[00:00] <jnthn> diakopter: same ;-)

[00:00] * jnthn wonders off to bed

[00:00] <diakopter> \

[00:00] <supernovus> night jnthn!

[00:03] *** replore_ joined
[00:04] <sorear> TimToady: What should be the result of my $x = 'a'; $x ~= $x for ^1024; say $x.chars?

[00:04] <sorear> TimToady: I see options 1. dies in loop 2. dies at 'chars' 3. Inf 4. 2**1024

[00:04] *** ZapZ joined
[00:05] *** tokuhirom left
[00:05] *** wolfman2000__ joined
[00:08] *** jferrero joined
[00:08] *** wolfman2000_ left
[00:12] <supernovus> Okay, I sent a "pull request" for those changes to IO::Socket::INET. Now to see why recv() isn't working as it previously did.

[00:14] *** patspam left
[00:17] <TimToady> sorear: well, it depends on if you have enough memory ;)

[00:17] <TimToady> you might need to run it on the simulator that runs the multiverse

[00:18] <diakopter> I posit option 0: the compiler's optimizer recognizes the overrun

[00:20] <TimToady> I think option 1 is most likely even with most lazy rope implementations

[00:21] <TimToady> diakopter: I suspect an optimizer that smart would generally use up more electrons than it was worth for typical Perl code

[00:25] <colomon> hmmm.  I guess I'd be very surprised if $x ~= $x for ^1024 were lazy.  I mean, $x =. push: 

[00:25] <colomon> argh

[00:26] <colomon> $x .= push($_) for ^1024 isn't excepted to be lazy, is it?  (is what I meant with the second bit there.)

[00:26] <colomon> afk # putting H to bed

[00:32] <supernovus> Okay, now if it wasn't weird enough, by changing recv() to get(), I can now send requests properly when telnetting to the port, but requests from Apache still aren't received until apache times out. Ah, the fun of socket stuff :-)

[00:34] <supernovus> I'm calling it a night. Have a good * #perl6!

[00:35] *** supernovus left
[00:39] *** lestrrat joined
[00:42] <sorear> TimToady: my ropes are not lazy, but they require O(log min(a,b)) time for appends

[00:42] <sorear> TimToady: so for a sequence of N doublings, total time is O(N^2), and so is total allocations

[00:43] *** wolfman2000__ left
[00:43] <sorear> option 1 would be implemented by adding extra code to the ~ operator to check if the logical string length has exceeded (u)int.MaxValue

[00:43] <sorear> option 2 would be implemented by adding extra code to .chars to detect overflow and throw

[00:43] <sorear> option 4 requires bignums in the internal nodes

[00:44] <sorear> #3 is probably easiest

[00:44] <sorear> actually the order of difficulty is probably #4 > #2 = #3 > #1

[00:47] *** uasi joined
[00:47] <TimToady> I suspect 2^64 positions in a string will be sufficient for some time yet

[00:47] <TimToady> so forget 4 :)

[00:48] <sorear> heh.  ok.

[00:48] <TimToady> well, depending on your bignum implementation...

[00:48] <sorear> I wonder if what I'm doing technically counts as a "rope"

[00:48] <TimToady> an implementation that steals pointer bits for ints could be very efficient :)

[00:49] <TimToady> (memory-wise)

[00:49] <sorear> I'm using a structure much closer to Hinze & Patterson's 2-3 finger trees, than to Boehm et al's 197x original

[00:49] <sorear> because it has much better bounds for many operations

[00:49] <sorear> like O(log n) worst case appends and O(1) amortized single-character appends

[00:49] <TimToady> I always invent my own data structures anyway, so don't ask me :)

[00:51] <TimToady> and I'm actually fine with any of those results...

[00:52] *** patspam joined
[00:53] *** patspam left
[00:53] *** whiteknight left
[00:54] <TimToady> as long as strings are relatively fast at representing everything from names to genomes

[00:55] *** Moukeddar joined
[00:55] *** Moukeddar left
[00:56] <cognominal> welcome to Gattaca :)

[00:57] <TimToady> TTAGGG &

[01:05] *** patspam joined
[01:06] *** whiteknight joined
[01:14] *** wolfman2000 joined
[01:19] *** Sarten-X joined
[01:23] *** JimmyZ joined
[01:28] <[Coke]> tadzik: the ping about the smolder server.

[01:39] *** thou left
[01:44] *** supernovus joined
[01:45] *** whiteknight left
[01:49] <supernovus> So, I think I know why my changes to IO::Socket::INET may not be working entirely right. The $.family, $.proto and $.type aren't being initialized in the new object, so when it builds its internal $!PIO, it doesn't have the same settings. I'm thinking someone more familiar with core work, NQP and the parrot socket library should probably take this one over. :/

[01:58] *** mkramer1 joined
[02:04] *** supernovus left
[02:05] *** patspam left
[02:38] *** JimmyZ left
[02:43] <sorear> jnthn: ping

[02:46] <sorear> jnthn: I am wanting to provide any necessary design assistance for the new NQP#

[03:03] *** frhodes joined
[03:03] <sorear> colomon: ping too

[03:03] *** frhodes left
[03:03] <colomon> sorear: I'm about to head to bed, but I can spare a couple of minutes.  what's up?

[03:04] <sorear> I have become aware of your mail

[03:04] <colomon> ah

[03:04] <sorear> 1, why does it make a difference where the complex trig logic is?

[03:04] <sorear> 2, I'd be interested in switching to code generation for all the little operator functions

[03:06] *** envi joined
[03:10] <colomon> 1. It's mostly a matter of simplicity / consistency.  For instance, tan($z) is most easily defined as sin($z) / cos($z).  That's easy to do at the Perl 6 level (as Rakudo does it), and it's easy to do at the C# level (as I'm proposing Niecza might).  But it's tricky to do in a mixed setting, as tan(Variable) cannot easily call sin(Variable) and cos(Variable).  (Or maybe it can and I just don't see how?)

[03:11] <colomon> also, based on a quick, very naive analysis it seems like doing it entirely in C# should be faster?

[03:11] <colomon> 2. Yeah, code generation can be very nice for that sort of repetitive code.

[03:19] <colomon> afk # off to bed

[03:20] *** sftp joined
[03:20] <sorear> phenny: tell colomon +1 to doing it all at the C# level.

[03:20] <phenny> sorear: I'll pass that on when colomon is around.

[03:44] *** daniel-s left
[03:44] * TimToady is starting to think that an object may only have one write owner at a time, and the purpose of an rw parameter is to change ownership temporarily

[03:45] <TimToady> this would prevent both upstack and downstack write violations

[03:46] <TimToady> this also resonates with the notion that an object may be owned only be one thread at a time

[03:47] <TimToady> s/only be/by only/

[03:49] <TimToady> and it would be extra bookkeeping only for rw binding and write operations

[03:49] <TimToady> (plus memory overhead of tracking current owner)

[03:54] *** matt3black joined
[03:55] <TimToady> also, it would not really need to be strict identity; N random bits is sufficient to reduce the chance of of not catching a write violations to 1 in 2^N, with less chance if the task is repeated with different random ids

[03:56] *** satyavvd joined
[04:02] *** birdwindupbird joined
[04:02] <TimToady> bbl &

[04:04] *** kaare_ joined
[04:15] *** matt3black left
[04:45] *** daniel-s joined
[05:07] *** sftp left
[05:19] *** koban` joined
[05:19] *** koban` left
[05:20] *** packetknife joined
[05:23] *** Shozan joined
[05:28] *** jevin joined
[05:43] *** woosley joined
[05:45] *** MayDaniel joined
[05:54] *** packetknife left
[05:58] *** packetknife joined
[06:10] *** orafu joined
[06:11] *** MayDaniel left
[06:16] *** alvis left
[06:19] *** cognominal_ joined
[06:19] *** REPLeffect joined
[06:30] *** alvis joined
[06:52] *** hanekomu joined
[07:04] *** frhodes joined
[07:22] *** skangas joined
[07:26] *** mj41 joined
[07:30] *** wtw joined
[07:37] *** pjcj joined
[07:42] *** pnu joined
[07:43] *** packetknife left
[07:47] *** kaare_ left
[07:48] *** replore__ joined
[07:48] *** replore_ left
[07:51] <moritz> good morning, #perl6

[07:53] *** wamba joined
[07:55] <Shozan> happy programmer's day!

[07:56] <moritz> \o/

[07:59] <snarkyboojum> that's awesome - wish we had a Programmers' Day :)

[08:06] <snarkyboojum> informal or no :)

[08:08] *** masak joined
[08:08] <masak> Perl 6 Day! \o/

[08:09] <moritz> rakudo: say (1, 6, 36 ... * <= 256)[*-1

[08:09] <p6eval> rakudo bb2a5a: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 1␤»

[08:09] <moritz> rakudo: say (1, 6, 36 ... * <= 256)[*-1]

[08:09] <p6eval> rakudo bb2a5a: OUTPUT«1␤»

[08:09] <moritz> rakudo: say (1, 6, 36 ... * <= 365)[*-1]

[08:09] <p6eval> rakudo bb2a5a: OUTPUT«1␤»

[08:09] <moritz> rakudo: say (1, 6, 36 ... * <= 365)

[08:09] <p6eval> rakudo bb2a5a: OUTPUT«1␤»

[08:10] <masak> the criterion is backwards, innit?

[08:10] <moritz> right

[08:10] <moritz> rakudo: say (1, 6, 36 ...^ * > 365)[*-1]

[08:10] <p6eval> rakudo bb2a5a: OUTPUT«216␤»

[08:10] <moritz> that should be programmer's day :-)

[08:10] <moritz> erm, Perl 6 programmer's day

[08:11] <moritz> b: say Date.new('2011-01-01') + 215

[08:11] <p6eval> b 1b7dd1: OUTPUT«2011-08-04␤»

[08:11] *** wamba left
[08:12] *** ranguard joined
[08:12] *** orafu left
[08:13] *** orafu joined
[08:13] *** satyavvd left
[08:15] *** Alias joined
[08:15] <masak> moritz: but I'm a Perl 6 programmer every day :P

[08:16] <moritz> masak: congratulations. There are still days where I find my self doubting very much if I'm a Perl 6 programmer

[08:16] <moritz> because I feel I have a misunderstanding of some very fundamental language feature

[08:17] <masak> I didn't say I was a *good* Perl 6 programmer.

[08:17] <masak> In fact, I know I am not one.

[08:18] <masak> my code keeps getting new bugs without me changing it.

[08:19] *** wamba joined
[08:22] <jnthn> *yawn*

[08:22] <jnthn> morning, #perl6

[08:22] <moritz> good morning jnthn 

[08:23] * jnthn finds himself only mildly pleased to be concious again "so soon" after going to bed...

[08:23] <masak> good Mornington, #jnthn

[08:24] <masak> er, jnthn*

[08:24] *** alvis left
[08:24] * masak .oO( The #jnthn channel )

[08:24] <jnthn> oh my, what on earth would be discussed there?

[08:24] <jnthn> er, actually, don't answer that :P

[08:25] <masak> beer!

[08:25] <masak> Slavic languages!

[08:25] <masak> metaobject protocols!

[08:25] <moritz> jnthn!

[08:25] <masak> pun!

[08:25] *** daxim joined
[08:25] <masak> puns*

[08:25] <masak> actually, that sounds like an awesome channel.

[08:26] *** dakkar joined
[08:26] <masak> all day, discussing MOP examples using Slavic beer-named variables, making subtle wordplays about it all.

[08:26] <moritz> ... in multiple languages, of course

[08:27] <masak> it sounds like #perl6...

[08:28] * masak is reminded of the scene in "Being John Malkovich" where Malkovich has gone into the portal

[08:30] <masak> http://www.youtube.com/watch?v=xX9MtuqVrUQ

[08:35] <moritz> nom: say Iterable.method(:local)

[08:35] <p6eval> nom bb2a5a: OUTPUT«Method 'method' not found for invocant of class 'Iterable'␤  in <anon> at /tmp/meFzebBoRK:1␤  in <anon> at /tmp/meFzebBoRK:1␤␤»

[08:35] <moritz> nom: say Iterable.^methods(:local)

[08:35] <p6eval> nom bb2a5a: OUTPUT«elems infinite item fmt Int Num Numeric Str␤»

[08:36] <moritz> oh, my local copy was out of date

[08:37] <masak> jnthn: did you write a spectest for Iterable.fmt?

[08:37] *** kaare_ joined
[08:38] <moritz> nom: say (1.3, 3.5, 3).fmt('%d', '_')

[08:38] <p6eval> nom bb2a5a: OUTPUT«Too many positional parameters passed; got 3 but expected between 1 and 2␤  in method fmt at src/gen/CORE.setting:1413␤  in <anon> at /tmp/7xv7t_jGKa:1␤  in <anon> at /tmp/7xv7t_jGKa:1␤␤»

[08:38] <moritz> that too should work

[08:38] <moritz> nom: say List ~~ Iterable

[08:38] <p6eval> nom bb2a5a: OUTPUT«Bool::True␤»

[08:38] <masak> b: say (1.3, 3.5, 3).fmt('%d', '_')

[08:38] <p6eval> b 1b7dd1: OUTPUT«1_3_3␤»

[08:39] * masak submits rakudobug

[08:39] <moritz> (there's a failing spectest for that)

[08:39] <masak> nom: say (1.3, 3.5, 3).WHAT

[08:39] <moritz> nom: say (1.3, 3.5, 3).list.fmt('%d', '_')

[08:39] <p6eval> nom bb2a5a: OUTPUT«Parcel()␤»

[08:39] <p6eval> nom bb2a5a: OUTPUT«1_3_3␤»

[08:39] <masak> nom: say (1.3, 3.5, 3).^mro

[08:39] <p6eval> nom bb2a5a: OUTPUT«Parcel() Cool() Any() Mu()␤»

[08:40] * moritz wonders why Parcel !~~ Iterable

[08:40] <moritz> that causes lots of code duplication or redispatches in Parcel.pm

[08:40] <moritz> will ask pmichaud++ when he appears

[08:41] *** alvis joined
[08:42] *** hanekomu left
[08:46] *** koban` joined
[08:46] *** koban` left
[08:48] <jnthn> masak: No. There's an RT ticket for it, so I figured somebody else would make sure of that before closing it.

[08:50] <moritz> masak: fwiw fmt.t has lots of rakudo skips (most of them LHF to implement, no doubt)

[08:50] <masak> jnthn: ah, ok.

[08:50] <moritz> you *can* turn them all into tickets, but I'd doubt the utility of that approach

[08:50] <masak> me too.

[08:52] <masak> my criterion for submitting RT tickets is something like "someone wants it". skipped spectests are slightly below that level.

[08:53] <dalek> rakudo/nom: ecce797 | moritz++ | src/core/Parcel.pm:

[08:53] <dalek> rakudo/nom: Parcel.fmt

[08:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ecce7977ad

[08:54] <dalek> roast: faa58d4 | moritz++ | S02-names_and_variables/fmt.t:

[08:54] <dalek> roast: test Range.fmt, unfudge Parcel.fmt tests

[08:54] <dalek> roast: review: https://github.com/perl6/roast/commit/faa58d4e2b

[08:59] <jnthn> sorear: (NQP# ;)) Great! :-) There's a bunch of things I'd like to ask at some point soonish (CPS vs stack reconstruction, efficient invocation, etc.)

[09:06] *** alvis left
[09:10] *** wamba left
[09:13] *** daniel-s left
[09:14] <pnu> http://goo.gl/8uKyk - (apparent) location of current #perl6 channel users

[09:15] <moritz> pnu++

[09:16] <pnu> moritz: unfotrunately it's p5, not six..

[09:16] <moritz> I'm not really surprised that it's lots of US and EU folks, just that there are so many in Europe

[09:17] * moritz finds it amusing that szabgab is on the equator in the Atlantic Ocean :-)

[09:18] <moritz> ah, might be (0, 0) for "no data obtained" or so

[09:18] <pnu> yes, well that's what lookup.geo.opera.com gives for his ip..

[09:18] <jnthn> Nice :)

[09:19] <pnu> 26 users didn't report ip address.. those are not shown but present in the kml (visibility hidden).

[09:20] <moritz> it might also make sense to filter out those with the 'voice' flag

[09:20] <moritz> (bots)

[09:23] <pnu> i added the (p5) code and source data i used to the same gist.. https://gist.github.com/1213459

[09:23] <pnu> mortiz: true..

[09:23] *** alvis joined
[09:23] <masak> wow, pnu++!

[09:23] <pnu> moritz: *

[09:24] <TiMBuS> haha wow. i live in victoria.

[09:24] <TiMBuS> but victoria, australia. not victoria, canada

[09:24] <TiMBuS> close though!

[09:24] <moritz> lol

[09:27] <moritz> b: say (a => 1).fmt('%s:%s')

[09:27] <p6eval> b 1b7dd1: OUTPUT«a:1␤»

[09:27] <moritz> b: say (a => 1).fmt('%s', '%s')

[09:27] <p6eval> b 1b7dd1: OUTPUT«Too many positional parameters passed; got 3 but expected between 1 and 2␤  in 'Enum::fmt' at line 5610:src/gen/core.pm␤  in main program body at line 22:/tmp/MPbUoIwfXU␤»

[09:28] <TiMBuS> also laughed at where szabgab is located

[09:28] <TiMBuS> maybe we should send a rescue boat...

[09:28] <masak> no, he's managed until now.

[09:28] <masak> he'll let us know if he needs rescuing.

[09:29] <bbkr> good localime() perl6

[09:29] <masak> bbkr++!

[09:29] <moritz> can't be so bad as long as his IRC is still working :-)

[09:29] <masak> right, exactly.

[09:30] *** dakkar left
[09:30] *** replore__ left
[09:37] *** daemon left
[09:37] *** shachaf left
[09:38] *** takesako joined
[09:38] *** Util joined
[09:38] *** szbalint joined
[09:38] *** ingy joined
[09:38] *** odoacre joined
[09:38] *** dukeleto joined
[09:38] *** itz joined
[09:38] *** s1n1 joined
[09:38] *** senobmeht joined
[09:38] *** mattp_ joined
[09:38] *** daemon joined
[09:38] *** shachaf joined
[09:39] *** dakkar joined
[09:39] <dalek> rakudo/nom: d97997e | moritz++ | src/core/Enum (2 files):

[09:39] <dalek> rakudo/nom: implement .fmt in Enum and EnumMap

[09:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d97997ed5c

[09:40] <dalek> roast: c70a045 | moritz++ | S02-names_and_variables/fmt.t:

[09:40] <dalek> roast: rakudo unfudges (fmt)

[09:40] <dalek> roast: review: https://github.com/perl6/roast/commit/c70a045066

[09:51] *** satyavvd joined
[09:51] *** satyavvd left
[09:52] *** satyavvd joined
[09:54] *** Alias_ joined
[09:57] *** Alias left
[10:06] *** daniel-s joined
[10:06] *** mj41 left
[10:07] *** frhodes left
[10:16] *** static_perl joined
[10:18] *** replore joined
[10:26] <masak> grrr. I still hate how array parameter binding works.

[10:27] <jnthn> How so?

[10:27] <masak> you take a named parameter :@a. you pass it on as a named arguemnt :@a to some constructor.

[10:27] <masak> suddenly you have another layer of array.

[10:27] <masak> scalars don't work like that. hashes don't work like that. but arrays do.

[10:27] <masak> yes, I've been upset about this before.

[10:28] <jnthn> nom: class Foo { has @.a }; my @a = 1,2,3; Foo.new(:@a).a.perl.say

[10:28] <p6eval> nom d97997: OUTPUT«Array.new(1, 2, 3)␤»

[10:28] <jnthn> nom: class Foo { has @.a }; my @a = 1,2,3; Foo.new(:@a).a.elems.say

[10:28] <p6eval> nom d97997: OUTPUT«3␤»

[10:29] <jnthn> masak: What am I missing?

[10:30] <masak> jnthn: I... I've changed my mind. it's a bug in Niecza.

[10:30] <masak> rakudo++

[10:30] <masak> perl6: sub foo(:@a) { say @a.elems }; foo

[10:30] <p6eval> niecza v9-23-g1a8efca: OUTPUT«1␤»

[10:30] <p6eval> ..pugs, rakudo d97997: OUTPUT«0␤»

[10:30] <masak> sorear: ^^

[10:31] * masak submits nieczabug

[10:31] *** replore left
[10:31] <jnthn> :P

[10:32] <bbkr> I cannot find that spec forbids many multi subs with the same signature: https://rt.perl.org/rt3/Ticket/Display.html?id=71536 - is this ticket still under discussion or should it be rejected?

[10:34] <masak> bbkr: it's probably not spec, no. but I think it's common sense.

[10:34] <masak> I invoke "things that can be caught at compile-time, should be"

[10:35] <jnthn> If the spec doesn't say we must, then it's not a bug.

[10:35] <jnthn> It's a worthwhile feature request though.

[10:35] <jnthn> So, it shouldn't have the bug tag.

[10:35] <jnthn> But it's an OK ticket.

[10:36] <jnthn> Perhaps one of those things the optimizer can spot.

[10:36] <jnthn> Or maybe we do it at czech time

[10:38] * masak removes the [BUG] tag

[10:41] <bbkr> I agree with moritz here - having multis with the same name and signature is perfectly fine. That can be used in any plugin implementation, for example "role Twiitter { multi method broadcast( Str) {} }; role Facebook { multi method broadcast (Str) {} }; class Social does Twitter does Facebook {}". compile error in this case is harmful.

[10:43] <benabik> bbkr: You expect it to invoke both?

[10:43] <jnthn> bbkr: It's important to distinguish multi methods and multi subs here.

[10:44] <jnthn> bbkr: The multi method case is potentially useful. The multi sub case can almost certianly never actually work

[10:44] <jnthn> benabik: .*/.+ dispatchers probably would

[10:44] <bbkr> yes, i expect both methods to be invoked if signature and name matches.

[10:45] <jnthn> bbkr: *only* if you used .+ or .* to ask for that.

[10:45] <jnthn> bbkr: Otherwise it's an ambiguous dispatch.

[10:47] <masak> it's an interesting use case. but yes, the ticket was about multi subs.

[10:47] <bbkr> jnthn: ticket was about signatures in general. you're right about subs. but for methods I should be able to define multis like in my example, and it should throw "ambigous dispatch" for .

[10:47] <bbkr> but not for .*

[10:48] <jnthn> bbkr: Yes, we're only suggesting compile time detection for multi subs, not multi methods.

[10:49] <masak> perl6: sub foo(:@a) { say @a[0]; say "alive" }; foo(:a["bar"])

[10:49] <bbkr> ok, maybe it should be explicitly mentioned in ticket subject just for clarification?

[10:49] <p6eval> pugs, rakudo d97997, niecza v9-23-g1a8efca: OUTPUT«bar␤alive␤»

[10:49] <masak> perl6: sub foo(:@a) { say @a[0]; say "alive" }; foo(:a("bar"))

[10:49] <p6eval> rakudo d97997: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Str instead␤  in sub foo at /tmp/an_6FTpM6d:1␤  in <anon> at /tmp/an_6FTpM6d:1␤  in <anon> at /tmp/an_6FTpM6d:1␤␤»

[10:49] <p6eval> ..niecza v9-23-g1a8efca: OUTPUT«(timeout)»

[10:49] <p6eval> ..pugs: OUTPUT«bar␤alive␤»

[10:49] <masak> sorear: ^^

[10:50] * masak submits nieczabug

[10:50] <masak> bbkr: yes, that's probably a good idea.

[10:52] <bbkr> changed

[10:54] * masak <== @lunch

[10:55] *** mj41 joined
[11:04] *** benabik left
[11:06] *** wamba joined
[11:16] *** uasi left
[11:38] *** benabik joined
[11:40] *** Psyche^ joined
[11:40] *** Psyche^ is now known as Patterner

[11:46] <tadzik> yay, physics passed! \o/

[11:46] <jnthn> tadzik++

[11:47] <tadzik> today's a good day

[11:47] <moritz> \o/

[11:47] <moritz> tadzik.physics++

[11:48] *** wamba left
[11:48] <tadzik> tadzik.physics.make_immutable

[11:48] <tadzik> aaaaand we're done here :P

[11:51] <masak> :P

[12:00] *** woosley left
[12:04] *** cognominal_ left
[12:04] *** cognominal_ joined
[12:15] *** wamba joined
[12:16] *** dalek joined
[12:16] *** ChanServ sets mode: +v dalek

[12:18] *** aindilis joined
[12:31] <colomon> tadzik++

[12:31] <phenny> colomon: 03:20Z <sorear> tell colomon +1 to doing it all at the C# level.

[12:33] <bbkr> nom: say 1.+WHAT # should this be allowed?

[12:33] <p6eval> nom d97997: OUTPUT«===SORRY!===␤Cannot use .+ on a non-identifier method call at line 1, near " # should "␤»

[12:33] *** bluescreen10 joined
[12:33] <jnthn> bbkr: .WHAT is a macro, not a method call

[12:33] <moritz> not sure; .WHAT is a macro, not an ordinary methods

[12:33] <moritz> s/s$//

[12:33] <jnthn> So at best it'd compile, but explode at runtime

[12:33] <jnthn> (method WHAT not found)

[12:34] <bbkr> ok, so this behaves correctly now, right? https://rt.perl.org/rt3/Ticket/Display.html?id=72818

[12:34] <jnthn> The error ain't so helpful

[12:34] <jnthn> The ticket is wrong though

[12:35] <jnthn> It thinks .WHAT is a method call. :)

[12:36] <bbkr> jnthn: that's why i'm asking to confirm it. it's an old ticket.

[12:36] <jnthn> nom: class A { method m { say 1 } }; class B is A { method m { say 2 } }; B.+m; B.*m;

[12:36] <p6eval> nom d97997: OUTPUT«2␤1␤2␤1␤»

[12:36] <jnthn> Looks like .* and .+ work just fine on actual methods.

[12:36] <jnthn> So +1 to close.

[12:36] <jnthn> With a note that WHAT isn't a method call.

[12:37] <bbkr> jnthn: which file should I put tests in? i'm not sure if those belongs more to macros or to multi dispatch

[12:37] <bbkr> s/those/it/

[12:37] <jnthn> bbkr: There already are a bunch of tests for .+ and .*

[12:37] <jnthn> calling_sets.t or something.

[12:38] <moritz> S12-methods/calling_sets.t

[12:38] <tadzik> nice users map

[12:38] <tadzik> I'd like to see one which lists only the users who said something during the last year or so :)

[12:40] <moritz> tadzik: do you want the user list?

[12:40] <bbkr> i've checked calling_sets.t and there is no test which checks "dies_ok {$foo.*MACRO }", IMO worth adding

[12:41] <jnthn> bbkr: OK, +1

[12:41] <jnthn> bbkr: But it's actually a compile time error

[12:41] <jnthn> So it'd need eval_dies_ok orso

[12:42] <tadzik> moritz: that'd be cool, yes

[12:42] <moritz> tadzik: I'll generate a list of all nicks that spoke in #perl6 this year, should be good enough for that purpose

[12:43] <tadzik> moritz: thanks

[12:43] <moritz> tadzik: http://moritz.faui2k3.org/tmp/active_perl6_nicks.txt

[12:43] <tadzik> whoa, that was fast

[12:44] <tadzik> the starred ones are the ones who spoke?

[12:44] <moritz> tadzik: note that it contains "* $nick" for an action that $nick performed

[12:44] <moritz> so you can grep 'em out

[12:44] <tadzik> oh, explains a lot

[12:44] *** donri joined
[12:44] <tadzik> huh, there are more of them than on the map

[12:45] <tadzik> curl http://moritz.faui2k3.org/tmp/active_perl6_nicks.txt | wcl says '930'

[12:45] <moritz> tadzik: the map was from a snapshot, iiuc

[12:45] <tadzik> oh, ok

[12:45] *** satyavvd left
[12:45] <moritz> tadzik: and at any given time there are < 200 nicks in here, but over the year a lot more assemble

[12:45] <tadzik> that's interesting

[12:46] <tadzik> ok, I'll give it a try in some near time

[12:46] <benabik> 774 once I filter out dups.

[12:47] <tadzik> I'd rather grep out those from the original list that do not appear on the activity list

[12:47] <moritz> that's probably the better approach

[12:47] <benabik> (dups from actions, to be specific)

[12:47] <benabik> There are a fair number of nick and nick_ "dups" as well.

[12:48] <tadzik> yeah, /tadzik/ appears 5 times :)

[12:49] *** wamba left
[12:49] <jnthn> Probably easy to regex away the ogonky though :)

[12:49] <moritz> mysql knows nothing of identity, just of string comparison

[12:50] <benabik> A few minutes of work could probably deal with the easy duplications.

[12:50] <benabik> If anyone really cared.  (I don't.)

[12:50] *** satyavvd joined
[12:51] <moritz> no deduplication necessary, when the list is ony used to filter the nicks in the map

[12:53] <tadzik> jnthn: ogonki :0

[12:53] <benabik> The %:s/^* // dedup might be handy.  :-D

[12:53] <tadzik> :)

[12:54] <jnthn> tadzik: oops, Slovak spelling ;)

[12:54] <moritz> perl -pe 's/^\* //' < nicks.txt | sort -u

[12:55] <benabik> moritz: You can spell it that way too.  I had opened it in vim.  :-D

[12:58] *** JimmyZ joined
[13:03] <bbkr> masak: what is the expected behavior in https://rt.perl.org/rt3/Ticket/Display.html?id=72820 ? 

[13:04] <moritz> std: &1

[13:04] <p6eval> std bb4f150: OUTPUT«ok 00:01 121m␤»

[13:05] *** satyavvd left
[13:05] <moritz> std: &foo

[13:05] <p6eval> std bb4f150: OUTPUT«ok 00:01 121m␤»

[13:06] <benabik> &1?  What's that mean?  Does that return something like `-> { return 1 }`?

[13:06] <moritz> why doesn't that produce the same error as foo() ?

[13:06] <moritz> benabik: &foo returns a reference to the routine named 'foo'

[13:06] <benabik> moritz: Right.  But I'm confused about it working on a number.

[13:06] <moritz> benabik: so &1 would be a reference to a routine named '1'

[13:07] <moritz> benabik: and I'm confused about it not being a compile time lookup

[13:07] <benabik> std: sub 1 { … }

[13:07] <p6eval> std bb4f150: OUTPUT«===SORRY!===␤Malformed block at /tmp/SBxx_WovI3 line 1:␤------> sub ⏏1 { … }␤    expecting any of:␤    name␤   routine_def␤    trait␤Parse failed␤FAILED 00:01 117m␤»

[13:07] <bbkr> you cannot name routine '1'

[13:07] <benabik> std: sub 1 { ... }

[13:07] <p6eval> std bb4f150: OUTPUT«===SORRY!===␤Malformed block at /tmp/_zoQ8AtasP line 1:␤------> sub ⏏1 { ... }␤    expecting any of:␤  name␤   routine_def␤    trait␤Parse failed␤FAILED 00:01 117m␤»

[13:07] <moritz> nom: Q:PIR { .lex '&1' }; say &1

[13:07] <p6eval> nom d97997: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:syntax error, unexpected '\n', expecting COMMA␤    in file '(file unknown)' line 841␤␤»

[13:07] <benabik> std: sub '1' { ... }

[13:07] <p6eval> std bb4f150: OUTPUT«===SORRY!===␤Malformed block at /tmp/U_Hs6qOCtu line 1:␤------> sub ⏏'1' { ... }␤    expecting any of:␤        name␤   routine_def␤    trait␤Parse failed␤FAILED 00:01 117m␤»

[13:08] <jnthn> std: @1

[13:08] <p6eval> std bb4f150: OUTPUT«ok 00:01 118m␤»

[13:08] <benabik> moritz: The syntax for .lex is .lex <variable name> <register>

[13:08] <daxim> has anyone already written working shapely/eyedrops style P6 programs?   http://code.google.com/codejam/japan/tshirt.html

[13:08] <moritz> nom: Q:PIR { .lex '&1' $P0 }; say &1

[13:08] <p6eval> nom d97997: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:syntax error, unexpected PREG, expecting COMMA ('$P0')␤    in file '(file unknown)' line 137␤␤»

[13:08] <jnthn> moritz: I think it may be parsed as an accidental side-effect of parsing $1, etc

[13:08] <moritz> jnthn: sounds plausible-ish

[13:09] <jnthn> nom: "foo" ~~ /(f)/; say $0

[13:09] <p6eval> nom d97997: OUTPUT«f␤»

[13:09] <jnthn> nom: "foo" ~~ /(f)/; say @0

[13:09] <p6eval> nom d97997: OUTPUT«f␤»

[13:09] <jnthn> nom: "foo" ~~ /(f)/; say &0

[13:09] <p6eval> nom d97997: OUTPUT«f␤»

[13:09] <jnthn> heh :)

[13:09] * moritz did that, probably

[13:09] <moritz> jnthn++

[13:09] <jnthn> b: "foo" ~~ /(f)/; say &0

[13:09] <bbkr> so this ticket should be rejected as not a bug?

[13:09] <p6eval> b 1b7dd1: OUTPUT«f␤»

[13:09] <jnthn> moritz: I think we may have always had it like that, just never realized ;)

[13:09] <moritz> ok, I just reused it :-)

[13:09] <jnthn> .oO( let's call it a feature ;-) )

[13:11] <jnthn> Guess a [ <?{ $<sigil> eq '$'}> <.panic: '...'> ] or so in the right place would catch it though.

[13:12] <moritz> of course it's a nice obfu

[13:12] <benabik> "Nice obfu" is not a good reason to keep it in the language.

[13:12] <moritz> and @0 even makes sense, if the capture 0 is quantified

[13:12] <moritz> benabik: not? :-)

[13:13] <bbkr> i'll copy-paste this discussion to ticket and leave it open

[13:13] <benabik> moritz: :-P

[13:14] *** colomon joined
[13:16] *** pernatiy joined
[13:18] *** tzhs joined
[13:20] *** clairvy joined
[13:21] *** mjreed joined
[13:21] *** wolfman2000 left
[13:24] <mls> good afternoon!

[13:26] <bbkr> nom: Int.() # parse bug? despite doing nothing useful it should be parsed as Int(), right?

[13:26] <p6eval> nom d97997: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Int'␤  in <anon> at src/gen/Metamodel.pm:3023␤  in <anon> at /tmp/8_3SpbH8XF:1␤  in <anon> at /tmp/8_3SpbH8XF:1␤  in <anon> at /tmp/8_3SpbH8XF:1␤␤»

[13:26] <moritz> good pm, mls

[13:28] <jnthn> o/ mls

[13:28] <mjreed> Query: given a string $x, and an array @w containing a list of other strings, I want to test to see if every element of @w appears as a substring of $x.  Is there a cleaner way than this?              $x ~~ all( @w.map(-> $w { regex { $w } }) )

[13:29] <mls> about 50% of the perl6 startup time is spent in compose

[13:29] <jnthn> mls: That's not so surprising.

[13:29] <jnthn> mls: We do quite a lot of work in compose.

[13:30] <jnthn> mls: 50% is a bit more than I'd have expected; any hot-spots of worth knowing about.

[13:30] <jnthn> mls: But also see my blog post from yesterday on the serialization stuff

[13:30] <moritz> mjreed: I'm sure there's a more concise solution involving index()

[13:30] <jnthn> mls: Essentially, the problem will go away because we'll be serializing the composed objects.

[13:31] <mls> (compute_mro / c3_merge are the hotspots)

[13:31] <moritz> mjreed: so $x.index(all(@substrings)).defined

[13:31] <jnthn> mls: Really?

[13:31] <jnthn> mls: That's...a little surprising.

[13:31] <moritz> rakudo: my @s = <foo bar>; say so 'foobarbaz'.index(all @s).defined

[13:31] <p6eval> rakudo d97997: OUTPUT«Bool::True␤»

[13:32] <moritz> rakudo: my @s = <foo bak>; say so 'foobarbaz'.index(all @s).defined

[13:32] <p6eval> rakudo d97997: OUTPUT«Bool::True␤»

[13:32] <moritz> huh.

[13:32] <mls> shall I try to optimize them a bit?

[13:32] <moritz> rakudo: say 'foobarbaz'.index('bak')

[13:32] <p6eval> rakudo d97997: OUTPUT«Str()␤»

[13:32] <moritz> rakudo: say 'foobarbaz'.index('bak').defined

[13:32] <p6eval> rakudo d97997: OUTPUT«Bool::False␤»

[13:32] <mls> But, as you said, it's probably not worth it because of the serialization changes

[13:32] <jnthn> moritz: .defined won't auto-thread there.

[13:32] <moritz> jnthn: urks

[13:33] <benabik> The junction is defined.

[13:33] <jnthn> right

[13:33] <moritz> right

[13:33] <PerlJam> moritz: you could do it with a reductio op

[13:33] <PerlJam> er, reduction

[13:33] <moritz> I want a way to say that stuff should (or should not) autothread

[13:33] <moritz> PerlJam: the old imperative way, yes

[13:33] <jnthn> mls: Well, it is in so far as any program that we just compile and immediately run will have to do that.

[13:33] <benabik> rakudo: my @s = <foo bak>; say so 'foobarbaz'.index(all @s)>>.defined

[13:33] <p6eval> rakudo d97997: OUTPUT«Bool::False␤»

[13:34] <mls> ok, I'll have a look at the code...

[13:34] <benabik> rakudo: my @s = <foo bar>; say so 'foobarbaz'.index(all @s)>>.defined

[13:34] <p6eval> rakudo d97997: OUTPUT«Bool::True␤»

[13:34] <moritz> rakudo: my @s = <foo bak>; say [&&] @s.map({'foobarbaz'.index($_).defined})

[13:34] <p6eval> rakudo d97997: OUTPUT«Bool::False␤»

[13:34] <moritz> rakudo: my @s = <foo baz>; say [&&] @s.map({'foobarbaz'.index($_).defined})

[13:34] <p6eval> rakudo d97997: OUTPUT«Bool::True␤»

[13:35] <moritz> does >>. hyper descend into junctions?

[13:35] <jnthn> No

[13:35] <jnthn> Only into iterables.

[13:35] <mjreed> rakudo: my $x = "this is a cat"; my @w = <this cat>; say $x.index(all @w)>>.defined

[13:35] <moritz> when I don't see why benabik's solution should work

[13:35] <p6eval> rakudo d97997: OUTPUT«all(True, True)␤»

[13:35] <benabik> moritz: I wasn't sure if it would, but it appeared to.  *shrug*

[13:35] <jnthn> moritz: Yeah, I'm confused about that too... 

[13:36] <mjreed> hm.  2011.04 says "Method 'iterator' not found for invocant of class 'Integer' "

[13:36] <benabik> b: my @s = <foo bak>; say so 'foobarbaz'.index(all @s)>>.defined

[13:36] <p6eval> b 1b7dd1: OUTPUT«Method 'iterator' not found for invocant of class 'Integer'␤  in main program body at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[13:36] <PerlJam> perhaps the "randomization" that rakudo does accidentally listifies the junction

[13:36] <jnthn> moritz: My only guess is that HYPER causes it to autothread.

[13:36] <jnthn> Or something

[13:36] <PerlJam> (for >> I mean)

[13:37] <jnthn> Yeah...looks like something in the >>. implementation is declared with Any.

[13:38] <moritz> src/core/metaops.pm uses implicit Any all over the place

[13:38] *** shinobicl joined
[13:38] <jnthn> There we go then.

[13:39] <shinobicl> nom: my Int $number = 0 {where 0..23};

[13:39] <p6eval> nom d97997: OUTPUT«===SORRY!===␤Confused at line 1, near "my Int $nu"␤»

[13:39] * jnthn afk a bit...walk

[13:39] <benabik> It working is kinda handy, since it provides a way to force things like .defined to autothread.

[13:40] <PerlJam> benabik: except that it isn't really autothreading

[13:40] <moritz> shinobicl: there 'where' must be outside block, for suer

[13:40] <moritz> it's auto-hyper-threading :-)

[13:40] <shinobicl> nom: my Int $number = 0 where 0 .. 23;

[13:40] <p6eval> nom d97997: OUTPUT«===SORRY!===␤Confused at line 1, near "my Int $nu"␤»

[13:40] <shinobicl> nom: my Int $number = 0 where {0 .. 23};

[13:40] <moritz> nom: my Int $number where (0..23) = 0;

[13:41] <p6eval> nom d97997: OUTPUT«===SORRY!===␤Confused at line 1, near "my Int $nu"␤»

[13:41] <PerlJam> nom: my Int where 0..23 $number = 0;  # there, that's my permutation  :)

[13:41] <p6eval> nom d97997: OUTPUT«===SORRY!===␤In "my" declaration, typename Int must be predeclared (or marked as declarative with :: prefix) at line 1, near " where 0.."␤»

[13:42] <PerlJam> oh, that's interesting that it complains about Int

[13:42] *** bluescreen10 left
[13:45] <mjreed> I'm still back on the fact that defined() doesn't descend into junctions.  How is one meant to test for all-defined, any-defined, one-defined, etc?

[13:48] *** Shozan left
[13:53] <mjreed> I'm also kinda thinking that index called in Boolean context should maybe return true if the string is found and false otherwise, rather than just letting the index boolify and this yielding false for a prefix..

[13:53] <PerlJam> mjreed: I never have gotten it clear in my head what should/shouldn't autothread.   Autothreading is meant to be one of the great features of junctions, so I'd wish that *everything* autothread and  that there's be some syntactic marker that says "don't thread this operation"

[13:56] <mjreed> Sure.  But then you have trouble passing around junctions as junctions.  I seem to recall the spec has gone back and forth on this a couple times...

[13:57] <PerlJam> If you can wrap a junction in a non-junctional package, it becomes easy to pass around without invoking autothreading

[13:57] *** bluescreen10 joined
[13:58] *** daxim left
[13:59] *** daxim joined
[14:01] <masak> rakudo: sub contains($big, $small) { defined $big.index($small) }; my @bigs = <food foolish eufooria kungfoo>; say so contains all(@bigs), 'foo'

[14:01] <p6eval> rakudo d97997: OUTPUT«Bool::True␤»

[14:01] <masak> rakudo: sub contains($big, $small) { defined $big.index($small) }; my @bigs = <food foolish notthisone kungfoo>; say so contains all(@bigs), 'foo'

[14:01] <p6eval> rakudo d97997: OUTPUT«Bool::False␤»

[14:01] <masak> mjreed: almost like English!

[14:02] * masak considers writing a blog post called "Don't let the junction get away!"

[14:03] <mjreed> what's "so" doing there?

[14:03] <moritz> extra pionts for writing 'contains' as an infix

[14:03] <masak> collapsing the junction.

[14:03] <PerlJam> mjreed: emphasis ;)

[14:03] <moritz> mjreed: boolean context

[14:03] <masak> rakudo: sub contains($big, $small) { defined $big.index($small) }; my @bigs = <food foolish notthisone kungfoo>; say (contains all(@bigs), 'foo').perl

[14:03] <p6eval> rakudo d97997: OUTPUT«all(True, True, False, True)␤»

[14:03] <mjreed> synonym for ?  then?

[14:03] <masak> aye.

[14:03] <moritz> but with looser precedence

[14:04] <masak> like 'and' and '&&'.

[14:06] <jlaire> rakudo: sub infix:<contain>($big, $small) { defined $big.index($small) }; my @bigs = <food foolish eufooria kungfoo>; say so all(@bigs) contain 'foo'

[14:06] <p6eval> rakudo d97997: OUTPUT«===SORRY!===␤Confused at line 1, near "say so all"␤»

[14:07] <jlaire> b: sub infix:<contain>($big, $small) { defined $big.index($small) }; my @bigs = <food foolish eufooria kungfoo>; say so all(@bigs) contain 'foo'

[14:07] <p6eval> b 1b7dd1: OUTPUT«Bool::True␤»

[14:07] <moritz> jlaire++ # eufooria

[14:07] <jlaire> I just copied masak++ :P

[14:07] <jlaire> jlaire--

[14:08] <masak> jlaire++ # honest ;)

[14:08] *** mjreed left
[14:08] *** mjreed joined
[14:08] <moritz> masak++ then, and jlaire++ for the infix implementation

[14:09] <mjreed> er, I would still call it infix:<contains>, with singular inflection.  Won't always be called with all(). :)

[14:09] <masak> right.

[14:10] <PerlJam> or reverse the $big and $small and call it infix:<in>   :-)

[14:10] <mjreed> how pythonic!

[14:10] <masak> PerlJam: ∈

[14:10] <mjreed> 'contains' reads pretty well as a method call on $big, actually.

[14:10] <moritz> too general, if you ask me

[14:11] <moritz> 'contains' is a question you ask a Set, not a Str

[14:11] <masak> rakudo: use MONKEY_TYPING; augment class Cool { method contains($small) { defined self.index($small) } }; my @bigs = <food foolish eufooria kungfoo>; say so all(@bigs).contains('foo')

[14:11] <p6eval> rakudo d97997: OUTPUT«Bool::True␤»

[14:12] <masak> \o/

[14:12] <mjreed> Well, I'm not saying add it to core.  But as long as you're defining a 'contains', it works as a method call as well as an infix. 

[14:12] <jlaire> was the parse fail a nom bug or shouldn't it work in b, either?

[14:13] <masak> jlaire: I was surprised by it.

[14:14] *** wtw left
[14:17] <PerlJam> #p5p say the oddest things

[14:18] <jnthn> PerlJam: I'm sure we could compete quite well on oddness on #perl6, if we put our minds to it ;)

[14:18] <masak> news at 11!

[14:20] <PerlJam> jnthn: in reference to your 6guts mention of reviving the CLR backend for rakudo ... <@Nicholas> and workng Perl 6 on $anything might be subvertable to compile Perl 5

[14:20] <jnthn> ;)

[14:30] <arnsholt> jnthn: In re "Bounded Serialization", will that most likely live in NQP or Rakudo land?

[14:32] <mls> jnthn: compute_mro is missing to "trivial" case, i.e. +@immediate_parents == 1

[14:32] <jnthn> arnsholt: NQP for sure.

[14:33] *** sftp joined
[14:33] <shinobicl> hi: how do i define a constraint in a variable without using a subset?

[14:33] <jnthn> arnsholt: There's a bigger underlying plan that other languages built on NQP will be able to use this too.

[14:33] <arnsholt> Yeah, that's what I was hoping

[14:33] <jnthn> In general, instead of writing Compiler/Grammar/Actions, you'll write Compiler/Grammar/Actions/[other thingy we don't have a good name for yet]

[14:34] <jnthn> Where that thingy handles the "model" of the program, including objects that should exist runtime and compile time.

[14:34] <arnsholt> I've an on-again off-again relationship with a Prolog compiler, and to do things like assert and retract I probably want some kind proper serialisation facility

[14:34] *** uasi joined
[14:35] <arnsholt> My current approach is more a long the lines of "if all you've got is a hammer..."

[14:36] <jnthn> "...every problem looks like a PAST tree"

[14:36] <jnthn> :)

[14:36] <arnsholt> How'd you guess? =)

[14:37] <masak> because every problem *does* look like a PAST tree?

[14:37] <moritz> once you've parsed and action'ed it, yes

[14:37] *** mkramer1 left
[14:40] *** Trashlord joined
[14:42] *** thou joined
[14:44] *** thou left
[14:48] *** shinobicl left
[14:50] <masak> Unhandled exception: System.InvalidCastException: Cannot cast from source type to destination type.

[14:50] <masak> auuugh

[14:52] <PerlJam> masak: is that niecza's "Null PMC" ?

[14:52] <dalek> roast: 2eddda3 | moritz++ | S02-names_and_variables/fmt.t:

[14:52] <dalek> roast: refudge fmt.t for rakudo

[14:52] <dalek> roast: review: https://github.com/perl6/roast/commit/2eddda30be

[14:52] <moritz> nom: printf '%f', 5.6

[14:52] <p6eval> nom d97997: OUTPUT«5.600000»

[14:53] <jnthn> PerlJam: That'd be NullReferenceException

[14:53] <moritz> is that... expected? normal?

[14:53] <moritz> nom: printf '%15f', 5.6

[14:53] <p6eval> nom d97997: OUTPUT«       5.600000»

[14:53] <[Coke]> rakudo: so say "we all"

[14:53] <p6eval> rakudo d97997: OUTPUT«we all␤»

[14:53] <moritz> nom: printf '%015f', 5.6

[14:53] <p6eval> nom d97997: OUTPUT«00000005.600000»

[14:53] <moritz> nom: printf '%.15f', 5.6

[14:53] <p6eval> nom d97997: OUTPUT«5.600000000000000»

[14:53] <moritz> b: printf '%f', 5.6

[14:53] <p6eval> b 1b7dd1: OUTPUT«5.600000»

[14:53] <PerlJam> moritz: looks fairly normal to me.

[14:54] <moritz> PerlJam: some spectests expect that to be 5.6

[14:54] <masak> PerlJam: no, but I've gotten it twice in two days now, so I'm starting to dislike it.

[14:54] <moritz> $ perl -wE 'printf "%f\n", 5.6'

[14:54] <moritz> 5.600000

[14:54] * moritz wonders what's up with the tests

[14:55] <mjreed> $ printf "%f\n" 5.6

[14:55] <mjreed> 5.600000 

[14:55] <mjreed> even bash agrees.

[14:55] <[Coke]> is nom now also rakudo  on p6eval?

[14:56] <moritz> yes, they are aliases

[14:56] <PerlJam> rakudo: say "hi"

[14:56] <p6eval> rakudo d97997: OUTPUT«hi␤»

[14:56] <PerlJam> nom: say "hello"

[14:56] <p6eval> nom d97997: OUTPUT«hello␤»

[14:56] *** dukeleto left
[14:56] <mjreed> b: say "I'm getting too old for this."

[14:57] <p6eval> b 1b7dd1: OUTPUT«I'm getting too old for this.␤»

[14:57] *** dukeleto joined
[14:57] <[Coke]> p6devl: help!

[14:57] <[Coke]> p6eval: help

[14:57] <p6eval> [Coke]: Usage: <(nom|pugs|perlesque|nqprx|yapsi|alpha|highlight|partcl|nqpnet|star|mildew|nqp|niecza|std|rakudo|b)(?-xism::\s) $perl6_program>

[14:57] <masak> b: say "...but I still kick nom's butt in some regards"

[14:57] <p6eval> b 1b7dd1: OUTPUT«...but I still kick nom's butt in some regards␤»

[14:57] <[Coke]> Every time I do that, I'm surprised that partcl is in there. Every time.

[14:57] * PerlJam thought for a second that Coke was invoking a perl 6 devil

[14:57] <[Coke]> and there you are!

[14:57] <moritz> [Coke]: well, giving partcl a $perl6_program might not be too smart :-)

[14:58] <mjreed> I thought maybe p6devl forwarded to the perl6-dev mailing list. :)

[14:58] <moritz> our secret replacement for p6l

[14:58] <mjreed> formed by the perl6 cabal.

[14:58] <PerlJam> partcl: say hi

[14:58] <p6eval> partcl 3977a9: OUTPUT«invalid command name "say"␤    while executing␤HLL::Compiler::eval␤    (file "<unknown file>" line 151)␤PCT::HLLCompiler::evalfiles␤    (file "<unknown file>" <unknown line>)␤PCT::HLLCompiler::command_line␤    (file "<unknown file>" <unknown line>)␤main␤    (file "…

[14:59] <PerlJam> (just making sure ;)

[14:59] <[Coke]> partcl: puts hi

[14:59] <p6eval> partcl 3977a9: OUTPUT«hi␤»

[14:59] <moritz> formed by the Perl 6 kobold

[14:59] * masak shudders

[15:00] *** static_perl left
[15:00] <[Coke]> partcl: puts [expr sqrt(64)]

[15:00] <p6eval> partcl 3977a9: OUTPUT«Invalid expression␤    while executing␤expr␤    (file "<unknown file>" line 8)␤HLL::Compiler::eval␤    (file "<unknown file>" line 151)␤PCT::HLLCompiler::evalfiles␤    (file "<unknown file>" <unknown line>)␤PCT::HLLCompiler::command_line␤    (file "<unknown file>" …

[15:00] <[Coke]> now, that's odd. ah well.

[15:02] <moritz> masak: can you confirm my observation that backtraces wrongly contain the name of the current script even for routines executed from modules defined in other files?

[15:02] <masak> moritz: no, I haven't seen that.

[15:02] <masak> haven't been looking for it either.

[15:02] <masak> I try to rely on backtraces as little as possible.

[15:03] <moritz> why?

[15:03] *** thou joined
[15:03] <masak> because they're so *booooring*

[15:03] * [Coke] probably should not try to use JIRA web app shortcuts on every page he goes to. whoops.

[15:03] <masak> moritz: when I do the dishes, I use my fingers to feel the surface of plates and cutlery, to see if they're clean. when I code, I do something similar.

[15:04] <moritz> masak: you might need to come up with a module that makes backtraces more exciting

[15:04] <moritz> like, inluding animated ASCII art :-)

[15:04] <masak> moritz: backtraces are like dishwasher fluid. too strong, too broad, inhuman.

[15:05] <jnthn> ...and fairly useful when you're trying to reconstruct what just happened in code you wrote 2 years ago that failed. :)

[15:05] <masak> I'm not saying they're a bad thing.

[15:05] <masak> I'm saying I try to rely on them as little as I can.

[15:06] <TimToady> backtraces should be written in HTML5, ovbiously

[15:06] <TimToady> and I've always said they should probably go to disk by default, not the terminal

[15:06] <TimToady> or to a backtrace cacher of some sort

[15:06] <masak> +1

[15:07] <benabik> Someone wrote a terminal program for OS X that used HTML5…  It used JSON to communicate with "command line" apps running in it.  It looked odd.

[15:07] <[Coke]> like on OS X, TimToady ?

[15:07] <masak> especially in Niecza, they're too long.

[15:07] <masak> but nom is catching up, too.

[15:07] <jnthn> \o/

[15:07] <jnthn> oh, wait..

[15:07] <TimToady> [Coke]: how would I know anything about OS X?

[15:07] <jnthn> :P

[15:07] <[Coke]> TimToady: the same way I would know how you would know anything about OS X?

[15:08] <TimToady> did anyone see my speculations at http://irclog.perlgeek.de/perl6/2011-09-13#i_4419513

[15:08] <[Coke]> but, yes, OS X has a service that tracks dumps for you, so you have a central location to go through your (C) backtraces.

[15:08] * moritz also wondered if backtraces should be gone by default, and only the calling location should be present, much like p5

[15:09] <TimToady> I think they should *appear* to be gone, by default :)

[15:09] <masak> benabik: this one? http://acko.net/blog/on-termkit

[15:09] <[Coke]> I think by default, that's fine. I'd really like an easy way to turn on the full backtrace, though.

[15:09] <benabik> masak: Looks like.

[15:09] <masak> benabik: it's the closest I've come to wanting to leave the text-based CLI model.

[15:09] <moritz> TimToady: sure. The full information should always remain somewhere behind the curtain.

[15:09] <TimToady> [Coke]: I think you can turn it on retractively if it's been saved somewhere

[15:10] <moritz> or rerun with a command line switch

[15:10] <moritz> like currently perl6 --ll-excpetion

[15:10] <masak> benabik: I believe with slightly *less* eye candy -- or rather, something like a "feet still on the ground" attitude -- I might go for a project like that.

[15:10] <moritz> thought that might become --bt=[none|concise|full]

[15:11] <benabik> masak: It looked interesting, but it really needs to be a) cross platform and b) have a rich set of programs supporting it.

[15:11] <moritz> *though

[15:11] <masak> benabik: right. it's a bit too much of a reinvention. like Smalltalk and Plan 9.

[15:11] <benabik> masak: Mostly agreed, although I tend to use Alfred for basic stuff instead.  Launcher bars FTW

[15:11] *** birdwindupbird left
[15:12] <TimToady> I know, we'll send all backtraces to gist.github.com  :)

[15:12] <TimToady> the good ones end up there anyway ;)

[15:12] <moritz> .oO( killing me hardly with this gist )

[15:12] <TimToady> "This program has terminated unexpectedly.  Do you wish to send the backtrace to github?"

[15:13] <moritz> (yes/no/show me already)

[15:13] <masak> benabik: I use Do. when I was on Mac OS X, I used Quicksilver.

[15:13] <masak> benabik: so, yes. I agree.

[15:14] <benabik> masak: Alfred is Quicksilver but actively developed.  :-D  On Linux I haven't ventured past just a term window yet, but I don't live in it much.

[15:15] <TimToady> jnthn, sorear: what do you think of the idea of passing write ownership of mutable objects around via rw binding, and having only one scope at a time be the write owner?

[15:17] <TimToady> then a write just fails unless you are the write owner

[15:17] <jnthn> TimToady: Can you define "scope" a little more?

[15:18] <TimToady> the lexical scope into which the rw parameter is temporarily bound

[15:18] <jnthn> So, routine-level scope, essentially?

[15:18] <TimToady> more or less

[15:19] <TimToady> kinda fits with only one thread owning write access to an object at a time too

[15:19] <jnthn> hm, it has the benefit of being lexically scoped, which goes well with code analysis.

[15:19] <jnthn> Yeah, I was just about to ask about that.

[15:19] <TimToady> would have to figure out how elements of an array/hash delegate to the container object, I suppose

[15:20] <jnthn> Well, I was about to ask about like @huge_thing>>++

[15:20] <TimToady> but I like that overall direction

[15:20] <moritz> my $a = []; sub f($x is rw) { gather { for 1..10 { take $_; $x.push($_) } };  my @b := f($a); # can I modify $a here? or does $f still hold the writing permissions?

[15:20] <jnthn> Where we want to break the array over many threads and do data-parallel operations

[15:21] <jnthn> TimToady: I don't have any immediate reaction either way. I think I need to see a bunch of examples.

[15:22] <TimToady> I think the write token is one aspect of a solution, but there needs to be some kind of dynamic delegation upward too, so that write access can be conferred on children too

[15:22] <jnthn> TimToady: Nothing immediately makes me think "oh, could never work". I like the lexical nature of it, since that's pretty good from an analysis/optimization point of view.

[15:22] <masak> sorear: under what conditions should I expect to get "Unable to cast object of type 'Niecza.P6opaque' to type 'Cursor'." ?

[15:22] <jnthn> TimToady: But I can imagine there's tricky edge cases.

[15:22] <TimToady> there's always tricky edge cases :)

[15:23] <jnthn> TimToady: Sure, I put it badly. I more meant, edge cases that users are going to bump in to a lot.

[15:23] <TimToady> anyway, that's the direction I'm thinking currently

[15:23] <jnthn> TimToady: The other issue is who is responsible for restoring the old ownership.

[15:24] <jnthn> s/old/previous/

[15:24] <jnthn> Things like gather/take could be interesting there too, as moritz++ pointed out.

[15:24] <jnthn> As you may have to set/restore them over coroutine boundaries...somehow.

[15:24] <TimToady> but coro/threading is precisely where we'd like better control of that anyway

[15:25] <jnthn> Well, there is that. :)

[15:25] <jnthn> So long as we don't get ourselves into deadlock issues.

[15:26] *** supernovus joined
[15:30] *** tzhs left
[15:32] <mls> jnthn: startup is now 20% faster

[15:33] <jnthn> mls: o.O

[15:33] <jnthn> mls++

[15:33] *** thou left
[15:33] <mls> gisting...

[15:34] <mls> diff: https://gist.github.com/1214122

[15:34] <mls> (I hope the code is correct, haven't run spectest yet)

[15:35] <mls> three changes: 1) the immediate_parents == 1 check, 2) call self.mro instead of self.compute_mro, 3) the publish_cache change

[15:39] <mls> same thing for nqp: https://gist.github.com/1214140

[15:40] * moritz spectests the rakudo changes

[15:40] <mls> thanks!

[15:40] <jnthn> moritz++

[15:41] <masak> mls: you, sir, rock.

[15:41] <mls> I just looked at the profile output

[15:41] <benabik> mls: The profiling that you got to work in the first place?

[15:42] <mls> yes

[15:42] <masak> mls++ mls++

[15:42] <benabik> mls++

[15:42] <mls> hey, calm down ;)

[15:42] <jnthn> mls++ !!!

[15:42] <jnthn> :)

[15:43] <masak> mls: we want to imbue you with positive emotions now, so that you'll do it again :P

[15:43] <mls> That's an old trick ;)

[15:43] <masak> but it's working, right? :D

[15:43] <mls> you'll see ;)

[15:43] * masak bounces

[15:45] <mls> the qregex fail in nqp's "make test" is normal, right?

[15:45] <jnthn> mls: The patch looks good to me, at a first glance.

[15:46] <moritz> mls: right

[15:46] <moritz> rakudo spectest is fine so far (S03-sequence)

[15:46] <mls> good. Now we just need to wait for the spectest result

[15:47] *** thou joined
[15:47] <supernovus> multi postfix:<**> (Numeric $a is rw) { $a *= $a; };  mls**;

[15:48] <jnthn> If startup is 20% faster, should be a little less waiting ;)

[15:48] <mls> unfortunately it's just startup time...

[15:49] <jnthn> mls: Yes, but the test run causes 100s of startups :)

[15:49] <mls> now a 20% faster setting compilation would be nice

[15:49] * masak .oO( easy, just compile the setting at startup! oh wait )

[15:49] <jnthn> Well, we calculate the MROs during compiling the setting too, so it will have shaved a little off that at least.

[15:49] <moritz> t/spec/S12-attributes/delegation.t ............................. Dubious, test returned 1 (wstat 256, 0x100)

[15:49] <mls> (actually I can do 6% with my ugly parrot patch...)

[15:50] <masak> "Dubious delegation" would be a great name for a rock band.

[15:50] <mls> huh

[15:50] <moritz> t/spec/S12-introspection/parents.t also fails

[15:50] <mls> debugging...

[15:50] <jnthn> The latter one is probably most telling.

[15:52] <[Coke]> hio. Anyone here getting data from: http://smolder.parrot.org/app/projects/smoke_reports/5

[15:53] <moritz> mls: with your patch, Str.^parents returns (Str, Cool, Any, Mu)

[15:53] <moritz> mls: should be (Cool, Any, Mu) only

[15:54] <jnthn> [Coke]: Haven't been, though it certainly looks useful.

[15:54] * moritz sometimes does, usually before releases

[15:55] <[Coke]> Ok. in fine perl6 tradition, I'm rolling a new one.

[15:56] <[Coke]> (the administration of that service is a pita, trying to make one that is easier to drop in on a server.)

[15:56] * jnthn gets curious why t/spec/S06-multi/type-based.rakudo fails on that box but not for him

[15:56] <[Coke]> (and gives us more features). Comments welcome on the perl6-compiler thread (that's the right list, aye?)

[15:57] *** Holy_Cow joined
[15:57] *** kshannon joined
[15:57] <[Coke]> jnthn: if you go to the report and click on "properties" you can see particulars about the test machine

[15:58] <jnthn> [Coke]: Well, it's been run on amd64 and fails consistently. The only pass I see was from a Win32 machine ;)

[15:58] *** jevin left
[15:58] *** Holy_Cow left
[15:58] <masak> "nested structural regular expressions" -- sounds familiar somehow. http://www-cs-students.stanford.edu/~blynn/nex/

[15:58] * moritz produces lots of PASSes on amd64, but rarely remembers to submit

[15:59] * jnthn has access to one and should try it at some point

[15:59] <jnthn> It's time to start getting The Beast set up tonight too :)

[16:00] <masak> The Baest!

[16:00] <[Coke]> ?

[16:01] <jnthn> [Coke]: I've got new hardware :)

[16:01] <masak> [Coke]: jnthn can haz a new bad-ass stationary computer.

[16:01] *** jevin joined
[16:01] <jnthn> So I can be, like, productive and stuff. :)

[16:03] <mls> jnthn: I think it's because of that compute_mro -> mro change

[16:03] <jnthn> mls: ah. Hmm.

[16:03] <mls> the code was self.compute_mro($_)

[16:04] <mls> is the "self" correct?

[16:04] <mls> I mean, compute_mro caches the result in self.!mro

[16:05] <tadzik> say so all(@bigs) contain 'foo' # fantastic poetry :)

[16:05] <jnthn> mls: er, no

[16:06] <jnthn> mls: That'll be the issue.

[16:06] <jnthn> You may want to try $_.HOW.mro($_)

[16:06] <mls> yes.

[16:06] <mls> (But I just copied code. So the old code was wrong, too?)

[16:07] <jnthn> No, compute_mro cares more for $obj than self, iirc.

[16:07] <mls> but it stores the result in @!mro, so it uses self

[16:07] <masak> moritz: I think you will like http://spikedmath.com/433.html

[16:07] <jnthn> mls: Yeah. I guess we got lucky by then overwriting it again with the correct thing later...

[16:08] <jnthn> mls: So, a good discovery.

[16:08] *** simcop2387 left
[16:08] *** sayu joined
[16:08] <mls> so, how to proceed? delete the $class argument from compute_mro and just use self?

[16:09] <masak> moritz: I figured some of them out before I saw the translation below ;)

[16:10] *** simcop2387 joined
[16:10] <jnthn> mls: In your patch where you've turned a self.compute_mro($_) into a call to mro, do it as $_.HOW.mro($_)

[16:11] <jnthn> mls: that should hopefully do it.

[16:12] <mls> yes. Testing...

[16:16] *** jevin left
[16:17] *** molaf joined
[16:18] <mls> Hmm, Null PMC access in get_string()

[16:18] <daxim> perl6: one; loop { two; three; four; five; }

[16:18] <p6eval> niecza v9-23-g1a8efca: OUTPUT«===SORRY!===␤␤The 'one' listop may not be called without arguments (please use () or whitespace to clarify) at /tmp/InICJnRYFo line 1:␤------> one⏏; loop { two; three; four; five; }␤␤Undeclared routines:␤ 'five' used at …

[16:18] <p6eval> ..rakudo d97997: OUTPUT«Could not find sub &two␤  in block <anon> at /tmp/LIH_GuxKXT:1␤  in <anon> at /tmp/LIH_GuxKXT:1␤  in <anon> at /tmp/LIH_GuxKXT:1␤␤»

[16:18] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&two"␤    at /tmp/zO6_zkbpCx line 1, column 13-16␤»

[16:18] *** eternaleye left
[16:21] *** jevin joined
[16:21] <tadzik> funny. Why "&two"?

[16:21] <TimToady> interesting that niecza lists the undeclared routines in reverse order; so does std

[16:22] <TimToady> oh, maybe it's alphabetical

[16:22] <TimToady> yeah

[16:23] *** bluescreen10 left
[16:23] *** stephang joined
[16:24] <TimToady> tadzik: I believe that's a run-time error; rakudo still does not check for undeclared subs at CHECK time like niecza does

[16:24] <TimToady> but yes, it could strip the &

[16:25] <tadzik> no, still. one() should be tried to be called before loop {}, no?

[16:25] <TimToady> one is a built-in, and may not be called without args, as niecza points out

[16:26] <TimToady> and nothing is called if an error is compile time, or check time

[16:26] <TimToady> if niecza says "SORRY!" nothing will be run (except beginish stuff)

[16:27] <TimToady> perl6: say "alive"; two

[16:27] <p6eval> niecza v9-23-g1a8efca: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'two' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤  a…

[16:27] <p6eval> ..pugs: OUTPUT«alive␤*** No such subroutine: "&two"␤    at /tmp/B5q4T3MfXQ line 1, column 14 - line 2, column 1␤»

[16:27] <p6eval> ..rakudo d97997: OUTPUT«alive␤Could not find sub &two␤  in <anon> at /tmp/_E7WjWU4GE:1␤  in <anon> at /tmp/_E7WjWU4GE:1␤␤»

[16:27] <TimToady> note niecza does not say "alive"

[16:27] <TimToady> that is corret

[16:27] <TimToady> *c

[16:28] *** MayDaniel joined
[16:30] *** eternaleye joined
[16:33] <jnthn> TimToady: I was pondering have the optimizer detect those, since it has to go over the various called routines anyway.

[16:33] <jnthn> er, callsites, I mean.

[16:34] <jnthn> I guess we could do the mystery approach STD uses also, though.

[16:34] <TimToady> the most import aspect is to check the visibility of post-declared routines from the lexical scope of the call

[16:35] <pmichaud> good morning, #perl6

[16:35] <TimToady> howdy

[16:35] <jnthn> Right...by the time we're in the optimizer, we know all the declarations.

[16:35] <jnthn> hej, pmichaud :)

[16:35] *** mj41 left
[16:35] *** bluescreen10 joined
[16:35] <[Coke]> ho, pmichaud 

[16:36] <TimToady> but you have to know all the original scopes too; merely having a declaration out there is no good if it's not visible from the point of the call

[16:36] <mjreed> so we're generally opposed to things that numify to 0 but boolify to true these days, correct?

[16:36] <[Coke]> I certainly am!

[16:36] <TimToady> it's considered a design smell

[16:37] <TimToady> btw, .defined should autothread, but .DEFINITE should not

[16:37] <jnthn> TimToady: So .defined should go in Any, not Mu?

[16:37] <pmichaud> jnthn: I think .defined in Junction should autothread.

[16:37] <jnthn> Oh, we should implement a .defined in Junction...OK.

[16:37] <pmichaud> jnthn: I'd still expect to have a Mu.defined, I think.

[16:37] <jnthn> wfm

[16:38] * pmichaud is several days out on recent conversations, so modulo my responses with that.

[16:38] <jnthn> So long as we don't go breaking the "auto-threading of method is just a method dispatcher fallback"

[16:38] <jnthn> :)

[16:38] <jnthn> TimToady: (know all the original scopes) yes, we very much still do in the optimizer. It has to know exactly what's going to be called, otherwise it's not going to be able to do inlining.

[16:39] <TimToady> or candidates for that matter

[16:39] <jnthn> Right. :)

[16:39] <jnthn> We have that to hand in nom already. :)

[16:39] <mjreed> I was asking because we don't have a trivial built-in way atm to do a yes/no "is X a substring of Y".  have to either turn X into a regex and smartmatch or call .index.defined.  Making .defined autothread makes the latter more palatable, though. 

[16:39] <TimToady> having the check in one spot does let us list all of the undefined routines together though

[16:40] <jnthn> TimToady: Sure - I'd expect the optimizer to note down all of these sorts of things as it goes and then just give a report of anything it found at the end.

[16:40] <TimToady> wfm

[16:41] <jnthn> TimToady: It'll no doubt detect a bunch of impossible type-based stuff too.

[16:41] <jnthn> Of course, from the user's point of view, they don't much care which stage whines at them. :)

[16:41] <jnthn> They just want the info. 

[16:42] <mjreed> as long as the whining includes information meaningful to me... which low-level whinging often doesn't.

[16:42] <mls> how do I create a copy of an array in nqp?

[16:42] <pmichaud> mls: deep copy or shallow?

[16:42] <mls> shallow is enough

[16:42] <pmichaud> my @new := nqp::clone(@old)

[16:43] <mls> Thanks!

[16:43] <jnthn> mjreed: Yes, it'd tell you the name of the undeclared thing, where the call was, etc.

[16:45] *** dukeleto left
[16:45] <mjreed> Oh, happy programmer's day, in case nobody mentioned it yet...

[16:45] <mls> jnthn: that was the issue with our last change: all classes shared the same @!mro cache afterwards

[16:46] <jnthn> mls: oh!

[16:46] <jnthn> mls: Well, ouch :)

[16:46] <mls> yes ;)

[16:47] <cotto_work> mls: how do you regard the sub profiling branch?  Is it as good as it'll ever get or do you have further plans?

[16:47] <mls> It's not in a bad state ;). It just needs some cleanups:

[16:48] <mls> int -> correct type, it shouldn't write to stderr but in a file, and similar small changes

[16:48] <cotto_work> also, tests

[16:49] <mls> regarding the cla: our legal expert wasn't here today, will try tomorrow...

[16:49] <mls> yes, tests would be nice

[16:49] *** alvis left
[16:50] <cotto_work> mls: ok.  Thanks for looking into that.

[16:50] <mls> jnthn: t/spec/S12-introspection/parents.t works again! and startup is still fast!

[16:50] <jnthn> \o/

[16:50] <jnthn> Well, faster ;)

[16:50] <mls> gisting...

[16:50] <mls> I little bit, maybe ;)

[16:50] <jnthn> mls: Does the delegation.t one pass also

[16:51] <mls> yes

[16:51] <pmichaud> afk, errands

[16:54] <mls> jnthn: https://gist.github.com/1214298

[16:54] <mls> note the strategic nqp::clone() ;)

[16:54] <mls> spectesting...

[16:55] <jnthn> ah, yes :)

[16:55] <mls> (btw, the nqp patch was not affected, as it doesn't cache the mro)

[16:55] *** envi left
[16:57] *** packetknife joined
[17:01] <mls> argh, instants-and-durations hangs...

[17:01] <mls> (stupid 32bit host...)

[17:02] *** alvis joined
[17:03] *** dakkar left
[17:06] *** Chillance joined
[17:10] *** mjreed left
[17:10] *** localhost joined
[17:11] *** daniel-s left
[17:24] <supernovus> So, my SCGI library now has PSGI support. Now to get it working with apache's mod_scgi again.

[17:24] <mls> jnthn: spectest complete, only the 32bit tests seem to fail

[17:25] <jnthn> mls: Great, thanks...will apply later today.

[17:25] <mls> thanks!

[17:25] <mls> afk -> home

[17:26] * [Coke] really hopes versions in perl6 don't suck.

[17:30] *** packetknife left
[17:37] <flussence> [Coke]: you were asking about TAP files the other day, do you still need them?

[17:42] *** dukeleto joined
[17:42] *** stephang left
[17:43] <[Coke]> I could use a few, sure.

[17:43] <[Coke]> juicy ones with failures and skips and things! ;_)

[17:43] <flussence> have you got access to feather3?

[17:43] <[Coke]> er, ;) 

[17:43] <[Coke]> just feather.

[17:45] *** molaf left
[17:45] <flussence> hm, I'm not sure how to get them to you...

[17:45] <flussence> moritz: ping?

[17:45] *** benabik left
[17:46] <[Coke]> you have access to feather3 but not feather? odd.

[17:46] <[Coke]> tell you what - just hang on to them, if you can, and I'll have you try to submit them via the webterface when that works.

[17:46] <flussence> yeah, I only needed it to poke tryrakudo when it stops working...

[17:47] <flussence> oh, most of these are getting uploaded to smolder.parrot.org too, I just happened to save them all locally

[17:47] <[Coke]> I no longer have access there ;)

[17:47] <[Coke]> no big deal. I'm days away from doing something with them anyway, and I can always generate my own if needed.

[17:47] <[Coke]> thanks.

[17:48] <Util> rakudo: class Wo { method look ($_:) { say $_.WHAT, ' ', self.WHAT; }; }; my $w = Wo.new; $w.look;

[17:48] <p6eval> rakudo d97997: OUTPUT«Wo() Wo()␤»

[17:48] <Util> rakudo: class Wo { method look       { say $_.WHAT, ' ', self.WHAT; }; }; my $w = Wo.new; $w.look;

[17:48] <p6eval> rakudo d97997: OUTPUT«Any() Wo()␤»

[17:48] <Util> Didn't the Specs (at some point in the past) say that methods auto-topicalize `self`, so that you can always say .method from within a method?

[17:48] <Util> Am I just imagining that history? 

[17:48] <flussence> [Coke]: depends how many you need... I have the whole nom branch here :)

[17:49] *** pernatiy left
[17:51] <masak> Util: you are not imagining that history.

[17:51] <masak> Util: it was changed to the current state in 2005. I have a blog post about why that was a good idea.

[17:52] <flussence> rakudo: class Wo { method look ($_:) { say .WHAT; }; }; my $w = Wo.new; $w.look; # curious...

[17:52] <p6eval> rakudo d97997: OUTPUT«Wo()␤»

[17:52] <masak> Util: http://strangelyconsistent.org/blog/the-dot-is-the-cutest-sigil

[17:52] <flussence> rakudo: class Wo { method look { say .WHAT; }; }; my $w = Wo.new; $w.look;

[17:52] <p6eval> rakudo d97997: OUTPUT«Any()␤»

[17:53] <flussence> no surprises here, good :)

[17:54] <Util> masak: tyvm

[17:54] *** wamba joined
[17:55] <[Coke]> flussence: ah, nifty. Might be fun to use that as a load to get data over time stuff working.

[17:58] *** JimmyZ left
[18:04] *** clairvy left
[18:05] *** uasi left
[18:10] *** zby_home joined
[18:20] *** JodaZ joined
[18:28] *** daxim left
[18:28] *** mj41 joined
[18:35] <Util> `for` is eager in Perl 5, so this is safe:

[18:35] <Util>     my @GLOBAL_ARRAY = 1,2,3; sub_which_mutates_the_global_array($_) for @GLOBAL_ARRAY;

[18:35] <Util> `for` is lazy in Perl 6, so to be safe, I must do this:

[18:35] <Util>     my @GLOBAL_ARRAY = 1,2,3; my @temp = @GLOBAL_ARRAY; sub_which_mutates_the_global_array($_) for @temp;

[18:35] <Util> Is there some single-statement syntax to make `for` eager?

[18:37] <jnthn> Note that for in sink context is lazy.

[18:37] <jnthn> gah

[18:37] <jnthn> Note that for in sink context is eager.

[18:38] *** pernatiy joined
[18:40] <PerlJam> Util: modulo what jnthn said, you can use "eager" to force eagerness.  :)

[18:41] <Util> PerlJam++ That is what I was looking for.

[18:42] <Util> jnthn: Interesting. I cannot think of example syntax, though.

[18:43] <Util> thanks to you both

[18:44] <jnthn> std: eager for 1..10 { }

[18:44] <p6eval> std bb4f150: OUTPUT«===SORRY!===␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/Tb7wJVdRED line 1:␤------> eager for 1..10 ⏏{ }␤    expecting infix or meta-infix␤Parse failed␤FAILED 00:01 120…

[18:44] <jnthn> Thought not...

[18:44] <jnthn> eager map ... works though.

[18:45] <Util> std: .say for eager 1..10

[18:45] <p6eval> std bb4f150: OUTPUT«ok 00:01 120m␤»

[18:47] *** sayu left
[18:52] *** daxim joined
[18:53] <masak> Util: all the 'eager' would do in that context would be roll out the range into a list in memory before iterating over it.

[18:53] <masak> the merits of that are questionable, though irrelevant in the case of 1..10 :P

[18:54] *** wallberg joined
[18:55] *** mjreed joined
[18:55] *** frhodes joined
[18:56] *** zby_home left
[18:57] <mjreed> how do I do a destructuring bind?  Something like my ($head, @rest) := @somearray..

[18:57] <jnthn> *@rest

[18:58] <mjreed> Ah, I was putting the star on the wrong side.  Thanks.

[18:58] <jnthn> b: my @a = 1,2,3,5; my ($head, *@rest) := @a; say $head; say @rest

[18:58] <p6eval> b 1b7dd1: OUTPUT«1 2 3 5␤␤»

[18:58] <jnthn> er, hm 

[18:58] <mjreed> hm.

[18:58] <mjreed> indeed.

[18:58] <jnthn> rakudo: my @a = 1,2,3,5; my ($head, *@rest) := @a; say $head; say @rest

[18:58] <p6eval> rakudo d97997: OUTPUT«===SORRY!===␤Cannot use bind operator with this LHS at line 1, near " @a; say $"␤»

[18:59] <jnthn> Yeah, didn't tackle that bit in nom yet.

[19:02] <mjreed> it seems like the syntax for that would be my ($head, @rest) := *@a;

[19:02] <jnthn> no.

[19:02] <jnthn> The LHS there is parsed as a signature.

[19:02] <jnthn> There's no prefix:<*>

[19:03] <mjreed> Hw do you pass the elements of an array as individual parameters to a sub?

[19:04] <TimToady> prefix:<|>

[19:06] <Util> masak: The 1..10 is bad example; in the backscroll, you will see I was looking for `eager` to do this:

[19:06] <mjreed> so "my  ($head, @rest) := |@a;" would seem to be the non-sub binding analogue..

[19:06] <Util> my @GLOBAL_ARRAY = 1,2,3; sub_which_mutates_the_global_array($_) for eager @GLOBAL_ARRAY;

[19:06] <masak> hey! #phasers!

[19:06] <Util> Whoops!

[19:06] <masak> Util: as jnthn pointed out *that already does what you want*.

[19:07] <masak> Util: for loops are lazy (because maps are lazy), but sink context eagerifies them.

[19:08] <Util> masak, (and anyone else who is questioning my sanity), @GLOBAL_ARRAY is just a placeholder for *anything* that I am trying to pre-read into memory before the `for` gets it.

[19:09] <Util> I should have used $fh.lines for an example instead.

[19:09] <Util> Thanks.

[19:09] *** molaf joined
[19:10] <masak> Util: sink context eagerifies for loops.

[19:10] * masak should perhaps change his way of saying this, since it hasn't worked so far

[19:11] <Util> but /me was absent the day they taught sink context :(

[19:11] <masak> Util: the example, even with the modifications you propose, is not lazy. unless it's at the last statement of a routine and some other things hold.

[19:11] *** im2ee joined
[19:11] <im2ee> Hello! :)

[19:12] <masak> im2ee: cześć!

[19:12] <jlaire> im2ee: terve

[19:12] <im2ee> masak, witaj.

[19:12] <tadzik> hej

[19:12] <im2ee> jlaire, terve! :)

[19:12] <im2ee> tadzik, hej! :)

[19:13] <Util> masak: So, like in Perl 5, it is always safe to say this? :

[19:13] <Util> for IO.readdir -> $file { clone_the_file_into_the_same_dir($file) }

[19:14] <masak> Util: unless it's the last statement of a routine and some other things hold, yes.

[19:15] <Util> Can you point me to the doc? I am writing example code, and I need to know those "other things" to be sure I don't err; this *is* being done as the last statement of a routine.

[19:15] <masak> rakudo: for 1..10 { .say }

[19:15] <p6eval> rakudo d97997: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[19:16] <masak> rakudo: sub foo { for 1..10 { .say } }; my @a := foo();

[19:16] <p6eval> rakudo d97997: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[19:16] <masak> hm. should that really evaluate?

[19:16] <masak> b: sub foo { for 1..10 { .say } }; my @a := foo();

[19:16] <p6eval> b 1b7dd1: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[19:17] <TimToady> afaik rakudo still cheats on sink context

[19:17] <masak> Util: "other things": the call isn't in sink context.

[19:18] <masak> TimToady: oh. that would explain it.

[19:18] <TimToady> niecza: sub foo { for 1..10 { .say } }; my @a := foo();

[19:18] <p6eval> niecza v9-23-g1a8efca: OUTPUT«Potential difficulties:␤  @a is declared but not used at /tmp/I17hkYIkBJ line 1:␤------> sub foo { for 1..10 { .say } }; my ⏏@a := foo();␤␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[19:18] <Util> masak: OK, thanks!

[19:18] <masak> rakudo: my @a := gather for 1..10 { .say; take }; say "alive"

[19:19] <p6eval> rakudo d97997: OUTPUT«alive␤»

[19:19] <masak> rakudo: my @a := gather for 1..10 { .say; take }; say "alive"; say @a[4]

[19:19] <p6eval> rakudo d97997: OUTPUT«alive␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤Nil␤»

[19:19] <masak> Nil!?

[19:19] <masak> rakudo: my @a := gather for 1..10 { .say; take }; say "alive"; say '@a[4] = ', @a[4]

[19:19] <p6eval> rakudo d97997: OUTPUT«alive␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤@a[4] = Nil␤»

[19:20] <masak> this is wrong, right?

[19:20] <masak> b: my @a := gather for 1..10 { .say; take }; say "alive"; say '@a[4] = ', @a[4]

[19:20] <p6eval> b 1b7dd1: OUTPUT«alive␤1␤2␤3␤4␤5␤@a[4] = ␤»

[19:20] <masak> oh!

[19:20] <masak> rakudo: my @a := gather for 1..10 { .say; take $_ }; say "alive"; say '@a[4] = ', @a[4]

[19:20] <p6eval> rakudo d97997: OUTPUT«alive␤1␤2␤3␤4␤5␤@a[4] = 5␤»

[19:20] * masak <-- very forgetful

[19:21] <PerlJam> rakudo: my @a := gather for 1..10 { .say; .take }; say "alive"; say '@a[4] = ', @a[4]

[19:21] <p6eval> rakudo d97997: OUTPUT«alive␤1␤Method 'take' not found for invocant of class 'Int'␤  in block <anon> at /tmp/cP1aes3Fv8:1␤  in method reify at src/gen/CORE.setting:3649␤  in method reify at src/gen/CORE.setting:3554␤  in method reify at src/gen/CORE.setting:3554␤  in method gimme at src/…

[19:21] <masak> TimToady: what do you think of nom's tendency to give Nil back from indexings that didn't find anything. (as opposed to Any, that Beijing gives back)

[19:22] <TimToady> rakudo: my @a := do for 1..10 { .say; $_ }; say "alive"; say '@a[4] = ', @a[4]

[19:22] <p6eval> rakudo d97997: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤alive␤@a[4] = 5␤»

[19:22] <TimToady> niecza: my @a := do for 1..10 { .say; $_ }; say "alive"; say '@a[4] = ', @a[4]

[19:22] <p6eval> niecza v9-23-g1a8efca: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤alive␤@a[4] = Any()␤»

[19:24] <TimToady> Any seems a bit better to me if there's any chance it'll be used as a placeholder

[19:24] <TimToady> (in a list)

[19:26] <masak> I agree.

[19:27] <TimToady> well, it depends on what the default value for the array is

[19:28] <TimToady> but most arrays default to Any

[19:28] *** mberends joined
[19:30] <TimToady> more precisely, most arrays default to their type object, and untyped arrays have a type object of Any

[19:30] <TimToady> perl6: my Int @array; say @array[1].WHAT

[19:30] <p6eval> pugs: OUTPUT«Scalar␤»

[19:30] <p6eval> ..rakudo d97997, niecza v9-23-g1a8efca: OUTPUT«Any()␤»

[19:30] *** kshannon left
[19:31] <TimToady> I think that should probably be Int

[19:31] <jnthn> TimToady: Agree

[19:31] <TimToady> but we want to be able to set a default separate from the type

[19:33] <mathw> (wakes up) That seems sensible

[19:34] <masak> math! 

[19:34] <masak> er, mathw! \o/

[19:35] * mathw has been busy with new job

[19:35] <mathw> been learning F# and C#, wishing for Perl 6

[19:35] <masak> P#

[19:35] <TimToady> smile when you say that

[19:36] <masak> P# :D

[19:36] *** araujo joined
[19:36] <mathw> actually been wishing for anything with macros, .NET seems to grow boilerplate randomly :(

[19:36] *** benabik joined
[19:39] * mathw would like to congratulate the nom developers on its promotion

[19:39] *** thou left
[19:40] <masak> its promotion to... still being nom :P

[19:41] <mathw> well yes

[19:41] <mathw> but it is now the default branch

[19:41] <mathw> which is a promotion :)

[19:41] <PerlJam> masak: but now it's *the* nom

[19:41] <masak> :P

[19:42] *** kshannon joined
[19:42] <mathw> We're using Mercurial at $newjob, which is confusing me a bit because it's almost the same as git, but not quite...

[19:42] <masak> mathw: having played around with nom in the past week, I find it less ready to replace b than I thought. but it seems to be closing the gap quickly enough.

[19:43] <mathw> masak: at some point the leap had to be taken, it's not like releasing a big new version of a popular app and leaving most of the functionality out.

[19:43] <mathw> Nobody ever does that, after all

[19:43] <masak> surely not

[19:44] <pmichaud> good afternoon, #perl6

[19:45] <mathw> oh hai pmichaud 

[19:45] <masak> pmichaud! \o/

[19:46] <masak> just the Perl 6 List Expert I was looking for :)

[19:46] <masak> pmichaud: btw, #phasers!

[19:47] <pmichaud> yeah, I just got in from @errands

[19:47] <mathw> on stun!

[19:47] <mathw> (sorry)

[19:47] <masak> peow peow

[19:47] *** frhodes left
[19:47] *** kshannon left
[19:48] *** kshannon joined
[19:49] *** MayDaniel left
[19:51] *** frhodes joined
[19:51] *** mberends left
[19:59] *** jevin left
[20:02] *** jevin joined
[20:03] *** skangas left
[20:20] *** eiro joined
[20:20] <supernovus> hmm, that's odd, if I run a script on the command line, it works fine, if I try to run it as a CGI script, it bails with "Method 'exists' not found for invocant of class 'Hash'". That's new one oO

[20:20] <eiro> hello 

[20:21] *** soh_cah_toa joined
[20:21] <jnthn> supernovus: Are you running an installed version, ooc?

[20:22] <supernovus> yup

[20:23] <tadzik> hello eiro 

[20:23] <masak> salut, eiro.

[20:25] <masak> eiro: bonne chose vous êtes venu. du peuple polonais et finlandais ont été la prise sur le channel. :)

[20:26] * tadzik es polonais

[20:27] *** wamba left
[20:29] * arnsholt hands tadzik a t

[20:29] <arnsholt> I think it's yours =)

[20:29] <tadzik> est. Like ist :)

[20:29] <tadzik> yeah, it's me t

[20:30] <arnsholt> Like ist, indeed. They're even etymologically related =D

[20:30] <masak> tadzik: och, nie mówił o *tobie* :)

[20:30] <tadzik> :P

[20:31] <arnsholt> I think the slavic copula is *Hes as well

[20:31] <masak> unless you're Russian, then it's ''

[20:31] <arnsholt> Quite, quite

[20:32] <arnsholt> I need to learn some kind of Slavic language

[20:33] <arnsholt> Old Church Slavonic might be useful ^_^

[20:33] <jnthn> It looks pretty if nothing else :)

[20:34] <arnsholt> Yup. And considering my Master's work used data from a Latin corpus, I can even make a case that I might even benefit from knowing it

[20:35] <arnsholt> Historical linguistics for the win =)

[20:35] <masak> Ѧ!

[20:36] <supernovus> Okay, so IO::Socket::INET works if I telnet into it, and manually send commands. If I use Apache or lighttpd to connect to it, they don't seem to send the data until the connection times out (or at least that seems to be the symptoms.) Anyone have experience with sockets?

[20:36] <arnsholt> Yeah, I should learn to read those things as well. I already know the Greek alphabet, so it should be mainly a matter of applying myself

[20:36] <arnsholt> .u Ѧ

[20:36] <phenny> U+0466 CYRILLIC CAPITAL LETTER LITTLE YUS (Ѧ)

[20:36] <masak> supernovus: sounds like something to do with buffering.

[20:37] <masak> arnsholt: latin, greek, and cyrillic. learning them all is like looking at cubistic art :P

[20:38] <arnsholt> Well, I don't know actual Greek (modern or ancient). I just know the letters of the alphabet

[20:38] <masak> aye.

[20:38] <arnsholt> I learned half of it from doing maths too, TBH

[20:38] <masak> same here.

[20:38] <masak> nodnod

[20:39] <arnsholt> But not sure I see how it's like cubism

[20:39] *** uasi joined
[20:39] <arnsholt> You trying to say Classics aren't a useful real-world skill? ;p

[20:43] <masak> I would never claim that.

[20:45] <masak> I learned Cyrillic before Greek. with each Greek letter I learned, I understood more about the Cyrillic ones. the perspective gained was almost like in cubism, with more observer angles than usually possible ;)

[20:48] *** kaare_ left
[20:48] <mikemol> http://rosettacode.org/mw/index.php?title=Talk:Language_Comparison_Table&diff=0&oldid=91998

[20:51] <masak> rakudo: say '1' + 1

[20:52] <p6eval> rakudo d97997: OUTPUT«2␤»

[20:52] <masak> this has little or nothing to do with "strong typing", at least in Perl 6.

[20:52] <masak> ...where the operators themselves more often than not contain implicit type conversions.

[20:52] <arnsholt> masak: Ah yes, I see what you mean now

[20:53] <arnsholt> Sanskrit is mighty useful in that context as well. Lots of fun stuff going on with the verbs

[20:53] <masak> d'oh, gotta learn Sanskrit.

[20:54] <arnsholt> It's pretty cool. Thankfully I can just ask the missus in most cases if I need some kind of Sanskrit trivia answered =)

[20:57] <masak> a Sanskrit missus? oh mama.

[20:59] <arnsholt> Oh yeah =D

[21:00] <arnsholt> Incidentally, it turns out Sanskrit classes are an excellent way to meet people interested in Sanskrit =D

[21:00] <supernovus> masak: Hmm, any idea how to work around buffering issues? I never came across these problems in ng or alpha. Always new and exciting things to find when new versions come along :-)

[21:00] <im2ee> Uhh, it's time for me. Good night! :)

[21:01] *** im2ee left
[21:02] *** MayDaniel joined
[21:02] <masak> im2ee: dobranoc!

[21:03] <masak> supernovus: I'm sorry, I have absolutely no idea. maybe mberends will know, he's done a bit in that area.

[21:04] <supernovus> masak: okay, I'll ask mberends when he's around.

[21:05] *** mberends joined
[21:05] <masak> :)

[21:06] <masak> he's around.

[21:06] <supernovus> I'm cleaning up my old projects, I'm going to pull half of them from the active list, as I have no intentions of resurrecting them. Exemel, SCGI, WebRequest (soon to be renamed WWW::App) Temporal::Utils and Flower will likely be the only survivors of my project purge.

[21:06] * mberends depubbed (pity, $work tomorrow)

[21:11] <jnthn> mberends: aww. 

[21:14] <mberends> supernovus: IO::Socket::INET initially had similar lack of buffer flushing in alpha and beijing, and each was patched after the initial implementation. Not sure, but perhaps the fixes are not portable enough between Rakudo branches.

[21:16] *** MayDaniel left
[21:16] <jnthn> I suspect the gist of them will be though.

[21:17] <mberends> yep, nom passes spectests, although networking is very hard to test thoroughly

[21:18] <supernovus> Ah, well, that likely explains the issue. I submitted a pull request with some changes that make the accept() method work properly in nom (still no buffer flushing though, I'm not sure where to find that.)

[21:18] <jnthn> Did anyone apply supernovus++ pull request?

[21:18] * jnthn is just in the middle of setting up his new dev machine at the moment... :)

[21:20] <mberends> jnthn: with Linux this time? ;)

[21:20] <jnthn> :P

[21:20] <mberends> :Positive \o/

[21:20] <jnthn> Good luck with that :)

[21:20] <jnthn> I do have 16 GB of RAM to do something with though :)

[21:20] <jnthn> So I can certainly do a Linux VM :)

[21:21] <jnthn> Pondered, but didn't feel like the shock therapy of just installing that. ;)

[21:21] <mberends> :)

[21:21] <cotto_work> jnthn: is your boolification work in nqp any more complicated that it sees to be or is it just a way to specify how a 6model thingy gets turned into 1/0?

[21:22] <supernovus> dual booting is always fun... games are on windows, work is on linux, keeps me undistracted during the day ;-)

[21:22] <cotto_work> s/sees/seems/

[21:22] <jnthn> cotto_work: It's basically that.

[21:22] <jnthn> cotto_work: It's a circularity saw in a sense.

[21:23] <jnthn> cotto_work: I wanted something that would (a) let me handle a bunch of common cases efficiently and (2) be easy to port.

[21:23] <jnthn> er, 1 and 2 :)

[21:25] <jnthn> cotto_work: Turns out it gave us a ~15% performance win :)

[21:25] <cotto_work> nice find

[21:25] <cotto_work> Is that from avoiding nested runloops?

[21:26] *** bbkr1 joined
[21:26] <jnthn> cotto_work: Yes, but even if we didn't have to enter a nested runloop it'd still be faster for the common cases too.

[21:27] *** dukeleto left
[21:27] *** wamba joined
[21:29] *** frhodes left
[21:29] *** frhodes joined
[21:30] *** frhodes left
[21:30] *** frhodes joined
[21:31] *** frhodes left
[21:31] *** frhodes joined
[21:31] *** skangas joined
[21:37] *** wallberg left
[21:39] <jnthn> Ugh. 

[21:39] <jnthn> .\miniparrot.exe -Iruntime/parrot/include config_lib.pir > runtime/parrot/include/config.fpmc

[21:39] <jnthn> NMAKE : fatal error U1077: '.\miniparrot.exe' : return code '0xc0000005'

[21:39] <jnthn> ...that's a segv. :(

[21:40] <jnthn> Hmm, I see your chosen INTVAL isn't the same size as your pointers.  Parrot

[21:40] <jnthn> should still compile and run, but you may see a ton of warnings.

[21:41] <jnthn> ...that's a giveaway...

[21:41] <diakopter> new windows trouble?

[21:41] <jnthn> diakopter: 64-bit windows trouble.

[21:41] <cotto_work> Parrot doesn't do well in that situation

[21:41] <jnthn> cotto_work: Yeah...wonder why it ends up configuring that way.

[21:44] *** benabik left
[21:44] *** mj41 left
[21:45] <diakopter> jnthn: yeah, last I tried parrot/rakudo on 64-bit windows, I guess I downloaded the 32-bit parrot installer.

[21:45] *** packetknife joined
[21:47] <jnthn> cotto_work: Turns out configuring with --intval="long long" helps

[21:48] *** benabik joined
[21:48] *** frhodes left
[21:48] *** frhodes joined
[21:48] <bbkr1> nom: my $::x = 3 # segfaults for me

[21:48] <p6eval> nom d97997:  ( no output )

[21:48] <bbkr1> nom: my $::x = 3; say "alive";

[21:48] <p6eval> nom d97997:  ( no output )

[21:49] <cotto_work> jnthn: yeah.  That's the workaround.

[21:49] <jnthn> cotto_work: Not quite sure how to update the configure probe.

[21:50] <cotto_work> jnthn: what should it do?  always use intval=long long on windows x64?

[21:50] *** jevin left
[21:50] <jnthn> cotto_work: "if it's Windows x64 on msvc, use long long" sounds like a sane starting point.

[21:51] *** jevin joined
[21:51] <cotto_work> jnthn: ok

[21:53] *** thou joined
[21:55] *** clairvy joined
[21:56] <masak> 'night, #perl6

[21:56] *** clairvy left
[21:56] <masak> keep it real :)

[21:56] *** clairvy joined
[21:56] *** masak left
[21:56] *** bluescreen10 left
[21:57] <dalek> ecosystem: 0df35d1 | (Timothy Totten)++ | META.list:

[21:57] <dalek> ecosystem: Removed my old dead projects, and added WWW::App.

[21:57] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/0df35d1093

[21:57] *** kfo_ joined
[21:57] <flussence> .oO( keep it rat? )

[21:59] *** Limbic_Region joined
[22:00] <cotto_work> jnthn: how does this work: http://nopaste.snit.ch/81313

[22:00] <bbkr1> what happened to ClassHOW type? are tickets related to it, such as https://rt.perl.org/rt3/Ticket/Display.html?id=73142 , still valid?

[22:01] <cotto_work> jnthn: actually, I don' think that's sufficient

[22:03] <jnthn> bbkr1: It's all under Metamodel:: these days

[22:03] *** supernovus left
[22:03] <jnthn> cotto_work: Can try in a moment

[22:03] <jnthn> cotto_work: Just getting a Rakudo build at all right now...and setting everything else up on here.

[22:03] <jnthn> (new machine)

[22:05] <bbkr1> jnthn: thanks,

[22:06] *** donri left
[22:06] <cotto_work> jnthn: try this one instead: http://nopaste.snit.ch/81314

[22:07] <cotto_work> it's possible it'll break something

[22:08] *** benabik left
[22:12] <jnthn> Will try when this spectest run is done :)

[22:15] <jnthn> 240 wallclock secs. Not bad. :)

[22:15] <jnthn> pmichaud: ^^ Who wins? ;)

[22:16] <jnthn> (spectest time)

[22:16] *** frhodes left
[22:17] *** frhodes joined
[22:22] <jnthn> cotto_work: For some reason the patch doesn't seem to apply. :S

[22:23] *** Limbic_Region left
[22:24] <cotto_work> jnthn: to parrot master?

[22:24] <jnthn> yeah

[22:24] <jnthn> not sure what's up with that, it looks like it should.

[22:25] <cotto_work> ditto

[22:27] <dalek> rakudo/nom: cca1166 | jnthn++ | t/spectest.data:

[22:27] <dalek> rakudo/nom: Label a few more tests as needing ICU.

[22:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cca11667da

[22:28] <jnthn> Commit from $new-machine \o/

[22:28] <tadzik> nice nice

[22:28] <tadzik> jnthn: you run spectest in 240 secs?

[22:29] <cotto_work> jnthn: win64-workaround branch

[22:31] <jnthn> tadzik: yes

[22:31] <tadzik> jnthn: that's... quite unusual :)

[22:31] <tadzik> what kind of cpu is that beast?

[22:31] <jnthn> Some quad core i7 :)

[22:31] <jnthn> I ran it with --jobs=4

[22:32] <diakopter> jnthn: try --jobs=8

[22:32] <jnthn> cotto_work: Just tried the branch. Doesn't help :(

[22:32] <jnthn> cotto_work: Gives:

[22:32] <jnthn> init::hints -         Load platform and local hints files...Use of uninitialized value in string eq at config/init/hints/mswin32.pm line 68.

[22:32] <jnthn> .............done.

[22:33] <jnthn> cotto_work: And then still has the INTVAL/pointer different sizes error

[22:33] <jnthn> diakopter: trying :)

[22:33] <jnthn> let's see if this slows things down

[22:33] <jnthn> :)

[22:34] <jnthn> no, machine still pretty responsive :)

[22:34] <diakopter> heh

[22:34] <jnthn> I wonder if it's doing HT...

[22:35] <diakopter> run all your dev area on a ramdisk :)

[22:35] <jnthn> Already doing it on an SSD... :)

[22:35] *** packetkn_ joined
[22:35] <jnthn> Got OS, compiler, and build all on the SSD

[22:35] <jnthn> This seems to have the added bonus that it's *very* quiet in here now :)

[22:37] <jnthn> diakopter: Gets it down to 220.

[22:37] <diakopter> hrm

[22:38] *** packetknife left
[22:48] <sjohnson> perl consistently blows my mind with awesomeness every day

[22:48] *** aloha joined
[22:49] <cotto_work> jnthn: I'm pretty sure I'm not fixing this in the right place.  I'll need to revisit this when I'm fresher.

[22:49] *** packetkn_ left
[22:53] <jnthn> cotto_work: OK, np. I have a workaround so I won't be blocked. 

[22:54] <diakopter> 32-bit parrot installer?

[22:57] *** aloha left
[22:58] <jnthn> diakopter: No, one can just pass --intval="long long" to the Configure script and the build works out.

[23:08] *** f00li5h joined
[23:10] *** clairvy left
[23:15] *** mattp_ left
[23:15] *** mattp_ joined
[23:18] *** wamba left
[23:23] *** tokuhirom joined
[23:23] *** bbkr1 left
[23:24] *** bbkr1 joined
[23:25] *** aloha joined
[23:29] *** supernovus joined
[23:30] <supernovus> mberends: I'm guessing HTTP::Server::Simple hasn't been ported to nom yet?

[23:31] <mberends> supernovus: correct, but only because of tuit shortage

[23:32] <supernovus> Ah, okay, I just updated my new WWW::App library so it can use either SCGI or HTTP::Server::Simple::PSGI as backends, but my attempt to test with the latter led me to the conclusion that it wasn't working in nom :-)

[23:32] <tadzik> mberends: may be Buf shortage as well :)

[23:34] <mberends> tadzik: ouch!

[23:35] <tadzik> yeah, sometimes we have no bufs :)

[23:36] <jnthn> OK, seems I've got my dev environment on my shiny new hardware ready to go. :)

[23:36] <mberends> there is a round buf somewhere in fifo implementations :)

[23:36] <jnthn> Too bad it's time to sleep now rather than hack...

[23:38] * jnthn rests...on-site $dayjob during the day, but should get some Rakudo time in the evening, and I've got all day Thursday for it too :)

[23:38] <jnthn> night all o/

[23:39] <tadzik> 'night!

[23:39] <tadzik> I should 'night too

[23:40] <TimToady> mikemol: response to paddy at http://rosettacode.org/mw/index.php?title=Talk:Language_Comparison_Table&curid=2945&diff=120447&oldid=120438

[23:44] <supernovus> I'm going to call it a night as well. WWW::App using SCGI is ready for action when IO::Socket::INET flushes its buffers, and will work with HTTP::Server::Simple::PSGI once that's running under nom. It should (not tested) work fine with both under the "ng" branch right now, in case anyone is still running that branch (and wants to write web apps for it?)

[23:46] *** molaf_ joined
[23:49] *** molaf left
[23:52] *** whiteknight joined
[23:55] *** packetknife joined
[23:56] *** abercrombie joined
[23:58] *** Chillance left
