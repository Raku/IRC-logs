[00:00] <tadzik> offby1: on the eqv note, I have no idea :)

[00:00] *** felineiron is now known as f00li5h

[00:00] *** [Coke] joined
[00:01] *** envi joined
[00:04] <offby1> ah well!

[00:04] <offby1> another day's troublemaking.

[00:06] *** [Coke] left
[00:07] *** [Coke] joined
[00:10] <tadzik> jnthn: sorry, but I can't find any docs on that. How does nqp treat named params, like :foo<bar>, accepts a slurpy hash?

[00:11] <tadzik> I stumbled upon that when trying to determine what has actually been passed to the function. It can't be just an array of Pairs, for nqp doesn't know about Pair

[00:12] <jnthn> tadzik: It just compiles down to a named parameter call

[00:12] <jnthn> tadzik: At PIR level

[00:12] <tadzik> which makes me wonder whether we'll need a special case of add_constant

[00:12] *** [Coke] left
[00:12] <jnthn> Maybe

[00:12] <jnthn> Or extract the new_type part of it

[00:13] <jnthn> And add a *%args

[00:13] <tadzik> jnthn: okay, but in case in which we're passing a named params to our add_constant. We can do foo([:a<b>, :c<d>])

[00:13] <tadzik> but then we need to something in sort of @values[0].WHAT in nqp

[00:13] <jnthn> tadzik: Yes, I'm suggesting you pass named params

[00:13] <jnthn> No, use a slurpy hash

[00:13] <tadzik> as an alternative to slurpy array?

[00:13] <jnthn> or use hash(a => $obj, b => $obj) and pass a hash

[00:13] *** [Coke] joined
[00:13] <jnthn> Well, new_type needs both

[00:13] <tadzik> okay

[00:14] <jnthn> But it takes a slurpy array at the moemnt

[00:14] <tadzik> but, at the same time?

[00:14] <jnthn> So may as well give it a slurpy hash too

[00:14] <jnthn> sure

[00:14] <jnthn> Then we keep it nice and general

[00:14] <tadzik> mhm

[00:14] <tadzik> I see

[00:14] <jnthn> it's used for Rat.new(1,2) today

[00:14] <jnthn> So we can't break that case

[00:15] <tadzik> nqp: sub foo(*@a, *%b) { say %b<foo> }; foo(:foo<bar>);

[00:15] <p6eval> nqp: OUTPUT«Null PMC access in get_pmc_keyed()␤current instr.: 'foo' pc 242 ((file unknown):61850768)␤»

[00:16] <tadzik> what's wrong?

[00:17] <jnthn> er...wow :/

[00:17] <tadzik> hmm

[00:17] <jnthn> wtf.

[00:17] <tadzik> it's ok, say(), not say

[00:17] *** franek joined
[00:17] <tadzik> LTA error though

[00:17] <jnthn> oh

[00:17] <jnthn> nqp: sub foo(*@a, *%b) { say(%b<foo>) }; foo(:foo<bar>);

[00:17] <p6eval> nqp: OUTPUT«bar␤»

[00:18] <tadzik> so I'm extendind add_constant with a slurpy hash, and then I'll process positional, then named

[00:18] <jnthn> well, it already processes positional, so you just add named :)

[00:18] <tadzik> yep :)

[00:20] <jnthn> Isn't it 2am there? ;-)

[00:20] <tadzik> it is :)

[00:20] *** franek left
[00:20] <tadzik> But now you're in range :P

[00:20] *** dorlamm left
[00:21] <jnthn> :)

[00:21] <tadzik> and my report is due to tuesday, you know :)

[00:21] <tadzik> . o O ( Insomnia considered useful )

[00:22] *** [Coke] left
[00:23] <tadzik> okay, I did it, and it didn't even break the spectest :)

[00:24] *** [Coke] joined
[00:24] <tadzik> so now it's quite easy. The PAST of the arguments is produced inside add_constant, with get_object_sc_ref_past(). I assume this won't work for Pod::Nodes, but should be fine for the rest of the things

[00:25] <tadzik> and since add_constant returns a past, I can feed that past into another new_type kind of add_constant, right?

[00:26] <jnthn> tadzik: Well, really you want the actual object when you call new_type

[00:26] <jnthn> So $what_add_constant_returned<compile_time_value>

[00:27] <tadzik> hmm

[00:27] <jnthn> And yes, if you add your Pod::Nodes instances to the SC you can have those reference each other too

[00:27] <jnthn> I guess you need to do that to build up the tree

[00:28] <tadzik> yes

[00:29] <jnthn> tadzik: See code for Rat handling in dec_number

[00:29] *** cooper left
[00:30] <tadzik> oh, good

[00:30] <tadzik> yay, I think I get all it :)

[00:32] <tadzik> just poking you one more time: Each of my action methods will return a past created by add_constant. Now the upper ones will just pass $children<compile_time_value> to their add_constant()s, and this gets upper... if you know what I mean :)

[00:32] *** [Coke] left
[00:32] *** Qiang joined
[00:32] <jnthn> tadzik: Sounds right

[00:32] <jnthn> tadzik: You just then also need a :my @*POD_BLOCKS array to push the top level things on to, I guess

[00:32] <tadzik> exciting is that once I understand all this, I'll be the second person who understands this :P

[00:32] <tadzik> jnthn: yeah, I think so

[00:32] <jnthn> And then in comp_unit you can do 

[00:33] *** Chillance joined
[00:33] <jnthn> $*ST.add_constant('List', 'type_new', |@*POD_BLOCK_COMPILE_TIME_VALUES) or some such

[00:33] *** [Coke] joined
[00:33] <tadzik> yeah, that looks right

[00:33] <jnthn> or just phush the compile time values into @*POD_BLOCK

[00:34] <tadzik> then I need to register that topmost constant as $*POD or so

[00:34] <tadzik> or maybe just $POD

[00:35] <tadzik> jnthn: or, I can work out a method which takes an object and, with a depth-first algorithm serializes it all. Would it be worthwhile?

[00:36] <jnthn> Well, that'[s what I need to do for implementing full-blown serialization

[00:36] <jnthn> So, I'd just do it the "easy way" for now :)

[00:36] <jnthn> You can use $*ST.install_lexical_symbol($*UNIT, ... ) to install it

[00:36] <jnthn> Isn't it @?POD or some such?

[00:37] <tadzik> $=POD, should be. But...

[00:37] * jnthn has no idea really :)

[00:37] <tadzik> rakudo: $=POD

[00:37] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "$=POD"␤»

[00:37] <tadzik> oh, whatever

[00:37] <jnthn> std: $=POD

[00:37] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 118m␤»

[00:37] <tadzik> it thinks it's $ = POD()

[00:37] <tadzik> :)

[00:37] <jnthn> nom: $=POD

[00:37] <p6eval> nom: OUTPUT«Non-declarative sigil is missing its name at line 1, near "$=POD"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[00:38] <jnthn> tadzik: I bet we're just missing token twigil:sym<=> { <sym> }

[00:38] *** [Coke] left
[00:38] <tadzik> mebbe

[00:38] <tadzik> I'll first put $POD in place

[00:40] *** [Coke] joined
[00:42] *** Qiang left
[00:53] <TimToady> phenny: tell masak just noticed that both multi fibs are missing a right paren

[00:53] <phenny> TimToady: I'll pass that on when masak is around.

[01:01] *** cxreg joined
[01:02] <tadzik> jnthn: sorry to bother you again, but I can't seem to be able to build list or anything in Actions.pm. I

[01:03] <tadzik> 'm trying my $pod := $*ST.add_constant('Array', 'type_new', $*POD_BLOCKS);, I tried 'List' too, and i get "Could not locate compile-time value for symbol Array"

[01:03] *** [Coke] left
[01:04] <jnthn> tadzik: odd

[01:04] *** wolfman2000 left
[01:04] <jnthn> tadzik: Where are you putting this cal?

[01:04] <jnthn> *call

[01:04] *** cooper joined
[01:04] *** Chillance left
[01:04] <tadzik> just after my $mainline := $<statementlist>.ast;

[01:05] <tadzik> part of a patch: http://wklej.org/id/556883/

[01:05] *** Chillance joined
[01:05] *** [Coke] joined
[01:06] *** Chillance left
[01:06] <jnthn> tadzik: oh...

[01:07] <jnthn> tadzik: Yeah, I see what's going on

[01:08] <jnthn> comp_unit is popping the setting in the grammar, before calling the action

[01:08] <jnthn> $*ST.pop_lexpad(); # UNIT_OUTER

[01:08] <tadzik> oh

[01:08] <jnthn> Unlucky :)

[01:09] <jnthn> Well, you could always stick the S*ST calls in Grammar.pm :)

[01:09] <jnthn> Or add a <.install_pod> or some such

[01:09] <tadzik> maybe that's why there are so many of them here :)

[01:10] <tadzik> but I need this whole bunch of action methods before I add_constant

[01:10] *** cognominal left
[01:10] <jnthn> tadzik: That's fine

[01:10] *** [Coke] left
[01:10] <jnthn> tadzik: You add it *after* statementlist

[01:10] <jnthn> But before the pop

[01:10] <tadzik> oh, ok

[01:10] <jnthn> *pos

[01:10] <jnthn> *pops

[01:10] <jnthn> gah, typing is hard :)

[01:11] <tadzik> oh, but... ah, I'll just try

[01:12] *** cognominal joined
[01:12] *** [Coke] joined
[01:17] *** wolfman2000 joined
[01:19] *** JimmyZ joined
[01:26] <dalek> rakudo/nom: 9928a0d | jonathan++ | src/Perl6/ (3 files):

[01:26] <dalek> rakudo/nom: First cut at constant. Only handles simple cases so far (e.g. literal on the RHS, and non-twigil variable or identifier with our/my scope).

[01:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9928a0d176

[01:28] *** Chillance joined
[01:28] <jnthn> if anyone fancies re-fudging S04-declarations/constant.t that'd be great.

[01:28] <tadzik> yay, segfault :)

[01:28] <tadzik> running through gdb

[01:29] <jnthn> tadzik: I assume that you actually are flattening the POD block array you pass to add_constant, BTW?

[01:29] <tadzik> em

[01:29] <jnthn> You weren't in the code you pasted

[01:29] <tadzik> ^C

[01:29] <tadzik> thanks jnthn :)

[01:29] <jnthn> :)

[01:31] <tadzik> that's ok, it

[01:31] <tadzik> 's still segfaulting :)

[01:34] <tadzik> and it's not under gdb. Great

[01:41] *** woosley joined
[01:42] *** fhelmberger_ joined
[01:43] *** fhelmberger left
[01:44] <tadzik> jnthn: $*POD_PAST := $*ST.add_constant(bla, bla); $*ST.install_lexical_symbol($*UNIT, '$POD', $*POD_PAST); -- would that be correct?

[01:45] <jnthn> You need $*POS_PAST<compile_time_value) when calling install_lexical_symbol

[01:45] <tadzik> thank you

[01:49] *** daniel-s joined
[01:51] <tadzik> > say $POD.perl

[01:51] <tadzik> ().list

[01:51] <tadzik> close enough :)

[01:52] <tadzik> I can now go to sleep hoping I won't forget everything I learned today

[01:55] <jnthn> \o/

[01:55] <jnthn> tadzik++

[01:56] <tadzik> now everything will be easy. I can create an empty List, then I can create a full Pod__Block too :P

[01:56] <tadzik> I hope :)

[01:56] <jnthn> :D

[01:57] * jnthn -> sightseeing

[01:58] <tadzik> zsh: segmentation fault  ./perl6 t/spec/S12-class/self-inheritance.t

[01:58] <tadzik> that's the downside :)

[01:58] <tadzik> jnthn: have fun!

[01:58] * tadzik -> sleeping

[02:19] *** JimmyZ left
[02:21] *** cognominal left
[02:27] *** cbk joined
[02:55] *** envi left
[02:56] <soh_cah_toa> does perl6 still have special variables like $| and $/ etc? in particular, i'm looking for $^O. i can't seem to find any docs on this

[02:57] *** envi joined
[02:58] <soh_cah_toa> oh wait, it's in S28. how did i miss that? :/

[03:01] *** perlhack joined
[03:02] <soh_cah_toa> although $*OSNAME does not seem to contain anything

[03:03] <perlhack> i'm back....

[03:05] *** JimmyZ joined
[03:06] <perlhack> JimmyZ:yw

[03:12] <perlhack> :-) what are you doing?

[03:14] *** perlhack left
[03:14] *** perlhack joined
[03:24] *** Su-Shee_ joined
[03:27] *** JimmyZ left
[03:27] *** Su-Shee left
[03:31] <soh_cah_toa> is it possible to define a sub at compile time inside a BEGIN block and call it at runtime? i'm trying to but i'm getting an error. i'm just wondering if there's some new p6 way for this

[03:35] <TimToady> more likely to work in nom or niecza than in rakudo

[03:35] <soh_cah_toa> ok

[03:36] <TimToady> but why do you need BEGIN when sub defs already happen at compile time?

[03:36] <soh_cah_toa> oh really? did not know that

[03:36] <TimToady> perl6: sub foo { say "bar" }; BEGIN foo

[03:37] <p6eval> niecza v7-11-g9ba8284: OUTPUT«bar␤»

[03:37] <p6eval> ..rakudo 72d158: OUTPUT«===SORRY!===␤Could not find sub &foo␤»

[03:37] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&BEGIN"␤    at /tmp/rbhXRQGRL_ line 1, column 24 - line 2, column 1␤»

[03:37] <TimToady> perl6: sub foo { say "bar" }; BEGIN { foo }

[03:37] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Could not find sub &foo␤»

[03:37] <p6eval> ..pugs, niecza v7-11-g9ba8284: OUTPUT«bar␤»

[03:37] <TimToady> nom: sub foo { say "bar" }; BEGIN { foo }

[03:37] <p6eval> nom: OUTPUT«Could not find sub &foo␤current instr.: '_block1005' pc 5 ((file unknown):29994341)␤»

[03:38] <TimToady> looks like nom still has issues there too

[03:38] <TimToady> probably just losing track of the lexical scope

[03:39] <TimToady> anyway, pugs and niecza have it right, though pugs doesn't know about curly-less BEGIN

[03:39] <soh_cah_toa> ok, i'll see if i can work around it

[03:40] <TimToady> nom: our sub foo { say "bar" }; BEGIN { foo }

[03:40] <p6eval> nom: OUTPUT«Could not find sub &foo␤current instr.: '_block1005' pc 5 ((file unknown):41362637)␤»

[03:40] <TimToady> nom: our sub foo { say "bar" }; BEGIN { OUR::foo }

[03:40] <p6eval> nom: OUTPUT«Could not find sub &die␤current instr.: '_block1005' pc 27 ((file unknown):67993283)␤»

[03:41] <TimToady> nom: our sub foo { say "bar" }; BEGIN { MAIN::foo }

[03:41] <p6eval> nom: OUTPUT«Could not find sub &die␤current instr.: '_block1005' pc 27 ((file unknown):57069251)␤»

[03:41] <TimToady> nom: say $?PACKAGE

[03:41] <p6eval> nom: OUTPUT«No method cache and no find_method method in meta-object␤current instr.: 'say' pc 282016 (src/gen/CORE.setting.pir:0) (:2586)␤»

[03:42] <TimToady> nom: sub foo { say "bar" }; BEGIN { UNIT::foo }

[03:42] <p6eval> nom: OUTPUT«Could not find sub &die␤current instr.: '_block1005' pc 27 ((file unknown):19)␤»

[03:42] *** JimmyZ joined
[03:42] <TimToady> ah well

[03:43] <soh_cah_toa> that's alright :)

[03:43] *** kaare_ joined
[03:49] <perlhack> that's alright :-)

[03:50] *** Trashlord left
[04:04] *** Eevee left
[04:04] <TimToady> sleep &

[04:05] <perlhack> :-)

[04:06] *** Eevee_ joined
[04:12] *** Sarten-X left
[04:18] *** Sarten-X joined
[04:19] *** Bzek joined
[04:28] <JimmyZ> BJPW videos was uploaded,  http://v.ku6.com/playlist/index_4350502.html

[04:30] <JimmyZ> Please tell me if it cann't be visited

[04:57] *** Eevee_ is now known as Eevee

[05:13] <jnthn> TimToady: I've got the "run in correct context" for BEGIN time stuff stubbed, just didn't actually finish that up yet. nom will handle BEGIN much better than master, anyways.

[05:19] *** birdwindupbird joined
[05:20] *** koban joined
[05:24] *** birdwindupbird left
[05:25] *** birdwindupbird joined
[05:25] *** daniel-s left
[05:37] *** perlhack left
[05:54] *** wamba joined
[06:05] *** wamba left
[06:10] <jnthn> nom:P say +Any

[06:10] <jnthn> nom: say +Any

[06:10] <p6eval> nom: OUTPUT«Method 'Numeric' not found for invocant of class 'Any'␤current instr.: 'prefix:<+>' pc 272899 (src/gen/CORE.setting.pir:67157) (:726)␤»

[06:10] *** soh_cah_toa left
[06:11] <jnthn> perl6: say +Any

[06:11] <p6eval> rakudo 72d158: OUTPUT«Use of uninitialized value in numeric context  in 'Any::Numeric' at line 1498:src/gen/core.pm␤0␤»

[06:11] <p6eval> ..pugs, niecza v7-11-g9ba8284: OUTPUT«0␤»

[06:17] *** Su-Shee_ is now known as Su-Shee

[06:22] *** Vlavv left
[06:26] <moritz> good morning

[06:28] <jnthn> morning, moritz 

[06:30] <moritz> $ ./perl6 t/spec/S02-builtin_data_types/parsing-bool.t 

[06:30] <moritz> Object of type 'Bool' cannot be referenced without having been assigned a serialization context

[06:31] <moritz> that looks like a regression

[06:31] <jnthn> I'm mostly confused why that test keeps getting added back

[06:31] <jnthn> It's never passed for me.

[06:31] <moritz> oh

[06:31] <jnthn> It ended up uncommented in spectest.data once before but failed for me too.

[06:32] *** wtw joined
[06:32] <jnthn> I highly doubt it's going to work until I actually do enums :)

[06:32] <moritz> I'll comment it out again

[06:33] <jnthn> Thanks

[06:33] <jnthn> I plan to look at enums in the near future

[06:33] <jnthn> Since a lot of things want Bool::True and Bool::False

[06:33] *** Vlavv joined
[06:34] *** drbean left
[06:36] <dalek> roast: a58918d | moritz++ | S02-literals/misc-interpolation.t:

[06:36] <dalek> roast: fudge misc-interpolation.t for nom

[06:36] <dalek> roast: review: https://github.com/perl6/roast/commit/a58918d93d

[06:36] <jnthn> moritz: If you have time for a couple of test twiddles today: constant.t (S04-declarator) could bere-fudged. We never ran it in master.

[06:36] <jnthn> afaik

[06:37] <jnthn> moritz: Also, imo binding-attributes.t is wrong in thinking that public attrs through the accessor can be bound

[06:37] <jnthn> They can't; only $!foo form can

[06:37] <moritz> makes sense

[06:37] <jnthn> I suspect that one passes if we toss the public binding tests.

[06:37] <jnthn> Another win over master - that file ain't even in spectest.data :)

[06:38] <dalek> rakudo/nom: c4d4a74 | moritz++ | t/spectest.data:

[06:38] <dalek> rakudo/nom: run three more spectest files, remove one that never passed

[06:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c4d4a74730

[06:39] <dalek> roast: 6c80155 | jonathan++ | S03-operators/equality.t:

[06:39] <dalek> roast: Untodo 3 tests that nom handles that master didn't.

[06:39] <dalek> roast: review: https://github.com/perl6/roast/commit/6c80155243

[06:39] <dalek> roast: d294b31 | jonathan++ | S12-methods/submethods.t:

[06:39] <dalek> roast: Correct a test that made a bad assumption about attribute inheritance.

[06:39] <dalek> roast: review: https://github.com/perl6/roast/commit/d294b31b79

[06:39] <dalek> rakudo/nom: 0562684 | jonathan++ | src/core/IO.pm:

[06:40] <dalek> rakudo/nom: Get print and say to use $*OUT; add note which uses $*ERR.

[06:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/05626847ab

[06:40] <dalek> rakudo/nom: d586e07 | jonathan++ | src/core/Mu.pm:

[06:40] <dalek> rakudo/nom: Add warning to use of uninitialized value in string context, and make uninitialized value in numeric context warn and give back 0.

[06:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d586e07840

[06:40] <dalek> rakudo/nom: 34c2983 | jonathan++ | t/spectest.data:

[06:40] <dalek> rakudo/nom: We now pass S03-operators/equality.t.

[06:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/34c29834fc

[06:45] <dalek> roast: 092ab84 | moritz++ | S03-operators/binding-attributes.t:

[06:45] <dalek> roast: fudge binding-attributes.t for nom

[06:45] <dalek> roast: review: https://github.com/perl6/roast/commit/092ab847e7

[06:46] <dalek> rakudo/nom: 23f5fbd | jonathan++ | LHF.markdown:

[06:46] <dalek> rakudo/nom: Add a LHF.

[06:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/23f5fbd897

[06:46] <jnthn> nom: (1 + 2i)    ~~ (1 + 2i)

[06:46] <p6eval> nom: OUTPUT«maximum recursion depth exceeded␤current instr.: 'Numeric' pc 300357 (src/gen/CORE.setting.pir:81212) (:710)␤»

[06:46] <jnthn> ew :)

[06:49] <dalek> rakudo/nom: 157e4f8 | jonathan++ | LHF.markdown:

[06:49] <dalek> rakudo/nom: Another (hopefully) LHF.

[06:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/157e4f8754

[06:52] <moritz> I think that's LHF indeed

[06:54] <moritz> perl6: say (1 + 0i) == 1

[06:54] <p6eval> rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«Bool::True␤»

[06:54] <p6eval> ..pugs: OUTPUT«1␤»

[06:56] <dalek> rakudo/nom: abd6769 | moritz++ | t/spectest.data:

[06:56] <dalek> rakudo/nom: we pass a (highly fudged) binding-attributes.t

[06:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abd6769686

[06:59] <dalek> rakudo/nom: 8b36d09 | moritz++ | / (3 files):

[06:59] <dalek> rakudo/nom: infix == for Complex, wins us back any-complex.t. jnthn++

[06:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b36d09793

[07:05] <dalek> rakudo/nom: 78388ab | moritz++ | t/spectest.data:

[07:05] <dalek> rakudo/nom: run constant.t

[07:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/78388ab031

[07:05] <moritz> jnthn++

[07:05] <moritz> evalbot rebuild nom

[07:05] <p6eval> OK (started asyncronously)

[07:06] <jnthn> moritz: I'm guessing constant.t had to be fudged a good bit?

[07:06] <moritz> jnthn: yes

[07:07] <moritz> jnthn: it doesn't like all literals (example: lists and hashes)

[07:07] <jnthn> They're not really literal enough :)

[07:07] <moritz> :-)

[07:07] * jnthn tries to improve the state of Bool without doing enums

[07:08] <moritz> turns out I can't use 1i in the setting

[07:09] <moritz> so I can't write  constant i = 1i;  either

[07:09] <jnthn> nom: constant i = 1i;

[07:09] <p6eval> nom:  ( no output )

[07:09] <jnthn> nom: constant i = 1i; say i

[07:09] <p6eval> nom: OUTPUT«0 + 1i␤»

[07:09] <mathw> o/

[07:09] <jnthn> oh

[07:09] <jnthn> in the setting

[07:09] <jnthn> right

[07:09] <jnthn> o/ mathw 

[07:09] <moritz> it complains about missing infix:<~>

[07:09] *** birdwindupbird left
[07:10] *** birdwindupbird joined
[07:10] <mathw> Semi-random query: does nom allow (or does it provide the basis for allowing) the Setting to be made as individual files which don't have to be concatenated together and compiled in one huge memory-guzzling multicore-unfriendly lump?

[07:11] <jnthn> mathw: no

[07:11] <jnthn> mathw: Rather, we plan to make compiling CORE.setting be less of a headache :)

[07:11] <moritz> mathw: it's still a big, concatenated file, but it's not quite as memory hungry as it was before

[07:11] <mathw> okay

[07:11] <jnthn> mathw: Match and Cursor objects are already a bunch lighter in terms of memory

[07:11] <moritz> nom: constant e = 2.71828183e0; say e

[07:11] <p6eval> nom: OUTPUT«2.71828183␤»

[07:12] <jnthn> PAST nodes are going to get 3 times lighter in terms of GCables.

[07:12] <mathw> nice

[07:12] <mathw> I've been following the performance wins, it's very exciting

[07:12] <jnthn> So I'm hopeful we'll get to the point where compiling it as one big file ain't painful any more.

[07:13] <mathw> that'll do

[07:13] <jnthn> aha, seems I can get us to *really* pass parsing-bool.t at last :)

[07:13] <jnthn> nom: say Bool::True

[07:13] <p6eval> nom: OUTPUT«Object of type 'Bool' cannot be referenced without having been assigned a serialization context␤current instr.: 'nqp;HLL;Compiler;SerializationContextBuilder;get_object_sc_ref_past' pc 45261 (src/stage2/gen/NQPHLL.pir:15581)␤»

[07:13] <jnthn> That works locally

[07:18] <dalek> rakudo/nom: add464b | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[07:18] <dalek> rakudo/nom: Fix Bool up a bit more; now Bool::True, Bool::False, True and False can all be mentioned.

[07:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/add464b508

[07:18] <dalek> rakudo/nom: 2ddc07d | jonathan++ | t/spectest.data:

[07:18] <dalek> rakudo/nom: Now we *really* pass parsing-bool.t. :-)

[07:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2ddc07da4f

[07:19] <moritz> :-)

[07:20] <jnthn> I bet we get a few spectests back from this

[07:20] <moritz> I'm running update_passing_test_files now

[07:20] <jnthn> excellent

[07:23] <dalek> rakudo/nom: b2b27f6 | jonathan++ | NOMMAP.markdown:

[07:23] <dalek> rakudo/nom: Few nommap updates.

[07:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b2b27f6503

[07:26] *** mj41 joined
[07:29] *** ab5tract joined
[07:31] *** Eevee left
[07:50] *** daniel-s joined
[07:54] *** birdwindupbird left
[07:54] *** birdwindupbird joined
[07:55] *** donri left
[07:59] <dalek> rakudo/nom: edef5dc | moritz++ | src/core/Num.pm:

[07:59] <dalek> rakudo/nom: add pi and e constants

[07:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/edef5dce82

[07:59] <dalek> rakudo/nom: 11972a9 | moritz++ | t/spectest.data:

[07:59] <dalek> rakudo/nom: 3 more passing test files

[07:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/11972a96dc

[07:59] <dalek> rakudo/nom: 179d411 | moritz++ | / (2 files):

[08:00] <dalek> rakudo/nom: implement Int.Rat, pass unpolar.t

[08:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/179d411e18

[08:04] <jnthn> moritz: (pi and e constants) suggest my constant ... - this is the setting, and constant defaults to our-scoped.

[08:05] <moritz> jnthn: right, will fix

[08:09] <jnthn> moritz: Did you push re-fudged constant.t?

[08:10] <dalek> rakudo/nom: dff16a7 | jonathan++ | / (3 files):

[08:10] <dalek> rakudo/nom: Add Whatever.pm with an ACCEPTS that accepts everything, plus its own new.

[08:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dff16a76e8

[08:10] <dalek> rakudo/nom: 362947a | jonathan++ | src/core/Mu.pm:

[08:10] <dalek> rakudo/nom: Turn new into a multi. Add a candidate that dies if you try to give positional arguments. Update bless so it can take * as an initial parameter and create a candidate; inline this rather than calling .CREATE and use it in .new, thus saving a method invocation per .new call.

[08:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/362947a05c

[08:28] <moritz> nom: say log(1 + 2i)

[08:28] <p6eval> nom: OUTPUT«0.80471895621705 + 1.10714871779409i␤»

[08:30] *** drbean joined
[08:34] *** wamba joined
[08:35] *** kst` joined
[08:37] *** stepnem_ joined
[08:37] *** satyavvd joined
[08:38] *** BinGOs_ joined
[08:40] *** dakkar joined
[08:42] <dalek> rakudo/nom: 3cae1b4 | moritz++ | src/core/Num.pm:

[08:42] <dalek> rakudo/nom: constants should be "my", jnthn++

[08:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3cae1b46d8

[08:42] <dalek> rakudo/nom: c14785b | moritz++ | / (2 files):

[08:42] <dalek> rakudo/nom: make log.t pass again

[08:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c14785bb30

[08:43] *** kst left
[08:43] *** stepnem left
[08:43] *** dju left
[08:43] *** stepnem_ is now known as stepnem

[08:43] *** BinGOs_ is now known as BinGOs

[08:43] *** BinGOs left
[08:43] *** BinGOs joined
[08:43] * daniel-s is a little confused

[08:44] <daniel-s> when you're creating a class with a non-default constructor

[08:44] <daniel-s> does the constructor have to be called BUILD

[08:44] <daniel-s> or is it any method that returns a self.bless()

[08:44] <daniel-s> or rather, returns an object using that method

[08:45] <moritz> BUILD is not a constructor

[08:45] <moritz> BUILD is automatically by (I think) bless

[08:46] <moritz> http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html

[08:46] <jnthn> By BUILDALL

[08:46] <daniel-s> thanks, moritz++

[08:47] *** agentzh joined
[08:48] *** daxim joined
[08:53] <dalek> roast: b35368d | moritz++ | S04-declarations/constant.t:

[08:53] <dalek> roast: fduge constant.t for rakudo

[08:53] <dalek> roast: review: https://github.com/perl6/roast/commit/b35368dd03

[08:53] <dalek> roast: 217021a | moritz++ | S02-builtin_data_types/num.t:

[08:53] <dalek> roast: fudge num.t for rakudo

[08:53] <dalek> roast: review: https://github.com/perl6/roast/commit/217021a3b4

[08:53] <dalek> roast: 4a43fe3 | moritz++ | S (5 files):

[08:53] <dalek> roast: random rakudo unfudges

[08:53] <dalek> roast: review: https://github.com/perl6/roast/commit/4a43fe3ba4

[08:55] <daniel-s> how do multi-dimensional arrays work in perl6

[08:55] <daniel-s> I don't think I've seen any documentation for that

[08:56] <daniel-s> eg. in Java, a 10 by 10 grid could be created using "int[][] grid = new int[10][10];"

[08:57] <daniel-s> I find it difficult to put arrays inside arrays in perl

[08:57] <dalek> rakudo/nom: a2aea3d | moritz++ | t/spectest.data:

[08:57] <dalek> rakudo/nom: pass num.t

[08:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a2aea3d35f

[08:57] <daniel-s> because they just get turned into one long array

[08:57] *** birdwindupbird left
[08:58] *** birdwindupbird joined
[08:59] <jnthn> (arrays inside arrays) how are you trying to do it?

[08:59] <jnthn> nom: my @x = [1,2,3], [4,5,6]; say @x[1][1]

[08:59] <p6eval> nom: OUTPUT«5␤»

[09:01] <arnsholt> daniel-s: The parens for list construction have some fiddly semantics, like auto-flattening

[09:01] <arnsholt> (Which I'm guessing is how you tried to make a 2D array)

[09:02] *** pnu left
[09:03] *** birdwindupbird left
[09:04] *** birdwindupbird joined
[09:05] *** pnu joined
[09:05] <dalek> roast: 2a3437e | moritz++ | S32-str/uc.t:

[09:05] <dalek> roast: fudge uc.t for rakudo

[09:05] <dalek> roast: review: https://github.com/perl6/roast/commit/2a3437ea38

[09:06] <daniel-s> nom: my @a = [1,2,3], [4,5,6]; say @a[1][1];

[09:06] <p6eval> nom: OUTPUT«5␤»

[09:06] <daniel-s> my @a = (1,2,3), (4,5,6); say @a[1][1];

[09:07] <daniel-s> nom: my @a = (1,2,3), (4,5,6); say @a[1][1];

[09:07] <p6eval> nom: OUTPUT«.[1] out of range for type 2␤current instr.: 'rethrow' pc 334635 (src/gen/CORE.setting.pir:95721) (:3118)␤»

[09:07] <daniel-s> I was using round brackets

[09:07] <dalek> roast: 8b36d58 | moritz++ | S32-str/lc.t:

[09:07] <dalek> roast: fudge lc.t for rakudo

[09:07] <dalek> roast: review: https://github.com/perl6/roast/commit/8b36d58573

[09:13] <tadzik> good morning #perl6

[09:13] <jnthn> morning, tadzik 

[09:14] <moritz> \o

[09:14] <dalek> rakudo/nom: 1f421d3 | moritz++ | t/spectest.data:

[09:14] <dalek> rakudo/nom: more passing tests

[09:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f421d3743

[09:15] <moritz> tadzik: FYI I will be travelling from Tuesday to Sunday. I exepct to have OK-ish internet from Wednesday to Saturday; if not, and during the commute days, I'll defer you to jnthn++ and masak++

[09:17] <tadzik> moritz: okay, have fun :)

[09:17] <moritz> tadzik: you too :-)

[09:17] <tadzik> oh I have :)

[09:17] <tadzik> have you see $POD working

[09:17] <tadzik> ?

[09:17] <moritz> tadzik: no, which branch is that?

[09:18] <tadzik> moritz: podparser, but not pushed. Still has some funny issues, as in random segfaults and so ;)

[09:18] <moritz> tadzik: ah, no wonder I didn't see it :-)

[09:18] <tadzik> moritz: so far I can create a List in compile time, and expose it to runtime

[09:18] <tadzik> now I only have to fill it with data :)

[09:18] <moritz> tadzik: I did backlog and see that you've made some progress...

[09:19] <tadzik> aye :)

[09:19] <tadzik> exciting times

[09:19] <moritz> tadzik: if you push your changes (even if not perfect), others might be able to help you

[09:19] <moritz> so, push early, push often

[09:19] <tadzik> I will

[09:19] <tadzik> jnthn: 5:20 PM in Beijing, right?

[09:20] <jnthn> tadzik: yes

[09:21] *** woosley left
[09:22] <jnthn> for me, S06-signature\unspecified.rakudo has TODO passed:   15

[09:22] <jnthn> Anyone else got that?

[09:22] <moritz> yes

[09:23] *** birdwindupbird left
[09:23] *** birdwindupbird joined
[09:26] <dalek> rakudo/podparser: e44bddd | tadzik++ | src/Perl6/SymbolTable.pm:

[09:26] <dalek> rakudo/podparser: [SymbolTable] Allow named parameters to type_new in add_constant()

[09:26] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/e44bddd65c

[09:26] <dalek> rakudo/podparser: 836c553 | tadzik++ | src/Perl6/ (2 files):

[09:26] <dalek> rakudo/podparser: Install $POD into the $*UNIT scope as an List (empty so far)

[09:26] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/836c553732

[09:29] <tadzik> oh, chromatic++ is optimizing Parrot again :)

[09:29] *** envi left
[09:29] <moritz> indeed :-)

[09:31] <jnthn> Wow, we're around 2000 tests again :)

[09:34] *** envi joined
[09:35] <tadzik> the podparser branch segfaults on t/spec/S12-class/self-inheritance.t

[09:35] <tadzik> I'll look into that in a second

[09:37] <dalek> rakudo/nom: a0d429e | jonathan++ | src/ (3 files):

[09:37] <dalek> rakudo/nom: First cut of support for automatically calling BUILD and initializing public attributes based on named arguments to .new/.bless. Doesn't yet handle default values or auto-vivifying type objects.

[09:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a0d429e508

[09:39] <tadzik> moritz: btw, the Exception case won't work for me, for I'll have a class Block {}, and that (so far) conflicts with the toplevel Block class. I've added it to NOMMAP for jnthn++

[09:40] <moritz> nom: my namespace Pod { class Block { } }; say Pod::Block

[09:40] <p6eval> nom: OUTPUT«Malformed my at line 1, near "namespace "␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[09:40] <moritz> nom: my package Pod { class Block { } }; say Pod::Block

[09:40] <p6eval> nom: OUTPUT«Illegal redeclaration of class 'Block' at line 1, near "{ } }; say"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[09:40] <moritz> tadzik: ok, I'm convinced :-)

[09:41] <dalek> roast: 8bb65b5 | moritz++ | S29-conversions/ord_and_chr.t:

[09:41] <dalek> roast: correct ord_and_chr.t (precedence, calling positionals by name), and fudge for rakudo

[09:41] <dalek> roast: review: https://github.com/perl6/roast/commit/8bb65b5958

[09:43] <dalek> roast: 6bb9d97 | moritz++ | S32-array/kv.t:

[09:43] <dalek> roast: start to fudge kv.t for rakudo. Not runnable yet

[09:43] <dalek> roast: review: https://github.com/perl6/roast/commit/6bb9d97b55

[09:45] *** Trashlord joined
[09:48] *** birdwindupbird left
[09:48] *** birdwindupbird joined
[09:48] *** sftp left
[09:49] <jnthn> heh

[09:50] <jnthn> S12-attributes/undeclared.t fails to compile now

[09:50] <jnthn> Because nom detects the failure at compile time rather than runtime :)

[09:50] <moritz> so it needs to be eval_dies_ok

[09:51] *** sftp joined
[09:52] <moritz> should I fix that?

[09:56] <moritz> rakudo: my @a; say @a ~~ Positional

[09:56] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[09:57] <moritz> nom: my @a; say @a ~~ Positional

[09:57] <p6eval> nom: OUTPUT«Bool::True␤»

[09:57] <moritz> nom: sub push(@a, *@args) {@a.push: @args }; push my @a, 1

[09:57] <p6eval> nom:  ( no output )

[09:57] <moritz> nom: sub push(@a, *@args) {@a.push: @args }; push my @a, 1; say @a

[09:57] <p6eval> nom: OUTPUT«1␤»

[09:58] <moritz> nom: proto sub push(|$) {*}; multi sub push(@a, *@elems) { @a.push: @elems }; push my @a, 1; say @a

[09:58] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'push'. Available candidates are:␤:(Positional @a, Positional @elems)␤␤current instr.: 'push' pc 454 ((file unknown):162) (:1)␤»

[09:58] <moritz> jnthn: that looks a bit botched up

[09:58] <moritz> work for single dispatch, but not for multi

[09:59] <moritz> also Positional @a in the signature is RONG

[10:02] *** wamba left
[10:04] <jnthn> Signature.perl is gnerally RONG

[10:05] <jnthn> Not sure why the multi dispatch is failing though

[10:07] <dalek> roast: d417a87 | jonathan++ | S12-class/lexical.t:

[10:07] <dalek> roast: Update a test for latest stringification semantics.

[10:07] <dalek> roast: review: https://github.com/perl6/roast/commit/d417a8721c

[10:08] <tadzik> funny t/spec/S12-class/self-inheritance.t, stopped segfaulting after nom merge

[10:08] <jnthn> Heisenbug :/

[10:08] <dalek> rakudo/nom: 478a82d | jonathan++ | t/spectest.data:

[10:08] <dalek> rakudo/nom: Two more passing test files.

[10:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/478a82dae2

[10:09] <dalek> rakudo/podparser: 7bec705 | tadzik++ | / (25 files):

[10:09] <dalek> rakudo/podparser: Merge branch 'nom' into podparser

[10:09] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/7bec7059f6

[10:14] *** am0c joined
[10:18] *** masak joined
[10:19] <masak> ahhai.

[10:19] <phenny> masak: 03 Jul 23:59Z <lue> tell masak in your 26 June post, the last two code examples are missing a ) on the last line.

[10:19] <phenny> masak: 00:53Z <TimToady> tell masak just noticed that both multi fibs are missing a right paren

[10:19] <masak> thanks, both of you :)

[10:19] <masak> will fix when I get home.

[10:20] <masak> people, I came here to say that this 'nom' thing is really big. people know that Perl 6 is the underdog, and they'd love for it to succeed.

[10:20] <masak> so let's make the Rakudo nom release a splash. it might yield a bigger response than Star.

[10:20] <masak> just think about that :)

[10:21] <jnthn> Success means hard work :)

[10:21] <jnthn> er

[10:21] *** birdwindupbird left
[10:21] <jnthn> comes from hard work :)

[10:21] <moritz> masak: right, there's a lot of things in LHF.markdown. Your patches are very welcome! :-)

[10:22] <jnthn> masak: I suspect the big splash will want to come when we land the optimizer.

[10:22] *** _twitch joined
[10:22] <masak> moritz: I want to contribute. but I also want to finish the June blogging properly.

[10:22] <masak> most of my tuits are going there currently.

[10:23] <jnthn> masak: Plus the fact that by then we'll have had chance for the nom fallout to settle :)

[10:23] <masak> jnthn: right. we have to be careful to point out that the optimizer is coming a bit after nom lands.

[10:23] <jnthn> (which, yes, should be less than the alpha => ng fallout...)

[10:23] <masak> jnthn: maybe even undersell nom and wait with the splash till the optimizer lands.

[10:23] <jnthn> masak: I'd say so.

[10:23] <masak> jnthn: you keep saying that :)

[10:24] <jnthn> masak: btw, today an alpha but not ng feature returned :)

[10:24] <jnthn> nom: constant answer = 42; say answer

[10:24] <p6eval> nom: OUTPUT«42␤»

[10:25] <masak> \o/

[10:25] *** donri joined
[10:25] <masak> when nom lands, I can retroactively change some of my June blog posts.

[10:27] * jnthn makes nom null pmc access

[10:27] <jnthn> That's...not common these days :)

[10:27] <moritz> but not too hard either

[10:27] <moritz> just trigger some action method that hasn't been nomified  yet

[10:30] <jnthn> oh, yes

[10:30] <jnthn> that'll do it :)

[10:36] *** mj41 left
[10:36] <flussence> nom: say qx(echo "G'morning, #perl6!"); # :)

[10:36] <p6eval> nom: OUTPUT«Could not find sub &echo␤current instr.: '_block1002' pc 75 ((file unknown):86780934) (:1)␤»

[10:37] <flussence> (well, I wasn't expecting *that*...)

[10:37] <flussence> rakudo: say qx(echo "doesn't qx autoquote?")

[10:37] <p6eval> rakudo 72d158: OUTPUT«Could not find sub &echo␤  in main program body at line 22:/tmp/5FS9ViUyrF␤»

[10:37] <flussence> oh, just me then

[10:38] *** birdwindupbird joined
[10:41] <masak> I'm so proud that perlhack is using the greetings I gave him when he enters the channel :)

[10:41] <jnthn> I hope they weren't rude ones :P

[10:42] <dalek> rakudo/nom: a0c28ce | jonathan++ | src/ (3 files):

[10:42] <dalek> rakudo/nom: First cut of defaults for attributes. Still to do is only to do this to untouched attributes.

[10:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a0c28ce5f0

[10:42] <dalek> rakudo/nom: abdcbc3 | jonathan++ | src/Perl6/Actions.pm:

[10:42] <dalek> rakudo/nom: Fix attributes refering to others in default value.

[10:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abdcbc3d2a

[10:48] *** awoodland joined
[10:51] <masak> rude greetings? in #perl6? :)

[10:52] <jnthn> It's kinda too nice for them here, I guess :)

[10:54] * masak .oO( "it's an affectionate term for 'female dogs'! surely you know that!" )

[10:54] <jnthn> yo dawg, I heard you like being greeted

[10:54] <Su-Shee> YOH BITCHES WAZZ UP? ;)

[10:55] *** Mowah joined
[10:56] *** Trashlord left
[10:56] <masak> Su-Shee: it's "whoz op" :P

[10:57] <Su-Shee> damn, I failed the ghetto slang exam.. ;)

[10:57] <dalek> roast: c850dd5 | jonathan++ | S12-attributes/inheritance.t:

[10:57] <dalek> roast: Fully unfudge S12-attributes/inheritance.t; nom gets attribute access correct.

[10:57] <dalek> roast: review: https://github.com/perl6/roast/commit/c850dd5b54

[10:58] *** am0c left
[10:58] *** am0c joined
[10:59] <dalek> rakudo/nom: 91077bf | jonathan++ | src/core/Mu.pm:

[10:59] <dalek> rakudo/nom: Implement $obj.Parent::bar().

[10:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/91077bf506

[10:59] <dalek> rakudo/nom: 2302959 | jonathan++ | t/spectest.data:

[10:59] <dalek> rakudo/nom: We now fully (unlike master) pass S12-attributes/inheritance.t.

[10:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2302959e1e

[10:59] <dalek> rakudo/nom: 4dd86c6 | jonathan++ | NOMMAP.markdown:

[10:59] <dalek> rakudo/nom: Update nommap.

[10:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4dd86c6ce3

[11:02] <tadzik> hey, I won't merge nom every 5 minutes! :P

[11:02] *** mj41 joined
[11:04] <jnthn> nom: say 1 === 1

[11:04] <p6eval> nom: OUTPUT«Bool::True␤»

[11:04] <jnthn> nom: say [===] 1, 2

[11:04] <p6eval> nom: OUTPUT«invoke() not implemented in class 'Failure'␤current instr.: '_block1002' pc 104 ((file unknown):28114338) (:1)␤»

[11:04] <jnthn> nom: say [==] 1, 2

[11:04] <p6eval> nom: OUTPUT«invoke() not implemented in class 'Failure'␤current instr.: '_block1002' pc 104 ((file unknown):30141858) (:1)␤»

[11:05] <jnthn> nom: say [+] 1, 2

[11:05] <p6eval> nom: OUTPUT«3␤»

[11:05] <jnthn> phenny: tell pmichaud seems there's something not quite right with reduction ops... [===] 1,1 don't work

[11:05] <phenny> jnthn: I'll pass that on when pmichaud is around.

[11:06] *** JimmyZ left
[11:06] *** Trashlord joined
[11:11] *** whiteknight joined
[11:13] <dalek> roast: 17a10d0 | jonathan++ | S12-methods/submethods.t:

[11:13] <dalek> roast: A couple of corrections to submethods.t, plus unfudge another couple.

[11:13] <dalek> roast: review: https://github.com/perl6/roast/commit/17a10d092e

[11:15] <tadzik> jnthn: how do I make "bacon" a valid SixModelObject? get_object_sc_ref_past complains about it

[11:16] <dalek> rakudo/nom: c3d1dcf | jonathan++ | t/spectest.data:

[11:16] <dalek> rakudo/nom: Run S12-methods/submethods.t.

[11:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3d1dcfb62

[11:17] <jnthn> you don't make something one

[11:18] <jnthn> you should just have one in the first place

[11:19] <tadzik> I run add_constant with :name<bacon>. Then for %named { say("Adding", $_.value, " as ", $_.key); ...} says "Addingbacon as name". But then the stacktrace, Can only use nqp_get_sc_for_object with a SixModelObject on my $x := self.get_object_sc_ref_past($_.value);

[11:20] <jnthn> Right

[11:20] <jnthn> You passed a Parrot string

[11:20] <jnthn> You neded to $*ST.add_constant('Str', 'str', 'bacon') 

[11:20] <tadzik> I see

[11:20] <jnthn> And pass the compile_time_value from that as :name(...)

[11:21] <tadzik> makes sense, thanks jnthn 

[11:21] <jnthn> np

[11:22] <jnthn> Files=122, Tests=2234 :)

[11:22] <tadzik> awesome

[11:22] <jnthn> oh, that exludes the one I just added too :)

[11:22] <tadzik> all this moves too fast

[11:23] <tadzik> when I run 'make', it should pass the spectest, but when I run 

[11:23] <tadzik> 'make spectest' after that, the roast already changes :)

[11:25] * jnthn makes life easier for tadzik++ by going for dinner :)

[11:25] <tadzik> :)

[11:25] <tadzik> look, look

[11:26] <tadzik> http://wklej.org/id/557009/

[11:26] <tadzik> I'm on the right track :)

[11:26] <tadzik> but the name is not what it should be, it seems

[11:29] <moritz> evalbot rebuild nom

[11:29] <p6eval> OK (started asyncronously)

[11:33] <dalek> roast: 77ce764 | moritz++ | S06-signature/unspecified.t:

[11:33] <dalek> roast: unfudge S06-signature/unspecified.t for rakudo

[11:33] <dalek> roast: review: https://github.com/perl6/roast/commit/77ce7640fa

[11:33] *** dju joined
[11:34] *** mj41 left
[11:36] <masak> tadzik++

[11:40] *** cognominal joined
[11:44] <dalek> roast: ab99d48 | moritz++ | S02-builtin_data_types/type.t:

[11:44] <dalek> roast: fudge and fix type.t

[11:44] <dalek> roast: review: https://github.com/perl6/roast/commit/ab99d487ce

[11:47] <dalek> rakudo/podparser: c3c1aba | moritz++ | t/spectest.data:

[11:47] <dalek> rakudo/podparser: we pass ord_and_chr.t

[11:47] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/c3c1aba630

[11:47] <dalek> rakudo/podparser: f13f52b | moritz++ | t/spectest.data:

[11:47] <dalek> rakudo/podparser: two more passing test files

[11:47] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/f13f52b3b2

[11:47] *** satyavvd left
[11:47] <moritz> \o/ double karma!

[11:50] *** JimmyZ joined
[11:50] <tadzik> moritz: was the push to podparser intentional? :)

[11:50] <moritz> tadzik: oh no, wrong branch

[11:50] <tadzik> :)

[11:51] <moritz> tadzik: sorry for messing with your stuff

[11:51] <tadzik> moritz: hey, you're welcome :)

[11:51] <tadzik> I now have to merge nom :P

[11:52] <moritz> I'll cherry-pick those two commits to nom

[11:59] <dalek> rakudo/nom: 1b7e7f3 | moritz++ | t/spectest.data:

[11:59] <dalek> rakudo/nom: we pass ord_and_chr.t

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1b7e7f31ab

[11:59] <dalek> rakudo/nom: 1f659be | moritz++ | t/spectest.data:

[11:59] <dalek> rakudo/nom: two more passing test files

[11:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f659be45a

[12:01] <dalek> roast: a4c0620 | moritz++ | S12-class/anonymous.t:

[12:01] <dalek> roast: (un)fudge anonymous.t for rakudo

[12:01] <dalek> roast: review: https://github.com/perl6/roast/commit/a4c0620f21

[12:06] <dalek> roast: 2e90102 | moritz++ | S02-whitespace_and_comments/minimal-whitespace.t:

[12:06] <dalek> roast: refudge minimal-whitespace.t

[12:06] <dalek> roast: review: https://github.com/perl6/roast/commit/2e90102527

[12:11] <moritz> jnthn: t/spec/S12-attributes/recursive.t fails in an interesting way

[12:11] <moritz> jnthn: the exception (hidden in the lives_ok) is "Type check failed in assignment to '$!attr'; expected 'A' but got 'Scalar'"

[12:12] <moritz> it seems the type check should decontainerize the LHS, or some such

[12:14] *** mj41 joined
[12:16] <dalek> roast: 8433461 | moritz++ | S03-operators/autoincrement.t:

[12:16] <dalek> roast: fudge autoincrement.t for rakudo

[12:16] <dalek> roast: review: https://github.com/perl6/roast/commit/8433461144

[12:17] <dalek> rakudo/nom: 939629a | moritz++ | t/spectest.data:

[12:17] <dalek> rakudo/nom: 5 more passing test files

[12:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/939629a58b

[12:21] <moritz> Files=132, Tests=2868

[12:21] <flussence> wow

[12:21] <flussence> that was ~1000 the other day

[12:23] *** woosley joined
[12:23] <tadzik> yep

[12:23] <moritz> jnthn++ made a lot of progress, I pimped up the numerical part of the setting, and there were lots of LHFs

[12:25] <masak> jnthn++ moritz++

[12:28] *** icwiener joined
[12:45] <JimmyZ> nom++

[12:49] *** pernatiy joined
[12:57] *** Mowah left
[13:02] *** bluescreen10 left
[13:03] *** bluescreen100 left
[13:05] *** cognominal left
[13:06] *** agentzh left
[13:07] *** cognominal joined
[13:15] *** bluescreen100 joined
[13:15] *** bluescreen10 joined
[13:20] *** wamba joined
[13:20] *** wamba left
[13:24] *** JimmyZ_ joined
[13:26] <pmichaud> good morning, #perl6

[13:26] <phenny> pmichaud: 11:05Z <jnthn> tell pmichaud seems there's something not quite right with reduction ops... [===] 1,1 don't work

[13:26] <pmichaud> 13:26 <phenny> pmichaud: 11:05Z <jnthn> tell pmichaud seems there's something not quite right with reduction ops... [===] 1,1 don't work

[13:26] <pmichaud> chained reductions nyi.... although it's supposed to tell you that :)

[13:26] <pmichaud> checking.

[13:27] <masak> morning, pm

[13:27] *** JimmyZ left
[13:27] *** JimmyZ_ is now known as JimmyZ

[13:31] <pmichaud> say [===] 1,1

[13:31] <pmichaud> nom: say [===] 1,1

[13:31] <p6eval> nom: OUTPUT«invoke() not implemented in class 'Failure'␤current instr.: '_block1002' pc 104 ((file unknown):74631386) (:1)␤»

[13:32] <pmichaud> ah, yes.  It's giving a NYI failure, which then can't be invoked.

[13:32] <pmichaud> I suppose I can change the fail to a die.

[13:33] *** wamba joined
[13:33] *** drbean left
[13:35] <pmichaud> > say [===] 1,1

[13:35] <pmichaud> chaining reduce NYI

[13:37] <dalek> rakudo/nom: df1de50 | pmichaud++ | src/core/metaops.pm:

[13:37] <dalek> rakudo/nom: Change the NYI metaops to die instead of fail.

[13:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/df1de50cb9

[13:39] *** wamba left
[13:40] *** wamba joined
[13:46] *** PacoLinux joined
[13:47] * jnthn back from nom + beer

[13:48] <jnthn> First night here that I could actually bear to sit out on the roof terrace and enjoy some beers :)

[13:48] <jnthn> (Others have been too hot/humid.)

[13:48] <pmichaud> \o/

[13:49] <jnthn> pmichaud: oh, it's a NYI rather than a bug

[13:50] *** am0c left
[13:50] <jnthn> pmichaud: We seem to have a weird double-containerization problem.

[13:51] <jnthn> pmichaud: So far as I can tell it shows up in slurpy hashes.

[13:51] <masak> today's autopun: http://twitter.com/carlmasak/status/87868045225242625

[13:52] <jnthn> nom: my $a = 42; sub x(*%h) { say %h<a>.WHAT }; x(:$a)

[13:52] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[13:52] <jnthn> hm

[13:52] <pmichaud> jnthn: http://gist.github.com/1063355  # proposed slight improvement to BUILDALL

[13:52] <jnthn> no, that won't expose it

[13:53] <jnthn> pmichaud: Avoding the iterator was deliberate.

[13:53] *** bbkr_ left
[13:53] <pmichaud> why is that?

[13:53] <jnthn> pmichaud: It's an extra object that has to be allocated

[13:53] <jnthn> We already allocate a bunch more than would be desirable in the proces of doing .new

[13:54] <jnthn> I remember doing a iterator => index transition in master in a similar code path (as part of new) a while ago.

[13:54] <pmichaud> okay.  I will say that my tests on lists showed that iterating was quite a bit faster than going through VTABLE_get_pmc_keyed_int

[13:54] <pmichaud> even with the cost of the pmc alloc

[13:55] <jnthn> That...would be worrying if right. :S

[13:55] <pmichaud> maybe it's only for large lists that it makes a difference though, for small lists the cost of the PMC might be more than the cost of the indexing

[13:55] <pmichaud> so, we can leave the index.

[13:56] <jnthn> When I did he iterator => index thing with this similar code area in master, it was a several percent (or maybe better) win

[13:56] <masak> maybe do both and measure?

[13:57] <jnthn> Benchmarks welcome :)

[13:57] <pmichaud> does "my int $i"  actually do the right thing, now?

[13:58] <jnthn> Depends what you mean by the right thing :)

[13:58] <pmichaud> avoid the box/unbox ?

[13:59] <jnthn> It uses a I register for storage.

[13:59] <pmichaud> I mean, that's been implemented already?  I missed that commit.

[13:59] <jnthn> Beyond that, it depends how you use it.

[13:59] <jnthn> Yes, that works

[13:59] <jnthn> if you have $a and $!b where both are natively typed, then $a = $!b never boxes, for example.

[14:00] <jnthn> Using it in a nqp::.... tends to work out fine too

[14:00] <pmichaud> > my $i = 0;

[14:00] <jnthn> Using natively typed things with infix operators tends to end badly.

[14:00] <pmichaud>     find_lex $P101, "$i"

[14:00] <pmichaud>     nqp_get_sc_object $P102, "1309787981.22907", 5

[14:00] <pmichaud>     perl6_container_store $P101, $P102

[14:00] <jnthn> in terms of performance

[14:00] <pmichaud> looks like it's still using PMCs to me.

[14:00] <jnthn> huh?

[14:00] <pmichaud> oh,w ait.

[14:00] <pmichaud> duh

[14:01] <pmichaud> wow, it does work

[14:01] <pmichaud> jnthn++

[14:01] <jnthn> We need the inlining to really take care of those.

[14:01] <jnthn> Generally, you *can* get better performance out of the natives today. But you have to know what's going on.

[14:02] <pmichaud> my int $i;  $i = nqp::add_i($i, 1)

[14:02] <pmichaud>     find_lex $I1012, "$i"

[14:02] <pmichaud>     perl6_box_int $P101, $I1012

[14:02] <pmichaud>     find_lex $I1013, "$i"

[14:02] <pmichaud>     add $I100, $I1013, 1

[14:02] <pmichaud>     store_lex "$i", $I100

[14:02] <pmichaud> (fyi)

[14:02] <jnthn> Right :)

[14:02] <pmichaud> still, very impressive.

[14:02] <jnthn> wait what...

[14:03] *** am0c joined
[14:03] <jnthn> where did that perl6_box come from?

[14:03] <pmichaud> it's boxing because we don't know about sink context on the "my int $i"

[14:03] <jnthn> wtf, it boxed it but didn't use it?

[14:03] <jnthn> oh!

[14:03] <pmichaud> when that's fixed, it'll be okay.

[14:03] <jnthn> ok :)

[14:04] <pmichaud> and native lexicals work in nqp, too?

[14:04] <pmichaud> or just in nom?

[14:05] <jnthn> Just nom for now

[14:05] *** thou joined
[14:05] <jnthn> I can do it in NQP too if needed.

[14:05] *** Mowah joined
[14:05] <jnthn> Well, I expect to in the end.

[14:05] <pmichaud> it could be really helpful at some point for the project I'm working on :)

[14:05] <jnthn> It's just a matter of how soon :)

[14:05] <pmichaud> but no rush needed yet

[14:05] <jnthn> Yeah, somebody wanting it will help bump it up :)

[14:10] <pmichaud> ...however, I suspect that  $i = nqp::add_i($i, 1)  is also creating a PMC

[14:11] <pmichaud> oh, maybe not.  depends on how smart the block calls are.

[14:11] <pmichaud> checking.

[14:11] <jnthn> pmichaud: Out of a lack of sink working properly?

[14:11] <pmichaud> jnthn: because it's the last statement in a block, and the block has to return a value.

[14:11] <pmichaud> (in the BUILDALL code)

[14:11] <Util> rakudo: my @a = grep { $_ %% 2 }, ( 1, 2, 3 ... 8 ); say @a.perl;

[14:12] <p6eval> rakudo 72d158: OUTPUT«[2, 4, 6, 8]␤»

[14:12] <Util> rakudo: my @a = grep { $_ %% 2 },   1, 2, 3 ... 8  ; say @a.perl;

[14:12] <p6eval> rakudo 72d158: OUTPUT«[]␤»

[14:12] <Util> How is that second attempt getting its '...' parsed, such that not even the '2' is passing the grep?

[14:13] <pmichaud> grep is tighter than ..., perhaps?

[14:13] <jnthn> pmichaud: ah, can easily move it

[14:13] <pmichaud> i.e., maybe  (grep { %_ %% 2 }, 1, 2, 3) ... 8

[14:13] <pmichaud> not sure, checking.

[14:14] <pmichaud> no, that's not it.

[14:14] <pmichaud> nom:  my @a = grep { $_ %% 2}, 1, 2, 3 ... 8;   say @a.perl;

[14:14] <p6eval> nom: OUTPUT«Array.new()␤»

[14:14] <pmichaud> nom:  my @a = grep { $_ %% 2}, (1, 2, 3 ... 8);   say @a.perl;

[14:14] *** xinming_ left
[14:14] <p6eval> nom: OUTPUT«Could not find sub &infix:<%%>␤current instr.: '_block1011' pc 440 ((file unknown):16518653) (:1)␤»

[14:15] <pmichaud> nom:  my @a = grep { $_ % 2 == 0 }, (1, 2, 3 ... 8);   say @a.perl;

[14:15] <p6eval> nom: OUTPUT«Array.new(2, 4, 6, 8)␤»

[14:15] <pmichaud> nom:  my @a = grep { $_ % 2 == 0 }, 1, 2, 3 ... 8;   say @a.perl;

[14:15] <p6eval> nom: OUTPUT«Array.new()␤»

[14:15] <pmichaud> nom:  say grep { $_ % 2 == 0 }, 1, 2, 3 ... 8;

[14:15] <p6eval> nom: OUTPUT«␤»

[14:15] <Util> .say

[14:16] <pmichaud> nom:  (grep { $_ % 2 == 0 }, 1, 2, 3 ... 8).say;

[14:16] <Util> (missing the dot)

[14:16] <p6eval> nom: OUTPUT«␤»

[14:16] <Util> Doh! nm the say comments

[14:16] <pmichaud> nom:  say 3...8

[14:16] <p6eval> nom: OUTPUT«3 4 5 6 7 8 ␤»

[14:17] <pmichaud> nom: say grep { $_ % 2 == 0 }, 1...8

[14:17] <p6eval> nom: OUTPUT«␤»

[14:17] *** xinming joined
[14:17] <pmichaud> nom: say (grep { $_ % 2 == 0 }, 1...8).eager

[14:17] <p6eval> nom: OUTPUT«␤»

[14:17] <pmichaud> nom: say (1...8).grep({$_ % 2 == 0})

[14:17] <p6eval> nom: OUTPUT«2 4 6 8␤»

[14:18] <pmichaud> looks like a problem with sub grep

[14:18] <pmichaud> looking

[14:20] <pmichaud> nom: say grep { $_ % 2 == 0 }, 1, 2, 3..8

[14:20] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'grep'. Available candidates are:␤:(Mu $test, Positional @values)␤␤current instr.: 'grep' pc 279979 (src/gen/CORE.setting.pir:68523) (:572)␤»

[14:20] <pmichaud> huh?

[14:21] <pmichaud> nom: say grep { $_ % 2 == 0 }, (1, 2, 3..8)

[14:21] <p6eval> nom: OUTPUT«2 4 6 8␤»

[14:21] <pmichaud> nom:  sub xyz($x, *@v) { say @v };    xyz { $_ * 2 == 0 }, 1, 2, 3..8

[14:21] <p6eval> nom: OUTPUT«1 2 3 4 5 6 7 8␤»

[14:22] <pmichaud> nom: proto sub xyz(|$) { * }; multi sub xyz($x, *@v) { say @v };   xyz { $_ * 2 == 0 }, 1, 2, 3..8

[14:22] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'xyz'. Available candidates are:␤:(Any $x, Positional @v)␤␤current instr.: 'xyz' pc 465 ((file unknown):74991828) (:1)␤»

[14:22] <pmichaud> jnthn: ^^^^^

[14:23] <pmichaud> (that's probably not the source of the bug in Util's case, but it's a big bug)

[14:27] <jnthn> nom: proto x(|$) { * }; multi x(*@a) { }; x(); say 1

[14:27] <p6eval> nom: OUTPUT«1␤»

[14:27] <jnthn> nom: proto x(|$) { * }; multi x(*@a) { }; x(1,2,3); say 1

[14:27] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'x'. Available candidates are:␤:(Positional @a)␤␤current instr.: 'x' pc 418 ((file unknown):9526769) (:1)␤»

[14:27] <jnthn> nom: proto x(|$) { * }; multi x(*@a) { }; x(1); say 1

[14:27] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'x'. Available candidates are:␤:(Positional @a)␤␤current instr.: 'x' pc 408 ((file unknown):38850031) (:1)␤»

[14:29] *** mj41 left
[14:29] *** wtw left
[14:33] <pmichaud> ok, I see what's wrong with grep.

[14:33] <pmichaud> oh, wait, no I don't.

[14:33] <pmichaud> hrm.

[14:33] *** Moukeddar joined
[14:33] <jnthn> Definite multi bug.

[14:34] <pmichaud> that's part of it, yes, but I think there's also a bug with the sequence generation.

[14:36] <jnthn> spectesting multi fix.

[14:37] <pmichaud> oh!

[14:37] <pmichaud> Util: here's the problem:  the block is one of the arguments to ...

[14:37] *** JimmyZ_ joined
[14:37] <pmichaud> nom:  my @a = grep { $_ * 2 == 2 }, 1, 2, 3, ... 8

[14:38] <p6eval> nom: OUTPUT«Comma found before apparent series operator; please remove comma (or put parens␤    around the ... listop, or use 'fail' instead of ...) at line 1, near " ... 8"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[14:38] <pmichaud> parses as

[14:38] <pmichaud> my @a = grep  ({ $_ * 2 == 0 }, 1, 2, 3 ... 8)

[14:38] <pmichaud> i.e., the first argument to grep is the entire sequence

[14:38] <pmichaud> and there are no values to grep.

[14:40] *** PhatEddy joined
[14:40] *** JimmyZ left
[14:41] *** JimmyZ_ is now known as JimmyZ

[14:41] <PhatEddy> nom: my num $n = NaN;

[14:41] <p6eval> nom: OUTPUT«error:imcc:undefined identifier 'NaN'␤␤     in file '(file unknown)' line 29986791␤»

[14:42] <PhatEddy> nom: my Num $n = NaN;

[14:42] <p6eval> nom:  ( no output )

[14:42] *** jimmy1980 joined
[14:42] <jnthn> nom: say NaN

[14:42] <p6eval> nom: OUTPUT«NaN␤»

[14:42] <PhatEddy> nom: my int $i; say $i +2;

[14:42] <p6eval> nom: OUTPUT«56746946␤»

[14:42] <jnthn> nom: say Inf

[14:42] <p6eval> nom: OUTPUT«Inf␤»

[14:43] <jnthn> nom: my int $i; say $i

[14:43] <p6eval> nom: OUTPUT«65054792␤»

[14:43] <jnthn> heh :)

[14:43] <PhatEddy> nom: my num $n; say $n +2;

[14:43] <p6eval> nom: OUTPUT«2␤»

[14:43] <jnthn> Guess we don't promise much about initial value of a native at the moment :)

[14:43] <PhatEddy> from yesterday - should I think be NaN

[14:44] <PhatEddy> looks like good progress though ...

[14:44] *** Moukeddar left
[14:44] *** am0c left
[14:44] <jnthn> Or we just say that if you're dealing with natives you do your own initialization :)

[14:44] <jnthn> Not sure if the spec has an opinion on that :)

[14:44] <PerlJam> jnthn: that would be LTA IMHO   :)

[14:45] <PhatEddy> spec does have opinion - one moment ...

[14:46] <PhatEddy> see http://perlcabal.org/syn/S02.html#Native_types near bottom of section

[14:46] <pmichaud> S02: "Since native types cannot represent Perl's concept of undefined values, in the absence of explicit initialization, native floating-point types default to NaN, while integer types (including bit) default to 0."

[14:46] <jnthn> ah, it does want us to 

[14:47] <tadzik> I wonder how much can I rip of the setting just to make the compilation faster

[14:47] *** koban left
[14:48] *** dju left
[14:48] <tadzik> Method 'exists' not found for invocant of class 'Hash' -- could that be a Parroty hash leaking through?

[14:49] *** lichtkind joined
[14:49] <dalek> rakudo/nom: 6c013c1 | jonathan++ | src/core/Mu.pm:

[14:49] <dalek> rakudo/nom: Move a statement to avoid an accidental boxing every time around a loop (pmichaud++ for noticing).

[14:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c013c1622

[14:49] <dalek> rakudo/nom: 18fe583 | jonathan++ | src/binder/multidispatch.c:

[14:49] <dalek> rakudo/nom: Fix multi-dispatches involving slurpy args.

[14:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/18fe5830c2

[14:49] <jnthn> tadzik: sounds like

[14:49] <jnthn> pmichaud: ^^ fix

[14:49] <tadzik> dang

[14:49] <pmichaud> note that if you're in NQP, hashes aren't "leaking" through.

[14:49] <pmichaud> Parrot hashes are normal in nqp (which includes Actions.pm)

[14:50] <jnthn> Yes, true :)

[14:50] <pmichaud> tadzik: you can always do "make perl6" if you're not interested in having an up-to-date setting.

[14:51] <tadzik> I'm adding named parameters to Past, see https://github.com/rakudo/rakudo/commit/e44bddd65

[14:51] <tadzik> pmichaud: oh, thanks

[14:51] <Util> pmichaud: Thanks!

[14:52] *** Mowah left
[14:52] *** [Coke] left
[14:52] <pmichaud> tadzik: changing "nqp::push($des,"  to $des.push looks Evil.

[14:52] <tadzik> also, it occures in say %h<name>;, in a sub with a *%h as a parameter

[14:52] <tadzik> pmichaud: does it?

[14:52] <pmichaud> you're changing a low-level operation into a higher-level method call.

[14:53] <tadzik> oh

[14:53] <tadzik> should it cause any problems besides the performance penalty?

[14:53] <pmichaud> depends on what $des is, underneath.

[14:53] <jnthn> PAST node

[14:53] <tadzik> PAST::Op

[14:54] *** [Coke] joined
[14:54] <pmichaud> if it's a PAST node, then .push is probably more correct.

[14:54] <jnthn> I've tended to use .push

[14:54] <tadzik> .push is usually used, that's why I changed that

[14:54] <jnthn> So in a way tadzik has made it some consistent with other stuff in SymbolTable.pm

[14:54] <pmichaud> yes, tadzik is correct... he converted some Evil into some Good.  tadzik++

[14:55] <jnthn> :)

[14:55] *** leprevost joined
[14:55] <tadzik> :)

[14:55] <tadzik> that still leaves my slurpy hash broken somehow

[14:59] <pmichaud> jnthn: btw, I did a quick check, and you're correct, using VTABLE_get_pmc_keyed_int is slightly faster than the iterator.

[14:59] *** whiteknight left
[14:59] <pmichaud> (the overall difference in time isn't significant, although the creation of the short-lived iterator object might be)

[15:00] *** whiteknight joined
[15:03] <pmichaud> get_pmc_keyed_int is probably faster only as long as you can guarantee that the index isn't being boxed somewhere, though.  Once that happens, the iterator likely wins (by a fair margin)

[15:03] <jnthn> Yes, if you're paying boxing penalties it'll quickly get expensive

[15:04] <pmichaud> looks like the index version gets 4x slower than the iterator version if the index is boxed even once per iteration.

[15:04] <pmichaud> so, iterator is the "safe bet", index version is the "we really know what we're doing here" bet.  :)

[15:05] <pmichaud> and have to be wary of native variables leaking out into other others that might do boxing (such as at the end of a block, or as an argument to an opcode that wants a PMC)

[15:07] <masak> "Polymorphism in Perl is inherently straightforward to write because of the language's use of sigils and references." -- huh? http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming#Perl

[15:08] <masak> what do sigils and references have to do with polymorphism?

[15:10] <jlaire> what do wikipedia articles have to do with facts? ;)

[15:11] *** daniel-s left
[15:12] <jlaire> I can't even guess what that's supposed to mean...

[15:14] *** perlhack joined
[15:14] <perlhack> hi all 

[15:15] <Util> masak: mystery to me as well. Introduced in oldid=244794648 by Draegtun. Perhaps ask on his talk page?

[15:15] <Util> Hi, perlhack

[15:15] <perlhack> hi Util

[15:16] <Util> Working on subfactorials:  a(n) = (n-1)( a(n-1) + a(n-2)     http://oeis.org/A000166

[15:16] <Util> rakudo: my $c; my @A000166 := 1, 0, { ++$c * ($^a + $^b) } ... *; say @A000166[7];

[15:16] <p6eval> rakudo 72d158: OUTPUT«1854␤»

[15:16] <Util> Is there any way to get rid of $c ?

[15:16] <perlhack> Util, i first met you 

[15:16] <masak> Util: I will. thanks.

[15:16] <Util> In other words, is the iteration count of a sequence available to its code block, perhaps in some special var?

[15:16] <jlaire> the whole article is a bit of a mess

[15:16] <jlaire> as the talk page shows

[15:17] <Util> jlaire: Ah, yes! The talk page for the *article* is better.

[15:18] <JimmyZ> rakudo: my @A000166 := 1, 0, { ++$_ * ($^a + $^b) } ... *; say @A000166[7]; # get rid of $c ?

[15:18] <p6eval> rakudo 72d158: OUTPUT«1854␤»

[15:18] <tadzik> jnthn: I'm sorry to bother you again, but something is still not right about handling the named params to new_type. Does any of the modifications in http://wklej.org/id/557173/ look more correctish to you, given the usecase above?

[15:18] *** dakkar left
[15:20] <JimmyZ> rakudo: my @A000166 := 1, 0,  ++$_ * ( * + * ) ... * ; say @A000166[7];

[15:20] <p6eval> rakudo 72d158: OUTPUT«1854␤»

[15:20] *** dakkar joined
[15:21] <JimmyZ> rakudo: my @A000166 := 1, 0,  ++(my $a) * ( * + * ) ... * ; say @A000166[7]; # or this?

[15:21] <p6eval> rakudo 72d158: OUTPUT«1854␤»

[15:24] * masak left a question on Draegtun's talk page

[15:25] <Util> JimmyZ: That last one is an improvement, although I question whether it *should* work, as opposed to `state`

[15:25] <Util> Using ++$_ actually gets in the way

[15:26] <Util> Thanks!

[15:27] <Util> perlhack: Did you mean "this is the first time we have spoken"? If so, yes I agree, but I have seen you interacting with others in the channel over the last few days.

[15:27] <jlaire> the article says "an object that has more than one form", which feels fundamentally wrong to me

[15:29] <jlaire> should be something like, a variable can refer to objects of different types

[15:29] <jnthn> tadzik: You also need to update the line $constant := $type_obj.new(|@value);

[15:30] <perlhack> Util, haa  this is the first time we have spoken.

[15:30] <jnthn> And pass |%named too

[15:30] <tadzik> jnthn: and the first patch was correct?

[15:30] <jnthn> yes, correct but not sufficient

[15:31] <tadzik> okay, I get it

[15:31] <tadzik> I think :)

[15:31] <jnthn> you handled the deserialize/pre-compiled case

[15:31] <jnthn> but not the immediate run case

[15:31] <tadzik> okay

[15:31] <JimmyZ> Util:  I think it likes C:   for( int i; i<10; i++ ) { int a; ++a; }

[15:32] <tadzik> OH WOW IT WORKS!

[15:32] <tadzik> jnthn++

[15:32] <jnthn> yay :)

[15:33] <tadzik> OH WOW :)

[15:34] <tadzik> okay, now I need a piece of paper and a pencil

[15:34] <JimmyZ> rakudo: my $a = 10;  my $b; while $a++ < 20 { say ++($b) }

[15:34] <p6eval> rakudo 72d158: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[15:34] *** felliott joined
[15:34] <JimmyZ> rakudo: my $a = 10; while $a++ < 20 { say ++(my $b) }

[15:34] <p6eval> rakudo 72d158: OUTPUT«1␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[15:35] <JimmyZ> rakudo: my @A000166 := 1, 0, ++(my $a) * ( * + * ) ... * ; say @A000166[7]; # so it's a bug?

[15:35] <p6eval> rakudo 72d158: OUTPUT«1854␤»

[15:35] <jlaire> JimmyZ: $b is local to the while block, but ++(my $a) isn't surrounded by {} so it's global

[15:36] <JimmyZ> rakudo: my @A000166 := 1, 0, { ++(my $c) * ($^a + $^b) } ... *; say @A000166[7];

[15:36] <p6eval> rakudo 72d158: OUTPUT«8␤»

[15:36] *** zby_home joined
[15:36] <JimmyZ> well, I'm confused

[15:37] <felliott> Hello, #perl6!

[15:37] <tadzik> hello felliott!

[15:37] <JimmyZ> looks like they are different

[15:38] <masak> hi felliott!

[15:38] <felliott> I've taken another stab at implementing flipflops, this time as a macro.

[15:38] <masak> tadzik: I'm happy to see you so happy :)

[15:38] <felliott> Hey, tadzik, masak!

[15:38] <felliott> https://github.com/felliott/rakudo/commit/826cc997

[15:38] <felliott> Do you mind taking a look at it?

[15:38] * masak looks, curious

[15:38] <felliott> I'm especially unsure about the pir part.

[15:39] <felliott> (line 2578)

[15:39] <felliott> I worked through the parrot pct tutorial, but I'm not sure I grok PAST.

[15:40] <masak> yeah, just noticed the PIR.

[15:40] <masak> I must say it looks like solid craftsmanship, though.

[15:40] <felliott> Thank you!

[15:40] <masak> I've given some thought to how to implement the flipflops, and your code reflects the things I had concluded.

[15:40] <felliott> I need a way to save the state of the flipflop, but I'm not sure where to store it.

[15:40] <masak> (for example, that a hidden variable is needed)

[15:41] <jlaire> rakudo: say ++(my $a) for ^5; { say ++(my $b) } for ^5

[15:41] <p6eval> rakudo 72d158: OUTPUT«1␤2␤3␤4␤5␤1␤1␤1␤1␤1␤»

[15:41] <masak> felliott: what happens if you have several flipflops in the same lexical scope?

[15:41] <masak> felliott: is the name of the state variable gensym'd somehow?

[15:41] <felliott> Shouldn't be a problem.  They get different names.

[15:41] <masak> \o/

[15:41] <felliott> ...I think.  (Woosh, off to test ...)

[15:42] <masak> :)

[15:42] *** perlhack left
[15:42] <moritz> that's what the .unique calls (should) do, right?

[15:42] <masak> felliott: test, and then make sure to check with pmichaud. after that, I'd say we should merge your commit into master.

[15:42] <masak> moritz: um, yes. :)

[15:43] <pmichaud> implementing ff in Actions seems Very Wrong

[15:43] <pmichaud> I don't think they should be macro-ized.

[15:43] <masak> I knew there was something I'd probably overlooked! :)

[15:43] <masak> pmichaud: how would you do them?

[15:43] *** woosley left
[15:44] <masak> pmichaud: in particular, where would you put the internal state of the op?

[15:44] <pmichaud> have &infix:<ff> keep track of a state variable based on the identity of the caller

[15:44] <masak> (you can't put it as a state variable, because it's local to the *individual* flipflop in the code)

[15:44] <jnthn> you could have a state hash keyed on the location of the caller

[15:44] <pmichaud> right

[15:45] <masak> conceivably.

[15:45] <jnthn> or even just a hash in the scope outside of infix:<ff> for now.

[15:45] <pmichaud> that's what I mean by "identify of the caller"  - use the caller location as the key

[15:45] <moritz> do we have the caller location sufficiently precise?

[15:45] <felliott> double checked.  two ffs in the same scope use different states.

[15:45] <pmichaud> we should be able to get it somehow.

[15:45] <jnthn> It's obtainable.

[15:46] <jnthn> May need a dynop

[15:46] <pmichaud> or a method on the CallContext 

[15:46] <pmichaud> it might also be available in the RetContinuation

[15:46] <felliott> pmichaud: where should ff be implemented?  I did it as a class originally.

[15:46] <pmichaud> felliott: it should be an operator.

[15:47] <pmichaud> like &infix:<+> and the like.

[15:47] <jnthn> Time for sleep here

[15:48] <pmichaud> looks to me like we can get the return continuation from the interpreter

[15:48] <masak> felliott: while you were gone testing, your patch was rejected, basically, and the proper solution was drawn up.

[15:48] <felliott> ah, okay

[15:48] <pmichaud> and we can use get_pointer to get the address from the return continuation

[15:48] <masak> see above.

[15:48] <felliott> I saw, I was just confused where it should go.  I found it now.  I can do that.

[15:48] <pmichaud> let's see if I can put together a proof of concept

[15:48] <pmichaud> just a sec

[15:49] *** frew joined
[15:49] <JimmyZ> rakudo: say ++(my $a) for ^5; { say ++(my $b) } for ^5 # i wonders whether it's a bug or not

[15:49] <p6eval> rakudo 72d158: OUTPUT«1␤2␤3␤4␤5␤1␤1␤1␤1␤1␤»

[15:49] <jnthn> JimmyZ: It's correct

[15:50] <jlaire> JimmyZ: what output did you expect?

[15:50] <jnthn> JimmyZ: If you want a fresh scope you need the curlies

[15:50] *** frew left
[15:50] <masak> felliott++ # rolling with it

[15:50] <felliott> :)

[15:51] <pmichaud> in the first one you're incrementing the same $a each time.  In the second you get a new $b with each block invocation.

[15:52] <pmichaud> (rebuilding nom)

[15:52] <masak> decommute &

[15:53] *** masak left
[15:53] <jlaire> 'my $a' doesn't reset the state every time, if that's what you were thinking

[15:54] <moritz> pmichaud: should the sub forms of push etc. be multis?

[15:55] <pmichaud> moritz: use whatever S32/containers says :)

[15:56] <JimmyZ> but SYN said * + * is equal to { $^a + $^b }

[15:56] <moritz> JimmyZ: it's not very precise when it says that

[15:57] <moritz> it says multi method ... is export

[15:57] <moritz> so I guess upon export it will be a multi sub too

[15:59] <jlaire> hm, LHF "Add .Rat method to Int" seems to be done already?

[16:00] <pmichaud> http://gist.github.com/1063533  # proof of concept of obtaining location of call

[16:00] *** JimmyZ left
[16:00] <pmichaud> oh, wait

[16:00] <pmichaud> let me show the output also

[16:01] *** tadzik_kindle joined
[16:01] <pmichaud> http://gist.github.com/1063536  # obtaining location of call, with output

[16:01] <tadzik_kindle> oh hai

[16:01] <pmichaud> each ftest invocation has its own unique call location.

[16:02] <Util> How close are we to having `state` vars in rakudo or nom?

[16:02] <pmichaud> probably won't happen in master

[16:02] <pmichaud> probably very close to happening in nom

[16:03] <Util> So master gets them when nom merges into master?

[16:03] <pmichaud> when nom becomes master

[16:03] <Util> Got it. Thanks!

[16:03] <pmichaud> (we're unlikely to do an actual merge)

[16:12] <pmichaud> oh.

[16:12] <pmichaud> looks like ff *has* to be a macro.

[16:12] <moritz> does it short-circuit?

[16:13] <pmichaud> it doesn't pre-evaluate its operands

[16:13] <pmichaud> if we do a plain  &infix:<ff>($a, $b),  both $a and $b are evaluated prior to the call

[16:13] <pmichaud> it's the same logic by which && and || can't be simple &infix operator calls.

[16:14] <pmichaud> I would really like to see Perl 6 definitions for things like || and &&.

[16:14] <pmichaud> It would clear up a lot of confusion if we knew how short-circuiting is to be defined.

[16:14] *** Mowah joined
[16:16] *** tadzik_kindle left
[16:17] <pmichaud> felliott: see note immediately above -- looks like you may have had it correct.  I'm re-evaluating your patch now.

[16:17] <felliott> drat.  I was almost done making it into an operator.  :)

[16:18] <pmichaud> sorry about that.

[16:19] <pmichaud> the patch feels too long to be correct, fwiw.

[16:19] <felliott> no problem. everytime I implement it, I learn something new

[16:19] <pmichaud> I mean, it's likely correct, but it really should be a lot shorter.

[16:20] <felliott> the basic flipflop logic isn't too complicated, but handling the exclude_first, excludes_last, and sedlike complicates it.

[16:20] <felliott> here's the logic in perl6: https://gist.github.com/1063566

[16:21] <felliott> (taken from when it was a class)

[16:21] <pmichaud> .match ?

[16:22] <pmichaud> I thought it just tests the bool of each side?

[16:23] *** _twitch left
[16:23] <felliott> I may be misunderstanding match

[16:23] <pmichaud> .match is typically for regexes

[16:24] <felliott> I'm trying to smartmatch $_ against the lhs

[16:24] <pmichaud> I don't see anything in the spec for ff about smartmatching, though.  I thought it just evaluated its operands in boolean context.

[16:24] <felliott> ff takes regexes

[16:24] <pmichaud> sure, a bare regex in boolean context performs a match

[16:24] <pmichaud> but that's because of the .Bool method on regex, not because of the ff operator

[16:25] <felliott> Ah!

[16:25] <felliott> That makes sense.

[16:26] <pmichaud> (and, fwiw, smart matching is .ACCEPTS :-)

[16:26] <felliott> There may have been a certain amount of cargo-culting going on...

[16:26] <felliott> \me looks shifty

[16:27] <felliott> I'll fix that.

[16:28] <pmichaud> I'm thinking the basic logic is

[16:28] <pmichaud>     $state ?? ($lhs && $state++) !! ($rhs && $state--)

[16:28] <pmichaud> (note $state is a Bool)

[16:28] <pmichaud> oh, backwards

[16:29] <pmichaud>     $state ?? ($rhs && $state--) !! ($lhs && $state++)

[16:29] <felliott> ff can flip and flop on the same input

[16:29] <felliott> fff doesn't

[16:29] <pmichaud> okay.

[16:30] <pmichaud> so what I gave above is fff-like, I guess.

[16:30] <felliott> yep.

[16:30] <pmichaud> $lhs && $state++ unless $state;  $rhs && $state-- if $state;

[16:31] <pmichaud> or, to avoid the if/unless

[16:31] <pmichaud> $state || $lhs && $state++;  $state && $rhs && $state--

[16:32] <felliott> Yes, but we also need to make note of when we flop, so we can exclude the last for ff^ and fff^.

[16:32] <pmichaud> I don't quite understand the ^'s yet.

[16:32] <felliott> ^ff returns false on flip.  ff returns true on flip

[16:33] <felliott> ff returns true on flop, ff^ returns false on flop

[16:33] <pmichaud> okay

[16:33] <pmichaud> so

[16:33] <felliott> there's a Dr. Seuss book in that...

[16:33] *** sivoais left
[16:33] <pmichaud> ^ff:   $state || $lhs && $state++;  $state && $rhs && --$state;

[16:34] <pmichaud> ff:  $state || $lhs && ++$state; $state && $rhs && --$state;

[16:34] <pmichaud> ff^:  $state || $lhs && ++$state; $state && $rhs && $state--;

[16:34] <pmichaud> ^ff^:  $state || $lhs && $state++; $state && $rhs && $state--;

[16:34] <felliott> looks right.

[16:35] <pmichaud> the ^'s just change prefix/postfix

[16:35] <felliott> but will that be shorter than doing it all in one method?

[16:35] <pmichaud> you can still do it all in one method

[16:35] <felliott> Oh, yeah. 

[16:35] <pmichaud> but you don't need all of the if/then/else cases

[16:36] <pmichaud> regardless, returning values like 0 is almost certainly wrong, because it's not a Bool

[16:36] <felliott> Is there a better way to do if and else than using PAST nodes?

[16:36] <felliott> ff returns empty string on false, and the state value on true.

[16:37] <pmichaud> in p5, yes.  in p6 I suspect it returns a Bool

[16:37] <pmichaud> re-reading spec.

[16:37] <felliott> spec says "do it like p5"

[16:39] <felliott> I asked TimToady about it in Feb.  

[16:39] <pmichaud> okay.

[16:39] <felliott> Here the link: http://irclog.perlgeek.de/out.pl?channel=perl6;date=2011-02-05

[16:39] <felliott> The advantage to ff returning the state value is that you can do things like skip every other line inside the condition.  I think brian d foy posted about that on the Effective Perler

[16:40] <pmichaud> okay

[16:40] <pmichaud> so,   (2 ff Bool::False) should return 2, yes?

[16:41] <felliott> That's where it gets weird.

[16:41] *** stephanmg left
[16:41] *** birdwindupbird left
[16:41] <felliott> A literal num is supposed to match the input line number. (my patch does not yet do this)

[16:41] *** stephanmg joined
[16:41] *** stephanmg left
[16:42] <pmichaud> okay, non-literal num then

[16:42] <pmichaud> my $a = 2;   ($a ff Bool::False) 

[16:42] *** stephanmg joined
[16:42] *** stephanmg left
[16:42] <felliott> should return 1

[16:42] <pmichaud> 1?  not the value of $a ?

[16:42] *** stephanmg joined
[16:42] *** stephanmg left
[16:42] <felliott> nope. it returns the value of $state

[16:42] <pmichaud> that would be True then.

[16:43] <felliott> True?

[16:43] <pmichaud> in the page you just posted, TimToady says   $secret = True

[16:43] <pmichaud> http://irclog.perlgeek.de/perl6/2011-02-05#i_3257429

[16:44] <pmichaud> True and False, not 0 and 1

[16:44] *** stephanmg joined
[16:44] *** stephanmg left
[16:44] <pmichaud> (or 1 and "")

[16:44] <felliott> farther down: http://irclog.perlgeek.de/perl6/2011-02-05#i_3257532

[16:44] *** stephanmg joined
[16:44] *** stephanmg left
[16:45] *** stephanmg joined
[16:45] *** stephanmg left
[16:45] <felliott> "TimToady: but returning the sequence number is useful"

[16:45] *** stephanmg joined
[16:45] *** stephanmg left
[16:46] <pmichaud> yes

[16:46] *** stephanmg joined
[16:46] *** stephanmg left
[16:46] <pmichaud> reading.

[16:46] *** stephanmg joined
[16:46] *** stephanmg left
[16:47] *** stephanmg joined
[16:47] *** stephanmg left
[16:47] <pmichaud> okay, ignore everything I said about Bools.

[16:47] <pmichaud> yes, using PAST nodes for 'if' and 'unless'  is the way to do  ??, &&, and ||

[16:47] *** stephanmg joined
[16:48] <pmichaud> :pirop('inc')   # pretty much guaranteed to fail

[16:49] <felliott> I wasn't sure how else to incr it.

[16:49] <pmichaud> easiest is call &prefix:<++> on it.  :-)

[16:49] <pmichaud> (or &postfix:<++>, depending on what you want)

[16:49] <felliott> I think I tried that and it didn't work.  I'll give it another go.

[16:50] <felliott> Maybe I was calling that on a parrot int.

[16:53] *** awoodland left
[16:53] <felliott> Thanks, pmichaud++!

[16:59] *** tokuhirom left
[17:02] <pmichaud> felliott: http://gist.github.com/1063619   # pretty close to complete

[17:03] <pmichaud> complete for the ff case, at any rate.  I suspect the same code can be used for fff with a tweak or two.

[17:05] *** dakkar left
[17:07] <pmichaud> http://gist.github.com/1063630  # code handling both ff and fff

[17:08] <felliott> wow.

[17:08] <felliott> I'll test it here.

[17:09] <pmichaud> http://gist.github.com/1063633  #  return '' instead of 0 for false

[17:09] <pmichaud> the state variable needs to always be an Int

[17:09] <pmichaud> i.e., it's initialized to zero.

[17:09] *** noganex_ joined
[17:12] *** noganex left
[17:21] <pmichaud> hmmm, that generates an extra test on $state, could probably factor that out a bit better as well.

[17:21] <moritz> perl6: say -9 div 4

[17:21] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "div"␤    expecting operator, ":" or ","␤    at /tmp/63Uo8Fvvm_ line 1, column 8␤»

[17:21] <p6eval> ..rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«-3␤»

[17:21] <moritz> perl6: say -9 div -4

[17:22] <p6eval> rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«2␤»

[17:22] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "div"␤    expecting operator, ":" or ","␤    at /tmp/yTJkrvw0hp line 1, column 8␤»

[17:23] <moritz> perl6: say  (-9) div -4

[17:23] <p6eval> rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«2␤»

[17:23] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "div"␤    expecting operator, ":" or ","␤    at /tmp/jjqTm7xZkb line 1, column 11␤»

[17:24] <lichtkind> all: o/

[17:24] <lichtkind> thou: cheers

[17:27] <thou> hello, lichtkind!

[17:27] <moritz> nom: say (0 + 1i) ** 2

[17:27] <p6eval> nom: OUTPUT«0 + 11.6067021786817i␤»

[17:27] <moritz> WTBH?

[17:28] <moritz> nom: say (0.7071067811865476 + -0.7071067811865475i)**4,

[17:28] <p6eval> nom: OUTPUT«0 - 42.8812867609298i␤»

[17:29] <moritz> nom: say exp(2)

[17:29] <p6eval> nom: OUTPUT«7.38905609893065␤»

[17:29] <moritz> nom: say log(1i)

[17:29] <p6eval> nom: OUTPUT«0 + 1.5707963267949i␤»

[17:29] <moritz> nom: say exp(2) * log(1i)

[17:29] <p6eval> nom: OUTPUT«0 + 11.6067021786817i␤»

[17:29] <moritz> I haz math fail

[17:30] <moritz> I though a ** b == exp(a) * log(b)

[17:30] <moritz> but in fact

[17:30] <moritz> I though a ** b == exp(a * log(b))

[17:30] <moritz> erm

[17:30] <moritz> It is  a ** b == exp(a * log(b))

[17:30] <moritz> nom: say exp(2 * log(1i))

[17:30] <p6eval> nom: OUTPUT«-1 + 1.22464679914735e-16i␤»

[17:30] <felliott> $*ST nom-only?  I couldn't grep it anywhere in master.

[17:30] <moritz> nom-only

[17:30] <felliott> ah-ha.

[17:31] <felliott> thank you

[17:32] *** dju joined
[17:33] <moritz> considering all the fails I introduce in nom math, maybe somebody who actually knows math should take over from here :-)

[17:33] <daxim> needs moar rageguy operators.  fffuuu

[17:34] *** masak joined
[17:34] <masak> evening, fellow symbionts.

[17:35] *** daxim left
[17:36] *** Jackneill joined
[17:37] <Jackneill> hi

[17:38] <Jackneill> can i install perl6 next to perl ?

[17:40] <Jackneill> perl6: say "perl6: \"say perl6!\"";

[17:40] <p6eval> pugs, rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«perl6: "say perl6!"␤»

[17:40] <Jackneill> very slow:/:(

[17:40] <sjohnson> course

[17:41] *** pernatiy left
[17:42] *** mj41 joined
[17:43] *** Tedd1 joined
[17:43] <masak> Jackneill: yes, you can run both 'perl' and 'perl6' alongside just fine.

[17:44] <masak> Jackneill: as to speed, that is our current focus. the Rakudo branch 'nom' is already quite a bit faster.

[17:49] <Jackneill> thanks, masak. How?

[17:49] <masak> how will it be faster? well...

[17:49] <Jackneill> i just install perl6 in terminal with apt?

[17:49] <masak> ah.

[17:49] <masak> yes.

[17:49] <Jackneill> no no, how can i install.

[17:49] <masak> or build from source.

[17:49] <Jackneill> sudo apt-get install perl6 ?

[17:49] <masak> I'll check.

[17:49] <Jackneill> and perl and perl6 will be works fine?

[17:49] <pmichaud> I don't believe there are any up-to-date debian packages yet.

[17:50] <masak> oh :/

[17:50] <pmichaud> (there are some out-of-date ones).

[17:50] *** cookys_ joined
[17:51] *** ingyfoo joined
[17:51] *** estrai joined
[17:51] *** Krunch_ joined
[17:51] *** barika_ joined
[17:51] *** MOAR-f00li5h joined
[17:51] *** Su-Shee left
[17:51] *** bluescreen__ joined
[17:52] *** cosimo_ joined
[17:52] *** moritz_ joined
[17:52] *** dual left
[17:52] *** ingy left
[17:52] *** wamba left
[17:52] *** barika left
[17:52] *** f00li5h left
[17:52] *** bluescreen100 left
[17:52] *** Vlavv left
[17:52] *** cosimo left
[17:52] *** moritz left
[17:52] *** Woody2143 joined
[17:52] *** frodwith joined
[17:52] <Jackneill> so build from source: cd to dir, ./configure, make, make install ?

[17:52] *** dual joined
[17:52] *** wamba joined
[17:52] *** Vlavv joined
[17:52] <masak> well, 'perl Configure.pm --gen-parrot', but yes :)

[17:52] <pmichaud> .pl, I think.

[17:52] <masak> and you'll probably want to 'sudo make install'.

[17:52] <masak> ah yes, .pl of course

[17:52] <moritz_> no

[17:52] *** Su-Shee joined
[17:53] <pmichaud> if you --gen-parrot, no sudo needed

[17:53] <moritz_> not sudo

[17:54] <masak> oh, right.

[17:55] <masak> that's why I don't --gen-parrot :P

[17:57] *** Mowah left
[18:00] *** barika_ is now known as barika

[18:07] *** Mowah joined
[18:12] *** bluescreen__ left
[18:12] *** bluescreen10 left
[18:13] *** bluescreen10 joined
[18:21] <felliott> I'm getting: 'Cannot modify readonly value in "&infix:<=>"' when I compile and run: https://gist.github.com/1063742

[18:21] <felliott> the infix:<=> is on line 59

[18:22] * masak looks

[18:22] <pmichaud> this is in master?

[18:22] <felliott> I tried adding a :lvalue(1) to the Op, nodice.

[18:22] <felliott> yes.

[18:23] <pmichaud> your state variable declaration is binding it to a constant 0

[18:23] <pmichaud>             PAST::Var.new( :name($state_var), :scope('lexical'), :isdecl(1), :viviself(0) ),

[18:23] <felliott> hmmm.

[18:23] <pmichaud> try removing the :viviself(0)

[18:24] <felliott> okay.

[18:24] <felliott> <compiling...>

[18:24] *** Instil left
[18:24] <felliott> So if I :viviself(0), I can modify it via PIR, but not by the HLL?

[18:25] <felliott> I was able to :pirop('inc')  on $state_var in the previous version.

[18:25] <pmichaud> I didn't realize you were working in master.

[18:25] <pmichaud> Still, that's bad form because it ends up incrementing what should be a constant.

[18:25] *** am0c joined
[18:26] <felliott> Gotcha. Thanks!

[18:26] <pmichaud> also, the use of &prefix:<++> gives the ^ semantics

[18:26] <pmichaud> i.e., return the value before incrementing, return the value after incrementing

[18:28] <felliott> If I wanted to declare a variable and initialize it to some value but have it be mutable, should I use PAST::Op.new(:name('bind')) instead?

[18:28] <pmichaud> ah, to use a scalar variable, will need to mark the variable with a "rw" property.

[18:28] <felliott> s/name/pasttype/

[18:29] <pmichaud> elsewhere we do:             PAST::Op.new( $cont, 'rw', $true, :pirop('setprop')

[18:29] <pmichaud> )

[18:29] <pmichaud> &infix:<=>  refuses to write to an object that doesn't have the 'rw' property set.

[18:30] <felliott> I see. 

[18:30] <felliott> I found an example of 'rw', I'll try that now.

[18:30] <felliott> thanks!

[18:39] <dalek> roast: 50a0687 | moritz++ | S02-builtin_data_types/flattening.t:

[18:39] <dalek> roast: fudge flattening.t for rakudo

[18:39] <dalek> roast: review: https://github.com/perl6/roast/commit/50a0687253

[18:41] <dalek> rakudo/nom: d9d8c49 | moritz++ | src/core/Complex.pm:

[18:41] <dalek> rakudo/nom: fix Complex exponentation

[18:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9d8c49428

[18:41] <dalek> rakudo/nom: ce2882f | moritz++ | src/core/Real.pm:

[18:41] <dalek> rakudo/nom: add infix mod

[18:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce2882f06c

[18:41] <dalek> rakudo/nom: d2a8943 | moritz++ | / (2 files):

[18:41] <dalek> rakudo/nom: sub forms of pop, shift, push

[18:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2a8943611

[18:46] <moritz_> nom: my @a = <a b c d>, [<e f g h>]; say "@a[]"

[18:46] <p6eval> nom: OUTPUT«a b c d e f g h␤»

[18:48] <dalek> roast: 2895952 | moritz++ | S02-literals/array-interpolation.t:

[18:48] <dalek> roast: fudge array-interpolation.t

[18:48] <dalek> roast: review: https://github.com/perl6/roast/commit/2895952596

[18:53] *** Instil joined
[19:01] <dalek> rakudo/nom: 97e5710 | moritz++ | t/spectest.data:

[19:01] <dalek> rakudo/nom: nine more passing test files

[19:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/97e571018b

[19:01] *** slavik1 left
[19:01] *** wamba left
[19:05] <[Coke]> how close are we getting to master?

[19:05] *** wamba joined
[19:05] <masak> "mastering nom in 20 days" :)

[19:06] <[Coke]> nom:  my $a = 1, 2, 3; $a = $a.grep({1}); say $a.perl

[19:06] <p6eval> nom: OUTPUT«(1,).list.item␤»

[19:07] <[Coke]> nom: 5.

[19:07] <p6eval> nom: OUTPUT«Confused at line 1, near "5."␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[19:07] <masak> that's how I feel about Haskell.

[19:07] <masak> "Confused at line 1" :P

[19:08] <jlaire> :D

[19:08] <jlaire> line 1: 'module Main where'

[19:08] <jlaire> or just, 'main = print 42'

[19:08] <masak> aaaugh confused

[19:09] <masak> ;)

[19:11] <Util> In a temp dir, I did this: GIT_SSL_NO_VERIFY=true git clone https://github.com/sorear/niecza.git

[19:11] <Util> then `cd niecza; git status`.

[19:11] <Util> It shows changes not staged for commit! How is this possible?

[19:11] <lue> hello world! o/

[19:11] <masak> \o

[19:11] <masak> Util: that's what you get for turning off SSL :P

[19:12] <flussence> that's bizarre, it doesn't do it for me

[19:12] <masak> hacked immediately.

[19:13] <sjohnson> hax0r

[19:14] <jlaire> Util: what changes?

[19:14] <jlaire> (and why NO_VERIFY?)

[19:15] <jlaire> works fine for me

[19:16] <Util> Hmmm. actually, it works for me too on Linux with Git 1.7.1. Failing on OS X 10.5, Git 1.7.5.1

[19:16] <Util> jlaire: NO_VERIFY because of old certificates on my laptop

[19:17] <Util> OK, I can pursue it since I have a known-good to work from.

[19:17] <Util> Thanks, all!

[19:17] <Util> jlaire: Large patch to hoopl/Nam.hs is the uncommitted change.

[19:18] <sjohnson> nom nom noms

[19:18] <jlaire> Util: huh, bizarre indeed...

[19:18] *** envi left
[19:25] *** birdwindupbird joined
[19:31] *** birdwindupbird left
[19:37] *** cooper left
[19:37] *** wamba left
[19:47] *** kaare_ left
[19:47] <lue> rakudo: say 2.Rat

[19:47] <p6eval> rakudo 72d158: OUTPUT«2␤»

[19:51] <lue> I see the Int.Rat method is there in nom (contrary to what LHF.markdown says)

[19:53] <masak> nom: say 2.Rat

[19:53] <p6eval> nom: OUTPUT«2␤»

[19:53] <masak> nom: say 2.Rat.WHAT

[19:53] <p6eval> nom: OUTPUT«Rat()␤»

[19:53] <masak> so it seems.

[19:54] <masak> lue: feel free to take it out of LHF.markdown

[19:54] <lue> I wouldn't be able to commit it though.

[19:54] <pmichaud> anyone besides me want to do s/\.markdown/.md/   ooc ?

[19:54] <masak> the thought has occurred to me :)

[19:55] <masak> but it's not that important

[19:55] <masak> lue: ok, I'll do it, then.

[19:56] <lue> How do I get rakudo commit privileges, again? Last I remember, it involved going through some (relatively) big process.

[19:57] <dalek> rakudo/nom: a2b9926 | masak++ | LHF.markdown:

[19:57] <dalek> rakudo/nom: [LHF.markdown] Int.Rat implemented

[19:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a2b99262c2

[19:57] <lue> nom: say Mu ~~ 0

[19:57] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'ACCEPTS'. Available candidates are:␤:(Numeric, Any $a)␤:(Mu, Mu $topic)␤␤current instr.: 'ACCEPTS' pc 304115 (src/gen/CORE.setting.pir:80419) (:227)␤»

[19:57] <pmichaud> looks like a bug in Int.ACCEPTS

[19:57] <pmichaud> ACCEPTS should always have a Mu $topic

[19:58] <pmichaud> nom:  say '3' ~~ 0

[19:59] <p6eval> nom: OUTPUT«Bool::False␤»

[19:59] <lue> so there should be a ACCEPTS method defined in Int.pm?

[19:59] <pmichaud> no, wait

[19:59] <pmichaud> it's using Numeric accepts

[19:59] <masak> makes sense.

[19:59] <pmichaud> but it seems like it ought to fall back to Mu.ACCEPTS

[19:59] <pmichaud> looking

[20:00] <pmichaud> I guess we need  multi method ACCEPTS(Mu:D: Mu \$topic) { Bool::False }

[20:00] <pmichaud> (in Mu.pm)

[20:00] <pmichaud> that gives all of the ACCEPTS methods something to fall back to

[20:00] <masak> +1

[20:01] <lue> nom: say 0 ~~ Mu; # this works though

[20:01] <p6eval> nom: OUTPUT«Bool::True␤»

[20:01] <pmichaud> sure, because Mu is undef

[20:01] <pmichaud> so Mu.ACCEPTS(Mu:U, Mu \$topic)   is able to handle it

[20:02] <pmichaud> we're missing a Mu:D: case

[20:02] <pmichaud> (the object is concrete, but the type didn't define a matching .ACCEPTS method)

[20:02] <lue> Does the spec detail the meaning of Mu:D: Mu:U: and so on?

[20:02] <pmichaud> yes

[20:03] <pmichaud> Mu:D  only matches "concrete" objects -- i.e., things that aren't types

[20:03] <pmichaud> Mu:U only matches "abstract" objects -- i.e., types

[20:03] <masak> S12:1528

[20:04] <masak> the :D and :U specifiers are basically waterbed kickback from unifying types and their instances.

[20:05] <lichtkind> masak++ for that expression

[20:06] <lue> So (if I got this right), Mu:U means any undefined Mu value (e.g. Mu), while Mu:D is for clearly defined Mu values (e.g. 42)

[20:07] <pmichaud> in principle, yes.

[20:07] <pmichaud> it's really "abstract" versus "concrete", instead of "undefined" versus "defined"

[20:07] <pmichaud> some concrete objects can be undefined if they override the .defined method

[20:07] <pmichaud> but still won't match :D

[20:08] <masak> lichtkind: nah, I'm just being high-falutin' :P

[20:10] <pmichaud> .oO( what kind of high-falutin' language is "high-falutin'", anyway?)

[20:10] <pmichaud> (almost an autopun)

[20:10] <masak> yes :)

[20:14] <dalek> nqp: 8557631 | pmichaud++ | src/core/NQPMu.pm:

[20:14] <dalek> nqp: Add a version of __dump() to NQPMu so that NQP objects can

[20:14] <dalek> nqp: be used by Parrot's Data::Dumper.

[20:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8557631585

[20:15] <lue> .oO(Drive-by punning.)

[20:15] <pmichaud> afk for a bit

[20:16] <lue> here's a question: when nom becomes master, will the current master become 'ng' [like it was before] or something else (maybe 'beta')?

[20:17] <masak> yes.

[20:17] <masak> :)

[20:17] <moritz_> "ug"

[20:17] <moritz_> erm, "og"

[20:17] <dalek> rakudo/nom: 59ec8c6 | moritz++ | / (2 files):

[20:17] <dalek> rakudo/nom: infix cmp for Pairs

[20:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59ec8c6a6b

[20:18] <masak> "pg"

[20:18] <masak> (previous)

[20:19] * masak read "infix cmp for Paris", probably due to TimToady's recent deliberate confusion of the two

[20:20] <masak> rakudo: subset Paris; subset Berlin; say Paris ~~ Berlin

[20:20] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[20:20] <masak> Peris, Berlin... wassedifference? :P

[20:20] *** s1n left
[20:20] <masak> er, Paris*

[20:20] <moritz_> perl6: say -13 mod 4

[20:20] <p6eval> rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«3␤»

[20:20] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "mod"␤    expecting operator, ":" or ","␤    at /tmp/kyc7uC34i4 line 1, column 9␤»

[20:21] <jlaire> rakudo: say -(13 mod 4); say (-13) mod 4

[20:21] <p6eval> rakudo 72d158: OUTPUT«-1␤3␤»

[20:21] <masak> pugs: say -13 % 4

[20:21] <p6eval> pugs: OUTPUT«3␤»

[20:21] <masak> there are two schools of thought with % and mod.

[20:21] <masak> I'm glad we're adhering to this one :)

[20:22] <masak> oh wait.

[20:22] <masak> no, it's what happens when you negate the rhs that's the difference.

[20:22] <masak> perl5: say 13 mod -4

[20:22] <masak> perl6: say 13 mod -4

[20:22] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "mod"␤    expecting operator, ":" or ","␤    at /tmp/ATrAMz4s5g line 1, column 8␤»

[20:22] <p6eval> ..rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«-3␤»

[20:22] <masak> pugs: say 13 % -4

[20:22] <p6eval> pugs: OUTPUT«-3␤»

[20:23] <masak> consistency across the board, at least.

[20:24] <lue> rakudo: say 5 mod 2.5

[20:24] <p6eval> rakudo 72d158: OUTPUT«No applicable candidates found to dispatch to for 'infix:<div>'. Available candidates are:␤:(Int $a, Int $b)␤␤  in 'infix:<mod>' at line 3803:src/gen/core.pm␤  in main program body at line 22:/tmp/89dWAKkNrR␤»

[20:25] <jlaire> perl6: sub f($x, $y) { $x - floor($x / $y) * $y }; say f(13, -4)

[20:25] <p6eval> pugs, rakudo 72d158, niecza v7-11-g9ba8284: OUTPUT«-3␤»

[20:26] <lue> rakudo: sub f($x, $y) { $x - floor($x / $y) * $y }; say f(5, 2.5)

[20:27] <p6eval> rakudo 72d158: OUTPUT«0␤»

[20:27] <dalek> roast: 674bf37 | moritz++ | S03-operators/arith.t:

[20:27] <dalek> roast: fudge arith.t for rakudo

[20:27] <dalek> roast: review: https://github.com/perl6/roast/commit/674bf37a2a

[20:27] <jlaire> perl6: sub f($x, $y) { $x - floor($x / $y) * $y }; say f(pi + 3i, e - i)

[20:27] <p6eval> niecza v7-11-g9ba8284: OUTPUT«Unhandled exception: floor is only defined for Reals, you have a Complex()␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE floor @ 0) ␤  at /tmp/vFHR6rnJR8 line 1 (MAIN f @ 2) ␤  at /tmp/vFHR6rnJR8 line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza…

[20:27] <p6eval> ..rakudo 72d158: OUTPUT«floor is only defined for Reals, you have a Complex()␤Method 'Bridge' not found for invocant of class 'Failure'␤  in 'infix:<*>' at line 3783:src/gen/core.pm␤  in 'infix:<*>' at line 4593:src/gen/core.pm␤  in 'f' at line 22:/tmp/z2u0sm9GVB␤  in main program body at…

[20:27] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&e"␤    at /tmp/OcUYq6OsNb line 1, column 60-65␤»

[20:27] <jlaire> lol

[20:28] <moritz_> hey, niecza and rakudo agree

[20:28] <dalek> rakudo/nom: 535395f | moritz++ | t/spectest.data:

[20:28] <dalek> rakudo/nom: run arith.t

[20:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/535395f44e

[20:28] <jlaire> yeah, that's nice

[20:28] <moritz_> nom: say <a b c>.sort

[20:28] <p6eval> nom: OUTPUT«Method 'sort' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 96 ((file unknown):20812801) (:1)␤»

[20:28] <moritz_> nom: say <a b c>.list.sort

[20:28] <p6eval> nom: OUTPUT«Method 'sort' not found for invocant of class 'List'␤current instr.: '_block1002' pc 108 ((file unknown):23698851) (:1)␤»

[20:28] <moritz_> ENOSORTYET

[20:29] <pmichaud> I can add it.

[20:29] <moritz_> $ ack -lw sort t/spec| wc -l

[20:29] <moritz_> 55

[20:29] <moritz_> might be worthwhile

[20:29] <jlaire> nom: say <a b c>.list.pick(*)

[20:29] <p6eval> nom: OUTPUT«Method 'pick' not found for invocant of class 'List'␤current instr.: '_block1002' pc 121 ((file unknown):205) (:1)␤»

[20:30] <moritz_> nom: say ~Int

[20:30] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤␤»

[20:30] <moritz_> nom: say Int.Str

[20:30] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤␤»

[20:32] <dalek> roast: e0f3ae7 | moritz++ | S14-roles/lexical.t:

[20:32] <dalek> roast: correct and fudge S14-roles/lexical.t

[20:32] <dalek> roast: review: https://github.com/perl6/roast/commit/e0f3ae776f

[20:33] <dalek> rakudo/nom: 8f1d810 | moritz++ | t/spectest.data:

[20:33] <dalek> rakudo/nom: two more passing test files

[20:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8f1d810c5b

[20:34] *** s1n joined
[20:34] *** bluescreen10 left
[20:36] <lue> how do I get a commit bit for rakudo? I'd like to start contributing to nom before all the easy stuff is gone :) ['cos then when the hard stuff is left, I'll be familiar enough with the code to work on those 'HHF']

[20:37] <moritz_> lue: first you submit a few good patches / pull request

[20:37] <moritz_> lue: and submit a CLA

[20:37] *** soh_cah_toa joined
[20:37] <moritz_> http://www.perlfoundation.org/contributor_license_agreement

[20:38] *** mj41 left
[20:39] <dalek> rakudo/nom: 56a1e10 | moritz++ | / (2 files):

[20:39] <dalek> rakudo/nom: Complex.sqrt, tests

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/56a1e10b13

[20:40] <[Coke]> with git (+github) it's really easy to fork an existing project and submit pull requests.

[20:40] <lue> (the snail-mail-only part surprised me for a second)

[20:40] <moritz_> pmichaud: t/spec/S04-statements/for-scope.t seems to be mostly changed stringification semantics, would appreciate if you could take a look at your convenience

[20:41] *** donri left
[20:43] <pmichaud> moritz_: will do

[20:43] <masak> rakudo: { our sub foo { say "OH HAI" } }; foo

[20:43] <p6eval> rakudo 72d158: OUTPUT«OH HAI␤»

[20:43] <masak> nom: { our sub foo { say "OH HAI" } }; foo

[20:43] <p6eval> nom: OUTPUT«Could not find sub &foo␤current instr.: '_block1002' pc 84 ((file unknown):33653897) (:1)␤»

[20:43] * masak nomds solemnly

[20:43] <masak> er, nods*

[20:44] <pmichaud> almost done with sort

[20:44] *** am0c_ joined
[20:44] <Util> perl6: sub nnn ( @a         ) { @a.perl.say }; nnn( [1,2,3] );

[20:44] <p6eval> niecza v7-11-g9ba8284: OUTPUT«[1, 2, 3].list␤»

[20:44] <p6eval> ..pugs, rakudo 72d158: OUTPUT«[1, 2, 3]␤»

[20:44] <Util> perl6: sub nnn ( @a is copy ) { @a.perl.say }; nnn( [1,2,3] );

[20:45] <p6eval> pugs: OUTPUT«[[1, 2, 3],]␤»

[20:45] <p6eval> ..rakudo 72d158: OUTPUT«[1, 2, 3]␤»

[20:45] <p6eval> ..niecza v7-11-g9ba8284: OUTPUT«[[1, 2, 3]].list␤»

[20:45] <Util> "is copy" makes niecza mis-handle the array?

[20:45] <pmichaud> looks like it.  and pugs also.

[20:46] <Util> should be [1,2,3] not [[1,2,3]], right?

[20:46] <pmichaud> I'm pretty sure it should be [1,2,3], yes.

[20:46] <Util> Thanks

[20:46] *** bluescreen10 joined
[20:46] <pmichaud> > say <the quick brown fox>.sort

[20:46] <pmichaud> brown fox quick the

[20:47] <masak> \o/

[20:47] <moritz_> \o/

[20:47] *** am0c left
[20:47] <dalek> rakudo/nom: 3e5c741 | pmichaud++ | src/core/ (2 files):

[20:47] <dalek> rakudo/nom: Add List.sort and Any.sort.

[20:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e5c741bf4

[20:50] <thou> \o/

[20:50] *** mj41 joined
[20:51] <pmichaud> fix for for-scope.t coming.

[20:52] *** [Coke] left
[20:54] *** [Coke] joined
[20:54] <[Coke]> anyone see an issue with copying over IO's "unlink" sub directly from master to nom?

[20:55] <dalek> rakudo/nom: ca93c8a | pmichaud++ | src/core/Any.pm:

[20:55] <dalek> rakudo/nom: Fix Any.join -- default separator should be '' and not ' '.  pmichaud--  S04-statements/for-scope.t now passes.  moritz++

[20:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca93c8a891

[20:55] <pmichaud> we're thinking the IO API should change, but I don't have a problem with it for now.

[20:55] *** dorlamm joined
[20:55] <pmichaud> so, +1 from me.

[20:56] <dalek> rakudo/nom: 2cac886 | pmichaud++ | t/spectest.data:

[20:56] <dalek> rakudo/nom: Add S04-statements/for-scope.t to spectest.data.

[20:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2cac886253

[20:57] <pmichaud> nom now passing 148 files and 3205 tests.

[20:57] <moritz_> that's good progress

[20:58] <pmichaud> I'm working on regexes

[20:58] <pmichaud> but that one is going to be a 2-day project or so

[20:58] <pmichaud> (to do "right", that is)

[20:58] <moritz_> regex integration in nom?

[20:59] <pmichaud> yes.

[20:59] <pmichaud> I suspect that will win us a bunch of tests.

[20:59] <moritz_> I'm surprised it'll be so much effort

[21:00] <pmichaud> the way we do regexes in master is quite different

[21:00] <moritz_> after all the wrapping layer isn't too much code

[21:00] <pmichaud> if we try to do the same thing in nom, we'll end up with a bunch of Parrot objects in our data

[21:00] <moritz_> so what's the plan?

[21:01] <pmichaud> I'm working on some fundamental regex engine changes

[21:01] <pmichaud> this will also get us some big speed wins, I suspect.

[21:01] <masak> \o/

[21:01] <pmichaud> it will also lay the groundwork for true LTM

[21:01] <pmichaud> (which will give us still more speed wins)

[21:02] *** am0c_ is now known as am0c

[21:02] <moritz_> that will make all of us and the spectest runs happy :-)

[21:02] *** am0c is now known as Guest88135

[21:02] <pmichaud> anyway, I figure it's better to get the core regex changes in now, rather than try to patch something in to nom just to "get it working" and then have to re-do it all again later.

[21:03] <pmichaud> if it looks like the regex engine changes will take more than two days, I'll suspend and go with the "patch something in" approach.

[21:03] *** Guest88135 left
[21:03] *** am0c_ joined
[21:03] *** Instil left
[21:04] <pmichaud> (more details:  in master, Regex/Cursor/Match objects were all based on P6object, and thus had the same metamodel at their base.  In nom, the regex engine objects are based on NQPMu while the Perl 6 objects are based on Rakudo's Mu class.  Getting all of the mappings correct will be expensive and prone to mistakes.

[21:05] <pmichaud> it's much better if we just make clean mappings out the outset. )

[21:05] <[Coke]> pmichaud++

[21:05] *** takadonet left
[21:05] <masak> yay clean mappings

[21:05] *** takadonet joined
[21:06] <tadzik> hello

[21:06] <pmichaud> and as I said, after studying the problem over the weekend I've found some big optimizations, I think.

[21:06] <masak> tadzik! \o/

[21:06] <tadzik> masak: o/

[21:06] *** aindilis left
[21:08] *** dolmen joined
[21:08] <[Coke]> bah. adding in unlink causes t/spec/integration/say-crash.t to crash instead of report a failure. ;)

[21:08] * arnsholt crosses fingers for LTM

[21:09] <[Coke]> (segfault)

[21:15] *** takadonet left
[21:18] *** MayDaniel joined
[21:20] <moritz_> nom: pir::new__PS('OS').rm("rakudo/README")

[21:20] <p6eval> nom: OUTPUT«Class 'OS' not found␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[21:22] <[Coke]> in master, unlink has "try {}\n $! ?? fail($!) !! True" ... is there a better way to write this in NOM?

[21:22] <[Coke]> moritz_: yah, needs to add "os" to the list of things loaded in...

[21:22] <[Coke]> src/Perl6/Actions.pm

[21:23] <moritz_> look pretty standard to me

[21:24] *** Jackneill left
[21:25] *** MayDaniel left
[21:30] *** Instil joined
[21:33] <[Coke]> #0  0x000000010164e3f9 in Rakudo_cont_decontainerize ()

[21:34] <[Coke]> https://gist.github.com/1063975 #add unlink

[21:35] <[Coke]> https://gist.github.com/1063976 #segfault

[21:38] *** Util left
[21:38] *** thou left
[21:38] *** pmichaud left
[21:38] *** hugme left
[21:38] *** PerlJam left
[21:42] *** Psyche^ joined
[21:44] <masak> blog post! http://strangelyconsistent.org/blog/june-27-2011-classes

[21:44] <dalek> nqp: de23ea5 | pmichaud++ | src/core/NQPMu.pm:

[21:44] <dalek> nqp: Make NQPMu.__dump aware of native types in attributes.

[21:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/de23ea5261

[21:46] *** Patterner left
[21:46] *** Psyche^ is now known as Patterner

[21:48] *** pmichaud joined
[21:48] <pmichaud> looks like feather died or otherwise became disconnected. :)(

[21:48] <pmichaud> :(

[21:49] <masak> aww

[21:49] <masak> (that's why you all missed my blog post announcement)

[21:49] <pmichaud> correct

[21:49] <masak> blog post! http://strangelyconsistent.org/blog/june-27-2011-classes

[21:49] <masak> :P

[21:49] <pmichaud> there's a "The the" in the post

[21:50] <masak> thanks, fixing.

[21:50] <pmichaud> I did see the announcement, thanks to irclog :)

[21:51] <masak> yes, but I know how much people like to click on links in their IRC clients :P

[21:51] <pmichaud> "collect" feels like the wrong sub/method name somehow.

[21:51] *** MOAR-f00li5h is now known as f00li5h

[21:52] <pmichaud> "Every class gets a (default) .new method for free"

[21:52] <pmichaud> might add "default" in there.

[21:52] <masak> aye.

[21:52] <masak> pmichaud: "give_ticket"?

[21:53] <pmichaud> or "get_ticket"

[21:53] <masak> doesn't that have the same problems as "collect"?

[21:54] <masak> maybe just "dispense_ticket"?

[21:54] <pmichaud> that works too

[21:54] * masak makes it so

[21:54] <pmichaud> "collect" is also an adjective and a noun so it might be a little ambiguous.

[21:55] <masak> ah -- I didn't know that :)

[21:55] <pmichaud> well, we have "collect calls"

[21:55] <pmichaud> and "collect" is also a form of prayer

[21:55] <masak> in Sweden it's the money you give during service.

[21:56] <masak> though I guess that might be a derived meaning... :)

[21:57] * pmichaud wonders about Platonic Programming after reading masak++ 's post

[21:57] <flussence> typo! s/pretict/predict/

[21:57] <masak> thank you. fixing.

[21:58] <pmichaud> yes, instead of one dispenser giving an infinite number of tickets, we now have infinite dispensers.  :)

[21:58] <masak> Oops. :-)

[21:58] <pmichaud> The heat death of the universe will undoubtedly follow shortly, all because everyone is greedy for a free lunch.  :)

[21:58] <masak> bastards.

[21:58] <pmichaud> (insert pity state of Greek economy quote here.)

[21:58] <pmichaud> *pithy

[21:58] <masak> well, pity as well :P

[21:59] <masak> and keep in mind that the Greeks *invented* platonism!

[21:59] <pmichaud> lol... I didn't quite make that connection.  masak++

[21:59] <pmichaud> time for me to change locations -- bbiaw

[21:59] *** pmichaud left
[22:00] <jlaire> masak: before "Oops.", the last .collect should be on $d2

[22:00] <jlaire> it's $d1

[22:02] <jlaire> oh, F5 and it's fixed

[22:03] <masak> yes, but thanks :)

[22:03] *** drbean joined
[22:09] *** felliott left
[22:10] *** felliott joined
[22:11] *** am0c_ left
[22:11] *** tadzik joined
[22:11] *** pmichaud joined
[22:12] *** Util joined
[22:12] *** PerlJam joined
[22:16] *** amkrankruleuen left
[22:16] *** Mowah left
[22:16] *** hatseflats joined
[22:20] <pmichaud> \o/ feather back

[22:23] <masak> well, that's it for me. 'night, #perl6.

[22:23] *** masak left
[22:26] *** amkrankruleuen joined
[22:31] *** kst` is now known as kst

[22:31] *** Eevee joined
[22:35] *** Tedd1^ joined
[22:37] *** Tedd1 left
[22:42] *** ab5tract left
[22:43] <TimToady> pugs: macro add'em($a,$b) { "($a + $b)" }; say add'em(3,4);

[22:43] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "'"␤    expecting "::", "handles", "is", bare trait, subroutine parameters, trait or block␤    at /tmp/uLfxdP92dL line 1, column 10␤»

[22:43] <TimToady> pugs: macro addem($a,$b) { "($a + $b)" }; say addem(3,4);

[22:43] <p6eval> pugs: OUTPUT«7␤»

[22:43] <TimToady> pugs: macro add-em($a,$b) { "($a + $b)" }; say add-em(3,4);

[22:43] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "-"␤    expecting "::", "handles", "is", bare trait, subroutine parameters, trait or block␤    at /tmp/7EmN3i6ceS line 1, column 10␤»

[22:44] *** rlb3 joined
[22:47] *** mj41 left
[22:49] *** dorlamm left
[22:49] *** Chillance left
[23:04] *** rlb3 left
[23:05] *** rlb3 joined
[23:05] *** cooper joined
[23:15] *** [Coke] left
[23:17] *** [Coke] joined
[23:26] *** Moukeddar joined
[23:29] *** orafu left
[23:29] *** orafu joined
[23:32] *** [Coke] left
[23:32] *** Moukeddar_ joined
[23:33] *** Moukeddar left
[23:33] *** [Coke] joined
[23:34] *** Moukeddar_ is now known as Moukeddar

[23:39] *** [Coke] left
[23:39] *** dolmen left
[23:39] *** tokuhirom joined
[23:40] *** [Coke] joined
[23:42] *** Moukeddar left
[23:42] *** molaf_ left
[23:45] *** drbean left
[23:48] *** cooper left
[23:51] *** [particle]1 joined
[23:53] *** leprevost left
[23:54] *** [particle] left
