[00:12] *** Guest11301 left
[00:16] *** ingyfoo is now known as ingy

[00:23] *** aloha left
[00:23] *** aloha joined
[00:26] *** Radvendii joined
[00:28] <sorear> o/ Radvendii 

[00:30] *** whiteknight joined
[00:31] *** whiteknight is now known as Guest33719

[00:37] <sorear> hmm.  the ICU preparser doesn't have a copyright licence

[00:43] *** Radvendii left
[00:48] *** shinobicl_ left
[00:55] *** molaf_ joined
[00:58] *** molaf left
[01:10] *** drbean left
[01:17] *** drbean joined
[01:34] <sjn> Question... Would it be sensible (for symmetry) to allow method names starting with . ? (the symmetry would be with private methods, who are declared thus: "method !name() { ... }" )

[01:34] <sjn> e.g.   method .name() { ... }

[01:35] * sjn imagines the . would do absolutely nothing in that postition, other than create a symmetry completeness between the meanings of . and ! 

[01:36] <sjn> the point with this, to make it a bit easier to teach Perl6 

[01:36] <Juerd> I wouldn't mind. But I wouldn't mind $foo.!bar either

[01:37] <Juerd> $foo!bar is slightly disturbing though

[01:37] * sjn likes the convention of ! being a "dot, but with a blocking line above it"

[01:37] <Juerd> Not enough to lose any sleep over.

[01:37] <Juerd> In programming, ! isn't typically any kind of special dot.

[01:37] <flussence> so... it's a not-dot? :)

[01:38] <Juerd> ! isn't related to .

[01:38] <sorear> except in intercal

[01:38] <Juerd> !! isn't related to ..

[01:38] <sjn> yes, it usually isn't

[01:38] <Juerd> So that mnemonic doesn't really work for me

[01:38] <sjn> you can't call methods with ..

[01:38] <Juerd> I meant !! in ??!!

[01:39] <sjn> ah

[01:39] <sjn> well, that's fine

[01:39] <sjn> I can't se any ambiguities there, at least

[01:39] <Juerd> Also, $foo? and $foo! don't have a $foo. sibling

[01:40] <Juerd> ! being some kind of extension to . is the exception, and definitely not a rule

[01:40] <sjn> well, exceptions in memes are bad for memorability

[01:40] <Juerd> Perhaps it's for that reason that it feels contrived

[01:40] <sjn> consistencies are better

[01:40] <Juerd> In any case, I don't really object to it, but I'm not entirely comfortable with it either.

[01:40] <Juerd> Yes, consistency is nice in any case.

[01:41] <sjn> ! _is_ a bit weird for a privacy memetic

[01:41] <Juerd> And I always do think it's easier to explain the absense of something as invoking a default, than to explain that to get different behavior you need to add something else.

[01:42] <Juerd> That's one of the reasons I wanted <->. It's easier to say that "for @foo { ... }" defaults to <-> rather than ->, than to explain that it's like "for @foo -> $_ is rw"

[01:43] * sjn doesn't know <->

[01:43] <Juerd> So I'd like to say that "method xyzzy" is short for "method .xyzzy"

[01:43] <Juerd> <-> is the same as ->, but implies "is rw" on its parameters.

[01:43] <sjn> aah

[01:43] <sjn> neat

[01:43] <Juerd> <-> $foo, $bar { ... } is like -> $foo is rw, $bar is rw { ... }

[01:43] <Juerd> Especially useful in for loops.

[01:44] <sjn> yep

[01:44] <sjn> no implicit aliasing of array content to $_ in loops

[01:44] <sjn> veeery nice :)

[01:45] <Juerd> It does still do that

[01:46] <Juerd> for @foo { ... } is short for for @foo <-> $_ { ... } which in turn is short for for @foo -> $_ is rw { ... }

[01:46] <sjn> ok

[01:46] <sjn> hm

[01:46] <sjn> well, so the default is to assume rw aliasing :-/

[01:46] <sjn> ah well

[01:46] <Juerd> If you don't like the implicit behavior you can always be explicit of course, and in a consistent and intuitive way.

[01:47] <sjn> yep, that's at least a plus

[01:47] <Juerd> If you want ro aliasing simply use ->. If you read Perl 6 code that's already out there, you'll see that this is actually what most people choose to do most of the time.

[01:47] <sjn> mm

[01:47] <sjn> and it makes the intention of the code much clearer too

[01:48] <Juerd> <-> was meant to indicate the bidirectionalism

[01:48] <Juerd> <- could be fun but there probably isn't any use to it, and it'd be hard to parse :)

[01:49] <Juerd> With <=> being the "spaceship operator", I wonder if <-> will get a nickname too.

[01:49] <sjn> "the flat spaceship operator" :-P

[01:50] * sjn isn't particularly creative at 3am

[01:50] <sjn> <- off to bed

[01:50] <sjn> nn guys

[01:51] <Juerd> Good night

[01:54] <sjn> oh, and thanks for the <-> explanation, Juerd :)

[01:58] *** drbean left
[02:05] *** drbean joined
[02:24] *** orafu left
[02:24] *** orafu joined
[02:25] *** alvis left
[02:28] *** Guest33719 left
[02:29] *** aloha left
[02:33] <colomon> jnthn++ # emergency Advent post

[02:38] *** aloha joined
[02:41] *** alvis joined
[02:43] *** JimmyZ_ joined
[02:46] *** drbean left
[02:51] *** wolfman2000 joined
[02:53] *** drbean joined
[02:56] *** JimmyZ_ left
[02:59] *** donri left
[03:12] *** aloha left
[03:12] *** aloha joined
[03:24] *** replore joined
[03:31] * sorear sent mail to the ICU people asking about terms of use for their UCD parser

[03:42] *** envi_ joined
[03:48] *** REPLeffect left
[04:21] *** drbean left
[04:24] <sorear> rakudo: /<[abc]&[bce]>/

[04:24] <p6eval> rakudo d2a096: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 1, near "&[bce]>/"␤»

[04:27] *** jimmy1980 left
[04:29] *** drbean joined
[04:29] *** REPLeffect joined
[04:33] *** jimmy1980 joined
[04:41] *** drbean left
[04:47] *** drbean joined
[04:50] *** thou left
[05:01] *** drbean left
[05:04] * sorear is looking at QRegex now and trying to figure out how it works.

[05:04] <sorear> rakudo: say "a" ~~ /a & a/

[05:04] <p6eval> rakudo d2a096: OUTPUT«=> <a>␤␤»

[05:05] <sorear> jnthn: ping

[05:05] <sorear> pmichaud: ping

[05:08] *** drbean joined
[05:09] *** kaleem joined
[05:14] *** sftp left
[05:22] *** mdxi left
[05:34] <sorear> jnthn: pmichaud: unping.  I was actually able to figure out QRegex on my own

[05:36] <moritz> jnthn++ # advent post

[05:36] <sorear> o/ moritz

[05:36] <moritz> good morning everybody and sorear :-)

[05:39] *** molaf_ left
[05:43] <dalek> roast: 7133c0f | moritz++ | S32-temporal/DateTime-Instant-Duration.t:

[05:43] <dalek> roast: rakudo refudges

[05:43] <dalek> roast: review: https://github.com/perl6/roast/commit/7133c0f095

[05:49] *** mkramer joined
[05:53] *** araujo left
[05:56] *** benabik left
[06:03] *** drbean left
[06:08] <sorear> Do we want LTM behavior to be exactly consistant across implementations?

[06:09] *** drbean joined
[06:25] <moritz> that would be nice, yes

[06:35] *** plutoid joined
[06:37] *** baest joined
[06:49] *** molaf joined
[07:01] *** koban joined
[07:13] *** wtw joined
[07:17] *** renormalist left
[07:17] *** renormalist joined
[07:34] <sorear> moritz: then I need a non-ad-hoc way of deciding when x & y is considered declarative

[07:40] <sorear> perhaps the answer is "never", which is what Rakudo does

[07:45] *** murker joined
[07:49] <jnthn> sorear: what does Niecza do with & at the moment for LTM?

[07:50] <sorear> niecza: /x & y/

[07:50] <p6eval> niecza v12-12-g0271e98: OUTPUT«Unhandled exception: Unable to resolve method oplift in class Any␤  at /home/p6eval/niecza/src/NieczaActions.pm6 line 340 (NieczaActions.op_for_regex @ 2) ␤  at /home/p6eval/niecza/src/NieczaActions.pm6 line 349 (NieczaActions.quote:sym</ /> @ 3) ␤  at /ho…

[07:50] <sorear> strange failure mode

[07:50] <sorear> anyway, & is NYI

[07:50] <jnthn> aha

[07:51] <jnthn> "never" doesn't seem like an unreasonable answer.

[07:51] <jnthn> ...but I didn't drink any coffee yet today :)

[07:51] <sorear> I'm thinking about character classes and perhaps allowing LTM for <[\w] & [\x00 .. \xFF]>

[07:51] <sorear> meh, probably not worth it

[07:51] *** plutoid left
[07:52] <sorear> rakudo: /<[\w]>/

[07:52] <p6eval> rakudo d2a096:  ( no output )

[07:54] <jnthn> rakudo: say 'a' ~~ /<[\w]>/

[07:54] <p6eval> rakudo d2a096: OUTPUT«=> <a>␤␤»

[07:54] <jnthn> phew :)

[07:54] <sorear> rakudo: 'a' ~~ /<[x\d]>/

[07:54] <p6eval> rakudo d2a096:  ( no output )

[07:54] <sorear> rakudo: say 'a' ~~ /<[x\d]>/

[07:54] <p6eval> rakudo d2a096: OUTPUT«#<failed match>␤»

[07:55] <cognominal___> moritz, you implemented the ACCEPT method in Any :  multi method ACCEPTS(Any:D: Mu \$a) { self === $a }

[07:55] <cognominal___> I dont understand the signature.

[07:55] *** cognominal___ is now known as cognominal

[07:55] <jnthn> oops, I'm working at $client today, ain't I...

[07:55] * jnthn commutes

[07:55] <sorear> jnthn: obvious bug: s/conj/alt/ on line 468 of src/QRegex/P6Regex/Actions.nqp

[07:56] <sorear> jnthn: see my last test

[07:56] <sorear> er

[07:56] <sorear> rakudo: say 'a' ~~ /<[a\d]>/

[07:56] <p6eval> rakudo d2a096: OUTPUT«=> <a>␤␤»

[07:56] <sorear> hrm

[07:56] <sorear> I wonder how this works

[07:57] <sorear> jnthn: nevermind I screwed up the test... the code is still "obviously wrong" but is working somehow

[07:57] <sorear> ah I see

[07:57] <sorear> obviously I need to sleep&

[07:58] *** domidumont left
[07:58] *** dod joined
[07:59] *** dod left
[07:59] *** domidumont joined
[08:00] <cognominal> I guess the Mu in the signature is redundant because Any:D: is a stricter constraint.

[08:02] *** daxim joined
[08:03] <moritz> cognominal: Any:D  is the type constraint of the invocant

[08:03] <moritz> the trailing : makes it the invocant marker

[08:04] <cognominal> thx, I did not notice the trailing :

[08:05] <cognominal> I am too much used to syntax highlighters and my brain gets lazy

[08:08] *** murker left
[08:09] *** mj41 joined
[08:16] *** plutoid joined
[08:17] *** am0c joined
[08:17] *** drbean left
[08:25] *** drbean joined
[08:26] *** araujo joined
[08:26] *** araujo left
[08:26] *** araujo joined
[08:37] * jnthn about again

[08:49] *** lestrrat left
[08:50] *** lestrrat joined
[09:01] <dalek> mu: f4c82d5 | moritz++ | misc/perl6advent-2011/schedule:

[09:01] <dalek> mu: [advent] update scheduel for the 11th

[09:01] <dalek> mu: review: https://github.com/perl6/mu/commit/f4c82d5d98

[09:19] <dalek> rakudo/ex-from-actions: f3f084c | moritz++ | src/Perl6/Actions.pm:

[09:19] <dalek> rakudo/ex-from-actions: thinko

[09:19] <dalek> rakudo/ex-from-actions: review: https://github.com/rakudo/rakudo/commit/f3f084cd7f

[09:24] *** snearch joined
[09:26] *** dakkar joined
[09:44] <snarkyboojum> hey guys, do I need to get access to post to the advent blog thingy?

[09:44] <moritz> snarkyboojum: yes

[09:44] <moritz> snarkyboojum: do you have an account on wordpress.com?

[09:44] <snarkyboojum> moritz: who can do that, and what info do they need?

[09:44] <snarkyboojum> yep - snarkyboojum

[09:44] <moritz> snarkyboojum: then I can invite you easily, I think

[09:44] <moritz> just a sec

[09:44] <snarkyboojum> moritz: cheers

[09:46] <moritz> snarkyboojum: sent

[09:46] <snarkyboojum> moritz: o/

[09:48] * moritz looks forward to ++snarkyboojum's post

[09:48] * jnthn too :)

[09:49] <jnthn> And I'm in again for the 14th, it seems... :)

[09:49] <snarkyboojum> it's not that exciting guys, but cheers :P

[09:49] <moritz> jnthn: it seems that HLL::Compiler.lineof returns 0-based line numbers. Is that intentional?

[09:49] <jnthn> moritz: Er

[09:50] <jnthn> So *that's* why I had to add 1 in the optimizer!

[09:50] <jnthn> :)

[09:50] <diakopter> lineoffby1

[10:01] *** grondilu joined
[10:02] <grondilu> Is panda supposed to work with nom?  It doesn't with me :(

[10:03] <jnthn> grondilu: What platform?

[10:03] <jnthn> grondilu: I thought the last blocker for it bootstrapping was resolved this weekend.

[10:03] *** replore left
[10:03] <jnthn> Though it doesn't work on Windows yet.

[10:04] <grondilu> jnthn: debian

[10:04] <jnthn> grondilu: If you're on something other than Windows, then yeah, it probably should work, and please let us know how it fails.

[10:06] <grondilu> I can't show you right now as I have pulled rakudo and not yet compiled.  But it showed me a long error message after about a minute of hanging.

[10:06] <grondilu> I'll make a screenlog next time

[10:07] <jnthn> grondilu: thanks.

[10:08] *** plutoid left
[10:10] <tadzik> grondilu: it should work on linuxes just fine

[10:11] <tadzik> I'm curious about the errors

[10:13] <jnthn> tadzik: Does it bootstrap fine for you now, given I sorted out the Test::Mock test suite?

[10:13] <tadzik> jnthn: aye

[10:14] <grondilu> I should have precised debian *sid*, though

[10:14] <tadzik> jnthn: I tried to sort out the IO.copy issues, and I'm more and more convinced that 'foo'.IO.copy('/some/directory/') should “just work”, no matter on which platform

[10:14] <dalek> rakudo/ex-from-actions: 602996b | moritz++ | src/core/Exception.pm:

[10:14] <dalek> rakudo/ex-from-actions: be explicit about calling .gist

[10:14] <dalek> rakudo/ex-from-actions: 

[10:14] <dalek> rakudo/ex-from-actions: IMHO it should work without it, but it does not. Not sure why

[10:14] <dalek> rakudo/ex-from-actions: review: https://github.com/rakudo/rakudo/commit/602996be39

[10:14] <dalek> rakudo/ex-from-actions: df1294a | moritz++ | src/Perl6/Actions.pm:

[10:14] <dalek> rakudo/ex-from-actions: HLL::Compiler.lineof returns 0-based line numbers

[10:14] <dalek> rakudo/ex-from-actions: 

[10:14] <dalek> rakudo/ex-from-actions: so add 1 to them for now

[10:14] <dalek> rakudo/ex-from-actions: review: https://github.com/rakudo/rakudo/commit/df1294ab96

[10:15] <tadzik> doesn't HLL::Compiler live in nqp?

[10:15] <moritz> it does

[10:15] <tadzik> I'll look at it

[10:16] <moritz> ... and it's written 100% in inline Q:PIR

[10:16] <moritz> thing is, if you change lineof, you need to change all calling locations too

[10:16] <tadzik> eww, pir

[10:16] <tadzik> yeah

[10:16] <tadzik> I'll look at it... in the undefined future :)

[10:16] <moritz> nqp/src/HLL/Grammar.pm

[10:16] <moritz> 321:        @args.push(HLL::Compiler.lineof($target, $pos) + 1);

[10:17] <moritz> so even the usage inside HLL::* adds 1

[10:17] <tadzik> :)

[10:17] <tadzik> oh, it's ackable

[10:17] <moritz> aye :-)

[10:17] <tadzik> HLL/Compiler.nqp:655: line = 0

[10:17] <moritz> seems to be used in only 3 place though... so not so bad

[10:18] <tadzik> let's try

[10:18] <moritz> it seems to have a single point of exit

[10:18] <moritz> so you can just add an    inc line  before the end :-)

[10:19] <tadzik> I'll just initialize it with 1

[10:20] *** grondilu left
[10:24] *** itz left
[10:24] <moritz> tadzik: beware, 'line' is also used as an array index

[10:24] <moritz> into the cache

[10:25] *** itz joined
[10:27] <moritz> if the parsing still spends significant amount of time in line_of, one could also replace the final loop with a binary search in linepos

[10:27] <tadzik> oh joy :)

[10:27] <jnthn> Parsing won't but code-gen may

[10:27] <jnthn> Taht's when we emit the .annotate

[10:28] *** jimmy1980 left
[10:33] *** jimmy1980 joined
[10:34] <moritz> tadzik: shall I have a go at it?

[10:34] <tadzik> moritz: I'm now building rakudo with the patched HLL::Compiler

[10:35] <moritz> tadzik: ok, I'll let you do it

[10:35] <tadzik> if you can build & spectest it on something more suitable than a laptop on battery, have a go :)

[10:35] <tadzik> still, we don't know whether it's intended and rational'd

[10:36] <moritz> tadzik: well, if two of us first mis-used the API, it's no good

[10:36] <tadzik> true

[10:36] * jnthn also mis-used it

[10:38] *** drbean left
[10:38] <moritz> jnthn: yes, you are no. 1 :-)

[10:39] <jnthn> oh :)

[10:45] *** drbean joined
[10:46] <moritz> tadzik: spectesting my changes now, on 4 cores :-)

[10:47] <tadzik> okay, nice :)

[10:47] <tadzik> I'll give that poor battery a rest

[10:50] <dalek> panda: a1a9f67 | tadzik++ | / (2 files):

[10:50] <dalek> panda: Make Panda::Ecosystem care about non-existent projects.json

[10:50] <dalek> panda: review: https://github.com/tadzik/panda/commit/a1a9f674c9

[10:50] <tadzik> oh look, a commit :)

[11:08] <moritz> tadzik: weird, my patch cause normal line numbers to be correctly reported, but the optimizer is off by -1

[11:08] <moritz> (so, reports the preceeding line)

[11:08] <moritz> hm, do I have to rebootstrap?

[11:11] *** yarp joined
[11:13] *** am0c left
[11:16] * moritz tries

[11:20] <moritz> oh, the optimizer uses PAST::Compiler.lineof, not HLL::Compiler.lineof

[11:20] * moritz hates the "two versions of everything" thing

[11:24] *** am0c joined
[11:26] <moritz> anyway, good to know that we have test coverage for some cases of line numbers :-)

[11:27] <dalek> nqp: f81b6c2 | moritz++ | src/HLL/ (2 files):

[11:27] <dalek> nqp: return 1-based line numbers of HLL::Compiler.lineof

[11:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f81b6c25ba

[11:27] <dalek> nqp: dc0ca28 | moritz++ | src/stage0/ (6 files):

[11:27] <dalek> nqp: update bootstrap

[11:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dc0ca287bf

[11:29] <dalek> rakudo/ex-from-actions: b690654 | moritz++ | / (3 files):

[11:29] <dalek> rakudo/ex-from-actions: use a HLL::Compiler.lineof that returns 1-based line numbers

[11:29] <dalek> rakudo/ex-from-actions: review: https://github.com/rakudo/rakudo/commit/b6906547e0

[11:29] <moritz> note that this commit needs to be cherry-picked to nom when somebody bumps the nqp revision there

[11:29] <moritz> or we need to merge the branch into master, which can happen soonish too

[11:31] *** risou_awy is now known as risou

[11:31] <moritz> like, after lunch :-)

[11:32] *** risou is now known as risou_awy

[11:34] <mls_> moritz: I don't like that lineof change. It makes nqp's lineof behave different than the one in PCT ("src/PCT/HLLCompiler.pir")

[11:34] <phenny> mls_: 04 Dec 21:01Z <jnthn> tell mls_ If you have a moment for an exception-related bug, in the following program the second try fails to catch: sub foo { fail "boo" }; my $val = foo(); try { ~$val }; say $!; try { ~$val; }; say "alive"

[11:39] <tadzik> I don't get how IO.copy('directory') works _sometimes_

[11:39] *** dudulz joined
[11:40] <tadzik> oh, wait

[11:42] <tadzik> jnthn: Now that I look at it, I don't think panda uses .copy('directory') at all

[11:53] *** koban left
[12:02] <tadzik> jnthn: what does t/panda/installer.t print out with https://gist.github.com/1466833?

[12:09] *** drbean left
[12:13] <jnthn> mls_: src/PCT/HLLCompiler.pir is no longer used by NQP and Rakudo

[12:14] *** snearch left
[12:14] <jnthn> tadzik: At $client so can't try that right now, sorry

[12:14] <jnthn> moritz: Feel free to make the optimizer use the other one.

[12:14] <tadzik> jnthn: ok, no worries

[12:16] *** drbean joined
[12:17] <mls_> so pmichaud++'s binary search optimization is no longer used? That's bad.

[12:17] <mls_> (when was this changed? Last time I looked nqp's lineof wasn't used)

[12:18] *** replore joined
[12:18] <mls_> jnthn: about the exception not being catched: it seems to be because Failure uses "rethrow" to rethrow the exception

[12:19] <mls_> I think it should work if you change it to use throw()

[12:19] *** replore left
[12:20] <mls_> (Hmm, maybe there's no throw() method, so probably pir::throw__0P )

[12:20] <jnthn> mls_: Gah, this two versions of stuff is getting confusing...

[12:20] <jnthn> Well, new NQP has not used PCT::HLLCompiler for a long time.

[12:21] *** envi_ left
[12:21] <jnthn> PAST::Compiler may still use it though.

[12:22] *** colomon left
[12:23] <mls_> (Exception.pm does have a throw() method)

[12:23] <jnthn> OK, I can try it this evening, or maybe somebody else has a tuit :)

[12:24] *** envi_ joined
[12:25] *** yarp left
[12:28] *** jeffreykegler joined
[12:34] *** mtk joined
[12:34] *** colomon joined
[12:38] *** drbean left
[12:43] *** drbean joined
[12:46] *** bluescreen10 joined
[12:48] *** kaleem left
[12:50] *** jeffreykegler left
[12:50] *** kaleem joined
[12:55] <dalek> nqp: 86b9112 | moritz++ | src/HLL/Compiler.pm:

[12:55] <dalek> nqp: backport lineof optimization from PCT

[12:55] <dalek> nqp: 

[12:55] <dalek> nqp: This backports the binary search lineof optimization from PCTs HLLCompiler

[12:55] <dalek> nqp: to HLL::Compiler.lineof

[12:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/86b9112c0e

[12:56] <moritz> mls_: I'm fine with changing src/PCT/HLLCompiler.pir too, but other projects might depend on it, and I have no idea which ones do

[12:57] <tadzik> I don't think anyone uses The New Nqp besides Rakudo :)

[12:58] <moritz> tadzik: HLLCompiler.pir is in the parrot repo

[12:58] <tadzik> oh, ok

[12:58] *** pen joined
[13:00] <moritz> nom: say 00802

[13:00] *** pen left
[13:00] <p6eval> nom d2a096: OUTPUT«802␤»

[13:01] <moritz> std: 00802

[13:01] <p6eval> std be1f10e: OUTPUT«Potential difficulties:␤  Leading 0 does not indicate octal in Perl 6; please use 0o0802 if you mean that at /tmp/IwgzoKdkr1 line 1:␤------> [32m00802[33m⏏[31m<EOL>[0m␤ok 00:01 118m␤»

[13:01] <moritz> maybe it shouldn't warn if the digits 8 or 9 appear in the literal :-)

[13:07] <moritz> std: 0o0802

[13:07] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Whitespace is required between alphanumeric tokens at /tmp/Bvu8pbTf8S line 1:␤------> [32m0o0[33m⏏[31m802[0m␤Two terms in a row at /tmp/Bvu8pbTf8S line 1:␤------> [32m0o0[33m⏏[31m802[0m␤    expecting any of:␤     POST␤   bracketed inf…

[13:12] *** jimmy1980 left
[13:13] *** jimmy1980 joined
[13:18] *** icwiener joined
[13:19] <dalek> roast: 1334a14 | moritz++ | integration/error-reporting.t:

[13:19] <dalek> roast: be less strict in line number checking; rakudo unfudges

[13:19] <dalek> roast: review: https://github.com/perl6/roast/commit/1334a14f5a

[13:19] <dalek> roast: d846e87 | moritz++ | S32-list/sort.t:

[13:19] <dalek> roast: remove debug output

[13:19] <dalek> roast: review: https://github.com/perl6/roast/commit/d846e87c26

[13:23] <moritz> nom: Code.Str

[13:23] <p6eval> nom d2a096: OUTPUT«Cannot look up attributes in a type object␤  in <anon> at src/gen/Metamodel.pm:2995␤  in method dispatch:<.?> at src/gen/CORE.setting:773␤  in method Str at src/gen/CORE.setting:657␤  in block <anon> at /tmp/gUKhDT_HSG:1␤  in <anon> at /tmp/gUKhDT_HSG:1␤»

[13:24] <moritz> nom: my $x := Code; $x.VAR.?name

[13:24] <p6eval> nom d2a096: OUTPUT«Cannot look up attributes in a type object␤  in <anon> at src/gen/Metamodel.pm:2995␤  in method dispatch:<.?> at src/gen/CORE.setting:773␤  in block <anon> at /tmp/CDVB8nl4Yk:1␤  in <anon> at /tmp/CDVB8nl4Yk:1␤»

[13:25] <moritz> jnthn: see above, I think that's a regression from the patch that shows the variable names in the uninitialized warnings

[13:25] <jnthn> moritz: I think it means Code's Str method is busted...

[13:25] <jnthn> moritz: Probably isn't multi and needing :D or some such.

[13:25] <moritz> jnthn: no, it's fine

[13:25] <jnthn> oh, wait

[13:25] <jnthn> yeah

[13:25] <jnthn> hm

[13:25] <moritz> jnthn: the second example doesn't use Code.Str at all

[13:25] <jnthn> ok, wtf

[13:25] <moritz> jnthn: I think it's becaused you used $v.VAR.?name

[13:25] *** hundskatt joined
[13:25] <jnthn> nom: Code.?name

[13:25] <p6eval> nom d2a096: OUTPUT«Cannot look up attributes in a type object␤  in <anon> at src/gen/Metamodel.pm:2995␤  in method dispatch:<.?> at src/gen/CORE.setting:773␤  in block <anon> at /tmp/qVNcx8PZAb:1␤  in <anon> at /tmp/qVNcx8PZAb:1␤»

[13:25] <jnthn> oh

[13:26] <moritz> jnthn: and .name can fail, even if it's dispatchable

[13:26] <jnthn> yeah

[13:26] <jnthn> Dunno what to do about that.

[13:26] <moritz> nom: class A { method name() { 'foo' } }; my $x := A; $x.Str

[13:26] <p6eval> nom d2a096: OUTPUT«Use of uninitialized variable foo of type A in string context␤»

[13:26] <moritz> erhm

[13:26] <jnthn> hm

[13:27] <jnthn> Maybe we need to check that .VAR.isa(Scalar) or some such :)

[13:27] <moritz> that's... LTA

[13:27] <moritz> aye

[13:27] <moritz> jnthn: I'll experiment with it

[13:27] <jnthn> VAR is spec'd as identity on anything non-container...

[13:27] <jnthn> er, non-scalar-container

[13:28] <jnthn> I think there's an nqp::iscont too or something

[13:28] <moritz> aye

[13:36] *** literal left
[13:37] *** avar left
[13:42] *** alim joined
[13:48] *** literal joined
[13:48] *** avar joined
[13:51] <dalek> rakudo/nom: f3f084c | moritz++ | src/Perl6/Actions.pm:

[13:51] <dalek> rakudo/nom: thinko

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f3f084cd7f

[13:51] <dalek> rakudo/nom: 602996b | moritz++ | src/core/Exception.pm:

[13:51] <dalek> rakudo/nom: be explicit about calling .gist

[13:51] <dalek> rakudo/nom: 

[13:51] <dalek> rakudo/nom: IMHO it should work without it, but it does not. Not sure why

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/602996be39

[13:51] <dalek> rakudo/nom: df1294a | moritz++ | src/Perl6/Actions.pm:

[13:51] <dalek> rakudo/nom: HLL::Compiler.lineof returns 0-based line numbers

[13:51] <dalek> rakudo/nom: 

[13:51] <dalek> rakudo/nom: so add 1 to them for now

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/df1294ab96

[13:51] <dalek> rakudo/nom: b690654 | moritz++ | / (3 files):

[13:51] <dalek> rakudo/nom: use a HLL::Compiler.lineof that returns 1-based line numbers

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6906547e0

[13:51] <dalek> rakudo/nom: de83900 | moritz++ | / (5 files):

[13:51] <dalek> rakudo/nom: Merge branch 'ex-from-actions' into nom

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de839003d1

[13:51] <dalek> rakudo/nom: c27eb70 | moritz++ | tools/build/NQP_REVISION:

[13:51] <dalek> rakudo/nom: bump NQP revision to get lineof optimization

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c27eb70f3d

[13:51] <dalek> rakudo/nom: b20ab2e | moritz++ | src/core/Mu.pm:

[13:51] <dalek> rakudo/nom: make uninitialized warnings more robust

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b20ab2ece6

[13:52] *** jimmy1980 left
[13:56] <colomon> \o/

[13:58] *** jimmy1980 joined
[14:05] *** REPLeffect left
[14:07] *** hrj joined
[14:07] <flussence> nom: $a

[14:07] <p6eval> nom d2a096: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near ""␤»

[14:07] <flussence> nom: my $a; say $a

[14:07] <p6eval> nom d2a096: OUTPUT«Any()␤»

[14:07] <flussence> nom: my Str $a; say $a

[14:07] <p6eval> nom d2a096: OUTPUT«Str()␤»

[14:07] <moritz> nom: my $a; print $a

[14:07] <p6eval> nom d2a096: OUTPUT«Use of uninitialized variable $v of type Any in string context␤»

[14:08] <flussence> $v?!

[14:08] <tadzik> tee hee

[14:09] <tadzik> where did it take that from

[14:09] <moritz> from Mu.Str

[14:09] <tadzik> yeah, but it was $a

[14:09] <moritz> nom: my $a; print ~$a

[14:09] <p6eval> nom d2a096: OUTPUT«Use of uninitialized value of type Any in string context␤»

[14:09] <flussence> $v.VAR.name on line 144?

[14:09] <moritz> nom: my $a; print $a.Str

[14:09] <p6eval> nom d2a096: OUTPUT«Use of uninitialized variable $a of type Any in string context␤»

[14:10] <flussence> nom: my Str $a; print $a

[14:10] <p6eval> nom d2a096: OUTPUT«Use of uninitialized variable $v of type Str in string context␤»

[14:11] <flussence> hm, thought that would've avoided calling Mu.Str

[14:11] *** preflex left
[14:11] <moritz> flussence: Str doesn't have a method Str(Str:U:) or so

[14:11] <flussence> ah

[14:11] <moritz> and I don't see a reason for having one

[14:12] <moritz> when people call the .Str method, they expect to get a defined Str back, not a Str type object

[14:12] *** preflex joined
[14:13] <moritz> or phrasing it differently, we need a method that returns a defined Str, so that we can unbox it and do low-level stuff with it

[14:13] <moritz> that's what .Str does in rakudo

[14:15] *** odoacre left
[14:19] *** REPLeffect joined
[14:25] *** jerome__ left
[14:25] *** alvis left
[14:26] *** jerome__ joined
[14:27] *** odoacre joined
[14:30] <felher> jnthn: first: nice blogpost :) . second: Is there a special reason you prefer if-else_if-else to given+ranges (http://paste.pocoo.org/show/519714/)? Matter of taste?

[14:31] <felher> jnthn: or (* < 100)

[14:31] *** sftp joined
[14:32] *** kaleem left
[14:32] *** am0c left
[14:32] *** mkramer left
[14:33] <jnthn> felher: NICE! :)

[14:33] <jnthn> felher: I didn't think of using ranges :)

[14:36] *** tokuhirom joined
[14:36] *** sayu joined
[14:36] <felher> jnthn: :) Glad i'm not the only one to like the combination :)

[14:39] <colomon> felher: I think I might prefer  when 1..100 { } when 101..1000 {} when 1001..* { } or something like that.  Just to make it more obvious what's going on

[14:39] <moritz> colomon: be careful, when non-integer quantities are allowed they do different things

[14:39] <moritz> just consider 100.5

[14:39] <colomon> true

[14:40] <colomon> 100^..1000, then, I suppose...

[14:40] <felher> colomon: yeah, i see your point :)

[14:42] *** alvis joined
[14:42] *** drbean left
[14:42] <jnthn> I like the ^100 fwiw. "If the order is up to but not including 100, you get no discount"

[14:45] <colomon> jnthn: but notice that it confused me -- I translated it to 1..100, ie if the order is up to and including 100...  :)

[14:46] <jnthn> colomon: oh :)

[14:46] <jnthn> I always parse ^ as "up to but excluding" :)

[14:46] <colomon> moritz apparently didn't notice my gaff either.  :)

[14:48] <moritz> colomon: I just focused on the most obvious issue, and didn't think more about it

[14:50] *** drbean joined
[14:56] *** toastedpenguin joined
[15:01] *** toastedpenguin left
[15:02] *** pomysl_ left
[15:02] *** pomysl joined
[15:05] <cognominal> nom: say Mu.^methods.map: {  .name ~ .signature }

[15:05] <p6eval> nom b20ab2: OUTPUT«(signal SEGV)»

[15:05] <cognominal> I am good at breaking things :(

[15:08] <moritz> cognominal++

[15:09] <moritz> nom: say Mu.^methods.WHAT

[15:09] <p6eval> nom b20ab2: OUTPUT«Parcel()␤»

[15:09] <moritz> nom: say Mu.^methods[0].WHAT

[15:09] <p6eval> nom b20ab2: OUTPUT«Method()␤»

[15:09] <cognominal> nom: say Mu.^methods.map: {  .name ~ 0 }

[15:09] <p6eval> nom b20ab2: OUTPUT«(signal SEGV)»

[15:09] <moritz> nom: say .name ~ .signature given Mu.^methods[0]

[15:09] <p6eval> nom b20ab2: OUTPUT«(signal SEGV)»

[15:09] <moritz> nom: say .name given Mu.^methods[0]

[15:09] <p6eval> nom b20ab2: OUTPUT«Method 'gist' not found for invocant of class 'String'␤  in sub say at src/gen/CORE.setting:5598␤  in block <anon> at /tmp/ujMAFgVuVD:1␤  in block <anon> at /tmp/ujMAFgVuVD:1␤  in <anon> at /tmp/ujMAFgVuVD:1␤»

[15:10] <moritz> ah, the .name is a parrot String, not a Str

[15:10] <moritz> nom: say .name ~ .name given Mu.^methods[0]

[15:10] <p6eval> nom b20ab2: OUTPUT«(signal SEGV)»

[15:10] <moritz> nom: say nqp::p6box_s(.name)  given Mu.^methods[0]

[15:10] <p6eval> nom b20ab2: OUTPUT«ACCEPTS␤»

[15:11] <moritz> nom: say nqp::p6box_s(.name) ~ nqp::p6box_s(.signature)  given Mu.^methods[0]

[15:11] <p6eval> nom b20ab2: OUTPUT«ACCEPTSSignature<-5339705135585706607>␤»

[15:11] *** wtw left
[15:11] <moritz> nom: say nqp::p6box_s(.name) ~ .signature.per given  Mu.^methods[0]

[15:11] <p6eval> nom b20ab2: OUTPUT«Method 'per' not found for invocant of class 'Signature'␤  in block <anon> at /tmp/L9VN9cA9GR:1␤  in block <anon> at /tmp/L9VN9cA9GR:1␤  in <anon> at /tmp/L9VN9cA9GR:1␤»

[15:11] <moritz> nom: say nqp::p6box_s(.name) ~ .signature.perl given  Mu.^methods[0]

[15:11] <p6eval> nom b20ab2: OUTPUT«ACCEPTS:(Mu, Any, Mu %_)␤»

[15:11] <jnthn> wtf, it's meant to coerce results of method calls into Perl 6 things.

[15:11] <moritz> nom: say nqp::p6box_s(.name) ~ .signature.perl for  Mu.^methods[0]

[15:11] <p6eval> nom b20ab2: OUTPUT«ACCEPTS:(Mu, Any, Mu %_)␤»

[15:11] <moritz> nom: say nqp::p6box_s(.name) ~ .signature.perl for  Mu.^methods

[15:11] <p6eval> nom b20ab2: OUTPUT«ACCEPTS:(Mu, Any, Mu %_)␤WHERE:(Mu, Mu %_)␤WHICH:(Mu, Mu %_)␤WHY:(Mu, Mu %_)␤Bool:(Mu, Any, Mu %_)␤so:(Mu, Mu %_)␤not:(Mu, Mu %_)␤defined:(Mu, Mu %_)␤new:(Mu, Any, Mu %_)␤CREATE:(Mu, Mu %_)␤bless:(Mu, Mu $candidate, Positional @autovivs, Associative %attrinit)␤BUILDAL…

[15:12] <jnthn> nom: say $_.name given Mu.^methods[0]

[15:12] <p6eval> nom b20ab2: OUTPUT«ACCEPTS␤»

[15:12] <jnthn> nom: say .name given Mu.^methods[0]

[15:12] <p6eval> nom b20ab2: OUTPUT«Method 'gist' not found for invocant of class 'String'␤  in sub say at src/gen/CORE.setting:5598␤  in block <anon> at /tmp/aIfwfj5Wqt:1␤  in block <anon> at /tmp/aIfwfj5Wqt:1␤  in <anon> at /tmp/aIfwfj5Wqt:1␤»

[15:12] *** mkramer joined
[15:12] <jnthn> Ah, just the default invocant case.

[15:14] *** mkramer left
[15:15] *** mkramer joined
[15:17] *** molaf left
[15:19] *** baest left
[15:22] *** risou_awy is now known as risou

[15:23] <moritz> ugh

[15:23] <moritz> I just found out why IO.copy doesn't work with a directory as the destination

[15:24] <moritz> char * const cto = Parrot_str_to_string(INTERP, to);

[15:24] <moritz> FILE * const target = fopen(cto, "w+b");

[15:24] <moritz> any questions? :/

[15:27] <colomon> Unmarshallable foreign language value passed for parameter '$b'   ???????

[15:28] <moritz> colomon: it means that you've passed a non-Rakudo object to a routine

[15:28] <moritz> and rakudo doesn't like that

[15:28] *** mkramer left
[15:28] <colomon> moritz: yeah, except I didn't

[15:28] <colomon> and running the code a second time (no changes) made the error go away

[15:28] <moritz> hm

[15:29] <moritz> something foul in the state of Denm^WRakudo

[15:29] <colomon> I never use the variable $b in this code at all.  

[15:29] *** thou joined
[15:29] <colomon> though I guess I could pass something to a core routine that did...

[15:29] <moritz> $b is probably used in the signature that you call (maybe indirectly)

[15:29] *** mkramer joined
[15:30] <moritz> right

[15:30] <colomon> https://gist.github.com/1467860 is the full stack trace

[15:31] <colomon> seem to happen every other time I run the code.

[15:31] <moritz> the reify/reify/gimme/eager/eager stuff is just a loop of some kind

[15:31] *** Psyche^ joined
[15:32] *** tokuhirom left
[15:32] *** tokuhirom joined
[15:35] *** Patterner left
[15:35] *** Psyche^ is now known as Patterner

[15:37] *** tokuhirom left
[15:40] <colomon> nom: my $z = 1 + .5i; say $z ** 2

[15:40] <p6eval> nom b20ab2: OUTPUT«0.75 + 1i␤»

[15:40] <colomon> nom: my $z = 1 + .5i; say $z ** 2.5

[15:40] <p6eval> nom b20ab2: OUTPUT«0.528879999348487 + 1.21128611554449i␤»

[15:43] <cognominal> I am working in improving Parameter.perl and Signature.perl

[15:44] <colomon> niecza: my $z = 1 + .5i; say $z ** 2.5

[15:44] <p6eval> niecza v12-12-g0271e98: OUTPUT«0.528879999348487+1.21128611554449i␤»

[15:45] <moritz> cognominal: that's a problem I've also attacked once...

[15:45] <moritz> cognominal: and decided that it might be easier to just store the original source code text for each parameter

[15:45] <moritz> cognominal: (compared to re-generating it from the Parameter object)

[15:46] <sorear> good * #perl6

[15:46] <moritz> cognominal: I think I had a branch for that, let me take a look...

[15:47] <moritz> cognominal: seems I never pushed the branch, doing that now

[15:48] <dalek> rakudo/parameter-perl: 9e3f3a2 | moritz++ | src/ (5 files):

[15:48] <dalek> rakudo/parameter-perl: store the original perl source for Parameter in an attribute

[15:48] <dalek> rakudo/parameter-perl: 

[15:48] <dalek> rakudo/parameter-perl: it turns out that there are so many cases to cover in Parameter.perl that

[15:48] <dalek> rakudo/parameter-perl: reconstructing it from the various flags and attributes is much more

[15:48] <dalek> rakudo/parameter-perl: complicated than simply storing the source code. At least that is

[15:48] <dalek> rakudo/parameter-perl: my hope :-)

[15:48] <dalek> rakudo/parameter-perl: Does not yet actually store the source

[15:48] <dalek> rakudo/parameter-perl: review: https://github.com/rakudo/rakudo/commit/9e3f3a260d

[15:48] <dalek> rakudo/parameter-perl: faf6af8 | moritz++ | src/Perl6/Actions.pm:

[15:48] <dalek> rakudo/parameter-perl: try to record Parameter.perl

[15:48] <dalek> rakudo/parameter-perl: review: https://github.com/rakudo/rakudo/commit/faf6af890f

[15:48] <moritz> cognominal: it branches off a rather old version of nom, but might be easy to merge nonetheless... feel free to pick it up from there

[15:52] <colomon> niecza: say 0i ** 2

[15:52] <p6eval> niecza v12-12-g0271e98: OUTPUT«NaN+NaNi␤»

[15:52] <colomon> ugh

[15:52] <colomon> nom: say 0i ** 2

[15:52] <p6eval> nom b20ab2: OUTPUT«0 + 0i␤»

[15:52] * moritz likes noms answer beter

[15:52] <moritz> *better even

[15:53] <sorear> nom: say pi ** i

[15:53] <cognominal> I have advanced a lot and it is a good pedagoical exercise. One can imagine people to generate code without going thru source.

[15:53] <p6eval> nom b20ab2: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&i' called (line 1)␤»

[15:53] <sorear> nom: say pi ** 1i

[15:53] <p6eval> nom b20ab2: OUTPUT«0.413292117142105 + 0.910598498740359i␤»

[15:53] <sorear> nom: say 1i ** 1i

[15:53] <p6eval> nom b20ab2: OUTPUT«0.207879576350762 + 0i␤»

[15:53] <cognominal> I have yet to grok LoL

[15:54] <colomon> niecza: say pow(0i, 2)

[15:54] <p6eval> niecza v12-12-g0271e98: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'pow' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 880 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1139 (P6.comp_unit @ 32) ␤  at /home/…

[15:56] *** bluescreen10 left
[15:56] <sorear> cognominal: nor do I

[15:58] <colomon> nom: say 0i.polar

[15:58] <p6eval> nom b20ab2: OUTPUT«0 0␤»

[15:58] <colomon> niecza: say 0i.polar

[15:58] <p6eval> niecza v12-12-g0271e98: OUTPUT«0 0␤»

[15:59] *** bluescreen10 joined
[15:59] <colomon> nom: say 0.log

[15:59] <p6eval> nom b20ab2: OUTPUT«-Inf␤»

[16:00] <moritz> niecza: say 0.log

[16:00] *** mkramer left
[16:00] <p6eval> niecza v12-12-g0271e98: OUTPUT«-Infinity␤»

[16:00] * colomon will track this down, but needs to hit the nordic track at the moment.

[16:01] *** mkramer joined
[16:02] <sorear> the what?

[16:03] <moritz> niecza: say 0i ** 2

[16:03] <p6eval> niecza v12-12-g0271e98: OUTPUT«NaN+NaNi␤»

[16:03] <moritz> this one, I guess

[16:03] <sorear> moritz: "nordic track"

[16:03] <moritz> oh

[16:03] <[Coke]> it's an exercise machine.

[16:03] *** donri joined
[16:04] <[Coke]> simulates cross country skiing.

[16:04] * moritz associated some winter sport / cross-country skiing with it

[16:04] * sorear thought it was something related to Perl conferences D:

[16:07] <daxim> you're giving me ideas.

[16:11] <sorear> colomon: it's because ** is implemented using log

[16:11] *** jeffreykegler joined
[16:12] <sorear> colomon: Builtins.cs line 773, log(0) = -Inf

[16:12] <sorear> and exp(-Inf) = NaN

[16:12] <moritz> erm, shouldn't exp(-Inf) be 0?

[16:13] <moritz> perl6: say exp(-Inf)

[16:13] <p6eval> pugs b927740, rakudo b20ab2, niecza v12-12-g0271e98: OUTPUT«0␤»

[16:13] <sorear> hrm

[16:14] <sorear> oh!

[16:14] <sorear> line 774 multiplies Inf by 0

[16:14] <[Coke]> more new spectest failures on niecza.

[16:14] <sorear> as part of a complex multiply

[16:14] *** xinming_ left
[16:15] <sorear> perl6: say -Inf * 2

[16:15] <p6eval> niecza v12-12-g0271e98: OUTPUT«-Infinity␤»

[16:15] <p6eval> ..pugs b927740, rakudo b20ab2: OUTPUT«-Inf␤»

[16:15] <sorear> perl6: say -Inf * 2i

[16:15] *** xinming joined
[16:15] <p6eval> pugs b927740: OUTPUT«NaN + -Infi␤»

[16:15] <p6eval> ..niecza v12-12-g0271e98: OUTPUT«NaN-Infinityi␤»

[16:15] <p6eval> ..rakudo b20ab2: OUTPUT«NaN - Infi␤»

[16:15] <sorear> perl6: say -Inf * (2+0i)

[16:15] <p6eval> pugs b927740, rakudo b20ab2: OUTPUT«-Inf + NaNi␤»

[16:15] <p6eval> ..niecza v12-12-g0271e98: OUTPUT«-Infinity+NaNi␤»

[16:15] <sorear> perl6: say 0i ** (2+0i)

[16:15] <p6eval> rakudo b20ab2: OUTPUT«NaN + NaNi␤»

[16:15] <p6eval> ..niecza v12-12-g0271e98: OUTPUT«NaN+NaNi␤»

[16:15] <p6eval> ..pugs b927740: OUTPUT«0␤»

[16:16] <moritz> pugs++

[16:16] *** mkramer left
[16:17] <sorear> Rakudo has the same-ish bug, but it manifests more on Niecza because of always treating the arguments as complex

[16:18] *** mkramer joined
[16:18] <sorear> [Coke]: not suprising, HEAD is rather in a state of flux

[16:19] <moritz> it seems to me that [Coke] expects some stability from niecza that sorear doesn't want to provide

[16:19] <moritz> maybe there's some branching solution to that

[16:19] <[Coke]> ah, it was because your "update t/spec" code seems to fail a lot for me. I check after a surprise failure, and all sorts of files are modified in t/spec, but not all up to date.

[16:19] <sorear> oh?

[16:19] <moritz> like, maintaining a separate stable branch, or doing more development in non-master branches, or whatever

[16:20] <[Coke]> moritz: Please don't go looking for trouble.

[16:20] <moritz> [Coke]: I'm not looking for trouble. I'm just observing your discussions here, and observe something. You are free to ignore that observation, of course

[16:20] <[Coke]> My complaint is not against sorear, but about the shared roast. If I think of a good way to fix roast, I'll let you know. ;)

[16:21] <[Coke]> Separate branch is just going to create more work for sorear. I'm trying to create LESS work for sorear.

[16:21] <sorear> [Coke]: I'm suprised the spectest update is failing, it's just a git pull call

[16:21] <moritz> a shared checkout? or the sharing of the repo?

[16:21] <sorear> I'd love to know what's going on here

[16:22] <[Coke]> sorear: any reason you're not using --rebase ?

[16:22] *** mkramer left
[16:22] <[Coke]> eh. doesn't matter, anyway. I can always manually do a rebase first, which should avoid the issue entirely.

[16:22] <sorear> [Coke]: I assumed that you would not have local commits so it didn't matter

[16:23] <sorear> this reminds me I was going to set up CI on p6eval

[16:25] *** arlinius left
[16:27] *** jimmy1980 left
[16:29] *** jeffreykegler left
[16:29] *** molaf joined
[16:30] *** toastedpenguin joined
[16:31] *** toastedpenguin left
[16:32] *** mkramer1 joined
[16:34] *** jimmy1980 joined
[16:34] *** mkramer1 left
[16:35] <[Coke]> there, much better with a clean roast.

[16:35] <[Coke]> sorear: https://github.com/sorear/niecza/issues/85 is a new regression.

[16:35] <[Coke]> (I think)

[16:36] <[Coke]> yah, those tests were added in 2008 and just started failing for niecza recently.

[16:37] *** drbean left
[16:43] *** drbean joined
[16:45] *** thou left
[16:53] *** estrabd joined
[16:55] *** bluescreen10 left
[16:57] <sorear> [Coke]: aaaaa

[16:57] <sorear> spectest update just failed horribly for me.

[16:58] *** djanatyn left
[16:58] *** Tene left
[16:59] *** Trashlord left
[17:00] *** skangas left
[17:00] *** jeffreykegler joined
[17:00] <dalek> niecza: 5bb9586 | sorear++ | / (3 files):

[17:00] <dalek> niecza: Implement &/&& in regexes (closely modelled off QRegex)

[17:00] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5bb9586222

[17:00] *** jeffreykegler left
[17:01] *** sayu left
[17:03] <dalek> niecza: 871b7db | sorear++ | t/run_spectests:

[17:03] <dalek> niecza: Update spectest files less stupidly

[17:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/871b7dbd33

[17:06] *** kaleem joined
[17:06] *** wolfman2000 left
[17:07] <[Coke]> sorear: glad it wasn't just my imagination, anyway. ;)

[17:10] *** mkramer joined
[17:10] *** Tene joined
[17:10] *** Tene left
[17:10] *** Tene joined
[17:11] *** djanatyn joined
[17:14] *** thou joined
[17:14] *** mkramer left
[17:14] *** MayDaniel joined
[17:15] *** mkramer joined
[17:15] *** mkramer left
[17:17] *** arlinius joined
[17:17] *** Juerd left
[17:18] *** tadzik left
[17:20] * colomon is back

[17:23] <colomon> has anyone done anything about the various 0i ** 2 crashes, etc.?  I saw sorear had pinpointed the troubled line in niecza...

[17:23] <sorear> colomon: no

[17:23] * colomon thinks we need to update roast and probably both compilers, by the sounds of things

[17:24] * jnthn home from $dayjob

[17:24] <sorear> o/ jnthn

[17:24] <jnthn> Well, from $client. There's more $dayjob to take care of this evening...

[17:24] *** icwiener left
[17:24] <sorear> jnthn: is there anyone other than pm who really understands qregex?

[17:25] *** icwiener joined
[17:26] <jnthn> sorear: I've understood it enough to fix various bugs and add features.

[17:26] <jnthn> sorear: If you want to ask "why is it done like X" style questions, though, I'm probably less use right now.

[17:27] <jnthn> sorear: Pm and I tended to divide Rakudo work up into areas that we focused on. In a Pm-with-much-fewer-tuits world I'm still trying to catch up on his bits. :-)

[17:28] <jnthn> sorear: If you have questions, feel free to ask. At best I'll just have to say "I don't know"

[17:28] <jnthn> er

[17:28] <jnthn> at worst

[17:28] <jnthn> :)

[17:28] <moritz> sorear: if you have specific questions, you can also try to ask pmichaud by email

[17:28] <sorear> moritz: good idea

[17:29] <sorear> jnthn: btw, the bug talk last night, complete false alarm

[17:29] <jnthn> sorear: That was what I took away form it. But thanks for confirming. :)

[17:30] *** Juerd joined
[17:31] *** tadzik joined
[17:31] * [Coke] returns from nearly killing feather. whoops.

[17:32] <sorear> [Coke]: yow, what happened?

[17:32] <sorear> urk.  Niecza/STD divergence is getting a bit out of hand

[17:32] *** risou is now known as risou_awy

[17:32] <[Coke]> sorear: ran niecza spec test using -j 100

[17:34] *** Trashlord joined
[17:34] <jnthn> sorear: heh...I bet it's nothing on Rakudo/STD divergence. :-P

[17:34] *** daxim left
[17:34] <jnthn> sorear: I do plan to bring Rakudo closer to STD in a bunch of ways, fwiw. 

[17:35] <sorear> yeah, niecza/STD is still close enough that I occasionally diff(1) the grammars :P

[17:35] <sorear> std: [+]1

[17:35] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (listop with args requires whitespace or parens) at /tmp/Crh58mEKue line 1:␤------> [32m[+][33m⏏[31m1[0m␤    expecting any of:␤       POST␤   bracketed infix␤        infix or meta-infix␤    postfix␤       

[17:35] <p6eval> ..postfix_prefix_meta_operator␤   pr…

[17:37] <sorear> also nothing compared to alpha I'm sure :P

[17:39] <sorear> std: [1]  2

[17:39] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/0dJ2pAJ9xU line 1:␤------> [32m[1]  [33m⏏[31m2[0m␤    expecting any of:␤      bracketed infix␤        infix or meta-infix␤    statement modifier loop␤Parse failed␤FAILED 00:01 121m␤»

[17:39] <sorear> niecza: [1]  2

[17:39] <p6eval> niecza v12-14-g871b7db: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row (preceding is not a valid reduce operator) at /tmp/uRQTKnHpw4 line 1:␤------> [32m[1]  [33m⏏[31m2[0m␤␤Parse failed␤␤»

[17:41] <jnthn> sorear: alpha's grammar engine and grammar pre-dated STD, as far as I'm aware :)

[17:41] *** xinming left
[17:42] <dalek> roast: bae50d7 | (Solomon Foster)++ | S32-num/complex.t:

[17:42] <dalek> roast: Add some Complex 0 ** tests.

[17:42] <dalek> roast: review: https://github.com/perl6/roast/commit/bae50d7c34

[17:42] *** xinming joined
[17:44] <sorear> niecza: /x ** {3}/

[17:44] <p6eval> niecza v12-14-g871b7db:  ( no output )

[17:44] <sorear> niecza: /x**{3}/

[17:44] <p6eval> niecza v12-14-g871b7db:  ( no output )

[17:44] <sorear> niecza: /x**y/

[17:44] <p6eval> niecza v12-14-g871b7db: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** y as separator;nowadays please use atom+ % y at /tmp/ZbIRPKFYnH line 1:␤------> [32m/x**y[33m⏏[31m/[0m␤␤»

[17:44] <colomon> sorear: any objection you can think to just checking to see if r is 0 and returning 0+0i if so?  (in 0i ** 2)

[17:45] <sorear> colomon: no, I think that would work.

[17:45] <colomon> compiling now

[17:46] <arnsholt> Hmm. I wonder how much of the syntactic changes in the Perl 6 spec can be traced simply via std's error messages

[17:48] *** icwiener left
[17:49] *** icwiener joined
[17:49] <felher> Hm, how do i get:

[17:50] <felher> nom: say ({ a => 1, b => 2 } xx 3).perl;

[17:50] <p6eval> nom b20ab2: OUTPUT«("a" => 1, "b" => 2, "a" => 1, "b" => 2, "a" => 1, "b" => 2).list␤»

[17:50] *** xinming left
[17:50] <felher> to give me a list of hashes?

[17:51] <sorear> nom: my $hash = { a => 1, b => 2 }; say ($hash xx 3).perl

[17:51] <p6eval> nom b20ab2: OUTPUT«("a" => 1, "b" => 2, "a" => 1, "b" => 2, "a" => 1, "b" => 2).list␤»

[17:51] <sorear> I call this a nombug

[17:51] <sorear> nom: my $hash = [ a => 1, b => 2 ]; say ($hash xx 3).perl

[17:51] <p6eval> nom b20ab2: OUTPUT«("a" => 1, "b" => 2, "a" => 1, "b" => 2, "a" => 1, "b" => 2).list␤»

[17:51] <sorear> it's flattening where it clearly shouldn't be

[17:52] <sorear> nom: say ({{ a => 1, b => 2}} xx 3)»().perl

[17:52] <p6eval> nom b20ab2: OUTPUT«===SORRY!===␤Method 'isa' not found for invocant of class 'Undef'␤»

[17:52] <sorear> 'Undef' should not appear in nom _ever_

[17:52] <sorear> I just found a second nombug!

[17:52] <sorear> I think

[17:53] <jnthn> sorear: You found a compiler bug and it's already in RT

[17:53] <jnthn> sorear: Note the SORRY.

[17:53] *** xinming joined
[17:53] <jnthn> The flattening one...probably a bug too.

[17:53] <jnthn> Not sure that one is filed.

[17:54] <felher> sorear: Thnx :)

[17:55] *** drbean left
[17:56] <colomon> doh!

[17:58] *** xinming left
[17:58] <dalek> roast: 530ccea | (Solomon Foster)++ | S32-num/complex.t:

[17:58] <dalek> roast: Unfudge new complex tests for niecza, add tests to plan.  (Doh!)

[17:58] <dalek> roast: review: https://github.com/perl6/roast/commit/530ccea5b9

[17:58] <dalek> niecza: 28f1fb1 | (Solomon Foster)++ | lib/Builtins.cs:

[17:58] <dalek> niecza: Add a special heck for 0i ** $a.

[17:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/28f1fb1b88

[17:59] <colomon> "special heck"!  doh again!

[17:59] *** Chillance joined
[18:00] <jnthn> .oO( what the hack? )

[18:00] *** dakkar left
[18:00] <colomon> is there an easy way to change commit messages which have already been pushed?

[18:01] *** drbean joined
[18:01] <moritz> colomon: only one that involves a forced push, which is frowned upon

[18:01] <jnthn> Re-writing public history is a bad idea.

[18:02] <colomon> I was afraid of that.

[18:04] <moritz> colomon: don't worry. Happens to the best of us.

[18:04] *** xinming joined
[18:07] *** molaf left
[18:07] *** mj41 left
[18:09] *** xinming left
[18:10] *** tokuhirom joined
[18:13] *** fagzal joined
[18:13] <fagzal> hi guys

[18:13] *** drbean left
[18:15] <fagzal> I've just read an article about FaceBook coming out with a VM for PHP... has anybody had the chance to look into that? A dynamic language VM is always interesting :)

[18:16] *** xinming joined
[18:19] <PerlJam> fagzal: are you suggesting that someone should compile Perl 6 to the hiphop vm?

[18:19] *** Radvendii joined
[18:19] *** drbean joined
[18:20] <fagzal> PerlJam: well, I was just wondering, yes... I really don't know anything about hiphop internals, but it's good to know there's a dynamic VM out there backed up by a big company

[18:21] <fagzal> PerlJam: it might worth to take a look, that's all what I'm saying :)

[18:22] <PerlJam> "...high-level stack-based virtual machine specifically tailored to PHP..."

[18:23] *** xinming left
[18:23] <fagzal> PerlJam: so that's a "no, not gonna happen"? :)

[18:23] <PerlJam> not quite no, just a data point.

[18:24] <PerlJam> (well, *I* ain't gonna do it :)

[18:24] *** xinming joined
[18:24] <PerlJam> There doesn't appear to be an on-disk format yet

[18:24] <fagzal> they have just released a preview AFAIK

[18:25] *** Radvendii left
[18:26] *** benabik joined
[18:27] <fagzal> I also wonder whether they (FB) would be able to target Parrot now...

[18:27] <[Coke]> sorear: looks like there are 275 different todo/skip reasons for niecza in the tests that are currently being run.

[18:28] <PerlJam> fagzal: not if they're optimizing for speed.

[18:29] <[Coke]> whoops. some dups I didn't strip, momentito.

[18:30] <fagzal> PerlJam: that answer scares me, kind of... :S

[18:30] *** thou left
[18:31] <fagzal> wow, rakudo-star is in the F16 repo :o I love you guys

[18:31] <[Coke]> 262 skip/todo reasons: http://feather.perl6.nl/~coke/niecza_todo.txt

[18:33] *** baest joined
[18:33] *** xinming left
[18:33] *** drbean left
[18:34] *** alim left
[18:34] *** baest left
[18:35] *** three18ti left
[18:36] *** xinming joined
[18:40] *** drbean joined
[18:41] <[Coke]> niecza: say "hello" !~~ m:ignorecase/Hello/

[18:41] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«Bool::False␤»

[18:42] <[Coke]> nom: say "hello" !~~ m:ignorecase/Hello/

[18:42] <p6eval> nom b20ab2: OUTPUT«Bool::True␤»

[18:42] <[Coke]> nom: say "hello" ~~ m:ignorecase/Hello/

[18:42] <p6eval> nom b20ab2: OUTPUT«#<failed match>␤»

[18:43] *** thou joined
[18:44] <[Coke]> spec tests indicate that nom is right here, but can someone explain why? (seems like ignorecase should allow Hello to match hello.)

[18:47] <[Coke]> niecza: say "hello" !~~ m:ignorecase/'Hello'/

[18:47] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«Bool::False␤»

[18:49] *** kaleem left
[18:50] *** xinming_ joined
[18:50] *** xinming left
[18:51] *** ggoebel left
[18:55] <fagzal> rakudo: say "hello" !~~ m:ignorecase/'Hello'/

[18:55] <p6eval> rakudo b20ab2: OUTPUT«Bool::True␤»

[18:56] *** ggoebel joined
[18:59] *** fagzal left
[19:00] *** jimmy1980 left
[19:05] <moritz> rakudo: say "hello" ~~ m:ignorecase/'Hello'/

[19:05] <p6eval> rakudo b20ab2: OUTPUT«#<failed match>␤»

[19:05] <moritz> rakudo: say "hello" ~~ m:i/'Hello'/

[19:05] <p6eval> rakudo b20ab2: OUTPUT«=> <hello>␤␤»

[19:05] *** xinming_ left
[19:19] <Tene> http://i.imgur.com/vJcsh.jpg -- bootstrapping perl 6?  ;)

[19:22] *** xinming joined
[19:24] *** baest joined
[19:26] *** kfo_ joined
[19:29] *** kfo left
[19:34] *** MayDaniel left
[19:35] *** xinming left
[19:37] *** tokuhirom left
[19:37] *** xinming joined
[19:45] *** xinming left
[19:53] *** snearch joined
[19:53] *** thou_ joined
[19:55] *** alim joined
[19:57] *** thou left
[19:59] *** jaldhar left
[20:01] <dalek> rakudo/nom: 92f3830 | moritz++ | src/core/Complex.pm:

[20:01] <dalek> rakudo/nom: fix infix:<**> for 0 base and Complex numbers

[20:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/92f3830717

[20:02] <dalek> roast: 6fb1102 | moritz++ | / (2 files):

[20:02] <dalek> roast: rakudo (un)fudges

[20:02] <dalek> roast: review: https://github.com/perl6/roast/commit/6fb1102d79

[20:05] *** tokuhirom joined
[20:06] *** xinming joined
[20:07] <colomon> moritz++ # sorry, I meant to get around to doing that, too.

[20:08] <colomon> hmmm, guess we should have a test for the real case you added too?

[20:09] <colomon> b: say 0 ** (2 + 0i)

[20:09] <p6eval> b 1b7dd1: OUTPUT«NaN + NaNi␤»

[20:10] <colomon> a-yup

[20:10] <colomon> niecza: say 0 ** (2 + 0i)

[20:10] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«0+0i␤»

[20:15] *** xinming left
[20:23] *** araujo left
[20:24] *** alim left
[20:34] <dalek> roast: be7da47 | (Solomon Foster)++ | S32-num/complex.t:

[20:34] <dalek> roast: Add test for 0 ** (2 + 0i).

[20:34] <dalek> roast: review: https://github.com/perl6/roast/commit/be7da474e0

[20:36] *** localhost left
[20:38] *** localhost joined
[20:42] <moritz> colomon++ # tests

[20:43] *** xinming joined
[20:55] *** xinming left
[20:55] *** thou_ left
[20:59] *** icwiener left
[20:59] *** icwiener joined
[21:01] *** MayDaniel joined
[21:10] *** baest left
[21:16] *** xinming joined
[21:17] *** drbean left
[21:17] *** cognominal left
[21:17] *** thou joined
[21:21] *** thou left
[21:22] *** xinming left
[21:24] *** drbean joined
[21:27] *** xinming joined
[21:29] *** thou joined
[21:30] *** araujo joined
[21:30] *** mj41 joined
[21:32] *** thou left
[21:34] *** y3llow_ joined
[21:34] *** pothos_ joined
[21:36] *** y3llow left
[21:36] *** y3llow_ is now known as y3llow

[21:36] *** pothos left
[21:37] *** snearch left
[21:37] *** pothos_ left
[21:38] <sorear> good * #perl6

[21:38] *** pothos joined
[21:38] <[Coke]> hio

[21:40] *** pothos left
[21:40] <colomon> o/

[21:41] *** pothos joined
[21:44] <dalek> niecza: ae277d0 | sorear++ | src/STD.pm6:

[21:44] <dalek> niecza: Port in some minor fixes from STD

[21:44] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ae277d0746

[21:48] *** xinming left
[21:51] <[Coke]> sorear: do any of those impact <ident> ?

[21:51] <sorear> no

[21:52] <sorear> ident is defined in CORE.setting

[21:53] *** cogno joined
[21:54] *** thou joined
[21:54] <[Coke]> perl6: "abc1_2" ~~ m/^ <ident> $/

[21:54] <p6eval> rakudo 92f383, niecza v12-15-g28f1fb1:  ( no output )

[21:54] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[21:54] <[Coke]> perl6: say "abc1_2" ~~ m/^ <ident> $/ #whoops

[21:54] <p6eval> rakudo 92f383: OUTPUT«=> <abc1_2>␤ ident => <abc1_2>␤␤»

[21:54] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[21:54] <p6eval> ..niecza v12-15-g28f1fb1: OUTPUT«Bool::False␤»

[21:55] <[Coke]> Where is <INTERNAL::alpha> defined?

[21:55] *** xinming joined
[21:56] <sorear> src/CClass.pm6 line 81

[21:57] *** bacek left
[21:57] <[Coke]> crap, just found it independantly. ;)

[21:58] <[Coke]> Should that list include "Pc" also, then? (for Punctuation, Connector)

[21:58] *** icwiener left
[21:59] * [Coke] looks for the p6 spec...

[22:02] <sorear> [Coke]: the P6 spec says specifically underscores

[22:02] <[Coke]> I can't find the part of the spec that declares valid varnames, though http://perlcabal.org/syn/S02.html#Names_and_Variables looks like where it should go.

[22:02] <[Coke]> ok.

[22:02] <sorear> hmm

[22:02] <sorear> maybe I'm wrong

[22:02] *** mj41 left
[22:03] <sorear> I must've copied it from STD

[22:03] <[Coke]> I'm assuming /at least/ they should be allowed, anyway.

[22:03] <sorear> the definition of valid varnames is made by token identifier { <.ident> [ <.apostrope> <.ident> ]* } on STD.pm6 line 702

[22:04] <sorear> STD.pm6 has the force of spec for syntactic matters

[22:04] <[Coke]> ah, I missed the plus("_") at the end of that, anyway.

[22:04] <[Coke]> ... but still, that doesn't seem to be working.

[22:04] <sorear> where apostrophe is <[ ' \- ]> and ident (OVERRIDEN IN STD, NOT THE CORE VERSION) is <.alpha> \w*

[22:04] <sorear> niecza: say '_' ~~ /\w/

[22:04] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«#<match from(0) to(1) text(_) pos([].list) named({}.hash)>␤»

[22:04] <sorear> niecza: say '_' ~~ /<alpha>/

[22:04] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«#<match from(0) to(1) text(_) pos([].list) named({"alpha" => #<match from(0) to(1) text(_) pos([].list) named({}.hash)>}.hash)>␤»

[22:05] <sorear> niecza: say '_' ~~ /<ident>/

[22:05] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«#<match from(0) to(1) text(_) pos([].list) named({"ident" => #<match from(0) to(1) text(_) pos([].list) named({}.hash)>}.hash)>␤»

[22:05] <[Coke]> std: my $abc1_2 = 4;

[22:05] <p6eval> std be1f10e: OUTPUT«ok 00:01 122m␤»

[22:05] <sorear> niecza: say '2' ~~ /\w/

[22:05] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«#<match from(0) to(1) text(2) pos([].list) named({}.hash)>␤»

[22:05] <sorear> niecza: say 'abc1_2' ~~ /<ident>/

[22:05] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({"ident" => #<match from(0) to(1) text(a) pos([].list) named({}.hash)>}.hash)>␤»

[22:06] <sorear> uhm

[22:06] <sorear> this isn't an underscore problem

[22:06] <sorear> niecza: say 'abc' ~~ /^ <ident> $/

[22:06] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«Match()␤»

[22:06] <benabik> nom: say 'abc' ~~ /^ <ident> $/ # curious

[22:06] <p6eval> nom 92f383: OUTPUT«=> <abc>␤ ident => <abc>␤␤»

[22:08] <[Coke]> niecza: say 'abc1' ~~ /^ <ident> $/

[22:08] <p6eval> niecza v12-15-g28f1fb1: OUTPUT«Rebuild in progress␤»

[22:08] *** colomon left
[22:08] *** cogno left
[22:08] <sorear> niecza: say 'xx' ~~ /\w\w/

[22:08] <p6eval> niecza v12-16-gae277d0: OUTPUT«Rebuild in progress␤»

[22:10] *** xinming left
[22:10] <sorear> niecza> 'abc' ~~ /:r <+INTERNAL::alpha> \w*/

[22:10] <sorear> #<match from(0) to(1) text(a) pos([].list) named({}.hash)>

[22:12] <[Coke]> niecza: say 'abc1_2' ~~ /^ <ident> $/

[22:12] <p6eval> niecza v12-16-gae277d0: OUTPUT«Match()␤»

[22:12] <[Coke]> niecza: say 'abc1_2' ~~ m/^ <ident> $/

[22:12] <p6eval> niecza v12-16-gae277d0: OUTPUT«Bool::False␤»

[22:12] <[Coke]> there's the difference.

[22:12] <[Coke]> the test is using m//

[22:12] <[Coke]> My apologies for the wild goose chase on the underscore.

[22:13] <sorear> I am thinking now that I broke ScanCClass

[22:13] <sorear> niecza: say ('abc' ~~ /:r \w*/)

[22:13] <p6eval> niecza v12-16-gae277d0: OUTPUT«#<match from(0) to(0) text() pos([].list) named({}.hash)>␤»

[22:13] *** cognominal joined
[22:13] *** CoreX__ joined
[22:18] *** alim joined
[22:18] *** xinming joined
[22:19] <sorear> [Coke]: I think I've fixed it

[22:19] *** colomon joined
[22:19] <benabik> :r ?

[22:21] <[Coke]> Issue #85

[22:22] <[Coke]> er, for that bugfix, if you want to mention it in the commit.

[22:23] <benabik> :r ~~ :ratchet?  I don't see it in spec.

[22:23] *** CoreX__ left
[22:24] *** CoreX_ joined
[22:28] *** xinming left
[22:45] <dalek> niecza: 8ff7b21 | sorear++ | lib/Cursor.cs:

[22:45] <dalek> niecza: :r \w* was being treated as zero width (fixes #85)

[22:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8ff7b214ad

[22:48] *** mj41 joined
[22:57] *** mj41 left
[23:20] <sorear> std: s{x}{y}

[23:20] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of brackets around replacement; in Perl 6 please use assignment syntax at /tmp/T6Ix5c4KpE line 1:␤------> [32ms{x}[33m⏏[31m{y}[0m␤Parse failed␤FAILED 00:01 120m␤»

[23:20] <sorear> niecza: s{x}{y}

[23:20] <p6eval> niecza v12-17-g8ff7b21: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/YSBAoyMGDW line 1:␤------> [32ms{x}[33m⏏[31m{y}[0m␤␤Parse failed␤␤»

[23:25] *** MayDaniel left
[23:26] *** dudulz left
[23:44] <sorear> std: / <|foo=bar> /

[23:44] <p6eval> std be1f10e: OUTPUT«ok 00:01 120m␤»

[23:44] <sorear> TimToady: what does this mean?

[23:49] *** Chillance left
[23:55] *** packetknife joined
[23:58] *** leprevost joined
