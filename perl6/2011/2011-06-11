[00:17] *** scottp left
[00:18] <sorear> *whew*

[00:18] <dalek> niecza/immediate: 077e4c9 | sorear++ | src/niecza:

[00:18] <dalek> niecza/immediate: Fix our-sub compilation

[00:18] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/077e4c90a5

[00:18] <dalek> niecza/immediate: 74027a9 | sorear++ | lib/ (3 files):

[00:18] <dalek> niecza/immediate: Make the unit loader tolerant of classes arriving out of preorder

[00:18] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/74027a9da0

[00:19] <sorear> that was a lot of lovely firefighting

[00:23] *** mtk left
[00:33] *** mtk joined
[00:34] *** Chillance left
[00:36] *** Ali_h left
[00:41] <sorear> /immediate is at the point where is can run fairly involved fragments like 'say [ 1,2,4 .. *>1000 ].perl'

[00:42] <sorear> known TODOs are regexes, subset, and "use"

[00:44] <TimToady> I missed the point of the /immediate refactor somewhere in the backlog

[00:44] <sorear> eliminating NieczaPassBegin

[00:45] <TimToady> ah

[00:45] <jnthn> oh, duh

[00:45] * jnthn finally finds why attributes with type parameters don't work

[00:45] <jnthn> well, and why my fix for why they didn't work didn't work, which was far more confusing... :)

[00:46] <sorear> niecza: augment class Int { has $!oops } # Point 1: semantic errors are caught early enough that they now can be reported with location info and as part of SORRY!ing

[00:46] <p6eval> niecza v6-89-ge849cf7: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Cannot augment class Int without MONKEY_TYPING at /tmp/8Iep9CMIWS line 1:‚ê§------> [32maugment class Int [33m‚èè[31m{ has $!oops } # Point 1: semantic error[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at

[00:46] <p6eval> ../home/p6eval/niecza/boot/lib/CORE.setting line 4‚Ä¶

[00:46] <sorear> niecza: use MONKEY_TYPING; augment class Int { has $!oops } # Point 1: semantic errors are caught early enough that they now can be reported with location info and as part of SORRY!ing

[00:46] <p6eval> niecza v6-89-ge849cf7: OUTPUT¬´Unhandled exception: attribute oops declared in an augment‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ‚ê§  at /home/p6eval/niecza/src/NieczaPassBegin.pm6 line 276 (NieczaPassBegin Attribute.begin @ 11) ‚ê§  at

[00:46] <p6eval> ../home/p6eval/niecza/src/NieczaPassBegin.pm6 line‚Ä¶

[00:50] <sorear> later, after /immediate is merged, I will modify niecza's copy of STD to use niecza's internal symbol table

[00:51] <sorear> this will eliminate all bugs where the two symbol tables get out of sync

[01:00] *** noganex_ joined
[01:01] <jnthn> Ah, found the issue. Too tired to fix it now though...

[01:02] <jnthn> Anyway, means role Foo[::T] { has T $.x } is almost working.

[01:02] *** bitpart left
[01:03] <jnthn> sleep &

[01:04] *** noganex left
[01:06] <dalek> rakudo/nom: 15dd8b9 | jnthn++ | src/binder/container.c:

[01:06] <dalek> rakudo/nom: Improve assignment failure errors.

[01:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15dd8b94ba

[01:06] <dalek> niecza/immediate: 7ed0712 | sorear++ | src/ (2 files):

[01:06] <dalek> niecza/immediate: Actions mergeback

[01:06] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/7ed0712dad

[01:15] *** benabik left
[01:16] * sorear wonders what conclusion to draw from the process surrounding Parrot#1589

[01:26] <dalek> niecza/immediate: da7bcf9 | sorear++ | src/niecza:

[01:26] <dalek> niecza/immediate: Reimplement subset

[01:26] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/da7bcf92a5

[01:26] *** benabik joined
[01:42] *** tonginbox joined
[01:42] <tonginbox> hi

[01:45] *** tonginbox left
[01:48] <sorear> people are so impatient these days

[01:58] <dalek> rakudo/nom: ac99523 | pmichaud++ | / (71 files):

[01:58] <dalek> rakudo/nom: git mv src/CORE.setting src/core

[01:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac99523601

[02:00] *** bluescreen10 left
[02:08] <dalek> rakudo/nom: 69a2ecc | pmichaud++ | src/Perl6/Actions.pm:

[02:08] <dalek> rakudo/nom: Restore term:<*> constructing an instance of Whatever.

[02:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69a2ecce8a

[02:09] *** whiteknight left
[02:13] <dalek> rakudo/nom: e86292d | pmichaud++ | src/core/List.pm:

[02:13] <dalek> rakudo/nom: Enable List.gimme to understand Whatever argument.

[02:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e86292d06d

[02:13] <dalek> rakudo/nom: 73b522e | pmichaud++ | src/core/ (2 files):

[02:13] <dalek> rakudo/nom: Eliminate temporary Parcel.rpa message now that attribute access works again.

[02:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/73b522e32f

[02:14] <sorear> I thought GIMME was dead

[02:14] *** kid51 left
[02:22] *** wamba left
[02:37] <Util> rakudo: my @a = <a b>; my @x = <x y>; .say for map { @($_).Str }, (|@a, |@x);

[02:37] <p6eval> rakudo 4a6d21: OUTPUT¬´a b‚ê§x y‚ê§¬ª

[02:38] <sorear> | probably isn't doing what you think it is there

[02:39] <Util> I want @a and @x to maintain their separate identity as they pass through the map

[02:40] <sorear> try $(@a), $(@x)

[02:40] <Util> I wanted to ask if @($_).Str is really they most concise way to dereference the capture.

[02:40] <sorear> oh

[02:40] <sorear> you can just write ~$_

[02:40] <sorear> er no

[02:40] <sorear> @$_ is the shortest way

[02:40] <Util> But I welcome your thoughts on how to better pass the arrays in.

[02:41] <sorear> $(@a), $(@b) is the most direct way to pass arrays as items

[02:42] <Util> thanks; will play with that

[02:42] <pmichaud> I searched the #perl6 logs for "gimme" and didn't see anything that indicated it was dead.

[02:43] <pmichaud> and it seems to be working out well

[02:46] <sorear> what's your gimme do?

[02:46] <pmichaud> it's taken the place of master's !fill

[02:46] <sorear> or ... I'll just check the code

[02:46] *** envi_laptop joined
[02:46] <sorear> gimme is perhaps an unfortunate name; it's the Perl 5 primitive underlying wantarray()

[02:47] <pmichaud> I'm open for another name; "gimme" is the only name that TimToady said was "fine"  :)

[02:47] <sorear> what was wrong with "fill"?

[02:47] <pmichaud> anyway, gimme reifies the first $n items, and returns the number of reified items.

[02:50] <pmichaud> gimme(*) reifies as many as it can consistent with "mostly eager" semantics

[02:53] <Util> sorear: thanks, that was what I needed!

[02:57] *** jaldhar joined
[02:58] *** kanishka joined
[03:10] <dalek> rakudo/nom: f17f312 | pmichaud++ | src/core/Array.pm:

[03:10] <dalek> rakudo/nom: Add a preliminary Array.STORE.

[03:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f17f3126d1

[03:10] <dalek> rakudo/nom: 0e64691 | pmichaud++ | src/Perl6/Actions.pm:

[03:10] <dalek> rakudo/nom: Include io_ops in the list of dynops loaded (for printerr).

[03:10] <dalek> rakudo/nom: We can remove this again later if we don't really need it.

[03:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0e646912f3

[03:20] <pmichaud> afk, sleep or something like that

[03:21] <dalek> rakudo/nom: 71c3f79 | pmichaud++ | src/core/ (2 files):

[03:21] <dalek> rakudo/nom: Add List.shift.  Write better cheating versions of &say and &print.

[03:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/71c3f79c71

[03:21] *** hudnix left
[03:24] *** Su-Shee_ joined
[03:25] *** furryfishy left
[03:25] *** furryfishy joined
[03:25] *** fish|ipad left
[03:25] *** fish|ipad joined
[03:25] *** furryfishy left
[03:25] *** furryfishy joined
[03:25] *** fish|ipad left
[03:25] *** fish|ipad joined
[03:26] <dalek> rakudo/nom: f2c0012 | pmichaud++ | src/core/List.pm:

[03:26] <dalek> rakudo/nom: Add List.elems.

[03:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f2c0012177

[03:27] *** Su-Shee left
[03:28] *** [particle]1 joined
[03:29] *** [particle] left
[03:29] *** woosley left
[03:30] *** woosley joined
[03:32] *** wooden joined
[03:32] *** wooden left
[03:32] *** wooden joined
[03:33] <dalek> niecza/immediate: e7ca1ee | sorear++ | src/niecza:

[03:33] <dalek> niecza/immediate: Reimplement regex_def

[03:33] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/e7ca1eead9

[03:36] <dalek> rakudo/nom: 4df27a3 | pmichaud++ | src/core/List.pm:

[03:36] <dalek> rakudo/nom: Add List.Bool.

[03:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4df27a35e3

[03:59] *** woosley left
[04:03] <dalek> niecza/immediate: 23625e7 | sorear++ | / (2 files):

[04:03] <dalek> niecza/immediate: One more fix to signature handling, can now compile entire setting

[04:03] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/23625e7656

[04:06] *** f00li5h left
[04:06] *** awwaiid joined
[04:06] *** f00li5h joined
[04:07] *** ymasory left
[04:08] *** ymasory joined
[04:13] <dalek> niecza/immediate: 18298ce | sorear++ | src/niecza:

[04:13] <dalek> niecza/immediate: Reimplement use

[04:13] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/18298cebf7

[04:13] <sorear> that was anticlimatic.  I thought I was saving the hardest for last...

[04:20] *** kanishka left
[04:22] *** ewemoa joined
[04:23] *** donri left
[04:29] *** kaare_ joined
[04:34] *** gbacon_ left
[04:43] *** furryfishy left
[04:44] <sorear> nom: say "hello"

[04:44] <p6eval> nom: OUTPUT¬´sh: ./perl6: not found‚ê§¬ª

[04:44] <sorear> pfff

[04:44] <sorear> moritz!

[05:08] <dalek> niecza/immediate: 6b88f1d | sorear++ | src/niecza:

[05:08] <dalek> niecza/immediate: More regex fixes, embedded blocks

[05:08] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/6b88f1d312

[05:08] <dalek> niecza/immediate: 9e7781a | sorear++ | / (2 files):

[05:08] <dalek> niecza/immediate: Fix shadowing of lexical classes, computed name scoping

[05:08] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/9e7781ac73

[05:26] *** donri joined
[05:32] *** Tedd1 joined
[05:33] *** Tedd1^ left
[05:36] *** daniel-s joined
[05:40] *** molaf joined
[05:47] <sorear> TimToady: I am wondering if it makes sense to have something like <commit> in newlex and friends

[05:47] <sorear> backtracking over a MOP operation ... causes problems.

[05:50] <dalek> niecza/immediate: fa1e13c | sorear++ | src/niecza:

[05:50] <dalek> niecza/immediate: Avoid .newlex (via embeddedblock) in <foo> parsing, give LTM more info

[05:50] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/fa1e13c2e7

[05:57] *** ChrisDennis left
[06:01] *** ymasory left
[06:02] <dalek> niecza/immediate: 3b8127a | sorear++ | src/niecza:

[06:02] <dalek> niecza/immediate: Parametric role bodies do not need to be run immediately

[06:02] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/3b8127ac4f

[06:03] <sorear> at this point /immediate can compile the test suite

[06:03] <sorear> it runs up to test 635/1008... just a few more yaks...

[06:04] <moritz> std: # just testing

[06:04] <p6eval> std 37a0cdd: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[06:06] *** Tedd1^ joined
[06:06] *** Tedd1 left
[06:06] <moritz> sorear: nom in evalbot doesn't work because the build fails

[06:07] <moritz> http://irclog.perlgeek.de/perl6/2011-06-10#i_3897806

[06:07] <moritz> I'll try a perl-5.14.0 once it has finished to compile

[06:07] *** ChrisDennis joined
[06:14] <dalek> niecza/immediate: 835b5da | sorear++ | test.pl:

[06:14] <dalek> niecza/immediate: Fiddle two tests for tightened pad rules

[06:14] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/835b5da7f1

[06:14] <dalek> niecza/immediate: 6ad299e | sorear++ | src/niecza:

[06:14] <dalek> niecza/immediate: Only real signatures should set :noinit

[06:14] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/6ad299ea2c

[06:15] <sorear> test.pl now runs to completion

[06:15] <moritz> what about spectest?

[06:15] <sorear> (Failed 10/1008)

[06:15] <sorear> moritz: not going to try until internal tests pass

[06:16] <moritz> somehow perlbrew on p6eval server is busted

[06:17] <moritz> even after perlbrew switch perl-5.14.0   the output of perl -v says it's 5.12.something

[06:18] <moritz> btw the patches to rakudo/nqp did not significantly decrease compilation time of the setting

[06:19] <moritz> from ~55s to ~53s on my machine

[06:19] <sorear> seems most of the failing tests are just fallout from the fact that bare blocks are no longer considered "global" blocks for protolexpad purposes

[06:20] <sorear> (btw, yesterday I got jjore++ to explain to me how this used to work)

[06:22] <moritz> I'm going to nuke the perlbrew dir on the p6eval server, and start a new one

[06:22] <moritz> so for maybe a few hours p6eval won't work really well

[06:24] <moritz> std: 1

[06:24] *** p6eval left
[06:27] <sorear> I could get very close to the Perl 5 semantics, at the cost of requiring an atomic memory operation on the first entry to any sub

[06:28] <sorear> heh.  now that I say that it sounds almost reasonable.

[06:29] *** woosley joined
[06:32] *** Tedd1 joined
[06:34] *** Tedd1^ left
[06:39] <sorear> hrm!

[06:39] <sorear> once settings are factored in ... Perl 5's semantics aren't all that hard

[06:43] <dalek> rakudo/nom: 2a50310 | moritz++ | src/core/operators.pm:

[06:43] <dalek> rakudo/nom: add a lot of coercive numeric operators

[06:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2a503109ee

[06:44] *** wamba joined
[06:59] <dalek> rakudo/nom: 5361de1 | moritz++ | src/core/operators.pm:

[06:59] <dalek> rakudo/nom: add infix:<div>, and cheat on infix:</>(Int, Int) until we get Rats going again (mostly needs object construction)

[06:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5361de18f7

[07:00] *** thou left
[07:07] *** fish|ipad left
[07:08] *** fish|ipad joined
[07:08] *** fish|ipad left
[07:08] *** fish|ipad joined
[07:09] <dalek> niecza/immediate: 7e0f5d9 | sorear++ | / (3 files):

[07:09] <dalek> niecza/immediate: More test fiddling, fix {} type, fix Junction.perl

[07:09] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/7e0f5d9c6d

[07:12] <dalek> evalbot: 76c56f6 | moritz++ | evalbot.pl:

[07:12] <dalek> evalbot: remove syntax that is deprecated in perl 5.14

[07:12] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/76c56f6ab5

[07:13] *** p6eval joined
[07:13] *** ChanServ sets mode: +v p6eval

[07:17] *** fish|ipad left
[07:19] <moritz> std: 1

[07:19] <p6eval> std 37a0cdd: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[07:21] <dalek> niecza/immediate: 510cdfd | sorear++ | src/niecza:

[07:21] <dalek> niecza/immediate: Fix prefix:sym<temp>

[07:21] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/510cdfd6d6

[07:21] <sorear> All tests successful.

[07:22] * sorear starts the spectester going and wanders off for a walk

[07:28] *** scottp joined
[07:31] <moritz> perl6: say 41 + 1

[07:31] <p6eval> pugs, rakudo , niecza v6-89-ge849cf7: OUTPUT¬´42‚ê§¬ª

[07:48] *** araujo left
[07:49] *** mj41 joined
[07:51] <sorear> failed to parse 3 test files, failed 1-5 tests in 6 others

[07:51] <sorear> out of 119 files, 2084 tests... not too bad

[07:52] <sorear> failed to parse STD outright...

[07:52] <sorear> agenda for the next few days:

[07:52] *** JimmyZ joined
[07:52] <sorear> * fix remaining regressions as found by make spectest and make reboot

[07:53] <sorear> * merge branch

[07:53] <sorear> * optimization tweak: {YOU_ARE_HERE} can be treated as a run-once sub

[07:54] <sorear> * kill NieczaPassBeta, run it during the parse too

[07:54] <sorear> * try to kill NieczaPassSimplifier

[07:54] <sorear> * at this point the only passes in the compiler are 1. parse 2. write to disk

[07:55] <sorear> * start modifying STD to use Niecza's own symbol tables.  Gut $*CURLEX.  (This could be a measurable speedup)

[07:55] <JimmyZ> just curious, what's the difference between $a.Int and $a as Int

[07:55] <sorear> * port tryfile/STD to current Niecza, to see how much closer it can be when not supporting Niecza :)  If sufficiently close, try to lure TimToady.

[07:56] <sorear> EOA

[07:56] <sorear> JimmyZ: $a.Int is a valid expression, $a as Int is a valid parameter

[07:56] <sorear> they cannot be used in any of the same syntactic contexts

[07:56] <sorear> how do you want them compared?

[08:01] <JimmyZ> sorear: just saw recent nom commits, some times they use $a as Int as parameter, sometimes they use $a as parameter, but use $a.Int in the method

[08:02] *** daniel-s left
[08:02] <sorear> JimmyZ: I think those are the same

[08:02] <sorear> using $a.Int in the method will be significantly faster currently

[08:03] <JimmyZ> I thought $a as Int is faster

[08:03] <sorear> $a as Int requires the binder to call the Int method

[08:03] <sorear> but the binder is written in C, so an inferior runloop is needed

[08:03] <sorear> those are quite slow ATM

[08:03] *** woosley left
[08:05] <JimmyZ> I see, that is what whiteknight++ said, pir is faster than C

[08:08] *** mj41 left
[08:10] *** mishnik joined
[08:11] <mishnik> Hi has anybody realize SOAP::LITE on Racudo?

[08:12] *** mtk left
[08:13] *** mishnik left
[08:15] <dalek> niecza/immediate: c4eed9f | sorear++ | lib/CORE.setting:

[08:15] <dalek> niecza/immediate: make Bool.Int DTRT

[08:15] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/c4eed9fbb4

[08:15] <dalek> niecza/immediate: 32dd320 | sorear++ | src/niecza:

[08:15] <dalek> niecza/immediate: Fudge {YOU_ARE_HERE} handling so MAIN's UNIT:: can be a global block

[08:15] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/32dd320321

[08:16] <sorear> nom: say 2

[08:16] <p6eval> nom: OUTPUT¬´2‚ê§¬ª

[08:17] <sorear> nom: class Foo { ... }; say Foo

[08:17] <p6eval> nom: OUTPUT¬´The following packages were stubbed but not defined:‚ê§    Foo‚ê§‚ê§current instr.: 'nqp;Perl6;SymbolTable;assert_stubs_defined' pc 2767 (src/gen/perl6-symboltable.pir:778)‚ê§¬ª

[08:17] <sorear> nom: my class Foo { }; if 1 { my class Foo { } }

[08:17] <p6eval> nom:  ( no output )

[08:17] <sorear> nom: my class Foo { }; my class Foo { }

[08:17] <p6eval> nom: OUTPUT¬´Illegal redeclaration of class 'Foo' at line 1, near "{ }"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 26397 (src/stage2/gen/NQPHLL.pir:7039)‚ê§¬ª

[08:17] <sorear> nom: package Foo { ... }; class Foo { method bar() { } }

[08:17] <p6eval> nom: OUTPUT¬´Cannot add a method to a class at line 1, near "}"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 26397 (src/stage2/gen/NQPHLL.pir:7039)‚ê§¬ª

[08:17] <sorear> nom: class Foo { method bar() { } }

[08:17] <p6eval> nom:  ( no output )

[08:18] <sorear> phenny: tell jnthn NOMBUG: package Foo { ... }; class Foo { method bar() { } }

[08:18] <phenny> sorear: I'll pass that on when jnthn is around.

[08:18] <sorear> phenny: tell jnthn S12-class/stubs.t line 15

[08:18] <phenny> sorear: I'll pass that on when jnthn is around.

[08:19] *** molaf left
[08:21] *** mtk joined
[08:21] <sorear> nom: my $x = 0; class Foo { method bar() { $x++ } }; Foo.bar; say $x

[08:21] <p6eval> nom: OUTPUT¬´Could not find sub &postfix:<++>‚ê§current instr.: 'bar' pc 931 ((file unknown):341) (:1)‚ê§¬ª

[08:21] <sorear> nom: my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x

[08:21] <p6eval> nom: OUTPUT¬´1‚ê§¬ª

[08:21] <sorear> nom: { my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x }

[08:21] <p6eval> nom:  ( no output )

[08:22] <sorear> nom: { my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x }()

[08:22] <p6eval> nom: OUTPUT¬´Lexical '$_' not found‚ê§current instr.: '_block18' pc 1060 ((file unknown):353) (:1)‚ê§¬ª

[08:22] <sorear> nom: if 1 { my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x }

[08:22] <p6eval> nom: OUTPUT¬´1‚ê§¬ª

[08:22] <sorear> nom: BEGIN { say 2 }

[08:22] <p6eval> nom: OUTPUT¬´Could not find sub !UNIT_OUTER‚ê§current instr.: 'nqp;Perl6;Actions;_block3887' pc 37258 (src/gen/perl6-actions.pir:12496)‚ê§¬ª

[08:25] <sorear> phenny: tell jnthn Could you explain to me how my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x; # is made to work in nom?

[08:25] <phenny> sorear: I'll pass that on when jnthn is around.

[08:30] <dalek> roast: 1b51b3a | sorear++ | S12-class/stubs.t:

[08:30] <dalek> roast: Fudge for a regression that needs jnthn feedback

[08:30] <dalek> roast: review: https://github.com/perl6/roast/commit/1b51b3ad92

[08:30] <dalek> roast: a2ccce2 | sorear++ | S03-junctions/autothreading.t:

[08:30] <dalek> roast: [S03-junctions/autothreading] Use our to avoid testing unrelated protolexpad handling

[08:30] <dalek> roast: review: https://github.com/perl6/roast/commit/a2ccce2ecf

[08:33] <dalek> niecza/immediate: 89d19ed | sorear++ | lib/CORE.setting:

[08:33] <dalek> niecza/immediate: prefix:<so> needs to take Mu

[08:33] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/89d19ed6e8

[08:36] *** Trashlord joined
[08:43] *** JimmyZ left
[08:47] *** wamba left
[08:56] <dalek> niecza/immediate: 819cf4a | sorear++ | src/niecza:

[08:56] <dalek> niecza/immediate: Fix metaop compilation

[08:56] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/819cf4a0ce

[08:59] *** jfried joined
[09:04] *** scottp left
[09:09] *** Tedd1^ joined
[09:10] *** Tedd1 left
[09:13] <sorear> two more failing spetest files for the morning

[09:13] * sorear out

[09:14] *** Su-Shee_ is now known as Su-She

[09:14] *** Su-She is now known as Su-Shee

[09:31] *** daniel-s joined
[09:40] *** Trashlord left
[09:41] *** masak joined
[09:41] <masak> morning, #perl6

[09:41] <masak> wow, it's great to see pmichaud++ back-n-hackin', and not only jnthn++ engaging him in conversation, but sorear++ too!

[09:42] <tadzik> like a family reunion :)

[09:42] <tadzik> good morning masak 

[09:43] <masak> it's the weekend! \o/

[09:44] <tadzik> today is gsocday :)

[09:44] *** Trashlord joined
[09:45] <tadzik> as soon as I wake up properly

[09:45] * masak pours a bucket of ice-cold water over tadzik 

[09:45] <masak> better? :P

[09:45] <tadzik> gah!

[09:45] <masak> oh, not good?

[09:45] <tadzik> I saw it a bit too late

[09:45] <masak> did I mess up...?

[09:45] <masak> that's kinda the point.

[09:46] <tadzik> prfrfrbrbt

[09:46] <masak> sorry, sorry...

[09:46] <tadzik> ;)

[09:46] <masak> ;)

[09:46] <masak> I would like to say "it won't happen again"... but... :P

[09:46] <Juerd> sorear: No

[09:46] <tadzik> now I'm scared to go to YAPC with you guys

[09:47] <masak> :P

[09:47] *** breatharian joined
[09:47] <breatharian> howdy

[09:47] <masak> breatharian: hi!

[09:47] <breatharian> Good morning! :-)

[09:47] * tadzik imagines a herd of zebras stumbling into random rooms with buckets of water screaming "commit flood!"

[09:47] <masak> breatharian: "breatharian" sounds like a political party. I'm in!

[09:48] <masak> tadzik: next hit on Youtube, clearly.

[09:48] <breatharian> So, I got some pretty good help on this question: http://stackoverflow.com/questions/6300674/for-with-multiple-arrays/6303440#6303440

[09:48] <breatharian> From tadzik for example. :-)

[09:48] <tadzik> masak: I can see those comments on youtube "so that's why Perl 6 is taking so long"

[09:48] <tadzik> breatharian: oh, hi :)

[09:49] <masak> rakudo: my @a = 1, 2, 3; my @b = 10, 20, 30; for @a Z @b -> $a, $b { say $a + $b }

[09:49] <p6eval> rakudo 4a6d21: OUTPUT¬´11‚ê§22‚ê§33‚ê§¬ª

[09:49] <masak> breatharian: like that, for example.

[09:49] <breatharian> moritz mentions that the official spec version of 'zip' can handle more than 2 lists. Are there any examples of this somewhere?

[09:49] <tadzik> I guess in the spec :)

[09:49] <masak> breatharian: the infix:<Z> interleaves the two arrays, and '-> $a, $b' pulls out two at a time.

[09:49] <breatharian> hehe

[09:50] <moritz> I think pugs implements it

[09:50] <tadzik> <a b> Z~ 1,2 Z+ 3,4

[09:50] <masak> breatharian: infix:<Z> is s'posed to handle more than two lists too. it just doesn't in Rakudo.

[09:50] <tadzik> for egg sample

[09:50] <tadzik> oh, I think I see a spectypo

[09:50] <tadzik> (<a b>; 1,2; 3,4).zip.lol.map { .reduce({$^a ~ $^b + $^c}) }

[09:50] <masak> alpha: my @a = 1, 2, 3; my @b = 4, 5, 6; my @c = 7, 8, 9; .say for @a Z @b Z @c

[09:50] <p6eval> alpha : OUTPUT¬´1‚ê§4‚ê§7‚ê§2‚ê§5‚ê§8‚ê§3‚ê§6‚ê§9‚ê§¬ª

[09:50] <tadzik> doesn't that miss a colon after 'map'?

[09:50] <masak> alpha did it.

[09:50] <masak> tadzik: yes.

[09:51] <tadzik> or a bunch of parns

[09:51] * tadzik fixes

[09:51] <masak> right.

[09:51] <masak> now it's TTIAR.

[09:52] <tadzik> rakudo: (<a b>; 1,2; 3,4).zip.lol.map({ .reduce({$^a ~ $^b + $^c}) }).perl.say

[09:52] <p6eval> rakudo 4a6d21: OUTPUT¬´Method 'zip' not found for invocant of class 'Parcel'‚ê§  in main program body at line 22:/tmp/8MDNvYnl2Q‚ê§¬ª

[09:52] <masak> aww.

[09:52] <dalek> specs: 62b8b39 | tadzik++ | S03-operators.pod:

[09:52] <dalek> specs: [S03] Fix ttiars in Zip operators

[09:52] <dalek> specs: review: https://github.com/perl6/specs/commit/62b8b39360

[09:52] <masak> tadzik: also, we don't support the ';' in the slice correctly yet.

[09:52] <moritz> pugs: for <a b> Z 1, 2 Z <FOO BAR> -> $a, $b, $c { say "$a$b$c" }

[09:52] <p6eval> pugs: OUTPUT¬´a 1 FOOb 2 BAR‚ê§¬ª

[09:53] <breatharian> I wonder if zip is really the most idiomatic way? I mean, for N lists, you'll have to list N-1 operators.

[09:53] <breatharian> (or so it seems)

[09:53] <tadzik> breatharian: you can [Z+] @a, @b, @c or whatever

[09:53] <tadzik> like with any other op, see:

[09:53] <breatharian> tadzik, Aha

[09:53] <tadzik> rakudo: say [+] 1, 2, 3, 4

[09:53] <p6eval> rakudo 4a6d21: OUTPUT¬´10‚ê§¬ª

[09:55] <breatharian> Oh wow, rakudo gives "Cannot resume dead coroutine." for [Z+] @a, @b, @c

[09:55] <breatharian> and exits

[09:55] <tadzik> many things in Perl 6 make you avoid writing lotsa loops

[09:56] <tadzik> breatharian: I guess that's Rakudorian for "not yet implemented, sorry"

[09:56] <masak> breatharian: what version of Rakudo is that?

[09:56] <breatharian> It's rakudo from git from a few days ago.

[09:56] <moritz> rakudo: say [Z+] (1, 2), (3, 4), (5, 6)

[09:56] <p6eval> rakudo 4a6d21:  ( no output )

[09:56] <masak> rakudo: my @a = 1, 2, 3; say [Z+] @a, @a, @a

[09:56] <p6eval> rakudo 4a6d21:  ( no output )

[09:56] * masak tries locally

[09:56] <tadzik> same thing locally

[09:57] <masak> tadzik: with which one-liner?

[09:57] <tadzik> masak: my @a = 1, 2, 3; my @b = 4, 5, 6; my @c = 7, 8, 9;[Z+] @a, @b, @c

[09:57] * masak can't reproduce it locally

[09:57] * masak submits rakudobug

[09:57] <breatharian> So Z can apply to an operator. Can I apply it to an anonymous sub as well?

[09:57] <tadzik> I guess so

[09:57] <masak> tadzik: strangely, I don't get it over here.

[09:57] <tadzik> oh?

[09:58] <masak> maybe I need to update my Rakudo :)

[09:58] <tadzik> oh, I'm on gsoc-podparser btw

[09:58] <masak> tadzik: yes, but breatharian likely isn't.

[09:58] <tadzik> For the general form, any existing, non-mutating infix operator may be used.

[09:59] <masak> hm, I was just some Configure.pl and build/ changes behind...

[09:59] <tadzik> rakudo: (<a b>; 1,2).zipwith(&[~]).perl.say

[09:59] <p6eval> rakudo 4a6d21: OUTPUT¬´Method 'zipwith' not found for invocant of class 'Parcel'‚ê§  in main program body at line 22:/tmp/I1u1owxQ_s‚ê§¬ª

[09:59] <breatharian> http://www.breatharian.com

[09:59] <breatharian> ;-)

[09:59] <breatharian> (I'm not really into that stuff) :-D

[09:59] <masak> tadzik: could you please nopaste your local dead-coroutine error? along with your local rakudo version?

[09:59] <breatharian> But you gotta love it!

[10:00] <tadzik> breatharian: nick-coincidence?

[10:00] *** ewemoa left
[10:00] <tadzik> masak: http://wklej.org/id/544470/

[10:00] <masak> tadzik: dz.

[10:00] <tadzik> masak: prsz

[10:01] <masak> :P

[10:01] <masak> tadzik: hm, is that a compile-time error? what happens if you 'say "alive"' at the *beginning* of the program?

[10:01] <tadzik> tadzik.com is quite more pleasant to look at :)

[10:02] <tadzik> erm, nuts

[10:02] <tadzik> > say 'alive'; my @a = 1, 2, 3; my @b = 4, 5, 6; my @c = 7, 8, 9;[Z+] @a, @b, @c

[10:02] <tadzik> alive

[10:02] <tadzik> no other errors

[10:02] <masak> hah! :)

[10:02] <breatharian> brb

[10:02] *** breatharian left
[10:02] <masak> this all goes into the ticket. tadzik++

[10:02] <tadzik> weird

[10:02] <tadzik> masak++ for actual work :)

[10:04] <masak> no worries, I really like this job :)

[10:05] *** breatharian joined
[10:06] <breatharian> Hmm... If I do: say 'alive'; my @a = 1, 2, 3; my @b = 4, 5, 6; my @c = 7, 8, 9; say ([Z+] @a, @b, @c)

[10:06] <breatharian> I don't see the second 'say' result.

[10:08] <breatharian> tadzik, Not really a nick-coincidence. :-)

[10:08] <masak> breatharian: I don't see the result there either.

[10:08] <masak> breatharian: but we know that 'say' sometimes swallows errors.

[10:08] <masak> breatharian: maybe try without 'say'.

[10:09] <masak> oh!

[10:09] <breatharian> masak, Right, in that case the output of the Z+ is not listed.

[10:09] <breatharian> But at least it doesn't crash. :-)

[10:09] <masak> I got it here on the REPL.

[10:09] * masak kicks the REPL, hard

[10:09] <breatharian> :-( Be nice to your REPL.

[10:09] <masak> my REPL isn't nice to me. :(

[10:10] <breatharian> I just introduced mine to rlwrap. :-)

[10:10] <breatharian> It's not the REPLs fault! It's just talking to rakudo. :-)

[10:10] <masak> what lib must Parrot find for history to work in the REPL?

[10:10] <tadzik> readline I think

[10:10] <masak> breatharian: you're a very reasonable person.

[10:11] <masak> please stick around ;)

[10:11] <masak> tadzik: oh, natch. thanks.

[10:11] <breatharian> haha

[10:11] <breatharian> I met dukeleto in Portland back in 2008 at mini Factor meetup.

[10:12] <breatharian> (hi dukeleto)

[10:12] <masak> auto::readline -      Does your platform support readline..................no.

[10:12] <tadzik> masak: libreadline-dev or something

[10:12] <tadzik> on debianesque systems

[10:12] <masak> tadzik++

[10:12] <masak> aye.

[10:13] *** jimmy1980 joined
[10:13] <breatharian> What is the 'alpha' bot running?

[10:13] <masak> breatharian: an older Rakudo strain.

[10:13] <breatharian> aha

[10:14] <breatharian> Funny that alpha can handle it then.

[10:14] <masak> "ha ha" :P

[10:14] *** woosley joined
[10:14] <masak> breatharian: I was the last alpharian, I think. :)

[10:14] <masak> for reasons like that.

[10:15] <masak> and because I was lazy and didn't want to translate oodles of module code...

[10:15] <moritz> you could have patched master to do what alpha was capable of :-)

[10:15] <masak> but that's *hard*...

[10:18] <breatharian> So with "[Z+] @a, @b, @c" I'm zipping with +. What's the syntax to zip with an anonymous sub?

[10:19] <masak> breatharian: zipwith(sub { ... }), something like that.

[10:19] <breatharian> aha

[10:19] <masak> you can only do Z with operators; with other kinds of Code you have to use &zipwith

[10:19] <breatharian> kewl

[10:20] *** whiteknight joined
[10:22] <masak> token longname { <name> {} [ <?before ':' <[ a..z A..Z _ \< \[ \¬´ ]>> <colonpair> ]* }

[10:22] <masak> TimToady: some guy called tchrist told me that doing A..Z in today's Unicode world is always wrong... :P

[10:23] <masak> well, he didn't exactly tell me. I could hear him shouting it through the massive missive of his on Stackoverflow.

[10:24] *** awoodland joined
[10:26] *** Mowah joined
[10:27] <masak> breatharian: ah; the actual syntax is (<a b>; 1,2).zipwith( sub($a, $b) { $a + $b } )

[10:27] <masak> breatharian: (but (<a b>; 1,2) doesn't work yet)

[10:29] <breatharian> masak, Aha, thanks.

[10:31] <breatharian> So in theory this should be OK: (100,200,300 ; 10,20,30 ; 1,2,3).zipwith( sub ($a,$b,$c) { $a + $b + $c } )

[10:31] <breatharian> and yield 111 222 333

[10:31] <breatharian> alpha: (100,200,300 ; 10,20,30 ; 1,2,3).zipwith( sub ($a,$b,$c) { $a + $b + $c } )

[10:31] <p6eval> alpha : OUTPUT¬´Method 'zipwith' not found for invocant of class 'List'‚ê§in Main (file src/gen_setting.pm, line 324)‚ê§¬ª

[10:32] <breatharian> (don't worry alpha, I won't kick you) ;-)

[10:33] <tadzik> turns out our Z is less than speccy

[10:33] <masak> breatharian: I'm not sure how zipwith is meant to work with subs of arity other than 2.

[10:33] <breatharian> masak, ok

[10:33] <masak> breatharian: either the above will work without a hitch, or you're meant to provide an arity-2 thingy, and it'll do the addition twice.

[10:34] <breatharian> Where's TimToady when you need him? :-)

[10:34] <masak> oh, he's around :)

[10:34] <masak> but likely asleep right now.

[10:34] <breatharian> I guess I'm wondering what Perl 6's answer is to Scheme's 'for-each' is. for-each works with 2 or more lists.

[10:35] <breatharian> http://www.r6rs.org/final/html/r6rs/r6rs-Z-H-14.html#node_sec_11.9

[10:36] <breatharian> Scheme's 'map' also works with 2 or more lists.

[10:37] <masak> things are factored slightly differently in Perl 6, I'd say.

[10:37] <breatharian> There's also vector-map and vector-for-each

[10:37] <masak> but I believe we still cover the same semantic territory, what with pointy blocks and infix-prefix Z.

[10:39] *** araujo joined
[10:39] *** araujo left
[10:39] *** araujo joined
[10:39] <breatharian> Hmm, this appears to work with 2 or more lists: http://cpan.uwinnipeg.ca/htdocs/Operator-Util/Operator/Util.html

[10:40] <breatharian> E.g. zipwith(',', ['a','b'], [1,2], ['x','y'])

[10:40] <breatharian> (I know, it's Perl 5) :-)

[10:41] <sorear> tadzik: if it makes you feel any better, I won't be at YAPC::EU this year :(

[10:42] <tadzik> :(

[10:42] <masak> awww

[10:42] <breatharian> Ah, but Operator::Util zipwith doesn't work with subs...

[10:43] <masak> odd.

[10:43] <masak> seems like that would be easier than strings.

[10:43] <sorear> wait

[10:43] <sorear> this is actually quite easy :p

[10:43] <sorear> niecza: say ((100,200,300) Z+ (10,20,30) Z+ (1,2,3)).perl

[10:43] <p6eval> niecza v6-89-ge849cf7: OUTPUT¬´(111, 222, 333).list‚ê§¬ª

[10:44] <moritz> sorear++

[10:44] <tadzik> nice

[10:44] <sorear> breatharian: [Z+] @x, @y, @z won't work because [] forgets where one array stops and the next begins

[10:45] <tadzik> oh

[10:45] <breatharian> sorear, Nice. However, with that form, for N lists, you must have N-1 operators. What's the form where you only list the operator *or* anonymous sub once and use it for all the lists?

[10:45] <jnthn> morn....afternoon, #perl6

[10:45] <phenny> jnthn: 08:18Z <sorear> tell jnthn NOMBUG: package Foo { ... }; class Foo { method bar() { } }

[10:45] <phenny> jnthn: 08:18Z <sorear> tell jnthn S12-class/stubs.t line 15

[10:45] <phenny> jnthn: 08:25Z <sorear> tell jnthn Could you explain to me how my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x; # is made to work in nom?

[10:45] <masak> we need '{Z+} (@a; @b; @c)' or something :)

[10:46] <sorear> niecza: say zipwith({ $^a + $^b + $^c }, (100,200,300), (10,20,30), (1,2,3)).perl # NOT PORTABLE

[10:46] <breatharian> maybe I should install niecza :-)

[10:46] <p6eval> niecza v6-89-ge849cf7: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§      'zipwith' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1146 (STD P6.comp_unit @ 31) ‚ê§  at

[10:46] <masak> jnthn: morning, s√∂mntuta :)

[10:46] <p6eval> ../home/p6eval/niecza‚Ä¶

[10:46] <moritz> what's wrong with [Z+] @a; @b; @c  ?

[10:46] <masak> oh!

[10:46] <masak> moritz++

[10:46] <sorear> niecza: say zipop({ $^a + $^b + $^c }, (100,200,300), (10,20,30), (1,2,3)).perl # NOT PORTABLE

[10:46] <p6eval> niecza v6-89-ge849cf7: OUTPUT¬´(111, 222, 333).list‚ê§¬ª

[10:46] <breatharian> niiiice

[10:46] <masak> moritz: but I thought [op] worked by replacing commas with op

[10:47] <sorear> moritz: mainly the fact that the ; ends the statement :)

[10:47] <masak> moritz: at least conceptually :)

[10:47] <moritz> sorear: modulo parens

[10:47] *** jimmy_ joined
[10:47] <sorear> moritz: the problem with that is that nobody here has the foggiest clue how slicelists are supposed to work

[10:47] <moritz> niecza : my @a = 1, 2, 3; my @b = 10, 20, 30; say [Z+](@a; @b).perl

[10:48] <moritz> niecza: my @a = 1, 2, 3; my @b = 10, 20, 30; say [Z+](@a; @b).perl

[10:48] <p6eval> niecza v6-89-ge849cf7: OUTPUT¬´[10, 20, 30].list‚ê§¬ª

[10:48] <masak> case in point.

[10:48] <masak> like Rakudo, it picks the last list.

[10:49] <jnthn> nom: say "om nom nom!"

[10:49] <p6eval> nom: OUTPUT¬´om nom nom!‚ê§¬ª

[10:49] <jnthn> \o/

[10:50] <breatharian> Well, I've got to run for now. Latar.

[10:50] *** breatharian left
[10:51] <masak> breatharian: thank you for reminding us all to breathe!

[11:03] <dalek> niecza/immediate: 9f4b95c | sorear++ | src/niecza:

[11:03] <dalek> niecza/immediate: Fix our-enum alias generation, anonymous enums

[11:03] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/9f4b95c532

[11:03] <sorear> all spectests fixed

[11:10] *** Shozan joined
[11:12] <jnthn> sorear: Ah, the NOMBUG is a known "didn't get to that yet". :)

[11:13] <jnthn> sorear: Thanks for the reminder :)

[11:13] *** MayDaniel joined
[11:13] <jnthn> nom: my $x = 0; class Foo { method bar() { $x = $x + 1 } }; Foo.bar; say $x

[11:13] <p6eval> nom: OUTPUT¬´1‚ê§¬ª

[11:14] *** araujo left
[11:14] <jnthn> sorear: I'm...not sure how to answer your question. I don't really do anything special to make that work.

[11:14] <jnthn> sorear: Just make sure all the blocks are in the correct lexical scopes.

[11:14] <jnthn> And then it "just works"

[11:18] <dalek> rakudo/nom: 825da2b | moritz++ | src/core/operators.pm:

[11:18] <dalek> rakudo/nom: add prefix:<so>

[11:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/825da2bb3f

[11:18] <dalek> rakudo/nom: d0d51dc | moritz++ | / (2 files):

[11:18] <dalek> rakudo/nom: add simplistic Rat; no literals yet

[11:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d0d51dcfcc

[11:19] <jnthn> moritz: Note that it'll be "does Real" soonish

[11:20] <jnthn> But yes, I need to fix MI :)

[11:20] <jnthn> Well

[11:20] <jnthn> MI with attributes

[11:20] <jnthn> :)

[11:22] <masak> waitwhat does MI have to do with attributes?

[11:23] <jnthn> masak: er? :)

[11:23] <jnthn> masak: Has quite an impact on attribute storage, potentially.

[11:23] <masak> oh!

[11:24] <masak> yeah.

[11:24] * masak un-asks question

[11:24] <jnthn> And P6opaque is -OSI :)

[11:24] <jnthn> With "jnthn, remember to do MI" hooks here and there :)

[11:24] * jnthn mostly hates MI

[11:25] * masak doesn't plan on using MI in Perl 6, ever

[11:25] <masak> well, maybe for finding bugs :P

[11:25] <jnthn> Well, I don't really advocate removing it, but I don't feel a need to make it especially efficient either.

[11:26] <jnthn> It's not like we don't have roles. :)

[11:32] <masak> implement a one-in-a-hundred error message saying "SORRY: You're using multiple inheritance. And it's 2011! Just thought we'd let you know."

[11:33] <jnthn> Heh. I just looked at why compiling CORE.setting.pir to PBC takes so long.

[11:33] <jnthn> According to the profile, we spend almost all the time in register allocation...

[11:34] <tadzik> fun with infinite registers

[11:34] <jnthn> Computing the du-chain is O(2 * num_symbols * num_instructions)

[11:36] <jnthn> Which basically means that the time to compile that file is going to grow as a square.

[11:36] <jnthn> Well, to compile the deserialization thingy.

[11:42] <sorear> jnthn: well, if you didn't do anything "special" to make it work, could you please still explain *how* it works? :)

[11:42] <sorear> masak-- # C3 Multiple inheritance has been very good to me, it doesn't need senseless hating

[11:43] <masak> sorear: glad to hear that. I'm still on the lookout for good examples of where MI is useful and roles can't be used instead.

[11:44] <sorear> well sure you CAN use roles instead, but why?

[11:44] <sorear> niecza's current factoring of enums using MI would be marginally trickier with roles

[11:44] <masak> oh, and even I, as the senseless MI hater I am, can see that C3 is a big improvement over most other schemes.

[11:45] <sorear> (if niecza had roles, which it doesn.t)

[11:45] <masak> sorear: why? because roles find collisions at composition time.

[11:45] <jnthn> sorear: The method's outer points to the class block, whose outer points to the main body.

[11:47] <jnthn> nom: my $x; my $y = 1; { $x = sub { $y = $y + 1 } }; $x(); say $y;

[11:47] <p6eval> nom: OUTPUT¬´get_pmc_keyed() not implemented in class 'Integer'‚ê§current instr.: 'nqp;Perl6;Actions;_block7293' pc 61636 (src/gen/perl6-actions.pir:0)‚ê§¬ª

[11:47] <jnthn> er, what...

[11:47] <sorear> nom: if 1 { my $x; class A { method b () { $x = 5 }; }; A.b; say $x }

[11:47] <p6eval> nom: OUTPUT¬´5‚ê§¬ª

[11:47] <sorear> doesn't the if { } generate a sub?

[11:48] <sorear> wait, I think I get this

[11:48] <sorear> if must not be using pir::clone

[11:48] <jnthn> sorear: If you mean Parrot sub, yes

[11:48] <jnthn> No, we take some care over when to clone

[11:48] <jnthn> Not just blindly cloning all over :)

[11:48] <jnthn> That'd be slow and get stuff wrong. :)

[11:49] <sorear> Where is the care?

[11:49] <jnthn> I suspect some of it's in PAST::Compiler

[11:49] <jnthn> Oh, maybe part of it is calling block_closure in the actions, or whatever we called it.

[11:50] *** gbacon_ joined
[11:50] <sorear> nom: sub foo($x) { if 1 { sub () { $x }; }; }; my $a = foo(5); my $b = foo(6); say $a(); say "alive"

[11:50] <p6eval> nom:  ( no output )

[11:50] <sorear> I THINK I BROKE IT

[11:50] <jnthn> nom: say 1; { say 2 }; say 3;

[11:50] <p6eval> nom: OUTPUT¬´get_pmc_keyed() not implemented in class 'Integer'‚ê§current instr.: 'nqp;Perl6;Actions;_block7293' pc 61636 (src/gen/perl6-actions.pir:0)‚ê§¬ª

[11:50] <jnthn> oh, heh

[11:50] *** scottp joined
[11:52] <sorear> nqp: sub foo($x) { if 1 { sub () { $x }; }; }; my $a := foo(5); my $b := foo(6); say($a()); say("alive")

[11:52] <p6eval> nqp: OUTPUT¬´5‚ê§alive‚ê§¬ª

[11:53] <sorear> nqp: my $x; class A { method b () { $x := 5 }; }; A.b(); say($x);

[11:53] <p6eval> nqp: OUTPUT¬´5‚ê§¬ª

[11:53] <jnthn> pmichaud++ # sorted a bunch of this stuff out :)

[11:53] <sorear> nqp: if 1 { my $x; class A { method b () { $x := 5 }; }; A.b(); say($x); }

[11:53] <p6eval> nqp: OUTPUT¬´5‚ê§¬ª

[11:54] <sorear> you'll need to be more patient with me

[11:54] <sorear> I still do not get how this is possible

[11:54] <jnthn> sorear: I'm still trying to work out what you're missing.

[11:55] <sorear> jnthn: why isn't there more than one copy of "$x"?

[11:55] <sorear> one per sub invocation, plus one for statics?

[11:56] <jnthn> In the above?

[11:56] <sorear> yes

[11:56] <jnthn> Where's the sub invocation?

[11:56] <sorear> if 1 { }

[11:56] *** daniel-s left
[11:57] *** daniel-s joined
[11:57] <jnthn> Ah, maybe what's missing is that the class body (and in turn the method) are lexically captured.

[11:57] <jnthn> So they see the correct $x

[11:57] <sorear> "lexically captured"?

[11:57] <jnthn> capture_lex

[11:57] <masak> as opposed to what?

[11:58] <sorear> jnthn: when are they captured?

[11:58] <jnthn> sorear: Outer block entry, IIRC.

[11:58] * jnthn didn't actually implement these bits, fwiw :)

[11:58] <jnthn> pmichaud++ can probably give more detailed answers.

[11:58] <jnthn> I'm mostly just happy that they work. :)

[11:59] *** envi_laptop left
[11:59] <sorear> ok.

[11:59] <sorear> I'll talk to pmichaud if he shows up again this month

[11:59] <jnthn> sorear: Maybe try --target=pir'ing the code you did above too. It may make things more clear.

[11:59] <jnthn> (Or less clear... :))

[12:00] <sorear> jnthn: I'm building a newer nom now for that purpose

[12:00] <sorear> can't --target=pir on p6eval/nom yet :)

[12:00] <sorear> (or can you?)

[12:00] <sorear> (probably with some Q:PIR...)

[12:01] <jnthn> I don't know of a way.

[12:02] <sorear> you used to be able to explicitly call Perl6::Compiler with :target<pir> on rakudo/ng in p6eval

[12:02] <sorear> with some other fudges

[12:02] <jnthn> Ah, OK

[12:03] <jnthn> That was more by Parrot namespaces being global rather than design, I suspect. :)

[12:03] * jnthn gets back to the bug he didn't manage to fix last night

[12:04] <sorear> nom is kinda infuriating, I feel like I've lost so much ground :p

[12:04] *** araujo joined
[12:05] <jnthn> sorear: Being able to do nom took a LOT of effort designing and building a new set of primitives.

[12:05] <jnthn> It's basically what I've done since Rakudo *.

[12:05] <jnthn> I never imagined it'd take until June 2011 to actually start on nom itself...

[12:06] <jnthn> Well, May, but...

[12:09] <sorear> nom pir is unreadable

[12:10] <masak> don't think of it as losing ground. think of it as Rakudo becoming an implementation more worthy of comparing oneself against. ;)

[12:11] <jimmy_> parrot -- if nom.pir is not readable;

[12:11] <sorear> jnthn: How does the .lex "$?PACKAGE", $P25 stuff work?

[12:13] *** jimmy_ is now known as JimmyZ

[12:15] <sorear> jnthn: why do your thaw subs use control flow?

[12:16] <jnthn> sorear: .lex "$?PACKAGE", $P25 declares a register to use for storage of $?PACKAGE

[12:16] <jnthn> sorear: Control flow is just "are we building the world" vs "are we fixing up"

[12:16] <jnthn> Yes, nom PIR is a horrible read.

[12:16] <masak> I'm not buying the sequel.

[12:16] <jnthn> :P

[12:17] <jnthn> sorear: It only emits both because it was, in theory, helpful for me when tracking down problems.

[12:17] <jnthn> sorear: It could really emit one or the other.

[12:18] <jnthn> Since I never really ran into the sort of problems it's dealing with...

[12:18] * sorear goes to read perl6lexpad and perl6lexinfo

[12:18] *** kid51 joined
[12:20] *** Fuad joined
[12:20] <sorear> jnthn: how much of those did you write?

[12:20] <Fuad> hello

[12:21] <sorear> hello, welcome, Fuad 

[12:21] <Fuad> sorear, hello, thanks

[12:22] <jnthn> sorear: The lot, though it's mostly copies NQPLexPad and NQPLexInfo

[12:22] <jnthn> sorear: They really just add static lexpad functionality.

[12:22] <jnthn> sorear: Other than that they do what the Parrot LexPad and LexInfo do.

[12:23] <dalek> niecza/immediate: dd266aa | sorear++ | src/niecza:

[12:23] <dalek> niecza/immediate: Fix nontrivial protoregex signature check

[12:23] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/dd266aae07

[12:24] * sorear hopes to still be relevant by YAPC::EU

[12:24] *** araujo left
[12:24] <masak> sorear: I think you worry too much.

[12:24] *** araujo joined
[12:25] <jnthn> sorear: fwiw, the lexpad situation in nom still annoys me.

[12:26] <jnthn> They're one of the fewish things we have left that aren't 6model objects

[12:31] *** awoodland left
[12:32] <sorear> masak: sorry, that was meant as a joke but I forgot to apply the :)

[12:32] <masak> happy to hear that.

[12:33] *** araujo left
[12:33] <masak> if nothing else, niecza provides an invaluable second data point.

[12:33] <masak> speed is in many ways secondary to that.

[12:33] *** araujo joined
[12:33] <sorear> jnthn: do you want to see lexpads as SixModelObject, or as P6opaque?

[12:34] <sorear> wheee, /immediate can compile itself

[12:34] <sorear> ...incorrectly

[12:35] <JimmyZ> wheee, so I should be happy or unhappy?

[12:36] <masak> ('sides, I still think niecza will be relatively fast.)

[12:38] <sorear> that was genuinely unexpected.  niecza's self-compilation fails on... the option parser

[12:39] <sorear> there are so many nastier bits of code to catch on, but no...

[12:49] *** Chillance joined
[12:50] *** gbacon_ left
[12:53] <masak> :)

[12:56] <dalek> rakudo/nom: 0f9c79f | jnthn++ | src/ (2 files):

[12:56] <dalek> rakudo/nom: Have a shot at .VAR.

[12:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f9c79fd22

[12:56] <dalek> rakudo/nom: 08316ac | jnthn++ | src/Perl6/Metamodel/ContainerDescriptor.pm:

[12:56] <dalek> rakudo/nom: Little optimization and bugfix all in one.

[12:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/08316ac4eb

[12:56] <dalek> rakudo/nom: 55eb27d | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[12:56] <dalek> rakudo/nom: Fix attributes in roles typed with role type parameters.

[12:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/55eb27d010

[12:57] <sorear> jnthn: does nom use the binder to populate $/,$!,$_?

[12:57] <sorear> I notice an absense of code to populate them

[12:57] <jnthn> sorear: We don't populate them at all yet.

[12:57] <jnthn> sorear: NYI

[12:58] <jnthn> (on nommap :))

[13:12] <dalek> niecza/immediate: 344f801 | sorear++ | / (2 files):

[13:12] <dalek> niecza/immediate: Fix "is export" on subs in modules that did not also contain classes/etc

[13:12] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/344f801af3

[13:12] <sorear> cute bug.

[13:18] *** scottp left
[13:36] *** lichtkind joined
[13:48] <sorear> \o/ \o/ \o/ \o/ \o/

[13:49] <sorear> make reboot finished without error.  the phase 1 refactor is done.

[13:49] <moritz> \o/ indeed

[13:49] * sorear tidies up a bit before merging

[14:05] *** Fuad left
[14:06] *** woosley left
[14:13] <dalek> niecza/immediate: 9fe8af9 | sorear++ | src/niecza:

[14:13] <dalek> niecza/immediate: Fix augment cur_pkg setting

[14:13] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/9fe8af9cfd

[14:13] <dalek> niecza/immediate: e72e1b6 | sorear++ | src/ (9 files):

[14:13] <dalek> niecza/immediate: Mergeback augments

[14:13] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/e72e1b6281

[14:16] *** JimmyZ left
[14:32] <dalek> niecza/immediate: 2510693 | sorear++ | / (8 files):

[14:32] <dalek> niecza/immediate: Kill off Body, Unit, and NieczaPassBegin for real

[14:32] <dalek> niecza/immediate: review: https://github.com/sorear/niecza/commit/2510693b4b

[14:32] *** jimmy1980 left
[14:33] <dalek> Heuristic branch merge: pushed 60 commits to niecza by sorear

[14:33] *** JimmyZ joined
[14:33] <sorear> final balance:  21 files changed, 1075 insertions(+), 1463 deletions(-)

[14:34] <TimToady> \o/

[14:34] <jnthn> It's nice when improvements remove code. :)

[14:36] *** JimmyZ_ joined
[14:38] *** JimmyZ left
[14:38] *** JimmyZ_ is now known as JimmyZ

[14:38] <TimToady> „ÅäÁñ≤„ÇåÊßò„Åß„Åó„Åü!

[14:39] <jnthn> JimmyZ: I submitted BJPW talks \o/

[14:41] <JimmyZ> jnthn: Great! what's the subject? 

[14:42] <jnthn> JimmyZ: Submitted two, which the organizers can choose one or both of. One about Rakudo, one about Perl 6 more generally.

[14:43] <JimmyZ> I'd like choose both ;)

[14:43] <JimmyZ> *like to

[14:44] <JimmyZ> seems that there will be two subject about Perl 6 and on about rakudo ;)

[14:44] <JimmyZ> *one

[14:44] *** kid51 left
[14:46] <jnthn> :)

[14:51] *** [particle]1 is now known as [particle]

[15:00] <dalek> rakudo/nom: 7ecee52 | jnthn++ | / (6 files):

[15:00] <dalek> rakudo/nom: Role summation, so class C does R1 does R2 { ... } now (at least somewhat) works. Composes methods, reports collisions. Also composes attributes from the role.

[15:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ecee52653

[15:00] *** lateau joined
[15:00] <tadzik> cool :)

[15:01] <jnthn> Getting there, bit by bit :)

[15:02] <tadzik> moritz: do you have a moment?

[15:03] <moritz> tadzik: yes

[15:04] <tadzik> or to all you friendly zebras: list item in pod6 can be any kind of block, as long as it's indentified by /^item [\d+]?/. Having a rule pod_block:sym<delimited>, also :sym<paragraph> and so on, I'm looking for some gentle way to do something like token list { <pod_block :where($<identifier> ~~ /^item/)> }

[15:05] <tadzik> I could roll 3 new block types as I did for code and comment blocks, but I wonder if I can avoid code repetition this time

[15:06] <tadzik> I could also distinguish between them in the action methods not in the grammar

[15:07] <moritz> maybe have a $.is-list-item attribute or some such

[15:07] <moritz> doing that in the actions seems sensible

[15:07] <TimToady> <podblock("item")>

[15:08] <tadzik> moritz: so no treating the list as a whole, in the grammar at least?

[15:08] <tadzik> TimToady: would that work?

[15:08] <TimToady> it's just a method call, so you can pass arguments

[15:08] <jnthn> We use that in Rakudo's grammar in various places.

[15:08] * tadzik looks around the grammar

[15:09] <moritz> tadzik: is a list delimited in pod?

[15:10] <tadzik> oh, no

[15:10] <tadzik> Lists in Pod are specified as a series of contiguous C<=item> blocks. No special "container" directives or other delimiters are required to enclose the entire list

[15:10] <tadzik> that makes lists really easy to parse :)

[15:11] <TimToady> it seems a bit fragile if you might want to stick something else in the middle of a list

[15:11] <tadzik> but Damian has Pod6::Block::List in his implementation, iirc

[15:12] <moritz> if we stick to that spec, it seems like a post-processing step would be appropriate to get from list items to a list

[15:12] <tadzik> yes

[15:12] <TimToady> what kind of list does it default to?

[15:13] * TimToady hasn't read the Pod6 spec in too long...

[15:13] <tadzik> no idea, but Perl6::Perldoc has separate Block::List and Block::Item blocks

[15:13] *** whiteknight left
[15:14] <tadzik> oh, it says there's an implicit =list block

[15:14] *** MayDaniel left
[15:14] * tadzik reads the spec more carefully

[15:15] *** daniel-s left
[15:15] <tadzik> I don't see anything like this mentioned

[15:15] <dalek> rakudo/nom: 21a686e | jnthn++ | src/Perl6/Metamodel/ParametricRoleHOW.pm:

[15:15] <dalek> rakudo/nom: Allow roles doing roles to work.

[15:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/21a686e570

[15:16] *** Trashlord left
[15:23] <TimToady> [Z+] @a, @b, @c is not going to work, since it's a listop, which flattens

[15:25] <TimToady> you need something more like [Z+] \@a, \@b, \@c

[15:26] *** envi_laptop joined
[15:27] <TimToady> hmm, we don't seem to have a good way to specify a list of items on the caller's end

[15:27] <TimToady> I don't think [Z+] \(@a,@b,@c) will work

[15:29] <TimToady> but maybe reducing with list infixes can automatically switch to "loi" context and dwym

[15:32] <TimToady> or use scalars as arrays as a workaround

[15:32] <TimToady> perl6: my $a = [1,2,3]; my $b = [4,5,6]; my $c = [7,8,9]; say [Z+]($a,$b,$c).perl

[15:32] <p6eval> pugs: OUTPUT¬´*** ‚ê§    Unexpected "["‚ê§    expecting bare or pointy block construct, ":", identifier or operator‚ê§    at /tmp/BTV65rzUDO line 1, column 56‚ê§¬ª

[15:32] <p6eval> ..niecza v6-89-ge849cf7: OUTPUT¬´(timeout)piling setting]‚ê§¬ª

[15:32] <p6eval> ..rakudo 4a6d21: OUTPUT¬´No applicable candidates found to dispatch to for 'zipwith'. Available candidates are:‚ê§:(&op, Any $lhs, Any $rhs)‚ê§‚ê§  in 'reducewith' at line 1‚ê§  in main program body at line 1‚ê§¬ª

[15:33] <TimToady> .oO(If you can't convince 'em, confuse 'em. --Harry S Truman)

[15:36] <jnthn> afk for a bit &

[15:36] <TimToady> oh, yeah, we're supposed to use semicolons for that

[15:36] * TimToady looks for more coffee...

[15:39] *** alyx joined
[15:39] *** alyx is now known as Guest96628

[15:40] <TimToady> oh, and sorear already covered all this; TimToady should finish backlogging before opening his trap, esp when insufficiently caffienated...

[15:40] <masak> TimToady: to Truman's credit, he said that while distancing himself from the idea: http://search.cpan.org/dist/autodie/

[15:40] <masak> er, link fail. http://en.wikiquote.org/wiki/Harry_S._Truman

[15:40] *** Tedd1 joined
[15:41] <TimToady> well, he was just trying to confuse people then.  :)

[15:41] <masak> how autopunny. :)

[15:41] <TimToady> some autopuns autodie

[15:41] <masak> "Truman's mention of an "old political trick" is often quoted alone as if it were a strategy he was advising rather than one he was criticizing."

[15:42] *** Tedd1^ left
[15:42] <masak> this problem arises often enough on Twitter, when people quote a thing they don't like, and get flamed because they didn't explicitly say they didn't like it.

[15:43] <masak> by default, quoting is consenting.

[15:43] <TimToady> if you're a politician, you can criticize something in an opponent and still be perfectly happy using the same trick yourself.

[15:43] <TimToady> .oO(after all, we're right, and they're wrong.)

[15:43] <masak> oh, sure.

[15:44] <masak> the fact that you know the trick is quite telling. :)

[15:44] <TimToady> as we say, takes one to know one

[15:44] <masak> blog post! http://strangelyconsistent.org/blog/fail-firmly

[15:44] <masak> (non-edublogging this time)

[15:45] <TimToady> is that allowed?

[15:45] <masak> apparently.

[15:46] <masak> the edublogging post will come later this evening.

[15:49] <tadzik> my Pod6::Items are Junctions

[15:49] <tadzik> any(Pod6;Item.new(level => Mu, content => ["Happy"]))

[15:49] <tadzik> oh my

[15:50] <tadzik> I thought |$_ flattens, apparently it doesn't, although the effect is what I wanted it to be

[15:51] <tadzik> rakudo: use Test; my $a = 5 | "foo"; isa_ok $a, Int; isa_ok $a, Str;

[15:51] <p6eval> rakudo 4a6d21: OUTPUT¬´ok 1 - The object is-a 'Int()'‚ê§ok 2 - The object is-a 'Str()'‚ê§¬ª

[15:51] <TimToady> .flat flattens, |$_ just strips off a scalar container to get at something that might be list interpolatable

[15:52] <tadzik> I'm using it in @content.push: |$_

[15:52] <TimToady> @$_ would probably be clearer

[15:52] <TimToady> though I think rakudo still requires @($_)

[15:52] <tadzik> but seems that | is not the issue

[15:53] <lichtkind> TimToady: can i have at least an official no? :)

[15:53] <masak> yes, Rakudo still requires @($_)

[15:53] <TimToady> lichtkind: huh?

[15:53] <masak> lichtkind: you didn't ask anything! :P

[15:54] <huf> no reason to deny him an official no

[15:54] <huf> i know it doesnt quite fit in with the perl6 culture, but you could get into the habit of handing those out randomly

[15:54] <TimToady> no

[15:54] <masak> :P

[15:55] <masak> everyone knows the secure thing to do is default-deny.

[15:55] <huf> ooooh, i'll frame it and hang it above my bed 

[15:55] <masak> of course then there are entire movies, like "Yes Man", that promote saying "yes" to life :P

[15:55] <tadzik> defaulting to yes gives you more tea

[15:55] <masak> ooh

[15:56] <tadzik> when you're very busy, someone asks you a question, you answer, then tea appears. I have it all the time

[15:57] <pmichaud> good morning, #perl6

[15:57] <TimToady> o/

[15:57] <tadzik> good morning pmichaud 

[15:57] <lichtkind> pmichaud: good morning

[15:58] <masak> morning, pmichaud 

[15:58] <JimmyZ> morning everyone

[16:00] *** thou joined
[16:00] *** mtk left
[16:00] <pmichaud> moritz: ping

[16:01] <moritz> pmichaud: pong

[16:02] <pmichaud> in commit 2a50310, should we be doing things like  +$a >= +$b   instead of $a.Numeric >= $b.Numeric   ?

[16:02] <masak> what's the difference?

[16:02] <masak> in fact, wouldn't >= enforce Numeric context?

[16:03] <pmichaud> masak: that's what commit 2a50310 is doing -- enforcing numeric context :)

[16:03] <moritz> pmichaud: I thought the two where synonymous

[16:03] <masak> pmichaud: ah, circularity chainsaw :)

[16:03] <masak> I agree that both would work. but one might have a shorter call chain.

[16:03] <moritz> and that is .Numeric at the moment

[16:04] <pmichaud> .Numeric has a shorter call chain, yes.

[16:04] <moritz> pmichaud: if we use prefix:<+>, we'd have to lift it

[16:04] <pmichaud> If we consider +$a to be equivalent to $a.Numeric, I'm fine with using that

[16:04] <pmichaud> the spec explicitly says  +$a  though.

[16:05] <masak> do we plan to let the user override prefix:<+>, so that it matters whether we use +$a > +$b or $a.Numeric >= $b.Numeric ?

[16:05] <masak> I think that's the question we need to ask.

[16:06] <pmichaud> S03:3342

[16:06] <pmichaud> (talking about <leg> and <cmp>, but likely can be extrapolated to the other stringy/numeric operators)

[16:06] <tadzik> http://wklej.org/id/544696/ -- what may cause such behaviour?

[16:06] <masak> pmichaud: I agree.

[16:06] <masak> pmichaud: but (as moritz points out) we don't have lift.

[16:07] <moritz> pmichaud: I think you are interpreting too much into a detail of the spec

[16:07] <pmichaud> moritz: that's my job.  :)

[16:07] <masak> pmichaud++

[16:08] <masak> moritz: fwiw, I think pmichaud has it right.

[16:08] <pmichaud> my brain is still starting up... why is lift important here?

[16:08] <masak> tadzik: re the 'somehow' comment: you can use ::Pod6::Block::Named::$type, I think. (not implemented in Rakudo yet, though)

[16:08] <pmichaud> oh, never mind, I know why.

[16:08] <masak> tadzik: there's always eval :)

[16:08] <pmichaud> (because we need the infix:<+> of the caller context)

[16:08] <tadzik> masak: well, I think I'm waiting for the NYI thing :)

[16:08] *** mtk joined
[16:09] <pmichaud> even if we don't have lift, that's not necessarily a reason to not use prefix:<+> now, to future-proof the code a bit)

[16:09] <masak> tadzik: don't wait past the deadline :)

[16:09] <moritz> except performance, of course

[16:09] <moritz> masak: you want to call eval from within the compiler? evil!

[16:09] <tadzik> masak: oh, I'll do it anyway if it will get implemented after the deadline ;)

[16:10] <masak> tadzik: your paste... it doesn't make sense. :/

[16:10] <pmichaud> it might be worthwhile to implement 'lift' as a no-op

[16:10] *** Trashlord joined
[16:10] <tadzik> masak: yeah, that's the point of it

[16:10] <pmichaud> so that we can at least write 'lift'

[16:10] <masak> tadzik: you need to show the whole code. the most likely situation right now is that you've mis-analyzed the situation.

[16:10] <moritz> tadzik, masak: easier workaround would be a hash with type objects as values

[16:10] <tadzik> funny thing is that everything works fine, besides everything being a one-element any()

[16:10] <masak> moritz: ooh, nice.

[16:11] <masak> together, hashes and eval can do everything :P

[16:11] <tadzik> masak: http://wklej.org/id/544700/ the patch against gsocmess master

[16:11] <moritz>  /^item [\d+]?/

[16:11] <pmichaud> okay, we can stick with .Numeric for now (for performance).  maybe it's worth adding a comment in each that says   # should be "lift +$a >= +$b"   

[16:11] * jnthn back

[16:11] <tadzik> also, test: http://wklej.org/id/544701/

[16:11] <moritz> should that contain a \s* or \s+ or :s or so?

[16:12] <tadzik> moritz: I don't think so

[16:12] <tadzik> that's to catch =item, =item1, =item172 etc

[16:12] <moritz> hm, ok

[16:12] <moritz> pmichaud: I can add those comments in later, I hope

[16:16] <dalek> rakudo/nom: 53ee68f | pmichaud++ | src/core/ (2 files):

[16:16] <dalek> rakudo/nom: Make sure a List constructed from Parcel.list gets its own RPA.  Add Any.list method.

[16:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/53ee68fa08

[16:16] <dalek> rakudo/nom: 9a3e6fc | pmichaud++ | / (12 files):

[16:16] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[16:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9a3e6fc146

[16:16] <dalek> rakudo/nom: 8d79b38 | pmichaud++ | src/core/ (2 files):

[16:16] <dalek> rakudo/nom: Rat.Str method must be multi and only for defined Rats.

[16:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d79b3813d

[16:18] * jnthn wonders how hard it'd be to actually do lift.

[16:18] <tadzik> rakudo: say any(Mu).defined

[16:18] <p6eval> rakudo 4a6d21: OUTPUT¬´Bool::True‚ê§¬ª

[16:18] <tadzik> ...great

[16:19] <jnthn> tadzik: .defined is a method that Junction has

[16:19] <jnthn> It only auto-threads the ones it doesn't have.

[16:19] <tadzik> yeah, I see

[16:19] <tadzik> jnthn: have you seen this? http://wklej.org/id/544696/

[16:20] <pmichaud> tadzik: I don't see the problem (not enough context, I think)

[16:20] <TimToady> rakudo: say defined any Mu

[16:20] <p6eval> rakudo 4a6d21: OUTPUT¬´Bool::True‚ê§¬ª

[16:21] <TimToady> jnthn: why isn't that one false?

[16:21] <pmichaud> defined has a Mu parameter?

[16:21] <pmichaud> (maybe)

[16:21] <jnthn> tadzik: Looks odd

[16:21] <jnthn> TimToady: Why would it be?

[16:22] <tadzik> pmichaud: basically, the function is returning Pod6::Item, but when I assign a result to a variable, the variable is a Junction, any($result)

[16:22] <TimToady> just trying to figure out how you would workaround it

[16:22] <jnthn> TimToady: Are you expecting Junction to override .defined?

[16:22] <TimToady> I called a function, not a method

[16:22] <jnthn> TimToady: At the moment it's falling back to Mu.defined

[16:22] <jnthn> TimToady: I'd expect the defined function just delegates to the .defined method.

[16:23] <jnthn> If it's not the same thing anyway (exported multi)

[16:23] <TimToady> why does Junction need .defined?

[16:23] <pmichaud> I think it inherits it from Mu

[16:24] <jnthn> TimToady: It doesn't, it's jsut falling back to the one pmichaud mentioned.

[16:24] <TimToady> hmm

[16:24] <jnthn> And Mu.defined goes on "is this a type object or not".

[16:25] <pmichaud> jnthn:

[16:25] <pmichaud> > my @a = <red green blue>;

[16:25] <pmichaud> Cannot assign to a non-container

[16:25] <pmichaud> :(

[16:25] <jnthn> Thus why I suggested that we could define .defined differently in Junction if we want it to behave in a different way.

[16:26] <TimToady> I think having some way to autothread .defined would be nice to the poor user

[16:26] <jnthn> pmichaud: Ah, worth discussing that one...

[16:26] <TimToady> so maybe Junction's .defined should force auto-autothreading :)

[16:27] <jnthn> pmichaud: In master I think we have various overrides of infix:<=>

[16:27] <jnthn> pmichaud: e.g. to handle list assignment

[16:28] <jnthn> pmichaud: Should we have something other than the "simple case" being hit in the above example?

[16:28] <pmichaud> actually, we don't for that one.

[16:28] <jnthn> pmichaud: OK.

[16:28] <TimToady> well, it could have an override since it's officially a pseudo-assignment

[16:28] <pmichaud> the array and list case still go through the standard &infix:<=> in master

[16:28] <TimToady> even if it ends up looking a lot like ordinary assignment

[16:29] <pmichaud> I think the multis in master are fossils

[16:29] <jnthn> pmichaud: OK. I can either

[16:29] <jnthn> s/I/we/ :)

[16:30] <jnthn> 1) Make it so that anything that's not a known scalar container calls .STORE on the thingy

[16:30] <jnthn> 2) Add multi candidates

[16:30] <pmichaud> I think we still need to check rw-ness, though.

[16:30] *** kid51 joined
[16:31] <jnthn> pmichaud: That'd be Array.STORE's job, I guess?

[16:31] <pmichaud> Array.STORE knows about itself, not its container declaration

[16:31] <jnthn> pmichaud: $!descriptor

[16:31] <pmichaud> I guess it could look there

[16:31] <jnthn> pmichaud: if $!descriptor.rw { ... }

[16:32] <pmichaud> I'm not sure if it's .STORE that should check rw or &infix:<=> though.

[16:32] <jnthn> pmichaud: Not sure. Doing it in infix:<=> may be making the op know too much about the container

[16:33] <pmichaud> I'm fine with doing it in .STORE for now

[16:33] <TimToady> sounds like the declarator should be delegating to the array

[16:33] <TimToady> and introspection is almost always a smell

[16:33] <pmichaud> TimToady: it's also present in    my @a;  @a = <red green blue>

[16:33] *** hudnix joined
[16:33] <TimToady> or "extrospection" in this case

[16:33] <pmichaud> (which doesn't involve the declarator)

[16:33] <pmichaud> anyway, "delegate to the array' sounds like "let .STORE do it"

[16:34] * jnthn understood it that way

[16:34] <TimToady> k

[16:34] <pmichaud> let's go that way.  #2 definitely sounds like a rat's nest to me

[16:34] <jnthn> Trust in thy dispatcher! :P

[16:34] <jnthn> I agree it could get hairy in places though :)

[16:35] <pmichaud> it's not the dispatch, it's the candidate set that concerns me :)

[16:35] <jnthn> ah :)

[16:35] <TimToady> though most other pseudo-assignments have to rewrite the tree

[16:35] <jnthn> pmichaud: OK, I'll go twiddle.

[16:35] <pmichaud> thanks

[16:36] <pmichaud> is there a file or place where I can put "ABC needs XYZ capability" items?

[16:36] <pmichaud> or I can just mention them here :)

[16:39] <jnthn> pmichaud: Should @a = <foo bar> work once I fix this issue?

[16:39] <pmichaud> no, I'll need to update Array.STORE

[16:39] <pmichaud> well, I guess it should work since I don't check.

[16:39] <pmichaud> so, yes.

[16:39] <jnthn> pmichaud: OK, patch compiling now.

[16:40] <jnthn> pmichaud: If it's an easy case of ABC needs XYZ then LHF file is a good place.

[16:40] <jnthn> pmichaud: Otherwise mention here and/or NOMMAP

[16:40] <pmichaud> on some of them I'm not sure they're easy cases

[16:40] <jnthn> OK

[16:40] <pmichaud> sometime I probably need an explanation of how multis work in nom

[16:41] <pmichaud> the one I'm currently missing is  &block.count

[16:41] <jnthn> pmichaud: In terms of nested lexical scopes, "they don't yet" :)

[16:41] <jnthn> Ah, OK

[16:41] <jnthn> I need to do various Signature things.

[16:41] <pmichaud> no, I just mean "how are they stored"

[16:41] <jnthn> Oh

[16:41] <jnthn> Code has a $!dispatchees

[16:41] <jnthn> If it's a dispatcher then this list is the candidate list.

[16:42] <jnthn> I suspect I can use the same mechanism for wrappers.

[16:42] <pmichaud> ah, I see

[16:42] <pmichaud> so, the multi itself can have a signature, and its dispatchees also have signatures?

[16:42] <pmichaud> or something like that?

[16:43] <pmichaud> anyway, $!dispatchees was the piece I was missing.

[16:43] <pmichaud> (I saw it but didn't recognize what it meant.)

[16:43] <jnthn> pmichaud: Correct

[16:43] <jnthn> > my @x = <foo bar baz>; say @x[0]

[16:43] <jnthn> foo

[16:43] <jnthn> \o/

[16:43] <pmichaud> \o/

[16:44] <pmichaud> I'll work on Hash.STORE next.

[16:44] <pmichaud> well, I actually have a fairly long task list atm :)

[16:44] <jnthn> pmichaud: Me too!

[16:44] <jnthn> pmichaud: oh btw, last night I did...

[16:44] <jnthn> > my Int $x = 42; $x = "hi";

[16:44] <jnthn> Type check failed in assignment to '$x'; expected 'Int' but got 'Str'

[16:44] <pmichaud> \o/

[16:44] <jnthn> Better error

[16:44] <jnthn> also

[16:45] <jnthn> nom: role R1 { method m() { } }; role R2 { method m() { } }; class C does R1 does R2 { }; # if p6eval is up to date...

[16:45] <p6eval> nom: OUTPUT¬´# XXX todo role summation‚ê§current instr.: 'apply' pc 30868 (src/gen/perl6-metamodel.pir:8635)‚ê§¬ª

[16:45] <jnthn> darn, it's not

[16:46] <jnthn> > role R1 { method m() { } }; role R2 { method m() { } }; class C does R1 does R2 { };

[16:46] <jnthn> Method 'm' must be resolved by class 'C' because it exists in multiple roles (R2, R1)

[16:46] <jnthn> It lists the class name and the names of the roles the method came from :)

[16:46] <pmichaud> excellent

[16:46] <jnthn> Errors. I improves them.

[16:46] <tadzik> I miss a git feature to commit a few lines of changes :)

[16:46] <pmichaud> jnthn: http://gist.github.com/1020741   # can I apply this to start working on gather/take ?

[16:47] <jnthn> looking

[16:47] <dalek> rakudo/nom: 0cb7000 | jnthn++ | src/binder/container.c:

[16:47] <dalek> rakudo/nom: Fix up container store handling (pmichaud++).

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cb7000502

[16:47] <pmichaud> master's gather/take implementation uses   .yield   (and I don't have another idea how to handle it in nom yet)

[16:47] <jnthn> pmichaud: That patch doesn't look problematic to me.

[16:48] <pmichaud> I didn't think it would be.  My preliminary code for gather/take looks awfully funky, though -- grabbing things out of the $!do property :-P

[16:48] <pmichaud> (funky but not long or too complex)

[16:48] <jnthn> :)

[16:49] <jnthn> I thought I added a .do method...

[16:49] <pmichaud> I suspect we'll need to revisit gather/take at some point, especially as we target other VMs, but this will get us going

[16:49] <pmichaud> oh, perhaps you did

[16:49] <pmichaud> I didn't look for one

[16:49] * jnthn czechs

[16:49] <pmichaud> ("TimToady slovaks"  :-)

[16:50] <jnthn> :D

[16:50] <TimToady> .oO(equal time)

[16:50] <jnthn> pmichaud: No, I didn't.

[16:50] <jnthn> Well, what you have is probably faster anyway :)

[16:50] <pmichaud> a "do" method could be handy, but I also don't mind grabbing the attribute

[16:50] <pmichaud> "do" might be tricky since what it returns isn't a 6model object

[16:50] <jnthn> I'm a little scared of what happens if we let the Parrot sub escape the Code object :)

[16:51] <pmichaud> exactly

[16:51] <jnthn> Do maybe it's best if only trusted things can do taht.

[16:51] <jnthn> *that

[16:51] *** thou left
[16:51] <jnthn> Giving people a method that'll just result in "OMG it exploded!!!" rakudobugs is probably not so valuable... :)

[16:51] <pmichaud> right, or we shouldn't make it easy for people t.... right

[16:51] <pmichaud> if you're mucking around with $!do, you should know what you're doing.  :)

[16:52] <TimToady> .oO(use MONKEY_SEE_MONKEY_DO)

[16:52] <tadzik> <.a> means "<a> but don't call an action method"?

[16:52] <jnthn> .oO( know what you're $!doing )

[16:52] *** thou joined
[16:52] <jnthn> tadzik: No

[16:52] *** thou left
[16:52] <jnthn> tadzik: It means "don't caeate a named capture"

[16:52] <pmichaud> action methods are always called

[16:52] <jnthn> *create

[16:52] <tadzik> okay I see

[16:53] <jnthn> pmichaud: Any particular "XYZ needs ABCs" that you're liable to block on soon?

[16:53] * TimToady should work on one of his other five full-time jobs, sigh...

[16:53] <pmichaud> &block.count was one... but I might be able to implement that one

[16:53] <jnthn> pmichaud: Ah, I can take that one.

[16:53] <jnthn> pmichaud: I need to do some other bits in that area to unbust multi error reporting anyway.

[16:54] <jnthn> We could kinda do with it to work.

[16:54] <pmichaud> jnthn: I'll let you do it then.  I don't mind implementing some of these so I can become familiar with the internals

[16:54] <pmichaud> but this one isn't terribly important at the moment

[16:54] <jnthn> *nod*

[16:54] <jnthn> The roles are coming on quite well. I've done the first 80% and have the other 80% left.

[16:55] <pmichaud> oh, I noticed that perl6_current_args_rpa op includes the invocant if used within a method

[16:55] <jnthn> Yes, it will

[16:55] <pmichaud> that's not necessarily a problem... just something a method writer has to be aware of if using it

[16:55] <jnthn> Since the invocant is just an argument.

[16:55] <jnthn> Well, it's only for limited, guts-y usage, I hope. :)

[16:55] <pmichaud> agreed

[16:55] <pmichaud> and I simply shifted the invocant off of the RPA in the case where I chea.... used it.

[16:55] <jnthn> Fixing it would be harder than ignoring the first arg.

[16:56] <jnthn> er, I mean, taking off the first one

[16:56] <jnthn> Though it's not so performant I guess...

[16:56] <pmichaud> it's no problem

[16:56] <pmichaud> I just wanted to make sure the current implementation with your expectations for it (and it sounds like it is)

[16:56] <jnthn> The best way if we want performance is to add a second version of the op that drops the first arg.

[16:56] <pmichaud> "current implementation is concistent"

[16:56] <pmichaud> *consistent

[16:56] <pmichaud> pir::shift isn't that expensive

[16:56] <jnthn> er

[16:56] <jnthn> :)

[16:57] <jnthn> Oh, it's unshift that mallocs every time.

[16:57] <pmichaud> right

[16:57] <jnthn> shift "just" memcpys... 

[16:57] <jnthn> Anyway, at this point it'd be a micro-optimization.

[16:58] <pmichaud> do we have private methods yet?

[16:58] <pmichaud> or submethods?

[16:58] <jnthn> No

[16:58] <jnthn> No

[16:58] <jnthn> I think private methods need to look very different than we're traditionally done them anyway

[16:58] <jnthn> And we kinda need to implement trusts.

[16:59] <jnthn> So I put them off for now.

[16:59] <jnthn> Do you need them?

[16:59] <jnthn> Submethods are an easier ask.

[16:59] <pmichaud> well, I can continue to do ALL_CAPS for private methods for now

[16:59] <jnthn> THAT'LL BE FINE.

[16:59] <pmichaud> so I don't really *need* them

[16:59] <jnthn> :)

[17:00] <jnthn> OK, we can just grep for method [A-Z] later :)

[17:00] <pmichaud> there are some places where submethods would be useful

[17:00] <jnthn> OK

[17:00] <pmichaud> but it's not a high priority

[17:00] <pmichaud> let me see what's in NOMMAP and see if I can use that for a list of "things I've come across that I said 'gee I wish that was available now'"  :-)

[17:00] * jnthn puts submethods on his "todo soon" list

[17:00] <jnthn> sure

[17:01] <pmichaud> oh, "our" is very high on the list.

[17:01] <jnthn> In theory that'll be easy.

[17:01] <tadzik> oh, first S26 bug foung :)

[17:01] <pmichaud> either that or we should change t/00-parrot  to use 'my' instead of 'our'

[17:01] <tadzik> erm, found

[17:01] <pmichaud> so we can start passing those tests

[17:01] <jnthn> pmichaud: I'll do our.

[17:01] <jnthn> I cna do "our" and submethods later today.

[17:02] <pmichaud> I think I might want to create src/core/cheats.pm

[17:03] <jnthn> ohnoes :)

[17:03] <pmichaud> as a place where we can put cheating operators

[17:03] <jnthn> OK

[17:03] <pmichaud> e.g., some of the metaops might go there temporarily until we have them working

[17:03] <jnthn> How much do we want lift?

[17:03] <pmichaud> we've lived without 'lift' for quite a while, so it's not a huge priority for me

[17:03] <jnthn> OK

[17:03] <pmichaud> if we had a dummy 'lift' it might be nice, though, so we could future-proof some of the operators

[17:04] <moritz> jnthn: I'd like to change Real and Numeric to be roles... should I update BOOTSTRAP.pm with something like  Real.HOW.add_role(Real, Numeric)?

[17:04] <moritz> instead of add_parent

[17:04] <jnthn> moritz: Not yet

[17:04] <jnthn> moritz: I think Real and Numeric themselves have been defined in BOOTSTRAP

[17:05] <pmichaud> will we just be able to define Real and Numeric in src/core/Real.pm anyway?

[17:05] <dalek> specs: 19a64f5 | tadzik++ | S26-documentation.pod:

[17:05] <dalek> specs: [S26] Fix an example in List section

[17:05] <dalek> specs: review: https://github.com/perl6/specs/commit/19a64f5347

[17:05] <pmichaud> (and src/core/Numeric.pm)

[17:05] <jnthn> Which is...sorta OKish...for classes but maybe a bit hairy for roles.

[17:05] <pmichaud> as opposed to defining them in BOOTSTRAP?

[17:05] <jnthn> pmichaud: Yeah, probably

[17:05] <jnthn> pmichaud: That's what I want

[17:05] <moritz> I'll try that

[17:05] <pmichaud> me tooo.

[17:05] <jnthn> But I didn't implement type checking against roles yet

[17:05] <jnthn> So any place you use Real and Numeric in a multi-dispatch at the moment will be FAIL.

[17:05] <moritz> oh, so I'd better way

[17:06] <jnthn> moritz: Right, thus "not yet" :)

[17:06] <pmichaud> moritz: for now, you could do  "role MyReal { ... }"

[17:06] <jnthn> moritz: I wasn't just spoiling the fun ;-)

[17:06] <pmichaud> and then test it with  "class Int does MyReal { ... }"

[17:06] <moritz> it's not a pressing issue

[17:06] <pmichaud> and when it works, then it's safe to migrate Numeric/Real from BOOTSTRAP

[17:06] <jnthn> I'll put in at least that much of the type checking soon.

[17:07] <jnthn> I just don't want to cause problems for folks hacking on setting stuff with a roles implementation that's not quite there yet. :)

[17:07] <pmichaud> .oO("problems for folks hacking on setting with other pieces that aren't quite there yet is okay, however."  :-)

[17:07] <moritz> btw for BackTrace I'll need to access interp["annotations"; level] - is that syntax accessible with pir:: things?

[17:08] <pmichaud> nope... have to use Q:PIR for that

[17:08] <jnthn> eww, two level keys

[17:08] <jnthn> pmichaud is, sadly, correct.

[17:09] <pmichaud> it's another place where pir syntax doesn't lend itself to hll-like handling

[17:10] <pmichaud> I have been thinking about adding a pir::const:: namespace, though, for things like  pir::const::CONTROL_RETURN

[17:12] <jnthn> rakudo: say Submethod ~~ Method

[17:12] <p6eval> rakudo 4a6d21: OUTPUT¬´Bool::False‚ê§¬ª

[17:12] <jnthn> rakudo: say Submethod ~~ Routine

[17:12] <p6eval> rakudo 4a6d21: OUTPUT¬´Bool::True‚ê§¬ª

[17:13] <pmichaud> or maybe it really wants to be   pir::const<CONTROL_RETURN>

[17:14] <pmichaud> a hash with the parrot constants already defined could be reallllllly handy

[17:14] <pmichaud> instead of doing the Q:PIR { .include 'whatever.pasm' } trick all over the place

[17:14] <jnthn> ooh, yes

[17:14] <moritz> agreed

[17:14] <pmichaud> maybe %pir::const<CONTROL_RETURN> then

[17:16] <JimmyZ> pir::%const<CONTROL_RETURN>

[17:16] <pmichaud> %pir::defines<CONTROL_RETURN>   # better, maybe?

[17:16] <pmichaud> JimmyZ: that's not really good syntax for p6

[17:17] <pmichaud> bbiab

[17:17] * JimmyZ sleeps

[17:18] <moritz> crontab for p6eval nom rebuild installed

[17:18] <jnthn> nom will be served regularly!

[17:18] <moritz> nom: say '\o/'

[17:18] <p6eval> nom: OUTPUT¬´\o/‚ê§¬ª

[17:19] *** JimmyZ left
[17:20] <masak> nom: say 'nom: say \'nom\''

[17:20] <p6eval> nom: OUTPUT¬´nom: say 'nom'‚ê§¬ª

[17:20] <masak> \o/

[17:21] <moritz> any nom LHFs?

[17:21] * moritz doesn't feel ready yet to attack CalLFrame and BackTrace

[17:22] <moritz> hm, maybe more Rat ops

[17:23] <tadzik> gsocmess now has lists

[17:24] <tadzik> now the hard part: implicit code blocks

[17:24] <jnthn> moritz: Could start to put Complex back too

[17:26] <moritz> come to think of it, there are probably lots of mostly-LHF options

[17:27] <jnthn> moritz: Feel free to put ideas on the LHF list also

[17:34] <pmichaud> actually, I think I'll do both %pir::const<NAME> and pir::const::NAME.  The former will be a runtime lookup while the latter will be a compile-time constant value.

[17:34] <dalek> rakudo/nom: 5ed4f6a | moritz++ | LHF.markdown:

[17:34] <dalek> rakudo/nom: new LHFs: Rat operators and Complex

[17:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ed4f6aaa5

[17:34] <dalek> rakudo/nom: 39b7782 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[17:34] <dalek> rakudo/nom: Add Submethod type.

[17:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39b778245b

[17:34] <dalek> rakudo/nom: f4bb33f | jnthn++ | src/Perl6/Metamodel/ClassHOW.pm:

[17:34] <dalek> rakudo/nom: Update ClassHOW.find_method and method dispatch cache generation to know about submethods; they now work.

[17:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4bb33fc89

[17:34] <dalek> rakudo/nom: 275ab3d | jnthn++ | src/Perl6/Metamodel/MethodContainer.pm:

[17:34] <dalek> rakudo/nom: Implement submethod handling in MethodContainer role (so it's available to all HOWs that do that role).

[17:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/275ab3ddac

[17:34] <jnthn> huh, out of order commit reporting.

[17:34] <pmichaud> "order" sometimes doesn't mean what you think it does in git.  :)

[17:35] <jnthn> ;)

[17:35] <pmichaud> it's like "Perl 6 has no 'length'"

[17:35] * jnthn is quite liking having the metamodel factored in terms of roles :)

[17:35] *** Mowah left
[17:36] <moritz> actually it's more like "Perl 6 has no SUPER" :-)

[17:37] <jnthn> pmichaud: I guess slurpies are possible now?

[17:38] <pmichaud> jnthn: should be possible, yes

[17:38] <jnthn> k

[17:39] <dalek> rakudo/nom: d9dd006 | moritz++ | src/ (3 files):

[17:39] <dalek> rakudo/nom: add lcm and gcd infix ops

[17:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9dd006d9f

[17:39] <pmichaud> we can hotpath it a bit later, but simplest might be to invoke  &infix:<,>() on the slurpy args, invoke ".list" on that, and bind the slurpy parameter to the resulting list

[17:39] <TimToady> would have to be pir::<%const> to be good p6

[17:40] <jnthn> pmichaud: sub foo(*@a) { @a.WHAT.say } # Array?

[17:40] <pmichaud> or, you can just create a List object and bind $!rest to the slurpy arg rpa

[17:40] <jnthn> Or List?

[17:41] <pmichaud> jnthn: I'm not sure it's an Array there.... I don't remember getting a ruling on whether one can modify the arguments via the slurpy

[17:41] *** mj41 joined
[17:41] <jnthn> pmichaud: Can do List for now. Like the "bind to $!rest" much better

[17:41] <TimToady> it's at least erroneous to assume one can

[17:41] <pmichaud> you can go ahead and make it an Array for now (that's what master does)

[17:41] <jnthn> pmichaud: $!rest is an RPA?

[17:41] <pmichaud> $!rest is an RPA, yes.

[17:41] <jnthn> Excellent.

[17:41] <pmichaud> you can do the same for Array, too

[17:41] <pmichaud> (since Array is List)

[17:42] <pmichaud> create an Array, bind the RPA to $!rest

[17:42] <jnthn> pmichaud: Given what TimToady just mentioned, List is better?

[17:42] <jnthn> Or did I misunderstand it?

[17:42] <pmichaud> given what TimToady just said, Array is better

[17:42] <jnthn> oh, OK :)

[17:42] * jnthn is still a bit confused ;)

[17:42] <pmichaud> (List has references to the containers used to create it, Array has its own containers)

[17:42] <jnthn> ah, got it.

[17:43] <pmichaud> I suppose one could say that    *@slurpy is rw    implies access to the original arguments

[17:43] <pmichaud> anyway, we'll do it as Array for now :)

[17:43] *** thou joined
[17:44] <jnthn> pmichaud: ooc, is .count and/or .arity a hot path?

[17:44] <pmichaud> not really

[17:44] <jnthn> OK

[17:44] <pmichaud> at least, not for the stuff I'm doing

[17:44] <jnthn> I won't premature opt them then :)

[17:57] <pmichaud> when you're at a good point for discussion, maybe we can talk about bigint/num handling a bit :)

[17:58] <pmichaud> I'm thinking maybe we want a    perl6_box_bigint__PN() opcode

[17:58] <pmichaud> which gives back an Int if the argument is in range, a Num otherwise

[17:58] <moritz> should I put the Rat operators into operators.pm or Rat.pm?

[17:58] <pmichaud> moritz: I tend to prefer that the operators go with their types

[17:58] <pmichaud> but I'm open to other interpretations

[17:58] <moritz> pmichaud: then we are d'accord

[17:59] <pmichaud> by the same reasoning, I think the string operators ought to go in Str.pm

[17:59] <pmichaud> or Stringy.pm, maybe

[18:00] <pmichaud> jnthn: unless you have other ideas about how we want to do large ints for the short-medium future

[18:00] <dalek> rakudo/nom: 7b6794e | moritz++ | src/core/Rat.pm:

[18:00] <dalek> rakudo/nom: normalize Rats

[18:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7b6794e9ce

[18:03] <pmichaud> basically, an opcode form of our "upgrade_to_num_if_needed" function in master

[18:03] <jnthn> pmichaud: Yeah, I hate having that function everywhere...

[18:03] <pmichaud> then we'd define

[18:03] <jnthn> pmichaud: I forget how it works... :)

[18:03] <pmichaud> sub infix:<+>(Int \$a, Int \$b) {

[18:04] *** lateau left
[18:04] <pmichaud>     perl6::perl6_box_bigint__PN(

[18:04] <pmichaud>     pir::add__NII(pir::repr_unbox_int__IP($a), pir::repr_unbox_int__IP($b)))

[18:04] <pmichaud> }

[18:05] <pmichaud> and perl6_box_bigint gives back Num/Int as appropriate

[18:05] * jnthn gets a REALLY bad feeling about upgraidng to Num...

[18:05] <pmichaud> the alternative is to limit all of our programs to int ranges

[18:05] <pmichaud> or to solve the bigint problem overall

[18:05] *** mj41 left
[18:05] <jnthn> We can't inline any of the integer operations if we do this

[18:05] <jnthn> Well, we can

[18:05] <jnthn> But we can't depend on the return type

[18:05] <pmichaud> as I said, "short-medium future"

[18:06] <jnthn> Yeah, but the optimizer is short-medium future too... :)

[18:06] <jnthn> Well, medium :)

[18:06] <pmichaud> I don't think we can limit the ranges of our ints

[18:06] <jnthn> I'm not sure what best thing to do is here.

[18:06] <pmichaud> that's always one of the first things that people use/test/discover

[18:06] <jnthn> Well, upgrading to Num is only so much better. It bites eventually.

[18:06] <jnthn> What're our bigint options?

[18:07] <pmichaud> I don't know... probably need a way to store bigints in an Int

[18:07] <jnthn> Yeah, I meant more actually doing the operations.

[18:07] <jnthn> Library wise.

[18:07] <pmichaud> oh, I think it should be libgmp

[18:08] <jnthn> My preference: we pick one we can bundle a copy of in nqp or Rakudo repo.

[18:08] <jnthn> So we don't ahve to play silly dependency games.

[18:08] <jnthn> ICU is already bad enough.

[18:08] <pmichaud> I think the challenge with libgmp has to do with macos or something

[18:08] <pmichaud> at least, according to colomon++

[18:08] *** mj41 joined
[18:09] <pmichaud> we should probably get colomon and sorear involved in the discussion for ideas (more)

[18:09] <jnthn> pmichaud: I was pondering integrating it at the NQP level and providing a set of ops and a repr.

[18:09] <pmichaud> NQP level I agree with, fully.

[18:11] <pmichaud> here's my proposal:  short-term let's do the upgrade-to-num approach, so we can pass tests.  when you reach the point of inlining optimizations (medium-term), I won't be strongly opposed to ripping out the Num upgrade if we have to do that and don't have another bigint replacement

[18:11] <pmichaud> i.e., I don't mind if we regress on bigint capability in the name of performance

[18:12] <jnthn> +1

[18:12] * TimToady has mixed feelings...

[18:12] <pmichaud> TimToady: so do we all, I think :)

[18:13] <jnthn> :)

[18:13] * jnthn wants to do bigint properly in the not too distant future

[18:13] <jnthn> And I'd rather do it in a way that fits well with 6model

[18:13] <masak> +1

[18:13] <pmichaud> I'm fully in favor of "bigint properly"... I'm just worried about "not to distant future" being a bigint :)

[18:13] <jnthn> :P

[18:14] <pmichaud> *too

[18:14] * moritz is more worried about nom landing than getting bigint soon

[18:14] * TimToady wants int to be fast and Int to be correct

[18:14] <masak> there are small bigints too :)

[18:14] <jnthn> TimToady: +1

[18:14] <jnthn> pmichaud: I suspect it needn't be too far into the future.

[18:14] <pmichaud> we also need Int to be fast, too, though

[18:14] <masak> of all the things nom could regress on, bigint support is not one that concerns me.

[18:14] <masak> ...much.

[18:15] <masak> ss/concerns me/has me concerned/

[18:15] <jnthn> pmichaud: I mean, after nom lands, for sure.

[18:15] <pmichaud> right

[18:15] <moritz> especially since it's only bigishint that it regresses on

[18:15] <TimToady> but it's harder to make ref types as fast as value types, and it's hard to do variable-sized value types...

[18:16] <moritz> t/00-parrot/03-op-logic.t has regressed (Null PMC access in get_bool() after test 5)

[18:16] <pmichaud> from a perception perspective, having overflow errors on Int types (when we don't have them in master) is probably not going to work out initially

[18:16] <pmichaud> but if we say we're eliminating them in the name of performance, I think that flies.

[18:16] <jnthn> moritz: It's because the 1.Bool got removed from say and print :(

[18:17] <jnthn> So now it returns a null PMC.

[18:17] <pmichaud> oh!

[18:17] <pmichaud> oops

[18:17] <jnthn> pmichaud: oh, it was you :P

[18:17] * pmichaud fixes.

[18:17] <jnthn> :)

[18:17] <tadzik> speaking of gmp, libgmp is currently being worked on in Parrot, a gsoc task

[18:17] <jnthn> tadzik: I doubt that'll look how I want it to for 6model.

[18:17] <pmichaud> tadzik: yes, I'm eagerly awaiting the results.  I'm worried that it might not address the problem(s) colomon++ was citing

[18:17] <jnthn> *that's

[18:17] <tadzik> I see

[18:18] *** kid51 left
[18:21] <jnthn> oh no...dalek?!

[18:21] <jnthn> No karma!

[18:25] *** dalek joined
[18:25] *** ChanServ sets mode: +v dalek

[18:27] *** mj41 left
[18:27] <moritz> nom: die 'OH NOEZ'

[18:29] <jnthn> nom: 'there?'

[18:29] <jnthn> Hm

[18:29] <jnthn> moritz: I'm pretty sure we can't die yet

[18:30] <moritz> seems I've killed it

[18:30] <tadzik> but it can't die yet

[18:30] <p6eval> nom: OUTPUT¬´Can only use get_who on a SixModelObject‚ê§current instr.: '_block13' pc 28 ((file unknown):0) (:1)‚ê§¬ª

[18:30] <p6eval> nom:  ( no output )

[18:31] <moritz> ah, the good old get_who

[18:34] <pmichaud> jnthn: any objections to me having HLL::Compiler automatically put .include lines at the beginning of every .pir file it generates?

[18:34] <pmichaud> (for the .pasm constants)

[18:35] <pmichaud> and if that's okay, which .pasm's do we want to have included?

[18:36] <jnthn> pmichaud: Sounds sane enough.

[18:36] <jnthn> pmichaud: I'm guessing exception severity 

[18:36] <jnthn> And exception type

[18:36] <pmichaud> I guess I could just grep on include and see which ones we currently use :)

[18:37] <jnthn> heh :)

[18:39] <pmichaud> http://gist.github.com/1020824   # list of files in nqp

[18:39] <pmichaud> seems pretty innocuous to just include those four always

[18:39] *** Shozan left
[18:39] <pmichaud> http://gist.github.com/1020825  # includes from master

[18:40] <pmichaud> I think I'll do that, then add pir::const::SOMETHING  which will put a symbolic constant into the output pir

[18:42] <jnthn> pmichaud: the nqp list, or the master list?

[18:42] <pmichaud> union of both

[18:42] <pmichaud> it's only about six includes

[18:42] <jnthn> OK

[18:44] *** TBA2 joined
[18:45] <TBA2> hi everyone, anyone know if theres any problems with %*ENV in rakudo? (2001.05-15, parrot 3.4.0)

[18:45] <TBA2> get this when trying to iterate over it: Method 'key' not found for invocant of class 'String'

[18:45] <TBA2>   in <anon> at line 5360:CORE.setting

[18:45] <TBA2>   in main program body at line 1

[18:46] <masak> rakudo: .say for keys %*ENV

[18:46] *** buubot_backup left
[18:46] <flussence> p6eval's pretty slow today...

[18:46] <masak> seems so.

[18:47] <masak> TBA2: could you nopaste your code somewhere?

[18:47] <flussence> ...but he's right, it does that for me

[18:47] <TBA2> .say for keys %*ENV does it to, thats the only line in the file :)

[18:47] <pmichaud> pmichaud@kiwi:/zip/perl/rakudo-2011.05$ ./perl6

[18:47] <pmichaud> > .say for keys %*ENV

[18:47] <pmichaud> Method 'key' not found for invocant of class 'String'

[18:47] <moritz> TBA2: it's a known limitation of parrot's Env PMC that you can't iterate over it

[18:47] <moritz> TBA2: sadly rakudo inherits that limitation

[18:47] <TBA2> moritz: any way to dump it out to see its contents? or can we only access elements directly?

[18:48] *** dalek left
[18:48] <pmichaud> ...we're not doing the %*ENV shadowing?  alpha did that.

[18:48] <masak> TBA2: does this sound familiar? http://rt.perl.org/rt3/Ticket/Display.html?id=80450

[18:48] *** p6eval left
[18:48] *** p6eval joined
[18:48] <TBA2> masak: yep thats it

[18:48] *** ChanServ sets mode: +v p6eval

[18:49] <masak> we've reduced the problem to a known RT ticket. :)

[18:49] <pmichaud> we'll undoubtedly have to do the shadowing again in nom, since we don't support Parrot native hashes anyway

[18:49] <TBA2> :) at least its not me thinking i've got my syntax wrong hehe

[18:50] <jnthn> pmichaud: In nom I suggest we do it with a custom container with STORE/FETCH that DTRT

[18:50] <pmichaud> jnthn: it'd have to have custom Scalars too, then

[18:50] <pmichaud> %*ENV<abc> = 'foo';   # not a Hash.STORE

[18:51] <jnthn> pmichaud: Yes, ti's the customer scalars I was thinking of :)

[18:51] <jnthn> pmichaud: Though now you mention it, we need custom hash too :)

[18:51] <jnthn> Or some help from the hash.

[18:51] <pmichaud> it could have Scalars with a $!whence value set... in which case $!whence means "upon assignment" instead of "upon vivification"

[18:51] <jnthn> Hm

[18:51] <jnthn> Not sure that'll work out too well.

[18:52] <pmichaud> I think the shadowing approach is *much* easier, fwiw

[18:52] <jnthn> pmichaud: "shadowing"?

[18:52] *** dalek joined
[18:52] *** ChanServ sets mode: +v dalek

[18:52] <pmichaud> we have a (nom) hash that holds the environment, it then updates the true environment when something "interesting" happens

[18:53] <pmichaud> (e.g., fork() or exec())

[18:54] *** p6eval left
[18:54] <pmichaud> this actually works out nicely in case someone does    my %*ENV = ...;   run('....')

[18:54] *** dalek left
[18:54] <pmichaud> (assuming that's possible)

[18:55] <jnthn> ah, true

[18:55] <jnthn> brb, dinner

[18:56] *** p6eval joined
[18:56] *** ChanServ sets mode: +v p6eval

[18:57] <TBA2> so does any of %*ENV work yet? can't seem to access any elements in it either (but perhaps i'm mistakingly assuming things like user etc will be set?)

[18:57] <masak> TBA2: you could check instead of asking, you know :P

[18:57] <masak> (don't want to discourage asking, but checking before is pretty nice, too)

[18:58] <TBA2> masak: i'm trying, but not really sure where else to start, nothing i do with %*ENV seems to work without error and not a clue where to start in the parrot/rakudo source yet :/

[18:59] <masak> TBA2: %*ENV corresponds to the things you get when typing 'env' on the command line.

[18:59] <masak> that's one way to check.

[18:59] <sorear> good * #perl6

[18:59] <masak> o/ sorear 

[18:59] <TBA2> tried that, but none of the entries listed by env appear to exist in the hash

[19:00] <TBA2> ah now i'm getting somewhere

[19:01] <TBA2> masak: thanks :)

[19:01] <masak> np

[19:01] *** dalek joined
[19:01] *** ChanServ sets mode: +v dalek

[19:01] <masak> The hardest thing to realize is often that there is a box outside of which one should think. :P

[19:02] <TBA2> i've found the box, just struggling with the way out ;p

[19:02] <masak> ;p

[19:05] *** buubot_backup joined
[19:06] *** dalek left
[19:06] <sorear> pmichaud: hi

[19:06] *** TBA2 left
[19:07] *** fish|ipad joined
[19:07] *** fish|ipad left
[19:07] *** fish|ipad joined
[19:08] <sorear> pmichaud: may I have some of your time?  I'm trying to understand why 'if 1 { my $x; class A { method b() { $x = 5 }; }; A.b; say $x }' works in nom

[19:08] *** dalek joined
[19:08] *** ChanServ sets mode: +v dalek

[19:25] *** dalek left
[19:31] <pmichaud> sorear: sorry, had window minimized...

[19:31] <pmichaud> jnthn might be the person to ask about it....

[19:32] <sorear> pmichaud: jnthn told me he had mostly no clue how it worked and said you would know

[19:32] <sorear> apparently you wrote NQPLexPad or something

[19:32] <pmichaud> I definitely didn't write NQPLexPad

[19:33] <sorear> *blink*

[19:33] <masak> emergent software! :D

[19:33] <sorear> Rakudo is starting to write itself, I guess :D

[19:34] <pmichaud> I don't even know where NQPLexPad is to be able to tell you who did :)

[19:34] <sorear> $NQP/src/pmc/nqplexpad.pmc

[19:34] <pmichaud> https://github.com/perl6/nqp/blame/72272904edacd50d7a5c7f347b761bbe6a513bd5/src/pmc/nqplexpad.pmc

[19:34] <pmichaud> wasn't me :)

[19:34] <masak> pmichaud: no, jnthn said you wrote the code that makes sure classes are lexically captured.

[19:35] <masak> is that the code that contains nasty Parrot-level re-linking of OUTER pointers?

[19:35] <sorear> masak: do you know where that code lives?

[19:35] <jnthn> pmichaud: I think sorear is missing an explanation of when we capture_lex or take closures

[19:35] <pmichaud> we capture_lex at the beginning of every block

[19:35] <jnthn> pmichaud: And how the capture_lex'ing makes the example he mentioned works.

[19:36] <jnthn> pmichaud: all the nested blocks, yes?

[19:36] <pmichaud> all of the first-level nested blocks

[19:37] <jnthn> sorear: I think the think you're asking about works in master also

[19:37] <sorear> jnthn: master cheats, HARD

[19:37] <jnthn> sorear: Are you asking about it in nom specifically, or just in Rakudo general?

[19:37] *** dalek joined
[19:37] *** ChanServ sets mode: +v dalek

[19:37] <sorear> nom/nqp general

[19:37] *** p6eval left
[19:37] <jnthn> sorear: I don't see the code generation we do that much differently though

[19:38] <pmichaud> I suspect that the difference here is that nom/nqp have static lexpads, whereas master doesn't

[19:38] <pmichaud> anyway, here's my guess

[19:38] <jnthn> True, though the block capturing doesn't play into the static lexpads.

[19:39] <pmichaud> when we execute the "if 1" block, that creates a $x and capture_lex's the "class A" block

[19:39] <pmichaud> we then execute the "class A" block (is that right?)

[19:39] <sorear> the block capturing is sufficient to explain this

[19:39] <sorear> yes

[19:39] <pmichaud> invoking the "class A" block does a capture lex on the method b block

[19:39] <sorear> class blocks are executed as if they were bare blocks, in addition to compile-time classmaking

[19:39] <pmichaud> thus when b is invoked, it's referencing the "my $x" that was established by the "if 1"

[19:40] *** dalek left
[19:41] <sorear> stefan@stefans:~/dl/rakudo$ install/bin/perl6 -e 'my $x; if 0 { class A { method b() { $x = 5 }; }; }; ::A.b; say $x'                                           

[19:41] <sorear> 5

[19:41] <sorear> with the "if 0", the method is never capture_lex'd, is it?

[19:41] <pmichaud> no, so I suspect it autocloses

[19:41] <sorear> so... shouldn't it be writing to the static lexpad version of $x?

[19:42] <pmichaud> master doesn't have "static lexpads"

[19:42] <jnthn> Nor does nom in that sense

[19:42] <sorear> I'm not touching master at all

[19:42] *** p6eval joined
[19:42] *** ChanServ sets mode: +v p6eval

[19:43] <jnthn> It builds lexpads for the blcoks until it finds one that has already been invoked (if at all), then stops

[19:43] <jnthn> In this case, it finds the $x 

[19:43] <jnthn> er, the pad with $x

[19:44] <sorear> I don't follow.  What do you mean, it finds the $x?  Doesn't $x creation have to wait until runtime?

[19:45] *** dalek joined
[19:45] *** ChanServ sets mode: +v dalek

[19:45] <pmichaud> when you invoke b, it says "oh, wait!  I haven't been capture_lex'd.  I'll just go ahead and capture my OUTER's current pad"

[19:45] <pmichaud> it's outer says "oh wait!  I haven't been capture_lex'd!  I'll just go ahead and capture my OUTER's current pad"

[19:45] <pmichaud> etc.

[19:46] <pmichaud> so eventually it gets to the pad that has been capture_lexed (the if 0 block) and we've established the outer chain

[19:46] <pmichaud> that's "autoclose"  (which is still somewhat controversial)

[19:46] *** lichtkind left
[19:47] *** envi_laptop left
[19:47] *** thou left
[19:48] *** dalek left
[19:48] *** dalek joined
[19:48] *** ChanServ sets mode: +v dalek

[19:48] <pmichaud> I didn't say all of that precisely correct, but that's the general idea.  When a block that hasn't been capture_lex'd gets invoked, it and its outer-parents look up the outer-chain to find a sub with an active lexpad and they close on that (creating dummy lexpads as needed in the process)

[19:49] <sorear> pmichaud: How does that interact with static lexpads?  I would have thought that "class A" already would be bound to a lexpad (the static one)

[19:50] <pmichaud> parrot doesn't really have static lexpads, iiuc

[19:50] <jnthn> The only thing I really say changing with static lexpads is s/creating dummy lexpads/using the static lexpad/

[19:50] <masak> what are un-static lexpads called?

[19:51] <pmichaud> anyway, I don't know about "class A" being bound at that point.  It's not been invoked.

[19:51] <sorear> jnthn: EAMBIGUOUS "say changing"

[19:51] *** dalek left
[19:51] <jnthn> s/say/see/ :)

[19:51] <sorear> pmichaud: I thought that, with static lexpads, all subs would be bound to the static lexpad before being cloned/capture_lexed

[19:51] <jnthn> If Parrot had a way to notify me it was in autoclose mode rather tha normal lexpad creating mode I'd probably have already done that.

[19:52] *** ggoebel left
[19:52] *** ggoebel joined
[19:53] *** p6eval left
[19:54] *** p6eval joined
[19:54] *** ChanServ sets mode: +v p6eval

[19:54] <pmichaud> sorear: I don't know the answer to that.  IIRC the spec is largely silent on the subject of static pads

[19:55] <pmichaud> and handwavy on other aspects

[19:56] <tadzik> I feel that spec is a bit too general on how implicit code blocks are handled

[19:57] <tadzik> for example, it says that a paragraph is a code block if it's indented more that its virtual left margin. Now S26:872 surely doesn't want the first paragraph to be a code block (or does it?), but the definition of the virtual left margin makes me think it should be treated as such

[19:58] <sorear> pmichaud: I spent an hour or two 2 days ago talking with jjore and getting an understanding of how Perl 5 handles this stuff, btw

[19:58] <pmichaud> sorear: yeah, chromatic++ gave me a similar lesson once

[19:59] <jnthn> errand, back in 30 mins or so

[19:59] <sorear> pmichaud: did he say anything about it being related to autoclose?

[20:00] <pmichaud> well, our discussion was comparing Perl 5's approach to Parrot's approach

[20:04] *** mj41 joined
[20:05] <tadzik> is @p6l a good place to ask about possible unclarity of the spec?

[20:05] <sorear> only if you want its complexity to be doubled

[20:05] <masak> :)

[20:05] <masak> sometimes one gets good suggestions from p6l.

[20:06] <tadzik> that's why I wanted to ask first :)

[20:06] <masak> tadzik: if the question is the above, I'd consider the probability low that you'll come out wiser from mailing p6l.

[20:07] <masak> tadzik: sounds more like a mis-stated part of S26 that you could fix using some good judgment.

[20:07] <tadzik> without mailing p6l I guess? :)

[20:07] <pmichaud> forgiveness > permission

[20:07] <tadzik> I'm more afraid that about TheDamian's angry look when he sees me on YAPC::EU :P

[20:08] *** dalek joined
[20:08] *** ChanServ sets mode: +v dalek

[20:09] <tadzik> plus I have no good idea about how it should be. Spec indents paragraphs all the time, and according to the spec these should all be code blocks

[20:09] <masak> tadzik: oh, it's not easily resolvable?

[20:09] <masak> I assumed it was.

[20:09] <masak> yes, then maybe mailing is a good idea.

[20:09] <tadzik> masak: not really. See: (moar)

[20:09] <masak> especially if it wakes up TheDamian. :)

[20:10] <pmichaud> tadzik: maybe email TheDamian directly?

[20:10] <masak> +1

[20:10] *** dalek left
[20:10] <masak> avoids being warnocked.

[20:10] <pmichaud> also, TheDamian sometimes doesn't want to get bogged down in p6l bikeshedding

[20:11] <pmichaud> something about "life" and "too short"  :-)

[20:11] <tadzik> or maybe not. Hmmm

[20:11] <masak> pmichaud: as opposed to the hoards of us who *want* to get bogged down in p6l bikeshedding? :P

[20:11] <tadzik> now that I look at it, spec puts every Pod6 it shows an example into a code block

[20:11] *** dalek joined
[20:11] *** ChanServ sets mode: +v dalek

[20:11] *** Krunch joined
[20:11] <masak> tadzik: that's how you show code in Pod6 :P

[20:11] <masak> (duh) :P

[20:11] <tadzik> I know that :)

[20:12] * masak is teasing tadzik

[20:12] * tadzik wonders what is the cheese, and what is the trap

[20:12] <moritz> tadzik: I'm pretty sure that S26:827 is meant to be parsed as a code block

[20:12] *** p6eval left
[20:13] *** dalek left
[20:13] <masak> tadzik: the probability that there are outright *errors* in S26 is low, at least for the older changes.

[20:13] <masak> the ones that have been checked with an actual parser.

[20:14] <tadzik> moritz: 872?

[20:15] *** MayDaniel joined
[20:15] <pmichaud> need lunch... bbiaw

[20:15] <tadzik> moritz: yeah, but when thinking inside a code block... So the document starts from "This ordinary paragraph", not "\tThis ordinary paragraph"?

[20:17] <tadzik> also, look at S26:821. That one is indented more than it's opening delimiter (which, I assume, is as indented as the first paragraphs of the example)

[20:18] <flussence> I guess what you're asking can be simplified to "do these indent the same way as heredocs?"

[20:18] *** p6eval joined
[20:18] *** ChanServ sets mode: +v p6eval

[20:18] <tadzik> how are heredocs indented?

[20:19] *** MayDaniel left
[20:19] <flussence> Like an ordinary string literal followed by .indent(*)

[20:19] *** mj41 left
[20:20] <tadzik> aroo, now I have two problems

[20:21] <tadzik> but from all of this I think I now understand something :)

[20:22] <tadzik> shame that all my tests as for now assume that the block content can indent to whatever it wants to :)

[20:23] <masak> well, it's OK to change the tests if you misunderstood the specification :)

[20:25] *** dalek joined
[20:26] *** ChanServ sets mode: +v dalek

[20:26] <tadzik> yeah :)

[20:26] <tadzik> but that all means that I have to treat =list and =pod specially

[20:26] *** dalek left
[20:26] <tadzik> already in the grammar

[20:26] <tadzik> though I don't quite see why code should only be allowed in those

[20:27] <moritz> there's a reason it's a gsoc project and not a weekend hacking session :-)

[20:27] <tadzik> :)

[20:27] <tadzik> I'm glad :)

[20:38] <tadzik> is it safe to assume that implicit code blocks only make sense in a delimited blocks?

[20:40] <moritz> with "implicit code block" you mean one that's marked up by indention?

[20:41] *** dalek joined
[20:41] *** ChanServ sets mode: +v dalek

[20:41] <tadzik> yep

[20:41] <moritz> that would be a pretty big departure from the p5 pod ways

[20:42] <tadzik> every time S26 uses them, it sorrounds them by blank lines. Now if they were inside a parablock, the leading blank line would end the parablock anyway

[20:42] <tadzik> moritz: would it?

[20:43] <moritz> I might have misunderstood the question

[20:43] <tadzik> it already is, contrary to P5 way, implicit code blocks are allowed only in explicit pod blocks or =items

[20:43] <moritz> I think it's safe to assume that code blocks are either surrounded by blank lines or specific =begin code ... =end code

[20:43] *** dalek left
[20:43] <tadzik> yes

[20:44] <tadzik> so if they're sorrounded by blank lines, they're by definition not allowed to be in paragraph or abbreviated blocks

[20:45] *** dalek joined
[20:45] *** ChanServ sets mode: +v dalek

[20:45] <moritz> phenny: ask diakopter any idea what's up with the appflux server? I can't seem to ssh to it, and dalek often times out

[20:45] <phenny> moritz: I'll pass that on when diakopter is around.

[20:45] *** wamba joined
[20:53] *** lumi_ joined
[20:56] <dalek> <sorear> moritz: dalek (host04) seems to be doing quite a bit better than our IRC on host02..

[20:57] *** am0c joined
[21:06] *** jaldhar left
[21:07] *** jaldhar joined
[21:07] *** _patch joined
[21:09] *** araujo left
[21:19] <dalek> niecza: 612a7b7 | sorear++ | / (6 files):

[21:19] <dalek> niecza: Eliminate Beta as a separate pass, inline subs during the parse

[21:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/612a7b7409

[21:20] *** scottp joined
[21:24] *** jaldhar left
[21:24] *** lumi_ left
[21:24] *** jaldhar joined
[21:24] *** y3llow_ joined
[21:24] *** pothos_ joined
[21:25] *** lumi_ joined
[21:26] *** y3llow left
[21:26] *** pothos left
[21:26] *** y3llow_ is now known as y3llow

[21:26] *** pothos_ is now known as pothos

[21:29] *** kaare_ left
[21:30] *** scottp left
[21:31] *** scottp joined
[21:33] <masak> blog post! http://strangelyconsistent.org/blog/june-11-2011-arrays

[21:34] <pmichaud> mmmm pancakes

[21:34] <pmichaud> pancakes would be good

[21:35] <Util> perl6: my @t; @t[0] = @t[2] = 9; @t.perl.say;

[21:35] <p6eval> niecza v6-150-g612a7b7: OUTPUT¬´[9, Any, 9].list‚ê§¬ª

[21:35] <p6eval> ..rakudo 4a6d21: OUTPUT¬´[9, Any, 9]‚ê§¬ª

[21:35] <p6eval> ..pugs: OUTPUT¬´[9, undef, 9]‚ê§¬ª

[21:35] <Util> perl6: my @t; @t[2] = @t[0] = 9; @t.perl.say;

[21:35] <p6eval> niecza v6-150-g612a7b7: OUTPUT¬´[9, Any, 9].list‚ê§¬ª

[21:35] <p6eval> ..rakudo 4a6d21: OUTPUT¬´[9, Any, 9]‚ê§¬ª

[21:35] <p6eval> ..pugs: OUTPUT¬´[9, undef, 9]‚ê§¬ª

[21:35] <Util> Those both work as expected.

[21:35] <masak> niecza++ # correctest

[21:35] <Util> perl6: my @t; @t[0][0] = @t[0][2] = 9; @t[0].perl.say;

[21:35] * tadzik has actually said "floursaltsugarmilkeggsbutter" 5 times

[21:35] <p6eval> rakudo 4a6d21, niecza v6-150-g612a7b7: OUTPUT¬´[9]‚ê§¬ª

[21:35] <p6eval> ..pugs: OUTPUT¬´[9, undef, 9]‚ê§¬ª

[21:35] <Util> perl6: my @t; @t[0][2] = @t[0][0] = 9; @t[0].perl.say;

[21:36] <masak> tadzik: *lol*

[21:36] <p6eval> rakudo 4a6d21, niecza v6-150-g612a7b7: OUTPUT¬´[Any, Any, 9]‚ê§¬ª

[21:36] <p6eval> ..pugs: OUTPUT¬´[9, undef, 9]‚ê§¬ª

[21:36] <masak> tadzik: but did you say it quickly?

[21:36] <Util> Pugs' output matches my expectation. Bug in both Rakudo and Niecza, or am I missing a clue about auto-viv?

[21:36] <tadzik> masak: I tried :)

[21:36] <masak> :P

[21:36] <masak> Util: undef is no more.

[21:36] <tadzik> if I say it quickly, it becomes flaukeshkeshkeshkeshkeshkesh

[21:36] <masak> Util: it's all undefined typoid values.

[21:36] <masak> Util: (like Any)

[21:36] <pmichaud> I think bug in rakudo as far as the lack of the initial 9 goes

[21:37] <pmichaud> it's one of the autoviv corner cases

[21:38] <Util> masak: I am not referring to undef vs Any.

[21:39] <Util> masak: Rakudo and Niecza only populate one element; should be two elements.

[21:40] <tadzik> moritz/masak: want to play "does this make sense" game?

[21:40] <pmichaud> anyway, autoviv bug, yes.

[21:40] <Util> pmichaud: Thanks! any pointers on where to start poking at the Rakudo source code?

[21:40] <pmichaud> the problem has to do with how Rakudo manages containers inside of methods

[21:41] <pmichaud> but the bug ultimately comes down to the Any.at_pos method

[21:41] *** Psyche^ joined
[21:41] <pmichaud> src/core/Any-list.pm:327

[21:42] <masak> Util: oh!

[21:42] *** Patterner left
[21:42] *** Psyche^ is now known as Patterner

[21:42] <Util> pmichaud: Thanks!

[21:42] <masak> Util: I missed that one. yes, pugs is righter in that sense.

[21:42] <pmichaud> that method automatically converts an Any value to be an Array when something is assigned to one of its (proxy) elements

[21:42] <tadzik> so: there is a global (grammar-wide) array keeping last-seen-virtual-left-margin. When a pod directive appears, it unshifts the current margin to it, and shifts it back when it comes to an end. Now, any text content checks the array[0] element, and if it contains <= amount of leading whitespace, it's a normal text block. If more, it looks like a code block

[21:43] <pmichaud> "unshifts the current margin"  might be better expressed as a dynamic variable, fwiw

[21:43] <tadzik> it seems hell complicated, but I have no better idea to make it right

[21:43] <pmichaud> we used to do a lot of stuff with unshifting arrays until we had dynamic variables

[21:44] <masak> tadzik: some stack-like mechanism is clearly needed. pmichaud's dynamicals suggestion seems nice.

[21:44] <tadzik> pmichaud: so having $*A = 5; { $*A = 7; blah() }, blah will see $*A as 7, but after the block it'd still be 5?

[21:44] <pmichaud> need some my's there

[21:44] <tadzik> two my's?

[21:44] *** Vlavv joined
[21:44] <pmichaud> my $*A = 5;  { my $*A = 7;  blah() }

[21:44] <tadzik> makes sense

[21:44] <pmichaud> my $*A = 5;  { my $*A = 7;  blah() };  blah()

[21:44] <pmichaud> first blah sees 7.  second blah sees 5.

[21:44] <tadzik> first blah sees 7, second...right

[21:45] <tadzik> great, just what I need

[21:45] *** lumi_ left
[21:45] <tadzik> now I "only" need to refactor paragraph handling and put that ideas together

[21:45] <masak> good thing you have tests ;)

[21:45] <tadzik> yep

[21:45] <tadzik> like 130 of them :)

[21:45] *** lumi_ joined
[21:46] <tadzik> I adopted this "you don't have tests? How can you tell it even works?" approach

[21:47] *** mj41 joined
[21:47] <tadzik> can it get any better than "$<spaces> = [ \h* ] { $VIRTUAL_MARGIN = $<spaces> }"?

[21:48] <tadzik> s/'$'/'$*'/ of course

[21:48] <tadzik> I don't need $<spaces> fwiw

[21:50] * tadzik peeks at rakudo source

[21:51] <tadzik> rakudo uses some :my $*QSIGIL := '';

[21:57] *** wamba left
[21:57] <dalek> pmichaud: <sorear> I have a solution in mind but it is very partial; it cannot handle @a[0][0][0] = @a[0][0][2] = 5.  Do you have one that can?

[21:57] *** scottp left
[21:58] <masak> I thought dalek reported commits.

[21:58] <jnthn> I think dalek is feeling a little unwell today :(

[22:02] <dalek> Util: <sorear> AIUI, the root of the problem is that, in @a[0][0] = @a[0][2] = 5, the term '@a[0]' appears twice

[22:02] <dalek> autovivification in niecza and rakudo works by creating a new scalar variable, then setting magic on it so that it is bound back into the container if the variable is written to or reference is taken

[22:03] <masak> dalek: are you really sorear?

[22:03] <dalek> unfortunately, because @a[0] is used twice, two variables are created, and they can't BOTH be bound back.  One of them has to be lost.

[22:03] <jnthn> oh wait what...sorear is talking as dalek?!

[22:03] <masak> spooky.

[22:04] <tadzik> I'm scared

[22:04] <masak> bots taking the souls of humans -- you should!

[22:04] <masak> should be*

[22:05] <masak> it's like a modern horror story on the 'Net.

[22:05] <jnthn> It's the abotalypse!

[22:05] *** sorear joined
[22:05] *** mj41 left
[22:05] <sorear> I just remembered I have an IRC client installed locally :p

[22:06] <sorear> don't need to puppet dalek :D

[22:06] <pmichaud> sorear++ has identified the problem, yes.

[22:07] <masak> each time I get details explained to me like that, a part of my brain goes "screw that, how do I have the cake and eat it too?" :)

[22:08] <sorear> masak: use pugs

[22:08] <sorear> :)

[22:08] <masak> :P

[22:08] <sorear> obviously pugs is using a different autoviv spec

[22:09] <sorear> anyway, anyone with p6eval access can speak through dalek

[22:09] *** sorear_ joined
[22:09] *** diakopter joined
[22:09] <pmichaud> maybe the scalar proxy could re-check its source to see if a vivification occurred since the time the proxy was created

[22:10] <pmichaud> but that gets kinda tricky

[22:10] <sorear> pmichaud: that was my "partial solution"

[22:10] <sorear> it doesn't seem to work for @a[0][0][0] = @a[0][0][2] = 5

[22:11] <sorear> perhaps another way would be to have latecomers tie themselves

[22:12] <sorear> or rather, the proxy acts like a tied thing, and doesn't guarantee to always bind

[22:12] <sorear> </slushy_thought>

[22:12] *** sorear left
[22:13] *** sorear_ is now known as sorear

[22:14] <pmichaud> yes, that's a possibility too, although we need to make sure that such tied items don't get counted in .elems and the like

[22:14] *** TimToady joined
[22:14] <pmichaud> so it's a sort of "provisional tie"

[22:14] *** jfried left
[22:16] <lue> hello world of zebras o/

[22:16] <masak> lue! \o/

[22:16] *** lumi_ left
[22:17] *** lumi_ joined
[22:18] <tadzik> hello lue!

[22:18] <lue> masak: there's a mistake in your 9 June post: "(Or more generally, the surrounding blog that sets $_.)"

[22:19] <masak> lue: thank you. fixing.

[22:23] <lue> .oO(Getting back into coding Perl6 is going to be an interesting couple of days....)

[22:23] <masak> glad you're following my course :)

[22:25] <pmichaud> Util: btw, both nqp and nom now support --gen-parrot=master  which forces building Parrot from its current 'master' branch.

[22:25] <lue> I was reading through them and learned at least one new thing I didn't know before (I forgot what it was though, so I'll have to look through them again)

[22:25] <pmichaud> if you forgot what it was, how do you know that you didn't know it before?  ;-)

[22:26] <tadzik> pmichaud: should '$<spaces> = [ \h* ] { my $*VMARGIN = ~$<spaces> }' work?

[22:27] <tadzik> doesn't the value get lost on }?

[22:28] <sorear> my sleep deprived brain just came up with an idea wacky enough to work

[22:29] <sorear> I'm tempted to try it, but it involves diverging from the spec... (also, scrapping WHENCE)

[22:29] <tadzik> it got better without the 'my' part, but I sense that's a concidence

[22:29] <pmichaud> yes, the value would be lost on }

[22:29] <pmichaud> try :my

[22:29] <pmichaud> (I think we have :my implemented)

[22:29] <pmichaud> (looking)

[22:29] <tadzik> pmichaud: I see :my in Perl6 grammar, but when I use it in my code it complains about malformed regex

[22:30] <pmichaud> note that rakudo currently requires :=

[22:30] <tadzik> yeah, I'm not in Rakudo yet

[22:30] <pmichaud> okay, nqp requires :=

[22:30] <tadzik> I'm in Perl 6:)

[22:31] <tadzik> also, it doesn't like := either

[22:31] <tadzik> it doesn't mind :my in TOP, but it does in other rules

[22:32] <tadzik> oh, a semicolon

[22:32] <sorear> pmichaud: do you think there's any point to persuing an approach to semantically better autoviv other than WHENCE?

[22:33] <tadzik> now $<spaces>.Str becomes "NPA in can()"

[22:34] <pmichaud> I'm not sure if nqp's regex engine understands $/ in a :my directive yet

[22:35] <tadzik> oh, that's a bug like hell

[22:35] <tadzik> if I add "{}\n" before the :my, the NPA is gone

[22:35] <sorear> !PREFIXES maybe?

[22:35] <pmichaud> right, because {} forces $/ to be bound.

[22:36] <sorear> oh

[22:36] <tadzik> oh

[22:36] *** awwaiid left
[22:36] *** awwaiid joined
[22:37] <tadzik> good, less and less tests fail

[22:37] <sorear> pmichaud: or rather, I want to make Any{ } and Hash.at_key unrelated concepts

[22:38] <sorear> pmichaud: the closer I look at the spec the less they seem to have in common

[22:39] <pmichaud> sorear: I presume you mean  $x{ }   and Hash.at_key  (where $x is Any)

[22:39] <pmichaud> since Any{ }  means something else entirely in the spec

[22:40] <tadzik> oh my, it almost passed

[22:40] <pmichaud> I just know that

[22:41] <pmichaud> my $x;  $x{<a b c>} = <alpha beta gamma>

[22:41] <pmichaud> is expected to work

[22:41] <pmichaud> which looks an awful lot like Hash.at_key to me

[22:41] <pmichaud> and standard postcircumfix:<{ }>

[22:41] <pmichaud> (and it's really Any.at_key at this point)

[22:45] *** fish|ipad left
[22:45] *** fish|ipad joined
[22:47] <sorear> pmichaud: heh.

[22:48] <sorear> pmichaud: actually I did mean Any{ }.  Your reaction confirms my "I'm thinking these are quite unrelated"... :)

[22:48] <pmichaud> they're quite unrelated, yes.

[22:48] <sorear> pmichaud: the spec describes both Any.[2] and Pair{ key => 2, value => 3 } using the word "autovivification"

[22:48] <pmichaud> Type{ }  is a syntactic construct meaning   Type but WHENCE({ } )

[22:49] *** rliu49 joined
[22:49] <sorear> but I don't think container autovivification and value autovivification are the same thing

[22:49] <pmichaud> however, both jnthn++ and I (and apparently you) feel this part of the spec needs some work.

[22:49] <sorear> I'm going to redo niecza's container autovivification based on the crazy idea

[22:50] <pmichaud> see also http://irclog.perlgeek.de/perl6/2011-06-10#i_3893608

[22:50] <sorear> is that the "um wtf it's a TYPE OBJECT how can it have STORAGE" one?

[22:50] <sorear> I'll see if it's fast enough, and has useful semantics

[22:50] <pmichaud> that was part of the discussion, yes.

[22:51] <pmichaud> (iiuc, there's not anything in the spec that prohibits type objects from having storage)

[22:51] <jnthn> :/

[22:51] <jnthn> Don't go there.

[22:51] <jnthn> I can put something in the spec if you like. :)

[22:51] <jnthn> I think S12's "empty instance" is sufficient though.

[22:52] <sorear> niecza makes a different assumption

[22:52] <pmichaud> I don't see "empty instance"  (looking)

[22:52] <sorear> niecza doesn't connect "type object" with "has storage"...

[22:52] <sorear> but the default REPRs all implement defined as $x !=== $x.WHAT

[22:52] <pmichaud> S12: "The type object

[22:52] <pmichaud> differs from an instance object not by having a different

[22:52] <pmichaud> type but rather in the extent to which it is defined."

[22:52] <sorear> one type, one type object

[22:52] <pmichaud> (yes, I now see "empty" instance above that)

[22:53] <pmichaud> I'm not sure that "empty" instance automatically translates to "no storage", though.  I think it simply means "not fully initialized".

[22:53] <jnthn> SMOP and 6model have both called empty as no storage. It turns out to work out pretty well.

[22:53] <pmichaud> oh, I thought SMOP actually had a defined flag

[22:54] <jnthn> I'm pretty sure lack of storage was the defined flag.

[22:54] <pmichaud> maybe I misremember.  I know there were big discussions about that several years ago.

[22:54] <sorear> niecza's type objects currently always have no storage

[22:54] <pmichaud> anyway, the underlying point is that   but WHENCE({ ... })   doesn't seem to quite work for vivification

[22:54] <sorear> in the past, niecza defined defined as "has no attribute storage"

[22:55] <sorear> but then I optimized some things by allowing types with no attributes to have no storage even in defined instances

[22:55] <pmichaud> either that or none of us implementors have figured out how to make it "quite work"  :)

[22:55] <jnthn> pmichaud: I suspect that bit of the spec has an issue.

[22:56] <pmichaud> jnthn: I agree; I was just passing that along to sorear++, who also seems to agree

[22:56] <pmichaud> jnthn: out of curiosity, will :U and :D honor .defined ?

[22:56] <jnthn> pmichaud: No

[22:56] <jnthn> They're more low level than that.

[22:56] <pmichaud> hmmm

[22:56] <pmichaud> in the spec, also?

[22:56] <jnthn> They really mean "is the repr defined"?

[22:56] <jnthn> Er, "does the repr consider itself defined"?

[22:57] <jnthn> pmichaud: Not sure. I distinctly remember a discussion here about that which ended up saying they're more low-level.

[22:57] <pmichaud> so it really means "is it abstract"?

[22:57] <jnthn> Not just sugar for .defined

[22:57] <pmichaud> as opposed to "is it undefined"

[22:57] <pmichaud> maybe it should be :A then

[22:57] <jnthn> In reality it really means "is it a type object" :)

[22:57] <pmichaud> or :T and :I, then.

[22:57] <jnthn> Could be T and I

[22:57] *** lumi_ left
[22:58] *** Mowah joined
[22:58] <jnthn> Type and In...spooky :)

[22:58] <pmichaud> Although I know seem to recall that TimToady liked the fact that :D smiles at you

[22:58] <pmichaud> s/know//

[22:58] <jnthn> Yeah, me too ;)

[22:58] <pmichaud> anyway, I think :D and :U might be a point of confusion there someday.

[22:58] <jnthn> Perhaps so

[22:58] *** lumi_ joined
[22:58] <jnthn> We really want them to be fast.

[22:59] <jnthn> And we do need a way of saying "is this a type or not"

[22:59] <pmichaud> I agree, fully.

[22:59] <jnthn> Which is a different thing from the overridable .defined

[22:59] <pmichaud> I'm not sure that calling it "definedness" is the right way to do it, since we can have concrete instances that aren't defined

[22:59] <jnthn> Yeah

[22:59] <jnthn> It's not instantiatedness.

[22:59] <jnthn> gah

[22:59] <jnthn> s/not/more/

[22:59] <pmichaud> indeed, it should probably be :A (abstract) and :C (concrete)

[22:59] <pmichaud> since S12 says

[23:00] <pmichaud>     Int:U       Allow only undefined (abstract) Int values

[23:00] <pmichaud>     Int:D       Allow only defined (concrete) Int values

[23:00] <jnthn> hmm :)

[23:00] <jnthn> Yes

[23:00] <pmichaud> then :B can be "both"

[23:00] <jnthn> :C looks *really* sad :)

[23:00] <pmichaud> and we have :A :B :C

[23:00] <jnthn> It's as simple as ABC!

[23:00] * jnthn likes

[23:00] <jnthn> :)

[23:00] <masak> +1

[23:00] <pmichaud> TimToady: ^^^^^^

[23:00] <jnthn> :A...that's a weird smile :)

[23:00] <masak> :A :B :C :D :U ?

[23:01] <jnthn> masak: I think we'd remove :D and :U

[23:01] <masak> oh, ok.

[23:01] <pmichaud> yeah.  :D is  then where *.defined

[23:01] <jnthn> *nod*

[23:01] * masak backlogs

[23:01] <pmichaud> and :U  is   where !*.defined

[23:01] <pmichaud> (and you write them with the where clause, not with the :D/:U)

[23:03] <masak> I approve. :U and :D are out, :A and :C are in.

[23:03] <masak> but :B sounds like a no-op to me.

[23:03] <jnthn> It's the default, in a sense.

[23:03] * sjn sees a bunch of new and novel smilies

[23:04] <sjn> :U

[23:04] <masak> sjn: we finished designing Perl 6, so now we're designing smilies! :B

[23:04] * sjn approves of this effort

[23:04] <jnthn> If it wasn't misleading, we could have object and prototype... :O and :P

[23:04] <sjn> makes the language much more expressive :)

[23:05] <masak> jnthn: ETOOCUTE :O

[23:08] <tadzik> I'm thinking optional and required parameter: :] and >:(

[23:08] <jnthn> tadzik: please stop thinking :P

[23:08] <jnthn> :)

[23:09] <tadzik> I did, I left fixing my podparser for the morning

[23:09] <tadzik> ETOOTIRED

[23:09] <masak> clearly there's a niche for an obfuscated language out there -- "Smiley".

[23:09] <colomon> pmichaud: As I recall, there were two libgmp issues.  The first was that they returned their own data structures on the stack from the functions, which isn't really Zavolaj-compatiable so far as I know.  (But can be worked around.)  The second was that they wouldn't build on certain versions of GCC, one of which was the default system GCC on some versions of OS X. 

[23:10] * sorear runs an autoviv benchmark to establish a baseline

[23:13] <colomon> pmichaud: BTW, IMO it would be a big win to have Bigints in nqp.  Their lack creates really ugly issues with numeric literal parsing, as we see in master.  (Still haven't backlogged fully to see what is going on, afk for a bit to read stories.)

[23:13] <masak> ++colomon

[23:14] <masak> 'night, #perl6.

[23:14] <sorear> 'night.

[23:15] <pmichaud> colomon: I'm in full agreement that nqp is where bigints want to live.  

[23:15] <pmichaud> my concern is mainly about getting libgmp or another bigint library to run on our target platforms

[23:20] <pmichaud> afk, walk

[23:32] *** donri left
[23:46] *** rliu49 left
[23:49] *** mtk left
[23:50] *** lumi_ left
[23:51] *** lumi_ joined
[23:59] *** mtk joined
[23:59] *** slavik1 joined
