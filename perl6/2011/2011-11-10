[00:01] *** sbp left
[00:03] *** alim left
[00:03] *** clairvy left
[00:10] *** clairvy joined
[00:15] *** dual left
[00:15] *** clairvy left
[00:16] *** clairvy joined
[00:22] *** alim joined
[00:23] *** replore_ joined
[00:24] *** pmurias left
[00:25] *** thou left
[00:25] *** clairvy left
[00:26] *** clairvy joined
[00:26] *** shinobicl left
[00:27] *** clairvy left
[00:28] *** clairvy joined
[00:30] *** shinobicl joined
[00:30] *** clairvy left
[00:30] *** clairvy joined
[00:32] *** clairvy left
[00:32] *** clairvy joined
[00:33] *** clairvy left
[00:56] *** aloha left
[00:56] *** aloha joined
[01:06] *** alim left
[01:06] *** kaleem joined
[01:08] *** kaleem left
[01:15] *** bazqux left
[01:22] *** hypolin joined
[01:38] *** lestrrat left
[01:40] *** lestrrat joined
[01:53] *** wolfman2000 joined
[01:57] *** Chillance left
[01:58] *** djanatyn left
[02:01] *** djanatyn joined
[02:16] <japhb> std: :16<>

[02:16] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed radix number at /tmp/4Lh9hezrLS line 1:␤------> [32m:16<[33m⏏[31m>[0m␤    expecting any of:␤   number in radix notation␤       statement end␤  statement list␤Parse failed␤FAILED 00:01 118m␤»

[02:16] <japhb> std: :16[]

[02:16] <p6eval> std be1f10e: OUTPUT«ok 00:01 119m␤»

[02:16] <japhb> Any reason that the first shouldn't DWIM like the second does?

[02:22] *** f00li5h left
[02:22] *** f00li5h joined
[02:23] *** daniel-s joined
[02:34] *** benabik joined
[02:40] *** aindilis joined
[02:47] *** Guest68707 left
[02:51] *** \patch is now known as patch

[02:57] <patch> nom: say [+] 1..^10

[02:58] <p6eval> nom 198513: OUTPUT«45␤»

[02:59] <patch> nom: say [+] (1..^10).grep(* %% (3|5))

[02:59] <p6eval> nom 198513: OUTPUT«23␤»

[03:02] <patch> nom: say [+] (1, 2, * + * ... * < 100).grep(* %% 2)

[03:02] <p6eval> nom 198513: OUTPUT«0␤»

[03:04] <patch> nom: say join ',', (1, 2, * + * ... * < 100)

[03:04] <p6eval> nom 198513: OUTPUT«1␤»

[03:06] *** replore_ left
[03:10] <TimToady> ... is an "until", not a "while"

[03:18] <patch> nom: say [+] (1, 2, * + * ... * > 100).grep(* %% 2)

[03:18] <p6eval> nom 198513: OUTPUT«188␤»

[03:18] <patch> TimToady: thanks!

[03:19] <TimToady> no, thank you!  :)

[03:24] <patch> nom: say (1..*).first( * %% all(1..4) );

[03:24] <p6eval> nom 198513: OUTPUT«12␤»

[03:28] <dalek> 6model: d1240fb | diakopter++ | lua/compiler/LST2Lua.pm:

[03:28] <dalek> 6model: typo

[03:28] <dalek> 6model: review: https://github.com/diakopter/6model/commit/d1240fb83b

[03:35] *** replore joined
[03:47] *** odoacre joined
[03:55] *** mkramer joined
[04:01] *** mkramer left
[04:10] *** envi_ joined
[04:17] *** patch left
[04:27] *** arnsholt left
[04:27] *** arnsholt joined
[04:29] *** drbean joined
[04:43] *** f00li5h left
[04:43] *** f00li5h joined
[04:44] *** icwiener left
[04:52] *** f00li5h left
[04:54] *** Trashlord left
[04:55] *** Trashlord joined
[05:07] *** alim joined
[05:09] *** patch joined
[05:11] <patch> nom: say (2,3,5,7,11 ... 29).perl

[05:11] <p6eval> nom 198513: OUTPUT«(2, 3, 5, 7, 11, Failure.new()).list␤»

[05:12] <patch> nom: say join ',', (2,3,5,7,11 ... 29)

[05:12] <p6eval> nom 198513: OUTPUT«unable to deduce sequence␤  in sub <anon> at src/gen/CORE.setting:7812␤  in sub coro at src/gen/CORE.setting:4154␤  in method reify at src/gen/CORE.setting:4128␤  in method reify at src/gen/CORE.setting:3913␤  in method reify at src/gen/CORE.setting:3913␤  in method r…

[05:13] *** orafu left
[05:13] *** orafu joined
[05:16] *** sftp left
[05:23] *** abercrombie joined
[05:33] *** envi_ left
[05:33] *** alim left
[05:46] *** xinming_ joined
[05:49] *** xinming left
[05:52] *** worr joined
[05:54] <moritz> patch: only arithmetic and geometric sequences are regocnized

[05:54] <sorear> (by spec)

[05:55] <sorear> o/ worr 

[05:57] *** Lorn left
[06:00] *** Lorn joined
[06:02] *** daniel-s left
[06:03] *** odoacre left
[06:03] *** Yappoko___ left
[06:03] *** odoacre joined
[06:03] *** Yappoko___ joined
[06:15] *** aloha left
[06:15] *** aloha joined
[06:19] *** koban joined
[06:20] *** drbean left
[06:24] *** wolfman2000 left
[06:26] *** drbean joined
[06:30] <dalek> nqp/bigint: 8534217 | moritz++ | src/ (2 files):

[06:30] <dalek> nqp/bigint: add nqp::radix_I alias, fix op name

[06:30] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/853421702e

[06:33] *** alim joined
[06:33] *** alim left
[06:40] <moritz> perl6: say +^0xdead

[06:40] <p6eval> pugs b927740, rakudo 198513, niecza v11-22-gbebf7a0: OUTPUT«-57006␤»

[06:44] <Tene> jnthn: friend of mine found a bug: https://gist.github.com/1354278

[06:48] <patch> moritz: has perl6-examples been abandoned?

[06:49] <moritz> patch: mostly, yes

[06:50] <patch> so, no use for new euler solutions or corrections to old examples?

[06:51] *** drbean left
[06:54] <moritz> well, you can revive it

[06:54] *** araujo left
[06:55] <moritz> I mostly meant that currently nobody maintains it

[06:56] <patch> i'd like to help with that

[06:56] <moritz> patch: do you have commit access already?

[06:57] *** araujo joined
[06:57] <patch> moritz: no, i'm patch on github.

[06:58] <moritz> patch: now you have. Have fun!

[06:58] *** drbean joined
[06:58] <patch> moritz: thanks!

[07:00] *** wtw joined
[07:00] * sorear wonders if patch is named after TimToady's program

[07:00] * sorear -> sleep

[07:03] * patch wonders if TimToady's program is named after himself

[07:16] *** drbean left
[07:24] *** drbean joined
[07:26] *** Mowah_ joined
[07:33] *** daniel-s joined
[07:38] *** simcop2387 left
[07:40] *** simcop2387 joined
[07:40] <Woodi> maybe not totally of topic: http://www.garfield.com/comics/todayscomic.html

[07:45] *** am0c joined
[07:47] *** benabik left
[07:48] <masak> morning, #perl6

[07:48] *** benabik joined
[07:48] <Tene> midnight, masak :)

[07:49] <masak> :)

[07:49] * masak .oO( Phase Off )

[08:12] <masak> moritz: #103258 looks a bit familiar. I wonder if that isn't a dupe.

[08:12] <masak> [Coke]: have you seen it before?

[08:18] *** drbean left
[08:20] *** drbean joined
[08:24] *** mj41 joined
[08:26] *** wk left
[08:29] *** icovnik joined
[08:38] <masak> I'm still thinking about lichtkind's Documentation-Driven Development idea.

[08:39] <masak> it seems a good idea to divert at least some of the initial energy of a project into writing user docs. at least as long as that itself doesn't kill the project.

[08:39] <masak> after that, it seems that the challenge is to have the documentation stay in sync with user-visible redesigns.

[08:40] <moritz> well, it seems to be prone to the same problems as waterfall development

[08:41] <masak> I don't know about that. there's a difference between laying out the whole user experience up front and laying out the whole design up front.

[08:42] <masak> the former seems to me like a net good and that it's often done too seldom -- to the detriment of UIs.

[08:42] *** replore left
[08:45] *** drbean left
[08:46] <moritz> well, design first suffers from the problem that you often have an imprecise idea of what the program should do in the end

[08:47] <moritz> and if you don't know that (or aren't deep enough into the problem domain), how can you spec the UI with more confidence than the other parts of the software design?

[08:49] <masak> no, one probably can't.

[08:49] <moritz> nom: say '(a' ~~ /'(' ~ ')' <alpha> /

[08:49] <p6eval> nom 198513: OUTPUT«=> <(>␤␤»

[08:49] <masak> which is why I like spike solutions and prototypes as a first step.

[08:49] *** risou_awy is now known as risou

[08:49] <moritz> it seems ~ is just NYI in qregex

[08:49] <moritz> I can't find its action method

[08:49] <masak> oh!

[08:49] <masak> but the above match is strange.

[08:50] <moritz> it's what I'd expect when the action method is missing

[08:50] <moritz> it just ignores the ~, goal and expression

[08:50] <moritz> hm

[08:50] <moritz> nom: say '(a)' ~~ /'(' ~ ')' <alpha> /

[08:50] <p6eval> nom 198513: OUTPUT«=> <(>␤␤»

[08:51] <moritz> right

[08:51] *** ab5tract joined
[08:51] *** drbean joined
[08:52] <masak> I'm not so sure I like Match.gist doing something other than Match.Str

[08:52] <masak> I found the former behaviour more useful.

[08:53] <masak> the above => <(>␤ is just confusing to look at.

[08:53] <moritz> masak: wait until you're developing grammars

[08:53] <masak> well.

[08:54] <masak> I tend to use regexes outside of grammars, so that argument doesn't really convince me. :/

[08:54] <moritz> currently it's a tradoff of which you see only the one half

[08:54] <masak> right.

[08:54] <masak> I'm saying I don't like that half.

[08:54] <masak> specifically, I don't like a '=>' without an LHS.

[08:54] <masak> that looks wrong and lazy.

[08:55] <moritz> if you find a way to make it nice of regexes, and still as informative for deeper match trees, please do so

[08:55] <masak> feels like that ought to be possible.

[08:55] *** Moukeddar joined
[08:59] <moritz> maybe rename the current method gist to 'pretty', and then add a .gist which does some magic check, and either delegates to .Str or to .pretty

[08:59] <masak> right.

[08:59] <moritz> fwiw the rationale for the => without the LHS is that we don't know (or don't have) the name of the current regex, which would be on the left of the =>

[08:59] <masak> yes, I see that.

[08:59] <moritz> nom: 'abc' ~~ /<alpha>+/; say $/

[08:59] <p6eval> nom 198513: OUTPUT«=> <abc>␤ alpha => <a>␤ alpha => <b>␤ alpha => <c>␤␤»

[09:00] <masak> er.

[09:00] <masak> good example of why it doesn't work ;)

[09:00] <moritz> huh?

[09:00] <moritz> please try it on a console, with proper indenting

[09:00] <masak> should be 'alpha => [<a>, <b>, <c>]', no?

[09:01] <moritz> should it? maybe :-)

[09:01] <masak> or maybe you consider the present layout a feature...

[09:01] * masak wishes he had more time to be involved when these changes happen :/

[09:02] <moritz> it's not like it's set in store or so

[09:02] <moritz> improvements are always possible

[09:03] <moritz> should probablye be    alpha =>  0 => <a>  1 => <b>  2 => <c>

[09:03] <masak> that looks wrong, too :/

[09:04] <moritz> why?

[09:04] <masak> specifically, not enough grouping.

[09:04] <moritz> I've left out the grouping by indenting here

[09:04] <masak> the problem with having those on the same line is if they contain further subrules.

[09:04] <moritz> yes, should have newlines

[09:06] *** envi_ joined
[09:06] <masak> generally, I have the feeling we're inventing Data::Dumper, and not making an excellent job at it.

[09:07] <moritz> Data::Dumper is more about round-tripping than about presentation

[09:07] <masak> hm.

[09:08] <masak> I must confess I do not often use it for its round-tripping capabilities.

[09:08] <masak> I use it quite often to look into nested data structures.

[09:09] *** alim joined
[09:13] <moritz> the leading $VAR1 =  would be quite unnecessary for the presentation aspect

[09:21] <moritz> nom: my Int $x = 3; my num $y = $x; say $y

[09:21] <p6eval> nom 198513: OUTPUT«3␤»

[09:22] *** icovnik left
[09:23] *** daxim joined
[09:27] *** daniel-s left
[09:34] *** Moukeddar left
[09:37] *** f00li5h joined
[09:37] *** integral joined
[09:38] *** simcop2387 left
[09:40] *** simcop2387 joined
[09:40] *** robertbrook joined
[09:45] <masak> moritz: let's try to clear up the solution space by dividing the possible solutions into Bracket Stringifications and Indented Stringifications. I agree that an indented stringification is a good thing to have. I'm not so sure I'd like it to be in .gist

[09:48] <moritz> masak: I find bracket-only stringifications (no indention) unreadable for larger match trees

[09:48] <moritz> there's .perl for that already

[09:48] <masak> good point.

[09:49] <mls> morning!

[09:49] <masak> morning, mls!

[09:49] <moritz> o/

[09:49] <dalek> nqp/bigint: 98cf1db | moritz++ | src/ops/nqp_bigint.ops:

[09:49] <dalek> nqp/bigint: correct docs for nqp_bigint_radix

[09:49] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/98cf1dbded

[09:50] <masak> moritz: I don't know if I'm just used to stringification of Match giving the matched substring, or if it's a genuinely useful, defendable behaviour. I do know I'll miss it.

[09:50] <moritz> stringification of Match still gives you the matched substring.

[09:50] <mls> (Data::Dumper uses the $VAR1 to show cyclic references)

[09:50] *** dakkar joined
[09:51] <moritz> ... even if there are no cyclic references

[09:51] <masak> moritz: right, but now we have two stringifications: .Str and .gist

[09:52] <dalek> rakudo/bigint: ffa2fe7 | moritz++ | src/core/Rat.pm:

[09:52] <dalek> rakudo/bigint: [Rat] avoid going through Num for .Int

[09:52] <dalek> rakudo/bigint: review: https://github.com/rakudo/rakudo/commit/ffa2fe7ed3

[09:52] <dalek> rakudo/bigint: 17b3fc8 | moritz++ | / (2 files):

[09:52] <dalek> rakudo/bigint: use nqp::radix_I in Str.Numeric

[09:52] <dalek> rakudo/bigint: 

[09:52] <dalek> rakudo/bigint: Fixes S32-str/numeric.t again

[09:52] <dalek> rakudo/bigint: review: https://github.com/rakudo/rakudo/commit/17b3fc811e

[09:52] <moritz> $ ./perl6 -e 'say ":16<FFFFFFFFFFFFFFFFFF>".Numeric'

[09:52] <moritz> 4722366482869645213695

[09:56] *** ab5tract left
[09:56] <moritz> rakudo: say ":16<FFFFFFFFFFFFFFFFFF>".Numeric

[09:56] <p6eval> rakudo 198513: OUTPUT«4.72236648286965e+21␤»

[09:56] <moritz> masak: right, and .gist is supposed to provide more interesting information besides the raw stringification

[09:57] <moritz> which is why .gist on a type object doesn't return the empty string

[09:57] <moritz> but rather Int() or so

[09:59] <masak> sure, but something like 'MATCH:[foo]' would also be more interesting information. and less verbose.

[09:59] <masak> there's nothing a priori that says .gist needs to output an indented match tree.

[10:00] <moritz> right, but people in here expressed their desire for better inspection of match trees, so it seems like a natural fit

[10:00] *** robertbrook left
[10:02] *** hypolin left
[10:05] *** ab5tract joined
[10:08] <masak> it might be a good/popular idea. we'll see.

[10:09] <masak> it would be nice if it didn't make non-grammar regex .gist-ification noisy, though.

[10:29] *** simcop2387 left
[10:30] *** simcop2387 joined
[10:43] <masak> egonw, jonalv: this might interest you: http://www.youtube.com/watch?v=vcXUrNSvjhU

[10:43] <masak> a few years old, but I remember it as good.

[10:44] *** simcop2387 left
[10:48] *** simcop2387 joined
[10:48] *** mkramer1 joined
[10:51] *** mkramer1 left
[10:53] *** wk joined
[10:56] <masak> er. sorry, ww.

[10:56] <moritz> still looks interesting :-)

[10:57] *** icovnik joined
[10:57] <masak> irssi advantage -- can handle many conversations simultaneously. disadvantage -- sometimes things end up in the wrong window...

[11:05] *** koban left
[11:05] <moritz> jnthn: I see some difficulties with parsing Int literals. We need to have a bigint type available in Actions.pm to create the Int constants from literals

[11:06] <moritz> jnthn: but of course we don't have them yet, and I guess we want to parse numbers before we set up Int. Should we create some NQPBigInt type for bootstrapping, and define some conversion to Int?

[11:11] *** ab5tract left
[11:39] *** nsh joined
[11:40] *** sbp joined
[11:41] *** sbp left
[12:09] *** bluescreen10 joined
[12:11] *** Psyche^ joined
[12:11] *** benabik left
[12:14] *** Patterner left
[12:14] *** Psyche^ is now known as Patterner

[12:16] *** simcop2387 left
[12:17] <masak> xkcd tackles YAGNI: http://xkcd.com/974/

[12:17] *** mishin joined
[12:18] <masak> I find the title attribute especially insightful. getting things right should always be done in the past, preferably :)

[12:18] *** simcop2387 joined
[12:21] <moritz> time machines will make it possible

[12:22] <moritz> OTOH the fact that we don't have time machines yet means that nobody from the future invented one, and brought them to us

[12:22] <moritz> so it's unlikely we'll ever get them :/

[12:23] <moritz> japhb: at your convenience, please review https://github.com/rakudo/rakudo/commit/17b3fc811ed02275904467cdd8fa3973c2a3716a

[12:28] *** ab5tract joined
[12:30] *** sftp joined
[12:31] *** mj41 left
[12:32] *** ab5tract left
[12:38] *** mj41 joined
[12:46] *** tokuhirom joined
[12:46] *** simcop2387 left
[12:50] *** simcop2387 joined
[12:54] *** benabik joined
[13:01] <moritz> the 'Perl 6' page on wikipedia does not mention Niecza. I'd like to call the lurkers in here to action to change that :-)

[13:02] <masak> ++lurkers

[13:04] <moritz> http://perl6.wikia.com/wiki/Constructor could also use some love :-)

[13:06] <moritz> could link to http://perlgeek.de/blog-en/perl-6/object-construction-and-initialization.html for example

[13:08] <masak> ooh - so *that's* where the idea of "a routine should only have one exit point" comes from! http://programmers.stackexchange.com/questions/118703/where-did-the-notion-of-one-return-only-come-from/118717#118717

[13:08] <masak> (I thought it was the Structured Programming movement)

[13:10] <moritz> curious

[13:12] <masak> yes. beware of memes that outlive their usefulness.

[13:13] <moritz> I had my "single point of exit" epiphany with Eiffel

[13:13] *** HarryS left
[13:14] <moritz> I wrote a small game, and that needed a routine to verify if a move was correct

[13:14] *** envi_ left
[13:14] <moritz> and that's a classical case where early exit is useful

[13:14] <moritz> you can do thing like    return False if $x1 != $x2 || $y1 != $y2;

[13:15] <moritz> subsequent validation might require that previous checks succeeded

[13:15] <moritz> but Eiffel enforces single point of exit

[13:15] *** envi_ joined
[13:15] <moritz> so I had to do something really ugly

[13:15] <moritz> a variable that remembered the check state, and doing an 'if' around each check except the first

[13:16] <moritz> and then I knew that it wasn't any easier to read or reason about that way

[13:16] <Juerd> I love having multiple returns

[13:17] <Juerd> And often I write it with "or" and "and"

[13:17] <Juerd> sub { condition or return; condition or return; condition or return; return 1; }

[13:18] <masak> I love multiple returns too. I'd probably lean towards statement-ending unless in that case, though.

[13:18] <masak> not religious about it; just a habit.

[13:19] <arnsholt> I'd probably go for statement-ending if with negated condition, I think

[13:19] <flussence> I only use the "or return" thing in languages that don't have postfix conditionals :)

[13:19] <Juerd> IIRC PBP wants you to use statement modifiers, because program flow is important and should stand out when skimming the beginnings of lines.

[13:19] <masak> right.

[13:19] <masak> that's probably where I got it from.

[13:19] <masak> and it's not just routines which return booleans -- this pattern works for all kinds of case-based processing.

[13:20] <Juerd> But to me, the condition seems more important. I've never written return unless open my $fh, "foo"; It's always open my $fh, "foo" or return;

[13:20] <masak> for example, deciding where to line-break a long string.

[13:20] *** shinobicl left
[13:20] <masak> Juerd: I'd 'die' or 'fail' there, not 'return'.

[13:20] <flussence> (having said that, I prefer use autodie; over both...)

[13:20] <moritz> Juerd: that's because open() is not executed primary for its return value in p5

[13:21] <arnsholt> Juerd: I feel it's more important to highlight the fact that we can return at this point

[13:21] <moritz> that's why it feels so weird in conditions

[13:21] *** HarryS joined
[13:21] <moritz> I might do

[13:22] <moritz> my $success = open my $fh, '<', $filename;

[13:22] <moritz> return unless $success;

[13:22] <moritz> rest of the thing here

[13:22] <Juerd> masak: In Perl 5 I can never decide between throwing exceptions and returning undef...

[13:23] <masak> heh :)

[13:24] <[Coke]> point to java, then. ;)

[13:24] <Juerd> arnsholt: Hm, maybe it's because I tend to keep subs short, that it's always really obvious that there are multiple return points.

[13:24] *** drbean left
[13:28] <masak> niecza: grammar G { token TOP { <var> | <var> \+ \d+ }; token var { \% $<name>=[\w+] \% { say 42 } } }; say ?G.parse("%foo%+1") # matches, fine

[13:28] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«42␤42␤Bool::True␤»

[13:28] <masak> niecza: grammar G { token TOP { <subrule> }; token subrule { <var> | <var> \+ \d+ }; token var { \% $<name>=[\w+] \% { say 42 } } }; say ?G.parse("%foo%+1") # doesn't match, and I think it's a bug

[13:28] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«42␤Bool::False␤»

[13:29] <masak> all I've done is move the alternation down into a subrule.

[13:29] <masak> that shouldn't make a difference, should it?

[13:29] <masak> niecza: grammar G { token TOP { <subrule> }; token subrule { <var> \+ \d+ | <var> }; token var { \% $<name>=[\w+] \% { say 42 } } }; say ?G.parse("%foo%+1") # matches again

[13:29] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«42␤Bool::True␤»

[13:30] * moritz wants a word diff for IRC

[13:30] <masak> I have no intuition for when order matters with infix:<|> in grammars.

[13:30] <masak> this seems (rightly or wrongly) to be one such case.

[13:31] *** drbean joined
[13:31] <masak> sorear: ^^

[13:32] * masak re-reads the relevant part of S05

[13:32] <benabik> I think | is supposed to do LTM and || is supposed to try in order.

[13:32] <masak> right. I'm with you that far.

[13:33] <arnsholt> masak: I think the inlined code makes both branches have the same declarative prefix

[13:33] <masak> oh!

[13:33] <benabik> So order shouldn't matter with |, right?

[13:33] <masak> yes.

[13:33] <masak> arnsholt++ # that's it, of course

[13:33] <masak> so I have to think about this from the viewpoint of the declarative prefixes of the transitive alternations.

[13:34] <masak> so, no bug.

[13:35] <masak> niecza: grammar G { token TOP { <subrule> }; token subrule { <var> | <var> \+ \d+ }; token var { \% $<name>=[\w+] \% } }; say ?G.parse("%foo%+1")

[13:35] <arnsholt> Yeah, LTM is all about the prefixes (as far as I can make out)

[13:35] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«Bool::True␤»

[13:35] <masak> right; without the code block it goes down the right branch.

[13:36] <masak> question is more: why does it discard the right branch when the code block is there?

[13:38] <masak> hm... maybe 'cus of the ratcheting implied by 'token'?

[13:38] <masak> niecza: grammar G { regex TOP { <subrule> }; regex subrule { <var> | <var> \+ \d+ }; regex var { \% $<name>=[\w+] \% { say 42 } } }; say ?G.parse("%foo%+1") # doesn't match, and I think it's a bug

[13:38] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«42␤42␤Bool::True␤»

[13:38] <masak> seems so.

[13:39] <masak> yeah; no bugs anywhere. keep up the good work, sorear++ :)

[13:42] *** envi_ left
[13:52] *** drbean left
[13:55] <moritz> perl6: say 123 ** 42

[13:55] <p6eval> rakudo 198513: OUTPUT«-9223372036854775808␤»

[13:55] <p6eval> ..pugs b927740, niecza v11-22-gbebf7a0: OUTPUT«5970554685064519004265641008828923248442340700473500698131071806779372733915289638628729␤»

[13:56] * moritz has a test case for pow_I

[13:56] *** vmspb joined
[13:58] *** drbean joined
[14:09] *** lucs left
[14:10] *** shinobicl joined
[14:13] <masak> someone could make a good blog post just by translating these Perl 5 one-liners to Perl 6: http://www.catonmat.net/blog/perl-one-liners-explained-part-six/

[14:14] <masak> as a bonus, explaining on the way why certain special variables are dead and gone, and what we use instead, and why it's better. :)

[14:18] <dalek> nqp/bigint: cf9144d | moritz++ | src/ops/nqp_bigint.ops:

[14:18] <dalek> nqp/bigint: fix spelling of base_core, though it does not seem to make a difference

[14:18] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/cf9144d02c

[14:18] <dalek> nqp/bigint: caacd56 | moritz++ | / (3 files):

[14:18] <dalek> nqp/bigint: First shot at a "smart" nqp::pow_I opcode

[14:18] <dalek> nqp/bigint: 

[14:18] <dalek> nqp/bigint: The idea is to return either a bigint or a float (for the +-Inf case,

[14:18] <dalek> nqp/bigint: and when the exponent is negative).

[14:18] <dalek> nqp/bigint: 

[14:18] <dalek> nqp/bigint: The float part isn't tested yet, so likely wrong. The part that returns

[14:18] <dalek> nqp/bigint: bigints has sparse test coverage, so it might be not too far off.

[14:18] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/caacd567b9

[14:18] *** tokuhirom left
[14:21] *** bazqux joined
[14:22] <moritz> http://www.perlmonks.org/?node_id=937320 might be fun to come up with a Perl 6 solution

[14:23] *** localhost left
[14:25] *** localhost joined
[14:27] <masak> feels like a bitmask problem.

[14:28] <masak> oh, but maybe you're not interested in the ways in which bases are ambiguous?

[14:30] <masak> what happens in the problem if two sequences have an ambiguous base at the same locus?

[14:31] <moritz> unspecified

[14:31] <moritz> erm, I meant to say: Mu

[14:31] <PerlJam> clearly you get a junction :)

[14:32] <masak> demons out my nose.

[14:33] <masak> reason I said "bitmask problem" was that my first view of the ambiguous base specifiers was that they represented bitmasks of ACGT possibles.

[14:33] <masak> and merging would then simply be some kind of joining (probably using infix:<+|>) of these.

[14:34] <masak> if I were to write a solution, I'd probably write one that did that.

[14:34] <moritz> nom: print for <A C G T> X~| <A C G T>

[14:34] <p6eval> nom 198513:  ( no output )

[14:34] <moritz> nom: .print for <A C G T> X~| <A C G T>

[14:34] <p6eval> nom 198513: OUTPUT«ACGUCCGWGGGWUWWT»

[14:34] <masak> you may or may not have taken me too literally there :P

[14:35] <moritz> nom: my %seen; %seen{$_} = 1 for (<A C G T> X~| <A C G T>); say %seen.keys.sort

[14:35] <p6eval> nom 198513: OUTPUT«A C G T U W␤»

[14:35] <masak> nom: say .ord.fmt("%b") for <A C G T>

[14:35] <p6eval> nom 198513: OUTPUT«1000001␤1000011␤1000111␤1010100␤»

[14:36] <masak> nom: say .ord.fmt("%b") for <U W>

[14:36] <p6eval> nom 198513: OUTPUT«1010101␤1010111␤»

[14:37] *** envi_ joined
[14:37] *** envi_ left
[14:37] *** envi_ joined
[14:38] *** kst left
[14:45] *** clsn joined
[14:50] *** bazqux left
[14:57] * masak liked http://avdi.org/talks/confident-code-rubymidwest-2011/

[14:58] <masak> it expresses something that I've wanted to be able to express for some time now.

[14:58] <masak> HN thread with link to video: http://news.ycombinator.com/item?id=3218882

[14:59] <clsn> Has this problem in rakudo been noted yet?  https://gist.github.com/1354278

[15:00] <moritz> oh noes, not another "for loops, recursion and lexicals mix badly" bug :(

[15:01] <masak> I thought we decided not to have any more of those

[15:01] <moritz> clsn: please submit that as a bug report to [email@hidden.address]
[15:01] *** simcop2387 left
[15:02] <clsn> Maybe we just shouldn't write so much with for loops and recursion.  Looping structures are for doing the same things over and over again anyway.  You should just do something right once and be done. :)

[15:02] <clsn> moritz: Thanks for letting me know it's worth reporting.

[15:02] <masak> waitwait.

[15:03] <masak> I agree with the lower output.

[15:03] <moritz> why? $h is declared inside sub recur

[15:03] <masak> yeah.

[15:03] <masak> on second thought, I don't.

[15:03] <moritz> $counter is shared, $h is private

[15:04] *** simcop2387 joined
[15:04] <masak> rakudo: my $c = 0; sub r($n) { return if !$n; $h = $c; r($n-1); say $h }; r 3

[15:04] <p6eval> rakudo 198513: OUTPUT«===SORRY!===␤Variable $h is not predeclared at line 1, near " = $c; r($"␤»

[15:04] <masak> rakudo: my $c = 0; sub r($n) { return if !$n; my $h = $c; r($n-1); say $h }; r 3

[15:04] <p6eval> rakudo 198513: OUTPUT«0␤0␤0␤»

[15:04] <masak> er :)

[15:05] <masak> rakudo: my $c = 0; sub r($n) { return if !$n; my $h = ++$c; r($n-1); say $h }; r 3

[15:05] <p6eval> rakudo 198513: OUTPUT«3␤2␤1␤»

[15:05] <masak> rakudo: my $c = 0; sub r($n) { return if !$n; my $h = 'h' ~ $c; $c++; r($n-1); say $h }; r 3

[15:05] * moritz wonders if a bisect could help

[15:05] <p6eval> rakudo 198513: OUTPUT«h2␤h1␤h0␤»

[15:05] <masak> hm

[15:06] <masak> rakudo: my $c = 0; sub r($n) { return if !$n; my $h = 'h' ~ $c; $c++; my @k = 1, 6; r($n-1); for @k { say $h } }; r 3

[15:06] <p6eval> rakudo 198513: OUTPUT«Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[15:06] <masak> o.O

[15:06] <PerlJam> perhaps I've seen too many commercials for Subway because all those Any() make me expect a subsequent "5 dollar foot long"

[15:07] <masak> rakudo: my $c = 0; sub r($n) { return if !$n; my $h = 'h' ~ $c; $c++; my @k = 1, 6; r($n-1); for @k { say "$_ and h is $h" } }; r 3

[15:07] <p6eval> rakudo 198513: OUTPUT«Use of uninitialized value in string context␤1 and h is ␤Use of uninitialized value in string context␤6 and h is ␤Use of uninitialized value in string context␤1 and h is ␤Use of uninitialized value in string context␤6 and h is ␤Use of uninitialized value in string …

[15:07] <clsn> I have written exactly one program more than a line or two long in perl6.  Every so often rakudo changes enough to break it (or sometimes fix it), and I have to see where I went wrong.

[15:07] * clsn sent the email.

[15:08] <masak> clsn: I used to feel that way about Rakudo two-three years ago.

[15:08] <masak> clsn: this bug of yours is quite unusual nowadays, and I'm surprised we don't have tests catching it.

[15:08] <clsn> Yeah, this one seemed awfully straightforward.

[15:09] <clsn> There's something else broken between those two rakudos; another thing making my program run wrong, but I haven't isolated the issue yet.

[15:09] <masak> rakudo: sub r { my $h = 'h'; my @k = 1, 6; for @k { say $h } }; r

[15:09] <p6eval> rakudo 198513: OUTPUT«h␤h␤»

[15:09] <clsn> It's probably something exasperating with pattern-matching.

[15:09] <masak> rakudo: my $c = 0; sub r { my $h = 'h' ~ $c; my @k = 1, 6; for @k { say $h } }; r

[15:09] <p6eval> rakudo 198513: OUTPUT«h0␤h0␤»

[15:09] <moritz> clsn: lots of regex things are broken in nom :(

[15:10] * masak is now terribly confused and needs to think before discussing further with p6eval

[15:10] <clsn> moritz: that's almost reassuring.  If people know they're broken, sooner or later they'll fix them (and my program might still be right.)

[15:10] <masak> I've seen three behaviors in a short time: clsn's h3-h3-h3 behavior, the correct behavior, and my Any-Any-Any behavior.

[15:10] <masak> I can't reproduce any of them reliably :/

[15:10] <clsn> Otherwise, I had it coded to the wrong understanding of the language before, and I have to figure out the new specs all over again.

[15:13] *** simcop2387 left
[15:14] <PerlJam> Is it just me or is nqp broken on the latest parrot?

[15:14] <moritz> in what way does it seem to be broken?

[15:15] *** simcop2387 joined
[15:15] <PerlJam> when compiling nqp I get: https://gist.github.com/1355083

[15:16] <moritz> is that nqp's master branch?

[15:16] <PerlJam> yes.

[15:18] * PerlJam needs an ever faster computer. 

[15:18] <PerlJam> I no longer have the patience to wait for compiles 

[15:19] <masak> clearly you need to become a Google Go programmer.

[15:20] <masak> or an assembler programmer, I guess.

[15:23] * moritz finds parrot and nqp compilation times acceptable

[15:23] <moritz> especially with ccache and parallelized make

[15:26] <moritz> b: https://gist.github.com/1354278

[15:26] <p6eval> b 1b7dd1: OUTPUT«1 and h is h3␤6 and h is h3␤h is h3␤1 and h is h2␤6 and h is h2␤h is h2␤1 and h is h1␤6 and h is h1␤h is h1␤1 and h is h0␤6 and h is h0␤h is h0␤»

[15:29] *** mishin left
[15:29] *** drbean left
[15:31] *** fsergot joined
[15:32] <fsergot> hi perl6! :) o/

[15:32] <slavik1> does the Mark L guy hang around here?

[15:35] *** drbean joined
[15:35] *** wolfman2000 joined
[15:39] <PerlJam> slavik1: Lehmann ?

[15:40] <daxim> schmorp thinks perl6 is the devil

[15:40] <[Coke]> schmorp?

[15:41] <masak> clsn: I just managed to reproduce your bug in nom HEAD.

[15:41] <slavik1> PerlJam: no, Mark Lentczner, the dude who made the periodic table of operators

[15:41] <masak> clsn: to me it looks like a stray OUTER pointer.

[15:41] <PerlJam> oh

[15:42] <clsn> I was reporting it in approximately nom head; whatever the most recent I happened to have on my latest pull.

[15:42] <clsn> So yeah, makes sense.

[15:43] *** sayu joined
[15:43] <slavik1> PerlJam: http://www.ozonehouse.com/mark/periodic/

[15:44] <slavik1> I am wondering if it's still accurate

[15:46] <moritz> it's two years old? probably not accurate anymore

[15:46] <moritz> for example it misses the Z meta operator

[15:48] <moritz> and the sequence operator, if present at all, will be outdated

[15:48] <moritz> lcm and gcd are missing

[15:48] <masak> nom: my $c; sub r($x) { my $h="h" ~ $c++; r $x-1 if $x; for 1 { say $h }; say "h is $h" }; r 3

[15:48] <p6eval> nom 198513: OUTPUT«h3␤h is h3␤h3␤h is h2␤h3␤h is h1␤h3␤h is h0␤»

[15:48] <masak> b: my $c; sub r($x) { my $h="h" ~ $c++; r $x-1 if $x; for 1 { say $h }; say "h is $h" }; r 3

[15:48] <p6eval> b 1b7dd1: OUTPUT«h3␤h is h3␤h2␤h is h2␤h1␤h is h1␤hAny()␤h is hAny()␤»

[15:48] <masak> golf'd!

[15:48] <masak> nom: my $c; sub r($x) { my $h="h" ~ $c++; r $x-1 if $x; say $h for 1; say "h is $h" }; r 3

[15:48] <p6eval> nom 198513: OUTPUT«h3␤h is h3␤h3␤h is h2␤h3␤h is h1␤h3␤h is h0␤»

[15:49] <masak> nom: my $c; sub r($x) { my $h = $c++; r $x-1 if $x; say $h for 1; say "h is $h" }; r 3

[15:49] <p6eval> nom 198513: OUTPUT«3␤h is 3␤3␤h is 2␤3␤h is 1␤3␤h is 0␤»

[15:49] <moritz> nom: my $c; sub r($x) { my $h = $c++; r $x-1 if $x; 1 for 1; say "h is $h" }; r 3

[15:49] <p6eval> nom 198513: OUTPUT«h is 3␤h is 2␤h is 1␤h is 0␤»

[15:50] <moritz> nom: my $c; sub r($x) { my $h = $c++; r $x-1 if $x; $h for 1; say "h is $h" }; r 3

[15:50] <p6eval> nom 198513: OUTPUT«h is 3␤h is 2␤h is 1␤h is 0␤»

[15:50] *** thou joined
[15:50] <masak> print $h in a for loop, and it comes out as 3

[15:50] <moritz> nom: my $c; sub r($x) { my $h = $c++; r $x-1 if $x; say $h for 1; }; r 3

[15:50] <p6eval> nom 198513: OUTPUT«3␤3␤3␤3␤»

[15:50] <sorear> good * #perl6

[15:51] <moritz> niecza: my $c; sub r($x) { my $h = $c++; r $x-1 if $x; say $h for 1; }; r 3

[15:51] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«3␤2␤1␤Any()␤»

[15:51] <moritz> \o sorear 

[15:52] <moritz> nom: my $t = ''; my $c; sub r($x) { my $h = $c++; r $x-1 if $x; $t ~= $h for 1; }; r 3; say $t

[15:52] <p6eval> nom 198513: OUTPUT«3333␤»

[15:52] <moritz> at least it's easy to turn into a test ;-)

[15:53] <moritz> niecza: my $t = ''; my $c = 0; sub r($x) { my $h = $c++; r $x-1 if $x; $t ~= $h for 1; }; r 3; say $t

[15:53] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«3210␤»

[15:53] <moritz> masak: do you still remember the number of that infamous ticket?

[15:54] *** drbean left
[15:54] <masak> 58392_

[15:54] <masak> ?

[15:54] <moritz> nom: my $t = ''; my $c; sub r($x) { my $h = $c++; r $x-1 if $x; for 1 { $t ~= $h }; }; r 3; say $t

[15:54] <p6eval> nom 198513: OUTPUT«3333␤»

[15:55] <moritz> masak: indeed

[15:55] <moritz> masak: thanks

[15:56] *** Trashlord left
[15:57] <benabik> PerlJam: I was able to replicate your build failure.

[15:57] *** Trashlord joined
[15:57] <masak> moritz: but this one is not identical, I think.

[15:57] <masak> this one is more benign and limited.

[15:58] <moritz> masak: but it's a good inspiration for where to put the test :-)

[15:58] *** pjcj left
[15:59] <moritz> nom: my $t = ''; my $c; sub r($x) { my $h = $c++; r $x-1 if $x; do { $t ~= $h }; }; r 3; say $t

[15:59] <p6eval> nom 198513: OUTPUT«3333␤»

[15:59] *** drbean joined
[15:59] <moritz> nom: my $t = ''; my $c; sub r($x) { my $h = $c++; r $x-1 if $x; $t ~= $h }; r 3; say $t

[15:59] <p6eval> nom 198513: OUTPUT«3210␤»

[15:59] *** daxim left
[16:00] <benabik> PerlJam: My backtrace had function names inside nqp_ops though.  Added it as a comment: https://gist.github.com/1355083#comments

[16:00] <moritz> so it needs to be just a block, not necessarily a loop

[16:00] *** icovnik left
[16:00] <dalek> roast: fe4c35b | moritz++ | S04-statements/for.t:

[16:00] <dalek> roast: RT #103332, for loops, lexicals and recursion

[16:00] <dalek> roast: review: https://github.com/perl6/roast/commit/fe4c35b3ee

[16:01] *** clairvy joined
[16:02] <masak> moritz: right. it's a block, and the block gets the OUTER wrong.

[16:04] *** vmspb left
[16:07] *** wtw left
[16:08] <cognominal> what is the Perl 6 equivalent of the PIR setprop?

[16:08] *** daxim joined
[16:08] <moritz> that is an odd question

[16:08] <moritz> cognominal: what do you want to accomplish?

[16:08] <sorear> pir::setprop(...)

[16:09] <cognominal> sorear: I forgot about pir::  :)

[16:09] <moritz> my first reaction was "traits", because it allows you to attach additional data to objects

[16:10] <cognominal> I don't care to expose it as an interface.

[16:10] * TimToady thinks complicated Match objects should probably gistify to yaml

[16:11] <masak> sounds reasonable.

[16:12] <TimToady> or yaml2  :)

[16:12] * moritz thinks complicated Match objects should .yaml to yaml

[16:12] <PerlJam> TimToady: did you just add yaml to the perl 6 spec?  :)

[16:12] <TimToady> no, I said "probably"  :P

[16:13] <masak> if the goal is to have a readable indented structure serialization, YAML is as good as any, IMO.

[16:13] <masak> no need to reinvent that wheel.

[16:13] <PerlJam> Sure, but I'm not aware of the probability distribution that you use for "probably"

[16:13] * moritz somehow never found yaml very readable

[16:14] <TimToady> it's better than the alternatives, is all

[16:16] <PerlJam> moritz: in what context have you seen yaml?  rails test fixtures?  There is some fairly complicated yaml out there that tries to scuttle the readability aspect.

[16:16] <moritz> PerlJam: catalyst config files

[16:17] <moritz> TBH I never read an explanation for what it does, but I didn't need that for JSON

[16:17] *** drbean left
[16:17] <flussence> (there's a yaml2?)

[16:17] <PerlJam> flussence: yeah, ingy is making yaml better

[16:18] * moritz hopes it reduces the spec size

[16:20] * TimToady hopes .perl gets prettier too

[16:20] *** pjcj joined
[16:22] *** drbean joined
[16:23] <moritz> in the long run it won't

[16:24] <moritz> for example if .perl is supposed to reproduce the difference between EnumMap and Hash, it will stay ugly, because we only have literals for one of them

[16:24] *** clairvy left
[16:24] * TimToady thinks about making .perl return eval :lang(yaml) q:to /END/ ...   :)

[16:25] *** clairvy joined
[16:26] *** alim left
[16:30] <TimToady> I'm not really saying that matches have to gistify to yaml in a completist sense like .perl must do, but that we can gistify matches in a much more readable format than we currently do, even while throwing some info away that .perl might keep

[16:30] *** clairvy left
[16:31] *** clairvy joined
[16:31] <TimToady> that's what .gist means, after all

[16:31] *** alim joined
[16:32] *** Sarten-X left
[16:32] * moritz wonders if $a.gist eq $b.gist becomes the new "loose eqv"

[16:32] *** alim left
[16:32] <moritz> fwiw I could build both nqp and rakudo on newest parrot

[16:32] <masak> TimToady: speaking of throwing info away -- how are these two things reconciled: (1) a Perl 5 to Perl 6 parser promises to retain as much information as possible, including, I suppose, comments. (2) we encourage people to do <.ws> in their grammars.

[16:32] <TimToady> well, might be the only way to compare two infinite sequences :)

[16:33] *** alim joined
[16:33] <mls> moritz: I wonder if Block.clone() should also clone the captured outer

[16:33] <TimToady> masak: poorly :)

[16:33] <TimToady> but there are some things worth doing poorly

[16:34] <masak> I'm still at the "at all" stage with this one, though.

[16:34] <masak> they seem directly at odds with one another, not just a little.

[16:34] <moritz> ah, that's why ops2c throws away comment from my .ops files :/

[16:34] <TimToady> are you asking about the places where the p5 programmer should have used /x but didn't?

[16:35] <masak> no, not at all.

[16:35] <TimToady> then I don't follow your question at all

[16:35] <masak> I'm saying how can a p52p6 translator translate whitespace correctly if it doesn't capture it?

[16:35] <PerlJam> moritz: I guess I'm going to with "it's just me" then.   I haven't built parrot/nqp/rakudo on this machine in a while and it was recently upgraded to ubuntu 11.10   so no telling what's going on.

[16:36] <TimToady> masak: STD can easily reproduce this info from the memos

[16:36] <moritz> PerlJam: but benabik reproduced it...

[16:36] <PerlJam> oh?  I didn't see.

[16:38] <TimToady> masak: and even in the absense of that, everything is marked with its .from and .to, so all you need do is substr the original string between tokens to get the whitespace, if you're interested in it

[16:38] <masak> TimToady: hm, ok.

[16:39] <mls> moritz: ok, now I'm confused. clone of a sub should clone the outer. I wonder why it fails here.

[16:39] <TimToady> whether a translator should reformat whitespace/comments is, of course, a decision that has to be made differently in different situations

[16:40] <TimToady> especially as you introducing refactoring options into your translator

[16:41] <TimToady> and a good translator is likely to introduce comments in various spots as well, saying "# I'm not 100% sure this is what you want here"

[16:41] <mls> moritz: ah, it doesn't work because the sub's outer is set at sub entry, but not restored at sub exit

[16:41] * TimToady is confused; surely an outer is set at compile tie, not run time

[16:41] <TimToady> *time

[16:42] <mls> yes, I meant "outer_ctx", not "outer_sub"

[16:42] *** Sarten-X joined
[16:43] <TimToady> is this parrotese for "dynamic context"?

[16:44] <mls> parrot implements a capture by cloning the sub and setting an "outer_ctx" attribute in the cloned sub.

[16:44] *** wolfman2000 left
[16:44] <mls> when the cloned sub is called, the "outer_ctx" will be made the "outer" of the current context

[16:46] *** simcop2387 left
[16:47] *** simcop2387 joined
[16:48] <mls> for some reason rakudo adds code to the beginning of every sub that calls capture_lex for every sub the code calls

[16:49] <mls> (I'm not sure why it is needed, the sub's outer() parameter should normally make sure that the context gets set correctly)

[16:49] <moritz> mls: might well be from a time when parrot's outer() handling was too buggy

[16:50] <mls> commenting out the capture_lex breaks the code, so they seem to be needed for something

[16:50] <moritz> mls: but I don't really grok the lexicals system, and codegen neither. So take my information with a rock of salt :-)

[16:51] <TimToady> might relate to S04:1746

[16:52] <mls> could be, yes. jnthn++ will know

[16:53] <mls> so I can explain what's going on, but I don't know the correct fix ;(

[16:54] *** daniel-s joined
[16:55] <TimToady> moritz: re http://irclog.perlgeek.de/perl6/2011-11-10#i_4685509 this might be helped with a Go-like strategy of keeping literals as their string repr until you know what context they're actually used in

[16:57] <TimToady> of course, that only helps if you don't actually use the literals before the type is available :)

[16:57] <moritz> ... and that kinda is the problem :-)

[16:58] <moritz> Int literals are pretty much everywhere

[16:59] <TimToady> heh, I'm definitely "a perfectionist with no ability to prioritize"  :)

[17:01] * masak decommutes

[17:02] * [Coke] wonders if TimToady is committed to yaml over, say, JSON.

[17:02] <TimToady> they both have their ups and downs

[17:03] * TimToady has no ability to prioritize, remember :P

[17:03] * [Coke] tends to prefer JSON, but Coke is ostensibly a web developer.

[17:03] <japhb> moritz: have not backlogged, but noticed your code review request.  Will look at it now.

[17:03] <benabik> JSON is good for simple structures.  YAML has nice things like types and loops.

[17:03] <[Coke]> TimToady: Oh, I'd tend to agree. ;)

[17:04] <PerlJam> I've found being able to refer to parts of the yaml doc in other parts of the yaml doc is quite nice

[17:04] *** overrosy left
[17:05] <PerlJam> [Coke]: and since ingy isn't here ...  JSON *is* YAML  ;)

[17:05] *** overrosy joined
[17:06] <benabik> I seem to recall somebody mentioning a new version of the YAML spec.  Or was I hallucinating?

[17:06] <[Coke]> Does he mean that in a literal sense or a "everything you can do, I can do better^Wtoo." ?

[17:06] <PerlJam> benabik: https://github.com/yaml/YAML2

[17:06] <TimToady> ingy-san announced the yaml2 effort a mere 2ish weeks ago

[17:06] <benabik> PerlJam++

[17:08] <TimToady> and I was the first to hear it, on the train to SFPM, where it was officially announced

[17:09] <TimToady> or maybe I was second, if rafl knew it already

[17:09] <cognominal> TimToady, not all projecta take a decade to accomplish :)

[17:09] <TimToady> we still don't know if Perl 6 takes a decade to accomplish :)

[17:10] <TimToady> might take two...

[17:10] <TimToady> or ten :)

[17:11] <TimToady> in fact, that's kinda the plan

[17:12] *** mj41 left
[17:12] <TimToady> c.f. "100-year language"

[17:13] *** evhan joined
[17:13] <cognominal> agreed, but I am hoping that by this christmas we will have a useful rakudo. What was perl 1 for the previous generation.

[17:14] <PerlJam> rakudo isn't useful now?

[17:14] <TimToady> um, it's already that useful

[17:14] <cognominal> …for a larger population

[17:14] <cognominal> beyond the current happy few.

[17:15] <TimToady> well, you have to convert the sysadmins before you convert the webdevs, and that'll take a Perl 4 equivalent at least :)

[17:15] <PerlJam> I never used perl 1, but I remember when perl 5 was released.  It seemed like it was in flux for a year or two before it became "useful for the general population"

[17:16] <abercrombie> When will be the next version released? Ever since 2011.07

[17:16] *** bluescreen10 left
[17:16] <PerlJam> abercrombie: you mean Rakudo Star?

[17:16] <abercrombie> No, just a release version

[17:17] <TimToady> abercrombie: try niecza if you can't wait for nom to stabiliz; it's officially released once a month

[17:17] <TimToady> and it's pretty zippy

[17:18] <PerlJam> abercrombie: I did the Oct release of Rakudo just a few weeks ago.

[17:18] *** sayu left
[17:18] <abercrombie> Oh, I didn't see it on rakudo.org

[17:18] <PerlJam> probably because I forgot to update it.

[17:19] <TimToady> abercrombie: also, you should not complain about the delay of a new Rakudo Star much, because it depends on health issues in pmichaud++'s family that he has no control over

[17:19] <TimToady> and we have told him in no uncertain terms that is priority is his family, not getting the next Rakudo Star out

[17:19] <TimToady> *his

[17:19] <cognominal> pmichaud++

[17:19] <abercrombie> I never complain about it. As pmichaud posted on rakudo.org, "rather than rush out a buggy release we’ve decided to spend a few more days cleaning things up a bit"

[17:20] <TimToady> abercrombie: "Ever since 2011.07" sounds like a complaint to me :)

[17:20] <abercrombie> Oh, I didn't mean that.

[17:21] <abercrombie> Sorry.

[17:22] <TimToady> ah, well, human languages are always a bit lossy...

[17:23] <abercrombie> definitely.

[17:24] <abercrombie> So now rakudo: in p6eval is 2011.10 ?

[17:25] <japhb> moritz: In bigint's Str.Numeric(), why on lines 257-258 do you say '$base.Int'?  It's already an Int, right?

[17:25] <japhb> And FWIW, jnthn's nqp::radix_I looked sane, though I'm not really qualified WRT tommath bits.

[17:26] <japhb> er, nqp_bigint_radix()

[17:29] *** MayDaniel joined
[17:31] *** bluescreen10 joined
[17:31] *** clairvy left
[17:32] *** clairvy joined
[17:33] <mls> hah! that test case is also nice to demonstrate that parrot's auto-clone is wrong. It has exactly the same bug as in rakudo

[17:34] <mls> (it stores the "latest" context in the sub and uses it for auto-close. I suspeced that this was wrong some weeks ago, but couldn't find a counter example. now I have one ;) )

[17:34] *** clairvy left
[17:35] *** clairvy joined
[17:36] <mls> (which also means that simply removing the "capture_lex" statements doesn't work. Also, because rakudo clones the sub before storing it in the lex, so the auto-close does not find the correct context)

[17:37] *** clairvy left
[17:38] <mls> (which also means that parrot's auto close is very broken as it can't deal with cloned subs ;( )

[17:41] *** lichtkind joined
[17:45] *** clairvy joined
[17:47] <TimToady> masak: maybe you should translate http://avdi.org/talks/confident-code-rubymidwest-2011/ to Perl 6 and see how it fares :)

[17:51] <PerlJam> TimToady: including or excluding the monkey patching?  :-)

[17:51] *** clairvy left
[17:51] <TimToady> -Ojoy

[17:52] *** molaf joined
[17:54] *** clairvy joined
[17:54] <cognominal> without a bill

[17:55] <TimToady> usually there's one bill too many...

[17:57] *** vmspb joined
[18:01] *** bluescreen10 left
[18:01] *** clairvy left
[18:02] *** daniel-s left
[18:02] *** bluescreen10 joined
[18:03] *** drbean left
[18:03] <PerlJam> that whole section on null and nil reminds me of Rich Hickey's Simple Made Easy

[18:03] *** daxim left
[18:04] *** dakkar left
[18:04] *** clairvy joined
[18:06] *** alim left
[18:06] *** kst joined
[18:06] *** clairvy left
[18:07] *** ab5tract joined
[18:08] *** bluescreen10 left
[18:09] *** bluescreen10 joined
[18:09] <lichtkind> moritz: ping

[18:10] *** drbean joined
[18:15] <lichtkind> masak: cheers all changes done

[18:17] *** clairvy joined
[18:23] *** wk left
[18:25] *** domm left
[18:27] <mls> moritz: I created two PIR test cases that show both problems (the recursion problem, and the "why capture_lex is needed" problem)

[18:27] *** clairvy left
[18:27] <mls> I'll try to find a solution tomorrow

[18:27] <mls> -> home

[18:27] *** clairvy joined
[18:33] *** MayDaniel left
[18:34] *** risou is now known as risou_awy

[18:34] *** icovnik joined
[18:41] <ingy> perl6 + yaml == ♥ :)

[18:41] * ingy gets to work on it...

[18:43] <ingy> fyi, this is a nice little tool that some hackers who just ported YAML to JS whipped up: http://nodeca.github.com/js-yaml/

[18:44] <ingy> the port was pyyaml to node.js originally, but now works in browser js-s

[18:45] <lichtkind> cheers ingy

[18:52] *** pjcj left
[18:53] *** pjcj joined
[18:55] *** lichtkind left
[18:56] *** lichtkind joined
[19:17] *** wk joined
[19:18] *** envi_ left
[19:25] *** am0c left
[20:03] <masak> evening, #perl6.

[20:03] <diakopter> o/

[20:04] <masak> lichtkind: I've forgotten what changes you mean, but I'm glad they're all done ;)

[20:05] *** Chillance joined
[20:10] <moritz> japhb: ah, the .Int is a fossil

[20:14] <japhb> gotcha

[20:14] <lichtkind> masak: i fixed my slides and uploaded as well as added % ans %% to the tablets

[20:16] <lichtkind> masak: and fixed ** in index A and B

[20:18] <masak> lichtkind: nice! cool!

[20:18] <masak> lichtkind++

[20:18] <masak> perl6: say Nil.Array

[20:18] <p6eval> niecza v11-22-gbebf7a0: OUTPUT«Unhandled exception: Unable to resolve method Array in class Nil␤  at /tmp/hlshtujl0z line 1 (mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2224 (ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2225 (module-CORE @ 58) ␤  at /home/…

[20:18] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/18XdXUl_4K line 1, column 5 - line 2, column 1␤»

[20:18] <p6eval> ..rakudo 198513: OUTPUT«␤»

[20:18] <lichtkind> masak: thanks but thats was the least, have to do much more

[20:18] <masak> rakudo: say Nil.Array.perl

[20:18] <p6eval> rakudo 198513: OUTPUT«Array.new()␤»

[20:18] <masak> rakudo++

[20:19] <masak> perl6: say Array(Nil).perl

[20:19] <p6eval> rakudo 198513: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Array' called (line 1)␤»

[20:19] <p6eval> ..niecza v11-22-gbebf7a0: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Array␤  at /tmp/DKGliZuEi2 line 1 (mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2224 (ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2225 (module-CORE @ …

[20:19] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&Array"␤    at /tmp/8aaJfwcijs line 1, column 5 - line 2, column 1␤»

[20:19] <dalek> rakudo/bigint: eab4d7a | moritz++ | src/core/Str.pm:

[20:19] <dalek> rakudo/bigint: remove fossil noticed by japhb++

[20:19] <dalek> rakudo/bigint: review: https://github.com/rakudo/rakudo/commit/eab4d7a6f9

[20:19] <masak> triple FAIL.

[20:21] <masak> lichtkind: it's funny how information gets propagated. my talk wasn't even really about % and %%, I just mentioned them in passing ;)

[20:23] <masak> true or false: ceteris paribus, a routine that doesn't use self shouldn't be a method. discuss. :)

[20:23] <moritz> not true in general, because of interface consistency

[20:24] <moritz> ie it's an implementation detail if a method uses self or not

[20:24] <masak> that's a fine argument in the abstract. I can't think of a concrete example, though. can you?

[20:24] <diakopter> false, because of the convenience in accessing so-called static methods with the .methodname suffix instead of typing the class name. also, for inherited "static" methods.

[20:25] <masak> diakopter: interesting. so -- using classes but not for their objects?

[20:25] <masak> I don't think I've seen that style of coding in Perl 6.

[20:25] <lichtkind> masak: even more funny it just started as impulse by me to talk about **, if there is any other thing happened in last 6 months?

[20:26] <diakopter> masak: yeah, using classes for interacting with their private static data

[20:26] <lichtkind> % is even from logic good because in math its also whats left from division

[20:26] <masak> lichtkind: check the git log of the 'specs' repo :)

[20:26] <diakopter> locals declared in the class body

[20:26] <masak> diakopter: right.

[20:27] <masak> perl6: class A { my $a = 42; method foo { say $a } }; class B is A {}; A.foo

[20:27] <masak> er.

[20:27] <masak> perl6: class A { my $a = 42; method foo { say $a } }; class B is A {}; B.foo

[20:28] <diakopter> o_O

[20:28] <abercrombie> niecza: say "a"

[20:28] <diakopter> p6eval decided to take a nap.  a dirt nap.

[20:29] *** am0c joined
[20:29] <diakopter> masak: maybe a better example would be what you wrote above but calling B.foo from a method in B that does use self

[20:30] *** aindilis` joined
[20:30] <diakopter> er, calling self.foo

[20:30] <diakopter> if p6eval ever wakes up

[20:31] *** p6eval left
[20:31] <masak> diakopter: right.

[20:32] <masak> I do see the use for it.

[20:32] <tadzik> 'evening!

[20:33] *** p6eval joined
[20:33] *** ChanServ sets mode: +v p6eval

[20:33] *** aindilis left
[20:33] <masak> tadzik! \o/

[20:34] <tadzik> lol! masak!

[20:34] <masak> lol!

[20:34] <masak> perl6: class A { my $a = 42; method foo { say $a } }; class B is A { method bar { self.foo } }; B.bar

[20:34] <p6eval> rakudo 198513, niecza v11-22-gbebf7a0: OUTPUT«42␤»

[20:34] <p6eval> ..pugs b927740: OUTPUT«␤»

[20:34] <masak> pugs--

[20:37] <cognominal> masak, you should respect the elders

[20:40] <masak> indeed. slightly unfair of me.

[20:40] <masak> I do plan to fix it at some point, though ;)

[20:40] <masak> nom: .say for "aarrff!", { my @a = .comb; @a[(^@a).pick].=uc until @a.join ne $_; @a.join } ... { $_ eq .uc }

[20:40] <p6eval> nom 198513: OUTPUT«aarrff!␤aarrFf!␤aaRrFf!␤aaRRFf!␤aaRRFF!␤AaRRFF!␤AARRFF!␤»

[20:41] <masak> I'm sure there are more elegant ways to write that.

[20:41] <tadzik> that's pretty cool

[20:43] <masak> nom: say my $s = "aarrff!"; for (^6).pick(*) { say $s = ((my @a = $s.comb)[$_].=uc; @a.join) }

[20:43] <p6eval> nom 198513: OUTPUT«aarrff!␤Aarrff!␤AarRff!␤AarRfF!␤AarRFF!␤AaRRFF!␤AARRFF!␤»

[20:44] <masak> much better ;)

[20:46] <masak> nom: say my $s = "aarrff!"; say $s = ((my @a = $s.comb)[$_].=uc; @a.join) for (^6).pick(*)

[20:46] <p6eval> nom 198513: OUTPUT«aarrff!␤aarRff!␤AarRff!␤AarRfF!␤AarRFF!␤AArRFF!␤AARRFF!␤»

[20:49] <masak> nom: say my $s = "aarrff!"; -> $i { say $s = (.[$i].=uc; .join) given $s.comb } for (^6).pick(*)

[20:49] <p6eval> nom 198513: OUTPUT«aarrff!␤Cannot assign to a non-container␤  in method dispatch:<.=> at src/gen/CORE.setting:730␤  in block <anon> at /tmp/dhRpFnqygY:1␤  in block <anon> at /tmp/dhRpFnqygY:1␤  in method reify at src/gen/CORE.setting:4007␤  in method reify at src/gen/CORE.setting:3914␤ …

[20:49] <masak> dang ;)

[20:49] <masak> I suspected that might happen.

[20:50] <masak> oh well, it wasn't really shorter anyway.

[20:50] *** benabik left
[20:51] *** _ilbot left
[20:51] *** moritz left
[20:51] *** yath left
[20:51] *** moritz joined
[20:53] *** benabik joined
[20:59] *** _ilbot joined
[21:01] *** yath joined
[21:02] <lichtkind> masak: yes had to fic my git config but now I cat fetch specs again easily

[21:11] <fsergot> masak, however, good job. :)

[21:17] *** bluescreen100 joined
[21:18] *** Mowah_ left
[21:18] *** bluescreen100 left
[21:18] *** bluescreen10 left
[21:30] <jnthn> evenin', #perl6

[21:30] <tadzik> hey, jnthn!

[21:31] * jnthn went to an event with free beer this evening :)

[21:32] <masak> jnthn! \o/

[21:33] <moritz> \o

[21:35] <moritz> jnthn: http://irclog.perlgeek.de/perl6/2011-11-10#i_4685509 when your mind turns to p6 again :-)

[21:35] *** krakan left
[21:36] <jnthn> moritz: Well, it's a little distracted on @other, but I'll take a look ;)

[21:36] <jnthn> moritz: I saw your commits :)

[21:37] *** krakan joined
[21:37] <jnthn> "I see some difficulties with parsing Int literals. We need to have a bigint type available in Actions.pm to create the Int constants from literals"

[21:37] <jnthn> The point is that we *do* have them! :)

[21:37] <jnthn> $*ST.find_symbol(['Int']) # gets the Int type object

[21:37] <jnthn> That's why Int is set up in BOOTSTRAP :)

[21:38] <PerlJam> jnthn is going to invent a time machine?

[21:39] <jnthn> PerlJam: No, I just worked out the bootstrap ;)

[21:43] <masak> \o/

[21:43] <masak> the bootstrap worked out the bootstrap!

[21:43] <tadzik> Bootstrap's bootstraps

[21:44] <masak> tadzik: I'M TELLIN' THE STORY!

[21:44] <PerlJam> All I know is that none of the boots I've ever owned or used or seen have straps of any kind.

[21:44] <tadzik> masak: I'M PLAYING THE SOUNDTRACK!

[21:44] <masak> "we're really bad eggs..."

[21:45] * masak plays the soundtrack, too

[21:45] <tadzik> oh, it's hier: http://www.youtube.com/watch?v=AacMBXI2tw8

[21:46] <tadzik> oh, "I'M TELLIN' THE STORY!" is a quote

[21:47] <masak> tadzik: yes. sorry if that wasn't clear ;)

[21:48] <tadzik> I fail at remembering those

[21:48] <tadzik> especially if I watched it in Polish :P

[21:48] <masak> oh!

[21:48] <masak> dubbing--

[21:48] <tadzik> recently I'm watching films with english subtitles. I still fail at hearing

[21:49] <masak> it's a matter of practice.

[21:49] <tadzik> probably. I should be watching more films

[21:49] <tadzik> or going to more conferences

[21:49] <masak> the subtitles can be distracting, because there's always something that the translation agency gets wrong :/

[21:50] <tadzik> oh I know that

[21:51] *** ab5tract left
[21:57] *** vmspb left
[21:58] <lichtkind> o/ tadzik 

[21:58] *** thou left
[21:58] <tadzik> hey lichtkind!

[22:08] *** thou joined
[22:16] *** abercrombie left
[22:16] *** thou left
[22:17] *** thou joined
[22:39] *** donaldh joined
[22:39] *** donaldh left
[22:40] *** packetknife joined
[22:41] *** wolfman2000 joined
[22:45] *** cafesofie joined
[22:47] *** packetknife left
[22:57] *** mj41 joined
[22:57] *** whiteknight joined
[22:58] *** whiteknight is now known as Guest53729

[22:59] *** alvis left
[23:11] *** buubot_backup left
[23:11] *** clairvy left
[23:11] <masak> good night, #perl6

[23:12] <diakopter> o/

[23:13] *** clairvy joined
[23:15] *** alvis joined
[23:16] *** mj41 left
[23:21] *** donaldh joined
[23:22] *** donaldh left
[23:30] *** am0c left
[23:31] *** Trashlord left
[23:31] *** clairvy left
[23:32] *** clairvy joined
[23:33] *** buubot_backup joined
[23:43] *** lichtkind left
[23:47] *** wolfman2_ joined
[23:49] <[Coke]>  -> (16:16) From Sue D. Nymme [meh], to perl:                                   

[23:49] <[Coke]>  - Crazy Perl Idea #433:  if/unless/else/elsif blocks should allow redo/next/las

[23:49] <[Coke]>  - t.  <redo> would jump back to the top of the <if> condition to have it       

[23:49] <[Coke]>  - re-evaluated; <next> would jump forward to the <else> (or next <elsif>), and 

[23:49] <[Coke]>  - <last> would jump out of the construct entirely (to the point right after    

[23:49] <[Coke]>  - the last <else>/<elsif> block).                                              

[23:50] *** wolfman2000 left
[23:52] <[Coke]> here's his next crazy idea:

[23:52] <[Coke]>  - YourLabel: while (condition) { say "iteration number ", YourLabel.count; if  

[23:52] <[Coke]>  - (foo) { YourLabel.next } etc }                                               

[23:59] <flussence> I've come across a few situations where being able to jump to the next of a chain of if/elsif/else would've made my code considerably less messy...

