[00:00] *** jaldhar joined
[00:03] *** whiteknight left
[00:03] *** risou is now known as risou_awy

[00:04] *** whiteknight joined
[00:04] *** lichtkind left
[00:12] *** lichtkind joined
[00:13] <lichtkind> nom: say 1..5

[00:13] <p6eval> nom ebd495: OUTPUT«1..5␤»

[00:14] <djanatyn> :)

[00:14] <lichtkind> nom: say (1..5)

[00:14] <p6eval> nom ebd495: OUTPUT«1..5␤»

[00:14] <lichtkind> nom: say list(1..5)

[00:14] <p6eval> nom ebd495: OUTPUT«1 2 3 4 5␤»

[00:14] <lichtkind> nom: say list(1,2...5)

[00:14] <p6eval> nom ebd495: OUTPUT«1 2 3 4 5␤»

[00:14] <lichtkind> nom: say list(0,1, $^a + $^b ...13)

[00:15] <p6eval> nom ebd495: OUTPUT«Nominal type check failed for parameter '$a'; expected Any but got Mu instead␤  in sub infix:<+> at src/gen/CORE.setting:1821␤  in <anon> at /tmp/6PUPDFS8t9:1␤  in <anon> at /tmp/6PUPDFS8t9:1␤␤»

[00:15] <lichtkind> nom: say list(0,1, * + * ...13)

[00:15] <p6eval> nom ebd495: OUTPUT«0 1 1 2 3 5 8 13␤»

[00:15] <lichtkind> nom: say list(1,2, * * * ... 32)

[00:15] <p6eval> nom ebd495: OUTPUT«1 2 2 4 8 32␤»

[00:16] <lichtkind> too weird

[00:17] <lichtkind> nom: say list(1,2, $^a * * ... 32)

[00:17] <p6eval> nom ebd495: OUTPUT«Nominal type check failed for parameter '$a'; expected Any but got Mu instead␤  in sub infix:<*> at src/gen/CORE.setting:1829␤  in whatevercode <anon> at /tmp/Hab2M6oaq0:1␤  in sub generate at src/gen/CORE.setting:6897␤  in sub coro at src/gen/CORE.setting:3728␤  in m…

[00:17] <lichtkind> autogenerated positional should work here

[00:18] <lichtkind> niecza: say list(1,2, * * * ... 32)

[00:18] <p6eval> niecza v8-65-g4e8d22a: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'list' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤  …

[00:18] <lichtkind> niecza: say list(1.. 32)

[00:18] <p6eval> niecza v8-65-g4e8d22a: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'list' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤  …

[00:19] <lichtkind> good night

[00:19] *** lichtkind left
[00:23] <ruz> std: grammar G { <?.boo> }

[00:23] <p6eval> std e3c970e: OUTPUT«ok 00:01 118m␤»

[00:23] <ruz> std: grammar G { <.?boo> }

[00:23] <p6eval> std e3c970e: OUTPUT«ok 00:01 118m␤»

[00:29] *** frhodes left
[00:29] *** frhodes joined
[00:29] <TimToady> std: / <????????????????????????????????.boo> /

[00:29] <p6eval> std e3c970e: OUTPUT«===SORRY!===␤Unable to parse metachar at /tmp/HRCr2dzk1Z line 1:␤------> / ⏏<????????????????????????????????.boo> /␤Couldn't find final '>'; gave up at /tmp/HRCr2dzk1Z line 1:␤------> / <???⏏???????????????????????…

[00:30] <TimToady> std: / <!!!!!!!!!.boo> /

[00:30] <p6eval> std e3c970e: OUTPUT«===SORRY!===␤Unable to parse metachar at /tmp/EQIJXwf3Pl line 1:␤------> / ⏏<!!!!!!!!!.boo> /␤Couldn't find final '>'; gave up at /tmp/EQIJXwf3Pl line 1:␤------> / <!!!⏏!!!!!!.boo> /␤Parse failed␤FAILED 00:01 11…

[00:30] <TimToady> std: / <!!.boo> /

[00:30] <p6eval> std e3c970e: OUTPUT«ok 00:01 120m␤»

[00:30] <TimToady> std: / <!!!.boo> /

[00:30] <p6eval> std e3c970e: OUTPUT«===SORRY!===␤Unable to parse metachar at /tmp/oH9ajkwWs6 line 1:␤------> / ⏏<!!!.boo> /␤Couldn't find final '>'; gave up at /tmp/oH9ajkwWs6 line 1:␤------> / <!!!⏏.boo> /␤Parse failed␤FAILED 00:01 119m␤»…

[00:30] <TimToady> std: / <!!!> /

[00:30] <p6eval> std e3c970e: OUTPUT«ok 00:01 119m␤»

[00:31] *** thou left
[00:33] <ruz> TimToady: <.?boo> is incorrect syntax, right?

[00:33] <TimToady> std: say $_.?foo

[00:33] <p6eval> std e3c970e: OUTPUT«ok 00:01 119m␤»

[00:34] <TimToady> looks like an optional method call

[00:34] *** frhodes left
[00:34] <TimToady> not sure what its semantics should be, probably fail the match if the .? doesn't find a method

[00:35] <TimToady> this is unspecced though

[00:35] <ruz> TimToady: but it's not a code block

[00:35] <TimToady> it's just a method call to a grammar method/rule

[00:35] <ruz> then <?boo> should be optional function/code call

[00:35] <TimToady> <? means something else

[00:35] <ruz> yes

[00:35] <TimToady> <. means method call

[00:36] <ruz> <foo> can call sub/method, right?

[00:36] <TimToady> yes, but it also captures

[00:36] <TimToady> <.foo> doesn't capture

[00:37] <ruz> all this kinda inconsistent even if it has some background

[00:37] <TimToady> we've had it many other inconsistent ways, and this seems to work pretty well :)

[00:38] <ruz> std: /<.foo=.bar>/

[00:38] <p6eval> std e3c970e: OUTPUT«ok 00:01 120m␤»

[00:38] <TimToady> that's probably not doing what you think

[00:39] <TimToady> std: /<.foo = .bar>/

[00:39] <p6eval> std e3c970e: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter (must be quoted to match literally) at /tmp/44tpUUQHa6 line 1:␤------> /<.foo =⏏ .bar>/␤Can't call method "from" on unblessed reference at /usr/local/share/perl/5.10.1/STD.pm line 5378…

[00:39] <TimToady> either that, or it's not doing what I think :)

[00:39] *** wolfman2000 joined
[00:39] <ruz> just trying a few bits from weekend spec/nqp code reading

[00:46] *** envi joined
[00:47] <TimToady> yeah, that parse is probably a bit infelicitous...

[00:51] <TimToady> method should not be delegating to assertion

[00:57] <ruz> std: / <?.?foo> /

[00:57] <p6eval> std e3c970e: OUTPUT«===SORRY!===␤Unable to parse metachar at /tmp/ZT20RhddDu line 1:␤------> / ⏏<?.?foo> /␤Couldn't find final '>'; gave up at /tmp/ZT20RhddDu line 1:␤------> / <?.⏏?foo> /␤    expecting any of:␤     assertion␤      dotty me…

[00:58] <TimToady> so <.?foo> is not being parsed like .?foo

[00:58] <ruz> yep

[00:58] <TimToady> if assertion:method parsed its own method, it would, and would also disallow <.foo=.bar>

[00:58] <TimToady> so that's probably what oughta happen

[00:59] <TimToady> niecza: / <.foo=.bar> /

[00:59] <p6eval> niecza v8-65-g4e8d22a:  ( no output )

[01:06] <ruz> std: /<before>/

[01:06] <p6eval> std e3c970e: OUTPUT«===SORRY!===␤before requires an argument at /tmp/HfQLJwiFpw line 1:␤------> /<before⏏>/␤    expecting assertion␤Parse failed␤FAILED 00:01 119m␤»

[01:07] *** woosley joined
[01:07] *** silug left
[01:08] *** silug joined
[01:15] <dalek> niecza: 6c0c55a | sorear++ | docs/announce.v9:

[01:15] <dalek> niecza: Add v9 announce

[01:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6c0c55a27a

[01:16] <sorear> request for comments

[01:17] *** abercrombie joined
[01:20] *** jferrero left
[01:24] *** whiteknight left
[01:28] *** awwaiid joined
[01:30] <TimToady> looks pretty good

[01:39] *** agentzh joined
[01:39] *** agentzh left
[01:39] *** agentzh joined
[01:44] *** yarp joined
[01:44] *** sftp_ left
[01:49] <colomon> so, slightly random point... I'm trying to run the ABC module in nom, and I'm getting an error.  Okay, that's totally expected.  What I hadn't expected is that the fatal error is getting printed to STDOUT, not STDERR.

[01:54] *** uasi joined
[01:54] *** araujo joined
[02:02] *** sili left
[02:02] *** bluescreen10 left
[02:12] *** soh_cah_toa left
[02:15] *** tokuhirom left
[02:17] *** tokuhirom joined
[02:21] *** lateau_ left
[02:22] *** abercrombie left
[02:27] *** soh_cah_toa joined
[02:33] *** Sarten-X left
[02:33] *** drbean joined
[02:48] *** tokuhirom left
[02:50] *** Sarten-X joined
[02:53] *** drbean left
[02:54] *** tokuhirom joined
[02:58] <djanatyn> Is it currently possible to generate a windows executable for a perl6 program?

[02:59] <djanatyn> Or am I going to have to wait a few years for that?

[03:02] <plobsing> djanatyn: how "real" does the executable need to be?

[03:03] <plobsing> it should be fairly simple to make a stub executable that unpacks a perl6 implementation and your sourcecode and then executes it inplace

[03:04] <plobsing> fwiw, that's how parrot generates rakudo's perl6 executable

[03:04] <plobsing> more or less

[03:04] <djanatyn> plobsing: How trivial would that be, and how large would the resulting executable (and any other files required) be, at minimum?

[03:06] *** jferrero joined
[03:07] *** eiro left
[03:07] *** eiro joined
[03:08] <tadzik> hello #perl6

[03:09] <plobsing> djanatyn: there would be no other files (it self-extracts everything it needs)

[03:09] <plobsing> as a result, probably very large

[03:10] <djanatyn> Any estimates, in terms of megabytes? :)

[03:11] <djanatyn> I know py2exe, which turns python programs into windows executables, does something similar.

[03:11] <plobsing> well, rakudo clocks in at 10M right off the bat

[03:12] <plobsing> djanatyn: I was thinking of PAR 

[03:12] <djanatyn> It includes a tiny python distribution with the file.

[03:12] <djanatyn> Ah, I played with that for a bit.

[03:12] <djanatyn> I could never get it to work >_>

[03:12] <djanatyn> eventually, I had a friend help me out.

[03:13] *** sili joined
[03:13] <djanatyn> Hmm.

[03:15] *** wolfman2000 left
[03:16] <plobsing> how important is it to generate a true executable? you could always change the filetype association appropriately.

[03:21] *** tokuhirom left
[03:23] *** tokuhirom joined
[03:31] <djanatyn> So, when you're using string interpolation and put a statement inside a bracket in perl6, it executes the code inside and replaces it with the return value?

[03:32] <PerlJam> djanatyn: aye

[03:32] <djanatyn> I was playing around with it, and if you put a statement inside with side effects that alter other variables, the return value is what is represented inside the string, but the other variables persist with whatever effect the statement had on them.

[03:32] <djanatyn> THat's cool.

[03:32] <djanatyn> I'm starting to think Perl 6 has the coolest string interpolation, like TimToady said :D

[03:32] <PerlJam> Perl 6 is cool in many respects.

[03:39] <djanatyn> Indeed.

[03:41] <sorear> yeah, we almost don't need (s)printf

[03:41] <PerlJam> almost

[03:42] <sorear> Does Windows have a good solution for third-party shared libraries yet?

[03:43] * sorear wants to see an 8kb stub-executor that can be attached to Perl 6 programs and functions by downloading parrot.dll and perl6.pbc from the Internet

[03:44] <sorear> iff they are not already cached on the user's machine somewhere

[03:44] <sorear> without OS support it would have to be bigger, and less correctly working

[03:47] *** yarp left
[03:50] <mberends> many Windows applications begin with a setup.exe sized 1~3MB on your machine, which then phones home and pulls in the full product.

[03:50] <sorear> djanatyn: incidentally, niecza v8 can create Windows .exe files

[03:51] <djanatyn>  :o

[03:51] <djanatyn> that's awesome.

[03:51] <djanatyn> One of the biggest difficulties I've had with programming is porting quickly and cleanly.

[03:51] <sorear> not strictly standalone as they require at least 3 of the Niecza .dlls

[03:51] <sorear> note, this feature is not in v9

[03:51] <djanatyn> I write code that works great and fine on my computer, but I can't get it working anywhere else.

[03:51] <sorear> djanatyn: the technical term for that is "deployment"

[03:52] <sorear> porting is when you modify your program so that it will run on different *kinds* of computer

[03:53] *** rlpowell joined
[03:53] <rlpowell> p6eval: "hello { my $foo = 'world' }";

[03:53] *** tokuhirom left
[03:53] <rlpowell> perl6: say "hello { my $foo = 'world' }";

[03:53] <p6eval> pugs, rakudo a55346: OUTPUT«hello world␤»

[03:53] <p6eval> ..niecza v8-66-g6c0c55a: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/gGonNc_5tQ line 1:␤------> say "hello { my ⏏$foo = 'world' }";␤␤hello world␤»

[03:53] <PerlJam> it's really weird to me that pugs gets that one right.

[03:54] <sorear> hello and welcome, rlpowell

[03:54] <djanatyn> Yep, that's the way it works, rlpowell.

[03:54] <djanatyn> He didn't believe me about string interpolation in perl 6 :D

[03:54] <rlpowell> wow.  My respect for p6 has just dropped through the floor.

[03:54] <djanatyn> ...interesting.

[03:54] <rlpowell> Sorry, I don't mean to be offensive, but without context that's really awful.

[03:54] <PerlJam> rlpowell: why is that?

[03:55] <rlpowell> Can someoen explain to me why that interpolation occurs, and how that doesn't boil down to "You can't ever have any special characters in any string ever because all strings interpolate theentire language?

[03:55] <rlpowell> I have no p6 context *at all*, so this is kind of drive-by dickery on my part; blame djanatyn  :)

[03:55] <djanatyn> I'm just spreading the perl 6 gospel! ^_^;

[03:55] <PerlJam> rlpowell: the interpolation occurs because that's how it's designed.

[03:56] *** tokuhirom joined
[03:56] <sorear> Perl historically has had magic characters in "" strings

[03:56] <rlpowell> Well, yes, I caught that.  But is it just "any P6 in your strings gets evaluated"?, or is there more to it?

[03:56] <sorear> Perl 6 has more of them

[03:56] <PerlJam> rlpowell: and not ll strings interpolate the entire language.   I'm not even sure what you mean by that.

[03:56] <sorear> rlpowell: only the left brace introduces statements

[03:56] <djanatyn> rlpowell: The P6 has to be within brackets.

[03:56] <djanatyn> ermm

[03:56] <rlpowell> OK.

[03:56] <djanatyn> curly braces

[03:56] <PerlJam> rlpowell: and P6 inside of {} inside of double quoted strings gets evaled

[03:57] <rlpowell> How do you avoid that?

[03:57] <PerlJam> avoid what?

[03:57] <djanatyn> rlpowell: I imagine there's an escape character

[03:57] <soh_cah_toa> use single quotes?

[03:57] <sorear> rlpowell: \{, or use single quotes

[03:57] <djanatyn> or, you could just use regular strings.

[03:57] <djanatyn> single quotes, I mean. non-interpolating.

[03:57] <rlpowell> What if I want variable interpolation, but also a literal { ?

[03:57] <sorear> \{

[03:57] <PerlJam> rlpowell: \{

[03:57] <rlpowell> Got it.  Thanks.

[03:57] <djanatyn> Yeah, that seems very reasonable to me.

[03:58] <rlpowell> I'd prefer a 2-character intro, but enh.

[03:58] <djanatyn> there are sigils that have to be escaped - the curly braces isn't exactly a common thing you would put in a string.

[03:58] <PerlJam> rlpowell: Ruby is very similar except they use #{...} in double quoted strings.

[03:58] <sorear> it's also possible to pick and choose what kinds of interpolation you want, but I've only wanted to use that once.

[03:59] <sorear> niecza: my $var = 5; say q:s"$var { 2 + 2 }"

[03:59] <p6eval> niecza v8-66-g6c0c55a: OUTPUT«5 { 2 + 2 }␤»

[03:59] <djanatyn> Ah, cool.

[03:59] <sorear> niecza: my $var = 5; say qs"$var { 2 + 2 }" # I wonder

[03:59] <rlpowell> PerlJam: Yes, I rather prefer the second character there; having the { by itself be your metacharacter just seems to be asking to have to quote a lot.

[03:59] <p6eval> niecza v8-66-g6c0c55a: OUTPUT«5 { 2 + 2 }␤»

[03:59] *** tokuhirom left
[04:00] <djanatyn> niecza: my $var = 5; say q:y"$var y 2 + 2 y"

[04:00] <rlpowell> But that's a fairly minor issue; what I thought was happening originally was a lot worse.  :)

[04:00] <p6eval> niecza v8-66-g6c0c55a: OUTPUT«===SORRY!===␤␤Unrecognized quote modifier: y at /tmp/5yqmsuj8Lt line 1:␤------> my $var = 5; say q⏏:y"$var y 2 + 2 y"␤␤Potential difficulties:␤  $var is declared but not used at /tmp/5yqmsuj8Lt line 1:␤------> my […

[04:00] <PerlJam> rlpowell: well ... so far it hasn't been a problem.  :-) 

[04:00] <djanatyn> ...I suppose that's not how it works. ^_^;

[04:00] <PerlJam> djanatyn: no.

[04:00] <PerlJam> djanatyn: the adverb describes what things can/can't be interpolated.

[04:00] <djanatyn> rlpowell: Did you think that any text that perl 6 recognized as a statement inside an interpolating string would be evaluated and substited with the return value?

[04:01] <rlpowell> djanatyn: I thought it was evalling all strings, yes.

[04:01] <djanatyn> PerlJam: So, in the case of q:s, what can and cannot be interpolated?

[04:01] <djanatyn> rlpowell: Oof. That would be...just wrong.

[04:01] <sorear> djanatyn: scalars

[04:02] <djanatyn> ah

[04:02] <sorear> djanatyn: like in Perl 5, q"" is the same as ''

[04:02] <rlpowell> < djanatyn> rlpowell: Oof. That would be...just wrong. -- You understand my horror now?

[04:02] <sorear> q:s or qs is '', with $foo interpolation

[04:02] <djanatyn> rlpowell: Yep.

[04:02] <djanatyn> rlpowell: Do you still think Ruby's string interpolation is better?

[04:03] <sorear> djanatyn: there's also qa (arrays), qh(hashes), qc (closures i.e. brace groups), qf (functions), qb (backslash escapes), maybe more

[04:03] <PerlJam> sorear: does niecza grok the full set of adverbs?

[04:04] <PerlJam> oh, I'm guessing not :)

[04:04] <rlpowell> Yes. I strongly prefer 2-char intros.  Because for any singlee special character, sooner or later I've had to write text that has a bunch of them, and quoting them all has driven me nuts.  IMO you shuold never have single-charter interp in a general languages general string syntax, ever.

[04:04] <sorear> djanatyn: you can combine them: q:s:c[ $foo { bar } but not @baz ]

[04:04] <PerlJam> For the full list see S02:3740

[04:04] <rlpowell> Erm, that was all to djanatyn ^^ ; the rest of you can ignore it.

[04:04] <sorear> PerlJam: niecza doesn't grok :x

[04:05] <sorear> I can't remember if it does :p

[04:05] * djanatyn should get a niecza setup to play with

[04:05] *** birdwindupbird joined
[04:05] <sorear> niecza: say qp|/etc/passwd|.perl

[04:05] <p6eval> niecza v8-66-g6c0c55a: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class CallMethod␤  at /home/p6eval/niecza/src/NieczaActions.pm6 line 970 (NieczaActions C392_ANON @ 5) ␤  at /home/p6eval/niecza/src/NieczaActions.pm6 line 979 (NieczaActions NieczaActions…

[04:05] <sorear> well, that's an interesting error

[04:06] <sorear> rlpowell: mm.  Not a fan of \n are you?

[04:07] <PerlJam> rlpowell: as I've said ... so far it hasn't been a problem.  And several of us have been writing Perl 6 for a few years now.

[04:07] <sorear> niecza: say '$x $y $z \qq[{2 + 2}] $a $b $c'

[04:07] <p6eval> niecza v8-66-g6c0c55a: OUTPUT«===SORRY!===␤␤Action method backslash:qq not yet implemented at /tmp/DAvvOsOyqP line 1:␤------> say '$x $y $z \qq[{2 + 2}]⏏ $a $b $c'␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting lin…

[04:07] <sorear> bah

[04:08] <sorear> rlpowell: according to spec, in a '' context you can still use general interpolation but it requires the \qq intro

[04:08] <PerlJam> rlpowell: also, there's a strong correspondence between {} and "block of executable code" in Perl 6.

[04:09] <sorear> nom: say '$x $y $z \qq[{2 + 2}] $a $b $c'

[04:09] <p6eval> nom ebd495: OUTPUT«$x $y $z \qq[{2 + 2}] $a $b $c␤»

[04:09] <sorear> perl6: say '$x $y $z \qq[{2 + 2}] $a $b $c'

[04:09] <p6eval> niecza v8-66-g6c0c55a: OUTPUT«===SORRY!===␤␤Action method backslash:qq not yet implemented at /tmp/ydX4EhljGp line 1:␤------> say '$x $y $z \qq[{2 + 2}]⏏ $a $b $c'␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting lin…

[04:09] <p6eval> ..rakudo a55346: OUTPUT«$x $y $z \qq[{2 + 2}] $a $b $c␤»

[04:09] <p6eval> ..pugs: OUTPUT«$x $y $z 4 $a $b $c␤»

[04:09] <sorear> heh, looks like pugs alone gets it right.

[04:09] <sorear> pugs++

[04:09] <PerlJam> pugs++ indeed.

[04:10] <sorear> btw, v9 announced.

[04:10] *** kaare_ joined
[04:11] <PerlJam> All we need now is audrey  :)

[04:12] *** molaf joined
[04:12] <sorear>  yeah, well

[04:12] <sorear> Rakudo is the only Perl 6 implementation that will survive past 2016 since Rakudo alone has attracted a second developer

[04:13] <PerlJam> sorear: Are you already getting burnt out on Niecza?

[04:14] <sorear> PerlJam: I wouldn't go so far as to say burnt out, but the enthusiasm is certainly fading.

[04:14] *** satyavvd joined
[04:17] <PerlJam> I doubt if I'll ever be a developer for niecza, but I'm certainly starting to use it more often.

[04:18] <mberends> sorear: that would be very sad. Please do $whatever-works-for-you to avoid burnout, many people are just beginning to become interested in Niecza.

[04:18] <PerlJam> sorear: what mberends said!

[04:18] <tadzik> Niecza v9 no longer supports .NET. That's interesting

[04:18] <Tene> orly?  what's niecza running on instead?

[04:19] *** mkramer joined
[04:20] <mberends> mono, but I saw some Visual Studio files from diakopter++ in Niecza very recently

[04:24] *** frhodes joined
[04:26] <mberends> sorear: imho gaining file access tests versus losing .NET compatibility is a poor trade, especially in the context of wanting to attract more users and contributors. I'd buy a regression on that any time.

[04:26] <sorear> that's what I wanted to hear

[04:27] *** rlpowell left
[04:33] <djanatyn> hmm

[04:34] <mberends> sorear: regarding startup speed, would it be feasible to make a small loader daemonize a full Niecza process at first execution, and then connect to it as a client in subsequent executions? I could imagine doing it in C, not sure about CLR.

[04:34] <djanatyn> well, I've been using mostly ghci and python for odd jobs around the desktop - just figuring out random questions and such.

[04:34] <djanatyn> I'm going to try to actively use rakudo for those now.

[04:36] *** soh_cah_toa left
[04:37] <tadzik> cool

[04:37] <tadzik> mberends: I could imagine mono itself having that feature, maybe

[04:40] <mberends> it would be a bit like mod_perl. You'd have to be thorough about cleaning up data after each execution, and be very careful to avoid memory leaks.

[04:41] <sorear> mberends: that could work, but it's far too inelegant for my tastes

[04:41] <mberends> :) there is that

[04:42] <sorear> the major problem is that compiled-niecza is too big; the largest part of startup cost is spent loading assemblies

[04:42] *** wamba joined
[04:42] <Tene> I notice in S02, there's a few comments on macros for quote-like operations, but none discuss how to add a quoting adverb.

[04:42] <sorear> I think it might be reasonable to have some kind of high-level bytecode for regexes

[04:43] <sorear> Tene: you need to augment the Q slang and add a multi candidate to tweak

[04:50] *** frhodes left
[04:54] <Tene> ahh, Q adverbs are roles applied to to the quoter there, in STD

[04:55] <Tene> so, augment slang Q { role A0 { token escape:sym<...> { ... } } }

[04:56] <Tene> oh, no, tweak

[04:57] <Tene> tweak just mixes in those roles

[04:57] <TimToady> well, STD does the mixin using Moose internally

[04:58] <Tene> TimToady: one thing that's not clear to me at all is, given a grammar modification like that, how do I indicate how it should be compiled?  I assume I'd use a quasi somewhere, but where do I add that?

[05:00] *** frhodes joined
[05:01] <Tene> or, should I be defining that with a macro instead?

[05:02] <sorear> Tene: I would think that if you are modifying the grammar, you need to specify how it is compiled by modifying the actions.  *handwave*

[05:02] <TimToady> I don't really know what you're trying t odo

[05:02] <sorear> or, inline the &make call within a {} block

[05:06] <tadzik> nqp: say("=begin END" ~~ /'=begin' [ <!before \h* \n> || { say "noez!" }]/) # huh?

[05:06] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤»

[05:06] <tadzik> oh, ok

[05:08] <sorear> TimToady: I'd like to see a complete example of a grammar modification that, say, makes "\ux" eq "X", "\uyy" eq "Yy"

[05:09] <sorear> TimToady: obviously part of the solution is augment slang Q { token backslash:u { <sym> . } }

[05:09] <sorear> TimToady: but where do I put the code that generates the uc call?

[05:12] <Tene> that's approximately the question I was asking, yes

[05:14] <dalek> niecza: 00ca678 | sorear++ | src/ (6 files):

[05:14] <dalek> niecza: mergeback

[05:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/00ca678594

[05:14] <dalek> niecza: 5c9b8fd | sorear++ | src/niecza:

[05:14] <dalek> niecza: Implement \qq[] escape syntax

[05:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5c9b8fd9f2

[05:14] <sorear> 1 insertions(+), 0 deletions(-)

[05:14] <sorear> I love these commits

[05:15] <tadzik> (:

[05:17] *** wamba left
[05:19] *** wamba joined
[05:23] <mberends> sorear: is niecza/docs/compiler.pod out of date?  'Perl 5 pipeline', 'viv-generated parser'?  I'll edit it if you give me just a few hints what to say.

[05:28] <sorear> mberends: yow!  almost none of what's there is useful

[05:29] <mberends> we could simply delete most of it and start afresh

[05:29] <sorear> probably for the best

[05:29] <sorear> it's so embarrasing to forget a doc even exists

[05:30] <mberends> ok, I'll write something under the forgiveness license

[05:30] <sorear> "forgiveness > permission"?

[05:30] <mberends> yes

[05:31] <mberends> I know you'll correct whatever is wrong

[05:33] <mberends> breakfast &

[05:35] <dalek> rakudo/nom: 53b1d8f | tadzik++ | src/Perl6/Grammar.pm:

[05:35] <dalek> rakudo/nom: Fix S02-whitespace_and_comments/begin_end_pod.t

[05:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/53b1d8f27f

[05:37] *** REPLeffect left
[05:39] *** SHODAN joined
[05:40] *** frhodes left
[05:50] *** wamba left
[05:50] *** REPLeffect joined
[05:53] *** wamba joined
[06:05] *** wtw joined
[06:06] *** wamba left
[06:14] <dalek> niecza: 1b855f7 | sorear++ | src/niecza:

[06:14] <dalek> niecza: Fix qp|| syntax

[06:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1b855f78a6

[06:20] * sorear out

[06:20] *** koban` joined
[06:20] *** koban` left
[07:00] *** mkramer left
[07:02] *** wk joined
[07:07] <dalek> niecza: ce20cf8 | (Martin Berends)++ | docs/compiler.pod:

[07:07] <dalek> niecza: [docs/compiler.pod] begin refresh of content

[07:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ce20cf86b0

[07:17] *** TiMBuS left
[07:17] *** TiMBuS joined
[07:22] <sorear> mberends: sleep is not cooperating - consider me available

[07:23] * sorear is now attempting to make sense of nom's native types implementation

[07:25] *** mj41 joined
[07:36] *** wk left
[07:44] <sorear> nom: my int $x; my $y := $x; $y = 5; say $x

[07:44] <p6eval> nom 53b1d8: OUTPUT«Cannot assign to a non-container␤  in <anon> at /tmp/M07XTKmea6:1␤  in <anon> at /tmp/M07XTKmea6:1␤␤»

[07:45] <sorear> nom: my int $x = 42; sub foo($y is rw) { $y++ }; foo($x); say $x;

[07:45] <p6eval> nom 53b1d8: OUTPUT«Cannot assign to a non-container␤  in sub postfix:<++> at src/gen/CORE.setting:2127␤  in sub foo at /tmp/EamQxNR_8R:1␤  in <anon> at /tmp/EamQxNR_8R:1␤  in <anon> at /tmp/EamQxNR_8R:1␤␤»

[07:45] <sorear> Correct?

[07:45] *** daxim joined
[07:46] <mberends> surely wrong, it looks NYI

[07:47] <sorear> making that work would involve a lot of performance-sapping complications

[07:48] <sorear> r/w autoboxing requires extending the life of the lexpad indefinitely

[07:49] <sorear> and it will expose inlining behavior

[07:49] <sorear> loop (my $x = 0; $x < 10; $x++) { my int $y = $x; secretly_saves_a_reference($y); }

[07:50] <sorear> how many distinct references are saved?

[07:50] <sorear> where "distinct" is taken in the sense of operational distinguishability

[07:50] <mberends> 10

[07:52] <sorear> grats, you've just broken the single largest optimization in niecza

[07:52] <mberends> native type are not going to perform faster than builtin types because of all this. The reason to use them has more to do with native code interop (structs etc).

[07:52] <sorear> reusing lexical slots around loops is *huge*

[07:54] <mberends> I cannot imagine how the code to reuse then would work

[07:55] <mberends> *them

[07:55] <sorear> mberends: them=?

[07:55] <mberends> lexical slots

[07:59] <sorear> I think I understand now

[08:02] <mberends> in !compile, where do the stages in @$.stages come from?

[08:03] <sorear> the constructor

[08:03] <sorear> src/niecza line 168

[08:03] * moritz doesn't see how one can take a reference to a native int at all

[08:04] <sorear> that code is slightly vestigal; I have an eye to removing the stage system

[08:04] <moritz> good morning btw

[08:04] <sorear> moritz: (CallFrame,Int) pair

[08:04] <mberends> gm moritz

[08:04] <sorear> o/ moritz

[08:05] <moritz> huh.

[08:05] <moritz> you can't bind to a nativly-typed lexical, afaict

[08:05] <moritz> and natives are passed by value

[08:06] <moritz> so all you get out of callframe.my<$y> is an int

[08:06] <sorear> *currently* natives are passed by value

[08:06] <moritz> not a reference to an int

[08:06] <sorear> I think mberends wants natives to be passed by reference

[08:06] <mberends> certainly when we get to structs

[08:07] <sorear> we want has int $.foo is rw to DWIM

[08:08] <moritz> oh.

[08:09] <moritz> I think that'd come at too high a price.

[08:10] *** im2ee joined
[08:13] <sorear> moritz, mberends: I'd like the two of you to come to a consensus before I implement anything :D

[08:14] <moritz> :-)

[08:14] <moritz> I can see how  has int $.thing is rw  is desirable for NCI

[08:15] <moritz> but maybe we need some cheating magic for that

[08:15] *** wamba joined
[08:16] <mberends> I think native types are not here for performance reasons. We have no use cases yet, but NCI will be the kind of application. Maybe Buf containing bytes has some overlap as well.

[08:17] <moritz> I do think that performance is a major reason for native types.

[08:17] <mberends> we should consider example usage first, then consider the spec, then implement.

[08:17] <moritz> maybe we can cheat ourselves a way out

[08:18] <moritz> we could have a kind of Int rw-proxy

[08:18] <sorear> moritz: in particular I want your thoughts on mberends' reply to http://irclog.perlgeek.de/perl6/2011-08-30#i_4344732

[08:18] <moritz> that stores a reference to the object which has the int slot, and the slot offset

[08:19] <sorear> moritz: that's what I meant by a (CallFrame,Int) pair

[08:19] <moritz> sorear: ah.

[08:21] <moritz> sorear: if we all that just for user-space objects with int slots, and not for lexpads, we can still get lots of optimizations

[08:21] <sorear> the most important thing we can't get, is loop optimization

[08:21] <moritz> IMHO it's OK to forbid 'is rw' on native routine parameters -- if you want that kind of magic, you use a boxed type instead

[08:21] <sorear> but on reflection that isn't necessarily a big loss

[08:22] <sorear> since you can always hoist variables out of loops, C89-style

[08:22] <sorear> a loop body with no native variables doesn't suffer the unique storage penalty

[08:22] <sorear> even if it closes over native variables

[08:22] <sorear> did that make any sense

[08:23] <mberends> only if you can *always* hoist, I'm not sure how that works

[08:23] <sorear> mberends: I mean manual hoisting

[08:23] <mberends> ok, I get it

[08:25] * moritz doesn't

[08:25] <moritz> but that's probably OK

[08:27] <mberends> I think it means the "my int $y" is repositioned before the loop and "$y = $x" remains inside the loop.

[08:28] *** wk joined
[08:28] *** baest joined
[08:40] *** dakkar joined
[08:45] *** im2ee left
[08:59] *** im2ee joined
[09:09] *** wamba left
[09:10] *** im2ee left
[09:10] *** im2ee joined
[09:10] *** im2ee left
[09:11] *** im2ee joined
[09:14] *** orafu left
[09:15] *** orafu joined
[09:17] *** Mowah_ joined
[09:26] *** Sarten-X left
[09:31] <lue> [looking at old euler problems in mu] what's Benchmark, and why am I expected to have it?

[09:31] <moritz> lue: it's probably one of the old pugs-based modules that is also included in mu

[09:32] <lue> that'd make sense, considering the plethora of /usr/bin/env pugs shebangs in those problems :)

[09:33] *** renormalist left
[09:33] *** Sarten-X joined
[09:33] *** renormalist joined
[09:35] <moritz> (they are probably in ext/ )

[09:35] <lue> is the inability to accept the line  module Benchmark-0.1;  nom's fault? [I have a feeling it is]

[09:35] <moritz> lue: no, the naming spec has changed

[09:35] <moritz> iirc

[09:36] <lue> ah, one would do well to s/-0.1/:ver<0.1>/, correct? :)

[09:36] * moritz thinks so

[09:38] <lue> I'm glad I got bored and decided to peruse mu [specifically the euler problems] . It's like an archaeological dig! :)

[09:38] *** pernatiy left
[09:41] <lue> [I have the urge to upgrade the Pod in Benchmark to Pod6. I think I shall do so]

[09:41] <moritz> lue: feel free to go wild in mu

[09:42] *** cexsum left
[09:42] <mberends> :)

[09:42] <lue> .oO(just not "decimate entire subdirectories" wild, I would imagine ...)

[09:43] <moritz> lue: well, it would make sense to leave misc/dalek-* in tact

[09:43] *** cexsum joined
[09:43] <moritz> lue: and camelia should be preserved

[09:44] <moritz> lue: otherwise much of mu is wasteland

[09:44] *** woosley left
[09:44] <lue> I'd only do it if the subdirectory were named something like "remove-after-Jan-13-2001" . Other than that, I'd reach for Community Consensus™ first

[09:45] <lue> .oO(then again, f>p)

[09:45] <moritz> and it's version-controlled after all.

[09:46] <mberends> Citizen Lue is a Good Citizen indeed

[09:53] *** am0c joined
[09:54] *** cexsum left
[09:54] *** Mowah_ left
[09:56] *** wamba joined
[09:56] <lue> [S26.html] somehow, I don't think the original header was titled "The FormattingCode<121451920> block"

[09:59] <lue> Benchmark coughs on this line: my @s = (time, times);  I wonder what 'times' once meant [I know what 'time' means]

[10:05] <lue> At least the module can be loaded, and it doesn't choke on the Pod (AFAICT). I think I should commit, and worry about the *code* working later :)

[10:05] <mberends> lue: perldoc -f times

[10:06] *** koban` joined
[10:06] <lue> let me guess, it's one of those things that's "the same as it was in P5", so it wasn't mentioned in the synopses (from what I could grep, at least)

[10:06] *** koban` left
[10:06] <mberends> good guess

[10:08] <lue> .oO(I'm compelled to give 'times' a more descriptive name, but can't think of one. So I'll drop the compellation(?))

[10:09] <mberends> yes, definitely drop it. that name is set in stone by decades of tradition.

[10:14] <lue> Yeah, it was a gut "that isn't very descriptive" reaction. But it's not worth the electricity used for the last thought bubble (nor is it worth the electricity for this message)

[10:17] <dalek> mu: 74d2344 | lue++ | ext/Benchmark/lib/Benchmark.pm:

[10:17] <dalek> mu: Modernized name of module Benchmark and turned POD in it to Pod6

[10:17] <dalek> mu: 

[10:17] <dalek> mu: Specifically I changed the name Benchmark-0.1 to Benchmark:ver<0.1>,

[10:17] <dalek> mu: which allows it load properly. Also I changed all the POD in the

[10:17] <dalek> mu: module to Pod6, getting rid of all those C<=cut>s and

[10:17] <dalek> mu: semanticizing most of it in the process.

[10:17] <dalek> mu: review: https://github.com/perl6/mu/commit/74d2344ce7

[10:17] <mberends> lue++

[10:18] <lue> whoops, s/it load/it to load/ [ah well, too late and doesn't matter all that much]

[10:18] <lue> Of course, if you want Benchmark to *work*, you'll have to wait until nom supports C<times>.

[10:21] <mberends> yeah, that's kind of the point of Benchmark, you can't really comment it out. I'll have a look later today at whether it's easily doable, I've been programming time functions quite a lot recently.

[10:23] <mberends> just getting my head around Niecza's internal architecture atm, can't easily put this down to resume later.

[10:23] <lue> I have a feeling I'm going to get a kick out of spelunking in mu . Alas, it's almost 03:30 in the morning, so I need to go to bed in a minute

[10:23] <lue> [wouldn't want to go to bed at dawn...]

[10:26] *** wamba left
[10:33] *** wamba joined
[10:38] *** wk left
[10:47] *** cexsum joined
[10:49] <lue> goodnight all o/

[10:49] <mberends> o/

[10:52] *** MayDaniel joined
[11:00] <dalek> niecza: ec4c616 | (Martin Berends)++ | docs/compiler.pod:

[11:00] <dalek> niecza: [docs/compiler/pod] rewrite up to the beginning of CLRBackend

[11:00] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ec4c6164f0

[11:00] <mberends> lunch &

[11:09] *** Trashlord left
[11:16] *** sftp joined
[11:21] *** Trashlord joined
[11:22] <mls> moring perl6!

[11:22] <daxim> lies!

[11:23] <mls> ok, afternoon then...

[11:23] *** mishin_ joined
[11:25] *** MayDaniel left
[11:29] <gfldex> cant we flattening earth? would solve quite a few problems

[11:40] <daxim> http://www.cubicearth.com/

[11:42] <gfldex> that would be a start

[11:43] * sjn remembers alt.pave.the.earth

[11:45] <colomon> but a cubic earth would have eight corners -- and everyone knows the earth has only four!

[11:46] <mberends> do you mean the north, south, east and west poles?

[11:48] *** wamba left
[11:49] <colomon> mberends: not at all.

[11:49] <mberends> it figures, a compass has four points

[11:49] <colomon> One corner of the earth is Fogo Island, Newfoundland.  I don't know where the others are off the top of my head.

[11:51] <colomon> Specifically Brimstone Head.

[11:51] <colomon> http://www.newfoundlandlabrador.com/PlanYourTrip/Detail/210426

[11:52] *** satyavvd left
[11:53] <mberends> I learn something new every day

[11:56] <colomon> actually, google searches is not providing any verification from that other than Newfoundland tourism promotions...

[12:00] *** donri joined
[12:08] <[Coke]>  /waay

[12:12] *** woosley joined
[12:27] *** mkramer joined
[12:46] *** cexsum left
[12:48] *** cexsum joined
[12:48] *** uasi left
[12:49] *** JimmyZ joined
[12:58] *** Sarten-X left
[13:03] *** JimmyZ left
[13:05] *** JimmyZ joined
[13:09] *** Sarten-X joined
[13:13] *** cexsum left
[13:15] *** cexsum joined
[13:20] *** [Coke] left
[13:22] *** baest left
[13:22] *** baest joined
[13:22] *** [Coke] joined
[13:30] *** bluescreen10 joined
[13:40] *** risou_awy is now known as risou

[13:43] <[Coke]> nom: say "forgiveness" > "permission"

[13:43] <p6eval> nom 53b1d8: OUTPUT«Bool::False␤»

[13:44] <[Coke]> aha!

[13:45] *** Holy_Cow joined
[13:52] *** sftp left
[13:53] *** sftp joined
[13:56] *** cosimo left
[13:57] *** cosimo joined
[13:59] <JimmyZ> nom: say "True" > "False"

[13:59] <p6eval> nom 53b1d8: OUTPUT«Bool::False␤»

[14:08] <plobsing> nom: say "up" == "down"

[14:08] <p6eval> nom 53b1d8: OUTPUT«Bool::True␤»

[14:08] *** Holy_Cow left
[14:10] * tadzik humms the Pirates of the Carribean "Up is Down" theme

[14:11] *** abercrombie joined
[14:13] <tadzik> lue: you're aware of the perlpilot/benchmark module?

[14:18] *** SHODAN left
[14:20] *** wtw left
[14:36] *** thou joined
[14:42] *** Su-Shee joined
[14:45] <colomon> hi all nomsters.  any idea why

[14:45] <colomon> my $match = ABC::Grammar.parse($*IN.slurp, :rule<tune_file>, :actions(ABC::Actions.new));

[14:45] <colomon> would get the error "too many named arguments: 1 passed, 0 used"

[14:46] <colomon> ?

[14:47] <moritz> colomon: :actions NYI

[14:47] <colomon> ah

[14:47] <colomon> so the ABC module is a lost cause at the moment, then

[14:47] <moritz> aye :(

[14:47] <moritz> as is JSON::Tiny

[14:53] <colomon> :(

[14:54] *** JimmyZ_ joined
[14:56] *** JimmyZ left
[14:56] *** JimmyZ_ is now known as JimmyZ

[14:57] <donri> wtf @ "up" == "down"; lemme guess it's a numeric compare and both evalulate to zero?

[14:58] <JimmyZ> nom: say "up" eq "down'

[14:58] <p6eval> nom 53b1d8: OUTPUT«===SORRY!===␤Confused at line 1, near "say \"up\" e"␤»

[14:58] <JimmyZ> nom: say "up" eq "down"

[14:58] <p6eval> nom 53b1d8: OUTPUT«Bool::False␤»

[14:58] <donri> ya I know :)

[14:59] <tadzik> nom: say +"up", +"down"

[14:59] <p6eval> nom 53b1d8: OUTPUT«00␤»

[14:59] <donri> nom: say 42 == "42 things I dare say!"

[14:59] <p6eval> nom 53b1d8: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:515␤  in sub infix:<==> at src/gen/CORE.setting:1873␤  in sub infix:<==> at src/gen/CORE.setting:1873␤  in <anon> at /tmp/2…

[15:00] <JimmyZ> nom: say "42" == "42 things I dare say!"

[15:00] <p6eval> nom 53b1d8: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:515␤  in sub infix:<==> at src/gen/CORE.setting:1873␤  in sub infix:<==> at src/gen/CORE.setting:1873␤  in <anon> at /tmp/w…

[15:00] <moritz> nom: say "42 things".Numeric.WHAT

[15:00] <p6eval> nom 53b1d8: OUTPUT«Failure()␤»

[15:00] <JimmyZ> rakudo: say "42" == "42 things I dare say!"

[15:00] <p6eval> rakudo a55346: OUTPUT«Bool::True␤»

[15:00] <colomon> nom: say "42".Numeric.WHAT

[15:00] <p6eval> nom 53b1d8: OUTPUT«Int()␤»

[15:03] <JimmyZ> LHF, me thinks

[15:04] <moritz> well, according to latest #perl6 think, "foo".Numeric should also fail()

[15:04] <moritz> but we don't have good dFailure handling in place

[15:05] <JimmyZ> so "42" == "42" will fail?

[15:05] <moritz> no

[15:06] <JimmyZ> "foo".Int won't fail, I guess

[15:06] <moritz> just strings that don't contain numbers should fail on .Numeric

[15:06] <JimmyZ> o

[15:06] *** birdwindupbird left
[15:06] <JimmyZ> I don't like that

[15:07] <JimmyZ> does it meant "up' == "down" will fail?

[15:07] <JimmyZ> s/'/"/

[15:08] *** zostay joined
[15:13] <JimmyZ> I don't expect "Whatever user input strings".Numeric makes my programs fails

[15:14] <daxim> JUST LIKE JAVA

[15:14] *** domidumont left
[15:14] <JimmyZ> JAVA fails?

[15:15] *** bluescreen10 left
[15:17] *** mkramer left
[15:17] <daxim> http://download.oracle.com/javase/7/docs/api/java/lang/NumberFormatException.html

[15:17] <daxim> for most beginning programmers, it's the first annoyance in a long long series.

[15:19] <JimmyZ> does it mean java fails too?

[15:20] <moritz> it dies

[15:22] <JimmyZ> throw a Exception doesn't mean die, I think

[15:23] *** wamba joined
[15:26] <JimmyZ> Is there a Exception class in core setting?

[15:27] <moritz> nom: say Exception

[15:27] <p6eval> nom 53b1d8: OUTPUT«Exception()␤»

[15:28] <JimmyZ> oh I don't see it  in  http://perlcabal.org/syn/S32/Exception.html 

[15:28] <moritz> yes, there's some mismatch between rakudo and spec

[15:28] <JimmyZ> aye

[15:28] <moritz> which I plan to resolve one way or another soonish

[15:29] <moritz> either Exception becomes X::Base in rakudo, or the other way round in the spec

[15:29] <bbkr_> rakudo: Exception.new("e").throw

[15:29] <p6eval> rakudo a55346: OUTPUT«Not a throwable object␤  in main program body at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[15:30] <JimmyZ> will there be a plan throw a Exception other than fails in the core setting ?

[15:30] <moritz> JimmyZ: I can't parse that question

[15:30] <JimmyZ> will there be a plan throw a Exception instead of fails in the core setting ?

[15:30] <moritz> JimmyZ: repeating it doesn't make it easier to understand

[15:31] <JimmyZ> hmm

[15:31] <moritz> sorry, wasn't repeated verbatimly

[15:31] <moritz> but I still don't know what it means :(

[15:31] <JimmyZ> sorry, my poor english

[15:32] <moritz> what bbkr_ tried should work

[15:32] <bbkr_> should I report a bug?

[15:32] <JimmyZ> will strings that don't contain numbers should throw a Exception instead of fail on .Numeric?

[15:32] <mberends> I think JimmyZ meant, will there be a plan to use 'throw' instead of 'fail'?

[15:33] <moritz> JimmyZ: no

[15:33] <moritz> bbkr_: not necessary

[15:33] <moritz> bbkr_: it's on my agned

[15:33] <moritz> *agenda

[15:33] * moritz can't type

[15:33] <bbkr_> moritz++

[15:34] <JimmyZ> I just realized core-setting won't use Exception class 

[15:35] <TimToady> I don't see that; a failure is just a lazily thrown exception

[15:35] <JimmyZ> which is in flood in java

[15:36] <TimToady> throwing exceptions eagerly is bad for parallel processing

[15:36] <JimmyZ> agreed 

[15:37] <TimToady> see for example S03:3366

[15:38] <TimToady> there is no exact definition for "mass production" yet, but certainly hyper is one of them

[15:39] <jnthn> evening, #perl6

[15:39] * jnthn is back from disappearing :)

[15:39] <mberends> o/ jnthn, welcome back!

[15:39] <jnthn> o/ mberends 

[15:39] <colomon> \o

[15:41] *** JimmyZ left
[15:43] <TimToady> you should throw an exception only when the program is defective, not when the data is defective; (not handling defective data is one way of making the program defective, of course)

[15:46] <TimToady> and languages that throw exceptions at the end of a list are nuts, since having an end does not make a list defective

[15:48] * bbkr_ agree, pythonisms like StopIteration exception are weird

[15:48] <mberends> TimToady++ # throw or fail should not be a structured programmer's goto

[15:53] <bbkr_> mberends: sorry about server downtime yesterday, some modifications on power grid were made here. it should be fine from now on.

[15:53] <mberends> :) no probs, thanks

[16:00] <TimToady> that's not to say that control exceptions don't exist, but it's more like a fatal exception is just a specific subclass of control exception that CATCH knows how to deal with

[16:01] * jnthn wonders how the new categorize fits in with classify

[16:01] <jnthn> oh, I see it...

[16:02] <jnthn> :)

[16:05] *** jevin left
[16:07] *** jevin joined
[16:08] *** bonifatio joined
[16:12] *** jevin left
[16:14] *** risou is now known as risou_awy

[16:14] *** mishin_ left
[16:14] *** risou_awy is now known as risou

[16:15] *** pelmenntm joined
[16:17] *** woosley left
[16:18] *** pelmenntm left
[16:29] *** jevin joined
[16:29] *** jevin left
[16:34] *** wolfman2000 joined
[16:35] *** jevin joined
[16:36] *** mj41 left
[16:39] *** mishin left
[16:45] *** agentzh left
[16:57] *** lakatos joined
[16:57] <moritz> jnthn: http://irclog.perlgeek.de/perl6/2011-08-29#i_4341153 might interest you

[16:57] <lakatos> Hey guys

[16:57] <lakatos> I'm thinking of learning Perl

[16:57] <lakatos> Is Perl 6 a safe bet?

[16:57] <lakatos> :D

[16:58] <mberends> I wouldn't bet *against* it

[16:59] <lakatos> So how should I go about learning this language then?

[17:00] <mberends> try using it to write what you like anyway, get guidance here or from references on perl.org

[17:00] <bbkr_> lakatos: a lot of languages copied Perl in past 20 years, and a lot of languages will copy Perl6 in next 20 years :) go for it!

[17:00] * sjn thinks there's a good chance most people might become better programmers in general by learning Perl 6

[17:01] <jnthn> moritz: Thanks for the pointer.

[17:02] <bbkr_> lakatos: the best way to learn is to write some perl6 modules. learning without target is hard. take a look at http://modules.perl6.org/ , check what is missint and try to implement it.

[17:02] <lakatos> What I'm asking is where can I find a book or something :P

[17:02] <mberends> lakatos: the biggest collection of little Perl 6 examples, and how they compare to other languages http://rosettacode.org/wiki/Category:Perl_6

[17:02] <mberends> lakatos: explore http://perl6.org

[17:03] <lakatos> Does Perl 6 have macros yet?

[17:03] <bbkr_> lakatos: book is here -  https://github.com/perl6/book/downloads

[17:03] *** benabik left
[17:04] <bbkr_> Please define "macro"

[17:04] <mberends> Rakudo might get macros soon, masak++ is planning to implement some (or all) of the spec

[17:05] <lakatos> bbkr_: Let's just say programs that write programs

[17:06] <Su-Shee> lakatos: I think you want to read higher order perl and learn perl 5 first. ;)

[17:06] <lakatos> bbkr_: Basically lisp-style macros

[17:07] *** wolfman2_ joined
[17:07] *** abercrombie left
[17:07] <lakatos> Su-Shee: I'm still not sure yet. Still weighing my options for now

[17:07] <mberends> lakatos: that's what masak++ will be producing

[17:08] <Su-Shee> lakatos: it'll make learning perl 6 much easier.

[17:09] *** dakkar left
[17:09] *** wolfman2000 left
[17:10] <lakatos> Well, seeing how all I really want is to, well, learn regular expressions, I guess I'll give Perl 5 a quick run

[17:10] *** lakatos left
[17:10] *** benabik joined
[17:13] *** abercrombie joined
[17:19] *** flussence joined
[17:21] *** masak joined
[17:22] <masak> hi, #perl6.

[17:22] <colomon> o/

[17:22] <masak> sorear++ # v9

[17:22] <colomon> is phasers in 98, or did it get rescheduled?

[17:22] <masak> yes :)

[17:23] <colomon> errrr.....

[17:23] <mberends> still in 98, sorear++ needs his schedule irl to stabilize

[17:24] <masak> oh, right. that's what we decided.

[17:30] <masak> mberends: yes. I'm going to implement macros in Rakudo. I'm pretty excited about it.

[17:32] <arnsholt> I think any sane person should be excited about your macro work

[17:32] <arnsholt> ++masak

[17:35] <masak> who knows, being insane might even heighten the excitement!

[17:36] <colomon> masak++

[17:49] <jnthn> oh, #phasers...

[17:49] <jnthn> I guess my report will be short this week. :/

[17:52] *** Trashlord left
[17:53] *** Trashlord joined
[17:55] *** thou left
[17:56] *** wolfman2000 joined
[17:56] *** abercrombie left
[17:57] *** abercrombie joined
[17:58] *** wolfman2_ left
[18:01] <colomon> ack, sure seems like roles would make my current $work task 90% easier.  (and just for masak, I'm working on writing tests...)

[18:01] <masak> \o/

[18:01] <masak> did you mean "macros"?

[18:02] <colomon> no, I meant roles.  I'm programming in C++

[18:03] *** benabik left
[18:04] <masak> ah.

[18:04] <masak> anyway, good that you're writing tests.

[18:05] <colomon> it just sucks they are such a pain in the neck to write here.

[18:06] <colomon> one of those situations where I'm staring at screens of code going "That one be three lines of p6...."

[18:07] <masak> or three characters of APL :P

[18:07] <colomon> doubt it, it's a text processing issue

[18:08] <masak> (only three characters, but they *say so much*)

[18:08] <colomon> read through the log being generated and make sure the info I just added to the log file is present

[18:10] <colomon> It means overriding the logging class for the test

[18:11] <colomon> whereas in p6, I believe I could pretty easily just mixin the one method that needs to change.

[18:14] <colomon> and naturally the text searching involved would be an order of magnitude simpler

[18:18] <masak> naturally.

[18:18] <pmichaud> good afternoon, #perl6

[18:18] <phenny> pmichaud: 29 Aug 12:46Z <[Coke]> ask pmichaud if that grant thing is still ongoing and if I should poke him about it.

[18:19] <masak> pmichaud! \o/

[18:19] <colomon> o/

[18:19] <mberends> hello pmichaud

[18:19] <pmichaud> phenny tell Coke yes, it's still ongoing, and consider me poked.

[18:19] <pmichaud> phenny: tell Coke yes, it's still ongoing, and consider me poked.

[18:19] <phenny> pmichaud: I'll pass that on when Coke is around.

[18:30] *** Kivutarrr joined
[18:30] <masak> Kivutarrr: \o

[18:30] <Kivutarrr> Hi all :)

[18:30] *** ccc_ joined
[18:30] <Kivutarrr> how is perl6 going?

[18:31] <moritz> it runs slowly, but it is developed fast :-)

[18:32] <masak> I was going to answer "we don't know, we're in the echo chamber!"

[18:32] <masak> moritz: if we magically had a Perl 6.0.0 implementation around, I bet work would proceed real fast. ;)

[18:33] <Kivutarrr> :)

[18:35] *** birdwindupbird joined
[18:36] *** daxim left
[18:38] <moritz> in unrelated news I'm working on a generic backend API for a blog engine (currently in perl 5 though)

[18:38] *** wolfman2000 left
[18:39] <moritz> for testing, I'm implementing an "each blog post is stored in a separate file" backend

[18:39] <moritz> want to a SQL backend later

[18:39] <masak> sounds interesting.

[18:39] <masak> except for the Perl 5 part, which was a letdown :P

[18:39] <moritz> I'm also consider writing a proof of concept frontend

[18:40] <moritz> masak: consider it the "plant to throw one away" :-)

[18:40] <colomon> masak: oooo, my test is only about 75% written, and it's already found a bug in my new code

[18:40] <masak> moritz: remind me never to let you take care of my plants. :P

[18:41] * moritz reminds masak to never let him take care of masak's plants

[18:41] * masak saw that one coming

[18:42] <masak> it was all planted ahead.

[18:42] <plobsing> I'm trying to understand how Perl 6 exceptions are supposed to work. I tried http://nopaste.snit.ch/76050 with rakudo, but it didn't work.

[18:42] <plobsing> is this my fault or rakudo's?

[18:43] <masak> plobsing: your bug report lacks the field "expected". please try again.

[18:43] <plobsing> heh. I'm expecting it to print *something*

[18:43] <plobsing> it doesn't

[18:43] <masak> come to think of it, it also lacks the field "observed".

[18:44] <plobsing> there is no output

[18:44] <masak> does the program terminate?

[18:44] <plobsing> yes

[18:44] <plobsing> but with no output and 0 exit status

[18:45] <masak> rakudo: die 2; CATCH { when $_ %% 2 { say "Even" } }; say "alive"

[18:45] <p6eval> rakudo a55346: OUTPUT«(timeout)»

[18:45] *** Kivutarrr left
[18:45] <masak> doesn't terminate here.

[18:45] <masak> or not soon enough anyway.

[18:46] <plobsing> rakudo: subset Even of Int where *%%2; die 2; CATCH { when Even { say "catch match"; } }

[18:46] <p6eval> rakudo a55346:  ( no output )

[18:46] <plobsing> I expect the catch to match or rethrow

[18:47] <moritz> rakudo never implemented that part.

[18:47] <masak> rakudo master certainly won't... right.

[18:47] <moritz> niecza: subset Even of Int where *%%2; die 2; CATCH { when Even { say "catch match"; } }

[18:47] <p6eval> niecza v9-5-gec4c616: OUTPUT«catch match␤»

[18:47] <plobsing> therefore, I expect either the text in the handler, or a backtrace

[18:47] *** envi left
[18:47] <masak> optimist :P

[18:48] <plobsing> masak: silent failure is the worst kind

[18:48] <masak> oh, I agree.

[18:48] <plobsing> niecza: subset Even of Int where *%%2; die 1; CATCH { when Even { say "catch match"; } }

[18:48] <masak> I'd use the exception system in Rakudo a lot more if it actually worked.

[18:48] <p6eval> niecza v9-5-gec4c616: OUTPUT«Unhandled exception: 1␤  at /home/p6eval/niecza/lib/CORE.setting line 741 (CORE die @ 2) ␤  at /tmp/_tLRxx50I4 line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2045 (CORE C954_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting lin…

[18:48] <masak> for now, I rely quite heavily on try and booleans.

[18:50] <pmichaud> niecza: die 2;  CATCH { say .WHAT }

[18:50] <p6eval> niecza v9-5-gec4c616: OUTPUT«Int()␤Unhandled exception: 2␤  at /home/p6eval/niecza/lib/CORE.setting line 741 (CORE die @ 2) ␤  at /tmp/yFwtGJyzBj line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2045 (CORE C954_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setti…

[18:50] <plobsing> I find it odd that the subset test terminates, but the direct %% test (in the handler) doesn't appear to do so

[18:51] <pmichaud> that feels weird.  The 2 is put into $!?

[18:52] <pmichaud> rakudo:  die 2;  CATCH { say .WHAT };

[18:52] <p6eval> rakudo a55346: OUTPUT«Exception()␤»

[18:52] <pmichaud> yeah, that's the difference.

[18:52] <plobsing> ah yes, parrot exception system sucks and can't throw arbitrary objects

[18:52] <pmichaud> rakudo (master)   creates an Exception that has the 2 as a payload

[18:54] <plobsing> pmichaud: why doesn't rakudo unbox the payload?

[18:54] <moritz> is it supposed to?

[18:54] <plobsing> that's the expected semantic

[18:55] <plobsing> perl expects arbitrary objects to be throwable. the parrot exception system supports that by providing a payload slot.

[18:55] <[Coke]> so, by "sucks" you mean "is different than perl"

[18:55] <[Coke]> ?

[18:56] *** risou is now known as risou_awy

[18:56] <plobsing> [Coke]: I also mean "is different from javascript, and other common languages"

[18:56] <moritz> plobsing: I'm currently thinking hard about the exception system (at least some aspects of it), and it's not clear to me that it must be unboxed

[18:56] <pmichaud> plobsing: I'm not certain that rakudo should be unboxing the payload.  It's not clear to me that the argument to "die" should be what ends up in $!

[18:57] <moritz> plobsing: I mean, how could you obtain the backtrace then, for example?

[18:58] <plobsing> moritz: that is a tradeoff. I'm just looking at some of the spec and noting how it works.

[18:58] <moritz> maybe if the argument to die isn't something throwable, $_ in the catch block becomes that argument, and $! the full exception

[18:58] *** dual joined
[18:59] <pmichaud> that's definitely *not* what the spec currently says.

[18:59] <pmichaud> the spec says that $_ is bound to the exception itself

[18:59] <moritz> pmichaud: I know

[18:59] * moritz was SPECulating

[18:59] <plobsing> spectacular

[19:00] <moritz> #phasers time!

[19:02] <pmichaud> certainly the spec implies that it's possible to .resume an exception.

[19:02] <pmichaud> so, whatever ends up in $_ either has to be an Exception, or an object with an exception mixed in

[19:02] <moritz> .oO( put .resume in Mu... NOOO!)

[19:05] <plobsing> where are exceptions covered in-depth in the spec. I found a little in s04, but I feel I'm missing somethign

[19:06] <plobsing> nm, found the draft spec, stupid question

[19:07] <masak> moritz: after that thought bubble, I'm a bit on edge having you in charge of exceptions :P

[19:09] <pmichaud> plobsing: exceptions haven't been covered in-depth in the spec, which is a big reason why rakudo's behavior seems wonky at times.  it's building to a handwavy spec

[19:09] <moritz> masak: I'm not in charge, I'm just being paid to do it

[19:09] <masak> "I just work here"

[19:10] <masak> anyway, moritz++ so far.

[19:10] <masak> hope Mu doesn't end up with .resume :P

[19:10] <plobsing> pmichaud: I'm looking to make some additions/improvements to parrot's exception system and was trying to determine what rakudo needs from it (which I suspect it doesn't provide ATM)

[19:10] <plobsing> specifically wrt exceptions uncaught by the first encountered handler

[19:13] <pmichaud> plobsing: yeah, that's been tricky.  (more)

[19:13] *** birdwindupbird left
[19:13] <pmichaud> to me "first encountered handler" isn't really what we want to be keying on

[19:14] <pmichaud> what I really want to be able to do is to mask a handler for a given scope or block or something like that

[19:14] <plobsing> I'm sorry, I didn't understand that. Can you dumb that down a little?

[19:14] <plobsing> or provide an example?

[19:14] <pmichaud> our biggest challenge at the moment is something like:    CATCH { die $! }

[19:15] <pmichaud> we need to make sure the CATCH block doesn't catch any exceptions thrown from within it

[19:16] <pmichaud> but it's not enough to say "ignore the first handler", because of something like:

[19:16] <plobsing> my reading of s04 is that the CATCH block *should* catch that, but defer it

[19:16] <pmichaud> plobsing: that's possible... s04 changed relatively recently and I haven't updated my mental model yet

[19:16] <pmichaud> (the SIMPLECATCH stuff is relatively new)

[19:17] <plobsing> i'm not exactly sure how that is supposed to work. I mean, the exception handler hit an exception handling the exception. How is it supposed to *continue* handling the first exception?

[19:17] <plobsing> but that's how I read it

[19:17] <pmichaud> well, think of something like

[19:18] <pmichaud> foo() { CATCH { ... };  die $something };    CATCH { foo(); }

[19:18] <pmichaud> sub foo() { CATCH { ... };  die $something };    CATCH { foo(); }

[19:19] <pmichaud> if foo's CATCH handles the exception, then the outer CATCH simply continues on when foo() returns

[19:19] <pmichaud> if foo's CATCH doesn't handle the exception, then the outer CATCH needs to either ignore it or arrange for it to be rethrown

[19:20] *** am0c left
[19:20] <ashleydev> I didn't understand what Perl 6 macros were going to be, but I found this: http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html -- that helped clear up a lot for me (note I know C and perl well)...

[19:20] <plobsing> yes, but to defer the rethrow... where do we continue in the handlng of the original exception?

[19:21] <plobsing> is it like 'on error resume next'?

[19:21] <pmichaud> plobsing: I don't know.  I haven't explored it fully myself yet; exceptions have been relatively low on the "needs to be done" list for rakudo.

[19:22] <pmichaud> they're important, but they haven't been critical in the way that regexes and lists and lexicals and stuff have been critical

[19:23] <masak> ashleydev: interesting.

[19:23] <masak> ashleydev: yes, Perl 6 macros will be AST-based, and hygienic, just as Lisp's.

[19:23] <ashleydev> masak: makes me think that Perl 6 is going to be lisp with more syntax

[19:23] <ashleydev> + some regex

[19:24] <masak> ashleydev: you're not the first to think so.

[19:24] <masak> ashleydev: if doing macros right makes your language a Lisp, then fair enough, it's a Lisp :)

[19:24] <ashleydev> heh

[19:24] <plobsing> pmichaud: the change/addition I'd like to make first is in how parrot manages rethrows. I want to add functionality that ignores rethrow points and only reports the original throw point (􏿽xE2􏿽x84􏿽xA6􏿽xCE􏿽xB7 wants this).

[19:25] <plobsing> I suspect the way perl6 exceptions work, rakudo wants that as well.

[19:25] <pmichaud> "ignore rethrow points" sounds non-perl6ish to me, though.

[19:25] <pmichaud> in general perl 6 doesn't ever want to throw information away.

[19:26] <plobsing> if you don't ignore rethrow points, you'll get a backtrace for every handler that *didn't* catch

[19:26] <plobsing> which is a lot of noise

[19:26] <pmichaud> well, a backtrace could be selective in what it displays.  indeed, it already is.

[19:27] *** birdwindupbird joined
[19:27] <pmichaud> and my mental model of perl 6 is that only handlers that catch would do a rethrow.

[19:28] <pmichaud> i.e., a handler that doesn't catch doesn't do anything to the exception.

[19:28] * ashleydev wonders if perl 6 will spark a DSL hell 2.0 after the rubyists beat that to death.

[19:28] <plobsing> pmichaud: from a perl6 perspective yes, but from parrot's perspective, the handler needs to catch to do the testing for code such as 'CATCH { when pred1 { ... } when pred2 {...} }'

[19:29] <plobsing> even though from perl6, we'd say that exceptions not satisfying the predicates were not caught

[19:29] <sjn> "DSL hell"? What's that? </ignorant>

[19:29] <pmichaud> plobsing: that doesn't fit my understanding.

[19:29] <pmichaud> in the case of   CATCH { when pred1 { ... } when pred2 { ... } }     there *is* a catch

[19:30] <plobsing> what if the object thrown doesn't match the predicates?

[19:30] <pmichaud> then it gets rethrown

[19:30] <pmichaud> (let me double-check this with latest s04)

[19:30] <plobsing> so then how can a catch block *not* catch?

[19:30] <pmichaud> there's more than one type of exception

[19:30] <pmichaud> we also have CONTROL exceptions

[19:30] <pmichaud> those handlers don't catch

[19:30] <pmichaud> those handlers don't catch "die" exceptions.

[19:31] <pmichaud> I also don't know yet to what extent the NEXT, LAST, and REDO phasers are exception-handler based.

[19:31] *** benabik joined
[19:31] <pmichaud> I do know that "next", "last", and "redo" are exception-based.

[19:31] <plobsing> so there is no way to selectively catch die exceptions based on arbitrary predicates?

[19:32] <pmichaud> I think the predicates are handled inside the CATCH block

[19:32] <pmichaud> (which, yes, is after it has been caught)

[19:32] <plobsing> I either always catch them (and sometimes rethrow them, at the cost of potentially low signal/noise backtraces) or I don't

[19:34] <pmichaud> the backtrace code can always choose to ignore handlers when displaying the backtrace

[19:35] <pmichaud> as I said, we already have to selectively ignore frames in the backtrace

[19:35] <pmichaud> so that's not really anything new.

[19:36] <plobsing> but we're not talking about frames. this makes the backtrace information 2-dimensional, only one dimension is the frames. the other dimension being the different throw/rethrow points.

[19:38] <pmichaud> well, if it's a newly thrown exception, it has its own backtrace.  if it's a rethrown exception, then I suspect knowing the original exception location and the point of the last rethrow might be enough (more)

[19:38] <lue> hello world o/

[19:40] <masak> lue! \o/

[19:41] <lue> perl6: say times;

[19:41] <p6eval> niecza v9-5-gec4c616: OUTPUT«2.440152 0.048003 2.440152 0.048003␤»

[19:41] <p6eval> ..pugs: OUTPUT«0.000010.00000100␤»

[19:41] <p6eval> ..rakudo a55346: OUTPUT«Could not find sub &times␤  in main program body at line 22:/tmp/xPDJ8iG3d5␤»

[19:53] *** birdwindupbird left
[19:59] *** lichtkind joined
[20:01] <mberends> hello lichtkind, for your history I looked up when classify was first mentioned here http://irclog.perlgeek.de/perl6/2006-09-20#i_-138392 and categorize http://irclog.perlgeek.de/perl6/2011-01-14#i_3186628

[20:02] <masak> mberends++

[20:02] <mberends> lichtkind: and someone asked about classify 2 years ago ;) http://irclog.perlgeek.de/perl6/2009-06-21#i_1254858

[20:02] *** jevin left
[20:03] <masak> mberends: fwiw, "classify" is mentioned a lot in E06 as "part", a horrible name :)

[20:03] <masak> and E06 is from 2003.

[20:03] <plobsing> pmichaud: there was more?

[20:04] <mberends> masak: oh, well remembered!

[20:04] <masak> signed, your friendly Perl 6 historian :)

[20:07] *** ccc_ left
[20:07] *** jevin joined
[20:09] * lue sets out for another dig in the mu repository

[20:09] <masak> 'night, #perl6

[20:09] *** masak left
[20:15] *** zby_home_ joined
[20:16] *** kaare_ left
[20:23] <lichtkind> mberends: i tend to be persistent :)

[20:23] <lichtkind> good night masak

[20:23] <mberends> lichtkind: :)

[20:41] <pmichaud> plobsing: oh, sorry, I got called afk at home

[20:41] <pmichaud> no, there's not more

[20:41] <pmichaud> or if there was (and there likely was), I've forgotten it now.  again, my apologies.

[20:42] <plobsing> ah, ENOMEM

[20:42] <pmichaud> yeah

[20:48] <plobsing> pmichaud: I've been looking over the spec a bit more, and it appears exceptions were as you said

[20:49] <plobsing> thrown objects that aren't exceptions probably get wrapped in X::AdHoc

[20:51] <plobsing> in terms of keeping track of rethrow points, is 'class Backtrace does Positional[Backtrace::Frame]' suitable for handling the 2D nature of backtraces?

[20:52] *** bluescreen10 joined
[21:03] *** thou joined
[21:04] *** zby_home_ left
[21:12] *** dorlamm joined
[21:17] <lichtkind> unbelievable, after 20some net  hours im still tweaking on http://kepher.kilo028.server4you.de/nightly/datastructures.pdf

[21:19] <felher> ashleydev++: Thanks for that link 'bout the macro-system of lisp. Seems to be very interesting indeed. I find it kind of funny though, that the author didn't fall into the hard-to-spot trap of macro-expansion in C (2/10*10 != 2/(10*10)) but into the trap of integer vs. float arithmetic (2/10*10 != 2) :)

[21:19] *** Sarten-X left
[21:28] *** REPLeffect left
[21:29] *** Sarten-X joined
[21:34] <felher> yeah, really interesting. especially if one - like me - never played with lisp.

[21:34] <ashleydev> felher: /o

[21:35] <ashleydev> me too, I'm not fluent in lisp

[21:35] *** bluescreen10 left
[21:36] <ashleydev> felher: but he did mention the (2/10*10 != 2/(10*10)) issue I think

[21:36] *** tokuhirom joined
[21:37] *** wallberg joined
[21:38] <felher> ashleydev: yeah, he mentioned it. As i said: the author didn't fall into the macro-expansion trap. :)

[21:40] <felher> ashleydev: maybe i should have written (2/10*10 != 2/10*10) as (2/square(10) == 2/10*10 != 2/(10*10) to make sure i'm talking about the macro expansion, not the float/integer arithmetic at that point.

[21:40] *** wamba left
[21:41] <felher> anyway, going to sleep. good night #perl6

[21:46] <ashleydev> can an AST based macro system not be hygenic?

[21:47] *** REPLeffect joined
[21:50] <dalek> specs: 0e7e19c | larry++ | S04-control.pod:

[21:50] <dalek> specs: refinement of SIMPLECATCH semantics

[21:50] <dalek> specs: 

[21:50] <dalek> specs: needs to go inside the loop to be able to give up on current exception

[21:50] <dalek> specs: review: https://github.com/perl6/specs/commit/0e7e19cc19

[21:55] *** REPLeffect left
[22:03] *** thou left
[22:04] *** soh_cah_toa joined
[22:05] *** slavik2 joined
[22:06] *** slavik left
[22:08] *** REPLeffect joined
[22:11] *** dorlamm left
[22:29] <lichtkind> is the cakture creating  op "/" gone?

[22:29] <lichtkind> capture

[22:31] *** im2ee left
[22:42] *** wallberg left
[22:44] *** y3llow left
[22:44] *** xinming left
[22:44] *** f00li5h left
[22:44] *** breinbaas left
[22:44] *** jnthn left
[22:44] *** sbp left
[22:44] *** snarkyboojum left
[22:44] *** imarcusthis left
[22:44] *** gabiruh left
[22:44] *** broquaint left
[22:44] *** Gothmog_ left
[22:44] *** phenny left
[22:44] *** nsh- left
[22:44] *** Grrrr left
[22:44] *** jjore left
[22:44] *** zb left
[22:44] *** \patch left
[22:44] *** dukeleto left
[22:44] *** jedai left
[22:44] *** odoacre left
[22:44] *** DarthGandalf left
[22:44] *** huf left
[22:44] *** jlaire left
[22:44] *** athomason left
[22:44] *** mikemol left
[22:44] *** bs338 left
[22:44] *** felipe left
[22:44] *** TimToady left
[22:44] *** Grimnir_ left
[22:44] *** tylercurtis left
[22:44] *** bonifatio left
[22:54] *** y3llow joined
[22:54] *** dukeleto joined
[22:54] *** jedai joined
[22:54] *** odoacre joined
[22:54] *** DarthGandalf joined
[22:54] *** huf joined
[22:54] *** jlaire joined
[22:54] *** xinming joined
[22:54] *** f00li5h joined
[22:54] *** breinbaas joined
[22:54] *** jnthn joined
[22:54] *** sbp joined
[22:54] *** snarkyboojum joined
[22:54] *** imarcusthis joined
[22:54] *** gabiruh joined
[22:54] *** broquaint joined
[22:54] *** Grimnir_ joined
[22:54] *** athomason joined
[22:54] *** mikemol joined
[22:54] *** Gothmog_ joined
[22:54] *** bs338 joined
[22:54] *** felipe joined
[22:54] *** phenny joined
[22:54] *** nsh- joined
[22:54] *** TimToady joined
[22:54] *** Grrrr joined
[22:54] *** jjore joined
[22:54] *** tylercurtis joined
[22:54] *** zb joined
[22:54] *** \patch joined
[22:54] *** donri left
[22:54] *** donri joined
[22:54] *** donri left
[22:54] *** donri joined
[22:55] *** thou joined
[22:56] *** donri left
[22:57] *** donri joined
[23:00] * ruz upgraded memory 2G->4G, finally can compile rakudo w/o affecting whole system perf

[23:01] <tadzik> ;)

[23:03] *** y3llow left
[23:03] *** xinming left
[23:03] *** f00li5h left
[23:03] *** breinbaas left
[23:03] *** jnthn left
[23:03] *** sbp left
[23:03] *** snarkyboojum left
[23:03] *** imarcusthis left
[23:03] *** gabiruh left
[23:03] *** broquaint left
[23:03] *** Gothmog_ left
[23:03] *** phenny left
[23:03] *** nsh- left
[23:03] *** Grrrr left
[23:03] *** jjore left
[23:03] *** zb left
[23:03] *** \patch left
[23:03] *** donri left
[23:03] *** dukeleto left
[23:03] *** jedai left
[23:03] *** odoacre left
[23:03] *** DarthGandalf left
[23:03] *** huf left
[23:03] *** jlaire left
[23:03] *** athomason left
[23:03] *** mikemol left
[23:03] *** bs338 left
[23:03] *** felipe left
[23:03] *** TimToady left
[23:03] *** Grimnir_ left
[23:03] *** tylercurtis left
[23:03] <ruz> pull requests kinda suck for small patches, can I use nopaste?

[23:04] <tadzik> sure

[23:05] *** donri joined
[23:05] *** y3llow joined
[23:05] *** dukeleto joined
[23:05] *** jedai joined
[23:05] *** odoacre joined
[23:05] *** DarthGandalf joined
[23:05] *** huf joined
[23:05] *** jlaire joined
[23:05] *** xinming joined
[23:05] *** f00li5h joined
[23:05] *** breinbaas joined
[23:05] *** jnthn joined
[23:05] *** sbp joined
[23:05] *** snarkyboojum joined
[23:05] *** imarcusthis joined
[23:05] *** gabiruh joined
[23:05] *** broquaint joined
[23:05] *** Grimnir_ joined
[23:05] *** athomason joined
[23:05] *** mikemol joined
[23:05] *** Gothmog_ joined
[23:05] *** bs338 joined
[23:05] *** felipe joined
[23:05] *** phenny joined
[23:05] *** nsh- joined
[23:05] *** TimToady joined
[23:05] *** Grrrr joined
[23:05] *** jjore joined
[23:05] *** tylercurtis joined
[23:05] *** zb joined
[23:05] *** \patch joined
[23:06] *** donri left
[23:06] *** donri joined
[23:06] *** donri left
[23:07] *** donri joined
[23:10] *** thou left
[23:10] <lichtkind> good night

[23:12] *** lichtkind left
[23:15] *** [Coke] left
[23:17] *** [Coke] joined
[23:22] *** [Coke] left
[23:24] *** [Coke] joined
[23:29] *** [Coke] left
[23:31] *** [Coke] joined
[23:34] *** tokuhirom left
[23:34] *** Psyche^ joined
[23:34] *** whiteknight joined
[23:35] *** Patterner left
[23:35] *** Psyche^ is now known as Patterner

[23:36] *** [Coke] left
[23:37] *** jferrero left
[23:38] *** jferrero joined
[23:38] *** [Coke] joined
[23:43] *** [Coke] left
[23:44] *** [Coke] joined
[23:48] *** envi joined
[23:49] *** [Coke] left
[23:50] *** [Coke] joined
[23:50] *** ZaphrodZenovka joined
[23:54] *** plobsing left
[23:55] *** [Coke] left
[23:55] *** plobsing joined
[23:56] *** [Coke] joined
[23:57] <ruz> http://pastie.org/2457199

[23:58] *** molaf_ joined
