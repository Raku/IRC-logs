[00:21] *** whiteknight left
[00:21] *** whiteknight joined
[00:28] *** tokuhirom left
[00:30] *** kfo left
[00:31] *** daniel-s joined
[00:31] *** kfo joined
[00:32] *** [Coke] left
[00:34] *** [Coke] joined
[00:35] *** wolfman2000 joined
[00:46] *** ssotka left
[01:03] *** noganex left
[01:05] *** noganex joined
[01:06] <TimToady> rakudo: use DateTime; say 'alive'

[01:06] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Unable to find module 'DateTime' in the @*INC directories.␤(@*INC contains:␤  lib␤  /home/p6eval/.perl6/lib␤  /home/p6eval//p1/lib/parrot/3.5.0-devel/languages/perl6/lib␤  .)␤»

[01:28] <sorear> good * #perl6

[01:28] <phenny> sorear: 03 Jul 20:45Z <moritz> tell sorear about a name idea for niecza: "FeP6" - like "Iron Perl 6", but with the symbol Fe for iron :-)

[01:28] <lue> when it comes to the ords method and sub, should I basically just copy what master says? I've already done that for Str's method, but the sub form beginning with 'proto' makes me want to make sure.

[01:32] <TimToady> o/ welcome back!

[01:33] <sorear> thank you

[01:41] <lue> for nom, should the char/chars/ord/ords methods and subs go in Cool.pm or Str.pm (in src/core)?

[01:42] * sorear has finished scanning a week of backlog

[01:57] *** whiteknight left
[02:43] *** _jaldhar joined
[02:54] *** Limbic_Region left
[02:58] *** lichtkind left
[03:05] *** everbrew joined
[03:14] *** woosley joined
[03:23] *** Su-Shee_ joined
[03:25] *** Su-Shee left
[03:38] <lue> rakudo: say [63,65].chars

[03:38] <p6eval> rakudo 72d158: OUTPUT«5␤»

[03:41] *** soh_cah_toa left
[03:41] <lue> I just realize now I was saying chars when I meant to say chrs.

[03:51] *** kaare_ joined
[04:08] *** agentzh joined
[04:15] *** satyavvd joined
[04:16] *** am0c joined
[04:18] <dalek> nqp: ebe6acb | pmichaud++ | src/core/NQPMu.pm:

[04:18] <dalek> nqp: Parrot's Data::Dumper apparently requires boxed arguments.

[04:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ebe6acbabe

[04:19] *** kaare_ left
[04:19] *** envi joined
[04:25] *** satyavvd left
[04:31] *** sftp left
[04:31] *** sftp joined
[04:35] <lue> nom: my $a=3;

[04:35] <p6eval> nom:  ( no output )

[04:35] <lue> .oO(now I wonder what I broke...)

[04:38] *** QinGW joined
[04:47] <sorear> niecza: my $a=3;

[04:47] <p6eval> niecza v7-11-g9ba8284: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/dJAFeoaVlZ line 1:␤------> my ⏏$a=3;␤␤»

[04:48] <dalek> niecza: 0b2219d | sorear++ | / (2 files):

[04:48] <dalek> niecza: Fix +=-based meta operators (pmichaud++)

[04:48] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0b2219d912

[04:48] <thou> niecza: given my $a = 3 { .say }

[04:49] <p6eval> niecza v7-11-g9ba8284: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/dNAr8ElTyk line 1:␤------> given my ⏏$a = 3 { .say }␤␤3␤»

[04:49] <thou> nom: given my $a = 3 { .say }

[04:49] <p6eval> nom: OUTPUT«3␤»

[04:51] <lue> I know what I did (stupid bash insisting on interpolating "" strings)

[04:51] <sorear> hehe, we all do that

[04:51] <lue> nom: say 1..3; say 1...3;

[04:51] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤1..3␤1 2 3 ␤»

[04:51] <sorear> nowadays I have a habit of using '' for -e strings

[04:52] <sorear> remember you can use q[] in Perl

[04:52] <sorear> I wish for a bourney shell with Tcl-style quoting

[04:57] *** Bzek joined
[05:00] <lue> nom: say 1..3; print 1..3;

[05:00] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤1..3␤123»

[05:00] <sorear> nom: gist 1..3

[05:00] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤»

[05:00] <sorear> nom: (1..3).gist

[05:00] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤»

[05:07] <lue> |$ (as found in  sub say(|$) {  ) flattens what's fed to it, right?

[05:07] <sorear> no

[05:07] *** pjcj left
[05:08] <sorear> it's a bit of a fossil really

[05:08] <sorear> | in signatures used to be related to | in parameter lists

[05:08] <sorear> but now they're separate things

[05:08] <sorear> | in a signature means "get the full parameter list as a Capture object, accepting any combination of parameters"

[05:09] <sorear> |$ means "accept and ignore any parameters whatsoever"

[05:09] <sorear> in nom, |$ is usually used when the parameters are going to be accessed by Some Other Means

[05:09] <sorear> niecza uses "is rawcall" instead, but |$ is much more elegant; I'd like tos witch

[05:10] <lue> (in nom's src/core/IO.pm) I'm curious as to why print and say go about the task completely differently, when I'd imagine you just need to define say as "print plus newline" (I expect, though, it's not that easy.)

[05:11] <sorear> lue: you're stuck in the two weeks ago.  we completely changed the definition of say, it no longer has anything to do with print

[05:12] *** Zapelius left
[05:13] <lue> That explains my confusion :) [now to read the spec about the changes]

[05:15] <sorear> grep for "gist"

[05:23] <lue> so, (IIUC,)  say  now gets the .gist of what you pass to it, while print does what it does the old way.

[05:24] <lue> [admittedly I've never bothered to learn how exactly  say  did it, so I don't know how it used to do it.]

[05:25] <jnthn> morning, #perl6

[05:27] <sorear> JNTHN!

[05:27] <lue> so is nom's behavior right with    say 1..3;    ?

[05:28] <sorear> no

[05:28] <jnthn> o/ sorear 

[05:28] <sorear> I don't care what the spec says, nom's behavior is OBVIOUSLY WRONG :D

[05:29] <jnthn> nom: say 1...3

[05:29] <sorear> jnthn: how was #perl6 without me?

[05:29] <p6eval> nom: OUTPUT«1 2 3 ␤»

[05:29] <sorear> that's... also wrong.

[05:29] <jnthn> sorear: The air was kinda thick and smoke filled

[05:29] <jnthn> oh, wait, that's 'cus I was in Beijing while you were gone... :)

[05:29] <lue> nom: say 1..3; say 1...3;

[05:29] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤1..3␤1 2 3 ␤»

[05:30] * jnthn suspects those uninit value errors come from something internaly.

[05:30] <jnthn> Which is wrong, and thus how we get the errors

[05:30] <jnthn> pmichaud++ will probably spot when he backlogs :)

[05:31] <lue> Perl 6 internals or nqp internals?

[05:33] <jnthn> Something in CORE

[05:45] *** birdwindupbird joined
[05:54] <thou> rakudo: say "def".subst(/ 'd' ('e')? 'f' /, { 'D' ~ $0.perl ~ 'F' });

[05:54] <p6eval> rakudo 72d158: OUTPUT«DAnyF␤»

[05:55] <sorear> niecza: say "def".subst(/ 'd' ('e')? 'f' /, { 'D' ~ $0 ~ 'F' });

[05:55] <p6eval> niecza v7-12-g0b2219d: OUTPUT«DeF␤»

[05:55] <thou> anyone know how to get «DeF» out of that?

[05:55] <sorear> well first off, don't use .perl

[05:55] <thou> well, yeah

[05:55] <thou> doesn't help, rakudo gives me DAny()F then :-)

[05:55] *** zby_home left
[05:56] <thou> rakudo: say "def".subst(/ 'd' ('e'?) 'f' /, { 'D' ~ $0.perl ~ 'F' });

[05:56] <p6eval> rakudo 72d158: OUTPUT«DAnyF␤»

[05:56] <sorear> rakudo can't use match variables directly in subst closueres

[05:56] *** Khisanth left
[05:56] *** cooper left
[05:56] <sorear> at the cost of making your code unportable, you can use -> $/ { "D$0F" }

[05:56] <thou> i guess that got lost in -ng branch

[05:57] <sorear> why do you keep wanting to use .perl?

[05:57] * thou is trying to get some old code working

[05:57] *** [perlhack] joined
[05:57] <sorear> rakudo: say "def".subst(/ 'd' ('e')? 'f' /, -> $/ { 'D' ~ $0.perl ~ 'F' });

[05:57] <thou> no reason, just to see what's in the thing

[05:57] <p6eval> rakudo 72d158: OUTPUT«D[Match.new(␤ from => 1,␤ orig => "def",␤ to   => 2,␤)]F␤»

[05:59] <thou> sorear, thanks. i'll go with that, with a #RAKUDO comment to remind me that it's a buggy workaround

[05:59] <sorear> thou: what are you working on?

[06:00] *** Su-Shee_ is now known as Su-Shee

[06:03] <thou> sorear: trying to get november to work on current rakudo

[06:03] <thou> evidently rakudo *used* to be able to use match vars in subst closure :-)

[06:03] <thou> currently i'm going through "prove -r -eperl6 t" and getting it all to pass. using whatever means necessary. >:-}

[06:03] <thou> then i'll try to get the actual wiki running

[06:03] <thou> then i'll try to bring it up to date, using Web.pm and whatever modules are in the community

[06:03] <thou> at least, that's the current plan

[06:05] <sorear> I think I'll do the same thing :>

[06:06] *** Chillance joined
[06:13] *** Khisanth joined
[06:14] <thou> cool :-)

[06:14] <thou> i should put a fork on github then

[06:14] *** [perlhack] left
[06:14] <sorear> thou: I mean making November run on niecza.

[06:15] <thou> yeah, but we could compare notes

[06:15] <thou> s/but/and/

[06:15] <sorear> or whatever I will call the Perl 6 implementation I relase this month

[06:17] *** koban joined
[06:17] *** koban left
[06:18] *** pjcj joined
[06:19] *** drbean left
[06:20] *** Jackneill joined
[06:36] <dalek> rakudo/nom: b9db729 | jonathan++ | src/Perl6/Metamodel/ClassHOW.pm:

[06:36] <dalek> rakudo/nom: Fix .^isa bug spotted by tadzik++/pmichaud++; was missing decont, as guessed.

[06:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9db7290c7

[06:37] *** wtw joined
[06:42] *** birdwindupbird left
[06:46] *** pjcj left
[06:55] *** pjcj joined
[06:55] *** kytibe left
[06:57] *** quiccker joined
[07:00] *** beekor joined
[07:06] <dalek> nqp: 5c9cd12 | jonathan++ | src/ops/nqp.ops:

[07:06] <dalek> nqp: Add op for checking if an attr has been initialized, thus exposing one of the recent REPR additions.

[07:06] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5c9cd1284c

[07:14] *** drbean joined
[07:14] <dalek> niecza: 739ab2f | sorear++ | lib/CORE.setting:

[07:14] <dalek> niecza: Fix Match.perl after then $0 change

[07:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/739ab2f54a

[07:19] <dalek> rakudo/nom: 8cb00d5 | jonathan++ | / (2 files):

[07:19] <dalek> rakudo/nom: Fix my ($a, $, $b) = 1,2,3;

[07:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8cb00d5555

[07:19] <dalek> rakudo/nom: 8de8d4b | jonathan++ | / (2 files):

[07:19] <dalek> rakudo/nom: Bump NQP_REVISION; chase 6model API update.

[07:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8de8d4b26b

[07:19] <dalek> rakudo/nom: 672c32a | jonathan++ | src/ (2 files):

[07:19] <dalek> rakudo/nom: Only use default attr init closure if the attribute is not otherwise initialized. Should work even if user provides their own BUILD.

[07:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/672c32aec1

[07:19] <dalek> rakudo/nom: 9000c38 | jonathan++ | NOMMAP.markdown:

[07:19] <dalek> rakudo/nom: Update nommap.

[07:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9000c380b0

[07:28] <sorear> perl6: sub foo(@x is copy) { say @x.perl }; foo([1,2,3])

[07:28] <p6eval> pugs: OUTPUT«[[1, 2, 3],]␤»

[07:28] <p6eval> ..rakudo 72d158: OUTPUT«[1, 2, 3]␤»

[07:28] <p6eval> ..niecza v7-13-g739ab2f: OUTPUT«[[1, 2, 3]].list␤»

[07:29] <jnthn> nom: sub foo(@x is copy) { say @x.perl }; foo([1,2,3])

[07:29] <p6eval> nom: OUTPUT«Array.new(1, 2, 3)␤»

[07:30] <sorear> jnthn: why?

[07:34] <jnthn> sorear: why what?

[07:35] <sorear> jnthn: why does rakudo do that?

[07:35] <jnthn> Dunno. It's not wrong, I guess...

[07:36] <jnthn> nom: say [1,2,3].perl

[07:36] <p6eval> nom: OUTPUT«[1, 2, 3]␤»

[07:36] <jnthn> oh

[07:36] <jnthn> hm

[07:36] <jnthn> oh!

[07:36] <jnthn> I guess it's flattening or not, or something

[07:37] <jnthn> sorear: For anything on list/array handling, pmichaud is the right person to ask. I've barely been following that area.

[07:37] <sorear> jnthn: niecza interprets @x is copy as \$x; my @x = $x

[07:37] <sorear> I'm changing it now to do a proper list binding *first*

[07:38] <sorear> (well, a sort of proper list binding.  It doesn't actually check for Positional...)

[07:38] <jnthn> sorear: Forget exactly what the binder does there, but I think it's a normal list assignment.

[07:40] *** pjcj left
[07:43] <thou> sorear:  getting close, down to two kinds of failure: https://gist.github.com/1069055

[07:43] *** mj41 joined
[07:45] <dalek> rakudo/nom: 2898945 | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[07:45] <dalek> rakudo/nom: Add missing multi-dispatch cache invalidation.

[07:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2898945c02

[07:45] <dalek> rakudo/nom: 3279598 | jonathan++ | NOMMAP.markdown:

[07:45] <dalek> rakudo/nom: Remove now-resolved .Bool dispatch issue from nommap.

[07:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3279598353

[07:45] <jnthn> Time to give $dayjob some love.

[07:49] *** pjcj joined
[07:52] *** ab5tract joined
[07:59] <dalek> niecza: bad54f1 | sorear++ | / (2 files):

[07:59] <dalek> niecza: Fix @x is copy for non-flatteny arguments

[07:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bad54f1bb8

[08:05] <tadzik> good morning zebras

[08:05] <sorear> hello, tadzik

[08:06] <jnthn> o/ tadzik 

[08:09] <tadzik> sorear: welcome back!

[08:09] <tadzik> jnthn: thanks for fixing the isa

[08:10] *** daxim joined
[08:11] <sorear> tadzik: thank you

[08:11] <jnthn> tadzik: welcome. I mostly need to focus on $dayjob for the next hours, but if you hit any other blockers lemme know and I can look

[08:11] <tadzik> jnthn: no worries

[08:12] <moritz_> good morning

[08:12] <tadzik> good morning moritz_ 

[08:12] <moritz_> tadzik: how's life and hacking?

[08:12] <sorear> moritz_: in backlog, you said you had an issue with niecza on 2.6.7

[08:12] <sorear> moritz_: what was it?

[08:13] <tadzik> moritz_: very good. We have pod tests in nom now :)

[08:13] <tadzik> see the blog post too

[08:14] <moritz_> sorear: after the new release, simply typing "make" resulted in completly borked niecza. git clean -xdf fixed it

[08:14] *** eiro is now known as marc

[08:14] *** marc is now known as eiro

[08:15] <moritz_> (in an updated git checkout, that is)

[08:15] *** Jackneill left
[08:15] <sorear> I see

[08:18] <moritz_> tadzik++ # blog post

[08:18] <jnthn> o/ moritz_ 

[08:18] *** wamba joined
[08:19] <tadzik> moritz_: what's the policy on rakudo's t/? What if I want to check the passes in t/pod/, should do I do it manually, add a makefile target?

[08:19] * moritz_ starts his day with 'git log' in nom, even before reading hackernews or perlmonks :-)

[08:19] <moritz_> tadzik: makefile target is fine

[08:20] <moritz_> tadzik: you could also have the default 'make test' run them, but I guess that's a bit too noisy for you right now

[08:21] <tadzik> yes. One merry day they'll just become spectests I believe. The form will have to be decided, for now it's "whatever works"

[08:22] <jnthn> moritz_: I'm worse than that, these days I read the nom commits page from GitHub on my phone before getting out of bed :)

[08:22] <jnthn> Then I know what bugs to think about fixes for in the shower. :)

[08:22] <moritz_> tadzik: I'm fine with a 'make podtest' or whatever you want to call it

[08:22] <tadzik> these days, when I wake up, I pick my laptop from under the bed and read the rss akregator

[08:24] <tadzik> yesterday, just before I got asleep, a thought came "hey, that's just a spli() I need!", and I had to note it down :) I should maybe move from code commets to my paper notebook

[08:24] *** ab5tract left
[08:28] *** Jackneill joined
[08:33] *** alim joined
[08:33] *** alim is now known as fimgolfin

[08:33] <tadzik> "Defaults should only be used if attribute never accessed", says NOMMAP. What if a default is ' = die "is a required parameter"'?

[08:34] * sorear -> seleep

[08:35] <tadzik> g'night

[08:35] <dalek> rakudo/podparser: b9db729 | jonathan++ | src/Perl6/Metamodel/ClassHOW.pm:

[08:35] <dalek> rakudo/podparser: Fix .^isa bug spotted by tadzik++/pmichaud++; was missing decont, as guessed.

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/b9db7290c7

[08:35] <dalek> rakudo/podparser: 8cb00d5 | jonathan++ | / (2 files):

[08:35] <dalek> rakudo/podparser: Fix my ($a, $, $b) = 1,2,3;

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/8cb00d5555

[08:35] <dalek> rakudo/podparser: 8de8d4b | jonathan++ | / (2 files):

[08:35] <dalek> rakudo/podparser: Bump NQP_REVISION; chase 6model API update.

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/8de8d4b26b

[08:35] <dalek> rakudo/podparser: 672c32a | jonathan++ | src/ (2 files):

[08:35] <dalek> rakudo/podparser: Only use default attr init closure if the attribute is not otherwise initialized. Should work even if user provides their own BUILD.

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/672c32aec1

[08:35] <dalek> rakudo/podparser: 9000c38 | jonathan++ | NOMMAP.markdown:

[08:35] <dalek> rakudo/podparser: Update nommap.

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/9000c380b0

[08:35] <dalek> rakudo/podparser: 2898945 | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[08:35] <dalek> rakudo/podparser: Add missing multi-dispatch cache invalidation.

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/2898945c02

[08:35] <dalek> rakudo/podparser: 3279598 | jonathan++ | NOMMAP.markdown:

[08:35] <dalek> rakudo/podparser: Remove now-resolved .Bool dispatch issue from nommap.

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/3279598353

[08:35] <dalek> rakudo/podparser: 9cd2db4 | tadzik++ | / (13 files):

[08:35] <dalek> rakudo/podparser: Merge branch 'nom' into podparser

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/9cd2db4892

[08:35] <dalek> rakudo/podparser: 9fb8447 | tadzik++ | t/pod/01-delimited.t:

[08:35] <dalek> rakudo/podparser: Untodo a test thanks to isa fixes

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/9fb8447a60

[08:35] <dalek> rakudo/podparser: 75c79fb | tadzik++ | tools/build/Makefile.in:

[08:35] <dalek> rakudo/podparser: [Makefile] Add a podtest target

[08:35] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/75c79fb828

[08:35] <tadzik> blfh

[08:36] *** wamba left
[08:48] *** mj41 left
[08:51] *** ab5tract joined
[08:52] <dalek> rakudo/nom: cc83922 | moritz++ | t/spectest.data:

[08:52] <dalek> rakudo/nom: 6 more passing test files (now at 4.6k passing tests)

[08:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cc83922ca4

[08:53] <dalek> roast: a0a2a81 | moritz++ | S (3 files):

[08:53] <dalek> roast: assorted rakudo unfudges

[08:53] <dalek> roast: review: https://github.com/perl6/roast/commit/a0a2a81290

[08:53] <jnthn> feeds?!

[08:54] <jnthn> nom: 1,2,3,4 ==> map * ** 2 ==> join '\n' ==> say

[08:54] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, Positional @values)␤␤current instr.: 'map' pc 327903 (src/gen/CORE.setting.pir:80336) (src/gen/CORE.setting:595)␤»

[08:54] <jnthn> nom: 1,2,3,4 ==> join '\n' ==> say

[08:54] <p6eval> nom: OUTPUT«1\n2\n3\n4␤»

[08:54] <jnthn> er :)

[08:54] <jnthn> hm

[08:55] *** dakkar joined
[08:55] <jnthn> nom: say map * + 2, 1,2,3,4;

[08:55] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, Positional @values)␤␤current instr.: 'map' pc 327903 (src/gen/CORE.setting.pir:80336) (src/gen/CORE.setting:595)␤»

[08:55] <jnthn> nom: say map * + 2, (1,2,3,4);

[08:55] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, Positional @values)␤␤current instr.: 'map' pc 327903 (src/gen/CORE.setting.pir:80336) (src/gen/CORE.setting:595)␤»

[08:55] <jnthn> nom: say (* + 2).WHAT

[08:55] <p6eval> nom: OUTPUT«_block1014␤»

[08:55] <jnthn> nom: say (* + 2) ~~ Callable

[08:55] <p6eval> nom: OUTPUT«Bool::False␤»

[08:55] <jnthn> er

[08:56] <jnthn> nom: * + 2

[08:56] <p6eval> nom:  ( no output )

[08:56] <jnthn> nom: say (* + 2)(2)

[08:56] <p6eval> nom: OUTPUT«4␤»

[08:56] <jnthn> nom: my $x = * + 2; say $s.WHAT

[08:56] <p6eval> nom: OUTPUT«Symbol '$s' not predeclared in <anonymous> (/tmp/olXaiWgVgx:1)␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[08:56] <jnthn> nom: my $x = * + 2; say $x.WHAT

[08:56] <p6eval> nom: OUTPUT«WhateverCode()␤»

[08:57] <jlaire> nom: my $f = * + 2; say map $f, 1,2,3,4;

[08:57] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, Positional @values)␤␤current instr.: 'map' pc 327903 (src/gen/CORE.setting.pir:80336) (src/gen/CORE.setting:595)␤»

[08:57] <jnthn> nom: my $f = * + 2; say map $f, (1,2,3,4);

[08:58] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, Positional @values)␤␤current instr.: 'map' pc 327903 (src/gen/CORE.setting.pir:80336) (src/gen/CORE.setting:595)␤»

[08:58] <jnthn> nom: my $f = * + 2; say map $f, [1,2,3,4];

[08:58] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, Positional @values)␤␤current instr.: 'map' pc 327903 (src/gen/CORE.setting.pir:80336) (src/gen/CORE.setting:595)␤»

[08:58] <jnthn> nom: say WhateverCode ~~ Callable

[08:58] <jlaire> nom: sub f(Callable $x) { say 42 }; f(* + 2)

[08:58] <p6eval> nom: OUTPUT«Nominal type check failed for parameter '$x'; expected Callable but got WhateverCode instead␤current instr.: 'f' pc 383 ((file unknown):63865447) (/tmp/VpfIeEcM2H:1)␤»

[08:58] <p6eval> nom: OUTPUT«Bool::False␤»

[08:58] <jnthn> oh

[08:58] <jnthn> That's the real issue. WhateverCode doesn't do Callable

[08:59] <jnthn> nom: say Code ~~ Callable

[08:59] <p6eval> nom: OUTPUT«Bool::True␤»

[08:59] <jnthn> nom: say WhateverCode ~~ Callable

[08:59] <p6eval> nom: OUTPUT«Bool::False␤»

[08:59] <jnthn> hm

[08:59] <jlaire> nom: say WhateverCode ~~ Code

[08:59] <p6eval> nom: OUTPUT«Bool::True␤»

[09:05] <jnthn> oh, I see what's going on...

[09:14] <dalek> rakudo/nom: 5c39eca | jonathan++ | / (3 files):

[09:14] <dalek> rakudo/nom: Should not compose subclasses before their parent classes (will support this later probably, but for now it's a no-no). Fixes WhateverCode ~~ Callable issue.

[09:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5c39eca734

[09:16] *** pjcj left
[09:19] *** _twitch joined
[09:19] *** Mowah joined
[09:28] *** Jackneill left
[09:29] *** bbkr joined
[09:31] *** cognominal left
[09:31] *** cognominal joined
[09:35] *** frettled left
[09:35] *** frettled joined
[09:38] *** pjcj joined
[09:42] <thou> perl6: say ([1,2] Z [*,*]).perl

[09:42] <p6eval> niecza v7-14-gbad54f1: OUTPUT«([1, 2], [Whatever.new(...), Whatever.new(...)]).list␤»

[09:42] <p6eval> ..rakudo 72d158: OUTPUT«(1, Any, 2, Any)␤»

[09:42] <p6eval> ..pugs: OUTPUT«((1, Inf), (2, Inf))␤»

[09:42] <thou> nom: say ([1,2] Z [*,*]).perl

[09:42] <p6eval> nom: OUTPUT«((1, Whatever<77724736>), (2, Whatever<77724496>)).list␤»

[09:59] *** woosley left
[10:02] *** QinGW left
[10:03] *** mj41 joined
[10:03] *** satyavvd joined
[10:06] *** _twitch left
[10:15] <dalek> roast: 53c1453 | moritz++ | S (6 files):

[10:15] <dalek> roast: rakudo unfudges

[10:15] <dalek> roast: review: https://github.com/perl6/roast/commit/53c1453d47

[10:22] <thou> \o/  All tests successful.   Files=43, Tests=236, 362 wallclock secs ( 0.25 usr  0.20 sys + 210.91 cusr 13.68 csys = 225.04 CPU)  Result: PASS 

[10:22] *** agentzh left
[10:22] <moritz_> nom: say Bool.pick

[10:22] <p6eval> nom: OUTPUT«Bool()␤»

[10:23] <thou> moritz_: i got november test suite passing on current rakudo :-)

[10:23] *** _twitch joined
[10:23] <moritz_> thou: that's great

[10:24] <moritz_> thou: I hope you have a commit bit, and have pushed it :-)

[10:24] *** hugme joined
[10:24] *** ChanServ sets mode: +v hugme

[10:24] * moritz_ wonders why hugme keeps leaving and not rejoining

[10:25] <dalek> roast: b9895db | moritz++ | S02-builtin_data_types/array_ref.t:

[10:25] <dalek> roast: fudge a failing test in array_ref.t for rakudo

[10:25] <dalek> roast: review: https://github.com/perl6/roast/commit/b9895db12d

[10:26] *** _twitch left
[10:27] *** whiteknight joined
[10:29] *** mj41 left
[10:29] *** mj41 joined
[10:30] *** kthakore left
[10:30] *** Chillance left
[10:33] *** kthakore joined
[10:34] <dalek> roast: c221290 | moritz++ | S02-builtin_data_types/bool.t:

[10:34] <dalek> roast: fudge bool.t for rakudo

[10:34] <dalek> roast: review: https://github.com/perl6/roast/commit/c221290239

[10:34] <moritz_> I should push fudges *before* I add the test file to t/spectest.data :-)

[10:35] *** felher left
[10:36] <jnthn> ;-)

[10:40] *** felher joined
[10:42] *** buubot_backup left
[10:50] *** [Coke] left
[10:50] *** im2ee joined
[10:50] <tadzik> thou: current Rakudo means Rakudo master?

[10:50] <thou> yes

[10:50] <tadzik> nice

[10:51] <thou> i'll need a few more features in nom (grammars, for instance)

[10:51] *** [Coke] joined
[10:51] <tadzik> oh, november is not Web.pm-dependant

[10:51] <thou> not yet :-)

[10:51] <tadzik> I see :)

[10:52] <tadzik> Web.pm started passing some tests recently

[10:52] <tadzik> (on master)

[10:52] <thou> once i get november working, i'd like to convert it to web.pm

[10:53] <jnthn> thou++

[10:53] <tadzik> nom: my $array_ref1 = ("foo", "bar", "baz"); $array_ref1 ~~ Seq

[10:53] <p6eval> nom:  ( no output )

[10:53] <tadzik> nom: my $array_ref1 = ("foo", "bar", "baz"); say $array_ref1 ~~ Seq

[10:53] <p6eval> nom: OUTPUT«Bool::False␤»

[10:53] <tadzik> looks like a recent isa fix regression

[10:53] <moritz_> nom: my $array_ref1 = ("foo", "bar", "baz"); say $array_ref1.WHAT

[10:53] <jnthn> tadzik: Don't think nom uses Seq for anything yet

[10:53] <p6eval> nom: OUTPUT«Parcel()␤»

[10:54] <moritz_> nom: say Parcel ~~ Seq

[10:54] <jnthn> It's stubbed but that's all.

[10:54] <p6eval> nom: OUTPUT«Bool::False␤»

[10:54] <tadzik> or maybe it's a new test

[10:54] <moritz_> tadzik: if we ever passed that test, it was a false positive

[10:54] <im2ee> Perl6 is still Larry's creation? :)

[10:54] <jnthn> (false positive) yes, agree

[10:54] <tadzik> im2ee: yes

[10:55] <im2ee> Hm, I'm learning Perl5, it's better to change Perl5 to Perl6?

[10:56] <moritz_> im2ee: what do you want to do with it?

[10:56] <flussence> .oO( you know you're having a bad day when you find statements like "int(sprintf($_/255*100)).'%'" )

[10:56] <im2ee> Hmm, I don't have specific way.

[10:57] <tadzik> im2ee: is it just for fun, not for a Job opportunities or anything?

[10:57] <dalek> rakudo/nom: 1dc9308 | moritz++ | / (2 files):

[10:57] <dalek> rakudo/nom: Bool.Int, run tests

[10:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1dc9308bb8

[10:57] <dalek> rakudo/nom: 32ab8d4 | moritz++ | src/core/BackTrace.pm:

[10:57] <dalek> rakudo/nom: change BackTrace handling a bit: collect all the information, and only filter on strintification

[10:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32ab8d4b1f

[10:57] <moritz_> im2ee: in here we believe that Perl 6 is certainly the nicer language, but we can't yet compete with perl 5's maturity and module system

[10:58] <im2ee> Hm, now It's for fun, but in future i want to use Perl for a job.

[10:58] <tadzik> Perl 6 is not really enterprise-y in its current state

[10:59] <im2ee> So, I should learn Perl5 at the beggining?

[10:59] <im2ee> beginning*

[11:00] <tadzik> if you plan to use it professionally, Perl 5 is probably the way to go

[11:00] <flussence> learn both, they're different languages

[11:01] <tadzik> learning both at the same time may be a bit confusing

[11:02] <flussence> well not at the same time, but limiting yourself to one language won't benefit you much :)

[11:03] *** wamba joined
[11:03] <im2ee> Ok. Thanks. :)

[11:03] <im2ee> I saw this: http://www.perlfoundation.org/perl6/index.cgi?best_of_perl_6_tablet

[11:03] *** buubot_backup joined
[11:03] <im2ee> And Perl6 impressed me.

[11:03] <im2ee> :)

[11:04] <tadzik> yes, Perl 6 is quite impressive :) That's why we use it even though not everything is ready

[11:05] <im2ee> When it'll be ready? :)

[11:05] <tadzik> although the "Case construct" part is lying a bit"

[11:05] <tadzik> "

[11:07] <tadzik> im2ee: before christmas :)

[11:07] <flussence> tadzik: I can see plenty more code errors on that page... it's a good effort though :)

[11:07] <im2ee> Great! :)

[11:08] <tadzik> im2ee: at least that's what Larry said in 2000 :)

[11:09] *** mj41 left
[11:09] <im2ee> :) Ok

[11:10] <im2ee> So i go back to learning Perl5! :)

[11:10] <im2ee> Thanks for help. :)

[11:12] <tadzik> you're welcome :)

[11:12] <flussence> just make sure you learn good Perl 5, and not from out of date examples or something: http://www.onyxneon.com/books/modern_perl/index.html

[11:12] <flussence> (that's a good starting point)

[11:13] *** daniel-s left
[11:16] *** [Coke] left
[11:18] *** [Coke] joined
[11:21] *** mls joined
[11:22] <mls> jnthn: I've got a question about the autoviv handling in 6model/reprs/P6opaque.c

[11:24] *** mj41 joined
[11:26] <mls> when repr_data->auto_viv_conf gets allocated, shouldn't the code alloc info_

[11:26] *** [Coke] left
[11:27] <mls> and shouldn't the code realloc the auto_viv_conf block after it knows how many entries are needed?

[11:28] <jnthn> mls: looking

[11:28] *** [Coke] joined
[11:28] <mls> OTOH if memory is not that much of an issue, wouldn't it be better to just use the slot to index auto_viv_conf instead of checking for a matching offset?

[11:29] <jnthn> mls: INTVAL info_alloc   = num_attrs == 0 ? 1 : num_attrs;

[11:29] <jnthn> There will never be more auto-vivs than there are attrs.

[11:30] <mls> yes, but the while loop later runs until it hits cur_auto_viv_conf->offset == NULL

[11:30] <jnthn> ah

[11:30] <jnthn> yeah, I see

[11:30] <jnthn> fail.

[11:31] <mls> no, not fail

[11:31] <jnthn> Yeah, 'tis a bug. Thanks

[11:31] <jnthn> mls++

[11:31] <mls> I guess it always finds the offset if the array is "full"

[11:31] <jnthn> Oh

[11:31] <jnthn> Yeah, you're right.

[11:31] <jnthn> But still, it's risky.

[11:31] <jnthn> It should always work though

[11:31] <mls> Yes. I was just wondering if an realloc would make sense.

[11:32] <mls> or, if indexing with the slot wouldn't be better instead of searching for the offset

[11:32] <jnthn> Maybe...realloc ain't free either.

[11:32] <jnthn> Indexing with the slot *would* be a win.

[11:32] <jnthn> If we're going to allocate the lot, may as well use it efficienlty.

[11:33] <mls> Right.

[11:33] <mls> That might actually save some memory because you don't need to store the offset

[11:34] <jnthn> Hm, yes.

[11:34] <mls> depending on how many slots use autoviv)

[11:34] <jnthn> That depends mostly on the language...NQP doesn't use it at all, Rakudo uses it heavily.

[11:35] <mls> if it doesn't get used at all, the array is not allocated, so it doesn't hurt for nqp

[11:35] <jnthn> Right

[11:35] <jnthn> I think for the most part - native attrs aside - it's probably all or nothing.

[11:35] <mls> so switching to index by slot would be a win.

[11:36] <jnthn> Yeah, and now that I know I'm killing the ->spill thingy, there's no reason index by slot won't work out.

[11:37] <mls> nice. ok, I just wanted to draw your attention to the code. Thanks!

[11:37] <jnthn> mls: Noted it down, so I won't forget it. Thanks!

[11:38] <jnthn> mls: Also, if you have time/interest, I'd happily accept a patch.

[11:38] <jnthn> mls: Otherwise, will get to it in the near future.

[11:38] <jnthn> I'll be in P6opaque.c soon anyway to sort out mixin support.

[11:38] <mls> okay. Maybe I find some spare time ;-)

[11:38] <jnthn> :)

[11:39] <tadzik> huh. Are there any circumstances under which a Match object's .ast can disappear over time?

[11:40] <jnthn> tadzik: Gee, I hope not :)

[11:40] <jnthn> tadzik: Never seen anything like that happen...

[11:41] <jnthn> tadzik: Can probably guess more if I see some code and what you're running into

[11:42] *** Chillance joined
[11:42] <tadzik> yeah, gisting

[11:42] <tadzik> jnthn: https://gist.github.com/1069339

[11:45] *** thou left
[11:46] *** birdwindupbird joined
[11:46] *** [Coke] left
[11:48] <jnthn> for $<pod_content> { ... }

[11:48] *** [Coke] joined
[11:48] <jnthn> tadzik: What does that actually capture?

[11:48] *** im2ee left
[11:49] <tadzik> jnthn: that can be either pod_content:sym<text> of pod_content:sym<block>

[11:49] <tadzik> the first's ast is an array of strings, the second's is a Pod::Block

[11:49] <tadzik> that's why I'm checking whether it's an array or not

[11:49] <jnthn> Your action method is for pod_block though, not pod_content

[11:50] <tadzik> hmm

[11:50] <jnthn> token pod_content:sym<block> {

[11:50] <tadzik> oh wait

[11:50] <jnthn> Do you have an action method for this, which passes the AST made for <pod_block> oh up?

[11:50] <jnthn> *on

[11:50] <tadzik> token pod_content:sym<block> has <pod_block> inside, true

[11:50] *** satyavvd left
[11:51] <jnthn> Right, you need to explicitly pass the AST upwards

[11:51] <tadzik> looks that I don't. I wonder how did that work...

[11:51] <tadzik> you're right, thank you

[11:51] <jnthn> np :)

[11:51] *** thou joined
[11:51] <jnthn> Side benefit of this is once you grok it all well, you'll grok how much of the rest of Rakudo's grammar/actions work :)

[11:52] <tadzik> yeah, it's all about learning, isn't it? :)

[11:53] <tadzik> yay, works!

[11:53] <tadzik> jnthn++

[11:53] <tadzik> next step: I'm stubbing every prototype in gsocmess, Justin Case :)

[11:54] <jnthn> tadzik: Note you never need methods for the proto

[11:54] <jnthn> (action methods, that is)

[11:54] <jnthn> Just the candidates.

[11:55] <tadzik> yes, I know that

[11:55] <tadzik> when I say "prototype" I mean "the Pod6 module I wrote in Perl 6"

[11:56] <jnthn> ah, I see :)

[11:56] <tadzik> oh, I also have a funny List vs. Array issue, but that's not a blocker so I won't bother you now

[11:56] <jnthn> k

[11:56] * jnthn tries to actually do some $dayjob stuff ;)

[11:57] <tadzik> sorry for distracting you

[11:57] *** mls left
[11:57] <jnthn> it's fine :)

[11:58] *** JimmyZ joined
[11:59] <JimmyZ> good evening, #perl6

[11:59] <pmichaud> good morning, #perl6

[11:59] <JimmyZ> and .... good morning, pmichaud 

[12:01] <jnthn> o/ pmichaud, JimmyZ 

[12:05] <moritz_> \o *

[12:06] *** lichtkind joined
[12:06] * JimmyZ is having dinner

[12:09] * tadzik is having fun :)

[12:11] *** nwc10 joined
[12:11] <nwc10> This might be the wrong time of day to ask this question.

[12:11] <nwc10> As I understand it, subroutine parameters are read only by default

[12:11] <nwc10> and you can pass an array or hash as a subroutine parameter

[12:12] * moritz_ nods

[12:12] <nwc10> "how" read-only does that make the hash or array? Is it shallow or deep? Does it just stop you changing the number of entries in the hash or array (no adding or removing) or does it create a recursively read only representation?

[12:12] <nwc10> what, "nod, wrong time"? :-)

[12:12] <moritz_> nod, "you're right so far"

[12:12] <moritz_> it's not recursive

[12:12] <pmichaud> the readonly-ness is somewhat shallow, iiuc

[12:13] <moritz_> to the best of my knowledge,  sub f(@a) { @a = ... } # forbidden

[12:13] <moritz_> sub f(@a) { @a[0] = ... } # forbidden, but the compiler doesn't have to enforce it

[12:14] <moritz_> @a[0].some-rw-attrib = "foo"; # allowed

[12:14] <jnthn> There's a bunch of open questions in this area

[12:14] <dalek> rakudo/podparser: 13ce60f | tadzik++ | / (2 files):

[12:14] <dalek> rakudo/podparser: Fix nested blocks, import more tests for that

[12:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/13ce60fea1

[12:14] <dalek> rakudo/podparser: 587360f | tadzik++ | t/pod/01-delimited.t:

[12:14] <dalek> rakudo/podparser: Import more pod tests. We now fully pass 01-delimited.t

[12:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/587360fe08

[12:14] <jnthn> Basically, the more we try to enforce in a hard way at runtime, the more costly it gets.

[12:14] <nwc10> cool, you can stop answering now *if you want*

[12:14] <nwc10> because that's already really useful

[12:14] <moritz_> nwc10: in the end, it will boil down to a compromise between performance and safety

[12:14] <nwc10> (was about to mail something to perl5-porters

[12:14] <nwc10> )

[12:15] <moritz_> nwc10: only experimenting with the implementations will show what's feasible

[12:15] * jnthn is hoping that we can do enough detection of these things at compile time to cope

[12:15] <moritz_> nwc10: are you trying to port (parts) of signatures to Perl 5?

[12:15] <pmichaud> I need to start remembering to 'git push' my local changes.  :)

[12:15] <jnthn> And not have to do any extra runtime checks

[12:15] <moritz_> pmichaud: if you don't, you'll have to rebase later :-)

[12:16] <nwc10> "port" may not be the right answer, strictly

[12:16] <moritz_> tadzik++ # podparser progress

[12:16] <moritz_> nwc10: "draw inspiration from"? :-)

[12:16] <nwc10> Perl 5 is missing function signatures

[12:16] <nwc10> we know that one of the key things is being able to have read only access to read write variables

[12:17] <nwc10> and Perl 5 currently can't enforce read only on hashes and arrays

[12:17] <moritz_> (most of us know a decent bit of p5 too, fwiw)

[12:17] <jnthn> nwc10: Nor can Rakudo.

[12:17] <nwc10> and then I was wondering "but what should be enforced, if we say it's read only?"

[12:17] <flussence> if you want a read-only array, just subclass it with all the mutator methods replaced by {!!!} and in the signature put ($myarray as ReadOnlyArray). Or something.

[12:17] <moritz_> flussence: but that involves either a copy or a rebless

[12:18] <jnthn> nwc10: If it's down to me, we'll do nothing about this at runtime, and detect the obvious cases statically

[12:18] <moritz_> flussence: but signature *binding* is, well, binding :-)

[12:18] <pmichaud> well, in nom we might be able to enforce one level of ro-ness on Array when we have all of the container elements sharing the same descriptor.

[12:18] <jnthn> nwc10: Here's the thing. Indexed access in Perl 6 is a method call

[12:18] <flussence> (is there a cheap way of saying "be this object now"?)

[12:18] <jnthn> And we agree that mutating method calls don't fall under the heading of what ro enforces.

[12:19] <moritz_> flussence: in p5, a rebless is relatively cheap, but probably not cheap enough to do it on every subroutine invocation

[12:19] <nwc10> raw arrays aren't blessed objects

[12:19] <moritz_> or maybe it is... I'm not sure

[12:19] <jnthn> So in my book that means that @a[0] = 42 ==> @a.postcircumfix:<[ ]>(0) = 42

[12:19] <jnthn> Is a method call

[12:19] <jnthn> nwc10: Right, in Perl 5 that's the case.

[12:19] <jnthn> nwc10: In Perl 6 everything but native types are essentially blessed.

[12:19] <flussence> moritz_: I imagine it is, after all you're only relabelling a reference.

[12:20] <jnthn> Anyway, to me there's no difference between @x[0] = 42 and $x.y = 42 in Perl 6 really, so any additional readonlyless is hard to enforce.

[12:20] *** thou left
[12:20] <moritz_> hugme: list projects

[12:20] <hugme> moritz_: I know about Math-Model, Math-RungeKutta, MiniDBI, bench-scripts, book, gge, hugme, ilbot, java2perl6, json, modules.perl6.org, november, nqp-rx, nqpbook, perl6, perl6-examples, perl6-wtop, proto, pugs, rakudo, star, svg-matchdumper, svg-plot, tardis, try.rakudo.org, tufte, ufo, web, yapsi

[12:21] <moritz_> hugme: add softmoth to november

[12:21] * hugme hugs softmoth. Welcome to november!

[12:21] <pmichaud> jnthn: Array's at_pos method (which is what postcircumfix:<[ ]> uses underneath) can certainly do some relatively inexpensive ro checking, though.

[12:22] <jnthn> pmichaud: I don't understand the container descriptor suggestion.

[12:22] <tadzik> syntax hilighting is screwed when it comes to paragraph blocks :/

[12:22] <pmichaud> jnthn: yeah, I'm not awake yet.  ignore that one.

[12:22] <jnthn> pmichaud: When we bind an argument it's the original thing, so same CD.

[12:22] <jnthn> pmichaud: :)

[12:22] <nwc10> pull coffee, pause, *then* git push

[12:23] <tadzik> oh wait, it isn't :)

[12:23] <pmichaud> when you bind an argument, it's not *exactly* the original thing.  it's a ro container referencing the original thing

[12:24] <jnthn> pmichaud: Yeah. I'm mostly hopeful we'll be able to do enough compile-time analysis (probably in the optimizer) to optimize that away at some point.

[12:24] <pmichaud> if we can multidispatch based on the ro-ness of the invocant, it can be fairly cheap.

[12:24] <moritz_> phenny: tell though thanks for the November pull request. I merged it, and gave you a commit bit - much easier in the long run than having to merge your stuff :-)

[12:24] <phenny> moritz_: I'll pass that on when though is around.

[12:25] <jnthn> moritz_: though or thou? :)

[12:25] <moritz_> oh.

[12:26] <jnthn> Message thee correctly!

[12:26] <TimToady> I still wonder whether we can get really cheap write capabilities by throwing a 1 bit into a ro pointer...

[12:26] <moritz_> phenny: tell thou thanks for the November pull request. I merged it, and gave you a commit bit - much easier in the long run than having to merge your stuff :-)

[12:26] <phenny> moritz_: I'll pass that on when thou is around.

[12:26] <moritz_> phenny: tell though sorry, wasn't meant for you, please ignore the previous message

[12:26] <phenny> moritz_: I'll pass that on when though is around.

[12:27] <nwc10> TimToady: can one combine the write-time check for "is this actually read only?" with a GC's write barrier code?

[12:28] <moritz_> that's something I wouldn't want to conflate

[12:29] <dalek> rakudo/podparser: 25cc743 | tadzik++ | / (3 files):

[12:29] <dalek> rakudo/podparser: Parse paragraph and abbreviated blocks, import tests for those (everything passes)

[12:29] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/25cc743422

[12:30] <nwc10> Fair enough. It's just that I see two actions when writing that are both "stop, wait a mo, do I need to do something more careful here?"

[12:30] *** mberends joined
[12:30] <tadzik> 6 lines of code, 220 lines of tests :)

[12:30] <mberends> o/ zebrae

[12:31] <tadzik> hello mberends!

[12:31] <jnthn> mberends: zebry of course :P

[12:31] <TimToady> well, we've got the 1 bit and the 2 bit available in most pointers :)

[12:32] <jnthn> TimToady: You're good at making assumptions about how malleable runtime environments will be. Good luck fiddling with 1 bit on CLR/JVM/v8 references...

[12:32] <TimToady> and the 4 bit and 8 bit

[12:32] <TimToady> I am aware of that issue :)

[12:33] <jnthn> TimToady: More interesting is "how much can we figure out statically, so we can just get on with stuff at runtime" :)

[12:33] <TimToady> just wondering how fast a native p6 can run

[12:33] *** everbrew left
[12:34] <nwc10> v8 is already using (at least) 1 bit of pointers. If the video I watched about it is still valid

[12:34] <tadzik> jnthn: what's the tiniest valid SixModelObject, close to Nil, or noop of some sort?

[12:34] <tadzik> or maybe I don't need that

[12:35] <jnthn> tadzik: Tiniest in what sense?

[12:35] <nwc10> I'm also suspecting that the only time you can go bit fiddling on pointers is if you are "native"

[12:35] <nwc10> (and you don't need to use valgrind to debug your code)

[12:35] <jnthn> I figure if you bit-fiddle you gotta to a bitop on your "pointer" to remove your fiddle every time you want to deref it too?

[12:35] <jnthn> *do a bitop

[12:36] <tadzik> jnthn: like when I have to pass a valid SixModelObject, I'm looking for some neutral element, like 0 in addition. But I can probably avoid cheats like that

[12:36] <jnthn> tadzik: Mu? :)

[12:36] <mberends> jnthn: while on unexpected vacation in Croatia, I've started work on 6model/c :-)

[12:36] <jnthn> mberends: oh, nice :)

[12:36] <jnthn> mberends: I'm curious how that'll turn out.

[12:37] <jnthn> mberends: Recommend seeing nqp's sixmodelobject.h for the latest API

[12:38] <mberends> jnthn: thanks, that's a useful tip. I hope a pull from 10 days ago is current enough.

[12:38] <nwc10> jnthn: yes, sort of. V8 was doing sick tricks by using bit 0 clear to mean integer, bit 0 set to mean pointer, and then storing "structure" offsets to things as +3 or +7 etc

[12:38] <tadzik> moritz_: importing my t/04-end.t may be a bit tricky (having multiple =END declarators is doomed to fail :)), so how about I pass the spectests instead?

[12:38] <dalek> rakudo/nom: 8f7a4ec | pmichaud++ | src/core/Nil.pm:

[12:38] <dalek> rakudo/nom: Nil should stringify to '' without an "undefined" warning.

[12:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8f7a4ec08c

[12:38] <nwc10> IIRC from the Google video recorded a couple of years back, that I only watched recently.

[12:38] <nwc10> could I just say:

[12:38] <nwc10> The rate of work on NOM is really impressive now.

[12:39] <jnthn> nwc10: sick tricks are sick :)

[12:39] <jnthn> I'm sure we'll get there eventually :)

[12:39] <nwc10> jnthn: yes. and try to bite you

[12:39] <jnthn> But I'm in no hurry.

[12:39] <jnthn> Plenty of clean optimizations to go yet :)

[12:44] <dalek> rakudo/podparser: 74bfbe4 | tadzik++ | / (3 files):

[12:44] <dalek> rakudo/podparser: Fix END block handling, we now pass S02-whitespace_and_comments/end-pod.t

[12:44] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/74bfbe456b

[12:44] <moritz_> tadzik: sounds good :-)

[12:45] <tadzik> moritz_: and passes good :)

[12:45] <nwc10> thanks all

[12:45] *** nwc10 left
[12:46] *** masak joined
[12:46] <masak> nom: role A { method foo(A $x) { say "from A!" } }; role B { method foo(B $x) { say "from B!" } }; class C does A does B {}; C.new.foo(A); C.new.foo(B)

[12:46] <p6eval> nom: OUTPUT«Method 'foo' must be resolved by class 'C' because it exists in multiple roles (B, A)␤current instr.: '_block2595' pc 34831 (src/gen/perl6-metamodel.pir:10742) (src/gen/Metamodel.pm:1031)␤»

[12:47] <masak> nom: role A { method foo(A $x) { say "from A!" } }; role B { method foo(B $x) { say "from B!" } }; class C does A does B { proto method foo($x) { * } }; C.new.foo(A); C.new.foo(B)

[12:47] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for ''. Available candidates are:␤␤current instr.: 'foo' pc 1087 ((file unknown):26427091) (/tmp/t_8OLW0AbK:1)␤»

[12:47] <masak> jnthn: that should work, right?

[12:48] <jnthn> masak: I think the proto forces those to become multi candidates.

[12:48] <jnthn> masak: Needs a patch to RoleToClassApplier, if you're up for it.

[12:48] <jnthn> masak: Or I'll get there in a bit :)

[12:49] <masak> the should become multi candidates, that's the whole idea.

[12:49] <masak> but it doesn't dispatch properly yet.

[12:49] <jnthn> masak: no no

[12:49] <jnthn> masak: They don't become multi candidates yet

[12:49] <jnthn> :)

[12:49] <masak> yes, we're in violent agreement, methinks.

[12:50] <jnthn> masak: It's not a hard patch to write, anyway :)

[12:50] <masak> I'll have a look at RoleToClassApplier, and then get back to you.

[12:50] <jnthn> masak: Oh, you'll need a .is_multi or something

[12:50] <jnthn> .multi I think we called it

[12:50] <masak> given how *nice* everything with the MOP is becoming, I might even be able to do it without supervision.

[12:50] <masak> ok, .multi

[12:50] <jnthn> masak: Oh

[12:50] <masak> I'll have a peek.

[12:50] <jnthn> You already ahve it

[12:51] <jnthn> .is_dispatcher I think

[12:51] <masak> oh

[12:51] <jnthn> masak: Read MultiMethodContainer.pm's incorporate_multi_candidates method

[12:51] <jnthn> masak: It'll make it fairly clear how to find out if a method is a dispatcher or not

[12:51] <jnthn> And how to add to its dispatch list

[12:51] <jnthn> masak: All being well you're looking at a 3 or 4 line patch to make this work, I think :)

[12:52] <masak> \o/

[12:52] <masak> I'm up to it.

[12:52] *** fimgolfin left
[12:52] <masak> s/to/for/

[12:52] <tadzik> nqp: say("foo" eq "foo" ?? 1 !! 0)

[12:52] <p6eval> nqp: OUTPUT«1␤»

[12:52] *** alim joined
[12:52] <masak> nqp: say +("foo" eq "foo")

[12:52] <p6eval> nqp: OUTPUT«Null PMC access in add_int()␤current instr.: '_block1000' pc 0 ((file unknown):1)␤»

[12:52] <jnthn> masak: I think you're up to it too :P

[12:53] <masak> jnthn: I don't know which preposition I am up it :P

[12:55] <moritz_> nqp: say ("foo" eq "foo").WHAT

[12:55] <p6eval> nqp: OUTPUT«Confused at line 1, near "say (\"foo\""␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[12:55] <moritz_> ah

[12:56] <moritz_> nqp: say(+("foo" eq "foo"))

[12:56] <p6eval> nqp: OUTPUT«1␤»

[12:56] <moritz_> nqp doesn't like listops

[12:56] <moritz_> nqp: say(+("foo" eq "Foo"))

[12:56] <p6eval> nqp: OUTPUT«0␤»

[12:56] *** xinming left
[12:57] <pmichaud> jnthn: ping

[12:57] *** drbean_ joined
[12:57] *** xinming joined
[12:58] *** REPLeffect left
[12:59] *** MayDaniel joined
[13:01] <masak> oh, right.

[13:01] <masak> still, a Null PMC access for something that's essentially a syntax error?

[13:01] <masak> it looks like it's parsing it into something, probably (say) + ("foo" eq "foo"), and then running it and failing.

[13:02] <jnthn> masak: It's doing that

[13:02] <jnthn> pmichaud: pong

[13:02] <jnthn> masak: nqp has less hand-holding than Rakudo in various places

[13:02] <pmichaud> jnthn: in nqp, how does one determine if an attribute has been declared int/num/str ?

[13:02] <pmichaud> I tried using .type, but I get a "cannot get_string()" error.

[13:03] <pmichaud> (.type on the attribute object, that is)

[13:03] <jnthn> .type =:= int # should work

[13:03] <jnthn> nom: say(int)

[13:03] <p6eval> nom: OUTPUT«No method cache and no find_method method in meta-object␤current instr.: 'say' pc 342480 (src/gen/CORE.setting.pir:89324) (src/gen/CORE.setting:2937)␤»

[13:03] *** REPLeffect joined
[13:03] <jnthn> Yeah...natives don't know how to do much in nqp :)

[13:04] <jnthn> pmichaud: You can get the name through the HOW

[13:04] <jnthn> $obj.HOW.name($obj)

[13:04] <pmichaud> yes, I got the name already.

[13:04] <jnthn> nom: say(int.HOW.name(int))

[13:04] <pmichaud> just need the type.

[13:04] <p6eval> nom: OUTPUT«int␤»

[13:04] <pmichaud> oh, you mean of the type

[13:04] <pmichaud> okay

[13:04] <jnthn> pmichaud: No, I mean, the name of...right

[13:04] <jnthn> pmichaud: But I'd use =:= int

[13:04] <pmichaud> jnthn:  trying that now

[13:04] *** Holy_Cow joined
[13:06] <pmichaud> awesome, that works.

[13:08] * masak reads '@!multi_methods_to_incorporate[+@!multi_methods_to_incorporate] := $todo;' and thinks "add a .push already!" :P

[13:08] <dalek> rakudo/nom: 1701cb2 | pmichaud++ | / (4 files):

[13:08] <dalek> rakudo/nom: Add Stringy role.  prefix:<^> enforces numeric context.  Another spectest file.

[13:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1701cb2e22

[13:08] <pmichaud> now at 4,802 spectests

[13:09] <jnthn> masak: There's a reason it's not a push

[13:09] <masak> "#perl6: getting faster every year at rebuilding Rakudo"

[13:09] <tadzik> 4,803 on podparser then :P

[13:10] <masak> jnthn: oh, good.

[13:10] <jnthn> masak: Though it's really an nqp auto-viv shortcoming

[13:10] <[Coke]> Yah, if we count perl6 by the number of rewrites (over all implementations), what are we at now, 6.4? (just for the rewrites?)

[13:10] <masak> jnthn: ah!

[13:10] <masak> [Coke]: that has to depend.

[13:11] <masak> [Coke]: there was the original perl6-on-parrot, the one before pmichaud came on.

[13:11] <jnthn> masak: Suspect we fix it at some point but it probably means moving further from from Parrot-y types and more towards 6model-y ones

[13:11] <masak> [Coke]: then there was Pugs.

[13:11] <masak> [Coke]: then there was the second original perl6, aka alpha, on PGE.

[13:11] <masak> [Coke]: then there was ng. now there's nom.

[13:11] <[Coke]> masak: do we count the first pugs as a rewrite of perl6-on-parrot? up to you.

[13:12] <pmichaud> there was a pre-alpha perl6

[13:12] <jnthn> pmichaud: Was there one that used TGE?

[13:12] <masak> [Coke]: but which ones are major versions and which ones are not (and yes, whether pugs should be part of that lineage) is very subjective.

[13:12] <pmichaud> jnthn: yes

[13:12] <jnthn> pmichaud: Whoa.

[13:12] <masak> pmichaud: oh, right.

[13:12] <[Coke]> and any big pugs rewrites? any for nie*

[13:12] <jnthn> pmichaud: How far did that one get?

[13:12] <masak> that was 2006-2007, no?

[13:12] <[Coke]> masak: Do you think I'm asking for a definitive, line in the sand answer? no. ;)

[13:13] <pmichaud> jnthn: that was the version of perl6 that existed just prior to the introduction of the original nqp and pct in 2007

[13:13] <masak> [Coke]: I think Pugs had two or three major rewrites. it stalled during a fourth.

[13:13] <pmichaud> alpha started in december 2007

[13:13] <[Coke]> so we're closer to 10 than 5. ;)

[13:13] <masak> [Coke]: I'm just outlining the richness of the answer to you :)

[13:13] <masak> there should really be a good timeline somewhere with these details on it.

[13:13] <jnthn> pmichaud: Ah, OK. TGE was long gone by the time I joined in, I think.

[13:14] <masak> maybe even *gasp* on Wikipedia!

[13:14] <pmichaud> or perl6.org

[13:14] <masak> TGE feels like a nice idea that turned out to be horrible in practice.

[13:14] <tadzik> nqp: say("foo\n".chomp)

[13:14] <p6eval> nqp: OUTPUT«Method 'chomp' not found for invocant of class 'String'␤current instr.: '_block1000' pc 36 ((file unknown):35) (/tmp/oZudsTSVSb:1)␤»

[13:14] <tadzik> hrm

[13:15] <jnthn> masak: I seem to remember some compilers lecturer mentioning that academia mostly rejected attribute grammars for compiler dev long ago.

[13:16] <jnthn> I suspect BEGIN mighta been hard if trying to treat the whole program as a tree too

[13:16] <jnthn> And nom thoroughly does away with the notion that an AST can capture everything we need to know.

[13:17] <masak> it does?

[13:17] <masak> I thought it embraced ASTs more than previously.

[13:18] <tadzik> nqp: my $a = "foo"; say("foo\n" ~~ /$a\n/);

[13:18] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " \"foo\"; sa"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[13:18] <jnthn> masak: It builds an AST *and* a bunch of other objects.

[13:18] <tadzik> nqp: my $a := "foo"; say("foo\n" ~~ /$a\n/);

[13:18] <p6eval> nqp: OUTPUT«foo␤␤»

[13:18] *** Mowah left
[13:21] <masak> I ran the spectests for nom. got a couple of failures for t/spec/S02-whitespace_and_comments/minimal-whitespace.t

[13:21] * [Coke] doesn't think wikipedia needs that timeline.

[13:22] *** mberends left
[13:22] <masak> [Coke]: no, maybe not.

[13:22] <pmichaud> masak: yes, some bug has been exposed there... needs fixing and/or fudging

[13:24] <TimToady> how am I supposed to backlog when you guys* talk so fast?        *Californian for y'all, gender neutral 

[13:24] *** birdwindupbird left
[13:24] *** birdwindupbird joined
[13:24] *** birdwindupbird left
[13:24] *** mj41 left
[13:25] <dalek> rakudo/nom: 0849b9d | pmichaud++ | t/spectest.data:

[13:25] <dalek> rakudo/nom: Some t/spectest.data note updates.

[13:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0849b9d92f

[13:25] *** Mowah joined
[13:25] <dalek> nqp: 0108338 | pmichaud++ | src/core/NQPMu.pm:

[13:25] <dalek> nqp: Fix to .__dump for native attributes -- jnthn++.

[13:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/010833803d

[13:25] *** drbean_ left
[13:25] <TimToady> and dalek talks faster'n anyone...

[13:26] <pmichaud> dalek is just repeating things we've said out-of-channel  :)

[13:28] *** drbean left
[13:29] <TimToady> sorear: re http://irclog.perlgeek.de/perl6/2011-07-07#i_4074310 I don't think the -> form of .subst is necessarily unportable, in the sense that any impl could detect whether the replacement is a unary closure and pass $/ to it; but yeah, it's not to current spec

[13:31] <arnsholt> jnthn: Attribute grammars sound a bit like unification-based grammars

[13:32] <TimToady> related to the .subst issue, I've wondered whether it'd make more sense to say that blocks only get their own $_, and $! and $/ are shared by everyone in the routine

[13:34] <TimToady> then we wouldn't have to worry about the collision of importing an outer $/ vs clobbering $/, and whether those are bindings or assignments

[13:35] <TimToady> and blocks might start up a bit faster if they don't have to worry about $! or $/ specially

[13:36] <jnthn> TimToady: I already figured out handling those lazily anyway

[13:36] <TimToady> 'course, on the flip side, that might turn some blocks into closures that might otherwise not have referred to any external lexicals

[13:36] <jnthn> (in nom)

[13:36] <TimToady> that was my next suggestion :)

[13:36] <moritz_> nom: say 1 ... 5, 6, 7

[13:36] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'ACCEPTS'. Available candidates are:␤:(Mu, Mu $topic)␤␤current instr.: 'ACCEPTS' pc 354002 (src/gen/CORE.setting.pir:94357) (src/gen/CORE.setting:227)␤»

[13:37] <moritz_> wow, (Mu, Mu) didn't fit? :-)

[13:37] <TimToady> but there's still the setting $/ issue from within .subst

[13:37] <jnthn> TimToady: Yeah, that's the really tricky one

[13:37] <jnthn> moritz_: Maybe somehow too many args passed

[13:37] <moritz_> jnthn: seems like

[13:37] <jnthn> moritz_: Oh

[13:37] <TimToady> kicking $/ out of blocks would kinda solve that

[13:38] <jnthn> moritz_: Also

[13:38] <jnthn> moritz_: That candidate is in Mu and only handles the :U case

[13:38] <jnthn> iirc

[13:38] <TimToady> and $! has similar reasoning

[13:39] <moritz_> jnthn: the problem is likely the the sequence generator tries to smart-match against all the items on the RHS, not just against the left-most

[13:39] <jnthn> TimToady: It makes the optimizer's life easier too I expect

[13:40] <TimToady> anyway, it's something I've been thinking about off and on for some time now

[13:40] <jnthn> nom: 1 ~~ (1,2,3)

[13:40] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'ACCEPTS'. Available candidates are:␤:(Mu, Mu $topic)␤␤current instr.: 'ACCEPTS' pc 354002 (src/gen/CORE.setting.pir:94357) (src/gen/CORE.setting:227)␤»

[13:40] <jnthn> moritz_: ^

[13:40] *** tokuhirom joined
[13:40] <moritz_> nom: sub s($right) { my @right := ($right,).list; my $endpoint = @right.shift; say $endpoint.perl }; s 1, 2, 3

[13:40] <p6eval> nom: OUTPUT«Too many positional parameters passed; got 3 but expected 1␤current instr.: 's' pc 452 ((file unknown):26852858) (/tmp/tHlGbQTwYO:1)␤»

[13:40] <moritz_> nom: sub s($right) { my @right := ($right,).list; my $endpoint = @right.shift; say $endpoint.perl }; s (1, 2, 3)

[13:40] <p6eval> nom: OUTPUT«(1, 2, 3)␤»

[13:41] <moritz_> that's how the problem is triggered

[13:41] <moritz_> pmichaud: ^^

[13:41] <TimToady> sorear: I'd also like to get your input on the idea of kicking $! and $/ upstairs into the routine's scope

[13:41] *** wamba left
[13:41] <moritz_> pmichaud: that's what makes t/spec/S03-sequence/basic.t bail out

[13:42] <TimToady> from a programming perspective, it means that if you want to temporize $! or $/ to a block, you have to use 'temp'

[13:42] <TimToady> or maybe just declare 'my $!' or 'my $/'

[13:42] <TimToady> that seems like a good tradeoff for simplifying blocks

[13:43] <TimToady> the other possible downside is that a thing like .subst can't just assume CALLER::<$/> will be there

[13:44] <TimToady> it would have to treat it like an ordinary dynvar

[13:44] <TimToady> hmm, that could be wrong too

[13:45] *** whiteknight left
[13:45] <TimToady> it needs to find the caller's lexically visible $/

[13:48] <TimToady> well, maybe CALLER::<$/> does the right thing, and starts the lexical search from the caller

[13:48] *** acrussell joined
[13:48] <dalek> rakudo/podparser: 12097c5 | tadzik++ | t/pod/04-code.t:

[13:48] <dalek> rakudo/podparser: Handle code blocks properly, import 04-code.t

[13:48] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/12097c56aa

[13:49] <tadzik> don't pull!

[13:49] <dalek> rakudo/podparser: 571755c | tadzik++ | / (3 files):

[13:49] <dalek> rakudo/podparser: Handle code blocks properly, import 04-code.t

[13:49] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/571755c34f

[13:49] <tadzik> ok, no one saw this :)

[13:50] <TimToady> saw what?

[13:50] <tadzik> my secret Jedi powers, specifically "Force Push"

[13:50] <TimToady> I always ignore dalek, except when I don't.

[13:50] <tadzik> I can understand that

[13:50] *** wamba joined
[13:51] <pmichaud> moritz_: ... was written before we had Positional available, so it needs an update.  I'll do that here shortly.

[13:52] <TimToady> pmichaud: you may have an opinion or two about $! and $/ as well

[13:52] <masak> happy discovery: in a signature, '@a where 2' means 'an array @a with length 2'. spread the word. :)

[13:52] *** Gothmog_ left
[13:52] <TimToady> well, sure, it's just a smartmatch

[13:52] <masak> yes, I know how it works :)

[13:52] <pmichaud> TimToady: I'm letting $! and $/ stew in my brane for a bit.

[13:52] <masak> I'm just claiming the patent rights...

[13:53] <pmichaud> my gut really likes the idea of a per-routine $! and $/ though.

[13:53] <TimToady> and I'm just claiming it was obvious

[13:53] <jnthn> Quick! Somebody find prior art!

[13:53] <jnthn> :)

[13:54] * moritz_ lazily points towards S0d

[13:55] * masak goes looking, interested

[13:55] *** Gothmog_ joined
[13:55] <pmichaud> I don't think the CALLER::<$/> in .subst is likely to be a blocker... we already need to sort out exactly how to handle $/ in that situation as well.

[13:56] <pmichaud> as far as looking at a caller's entire lexical scope -- I'm already doing that for lexical returns.

[13:56] <pmichaud> so there's a bit of prior art there.

[13:57] <masak> moritz_: neither S06 nor S12 mention doing @array where $some_int

[13:57] <masak> I don't think there's prior art in the application cheese, either.

[13:57] <moritz_> masak: they mention <some_variable> where <literal>, iirc. That's enough for me :-)

[13:57] * masak snorts at the lack of respect for this new discovery :)

[13:58] <moritz_> masak: I do apologize :-)

[13:58] <masak> I'm not saying it's original, or very creative. I'm saying it's never been done before.

[13:58] <pmichaud> I respect this new discovery enough to use it blatantly and liberally without paying any patent license royalties on it.  :)

[13:58] <masak> dang :P

[14:00] <TimToady> rakudo: multi foo (2) { say "Two-ness!" }; foo(<bacon bits>)

[14:00] <p6eval> rakudo 72d158: OUTPUT«No applicable candidates found to dispatch to for 'foo'. Available candidates are:␤:(Int  where (2))␤␤  in main program body at line 22:/tmp/fdaLYKvcQc␤»

[14:00] <TimToady> aww

[14:01] <TimToady> rakudo: multi foo ($ where 2) { say "Two-ness!" }; foo(<bacon bits>)

[14:01] <p6eval> rakudo 72d158: OUTPUT«Two-ness!␤»

[14:01] * masak files his first patent infringement complaint :)

[14:02] <tadzik> . o O ( masak submits patentobug )

[14:02] <TimToady> rakudo: multi foo ($ where 1+1) { say "Two-ness!" }; foo(<bacon bits>)

[14:02] <jlaire> masak: are you sure your claims where general enough to cover '$' lhs

[14:02] <p6eval> rakudo 72d158: OUTPUT«Two-ness!␤»

[14:02] <pmichaud> 13:41 <moritz_> that's how the problem is triggered

[14:02] * TimToady works around the patent issue

[14:02] <pmichaud> I don't quite see the relationship there.

[14:03] <moritz_> pmichaud: that's how &SEQUENCE extracts the $endpoint

[14:03] <moritz_> pmichaud: which ends up being the whole list, not just the first item

[14:03] <masak> jlaire: no I am not, but that's what the legal system is there for.

[14:04] <pmichaud> 13:40 <moritz_> nom: sub s($right) { my @right := ($right,).list; my $endpoint = @right.shift; say $endpoint.perl }; s 1, 2, 3

[14:04] <pmichaud> oh, I see.

[14:04] <pmichaud> okay.

[14:04] *** wamba left
[14:04] <jnthn> TimToady: Note that multi foo(2) { ... } is not multi foo($ where 2) { ... }

[14:05] <jlaire> although, even a uselessly narrow patent can be used to scare people who don't read what it actually covers

[14:05] <jnthn> TimToady: It's like multi foo(Int $ where 2) { }

[14:05] <TimToady> yes, I giffered that out

[14:05] <moritz_> from S03/Smart matching/: Any       Callable:($)  item sub truth          X($_)

[14:06] <jnthn> TimToady: Turns out it's gotta be like that, otherwise if you write a fib(0), fib(1) and fib(Int $n) set of candidates, things wouldn't work out so well :)

[14:06] <moritz_> X($_) or ?X($_) ?

[14:07] <moritz_> nom: say 3 ~~ -> $x { say $x; $x }

[14:07] <p6eval> nom: OUTPUT«3␤3␤»

[14:07] *** Holy_Cow left
[14:07] <pmichaud> rakudo:  say 3 ~~ -> $x { say $x; $x }

[14:07] <p6eval> rakudo 72d158: OUTPUT«3␤Bool::True␤»

[14:08] <dalek> rakudo/podparser: 40859e6 | tadzik++ | / (2 files):

[14:08] <dalek> rakudo/podparser: Fix comment block parsing, add tests

[14:08] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/40859e69aa

[14:08] <pmichaud> I'm inclined towards nom's interpretation, fwiw.

[14:08] * moritz_ too

[14:09] <TimToady> eh? that doesn't make sense

[14:09] <TimToady> nom: say 0 ~~ -> $x { say $x; $x }

[14:09] <p6eval> nom: OUTPUT«0␤0␤»

[14:09] <TimToady> that would be false?

[14:09] <moritz_> sure

[14:09] <TimToady> hmm, I guess it would

[14:09] <TimToady> nm

[14:09] <jnthn> :)

[14:10] <TimToady> someone musta snuck some decaf into the caf this morning

[14:10] <jnthn> .oO( strangely consistent with if foo() -> $x { ... } ? :) )

[14:10] * moritz_ discovers that S03-smartmatch/any-sub.t doesn't test what the author probably thought it would test

[14:10] <TimToady> but, but, we trigger that behavior on the return type of boolean

[14:10] <masak> I'm reading old p6l archives. did you know that at some point back in 2005, 'self.foo()' was spelled './foo()'? :)

[14:11] <TimToady> oh, it's the return type of -> duh

[14:11] <jnthn> masak: yes

[14:11] *** wtw left
[14:11] <jnthn> masak: iirc htat's why we ended up being able to put args on $.foo(...)

[14:11] * moritz_ never witnessed that syntax

[14:11] <TimToady> pay no attention to the man behind the curtain

[14:11] <jlaire> masak: TimToady called it 'shellishly' cute

[14:11] <jlaire> iirc

[14:11] <masak> :P

[14:12] <pmichaud> many of us thought the initial 's' should be dropped from 'shellishly'

[14:12] *** spq1 left
[14:12] <jlaire> hehe

[14:12] <jnthn> lol

[14:12] <masak> that was also the first debate where I piped up, expressing my language design opinion.

[14:12] <masak> granted, it was just au++'s opinion, copied. but still...

[14:12] <jnthn> I seem to remember somebody saying, "It's cute. Can't we keep it?" :)

[14:13] <TimToady> I never remember who stood up for which side, which is probably a mercy...

[14:13] <jlaire> 2005, uh... I must've been following Perl 6 for quite a while

[14:14] * jnthn was only looking on from a distance in 2005 :)

[14:14] <jnthn> I understood about a third of what I read on p6l

[14:14] * TimToady too

[14:14] <jnthn> .oO( Some things never change... :) )

[14:15] * TimToady wonders if there's some way to turn 'decont' into 'decant'...

[14:16] *** kaare_ joined
[14:16] <TimToady> and how a cantainer differs from a container

[14:16] <masak> well, I argued for .foo() always meaning $_.foo(). because an intermediate proposal wanted to mix up .foo() into meaning either self.foo() or $_.foo(), depending.

[14:16] <jnthn> oh no, not the "where does the invocant go" threads!

[14:16] <masak> TimToady: a 'cantainer' is what you eat from in a 'cantine' :)

[14:17] <TimToady> if you remember that, I'll bet you hold grudges too :P

[14:17] <[Coke]> canonttainer.

[14:17] <[Coke]> *n

[14:17] <pmichaud> I figure that a cantainer is just .^methods, since that determines what an object "can do"  :-)

[14:17] <jnthn> TimToady: I forget all the details of those discussions. Or maybe suppressed the memories :)

[14:19] <pmichaud> jnthn: the lack of a working REPL is getting a little painful.  :/

[14:20] <TimToady> .oO(is jnthn++ suppressing the memories of a working REPL?)

[14:20] *** wamba joined
[14:20] *** spq1 joined
[14:21] <jnthn> pmichaud: I spent a little bit on that this morning while doing the various other fixes.

[14:21] <jnthn> pmichaud: Didn't get to the bottom of it, then had to look at $dayjob. I'll return to it later today.

[14:21] <pmichaud> okay, just wanted to bump the priority slightly.  :)

[14:21] <masak> oh! it was Juerd++ who suggested the ./ syntax.

[14:21] <jnthn> pmichaud: Don't worry, it annoyed me no end this morning too :)

[14:22] <pmichaud> "later today" is fine.  "in the next week" is fine, too, just know that it hurts a little.  :)

[14:22] <TimToady> we want it to annoy you end :)

[14:22] <jnthn> :P

[14:23] <jnthn> masak: If only I'd not been too shy to troll the thread with "as I Windows user I demand .\foo works too!" :)

[14:23] <jnthn> s/I/a/ 

[14:23] <tadzik> any way to convert a String to an Int in nqp?

[14:23] <moritz_> jnthn shy? what did I miss?

[14:23] <pmichaud> tadzik:  +

[14:23] <moritz_> nqp: say( +"123")

[14:23] <p6eval> nqp: OUTPUT«123␤»

[14:23] <tadzik> oh, cool. Thanks

[14:23] *** JimmyZ_ joined
[14:23] <masak> jnthn: :)

[14:23] <tadzik> that'd be a parrot int, or a SixModelObject?

[14:23] <jnthn> moritz_: I was...quite quiet back then :)

[14:23] <moritz_> ... execpt that it's a num, not an int

[14:23] <TimToady> I believe jnthn++ is mistaking 'shy' for 'civil'

[14:24] <masak> I wonder how soon after 2005 we got the $.foo() syntax...

[14:24] <jnthn> :)

[14:24] <pmichaud> tadzik: it's a num.

[14:24] <jnthn> tadzik: It'll be a Parrot object

[14:24] <jnthn> tadzik: If you're in nqp

[14:24] <jnthn> tadzik: Didn't manage to eradicate those yet.

[14:24] <jnthn> So, Float PMC.

[14:25] <tadzik> ok, so I need to add it to a symboltable anyway

[14:25] <dalek> roast: a71a764 | moritz++ | S03-smartmatch/any-sub.t:

[14:25] <dalek> roast: change S03-smartmatch/any-sub.t to test what it is supposed to test, IMHO

[14:25] <dalek> roast: review: https://github.com/perl6/roast/commit/a71a764b99

[14:25] <jnthn> The circularity sawing there is gonna hurt a bit when we try to reall resolve it.

[14:25] <jnthn> *really

[14:25] <pmichaud> it's a num

[14:25] <jnthn> pmichaud: N register?

[14:25] <pmichaud> it doesn't become a Float until you do something PMC-ish with it.

[14:25] <pmichaud> Yes, N register.

[14:25] <jnthn> pmichaud: Oh. Call doesn't imply boxing in NQP?

[14:25] <jnthn> OK 

[14:25] <pmichaud> there's no Call.

[14:25] <jnthn> pmichaud: say

[14:25] <dalek> rakudo/nom: 3aa3352 | moritz++ | t/spectest.data:

[14:25] <dalek> rakudo/nom: two more passing test files

[14:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3aa3352c10

[14:26] <pmichaud> okay, the say() implies a boxing, yes.

[14:26] <pmichaud> but not the prefix +

[14:26] <jnthn> ok

[14:26] <jnthn> Makes sense.

[14:26] <pmichaud>     token prefix:sym<+>   { <sym>  <O('%symbolic_unary, :pirop<set N*>')> }

[14:26] * jnthn suspects that the NQP circularity saw involves two settings...

[14:27] <pmichaud> I actually think it's just going to Work Out.

[14:27] <TimToady> A City of Two Tales

[14:27] <pmichaud> the circularity saw may end up being a singularity that collapses on itself.

[14:27] <jnthn> pmichaud: We rely a LOT on Parrot PMCs to do our circularity sawing at the moment.

[14:28] <jnthn> pmichaud: I couldn't do that in nqpclr so had to solve the various circularities there in other ways

[14:28] *** JimmyZ left
[14:28] <masak> ah, in Feb 2006 we got $.foo()

[14:28] *** JimmyZ_ is now known as JimmyZ

[14:28] <jnthn> Apart from I didn't do compile time meta-objects in nqpclr so it was less hard.

[14:28] <pmichaud> yes, I know, but I think we'll be able to ultimately eliminate those dependencies, as opposed to having to emulate them.

[14:28] <masak> that's about half a year later.

[14:28] <jnthn> pmichaud: Sure, I'm just saying it won't be entirely trivial :)

[14:29] <TimToady> the problem with using parrot as a circularity saw is that it collapses to a rather massive singularity...

[14:29] <jnthn> TimToady: Yeah, I don't see doing so as desirable really. It's just where we are at the moment.

[14:30] <pmichaud> TimToady: right, which is why I think our answer will end up avoiding the Parrot-ness altogether.

[14:30] <pmichaud> that didn't come out right

[14:31] <TimToady> someone should write a VM called 'turtles'

[14:31] <pmichaud> our answer won't involve Parrot PMCs for resolving the circularities.  Indeed, I think it'll just end up being natural/native to 6model

[14:31] <pmichaud> I think that part of the reason we have to involved Parrot PMCs now is because of PCT/PAST.  Once we've converted that to nqp, a lot of the boxing issues go away.

[14:32] <TimToady> it's always nice if you can get the circularity to hide itself behind a rarely visited abstraction

[14:32] <jnthn> pmichaud: I dunno if you read it, but https://github.com/jnthn/6model/blob/master/common/NQP/NQPSetting.pm

[14:32] <jnthn> pmichaud: That is the closest idea we have yet of what 6model all the way down looks like.

[14:33] <pmichaud> ouch

[14:33] <jnthn> The trick is attributeless objects.

[14:33] <pmichaud> those nqp:: opcodes hurt my head.

[14:33] *** wolfram joined
[14:33] <pmichaud> is that pseudocode or real code there?

[14:33] <jnthn> pmichaud: It's real running code on the clr

[14:33] <jnthn> pmichaud: It's also 6+ months old.

[14:34] <pmichaud> okay, so those aren't the nqp:: codes we recently started

[14:34] <pmichaud> okay

[14:34] <jnthn> pmichaud: e.g. it pre-dates having nqp:: in any "official" sense by months.

[14:34] <pmichaud> I'll look at it more closely

[14:34] <jnthn> pmichaud: The "is repr" bits are the key

[14:34] <pmichaud> right

[14:34] <jnthn> pmichaud: Looking over it, I can see a bunch of areas where it may well chance today too

[14:34] <pmichaud> right

[14:35] <jnthn> s/chance/want to change/

[14:35] <jnthn> as in, things I'd do differently with hindsight

[14:35] <pmichaud> anyway, I need to get back to more concrete tasks for now :)

[14:35] <jnthn> Me too :)

[14:35] <jnthn> EPERL6TOOINTERESTING

[14:35] * jnthn tries to crank out at least a little more $dayjob stuff :)

[14:35] <TimToady> SIGWORK

[14:36] *** mj41 joined
[14:36] *** wamba left
[14:37] <wolfram> An urge to have hashes that remember element creation order just possesses me again in perl 5. Will those be easier to have in perl 6?

[14:37] *** am0c left
[14:38] <TimToady> everything will be easier eventually...

[14:38] <wolfram> Sure

[14:38] <masak> wolfram: I expect you'll be able to subclass Hash eventually.

[14:38] <masak> wolfram: with a custome .STORE method, you could do what you want.

[14:39] <moritz_> but notice that getting such a thing right is rather tricky

[14:39] <moritz_> where by "right" I mean "consistent and fast under all possible operations"

[14:39] <masak> sure.

[14:39] <colomon> any hints on how to call a custom in rule by name in a regex in one of the current p6 implementations?

[14:40] *** Trashlord left
[14:40] <pmichaud> "custom in rule" ?

[14:40] <moritz_> s/in // probably

[14:40] <colomon> moritz_++

[14:40] *** moritz_ is now known as moritz

[14:40] <pmichaud> need more context.

[14:41] <pmichaud> in Rakudo, it's just   <customrule>

[14:41] <wolfram> masak: that sounds like there are still a number of NYI on the way there?

[14:41] <colomon> say $line if $line ~~ /<dec_number>/;

[14:41] <colomon> gives me Method 'dec_number' not found for invocant of class 'Cursor' in rakudo

[14:41] <pmichaud> I suspect subclassing Hash in nom is possible today.

[14:41] *** Trashlord joined
[14:41] <flussence> anyone want to port Tie::IxHash?

[14:42] <moritz> you need GrammarContainingClass.parse($line, :rule<decnumber>)  for now

[14:42] <phenny> moritz: 06 Jul 02:27Z <jnthn> tell moritz in BackTrace you put subname and subtype into the BackTraceLine but not the actual Sub object itself, which would seem more general. Any reason why not?

[14:42] <colomon> that's after "our token dec_number"

[14:42] <pmichaud> colomon: aha

[14:42] <pmichaud> that's an unresolved spec issue

[14:42] <TimToady> nom: class MyHash is Hash {}; my %foo is MyHash; %foo<a b c> = 1,2,3; say %foo<b>

[14:42] <p6eval> nom: OUTPUT«2␤»

[14:42] <TimToady> \o/

[14:42] <pmichaud> say %foo.WHAT

[14:42] <moritz> currently <&dec_number> should work, but not capture

[14:42] <colomon> \o/

[14:42] <pmichaud> it's still a Hash I bet.

[14:42] *** mj41 left
[14:42] <TimToady> nom: class MyHash is Hash {}; my %foo is MyHash; %foo<a b c> = 1,2,3; say %foo.WHAT

[14:42] <p6eval> nom: OUTPUT«Hash()␤»

[14:42] <pmichaud> colomon: you need to do it with a lexical.

[14:43] <TimToady>  /o\

[14:43] <pmichaud> nom: class MyHash is Hash {};  my $foo = MyHash.new;  $foo<a b c> = 1,2,3;  say %foo.WHAT;  say %foo<b>

[14:43] <p6eval> nom: OUTPUT«Symbol '%foo' not predeclared in <anonymous> (/tmp/hnbZEj4EK6:1)␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[14:44] <pmichaud> nom: class MyHash is Hash {};  my $foo = MyHash.new;  $foo<a b c> = 1,2,3;  say $foo.WHAT;  say $foo<b>

[14:44] <p6eval> nom: OUTPUT«MyHash()␤2␤»

[14:44] <pmichaud> \o/

[14:44] <masak> \o/

[14:44] <masak> wolfram: there you go. it's possible, but only in the future :)

[14:44] <TimToady> nom: class MyHash is Hash {}; my %foo := MyHash.new; %foo<a b c> = 1,2,3; say %foo.WHAT

[14:44] <p6eval> nom: OUTPUT«MyHash()␤»

[14:44] <TimToady> nom: class MyHash is Hash {}; my %foo := MyHash.new; %foo<a b c> = 1,2,3; say %foo<b>

[14:44] <p6eval> nom: OUTPUT«2␤»

[14:45] <masak> does nom do tailored .STORE on Hash subclasses, too?

[14:45] <pmichaud> if you define a STORE, it uses it.

[14:45] <wolfram> masak: o.k. but some of it works already. Thanks all for the demo!

[14:45] <moritz> nom: class MyHash is Hash { method STORE(|$) { say "in store" } }; my %h := MyHash.new; %h<foo> = 'bar'

[14:45] <p6eval> nom:  ( no output )

[14:45] <masak> nom: class MyHash is Hash { method STORE { say "OH HAI" } }; my $foo = MyHash.new; $foo<a b c> = 1, 2, 3; say "alive"

[14:45] <p6eval> nom: OUTPUT«alive␤»

[14:45] <masak> apparently not.

[14:45] <pmichaud> you're not using MyHash's STORE there, though.

[14:46] <masak> ah.

[14:46] <pmichaud> STORE is for storing the entire hash, not a single element.

[14:46] <masak> rightright.

[14:46] <pmichaud> you probably need to overload at_key

[14:46] <masak> ah, yes.

[14:46] <moritz> nom: class MyHash is Hash { method at_key(|$) { say "in store" } }; my %h := MyHash.new; %h<foo> = 'bar'

[14:46] *** alim left
[14:46] <p6eval> nom: OUTPUT«in store␤Cannot assign to a non-container␤current instr.: '_block1002' pc 128 ((file unknown):89) (/tmp/eIPosor0C1:1)␤»

[14:46] *** wamba joined
[14:46] *** alim joined
[14:46] <tadzik> masak: how about some S26 doubts?

[14:46] <wolfram> IRC might not be for me. You can type faster than i can read... 

[14:47] <tadzik> moritz: you're invited too :)

[14:48] <tadzik> basically, I'm wondering whether the =foo in abbreviated blocks and =for foo in paragraph blocks should be considered an opening delimiters, and thus, whether they should allow the implicit code blocks inside

[14:48] <wolfram> One of the few cases where I whish I learned to type with more that 2 fingers ;-)

[14:48] *** birdwindupbird joined
[14:48] <moritz> wolfram: you can still learn it

[14:49] <tadzik> because if they do, "=item foo" makes foo a code block, which is LTA

[14:49] <TimToady> and I didn't learn to skim until I started reading Usenet...

[14:49] <pmichaud> TimToady: How long ago was that?  ;-)

[14:49] <wolfram> moritz: yes, but for other things (like coding) it is no problem because I still spend far more time thinking than typing

[14:49] * pmichaud remembers using 'rn' in 1988.

[14:49] <TimToady> back in the Fourth age of Middle Earth

[14:50] <TimToady> *Age

[14:51] <moritz> wolfram: it makes a huge difference. Believe me.

[14:51] <TimToady> the main thing is you can type in the dark :)

[14:51] * pmichaud has a new backlit keyboard.  :)

[14:52] <colomon> rakudo: "this is a test".subst(m/ \s. /, -> $m { say $m }).say

[14:52] <p6eval> rakudo 72d158: OUTPUT«Method 'match' not found for invocant of class ''␤  in main program body at line 22:/tmp/W4GyPHTRPA␤»

[14:52] <colomon> rakudo: "this is a test".subst(m/ \s. /, -> $m { say ~$m }).say

[14:52] <p6eval> rakudo 72d158: OUTPUT«Method 'match' not found for invocant of class ''␤  in main program body at line 22:/tmp/kvVGgQuzQh␤»

[14:52] <dalek> rakudo/nom: c12b7cc | pmichaud++ | src/core/List.pm:

[14:52] <dalek> rakudo/nom: Fix test for $!items in List.munch().

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c12b7cc101

[14:52] <dalek> rakudo/nom: 5fac548 | pmichaud++ | src/core/operators.pm:

[14:52] <dalek> rakudo/nom: Improve list handling in sequence generator.

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5fac548c1e

[14:52] <pmichaud> moritz: 5fac548 gets us closer to passing S03-sequence/basic.t ... now we're blocked on junctions (the one() Junction)

[14:52] <TimToady> m// returns a Match, not a Regex

[14:53] <TimToady> try rx// instead

[14:53] <jnthn> ah, junctions :)

[14:53] <masak> tadzik: sounds like one of these "what does your heart tell you?" issues

[14:53] <pmichaud> jnthn: is the junction dispatcher available/working yet?

[14:53] <colomon> TimToady++

[14:53] <pmichaud> I might stub in a Junction implementation

[14:53] <tadzik> masak: I'm based, for I have tests to pass :P

[14:53] <tadzik> s/based/biased/

[14:54] <TimToady> colomon: the error message is admittedly LTA

[14:54] <tadzik> but I'll still go with my heart

[14:54] <colomon> TimToady: I wasn't even getting an error message in my code, that was my attempt to golf my issue.

[14:55] <TimToady> that will probably be a recurring trap for recovering P5 programmers

[14:55] <TimToady> so .subst could have a multi that recognizes the situation and says something meaningful

[14:56] <TimToady> or just dwims it into .from and .to

[14:56] <TimToady> but that wouldn't work with :g

[14:57] <TimToady> well, it could be forced to work by deriving a new cursor from the .to, I suppose

[14:57] <masak> tadzik: well, you can't go wrong, then.

[14:58] <jnthn> pmichaud: Junctions are currently NYI

[14:58] <TimToady> also assuming the Match can get back to the original Regex for rematching purposes...

[14:58] <jnthn> pmichaud: Like, at all

[14:58] <pmichaud> jnthn: okay.

[14:58] <pmichaud> I'll stub in a Junction class

[14:58] <jnthn> pmichaud: I mean, there are some hookers left over from the previous implementation

[14:58] <pmichaud> even if it doesn't dispatch properly yet, we can start doing stuff with it.

[14:58] <jnthn> pmichaud: But not re-wired to nom things

[14:58] *** wolfram left
[14:58] <jnthn> pmichaud: So will need to revisit those.

[14:59] <pmichaud> will it ultimately need to be in BOOTSTRAP.pm?

[14:59] <jnthn> pmichaud: I dunno.

[14:59] <pmichaud> (well, not ultimately, but intermediately)

[14:59] <pmichaud> I'll leave it out for now.

[14:59] <jnthn> pmichaud: oh

[14:59] <jnthn> pmichaud: It needs registering with types.c

[14:59] <pmichaud> I'll just create the basic class for now, we can integrate it with other stuff as we get to it.

[14:59] <tadzik> masak: well, I can actualy. Parser migrated to nom gave different test results, due to around-test environment

[14:59] <jnthn> pmichaud: And we can only do that by having it on BOOTSTRAP.pm for now

[15:00] <jnthn> pmichaud: Sure, do whatever bits you wish. I'll fill in the gaps ;)

[15:00] <jnthn> *:)

[15:00] <masak> tadzik: interesting.

[15:00] <masak> tadzik: were the differences significant in any way? I mean, did the tests just break or were they arguably wrong in the first place?

[15:00] <tadzik> still, I decided to go with my heart _and_ make the tests pass :)

[15:01] <tadzik> now when I look at it, the tests are wrong

[15:01] *** birdwindupbird left
[15:01] *** birdwindupbird joined
[15:02] <tadzik> but that doesn't make the results (primary) wrong

[15:03] <masak> tadzik++ # heart _and_ tests

[15:05] <TimToady> perl6: say ([1,2] Z [*,*]).perl

[15:05] <tadzik> that could be a nice life meaphor, or a motto

[15:05] <p6eval> niecza v7-14-gbad54f1: OUTPUT«([1, 2], [Whatever.new(...), Whatever.new(...)]).list␤»

[15:05] <p6eval> ..rakudo 72d158: OUTPUT«(1, Any, 2, Any)␤»

[15:05] <p6eval> ..pugs: OUTPUT«((1, Inf), (2, Inf))␤»

[15:06] <TimToady> I believe niecza++ is correct here

[15:06] <TimToady> [] should not flatten in a list

[15:06] <TimToady> perl6: say (1,2 Z *,*).perl

[15:07] <p6eval> rakudo 72d158: OUTPUT«(1, Any, 2, Any)␤»

[15:07] <p6eval> ..niecza v7-14-gbad54f1: OUTPUT«(1, Whatever.new(...), 2, Whatever.new(...)).list␤»

[15:07] <p6eval> ..pugs: OUTPUT«((1, Inf), (2, Inf))␤»

[15:07] <pmichaud> nom: say ([1,2] Z [*,*]).perl

[15:07] <p6eval> nom: OUTPUT«((1, Whatever<70133968>), (2, Whatever<70133768>)).list␤»

[15:07] <TimToady> I think that's wrong

[15:07] <pmichaud> Z doesn't produce parcels?

[15:08] <pmichaud> oh, it shouldn't be flattening.

[15:08] <TimToady> Z is a list infix, so takes two lists, but [] is a single item to Z

[15:08] <pmichaud> right

[15:08] <pmichaud> I agree, that's wrong.

[15:08] *** daniel-s joined
[15:08] <pmichaud> nom: say (([1,2],) Z ([*,*],)).perl

[15:08] <p6eval> nom: OUTPUT«(([1, 2], [Whatever<80656192>, Whatever<80655992>]),).list␤»

[15:08] <[Coke]> bar used rn in... 89? 90?

[15:09] <[Coke]> s/bar/Coke//

[15:09] <tadzik> nom: say Mu.defined

[15:09] <p6eval> nom: OUTPUT«Bool::False␤»

[15:09] <pmichaud> nom isn't quite sure how to cast its arguments in LoL context yet.

[15:09] <tadzik> nom: say Mu.new.defined

[15:09] <p6eval> nom: OUTPUT«Bool::True␤»

[15:09] <tadzik> eek?

[15:10] <tadzik> is that correct?

[15:10] <TimToady> well, why not?

[15:10] <tadzik> hmm, so it's only undefined as a type object?

[15:10] <tadzik> nom: say Int.defined

[15:10] <p6eval> nom: OUTPUT«Bool::False␤»

[15:10] <tadzik> hmm

[15:11] *** JimmyZ_ joined
[15:11] <TimToady> nom: say Int.new.defined

[15:11] <p6eval> nom: OUTPUT«Bool::True␤»

[15:11] <tadzik> so type objects are undefined

[15:11] <TimToady> yup

[15:11] <tadzik> okay, I get it

[15:12] <pmichaud> jnthn: is Mu.new/bless/build "working" yet?

[15:12] <tadzik> I think it is. My Pod classes in the setting have their default .news and initialize attributes properly

[15:12] <TimToady> my $ocrates = Man.new;

[15:12] <tadzik> even those inherited

[15:13] *** JimmyZ left
[15:13] <TimToady> "undefined" in P6 really means more like "uninstantiated"

[15:13] <sorear> good * #perl6

[15:14] *** JimmyZ joined
[15:14] <sorear> yikes a lot of backlog.

[15:14] <masak> sorry...

[15:14] <moritz> rakudo: say (1...()).WHAT

[15:14] <masak> g'* sorear

[15:14] <p6eval> rakudo 72d158: OUTPUT«Failure()␤»

[15:15] *** JimmyZ_ left
[15:16] <moritz> nom: say (1...()).WHAT

[15:16] <p6eval> nom: OUTPUT«Parcel()␤»

[15:16] <pmichaud> old version of Nom.

[15:16] <moritz> nom: my $x := 1...(); say $x.WHAT

[15:16] <p6eval> nom: OUTPUT«Parcel()␤»

[15:17] <pmichaud> nom needs rebuild

[15:17] <moritz> nom: say ((1...*) Z ('a' ... 'z')).much(5).perl

[15:17] <p6eval> nom: OUTPUT«Method 'much' not found for invocant of class 'List'␤current instr.: '_block1002' pc 136 ((file unknown):42225793) (/tmp/nFK0VM17wp:1)␤»

[15:17] <pmichaud> pmichaud@kiwi:~/nom$ ./perl6

[15:17] <pmichaud> > my $x := 1...();  say $x.WHAT

[15:17] <pmichaud> List()

[15:17] <moritz> nom: say ((1...*) Z ('a' ... 'z')).munch(5).perl

[15:17] <p6eval> nom: OUTPUT«elements() not implemented in class 'Mu'␤current instr.: 'munch' pc 378230 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:2228)␤»

[15:17] <pmichaud> moritz: nom needs rebuild

[15:17] <moritz> evalbot rebuild nom

[15:17] <p6eval> OK (started asyncronously)

[15:17] <moritz> pmichaud: yes, I understood :-)

[15:17] <pmichaud> okay, just checking.

[15:18] <jnthn> pmichaud: (new/bluess/BUILD) more working than master :)

[15:18] <jnthn> pmichaud: It even gets defaults right as of this morning.

[15:18] <pmichaud> jnthn: http://gist.github.com/1069743   # what am I missing?

[15:19] <jnthn> pmichaud: That nom follows the spec, and master didn't.

[15:19] <jnthn> pmichaud: Only public attrs are allowed to be initialized from the default constructor in current spec.

[15:19] <pmichaud> ah, that's what I'm missing.

[15:20] <jnthn> (OK, I think master's way of doing it was what led to the spec coming to say that only publics get init'd)

[15:20] <jnthn> pmichaud: Solution is easy

[15:20] <pmichaud> so, to initialize a private attribute I do...?

[15:20] <jnthn> submethod BUILD(:$!type) { }

[15:20] <pmichaud> \o/

[15:20] <jnthn> Should work.

[15:21] <masak> it was after a discussion on p6l about breaking encapsulation and data hiding.

[15:21] <masak> the one where Damian had a strong opinion.

[15:21] <jnthn> ah :)

[15:21] * TimToady guesses that 'only submethod BUILD($!type) should work by current spec on named-to-positional binding

[15:22] <jnthn> TimToady: ew.

[15:22] <jnthn> TimToady: Maybe.

[15:22] <TimToady> and not work without the only

[15:22] <jnthn> TimToady: I wasn't sure to what degree the new spec applied to methods.

[15:22] <jnthn> TimToady: I'd read "only subs" into it.

[15:22] <jnthn> But maybe shouldn't have.

[15:23] <TimToady> the intent is that it apply to methods too

[15:23] <TimToady> certainly BUILD is on the hot path

[15:24] <sorear> jnthn: why shouldn't @a = ... be allowed for rw arrays?  It's just like @a.STORE(...)

[15:24] <TimToady> and doesn't need to be ditzing around with checking positionals for named if it doesn't need to

[15:24] <sorear> jnthn: *ro arrays

[15:24] <TimToady> and in any case, submethods are really more like subs when it comes to invoking them

[15:24] <jnthn> TimToady: Not really

[15:25] <jnthn> TimToady: It's still a dynamic dispatch

[15:25] <jnthn> Whereas subs are statically linked.

[15:25] <jnthn> sorear: I didn't mean to argue that it shoudln't be allowed

[15:25] <jnthn> sorear: I was more arguing that if we are going to catch such things, we do it statically

[15:25] <jnthn> Rather than burdening runtime with it.

[15:26] <TimToady> submethods could just be subs, I think, if we disallowed the 'nextsame' nonsense, and hardwired the default BUILD into BUILDALL

[15:26] <dalek> rakudo/podparser: 48ed49c | tadzik++ | src/Perl6/SymbolTable.pm:

[15:26] <dalek> rakudo/podparser: [SymbolTable] Ignore undefined parameters in cache key, saves a lot of "Use of uninitialized value in string context" when passing :name(Mu)

[15:26] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/48ed49c6fb

[15:26] <dalek> rakudo/podparser: 3a828b7 | tadzik++ | / (4 files):

[15:26] <dalek> rakudo/podparser: Parse lists properly, makes 06-lists.t

[15:26] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/3a828b787c

[15:26] <dalek> rakudo/podparser: 0fda6ab | tadzik++ | t/pod/04-code.t:

[15:26] <dalek> rakudo/podparser: Follow the decision about disallowing implicit code blocks in abbreviated and paragraph blocks in 04-code.t

[15:26] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/0fda6abb49

[15:27] <TimToady> might makes sense from a performance perspective...

[15:27] <tadzik> jnthn: feel free to disagree with 48ed49c6fb, I'm not sure about this one

[15:27] <jnthn> TimToady: fwiw, nom already makes a BUILDPLAN at class composition time, in which it figures out all the BUILDs it would need to call

[15:28] <TimToady> which it could call as subs?

[15:28] <jnthn> TimToady: Also, it doesn't actually have a Mu.BUILD. It works out what public attrs would be initilzied if there's an arg for them and just inlines it.

[15:28] <jnthn> TimToady: Well, "inlines"

[15:28] <TimToady> "outlines" :)

[15:28] <jnthn> TimToady: Essentially, nom's BUILDALL is a little interpreter with 3 opcodes

[15:29] <jnthn> TimToady: But yes, it's like a sub invocation

[15:29] <jnthn> Apart from the lookup is pre-done

[15:29] <tadzik> does t/spec/S02-whitespace_and_comments/minimal-whitespace.t fail in nom?

[15:29] <jnthn> So it's really just invoking a code ref :)

[15:30] <sorear> jnthn: what do you mean by handling $/ lazily?

[15:30] * TimToady wonders if BUILDALL is a macro method...

[15:31] <TimToady> I assumed it meant install lazily in the lexpad, but I could be wrong

[15:31] <sorear> TimToady: I think restricting $/ to routines only is a lovely idea.  I've added a note on that to my TODO

[15:31] <TimToady> maybe we should try to do that in next release(s) and see how it pans out

[15:32] <pmichaud> jnthn: feel free to restrict $/ creation to Routines in nom :)

[15:32] <TimToady> and $!

[15:32] <pmichaud> (since I'm dealing with regexes there anyway)

[15:32] <jnthn> sorear: What TimToady said

[15:33] <jnthn> But life just got easier there :)

[15:33] <jnthn> pmichaud: add to nommap

[15:33] *** daxim left
[15:34] <dalek> rakudo/nom: ecc173b | pmichaud++ | NOMMAP.markdown:

[15:34] <dalek> rakudo/nom: Add NOMMAP note about $/ and $!.

[15:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ecc173b94f

[15:34] <TimToady> now, if $! contains the last exception, to think about how CATCH really wants to a loop over @! containing all unhandled exceptions, semi-independent of $!

[15:35] <TimToady> s/to a/to/

[15:35] *** alim left
[15:36] <sorear> pmichaud: any progress on the my token / <foo> issue?

[15:36] <TimToady> we haven't specced anything on it

[15:37] *** daniel-s left
[15:37] <sorear> now caught up to the backlog *when I joined*...

[15:37] <TimToady> still debating in my head whether the current lexical scopes can function as an implicit grammar subclass...

[15:38] <masak> what's the thinking behind restricting $/ to routines? I think I missed the discussion part.

[15:39] <pmichaud> sorear: I'm waiting to see what TimToady++ comes up with on my token / <foo>.  I might experiment with some things in nom once we have regexes going there again.

[15:39] *** espadrine` joined
[15:39] <TimToady> masak: see http://irclog.perlgeek.de/perl6/2011-07-07#i_4075877 and following

[15:40] *** mj41 joined
[15:41] <TimToady> implicit there was the notion that it gives the user more control of the scoping as well, since they can always restrict with a 'my $/', but have the option of having $/ or $! factored out to check after any conditional structure

[15:42] <masak> TimToady: ok, reading that, it feels like an immediately good idea to do this with $/ and $!

[15:42] <TimToady> in current specland that's not easy

[15:42] <masak> I'm undecided/clouded over as to whether it's a good idea with $_

[15:42] <TimToady> not proposing it for $_

[15:42] <masak> oh, ok.

[15:42] <masak> at 13:32 you were :)

[15:43] <TimToady> no I wasn't

[15:43] <TimToady> I was saying that $_ stays the same

[15:43] <pmichaud> masak: reread it :)

[15:43] <TimToady> poorly

[15:44] <pmichaud> the "and" is a loose and

[15:44] <masak> argh :)

[15:44] <TimToady> *saying poorly, not reread it poorly :)

[15:44] <ingy> o/

[15:44] <masak> TimToady: I read that as "anyone who doesn't read properly is forced to reread it, poorly" :P

[15:44] <masak> ingy! \o/

[15:44] <ingy> where is the shelter?

[15:44] <tadzik> in the ecosystem recently :)

[15:45] <ingy> hi masak!

[15:45] <masak> what, the collapse has started?

[15:45] <ingy> tadzik: where is the ecosystem?

[15:45] <tadzik> ingy: https://github.com/perl6/ecosystem/tree/master/SHELTER

[15:45] <ingy> ta

[15:46] <tadzik> nom – Files=166, Tests=4570; podparser – Files=167, Tests=4571

[15:46] <tadzik> :)

[15:46] *** JimmyZ_ joined
[15:46] <ingy> tadzik: where did my sheltered modules go?

[15:47] <TimToady> they disintegrated in the harsh radiation

[15:47] <ingy> ?

[15:47] <tadzik> ingy: they don't need to be in the SHELTER now, they have their META.infos in their repos. SHELTER keeps META.infos of modules that don't have their own

[15:47] *** espadrine` left
[15:48] <ingy> sorry, just a bit lost. so where do all the GoodModules go?

[15:48] <ingy> or where are they referenced?

[15:48] <tadzik> https://github.com/perl6/ecosystem/blob/master/META.list

[15:49] <ingy> (it's been a while since I sprinted on your track :)

[15:49] <moritz> META.list

[15:49] <moritz> in the 'ecosystem' repo

[15:49] <ingy> to misquote TimToady++

[15:49] *** JimmyZ left
[15:49] *** ab5tract left
[15:49] *** JimmyZ_ is now known as JimmyZ

[15:50] <ingy> tadzik: got it. ta!

[15:50] *** ab5tract joined
[15:51] <tadzik> ta?

[15:51] * ingy bets patch patched them

[15:51] <sorear> *whew*

[15:51] <tadzik> yeah, I think so

[15:51] <ingy> thank you (in ozzie)

[15:51] <ingy> that's where I picked it up anyways

[15:52] <sorear> jnthn: niecza does $/ installation lazily... and it causes a lot of problems

[15:52] <sorear> jnthn: I'd like to know more about how you're doing it

[15:53] <ingy> everyone going to YAPC::EU raise their left hand

[15:53] <ingy> o/

[15:53] <tadzik> o/

[15:53] <pmichaud> don't know yet if I'll be able to go to YAPC::EU -- still working on travel funding.

[15:53] <TimToady> ö/

[15:53] <pmichaud> but I have a talk accepted.  :)

[15:53] <ingy> pmichaud++

[15:53] <sorear> *not* going.

[15:53] <ingy> damn!

[15:54] <ingy> I really wanted to meet teh sorear 

[15:55] <sorear> :(

[15:55] <sorear> colomon: ping

[15:55] <JimmyZ> we would like to see TimToady will go to BJPW next year :)

[15:55] * ingy just started working with #activestate++ again. They are helping me fund yapceu in return for impersonating Gisle Aas.

[15:56] <ingy> BJPW?

[15:56] <ingy> sounds dirty

[15:57] <moritz> Beijing Perl Workshop

[15:57] *** kaare_ left
[15:58] <JimmyZ> and pmichaud  too, if he is pleased

[15:59] <pmichaud> I'm always happy to present at workshops and conferences; it only depends on availability of time and travel funding :)

[15:59] * jnthn hopes they put next BJPW in winter or something :)

[15:59] <JimmyZ> well, travel funding is not a problem

[15:59] <pmichaud> summer BJPW is about the same as summer DFW, so no difference there for me :)

[15:59] <pmichaud> JimmyZ: then I'll be glad to attend!

[16:00] <JimmyZ> I think the problem is availability of time

[16:00] <pmichaud> generally that's not an issue for me :)

[16:01] <jnthn> pmichaud: Yeah, guess you're more used to that kinda weather.

[16:01] <JimmyZ> jnthn:  Shenzhen is much more hot than beijin

[16:01] <JimmyZ> pmichaud: I'm glad that you are pleased

[16:01] <jnthn> JimmyZ: Oh my... :)

[16:01] <jnthn> JimmyZ: It would kill me. :)

[16:01] <JimmyZ> jnthn: )

[16:01] <JimmyZ> :)

[16:02] <pmichaud> temperatures this week have been 37+ all week

[16:02] <pmichaud> (here in DFW)

[16:02] <jnthn> pmichaud: Humidity?

[16:02] <pmichaud> don't know... not too bad for humidity though.

[16:02] <JimmyZ> wow, here is  about 32 all week

[16:02] <pmichaud> not nearly as bad as Houston or Corpus Christi.

[16:03] <jnthn> pmichaud: ah, OK. In Beijing it was > 90% sometimes.

[16:03] <pmichaud> jnthn: yeah, that's about like Houston or Corpus Christi then.  :)

[16:04] <masak> ingy, tadzik: as far as I know, 'ta' comes from British English. that's not to say other parts of the Commonwealth don't use it a lot too :)

[16:05] * masak decommutes

[16:05] *** masak left
[16:05] <colomon> sorear: pong

[16:06] * colomon is not sure how he missed being notified of the ping by his software, considering he's been sitting at the computer for an hour...

[16:10] *** wolfman2000 left
[16:10] <sorear> pmichaud: temperatures seem to be ridiculous all across the USA

[16:10] <pmichaud> sorear: I agree, but 37+ is pretty normal for this area in July.

[16:10] <pmichaud> it's at least not abnormal

[16:11] *** Mowah left
[16:11] <sorear> colomon: the patch seems fine per se, but it's making me think about how to make multiple dispatch performance suck less

[16:11] <pmichaud> I am a little worried about later in July/August though... if it's this hot this regularly this early in the summer... later summer may be really bad for us.

[16:12] <colomon> sorear: as in multi subs/methods, you mean?

[16:12] <sorear> yes

[16:13] <colomon> in terms of my patch, would optional parameters (instead of multi) be an improvement, then?

[16:13] <colomon> (not that I want to stop you from optimizing multis!)

[16:14] <sorear> a performance improvement, yes, but the semantics aren't quite the same.

[16:14] <sorear> I'm wondering if it makes sense to special-case multiple dispatch where the candidates are distinguished by arity.

[16:15] *** ab5tract left
[16:15] <dalek> rakudo/nom: 7d4d042 | pmichaud++ | / (3 files):

[16:15] <dalek> rakudo/nom: Initial implementation of Junction type.

[16:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d4d0427c2

[16:15] <dalek> rakudo/nom: 15ec618 | pmichaud++ | src/core/ (6 files):

[16:15] <dalek> rakudo/nom: Refactor .gist to more closely match the spec.

[16:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15ec618718

[16:15] <dalek> rakudo/nom: b4d5e56 | pmichaud++ | src/core/Junction.pm:

[16:15] <dalek> rakudo/nom: Add Junction.ACCEPTS.

[16:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b4d5e56a07

[16:15] <dalek> rakudo/nom: 5f00dbc | pmichaud++ | NOMMAP.markdown:

[16:15] <dalek> rakudo/nom: Add Junction dispatch to NOMMAP.

[16:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5f00dbc3d4

[16:15] <pmichaud> Those commits give us basic Junction support in nom.  As long as you aren't doing something with autothreading, it should work out okay.  :-)

[16:17] <jnthn> woo :)

[16:17] <colomon> sorear: that's an interesting question.  naively, it seems like most likely the times it would come into play would mostly be ones where the "extra" parameters are basically optional.  I don't have a feel for the performance trade-off there.

[16:19] <pmichaud> although I bet jnthn++ will have junction dispatch and autothreading implemented in about... 5 min.

[16:19] <pmichaud> :D

[16:19] *** daxim joined
[16:19] <moritz> after all he has done it several times, iirc :-)

[16:20] *** JimmyZ left
[16:21] <pmichaud> jnthn: we can convert the $!storage attribute to be an RPA or a List if that's easier at some point... I just did it as an Array here for quickness/simplicity

[16:22] <moritz> nom: my $a = 3; say "$a".WHAT

[16:22] <p6eval> nom: OUTPUT«Int()␤»

[16:22] <moritz> I believe we've fixed this before too... :-)

[16:22] *** mj41 left
[16:23] <pmichaud> jnthn: it's probably safe to use the $!items attribute of $!storage if you just want to get the RPA that way

[16:23] <pmichaud> afk, lunch

[16:24] *** peczenyj joined
[16:24] <[Coke]> pmichaud: I voted your travel grant up, but haven't seen the comment show up yet.

[16:24] <peczenyj> perl6: say 4;

[16:24] <p6eval> pugs, rakudo 72d158, niecza v7-14-gbad54f1: OUTPUT«4␤»

[16:25] <pmichaud> [Coke]: thanks.  I didn't even realize that had been posted yet :)

[16:25] <peczenyj> perl6: say ^5

[16:25] <p6eval> pugs, rakudo 72d158, niecza v7-14-gbad54f1: OUTPUT«01234␤»

[16:25] *** prammer left
[16:25] <TimToady> nom: say ^5

[16:25] <p6eval> nom: OUTPUT«0..^5␤»

[16:26] <[Coke]> http://news.perlfoundation.org/2011/07/hague-grant-application-travel.html

[16:26] <dalek> roast: ba9a5d4 | moritz++ | S0 (2 files):

[16:26] <dalek> roast: various rakudo (un)fudges

[16:26] <dalek> roast: review: https://github.com/perl6/roast/commit/ba9a5d4816

[16:26] <[Coke]> (looks like several folks here have +1d it)

[16:27] *** ab5tract joined
[16:28] <moritz> nom: say say(1, 2, 3 ... 10)[*-2].WHAT

[16:28] <p6eval> nom: OUTPUT«1 2 3 4 5 6 7 8 9 10␤Failure()␤»

[16:28] <moritz> nom: say say (1, 2, 3 ... 10)[*-2].WHAT

[16:28] <p6eval> nom: OUTPUT«Int()␤Bool::True␤»

[16:28] <[Coke]> should --gen-parrot in nom resolve parrot before it resolves nom?

[16:28] <[Coke]> er, s:2nd/nom/nqp/

[16:28] <[Coke]> (since nqp needs parrot to build?)

[16:29] <pmichaud> [Coke]: it first gets nqp to find out what version of parrot to build, then builds parrot, then builds nqp

[16:29] <[Coke]> dizzy! ok. ;)

[16:29] *** Mowah joined
[16:29] <pmichaud> (since the version of parrot needed can be affected by --gen-nqp=...)

[16:31] <pmichaud> afk, lunch

[16:31] *** TBA2 left
[16:31] *** TBA2 joined
[16:32] *** wamba left
[16:34] *** everbrew joined
[16:40] <dalek> niecza: 981a202 | (Solomon Foster)++ | lib/ (2 files):

[16:40] <dalek> niecza: Implement sin, Complex.Complex.

[16:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/981a202840

[16:40] <dalek> niecza: 4c894a7 | (Solomon Foster)++ | lib/ (2 files):

[16:40] <dalek> niecza: Add ln/log and exp.

[16:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4c894a72c8

[16:40] *** am0c joined
[16:41] <moritz> colomon: btw, is ln spec?

[16:42] *** wamba joined
[16:42] *** wooden joined
[16:43] <[Coke]> http://perlcabal.org/syn/S32/Numeric.html # doesn't look like it.

[16:43] *** prammer joined
[16:43] <jnthn> [Coke]: Added my +1 too

[16:43] <colomon> ln is not spec, it's just terribly, terribly convenient for implementing log

[16:45] <moritz> colomon: in nom, I've justed used the single-arg form of log() as ln(), and used it to implement the two-arg form

[16:46] <moritz> colomon: I know that didn't work out well in master, because we subclassed the parrot Float PMC which had its own log() method

[16:47] <dalek> rakudo/nom: 1e4b69a | moritz++ | t/spectest.data:

[16:47] <dalek> rakudo/nom: three more passing test files

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e4b69acba

[16:47] <colomon> probably the "right" way to do it is to have single argument log be the equivalent of ln, and double argument log call single argument log.  but then there's the multi versus optional parameter thing going on again.

[16:47] <moritz> I like log better as a multi

[16:48] <moritz> the reason is that if you write multi sub log($num, $base = e) { ... } you have to take care of the $base even if it wasn't supplied

[16:48] *** jevin_ joined
[16:49] <colomon> moritz: sure, but you could also do log($num, $base?)

[16:49] <colomon> agreed for sure that $base = e is a loser

[16:50] <TimToady> similar reasoning to the trig simplifications

[16:51] <moritz> colomon: that's what the multi with two arguments is for

[16:51] *** Holy_Cow joined
[16:51] <moritz> multi sub log($num) { use VM's primitive for ln here }; multi sub log($num, $base) { log($num) / $log($base) }

[16:52] <sorear> the problem with $base? is that you cannot destinguish between not-supplied and undef

[16:52] <moritz> I find the current log setup in nom quite satisfactory

[16:53] <colomon> moritz: I'm saying you just do sub log($num, $base?) { $base ?? log($num) / log ($base) !! VM primitive }

[16:54] <colomon> though sorear's point is an interesting one...

[16:55] <colomon> so by spec, say, log(323, Cool) should be an error, but the $base? version would treat it as no $base specified.

[16:55] <moritz> I think it doesn't really matter all that much, because we can't do anything sensible with a base of 0 or udnefined

[16:55] <moritz> hm, right

[16:55] *** tokuhirom left
[16:56] <[Coke]> I'm confused - if we use multis, why have a 2-arg with the second optional arg?

[16:56] <[Coke]> (we'd just have a single-arg and a 2-arg variant)

[16:56] <moritz> [Coke]: it's either multis or a single routine with optional second arg

[16:57] <moritz> [Coke]: we're discussing the merits of either approach

[16:57] <[Coke]> ah. I misread it as a combination of the 2. ;)

[16:57] <colomon> part of the question is, what is the relative performance hit of the two approaches?

[16:58] <TimToady> which will, of course, depend on how ferocious your optimizer is

[16:58] <sorear> it will only make a difference when passing &log to a higher-order function

[16:59] <sorear> I'm definitely going to make multi-subs-by-arity handled at compile time

[16:59] <TimToady> one can always do &log.assuming

[16:59] <moritz> and for methods

[16:59] *** Holy_Cow left
[16:59] <sorear> with the current niecza runtime code, optional-argument will win by a wide margin

[17:00] <moritz> nom: say NaN

[17:00] <p6eval> nom: OUTPUT«NaN␤»

[17:01] <sorear> multiple dispatch is a bit underspecced atm; during candidate sorting, given A < B, B < C, A < D, are D and B tied?

[17:01] <TimToady> well, in the abstract, dispatching to multiple candidates is one of those constraint matrix logic problems like http://rosettacode.org/wiki/Dinesman%27s_multiple-dwelling_problem

[17:04] *** birdwindupbird left
[17:04] <TimToady> I suspect no-known-relation should be considered a tie

[17:05] <TimToady> unless anyone can see a good reason not to

[17:05] <moritz> the more I hack in the setting, the more convinced I am that methods need to default to :D

[17:05] <TimToady> alternately, we do something arbitrary like we did for constraints

[17:05] <moritz> on the invocant

[17:06] <moritz> (or whatever we are going to call it in the end

[17:07] <moritz> just take a look in src/core/Complex.pm - basically every method in there is wrong, unless I add a :D to the invocant

[17:08] <wolverian> hrm, iTerm 2 changes the font for all the following lines after the symbol after the NaN in p6eval's output. guess it's back to Terminal.app 

[17:09] *** MayDaniel left
[17:10] <moritz> wolverian: maybe it's not correctly configured for UTF-8?

[17:10] <wolverian> sorear: it is set to UTF-8.

[17:10] <[Coke]> looks like we're now at 4830 passing tests in nom.

[17:10] <wolverian> I suppose the character replacement strategy hits a bug 

[17:11] <wolverian> (assuming Menlo doesn't have that character)

[17:11] *** dakkar left
[17:12] <TimToady> moritz: one thing that might help is that if a proto enforces :D the multis don't have to

[17:13] <moritz> TimToady: I still think it's way easier to default to :D

[17:13] <moritz> TimToady: and manybe warn if a method call new() doesn't override the default

[17:13] *** cdarroch joined
[17:13] *** cdarroch left
[17:13] *** cdarroch joined
[17:13] <TimToady> then people will forget to change it in their constructors

[17:14] <TimToady> such a warning would be a hack

[17:14] <moritz> ... and find their error as soon as they call the constructor

[17:14] <TimToady> just playing devil's advocate

[17:14] <moritz> instead of having a hidden error in their code base

[17:15] <TimToady> we could make people say Just Dog all over :)

[17:15] <moritz> I don't buy the "such a warning would be a hack" argument. We do that all the time with deprecation warnings, forbidding empty <> etc.

[17:15] <moritz> so we are not above such hacks if it helps the user

[17:15] <TimToady> SIGTRUE

[17:16] <[Coke]> nom: my @a=(1,2,3); say [+]@a;

[17:16] <p6eval> nom: OUTPUT«6␤»

[17:16] <[Coke]> std: my @a=(1,2,3); say [+]@a;

[17:16] <p6eval> std 37a0cdd: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/c6jFUiwwuP line 1:␤------> my @a=(1,2,3); say [+]⏏@a;␤    expecting any of:␤   POST␤   bracketed infix␤        infix or meta-infix␤    postfix␤        postfix_prefix_meta_operator␤  

[17:16] <p6eval> ..prefix_circumfix_meta_operator…

[17:16] <[Coke]> std: my @a=(1,2,3); say [+] @a;

[17:16] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 123m␤»

[17:17] <pmichaud> whydoprogrammersavoidwhitespacebetweentokens?  :-)

[17:17] <TimToady> if we did that we might have to exempt .can from checking :D-ness

[17:18] <moritz> True, I didn't think of that

[17:18] <TimToady> otherwise we can't reason about our types very well

[17:18] <colomon> moritz: I wandered away, but I agree on defaulting to :D, I think

[17:19] <sorear> niecza: my @a=(1,2,3); say [+]@a

[17:19] <p6eval> niecza v7-14-gbad54f1: OUTPUT«Unhandled exception: assigning to readonly value␤  at /home/p6eval/niecza/src/STD.pm6 line 0 (STD C632_ANON @ 0) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1989 (STD P6.termish @ 6) ␤  at /home/p6eval/niecza/src/STD.pm6 line 4492 (STD C1896_ANON @ 5) ␤  at …

[17:20] <moritz> though .can on the type object is a fragile thingy anyway

[17:20] <TimToady> yes, well, and all of Platonism... :)

[17:20] <sorear> niecza: my @a=(1,2,3); say [+] @a

[17:21] <p6eval> niecza v7-14-gbad54f1: OUTPUT«6␤»

[17:21] <sorear> strange

[17:21] <TimToady> I'd just like to not make our platonism any fragiler than it needs to be...

[17:22] *** Holy_Cow joined
[17:22] <TimToady> there's something going on here of the form "Just call into this thing, and if you hit a roadblock, take a suspension and wait for a real invocant"

[17:22] *** Holy_Cow left
[17:23] <TimToady> like calling into something using a type object automatically treats it as generic in some sense

[17:24] <TimToady> like a type object intrinsically has some "whateverness" to it

[17:24] *** _jaldhar left
[17:24] *** _jaldhar joined
[17:25] <sorear> what does [ x || y || <!> ] mean?

[17:25] <TimToady> x or y or fail?

[17:25] <sorear> how does it differ from [ x || y ] ?

[17:26] * sorear wonders why [+] is parsed as a PRE and not as a term

[17:26] <sorear> std: [+]« 1, 2, 3

[17:26] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[17:26] <sorear> what does that mean?

[17:27] <TimToady> it would presumably be expecting a list for each argument

[17:28] <sorear> I don't think that makes any sense

[17:28] <sorear> hyperops are recursive

[17:28] <sorear> so [+] would never see a list

[17:29] *** wolfman2000 joined
[17:30] <pmichaud> I'm getting nom fails in S03-sequence/basic.t

[17:30] <sorear> [+] would make much more sense as a list prefix operator, imo

[17:30] <moritz> did I forget to push the roast fudges

[17:30] <moritz> ?

[17:30] <moritz> hm, seems not

[17:30] <pmichaud> I got some of them

[17:30] <sorear> rather than a prefix

[17:30] <moritz> pmichaud: did you update roast?

[17:30] <sorear> TimToady, comments?

[17:30] <pmichaud> moritz: yes.

[17:30] <colomon> sorear: list prefix operator?

[17:30] <pmichaud> let me try again

[17:30] <sorear> colomon: like how subs parse

[17:31] <TimToady> sorear: sure, I already think of them as listops

[17:31] <moritz> pmichaud: sorry, I forgot to commit, not just to push :K-)

[17:31] <jnthn> sorear: Just drew the DAG to check. In your example, tie groups are A, BD, C

[17:31] <dalek> roast: 0df5744 | moritz++ | S03-sequence/basic.t:

[17:31] <dalek> roast: fudge basic.t for rakudo

[17:31] <dalek> roast: review: https://github.com/perl6/roast/commit/0df574451d

[17:31] <sorear> jnthn: why BD and not BC?

[17:33] <jnthn> sorear: B < C so we can never remove B and C from the DAG in the same "bunch" when top-sorting.

[17:33] <TimToady> on some level, if two actual types are unrelated, it doesn't matter which order you do them, since the dispatches on the types are exclusive; but this breaks down for roles that can be mixed in I suppose

[17:34] <jnthn> sorear: After we remove A, B and D have no outgoing arrows so they're both elligible for the next group.

[17:35] <jnthn> sorear: Which just leaves C for the final group.

[17:36] <TimToady> but you don't know the relative lengths of the arrows...

[17:37] <jnthn> TimToady: Right, but that's not relevant.

[17:38] <jnthn> 'tis just a DAG.

[17:39] <dalek> rakudo/nom: a05e994 | pmichaud++ | src/core/Whatever.pm:

[17:39] <dalek> rakudo/nom: Let Whatever.gist return '*' instead of 'Whatever<...>'.  Perhaps Whatever.Str should do something similar.

[17:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a05e99478d

[17:47] *** daxim left
[17:50] <sorear> niecza: any([1],[2],[3,4]).[*-1].perl.say

[17:50] <p6eval> niecza v7-16-g4c894a7: OUTPUT«any(1, 2, 4)␤»

[17:52] *** Kivutarrr joined
[17:58] *** lue left
[18:00] *** rjbs joined
[18:00] <rjbs> Hi.  I was just confused by doing this:  my $x = [1,2,3];  my %y = { $x => 1 };

[18:00] <rjbs> I expected to get a hash with $x as a key.  How do I actually get that?

[18:01] <pmichaud> I don't think Rakudo really supports non-string keys in hashes yet.

[18:01] <pmichaud> (I could be wrong about that)

[18:02] <colomon> rakudo: my $x = [1,2,3];  my %y = { $x => 1 }; say :%y.perl

[18:02] <pmichaud> also might need to be   my %y = ( %x => 1 )

[18:02] <p6eval> rakudo 72d158: OUTPUT«"y" => {"1" => 1, "2" => Any, "3" => Any}␤»

[18:02] <pmichaud> er, $x

[18:02] <pmichaud> colomon: huh.  That looks really wrongish to me.

[18:02] <rjbs> That's what I got in the repl, btw.

[18:02] <colomon> rakudo: my $x = [1,2,3]; say ( $x => 1 ) .perl

[18:03] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Confused at line 22, near "say ( $x ="␤»

[18:03] <colomon> rakudo: my $x = [1,2,3]; say ( $x => 1 ).perl

[18:03] *** mj41 joined
[18:03] <p6eval> rakudo 72d158: OUTPUT«[1, 2, 3] => 1␤»

[18:03] <colomon> interesting....

[18:03] <pmichaud> sure, Pairs work

[18:03] <pmichaud> but Pairs don't have hash keys

[18:03] <pmichaud> rakudo:  my $x = [1,2,3];  my %h = ( $x => 1 );  say %h.perl

[18:03] <p6eval> rakudo 72d158: OUTPUT«{"1" => 1, "2" => Any, "3" => Any}␤»

[18:03] <rjbs> Also what I got.

[18:03] <pmichaud> I don't know what rakudo is doing there.

[18:04] <pmichaud> nom:  my $x = [1,2,3];  my %h = ( $x => 1 );  say %h.perl

[18:04] <p6eval> nom: OUTPUT«("1 2 3" => 1).hash␤»

[18:04] <rjbs> So, while what rakudo is doing is, um, neat... :)  ...is the syntax that I used *destined* to work?

[18:04] <pmichaud> better, but I'm not happy about the hash key being stringified

[18:04] <rjbs> p.s., you guys have the best bost

[18:04] <pmichaud> rjbs: there will be a way to do it, yes... but might need a specialized hash declaration

[18:04] <rjbs> bots

[18:04] <pmichaud> let me review the spec

[18:05] <rjbs> Thanks much.

[18:05] <[Coke]> zomg, it's rjbs.

[18:05] <rjbs> Yeah, I still live.

[18:05] <rjbs> I might want to ask you guys about ~~ sometime soon.

[18:05] <[Coke]> I'm still cowering.

[18:05] <rjbs> I have been railing about it on p5p, and I wonder whether you actually find value in some of the weirder default cases like @a ~~ %b

[18:06] <pmichaud> from S02: "The key type of a hash may be specified as a shape trait--see S09.

[18:06] <pmichaud> (looking in S09)

[18:07] <pmichaud> from S09:

[18:07] <pmichaud> To declare a hash that can take any object as a key rather than just a string or integer, say something like:

[18:07] <pmichaud>      my %hash{Any};

[18:07] <pmichaud>     my %hash{*};

[18:07] <pmichaud> this is absolutely NYI in Rakudo afaik

[18:07] <pmichaud> but the language defines how it will look, at least :)

[18:08] <TimToady> as for smartmatches, it's not really a big deal in p6, since that just means %b.ACCEPTS(@a)

[18:09] <TimToady> we don't have to do any introspection, which tends to be evil

[18:09] <pmichaud> I haven't seen any code that actually uses @a ~~ %b yet, no.

[18:09] <TimToady> if you want to rail against something, rail against the lack of a real type system in p5

[18:09] <pmichaud> (so I don't know if there's value in it or not :-)

[18:10] <rjbs> TimToady: *all over it*

[18:10] <TimToady> nearly all the mess in smartmatching comes from that

[18:10] <rjbs> TimToady: Yeah, the behavior of ~~ in general in p6 is much better.  Mostly, I wondered whether the default behavior for (say) Hash is ever useful.

[18:10] <rjbs> TimToady: I'm not sure I agree with that statement, though.

[18:10] <TimToady> for instance, all the boolean cases just fall out of having a Bool type

[18:11] *** mj41 left
[18:11] <rjbs> Smartmatch in p5 suffers from over complicated design plus buggy implementation plus half-hearted grammar changes.  The lack of typing is only annoying gravy on the annoying steak.

[18:11] <TimToady> well, it's just a design decision, if Hash.ACCEPTS is going to mean anything, what would a user want it to mean

[18:12] <rjbs> TimToady: Right.  My feeling in evaluating that question so far has been "too hard to predict"

[18:12] <TimToady> I think it's the other way around, where the typing is the steak :)

[18:12] <rjbs> I described it to mjd recently as "it's like there's a table and we *had to* fill in all the boxes."

[18:12] <TimToady> that's what tends to lead to the other problems

[18:13] <rjbs> I recently proposed a simplified ~~ dispatch on p5p in which the only valid RHS are code, qr, and object with ~~ overload.

[18:13] <[Coke]> +1 on that, btw.

[18:13] <rjbs> This gets you the .ACCEPTS behavior with obvious-to-user behavior.

[18:13] <[Coke]> <-- p5p lurker.

[18:13] <rjbs> but it eliminates @array or %hash on rhs, because guessing what the user will mean is too hard

[18:14] <TimToady> er, you left out the most important ones, string and number

[18:14] <rjbs> The suffering we get from not being able to have Scalar in there without num/str being clear is a big fat bummer, though.

[18:14] <rjbs> I left them out on purpose.  Typing makes them a nightmare.

[18:14] <rjbs> So instead you say ($x ~~ num(4))

[18:15] <TimToady> it's usually easy to tell the literals apart, which is by far the most common use case

[18:15] <TimToady> esp in a switch

[18:15] <rjbs> TimToady: I will throw that out and see what is said.

[18:16] <rjbs> I don't know enough about the guts to argue for or against.  If we can make it work only for literals, that would be nice.

[18:17] <rjbs> I agree that with a literal, what the user means is obvious.

[18:17] <TimToady> certainly in a C switch statement, you'll never see anything *but* literals :)

[18:17] <rjbs> [Coke]: thanks :)

[18:18] <TimToady> and that's what I think of as the baby in the bathwater

[18:18] <rjbs> TimToady: One use case that I really like is passing around a variable as a predicate.  So, &foo expects ($aref, $predicate) and you pass in ([...], $coderef)

[18:18] *** thou joined
[18:18] <rjbs> Passing in C< 5 > there is harder, sadly.

[18:18] <TimToady> the main reason for making it an assymetrical operator is so that we could force the comparison semantics at compile time

[18:19] <rjbs> which is one reason I didn't think much about literals

[18:19] <TimToady> yes, we use that heavily in things like grep

[18:19] <TimToady> and all our 'where' clauses are smartmatching

[18:20] <rjbs> I'd be really wary of allowing that to be passed in, in p5, because somebody adds: warn "DEBUG: got predicate $p"

[18:20] <rjbs> and now it might be a string; oops

[18:20] <TimToady> having an optional num() that strips any string caching would be useful at times

[18:20] <Tene> fwiw, I've used @a ~~ %b at least once

[18:20] <rjbs> I've talked with some guys about adding a "strict type" layer, where you can get an IV that won't stringify without the safeword.

[18:20] <TimToady> well, that's another design flaw of p5 I can blame on myself

[18:20] <rjbs> Tene: Was it in the test suite? :)

[18:21] <TimToady> I should have made that cache the string without raising it to the same type level

[18:21] <TimToady> so it still "knows" it's a num

[18:21] *** impious joined
[18:21] <Tene> rjbs: no, in code for work.  Lemme see if I can find where it was, though...

[18:21] <rjbs> TimToady: Maybe someday you can work on something that doesn't make those mistakes, but makes new and better ones!

[18:21] <TimToady> but it comes down to sloppy types again

[18:21] <TimToady> now there's an idea. :)

[18:21] *** Bzek left
[18:21] <rjbs> TimToady: Yeah.  I'm really hoping I can write up a set of tests for being stricter.  Also, rurban has talked about somewhat similar work.

[18:22] <Tene> Hmm.... I'm not seeing it now.  Maybe it wasn't for work after all...

[18:22] *** alim joined
[18:22] <rjbs> The lack of num/str types is a huge problem, for sure.  Still, I'll take Perl 5 without those over Python 3 with them any day.

[18:22] *** Bzek joined
[18:22] <TimToady> but I do think that retyping scalars so they have more memory of their original intent, and making cached values second class, would probably be a win

[18:23] <rjbs> I wonder if nobody suggests that now because it's too much work or because they're too close to the code for it to occur to them.

[18:23] <TimToady> it might be as easy as expanding the type table, where some of them are aliases to the same struct

[18:24] <TimToady> I'd guess the latter, with perhaps an unawareness that Larry already said Oops about it :)

[18:25] <rjbs> carlmasak recently tweeted something like "a slow p6 is cool; a fast p6 is a gamechanger; we will soon have one"

[18:25] <rjbs> Was that nom or something from the skunkworks?

[18:25] <[Coke]> I'm assuming nom. and I'd say "faster", not "fast".

[18:26] <TimToady> it's nom, but masak was misreading a benchmark by an order of magnitude

[18:26] * [Coke] wonders where masak is!

[18:26] <rjbs> Okay!

[18:26] <rjbs> That's why I asked, having seen the numbers.

[18:26] <TimToady> so it's 10 times slower than fast :)

[18:26] <Tene> [Coke]: probably sleeping, if I remember his time zone right.

[18:26] *** masak joined
[18:26] <masak> \o/

[18:26] <rjbs> but at least it knows the difference between a num and a str

[18:26] <[Coke]> do we have benchmarks comparing nom to master to p5?

[18:26] *** alim left
[18:26] <[Coke]> Tene: HA!

[18:27] * [Coke] thinks it's only ... like... 2100 or something where masak is.

[18:27] <masak> yes, I was misreading a benchmark by an order of magnitude.

[18:27] <masak> but that didn't have much to do with the tweet.

[18:27] <masak> I'm still mighty impressed by nom and the possibilities it entails.

[18:28] <masak> rjbs: I don't think any Perl 6 implementation will ever come within a factor of 2 compared to Perl 5. and I'm fine with that.

[18:28] <TimToady> I do

[18:28] <masak> YMMV

[18:29] *** estrabd joined
[18:29] <TimToady> You might have to write in the C subset of Perl 6 for that, but it'll happen :)

[18:29] <masak> rjbs: I sincerely think that the speedups will make more people interested in Perl 6, and I wager-ish that nom will be part of that.

[18:29] <TimToady> or more likely the Go subset

[18:29] <masak> TimToady: still half a decade away or so, though.

[18:30] <TimToady> I think the future will be unevenly distributed

[18:30] <masak> even in the future, the future is unevenly distributed!

[18:30] <Tene> ... why did you have to say that?  I already have plans for this weekend.  I don't want to cancel them to work on a go backend for Perl 6 instead.  :P

[18:30] <TimToady> the sprixel subset already way outpaces P5

[18:30] <jnthn> masak: What was the benchmark you misread, ooc?

[18:30] <masak> jnthn: my own, the one with the MMD ackermann.

[18:30] <jnthn> masak: ah

[18:30] <masak> jnthn: it's in a recent gist of mine. want me to fetch it?

[18:31] <jnthn> masak: sure

[18:31] <jnthn> masak: I'm curious how many orders of magnitude of Perl 5 we were in that example.

[18:31] <jnthn> *off

[18:31] <masak> 1.5

[18:31] <rjbs> masak: I think that if people are told "we are actually going to release a fast Perl 6" and then get a 10% (is that right?) speedup, they will be let down.

[18:32] <rjbs> but I do agree that the faster it gets, more people may be interested

[18:32] <masak> rjbs: I don't want to over-hype nom in any way. jnthn suggested that the real speedups will come this fall, with the optimizer. so I'll probably hold back when nom releases.

[18:32] <TimToady> well, in general I think nom has been running about five times faster than master, though that ain't sayin' a lot

[18:32] <rjbs> I'm not the best test, anyway.  I can barely find time to learn the fast, resume-building languages that interest me.

[18:32] <[Coke]> chromatic is also still working on making parrot faster in his spare time.

[18:33] <rjbs> That sounded promising as well.

[18:33] <masak> rjbs: it makes me really happy that the general discourse has moved from "Perl 6 doesn't exist" to "Perl 6 is too slow".

[18:33] <masak> rjbs: I'm also happily surprised by how much that tweet fires people up, in a good way.

[18:33] <[Coke]> rjbs: (language that interest me) I'm stuck doing ColdFusion most of the day, I sympathize. ;)

[18:33] <rjbs> masak: That's how we feel about: from "Perl 5 is dead" to "Perl 5 is meandering"

[18:33] <masak> :)

[18:33] <masak> that's a blog post in itself :P

[18:34] <Tene> I still prefer "Perl is undead"

[18:34] <masak> braaaaaaains

[18:34] <rjbs> [Coke]: How awful is it, really?  Compared to say PHP?

[18:34] <jnthn> How much faster nom is depends on the benchmark you do, of course. I've seen figures from "couple of times faster" to "20 times faster" depending on benchmark.

[18:34] *** wolfman2000 left
[18:34] <Tene> That, combined with the velociraptor logos, makes perl users into archeologist necromancers.

[18:34] *** whiteknight joined
[18:34] *** impious left
[18:34] <masak> jnthn: whaaa? it depends on the benchmark? is there any way to fix that? :P

[18:35] <jnthn> masak: :P

[18:35] <TimToady> sure, put exit at the top of every benchmark

[18:35] * masak supposes that the only ways to fix that are to make nom infinitely fast or infinitely slow

[18:35] <[Coke]> rjbs: it's really not that bad. Like many languages, it's possible for hacks to generate truly horrible horrible code, but of course I don't do that. ;)

[18:36] <rjbs> Yes, pick a single consistent benchmark.  I suggest (sleep 7 - $[)

[18:36] <TimToady> masak: no, no, just learn from the human factors people, and make it always take 5 seconds to get an answer, even if it was computed in .00002 seconds

[18:36] <[Coke]> heh.

[18:36] <[Coke]> to both TimToady & rjbs.

[18:36] * rjbs once got a complaint that "Acme::ProgressBar works well, but it's so SLOW"

[18:37] <TimToady> I think rjbs's is funnier

[18:37] <TimToady> not sure what happens when we get to Perl 8 though...

[18:37] <rjbs> That's when all those quantum superpositions will come in handy.

[18:38] <TimToady> actually, I'm pretty sure what happens with Pelr 6

[18:38] <TimToady> *Perl 6

[18:38] <rjbs> Perl *

[18:38] <TimToady> perl6: sleep 7 - $[

[18:38] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "["␤    expecting "::"␤    at /tmp/_m3ol246WT line 1, column 12␤»

[18:38] <p6eval> ..niecza v7-16-g4c894a7: OUTPUT«===SORRY!===␤␤Non-declarative sigil is missing its name at /tmp/ngL5Nmuxb0 line 1:␤------> sleep 7 - ⏏$[␤␤Non-simple variables NYI at /tmp/ngL5Nmuxb0 line 1:␤------> sleep 7 - ⏏$[␤␤Any()Confused at /tm…

[18:38] <p6eval> ..rakudo 72d158: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 22␤»

[18:38] <TimToady> that's what happens :)

[18:38] <masak> we haven't talked too much about the plans for Perl 8.

[18:38] <masak> Perl 7 and Perl 9 come up far more often.

[18:38] <rjbs> I was often amused by Sid Meier's Alpha Centauri (Alien Crossfire), in which there was a 22nd century computer programmer whose bio blurb noted her expert in C**.

[18:38] * diakopter joins #perl8

[18:39] <rjbs> masak: I hadn't heard anybody mention Perl 9.

[18:39] <masak> diakopter! \o/

[18:39] <rjbs> Is that just Perl 6 writen in upside down Unicode?

[18:39] <TimToady> it's from Outer Space

[18:39] <masak> rjbs: really? Gloria Wall has even promised that there won't be one, in some interview or other.

[18:39] <rjbs> of course it is

[18:39] <flussence> .u UPSIDE-DOWN NUMBER 6

[18:39] <phenny> flussence: Sorry, no results for 'UPSIDE-DOWN NUMBER 6'.

[18:39] <flussence> :(

[18:40] <TimToady> Perl ᵷ

[18:40] <TimToady> that one goes upside down

[18:41] <sjohnson> ilooks like an upside down cursive "g"

[18:42] <TimToady> which is what it is, so you can turn it upside down

[18:42] <flussence> (it annoys me that there's an entire unicode block dedicated to "mathematical symbols" that are just alphanumerics in half a dozen typefaces...)

[18:43] <rjbs> Blame the mathematicians.

[18:43] <sjohnson> it annoys me that "trollface" isn't part of unicode yet

[18:43] <masak> I'm fine with that omission.

[18:43] <rjbs> I wish we had a COMBINING DOUBLE VERTICAL LINE

[18:43] <rjbs> for making a proper $

[18:44] <flussence> .u 20b4

[18:44] <phenny> U+20B4 HRYVNIA SIGN (₴)

[18:44] <flussence> (almost)

[18:44] <sorear> hello masak, rjbs.

[18:44] <flussence> (well, if you squint and tilt your head a bit...)

[18:45] <flussence> waaaaaait.

[18:45] <flussence> .u 20e6

[18:45] <phenny> U+20E6 COMBINING DOUBLE VERTICAL STROKE OVERLAY (◌⃦)

[18:45] <diakopter> #!/bin/perl

[18:45] <diakopter> use AnyEvent;

[18:45] <diakopter> use AnyEvent::Curl::Multi;

[18:45] <diakopter> use File::Slurp;

[18:45] <diakopter> use HTTP::Request;

[18:45] <diakopter> use File::CounterFile;

[18:45] <diakopter> use Time::HiRes qw( gettimeofday tv_interval );

[18:45] <rjbs> sorear: ahoy

[18:45] <diakopter> #$| = 1;

[18:45] <diakopter> my $conc = $ARGV[0];

[18:45] *** ChanServ sets mode: +o sorear

[18:45] <diakopter> my $target = $ARGV[1]; # 172.25.19.48

[18:45] <diakopter> my $duration = $ARGV[2];

[18:45] *** diakopter was kicked by sorear (diakopter))
[18:46] *** diakopter joined
[18:46] <diakopter> hey, I apologized

[18:46] <rjbs> flussence: hm!

[18:46] <flussence> you deserved that for putting perl in /bin/ :)

[18:46] *** sorear sets mode: -o sorear

[18:46] <TimToady> that's why I have my paste limit set to 1 line :)

[18:46] <rjbs> flussence: I wonder why I didn't see that before.

[18:46] <diakopter> sigh

[18:47] * masak hugs diakopter 

[18:47] * diakopter finds paste_verify_line_count

[18:48] <sjohnson> heh

[18:48] <rjbs> Ｓ⃦

[18:48] <TimToady> hugme: hug everyone who deserves it, and diakopter too

[18:48] * hugme hugs everyone who deserves it, and diakopter too

[18:48] <sjohnson> （　｀ー´）

[18:48] <rjbs> Okay, thanks folks.  I will return another time, I'm sure.

[18:48] *** wamba left
[18:49] <masak> rjbs: thanks for dropping by!

[18:49] *** rjbs left
[18:50] <masak> TimToady: the nice thing about hugs is that they can work on a very cross-deserve basis

[18:51] <sorear> masak: I hear you had issues with 2.6.7

[18:51] <masak> sorear: hm, yes. but it's a while ago, so I've garbage-collected what exactly was wrong...

[18:51] <masak> sorear: I vaguely remember building from source. I might even have succeeded doing that.

[18:51] * masak checks

[18:52] <sorear> masak: moritz had an issue with non-clean rebuilding after a pull

[18:52] <masak> yes, it seems that I now have Mono 2.10.2

[18:52] <masak> so we can assume that all my problems with 2.6.7, if there ever were any such, are fixed :)

[18:52] <diakopter> anyone know how to set paste_verify_line_count while irssi is running?

[18:53] <flussence> /set paste_verify_line_count :)

[18:54] <masak> sorear: yes, I have a working niecza-7 \o/

[18:56] <sorear> std: foo@a

[18:56] <p6eval> std 37a0cdd: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/NJcOmCYADn line 1:␤------> foo⏏@a␤    expecting any of:␤       POST␤   argument list␤  bracketed infix␤        infix or meta-infix␤    postfix␤        postfix_prefix_meta_operator␤   statement modifier

[18:56] <p6eval> ..loop␤Undeclared …

[18:58] *** wolfman2000 joined
[18:58] <tadzik> good evening zebry

[18:59] <pmichaud> aiiiie  I leave the keyboard for 40 minutes and there's pages of backscroll!!!

[19:02] <thou> o/ tadzik

[19:02] <phenny> thou: 12:26Z <moritz_> tell thou thanks for the November pull request. I merged it, and gave you a commit bit - much easier in the long run than having to merge your stuff :-)

[19:02] <tadzik> thou: o/

[19:03] <tadzik> everyone: please test the podparser branch :)

[19:03] <pmichaud> (speed of nom)  -- my goal at this point isn't "as fast as p5", it's more of "fast enough that you're willing to accept slower-than-p5 because you value other attributes of p6 more"

[19:04] <pmichaud> that said, we are seeing 4x-5x speed improvements in nom versus master in a lot of core areas

[19:04] <pmichaud> if raw speed was really the only factor, we'd probably all be C programmers or something like that.

[19:07] <masak> what pmichaud said.

[19:07] <masak> when I said "fast" in the tweet, I actually didn't mean "Perl 5 fast".

[19:07] <masak> I meant something like "no longer unbearably slow for some things". :)

[19:08] <masak> I believe, for example, that we will see an upswing in Web stuff after nom lands. simply because it'll be a niche that opens up.

[19:08] <masak> moritz++ # merging thou's pull request

[19:08] <masak> thou++ # working on November

[19:09] <masak> thou: I'd like to support you in any way I can. please let me know if there's anything I can do.

[19:09] <thou> thanks

[19:09] <masak> thou: I thought it might be nice to throw November up on the web again, for example.

[19:09] <masak> I think I still own the domain and everything.

[19:09] <thou> yeah, i understand it's gonna be slow; hopefully nom will help w/ that soon.

[19:10] <sorear> *ahem*

[19:10] <masak> :)

[19:10] <masak> sorear feels overlooked, I see.

[19:10] <masak> sorear: has November ever run on Niecza?

[19:11] <thou> i don't want to branch out my thinking too much beyond getting it running on rakudo master :-)

[19:11] <masak> makes sense.

[19:12] <sorear> masak: no

[19:12] <masak> maybe someone'll start a "December" project, that runs on Niecza, learned from the lessons of November, and sits on top of some Dancer-like web framework or other.

[19:13] <everbrew> pugs: my $test = 1..10; say $test.shift;

[19:13] <p6eval> pugs: OUTPUT«1␤»

[19:13] <everbrew> rakudo: my $test = 1..10; say $test.shift;

[19:13] <p6eval> rakudo 72d158: OUTPUT«Method 'shift' not found for invocant of class 'Range'␤  in main program body at line 22:/tmp/svy9sSnjxv␤»

[19:14] * everbrew scratches his head

[19:14] <moritz> everbrew: ranges are immutable, iirc

[19:14] <moritz> everbrew: what are you trying to do?

[19:14] <everbrew> Poking around in perl6-examples

[19:15] <moritz> ah, much of that is out of date :(

[19:15] <everbrew> I'm learning a lot of things about perl6 by out of date examples :)

[19:15] <moritz> maybe I should remove the link from perl6.org until somebody fixes them up

[19:15] <everbrew> rakudo: my $test = @(1..10); say $test.shift;

[19:15] <p6eval> rakudo 72d158: OUTPUT«1␤»

[19:16] <everbrew> I can always make it work

[19:18] <everbrew> there's several things on the perl6.org/documentation page out of date

[19:21] <everbrew> or incomplete, or otherwise tried and failed (I'm good at finding all the unhelpful docs)

[19:21] <pmichaud> everbrew: want a commitbit?  We'd love for you to fix them.

[19:21] <pmichaud> everbrew: or if you point out the errors, I'm sure one of us will be glad to attack it.

[19:22] <pmichaud> note that   my @test = 1..10;  say @test.shift  works fine

[19:22] <pmichaud> nom:  my @test = 1..10; say @test.shift

[19:22] <p6eval> nom: OUTPUT«1␤»

[19:24] <everbrew> that wasn't the example given by the original committer ... that's the approach I took in my implementation

[19:26] *** mberends joined
[19:26] <masak> mberends! \o/

[19:29] <mberends> o/ masak!  So much backlogging to do, and so little time!

[19:31] <masak> mberends: news: I've now seen the Eiffel tower. it's not much besides what one sees in the pictures.

[19:32] <moritz> masak: did you climb it?

[19:32] <mberends> masak: :) it looks a bit nicer when parts of it are under your feet

[19:32] <moritz> it does get more impressive when you're on top

[19:32] <pmichaud> I elevatored the Eiffel tower once.

[19:33] <moritz> iirc you can only use the elevator up to the 2nd level, you have to walk to the 3rd

[19:33] <mberends> pmichaud: wise move, literally

[19:33] <pmichaud> that was 13 years ago for me, I think, so I don't remember how high up it went.  :)

[19:33] <pmichaud> But I was in the tower of the Paris hotel in Las Vegas just a couple of years ago.  No stairs there.  :)

[19:35] <masak> I figured the elevator might help. I also figured it'd not be worth the queueing without good company :)

[19:36] <pmichaud> Ah yes, I had extremely good company with me (fiancee') when I visited the Tower.  :)

[19:36] *** cooper joined
[19:36] *** cooper left
[19:37] <pmichaud> or maybe we were already married then.  Don't remember exactly what year that was.  :)

[19:37] *** cooper joined
[19:37] * moritz discovers with horror that he has no entry for security.debian.org in his sources.list

[19:37] <mberends> masak: the Masak organic composting system v1.1 now has about 100 litres of plant matter doing nicely :)

[19:39] <masak> \o/

[19:39] <moritz> a compost heap?

[19:39] <masak> I'll tell the good news to my mother.

[19:39] <pmichaud> .oO( something is rotten in .nl? )

[19:40] <masak> hopefully not.

[19:40] <masak> rotting takes place in unfavourable circumstances.

[19:40] <masak> mulching is the goal.

[19:40] <Su-Shee> oh boy.. long day.. for more than a second I was actually thinking what in computers a compost heap might be and why they choose this pun....

[19:40] <dalek> rakudo/nom: 51d0614 | pmichaud++ | src/core/Cool.pm:

[19:40] <dalek> rakudo/nom: Fix some copy-paste errors in Cool's string subs.

[19:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/51d061435b

[19:40] <dalek> roast: 775de5b | moritz++ | S32-num/roots.t:

[19:40] <dalek> roast: fudge roots.t for Rakudo

[19:40] <dalek> roast: review: https://github.com/perl6/roast/commit/775de5bc2f

[19:41] <mberends> it's definitely mulching, no odour problems at all :)

[19:41] <masak> I'm glad. the principles behind that should really be common knowledge.

[19:43] <moritz> wow, we have assembled a lot of history... 'git gc' in rakudo takes quite some time :-)

[19:43] <masak> (just in case someone's interested: it's not composting/mulching unless it's (1) body-temp, (2) aired, (3) dry)

[19:43] <dalek> rakudo/nom: 49b4b78 | moritz++ | / (4 files):

[19:43] <dalek> rakudo/nom: roots and tests

[19:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/49b4b78cee

[19:47] <masak> moritz: I noticed today that the Rakudo repo has more objects, but the npq repo is larger in bytes.

[19:48] <mberends> afk & # zzz

[19:48] *** mberends left
[19:49] *** Bzek left
[19:49] <moritz> masak: nqp stores the bootstrapping files

[19:49] <sorear> masak: the nqp repo contains several generated files that diff poorly

[19:49] <masak> yes, I concluded that would be it.

[19:49] <sorear> because PCT uses the current system time for generated symbols

[19:50] *** Mowah left
[19:51] <dalek> roast: a3634a9 | moritz++ | S02-whitespace_and_comments/minimal-whitespace.t:

[19:51] <dalek> roast: fudge minimal-whitespace.t for rakudo

[19:51] <dalek> roast: review: https://github.com/perl6/roast/commit/a3634a9258

[19:53] *** soh_cah_toa joined
[19:55] *** wolfman2000 left
[19:57] <dalek> nqp: 7426748 | pmichaud++ | src/core/NQPMu.pm:

[19:57] <dalek> nqp: Remove extra boxing... turns out the .__dump issue was in NQP, not Parrot.

[19:57] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7426748b39

[19:58] <dalek> niecza: 3708452 | sorear++ | / (3 files):

[19:58] <dalek> niecza: Experimentally change [+] to be a listop, using <args>

[19:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3708452257

[19:59] <masak>  sorear: ooh! does that mean 'say [+];' will work?

[19:59] *** Mowah joined
[19:59] <sorear> masak: yes

[19:59] <masak> wohoo!

[20:00] <sorear> mm?

[20:00] <sorear> rakudo: say [+]

[20:00] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 22␤»

[20:00] <masak> :(

[20:00] <sorear> other than removing 20 lines of very ugly code, what's so exciting?

[20:01] <masak> I can't put exact words on it. it just *feels* right that it's a listop.

[20:01] <masak> call it design intuition.

[20:02] <masak> maybe because (+) works in Lisp.

[20:02] <masak> maybe just because it'd be a shame if it didn't work.

[20:03] <benabik> rakudo: say [+] ()

[20:03] <p6eval> rakudo 72d158: OUTPUT«0␤»

[20:05] *** lue joined
[20:05] <masak> lue! \o/

[20:06] *** pjcj left
[20:06] <lue> .oO(I didn't get a chance to say) hello world! o/ .oO(first.)

[20:06] * lue backlogs

[20:06] *** leprevost left
[20:08] *** wamba joined
[20:09] *** ab5tract left
[20:09] *** im2ee joined
[20:10] *** alim joined
[20:13] <sorear> o/ lue

[20:13] <lue> nom: say 1..3; # he typed, hoping against hope it was fixed in the meantime

[20:13] <p6eval> nom: OUTPUT«1..3␤»

[20:14] <lue> ooh, the "Uninitialize string value" error is gone.

[20:15] *** wolfman2000 joined
[20:15] <sjn> rakudo: say q(this is quoted)

[20:15] <p6eval> rakudo 72d158: OUTPUT«Could not find sub &quoted␤  in main program body at line 22:/tmp/jE8j4aDlA3␤»

[20:15] <sjn> rakudo: say qq(this is quoted, with interpolation)

[20:15] <p6eval> rakudo 72d158: OUTPUT«Could not find sub &quoted␤  in main program body at line 22:/tmp/1jvMLprOwJ␤»

[20:16] <sjn> rakudo: say qq(this is a quote, with interpolation)

[20:16] <p6eval> rakudo 72d158: OUTPUT«Could not find sub &quote␤  in main program body at line 22:/tmp/r0oWbd9ylX␤»

[20:16] * sjn expects perl5isms, obviously

[20:16] <TimToady> none of those are quotes in p6

[20:16] <TimToady> but the message is wrong

[20:16] <sjn> any reason for that?

[20:16] <sjn> I mean, them not being there?

[20:17] <TimToady> so you can always, always call a function with (), even if we add keywords later

[20:17] <lue> Unless it's not supposed to (I don't know what changes have been made lately), I would expect    say 1..3;     to return the list 1,2,3

[20:17] <sorear> Does it make sense to use :$!foo anywhere except in submethod build?

[20:17] <sorear> lue: no, it should return 1..3

[20:18] <sorear> lue: say doesn't muck with lists anymore

[20:18] <sorear> lue: like I said, it was completely changed

[20:18] <TimToady> lue: ranges are now intervals, not sequences, which are now done with ... instead

[20:18] <jnthn> sorear: Well, ti's just a combination of a couple of features really.

[20:18] <jnthn> sorear: There's nothing magical about it and build.

[20:18] <sorear> jnthn: I mean BIND_ATTRIBUTE

[20:18] <lue> OK.

[20:18] <sorear> jnthn: I can't think of any case except BUILD where BIND_ATTRIBUTE is what you want

[20:19] * lue continues to wonder where he was when everything changed... [obviously not on #perl6]

[20:19] <jnthn> sorear: I'm sure I've had a couple of real world cases in @other-lang where I thought "oh, in Perl 6 I'd use attributive params" :)

[20:19] <jnthn> sorear: Sadly I can't think of them off hand.

[20:19] *** alim_ joined
[20:20] <jnthn> I agree BUILD is by far the most obvious place for it, but it also makes it very easy to write traditional setter methods.

[20:21] *** alim left
[20:21] *** alim_ is now known as alim

[20:26] * sorear thinks about giving niecza's signatures a bit more..structure

[20:28] *** pjcj joined
[20:29] *** mj41 joined
[20:31] <pmichaud> std:  say q(this is quoted)

[20:31] <p6eval> std 37a0cdd: OUTPUT«===SORRY!===␤Undeclared routines:␤        'is' used at line 1␤    'q' used at line 1␤     'quoted' used at line 1␤        'this' used at line 1␤Check failed␤FAILED 00:01 119m␤»

[20:32] *** alim_ joined
[20:32] *** alim left
[20:32] *** alim_ is now known as alim

[20:36] <masak> sorear: would it be possible to get a final newline after ^D at the REPL? want me to file a github issue?

[20:36] <masak> blog post idea, free for anyone to implement: a quick tour of the best of Perl 6, using the Niecza REPL.

[20:38] <jlaire> what's the idiomatic way to implement a constructor? I've got a class C which 'has Int $.a' and I want to be able to write C.new(42) instead of C.new(:a(42))

[20:39] *** cooper left
[20:39] <masak> jlaire: first question: why do you want that? :)

[20:39] <tadzik> method new(Int $a) { self.bless(*, a => $a) }

[20:39] <masak> that is, why do you feel a need to override the default?

[20:39] <jlaire> masak: it's so much shorter :)

[20:39] *** cooper joined
[20:39] <sjn> rakudo: "".^methods.perl.say

[20:39] <p6eval> rakudo 72d158: OUTPUT«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { .…

[20:39] <masak> ok, I buy that.

[20:39] <jlaire> these classes are for the AST of lambda calculus

[20:40] <masak> rakudo: say "".^methods>>.name.perl

[20:40] <p6eval> rakudo 72d158: OUTPUT«("ACCEPTS", "perl", "pred", "succ", "WHICH", "Bool", "Str", "encode", "indent", "Numeric", "Real", "Int", "Rat", "Num", "abs", "conjugate", "exp", "log", "log10", "sqrt", "roots", "to-radians", "from-radians", "floor", "ceiling", "round", "truncate", "sign", "cis",…

[20:40] <jlaire> Lambda(Var('x'))  vs.  Lambda.new(Var.new('x'))

[20:40] <masak> jlaire: ah.

[20:40] <jlaire> plus, it feels more like a Haskell ADT without 'new' :)

[20:40] <masak> jlaire: to get the former, you need to give it a postcircumfix:<( )> method.

[20:40] <jlaire> I tried  method new(Int $a) { callwith(:$a) }  but that gives mysterious errors

[20:41] <masak> jlaire: I sometimes do that, but I usually hesitate quite a bit.

[20:41] <jlaire> .new is somewhat ok, but the :names I don't like

[20:41] * sjn has an impressipon that introspection in perl6 isn't obvious enough

[20:41] <jnthn> method new(Int $a) { self.bless(*, :$a) }

[20:41] <jlaire> I meant to compare Var.new('x') vs. Var.new(:name('x'))

[20:42] <jlaire> jnthn: thanks, I'll try that

[20:42] <jnthn> rakudo: say "".^methods

[20:42] <p6eval> rakudo 72d158: OUTPUT«ACCEPTSperlpredsuccWHICHBoolStrencodeindentNumericRealIntRatNumabsconjugateexploglog10sqrtrootsto-radiansfrom-radiansfloorceilingroundtruncatesigncisunpolarchrchrsrandsincostanseccoseccotansinhcoshtanhsechcosechcotanhasinacosatanatan2asecacosecacotanasinhacoshatanh…

[20:42] <jnthn> nom: say "".^methods

[20:42] <p6eval> nom: OUTPUT«Bool Int Num Numeric chomp chop substr pred succ Str ACCEPTS gist perl rand bytes chars fmt substr uc lc ucfirst lcfirst chomp chop ord flip index rindex eager elems infinite flat hash list pick roll reverse sort Array grep join map min postcircumfix:<[ ]> at_pos postcircumf…

[20:42] <jlaire> currently I have 'class Var' etc. and 'sub Var' etc. which works great but feels wrong :)

[20:42] <jnthn> sjn: If you'd not added the .perl you'da got what you were after :)

[20:42] <masak> sjn: introspection as a concept isn't very obvious.

[20:42] <jlaire> the constructor with .new and positional params will be fine

[20:43] <jnthn> sjn: Well, I guess you wanted a list of names, anyway :)

[20:43] <sjn> masak: I think it could be made very obvious :)

[20:43] <jnthn> Routine.perl certainly could be improved.

[20:43] <masak> sjn: do you have any concrete suggestions? :)

[20:43] <sjn> rakudo: "".^methods>>.say

[20:43] <p6eval> rakudo 72d158: OUTPUT«ACCEPTS␤perl␤pred␤succ␤WHICH␤Method 'say' not found for invocant of class 'Perl6MultiSub'␤  in main program body at line 22:/tmp/2BVtGzs9sC␤»

[20:43] <masak> sjn: um, please do not use .say with a parallelization construct.

[20:44] <TimToady> we usually write that as:

[20:44] <TimToady> rakudo: .say for ''.^methods

[20:44] <p6eval> rakudo 72d158: OUTPUT«ACCEPTS␤perl␤pred␤succ␤WHICH␤Method 'say' not found for invocant of class 'Perl6MultiSub'␤  in <anon> at line 22:/tmp/mSES57Ws5I␤  in main program body at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[20:44] <sjn> masak: sounds like a errormessage bug :)

[20:44] <masak> sjn: no, freedom under responsibility :)

[20:44] <benabik> rakudo: ''.^methods[0].say

[20:44] <p6eval> rakudo 72d158: OUTPUT«ACCEPTS␤»

[20:46] <sjn> masak: anyhow, I have no concrete suggestions, but perhaps some principles

[20:46] <jnthn> .oO( another failure mode that's gone away in nom)

[20:46] <sorear> masak: ehehehe.  there's a subtle bug in the REPL that makes that not quite work :/

[20:46] <masak> sorear: oh

[20:47] <masak> sorear: I'll file the github issue, then.

[20:47] <sorear> no

[20:47] <sorear> I can fix \n easily enough

[20:47] <masak> ok :)

[20:47] <sorear> but there's something very subtly broken with $_ in the REPL

[20:47] <sorear> try say *-1; { say 2 }

[20:48] <sorear> or just say *-1;\n say $_

[20:48] <masak> urgh

[20:48] <masak> System.NullReferenceException: Object reference not set to an instance of an object

[20:48] <jlaire> rakudo: class C { has $.a }; my $a = 42; say C.new(:$a), C.new($:a)

[20:48] <p6eval> rakudo 72d158: OUTPUT«C()<0x613fc38>C()<0x6104f88>␤»

[20:48] <masak> [stacktrace omitted]

[20:49] <masak> jlaire: huh!

[20:49] <jnthn> placeholder parameters shouldn't work there :)

[20:49] <masak> std: class C { has $.a }; my $a = 42; say C.new(:$a), C.new($:a)

[20:49] <p6eval> std 37a0cdd: OUTPUT«===SORRY!===␤Placeholder variable $:a may not be used outside of a block at /tmp/Yf68hECzVU line 1:␤------> }; my $a = 42; say C.new(:$a), C.new($:a⏏)␤Check failed␤FAILED 00:01 123m␤»

[20:49] <masak> right.

[20:49] <masak> I think there's an RT ticket about that.

[20:49] <jnthn> nom: class C { has $.a }; my $a = 42; say C.new(:$a), C.new($:a)

[20:50] <p6eval> nom: OUTPUT«Redeclaration of symbol $a as a placeholder parameter at line 1, near ")"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[20:50] * jlaire goes to rtfs

[20:50] <masak> jlaire: S06.

[20:50] <jnthn> nom: class C { has $.a }; my $a = 42; say C.new(:$a), C.new($:b)

[20:50] <lue> blog post! https://rdstar.wordpress.com/2011/07/07/configure-the-past-during-the-compile-time-phase-of-the-core-setting-generation-the-effect-of-nom-on-me/

[20:50] <p6eval> nom: OUTPUT«Segmentation fault␤»

[20:50] <jnthn> wow :)

[20:50] <moritz> nom: say "a" => 5

[20:50] <p6eval> nom: OUTPUT«"a" => 5␤»

[20:50] <tadzik> lue: the url doesn't fit in my terminal window :P

[20:50] <moritz> nom: say ("a" => 5).Str

[20:50] <p6eval> nom: OUTPUT«a   5␤»

[20:51] <jlaire> masak: ty

[20:51] <jlaire> good thing about these twigils and other symbols is that they're easily greppable

[20:52] <jlaire> the other day I ran into a piece of scala syntax and couldn't easily find where it's defined

[20:52] <lue> try this: http://wp.me/pUzx1-1z

[20:52] <masak> lue++ # blog post

[20:52] <masak> lue: for what it's worth, I was in your shoes a couple of years back. then #perl6 corrupted me :P

[20:53] <masak> lue: (that said, I never quite grokked what pmurias and ruoso were talking about, they seemed really really smart)

[20:54] <moritz> *and* they were using their own language :-)

[20:54] <tadzik> I still can't distinguish List from Parcel or Array or Seq or ...

[20:54] <masak> moritz: Polish and Portuguese? :)

[20:54] <tadzik> I think Seq is immutable :)

[20:54] <moritz> masak: MOPspeak

[20:55] <masak> lue: most compiler talk becomes much more understandable once you've grokked your first compiler.

[20:55] <moritz> tadzik: I can't either. I still hope that pmichaud++'s rewrite of S07 will eventually enlighten me

[20:55] <tadzik> :)

[20:55] * jnthn would probably be able to parse the MOPspeak quite well these days :)

[20:55] <masak> lue: wanna help me develop Yapsi? :)

[20:55] <lue> Every time I think something along the lines of .oO(What is their secret‽ Is there a secret society of knowledge‽ Where is the secret book that lets understand it by Larry Wall‽)

[20:55] <moritz> in particular I'm quite surprised that List is now mutable

[20:55] <moritz> what's the point in having it over Array if both are mutable?

[20:55] <jnthn> slime on the other hand... :)

[20:56] <tadzik> oh, I can now investigate the scary List bug

[20:56] <jnthn> lue: There's not really a secret. Compilers are just another area of computing with a bunch of their own terminology and concepts.

[20:56] <masak> lue: answer me truly: what is a compiler?

[20:57] <lue> A program that turns high-level programming into something a machine can run.

[20:57] <masak> fair enuf.

[20:57] <tadzik> it's a program that takes some input and generates some output

[20:57] <tadzik> :)

[20:57] <tadzik> that makes compilers sound a lot less scary

[20:57] <jnthn> tadzik: Basically, yes :)

[20:57] <masak> score one to tadzik.

[20:57] <sjn> huh

[20:58] <masak> that's what I wanted my point to be :)

[20:58] <tadzik> and, however you look at it, that's correct

[20:58] <masak> a compiler is a special kind of filter.

[20:58] <sjn> rakudo: "".^methods.elems.say

[20:58] <masak> filters are really non-scary.

[20:58] <p6eval> rakudo 72d158: OUTPUT«151␤»

[20:58] <sjn> rakudo: "".^methods.elems.uniq.say

[20:58] <p6eval> rakudo 72d158: OUTPUT«151␤»

[20:58] <sjn> oops

[20:58] <moritz> and it's even a rather simple program, because it "just" transforms a text to something

[20:58] <masak> filters don't have side-effects. they just have an input and an output.

[20:58] <sjn> rakudo: "".^methods.uniq.elems.say

[20:58] <jnthn> Generally compilers go text => tree => another tree => ... => text :)

[20:58] *** alim left
[20:58] <jlaire> jnthn: what's slime?

[20:58] <p6eval> rakudo 72d158: OUTPUT«145␤»

[20:58] <moritz> it doesn't have to deal with networks or anything

[20:58] <sjn> ooh, now it works

[20:58] <masak> jlaire: pmurias and ruoso liked to name their projects after icky, growing things.

[20:59] <tadzik> there's this Zenish story about a banking software and the operating system, or something

[20:59] <jnthn> jlaire: There were a sequence of components in the smop project that tended to be named after...unpleasant sounding substances :)

[20:59] <lue> .oO(and now everything I knew about say is just heresay)

[20:59] <masak> lue: here's what a compiler looks like on the inside: [parser | tree manipulator | serializer]

[20:59] <jlaire> .oO( slime = Superior Lisp Interaction Mode for Emacs... )

[20:59] <jlaire> okey

[21:00] <sjn> anyhoo, shouldn't "".^methods.elems == "".^methods.uniq.elems; ?

[21:00] <tadzik> http://www.enchanter.net/tao.html#book3 -- see 3.3

[21:00] *** Holy_Cow joined
[21:00] <masak> lue: the parser makes you a tree. the tree manipulator might do things like make a better tree out of the parse tree, or do nice optimizations. the serializer gives you back some text.

[21:00] *** Holy_Cow left
[21:00] <masak> lue: you already know about grammars, so you know how that bit works. tree manipulation is kinda easy; that's why we like things as trees. serialization is super-easy.

[21:01] <tadzik> the code generation part has always scared me

[21:01] <TimToady> sjn: not necessarily; what if you want to grep out all the .foo methods?

[21:01] <masak> lue: the only tricky part is understanding the domain: the way the runtime works and what it needs to work.

[21:01] <jlaire> there are lots of text books about compilers, if you like reading

[21:01] <tadzik> I think the upcoming summer will make me feel better about it :)

[21:01] <moritz> tadzik: me too, but PCT mostly fixes that for me

[21:01] <masak> tadzik: iterating through a tree and outputting things is conceptually simple, though.

[21:01] <tadzik> yeah, but I'd like to know how it works, and why

[21:01] <sjn> TimToady: what do you mean? my test just pointed out that the ""^.methods array contains duplicates

[21:02] <tadzik> after the GSoC cools down a bit, I plan to start a C compiler, just for the sake of learning stuff

[21:02] <masak> tadzik: in Perl 6? :)

[21:02] <sjn> rakudo: "".^methods.uniq.elems < "".^methods.elems

[21:02] <tadzik> masak: probably, yes :) If it turns out to be fun enough, I may rewrite it to C and bootstrap

[21:02] <p6eval> rakudo 72d158:  ( no output )

[21:02] <sjn> rakudo: say "".^methods.uniq.elems < "".^methods.elems

[21:02] <masak> tadzik: \o/

[21:02] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[21:02] <tadzik> masak: but I want to generate assembly, not Parrot code

[21:02] <masak> granted.

[21:03] <masak> tadzik: make sure you read sorear's recommended text.

[21:03] <tadzik> just to solidify the knowledge from the assembly classes

[21:03] <tadzik> "let's build a compiler"?

[21:03] <tadzik> it's already on my Kindle, next to the Dragonbook :)

[21:03] <masak> tadzik: yes, that.

[21:04] <sorear> I haven't actually ever seen a copy of the Dragonbook.

[21:04] <masak> the Dragon book can't hurt either :)

[21:04] <tadzik> The Scary List Bug: https://gist.github.com/1070537

[21:04] *** mj41 left
[21:04] <lue> (I have the feeling my P6IF project would help with understanding compilers.)

[21:05] <sjn> rakudo: "".^methods.sort.join(" ").say

[21:05] <p6eval> rakudo 72d158: OUTPUT« ACCEPTS ACCEPTS BUILD BUILDALL Bool Bool CREATE Capture IO Int Num Numeric Numeric PARROT Rat Real Seq Str Str WALK WHENCE WHERE WHICH WHICH abs acos acosec acosech acosh acotan acotanh all any asec asech asin asinh at_key at_pos atan atan2 atanh bless bytes can c…

[21:05] <[Coke]> tadzik: what kind of assembly?

[21:05] <jnthn> nom: say List.new('a', 'b', 'c')

[21:05] <dalek> roast: 538f68c | moritz++ | S03-operators/reduce-le1arg.t:

[21:05] <dalek> roast: fudge reduce test for rakudo

[21:05] <dalek> roast: review: https://github.com/perl6/roast/commit/538f68cd6f

[21:05] <masak> lue: have you read http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html ?

[21:05] <p6eval> nom: OUTPUT«a b c␤»

[21:05] <tadzik> [Coke]: x86, probably nasm syntax

[21:05] <masak> lue: basically, one's whole outlook on programming is helped by understanding compilers.

[21:06] <lue> I have not /me looking

[21:06] <tadzik> I wanted to take compiler classes next semester, but everyone on my year is to scared to join me :)

[21:06] <jlaire> steve yegge's articles need a tl;dr...

[21:07] <masak> jlaire: this one has one :P

[21:07] <masak> it's at the bottom.

[21:07] <jlaire> masak: oh! :)

[21:07] <jlaire> heh

[21:08] <masak> :)

[21:10] <moritz> Files=183, Tests=5197 \o/

[21:10] <dalek> rakudo/nom: 533cd63 | moritz++ | t/spectest.data:

[21:10] <dalek> rakudo/nom: run 4 more test files, pass 5.1k tests

[21:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/533cd6358c

[21:10] <masak> wow!

[21:10] <jnthn> moritz++

[21:11] <masak> you people are amazing!

[21:11] <tadzik> yy :)

[21:11] <tadzik> or even a full yay!

[21:11] <tadzik> so it's 5198 on podparser I suppose :P

[21:11] <tadzik> jnthn: could you take a peek at the Scary List Bug?

[21:12] <tadzik> https://gist.github.com/1070537

[21:12] <jnthn> tadzik: I'm peeking at the very scary REPL bustage at the moment. :)

[21:12] <jnthn> tadzik: I'll try and get to the List one in a bit.

[21:12] <tadzik> ok, no problem :)

[21:12] <jnthn> Somehow on the second run in the repl, it ends up considering "say" a type name... :/

[21:13] <[Coke]> so is this coming together faster than ng did?

[21:14] <moritz> [Coke]: it certainly feels like it

[21:14] <jnthn> yes and no

[21:14] <jnthn> Yes, once nom was really dug in to it's been coming together faster than ng 

[21:15] <dalek> specs: 08f2ce9 | larry++ | S05-regex.pod:

[21:15] <dalek> specs: $/ is now per-routine

[21:15] <dalek> specs: review: https://github.com/perl6/specs/commit/08f2ce9d48

[21:15] <jnthn> But the groundwork leading up to nom may well have been longer

[21:15] <lue> .oO(situation 2 [in that blogspot post] doesn't sound like me...)

[21:15] <jnthn> Hard to say for sure.

[21:16] <jnthn> I know that 6model took a while to think up, got a CLR implementation, then got a Parrot implementation, then NQP got re-done, then it got migrated to build meta-objects at compile time. Plus multi-dispatch got re-designed. All of that took place before nom started.

[21:17] <jnthn> otoh, ng was preceded by in some ways an even bigger NQP re-write, and a total grammar engine do-over

[21:17] <TimToady> rakudo: ''.^methods[0].WHAT.say

[21:17] <p6eval> rakudo 72d158: OUTPUT«Code()␤»

[21:17] <tadzik> oh-oh, panda will be talked about!

[21:18] <TimToady> rakudo: say ''.^methods.grep('ACCEPTS')».WHICH

[21:18] <p6eval> rakudo 72d158: OUTPUT«14020462704742458315224␤»

[21:18] <TimToady> rakudo: .say for ''.^methods.grep('ACCEPTS')».WHICH

[21:18] <p6eval> rakudo 72d158: OUTPUT«140043144995840␤56742360␤»

[21:19] <TimToady> sjn: ^^ note the supposed dups are two different Codes

[21:20] <[Coke]> jnthn: that reminds me - will nom branch work on nqp-clr?

[21:20] <masak> lue: Yegge has, like many people, an outdated view of Perl. lots of people do.

[21:21] <masak> lue: it's especially bad for people who have been exposed to lots of code by people who don't, let's say, value maintainability.

[21:22] <dalek> roast: f77300f | moritz++ | S32-num/power.t:

[21:22] <dalek> roast: unfudge Complex.roots tests for rakudo

[21:22] <dalek> roast: review: https://github.com/perl6/roast/commit/f77300f392

[21:22] <jnthn> [Coke]: No - there's a bunch of work to go before that can happen

[21:23] <jnthn> [Coke]: The Parrot 6model implementation is ahead of the clr one, for one thing.

[21:23] <moritz> that should push us over the 5.2k tests limit

[21:23] <moritz> and with that I'll retire to bed. Good * folks!

[21:23] <jnthn> o/ moritz 

[21:23] *** Chillance left
[21:24] *** masak left
[21:24] *** masak joined
[21:24] <masak> 'night, moritz

[21:25] <masak> dream of 7k tests :)

[21:25] <sorear> hello masak.

[21:26] <masak> must've been a glitch. I hope it doesn't manifest again.

[21:31] <sjn> TimToady: ah, cool. how do I probe for more information on those methods? (e.g. what class they're inherited from)

[21:31] <TimToady> rakudo: ''.^methods[0].WHAT.^methods.join(' ').say

[21:31] <p6eval> rakudo 72d158: OUTPUT«new assuming callwith multi name perl signature do Str of returns Numeric Real Int Rat Num abs conjugate exp log log10 sqrt roots to-radians from-radians floor ceiling round truncate sign cis unpolar chr chrs rand sin cos tan sec cosec cotan sinh cosh tanh sech cos…

[21:32] <TimToady> nom: ''.^methods[0].WHAT.^methods.join(' ').say

[21:32] <p6eval> nom: OUTPUT«Method 'Stringy' not found for invocant of class 'Sub'␤current instr.: 'join' pc 368542 (src/gen/CORE.setting.pir:98936) (src/gen/CORE.setting:486)␤»

[21:32] <jnthn> aww, that used to work

[21:32] <TimToady> rakudo: ''.^methods[0].WHAT.^methods(:local).join(' ').say

[21:32] <p6eval> rakudo 72d158: OUTPUT«new assuming callwith multi name perl signature do Str of returns␤»

[21:33] <jnthn> TimToady: Should Code ~~ Cool?

[21:33] <TimToady> NO!

[21:33] <masak> :)

[21:33] <jnthn> TimToady: Figured not

[21:33] <TimToady> we had that discussion several days ago

[21:33] <masak> when you were away, jntn :)

[21:33] <jnthn> OK, just trying to figure out who was the Stringy :)

[21:34] *** everbrew left
[21:34] <TimToady> I suspect we should not rely on Cool for stringifying method names

[21:35] *** peczenyj left
[21:35] *** deezy joined
[21:35] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).gist.say

[21:35] <p6eval> nom: OUTPUT«␤»

[21:35] <deezy> when will perl6 be production ready?

[21:35] <jnthn> nom: say ''.^methods[0].WHAT

[21:35] <p6eval> nom: OUTPUT«Method()␤»

[21:35] <TimToady> Christmas

[21:36] <masak> deezy: any reason you ask?

[21:36] <jnthn> TimToady: Method is just a subclass of Routine, so it has no local methods.

[21:36] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local)».name.gist.say

[21:36] <dalek> niecza: 240a9af | sorear++ | / (3 files):

[21:36] <dalek> niecza: More tweaks to repl variable handling, I think $_ is mostly working

[21:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/240a9af84d

[21:36] <p6eval> nom: OUTPUT«Could not find sub !dispatch_method_parallel␤current instr.: '_block1002' pc 138 ((file unknown):999128829) (/tmp/2IYWXi3Mhj:1)␤»

[21:36] <sorear> deezy: "production ready" doesn't apply to software

[21:37] <jnthn> No hypers in nom yet

[21:37] <masak> deezy: I'm using Perl 6 in production, and have for going on a year now.

[21:37] <sorear> deezy: when will Perl 6 be ready for you to use?  well, that depends entirely on what you want to use it for.

[21:37] <deezy> yes, I have been a perl 5 user for years and was curious on whether I could use perl6 for production web development.

[21:37] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).map(*.name).gist.say

[21:37] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Whatever'␤current instr.: '_block1002' pc 149 ((file unknown):88) (/tmp/Poxgcl6cjW:1)␤»

[21:37] <masak> deezy: that's what I'm using it for.

[21:38] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).map({.name}).gist.say

[21:38] <masak> deezy: I have a 250 line Perl 6 script building my static blog for me.

[21:38] <p6eval> nom: OUTPUT«␤»

[21:38] <deezy> masak, how is the performance compared to php5 and jsp?

[21:38] <sjn> deezy: no hurries yet, perl6 is under good development, but if you want it to do demanding stuff you should probably stay with Perl5 for a while more

[21:38] <masak> deezy: slower, currently.

[21:39] <TimToady> but we're getting faster faster :)

[21:39] <masak> deezy: likely too slow for what you're planning. but we won't know that until you've tried. :)

[21:39] <masak> deezy: also, try Niecza for speed.

[21:39] <sjn> deezy: what you get with Perl6 is an really expressive language

[21:39] <sjn> a*

[21:39] <masak> deezy: I'm planning to rewrite some hot paths of my blog engine in Niecza.

[21:40] <sjn> deezy: so if you're a computer language geek, this is the place to be :)

[21:40] <deezy> Thanks masak. I will try it. Keep up the good work guys.

[21:40] <lue> afk

[21:40] <sjn> deezy: if you're just after Getting the Job Done, stick with Perl5 and CPAN for a little while more

[21:40] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local)[0].name.say

[21:40] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Mu'␤current instr.: '_block1002' pc 154 ((file unknown):55098344) (/tmp/sz2h_1IjML:1)␤»

[21:41] <TimToady> say wot?

[21:41] <deezy> masak, whats the url of your blog

[21:41] *** Mowah left
[21:41] <masak> deezy: http://strangelyconsistent.org

[21:41] <deezy> thanks

[21:41] <masak> my pleasure :)

[21:41] <TimToady> rakudo: ''.^methods[0].WHAT.^methods(:local)[0].name.say

[21:41] <p6eval> rakudo 72d158: OUTPUT«new␤»

[21:42] <TimToady> jnthn: how comes I get a Mu there?

[21:43] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).WHAT.say

[21:43] <p6eval> nom: OUTPUT«Parcel()␤»

[21:43] <jnthn> nom: (1,2,3)[3].WHAT.say

[21:43] <p6eval> nom: OUTPUT«Mu()␤»

[21:43] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).list.[0].name.say

[21:43] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Mu'␤current instr.: '_block1002' pc 166 ((file unknown):49039754) (/tmp/xaE5NsHEXX:1)␤»

[21:44] <jnthn> nom: (1,2,3).list.[3].WHAT.say

[21:44] <p6eval> nom: OUTPUT«Mu()␤»

[21:44] <jnthn> nom: (1,2,3).list.WHAT.say

[21:44] <p6eval> nom: OUTPUT«List()␤»

[21:44] <jnthn> Hm

[21:44] <TimToady> seems a bit suboptimal...

[21:44] <jnthn> TimToady: Guess it shoulda been Any?

[21:44] <jnthn> nom: my @a; say @a[0].WHAT

[21:44] <p6eval> nom: OUTPUT«Any()␤»

[21:45] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).Array.[0].name.say

[21:45] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Any'␤current instr.: '_block1002' pc 166 ((file unknown):35281290) (/tmp/4mu1Y03IU4:1)␤»

[21:46] *** Patterner left
[21:46] <TimToady> point is, it should be either Mu or Any, it should be the name of new

[21:46] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).list.munch.name.say

[21:46] <p6eval> nom: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'munch' pc 389932 (src/gen/CORE.setting.pir:109276) (src/gen/CORE.setting:2297)␤»

[21:47] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).list.munch(1).name.say

[21:47] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 166 ((file unknown):59600714) (/tmp/U4LPL8oPox:1)␤»

[21:47] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).list.munch(1).perl.say

[21:47] <p6eval> nom: OUTPUT«()␤»

[21:47] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local).perl.say

[21:47] <p6eval> nom: OUTPUT«()␤»

[21:47] <jnthn> TimToady: I'm confused

[21:47] <jnthn> TimToady: "name of new"?

[21:48] <TimToady> nom: ''.^methods[0].WHAT.^methods(:local)[0].name.say

[21:48] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Mu'␤current instr.: '_block1002' pc 154 ((file unknown):44821480) (/tmp/n_WWo2GAbH:1)␤»

[21:48] <TimToady> rakudo: ''.^methods[0].WHAT.^methods(:local)[0].name.say

[21:48] <p6eval> rakudo 72d158: OUTPUT«new␤»

[21:49] <jnthn> TimToady: Seems that some some reason in master, Method declares its own .new method

[21:49] <jnthn> TimToady: In nom it just inherits one from elsewhere

[21:49] <TimToady> nom: ''.^methods[0].WHAT.^methods()[0].name.say

[21:49] <p6eval> nom: OUTPUT«Method 'name' not found for invocant of class 'Sub'␤current instr.: '_block1002' pc 146 ((file unknown):20538630) (/tmp/DX_tvRIjQJ:1)␤»

[21:49] <TimToady> well, that's different at least :)

[21:49] <jnthn> Now, that's a bug.

[21:49] <jnthn> nom: sub foo() { }; say &foo.name

[21:50] <p6eval> nom: OUTPUT«foo␤»

[21:50] <jnthn> oh :/

[21:50] *** drbean joined
[21:50] <jnthn> Code has NQP methods, not Perl 6 ones. Circularity sawing fun.

[21:50] <jnthn> Fixable.

[21:50] <TimToady> Cool!  I mean, not Cool!

[21:51] *** wamba left
[21:51] <jnthn> Just a bit of fun when Code's methods need to be Code :)

[21:51] <jnthn> Well, or Method :)

[21:51] * jnthn is having a hard time with the repl breakage

[21:51] <TimToady> .o(there's a Code to our Cadness...)

[21:52] *** spq1 left
[21:52] *** wamba joined
[21:53] *** Psyche^ joined
[21:53] *** Psyche^ is now known as Patterner

[21:54] *** alester joined
[22:00] *** im2ee left
[22:01] *** deezy left
[22:02] *** bitpat joined
[22:03] <masak> I'll tell you, this text adventure game stuff is no child's play.

[22:04] <TimToady> when will you tell us?

[22:04] <masak> oops, uncolloquial English detected.

[22:05] <masak> s/\'ll//

[22:05] <TimToady> :)

[22:05] <masak> I'm now up to 233 lines, with no sign of slowing down or becoming shorter.

[22:05] <masak> but I guess that's OK.

[22:07] <masak> rakudo: role R { has $.x; method x {} }; class C does R {}; say "alive"

[22:07] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤A method named 'x' already exists in class 'C'. It may have been supplied by a role.␤»

[22:07] <masak> jnthn: known?

[22:07] <masak> nom: role R { has $.x; method x {} }; class C does R {}; say "alive"

[22:07] <p6eval> nom: OUTPUT«Package 'C' already has a method 'x'; did you mean to declare a multi-method?␤current instr.: 'nqp;Perl6;Metamodel;MethodContainer;add_method' pc 21437 (src/gen/perl6-metamodel.pir:0) (src/gen/Metamodel.pm:190)␤»

[22:07] <jnthn> Better.

[22:07] <masak> but wrong.

[22:08] <jnthn> oh?

[22:08] <masak> I say so.

[22:08] <masak> there's no conflict there.

[22:08] <jnthn> The role conflict one is wrong

[22:08] <jnthn> The nom error is just a duplicate method error

[22:08] <masak> there's no duplicate method either.

[22:09] <masak> there's just one method.

[22:09] <jnthn> Well, there is because Attribute.compose tries to add the accessor you ask for.

[22:09] <masak> I know why.

[22:09] <jnthn> I suspect we should tell it not to if there already is one.

[22:09] <masak> and it doesn't generate an error for classes.

[22:09] <masak> shouldn't for roles either.

[22:09] <jnthn> I find that hard to believe.

[22:09] <masak> which part?

[22:09] <felher> lue++ for blog blog post :)

[22:10] <jnthn> nom: class C { has $.x; method x {} }

[22:10] <p6eval> nom: OUTPUT«Package 'C' already has a method 'x'; did you mean to declare a multi-method?␤current instr.: 'nqp;Perl6;Metamodel;MethodContainer;add_method' pc 21437 (src/gen/perl6-metamodel.pir:0) (src/gen/Metamodel.pm:190)␤»

[22:10] <jnthn> No, it's true for classes too

[22:10] <masak> wtf?

[22:10] <masak> rakudo: class C { has $.x; method x {} }

[22:10] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤A method named 'x' already exists in class 'C'. It may have been supplied by a role.␤»

[22:10] <TimToady> S12:669 seems to imply that masak is correct, or at least speccish

[22:10] <jnthn> Anyway, just a fix to Attribute.compose

[22:10] <TimToady> it doesn't say you have to change $.x to $!x

[22:10] <masak> I... I just assumed.

[22:10] <jnthn> TimToady: Yeah, I'm agreeing. :)

[22:11] <masak> ok, so it needs fixing for both classes and roles. in both master and nom :P

[22:11] <jnthn> masak: no

[22:11] <jnthn> It needs fixing in Attribute.compose

[22:11] <masak> sure, ok.

[22:11] <jnthn> (Which fixes it for all package types.)

[22:12] * jnthn puts aside the repl bug for now to do other bits

[22:13] <dukeleto> tadzik: pong

[22:14] <dalek> specs: 61c34a1 | larry++ | S12-objects.pod:

[22:14] <dalek> specs: slightly clarify that $.x autogens at } if needed

[22:14] <dalek> specs: review: https://github.com/perl6/specs/commit/61c34a1c26

[22:14] <tadzik> dukeleto: ack. So, is your talk just about the usage, or you want to poke some panda philosophy/internals?

[22:15] <TimToady> where } is shorthand for "compose time"

[22:15] <dukeleto> tadzik: mostly basics. Just want to give people a very easy onramp to understand Perl 6 modules. Just want to show the basics of panda, module-starter and the structure of a Perl 6 module

[22:15] <masak> dukeleto++

[22:16] *** bitpat left
[22:16] * dukeleto is going to give a talk at the next PDX.pm that is an intro to Perl 6 modules

[22:16] <masak> \o/

[22:17] <tadzik> dukeleto: it's just that panda's user interface is pretty crappy and inconsistent and I'm planning a rework of that, but the 'panda install something' case shouldn't really change

[22:17] <jnthn> TimToady: It already does at }, just misses the "if needed" part

[22:17] <dukeleto> tadzik: yeah, i just want to show people how to install panda and then use panda to install perl 6 modules. Not going to do more than that

[22:17] <dukeleto> tadzik: is the sh bootstrap.sh part going to change soon?

[22:17] <dukeleto> tadzik: just want to show people how to install panda

[22:18] <tadzik> dukeleto: no, I think that'll stay

[22:18] <dukeleto> tadzik: goodly

[22:18] <dukeleto> tadzik: Module::Starter could use some love

[22:18] <tadzik> it's just that I tried to DRY as much as possible in panda's REPL and the batch interface, and as a result both suck :)

[22:19] <tadzik> dukeleto: the GITHUB_ issue, or something more?

[22:19] <dukeleto> tadzik: i would like it to at least generate stub module code, even if it is just: use v6; class FOO { };

[22:19] *** donri left
[22:19] <dukeleto> tadzik: module-starter should give people some basic tests, a stub .pm, and a README

[22:20] <tadzik> well, you never know if it's gonna be a class {}, module {} or just a collection of other modules, that's why I avoided that part

[22:20] <tadzik> but I'm fine with --create-stubs, --create-tests etc

[22:20] <tadzik> feel free to open issues for that, I may look at them in the morning

[22:20] <dukeleto> tadzik: ok, sounds good. 

[22:22] <TimToady> cleaning up the specmess for $! is gonna take more work than $/ did, sigh

[22:23] <TimToady> $! needs to be only the last failure, whether handled or not, and be completely decoupled from the notion of current inflight exception(s)

[22:24] <jnthn> nom: sub foo(*@x) { say @x.elems }; my @a = 1,2; my @b = 3,4; foo(@a, @b)

[22:24] <p6eval> nom: OUTPUT«4␤»

[22:24] <TimToady> or at least, mostly decoupled

[22:24] <jnthn> nom: sub foo(**@x) { say @x.elems }; my @a = 1,2; my @b = 3,4; foo(@a, @b)

[22:24] <p6eval> nom: OUTPUT«2␤»

[22:24] *** bluescreen10 joined
[22:25] <TimToady> nom: sub foo(**@x) { say @x[0].elems }; my @a = 1,2; my @b = 3,4; foo(@a, @b)

[22:25] <p6eval> nom: OUTPUT«2␤»

[22:25] <TimToady> nom: sub foo(**@x) { say @x[0][10] }; my @a = 1,2,4...*; my @b = 3,4; foo(@a, @b)

[22:25] <p6eval> nom: OUTPUT«1024␤»

[22:26] <TimToady> \o/

[22:27] <masak> TimToady: are attributes private to a role? can I use $!attr in a role and expect it to bind to a private attribute in a class?

[22:28] <TimToady> don't know what you mean by 'use' there

[22:29] <TimToady> do you mean declare?

[22:29] <masak> role R { method m { $!attr } }; class C does R { has $!attr }

[22:30] <TimToady> rakudo: role R { method m { $!attr } }; class C does R { has $!attr }

[22:30] <p6eval> rakudo 72d158:  ( no output )

[22:30] <masak> I know Rakudo does it.

[22:30] <TimToady> rakudo: role R { method m { $!attr } }; class C does R { has $!attr }; say 'alive'

[22:30] <p6eval> rakudo 72d158: OUTPUT«alive␤»

[22:30] <TimToady> niecza: role R { method m { $!attr } }; class C does R { has $!attr }; say 'alive'

[22:30] <masak> I'm wondering whether there is a long-term support for it.

[22:30] <p6eval> niecza v7-18-g240a9af: OUTPUT«===SORRY!===␤␤Action method trait_mod:does not yet implemented at /tmp/WQJ_TGV_RE line 1:␤------> { method m { $!attr } }; class C does R ⏏{ has $!attr }; say 'alive'␤␤Cannot use hash access on an object of type Str at /…

[22:31] <masak> I don't want to write code for the adventure game that will be obsolete in the next big refactor.

[22:31] <jnthn> masak: nom: role R { method m { $!attr } }; class C does R { has $!attr }

[22:31] <jnthn> er

[22:31] <jnthn> nom: role R { method m { $!attr } }; class C does R { has $!attr }

[22:31] <p6eval> nom: OUTPUT«Attribute $!attr not declared in role R at line 1, near " } }; clas"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[22:31] <TimToady> well, I'd argue that if the role does the 'has', it should probably be private to the role, but if the class does the 'has', it's pretty obvious to the role that it must be coming from elsewhere...

[22:31] <jnthn> nom is correct here

[22:31] <masak> jnthn: guess that answers my question, then.

[22:32] <masak> TimToady: I think so too.

[22:32] <masak> TimToady: that works much better with parametric roles.

[22:32] <jnthn> nom: role R { has $!attr; method m { $!attr } }; class C does R { has $!attr }

[22:32] <p6eval> nom: OUTPUT«Attribute '$!attr' already exists in the class 'C', but a role also wishes to compose it␤current instr.: '_block2612' pc 35151 (src/gen/perl6-metamodel.pir:10860) (src/gen/Metamodel.pm:1055)␤»

[22:32] <jnthn> That one we could discuss a bit. It's not going to be easy to fix at all.

[22:33] <masak> TimToady: waitwait. what does the thing after ', but' mean? :)

[22:33] <jnthn> (if we decide it's wrong, that is)

[22:33] <masak> TimToady: it's *not* obvious to the role.

[22:33] <masak> TimToady: the role isn't aware of the class until it's composed into it.

[22:33] <jnthn> But S14 IIRC has language to the effect of an attribute declaration in a role being as if it was in the class.

[22:34] <jnthn> In which case this one:

[22:34] <jnthn> nom: role R { has $!attr; method m { $!attr } }; class C does R { method foo() { $!attr } }

[22:34] <p6eval> nom: OUTPUT«Attribute $!attr not declared in class C at line 1, near " } }"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[22:34] <jnthn> Is probably dubious.

[22:34] <masak> aye.

[22:34] <jnthn> That one is fairly easy to fix.

[22:35] <jnthn> We just have to postpone our attribute usage checks until after the }

[22:35] <jnthn> When we really know all the attributes taht we have

[22:35] <jnthn> though of course that lets you write

[22:35] <jnthn> class Foo { method x { $!y }; has $!y } 

[22:35] <jnthn> :)

[22:35] <jnthn> Which nom currently complains about.

[22:36] <TimToady> I'm not too worried about that

[22:36] *** Kivutarrr left
[22:36] <jnthn> We'd still get the errors at compile time. 

[22:37] <jnthn> We could keep around enough to complain with the correct source position too.

[22:37] <TimToady> I was even entertaining the thought of allowing postdeclaration of lexicals in certain situations, to make it easier to write list comprehensions

[22:38] <masak> lue: just pushed a big commit to crypt. there's now a hidden door in the hill, which can be opened, connecting together the hill and the chamber. feel free to try it if you have time.

[22:38] <masak> TimToady: nooooo

[22:39] <masak> it's fine as it is, really.

[22:43] *** mtk left
[22:44] <jnthn> > class Foo { has $.x; method x { 42 } }; say Foo.new.x

[22:44] <jnthn> 42

[22:44] <masak> \o/

[22:44] <masak> jnthn++

[22:44] <TimToady> yayness

[22:45] <jnthn> nom: my @a = 1,2,3; my @b = 4,5,6; say @a X @b

[22:45] <p6eval> nom: OUTPUT«1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6␤»

[22:46] <jnthn> nom: my @a = 1,2,3; my @b = 4,5,6; my @c = @a X @b; say @c.elems

[22:46] <p6eval> nom: OUTPUT«18␤»

[22:46] <jnthn> nom: my @a = 1,2,3; my @b = 4,5,6; my @c := @a X @b; say @c.elems

[22:46] <p6eval> nom: OUTPUT«9␤»

[22:46] <jnthn> nom: my @a = 1,2,3; my @b = 4,5,6; my @c := @a X @b; say @c[0].WHAT

[22:46] <p6eval> nom: OUTPUT«Parcel()␤»

[22:46] <jnthn> \o/

[22:47] <jnthn> pmichaud++

[22:47] <jnthn> nom: my $a = [1,2,3]; my $b = [4,5,6]; my @c := $a X $b; say @c[0].WHAT

[22:47] <p6eval> nom: OUTPUT«Parcel()␤»

[22:47] <jnthn> nom: my $a = [1,2,3]; my $b = [4,5,6]; my @c := $a X $b; say @c.elems

[22:47] <p6eval> nom: OUTPUT«9␤»

[22:47] <jnthn> ah

[22:47] <jnthn> :(

[22:48] <jnthn> pmichaud: ^^ looks wrongish. I realized that X makes all permutations of stuff - which turns out to be exactly what we need to do auto-threading.

[22:48] <jnthn> pmichaud: but if I can't scalarize individual arguments and not have X flatten them out, it's probably not going to work

[22:49] <TimToady> I think we noticed that bug yesterday

[22:49] <jnthn> oh

[22:49] <jnthn> yeah, we did but I think with Z

[22:49] <TimToady> same difference

[22:49] <jnthn> Right

[22:49] <jnthn> Same underlying issue I expect

[22:50] *** whiteknight left
[22:50] <TimToady> nom: my @a = 1,2,3; my @b = 4,5,6; my @c = 7,8,9; say (@a Z @b Z @c).perl

[22:50] <p6eval> nom: OUTPUT«((1, 4, 7), (2, 5, 8), (3, 6, 9)).list␤»

[22:51] <TimToady> nom: my @a = 1,2,3; my @b = 4,5,6; my @c = 7,8,9; say (\@a Z \@b Z \@c).perl

[22:51] <p6eval> nom: OUTPUT«((1, 4, 7), (2, 5, 8), (3, 6, 9)).list␤»

[22:51] <TimToady> and that

[22:51] <jnthn> Anyway, junction auto-threading gets a bunch easier if I can just use X rather than re-invent it.

[22:51] *** estrabd left
[22:54] <jlaire> hm, is there a syntax for declaring in a role an attribute that must be provided by the host class?

[22:54] <TimToady> I kinda wish we could write: for ^10 -> $x X $x..^10 -> $y { say "$x $y" }

[22:54] <masak> TimToady: that's hakank++'s suggestion :)

[22:55] * masak vaguely feels that there should be a macro for that

[22:55] <jnthn> jlaire: No, but you couldn't access the attribute of the class anyway

[22:55] <jnthn> jlaire: There is a way for a role to require a method though

[22:55] <jlaire> jnthn: ok, method will do

[22:55] <jlaire> thanks

[22:57] <TimToady> well, if you just use the attribute, and it's never declared, I suspect it'll blow up at compose time at the latest

[22:57] <TimToady> that's kinda what we were talking about earlier

[22:57] <jlaire> yeah

[22:57] <jlaire> but that sounds very error-prone

[22:57] <TimToady> in what way?

[22:58] <masak> in a good way :)

[22:58] <jlaire> a typo could look like the class doesn't provide the attribute

[22:58] <TimToady> in which case it blows up at compile time

[22:58] <TimToady> which is good

[22:59] <TimToady> compose usually happens at compile time, anyhoo

[22:59] * jlaire might be thinking too much about scala traits...

[23:00] <TimToady> which apparently throw out the main point of Smalltalk traits...

[23:00] <jlaire> to see everything a role requires, I'll need to read everything in it

[23:00] <TimToady> no, that's the compiler's job :)

[23:00] <jlaire> an attribute declaration would make the requirement very explicit

[23:01] <jnthn> oh, wait, I don't think using X for auto-threading is even right...

[23:01] <jnthn> It own't get the nesting right

[23:01] <jnthn> d'oh.

[23:02] <TimToady> it's pretty easy to find a misspelled attribute if the compiler tells you its name

[23:02] <jnthn> jnthn-- should probably not hack when jetlagged :)

[23:02] <jnthn> Though I don't actually feel tired at all...

[23:03] <jlaire> maybe I'll start to like this, just need to write more Perl 6

[23:04] <jlaire> TimToady: what's the main point of Smalltalk traits?

[23:04] <jlaire> that scala throws away

[23:05] <TimToady> collision detection

[23:05] <jlaire> kk

[23:05] <TimToady> otherwise you might as well just use mixins

[23:06] <TimToady> sounds like scala is using mixins and calling the traits

[23:06] <TimToady> but maybe they aren't actually trying to follow smalltalk

[23:06] <TimToady> after all, we also use the word 'traits' for something else

[23:06] <jlaire> the word 'mixin' is also used in scala

[23:06] <jlaire> when talking about traits

[23:07] <jlaire> so the deviation might be intentional

[23:07] <TimToady> dinner &

[23:08] <jlaire> from Tour of Scala: "To define a class that can be used as a mixin we use the keyword trait." :)

[23:15] <jlaire> rakudo: my @xs = 1,2,3; say @xs[0 .. *]

[23:16] <p6eval> rakudo 72d158: OUTPUT«(timeout)»

[23:16] <jnthn> rakudo: my @xs = 1,2,3; say @xs[0 .. Inf]

[23:16] <p6eval> rakudo 72d158: OUTPUT«(timeout)»

[23:16] <jlaire> that should work, right?

[23:16] <jnthn> Probably not the Inf one. Maybe the * one

[23:16] <jnthn> rakudo: my @xs = 1,2,3; say @xs[*]

[23:16] <p6eval> rakudo 72d158: OUTPUT«123␤»

[23:16] <jlaire> S09 says @xs[*] and @xs[0 .. *] are the same thing

[23:17] <jnthn> nom: my @xs = 1,2,3; say @xs[*]

[23:17] <p6eval> nom: OUTPUT«1 2 3␤»

[23:17] <jnthn> nom: my @xs = 1,2,3; say @xs[0 .. *]

[23:17] <p6eval> nom: OUTPUT«1 2 3␤»

[23:17] *** wamba left
[23:17] <jnthn> ah, fixed in nom already :)

[23:17] <jnthn> pmichaud++

[23:17] <jlaire> nice :)

[23:18] <jlaire> nom: my @xs = 1,2,3; say @xs[1 .. *]

[23:18] <p6eval> nom: OUTPUT«2 3␤»

[23:19] *** tokuhirom joined
[23:20] <pmichaud> back again

[23:21] <sjohnson> back in black

[23:26] *** whiteknight joined
[23:28] *** orafu left
[23:29] *** orafu joined
[23:32] *** dorlamm joined
[23:34] <jlaire> nom: my @xs = 1,2,3; say @xs[4 .. *]

[23:34] <p6eval> nom: OUTPUT«␤»

[23:34] <jlaire> nom: my @xs = 1,2,3; say +@xs[4 .. *]

[23:34] <p6eval> nom: OUTPUT«0␤»

[23:35] <jlaire> nom: my @xs; say +(@xs[0], @xs[1 .. *])

[23:35] <p6eval> nom: OUTPUT«1␤»

[23:35] <jlaire> nom: my @xs = 0; say +(@xs[0], @xs[1 .. *])

[23:35] <p6eval> nom: OUTPUT«1␤»

[23:36] <sjohnson> nom noms

[23:42] *** colomon left
[23:46] *** cdarroch left
[23:54] *** molaf_ joined
[23:55] *** molaf__ left
