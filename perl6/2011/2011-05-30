[00:00] *** PacoLinux left
[00:03] *** cooper left
[00:03] *** cooper joined
[00:05] *** silug left
[00:05] *** PacoLinux joined
[00:05] *** silug joined
[00:07] *** lumi_ left
[00:17] *** lumi joined
[00:20] *** Moukeddar joined
[00:25] *** thou left
[00:35] *** Moukeddar left
[00:36] *** Moukeddar joined
[00:42] *** nymacro joined
[00:55] *** silug left
[00:55] *** silug joined
[00:57] *** fhelmberger joined
[01:00] *** jfried left
[01:01] *** noganex left
[01:06] *** noganex joined
[01:09] *** aindilis joined
[01:11] *** lumi left
[01:12] *** lumi joined
[01:22] *** silug left
[01:23] *** silug joined
[01:28] *** molaf_ left
[01:39] *** yinyin joined
[01:45] *** silug left
[01:47] *** Moukeddar left
[02:04] *** silent_h_ joined
[02:07] *** ethan joined
[02:08] <ethan> is moritz around? or anybody who has setup ilbot before

[02:10] *** donri left
[02:14] *** tokuhirom joined
[02:34] *** ymasory left
[02:34] *** ymasory joined
[02:39] *** silent_h_ left
[02:41] *** dayangkun left
[02:43] *** dukeleto left
[02:43] *** dukeleto joined
[02:55] *** woosley joined
[03:00] *** agentzh joined
[03:21] *** hudnix left
[03:21] *** cooper left
[03:46] *** Eevee left
[03:48] *** jaldhar_ left
[03:48] *** Eevee joined
[04:00] *** jaldhar joined
[04:08] *** Eevee left
[04:09] *** satyavvd joined
[04:10] *** Eevee joined
[04:14] *** satyavvd left
[04:15] *** Zapelius joined
[04:15] *** jaldhar left
[04:19] *** woosley left
[04:20] *** ymasory left
[04:20] *** satyavvd joined
[04:27] *** jaldhar joined
[04:30] *** jaldhar left
[04:31] *** jaldhar joined
[04:32] *** ymasory joined
[04:34] *** silug joined
[04:35] *** jaldhar left
[04:36] *** jaldhar joined
[04:43] *** silug left
[04:43] *** silug joined
[04:44] *** jaldhar left
[04:44] *** jaldhar joined
[04:53] *** thou joined
[04:55] *** satyavvd left
[04:56] *** satyavvd joined
[04:56] *** satyavvd left
[04:57] *** satyavvd joined
[04:58] *** woosley joined
[05:01] *** birdwindupbird joined
[05:09] *** ymasory left
[05:11] *** silug left
[05:18] *** jaldhar left
[05:20] *** jaldhar joined
[05:21] *** ymasory joined
[05:23] *** wamba joined
[05:45] *** koban` joined
[05:46] *** ymasory left
[05:52] *** dayangkun joined
[05:58] *** molaf joined
[05:59] *** wamba left
[06:01] *** wtw joined
[06:20] *** daxim joined
[06:24] <dalek> niecza: 5c3490f | sorear++ | / (9 files):

[06:24] <dalek> niecza: Move assign process, including LISTSTORE, off CPS

[06:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5c3490ffd4

[06:26] *** envi joined
[06:27] *** envi left
[06:27] *** envi_laptop joined
[06:29] *** am0c joined
[06:39] *** rhr left
[06:40] *** yahooooo left
[06:44] *** yahooooo joined
[06:46] *** amkrankruleuen left
[06:56] *** rhr joined
[07:03] *** Mowah joined
[07:03] *** amkrankruleuen joined
[07:03] *** jfried joined
[07:07] <daxim> http://www.reddit.com/r/programming/comments/hmtki/best_comment_about_unicode_support_in_programming/   # I'm currently at the part of the comments where someone makes a ridiculous font recommendation

[07:07] *** envi_laptop left
[07:12] * sorear wonders if there's a statistically nicer way to get microbenchmark data then "loop 1M times, divide by 1M"

[07:15] <sorear> like maybe run 100 loops of 10k times, then regressively fit the resulting times to a normal distribution and report the mean

[07:15] <sorear> wonder if that would work better.

[07:17] <sorear> sometime after v6 I'll port Benchmark to niecza

[07:18] <tadzik> sorear: how about making up Time::HiRes and making Benchmark portable?

[07:20] <sorear> maybe.

[07:20] <sorear> but I get in a very NIHy mood when I see Perl 6 code that obviously wasn't written to take advantage of Niecza's more efficient primitives: )

[07:23] *** icwiener joined
[07:24] * sorear decides that real-time benchmarking is stupid and looks to add some kind of clock() to Niecza

[07:27] *** Shozan joined
[07:34] <moritz> ethan: I'm around now

[07:36] * moritz back after a long weekedn with itnernets

[07:36] *** mj41 joined
[07:38] <moritz> for some reason the DSL splitter decided to say goodbye (at least that's my first diagnose)

[07:44] <yath> moritz: just put your dsl modem directly to the phone line

[07:44] <yath> moritz: it has a high-pass filter anyway

[07:44] <moritz> yath: but then I can't connect the phone

[07:45] <moritz> yath: and the plugs are incompatible

[07:45] <yath> moritz: man soldering iron :)

[07:45] *** jfried left
[07:45] <yath> NTBAs have low-pass filters too, for that matter.

[07:46] *** jfried joined
[07:50] *** amkrankruleuen left
[07:51] *** amkrankruleuen joined
[08:08] *** ethan left
[08:12] *** silug joined
[08:23] *** amkrankruleuen left
[08:24] *** cognominal_ left
[08:24] *** amkrankruleuen joined
[08:26] <dalek> niecza: f7b5a9c | sorear++ | lib/ (2 files):

[08:26] <dalek> niecza: Add &times

[08:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f7b5a9c75e

[08:26] <dalek> niecza: 94d21c4 | sorear++ | perf/std-20110528.pl6:

[08:26] <dalek> niecza: Use user time in benchmark script

[08:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/94d21c4375

[08:29] *** tzhs joined
[08:30] *** bacek joined
[08:41] *** dayangkun left
[08:45] *** am0c left
[08:53] *** jaldhar left
[08:54] *** dayangkun joined
[08:54] *** jaldhar joined
[08:58] *** am0c joined
[08:59] *** silug left
[09:03] *** thou left
[09:04] *** cognominal joined
[09:31] *** Trashlord joined
[09:33] *** woosley left
[09:34] <dalek> niecza: 0571dfc | sorear++ | lib/ (3 files):

[09:34] <dalek> niecza: Rewrite List.{pop,push,shift,unshift} at the C# level

[09:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0571dfc928

[09:34] <dalek> niecza: 2825023 | sorear++ | / (3 files):

[09:34] <dalek> niecza: push/pop/shift/unshift get inlined

[09:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2825023b15

[09:34] <dalek> niecza: c49e30c | sorear++ | / (3 files):

[09:34] <dalek> niecza: Make bitops inlinable

[09:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c49e30c299

[09:35] *** Mowah_ joined
[09:38] *** amkrankruleuen left
[09:39] *** amkrankruleuen joined
[09:42] *** TBA2 left
[09:43] *** TBA joined
[09:50] *** MayDaniel joined
[09:52] *** buubot_backup left
[09:53] *** bacek left
[09:54] *** amkrankruleuen left
[09:55] *** amkrankruleuen joined
[10:05] *** bacek joined
[10:08] *** MayDaniel left
[10:09] *** amkrankruleuen left
[10:11] *** amkrankruleuen joined
[10:17] *** dayangkun_ joined
[10:20] *** dayangkun left
[10:26] *** envi_laptop joined
[10:28] *** bacek left
[10:30] *** molaf left
[10:30] *** amkrankruleuen left
[10:45] *** amkrankruleuen joined
[10:59] *** pernatiy joined
[11:05] *** whiteknight joined
[11:10] *** cognominal_ joined
[11:12] *** ab5tract joined
[11:13] *** cognominal left
[11:17] *** zamolxes joined
[11:37] *** satyavvd left
[11:39] *** buubot_backup joined
[11:39] *** amkrankruleuen left
[11:42] *** wamba joined
[11:43] *** amkrankruleuen joined
[11:56] <jnthn> good afternoon, #perl6

[11:56] *** ethan_ joined
[11:57] *** silug joined
[11:58] <takadonet> morning all

[12:01] <pmichaud> jnthn: o/

[12:01] *** wamba left
[12:04] <jnthn>  o/ pmichaud 

[12:04] <jnthn> pmichaud: How's things? Any exciting happenings in my last few days away? :)

[12:04] <pmichaud> I've been working on list and other improvements

[12:05] <pmichaud> What's the plan or strategy for bringing nom to life?  (more)

[12:05] <pmichaud> I'm a little concerned that if we try to rip+patch the existing actions code, we'll be fighting a lot of cruft with lots of outdated assumptions

[12:06] *** hanekomu joined
[12:06] <jnthn> I'm reviewing quite a lot of the actions as I go.

[12:06] <jnthn> I don't want to toss it and start again.

[12:07] <jnthn> There's a lot of good knowledge encoded in the current ones that I'd hate to lose.

[12:07] <pmichaud> there's a lot of ugliness there too, though.  However, I'm going to let this one be your call, so we'll go with fixing the existing stuff.

[12:08] <jnthn> Also I'm trying to keep the scope of the current branch relatively limited, to the degree that a do-over of meta-model, packages handling, multi-dispatch and literals can be limited. :)

[12:08] <pmichaud> I don't quite understand that

[12:08] <jnthn> A lot of ugliness has been in symbol installation, which is decidedly les ugly now.

[12:09] <jnthn> pmichaud: I don't want this to drag on for months on end.

[12:09] <pmichaud> I agree with that, fully.

[12:09] <pmichaud> I don't understand "scope of current branch relatively limited"

[12:09] <pmichaud> do you expect to merge with master again at some point?

[12:09] <jnthn> I didn't form an expectation yet, but I am trying to keep that as a possibility.

[12:10] <jnthn> Or at least track changes in master best I can so we don't have to re-do stuff.

[12:10] <jnthn> If I had to guess though, I suspect we'll take a similar approach as we did with ng.

[12:10] <jnthn> nom becomes master, master becomes beta, or something. :)

[12:10] <pmichaud> well, with ng we "started over"

[12:11] <jnthn> Yeah. I've tried to avoid "starting over" this time. :)

[12:11] <jnthn> Apart from the bits that I intended to start over with.

[12:11] <pmichaud> I'm worried it's going to be really hard to track master

[12:11] <jnthn> When the cost of doing so comes to exceed the benefits of doing so, it's easy to stop.

[12:12] <pmichaud> ...easy to stop?

[12:12] <pmichaud> meaning, we merge with master at that point even if everything breaks?

[12:13] <jnthn> No, I mean if trying to bring changes being done in master into nom - which I've done to some extent so far - becomes too hard, we needn't keep doing so.

[12:13] <jnthn> Or at least, not in the "merge master into nom" sense.

[12:13] <jnthn> Guess some could be cherrypicked.

[12:14] <jnthn> Really, I think we should wait a little bit and see.

[12:14] <pmichaud> okay

[12:14] <pmichaud> I'm guessing I don't want to have to redevelop the fixes I'm working on

[12:14] <jnthn> OK, which bits are you working on? Lists?

[12:14] <pmichaud> nom isn't far enough along where I can make them there, and I don't want to put them in master just to have to redevelop them again later

[12:15] <pmichaud> afk for 5 mins

[12:15] <jnthn> k

[12:18] <pmichaud> back

[12:18] <pmichaud> working on Lists, but also working on fixing some of the calling/return value bits

[12:18] <pmichaud> for example, I worked on fixing the 'take' bug yesterday

[12:18] <jnthn> ah, nice

[12:19] <pmichaud> (almost have it fixed entirely, but there's a trans.t bug somewhere that stops me from completing the fix)

[12:19] <jnthn> I wanted to ask you a bit aobut lists.

[12:19] <jnthn> At the moment I think we still rely there - probably more than anywhere else - on dropping Perl 6 methods into e.g. RPA.

[12:20] <jnthn> Of note, iirc, Parcel was a "subclass" of the RPA PMC.

[12:21] <pmichaud> that's more out of performance than any particular design choice

[12:21] <jnthn> There's no PMC inheritance in 6model, and we should probably not re-create a mechanism to pollute Parrot namespaces.

[12:21] <pmichaud> what does 6model use for basic arrays?

[12:22] <jnthn> Well, we have some choices here.

[12:22] <jnthn> 6model can do two things with parrot v-tables

[12:22] <jnthn> 1) Allow an override of them, which is a HLL method.

[12:22] <jnthn> 2) Delegate to the same v-table method on a particular attribute.

[12:23] <jnthn> With (2) you basically get equivalent - well, better - performance as you did with PMC inheritance before.

[12:23] <jnthn> The other thing we could do - and will need to at some point - is to have a custom representation, which we use for lists.

[12:23] <jnthn> We'll need that to do things like packed arrays.

[12:23] <jnthn> But there's no need to do that refactor now.

[12:23] <pmichaud> we need to avoid vtables as much as we can, I think.

[12:24] <jnthn> Well, the alternative is our own array storage representation and some ops to work with doing stuff with that repr.

[12:24] <jnthn> That's the nqpclr approach.

[12:24] <pmichaud> did you see whiteknight++'s article on the cost of vtables?

[12:25] <jnthn> think so...let's check we're talking about the same one...

[12:25] <whiteknight> http://whiteknight.github.com/2011/05/10/timings_vtable_overrides.html

[12:25] <pmichaud> yes, that one

[12:25] <jnthn> http://whiteknight.github.com/2011/05/10/timings_vtable_overrides.html

[12:26] <jnthn> Yeah, Parrot's vtable override handling is insanely slow.

[12:26] <pmichaud> I profiled rakudo to see how much we're hitting the vtable interface -- turns out it's much less than I had expected, at least for the benchmarks I ran

[12:26] <jnthn> 6model is way smarter.

[12:26] <pmichaud> whiteknight: you might also be interested to know that I switched Rakudo to have its own qsort (hand-coded PIR) instead of using the builtin sort, and there was almost no performance increase

[12:26] <jnthn> It makes a PMC** which maps to the vtable slots (yes, C-level array) and looking up a v-table override is a pointer follow.

[12:27] <whiteknight> pmichaud: oh, that's disappointing. was there a performance decrease?

[12:27] <jnthn> The meta-object is responsible for making a flattend hash which 6model then turns into this efficient lookup.

[12:28] *** noganex left
[12:28] <jnthn> 6model also manually contructs the CallContext.

[12:28] <pmichaud> whiteknight: slight increase in performance

[12:28] <jnthn> (yes, using the v-table API, nothing nasty)

[12:29] <pmichaud> back in 2

[12:29] <jnthn> Anyway, do profile, but the cost of using v-table overrides with 6model is likely to be vastly lower than the cost with Parrot's Class/Object implementation.

[12:29] <whiteknight> pmichaud: okay, that's better than nothing. I've been doing some benchmarks where I've been seeing pretty consistent improvements

[12:29] <whiteknight> on the order of 20-40%, depending on the shape of the input array

[12:29] <whiteknight> the higher end of that range was with a hybrid qsort+insertion sort I put together

[12:30] <pmichaud> jnthn: so, back to nom and Parcel

[12:30] *** silug left
[12:30] <pmichaud> Parcel wants to be a very simple list of elements

[12:31] <pmichaud> it probably doesn't want to be a List, as that's a high-level construct

[12:32] <jnthn> pmichaud: At the moment, Parcel isa RPA?

[12:32] <pmichaud> at the moment, yes

[12:32] <pmichaud> doesn't have to be... but having it as an RPA was convenient because that's also what :slurpy args become

[12:32] <jnthn> If Parcel has-a RPA and delegation is as cheap as inheritance, is that a good enough way forward for now?

[12:33] <jnthn> oh. 

[12:33] *** noganex joined
[12:33] <jnthn> We'd need a cheap way to go RPA => Parcel,then?

[12:33] <pmichaud> don't know

[12:33] <pmichaud> maybe

[12:33] <pmichaud> this is partially what I mean about a lot of assumptions get thrown out

[12:33] <jnthn> :)

[12:33] <pmichaud> how many times are we going to be using :slurpy, for example?

[12:33] <pmichaud> I'm expecting "not very much"

[12:34] <jnthn> :slurpy as in, at PIR level?

[12:34] <pmichaud> right

[12:34] <jnthn> Near enough not at all. :)

[12:34] <pmichaud> exactly

[12:34] *** agentzh left
[12:34] <jnthn> There shouldn't really be any PIR (other than Q:PIR and pir::foo) left after nom.

[12:35] <pmichaud> so, if we don't have a lot of :slurpy, we don't have a lot of need for RPA => Parcel

[12:35] <jnthn> Right.

[12:35] <pmichaud> but it also means a complete rewrite of the List code

[12:35] <jnthn> Really, *@foo is the place we'll need to do the construction of slurpy and that's down in the binder.

[12:36] <jnthn> What bit causes the complete re-write?

[12:36] <pmichaud> List depends on RPA also

[12:36] <pmichaud> in a has-a sense

[12:36] <jnthn> Depends on having something with the external interface of an RPA?

[12:36] <pmichaud> capabilities more than interface

[12:36] <jnthn> What capabilities, specifically?

[12:37] <jnthn> as in, push, pop, indexing...

[12:37] <pmichaud> the ability to maintain has-a arrays that can grow and shrink, mostly

[12:38] <jnthn> Does List has-a RPA(s) today?

[12:38] <pmichaud> yes

[12:38] <jnthn> Or has-a Parcel today?

[12:38] <jnthn> OK.

[12:38] <pmichaud> has-a RPA

[12:38] <pmichaud> (which can also be a Parcel)

[12:38] <pmichaud> (since Parcel isa RPA)

[12:38] <pmichaud> but mostly List just has-a RPA

[12:38] <jnthn> We could still do that.

[12:38] <pmichaud> In some sense I'd rather get rid of that

[12:39] <pmichaud> might not be possible at present, though

[12:39] <jnthn> Maybe best to try not to do anything too drastic with lists in nom.

[12:40] <pmichaud> which brings me back to my earlier question, then :)

[12:40] <pmichaud> because it means, well, I'm kinda blocked.

[12:40] <jnthn> Blocked because you don't want to have to re-do work in nom?

[12:41] <pmichaud> working on lists in master isn't really helpful

[12:41] <pmichaud> (more)

[12:41] <pmichaud> one thing I've discovered in all of this is that the underlying list and container model has huge ramifications for the entire code base (more)

[12:41] <pmichaud> having done it at least three or four times now

[12:42] <pmichaud> I'd like to think that we have the list api pretty close to right, and we probably do

[12:42] <jnthn> Yes, it feels like people complain relatively little about the semantics of Rakudo's list implementation.

[12:43] <jnthn> Especially compared to previous APIs. :)

[12:43] <pmichaud> but since nom has some pretty different underlying assumptions, especially with respect to attribute handling and efficiency of calls, I'm not sure that the existing List code is at all appropriate

[12:43] <jnthn> OK.

[12:43] <jnthn> I'm not unwilling to have us do a container and list re-work in nom.

[12:44] <pmichaud> I guess my question is partially -- how/when will we know if nom can work with the existing List implementation?

[12:44] <pmichaud> (and Parcel)

[12:44] *** bacek joined
[12:44] <pmichaud> is it likely to work soon, or will nom be blocked until that gets redone?

[12:45] <pmichaud> where "redone" can mean either "rewritten" or "patched to work in nom"

[12:46] <jnthn> Well, we'll need list handling pretty early on.

[12:46] <jnthn> So I wasn't planning on it being left until much further down the line.

[12:46] <pmichaud> right

[12:46] <pmichaud> I'm worried we may get caught in a deadlock (more)

[12:46] <jnthn> My next two items are putting back primitives - literals and multi-dispatch.

[12:47] *** donri joined
[12:47] *** hudnix joined
[12:48] <pmichaud> because the current literals code (which also needs some substantial reworking) depends a bit on lists

[12:48] <pmichaud> might not be that much, though

[12:48] <jnthn> I was mostly just going to put back Int and Str just to get a start on it

[12:48] <jnthn> And then put multi-dispatch back

[12:48] *** arnsholt_ is now known as arnsholt

[12:48] <jnthn> And then it's a bit easier for folks to jump in.

[12:49] <pmichaud> ...as long as they don't need parcels or lists :)

[12:49] <jnthn> Right.

[12:49] <pmichaud> I think nom may block there.

[12:49] <jnthn> OK.

[12:49] <jnthn> So you're thinking parcels and lists need a priority bump, or?

[12:50] <pmichaud> well, even parcels and lists need multidispatch and literals first

[12:50] <jnthn> Yes, that was my feeling too :)

[12:50] <jnthn> The other question is what we want to do about containers generally.

[12:50] <pmichaud> I'm trying to get a sense of when it makes sense to start hacking on nom

[12:51] <pmichaud> (more)

[12:51] *** dayangkun_ left
[12:51] <pmichaud> much of the overall Actions.pm code from master is somewhat hard to follow at the moment.  I'm hoping a bunch of it gets ripped out.

[12:51] <pmichaud> or at least drastically simplified

[12:52] <pmichaud> maybe that's a false hope, or you're thinking it doesn't change that much?

[12:53] <jnthn> nom has more of a three-way split than the two-way one in master.

[12:53] <jnthn> grammar, actions, symbol table

[12:53] <jnthn> Also, it doesn't maintain compile-time notions of packages and signatures.

[12:53] <jnthn> Instead, those are unified with the runtime ones.

[12:54] <jnthn> IMHO, new nqp has less cruft in actions related to OO stuff.

[12:54] <pmichaud> as it should :-)

[12:54] <jnthn> So far nom feels nicer too.

[12:55] <jnthn> $*ST.pkg_add_method($*PACKAGE, 'add_method', $name, $code_obj); # how adding a method looks in the actions, for example.

[12:55] <pmichaud> $*PACKAGE ?

[12:55] <pmichaud> for a method?

[12:55] <jnthn> The current meta-object.

[12:55] <pmichaud> ah

[12:55] <jnthn> Well, it could be a role, or a grammar.

[12:56] <jnthn> Every package declarator type populates $*PACKAGE.

[12:56] <pmichaud> okay

[12:56] <jnthn> Looks up in %*HOW to find the correct type of meta-object.

[12:56] <jnthn> So it's extensible. :)

[12:56] <pmichaud> I understand the reasoning now... the name still is jarring

[12:57] <pmichaud> if only because it's likely to confuse other p5 folks :)

[12:57] <jnthn> oh, I mis-spoke

[12:57] <jnthn> The current *type object*. :)

[12:57] <pmichaud> right

[12:57] <pmichaud> the name is jarring :)

[12:57] <jnthn> $*PACKAGE.HOW is the current meta-object :)

[12:57] <jnthn> Well, I didn't have a better word to hand that covers package/module/role/class/grammar etc :)

[12:58] <jnthn> (yes, there's a $*PACKAGE for package too, but it doesn't know how to do...well...anything much more than have a name...)

[12:58] *** Moukeddar joined
[12:59] <jnthn> "can be have a method" is just a .can check on $*PACKAGE.HOW

[12:59] <jnthn> Anyway, no objections to name improvements. I just don't have a better one off hand.

[12:59] <jnthn> And also it maps to the runtime notion of $?PACKAGE quite neatly.

[13:00] <pmichaud> no problem, $*PACKAGE can work for now

[13:00] <jnthn> Oh, another fun circularity is gonna be Bool... :|

[13:01] <pmichaud> okay, let's see if I can summarize a bit

[13:01] <jnthn> If I can throw in some timeline guesses first...

[13:02] <jnthn> My week is going to be pretty good for Rakudo hacking.

[13:02] <jnthn> I expect to have basic work on literals and multi-dispatch handled by end of Wednesday.

[13:03] <jnthn> At that point container and listy stuff are kinda next on the roadmap.

[13:04] <pmichaud> My week is also looking very good for Rakudo hacking

[13:04] <pmichaud> it will either be very good or Very Bad.

[13:05] <pmichaud> I think that anything I might do with Lists and call/return stuff in master is unlikely to merge to nom

[13:05] <pmichaud> indeed, anything "substantial" I work on in master would feel very unlikely to merge to nom

[13:05] <pmichaud> (under the theory that a lot of the non-substantial stuff has been taken care of already in master :-)

[13:06] <pmichaud> so, I'm eager to push nom along however I can best help

[13:06] <pmichaud> I can work on literals... but there's not much that one can do with literals until, e.g., 'say' works.

[13:06] <jnthn> I was pondering just adding a dummy say until we get IO back in place.

[13:07] <pmichaud> that'd be fine... I'm not sure what the dummy say should look like

[13:07] <pmichaud> but even then things don't really work until we have  Str

[13:07] <jnthn> sub say($x) { pir::say($x) } # very dumb-y :)

[13:07] <pmichaud> er, .Str

[13:07] <jnthn> Oh heh, but...yeah :)

[13:07] <jnthn> Hm :)

[13:08] <jnthn> OK, let me try and get Str and Int back and try and put some kinda dummy say in place.

[13:08] <pmichaud> and fixing .Str/.Stringy is another thing that needs to be done, too

[13:08] <jnthn> Ah, yes...that also.

[13:08] <pmichaud> because those are wrong in master

[13:08] <jnthn> Yeah

[13:08] <jnthn> say actually wants .Str though, iircy.

[13:08] <jnthn> *iirc.

[13:08] <moritz> rakudo: say Buf ~~ Stringy

[13:08] <pmichaud> and .Str is supposed to be in terms of .Stringy

[13:08] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[13:08] <jnthn> Whereas e.g. prefix:<~> wants .Stringy

[13:09] <pmichaud> or maybe I have those backwards... I'd have to review

[13:09] <pmichaud> regardless, the current vtable interface is wrong/backwards there

[13:09] <jnthn> pmichaud: *nod*

[13:09] <moritz> agreed

[13:09] <moritz> Int.Str should *not* go through a vtable

[13:09] <moritz> in fact any type coercions within Perl 6 should avoid the vtables

[13:09] <jnthn> moritz: +1

[13:09] <jnthn> vtables are just for the outside world.

[13:09] <pmichaud> agreed fully

[13:10] <moritz> vtables should only be... right. HLL interop, nothing more

[13:10] <pmichaud> we do have a problem there, though, that vtables are for our inside world as well, whether we like it or not

[13:10] <pmichaud> $I0 = $P0   # vtable

[13:10] <pmichaud> if $P0 goto label  # vtable

[13:10] <pmichaud> $S0 = $P0   # vtable

[13:11] <jnthn> Sadly, $I0 = $P0 and $S0 = $P0 are ambiguous in intent.

[13:11] <pmichaud> pir::add__NNN($P0, $P1)    # vtable

[13:11] <jnthn> We probably want to say that those vtables are for coercion, not unboxing.

[13:12] *** daniel-s joined
[13:12] <pmichaud> right now we don't pay a performance penalty on vtables there because our Int/Num/Str/etc objects are isa-Integer, isa-Float, isa-String

[13:12] <pmichaud> what happens in the 6model version?

[13:13] <jnthn> pmichaud: A REPR may know how to box/unbox natives.

[13:13] <pmichaud> jnthn: but does it do it using a PIR sub or in C?

[13:14] <jnthn> The REPR itself is written in C. REPRs are our "glue" to the VM, whatever the VM may be.

[13:14] <jnthn> (e.g. so the REPR is written in C# for nqpclr)

[13:14] <jnthn> e/s.g.//

[13:14] <jnthn> gah :)

[13:14] <pmichaud> okay.  I guess I need to see what Int looks like in nom.

[13:15] <jnthn> class Int { has int $!value is box_target; } # for now, until we get a repr that can handle bigint.

[13:15] <jnthn> Note that there's a (already resolved) circularity there since int ~~ Int. :)

[13:15] <pmichaud> assuming that $P0 is an Int, how does $I0 = $P0 get resolved?

[13:16] <jnthn> Depends

[13:16] <jnthn> (more)

[13:16] *** daniel-s left
[13:16] <jnthn> If you mean "take the thingy on the right and get a native integer somehow" then you'd do $I0 = $P0, which would call the v-table override which would presumably be also Mu.int.

[13:17] <jnthn> If you already did a multi-dispatch and you know you have an Int, then it's pir::repr_unbox_int__IP($P0)

[13:17] <jnthn> Which doesn't do anything v-table-ish but goes straight to the REPR.

[13:17] <jnthn> This is what I mean by reifying the difference between coercion and box/unbox.

[13:17] <pmichaud> wait

[13:18] <pmichaud> how does   pir::repr_unbox_int__IP know to look in $!value ?

[13:18] <jnthn> has int $!value is box_target; 

[13:18] <jnthn> (the is box_target)

[13:19] <jnthn> Note that under the hood, the REPR introspects and works out the offset once and stashes it away.

[13:19] <jnthn> So getting the int value out is cheap.

[13:19] <pmichaud> if you know you have an Int

[13:19] *** MayDaniel joined
[13:19] <jnthn> Yes. In multi infix:<+>(Int, Int) { ... } then you know you have an Int

[13:19] <pmichaud> if you have a Mu, getting the int value out via the vtable is expensive

[13:20] <pmichaud> (because vtables in PIR are expensive)

[13:20] <jnthn> Right, but all the built-in operators are multi-dispatch, so by the time we hit them we know what we have.

[13:20] <pmichaud> so we need to re-do all of the builtin operators, too :)

[13:21] <pmichaud> (granted, we can do them piecemeal)

[13:21] <jnthn> Yeah but it should be quite mechanical.

[13:22] <pmichaud> I'm not certain of that, but I'll go with it for now

[13:22] <pmichaud> this is another place where the builtins got optimized somewhat due to the performance characteristics of the model we were (but are no longer) under

[13:22] <pmichaud> so a mechanical translation could be very wrong.

[13:22] <jnthn> True :)

[13:23] <jnthn> I'm happy that the new model will be faster in this area.

[13:23] <jnthn> s/happy/confident/

[13:23] * moritz is happy that jnthn is confident

[13:23] <jnthn> For one because it's a lot less levels of indirection

[13:23] <pmichaud> oh, I'm sure it will too.... if we can avoid doing things that are very suboptimal

[13:24] <jnthn> Today our Int is an Object PMC + an RPA for attributes + an Integer PMC.

[13:24] <pmichaud> I guess I've just been discouraged by the amount of suboptimal code I've already found in master

[13:24] <jnthn> *nod*

[13:24] <pmichaud> I'm worried we'll have even more in nom

[13:24] <pmichaud> especially if we're just bringing master code as-is into nom

[13:25] <pmichaud> okay, well, let's not ponder that much more for now (more)

[13:25] <jnthn> Aye, but nom is the start of the next journey as much as it is the end of the current one. It'll be what enables a bunch more optimizations that we just can't really code towards today.

[13:26] <pmichaud> I agree that it enables much more optimizations

[13:26] <pmichaud> I'mworried we may miss them because of code that depends on outdated assumptions

[13:26] <jnthn> And the cost-model is going to be different. Today type annotations are more costly than they are helpful. The work in nom will let us start using them to be efficient.

[13:27] <jnthn> Ah, OK. That I can understand as a risk, yes.

[13:27] <pmichaud> ultimately we kinda need to review everything

[13:27] <jnthn> I'm not sure what we can do about it other than very careful code review and trying to document the cost model for @other.

[13:28] <jnthn> Well, and each other. I'm not sure I fully grasp the cost model for all of the list stuff, for example. ;)

[13:28] *** never_ left
[13:28] <pmichaud> well, none of us do yet, I think :)

[13:29] <pmichaud> master's list implementation was "the first Perl 6 list implementation that actually worked"

[13:29] <pmichaud> cost was less important than "works"

[13:29] <pmichaud> (and the list implementation was done on a time deadline, too :)

[13:30] <pmichaud> so, I'm looking forward to fixing it in nom

[13:31] <jnthn> I think a lot of things in master were in that "needs to work" boat. :)

[13:32] <pmichaud> okay, I think I can summarize a short-term plan

[13:32] <pmichaud> oh, one question before that -- do you mind if I refactor the nqp and nom build subsystems?

[13:33] <pmichaud> mainly I'm thinking of removing --gen-parrot from nom, so that it just has --gen-nqp

[13:33] <pmichaud> and we eliminate PARROT_REVISION from nom, it just has a NQP_REVISION

[13:33] <pmichaud> (and NQP_REVISION keeps track of the PARROT_REVISION dependency)

[13:34] <jnthn> Not only do I not mind, I very much encourage that.

[13:34] *** yinyin left
[13:34] <pmichaud> okay

[13:34] <pmichaud> so, here's my short-term guess at a plan, pending available tuits

[13:34] <jnthn> I didn't build the solution I wanted there, I built the thing that unblocked me and trusted that those who are skilled at such things would jump in. :)

[13:34] <pmichaud> for the next 2-3 days, I think I'll work on build system refactor

[13:35] <pmichaud> mainly I want to improve the download+install state of nqp and nom

[13:35] *** ab5tract left
[13:35] <pmichaud> then, whatever time is left outside of that I may try building an example language in nqp... probably try to port lolcode to 6model

[13:36] <pmichaud> that will help me to understand 6model and how things work in the new nqp for building compilers without having to try to grok it in nom

[13:36] <jnthn> In terms of building compilers, little's changed besides "you can do it all in NQP now" and "add some use statements" :)

[13:36] <jnthn> Well

[13:36] <jnthn> separate compilation will catch you some more too :)

[13:37] <jnthn> It only gets exciting once you hit 6model :)

[13:37] <jnthn> (where exciting = shiny new stuff)

[13:37] <jnthn> I need to do a heck of a lot of work on docs there.

[13:37] <pmichaud> well, I'd expect it's a little more changed if I have custom types instead of using Parrot's builtins, yes?

[13:37] <pmichaud> i.e., where lolcode used Integer/Float  I'm guessing I'll have things that are   has int $!value ....

[13:38] <jnthn> Yes, you could do that. :)

[13:38] <jnthn> Note that NQP itself still uses Integer/Float though.

[13:38] <jnthn> I didn't take that bit on. Coulda done.

[13:38] <pmichaud> I'm fine with NQP itself still using Integer/Float

[13:38] <jnthn> I'm fine with it until the point it makes NQP's cross-vmness an issue.

[13:39] <pmichaud> but in order to build a reasonable Perl 6 implementation of List, I feel like I need to understand the low-level primitives pretty well

[13:39] <jnthn> Yes, agree.

[13:39] <jnthn> There are some things to read.

[13:39] <pmichaud> we could do that by me being able to watch them be built up in nom (in a "start-from-scratch review-all-the-code-as-we-rebuild it approach"), or I can learn it by writing a separate language from scratch

[13:39] <pmichaud> the latter seems more productive at the moment

[13:39] <jnthn> Yes, and exampels are good. :)

[13:40] <jnthn> https://github.com/jnthn/6model/blob/master/overview.pod and sixmodelobject.h are worth reading.

[13:40] <pmichaud> well, you're likely to get a lot of questions from me

[13:40] <jnthn> That's good.

[13:40] <jnthn> Hm

[13:40] <jnthn> I/we should use this as an opportunity to document stuff more. :)

[13:40] <pmichaud> yes, I'm thinking that as well.

[13:40] <pmichaud> as well as a new nqp tutorial

[13:41] <jnthn> So that we get at least an FAQ or something out.

[13:41] <pmichaud> anyway, I can work on those while you work on literals and multidispatch in nom

[13:41] <jnthn> OK, sounds like a plan.

[13:41] <pmichaud> when you have things far enough along that we can do simple say of literal values, perhaps I can jump in at that point and we can work on containers

[13:42] <jnthn> +1

[13:42] <jnthn> I'm going to dig in on that very soon :)

[13:42] <pmichaud> I still fear we're going to have a long slog ripping things out and fixing them

[13:42] <pmichaud> but we'll try it and see.

[13:44] <jnthn> Yes, it's a balance of getting improvements into our user's hands soon, but also making sure we don't take shortcuts to do so that make ourselves more problems in the near future.

[13:44] <ruoso> btw... I was considering porting 6model to p5 guts... 

[13:44] <ruoso> but I kinda didn't find where to start...

[13:46] <ruoso> the bootstrapping path starts by the 6model lower-level stuff, right? which would be the "runtime" folder in the dotnet implementation, right?

[13:47] <jnthn> ruoso: Yes.

[13:48] <jnthn> ruoso: That probably needs some updating with stuff I figgered out while working on the nqp/6model on Parrot stuff but it's probably mostly right.

[13:49] <ruoso> hmm... ok... is there some guide through the different parts of it?

[13:49] <ruoso> (I can look on the nqp/6model instead of dotnet)

[13:50] *** wtw left
[13:51] <jnthn> ruoso: Not a good one. :( I need to write it really soon. https://github.com/jnthn/6model/blob/master/overview.pod is an overview.

[13:51] <ruoso> yeah... I've read that one...

[13:51] * ruoso keeps diving into code then...

[13:52] *** hudnix left
[13:53] *** Limbic_Region joined
[13:54] *** Shozan left
[13:54] *** jaldhar left
[13:55] *** jaldhar joined
[13:55] *** jaldhar left
[13:55] *** jaldhar joined
[13:56] <pmichaud> oh, I'll also go ahead and prototype some list fixes in master when TimToady++ responds to my questions from yesterday :)

[13:57] <pmichaud> (so that we can pin down the autotrim behavior we want)

[13:58] <pmichaud> that's a case where I don't mind working in master because it's mostly testing new capability as opposed to major code refactors

[13:59] <Limbic_Region> . o O  ( we don't need no stinking revision control )

[13:59] <pmichaud> afk for a bit

[13:59] <Limbic_Region> pmichaud, take your time and take a whole byte

[14:00] <ruoso> on a different subject, how is the support for feeds this days?>

[14:02] <pmichaud> rakudo:  <I think feeds are working> ==> sort ==> say

[14:02] <p6eval> rakudo 048573: OUTPUT«Iarefeedsthinkworking␤»

[14:02] <pmichaud> probably not completely, but there's some basic support there

[14:02] <wolverian> rakudo: say <== <foo bar> ==> say

[14:02] <p6eval> rakudo 048573: OUTPUT«==<foobar␤Bool::True␤»

[14:03] <wolverian> I don't know if that's even supposed to be sensible. :)

[14:03] <pmichaud> I don't know if <== works... it's currently a misparse

[14:03] <ruoso> any paralellization already?

[14:03] <moritz> nope

[14:03] <pmichaud> that's one of the things I'd like to move towards in nom

[14:03] <ruoso> is it implemented in terms of iterators already? or are they cheating?

[14:03] <moritz> parrot segfaults when you launch a second thread while inside a HLL

[14:03] <pmichaud> I think we should simulate parallelization even if we don't implement it

[14:04] <pmichaud> e.g., hypers should work out-of-sequence, etc.

[14:04] <pmichaud> feeds are implemented in terms of iterators -- at least to the extent that they fall out naturally from lazy slurpy parameter semantics

[14:04] <ruoso> pmichaud: does parrot support co-routines, doesn't it>

[14:04] <ruoso> ?

[14:04] <moritz> continuations even

[14:05] <moritz> we use those for gather/take

[14:05] <pmichaud> parrot has coroutines, yes.  but they carry a lot of baggage

[14:05] <ruoso> ok... and iterators can block, right?

[14:05] <pmichaud> suspend, yes.

[14:05] <pmichaud> they're lazy

[14:05] <ruoso> (do we have an API for something like EWOULDBLOCK?)

[14:06] <pmichaud> an IO iterator would block, yes.

[14:06] <ruoso> but do we have how to raise, say, a control exception when they would block?

[14:06] <pmichaud> no, we don't have that

[14:06] <pmichaud> not sure that's even specced

[14:07] * moritz doesn't think so

[14:10] <ruoso> here is what I had in mind...

[14:11] <ruoso> if we had all blocking operations raising control exceptions, we could implement a POE-like model for iterators

[14:12] <ruoso> what I initially thought on that subject was that the feed operator would always start two coroutines and a transmission buffer

[14:14] <ruoso> then if we had something like a EWOULDBLOCK control exception, we could use it to control the states of the coroutines

[14:17] *** Qerub left
[14:18] <ruoso> but this would mean we need a co-routine scheduler...

[14:19] <ruoso> and if parrot supports threads fully, it would mean the co-routine scheduler would be able to distribute the tasks accross different threads...

[14:20] *** wamba joined
[14:22] *** Mowah_ left
[14:22] <moritz> parrot supporting threads is a fairytale

[14:24] *** Moukeddar_ joined
[14:25] *** REPLeffect left
[14:26] *** Moukeddar left
[14:27] *** am0c left
[14:30] <ruoso> moritz: well, in that case, the co-routine scheduler would do the "simulation" pmichaud was talking about

[14:34] <pmichaud> Linux 3.0-rc1:  Proof that version numbers have become meaningless with respect to "major revisions":  http://permalink.gmane.org/gmane.linux.kernel/1147415

[14:36] <daxim> some background:  http://h-online.com/-1248294

[14:38] <moritz> ah well, there have been long discussions about the difference in major version number increases between chrome and firefox

[14:39] <pmichaud> after RedHat (not EL) 7.1 came out, I was pretty well convinced that major version numbers mean nothing beyond marketing.

[14:40] <pmichaud> RedHat 6.1 -> RedHat 7.0    trivial upgrade

[14:40] <pmichaud> RedHat 7.0 -> RedHat 7.1    OMGWTF

[14:41] <moritz> so, lots of examples of meaningless version numbers

[14:42] * moritz thinks we should rename Perl 6 to perl.2011

[14:42] <arnsholt> That'd give the folks over on slashdot something to rage about, at least =)

[14:42] <pmichaud> then we'd only be 989 integers behind Python 3000

[14:42] <moritz> p6v2011.05

[14:44] *** Moukeddar__ joined
[14:47] <ruoso> If I was to experiment with a "co-routine scheduler", would it be required to be done in Parrot level? or is it possible to do in rakudo-level?

[14:48] *** Moukeddar_ left
[14:48] <moritz> you don't have to patch parrot to use coroutines, if that's your question

[14:51] <ruoso> no no... the question was more in the lines of "does rakudo have hooks where I can hang this sort of stuff? or the only way is in parrot-level? "

[14:51] <moritz> depends on what you mean by "this sort of stuff"

[14:52] <moritz> there are no hooks for identifying blocking API calls

[14:52] <ruoso> implementing the equivalent of processes and unix pipes

[14:52] <moritz> you'd have to patch that in

[14:53] <ruoso> well... I guess I'd need some sort of spec for EWOULDBLOCK

[14:55] *** gbacon joined
[14:55] <moritz> you don't need a spec for experimenting

[14:56] <moritz> in fact any spec with less than two implementaions is considered "experimental" anyway

[14:56] *** cooper joined
[14:59] *** koban` left
[14:59] *** aindilis left
[15:00] *** aindilis joined
[15:02] *** wamba left
[15:03] <ruoso> rakudo: my @a = (1,2,3); say @a.get();

[15:03] <p6eval> rakudo 048573: OUTPUT«Method 'get' not found for invocant of class 'Array'␤  in main program body at line 22:/tmp/jh2BHwp9GF␤»

[15:03] <ruoso> rakudo: my $a <== (1,2,3); say $a.get();

[15:03] <p6eval> rakudo 048573: OUTPUT«Method 'push' not found for invocant of class ''␤  in main program body at line 22:/tmp/FFnTtzuP4V␤»

[15:04] *** ethan_ left
[15:04] <ruoso> rakudo: say (1,2,3).get()

[15:04] <p6eval> rakudo 048573: OUTPUT«Method 'get' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/coWpzZN9X_␤»

[15:05] <ruoso> rakudo: say (1,2,3).getargs()

[15:05] <p6eval> rakudo 048573: OUTPUT«Method 'getargs' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/NGuAvH3WeN␤»

[15:05] <moritz> rakudo: say $*IN.get

[15:05] <p6eval> rakudo 048573: OUTPUT«Land der Berge, Land am Strome,␤»

[15:05] <moritz> rakudo: say (1, 2, 3).iterator.get

[15:05] <p6eval> rakudo 048573: OUTPUT«Method 'get' not found for invocant of class 'ParcelIter'␤  in main program body at line 22:/tmp/x114vpwj__␤»

[15:06] <ruoso> S07 is still far from reality it seems

[15:07] <moritz> it is.

[15:07] <ruoso> but is it still in the right direction?

[15:07] <ruoso> or is it just outdated?

[15:07] <moritz> outdated

[15:08] <ruoso> is the most up-to-date documented anywhere?

[15:08] <moritz> ask sorear when he shows up, I think he did the most recent implementation

[15:12] *** silug joined
[15:12] *** _twitch joined
[15:19] *** Moukeddar__ left
[15:20] *** silug left
[15:20] *** silug joined
[15:24] *** silug left
[15:24] *** ethan joined
[15:25] *** silug joined
[15:29] *** silug left
[15:30] *** silug joined
[15:39] *** silug left
[15:40] *** tzhs left
[15:40] *** silug joined
[15:43] *** _twitch left
[15:47] *** jaldhar left
[15:47] *** jaldhar joined
[15:48] *** ethan left
[15:58] *** silug left
[15:58] *** silug joined
[15:59] *** jaldhar left
[16:01] *** jaldhar joined
[16:01] *** kaare_ joined
[16:01] *** thou joined
[16:01] *** ymasory joined
[16:01] *** nymacro left
[16:03] *** lumi left
[16:04] *** lumi joined
[16:07] *** silug left
[16:08] *** silug joined
[16:10] *** Moukeddar joined
[16:11] *** ymasory left
[16:13] *** ethan joined
[16:13] *** Moukeddar left
[16:16] *** daxim left
[16:17] <dalek> nqp: 1c65083 | jonathan++ | src/6model/reprs/P6opaque.c:

[16:17] <dalek> nqp: Update P6opaque to more fully handle box/unbox of native types.

[16:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1c65083452

[16:19] *** silug left
[16:20] *** silug joined
[16:29] *** pernatiy left
[16:31] *** n0den1te joined
[16:33] *** silug left
[16:33] <n0den1te> rakudo: (42 ** 3) ==> say

[16:33] <p6eval> rakudo 048573: OUTPUT«74088␤»

[16:33] *** silug joined
[16:33] <n0den1te> rakudo: (42 ** 3) ===> say  #?

[16:33] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Confused at line 22, near "(42 ** 3) "␤»

[16:34] *** MayDaniel left
[16:35] *** lumi left
[16:36] *** lumi joined
[16:37] <n0den1te> rakudo: class C { has $.x; }; my $aa = C.new(:$x = 42); my $bb = C.new(:$x=84); ($aa === $bb).say;

[16:37] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[16:37] <jnthn> C.new(:x(42))

[16:38] <n0den1te> rakudo: class C { has $.x; }; my $aa = C.new(:x(42)); my $bb = C.new(x(84)); ($aa === $bb).say;

[16:38] <p6eval> rakudo 048573: OUTPUT«Could not find sub &x␤  in main program body at line 22:/tmp/fdUXASYby0␤»

[16:38] <n0den1te> rakudo: class C { has $.x; }; my $aa = C.new(:x(42)); my $bb = C.new(:x(84)); ($aa === $bb).say;

[16:38] <p6eval> rakudo 048573: OUTPUT«Bool::False␤»

[16:38] <n0den1te> thanks, jnthn! 

[16:39] <n0den1te> err, sorry..

[16:39] *** n0den1te is now known as isBEKaml

[16:39] <isBEKaml> so this is equivalent to javascript's strict equality? both value and type equality, except that it sniffs out attribute equality too reflectively?

[16:40] <isBEKaml> (i.e., in cases of composite objects)

[16:40] <jnthn> === defaults to reference equality apart from types which define a .WHICH that says otherwise.

[16:40] *** jmp___ joined
[16:41] <isBEKaml> I see

[16:41] *** mj41 left
[16:42] <jmp___> good morning. I'm fairly new to Perl5 (started programming it seriously in March) and have begun reading Perl6 web stuff (and watching the YouTube vids) this weekend.

[16:42] <jmp___> so I'm basically a newbie

[16:42] <isBEKaml> rakudo: class C { has $.x; }; my $aa = C.new(:x(42)); my $bb = $aa(:x(84)); ($aa === $bb).say;

[16:42] <p6eval> rakudo 048573: OUTPUT«invoke() not implemented in class 'C'␤  in main program body at line 22:/tmp/7VHvdYKVBx␤»

[16:42] <isBEKaml> didn't think it would work. :)

[16:42] <jmp___> but I have a question regarding references.

[16:43] <jmp___> under perl6

[16:43] <jmp___> is this the right place to ask?

[16:43] *** icwiener left
[16:43] <isBEKaml> jmp___: anything about perl6, even a shred of remote link to perl6 goes here. go ahead. 

[16:44] <jmp___> while playing around in rakudo (downloaded last night to my Mac... works nicely as a playground, btw)

[16:45] <jmp___> i've discovered a solid metonymy between the $x reference to %h, in that everything i due with either is the same

[16:45] <jmp___> is this intentional

[16:45] <jmp___> will it remain forever>

[16:45] <jmp___> (i like it)

[16:46] <jmp___> do you want a specific example?

[16:46] <isBEKaml> so you're asking if a class reference $x works like an hash under the hood ?

[16:47] <jmp___> ah! i may be confused there.... i assumed doing the $x=%h would give me a reference

[16:47] <jmp___> but that is not what it is?

[16:47] <jnthn> jmp___: There aren't really explicit references in Perl 6.

[16:47] <jnthn> jmp___: Generally, you just don't have to think about those things.

[16:48] <jmp___> so creating a scalar ($x) that "references" an array or hash just "works"?

[16:48] <jnthn> "my %h; %h<foo>" and "my $h = { }; $h<foo>" will work out just the same.

[16:48] <jnthn> Yes.

[16:48] <jmp___> trey cool. Thank you.

[16:51] <jmp___> i have one other question, if I may... The %h.push('Foo'=>5) construct for adding an array element to the value in a hash requires parenthesis, but

[16:51] <jmp___> push %h<Foo>,5 does not

[16:51] <jmp___> oops

[16:52] <jmp___> i goofed that last... just a sec

[16:52] <isBEKaml> rakudo: my %h; %h.^methods(:local).perl.say;

[16:52] <p6eval> rakudo 048573: OUTPUT«[{ ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }, { ... }]␤»

[16:52] <jmp___> push %h.<Foo>,5

[16:53] <isBEKaml> rakudo: my %h; %h.^methods(:local).join(",").perl.say;

[16:53] <p6eval> rakudo 048573: OUTPUT«"at_key,Bool,delete,push,list,hash,sort,pick,roll"␤»

[16:53] <jmp___> rakudo:

[16:53] <jmp___> rakudo: %h<Foo>=>4

[16:54] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Symbol '%h' not predeclared in <anonymous> (/tmp/EHrkwkhaKb:22)␤»

[16:54] <jmp___> rakudo: my %h<Foo>=4;

[16:54] <p6eval> rakudo 048573: OUTPUT«Could not find sub &Foo␤  in main program body at line 22:/tmp/q81rzbeu45␤»

[16:54] <isBEKaml> jmp___: two things, you need to prefix my there and create a new instance of an hash for you to use later. 

[16:54] <isBEKaml> rakudo: my %h; %h<Foo> = 4; %h.perl.say;

[16:54] <p6eval> rakudo 048573: OUTPUT«{"Foo" => 4}␤»

[16:55] <jmp___> rakudo: my %h

[16:55] <p6eval> rakudo 048573:  ( no output )

[16:55] <jmp___> rakudo: %h<Foo>=4

[16:55] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Symbol '%h' not predeclared in <anonymous> (/tmp/OuM6hZT4Bk:22)␤»

[16:56] <isBEKaml> jmp___: two more things, you have to use 'say' for p6eval to print out stuff. It doesn't preserve state like your local REPL. :)

[16:56] <isBEKaml> jmp___: one too many 'two'. SCNR. :)

[16:56] <jmp___> not a problem, I'm just a fumble fingered typer (and fumble minding when working with new languages)... I'll play more on my private rakuto before pasting here, next time, sorry

[16:57] <jmp___> thanks!

[16:57] <isBEKaml> jmp___: feel free to try things out here. We were all newbies and are still very much so. :)

[16:58] <jmp___> btw... when i read about 'unspace' i almost fell off the couch .... awesome concept -- yet elegantly simple. Does any other major language use it?

[17:00] *** birdwindupbird left
[17:00] <jmp___> Larry's obsession with making space irrelevant to the parser seems to have born, if not borrowed, an incredible concept.

[17:01] <isBEKaml> jmp___: it's just a concept of escaping a few characters. Only difference here is, it's more generalized in perl6 to any whitespace character. 

[17:01] <jmp___> any plans to eventually let 'unspace' live amidst a token? 

[17:01] <jmp___> yes, i programmed C for years, and nawk and lots of others that used the backslash to escape newlines on the end of lines

[17:02] <jmp___> it was particualarly nasty in the shell

[17:02] <jmp___> where if some other whitespace got between the backslash and end of line you had invisible breakage

[17:02] <jmp___> with it being applied to all white space, that bug goes away

[17:03] <isBEKaml> ah, not sure if that's a good idea(unspace in tokens). IIUC, tokens are meant to be single entities. 

[17:03] <jmp___> awesome... maybe it is just "escaping a few characters" but to me it is somewhat a jewel.

[17:04] <jmp___> ok

[17:04] <jmp___> i understand re tokens, but just curious on that.... i'll not complain. for sure.

[17:05] <isBEKaml> if you want more examples, you can always look at Rosetta Code. It's still a work in progress, but some examples have left me stunned. 

[17:06] *** Vlavv left
[17:06] <jmp___> chrestomathy: wow, what a word!

[17:06] <isBEKaml> http://rosettacode.org/wiki/Category:Perl_6

[17:06] *** lumi left
[17:07] *** lumi joined
[17:09] <isBEKaml> jmp___: http://rosettacode.org/wiki/Define_a_primitive_data_type#Perl_6  haffun! :)

[17:09] *** Chillance joined
[17:10] <isBEKaml> rakudo: subset OneToTen of Int where { 1 <= $^n <= 10 }; my OneToTen $num = 5; $num += 5; say $num;

[17:10] <p6eval> rakudo 048573: OUTPUT«10␤»

[17:10] <isBEKaml> rakudo: subset OneToTen of Int where { 1 <= $^n <= 10 }; my OneToTen $num = 5; $num += 6; say $num;

[17:10] <p6eval> rakudo 048573: OUTPUT«Type check failed for assignment␤    Container type: Int␤               Got: Int␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/WFDtv_w_rs␤»

[17:10] <isBEKaml> rakudo++

[17:10] <jmp___> i'll try them on my rakudo installation.

[17:11] *** silug left
[17:16] <dalek> rakudo/nom: 8511092 | jnthn++ | src/Perl6/ (2 files):

[17:16] <dalek> rakudo/nom: First cut of Int and Str constants. Rather than making them every single time, we instead stash them away in the SC, which amongst other things serves as a constants table. Then the code is just looking up that boxed constant. Also refactor the way we handle the case where we need a string value to hand at compile time; should give better errors.

[17:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8511092b8a

[17:16] <dalek> rakudo/nom: 6c4de02 | jnthn++ | src/ (2 files):

[17:16] <dalek> rakudo/nom: Shuffle Int/Num/Str setup into the initial meta-model bootstrap; seems they gotta be at least partially done there.

[17:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6c4de023d2

[17:16] <dalek> rakudo/nom: c704aff | jnthn++ | src/Perl6/Metamodel/ClassHOW.pm:

[17:16] <dalek> rakudo/nom: Add find_method fallback dispatcher for when there's no hit from the cache; can flesh out more bits in here later for e.g. weird delegation cases.

[17:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c704aff581

[17:16] <dalek> rakudo/nom: 7845bc1 | jnthn++ | / (5 files):

[17:16] <dalek> rakudo/nom: Dummy &say, first couple of useful setting methods. We can now say('Hello, world!').

[17:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7845bc146a

[17:19] *** Vlavv joined
[17:21] <sorear> good * #perl6

[17:21] <jnthn> LHF but important hacking task for anybody who knows NQP: add_constant in src/Perl6/SymbolTable.pm currently doesn't detect duplicate usaes of the same constant within a compilation unit.

[17:21] *** silent_h_ joined
[17:21] <jnthn> o/ sorear 

[17:21] <isBEKaml> hello, sorear 

[17:21] <ruoso> hi sorear...

[17:22] <ruoso> moritz was saying you have insight on the state of affairs surrounding Iterator

[17:23] <ruoso> is there any docs on the Iterator behavior? how that relates to the current state of S07?

[17:23] <isBEKaml> sorear: I saw you were looking for some help with unicode treatment in niecza. any way I can help?

[17:26] *** Mowah_ joined
[17:26] <sorear> moritz: #p5p is is (still jokingly at this point) suggesting 6.0-rc1

[17:27] *** Sarten-X joined
[17:28] <sorear> o/ ITS JNTHN

[17:28] <jnthn> :)

[17:28] *** EDevil joined
[17:29] <sorear> isBEKaml: I am looking for people with native languages other than pl, es, de, en, jp, cn

[17:29] <sorear> isBEKaml: but not verty actively now; TimToady nudged me that this is worth punting

[17:30] <isBEKaml> sorear: my native language is ta and I can help with hi and devanagari too. 

[17:32] *** silent_h_ left
[17:33] <ruoso> jnthn: why is Invoke implemented in STable?

[17:34] *** lumi left
[17:34] <jnthn> ruoso: Are you looking at CLR one?

[17:35] <ruoso> yes

[17:35] <jnthn> If Parrot one I suspect fossil...

[17:35] <jnthn> Well, it's gotta go somewhere. :)

[17:35] <ruoso> but it's just a regular method, isn't it?

[17:35] <ruoso> it actually implements by doing a lookup and a call

[17:36] <ruoso> I was wondering why it is available at the lower-levle

[17:36] <ruoso> ...

[17:36] <jnthn> It's gotta bottom out somewhere.

[17:36] <jnthn> And doing a method lookup for every single method invocation is gonna get horribly slow.

[17:36] <ruoso> So you expect STable implementations to override .invoke

[17:37] *** lumi joined
[17:37] <ruoso> ah... just see what you mean... (found SpecialInvoke)

[17:37] <jnthn> Well, there kinda should only be one implementation in a sense...yes, you found the trick. :)

[17:37] <jnthn> I'm not totally happy with that chunk of stuff.

[17:38] <jnthn> I needed something that worked and that worked. But it's kinda slow.

[17:38] <ruoso> so things in the lower-level know that .postcirumfix:<( )> have a shortcut

[17:39] <jnthn> *nod*

[17:40] <jnthn> Though when I get back to nqpclr I expect that bit will change.

[17:40] <ruoso> so, conceptually, this is just an optimization..

[17:40] <jmp___> isBEKaml, regarding the samples you sent me to, is there something special (like use Math;) i need to make the 'sqrt' function visable?

[17:40] <jnthn> The background on this is that I did the 6model prototyping on the clr, without any real expectation of whether it'd lead anywhere or not. So I deliberately punted on the "best way" to do things that didn't matter that much to the prototyping I was doing.

[17:41] <jnthn> ruoso: Yes, you could see it as that.

[17:41] <jnthn> Or not doing it is a pessimization. :)

[17:41] *** pernatiy joined
[17:41] <jmp___> LOL

[17:41] *** ymasory joined
[17:41] <jnthn> rakudo: say sqrt(9)

[17:42] <p6eval> rakudo 048573: OUTPUT«3␤»

[17:42] <jnthn> jmp___: Seems not :)

[17:42] * jnthn goes for dinner, back in a little bit

[17:42] <jmp___> jnthn, thanks, the parens did it.

[17:43] <isBEKaml> jmp___: it's just Num. you can directly use sqrt

[17:43] <isBEKaml> ah, jnthn++ already replied to your qn. :)

[17:43] <jmp___> my problem is that when defining a type, it wont recognize sqrt

[17:44] <jmp___> at the point in time the range for the type is checked

[17:44] <jmp___> when the assignment to the actual variable is made

[17:44] <isBEKaml> jmp___: you're using subset?

[17:44] <jmp___> yes

[17:44] <jmp___> attempting to copy an example i found

[17:45] <jmp___> curious if it memoized the subset 

[17:45] <isBEKaml> rakudo: subset OneToTen of Int where { 1 <= $^n <= 10 }; my OneToTen $num = 5; $num += 4; say sqrt($num); #like this?

[17:45] <p6eval> rakudo 048573: OUTPUT«3␤»

[17:46] <jmp___> i was trying subset Prime of Int where { $^n > 1 and $^n %% none 2 .. sqrt($^n) }

[17:47] <jmp___> thought it was interesting and curious about implementation... however, later attempts to use vars of that subset fail:

[17:48] <jmp___> my Prime $p; p=37;

[17:48] <isBEKaml> rakudo: subset P of Int where { $^n > 1 and $^n %% none 2 .. sqrt($^n) }; my P $pp = 37; say $pp;

[17:48] <p6eval> rakudo 048573: OUTPUT«Could not find sub &sqrt␤  in <anon> at line 22:/tmp/TrovCZ40vH␤  in 'Block::ACCEPTS' at line 6374:CORE.setting␤  in 'infix:<~~>' at line 483:CORE.setting␤  in <anon> at line 1:/tmp/TrovCZ40vH␤  in 'Block::ACCEPTS' at line 6374:CORE.setting␤  in 'ACCEPTS' at line

[17:48] <p6eval> ..1082:CORE.setting␤…

[17:48] <jmp___> my rakudo response to the assignment with could not find sub &sqrt

[17:49] *** fhelmberger left
[17:49] *** masak joined
[17:49] <masak> evenin', zebras.

[17:50] <isBEKaml> masak!

[17:50] <isBEKaml> masak: how are you, my good sir? :)

[17:50] <masak> hey! :)

[17:50] <TBA> evening masak :) funny you should say zebras, currently logged into my server named zebra :p fun animal!

[17:51] *** hanekomu left
[17:51] <masak> TBA: it's one of our mascot animals here in #perl6.

[17:51] <isBEKaml> jmp___: hmmm, that's odd it should fail. maybe someone here could explain better. 

[17:51] <jmp___> i am guessing zebra is the new animal from O'Reilly to take the place of the Perl5 camel for perl6?

[17:51] <TBA> masak: odd i should choose zebra as my p6 testing server then lol... they're all named after animals but what a coincidence

[17:51] <isBEKaml> rakudo: my Int $n = 37; say sqrt($n);

[17:51] <sorear> hmm.  if the Germans got de_DE for Deutsch(land), why didn't Japanese get ni_NI?

[17:52] <p6eval> rakudo 048573: OUTPUT«6.08276253029822␤»

[17:52] <isBEKaml> sorear: this is only a guess. Japanese have their own name for their country. Nippon, I think

[17:53] <sorear> ruoso: niecza has real threads, btw.

[17:53] <isBEKaml> sorear: and their language, nihongo bashi. (cool, I"m making this up) :D

[17:54] <sorear> just nihongo

[17:54] <sorear> also, the country itself can be called nihon

[17:54] *** araujo left
[17:55] <isBEKaml> you got it. 

[17:55] <sbp> "Japanese is represented by ja (even though its endonym is Nihongo)"

[17:55] <sbp> http://en.wikipedia.org/wiki/ISO_639-1

[17:56] <TBA> does anyone know if theres a perl interpreter for avr microcontrollers (or any microcontroller)?

[17:56] *** Sarten-X left
[17:56] *** mj41 joined
[17:57] <sbp> phenny: ask clsn why Japanese is jp in ISO 639-1 instead of ni for the endonym, Nihongo

[17:57] <phenny> sbp: I'll pass that on when clsn is around.

[17:57] *** mberends joined
[17:57] *** lumi left
[17:57] <isBEKaml> rakudo: my Int $n =  37; say { $n %% none 2..sqrt($n) };

[17:57] <p6eval> rakudo 048573: OUTPUT«_block139␤»

[17:57] <TBA> or perhaps more relevant, whats my chances of getting parrot and perl6 to compile using avrgcc

[17:57] *** MayDaniel joined
[17:57] *** lumi joined
[17:58] <isBEKaml> rakudo: my Int $n =  37; say ( $n %% none 2..sqrt($n));

[17:58] <p6eval> rakudo 048573: OUTPUT«none(Bool::False)␤»

[17:59] <ruoso> sorear: but my question was more regarding Implementation vs Spec

[17:59] <sbp> same result with say { $n %% none 2..sqrt($n) }(), and just say $n %% none 2..sqrt($n)

[17:59] <ruoso> S07 seems far from reality

[18:00] <isBEKaml> sbp: yeah, I was more wondering why the subset assignment failed in my earlier example. 

[18:00] <sbp> ah

[18:01] <isBEKaml> sbp: so that looks wrong. 

[18:02] <isBEKaml> rakudo: my Int $n =  37; say ( all $n %% 2..sqrt($n));

[18:02] <p6eval> rakudo 048573: OUTPUT«all(0, 1, 2, 3, 4, 5, 6)␤»

[18:02] *** vlixes joined
[18:02] <sorear> ruoso: S07 is close to what alpha did.

[18:03] <ruoso> sorear: ah... so S07 is still in the right direction...

[18:03] <isBEKaml> rakudo: my Int $n = 37; say all $n; #huh?

[18:03] <p6eval> rakudo 048573: OUTPUT«all(37)␤»

[18:03] <sorear> niecza is pretty close to rakudo master (which is quite different), although I took some license with iterators

[18:03] <jmp___> the sample was posted in Wikipedia at: http://rosettacode.org/wiki/Define_a_primitive_data_type#Perl_6 if you wan't original not mangled by my typing on the irc

[18:04] <isBEKaml> rakudo: my Int $n =  37; say ($n %% 2..sqrt($n));

[18:04] <p6eval> rakudo 048573: OUTPUT«0123456␤»

[18:04] <sorear> jnthn: How {does,will} $obj ~~ MyClass work in nom?

[18:05] <isBEKaml> rakudo: my Int $n =  37; say ($n %% 2..sqrt($n).Int);

[18:05] <p6eval> rakudo 048573: OUTPUT«0123456␤»

[18:05] <ruoso> rakudo: say List ~~ Iterator, Iterator ~~ List

[18:05] <p6eval> rakudo 048573: OUTPUT«Bool::FalseBool::False␤»

[18:06] <ruoso> From what is in S07, I would think List and Iterator are kinda the same thing

[18:06] <sorear> ruoso: they were in alpha

[18:07] <isBEKaml> rakudo: my Int $n =  37; say ( $n %% none 2..sqrt($n));

[18:07] <p6eval> rakudo 048573: OUTPUT«none(Bool::False)␤»

[18:07] <sorear> little if anything in S07 has been relevant since ng was merged

[18:07] <isBEKaml> masak, jnthn: ^^ is this correct?

[18:07] <masak> rakudo: my Int $n =  37; say ?( $n %% none 2..sqrt($n))

[18:07] <p6eval> rakudo 048573: OUTPUT«Bool::True␤»

[18:08] <masak> none(False) == True :)

[18:08] <ruoso> sorear: "has been relevant" meaning nobody tried to implement... but the spec is still kinda what it was supposed to be

[18:08] <sorear> ruoso: no

[18:08] <sorear> not at all

[18:08] <isBEKaml> masak: ahhh... :)

[18:08] <sorear> pmichaud has repeatedly promised to delete S07 and replace it with a description of what Rakudo master does

[18:09] *** daxim joined
[18:09] <ruoso> ok... I guess that means there isn't any other document explaining it...

[18:10] *** Sarten-X joined
[18:10] <mberends> TBA: parrrot and rakudo make a 50MB process, that is way beyond any avr hardware. I am working on a perl 6 subset -> C translator (perlduino) whose output can be compiled by avrgcc, but only parts of it are written. It's taking a lot of my time ;)

[18:12] *** lumi left
[18:13] *** lumi joined
[18:17] <jmp___> ok... don't hit the online perl engine with this... I've tried it on my iMac and it is slow, every time i run it, suggesting that the engine is not memoizing the results...I presume that eventually the engine will hang onto key values make things run faster...

[18:18] *** wamba joined
[18:18] <jmp___> { $^n>1 and $^n %% none 2 .. sqrt( $^n) }(1000_000)

[18:19] <masak> I see no memoization going on there.

[18:20] <jmp___> i can't make my iMac xterm cut and paste cleanly so i could have typo'd but the idea is exposed... in the event of using the block as the body of a subset

[18:22] <jmp___> , i'd presume the interpreter would automatically retain memoized intermediates for something like that (or of course, i suppose a user written function could be used in lieu of parts of the block with explicit caching in a hash...)

[18:22] <isBEKaml> rakudo: subset PP of Int where { $^n > 1 and ?($^n %% none 2..($^n.sqrt)) }; my PP $nn = 37; say $nn; #ok

[18:22] <p6eval> rakudo 048573: OUTPUT«37␤»

[18:22] <masak> jmp___: you overestimate Rakudo :)

[18:23] <jmp___> i'm only asking for omniscience...

[18:23] *** HarryS left
[18:23] <jmp___> I guess that could be a Perl7 thing... 

[18:24] *** wooden left
[18:24] <isBEKaml> jmp___: see my last example. that works. 

[18:24] <isBEKaml> now someone could take this up to change the p6 code example on RC. 

[18:24] <jmp___> sweet. THANKS isBEKaml

[18:25] *** HarryS joined
[18:25] <isBEKaml> jmp___: you're welcome. :)

[18:26] *** Sarten-X left
[18:28] *** lumi left
[18:29] *** kaare_ left
[18:29] <jmp___> one oddity: the "Type check failed for assignment" message should probably reference the subset name, if that is possible, rather than the larger Class name, as it tells me that I can't put an Int in an Int...

[18:29] *** lumi joined
[18:30] <jmp___> Type check failed for assignment \n Container type: Int \n Got: Int

[18:30] <masak> jmp___: agreed.

[18:30] <masak> that's a known issue.

[18:30] <masak> will be fixed in nom ;)

[18:30] <jmp___> oh... sorry

[18:30] <jnthn> masak: yes, it will :)

[18:30] <masak> don't be sorry :)

[18:30] <masak> jnthn: I'm starting to be able to tell :P

[18:32] <jnthn> sorear: $obj ~~ MyClass will do MyClass.ACCEPTS($obj) which will in turn call the typecheck op which will look in the typecheck cache and if it doesn't get lucky in there will call back to .^type_check

[18:32] <isBEKaml> I don't know the extent of changes in NOM, but I'm working on nqpjvm after a month. :)

[18:32] <sorear> jnthn: so the calling into the typecheck enging happens from Mu.ACCEPTS(Mu:U $self:) ?

[18:32] <jnthn> sorear: yes

[18:33] <jnthn> sorear: Note that things like the binder, runtime assignment type checks and so on will not go via .ACCEPTS

[18:33] <jnthn> sorear: But rather straight to the typecheck engine.

[18:33] <tadzik> hello #perl6

[18:33] <isBEKaml> hey tadzik!

[18:34] <tadzik> hey isBEKaml. How is the world on the other side of the wire?

[18:34] <masak> tadzik! \o/

[18:34] <jnthn> o/ tadzik 

[18:34] <sorear> ok.

[18:34] <isBEKaml> tadzik: frayed as ever. :)

[18:34] <isBEKaml> tadzik: how's things at your end?

[18:35] <tadzik> my class Whatever is Cool -- Cool

[18:35] <jnthn> rakudo: say Whatever ~~ Cool

[18:35] <p6eval> rakudo 048573: OUTPUT«Bool::False␤»

[18:35] <tadzik> isBEKaml: fair enough. I feel a little moody though, may be related to the hardcore semester ending

[18:35] <jnthn> ah

[18:35] <jnthn> tadzik: Feel free to fix.

[18:36] <isBEKaml> .oO(hardcore semesters?)

[18:36] * sorear is fixing spectests for v6

[18:36] <tadzik> isBEKaml: yeah, every single one

[18:37] <isBEKaml> tadzik: that's odd. my memories of univ and semesters are a total haze. 

[18:37] <isBEKaml> they just kind of passed me by that fast. 

[18:38] *** Sarten-X joined
[18:39] <tadzik> not a piece of cake for me it seems

[18:39] <dalek> rakudo/nom: e127457 | tadzik++ | src/Perl6/Metamodel/ClassHOW.pm:

[18:39] <dalek> rakudo/nom: Minor typo fix

[18:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e127457492

[18:39] <tadzik> FWIW, 48 out of 120 passed the first year

[18:39] <tadzik> one-letter karma

[18:40] <daxim> perl6: [1,3,2,8,9,6] >> sort

[18:40] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ">>"␤    expecting operator␤    at /tmp/d6rjCteDYH line 1, column 15␤»

[18:40] <p6eval> ..niecza v5-130-gc49e30c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of >> to do right shift; in Perl 6 please use +> or ~> at /tmp/4bE6tTW63C line 1:␤------> [32m[1,3,2,8,9,6] >>[33m⏏[31m sort[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting

[18:40] <p6eval> ..line 413 (CORE die …

[18:40] <p6eval> ..rakudo 048573: OUTPUT«===SORRY!===␤Unsupported use of >> to do right shift; in Perl 6 please use +> or ~> at line 22, near "sort"␤»

[18:40] <daxim> rakudo: [1,3,2,8,9,6] >>> sort

[18:40] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Missing << or >> at line 22, near " sort"␤»

[18:41] <daxim> is that called the pipeline operator?  I totally forgot the name, how to look this up

[18:41] <jnthn> ==>

[18:41] <jnthn> fed

[18:41] <jnthn> gah

[18:41] <jnthn> feed

[18:42] <isBEKaml> rakudo: (1,3,2,8,9,7).>>sort.say

[18:42] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Confused at line 22, near "(1,3,2,8,9"␤»

[18:42] <jnthn> >>.

[18:42] <isBEKaml> bah

[18:42] <isBEKaml> rakudo: (1,3,2,8,9,7)>>.sort.say

[18:42] <p6eval> rakudo 048573: OUTPUT«132897␤»

[18:42] <isBEKaml> rakudo: (1,3,2,8,9,7) ==> sort.say

[18:42] <daxim> rakudo: [1,3,2,8,9,6] ==> sort ==> map ->n { n*n }

[18:42] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Sorry, do not know how to handle this case of a feed operator yet. at line 22, near " sort.say"␤»

[18:42] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Invalid typename in parameter declaration at line 22, near " { n*n }"␤»

[18:42] <daxim> pugs: [1,3,2,8,9,6] ==> sort ==> map ->n { n*n }

[18:42] <p6eval> pugs: OUTPUT«*** ␤    Unexpected " sort"␤    at /tmp/poIsv6ggHZ line 1, column 18␤»

[18:43] <tadzik> fed operator. sjohnson, bring the fat face!

[18:43] <jnthn> rakudo: [1,3,2,8,9,6] ==> sort ==> map -> $n { $n * $n } ==> say

[18:43] <p6eval> rakudo 048573: OUTPUT«36␤»

[18:43] <jnthn> heh

[18:43] <jnthn> rakudo: (1,3,2,8,9,6) ==> sort ==> map -> $n { $n * $n } ==> say

[18:43] <p6eval> rakudo 048573: OUTPUT«149366481␤»

[18:43] <isBEKaml> ( >> o|O << )

[18:44] <isBEKaml> rakudo doesn't treat arrays and lists as equivalent/

[18:45] <isBEKaml> ISTR pmichaud saying something like that... 

[18:45] <jnthn> isBEKaml: [...] will not flatten

[18:46] <isBEKaml> jnthn: if they are meant to be equivalent, shouldn't it also flatten?

[18:46] <isBEKaml> jnthn: equivalent constructs, consistent behaviour?

[18:46] *** vlixes left
[18:46] <daxim> niecza: [1,3,2,8,9,6] ==> sort ==> map ->n { n*n }

[18:46] <p6eval> niecza v5-130-gc49e30c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Preceding context expects a term, but found infix ==> instead at /tmp/C9wc50RjPO line 1:␤------> [32m[1,3,2,8,9,6] ==> sort [33m⏏[31m==> map ->n { n*n }[0m␤␤Parse failed␤␤»

[18:46] <jnthn> isBEKaml: They're not meant to be equivalent in this context.

[18:47] <jnthn> It's like doing sort (1,2,3) vs sort [1,2,3]

[18:47] <jnthn> (1,2,3).sort and [1,2,3].sort OTOH would do the same.

[18:48] <isBEKaml> jnthn: hmmm, I must check this one

[18:48] <isBEKaml> rakudo: sort [1,4,98,8,2] >> .say;

[18:48] <p6eval> rakudo 048573: OUTPUT«===SORRY!===␤Unsupported use of >> to do right shift; in Perl 6 please use +> or ~> at line 22, near ".say;"␤»

[18:49] <isBEKaml> rakudo: sort [1,4,98,8,2].say;

[18:49] <p6eval> rakudo 048573: OUTPUT«1 4 98 8 2␤»

[18:49] *** hudnix joined
[18:49] <isBEKaml> rakudo: (sort [1,4,98,8,2]).say;

[18:49] <p6eval> rakudo 048573: OUTPUT«1 4 98 8 2␤»

[18:49] <isBEKaml> jnthn: I see what you mean. 

[18:49] <masak> isBEKaml: it's considered "bad form" to combine hyperops and side-effectful methods like .say

[18:49] *** lumi left
[18:50] <isBEKaml> masak: haskell-y, yeah. Until I get a firm grip on ropes, instead of groping around. :)

[18:50] <masak> sure thing.

[18:50] *** vlixes joined
[18:50] *** lumi joined
[18:50] <masak> the pseudo-junction type 'each' has been suggested to fill this gap.

[18:54] <isBEKaml> masak: it's still doing the rounds in proposals in the ML?

[18:55] <tadzik> oh noes, nom doesn't compile

[18:55] <tadzik> http://wklej.org/id/538120/

[18:56] <masak> isBEKaml: it's marked "conjectural" in the spec.

[18:57] <jnthn> tadzik: Your nqp is too old

[18:57] <isBEKaml> masak: OIC. IM IN YR SPEC. O RLY? NO WAI. IM OUTTA YR SPEC. 

[18:57] <masak> ;)

[18:58] *** MayDaniel left
[18:59] <tadzik> jnthn: oh thanks

[18:59] *** Sarten-X left
[19:02] <isBEKaml> masak: my fascination for that form of language grew when I saw a google code jam submission for the candy problem recently. :)

[19:02] <masak> candy problem?

[19:02] <isBEKaml> masak: yeah, that was one of the problem statements in teh contest. 

[19:03] <isBEKaml> masak: http://code.google.com/codejam/contest/dashboard?c=975485#s=p2  -- candy splitting problem. 

[19:04] <isBEKaml> one of the submissions to that problem was in LOLCODE. :D

[19:04] *** meteorjay joined
[19:07] *** nwc10 joined
[19:08] *** Sarten-X joined
[19:08] <nwc10> do I misremember, or was there something on jnthn's blog at http://6guts.wordpress.com/ about how the new 6model compiler/loader architecture had to merge settings at load time?

[19:08] <nwc10> [I can see the bit about "clean slate" for compiling, but I though also there was a discussion about the implications of what that means at load time, when 2 different compiled modules had both been fiddling with globals]

[19:10] <jnthn> nwc10: There's no setting merging as that's just an outer scope.

[19:10] <jnthn> But for modules there is.

[19:11] <jnthn> I may have scribbled about that. :)

[19:11] <jnthn> Don't see it in that post either though...

[19:11] <tadzik> yay, Hello world

[19:11] <nwc10> I *thought* you had, but re-reading at "skim" speed and with a couple of what-I-thought-were-reasonable searches, I couldn't find anything.

[19:11] <nwc10> So, guess my memory is faulty.

[19:12] <nwc10> I guess.

[19:13] <jnthn> nwc10: There's a little bit on global merging in http://6guts.wordpress.com/2011/04/25/separate-compilation-package-refactors-and-gradual-typing-oh-boy-what-a-mix/

[19:13] <jnthn> But just a reference to it rather than any details.

[19:13] <colomon> o/

[19:14] * jnthn => shop, before it shuts

[19:15] <nwc10> good plan. would be a bad plan to run out of beer, er food

[19:15] *** daxim left
[19:16] <jmp___> i thought beer was food...

[19:17] <nwc10> jnthn: ah yes, this bit: Obviously, this means that you kind of need to have parallel realities: the module's view of GLOBAL is decidedly not going to contain whatever happens to be in GLOBAL by whatever does the "use" statement to load the module. Of course, they must be reconciled at some point, but not until that module's compilation is completed.

[19:18] <nwc10> well, guiness *is* the classic "liquid lunch"

[19:19] <tadzik> call me crazy, but I didn't like Guiness last time I tried

[19:19] <nwc10> I didn't use to, but now I do

[19:19] <tadzik> I even added sugar to it

[19:20] <jmp___> tadzik, maybe you'd find Smithwyck's more to your liking... and its a guiness beer...

[19:21] <jmp___> btw: beer discussion is ok here, right? I mean the mongers seem like a hoppy bunch of folks...

[19:21] * nwc10 was just treating all channels like #london.pm :-)

[19:22] *** EDevil left
[19:22] *** mj41 left
[19:23] *** lumi left
[19:24] *** lumi joined
[19:26] <tadzik> jmp___: I'm sure jnthn won't complain

[19:28] *** Limbic_Region left
[19:31] <jnthn> ooh, we're on to beer!

[19:31] *** Enlik left
[19:31] <jnthn> nwc10: Yes, that's the bit I was thinking of.

[19:32] *** Moukeddar joined
[19:33] <Moukeddar> Hello guys \o

[19:33] <masak> hi Moukeddar.

[19:33] <nwc10> hi Moukeddar. However, I'm off

[19:33] *** nwc10 left
[19:33] <Moukeddar> how are doing masak ?

[19:34] <masak> doing okay :)

[19:34] <masak> Moukeddar: how're you?

[19:34] <Moukeddar> good to hear :)

[19:35] <Moukeddar> i'm pretty stressed :)

[19:35] <pmichaud> good afternoon, #perl6

[19:35] <Moukeddar> exams are soon 

[19:36] <Moukeddar> evening here :)

[19:37] <Moukeddar> masak, since you're here ,should i start with design patterns , or with the algorithms/ datastructure book ?

[19:37] <masak> Moukeddar: what's your aim?

[19:37] <Moukeddar> aim?

[19:38] <masak> yes. why are you reading those books?

[19:38] <masak> in three words or less :P

[19:38] <colomon> Moukeddar: algorithms.  :)

[19:38] <Moukeddar> to be the best :)

[19:39] <masak> Moukeddar: I don't think the patterns book is going to tell you much until you've written a few "systems".

[19:39] <Moukeddar> i'm attending a school next year , i want to be the best , also i have a few projects of my own , and i want to do them right :)

[19:40] *** jaldhar left
[19:40] *** jaldhar joined
[19:40] <masak> Moukeddar: I'm trying to learn Go (the board game) on my spare time. I go back and forth between getting beat up by the computer and reading about tactics and strategy on the web.

[19:40] <colomon> Moukeddar: understand that there is a wildly different skillset needed to by, say, "the best" web app designer and "the best" compiler writer.

[19:41] <masak> Moukeddar: I think you'd be wise to do the same. pick a programming book you really like, doesn't much matter which one, and apply what you read into working code.

[19:41] <Moukeddar> colomon, how about solution designer :)

[19:41] <Moukeddar> like writing some system to manage a school , or store

[19:41] <masak> Moukeddar: did you know Pugs (the Perl 6 compiler) was started because au++ read a book and went through the exercises in it? :)

[19:42] <Moukeddar> interesting

[19:43] <masak> I got heavily involved in Perl 6 development because I started writing a wiki engine one summer with a friend.

[19:44] <colomon> I got heavily involved in Perl 6 development because I was impatient for all the cool new Perl 6 features.  :)

[19:44] <Moukeddar> you see , my goal is quite simple , learn design instead of dry coding :p

[19:45] <jnthn> I got heavily involved in Perl 6 development because I drunk beer and then said I'd implement stuff without knowing how hard it'd be. :P

[19:45] <Moukeddar> lol

[19:45] <masak> Jonathan Worthington: beer-driven development, beer-driven project involvment :P

[19:46] <jmp___> This has got to be the best channel on the web... Beer, Perl and Go....

[19:46] <TBA> mberends: thanks for the info, which controller are you using btw? sounds like something i'd be interested in if you'll be releasing the source at any point, need to build a heating control unit and keep coming back to the conclusion that perl is the way to go, just don't want to run linux in between if i can avoid it!

[19:46] <colomon> jnthn++

[19:46] <pmichaud> colomon: still impatient?

[19:46] <colomon> pmichaud: you betcha!  :)

[19:47] <Moukeddar> beer-driven , that's a good one Sir

[19:47] <masak> Moukeddar: that goal is admirable. all I'm saying is make sure you build a few houses along the way. otherwise the architecture you learn isn't going to be as strong.

[19:47] *** jaldhar left
[19:48] <Moukeddar> masak, roger that :)

[19:48] <tadzik> jmp___: go?

[19:48] *** jaldhar joined
[19:48] <Moukeddar> i'll play in the sandbox before doing something seriouss 

[19:48] <masak> Moukeddar: I can frankly say I spent the first 10 years as a developer building dog-house-sized houses. that's very useful for learning the small patterns. :)

[19:48] *** lumi left
[19:49] *** lumi joined
[19:49] <masak> tadzik: it's a board game played on the intersections of a grid, wherein the object is to occupy territory by surrounding and suffocating opponent groups of stones.

[19:49] <jlaire> masak: how strong are you at Go? :)

[19:49] <masak> jlaire: pitifully weak :)

[19:49] <jlaire> heh, me too

[19:50] <Moukeddar> long way to go , because i began to hate dry coding

[19:50] <masak> Moukeddar: what is this "dry coding" you're talking about?

[19:50] <donri> rejoice, new MoR!

[19:51] <tadzik> masak: oh, this go

[19:51] <masak> dalek: YAY

[19:51] <Moukeddar> well , jumping into the code without having a plan or whatso ever

[19:51] <masak> donri: YAY

[19:51] <pmichaud> I'm not sure why I got into Perl 6 development.

[19:51] *** hanekomu joined
[19:51] * masak hugs pmichaud 

[19:51] <Moukeddar> just an idea and hacking and slashing your way through

[19:51] <jlaire> Moukeddar: studying algorithms and data structures might make coding seem less dry to you

[19:51] <pmichaud> I think it had something to do with fame and world renown.  I didn't realize it was going to be "infamy".

[19:51] <jmp___> i quit pursuing Go skill when i came to the conclusion that I'd possibly never reach Dan rank.... but it is an awesome game, if you have the extra neurons for it.

[19:51] *** Mowah_ left
[19:51] <TBA> moukeddar: sometimes that can be good though, design is all well and good when theres a clear end goal in mind, but sometimes you just have to go for it and see what you get at the other end :p it feels naughty!

[19:51] <jmp___> i plan to take it back up after retiring

[19:52] <Moukeddar> jlaire, thank you , that was my opinion too ,

[19:52] *** molaf joined
[19:52] <Moukeddar> TBA, it's like inventing , but less cheerful :)

[19:52] <TBA> lol

[19:53] <masak> Moukeddar: I never go in *entirely* without a plan. but with TDD, one still gets to pace oneself. I *really* enjoy seeing the code grow in minimal increments :)

[19:53] *** hanekomu left
[19:53] <Moukeddar> masak, you should join SWAT forces :)

[19:53] *** hanekomu joined
[19:53] <pmichaud> TDD makes the little successes (and the little failures) more evident earlier :)

[19:54] <TBA> masak: to me it always feels nice to wake up to a lack of test failure emails :P

[19:54] <TBA> apart from that, TDD sometimes drives me nuts lol

[19:54] <masak> TBA: why?

[19:54] <TBA> but i do think it produces better quality code

[19:54] <TBA> normally environment issues tbh

[19:54] <Moukeddar> also , i want to learn SOA and DDD and TDD and CQRS and all these philosophies :)

[19:54] <masak> Moukeddar: but yes, over the years I've come to believe that the really good pieces of software out there were written by people who had already tried writing that kind of software 49 times before. :)

[19:54] <jmp___> maybe there is a good balance to be found between theory and practice... use the practice to make the Patterns more alive in the mind... i mean

[19:54] <TBA> tests fail and you spend hours chasing a red herring lol :/

[19:55] <Moukeddar> haha 

[19:55] <masak> TBA: you should write a test 'is $herring.color, "red"', duh :P

[19:55] <TBA> lol, at least it'd pass every time ;)

[19:56] <jmp___> after decades of "coding" and writing, I became a much better programmer after studying Patterns... though I'm not sure they would have been much use beforehand.

[19:56] <masak> exactly.

[19:56] <jmp___> too much of coding is knowing the system you are working on

[19:56] <Moukeddar> again , patterns :)

[19:56] <mberends> TBA: I currently have the Uno, Nano and the (obsoleted) Duemillenove in http://arduino.cc/en/Main/Hardware

[19:56] <jmp___> and that is developed by experience, not study

[19:56] <masak> Patterns encode experience you wish you had earlier. but you can't get it earlier.

[19:56] <Moukeddar> masak, that site "infoQ" has really changed my view of a lot of things

[19:57] <masak> "the sad thing 'bout experience / is by the time you get it / it's usually all you've got"

[19:57] <Moukeddar> masak, alternative joy :)

[19:57] <jmp___> ouch

[19:57] *** silug joined
[19:57] <masak> ...sung by a very old female sleeping train in "Starlight Express" :P

[19:58] <sjohnson> tadzik: :]

[19:58] <sjohnson> （　｀ー´）

[19:58] <tadzik> :)

[19:58] <Moukeddar> good one , very true :(

[19:58] * masak puts on "Starlight Express"

[19:58] <masak> sjohnson! \o/

[19:58] <pmichaud> "good judgment comes from experience.  experience comes from bad judgement."

[19:58] <sjohnson> yo

[19:58] <TBA> mberends: just had a look, but are they not avr chips used by those arduinos?

[19:59] <pmichaud> afk for a bit

[19:59] <jmp___> do the primitive types work in rakudo?

[19:59] <jmp___> I mean, Int works, but does int?

[20:00] <tadzik> it is supposed to work in nom

[20:00] <jnthn> jmp___: Not yet.

[20:00] <Moukeddar> pmichaud, infinite loop

[20:00] <jmp___> thanks tadzik,jnthn

[20:00] <masak> Moukeddar: oh! I have a recommendation for you. but... if you liked "infoQ"... this one is likely to keep you awake for a week...

[20:00] <jmp___> what is "nom"

[20:00] <jmp___> the next release?

[20:00] <jmp___> another compiler?

[20:00] <Moukeddar> masak, bring it  :)

[20:00] <masak> Moukeddar: http://c2.com/cgi/wiki?ReallyValuablePages

[20:01] <Moukeddar> i nom , you nom , noming 

[20:01] <masak> You Have Been Warned.

[20:01] <tadzik> jmp___: "new object model"

[20:01] <jmp___> thanks tadzik

[20:01] <jnthn> jmp___: It's a branch in the Rakudo repository where various improvements are being developed.

[20:01] <jmp___> so...its "on the way" or just "in planning"

[20:02] <jmp___> ah ha!

[20:02] <jnthn> jmp___: Many performance related.

[20:02] <tadzik> on the planning

[20:02] <masak> in the way :)

[20:02] <jnthn> masak: :P

[20:02] <masak> SCNR

[20:02] <TBA> out of interest, is any benchmarking being done between p5 and rakudo atm?

[20:02] <mberends> TBA: I thought we were discussing the same thing ;) Arduino is the board design and avr ATmega328 is the CPU.  Users use avrgcc to produce binaries for them and avrdude to upload the executables to the board via USB cable.

[20:02] *** Moukeddar left
[20:02] <masak> TBA: only when we need a good cry.

[20:03] <jmp___> i suspect that until the primitives are instantiatable, any performance testing will just make us Perl6 lovers cry.

[20:03] <TBA> mberends: you said about the 50mb limit on the avrs, which would apply to the ATmega328 too? i'm using avrgcc on an atmega328 already, just directly on a (non-arduino) programmer

[20:03] *** Moukeddar joined
[20:03] <jnthn> jmp___: Rakudo performance is pretty bad at the moment.

[20:03] <TBA> masak: that bad eh? :/

[20:03] <Moukeddar> sorry , what did i miss

[20:03] <jnthn> Moukeddar: The rapture happened.

[20:03] <TBA> lmao jnthn

[20:03] <Moukeddar> so fast?

[20:04] <jnthn> Yeah, it was an accelarapture...

[20:04] <Moukeddar> casulties report please :)

[20:04] <masak> jnthn: dåligt :)

[20:04] *** lumi left
[20:04] <masak> Moukeddar: did you get my link?

[20:04] <masak> if not, it's in the backlog.

[20:05] <Moukeddar> yes masak 

[20:05] <masak> it's... a wiki for patterns!

[20:05] <masak> (and other topics of discussion)

[20:05] <mberends> TBA: no, I mean a Rakudo perl6 process measures over 50MB on an i386 system, and you will never squeeze anything like that into the *32KB* of the atmega328.

[20:05] <Moukeddar> very interesting :)

[20:05] <Moukeddar> thanks

[20:07] <mberends> TBA: the biggest atmega chip has 256KB flash memory afaik.

[20:07] <TBA> mberends: ah i see, so what are the options? iirc the avrs only go upto 64kb internal? is there any way to use external ram to support it? kinda new to microcontroller programming so sorry if silly questions :)

[20:07] *** lumi joined
[20:07] <TBA> mberends: psychic, correcting me before i say anything ;)

[20:07] <TBA> mberends: or, any way to get a perl parser working in under 256kb? ;)

[20:08] <mberends> TBA: the option is to stick to a small subset of the language, and to generate code for only the instructions actually used by the program.

[20:08] <mberends> TBA: forget eval() for starters...

[20:10] <mberends> TBA: it is an interesting experiment to discover how quickly the memory will be filled. I optimistically expect some pleasant surprises, and some disappointments :)

[20:10] <TBA> mberends: so how do PC's do it? i mean, obviously there's a cache in the processor (8mb?) and external ram, but is that it? if so, could we not use external ram (assuming we have enough pins lol)

[20:10] <TBA> mberends: how far are you off getting it to compile?

[20:11] <mberends> TBA: no, the PC RAM can all contain machine language, even gigabytes of it, and the atmega has only kilobytes for machine language.

[20:12] <mberends> TBA: I had a little bit working with lex and yacc, and I hated it, so I broke it and am re-doing it another way.  I have been one day off getting working for about three weeks now ;)

[20:12] <TBA> lol :p

[20:13] *** silug left
[20:13] <TBA> presumably there are other controllers which could do it though? what about ARM?

[20:14] <mberends> TBA: yes, the ARM is much more powerful, a 32 bit CPU instead of 8 bit.

[20:14] *** Sarten-X left
[20:14] *** silug joined
[20:15] <TBA> mberends: so potentially something like the ARM11MPCore (has built in MMU too!)?

[20:15] <mberends> I have two ARM based NAS servers running Linux and Perl 5, but the 64MB RAM is too small to *build* Rakudo :(

[20:15] <TBA> lmao typical

[20:15] *** MayDaniel joined
[20:15] <TBA> no way to build on another machine?

[20:15] *** Sarten-X joined
[20:15] <jmp___> regarding perl6 perlformance, a simple subroutine to compute and print (into | wc) all the primes up to 1_000_000 takes about 4.2 seconds on my Mac mini... with Perl FIVE....

[20:16] <jmp___> ... i'll report how long perl SIX takes when it finishes, sometime in the next hour, i'd imagine

[20:16] <mberends> TBA: yes, cross compiling *should* work, but I have no tuits to explore that field :(

[20:16] <TBA> mberends: how easy is it to get linux running on an arm chip? been thinking about building a nas (just building a server room for it to go in lol) but not really looked at any of the details yet

[20:17] <Moukeddar> ok guys , thanks for all the help , and thanks for your time

[20:17] <TBA> jmp: lol didn't realise it was that bad...

[20:17] <tadzik> jmp___: it may never finish :)

[20:17] <Moukeddar> ttyl

[20:17] *** Moukeddar left
[20:17] <TBA> jmp, tadzik: is there room for optimisations or should we be, er, concerned about performance? lol

[20:17] <pmichaud> there's a ton of room for optimization

[20:17] <tadzik> TBA: yes, yes

[20:17] *** envi_laptop left
[20:18] <jmp___> i'm using a similar algorithm in both... wrote it in perl6 (my first perl6 program) and hand-converted into a perl5 similar  program

[20:18] <pmichaud> also, there are lots of pieces of the implementation (in both Rakudo and Parrot) that are far from optimal.  nom is trying to address a lot of those.

[20:18] <TBA> ah cool, just thinking 4 seconds to 5+ minutes seems quite a difference lol

[20:18] <jmp___> still, "early optimization is the root of all evil", eh?

[20:18] <jlaire> conclusion, don't use perl6 for finding primes

[20:18] <TBA> rofl

[20:19] <jmp___> jlaire... it does ok, for small primes

[20:19] <jmp___> TBA, it is still running... i really expect it to take about one hour.

[20:20] <pmichaud> jmp___: could you nopaste the code somewhere?

[20:20] <TBA> there any value to having a performance comparison test suite (i.e. a set of perl5/perl6 tests which achieve the same functionality)?

[20:20] <pmichaud> TBA: I suspect there's little point to that until rakudo gets about 10x faster

[20:21] <TBA> fair enough lol

[20:21] <jmp___> sure... (btw i did handicap p6 a little...oops off to the airport... i'll post code with results when i get back.... about 2 hours.... sorry

[20:21] <masak> 'night, #perl6.

[20:21] <pmichaud> later, masak

[20:21] <TBA> night masak

[20:21] <jnthn> 'night, masak

[20:21] *** masak left
[20:22] *** pothos_ joined
[20:22] *** y3llow_ joined
[20:22] *** stephanepayrard_ joined
[20:23] *** baest_ joined
[20:23] *** kst` joined
[20:23] <mberends> TBA: I don't know much about it, but there is a community for building NAS type embedded Linux at https://openwrt.org/ . Good luck there :)

[20:24] <TBA> mberends: thanks, will take a look there :)

[20:24] *** y3llow left
[20:24] *** y3llow_ is now known as y3llow

[20:24] *** pothos left
[20:24] *** pothos_ is now known as pothos

[20:25] *** TiMBuS|Away joined
[20:26] <pmichaud> TBA: maybe also see http://www.raspberrypi.org

[20:26] *** shachaf_ joined
[20:26] *** estrai_ joined
[20:26] *** jdv79 joined
[20:26] *** Sarten-X left
[20:26] *** xinming_ joined
[20:29] *** shachaf left
[20:29] *** shachaf_ is now known as shachaf

[20:29] <mberends> Oh, yes, saw that raspberrypi once before, very promising. It's still mainly in the planning and high cost prototyping stage, though. Futureware.

[20:29] *** TiMBuS left
[20:29] *** [Sec] left
[20:29] *** jevin left
[20:29] *** jlaire left
[20:29] *** baest left
[20:29] *** estrai left
[20:29] *** krunen left
[20:29] *** cognominal_ left
[20:29] *** PacoLinux left
[20:29] *** kst left
[20:29] *** xinming left
[20:29] *** jdv79_ left
[20:29] *** yath left
[20:29] *** PacoLinux_ joined
[20:29] *** PacoLinux_ is now known as PacoLinux

[20:30] *** TiMBuS|Away is now known as TiMBuS

[20:30] *** jlaire joined
[20:30] <TBA> pmichaud, mberends: the photo on their homepage shows it running ubuntu so looks promising

[20:30] <TBA> thanks again

[20:30] *** jevin joined
[20:30] <mberends> :)

[20:30] <pmichaud> raspberrypi also claims "late 2011"

[20:31] <pmichaud> "later in 2011"

[20:31] <pmichaud> although perhaps it's another DNF example :-)

[20:31] *** krunen joined
[20:31] <pmichaud> maybe it'll be ready in time for Christmas :-P

[20:31] *** hanekomu left
[20:32] *** silug left
[20:32] *** hanekomu joined
[20:32] *** silug joined
[20:33] *** Sarten-X joined
[20:34] *** yath joined
[20:34] <TBA> DNF?

[20:35] <mberends> Duke Nukem Forever

[20:35] <jlaire> or Did Not Finish

[20:35] <jlaire> used in some sports

[20:35] <TBA> ahh

[20:36] *** jlaire_ joined
[20:37] <pmichaud> "Duke Nukem Forever" is what I was referring to.  It won various vaporware awards for never being released

[20:37] *** jlaire_ left
[20:39] *** lumi left
[20:39] <mberends> The experimenter market that the raspberrypi is aiming at does not have the massive volumes that are required for very low manufacturing costs, so I think the challenge may be more financial than technical. The Blackberry PlayBook is only slightly ahead hardware-wise, will sell in greater volumes and for a much higher price.

[20:40] *** lumi joined
[20:42] <colomon> pmichaud: you know DNF comes out week after next, right?

[20:42] <pmichaud> colomon: yes, I do.  :)

[20:42] <colomon> :)

[20:43] <pmichaud> colomon: but it still wins the vaporware lifetime achievement award :)

[20:44] <TBA> hang on... let me get this right. raspberrypi have made a computer so small that you need a usb *hub* to connect basic devices like a mouse and keyboard... isn't this a little self defeatist?

[20:46] <mberends> aye, that is why they will appeal only to experimenters

[20:46] <TBA> seems insane. the combined size of the pc and the usb hub is bigger than if they'd just added a few extra usb ports. same for the power, it now requires 2 cables instead of 1...

[20:48] <TBA> anyway, best go, work @7am sucks lol, night #perl6!

[20:48] *** vlixes left
[20:48] <colomon> pmichaud: in my head, the award might go to Cyc.  Weren't they supposed to have revolutionized AI by 1995 or so?

[20:49] *** TBA left
[20:53] <colomon> Though I guess at least they haven't given up yet.

[20:54] <dalek> rakudo/nom: 9042f2d | jnthn++ | src/Perl6/Grammar.pm:

[20:54] <dalek> rakudo/nom: Fix <routine_def> calls in multi declarators.

[20:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9042f2dc81

[20:54] <dalek> rakudo/nom: bf1066c | jnthn++ | src/Perl6/ (2 files):

[20:54] <dalek> rakudo/nom: Get onlystar handling in place a little more, with a call into the (do be set up) multi-dispatcher.

[20:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf1066c662

[20:58] *** stephanepayrard_ left
[20:58] *** stephanepayrard_ joined
[21:00] *** silug left
[21:00] *** silug joined
[21:05] *** donri left
[21:05] <mberends> wow, v5.14 perl -Dx -E 'say "hello";' produces over 2200 lines of syntax tree dump

[21:06] <sorear> perl6: my $x = 12; (foo => $x).value++; say $x

[21:06] <p6eval> pugs, niecza v5-130-gc49e30c: OUTPUT«13␤»

[21:06] <p6eval> ..rakudo 048573: OUTPUT«12␤»

[21:06] *** TiMBuS left
[21:06] <sorear> if pugs agrees, then Rakudo is probably wrong here

[21:06] * sorear fixes the test

[21:06] *** silug left
[21:07] *** TiMBuS joined
[21:07] <colomon> jnthn: what do we need to get string / int constants working?

[21:07] <jnthn> colomon: I already did that earlier today :)

[21:07] <colomon> jnthn++

[21:08] <colomon> \o/

[21:08] *** silug joined
[21:08] <colomon> you spend your time at parades and picnics, you miss some things.

[21:08] <sorear> perl6: (foo => 12).value++;

[21:08] <p6eval> niecza v5-130-gc49e30c: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/DOSwHAYfly line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1438 (CORE C638_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1439 (CORE module-CORE @ 42) ␤  at

[21:08] <p6eval> ../home/p6eval/niecza/lib/CORE.…

[21:08] <p6eval> ..rakudo 048573:  ( no output )

[21:08] <p6eval> ..pugs: OUTPUT«*** Can't modify constant item: VInt 12␤    at /tmp/P_TNSl5jYD line 1, column 1-20␤»

[21:10] <dalek> rakudo/nom: 91ec2d0 | jnthn++ | NOMMAP.markdown:

[21:10] <dalek> rakudo/nom: Update nommap.

[21:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/91ec2d0de3

[21:10] <colomon> jnthn: so the answer to my question was, "party while jnthn does all the work."  works for me!

[21:10] <jnthn> sorear: uh, given Rakudo tends to be more up to date than Pugs, "if Pugs agrees" is probably not the best assumption. :/

[21:11] *** Sarten-X left
[21:12] *** jaldhar left
[21:12] *** lumi left
[21:13] *** lumi joined
[21:14] *** jaldhar joined
[21:15] *** gbacon left
[21:15] *** mberends left
[21:16] <sorear> jnthn: I can't find it either way in the spec and the Rakudo behavior seems distinctly less useful to me

[21:19] *** Sarten-X joined
[21:21] *** silug left
[21:22] *** silug joined
[21:27] *** silug left
[21:27] *** cooper left
[21:28] *** silug joined
[21:34] *** pernatiy left
[21:34] *** silug left
[21:35] *** silug joined
[21:35] <sorear> niecza: say NaN; # oops!

[21:35] <p6eval> niecza v5-130-gc49e30c: OUTPUT«Infinity␤»

[21:39] <tadzik> funny

[21:39] *** lumi left
[21:41] *** lumi joined
[21:46] *** Psyche^ joined
[21:49] *** Patterner left
[21:49] *** Psyche^ is now known as Patterner

[21:49] <dalek> niecza: c8fbbef | sorear++ | t/spectest.data:

[21:49] <dalek> niecza: Remove accidentally passing and in spec limbo test files from list

[21:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c8fbbef3c2

[21:49] <dalek> niecza: 34b68ce | sorear++ | / (2 files):

[21:49] <dalek> niecza: Fix NaN handling after numerics overhaul

[21:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/34b68cec2a

[21:49] <dalek> roast: 01c8d9e | sorear++ | S32-hash/pairs.t:

[21:49] <dalek> roast: [S32-hash/pairs] explicitly rw-ize pair elements for niecza and pugs

[21:49] <dalek> roast: review: https://github.com/perl6/roast/commit/01c8d9e402

[21:50] *** araujo joined
[21:50] *** araujo left
[21:50] *** araujo joined
[21:50] *** PacoLinux left
[21:51] *** Sarten-X left
[21:51] *** Ali_h left
[21:56] *** Ali_h joined
[22:01] <dalek> roast: 1c7477c | sorear++ | S03-metaops/hyper.t:

[22:01] <dalek> roast: Add a few #?DOES to hyper.t and move it to done; for good measure

[22:01] <dalek> roast: review: https://github.com/perl6/roast/commit/1c7477c6db

[22:03] *** slavik joined
[22:04] *** Sarten-X joined
[22:07] <dalek> rakudo/nom: 2f29d66 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[22:07] <dalek> rakudo/nom: Need a place for the dispatcher to hang any extra info it needs.

[22:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f29d6692a

[22:07] <dalek> rakudo/nom: 82d35af | jnthn++ | src/binder/multidispatch.h:

[22:07] <dalek> rakudo/nom: Move various multi-dispatch data structures into a header file, plus way that we'll be able to get at the dispatcher list, dispatcher info stash and so forth.

[22:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/82d35af306

[22:07] * jnthn has more partially done bits locally

[22:07] <jnthn> May get multi dispatch back in place, or at least basic case of it, tomorrow. :)

[22:08] *** slavik left
[22:08] *** lumi left
[22:08] *** lumi joined
[22:14] *** ethan_1 joined
[22:20] *** [Sec] joined
[22:21] <colomon> jnthn: what's the status on operators?

[22:22] *** bacek left
[22:23] <jnthn> colomon: Need multiple dispatch first.

[22:23] *** silug left
[22:23] <colomon> k

[22:24] <colomon> > 4

[22:24] <colomon> get_string() not implemented in class 'SixModelObject'

[22:24] <jnthn> That will land either tomorrow or Wednesday.

[22:24] <colomon> jnthn++

[22:24] <jnthn> That get_string thing will need Parrot v-table mapping trait in place.

[22:25] <jnthn> Again, not hard, jut didn't get there yet :)

[22:25] <colomon> so not solvable by a quick method in Int.pm?  (which I haven't looked in yet, been cooking dinner)

[22:26] * colomon is chomping at the bit to be useful....

[22:26] <jnthn> No, it's not that.

[22:26] <colomon> afk, noms

[22:26] <jnthn> Well, if you can work out how to get num values computed in NQP then you can get Num literals in along the same lines as Int ones. I already did a chunk of the work.

[22:31] *** lumi left
[22:32] *** lumi joined
[22:36] <dalek> niecza: 02ec23f | sorear++ | src/ (7 files):

[22:36] <dalek> niecza: Mergeback

[22:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/02ec23fe8b

[22:42] *** pjcj left
[22:42] *** pjcj joined
[22:55] *** pjcj left
[22:55] *** pjcj joined
[22:59] *** Sarten-X left
[23:00] *** lumi left
[23:01] *** jaldhar left
[23:01] <sorear> kumpera++ # fixing the GC+dynamic code gen bug I found the other day

[23:02] *** jaldhar joined
[23:02] <dalek> niecza: 614215a | sorear++ | / (2 files):

[23:02] <dalek> niecza: Update to v6 bootstrap

[23:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/614215a441

[23:03] *** lumi joined
[23:05] <sorear> v6 announce pushed

[23:06] *** MayDaniel left
[23:08] *** Sarten-X joined
[23:10] <jmp___> the first 78K primes (those < 1_000_000) calc by p6 from a couple of hours ago is still running .... I'm going to cancel it, take out a terminal 'say' where it prints out all the primes it has found and start it over for a smaller set, maybe those less than 100_000, that should only take a few minutes.

[23:12] <sorear> niecza: my @primes = 2; CANDIDATE: for 2..1_000_000 -> $i { for @primes -> $p { last if $p * $p > $i; next CANDIDATE if $i %% $p }; push @primes, $i }; say @primes[*-1]

[23:12] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:13] <sorear> niecza: my @primes = 2; CANDIDATE: for 2..1_000 -> $i { for @primes -> $p { last if $p * $p > $i; next CANDIDATE if $i %% $p }; push @primes, $i }; say @primes[*-1]

[23:13] <p6eval> niecza v5-132-g34b68ce: OUTPUT«997␤»

[23:13] <sorear> niecza: my @primes = 2; CANDIDATE: for 2..100_000 -> $i { for @primes -> $p { last if $p * $p > $i; next CANDIDATE if $i %% $p }; push @primes, $i }; say @primes[*-1]

[23:13] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:13] <sorear> niecza: my @primes = 2; CANDIDATE: for 2..^50_000 -> $i { for @primes -> $p { last if $p * $p > $i; next CANDIDATE if $i %% $p }; push @primes, $i }; say @primes[*-1]

[23:14] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:14] <jlaire> eratosthenes' sieve is a bit faster

[23:14] <jlaire> than trial division

[23:14] <jmp___> much better than mine ($p*$p > $i) better than my silly sqrt($i) ....

[23:16] <jmp___> hey... i had problems with @primes-> $p construct, i had to use @primes.list->$p ....

[23:16] <jlaire> but really, that type of code is probably where perl6 is the most inefficient at, and even perl5 is orders of magnitude slower than C

[23:16] <sorear> niecza: my $MAX = 50_000; my @primes; my @sieve; CANDIDATE: for 2..^$MAX -> $i { next if @seive[$i]; loop (my $j = $i; $j < $MAX; $j += $i) { @sieve[$j] = True }; push @primes, $i }; say @primes[*-1];

[23:17] <p6eval> niecza v5-132-g34b68ce: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable @seive is not predeclared at /tmp/ZKmL0IayIf line 1:␤------> [32mCANDIDATE: for 2..^$MAX -> $i { next if [33m⏏[31m@seive[$i]; loop (my $j = $i; $j < $MAX;[0m␤␤Unhandled exception: Check failed␤␤  at

[23:17] <p6eval> ../home/p6eval/niecza/boot/lib/CORE.sett…

[23:17] <sorear> niecza: my $MAX = 50_000; my @primes; my @sieve; CANDIDATE: for 2..^$MAX -> $i { next if @sieve[$i]; loop (my $j = $i; $j < $MAX; $j += $i) { @sieve[$j] = True }; push @primes, $i }; say @primes[*-1];

[23:17] <p6eval> niecza v5-132-g34b68ce: OUTPUT«49999␤»

[23:17] <sorear> niecza: my $MAX = 500_000; my @primes; my @sieve; CANDIDATE: for 2..^$MAX -> $i { next if @sieve[$i]; loop (my $j = $i; $j < $MAX; $j += $i) { @sieve[$j] = True }; push @primes, $i }; say @primes[*-1];

[23:17] *** lumi__ joined
[23:17] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:17] <jlaire> you can start $j at $i*$i

[23:17] <jmp___> are bit types out yet? specifically, can we do bitbuffers yet?

[23:17] <sorear> 49999 does not look like a prime number

[23:17] <jlaire> sorear: it is

[23:18] <jlaire> factor 49999

[23:18] <jlaire> 49999: 49999

[23:18] <sorear> niecza: my $MAX = 500_000; my @primes; my @sieve; CANDIDATE: for 2..^$MAX -> $i { next if @sieve[$i]; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; push @primes, $i }; say @primes[*-1];

[23:18] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:19] <sorear> well I do have something new for an optimization target now

[23:19] <sorear> :)

[23:19] <sorear> niecza: my $MAX = 200_000; my @primes; my @sieve; CANDIDATE: for 2..^$MAX -> $i { next if @sieve[$i]; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; push @primes, $i }; say @primes[*-1];

[23:19] <dalek> nqp: e08c5ca | jonathan++ | docs/6model/ (2 files):

[23:19] <dalek> nqp: Add a little 6model documentation.

[23:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e08c5cac2c

[23:19] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:19] <sorear> hmm

[23:20] <jlaire> a common optimization is to special case 2 and 3 and only loop through numbers that are 1 or 5 mod 6

[23:20] *** lumi left
[23:21] <jmp___> since Perl6 is OO, and we don't yet have primitives, are the members of an array treated as Num or Int objects that have to be autoboxed?

[23:21] <jmp___> that could slow things down by a factor of 5 or more, i'd guess....

[23:21] <sorear> niecza: my $MAX = 200_000; my @primes; my $t1 = times[0]; my %sieve; for 2..^$MAX -> $i { next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True }; push @primes, $i }; say @primes[*-1]; say times[0] - $t1;

[23:21] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)144446␤»

[23:21] <jmp___> for computation heavy items like this

[23:21] <sorear> jmp___: yes, that's one of the main problems

[23:22] <sorear> jmp___: yes, that's one of the main problems

[23:22] <sorear> niecza: my $MAX = 200_000; my @primes; my $t1 = times[0]; my %sieve; for 2..^$MAX -> $i { next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True }; push @primes, $i }; say @primes[*-1]; say times[0] - $t1;

[23:22] <p6eval> niecza v5-132-g34b68ce: OUTPUT«199999␤7.172448␤»

[23:22] <sorear> it should be possible to use my bool @sieve; my int @primes and avoid most of that

[23:22] <jmp___> ok, its way too early to start "optimizing" then, as someone said earlier, we're still pessimizing for a while....

[23:22] <sorear> 7.2 seconds for 200k primes to sieve

[23:22] <sorear> not terrible

[23:23] <jlaire> more than enough for most use cases :)

[23:23] <jmp___> primes under 200K, yes? 

[23:23] <sorear> niecza: my $MAX = 200_000; my @primes = 2,3; my $t1 = times[0]; my %sieve; for map { $_*6 + 1, $_*6 + 5 } ^($MAX/6) -> $i { next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True }; push @primes, $i }; say @primes[*-1]; say times[0] - $t1;

[23:23] <jlaire> sorear: how much memory would  my bool @sieve;  use per item?

[23:23] *** wamba left
[23:24] <p6eval> niecza v5-132-g34b68ce: OUTPUT«Unhandled exception: Junctions NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 469 (CORE die @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1324 (CORE infix:<^> @ 2) ␤  at /tmp/6oMCutNBgY line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting

[23:24] <p6eval> ..line 1438 (CORE…

[23:24] <sorear> jlaire: 1 bit *waves hands*

[23:24] <jlaire> awesome

[23:24] <sorear> niecza: my $MAX = 200_000; my @primes = 2,3; my $t1 = times[0]; my %sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True }; push @primes, $i }; say @primes[*-1]; say times[0] - $t1;

[23:24] <p6eval> niecza v5-132-g34b68ce: OUTPUT«200003␤2.984187␤»

[23:24] <jmp___> you could use a bit buffer, too, as it treats contiguous storage like one ginormous integer

[23:24] <jlaire> I want to solve project eulers in perl6 now

[23:25] <sorear> I'm suprised and a little irritated that storing the sieve in a hash is faster

[23:25] <sorear> niecza: my $MAX = 500_000; my @primes = 2,3; my $t1 = times[0]; my %sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True }; push @primes, $i }; say @primes[*-1]; say times[0] - $t1;

[23:25] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:25] <jmp___> less memory

[23:25] <jlaire> sorear: try replacing @primes with just $max-prime and print that at the end

[23:26] <jnthn> sleep &

[23:26] <sorear> niecza: my $MAX = 200_000; my $max-prime; my $t1 = times[0]; my %sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { $max-prime = $i; next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True } }; say $max-prime; say times[0] - $t1;

[23:26] <p6eval> niecza v5-132-g34b68ce: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Confused at /tmp/lkgHdXNVEf line 1:␤------> [32m < $MAX; $j += $i) { %sieve{$j} = True }[33m⏏[31m }; say $max-prime; say times[0] - $t1;[0m␤␤Parse failed␤␤»

[23:26] <sorear> niecza: my $MAX = 200_000; my $max-prime; my $t1 = times[0]; my %sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { $max-prime = $i; next if %sieve{$i}:exists; loop (my $j = $i*$i; $j < $MAX; $j += $i) { %sieve{$j} = True }; }; say $max-prime; say times[0] - $t1;

[23:26] <p6eval> niecza v5-132-g34b68ce: OUTPUT«200003␤2.832177␤»

[23:27] <jlaire> so that makes no difference

[23:27] <sorear> niecza: my $MAX = 200_000; my $max-prime; my $t1 = times[0]; my @sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { $max-prime = $i; next if @sieve[$i]; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:27] <p6eval> niecza v5-132-g34b68ce: OUTPUT«200003␤2.436153␤»

[23:27] <jlaire> the way you loop through 1,5 mod 6 is really neat

[23:27] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { $max-prime = $i; next if @sieve[$i]; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:28] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:28] <jmp___> which is better for work with perl6, Ubuntu or Fedora, or is there a better? my Mac interface just isn't quite up to pare for cutting and pasting...

[23:28] <jmp___> i'm gonna stick a VirtualBox on my Mac and plant a Linux there... Suggestions?

[23:28] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { $max-prime = $i; next if @sieve[$i];  }; say $max-prime; say times[0] - $t1;

[23:28] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:29] <sorear> I've been using Debian since 2003...no comment

[23:29] <jlaire> arch here, but I don't think the distro matters much

[23:29] <jlaire> use whatever you like most

[23:29] <jmp___> sounds good. thanks.

[23:29] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; for (map { $_*6 + 1, $_*6 + 5 }, ^($MAX/6)) -> $i { $max-prime = $i; next if @sieve[$i];  }; say $max-prime; say times[0] - $t1;

[23:30] <p6eval> niecza v5-132-g34b68ce: OUTPUT«(timeout)»

[23:30] *** Sarten-X left
[23:35] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; my @ok = 0,1,0,0,0,1; loop (my $i = 0; $i < $MAX; $i++) { next unless @ok[$i % 6]; $max-prime = $i; next if @sieve[$i];  }; say $max-prime; say times[0] - $t1;

[23:35] <p6eval> niecza v6: OUTPUT«499999␤2.356147␤»

[23:35] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; my @ok = 0,1,0,0,0,1; loop (my $i = 0; $i < $MAX; $i++) { next unless @ok[$i % 6]; $max-prime = $i; next if @sieve[$i]; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:35] <p6eval> niecza v6: OUTPUT«499999␤4.012251␤»

[23:36] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; my @ok = 0,1,0,0,0,1; loop (my $i = 0; $i < $MAX; $i++) { next unless @ok[$i % 6]; next if @sieve[$i]; $max-prime = $i; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:36] <p6eval> niecza v6: OUTPUT«1␤4.060253␤»

[23:37] *** Sarten-X joined
[23:37] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; my @ok = 0,1,0,0,0,1; loop (my $i = 6; $i < $MAX; $i++) { next unless @ok[$i % 6]; next if @sieve[$i]; $max-prime = $i; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:37] <p6eval> niecza v6: OUTPUT«499979␤4.500281␤»

[23:37] <sorear> niecza: my $MAX = 1_000_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; my @ok = 0,1,0,0,0,1; loop (my $i = 6; $i < $MAX; $i++) { next unless @ok[$i % 6]; next if @sieve[$i]; $max-prime = $i; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:38] <p6eval> niecza v6: OUTPUT«(timeout)»

[23:40] *** hanekomu left
[23:41] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my $ct = -$MAX; push @sieve, False while $ct++; my @adv = 0,4,0,0,0,2; loop (my $i = 5; $i < $MAX; $i += @adv[$i % 6]) { next if @sieve[$i]; $max-prime = $i; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:41] <p6eval> niecza v6: OUTPUT«499979␤2.940184␤»

[23:42] <sorear> niecza: my $MAX = 500_000; my $max-prime; my $t1 = times[0]; my @sieve; my @adv = 0,4,0,0,0,2; loop (my $i = 5; $i < $MAX; $i += @adv[$i % 6]) { next if @sieve[$i]; $max-prime = $i; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:42] <p6eval> niecza v6: OUTPUT«499979␤2.052128␤»

[23:42] <jmp___> wow

[23:42] <sorear> niecza: my $MAX = 1_000_000; my $max-prime; my $t1 = times[0]; my @sieve; my @adv = 0,4,0,0,0,2; loop (my $i = 5; $i < $MAX; $i += @adv[$i % 6]) { next if @sieve[$i]; $max-prime = $i; loop (my $j = $i*$i; $j < $MAX; $j += $i) { @sieve[$j] = True }; }; say $max-prime; say times[0] - $t1;

[23:42] <p6eval> niecza v6: OUTPUT«999983␤4.15626␤»

[23:42] <sorear> \o/

[23:42] <jmp___> you must have something up your sieve...

[23:43] *** Sarten-X left
[23:44] <jlaire> niiiice

[23:44] <jmp___> i'm emailing myself that last one, so that i can cut and paste it later.... thanks, sorear

[23:45] *** molaf_ joined
[23:46] <sorear> jmp___: I've spent basically the last year working on Perl 6 optimization technology

[23:47] *** ethan_1 left
[23:47] <jmp___> it showed

[23:49] *** molaf left
[23:49] *** Sarten-X joined
[23:51] *** jaldhar left
[23:51] <sorear> things I have up my sleeve: an implementation which is less complete than, but faster than, Rakudo.  Detailed knowledge of exactly what is supported in this implementation and how relatively fast different operations are in it.

[23:52] <jdhore1> I'm surprised no one's working on a pure C, P5-style implementation of P6

[23:52] <jmp___> someone mentioned one for a couple of small processors, earlier...

[23:53] <jdhore1> ah

[23:53] <sorear> jdhore1: the answer to this has two parts

[23:53] <sorear> jmp___: I think that was a Perl->C translator, not a C interpreter

[23:54] <sorear> 1. Perl 6 is specced such that the only reasonable way to parse it is with a Perl 6 grammar

[23:54] <jmp___> 13:10] <mberends> TBA: parrrot and rakudo make a 50MB process, that is way beyond any avr hardware. I am working on a perl 6 subset -> C translator (perlduino) whose output can be compiled by avrgcc, but only parts of it are written. It's taking a lot of my time ;)

[23:54] *** lumi__ left
[23:55] <jdhore1> sorear, ah, what's the second reason?

[23:55] <sorear> 2. I've thought a couple times about writing a C bytecode interpreter, but decided that if I'm going to rewrite Parrot, I'd use my time more effectively by hijacking the existing Parrot rewrite

[23:55] *** lumi joined
[23:57] <jmp___> jdhorel, was that earlier entry from mberends in any way bearing on your query? i'm so new here and to the Perl community at large that I don't always savvy what is salient

[23:57] *** Chillance left
[23:58] <sorear> ruoso wrote a custom VM (although he refuses to call it one) for Perl 6 once

[23:58] <sorear> in C

