[00:00] <TimToady> with count of 1

[00:00] <jlaire> I see

[00:00] *** Trashlord left
[00:00] <TimToady> probably just not implemented on coercions yet

[00:01] <TimToady> rakudo: say (1,2,3).map: *.sqrt

[00:01] <p6eval> rakudo 72d158: OUTPUT«11.41421356237311.73205080756888␤»

[00:01] <TimToady> works on ordinary methods though

[00:01] <TimToady> coercers are special

[00:02] <jlaire> rakudo: say (1,2,3).map: { $^a.Str.What }

[00:02] <p6eval> rakudo 72d158:  ( no output )

[00:03] <jlaire> rakudo: say (1,2,3).map: { $^a.Str.WHAT }

[00:03] <p6eval> rakudo 72d158: OUTPUT«Str()Str()Str()␤»

[00:03] <jlaire> wfm

[00:04] <jnthn> nom: say (*.Str).WHAT

[00:04] <p6eval> nom: OUTPUT«Str()␤»

[00:04] <jnthn> hmm

[00:05] <jnthn> nom: say (*.perl).WHAT

[00:05] <p6eval> nom: OUTPUT«Str()␤»

[00:05] <jnthn> nom: say (*.foo).WHAT

[00:05] <p6eval> nom: OUTPUT«Method 'foo' not found for invocant of class 'Whatever'␤current instr.: '_block1002' pc 83 ((file unknown):57853675) (/tmp/M2y4KnGEGz:1)␤»

[00:05] <TimToady> looks like it's coercing * to Str

[00:05] <jnthn> I think the *.foo form you ain't implemented.

[00:05] <jnthn> s/you/just/

[00:06] *** dorlamm left
[00:06] <TimToady> oh, I did it on rakudo, duh

[00:06] <TimToady> nom: say (1,2,3).map: *.sqrt

[00:06] <p6eval> nom: OUTPUT«Method 'sqrt' not found for invocant of class 'Whatever'␤current instr.: '_block1002' pc 108 ((file unknown):68060911) (/tmp/C3BLzsPzm_:1)␤»

[00:06] <TimToady> yep, nyi

[00:09] * jnthn forgets how that's meant to work

[00:09] <jnthn> I have this memory of it fiddling with method dispatch or something :)

[00:11] <TimToady> it needs to be macro-y like other affixes, or *.foo(args()) evaluates args too soon

[00:11] <jnthn> ah

[00:12] * jnthn wonders if master gets that right

[00:12] <TimToady> has to rewrite to { .foo(args) }

[00:12] <jnthn> Think it dod

[00:12] <jnthn> *did

[00:12] <jnthn> yeah

[00:12] <jnthn> makes sense.

[00:12] <jnthn> OK, good. That's better than fiddling dispatch. :)

[00:12] <jnthn> Now junctions, OTOH... :)

[00:12] <TimToady> have to be dispatchy

[00:12] <jnthn> yeah

[00:12] <jnthn> Didn't do that bit of auto-threading yet

[00:12] <TimToady> since the whole point is to subvert the type system :)

[00:12] * jnthn gets curious

[00:13] <jnthn> nom: my @a = 1,2,3,4; say @a[1|2]

[00:13] <p6eval> nom: OUTPUT«any(2, 3)␤»

[00:13] <jnthn> \o/

[00:13] <jnthn> rakudo: my @a = 1,2,3,4; say @a[1|2]

[00:13] <p6eval> rakudo 72d158: OUTPUT«any(2, 3)␤»

[00:13] <jnthn> oh, it did work before

[00:13] <jnthn> Nice that it still does, then :)

[00:14] <jlaire> rakudo: say +(().map: *.foo(die()))

[00:14] <p6eval> rakudo 72d158: OUTPUT«0␤»

[00:14] <sorear> nom: my %a = :a, :b, :c; say ?( %a{any 'b', 'd'}:exists )

[00:14] <p6eval> nom: OUTPUT«Unsupported use of ?: for the conditional operator; in Perl 6 please use ??!! at line 1, near "( %a{any '"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23533 (src/stage2/gen/NQPHLL.pir:6314) (src/stage2/gen/NQPHLL.pm:328)␤»

[00:14] <sorear> wha?

[00:15] <jnthn> It's a good guess for a parser that doesn't do operator advergs :)

[00:15] <jlaire> nom: my %a = :a, :b, :c; say (?( %a{any 'b', 'd'}:exists ))

[00:15] <p6eval> nom: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3851 (src/Regex/Cursor.pir:239)␤»

[00:15] <tadzik> std: my %a = :a, :b, :c; say ?( %a{any 'b', 'd'}:exists )

[00:15] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 123m␤»

[00:15] <sorear> jnthn: does it do ? at all?

[00:15] <TimToady> but it should not be expecting an infix there

[00:15] <jlaire> nom: say ?0

[00:15] <TimToady> so must be inadvertent backtracking

[00:15] <p6eval> nom: OUTPUT«Bool::False␤»

[00:16] <jnthn> TimToady: No, something curious is up there

[00:17] <dalek> niecza: bcc1cf3 | sorear++ | / (2 files):

[00:17] <dalek> niecza: Optimize $*foo to a direct fetch if $*foo is declared in the current frame or inline caller

[00:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bcc1cf37bc

[00:17] <TimToady> it's gotta be the check for ?: is firing as if there are no args to say

[00:18] <TimToady> it's probably looking for ?\N*: or some such, and ignoring parens

[00:18] <TimToady> but it should commit to ? being prefix

[00:18] <jnthn> yeah, probably

[00:18] <dalek> rakudo/nom: 4677323 | jonathan++ | LHF.markdown:

[00:18] <dalek> rakudo/nom: A few more bits of LHF.

[00:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/46773231f1

[00:18] <dalek> rakudo/nom: e42b089 | jonathan++ | src/Perl6/Actions.pm:

[00:18] <dalek> rakudo/nom: Fix a few compile-os. Of note, this gets default { ... } to work again.

[00:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e42b0894da

[00:18] <TimToady> hence, a backtracking problem, likley

[00:18] <TimToady> nice work, likley...

[00:19] <jnthn> :P

[00:19] <jnthn> OK, enough for today

[00:19] <jnthn> mix-ins tomorrow...and maybe BEGIN

[00:20] <TimToady> o/

[00:20] <jnthn> night o/ 

[00:31] *** cooper left
[00:39] *** GodFather left
[00:47] <jlaire> rakudo: class C { has $.a }; sub f { C.new }; my $c = f(); $c.a = 1; say 'alive'

[00:47] <p6eval> rakudo 72d158: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in main program body at line 22:/tmp/wGhepu1eqI␤»

[00:47] <jlaire> rakudo: class C { has $.a }; sub f { C.new }; my $c = C.new; $c.a = 1; say 'alive'

[00:47] <p6eval> rakudo 72d158: OUTPUT«Cannot modify readonly value␤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in main program body at line 22:/tmp/JPxh0IW40q␤»

[00:48] <jlaire> rakudo: class C { has $.a is rw }; sub f { C.new }; my $c = f(); $c.a = 1; say $c.a

[00:48] <p6eval> rakudo 72d158: OUTPUT«1␤»

[00:48] <jlaire> oic

[00:50] <ciphertext> \reload

[00:51] <tadzik> perl6: say &infix:<%%>(5)

[00:51] <p6eval> niecza v7-21-gbcc1cf3: OUTPUT«Unhandled exception: No value for parameter $y in CORE infix:<%%>␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE infix:<%%> @ 0) ␤  at /tmp/n0UDRdbjj1 line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_ANON @ …

[00:51] <p6eval> ..rakudo 72d158: OUTPUT«No applicable candidates found to dispatch to for 'infix:<%%>'. Available candidates are:␤:(Any $a, Any $b)␤␤  in main program body at line 22:/tmp/XBbtxBiEOx␤»

[00:51] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&infix:%%"␤    at /tmp/C7epqlg7sN line 1, column 5 - line 2, column 1␤»

[00:58] *** george_z0rwell is now known as Haskelletor

[01:00] *** noganex joined
[01:04] *** noganex_ left
[01:12] <dalek> rakudo/nom: f83f8ce | tadzik++ | / (3 files):

[01:12] <dalek> rakudo/nom: Implement infix:<%%>, run tests

[01:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f83f8ce1fd

[01:28] *** [Coke] left
[01:30] *** [Coke] joined
[01:33] <jlaire> perl6: sub f(Int $x) { $x }; say (1,2,3).map: f(*)

[01:33] <p6eval> rakudo 72d158: OUTPUT«Nominal type check failed for parameter '$x'; expected Int but got Whatever instead␤  in 'f' at line 1:/tmp/WnmHo4vGB8␤  in main program body at line 22:/tmp/WnmHo4vGB8␤»

[01:33] <p6eval> ..niecza v7-21-gbcc1cf3: OUTPUT«Unhandled exception: Nominal type check failed in binding Int $x in MAIN f; got Whatever, needed Int␤  at /tmp/71jzxXbX8r line 0 (MAIN f @ 0) ␤  at /tmp/71jzxXbX8r line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_AN…

[01:33] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VList [VNum Infinity] to Pugs.AST.Types.VCode (VCode)␤    at /tmp/zsiXiaK1zO line 1, column 27 - line 2, column 1␤»

[01:33] <jlaire> perl6: sub f(Int $x) { $x }; say (1,2,3).map: { f($^a) }

[01:33] <p6eval> pugs, rakudo 72d158, niecza v7-21-gbcc1cf3: OUTPUT«123␤»

[01:33] <jlaire> funny

[01:35] <jlaire> perl6: sub f(Int $x) { $x }; say (1,2,3).map: &f

[01:35] <p6eval> pugs, rakudo 72d158, niecza v7-21-gbcc1cf3: OUTPUT«123␤»

[01:35] <jlaire> ah

[01:35] <jlaire> KISS

[01:42] *** jevin left
[01:43] *** colomon joined
[01:47] *** kst joined
[01:57] *** whiteknight joined
[02:00] *** wknight8111 joined
[02:13] *** wknight8111 left
[02:46] *** cognominal left
[02:48] *** cognominal joined
[02:49] *** whiteknight left
[02:57] *** cooper joined
[02:57] *** Chillance left
[03:12] *** jack-ji joined
[03:12] *** ymasory joined
[03:22] *** Quadrescence joined
[03:24] *** Su-Shee left
[03:27] *** Quadrescence left
[03:28] *** Su-Shee joined
[03:31] *** ymasory left
[03:51] *** tokuhir__ joined
[03:56] *** donri left
[04:17] *** mberends left
[04:26] *** donri joined
[04:34] <daniel-s> rakudo: (1,2,3).WHAT.say;

[04:34] <p6eval> rakudo 72d158: OUTPUT«Parcel()␤»

[04:34] <daniel-s> rakudo: [1,2,3].WHAT.say;

[04:34] <p6eval> rakudo 72d158: OUTPUT«Array()␤»

[05:01] *** daniel-s left
[05:02] *** daniel-s joined
[05:10] *** daniel-s left
[05:15] <soh_cah_toa> rakudo: Bool::False // say "Foo"

[05:15] <p6eval> rakudo 72d158:  ( no output )

[05:15] <soh_cah_toa> rakudo: Bool::False || say "Foo"

[05:15] <p6eval> rakudo 72d158: OUTPUT«Foo␤»

[05:17] <soh_cah_toa> rakudo: my $a = undef; $a // say "\$a is undefined";

[05:17] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤  Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  Nil as an empty list,␤  !*.defined as a matcher or method,␤     Any:U as a type constraint␤     or…

[05:18] <soh_cah_toa> that can't be right :\

[05:18] <soh_cah_toa> nom: my $a = undef; $a // say "\$a is undefined";

[05:18] <p6eval> nom: OUTPUT«Unsupported use of undef as a value; in Perl 6 please use something more specific:␤ Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  Nil as an empty list,␤  !*.defined as a matcher or method,␤     Any:U as a type constraint␤     or fail() as a failure re…

[05:19] <benabik> rakudo: * // say "* is undef"

[05:19] <p6eval> rakudo 72d158:  ( no output )

[05:19] <TimToady> you probably want Nil for uniniting something

[05:19] <TimToady> nom: my $a = Nil; $a // say "\$a is undefined";

[05:19] <p6eval> nom: OUTPUT«$a is undefined␤»

[05:19] <soh_cah_toa> interesting

[05:19] <TimToady> nom: my $a = 42; $a = Nil; $a // say "\$a is undefined";

[05:19] <p6eval> nom: OUTPUT«$a is undefined␤»

[05:20] <pmichaud> there's also   undefine($a)

[05:20] <benabik> TimToady: Why Nil (empty list) instead of Undef?

[05:20] <soh_cah_toa> i thought $a // $b was shorthand for defined $a ?? $a !! $b

[05:20] <TimToady> becuase undef is an overload concept, and means too many completely different things in P5

[05:21] <TimToady> soh_cah_toa: it is

[05:21] <TimToady> my $a = Int; $a // say "\$a is undefined";

[05:21] <TimToady> nom: my $a = Int; $a // say "\$a is undefined";

[05:21] <p6eval> nom: OUTPUT«$a is undefined␤»

[05:21] <TimToady> our undefs are typed

[05:22] <TimToady> my Int $x; say $x.WHAT

[05:22] <TimToady> nom: my Int $x; say $x.WHAT

[05:22] <p6eval> nom: OUTPUT«Int()␤»

[05:23] <pmichaud> nom:  my Int $x;  say $x;  # curious

[05:23] <p6eval> nom: OUTPUT«Int()␤»

[05:23] <pmichaud> :-D

[05:23] <TimToady> but Nil represents the concept of 'not enough arguments'

[05:24] <soh_cah_toa> when you say undef's are typed, you mean I can do: my Undef $a; ?

[05:24] <TimToady> so it's not really an object, like Int or Mu

[05:24] <TimToady> only if you were to define an Undef type

[05:24] <soh_cah_toa> right

[05:24] <TimToady> Mu is the closest thing you can assign as the type of an object

[05:25] <TimToady> since it's the top of the type hierarchy (like Object in Java), it's the least defined

[05:25] <TimToady> it's actually something outside of an object, in a sense

[05:25] <soh_cah_toa> i see

[05:25] <TimToady> Mu is more of a concept

[05:26] <TimToady> Any is really the first type that is a real object

[05:26] <TimToady> Mu also contains things like Junction, which is more like a linguistic construct

[05:26] <soh_cah_toa> what does Mu stand for?

[05:27] <TimToady> it's overloaded

[05:27] <TimToady> "Most Undefined"

[05:27] <TimToady> the Zen concept of nonthingness

[05:27] <TimToady> and, of course, what a cow says

[05:27] <benabik> µ

[05:27] <soh_cah_toa> yeah, it is very zen. i was just thinking that

[05:27] <soh_cah_toa> rakudo: my $a = 1; $a = undef; say $a.WHAT;

[05:28] <p6eval> rakudo 72d158: OUTPUT«===SORRY!===␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤  Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  Nil as an empty list,␤  !*.defined as a matcher or method,␤     Any:U as a type constraint␤     or…

[05:28] * offby1 claps one hand

[05:28] <soh_cah_toa> right, good

[05:28] <benabik> What's an `is rw` routine?  Returns an lvalue?

[05:28] *** daniel-s joined
[05:28] <pmichaud> benabik: yes

[05:28] <TimToady> Perl 6 has many kinds of nothing, just as it has interesting values of failure

[05:29] <soh_cah_toa> indeed

[05:29] <TimToady> but the type objects like Int or Any are so that you can reason linguistically about generic objects without actually having one

[05:30] <TimToady> "Socrates is a Man"

[05:30] <TimToady> in P6 is more like $socrates ~~ Man

[05:31] <TimToady> so P6 doesn't really have class objects like other OO languages

[05:31] <TimToady> since the "class" objects are the same type, just uninstantiated

[05:32] <TimToady> rakudo: my Any $x; say $x.defined; $x .= new; say $x.defined

[05:32] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤Bool::True␤»

[05:32] <benabik> Watching nom's progress is really teaching me a lot about P6 syntax.

[05:33] <soh_cah_toa> wow, i've never heard of any object system like that before

[05:33] <TimToady> have you looked at Haskell?

[05:33] <TimToady> it's kinda like Just vs Maybe types

[05:34] <soh_cah_toa> no. why is it's oo-system similar?

[05:34] <benabik> What is HOW.instantiate_generic in nom?

[05:34] * benabik is trying to catch up on a few days of nom and getting lost.

[05:34] <TimToady> it has some similar concepts

[05:35] <TimToady> though Haskell chooses a different default; P6's types are more like Maybe types, or Error types

[05:35] <soh_cah_toa> ok

[05:35] <TimToady> and Just types are constrained to be defined with :D, which makes them happy types

[05:35] <soh_cah_toa> ha!

[05:36] <benabik> P6 is very punny

[05:36] <TimToady> but P6 doesn't officialy care whether an object of a particular type is defined or not

[05:36] <TimToady> type objects are like color charge gluons in a nucleus

[05:36] *** cooper left
[05:36] <TimToady> they just carry a type "charge" without actually having to act like real particles

[05:37] *** cooper joined
[05:37] <soh_cah_toa> that's actually a good analogy

[05:37] <TimToady> you can think of them as typed (void*) from a Cish perspective

[05:38] <TimToady> that doesn't work as well, I suppose

[05:38] <TimToady> more like typed pointers, except the type is officially at the same distance as the object would be if it were there :)

[05:39] <TimToady> so they function as generic objects

[05:39] <TimToady> so more like turning Pinocchio into a real boy :)

[05:39] <benabik> Kinda like mock objects?  They look right, but don't do anything?

[05:40] <TimToady> kinda like platonic ideals

[05:40] <soh_cah_toa> :) alright, that's not too hard to understand

[05:40] <TimToady> they're the stunt doubles that can't die because they were never born.  :)

[05:41] <TimToady> anyway, it's one of the experiments that P6 is making

[05:41] *** drbean left
[05:41] <TimToady> so far it seems to work pretty well, though there's been some discussion lately that invocants should default to the :D subtype that requires a defined object

[05:42] <benabik> masak++'s blog on Classes discusses the philosophical nature of type objects.

[05:42] <soh_cah_toa> benabik: do you have the link?

[05:42] <TimToady> it's either a Grand Idea, or a Grand Illusion, or maybe both :)

[05:43] <soh_cah_toa> indeed, there is a "philosophical nature" to them

[05:43] <benabik> soh_cah_toa: I closed it right after mentioning it.  Not smart.  Fortunately, browsers are smart enough to come with "Unclose" these days.

[05:43] <benabik> soh_cah_toa: http://strangelyconsistent.org/blog/june-27-2011-classes

[05:46] <soh_cah_toa> well, i'm heading off to bed now

[05:46] <soh_cah_toa> take care guys

[05:46] *** soh_cah_toa left
[05:47] * TimToady 2

[05:47] <TimToady> zzz &

[06:03] *** Bzek joined
[06:04] *** Mowah joined
[06:04] *** [particle] left
[06:06] *** [particle] joined
[06:10] *** donri left
[06:29] *** Mowah left
[06:33] *** Mowah joined
[06:36] *** colomon left
[06:54] *** masak joined
[06:54] <masak> <benabik> masak++'s blog on Classes discusses the philosophical nature of type objects.

[06:54] <masak> it does? :)

[06:54] <masak> maybe it should, though.

[06:54] <benabik> masak: "This is where I wax a bit philosophical"

[06:55] <masak> oh, that's about classes and objects in general, not so much about type objects.

[06:57] *** masak left
[06:58] *** masak joined
[07:00] * masak turns back to his crypt

[07:02] *** am0c joined
[07:10] <masak> rakudo: my $a; sub bar { say $a ~~ Foo; }; role Foo {}; $a = Foo.new; bar

[07:10] <p6eval> rakudo 72d158: OUTPUT«Could not find sub &Foo␤  in 'bar' at line 22:/tmp/mWQ8S7CUcM␤  in main program body at line 22:/tmp/mWQ8S7CUcM␤»

[07:10] <masak> std: my $a; sub bar { say $a ~~ Foo; }; role Foo {}; $a = Foo.new; bar

[07:10] <p6eval> std 37a0cdd: OUTPUT«===SORRY!===␤Illegally post-declared type:␤       'Foo' used at line 1␤Check failed␤FAILED 00:01 122m␤»

[07:10] <masak> ah, that's much better.

[07:10] * masak submits rakudobug

[07:10] <masak> nom: my $a; sub bar { say $a ~~ Foo; }; role Foo {}; $a = Foo.new; bar

[07:10] <p6eval> nom: OUTPUT«Could not find sub &Foo␤current instr.: 'bar' pc 569 ((file unknown):32851333) (/tmp/hvv03D3Gon:1)␤»

[07:15] <masak> moritz: oh, and I don't know what 'my ::T $x' means. :) you'll note that diakopter found that NPMCA, which means it's high on the insanity scale.

[07:15] <masak> er, meant diakopter++

[07:22] *** drbean joined
[07:23] <masak> method on_open { say "Opening the $.name reveals a {join " and a ", @.contents}."; }

[07:23] <masak> this is fun :)

[07:28] <masak> a text adventure game is a perfect way to explain event handling, too.

[07:28] <masak> "you make an event handler for an object when you want that object to express some behavior as a response to a regular event."

[07:29] <masak> the above on_open method sits on a role called Container.

[07:29] <masak> with the current factoring, Room does Container. I didn't plan or expect that :)

[07:29] <masak> but it does make sense.

[07:32] *** odrm joined
[07:41] *** wamba joined
[07:41] <mathw> :)

[07:42] <mathw> Text adventures are fun. I used to have loads of happy hours mucking about with Inform. The idea of a language designed for writing interactive fiction is very interesting.

[07:42] <masak> I am currently hammering out the semantics of whether things can be noticed or seen when they are inside something else.

[07:43] <masak> mathw: though I've never used Inform, it seems to be an excessive (and at least partially successful) experiment in a direction I'd prefer not to go :)

[07:44] <masak> it has the same dangerous "look, it's so much like natural language" quality as does COBOL and Ruby DSLs.

[07:47] *** jack-ji left
[07:48] *** jack-ji joined
[07:49] <jnthn> morning, #perl6

[07:49] <masak> jnthn! \o/ morning!

[07:51] <masak> jnthn: how's the weather down there? here it's nice and cool.

[07:51] <jnthn> Didn't go outside yet today...looks sunny but it's probably not too hot.

[07:51] <masak> ok.

[07:52] * masak has to go to a teacher's planning meeting

[07:52] <masak> bbl

[07:52] *** masak left
[07:52] *** Hansy_ joined
[07:53] <jnthn> benabik: (HOW.instantiate_generic) that's part of the MOP that deals with specializing type-parametric things into concrete things.

[07:55] *** Hansy_ left
[07:57] *** Su-Shee left
[07:59] *** _jaldhar left
[08:00] *** _jaldhar joined
[08:04] *** snkcld joined
[08:09] <snkcld> are there any good sites on perl 6 / rakudo internals?

[08:09] <snkcld> i would love to contribute to the perl compiler

[08:10] *** Su-Shee joined
[08:11] <moritz> welcome snkcld 

[08:11] <snkcld> thank you

[08:11] <moritz> there's http://perlgeek.de/blog-en/perl-6/rakudo-overview.html for an overview, but it's slightly out of date

[08:12] <snkcld> hmm

[08:12] <moritz> jnthn has blogged a lot about the new internals at http://6guts.wordpress.com/

[08:12] <snkcld> oh man

[08:12] <moritz> I recommend going through the posts in the order they were written

[08:12] <snkcld> this is good stuff

[08:12] <snkcld> thank you so much

[08:13] <moritz> snkcld: you're welcome, if you have any questions, don't hesitate to ask

[08:13] <snkcld> well, this is distro specific, probably... but i might as well give it a shot

[08:13] <moritz> I won't be available for most of the day, but others will be

[08:13] <snkcld> i was attempting to compile rakudo, and i did Configure --gen-parrot

[08:14] <snkcld> or

[08:14] <snkcld> perl Configure.pl --gen-parrot

[08:14] <snkcld> and it said it could not find libpcre

[08:14] <snkcld> though i do have it installed....

[08:14] <moritz> that's a known parrot issue

[08:15] <moritz> a workaround is   perl Configure --gen-parrot --gen-parrot-option=--without-pcre

[08:15] <snkcld> ohhh

[08:15] <snkcld> so, my perl code can not use regex then?

[08:15] <snkcld> if i did that?

[08:15] <moritz> it's been reported on gentoo and macos so far

[08:15] <snkcld> yea, im on gentoo

[08:16] <moritz> snkcld: no, Rakudo comes with its own grammar engine

[08:16] <snkcld> ohh

[08:16] <snkcld> i dont really understand what 'parrot' is, and what 'rakudo' is...

[08:16] <snkcld> the way i see it,

[08:16] <moritz> snkcld: parrot is a virtual machine, much like the JVM or the CLR

[08:16] <moritz> and Rakudo is a Perl 6 compiler that uses parrot

[08:16] <snkcld> ok ok

[08:17] <snkcld> so rakudo creates the bytecode that parrot executes

[08:17] <moritz> correct

[08:17] <snkcld> so,

[08:17] <moritz> (though it doesn't directly create bytecode, but an intermediate assembler)

[08:17] <snkcld> when i run: perl blah.pl, it invokes rakudo to assemble, then passes that assembly to parrot?

[08:17] <snkcld> are parrot and rakudo help in the same binary?

[08:18] <snkcld> or does it fork and exec

[08:18] <moritz> the 'perl6' binary links to parrot

[08:19] <snkcld> hmm.. that doesnt seem to be the case on my system, but i understand what you are saying

[08:19] <snkcld> they are essentially synonymous?

[08:19] <snkcld> links as in symlink?

[08:19] <moritz> as in "linking object files, as the C compiler/linker does"

[08:20] <snkcld> OH 

[08:20] <snkcld> haha ok of course

[08:20] <snkcld> yea, so perl6 loads rakudo libraries

[08:20] <snkcld> i mean

[08:20] <snkcld> parrot

[08:20] <snkcld> ok, so does it also have rakudo loaded in, to do the compilation

[08:21] <moritz> correct

[08:21] <snkcld> haha, that makes perfect sense

[08:21] <snkcld> out of curiousity, what is the command to see what libraries a binary will load/

[08:21] <snkcld> ldd or something?

[08:21] <moritz> yep

[08:21] <sorear> ldd.  sort of.

[08:22] <snkcld> ok i do see libparrot as a library

[08:22] <sorear> ldd actually works by running the binary with a special environment variable that tells ld.so to dump load paths

[08:22] <snkcld> i imagine that thats where the code resides to convert bytecode -> real code to exec

[08:22] <sorear> DO NOT USE ON UNTRUSTED BINARIES

[08:22] <snkcld> oh word haha ok

[08:22] <sorear> snkcld: parrot runs bytecode directly

[08:22] <snkcld> directly? as opposed to... ?

[08:23] <sorear> it doesn't convert bytecode into anything

[08:23] <snkcld> oh

[08:23] <snkcld> ok ok

[08:23] <snkcld> so, libparrot.so.3.3.0 contains the code to run the bytecode

[08:23] <sorear> yes

[08:23] <snkcld> and, the actual perl6 binary itself is effectively 'rakudo'

[08:24] <sorear> however most of it is runtime support stuff

[08:24] <dalek> rakudo/nom: 4050741 | moritz++ | / (2 files):

[08:24] <dalek> rakudo/nom: Parcel.values, tests

[08:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/405074182a

[08:24] <snkcld> so, in perl5 and what not, did this seperation of VM & compiler not exist?

[08:24] <sorear> snkcld: I don't know if you've heard yet, but there are other Perl 6 implementations that try to compete with Rakudo

[08:25] <snkcld> i have not heard, but i can imagine

[08:25] <snkcld> did perl 5 not have the seperation that rak & par have

[08:25] <sorear> snkcld: in Perl5 there was an internal separation between "the parser" (toke.c et al) and "the runtime" (pp.c et al)

[08:25] <snkcld> oh

[08:25] <snkcld> ok ok this makes sense.

[08:25] <snkcld> so now, to change the run time, you simply link the library to a different file

[08:25] <sorear> Perl6 takes this further by having separate repositories, indeed separate legal entities holding copyright

[08:25] <moritz> but in perl 5 you can't (easily) dump the compiled bytecode and run it again, for example

[08:26] <sorear> toke.c and pp.c are both owned by the Perl Foundation

[08:26] <snkcld> ah

[08:26] <snkcld> on gentoo, is libpcre located at a different place than other systems?

[08:27] <moritz> no, the problem is something else

[08:27] <moritz> iirc that the .so file is a linker script (?), not the actual object file

[08:27] <moritz> and parrot can't handle that

[08:28] <sorear> snkcld: fwiw, I'm #1 on the #2 implementation

[08:28] <moritz> http://trac.parrot.org/parrot/attachment/ticket/2107/pcre-bug

[08:28] <snkcld> sorear, i dont understand

[08:28] <sorear> snkcld: so if I talk a bit detachedly about Rakudo, that's why

[08:28] <moritz> http://trac.parrot.org/parrot/ticket/2107

[08:28] <sorear> http://github.com/sorear/niecza # this is mine

[08:28] <moritz> snkcld: sorear leads the development of niecza, which is another Perl 6 compiler

[08:29] <moritz> and it's worth trying out

[08:29] <snkcld> OH

[08:29] <snkcld> haha

[08:29] <snkcld> thats awesome

[08:29] <snkcld> the underdog eh

[08:29] <moritz> not at all

[08:29] <moritz> niecza does some very interesting things that rakudo doesn't

[08:29] <moritz> also it's a very friendly competition (at least in my eyes :-), and we do "steal" code back and forth

[08:30] <snkcld> man

[08:30] <snkcld> i would _love_ to help out

[08:30] <moritz> then do :-)

[08:30] <sorear> snkcld: competetion between implementations, a no-holds-barred race, is a poisonous meme

[08:30] <snkcld> haha, indeed. 

[08:30] <jnthn> Also worth noting that the active Rakudo development at the moment is in the "nom" branch, not the master branch.

[08:30] <sorear> snkcld: I've caught myself being happy over Rakudo's setbacks.  And I feel so guilty afterward.

[08:31] <moritz> bad sorear, no cookie :-)

[08:31] <dalek> roast: a9de2f6 | moritz++ | S (5 files):

[08:31] <dalek> roast: various rakudo fudges and unfudges

[08:31] <dalek> roast: review: https://github.com/perl6/roast/commit/a9de2f65ac

[08:31] <dalek> roast: e982a79 | moritz++ | S04-declarations/my.t:

[08:31] <dalek> roast: unfudge another test for rakudo

[08:31] <dalek> roast: review: https://github.com/perl6/roast/commit/e982a79c82

[08:31] *** cooper left
[08:33] <jnthn> moritz: We regressed on the .pick/:replace one with the *%_ patch I guess

[08:33] <moritz> jnthn: that's what I thought too

[08:34] <snkcld> localhost ~ # cat /usr/lib64/libpcre.so | tr -d '\n' | sed  's/\/\*.*\*\///g'

[08:34] <snkcld> OUTPUT_FORMAT ( elf64-x86-64 )GROUP ( /lib64/libpcre.so.0 )

[08:34] <jnthn> moritz: So it was kinda a false pass before. 

[08:34] <moritz> jnthn: and I kinda think the test can go now, because the spec change is old enough

[08:34] <jnthn> moritz: That'w what I was also going to mention...do we need this test any more :)

[08:35] <sorear> snkcld: man strings

[08:35] *** drbean left
[08:35] <snkcld> haha, sorear thank you

[08:35] <snkcld> well, the file is plain text

[08:35] <sorear> ow

[08:35] <snkcld> i was just sedding out everything between /* and */

[08:35] <sorear> that's your problem!!

[08:35] <snkcld> yea yea haha i was just reaffirming what moritz had said

[08:35] <moritz> no, it's parrot's problem

[08:35] <snkcld> as much as  i love gentoo...

[08:36] <sorear> yeah

[08:36] <snkcld> X_X

[08:36] <sorear> dlopen is a mess on Linux

[08:37] <snkcld> so, if i was writing a compiler, i would dlopen() the library of the vm i want, then dlsym() for a function to run the code...?

[08:37] <snkcld> then run run_the_code(my_code)

[08:37] <snkcld> where run_the_code is in the library>

[08:38] <jnthn> rakudo: class A { }; role R { }; my $x = A.new; $x does R; say $x.WHAT

[08:38] <p6eval> rakudo 72d158: OUTPUT«()␤»

[08:38] <jnthn> niecza: class A { }; role R { }; my $x = A.new; $x does R; say $x.WHAT

[08:38] <p6eval> niecza v7-21-gbcc1cf3: OUTPUT«Unhandled exception: Retyping NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 663 (CORE die @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1746 (CORE infix:<does> @ 2) ␤  at /tmp/wZmvSLcsKq line 1 (MAIN mainline @ 4) ␤  at /home/p6eval/niecza/lib/C…

[08:38] <jnthn> pugs: class A { }; role R { }; my $x = A.new; $x does R; say $x.WHAT

[08:38] <p6eval> pugs: OUTPUT«*** Unknown syntactic construct: Syn "does" [Var "$x",Val (VType (mkType "R"))]␤    at /tmp/VLuZBfg4yS line 1, column 41-50␤»

[08:38] <jnthn> heh :)

[08:38] <sorear> niecza: class A { }; role R { }; say (A but R)

[08:38] <p6eval> niecza v7-21-gbcc1cf3: OUTPUT«A but R()␤»

[08:38] <jnthn> aha

[08:38] <sorear> the *only* thing you can do with roles in Niecza is mix them into type objects

[08:38] <jnthn> yeah, I was wondering what to make the type object name look like.

[08:39] <sorear> I guessed

[08:39] <jnthn> Your guess was at least better than Rakudo's... :)

[08:39] <sorear> (not coincidentally, this is exactly what STD needed)

[08:39] <jnthn> Yeah, I figured you'd have enough for STD.

[08:40] *** wamba left
[08:40] <sorear> I still have a lot of confusion about how roles work in the context of $?CLASS

[08:40] <sorear> let me know when you have something worth stealing in nom :)

[08:41] <sorear> or if you want to clarify things otherwise, like what A.^does(R[2]) means

[08:41] <jnthn> I'm getting there...still some hard problems to go.

[08:42] <snkcld> where should i go to begin contributing to perl? what is the process?

[08:42] <snkcld> do i prove myself, then i have the ability to push my code?

[08:43] <sorear> haha

[08:43] <sorear> no

[08:43] *** envi joined
[08:43] <sorear> what repository(s) do you want push access to?

[08:44] <sorear> in #perl6-land we treat our repositories like wikis

[08:44] <sorear> common decency dictates that if you're unsure about a change, you should ask for input before pushing

[08:44] *** apex_zone joined
[08:44] *** apex_zone left
[08:45] *** apex_zone joined
[08:45] *** nymacro joined
[08:45] <sorear> (sure, we can revert, but we don't like breaking the continuous integration if we can help it)

[08:45] <apex_zone> are perl6 binary installer for windows available?

[08:47] <sorear> They used to be

[08:47] <sorear> I think github was having availability issues during the time of the last release(?)

[08:47] <sorear> wait, you said binary

[08:47] <sorear> no

[08:47] <sorear> (not for Rakudo... hehehehe)

[08:48] <sorear> Parrot expects to know its install path at compile time

[08:48] <sorear> wait, I think we had an installer that provided that

[08:48] <sorear> someone else answer :/

[08:50] *** mj41 joined
[08:50] <apex_zone> i have tried parrot but it still error on my PC.. so, i quit learn perl, and start learn java again

[08:50] <apex_zone> :(

[08:50] <sorear> apex_zone: try niecza :D

[08:50] <sorear> it has a binary Windows-compatible package :D

[08:51] <sorear> also, wait for moritz.  ey would know if there's a current Rakudo package.

[08:52] <apex_zone> Ok, i will try later

[08:52] <sorear> why wait? https://github.com/downloads/sorear/niecza/niecza-7.zip

[08:52] <apex_zone> Thanks for the information

[08:54] <apex_zone> yupz.. i have downloaded it

[08:56] <apex_zone> then what should i do now after it?

[08:57] *** mj41 left
[08:57] <sorear> run run\Niecza.exe, wait 15 seconds or so, then try say 1..5

[08:58] <snkcld> err

[08:58] <snkcld> is rakudo written in perl???

[08:58] <Tene> yes, primarily

[08:59] <snkcld> wow i had no idea

[08:59] <snkcld> and parrot? is that in c or perl?

[08:59] <Tene> C

[09:00] <apex_zone> cant run niecza, there is window pop up say "the plication failed to initialize properly (0xc0000135)

[09:00] <snkcld> so rakudo is written in perl 5 then?

[09:00] <Tene> snkcld: Rakudo is written in Perl 6

[09:00] *** wamba joined
[09:00] <snkcld> i dont understand... how do you run rakudo if you dont have a p6 compiler already

[09:01] <Tene> snkcld: we do have a Perl 6 compiler: rakudo :)

[09:01] <Tene> snkcld: I'll elaborate...

[09:01] <snkcld> haha

[09:01] <snkcld> my mind has just been blown

[09:01] <sorear> rakudo is written in a subset-ish of Perl 6 called NQP "Not Quite Perl6"

[09:01] <snkcld> ok ok...

[09:01] <sorear> NQP has its own compiler

[09:01] <Tene> snkcld: Rakudo is primarily compiled by a core written in a restricted subset of Perl 6 called NQP, Not Quite Perl.  NQP is written in NQP and uses a bootstrapping precompiled stage to compile itself.

[09:02] <sorear> NQP is written in NQP; the NQP you see is compiled using an older version of NQP

[09:02] <snkcld> ...

[09:02] <sorear> this regresses back maybe 50 loops

[09:02] <snkcld> i...

[09:02] <snkcld> this is insane

[09:02] <sorear> then you get to an ancient version of NQP, which was written using other tools

[09:02] <Tene> snkcld: there's a precompiled version checked into the source repository

[09:02] <Tene> snkcld: it's pretty standard compiler bootstrapping, actually.

[09:02] <sorear> Parrot Grammar Engine and Tree Grammar Engine, both shipped with Parrot

[09:03] <Tene> snkcld: GCC is largely written in C, for example.

[09:03] <snkcld> hahaha

[09:03] <snkcld> omg, it is

[09:03] <snkcld> i didnt think of that

[09:03] <snkcld> ok ok so umm

[09:03] <Tene> sorear: nothing has used TGE in ages, afaik

[09:03] <snkcld> when rak is being compiled,

[09:03] <sorear> The standard joke with new programming languages is: Have you written anything large in it other than its own compiler?

[09:03] <snkcld> NQP is used to compile the p6 code?

[09:03] <snkcld> and NQP is a binary

[09:03] <Tene> snkcld: nqp is used to compile the core, and the core is used to compile the rest.

[09:03] <sorear> snkcld: half of it.

[09:03] <snkcld> at some point

[09:03] <snkcld> yea

[09:04] <snkcld> but, the very first stage of NQP is binary yes?

[09:04] <sorear> snkcld: NQP is shipped as Parrot assembly language

[09:04] <sorear> .pir files

[09:04] <snkcld> OH

[09:04] <snkcld> haha that makes alot of sense

[09:04] <snkcld> ok so parrot executes the compiler

[09:04] <sorear> ext/nqp-rx/src/stage0 in your Parrot copy

[09:04] <sorear> if you want to look at them

[09:05] <Tene> snkcld: exactly

[09:06] <snkcld> so stage0 is ran on parrot... at this point, we have a NQP compiler

[09:06] <snkcld> we can now compiler p6 code?

[09:06] <snkcld> *compile

[09:07] <Tene> snkcld: with nqp, you can compile NQP code.  NQP is a restricted subset of Perl 6.

[09:07] <snkcld> ahhh haha

[09:07] <snkcld> i love this

[09:07] <snkcld> this is incredible

[09:07] <Tene> That's enough to compile and run the core of the Rakudo compiler, though

[09:08] <snkcld> so rakudo is written in NQP?

[09:08] <jnthn> Yes and no

[09:08] <jnthn> Rakudo's grammar, actions, meta-objects and so on (in nom branch at least) are written in NQP

[09:08] <jnthn> We then use this core to build the built-ins, which are written in Perl 6.

[09:09] <jnthn> In the master branch chunks of Rakudo are written in Parrot assembly too. In the "nom" branch, it's all NQP, Perl 6 and just a few bits of C here and there.

[09:13] <snkcld> ok so... to execute "perl6 blah.pl"... 1)perl6 binary links in parrot 2) parrot runs stage 0 3) each next stage is ran by the previous stage 4) on the last stage, we can compile rakudo into parrot assembly 5) rakudo is executed and runs the blah.pl file?

[09:13] <Tene> snkcld: no; compiling rakudo generates parrot bytecode.

[09:13] <jnthn> snkcld: As an exmaple, https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Grammar.pm is the parser, written in NQP. https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Metamodel/ClassHOW.pm is the bit of code that determines how a class works, written in NQP. https://github.com/rakudo/rakudo/blob/nom/src/core/Str.pm is a big chunk of the Str (string) built-in class, written in Perl 6.

[09:13] <Tene> so 'perl6 blah.pl' is more like the following:

[09:14] <Tene> parrot loads perl6.pbc, which reads and compiles the file, and then runs the generated program

[09:14] <Tene> so, the bootstrapping steps are only involved when compiling rakudo itself

[09:14] <snkcld> OH

[09:14] <snkcld> of course, of course haha

[09:14] <Tene> :)

[09:14] <snkcld> haha

[09:14] *** nothingmuch left
[09:15] <snkcld> rakudo in the end is parrot bytecode then

[09:15] *** jferrero left
[09:16] *** jferrero joined
[09:16] <snkcld> rather, rakudo is perl6.pbc?

[09:18] <jnthn> Yes, that contains the results of compiling Rakudo

[09:18] <jnthn> It's what gets run

[09:18] <jnthn> perl6 executable just embeds that PBC file

[09:18] <snkcld> so given only a C compiler, we can generate rakudo and parrot

[09:19] <snkcld> because we compile, _from_ C, a stage-0

[09:19] <snkcld> which steps us up towards per

[09:19] <snkcld> l

[09:19] *** kaare_ joined
[09:22] <Tene> snkcld: rather, given a c compiler, we can compile parrot (and the C-only parts of rakudo), which can run perl6.pbc

[09:23] *** colomon joined
[09:23] *** colomon left
[09:24] <snkcld> interesting

[09:24] <snkcld> perl6.pbc is stage 0?

[09:30] <snkcld> map { $_ ** 2 } ?

[09:30] <snkcld> OH

[09:30] <snkcld> nevermind, i assume ** is raise to power of

[09:30] <apex_zone> someone know where to download rakudo like compiler

[09:31] *** apex_zone left
[09:34] <tadzik> good morning #perl6

[09:35] *** Trashlord joined
[09:42] <jnthn> on nom bacon

[09:42] <jnthn> o/ tadzik 

[09:47] *** snkcld left
[09:48] *** am0c left
[09:51] *** colomon joined
[09:52] <tadzik> two new people the same night, how exciting :)

[09:55] *** colomon left
[10:07] * sorear out

[10:22] *** Chillance joined
[10:32] *** Mowah left
[10:34] *** takesako_ joined
[10:46] *** takesako_ left
[10:47] *** nymacro left
[10:48] *** im2ee joined
[10:57] *** takesako_ joined
[11:04] <dalek> nqp: dbc9e77 | jonathan++ | src/ops/nqp.ops:

[11:04] <dalek> nqp: Add repr_change_type op, for asking the repr to do a type change on the object.

[11:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dbc9e77615

[11:04] <dalek> nqp: 6ace072 | jonathan++ | src/6model/reprs/P6opaque.c:

[11:04] <dalek> nqp: Implement change_type for P6opaque.

[11:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6ace072d1f

[11:08] <dalek> rakudo/nom: ec206d6 | jonathan++ | tools/build/NQP_REVISION:

[11:08] <dalek> rakudo/nom: Bump NQP_REVISION to get repr_change_type support.

[11:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ec206d6862

[11:08] <dalek> rakudo/nom: 6503f6b | jonathan++ | / (3 files):

[11:08] <dalek> rakudo/nom: First sketch of mixin support.

[11:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6503f6b9c0

[11:08] <dalek> rakudo/nom: 5349d59 | jonathan++ | src/core/operators.pm:

[11:08] <dalek> rakudo/nom: First, though basically working, implementation of does and but operators. Undertested so far - there will be bugs.

[11:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5349d59ed0

[11:11] *** takesako_ left
[11:11] *** takesako joined
[11:14] *** Kivutarrr joined
[11:16] <dalek> 6model: e849201 | (Martin Berends)++ | c/ (4 files):

[11:16] <dalek> 6model: odel/c] start Configure.bat and MSVC support - incomplete

[11:16] <dalek> 6model: review: https://github.com/jnthn/6model/commit/e84920168f

[11:26] *** _jaldhar left
[11:27] *** _jaldhar joined
[11:43] *** wamba left
[11:51] *** drbean joined
[11:53] *** Moukeddar joined
[11:55] *** MayDaniel joined
[11:57] *** masak joined
[11:57] <masak> rehi #perl6.

[11:57] *** _jaldhar left
[11:57] <tadzik> cześć masak 

[11:58] <masak> cz

[11:58] *** _jaldhar joined
[11:58] <masak> nice to see someone new (snkcdl) find #perl6.

[11:58] <masak> er, snkcld.

[11:58] <masak> I have a newbie question: have Array, want List. what do I do nowadays?

[11:59] <masak> rakudo: say [1, 2, 3].perl; say [1, 2, 3].WHAT

[11:59] <p6eval> rakudo 72d158: OUTPUT«[1, 2, 3]␤Array()␤»

[12:03] *** birdwindupbird joined
[12:04] <tadzik> masak: any idea how can I do proper split(/regex/) in nqp, without reimplementing split?

[12:04] <tadzik> in nqp, aka in Actions.pm

[12:05] <masak> a while loop and /regex/?

[12:05] <masak> something like that.

[12:05] <tadzik> yeah, probably

[12:05] <masak> the "without reimplementing split" is a tricky clause, if what you want is split semantics :P

[12:05] <tadzik> :)

[12:05] <masak> tadzik: any idea how to turn an Array into a List?

[12:05] <tadzik> handling tables in nqp is madness

[12:06] <tadzik> masak: sorry, I can't really distinguish these two :P

[12:06] <tadzik> not Array.list at a chance?

[12:06] <masak> List is the one with soft parentheses, Array is the one with hard brackets.

[12:06] <masak> rakudo: say [1, 2, 3].list.perl

[12:06] <p6eval> rakudo 72d158: OUTPUT«[1, 2, 3]␤»

[12:06] <tadzik> yeah, the visual difference is ok :)

[12:06] <masak> rakudo: say [1, 2, 3].list.WHAT

[12:06] <p6eval> rakudo 72d158: OUTPUT«Array()␤»

[12:06] <tadzik> :P

[12:06] <masak> that used to work, I'm sure.

[12:07] <masak> nom: say [1, 2, 3].list.perl; say [1, 2, 3].list.WHAT

[12:07] <p6eval> nom: OUTPUT«Array.new(1, 2, 3)␤Array()␤»

[12:07] <masak> this is such a blatant regression that I'm thinking I might have missed the latest fashion in List/Array semantics.

[12:07] <masak> hence my newbie question.

[12:07] <jnthn> masak: Why are you worrying, ooc?

[12:08] <jnthn> masak: If you're asking "I want type X" then I guess you must have in mind something specific about List as opposed to Array.

[12:08] <masak> jnthn: is the question equivalent to "why do you even want to make a List from an Array?"?

[12:08] <jnthn> masak: right

[12:08] <jnthn> masak: Like, are you after flattening, for example?

[12:08] <jnthn> .list is a contextualizer rather than a coercer

[12:09] <masak> jnthn: yes, I have an any() call, and I want to flatten the arguments, some of which are arrays.

[12:09] <jnthn> nom: for [1,2,3] { say "loop" }

[12:09] <p6eval> nom: OUTPUT«loop␤»

[12:09] <jnthn> nom: for [1,2,3].list { say "loop" }

[12:09] <p6eval> nom: OUTPUT«loop␤loop␤loop␤»

[12:09] <Moukeddar> masak, Da MAN!

[12:09] <masak> the only thing I found so far that works is .map({$_})

[12:09] <masak> Moukeddar: hello, person of vigorous greetings.

[12:09] <jnthn> nom: say 1 == any([1,2,3].list)

[12:09] <p6eval> nom: OUTPUT«any(Bool::True, Bool::False, Bool::False)␤»

[12:09] <jnthn> Looks like .list works fine

[12:09] <jnthn> nom: say 1 == any([1,2,3].flat)

[12:10] <Moukeddar> my Specialty :)

[12:10] <p6eval> nom: OUTPUT«any(Bool::True, Bool::False, Bool::False)␤»

[12:10] <masak> nom: say 1 == any([1,2,3])

[12:10] <Moukeddar> how are you doing?

[12:10] <p6eval> nom: OUTPUT«any(Bool::False)␤»

[12:10] <jnthn> Flattening is orthogonal to type, afaiu.

[12:10] <masak> jnthn: ok, so it flattens but there's no exterior sign of it?

[12:10] <masak> Moukeddar: I'm ok. I fled southern Sweden because it was too hot. up here it's cooler.

[12:10] <jnthn> "exterior sign"? :)

[12:11] <masak> Moukeddar: how're you?

[12:11] <jnthn> But if you want a type change, then no...

[12:11] <masak> jnthn: yes, I do .list or .flat, and it's still an Array.

[12:11] <jnthn> Right.

[12:11] <Moukeddar> lazy and out-of-focus

[12:11] <masak> jnthn: and .perl still looks the same.

[12:11] <tadzik> $row ~~ /\s+/; my $n := $/.to; -- how do I do something like this in nqp? nqp doesn't set $/ it seems

[12:11] <tadzik> oh, there's a bug too, but nvm :)

[12:11] <jnthn> masak: Maybe the .perl looking the same is dubious.

[12:12] <jnthn> tadzik: my $match := $row ~~ /\s+/;

[12:12] <masak> tadzik: just bind the match to a variable?

[12:12] <jnthn> $match.to ...

[12:12] <tadzik> oh, ok

[12:12] <jnthn> No, we don't do implicit $/ setting in NQP

[12:12] <masak> jnthn: I was surprised by it.

[12:12] <jnthn> Not sure we will.

[12:12] <jnthn> nom: [1,2,3].perl

[12:12] <p6eval> nom:  ( no output )

[12:12] <tadzik> seems that we don't, "$/ not predeclared bla bla"

[12:12] <jnthn> nom: [1,2,3].perl.say

[12:12] <p6eval> nom: OUTPUT«[1, 2, 3]␤»

[12:12] <jnthn> nom: [1,2,3].flat.perl.say

[12:12] <p6eval> nom: OUTPUT«Array.new(1, 2, 3)␤»

[12:12] <jnthn> nom: [1,2,3].list.perl.say

[12:12] <p6eval> nom: OUTPUT«Array.new(1, 2, 3)␤»

[12:12] <jnthn> masak: huh, looks rather different to me :)

[12:13] <masak> jnthn: in nom, yes.

[12:13] <jnthn> masak: oh

[12:13] *** Mowah joined
[12:13] <masak> out here in the *real world*...

[12:13] <masak> :P

[12:13] <jnthn> You weren't talking about nom

[12:13] <jnthn> Right

[12:13] <jnthn> :)

[12:13] <jnthn> OK, then I don't know. :)

[12:13] <jnthn> But..."fixed in nom!" :)

[12:13] <masak> you people and your ivory tower branch... :P

[12:13] <jnthn> :P

[12:14] <jnthn> masak: You'll be happy to know it does proto auto-gen now for multis :)

[12:14] *** wamba joined
[12:14] <masak> wow, cool!

[12:14] <jnthn> masak: So you don't have to pollute your multi code with protos ;)

[12:14] <masak> jnthn++, I s'pose.

[12:14] <masak> yay

[12:14] <jnthn> nom: multi fac(0) { 1 }; multi fac($n) { $n * fac($n - 1) }; say fac(5)

[12:14] <p6eval> nom: OUTPUT«120␤»

[12:15] <jnthn> nom: multi fac(0) { 1 }; multi fac($n) { $n * fac($n - 1) }; say &fac.signature

[12:15] <p6eval> nom: OUTPUT«:(Mu)␤»

[12:15] <jnthn> oh, Signature.perl doesn't really work yet...

[12:15] <masak> how is .signature computed?

[12:15] <jnthn> masak: It's always |$

[12:15] <masak> ah, convenient.

[12:16] <jnthn> masak: If you want a more specific one, we leave you to nail it down yourself.

[12:16] <masak> that's on the level of detail saying "lol, I'm a signature" :)

[12:16] <masak> Moukeddar: have you tried my adventure game yet?

[12:17] <jnthn> nom: multi fac(0) { 1 }; multi fac($n) { $n * fac($n - 1) }; say &fac.is_dispatcher

[12:17] <p6eval> nom: OUTPUT«Bool::True␤»

[12:17] <masak> Moukeddar: perfect for a lazy, out-of-focus day in the heat ;)

[12:17] <masak> jnthn: ah, so a routine knows if it's a proto. nice.

[12:17] <Moukeddar> i've been busy lately, putting myself together 

[12:17] <masak> I see.

[12:18] *** daniel-s left
[12:18] <Moukeddar> rough week,

[12:19] *** MayDaniel left
[12:20] <tadzik> does nqp have something like .__dump now?

[12:20] <tadzik> istr there was something like this

[12:22] <masak> tadzik: https://github.com/perl6/nqp/commit/855763158571805197bd4ff287cbda4b33da4db3

[12:22] *** Mowah left
[12:23] <tadzik> int eresting; masak++

[12:26] *** frettled left
[12:27] *** frettled joined
[12:28] *** Mowah joined
[12:37] *** wamba left
[12:41] <masak> nom: for [1, 2, 3] { say "!" }

[12:41] <p6eval> nom: OUTPUT«!␤»

[12:41] <masak> nom: for [1, 2, 3].flat { say "!" }

[12:41] <p6eval> nom: OUTPUT«!␤!␤!␤»

[12:41] <masak> rakudo: for [1, 2, 3].flat { say "!" }

[12:41] <p6eval> rakudo 72d158: OUTPUT«!␤!␤!␤»

[12:46] <masak> rakudo: my @a = "foo", ["foo"], [["foo"]]; my %h = "foo" => 42; say %h{@a}.perl

[12:46] <p6eval> rakudo 72d158: OUTPUT«(42, (42, ), ((42, ), ))␤»

[12:47] <masak> interesting new behavior.

[12:47] <jnthn> o.O

[12:47] * jnthn wonders if nom does that too

[12:47] <masak> nom: my @a = "foo", ["foo"], [["foo"]]; my %h = "foo" => 42; say %h{@a}.perl

[12:47] <jnthn> nom: my @a = "foo", ["foo"], [["foo"]]; my %h = "foo" => 42; say %h{@a}.perl

[12:47] *** tokuhir__ left
[12:47] <p6eval> nom: OUTPUT«(42, (42,), ((42,),))␤»

[12:47] <p6eval> nom: OUTPUT«(42, (42,), ((42,),))␤»

[12:48] <jnthn> cute :)

[12:48] <masak> I can't tell if it's right or wrong, because I don't grok lols and slices well enough.

[12:48] <jnthn> Let's...call it a feature. :D

[12:48] <masak> nom: my @a = "foo", ["foo"], [["foo"]]; my %h = "foo" => 42; say %h{@a}.flat.perl

[12:48] <p6eval> nom: OUTPUT«(42, 42, 42).list␤»

[12:49] <masak> ah, .flat smoothes things over. :)

[12:50] <tadzik> nqp: my $str := "foo  bar   asd    zebra"; my $match := $str ~~ / (\w+) ** \h+ /; for $match[0] { say($_) }; # poor man's split() :)

[12:50] <p6eval> nqp: OUTPUT«foo␤bar␤asd␤zebra␤»

[12:50] <masak> tadzik++

[12:51] <tadzik> I don't know thy it's $match[0] though

[12:51] <tadzik> why

[12:51] <masak> tadzik: what about the corner cases? empty string, string with just whitespace, whitespace at the beginning, whitespace at the end?

[12:51] <jnthn> tadzik: Becuase (...) is the zeroth capture

[12:51] <masak> tadzik: it's $match[0] because that's where (\w+) ends up.

[12:51] *** tokuhir__ joined
[12:51] <tadzik> oh, ok

[12:52] <masak> now, what about the corner cases? :)

[12:52] <tadzik> masak: all about leading whitespace is covered before

[12:52] <tadzik> let's see that one

[12:52] <tadzik> nqp: my $str := "     foo  bar   asd    zebra"; my $match := $str ~~ / (\w+) ** \h+ /; for $match[0] { say($_) }; # poor man's split() :)

[12:52] <p6eval> nqp: OUTPUT«foo␤bar␤asd␤zebra␤»

[12:52] <tadzik> win :)

[12:52] <masak> \o/

[12:52] <jnthn> Sure, it's not anchored at the start of the string, nor the end :)

[12:52] <masak> oh, troo

[12:53] <tadzik> encountered with a problem, I used regexes. Now what? :P

[12:53] <masak> it's essentially a ratchet, not an eager.

[12:53] <masak> tadzik: make it ratchet, and save some memory :P

[12:53] <tadzik> :ratchet?

[12:54] <masak> think so.

[12:54] <tadzik> nqp: my $str := "     foo  bar   asd    zebra"; my $match := $str ~~ / :ratchet (\w+) ** \h+ /; for $match[0] { say($_) }; # poor man's split() :)

[12:54] <p6eval> nqp: OUTPUT«foo␤bar␤asd␤zebra␤»

[12:54] <tadzik> wfm

[12:54] <masak> the difference, internally, is that an eager quant builds up a list of failpoints.

[12:54] <masak> which are then used when things start to backtrack.

[12:54] <masak> but your thing never backtracks.

[12:54] <tadzik> yeah, I read about that in Mastering Regexes

[12:55] <tadzik> I still have this on my shelf, I hope the librarian won't kill me

[12:55] <masak> I haven't read that book, but I think I got an equivalent dosage by implementing GGE :)

[12:55] <tadzik> :)

[12:55] <tadzik> probly

[12:55] <masak> still haven't blogged about PGE. it was a fun project, though.

[12:55] <tadzik> PGE, GGE?

[12:55] <masak> time to implement an inventory in crypt! :)

[12:56] <jnthn> Do you have to invent it first?

[12:56] <tadzik> I wan't to blog about "look how fun Pod is" in the near future

[12:56] <masak> tadzik: PGE: pmichaud++'s old grammar engine.

[12:56] <tadzik> I see

[12:56] <masak> tadzik: GGE: masak's port of it to Perl 6.

[12:56] <masak> (PGE was in PIR)

[12:56] <masak> jnthn: invent? O RY?

[12:56] <tadzik> yeah, I just wondered if you made a typo or just changed the topic :)

[12:57] <tadzik> alias :w='echo vim is on another window'

[12:57] <tadzik> how would I survive without this :)

[12:57] <masak> tadzik: the 'P' stands, as always, for "pmichaud's". the 'G' stands for "glacial" :P

[12:57] <tadzik> :)

[12:58] <tadzik> or maybe for masag :)

[12:58] <masak> acronyns, your doin it rong.

[12:58] <masak> acronyms*, even

[12:58] <tadzik> ronk?

[12:58] <tadzik> okay, I still see no conclusion about formattingcodes!

[12:58] <tadzik> any better way than pod_string { [ . || <formattingcode> ]+ }?

[12:59] <tadzik> this looks ugly, but maybe it's the best we can do

[12:59] <masak> what's wrong with that?

[12:59] <masak> huh, wait.

[12:59] <tadzik> I just don't like this

[12:59] <masak> rhs of || will never match, right?

[12:59] <tadzik> wouldn't it be just grossly inneficient? I mean, for ...

[12:59] <tadzik> of course, another way around, sorry

[12:59] <masak> "the other way around" :)

[12:59] <tadzik> so, for every character in pod documentation a lookahed, bleh

[13:00] <tadzik> not the first one probably

[13:00] <masak> tadzik: I think it's either that or post-processing.

[13:00] <masak> tadzik: did you take a look at STD's nibbler?

[13:00] <tadzik> post-processing is not an option

[13:00] <tadzik> and would result in exactly the same thing, but in different moment :)

[13:00] <tadzik> masak: no, what's that?

[13:00] <masak> tadzik: TimToady mentioned it in yesterday's backlog.

[13:00] <masak> have a look, I implore you.

[13:01] * tadzik looks

[13:01] <masak> because you are fundamentally solving the same problem: that of escaped things in a delimited piece of code.

[13:01] <tadzik> working on rakudo, and doing even only 'make perl6' from time to time gives me so much free time :)

[13:02] <tadzik> "just like the quote nibbler does" that's the only thing I see

[13:02] <tadzik> what is that thing?

[13:03] <masak> it's the thing in STD that eats text until it finds a real terminating... whatever.

[13:03] <tadzik> a tokenizer?

[13:03] <masak> no, not really.

[13:03] <masak> an... eater. :)

[13:03] <masak> the thing you're trying to do just now.

[13:03] <masak> nibble away at text until you find something interesting.

[13:03] <tadzik> oh, ok

[13:04] <masak> just look at the code, grok it, and see if there's something to take away from it.

[13:04] <tadzik> wo, a big thingy

[13:04] <tadzik> I'll finish tables first, the hardest case is still before me

[13:04] <masak> :)

[13:05] <masak> interesting. the verb 'take' is an operation on the thing's container, not on the thing itself.

[13:05] <masak> that... complicates matters somewhat.

[13:06] <tadzik> to nom, or to hack

[13:07] <tadzik> looking at my 60 kgs of weight, I can sell what's the usual decision :(

[13:07] <masak> o.O

[13:08] <masak> tadzik: eat! we need more of you than that! :)

[13:08] <tadzik> :)

[13:08] <tadzik> bad metabolism, be more lazy

[13:10] *** REPLeffect left
[13:10] <pmichaud> good morning, #perl6

[13:11] <masak> good morning, pm.

[13:11] <tadzik> good morning pmichaud 

[13:11] *** icwiener joined
[13:19] *** daniel-s joined
[13:23] *** REPLeffect joined
[13:31] <masak> besides the method returning something non-Nil, is there a good way to know whether $o.?foo actually called a .foo ?

[13:31] *** Moukeddar left
[13:31] *** mberends joined
[13:31] <masak> I'm asking because I have a case where it would be good to know, but I don't want to institute a policy where all such methods return something non-Nil.

[13:32] <masak> so far I've settled on 'try { $o.foo; $found = True }', but I can't say I like the solution much.

[13:32] <jnthn> masak: .can

[13:32] <masak> ooh :)

[13:32] <masak> jnthn++ masak-- # obvious, really

[13:32] <mberends> good *, *

[13:32] <tadzik> good afternoon Martin :)

[13:33] <masak> mberends! \o/

[13:33] <jnthn> hi mberends :)

[13:33] <jnthn> See you've been hacking on 6model/c :)

[13:34] <masak> unless $thing.can($verb) { # jnthn++

[13:34] *** Moukeddar joined
[13:34] <mberends> :-) programming for MSVC is a dubious pleasure, or maybe it's just that I'm re-become a Windows n00b

[13:34] <masak> I'm told that IDE is quite polished, though.

[13:35] <jnthn> mberends: It's a bit of a C89 zealot, that's all. :)

[13:35] <masak> rakudo: say "OH"; return; say "HAI"

[13:35] <p6eval> rakudo 72d158: OUTPUT«OH␤»

[13:35] <masak> can I ticket this?

[13:35] <tadzik> niecza: say "OH"; return; say "HAI"

[13:35] <p6eval> niecza v7-21-gbcc1cf3: OUTPUT«OH␤Unhandled exception: Illegal control operator: return␤  at /tmp/N2x5JTt4aS line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C887_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1892 (CORE module-CORE @ 54) ␤…

[13:36] <masak> "works in nom", yes :)

[13:36] <tadzik> then don't bother :P

[13:36] * masak disobeys and submits rakudobug

[13:36] <tadzik> masak: tag it with 'workswithnom' or something

[13:37] <jnthn> nom: say "OH"; return; say "HAI"

[13:37] <p6eval> nom: OUTPUT«OH␤Attempt to return outside of any Routine␤current instr.: 'die' pc 375291 (src/gen/CORE.setting.pir:91463) (src/gen/CORE.setting:204)␤»

[13:37] <masak> oh!

[13:37] <masak> that wasn't nom above, was it? :)

[13:37] <jnthn> :P

[13:37] <tadzik> you said you know that it works with nom

[13:37] * tadzik confused

[13:37] <masak> I guess I didn't know. :)

[13:38] <masak> sorear: something that doesn't start with "n" :P

[13:38] <masak> (as in, new name suggestion for nom)

[13:38] <masak> for niecza! dammit!

[13:38] <tadzik> miecza!

[13:38] <tadzik> phenny: "miecza"?

[13:38] <phenny> tadzik: "sword" (pl to en, translate.google.com)

[13:39] <tadzik> well, it's rather "sword's"

[13:39] <mberends> jnthn: did you know there was an ICU for Windoze? It was news to me. http://site.icu-project.org/download/48#ICU4C-Download

[13:39] <masak> *and* it's much easier to remember than "niecza". oh wait. :P

[13:39] *** wamba joined
[13:39] <jnthn> mberends: ooh :)

[13:40] <pmichaud> masak/mberends:  jnthn and I have been discussing timing of star releases

[13:40] <pmichaud> we could use your opinions

[13:40] <masak> ooh

[13:40] <mberends> jnthn: I'm going to try to integrate it with 6model/c in both Win and Unix versions

[13:40] <pmichaud> we'd like to have a nom-based star release before yapc::eu

[13:40] <mberends> pmichaud: ah

[13:41] <pmichaud> but it's unlikly (and perhaps unwise) to do that for the july release

[13:41] <masak> pmichaud: oh, so it's still "Star"?

[13:41] <pmichaud> doesn't have to be "Star", no.

[13:41] <pmichaud> a distribution release, though.

[13:41] <masak> right.

[13:41] <masak> I kinda figgered, if nom isn't "next boosting step", what is?

[13:41] <masak> hence, new name.

[13:42] <pmichaud> i.e., when we get to yapc::eu, we'd like to tell people "if you want to play with the latest Perl 6 goodness, download <insert nom-based thingy here>"

[13:42] <mberends> I'd prefer to put the brakes on inventing more new names

[13:43] <pmichaud> mberends: I'm wondering if putting the brakes on names is a premature stabilization

[13:43] <pmichaud> it's still "Rakudo", after all.

[13:44] <masak> right.

[13:44] <mberends> but we should not re-use the Star name if what we're releasing is not at least as well supported by modules.

[13:44] <masak> people liked "Rakudo Star". maybe they'll perk up when they hear "Rakudo <next great thing>"

[13:44] <pmichaud> the upside of a new name is it gives us ability to "break" somewhat with the Star ecosystem.  the (big) downside of a new name is that we have to explain the difference.  :)

[13:45] <mberends> there is too little time now to port y

[13:45] <mberends> * the modules from earlier Stars

[13:45] <pmichaud> oh, I should mention that we were thinking that the new distribution release (named "Star" or other) would be second week of august, not last week of July.

[13:45] <pmichaud> i.e., right before yapc::eu

[13:46] <masak> right.

[13:46] <pmichaud> that gives a little more time for module portage and the like.

[13:46] <pmichaud> (which might still not be enough time :)

[13:46] <mberends> from a contributor perspective Star was an almost year long process, with a roadmap.

[13:47] *** drbean left
[13:47] <jnthn> Also important is making sure panda and pes work on nom.

[13:47] <tadzik> I'll handle that

[13:48] <mberends> and Zavolaj

[13:48] <tadzik> yes

[13:48] <pmichaud> anyone have a time estimate for how long it might make for modules to work with a nom-based system?

[13:48] <pmichaud> *might take

[13:48] <pmichaud> are we talking weeks, months, ... ?

[13:49] <masak> I actually have the impression that breakage won't be so bad.

[13:49] <tadzik> pmichaud: depends on the nom state

[13:49] <masak> oh! true.

[13:49] <pmichaud> tadzik: well, I'm assuming that nom has become master by the July release.

[13:49] <masak> right, depends on where we regress.

[13:49] <tadzik> if it'll be as-complet-as-master, that's a matter of hours, maybe days

[13:49] <pmichaud> and that it's in the same order of capabilities as nom.

[13:50] <masak> seems that regressions will be hard to predict.

[13:50] <tadzik> writing panda from scratch would be a matter of hours, I don't think porting will be harder :)

[13:50] <masak> pmichaud: what tadzik said. a concerted effort might ensure everything works in the span of a weekend.

[13:50] * tadzik mumbles something about a hackathon

[13:51] <pmichaud> It wouldn't bother me too much if we did that concerted effort at the yapc::eu hackathon.

[13:51] <pmichaud> (if we had to.)

[13:51] <tadzik> not the during-yapc one, I think before, even on irc

[13:51] <tadzik> to have everything tip-top til yapc

[13:51] <pmichaud> then release the new distribution on Sunday before yapc::eu

[13:51] <jnthn> The main thing I'm seeing in panda is that it really wants IO/exteranl calling stuff to work (which shouldn't be too hard to get back) and it also uses deferral quite a bit (which is harder)

[13:51] <pmichaud> I think IO isn't a difficult blocker.

[13:51] <tadzik> deferral?

[13:52] <jnthn> nextsame, etc

[13:52] <pmichaud> tadzik: yes, a hackathon before then could be made to work also, if we can figure out a time for it.

[13:52] <tadzik> oh, right

[13:52] <pmichaud> oh, I susepct we need nextsame to work before nom->master

[13:52] <tadzik> that can be worked around though, methinks

[13:52] <mberends> I personally expect to have time for hacking around yapc:eu, but will probably not go to Riga. I'll see whether moritz might be in the same situation and go to Erlangen.

[13:52] <pmichaud> nextsame is pretty core.

[13:53] <masak> +1

[13:53] <jnthn> Yeah, difficult too :)

[13:54] <pmichaud> not having nextsame would be too big a regression, I think -- especially since that's the canonical answer to "how do I call my parent's method?"

[13:54] <jnthn> *nod*

[13:54] <jnthn> I'll try and sort it out before $vacation.

[13:54] <pmichaud> okay.

[13:55] <pmichaud> the other question is the timing of the July Star release.

[13:55] <jnthn> Mostly it's tricky because I can't do it anything like I did last time around.

[13:55] <jnthn> So need to completely redesign it.

[13:55] <pmichaud> There will unboutedly be a Star release in July based on the 2011.06 release of Rakudo.

[13:56] <pmichaud> There's no reason it has to take place the last week of July -- we could push it a little early this month, to give more time/space before whatever nom-based distribution we create in August.

[13:56] <pmichaud> also we might be able to identify important changes and/or deprecations that people might want to be aware of

[13:57] <pmichaud> s/unboutedly/undoubtedly/   # boy did I mistype that one :)

[13:58] *** pmurias joined
[13:58] <pmichaud> opinions on this would be welcome also

[13:58] * jnthn things giving people deprecation warnings is useful

[13:58] <pmichaud> I'm worried we might not know what to warn about until nom->master :)

[13:58] <pmichaud> (which implies a late-July release, which is fine)

[13:59] <jnthn> Of note, we do know about a lot of the non-regression deprecations.

[13:59] <jnthn> Like, .new behaving differently

[13:59] <jnthn> Attribute changes

[13:59] <jnthn> and so forth

[13:59] <pmichaud> we need to collect those tidbits somewhere

[14:00] <jnthn> indeed

[14:00] *** Mowah left
[14:01] *** Chillance left
[14:05] <pmichaud> anyway, if anyone has any more thoughts/ideas on the subject, please send me a message (phenny, email, backlog notes, whatever)

[14:05] <mberends> ok (bit afk atm)

[14:06] <pmichaud> I completely agree with mberends that if we continue to use the Star name there should not be any significant regress

[14:06] *** birdwindupbird left
[14:06] <pmichaud> I also think a bring-modules-up-to-speed hackathon could be really worthwhile.

[14:07] <masak> agreed.

[14:07] <mberends> +1

[14:07] <masak> (but I also think we should look for a name that's not Star)

[14:09] <mberends> Nova

[14:09] <masak> it's cute, but hard to follow up on. "Interstellar Dust"? :P

[14:09] <jnthn> "Doesn't go" - nah. It goes!

[14:10] <pmichaud> I'm tentatively thinking module hackathon can be either the weekend of Jul 30 (preferred) or Aug 6 (if we're not able to do the 30th)

[14:11] <mberends> wfm, maybe even with a trip to .de or .se

[14:12] <pmichaud> since the "Star" also meant "Whatever", we're free to move outside of the celestial realm for names if we wish :)

[14:13] <pmichaud> naming ideas always welcomed

[14:13] <pmichaud> I need to get back to hacking for a while -- bbl

[14:13] <masak> mberends: you're welcome to .se -- would be great!

[14:14] *** wamba left
[14:14] *** buubot_backup left
[14:14] <mberends> masak: \o/

[14:14] *** wamba joined
[14:14] <masak> "Rakudo Hyper" -- it's not so lazy anymore. :P

[14:14] <flussence> Rakudo Guillemot? :)

[14:15] <masak> point taken.

[14:16] <flussence> .oO( this would be much easier if we had a time machine; release with a crap name, then go back and rename it to whatever the most "They should've named it $x" complaints say :)

[14:17] <pmichaud> .oO( Perl 6 would be much easier with a time machine... release it with most of the features missing....  :)

[14:17] <masak> flussence: but wouldn't that create an unstable loop in the continuum?

[14:17] <mberends> lue++ has been to the future a couple of times, maybe he can remember what people are going to say ;)

[14:18] <flussence> can't say for sure, it's pretty hard to apply TDD to a time machine...

[14:18] *** Chillance joined
[14:18] <TimToady> if loops go unstable they just bifurcate the universe so we never see 'em :)

[14:18] <masak> flussence: "Test First... but not necessarily in that order." :)

[14:18] <jnthn> mberends: You're welcome to crash here in .se also

[14:19] <masak> mberends: yes, crash at jnthn's place. his apartment has several rooms. :)

[14:19] <jnthn> Yes, but the kitchen and bathroom aren't very crashable :P

[14:20] <tadzik> :)

[14:20] <jnthn> My place in BA was *awesome* in terms of space :)

[14:20] <masak> ooh! $inventory is a Container! :) nice!

[14:20] <mberends> jnthn: cool. I was thinking about hacking 6model, but that can wait until after yapc::eu

[14:20] <tadzik> mberends: what about popolnik?

[14:20] <jnthn> mberends: I'm sure we can discuss that some too :)

[14:21] <mberends> tadzik: (blush) almost totally forgotten

[14:21] <tadzik> (:

[14:22] <mberends> (my London host is porting biggishint.c to... Excel !?)

[14:23] <masak> o.O

[14:23] <tadzik> wut

[14:23] <jnthn> O.O

[14:24] *** MayDaniel joined
[14:27] <pmurias> what's biggishint.c?

[14:27] *** Moukeddar left
[14:28] <mberends> pmurias: a fairly high precision integer math library, see https://github.com/jnthn/zavolaj/tree/master/examples

[14:30] *** Moukeddar joined
[14:34] <masak> nom: sub foo($ = 0) { say "OH HAI" }; foo; foo(5)

[14:34] <p6eval> nom: OUTPUT«OH HAI␤OH HAI␤»

[14:35] <masak> just checking :)

[14:37] *** buubot_backup joined
[14:37] <masak> text adventure games are complicated. ;)

[14:37] *** mberends left
[14:39] *** mberends joined
[14:41] <pmurias> masak: are you writing one?

[14:41] <masak> pmurias: yes, for the June 29 and June 30 posts on my blog.

[14:41] <masak> (yes, I'm slightly late)

[14:46] *** mberends left
[14:52] *** van7hu joined
[14:52] <van7hu> hi

[14:52] <masak> hi, van7hu 

[14:54] <flussence> Is there any way to get nom to work when I'm not running it from `./perl6`? I get «"load_bytecode" couldn't find file 'Perl6/Grammar.pbc'» if I'm not in the same directory.

[14:54] <jnthn> flussence: Only if make install works

[14:55] *** wamba left
[14:56] <flussence> doesn't seem to be an error there... I'm using --gen-parrot if that makes a difference, neither the perl6 in the top level dir or the one in install/bin works.

[14:56] <tadzik> I found my attempts to make it work in my git stash recently

[14:57] <masak> flussence: you need to 'make install' in order to run from anywhere.

[14:58] <flussence> yeah, but I've tried that :(

[15:02] *** MayDaniel left
[15:04] <masak> flussence: seems there is some known problem with 'make install' on nom. I don't know more about it, though.

[15:04] *** shinobicl joined
[15:05] *** Moukeddar left
[15:05] *** Moukeddar_ joined
[15:06] *** [perlhack] joined
[15:07] *** wamba joined
[15:07] <tadzik> flussence: I was working on that, and brought to it to a state when you could either have nom working with in then nom directory or outside it, not by any chance in both :(

[15:11] *** mberends joined
[15:11] *** wamba left
[15:19] *** mberends left
[15:20] *** Moukeddar_ left
[15:26] <masak> the adventure game just crept over 400 lines of code.

[15:26] <masak> it's getting marginally fun to play, too :)

[15:28] <tadzik> (:

[15:29] *** JimmyZ joined
[15:29] *** shinobicl left
[15:29] <JimmyZ> good evening, #perl6

[15:33] <tadzik> does |@foo flatten @foo by any chance?

[15:33] <masak> tadzik: yes...? :)

[15:33] <tadzik> ...crap :)

[15:34] *** mberends joined
[15:34] <tadzik> my $insides := $*ST.add_constant('Array', 'type_new', |@content);, @content is array of arrays. How do I keep it this way?

[15:34] <tadzik> nom: my $a = Array.new([1, 2], [3, 4], [5, 6]); say $a.perl

[15:34] <p6eval> nom: OUTPUT«[[1, 2], [3, 4], [5, 6]]␤»

[15:35] <tadzik> nom: my @a = 1, 2; my @b = 3, 4; my $c = Array.new(|@a, |@b); say $c.perl

[15:35] <p6eval> nom: OUTPUT«[1, 2, 3, 4]␤»

[15:35] <tadzik> yeah, that's the thing

[15:35] <tadzik> nom: my @a = 1, 2; my @b = 3, 4; my $c = List.new(|@a, |@b); say $c.perl

[15:35] <p6eval> nom: OUTPUT«(1, 2, 3, 4).list.item␤»

[15:36] <tadzik> nom: my $a = 1, 2; my $b = 3, 4; my $c = Array.new(|@a, |@b); say $c.perl

[15:36] <p6eval> nom: OUTPUT«Symbol '@a' not predeclared in <anonymous> (/tmp/ihC6i7FTY7:1)␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[15:36] <tadzik> nom: my $a = 1, 2; my $b = 3, 4; my $c = Array.new(|$a, |$b); say $c.perl

[15:36] <p6eval> nom: OUTPUT«Method 'ARGLIST_FLATTENABLE' not found for invocant of class 'Int'␤current instr.: '_block1002' pc 131 ((file unknown):39995992) (/tmp/KE75cB4y0d:1)␤»

[15:36] <tadzik> :)

[15:36] <tadzik> jnthn?

[15:36] <masak> nice YAPC::NA post. http://babyl.dyndns.org/techblog/entry/asheville-part-II

[15:37] <masak> contents: TimToady's huggable talk, Abigail making a talk that sounds over-the-top but is sincere.

[15:37] *** man joined
[15:37] <masak> man!

[15:37] <masak> man: am I tired today :P

[15:38] <man> take a nap

[15:38] <man> =D

[15:38] <masak> yeah :)

[15:39] <man> I'm looking for introductory material on perl 6

[15:39] <masak> man: you're in the right place!

[15:39] <man> interested in OO features it has

[15:40] <masak> man: there's the advent calendar, which contains lots of examples.

[15:40] <masak> man: the end of my blogging month at http://strangelyconsistent.org/ talks about OO.

[15:40] <man> nice, I gonna take a look at it

[15:40] <masak> man: beyond that, I think I'd need to know what level you're at and what your expectations are.

[15:41] <masak> http://perl6advent.wordpress.com/

[15:41] <man> I'm new to perl at all, just started reading something about, I saw perl 6 is even better then 5 is

[15:42] <masak> ok. that's true from some angles and not from others. :)

[15:42] <masak> just so you know.

[15:42] <masak> here, let me show you some OO:

[15:42] <man> but I'm not sure if it will be better to start learning perl 5 and then lern perl 6

[15:42] <man> or go straight to perl 6

[15:42] <masak> rakudo: class A { has $.x }; my $a = A.new(:x(42)); say $a.x

[15:42] <p6eval> rakudo 72d158: OUTPUT«42␤»

[15:43] <masak> man: either path is possible. I learned Perl 5 first and then Perl 6, basically. but learning one often helps in learning the other, because they are similar in some ways.

[15:44] <man> good to know

[15:44] <masak> rakudo: role Foo { method foo { say "foo!" } }; role Bar { method bar { say "bar!" } }; class C does Foo does Bar {}; my $c = C.new; $c.foo; $c.bar

[15:44] <p6eval> rakudo 72d158: OUTPUT«foo!␤bar!␤»

[15:44] <man> but, one question, perl 6 is at development stage yet?

[15:44] <jnthn> tadzik: my $a = 1, 2 parses as (my $a = 1), 2

[15:44] <masak> man: yes, it's definitely at development stage.

[15:45] <man> when it will come to the wild?

[15:45] <masak> man: what you see me running above is an actual Perl 6 implementation.

[15:45] <masak> man: it's in the wild, man!

[15:45] <mberends> man: p6 has much more OO in the core, p5 had OO kinda bolted on. but for production, p5 already has 10000's of modules, p6 only a handful.

[15:45] <masak> man: the URL to my blog that I gave you -- that blog is running Perl 6.

[15:45] <man> I saw, perl 6 is much better on OO

[15:46] <tadzik> jnthn: okay, but how do I make an array of arrays with add_constant?

[15:46] <masak> man: well, Moose (for Perl 5) is pretty cool too. but it's not built in.

[15:46] <masak> in Perl 6, OO runs all the way down.

[15:48] <man> advent calendar seems nice

[15:48] <masak> keep in mind that there are two years' worth of material.

[15:49] <man> \o/

[15:49] <masak> I mean, so you don't miss the 2009 stuff. it's often about more basic features.

[15:50] <man> I liked perl, because it feels like programming language itself, kind of strange, but seems productive

[15:50] <masak> I know what you mean :)

[15:50] <man> with some strange stuff that is different from other languages

[15:51] <masak> there's a list of 2009 posts, but it's way over at the start of the blog: http://perl6advent.wordpress.com/2009/12/01/perl-6-advent-calendar/

[15:51] <man> you know, something that only programmers understand :)

[15:51] <tadzik> isn't that typical for programming languages?

[15:51] <masak> yeah :)

[15:51] <masak> Day 11 is about classes.

[15:51] <man> not a language that other people can understand but makes programmers life harder

[15:52] <masak> tadzik: you mean that Perl isn't the only programming language for programmers? heresy! :P

[15:52] <man> like shell script, very strange, but nice when you know it

[15:52] <tadzik> man: harder?

[15:53] <jnthn> tadzik: Add each array, then call add_constant for array with a |@arrays. Note that NQP *@foo is really like Perl 6 **@foo

[15:53] <tadzik> jnthn: that's what I did. Will paste the code

[15:54] <jnthn> tadzik: oh, did they end up getting up flattened? :)

[15:54] <masak> ooh -- 'take X' is just a special case of 'put X in inventory' :)

[15:54] <tadzik> jnthn: https://gist.github.com/1074641

[15:54] <tadzik> yep

[15:54] <masak> and 'drop X' is just a special case of 'put X in the current room'...

[15:54] <jnthn> tadzik: heh, splat.

[15:54] <masak> unifications++ \o/

[15:55] <tadzik> jnthn: hm?

[15:55] <jnthn> tadzik: Thinking how best so solve it.

[15:55] <tadzik> ok

[15:56] <jnthn> tadzik: I mean, the easy way is to just call .item on every one of the arrays before the final .add_constnat call

[15:56] <jnthn> tadzik: but...darn, that won't work

[15:57] <jnthn> tadzik: All itemization is, is wrapping things in a Scalar

[15:57] <jnthn> tadzik: It's like you want to write $*ST.itemize or $*ST.scalar_wrap or some such.

[15:57] <tadzik> mhm

[15:59] <jnthn> I think that's gonna be your best bet.

[15:59] *** cooper joined
[15:59] *** shinobicl joined
[15:59] <tadzik> so I need to write something like this?

[16:00] <jnthn> tadzik: yeah

[16:00] <tadzik> oh gosh.

[16:00] <jnthn> It should find_symbol(['Scalar']), repr_instance_of it and then bind the $!value to the thing you pass it to itemize

[16:01] <jnthn> Then the deserialization code for doing that

[16:01] <tadzik> piece of cake

[16:01] *** man left
[16:01] *** kaare_ left
[16:02] <tadzik> ok, let's try

[16:03] <jnthn> tadzik: https://gist.github.com/1074649 # totally untested

[16:04] *** _jaldhar left
[16:05] *** _jaldhar joined
[16:06] <tadzik> and now .add_event(:deserialize_past()), or something?

[16:06] <tadzik> hmm. It just worked

[16:06] <tadzik> tests pass, and everything

[16:07] *** daniel-s left
[16:09] <tadzik> jnthn: what do I need this deserialization stuff for?

[16:11] *** mberends left
[16:13] *** thou joined
[16:14] <shinobicl> hi, is there a way to use the perl5 "prove" with perl6?

[16:14] <tadzik> sure, we use it all the time

[16:14] <tadzik> just make it prove -e perl6

[16:14] <masak> shinobicl: yes, with a sufficiently new version of Test::Harness.

[16:14] <masak> 3.16 or something.

[16:15] *** zby_home_ joined
[16:17] *** MayDaniel joined
[16:18] <jnthn> tadzik: pre-compilation

[16:18] <jnthn> tadzik: So you could always leave it for now

[16:19] <shinobicl> mmm. i got an "open3: exec of perl6 failed" error

[16:20] <masak> shinobicl: do you have perl6 in your $PATH?

[16:20] <shinobicl> no, just an alias.... thanks masak :)

[16:20] <masak> that's probably it, then :)

[16:22] *** van7hu left
[16:25] *** JimmyZ left
[16:26] *** mberends joined
[16:27] *** am0c joined
[16:29] *** whiteknight joined
[16:30] *** MayDaniel left
[16:33] <masak> rakudo: class A { method foo { self.?bar(42) }; method bar(Num) { say "never binds" } }; A.new.foo

[16:33] <p6eval> rakudo 72d158: OUTPUT«Nominal type check failed for parameter ''; expected Num but got Int instead␤  in 'A::foo' at line 22:/tmp/cwVHizvWvX␤  in main program body at line 22:/tmp/cwVHizvWvX␤»

[16:33] <masak> jnthn: bug?

[16:34] <jnthn> no

[16:34] <masak> note the ?

[16:34] <jnthn> noted

[16:34] <masak> I'm missing something, then.

[16:34] <jnthn> you didn't fail to dispatch

[16:35] <jnthn> you failed to bind to what the dispatcher found

[16:35] <masak> oh.

[16:35] <masak> noted.

[16:35] <masak> will remember that :)

[16:35] <moritz> so with a 'multi method' it should just return Nil?

[16:36] <masak> rakudo: class A { method foo { self.?bar(42) }; multi method bar(Num) { say "never binds" } }; A.new.foo

[16:36] <p6eval> rakudo 72d158:  ( no output )

[16:36] <moritz> \o/

[16:36] <masak> \o/

[16:36] <jnthn> I'm, er

[16:36] <jnthn> Not convinced that's going to work with the new multi semantics.

[16:36] <masak> :)

[16:36] <masak> why not?

[16:36] <jnthn> So far as the method dispatcher cares, it dispatched just fine to a proto.

[16:36] <jnthn> It's the multi-dispatcher that the proto delegated to that then failed.

[16:37] * masak .oO( it shouldn't be called "whenn't", it should be called "wunless"! )

[16:37] <jnthn> We went the way of separate dispatchers.

[16:37] <jnthn> This is one of the negatives.

[16:37] <masak> jnthn: agree.

[16:37] <jnthn> Though the positives generally make it worth doing.

[16:37] *** wamba joined
[16:37] <masak> it's probably saner in the long run.

[16:37] <jnthn> yeah

[16:38] <jnthn> .?foo is really useful if you may have a method to call based on something being mixed in or not mixed in.

[16:38] <jnthn> I don't think we want to go down the route of .?foo suppressing exceptions that happen to the thing that was dispatched to though.

[16:38] <jnthn> Especially then "try" is available in blockless form.

[16:38] <masak> nodnod

[16:39] <masak> I've already worked around it. :) it's better this way. :)

[16:39] <masak> when Car { say "Great. Now your car is full of leaves." }

[16:39] <masak> :P

[16:39] * masak plays the game and tries to stuff his car full of leaves

[16:42] <masak> it worked :P

[16:43] <tadzik> I could play the cars and leaves game, but I have to hack on tables instead :(

[16:44] <masak> I'm sure there'll be a break somewhere. :)

[16:44] <masak> and the game will only get more implemented the more you wait. :)

[16:44] <tadzik> if I finish those tables today it'd be great

[16:44] <jnthn> tadzik++

[16:44] <tadzik> I've added like 100 LOC to Actions.pm and I'm like in 3/4 of the problem

[16:44] * jnthn is currently trying to figure out how on earth to implement nextsame etc

[16:44] <tadzik> with the most complex one still ahead :)

[16:45] <masak> jnthn: bet you wish you could just delegate the problem? :P

[16:45] <jnthn> masak: Well volunteered! :P

[16:45] <masak> well misunderstood! :P

[16:45] <jnthn> Dang! :P

[16:46] <masak> Phew! :P

[16:46] <dalek> roast: a4c379f | Coke++ | S32- (2 files):

[16:46] <dalek> roast: track nom regressions.

[16:46] <dalek> roast: review: https://github.com/perl6/roast/commit/a4c379f34e

[16:46] <tadzik> :D

[16:46] <jnthn> The problem isn't so much doing it, it's doing it without making nom a bunch slower when the majority of the time we don't defer.

[16:47] <jnthn> master makes *every* method dispatch pay a GC-able object allocation for the few that actually use nextsame et al.

[16:47] <dalek> rakudo/nom: 850e5c6 | Coke++ | t/spectest.data:

[16:47] <dalek> rakudo/nom: track more nom test status.

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/850e5c67e3

[16:47] *** jevin joined
[16:47] <jnthn> And I'd really rather we didn't do that in nom.

[16:49] <tadzik> ouch

[16:50] *** satyavvd joined
[16:52] <jnthn> Then it's trying to make this work when we have a method cache and multi-dispatch cache around

[16:52] <jnthn> Plus still trying to unify all of these different dispatchers.

[16:53] *** Bzek left
[16:56] * masak begins to see why it might be a tad difficult

[16:57] *** mberends left
[16:59] <jnthn> walk &

[17:01] <masak> I'm getting a better appreciation for why text adventure games are sometimes very contrained in their language. :)

[17:01] <tadzik> (:

[17:04] <masak> I will pass 500 LoC later this evening. but that's enough hacking for now.

[17:11] *** dual left
[17:12] *** satyavvd left
[17:16] *** shinobicl left
[17:22] *** Instil joined
[17:27] *** Instil left
[17:29] *** Instil joined
[17:33] *** mberends joined
[17:39] *** [perlhack] left
[17:40] *** MayDaniel joined
[17:40] *** MayDaniel left
[17:54] *** dual joined
[17:56] *** simcop2387 left
[17:58] *** simcop2387 joined
[17:59] *** jimmy1980 left
[18:01] *** colomon joined
[18:02] *** jedai_ joined
[18:02] *** jimmy1980 joined
[18:02] *** jedai left
[18:08] *** jack-ji left
[18:08] <tadzik> \o/

[18:08] <tadzik> masak: want to look at my magical cell splitting algorithm? :)

[18:11] <pmurias> masak: have you heard of dependency parsing?

[18:12] *** mberends left
[18:15] *** mberends joined
[18:20] *** wamba left
[18:22] *** REPLeffect left
[18:32] <tadzik> okay, I want a walk too :)

[18:34] *** bluescreen10 left
[18:35] *** wamba joined
[18:36] <sorear> good * #perl6

[18:38] *** donri joined
[18:48] <tadzik> hello sorear 

[18:48] *** mberends left
[18:51] <pmurias> sorear: hi

[18:54] *** Kivutarrr left
[18:57] <thou> i am seeing the weirdest bug w/ rakudo

[18:57] <thou> tadzik: you around?

[18:58] <moritz> show it

[18:58] <thou> it is the Digest::MD5 project from github

[18:58] <thou> if use ufo and 'make', the  'make test' fails on t/perl5-compat.t

[18:59] <thou> but if i change the text of the comment at the top, it works

[18:59] <thou> i'll try to actually show it

[18:59] *** Kivutarrr joined
[18:59] <thou> #

[18:59] <thou> # Test compability with Perl5 Digest::MD5

[18:59] <thou> #

[18:59] <thou> use Test;use Digest::MD5;

[18:59] <thou> ^ This is the original. it fails with: 

[19:00] <thou> tim@lakshmi:~/g/code/p6/perl6-digest-md5$ env PERL6LIB=/Users/tim/g/code/p6/perl6-digest-md5/blib/lib:/Users/tim/g/code/p6/perl6-digest-md5/lib:. perl6 t/01-basic.t 

[19:00] <thou> ===SORRY!===

[19:00] <thou> Confused at line 6, near "\n\nok(1, 'M"

[19:00] *** jimmy1980 left
[19:00] <thou> (i renamed the test to 01-basic.t to see if that was the problem)

[19:00] <thou> now if i fix the spelling of compatibility, it works. I change that one word only:  # Test compatibility with Perl5 Digest::MD5 

[19:00] <thou> save, and re-run:

[19:00] <tadzik> thou: oui

[19:01] <thou> im@lakshmi:~/g/code/p6/perl6-digest-md5$ env PERL6LIB=/Users/tim/g/code/p6/perl6-digest-md5/blib/lib:/Users/tim/g/code/p6/perl6-digest-md5/lib:. perl6 t/01-basic.t 

[19:01] <thou> ok 1 - Module loaded

[19:01] <thou> ok 2 - MD5 hex of 'Hello World' must be 'b10a8db164e0754105b7a99be72e3fe5' (static method)

[19:01] <thou> ... ok all the rest

[19:01] <thou> *so* weird

[19:01] <moritz> that's... very weird indeed

[19:01] <moritz> thou: please try   find -name \*.pir

[19:01] <thou> I re-typed that line w/o any copy/paste in case there were some weird chars that vim wasn't showing me

[19:02] <thou> tim@lakshmi:~/g/code/p6/perl6-digest-md5$ find . -name \*pir

[19:02] <thou> ./blib/lib/Digest/MD5.pir

[19:02] <moritz> it could be an out-of-date .pir version of the test file, where writing to the file forced recompilation

[19:02] <thou> tadzik: you were able to repeat that bug, right?

[19:02] <moritz> hm

[19:02] <tadzik> thou: si

[19:02] * moritz needs to compile a rakudo/master first

[19:02] <thou> tadzik: can you repeat the fix?

[19:03] <tadzik> thou: in a sec

[19:03] <thou> to confirm i'm not just crazy....

[19:03] <thou> i'm not really going to complain if rakudo doesn't like misspellings in comments

[19:03] <thou> but i would prefer a more helpful error message

[19:03] <thou> ;-)

[19:03] <moritz> :-)

[19:04] <tadzik> perl Configure.pl --buzz-off-aspell

[19:05] <thou> moritz: it's not out-of-date pir for the test; there's no pir for the test at all; plus i've flip-flopped this test many times back and forth, with consistent results

[19:05] <thou> works if i remove several letters from that word, too

[19:05] <tadzik> wat

[19:06] <thou> seems to be that *exact* num of chars

[19:06] <thou> if i remove several other chars in the comment, but fix the spelling of compatibility, it has same error

[19:06] <thou> one more or one fewer chars, and it passes

[19:07] <thou> hmmm, i can add a single char to a different line of the comment, and it fails

[19:07] <thou> so it's the total chars in that set of lines that make up the comment

[19:07] <tadzik> ok, looking on that

[19:07] <moritz> I reproduced the error

[19:08] <thou> e.g., this fails:  # # Test compatibility h Perl5 Digest::MD5  #

[19:08] *** jimmy1980 joined
[19:08] <thou> ^ only comment line, no spaces after last #

[19:08] *** cipherte1t joined
[19:08] <moritz> curious enough, it goes away if I remove the .pir version of the module

[19:08] <thou> moritz: yes, that was the original symptom i complained to tadzik about; i thought it was a panda bug

[19:09] <thou> but it was just that panda was building it, and i had been testing w/o building it

[19:09] <thou> soooo strange :-)

[19:09] <moritz> after an rm -rf blib; git checkout .; make test # passes again

[19:09] <thou> i'm glad it's not just on my machine, or i'd be really scared

[19:09] <tadzik> :)

[19:09] <tadzik> solar rays!

[19:10] <moritz> git clean -xdf; ufo; make # there's the error again

[19:10] <moritz> I'll bring Ronja to bed and then see if I can provide any more diagnostics afterwards

[19:10] *** ciphertext left
[19:11] <thou> ok

[19:18] <masak> ooh, a weird bug! :>

[19:18] <masak> thou++

[19:19] <thou> has to be 47 chars before "use Test;

[19:19] <masak> pmurias: no, I don't believe I've heard of dependency parsing.

[19:19] <tadzik> :O

[19:19] <thou> and if i put "use  Test;" (two spaces), it goes away, too

[19:19] <masak> very weird indeed.

[19:19] <thou> or a space after "use Test; "

[19:19] <tadzik> the double bacon bug is nothing compared to this :)

[19:20] <tadzik> thou: just put the space there and let's pretend this never happened :D

[19:20] <masak> please let's summarize it a bit.

[19:20] <thou> space before "Digest::" avoids bug, too

[19:20] <masak> it's a parsing bug, yes?

[19:20] <tadzik> yes

[19:20] <masak> what else?

[19:20] <tadzik> relates to the number of whitespace/comment characters

[19:20] <thou> space after Digest avoids it, but space after ; does not avoid it

[19:20] <masak> what's the shortest program that exhibits the bug? preferably on one line.

[19:21] <tadzik> we need a genetic algorithm to generate it :)

[19:21] <masak> as few dependencies as possible.

[19:21] <thou> ok, i can replace "use Test;" with spaces and the bug remains

[19:21] <masak> tadzik: humans are perfectly good generic algorithms, most of the time :P

[19:22] <tadzik> (:

[19:22] <thou> #23456789 123456789 123456789 123456789 123456789 123456

[19:22] <thou> use Digest::MD5;

[19:22] <thou> ^ That reproduces it

[19:22] <thou> but only if Digest::MD5 is compiled to pir

[19:22] <masak> that's a big clue.

[19:22] <masak> (the "but only" part)

[19:22] <tadzik> how about any other module compiled to pir?

[19:24] <thou> btw if i remove one char from the comment, and add a space e.g., before or after "Digest", it still happens.

[19:25] <masak> thou: wfm. I put those two lines in foo.pm, and did 'perl6 --target=pir foo.pm' -- it works fine.

[19:25] <masak> I may not have the very latest Rakudo, though. hold on and I'll rebuild.

[19:25] <thou> env PERL6LIB=/Users/tim/g/code/p6/perl6-digest-md5/blib/lib:/Users/tim/g/code/p6/perl6-digest-md5/lib:. perl6 t/01-basic.t

[19:26] <masak> no, I was on latest master.

[19:26] <thou> those two lines are in 01-basic.t

[19:26] <masak> thou: hm, blib...

[19:26] <thou> i didn't try compiling to pir

[19:26] <masak> ok, so there are no existing pir files involved?

[19:26] <thou> blib/lib/Digest/MD5.pir

[19:26] <thou> exists

[19:27] <thou> no other pir

[19:27] <masak> try removing it?

[19:27] <thou> then bug goes away

[19:27] <masak> ah.

[19:27] <masak> right, you said above.

[19:27] <masak> that's the step I'm missing right now, then.

[19:27] *** shinobicl joined
[19:27] *** benabik left
[19:28] *** benabik joined
[19:29] <masak> nope, works even after I compile a Digest/MD5.pm to PIR.

[19:29] <masak> but I'll try the right one.

[19:31] <thou> ok, can repeat without ufo; i copied Digest::MD5.pm to /tmp/Digest-MD5.pm, and moved my test script there ("use" line and adding a char to the comment as appropriate)

[19:31] *** [Coke] left
[19:32] <thou> 2101  perl6 --target=pir --output=Digest-MD5.pir Digest-MD5.pm

[19:32] <thou>  2102  PERL6LIB=. perl6 buggy.pl6 

[19:32] <jnthn> so...pre-compiled breaks parsing?

[19:32] <thou> yeah

[19:32] <masak> the PERL6LIB=. should be unnecessary by now.

[19:32] <jnthn> Bugs. We make EXCELLENT ones. :/

[19:32] <masak> at least if you clear the one in %ENV.

[19:33] <thou> i just wanted to avoid anything in env, yeah

[19:33] <jnthn> My only guess is that the MARKED state is somehow too shared.

[19:34] *** [Coke] joined
[19:35] <jnthn> https://github.com/perl6/nqp/blob/master/src/HLL/Grammar.pm#L817 mebbe...

[19:39] *** jevin left
[19:40] <thou> sorry to stir the pot and then run, but i have to leave for a bit. will bbl i hope.

[19:43] *** jevin joined
[19:49] *** Jackneill joined
[19:49] *** Jackneill left
[19:49] *** Jackneill joined
[19:50] *** Jackneill left
[19:53] <moritz> rakudo: say ords(Any).perl

[19:53] <p6eval> rakudo 72d158: OUTPUT«Method 'ords' not found for invocant of class ''␤  in 'ords' at line 2788:src/gen/core.pm␤  in main program body at line 22:/tmp/1dQJaw9rVB␤»

[19:53] <moritz> rakudo: say ords(Cool).perl

[19:53] <p6eval> rakudo 72d158: OUTPUT«(67, 111, 111, 108, 40, 41)␤»

[19:54] <tadzik> rakudo: say ~Cool

[19:54] <p6eval> rakudo 72d158: OUTPUT«Cool()␤»

[19:55] *** [Coke] left
[19:56] <jnthn> heh :)

[19:56] <jnthn> nom doesn't ~ type objects like that.

[19:56] <moritz> I know :-)

[19:56] <jnthn> Which in this case seems an improvement :)

[19:56] <tadzik> I have a feeling I made Actions.pm compilations hell slower

[19:57] <jnthn> tadzik: OH NOES

[19:57] <jnthn> :)

[19:57] <moritz> tadzik: can't think like table construction go into a separate (nqp) module?

[19:57] *** [Coke] joined
[19:57] <tadzik> moritz: may be a sane way, yes

[19:58] <tadzik> I'll also care less for namespace pollution :)

[19:58] *** Limbic_Region joined
[19:58] <tadzik> moritz: your magical cell splitting algorithm is around 70 lines alone

[19:58] <tadzik> but it seems to work just fine :)

[19:59] <tadzik> so something like use Pod::Table; Pod::Table::process_rows()?

[19:59] <moritz> yes (except that "process" is probably a too generic verb)

[19:59] <tadzik> I'll think about it

[19:59] <moritz> more like extract_columns

[20:00] <tadzik> git diff is 419 lines long

[20:00] <tadzik> that's like 10% of Actions.pm :)

[20:00] <tadzik> so maybe the whole Pod processing should go into a separate module?

[20:01] *** icwiener left
[20:01] <moritz> +1

[20:02] <tadzik> oookye

[20:02] *** icwiener joined
[20:02] <jnthn> maybe collect the Pod related stuff in Perl6::PodParser or some such

[20:02] <moritz> rakudo: say ords(42).perl

[20:02] <p6eval> rakudo 72d158: OUTPUT«(52, 50)␤»

[20:03] <moritz> PodActions more likely

[20:03] <jnthn> I'd put it under the Perl6 namespace like Actions, SymbolTable, etc.

[20:03] <tadzik> maybe just Perl6::Pod

[20:03] <tadzik> sounds saneish

[20:03] *** Kivutarrr left
[20:03] <tadzik> and I have a feeling that 'make perl6' is a few minutes now, as 'make' used to be..

[20:04] <tadzik> but well, I finished HPatMoR, I have time for that now :)

[20:04] * moritz still waits for a new chapter

[20:04] <colomon> is it done, or. ... guess not

[20:05] <tadzik> I very liked the 60-something ones, when suddenly it all becomes a Big Deal

[20:07] <colomon> I actually gave up on it early on... weird mixture of irresistible (so I was reading when I shouldn't be) and frustrating. 

[20:07] *** molaf left
[20:07] <moritz> tadzik: aye. The last few read like a collection of clichees and side plots

[20:07] <moritz> tadzik: I hope he'll recover :-)

[20:08] <tadzik> (:

[20:09] <dalek> roast: 5eaae4f | moritz++ | S32-str/ords.t:

[20:09] <dalek> roast: test for ords()

[20:09] <dalek> roast: review: https://github.com/perl6/roast/commit/5eaae4f7d5

[20:09] <dalek> rakudo/nom: cb99254 | moritz++ | / (3 files):

[20:09] <dalek> rakudo/nom: implement and test .ords, &ords()

[20:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cb9925401d

[20:11] <tadzik> does nqp have 'module' in place?

[20:11] <tadzik> Perl6::Pod doesn't need to be a class really

[20:11] <moritz> ack -w module nqp/t

[20:11] <moritz> looks like 'yes'

[20:11] <tadzik> :)

[20:24] *** Mowah joined
[20:31] *** wamba left
[20:33] *** mj41 joined
[20:34] *** Mowah left
[20:34] *** im2ee left
[20:38] <tadzik> I like how 2 smaller files compile faster than 1 bigger file

[20:42] <dalek> rakudo/nom: cd4801e | moritz++ | LHF.markdown:

[20:42] <dalek> rakudo/nom: remove ords() from LHF

[20:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cd4801ea67

[20:46] *** shinobicl left
[20:53] <felher> jnthn++: just saw your talks from bejing, great stuff, thnx. :)

[20:55] *** [Sec] left
[20:59] <jnthn> felher: Glad you enjoyed them :)

[21:00] *** soh_cah_toa joined
[21:00] *** odrm left
[21:02] *** lichtkind joined
[21:03] <tadzik> # Looks like you failed 1 tests of 52

[21:03] <tadzik> one failing test! in 07-tables.t!

[21:03] <tadzik> well, that's due to tests being crap... :)

[21:05] <tadzik> but still, almost there :)

[21:09] *** wamba joined
[21:09] <lichtkind> thou: cheers

[21:14] *** cooper left
[21:16] <jnthn> tadzik: yay :)

[21:17] <tadzik> when I saw "King arthur's singing shovel singing shovel" it reminded me of the bacon bug

[21:17] <tadzik> but this time it's just my fault :)

[21:17] <jnthn> lol

[21:18] <tadzik> I chose some other words when I saw this, but ok :)

[21:23] *** PacoLinux left
[21:23] <tadzik> t/pod/07-tables.t ....... ok

[21:23] <tadzik> woooo

[21:24] <tadzik> what am I going to do with all the free time now? :)

[21:24] <tadzik> besides refactoring this beast

[21:24] *** zby_home_ left
[21:25] <jnthn> refactor that beast!

[21:25] <jnthn> And beer!

[21:25] <jnthn> ;)

[21:25] <flussence> .oO( a string like "failed 1 tests" should be a fail in itself... )

[21:26] <sorear> die, plurals

[21:28] <jnthn> hah, no, resurrect duals!

[21:28] *** Limbic_Region left
[21:29] <tadzik> g diff | wc -l

[21:29] <tadzik> 705

[21:29] <tadzik> I'm even afraid to look inside

[21:30] <jnthn> make backups! :)

[21:30] <tadzik> before commiting :)

[21:32] <dalek> rakudo/podparser: 076e348 | tadzik++ | / (3 files):

[21:32] <dalek> rakudo/podparser: Move pod related metod from Actions.pm to Pod.pm

[21:32] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/076e348fe7

[21:32] <dalek> rakudo/podparser: 8787be2 | tadzik++ | / (6 files):

[21:32] <dalek> rakudo/podparser: Parse tables, import 07-tables.t

[21:32] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/8787be284f

[21:32] <tadzik> please do not review, this needs some mad refactoring :)

[21:33] <tadzik> oh, I accidentally commited the SymbolTable patch with everything else, it was supposed to be a separate commit

[21:34] <soh_cah_toa> what does the "make" function do? i usually see it in grammar/actions files

[21:35] <flussence> make is sort of like return

[21:35] <benabik> soh_cah_toa: It attaches an object to the current match object's .ast property

[21:35] <benabik> And I don't think it acts like return.  I think it continues executing afterwards.  (But I'm less sure of that.)

[21:36] <flussence> or take then :)

[21:36] <soh_cah_toa> ok

[21:37] <benabik> soh_cah_toa: If you look through Actions, there's usually something like `$<statement>.ast`.  That evaluates to the object passed to make.

[21:37] *** mj41 left
[21:37] <benabik> in the statement action.

[21:38] <soh_cah_toa> hmm...ok

[21:38] <tadzik> benabik: your newPOST work seems hell exciting. I'd love to see that :)

[21:38] <benabik> tadzik: It's in the nqp_pct branch of Parrot.  Only real advantage right now is that PAST is now written in NQP so it's far easier to tell what's going on.

[21:38] <benabik> Of course it's written in really _funny_ NQP since I was converting it from PIR.  I have some notes of NQP-isms I should really be using.

[21:39] <tadzik> benabik: I mainly mean direct past -> pbc compilation

[21:39] <tadzik> or is it post->pbc

[21:39] <benabik> tadzik: It's PAST->POST->PBC

[21:39] <tadzik> whatever, skipping the pir layer is worth the work

[21:39] <benabik> Yes yes.

[21:39] <benabik> Not sure if NQP or Rakudo will be able to use it near term...  Not sure how I'm going to handle Q:PIR blocks.

[21:40] <tadzik> okay, I need a walk :) bbs

[21:42] *** Haskelletor left
[21:42] *** Psyche^ joined
[21:45] <jnthn> benabik: Mostly, we try to avoid Q:PIR

[21:45] <jnthn> benabik: But we do have some.

[21:46] *** Patterner left
[21:46] *** Psyche^ is now known as Patterner

[21:47] *** Chillance left
[21:50] <benabik> jnthn: The real sad thing is that PAST and POST still have Q:PIR so they can't direct compile themselves to PBC.  If I have time by end of summer I'm going to try to hook up PIRate to deal with them.

[21:54] * masak .oO( "King Arthur's singing shovel singing shovel" sounds like the more catchy part of a musical number )

[21:57] <tadzik> :)

[21:57] <jnthn> grrrrr....what on earth is wrong with this deferral thingy...

[21:58] <tadzik> . o O ( If you're happy and you know it syntax error! – Syntax error! )

[22:00] <masak> tadzik: ===SORRY===

[22:01] <tadzik> :)

[22:02] <masak> I have a heartfelt recommendation: if you want to experience the fun part of Perl 6, write a text adventure game. it's an experience. :)

[22:03] <jnthn> If not, implement deferal.

[22:04] *** wolfman2000 left
[22:04] * masak .oO( the next version wasn't the same... )

[22:06] <masak> 'night, #perl6

[22:06] *** masak left
[22:09] *** wamba left
[22:17] *** envi left
[22:26] *** meteorjay left
[22:36] *** drbean joined
[22:39] *** cipherte1t is now known as ciphertext

[22:51] *** [Sec] joined
[22:57] <dalek> rakudo/nom: 62c04ce | jonathan++ | / (3 files):

[22:57] <dalek> rakudo/nom: Start to sketch out how dispatchers could look for supporting nextsame et al.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/62c04cea60

[22:57] <dalek> rakudo/nom: b02654b | jonathan++ | src/ops/perl6.ops:

[22:57] <dalek> rakudo/nom: Some ops related to dispatchers.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b02654b549

[22:57] <dalek> rakudo/nom: 0cd9e67 | jonathan++ | src/Perl6/Actions.pm:

[22:57] <dalek> rakudo/nom: multis and methods get a slot for a dispatcher, which just contains a type object; we'll vivify it on demand to create a real dispatcher if nextsame et al are used.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cd9e67b7c

[22:57] <dalek> rakudo/nom: 0ecf393 | jonathan++ | src/ops/perl6.ops:

[22:57] <dalek> rakudo/nom: Toss some dead code.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ecf3939ad

[22:57] <dalek> rakudo/nom: 0373976 | jonathan++ | src/ops/perl6.ops:

[22:57] <dalek> rakudo/nom: First cut of op for finding a dispatcher (doesn't try to consider exhaustedness or any such stuff yet, though).

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/037397630d

[22:57] <dalek> rakudo/nom: db2ce31 | jonathan++ | src/ops/perl6.ops:

[22:57] <dalek> rakudo/nom: Couple of corrections to find_dispatcher op.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/db2ce316bc

[22:57] <dalek> rakudo/nom: 3209cd1 | jonathan++ | src/Perl6/Metamodel/Dispatchers.pm:

[22:57] <dalek> rakudo/nom: Refactor dispatchers; introduce a common case to factor out a bunch of stuff they'll probably all share.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3209cd1aec

[22:57] <dalek> rakudo/nom: 4bc1ac3 | jonathan++ | src/core/ (2 files):

[22:57] <dalek> rakudo/nom: First cut implementation of callwith. Probably not perfect, but essentially works.

[22:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4bc1ac3983

[23:00] *** wamba joined
[23:01] <jnthn> Gotta $dayjob in the morning, so should get some rest. Now I've got the primitives in place, it shouldn't be too bad to get the other deferal bits in place, plus it's the basis for getting .wrap back too.

[23:07] *** Yume joined
[23:09] *** pmurias left
[23:29] *** orafu left
[23:29] *** orafu joined
[23:34] *** wolfman2000 joined
[23:35] *** wamba left
[23:37] *** Yume left
[23:37] *** _jaldhar left
[23:39] *** _jaldhar joined
[23:54] *** ymasory joined
