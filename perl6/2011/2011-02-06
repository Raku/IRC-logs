[00:00] <Tene> rakudo: my @a = 1..10; say @a[*-1,*-2];

[00:00] <p6eval> rakudo 924242: OUTPUT¬´109‚ê§¬ª

[00:01] <Tene> rakudo: my @a = 1..10; say @a[map { *-$_ }, 1,2];

[00:01] <masak> rakudo: my @a = 1..10; say ~@a[*-1,*-2]

[00:01] <p6eval> rakudo 924242: OUTPUT¬´109‚ê§¬ª

[00:01] <p6eval> rakudo 924242: OUTPUT¬´10 9‚ê§¬ª

[00:02] <TimToady> masak: re sets and hashes, that's exactly why sets are defined as special hashes with virtual values

[00:02] <masak> well, HashSet is.

[00:03] <TimToady> and why sets and bags behave like lists in list context

[00:03] <TimToady> the API is consistent for the immutables too

[00:03] <masak> ok.

[00:03] <TimToady> in the spec, anyway...

[00:03] <masak> what does that mean in terms of sigils? can I declare a Set with a % sigil?

[00:04] <masak> it feels pretty natural to do .{} on a Set...

[00:04] <TimToady> my %set of Set; or my %set := set(...)

[00:04] <masak> oki, nice.

[00:04] <TimToady> well, my %set of KeySet, if mutalbe

[00:04] <TimToady> *bl

[00:04] <masak> *nod*

[00:05] <TimToady> er s/of/is/

[00:05] <masak> oh, good :)

[00:05] <TimToady> KeySets are basically just set containers, since sets are immutable

[00:06] <masak> std: set 1, 2, 3

[00:06] <p6eval> std 625303c: OUTPUT¬´ok 00:01 121m‚ê§¬ª

[00:06] <TimToady> so tweaking the membership generates a new set

[00:06] <masak> std: bag "lady"

[00:06] <p6eval> std 625303c: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[00:06] <masak> \o/

[00:07] <TimToady> rakudo: say set 1,2,3

[00:07] <p6eval> rakudo 924242: OUTPUT¬´123‚ê§¬ª

[00:07] <masak> rakudo: say set 1, "1"

[00:07] <p6eval> rakudo 924242: OUTPUT¬´1‚ê§¬ª

[00:07] <TimToady> oops :)

[00:07] <masak> heh.

[00:07] <masak> it stringifies everything, IIRC.

[00:08] <TimToady> yes, well, parrot doesn't really support OO keys yet, iiuc

[00:08] <TimToady> but they should use === semantics, not eq

[00:08] <masak> hm, it doesn't use a hash internally. it uses an array and uniq.

[00:09] <masak> wonder why it only retains one 1...

[00:09] <TimToady> good think it's encapsulated :)

[00:09] <masak> rakudo: say (uniq 1, "1").perl

[00:09] <p6eval> rakudo 924242: OUTPUT¬´(1)‚ê§¬ª

[00:09] <TimToady> because uniq uses a hash?

[00:09] <masak> ah.

[00:09] <masak> is that what we expect of uniq?

[00:09] * masak looks in the spec

[00:09] <TimToady> no, I expect === semantics

[00:11] * masak submits rakudobug

[00:11] <TimToady> Cat.new("mitsy") and Dog.new("mitsy") are obviously two different critters

[00:11] <masak> yap.

[00:19] <masak> 'night, #perl6

[00:19] <TimToady> yap

[00:19] *** masak left
[00:21] *** vmspb left
[00:46] <sorear> nice, t0m is a Perl6er

[00:55] *** stifynsemons left
[00:57] *** jaldhar left
[00:58] *** jaldhar joined
[01:00] *** stifynsemons joined
[01:04] *** guidjos joined
[01:08] *** guidjos left
[01:09] *** guidj0s_ joined
[01:11] *** guidj0s_ left
[01:12] <colomon> poop.  If I'd spent another couple of hours working on p4, I'd have gotten seen the pattern repeat and fully cracked the problem.

[01:19] <colomon> s/gotten seen/reached/

[01:21] *** justatheory left
[01:24] *** risou_ left
[01:40] *** flatwhatson_ left
[01:49] <colomon> Well, for definitions of "fully cracked" that don't include proving I was doing the right thing.

[01:57] *** coldhead left
[02:00] *** benabik_away is now known as benabik

[02:01] <diakopter> colomon: ping

[02:01] <colomon> pong

[02:01] <diakopter> :D

[02:02] <diakopter> impromptu non-trivia quiz:

[02:02] <diakopter> what is a Perl 6  "Container Type"

[02:03] <diakopter> (anyone else feel free to respond/answer, of course)

[02:03] <colomon> :)

[02:03] <colomon> I'm not sure there is a formal definition.

[02:03] <colomon> but, you know, Array or Hash.

[02:04] <colomon> I believe there was a thought of having a formal Container role at one point, but no one could work out what it actually did.

[02:05] *** noganex left
[02:05] <colomon> I could be completely wrong about the details, though.  :)

[02:06] * diakopter reads the paragraphs mentioning 'container' in S09 and S12

[02:06] *** noganex joined
[02:07] <benabik> S10 appears to be using Container as a type in the def of CANDO

[02:08] <sorear> the CANDO stuff is completely wrong

[02:08] <diakopter> yay! someone can erase it! :)

[02:08] <sorear> it hasn't made any sense since the last overhaul of the package system

[02:08] <benabik> The spec being wrong makes things hard to follow.  :-D

[02:10] *** coldhead joined
[02:10] <benabik> S32/Containers also defines a Container role, which appears to be an marker role.

[02:11] <benabik> But all the usages in S02 and S09 appear to refer to "Array, Hash or similar"

[02:13] <diakopter> it'd be cool if there was a link on each Text::SmartLinks page (the synopses on perlcabal.org) to each's revision history on github

[02:13] <TimToady> anything mutable is essentially a container

[02:14] <diakopter> ok

[02:15] <diakopter> is the http://perlcabal.org/syn/S32/Containers.html#Container up-to-date?

[02:16] <diakopter> also, is this fossilized as sorear says: http://perlcabal.org/syn/S10.html#Autoloading

[02:16] <TimToady> a bit distracted at the moment...

[02:16] * diakopter waits

[02:18] *** stifynsemons left
[02:18] * diakopter takes up the mantle of recording sorear's off-hours irc questions for TimToady in a file in the github repo

[02:19] <diakopter> and others'

[02:21] <colomon> diakopter: I would argue that the three functions assigned to Container are pretty useless as a role.

[02:24] <colomon> Errr... unless Hash is not supposed to be involved?  It looks like the interface is strictly defined in terms of @ variables, lists, and arrays....

[02:28] *** icwiener left
[02:31] *** kst left
[02:38] *** kst joined
[02:39] <sorear> Array and Hash containers have much more in common with each other than with Scalar

[02:39] <sorear> if Scalar even exists

[02:48] <colomon> but what can you do with a variable that is Array or Hash, other than treat one type as the other?

[02:49] <colomon> .elems, maybe.

[02:52] <sorear> colomon: .iterator and .LISTSTORE

[02:53] <colomon> LISTSTORE?

[02:53] <colomon> .iterator makes sense, agreed.

[02:54] <sorear> whatever you want to call the function that handles list assignment

[02:55] <colomon> you can do list assignment to a Hash?

[02:56] <colomon> (and I would have thought Container was supposed to read-only?)

[02:56] <sorear> sure

[02:56] <sorear> my %hash; %hash = a => 1, b => 2;

[02:57] <colomon> ah, assigning a list of Pairs, sure.

[02:57] <colomon> good point.

[02:58] <colomon> though that (liststore of Pairs) seems thin stuff for a Role, IMO.

[02:59] <colomon> hmmm... you can call .elems and .iterator on a scalar too, can't you?

[02:59] <colomon> rakudo: say 1.elems

[02:59] <p6eval> rakudo 924242: OUTPUT¬´1‚ê§¬ª

[03:00] <colomon> rakudo: say 1.iterators

[03:00] <p6eval> rakudo 924242: OUTPUT¬´Method 'iterators' not found for invocant of class 'Int'‚ê§  in main program body at line 22:/tmp/0A5wNvgfBA‚ê§¬ª

[03:00] <colomon> rakudo: say 1.iterator

[03:00] <p6eval> rakudo 924242: OUTPUT¬´Method 'iterator' not found for invocant of class 'Int'‚ê§  in main program body at line 22:/tmp/Rz95KVLGsL‚ê§¬ª

[03:00] <colomon> okay, maybe not that one.

[03:04] *** f00li5h left
[03:06] *** whiteknight left
[03:08] *** rgrau left
[03:10] *** justatheory joined
[03:39] *** jaldhar left
[03:40] *** jaldhar joined
[03:52] *** zy3g0 joined
[04:06] *** zy3g0 left
[04:06] *** jimbob joined
[04:12] *** stifynsemons joined
[04:15] <dalek> niecza: 64beb12 | sorear++ | / (3 files):

[04:15] <dalek> niecza: Simplify handling of labelled control exceptions

[04:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/64beb1257c

[04:15] <sorear> True or false: A when statement must be the immediate child of a topicalizer block.

[04:20] *** benabik is now known as benabik_away

[04:21] *** risou joined
[04:26] *** Su-Shee left
[04:28] *** Su-Shee joined
[04:49] *** wiseguyxp_ joined
[04:50] *** wiseguyxp_ left
[04:51] *** wiseguyxp joined
[05:04] *** felliott left
[05:07] <snarkyboojum> o/

[05:10] <sorear> hi!

[05:13] *** risou left
[05:16] <TimToady> sorear: false

[05:18] <TimToady> succeed and proceed are just control exceptions (that can typically be optimized into goto)

[05:19] <sorear> Why aren't succeed and proceed totally dynamic like next and last?

[05:19] <TimToady> next and last are totally dynamic in the absence of a label

[05:19] <TimToady> with a label they're lexotic

[05:20] <TimToady> I don't there's as much call for dynamic succeed, but certainly if you succeed in a scope without an outer topicalizer, dynamic is the only thing left to try

[05:20] <sorear> I mean like next and last withou labels

[05:21] <TimToady> it doesn't seem to me to be what the typical user would expect

[05:22] <TimToady> we could, I suppose, allow LABEL.succeed for pure lexotic, and the implicit succeed would then lexotic as well

[05:23] <TimToady> an explicit succeed without a label could conceivably be dynamic

[05:23] <TimToady> but certainly it's not specced that way currently

[05:24] <TimToady> I think consistency with the loop policy has something to be said for it, as long as the implicit ones stay lexotic (even if there's no label)

[05:25] <TimToady> I wouldn't expect anyone to ever use LABEL.succeed, but consistency doesn't seem inachievable here

[05:26] <TimToady> unachievable even

[05:26] <TimToady> I'm not sure what LABEL.proceed would mean though

[05:27] <TimToady> presumably the label would be on the when that is being left

[05:27] *** envi joined
[05:27] <TimToady> otherwise it's just a goto

[05:28] <snarkyboojum> phenny: tell masak, I particularly enjoyed the release "story" for yapsi this month :D

[05:28] <phenny> snarkyboojum: I'll pass that on when masak is around.

[05:28] <TimToady> or maybe it uses the label of the whole structure to figure out which when to exit

[05:28] <sorear> Is LABEL required to be able to identify the Block object?

[05:29] <TimToady> a thing can be lexotic without a label, but then it's difficult to express intentional lexoticity

[05:30] <TimToady> like return from a 'sub', which doesn't care about the subs name, only the keyword and the identity of the sub in question

[05:31] <TimToady> so I can also argue that succeed/proceed are always lexotic, and you can use $scope.leave to do anything else dynamically

[05:32] <TimToady> so it would be more like return, and less like last

[05:33] <TimToady> and, in fact, the proper way to implement succeed is more like return, so that it can return the value of the when block

[05:34] <sorear> LOOP: for 1 { say ?( LOOP ~~ Code ) } # ??

[05:34] <sorear> LOOP: for 1 { say ?( LOOP === &?BLOCK ) } # ??

[05:34] <TimToady> no

[05:34] <TimToady> it's just a label

[05:34] <TimToady> presumably you can ask it for the identity of the block in question though

[05:35] <sorear> Is that necessary?  I just noticed that the model of labels I've been working under doesn't allow it

[05:36] <TimToady> rakudo: LABEL: say LABEL.WHAT

[05:36] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "LABEL: say"‚ê§¬ª

[05:36] <sorear> rakudo doesn't do labels at all

[05:36] <TimToady> pugs: LABEL: say LABEL.WHAT

[05:36] <p6eval> pugs: OUTPUT¬´*** No such subroutine: "&LABEL"‚ê§    at /tmp/pUR53unwQV line 1, column 12 - line 2, column 1‚ê§¬ª

[05:36] <TimToady> pugs: LABEL: for 1 { say LABEL.WHAT }

[05:36] <p6eval> pugs: OUTPUT¬´*** No such subroutine: "&LABEL"‚ê§    at /tmp/MEgABLtd6j line 1, column 20-31‚ê§¬ª

[05:36] <TimToady> I guess pugs doesn't either

[05:36] <sorear> pugs: LABEL: goto LABEL;

[05:36] <p6eval> pugs: OUTPUT¬´*** No such subroutine: "&goto"‚ê§    at /tmp/P_XSWEdhfd line 1, column 8-18‚ê§¬ª

[05:37] <sorear> pugs: LABEL: while True { last LABEL; }

[05:37] <p6eval> pugs: OUTPUT¬´*** No such subroutine: "&LABEL"‚ê§    at /tmp/3Fvi56XQpp line 1, column 21-31‚ê§¬ª

[05:37] <TimToady> how can you write a lexotic exception if you can't identify the correct frame to unwind to?

[05:38] <sorear> The frame to unwind to is the OUTER:: of the block

[05:38] <TimToady> no

[05:39] <TimToady> that's like saying you can't return from inside an if

[05:39] <TimToady> that's why we invented lexoticness, so we can identify frames lexically

[05:40] <TimToady> and use that to capture the throw at the right palce

[05:40] <TimToady> *place

[05:40] <sorear> No, that's not quite what I meant

[05:41] <sorear> LOOP: loop { loop { last LOOP } } -> my $LOOP = Label.new(callframe, "LOOP"); "LOOP": loop { loop { last $LOOP } }

[05:41] <sorear> the label doesn't hold a reference to the loop body

[05:42] <sorear> if it did, it would prevent loop inlining in a lot of interesting cases

[05:43] <TimToady> labels aren't strings; they're constants

[05:43] <sorear> my $LOOP = Label.new(callframe, 0); 0: loop { loop { last $LOOP } } # if you prefer

[05:44] <sorear> I had planned to use names for debugging, but my model works with any unique identifier

[05:44] <sorear> *debuggability

[05:45] <TimToady> I don't see how knowing the outer callframe helps you know where to start up again with 'next'

[05:46] <TimToady> the code performing the loop needs to know if the block passed in is the one referred to in the control exception it just caught

[05:46] <TimToady> so it's more the block needs to know its label

[05:47] <sorear> the code performing the loop knows the label name

[05:47] <sorear> the exception is correct to catch if the frame matches the current frame, and the name matches

[05:48] <TimToady> it will get the wrong one dynamically if it's scanning for names, and an inner loop has the same label; that's no good

[05:48] <sorear> it's not just scanning for names, it's also scanning for frames

[05:48] <TimToady> it has to be a unique identity for the block, that the exception has got from the label used

[05:49] <sorear> name,outerframe pairs are a unique identity for blocks

[05:49] <sorear> since the outer block only clones its children once

[05:49] <sorear> and names are unique within the outer block

[05:50] <TimToady> well, maybe name/outerframe the value of the label constant

[05:50] <TimToady> but it ain't just a string

[05:50] <sorear> aye

[05:51] <TimToady> when you say LABEL.foo, it's got the lexotic identity, and when you say "LABEL".foo, you have to do it dynamically

[05:52] <TimToady> (unless we let some things look up caller labels...)

[05:52] <TimToady> in which case the latter could behave lexotically, with the cooperation of .foo

[05:54] <TimToady> anyway, I suspect for optimizability it would be better if succeed defaults to lexotic

[05:54] <TimToady> then it has some change of turning into a low-level goto

[05:54] <TimToady> *chance

[05:55] <TimToady> which also makes me wonder if we've defaulted next and last the wrong way

[05:55] <TimToady> and we should have something explicit to indicate a dynamic throw

[05:56] <TimToady> "next if" is very heavily used in typical perl code

[05:56] <sorear> actually I find dynamic to be easier to optimize

[05:56] <TimToady> that seems counterintuitive to me

[05:57] * PerlJam puts a next inside a nested sub 5 levels deep just for sorear

[05:57] <sorear> there are 2 interesting cases

[05:58] <sorear> case 1: next/etc is inside a pile of lexical scopes, with no extra dynamic scopes

[05:58] <sorear> case 2: there are extra dynamic scopes

[05:58] <sorear> in case 1, dynamic and lexotic can both be turned into a goto

[05:58] <TimToady> I suppose the dynamic scope can make it easier to 'next' things like, say map

[05:58] <sorear> in case 2, neither can because the dynamic scopes might have CONTROL blocks

[05:59] <sorear> but dynamic is easier because it doesn't require creating label objects

[05:59] *** arlinius left
[05:59] <sorear> I agree it's counterintuitive

[05:59] <sorear> it makes me think I'm attacking the problem entirely wrong

[06:00] <TimToady> I think people will tend to write their own loops more than their own switches, but I suppose the argument can carry over there too

[06:00] <sorear> the main argument for lexicality of switchy stuff is that $_ is lexical

[06:01] <TimToady> well, but for loops also set $_

[06:01] *** arlinius joined
[06:03] <TimToady> it's not entirely clear whether we want to say that CONTROL blocks see exceptions that are lexotically aimed elsewhere; if we blinded them to that, then you case 2 becomes easier to optimize for lexotic scopes, since you can ignore dynamic CONTROL blocks

[06:03] <TimToady> *your

[06:04] <TimToady> and really, anything you want to do on stack unwind should really be in something more like a LEAVE block

[06:05] <TimToady> so I'm not too scared to say that CONTROL blocks can be auto-skipped, unless there's a good use case for not doing so

[06:05] <TimToady> in that sense, it's really the identity of the CONTROL block that is at issue here

[06:06] *** dukeleto left
[06:06] <TimToady> well, maybe that's oversimplified

[06:06] *** dukeleto joined
[06:06] <sorear> even a LEAVE block has issues

[06:06] <sorear> it requires a stack unwind

[06:07] <TimToady> well, yes, that's the point of 'em

[06:07] <sorear> unwinding to a specific frame doesn't ring to me as much cheaper than unwinding to a frame with the "handles next" bit

[06:07] <TimToady> the unwind should not be confused with the throw

[06:08] <TimToady> the unwind happens after the throw finds the right handler

[06:11] <PerlJam> I sure wish I understood what you guys were talkling about.  :-)

[06:11] <TimToady> for example, if a 'return' doesn't find its sub, it throws a new exception from the point of the return

[06:11] <TimToady> with the original frames still there

[06:11] <sorear> PerlJam: last LABEL;

[06:12] <PerlJam> Because "auto-skipping CONTROL blocks" makes me wonder how you exit out of nested blocks each with their own LAST semantics.

[06:12] *** Su-Shee left
[06:12] <TimToady> LASTs are processed more like LEAVE, it would seem

[06:13] <TimToady> that is, on stack unwind, not on the control exception

[06:14] <TimToady> might imply that a stack unwind should be told the reason for unwinding

[06:15] <dalek> niecza: 7742322 | sorear++ | src/ (3 files):

[06:15] <dalek> niecza: Trap succeed in blocks that signature-bind $_

[06:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7742322928

[06:15] <TimToady> but again, a 'last' that doesn't find its loop frame as a control exception throws a real exception from the same deep frame instead (which is likely to unwind)

[06:16] <sorear> TimToady: Have you seen t0m's TR18 post?

[06:16] <TimToady> exception of either kind never unwind; they only schedule an unwind after they've decide who handles the exception

[06:16] <PerlJam> TimToady: and that "find" is lexical?

[06:16] <TimToady> no, dynamic, which includes lexotic if there's a lexical identity to scan for

[06:16] <TimToady> but the scan is of necessity dynamic

[06:17] <TimToady> sorear: yes, I glanced at it, but haven't had a chance to reply

[06:17] <TimToady> it's probably worth someone taking a pass over to see how much the Perl vision and the Unicode vision have diverged over the last year or three

[06:18] <TimToady> in any case, most of what we've come up with we've done because it's the right thing to do, not because of a consortium report

[06:18] <sorear> TimToady: What do you mean by last throwing a real exception?

[06:18] <TimToady> a fatal exception to be caught by CATCH, not a control exception

[06:18] <PerlJam> sorear: I parsed that as "non-CONTROL exception"

[06:19] <sorear> "No handler for control exception last in dynamic scope" or so?

[06:19] <TimToady> control expections are conceptually similar, but we want a very lightweight implementation

[06:19] <TimToady> since they aren't, in fact, exceptional

[06:20] <PerlJam> maybe they should be "control expectations" rather than "control exceptions"

[06:20] <TimToady> sorear: well, I'd put it into User-ese rather than Language-lawyer-ese, but yes

[06:20] <TimToady> You used a 'last' that wasn't in the dynamic scope of a loop; shame on you!

[06:21] <TimToady> I don't expect the casual use to know that 'last' throws a control exception

[06:21] <TimToady> this is one of those spots where it's important for budding programmers to do cargo-cult programming

[06:21] <TimToady> they can learn the exact semantics and technical terms later

[06:24] <PerlJam> I've always gotten the impression that the dynamic nature of next/last/redo was surprising to most Perl 5 programmers.  I bet that will continue to be the case with Perl 6.

[06:26] <TimToady> same deal with my "Useless use of [] around infix op" in my version of that patch; I don't think the newish user will understand "metaoperator brackets"

[06:27] <TimToady> (it's not clear they are intrinsically tied to metaoperators in any case)

[06:27] <TimToady> (for instance, there's no metaoperator in the &[+] form, but I think of those as the same brackets)

[06:28] <TimToady> std: 1 [+] 42

[06:28] <p6eval> std 625303c: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[06:28] <TimToady> I guess it hasn't recompiled lately

[06:29] <sorear> niecza: 1 [+] 42

[06:29] <p6eval> niecza v2-10-g7742322: OUTPUT¬´Potential difficulties:‚ê§  Useless use of [] around infix op at /tmp/ItTwkZ8sAH line 1:‚ê§------> [32m1 [33m‚èè[31m[+] 42[0m‚ê§‚ê§¬ª

[06:29] <TimToady> :)

[06:30] <TimToady> or I guess it's using the CPAN viv?

[06:30] *** risou joined
[06:31] <sorear> the last build attempt was successful (and last year)

[06:32] <TimToady> niecza: s{foo}{bar}

[06:32] <p6eval> niecza v2-10-g7742322: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/zvTneNmG79 line 1:‚ê§------> [32ms{foo}[33m‚èè[31m{bar}[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[06:33] <TimToady> aha, you didn't get that one yet :)

[06:34] <sorear> std is suspiciously absent from /chroot/var/spool/cron/crontabs/p6eval

[06:34] *** arlinius left
[06:34] <sorear> phenny: tell moritz_ std isn't in /chroot/var/spool/cron/crontabs/p6eval and the last std: update was Dec 16.  Bug?

[06:34] <phenny> sorear: I'll pass that on when moritz_ is around.

[06:37] <sorear> std: given 12 -> $x { } # Is this a topicalizer?

[06:37] <p6eval> std 625303c: OUTPUT¬´Potential difficulties:‚ê§  $x is declared but not used at /tmp/FeqhRld8XY line 1:‚ê§------> [32mgiven 12 -> [33m‚èè[31m$x { } # Is this a topicalizer?[0m‚ê§ok 00:01 121m‚ê§¬ª

[06:37] <TimToady> not in the sense of setting $_

[06:38] <TimToady> used to be that way, till we deemed double binding insane

[06:40] <TimToady> it got particularly messy if there were multiple parameters; is $_ only an alias for the first one?

[06:41] <TimToady> took a long time to detangle invocants from topics too

[06:42] <sorear> there's still mention of invocants in S04

[06:42] *** _ilbot joined
[06:42] <sorear> I take it that's a fossil?  it seemed odd.

[06:43] <TimToady> those look accurate to me, on first blush.  .foo takes $_ outside, but inside it's the invocant

[06:44] <TimToady> or was it a different place you're wondering about?

[06:44] <sorear> S04:869

[06:44] <TimToady> inside, the topic and invocant are the same only if $_ is one of the formal parameters

[06:45] <TimToady> that seems consistent with what I just said

[06:45] <dalek> niecza: 03bd80d | sorear++ | / (2 files):

[06:45] <dalek> niecza: Implement "given"

[06:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/03bd80d90e

[06:45] <TimToady> method ($_: $a,$b,$c) {...}

[06:46] <sorear> S04:869 seems to imply that method foo($x: $_) { } doesn't set the topic

[06:46] <TimToady> $_ is both invocant and topic there

[06:46] <TimToady> it should probably s/invocant/any of its parameters, including the invocant,/

[06:47] *** molaf joined
[06:47] <TimToady> in some sense $_ = 'foo' is a topicalizer too, but not as far as 'succeed' knows

[06:48] <TimToady> it can really only know about sig bindings attached to a scope

[06:48] <sorear> I get the feeling that Perl 6 once thought of "topic" as the master concept

[06:49] <TimToady> succeed is really based on the topic container's identity, not the topic's contents...

[06:49] <sorear> whereas now $_ is master and "topic" just means "whatever is in the lexically visible $_"

[06:50] <TimToady> $_ as an lvalue is the master now, and the actual topic is kind of epiphenomenal

[06:50] <TimToady> so yeah

[06:52] <TimToady> the actual meaning of "it" is pretty sloppy in natural languages, even if you have official topicalization syntaxes

[06:55] <sorear> (have I mentioned yet that I'm currently studying Japanese?)

[06:57] <TimToady> „ÅØ„ÅÑ„ÄÅ„Åù„ÅÜÂàÜ„Åã„Çä„Åæ„Åó„Åü„Çà„ÄÇ

[06:58] *** arlinius joined
[07:02] * sorear does not know what sou is doing there

[07:02] <sorear> also, I seem to have lost my ability to type macrons since I restarted X earlier today

[07:03] <TimToady> sou works much the same as in English, oddly

[07:03] <dalek> niecza: b0e8b22 | sorear++ | / (2 files):

[07:03] <dalek> niecza: Implement postfix when and for

[07:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b0e8b2231f

[07:03] <TimToady> "so I have understood"

[07:06] <TimToady> sou often ends up as kinda meaning "that" when applied to an actoin

[07:06] <TimToady> *action

[07:06] <TimToady> „Åù„ÅÜ„Åó„Åæ„Åô for instance

[07:07] <TimToady> be we also have "do so" in English

[07:07] <TimToady> *but

[07:10] <diakopter> oddly and evenly

[07:11] *** meteorjay left
[07:14] <TimToady> std: „Å´„Åª„Çì„Åî: goto „Å´„Åª„Çì„Åî;

[07:14] <p6eval> std 625303c: OUTPUT¬´ok 00:01 118m‚ê§¬ª

[07:18] *** kaare_ joined
[07:18] <diakopter> perlesque: „Å´„Åª„Çì„Åî: goto „Å´„Åª„Çì„Åî;

[07:18] <p6eval> perlesque: OUTPUT¬´(timeout)¬ª

[07:18] <diakopter> FTW

[07:20] <sorear> TimToady: When you talk about "doing all your C coding in Perl 6", what do you have in mind?  Linux loadable kernel modules? :)

[07:23] * diakopter would love more context there too

[07:25] <TimToady> well, if we could write the filesystem in Perl 6, that might make it easier to support Unicode filenames.  :)

[07:25] <TimToady> interestingly, Clearcase's translucent filesystem was written in Perl 5

[07:26] <dalek> niecza: 4ebb175 | sorear++ | / (2 files):

[07:26] <dalek> niecza: Implement block "when"

[07:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4ebb175c9c

[07:26] <TimToady> it actually ran ten times faster than their C version of the code--go figure

[07:26] <sorear> ok, niecza has given/when now

[07:26] <sorear> that wasn't nearly so hard as I expected

[07:27] <TimToady> and having failed to compile a Linux driver module earlier today, I'd certainly prefer to write one in Perl 6...

[07:27] <sorear> and this'll allow a few hundred more lines of STD diff noise to be removed

[07:28] * sorear -> sleep

[07:28] <TimToady> „Åä„ÇÑ„Åô„Åø„Å™„Åï„ÅÑÔºÅ

[07:36] *** Chillance joined
[07:39] *** wiseguyxp left
[07:51] <szabgab> good morning

[07:51] <szabgab> we are in the Perl dev room at FOSDEM on screen, just before the Perl 6 taslk

[07:53] <szabgab> rakudo: say "good morning"

[07:53] <p6eval> rakudo 924242: OUTPUT¬´good morning‚ê§¬ª

[07:54] *** justatheory left
[07:54] *** justatheory joined
[07:56] *** Mowah joined
[07:57] <diakopter> hello screen

[07:59] *** franckc joined
[07:59] *** tommie joined
[07:59] <franckc> hi fosdem!

[07:59] *** justatheory left
[07:59] <tommie> :-D

[07:59] <szabgab> rakudo: say "good morning, frank"

[07:59] <p6eval> rakudo 924242: OUTPUT¬´good morning, frank‚ê§¬ª

[08:00] *** awoodland joined
[08:00] *** AlviN900 joined
[08:01] *** jeeger joined
[08:01] *** jonnie joined
[08:01] *** sawyer_ joined
[08:01] <jeeger> rakudo: say [*] 1..10

[08:01] <p6eval> rakudo 924242: OUTPUT¬´3628800‚ê§¬ª

[08:02] <TimToady> rakudo: say (1, 1, * + * ... *)[^20].Str

[08:03] <p6eval> rakudo 924242: OUTPUT¬´1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765‚ê§¬ª

[08:03] <jeeger> rakudo: say 1..30¬ª.PERL

[08:03] <p6eval> rakudo 924242: OUTPUT¬´Method 'PERL' not found for invocant of class 'Int'‚ê§  in main program body at line 22:/tmp/_iaorJwfyL‚ê§¬ª

[08:03] <jeeger> rakudo: say 1..30¬ª.perl

[08:03] <p6eval> rakudo 924242: OUTPUT¬´1‚ê§¬ª

[08:03] <TimToady> precedence

[08:03] <jeeger> rakudo: say 1..30¬ªperl

[08:04] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say 1..30\x{bb}"‚ê§¬ª

[08:04] <jeeger> hm

[08:04] <diakopter> rakudo: say (0, 1, * + * ... *)[^20].Str

[08:04] <p6eval> rakudo 924242: OUTPUT¬´0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181‚ê§¬ª

[08:04] <jeeger> say (1..30)¬ª.perl

[08:04] <TimToady> rakudo: say (1..30)¬ª.perl.Str

[08:04] <p6eval> rakudo 924242: OUTPUT¬´1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30‚ê§¬ª

[08:04] <jeeger> ah

[08:07] *** AlviN900 left
[08:11] <TimToady> zzz &

[08:12] *** risou left
[08:13] *** Raven joined
[08:14] <jeeger> rakudo: say 1 <= 35

[08:14] <p6eval> rakudo 924242: OUTPUT¬´Bool::True‚ê§¬ª

[08:15] <Raven> raduko:  for(1,2,3,4,5) -> $x, $y? { say "$x, $y"; }

[08:17] *** ecocode joined
[08:21] <jeeger> rakudo: my @series = 1..Inf; say @series[-1];

[08:21] <p6eval> rakudo 924242:  ( no output )

[08:22] <Raven> raduko:for(1,2,3,4,5) -> $x, $y? { say "$x, $y"; }

[08:23] <jeeger> Raven: rakudo, not raduko

[08:24] <Raven> rakudo:for(1,2,3,4,5) -> $x, $y? { say "$x, $y"; }

[08:24] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "for(1,2,3,"‚ê§¬ª

[08:24] <Raven> ha, that explains why query did work

[08:24] <jeeger> rakudo: say (1,2,3,4,5) -> $x, $y { say "$x, $y"; }

[08:24] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say (1,2,3"‚ê§¬ª

[08:25] <jeeger> rakudo: for (1,2,3,4,5) -> $x, $y { say "$x, $y"; }

[08:25] <p6eval> rakudo 924242: OUTPUT¬´1, 2‚ê§3, 4‚ê§Not enough positional parameters passed; got 1 but expected 2‚ê§  in <anon> at line 2:/tmp/2BoZpuOn_n‚ê§  in main program body at line 1‚ê§¬ª

[08:25] <jeeger> rakudo: for(1,2,3,4,5) -> $x, $y { say "$x, $y"; }

[08:25] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "for(1,2,3,"‚ê§¬ª

[08:25] <jeeger> hm, that looks like a bug

[08:25] <Raven> yay for early morning bugfixes!

[08:33] *** RichiH_FOSDEM joined
[08:33] <ecocode> approx 50 persons in Perl Devroom @ Fosdem.

[08:34] <RichiH_FOSDEM> shouldn't the topic say "p6eval usage"?

[08:39] *** tommie left
[08:41] <Raven> I love his @experssions

[08:47] *** jeeger left
[08:47] *** awoodland left
[08:47] <RichiH_FOSDEM> experss yourself

[08:49] <RichiH_FOSDEM> and at the end of the talk, he started telling us about ncurses ;)

[08:52] *** flatwhatson_ joined
[08:52] *** sunnavy joined
[08:53] *** awoodland joined
[08:58] <jdhore> quick question (since i'm in here) can you not put curly braces around an if statement if it only contains one line?

[09:00] *** jimbob left
[09:02] *** stifynsemons left
[09:13] *** envi left
[09:13] *** sawyer_ left
[09:13] *** envi joined
[09:20] *** awoodland left
[09:25] <tadzik> jdhore: nope

[09:25] <tadzik> you can use the FOO if BAR though

[09:25] <tadzik> rakudo: say "foo" if 5 < 7

[09:25] <p6eval> rakudo 924242: OUTPUT¬´foo‚ê§¬ª

[09:27] <jdhore> ah

[09:27] <jdhore> thanks

[09:48] *** ecocode left
[09:49] *** ecocode joined
[09:50] *** pmurias joined
[09:51] *** ecocode left
[10:00] *** cafesofie left
[10:16] *** sunnavy left
[10:17] *** sunnavy joined
[10:48] *** zenog joined
[10:49] <zenog> Stupid newbie question that unfortunately has not been answered by Google: What is wrong with the line "my %hash = map { $_ => $_ } @array;"?

[10:53] <tadzik> my @a = 1, 2, 3; my %hash = map { $_ => $_ } @a; %hash.perl.say

[10:53] <tadzik> rakudo: my @a = 1, 2, 3; my %hash = map { $_ => $_ } @a; %hash.perl.say

[10:53] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "my %hash ="‚ê§¬ª

[10:53] <tadzik> rakudo: my @a = 1, 2, 3; my %hash = map { $_ => $_ }, @a; %hash.perl.say

[10:53] <p6eval> rakudo 924242: OUTPUT¬´Can't call map() with a Hash argument, Callable required‚ê§You probably wrote a Hash composer accidentally - try to‚ê§disambiguate it with a ; directly after the opening brace‚ê§  in 'Any::map' at line 1511:CORE.setting‚ê§  in 'map' at line 1863:CORE.setting‚ê§  in main program body at

[10:53] <p6eval> ..line ‚Ä¶

[10:53] *** agentzh joined
[10:53] <tadzik> sigh

[10:53] <tadzik> rakudo: my @a = 1, 2, 3; my %hash = @a.map({ $_ => $_ }); %hash.perl.say

[10:54] <p6eval> rakudo 924242: OUTPUT¬´Can't call map() with a Hash argument, Callable required‚ê§You probably wrote a Hash composer accidentally - try to‚ê§disambiguate it with a ; directly after the opening brace‚ê§  in 'Any::map' at line 1511:CORE.setting‚ê§  in main program body at line 22:/tmp/aKiFU9Mkty‚ê§¬ª

[10:55] *** f00li5h joined
[10:55] <tadzik> I don't think hash is a list of pairs actually

[10:56] <moritz_> map: {; $_ => $_ }

[10:56] <phenny> moritz_: 06:34Z <sorear> tell moritz_ std isn't in /chroot/var/spool/cron/crontabs/p6eval and the last std: update was Dec 16.  Bug?

[10:56] <moritz_> sorear: yes, bug

[10:56] <tadzik> moritz_: and that's a bug, above?

[10:57] <zenog> tadzik: it has nothing to do with the %hash, "map { $_ => $_ } @array;" also fails.

[10:57] <moritz_> tadzik: specbug

[10:57] <tadzik> I see

[10:58] <tadzik> zenog: see the moritz_'s example

[10:58] *** masak joined
[10:58] <masak> g'day, zebras.

[10:58] <phenny> masak: 05:28Z <snarkyboojum> tell masak I particularly enjoyed the release "story" for yapsi this month :D

[10:58] <masak> :)

[10:59] <masak> it's a true story, by the way. my life is full of incidents where I lose my way.

[11:00] <coldhead> is the Perl 6 And Parrot Essentials book still relevant/recommended (if that's not a rude question)?

[11:00] <masak> not a rude question. :)

[11:00] <moritz_> coldhead: it's very out of date

[11:01] <zenog> tadzik: If it is a bug I'll just try a not-so-elegant workaround for now. Thanks.

[11:01] <masak> coldhead: I suppose something can be learned from it, but mostly it'll be something having to do with ancient history.

[11:01] <moritz_> it still gets some of the Perl 6 essentials across, but lots of details have changed

[11:01] <coldhead> that was my fear, it seemed foolhardy to try to document it back then

[11:01] <masak> coldhead: especially in retrospect...

[11:02] <moritz_> a nice way to write  %h = map { $_ => $_ }, @a  is   %h = @a Z=> @a

[11:03] <coldhead> i might try it anyway. maybe it could be redeemed by an errata sheet

[11:07] <masak> ...a long errata sheet...

[11:08] <moritz_> coldhead: I hope somebody already pointed you to "Using Perl 6"?

[11:09] *** jaffa4 joined
[11:09] <coldhead> they did but i liked the perl 6 + parrot option

[11:09] <jaffa4> rakudo: $_ = 'foo'; s:g/ /a/; say 'alive'

[11:09] <p6eval> rakudo 924242: OUTPUT¬´alive‚ê§¬ª

[11:10] <jaffa4> std: $_ = 'foo'; s:g/ /a/; say 'alive'

[11:10] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null pattern not allowed at /tmp/XkMjKRPuJf line 1:‚ê§------> [32m$_ = 'foo'; s:g/ [33m‚èè[31m/a/; say 'alive'[0m‚ê§    expecting quantifier‚ê§Parse failed‚ê§FAILED 00:01 122m‚ê§¬ª

[11:10] <jaffa4> Where is null pattern over there? I cannot see it.

[11:11] <jaffa4> std: $_ = 'foo'; m:g/ /a/; say 'alive'

[11:11] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null pattern not allowed at /tmp/TdwOVFDp1V line 1:‚ê§------> [32m$_ = 'foo'; m:g/ [33m‚èè[31m/a/; say 'alive'[0m‚ê§    expecting quantifier‚ê§Parse failed‚ê§FAILED 00:01 122m‚ê§¬ª

[11:11] <masak> jedai: s:g/‚èè/a/

[11:11] <masak> argh, mistab again :/

[11:11] <masak> jaffa4: the null pattern is where the ‚èè is.

[11:11] <jaffa4> there is space there.

[11:12] <masak> jaffa4: whitespace is irrelevant in p6 regexes.

[11:12] <jaffa4> ok

[11:14] *** dju left
[11:14] <jaffa4> Can I modify rakudo?

[11:15] <masak> please be more specific.

[11:15] <jaffa4> Do I have the permissions to do so?

[11:15] <jaffa4> Do I have the permissions of rakudo github to do so?

[11:18] *** dakkar joined
[11:18] <moritz_> jaffa4: nope. But you can fork and submit pull requests, or submit patches via RT

[11:18] <moritz_> good morning btw

[11:18] <masak> mornin', moritz_ 

[11:18] <moritz_> we had a great (late) burns supper yesterday night

[11:19] <moritz_> and there's a portion of Stickey Toffee Pudding in the fridge :-)

[11:20] <coldhead> wee muckle kilty tehk the glen!

[11:25] <jaffa4> How do you debug rakudo?

[11:26] <jaffa4> Do you use some tools?

[11:29] <tadzik> jaffa4: what do you mean "debug rakudo"?

[11:29] <jaffa4> perl -d?

[11:30] <jaffa4> I mean are there some debugging switches or settings?

[11:30] <moritz_> there's the --target switch which lets you see intermediate code

[11:30] <moritz_> and --ll-backtrace

[11:30] <moritz_> see docs/running.pod

[11:30] <tadzik> use Devel::Trace also

[11:32] *** zenog left
[11:39] *** coldhead left
[11:53] <colomon> jaffa4: lots and lots of "say" statements.

[11:53] <jaffa4> I mean the rakudo compiler

[11:54] <colomon> jaffa4: so did I.

[11:54] <colomon> tadzik:

[11:55] <colomon> rakudo: my @a = 1, 2, 3; my %hash = @a Z=> @a; %hash.perl.say # just in case you actually were looking for how to do that.  :)

[11:55] <p6eval> rakudo 924242: OUTPUT¬´{"1" => 1, "2" => 2, "3" => 3}‚ê§¬ª

[11:57] <masak> jaffa4: when developing things for src/core, it's often best to do it in a standalone file first, and only later integrate it. keeps the development cycle short.

[11:57] <jaffa4> What standalone file?

[12:00] <moritz_> a .pl file

[12:00] <masak> a script file that you write, instead of starting by integrating things into src/core

[12:00] <moritz_> colomon: re Z=>, I proposed that two hours ago too :-)

[12:00] <jaffa4> How could I extract a part from the whole without breaking the whole?

[12:01] <colomon> moritz_: sorry, sketchy half-awake backlogging.  ;)

[12:01] <moritz_> jaffa4: http://en.wikipedia.org/wiki/Jenga

[12:02] <masak> jaffa4: the parts of src/core are relatively independent. in the cases where they aren't, it can get tricky. but often it's solvable even then.

[12:07] *** franckc left
[12:12] *** MayDaniel joined
[12:13] <moritz_> to be more precises, things in src/core are not needed while compiling rakudo, other parts of rakudo only depend on them at run time

[12:13] <moritz_> so if you supply the missing parts at run time, it's all good

[12:13] <tadzik> sounds like the day to merge metainfo

[12:20] *** Chillance left
[12:28] <tadzik> bah. While JSON parses for 40 seconds, storing the .perl string and evaling it later takes 17 seconds

[12:29] <tadzik> not much better, but still, 23 seconds less for installing a module

[12:29] <tadzik> maybe sqlite is the way then... bleh

[12:30] <masak> tadzik: 17 seconds -- that sounds... unreasonable.

[12:34] <colomon> very unreasonable

[12:34] <colomon> can you paste the .perl string to a gist?

[12:37] <tadzik> si

[12:38] <tadzik> https://gist.github.com/raw/813345/c328fe141888de6b758a2c40ba84c1758aefd6c8/projects.perl

[12:39] <tadzik> maybe the cpanm way is the way: fetching the metainfo every single time from a web service. But it's nothing but a workaround for the Rakudo slowness

[12:40] *** yarp joined
[12:41] *** whiteknight joined
[12:43] <tadzik> I wonder how niecza... ah, no eval

[12:45] *** dakkar left
[12:51] *** dakkar joined
[12:57] *** agentzh left
[13:15] *** kfo_ joined
[13:18] *** kfo left
[13:18] *** jeeger joined
[13:19] <jeeger> Greetings! I'm still looking on how to do something like "@a Z @b Z @c", but with extending the lists. 

[13:20] <masak> jeeger: extending the lists with what?

[13:21] <jeeger> masak: repeating them, for example, like @a <<,>> @b would

[13:21] <masak> I seem to recall the spec has something to say about this. hold on.

[13:23] *** felliott joined
[13:23] <masak> ah, S32/Containters:101: "The C<zip> function defaults to stopping as soon as any of its lists is exhausted.  This behavior may be modified by conceptually extending any short list using C<*>, which replicates the final element."

[13:26] <masak> rakudo: sub repeat(@list) { gather loop { take $_ for @list } }; my @alpha = 'a' .. 'z'; my @digits = 0..9; say @alpha Z repeat(@digits)

[13:26] <p6eval> rakudo 924242: OUTPUT¬´a0b1c2d3e4f5g6h7i8j9k0l1m2n3o4p5q6r7s8t9u0v1w2x3y4z5‚ê§¬ª

[13:26] <masak> \o/

[13:27] <jeeger> rakudo: @numbers,* Z @letters

[13:27] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Symbol '@numbers' not predeclared in <anonymous> (/tmp/4cjm9bIaPO:22)‚ê§¬ª

[13:27] <jeeger> rakudo: say (1,2,3,4,*) Z ("one","two","three","four","five")

[13:27] <p6eval> rakudo 924242: OUTPUT¬´1one2two3three4four4five‚ê§¬ª

[13:27] <jeeger> aha!

[13:28] <jeeger> rakudo: say (1,2,3,4,Any()) Z ("one","two","three","four","five") Z 

[13:28] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say (1,2,3"‚ê§¬ª

[13:29] <jeeger> rakudo: say (1,2,3,4,undef) Z ("one","two","three","four","five") Z 

[13:29] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Unsupported use of undef as a value; in Perl 6 please use something more specific:‚ê§  Mu (the "most undefined" type object),‚ê§ an undefined type object such as Int,‚ê§  Nil as an empty list,‚ê§  *.notdef as a matcher or method,‚ê§       Any:U as a type constraint‚ê§     or

[13:29] <p6eval> ..fail() as a failur‚Ä¶

[13:29] <arnsholt> You've got a trailing Z

[13:29] <masak> Perl 6 doesn't have an undef.

[13:29] <jeeger> rakudo: say (1,2,3,4,undef) Z ("one","two","three","four","five")

[13:29] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Unsupported use of undef as a value; in Perl 6 please use something more specific:‚ê§  Mu (the "most undefined" type object),‚ê§ an undefined type object such as Int,‚ê§  Nil as an empty list,‚ê§  *.notdef as a matcher or method,‚ê§       Any:U as a type constraint‚ê§     or

[13:29] <p6eval> ..fail() as a failur‚Ä¶

[13:29] <jeeger> Yeah, that was a quite exhaustive error message

[13:29] <jeeger> (for once^^)

[13:29] <masak> :)

[13:30] <jeeger> rakudo: say (1,2,3,4,Mu()) Z ("one","two","three","four","five")

[13:30] <p6eval> rakudo 924242: OUTPUT¬´Could not find sub &Mu‚ê§  in main program body at line 22:/tmp/hFSgS8xjcY‚ê§¬ª

[13:30] <jeeger> Okay, I'll take this to a query

[13:31] <masak> it's Mu, not Mu()

[13:31] <jeeger> That's what I'm trying now^^

[13:44] *** REPLeffect left
[13:50] *** jeeger left
[13:50] *** jeeger joined
[13:50] *** Axius joined
[13:59] *** yarp left
[13:59] *** jeeger left
[13:59] *** REPLeffect joined
[14:13] <masak> std: sink

[14:13] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Bogus statement at /tmp/prQVAhS8Ix line 1 (EOF):‚ê§------> [32msink[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:01 119m‚ê§¬ª

[14:13] *** orafu left
[14:13] <masak> std: sink say "OH HAI"

[14:13] <p6eval> std 625303c: OUTPUT¬´ok 00:01 120m‚ê§¬ª

[14:13] <masak> rakudo: sink say "OH HAI"

[14:13] <p6eval> rakudo 924242: OUTPUT¬´OH HAI‚ê§¬ª

[14:13] <masak> \o/

[14:15] *** cotto left
[14:16] *** Axius left
[14:23] <masak> TimToady: $obj.?foo returns Nil if there's no .foo method in the WALK chain. what about $obj.*foo? S12 doesn't seem to say.

[14:24] * masak checks roast

[14:26] <xinming_> do -> $x { $x.say }         <--- How do we provide the arg for $x in this case?

[14:26] *** drbean left
[14:27] <xinming_> do (-> $x { $x.say })(1)     Got it.

[14:27] <masak> rakudo: -> $x { $x.say }(1)

[14:27] <p6eval> rakudo 924242: OUTPUT¬´1‚ê§¬ª

[14:27] <masak> no need for 'do' or parens.

[14:28] <xinming_> I was thinking that how to pass arg to do block.

[14:28] <xinming_> Since we can have positional arg

[14:28] <xinming_> there

[14:29] <xinming_> do { say $^x };    This

[14:30] *** Hackbinary joined
[14:30] <masak> there's not really any such thing as a "do block".

[14:30] <masak> there's the "do" keyword, and then there's blocks.

[14:31] <masak> rakudo: do say 42

[14:31] <p6eval> rakudo 924242: OUTPUT¬´42‚ê§¬ª

[14:31] <masak> rakudo: do do do do say "doo-diddly-do"

[14:31] <p6eval> rakudo 924242: OUTPUT¬´doo-diddly-do‚ê§¬ª

[14:32] <masak> rakudo: do do do do my $ = { say "not executed" }

[14:32] <p6eval> rakudo 924242:  ( no output )

[14:32] <masak> rakudo: do do { say "immediate block" }

[14:32] <p6eval> rakudo 924242: OUTPUT¬´immediate block‚ê§¬ª

[14:32] <xinming_> hmm, Got it, I think I need to think more about this.

[14:33] <masak> xinming_++

[14:33] *** xinming_ is now known as xinming

[14:33] <xinming> xinming, not xinming_ :-)

[14:33] <xinming> please ++ again. :-P

[14:33] <xinming> The synopsis now is quite different from what I read last time.

[14:35] <masak> xinming++

[14:35] <masak> yes, synopses tend to behave that way.

[14:36] <masak> from the bright side, the changes are either improvements, or the change before the improvement :P

[14:37] <xinming> When I read the synopsis, I found perl 6 maybe abit over complicated.

[14:37] <xinming> Which made me think, How to implement such a language. :-)

[14:37] <moritz_> we've been asking that ourselves for some years now.

[14:37] <moritz_> :-)

[14:37] <xinming> Though, Design direction is consistent.

[14:38] <moritz_> but we've made progress

[14:38] <xinming> yes, a great progress, I am trying rakudo these days.

[14:39] <xinming> too much to learn, But I believe perl 6 will be the programming language in last 30 yearts. :-P

[14:39] <xinming> A bit like perl 5 released in last century.

[14:41] <masak> Perl 6 is a connaisseur language, for people with great taste.

[14:41] *** dakkar left
[14:43] <masak> rakudo: say Nil.elems

[14:43] <p6eval> rakudo 924242: OUTPUT¬´0‚ê§¬ª

[14:44] <masak> where the spec is implicitly undecided on what .*foo returns when there's no .foo, roast is *explicitly* indecisive. interesting.

[14:44] <masak> it just says "empty list", which might be () or Nil.

[14:44] <masak> it doesn't have a test for the definedness of the value.

[14:44] * masak adds a test

[14:46] *** dakkar joined
[14:48] <masak> rakudo: class A {}; A.new.+foo; say 'alive'

[14:48] <p6eval> rakudo 924242: OUTPUT¬´Could not invoke method 'foo' on invocant of type 'A()'‚ê§  in main program body at line 22:/tmp/E3axhhS400‚ê§¬ª

[14:48] <masak> rakudo: class A {}; A.new.*foo; say 'alive'

[14:48] <p6eval> rakudo 924242: OUTPUT¬´alive‚ê§¬ª

[14:49] <masak> rakudo: class A {}; say A.new.*foo.perl

[14:49] <p6eval> rakudo 924242: OUTPUT¬´()‚ê§¬ª

[14:50] <dalek> roast: 63157bc | masak++ | S12-methods/calling_sets.t:

[14:50] <dalek> roast: [S12-methods/calling_sets.t] made test more precise

[14:50] <dalek> roast: 

[14:50] <dalek> roast: .*foo when there's no .foo is now tested to give not only the empty list

[14:50] <dalek> roast: (), but Nil, just like .?foo

[14:50] <dalek> roast: review: https://github.com/perl6/roast/commit/63157bc618

[14:53] *** jferrero left
[14:57] *** sji joined
[15:05] <jaffa4> rakudo: m/hello/;

[15:05] <p6eval> rakudo 924242: OUTPUT¬´Method 'match' not found for invocant of class ''‚ê§  in main program body at line 22:/tmp/sjOqeFwzl5‚ê§¬ª

[15:05] *** cafesofie joined
[15:07] <jaffa4> rakudo: /hello/;

[15:07] <p6eval> rakudo 924242:  ( no output )

[15:07] <jaffa4> rakudo: m/hello/;

[15:07] <p6eval> rakudo 924242: OUTPUT¬´Method 'match' not found for invocant of class ''‚ê§  in main program body at line 22:/tmp/sFNaRD0_w5‚ê§¬ª

[15:08] <jaffa4> rakudo: :m/hello/;

[15:08] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near ":m/hello/;"‚ê§¬ª

[15:08] <masak> jaffa4: the difference is that /hello/ is a (Regex) object, but m/hello/ is an operation.

[15:08] <masak> jaffa4: there's nothing like :m/hello/, and I don't know what made you think there is.

[15:09] *** jferrero joined
[15:09] <jaffa4> Is it possible to change / as a separator?

[15:10] <masak> rakudo: $_ = "heffo"; s!ff!ll!; say $_

[15:10] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "s!ff!ll!; "‚ê§¬ª

[15:10] <masak> hm.

[15:10] * masak checks S05

[15:12] <sorear> good * #perl6

[15:12] <masak> o/ sorear

[15:13] <masak> std: s!ff!ll!

[15:13] <p6eval> std 625303c: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[15:13] * masak submits rakudobug

[15:13] <masak> jaffa4: so, the answer seems to be "yes, it should be possible to use a separator other than '/', but Rakudo doesn't allow that yet".

[15:15] <jaffa4> right

[15:15] <dalek> rakudo: 684fdf8 | masak++ | src/glue/dispatch.pir:

[15:15] <dalek> rakudo: [src/glue/dispatch.pir] .*foo returns Nil, not ()

[15:15] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/684fdf80ab

[15:22] *** sji left
[15:25] <jaffa4> $*key is like local, right?

[15:27] <sorear> right.

[15:27] <sorear> in terms of usage, anyway

[15:27] *** shi joined
[15:28] *** wamba joined
[15:30] <TimToady> I'm not sure that Nil is correct for something that is expected to return a list

[15:30] <TimToady> shower &

[15:32] <masak> hm. it feels odd to me that there'd be an inconsistency between .?foo and .*foo

[15:32] <masak> we care enough about the *consistency* between /<foo>?/ and /<foo>*/ to package the former into an array.

[15:33] <masak> (despite the overhead and confusion that creates)

[15:43] <jaffa4> !paste

[15:43] <jaffa4> ?paste

[15:44] <tadzik> phenny: paste?

[15:45] <jaffa4> What does this mean <quote_EXPR: ':qq'>?

[15:46] *** mikehh joined
[15:48] <moritz_> it calls the method quote_EXPR on the Curosr with argument ':qq'

[15:48] *** dakkar left
[15:49] <jaffa4> You mean rule?

[15:50] <sorear> Rules are just one kind of method

[15:56] <masak> ...in the OO inheritance sense, even.

[15:57] <moritz_> in any kind of sense, really

[15:58] *** dakkar joined
[15:59] * sorear is doing s!!! for niecza now

[15:59] <jaffa4> rakudo: $e~~s//g/;

[15:59] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "$e~~s//g/;"‚ê§¬ª

[15:59] <moritz_> sorear: if you figure out sane semantics for return value and $/ setting for s/// I'd like to steal that for rakudo :-)

[16:00] *** pmurias left
[16:00] <sorear> moritz_: What's the problem with the return value ?

[16:00] <jaffa4> rakudo: $e~~s://g/;

[16:00] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "$e~~s://g/"‚ê§¬ª

[16:00] <masak> ...also, the problem with $/ in .subst blocks...

[16:00] <jaffa4> rakudo: $e~~s:/ /g/;

[16:00] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "$e~~s:/ /g"‚ê§¬ª

[16:00] *** vmspb joined
[16:00] <jaffa4> rakudo: s:/ /g/;

[16:00] <p6eval> rakudo 924242: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "s:/ /g/;"‚ê§¬ª

[16:00] <sorear> jaffa4: might I suggest declaring your variables?

[16:01] <sorear> std: $e~~s//g/;

[16:01] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $e is not predeclared at /tmp/vwaCvtG6bh line 1:‚ê§------> [32m$e[33m‚èè[31m~~s//g/;[0m‚ê§Null pattern not allowed at /tmp/vwaCvtG6bh line 1:‚ê§------> [32m$e~~s/[33m‚èè[31m/g/;[0m‚ê§Parse failed‚ê§FAILED 00:01 120m‚ê§¬ª

[16:01] <masak> jaffa4: even if you fix the variable, you shouldn't try to use the null pattern.

[16:01] <masak> jaffa4: the null pattern isn't allowed in Perl 6 regexes. we talked about that yesterday.

[16:01] <jaffa4> yes, that is clear

[16:02] <masak> good.

[16:04] <sorear> niecza: s:pos(1)/x/y/

[16:04] <p6eval> niecza v2-13-g4ebb175: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method sibble not yet implemented at /tmp/pxxMlS6fwj line 1 (EOF):‚ê§------> [32ms:pos(1)/x/y/[33m‚èè[31m<EOL>[0m‚ê§‚ê§Action method quote:s not yet implemented at /tmp/pxxMlS6fwj line 1 (EOF):‚ê§------>

[16:04] <p6eval> ..[32ms:pos(1)/x/y/[33m‚èè[31m<EOL>[0m‚ê§‚ê§Unhan‚Ä¶

[16:06] *** cafesofie left
[16:08] <jaffa4> Am I right that recompiling rakudo is slow?

[16:08] <sorear> yes

[16:09] <jaffa4> more than 2 minutes.

[16:09] <masak> oh, probably on most platforms.

[16:09] <sorear> I've had it take 600 on me

[16:09] <masak> especially core.pir is slow.

[16:09] <sorear> the fastest I've seen is 8

[16:09] <jaffa4> 8?

[16:09] <jaffa4> 8 what?

[16:09] <sorear> minutes

[16:10] <sorear> 600 was also in units of minutes

[16:10] <xinming> Why will $hash = { "a" => 1, $b, $c, %stuff, @nonsense };   be hash, but    $code = { "a" => 1, $b, $c, %stuff, @_ };   will be parsed as code?

[16:11] <jaffa4> 600 minutes?

[16:11] <jaffa4> or rather seconds?

[16:11] <sorear> 10:10 < sorear> 600 was also in units of minutes

[16:11] <xinming> jaffa4: seconds.

[16:11] <sorear> xinming: because the latter block has an implicit parameter

[16:12] <sorear> xinming: wrong, minutes

[16:12] <xinming> sorear: So, you mean, with $_, @_, %_ will cause the {} be parsed as block?

[16:12] <sorear> yes.

[16:13] <xinming> Thanks, A bit strange for the first glance. :-)

[16:13] <jaffa4> what is <?[/]>?

[16:14] <sorear> It's always parsed as a block - there's a postprocess that turns parameter-less blocks consisting of a single list of items, the first of which is a pair constructor or %-variable

[16:14] <sorear> jaffa4: Is the next character /?  Zero width assertion

[16:14] <sorear> Like <?before '/'>, but faster on nqp-rx

[16:14] *** Patterner left
[16:15] <moritz_> sorear: what should s/// return?

[16:16] <jaffa4> rakudo:  "//"~~m/'/' \s* '/'/

[16:16] <p6eval> rakudo 924242:  ( no output )

[16:17] *** Psyche^ joined
[16:17] *** Psyche^ is now known as Patterner

[16:17] *** envi left
[16:22] <masak> moritz_: http://irclog.perlgeek.de/perl6/2011-01-13#i_3184316

[16:22] * sorear wonders if smartmathing against * should be more like .so

[16:23] <masak> sorear: then what would replace the old * behvaior?

[16:23] <masak> sorear: ~~ Any ?

[16:23] <masak> um. ~~ Mu ?

[16:24] <sorear> True

[16:24] <moritz_> masak: did you spec that (return value of s///)?

[16:24] <masak> sorear: that's currently syntactically disallowd because people misunderstand it.

[16:24] <masak> moritz_: no.

[16:24] <masak> I could, though.

[16:24] <sorear> masak: that's problematic from a p5 consistency viewpoint

[16:25] <moritz_> masak: it's not disallowed, it just warns

[16:25] <masak> ok.

[16:25] <sorear> if $string ~~ s/.../.../ { is idiomatic

[16:25] <moritz_> and rakudo treats all compile time warnings as errors

[16:25] <sorear> (and used in STD)

[16:25] <moritz_> well, then returning $string on success is unreliable

[16:25] <sorear> so I'd rather have s/// return true iff there was a substitution

[16:25] <moritz_> fwm too

[16:26] <sorear> right.  p5 idioms breaking is fine, having them become slightly unreliable is BAD

[16:26] <moritz_> erm, wfm

[16:26] <masak> I think it works for me as well, but I'll need to ponder it a bit more.

[16:26] <moritz_> so s/// becomes   do { $_ = $_.match; so $/ }  ?

[16:26] <masak> it does simplify the 'while s/.../.../' case.

[16:27] <moritz_> uhm

[16:27] <masak> moritz_: well, .subst

[16:27] <moritz_> *danger alert*

[16:27] <moritz_> while s:g/.../../  will behave quite differently than in Perl 6

[16:28] <moritz_> thing is, people sometimes want to access the captures from the substituion

[16:28] <sorear> according to perlre, s/// returns the number of substituions made

[16:28] <sorear> always

[16:28] <moritz_> so they want something like  for s:g/.../.../ -> $/ { say $0 }

[16:29] <sorear> so I think I'll just use that in niecza

[16:29] <moritz_> somehow I feel we can't make it right for everybody

[16:29] <jaffa4> Who should I sent a patch?

[16:29] <moritz_> jaffa4: [email@hidden.address]
[16:30] <moritz_> with [PATCH] + description in the subject

[16:30] <masak> I'd rather see we tried to work out something consistent than try to please everybody.

[16:30] <moritz_> does   s:g[foo] = do { .... }  loop the RHS automagically over all matches?

[16:31] <moritz_> I think so

[16:31] <jaffa4> what about the web interface?

[16:31] <moritz_> so that would replace the old while(s///g) { ... } idiom

[16:31] <moritz_> jaffa4: what about it?

[16:31] <masak> jaffa4: there's no way to submit patches through the web interface.

[16:32] <jaffa4> that is weird.

[16:32] <masak> I suggest you try to live with it. :)

[16:32] <moritz_> you are entitled to that opinion.

[16:33] <jaffa4> thanks for understanding.

[16:33] <masak> anytime.

[16:36] <jaffa4> well, mail sent.

[16:38] <masak> jaffa4++

[16:42] *** kjeldahl left
[16:47] <dalek> nqp-rx/nom: 57d4969 | moritz++ | build/Makefile.in:

[16:47] <dalek> nqp-rx/nom: missing dependency on nqp-builtins.pir

[16:47] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/57d4969faa

[16:47] <dalek> nqp-rx/nom: e778745 | moritz++ | / (2 files):

[16:47] <dalek> nqp-rx/nom: add skip() builtin to avoid test-out-of-sequence for skipped tests

[16:47] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/e77874559e

[16:48] <moritz_> this makes the test summary in nom a bit smaller :-)

[16:48] *** Ultali joined
[16:50] *** Sarten-X left
[16:51] *** araujo joined
[16:55] *** Ultali left
[16:56] *** Sarten-X joined
[16:57] <jnthn> evening, #perl6

[16:57] <masak> jnthn! \o/

[16:57] <jnthn> masak! \o/

[16:58] <jnthn> moritz_: Thanks for taking care of the smartmatch.t mess. :)

[16:59] <sorear> hello jnthn!

[17:01] <jnthn> o/ sorear 

[17:01] <moritz_> jnthn: no problem

[17:01] <moritz_> it was the lowest hanging fruit of all the test failures :-)

[17:01] <jnthn> :)

[17:02] <jnthn> Yes, the others are harder targets. :)

[17:02] <masak> jnthn++ # line numbers on errors in Rakudo

[17:02] <tadzik> what, where?

[17:02] <jnthn> masak: Huh? I did those ages ago :P

[17:02] <masak> nevertheless :)

[17:02] *** risou joined
[17:02] <masak> they're *really* convenient.

[17:02] <jnthn> .oO( Some features are a subscription program for karma )

[17:03] <masak> exactly.

[17:18] *** justatheory joined
[17:26] *** Su-Shee joined
[17:26] <Su-Shee> good evening all.

[17:26] <masak> evening, Su-Shee

[17:27] <sorear> hello Su-Shee 

[17:28] <jnthn> o/ Su-Shee :)

[17:29] <Su-Shee> how's the fosdem going for perl6? :)

[17:35] <dalek> niecza: 6d45faa | sorear++ | / (2 files):

[17:35] <dalek> niecza: Add &succeed and &proceed

[17:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6d45faae8b

[17:35] <dalek> niecza: f9417bc | sorear++ | / (3 files):

[17:35] <dalek> niecza: Implement substitutions

[17:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f9417bc7f2

[17:36] <sorear> moritz_: check the tests for f9417bc and see if there's anything interesting there

[17:36] *** benabik_away is now known as benabik

[17:36] <benabik> o/

[17:38] <masak> benabik: \o

[17:43] *** icwiener joined
[17:47] *** mauror joined
[17:48] *** wamba left
[17:51] *** stifynsemons joined
[17:52] *** mauror left
[17:52] <moritz_> sorear: nice, but nothing really unexpected

[17:52] *** cafesofie joined
[17:55] <diakopter> perl6: say Str

[17:55] <p6eval> pugs: OUTPUT¬´Str‚ê§¬ª

[17:55] <p6eval> ..rakudo 684fdf: OUTPUT¬´Str()‚ê§¬ª

[17:55] <p6eval> ..niecza v2-13-g4ebb175: OUTPUT¬´‚ê§¬ª

[17:56] <TimToady> masak: actually, I'm starting to think that ? in regex should return Nil for 0 matches, but * shouldn't

[17:57] <TimToady> so I think the reasoning should go the other direction

[17:57] <masak> ok.

[17:57] <diakopter> so

[17:57] <TimToady> Nil is a useful value for the boundary between scalarness and listness

[17:57] <TimToady> and ? items are perceived both ways

[18:01] <masak> aye.

[18:09] <dalek> specs: a56ffc3 | larry++ | S (2 files):

[18:09] <dalek> specs: make ?/* semantics consistently Nil/()

[18:09] <dalek> specs: review: https://github.com/perl6/specs/commit/a56ffc33ac

[18:11] <TimToady> rakudo: 'x' ~~ /(y)? (z)*/; say $0.defined, $1.defined;

[18:11] <p6eval> rakudo 684fdf: OUTPUT¬´Bool::TrueBool::True‚ê§¬ª

[18:12] <TimToady> that should be False True

[18:12] <TimToady> by the new rules

[18:12] * masak submits rakudobug

[18:12] <TimToady> and actual, the first was supposed to be False already by the old spec

[18:12] <TimToady> *ly

[18:14] <masak> rakudo: 'x' ~~ /<alpha>?/; say $<alpha>.WHAT

[18:14] <p6eval> rakudo 684fdf: OUTPUT¬´Array()‚ê§¬ª

[18:14] <masak> TimToady: so this should be Match now?

[18:15] <TimToady> no, it's still a list

[18:15] <masak> so... always Nil or a list of one item?

[18:15] <jnthn> TimToady: (by the old spec) how? An empty list is defined?

[18:15] <TimToady> we just mark the 0 case as undefined rather than defined

[18:15] <jnthn> Or did that change also?

[18:15] <TimToady> rakudo: say ().defined

[18:15] <p6eval> rakudo 684fdf: OUTPUT¬´Bool::True‚ê§¬ª

[18:16] <TimToady> rakudo: say Nil.defined

[18:16] <p6eval> rakudo 684fdf: OUTPUT¬´Bool::False‚ê§¬ª

[18:16] <TimToady> that is correct

[18:16] <jnthn> *nod*

[18:16] <masak> TimToady: when $obj.?foo succeeds, it doesn't return a list of one item.

[18:16] <TimToady> *shrug*

[18:17] <jnthn> So if (y)? by the old spec gave back and empty list, then .defined on it shoulda been true, as Rakudo has it?

[18:17] <TimToady> old spec said Nil for that

[18:17] <jnthn> oh

[18:17] <TimToady> it just didn't specify that * returned ()

[18:18] <jnthn> ah, OK

[18:18] <jnthn> I misunderstood what had changed.

[18:19] <TimToady> it's possible we can relax /x?/ to not return a list now that Nil and () are different

[18:20] <TimToady> esp if .[0] is a no-op on scalars

[18:21] <TimToady> rakudo: say 1.[0]

[18:21] <p6eval> rakudo 684fdf: OUTPUT¬´1‚ê§¬ª

[18:22] <TimToady> so again, where .?meth and x? are inconsistent, it's probably the regex that wants to change

[18:22] <TimToady> I'd like to let pmichaud++ comment on that notion first though

[18:22] *** stifynsemons left
[18:25] <masak> it's been proposed before.

[18:25] <TimToady> it makes more sense now that we have the Nil/() distinction

[18:26] *** dual left
[18:26] <TimToady> the main difference is +$0 would do something different

[18:27] <masak> I'd never do that on <rule>? anyway. I'd do ?$0

[18:27] <TimToady> rakudo: say +Nil

[18:27] <p6eval> rakudo 684fdf: OUTPUT¬´0‚ê§¬ª

[18:27] <TimToady> arguably, +Nil should warn, while +() shouldn't

[18:28] <TimToady> because the idea of Nil is that there's a least one less value than you expected

[18:29] <TimToady> which is why listy things return () instead, if 0 items is permissable

[18:29] <TimToady> Nil is the absence of an expected value

[18:30] <masak> aye.

[18:30] <TimToady> (ignoring the fact that using the ? quantifier means you are expecting 0 values :)

[18:31] <masak> was just going to say that :P

[18:38] *** dual joined
[18:43] *** cspencer joined
[18:44] <dalek> rakudo: 9898837 | pmichaud++ | src/Perl6/Actions.pm:

[18:44] <dalek> rakudo: Fix RT #83420; statement_control:<if> returns Nil if no else clause given.

[18:44] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/9898837121

[18:45] <jnthn> yay pmichaud++ patch!

[18:48] <masak> \o/

[18:50] *** cotto joined
[18:54] *** Raven left
[18:56] <sorear> TimToady: would it be ok for Nil !~~ Any?

[18:56] <sorear> S02 talks about magical behavior for assigning Nil to variables

[18:56] <sorear> I don't like magical assignment behavior unless it can be done in the type check slow path

[18:56] <sorear> (c.f. Parcels)

[18:57] * masak somehow likes Nil !~~ Any

[18:57] <masak> "it's not even anything!"

[19:09] * moritz_ installs a cronjob for std rebuilding on p6eval 

[19:16] <colomon> moritz_++

[19:16] <sorear> std: 1 [+] 2

[19:16] <p6eval> std 625303c: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[19:19] <jnthn> std: 1 [[[+]]] 2

[19:19] <p6eval> std 625303c: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[19:19] <jnthn> rakudo: say 1 [[[+]]] 2

[19:20] <p6eval> rakudo 684fdf: OUTPUT¬´3‚ê§¬ª

[19:20] <jnthn> :)

[19:20] *** cafesofie left
[19:20] <masak> rakudo: say 1 >>[[[[[RRRRR+]]]]]<< 2

[19:20] <p6eval> rakudo 684fdf: OUTPUT¬´===SORRY!===‚ê§Could not find sub &infix:<[[[[[RRRRR+]]]]]>‚ê§¬ª

[19:20] <masak> huh.

[19:21] <moritz_> rakudo: say 1 [[RR+]] 2

[19:21] <p6eval> rakudo 684fdf: OUTPUT¬´3‚ê§¬ª

[19:22] *** dorlamm joined
[19:22] <moritz_> rakudo: say 1 [RR[RR+]] 2

[19:22] <p6eval> rakudo 684fdf: OUTPUT¬´3‚ê§¬ª

[19:22] <moritz_> rakudo: say 1 >>[RR[RR+]]>> 2

[19:22] <p6eval> rakudo 684fdf: OUTPUT¬´===SORRY!===‚ê§Could not find sub &infix:<[RR[RR+]]>‚ê§¬ª

[19:22] <moritz_> seems it doesn't like that hyper'ed

[19:24] <jnthn> hmm

[19:26] <masak> rakudo: say 1 >>R+<< 2

[19:26] <p6eval> rakudo 684fdf: OUTPUT¬´3‚ê§¬ª

[19:26] <masak> rakudo: say 1 >>[+]<< 2

[19:26] <p6eval> rakudo 684fdf: OUTPUT¬´===SORRY!===‚ê§Could not find sub &infix:<[+]>‚ê§¬ª

[19:26] <masak> seems to be hyper and reduction together.

[19:26] * masak submits rakudobug

[19:26] <jnthn> oh

[19:27] <jnthn> that's not a reduction

[19:27] <jnthn> that's a bracketed infix

[19:27] <jnthn> Or should be....

[19:27] <benabik> Does >>[+]<< Make sense?  Isn't [+] a listop, not a binop?  [+] 1, 2 not 1 [+] 2

[19:27] <colomon> but rakudo screws it up

[19:27] <colomon> If you use [+] as an infix, it's just +

[19:27] <benabik> Non-intuitive, but okay.

[19:27] <jnthn> The [+] in >>[+]<< is not related to [+] 1,2,3 style things. It's just the same as >>+<<

[19:28] <jnthn> Yeah, I was like "wtf" at first :)

[19:28] <colomon> benabik: I'm not sure it isn't non-intuitive and not okay.  :)

[19:28] <colomon> It seems a very very confusing overload.

[19:28] <jnthn> colomon: Yeah, not sure why it screws it up

[19:28] <masak> jnthn: oh, true.

[19:29] <benabik> colomon: I wouldn't make it work that way, but I'm not the BDFL.  I'm willing to accept there may be reasons for it, even if I can't think of any.

[19:29] <colomon> and we've already seen a bug where someone accidentally left out an operator and converted a desired [+] reduction into normal infix:<+> with a list on the right-hand side.

[19:30] <colomon> jnthn: parser issue?

[19:30] <colomon> rakudo: say 5 R[-] 4

[19:30] <p6eval> rakudo 684fdf: OUTPUT¬´-1‚ê§¬ª

[19:30] <jnthn> colomon: I suspect the munging in the actions.

[19:33] * sorear needs to get hypers working in niecza

[19:37] *** stifynsemons joined
[19:37] *** shortcircuit left
[19:43] <masak> rakudo: my %info = x => 1, y => 2; my ($x, $y) := %info; say ($x, $y).perl

[19:43] <p6eval> rakudo 684fdf: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in 'infix:<:=>' at line 1‚ê§  in main program body at line 22:/tmp/kudgcUuXVo‚ê§¬ª

[19:43] <masak> jnthn: should something like that work?

[19:43] <xinming> perl6: Num.new(5).perl.say;

[19:43] <p6eval> niecza v2-15-gf9417bc: OUTPUT¬´(timeout)¬ª

[19:43] <p6eval> ..pugs: OUTPUT¬´*** Must only use named arguments to new() constructor‚ê§    Be sure to use bareword keys.‚ê§    at /tmp/KPV3d9A7wS line 1, column 1-20‚ê§¬ª

[19:43] <p6eval> ..rakudo 684fdf: OUTPUT¬´0‚ê§¬ª

[19:43] <jnthn> masak: Can't remember if you need to explicitly capture-ize the RHS

[19:43] *** wiseguyxp joined
[19:44] <xinming> rakudo: Num.new(5).perl.say;

[19:44] <p6eval> rakudo 684fdf: OUTPUT¬´0‚ê§¬ª

[19:44] <xinming> hmm, Why won't this returns the object please?

[19:44] <xinming> Just curious.

[19:44] <jnthn> rakudo: my %info = x => 1, y => 2; my ($x, $y) := \%info; say $x, $y;

[19:44] <p6eval> rakudo 684fdf: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in 'infix:<:=>' at line 1‚ê§  in main program body at line 22:/tmp/LsMKGXbXkQ‚ê§¬ª

[19:44] <jnthn> er, wtf

[19:44] <jnthn> I'm sure that _did_ work...

[19:45] <masak> yeah

[19:45] <jnthn> oh, wait

[19:45] <jnthn> rakudo: my %info = x => 1, y => 2; my (($x, $y)) := %info; say $x, $y;

[19:45] <p6eval> rakudo 684fdf: OUTPUT¬´12‚ê§¬ª

[19:45] <jnthn> ah.

[19:45] <jnthn> That's telling.

[19:45] <sorear> xinming: Num doesn't have a user-accessible construcot

[19:46] *** kaydsoft left
[19:46] <moritz_> it should have

[19:46] *** rgrau joined
[19:46] <masak> jnthn: can I submit as a rakudobug that it doesn't work without the double parens?

[19:46] <moritz_> just for consistency sake

[19:46] <jnthn> masak: Check if the spec says it should first.

[19:46] <masak> oki.

[19:47] <jnthn> masak: I sorta expected it to.

[19:47] *** stifynsemons left
[19:47] <xinming> sorear: So, Int, Num such kind of types don't have constructor?

[19:47] <masak> jnthn: hm.

[19:47] <masak> (:@even, :@odd) := |classify { $_ % 2 ?? 'odd' !! 'even' }, @list;

[19:47] *** cspencer left
[19:48] <masak> seems the | is needed, too.

[19:48] <masak> rakudo: my %info = x => 1, y => 2; my ($x, $y) := |%info; say ($x, $y).perl

[19:48] <p6eval> rakudo 684fdf: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in 'infix:<:=>' at line 1‚ê§  in main program body at line 22:/tmp/1QbM2ij3UZ‚ê§¬ª

[19:48] <masak> but that doesn't work either, so... :)

[19:48] * masak submits rakudobug

[19:48] <jnthn> I'm not sure | knows what to do there

[19:48] <jnthn> oh, or maybe it does...but does something wrong, hmm

[19:48] <jnthn> I bet there's some screw-up somehwere in coercion to capture.

[19:49] <colomon> xinming: They don't right now, but that is most likely a bug in Rakudo, not an actual design decision. 

[19:49] <xinming> Ok, thanks.

[19:49] <jnthn> Note that the way you get from native 2 to an Int object representing 2 isn't a constructor call. But there's no reason not to support a constructor style too.

[19:49] <sorear> If something isn't specced, you can't assume it exists

[19:50] <moritz_> well, in the long run the correct way to create a Num object is to box a low-level equivalent

[19:50] <moritz_> but what jnthn++ said

[19:50] <jnthn> Right, but Perl 6 does auto-boxing. :)

[19:50] <jnthn> So you don't have to. :)

[19:50] <sorear> Rakudo and Niecza both recognize Num.new but fail, since it doesn't actually have any useful meaning

[19:50] *** [Coke] left
[19:50] <jnthn> sorear: Right.

[19:50] <jnthn> sorear: They just hit the default constructor.

[19:51] <moritz_> niecza: Num.new(3)

[19:51] <p6eval> niecza v2-15-gf9417bc: OUTPUT¬´Unhandled exception: Excess arguments to SAFE Mu.new, used 1 of 2 positionals‚ê§  at /home/p6eval/niecza/lib/SAFE.setting line 0 (SAFE Mu.new @ 0)‚ê§  at /tmp/DK9rOlq0Aq line 1 (MAIN mainline @ 1)‚ê§  at /home/p6eval/niecza/lib/SAFE.setting line 1044 (SAFE C435_ANON @ 2)‚ê§ 

[19:51] <p6eval> ..at /home/p6eva‚Ä¶

[19:51] <sorear> the default constructor builds Num objects with a P6opaque representation, which the rest of the runtime is sadly not very robust about handling

[19:51] <sorear> that's part of what I've roadmapped to fix this month

[19:52] *** sji joined
[19:53] *** shi left
[19:56] <TimToady> colomon: 1 [+] 2 now warns, but std hasn't updated itself

[19:56] <TimToady> niecza: 1 [+] 2

[19:56] <p6eval> niecza v2-15-gf9417bc: OUTPUT¬´Potential difficulties:‚ê§  Useless use of [] around infix op at /tmp/AOZZgjrWwJ line 1:‚ê§------> [32m1 [33m‚èè[31m[+] 2[0m‚ê§‚ê§¬ª

[19:57] <colomon> TimToady: and no one has fixed Rakudo to have the same warning, so far that I know.  :)

[19:58] *** risou left
[19:59] *** coldhead joined
[20:08] *** Chillance joined
[20:09] *** [Coke] joined
[20:10] *** stifynsemons joined
[20:14] *** Mowah left
[20:16] *** dukeleto left
[20:17] *** dorlamm left
[20:17] *** dukeleto joined
[20:20] <moritz_> masak: am I to understand that i need at least the first two volumes of "Winning Ways" to get to the interesting games? :-)

[20:20] <masak> moritz_: I have the first volume checked out from the library. it wouldn't cross my mind to call it devoid of interesting games. :)

[20:21] <masak> but, by all means, get all four volumes.

[20:21] <masak> the first two are a bit more "theoretical", the latter two a bit more "practical".

[20:24] *** vmspb left
[20:24] <moritz_> well, they aren't cheap :(

[20:24] <masak> if only there was some way to win books...

[20:24] <moritz_> well, I've put it on my wishlist and hope that I didn't mess up p4 too badly :-)

[20:24] <masak> :)

[20:25] <masak> in the interests of suspense, I won't more than smile for now.

[20:26] <arnsholt> moritz_: Well, apparently noone who actually submitted on time did the perfect play variant =)

[20:26] <arnsholt> So I'd assume you're still in the running

[20:29] *** solarion left
[20:29] *** solarion joined
[20:29] <colomon> I don't know how poor masak is going to decide between different broken implementations.

[20:29] <colomon> inter-version duel to the death?

[20:30] <masak> I'm thrilled that people did badly on at least one task.

[20:30] <masak> otherwise I'd have started to doubt the level of the problems.

[20:31] <colomon> masak: don't know if you saw my comment yesterday.  Turns out that if I'd just worked a couple more hours on p4, I'd probably have noticed the 34-repeat pattern.  :)

[20:31] <masak> colomon: no, I missed that comment.

[20:31] * masak looks

[20:32] <colomon> that was the entire sum of the comment, no point looking for it now.  :)

[20:32] <masak> found it.

[20:33] <colomon> I actually got far enough to hit the repeat in the code, but not far enough that the repeat was obvious to me.

[20:33] <masak> ok.

[20:33] <colomon> just doing it via shear brute force, mind you, no smarts involved.

[20:33] <masak> counterfactuals are always fascinating. :)

[20:33] <colomon> I'm not asking for credit for it, believe me.  :)

[20:33] <masak> other contestants might have been close to cracking it and not known it, too :)

[20:33] <colomon> naturally.

[20:34] <colomon> what caught my attention is that I worked on the problem for probably something like 40 hours.

[20:34] * masak wonders how long arnsholt spent on the problem

[20:34] <arnsholt> Good question

[20:35] <colomon> I thought I was chasing down completely the wrong path, but I was actually really close to having it worked out.  But close doesn't count.

[20:35] <arnsholt> I spent quite a bit of time on the research, and just figuring out how this octal game business worked

[20:36] <colomon> arnsholt++

[20:36] <arnsholt> Once I managed to wrap my head around it, it turned out that the user-facing code took more time than the AI part proper

[20:36] <masak> :)

[20:37] <masak> ...which shows that the problem was in the same class as the others: "easy if you know how"

[20:37] <arnsholt> Which, TBH, I think is in part because the AI code is very abstract

[20:37] <arnsholt> My gut feeling is that with a differently designed AI code the UI part could probably be simplified

[20:40] * moritz_ actually did two DP attempts, but each time failed to properly combine the sub-solutions

[20:41] <masak> the combination operations are quite non-obvious and specific to this type of games, I would say.

[20:41] <arnsholt> Definitely. I don't think I'd gotten it without Wikipedia

[20:42] <arnsholt> There's a part of me that wants to know how that stuff falls out of the theory

[20:42] <masak> it's the "unknown unknowns" that prevented most people from reaching for Wikipedia.

[20:42] <masak> arnsholt: how do you mean?

[20:42] <arnsholt> The other part of me suspects that it's really, really hairy =)

[20:43] <masak> (maybe I can help) :)

[20:43] <arnsholt> Actually, your posts were quite helpful =)

[20:44] <masak> the only thing I don't understand is where 34 comes from :P

[20:45] <arnsholt> Good question. I guess it's either completely arbitrary, or hsa to be like that because of deep and inscrutable number theory =)

[20:45] <masak> I don't feel comfortable with either answer...

[20:46] <arnsholt> A true mathematician's answer

[20:48] *** ofir joined
[20:48] <masak> arnsholt: I'm looking at lib/Kayles.pm for the first time. nice code.

[20:49] *** shortcircuit joined
[20:50] *** kjeldahl joined
[20:53] *** wooden left
[20:53] <arnsholt> Thanks! I'm quite happy with that part of the code, actually

[20:53] *** wooden joined
[20:53] <arnsholt> The theory turned out to be pretty straightforward to put into code

[20:54] <arnsholt> You don't have to look too much at the UI bits ;)

[20:54] <masak> :)

[20:57] <moritz_> masak: maybe you can review arnsholt's code for p4 too (and just mention it's post deadline)

[20:57] *** mikehh left
[20:58] <masak> moritz_: yes, I'll end up doing something like that.

[20:58] <masak> note that even if arnsholt had made the deadline, which he deplorably didn't, he'd still have sent in only four solutions.

[20:58] <masak> huh, someone on parrot-dev just released something called ‚Ñ¶Œ∑;)XD

[20:59] <masak> plobsing++

[20:59] * moritz_ nods

[21:00] *** Axius joined
[21:04] *** Chillance left
[21:15] *** kaydsoft joined
[21:16] *** kaare_ left
[21:17] *** jasonmay is now known as JasonMay

[21:18] *** kaare_ joined
[21:21] *** kaydsoft left
[21:24] *** Axius left
[21:31] *** JasonMay is now known as jasonmay

[21:32] *** kaydsoft joined
[21:35] <ofir> is perl5 expected to be totally deprecated after perl6 is officialy released ?

[21:35] <tadzik> no

[21:35] <jnthn> No

[21:35] <masak> ofir: Perl 6 has been officially released.

[21:35] <ofir> oh nice to know

[21:36] <masak> and Perl 5 hasn't been totally deprecated.

[21:36] <ofir> so those are 2 different dev branches ?

[21:36] <masak> exactly.

[21:36] <masak> you got it in two guesses :)

[21:36] <ofir> heh

[21:36] <masak> nicely done.

[21:36] <mathw> perl 6 isn't backwards compatible with perl 5, so we can't declare that perl 5 is gone

[21:36] <mathw> the perl 5 community would hate that anyway :)

[21:36] <masak> yeah, they'd be pretty pissed off, I think.

[21:37] <masak> heck, I'd be a little angry.

[21:37] <jnthn> :)

[21:37] <jdhore> Perl 6 seems VERY nearly 100% backward-compatible to Perl 5 to me, but what do i know.

[21:37] *** pmurias joined
[21:37] <masak> jdhore: well, they're not totally dissimilar. but saying that they're close isn't exactly it either.

[21:37] <ofir> like anything in life, it is a matter of time until Perl 5 will no longer be maintained

[21:38] <masak> jdhore: it was more true around 2002-2003.

[21:38] <diakopter> ofir: most would disagree with that

[21:38] <ofir> diakopter, why, what's the point in the duplicites of two different languages in one langauge ?

[21:38] <sorear> perl 5 will die

[21:38] <sorear> very slowly

[21:39] <mathw> jdhore: there's really not much perl 5 you can feed to a perl 6 compiler and have it work

[21:39] <sorear> it will probably still be in use 40 years from now

[21:39] <ofir> diakopter, it's as if I'll tell you that you can still burn CD's, and floppy disks, but you wouldn't

[21:39] <diakopter> it's installed just too many places, and too many places rely on it for building/bootstrapping other software that must live on forever

[21:39] <benabik> Perl 6 will replace Perl 5 the same way C++ replaced C.

[21:39] <sorear> I assign 80% odds that perl 5 will reach "dead language" status before Perl 6

[21:39] <masak> benabik: that is to say, "not really"? :)

[21:39] <diakopter> ofir: not even close.

[21:39] <masak> ofir: what diakopter said.

[21:40] <masak> ofir: I'm an ardent Perl 6 user, and I use Perl 5 quite a bit.

[21:40] <diakopter> there are tens or hundreds of perl5 installations, and I fully agree with sorear that it'll still be in use 40 years from now.

[21:40] <masak> ofir: some of the reasons is of the "at this point in time" kind, but not all of it.

[21:40] <ofir> masak, until one day it'll give you the creeps and you're mind will be split to 5 & 6 chunks, and you'll decide that there's a room for one perl only

[21:41] <masak> diakopter: s/hundreds/hundreds of thousands/?

[21:41] <diakopter> in an individual's mind, maybe, but that has nothing to do with the market as a whole

[21:41] <mathw> hundreds of thousands, more like

[21:41] <jdhore> Also, it'll prolly take a very long time till most of the CPAN is P6

[21:41] <diakopter> masak: bwahaha; I meant to say tens or hundreds of millions :D  thanks

[21:41] <masak> diakopter: :)

[21:41] <mathw> and many, many of those aren't even a very recent Perl 5

[21:41] <masak> ofir: actually, I feel I'm moving in the other direction.

[21:41] *** wallberg joined
[21:41] <mathw> (which is a big shame)

[21:42] <masak> ofir: I'm learning more and more programming languages, and Perl 5 and Perl 6 keep coming out as my favorite two.

[21:42] <Su-Shee> ah well that old perl 5 feeds 55 people here for example. ;)

[21:42] *** wallberg left
[21:42] <jdhore> ascent_, for me, that's Perl 5, Perl 6 and C 9in no particular order)

[21:42] <jdhore> *(

[21:43] *** wallberg joined
[21:43] <diakopter> .(

[21:43] <mathw> Perl 5 skills pay part of my salary...

[21:43] <mathw> a very small part, but part :)

[21:43] <jdhore> er, i highlighted the wrong person, i suck.

[21:43] <jdhore> masak, ^^

[21:43] <mathw> mostly, I get paid for being very patient

[21:43] <mathw> :P

[21:44] <Su-Shee> well it boils down to environment.. every time I try something else but perl I'd either have to use java or python to get something even resembling CPAN's power. 

[21:44] <mathw> Mmm I recently got the freedom to do a script with as many CPAN modules as I wanted/needed

[21:45] <mathw> found some very helpful ones indeed

[21:45] <Su-Shee> last weekend I got stuck with something as stupid as javascript's \w not working properly with umlauts. 

[21:45] <mathw> although there wasn't one which did precisely what I wanted, which was disappointing because I thought there might be (or at least, I couldn't find one)

[21:45] <mathw> Su-Shee: eeww

[21:45] <Su-Shee> yeah that's what I said but with more words ;)

[21:45] <pmurias> mathw: what did you intend to do?

[21:47] *** pmurias left
[21:49] <diakopter> ofir: last I looked, even git depends on perl... (someone correct me where I'm wrong)

[21:52] <ofir> diakopter, correct

[21:52] <diakopter> (my point is that all the (tens/hundreds? of) thousands of free/open-source software packages/projects that depends on Perl 5 (NOT TO MENTION the 100x that amount (probably, by lines of code) of unseen/corporate/private Perl 5 code) would all need to recursively remove/port all those Perl 5 dependencies, or go dormant/obsolete themselves, in order to satisfy your claim)

[21:53] <Su-Shee> yeah. if it's out there, it's out there. ;)

[21:54] <diakopter> (by a wide definition of "maintained")

[21:54] <diakopter> for example.

[21:54] <Su-Shee> I don't want to know how many perl scripts are silently running for a decade noone ever touching them until they get forgotten.. 

[21:54] <ofir> diakopter, well I guess you are right, it doesn't count by number of weeks nor months, but It must happen sometime

[21:55] <diakopter> lifetimes

[21:55] <Su-Shee> ofir: there is no "must happen" - a perl renaissance could happen as well. 

[21:56] <diakopter> (the other half of my point is that if there are so many softwares dependent on it, it will be "maintained" *enough* for them, b/c they need it)

[21:56] <dalek> nqp-rx/nom: ad21c53 | jonathan++ | / (5 files):

[21:56] <dalek> nqp-rx/nom: Role composition for when a class just does a single role (we don't do the role summation case just yet). Seems method and attribute composition works, methods in the class beat ones from the role and mentions of $?CLASS are correctly generic.

[21:56] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/ad21c534fa

[21:56] <ofir> diakopter, and who guarantees that support & maintenance ?

[21:57] * masak liked the phrase "recursively remove/port all those Perl 5 dependencies"

[21:58] <masak> that's not really true, though. Perl 5 could stop being maintained, and all that code could still exist out there.

[21:58] <masak> just as some people still run Perl 4 code, even though Perl 4 isn't being maintained.

[21:58] <diakopter> eh, I was using a wide definition of maintained

[21:59] <masak> does it matter? unmaintained Perl versions don't just disappear...

[21:59] <BinGOs> Perl5::ButMaintained

[21:59] <diakopter> like, "still available to download", and "folks available/willing to be paid to consult on it privately to maintain/install/support it if it's not publicly maintained"

[22:00] <masak> oh, ok.

[22:00] *** wallberg left
[22:00] <diakopter> i guess another portion of my argument would need to be that those private supporters would help keep it public too.

[22:01] <diakopter> (seems reasonable to me)

[22:03] *** dakkar left
[22:06] *** icwiener left
[22:10] *** kjeldahl left
[22:12] <dalek> sprixel: 86dcfe6 | diakopter++ | / (9 files):

[22:12] <dalek> sprixel: [perlesque] (compiler) yet another iteration of improvements to generics on mono

[22:12] <dalek> sprixel: should support knap01 now.

[22:12] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/86dcfe6d34

[22:13] <diakopter> sorear: re "80% odds"... that's interesting

[22:19] *** cosimo joined
[22:19] <sorear> jnthn: Any progress on subset/native types in 6model?

[22:19] *** cafesofie joined
[22:21] <jnthn> sorear: 'fraid not. I had a lack of tuits last week to do much Perl 6 stuff at all. Much of the thinking time I have had has gone into how to factor roles and trying to work out a roadmap for the rakudo/nom branch.

[22:21] <jnthn> sorear: Though I think roles may soon make me hit the same issue that subset types bring up in terms of the type cache.

[22:21] <sorear> jnthn: any type 'does' a finite number of roles

[22:22] <sorear> but an infinity of subset types

[22:22] <jnthn> sorear: That's not exactly true.

[22:22] <sorear> ?

[22:22] <jnthn> In the non-parametric case you're right.

[22:22] <jnthn> but PR[S] ~~ PR[T] is true where S ~~ T

[22:23] <jnthn> It's still finite in a sense

[22:23] <jnthn> But not automatically in a useful way.

[22:24] <jnthn> Well, the totally non-parametric case of roles doesn't actully exist.

[22:24] <jnthn> Since any mention of $?CLASS is generic.

[22:24] <jnthn> But you get a certain amount of simplification if you only handle that case.

[22:30] <xinming> What is twigil mean please?

[22:30] <jnthn> $!foo $*bar $.baz # in these, the twigils are !, * and .

[22:30] <xinming> jnthn: thanks

[22:30] <jnthn> It's a "secondary sigil" essentialy

[22:31] <benabik> Name is derived from sigil number two, or something similar.

[22:31] <xinming> Ok, got it. thanks

[22:33] <masak> Á¨¨‰∫å‰∏™sigil :)

[22:35] <diakopter> chimchimney

[22:36] <masak> I don't even see the characters anymore. to me, they're just blonde, brunette...

[22:37] <jnthn> That's kinda shallow. They all have personalities and stuff.

[22:41] <masak> jnthn: http://www.imdb.com/title/tt0133093/quotes?qt0324317

[22:41] <jnthn> Oh!

[22:42] <masak> you might have seen it... :)

[22:42] * jnthn missed that reference completely, and was trying to work out why masak had randomly context-switched... :)

[22:42] <masak> (too bad they never made any sequels)

[22:44] <diakopter> or prequels

[22:44] *** garo joined
[22:44] <tadzik> yeah

[22:47] <sorear> I'm thinking parametrized roles need to have a little bit of the subset-nature

[22:48] <jnthn> sorear: In so far as "a simple type cache won't get us all the way", certainly.

[22:49] <jnthn> sorear: The main issue at the moment is that the type cache is "all or nothing".

[22:49] <jnthn> Which isn't really ideal.

[22:49] <jnthn> I just didn't settle on exactly how to change it yet.

[22:49] *** garo left
[22:50] *** am0c joined
[22:50] *** kaare_ left
[22:50] <jnthn> We'd really like "is this some kind of Positional/Callabe/Associative" to be fast.

[22:50] <jnthn> At the moment it's painfully not.

[22:52] * jnthn wonders if NQP roles should supporting punning or just demand they be composed into something

[23:05] *** drbean joined
[23:06] *** leprevost joined
[23:07] *** leprevost left
[23:08] *** leprevost joined
[23:11] *** leprevost left
[23:11] *** jql joined
[23:12] *** benabik is now known as benabik_away

[23:16] <masak> '‚ôû, #perl6.

[23:16] *** masak left
[23:17] *** jaffa4 left
[23:18] *** guidj0s joined
[23:19] <colomon> "black knight, #perl6"??  ;)

[23:21] <arnsholt> White knight on my end =p

[23:22] *** guidj0s left
[23:22] <jnthn> sleep &

[23:27] *** orafu joined
[23:29] *** am0c left
[23:32] <diakopter> TimToady: knap01 works now on mono :)

[23:32] <diakopter> 3 seconds on the p6eval machine from the shell, but oddly 30 seconds from p6eval

[23:32] <diakopter> I'm trying to diagnose why

[23:33] <diakopter> hm, maybe p6eval needs another execution mode ;)

[23:33] <diakopter> ...at least for perlesque

[23:36] *** MayDaniel left
[23:39] *** jasonmay left
[23:49] *** rgrau left
[23:49] *** hudnix joined
