[00:08] <sjohnson> o.O

[00:18] <sorear> hello adriano86

[00:21] *** awoodland left
[00:21] *** stkowski left
[00:33] <sorear> moritz_: __sri: TimToady: one very important thing to consider is that Perl 6 is a _programming language_

[00:33] <sorear> by design, our only users are other programmers

[00:33] <sorear> which makes a lot of the normal friction points disappear

[00:33] <__sri> sorear: that's very very wrong

[00:34] <__sri> programming languages need to be sold to decision makers

[00:34] <__sri> which are sadly not programmers most of the time

[00:37] <sorear> when your implementations suck as badly as ours do, decision makers can be counted out.

[00:47] *** ponbiki left
[00:51] *** adriano86 left
[00:59] *** kfo joined
[01:01] *** icwiener left
[01:04] *** Rotwang left
[01:07] *** rdesfo joined
[01:08] *** ymasory left
[01:08] *** woosley joined
[01:09] *** ymasory joined
[01:09] *** edenc joined
[01:10] *** ymasory left
[01:10] *** ymasory joined
[01:11] *** envi joined
[01:28] *** HarryS left
[01:33] *** am0c joined
[01:33] *** jaldhar joined
[01:40] *** impious left
[01:45] *** HarryS joined
[01:47] *** whiteknight left
[02:00] *** tadzik left
[02:02] <rdesfo> goodnight

[02:02] <rdesfo> :o wrong window

[02:11] *** Juerd joined
[02:13] *** de joined
[02:13] <de> Hop

[02:15] *** hugme joined
[02:15] *** ChanServ sets mode: +v hugme

[02:15] <Juerd> FYI: really weird Xen troubles

[02:16] <Juerd> Just did an emergency migration to KVM...

[02:16] *** de left
[02:16] *** de joined
[02:19] *** s1n left
[02:20] *** s1n joined
[02:27] *** de left
[02:29] *** pnu joined
[02:38] *** ymasory_ joined
[02:44] *** am0c left
[02:46] *** donri joined
[02:49] *** Util joined
[02:54] *** donri left
[02:54] *** hugme left
[02:54] *** rdesfo left
[02:54] *** cosimo left
[02:54] *** dju_ left
[02:54] *** barika left
[02:54] *** HarryS left
[02:54] *** plobsing left
[02:54] *** dsp_ left
[02:54] *** PacoLinux left
[02:54] *** amkrankruleuen left
[02:54] *** noganex left
[02:54] *** starcoder2 left
[02:54] *** PZt left
[02:54] *** ggoebel left
[02:54] *** DarthGandalf left
[02:57] *** orafu left
[02:57] *** orafu joined
[02:57] *** donri joined
[02:57] *** hugme joined
[02:57] *** rdesfo joined
[02:57] *** cosimo joined
[02:57] *** dju_ joined
[02:57] *** wooden joined
[02:57] *** aloha joined
[02:57] *** barika joined
[02:57] *** mathw joined
[02:57] *** rokoteko joined
[02:57] *** asimov.freenode.net sets mode: +v hugme

[02:58] *** donri left
[02:58] *** donri joined
[02:59] *** ymasory left
[03:00] *** HarryS joined
[03:00] *** plobsing joined
[03:00] *** dsp_ joined
[03:00] *** PacoLinux joined
[03:00] *** amkrankruleuen joined
[03:00] *** noganex joined
[03:00] *** starcoder2 joined
[03:00] *** PZt joined
[03:00] *** ggoebel joined
[03:00] *** hatseflats joined
[03:00] *** Bucciarati joined
[03:00] *** renormalist joined
[03:00] *** TiMBuS joined
[03:00] *** drbean joined
[03:00] *** _dev0_ joined
[03:00] *** knewt2 joined
[03:00] *** awwaiid joined
[03:00] *** baest joined
[03:00] *** Brandon_W_ATS joined
[03:00] *** mdxi_ joined
[03:00] *** apejens joined
[03:00] *** DarthGandalf joined
[03:00] *** ribasushi joined
[03:00] *** IRSeekBot joined
[03:00] *** kolibrie joined
[03:00] *** charsbar_ joined
[03:00] *** kcwu joined
[03:00] *** robinsmidsrod joined
[03:01] *** HarryS left
[03:01] *** HarryS joined
[03:20] <sorear> Juerd: "emergency migration"?

[03:21] *** nymacro joined
[03:21] <Juerd> Yes.

[03:22] <Juerd> There is no working combination of the spare hardware at hand, a linux kernel and a Xen hypervisor

[03:22] <Juerd> I've tried just about every permutation I could find.

[03:22] *** pnu left
[03:23] <Juerd> I couln't really get rid of Linux or the hardware

[03:23] <Juerd> So Xen had to go

[03:23] <Juerd> It all started with broken hardware :(

[03:27] *** pnu joined
[03:34] *** agentzh joined
[04:31] *** mtk left
[04:33] *** ymasory_ is now known as ymasory

[04:39] *** mtk joined
[04:40] *** envi left
[04:40] *** envi joined
[05:01] <sorear> The current realpath/modtime approach to niecza's module path is starting to bug me

[05:01] <sorear> *cache

[05:01] <sorear> Any good reason not to bundle a SHA implementation and use that instead?

[05:05] *** rdesfo left
[05:14] *** mberends joined
[05:16] <mberends> hi sorear

[05:19] <sorear> hello mberends

[05:19] <mberends> SHA1 for module tracking is fine, although I think the algorithm and the digest size may be overkill for what is needed. There are faster algorithms such as CRC, Fletcher etc.

[05:19] <sorear> niecza won't bootstrap today ... I wonder what broke

[05:20] <mberends> also, although only tangentially related, I suggest following the general approach that Rakudo is also doing initially: https://github.com/rakudo/rakudo/blob/master/docs/S11-Modules-proposal.pod

[05:21] <sorear> I don't beleive that document has been updated since (before I heard of Perl6)

[05:21] <mberends> yes, but I co-wrote it ;)

[05:22] <mberends> the intent has not changed.

[05:23] <mberends> it was just a path through the minefield of ambitious expectations

[05:25] *** tadzik joined
[05:25] <mberends> oh hai tadzik

[05:26] <tadzik> oh hai

[05:26] <tadzik> what happened to feather?

[05:26] <mberends> tadzik: Juerd++ reported a hardware problem that affected the virtual machine hosting

[05:27] <tadzik> yeah, just read the log

[05:36] *** benabik left
[05:41] *** dzg joined
[05:45] *** nick_ joined
[05:46] *** nick_ is now known as Guest16281

[05:49] *** mberends left
[05:57] *** Guest16281 left
[05:57] *** dzg left
[06:11] *** sftp left
[06:29] * sorear out.

[06:33] *** pnu left
[06:35] *** mberends joined
[06:35] *** pnu joined
[06:37] *** kaare_ joined
[06:51] *** mberends left
[07:07] *** cosimo left
[07:21] *** mberends joined
[07:25] *** noganex_ joined
[07:28] *** dual left
[07:29] *** noganex left
[07:29] *** kjeldahlw joined
[07:36] *** dual joined
[07:38] <jnthn> Good afternoon :)

[07:50] <mberends> good *, jnthn :)

[07:52] <jnthn> o/ mberends 

[07:55] *** shi joined
[08:07] *** jaldhar left
[08:07] *** jaldhar joined
[08:19] *** mj41 joined
[08:20] *** tadzik left
[08:29] *** nymacro left
[08:31] *** fhelmberger joined
[08:51] *** Mowah joined
[08:52] *** ggoebel left
[08:53] *** ggoebel joined
[08:53] *** jaldhar left
[08:53] *** jaldhar joined
[09:06] <moritz_> \o

[09:06] <moritz_> hugme is still alive, that's a good sign :-)

[09:06] <moritz_> hugme: hug everybody

[09:06] * hugme hugs everybody

[09:07] *** jql left
[09:13] *** am0c joined
[09:19] *** woosley left
[09:21] *** dakkar joined
[09:32] <woldrich> hugme,

[09:32] <woldrich> hugme, hugme

[09:32] <hugme> woldrich: 

[09:32] <moritz_> woldrich: it understands 'hug me'

[09:32] <woldrich> hugme, hug me

[09:32] * hugme hugs woldrich

[09:33] <woldrich> but, but, but

[09:33] <woldrich> I wanted hugme to hug hugme!

[09:33] <moritz_> then say it

[09:33] <moritz_> hugme: hug hugme

[09:33] * hugme hugs hugme

[09:33] *** shi left
[09:33] <woldrich> oh, I suck :)

[09:34] <woldrich> hugme, source

[09:34] <moritz_> hugme: show hugme

[09:34] <hugme> moritz_: the following people have power over 'hugme': P⁣erlJam, T⁣imToady, [⁣particle], c⁣olomon, j⁣nthn, m⁣asak, m⁣berends, m⁣oritz_, p⁣michaud. URL: http://github.com/moritz/hugme/

[09:35] <woldrich> Heh. I thought she'd be written in perl6 :)

[09:36] <moritz_> woldrich: I would have written it in Perl 6 if its only feature were hugging

[09:36] <woldrich> heh

[09:36] <moritz_> but the main feature is adding committers to various repositories

[09:36] <woldrich> yeah, I see that

[09:36] <moritz_> and for that you need good library support

[09:37] <woldrich> Is there some not-so-sucky bot written in actual perl6 that you know of?

[09:37] <moritz_> woldrich: TiMBuS has been working on an IRC bot, but I don't know what it does, and how good the code quality is (never really looked at it)

[09:38] <woldrich> oh, Net::IRC for perl6

[09:39] *** tzhs joined
[09:39] <TiMBuS> oh

[09:39] <TiMBuS> hello

[09:39] <TiMBuS> Net::IRC works except with no threads you cant do much

[09:42] <TiMBuS> async IO might help

[09:42] <TiMBuS> for web requests, like a twitter bot or something. i could tie IO requests into the bots IO loop somehow

[09:47] *** shi joined
[09:58] *** timbunce joined
[09:59] *** timbunce left
[10:03] *** fhelmberger_ joined
[10:04] *** fhelmberger left
[10:17] *** fhelmberger_ left
[10:19] *** fhelmberger joined
[10:21] *** tadzik joined
[10:22] *** dolmen joined
[10:39] *** tzhs left
[10:39] *** tzhs joined
[11:00] *** birdwindupbird joined
[11:09] *** woosley joined
[11:14] <tadzik> o/

[11:17] *** bacek left
[11:29] *** agentzh left
[11:38] *** leprevost joined
[11:44] <tadzik> mberends: why is there a Configure and Makefile.in in Web.pm?

[11:45] *** jevin joined
[11:57] <mberends> tadzik: the answer is in Web.pm/lib/Configure.pm: customize the PERL6LIB, PERL6BIN and RAKUDO_DIR variables in the Makefile. This pre-dates the creation on ufo.

[11:57] <mberends> s/on/of/

[12:00] <takadonet> morning all

[12:00] <tadzik> mberends: so it it obsolete now?

[12:05] <mberends> tadzik: I think so, but test the change

[12:06] <tadzik> mberends: difficult to test, for there is almost nothing that works anyway :) But I was using ufo for my development

[12:16] *** fhelmberger left
[12:17] *** mtk left
[12:18] *** rdesfo1 joined
[12:26] *** mtk joined
[12:31] *** fhelmberger joined
[12:40] *** birdwindupbird left
[12:58] *** pmurias joined
[13:00] *** mj41 left
[13:03] *** mj41 joined
[13:11] *** plobsing left
[13:13] *** birdwindupbird joined
[13:16] *** MayDaniel joined
[13:30] *** MayDaniel left
[13:33] *** birdwindupbird left
[13:38] *** plainhao joined
[13:46] *** quotemstr joined
[13:46] <quotemstr> Perl 6 rules look awesome.

[13:46] <quotemstr> Is there anything that would have been changed in hindsight?

[13:47] *** arlinius joined
[13:47] <moritz_> if we find something that should have been changed in hindsight, we still change it

[13:48] <moritz_> so I guess the answer is "no"

[13:48] <quotemstr> Heh, good point.

[13:48] <moritz_> though I do have a concern, but no good solution for it

[13:48] <moritz_> for regexes, the current syntax is just fine

[13:49] <moritz_> but for grammars it would be beneficial if one could omit the < > around rule calls, and be forced to quote literals at the same time

[13:49] <quotemstr> I'm implementing a PEG-ish composable grammar system for Emacs, and it turns out my thinking went along the same lines as the design behind Perl 6 rules. I figured I might as well learn from experience.

[13:49] <moritz_> but we don't want to force people to use two regex syntaxes

[13:49] <quotemstr> You already have a different syntax for tokens and other rules.

[13:50] <quotemstr> (The default backtracking is different.)

[13:50] *** ymasory left
[13:50] <moritz_> well, I wouldn't go so far as to call it a different syntax

[13:51] <moritz_> in fact it *looks* the same, which is what syntax is about :-)

[13:52] <moritz_> and I think it's a good thing; it makes it very easy to test if backtracking is a problem in a certain rule

[13:52] <quotemstr> When two things look the same and mean something different, we call that a "lie". :-)

[13:52] <moritz_> quotemstr: we call it "distinguished by context"

[13:53] <moritz_> does javascript lie when it uses + both for addition and concatenation?

[13:53] <quotemstr> Why don't tokens and rules backtrack by default though?

[13:53] *** PerlJam joined
[13:54] <moritz_> because they are usually used in bigger parsers, where backtracking is nearly never needed

[13:54] <moritz_> it just slows things down, and causes confusion

[13:55] <moritz_> quotemstr: the standard grammar for Perl 6 has 807 tokens and rules, and only 27 regexes

[13:56] <quotemstr> Oh, I'm not objecting.

[13:56] * jnthn didn't realize we had as many as 27...

[13:56] <moritz_> nor did I think you did

[13:56] <moritz_> wait, my numbers are bogus

[13:57] <moritz_> I did an   ack -w regex|wc -l

[13:57] <moritz_> and didn't realize that most regex parsing error messages matched that

[13:57] <jnthn> ah :)

[13:57] <moritz_> $ ack '^\s*regex\b' STD.pm6|wc -l

[13:57] <moritz_> 6

[13:57] <quotemstr> Also, do ::, ::>, and friends only work in the *lexical* scope of an alternation?

[13:58] <moritz_> that number sounds much more reasonable

[13:58] <moritz_> quotemstr: I think it depends on the "friends"

[13:58] <jnthn> moritz_: Yes, I much prefer that number :)

[13:58] *** icwiener joined
[13:58] <quotemstr> Well, let's just talk about ::. If we have ms/ something :: <blah> /, :: commits after matching something

[13:58] <moritz_> quotemstr: I only have an old definition of the regex control sequences in my head. In those, ::: definitively acted on the surroundings too

[13:59] *** PerlJam left
[13:59] <quotemstr> What about blah = a :: b, ms / < blah>, <blah2> / ...

[13:59] *** PerlJam joined
[14:00] <moritz_> :: works in the current LTM construct

[14:00] <quotemstr> Right. But is "current" bound lexically or dynamically?

[14:00] <moritz_> if you add foo:sym<bla> rules to it, the current LTM construct is larger than the lexical scope

[14:00] <moritz_> so, not lexical

[14:01] <quotemstr> Ah, okay.

[14:03] <moritz_> though LTM basically "inlines" until it finds things a DFA can't match

[14:03] <quotemstr> Ah, so you do construct a DFA instead of just running an NFA directly.

[14:03] <moritz_> but as far as I understand, :: only works on the current alternative, not on the full DFA

[14:04] <moritz_> quotemstr: that's the idea behind it, but some implementations still cheat

[14:04] *** rdesfo1 left
[14:04] <quotemstr> Right. So :: does nothing if we're not inside a LTM alternation (|), and ::> does nothing if we're not inside a prioritized choice (||) ?

[14:05] <quotemstr> It's be nice if Synopsis 5 called that out.

[14:05] <PerlJam> "does nothing"?

[14:05] <moritz_> quotemstr: you can add that. Tell me your github account, and I'll give you a commit bit

[14:06] *** jaldhar left
[14:06] <moritz_> quotemstr: and the good thing is that if we both understood that wrongly, somebody will revert your commit, and we know we were wrong :-)

[14:06] <quotemstr> moritz_: dcolascione :-)

[14:06] <quotemstr> Good point.

[14:06] <moritz_> hugme: add dcolascione to perl6

[14:06] * hugme hugs dcolascione. Welcome to the perl6 github organization

[14:06] <TimToady> it sounds about right to precaffienated /me

[14:06] <TimToady> niecza does DFA, rakudo doesn't yet

[14:07] <moritz_> rakudo doesn't do real LTM yet either

[14:07] <moritz_> it just does it for constant prefixes

[14:07] <TimToady> and ::> is mostly a placeholder; I don't know if anyone implements it yet

[14:07] <quotemstr> Now I just need to find that piece.

[14:07] <moritz_> repo is perl6/specs/

[14:07] <quotemstr> moritz_: Honestly, I very seldom myself wanting longest-match behavior.

[14:07] * quotemstr edits.

[14:08] <moritz_> quotemstr: it's *very* handy when you want to write extensible grammars

[14:08] <moritz_> quotemstr: without LTM, you have to find some rules about the order of parsing when adding new alternatives. Which gets ugly when you have two or more independent augmentions of the same grammar

[14:09] <quotemstr> moritz_: Why's that? Wouldn't the other kind of alternation be more predictable?

[14:09] *** jimmy1980 joined
[14:09] <TimToady> a longest match anchored at the current position is very much more useful than a longest match out in the middle somewhere

[14:09] <quotemstr> moritz_: If I'm extending a grammar, I can prefix one of its alternations with my own and be confident that it'll be tried first regardless of whatever else is in that alternation.

[14:10] <quotemstr> Likewise, if I add an entry to the end of the alternation list, I know that I won't preempt any valid syntax.

[14:10] <moritz_> quotemstr: unless a second grammar modification is applied, which does the same thing

[14:10] <TimToady> the LTM rule scales better

[14:10] <moritz_> and those two modifications know nothing of each other

[14:10] <quotemstr> moritz_: But in the presence of two grammar modifications, you don't know which modification adds the longer match and the result is still unpredictable, yes?

[14:10] <quotemstr> TimToady: Performance-wise? Temporal should be faster, yes?

[14:11] <TimToady> dfa can be fast

[14:11] <quotemstr> TimToady: You can only create a DFA when the LTM prefixes match regular languages.

[14:11] <moritz_> quotemstr: I don't find LTM to be unpredictable at all. The rules are pretty intuitive, and well defined

[14:12] <quotemstr> In the general case, you just have to try all cases and pick the longest.

[14:12] <moritz_> well, LTM prefixes are defined in a way to allow DFA construction

[14:12] <quotemstr> moritz_: What do you mean? I thought they could be general.

[14:13] <moritz_> quotemstr: http://perlcabal.org/syn/S05.html#Longest-token_matching has a list of what terminates LTM prefixes

[14:13] *** jonalv joined
[14:13] *** jonalv left
[14:14] <moritz_> it's quite intuitive that a ++ is parsed as prefix:<++>, and not two chained prefix:<+>. That's what LTM gives you for free.

[14:14] <quotemstr> Ahh.

[14:15] <moritz_> mind you, I haven't written a grammar engine, and only a small number of grammars, but the concept of LTM makes sense to me

[14:15] <TimToady> a P6 grammar gives you the best of both DFA and NFA matching, and generally manages the transition from one to the other without the user having to worry much

[14:16] <moritz_> quotemstr: if you want some more reading, I've written two articles on http://perlgeek.de/en/article/ ("A Mutable Grammar for Perl 6" and "Longest-Token Matching"), mostly in an attempt to actually understand it myself

[14:16] <TimToady> or looking at it another way, a P6 grammar will write JIT lexers for you as needed

[14:16] <quotemstr> moritz_: I'll take a look --- thanks.

[14:17] <quotemstr> So let me get this straight --- a LTM is only longest-match with respect to (essentially) the regular prefixes of all the alternatives?

[14:17] <moritz_> quotemstr: feel free to ask if anything in these articles is unclear to you

[14:17] <moritz_> quotemstr: yes

[14:18] <moritz_> (and regular prefixes can be artifically excluded from the prefix with things like :: and {} )

[14:18] * quotemstr reads.

[14:18] <PerlJam> moritz_: you need to change your favicon to a zebra :)

[14:18] <moritz_> s:2nd/prefix/LTM/

[14:18] <TimToady> the "token" part of it implies that each token is anchored to the end of the previous token/whitespace

[14:18] *** arlinius left
[14:18] <moritz_> PerlJam: make me a zebra favicon, and I'll do it :-)

[14:18] <quotemstr> TimToady: It seems obvious that longest-match is longest-match at that point, not globally.

[14:19] * quotemstr looks up how to create a link in POD.

[14:19] <moritz_> L<...>

[14:20] <quotemstr> Right, but that's absolute according to man perlpod. What's the equivalent to <a href="#foo">bar</a>?

[14:20] <quotemstr> Ahh.

[14:20] <quotemstr> L<foo|"bar">

[14:21] <moritz_> or just L<#Section Name>

[14:21] <moritz_> o wait, that might P6 Pod only

[14:21] <moritz_> (and the specs are in p5 POD)

[14:23] <sorear> niecza: say "foom" ~~ / [ .* ::> o ] /

[14:23] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«Unhandled exception: Unable to resolve method oplift in class Any␤  at /home/p6eval/niecza/src/RxOp.pm6 line 9 (RxOp C8_ANON @ 1)␤  at  line 0 (KERNEL map @ 2)␤  at /home/p6eval/niecza/src/RxOp.pm6 line 9 (RxOp RxOp.oplift @ 3)␤  at /home/p6eval/niecza/src/RxOp.pm6

[14:23] <p6eval> ..line 9 (RxOp C8_…

[14:23] <sorear> "looks like no"

[14:24] <sorear> the support code is there, though; getting that to work is probably LHF

[14:28] <quotemstr> Changes made.

[14:28] <dalek> specs: 9c90489 | (Daniel Colascione)++ | S05-regex.pod:

[14:28] <dalek> specs: add links to LTM acronym expansion

[14:28] <dalek> specs: review: https://github.com/perl6/specs/commit/9c904897f9

[14:28] <dalek> specs: b6ea876 | (Daniel Colascione)++ | S05-regex.pod:

[14:28] <dalek> specs: Explain effects of :: and ::> wrt dynamic/lexical scope and lack of enclosing alternations

[14:28] <dalek> specs: review: https://github.com/perl6/specs/commit/b6ea8768a8

[14:28] * quotemstr pushes.

[14:28] <moritz_> quotemstr++

[14:29] *** benabik joined
[14:30] <PerlJam> quotemstr++ indeed.  I was slightly worried about the "does nothing" wording, but you've made sense of it perfectly :)

[14:30] <moritz_> I think that was the fastest spec patch ever, measured from first speaking up here in the channel (or in the mailing list)

[14:31] <moritz_> people initially have the fear that when they touch the spec, TimToady++ will hit them with a hammer or something :-)

[14:31] <quotemstr> That's what the VCS is for. It's not as if I chiseled it into stone. :-)

[14:31] *** TiMBuS left
[14:32] <moritz_> aye. Still people are afraid.

[14:32] <PerlJam> moritz_: or maybe they are just mostly unsure of themselves.

[14:32] <moritz_> well, it is now chiseled into the stone of the gith history

[14:32] <quotemstr> "However, sometimes you would like an alternate scalar value to ride along with the match. The Match object itself describes a concrete parse tree, so this extra value is called an abstract object; it rides along as an attribute of the Match object."

[14:33] <quotemstr> Dammit, that was exactly the design I came up with for my own parser.

[14:33] <quotemstr> moritz_: Unless it's rebased.

[14:33] <moritz_> s/Dammit/Yay/

[14:33] <quotemstr> moritz_: True.

[14:33] <moritz_> quotemstr: but that requires a push --force, which is frowned upon

[14:33] *** kjeldahlw left
[14:33] <quotemstr> Except I imagined having multiple abstract values, each identified by a tag.

[14:34] <quotemstr> moritz_: So it's chiseled into stone so long as nobody minds too much. :-)

[14:34] <moritz_> just like you *can* erase text chiseled into stone, by removing the whole layer :-)

[14:35] <moritz_> quotemstr: having multiple abstract objects by tag is really isomorphic to having a hash of abstract objects

[14:35] *** jimmy1980 left
[14:35] <quotemstr> moritz_: Right, which is why it's not really a different idea.

[14:35] <quotemstr> As you said, isomorphic.

[14:36] <moritz_> I find that for many things a scalar as .ast is sufficient

[14:36] <moritz_> for example my json parser just returns the parsed literal as .ast

[14:36] <quotemstr> Can you do something like call/cc while matching a pattern so you can save intermediate matching state?

[14:37] <moritz_> I don't know call/cc, care to explain more?

[14:37] <TimToady> yes, this is $¢ which represents the current cursor

[14:37] <quotemstr> It's a Scheme concept --- continuations.

[14:38] <quotemstr> Essentially, my parser is implemented as a parsing machine (or fancy pushdown automaton, if you prefer) so that the state of the parser can be saved every so often.

[14:38] <TimToady> cursors are immutable match states, so you can resume at any cursor

[14:38] <TimToady> you backtrack merely by throwing away uninteresting cursors

[14:38] <quotemstr> That way, when we've parsed an Emacs buffer and the user changes something, we can resume parsing from the last known good position instead of having to start from the top again.

[14:38] <quotemstr> Ahh.

[14:39] <moritz_> see also the 'moreinput' method in STD.pm6

[14:39] *** plobsing joined
[14:39] <TimToady> well, that's just making the input lazy-able

[14:40] <moritz_> but that sounds exactly like what quotemstr wants to achieve

[14:40] <TimToady> but laziness is a similar concept

[14:40] *** benabik left
[14:40] <TimToady> you can't un-moreinput

[14:40] *** jimmy1980 joined
[14:41] <jnthn> .oO( lessinput )

[14:41] <moritz_> :-)

[14:41] <TimToady> likewise with a lazy list, you un-munch it only by keeping the ref to the head of the list

[14:42] <TimToady> list cursors are also readonly (in the abstract) for that reason, though of course an implmentation may cheat for performance

[14:42] <moritz_> anyway, time to call it a week. I'll commute, and leave the discussion to those who actually know what they are talking about :-)

[14:42] * TimToady looks around...

[14:42] <PerlJam> And this is why functional languages hate side-effects  ;)

[14:43] <TimToady> and it's why various P6 constructs promise that there aren't side effects, or that you don't care if there are :)

[14:44] <quotemstr> The proto regex facility is neat.

[14:47] <quotemstr> I think I'll skip the bottom-up parsing though.

[14:47] <TimToady> we don't do much of that, other than operator precedence

[14:48] <quotemstr> For practically anything an editor can do, operator precedence doesn't matter, and operator precedence seems to be the primary application of the bottom-up stuff.

[14:48] <quotemstr> Yeah.

[14:48] <TimToady> (for some fancy def of op prec)

[14:48] <quotemstr> The one issue I have with :: and ::> is safety though.

[14:48] <PerlJam> When your language is full of operators, operator precedence parsing becomes important :)

[14:49] <quotemstr> Say we have for-statement <- "for" :: { <statement-list> }, while-statement <- "while" :: { < statement-list> }

[14:49] <quotemstr> We can write | <foo-statement> <while-statement> and it works fine.

[14:50] <quotemstr> But what if, for some reason, we want to just match a while-statement?

[14:50] <quotemstr> That is, outside an alternation.

[14:50] <quotemstr> In that case, the :: is harmless.

[14:50] <quotemstr> But what if *that* rule is inside some unrelated alternation?

[14:50] <PerlJam> quotemstr: where's the harm there?

[14:51] <TimToady> PerlJam: basically, throwing an "exception" to the wrong handler

[14:51] <quotemstr> PerlJam: It might end the LTM part of the enclosing alternation unexpectedly.

[14:51] <sorear> quotemstr: exactly what you'd think would happen, will happen

[14:51] <sorear> quotemstr: so that definition of for-statement is not that nice

[14:51] <TimToady> in STD, I found myself terminating the longest token more often with {} rather than ::

[14:52] <sorear> quotemstr: I recommend only using :: if a) in a | in the rule b) in a multi regex c) if you know what you're doing

[14:52] <TimToady> so yes, :: needs to know it's context by convention at that point, in this design

[14:52] <PerlJam> Hmm.

[14:52] <sorear> quotemstr: have you played with niecza LTM yet?

[14:52] <quotemstr> So in that case, you'd split the definitions into while-prefix and while-guts, let's say.

[14:52] <quotemstr> sorear: Not yet. I'm just reading specs.

[14:53] *** jimmy1980 left
[14:54] <quotemstr> Also, correct me if I'm wrong, but LTM prefixes can't include rules with recursive portions (which would make the matched language non-regular), right?

[14:54] <TimToady> quotemstr: in general, :: is mostly used in rules that have a proto representing the alternation

[14:54] *** jimmy1980 joined
[14:54] <TimToady> so in that case, we know exactly where the alternation point is

[14:55] <quotemstr> TimToady: Fair enough. So they're legal elsewhere and just discouraged.

[14:55] <TimToady> quotemstr: the lexer generator will stop at a left recursion, since a DFA can't do that

[14:56] <TimToady> quotemstr: it would seem to fall in the category of "Doctor it hurts when I do this"

[14:57] <quotemstr> TimToady: I suppose I'm just concerned that an unrelated change in some distant part of a grammar can cause LTM prefix length to change and cause hard-to-debug spooky action at a distance.

[14:58] <PerlJam> TimToady: so what are some uses where there isn't a rule with a proto representing the alternation?

[14:58] <TimToady> :: is also useful in an alternation that is known because it's in the current rule

[14:58] * PerlJam is suffering a failure of imagination this morning

[14:59] <TimToady> quotemstr: we are very much not in favor of spooky action here, having learned our lesson with P5

[14:59] <PerlJam> TimToady: or what I'm going to ask eventually is ... why not some other declarational construct specifically for LTM such that :: and friends aren't needed as terminators?

[15:00] <quotemstr> TimToady: Right. I'm inclined to make non-declarative LTM prefixes compile errors and force users to use :: to split things up.

[15:01] <TimToady> but the Perl approach is to not force the user to think about things they don't want to think about, unless they want to, to the extent we can get away with it

[15:01] <TimToady> and I think we can get away with an implicit transition here most of the time

[15:02] <quotemstr> Fair enough. I think I'll go the other way in my parser though.

[15:02] <PerlJam> I guess in the small universe I just imagined explicit declared LTM would fill regex with <.start_ltm> and <.end_ltm> or some other markers anywya

[15:03] <TimToady> "Languages differ not in what you can say, but in what you *must* say."  --Roman Jakobson

[15:04] *** ronoreck left
[15:04] <TimToady> the experience with P6 grammars so far would indicate that this is not something worth forcing the user to say

[15:05] *** shi left
[15:06] <TimToady> we give programmers a language that they can learn "small end first"

[15:06] * quotemstr wonders whether captures can happen inside LTM prefixes.

[15:07] <PerlJam> TimToady: that just means that there aren't enough people using Perl 6 grammars to be surprised at the action-at-a-distance that they themselves have accidentally created  :)

[15:07] *** achref joined
[15:07] <TimToady> quotemstr: yes, they can; if necessary the dfa merely guides the choices of the nfa

[15:08] <achref> your site is down?

[15:08] <PerlJam> quotemstr: I would think captures are okay as long as there are no backrefs.   (but what do I know?)

[15:08] <TimToady> the dfa tells the nfa "Here is your fate."

[15:08] <achref> http://rakudo.org/how-to-get-rakudo

[15:08] <quotemstr> So you don't like Ville Laurikari's algorithm to automatically generate matches from the DFA?

[15:08] <TimToady> it allocated 17 MB on the stack for every token :(

[15:08] <PerlJam> achref: thanks.

[15:09] <TimToady> that didn't run so well...

[15:09] <quotemstr> PerlJam: You can do it, but it turns out that capturing with a DFA is non-trivial even for POSIX regular expressions, much less Perl 6 ones.

[15:09] <quotemstr> Right. Just running the DFA to figure out which NFA should be run seems like a simpler approach.

[15:10] <PerlJam> achref: try again.

[15:11] <TimToady> the original implementation STD actually determined the "fated" choices all the way down the recursive descent, but I think sorear++ is playing with redeciding via DFA at each choice point to see if it goes faster or slower

[15:11] <achref> ok fine

[15:12] *** ronoreck joined
[15:12] <quotemstr> TimToady: By "all the way down the recursive descent", do you mean matching each LTM alternative in its entirety, then re-parsing the chosen one?

[15:12] <TimToady> as long as the semantics are conserved, it doesn't matter which way we do it, so we'll go with whatever turns out more efficient

[15:12] <quotemstr> TimToady: Of course.

[15:13] <TimToady> a given left-most token may be recursively parsed down through several alternations before we "advance"

[15:13] <TimToady> the DFA can tell all of the alternations what they well decide in advance if we use the fuller fates model

[15:14] <TimToady> so the lower alternatives don't even have to think about LTM again

[15:14] <TimToady> since it's already implicit in the outer lexer's decisions

[15:14] *** kaare_ left
[15:15] *** kaare_ joined
[15:16] *** Patterner left
[15:17] <quotemstr> Right. That makes a lot of sense.

[15:17] <TimToady> we do always do the recursive descent parsing though

[15:18] *** Psyche^ joined
[15:18] *** Psyche^ is now known as Patterner

[15:18] <TimToady> though there might be ways of faking that too

[15:18] <quotemstr> TimToady: I can see why that approach might not always be a performance win though, especially for a small number of alternatives.

[15:18] <quotemstr> TimToady: Well, if there are no captures, faking it should be easy.

[15:18] *** tzhs left
[15:19] <TimToady> well, it's hard to return to some place that never existed :)

[15:19] <quotemstr> TimToady: For backtracking? You just return to the point before you even initialized the DFA, right?

[15:19] <TimToady> anyway, we try to nail down the semantics, and optimizers are free to cheat within those constraints

[15:19] <quotemstr> Right.

[15:19] <quotemstr> Same here.

[15:20] <TimToady> returning not for backtrack, but for success

[15:21] <TimToady> there may well be action methods associated with the higher nodes in the tree

[15:21] *** kaare_ left
[15:21] <quotemstr> Shouldn't \N exclude U+0085, U+2028, and U+2029 too?

[15:21] <TimToady> those have to be called as if we did the recursive descent, and are now ascending

[15:22] <quotemstr> TimToady: Ah, right.

[15:23] <TimToady> yes, \N is supposed to match a single character anywhere where \n doesn't

[15:23] <TimToady> and \n is logical newline, not a concrete char

[15:24] <quotemstr> Ah, good. I see that \n now matches the TR18 newlines.

[15:24] <TimToady> the intent is to track Unicode to the point where they go insane, and perhaps a little beyond that point :)

[15:24] <quotemstr> ". matches an anything, while \N matches an anything except newline. (The /s modifier is gone.) In particular, \N matches neither carriage return nor line feed." should be ". matches an anything, while \N matches an anything except what \n matches. (The /s modifier is gone.) In particular, \N matches neither carriage return nor line feed."

[15:25] <flussence_> «#      got: 'oxy()<0x8609b58>'␤# expected: ' quack'» .oO( this isn't going well... )

[15:26] <TimToady> quotemstr: that would be clearer

[15:26] <pmurias> sorear: hi

[15:27] <dalek> specs: e7cc2ec | (Daniel Colascione)++ | S05-regex.pod:

[15:27] <dalek> specs: Be more explicit about what \N does not match.

[15:27] <dalek> specs: review: https://github.com/perl6/specs/commit/e7cc2ecfb2

[15:31] <sorear> pmurias: hi

[15:32] <pmurias> sorear: i'm thinking of working on niecza during gsoc, what would be a good task?

[15:33] *** MayDaniel joined
[15:34] * TimToady ablutes &

[15:38] <[Coke]> .d ablute

[15:44] <quotemstr> [Coke]: IME, "ablution" is more common.

[15:44] <flussence_> argh, I've screwed this indent thing up completely

[15:45] <quotemstr> S05 contains a lot of forward references, which makes it hard to read.

[15:48] <moritz_> quotemstr: it contains enough information that I needed multiple passes (more than 2) anyway

[15:48] *** dual left
[15:49] <moritz_> and I think I still haven't grokked it all

[15:51] <moritz_> still, more readable would be better

[15:51] <quotemstr> I think I'll prefer to have exactly one kind of "aliasing", the explicit named capturing kind.

[15:54] *** cotto left
[15:56] *** madalu joined
[15:59] <quotemstr> Hrm.

[15:59] <quotemstr> Say we have regex a b c (|| x y z)) d e f

[15:59] <quotemstr> We match the first three tokens normally, then hit the alternation.

[16:00] <quotemstr> (Assume backtracking is on.) The alternation has to try x d e f, then y d e f, then z d e f, then fail.

[16:00] <quotemstr> Also assume we're using the NFA matcher.

[16:00] <quotemstr> How does the current implementation communicate to the alternation what the remainder of the pattern is supposed to be?

[16:01] <quotemstr> Do we just model the sequence as a series of explicit states and let the alternation know what the next state ought to be?

[16:01] *** woosley left
[16:02] *** achref left
[16:02] <moritz_> quotemstr: your regex is just the same as regex { a b c x y z d e f }

[16:02] <moritz_> an alternative with a single branch is a no-op

[16:03] <moritz_> and the leading empty branch is ignored

[16:03] <quotemstr> moritz_: Err, I typed that wrong. The alternative is supposed to have three branches.

[16:03] <moritz_> so regex { abc (x || y || z) def } ?

[16:03] <quotemstr> Yes.

[16:03] <quotemstr> Brain was still in Lisp mode.

[16:04] *** jfried joined
[16:04] <moritz_> the (x || y || z) is just compiled to a routine that returns a lazy list of three cursors

[16:04] <quotemstr> Essentially, when backtracking happens, where is the backtracking *state* stored?

[16:05] <quotemstr> When you backtrack to position P, you also need to restore all the state for that P except the bit that modifies the path taken.

[16:05] <quotemstr> And the cursor object includes all that state?

[16:06] <moritz_> I think the cursors just stores an integer position, and a reference to the string being matched

[16:07] <moritz_> nested backtracking is done by constructing a lazy tree from the lazy lists

[16:07] <quotemstr> The cursor would have to include information about which branch to take.

[16:07] <moritz_> btw your example isn't the best, since (x || y || z) never backtracks, because something that matches 'x' can't match 'y'

[16:08] <quotemstr> You get the idea.

[16:08] <moritz_> just sayin'

[16:08] <moritz_> well, the cursor needs to include the information which branch it took

[16:08] *** mberends left
[16:08] <sorear> most serious implementations use a choice-point stack

[16:09] <sorear> "a" is compiled to backtrack() unless @chars[$pos++] eq 'a'

[16:10] <sorear> sub backtrack() { $pos = @save-pos.pop; goto @save-label.pop }

[16:11] <sorear> [x || y] -> save(O); code_for_x(); goto E; O: code_for_y(); E:

[16:12] <quotemstr> I should read about how choice point stacks work.

[16:13] <flussence_> my $?TABSTOP = 8; my @ws = ((' ' Xx 0..$?TABSTOP-1) X~ "\t"); [==] @ws».indent(-4);    # I can't decide what happens with leading space+tab and the spec doesn't help. Any ideas?

[16:14] <sorear> quotemstr: start here: http://mitpress.mit.edu/sicp/full-text/sicp/book/node89.html

[16:14] <sorear> niecza: my $?TABSTOP = 8;

[16:14] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variables with the ? twigil cannot be declared using my; they are created using 'constant'. at /tmp/kkt6QyORCF line 1:␤------> [32mmy $?TABSTOP [33m⏏[31m= 8;[0m␤␤Unhandled exception: Check failed␤␤  at

[16:14] <p6eval> ../home/p6eval/niecza/boot/lib/CORE.setting li…

[16:15] <flussence_> rakudo: constant $?TABSTOP = 8;

[16:15] <p6eval> rakudo 792e86: OUTPUT«===SORRY!===␤Constant type declarator not yet implemented at line 22, near "= 8;"␤»

[16:15] <flussence_> :(

[16:15] *** hudnix left
[16:16] *** hudnix joined
[16:17] <sorear> niecza: constant $?TABSTOP = 2; sub foo() { say caller.hints('$?TABSTOP'); }; sub bar(&f) { constant $?TABSTOP = 9; f(); }; bar(&foo);

[16:17] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«9␤»

[16:18] *** kaare_ joined
[16:23] <TimToady> supposedly CALLER::<$?TABSTOP> should give you the same thing

[16:24] <sorear> I still haven't formed a complete mental model of how pseudo-packages work

[16:24] *** hudnix left
[16:26] *** takadonet joined
[16:26] <sorear> niecza seems to think the contents of CORE.setting are "Bool::False"

[16:26] <sorear> wtf...

[16:27] *** takadonet left
[16:27] *** takadonet joined
[16:28] <sorear> oh...

[16:29] <sorear> my ($path, $time, $contents) = (~$p.realpath, $p.modified.to-posix, $p.slurp)

[16:30] *** sftp joined
[16:30] *** hudnix joined
[16:31] <dalek> niecza: 7a937de | sorear++ | src/NieczaPathSearch.pm6:

[16:31] <dalek> niecza: [compiler] Be tolerant of .to-posix returning a list now

[16:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7a937de295

[16:37] *** madalu left
[16:41] *** MayDaniel left
[16:42] <quotemstr> sorear: Thanks.

[16:43] <quotemstr> sorear: My idea was for each parser-function to provide two closures to the "next" parser, on-success and on-failure.

[16:43] <quotemstr> sorear: Essentially using functions as automaton states.

[16:46] <quotemstr> sorear: The nice thing about that approach is that you can unwind state changes on both paths, and admits the optimizing of using the parent's on-failure closure directly if there's no additional work to be done.

[16:46] <quotemstr> sorear: It's a spaghetti stack, essentially. Is that equivalent to a choice-point stack?

[16:50] <sorear> quotemstr: something like that can probably be made to work, but mind performance

[16:51] <sorear> quotemstr: it's possible to handle unwinding state changes in the choice point model; imagine [ stuff || { restore; } <!> ]

[16:51] <sorear> if stuff backtracks, then restore; will be called and the whole block will backtrack

[16:53] *** plobsing left
[16:54] <sorear> quotemstr: also, whatever you decide to implement, S05 requires that regex methods communicate using lazy lists

[16:55] <quotemstr> sorear: Ah, good point.

[16:56] <quotemstr> sorear: Also, is there anything wrong with thinking of repetition as simply temporal alternation starting with an infinite number of copies, then on backtrack, nr_success - 1, nr_success - 2, ... 0 copies ?

[16:56] <sorear> quotemstr: yes; counting down from infinity takes a while

[16:57] <quotemstr> Well, how else can you get a*a to match successfully?

[16:57] <sorear> well, start from "as many as possible"

[16:57] <sorear> but it's still subtly wrong

[16:58] <quotemstr> The first time through, we match as many times as we can and remember how many times we backtrack.

[16:58] <quotemstr> The next time throught (on the next choice point, as it were), we subtract one from that value and try to match that many times.

[16:58] <quotemstr> sorear: Thanks for the help, by the way.

[16:58] *** mtk left
[16:59] <sorear> niecza: "aaa" ~~ /^ [ [a||a]**3 || [a||a]**2 || [a||a]**1 || <?> ] { say $¢.pos } <!> /;

[16:59] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«1␤1␤1␤1␤1␤1␤0␤»

[16:59] <sorear> hrm

[17:00] <sorear> niecza: "aaa" ~~ /^ [a||a]**3 { say $¢.pos } <!> /;

[17:00] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«1␤1␤»

[17:02] <sorear> niecza: "aaa" ~~ /^ a**3 { say $¢.pos } <!> /;

[17:02] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«1␤»

[17:02] <quotemstr> Ah.

[17:02] * quotemstr scratches his head.

[17:02] <sorear> don't; I'm trying to get my example to work

[17:03] *** plobsing joined
[17:03] <quotemstr> Shouldn't the backtracking always be *inside* the inner group [a||a]?

[17:03] <quotemstr> And shouldn't the first branch always be taken in that case?

[17:03] *** noganex_ is now known as noganex

[17:04] <sorear> niecza: "aaa" ~~ /^ [ [a||a]**3..3 || [a||a]**2..2 || [a||a] || <?> ] { say $¢.pos } <!> /;

[17:04] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«3␤3␤2␤1␤2␤2␤1␤1␤1␤0␤»

[17:05] *** mj41 left
[17:05] <sorear> looks like ** is pretty broken

[17:05] <sorear> niecza: "aaa" ~~ /^ [ [a||a][a||a][a||a] || [a||a][a||a] || [a||a] || <?> ] { say $¢.pos } <!> /;

[17:05] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«3␤3␤3␤3␤3␤3␤3␤3␤2␤2␤2␤2␤1␤1␤0␤»

[17:05] <sorear> this is what you get if you implement repetition like you just suggested

[17:06] <sorear> but it's wrong

[17:06] <sorear> niecza: "aaa" ~~ /^ [a||a]* { say $¢.pos } <!> /;

[17:06] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«3␤3␤2␤3␤3␤2␤1␤3␤3␤2␤3␤3␤2␤1␤0␤»

[17:06] <quotemstr> Is that so?

[17:06] <quotemstr> Ahh.

[17:07] <quotemstr> And the exact ordering of the calls to that action is defined, I imagine.

[17:07] <quotemstr> (Unlike a semantic predicate.)

[17:07] <sorear> well, it makes a big difference if you have cuts

[17:08] <sorear> TimToady can probably say why it's critical that it be defined this way

[17:08] <sorear> niecza: my regex x { a { make 1 } || b { make 2 } }; "aaa" ~~ /^ <x=&x>* { say map *.ast, @$<x> } <!> /

[17:09] <p6eval> niecza v3-80-g3cc93a7: OUTPUT«Unhandled exception: Unable to resolve method ast in class Any␤  at /tmp/t3UHl1RzW7 line 1 (MAIN C6_ANON @ 1)␤  at  line 0 (KERNEL map @ 2)␤  at /tmp/t3UHl1RzW7 line 1 (MAIN C5_ANON @ 2)␤  at /tmp/t3UHl1RzW7 line 1 (MAIN C4_ANON @ 5)␤  at

[17:09] <p6eval> ../home/p6eval/niecza/lib/CORE.setting line 1…

[17:09] *** TTL joined
[17:10] *** TTL left
[17:11] <quotemstr> sorear: Still trying to wrap my head around how that actually works.

[17:12] <quotemstr> sorear: The first time through the [a||a]* version, we match [a||a]* successfully three times, output 3, and fail. Why do we back up only one position the next time?

[17:12] <quotemstr> Oh.

[17:12] <quotemstr> I see.

[17:12] <moritz_> because there are two ways to match 'a'

[17:12] <sorear> a* = [ a a* || <?> ]

[17:13] <quotemstr> Because the most recent choice point was the one created by [a||a].

[17:13] <quotemstr> And only if *that* fails do we backtrack to the previous choice point.

[17:13] <quotemstr> Hrm. What

[17:13] <moritz_> if you name them a1 and a2

[17:13] *** plobsing left
[17:13] <moritz_> first you match a1 a1 a1

[17:13] <quotemstr> 's the best Perl 6 implementation I can play with, and where should I get it?

[17:13] <moritz_> then a1 a1 a2

[17:14] <moritz_> then a1 a2 a1, then a1 a2 a2 etc.

[17:14] <quotemstr> Right. Then a1 a2 a1, then a1 a2 a2, etc.

[17:14] <moritz_> quotemstr: niecza is leading in terms of regexes

[17:14] <quotemstr> Okay, that makes sense.

[17:14] <moritz_> http://github.com/sorear/niecza

[17:15] <moritz_> clone it, the README has installation instructions

[17:15] <quotemstr> I actually wonder whether the code could just be transliterated. Perl 6 and Emacs are license-compatible.

[17:15] <quotemstr> Thanks.

[17:15] <moritz_> well, niecza targests .NET/mono

[17:16] <moritz_> if you want your emacs stuff to emit CLR code, go ahead and transliterate :-)

[17:16] <quotemstr> moritz_: Sure, but it'd be the algorithms and data structures. Not a single character of the code would literally survive.

[17:16] <quotemstr> (That kind of construct-for-construct transliteration still triggers copyright though.)

[17:19] <sorear> quotemstr: what are you trying to port?

[17:20] <quotemstr> sorear: The rules engine.

[17:20] <quotemstr> I'm just surprised and pleased that my thinking was leading toward something very much like it.

[17:20] <sorear> Which rules engine?

[17:21] *** hercynium joined
[17:22] <quotemstr> Actually, I had it backwards: *my* solution would match a1 a1 a1, a1 a1 a2, a1 a2 a1, etc. What Perl 6 does above is backtrack one step in the repetition without trying any inner alternatives.

[17:23] <quotemstr> sorear: The piece of code that generates parsers for the new Perl 6 "regular" expressions.

[17:23] <sorear> quotemstr: oh, you're trying to port it *to* Emacs?

[17:23] <quotemstr> sorear: Yes.

[17:25] <moritz_> alternative route: write a emacs-lisp backend for niecza, bootstrap niecza and leave it as Perl 6 code :-)

[17:25] <quotemstr> I'm not going to require niecza to regenerate grammars though, since the goal is for them to be user-customizable in a way they aren't today.

[17:26] <quotemstr> Say you're using a weird dialect of C at work that requires _In_ or _Out_ before each parameter type in a function declaration's argument list.

[17:26] <quotemstr> With the current C support, you're out of luck because the grammar is essentially hardcoded into the mode implementation. This is an effort to provide more extensibility by just plugging new syntax into ~/.emacs.

[17:27] <quotemstr> Requiring niecza in order to make these changes would hurt adoption at the very least, unfortunately, so I'd like this facility to be pure elisp.

[17:27] <quotemstr> Nice idea though. :-)

[17:32] *** donri left
[17:35] <quotemstr> Ah, that's a shame.

[17:37] <quotemstr> Ah, the Artistic 2.0 license *is* GPLv[23]-compatible.

[17:46] *** dual joined
[17:50] *** plobsing joined
[17:52] *** ymasory joined
[17:52] *** ymasory left
[17:55] *** dakkar left
[18:09] *** spq joined
[18:10] *** dsp_ left
[18:13] *** envi left
[18:15] <Juerd> More feather rebooting. Sorry.

[18:15] *** Juerd left
[18:19] *** tadzik left
[18:19] *** hugme left
[18:19] *** PerlJam left
[18:19] *** Util left
[18:19] *** hugme joined
[18:19] *** ChanServ sets mode: +v hugme

[18:20] *** leprevost left
[18:21] *** Chillance joined
[18:21] *** Juerd joined
[18:22] *** madalu joined
[18:26] *** stkowski joined
[18:27] *** dsp_ joined
[18:35] *** tadzik joined
[18:46] *** wallberg joined
[18:49] *** MayDaniel joined
[18:49] *** MayDaniel left
[18:49] *** MayDaniel joined
[18:55] *** jferrero joined
[18:57] *** fhelmberger left
[19:05] *** donri joined
[19:07] *** Mowah left
[19:10] *** Mowah joined
[19:13] <pmurias> quotemstr: there exists a start of a common lisp backend for niecza, i could expand it if you are willing to port it over to emacs lisp ;)

[19:15] *** risou joined
[19:16] <quotemstr> pmurias: I just saw that, actually.

[19:16] <quotemstr> While that looks good, it'd still equire the niecza engine at grammar-compilation time and so wouldn't suit my purposes.

[19:16] <quotemstr> Thanks anyway though.

[19:16] *** awoodland joined
[19:18] <pmurias> quotemstr: if we expand it enough we could bootstrap niecza with it (so instead of in .net the engine itself will be in emacs lisp)

[19:18] <pmurias> but it's not the simplest way of achieving what you want

[19:19] *** plainhao left
[19:19] <quotemstr> Yeah. It's a neat idea though.

[19:19] <quotemstr> Besides, elisp lacks some features of CL (like packages and lexical closures) that might increase the cost of such a port.

[19:20] <sorear> pmurias: (gsoc) I don't have 3 months of good plans, myself

[19:20] <Juerd> Another reboot coming up. I hope it's the last.

[19:20] *** Juerd left
[19:20] *** tadzik left
[19:21] <sorear> "multiple dispatch", "BEGIN", "make yapsi work", "make Web.pm work", "JVM port"

[19:21] <sorear> all of those are 2-4 week projects, or more if I try to do them while classes are in session

[19:22] *** Juerd joined
[19:22] <sorear> yapsi is probably closer to 1-2, although it depends on MMD working first

[19:23] *** hugme left
[19:24] *** risou left
[19:25] <pmurias> JVM port looks like a more length thing

[19:27] *** risou joined
[19:27] *** snearch joined
[19:27] <pmurias> * lengthy

[19:27] *** MayDaniel left
[19:28] <dalek> niecza: 1dc43eb | sorear++ | docs/announce.v4:

[19:28] <dalek> niecza: Draft v4 release announcement

[19:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1dc43eba1e

[19:31] <sorear> except that the JVM and CLR are already quite close

[19:31] <pmurias> so it would be a rather boring port over the differences thing?

[19:31] <sorear> yes

[19:31] <sorear> the bytecode emitter would need significant refactoring but little actual redesign

[19:32] <sorear> a niecza-JVM port might be even easier than 6model/JVM because niecza avoids using delegates

[19:32] <pmurias> do you plan to take part in gsoc this year?

[19:33] <sorear> I haven't decided yet - with my current course load I find it hard to think about another long-term thing

[19:35] <pmurias> one thing which seems interesting would be to port over hoopl and write an optimiser using it

[19:36] <pmurias> the hoopl library allows combining simple optimalisation pass together

[19:37] <pmurias> so one could write container elimination, simple type inference and constant folding and have it combined into a single pass that does all of that

[19:39] <pmurias> hoopl is used by ghc so the approach was proved in production

[19:40] <pmurias> sorear: what do you think about that?

[19:41] *** ymasory joined
[19:41] *** dolmen left
[19:42] *** masak joined
[19:43] <masak> good evening, zebras!

[19:43] <moritz_> \o

[19:43] <flussence_> masak!

[19:43] * masak has a good feeling about announcing the p6cc winner tonight

[19:44] *** zby_home joined
[19:46] <flussence_> I'm stuck on a thing. What should .indent(3) and .indent(-3) output for " \t \t "? (it's not as obvious as it looks...)

[19:46] * masak thinks

[19:47] <masak> hm, it's a line with only whitespace?

[19:47] <masak> and it's mixed, so the rule of mixed whitespace kicks in...

[19:48] <[Coke]> what rule about mixed whitespace?

[19:48] <masak> I'd say add $*TABSTOP spaces to the end of the string in the first case, and explode the second \t into $*TABSTOP-2 spaces in the second case.

[19:48] <masak> [Coke]: it's all in the .indent spec in S32/Str.

[19:49] <[Coke]> masak: and the word "mixed" isn't used there at all.

[19:49] <flussence_> [Coke]: ^\t removes indent from the right-hand-side so that it ends up as ^\t if possible. Everything else goes from the left.

[19:49] *** tadzik joined
[19:50] <flussence_> (oh whoops, I asked the wrong question there. indent(3) is easy stuff)

[19:51] <pmurias> masak: who one the overall contest?

[19:51] <pmurias> s/one/won/

[19:52] <tadzik> try.rakudo.org is broken

[19:52] <flussence_> I wasn't sure whether outdenting should've done a visual-whitespace outdent, but thinking about it that seems impossibly hard to do well

[19:52] <flussence_> tadzik: gimme 30 seconds

[19:52] *** madalu left
[19:53] <flussence_> fixed!

[19:53] <[Coke]> I would expect .indent(3) to return "    \t \t " and .indent(-3), assuming a TABSTOP of 4, to return "   \t "

[19:53] <[Coke]> I'm not sure why masak is saying it should touch the /end/ of the string.

[19:54] <tadzik> flussence_: thanks

[19:54] <flussence_> (I really need to figure out a way of starting that in screen on boot that actually works...)

[19:55] <sorear> pmurias: curious but dubious

[20:02] <pmurias> sorear: what's dubious about that?

[20:03] <quotemstr> Is the only difference between <commit> and <cut> that the latter has the side effect of modifying the sequence being matched?

[20:04] <sorear> quotemstr: I beleive so

[20:07] <sorear> pmurias: applicability to niecza

[20:11] <masak> pmurias: I'm planning to announce that tonight.

[20:12] <masak> [Coke]: I think I arrived at operating on the end of the whitespace prefix being the only sensible option. probably exactly because of the conceptual difficulties flussence_ seems to be having right now.

[20:12] <masak> [Coke]: sadly, it never made it into the spec. probably should.

[20:14] <masak> [Coke]: basically, the reason to operate on the end of the whitespace prefix is that tab characters jiggle around their widths when one puts spaces before them. and that's not how you'd want an .indent function to work.

[20:14] *** pjcj left
[20:17] <[Coke]> ok. please don't refer me to the spec and then say not to use it. ;)

[20:19] <sorear> the spec .indent was never designed for use with mixed tabs/spaces

[20:20] <[Coke]> then why does it explicitly try to cover it with TABSTOP?

[20:20] <masak> sorear: what makes you say that? I wrote that part, and I thought of the mixed case.

[20:21] <masak> specifically "[added spaces] will be either (1) consistent with subsequent leading whitespace already on the line, if these are all the same, or (2) spaces"

[20:21] <masak> the (2) denotes the mixed case.

[20:22] <sorear> masak: I say that because I wrote it.  If you've changed it since then... I can't contribute usefully.

[20:23] * masak , confused, does a git blame

[20:23] <flussence_> AIUI, for /^(\s) (\s*) (.*)/, if $0 is a \t, the in/outdent happens at the end of $1, otherwise it's at the beginning of the string

[20:23] <flussence_> with the general aim of not screwing up someone's existing tab-indent

[20:24] <masak> sorear: I haven't changed it since then. the only commits on the .indent spec are two commits on the same day, and they're the original ones.

[20:25] <masak> flussence_: hm, what's situation where acting at the end of $1 results in something surprising/less than good?

[20:25] <flussence_> nothing I've come across...

[20:26] <masak> I suggest we spec and implement for it to act at the end of $1 always, for consistency.

[20:26] <pmurias> sorear: why do you think it's not applicable?

[20:26] *** Util joined
[20:27] <masak> flussence_: it seems to me there's either no way to tell the difference between it acting on the beginning of the whitespace prefix or the end, or there are tabs involved and then it matters that it's at the end.

[20:27] <pmurias> Perl 6 does not give us enough info to work with? trading compile time for runtime performance is not worth it?

[20:27] <masak> quotemstr: I think so.

[20:27] <pmurias> ghc uses it's for an imperative intermediate language so it's not a functional programming thing

[20:27] <pmurias> s/it's/it/

[20:28] <flussence_> I think that's a better way to go. All my code for doing stuff at that end passes tests already :)

[20:28] <masak> flussence_++

[20:28] <masak> how about I change the spec a little? try to reduce some confusion rather than change the actual semantics...

[20:30] *** hudnix left
[20:30] <masak> sorear: if by "I wrote it" you mean "I implemented .indent in Niecza", I'm less confused than if you meant "I wrote the specification on .indent" ;)

[20:31] <sorear> masak: I either wrote the specification, or wrote the implementation it was based on

[20:31] <sorear> either way, it predates niecza

[20:31] <masak> sorear: git blame says 'masak' on the spec. I don't remember basing that text on any implementation.

[20:32] <sorear> odd

[20:32] <masak> but yes, 2010-06-03 probably predates niecza.

[20:32] *** Hackbinary left
[20:33] <masak> the .indent method was born because pmichaud++ felt it might be a good idea to expose as a method the behavior that was implicit in heredoc outdenting.

[20:33] <masak> that's what .indent(*) does.

[20:33] *** Mowah left
[20:33] <sorear> pmurias: it doesn't seem very suitable for a Perl implementation

[20:34] <sorear> masak: my recollection is that it was born as an implementation factor of the viv -5 pretty printer that we (me and TimToady) decided was general enough that it ought to be made trivial

[20:34] <sorear> I wonder what I'm thinking of

[20:34] <masak> me too. :)

[20:35] *** jfried left
[20:35] <masak> could be there's a slight parallel universe bleedover in this part of the continuum.

[20:35] <masak> er. I mean.

[20:36] <masak> might've been there was an .indent method before I wrote it into the spec, but I'm pretty sure I wasn't aware of it at the time.

[20:38] *** frettled joined
[20:38] <masak> frettled! \o/

[20:38] <frettled> o/

[20:48] *** dsp_ left
[20:49] *** dsp_ joined
[20:51] *** pjcj joined
[20:52] <pmurias> sorear: what aspect of Perl do you think makes it unsuitable?

[20:53] <pmurias> sorear: i see it very usefull with removing a lot of the overhead

[20:53] <dalek> specs: dbfdabb | masak++ | S32-setting-library/Str.pod:

[20:53] <dalek> specs: [S32/Str] rewrote .indent description

[20:53] <dalek> specs: 

[20:53] <dalek> specs: Explained that indentation is in fact added at the end of the whitespace

[20:53] <dalek> specs: prefix, not at the beginning. (This is in order to make tab characters

[20:53] <dalek> specs: act sanely.)

[20:53] <dalek> specs: 

[20:53] <dalek> specs: Rewrote other parts, but they should be identical in meaning, just

[20:53] <dalek> specs: (hopefully) clearer.

[20:53] <dalek> specs: review: https://github.com/perl6/specs/commit/dbfdabb956

[20:54] <sorear> pmurias: dynamic types and lack of optimization for purely-functional code

[20:54] <pmurias> sorear: as we need to optimise out multimethods or otherwise numerics will be horribly slow

[20:54] <masak> rakudo: my @foo := 1..3, @foo; .say for @foo[^10]

[20:54] <p6eval> rakudo 792e86: OUTPUT«1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤»

[20:55] <masak> this is what I expect.

[20:55] <pmurias> sorear: explain what you mean by the second thing?

[20:55] <masak> rakudo: my @foo := 1..3, (@foo Z+ 100); .say for @foo[^10]

[20:55] <p6eval> rakudo 792e86: OUTPUT«1␤2␤3␤101␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[20:55] <masak> that... is not.

[20:55] <masak> can we rely on array binding of the above kind to work?

[20:55] <masak> if yes, is the second eval an expression of a rakudobug?

[20:56] <masak> if no, how are we supposed to explain that some cases work and some not? :/

[20:56] <sorear> masak: I beleive so on both counts

[20:56] * masak submits rakudobug

[20:57] <sorear> I expect "1 2 3 Any() Any() ..." for both of them

[20:57] <masak> flussence_: please let me know if the above spec change was an improvement :)

[20:57] <masak> sorear: ok.

[20:57] <flussence_> reading it now

[20:57] <sorear> AIUI, looping like that is specifically a hyperoperator feature

[20:58] <masak> sorear: does "1 2 3 Any() Any() ..." have support in the spec over "1 2 3 1 2 3 ..."?

[20:58] <flussence_> masak++ # that looks a lot better

[20:58] <sorear> pmurias: I have an agenda for numerics already which does not involve type inference

[20:58] <masak> \o/

[20:59] <sorear> pmurias: I think type inference for numerics is a dead end, but I can't explain why well enough to convince anyone else

[20:59] *** Juerd left
[20:59] *** Juerd joined
[21:00] <masak> that sounds interesting. jnthn, as far as I know, is going down the type inference road for the common operators.

[21:01] <masak> so there should be some empiric data on that soonish.

[21:01] <pmurias> sorear: what's your agenda?

[21:01] <sorear> masak: S03:4165 says that >>+<< will repeat anything, including simple scalars and Parcels, so repetition as a .. feature is... odd

[21:02] <pmurias> m

[21:02] <masak> sorear: it's not an infix:<..> feature, just a feature of infix:<:=> (if it is indeed a feature at all).

[21:02] <flussence_> rakudo: my @foo := @foo; say @foo.perl;

[21:03] <p6eval> rakudo 792e86: OUTPUT«(timeout)»

[21:03] <masak> known bug.

[21:03] <flussence_> rakudo: my @foo := @foo; say @foo[^2];

[21:03] <p6eval> rakudo 792e86:  ( no output )

[21:03] <masak> luckily, binding something to itself should be a no-op, so you don't need to do it often in real code. :)

[21:03] <sorear> masak: := is defined principally by its lack of magic; for it to do something like that is ... very wrong

[21:03] <masak> sorear: understood.

[21:04] <masak> sorear: but then again, I think binding individual array elements or hash keys is sufficiently magical.

[21:04] <sorear> also parameter binding is (iirc) defined as being the same as :=

[21:04] <masak> aye.

[21:04] <masak> good point.

[21:04] <moritz_> ::= by default

[21:04] <sorear> sub foo(@bar) { .say for @bar }; foo(1..3) # WTF why does this infiniloop

[21:05] <moritz_> perl6: sub foo(@bar) { .say for @bar }; foo(1..3)

[21:05] <p6eval> pugs, rakudo 792e86, niecza v3-82-g1dc43eb: OUTPUT«1␤2␤3␤»

[21:05] <masak> \o/

[21:05] <masak> sorear: why would it loop infinitely? I don't follow.

[21:05] <masak> it's not the same situation. in the parameter binding, @bar does not occur in the "RHS".

[21:05] <sorear> masak: because it means the same as my @bar ::= 1..3; .say for @bar;

[21:06] <masak> right, and that's a *finite* list.

[21:06] <masak> finite and non-self-referent.

[21:07] <sorear> masak: ignore everything I've said in the last 12 minutes; I misread your example as my @foo := 1..3; @foo; .say for @foo[^10]

[21:07] <masak> ah :)

[21:07] <sorear> and I was WTFing at the rakudoinsanity

[21:07] <masak> :P

[21:07] * masak adds that to the rakudobug

[21:08] <sorear> re-reading, the Rakudo behavior is probably correct

[21:09] <masak> for both evals?

[21:09] <masak> the second one has be confuddled.

[21:10] *** Rotwang joined
[21:10] <sorear> rakudo: say (1,2,3 Z+ 5)

[21:10] <p6eval> rakudo 792e86: OUTPUT«6␤»

[21:10] <sorear> Z+ truncates to the length of the shorter list.

[21:10] <sorear> rakudo: say (1,2,3 »+» 5) # You may have wanted this, instead.

[21:10] <p6eval> rakudo 792e86: OUTPUT«128␤»

[21:11] <sorear> rakudo: say ((1,2,3) »+» 5) # You may have wanted this, instead.

[21:11] <p6eval> rakudo 792e86: OUTPUT«678␤»

[21:11] <flussence_> rakudo: say (1,2,3 X+ 5)

[21:11] <p6eval> rakudo 792e86: OUTPUT«678␤»

[21:11] <masak> ah, yes.

[21:12] <masak> rakudo: my @foo := 1, 2, 3, (@foo »+» 100); .say for @foo[^10]

[21:12] <p6eval> rakudo 792e86: OUTPUT«1␤2␤3␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:12] <masak> hm.

[21:12] <sorear> »+» is explicitly not lazy

[21:12] <sorear> X+ is better

[21:12] *** PerlJam joined
[21:12] <masak> rakudo: my @foo := 1, 2, 3, (@foo X+ 100); .say for @foo[^10]

[21:12] <p6eval> rakudo 792e86: OUTPUT«1␤2␤3␤101␤102␤103␤201␤202␤203␤301␤»

[21:12] <masak> \o/

[21:13] <masak> that is so cool.

[21:14] <masak> unfortunately, X+ can't be used to define @fib.

[21:14] <sorear> Z+ can

[21:14] <pmurias> sorear: what would convince you that (partial) type inference is feasible? short of a working implementation?

[21:14] <masak> rakudo: my @fib = 1, 1, (@fib Z+ @fib[1..*]); .say for @fib[^20]

[21:14] <sorear> @foo X+ 100 is like @foo Z+ (100 xx *)

[21:14] <p6eval> rakudo 792e86: OUTPUT«(timeout)»

[21:14] <masak> :/

[21:15] <masak> rakudo: my @fib = 1, 1, (@fib Z+ @fib[1..20]); .say for @fib[^20]

[21:15] <p6eval> rakudo 792e86: OUTPUT«1␤1␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:15] *** risou left
[21:15] <masak> bleh.

[21:15] <sorear> masak: I think @fib[1..*] is trying to calculate the length of the Fibonacci sequence

[21:15] <masak> I don't see why, but I think so too.

[21:15] <sorear> masak: the list iteration is lazy, but @fib[1..20] is just a term, it's evaluated immediately

[21:16] <masak> rakudo: my @fib = 1, 1, (@fib Z+ @fib[1...20]); .say for @fib[^20]

[21:16] <p6eval> rakudo 792e86: OUTPUT«1␤1␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:16] <sorear> rakudo: my @fib = 1, 1, gather { .take for (@fib Z+ @fib[1..20]) }; .say for @fib[^20]

[21:16] <p6eval> rakudo 792e86: OUTPUT«1␤1␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:16] <sorear> rakudo: my @fib = 1, 1, gather { take $_ for (@fib Z+ @fib[1..20]) }; .say for @fib[^20]

[21:16] <p6eval> rakudo 792e86: OUTPUT«1␤1␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:17] <sorear> rakudo: my @fib = 1, 1, ((1, @fib) Z+ @fib); .say for @fib[^20]

[21:17] <p6eval> rakudo 792e86: OUTPUT«1␤1␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[21:17] <sorear> rakudo: my @fib := 1, 1, ((1, @fib) Z+ @fib); .say for @fib[^20]

[21:17] <masak> rakudo: my @fib = 1, 1, gather { take @fib[$_] + @fib[$_ + 1] for 0..Inf }; .say for @fib[^20]

[21:18] <p6eval> rakudo 792e86: OUTPUT«1␤1␤2␤2␤3␤4␤5␤7␤9␤12␤16␤21␤28␤37␤49␤65␤86␤114␤151␤200␤»

[21:18] <p6eval> rakudo 792e86: OUTPUT«(timeout)initialized value in numeric context  in <anon> at line 22:/tmp/0JnwZFJQH8␤Use of uninitialized value in numeric context  in <anon> at line 22:/tmp/0JnwZFJQH8␤Use of uninitialized value in numeric context  in <anon> at line 22:/tmp/0JnwZFJQH8␤Use of uninitialized

[21:18] <p6eval> ..value in …

[21:18] *** cxreg2 joined
[21:18] <masak> rakudo: my @fib := 1, 1, gather { take @fib[$_] + @fib[$_ + 1] for 0..Inf }; .say for @fib[^20]

[21:18] *** d4l3k_ joined
[21:18] <p6eval> rakudo 792e86: OUTPUT«1␤1␤2␤3␤5␤8␤13␤21␤34␤55␤89␤144␤233␤377␤610␤987␤1597␤2584␤4181␤6765␤»

[21:18] *** y3llow_ joined
[21:18] <masak> \o/

[21:19] <masak> rakudo: my @fib := 1, 1, gather (take @fib[$_] + @fib[$_ + 1] for 0..Inf); .say for @fib[^20]

[21:19] *** frettled_ joined
[21:19] <p6eval> rakudo 792e86: OUTPUT«1␤1␤2␤3␤5␤8␤13␤21␤34␤55␤89␤144␤233␤377␤610␤987␤1597␤2584␤4181␤6765␤»

[21:19] *** snearch left
[21:20] *** frettled left
[21:20] <masak> rakudo: my @fib := 1, 1, map { @fib[$_] + @fib[$_ + 1] }, 0..Inf; .say for @fib[^20]

[21:20] *** y3llow_ is now known as y3llow

[21:20] *** d4l3k_ is now known as dalek

[21:20] *** ChanServ sets mode: +v dalek

[21:20] <p6eval> rakudo 792e86: OUTPUT«1␤1␤2␤3␤5␤8␤13␤21␤34␤55␤89␤144␤233␤377␤610␤987␤1597␤2584␤4181␤6765␤»

[21:20] <masak> \o/ \o/

[21:21] <sorear> eagerly (without {} blocks) self-referential binding will never work

[21:21] <sorear> because all occurrences of @fib in the RHS will be resolved to the old container, which is discarded by the binding

[21:21] <sorear> eagerly self-referential *assignment* may work in some cases

[21:22] <masak> rakudo: my @selfref := 1, 2, 3, @selfref; .say for @selfref[^10]

[21:22] <p6eval> rakudo 792e86: OUTPUT«1␤2␤3␤1␤2␤3␤1␤2␤3␤1␤»

[21:22] <masak> sorear: how come that works, then?

[21:22] <sorear> masak: rakudo's broken binding model

[21:22] <masak> :(

[21:22] <sorear> perl6: my $x = 1; my $y := $x; $x := 3; say $y;

[21:23] <p6eval> pugs, niecza v3-82-g1dc43eb: OUTPUT«1␤»

[21:23] <p6eval> ..rakudo 792e86: OUTPUT«3␤»

[21:23] <masak> that is indeed broken.

[21:23] <masak> wow.

[21:23] <sorear> rakudo: my $x; my $y; $x := $y; $y := $x; say $x;

[21:23] <p6eval> rakudo 792e86:  ( no output )

[21:24] <sorear> rakudo: my $x; my $y; $x := $y; $y := $x; say $x; say "alive";

[21:24] <p6eval> rakudo 792e86:  ( no output )

[21:24] *** MayDaniel joined
[21:25] *** TiMBuS joined
[21:29] *** jfried joined
[21:29] *** jfried left
[21:29] *** hercynium left
[21:32] *** mj41 joined
[21:32] *** benabik joined
[21:39] <masak> would it be a bad idea to make $0.succ default to $0.Str.succ?

[21:40] <masak> or, in other words, to have Match objects behave as Str in the case of .succ and .pred

[21:40] *** alester left
[21:40] <moritz_> not a bad idea at all

[21:41] <sorear> The point is not obvious

[21:41] *** Lorn joined
[21:41] <masak> no, it isn't.

[21:42] <masak> a colleague at client was surprised when it didn't have that default.

[21:42] <masak> s/client/$client/

[21:43] <moritz_> ===SORRY!===

[21:43] <moritz_> Symbol '$client' not predeclared in <anonymous>

[21:43] <masak> :P

[21:43] <moritz_> SCNR

[21:44] *** bacek joined
[21:45] <masak> rakudo: my @fib = (1,1,*+*...*)[^10]; say diff(@fib).perl given my &diff := sub (@a) { @a[1..*-1] Z- @a }

[21:45] <p6eval> rakudo 792e86: OUTPUT«(0, 1, 1, 2, 3, 5, 8, 13, 21)␤»

[21:45] <masak> rakudo: my @fib = (1,1,*+*...*)[^10]; say diff(@fib).perl given my &diff := sub (@a) { @a[1..*] Z- @a }

[21:45] <masak> how come one works and the other one times out?

[21:45] <p6eval> rakudo 792e86: OUTPUT«(timeout)»

[21:47] <sorear> rakudo: my @foo = <a b c d>; say @foo[1..*]

[21:47] <p6eval> rakudo 792e86: OUTPUT«(timeout)»

[21:48] <sorear> rakudo: my @foo = <a b c d>; say @foo[1..*-1]

[21:48] <p6eval> rakudo 792e86: OUTPUT«bcd␤»

[21:50] <Juerd> Hm, let's do a feather dist-upgrade.

[21:58] <pmurias> sorear: if i wrote a simple proof of concept in haskell that loads up nam, does some simple type inference, constant folding and maybe if 0 {...} and if 1 {...} handling would you believe type inference for Perl 6 is feasible?

[22:04] *** kaare_ left
[22:15] *** hudnix joined
[22:15] <sorear> pmurias: oh, I absolutely beleive it's feasable

[22:16] <sorear> pmurias: I just don't beleive it's _useful_

[22:17] *** MayDaniel left
[22:20] *** gbacon left
[22:22] *** awwaiid left
[22:23] *** awwaiid joined
[22:24] <pmurias> sorear: explain

[22:25] *** donri left
[22:26] <pmurias> sorear: how do you intend to implement addition fast without type inference?

[22:27] <sorear> The most important thing is not going through the general procedure call interface

[22:29] <sorear> We know CORE::<&infix:<+>> takes two arguments and doesn't need &take, so the C# code can be called directly, avoiding two trampoline bounces, a frame construction, and the interpretive binder loop

[22:31] *** Hackbinary joined
[22:31] <sorear> type inference buys us the ability to bypass a couple of if statements in Builtins.cs

[22:32] <sorear> it doesn't buy us the ability to bypass the general dispatcher, because we already have that

[22:32] <moritz_> even if the user defines his own infix:<+> multis?

[22:33] <sorear> then type inference becomes relevant

[22:33] <pmurias> type inference also buys as the ability to bypass a container fetch and a junction check

[22:34] <sorear> type inference is doable and useful to have, but it is not even close to the most important performance feature

[22:35] <pmurias> what's the most important performance feature?

[22:35] <masak> finished adding up scores. turning to blogging.

[22:35] <pmurias> profiling?

[22:35] <sorear> by "useful to have" I mean that it will improve error quality a lot

[22:35] * masak hopes to whip up some small bit of excitement over the winner announcement

[22:36] <masak> this is a prestigious contest, you know. :)

[22:36] <masak> the winner gets 1e3 EUR in books.

[22:36] <sorear> my Num $foo; say $foo.cps; # Blows up or at least warns at compile time, because the method is spelled cos

[22:36] <sorear> Wasn't it 2e2 previously?

[22:36] <masak> no.

[22:37] <masak> but I suspect it'll be 2e3 next year around.

[22:37] * sorear wonders where masak is getting 2e3 EUR/yr to spend on prizes (TPF?)

[22:37] <pmurias> masak: you founded the competition out of your own money?

[22:37] <masak> pmurias: aye.

[22:37] <masak> so worth it :)

[22:38] <masak> er wait.

[22:38] <masak> 1e2 this year and 2e2 next year.

[22:38] <masak> :)

[22:38] <masak> was thinking SEK, not EUR.

[22:39] *** am0c left
[22:39] * masak writes that blog post

[22:43] *** whiteknight joined
[22:44] *** dorlamm joined
[22:47] <masak> sorear: I probably would be hard pressed to spend 2e3 EUR/yr on the contest, true. :) maybe some day.

[22:49] *** cosimo joined
[22:58] *** icwiener left
[23:00] *** icwiener joined
[23:00] *** dorlamm left
[23:02] *** mj41 left
[23:08] <masak> http://strangelyconsistent.org/blog/announcing-the-winner-of-p6cc2010

[23:10] *** pmurias left
[23:15] <tadzik> moritz_++!

[23:15] <tadzik> oh wait, that's a spoiler :)

[23:16] <masak> :P

[23:16] <masak> the cat being now out of the bag, I'm not sure it matters much.

[23:17] <masak> I'd like to say colomon++ too. the gap between 1st and 2nd place, while not small, was smaller than the gap between 2nd and 3rd place.

[23:17] <sorear> hmm, I should implement that POD parser we talked about some months ago... :)

[23:20] <masak> what made you think of that? :)

[23:24] *** HarryS left
[23:26] *** hercynium joined
[23:27] *** PacoLinux left
[23:27] <[Coke]> that's 1e2, not 10e2, yes? ;)

[23:28] *** PacoLinux joined
[23:28] <[Coke]> hurm. even that is a lot. masak++

[23:29] <[Coke]> I think I slipped a digit, and also, need another drink. ;)

[23:32] *** dsp_ left
[23:32] *** woosley joined
[23:35] *** arlinius joined
[23:41] *** dsp_ joined
[23:41] *** ymasory left
[23:48] *** wallberg left
[23:50] *** mjk joined
[23:50] *** mjk left
[23:57] *** hercynium left
