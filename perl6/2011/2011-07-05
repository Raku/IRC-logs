[00:11] *** rlb3 left
[00:12] *** perlhack joined
[00:12] <perlhack> i came here quiety

[00:12] <perlhack> :-)

[00:19] <perlhack> i'm trying to learn English ...haha

[00:22] *** Sarten-X left
[00:28] *** Sarten-X joined
[00:33] *** drbean joined
[00:41] *** icwiener left
[00:55] *** molaf joined
[00:58] *** thou joined
[01:00] *** jferrero left
[01:04] <jnthn> morning, #perl6

[01:06] *** tokuhirom left
[01:07] *** drbean left
[01:11] <offby1> Good moooorning Vietnam!

[01:14] *** drbean joined
[01:21] *** daniel-s joined
[01:22] <Util> Hi, jnthn 

[01:26] *** thou left
[01:30] *** felliott_ joined
[01:33] *** felliott left
[01:33] *** felliott_ is now known as felliott

[01:37] *** woosley joined
[01:41] <lichtkind> moin jnthn 

[01:45] <jnthn> lichtkind: You're either up very late or very early :)

[01:45] <lichtkind> jnthn: late

[01:48] *** [particle]1 is now known as [particle]

[01:49] <soh_cah_toa> is it possible to use prove w/ perl6? since i 'use v6;', i get the error about needing perl 6. i've just been running tests w/ the perl6 binary instead

[01:49] <jnthn> prove --exec=perl6 t 

[01:49] <jnthn> is another way

[01:50] <soh_cah_toa> ah yes

[01:51] <lichtkind> jnthn: for first time i have an installed current rakudo on my linux :)

[02:00] <lichtkind> good night

[02:00] *** lichtkind left
[02:15] *** envi joined
[02:21] *** PhatEddy left
[02:23] <dalek> rakudo/nom: 3d623cd | jonathan++ | src/core/Str.pm:

[02:23] <dalek> rakudo/nom: Fix chomp on Win32, thus fixing basic-open.t.

[02:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3d623cdd4e

[02:27] *** whiteknight left
[02:37] *** test joined
[02:39] *** test left
[02:46] *** [particle] left
[02:47] *** [particle] joined
[03:09] *** cooper joined
[03:14] *** f00li5h left
[03:17] *** Chillance joined
[03:20] *** thou joined
[03:26] *** Su-Shee left
[03:28] *** Su-Shee joined
[03:29] *** Chillance left
[03:35] *** bluescreen10 left
[03:39] *** ingyfoo is now known as ingy

[03:40] *** agentzh joined
[03:44] *** [perlhack] joined
[03:45] <[perlhack]> hello friends

[03:54] *** felliott left
[03:56] *** JimmyZ joined
[03:58] <JimmyZ> \o

[03:58] *** satyavvd joined
[03:58] <[perlhack]> :-)

[03:59] *** Zapelius joined
[04:07] *** f00li5h joined
[04:16] *** araujo left
[04:19] *** [perlhack] left
[04:29] *** [particle] left
[04:35] *** Zapelius left
[05:04] *** [perlhack] joined
[05:04] *** aloha left
[05:05] <[perlhack]> :-)

[05:05] *** aloha joined
[05:06] <[perlhack]> this is civilized place.

[05:13] *** [perlhack] left
[05:24] *** aloha left
[05:25] *** aloha joined
[05:41] *** soh_cah_toa left
[05:46] *** koban joined
[05:51] *** zby_home left
[05:55] *** f00li5h left
[05:58] *** birdwindupbird joined
[06:09] *** wtw joined
[06:25] *** perlhack left
[06:28] *** Chillance joined
[06:52] *** cooper left
[07:04] *** araujo joined
[07:16] *** birdwindupbird left
[07:20] *** aloha left
[07:26] *** bakedb joined
[07:27] *** wamba joined
[07:34] *** ab5tract joined
[07:34] <tadzik> good morning #perl6

[07:34] *** aloha joined
[07:39] <kthakore> tadzik: good afternoon

[07:45] *** Mowah joined
[07:45] <thou> good night, tadzik

[07:48] *** daxim joined
[08:00] <mathw> Good morning #perl6

[08:04] *** [perlhack] joined
[08:07] <[perlhack]> :-)

[08:08] <[perlhack]> what are you doing

[08:09] *** [perlhack] left
[08:13] <moritz_> nom: say nqp::atkey(pir::getinterp, 'context').backtrace

[08:13] <p6eval> nom: OUTPUT«Method 'gist' not found for invocant of class 'Hash'␤current instr.: 'gist' pc 322896 (src/gen/CORE.setting.pir:89051) (:1626)␤»

[08:13] <moritz_> nom: my Mu $bt = nqp::atkey(pir::getinterp, 'context').backtrace; say $bt

[08:14] <p6eval> nom: OUTPUT«Method 'gist' not found for invocant of class 'Hash'␤current instr.: 'gist' pc 322896 (src/gen/CORE.setting.pir:89051) (:1626)␤»

[08:14] <moritz_> nom: my Mu $bt = nqp::atkey(pir::getinterp, 'context').backtrace; say $bt.elements

[08:14] <p6eval> nom: OUTPUT«Method 'elements' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 105 ((file unknown):42115263) (:1)␤»

[08:14] <moritz_> why is it suddenly a Parcel when I call a method on it_

[08:14] <moritz_> s/_/?/

[08:16] <jnthn> moritz_: It may be coming back as one and it's the recursive gisting into it that finds the hash.

[08:16] <moritz_> jnthn: but why would a pure parrot-internal thing return a Parcel?

[08:17] <jnthn> moritz_: We map such things.

[08:17] <moritz_> or is that an RPA, which automagically gets Parcel'ed in some way?

[08:17] <jnthn> But only one level deep at the momnt

[08:17] <jnthn> Yeah

[08:17] <jnthn> it's magic :)

[08:22] <jnthn> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; say $bt.elems

[08:22] <p6eval> nom: OUTPUT«12␤»

[08:23] <jnthn> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; say $bt[0].WHAT

[08:23] <p6eval> nom: OUTPUT«Hash()␤»

[08:23] <jnthn> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; say $bt[0]

[08:23] <p6eval> nom: OUTPUT«Hash<34017312>␤»

[08:23] <jnthn> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; say $bt[0].keys

[08:23] <p6eval> nom: OUTPUT«Segmentation fault␤»

[08:23] <jnthn> ouch!

[08:24] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for $bt.list { say nqp::p6box_s(nqp::atkey(pir::perl6_decontainerize($_), 'line')) }

[08:24] <p6eval> nom: OUTPUT«error:imcc:The opcode 'perl6_decontainerize_p' (perl6_decontainerize<1>) was not found. Check the type and number of the arguments␤ in file '(file unknown)' line 175␤»

[08:24] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for $bt.list { say nqp::p6box_s(nqp::atkey(pir::perl6_decontainerize__PP($_), 'line')) }

[08:24] <p6eval> nom: OUTPUT«Segmentation fault␤»

[08:24] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for $bt.list { say nqp::p6box_s(pir::perl6_decontainerize__PP($_)) }

[08:24] <p6eval> nom: OUTPUT«Segmentation fault␤»

[08:25] <jnthn> I don't think it's a list of strings.

[08:25] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for ^$bt.elems { say $bt[$_] }

[08:25] <p6eval> nom: OUTPUT«Hash<98870152>␤Hash<93252088>␤Hash<92173920>␤Hash<91073584>␤Hash<89936288>␤Hash<88873464>␤Hash<87771608>␤Hash<86695888>␤Hash<85550760>␤Hash<84468792>␤Hash<83332704>␤Hash<82246024>␤»

[08:25] <jnthn> It's turned those into Perl 6 hashes

[08:25] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for ^$bt.elems { say nqp::atkey($bt[$_], 'line') }

[08:25] <jnthn> So in theory you can use <foo> if you know what key should be there

[08:25] <p6eval> nom: OUTPUT«get_pmc_keyed_str() not implemented in class 'Hash'␤current instr.: '_block1011' pc 463 ((file unknown):28769796) (:1)␤»

[08:26] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for ^$bt.elems { say $bt[$_]<line> }

[08:26] <p6eval> nom: OUTPUT«Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[08:26] <jnthn> It's a Perl 6 hash due to the marshalling. atkey is only for Parrot hashes.

[08:26] <jnthn> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for ^$bt.elems { say $bt[$_]<annotations><line> }

[08:26] <p6eval> nom: OUTPUT«1␤1␤1287␤1280␤1446␤1390␤1385␤26␤1␤Any()␤Any()␤Any()␤»

[08:26] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for ^$bt.elems { say $bt[$_]<annotations><flie> }

[08:26] <p6eval> nom: OUTPUT«Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[08:26] <moritz_> nom: my $bt = nqp::atkey(pir::getinterp, 'context').backtrace; for ^$bt.elems { say $bt[$_]<annotations><file> }

[08:27] <p6eval> nom: OUTPUT«␤␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤Any()␤»

[08:27] <moritz_> jnthn: thank you, I think that should be enough to get me started

[08:27] <jnthn> I think actually we're not setting file properly yet

[08:28] <moritz_> right, that's what my experiments with interp['annotations'; 1]  etc also showed

[08:28] *** noganex_ is now known as noganex

[08:29] <jnthn> I think I may know how to fix that...

[08:30] <jnthn> nqp: die "oh noes"

[08:30] <p6eval> nqp: OUTPUT«Confused at line 1, near "die \"oh no"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[08:30] <moritz_> list ops

[08:30] <jnthn> nqp: die("oh noes")

[08:30] <p6eval> nqp: OUTPUT«Could not find sub die␤current instr.: '_block1000' pc 30 ((file unknown):32)␤»

[08:30] <jnthn> ah, of course it's file unkown there :)

[08:30] <moritz_> nqp: nqp::die('oh noez')

[08:30] <p6eval> nqp: OUTPUT«Unrecognized nqp:: opcode 'nqp::die' at line 1, near ""␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[08:30] <jnthn> oh, no, it shoulda been the p6eval temp file name

[08:31] <moritz_> rakudo: die

[08:31] <p6eval> rakudo 72d158: OUTPUT«Died␤␤  in main program body at line 22:/tmp/6WXL11CRGG␤»

[08:31] *** mj41 joined
[08:32] <jnthn> nqp: my $?foo: = 42;

[08:32] <p6eval> nqp: OUTPUT«Confused at line 1, near "my $?foo: "␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[08:32] <jnthn> nqp: my $?foo := 42;

[08:32] <p6eval> nqp:  ( no output )

[08:37] *** pernatiy joined
[08:44] <dalek> nqp: 26dd00c | jonathan++ | src/HLL/Compiler.pm:

[08:44] <dalek> nqp: Get file name annotations working again for moritz++.

[08:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/26dd00cb14

[08:46] <thou> good bye, #perl6

[08:46] <tadzik> o/

[08:46] *** thou left
[08:50] *** mj41 left
[08:51] *** Jackneill joined
[09:00] *** dakkar joined
[09:00] <moritz_> \o

[09:00] <moritz_> jnthn++

[09:04] <tadzik> oh, my pod grammar is flawed when put into Rakudo

[09:04] *** bakedb left
[09:05] <tadzik> in theory, it should be capable of slurping the entire source code and treating it as pod, and that might even happen if we had LTM :)

[09:07] *** buubot_backup left
[09:07] <jnthn> Time to go play with P6opaque.c...

[09:09] <moritz_> in master, Perl6::BacktracePrinter uses pir::isnull(pir::getprop__psp('$!p6code', $_<sub>)) to identify intermediate blocks

[09:10] <moritz_> grepping thought the current source I only see p6code mentioned in old/ and in the backtrace printer

[09:10] <moritz_> does that mean this possibility is gone? any alternatives?

[09:13] <jnthn> Yeah, there is a backlink from Parrot sub to Perl 6 code object

[09:13] <jnthn> Though everything has one now

[09:13] <jnthn> So you need to ~~ Routine

[09:13] <jnthn> lemme check if we have a way to get at it

[09:15] <jnthn> d'oh, there's not

[09:15] *** drbean left
[09:15] <moritz_> huh?

[09:15] <moritz_> so the Perl 6 code object has-a parrot sub, and that's it?

[09:16] <jnthn> moritz_: No, the Parrot sub has a link back to the Perl 6 one, but at the moment you can only get there in C land

[09:17] <moritz_> jnthn: what's the link?

[09:18] <jnthn> moritz_: I, er, found a spare pointer in the Parrot sub PMC and (ab)used it :)

[09:18] <moritz_> /o/

[09:18] <jnthn> moritz_: Writing a dynop now so you can do what you're after :)

[09:19] <moritz_> jnthn: thank you, I thought I might have to write such a thing :-)

[09:25] <jnthn> my $perl6_code_object = pir::perl6_code_object_from_parrot_sub($parrot_sub_here)

[09:26] <moritz_> \o/

[09:29] *** buubot_backup joined
[09:29] <dalek> rakudo/nom: 6893932 | jonathan++ | LHF.markdown:

[09:29] <dalek> rakudo/nom: Add a LHF.

[09:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/689393211a

[09:29] <dalek> rakudo/nom: 8555c62 | jonathan++ | src/ops/perl6.ops:

[09:29] <dalek> rakudo/nom: Add (untested) perl6_code_object_from_parrot_sub op for moritz++.

[09:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8555c629ec

[09:37] *** wamba left
[09:38] <tadzik> Files=148, Tests=3227, 303 wallclock secs

[09:38] <tadzik> nice!

[09:40] <moritz_> https://gist.github.com/1064564 # also nice :-)

[09:40] <tadzik> git question: how can I edit a commit I did a couple dozen of commits ago

[09:40] <jnthn> How many days ago was it when we were being happy about 1000 test mark having been passed? :)

[09:40] <tadzik> I accidentally did -am and commited something like: my $name := $*ST.add_constant('Str', 'str', 'bacon'); as a stub

[09:41] <tadzik> jnthn: like, two? :)

[09:41] <moritz_> tadzik: git rebase -i HEAD~15

[09:41] <jnthn> tadzik: bacon FTW!

[09:41] <tadzik> where ~15 is "15 commits ago"?

[09:41] <moritz_> tadzik: then pick the commit in question, and put an 'e' in the first column

[09:41] <tadzik> okay, will look into it

[09:42] <moritz_> tadzik: yes... or just screw it, and make a commit that corrects it

[09:42] <moritz_> tadzik: we're all not perfect, and sometimes leave debugging output in files etc.

[09:42] <arnsholt> I usually leave all the embarrasing details in my git history

[09:42] <arnsholt> And scatter it with "Remove forgotten debug code" commits and the like

[09:43] <moritz_> same here

[09:43] <arnsholt> Although the fact that I donæt know how to rewrite history may be a contributing factor =)

[09:44] <jnthn> tadzik: btw, don't edit history that was already pushed somewhere

[09:44] *** JimmyZ left
[09:45] <moritz_> https://gist.github.com/1064564 # non-routines successfully hidden. The segfault is a bit of a downer though :/

[09:46] *** f00li5h joined
[09:46] <moritz_> gist updated with bracktrace

[09:46] <tadzik> I don't know what I did, let's see what happens...

[09:47] <tadzik> okay, could be worse

[09:47] <dalek> Heuristic branch merge: pushed 29 commits to rakudo/podparser by tadzik

[09:48] <jnthn> moritz_: pir::perl6_code_object_from_parrot_sub__PP($bt[$_]<sub>)

[09:48] <jnthn> moritz_: That could return null

[09:48] <moritz_> jnthn: ah, will catch that

[09:48] <jnthn> moritz_: Sure, or we diddle the op to hand back Mu instead :)

[09:49] <moritz_> jnthn: that would be easier, because then I don't have to fetch twice (once for isnull, once for storing)

[09:49] *** am0c joined
[09:51] <jnthn> changing

[09:54] <dalek> nqp: 5efb646 | jonathan++ | src/6model/knowhow_bootstrapper.c:

[09:54] <dalek> nqp: Add .^mro method to core KnowHOW.

[09:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5efb64625e

[09:54] <dalek> nqp: a957601 | jonathan++ | src/how/NQPClassHOW.pm:

[09:54] <dalek> nqp: Add .^mro for NQPClassHOW.

[09:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a957601e06

[09:54] <dalek> nqp: 2d4a979 | jonathan++ | src/how/NQP (3 files):

[09:54] <dalek> nqp: Use Uninstantiable repr for things that should not be instantiated.

[09:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2d4a979409

[09:54] <dalek> nqp: 26c3c1c | jonathan++ | src/stage0/ (7 files):

[09:54] <dalek> nqp: Update bootstrap.

[09:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/26c3c1ca56

[09:56] <moritz_> I was just about to update NQP_REVISION

[09:56] <jnthn> There's more to come

[09:56] <moritz_> I think I'll just go with what I need, and you can bump again when you're done-ish :-)

[09:56] <jnthn> +1

[09:57] *** birdwindupbird joined
[09:57] <dalek> rakudo/nom: 1a56b91 | jonathan++ | src/ops/perl6.ops:

[09:57] <dalek> rakudo/nom: Make sure we don't hand back nulls from perl6_code_object_from_parrot_sub.

[09:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1a56b918ab

[09:59] <tadzik> karma jnthn

[09:59] <aloha> jnthn has karma of 955.

[09:59] <tadzik> karma jonathan

[09:59] <aloha> jonathan has karma of 1338.

[09:59] <tadzik> this jonathan guy, stealing all karma

[10:00] <dalek> rakudo/nom: e24c94d | moritz++ | tools/build/NQP_REVISION:

[10:00] <dalek> rakudo/nom: bump nqp revision to get file annotations

[10:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e24c94d8c8

[10:01] *** woosley left
[10:03] *** bakedb joined
[10:07] *** cosimo_ left
[10:08] <tadzik> is there anything more-less like .WHAT() in nqp?

[10:09] <moritz_> there's pir::typeof

[10:09] <tadzik> it's more like .isa?

[10:09] <jnthn> .WHAT works if you have a 6modelobject

[10:09] <moritz_> there's also pir::isa

[10:10] <moritz_> tadzik: what do you want to achieve?

[10:10] <tadzik> moritz_: cycling through $<pod_content>.ast I want to see if I'm getting the types I'm expecting to get

[10:11] <moritz_> isn't that always PAST:: something?

[10:12] <tadzik> I hope it is, that's the thing

[10:12] <tadzik> teaser trailer: https://gist.github.com/1064604

[10:13] *** cosimo joined
[10:14] <moritz_> \o/ bacon

[10:14] <jnthn> nom: say Pair.^mro

[10:14] * moritz_ hungry

[10:14] <p6eval> nom: OUTPUT«Pair() Enum() Any() Mu()␤»

[10:15] <tadzik> moritz_: the saddest part is that bacon is only temporary :(

[10:15] <moritz_> chunky bacon?

[10:15] <tadzik> quickly, say something tasty!

[10:16] <sjn> yum?

[10:16] <tadzik> masak's edublogging is a bit like that guide, aside from being more to the topic :)

[10:20] <moritz_> it's like chunky bacon without the bacon :/

[10:24] <moritz_> rakudo: sub f { die  }; f

[10:24] <p6eval> rakudo 72d158: OUTPUT«Died␤␤  in 'f' at line 22:/tmp/8BbwAGyf6D␤  in main program body at line 22:/tmp/8BbwAGyf6D␤»

[10:25] <moritz_> perl6: my ($a, $b) = <a b>; say "$a:$b"

[10:25] <p6eval> pugs, niecza v7-11-g9ba8284: OUTPUT«a:b␤»

[10:25] <p6eval> ..rakudo 72d158: OUTPUT«===SORRY!===␤Symbol '$a:$b' not predeclared in <anonymous> (/tmp/32SQJaCkWM:22)␤»

[10:25] <moritz_> nom: my ($a, $b) = <a b>; say "$a:$b"

[10:25] <p6eval> nom: OUTPUT«Symbol '$a:$b' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[10:25] <moritz_> std: my ($a, $b) = <a b>; say "$a:$b"

[10:25] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 124m␤»

[10:26] <moritz_> is that bug known?

[10:26] <moritz_> nom: my ($a, $b) = <a b>; say "{$a}:$b"

[10:26] <p6eval> nom: OUTPUT«a:b␤»

[10:27] <jnthn> Looks new to me.

[10:28] <tadzik> hrm. What does prefix | mean, in nqp? Creates a capture from an array, si?

[10:28] <moritz_> context_

[10:28] <moritz_> context?

[10:29] <tadzik> foo('bar', |@asd);

[10:29] <moritz_> it interpolates into the argument list

[10:30] <tadzik> okay, thanks

[10:30] <tadzik> somewhere, somehow, my array duplicates itself

[10:30] <moritz_> the fun of using binding instead of assignment

[10:31] <tadzik> oh, a trap

[10:32] <tadzik> jnthn: is that ok that ST.add_constant returns something that stringifies to Capture[0x2643888]?

[10:32] <tadzik> I thought it would be PAST::something

[10:34] <jnthn> tadzik: I suspect it is a PAST node and it inherits its stringification from Parrot's Caputre PMC somehow

[10:34] <tadzik> all right, thanks

[10:36] *** pernatiy_ joined
[10:36] *** pernatiy left
[10:37] <tadzik> nqp: my $s = " foo    bar  "; $s ~~ s:g/\s+/ /; say($s)

[10:37] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 1, near " \" foo    "␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[10:37] <tadzik> nqp: my $s := " foo    bar  "; $s ~~ s:g/\s+/ /; say($s)

[10:37] <p6eval> nqp: OUTPUT«Confused at line 1, near "$s ~~ s:g/"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[10:38] <tadzik> nqp: my $s := " foo    bar  "; $s := subst($s, /\s+/, ' '); say($s)

[10:38] <p6eval> nqp: OUTPUT« foo    bar  ␤»

[10:38] <tadzik> nqp: my $s := " foo    bar  "; $s := subst($s, /\s+/, ' ', :global); say($s)

[10:38] <p6eval> nqp: OUTPUT« foo bar ␤»

[10:38] <tadzik> wfm

[10:46] *** _twitch joined
[11:09] *** daniel-s left
[11:12] <tadzik> moritz_: turns out moving $=POD earlier in the schedule was a good decision. In case I won't be able to debug the $=POD stuff today, I should be able to do those tables and formatting codes and have another week for $=POD, what do you think?

[11:15] <jnthn> tadzik: ohbtw - I checked. we are missing the token for the = twigil

[11:15] <tadzik> just that?

[11:15] <jnthn> tadzik: I didn't try adding it.

[11:15] <jnthn> tadzik: But it is missing

[11:15] *** envi left
[11:15] <tadzik> I see

[11:16] <jnthn> (e.g. STD has it and Grammar.pm doesn't)

[11:16] *** envi joined
[11:16] <tadzik> $=foo       Pod variable, says S02. And S26 mentions $=POD as the only Pod variable. Makes me wonder if we even want = as a special twigil, if it's only for one case

[11:18] <jnthn> yeah, it feels odd if there's only the one

[11:19] <dalek> nqp: f14f5b6 | jonathan++ | src/6model/reprs/P6opaque.c:

[11:19] <dalek> nqp: Refactor P6opaque a bit so that we can handle multiple inheritance.

[11:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f14f5b6fe6

[11:19] <dalek> nqp: 4c68b90 | jonathan++ | src/6model/reprs/P6opaque. (2 files):

[11:20] <dalek> nqp: Stash flag for when we're in an MI situation. Also a little cleanup.

[11:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4c68b90a39

[11:20] <dalek> nqp: 037134d | jonathan++ | src/6model/reprs/P6opaque.c:

[11:20] <dalek> nqp: Sort out error reporting for non-existant attributes so it actually says that's the problem.

[11:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/037134d4bd

[11:20] <dalek> nqp: 8fffc11 | jonathan++ | src/6model/reprs/P6opaque.c:

[11:20] <dalek> nqp: Add back decontainerize that got lost during refactors.

[11:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8fffc11005

[11:20] <jnthn> $?POD would maybe make sense

[11:22] *** masak joined
[11:22] <masak> o/

[11:22] <jnthn> lolitsmasak

[11:23] <jnthn> ni hao ma?

[11:23] <masak> wo hen hao. ni ne? :)

[11:23] <jnthn> hen hao, xie xie

[11:24] <masak> bu ke, bu ke :P

[11:31] *** satyavvd left
[11:32] *** agentzh left
[11:33] *** _twitch left
[11:34] *** wamba joined
[11:34] <moritz_> tadzik: +1 to taking more time to tweak $POD. Not sure if it needs to be a whole weak, YMMV

[11:35] *** pernatiy_ left
[11:35] <tadzik> moritz_: probably not, but I don't think it will be the half of the day, see today :)

[11:35] <tadzik> too many suprise issues. Plus I don't want to deliver anything Less Than Awesome, it should be awesome, period :)

[11:36] <masak> +1

[11:36] <moritz_> tadzik: sure, take your time. I prefer an incomplete-but-good-enough-to-be-mergeable any time over a quick hack that pmichaud++ will reject because it's trash :-)

[11:37] <masak> pmichaud++ always has good reasons to reject things, often far more detailed than "it's trash" :)

[11:37] *** am0c left
[11:37] <masak> when I grow up, I want to have good reasons to reject commits, just like pmichaud :)

[11:37] *** am0c joined
[11:38] <moritz_> when I grow up, I want to have good resons to accept commits :-)

[11:39] * moritz_ finds a bug in pmichaud++'s code :-)

[11:42] <moritz_> i need name suggestions: how do you call an element of a backtrace?

[11:42] <jnthn> A callframe?

[11:42] <moritz_> in the specs I wrote that it's a CallFrame, but that does additional stuff (like exposing some variables etc.)

[11:43] <moritz_> nom: say List.Str

[11:43] <p6eval> nom: OUTPUT«Parameter '(null)' requires an instance, but a type object was passed␤current instr.: 'Str' pc 328548 (src/gen/CORE.setting.pir:91608) (src/gen/CORE.setting:2010)␤»

[11:44] *** whiteknight joined
[11:44] <jnthn> Missing multi or stray proto

[11:44] <moritz_> missing multi

[11:45] <moritz_> I discovered it while writing class BackTrace is List { multi method Str ... }

[11:46] <jnthn> dinner &

[11:46] <moritz_> good nom!

[11:48] <dalek> rakudo/nom: bd50d5d | moritz++ | src/core/List.pm:

[11:48] <dalek> rakudo/nom: List.Str should be a multi

[11:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd50d5df29

[11:50] *** mj41 joined
[11:51] <flussence> stupid question: using --without-pcre to get parrot to compile won't break anything in rakudo will it?

[11:51] <moritz_> won't break rakudo, no

[11:52] <flussence> (3227 passing tests already?!)

[11:53] <flussence> at this rate nom will be passing 200% of the spectests by August :)

[11:54] *** [perlhack] joined
[11:55] <[perlhack]> :-)

[11:55] <[perlhack]> hi friends

[11:55] <[perlhack]> i came here again.

[11:56] <masak> hi, [perlhack] 

[11:56] <masak> flussence: well, we have to write more spectests, then.

[11:56] <[perlhack]> what are you do ding ?

[11:56] <[perlhack]> what are you doing

[11:57] <masak> [perlhack]: industrious people here are working on the 'nom' branch of Rakudo, making it pass tests.

[11:58] <[perlhack]> haha

[11:59] <[perlhack]> what is the 'nom' ?

[11:59] <masak> it's just a name.

[11:59] <[perlhack]> masak

[11:59] <masak> it stands for 'New Object Model', since that's what it's about.

[11:59] <moritz_> [perlhack]: http://pmthium.com/2011/02/08/new-nqp-repository-new-nom-rakudo-branch/

[12:00] <[perlhack]> :-)haha i get  it

[12:01] <[perlhack]> your English is  very good

[12:01] <[perlhack]> moritz_               masak   

[12:01] <[perlhack]> ty moritz

[12:01] <moritz_> because I pasted a link?

[12:01] <[perlhack]> ty masak

[12:01] <[perlhack]> haha yes

[12:02] *** jedai joined
[12:03] <moritz_> masak: you will like this one: https://gist.github.com/1064564

[12:03] <moritz_> (just updated)

[12:03] <[perlhack]> moritz_:this is a friendly  link .

[12:04] <[perlhack]> :-)

[12:04] <masak> moritz_: I like the improvements it represents :)

[12:04] <masak> moritz_: <anon> subs always reported themselves as being on "line 1", even though they most often weren't.

[12:04] <moritz_> oh, it would make more sense if I put the loop *inside* the method :-)

[12:05] <masak> this looks fixed here. moritz_++

[12:05] *** jedai_ left
[12:05] <moritz_> I wonder if I should generally filter out setting routines

[12:05] <masak> huh? why?

[12:06] <moritz_> paste forthcoming...

[12:06] <moritz_> masak: please reload that gist

[12:07] <masak> moritz_: on line 24, 25: you can use <line file> and save yourself some repetition

[12:07] <moritz_> masak: I've now put the loop inside the method

[12:07] <masak> moritz_: not sure I like the thought of suppressing setting routines.

[12:08] <masak> that would make things harder to debug in some cases.

[12:08] <moritz_> masak: me neither, but I don't like 3x reify, 1x gime and 3x eager for a single for-loop either

[12:09] <masak> I'd suggest merging them into one line somehow, but the line numbers are different...

[12:10] <moritz_> the problem here is really that the user called none of those routines

[12:10] <masak> while we're on the topic of backtraces: one feature that is desperately missing from Rakudo is the ability to do die/warn without a backtrace.

[12:10] <masak> even a short-term solution would be appreciated here.

[12:11] <moritz_> maybe the "real" solution is to add some magic to the code emitted for a 'for' that surpresses the backtrace, or some such

[12:11] <masak> moritz_: oh, I see what you mean now.

[12:11] <masak> moritz_: why *are* reify, gimme, and eager called in this case?

[12:12] <moritz_> masak: in master, you should be fine-ish patching src/Perl6/BacktracePrinter.pm to omit the backtrace if the error messages end in an \n

[12:12] <moritz_> masak: that's because for() is really an 'eager map()'

[12:13] <masak> ah, and you're doing a 'for'. yes, I see now.

[12:15] <pmichaud> 'for' is not supposed to be any more or less eager than map() -- that's a rakudoism at the moment.

[12:16] <moritz_> yes, missing sink context and all that

[12:16] <pmichaud> (good morning, #perl6)

[12:16] <moritz_> good morning pmichaud :-)

[12:16] <tadzik> I wish my flat had a sink context. Could help with the suprise lake

[12:16] <moritz_> but the question remains: how do we remove the noise from the backtrace?

[12:17] <masak> gm pm

[12:17] <TimToady> write the backtrace to a file, and just give a URI to it :)

[12:18] <masak> std: KitchenSink

[12:18] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 118m␤»

[12:20] <masak> I look forward to being able to push feeds into IO objects... but I'm not married to the term "KitchenSink", which seems pretty arbitrary.

[12:21] <masak> it's both too close to and too different from the term 'sink', which we already have.

[12:21] <moritz_> Can't we just use the * to mean "sink" in feeds?

[12:22] <TimToady> it's probably more important that we figure out how feeds can be event queues a lá Go channels

[12:22] <masak> moritz: right, but '@contents ==> "myfile".IO' would be an example of a KitchenSink.

[12:22] <masak> I'd also like to see someone take on the task of making the Actor model supportable from within Perl 6.

[12:22] *** drbean joined
[12:23] <TimToady> at the moment KitchenSink is mostly for countering those folks that say "you've put everything in except the kitchen sink"

[12:23] <[perlhack]> :-)

[12:23] <masak> right, I suspected that. and hence it gets an automatic "cute today" label :P

[12:23] <TimToady> think of it as a placeholder

[12:23] <masak> that helps. a little.

[12:26] <moritz_> any more thoughts on possible solutions for the backtrace problem?

[12:26] <moritz_> niecza: for 1..3 { die '' }

[12:26] <p6eval> niecza v7-11-g9ba8284: OUTPUT«Unhandled exception: ␤  at /home/p6eval/niecza/lib/CORE.setting line 656 (CORE die @ 2) ␤  at /tmp/fdoR9kH5WW line 1 (MAIN mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1879 (CORE C879_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting lin…

[12:27] <flussence> .oO( hm, on the one hand, nom's REPL starts up pretty much instantly. Typing "1" into it eats 120MB of RAM even faster... )

[12:27] <masak> a lot of older Perl 6 documents under dev.perl.org/perl6 are missing.

[12:28] <pmichaud> moritz_: the "backtrace problem" being the emitting of setting routines in the backtrace?

[12:28] <moritz_> pmichaud: well, being the emitting of 7 setting routines for a single for loop

[12:29] <moritz_> masak: I think Ranguard on irc.perl.org could know something about that

[12:29] <moritz_> pmichaud: I don't think setting methods per se are a problem - often it's even helpful

[12:29] *** ab5tract left
[12:29] <moritz_> for example if you die from within a callback to sort(), you certainly want the sort to appear in the backtrace

[12:30] <moritz_> pmichaud: https://gist.github.com/1064564#file_output%3A

[12:31] <pmichaud> maybe we need error context setters -- some form of dynamic var

[12:31] <pmichaud> similar to :dba in STD.pm6

[12:31] <[Coke]> pmichaud: o/

[12:31] *** pernatiy joined
[12:31] <pmichaud> [Coke]: o/

[12:32] * [Coke] was momentarily surprised those lined up.

[12:32] *** JimmyZ joined
[12:32] <pmichaud> the other strategy I can think of is to print the setting call that is first within user code

[12:33] <[perlhack]> :-)

[12:33] <moritz_> pmichaud: that's certainly worth trying out

[12:33] <masak> moritz_: ok, I'll ask him when I get home.

[12:34] <moritz_> pmichaud: people will be confused when a 'for' gets turned into an 'eager' or a 'map' though

[12:35] <pmichaud> yes, that's a bit tricky.  because by the time you get to doing the 'for' loop iterations, you've already exited the for/map

[12:35] <pmichaud> (because it's lazy)

[12:37] *** felliott joined
[12:37] <moritz_> I'd be fine with a for-loop not showing up at all

[12:37] *** [perlhack] left
[12:38] <moritz_> just like it doesn't show up in p5 stack traces

[12:38] <pmichaud> I suspect the level of detail for a backtrace ought to be contextual, also.

[12:39] * [Coke] throws out his attempt to add unlink and reclaim t/spec/integration/say-crash.t

[12:40] <pmichaud> [Coke]: I'm a little surprised you're having trouble there -- can I see your latest patch before you toss it out?

[12:40] <pmichaud> (or am I too late?)

[12:41] <[Coke]> there's a gist. momentito.

[12:41] <pmichaud> moritz_: also, why is "BackTrace is List", ooc?

[12:42] <[Coke]> https://gist.github.com/1063975 (add it)

[12:42] <[Coke]> https://gist.github.com/1063976 (bt you get running said spec test)

[12:42] <pmichaud> moritz_: nm, I see why.

[12:43] <pmichaud> [Coke]: I suspect part of the problem is that the try block ends with a non-rakudo object.

[12:43] <pmichaud> (the result of the .rm)

[12:43] <[Coke]> given the backtrace, very likely.

[12:43] <pmichaud> try adding a 1; at the end of the try { }

[12:43] <[Coke]> let me put in an explicit return.

[12:43] <[Coke]> I was going to check the spec and see what it said. ;)

[12:43] <pmichaud> that works too :)

[12:44] <moritz_> it says "don't segfault" :-)

[12:44] <pmichaud> it's also possible/likely that .rm returns PMCNULL and that's causing the segfault.

[12:44] <pmichaud> I have to run -- bbiab

[12:44] <moritz_> if it returns a PMCNULL in case of failure, there's no need for the try/catch

[12:45] <moritz_> in that case a pir::isnull would be appropriate

[12:45] <moritz_> oh, in the success case. Never mind.

[12:46] <[Coke]> looks like it throws an ugly exception, the c ends with THROW("unlink");

[12:51] *** whiteknight left
[12:53] *** colomon joined
[12:53] *** wamba left
[13:04] <[Coke]> pmichaud: adding a 1 inside the try block did not avert the segfault.

[13:05] <pmichaud> [Coke]: okay, looking

[13:05] *** drbean left
[13:06] <[Coke]> no rush, don't want you to get sidetracked. ;)

[13:07] *** tokuhirom joined
[13:11] *** estrabd joined
[13:13] *** woosley joined
[13:23] <pmichaud> it only crashes (PMCNULL) when in the setting.  standalone it seems to work fine.

[13:26] *** birdwindupbird left
[13:27] <pmichaud> is there a flag I can pass to trace to tell it to just dump the opcodes being executed, and not the values of the operands?

[13:27] <pmichaud> trace in nom is... LTA

[13:28] <pmichaud> (because Parrot's trace is helpfully tring to display the types of the PMC operands... which invokes a PIR subroutine which then gets inserted into the trace output)

[13:31] <pmichaud> Looks like it's the 'True' that is causing the problem.

[13:32] *** tokuhirom left
[13:33] <moritz_> oh right, 1.True should solve that

[13:33] <pmichaud> 1.Bool

[13:33] <moritz_> erm, right

[13:34] <[Coke]> checking...

[13:35] *** tokuhirom joined
[13:35] <[Coke]> pmichaud: I don't think trace has that flag, no

[13:35] <pmichaud> maybe I can fix whatever does the stringification in nqp

[13:37] *** [particle] joined
[13:38] <dalek> rakudo/nom: 32dccc7 | pmichaud++ | NOMMAP.markdown:

[13:38] <dalek> rakudo/nom: Add note to NOMMAP about True not working in setting.

[13:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32dccc7e15

[13:38] <[Coke]> pmichaud++ # unlink works, at least one test file reclaimed. ;)

[13:40] <[Coke]> will push after a rebase and re-test.

[13:42] *** mj41 left
[13:46] *** ab5tract joined
[13:46] *** chris99 left
[13:47] *** bluescreen10 joined
[13:50] <dalek> rakudo/nom: 393264f | moritz++ | / (3 files):

[13:50] <dalek> rakudo/nom: add &hash sub, enable tests

[13:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/393264f98f

[13:50] <moritz_> [Coke]: I just pushed another commit, but you don't have to re-test after that one (no interaction with your stuff) :-)

[13:53] <[Coke]> danke.

[13:54] *** estrabd left
[13:57] *** felliott left
[13:59] <[Coke]> worth adding an option to the default spectest to shuffle the order of tests?

[13:59] <pmichaud> ?

[13:59] <[Coke]> (er, to make "make spectest" shuffle the test order by default)

[13:59] <moritz_> [Coke]: what would you achieve with that?

[13:59] <[Coke]> "prove -s"\

[14:00] <moritz_> not "how", "what"?

[14:00] <moritz_> or better, "why"?

[14:01] <[Coke]> by running them in the same order each time you can (theoretically) end up with tests that depend on each other when you didn't mean for them to.

[14:03] <dalek> roast: 347de93 | moritz++ | S04-statement (2 files):

[14:03] <dalek> roast: small rakudo (un)fudges

[14:03] <dalek> roast: review: https://github.com/perl6/roast/commit/347de93d5d

[14:03] <dalek> rakudo/nom: b195df3 | Coke++ | src/ (2 files):

[14:03] <dalek> rakudo/nom: add "unlink" from master with small tweak

[14:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b195df3351

[14:03] <dalek> rakudo/nom: dc78320 | Coke++ | t/spectest.data:

[14:03] <dalek> rakudo/nom: reclaim a test.

[14:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc78320274

[14:03] <[Coke]> Tests=3231 #spectst

[14:03] *** koban left
[14:04] * moritz_ increases that number

[14:04] <dalek> rakudo/nom: f1caed6 | moritz++ | t/spectest.data:

[14:04] <dalek> rakudo/nom: 5 more passing test files

[14:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f1caed605a

[14:04] <colomon> \o/

[14:05] <moritz_> it's funny how a little builtin can win you back tests if all the basics are in place

[14:08] <moritz_> and I'm pretty sure there are quite some files that pass dozens of tests, but hinge on some small thing that makes them bail out

[14:12] <dalek> roast: b24a341 | moritz++ | S02-builtin_data_types/hash_ref.t:

[14:12] <dalek> roast: refudge hash_ref.t for rakudo

[14:12] <dalek> roast: review: https://github.com/perl6/roast/commit/b24a341094

[14:13] *** wtw left
[14:14] <[Coke]> moritz_: I am pondering making a gist of explosions per test file.

[14:14] <[Coke]> (then you could focus on explosions that were shared across test files)

[14:14] <[Coke]> ... though I have to focus on $DAYJOB now. ;)

[14:16] *** woosley left
[14:17] <pmichaud> nom:  say 'a'.chars

[14:17] <p6eval> nom: OUTPUT«1␤»

[14:17] <pmichaud> nom: say a.substr(-1)

[14:17] <tadzik> nom: say 'ą'.chars; say 'ą'.bytes;

[14:17] <p6eval> nom: OUTPUT«Could not find sub &a␤current instr.: '_block1002' pc 70 ((file unknown):59343318) (/tmp/T5vyriKzDs:1)␤»

[14:17] <p6eval> nom: OUTPUT«1␤2␤»

[14:17] <pmichaud> nom: say 'a'.substr(-1)

[14:17] <p6eval> nom: OUTPUT«a␤»

[14:18] <pmichaud> ...what's the overall guidelines for putting string methods in Cool vs. Str?

[14:18] <pmichaud> in master and at the beginning of nom, we tended to define the methods in Cool.  Lately they seem to be going in Str with Cool doing self.Str.foo

[14:19] <moritz_> the latter kinda seems cleaner to me

[14:19] <moritz_> since many of those methods stringified the invocant first anyway

[14:19] <moritz_> and then did something on it

[14:20] <pmichaud> why doesn't Cool have the numeric methods defined on it yet?

[14:21] <moritz_> which ones?

[14:21] <pmichaud> nom:  say "1".sin

[14:21] <p6eval> nom: OUTPUT«Method 'sin' not found for invocant of class 'Str'␤current instr.: '_block1002' pc 75 ((file unknown):7560606) (/tmp/bFP9j6bHnq:1)␤»

[14:21] <moritz_> ah, I mostly just added those back that I needed to get tests passing

[14:22] <moritz_> the rest should go there too

[14:22] <pmichaud> okay, I think I'm fine with having  self.Str.foo as the general pattern, then.

[14:22] <pmichaud> (and we should move the existing Cool methods that way)

[14:23] <pmichaud> I'm kind of wondering which one ultimately ends up being more efficient

[14:24] <pmichaud> also, I suspect that Cool should be   self.Stringy.foo  instead of self.Str.foo

[14:24] <pmichaud> since the numerics are generally    self.Numeric.foo

[14:25] <moritz_> probably

[14:25] <[Coke]> Method 'Capture' not found for invocant of class 'Parcel'

[14:25] <moritz_> but these days all the builtins .Stringy and .Str the same, no?

[14:25] <[Coke]> (there's one of yer 'splosions)

[14:25] <moritz_> and they just .gist differently

[14:26] <moritz_> [Coke]: I've had that one multiple times, and always thought "I'll live that one to pmichaud++' :-)

[14:26] <pmichaud> Capture will undoubtedly be added as part of the new regex stuff, since Match ~~ Capture

[14:26] <masak> when you're writing tests post facto for legacy code, "got" and "expected" are confusingly reversed :)

[14:27] * moritz_ didn't got that... erm, expected :-)

[14:27] <pmichaud> (.Stringy/.Str)  sure, they're the same now, but that might not be true for user classes that "is Cool"

[14:27] <moritz_> right

[14:27] * jnthn back from dinner/beer

[14:29] <tadzik> what a day. Leaking washing machine, burning dinner, bugs in code. I'm curious what else can make it worse

[14:29] *** simcop2387 joined
[14:30] <colomon> tadzik: doesn't every single day have bugs in code?  ;)

[14:31] <tadzik> ask masak, he's submitting bugs daily :)

[14:31] <masak> even code that looks right has bugs.

[14:31] <masak> possibly with the exception of trivial and almost-trivial code.

[14:31] <masak> but even that is suspect :P

[14:32] <masak> I still haven't tracked down the error in my "obviously correct" recursive sierpinski builder.

[14:32] <pmichaud> even if the trivial code is bug-free, the non-trivial compiler that runs it isn't.  :)

[14:33] <colomon> personally, my major change in my $work code over the weekend only turned up a trivial-to-fix seg fault.  So I get to spend all day writing tests to see if I really got it right.

[14:34] <tadzik> my gsoc goals tend to be a 10-line patches to the parser and another 100 lines of tests for that

[14:35] <masak> my most anti-climactic bug hunt ever involved Perl 5, a 'sort' call, and a global variable called '$a'. I think you can fill in the blanks.

[14:35] <colomon> though I think I've just detoured into doing a refactoring that will make it easier to write the tests, and therefore to actually use my new code...

[14:36] <pmichaud> masak: heh

[14:36] <jnthn> I doubt the True-in-setting issue will be dealt with until I actually implement enums.

[14:37] <jnthn> I'm a little amazed the current hack works at all :)

[14:38] <pmichaud> maybe we should go ahead and define True as a term then, as a short-term fix.

[14:38] <jnthn> In general, "X works but not in the setting" shouldn't be that surprising. The setting is playing part of the role of circularity saw in places.

[14:38] <masak> jnthn: what would it take to implement enums?

[14:38] <jnthn> pmichaud: I doubt that'd actually help

[14:38] *** bluescreen10 left
[14:39] <jnthn> I'm not sure what the current bug is. it looks nasty and I'd rather spend time on doing enums than debugging why a questionable cheat doesn't work.

[14:39] <jnthn> masak: Mostly, figuring out how EnumHOW looks :)

[14:40] <pmichaud> I don't see why/how Inf works at the moment, fwiw.

[14:40] <masak> jnthn: sounds like fun.

[14:40] <jnthn> no, me either :)

[14:40] <masak> jnthn: I might have a look at it this weekend.

[14:40] *** donri joined
[14:40] <pmichaud> jnthn: surely   term:sym<True> would be guaranteed to work.

[14:40] <pmichaud> sub term:sym<True> { 1.Bool }   

[14:40] <jnthn> masak: I glanced through the enum spec quickly again recently and realized 6model may make a few things easier.

[14:40] <pmichaud> if nothing else.

[14:41] <jnthn> pmichaud: oh, that'd work but...why bother

[14:41] <jnthn> pmichaud: I expect to have enums done in the next week or so anyway.

[14:41] <pmichaud> so our setting isn't filled with 1.Bool all over the place, and so Coke++ doesn't spend hours trying to find a segfault that is because of a not-working "True" symbol.

[14:41] <jnthn> masak: ooh, we could have a weekend hackathon

[14:42] <masak> jnthn: remotely, in that case. :/

[14:42] <jnthn> masak: Well, part-of-weekend

[14:42] <jnthn> masak: Oh?

[14:42] <masak> jnthn: leaving early on Sat.

[14:42] * jnthn will be back, but guesses masak won't be

[14:42] <jnthn> ah, ok

[14:43] <masak> gonna be a teacher for a week :)

[14:43] <masak> I expect to have some time left over for coding, though.

[14:43] <jnthn> heh. When you get back I'll be gone again ;)

[14:44] <masak> well, when I get back I'll just re-pack and take a week of vacation :)

[14:45] <jnthn> ah, you're vacationing that week too :)

[14:45] <jnthn> $dayjob will be quiet :)

[14:45] <masak> indeed :)

[14:47] *** simcop2387 left
[14:48] *** everbrew joined
[14:48] *** simcop2387 joined
[14:53] *** ymasory joined
[14:54] *** bluescreen10 joined
[14:55] *** simcop2387 left
[14:58] *** simcop2387 joined
[15:13] *** ab5tract left
[15:16] *** woosley joined
[15:17] *** leprevost joined
[15:19] *** Holy_Cow joined
[15:19] *** am0c left
[15:32] *** am0c joined
[15:36] <dalek> nqp: b003b38 | jonathan++ | src/6model/sixmodelobject.h:

[15:36] <dalek> nqp: Extend representation API with a couple of new features to support doing defaults properly in Perl 6 and in order to support mixins (actually, the mechanism is far more generic, and should be able to support a bunch of other stuff that Perl 6 doesn't need, but other languages may).

[15:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b003b387cb

[15:36] <dalek> nqp: 0ae9745 | jonathan++ | src/6model/reprs/ (7 files):

[15:36] <dalek> nqp: First sketch of implementation of is_attribute_initialized for all reprs.

[15:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0ae9745621

[15:36] *** mkramer joined
[15:38] <everbrew> ls

[15:41] <masak> No such file or directory.

[15:41] <everbrew> thank you

[15:41] <masak> just us chickens.

[15:42] <everbrew> *facepalm*

[15:42] <everbrew> I need more coffee

[15:42] <everbrew> I thought it was zebras ...

[15:43] *** thou joined
[15:43] *** mkramer left
[15:44] *** mkramer joined
[15:44] *** mkramer left
[15:45] <masak> if you ls zebras, all you get is lines and lines of output.

[15:45] *** woosley left
[15:45] <jnthn> every other line is blank, though

[15:50] *** ymasory left
[15:54] * masak decommutes

[15:54] *** masak left
[16:03] <dalek> rakudo/nom: df26bd3 | pmichaud++ | src/Perl6/ (2 files):

[16:03] <dalek> rakudo/nom: Temporary change to handle True/False and Bool::True/Bool::False

[16:03] <dalek> rakudo/nom: directly in the grammar for now, so they're available to CORE.setting.

[16:03] <dalek> rakudo/nom: We can undo these when the official definitions of True/False become available.

[16:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/df26bd3199

[16:04] <dalek> gsocmess: 8e69807 | tadzik++ | / (3 files):

[16:04] <dalek> gsocmess: Parse the simple case of tables

[16:04] <dalek> gsocmess: review: https://github.com/tadzik/gsocmess/commit/8e698079fa

[16:04] *** jaldhar left
[16:05] <dalek> rakudo/nom: e77b738 | pmichaud++ | NOMMAP.markdown:

[16:05] <dalek> rakudo/nom: Add note to NOMMAP about array/hash variable initialization.

[16:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e77b73832a

[16:06] *** kaare_ joined
[16:11] *** bakedb left
[16:14] <pmichaud> afk, errands

[16:15] *** cotto_work joined
[16:19] <dalek> rakudo/nom: 7019642 | pmichaud++ | src/core/ (7 files):

[16:19] <dalek> rakudo/nom: Convert instances of 1.Bool into Bool::True.

[16:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/701964259a

[16:20] *** mkramer1 joined
[16:21] *** mkramer1 left
[16:24] *** pernatiy left
[16:25] *** wamba joined
[16:30] <tadzik> I'm starting to hate Pod tables

[16:31] <moritz_> it might make sense to not parse the tables completely with rules

[16:31] <tadzik> I don't think they can be

[16:31] <moritz_> but to postprocess stuff

[16:32] *** kst left
[16:32] <moritz_> you know the bitwise-AND trick for discovering column boundaries?

[16:33] <tadzik> you have to parse the whole table, then count the number of separators. if there are none, this is an ordinary table. If there's one, there's header and the ordinary table. If there's more than one, but all alike, it's a multi-line table. If there's more than one and they're different, then the first row is a multi line header and then comes the multi-line table

[16:33] <tadzik> madness

[16:33] <tadzik> moritz_: no, never heard of it

[16:33] <moritz_> tadzik: when you have whitespace-aligned columsn, you bit-AND all the rows

[16:34] <moritz_> tadzik: and only the columns where the result is still a space can be column boundaries (but not all of them must be)

[16:34] *** am0c left
[16:35] <tadzik> interesting. So far I'm just relying on the fact, that the cells must be separated by at least two whitespaces... oh wait, that's weird

[16:35] <tadzik> Columns are separated by two or more consecutive whitespace characters, or by a vertical line (C<|>) or a border intersection (C<+>), either of which must be separated from any content by at least one whitespace character.

[16:36] <tadzik> So when they're separated by at least two consecutive whitespaces, must they be separated from any content by at least one whitespace too, which makes them at least four whitespaces? :)

[16:37] <moritz_> I guess the "either" doesn't apply to the first item

[16:37] <tadzik> probably, yes

[16:37] <tadzik> I have a feeling that Tables are a bit too complex to be summarized in 3 paragraphs and 3 examples

[16:37] *** MayDaniel joined
[16:38] <moritz_> tadzik: how many weeks did you allocate for tables?

[16:39] <tadzik> moritz_: one. They're supposed to be tables and formatting codes this week

[16:39] <tadzik> that'd probably end up as 'tables and serialization experimentation' this week, and 'formatting codes and serialization' next week

[16:40] *** mj41 joined
[16:41] *** cdarroch joined
[16:41] *** cdarroch left
[16:41] *** cdarroch joined
[16:42] <tadzik> I should've started this week earlier

[16:42] *** kst joined
[16:42] <tadzik> even though it's tuesday :)

[16:45] <jnthn> sleep time

[16:45] <jnthn> yes, I preported for #phasers :)

[16:45] <jnthn> Will be offline-ish for a bunch of tomorrow due to flight

[16:46] * JimmyZ sleeps too

[16:46] <jnthn> o/

[16:47] <thou> good night, beijing!

[16:47] <thou> \o

[16:47] *** Jackneill left
[16:48] <tadzik> good night :)

[16:49] *** MayDaniel left
[16:55] *** JimmyZ left
[16:57] *** MayDaniel joined
[17:02] *** daxim left
[17:02] *** MayDaniel left
[17:05] *** soh_cah_toa joined
[17:06] <soh_cah_toa> Util: hey

[17:09] *** mkramer joined
[17:09] *** dakkar left
[17:10] *** noganex_ joined
[17:10] *** masak joined
[17:12] <tadzik> #      got: ("Human", "2", "Pizza")

[17:12] <tadzik> # expected: ("Human", "2", "Pizza")

[17:12] <tadzik> Contest! I'll show the winner the fastest way to tie a shoe

[17:13] <masak> probably something silly like one being a List and the other a Seq...

[17:13] *** noganex left
[17:13] <masak> or hidden Nil elements that get flattened out...

[17:14] <masak> or maybe the is_deeply routine simply doesn't handle that type.

[17:14] <masak> so many ways this can fail! :)

[17:15] <tadzik> :)

[17:15] <tadzik> I'll get back to checking every pair of indexes then

[17:19] <masak> unless you consider stringifying the whole lists and checking those with 'is' Good Enough.

[17:19] <masak> one technique I've been liking more and more lately is making diffs and testing those.

[17:20] <everbrew> panda's interactive mode isn't very interactive, is it?

[17:21] <tadzik> isn't it?

[17:22] <tadzik> it's less functional than the batch mode, IIRC. I'm planning a rewrite of those for a while now

[17:22] <everbrew> I keep expecting cpan for no reason :)

[17:22] <dalek> gsocmess: fbb1956 | tadzik++ | / (2 files):

[17:22] <dalek> gsocmess: Allow '|' and '+' cell separators

[17:22] <dalek> gsocmess: review: https://github.com/tadzik/gsocmess/commit/fbb1956306

[17:22] <dalek> gsocmess: 458689d | tadzik++ | / (3 files):

[17:22] <dalek> gsocmess: Handle a one-lined table with a header. Add a skeleton for handling a multi-line tables

[17:22] <dalek> gsocmess: review: https://github.com/tadzik/gsocmess/commit/458689d2ca

[17:22] <tadzik> patches welcome :)

[17:24] <everbrew> as soon as I get familiar enough to write something beyond hello.pl

[17:24] *** l234567 joined
[17:24] *** l234567 left
[17:25] *** l234567 joined
[17:25] *** l234567 left
[17:25] <tadzik> how do you like Perl 6?

[17:26] <tadzik> nqp: sub foo { sub bar { say(1) }; bar; bar; }; foo

[17:26] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 1, near "{ sub bar "␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6372)␤»

[17:26] <tadzik> nqp: sub foo() { sub bar() { say(1) }; bar; bar; }; foo

[17:26] <p6eval> nqp:  ( no output )

[17:26] <everbrew> as a long-time perler, short-time perl6er, I like the language a lot (but it's a tad slowish)

[17:27] <tadzik> yeah, we're working on that. You may want to try niecza when you're looking for speed rather than features

[17:28] *** l234567 joined
[17:28] *** l234567 left
[17:29] <masak> luckily, it's not the language that's slow :)

[17:30] <tadzik> :)

[17:38] *** mkramer left
[17:38] *** jevin_ left
[17:38] *** rindolf joined
[17:38] <rindolf> Hi all.

[17:38] <tadzik> hello rindolf 

[17:39] <rindolf> tadzik: hi.

[17:44] *** impious joined
[17:46] *** jevin joined
[17:47] <tadzik> masak: can I have your helpy hand?

[17:48] <tadzik> moritz_: or yours :)

[17:49] <moritz_> tadzik: I can try

[17:50] <tadzik> preparing a gist, hold on

[17:51] <tadzik> moritz_: https://gist.github.com/1065396

[17:52] <tadzik> when I change line 22 from ]+ to ]* that fixes the example with a trailing empty field, but not with the leading

[17:53] <moritz_> you really need to post-process

[17:53] <tadzik> the bitwise-way?

[17:54] <moritz_> or you can turn $/.from into column numbers

[17:54] <moritz_> and do some matching afterwards

[17:55] <tadzik> hmm

[17:58] <tadzik> or I can push an empty element if the last one ends with |, and unshift one if the first one starts with |

[17:59] <tadzik> well, any possible separator, not |

[17:59] <masak> tadzik: I'm with moritz; parse the contents of the table in the simplest possible way, then post-process.

[18:00] <tadzik> that's what I did, but I included splitting the row between cells in the simplies possible way :)

[18:00] <masak> tadzik: you're in 2D-land here, and recursive-descent parsing is no longer the fastest vehicle.

[18:00] <tadzik> yeah, I can see that

[18:00] <tadzik> sigh :)

[18:01] <masak> it doesn't seem to me you can say a lot about table cells before you've seen the whole table.

[18:01] <moritz_> especially if the separator is \s ** 2

[18:01] <tadzik> yep

[18:01] <masak> fwiw, this is very much the same situation I'm facing right now when I'm "parsing" Sudoku problems, and the like.

[18:01] <masak> (for dlx-simple)

[18:04] *** mj41 left
[18:05] *** mj41 joined
[18:05] *** cooper joined
[18:20] *** Holy_Cow left
[18:33] <masak> speaking of the flip-flop operations:

[18:34] <masak> why are there eight of them? :)

[18:34] <masak> wouldn't it be... fun... to try to come up with even one use case for each of those eight?

[18:34] <masak> I'd sure like to get to know the flipflop family a little better.

[18:35] <masak> at present, I don't think I grok the semantics of them very well.

[18:35] <masak> what does ^ff do again? how about fff^ ?

[18:38] <pmichaud> for lines() { /start/ ff /end/ && .print }

[18:39] <masak> nice, good.

[18:39] *** zby_home_ joined
[18:39] <pmichaud> as soon as we see a line containing 'start', we start printing, we continue printing until we see a line containing 'end'

[18:39] <masak> inclusive, both ends. good.

[18:39] <pmichaud> for lines() { /start/ ^ff /end/ && .print }

[18:39] <pmichaud> omit the start line.

[18:39] <masak> nod.

[18:40] <pmichaud> for lines() { /start/ ff^ /end/ && .print }

[18:40] <pmichaud> (I think) keep the start line, omit the end line.

[18:40] <masak> I think so too.

[18:40] <masak> and ^ff^ is omit both.

[18:40] <pmichaud> I think so, yes.

[18:40] <masak> makes total sense.

[18:41] <masak> that's four.

[18:41] *** meteorjay joined
[18:41] <masak> for what the 'fff' operator even does, it seems one has to go to 'perldoc perlop'.

[18:42] <pmichaud> with the ff version, if a line contains both start and end, then we flip and flop on that one line.

[18:42] <pmichaud> i.e., we don't print anything.

[18:42] <masak> oh!

[18:42] <masak> yes, I see where this is heading.

[18:42] <pmichaud> with fff, if a line contains start, we flip but don't even try to flop.

[18:43] <masak> 'If you don't want it to test the right operand till the next evaluation, as in sed, just use three dots ("...") instead of two.  In all other regards, "..." behaves just like ".." does.'

[18:43] <masak> yes, perldoc perlop agrees.

[18:43] <masak> still, that makes ^ff^ abd ^fff^ perfectly equivalent, I guess.

[18:44] *** Mowah left
[18:44] <masak> and ^ff and ^fff, and ff^ and fff^...

[18:44] <masak> no wait.

[18:44] <masak> sorry, I'm speaking without thinking.

[18:44] <masak> no, it's different behaviours.

[18:46] <dalek> rakudo/nom: 87e9756 | pmichaud++ | src/core/ (5 files):

[18:46] <dalek> rakudo/nom: More True/False changes.

[18:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/87e9756aa3

[18:47] <masak> the way to pick between the eight seems to be to ask (1) "what to I want to happen at the endpoints?", and (2) do I want to test for flopping directly after flipping?

[18:47] <pmichaud> correct.

[18:47] <masak> the first question picks the left and right hats; the second one picks between ff and fff.

[18:48] <pmichaud> .print for lines().grep({/start/ ff /end/})  # nice

[18:48] <masak> ooh

[18:48] <masak> I love what Perl 6 is doing with Perl :)

[18:50] <colomon> hmm... does lines eat the newlines?

[18:50] <masak> aye.

[18:50] <pmichaud> if so, then .say

[18:51] <colomon> two characters shorter!!  \o/

[18:52] <masak> .say for lines.grep: /start/ ff /end/

[18:52] <masak> hm, I need those curlies, don't I?

[18:52] <pmichaud> yes

[18:53] <masak> wrong $_ otherwise.

[18:53] <tadzik> moritz_, masak, could you please take a look at https://gist.github.com/1065563, did I get it right? Others are welcome to look in it as well :)

[18:53] * masak takes a look

[18:53] <pmichaud> nom: say 'a'.substr(-1);

[18:53] <p6eval> nom: OUTPUT«a␤»

[18:54] <pmichaud> we should fix that.

[18:54] <masak> tadzik: doesn't look obviously wrong :)

[18:54] <tadzik> (:

[18:55] <masak> tadzik: there are a number of things that can go wrong with a table. what's the failure mode?

[18:55] <tadzik> I'd like to have it correct before I start reimplementing .comb :)

[18:55] <tadzik> masak: looking at the spec, which says not much really, I think the failure mode is: you write weird tables, you deserve an undefined behaviour :)

[18:55] <masak> things like people using inconsistent delimiters, or not lining them up correctly, or having different amounts of cells on each line...

[18:56] <tadzik> different amount of cells is even in spec, that's what causes me make a post-processing

[18:56] <masak> tadzik: you write weird tables, you get a good error message -- would please me more :)

[18:56] <masak> tadzik: but probably not a parse error.

[18:57] <Util> soh_cah_toa: Hi!

[18:57] <tadzik> not lining the delimiters correctly is not an issue if we do the search for the delimiters for each row separately

[18:57] <masak> huh what?

[18:57] <masak> it's allowed to write bad tables?

[18:57] <tadzik> what is the question about?

[18:57] <tadzik> the spec?

[18:58] <masak> or the interpretation of it.

[18:58] <tadzik> remember the previous gist?

[18:58] <masak> vividly.

[18:58] <tadzik> https://gist.github.com/1065396

[18:58] <tadzik> the heading uses a different number of cells each line

[18:58] <tadzik> and the example is straight from S26

[18:59] <masak> hm. slow down.

[18:59] <masak> what's a "cell" to you?

[18:59] <tadzik> something between the delimiters, or between a line boundary and a delimiter

[18:59] <masak> good. to me too.

[19:00] <masak> I think I see what you mean.

[19:00] <tadzik> oh, so what happens if someone forgets a trailing delimiter before the empty cell?

[19:00] <masak> for the header at least, it doesn't matter which line things are on.

[19:00] <tadzik> I assume one gets an array of rows in which one of the rows has less cells than the other

[19:01] <masak> before you pointed it out, I didn't even consider the different placement of the header cell contents a difference.

[19:01] <masak> I mean, I didn't even think of it.

[19:02] <masak> visually, even though there are two lines up there, I keep thinking of it as three cells, not six.

[19:02] <tadzik> I didn't either, and then that test failed :P

[19:02] <masak> have you considered treating it as three cells?

[19:03] <tadzik> I will, one day. So far I used something like... (pasting)

[19:03] <tadzik> https://gist.github.com/1065588

[19:04] <tadzik> then I determined how long is the heading and did merge_rows(@rows[0..$how-long-is-the-heading])

[19:04] *** molaf left
[19:10] *** Bzek left
[19:13] <[Coke]> [~] doesn't work yet in nom, aye?

[19:14] <dalek> rakudo/nom: 86ff74d | pmichaud++ | src/core/ (2 files):

[19:14] <dalek> rakudo/nom: Move .substr guts from Cool to Str, make .substr properly fail on negative start or length arguments.

[19:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/86ff74d622

[19:14] <pmichaud> nom:  say [~] <a b c d>;

[19:14] <p6eval> nom: OUTPUT«abcd␤»

[19:14] <pmichaud> works.  :)

[19:15] <dalek> rakudo/nom: 4353c16 | pmichaud++ | LHF.markdown:

[19:15] <dalek> rakudo/nom: Add a LHF for Str.chomp.

[19:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4353c16565

[19:15] *** jferrero joined
[19:16] <[Coke]> is that recent? hurm.

[19:16] <pmichaud> since Sat, I suspect.

[19:16] <[Coke]> probably a result of the other thing I'm adding not working. ;)

[19:17] <[Coke]> any gotches to bringing over the sub form of WHAT?

[19:17] <[Coke]> aside from s/our// ?

[19:18] <pmichaud> it's really supposed to be a macro, not a sub :)

[19:18] <pmichaud> I'm okay if we cheat as a sub for a while longer, though.  :)

[19:18] <[Coke]> I'm bringing over the comment that says that too! :)

[19:19] <pmichaud> [Coke]++

[19:19] *** cooper left
[19:20] <[Coke]> nom: my $a=3;say $a.WHAT

[19:20] <p6eval> nom: OUTPUT«Int()␤»

[19:20] <[Coke]> hurm. that's not what that says locally, odd. (I have added a sub WHAT in core/operators.pm, but that's not the sub form. wtf.)

[19:21] <masak> nom: say Mu.^methods>>name.perl

[19:21] <p6eval> nom: OUTPUT«Confused at line 1, near "say Mu.^me"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[19:21] <masak> worth a shot :)

[19:22] <lue> hello world o/

[19:22] <masak> hi lue!

[19:23] * masak is quickly realizing that even a smallish text adventure will be a bit of a challenge

[19:23] <dalek> specs: 839c329 | (Felix Herrmann)++ | S06-routines.pod:

[19:23] <dalek> specs: [S06] typo fix: insert missing 'is'

[19:23] <dalek> specs: review: https://github.com/perl6/specs/commit/839c329b50

[19:23] <masak> felher++ # you're really reading the spec, aren't you? :)

[19:23] <lue> ifMUD (a MUD for Interactive Fiction) runs on perlMUD

[19:24] <masak> lue: yes, but that doesn't help me much for the blog posts...

[19:25] *** buubot_backup left
[19:25] *** am0c joined
[19:25] <lue> I just mentioned it in case you'd like to take a look at perlMUD.

[19:26] <masak> maybe afterwards :)

[19:26] * lue tries to start working on nom soon

[19:26] <masak> for now, I'll take a first shot at writing a game prototype.

[19:27] <[Coke]> nom: say 3.WHAT

[19:27] <p6eval> nom: OUTPUT«Int()␤»

[19:28] <masak> nom: say 3.WHAT.WHAT.WHAT # !?

[19:28] <p6eval> nom: OUTPUT«Int()␤»

[19:28] <[Coke]> in the REPL, that dies with:

[19:28] <[Coke]> Can only use nqp_get_sc_for_object with a SixModelObject

[19:28] <pmichaud> pmichaud@kiwi:~/nom$ ./perl6

[19:28] <pmichaud> > say 3.WHAT

[19:28] <pmichaud> Int()

[19:28] <felher> masak: well, actually i'm just reading the typos ;) 

[19:29] <pmichaud> there seems to be a problem in the repl that once an error occurs, we end up with the "SizModelObject" on various things afterwards (and so you need a fresh REPL)

[19:29] <pmichaud> *SixModelObject

[19:29] <masak> felher: :P

[19:30] <[Coke]> hurm. yah, it only happens after, e.g. my $a=3;$a.WHAT.say  , but that doesn't throw an error.

[19:31] <[Coke]> but, "don't trust the REPL right now". Roger.

[19:34] <[Coke]> No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:

[19:34] <[Coke]> ... it would be helpful if that told me what types it was checking for, too, not just which multis were available.

[19:35] <everbrew> "Learning Perl 6" -- not a good reference?

[19:35] <tadzik> what's the date of publishing?

[19:36] <everbrew> never

[19:36] <moritz_> not good.

[19:36] <lue> rakudo: my $a = 3; say $a; $a = Nil; say $a;

[19:36] <p6eval> rakudo 72d158: OUTPUT«3␤Any()␤»

[19:36] <lue> nom: my $a = 3; say $a; $a = Nil; say $a;

[19:36] <p6eval> nom: OUTPUT«3␤Nil␤»

[19:36] <lue> which one is right here?

[19:36] <betterworld> how do these spectests for hygienic macros look? - http://pastebin.com/qzmHfVG7

[19:37] <betterworld> especially the last one

[19:37] *** cooper joined
[19:37] <moritz_> betterworld: the first one already is not correct

[19:38] <moritz_> oh wait, no

[19:38] <moritz_> I thought you'd have to declare $x

[19:38] <masak> lue: Rakudo master is right.

[19:38] <moritz_> but it's just a closure..

[19:38] <betterworld> i don't quite follow ;)

[19:39] <masak> betterworld++ # writing tests for that

[19:39] <[Coke]> I have a test that I'm trying to recoup that is doing an infix ~ on a Pair, and then failing to dispatch that to the Any/Any multi version. 

[19:39] <moritz_> betterworld: ignore what I wrote so far

[19:40] <moritz_> betterworld: more interesting, in defun(foo, Int $arg, $arg * $arg); the foo needs to be quoted

[19:40] <betterworld> i wondered about that too

[19:40] <moritz_> betterworld: unless you add "is parsed", the arguments to the macro are just normal Perl 6 code

[19:41] <pmichaud> [Coke]: what's the test?

[19:41] <[Coke]> t/spec/integration/pair-in-array.t

[19:41] <[Coke]> added the WHAT() locally, just trying to get the [~] working on Pairs now.

[19:41] <moritz_> betterworld: so I guess the 'Int $arg' suffers from the same problem

[19:42] *** kaare_ left
[19:43] <betterworld> then I guess the test might be more interesting with 'is parsed' than with strings.  Something like this might become my favorite use case of macros ;)

[19:43] <[Coke]> nom: my @P1 = ('a'=>2);

[19:43] <masak> we won't know until we have macros :)

[19:43] <p6eval> nom:  ( no output )

[19:43] <[Coke]> nom: my @P1 = ('a'=>2); say [~] @p1

[19:43] <p6eval> nom: OUTPUT«Symbol '@p1' not predeclared in <anonymous> (/tmp/ZlNOsk1KII:1)␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[19:43] <[Coke]> nom: my @P1 = ('a'=>2); say [~] @P1

[19:43] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:␤:(Str $a, Str $b)␤:(Any $a, Any $b)␤␤current instr.: 'infix:<~>' pc 292999 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:1379)␤»

[19:43] <pmichaud> oh!

[19:44] <moritz_> [Coke]: I think it's the [...] is NYI

[19:44] <pmichaud> no

[19:44] <pmichaud> we haven't defined  &infix:<~>($x?) { $x }   yet

[19:44] <pmichaud> or any of the degenerate infixes

[19:44] <[Coke]> ahhh. ok. I can grab that one.

[19:44] <pmichaud> so [~] can't work when there's only zero or one element

[19:45] <pmichaud> nom:  say [~] 'a'

[19:45] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'infix:<~>'. Available candidates are:␤:(Str $a, Str $b)␤:(Any $a, Any $b)␤␤current instr.: 'infix:<~>' pc 292999 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:1379)␤»

[19:45] <pmichaud> nom:  say [~] 'a', 'b'

[19:45] <p6eval> nom: OUTPUT«ab␤»

[19:46] *** buubot_backup joined
[19:47] <[Coke]> actually, do you want all those metaops brought over? 

[19:48] *** molaf joined
[19:49] <lue> What's the gist method for in Iterator.pm?

[19:51] <moritz_> stringification that is targeted at the human, not at the computer

[19:51] <pmichaud> [Coke]: yes, please.

[19:51] <[Coke]> pmichaud: Failed to build with a naive copy and s/our//g - trying just the one first, will see if I can add more later.

[19:51] <pmichaud> std:  my @list;  OUTER: @list.map({ ... });   # checking

[19:51] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[19:52] *** Chillance left
[19:55] <jlaire> perl6: my @a; say [+] @a; say [*] @a

[19:55] <p6eval> niecza v7-11-g9ba8284: OUTPUT«0␤0␤»

[19:55] <p6eval> ..pugs, rakudo 72d158: OUTPUT«0␤1␤»

[19:56] <jlaire> perl6: my @a; say [+] @a; say [*] @a; say [&&] @a; say [||] @a; say [**] @a

[19:56] <p6eval> rakudo 72d158: OUTPUT«0␤1␤Bool::True␤Bool::False␤1␤»

[19:56] <p6eval> ..niecza v7-11-g9ba8284: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤This macro cannot be used as a function at /tmp/sguDx7yWH2 line 1:␤------> [32mmy @a; say [+] @a; say [*] @a; say [&&][33m⏏[31m @a; say [||] @a; say [**] @a[0m␤␤This macro cannot be used as a function at /tmp/sguDx7yWH2 l…

[19:56] <p6eval> ..pugs: OUTPUT«0␤1␤1␤␤1␤»

[19:57] <pmichaud> \o/ rakudo++

[19:57] <jlaire> indeed :)

[19:57] <jlaire> (assuming that's correct)

[19:57] <masak> looks like.

[19:58] <jlaire> karma rakudo

[19:58] <aloha> rakudo has karma of 17.

[19:58] <jlaire> karma niecza

[19:58] <aloha> niecza has karma of 13.

[19:58] <jlaire> karma pugs

[19:58] <aloha> pugs has karma of 0.

[19:58] <pmichaud> That's just Wrong, somehow.

[19:58] <jlaire> aww, pugs++, it's close enough

[19:59] <jlaire> what is?

[19:59] <pmichaud> "pugs has karma of 0"  <- wrong

[19:59] <jlaire> oh, definitely

[19:59] <pmichaud> as in, morally wrong or something.

[19:59] <jlaire> maybe it ha overflowed

[19:59] <jlaire> has*

[20:00] <tadzik> probably

[20:06] <tadzik> soh_cah_toa: is your new module in the ecosystem already?

[20:06] <soh_cah_toa> tadzik: are you referring to META.info?

[20:07] <soh_cah_toa> er, read that wrong. no it isn't

[20:07] <soh_cah_toa> i was gonna ask how it get's on modules.perl6.org but i fell asleep :)

[20:07] <tadzik> :)

[20:09] <soh_cah_toa> what do i need to do to get it on modules.perl6.org and/or panda?

[20:10] <tadzik> ask me :) Do you have a META.info?

[20:10] <soh_cah_toa> yes

[20:11] <tadzik> I'll add it to the https://github.com/perl6/ecosystem/blob/master/META.list file, and it'll magically appear in all the sources, modules.perl6.org, panda, API etc

[20:11] <tadzik> that's it :)

[20:13] <soh_cah_toa> ah neat. the repo's at https://github.com/soh-cah-toa/digest-sha256

[20:14] <tadzik> ok, I'll do this in a second

[20:14] <soh_cah_toa> sure

[20:14] <masak> std: my @a = 1, 2, 3, given 42;

[20:14] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 122m␤»

[20:14] <masak> rakudo: my @a = 1, 2, 3, given 42; say @a

[20:14] <p6eval> rakudo 72d158: OUTPUT«Could not find sub &given␤  in main program body at line 22:/tmp/SdfkdMe7WW␤»

[20:15] * masak submits rakudobug

[20:18] <betterworld> so, could I write the definition like macro defun($name is parsed /<deflongname>/, $sig is parsed /<signature>/, $body)

[20:19] <betterworld> where deflongname and signature are supposed to reference the definitions in Perl6/Grammar.pm?

[20:19] <moritz_> I don't think so

[20:19] <moritz_> you'd have to do something like

[20:20] <moritz_> macro defun() is parsed /rule for the whole thing/ { compile $/ to Perl 6 code; do stuff with it }

[20:21] <betterworld> hm, that does not sound very beautiful to be honest ;)

[20:21] <moritz_> it sounds like what you want can really be done with a sub at compile time

[20:22] <moritz_> BEGIN install_sub('name', -> $x { $x * $x })

[20:22] <moritz_> betterworld: point is, if you go with 'is parsed' on parameters, how would the compiler know that you want a comma-separated list?

[20:22] *** leprevost left
[20:23] <betterworld> that's a reasonable question

[20:23] <dalek> ecosystem: 6056d42 | tadzik++ | META.list:

[20:23] <dalek> ecosystem: Added Digest::SHA256 thanks to soh_cah_toa++

[20:23] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/6056d4261c

[20:24] <masak> rakudo: class A { has $!x; method change(A $a) { $a!x = "foo" } }; my $a = A.new; my $b = A.new; $a.change($b)

[20:24] <p6eval> rakudo 72d158: OUTPUT«Method '!x' not found for invocant of class 'A'␤  in 'A::change' at line 22:/tmp/Fxz0gRbVJY␤  in main program body at line 22:/tmp/Fxz0gRbVJY␤»

[20:24] <[Coke]> sadly, those 2 commits don't get me that integration test back. Close, though.

[20:24] <tadzik> soh_cah_toa: visibly done :) cronjobs for modules.perl6.org and he modules api run hourly, so you'll have to wait a bit for the module to appear in the media

[20:24] <dalek> rakudo/nom: 2e59702 | Coke++ | src/core/metaops.pm:

[20:24] <dalek> rakudo/nom: add degenerate infix:<~>

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e5970211f

[20:24] <dalek> rakudo/nom: 5fa788d | Coke++ | src/core/operators.pm:

[20:24] <dalek> rakudo/nom: add subish WHAT()

[20:24] <masak> is the above supposed to work one day?

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5fa788d3ed

[20:25] * moritz_ has no idea

[20:25] <colomon> soh_cah_toa++

[20:25] <soh_cah_toa> tadzik: yay! it's nothing spectacular being my first attempt at a p6 module but it'll grow in time :)

[20:25] <tadzik> soh_cah_toa: my first module was a port of Acme::Meow :P

[20:25] * moritz_ uploaded new book snapshots to github

[20:26] <betterworld> on the other hand, I think you can use macros for this kind of stuff in scheme, so I thought it might be similar in Perl 6

[20:26] <moritz_> well, you can

[20:27] <moritz_> we just haven't worked out yet how to do it nicely

[20:27] <moritz_> betterworld: if you just pass existing literals to your macros, it will be much easier

[20:27] <moritz_> where with "literals" I mean "anything that can be a statement in Perl 6"

[20:27] <moritz_> :-)

[20:28] <lue> .oO[ Mrr. I'm trying to do an extremely clever one-liner ?? !! conditional to fix a piece of LHF and nqp isn't letting me. :( ]

[20:28] <pmichaud> [Coke]: the test has to be changed.

[20:28] <masak> TimToady: true or faux: instances of a class can change each other's private attributes.

[20:28] <dalek> book: 0210e16 | moritz++ | src/ (6 files):

[20:28] <dalek> book: pseudopod needs a newline between headings and Z<...>

[20:28] <dalek> book: review: https://github.com/perl6/book/commit/0210e162fd

[20:28] <pmichaud> type objects no longer stringify to their typename.

[20:28] <masak> (provided they're rw, of course)

[20:30] <jlaire> is that allowed in other languages?

[20:30] <masak> in Java, it is.

[20:31] <masak> it makes some sense. it's within the bounds of the class, so it's the class author that's making the access.

[20:31] *** [Coke] left
[20:31] <dalek> roast: a94b224 | pmichaud++ | integration/pair-in-array.t:

[20:32] <dalek> roast: Type objects no longer stringify to "Type()" -- have to use .gist instead.  Coke++ for working on this one.

[20:32] <dalek> roast: review: https://github.com/perl6/roast/commit/a94b22487a

[20:32] <jlaire> yeah, it's allowed in C++ too

[20:32] <masak> that also means that the private attribute is already "visible", since self can see it.

[20:32] <jlaire> the '$obj!attr' syntax looks a bit odd

[20:32] <masak> truly, the issue turns up as soon as you do something involving two objects of a class.

[20:32] <jlaire> .oO( $obj.!attr )

[20:32] <dalek> rakudo/nom: 48b9efc | pmichaud++ | t/spectest.data:

[20:32] <dalek> rakudo/nom: Add t/spec/integration/pair-in-array.t to spectest.data.  Coke++

[20:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/48b9efcca2

[20:33] <masak> like "connect these rooms together, mutually".

[20:33] <masak> jlaire: I like your syntax, too.

[20:33] *** mj41 left
[20:33] <moritz_> nom: say Int.Str, Int.Stringy, Int.gist

[20:33] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤Int()␤»

[20:34] *** [Coke] joined
[20:34] <pmichaud> coule also do Int.perl

[20:35] <pmichaud> *could

[20:35] <pmichaud> nom: say Int.Stringy, Int.gist, Int.perl

[20:35] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤Int()Int␤»

[20:35] <dalek> rakudo/nom: 8c4e7fd | moritz++ | / (2 files):

[20:35] <dalek> rakudo/nom: add BackTrace class to setting. Not yet used in exceptions

[20:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c4e7fdad7

[20:36] * [Coke] checks backscroll.

[20:36] <pmichaud> moritz:  anytime we have a non-rakudo object going to a variable, we probably need to declare the variable as "Mu"

[20:36] <pmichaud>         my $bt = nqp::atkey(pir::getinterp, 'context').backtrace;

[20:37] <pmichaud> and binding is probably wise there also :)

[20:37] <moritz_> pmichaud: it comes back as a Parcel

[20:37] <[Coke]> ah, pmichaud++, danke.

[20:37] <pmichaud> oh, because it's an rpa

[20:37] <moritz_> right

[20:37] <pmichaud> safer would still be Mu.  Note that assigning a Parcel to a scalar may also end up converting it to a Seq.

[20:38] <pmichaud> (That's what the spec currently says, I'm thinking we might avoid that)

[20:38] <moritz_> that wouldn't hurt in this case

[20:38] <pmichaud> okay.

[20:38] <moritz_> I just need something that has .elems and can be indexed

[20:39] <moritz_> my attempts to iterate directly over .list of it always lead to segfaults

[20:39] <pmichaud> yeah, because the things inside of the backtrace aren't rakudo objects.

[20:39] <moritz_> they are parrot hashes, and get turned into Hash objects

[20:39] <pmichaud> so binding in the subcall has trouble

[20:39] *** Sarten-X left
[20:40] <pmichaud> could do it with nqp::iterator and nqp::shift

[20:40] <lue> $ perl6 -e 'print "START"; print "\n".chomp; print "".chomp; say "END"'

[20:41] <lue> STARTEND

[20:41] <pmichaud> lue: \o/

[20:41] <lue> should I run  make spectest  and report the changes?

[20:41] <pmichaud> lue: yes, please.

[20:43] * lue running

[20:43] <pmichaud> moritz_: also, using .[] on a Parcel gets very expensive -- it has to construct a new List for each invocation.

[20:43] <pmichaud> (not that it matters much for backtraces... just for future reference)

[20:44] <pmichaud> if it becomes a .Seq it won't be expensive, though.

[20:44] <lue> Actually, things have been commited since I started working on this. Should I pull the latest before creating a patch?

[20:44] <pmichaud> lue: can you nopaste the patch somewhere?

[20:44] <pmichaud> If so, I can give a quick review.  In the meantime, yes, it'd be better to pull first.

[20:45] <lue> I will do that as soon as the spectest is done [or if needed, I can open up another terminal and just create the patch now]

[20:45] <pmichaud> lue: up to you :)

[20:46] <pmichaud> moritz_: I wonder if the verbosity of the backtrace should be figured out when it stringifies, instead of when it's created :).

[20:47] *** rindolf left
[20:47] *** wamba left
[20:48] <masak> rakudo: my %h = <a b c>.kv; subset ABCStr of Str where { %h.exists($_) }; my ABCStr $b = "b"; say "alive"

[20:48] <p6eval> rakudo 72d158: OUTPUT«Null PMC access in find_method('exists')␤  in <anon> at line 1:/tmp/XW15lZmHcc␤  in 'Block::ACCEPTS' at line 6377:src/gen/core.pm␤  in 'infix:<~~>' at line 483:src/gen/core.pm␤  in <anon> at line 1:/tmp/XW15lZmHcc␤  in 'Block::ACCEPTS' at line 6377:src/gen/core.pm␤…

[20:48] <masak> known bug?

[20:49] <pmichaud> masak: I'm sure I've run into it before, but I don't know if it's ticketed.

[20:49] * masak submits rakudobug

[20:49] <pmichaud> okay by me to masakbug it :)

[20:49] <jlaire> is that allowed? seems evil

[20:49] <jlaire> if %h is not constant

[20:50] <pmichaud> Perl 6 gives lots of new Evil possibilities.  That's what happens when Damian is one of the main designers.

[20:50] *** Sarten-X joined
[20:50] <pmichaud> masak: also, that example suffers slightly in that 'b' isn't a key in the hash.

[20:50] <masak> I guess this is related: https://rt.perl.org/rt3/Ticket/Display.html?id=77356

[20:50] <masak> rakudo: my %h = <a b c>.kv; say %h.perl

[20:51] <p6eval> rakudo 72d158: OUTPUT«{"0" => "a", "1" => "b", "2" => "c"}␤»

[20:51] <masak> pmichaud: oh :)

[20:51] <pmichaud> I doubt that eliminates the bug, but it means the test case needs a bit of work.

[20:51] *** ribasushi left
[20:51] <masak> jlaire: subtypes are very much allowed to change dynamically.

[20:51] <jlaire> masak: kk

[20:52] <pmichaud> jlaire: you can even do things like     subset Chaos of Str where { rand > 0.5 }

[20:52] <masak> the freedom of dynamic languages :P

[20:52] <jlaire> subset July4th of Date where { ... }

[20:52] <pmichaud> which only lets you assign about half of the time.

[20:52] <jlaire> can only be instantiated on that day

[20:52] <masak> pmichaud: have you looked into Java2k, perchance? :)

[20:52] *** ribasushi joined
[20:52] <pmichaud> masak: I have not.  :)

[20:52] <pmichaud> does nom have where clauses, yet?

[20:53] <pmichaud> nom:  subset Even of Int where { $_ * 2 == 0 };  my Even $a = 3;  say $a;

[20:53] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[20:53] <masak> pmichaud: Java2k argues that since programming is so fallible, it's "best" to build in 10% chance of failure into the language itself...

[20:53] <lue> only S02-literals/numeric.rakudo didn't give ok

[20:54] <masak> so every operation has a 10% chance of failing. protection against this comes through nested if statements.

[20:54] <pmichaud> masak: that sounds like another one of those "made up on the spot statistics"  :-P

[20:54] <masak> reducing failure rate to 1%, .1%, .01%, etc.

[20:54] <pmichaud> lue: that's a known failure if you don't have libgmp or some other bigint library installed

[20:55] <pmichaud> I think I'm going to fudge numeric.t

[20:55] <masak> that way -- so Java2k claims -- the programmer gets a "failure-oriented" mindset from the start, leading to better programs.

[20:55] <masak> it also naturally leads to *short* programs, since you don't want to expose the program to too many operations :P

[20:55] <pmichaud> seems low on the whipituptitude scale, though.

[20:56] <jlaire> we need a 'Perl6_2k' module that overwrites all standard subs to produce errors randomly

[20:57] <masak> pmichaud: I haven't even mentioned that the language is base 11, with the 11th "numeral" being represented by ASCII 0x20 :)

[20:57] <masak> I am not making this up.

[20:57] <masak> (it's an esoteric language, of course)

[20:58] <dalek> roast: 7a1f6e3 | pmichaud++ | S02-literals/numeric.t:

[20:58] <dalek> roast: Fudge test in S02-literals/numeric.t for Rakudo (until we have a chance to fix numeric literals).

[20:58] <dalek> roast: review: https://github.com/perl6/roast/commit/7a1f6e34c2

[20:59] <jlaire> 'of course' <-- when it comes to java, I can't always be sure...

[21:00] <pmichaud> "Java2k: 2000 iterations and still inflicting pain"

[21:02] <masak> Java2k has about as much connection with Java as does JavaScript.

[21:03] <Util> PWN: #parrotsketch will be held an hour earlier, starting next week.

[21:03] <jlaire> niceone! but people who don't know it think it's almost the same language

[21:04] <pmichaud> parrotsketch may overlap with phasers a bit, but that's probably okay.

[21:04] <lue> here be the patch:    https://gist.github.com/1065930

[21:06] <pmichaud> I'd prefer something with fewer variables.  :-|

[21:07] <lue> At least I didn't add more :)

[21:09] <masak> lue: sub chomp { self.subst(/\n$/, '') }

[21:09] <pmichaud> definitely don't do it with a regex

[21:09] <pmichaud> chomp gets used on IO.lines and needs to be fast

[21:10] <masak> aww :)

[21:10] <masak> but it had no variables! :P

[21:10] <pmichaud> (that's why it's in PIR in master)

[21:11] <masak> lue: you can probably safely replace $rn_idx with *-2, etc.

[21:11] <pmichaud> we don't have whatever closures yet, either.

[21:11] <lue> I didn't realize it, but why not get change substr for chop?

[21:12] <pmichaud> (in .substr)

[21:12] <masak> lue: because chop removes any character, not just newlines

[21:12] <pmichaud> but still, whatever closures is heading towards slower instead of faster

[21:14] <pmichaud> also, I wonder if chomp should chomp a trailing \r, too, and not just \r \n

[21:15] <pmichaud> I think some macs use \r as a newline

[21:15] <diakopter> yeah

[21:15] <lue> I was wondering that too. IIRC, Pre-OSX macs use \r

[21:17] <pmichaud> and we should have tests for all of these cases :)

[21:18] <masak> FYI, making a text adventure game in Perl 6 is *fun*!

[21:20] <lue> pmichaud: [looking at S32-Str/chomp.t] would those tests need to test everything that is already tested for \n ? [or just a simple does it chomp for now]

[21:21] *** y3llow_ joined
[21:22] *** pothos_ joined
[21:23] *** y3llow left
[21:23] *** y3llow_ is now known as y3llow

[21:24] *** pothos left
[21:24] *** pothos_ is now known as pothos

[21:24] *** drbean joined
[21:25] *** bluescreen100 joined
[21:26] <lue> .oO(Actually, if we really wanted to be thorough, we'd test \n\r too.)

[21:26] *** bluescreen10 left
[21:26] *** bluescreen100 left
[21:27] <masak> lue: want to test-drive my text adventure game?

[21:27] <pmichaud> we should test \n, \r, and \r\n

[21:27] <pmichaud> I don't think there are any systems that have \n\r

[21:27] <pmichaud> and we should test strings that are 0, 1, and 2 chars long

[21:28] <pmichaud> afk for a while

[21:28] <diakopter> and ones that are mixed line enndings

[21:28] <pmichaud> ...mixed line endings?

[21:28] <masak> pmichaud: Classic Mac OS has \n\r

[21:28] <diakopter> just \r

[21:29] <masak> oh, ok.

[21:29] <diakopter> LF+CR: Acorn BBC spooled text output

[21:29] <diakopter> sez wikipedia; lol

[21:29] <lue> masak: yes. Just tell me if it runs on nom or master [I would guess master]

[21:29] <masak> master.

[21:29] *** simcop2387 left
[21:30] <masak> lue: https://github.com/masak/crypt/blob/5675bb8ce35e52978623d123a31833e25ef1ba81/crypt.pl

[21:31] <masak> just the rooms so far. that's how far I got today ;)

[21:31] <masak> I have an approximate idea for what to fill the rooms with (items, puzzles...)

[21:34] *** simcop2387 joined
[21:36] *** fhelmberger_ left
[21:37] *** wamba joined
[21:39] <masak> also, roles are perfect for text adventure games :)

[21:39] <masak> Pullable, Drinkable, LightSource, Openable...

[21:40] <masak> Readable, Container, Takeable...

[21:42] *** am0c left
[21:45] <jlaire> hmm, roles seem very similar to Scala's traits

[21:46] <masak> I'd guess they are.

[21:46] <masak> they're called 'traits' in Smalltalk, too.

[21:46] *** Patterner left
[21:48] *** Psyche^ joined
[21:48] *** Psyche^ is now known as Patterner

[21:59] *** am0c joined
[22:13] <lue> hm. I'm having trouble pushing to the roast repo.

[22:15] *** everbrew left
[22:18] <masak> lue: what kind of trouble?

[22:19] <lue> connection timed out

[22:19] <lue> I thought it was a problem here at home but it doesn't seem like it.

[22:19] <masak> does it say why?

[22:19] <masak> I can push to github without a problem.

[22:20] *** Zapelius joined
[22:21] *** sivoais joined
[22:22] <masak> lue: did you have a chance to try the game? :)

[22:24] <masak> blog post! http://strangelyconsistent.org/blog/june-28-2011-roles

[22:25] <jlaire> masak: "WHereas" <-- s/H/h/

[22:27] <lue> masak: I will, I just need to switch over to master.

[22:27] <lue> the push command is 'git push origin master', right?

[22:27] <jlaire> masak: "hearts content" --> "heart's content"

[22:27] <jlaire> lue: right

[22:28] <masak> jlaire: thanks, thanks. fixing, fixing. :)

[22:29] <jlaire> masak: yay, this time I was FIRST!11!!

[22:29] <lue> Hm, I think it's a problem with the remote server I use :/ [will push tests and recompile master later]

[22:30] <jlaire> "option 3 is the right answer" <- I'm not disagreeing, but Scala explicitly goes with option 2

[22:30] *** impious left
[22:31] <masak> jlaire: aw, that's a shame.

[22:31] <jlaire> the Perl 6 way feels saner

[22:31] <jlaire> much saner

[22:31] <masak> jlaire: the conflict flagging is one of the really nice things about roles.

[22:33] <jlaire> oops, it was "our hearts content", so --> "our hearts' content" (right? not a native speaker)

[22:34] *** am0c left
[22:35] <masak> guess it could be argued both ways...

[22:36] <jlaire> masak: these blog posts are really nice, they vaguely remind me of "Learn You a Haskell"

[22:36] <lue> I think "our heart's content" is correct (because I've never heard someone say "our hearts' content")

[22:36] <jlaire> is there one heart or more

[22:36] <thou> hearts'

[22:37] <jlaire> google agrees with hearts'

[22:37] <jlaire> (the first few results anyway)

[22:37] <masak> oki

[22:37] <masak> thanks', guys'

[22:38] *** beekor left
[22:39] *** smallfoot- joined
[22:39] <lue> The best thing I've gotten out of your posts so far is learning what map and grep do.

[22:39] <smallfoot-> you guys heard Duke Nukem Forever got released?

[22:40] <smallfoot-> so when is Perl 6 getting released?

[22:40] *** lichtkind joined
[22:40] <masak> smallfoot-: every month since 2008.

[22:41] <smallfoot-> oh

[22:42] <smallfoot-> when is stable release?

[22:42] <lichtkind> about this duke thing I wanted post a motnh ago

[22:42] <dalek> roast: 48e879e | lue++ | S32-str/chomp.t:

[22:42] <dalek> roast: Added tests to S32-str/chomp.t for other newline styles (\r, \r\n), as well as for strings with less than 2 characters.

[22:42] <dalek> roast: review: https://github.com/perl6/roast/commit/48e879ebd9

[22:42] <smallfoot-> people say perl is ugly, is that so?

[22:42] <masak> smallfoot-: Rakudo Star was a milestone towards stable releases, and we'll soon start a new series that's even more stable.

[22:43] <jlaire> smallfoot-: some of those same people say that Perl 6 is beautiful

[22:43] <masak> smallfoot-: I've seen some really beautiful Perl and some really ugly Perl. it's just a substrate.

[22:43] <smallfoot-> masak, alright, but when is the really stable release coming, you know like the gold release, like 6.0, not beta, not release candidate

[22:43] <smallfoot-> jlaire, Perl 6 is more beautiful / less ugly, than Perl 5?

[22:43] <masak> smallfoot-: I wish I could give you a date. we're working really hard, and we're really expectant, but there's a lot to do.

[22:43] <jlaire> smallfoot-: yes

[22:44] <smallfoot-> jlaire, cool

[22:44] <smallfoot-> masak, alright

[22:44] <masak> smallfoot-: right now we're not in a place where we can predict the 6.0.0 release.

[22:44] <masak> but that doesn't mean that we're idle. far from it.

[22:44] <thou> we're cranking

[22:45] <smallfoot-> i used to code some in Perl, like a decade ago... but is Perl relevant these days with Python and Ruby?

[22:45] <lue> masak: the text adventure is good so far. I can't help but notice the room description comes up only once (known as BRIEF mode in Infocom games)

[22:46] <thou> n

[22:46] <thou> l

[22:46] <thou> x smallfoot

[22:46] <thou> put smallfoot in mouth

[22:46] <thou> get smallfoot

[22:46] <thou> put smallfoot in mouth

[22:47] <TimToady> What, with your bare hands?!?

[22:47] <thou> smallfoot-: yes, the perl5 community is still very active, too, and there's tons of modules on cpan, etc. it's still a very relevant and great environment for getting things done

[22:48] *** mtk left
[22:48] <sjohnson> smallfoot-: uhh... in probably all our opinions, perl is our preferred choice over those other two languages you mentioned

[22:48] <sjohnson> despite it being 2011!

[22:48] *** dorlamm joined
[22:48] <masak> lue: glad you like it :)

[22:49] *** cooper left
[22:49] <tadzik> smallfoot-: there've been cases of Perl people leaving to Ruby and then coming back to Perl seeing its evolution

[22:49] *** cooper joined
[22:49] <masak> lue: yes, I'm trying to emulate Infocom games a bit.

[22:50] *** PerlJam left
[22:50] *** PerlJam joined
[22:50] <masak> smallfoot-: keeping just to Perl 5, there's no other language out there with that kind of module repository. it's very large and very active.

[22:50] <lue> I'd recommend printing the room name. For a second I thought I entered an under-developed part of the game :)

[22:50] *** envi left
[22:51] <masak> lue: yes, I realized that too. thanks for the reminder.

[22:51] <masak> I'll push that change, then go to bed.

[22:51] <masak> lue: I also need to fix the "duplicate exits" problem somehow.

[22:52] <smallfoot-> masak, so Perl is good because large number of modules? thats same reason people argue that Fortran is good, no other language has as much math/algorithm modules

[22:53] <masak> smallfoot-: :)

[22:53] <masak> smallfoot-: yes, that's one of the reasons Perl is good.

[22:53] <lue> "duplicate exits", as in both out and south point to the same place?

[22:53] <masak> lue: right.

[22:54] <masak> smallfoot-: it's also good because it's a very malleably medium. it's easy to translate ideas about a program to a program. people around here call it Perl's "whipuptitude".

[22:54] <jlaire> smallfoot-: is PHP relevant these days with Python and Ruby?

[22:54] <masak> urgh, I wouldn't defend Perl by comparing it to PHP :P

[22:55] *** huf left
[22:55] <smallfoot-> jlaire, yeah, but its been losing some ground to Python and Ruby

[22:55] <jlaire> surely Perl is better, but my point is that _even PHP_ is still relevant :)

[22:55] <lichtkind> smallfoot-: perl is relevant because you get things done faster

[22:55] <jlaire> there's definitely more public hype around python and ruby

[22:55] <smallfoot-> y

[22:55] <smallfoot-> ya

[22:55] <Khisanth> masak: meh that cuts both ways

[22:56] <lichtkind> smallfoot-: with more modules we mean modules that are not existing in python or ruby

[22:56] <Khisanth> some people take it to mean it's fine write things in the messiest way possible because 'it works'

[22:57] <masak> Khisanth: yes, I'm aware of that.

[22:57] <lichtkind> smallfoot-: plus the whole cpan inrastructure is far beyond anything you will find in ruby or python

[22:57] <masak> Khisanth: and not shunning those people is part of being open-minded towards "baby Perl", I guess.

[22:57] <masak> Khisanth: it's OK to start out simple and unstructured.

[22:57] <lichtkind> thou: <sob> you left me again

[22:58] <masak> lue: pushed

[22:58] <masak> 'night, #perl6

[22:58] *** masak left
[22:58] <lichtkind> gnight masak

[22:59] <lue> Python's good, as long as you don't need pointers (binding in Perl6) or switch statements...

[22:59] <Khisanth> those are not the people I am referring to ...

[22:59] <thou> lichtkind: i know, i've not had much slack time of late :-/

[22:59] *** huf joined
[22:59] <thou> lichtkind: but i'm getting bits of progress on november-wiki

[22:59] <lichtkind> thou: what you mean by that

[22:59] <lichtkind> november is dead methinks

[23:00] <thou> zombie november

[23:00] <thou> november wants braaaaiiiiinsssss

[23:00] <lichtkind> your perl 5 version?

[23:00] <thou> no, perl6

[23:01] <lichtkind>  great

[23:01] *** cdarroch left
[23:01] *** aindilis joined
[23:01] <lichtkind> thou: dont worry it gets better http://www.youtube.com/watch?v=VeEunG9M2s0&feature=fvst

[23:02] <thou> tadzik: do you have any tricks for understanding what panda is doing? i can't find a verbose mode. i have an issue where 'panda install Digest::MD5' fails the 2nd test, but if i check it out from git and run 'PERL6LIB=$PWD/lib prove -eperl6 -r t' it works just fine, but i can't tell why the panda one fails

[23:05] <lichtkind> smallfoot-: got enough answers?

[23:08] *** cooper left
[23:09] *** cooper joined
[23:12] *** stepnem left
[23:14] *** stepnem joined
[23:16] <tadzik> thou: well, the tests indeed fail for me

[23:16] *** dorlamm left
[23:17] <tadzik> I think panda even has an option of being verbose, it's just the getopt which is broken

[23:17] <tadzik> or maybe not

[23:18] <tadzik> that needs fixing

[23:20] <tadzik> thou: looks like compiling the module to pir breaks tests somehow

[23:22] <tadzik> panda compiles the modules first, hence the tests break. If you install ufo and run ufo && make test inside the cloned dir, you'll see the tests fail too

[23:29] *** orafu left
[23:29] *** orafu joined
[23:39] *** wamba left
[23:51] <thou> tadzik: thanks, i'll try to look into that

[23:51] <thou> or i'll just ignore it for now, maybe ....

[23:52] <thou> tadzik: i had a problem that when i added "say 'debugging stuff'" in various places around Panda/*.pm, etc., it didn't show up on the terminal for some reason. i didn't spend much time on it though

[23:56] *** molaf_ joined
[23:59] *** molaf left
