[00:02] *** kerby joined
[00:03] *** kerby left
[00:04] *** benabik joined
[00:05] *** benabik left
[00:10] *** TheMartianGeek left
[00:11] *** mikehh joined
[00:15] <jnthn> Grr, too tired to think.

[00:15] <jnthn> More hacking tomorrow

[00:15] <jnthn> &

[00:16] *** M_o_C joined
[00:19] *** [particle] left
[00:20] *** [particle] joined
[00:22] *** awwaiid left
[00:24] *** mikehh left
[00:24] *** mtk left
[00:33] *** mtk joined
[00:37] *** Rotwang left
[00:41] *** woosley joined
[01:15] *** M_o_C left
[01:44] *** imamelia joined
[01:49] *** bluetom joined
[02:02] *** noganex_ left
[02:06] *** noganex joined
[02:08] *** bluetom left
[02:09] *** coldhead left
[02:24] *** donri left
[02:26] *** slavik2 joined
[02:28] *** pmurias left
[02:32] *** cdarroch left
[02:40] *** risou left
[02:45] *** cls_bsd joined
[02:46] *** awwaiid joined
[02:47] *** tyatpi_ joined
[02:52] *** wooden left
[03:04] *** envi joined
[03:42] <colomon> Does anyone out there have a handy framework for using git-bisect with Rakudo?  I'm hoping to pin down which commits hosed our speed in the prime.pl benchmark....

[03:42] <colomon> afk # much-needed sleep

[03:47] *** noganex left
[03:55] *** woosley left
[03:58] *** noganex joined
[04:35] <awwaiid> greetings

[04:37] <awwaiid> I'm writing a blog post about the Whatever-star. Is that an ok thing to call it? "Whatever-star", that is.

[05:08] <sorear> sure why not

[05:24] *** risou joined
[05:32] <awwaiid> lovely

[05:32] <mberends> sorear: so I'm wanting to add a 'now' to niecza that compiles down to 'Instant.new(val=>Q:CLR{DateTime.Now.ToFileTime()*0.0000001})' but that's not how it's done. How is it done?

[05:34] <mberends> the Q:CLR is pseudocode for the C# that returns the right value

[05:36] <mberends> probably to be added near niecza/lib/CORE.setting:1188

[05:38] *** imamelia left
[05:41] *** orafu left
[05:41] <sorear> niecza: say now;

[05:41] <p6eval> niecza v3-67-geec33bf: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method term:sym<now> not yet implemented at /tmp/hGBRXSWM5O line 1:␤------> [32msay now[33m⏏[31m;[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 387 (CORE die @ 2)␤  at

[05:41] <p6eval> ../home/p6eval/niecza/src/ST…

[05:41] *** orafu joined
[05:41] <mberends> niecza: my $i = Instant.new(val=>99); say $i.to-posix

[05:42] <p6eval> niecza v3-67-geec33bf: OUTPUT«99␤»

[05:42] <mberends> rakudo: say now.to-posix[0]

[05:42] <p6eval> rakudo a357c9: OUTPUT«1299994947.22292␤»

[05:42] <sorear> mberends: for some reason I can't quite remember, there's already a Builtins.GetNow which returns a value suitable for val =>

[05:43] <mberends> ok, I'll search for that. I don't want you to give me a fish, I want you to  teach me how to fish.

[05:43] <sorear> mberends: probably because of the 'long' termorary that would otherwise be required

[05:43] *** imamelia joined
[05:44] <sorear> naturally

[05:44] <sorear> there are three ways to do this - the wrong way, the simple correct way, and the yak-shaving way

[05:45] <sorear> the first is seen at NieczaCompiler.pm6 line 14

[05:45] <sorear> since TimToady is strongly opposed to conditional compilation, backend-specific primitives like rawscall really, really, really shouldn't be used in CORE.setting

[05:46] <mberends> I see

[05:46] <sorear> hrm

[05:46] <sorear> it seems the "simple correct way" is already half done

[05:47] <sorear> you can use Q:CgOp { (bif_gettimeofday) } to access GetNow in a backend-neutral way

[05:47] <mberends> ok, sounds sane

[05:48] <sorear> so basically what you need to do is term:<foo> handling

[05:49] <sorear> NieczaActions.FALLBACK is the interesting bit here

[05:49] <sorear> it's... a big ugly ball of workarounds

[05:49] <sorear> sorry

[05:49] <mberends> not just a CORE.setting addition?

[05:49] <sorear> nope.

[05:50] <sorear> if it were just a function, it could be a CORE.setting addition

[05:50] <mberends> I can imagine that being Wrong somehow

[05:51] <sorear> term:<foo> is part of the operator overloading stuff

[05:51] <sorear> an unimplemented part, it seems :/

[05:51] <dalek> book: d9d8f42 | duff++ | src/basics.pod:

[05:51] <dalek> book: [basics] add some verbage on scopes and sigils

[05:51] <dalek> book: review: https://github.com/perl6/book/commit/d9d8f4276a

[05:51] <dalek> book: dfed068 | duff++ | src/grammars.pod:

[05:51] <dalek> book: [grammars] Add some more prose, change some wording

[05:51] <dalek> book: review: https://github.com/perl6/book/commit/dfed06855b

[05:51] <dalek> book: c661a1d | duff++ | src/grammars.pod:

[05:51] <dalek> book: [grammar] add a note about POD processing

[05:51] <dalek> book: review: https://github.com/perl6/book/commit/c661a1d0d6

[05:51] <dalek> book: 1ad574f | duff++ | src/classes-and-objects.pod:

[05:51] <dalek> book: [classes] rewording

[05:51] <dalek> book: review: https://github.com/perl6/book/commit/1ad574f2d0

[05:53] <sorear> mberends: how interested are you in figuring out how to do this?

[05:53] <sorear> I have spoilers.

[05:53] <mberends> This was an itch to scratch because of my future benchmarking plans (popolnik) but I'm not in the mood for an ugly ball of workarounds, I think I'll shelve this idea for a while. As a niecza n00b developer, I'll take a look at the LHF first.

[05:53] <sorear> popolnik?

[05:54] <mberends> unpublished, a smoker results aggregator

[05:54] <sorear> once I get niecza building again after the current refactor I'll LHFify now

[05:54] <mberends> :D

[06:01] <mberends> (popolnik is Slovak for ashtray)

[06:08] *** takadonet1 joined
[06:08] *** takadonet1 left
[06:08] <dalek> niecza: a800dde | sorear++ | / (6 files):

[06:08] <dalek> niecza: Refactor Op::SubDef to delay choosing lexical name

[06:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a800dde44b

[06:09] *** Bzek left
[06:09] *** Bzek joined
[06:10] <mberends> sorear: I think I can use gettimeofday() as a workaround in niecza/lib/Test.pm6 for the time being. Experimenting with that...

[06:13] <dalek> niecza: 7caf678 | sorear++ | src/niecza:

[06:13] <dalek> niecza: Implement term:<> categoricals

[06:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7caf6780e3

[06:13] <sorear> mberends: term:<now> is now LHF

[06:13] <mberends> oh cool. That is quick customer service!

[06:23] <mberends> sorear: is there a way to expose Environment.GetEnvironmentVariable() ? I know the whole %*ENV thing is a bigger yak, it was in Rakudo as well.

[06:25] <sorear> yes

[06:25] <sorear> (the main reason I haven't done %*ENV is that tied hashes aren't there yet)

[06:25] <sorear> to add a completely new OS primitive:

[06:26] <sorear> 1. add a method to the CgOp class, following the bif_xxx pattern

[06:26] *** nymacro joined
[06:26] <sorear> 2. add a clause in the pile of stuff around CLRBackend.cs line 3200

[06:27] <sorear> 3. add a wrapping function to Builtins.cs, if needed

[06:27] <sorear> 4. add a function to CORE.setting to wrap the new op

[06:27] <mberends> 5. profit!

[06:28] <sorear> 5. (optional, only for 'hot' functions) add a clause to NieczaPassSimplifier.pm6 to inline direct calls

[06:28] <mberends> looks like a nice yak to shave

[06:28] <sorear> it's like the opposite of a yak

[06:29] *** Chillance joined
[06:29] <sorear> it's something small I have to do far too many times

[06:29] <sorear> not a big one-time annoyance

[06:29] <mberends> .oO(what's the opposite of a yak IRL?)

[06:29] <sorear> in this case, step 3 won't be needed, as NAM can handle str->str fine

[06:30] <sorear> actually it would probably be better to copy the implementation of path_file_exists

[06:30] <mberends> to me the first time will be a shaving task :)

[06:31] <sorear> that already demonstrates how to call a CLR function directly

[06:31] <mberends> yes, that's a good similar case

[06:32] <sorear> tip: don't modify CgOp.pm6 unless you really want to recompile about 5,000 lines of downstream code.  play with the augments in src/niecza instead.

[06:32] <mberends> thanks. I'll be entering timesharing mode soon, as Sunday dawns in NL.

[06:32] <sorear> timesharing mode?

[06:32] <mberends> multitasking IRL

[06:33] <sorear> is sunday the start of the NL work week?

[06:33] <mberends> doing other stuff around the house

[06:33] <mberends> no, Sunday is for home. Sometimes I go to $work for a break ;)

[06:38] *** coldhead joined
[06:42] *** Bzek_ joined
[06:44] *** Bzek left
[06:47] *** nymacro left
[06:47] *** nymacro joined
[06:57] *** tyatpi_ left
[07:01] <dalek> niecza: 22617be | sorear++ | src/ (5 files):

[07:01] <dalek> niecza: mergeback

[07:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/22617be949

[07:24] *** imamelia left
[07:31] *** xinming joined
[07:34] <moritz_> good morning

[07:34] <mberends> hi moritz_

[07:36] * moritz_ has a wide awake and peaceful baby in his arms

[07:36] <mberends> :-) :-)

[07:41] <dalek> specs: f265507 | moritz++ | S19-commandline.pod:

[07:41] <dalek> specs: [S19] make it possible to the comma in one-liners

[07:41] <dalek> specs: review: https://github.com/perl6/specs/commit/f265507aa1

[07:42] <coldhead> aw

[07:45] <moritz_> s/to/to use/

[07:46] <moritz_> I shouldn't spec hack before being really awake :-)

[07:47] <mberends> moritz_: it looked like you the 'skip' or something ;)

[07:47] <mberends> accidentally

[07:48] <moritz_> I thought I the verb :-)

[07:51] *** justatheory left
[07:53] *** wooden joined
[07:53] *** wooden left
[07:53] *** wooden joined
[08:09] *** risou left
[08:12] *** mtk left
[08:20] *** mtk joined
[08:22] *** Mowah joined
[08:42] *** VXZ joined
[08:54] *** gabiruh joined
[09:14] <masak> good morning.

[09:15] <masak> src/gc/gc_gms.c:2336: failed assertion 'Dead object found!'

[09:15] <masak> colomon: did you encounter failures like this when running the p5 solutions over long strings? I do.

[09:23] *** risou joined
[09:30] <moritz_> probably different parrot revisions

[09:30] *** risou_ joined
[09:32] *** risou left
[09:33] <masak> or different input data. or just some indeterminism somewhere.

[10:02] <masak> rakudo: say any(3, 4) * any(3, 4); say any(3, 4) ** 2

[10:02] <p6eval> rakudo a357c9: OUTPUT«any(any(9, 12), any(12, 16))␤any(9, 16)␤»

[10:02] <masak> junctions and the laws of algebra don't mix well :)

[10:03] <moritz_> junctions and the naively applied laws of algebra don't mix will :-)

[10:05] <masak> are you calling my laws of algebra naïve? :)

[10:05] <masak> they've gotten me this far in life...

[10:06] <moritz_> I just say it's naïve to apply the algebra of real numbers to junctions

[10:06] <moritz_> but there might well be a separate algebra for junctions

[10:08] <masak> sure. some laws do hold out-of-the box.

[10:08] <masak> addition and multiplication are still commutative, for example.

[10:09] *** M_o_C joined
[10:09] <moritz_> and I guess distributivity also holds up

[10:09] <masak> was just going to say that :)

[10:10] <masak> the slightly disturbing thing is that an infix:<**> containing special-casing for an exponent of 2 might well give the any(8, 12, 16) result above.

[10:10] <masak> er, 9*

[10:11] *** isBEKaml joined
[10:13] <moritz_> how so?

[10:13] *** noganex left
[10:13] <moritz_> I mean, how would that happen?

[10:14] <masak> sub infix:<**>($base, $exp) { if $exp == 2 { return $base * $base }; ... }

[10:15] <moritz_> autothreads over $base

[10:15] *** noganex joined
[10:15] <moritz_> ie $base is a Real, not a Junction

[10:17] <moritz_> rakudo: sub pow($base, $exp) { if $exp == 2 { $base * $base } }; say pow(any(3, 4), 2);

[10:17] <p6eval> rakudo a357c9: OUTPUT«any(9, 16)␤»

[10:20] <masak> hm.

[10:20] *** MayDaniel joined
[10:20] <masak> true.

[10:20] <masak> rakudo: sub pow(Mu $base, $exp) { if $exp == 2 { $base * $base } }; say pow(any(3, 4), 2);

[10:20] <p6eval> rakudo a357c9: OUTPUT«any(any(9, 12), any(12, 16))␤»

[10:20] <masak> right. one has to want to cause it to cause it.

[10:25] *** MayDaniel left
[10:26] <moritz_> insert blurb about how Mu type declarations imply that you deal with junctions yourself

[10:29] <isBEKaml> perl6: say substr("camel", 1|2, 3&4);  # :?

[10:30] <p6eval> niecza v3-70-g22617be: OUTPUT«Unhandled exception: Junctions NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 387 (CORE die @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1165 (CORE infix:<|> @ 2)␤  at /tmp/PfaU4Oiwn8 line 1 (MAIN mainline @ 1)␤  at /home/p6eval/niecza/lib/CORE.setting line

[10:30] <p6eval> ..1261 (CORE C5…

[10:30] <p6eval> ..rakudo a357c9: OUTPUT«all(any("ame", "mel"), any("amel", "mel"))␤»

[10:30] <p6eval> ..pugs: OUTPUT«all(VJunc any(VRef <Scalar::Proxy:0x7ff9b979d659>,VRef <Scalar::Proxy:0x7ff9b97a3779>),VJunc any(VRef <Scalar::Proxy:0x7ff9b979f5c9>,VRef <Scalar::Proxy:0x7ff9b97a10d9>))␤»

[10:32] <isBEKaml> hmmm, while autothreading over junctions as above, how does rakudo treat the ordering? Essentially unordered?

[10:33] <moritz_> junctions are unordered intrinsically

[10:33] <isBEKaml> moritz_: I understand. But, when I enter something like above, <any> and <all>. how does Rakudo see them?

[10:33] <isBEKaml> especially, in parameters to subs. 

[10:34] <masak> isBEKaml: <all> binds tighter than <any>.

[10:35] <masak> isBEKaml: just as && binds tighter than ||

[10:35] <masak> rakudo: say any(1,2) + all(3,4); say all(3,4) + any(1,2)

[10:35] <p6eval> rakudo a357c9: OUTPUT«all(any(4, 5), any(5, 6))␤all(any(4, 5), any(5, 6))␤»

[10:36] <masak> so no matter what the ordering is in the expression, the all() junctions are evaluated before the any() junctions.

[10:36] <masak> that's why they end up outermost both times above.

[10:37] <isBEKaml> makes sense. all() overrides everything else. how about none() ?

[10:37] <isBEKaml> a contrived eg. 

[10:38] <isBEKaml> rakudo: say none(1,2) + all(3,4); 

[10:38] <p6eval> rakudo a357c9: OUTPUT«none(all(4, 5), all(5, 6))␤»

[10:38] <isBEKaml> hmmm

[10:38] <masak> none() is just a version of all(), so they're treated the same, I think.

[10:38] <masak> I don't know offhand about the tightness of one().

[10:39] <isBEKaml> spec doesn't say anything about this. S09:955

[10:40] <masak> anything about what? seems that section explains it.

[10:41] <isBEKaml> none() and all(), in the eg above. 

[10:41] <masak> all() and none() get first dibs from left to right.

[10:41] <isBEKaml> the way I see it - it should just be all(3,4). 

[10:41] <masak> isBEKaml: then you've misunderstood junctions a bit.

[10:41] <masak> isBEKaml: they're not intuitive, they're logical :P

[10:41] <isBEKaml> rakudo: all(1,2) + none(3,4) 

[10:42] <p6eval> rakudo a357c9:  ( no output )

[10:42] <isBEKaml> rakudo: say all(1,2) + none(3,4) 

[10:42] <p6eval> rakudo a357c9: OUTPUT«all(none(4, 5), none(5, 6))␤»

[10:42] <isBEKaml> L2R, right. :)

[10:42] <masak> just because you see the word "none" there doesn't mean the compiler will go "oh, so these shouldn't partake in the addition!"

[10:42] <isBEKaml> masak: I have failed several times over at modern algebra. :D

[10:43] <masak> it's more like the compiler goes "hokay, I'll just go ahead and wrap this expression in a none() junction"

[10:44] <moritz_> s/compiler/runtime/ and ss/wrap this/autothread over/

[10:44] <isBEKaml> unionised sets? :?

[10:44] <masak> and a none() junction is as much a junction of a bunch of values as the other three.

[10:44] <masak> it's just that it has a more negative outlook on life.

[10:45] <masak> isBEKaml: sort of. except that junctions aren't really sets.

[10:47] <isBEKaml> rakudo: none(0+1,8*8) + all(14/7, 89%%3) 

[10:47] <p6eval> rakudo a357c9:  ( no output )

[10:47] <isBEKaml> rakudo: say none(0+1,8*8) + all(14/7, 89%%3); ## gack, nosay. 

[10:47] <p6eval> rakudo a357c9: OUTPUT«none(all(3/1, 1), all(66/1, 64))␤»

[10:47] *** donri joined
[10:47] *** coldhead left
[10:48] <isBEKaml> rakudo: say none(0+1,8*8) + all(14/7, 89%3); 

[10:48] <p6eval> rakudo a357c9: OUTPUT«none(all(3/1, 3), all(66/1, 66))␤»

[10:50] <masak> rakudo: say all(1,2) / any(3,0)

[10:50] <p6eval> rakudo a357c9: OUTPUT«all(any(1/3, 1/0), any(2/3, 1/0))␤»

[10:50] <isBEKaml> what I got seems weird to me. :(

[10:50] <masak> why?

[10:51] <isBEKaml> evaluate expressions and perform operation. it goes the other way. 

[10:51] <masak> that's part of the point of junctions.

[10:52] <isBEKaml> maybe, I'll have to re-read the section again. 

[10:57] <masak> maybe you shouldn't start by understanding two junctions in one expression. one junction is easier to see.

[10:57] <masak> rakudo: say 40 + any(1,2,3)

[10:57] <p6eval> rakudo a357c9: OUTPUT«any(41, 42, 43)␤»

[11:10] *** whiteknight joined
[11:14] <isBEKaml> hmm, in the case of all() and none(), the left most autothreads. with others, all() or none(), if present override the rest to be autothreaded. 

[11:14] <isBEKaml> unintuitive but logical. :)

[11:23] <masak> I didn't grok that, but it sounds overly complicated.

[11:24] *** woosley joined
[11:26] *** fisted_ is now known as fisted

[11:30] <isBEKaml> it looks like it. my attention deficit forced me to skip reading it the first time around. 

[11:30] * isBEKaml ducks

[11:31] *** risou joined
[11:31] *** cjk101010 joined
[11:34] *** risou_ left
[11:41] *** donri left
[11:43] *** karupanerura joined
[11:45] *** M_o_C left
[11:50] *** cjk101010 left
[11:57] *** cjk101010 joined
[11:58] *** [particle]1 joined
[11:59] *** [particle] left
[12:02] *** jaldhar left
[12:02] *** jaldhar joined
[12:12] *** LoRe joined
[12:19] *** isBEKaml left
[12:19] *** MayDaniel joined
[12:35] *** kaare_ joined
[12:39] *** kaare_ left
[12:43] *** aloha left
[12:45] *** aloha joined
[12:51] <colomon> masak: I actually don't know.  The benchmarking setup actually just times how long the program runs, it doesn't check the results in any way.

[12:52] <colomon> masak: sounds like a Rakudo or Parrot bug......

[12:53] <masak> oh, it's definitely GC-related (so, Parrot).

[12:53] <masak> I also don't check the results, but I kinda notice when the program dies with a stacktrace. :)

[12:58] * masak .STORE

[13:00] <jnthn> .oO( what's being stored in masak? )

[13:02] <tadzik> most likely the groceries

[13:05] *** tyatpi_ joined
[13:23] *** M_o_C joined
[13:30] *** sji joined
[13:31] *** sji left
[13:31] *** sji joined
[13:31] *** risou_ joined
[13:32] *** sji left
[13:33] *** sji joined
[13:34] *** risou left
[13:35] *** sji left
[13:36] *** sji joined
[13:36] *** sji left
[13:37] *** sji joined
[13:38] *** sji left
[13:39] *** sji joined
[13:40] *** sji left
[13:43] *** karupanerura left
[13:45] *** M_o_C left
[14:05] <colomon> masak: the other thing is I was running everything on my box with 8 gigs of RAM.  :)

[14:07] *** cjk101010 left
[14:08] *** Axius joined
[14:10] <tadzik> hmm, the shiny new IO.copy hangs on directories

[14:13] *** UAACIEU joined
[14:16] <tadzik> Module to port: ExtUtils::Command

[14:18] <mberends> aye :)

[14:19] <tadzik> there was this Rakudo Star wiki, with Most Wanted List

[14:19] <tadzik> or maybe we should start one in the ecosystem

[14:20] <jnthn> Sounds good

[14:20] <jnthn> It's another thing to point people who want to contribute at

[14:21] <tadzik> aye

[14:21] <mberends> then also make sure it's prominently linked on perl6.org

[14:26] <tadzik> https://github.com/perl6/ecosystem/wiki/Most-Wanted:-Modules-to-write-port

[14:29] * mberends worries about an unhelpful flood of module names

[14:30] <tadzik> oh, there aren't that many of us so we won't be able to track who did this :)

[14:31] <mberends> s/won't/will/

[14:32] <tadzik> hmm, that's not what I meant :)

[14:32] <tadzik> There aren't that many of us that the seek for the flooder will be difficult. There

[14:35] <mberends> ok, it looks like you have to be logged in to edit the page :)

[14:36] <tadzik> aye. I reported that as a Githubbug around a year or two ago. They said: "We're working on it"

[14:50] <dalek> perl6.org: 2aeec31 | tadzik++ | source/getting-started/involved.html:

[14:50] <dalek> perl6.org: [getting involved] Add a like to the Most Wanted page on the ecosystem wiki

[14:50] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/2aeec31c26

[14:50] <dalek> perl6.org: 3386761 | tadzik++ | source/compilers/index.html:

[14:50] <dalek> perl6.org: [compilers] Move Niecza higher on the list

[14:50] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/338676189d

[14:51] *** imamelia joined
[14:51] <tadzik> mberends: well, there's a risk some people will rush with Catalyst, Mason, DBIx::Class and then say "what? Of course it's Most Wanted"

[14:51] <mberends> indeed, there could be so many such "clever" remarks

[14:52] <tadzik> we could grant a Captain Obvious Award to ones who add such entries :)

[14:52] <mberends> +1

[14:55] *** wooden left
[14:55] * moritz_ is General Oblivious

[14:56] <mberends> :-) I've just put the following into an executable /usr/local/bin/niecza:

[14:56] <mberends> #!/bin/sh

[14:56] <mberends> MONO_PATH=/home/martin/2011/perl/niecza/run /home/martin/2011/perl/niecza/run/Niecza.exe "$@"

[14:56] <mberends> and it works lovely!

[15:07] <masak> \o/

[15:10] *** gabiruh left
[15:17] *** gabiruh joined
[15:20] <mberends> masak: did you really mean "Perl 6 coding context" in http://strangelyconsistent.org/blog/p5-find-the-longest-common-substring ?

[15:27] <masak> no :) will fix.

[15:30] *** icwiener joined
[15:32] *** ggoebel joined
[15:38] *** _twitch joined
[15:38] <mberends> niecza currently aborts all of the p5 solutions, I wonder how soon it will be able to run some of them

[15:55] *** imamelia left
[15:56] <masak> mberends: aborts due to syntactical problems?

[15:58] *** woosley left
[15:58] <masak> er, I mean due to NYIisms?

[15:59] *** mtk left
[15:59] *** dual joined
[16:00] <masak> oh, and typo fixed. mberends++ http://strangelyconsistent.org/blog/p5-find-the-longest-common-substring

[16:01] *** Axius left
[16:07] *** mtk joined
[16:09] *** MayDaniel left
[16:13] <sorear> good * #perl6

[16:16] <sorear> hello mberends

[16:16] <masak> sorear! \o/

[16:16] <sorear> does 'now' work yet?

[16:17] <mberends> hi sorear, not yet, I was distracted ;-)

[16:17] *** envi left
[16:18] *** Patterner left
[16:19] <mberends> sorear: could niecza (with a little fixin') run any of these 2010 P6 Coding Contest entries? http://strangelyconsistent.org/p6cc2010/

[16:19] *** Psyche^ joined
[16:19] *** Psyche^ is now known as Patterner

[16:25] <mberends> niecza p5-colomon.pl Undeclared routine: 'exists' used at line Any() Unhandled exception: Check failed

[16:25] <mberends> niecza p5-fox.pl Unhandled exception: No value in mainline available for parameter $j

[16:25] <mberends> niecza p5-matthias.pl Unhandled exception: Unable to resolve method push in class Hash

[16:25] <mberends> niecza p5-moritz.pl Multi routines NYI at /home/martin/2011/perl/p5-moritz.pl line 43

[16:25] <mberends> niecza p5-util.pl Unhandled exception: System.InvalidCastException: Cannot cast from source type to destination type.

[16:27] <sorear> foxp3 looks like will run

[16:28] <mberends> and my unofficial solution niecza p5-mberends.pl Undeclared routine: 'index' used at line Any()134

[16:28] <mberends> sorear: you could wipe the board with the CLR speed

[16:29] *** [particle]1 is now known as [particle]

[16:31] <masak> I predict that next Christmas, Niecza will be a viable implementation for doing p6cc solutions in.

[16:31] <mberends> aye

[16:31] *** mj41_nb joined
[16:31] *** barika joined
[16:31] <masak> today's autopun spotting: "Circular logic is the best type of logic, because it's circular." (from @acangiano)

[16:32] <mberends> lol

[16:32] <masak> it's funny how autopuns keep being funny, despite being so formulaic ;)

[16:33] <sorear> mberends: want commit bit?

[16:33] <mberends> sorear: definitely

[16:34] <sorear> done

[16:34] <mberends> thanks

[16:34] *** mj41_nb left
[16:36] *** mj41_nbx joined
[16:37] *** barika left
[16:39] *** MayDaniel joined
[16:41] *** justatheory joined
[16:43] *** dju__ left
[16:44] *** barika joined
[16:53] *** benabik joined
[16:58] *** mj41_nbx left
[17:06] *** tyatpi_ left
[17:12] *** mj41_nbx joined
[17:13] *** MayDaniel left
[17:16] *** mj41_nbx left
[17:21] *** kaare_ joined
[17:24] *** allbery_b joined
[17:29] *** tyatpi_ joined
[17:34] *** imamelia joined
[17:36] <masak> imamelia: your nick reminds me of http://bash.org/?328464 :)

[17:37] <Trashlord> masak: haha

[17:38] <imamelia> I'm actually TheMartianGeek, but since I used this nickname on another server long before I ever joined any Perl-related channels and I'm not familiar enough with my IRC client to set more than one nickname as default, that's what it turned out as.

[17:39] *** imamelia is now known as TheMartianGeek

[17:39] <masak> ah, now I recognize you! :)

[17:39] <TheMartianGeek> (In fact, there are quite a few other things I can't figure out how to do with it either...)

[18:02] <moritz_> TheMartianGeek: suggesting to read your IRC client's documentation won't do much good, will it?

[18:05] <mberends> RTFM is so last century

[18:07] <twinshadow> wicked burn

[18:09] <TheMartianGeek> [12:02] <moritz_> TheMartianGeek: suggesting to read your IRC client's documentation won't do much good, will it? <-- Lousy documentation.  And some of the things it says are possible, I've tried with no luck.

[18:11] <mberends> TheMartianGeek: xchat works nicely for me, even though I don't know much about it. Try some other programs.

[18:11] <flussence_> I tried to figure out how to write irssi's scrollback to a file the other day. The docs literally cut off a few pages in saying "I couldn't be bothered to do the rest"

[18:12] <mberends> naughty irssi, no biscuit!

[18:16] <sorear> there are no good irc clients; the protocol sucks too much

[18:18] <sorear> (actually I got into Perl 6 because I wanted to use it to write an irc client, but gave up)

[18:18] <masak> yeah, probably too early still.

[18:18] <masak> maybe another good goal for Niecza? :)

[18:19] *** donri joined
[18:20] <sorear> interesting that in multi sub infix:<+>(Int $x, Int $y) { ... } the colonpair adds to the short name

[18:20] <sorear> while in multi token infix:sym<+> { <...> } the colonpair adds to the long name

[18:20] <masak> huh. never thought of that.

[18:21] <masak> though the first form doesn't really look like a colonpair...

[18:21] <tadzik> hola zebras

[18:21] * sorear is trying to build a single unified conception of "multi"

[18:22] <sorear> does any current implementation support "my proto token"?

[18:22] <masak> tadzik! \o/

[18:22] <masak> tadzik: 5K! \o/

[18:22] <masak> oh wait. wrong tzadik... :)

[18:49] *** _twitch left
[18:57] <flussence_> .oO( are the [← →] arrows in DejaVu Sans vertically misaligned? or is there a reason I'm not getting... )

[19:04] <dalek> niecza: af2dab4 | sorear++ | src/ (9 files):

[19:04] <dalek> niecza: Remove stale hashes, workaround bitop definitions

[19:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/af2dab4548

[19:04] <benabik> flussence_: They don't look aligned in Monaco either.

[19:05] *** imamelia joined
[19:06] <mberends> TheMartianGeek: you can run, but you can't hide!

[19:07] *** TheMartianGeek left
[19:07] *** imamelia is now known as TheMartianGeek

[19:12] <dalek> rakudo: 592e298 | tadzik++ | src/core/IO.pm:

[19:12] <dalek> rakudo: Don't try to copy directories in IO::copy. Previously it hanged, now it gives a friendly die()

[19:12] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/592e2989f0

[19:17] *** TheMartianGeek left
[19:27] <sorear> I liked "imamelia" better

[19:29] <masak> who wouldn't like an imam named Elia? ;)

[19:30] *** frodwith joined
[19:48] <tadzik> http://nopaste.snit.ch/37334 -- could someone give me a hand with this one?

[19:49] <jnthn> Rakudo is giving the right complaint

[19:49] <jnthn> There is no sub foo

[19:49] <tadzik> yeah, there is a method though

[19:50] <jnthn> self.can('&foo').wrap({ ... }) may do it

[19:50] <jnthn> cah

[19:50] <jnthn> self.can('foo').wrap({ ... }) 

[19:50] <jnthn> Or look in .^methods

[19:50] <tadzik> why the .can part?

[19:50] <tadzik> now I get Method 'wrap' not found for invocant of class 'P6Invocation'

[19:51] <jnthn> Figured that may happen

[19:51] <jnthn> Well, easy way is to make it an our method and then &A::foo.wrap

[19:51] *** Rotwang joined
[19:51] <jnthn> But looking in .^methods to find it would also work I guess.

[19:51] <tadzik> well, that can be done with just 'method foo { say "before"; callsame }'

[19:52] <jnthn> No, then .wrap the thing you find

[19:52] <jnthn> You could also do that but I guessed you wanted to wrap the original...

[19:53] <tadzik> well, I just wanted the 'before' from Moose, there or another way. Not sure which one will be more correct

[19:54] <masak> maybe worth adding that this will be fixed with the nom branch merge...

[19:54] *** TheMartianGeek joined
[20:01] *** MayDaniel joined
[20:04] <tadzik> as everything, including the black spots on the sun :)

[20:04] <masak> yeah. I submitted those back in '08.

[20:06] <sorear> wrap is basically nothing like Moose's before

[20:07] <sorear> jnthn is adamant that Moose's before is not needed in core Perl 6

[20:07] <jnthn> sorear: er

[20:07] <jnthn> sorear: When did I say that

[20:07] <jnthn> ?

[20:08] <sorear> jnthn: around a year ago.  might've been TimToady.

[20:08] <lue> hello world! o/

[20:08] <sorear> hi leu

[20:08] <mberends> hellue! o/

[20:10] <masak> lue! \ue/

[20:11] <sorear> niecza: say ?Bool

[20:11] <p6eval> niecza v3-71-gaf2dab4: OUTPUT«Unhandled exception: System.InvalidCastException: Cannot cast from source type to destination type.␤  at Niecza.CtxJustUnbox`1[System.Boolean].Get (Niecza.Variable obj) [0x00000] in <filename unknown>:0 ␤  at CORE.C108_Bool_2EStr (Niecza.Frame ) [0x00000] in <filename

[20:11] <p6eval> ..unknown>:0 ␤ …

[20:11] <masak> "Cannot cast from source type to destination type" -- what else would you cast to and from? :P

[20:12] *** Bzek joined
[20:14] <tadzik> Nominal type check failed for parameter '$p'; expected Pies::Project but got Str instead -- could those include line numbers by any chance?

[20:15] <jnthn> The backtrace should.

[20:15] <tadzik> it maybe doesn't like .pir files

[20:15] *** Bzek_ left
[20:25] *** jaldhar left
[20:25] *** jaldhar joined
[20:27] <Util> flussence_: To write Irssi's scrollback to a file, use: /lastlog -file some_file_name

[20:28] <flussence_> argh, should've known it was something simple.

[20:28] *** coldhead joined
[20:29] <Util> Don't feel bad; I happened to look for that functionality a few days ago, and had to read *every* option in the command reference until I got to /lastlog.

[20:30] <mberends> well it would be last, wouldn't it? ;)

[20:32] <Util> Did I just slip into a "my keys are always in the last place I look for them" joke? Doh!

[20:33] <Util> I had to read over half the manual to find the option.

[20:33] <Util> s/over/almost/

[20:34] * Util obviously needs to recharge; supper &

[20:36] <masak> I get the feeling that most people who do the "keys in last place I look" thing aren't aren't really joking. more likely they're really flummoxed by this correlation.

[20:40] <jnthn> "I found my keys, but I kept looking for a while, just so they weren't in the last place I looked."

[20:40] <dalek> nqp/ctmo: e458b36 | jonathan++ | src/NQP/ (2 files):

[20:40] <dalek> nqp/ctmo: Parse scope declarators on packages; minor actions updates.

[20:40] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/e458b36329

[20:40] <dalek> nqp/ctmo: 2b1619e | jonathan++ | src/ (2 files):

[20:40] <dalek> nqp/ctmo: Compile time symbol installation becomes a task for the SC builder.

[20:40] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/2b1619ed47

[20:40] <dalek> nqp/ctmo: dd93e72 | jonathan++ | src/ (2 files):

[20:40] <dalek> nqp/ctmo: Add storage slot for WHO and get_who/set_who ops.

[20:40] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/dd93e724f1

[20:40] <dalek> nqp/ctmo: 5d47501 | jonathan++ | src/ (2 files):

[20:40] <dalek> nqp/ctmo: .WHO support; make sure we don't ever hand back a C NULL.

[20:40] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/5d47501b69

[20:45] <frettled> :)

[20:46] <frettled> I often find (pun intended) that things usually are not in the last place I look, but either in a place I have already looked (but not good enough), or simply discarded as a place I think I know it cannot be.

[20:46] <frettled> «Nah, that book isn't THAT thin, it can't _possibly_ be in that pile.» -> FAIL

[20:47] <masak> solution: don't have piles.

[20:47] <jnthn> Yeah, they're a pain in the ass!

[20:47] <tadzik> piles++

[20:48] <tadzik> at least everything is in one place

[20:48] <lue> But they're *sooo* easy to make!

[20:48] <mberends> but are your piles stacks or heaps?

[20:49] <tadzik> hmm, it depends

[20:49] <masak> stacks of heaps.

[20:49] <tadzik> heaps of stacks

[20:49] <mberends> HoSoH

[20:49] <tadzik> all(Stack, Heap) does Mess;

[20:50] <mberends> s/Mess/Garbage/

[20:55] *** mj41_nb joined
[20:55] <lue> btw, can anyone take a look at this? I'll take another crack at it in a bit, but I think more eyes would be handy: https://gist.github.com/837820

[20:57] <tadzik> what's the problem?

[20:58] <lue> It's in there, but the grammar only decides to parse one POD block before giving up.

[20:58] <tadzik> is there any other block in there?

[20:59] <lue> yes. The link I gave above has sample REPL usage.

[20:59] <tadzik> yes, I'm looking at that one

[21:00] <tadzik> rule document is <block>+. =begin head1\nHAI\n=end head1\n is the first block, which one is the second?

[21:02] <lue> =for head1\nDERE\n\n

[21:02] <tadzik> oh I get it

[21:02] <tadzik> is <?DEBUG(1)> helpful?

[21:04] <lue> I tried that a while back, and I don't remember it being helpful (partly because it seems to continuously loop through all the possible blocktypes repeatedly before moving on, even if it already matched something, IIRC)

[21:05] <jnthn> That sounds...odd.

[21:05] <masak> lue: that, in all honesty, sounds like a problem with your grammar, rather than with <?DEBUG(1)>

[21:06] <jnthn> The DEBUG shouldn't ever change the control flow.

[21:06] <jnthn> I've seen how it's implemetned and it's hard to imagine it not being pretty honest about what's going on.

[21:06] <masak> lue: fwiw, I'm having a very similar problem with Yapsi right now.

[21:06] <masak> lue: how much do you know about backtracking and token/regex?

[21:07] <tadzik> the DEBUG wfm in this case

[21:08] <lue> I've been guessing it's a problem with (!)backtracking somewhere.

[21:10] <masak> lue: do you know about ratcheting and token/regex?

[21:11] <masak> (and things like the difference between .* and .*: )

[21:11] <lue> I haven't bothered to look up ratcheting yet.

[21:11] <masak> ratcheting is what prevents backtracking.

[21:12] <masak> generally, in a grammar that parses large amounts of text (like Pod), you'll want ratcheting in as many places as possible.

[21:12] <masak> (to make the grammar parse the text in linear time)

[21:18] <lue> There wasn't an advent post on ratcheting, was there? [If not, I'll continue reading the synopses]

[21:21] *** takadonet1 joined
[21:21] <takadonet1> hey all

[21:22] <flussence_> o/

[21:24] <masak> hey takadonet1

[21:24] <takadonet1> question.... How does a child class calls it's parent class method ? i.e class Parent { method fcn {  ... }  } ; Class child does Parent { method fcn {  self.super.fcn ???? } } ; child.new().fcn();

[21:25] <jnthn> Normal was is callwith (or callsame just to pass on same args)

[21:25] <jnthn> s/was/way/

[21:25] <lue> regex is the only one of the three that does backtracking by default, right?

[21:26] <takadonet1> just callsame() ?

[21:26] <jnthn> rakudo: class A { method lol() { say "wtf" } }; class B is A { method lol() { "omg{callsame}bbq" } }; B.lol

[21:26] <p6eval> rakudo 592e29: OUTPUT«wtf␤»

[21:26] <jnthn> oh duh :)

[21:26] <jnthn> rakudo: class A { method lol() { "wtf" } }; class B is A { method lol() { say "omg{callsame}bbq" } }; B.lol

[21:26] <p6eval> rakudo 592e29: OUTPUT«omgwtfbbq␤»

[21:27] <jnthn> Anyway, yes, just callsame() :)

[21:27] <takadonet1> perfect

[21:27] <jnthn> parens optional :)

[21:27] <takadonet1> jnthn++

[21:27] <takadonet1> how's your branch coming along?

[21:27] <jnthn> Slowly but mostly because I'm having to do a bunch of ground work.

[21:27] <jnthn> It'll pay off though.

[21:27] <takadonet1> I know

[21:28] <jnthn> Expect we get resolve a bunch of long-running issues. The dependency tree for doing so just went deeper than I had expected.

[21:28] <takadonet1> well your branch will probably break lots of my workarounds then :)

[21:28] <jnthn> Depends how cheaty/non-Perl-6-y they are :)

[21:29] <takadonet1> some are bad

[21:29] <jnthn> :)

[21:29] <takadonet1> but gotten a huge of the base class somewhat working for bioperl6

[21:29] *** M_o_C joined
[21:29] <takadonet1> huge piece*

[21:29] <masak> takadonet++

[21:29] <jnthn> yay!

[21:30] <takadonet1> https://github.com/cjfields/bioperl6

[21:30] <takadonet1> once all the test are passing, time to cleanup the code

[21:30] <jnthn> :)

[21:32] <dalek> nqp/ctmo: d0337bd | jonathan++ | src/ (3 files):

[21:32] <dalek> nqp/ctmo: Stub in use. Will eventually be where GLOBAL merging and stuff gets done.

[21:32] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/d0337bd9fb

[21:32] <dalek> nqp/ctmo: 3dd30e3 | jonathan++ | src/stage0/ (6 files):

[21:32] <dalek> nqp/ctmo: Push basic use support into the bootstrap.

[21:32] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/3dd30e37a6

[21:35] <lue> I think what I'll do is look through my grammar and place racheting marks where they seem to be useful.

[21:36] <lue> [ and if it turns out they aren't useful, remove them :) ]

[21:36] <masak> lue: sounds good. remember, there's both ratcheting marks, and token/rule.

[21:36] <takadonet1> Is there a way yet to do lazy parsing with a grammar/action combo? i.e return after only parsing a section of an input file?

[21:37] <jnthn> takadonet1: Do you want to resume afterwards?

[21:37] <takadonet1> yes

[21:37] <benabik> Doesn't rule backtrack?

[21:37] <jnthn> takadonet1: Hm

[21:37] <takadonet1> it would be great to do that when parsing very large text files

[21:37] <jnthn> takadonet1: You can't somehow use gather/take to do that?

[21:37] <jnthn> takadonet1: Doing the takes in the action methods?

[21:38] <takadonet1> I was but I believe at the time, something I was using was forcing it to be eager instead of lazy b/c NYI

[21:38] <jnthn> ah

[21:39] <takadonet1> https://github.com/cjfields/bioperl6/blob/master/lib/Bio/Grammar/Actions/Fasta.pm

[21:39] <takadonet1> not sure what operators to use to make that it's lazy

[21:40] <lue> .oO(time to move the rest of my round tuits into the P6 bin.)

[21:40] <jnthn> takadonet1: The thing is that it will already have parsed everything by the time the TOP action method gets called.

[21:41] <jnthn> takadonet1: I suspect the gather needs to be entirely outside of the actions

[21:41] <jnthn> takadonet1: And the take needs to be in action method fasta, for example.

[21:42] <takadonet1> jnthn: i see If I can do that

[21:42] <takadonet1> thx

[21:44] *** MayDaniel left
[21:59] *** TheMartianGeek left
[22:02] *** mj41_nb left
[22:04] <dalek> nqp/ctmo: 76d887f | jonathan++ | / (5 files):

[22:04] <dalek> nqp/ctmo: Re-write the nqp-builtins cheats into NQP and stick 'em in the setting.

[22:04] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/76d887f470

[22:05] *** tyatpi_ left
[22:12] <masak> good night, #perl6.

[22:12] <mberends> o/

[22:13] *** masak left
[22:26] <lue> I think this helps: I found out it's not a "won't parse >1 block" problem, it's simply that it only parses delimited (=begin/=end style) blocks!

[22:27] *** plobsing joined
[22:30] <dalek> niecza: 543ebb3 | (Martin Berends)++ | / (3 files):

[22:30] <dalek> niecza: [my first niecza commit] implement 'now' as per Synopsis 02

[22:30] <dalek> niecza: review: https://github.com/sorear/niecza/commit/543ebb3f6f

[22:30] <takadonet1> mberends++ congratz

[22:30] <mberends> :D

[22:34] <colomon> \O/

[22:35] * colomon apparently has a big head

[22:35] <mberends> rakudo: say now.to-posix[0]

[22:35] <p6eval> rakudo 592e29: OUTPUT«1300055719.72275␤»

[22:35] <mberends> niecza: say now.to-posix[0]

[22:35] <p6eval> niecza v3-71-gaf2dab4: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical &term:<now> in mainline␤␤Server stack trace: ␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ␤  at

[22:35] <p6eval> ..Niecza.CLRBackend.NamProcesso…

[22:36] <benabik> What is now.to-posix[1]?

[22:36] <mberends> like unix time, but with fractional seconds too

[22:36] <benabik> rakudo: now.to-posix[1]

[22:36] <p6eval> rakudo 592e29:  ( no output )

[22:37] <mberends> oh, [1] is a flag whether there is a leap second somewhere

[22:37] <benabik> rakudo: now.to-posix[1].say

[22:37] <p6eval> rakudo 592e29: OUTPUT«Bool::False␤»

[22:37] <benabik> Oddly.

[22:37] <benabik> Odd, rather.  But precisely defining "now" is odd.

[22:39] <moritz_> rakudo: say now.to-posix.perl

[22:39] <p6eval> rakudo 592e29: OUTPUT«(1300055939.16743, Bool::False)␤»

[22:40] <jnthn> rakudo: say("body"); sub MAIN() { say("main") }

[22:40] <p6eval> rakudo 592e29: OUTPUT«body␤main␤»

[22:40] <lue> .oO(it FINALLY works! time to blog...)

[22:40] <moritz_> rakudo: sub MAIN() { say("main") }; say 'body'

[22:41] <p6eval> rakudo 592e29: OUTPUT«body␤main␤»

[22:41] *** nymacro left
[22:42] <jnthn> phew ;)

[22:42] <mberends> colomon, moritz_ : p5-mberends-c.c for comparison, and more benchmark results inside

[22:43] <mberends> colomon, moritz_: http://pastebin.com/YgQDEcpq

[22:43] *** Mowah left
[22:49] *** M_o_C left
[22:53] *** Rotwang left
[23:05] *** tyatpi_ joined
[23:07] *** kaare_ left
[23:10] *** wolverian joined
[23:11] <dalek> nqp/ctmo: c910ccf | jonathan++ | src/ (4 files):

[23:11] <dalek> nqp/ctmo: Start working towards eliminating src/nqp/Compiler.pir in favor of just having Compiler.pm. This moves a couple of bits around, and also twiddles Grammar.pm and Actions.pm to actually be valid Perl 6 (they used to have two semicolon style packages in the same file).

[23:11] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/c910ccf83b

[23:11] <dalek> nqp/ctmo: e96422c | jonathan++ | src/NQP/ (2 files):

[23:11] <dalek> nqp/ctmo: Implement sub MAIN. The multi case probably works too (if you declare a proto). Also should handle the case where it's not in the outermost scope (Rakudo gets that wrong...steal this fix! ;-)).

[23:11] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/e96422c1aa

[23:11] <dalek> nqp/ctmo: 4619313 | jonathan++ | src/ (2 files):

[23:11] <dalek> nqp/ctmo: Move Lexpad HLL mapping to where it probably shoulda gone in the first place.

[23:11] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/4619313258

[23:11] <dalek> nqp/ctmo: d5fbdcf | jonathan++ | src/stage0/ (6 files):

[23:11] <dalek> nqp/ctmo: Update bootstrap.

[23:11] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/d5fbdcf5b3

[23:11] <dalek> nqp/ctmo: 02dd606 | jonathan++ | src/NQP/Compiler.pir:

[23:11] <dalek> nqp/ctmo: Toss a chunk of stuff that's happily handled by NQP's generated output now, so needn't be done magically at compiler startup.

[23:11] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/02dd6061b5

[23:14] *** PacoLinux left
[23:34] *** risou joined
[23:34] *** risou_ left
[23:37] <lue> blog post!  https://rdstar.wordpress.com/2011/03/13/this-is-what-happens-when-you-stuff-things-into-boxes-blindfolded/

[23:38] *** Grrrr left
[23:41] *** Grrrr joined
[23:45] *** mtk left
[23:54] *** mtk joined
[23:55] *** fisted_ joined
[23:57] *** ymasory joined
[23:57] *** fisted left
