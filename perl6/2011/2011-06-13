[00:03] *** ymasory joined
[00:16] <sorear> lichtkind: a lexpad is an object that holds lexicals

[00:16] <sorear> lichtkind: sometimes the word is also used to refer to the compiler's record of what lexicals exist in what blocks

[00:17] *** kcwu joined
[00:21] *** lumi_ left
[00:22] *** lumi_ joined
[00:29] *** tokuhirom joined
[00:31] <lichtkind> thanks you sorear

[00:39] *** daniel-s left
[00:45] *** yinyin joined
[00:46] *** lichtkind left
[00:51] *** lumi_ left
[00:51] *** lumi_ joined
[00:54] *** icwiener left
[01:01] *** noganex_ joined
[01:04] *** noganex left
[01:29] *** starcoder left
[01:29] *** starcoder joined
[01:34] *** lumi_ left
[01:35] *** lumi_ joined
[01:39] *** Moukeddar joined
[01:41] <Moukeddar> Hello

[01:46] *** pjcj left
[01:51] *** whiteknight left
[01:56] <thou> hi, Moukeddar

[01:56] <Moukeddar> how's going?

[01:57] <thou> things are good here. enjoying some supper, watching the colors change outside as the sun goes down.

[01:58] <thou> Moukeddar: i'm curious, are you learning (or already using) perl6?

[01:58] <Moukeddar> learning perl5

[01:59] <thou> ah, ok

[01:59] <Moukeddar> but i'm mostly here for the knowledge

[01:59] <thou> sure, it's an interesting place

[01:59] <thou> kind of like #haskell can be, too :-)

[01:59] <Moukeddar> it really is

[01:59] <thou> i guess i'm learning perl6 mostly for the knowledge.

[02:00] <colomon> rakudo: $*IN.lines.map(*.say)

[02:00] <p6eval> rakudo ae5bea:  ( no output )

[02:00] <colomon> rakudo: for $*IN.lines { .say }

[02:00] <p6eval> rakudo ae5bea: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmitten,␤einem

[02:00] <p6eval> ..stark…

[02:02] *** lumi_ left
[02:02] *** lumi_ joined
[02:09] <thou> colomon: lazily choses not to eval the .say because the result isn't needed, i think

[02:09] <colomon> thou: yes.

[02:09] <colomon> actually, not to eval the results of the map, but it's the same effect.

[02:10] <colomon> (I mean, that causes the .say not to be evaluated.)

[02:10] <colomon> rakudo: $*IN.lines.map(*.say).sink

[02:10] <p6eval> rakudo ae5bea: OUTPUT«Method 'sink' not found for invocant of class 'List'␤  in main program body at line 22:/tmp/lH7q0nJZru␤»

[02:10] <colomon> and I forget what the current syntax is for making that work.

[02:11] <colomon> sorry, I've been amusing myself by reading http://www.artima.com/weblogs/viewpost.jsp?thread=328540 and figuring out how to write the examples more succinctly in Perl 6.  :)

[02:12] <thou> cool

[02:13] <thou> interesting to read the comment in the 1st paragraph about scala breaking changes to make the language better, with my brain in the perl6 context

[02:14] <colomon> Yeah, and a lot of the examples are Perl 6y in spirit.  Just more verbose.  :)

[02:15] <thou> like, perl6 has taken that approach farther towards its logical (but completely impractical) terminus, with its design-by-community spiral

[02:18] *** PhatEddy left
[02:19] <TimToady> impractical in which sense?

[02:21] *** beekar left
[02:21] <thou> i am imagining a line between ADA-like design by closed committee to some vague idea of design by reimplementation (put out one implementation, find what breaks, put out another, breaking all old code, etc.)

[02:23] *** daniel-s joined
[02:23] <thou> i think Perl6 seems to be closer to the reimplementation side of things, in that the specs were under heavier revision based on feedback from growing implementations

[02:24] <thou> and i think both scala and perl6 are taking practical approaches to this aspect of language design (not getting stuck with early decisions)

[02:24] <TimToady> maybe, though the Ada spec went through lots of iterations

[02:24] <colomon> thou: it's usually mostly just the odd (or new) corners of the p6 spec under revision

[02:24] <thou> but going all the way down that road would just be chaos

[02:25] <TimToady> we just try not to fall in love with all the cute ideas :)

[02:25] <daniel-s> perl6: my $str1 = "Stuff"; my @arr1 Z~ ("_", ^10); say @arr1;

[02:25] <p6eval> pugs, rakudo ae5bea, niecza v6-151-ge51f7a9: OUTPUT«␤»

[02:25] <thou> i didn't mean to say that perl6 is impractical -- the ADA approach may have been too close to the other impractical end of the spectrum

[02:25] <daniel-s> HL?

[02:25] <thou> although actually it was (is?) a pretty cool language i think

[02:25] <TimToady> it's also a bit like the Ada effort in thinking a lot about what is implementable and (hopefully) efficient

[02:25] <thou> especially for its time

[02:25] <daniel-s> perl6: my $str1 = "Stuff"; my @arr1 Z~ ("_", "^10"); say @arr1;

[02:25] <p6eval> pugs, rakudo ae5bea, niecza v6-151-ge51f7a9: OUTPUT«␤»

[02:26] <szabgab> hmm, after a long time I tried to build rakudo on my server and it failed (both trunk and rakudo *)

[02:26] <szabgab> with the same error

[02:26] <thou> yes, but not just thinking, but also fleshing that out via implementations, which i think is awesome

[02:26] *** lumi_ left
[02:26] <szabgab> /usr/bin/ld: cannot find -lparrot

[02:26] <szabgab> anyone has a hint what might be the issue?

[02:26] *** daniel-s left
[02:26] <szabgab> this is a 3 years old ubuntu machine

[02:27] *** lumi_ joined
[02:27] <szabgab> more specifically 8.04

[02:28] <thou> re-reading my first comment i can see it may have sounded negative towards the approach perl6 is taking, but i actually think it's really cool. everything from the RFC process through the current wave (which i'm part of) of interest post rakudo* and the rest of the growing "dry land" of the perl6 continent

[02:30] <TimToady> there was just ambiguity, and wondered which way you meant it--if I haven't developed a thick hide by now, I never will :)

[02:30] <thou> hehe

[02:30] <TimToady> so if you do see any actual impracticalities, feel free to point them out :)

[02:31] <thou> other than that it's TEN YEARS IN THE MAKING?!!!!! ;-)

[02:31] <TimToady> well, there is that...

[02:32] <thou> szabgab: what's the full linker command above that error? can you paste it to a pastebin somewhere?

[02:32] <TimToady> that one's a bit hard to fix though..

[02:32] <TiMBuS> use Time::Travel;

[02:33] * TimToady is too old for that

[02:35] *** srid joined
[02:35] *** srid left
[02:36] <szabgab> thou: http://www.pastebot.net/paste/mSyZn8Z1fp4/

[02:36] <thou> TimToady: the other impracticality i see is that there's a lot of crufty info floating around, e.g. lots of links to old pugs repos, tons of stuff that's from 2006 or whatever, and it was hard for me to get a sense of what to look at and what to ignore.

[02:37] <thou> and that, too, is hard to fix

[02:39] <thou> perhaps a quarterly review of perl6.org content, ensuring that it has current pointers to best docs of the moment

[02:42] <szabgab> thou: I am sure there is lots of old content on perl6.org, could you point out the ones you found recently?

[02:52] *** ymasory left
[02:58] *** lumi_ left
[02:59] *** lumi_ joined
[03:05] *** cognominal_ joined
[03:06] *** kaare_ joined
[03:08] *** cognominal left
[03:09] *** stephanepayrard_ joined
[03:12] *** cognominal_ left
[03:12] <thou> szabgab: Community >> Wikis: seems that only perlfoundation one is current; november is down, .au and programmer's heaven look to be 3 years or so lod

[03:12] <thou> *old

[03:13] <thou> Specification: good, but the "Incomplete rigorous spec" page looks to be a few years old and it's hard to tell what there is relevant or not

[03:16] <thou> Compilers: the long list is intimidating. I know there's danger in putting too much weight on some "big players", but it'd be nice to know that 1) STD is definitive (for what it does); 2) rakudo and niecza are really active and fun to use, and 3) everything else is in some state or another of disuse for the most part (as far as I can tell at this point)

[03:18] <sorear> I just came in and can't make sense of the backlog.  What's the problem?

[03:20] <TimToady> no real problem, just noticing thing slightly stale things on perl6.org

[03:20] <thou> sorear: i complained about feeling lost at first regarding what stuff is current and what is stale or no longer relevant

[03:20] *** Moukeddar left
[03:20] <TimToady> s/thing/some/

[03:21] <TimToady> when you guys work on the new stuff it makes some of the older stuff look not so new :)

[03:21] <thou> and szabgab asked me to be more specific, particularly about perl6.org

[03:21] <sorear> november is pretty out of place on a "list of Perl 6 wikis"

[03:22] <sorear> november is a Perl 6 wiki, in the same way MediaWiki is a PHP wiki

[03:22] <thou> yeah. AND it's down. ;-)

[03:23] <szabgab> thou: do you have commit bit to the source of perl6.org ?

[03:23] <thou> i watched a video preso on november wiki, looked cool. it made me kind of sad that they implemented stuff in Parrot though 'cause they couldn't get it going in rakudo at the time (as i understood & remember it)

[03:23] *** Su-Shee_ joined
[03:24] <thou> szabgab: hmmm, not sure, i just got commit bit via github user 'softmoth' to some perl6 stuff, maybe perl6.org is included

[03:24] <thou> The Documentation page is the hardest to review, for me.

[03:25] <sorear> thou: november was very much an early adopter

[03:25] <thou> some things are easy to say they're stale, like Grok, and probably Perl6::Doc

[03:25] *** lumi_ left
[03:25] <thou> Perl Tablets is unfortunately not being updated (even in German?) and the english xlations are missing most of the content

[03:25] <szabgab> http://www.perl6.org/about/ has info on how to contribute to the perl6.org web site

[03:25] *** lumi_ joined
[03:26] <sorear> I think the tablets were updated recently

[03:27] *** Su-Shee left
[03:27] <thou> The two "in progress" books seem to be no longer in progress (somewhere i searched and found an o'reilly page saying "we rewrote the book twice already, and will write it again once the language is ready" basically)

[03:28] <sorear> the open commit book on github gets some activity

[03:31] <thou> Similar to the compilers, it'd be nice to have a clear 1) Synopses are definitive (as much as possible); 2) Using Perl 6 book is up-to-date, and the best intro point (although not yet complete); and Perl 5 to 6 is maintained (I think); 3) Everything else is kinda a mixed bag, sorry!

[03:32] *** c1sung left
[03:32] <thou> of course probably i've overlooked some gems, but i guess that's my point

[03:32] *** c1sung joined
[03:36] *** lumi_ left
[03:37] *** lumi_ joined
[03:38] <sorear> sadly I think we're still at the point where @Larry is more definitive than the synopses

[03:39] <TimToady> well, especially when we change our mind :)

[03:40] <mberends> thou: it's good for us to have your objective and fair comments, we are often too preoccupied with details to lose sight of the big picture.  Editing or removing stale content has been low on our agenda, and that would be a helpful contribution from anyone getting to know the state of the Perl 6 language.

[03:40] <sorear> TimToady: in STD method 'variable', what is '$:' <name> for?

[03:42] <sorear> surely <sigil> <twigil>? <desigilname> covers $:foo and $::foo

[03:42] <TimToady> well, I presume it was for the $:foo named form at some point, but maybe it's not used, or maybe it's in there to prevent to allow $: to mean a $ invocant elsewhere

[03:43] <TimToady> the fact that there's an XXX indicates it was a workaround to some difficulty

[03:43] <TimToady> so maybe ignore it and see what breaks

[03:44] <sorear> perhaps LTM issues.  it's at least 1.5years old

[03:44] *** tokuhiro_ joined
[03:44] <TimToady> it might predate your LTM

[03:44] <TimToady> yeah

[03:44] <sorear> it predates my *involvement*

[03:44] <sorear> I arrived just after the ng merge

[03:44] <TimToady> as soon as you joined I got stupid :)

[03:44] <sorear> I don't know how long ago your LTM came in though

[03:44] *** tokuhirom left
[03:44] <sorear> hey, now I feel guilty...

[03:45] <ingy> it avoids o/

[03:45] <TimToady> no wait, I only got stupider

[03:45] <TimToady> ingy: what doesn't it avoid?

[03:45] <ingy> er

[03:45] <TimToady> I guess it doesn't at that...

[03:46] <ingy> sorry irc time warp

[03:46] <ingy> just meant to say HI!

[03:46] <TimToady> it's that Time::Travel module we were using earlier

[03:47] <TimToady> hi, which TZ are you in these days?

[03:47] <ingy> the one in the future

[03:47] <ingy> Melbourne

[03:47] <thou> mberends: thanks, i am not sure if i just sound cranky. :-) i will look a bit more at the site to come up with some way to highlight the freshest stuff without losing the breadth of the more ... historical content

[03:48] <TimToady> thou: we could use more cranks like you :)

[03:48] <mberends> thou: thanks to you! :)

[03:48] <TimToady> btw, do you pronounce your th voiced or voiceless?

[03:48] <thou> voiced

[03:49] <TimToady> thanks  <-> voiceless

[03:49] <thou> oh, i thought you meant in "thou"

[03:49] <TimToady> yes

[03:49] <TimToady> thought it could be short for "thousand" or sumpn

[03:49] <thou> right

[03:50] <thou> nope, just the familiar you

[03:50] <TimToady> how...elizabethan...

[03:50] <thou> hehe. i think of it as king jamesian :-)

[03:51] *** kaare_ left
[03:51] <TimToady> ah, yes, I grew up with that :)

[03:51] <ingy> about to set sail though: Melbourne -> Seattle -> Asheville -> Pitt -> Chicago -> Duluth -> Banja Luka -> London -> Berlin -> Riga -> Chamonix -> Torino -> Paris -> Pittsburgh -> Tokyo -> 台北 -> Canberra -> unknown...

[03:51] <thou> i just found out that those plastic collars that we put on our dogs and cats to keep them from licking a sore are called "elizabethan collars", so i can't think of anything else when i hear that word

[03:52] <thou> it seems a strangely apt picture to capture the elizabethan era

[03:52] <TimToady> yes, we've had a few of those collars in our petful career

[03:55] <TimToady> what's pitiful is seeing them try to lick the wound through the collar; something deep about psychology there...

[03:55] <TimToady> sometimes it seems better to do something ineffective than to do nothing at all

[03:56] <TimToady> explains a lot of the quackery in the world

[03:56] <thou> when you can't even lick your wounds, you're really down and out...

[03:56] <ingy> TimToady: are we intersecting in any of those cities?

[03:56] <TimToady> Asheville, Riga, maybe Tokyo

[03:56] <TimToady> subset YAPC of Ingy where ...

[03:57] *** fuzzyflounder joined
[03:57] <ingy> no IPW for you eh?

[03:57] *** fuzzyflounder left
[03:57] *** fuzzyflounder joined
[03:57] *** fuzzyflounder is now known as cooper

[03:57] <ingy> or PPW more surprisingly

[03:57] <TimToady> well, that may yet happen

[03:58] <TimToady> at the moment I've been so overbooked that I actually begged off a trip up to Seattle with my family, so I'm Home Alone.

[03:58] <ingy> are you headed to NPW or FPW? I can't make those...

[03:58] <TimToady> prolly not

[04:01] <ingy> well enjoy the living room. I'd pop in for a hack, but I'm not a good swimmer.

[04:01] *** lumi_ left
[04:02] *** donri left
[04:02] *** lumi_ joined
[04:09] <dalek> niecza: 6083fb7 | sorear++ | src/niecza:

[04:09] <dalek> niecza: Use metamodel to verify $?FOO references.  Add placeholders to metamodel immediately.

[04:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6083fb7bfa

[04:11] *** molaf joined
[04:19] *** hudnix left
[04:20] *** woosley joined
[04:21] *** satyavvd joined
[04:31] *** mishnik|2 left
[04:31] *** mishnik left
[04:35] *** cognominal_ joined
[04:35] <sorear> std: { our $x }; say $x

[04:35] <p6eval> std 37a0cdd: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/7S52W1dx8O line 1:␤------> { our $x⏏ }; say $x␤ok 00:01 120m␤»

[04:35] *** stephanepayrard_ left
[04:36] <sorear> this is wrong on multiple levels...

[04:36] <TimToady> std: { our $x }; package Foo { $x }

[04:36] <p6eval> std 37a0cdd: OUTPUT«===SORRY!===␤Variable $x is not predeclared at /tmp/wxa2IxlTUJ line 1:␤------> { our $x }; package Foo { $x⏏ }␤Potential difficulties:␤  $x is declared but not used at /tmp/wxa2IxlTUJ line 1:␤------> { our $x⏏ }; package Foo {

[04:36] <p6eval> ..$x …

[04:36] <sorear> is_known is checking $*CURPKG first thing

[04:37] <TimToady> yeah, though that doesn't much matter for a boolean

[04:38] <sorear> What do you mean?

[04:38] <TimToady> the point of the routine is only to return true or false

[04:39] <TimToady> it was just doing a simple check before a complex check

[04:40] <TimToady> assuming P6 still looks in the current package regardless of 'our' scoping

[04:40] *** lumi_ left
[04:40] <TimToady> like P5 does

[04:40] <sorear> I thought that was only with 'no strict'

[04:41] *** lumi_ joined
[04:41] <TimToady> yeah, I guess, though the error is interesting: Variable "$x" is not imported at - line 2.

[04:42] <TimToady> anyway, feel free to fix it

[04:43] *** wamba joined
[04:48] <sorear> TimToady: what is the intended difference between is_known and is_name?

[04:49] <sorear> they look like they're doing exactly the same thing modulo bugs

[04:50] <TimToady> is_name is intended for sigilless names, though they may have converged over time

[04:51] <sorear> std: my class A {}; { say A.WHICH; my class A {} }

[04:51] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[04:51] <sorear> that's the main point of difference I see :)

[04:52] <TimToady> well, the presence of a name can influence the parsing

[04:53] <TimToady> started out just type names, but also constants and enums, or any names that don't take args

[04:53] <TimToady> or in the alternate view, constants are just a very small subset type :)

[04:54] <sorear> except for constants with sigils

[04:54] <sorear> my view is that sigil presense is the important factor, not the kind of declarator

[04:54] <TimToady> sure, but those are pretending to be variables

[04:55] <TimToady> well, not for post-declared listops

[04:55] <TimToady> those don't have a sigil, but are parsed as functions nonetheless

[04:55] *** lumi_ left
[04:56] <TimToady> we can either have post-declared listops or post-declared types, but not both

[04:56] *** lumi_ joined
[04:57] <TimToady> anyway, there's probably some way to unify the routines with a few internal conditionals

[04:57] <sorear> I'm just doing s/is_known/is_name/g and seeing what breaks...

[05:03] *** wamba left
[05:07] *** TiMBuS left
[05:08] *** molaf left
[05:13] *** TiMBuS joined
[05:14] <TiMBuS> ... wtf

[05:14] <TiMBuS> what happened there

[05:14] <sorear> freenode sometimes bans people for no reason

[05:14] <TiMBuS> :[

[05:14] <sorear> what'cha gonna do, start your own network?

[05:15] <TiMBuS> yeah

[05:15] <sorear> 22:07 -!- TiMBuS [~durf@2607:f358:1:fed5:22:0:b61d:edc1] has quit [K-Lined]

[05:15] <TiMBuS> im ipv6 aware :>

[05:15] <sorear> k-line disallows a single IP address from connecting to a single server

[05:15] <sorear> you reconnected as ipv5

[05:15] <sorear> v4

[05:16] <TiMBuS> yeah i know, ive ran quite a few ircd's for this reason

[05:16] <TiMBuS> time to complain to the overlords

[05:17] *** pmichaud left
[05:18] *** pmichaud joined
[05:21] *** JimmyZ joined
[05:30] <mberends> good * pmichaud

[05:31] <pmichaud> mberends: o/

[05:31] <pmichaud> my talk to yapc::eu was accepted!

[05:31] <mberends> \o/

[05:31] <JimmyZ> pmichaud++

[05:32] <pmichaud> guess I better book some flights :)

[05:32] <pmichaud> or get ready for a lot of swimming and walking

[05:32] * pmichaud wonders... steamship and train, perhaps?

[05:33] <mberends> round the perl in 80 days

[05:33] <sorear> is the bridge over the Bering Strait finished yet?

[05:33] <sorear> you could go the long way.  through Canada and Russia.

[05:33] <sorear> .o( if you're counting countries it's be fewer)

[05:34] <pmichaud> I could stop in Portland, OR for OSCON on the way, too :)

[05:37] *** lumi_ left
[05:38] *** lumi_ joined
[05:41] *** pjcj joined
[05:44] <dalek> niecza: 6cb84d6 | sorear++ | src/niecza:

[05:44] <dalek> niecza: Remap is_known to is_name

[05:44] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6cb84d6e16

[05:49] *** _twitch joined
[06:18] *** kaare_ joined
[06:20] *** amkrankruleuen left
[06:20] *** amkrankruleuen joined
[06:22] <JimmyZ> aloha: tell jnthn Hello Jnhtn++, your two talks are accepted.

[06:23] *** lumi_ left
[06:24] *** lumi_ joined
[06:35] <JimmyZ> :(

[06:36] *** zorgnax joined
[06:46] *** wamba joined
[07:03] *** mj41 joined
[07:07] *** mj41 left
[07:13] *** lumi_ left
[07:14] *** lumi_ joined
[07:14] *** mj41 joined
[07:17] *** zorgnax left
[07:17] *** f00li5h left
[07:21] *** wamba left
[07:27] <TiMBuS> phenny: tell JimmyZ to use you instead of aloha

[07:27] <phenny> TiMBuS: I'll pass that on when JimmyZ is around.

[07:33] *** mj41 left
[07:37] *** Su-Shee_ is now known as Su-Shee

[07:38] *** mj41 joined
[07:44] *** f00li5h joined
[07:46] <Su-Shee> good morning everyone.

[07:52] *** jfried joined
[07:59] <jnthn> morning o/

[08:02] <moritz> \o

[08:03] <sorear> hello, Su-Shee.

[08:04] <sorear> tis been a while!

[08:04] <Su-Shee> I make a sound every day! :)

[08:04] <sorear> oh.

[08:05] <sorear> I am too young to be losing my mind :/

[08:05] <Su-Shee> sorear: just the timezone drift.. I make my sounds when you are asleep probably ;)

[08:06] <JimmyZ> jnthn: \o, your two talks are accepted.

[08:06] <phenny> JimmyZ: 07:27Z <TiMBuS> tell JimmyZ to use you instead of aloha

[08:08] *** lumi_ left
[08:09] *** lumi_ joined
[08:13] <jnthn> JimmyZ: Nice :)

[08:13] *** thou left
[08:16] <jnthn> JimmyZ: Looking forward to it. :)

[08:16] *** wamba joined
[08:16] <jnthn> JimmyZ: I'll arrive on the Wednesday before BJPW, so by the workshop I should be de-jetlagged :)

[08:17] *** amkrankruleuen left
[08:17] *** amkrankruleuen joined
[08:19] <JimmyZ> jnthn: Good

[08:20] *** [particle] left
[08:21] *** HarryS left
[08:22] *** benabik left
[08:24] *** [particle] joined
[08:28] *** benabik joined
[08:28] *** dakkar joined
[08:34] *** wamba left
[08:37] *** wamba joined
[08:50] *** daniel-s joined
[08:52] *** burning_aces joined
[08:52] *** wamba left
[08:52] *** burning_aces left
[08:54] *** jerome joined
[08:55] *** _twitch left
[08:57] *** envi_laptop joined
[08:57] *** lumi_ left
[08:57] *** wamba joined
[08:58] *** lumi_ joined
[09:05] *** wamba left
[09:12] <tadzik> nom: say (1, 2).WHAT

[09:12] <p6eval> nom: OUTPUT«Cannot access attributes in a type object␤current instr.: '_block4329' pc 145318 (src/gen/CORE.setting.pir:39435) (:488)␤»

[09:20] *** amkrankruleuen left
[09:21] *** amkrankruleuen joined
[09:25] <tadzik> I has join() :)

[09:25] <mberends> \o/

[09:25] *** agentzh joined
[09:25] <tadzik> jnthn: want to review it first or should I push it?

[09:27] <tadzik> I think moritz++ tried to use FSA with it, I just did the simpliest thing: http://wklej.org/id/545644/

[09:27] *** HarryS joined
[09:27] <mberends> tadzik: I'd guess push it if it doesn't break anything (forgiveness..)

[09:27] <tadzik> it makes a test pass

[09:29] <tadzik> nom: my @a = [1, 2], 3;

[09:29] <mberends> tadzik++: so elegantly simple, if there's anything wrong with that it would be easy to correct

[09:29] <p6eval> nom: OUTPUT«Could not find sub &circumfix:<[ ]>␤current instr.: '_block13' pc 94 ((file unknown):159) (:1)␤»

[09:30] <tadzik> I don't think it flattens the list

[09:30] *** lumi_ left
[09:31] *** lumi_ joined
[09:33] <dalek> rakudo/nom: 1641672 | tadzik++ | src/core/List.pm:

[09:33] <dalek> rakudo/nom: Implement List.join() and List.Str(), gives us one more passing test in 08-var-array.t

[09:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1641672952

[09:36] * tadzik leaves for classes

[09:40] *** MayDaniel joined
[09:51] *** Moukeddar joined
[09:51] <jnthn> say (1, 2).WHAT # I suspect that a Str multi missing its :D

[09:51] <jnthn> Or just missing its multi also :)

[09:52] *** wamba joined
[09:57] *** lumi_ left
[09:57] *** lumi_ joined
[09:59] *** wamba left
[10:01] *** wamba joined
[10:02] *** MayDaniel left
[10:11] *** woosley left
[10:28] *** pnu left
[10:32] *** Moukeddar_ joined
[10:35] *** Moukeddar left
[10:35] *** pnu joined
[10:37] *** lumi_ left
[10:37] *** lumi_ joined
[10:47] *** daniel-s left
[10:48] *** icwiener joined
[10:56] *** molaf joined
[11:00] *** daemon left
[11:01] *** daemon joined
[11:04] *** wamba left
[11:05] *** daemon left
[11:07] *** daemon joined
[11:07] *** wamba joined
[11:10] *** lumi_ left
[11:11] *** lumi_ joined
[11:20] *** daemon left
[11:21] *** daemon joined
[11:25] *** wamba left
[11:26] *** wamba joined
[11:30] *** MayDaniel joined
[11:39] *** satyavvd left
[11:40] *** satyavvd joined
[11:41] *** wamba left
[11:45] *** satyavvd left
[11:50] <colomon> rakudo: say 1e30.sin

[11:50] <p6eval> rakudo ae5bea: OUTPUT«0.00933146893117582␤»

[11:51] *** MayDaniel left
[11:52] <colomon> rakudo: say 31415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679.sin

[11:52] <p6eval> rakudo ae5bea: OUTPUT«0.805989455610472␤»

[11:52] <colomon> rakudo: say pi.say

[11:52] <p6eval> rakudo ae5bea: OUTPUT«3.14159265358979␤Bool::True␤»

[11:53] <colomon> rakudo: say pi.sin

[11:53] <p6eval> rakudo ae5bea: OUTPUT«1.22464679914735e-16␤»

[11:53] *** nymacro left
[11:53] <colomon> sigh

[11:56] *** lumi_ left
[11:56] *** lumi_ joined
[11:59] *** kaare_ left
[12:00] <takadonet> morning all

[12:03] *** mtk joined
[12:03] <mberends> hi takadonet

[12:06] <mberends> colomon: whigh sigh? 1e-16 is about as good as it gets for a Num 0.

[12:18] *** jaldhar left
[12:19] <ingy> has p6 settled on a version format?

[12:19] <ingy> or is it as wild as p5?

[12:20] <mberends> ingy: it's settled. wait, looking..

[12:21] <mberends> ingy: http://perlcabal.org/syn/S11.html#Versioning

[12:23] *** lumi_ left
[12:23] *** lumi_ joined
[12:24] <mberends> ingy: and because that's too difficult to implement all at once, for Rakudo we aimed for just https://github.com/rakudo/rakudo/blob/master/docs/S11-Modules-proposal.pod (but haven't got there yet)

[12:24] *** cognominal joined
[12:27] *** cognominal_ left
[12:27] *** jaldhar joined
[12:27] *** cjk101010 joined
[12:27] <ingy> mberends: I meant is #.# or #.#.# or v#.#.# allowed, or just one

[12:28] <ingy> I didn't see it stated, although it seemed like #.#.# was prevalant

[12:29] *** agentzh left
[12:29] *** Moukeddar_ left
[12:29] <mberends> ingy: v is optional, and number of dots is unrestricted

[12:30] <pmichaud> good morning, #perl6

[12:30] <ingy> so pretty much v5 madness :)

[12:30] *** cjk101010 left
[12:30] <mberends> gm, pmichaud

[12:30] <ingy> o/

[12:31] * ingy wonders how far into p6 he'll be sucked this summer

[12:31] <mberends> the sucking power of p6 continues to increase ;)

[12:33] <mberends> nothing like an Electrolux though ;)

[12:33] <ingy> I just watched an Australian expose on woofering

[12:34] <ingy> not keen to think about an Electrolux

[12:35] <mberends> ouch

[12:44] <jnthn> o/ pmichaud 

[12:59] <colomon> mberends: pi.sin is correct.  (pi * 10 ** 100).sin is very badly wrong.

[13:02] *** jaldhar left
[13:02] *** jaldhar joined
[13:02] <mberends> colomon: ah. better not throw away that circular slide rule then

[13:02] *** Holy_Cow joined
[13:02] <pmichaud> jnthn: my talk was accepted :)

[13:04] *** lumi_ left
[13:05] *** lumi_ joined
[13:06] <jnthn> pmichaud: \o/

[13:07] <jnthn> pmichaud: Did you come up with a second one?

[13:07] <pmichaud> not yet.  I'm thinking of doing the rpbench one as a lightning talk

[13:07] <jnthn> ah, lightning talks can be good :)

[13:07] <jnthn> .oO( but can pmichaud do an rpbench talk as funny as translating NQP to lolcode? :-D )

[13:08] <pmichaud> someday I will have to come up with a talk to beat that one

[13:08] *** Holy_Cow left
[13:08] *** TiMBuS left
[13:12] *** daniel-s joined
[13:12] *** kaare_ joined
[13:27] *** envi_laptop left
[13:27] <gfldex> i'm getting a segfault on 32bit in the latest rakudo with perl6 --version

[13:27] <gfldex> 64bit is fine tho

[13:28] <pmichaud> gfldex: latest rakudo release, using a standard parrot?

[13:28] <gfldex> Program received signal SIGSEGV, Segmentation fault.

[13:28] <gfldex> [Switching to Thread 0xb741d8d0 (LWP 20271)]

[13:28] <gfldex> Parrot_oo_find_vtable_override (interp=0x94be028, classobj=0xa530ab0,  name=0x94e9014) at src/oo.c:513

[13:28] <gfldex> 513	        VTABLE_get_pmc_keyed_str(interp, _class->parent_overrides, name);

[13:28] <gfldex> This is Rakudo Perl 6, version 2011.05-16-gae5bead built on parrot 3.4.0 RELEASE_3_4_0-224-g5d77384

[13:28] <pmichaud> ah, on rakudo master

[13:29] <pmichaud> maybe I better build me a 32-bit environment

[13:29] <gfldex> dont worry, i will bug you every time that happens :)

[13:30] <pmichaud> that function was recently changed in Parrot, so I wonder if it's related to that.

[13:31] <gfldex> can't i tell configure.pl now to pull a different parrot version now?

[13:31] <pmichaud> in nom one can do it... master doesn't use the new config scripts

[13:31] <pmichaud> I thought about porting it, but the API to Configure.pl is quite different

[13:32] <gfldex> PARROT_REVISION will have to do then

[13:32] <gfldex> pmichaud: could you tell me the latest version that got the old oo.c?

[13:32] <pmichaud> so it wasn't an obvious step

[13:33] *** Moukeddar joined
[13:33] <mberends> o/ Moukeddar

[13:33] <Moukeddar> Hello mberends 

[13:33] <Moukeddar> how are you doing?

[13:34] <Moukeddar> what do you think ?

[13:34] <Moukeddar> http://i.imgur.com/vl7ey.png

[13:34] <mberends> nice :) had a few quiet days at home. $work begins tomorrow

[13:35] <Moukeddar> it's good to have a few days of tranquility

[13:35] <mberends> Moukeddar: at first sight, very good. I'll stare at it a little longer now

[13:36] <pmichaud> gfldex: looking... it's not obvious from 'git log' though

[13:36] *** icwiener left
[13:36] <pmichaud> gfldex: oh, that was apparently in a branch

[13:36] <pmichaud> so, I don't know.

[13:37] <gfldex> pmichaud: i will see if gdb can tell me more

[13:40] *** TBA2 joined
[13:40] <TBA2> afternoon perl6

[13:40] <mathw> hi

[13:40] <TBA2> quick question, hoping someone can clarify some inheritance stuff in p6 for me :)

[13:40] <TBA2> for basic inheritance, this is enough:

[13:40] <TBA2> (p.s. how do i do a newline in mirc lol)

[13:41] <flussence> gfldex: fwiw I don't get a segfault there on 32bit...

[13:41] <TBA2> class X {}; class Y is X {}; my Y $y = Y.new();

[13:41] <TBA2> works fine. but, what about constructors? BUILD is done at compile time, so I presume I overload sub new?

[13:42] <pmichaud> ...BUILD is done at compile time?

[13:42] <pmichaud> you can override BUILD or new.

[13:42] <pmichaud> depends on what part of construction you want to override

[13:43] <TBA2> if it helps, my aim is something like this:

[13:43] <TBA2> class X { has $!Summat; method new(Str $SummatElse) {} }; class Y is X { method new(Str $SummatElse) {} };

[13:44] <TBA2> where i can call Y.new($summat) and both Y.new and X.new are called in order

[13:44] <gfldex> pmichaud: my problem may be an oldish libc

[13:45] <TBA2> pmichaud: thx btw :)

[13:45] <pmichaud> TBA2: I think you want to be overriding BUILD then

[13:45] <pmichaud> X's BUILD will describe how to initialize $!Summat

[13:45] *** hudnix joined
[13:45] <pmichaud> (if the default isn't good enough for you.)

[13:46] *** lumi_ left
[13:46] <pmichaud> I could be wrong about that though.  we really ought to have a good "basics of Perl 6 oo" somewhere.

[13:46] <pmichaud> I wonder if the perl6book has something :-)

[13:46] <TBA2> pmichaud: perhaps more accurate question then, if I want to execute code on an object when its being created, is that BUILD or new? I realise new() doesn't have a reference to $self, and thats where I start getting confused lol

[13:47] <pmichaud> that's BUILD

[13:47] *** lumi_ joined
[13:47] <pmichaud> new has a reference to "self", but it's not the self of the object being created

[13:47] <pmichaud> it's the self of the object doing the creating

[13:48] <TBA2> yeah, i'd been using $self = self.bless(*) (albeit without really knowing what exactly thats doing) and then using the reference to $self to call subs, which explains why my classes are blowing up in my face lol

[13:49] <TBA2> so in BUILD I can do the normal $.Whatever to access instance vars?

[13:49] <pmichaud> I think you want to be using the private interface, in general

[13:49] <pmichaud> i.e., $!xyz instead of $.xyz

[13:49] <pmichaud> S12 talks about that a fair bit, iirc

[13:49] <TBA2> thanks, will take a look, actually already have it open haha :p

[13:50] <mberends> Moukeddar: your entity relationship diagram looks quite workable. It looks like commenters are not users, which is fine, but then having an email address on each comment may be pointless.

[13:50] <TBA2> if I ever get my head around this I'll put together an FAQ with what I've learned lol :p

[13:50] <Moukeddar> it's for that the visitors could comment without being a registered user

[13:51] <mberends> Moukeddar: I guessed as much :)

[13:51] <Moukeddar> and the user table is for the peeps that are going to write on the blog

[13:51] *** colomon left
[13:52] <mberends> yes, that part makes perfect sense

[13:53] <Moukeddar> is there anything wrong with it?

[13:55] <TBA2> pmichaud: amazing, thank you, just redone my classes with BUILD and its all working as expected!

[13:55] <mberends> I would just drop the email field from the Comments table, that is all.  You would not be able to validate the addesses, and people don't like to have to give email addresses because of spam, phising etc.

[13:56] <pmichaud> TBA2++

[13:56] *** buubot_backup left
[13:57] <Moukeddar> i admit it , it's kinda annoying to give your email adress just to comment :)

[13:57] <Moukeddar> +1 internetz for you mberends 

[13:58] <TBA2> just a thought, could the synopses be released as a book once they're all out of draft? i'd pay for a copy just to have it on my desk instead of using up an extra monitor, could be some extra cash for TPF!

[13:59] *** spq1 joined
[14:00] <mberends> .oO( where do I put this new internet? i haz 2 already!? )

[14:00] <Moukeddar> please consider donating to the less fortunate people

[14:00] <mberends> :) ok

[14:01] <Moukeddar> thanks for the help mberends 

[14:01] *** meraxes left
[14:01] <mberends> good luck with the construction Moukeddar

[14:02] <Moukeddar> thank you

[14:03] *** buubot_backup joined
[14:03] *** awoodland joined
[14:03] *** perigrin left
[14:04] *** awoodland left
[14:07] *** envi_laptop joined
[14:09] *** TBA2 left
[14:10] *** TBA2 joined
[14:14] *** PacoLinux joined
[14:16] *** c9s left
[14:16] *** estrabd left
[14:27] *** Moukeddar left
[14:32] *** lumi_ left
[14:33] *** lumi_ joined
[14:37] *** bluescreen10 joined
[14:40] *** JimmyZ left
[14:51] <Su-Shee> rakudo: sub foo () { say; }; "Hello".foo();

[14:51] <p6eval> rakudo ae5bea: OUTPUT«Method 'foo' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/dbQUrFhDW7␤»

[14:54] *** tokuhiro_ left
[14:58] <pmichaud> rakudo: sub foo ($a) { $a.say; };  "Hello".&foo();

[14:58] <p6eval> rakudo ae5bea: OUTPUT«Hello␤»

[14:59] <daniel-s> I just noticed, in #emacs they have a bot that will automatically tinyurl a link that it sees in the chat

[15:00] <daniel-s> I've never seen that before

[15:00] <daniel-s> would that be useful in #perl6?

[15:00] <PerlJam> we've been doing that on #perl for a long time

[15:00] <flussence> seems like a gratuitous use of short url namespace to me...

[15:01] <daniel-s> I'm pretty sure a good percentage of tinyurls are just spam anyway

[15:01] <daniel-s> I wouldn't feel guilty about it

[15:01] * daniel-s is looking for a new perl 6 project

[15:02] <flussence> I prefer long urls, you never know when one of those url shortener sites will disappear...

[15:02] <flussence> can I suggest one involving NativeCall? Just so someone's using it :)

[15:04] <daniel-s> actually, I've been meaning to ask

[15:04] <daniel-s> I can't find anything that describes how to execute external commands

[15:04] <daniel-s> in perl 6

[15:05] <flussence> backticks and qx work the same as perl 5, if that's what you mean

[15:05] <daniel-s> eg. if i had $directory = "/home/daniel-s/stuff", to then execute "unzip $directory"

[15:05] <daniel-s> which calls the unzip executable

[15:06] <flussence> that'd be `unzip $directory`, or qqx(unzip $directory)

[15:06] <flussence> (I don't think anything more in-depth than that exists yet)

[15:08] <moritz> ` is gone from p6

[15:11] <flussence> oops

[15:11] <daniel-s> say qqx('pwd');  <--- doesn't work

[15:11] *** mkramer joined
[15:11] *** mkramer left
[15:12] <daniel-s> rakudo: say qx('echo hello');

[15:12] <p6eval> rakudo ae5bea: OUTPUT«Could not find sub &qx␤  in main program body at line 22:/tmp/SJ1N8Jb9Sd␤»

[15:12] <moritz> in what way?

[15:13] <moritz> ah, it's not a sub

[15:13] <moritz> it's a quoting construct

[15:13] <moritz> so () won't work

[15:13] <moritz> qx/pwd/ should work

[15:13] <moritz> rakudo: say $*CWD

[15:13] <p6eval> rakudo ae5bea:  ( no output )

[15:13] <daniel-s> rakudo: say qx/echo hi/;

[15:13] <moritz> but qx won't work on evalbot, for security reasons

[15:13] <p6eval> rakudo ae5bea: OUTPUT«Operation not permitted in safe mode␤  in 'Safe::forbidden' at line 2:/tmp/5NBpK2U4WS␤  in main program body at line 22:/tmp/5NBpK2U4WS␤»

[15:14] <daniel-s> yep, works for me, thanks

[15:15] <daniel-s> it's not possible to let a process run, do other stuff, then come back to it once it's done though, is it?

[15:15] *** kliff joined
[15:19] *** mtk left
[15:19] <moritz> you can launch it in the background and  redirect ouzput to a file

[15:19] <moritz> and open() that file later

[15:23] *** Tedd1 left
[15:24] *** mtk joined
[15:24] *** Tedd1 joined
[15:33] *** icwiener joined
[15:38] *** lumi_ left
[15:39] *** lumi_ joined
[15:41] *** xinming left
[15:42] *** thou joined
[15:43] <moritz> nom: say <a b c>.WHAT

[15:43] <p6eval> nom: OUTPUT«Cannot access attributes in a type object␤current instr.: '_block4329' pc 146006 (src/gen/CORE.setting.pir:39611) (:488)␤»

[15:43] *** xinming joined
[15:43] <moritz> nombug

[15:47] *** kfo joined
[15:48] <pmichaud> yes, it's in List.gimme

[15:48] <pmichaud> as soon as I finish temporary registers I'll fix List.gimme

[15:49] * moritz got a patch for List.join that constructs a FixedStringArray and populates it with manually unboxed strings

[15:50] *** kfo_ left
[15:51] *** wamba joined
[15:54] <masak> good evening, #perl6.

[15:56] *** meteorjay joined
[15:59] <dalek> rakudo/nom: 011e8a4 | moritz++ | src/core/List.pm:

[15:59] <dalek> rakudo/nom: replace List.join with an implementation that unboxes strings manually

[15:59] <dalek> rakudo/nom: 

[15:59] <dalek> rakudo/nom: As per the IRC discussions yesterday, this should be much faster than

[15:59] <dalek> rakudo/nom: letting parrot do it through the get_string vtable.

[15:59] <dalek> rakudo/nom: Experimental verification (or falsification) welcome.

[15:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/011e8a4191

[16:04] <masak> moritz: I'm curious: what does the \ do in \$separator?

[16:04] <gfldex> pmichaud: segfault gone, rm -r rakudo did the trick

[16:05] <moritz> masak: something like "don't bother about the containerness" - it's just a (small) optimization in this case

[16:06] <moritz> nom: sub f($x is rw) { $x = 5 }; my $y = 8; f $y; say $y

[16:06] <p6eval> nom: OUTPUT«Cannot assign to a readonly variable or a value␤current instr.: 'infix:<=>' pc 133245 (src/gen/CORE.setting.pir:32844) (:763)␤»

[16:06] <moritz> another nombug

[16:06] <masak> moritz: when would it make a difference?

[16:06] <masak> (the \)

[16:08] *** JimmyZ joined
[16:09] <pmichaud> masak: it binds $separator directly to the value being passed in, instead of creating a new Scalar PMC to hold the reference.

[16:10] <pmichaud> someday rakudo will be able to detect this automatically and make the optimization for you when it's safe to do so

[16:10] <masak> ah.

[16:10] <masak> so unless we then try to assign to $separator, there's no way to tell the difference?

[16:11] <masak> do we care so much about a micro-optimization that we want to strew backslashes all over our setting until Rakudo detects this kind of thing automatically?

[16:11] <pmichaud> maybe not even then :-)

[16:11] <pmichaud> I think it's a premature optimization in this case, yes.

[16:11] <pmichaud> O

[16:12] <pmichaud> I'd prefer to save the backslashes for cases where we *know* performance is going to be an issue.

[16:12] <masak> +1

[16:12] <masak> code should mean stuff.

[16:12] <pmichaud> thus it makes sense for the math operators, and for the List internals

[16:13] <pmichaud> but other places... I don't think it makes good sense

[16:13] *** JimmyZ left
[16:13] <masak> I'm glad I learned about the meaning of \ -- and now I think it doesn't carry its weight in this case.

[16:13] <pmichaud> I agree.

[16:13] * masak removes it

[16:14] *** JimmyZ joined
[16:14] *** wamba left
[16:14] <moritz> .oO( premature pessimization )

[16:15] <JimmyZ> rakudo: sub foo ($a) { $a.say; };  "Hello".&foo(); # how do I pass one more args?

[16:15] <p6eval> rakudo ae5bea: OUTPUT«Hello␤»

[16:16] <pmichaud> rakudo:  sub foo ($a, $b) { $a.say; $b.say; };   "Hello".&foo('world');

[16:16] <p6eval> rakudo ae5bea: OUTPUT«Hello␤world␤»

[16:16] <masak> JimmyZ: a method is just a funny sub where the first argument is the object (=invocant).

[16:16] <masak> s/argument/parameter/

[16:16] <pmichaud> "Hello".&foo()   is  like   &foo("Hello")

[16:17] *** lumi_ left
[16:17] <JimmyZ> most like python? 

[16:17] <masak> not to mention Perl 5.

[16:17] *** lumi_ joined
[16:18] * JimmyZ didn't find where is mentioned in SYN.

[16:18] <pmichaud> I'm not sure it's explicitly mentioned as such.

[16:18] <masak> OTOH, it's not different from Perl 5... :P

[16:18] <pmichaud> (and yes, it probaly should be.)

[16:19] <pmichaud> correct, it's not different from p5.  :)

[16:19] <JimmyZ> it is not in SYN ?

[16:19] <masak> (but yes, it's a good idea to say so explicitly)

[16:19] <pmichaud> but there's enough other stuff in the object system that is way different from p5 that one can easily think that this might be different also :)

[16:19] <pmichaud> so an explicit mention would be helpful

[16:20] <pmichaud> also, at some point the p6 specs need to not default to "same as p5"

[16:20] <pmichaud> especially since p5 itself isn't static :)

[16:20] <moritz> and not specced

[16:21] <dalek> rakudo/nom: 59fcb4f | masak++ | src/core/List.pm:

[16:21] <dalek> rakudo/nom: removed premature backslashtimization

[16:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59fcb4f6c9

[16:22] <moritz> (backslashes) asking the other way round: when does it actually make sense to create an extra scalar container for a parameter?

[16:22] <moritz> when you want to it to something?

[16:22] *** cdarroch joined
[16:22] *** cdarroch left
[16:22] *** cdarroch joined
[16:23] *** yinyin left
[16:23] <JimmyZ> the example is strange, that force the sub to be a method

[16:23] *** Moukeddar joined
[16:23] <masak> JimmyZ: the other way also works.

[16:23] <masak> rakudo: my &bar = method { say self }; bar("OH HAI")

[16:24] <p6eval> rakudo ae5bea: OUTPUT«OH HAI␤»

[16:24] <moritz> JimmyZ: it's not the fact that something is a sub or method that makes it special, but rather the way you invoke it

[16:24] <pmichaud> moritz: the extra scalar container is when you're enforcing a new type or read-only-ness

[16:25] <pmichaud> sub abc($x) {  def($x) };   sub def($y is rw) { $y = 5 };   my $z = 5;  abc($z);

[16:25] <moritz> JimmyZ: in $obj.routine(), the fact that you call 'routine' as a method means that it is searched for in the context of $obj, not in the current lexical scope

[16:25] * jnthn home

[16:25] <JimmyZ> So I don'nt need to 'use MONEY' , I can argment any class 

[16:25] <moritz> jnthn: then let me tell you that sub f($x is rw) { $x = 3 } doesn't work... should it right now?

[16:25] <pmichaud> if abc has \$x instead of $x, then you lose the rw checking

[16:26] <moritz> JimmyZ: you're not changing the class

[16:26] *** cognominal left
[16:26] <JimmyZ> moritz: yes, but it give me this impression.

[16:26] <pmichaud> also, if anything binds to a backslashed parameter, you're potentially binding to the outer container or something like that

[16:27] <pmichaud> basically, using a backslash defeats a lot of constraint checking

[16:28] *** cognominal joined
[16:28] <jnthn> moritz: is rw, is copy, etc are NYI.

[16:28] <jnthn> moritz: More to the point, parameter traits are NYI

[16:28] <pmichaud> ...is copy is NYI?

[16:28] <pmichaud> oh.

[16:29] <jnthn> nom: sub foo is anaadvark { }

[16:29] <p6eval> nom:  ( no output )

[16:29] <masak> nom sub foo is awesome { }; say "alive!"

[16:29] <pmichaud> I better fix Array.BIND_POS and Hash.BIND_KEY then, unless they'll be implemented soon

[16:29] <masak> nom: sub foo is awesome { }; say "alive!"

[16:29] <p6eval> nom: OUTPUT«alive!␤»

[16:29] <jnthn> pmichaud: Just didn't get around to it yet.

[16:29] <pmichaud> s/they'll/'is copy'/

[16:30] *** Moukeddar left
[16:30] <masak> nom: sub is_copy is not_implemented { }; say "correct."

[16:30] <p6eval> nom: OUTPUT«correct.␤»

[16:30] <masak> wow, nom is so fast!

[16:30] <jnthn> Doing is rw and is copy means doing parameter traits fully, since we're not cheating on any traits in nom :)

[16:31] * moritz tosses his plans to do ++ and --

[16:31] <JimmyZ> rakudo: my $this = { 'Class_Name' => 'Foo'; }; sub foo ($this, $str ) { ~$this.say; $str.say; }; "Hello".&foo('world');  #this looks like Javascript :)

[16:31] <p6eval> rakudo ae5bea: OUTPUT«Hello␤world␤»

[16:31] <moritz> nom: 1i

[16:31] <p6eval> nom: OUTPUT«Method 'new' not found for invocant of class 'Sub'␤current instr.: '_block13' pc 80 ((file unknown):69240188) (:1)␤»

[16:32] * moritz still doesn't understand this one

[16:32] <jnthn> Is that a complex literal?

[16:32] <pmichaud> I'm guessing the action method needs updating.

[16:32] <jnthn> If so, they're decidedly not put back

[16:32] <jnthn> We can't put back more numeric literals until we work out how to unify compile time and runtime string to number handling.

[16:33] <jnthn> moritz: ah, yeah...is rw is a blocker for ++ and --, ain't it...

[16:34] <pmichaud> won't  \$param work there?

[16:34] <jnthn> Yes, it would, as a cheat.

[16:34] * jnthn tries to remember exactly what is copy does under our current container model :)

[16:34] <jnthn> pmichaud: Guess is copy = create a container and STORE?

[16:34] <pmichaud> jnthn: yes

[16:34] <jnthn> k

[16:35] <jnthn> And is rw is like \$param apart from check rw flag.

[16:35] <moritz> nom: my $x = 3; sub f(\$y) { $y = 8 }; f $x; say $x

[16:35] <p6eval> nom: OUTPUT«8␤»

[16:35] <moritz> oh

[16:35] <moritz> then I can go ahead, I think

[16:35] <jnthn> I'll do is copy and is rw this evening.

[16:35] <jnthn> moritz: Yes, feel free. Can fix it up with "is rw" once it works.

[16:36] *** uniejo left
[16:36] *** Mowah_ joined
[16:40] *** uniejo joined
[16:42] <moritz> rakudo: say True.pred

[16:42] <p6eval> rakudo ae5bea: OUTPUT«Bool::False␤»

[16:43] <masak> rakudo: say True.succ

[16:43] <moritz> rakudo: say Any.pred

[16:43] <p6eval> rakudo ae5bea: OUTPUT«Bool::True␤»

[16:43] <p6eval> rakudo ae5bea: OUTPUT«Method 'pred' not found for invocant of class ''␤  in main program body at line 22:/tmp/cTseiyxD33␤»

[16:43] <JimmyZ> rakudo: my $this = { 'Hello'; }; sub foo ($this, $str ) { $this.()," $str" }; $this.&foo('World').say;  # I guess this will scare some newbie

[16:43] <p6eval> rakudo ae5bea: OUTPUT«Hello World␤»

[16:43] <moritz> rakudo: my Int $x; say $x.pred

[16:43] <p6eval> rakudo ae5bea: OUTPUT«-1␤»

[16:43] <masak> rakudo: enum E <a b c>; say c.succ

[16:43] <p6eval> rakudo ae5bea: OUTPUT«3␤»

[16:43] <moritz> JimmyZ: well, then don't show the newbie

[16:43] <masak> er.

[16:44] <JimmyZ> That's javascriptish...

[16:45] <moritz> there are lots of parts in Perl 6 that scare the newbie

[16:46] <moritz> like the meta object thingy

[16:46] <TBA2> and there weren't in p5? ;p

[16:46] <pmichaud> There are lots of parts in Perl 6 that scare the oldbie, too.

[16:46] <pmichaud> I'm still frightened by some of what I see.  :)

[16:46] <moritz> but they also gives the oldbie lots of power, so they have their place

[16:46] *** wamba joined
[16:46] <JimmyZ> I agree

[16:47] <masak> shouldn't the above say 'c'?

[16:47] <masak> (yes, I probably implemented that part...)

[16:47] <moritz> masak: I think so

[16:47] * masak submits rakudobug

[16:47] <masak> good enough for me :)

[16:48] <jnthn> Now masak++ introduces bugs so he can submit them :P

[16:49] *** mj41 left
[16:49] <masak> it wasn't like that... :)

[16:50] <masak> honest

[16:50] <jnthn> :)

[16:52] *** Chillance joined
[16:52] <pmichaud> working on this temporary register solution, I'm once again reminded just how completely broken parrot's object model is.

[16:52] <pmichaud> sorry, how broken parrot's lexical model is

[16:53] <pmichaud> .lex 'name',  $P999      # $P999 must not be reused

[16:53] <pmichaud> $P999 = find_lex 'name'    # reusing $P999 is okay

[16:53] <pmichaud> bleh

[16:53] <jnthn> pmichaud: .lex 'name', $P9999 is actually associating that lexical name with that register

[16:53] <pmichaud> I now that.

[16:53] <pmichaud> *I know that.

[16:54] <pmichaud> that's what is kinda broken about it.

[16:54] <jnthn> Not that I really think relxicals belong in registers

[16:54] <jnthn> wtf

[16:54] <jnthn> lexicals

[16:54] <pmichaud> they don't

[16:54] <pmichaud> that "feature" was really a premature optimization, I think.

[16:54] <pmichaud> and it's come back to bite us many times.

[16:54] <moritz> can one do  $S999 = find_lex 'str_lexical' ?

[16:55] <jnthn> For one, you can't free the register set if there's a closure around.

[16:55] <pmichaud> not in parrot, not yet

[16:55] <pmichaud> you could at least null out the non-bound registers, though

[16:55] <jnthn> I actaully in theory could, with dynops, implement that now we have our own lexpad/lexinfo

[16:56] <jnthn> oh, but .lex 'foo', $S0 probably won't work.

[16:56] <pmichaud> at some point I wonder if we just give up on Parrot's lexicals altogether and use our own lexical opcodes and lexpads

[16:56] <jnthn> Probably.

[16:57] <jnthn> That's what we do with most things.

[16:57] <jnthn> :)

[16:57] *** lumi_ left
[16:57] <moritz> \o/ t/01-sanity/02-counter.t passes nwo

[16:57] <moritz> *now

[16:58] <jnthn> moritz: Probably 05-subs.t too

[16:58] <moritz> jnthn: yes

[16:58] <dalek> rakudo/nom: 90513c2 | moritz++ | src/core/operators.pm:

[16:58] <dalek> rakudo/nom: implement ++ and --

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90513c2a40

[16:58] <dalek> rakudo/nom: 4f41d0b | moritz++ | src/core/ (2 files):

[16:58] <dalek> rakudo/nom: add missing .pred methods

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f41d0b27e

[16:58] <pmichaud> jnthn: currently PAST does a little bit of work to optimize out a 'set' opcode when dealing with lexicals.  

[16:58] *** lumi_ joined
[16:58] <pmichaud> I'm thinking of pessimizing that again to make sure we're using temporaries safely.

[16:59] <jnthn> pmichaud: set is cheap

[16:59] <pmichaud> yeah

[16:59] <pmichaud> I'll do that.

[17:02] <pmichaud> oh, one of the cases I was worried about is already handled!  pmichaud[2008]++

[17:04] *** Maddeth joined
[17:04] <Maddeth> hello

[17:05] * moritz looks for more LHFs

[17:05] <Maddeth> may i be a pain in the butt and ask about ilbot :)

[17:05] <moritz> Maddeth: I'm the author of ilbot, feel free to /msg me

[17:06] *** dakkar left
[17:08] *** [hudnix] joined
[17:08] *** hudnix left
[17:13] *** lichtkind joined
[17:16] * JimmyZ sleeps

[17:17] *** JimmyZ left
[17:28] *** cooper left
[17:29] *** cooper joined
[17:29] *** cooper left
[17:29] *** cooper joined
[17:32] *** cognominal_ joined
[17:33] *** lumi_ left
[17:34] *** lumi_ joined
[17:35] *** cognominal left
[17:39] *** araujo left
[17:40] <tadzik> o/

[17:40] *** [hudnix] left
[17:43] <jnthn> o/ tadzik 

[17:44] <masak> \o tadzik 

[17:44] <pmichaud> erg.... something in nqp and also in rakudo master is relying on parrot's lexical register mapping behavior :-(

[17:45] <jnthn> pmichaud: ?

[17:46] *** ymasory joined
[17:46] <jnthn> pmichaud: As in, that .lex '$foo', $P1 will actually expect $P1 to not get re-used?

[17:46] <pmichaud> no

[17:46] <pmichaud> suppose I now have

[17:46] <pmichaud>     .lex '$foo', $P1

[17:46] <pmichaud> wait, start over

[17:46] <pmichaud> suppose I now have

[17:46] <pmichaud>     $P1 = ...stuff to initialize a lexical...

[17:47] <pmichaud>     .lex '$foo', $P1

[17:47] <pmichaud> if I change that to

[17:47] <pmichaud>     $P1 = ...stuff to initialize a lexical...

[17:47] <pmichaud>     $P100 = $P1

[17:47] <pmichaud>     .lex '$foo', $P100

[17:47] <pmichaud> then things are failing

[17:47] <jnthn> OK, that confuses me.

[17:47] <pmichaud> me too

[17:48] <pmichaud> maybe to be a little more accurate

[17:48] <pmichaud> (rephrasing one more time)

[17:48] <pmichaud> we have

[17:48] <pmichaud>     $P1 = ...stuff to initialize a lexical...

[17:48] <pmichaud>     .lex '$foo', $P1

[17:48] *** ymasory left
[17:48] <pmichaud>     ... use $P1 for other operations ...

[17:48] <pmichaud> but if that gets changed to

[17:48] <pmichaud>     $P1 = ...stuff to initialize a lexical...

[17:49] *** uniejo_ joined
[17:49] <pmichaud>     $P100 = $P1

[17:49] <pmichaud>     .lex '$foo', $P100

[17:49] <pmichaud>     ... use $P100 for other operations ...

[17:49] <pmichaud> then things start breaking

[17:49] *** uniejo_ left
[17:49] <jnthn> I suspect in either case using it for other operations may be a problem.

[17:50] <jnthn> But I can't explain why it'd work out in the first and not in the second.

[17:50] <pmichaud> the first case is normal

[17:50] <jnthn> Wait, what you you mean by "use for other operations"?

[17:50] <pmichaud> the result of a PAST::Var :scope<lexical> node

[17:51] <jnthn> ah

[17:51] <pmichaud> as in

[17:51] <jnthn> Which is $P1 / $P100. 

[17:51] <pmichaud> oh, I think I see the problem

[17:51] <pmichaud> I have to go pick up kid -- bbi20

[17:52] <Su-Shee> where do I find some explanation about yapsi - npq - rakudo and their relationship to pass to someone?

[17:53] *** kaare_ left
[17:53] *** Mowah_ left
[17:54] <pmichaud> Su-Shee: there's a description of our plan for nqp at http://pmthium.com/2011/01/31/nqp-roadmap-2011-01/

[17:54] <pmichaud> also http://pmthium.com/2011/02/08/new-nqp-repository-new-nom-rakudo-branch/

[17:54] <Su-Shee> ok, I consider that the "that's what people should know" until further notice? :)

[17:54] <pmichaud> (no kid pickup -- someone else is taking care of it)

[17:55] <pmichaud> it's probably time for an update

[17:55] <pmichaud> but for now, that's what we have

[17:55] *** Mowah_ joined
[17:55] <pmichaud> jnthn: okay, here's the problem  (stupid $&!#$%  :pasttype<bind> again)

[17:56] *** envi_laptop left
[17:56] <pmichaud> PAST::Op.new( :pasttype<bind>, PAST::Var.new(:scope<lexical>, :name<$foo>), $ast)

[17:58] <pmichaud> something is relying on having the register for $ast and the .... wait, that can't be it.

[17:58] <pmichaud> oh, yes it is

[17:58] <pmichaud> I have to rephrase this one

[17:58] <pmichaud> PAST::Op.new( :pasttype<bind>, PAST::Var.new(:scope<lexical>, :name<$foo>, :isdecl), $ast)

[17:59] <pmichaud> something is relying on the result of the PAST::Op being exactly the same as $ast

[17:59] <jnthn> Where "exactly the same" means?

[17:59] <jnthn> Same register?

[17:59] <pmichaud> yes.

[17:59] <pmichaud> because normally :pasttype<bind> returns the register associated with the lexical

[18:01] * jnthn tries to think of a place where that's relied on

[18:01] <pmichaud> I can't imagine quite why/where it would make a difference

[18:02] <jnthn> I'm struggling also.

[18:02] <jnthn> It feels like it shouldn't matter.

[18:02] <pmichaud> let me back up and make the change with a normal parrot master, no temporaries involved

[18:02] <pmichaud> see if I get the same problem.

[18:04] <sorear> good * #perl6

[18:06] <pmichaud> yes, I get the error

[18:07] *** cooper left
[18:08] <pmichaud> here's the patch that breaks things:  http://gist.github.com/1023329

[18:08] <Su-Shee> now I'm confused by the roadmap.

[18:09] * pmichaud suddenly wonders why we call "plan for unexplored territory" a "roadmap"  :)

[18:10] <Su-Shee> "the map is not the territory" :)

[18:10] <pmichaud> jnthn: all I'm doing is making sure that the lexical gets its own register instead of using whatever register comes back from vivipost

[18:10] <pmichaud> Su-Shee: maybe I can give a quick overview here, you can ask questions, and we'll make a blog post about it for others

[18:10] <pmichaud> the pieces:

[18:11] *** molaf left
[18:11] <pmichaud>     parrot - the virtual machine

[18:11] <Su-Shee> pmichaud: it sounds like phasing out parrot by making nqp an vm-independent ... something to run perl 6 implementations on. (rakudo these days)

[18:11] <jnthn> pmichaud: I agree the patch should be innocuous.

[18:11] *** lumi_ left
[18:11] <pmichaud> jnthn: when compiling with nqp, I get

[18:12] <pmichaud> Su-Shee: the point is not to phase out parrot, it's to enable rakudo (and other nqp-based programs) to target VMs other than parrot

[18:12] <pmichaud> http://gist.github.com/1023342

[18:12] *** lumi_ joined
[18:12] <pmichaud> jnthn: s/with//

[18:13] <pmichaud> also, we've decided that parrot's API is a very poor match for Perl 6, so NQP is giving us a level of abstraction where we can fix that

[18:13] <TimToady> the first-arg-is-invocant policy is talked about at S12:349 and following

[18:14] <pmichaud> (we expect the same may be true for others VMs that we target -- i.e., they probably won't fit Perl 6's expectations, so NQP gives us a layer in which to make things match)

[18:14] <Su-Shee> pmichaud: did you have something like "Clojure" in mind? I mean it's a lisp on a Java VM which "accidently" can incorporate all the Java libs out there...

[18:14] <jnthn> pmichaud: looking

[18:14] <pmichaud> Su-Shee: our primary other targets have been CLR and JVM

[18:15] <pmichaud> but we're not limiting ourselves to those.  we'd also be interesting in JavaScript (e.g., Google's V8) and llvm

[18:15] <pmichaud> *interested

[18:16] <jnthn> pmichaud: Please can you gist me the contents of _block2576 in src/stage1/gen/nqp-mo.pir?

[18:16] <jnthn> pmichaud: If I can see that there's a good chance I can fairly quickly tell you what's producing it.

[18:16] <pmichaud> http://gist.github.com/1023350

[18:17] <Su-Shee> pmichaud: I think that'll make many people happy and interested. 

[18:17] <pmichaud> Su-Shee: that's our hope/expectation as well

[18:17] <jnthn> pmichaud: OK, I know what bit of code that is.

[18:18] *** Zapelius joined
[18:18] <jnthn> pmichaud: It's result of compiling what's in src/how/EXPORTHOW.pm

[18:19] <pmichaud> ...are there lexical declarations there?  I don't see any.

[18:19] <pmichaud> also, the problem might not be in what is being compiled but rather in the thing doing the compiling

[18:19] <Su-Shee> how does sorear's c# implementation fit in all that? it's totally independent?

[18:19] <pmichaud> code-wise, it's fairly independent

[18:20] <pmichaud> there's not any direct code relation between niecza and rakudo/nqp/parrot

[18:20] <Su-Shee> c# .net and jvm sounds very enterprise-compatible. 

[18:20] <pmichaud> yes, that's another reason rakudo went this way

[18:21] <pmichaud> we think there needs to be a .net and/or .jvm Perl

[18:21] <jnthn> pmichaud: oh :(

[18:21] <jnthn> pmichaud: I think I know what's up.

[18:22] <jnthn> pmichaud: $?PACKAGE and $?CLASS are in the static lexpad.

[18:22] <Su-Shee> pmichaud: from my office's code point of view I'd buy it yesterday.

[18:22] <jnthn> pmichaud: At lexpad creation time, we populate those lexicals with values from the static lexpad.

[18:23] <jnthn> pmichaud: Before it was just:

[18:23] <jnthn>    .lex "$?PACKAGE", $P2579

[18:23] <jnthn> Which has zero runtime effect.

[18:23] <jnthn> It just declares "this lexical goes in this register"

[18:23] <jnthn>     set $P2579, $P2578

[18:23] <jnthn>     .lex "$?PACKAGE", $P2579

[18:23] <jnthn> Is thus scribbling over the value from the static lexpad with a null.

[18:24] * jnthn shoulda seen this issue earlier...

[18:24] <jnthn> The bind threw me off

[18:24] <jnthn> It's not binds that are the issue

[18:24] <jnthn> It's a PAST::Var.new( :name('$?PACKAGE'), :scope('lexical'), :isdecl(1) )

[18:24] <jnthn> Directly in a PAST::Stmts

[18:25] <jnthn> with no viviself and not being bound.

[18:25] <pmichaud> ohhhhh

[18:25] <pmichaud> checking

[18:27] <pmichaud> well, there's always an implied viviself in this particular codepath

[18:27] *** mj41 joined
[18:27] *** colomon joined
[18:27] <sorear> pmichaud: I agree that roadmap is an extremely stupid name for it

[18:29] <pmichaud> sorear: yeah, I think the analogy should be more of "we see this cool mountain peak in the distance... here's our plan for how to reach it.  There's a lot of unexplored territory between here and there, though"

[18:29] <pmichaud> so whatever we'd call that plan.  "expedition", perhaps, although I don't necessarily like some of the connotations of that word :)

[18:30] <jnthn> It's more a taiga map than a road map, in terms of how hard it is to cut our way through to the mountain. :)

[18:30] <pmichaud> jnthn: so, is the "Can only use get_who..." message coming from trying to use get_who on a PMCNULL ?

[18:30] <jnthn> pmichaud: Yeah, looks so

[18:30] <pmichaud> maybe we should error that case out a little better :)

[18:30] <Su-Shee> whatever you call it, I compile it monthly like clockwork. ;)

[18:31] <jnthn> pmichaud: Yeah, I'd not really run into this so much :)

[18:31] <pmichaud> jnthn: well, that's a good thing!

[18:31] <jnthn> pmichaud: Most of the time it's "oh no, it's a Parrot object that got in" :)

[18:31] <pmichaud> well, that's really what this is, too :)

[18:31] <pmichaud> it's a Parrot object  (PMCNULL) that got in

[18:31] <jnthn> It just checks vtable->base_type

[18:31] <jnthn> Right :)

[18:31] <pmichaud> so, the error message should say what it did get

[18:31] <jnthn> Null is just a PMC type.

[18:32] <pmichaud> Can only use get_who on a SixModelObject, not a silly Parrot <foo>

[18:32] <pmichaud> anyway, now that you've identified the problem, I'm certain I can fix it.

[18:33] <pmichaud> (trivially, even.)

[18:33] <jnthn> OK, now you've given me the wording, I can happily add that. <grin>

[18:33] <TimToady> it's too bad that ✕ looks so much like x, or we could say * ✕ * instead of * * *

[18:34] <pmichaud> btw, on another topic... earlier today I was thinking about using a role   Parrot::PMC[::T]   to be able to get to Parrot PMC's.  For example:   Parrot::PMC[ResizablePMCArray]   :-P

[18:34] *** Tedd1 left
[18:34] <jnthn> O.O

[18:34] <pmichaud> (this was in reaction to binding Mu variables to non-Rakudo objects :-)

[18:35] <pmichaud> which I think is okay for now if you want to add that :)

[18:35] <jnthn> role Parrot::PMC[$type] { method new() { pir::new($type) } }

[18:35] <jnthn> :P

[18:35] <pmichaud> yeah, something like that :)

[18:35] <pmichaud> but being a little smarter about handling $type, such as being able to parse  'PAST::Node'  into namespaces

[18:37] <pmichaud> jnthn: okay, so what you just described explains why nqp fails... is there as similar problem in rakudo master?

[18:38] <pmichaud> (there must be :-)

[18:38] *** Tedd1 joined
[18:39] <pmichaud> trying patch now

[18:39] <jnthn> master surprises me more

[18:39] <pmichaud> yeah, me too

[18:39] <pmichaud> anyway, we'll know soon (about 4 mins)

[18:40] *** tewk left
[18:40] <pmichaud> seems to have resolved the nqp issue

[18:40] <pmichaud> let's see how rakudo master does

[18:41] <jnthn> nom uses static lexpads too, but we didn't have them in master

[18:43] *** Mowah_ left
[18:45] *** fhelmberger_ joined
[18:45] *** fhelmberger left
[18:47] <pmichaud> okay, that fixed seems to have resolved it in master also.

[18:50] *** lumi_ left
[18:51] *** lumi_ joined
[18:52] *** wamba left
[18:53] *** dju_ joined
[18:54] *** breinbaa1 left
[18:55] *** breinbaas joined
[18:56] *** dju left
[18:56] <jnthn> afk for a bit

[18:58] *** daniel-s_ joined
[19:01] *** daniel-s left
[19:01] <pmichaud> jnthn: (for when you get back)  now nqp's t/p6regex/01-regx.t hangs for me when it gets to the "end"

[19:02] <pmichaud> it runs through all of the test files and displays the final plan, but doesn't actually exit.  Weird.

[19:03] <TimToady> hah, the ir clog gives a link to S99 in http://irclog.perlgeek.de/perl6/2011-06-13#i_3917424

[19:05] <pmichaud> time for lunch

[19:07] <masak> oh man. S99... how big is this project? /o\

[19:07] <masak> all I ever got to was S53.

[19:08] <masak> "Illexical hyperroles"

[19:08] <TimToady> well, the bug is actually that it was a ref to S999

[19:10] <masak> oh, phew. what!?

[19:10] <masak> /o\

[19:10] <mberends> S99/S999 could be a meta-Synopsis of all the Synopses: "DWIM. TIMTOWTDI. Amen."

[19:11] <masak> I still have nightmares about S38 sometimes. "Autojunctive paratokens."

[19:11] <TimToady> that would be Sω

[19:12] <Su-Shee> and it's not really a good sign if I can't tell wether you're just making things up or if it's a feature... ;)

[19:12] <masak> someone should totally build a Markov chain spec generator.

[19:12] <Su-Shee> oh god... :)

[19:12] <Su-Shee> masak: you realize that someone will come along and implement it? ;)

[19:13] <masak> hee hee

[19:13] <TimToady> wait, isn't that what I did already <mmmph!>

[19:13] <TimToady> pay no attention to the bdlf behind the curtain...

[19:13] <TimToady> *fl

[19:14] <masak> "The metaclass is the sole hyperoperator in the module that can't control the method and the dynamic variable for loop."

[19:14] <TimToady> my irc remarks are also generated markovianesquely

[19:14] <masak> I bet a good Markov spec generator could give implementors gray hairs... :)

[19:15] <TimToady> how would you distinguish it from the current spec?

[19:15] <masak> "But I just did the MOP according to the old spec! What's all this new stuff?"

[19:15] <masak> "It's brilliant, but..."

[19:15] <Su-Shee> "In quantum dispatch multiple objects can easily dispersed by a simple hyperrole actor model."

[19:15] <masak> Su-Shee: you're better at it than I am :P

[19:16] <Su-Shee> masak: I like to see the code you make out of it ;)

[19:16] <masak> "We also see that a single given/WHICH interpolation suffices to turn off the LTM."

[19:17] <Su-Shee> oh boy this will end badly.. :)

[19:17] <TimToady> if we run it enough times, we can have everything specced that is currently missing

[19:17] <Su-Shee> TimToady: you should consider a new spec to be released on April, 1st 2012 ;)

[19:18] <masak> "Note that the base representation of a Unicode metaoperand is fixed at a precedence level of MONKEY_TYPING."

[19:19] * TimToady ponders a series of Google searches as a markov chain driver

[19:19] <masak> ooh

[19:20] <TimToady> maybe that could be Perl 6's killer app :)

[19:20] <Su-Shee> "On a subatomic level - which is a metaphor for the single most basic unit type coercion happening during initialization of the most basic object of type ObjectType - one can prove the speed improvement by factor 10 due to the extremely late build of basic heaps"

[19:21] <masak> TimToady: how automorph. :)

[19:21] <masak> Su-Shee++

[19:22] <Su-Shee> also, someone's already done something like this in perl.. for postmodern philosophy. :) http://www.elsewhere.org/pomo/ 

[19:22] <masak> btw, today's autopun: "The argument from authority is the weakest form of argument, according to Boethius." -- St. Thomas Aquinas

[19:22] <Su-Shee> *haha* :)

[19:23] <masak> even when I give a heads-up... :P

[19:23] <TimToady> Argument by assertion is even weaker.

[19:23] <masak> :P

[19:25] <Su-Shee> masak: we should write a paper and submit it somewhere ;)

[19:30] *** lumi_ left
[19:30] <masak> Su-Shee: ;)

[19:31] *** lumi_ joined
[19:31] <masak> "On the autopunny properties of online programming communities, and their effects on morale and digestion."

[19:31] * masak will probably be chewed out for that one...

[19:32] <TBA2> is there a way to binmode $*IN in rakudo without opening a new filehandle?

[19:32] <masak> TBA2: good question. there really should be.

[19:33] <TBA2> masak: i like it, a no without being negative ;)

[19:33] <masak> no.

[19:33] <masak> :)

[19:33] <masak> it was more like an "I don't know."

[19:34] <TBA2> lol :)

[19:34] * TBA2 starts digging

[19:35] *** dju_ is now known as dju

[19:35] <masak> S16, IIRC.

[19:36] <lue> hello world! o/

[19:36] <masak> lue! \o/

[19:36] <colomon> \o

[19:37] <masak> lue: could you write us a Markov-chain spec generator? :)

[19:40] <sorear> o/ masak

[19:40] <masak> sorear \o

[19:40] <masak> how goes the Niecza hacking?

[19:40] <lue> why would you ask me a question like that? .oO(What is a markov chain? To the Wikipedia!)

[19:40] <masak> lue: because I know you'll be delighted ;)

[19:41] <colomon> sorear: I started coding up .sin for Niecza this morning -- need to talk to you about it at some point, but now is not really a good time for me.  :)

[19:41] <masak> lue: make sure you check prior art: http://en.wikipedia.org/wiki/Dissociated_press

[19:41] *** cooper joined
[19:41] *** cooper left
[19:41] *** cooper joined
[19:47] <lue> I'm still wondering what exactly you mean by Markov-chain spec generator. spec as in the Perl6 spec? would it just take various synopses and use them to create humorous texts?

[19:47] <sorear> https://secure.wikimedia.org/wikipedia/en/wiki/SCIgen is much better prior art, IMHO

[19:48] <Su-Shee> lue: scroll up :) 

[19:48] * pmichaud detects a lightning talk for yapc::eu

[19:49] <mberends> lue: FYI: http://irclog.perlgeek.de/perl6/2011-06-13#i_3918205 etc etc

[19:49] <Su-Shee> a real one or a made-up-on-the-fly one with realtime human markov chaining specs? ;)

[19:49] <masak> lue: at this point, you might want to backlog :P

[19:49] <masak> oh, Su-Shee++ and mberends++ beat me to it :)

[19:50] <lue> Hm, I wonder if I should backlog.

[19:50] <lue> </sarcasm>

[19:51] <pmichaud> my wife suggests a game:  "Is it markov or is it spec?"

[19:51] *** Bzek_ left
[19:52] <jnthn> lol :D

[19:52] <pmichaud> grab markov chain sequences and intersperse them with real stuff from the spec and see who can tell the difference :)

[19:52] <jnthn> pmichaud: I've heard all kinds of interesting reports about that test file.

[19:52] <pmichaud> jnthn: which one?  the 01-p6regex.t?

[19:52] <jnthn> pmichaud: How's the temps patch looking otehrwise?

[19:52] <jnthn> pmichaud: yes

[19:52] <pmichaud> I need to muck around with it a bit I think.

[19:52] <jnthn> pmichaud: I don't even get it run when I do make test here :S

[19:52] <TimToady> it helps to filter generated sentences through a parser, though, to weed out obvious grammaros

[19:53] <colomon> But the spec has those too.... ;)

[19:53] <pmichaud> we'd probably pick out some candidates in advance

[19:53] <pmichaud> jnthn: I think I'm almost done.

[19:53] <pmichaud> the basic implementation was pretty straightforward, but then one has to be careful with things like exception handler blocks and lexicals and the like

[19:54] <jnthn> pmichaud: Yes, can imagine :)

[19:54] <jnthn> pmichaud: Any sense on improvement to CORE.setting.pir compilation?

[19:54] <pmichaud> haven't gotten to that yet.

[19:54] <pmichaud> will do that next.

[19:55] <jnthn> k

[19:55] <pmichaud> however, my test case I was looking at yesterday is down to 15 "permanent" registers being allocated, with the rest all as temporaries.

[19:55] <jnthn> Just need to write something up for $dayjob and then can get back to nom hacking for a bit.

[19:56] <lue> So the basic premise of the generator is to mathematically take words from the spec and put them together, am I right?

[19:57] <masak> lue: yes. semi-guided randomness.

[19:57] <lue> Sounds like fun :)

[19:59] *** mj41 left
[19:59] <TimToady> see http://cpan.perl.org/scripts/nutshell/ch6/travesty

[20:00] <dalek> rakudo/nom: 11eb26f | moritz++ | LHF.markdown:

[20:00] <dalek> rakudo/nom: remove Complex from LHF

[20:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/11eb26f71e

[20:04] *** araujo joined
[20:04] *** araujo left
[20:04] *** araujo joined
[20:06] <pmichaud> jnthn: with latest version of temporary register allocator, my test program goes from 173 permanently allocated registers to 10.  And all but two of those are lexicals or subroutine constants.  (The two that remain need to be non-temporary as well.)

[20:06] *** Moukeddar joined
[20:07] <Moukeddar> Hello

[20:07] <mberends> hi again Moukeddar

[20:07] <Moukeddar> still good?

[20:07] <masak> rehi, Moukeddar.

[20:07] <masak> better than ever :)

[20:08] <Moukeddar> Good to hear

[20:08] <mberends> Moukeddar: very good, you too I hope

[20:08] <Moukeddar> i'm fine , the exams are soon :)

[20:08] <Moukeddar> take a look masak 

[20:08] <Moukeddar> http://i.imgur.com/xyI7P.png

[20:08] * masak looks

[20:09] <masak> Moukeddar: nice :)

[20:09] * mberends likes

[20:09] <lue> (aah, now you got me thinking hard about how to do such a thing /o\)

[20:10] <Moukeddar> now , the hard part , actuallty coding it :)

[20:10] <dalek> rakudo/nom: 135459a | moritz++ | src/core/List.pm:

[20:10] <dalek> rakudo/nom: add some numeric coercion methods to List

[20:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/135459a004

[20:10] <jnthn> pmichaud: Great! I think we'll need that sort of thing for when I get to implementing hyperroles...they'll need lots of registers.

[20:10] <masak> Moukeddar: no, the design is the hard part. it's just not evident yet ;)

[20:11] <Moukeddar> i'm just getting started

[20:11] <jnthn> pmichaud: Gotta do the quantum dispatch first though....

[20:11] <moritz> masak: that always depends on the level of experience

[20:11] <mberends> Moukeddar: s/hard/fun/ !

[20:11] <masak> moritz: you're right, as always.

[20:11] <Moukeddar> yes , yes , i'm accumulating the knowledge :)

[20:13] <mberends> jnthn: s/hyperr/hyperb/ !

[20:14] <moritz> in rakudo/master, push, pop etc. al. are implemented in List, not in Array. Is that intentional?

[20:14] <pmichaud> jnthn: ... it didn't help.

[20:14] <pmichaud> gist coming.

[20:15] <pmichaud> what is responsible for generating  http://gist.github.com/1023585 ?

[20:15] * masak hoped it was Markov spec and was disappointed :)

[20:16] *** lumi_ left
[20:17] *** lumi_ joined
[20:18] <lue> As soon as I understand Markov chains, I can start thinking about that spec generator.

[20:18] <jnthn> pmichaud: It didn't? Ouch. :S

[20:18] <jnthn> pmichaud: What's the range it allocates registers in as temporaries?

[20:19] <jnthn> pmichaud: For example, if I look at this:

[20:19] <jnthn>     .const 'Sub' $P24021 = "12_1307995813.53488"

[20:19] <jnthn>     nqp_get_sc_object $P24022, "1307995813.26545", 92

[20:19] <jnthn>     nqp_get_sc_object $P24023, "1307995805.20037", 206

[20:19] <jnthn>     setattribute $P24022, $P24023, "$!do", $P24021

[20:19] <jnthn> Here, $P24022 and $P24023 should be temporaries

[20:19] <pmichaud> sure

[20:20] <pmichaud> but I'm thinking whatever generated that isn't marked properly (more)

[20:20] <pmichaud> I ended up leaving PAST::Stmts alone, for backcompat and other reasons

[20:20] <pmichaud> instead, there's now PAST::Stmt, which represents a single "statement"

[20:20] <jnthn> pmichaud: SymbolTable.pm in Rakudo and HLL::SerializationContext in NQP are responsible.

[20:20] <jnthn> pmichaud: Ah, that's new?

[20:20] <pmichaud> yes.

[20:21] <jnthn> pmichaud: 994/995

[20:21] <jnthn> In SymbolTable.pm

[20:21] <pmichaud> PAST::Stmt can contain multiple operations to be performed, like Stmts, but it considers any temporary registers allocated within to be reusable outside of the statement

[20:21] <pmichaud> I already fixed 994/995 to be Stmt

[20:21] <jnthn> Oh.

[20:21] <pmichaud> I'm thinking it's 432 that needs to change

[20:22] <pmichaud> I want to s/Stmts/Stmt/   there

[20:22] <jnthn> pmichaud: here 432 is a comment line

[20:22] <pmichaud>        # Fixup will install the real thing.

[20:22] <pmichaud>         $fixups.push(PAST::Stmts.new(

[20:23] <sorear> is Stmts the old thing that allows for reusing temporaries?

[20:23] <pmichaud> Stmt is just like Stmts but handles the register boundary.  (Also, one could consider that Stmts is the container for multiple Stmt nodes

[20:23] <jnthn> pmichaud: Ah, that's 451 here. :)

[20:24] <sorear> masak: (how's the niecza hacking) ok.  I'm moving niecza away from "use STD with as few modifications as possible", which is a bit... sad

[20:24] <jnthn> pmichaud: How did you get that chunk of PIR, ooc?

[20:24] <pmichaud> looking at src/gen/CORE.setting.pir

[20:24] <jnthn> pmichaud: Oh...do you have my patch from yesterday applied?

[20:25] <pmichaud> the Stmts one, yes.  but not the one that turns off the part that needed turning off :)

[20:25] <masak> sorear: why are you doing that?

[20:25] <pmichaud> I said I wasn't going to pull until I had temporaries working.  :)

[20:25] <jnthn> pmichaud: *nod*

[20:25] <jnthn> pmichaud: It's just that the bit of code you gisted me is a part that we don't emit in the CORE.setting.pir case any more ;)

[20:25] <sorear> masak: because STD isn't just a parser

[20:26] <pmichaud> right 

[20:26] <jnthn> pmichaud: Though it is emitted in the run-right-away case.

[20:26] <pmichaud> it's the part that is making things slow

[20:26] <jnthn> So it's still relevant to fix.

[20:26] <jnthn> Ah, hm

[20:26] <pmichaud> which is why I need it to remain so I can figure out when we've crossed over to not-as-slow

[20:26] <jnthn> Yup

[20:26] <jnthn> OK, maybe the PAST::Stmt where you suggested helps.

[20:26] <pmichaud> actually, I'm going to do it in several places that look right and see what happens :)

[20:27] <jnthn> pmichaud: Also on 463

[20:27] <jnthn> Under CLONE_CALLBACK

[20:27] <sorear> masak: STD also does various kinds of lexical scope analysis; it's redundant (and slow) with the more-complete analysis niecza does to compile, and when the two get out of sync, things get pretty confused

[20:27] <sorear> niecza: { our $x }; say $x

[20:27] <p6eval> niecza v6-153-g6cb84d6: OUTPUT«===SORRY!===␤␤Variable $x is not predeclared at /tmp/X7GS_mLUbw line 1:␤------> { our $x }; say ⏏$x␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at

[20:27] <p6eval> ../home/p6eval/niecza/src/STD.pm6 …

[20:27] <pmichaud> yeah, I shuddered when I saw the setprop opcode there :)

[20:27] <jnthn> pmichaud: Evil trick is evil

[20:27] <sorear> oops, I fixed that one already :)

[20:27] <jnthn> pmichaud: It's the only setprop in the entir eof nom :)

[20:27] <jnthn> *entire of

[20:28] <pmichaud> tsk tsk... once you start down the dark path, forever will it dominate your destiny.  :-)

[20:28] <jnthn> pmichaud: I, er...didn't have an unused PMC * in Parrot Sub to use.

[20:28] <masak> sorear: understandable. sounds like the right decision, if you ask me.

[20:28] <jnthn> I'm already abusing its multisig slot for something that's not one. :)

[20:31] <benabik> In NQP-rx is `foo_sub(:named<a>)` supposed to be the same as `foo_sub(named => 'a')` or `foo_sub(named => ['a'])`?  I thought it was the former but it turned out to be the latter.

[20:31] *** cooper is now known as Cooper

[20:32] <sorear> If Parrot were to deprecate property hashes in 3.6.0, would nom care?

[20:33] * sorear is excited by the possibility of saving 1 word per PMC

[20:34] *** hudnix joined
[20:37] <pmichaud> nom wouldn't, but master would.

[20:37] <pmichaud> (and nom might also)

[20:37] <pmichaud> compile of src/gen/CORE.settings.pir:   was 48sec  now 17sec

[20:37] <benabik> pmichaud++

[20:38] <benabik> (Even if he keep changing code out from under my GSoC project. ;-) )

[20:38] <pmichaud> yeah, sorry for the extra hassle

[20:39] <benabik> pmichaud: Bah.  I'd rather not have my project hold up improvements.

[20:39] *** masak left
[20:41] <thou> szabgab: did you ever solve that rakudo compile issue? this is what i'm looking at when i compile rakudo-star-2011-04: http://www.pastebot.net/paste/842gPkQVRS5/

[20:41] <thou> (and sorry i dropped out on you yesterday about this...)

[20:41] <sorear> o/ thou

[20:42] *** Zapelius left
[20:42] <thou> that was during "perl Configure.pl --gen-parrot", which i assume you were doing, too

[20:43] <pmichaud> jnthn: how about http://gist.github.com/1023646  .... what's generating that?

[20:43] <jnthn> pmichaud: phone, moment

[20:43] <pmichaud> okay

[20:46] <thou> szabgab: odd that you're using cc instead of c++; but the main thing i see is that the first -L flag for you isn't pointing at .../parrot-VERSION/blib/lib, it's just going to .../blib/lib -- and it seems that libparrot isn't getting installed there like it should

[20:46] *** masak joined
[20:47] <pmichaud> bbi10

[20:47] <thou> szabgab: in my test i didn't pass --prefix=FOO, which might be part of the issue; anyways, it doesn't seem to be related to Ubuntu 8.04, since it seems due to bad flags being passed to the tools or similar, not due to compiler version or something

[20:48] <thou> szabgab: i didn't go to the lengths of installing ubuntu 8.04 and trying it there, though.

[20:48] <thou> sorear: howdy!

[20:50] <masak> hi, thou.

[20:50] <masak> I haven't named my sourdough yet.

[20:51] <thou> hej, masak.  :-)

[20:51] <masak> :)

[20:51] *** Zapelius joined
[20:51] <thou> i think Herman was like 20 years old when Mom got [some of] him

[20:52] <thou> at least i remember being pretty impressed with the story when she first brought him home

[20:52] <masak> indeed impressive.

[20:52] <thou> could have been 2 years, i suppose, given a youngster's time perspective :-)

[20:52] <colomon> My beloved Homer went all moldy in '10.

[20:52] <colomon> He was given to me by a fictional character, weirdly enough.

[20:53] <thou> awwww

[20:53] <lue> I'm thinking the MCSG should work on a per-character basis. I can easily come up with a way to do it, but it involves a large table and I'm not sure I like that idea so much...

[20:53] <masak> lue: it does involve a large table.

[20:54] <masak> lue: from experience, per-character is too fine-grained.

[20:54] <masak> lue: per-word is much more fun. or two or three words, even.

[20:54] <sorear> per-character makes it generate nonsense words like "Presidentagon"

[20:54] <masak> if you're lucky.

[20:54] <sorear> thou: I think --gen-parrot is obsolete and we use --gen-nqp now

[20:55] * thou will try that w/ trunk

[20:56] <lue> Oh, you don't use --gen-parrot anymore?

[20:56] *** lumi_ left
[20:57] *** Moukeddar left
[20:57] <thou> at least the 2011.04 README still recommends --gen-parrot

[20:57] <sorear> must be a nom/master thing

[20:57] *** lumi_ joined
[20:57] * thou still doesn't know what nom is

[20:57] <lue> This is a per-character generator which works quite well (on the default order of 4, whatever "order" means): http://www.haykranen.nl/projects/markov/demo/

[20:58] <thou> ... except as part of "nom, nom, nom, COOKIE!!!, nom nom"

[20:58] <jnthn> pmichaud: back

[20:58] <jnthn> pmichaud: Revenge of the $dayjob :)

[20:58] <jnthn> pmichaud: Looks like you're looking at create_parameter output

[20:59] <sorear> thou: nom!  it's like Rakudo, but better.

[20:59] <jnthn> pmichaud: Actually, method set_attribute - put a PAST::Stmt around that.

[21:00] <sorear> it's pretty clearly the best Perl 6 compiler available.

[21:00] <lue> .oO( nom > ng > alpha )

[21:01] <jnthn> sorear: not yet :)

[21:01] <jnthn> sorear: Maybe when we have more features, and less SEGV :)

[21:03] *** scottp joined
[21:03] *** scottp left
[21:04] <moritz> it's both pretty amazing what nom can do, and what it can't do yet :-)

[21:05] <jnthn> .oO( It's pretty amazing how big Perl 6 is... :) )

[21:05] <thou> yeah, i had a vague idea that it's related to 6model. now i have googled and know more what it is :-)

[21:07] *** Juerd left
[21:08] <jnthn> thou: It's re-building Rakudo on top of 6model, essentially.

[21:09] <lue> [ running S03 through the Markov chain generator created this line as its own paragraph: "S03-metaoperator more complicated." :) ]

[21:10] <masak> lue: hard to argue with that :P

[21:10] <pmichaud> jnthn:  PAST::Stmt around set_attribute still leaves    http://gist.github.com/1023717

[21:11] <jnthn> pmichaud: OK, that looks like create_parameter output.

[21:12] <thou> thanks to whiteknight++ for http://whiteknight.github.com/2011/05/07/6model_on_parrot.html

[21:12] <moritz> is the setting compilation (the pir->pbc) part actually faster with the new stuff?

[21:12] <jnthn> pmichaud: And partly build_container_past

[21:19] *** Zapelius left
[21:19] *** bitpart joined
[21:21] <lue> I think I'll go do a true Markov chain (weighted probability word-for-word) instead of the dissociated press method (what emacs uses). Off to the races, I guess!

[21:21] <sorear> well, they are equivalent

[21:34] *** estrabd joined
[21:36] *** bitpart left
[21:38] <lue> afk

[21:40] *** estrabd left
[21:40] *** jfried left
[21:41] *** Psyche^ joined
[21:42] <lichtkind> how much faster rakudo went in last year you would estimate?

[21:43] <masak> rakudo is slower than alpha.

[21:44] <lichtkind> you mean rakudo ng is still slower than the old branch?

[21:44] <masak> I would say so.

[21:44] <lichtkind> ah

[21:44] <pmichaud> but it does so much more than the old branch

[21:44] *** Patterner left
[21:44] *** Psyche^ is now known as Patterner

[21:44] <masak> oh, for sure.

[21:44] <pmichaud> so it's not an apples-to-apples comparison.

[21:44] <masak> ng is more correct.

[21:45] <pmichaud> the purpose of the ng branch was feature completeness and correctness more than "faster alpha"

[21:45] *** spq1 left
[21:45] <lichtkind> and has more layer if understand correctly

[21:45] <masak> I'm not criticizing, of course. I'm saying November runs faster on alpha than on ng.

[21:45] <pmichaud> I can't speak to "the past year" (also an apples-to-oranges comparison), but since January Rakudo+Parrot have sped up about 8%.

[21:45] <pmichaud> as much as 30% depending on your machine's characteristics and application.

[21:46] <pmichaud> https://github.com/pmichaud/rpbench-results

[21:46] *** george_z0rwell left
[21:46] <pmichaud> more specifically:  https://github.com/pmichaud/rpbench-results/blob/master/kiwi-x86_64-7994m-201105191411.txt

[21:47] *** bluescreen10 left
[21:47] <pmichaud> https://github.com/pmichaud/rpbench-results/blob/master/orange-x86_64-3521m-201105191414.txt

[21:47] *** bluescreen10 joined
[21:48] <jnthn> .oO( are they named after fruits, colors, or both? :) )

[21:48] <pmichaud> fruits more than colors

[21:49] <pmichaud> but yes, when I remote shell into any of the machines, the window background matches the color of the fruit  (suitably tinted as to not be over-saturated)

[21:49] <pmichaud> that way I can instantly know what machine a window is for without having to check the title

[21:49] <jnthn> wow, nice :)

[21:49] <pmichaud> or can have a subtle clue that "sudo poweroff" might be going to the wrong target.  :-)

[21:49] <lichtkind> thank you patrick

[21:50] <pmichaud> all of the computers in the Pm household are named for fruits :)

[21:50] <lichtkind> he isnt nuts :)

[21:50] * jnthn looks forward to benchmarks from pomegranate

[21:51] <thou> sorear: looks like nom's Configure.pl will add --gen-nqp if --(with|gen)-parrot is specified, so the old instructions should still work. i'm testing it out now :-)

[21:51] <pmichaud> for some reason nom isn't reusing registers as well as it should.

[21:51] <pmichaud> and --target=past doesn't help :(

[21:52] <pmichaud> s/help/work/  # actually

[21:52] *** lumi_ left
[21:53] *** lumi_ joined
[21:54] *** estrabd joined
[21:54] <jnthn> pmichaud: In

[21:54] <jnthn>         pir::setattribute__0PPsP(

[21:54] <jnthn>             pir::repr_instance_of__PP(List),

[21:54] <jnthn>             List, '$!rest', $!params);

[21:54] <jnthn> pmichaud: Might this be destructive to $!params?

[21:54] <masak> blog post! http://strangelyconsistent.org/blog/june-13-regexes

[21:55] <pmichaud> jnthn: what file?

[21:55] *** estrabd left
[21:55] <pmichaud> (short answer:  yes, it could destroy $!params.  but depending on context that may be okay)

[21:56] <jnthn> pmichaud: ah

[21:56] <jnthn> pmichaud: That, er

[21:56] <jnthn> Probably explains why when we .perl a signature, it loses its parameters :)

[21:56] <pmichaud> use  pir::clone__PP($!params) then.

[21:56] <jnthn> *nod*

[21:56] <jnthn> Guessed that would do it :)

[21:57] <jnthn> Was a bit spooky

[21:57] <jnthn> "huh, where'd the params go?!" :)

[21:57] <pmichaud> jnthn: where do PAST::BLOCK objects go in nom?  e.g., for a subroutine definition?

[21:57] *** Maddeth left
[21:57] <pmichaud> do they still remain children of the outer block?

[21:57] <jnthn> pmichaud: Into [0] of the outer block

[21:57] *** estrabd joined
[21:57] <pmichaud> not as statements, then?

[21:58] <jnthn> pmichaud: We don't do *anything* with PAST::Block in nom other than stick them in the outer block.

[21:58] <jnthn> pmichaud: Anything in SymbolTable.pm that wants to talk about one uses PAST::Val.new( :value($the_past_block) )

[21:58] <jnthn> Otherwise the lexical scoping gets all busted, which was the source of much pain in master.

[21:58] <pmichaud> okay.

[21:59] <pmichaud> would it hurt much to change

[21:59] <pmichaud> $outer[0].push($block);

[21:59] <pmichaud> to

[21:59] <pmichaud> $outer[0].push(PAST::Stmt.new($block))

[21:59] <pmichaud> (I'm thinking "yes")

[21:59] <jnthn> pmichaud: Would it affect capture_lex?

[21:59] <pmichaud> it might.

[21:59] <pmichaud> okay, I have another approach.

[22:00] <jnthn> OK, if yes then we're in trouble

[22:00] <jnthn> oh wait

[22:00] <jnthn> It's unlikey to

[22:00] <jnthn> Becuase [0] is a PAST::Stmts.

[22:00] <jnthn> (I retained the PAST::Block with 2 PAST::Stmts approach we used in ng...)

[22:00] <pmichaud> right

[22:00] <pmichaud> right, it won't affect capture_lex

[22:00] <pmichaud> okay, let me try it and see what happens

[22:00] <pmichaud> I follow the model you're using now  (and lik eit)

[22:01] <jnthn> Well, you created the 2-stmts bit ;)

[22:01] <pmichaud> if $outer[0] is Stmts then it makes almost infinite sense that its contents will be Stmt

[22:01] <jnthn> ;)

[22:01] <jnthn> Note that this probably helps the SC little.

[22:02] <jnthn> But I guess you're looking at nom's register alloc more generally.

[22:02] <pmichaud> it's not the SC that I'm grappling with at the moment.

[22:02] <jnthn> ah, OK

[22:02] *** bluescreen10 left
[22:02] <pmichaud> after making that change....

[22:02] <jnthn> SEGV (core dumped)

[22:02] <jnthn> ;)

[22:03] <pmichaud> compilation of CORE.settng.pir:   was 47sec   now 5sec

[22:03] <benabik> !

[22:03] <pmichaud> (47sec is where things were before I started this morning.  without that small change, CORE.setting.pir was 16sec

[22:05] <jnthn> \o/

[22:05] <jnthn> pmichaud++

[22:05] <jnthn> !!

[22:06] <jnthn> pmichaud: Wonder if there's a further improvement with my patch from yesterday also

[22:06] <pmichaud> I'm sure there will be

[22:06] <pmichaud> CORE.setting.pir is still 45K lines long.  With your patch it'll be much less.

[22:07] <sorear> I thought jnthn's patch from yesterday had no effect on --target=pir

[22:07] <jnthn> sorear: You misthunk. :)

[22:07] <jnthn> It had a smaller effect on that than the other case.

[22:08] <jnthn> But an effect nonetheless.

[22:08] <pmichaud> okay, time for me to go back and put a few items in place

[22:08] <pmichaud> not having --target=past is hurting, though.

[22:09] <tadzik> why is it broken?

[22:09] <jnthn> dumper doesn't know 6model, I guess

[22:09] <pmichaud> I think .... what jnthn++ said

[22:11] <tadzik> did it work before 6model?

[22:11] <jnthn> nom: sub x($a) { }; say &x.signature.perl; say &x.signature.perl

[22:11] <p6eval> nom: OUTPUT«:(Any $a)␤:()␤»

[22:12] <jnthn> lol :)

[22:13] <pmichaud> jnthn: does nom fetch all of its constants at the beginning of a block/routine?

[22:14] <jnthn> pmichaud: Not yet (more)

[22:14] <jnthn> pmichaud: The more obvious one is to fetch the SCs it uses so it can do cheaper lookups

[22:14] <jnthn> I can do taht with the deserialization code too and get a small discount on startup time.

[22:14] <jnthn> Lots of room for optimization.

[22:17] <sorear> On the subject of ENTER stuff and constants, I'm having a problem with S04:1720

[22:18] <sorear> niecza: sub foo($x = { say 5 }) { $x }; foo().()

[22:18] <p6eval> niecza v6-153-g6cb84d6: OUTPUT«Unhandled exception: System.Exception: Improper null return from sub default for $x = { say 5 } in MAIN foo␤  at Niecza.SubInfo.Binder (Niecza.Frame caller, Niecza.Frame outer, Niecza.P6any sub, Niecza.Variable[] pos, Niecza.VarHash named, Boolean quiet,

[22:18] <p6eval> ..Niecza.DispatchEnt de) [0x0…

[22:19] <sorear> { say 5 } is cloned when the lexical scope is entered, but that's too late to produce a non-null value for the binder

[22:19] <jnthn> nom: sub foo($x = { say 5 }) { $x }; foo().() # not sure if it'l handle it...

[22:19] <p6eval> nom: OUTPUT«Lexical '$_' not found␤current instr.: '_block22' pc 923 ((file unknown):519) (:1)␤»

[22:19] *** lumi_ left
[22:19] <jnthn> nom: sub foo($x = -> { say 5 }) { $x }; foo().() # not sure if it'l handle it...

[22:19] <p6eval> nom: OUTPUT«5␤»

[22:19] <jnthn> sorear: We carefully call the binder after that.

[22:20] *** whiteknight joined
[22:20] *** lumi_ joined
[22:20] <sorear> nom: my $i = 0; my @x; push @x, sub () {} while ($i++) < 2; say @x[0] === @x[1]

[22:20] <p6eval> nom: OUTPUT«Can only use get_who on a SixModelObject␤current instr.: '_block13' pc 137 ((file unknown):26123756) (:1)␤»

[22:21] <sorear> rakudo: my $i = 0; my @x; push @x, sub () {} while ($i++) < 2; say @x[0] === @x[1]

[22:21] <p6eval> rakudo ae5bea: OUTPUT«Bool::False␤»

[22:21] <pmichaud> okay, time to do some merges and pushes.

[22:21] <sorear> niecza: my $i = 0; my @x; push @x, sub () {} while ($i++) < 2; say @x[0] === @x[1]

[22:21] <p6eval> niecza v6-153-g6cb84d6: OUTPUT«Bool::True␤»

[22:21] <sorear> it seems master doesn't implement S04:1720

[22:21] <sorear> does nom?

[22:21] <jnthn> Not sure why I'd expect that to be true.

[22:22] <jnthn> Oh, maybe for === I can

[22:22] * jnthn was thinking =:=, which will certainly be false

[22:22] <jnthn> sorear: I can implement it easy enough in nom if that's what needs to happen.

[22:24] <jnthn> sorear: tbh, master doesn't really get .WHICH right at all.

[22:24] <jnthn> sorear: So that whole lot needs a re-visit anyway.

[22:26] <sorear> jnthn: long-term, it won't be obverbable; Sub is an immutable type, and two clones of the same sub with the same OUTER:: should be ===

[22:26] <sorear> observable

[22:27] <sorear> Rakudo/master compiles sub () { } to something like Sub.new(pir::capturelex(pir::clone($SUB)))

[22:28] <sorear> niecza compiles sub () { } to something like &anon_42 with code at the beginning to Sub.new($subinfo, callframe)

[22:28] <sorear> which does nom do?

[22:28] <jnthn> sorear: Similar to master. I wasn't planning on changing that really.

[22:28] <jnthn> sorear: Also Sub is explicitly not immutable by spec

[22:29] <jnthn> sorear: Routines are mutable, otherwise .wrap can't work.

[22:29] <sorear> jnthn: the spec is unclear whether .wrap is intended to apply to the Sub or to the underlying code object

[22:29] <jnthn> sorear: That may be a good thing.

[22:30] <sorear> sub mkacc() { my $x = 0; sub () { $x++ } }; my $a = mkacc; my $b = mkacc; $a.wrap(sub () { return 42 }); say $b()

[22:31] <jnthn> I don't really get "underlying code object"

[22:31] <jnthn> Sub ~~ Code

[22:31] <jnthn> Or do you mean $!do?

[22:32] <jnthn> pmichaud: my @x = 1,2,3; my @y = @x; @x[0] = 100; say @y[0] looks dubious

[22:32] <sorear> jnthn: In Rakudo terms, I mean $!do

[22:32] <sorear> except not

[22:32] <sorear> because $!do is cloned

[22:32] <jnthn> Right

[22:32] <sorear> I mean the part which isn't cloned

[22:32] <sorear> the code segment

[22:33] <jnthn> Yeah, that's how I'd do === being true for two subs

[22:33] <jnthn> Look at the code segment pointer.

[22:36] <jnthn> sorear: In your example I'd expect only $a to have been wrapped.

[22:38] <dalek> rakudo/nom: e8bda83 | jnthn++ | src/binder/multidispatch.c:

[22:38] <dalek> rakudo/nom: Try a simpler approach to signature bind testing for mutli disambiguation.

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e8bda839e9

[22:38] <dalek> rakudo/nom: 0144714 | jnthn++ | src/ (2 files):

[22:38] <dalek> rakudo/nom: Handlers for 'is rw' and and 'is copy' trait on parameters, plus a stub trait_mod:<as>.

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0144714aff

[22:38] <dalek> rakudo/nom: e3273a5 | jnthn++ | src/core/traits.pm:

[22:38] <dalek> rakudo/nom: Oops, didn't mean to commit Parameter rw trait commented out.

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e3273a525a

[22:38] <dalek> rakudo/nom: 54141c8 | jnthn++ | src/Perl6/Actions.pm:

[22:38] <dalek> rakudo/nom: Apply parameter traits.

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/54141c8fb0

[22:38] <dalek> rakudo/nom: 2354e78 | jnthn++ | src/ (2 files):

[22:38] <dalek> rakudo/nom: First cut of 'is rw' and 'is copy'. Not fully right yet; looks like there may be a .STORE issue on Array.

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2354e7805e

[22:38] <dalek> rakudo/nom: 1727d60 | jnthn++ | src/core/Signature.pm:

[22:38] <dalek> rakudo/nom: Make sure Signature.params doesn't nom the params.

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1727d604be

[22:44] *** tomize left
[22:45] * jnthn wishes he'd slept more than 3ish hours last night...

[22:48] <kliff> hello

[22:48] <kliff> :)

[22:49] *** Tedd1 left
[22:51] <thou> hi, kiff

[22:51] <thou> s/kiff/kliff/

[22:52] *** Tedd1 joined
[22:54] <thou> moritz: should we s/proto/panda/g on https://github.com/rakudo/rakudo/wiki/What%27s-going-into-Rakudo-*%3F ?

[22:54] <thou> (which is pointed to by rakudo/star/README)

[22:55] <jnthn> thou: Probably yes

[22:55] <jnthn> thou: Well, almost certainly yes :)

[23:01] *** tomize joined
[23:02] <thou> hmmm, i guess the first reference to proto still needs to be proto -- regarding the bootstrapping of rakudo and parrot themselves.

[23:04] <thou> ok, edit made, hopefully it's in the right direction.

[23:07] *** mtk left
[23:14] *** cdarroch left
[23:16] *** nsh left
[23:16] *** icwiener left
[23:18] *** nsh joined
[23:19] *** nsh is now known as Guest87668

[23:27] *** Cooper is now known as cooper

[23:32] *** Chillance left
[23:34] <sorear> jnthn: ping

[23:36] *** dju_ joined
[23:37] <jnthn> sorear: sleepy pong

[23:37] <jnthn> (easy questions, plz :))

[23:37] <sorear> jnthn: does it make sense to catch redeclarations of our-symbols?

[23:37] <sorear> generally I interpret our-scope as a COMMON sort of thing

[23:38] <sorear> likewise nom seems to

[23:38] <jnthn> sorear: Do you mean "within the same lexical scope"?

[23:38] <sorear> no

[23:38] <jnthn> sorear: Or in a wider sense?

[23:38] *** dju left
[23:38] <sorear> I mean redeclaration of the package object

[23:39] <sorear> in particular, sub Foo::bar() { }; sub Foo::bar() { }

[23:39] <jnthn> Oh, that. :/

[23:39] *** kliff left
[23:39] <jnthn> That's weird too because subs default to my scope

[23:40] <sorear> related questions include:  'package Foo { our &bar; }; sub Foo::bar() { }'

[23:40] <jnthn> I'm not sure master has ever supported multi-part sub names.

[23:41] <jnthn> I'd forgotten you could do that.

[23:41] <jnthn> I suspect it's not an error, anyway

[23:41] * jnthn has to wonder *why* you can do that

[23:41] <sorear> Do you rule that the second overrides the first?

[23:41] <jnthn> Also whether my sub Foo::bar() { } and our sub Foo::bar() { } mean different things.

[23:42] <jnthn> sorear: It'd seem so.

[23:42] <jnthn> sorear: But I'm quite bothered about this:

[23:42] <sorear> jnthn: I rule that "my sub Foo::bar" is an error

[23:42] <jnthn> sorear: Then sub Foo::bar is also an error.

[23:42] <jnthn> Because the default scope declarator for subs is "my"

[23:42] <sorear> lack of a scope is weakly DWIM.  for instance, 'my sub () { }' makes no sense, but 'sub () { }' means "anon"

[23:43] <jnthn> What happens here:

[23:43] <jnthn> my package Foo { }; our sub Foo::bar { }

[23:43] <sorear> I fear I may have asked a non-easy question :/

[23:44] <jnthn> Does Foo suddenly get promoted to an our-scoped package? Error?

[23:44] <sorear> No

[23:44] <jnthn> Well, mostly you've ticked my "wtf do we even want to support Foo::bar as a sub name anyway" nerve :-)

[23:44] <sorear> "our" just means "in a package"; it says nothing about where *the package* lives

[23:44] <jnthn> That's not really true.

[23:45] <jnthn> Oh, wait

[23:45] <jnthn> I see what you were getting at.

[23:45] <jnthn> I still don't like this at all.

[23:45] <jnthn> My gut feeling is just "ban multi-part sub names and save people a lifetime of confusion over the semantics"

[23:46] <sorear> Multi-part sub names have exactly the same semantics as multi-part class names

[23:46] <sorear> (and they share a LOT of code in niecza)

[23:46] <sorear> If I ban the latter people will not be amused.

[23:47] <sorear> This isn't just a question of subs; it's also about if and how 'class Foo::Bar {}; class Foo::Bar {}' should be detected and caught.

[23:47] <jnthn> Yes, those absolutely should.

[23:48] <jnthn> So maybe the answer for subs is the same. They declare-y, after all.

[23:49] <jnthn> Maybe I should just shove multi-part sub names through the same code path as multi-part package names and see what happens. :)

[23:53] <sorear> the other question is how do you *detect* redeclaration?

[23:54] <jnthn> nom: class Foo::Bar { }; class Foo::Bar { } # checking...

[23:54] <p6eval> nom: OUTPUT«"load_bytecode" couldn't find file 'CORE.setting.pbc'␤current instr.: 'nqp;Perl6;ModuleLoader;_block314' pc 3008 (src/gen/perl6-moduleloader.pir:1160)␤»

[23:54] <jnthn> fail

[23:54] <jnthn> nom: class Foo::Bar { }; class Foo::Bar { } # checking...

[23:54] <p6eval> nom: OUTPUT«Illegal redeclaration of class 'Foo::Bar' at line 1, near "{ } # chec"␤current instr.: 'nqp;HLL;Grammar;panic' pc 26397 (src/stage2/gen/NQPHLL.pir:7039)␤»

[23:54] <jnthn> ah, rebuild

[23:54] <jnthn> sorear: We just look in the Foo package to see if there's a Bar there :)

[23:55] <jnthn> And if there is a Bar there, we go in for a pint...er...complain. :)

[23:55] <sorear> jnthn: what if there's only a Bar there because of an autovivifying reference to defined(Foo::Bar) in a BEGIN somewhere?

[23:56] <jnthn> It'll have only auto-vivified a package, and I consider those "stealable"

[23:56] <jnthn> That's why I'd expect class Foo::Bar { }; class Foo { } to work also.

[23:56] <sorear> How does stealing work?

[23:57] <jnthn> Grab the WHO of the package, make it your own WHO, install yourself.

[23:57] <sorear> Are packages always stealable?

[23:57] <jnthn> By packages I mean things declared with "package" or auto-viv'd to "package"

[23:58] <jnthn> So for that definition yes.

[23:58] <jnthn> module Foo { }; class Foo { } # problem.

[23:58] <jnthn> Where problem means redeclaration error.

[23:59] <jnthn> Note, didn't get to implementing these semantics in nom yet.

[23:59] <jnthn> On my todo ist.

[23:59] <jnthn> *list

[23:59] *** gabiruh left
[23:59] <jnthn> Probably for the nearish future...if I ever get roles finished. :)

