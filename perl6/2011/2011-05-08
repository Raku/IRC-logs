[00:00] <jnthn> Guess I can read "within its scope" both ways... :)

[00:01] <masak> here's the mental model I had of things.

[00:01] <jnthn> masak: But see the langauge on a proto's "managed set" later on in S06.

[00:02] <masak> yeah, I'm reading it now.

[00:03] <masak> I see 'proto' and 'only' as the same shape of thing.

[00:03] <masak> 'multi' is nowadays a kind of subordinate to 'proto'.

[00:04] <masak> so each time you do 'proto' or 'only', you define a new thing, hiding the old thing.

[00:04] <jnthn> right, writing only or proto would always give you one of those

[00:04] <masak> in explaining this, I think I see now why newbee's sub should become a multi :)

[00:04] *** perimosocordiae left
[00:05] <masak> (because there's a proto in the setting, so 'only' isn't the default for infix:<+>)

[00:05] <jnthn> I'm mostly curious about whether a proto means that all the places that can see it default to multi for that name.

[00:05] <masak> right. I think it might.

[00:05] <masak> in which case I agree fully.

[00:05] <jnthn> Yeah, that's how I'd understood it so far.

[00:05] <masak> that's actually quite nice.

[00:05] <jnthn> Yeah, I think so.

[00:05] <masak> because it'd be what people expect.

[00:06] <masak> basically they can use multis without having to understand protos and multis :)

[00:11] *** mdrc joined
[00:12] <mdrc> hello, where to get the sea-cow grammar?

[00:12] <Tene> mdrc: eh?

[00:12] <mdrc> the light variety of perl

[00:13] *** risou left
[00:13] <mdrc> minus lazy classes etc.

[00:13] <Tene> I've never heard of that, and I'm having trouble finding anything about it on google.

[00:14] <mdrc> me to

[00:14] <Tene> can you give me a link?

[00:14] *** Moukeddar joined
[00:14] <mdrc> only by the name. i don't know if the version is publically available

[00:15] <Tene> Where did you hear about this?  Can you tell me more about it?

[00:16] <mdrc> might have been a dream. at least the probability is there

[00:16] <Tene> Probably a dream.  :)

[00:16] <Tene> What was it in your dream, then?  I'm curious now.

[00:16] <mdrc> some stripped version but without the strict parentheses

[00:16] <Tene> Or, could be that you've misremembered the name, and it's a real thing just under a different name.

[00:17] <mdrc> actually i think the bug from perl6 reminded me

[00:17] <mdrc> just visited

[00:18] <masak> we're glad you're here :)

[00:18] <mdrc> thanks :)

[00:19] <masak> I'm almost sorry there isn't a sea-cow grammar outside of your dreams...

[00:19] <mdrc> might have been a grep script

[00:19] <mdrc> i don't know

[00:19] <Tene> mdrc: What would that have been?  For example, if I *had* answered with "Here you go, it's right here: <link>", what would you have expected to find at the link?

[00:20] <mdrc> some variety of the grammar, generated by a stream of feature strings filtered by the sea-cow

[00:23] <mdrc> like a preset compilation

[00:23] <masak> mdrc: I think you came here to be properly hugged.

[00:23] * masak hugs mdrc

[00:24] <masak> there you go.

[00:24] <mdrc> actually thanks , i was looking for an executable object

[00:24] <masak> you're welcome.

[00:25] <masak> in the postmodern era, I guess we're all executable objects.

[00:25] *** Moukeddar left
[00:25] <mdrc> seems to be available, only with whole feature set, from rakudo

[00:25] <masak> yeah.

[00:26] <masak> both.

[00:27] <mdrc> haven't actually seen a list of extern symbols for the standard version. would be nice with something simple.

[00:28] <masak> mdrc: most of it can be found in the spec, but some parts are slushy.

[00:29] <mdrc> the spec seems fine, i mean, how many extern libraries are used?

[00:31] <masak> that's dependent on the implementation, I guess.

[00:31] <masak> there are some implementations for which the question doesn't make much sense.

[00:32] <mdrc> of course. probably just the stdio interface

[00:34] *** xinming_ joined
[00:36] <masak> the question feels unwarrantedly C-centric.

[00:36] *** Sefnajjer joined
[00:36] <mdrc> true. the regular execution environment, you know

[00:36] *** Sefnajjer left
[00:36] *** xinming left
[00:37] *** plobsing left
[00:40] *** plobsing joined
[00:42] *** sftp left
[00:44] *** sftp joined
[00:45] *** sftp left
[00:45] <masak> 'night, #perl6

[00:45] *** masak left
[00:46] *** pjcj left
[00:47] <mdrc> [stdio[rakudo[application]]] alike

[00:51] *** pjcj joined
[01:06] *** tinhead joined
[01:08] *** Bucciarati left
[01:10] *** Bucciarati joined
[01:14] <newbee> sorry i had to go out but i read your response, masak. So, whan can i do to avoid this "double" definition of + ? 

[01:14] <newbee> s/whan/what/

[01:15] <newbee> or is that i just can't use + inside a definition of an overroded + operator?

[01:15] <newbee> oh, never mind

[01:16] <newbee> i got it, i should replace sub by multi :)

[01:16] <newbee> thanks! :D

[01:20] <newbee> rakudo: use v6; class hourmin {  has Int $.h is rw;  has Int $.m is rw; }; multi infix:<+>(hourmin $h1, hourmin $h2) {  my $r = hourmin.new(h=>0,m=>0);  $r.h = $h1.h + $h2.h;  $r.m = $h1.m + $h2.m;  if $r.m > 60 { $r.h += 1; $r.m-=60};  return $r; }; my $H1 = hourmin.new(h=>22,m=>40); my $H2 = hourmin.new(h=>1,m=>21); say $H1.perl; say ($H1+$H2).perl;

[01:20] <p6eval> rakudo 705435: OUTPUT«hourmin.new(h => 22, m => 40)␤hourmin.new(h => 24, m => 1)␤»

[01:24] *** whiteknight left
[01:30] <mdrc> (should work like the missing chip. well, i guess i have to leave. bye)

[01:30] *** mdrc left
[01:38] *** mjreed joined
[01:39] *** mjreed left
[01:56] *** mdrc joined
[01:57] <mdrc> hello again, sorry for confusing the sea-cow script. it was an old model for something completely different http://www.gangsterfreak.com/file:scm.png

[01:58] <mdrc> (just found in the archive)

[02:00] <mdrc> maybe some other time

[02:00] *** mdrc left
[02:00] <Tene> jnthn: really, looks like I want to implement http://ruby-doc.org/core/classes/Module.html as my first HOW

[02:04] *** Moukeddar joined
[02:04] *** Moukeddar left
[02:24] *** jaldhar left
[02:25] *** jaldhar joined
[02:39] *** risou joined
[03:04] *** Chillance left
[03:14] *** jaldhar left
[03:15] *** jaldhar joined
[03:20] *** s1n left
[03:22] *** s1n joined
[03:22] *** hudnix left
[03:23] *** Su-Shee_ joined
[03:26] *** Su-Shee left
[03:31] *** newbee left
[03:34] *** am0c joined
[03:39] *** xinming_ is now known as xinming

[03:46] *** Limbic_Region left
[03:54] *** cotto left
[04:03] *** cotto joined
[04:04] *** cottoo joined
[04:04] *** cottoo left
[04:36] *** ymasory left
[04:37] *** Teedev joined
[04:55] *** Psyche^ joined
[04:55] *** Psyche^ is now known as Patterner

[05:06] *** kaare_ joined
[05:11] *** Patterner left
[05:23] *** Teedev left
[05:47] *** birdwindupbird joined
[05:52] *** imamelia joined
[05:53] <imamelia> Will Perl 6 have any more settings for pack and unpack?

[06:12] *** dolmen joined
[06:24] *** imamelia is now known as imamelia|Sleep

[06:29] *** imamelia|Sleep left
[06:36] *** xinming left
[06:36] *** xinming joined
[06:37] *** kaare_ left
[06:48] *** Psyche^ joined
[06:48] *** Psyche^ is now known as Patterner

[06:53] *** Patterner left
[07:23] *** am0c left
[07:28] *** tylercur1is is now known as tylercurtis

[07:36] *** envi joined
[07:43] *** Mowah joined
[07:44] <tadzik> hello #perl6

[07:48] *** Su-Shee_ is now known as Su-She

[07:48] *** Su-She is now known as Su-Shee

[07:54] *** wamba joined
[07:54] *** agentzh joined
[07:54] *** tomen joined
[07:55] *** tomen left
[08:06] *** anazawa joined
[08:16] *** araujo left
[08:23] *** am0c joined
[08:33] *** justatheory left
[08:50] *** anazawa left
[08:59] *** anazawa joined
[09:06] *** anazawa left
[09:06] *** anazawa_ joined
[09:08] *** awoodland joined
[09:08] <moritz> good morning

[09:21] *** sftp joined
[09:28] *** cotto left
[09:28] *** wamba left
[09:31] *** SHODAN joined
[09:34] *** tinhead left
[09:37] *** agentzh left
[09:41] <tadzik> oh, moritz. I was thinking about the gsoc week #1 today, and I still have no clue about how the tests for Pod classes should look like. How about me writing the tests for the Pod parser itself? They will be needed in a later stage anyway, have no specific date (besides "make sure the test suite covers the whole spec" in the week nth), and will probably reveal some stupid things about the Pod nodes too, 

[09:41] <tadzik> what do you think?

[09:41] <tadzik> For I don't have any good idea for testing the classes themselves, and it's a waste of effort to implement tests for containers just for the sake of writing tests

[09:43] *** llabthgie left
[09:44] *** llabthgie joined
[09:58] *** am0c left
[10:06] *** MayDaniel joined
[10:07] *** araujo joined
[10:07] *** araujo left
[10:07] *** araujo joined
[10:09] *** wamba joined
[10:15] *** risou left
[10:20] <ingy> seen shortcircuit

[10:20] <aloha> shortcircuit was last seen in #perl6 34 days 7 hours ago joining the channel.

[10:25] *** whiteknight joined
[11:02] *** masak joined
[11:02] <masak> greetings, lolhorses.

[11:06] *** Su-Shee left
[11:07] *** Su-Shee joined
[11:18] *** mkramer1 joined
[11:20] *** mkramer left
[11:21] *** mkramer joined
[11:23] *** mkramer1 left
[11:27] *** nymacro joined
[11:37] <jnthn> Is a lolhorse like a seahorse, but laughing more often?

[11:40] *** mkramer left
[11:40] *** mkramer joined
[11:42] <masak> right. a close relative to the sea-cow, in fact.

[11:55] <tadzik> (:

[11:55] <tadzik> I imagine lolhorses as horses, which instead of "nihihihihi" do "ololololol!"

[11:58] <tadzik> masak: could you backlog and tell me what you think about the question I asked moritz?

[12:03] *** donri joined
[12:12] <masak> tadzik: the one about tests?

[12:14] <masak> could it be that the question "what tests should I write?" lacks a bit of context?

[12:15] <masak> after all, you don't write tests just for writing tests. you write tests for making sure the code you're about to write does what you wanted.

[12:15] <tadzik> masak: aye

[12:15] <masak> so... what code do you want to write, and what should it do? :)

[12:16] <tadzik> yes. And a code I am to write is a container. Any test for that is basically testing if the classes and their attributes work

[12:16] <tadzik> the code I'm writing are the classes representing a Pod document, and abstract syntax tree

[12:16] <masak> it could be useful to see if the Pod classes have been populated correctly.

[12:17] <masak> i.e. given this or that Pod input, the Pod nodes come out right.

[12:17] <masak> the way I see it, you have an I/O filter. perfect for testing in all sorts of ways.

[12:18] <masak> the power of testing filters is what ingy exploits in http://search.cpan.org/~ingy/Test-Base-0.60/lib/Test/Base.pm

[12:23] <masak> tadzik: but I'm somewhat evading your question.

[12:23] <masak> tadzik: your problem is that the classes you're about to write are mostly behaviour-less shells, so there's nothing interesting to test.

[12:24] <masak> so, playing Devil's advocate for a while, I ask: why are you writing those classes in the first place? :)

[12:26] <tadzik> so, playing the dumb for a while I answer: because that's what in my proposal, and everyone expects the "write tests" statement after every "write code" :)

[12:27] <masak> :P

[12:28] <tadzik> so, instead of reporting "tests were not needed", I'm planning to report "tests were not needed, but I wrote the spectests instead, they helped too, and they will be needed anyway"

[12:28] <masak> no, I meant, do you expect these classes to be useful in some context, besides testing that their attributes work correctly?

[12:29] <masak> because it's those classes that would be useful. those that use the classes in the context they were intended to.

[12:30] <tadzik> brb, nom

[12:48] <tadzik> okay I'm back there

[12:48] *** hudnix joined
[12:49] *** newbee joined
[12:50] <tadzik> masak: the classes are only useful for representing the actual pod document. If it wasn't for convenience, they could be arrays or hashes. Testing them only makes sense if you compare the pod document to the representation you get from it. At the moment we have no way to transform the pod document into its representation, so the Pod classes are only a bunch of sad pandas in the zoo, which everyone can look

[12:50] <tadzik>  at and nothing more. Now, I could write tests for the fictional parser, so once it's here (or partly here), the tests will slowly start to work

[12:50] <tadzik> so, TDD :)

[12:51] <tadzik> so no tests for Pod classes, but rather tests for what Pod classes will be used for

[12:52] <tadzik> but they won't be testing anything right now, at the moment of deliverance

[12:52] <newbee> rakudo: class test { has $.x = 0 where {(0..9)} }

[12:52] <masak> let's say you decided to test a serializer that used the Pod classes. then the attributes in the Pod classes would *have* to work as intended, and you wouldn't have to write the boring tests.

[12:52] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[12:53] <jnthn> std: class test { has $.x = 0 where {(0..9)} }

[12:53] <p6eval> std 9f27365: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/peTAuzXIHk line 1:␤------> [32mclass test { has $.x = 0 [33m⏏[31mwhere {(0..9)} }[0m␤    expecting any of:␤   bracketed infix␤        infix or meta-infix␤    statement modifier loop␤Parse failed␤FAILED 00:01 117m␤»

[12:53] <jnthn> std: class test { has $.x where {(0..9)} = 0 }

[12:53] <p6eval> std 9f27365: OUTPUT«ok 00:01 116m␤»

[12:53] <tadzik> masak: yes

[12:54] <tadzik> the thing is, at the moment of writing the tests, I have no serializer, so the tests don't show anything

[12:54] <newbee> rakudo: class test { has $.x where {(0..9)} = 0 }

[12:54] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[12:54] <jnthn> newbee: Pretty sure Rakudo doesn't know how to do that yet.

[12:55] <newbee> oh well... i can use subsets in the meantime.

[12:57] <newbee> rakudo: subset Digit of Int where (0..9); class test { has Digit $.x = 0 }

[12:57] <p6eval> rakudo 705435:  ( no output )

[12:57] <masak> newbee: be aware that attributes aren't typechecked in Rakudo at the moment.

[12:57] <masak> rakudo: subset Even of Int where { $_ %% 2 }; class A { has Even $.e }; say A.new(:e(5)).e

[12:57] <p6eval> rakudo 705435: OUTPUT«5␤»

[12:58] <masak> rakudo: subset Even of Int where { $_ %% 2 }; class A { has Even $.e }; say A.new(:e("OH NOES")).e

[12:58] <p6eval> rakudo 705435: OUTPUT«OH NOES␤»

[12:58] <masak> myself, I'm consciously avoiding attribute typing right now, because I know how hard my apps would break when it came online if I used them everwhere :P

[12:59] <newbee> subset Digit of Int where (0..9); class test { has Digit $.x is rw = 0  } 

[12:59] <tadzik> masak: so, did we get to any conclusion?

[12:59] <jnthn> masak: nom will almost certainly have it.

[12:59] <jnthn> masak: You've chosen wisely ;)

[12:59] <newbee> i think that this syntax is too complicated,  should be subset Digit of Int where (0..9); class test { has Digit $.x = 0 is rw  }

[13:00] *** benabik left
[13:00] *** benabik joined
[13:00] *** benabik left
[13:00] <jnthn> newbee: But the 0 isn't rw. The attribute is.

[13:00] <newbee> has Digit $.x is rw = 0   v/s   has Digit $.x = 0 is rw

[13:01] <newbee> ahmmm i see

[13:01] <jnthn> I find "has Digit $.x is rw = 0" clearer, but maybe that's just me. :)

[13:02] <newbee> i read "is rw = 0" like saying "rw is false"

[13:02] <newbee> i know that perl6 does not work like that but reading it fast sounds like that

[13:02] *** MayDaniel left
[13:03] *** noganex_ joined
[13:03] <jnthn> Ah, I see.

[13:05] *** noganex left
[13:05] <masak> tadzik: good question :)

[13:05] *** MayDaniel joined
[13:05] *** anazawa joined
[13:06] <masak> tadzik: don't write tests just for testing's sake. write tests that will help you move forward with implementing functionality.

[13:07] *** anazawa_ left
[13:07] *** fglock joined
[13:09] <fglock> hmm - Perlito bootstrap was taking 5min instead of 1min, I was looking for a bug - it turned out the MacBook Air was overheating, and slowed down

[13:09] <fglock> putting some ice under the computer fixed it

[13:12] <masak> :D

[13:12] <newbee> rakudo: class Point{has $.x is rw = 0; has $.y is rw = 0}; my $p1 = Point.new; say $p1.perl;

[13:12] <p6eval> rakudo 705435: OUTPUT«Point.new(x => 0, y => 0)␤»

[13:13] <newbee> rakudo: class Point{has $.x is rw = 0; has $.y is rw = 0}; my Point $p1; say $p1.perl;

[13:13] <p6eval> rakudo 705435: OUTPUT«Point␤»

[13:13] <newbee> why the different outputs?

[13:13] <masak> newbee: the first is an instance, the second is the type object Point.

[13:14] <newbee> you mean that in the 2nd, $p1 is like a "clone" of the Point class?

[13:15] <newbee> rakudo: class Point{has $.x is rw = 0; has $.y is rw = 0}; my Point $p1; my $p2 = $p1.new; say $p2.perl;

[13:15] <p6eval> rakudo 705435: OUTPUT«Point.new(x => 0, y => 0)␤»

[13:15] *** benabik joined
[13:16] <newbee> rakudo: class Point{has $.x is rw = 0; has $.y is rw = 0}; my Point $p1; $p1.x = 10; my $p2 = $p1.new; say $p2.perl;

[13:16] <p6eval> rakudo 705435: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!x␤  in main program body at line 22:/tmp/EJrgoLi8zG␤»

[13:17] <masak> newbee: not really a "clone", more like a Point object that represents the Point class itself. an uninstantiated Point object.

[13:17] *** Chillance joined
[13:17] <newbee> now i understand that error message :)

[13:17] <masak> :)

[13:17] <newbee> thanks to all again :) going back to code some more.....

[13:18] <masak> rakudo: class A { has $.b }; my $a = A.clone; $a.b = 42; say "alive"

[13:18] <p6eval> rakudo 705435: OUTPUT«Type objects are abstract and have no attributes, but you tried to access $!b␤  in main program body at line 22:/tmp/SlbryIPzhK␤»

[13:18] <masak> rakudo: class A { has $.b }; say A === A.clone

[13:18] <p6eval> rakudo 705435: OUTPUT«Bool::True␤»

[13:20] <newbee> mmm so, how does Int work then? You don't have to say my $x = Int.new 

[13:21] <masak> you could say that Int is a bit special-cased, since the literal syntax creates Int instances for you.

[13:21] <masak> but it's slightly more involved than that, what with unboxed values and so on.

[13:24] <newbee> rakudo: class Point{has $.x is rw = 0; has $.y is rw = 0}; class Line { has Point $p1 is rw = (x=>0, y=>0); has Point $p2 is rw = (x=>0, y=>0) }; my $L = Line.new; say $L.perl;

[13:24] <p6eval> rakudo 705435: OUTPUT«Line.new(p1 => ("x" => 0, "y" => 0), p2 => ("x" => 0, "y" => 0))␤»

[13:24] <newbee> rakudo: class Point{has $.x is rw = 0; has $.y is rw = 0}; class Line { has Point $p1 is rw = (x=>0, y=>0); has Point $p2 is rw = (x=>10, y=>10) }; my $L = Line.new; say $L.perl;

[13:24] <p6eval> rakudo 705435: OUTPUT«Line.new(p1 => ("x" => 0, "y" => 0), p2 => ("x" => 10, "y" => 10))␤»

[13:24] <newbee> cool :)

[13:27] *** MayDaniel left
[13:29] <mikemol> ingy: I'm around

[13:29] <mikemol> I just don't speak much. :)

[13:34] *** p6eval left
[13:34] <newbee> rakudo: class hourmin {has Int $.h is rw; has Int $.m is rw;}; multi infix:<+>(hourmin $h1, hourmin $h2) {my $r=hourmin.new(h=>0,m=>0); $r.h=$h1.h+$h2.h; $r.m=$h1.m+$h2.m; if $r.m>60 {$r.h+=1; $r.m-=60}; return $r;};    my $H1=hourmin.new(h=>22,m=>40); my $H2=hourmin.new(h=>1,m=>21); my $H3=$H1+$H2;

[13:35] *** p6eval joined
[13:35] *** ChanServ sets mode: +v p6eval

[13:35] <newbee> rakudo: class hourmin {has Int $.h is rw; has Int $.m is rw;}; multi infix:<+>(hourmin $h1, hourmin $h2) {my $r=hourmin.new(h=>0,m=>0); $r.h=$h1.h+$h2.h; $r.m=$h1.m+$h2.m; if $r.m>60 {$r.h+=1; $r.m-=60}; return $r;};    my $H1=hourmin.new(h=>22,m=>40); my $H2=hourmin.new(h=>1,m=>21); my $H3=$H1+$H2;

[13:36] *** wamba left
[13:36] <p6eval> rakudo 705435:  ( no output )

[13:36] *** birdwindupbird left
[13:36] *** newbee left
[13:39] <tadzik> masak: I read that as "I agree" :)

[13:40] <tadzik> fglock: speaking of MacBook, how annoying is the heat problem in a machine like that?

[13:40] <ingy> mikemol: you changed nicks?

[13:41] <masak> tadzik: yes, I think I do. :)

[13:41] *** newbee joined
[13:41] <newbee> hi again :D

[13:41] <masak> welcome back. :)

[13:41] <newbee> i have a + operator defined inside a pm (inside a class)

[13:41] <mikemol> ingy: Ah. Yeah, I forgot about that. :)

[13:42] <newbee> i did a test and i can't use the operator in it

[13:42] <mikemol> ingy: Now using my real name for my nick, since that's what I do just about everywhere else, now.

[13:42] <ingy> mikemol: join #ingy again for a bit

[13:42] <masak> newbee: sub declarations are lexically scoped. so it'll only be visibble inside the class if you define it there.

[13:42] <newbee> i can only use it if i move the + definition from the .pm to the .t file 

[13:42] <newbee> i defined as a multi

[13:42] <newbee> ahh i see

[13:43] <newbee> so i should use "method infix:....."

[13:43] <masak> no.

[13:43] <masak> you should place the sub declaration where it's visible from where you use it.

[13:44] <masak> rakudo: class A {}; multi sub infix:<+>(A, A) { "OH HAI" }; say A.new + A.new

[13:44] <p6eval> rakudo 705435: OUTPUT«OH HAI␤»

[13:44] <masak> rakudo: class A { multi sub infix:<+>(A, A) { "OH HAI" } }; say A.new + A.new

[13:44] <p6eval> rakudo 705435: OUTPUT«Cannot take numeric value for object of type A␤  in 'Any::Numeric' at line 1482:CORE.setting␤  in 'infix:<+>' at line 7651:CORE.setting␤  in main program body at line 22:/tmp/umUksggfP_␤»

[13:45] <newbee> that's the error message i'm getting

[13:47] *** imamelia|Sleep joined
[13:50] <benabik> Wouldn't an infix method take one of the params as an invocant?  So it would be infix:<+>(A) or (A: A)?

[13:52] *** noganex joined
[13:53] *** imamelia|Sleep is now known as imamelia

[13:54] *** Moukeddar joined
[13:54] <Moukeddar> Hello :)

[13:54] <masak> o/

[13:54] <Moukeddar> how are you doing Sir?

[13:55] <masak> good, thanks.

[13:55] <masak> and you?

[13:55] *** noganex_ left
[13:55] <Moukeddar> doing Fine , thank you

[13:55] <masak> benabik: it would; but the operator isn't translated into a method call, it's translated into a sub call.

[13:55] <masak> rakudo: class A { method infix:<+>(A, A) { "OH HAI" } }; say A.new + A.new

[13:56] <p6eval> rakudo 705435: OUTPUT«Cannot take numeric value for object of type A␤  in 'Any::Numeric' at line 1482:CORE.setting␤  in 'infix:<+>' at line 7651:CORE.setting␤  in main program body at line 22:/tmp/8iMgcjd1G7␤»

[13:56] <masak> (doesn't work, because the method is never called)

[13:56] <Moukeddar> rakudo : What?

[13:56] <Moukeddar> rakudo: What?

[13:56] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤Confused at line 22, near "What?"␤»

[13:57] <Moukeddar> masak, i wanted your opinion ,

[13:57] <Moukeddar> me and my friends are about to build a website

[13:57] <Moukeddar> kinda like this : http://dotnet.dzone.com/

[13:57] *** whiteknight left
[13:58] <Moukeddar> and we were agueing wether we should Use the MVC architectur or not

[13:58] <Moukeddar> what do you think ?

[13:58] *** wamba joined
[13:58] <masak> Moukeddar: I think it sounds slightly off-topic for #perl6. mind if we take it through privmsg?

[13:59] <Moukeddar> ok :)

[14:07] *** fglock left
[14:16] *** dual left
[14:18] *** am0c joined
[14:21] *** Moukeddar left
[14:30] <dalek> rakudo/nom: 4128e6a | jnthn++ | / (4 files):

[14:30] <dalek> rakudo/nom: Toss some PMCs that we'll no longer need.

[14:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4128e6a5a0

[14:30] <dalek> rakudo/nom: 7e411b3 | jnthn++ | src/Perl6/Metamodel/EXPORTHOW.pm:

[14:30] <dalek> rakudo/nom: Correct HOW exports.

[14:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7e411b34a8

[14:46] <dalek> rakudo/nom: b659333 | jnthn++ | / (3 files):

[14:46] <dalek> rakudo/nom: Add lexpad and lexinfo PMCs. Copies of the NQP ones, but I expect we'll end up with a bit more in the Rakudo ones.

[14:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b659333b3b

[14:46] <dalek> rakudo/nom: 6664726 | jnthn++ | src/Perl6/SymbolTable.pm:

[14:46] <dalek> rakudo/nom: Make sure we always do the LexPad => Perl6LexPad mapping.

[14:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6664726037

[14:46] <dalek> rakudo/nom: 7ab4a55 | jnthn++ | src/pmc/perl6lexinfo.pmc:

[14:46] <dalek> rakudo/nom: Simplify static lexical installation.

[14:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7ab4a5509b

[14:46] <dalek> rakudo/nom: 3eb5ba0 | jnthn++ | src/Perl6/SymbolTable.pm:

[14:46] <dalek> rakudo/nom: Compile-time lexical installation.

[14:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3eb5ba05f0

[14:50] *** [Coke] left
[14:53] *** molaf joined
[14:55] *** nymacro left
[15:02] *** kaare_ joined
[15:03] *** [Coke] joined
[15:08] *** p6eval left
[15:09] *** p6eval joined
[15:09] *** ChanServ sets mode: +v p6eval

[15:09] <newbee> rakudo: use v6; class Point { has $.x is rw = 0; has $.y is rw = 0; }; multi sub infix:<+>(Point $P1, Point $P2) {my $R = Point.new; $R.x = $P1.x + $P2.x; $R.y = $P1.x + $P2.x; return $R;} use v6; use Test; my $P1=Point.new(x=>5 ,y=>5); my $P2=Point.new(x=>10,y=>10); my $P3=$P1+$P2; ok($P3.x==15 && $P3.y==15, "Add points");

[15:09] *** [1]imamelia joined
[15:10] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤Confused at line 22, near "multi sub "␤»

[15:11] *** imamelia left
[15:11] *** [1]imamelia is now known as imamelia

[15:14] <sorear> newbee: what are you trying to do?  you seem to have been stuck on the same stuff for a week.

[15:15] <sorear> newbee: "use v6" is unnecessary with Rakudo, also, there's a bug which requires operator overloads to be declared "our multi sub"

[15:15] <sorear> newbee: you need a ; after the sub-ending }

[15:18] <dalek> rakudo/nom: b56c1b3 | jnthn++ | src/Perl6/SymbolTable.pm:

[15:18] <dalek> rakudo/nom: Add a way to track stub packages that we need to check get defined at some point.

[15:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b56c1b3353

[15:18] <dalek> rakudo/nom: 097725c | jnthn++ | src/Perl6/Grammar.pm:

[15:18] <dalek> rakudo/nom: Install lexical packages.

[15:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/097725c795

[15:18] <dalek> rakudo/nom: 630af7d | jnthn++ | src/Perl6/Actions.pm:

[15:18] <dalek> rakudo/nom: Toss existing package_def action and start to fill it out with compile time meta-object handling and other basic bits.

[15:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/630af7d65f

[15:18] <dalek> rakudo/nom: ea005f4 | jnthn++ | src/Perl6/Actions.pm:

[15:18] <dalek> rakudo/nom: Typo.

[15:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ea005f45aa

[15:19] *** hatsefla1s is now known as hatseflats

[15:22] *** s1n left
[15:22] *** s1n joined
[15:40] *** birdwindupbird joined
[15:42] <masak> rakudo: multi sub infix:<+>(Rat $a, Rat $b) { "OH HAI" }; say 2.5 + 2.5

[15:42] <p6eval> rakudo 705435: OUTPUT«Ambiguous dispatch to multi 'infix:<+>'. Ambiguous candidates had signatures:␤:(Rat $a, Rat $b)␤:(Rat $a, Rat $b)␤␤  in main program body at line 22:/tmp/Wok6SJmL1Y␤»

[15:43] <masak> sorear: no, it seems to work without the 'our'.

[15:43] <masak> rakudo: multi sub infix:<+>(Str $a, Str $b) { $a ~ $b }; say "OH" + " " + "HAI"

[15:43] <p6eval> rakudo 705435: OUTPUT«OH HAI␤»

[15:43] <masak> sorear: it's just some other things that don't work without it, such as metaoperators.

[15:44] <masak> rakudo: multi sub infix:<+>(Str $a, Str $b) { $a ~ $b }; say [+] "OH", " ", "HAI"

[15:44] <p6eval> rakudo 705435: OUTPUT«0␤»

[15:44] <masak> rakudo: our multi sub infix:<+>(Str $a, Str $b) { $a ~ $b }; say [+] "OH", " ", "HAI"

[15:44] <p6eval> rakudo 705435: OUTPUT«OH HAI␤»

[15:45] *** PhatEddy joined
[15:47] <PhatEddy> rakudo: class A { has $.b;}; class B is A { proto method b{}};

[15:47] <p6eval> rakudo 705435:  ( no output )

[15:48] <PhatEddy> rakudo: class A { has $.b; proto method b{}};

[15:48] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[15:49] <PhatEddy> masak: do you have a moment to chat about rt #76298 ?

[15:53] *** dual joined
[15:53] *** justatheory joined
[15:54] <moritz> tadzik: I'd be fine with you writing tests for combined parser + pod classes first, and spend some effort on getting the first test pass early

[15:54] <moritz> even if that's a small deviation from the schedule

[15:55] <tadzik> good

[15:55] <tadzik> moritz: it's nothing wrong if I modify the classes designed in the week #1 later on, while implementing stuff?

[15:55] <tadzik> I think I already asked that

[15:56] <moritz> tadzik: setting things in stone early on is considered harmful

[15:57] <tadzik> yeah. The spec is not frozen either

[15:58] <moritz> exactly

[15:58] <moritz> or to put it another way, working code in the end is more important than particular milestones or than sticking to early results

[15:59] <newbee> sorry, i was afk..

[16:00] <newbee> rakudo: class Point { has $.x is rw = 0; has $.y is rw = 0; }; our multi sub infix:<+>(Point $P1, Point $P2) {my $R = Point.new; $R.x=$P1.x+$P2.x; $R.y =$P1.y+$P2.y; return $R;}; my $p1 = Point.new(x=>30,y=>0); my $p2=$p1; ;my $P3=$p2 + $p1;  say $P3.perl;

[16:00] <p6eval> rakudo 705435: OUTPUT«Point.new(x => 60, y => 0)␤»

[16:00] <newbee> this works well... but

[16:00] <newbee> if i kame two files like that:

[16:00] <newbee> s/kame/name/

[16:00] <newbee> file Point.pm : class Point { has $.x is rw = 0; has $.y is rw = 0; }; our multi sub infix:<+>(Point $P1, Point $P2) {my $R = Point.new; $R.x=$P1.x+$P2.x; $R.y =$P1.y+$P2.y; return $R;};   

[16:00] <newbee> file Test.pl  : use Point; my $p1 = Point.new(x=>30,y=>0); my $p2=$p1; ;my $P3=$p2 + $p1; say $P3.perl;

[16:01] <newbee> i got this error: "Cannot take numeric value for object of type Point"

[16:01] *** cotto joined
[16:02] <moritz> newbee: you didn't export your infix:<+>

[16:03] <moritz> newbee: and even if you did, I think exporting of overloaded operators in very fragile in rakudo :(

[16:03] *** Alias joined
[16:04] <newbee> export? mmmm like an EXPORT array at the beggining of Point.pm ?

[16:05] <moritz> multi infix:<+>(...) is export { ... }

[16:06] <newbee> didn't work either,, i guess i'll stick to "normal" subs for the moment :(

[16:06] <newbee> thanks moritz :)

[16:07] <masak> PhatEddy: yes, sure.

[16:08] <PhatEddy> rakudo: class A { has $.b; method b{}};

[16:08] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤A method named 'b' already exists in class 'A'. It may have been supplied by a role.␤»

[16:08] <newbee> sorear: I'm trying to do a "TimeOfDay" class. Hours minutes and seconds, completely unrelated to the day.

[16:08] <masak> PhatEddy: that's wrong too, AFAIU.

[16:09] <masak> rakudo: class TimeOfDay { has $.hour; has $.minute; has $.second }; say "done"

[16:09] <jnthn> maybe.

[16:09] <p6eval> rakudo 705435: OUTPUT«done␤»

[16:09] <PhatEddy> It doesn't just seem to be about proto's and if you back up a bit on the channel you might notice that I have a workaround based on inheritance.

[16:09] * masak backs up a bit

[16:10] <newbee> i want to add Durations and other "TimeOfDay" instances, that's why i olverload operators

[16:10] <PhatEddy> rakudo: class A { has $.b;}; class B is A { method b{}};

[16:10] <p6eval> rakudo 705435:  ( no output )

[16:10] <masak> jnthn: shouldn't 'has $.b' only generate an accessor method if there isn't already one in the class declaration?

[16:11] <jnthn> masak: Probably, yes

[16:11] *** am0c left
[16:11] <masak> I even seem to recall reading that in some synopsis somewhere.

[16:11] <jnthn> Though you could use has $!b; then :)

[16:11] <masak> :)

[16:12] <jnthn> That'd seem like the simple workaround if you want to write your own accessor.

[16:12] <masak> aye.

[16:12] <jnthn> Will try and remember to add that check when implementing the attribute meta-object in nom, anyway.

[16:12] <masak> \o/

[16:14] *** imamelia left
[16:15] <tadzik> why is #= currently Rakudo-illegal?

[16:16] <jnthn> tadzik: I thought it was no longer in the spec?

[16:16] <masak> tadzik: it's #=[]

[16:16] <masak> or some other set of parenthetical characters.

[16:17] <PhatEddy> Is there really a point in allowing the override of the accessor if declaring private and your own accessor is just as good?

[16:17] <tadzik> it's in the S26

[16:17] <jnthn> Oh, I thought we were taking about {*} #= open in a regex.

[16:17] <jnthn> Mostly because I tossed one of the few remaining usages of it a couple of days ago in package_def... :)

[16:18] <tadzik> :)

[16:18] <jnthn> PhatEddy: Things that want to see has_accessor being true when doing introspection would benefit from it.

[16:18] <tadzik> so, what about #=?

[16:18] *** colomon left
[16:19] *** Alias left
[16:19] <PhatEddy> Thanks everyone ...

[16:20] <masak> tadzik: I'll look into it.

[16:24] *** am0c joined
[16:24] *** leprevost joined
[16:24] <masak> tadzik: oh, you're right.

[16:25] <masak> tadzik: by the way, I have a pending addition to S26 concerning exactly this feature.

[16:25] <tadzik> changing #= to #=[]?

[16:25] *** MayDaniel joined
[16:25] <masak> no.

[16:26] <dalek> rakudo/nom: 4aab825 | jnthn++ | NOMMAP.markdown:

[16:26] <dalek> rakudo/nom: Update NOMMAP.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4aab825a5e

[16:26] <dalek> rakudo/nom: f2dd8a5 | jnthn++ | src/Perl6/Metamodel/ (4 files):

[16:26] <dalek> rakudo/nom: A bit more fleshing stuff out in the metamodel.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f2dd8a5a69

[16:26] <dalek> rakudo/nom: eacc9e9 | jnthn++ | src/Perl6/ (2 files):

[16:26] <dalek> rakudo/nom: {YOU_ARE_HERE} handling fixes.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eacc9e9457

[16:26] <dalek> rakudo/nom: ddeadfd | jnthn++ | src/CORE.setting/BOOTSTRAP.pm:

[16:26] <dalek> rakudo/nom: Simplify BOOTSTRAP.pm so it's something we can at least produce code for now.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ddeadfd281

[16:26] <dalek> rakudo/nom: 31a098b | jnthn++ | src/Perl6/ (2 files):

[16:26] <dalek> rakudo/nom: Check for undefined package stubs. Compiling CORE.setting now complains (correctly) about these.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/31a098b434

[16:26] <dalek> rakudo/nom: 7767bf4 | jnthn++ | / (3 files):

[16:26] <dalek> rakudo/nom: Stub in natives.

[16:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7767bf4e25

[16:26] <masak> tadzik: I believe both exist already.

[16:28] <masak> tadzik: no, the change is to replace the magical attachment behavior of #= with two constructs: #= and #^

[16:29] *** mberends joined
[16:31] *** newbee left
[16:31] <masak> tadzik: please read this: http://irclog.perlgeek.de/perl6/2010-06-18#i_2453615

[16:32] <masak> tadzik: up until 14:28 or so.

[16:32] <tadzik> oh, I think I remember sorear talking about this

[16:32] <masak> hm, seems the two alternatives we settled on were #= and #|

[16:33] *** Moukeddar joined
[16:33] <Moukeddar> Heyoo

[16:34] <Moukeddar> why the compiler is called rakudo?

[16:34] <Moukeddar> japanses?

[16:35] <Moukeddar> japanese*

[16:36] <PhatEddy> Quick though on paperwork - does it make sense to add a reference to the discussion here to rt76298 - fine with me to do it ...

[16:37] <tadzik> I see

[16:44] <masak> Moukeddar: the name 'rakudo' is derived from the Japanese phrase 'rakudado', meaning 'the way of the camel'.

[16:44] <masak> Moukeddar: 'rakudo' itself means 'paradise'.

[16:47] *** r0b86 joined
[16:47] *** Moukeddar left
[16:49] *** Su-Shee_ joined
[16:52] *** Su-Shee left
[16:52] *** Su-Shee_ is now known as Su-Shee

[16:54] *** leprevost left
[16:59] <masak> ok, I tried changing S26 into #| and #=

[17:00] *** wamba left
[17:00] <masak> it's not as trivial as just putting them there, because much of the explanation that's there now is spent clarifying the silly system of attaching doc comments to the right declaration.

[17:01] <masak> a slightly bigger rewrite is needed.

[17:02] <tadzik> (:

[17:02] <tadzik> well, my second mentor...

[17:02] <tadzik> I can do it if you're not in a hurry

[17:03] <masak> hey, thanks! :)

[17:03] <tadzik> (:

[17:03] <tadzik> but I suppose that's not until July :P

[17:04] <tadzik> for .WHY is quite far on my list

[17:04] <tadzik> and there's plenty of things not so far

[17:04] *** mj41 joined
[17:11] * moritz returns and backlogs

[17:12] <jnthn> std: sub foo is bar$('wtf') { }

[17:12] <p6eval> std 9f27365: OUTPUT«ok 00:01 113m␤»

[17:20] <sorear> phenny: tell Moukeddar http://mail.pm.org/pipermail/chicago-talk/2008-January/004726.html

[17:20] <phenny> sorear: I'll pass that on when Moukeddar is around.

[17:23] *** Limbic_Region joined
[17:28] <masak> tadzik: ok, I might beat you to it, but no promises either way :)

[17:29] <tadzik> :)

[17:36] <jnthn> TimToady: Since we need to evaluate trait parameters at parse/compile time, is there any reason at all to just parse some generic circumfix that could contain just about anything for the parameter? Can we not somehow parse a far more restrictive set of things?

[17:36] *** ymasory joined
[17:36] *** [Coke] left
[17:36] <jnthn> Like, literal values and type names... :)

[17:37] <moritz> why not just wrap an implicit BEGIN block around it, and allow arbitrary expressions?

[17:37] <jnthn> meh

[17:37] <jnthn> could do

[17:37] <moritz> ok, wouldn't make your life easier :-)

[17:37] *** [Coke] joined
[17:38] <jnthn> Well, it'll make everyone's life slower too

[17:39] <jnthn> And it's not so simple because of circularity issues

[17:40] <jnthn> It'd probably "work" though, I guess.

[17:41] * jnthn starts to realize that the whole thing is ridiculously circular.

[17:43] <jnthn> You can't define inheritance hierarchy until you can call a trait, which needs multi-dispatch. But you can't do multi-dispatch until you have an inheritance hierarchy in place. :)

[17:44] <moritz> so, time for our circularity chainsaw, which can define inheritance without traits

[17:44] <jnthn> Yeah

[17:45] <jnthn> I think I'm just going to make Mu/Any etc initially exist and be related by doing a bunch of manual meta-object calls.

[17:51] *** envi left
[17:57] *** am0c left
[18:00] <PhatEddy> Synopsis 12 says: Every dot declaration also declares a corresponding private exclamation storage location, and the exclamation form may be used only in the actual class, not in derived classes.

[18:00] <PhatEddy> rakudo: class A { has $.b;}; class B is A { method set_p_b{ $!b = 'x'}; method say_p_b{say $!b}}; my $b = B.new; $b.set_p_b; $b.say_p_b;

[18:00] <p6eval> rakudo 705435: OUTPUT«x␤»

[18:00] <PhatEddy> Is the sample I just ran a (new?) bug?

[18:01] <jnthn> It's not a new bug, it's one of the oldest ones in rT.

[18:02] <PhatEddy> Sorry - I did check rt and missed it.

[18:02] <jnthn> nqp: class A { has $.b; }; class B is A { method set_p_b() { $!b := 'x' } }

[18:02] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3863 (src/Regex/Cursor.pir:239)␤»

[18:02] <moritz> rt is not easy to search for

[18:03] <jnthn> nqp: class A { has $!b; }; class B is A { method set_p_b() { $!b := 'x' } }

[18:03] <p6eval> nqp: OUTPUT«Attribute '$!b' not declared at line 1, near " := 'x' } "␤current instr.: 'nqp;HLL;Grammar;panic' pc 26292 (src/stage2/gen/NQPHLL.pir:7011)␤»

[18:03] <jnthn> That's how it should work.

[18:04] <sorear> jnthn: You're only just realizing the circularity? :)

[18:05] <jnthn> sorear: Just having to deal with different bits of it. :)

[18:06] <jnthn> sorear: When your compilation model is Perl 6 in ==> PIR out, it's kinda easier. ;)

[18:06] <jnthn> When it's Perl 6 in ==(build the world)==> PIR out that uses objects built during compilation, there's some new things to worry about. :)

[18:07] <sorear> niecza solves that problem by building the world in compilerspace

[18:07] <sorear> though this is likely to become a problem when I implement trait_mod

[18:07] <jnthn> Yes.

[18:08] <sorear> How do you plan to handle separate compilation + BEGIN interaction in ctmo?

[18:08] <jnthn> And all the BEGIN fun in general, I guess.

[18:08] *** mj41 left
[18:09] <jnthn> The only thing a BEGIN block can reach is either symbols in the dynamic scope or symbols in the current understanding of GLOBAL

[18:09] <sorear> that's the #1 blocker for BEGIN in Niecza; I can't afford to lose separate compilation when it takes 20 seconds just to build a setting 1/6 the size of Rakudo's

[18:09] <jnthn> (Note, not using Parrot namespaces any more, so not tied to any single view of what is GLOBAL).

[18:09] <jnthn> I had to fix that so NQP could actually keep on bootstrapping itself and I could statically resolve symbols

[18:10] <jnthn> Was getting into situations where it was linking symbols against the compiler, not the the ones beloning to the thing being compiled. Then you ran the compiled output and it was like "oh noes, where are my symbols" :)

[18:11] <jnthn> That took days to untangle. :/

[18:11] <sorear> What would you do for something like use A; my $x; BEGIN { $x = $A::y; $x.[0] = 42 } ?

[18:12] <jnthn> If you do that by just compile-n-run it'd probably end up OK, but you're hosed if you do that with --target=pir and then expect $A::y to show up differently when running that.

[18:13] <jnthn> It's no different to BEGIN { $A::y.[0] = 42 }

[18:15] <jnthn> Potentially you'd screw up the whole separate compilation thing too, but only within the current process.

[18:15] *** MayDaniel left
[18:16] <jnthn> Dunno what we can really do about that, short of a load of extra copying, which'll cause other issues.

[18:16] <jnthn> Or trying to track object changes or something

[18:16] <jnthn> But...it's silly.

[18:16] <jnthn> Can only go so far to stop people shooting themselves in the foot.

[18:17] <jnthn> And BEGIN kinda is a shotgun. :)

[18:18] *** Moukeddar joined
[18:18] * sorear has vague desires of being able to run Niecza on Rakudo/Yapsi someday

[18:19] <sorear> heh, I guess

[18:19] <sorear> Have you figured out how to do away with the sc field yet?  Adding an extra pointer to P6any just for separate compilation+BEGIN does not amuse me

[18:20] <jnthn> Well, it's for bounded serialization too

[18:21] <jnthn> I didn't work out how to do away with it but I'm not really planning to either.

[18:21] <sorear> Bounded serialization "too"?

[18:22] <jnthn> heh. That was the primary motivation. :)

[18:23] <jnthn> For now I'm getting most of the stuff in line to actually do some kind of "real serialization"

[18:23] *** imamelia joined
[18:23] <jnthn> But I'll probably go on with the current stop-gap until after rakudo/nom.

[18:24] <jnthn> Want to give folks at least some of the new nice stuffs. :)

[18:24] <jnthn> dinner, bbl 

[18:27] <sorear> What is "the current stop-gap"?

[18:27] <sorear> What is "real serialization"

[18:29] *** Moukeddar left
[18:30] *** toto joined
[18:30] *** toto is now known as Guest6918

[18:32] *** Mowah_ joined
[18:33] *** wamba joined
[18:36] *** Guest6918 left
[18:37] *** birdwindupbird left
[18:40] *** mj41 joined
[18:43] *** benabik left
[18:53] <masak> rakudo: say "OH HAI @a<"

[18:53] <p6eval> rakudo 705435: OUTPUT«OH HAI @a<␤»

[18:53] <masak> rakudo: say "OH HAI @a["

[18:53] <p6eval> rakudo 705435: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 22␤»

[18:53] <sorear> hi masak!

[18:53] <masak> why is < OK but not [ ?

[18:53] <masak> oh hai sorear

[18:53] <sorear> std: say "OH HAI @a<"

[18:53] <p6eval> std 9f27365: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse quote-words subscript; couldn't find right angle quote at /tmp/SFvtOOnNLU line 1:␤------> [32msay "OH HAI @a<[33m⏏[31m"[0m␤    expecting escape␤Parse failed␤FAILED 00:01 114m␤»

[18:54] * masak submits rakudobug

[18:59] *** lichtkind joined
[19:03] * masak already found a use for .base in real-world code

[19:03] <masak> though in this case .fmt('%b') wouldn't worked too ;)

[19:04] <imamelia> Will pack() get changed at all in Perl 6?

[19:05] <masak> imamelia: yes, a little bit.

[19:05] <masak> imamelia: mostly because we now have Str and Buf, not just Str.

[19:05] <masak> imamelia: but all the changes I've seen have been about that.

[19:06] <imamelia> Hm.

[19:06] <imamelia> I don't recall hearing about any new developments for that, but...

[19:06] <masak> I started on it last summer during GSoC.

[19:06] <imamelia> The fact that it has no option for 24-bit character strings has come up a couple of times.

[19:06] *** benabik joined
[19:07] <masak> hm, back up a bit. :)

[19:07] <masak> what has no option for 24-bit character strings?

[19:07] <imamelia> The pack and unpack functions.

[19:07] <imamelia> n and v are 16-bit, N and V are 32-bit...but there's nothing for 24-bit.

[19:07] <masak> huh.

[19:08] <imamelia> And using C* or the like forces big-endian mode.

[19:08] <masak> this is the first time I've heard that complaint about pack and unpack.

[19:08] <imamelia> Huh.

[19:08] <sorear> me too

[19:08] <masak> have you discussed this with the Perl 5 people?

[19:08] <imamelia> What Perl 5 people?

[19:08] <imamelia> I've mentioned in on #perl, and at least one other person knows about it...

[19:09] <imamelia> Currently, I've just been using the 32-bit one and adding or removing a leading \x00, but that seems rather...workaround-ish?

[19:10] <imamelia> (Nothing bigger than 32-bit either, but that hasn't come up yet anyway.)

[19:10] <imamelia> *mentioned it

[19:12] <imamelia> But would it be useful enough to have in Perl 6, I guess...

[19:13] <imamelia> Maybe a special character sequence for any character length in either big- or little-endian mode? That would be the most flexible option.

[19:13] <imamelia> Might be useful for more people.

[19:14] <masak> noted.

[19:16] <masak> given a list of zeroes and ones, how do I get a list of the indices with ones?

[19:17] *** Moukeddar joined
[19:18] <masak> this is the shortest I can come up with:

[19:18] <masak> rakudo: my @a = 0, 1, 1, 0, 1, 0, 1; say (map *.key, grep *.value == 1, @a.pairs).perl

[19:18] <p6eval> rakudo 705435: OUTPUT«(1, 2, 4, 6)␤»

[19:18] <masak> oh wait.

[19:18] <masak> rakudo: my @a = 0, 1, 1, 0, 1, 0, 1; say (grep *.value == 1, @a.pairs)>>.key.perl

[19:18] <p6eval> rakudo 705435: OUTPUT«(1, 2, 4, 6)␤»

[19:19] <sorear> ; my @a = 0,1,1,0,1,0,1; say @a.pairs>>.invert.hash.[1]

[19:19] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs>>.invert.hash.[1]

[19:19] <p6eval> rakudo 705435:  ( no output )

[19:19] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs>>.invert.perl

[19:19] <p6eval> rakudo 705435: OUTPUT«(0 => 0, 1 => 1, 1 => 2, 0 => 3, 1 => 4, 0 => 5, 1 => 6)␤»

[19:20] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs>>.invert.hash.perl

[19:20] <p6eval> rakudo 705435: OUTPUT«{"0" => 5, "1" => 6}␤»

[19:20] <masak> sorear: one has to push the values onto a hash.

[19:20] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs.hash.invert.perl

[19:20] <masak> I make that mistake a lot.

[19:20] <p6eval> rakudo 705435: OUTPUT«(0 => "0", 1 => "1", 1 => "2", 0 => "3", 1 => "4", 0 => "5", 1 => "6")␤»

[19:20] <masak> rakudo: my @a = 0,1,1,0,1,0,1; say {}.push(@a.pairs.invert)

[19:21] <p6eval> rakudo 705435: OUTPUT«Method 'invert' not found for invocant of class 'List'␤  in main program body at line 22:/tmp/iaew_5UI9N␤»

[19:21] <masak> rakudo: my @a = 0,1,1,0,1,0,1; say {}.push(@a.pairs.hash.invert).perl

[19:21] <p6eval> rakudo 705435: OUTPUT«{"0" => ["0", "3", "5"], "1" => ["1", "2", "4", "6"]}␤»

[19:21] <masak> rakudo: my @a = 0,1,1,0,1,0,1; say {}.push(@a.pairs.hash.invert)[1].perl

[19:21] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs.classify(*.value).[1]

[19:21] <masak> sorear++

[19:21] <p6eval> rakudo 705435: OUTPUT«undef␤»

[19:21] <p6eval> rakudo 705435: OUTPUT«1 1       1 2     1 4     1 6     1␤»

[19:21] <masak> rakudo: my @a = 0,1,1,0,1,0,1; say {}.push(@a.pairs.hash.invert)<1>.perl

[19:21] <p6eval> rakudo 705435: OUTPUT«["1", "2", "4", "6"]␤»

[19:21] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs.classify(*.value).[1].perl

[19:21] <p6eval> rakudo 705435: OUTPUT«"1" => [1 => 1, 2 => 1, 4 => 1, 6 => 1]␤»

[19:21] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs.classify(*.value)<1>.perl

[19:22] <p6eval> rakudo 705435: OUTPUT«undef␤»

[19:22] <benabik> p6golf

[19:22] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs.classify(*.value).hash<1>.perl

[19:22] <p6eval> rakudo 705435: OUTPUT«[1 => 1, 2 => 1, 4 => 1, 6 => 1]␤»

[19:23] <sorear> rakudo: my @a = 0,1,1,0,1,0,1; say @a.pairs.grep(*.value)».key.perl

[19:23] <p6eval> rakudo 705435: OUTPUT«(1, 2, 4, 6)␤»

[19:23] *** Moukeddar left
[19:27] <masak> rakudo: my $n = 5; for 0 ..^ 2 ** $n -> $bitmask { my @r = ({}.push($bitmask.fmt('%0' ~ $n ~ 'b').flip.comb.pairs.hash.invert)<1> // []).list; say @r }

[19:28] <p6eval> rakudo 705435: OUTPUT«␤0␤1␤01␤2␤02␤12␤012␤3␤03␤13␤013␤23␤023␤123␤0123␤4␤04␤14␤014␤24␤024␤124␤0124␤34␤034␤134␤0134␤234␤0234␤1234␤01234␤»

[19:28] <masak> all possible subsets of the set {0, 1, 2, 3, 4, 5}.

[19:32] *** whiteknight joined
[19:35] <sorear> niecza: .say for &[X~](('', '0'), ('', '1'), ('', '2'), ('', '3'), ('', '4'), ('', '5'))

[19:35] <p6eval> niecza v5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Non-simple variables NYI at /tmp/gSm0pmwb8O line 1:␤------> [32m.say for &[X~][33m⏏[31m(('', '0'), ('', '1'), ('', '2'), ('', '[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 413 (CORE die @ 2)␤  at

[19:35] <p6eval> ../ho…

[19:36] <sorear> niecza: .say for ('', '0') X~ ('', '1') X~ ('', '2') X~ ('', '3') X~ ('', '4') X~ ('', '5')

[19:36] <p6eval> niecza v5: OUTPUT«␤5␤4␤45␤3␤35␤34␤345␤2␤25␤24␤245␤23␤235␤234␤2345␤1␤15␤14␤145␤13␤135␤134␤1345␤12␤125␤124␤1245␤123␤1235␤1234␤12345␤0␤05␤04␤045␤03␤035␤034␤0345␤02␤025␤024␤0245␤023␤0235␤0234␤02345␤01␤015␤014␤0145␤013␤0135␤0134␤01345␤012␤0125␤0124␤01245␤0123␤01235␤01234␤012345␤»

[19:36] <masak> :)

[19:36] <sorear> this would work even better if I had a working ||

[19:40] <sorear> needs more lols

[19:40] <jnthn> sorear: Real as in data driven. Current stop-gap is "all compile time meta-object actions are events, and the "serialization" is running through that event stream.

[19:45] * tadzik wonders if 12 pages is enough for S26

[19:45] <tadzik> any ideas how many lines does lp(1) print on one page?

[19:45] <TimToady> usually about 60 (out of 66)

[19:46] <TimToady> on an old fashioned line printer

[19:46] <sorear> people still use lp?

[19:46] <TimToady> on a modern printer, depends on the font size

[19:47] <sorear> I guess it's like how in high school I did all my English-class submissions using troff

[19:47] *** birdwindupbird joined
[19:47] *** mj41 left
[19:48] <tadzik> I quite like the archaism in the act of printing a text file in the command line. I only need a pipe and a...

[19:48] <tadzik> phenny: "melonik"?

[19:48] <phenny> tadzik: Language guessing failed, so try suggesting one!

[19:48] <tadzik> phenny: pl "melonik"?

[19:48] <phenny> tadzik: "bowler" (pl to en, translate.google.com)

[19:48] <flussence> rakudo: my @a = 0,1,1,0,1,0,1; say (0..@a Z=> @a).classify(*.value).pop.value.hash.keys.perl # I couldn't make it shorter, but I can make it horrible no problem :)

[19:48] <p6eval> rakudo 705435: OUTPUT«("1", "2", "4", "6")␤»

[19:49] <TimToady> ^@a would work just as well

[19:49] <sorear> tadzik: hat?

[19:49] <TimToady> @a.pairs

[19:49] <tadzik> sorear: yes

[19:49] <tadzik> bleh, OOWriter wants to print me this on 108 pages

[19:51] <sorear> tadzik: have you tried using pod2man and groff -Tps ?

[19:51] <tadzik> sorear: I don't think pod2man will help with pod6

[19:52] <tadzik> I guess I'll just visit a xero point

[19:56] <sorear> jnthn: What do you mean when you say that (the purpose of SerializationContext is not BEGIN)?

[19:58] *** SHODAN left
[19:58] <jnthn> sorear: Well, depends if you mean "stuff that happens at begin time" or just BEGIN explicitly. If you mean "stuff that happens at BEGIN time" then yes, that's primarily what it's for.

[20:03] *** zer0o joined
[20:05] <lue> hello world! o/

[20:05] <masak> \o

[20:06] <tadzik> hello lue1

[20:06] <tadzik> 1

[20:06] <tadzik> damn this, shift

[20:06] <moritz> \o

[20:06] <tadzik> hello lue!

[20:06] <masak> tadzik: it's slightly ironic that you're now performing a step (printing Pod6) that would benefit by your GSoC work ;)

[20:06] <masak> s/by/from/

[20:06] <tadzik> masak: yeah, that's this bootstraping problem :)

[20:07] <tadzik> I see the pod 6 source, but I have no idea how it should really look about :)

[20:10] <sorear> jnthn: I mean BEGIN specifically

[20:10] <masak> tadzik: :)

[20:10] <sorear> jnthn: stuff that happens at BEGIN time can be serialized with non-bounded and otherwise ad-hoc methods.  Niecza uses JSON to serialize class meta objects

[20:11] <masak> tadzik: Damian proudly asserts that S26 is written in Pod6. in his CPAN module, he bitterly laments that the documentation has to be written in plain ol' POD. :)

[20:11] <tadzik> masak: yeah, I saw that :)

[20:11] <masak> he names it "cruel irony" or something like that...

[20:11] <tadzik> "The Cruel Irony", or something

[20:11] <tadzik> hehe :)

[20:11] <sorear> jnthn: BEGIN itself seems to want to be bounded though, if we want BEGIN { $x = Num } to work well

[20:11] <benabik> I thought BEGIN was "start of program" not "compile time"

[20:11] <sorear> benabik: you're thinking of INIT

[20:12] <sorear> excuse me - BEGIN { $x = Num }; ok $x === Num

[20:12] * lue gets the idea he should continue work on SUPERNOVA, when he has time.

[20:12] <masak> I've come to think of BEGIN as "as early as possible", which often means at compile time.

[20:13] <moritz> it should really be called ASAP

[20:14] *** kaare_ left
[20:14] <lue> tadzik: ooc, what is your GSoC project?

[20:14] <tadzik> lue: we may be able to combine manpower regarding my GSoC project

[20:14] <sorear> hmm, it just occurred to me that rakudo-ng = event sourcing, rakudo-nom = data sourcing

[20:14] * sorear blows the masak-whistle

[20:14] <tadzik> tee-hee. The Pod parser for Rakudo :)

[20:15] * tadzik wonders whose whistle makes the "beeeer!" sound

[20:15] <lue> do you even have to ask? It's jnthn's of course :)

[20:18] <masak> sorear: :)

[20:18] <benabik> sorear: Ah.  I thought BEGIN was INIT and COMPILE was BEGIN.  BEGIN seems like an odd name for it, but I'll get used to it.  :-)

[20:18] <masak> sorear: I think "state sourcing" is a more apt term.

[20:18] <moritz> benabik: hysteric raisins, and all that

[20:19] <benabik> moritz: ...  ?

[20:19] *** bluescreen10 left
[20:19] <masak> well, as early as possible might as well be called BEGIN :)

[20:19] *** bluescreen10 joined
[20:19] * benabik didn't get anywhere near enough sleep.

[20:20] <moritz> benabik: "historic reasons", a bit misspelled

[20:20] <masak> benabik: see http://www.jargondb.org/soundalike_slang

[20:20] <benabik> moritz: Oh!  My grandma says "hysterical buildings" all the time...  I'm too tired.

[20:20] *** imamelia left
[20:23] *** Mowah left
[20:24] <lue> I feel your GSoC project is Pod6 related... /me investigates further

[20:25] <tadzik> lue: 2214          tadzik | tee-hee. The Pod parser for Rakudo :)

[20:26] <tadzik> lue: http://www.google-melange.com/gsoc/proposal/review/google/gsoc2011/tadzik/1

[20:32] <moritz> std: 'a' =~ /a/

[20:32] <p6eval> std 9f27365: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at /tmp/vQylQfDv5v line 1:␤------> [32m'a' =~[33m⏏[31m /a/[0m␤Parse failed␤FAILED 00:01 113m␤»

[20:32] <sorear> std: my $x; $x=~1;

[20:32] <p6eval> std 9f27365: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at /tmp/cksxAqn4XX line 1:␤------> [32mmy $x; $x=~[33m⏏[31m1;[0m␤Parse failed␤FAILED 00:01 114m␤»

[20:35] *** imamelia joined
[20:35] <lue> tadzik: looks cool, esp. considering there are some things about Pod6 I'll be purposely delaying (e.g. #=<> declarator blocks) or not doing without decent arguments (e.g. all the Pod6:: classes S26 implies are necessary.)

[20:37] <dalek> specs: 15b1a49 | moritz++ | S32-setting-library/Exception.pod:

[20:37] <dalek> specs: [S32/Exceptions] add a few syntax errors

[20:37] <dalek> specs: review: https://github.com/perl6/specs/commit/15b1a49e67

[20:37] <sorear> Normally I see people make commits like "Remove a few syntax errors"/

[20:37] <sorear> .

[20:38] <sorear> masak: Why is event sourcing a good thing for web apps but bad for Perl 6?

[20:38] <moritz> what's a nice way to supply the default error message programmatically?

[20:39] <sorear> moritz: What do you mean by default error message?

[20:39] <moritz> if I do a "has $.message = 'default string';", I'll get a conflict with X::Base

[20:40] <moritz> sorear: X::Syntax::Obsolete.message should default to 'Unsupported use of $<old>;$<when> please use $<new>'

[20:40] <tylercurtis> BUILD?

[20:40] <moritz> BUILD is an idea, yes

[20:40] <tadzik> lue: my project does not aim for a complete Pod 6 implementation

[20:40] <sorear> I think you want to override new() for this

[20:41] <moritz> why new and not a BUILD?

[20:41] <masak> sorear: huh? I didn't say it was.

[20:41] <sorear> masak: YOU didn't, JNTHN does

[20:41] <masak> oh!

[20:42] <masak> that's funny, only yesterday jnthn described the things he's doing with serialization as event-based.

[20:42] <lue> ah. So it only does as much as it needs to be useful as a part of Rakudo?

[20:42] <sorear> What Rakudo does now is event-based

[20:43] <jnthn> sorear: Not really...

[20:43] <jnthn> sorear: Not in a formal way.

[20:43] <masak> I'm afraid I don't know enough about the Rakudo internals to have an opinion...

[20:43] <jnthn> sorear: nom is still event-driven but with a bunch of cross-referencing already worked out.

[20:43] <jnthn> It's half way to being data-driven.

[20:44] <jnthn> Becasue going all the way is another hard chunk of work that I don't want to take on just yet. :)

[20:44] <tadzik> lue: it aims to be a base on which it will be more like a LHF than a hellofahardwork to implement something Pod-related. Also the most exciting bit is of course the .WHY :)

[20:44] <moritz> WHY? :-)

[20:46] <lue> .oO(say .WHEREFORE # 'art thou Romeo?')

[20:46] <tadzik> I feel that we have an alias .BECAUSE :)

[20:47] <tadzik> oh that will be something reversed

[20:47] <tadzik> it could add the explanations in runtime :)

[20:47] *** bluescreen10 left
[20:48] <lue> That reminds me of a why/because conditional I've thought about (e.g.    why {$x += $y; say $z;} because $q = 5) which would just be a reverse if/then.

[20:48] <tadzik> augment class Tea { has $.more.BECAUSE('I can') }

[20:48] *** Mowah_ left
[20:49] *** bluescreen10 joined
[20:50] *** birdwindupbird left
[20:54] <moritz> event sourcing might a good idea for a time-traveling debugger

[20:57] <masak> that's basically what Tardis does.

[20:57] <masak> oh wait. no, it isn't.

[20:57] <masak> :)

[20:57] <masak> so yes, that would be a good place to apply it. :)

[20:59] <lue> .oO(IIUC event sourcing from what I've just looked up, then Tardis would actually use event editing)

[21:00] *** bluescreen100 joined
[21:00] *** donri left
[21:03] <masak> lue: events are append-only.

[21:04] <masak> but I guess with a time-traveling debugger, one could choose to "restart" from some point in the event stream, discarding all the events after that point as belonging to a false future.

[21:05] *** imamelia is now known as imamelia|Away

[21:05] *** imamelia|Away left
[21:11] <masak> 'night, #perl6

[21:11] *** masak left
[21:13] *** p6eval left
[21:15] *** p6eval joined
[21:15] *** ChanServ sets mode: +v p6eval

[21:31] *** Su-Shee_ joined
[21:34] *** Su-Shee left
[21:37] *** cotto left
[21:38] *** cotto joined
[21:41] *** gottreu joined
[21:43] <PhatEddy> rakudo: my @a = (1);  @a ||= (); say @a

[21:43] <p6eval> rakudo 705435:  ( no output )

[21:44] <PhatEddy> rakudo: my @a = (1);  @a ||= (); say ~@a

[21:44] <p6eval> rakudo 705435: OUTPUT«(timeout)»

[21:45] *** bluescreen__ joined
[21:47] <PhatEddy> if anyone is around to second and no objection maybe a bug report?

[21:49] *** zer0o left
[21:52] <PhatEddy> rakudo: my @a = (); say @a.perl;  @a ||= (); say @a.perl

[21:52] <p6eval> rakudo 705435: OUTPUT«[]␤[()]␤»

[21:56] <tadzik> rakudo: my @a = (1);  @a ||= (); say @a.perl

[21:56] <p6eval> rakudo 705435: OUTPUT«maximum recursion depth exceeded␤  in 'Block::count' at line 6342:CORE.setting␤  in 'Block::count' at line 6342:CORE.setting␤  in 'Any::join' at line 1␤  in 'Array::perl' at line 3161:CORE.setting␤  in <anon> at line 3161:CORE.setting␤  in 'Any::join' at line 1␤  in

[21:56] <p6eval> ..'Array::perl' a…

[22:02] *** silent_h_ joined
[22:07] *** gottreu left
[22:20] *** arnsholt left
[22:20] *** arnsholt joined
[22:22] *** dju joined
[22:24] *** dju left
[22:25] *** dju joined
[22:26] *** risou joined
[22:27] *** anazawa left
[22:32] *** dolmen left
[22:43] *** risou_ joined
[22:44] *** risou left
[22:45] *** Moukeddar joined
[22:52] *** Sefnajjer joined
[22:52] *** Sefnajjer left
[22:54] *** colomon joined
[22:57] *** benabik left
[22:59] *** Moukeddar left
[23:20] <dalek> rakudo/nom: fc60b90 | jnthn++ | src/Perl6/ (2 files):

[23:20] <dalek> rakudo/nom: Rip out existing traits handling, as it needs to be done very differently. Get natives to parse/compile.

[23:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fc60b9058d

[23:20] <dalek> rakudo/nom: a8702a4 | jnthn++ | / (2 files):

[23:20] <dalek> rakudo/nom: Start sketching out circularity-sawing object system bootstrap.

[23:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a8702a4893

[23:20] <dalek> rakudo/nom: b2fea87 | jnthn++ | src/Perl6/Metamodel/MultipleInheritance.pm:

[23:20] <dalek> rakudo/nom: Fix inheritance bug.

[23:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b2fea874ef

[23:20] <dalek> rakudo/nom: e020635 | jnthn++ | / (6 files):

[23:20] <dalek> rakudo/nom: Start fleshing out the setting a bit. Doesn't build - getting it to do so is the next target.

[23:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e0206358c5

[23:20] *** wamba left
[23:25] <jnthn> sleep &

[23:26] *** lichtkind left
[23:28] *** PhatEddy left
[23:29] *** fridim_ left
[23:32] *** silent_h_ left
[23:32] *** benabik joined
[23:34] *** molaf_ joined
[23:37] *** molaf left
[23:39] *** spinclad left
[23:44] *** risou_ left
[23:49] *** spinclad joined
