[00:03] *** ethndbst joined
[00:03] *** ethndbst left
[00:03] *** ethndbst joined
[00:10] *** colomon_Droid left
[00:10] <dalek> niecza: 193ca57 | sorear++ | lib/ (3 files):

[00:10] <dalek> niecza: [Threads.pm6] Fix build; exception-safe &lock

[00:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/193ca57c4e

[00:10] *** Radvendii joined
[00:11] <sorear> I'd be interested in hearing how this works on a real multiprocessor system

[00:12] *** ethndbst left
[00:15] <Radvendii> what's the deal with panda, does it install on rakudo now?

[00:16] *** xinming left
[00:16] *** Trashlord left
[00:18] <japhb> jnthn, ping

[00:19] <sorear> Radvendii: by "rakudo" do you mean Rakudo Star, Beijing, the most recent monthly monthly, or the HEAD

[00:19] <sorear> ?

[00:19] <Radvendii> i don't believe i have rakudo star

[00:19] <Radvendii> does it work better with that?

[00:20] <sorear> actually I think Rakudo Star includes it

[00:20] <Radvendii> ag

[00:20] <Radvendii> ah*

[00:20] <sorear> the thing is that Star is a few months old

[00:20] <Radvendii> good to know

[00:20] <jnthn> Rakudo Star distributions include panda and various modules

[00:20] <japhb> phenny, ask jnthn Can &fail from src/core/Failure.pm be written more simply (with less Q:PIR and pir::) in current nom without losing too much performance?

[00:20] <phenny> japhb: I'll pass that on when jnthn is around.

[00:20] <sorear> there have recently been major compatibility-disrupting refactors in Rakudo, and the ecosystem hasn't fully caught up

[00:21] <Radvendii> i'll check that out, thanks

[00:21] <sorear> until things are more stabilized we recommend outside users stay with the 'Beijing' monthly release, or the most recent Star which is based on Beijinng

[00:22] <japhb> jnthn, you have a curious habit of appearing just about the time I've assumed you went to sleep and finished asking phenny to forward to you.  And then I see in the backlog you speaking just before my message to phenny appears.  ;-)

[00:22] *** xinming joined
[00:22] <jnthn> Current Rakudo master can handle Panda *but* the bootstrap is busted because one (or two) of the modules that Panda depends on fail tests.

[00:22] <phenny> jnthn: 00:20Z <japhb> ask jnthn Can &fail from src/core/Failure.pm be written more simply (with less Q:PIR and pir::) in current nom without losing too much performance?

[00:23] <sorear> jnthn: pff, I thought we already killed master off

[00:23] <jnthn> sorear: gah

[00:23] <jnthn> s/master/nom/

[00:23] <jnthn> sorry, in the middle of $bughunt...and it's late :)

[00:24] <Timbus> sorear

[00:24] <Timbus> Timbus: I'm not sure if niecza's Threads.pm6 supports nonconsentual termination of threads.  That kind of feature is quite out of favor in modern libs like the CLR :|

[00:24] <jnthn> japhb: Will look in a moment

[00:24] <Timbus> uh, i meant, can the threads end themselves

[00:24] <sorear> Yes

[00:24] <japhb> jnthn, thank you

[00:24] <Timbus> in p5 they kill gtk of they end.

[00:24] <Timbus> if they end*

[00:29] <sorear> Timbus: ah.

[00:30] <sorear> Timbus: I just got done adding multithreading to colomon's gtk mandelbrot, seems to work fine although I've only one processor so I'm not hitting the data races as hard as they could be hit

[00:32] <jnthn> japhb: hmm. It may be possible with an actual try { die $value; CATCH { default { $ex = $! } } }

[00:32] <jnthn> japhb: Though at the cost of efficiency and not sure if it'll accidentally introduce frames.

[00:35] <Timbus> you can avoid data races in gtk by setting your return data in a var and then, after all that, spawning a g_add_idle in the main thread to collect the data and use it

[00:36] *** araujo left
[00:36] <japhb> jnthn, hmmm.  OK, thanks.  I wanted to make a variant of &fail for reporting Str -> other type conversion parsefails, that would report extra information, like position of problem in source string.  I was hoping not to have to duplicate all that code again.  Makes my DRY muscle itch.  :-/

[00:37] *** Mowah_ left
[00:37] <Timbus> a less optimal way could be to spawn the idle at the same time you make the thread, if its impossible to get glib to add an idle from your second thread.. but thatll waste a lot of cycles and you need a semaphore to signal when data is ready

[00:38] <jnthn> japhb: YOu can't just call fail directory?

[00:38] <jnthn> *directly

[00:38] <jnthn> japhb: Or you don't want to return at that point?

[00:40] <sorear> Timbus: looks like I'm using g_timeout_add(0, ...)

[00:40] <sorear> via Application.Invoke() from gtk#

[00:41] <japhb> jnthn, it was a factoring issue.  I could do 'sub parse_fail ($msg) { fail $msg ~ $other_useful_info }' then later 'return parse_fail $msg;' ... or I could do 'sub with_extra_info ($msg) { return $msg ~ $other-useful-info }' then later 'fail extra_info $msg' ... but I wanted to just do 'parse_fail $msg'.

[00:41] <Timbus> that's the one

[00:42] <japhb> * fail with_extra_info $msg

[00:42] <Timbus> i don't have a reference and I gave up on remembering library function names after memorizing half of MSDN

[00:43] <japhb> jnthn, in any case, I was hoping &parse_fail could be short and sweet.

[00:44] <japhb> (I should note that because of the layered parsing of numbers, &parse_fail could be called from several different levels of the call stack, but I only wanted to define it once, so I needed the RETURN finding magic of &fail.

[00:45] <jnthn> japhb: Hmm, would doing

[00:45] <jnthn> my &parse_fail := -> $info { fail $info ~ $other_info }

[00:45] <jnthn> help?

[00:45] <jnthn> japhb: That fail will fail the lexically enclosing routine.

[00:46] *** colomon joined
[00:47] <japhb> jnthn, I don't think so, because I have three different lexical levels inside Str.Numeric, and I want the Failure fail up *one* level when it happens.  And I was planning to define &parse_fail only once, at the topmost level, so it could be seen at all levels.

[00:47] <Radvendii> is that the new syntax for anonymous subroutine references? -> $args {}  ?

[00:48] <japhb> Radvendii, it is one type of anon code; in particular it is a type that does not capture RETURN control flow.

[00:48] <jnthn> Radvendii: Well, an anonymous subroutine is still sub ($args) { ... }

[00:48] <japhb> so a return within it returns from the *enclosing* routine.

[00:49] <jnthn> Radvendii: The -> $args {} is a lambda/closure that takes parameters. It has different return behavior, as japhb pointed out

[00:49] <Radvendii> what is the difference in when you would use the two?

[00:49] *** cognominal_ joined
[00:50] <colomon> Radvendii: the classic place to use -> $args is a for statement

[00:50] <Radvendii> right. i've seen that.

[00:50] <colomon> nom: for 1..3 -> $x { say $x * $x; }

[00:50] <p6eval> nom 80669d: OUTPUT«1␤4␤9␤»

[00:50] <japhb> Radvendii, you find '-> { }' most often used in a for loop.  The use that jnthn put it too is advanced usage, in my mind.

[00:50] <Radvendii> okay

[00:50] <Radvendii> that makes sense

[00:50] <japhb> (very useful to know about, mind you, just not something you'll do every day)

[00:51] <Radvendii> could you also use a normal subroutine in a for loop?

[00:51] <sorear> o/ colomon

[00:51] <Radvendii> like for 1..3 sub (…){…}

[00:51] <sorear> Radvendii: no, you can't; the syntax requires either { or -> to terminate the expression

[00:51] <colomon> nom: my $c = .5 + .5i; my @mandelbrot := 0, -> $z { $z * $z + $c } ... *; say @mandelbrot[^5].perl

[00:51] <p6eval> nom 80669d: OUTPUT«(0, Complex.new(0.5, 0.5), Complex.new(0.5, 1), Complex.new(-0.25, 1.5), Complex.new(-1.6875, -0.25))␤»

[00:52] <colomon> sorear, o/  # finally solidly logged in again

[00:52] <Radvendii> okay.

[00:52] *** wolfman2000 left
[00:52] *** araujo joined
[00:52] <sorear> colomon: I'd like you to check out my last commit, you absolutely need niecza HEAD

[00:52] *** cognominal left
[00:52] * colomon is settled in at his in-laws with pretzels, hard cider, the big ten championship, and his macbook pro

[00:53] <sorear> well, it sounds like you have other priorities.

[00:53] *** xinming left
[00:53] <colomon> no, this is good

[00:54] <colomon> hacking, drinking, and football.  Doesn't get any better!  (unless music is involved)

[00:55] <sorear> one thing that would make a cool smallish task would be to display the uncalculated part of the fractal as something other than black

[00:55] *** xinming joined
[00:56] <Timbus> hmmmm.. does padre have a split view

[00:57] <Timbus> cant seem to find it. probably not

[00:57] <Timbus> :<

[00:58] <colomon> sorear: huh.  Just seem to have gotten a black window?

[00:58] <jnthn> Mmmmm. Beer aged in oak rum casks. 

[00:59] *** Radvendii left
[01:00] *** xinming left
[01:00] <colomon> sorear: definitely does not appear to be working correctly here.

[01:06] <colomon> hmmm... I can zoom... into more black

[01:07] <Timbus> but does the void stare back

[01:08] <colomon> always it does

[01:09] <colomon> sorear: doesn't look like it ever actually calls "row"

[01:09] <Timbus> is this in a separate repo or

[01:09] <dalek> rakudo/nom: df73d45 | jnthn++ | src/Perl6/Metamodel/ (3 files):

[01:09] <dalek> rakudo/nom: Fix type checking with parametric roles instantiated with type variables that are later reified.

[01:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/df73d45c92

[01:09] <dalek> rakudo/nom: 4c8bc09 | jnthn++ | src/Perl6/Actions.pm:

[01:09] <dalek> rakudo/nom: Allow things like 'Int %h' in signatures.

[01:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4c8bc09212

[01:09] <dalek> rakudo/nom: 6825f44 | jnthn++ | src/core/Hash.pm:

[01:09] <dalek> rakudo/nom: Add stuff to Hash to support typed hashes. Just leaves my Int %h syntax to be wired up.

[01:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6825f44532

[01:09] <Timbus> i built niecza yesterday.. apparently (i was very drunk)

[01:10] <colomon> jnthn++

[01:10] <colomon> Timbus: is what in a separate repo?

[01:10] <Timbus> the gtk stuff

[01:10] <jnthn> Will fix the other bits tomorrow...

[01:11] <jnthn> The wiring up of "my T %h" gets a bit subtle...especially in the case T is a type var or something.

[01:12] <colomon> Timbus: nope, niecza just does Gtk (assuming you have the libraries available with your Mono)

[01:12] *** xinming joined
[01:13] <jnthn> rest &

[01:18] <colomon> sorear: oh, you call start-work only in resize

[01:18] <colomon> I can fix that.

[01:19] <colomon> huh

[01:20] <colomon> I don't get the impression this is particularly fast?

[01:20] <colomon> I definitely like having it draw as it goes

[01:21] *** xinming left
[01:22] *** PacoLinux joined
[01:22] *** xinming joined
[01:27] <sorear> aha.  oops.

[01:27] <colomon> sorear: okay, I've got a patch so it starts to draw when the window is first created.

[01:28] <sorear> colomon: go for it

[01:28] <colomon> but it's still significantly slower than the unthreaded version was, at least on my machine

[01:29] <sorear> oh?  interesting

[01:29] <colomon> yeah, might be as much as four times slower

[01:30] <sorear> there's definitely room for optimizing in ExposeEvent (only drawing the actual dirty rows from the clip region, and pulling the locking out of the inner loop

[01:30] <sorear> )

[01:30] <sorear> what happens with THREADS=1?

[01:30] <colomon> pushed my bug fix.

[01:30] <colomon> was just going to check that

[01:31] <colomon> vastly faster

[01:31] *** xinming left
[01:32] <colomon> I'd say it's still about running in about 125% of the time the non-threaded version did.

[01:32] <colomon> let me try 2...

[01:33] <colomon> 2 is noticeably slower than 1

[01:37] *** tadzik left
[01:38] <Timbus> why such a slowdown?

[01:39] <colomon> Timbus: I'm guessing sorear and I are both looking at it.

[01:39] *** Radvendii joined
[01:40] <colomon> it looks like the drawing loop in our ExposeEvent gets called over and over again -- I don't understand how.  But My guess is that accounts for all the difference when THREADS=1

[01:40] *** xinming joined
[01:40] <Timbus> so its not supposed to be?

[01:40] *** donri left
[01:41] <Timbus> hrm :/

[01:42] <colomon> well, somehow that's how sorear got it to display each line of the fractal as it is calculated.

[01:42] <colomon> but based on my earlier timing tests, that many Gtk calls in a row probably hurts performance

[01:43] <Timbus> can i get a link to the repo

[01:43] <colomon> https://github.com/colomon/mandelbrot

[01:43] <Timbus> thanks

[01:44] *** tadzik joined
[01:44] *** toebu joined
[01:45] *** zby_home___ left
[01:50] <colomon> oh, hey, wonder if operating on battery power is messing up my threading?

[01:50] *** scottp_ joined
[01:52] *** mls_ joined
[01:52] <colomon> nope

[01:52] <colomon> (Or at least, plugging in doesn't seem to help.)

[01:53] *** spacebat_ joined
[01:53] <Timbus> so the real difference here is that the threaded model swars line by line, and the old one drew only once, since it drew after calculating the whole image

[01:53] <Timbus> meaning it froze the UI on redraw

[01:53] *** Util_ joined
[01:53] <Timbus> draws*

[01:54] *** szbalint_ joined
[01:55] *** shachaf_ joined
[01:55] <colomon> Timbus: the threaded model does the line-by-line draw loop repeatedly until the entire image is drawn.  If you add "say $y" to the ExposeEvent loop, you can see it counting repeatedly from 0 to $windowHeight until the fractal is completely drawn

[01:55] *** sorear_ joined
[01:55] *** zamolxes_ joined
[01:55] <Timbus> yep

[01:56] <colomon> like I said, I don't know why that happens

[01:56] *** takesako_ joined
[01:57] <Timbus> well, that's so you can make a progressive image, which is a good example of threading kinda. but it'd be a lot slower

[01:57] *** fsergot left
[01:57] <Timbus> oh dear

[01:58] <Timbus> yeah. you should be using threads so that the UI just remains responsive, allows for a 'stop' button, etc. just don't draw the image until its fully rendered by the thread imo. don't bother with lines

[01:58] <Timbus> its not really for speed anyway

[02:08] *** xinming left
[02:09] *** fridim_ left
[02:09] *** xinming joined
[02:14] *** xinming left
[02:16] *** xinming joined
[02:21] *** xinming left
[02:26] *** xinming joined
[02:26] *** orafu left
[02:27] *** orafu joined
[02:28] <colomon> hmmm, QueueDrawArea?

[02:31] *** overrosy joined
[02:37] *** xinming left
[02:38] *** overrosy left
[02:39] *** jimmy1980 left
[02:39] *** xinming joined
[02:41] <colomon> so that's what causes ExposeEvent to be called so much.

[02:45] *** overrosy joined
[02:45] *** jimmy1980 joined
[02:50] *** xinming left
[02:51] *** xinming joined
[02:55] *** xinming left
[02:56] *** tokuhirom joined
[02:57] *** toebu left
[02:58] *** xinming joined
[03:03] <Radvendii> is there a round() function in the core? i know there are floor() and ceil() but is there a round()?

[03:04] <colomon> yes

[03:05] <colomon> truncate too

[03:05] <colomon> noml

[03:05] <colomon> nom: say 23.542323.round

[03:05] <p6eval> nom 6825f4: OUTPUT«(timeout)»

[03:05] <colomon> ummm....

[03:05] <colomon> b: say 23.542323.round

[03:05] <p6eval> b 1b7dd1: OUTPUT«24␤»

[03:06] <colomon> that seems like a rather surprising nom bug

[03:06] <Radvendii> perl6: say round(23.54)

[03:06] <p6eval> rakudo 6825f4: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&round' called (line 1)␤»

[03:06] <p6eval> ..pugs b927740, niecza v12-3-g193ca57: OUTPUT«24␤»

[03:06] <Radvendii> yeah…

[03:06] <Radvendii> not in rakudo apparently… what's b:?

[03:06] <colomon> nom: say 23.542323.floor

[03:06] <p6eval> nom 6825f4: OUTPUT«23␤»

[03:06] <colomon> b is the last major version of rakudo (pre-nom)

[03:07] <Radvendii> b: say 23.54.round

[03:07] <p6eval> b 1b7dd1: OUTPUT«24␤»

[03:07] <Radvendii> b: say round 23.54

[03:07] <p6eval> b 1b7dd1: OUTPUT«24␤»

[03:07] <Radvendii> that's odd…

[03:07] *** xinming left
[03:07] <Radvendii> why doesn't it work with perl6: or with my perl6 implimentation?

[03:08] <Radvendii> i just downloaded rakudo star…

[03:08] <colomon> rakudo star *is* b

[03:08] <colomon> at least, to a very close approximation

[03:08] <Radvendii> ooooh

[03:09] <colomon> > say round 23.54

[03:09] <colomon> 24

[03:09] <colomon> that's what I get from rakudo star

[03:09] <Radvendii> never mind. i think i didnt finish the installation process. because make install doesnt install it in /usr/bin/

[03:09] <Radvendii> does anyone know how to make it?

[03:09] <colomon> ah, right

[03:09] <Radvendii> i didnt find anything in Configure.pl --help

[03:09] <colomon> make it install it in /usr/bin?  There isn't a way

[03:09] <Radvendii> so i just have to move it manually?

[03:10] <colomon> I just made a symbolic link

[03:10] <Radvendii> wha?

[03:10] <Radvendii> how do i do taht?

[03:10] <colomon> cd /usr/bin

[03:10] <colomon> sudo ln -s /your/path/to/perl6 

[03:11] <colomon> (or su if you cannot sudo)

[03:11] <Radvendii> then i can just use perl6 from the command line?

[03:11] <colomon> yes

[03:12] <colomon> (only if you have done make install, otherwise you cannot call it from outside your rakudo directory)

[03:12] <Radvendii> i have

[03:14] <colomon> nom: say 23.542323.round

[03:14] <p6eval> nom 6825f4: OUTPUT«(timeout)»

[03:14] *** xinming joined
[03:14] <colomon> nom: say round 23.54

[03:14] <p6eval> nom 6825f4: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&round' called (line 1)␤»

[03:15] <colomon> bug reported

[03:15] <colomon> Radvendii++

[03:16] <Radvendii> what?

[03:18] *** Jeffrey__ joined
[03:19] *** Jeffrey__ left
[03:19] <colomon> I gave you karma, because your curiosity about round turned up a bug.

[03:20] <Radvendii> okay..?

[03:20] <Radvendii> in anycase, now im getting a strange error:

[03:20] <Radvendii> PARROT VM: Could not initialize new interpreter PackFile_Header_validate: This Parrot cannot read bytecode files with version 11.0.

[03:22] *** cognominal_ left
[03:22] <colomon> hmmm... now that I cannot explain.

[03:22] <colomon> might you have another version of parrot installed on the machine?

[03:22] *** xinming left
[03:22] <Radvendii> it's quite possible

[03:22] <Radvendii> probably even, i installed rakudo several times

[03:23] <Radvendii> could i move all the files to the /usr/ directory?

[03:24] <Radvendii> if it's more convenient. . .

[03:24] *** cognominal joined
[03:25] <colomon> I don't know what happens if you do that.  Sorry.

[03:28] *** jimmy1980 left
[03:30] *** quietfanatic_ joined
[03:31] <quietfanatic_> niecza: run

[03:31] <p6eval> niecza v12-3-g193ca57: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'run' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 880 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1139 (P6.comp_unit @ 32) ␤  at /home/p…

[03:31] <quietfanatic_> Is there a workaround for run in niecza?

[03:34] *** wolfman2000 joined
[03:36] *** quietfanatic_ left
[03:38] *** quietfanatic joined
[03:38] *** xinming joined
[03:39] <colomon> phenny: tell quietfanatic_ http://stackoverflow.com/questions/878632/best-way-to-call-external-program-in-c-sharp-and-parse-output

[03:39] <phenny> colomon: I'll pass that on when quietfanatic_ is around.

[03:39] <quietfanatic> oh, so

[03:40] <colomon> I haven't tried that, but I think it should work pretty easily

[03:40] <quietfanatic> are those classes accessible in p6 then?

[03:40] <quietfanatic> or do I have to do the equivalent of Q:PIR?

[03:41] <colomon> you can do it like we've been doing Gtk.

[03:41] <colomon> give me a sec, I'll code up an example for you.

[03:41] <quietfanatic> thanks

[03:44] <colomon> hmmm, seems Glib.Process is different from the one described in that post

[03:47] <colomon> well, bother, it's not proving to be as easy as I had hoped

[03:48] *** quietfanatic_ joined
[03:48] <quietfanatic_> Sorry about the dropping in and out.

[03:48] <phenny> quietfanatic_: 03:39Z <colomon> tell quietfanatic_ http://stackoverflow.com/questions/878632/best-way-to-call-external-program-in-c-sharp-and-parse-output

[03:49] *** quietfanatic left
[03:49] <colomon> no worries

[03:49] <quietfanatic_> My college wifi is a little less than reliable.

[03:50] <quietfanatic_> If it's too much trouble, I guess I could try switching to the optimized Rakudo.

[03:55] <colomon> It *should* be easy.  :\

[03:55] *** xinming left
[03:56] <quietfanatic_> so one would think.

[03:58] <colomon> one sec

[03:59] <colomon> *frown*

[04:02] *** xinming joined
[04:02] <colomon> bloody hell, capitalization issues

[04:02] <quietfanatic_> oh, hah

[04:03] <colomon> what platform are you running on?

[04:03] <quietfanatic_> Linux

[04:03] <quietfanatic_> Arch

[04:03] <colomon> okay, this code may be mono-specific

[04:03] <colomon> https://gist.github.com/1429114

[04:03] <quietfanatic_> okay, I'll try that.

[04:03] <quietfanatic_> thanks

[04:06] <quietfanatic_> Unhandled exception: Unable to resolve method SpawnCommandLineSync in class CLR::GLib::Process,glib-sharp, Version=2::12::0::0, Culture=neutral, PublicKeyToken=35e10195dab3c99f

[04:06] <quietfanatic_> I got that

[04:06] *** xinming left
[04:06] <quietfanatic_> Perhaps I need a library

[04:07] <colomon> hmmm, could be

[04:07] <colomon> sorry I don't know more about mono installs

[04:08] <quietfanatic_> I don't see any packages in my system relating mono to glib

[04:08] <quietfanatic_> oh well.  I'll figure something out. Thanks for the help

[04:09] <colomon> try saying monop GLib.Process

[04:09] <quietfanatic_> "Could not find GLib.Process"

[04:10] <quietfanatic_> yeah

[04:10] <colomon> yeah, that's your problem there.  :)

[04:13] <quietfanatic_> Aha

[04:13] <quietfanatic_> I found it in a package called gtk-sharp-2

[04:13] <colomon> \o/

[04:14] <quietfanatic_> And it works perfectly

[04:14] <quietfanatic_> wish I could say as much for my code that calls it :)

[04:14] <quietfanatic_> s/calls/uses

[04:14] <quietfanatic_> but that's my problem

[04:14] <quietfanatic_> btw, you gave me an implementation of shell, rather than run

[04:14] <quietfanatic_> not like there's a big difference

[04:15] <quietfanatic_> At least, I think that's what this does

[04:16] <colomon> run doesn't return standard out, etc?

[04:16] <quietfanatic_> Run doesn't call the shell, I believe

[04:16] <quietfanatic_> the multi-argument and single-argument forms of run were split up, at least according to how I'm reading this spec

[04:17] <quietfanatic_> looks like I can skip the shell with SpawnSync

[04:17] <colomon> ah

[04:17] <colomon> you're now officially ahead of me on this.  :)

[04:18] <quietfanatic_> Heh :)

[04:19] <quietfanatic_> Oh dear, looks like SpawnSync takes all sorts of nasty arguments.

[04:20] <quietfanatic_> I think I may stick with SpawnCommandLineSync.

[04:21] <colomon> constant String-Array   = CLR::("System.String[]");

[04:21] <colomon> String-Array.new(0);

[04:21] <colomon> if string[] is what you're worried about, and 0 elements is good enough.  :)

[04:22] <quietfanatic_> There's like a

[04:22] <quietfanatic_> SpawnFlags

[04:22] <quietfanatic_> and

[04:22] <quietfanatic_> SpawnChildSetupFunc

[04:23] <quietfanatic_> Flags I can probably give 0 or a bitty number, but I have no clue what to do with that second thing

[04:23] <colomon> should be able to do something like 

[04:23] <colomon> constant GlibSpawnChildSetupFunc = CLR::("GLib::SpawnChildSetupFunc,$GLIB");

[04:23] <colomon> and then GlibSpawnChildSetupFunc.enum-you-want

[04:24] <quietfanatic_> hm

[04:26] <quietfanatic_> Well, I'll figure that out later if the shell proves to be too much overhead

[04:27] *** xinming joined
[04:29] *** xinming left
[04:29] *** xinming joined
[04:33] *** shachaf_ is now known as shachaf

[04:34] *** xinming left
[04:38] *** colomon left
[04:39] *** mdxi joined
[04:50] *** xinming joined
[04:51] *** jeffreykegler joined
[04:58] *** xinming left
[05:00] *** colomon joined
[05:02] *** xinming joined
[05:09] *** jeffreykegler left
[05:12] <moritz> \o

[05:13] <diakopter> o/

[05:14] *** xinming left
[05:20] *** xinming joined
[05:21] *** agentzh joined
[05:25] *** xinming left
[05:27] *** xinming joined
[05:33] <Radvendii> how do i reference a captured value in a replace clause of .subst(:g,//,{replacement})?

[05:33] <Radvendii> i have tried $/ $() and *

[05:33] <moritz> Radvendii: the match object is passed as the argument to the {replacement} closure

[05:33] <moritz> so it's available as $_

[05:34] <Radvendii> ah

[05:34] <Radvendii> thank you muchly

[05:34] <Radvendii> and if there is only one match, then $_ will be it?

[05:34] <moritz> or you can also write    -> $/ { $0 ~ $2 }

[05:34] <moritz> Radvendii: if there are multiple matchs, then the block in invoked multiple times, each time with a different match

[05:35] <Radvendii> ok. that makes sense. thanks

[05:35] <Radvendii> you guys are so helpful!

[05:35] *** xinming left
[05:38] *** sorear_ is now known as sorear

[05:40] <Radvendii> b: say "".subst(:g, /<![#]>(\d)/, {$_});

[05:40] <p6eval> b 1b7dd1: OUTPUT«Cannot take substr outside string␤  in <anon> at line 22:/tmp/D5MA62rdzf␤  in <anon> at line 2647:src/gen/core.pm␤  in 'Cool::match' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in 'Cool::subst' at line 2312:src/gen/core.pm␤  in main program body at line 22:/tmp/…

[05:40] <Radvendii> why does it do that?

[05:40] <Radvendii> b: say "".subst(/<![#]>(\d)/, {$_});

[05:40] <p6eval> b 1b7dd1: OUTPUT«Cannot take substr outside string␤  in <anon> at line 22:/tmp/2FbIG2wPI6␤  in 'Cool::match' at line 2684:src/gen/core.pm␤  in 'Cool::subst' at line 2312:src/gen/core.pm␤  in main program body at line 22:/tmp/2FbIG2wPI6␤»

[05:40] <sorear> colomon: the QueueDrawArea calls are really important - that's how we actually make the data appear on screen

[05:41] <sorear> colomon: HOWEVER it would be possible to optimize ExposeEvent a lot so that it makes 1 gtk call instead of O(height)

[05:41] <sorear> quietfanatic_: run is not available in Niecza because of a major impedance mismatch between the C# API and the Perl 6 API

[05:42] <Radvendii> how do i match not a series of characters in a regex?

[05:42] <Radvendii> if i want to match everything that is not a #?

[05:43] <sorear> quietfanatic_: C# is a Windows export - it uses command tails.   run("whatever", 'arg1 arg2 "arg 3"').  The called process is responsible for parsing the data which comes in via GetCommandLine, what used to show up at 80h in the PSP...

[05:45] <sorear> Radvendii: <![#]>(\d) is equivalent to <!before '#'> \d; I don't think that's what you mean (take a moment to understand why the <!before '#'> is redundant)

[05:45] <Radvendii> what do you mean by <!before '#'>?

[05:45] <Radvendii> what is the before?

[05:46] *** cooper left
[05:47] <Radvendii> litterally an exclamation point followed by a #?

[05:50] <sorear> Radvendii: are you familiar with the concept of a zero-width assertion?  <![#]> is one

[05:50] *** quietfanatic_ left
[05:50] <Radvendii> i am not. how would i get it to match a series of numbers, except when preceded by a #

[05:52] <sorear> Radvendii: consider the string "#234".  neither 3 nor 4 is immediately preceded by a #.  should they match?

[05:52] <Radvendii> well… no

[05:52] <sorear> how about "12 # 34 56".  What should match?

[05:53] <Radvendii> 12 and 56 should and it doesn't matter if 34 does or not

[05:53] <Radvendii> well

[05:53] <Radvendii> lets say it should match

[05:53] <Radvendii> the entire number cant be immediately preceded by a pound.

[05:54] <sorear> so, "12 #34 56" -> 12 56?

[05:55] <Radvendii> yeah

[05:57] <sorear> niecza: .say for "12 #34 56".comb(/\#? \d+/).grep({ !m/\#/ }) # I guess something like this

[05:57] <p6eval> niecza v12-3-g193ca57: OUTPUT«===SORRY!===␤␤No unspace allowed in regex; if you meant to match the literal character, please enclose in single quotes ('#') or use a backslashed form like \x23 at /tmp/CPYZjcbk_c line 1:␤------> .say for "12 #34 56".comb(/\⏏[3…

[05:58] <sorear> niecza: .say for "12 #34 56".comb(/'#'? \d+/).grep({ !m/'#'/ }) # I guess something like this

[05:58] <p6eval> niecza v12-3-g193ca57: OUTPUT«12␤56␤»

[06:00] <Radvendii> and to only match ones that had no # could i do /'#'! \d+/

[06:00] <Radvendii> where does the ! (not) go?

[06:01] <moritz> it doesn't work like that.

[06:01] <Radvendii> dang. how does it work?

[06:02] <moritz> when <after> is implemented, <!after '#'> \d+

[06:02] <sorear> moritz: that won't work

[06:03] <moritz> hm, needs <!after '#> << \d+  maybe

[06:03] <sorear> niecza: say "123 #456 789".comb(/<!after '#'> \d+/)

[06:03] <p6eval> niecza v12-3-g193ca57: OUTPUT«123 56 789␤»

[06:03] <moritz> niecza: say "123 #456 789".comb(/<!after '#'> « \d+/)

[06:03] <p6eval> niecza v12-3-g193ca57: OUTPUT«123 789␤»

[06:03] <moritz> better

[06:03] <sorear> that also won't work if there are letters before the numbers

[06:03] <Radvendii> there arent

[06:03] <Radvendii> so no worries

[06:04] <Radvendii> what does the « modifier do generically

[06:04] <sorear> does anyone have a favorite regex tutorial to recommend?

[06:04] <moritz> not modifiers, word boundary assertions

[06:05] <sorear> embarrasingly, I seem to have forgotten all my regex pedagogy

[06:05] <moritz> sorear: you mean, general ones?

[06:05] <sorear> moritz: yes

[06:05] <moritz> sorear: "Mastering Regular Expressions" be J. Friedl

[06:05] <moritz> or   perldoc perlretut

[06:06] <Radvendii> alright. it seems regex has been kicked up a notch since perl5 :P ill hit the books. thanks

[06:09] *** cooper joined
[06:18] <Radvendii> wait, you said after they impliment "after" is that not implimented yet?

[06:22] *** cooper left
[06:24] <moritz> not in rakudo, iirc

[06:37] <sorear> niecza has after in some cases

[06:37] *** cooper joined
[06:43] *** sayu joined
[06:56] *** ponbiki joined
[06:57] *** Radvendii left
[07:12] <moritz> does it reverse the string or the regex?

[07:23] *** zby_home joined
[07:24] <sorear> moritz: oooooh!

[07:24] <sorear> moritz: it reverses the regex, which is why it only the very simple case of a list of character classes

[07:24] <sorear> supports

[07:25] <sorear> reversing the string is a brillia... wait no that won't work.

[07:26] <moritz> right, I should have thought a bit more about it :-)

[07:26] <moritz> p5 does a nice cheat for look-behind

[07:27] <moritz> it keeps track of the lengths that a regex can match

[07:27] <moritz> and only allows fixed length pattern in look-behind

[07:27] <moritz> and then simply anchors the regex to $pos - $expected_len, and matches forward

[07:27] <moritz> from there

[07:29] *** jimmy1980 joined
[07:32] <sorear> p5 can cheat a lot more than we can because p5regexes are so much more declarative

[07:32] *** Chillance joined
[07:34] *** mkramer joined
[07:34] *** mkramer left
[07:42] *** f00li5h joined
[07:43] *** mkramer1 joined
[07:43] *** mkramer1 left
[07:52] *** grondilu joined
[07:53] <grondilu> perl6: say 'foo bar' ~~ /(.*) \s bar/

[07:53] <p6eval> rakudo 6825f4: OUTPUT«#<failed match>␤»

[07:53] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[07:53] <p6eval> ..niecza v12-3-g193ca57: OUTPUT«#<match from(0) to(7) text(foo bar) pos([#<match from(0) to(3) text(foo) pos([].list) named({}.hash)>].list) named({}.hash)>␤»

[07:53] <grondilu> ^ bug, right?

[07:54] <grondilu> nom: say 'foo bar' ~~ /(.*) \s bar/

[07:54] <p6eval> nom 6825f4: OUTPUT«#<failed match>␤»

[07:54] <grondilu> this should match, shouldn't it?

[07:55] *** tokuhirom left
[07:55] <moritz> seems it doesn't backtrack :(

[07:56] <moritz> ah, it's submitted as a bug already, iirc

[07:56] <moritz> backtracking over captures doesn't seem to work

[08:02] <sorear> moritz: not captures, subrules

[08:02] <sorear> non-capturing subrules like <.foo> also don't backtrack properly

[08:02] <sorear> nom: say 'foo bar' ~~ /$0=[.*] \s bar/

[08:02] <p6eval> nom 6825f4: OUTPUT«=> <foo bar>␤ 0 => <foo>␤␤»

[08:02] <sorear> and capturing non-subrules seem to work

[08:06] <moritz> sorear: the example above did not involve a subrule

[08:11] <sorear> I call () an anonymous subrule, since it's semantically very much like $0=<$( / ... / )>

[08:11] * sorear is feeling very self-concious about contraryness now

[08:15] *** grondilu left
[08:21] <lue> Am I wrong in thinking (.*) captures all of 'foo bar' here ?

[08:23] <sorear> lue: not really

[08:23] <sorear> lue: usually we reserve the term "captures" for when the enclosing match is sucessfull

[08:25] * lue just realizes the significance of the statement "seems it doesn't backtrack :(" to his question

[08:25] <Woodi> sorear: I am second to recomend "Mastering Regular Expressions"

[08:26] *** colomon_ joined
[08:28] *** colomon left
[08:28] *** colomon_ is now known as colomon

[08:35] *** Trashlord joined
[09:10] *** fsergot joined
[09:31] <sorear> shocking.  I just made the optimization I talked about earlier to ExposeEvent in colomon 's mandelbrot, 40% speedup

[09:34] <Woodi> gratz ! :)

[09:34] *** jimmy1980 left
[09:35] <Woodi> btw. to make subs awailable from module I need to put "proto ..." stuf ?

[09:37] *** sayu left
[09:41] *** jimmy1980 joined
[09:53] <sorear> no

[09:53] <sorear> to make subs available from module you use "is export"

[09:56] <Woodi> ok. i steal examples from Test.pm and everything there is proto-marked and multi-marked...

[09:56] <Woodi> sorear: but just adding 'is export' work. thanx

[09:57] *** GlitchMr joined
[09:57] <GlitchMr> perl6: print «Hello world!»

[09:57] <p6eval> niecza v12-3-g193ca57: OUTPUT«Hello world!»

[09:57] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\171'␤decodeUTF8': bad data: '\187'␤Helloworld!»

[09:57] <p6eval> ..rakudo 6825f4: OUTPUT«Helloworld!»

[09:58] <GlitchMr> ...

[09:58] <GlitchMr> I see small difference... 1 space of difference... it's weird...

[09:58] <GlitchMr> But I find it nice that it recognized those quotes...

[10:00] *** GlitchMr left
[10:05] *** agentzh left
[10:08] <Woodi> add_method adds routines __into__ class body so $class_instance->added_method works. is, in modules, kind of routines table I can add sub ? storing subs in hash require useing one lvl of calls more eg: execute( $name) { &%cmdhash{ $name} }

[10:16] <sorear> perl6: print 1..6

[10:16] <p6eval> niecza v12-3-g193ca57: OUTPUT«1..6»

[10:16] <p6eval> ..pugs b927740, rakudo 6825f4: OUTPUT«123456»

[10:18] * sorear -> sleep

[10:19] *** agentzh joined
[10:47] *** wk joined
[10:49] *** jimmy1980 left
[10:54] *** GlitchMr joined
[10:54] *** jimmy1980 joined
[10:54] *** mj41 joined
[10:59] *** icwiener joined
[11:03] *** mj41 left
[11:04] *** toebu joined
[11:17] *** mj41 joined
[11:21] *** toebu left
[11:26] *** jimmy1980 left
[11:26] *** jimmy1980 joined
[11:35] *** xinming joined
[11:45] *** Chillance left
[11:46] *** toebu joined
[11:50] *** Chillance joined
[11:51] *** fsergot left
[12:02] *** toebu left
[12:04] *** Moukeddar joined
[12:13] *** fsergot joined
[12:13] *** Psyche^ joined
[12:16] *** Patterner left
[12:16] *** Psyche^ is now known as Patterner

[12:33] <colomon> sorear: nice optimization!

[12:34] <colomon> sorear: I thought that loop must be really hurting us, because it involved a lot of both costly Gtk calls and lock checks.

[12:34] *** MayDaniel joined
[12:41] *** shinobicl_ joined
[12:46] *** shinobicl_ left
[12:47] *** icwiener left
[12:48] *** Moukeddar left
[12:48] *** icwiener joined
[13:00] *** mkramer joined
[13:00] *** mkramer left
[13:00] *** toebu joined
[13:02] *** mishin joined
[13:05] *** wk left
[13:10] *** MayDaniel left
[13:10] *** agentzh left
[13:17] *** am0c left
[13:28] *** fsergot left
[13:28] *** mj41 left
[13:30] *** colomon left
[13:39] *** kaare_ joined
[13:46] *** hundskatt left
[13:47] *** ilogger2 joined
[13:47] *** dju joined
[13:48] *** _ilbot joined
[13:48] *** buubot_backup joined
[13:48] *** jimmy1980 joined
[13:49] *** DarthGandalf joined
[13:49] *** imarcusthis joined
[13:49] *** simcop2387 joined
[13:51] *** fsergot joined
[13:52] *** jlaire joined
[13:52] *** jrockway joined
[13:52] *** cxreg joined
[13:52] *** LoRe joined
[13:52] *** kthakore joined
[13:52] *** avar joined
[13:52] *** jnthn_ joined
[13:52] *** mishin joined
[13:52] *** icwiener joined
[13:52] *** ponbiki joined
[13:52] *** sorear joined
[13:52] *** domidumont joined
[13:52] *** fhelmberger joined
[13:52] *** Exodist joined
[13:52] *** rsimoes joined
[13:52] *** mattp_ joined
[13:52] *** Lothar joined
[13:52] *** rhr joined
[13:52] *** PAAC234 joined
[13:52] *** mantovani joined
[13:52] *** mux joined
[13:52] *** broquaint joined
[13:52] *** zamolxes_ joined
[13:52] *** tadzik joined
[13:52] *** estrabd joined
[13:52] *** Sarten-X joined
[13:52] *** stepnem joined
[13:52] *** kranius joined
[13:52] *** s1n joined
[13:53] *** risou joined
[13:53] *** djanatyn joined
[13:53] *** kaare_ joined
[13:53] *** xinming joined
[13:53] *** GlitchMr joined
[13:53] *** ribasushi joined
[13:53] *** REPLeffect joined
[13:53] *** [particle] joined
[13:53] *** Khisanth joined
[13:53] *** silug joined
[13:53] *** Juerd joined
[13:53] *** amkrankruleuen joined
[13:53] *** zostay joined
[13:53] *** aloha joined
[13:53] *** revdiablo joined
[13:53] *** hillu joined
[13:53] *** kst joined
[13:53] *** mikemol joined
[13:53] *** HarryS joined
[13:53] *** Tene joined
[13:53] *** sftp joined
[13:53] *** yves joined
[13:53] *** frettled joined
[13:53] *** clkao joined
[13:53] *** pochi joined
[13:53] *** og01 joined
[13:53] *** BooK joined
[13:53] *** apejens joined
[13:53] *** Gothmog_ joined
[13:53] *** Patterner joined
[13:53] *** Chillance joined
[13:53] *** overrosy joined
[13:53] *** orafu joined
[13:53] *** shachaf joined
[13:53] *** szbalint_ joined
[13:53] *** PacoLinux joined
[13:53] *** wooden joined
[13:53] *** preflex joined
[13:53] *** lestrrat joined
[13:53] *** lue joined
[13:53] *** jaldhar joined
[13:53] *** felher joined
[13:53] *** cosimo joined
[13:53] *** alvis joined
[13:53] *** flussence joined
[13:53] *** sivoais joined
[13:53] *** arlinius joined
[13:53] *** betterworld joined
[13:53] *** gfldex joined
[13:53] *** plobsing joined
[13:53] *** mtk joined
[13:53] *** dakkar joined
[13:53] *** kcwu joined
[13:53] *** awwaiid joined
[13:53] *** prammer joined
[13:53] *** jasonmay joined
[13:53] *** ashleydev joined
[13:53] *** jerome__ joined
[13:53] *** aindilis joined
[13:53] *** daemon joined
[13:53] *** Helios joined
[13:53] *** p6eval joined
[13:53] *** Ingis joined
[13:53] *** charsbar__ joined
[13:53] *** sendak.freenode.net sets mode: +v p6eval

[13:53] *** ruoso_ joined
[13:53] *** z-b joined
[13:53] *** bbkr joined
[13:53] *** drbean joined
[13:53] *** Woodi joined
[13:53] *** rafl joined
[13:53] *** twinshadow joined
[13:53] *** integral joined
[13:53] *** jjore_ joined
[13:53] *** krakan joined
[13:53] *** Timbus joined
[13:53] *** phenny joined
[13:53] *** nsh joined
[13:53] *** Lorn joined
[13:53] *** arnsholt joined
[13:53] *** ingy joined
[13:53] *** szabgab joined
[13:53] *** TimToady joined
[13:53] *** pnu joined
[13:53] *** __sri joined
[13:53] *** ranguard joined
[13:53] *** athomason_ joined
[13:53] *** jtpalmer joined
[13:53] <GlitchMr> > qw qw q;

[13:53] <GlitchMr> Alphanumeric character is not allowed as a delimiter at line 1, near "qw q;\n"

[13:53] <GlitchMr> Perl 6 is fun...

[13:53] <GlitchMr> Also, I see a lot of people there :).

[13:54] *** jimmy1980 left
[13:54] *** skangas_ joined
[13:54] *** skangas_ is now known as skangas

[13:54] <GlitchMr> ... unless it was just a lag...

[13:54] *** dalek joined
[13:55] *** BinGOs joined
[13:56] *** jimmy1980 joined
[14:02] *** dju left
[14:02] *** dju joined
[14:02] *** DarthGandalf left
[14:02] *** DarthGandalf joined
[14:02] *** ChanServ sets mode: +v dalek

[14:02] *** HarryS is now known as Guest11641

[14:06] *** jimmy1980 left
[14:07] *** jimmy1980 joined
[14:08] *** carlin joined
[14:09] *** Sarten-X left
[14:14] *** agentzh joined
[14:16] *** Radvendii joined
[14:16] *** PZt joined
[14:16] <Radvendii> what is the syntax for calling a method on each element of an array?

[14:16] <Radvendii> and what happens to the return values?

[14:17] <Radvendii> never mind. .map({}) works for me

[14:27] <moritz> @a>>.meth

[14:32] <jnthn_> afternoon, #perl6

[14:32] *** jnthn_ is now known as jnthn

[14:32] <jnthn> hmm...we hadded a netsplit or two, did we... :)

[14:35] *** BinGOs left
[14:35] *** BinGOs joined
[14:39] <moritz> \o jnthn 

[14:39] <jnthn> hi moritz 

[14:39] *** simcop2387 left
[14:39] *** imarcusthis left
[14:40] *** imarcusthis joined
[14:40] *** simcop2387 joined
[14:44] *** jimmy1980 left
[14:44] *** mj41 joined
[14:44] *** jimmy1980 joined
[14:45] *** prammer left
[14:46] *** MayDaniel joined
[14:48] *** prammer joined
[14:58] *** kaare_ left
[14:58] *** sayu joined
[15:02] *** jimmy1980 left
[15:03] *** am0c joined
[15:03] *** Radvendii left
[15:06] *** hundskatt joined
[15:08] *** Woodi left
[15:09] *** jimmy1980 joined
[15:10] *** Woodi joined
[15:22] <GlitchMr> perl6: eval {print "I know that I was supposed to use try {}"}

[15:22] <p6eval> niecza v12-3-g193ca57: OUTPUT«Unhandled exception: Cannot invoke an undef sub␤  at (eval) line 1 (mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2003 (eval @ 3) ␤  at /tmp/HO3Epa1XNk line 1 (mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2224 (ANON @ 2) ␤  …

[15:22] <p6eval> ..rakudo 6825f4: OUTPUT«Nominal type check failed for parameter '$code'; expected Str but got Block instead␤  in sub eval at src/gen/CORE.setting:449␤  in block <anon> at /tmp/0Z4hB_dCEM:1␤  in <anon> at /tmp/0Z4hB_dCEM:1␤»

[15:22] <p6eval> ..pugs b927740:  ( no output )

[15:22] <GlitchMr> ... too bad that eval {} block form doesn't have helpful error messages... not surprised...

[15:23] *** Radvendii joined
[15:23] <moritz> what's not helpful about it?

[15:23] <jnthn> The Rakudo one told you that eval expected a Str rather than a Block. 

[15:23] <moritz> it says it wants a Str, not a Block

[15:23] <GlitchMr> ... right...

[15:23] <moritz> which should be enough hint, no?

[15:23] *** agentzh left
[15:23] <GlitchMr> yeah...

[15:23] <jnthn> At a stretch we could add a candidate that takes a block and tells you to use "try" :)

[15:27] <dalek> rakudo/nom: 2f10ef6 | jnthn++ | src/Perl6/ (2 files):

[15:27] <dalek> rakudo/nom: Refactor sigiltype to do the type object lookup, so we have it to hand a bit earlier.

[15:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2f10ef6c7e

[15:27] *** jimmy1980 left
[15:33] *** donri joined
[15:35] *** jimmy1980 joined
[15:37] <GlitchMr> perl6: qq(is not a function...)

[15:37] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&qq"␤    at /tmp/7cdCeDjust line 1, column 1 - line 2, column 1␤»

[15:37] <p6eval> ..niecza v12-3-g193ca57: OUTPUT«===SORRY!===␤␤Bogus term at /tmp/DtfuLccAvo line 1:␤------> qq(is not a function...⏏)␤␤Undeclared routine:␤  'function' used at line 1␤␤Parse failed␤␤»

[15:37] <p6eval> ..rakudo 6825f4: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[15:37] <GlitchMr> That's good thing :).

[15:39] <Radvendii> what does the unable to parse postcircumfix:sym<()> thing mean? i'm getting that a lot.

[15:41] <GlitchMr> It means that it couldn't find ending parentheses...

[15:41] <GlitchMr> ... or not...

[15:41] <Radvendii> but i have the ending parentheses. they're all matched. . .

[15:42] <jnthn> It tends to mean something you wrote inside a set of parens could not be parsed. It hit a parse failure before finding the final )

[15:44] <Radvendii> ah

[15:44] <Radvendii> object orientation always makes errors uninteligible…

[15:44] <moritz> nom: (1 1)

[15:45] <p6eval> nom 6825f4: OUTPUT«===SORRY!===␤Confused at line 1, near "(1 1)"␤»

[15:45] <GlitchMr> rakudo: burgers (|) are (|) awesome

[15:45] <p6eval> rakudo 6825f4: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[15:45] *** donri left
[15:45] <moritz> Radvendii: parse errors have nothing to do with object orientation

[15:45] <Radvendii> then why are they so much less understandable in perl6 than perl5

[15:46] <moritz> Radvendii: because rakudo doesn't implement them very well yet

[15:46] <GlitchMr> Because it's... WIP?

[15:46] <moritz> niecza: (1 1)

[15:46] *** toebu joined
[15:46] <p6eval> niecza v12-3-g193ca57: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/gqn9SOgqyq line 1:␤------> (1 ⏏1)␤␤Parse failed␤␤»

[15:46] <moritz> much better

[15:46] <GlitchMr> Trust me, errors in languages other than Perl are way less understandable... so it's not that bad...

[15:46] <Radvendii> ah, and, what's WIP?

[15:46] <Radvendii> yeah, i know

[15:46] <GlitchMr> work in progress

[15:47] <Radvendii> ah

[15:47] <Radvendii> fair enough

[15:47] <moritz> perl 5 quite often just says "syntax error"

[15:47] <GlitchMr> With location of error :).

[15:47] <GlitchMr> It's actually not that bad...

[15:47] <moritz> ... which is often just as inaccurate as that of rakudo

[15:48] <Radvendii> just saying, this isn't even giving me the line number, it's giving me a range of lines it could be on (between the parens)

[15:48] <GlitchMr> syntax error at - line 13, near "")"

[15:48] <GlitchMr>   (Might be a runaway multi-line "" string starting on line 1)

[15:48] <GlitchMr> ...

[15:49] <GlitchMr> Yeah, not really helpful

[15:49] <GlitchMr> But it's way better than what PHP does for example...

[15:50] <Radvendii> mhmm

[15:50] <Radvendii> or java

[15:50] *** jimmy1980 left
[15:50] <GlitchMr> if (isset($_GET['user']) {}

[15:50] <GlitchMr> Parse error: syntax error, unexpected '{' in /code/uRjY0V on line 2

[15:51] <GlitchMr> ... but Perl 5 gives similar results in this code, so yeah...

[15:51] <GlitchMr> syntax error at - line 1, near ") {"

[15:52] *** jimmy1980 joined
[15:53] <GlitchMr> But I think that with removed parentheses in if statement I will avoid such errors... It's hard to make such errors if you don't have parentheses...

[15:54] <Radvendii> huh?

[15:54] <GlitchMr> if defined $variable {}, or even if defined($variable) {}

[15:55] <GlitchMr> Actually, isset() is pretty funny in PHP...

[15:55] <GlitchMr> if (isset(CONSTANT)) {echo CONSTANT}

[15:55] <GlitchMr> And error:

[15:55] <GlitchMr> Parse error: syntax error, unexpected ')', expecting T_PAAMAYIM_NEKUDOTAYIM in /code/i9f450 on line 2

[15:55] *** Chillance left
[15:55] <GlitchMr> Now try to find it :).

[15:56] <Radvendii> haha. were you really expecting me to randomly type T_PAAMAYIM_NEKUDOTAYIM?

[15:56] <Radvendii> and why are they using hebrew words...

[15:56] <GlitchMr> It's token name...

[15:57] <GlitchMr> lol

[15:57] <Radvendii> paamayim is twice and nekudotayim is two punctuations

[15:57] <GlitchMr> It's actually double colon, but in this case you shouldn't use isset() at all...

[15:57] <Radvendii> uh...

[15:57] <Radvendii> oh

[15:57] *** donri joined
[15:57] <Radvendii> that makes sense

[15:58] <Radvendii> nekudotayim must be how they say colon

[15:58] <GlitchMr> You should use defined() to check constants, but well... that's really confusing...

[15:58] <Radvendii> but why the hell do they use hebrew?

[15:58] <Radvendii> mhmm

[15:59] <GlitchMr> Who knows...

[15:59] <GlitchMr> It expects "::" which is used to activate static class variables in PHP...

[15:59] <GlitchMr> And functions...

[16:00] <GlitchMr> It's really confusing when PHP gives token names in error messages...

[16:00] <GlitchMr> Especially if some of those tokens mean only one thing... like T_PAAMAYIM_NEKUDOTAYIM which only marks ::...

[16:02] <Radvendii> im stumped. what's the syntax error in this:

[16:02] <Radvendii> (   5     ( #AVERAGE ANNUAL SALARY   6         ([+] #sum   7             (@as = #Contract value divied by the contract length   8                     (@data= (slurp 'draftdata.txt').split("\n").map({ [.split(' ')] }) )   9                     #parse text(split by newline then split each by space  10                 .map(->$_ {$_[1]/$_[0]}) #divide each value by length of contract  11             )  12         )/@data.elems #divide th

[16:02] <Radvendii> aw crap

[16:03] <Radvendii> hang on

[16:03] <GlitchMr> ...

[16:03] <GlitchMr> can you put this to pastebin

[16:03] <moritz> Radvendii: please use a paste bin for pasting code here

[16:03] <Radvendii> how do i do that?

[16:04] <moritz> Radvendii: go to gist.github.com, and paste your code into the big text box

[16:04] <moritz> Radvendii: and then submit it, and paste the result URL here

[16:04] <moritz> djanatyn: do you need a deadline extension for http://www.google-melange.com/gci/task/view/google/gci2011/7177376 ?

[16:05] <Radvendii> okay

[16:07] <moritz> jnthn: your commits seem to have caused a regression in t/spec/S02-types/declare.t

[16:07] <moritz> "Type Array cannot accept type arguments"

[16:08] *** s1n left
[16:10] *** jimmy1980 left
[16:11] <jnthn> moritz: Yeah, I'm aware

[16:11] <jnthn> moritz: It was passing bogusly before. I'd fudge it part from I'm going to put in commits that fix it in just a moment.

[16:12] <moritz> jnthn: np, just stumbled over it while spectesting another patch

[16:13] <moritz> oh hell, this is taking ages, I'll just commit it :-)

[16:13] <dalek> rakudo/nom: 48514ff | moritz++ | src/core/Failure.pm:

[16:13] <dalek> rakudo/nom: restore "use fatal"

[16:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/48514ff01b

[16:14] <jnthn> ;)

[16:15] *** GlitchMr left
[16:15] *** jimmy1980 joined
[16:16] *** z-b is now known as zb

[16:16] *** colomon joined
[16:18] <Radvendii> why is it that i can't have an object, and then on the next line have a method call. like so:https://gist.github.com/1430575

[16:19] *** sayu left
[16:20] <colomon> Radvendii: If you're getting a parse error message you can't figure out from Rakudo, it may be helpful to run it through std: here, which is a completely different implementation of the Perl 6 grammar.

[16:20] <colomon> std: if (isset($_GET['user']) {}

[16:20] <p6eval> std be1f10e: OUTPUT«===SORRY!===␤Variable $_GET is not predeclared at /tmp/5djNPTfPve line 1:␤------> if (isset(⏏$_GET['user']) {}␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/5djNPTfPve li…

[16:21] <colomon> (for instance) (looks better if your IRC client supports colors)

[16:21] *** sayu joined
[16:21] <Radvendii> i figured out what the error was

[16:21] <Radvendii> now i just want to know why it was implimented that way

[16:21] <Radvendii> im trying to break one statement over several lines

[16:22] <Radvendii> and it doesnt let me put the method call on the line after the object

[16:23] <jnthn> Radvendii: That's the way Perl 6 syntax is; I suspect the spec (S02) has some justification on that. You can get around the issue by sticking a \ at the end of the previous line ("unspace")

[16:23] <Radvendii> ah. i solved it by putting parens around the object, but thanks!

[16:23] <colomon> Actually, that detail of the p6 grammar spec has always bugged me, too.

[16:26] *** JimmyZ joined
[16:27] *** three18ti joined
[16:28] *** kaare_ joined
[16:29] *** MayDaniel left
[16:44] *** GlitchMr joined
[16:46] *** JimmyZ left
[16:46] <colomon> nom: say 12313.WHICH; my $a = 12313; say $a.WHICH

[16:46] <p6eval> nom 48514f: OUTPUT«-3029978659897549649␤-3029978659897549649␤»

[16:46] <colomon> nom: say (12313/2).WHICH; my $a = (12313/2); say $a.WHICH

[16:46] <p6eval> nom 48514f: OUTPUT«-9175363216054543126␤-9175363216054536736␤»

[16:47] <colomon> nom: say (12313/2).WHICH; my $a = (12311/2)+1; say $a.WHICH

[16:47] <p6eval> nom 48514f: OUTPUT«-587439194525867475␤-587439194515431390␤»

[16:47] <colomon> how is that working?!

[16:49] <jnthn> Does Rat override WHICH?

[16:49] <colomon> I don't know.

[16:49] *** icwiener left
[16:49] *** lichtkind joined
[16:49] <colomon> nope

[16:50] <colomon> The only definition coming up in my ack source is in Mu.pm

[16:51] <colomon> nqp::p6box_i(nqp::where(self))

[16:53] <moritz> it should, I think

[16:54] <colomon> next question is: how?

[16:54] <colomon> heck, how does Int get a proper WHICH?

[16:54] <jnthn> nom: say 42 === 42

[16:54] <p6eval> nom 48514f: OUTPUT«Bool::True␤»

[16:54] <jnthn> nom: my $a = 42; my $b = 42; say $a === $b

[16:55] <p6eval> nom 48514f: OUTPUT«Bool::True␤»

[16:55] <colomon> I don't mean current-programming-wise, I just mean concept wise

[16:55] <jnthn> nom: my $a = 42; my $b = 41 + 1; say $a === $b

[16:55] <moritz> colomon: with a cheating multi infix:<===>(Int, Int)

[16:55] <p6eval> nom 48514f: OUTPUT«Bool::True␤»

[16:55] <moritz> colomon: ah

[16:55] <jnthn> ah

[16:55] <moritz> colomon: value types are supposed to overwrite .WHICH

[16:55] <colomon> right.

[16:55] <moritz> and they shouldn't return a Str or an Int

[16:55] <colomon> but every Int value needs a ... wait, what?

[16:56] <moritz> but rather an object that captures the type and the value or memory location

[16:56] <colomon> I thought .WHICH returned an Int

[16:56] <jnthn> Should be an ObjAt, but NYI

[16:56] <colomon> ObjAt?

[16:57] <moritz> see S02/The ObjAt Type/

[16:58] <dalek> roast: c73f724 | moritz++ | S (2 files):

[16:58] <dalek> roast: unfudge now passing "use fatal" tests for rakudo

[16:58] <dalek> roast: review: https://github.com/perl6/roast/commit/c73f72401a

[16:59] <colomon> afkish # someone is demanding "The Little Engine that Could"

[17:00] <moritz> the spec is very vague on ObjAt

[17:01] *** molaf joined
[17:01] <moritz> it says it's a "value, rather than another object"

[17:01] <moritz> but it also says that it can be memory location, plus other information

[17:01] <moritz> and then that the serialization can also be used for value types

[17:02] <moritz> so it seems to that ObjAt is rather flexible for a value type

[17:06] <colomon> so ObjAt is a magic class, eh?  :)

[17:06] <moritz> well, I dunno what it is

[17:06] <moritz> I can't be both very magic and a value type

[17:08] <colomon> and can you call .WHICH on an ObjAt?

[17:08] <moritz> yes

[17:09] <jnthn> .oO( tbh, I prefer it when moritz is magic rather than a value type )

[17:13] * jnthn is one test off having typed hashes and stuff working

[17:13] <colomon> \o/

[17:13] <jnthn> Well, actually the test is to do with typed arrays.

[17:13] <jnthn> Well, actually, the test is a terrifying generic instantiation bug...but anyways :)

[17:13] <jnthn> *is to do with

[17:14] <jnthn> ah, I see what's going on. Hm.

[17:16] *** birdwindupbird joined
[17:17] *** birdwindupbird left
[17:17] *** Guest11641 left
[17:17] *** HarryS joined
[17:33] *** toebu left
[17:37] <dalek> rakudo/nom: cb2abae | jnthn++ | src/Perl6/ (2 files):

[17:37] <dalek> rakudo/nom: Refactor container handling to get various bits of decision making in one place and get initial support for 'my Int %foo' in place. Not all working yet, and a couple of regressions.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cb2abae4fd

[17:37] <dalek> rakudo/nom: 0e33341 | jnthn++ | src/core/Hash.pm:

[17:37] <dalek> rakudo/nom: Quick, temporary fiddle to get typed hashes to correctly fail type checks, though error will need awesomizing.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0e33341f26

[17:37] <dalek> rakudo/nom: 7b121b5 | jnthn++ | src/core/Array.pm:

[17:37] <dalek> rakudo/nom: Just enough to make 'my Int @foo' style declarations compile properly; it's not donig the proper checks yet.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7b121b53f7

[17:37] <dalek> rakudo/nom: 0142df3 | jnthn++ | src/Perl6/Actions.pm:

[17:37] <dalek> rakudo/nom: Make sure we correctly pass along type information about what's inside a typed container.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0142df3526

[17:37] <dalek> rakudo/nom: a4e91b0 | jnthn++ | src/Perl6/Metamodel/Mixins.pm:

[17:37] <dalek> rakudo/nom: Add a way to introspect if a type is one created due to a mixin.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a4e91b0ad7

[17:37] <dalek> rakudo/nom: 5ef2d9e | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[17:37] <dalek> rakudo/nom: Fix a subtle bug that showed up in constructs like role TreeNode[::T] does Positional { has TreeNode[T] @!foo }; we actually used to ignore that type constraint and bogusly pass the test, and with this fix we can pass it for the right reasons.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ef2d9e7f0

[17:41] <dalek> roast: 9ca2f14 | jnthn++ | S09-typed-arrays/hashes.t:

[17:41] <dalek> roast: Re-fudge typed hashes test (mostly unfudges).

[17:41] <dalek> roast: review: https://github.com/perl6/roast/commit/9ca2f14ece

[17:42] <dalek> rakudo/nom: 7fd864b | jnthn++ | t/spectest.data:

[17:42] <dalek> rakudo/nom: Turn on typed hashes test file.

[17:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7fd864b4fa

[17:46] *** ksi joined
[17:49] <tadzik> greetings, #perl6

[17:49] <phenny> tadzik: 02 Dec 22:17Z <japhb> ask tadzik Why did you choose to clone Dancer, as opposed to Mojolicious or one of the other Perl 5 frameworks?  Just the one you were most familiar with, or was there a deeper reason?

[17:50] <tadzik> japhb: I knew and liked Dancer. Also, I knew mberends from the Dancer community, and have heard about the Perl 6 port for some time

[17:51] <japhb> tadzik:  I thought you were the one that created Bailador?  Or did you mean you had heard that people were working on the lower-level stuff with the intent of eventually porting Dancer?

[17:52] <tadzik> japhb: I am the one. I've heard stories on #dancer about plans for a Perl 6 port, but didn's see action

[17:52] <japhb> Ah, I get it.

[17:53] <japhb> The #mojo people (well, at least sri) are very interested in a Mojo/Mojolicious port as well.

[17:53] *** Sarten-X joined
[17:53] <tadzik> yeah, right

[17:53] <tadzik> I've heard it like 10 times already

[17:53] <tadzik> well, sri is complaining about the lack of docs now, which is kind of reasonable

[17:53] *** MayDaniel joined
[17:54] <__sri> i'm very interested in a perl 6 port of mojolicious, in case you've not heard it yet

[17:54] <tadzik> in a port, or in creating a port?

[17:54] <__sri> creating

[17:54] <tadzik> mojolicious seems Perl 6 friendly, I've seen something like this in its docs

[17:55] <__sri> it is designed to be easy to port

[17:55] <tadzik> you're missing mostly docs, right?

[17:55] <__sri> right

[17:55] <tadzik> now that we have proper NCI I may be able to figure out some proper epoll :)

[17:56] <__sri> epoll is an optimization, to get started select/poll are perfectly fine

[17:56] <jnthn> Would be a god test for it.

[17:56] <jnthn> er, good

[17:56] <tadzik> there's poll()

[17:56] <tadzik> well, IO::Socket.poll

[17:57] <__sri> all i need to get started is the functionality of what perl5 core currently offers with reasonable reference documentation

[17:57] *** benabik joined
[17:57] <tadzik> __sri: if you can, please maintain a list of things like "I was looking for some docs on XXX and didn't find any"

[17:58] <tadzik> would be great to know such stuff

[17:58] <__sri> https://github.com/kraih/mojo/blob/master/Makefile.PL#L44 # core modules we use

[17:58] *** mtk left
[17:59] <japhb> __sri, I think you might run into a chicken and egg problem -- the functionality is being filled in whenever there is both a direct need and someone capable of filling that need.  Until we know exactly what is needed that is not already there, you'd have to wait an unknown time for someone to either build it because someone *else* needs it, or we get far enough along we're just filling gaps to get "completeness"

[17:59] <tadzik> I don't see anything exotic at the first glance, maybe aside from B

[17:59] <__sri> mojolicious itself is just 11k lines of code, so once started it shouldn't take too long

[18:00] <japhb> The problem is, until someone starts the port, we won't know what *in precise detail* we're missing.

[18:01] <japhb> A lot of features were implemented not to completion, but to "good enough for the present needs"

[18:01] <japhb> That's unfortunately the way of things when a project is "75% complete"

[18:02] <japhb> However, my gut feeling is that there is enough there now to get pretty far along until there's an impassible barrier,

[18:02] <japhb> and at that point there will be strong incentive to find a way to break that barrier down.

[18:04] <__sri> maybe i should make it more clear that i'm not interested in a toy port

[18:04] *** mugenken joined
[18:04] <tadzik> :)

[18:05] <japhb> __sri, I didn't mean that.

[18:06] <japhb> I meant that at this stage, it's probably best to start with a sketch of the port, and then fill in things iteratively until a missing Perl 6 feature is found, then someone works on fixing the missing feature and someone works on continuing the iteration of the port.

[18:07] <japhb> I don't think you can start by utterly completing one layer of the Mojo* stack at a time before moving to the next, without getting rather frustrated.

[18:07] <japhb> I think the end result is a complete port, just not one build in classic bricklaying fashion.

[18:07] <japhb> *built

[18:12] *** risou is now known as risou_awy

[18:13] *** toebu joined
[18:29] *** sayu left
[18:33] *** packetknife joined
[18:42] <moritz> nom: say (-1234).base(16)

[18:42] <p6eval> nom 7fd864: OUTPUT«-4D2␤»

[18:44] <dalek> nqp: 65a9ad3 | moritz++ | / (3 files):

[18:44] <dalek> nqp: add base_I op that converts a bigint to a string with a given base

[18:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/65a9ad30a5

[19:01] *** s1n1 joined
[19:05] *** s1n1 left
[19:11] *** pat_js joined
[19:15] *** mishin left
[19:15] <moritz> nom: my $t = now; for ^1000 { 1234.base(16) }; say now - $t

[19:15] <p6eval> nom 7fd864: OUTPUT«5.20457565984858␤»

[19:16] <jnthn> o.O

[19:16] <moritz> I'm about to change that to use the C implementation in libtommath

[19:16] <jnthn> moritz++

[19:16] <wolverian> I'm more surprised it doesn't eliminate the whole for loop ;)

[19:16] <tadzik> :P

[19:17] <moritz> wolverian: well, it will as soon as we detect void context

[19:17] <jnthn> heh. And can prove that 1234.base(16) always has no side-effects :)

[19:17] <benabik> wolverian: What would be difficult as it would have to know that base…  what jnthn said

[19:17] <moritz> ah well, I forgot that void context is eager...

[19:17] <jnthn> Optimizing away for ^1000 { 1234.say } in void context probably will get us bug reports :)

[19:19] <moritz> $ ./perl6 -e 'my $t = now; for ^1000 { 1234.base(16) }; say now - $t'

[19:19] <moritz> 0.0538511770344779

[19:19] <flussence> .oO( maybe things should have a .void to go with .item and .list, to give the compiler a hint they have side effects )

[19:19] <moritz> ok, that CPU is a wee bit faster than the one on p6eval 

[19:20] <moritz> but not a factor of 100

[19:20] <dalek> rakudo/nom: c97b172 | moritz++ | src/core/Int.pm:

[19:20] <dalek> rakudo/nom: simplify Cool.base by using the appropriate nqp op

[19:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c97b172b69

[19:21] <moritz> evalbot rebuild nom

[19:21] <p6eval> OK (started asynchronously)

[19:21] *** s1n1 joined
[19:25] *** Radvendii left
[19:27] *** pat_js left
[19:33] <lichtkind> cheers

[19:33] <tadzik> hey lichtkind 

[19:33] <moritz> \o lichtkind 

[19:33] <moritz> nom: say 1

[19:33] <p6eval> nom 7fd864: OUTPUT«1␤»

[19:34] <moritz> hasn't rebuilt yet :(

[19:35] <lichtkind> moritz: du bist da in erlangen?

[19:36] <moritz> lichtkind: I'm in Erlangen 99% of the time :-)

[19:36] <lichtkind> im speeking about 3 days in march

[19:37] <sorear> good * #perl6

[19:37] <moritz> lichtkind: yes. I'm one of the organizers.

[19:38] <lichtkind> moritz: its because i had lately another idea for a talk just wated make sure that our talks dont overlap

[19:39] <moritz> Unrecognized nqp:: opcode 'nqp::base_I' at line 2342, near ");\n    }\n}"

[19:39] <moritz> seems I didn't bump the nqp revision correctly :(

[19:40] <dalek> rakudo/nom: 48b979e | moritz++ | tools/build/NQP_REVISION:

[19:40] <dalek> rakudo/nom: bump NQP revision

[19:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/48b979e7d1

[19:44] *** Radvendii joined
[19:45] <lichtkind> moritz: but if you orgnaizer yur aware of my submissions anyway

[19:47] *** Radvendii left
[20:09] <moritz> nom: my $t = now; for ^1000 { 1234.base(16) }; say now - $t

[20:09] <p6eval> nom 48b979: OUTPUT«0.0757341564784759␤»

[20:09] <moritz> nom: say 5.2 / 0.076

[20:09] <p6eval> nom 48b979: OUTPUT«68.4210526315789␤»

[20:10] <moritz> that's how much my last patch sped up Int.base :-)

[20:10] <colomon> \o/

[20:10] *** fsergot left
[20:10] <sorear> o/ colomon

[20:10] <colomon> \o

[20:11] <djanatyn> Heyo!

[20:11] <colomon> sorear: the last optimization you pushed was quite nice!

[20:13] *** wolfman2000 joined
[20:19] <sorear> colomon: how well does it work now?

[20:19] <sorear> colomon: do threads give a speedup now?

[20:20] <colomon> with THREADS=1, it's about as fast as the last non-threaded version, and looks much nicer.  THREADS=2 still makes it go slower, alas.

[20:20] <colomon> give me a minute

[20:20] <benabik> more threading should not be slower.  :-/

[20:22] *** Radvendii joined
[20:23] <colomon> back

[20:23] <colomon> I'm wondering if we're suffering lots of lock contention.

[20:23] <colomon> And extra threads just makes that worse

[20:25] <sorear> *shrug* could be.

[20:25] <sorear> the WorkQueue.monitor lock is only taken O(height) times because the work unit granularity is the line, not the pixel

[20:26] <sorear> I had hpped that would be enough to make lock contention a non-issue

[20:28] <colomon> it does seem like that should be enough, I agree.  but I'm not sure what else it could be.  You've got the DrawRgbImage calls down to a minimum, and adding threads shouldn't ever add more...

[20:31] <colomon> but yeah, with THREADS=1, I get Waiting for work at 12.910678; with =2, it's 25.953764

[20:33] <colomon> and I think there actually are more calls to ExposeEvent -- I've got it dumping the Y and height of the expose event, and I'm pretty sure there are more height 2 calls in the THREADS=1 run.

[20:34] *** fsergot joined
[20:35] *** MayDaniel left
[20:36] *** Radvendii left
[20:37] *** localhost joined
[20:37] <sorear> colomon: mmm, expose event merging

[20:45] <japhb> nom: my $val := fail "boo"; say "NO BLOCK"; try { ~$val }; say ~$!; say "alive"; say "WITH BLOCK"; { try { ~$val }; say $!; say "alive"; }

[20:45] <p6eval> nom 48b979: OUTPUT«NO BLOCK␤boo␤alive␤WITH BLOCK␤boo␤  in block <anon> at /tmp/TLc4yC1zrZ:1␤  in <anon> at /tmp/TLc4yC1zrZ:1␤»

[20:45] <japhb> ^^ That took me forever to find and golf ...

[20:46] <sorear> uh

[20:46] <sorear> fail does a return implicitly, or it's supposed to anyway

[20:46] <sorear> so nothing after the first statement should be run at all

[20:46] <jnthn> ...how does that not immediately explode?

[20:47] <jnthn> nom: fail

[20:47] <p6eval> nom 48b979:  ( no output )

[20:47] <jnthn> nom: return

[20:47] <p6eval> nom 48b979: OUTPUT«Attempt to return outside of any Routine␤  in block <anon> at /tmp/FTgq6yZYua:1␤  in <anon> at /tmp/FTgq6yZYua:1␤»

[20:47] <moritz> nom: fail; say 1

[20:47] <p6eval> nom 48b979: OUTPUT«1␤»

[20:48] <moritz> nom: my $x = fail; say 1

[20:48] <p6eval> nom 48b979: OUTPUT«1␤»

[20:48] <jnthn> nom: my $x = fail; say $x

[20:48] <p6eval> nom 48b979: OUTPUT«Failure.new()␤»

[20:48] <jnthn>     $return($fail) unless nqp::isnull($return);

[20:48] <jnthn>     $fail

[20:48] <jnthn> argh!

[20:49] <japhb> jnthn, that's not the real problem.

[20:49] <japhb> Because someone *should* be able to do what I did in mainline code.

[20:49] <japhb> The real problem is that, having bound the Failure, try {} acts differently inside and outside the block.

[20:51] *** molaf left
[20:52] <colomon> sorear: hmm, just crashed the program

[20:53] <jnthn> nom: my $val := fail "boo"; say "NO BLOCK"; try { ~$val }; say ~$!; say "alive"; say "NO BLOCK AGAIN"; try { ~$val }; say $!; say "alive";

[20:53] <p6eval> nom 48b979: OUTPUT«NO BLOCK␤boo␤alive␤NO BLOCK AGAIN␤boo␤  in block <anon> at /tmp/gWIstq77lb:1␤  in <anon> at /tmp/gWIstq77lb:1␤»

[20:54] <jnthn> japhb: Not block related, it seems, but using the failure twice.

[20:54] <japhb> jnthn, NICE

[20:54] <japhb> I totally didn't see that.

[20:54] <japhb> (I had golfed it down from something that used it first without a block, and then again inside an if block)

[20:54] *** birdwindupbird joined
[20:55] *** GlitchMr left
[20:55] <jnthn> nom: my $val := fail "boo"; say "NO BLOCK"; try { ~$val }; say $!.WHAT; say "alive"; say "NO BLOCK AGAIN"; try { ~$val }; say $!.WHAT; say "alive";

[20:55] *** birdwindupbird left
[20:55] <p6eval> nom 48b979: OUTPUT«NO BLOCK␤Exception()␤alive␤NO BLOCK AGAIN␤boo␤  in block <anon> at /tmp/q6Ib9GRfPY:1␤  in <anon> at /tmp/q6Ib9GRfPY:1␤»

[20:55] <jnthn> nom: my $val := fail "boo"; say "NO BLOCK"; try { ~$val }; say $!.WHAT; say "alive"; say "NO BLOCK AGAIN"; try { ~$val }; 

[20:55] <p6eval> nom 48b979: OUTPUT«NO BLOCK␤Exception()␤alive␤NO BLOCK AGAIN␤boo␤  in block <anon> at /tmp/fIohgfGtHZ:1␤  in <anon> at /tmp/fIohgfGtHZ:1␤»

[20:55] <japhb> Yeah, the second try {} throws.

[20:56] <jnthn> Well, fails to swallow at least, yeah

[20:56] <jnthn> nom: my $val := fail "boo"; say "NO BLOCK"; try { ~$val }; say $!.WHAT; say "alive"; say "NO BLOCK AGAIN"; try { ~$val; CATCH { say "was here" } }; 

[20:56] <p6eval> nom 48b979: OUTPUT«NO BLOCK␤Exception()␤alive␤NO BLOCK AGAIN␤boo␤  in block <anon> at /tmp/kNvyELZY0L:1␤  in <anon> at /tmp/kNvyELZY0L:1␤»

[20:56] <japhb> jnthn, right, that's what I meant, just poorly said.

[20:57] <jnthn> japhb: Well, but it's weird it doesn't even run that CATCH block.

[20:57] <japhb> nodnod

[20:58] <jnthn> nom: try { die "foo" }; try { die "foo" }; say "alive"

[20:58] <p6eval> nom 48b979: OUTPUT«alive␤»

[20:58] <jnthn> Dang. It's not *that* subtle.

[20:58] <jnthn> er

[20:58] <jnthn> *that* simple

[20:58] <jnthn> It is more subtle. 

[20:59] <japhb> nom: my $val := fail "boo"; try { ~$val }; try { ~$val; };

[20:59] <p6eval> nom 48b979: OUTPUT«boo␤  in block <anon> at /tmp/fQj2rwNxvn:1␤  in <anon> at /tmp/fQj2rwNxvn:1␤»

[20:59] <jnthn> nom: sub foo { fail "boo" }; my $val = foo(); say "NO BLOCK"; try { ~$val }; say $!.WHAT; say "alive"; say "NO BLOCK AGAIN"; try { ~$val; }; 

[20:59] <p6eval> nom 48b979: OUTPUT«NO BLOCK␤Exception()␤alive␤NO BLOCK AGAIN␤boo␤  in sub foo at /tmp/1rcHs8nYL1:1␤  in block <anon> at /tmp/1rcHs8nYL1:1␤  in <anon> at /tmp/1rcHs8nYL1:1␤»

[21:00] <jnthn> OK, so we can reproduce it without needing binding, and with a completely valid use of fail.

[21:00] <japhb> nom: my $val := fail "boo"; try { ~$val }; say "foo"; try { ~$val; };

[21:00] <p6eval> nom 48b979: OUTPUT«foo␤boo␤  in block <anon> at /tmp/fo1Tj9StJq:1␤  in <anon> at /tmp/fo1Tj9StJq:1␤»

[21:00] <jnthn> nom: sub foo { fail "boo" }; my $val = foo(); try { ~$val }; say $!; try { ~$val; }; say $!;

[21:00] <p6eval> nom 48b979: OUTPUT«Exception.new()␤boo␤  in sub foo at /tmp/nhVqWZ2IYL:1␤  in block <anon> at /tmp/nhVqWZ2IYL:1␤  in <anon> at /tmp/nhVqWZ2IYL:1␤»

[21:00] <jnthn> nom: sub foo { fail "boo" }; my $val = foo(); try { ~$val }; say $!; try { ~$val; }; say "alive"

[21:00] <p6eval> nom 48b979: OUTPUT«Exception.new()␤boo␤  in sub foo at /tmp/C_3q6Pt90c:1␤  in block <anon> at /tmp/C_3q6Pt90c:1␤  in <anon> at /tmp/C_3q6Pt90c:1␤»

[21:01] <jnthn> phenny: tell mls_ If you have a moment for an exception-related bug, in the following program the second try fails to catch: sub foo { fail "boo" }; my $val = foo(); try { ~$val }; say $!; try { ~$val; }; say "alive"

[21:01] <phenny> jnthn: I'll pass that on when mls_ is around.

[21:02] <japhb> nom: my $val := fail "boo"; say try { ~$val; 1 }; say try { ~$val; 2 };

[21:02] <p6eval> nom 48b979: OUTPUT«Exception.new()␤boo␤  in block <anon> at /tmp/86UMNrDMiO:1␤  in <anon> at /tmp/86UMNrDMiO:1␤»

[21:02] <jnthn> japhb: mls_++ is the Rakudo exceptions guru, so can probably find this rather faster than I can.

[21:02] <japhb> jnthn, roger that, thanks

[21:04] <japhb> Wait, why does the first part of my last eval say 'Exception.new()' instead of '1'?

[21:05] <jnthn> japhb: Because a try that encounters an exception evaluates to the exception.

[21:05] <jnthn> japhb: The 1 is never reached

[21:05] <japhb> *smack*

[21:05] <japhb> Duh.

[21:05] <japhb> Its not *surpressing*, it's *catching*.

[21:06] <jnthn> Correct

[21:06] * japhb has clearly been looking at the same code far too long.

[21:16] *** fsergot left
[21:22] *** kaare_ left
[21:26] *** araujo joined
[21:26] *** araujo left
[21:26] *** araujo joined
[21:36] *** jimmy1980 left
[21:40] *** kfo joined
[21:41] *** araujo left
[21:42] *** wolfman2000 left
[21:42] *** jimmy1980 joined
[21:45] * djanatyn plays around with roast

[21:46] *** Radvendii joined
[21:47] *** araujo joined
[21:47] *** araujo left
[21:47] *** araujo joined
[21:47] *** araujo left
[21:49] <djanatyn> moritz: *poke*

[21:50] *** fridim_ joined
[21:58] *** fsergot joined
[22:01] *** Radvendii left
[22:02] *** Moukeddar joined
[22:02] *** Radvendii joined
[22:04] <Moukeddar> can someone please explain why ListDictionary is so slow?

[22:04] <tadzik> what is ListDictionary?

[22:04] <Moukeddar> oops, wrong window, my bad

[22:05] <lichtkind> tadzik: souds like a list that emulates a fixed hash

[22:05] <Moukeddar> a collection in .NET

[22:05] <tadzik> wild guess: it has an O(n) lookup?

[22:06] <Moukeddar> not sure about O(n), but it's pretty slow

[22:06] <Moukeddar> really reall slow

[22:06] <Moukeddar> really*

[22:07] <benabik>  Item, Add, Remove, Contains are all O(n).  It's supposed to have "fasted keyed retrieval"

[22:07] <tadzik> logarithmic I guess

[22:09] *** toebu left
[22:11] <Moukeddar> got it, yes it's O(n)

[22:15] *** risou_awy is now known as risou

[22:17] <flussence> I've seen some of the code in PHP's associative arrays; all I can say is that it's definitely not optimised for large data structures...

[22:23] <sorear> Moukeddar: ListDictionary is horribly slow.  It just is.  I think it was designed by someone who doesn't know assembly, doesn't use profilers, or both.

[22:24] <Moukeddar> the thing that baffles me, why it got shipped with other collections, i find it quite useless

[22:24] <benabik> The docs say it's designed for small collections.  Perhaps more space efficient that other dictionaries, but (nearly) as fast?

[22:25] <sorear> Moukeddar: I recommend you steal the hybrid dictionary I implemented for Niecza,     say $args.Event.Area.Y;

[22:25] <sorear>     say $args.Event.Area.Height;

[22:25] <sorear> what the?

[22:25] <sorear> https://github.com/sorear/niecza/blob/master/lib/Utils.cs#L153

[22:25] <Moukeddar> ok, a sec

[22:25] <sorear> I select text in one window, middle click in another, and it pastes something I deleted in vim hours ago

[22:26] <benabik> Not all apps deal with the Selection clipboard, only the pasteboard.

[22:27] <Moukeddar> hmm, seems that they already shipped a HybridDictionary, which converts to a hashtable when reaching a specific size

[22:27] *** ggoebel joined
[22:28] <flussence> (I've found chromium loses an URL bar selection 95% of the time I try to use it. Really annoying.)

[22:28] <sorear> Moukeddar: yes, and it's even slower than ListDictionary

[22:29] <Moukeddar> lol, don't know which to use anymore 

[22:29] <diakopter> why not List<>

[22:30] <sorear> Moukeddar: use Dictionary<,>

[22:30] <Moukeddar> yeah, i guess Dictionary<,> is the safe ground 

[22:30] <sorear> Moukeddar: if you have to store 250,000 dictionaries, most of which have 0-1 element, use VarHash

[22:33] <Moukeddar> sweet

[22:36] *** dorlamm joined
[22:40] <tadzik> Tests=19975

[22:40] <tadzik> woooo, when did we get there?

[22:40] *** wolfman2000 joined
[22:40] <tadzik> btw, I get Failed tests:  4-6, 11-13 in t/spec/S05-mass/properties-general.rakudo

[22:41] *** araujo joined
[22:41] *** araujo left
[22:41] *** araujo joined
[22:48] *** am0c left
[22:50] *** mugenken left
[22:51] *** Moukeddar left
[22:52] *** mj41 left
[22:55] *** tokuhirom joined
[23:01] *** risou is now known as risou_awy

[23:02] *** PacoLinux left
[23:05] *** ksi left
[23:10] *** jeffreykegler joined
[23:21] *** fridim_ left
[23:26] *** patspam joined
[23:31] <jnthn> tadzik: wow, should break 20k soon :)

[23:31] <tadzik> aye

[23:31] <tadzik> almost ng :)

[23:32] <jnthn> What did that peak at?

[23:33] <tadzik> 21-something I believe

[23:36] *** cooper joined
[23:40] *** patspam left
[23:41] *** patspam1 joined
[23:41] <lue> hello world o/

[23:42] <tadzik> hello lue 

[23:42] *** patspam1 left
[23:42] *** patspam joined
[23:43] *** toebu joined
[23:44] *** patspam left
[23:44] *** jaldhar left
[23:49] *** patspam joined
[23:51] *** dorlamm left
[23:57] <dalek> roast: 7127a14 | tadzik++ | S02-lexical-conventions/comments.t:

[23:57] <dalek> roast: Fix Pod in S02-lexical-conventions/comments.t

[23:57] <dalek> roast: 

[23:57] <dalek> roast: Per S26, content is not allowed in the same line with a paragraph block

[23:57] <dalek> roast: declaration. Use abbreviated blocks instead.

[23:57] <dalek> roast: review: https://github.com/perl6/roast/commit/7127a14ea6

[23:57] <tadzik> g'night #perl6

