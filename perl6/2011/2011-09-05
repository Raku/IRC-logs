[00:02] *** dudley5000 joined
[00:03] *** dudley5000 left
[00:11] *** risou is now known as risou_awy

[00:18] *** donri left
[00:19] *** donri joined
[00:35] <soh_cah_toa> perl6: #={ I'm a declarator block for $foo } my $foo; say $foo.WHY

[00:35] <p6eval> niecza v9-9-gd637b5c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method comment:sym<#=(...)> not yet implemented at /tmp/ImrmJki0I8 line 1:‚ê§------> [32m#={ I'm a declarator block for $foo }[33m‚èè[31m my $foo; say $foo.WHY[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/ni‚Ä¶

[00:35] <p6eval> ..pugs, rakudo 3654b0:  ( no output )

[00:35] <soh_cah_toa> nom: #={ I'm a declarator block for $foo } my $foo; say $foo.WHY

[00:36] <soh_cah_toa> aw man, i like declarator blocks :\

[00:38] *** whiteknight joined
[00:38] <sorear> soh_cah_toa: spelled "rakudo:" now

[00:38] <soh_cah_toa> rakudo: #={ I'm a declarator block for $foo } my $foo; say $foo.WHY

[00:38] <p6eval> rakudo 3654b0:  ( no output )

[00:39] <soh_cah_toa> :(

[00:49] *** plobsing joined
[00:54] <sorear> soh_cah_toa: #= is a line comment now.

[00:55] <sorear> also I think it's spelled #|.

[00:55] *** abercrombie joined
[00:56] <soh_cah_toa> well, that's just what's implemented atm right? the spec mentions multi-line ones as well

[00:58] <sorear> soh_cah_toa: the spec is lagging the implementation here.

[00:58] <sorear> talk to tadzik, ey knows the state of the arg

[00:59] <TimToady> a block form might be allowed, but you'd need to use #|{} to put it in front

[00:59] <soh_cah_toa> ok

[01:12] *** REPLeffect left
[01:12] *** woosley joined
[01:17] *** drbean left
[01:26] *** REPLeffect joined
[01:26] *** plobsing left
[01:28] *** jevin left
[01:29] *** jevin joined
[01:41] *** daniel-s joined
[02:02] *** sdadawdaw joined
[02:04] *** sdadawdaw is now known as BosSkurt

[02:04] *** BosSkurt left
[02:04] *** BosSkurt joined
[02:04] *** BosSkurt left
[02:04] *** BosSkurt joined
[02:05] *** BosSkurt left
[02:13] *** uvtc joined
[02:14] <uvtc> rakudo: my @a = <y z x b c a y z x>; @a.=sort.uniq; say @a

[02:14] <p6eval> rakudo 3654b0: OUTPUT¬´Method 'uniq' not found for invocant of class 'Array'‚ê§  in <anon> at /tmp/lRGf8vsKdz:1‚ê§  in <anon> at /tmp/lRGf8vsKdz:1‚ê§‚ê§¬ª

[02:15] <uvtc> rakudo: my @a = <y z x b c a y z x>; @a .= sort.uniq; say @a

[02:15] <p6eval> rakudo 3654b0: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "@a .= sort"‚ê§¬ª

[02:15] <uvtc> rakudo: my @a = <y z x b c a y z x>; @a = @a.sort.uniq; say @a

[02:15] <p6eval> rakudo 3654b0: OUTPUT¬´Method 'uniq' not found for invocant of class 'Parcel'‚ê§  in <anon> at /tmp/lb3R4E565O:1‚ê§  in <anon> at /tmp/lb3R4E565O:1‚ê§‚ê§¬ª

[02:16] <uvtc> Hm. On my own R* 2011.07, `@a.=sort.uniq` works, but `@a .= sort.uniq` (with spaces around ".=") fails.

[02:17] <uvtc> nom: my @a = <y z x b c a y z x>; @a = @a.sort.uniq; say "@a";

[02:18] <TimToady> neither of those is the same as the = one, since you don't have .= on the uniq

[02:18] <sorear> uvtc: rakudo: is not R*

[02:18] <uvtc> sorear: right, but I've only got R* 2011.07 installed atm.

[02:19] <TimToady> but yes, it should be a little more dwimy

[02:19] <uvtc> TimToady: is `@a.=@a.foo` the same as `@a = @a.foo`?

[02:19] <uvtc> TimToady: oops. I meant `@a.=foo`.

[02:20] <uvtc> rakudo: my @a = <y z x b c a y z x>; @a = @a.sort.uniq; say "@a";

[02:20] <p6eval> rakudo 3654b0: OUTPUT¬´Method 'uniq' not found for invocant of class 'Parcel'‚ê§  in <anon> at /tmp/mCbkmaKpjj:1‚ê§  in <anon> at /tmp/mCbkmaKpjj:1‚ê§‚ê§¬ª

[02:21] <soh_cah_toa> uvtc: yes, the .= invocation is mutating while . is non-mutating

[02:22] <uvtc> Then my next question then is (and what I was driving at in the first place): should `@a.=foo` be the same as `@a .= foo`? (spaces around ".=")

[02:22] <uvtc> ^ s/then//

[02:23] <TimToady> the latter is sugar for the former

[02:25] <TimToady> it does not really make sense for the precedence of .= to vary depending on whether there are spaces

[02:25] <uvtc> `@a .= foo` is sugar for `@a.=foo`?

[02:25] <TimToady> as currently defined

[02:26] <uvtc> Ok. Thank you.

[02:26] <TimToady> the only way to write what you wanted earlier was .=sort.=uniq

[02:26] <TimToady> note the = on the uniq too

[02:27] <uvtc> rakudo: my @a = <y z x b c a>; @a.=sort; say "@a";

[02:27] <p6eval> rakudo 3654b0: OUTPUT¬´@a‚ê§¬ª

[02:27] <uvtc> rakudo: my @a = <y z x b c a>; @a.=sort; say "@a{}";

[02:27] <p6eval> rakudo 3654b0: OUTPUT¬´a b c x y z‚ê§¬ª

[02:27] <uvtc> rakudo: my @a = <y z x b c a>; @a .= sort; say "@a{}";

[02:27] <p6eval> rakudo 3654b0: OUTPUT¬´a b c x y z‚ê§¬ª

[02:27] <uvtc> Good.

[02:29] *** whiteknight left
[02:30] <uvtc> TimToady: I don't understand why you say that " .= " is sugar for ".="... Isn't "$foo op= $bar" always "$foo = $foo op $bar" regardless of spaces?

[02:31] <TimToady> .= exists by analogy to that, but you can't actually say $foo . $bar

[02:31] <TimToady> std: $foo . $bar

[02:31] <p6eval> std e3c970e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $foo is not predeclared at /tmp/_XuDco3T0G line 1:‚ê§------> [32m$foo[33m‚èè[31m . $bar[0m‚ê§Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/_XuDco3T0G line 1:‚ê§------> [32m$foo . [33m‚èè[31m$bar[0m‚ê§P‚Ä¶

[02:32] <uvtc> Oh, of course. Thanks. :)

[02:32] <uvtc> Just a little extra pixie dust to save you from having to write the array name twice.

[02:33] <TimToady> it's mostly there for .= new()

[02:35] <uvtc> Ok -- to save you from writing the classname twice (ex. `my Foobar $f = Foobar.new()` vs. `my Foobar $f .= new()`).

[02:37] *** uasi joined
[02:48] *** uvtc left
[02:52] *** agentzh joined
[02:59] *** drbean joined
[03:07] *** donri left
[03:21] *** beppu left
[03:26] *** Su-Shee left
[03:28] *** Su-Shee joined
[03:37] *** jevin left
[03:37] *** jevin joined
[03:38] *** daniel-s_ joined
[03:38] *** daniel-s left
[04:04] *** birdwindupbird joined
[04:12] *** kaare_ joined
[04:16] *** colomon_ joined
[04:16] *** colomon left
[04:16] *** colomon_ is now known as colomon

[04:18] *** puppyuser joined
[04:18] *** birdwindupbird left
[04:18] *** birdwindupbird joined
[04:24] *** jamtech joined
[04:25] *** dark_x joined
[04:32] *** odoacre joined
[04:36] *** abercrombie left
[04:39] *** soh_cah_toa left
[04:40] *** plobsing joined
[04:41] *** y3llow left
[04:41] *** pothos left
[04:41] *** y3llow_ joined
[04:41] *** pothos_ joined
[04:42] *** pothos_ is now known as pothos

[04:43] *** puppyuser left
[04:43] *** y3llow_ is now known as y3llow

[05:10] *** sftp left
[05:18] *** jamtech left
[05:20] *** dark_x left
[05:22] *** molaf joined
[05:41] *** koban` joined
[05:41] *** koban` left
[05:49] <dalek> niecza: 678102e | sorear++ | lib/ (3 files):

[05:49] <dalek> niecza: Draft of P6->CLR coercion routines

[05:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/678102eed0

[05:53] *** natureboy left
[05:58] *** jevin left
[05:59] *** jevin joined
[06:01] *** satyavvd joined
[06:01] *** MayDaniel joined
[06:02] *** molaf left
[06:03] *** plobsing left
[06:04] *** REPLeffect left
[06:06] *** plobsing joined
[06:06] *** MayDaniel left
[06:14] * sorear out

[06:17] *** c1sung joined
[06:19] *** REPLeffect joined
[06:38] *** wtw joined
[06:45] *** c1sung left
[06:56] *** wamba joined
[07:01] *** frhodes joined
[07:16] <TiMBuS> self.bless(*, |%args)!initialize()

[07:16] <TiMBuS> ooOoo

[07:16] <TiMBuS> thats nifty, whoever did that

[07:18] <TiMBuS> on the other hand, it makes me feel like we left something out of the perl6 OO model, if we need to resort to that to init a class

[07:20] <PerlJam> TiMBuS: but you don't.

[07:21] <TiMBuS> well yeah, submethod BUILD can do the initialization

[07:21] <TiMBuS> but then why did someone change my code to specifically not use it? does nom not have BUILD

[07:25] <PerlJam> pretty sure you're talking about a bug right now.

[07:26] <PerlJam> Where did you see the line of code you mentioned above?

[07:39] *** wamba left
[07:48] <jnthn> morning, #perl6

[07:48] <moritz> morning everybody

[07:48] *** Siddy left
[07:51] <tadzik> good morning

[07:52] *** Siddy joined
[07:56] *** wamba joined
[08:00] *** daxim joined
[08:00] <mberends> good morning all

[08:13] *** thou left
[08:19] *** wamba left
[08:20] *** Siddy is now known as Trashlord

[08:21] *** wamba joined
[08:22] *** colomon left
[08:22] <TiMBuS> sorry PerlJam, had a phone call

[08:23] <TiMBuS> I'm talking about IO::Socket::INET in nom

[08:30] <tadzik> I'm pretty sure nom has BUILD, maybe it didn't when someone was moving the code to nom

[08:32] *** wamba left
[08:39] *** sentinel_ joined
[08:43] *** wamba joined
[08:47] *** lumi_ left
[08:49] *** agentzh left
[09:01] *** drbean left
[09:11] *** orafu left
[09:11] *** orafu joined
[09:13] *** domidumont left
[09:23] *** domidumont joined
[09:24] *** SHODAN joined
[09:30] *** uniejo left
[09:43] *** woosley left
[09:45] *** sentinel_ left
[09:56] *** wamba left
[10:35] *** whiteknight joined
[10:46] *** envi_laptop joined
[10:54] *** hatseflats left
[10:55] *** hatseflats joined
[10:57] *** hatseflats left
[10:59] <felher> Hm, so '$x .= foo.bar' is the same as '($x = $x.foo).bar' while '$x -= 3 - 3' is '$x = $x - (3-3)' and not '($x = $x - 3) -3'. Why's that? At a first glance '$x .= foo.bar' isn't very DWIM to me. I really thought it be the same as '$x = $x.foo.bar'. Am i forgetting something and its actually consistent?

[11:09] <flussence> if it were foo.bar, then $x.=foo + 3 probably wouldn't DWYM either

[11:13] <jnthn> iirc, .= forces the parser to immediately parse a methodop after it

[11:13] <jnthn> Which only swallows the foo

[11:15] *** daniel-s_ is now known as daniel-s

[11:16] *** colomon joined
[11:17] <flussence> ooh, I just had a (probably terrible) idea, a HTML tag object where .Str is well-formed XML and .gist is well-formed HTML

[11:17] <tadzik> tee hee

[11:23] *** lumi_ joined
[11:25] *** PZt joined
[11:38] *** JimmyZ joined
[11:48] <moritz> some of you might remember http://perlgeek.de/blog-en/perl-6/how-fast-is-nom.writeback

[11:48] *** ruoso left
[11:49] <moritz> I just timed it again, this time it was roughly 2 minutes

[11:49] *** ruoso joined
[11:49] <flussence> whoa

[11:50] <tadzik> nicey

[11:50] <mls> hello perl6!

[11:51] * JimmyZ hopes that will be 2 seconds  :)

[11:51] <mls> whoa, jnthn++ has been really busy this weekend! jnthn++

[11:51] <jnthn> mls: nice :)

[11:51] <jnthn> er, moritz I meant :)

[11:51] <jnthn> Well, mls++ did provide a nice patch too ;)

[11:52] <mls> I must run valgrind again to see if the 20% rakudo spent in find_method is gone...

[11:52] <moritz> (this timing has been on top of parrot master with whiteknight++'s execellent branch merged into it)

[11:52] <moritz> this combination also passes all spectests, fwiw

[11:53] <jnthn> mls: Highly likely.

[11:54] <jnthn> mls: New boolification protocol + massive method cache miss reduction should have helped with that.

[11:54] *** cognominal left
[11:54] <mls> sounds awesome!

[11:54] *** cognominal joined
[11:59] <moritz> rakudo: run('echo $$')

[11:59] <p6eval> rakudo 3654b0: OUTPUT¬´32145‚ê§¬ª

[12:00] <JimmyZ> rakudo: run('!!');

[12:00] <p6eval> rakudo 3654b0: OUTPUT¬´sh: !!: not found‚ê§¬ª

[12:00] <moritz> it seems that rakudo's run() is what S29 now specifies to be called shell()

[12:03] * JimmyZ suggests add an invert method to Array, returns a Hash

[12:04] <JimmyZ> TimToady: ^^

[12:05] <tadzik> hmm

[12:05] <tadzik> b: say <a b c>.kv.hash.invert.perl

[12:05] <p6eval> b 1b7dd1: OUTPUT¬´("a" => "0", "b" => "1", "c" => "2")‚ê§¬ª

[12:05] <moritz> JimmyZ: there's a reason that Hash.invert returns a List, not a Hash

[12:06] <moritz> b: say <a b c>.kv>>.invert.perl

[12:06] <p6eval> b 1b7dd1: OUTPUT¬´Method 'invert' not found for invocant of class 'Int'‚ê§  in main program body at line 22:/tmp/XZ3XaCwElw‚ê§¬ª

[12:06] <moritz> b: say <a b c>.kv>>.inveret.perl

[12:06] <p6eval> b 1b7dd1: OUTPUT¬´Method 'inveret' not found for invocant of class 'Int'‚ê§  in main program body at line 22:/tmp/PvuNVIN3V1‚ê§¬ª

[12:06] <moritz> argl

[12:08] <JimmyZ> moritz: I want invert key  &&  value

[12:08] *** satyavvd left
[12:08] <moritz> JimmyZ: yes, but returning a Hash is wrong

[12:09] <JimmyZ> what is better?

[12:09] <tadzik> returning a list :)

[12:09] <moritz> JimmyZ: because that way you lose information when there are duplicate values

[12:09] <moritz> JimmyZ: but  @list Z=> @list.keys  isn't too complicated either

[12:12] <mls> hmm, I must reduce the profiler overhead, it influences the 'ticks' result too much

[12:13] <mls> pmichaud++ complained that the profiler said that lineof is 20% of the execution time (for ng)

[12:14] <mls> but reducing lineof to a simple ".return 0" only saves 6 of 120 seconds, that's 5% instead of 20%

[12:16] <mls> I think it's because lineof execution consists of many many parrot ops, so the profiling overhead per op matters

[12:16] <mls> I.e. the *profiling* run really is 20% faster with the dummy lineof(), just not the normal run

[12:17] <moritz> a classical profiler problem

[12:18] <JimmyZ> moritz: losing information is expected

[12:18] <moritz> JimmyZ: by whom?

[12:18] <tadzik> uhh

[12:18] <tadzik> ww

[12:19] <JimmyZ> moritz: whoever use array.invert :)

[12:19] <moritz> JimmyZ: we didn't make that assuption for Hash.invert

[12:22] <JimmyZ> moritz: return List wfm too

[12:24] <JimmyZ> moritz: there is a invert method for hash, it's not bad that there is a  invert method for array 

[12:25] <moritz> JimmyZ: I generally agree, just don't know if it's used often enough to warrant inclusion

[12:25] <felher> flussence: well, before today i expected '$x .= foo + 3' to be '$x = $x.foo + 3'. It's just that i didn't expect that you can write someting on the right-hand-side of the 'x=' that doesn't affect the left-hand-side because of the low precedence of '='. I think i really need to study the spec on 'x=' again. :)

[12:25] <moritz> ie I like the idea

[12:26] <JimmyZ> moritz: I always invert a array :)

[12:28] <JimmyZ> moritz: I use http://cn.php.net/manual/en/function.array-flip.php, which invert a array, hehe

[12:29] <moritz> JimmyZ: I'm curious, could you name a few use cases?

[12:31] <moritz> another way to write it is  my %h; %h{@list.keys} = @list  # JFYI

[12:31] <tadzik> oh, clever one

[12:32] <moritz> I think that's how I usually do it in p5, but I do it so seldom I wonder why others use it often

[12:32] <moritz> (the p5 variant is $h{0..$#list} = @list, fwiw)

[12:33] <moritz> though for Perl 6 is Like the  @list.keys Z=> @list  version better

[12:33] <JimmyZ> moritz: when search a value if it's in a small array and I don't want to write a loop, with a  invert , I just write %h = @array.invert; if %h<value> {  ...  }

[12:34] <mls> Some profiler changes brought lineof() down to 8% instead of 5%. I can live with that ;)

[12:34] <moritz> ... and fail for the first array item?

[12:35] <moritz> in Perl 6, you'd say   if 'value' eq any(@array) { ... }   instead

[12:35] * JimmyZ forgot that one :(

[12:35] <JimmyZ> moritz++

[12:38] <JimmyZ> rakudo: my @list = <a b c d>; my %h; %h{@list} = @list.keys; say %h.perl; 

[12:38] <p6eval> rakudo 3654b0: OUTPUT¬´("a" => 0, "b" => 1, "c" => 2, "d" => 3).hash‚ê§¬ª

[12:42] *** jerome_ left
[12:45] *** JimmyZ_ joined
[12:45] *** jerome_ joined
[12:48] *** JimmyZ left
[12:48] *** JimmyZ_ is now known as JimmyZ

[12:48] <JimmyZ> rakudo: my @a = 1,2,34, hash(@a).say

[12:48] <p6eval> rakudo 3654b0: OUTPUT¬´().hash‚ê§¬ª

[12:53] <moritz> that looks wrongish

[12:54] <JimmyZ> rakudo: my @a = 1,2,34; my %h = 1 => 'b', 5 => 'd'; sub hasssh(*@a, *%h) { my %b = @a, %h; }; hasssh(@a,%h).say

[12:54] <p6eval> rakudo 3654b0: OUTPUT¬´("1" => 2, "34" => "1" => "b", "5" => "d").hash‚ê§¬ª

[12:54] <JimmyZ> rakudo: my @a = 1,2,34; my %h = 1 => 'b', 5 => 'd'; sub hasssh(*@a, *%h) { my % = @a, %h; }; hasssh(@a,%h).say # 

[12:54] <p6eval> rakudo 3654b0: OUTPUT¬´("1" => 2, "34" => "1" => "b", "5" => "d").hash‚ê§¬ª

[12:55] <moritz> rakudo: say hash(1, 2, 3).perl

[12:55] <p6eval> rakudo 3654b0: OUTPUT¬´Odd number of elements found where hash expected‚ê§  in method STORE at src/gen/CORE.setting:4427‚ê§  in sub hash at src/gen/CORE.setting:4486‚ê§  in sub hash at src/gen/CORE.setting:4487‚ê§  in <anon> at /tmp/hxsZZprAiO:1‚ê§  in <anon> at /tmp/hxsZZprAiO:1‚ê§‚ê§¬ª

[12:55] <moritz> rakudo: say hash(1, 2, 3, 4).perl

[12:55] <p6eval> rakudo 3654b0: OUTPUT¬´("1" => 2, "3" => 4).hash‚ê§¬ª

[12:55] <moritz> rakudo: say hash(ny @ = 1, 2, 3, 4).perl

[12:55] <p6eval> rakudo 3654b0: OUTPUT¬´===SORRY!===‚ê§Non-declarative sigil is missing its name at line 1, near "@ = 1, 2, "‚ê§¬ª

[12:55] <moritz> rakudo: say hash(ny @a = 1, 2, 3, 4).perl

[12:55] <p6eval> rakudo 3654b0: OUTPUT¬´===SORRY!===‚ê§Symbol '@a' not predeclared in <anonymous> (/tmp/TWl4NJCf9K:1)‚ê§¬ª

[12:55] <moritz> huh? I'm declaring it right there!

[12:56] <moritz> rakudo: say hash(ny @a = (1, 2, 3, 4)).perl

[12:56] <p6eval> rakudo 3654b0: OUTPUT¬´===SORRY!===‚ê§Symbol '@a' not predeclared in <anonymous> (/tmp/8IWukZ873b:1)‚ê§¬ª

[12:56] <moritz> b: say hash(ny @a = (1, 2, 3, 4)).perl

[12:56] <JimmyZ> rakudo: my @a = 1,2,34; my %h = 1 => 'b', 5 => 'd'; hash(@a,%h).say 

[12:56] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Symbol '@a' not predeclared in <anonymous> (/tmp/nQ_YvZ_fb6:22)‚ê§¬ª

[12:56] <p6eval> rakudo 3654b0: OUTPUT¬´("1" => 2, "34" => "1" => "b", "5" => "d").hash‚ê§¬ª

[12:57] <JimmyZ> rakudo: my @a = 1,2,34; my %h; hash(@a,%h).say 

[12:57] <p6eval> rakudo 3654b0: OUTPUT¬´Odd number of elements found where hash expected‚ê§  in method STORE at src/gen/CORE.setting:4427‚ê§  in sub hash at src/gen/CORE.setting:4486‚ê§  in sub hash at src/gen/CORE.setting:4487‚ê§  in <anon> at /tmp/G4r35PDeMe:1‚ê§  in <anon> at /tmp/G4r35PDeMe:1‚ê§‚ê§¬ª

[12:58] <jnthn> moritz: ny :)

[12:58] <moritz> ny?

[12:58] * moritz confused

[12:58] <jnthn> you typed ny instead of my :)

[12:58] <moritz> oh.

[12:58] <moritz> b: say hash(my @a = (1, 2, 3, 4)).perl

[12:58] <p6eval> b 1b7dd1: OUTPUT¬´{"1" => 2, "3" => 4}‚ê§¬ª

[12:58] <moritz> b: say hash(my @a = 1, 2, 3, 4).perl

[12:59] <p6eval> b 1b7dd1: OUTPUT¬´{"1" => 2, "3" => 4}‚ê§¬ª

[12:59] <moritz> rakudo: say hash(my @a = 1, 2, 3, 4).perl

[12:59] <p6eval> rakudo 3654b0: OUTPUT¬´("1" => 2, "3" => 4).hash‚ê§¬ª

[13:02] <JimmyZ> rakudo: my @a = 1,2,34, 5 ; hash(@a).say 

[13:02] <p6eval> rakudo 3654b0: OUTPUT¬´("1" => 2, "34" => 5).hash‚ê§¬ª

[13:02] <JimmyZ> rakudo: my @a = 1,2,34 ; hash(@a).say 

[13:02] <p6eval> rakudo 3654b0: OUTPUT¬´Odd number of elements found where hash expected‚ê§  in method STORE at src/gen/CORE.setting:4427‚ê§  in sub hash at src/gen/CORE.setting:4486‚ê§  in sub hash at src/gen/CORE.setting:4487‚ê§  in <anon> at /tmp/MN3VN9kDaB:1‚ê§  in <anon> at /tmp/MN3VN9kDaB:1‚ê§‚ê§¬ª

[13:04] *** woosley joined
[13:12] *** colomon left
[13:19] *** abercrombie joined
[13:19] *** woosley left
[13:30] *** benabik left
[13:32] *** bluescreen10 joined
[13:32] *** colomon joined
[13:33] *** colomon left
[13:39] *** PacoLinux_ joined
[13:44] *** pmurias joined
[13:46] *** JimmyZ_ joined
[13:47] *** SHODAN left
[13:49] *** pmurias left
[13:50] *** JimmyZ left
[13:50] *** JimmyZ_ is now known as JimmyZ

[13:56] *** Reaganomicon joined
[14:12] <dalek> rakudo/nom: f34aa80 | moritz++ | src/core/control.pm:

[14:12] <dalek> rakudo/nom: rename &run to &shell

[14:12] <dalek> rakudo/nom: 

[14:12] <dalek> rakudo/nom: It should have been that way for quite some time, according to the spec.

[14:12] <dalek> rakudo/nom: Add a stub &run to ease the transition

[14:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f34aa80db0

[14:12] <dalek> roast: ab15f81 | moritz++ | S32-trig/pi.t:

[14:12] <dalek> roast: simplify pi.t

[14:12] <dalek> roast: review: https://github.com/perl6/roast/commit/ab15f818b7

[14:12] <dalek> roast: 143c569 | moritz++ | / (2 files):

[14:12] <dalek> roast: track spec change: &run -> &shell

[14:12] <dalek> roast: review: https://github.com/perl6/roast/commit/143c569581

[14:17] *** wtw left
[14:18] *** donri joined
[14:21] *** amil joined
[14:25] <mls> find_method is down from 20% to 2.01%. Good job, jnthn++

[14:26] *** woosley joined
[14:26] <tadzik> nice

[14:26] <tadzik> what's up?

[14:26] <tadzik> I mean, you know... ;)

[14:27] *** drbean joined
[14:27] <mls> the "top" function is stll get_new_pmc_header. 27%

[14:27] <mls> still

[14:28] <moritz> so we're creating too many objects, right? :-)

[14:28] *** risou_awy is now known as risou

[14:28] <mls> right. Note that a function call needs at least two PMCs

[14:28] <mls> one for the continuation, and one for the args

[14:28] <moritz> so, we call too many functions too :(

[14:29] <mls> maybe

[14:30] <mls> Parrot_Sub_invoke: 20%

[14:30] <JimmyZ> oh, that's 47% 

[14:31] <moritz> though not all new PMCs come from Parrot_Sub_invoke, right?

[14:31] <mls> don't add them. the 20% and 27% include the cost of the called function

[14:32] <mls> invoke calls get_new_pmc_header when it allocates the continuation

[14:32] <mls> moritz: about 50%

[14:33] <mls> invoke->pmc_new 13.78%, all pmc_new calls: 27.26%

[14:35] *** cognominal_ joined
[14:35] <mls> SixModelObject_get_bool: 5.44%. Is that good or bad?

[14:36] * JimmyZ is not sure

[14:37] <mls> (It's actually 7.4% instead of 5.44%)

[14:38] *** cognominal left
[14:38] <mls> seen jnthn

[14:38] <aloha> jnthn was last seen in #perl6 1 hours 39 mins ago saying "you typed ny instead of my :)".

[14:42] <mls> jnthn: seems like we still have many BOOL_MODE_CALL_METHOD usages. Expected?

[14:44] <sorear> good * #perl6

[14:44] <mls> o/

[14:44] * sorear wonders if BOOL_MODE is based on Niecza's vtable system

[14:48] <jnthn> Note that get_new_pmc_header almost certainly includes the time we spend running GC as well as the time we spend allocating.

[14:48] <jnthn> sorear: no

[14:48] <jnthn> sorear: Though if we came up with something similar that's maybe reassuring ;)

[14:49] <jnthn> mls: Not entirely unexpected. I've a further optimization to do there, and after that if there's still a lot it'd be interesting to know where they're coming from.

[14:49] <mls> jnthn: from the 18.1% of gc_gms_allocate_pmc_header, 13.93% are spent in GC

[14:50] <jnthn> mls: ok, that's still a fair amount in allocation.

[14:51] <jnthn> moritz: yes, we certainly call too many things...that's why we need an inliner. :)

[14:53] *** uasi left
[14:53] *** uasi joined
[14:57] *** uasi left
[14:59] *** [Coke] left
[15:00] *** [Coke] joined
[15:02] *** daniel-s left
[15:02] *** daniel-s joined
[15:05] *** thou joined
[15:06] *** birdwindupbird left
[15:06] *** im2ee joined
[15:07] <im2ee> Hi! :)

[15:09] <tadzik> hi inliner :)

[15:12] <abercrombie> Hi #perl6, how to set the file pointer to the beginning of the file?

[15:13] <mux> use seek(FILEHANDLE, 0, SEEK_SET)

[15:13] <mux> oh, perl6 might have changed this though.

[15:14] <tadzik> I suppose it did. The only thing on the top of my head is "close and open"

[15:14] <tadzik> I'm sure there's a better way though

[15:14] <abercrombie> Yes, right now I am using close and open. But I think it's better if I can reset the file pointer

[15:14] *** molaf joined
[15:16] *** thou left
[15:36] *** woosley left
[15:38] *** benabik joined
[15:44] *** phenny left
[15:44] *** phenny joined
[15:48] <abercrombie> niecza: my $a='abc'; if $a ~~ s/(.*)b(.*)/$0$1/ {say $a}

[15:48] <p6eval> niecza v9-10-g678102e: OUTPUT¬´ac‚ê§¬ª

[15:48] <abercrombie>  rakudo: my $a='abc'; if $a ~~ s/(.*)b(.*)/$0$1/ {say $a}

[15:48] <p6eval> rakudo f34aa8: OUTPUT¬´abc‚ê§¬ª

[15:48] <abercrombie> How to do it in rakudo?

[15:49] <sorear> huh

[15:49] <tadzik> b: my $a='abc'; if $a ~~ s/(.*)b(.*)/$0$1/ {say $a}

[15:49] <p6eval> b 1b7dd1: OUTPUT¬´Any()Any()‚ê§¬ª

[15:49] <tadzik> pff

[15:50] <TimToady> rakudo: my $a='abc'; if $a.subst(/(.*)b(.*)/, -> $/ { "$0$1" }) { say $a }

[15:50] <p6eval> rakudo f34aa8: OUTPUT¬´abc‚ê§¬ª

[15:50] <TimToady> hmm

[15:50] <TimToady> b: my $a='abc'; if $a.subst(/(.*)b(.*)/, -> $/ { "$0$1" }) { say $a }

[15:50] <p6eval> b 1b7dd1: OUTPUT¬´abc‚ê§¬ª

[15:50] <TimToady> double hmm

[15:51] <jnthn> o.O

[15:51] <TimToady> b: my $a='abc'; if $a.subst(/(.*)b(.*)/, -> $/ { say $0; say $1; "$0$1" }) { say $a }

[15:51] <p6eval> b 1b7dd1: OUTPUT¬´a‚ê§c‚ê§abc‚ê§¬ª

[15:51] <jnthn> oh, .subst won't mutate $a

[15:51] <TimToady> duh

[15:52] * jnthn hands TimToady another coffee :)

[15:52] <TimToady> b: my $a='abc'; if $a.=subst(/(.*)b(.*)/, -> $/ { "$0$1" }) { say $a }

[15:52] <p6eval> b 1b7dd1: OUTPUT¬´ac‚ê§¬ª

[15:52] <sorear> niecza has $a.subst(PAT, SUBST, :inplace) for this

[15:52] <TimToady> rakudo: my $a='abc'; if $a.=subst(/(.*)b(.*)/, -> $/ { "$0$1" }) { say $a }

[15:52] <p6eval> rakudo f34aa8: OUTPUT¬´abc‚ê§¬ª

[15:52] <TimToady> bug

[15:53] <jnthn> indeed.

[15:53] * TimToady hands pmichaud a DP

[15:53] <sorear> DP?

[15:53] <jnthn> rakudo: my $a='abc'; $a.match(/(.*)b(.*)/).perl.say

[15:53] <p6eval> rakudo f34aa8: OUTPUT¬´‚ê§¬ª

[15:53] <jnthn> rakudo: my $a='abc'; $a.match(/(.*)b(.*)/).say

[15:53] <p6eval> rakudo f34aa8: OUTPUT¬´‚ê§¬ª

[15:53] <TimToady> Dr Pepper

[15:53] <jnthn> rakudo: my $a='abc'; say ?$a.match(/(.*)b(.*)/)

[15:54] <p6eval> rakudo f34aa8: OUTPUT¬´Bool::False‚ê§¬ª

[15:54] <jnthn> rakudo: my $a='abc'; say ?$a.match(/(.*?)b(.*?)/)

[15:54] <p6eval> rakudo f34aa8: OUTPUT¬´Bool::True‚ê§¬ª

[15:54] <abercrombie> jnthn: I know subst won't mutate the original string. How about s/// form in perl6?

[15:54] <jnthn> Backtracking FAIL

[15:54] <jnthn> abercrombie: s/// mutates.

[15:54] *** benabik left
[15:54] <abercrombie> so currently b: and rakudo: all fail on s/// ?

[15:55] *** phenny left
[15:55] *** phenny joined
[15:55] <jnthn> Seems in b the s/// runs, but $0 and $1 aren't available.

[15:56] <TimToady> rakudo: $_ = 'entirely'; s/^/not /; .say

[15:56] <p6eval> rakudo f34aa8: OUTPUT¬´not entirely‚ê§¬ª

[16:00] *** JimmyZ left
[16:13] *** MayDaniel joined
[16:18] *** daniel-s left
[16:19] <abercrombie> I thought the default loop var $_ in a for loop is writable, but it seems not true in Rakudo July

[16:20] <TimToady> b: my @a = 1,2,3; for @a { $_++ }; say @a

[16:20] <p6eval> b 1b7dd1: OUTPUT¬´234‚ê§¬ª

[16:21] <TimToady> looks writable to me

[16:21] <TimToady> rakudo: my @a = 1,2,3; for @a { $_++ }; say @a

[16:21] <p6eval> rakudo f34aa8: OUTPUT¬´2 3 4‚ê§¬ª

[16:21] <TimToady> can you give a counterexample?

[16:22] <abercrombie> my $fh = open 'a.txt';  .say if .=subst(...) for $fh.lines;

[16:22] <abercrombie> I got the following error: Cannot modify readonly value

[16:22] <TimToady> sorear: re http://irclog.perlgeek.de/perl6/2011-09-04#i_4372584, I think you'll find that Alaska is further from Quebec than SD is, and fits your criteria

[16:22] <abercrombie> if I use $some=.substr(..) instead, I am fine

[16:22] <abercrombie> s/substr/subst/

[16:23] <TimToady> the values returned from .lines are readonly because they have no container

[16:23] *** icwiener joined
[16:23] <abercrombie> Isn't the returned value stored in $_ ?

[16:23] <jnthn> Essentially, You're trying to modify values coming back from an iterator rather than looping over an array.

[16:24] <TimToady> Perl 5 did everything with containers, so you can modify any temp values.  In Perl 6 we're trying to keep better track of immutability so that the optimizer will (someday) have more to work with.

[16:25] <jnthn> I *think* we're binding to $_ in that case, so there's no container.

[16:25] *** MayDaniel left
[16:25] <jnthn> Well, we'd have to bind

[16:25] <jnthn> Otherwise we wouldn't be able to modify original things when there are containers. :)

[16:26] <abercrombie> Oh, I got it

[16:28] <TimToady> rakudo: .say if s/am/pm/ for [$*IN.lines].list

[16:28] <p6eval> rakudo f34aa8: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in sub infix:<=> at src/gen/CORE.setting:6870‚ê§  in block <anon> at /tmp/YGzjR0Hb5U:1‚ê§  in method reify at src/gen/CORE.setting:3601‚ê§  in method reify at src/gen/CORE.setting:3506‚ê§  in method reify at src/gen/CORE.se‚Ä¶

[16:29] <TimToady> hmm

[16:29] <TimToady> rakudo: .say if s/am/pm/ for [$*IN.lines].values

[16:29] <p6eval> rakudo f34aa8: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in sub infix:<=> at src/gen/CORE.setting:6870‚ê§  in block <anon> at /tmp/R9oo1Ij1JU:1‚ê§  in method reify at src/gen/CORE.setting:3601‚ê§  in method reify at src/gen/CORE.setting:3506‚ê§  in method reify at src/gen/CORE.se‚Ä¶

[16:29] <TimToady> rakudo: .say if s/am/pm/ for @([$*IN.lines])

[16:29] <p6eval> rakudo f34aa8: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in sub infix:<=> at src/gen/CORE.setting:6870‚ê§  in block <anon> at /tmp/5JxvpLO3qa:1‚ê§  in method reify at src/gen/CORE.setting:3601‚ê§  in method reify at src/gen/CORE.setting:3506‚ê§  in method reify at src/gen/CORE.se‚Ä¶

[16:29] <TimToady> jnthn: what's up with that ^^

[16:30] <TimToady> rakudo: .say for @([$*IN.lines])

[16:30] <p6eval> rakudo f34aa8: OUTPUT¬´Land der Berge, Land am Strome,‚ê§Land der √Ñcker, Land der Dome,‚ê§Land der H√§mmer, zukunftsreich!‚ê§Heimat bist du gro√üer S√∂hne,‚ê§Volk, begnadet f√ºr das Sch√∂ne,‚ê§vielger√ºhmtes √ñsterreich,‚ê§vielger√ºhmtes √ñsterreich!‚ê§‚ê§Hei√ü umfehdet, wild umstritten‚ê§liegst dem Erdteil du inmi‚Ä¶

[16:30] <jnthn> rakudo: [<a b c>][1] = 'd'

[16:30] <p6eval> rakudo f34aa8:  ( no output )

[16:30] <jnthn> hm

[16:30] <TimToady> rakudo: .say if .=subst(/am/, 'pm') for @([$*IN.lines])

[16:30] <p6eval> rakudo f34aa8: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in method dispatch:<.=> at src/gen/CORE.setting:623‚ê§  in block <anon> at /tmp/RBKI2SuFjC:1‚ê§  in method reify at src/gen/CORE.setting:3601‚ê§  in method reify at src/gen/CORE.setting:3506‚ê§  in method reify at src/gen/C‚Ä¶

[16:31] <jnthn> rakudo: [<a b c>][1] .= subst('b', 'x')

[16:31] <p6eval> rakudo f34aa8:  ( no output )

[16:31] <TimToady> say?

[16:31] <jnthn> TimToady: Didn't want output, just wanted to see if it complained about lack of rw-ness

[16:32] <jnthn> (trying to figure out if it's just down to the iterator)

[16:32] <jnthn> rakudo: @([$*IN.lines]).perl.say

[16:32] <p6eval> rakudo f34aa8: OUTPUT¬´Array.new("Land der Berge, Land am Strome,", "Land der √Ñcker, Land der Dome,", "Land der H√§mmer, zukunftsreich!", "Heimat bist du gro√üer S√∂hne,", "Volk, begnadet f√ºr das Sch√∂ne,", "vielger√ºhmtes √ñsterreich,", "vielger√ºhmtes √ñsterreich!", "", "Hei√ü umfehdet, wild um‚Ä¶

[16:32] <jnthn> rakudo: [$*IN.lines][0] = 'foo'

[16:32] <p6eval> rakudo f34aa8:  ( no output )

[16:32] <jnthn> rakudo: @([$*IN.lines])[0] = 'foo'

[16:32] <p6eval> rakudo f34aa8:  ( no output )

[16:33] <jnthn> hmmm.

[16:33] <jnthn> rakudo: for @([$*IN.lines]) { $_ = 'foo' }

[16:33] <p6eval> rakudo f34aa8:  ( no output )

[16:34] <jnthn> rakudo: for @([$*IN.lines]) { .= say }

[16:34] <p6eval> rakudo f34aa8: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 1‚ê§¬ª

[16:34] <jnthn> rakudo: for @([$*IN.lines]) { .=say }

[16:34] <p6eval> rakudo f34aa8: OUTPUT¬´Land der Berge, Land am Strome,‚ê§Land der √Ñcker, Land der Dome,‚ê§Land der H√§mmer, zukunftsreich!‚ê§Heimat bist du gro√üer S√∂hne,‚ê§Volk, begnadet f√ºr das Sch√∂ne,‚ê§vielger√ºhmtes √ñsterreich,‚ê§vielger√ºhmtes √ñsterreich!‚ê§‚ê§Hei√ü umfehdet, wild umstritten‚ê§liegst dem Erdteil du inmi‚Ä¶

[16:34] <jnthn> rakudo: for @([$*IN.lines]) { .=subst('am', 'pm') }

[16:34] <p6eval> rakudo f34aa8:  ( no output )

[16:34] <jnthn> .=subst('am', 'pm') for @([$*IN.lines])

[16:34] <TimToady> seems to be only the modifier form

[16:34] <jnthn> rakudo: .=subst('am', 'pm') for @([$*IN.lines])

[16:34] <p6eval> rakudo f34aa8: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in method dispatch:<.=> at src/gen/CORE.setting:623‚ê§  in block <anon> at /tmp/iCFojRSfI1:1‚ê§  in method reify at src/gen/CORE.setting:3601‚ê§  in method reify at src/gen/CORE.setting:3506‚ê§  in method reify at src/gen/C‚Ä¶

[16:34] <jnthn> TimToady: Yeah, that's what I was just concluding too. 

[16:35] *** MayDaniel joined
[16:35] <jnthn> ah, I think I see what might be going on...

[16:36] <TimToady> is something decontainerizing?

[16:36] <jnthn> TimToady: Yeah, the thunk we pass to map.

[16:37] <jnthn> Decontainerizes the $_

[16:37] <jnthn> I should be $dayjob-ing right now; I'll patch it this evening.

[16:37] *** phenny left
[16:37] <TimToady> 'k, thanks

[16:38] *** phenny joined
[16:41] *** frhodes left
[16:44] *** phenny left
[16:45] *** phenny joined
[16:50] *** mberends left
[16:57] *** zby_home_ joined
[17:01] *** phenny left
[17:02] *** frhodes joined
[17:02] *** phenny joined
[17:08] *** masak joined
[17:08] <masak> evenin', channel.

[17:09] <jnthn> good evening, human.

[17:10] * masak glances nervously around him

[17:10] <tadzik> good evening masak 

[17:11] <masak> tonight's plan: do a few of the things I planned to do in the weekend, but didn't :)

[17:12] <masak> notably, I'll try blogging a bit.

[17:16] *** sftp joined
[17:16] *** amil left
[17:36] *** wamba joined
[17:37] *** thou joined
[17:41] *** ashleyde1 left
[17:41] *** ashleydev joined
[17:47] <sorear> o/ masak

[17:47] <sorear> TimToady: what is the functional difference between not having a container and a SvREADONLY container?

[17:51] <flussence> er, this? https://metacpan.org/module/Readonly::XS

[17:52] <sorear> flussence: vaguely

[17:52] <sorear> flussence: SvREADONLY is a core Perl 5 feature

[17:52] *** icwiener left
[17:55] *** frhodes left
[18:06] *** benabik joined
[18:10] *** colomon joined
[18:14] *** molaf left
[18:16] *** benabik left
[18:17] *** thou left
[18:22] *** benabik joined
[18:24] *** benabik left
[18:24] *** benabik joined
[18:29] *** risou is now known as risou_awy

[18:32] *** amil joined
[18:36] *** mj41 joined
[18:50] *** daxim left
[18:54] *** envi_laptop left
[18:54] <masak> nice email on p6u.

[18:54] * masak replies to it

[18:58] <masak> rakudo: my $c = 0..20; say +$c

[18:58] <p6eval> rakudo f34aa8: OUTPUT¬´21‚ê§¬ª

[18:58] <masak> rakudo: my $c = 0..20; say ~$c

[18:58] <p6eval> rakudo f34aa8: OUTPUT¬´0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20‚ê§¬ª

[18:58] *** frhodes joined
[18:59] *** frhodes left
[19:04] <masak> rakudo: my $c = 0.5 .. 5.5; say +$c

[19:04] <p6eval> rakudo f34aa8: OUTPUT¬´6‚ê§¬ª

[19:04] <masak> rakudo: my $c = 0.5 .. 5.4; say +$c

[19:04] <p6eval> rakudo f34aa8: OUTPUT¬´5‚ê§¬ª

[19:06] <tadzik> masak++ # responses

[19:07] <sorear> We need to coordinate this better

[19:07] <sorear> I responded at the same time

[19:07] <sorear> to the other thread

[19:07] <sorear> also, my responce directly contradicted masak's on one point.

[19:08] *** wamba left
[19:08] <masak> sorear: I posted here on the channel that I was responding. I figgered that'd reduce duplicated effort. :P

[19:08] <masak> apparently not.

[19:09] <sorear> masak: I checked this channel before I started writing, and checked it again after I was done.

[19:09] <sorear> clearly, *I* should have posted that I was responding

[19:11] <masak> yes. :)

[19:11] <masak> though I liked your responses, too. and I don't see the point of our disagreement.

[19:12] <masak> er. I mean I didn't find any.

[19:12] <lue> hello planet o/

[19:12] <masak> good time, lue.

[19:12] *** envi_laptop joined
[19:13] * lue should get in the habit of checking his email on a semi-regular basis

[19:14] <sorear> masak: I said that if {...} { say "yes" } was correct (it said yes).  You said bug.

[19:15] <masak> hm.

[19:15] <masak> I think I agree that it should say "yes".

[19:15] * masak re-reads what he wrote

[19:15] <lue> rakudo: say ?{...}

[19:15] <p6eval> rakudo f34aa8: OUTPUT¬´Bool::True‚ê§¬ª

[19:17] <masak> I posted a correction. sorear++ masak--

[19:21] *** birdwindupbird joined
[19:28] <lue> I wonder if I should sign up for p6l/p6u again...

[19:28] <moritz> p6u is low traffic

[19:28] <masak> moritz! \o/

[19:31] *** mj41 left
[19:33] *** frhodes joined
[19:34] *** donri left
[19:35] <lue> how about  die("of a awful fate" :noloc)  or something like that?

[19:35] <masak> sans TTIAR, perhaps :)

[19:35] <moritz> lue: read my mail to p6u

[19:36] <sorear> niecza: die "of an awful fate" :noloc

[19:36] <jnthn> die-quietly "of a awful fate"

[19:36] <p6eval> niecza v9-10-g678102e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§You can't adverb that at /tmp/91CmRUmJD9 line 1 (EOF):‚ê§------> [32mdie "of an awful fate" :noloc[33m‚èè[31m<EOL>[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ‚Ä¶

[19:36] <moritz> and p6l

[19:36] <masak> lue: it's generally considered a design smell to have a negatively-phrased adverb.

[19:36] <sorear> niecza: (die "of an awful fate") :noloc

[19:36] <p6eval> niecza v9-10-g678102e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§You can't adverb that at /tmp/zcrgTY4JkJ line 1 (EOF):‚ê§------> [32m(die "of an awful fate") :noloc[33m‚èè[31m<EOL>[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2‚Ä¶

[19:36] <sorear> hrhmf

[19:36] <moritz> std: 'foo' :a

[19:36] <p6eval> std e3c970e: OUTPUT¬´ok 00:01 119m‚ê§¬ª

[19:36] <lue> I read the p6u email, but didn't get to your condemnation of the named argument before saying that :)

[19:36] <moritz> std: sort(1, :foo :bar)

[19:36] <p6eval> std e3c970e: OUTPUT¬´ok 00:01 121m‚ê§¬ª

[19:37] <moritz> named arguments aren't bad per se -- they are just a hint to investigate if there's something we could do better on another level

[19:37] <lue> masak: TTIAR? [Ten Times In A Row ?]

[19:37] <masak> Two Terms.

[19:38] <masak> lue: I bet you know this by now :)

[19:38] <lue> yes, just not the acronym :)

[19:40] <lue> .oO(For quiet &die, perhaps &faint [implying it died (or at least went unconscious] before it could say everything]?)

[19:41] <masak> lue: there's already &exit and &sleep

[19:42] <lue> Hm. (mortiz is right, figuring out the way to do &die without backtrace is interesting)

[19:43] <tadzik> passout()

[19:45] <jnthn> whine

[19:45] <lue> .oO(if it's a user error (and you don't want backtrace), it's like they gave a nasty blow to the poor program, perhaps &ko for quiet form of &die?)

[19:46] <lue> I like the sound of &whine :)

[19:51] * masak likes the taste of beer :)

[19:52] *** MayDaniel left
[19:52] *** mux left
[19:52] <tadzik> :P

[19:52] <lue> .oO(whine "you never pick the right card! Never never never never!";)

[19:53] <tadzik> whine() should randomly say "you don't love me anymore" or "I'm not talking to you"

[19:53] <masak> it should play discordant tunes on the PC speaker.

[19:54] <masak> man, Perl 6 gonna be *great*.

[19:55] <masak> blog post! http://strangelyconsistent.org/blog/dash-n-and-dash-p-part-two

[19:55] <masak> TimToady: that one's for you :)

[19:57] <masak> I think that might be the most confused Perl 6 blog post I've ever written. but that's how I feel about the {YOU_ARE_HERE} approach to -n and -p.

[19:57] <masak> in a way, the current AST approach is an immunoresponse to the abject handwavery of the spec.

[19:59] *** thou joined
[19:59] *** mux joined
[20:00] <sorear> meh, the spec is not that ad

[20:00] <sorear> bad

[20:00] <masak> how does Niecza implement it?

[20:01] <sorear> CORN.setting: for lines {YOU_ARE_HERE}

[20:01] <sorear> I'm not crazy about TimToady's choice of names

[20:01] <sorear> a module does not have one setting, it has a stack of them

[20:02] <sorear> SETTING means UNIT::OUTER

[20:02] <sorear> in a typical program, SETTING === CORE

[20:02] <sorear> typically you have NULL -> CORE -> (program)

[20:02] <sorear> in an eval, you need SETTING::SETTING, because it's NULL -> CORE -> (program) -> (eval)

[20:03] <sorear> with -n you have NULL -> CORE -> CORN -> (program)

[20:04] <sorear> Niecza interprets -n, -p, and -L as applying to the main program only; there is currently no way to override the setting for modules, but it would be LHF

[20:04] *** birdwindupbird left
[20:04] <masak> ooh!

[20:05] <masak> I'm glad I posted my confused rant, if the result was this nice answer.

[20:05] <sorear> the interesting bit comes in where this interacts with the compiled module cache, if you have some people wanting to use CORE->CORN and other people wanting to use CORE->CompanySetting->CORN on the same niecza install

[20:05] <masak> that's what TimToady meant by saying that the settings are nested...

[20:05] <sorear> I haven't actually read your rant yet.  Let me do that now

[20:05] <masak> well, it's basically obsolete at this point :)

[20:06] <masak> I need to write a part three now.

[20:06] * lue considers using the name 'frotzlexity' for a P6-coded IF

[20:07] <masak> oddly appropriate.

[20:08] <TimToady> note that CORN is really the name of the new language, which includes its entire pedigree CORE+N

[20:08] <masak> nodnod

[20:08] <TimToady> CORE->CompanySetting->CORN is non-sensical

[20:08] <TimToady> CORE+CompanySetting+N is its true identity

[20:08] <sorear> oh!

[20:09] *** envi_laptop left
[20:09] <TimToady> I keep saying this, and I'm glad to keep saying it: we must always know what language we are in while we're parsing

[20:10] <TimToady> so relative language names don't cut it, when you need a universal naming scheme

[20:10] <masak> maybe we don't understand you because we don't know what language you're speaking :P

[20:12] *** bluescreen10 left
[20:13] <TimToady> At this point I believe I am speaking Axiomatic rather than Handwaving...

[20:13] <cotto> pmichaud, ping

[20:13] <TimToady> problem is, both of those languages always leave something unsaid...

[20:15] <sorear> TimToady: would it be reasonable for me to a) rename COR{N,P}.setting to {N,P}.setting; b) change -L to accept a +-path line CORE+P, CORE+N; and c) change -n,-p to append +P or +N to the language name

[20:15] <sorear> ?

[20:15] <masak> TimToady: thanks for explaining this.

[20:15] <TimToady> sorear: sure, that'd be reasonable

[20:15] <TimToady> and more composable, as masak++ wishes

[20:16] <TimToady> though I'd be a little unhappy if people start abusing settings when they should just have a 'use', where a 'use' can adequately tweak the grammar

[20:17] <TimToady> -n and -p require a setting because 'use' can't retroactively put a loop around UNIT without cheating

[20:19] <sorear> in CORE.setting: my $_runner = *(); $_runner.({YOU_ARE_HERE});

[20:19] <sorear> in N: IMPORT { $CALLER::_runner = sub ($code) { for lines { $code() } } }

[20:20] <sorear> easy.

[20:22] <sorear> also, I kind of liked the eskimo operator.

[20:25] <masak> I admire it as a neat hack.

[20:25] <masak> I don't find it particularly useful or worth preserving.

[20:26] *** bluescreen10 joined
[20:30] <moritz> one can replace it by a LAST phaser quite elegantly and more readable, no?

[20:30] <masak> aye.

[20:30] <masak> even in Perl 5, '}{ ...' is just a funky way to say 'END { ... }'

[20:31] *** kaare_ left
[20:31] <lue> b: say "'hai\"" ~~ /$bq=(\"||\') <?before $bq> \N* /

[20:31] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say \"'hai\\"‚ê§¬ª

[20:32] <moritz> don't use p5 regex syntax in p6

[20:32] <moritz> std: /$bq=(\"||\') <?before $bq> \N* /

[20:32] <p6eval> std e3c970e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $bq is not predeclared at /tmp/Ggk10Fntqo line 1:‚ê§------> [32m/$bq[33m‚èè[31m=(\"||\') <?before $bq> \N* /[0m‚ê§Variable $bq is not predeclared at /tmp/Ggk10Fntqo line 1:‚ê§------> [32m/$bq=(\"||\') <?before $bq[33m‚èè[31m> \N* ‚Ä¶

[20:34] <lue> .oO(I accidentaly used P5? Wow.)

[20:35] *** frhodes left
[20:38] <moritz> not quoting = is what I actually meant :-)

[20:38] *** im2ee left
[20:38] *** im2ee joined
[20:41] *** supernovus joined
[20:42] <moritz> masak++ # blag

[20:43] <masak> henceforth I'll not hesitate to post "I'm so confused!" :P

[20:50] *** whiteknight left
[20:57] <lue> .oO(Now is a good time I think to start coding Frotzlexity's world model)

[20:57] <TimToady> sorear: your 'lines' needs a ()

[20:59] <masak> std: for lines { .say }

[20:59] <p6eval> std e3c970e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Function 'lines' needs parens to avoid gobbling block at /tmp/6MtcddYvQ1 line 1:‚ê§------> [32mfor lines[33m‚èè[31m { .say }[0m‚ê§Missing block (apparently gobbled by 'lines') at /tmp/6MtcddYvQ1 line 1:‚ê§------> [32mfor lines { .say }[33‚Ä¶

[21:03] *** Trashlord left
[21:07] *** amil left
[21:07] *** donri joined
[21:08] <dalek> rakudo/nom: 493e23e | jonathan++ | src/Perl6/Actions.pm:

[21:08] <dalek> rakudo/nom: Fix rw-stripping bug in statement modifier form of for.

[21:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/493e23e586

[21:09] *** frhodes joined
[21:11] <masak> 'night, #perl6

[21:11] *** masak left
[21:21] <im2ee> good night! :)

[21:22] <tadzik> o/

[21:25] *** im2ee left
[21:36] *** supernovus left
[21:37] *** zby_home_ left
[21:50] <dalek> rakudo/optimizer: 5ab4e11 | jonathan++ | / (4 files):

[21:50] <dalek> rakudo/optimizer: Add an optimizer stage to the compiler, which for now we only enable when --optimize is passed.

[21:50] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/5ab4e1151a

[21:50] <dalek> rakudo/optimizer: de1b900 | jonathan++ | src/Perl6/ (3 files):

[21:50] <dalek> rakudo/optimizer: Start sketching out inlining of statements of simple blocks. Many issues, but handles a basic example case.

[21:50] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/de1b900483

[21:50] <dalek> rakudo/optimizer: 3f25af9 | jonathan++ | src/Perl6/Optimizer.pm:

[21:50] <dalek> rakudo/optimizer: Start to harden and improve the immediate block inline handling a bit.

[21:50] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/3f25af9aac

[21:50] <dalek> rakudo/optimizer: 471fc0d | jonathan++ | src/Perl6/Optimizer.pm:

[21:50] <dalek> rakudo/optimizer: Topic preservation over immediate block inlines. A little refactoring. Preliminaries for detecting cases where we can 'inline' onlystar protos (though it won't be so much an inlining as just jumping right into the multi-dispatcher).

[21:50] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/471fc0d73d

[21:50] <jnthn> Mmm. Oktoberfest bier.

[21:53] <tadzik> wooo

[21:53] <tadzik> jnthn: does this work?

[21:53] <jnthn> tadzik: The beer seems to work pretty well, yes.

[21:53] <jnthn> tadzik: The optimizer...well, it only implements one optimization. I didn't try it on anything serious yet (like the setting).

[21:54] <jnthn> This is mostly me having some -Ofun rather than working on the stuff I probably should be to get a nom-based release in shape... :)

[21:56] * jnthn checks if CORE.setting builds on it, just out of curiosity.

[21:56] <jnthn> (e.g. with --optimize)

[21:59] *** zby_home joined
[22:00] <jnthn> Well, it builds a setting that compiles

[22:00] <jnthn> as in, we make it through the build

[22:00] <jnthn> Survive hello world too.

[22:01] <jnthn> Claims it inlined 174 immediate blocks.

[22:01] <benabik> jnthn++

[22:02] <tadzik> to benchmark? :)

[22:02] <tadzik> well, measure

[22:03] <jnthn> Guess could always see if it makes any impact on the spectests, though I'd be skeptical of much given it's only doing one thing. :)

[22:03] <jnthn> spectest is looking OK so far.

[22:07] <jnthn> ah, it's caused some fails 

[22:18] <jnthn> ah, hm

[22:20] <benabik> hmm?

[22:21] <jnthn> think I tracked down what's going on.

[22:28] <dalek> rakudo/optimizer: 5b1e31b | jonathan++ | src/Perl6/Optimizer.pm:

[22:28] <dalek> rakudo/optimizer: Ensure that topic restoration doesn't clobber block result!

[22:28] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/5b1e31b504

[22:29] *** plobsing left
[22:30] *** plobsing joined
[22:31] *** djanatyn joined
[22:33] <djanatyn> Heyo.

[22:34] <jnthn> o/ djanatyn 

[22:34] <jnthn> Yay, tests looking better after that fix.

[22:38] <felher> jnthn++

[22:39] <felher> jnthn: where do i have to pass the --optimize-flag? to Configure.pl? 

[22:39] <tadzik> jnthn: is there a performance win?

[22:40] <jnthn> felher: Are you talking about the current work I'm doing in the optimizer branch?

[22:40] <felher> jnthn: yeah :)

[22:40] <jnthn> felher: It's really to early to sanely use it for anything. But if you want to play, you just pass Rakudo a --optimize flag

[22:40] <jnthn> If you want to try and optimized setting, just hack the appropriate line in Makefile

[22:41] <jnthn> *an

[22:41] <jnthn> felher: This is *extremely* early and experimental work at the moment, though.

[22:41] <felher> jnthn: Yeah, np. I just want to play with it :)

[22:41] <felher> jnthn: thnx

[22:42] <jnthn> :)

[22:44] *** bluescreen10 left
[22:52] *** benabik left
[22:52] <jnthn> ok, sleep time &

[22:52] <tadzik> jnthn: g'night

[22:57] *** daniel-s joined
[22:59] *** Trashlord joined
[23:00] *** frhodes left
[23:03] *** zby_home left
[23:03] <tadzik> ooh, win

[23:04] *** contempt_ joined
[23:04] <tadzik> https://gist.github.com/1196124

[23:05] <tadzik> b: say (34.89 - 27.12) / 34.89

[23:05] <p6eval> b 1b7dd1: OUTPUT¬´0.222699914015477‚ê§¬ª

[23:05] <tadzik> http://goo.gl/acAxg

[23:05] *** contempt_ left
[23:08] <felher> tadzik: hui, quite nice. :)

[23:08] *** whiteknight joined
[23:15] <tadzik> mandelbrot does not react to --optimize at all

[23:17] <sorear> niecza: my $start = times[0];my $i = 0; for 1..100000 { $i = $i + $_; }; say $i; say times[0] - $start;

[23:17] <p6eval> niecza v9-10-g678102e: OUTPUT¬´5000050000‚ê§4.136259‚ê§¬ª

[23:17] <sorear> disappointing

[23:17] <sorear> oh right I completely forgot to optimize Ranges

[23:19] <tadzik> g'night #perl6

[23:21] <felher> good night tadzik 

[23:35] *** Psyche^ joined
[23:38] *** Patterner left
[23:38] *** Psyche^ is now known as Patterner

[23:39] *** uasi joined
[23:43] *** uasi left
[23:44] *** uasi joined
[23:48] *** uasi left
