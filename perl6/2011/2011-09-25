[00:01] <benabik> Ooh, language design arguments.  :-D

[00:02] *** Chillance left
[00:04] *** Trashlord left
[00:06] *** soh_cah_toa left
[00:07] *** [Coke] left
[00:09] *** [Coke] joined
[00:13] *** soh_cah_toa joined
[00:25] <colomon> sorear: just e-mailed you the complete trig patch.  

[00:25] *** kfo joined
[00:25] <colomon> still needs some work on real inverse hyperbolic functions, current implementation is hacky.

[00:26] <colomon> now to patch roast...

[00:29] *** kfo_ left
[00:42] <colomon> b: say True ?? "hello" !! "Goodbye"

[00:42] <p6eval> b 1b7dd1: OUTPUT«hello␤»

[00:45] <sorear> rakudo: say tan pi/2

[00:45] <p6eval> rakudo aed9fe: OUTPUT«557135115.020977␤»

[00:46] *** PacoLinux joined
[00:47] <dalek> niecza: 08a7d84 | (Solomon Foster)++ | / (6 files):

[00:47] <dalek> niecza: Significant expansion of the C# Complex class in Utils.cs. Complete implementation of an auto-generated set of trig functions.

[00:47] <dalek> niecza: review: https://github.com/sorear/niecza/commit/08a7d84360

[00:48] <colomon> sorear: does niecza not allow todo fudging?

[00:49] <sorear> colomon: correct

[00:50] <sorear> I don't actually quite know how it should work

[00:50] <sorear> I'll research that later maybe?

[00:50] <colomon> sure

[00:50] <colomon> and I'll change them to skips for now

[00:54] <dalek> roast: 46de8ad | (Solomon Foster)++ | S32-trig/generate-tests.pl:

[00:54] <dalek> roast: Update trig generator with fudging for Niecza.

[00:54] <dalek> roast: review: https://github.com/perl6/roast/commit/46de8adfd6

[00:54] <dalek> roast: 4661e6b | (Solomon Foster)++ | S32-trig/ (13 files):

[00:54] <dalek> roast: Update generated trig files with fudging for Niecza.

[00:54] <dalek> roast: review: https://github.com/perl6/roast/commit/4661e6bc02

[00:59] <japhb> Is there a way (other than string eval) to produce a role that closes over surrounding variables?

[01:00] <colomon> oooo, there's a make spectest target now.

[01:00] <japhb> e.g. my $foo = "blah"; my $role = role { method bar { $foo } };

[01:06] *** REPLeffect left
[01:19] *** REPLeffect joined
[01:23] <colomon> sorear: whoops.  forgot to implement atan2!

[01:23] *** packetknife left
[01:26] *** wolfman2000 joined
[01:28] *** uasi joined
[01:32] <colomon> sorear: you can turn on all the S32-trig tests except atan2.t

[01:44] <colomon> whee, sierpinski!!

[01:58] *** envi joined
[01:59] *** frhodes left
[02:44] <colomon> sorear: you out there atm?

[02:47] <colomon> I just defined  static Func<Variable,Variable,Variable> atan2_d = atan2;  and that seems to compile okay, but when I add method atan2($x) { Q:CgOp { (atan2 {self, $x}) } } to Cool, niecza's compile blows sky high.  What am I doing wrong?

[02:48] *** flatwhatson left
[02:50] *** envi left
[02:51] <colomon> oh, should be atan2 {self} {$x}

[02:56] *** envi joined
[03:02] <sorear> japhb: role parameterization

[03:02] <sorear> colomon: I have just returned from dinner

[03:03] <colomon> sorear: just sent you another patch

[03:03] <sorear> colomon: (atan2 {self} {$x}).  It's modelled on lisp.

[03:03] <sorear> {self, $x} should result in some kind of MethodNotFoundException

[03:04] <sorear> colomon: Why did you give atan2 a default argument?

[03:04] <colomon> sprec

[03:04] <colomon> spec

[03:05] <sorear> looks decent to me then.  Which thing did you cargo-cult?

[03:05] <colomon> all the stuff with the a2.Fetch() ; GetNumber etc

[03:05] <sorear> sorry, I mean where did you get it from.

[03:05] <colomon> I dropped the HandleSpecial bit because I wasn't sure how to do it with two arguments

[03:06] <colomon> oh, I started with the code for sin, I think

[03:06] <sorear> add() contains an example of HandleSpecial used for two arguments

[03:07] <sorear> but you don't really need it here

[03:07] <colomon> ah, yeah, I did find mul later, looking for something else.  didn't occur to me to grab the HandleSpecial from there.

[03:07] <sorear> the purpose of HandleSpecial is to implement junctional autothreading

[03:07] <colomon> ah, right

[03:07] <sorear> since you're only calling (atan2) from inside a function with Any args, atan2 can never see a junction

[03:08] <sorear> for add() and friends it's useful to avoid the cost of a function call and signature binding.  not sure atan2 is the same

[03:09] <dalek> niecza: 26ad592 | (Solomon Foster)++ | lib/ (2 files):

[03:09] <dalek> niecza: First stab at implementing atan2.

[03:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/26ad592ac4

[03:09] <colomon> yeah, I have no real feel on junctions other than as a simple shortcut in comparisons.  :)

[03:09] <sorear> karma colomon

[03:09] <aloha> colomon has karma of 152.

[03:09] <sorear> karma Colomon Foster

[03:09] <aloha> Colomon Foster has karma of 0.

[03:09] <sorear> karma Solomon Foster

[03:09] <aloha> Solomon Foster has karma of 112.

[03:09] <colomon> I have a (not so) secret identity

[03:10] <sorear> (also have to avoid typing 'colophon:')

[03:11] <sorear> colomon: My command on junctions isn't the best either.  The niecza implementation of them is several orders of magnitude faster than I expected it to be

[03:11] <colomon> that's handy!

[03:11] <sorear> $obj == 1 | 3 | 5 is not significantly slower than $obj == 1 || $obj == 3 || $obj == 5

[03:12] <colomon> btw, the GTK Sierpinski example Just Worked for me.  That's terrific!

[03:21] <colomon> afk # bed

[03:23] *** newsbad_com left
[03:29] *** newsbad_com joined
[03:36] *** donri left
[03:56] <ingy> hi TimToady 

[03:56] <ingy> TimToady: I read over % more in detail

[03:57] <ingy> TimToady: it's nice, but I still don't see how to allow for possible trailing comma

[04:00] *** soh_cah_toa left
[04:02] <ingy> sb end

[04:05] <ingy> moritz: funny how you tried to talk me out of a+ ** to be a +** and now its a+ ** in a05, albeit a+ %

[04:15] <japhb> Once I have the message string, how do I create the $?USAGE variable in Rakudo, and set it to my newly-minted message?

[04:16] <japhb> (from within the setting, of course)

[04:36] <araujo> hello

[04:40] <japhb> o/

[05:05] *** REPLeffect left
[05:13] *** djanatyn left
[05:13] *** djanatyn joined
[05:18] *** REPLeffect joined
[05:20] *** Tene left
[05:20] *** djanatyn left
[05:21] *** bluescreen10 left
[05:27] *** kaare_ joined
[05:31] *** Tene joined
[05:31] *** Tene left
[05:31] *** Tene joined
[05:34] *** flatwhatson joined
[05:36] *** kaleem joined
[05:44] *** flatwhatson left
[05:50] *** kaleem left
[05:52] *** mj41 joined
[06:05] *** orafu left
[06:06] *** orafu joined
[06:07] *** risou_awy is now known as risou

[06:07] *** mj41 left
[06:10] *** REPLeffect left
[06:12] *** risou is now known as risou_awy

[06:13] *** f00li5h left
[06:17] <sorear> hello araujo

[06:19] *** araujo left
[06:23] *** REPLeffect joined
[06:24] *** Woodi joined
[06:41] <moritz> good morning

[06:41] <moritz> ingy: funny indeed

[06:45] <Woodi> morning #perl6

[06:45] <Woodi> i got something like this:

[06:46] <Woodi> rakudo: class A { has %!c = { 'a' => 1, 'b' => 2 } ; for %!c.keys -> $name { say $name } }

[06:46] <p6eval> rakudo aed9fe: OUTPUT«Can only use repr_get_attr_obj on a SixModelObject␤  in <anon> at /tmp/6KlyczI8WZ:1␤  in <anon> at /tmp/6KlyczI8WZ:1␤  in <anon> at /tmp/6KlyczI8WZ:1␤␤»

[06:46] <Woodi> and

[06:46] <Woodi> rakudo: class A { our %c = { 'a' => 1, 'b' => 2 } ; for %c.keys -> $name { say $name } }

[06:46] <p6eval> rakudo aed9fe: OUTPUT«Method 'STORE' not found for invocant of class 'Any'␤  in <anon> at /tmp/9HjmJPA6Ww:1␤  in <anon> at /tmp/9HjmJPA6Ww:1␤  in <anon> at /tmp/9HjmJPA6Ww:1␤␤»

[06:47] <Woodi> hwhat should i use in nom ? works with star-07

[06:48] *** woosley joined
[06:49] <moritz> Woodi: the problem is that attributes are tied to specific instances, but the class body (in which you try to access the attribute) is no

[06:49] <Woodi> our version works

[06:49] <Woodi> hmm

[06:49] <moritz> Woodi: so put the code into a method, create an instance of the class, and call the method with the code

[06:50] <Woodi> you mean 'for' ?

[06:50] <moritz> yes

[06:51] <moritz> you'll notice that all examples of attribute usage use them in methods, not in the class body

[06:51] <Woodi> it is intentional outside method becouse it generate methods :) should be BEGIN probably

[06:51] <moritz> then it can't be in an attribute

[06:51] <Woodi> ok

[06:51] <Woodi> so our should work ?

[06:52] <moritz> yes

[06:52] <Woodi> b: class A { our %c = { 'a' => 1, 'b' => 2 } ; for %c.keys -> $name { say $name } }

[06:52] <p6eval> b 1b7dd1: OUTPUT«a␤b␤»

[06:52] <Woodi> oo

[06:52] <Woodi> hmm

[06:52] *** lue left
[06:53] <Woodi> ok, so b is ok

[06:53] <Woodi> in nom i got STORE problems...

[06:57] <Woodi> rakudo: class A { our %c = { 'a' => 1, 'b' => 2 } ;BEGIN { for %c.keys -> $name { say $name } } }

[06:57] <p6eval> rakudo aed9fe: OUTPUT«===SORRY!===␤Method 'keys' not found for invocant of class 'Mu'␤»

[07:00] *** mj41 joined
[07:04] *** SHODAN joined
[07:04] <Woodi> today release of next Star ?

[07:04] *** lue joined
[07:08] *** senobmeht left
[07:09] *** lue left
[07:10] *** senobmeht joined
[07:13] *** lue joined
[07:15] * sorear -> sleep

[07:16] <sorear> tomorrow: study nom's implementation of parametric roles

[07:21] <snarkyboojum> Woodi: haven't heard about a date for next Star yet - devs are waiting to bed down nom first I believe

[07:24] <TiMBuS> is there a perl5 version of the cross operator? list::moreutils doesnt have one :/

[07:24] <Woodi> perl6:  my $a = "A\n"; lc $a; $a.chomp ; say $a;

[07:24] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«A␤␤»

[07:24] <Woodi> perl6:  my $a = "A\n"; lc $a; chomp $a; say $a;

[07:24] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«A␤␤»

[07:25] <TiMBuS> Algorithm::Loops might have one...

[07:31] <snarkyboojum> perl6: my $a = "A\n"; say $a.chomp;

[07:31] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«A␤»

[07:35] <Woodi> perl6:  my $a = "A\n"; $a.lc; $a.chomp; say $a;

[07:35] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«A␤␤»

[07:35] <Woodi> perl6:  my $a = "A\n"; $a.chomp; say $a;

[07:35] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«A␤␤»

[07:36] <Woodi> perl6:  my $a = "A\n"; say $a.lc;

[07:36] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«a␤␤»

[07:36] <Woodi> perl6:  my $a = "A\n"; say $a.lc; say $a;

[07:36] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«a␤␤A␤␤»

[07:37] <Woodi> perl6:  my $a = "A\n"; say $a.chomp; say $a;

[07:37] <p6eval> pugs, rakudo aed9fe, niecza v9-50-g26ad592: OUTPUT«A␤A␤␤»

[07:37] <Woodi> it little strange but consistent :)

[07:38] <moritz> not strange if you remember that Str and Int methods don't modify the invocant, but return a modified copy

[07:39] <moritz> you can do $a.=chomp  if you want in-place modification

[07:41] <Woodi> moritz: chomp at least was modyfing in-place and it was perfect

[07:41] <Woodi> lc not

[07:51] *** mj41 left
[07:55] *** lue left
[08:03] *** lue joined
[08:06] *** mj41 joined
[08:09] *** lue left
[08:18] *** im2ee joined
[08:18] <im2ee> Hello! :)

[08:24] <moritz> good morning im2ee 

[08:24] <moritz> perfectly inconsistent, yes

[08:28] *** risou_awy is now known as risou

[08:32] *** cognominal joined
[08:33] *** lue joined
[08:36] *** masak joined
[08:36] <masak> good morning, #perl6!

[08:38] <moritz> good am, ma<tab>

[08:38] <masak> ;)

[08:38] *** lue left
[08:39] <moritz> you will love this one:

[08:39] <moritz> multi sub infix:«<=>»(Buf:D $a, Buf:D $b) { [||] $a.list Z<=> $b.list or $a.elems <=> $b.elems

[08:39] <moritz> }

[08:41] *** araujo joined
[08:41] *** lue joined
[08:41] <masak> ooh

[08:42] <moritz> thought so :-)

[08:42] *** molaf joined
[08:43] *** REPLeffect left
[08:43] <moritz> I'm sure it's terribly inefficient in contemporary rakudo

[08:44] <moritz> but it's so beautiful that I'll keep it that way until somebody complains about speed :-)

[08:45] <szabgab_> guys, can I ask you for a quick but unrelated help. I am trying to run a poll and I need a quick feedback before I launch it

[08:45] <szabgab_>  http://perlpolls.com/perl-news  is the url, I'd appreciate your comments

[08:45] *** MayDaniel joined
[08:45] *** szabgab_ is now known as szabgab

[08:46] *** lue left
[08:50] <masak> looks ok.

[08:50] <masak> from a sixer's perspective, it's more "Perl 5 news" than "Perl news", but I'm not sure the distinction matters much to the rest of the world. ;)

[08:51] <szabgab> shall I add the planetsix?

[08:51] <masak> wouldn't hurt.

[08:54] <szabgab> unfortunatelly I am not sure in that :(   but I added as I think it is important

[08:56] <masak> hey, it's your poll. ;)

[08:56] <szabgab> masak: in any case, thanks for you quick feedback!

[08:57] <masak> I'm not sure use.perl.org belongs there.

[08:57] <masak> it's literally impossible to blog there nowadays.

[08:57] <szabgab> this is the beginnng of those polls I mentioned almost a year ago

[08:58] <szabgab> I put it there as sort of a reality check

[08:58] <masak> ok.

[08:58] <szabgab> I am quite sure many people will still check it

[08:58] <szabgab> as happened a while ago

[08:58] <szabgab> but we'll see

[08:58] <masak> I think a fair number of people would check "planet perl 6" if it were in that list.

[08:58] <szabgab> it is already

[08:59] <masak> \o/

[08:59] <masak> so it is. szabgab++

[09:01] <masak> moritz: how come split gets a Str $delimiter variant, but comb doesn't get a Str $matcher variant?

[09:05] *** mj41 left
[09:06] <masak> re the discussion about "the final release" yesterday. I'd *love* for there to be such a moment, where we put away our tools, wipe our hands and say "there. we did it." it's just -- from what I've seen of the world, it doesn't work that way. :/

[09:07] <masak> any 6.0.0 point will by necessity be arbitrary and thus a disappointment to some.

[09:08] <Patterner> are those people paying you?

[09:08] <masak> so ingy claimed.

[09:09] <masak> see backlog.

[09:09] *** MayDaniel left
[09:09] <Patterner> unless you have proof: ignore some. and continue the good work.

[09:10] <masak> aye.

[09:10] <masak> though possibly I'll get the energy to blog about this.

[09:11] <masak> I was happy to see Rakudo gain speed. I was even happier about Rakudo Star. if we manage to make the jigsaw pieces fit, nom will be our awesomest product yet.

[09:12] *** MayDaniel joined
[09:12] <masak> it just feels so skewed to be talking about failed 6.0.0 expectations in the middle of that.

[09:13] * masak continues the good work

[09:15] <masak> std: my $a = "HAI"; say "OH $a # comment"

[09:15] <p6eval> std c22b2ee: OUTPUT«ok 00:01 121m␤»

[09:15] <masak> nom: my $a = "HAI"; say "OH $a"

[09:15] <p6eval> nom aed9fe: OUTPUT«OH HAI␤»

[09:15] <masak> my $a = "HAI"; say "OH $a # comment"

[09:15] <masak> nom: my $a = "HAI"; say "OH $a # comment"

[09:15] <p6eval> nom aed9fe: OUTPUT«===SORRY!===␤Confused at line 1, near "say \"OH $a"␤»

[09:15] * masak submits rakudobug

[09:15] <masak> I think we've had this one before.

[09:15] <masak> b: my $a = "HAI"; say "OH $a # comment"

[09:15] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Confused at line 22, near "say \"OH $a"␤»

[09:16] <masak> oh, ok.

[09:16] * masak searches RT for this bug

[09:17] *** MayDaniel left
[09:18] <masak> aye, here: https://rt.perl.org/rt3/Ticket/Display.html?id=78202

[09:19] <masak> some goof named masak already found that one a year ago.

[09:19] <Woodi> masak: i do not think that Perl6 is spec only. it totally do not matter to user, especially outside Perl sphere. only implementations matter and spec is just one of design stage for them. they think that way. and now: if Perl6 spec is like ANSI specification will be + on top of the first

[09:20] <Woodi> so ingy problem was just name...

[09:20] <masak> Woodi: no disagreement there.

[09:21] <masak> well, Perl 6 *is* a spec. maybe if he said that's what people had been paying for all along, and not the implementations too, that's why they revolted.

[09:21] <masak> but note that things like Hague grants are never on just the spec, but on Rakudo primarily and the spec secondarily.

[09:22] <masak> nom: my $a = "HAI"; say "OH $a \# comment"

[09:22] <p6eval> nom aed9fe: OUTPUT«OH HAI # comment␤»

[09:22] <masak> workaround ^^

[09:31] *** lue joined
[09:34] <Woodi> that is nice: Perl isn't a programming language. It's a life support system for CPAN. :)

[09:34] <szabgab> masak: btw I'd really like to have at least one interesting news item about Rakudo every week

[09:35] <szabgab> I'd put it in the Perl Weekly and hope to get more and more people paying attention

[09:37] <masak> szabgab: that's a nice idea. I support it wholeheartedly.

[09:37] <Woodi> szabgab: there is new module Simple::Redis for perl6 on github. i was angry of no working db bindings available :)

[09:37] <Woodi> still in heavy development

[09:38] <masak> Woodi++

[09:38] <masak> I hope to use that module soon.

[09:39] <Woodi> pls give me know if you notice problems. and if module will help in something then pls too :)

[09:39] *** woosley left
[09:40] <moritz> Woodi: does my IO::Socket.recv patch from yesterday night make it more useful for you?

[09:41] <szabgab> Woodi: it would be much easier for me if you blogged about it :) and if that bog was aggregared on planet six

[09:41] <szabgab> but if you give me a url I can link to Github as well

[09:43] <Woodi> szabgab: link is: https://github.com/slunski/perl6-simple-redis

[09:44] <Woodi> but still not decided where to put eventual blogs :)

[09:44] <masak> blogs.perl.org is nice.

[09:44] <masak> and easy to start using.

[09:44] <Woodi> will look

[09:45] <szabgab> Woodi: why not write a blogging platform in Perl 6 :)

[09:46] <szabgab> you could start by pre-generated html files and RSS feed so they are static for the reader

[09:46] <Woodi> szabgab: agree, definitly someone should do that :)

[09:47] <Woodi> but as for me i am terrible programmer. on the other side i can start project or two :)

[09:47] <Woodi> just porting Net::DBus looks important :)

[09:47] <szabgab> Oh I am a terrible programmer too

[09:48] <szabgab> I create bugs annoying enough for others to come in and fix them :)

[09:49] <Woodi> if it works for you then maybe it is possible to follow :)

[09:59] *** zby_home joined
[10:04] *** Chat3240 joined
[10:05] *** Chat3240 left
[10:05] *** risou is now known as risou_awy

[10:06] *** risou_awy is now known as risou

[10:12] *** lue left
[10:16] *** molaf left
[10:18] <dalek> roast: e9ba740 | moritz++ | S03-operators/buf.t:

[10:18] <dalek> roast: start to test comparison operators for Buf

[10:18] <dalek> roast: review: https://github.com/perl6/roast/commit/e9ba7406dc

[10:18] <dalek> rakudo/nom: 6fd0773 | moritz++ | src/core/Buf.pm:

[10:18] <dalek> rakudo/nom: comparison operators for Buf

[10:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6fd0773fce

[10:19] <masak> moritz: I'm thinking of spec'ing a Str $matcher form for comb. any objections?

[10:20] *** djanatyn joined
[10:20] <mberends> masak: I can't think os many cases where that would be used.

[10:20] <mberends> *of

[10:20] <moritz> nom: say 'abc'.comb('b')

[10:20] <p6eval> nom aed9fe: OUTPUT«No applicable candidates found to dispatch to for 'comb'. Available candidates are:␤:(Str, Mu %_)␤:(Str, Regex $pat, Any $limit, Any $match, Mu %_)␤:(Cool, Mu %_)␤:(Cool, Regex $matcher, Any $limit, Mu %_)␤␤  in method comb at src/gen/CORE.setting:1559␤  in <anon> at …

[10:20] <masak> mberends: I had one yesterday.

[10:20] <moritz> nom: say 'abc'.match('b')

[10:20] <p6eval> nom aed9fe: OUTPUT«b␤»

[10:21] <masak> mberends: $string.comb("1").elems # count the number of 1s in string

[10:21] <moritz> nom: say "Lasst uns die Anzahl der a's zählen'.match('a', :g).elems

[10:21] <p6eval> nom aed9fe: OUTPUT«===SORRY!===␤Confused at line 1, near "say \"Lasst"␤»

[10:21] <moritz> nom: say "Lasst uns die Anzahl der a's zählen".match('a', :g).elems

[10:21] <p6eval> nom aed9fe: OUTPUT«3␤»

[10:21] <masak> that's all fine and good.

[10:21] <moritz> masak: no objections

[10:21] <masak> \o/

[10:22] * masak makes it so

[10:22] <Woodi> nom: say "Lasst uns die Anzahl der a's zählen".match('a', :g).perl

[10:22] <p6eval> nom aed9fe: OUTPUT«Array.new(a, a, a)␤»

[10:22] <moritz> in nom I've just written a low-level Str.match(Str) that creates a Match object

[10:22] <masak> Woodi: that looks like a faulty .perl output.

[10:23] <masak> why aren't the letters quoted?

[10:23] <moritz> indeed

[10:23] * masak submits rakudobug

[10:23] <masak> also, why Array.new rather than just [] ?

[10:23] <moritz> because [] never flattens

[10:23] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; $a.match('a', :g) ; $a.WHAT;

[10:23] <p6eval> nom aed9fe:  ( no output )

[10:23] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; $a.match('a', :g) ; say $a.WHAT;

[10:24] <p6eval> nom aed9fe: OUTPUT«Str()␤»

[10:24] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; $b = $a.match('a', :g) ; say $b.WHAT;

[10:24] <p6eval> nom aed9fe: OUTPUT«===SORRY!===␤Symbol '$b' not predeclared in <anonymous> (/tmp/MDZILoYUJ6:1)␤»

[10:24] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; my $b = $a.match('a', :g) ; say $b.WHAT;

[10:24] <p6eval> nom aed9fe: OUTPUT«Array()␤»

[10:25] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; my $b = $a.count('a', :g) ; say $b;

[10:25] <p6eval> nom aed9fe: OUTPUT«Method 'count' not found for invocant of class 'Str'␤  in <anon> at /tmp/eMq5STVE0D:1␤  in <anon> at /tmp/eMq5STVE0D:1␤␤»

[10:25] <Woodi> what od .match ?

[10:25] <Woodi> s/od/do ?

[10:25] <Woodi> grrr

[10:25] <Woodi> ah, know

[10:26] <moritz> nom: say 'abc'.match('a').WHAT

[10:26] <p6eval> nom aed9fe: OUTPUT«Match()␤»

[10:26] <moritz> nom: say 'abc'.match('b').from

[10:26] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; $a.match(/[ab]/, :g) ; say $a.WHAT;

[10:26] <p6eval> nom aed9fe: OUTPUT«1␤»

[10:26] <p6eval> nom aed9fe: OUTPUT«Str()␤»

[10:26] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; $a.match(/[ab]/, :g) ; say $a.perl;

[10:26] <p6eval> nom aed9fe: OUTPUT«"Lasst uns die Anzahl der a's zählen"␤»

[10:26] *** Trashlord joined
[10:26] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; my $b = $a.match(/[ab]/, :g) ; say $b.perl;

[10:26] <p6eval> nom aed9fe: OUTPUT«[]␤»

[10:26] <moritz> Woodi: $a.match doesn't modify the string, so if you ignore the return value, there's no reason for matching at all

[10:26] <moritz> ah, you found out too :-)

[10:27] <moritz> char classes are written as <[ab]> in p6

[10:27] * moritz -> afk

[10:27] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; $a.match(/<[ab]>/, :g) ; say $a.perl;

[10:27] <p6eval> nom aed9fe: OUTPUT«"Lasst uns die Anzahl der a's zählen"␤»

[10:27] *** risou is now known as risou_awy

[10:27] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; my $b = $a.match(/<[ab]>/, :g) ; say $b.perl;

[10:27] <p6eval> nom aed9fe: OUTPUT«[a, a, a]␤»

[10:27] *** lue joined
[10:28] <Woodi> nom: my $a = "Lasst uns die Anzahl der a's zählen"; my $b = $a.match(/<[az]>/, :g) ; say $b.perl;

[10:28] <p6eval> nom aed9fe: OUTPUT«[a, z, a, a, z]␤»

[10:29] <dalek> specs: d7b5637 | masak++ | S32-setting-library/Str.pod:

[10:29] <dalek> specs: [S32/Str] added Str form to .comb

[10:29] <dalek> specs: 

[10:29] <dalek> specs: In parallel with the Str form in .split -- it's nice to have the

[10:29] <dalek> specs: few times one needs it.

[10:30] <dalek> specs: 

[10:30] <dalek> specs: Also, added the :match parameter mentioned in the text.

[10:30] <dalek> specs: review: https://github.com/perl6/specs/commit/d7b5637978

[10:30] *** wamba joined
[10:33] <masak> phenny: de en "Lasst uns die Anzahl der a's zählen"?

[10:33] <phenny> masak: "Let us count the number of a's" (de to en, translate.google.com)

[10:34] * masak thought so

[10:34] <moritz> masak: now I'd like to see tests :-)

[10:34] <masak> moritz: I'm working on tests, though not those :)

[10:34] <masak> I'm 31% through pack.t

[10:34] <moritz> wow

[10:35] <masak> 230 tests running.

[10:35] *** lue left
[10:35] <moritz> are you implementing as you go along?

[10:35] <masak> heck, no. :P

[10:35] <masak> that would be *impressive*, though.

[10:36] <masak> no, I have my hands full with "what did they actually want to test here?" and "is this still relevant for us?"

[10:36] <masak> just deleted a bunch of 'p' template tests.

[10:38] <szabgab> masak: and I did not had PErl 6 in the "what articles would you like to read" section either, now fixed that too

[10:38] <masak> szabgab: nice.

[10:38] <szabgab> I hope to reach 1000 responses but I only have 4 days :)

[10:39] <szabgab> I'll start promoting it very heavily in a few hours from now

[10:39] *** pmurias joined
[10:40] <masak> best of luck.

[10:54] <masak> what about s! et al in pack/unpack. perldoc says 'forces native (short, long, int) sizes instead of fixed (16-/32-bit) sizes'.

[10:54] <masak> I'm thinking that's another thing that doesn't apply when you're on Parrot or CLR or JVM.

[10:54] <masak> any thoughts?

[10:59] <mberends> masak: it's one of those 'can argue both ways' cases. Initially go minimalist, so drop 'em.

[11:02] <masak> aye.

[11:04] <mberends> masak: comments by moritz++ and colomon++ present a good case for a separate but related serialization/Storable spec. It would be worth collecting these kind of types to help set up that other spec, since it doesn't really exist yet apart from scattered mentions of native types in the Synopses.

[11:07] *** molaf joined
[11:08] <masak> aye. this is the thing that's related to the Compact structs in S09, right?

[11:08] * mberends reads

[11:08] <masak> "(This is to be construed as a substitute for at least some of the current uses of C<pack>/C<unpack>.)"

[11:09] <masak> whether or not it is, it feels like there's a number of ideas here that need coordinating and nurturing.

[11:11] *** Kivutarrr joined
[11:14] <mberends> yes. The C language bias in S09 should be softened to accommodate various platforms and implementations. It's interesting that jnthn++ is currently working hard on native types, and much of this arises in Niecza CLR Interop as well.

[11:17] <pmurias> mberends: what are the current problems with CLR Interop?

[11:18] <mberends> pmurias: there are issues #56 and #57 on github, sorear++ has done half a workaround for #56.

[11:21] *** lue joined
[11:22] <mberends> pmurias: I'm still exploring the CLR Interop territory, it's vast. I recently found (for the matchboxes puzzle) that Niecza has no pick or roll. I tried to use the System.Random class from Niecza and failed, that one has not been ticketed yet because there may some usual suspects still to try (I don't want to flood github issues with noise).

[11:23] *** replore joined
[11:25] *** lue left
[11:33] <pmurias> mberends: would eval(:from<c#>,...) help with anything?

[11:33] <mberends> pmurias: thanks, I never thought of that! I'll give it a try :)

[11:34] <pmurias> it's not implemented yet ;)

[11:34] <mberends> ok, tomorrow then ;)

[11:34] <pmurias> just trying to determine if i should implement that ;)

[11:35] *** type joined
[11:35] <type> o/

[11:35] <type> hello masak

[11:36] <mberends> \o type: strong or weak?

[11:36] <tadzik> duck!

[11:36] * tadzik ducks

[11:36] *** Psyche^ joined
[11:36] <type> not  strong but strange

[11:36] <type> nom: > subset Even of Int where { $_ % 2 == 0 } Even() > my Even @a  > @a=1..5 1 2 3 4 5  > my Int $x =1.3 Type check failed in assignment to '$x'; expected 'Int' but got 'Rat'  > my Int @b  > @b=(1,2.2,3) 1 2.2 3

[11:36] <p6eval> nom 6fd077: OUTPUT«===SORRY!===␤Confused at line 1, near "> subset E"␤»

[11:37] <tadzik> type: 1.3 is not an Int, hence the fail

[11:37] <tadzik> nom: say so 1.3 ~~ Int

[11:37] <p6eval> nom 6fd077: OUTPUT«Bool::False␤»

[11:37] <tadzik> it works for @b, because typed arrays are not yet implemented

[11:37] <tadzik> as in, the types are not checked

[11:38] <type> thanks !!

[11:39] <tadzik> you're welcome, glad I could help

[11:39] *** Patterner left
[11:39] *** Psyche^ is now known as Patterner

[11:39] *** wooden joined
[11:39] *** wooden left
[11:39] *** wooden joined
[11:40] <masak> type: hi there!

[11:41] <masak> mberends: I must've missed any C language bias in S09. to me it feels like the decisions about the actual memory layout belong in a repr somewhere.

[11:42] <type> hi masak: tadzik gave me the answer. thanks!!

[11:45] *** woosley joined
[11:45] *** bbkr left
[11:46] <pmurias> mberends: would eval(:lang<C#>,...) be usefull to you?

[11:46] *** bbkr joined
[11:47] *** type left
[11:49] <mberends> pmurias: It would be far from the first thing I would think of using. Without knowing the spec in enough details, I would also suspect that such code would be very unportable. It reminds of a Q:PIR() syntax that Rakudo used to have and happily got rid of. So the short answer is, probably not, except in desperate times.

[11:50] <mberends> (I've satisfied my need for random numbers with the seriously ugly now.to-posix[0].Str.comb.[*-1] %% 2)

[11:51] * masak would love to see some Apocalypses fanfic

[11:51] <masak> a really good A09, for example :)

[11:55] <pmurias> mberends: it's equaly unportable to other forms of C# interop

[11:56] <mberends> masak: "and so they went back to the bikeshed. It was blue, which jnthn always hated, but he'd been outvoted that last time they chose its color."

[11:58] <im2ee> Hmm, can i check if there is a client who is waiting to be accepted without accepting? (in IO::Socket)

[12:02] <tadzik> ...why would you need that? :)

[12:02] <ingy> o/

[12:03] <tadzik> as in, what is the problem you want to solve?

[12:03] <tadzik> ingy: o/

[12:03] <im2ee> Hmm, tadzik im training perl6. I have some ideas and i want to try them out. :)

[12:03] <tadzik> im2ee: I can see that, but why do you need to check if there's someone to accept()?

[12:03] *** drbean left
[12:03] <tadzik> im2ee: you want a non-blocking IO, maybe?

[12:04] <im2ee> tadzik, yes, something like that. :)

[12:04] <mberends> pmurias: you're right. Interop spec will only become standardized after a number of styles have been tried and compared. Styles that isolate Perl code in one file and and C# code in another file would be preferred, however.

[12:04] <im2ee> tadzik, in p6 there is no multi-threading, right? :) So i want to get around :)

[12:04] <tadzik> im2ee: IO::Select has some non-blocking IO capabilities, but I don't know how to apply them to this particular case

[12:05] <tadzik> im2ee: maybe can_read() will return your socket if it has someone to accept()?

[12:05] <tadzik> bbl

[12:05] <im2ee> tadzik, i want to make tcp server which can work with more than 1 clients. :)

[12:15] <Woodi> im2ee: on server side: accept returns new socket for each connsction probably

[12:16] <Woodi> and to switch betwin clients usually select-like is used

[12:20] *** drbean joined
[12:21] <Woodi> do threads work in parrot ?

[12:24] <im2ee> tadzik, where i can find something more informations about IO::Select? :)

[12:25] *** lue joined
[12:26] <pmurias> mberends: i don't think there is much difference between using C# code and .net specific libraries

[12:27] <jnthn> mberends: wtf, blue is my fave color! :P

[12:27] <jnthn> I mean, er, morning :)

[12:28] *** Kivutarrr left
[12:28] <pmurias> we might end up with CPAN modules that expose the interface to say GTK on multiple platforms, but programs that use interop generally won't be portable

[12:28] <mberends> jnthn: morning blues, eh?  good * anyways :)

[12:28] <tadzik> im2ee: you can read the source :)

[12:29] <tadzik> im2ee: that's precisely what IO::Select is for :)

[12:29] <pmurias> mberends: unless both implementations support interop with the same platform

[12:29] <tadzik> Woodi: threads don't

[12:29] <tadzik> im2ee: I wrote IO::Select quite recently, but without any usecase for it. If you find something that sucks, tell me, and we'll think about making it better

[12:29] <tadzik> im2ee: it's supposed to be modelled after Perl 5's IO::Select

[12:30] *** lue left
[12:33] <im2ee> tadzik, so, i can use can_read, yes?

[12:33] <tadzik> im2ee: I think so, yes

[12:37] <mberends> pmurias: I agree there is not much difference. I would just prefer to keep the two languages separate, so that changes in one file affect only the Niecza compiler and changes in the other file affect only the C# compiler. Merging them I don't prefer, which makes me feel desperate. Note that asp.net opts for language separation too, with code-behind files.

[12:39] *** lue joined
[12:44] <im2ee> b: my @tab = <a b c>; for @tab.keys { @tab.delete($_) if $_ == 'a'; }; say @tab;

[12:44] <p6eval> b 1b7dd1: OUTPUT«Any()bc␤»

[12:45] <im2ee> is there any function to clear array from Any()? :)

[12:45] <im2ee> s/of/from/

[12:46] <tadzik> not that I know of

[12:46] <jnthn> Um, is delete meant to leave it behind?

[12:46] <tadzik> maybe @tab.=grep($_)

[12:46] <tadzik> well, that'll clear it from false values

[12:46] <jnthn> *.defined

[12:46] <tadzik> jnthn: I wanted to left that as an excercise for the reader :)

[12:46] <tadzik> s/left/leave/

[12:46] <jnthn> oh, sorry :P

[12:47] <im2ee> Thanks. :)

[12:50] <im2ee> jnthn, why *.defined? Why not just .defined? :) 

[12:50] <im2ee> .defined doesn't work, but why? :)

[12:50] <tadzik> std: .defined

[12:50] <p6eval> std c22b2ee: OUTPUT«ok 00:01 118m␤»

[12:50] <tadzik> ek

[12:51] <tadzik> im2ee: .defined doesn't construct a block

[12:51] <tadzik> *.defined does

[12:51] <tadzik> .grep({ .defined }) would probably work

[12:51] <im2ee> So, clear now. :) Thanks tadzik 

[12:52] <jnthn> im2ee: { .defined } would work.

[12:52] <jnthn> *.defined is just a bit shorter...and generates better code too, iirc.

[12:53] <im2ee> Great! :)

[12:58] <masak> im2ee: the reason a block is needed is that you don't want to call .defined *right now*, you want .grep to call it when it needs to.

[13:00] <masak> im2ee: that whole idea is called a closure (or a callback), and I've written a blog post about it, if you're interested. http://strangelyconsistent.org/blog/speaking-hypothetically-in-perl-6

[13:00] <im2ee> Hmm, right, sounds logical. :) Thanks masak

[13:00] <masak> I might be biased, but I think it's a good read ;)

[13:01] <im2ee> masak, i will read it.

[13:01] <im2ee> masak, i have some other problems.

[13:01] <im2ee> masak, I want to write something like TCP server, which can work with more than 1 clients.

[13:02] <im2ee> masak, and i must to check if there is anybody who is waiting for accept.

[13:02] <im2ee> masak, can i do this without IO::Select ? :)

[13:02] <masak> im2ee: sorry, I don't know enough about TCP/IP to help you. :/

[13:05] <masak> im2ee: it sounds like you're sniffing around in the vicinity of asyncronous IO and event handling. Perl 6 is weak there at the moment.

[13:06] *** Chillance joined
[13:06] <masak> hm, it'd be a really interesting exercise to write A09. it'd have to comment a lot on the appropriate RFC's... and in order to be historically believable, it couldn't mention the @a[*-1] syntax, which was developed afterwards...

[13:07] *** larion joined
[13:07] *** larion left
[13:08] <dalek> niecza: 493fbf9 | mberends++ | examples/gtk-sierpinski.pl:

[13:08] <dalek> niecza: [examples/gtk-sierpinski.pl] refactor and tidy up source

[13:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/493fbf9d34

[13:09] <tadzik> masak: fwiw, https://metacpan.org/module/IO::Select#EXAMPLE shows the case as an example of what can be solved using select(), so maybe it's doable in nom

[13:10] <masak> nom has select()?

[13:10] <tadzik> more-less

[13:10] <tadzik> https://github.com/tadzik/IO-Select/

[13:10] <masak> in that case, more or less wow.

[13:10] <masak> tadzik++

[13:10] <tadzik> I wanted to provoke Mojolicious guys

[13:10] <masak> :)

[13:11] <masak> too bad you put it in a module, then! :P

[13:11] <tadzik> they said "we'll port it once rakudo gets non-blocking IO". Few hours later I said "your turn"

[13:11] <tadzik> still waiting for their reaction :)

[13:11] *** drbean left
[13:11] <tadzik> masak: I want it to be used in-field a bit before even thinking about making it core/speccing it

[13:11] <tadzik> no one seems to have a view on how it should work like

[13:12] <masak> nodnod

[13:12] <tadzik> so let's just use it and see what sucks

[13:12] <tadzik> Parrot was wondering for a few months "what interface should Select pmc have?"

[13:12] *** kcwu left
[13:12] <tadzik> and after some discussion we decided "let's ship it and let users criticise it"

[13:13] *** drbean joined
[13:13] *** f00li5h joined
[13:13] <tadzik> IMHO, if this interface is good enough for CPAN, it's very likely it'll be good enough for us too

[13:14] <tadzik> IO::Select is core since 5.00307 and I don't see anything that wants to replace it with something with a better interface

[13:14] <tadzik> I didn't look around much though :)

[13:14] <masak> I like that kind of thinking.

[13:15] *** lue left
[13:15] <tadzik> okay, back to sicp

[13:18] *** risou_awy is now known as risou

[13:21] *** pmurias left
[13:23] <masak> tadzik: the book or the videos?

[13:25] *** lue joined
[13:26] *** snarkyboojum left
[13:27] *** espadrine joined
[13:27] *** snarkyboojum joined
[13:27] <cognominal> ingy, no Chartreuse hangover?

[13:35] *** lue left
[13:38] *** pmurias joined
[13:39] <felher> nom: state $blar;

[13:39] <p6eval> nom 6fd077: OUTPUT«(signal SEGV)»

[13:40] <jnthn> epic fel

[13:40] <felher> :)

[13:40] <pmurias> in roast/S01-perl-5-integration/basic.t a p5 routine exposed to perl6 has wantarray

[13:40] * masak submits rakudobug

[13:41] <pmurias> with the way context work in Perl 6 now is there a way to make that work?

[13:41] <masak> pmurias: doesn't feel like it.

[13:41] *** envi left
[13:41] <masak> or maybe Perl 6 callers always wants the same thing nowadays.

[13:41] <masak> want*

[13:42] *** envi joined
[13:42] <masak> haven't thought about it.

[13:42] <pmurias> it doesn't seem to be a thing that should be tested for in a basic test

[13:43] <masak> nom: sub foo { state $blar = "OH HAI"; say $blar }; foo

[13:43] <p6eval> nom 6fd077: OUTPUT«OH HAI␤»

[13:44] <jnthn> masak: It's some oddity in the mainline.

[13:44] <pmurias> should i take it out?

[13:44] <jnthn> masak: Seen it before, evidently forgot to fix it.

[13:44] <masak> pmurias: +1

[13:44] <jnthn> tickets++

[13:45] <pmurias> did blitzkost have tests of it's own?

[13:45] *** woosley left
[13:52] *** lue joined
[13:56] *** zby_home_ joined
[13:56] *** zby_home left
[14:00] *** lue left
[14:02] *** grondilu joined
[14:04] <grondilu> So can't I provide arguments to a sub that has been defined as 'sub foo { }'?  I mean, prototyping is mandatory now?

[14:05] <grondilu> please don't answer all at once :)

[14:05] <benabik> You can get around it some by…  sub foo(|$c) { }, IIRc

[14:05] <benabik> Which declares a capture that grabs all the arguments.

[14:06] <grondilu> well, yeah but that's 4 additional characters to type :(

[14:07] <masak> grondilu: you must like the Perl 5 parameter handling very much ;)

[14:07] <benabik> Someone has to.  :-D

[14:07] <grondilu> masak: I do indeed

[14:08] <jnthn> grondilu: You have a lot of use cases where you want to take arguments and ignore them?

[14:08] <grondilu> I like the forth-like aspect of not having to worry about argument passing.

[14:08] <benabik> sub foo { $^these + $^are + $^parameters }

[14:08] <masak> grondilu: well, 5 (by my count) extra characters is the "tax" you have to pay in Perl 6 so that the rest of us can have sane argument handling.

[14:09] <jnthn> 4 

[14:09] <grondilu> For simple functions I mean.  Of course, prototyping is necessary for complex stuffs.

[14:09] <jnthn> (|$)

[14:09] <jnthn> Don't need to name the variable you stick the capture in if you don't want it.

[14:09] <masak> jnthn: yeahbut.

[14:09] <grondilu> jnthn: cool

[14:09] <masak> how will you extract the arguments from that?

[14:09] <benabik> Why have a function that takes arguments that you can never get to?

[14:09] <masak> exactly.

[14:10] <benabik> grondilu: You can declare parameters inside your function.  sub add { $^a + $^b }

[14:10] <grondilu> ?

[14:10] <jnthn> Also note that

[14:10] <jnthn> rakudo: sub foo { say @_ }; foo; foo(1,2,3)

[14:10] <p6eval> rakudo 6fd077: OUTPUT«␤1 2 3␤»

[14:10] * grondilu doesn't know about $^

[14:10] <jnthn> If you mention @_ anywhere in your sub body, then it automatically generates a signature for you of (*@_)

[14:10] <masak> rakudo: sub add { $^a + $^b }; say add 4, 5

[14:10] <p6eval> rakudo 6fd077: OUTPUT«9␤»

[14:11] <grondilu> jnthn: even cooler

[14:11] <masak> jnthn: oh, I forgot about that! that should make grondilu very happy.

[14:11] <benabik> jnthn: Does the same happen with %_?

[14:11] <jnthn> Also note that if what you really want is a closure, Perl 6 doesn't require you to write "sub"

[14:11] <jnthn> benabik: Yes

[14:11] <flussence> rakudo: sub add { my $a = shift; my $b = shift; }; say add(4, 5)

[14:11] <p6eval> rakudo 6fd077: OUTPUT«Too many positional parameters passed; got 2 but expected 0␤  in sub add at /tmp/Hze8d7ImSG:1␤  in <anon> at /tmp/Hze8d7ImSG:1␤  in <anon> at /tmp/Hze8d7ImSG:1␤␤»

[14:11] <flussence> rakudo: sub add { @_; my $a = shift; my $b = shift; }; say add(4, 5)

[14:11] <p6eval> rakudo 6fd077: OUTPUT«No applicable candidates found to dispatch to for 'shift'. Available candidates are:␤:(Positional @a)␤␤  in sub shift at src/gen/CORE.setting:4222␤  in sub add at /tmp/iRtE0BPsUH:1␤  in <anon> at /tmp/iRtE0BPsUH:1␤  in <anon> at /tmp/iRtE0BPsUH:1␤␤»

[14:11] <flussence> oh.

[14:11] <jnthn> flussence: No implicit argumetns.

[14:11] <jnthn> *arguments

[14:12] <flussence> rakudo: sub add { my $a = shift @_; my $b = shift @_; }; say add(4, 5)

[14:12] <p6eval> rakudo 6fd077: OUTPUT«5␤»

[14:12] <flussence> close enough

[14:12] <masak> algorithm fail ;)

[14:12] <jnthn> Saturating add :P

[14:12] <flussence> rakudo: sub add { [+]@_ }; say add(4, 5)

[14:12] <p6eval> rakudo 6fd077: OUTPUT«2␤»

[14:12] <flussence> :(

[14:12] <benabik> rakudo: sub foo { $_ = @_; my $a = .shift; say $a }; foo 5

[14:12] <p6eval> rakudo 6fd077: OUTPUT«5␤»

[14:12] <benabik> :-D

[14:13] <grondilu> :)

[14:13] <flussence> rakudo: sub add { [+](|@_) }; say add(4, 5)

[14:13] <p6eval> rakudo 6fd077: OUTPUT«Could not find sub &prefix:<|>␤  in sub add at /tmp/AucDj7Fdd4:1␤  in <anon> at /tmp/AucDj7Fdd4:1␤  in <anon> at /tmp/AucDj7Fdd4:1␤␤»

[14:13] <benabik> rakudo: sub add { [+] @_ }; say add(4, 5)

[14:13] <jnthn> er, why on earth did [+] @_ not work...

[14:13] <p6eval> rakudo 6fd077: OUTPUT«2␤»

[14:13] <flussence> b: sub add { [+]@_ }; say add(4, 5)

[14:13] <p6eval> b 1b7dd1: OUTPUT«9␤»

[14:13] <masak> nom: sub add { [+](@_) }; say add 4, 5

[14:13] <p6eval> nom 6fd077: OUTPUT«2␤»

[14:13] <benabik> nombug?

[14:13] * masak submits rakudobug

[14:13] <jnthn> nom: sub add(*@x) { [+] @x }; say add 4, 5

[14:13] <p6eval> nom 6fd077: OUTPUT«9␤»

[14:15] <benabik> A bug in the implicit @_?

[14:15] <grondilu> raduko: sub add { [+]@_ }; say add 1, 1

[14:15] <grondilu> rakudo: sub add { [+]@_ }; say add 1, 1

[14:15] <TimToady> std: sub add { [+]@_ }; say add(4, 5)

[14:15] <p6eval> rakudo 6fd077: OUTPUT«2␤»

[14:15] <p6eval> std c22b2ee: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row at /tmp/7tqKXg2sdR line 1:␤------> [32msub add { [+][33m⏏[31m@_ }; say add(4, 5)[0m␤    expecting any of:␤    POST␤   bracketed infix␤        infix or meta-infix␤    postfix␤        postfix_prefix_meta_operator␤  

[14:15] <p6eval> ..prefix_circumfix_meta_o…

[14:15] <jnthn> benabik: Yeah, that's my guess

[14:15] <TimToady> space required after a reduce

[14:15] <grondilu> rakudo: sub add { [+] @_ }; say add 1, 1

[14:15] <masak> fairy nuff.

[14:15] <p6eval> rakudo 6fd077: OUTPUT«2␤»

[14:16] <grondilu> rakudo: sub add { [+] @_ }; say add 1, 42

[14:16] <p6eval> rakudo 6fd077: OUTPUT«2␤»

[14:16] <benabik> Two bugs!  Parsing can @_ not working right in a reduce.

[14:16] <benabik> s/can/and/, wtf keyboard?

[14:17] <masak> aye.

[14:17] <flussence> b: sub add { [+] @_[0..*] }; say add(4, 5)

[14:17] <jnthn> benabik: It's not reduce

[14:17] <jnthn> benabik: It's something about the binding.

[14:17] <flussence> er...

[14:17] <p6eval> b 1b7dd1: OUTPUT«(timeout)»

[14:17] <TimToady> extra capture parens?

[14:17] <jnthn> git stash

[14:17] <jnthn> er, wrong window

[14:17] <flussence> rakudo: sub add { [+] @_[0..*] }; say add(4, 5)

[14:17] <p6eval> rakudo 6fd077: OUTPUT«9␤»

[14:18] <jnthn> TimToady: Almost certainly a failure to set a flatten flag or something like that.

[14:18] * masak removes all jnthn's changes and hides them

[14:18] <TimToady> not marked as flatten

[14:19] <flussence> well I've managed to break both rakudo branches today, that's an achievement :)

[14:19] <jnthn> TimToady: Forget exactly how it works. Do know that we're not telling the binder something we should be by looking at the code though...

[14:20] <jnthn> nom: ({ say [+] @^a })([1,2,3])

[14:20] <p6eval> nom 6fd077: OUTPUT«3␤»

[14:21] <jnthn> nom: (sub (@a) { say [+] @a })([1,2,3])

[14:21] <p6eval> nom 6fd077: OUTPUT«6␤»

[14:21] <jnthn> Yeah, same issue there.

[14:21] <jnthn> Fixed locally, spectesting.

[14:22] *** envi left
[14:22] <jnthn> At least this was easier to find than whatever's wrong in my explosive multi-dispatch patches.

[14:22] *** donri joined
[14:23] <grondilu> rakudo: { say [+]@_ }(42, 1)

[14:23] <p6eval> rakudo 6fd077: OUTPUT«2␤»

[14:23] <grondilu> it does work on my machine

[14:24] <pmichaud> good morning, #perl6

[14:24] <jnthn> grondilu: Yes, I guess you're running from a released Rakudo.

[14:24] <grondilu> "This is Rakudo Perl 6, version 2011.07 built on parrot 3.6.0 0"

[14:24] <jnthn> grondilu: You just helped us find a regression in the current development branch. So, thanks! :-)

[14:24] <jnthn> o/ pmichaud 

[14:25] <grondilu> lol, glad to have helped :)

[14:25] <masak> grondilu++

[14:25] * grondilu is very enthusiastic about Perl and Perl6

[14:25] <grondilu> I just love this language

[14:25] <masak> we share your enthusiasm :)

[14:25] <flussence> perl6: sub add { [+]@_ }; sub add2 { [+]@_[0..*] }; say add(4, 5); say add2(4, 5); #j/w

[14:26] <p6eval> rakudo 6fd077: OUTPUT«2␤9␤»

[14:26] <p6eval> ..niecza v9-51-g493fbf9: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row at /tmp/HGOaEiD2Ua line 1:␤------> [32msub add { [+][33m⏏[31m@_ }; sub add2 { [+]@_[0..*] }; say add([0m␤␤Parse failed␤␤»

[14:26] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "@_"␤    expecting dot, ":", "(", term postfix, operator or "}"␤    at /tmp/vWoyH1wAvI line 1, column 14␤»

[14:26] <flussence> hm

[14:26] <flussence> perl6: sub add { [+] @_ }; sub add2 { [+] @_[0..*] }; say add(4, 5); say add2(4, 5);

[14:26] <p6eval> rakudo 6fd077: OUTPUT«2␤9␤»

[14:26] <p6eval> ..niecza v9-51-g493fbf9: OUTPUT«(timeout)9␤»

[14:26] <p6eval> ..pugs: OUTPUT«9␤9␤»

[14:26] <flussence> oh wow, I broke niecza too

[14:27] <dalek> rakudo/nom: efe3f82 | jnthn++ | src/Perl6/Actions.pm:

[14:27] <dalek> rakudo/nom: Fix bug with placeholder parameter binding of arrays.

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/efe3f82923

[14:31] *** lue joined
[14:34] <grondilu> got to go.  Keep on the good work guys!

[14:34] *** grondilu left
[14:46] *** whiteknight joined
[14:47] *** lue left
[14:50] *** satyavvd joined
[14:51] <sorear> good * #perl6

[14:51] <masak> *

[14:51] <colomon> */

[14:52] *** im2ee left
[14:54] <pmurias> sorear: hi

[14:56] <sorear> pmurias: the .net platform does not come with a C# compiler, and bundling Mono.CSharp.dll would double the size of the niecza package

[15:04] *** kaare_ left
[15:06] *** im2ee joined
[15:08] <pmurias> sorear: i'll work on more usefull thing for now then

[15:08] <pmurias> sorear: does niecza work on .net?

[15:08] <tadzik> masak: the book 'fcourse

[15:10] *** pmurias_ joined
[15:10] * colomon just uttered the words "It seems like it's random whether or not it happens" and immediately launched valgrind on his $work bug from hell.

[15:12] <masak> tadzik: nice! godspeed.

[15:13] *** pmurias left
[15:17] *** lue joined
[15:26] *** lue left
[15:26] <tadzik> seems that guile uses Rats for calculations as well

[15:28] *** satyavvd left
[15:29] *** MayDaniel joined
[15:30] <masak> tadzik: Lisp people are pretty proud of their http://en.wikipedia.org/wiki/Numerical_tower

[15:30] *** pmurias joined
[15:31] *** MayDaniel left
[15:32] <tadzik> I ended up writing my (define (numify x)) :)

[15:32] *** birdwindupbird joined
[15:32] *** birdwindupbird left
[15:33] *** pmurias_ left
[15:36] *** mj41 joined
[15:36] <pmichaud> general note:  I'm still tuit deprived.  Yesterday ended up not being a very good day.  :-/

[15:37] <pmichaud> s/not being/being not/

[15:37] <mberends> :(

[15:37] <colomon> :(

[15:38] *** lue joined
[15:44] * colomon has found his $work bug, which appears to be something colossally stupid he did nearly a decade ago...

[15:45] <dalek> rakudo/nom: c4c2e1d | jnthn++ | src/binder/bind. (2 files):

[15:45] <dalek> rakudo/nom: Move/share a struct definition.

[15:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c4c2e1d80d

[15:45] <dalek> rakudo/nom: 03afd02 | jnthn++ | src/binder/ (2 files):

[15:45] <dalek> rakudo/nom: Switch junctional arguments check in multi-dispatcher over to being able to cope with natively typed arguments.

[15:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/03afd0274e

[15:45] <dalek> rakudo/nom: 9e831e0 | jnthn++ | src/binder/multidispatch.c:

[15:45] <dalek> rakudo/nom: Tweak the multi-dispatch candidate check to try and make it aware of native types.

[15:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9e831e0d56

[15:45] <pmichaud> afk again

[15:46] *** huf joined
[15:48] <masak> pmichaud: :(

[15:50] * [Coke] yawns.

[15:55] <mberends> masak: this was around the time I'd suggested for pugs and haskell exploration, primarily because I thought it stood a good chance of being possible for others too. I could also make other times. I'm now writing a GUI solution for your matchboxes puzzle, but am happy to look at pugs any time.

[15:56] <masak> mberends: cool.

[15:56] <mberends> masak: shall we look at pugs in, say, an hour?

[15:57] *** pmurias_ joined
[15:57] <masak> mberends: hm. I was planning to go out for a run around that time.

[15:57] <mberends> masak: ok, what time suits you?

[15:58] <masak> but sometime during the evening I think I could have some time to download Pugs and try to get it to run.

[15:58] <masak> mberends: mostly I'd like to see you and [Coke] agree on a time that works for both of you.

[15:58] <masak> right now I'm going AFK for ~30 minutes.

[15:58] <mberends> ok, me too

[15:59] *** pmurias left
[16:03] *** lue left
[16:10] * japhb has a lot to backlog ... anyone happen to know if my question last night about how to assign $?USAGE properly in the Rakudo setting got answered?  (By the time I finish backlogging, the people who could answer will probably be gone :-/ (

[16:13] *** pmurias joined
[16:14] *** espadrine left
[16:14] *** im2ee left
[16:14] *** im2ee joined
[16:16] *** pmurias_ left
[16:19] *** lue joined
[16:19] *** envi joined
[16:20] <dalek> rakudo/nom: 8b7a2a5 | jnthn++ | src/binder/multidispatch.c:

[16:20] <dalek> rakudo/nom: Get multi-dispatch cache to handle natively typed arguments.

[16:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b7a2a5a7a

[16:21] <japhb> jnthn++ is awake!

[16:21] <jnthn> japhb: I didn't answer it...but I probably could ;)

[16:21] <japhb> jnthn, Once I have the message string, how do I create the $?USAGE variable in Rakudo, and set it to my newly-minted message? (In the setting, of course)

[16:21] <jnthn> nom: say $?USAGE

[16:21] <p6eval> nom 9e831e: OUTPUT«===SORRY!===␤Symbol '$?USAGE' not predeclared in <anonymous> (/tmp/7eqQXlAlF_:1)␤»

[16:21] <japhb> jnthn, thx

[16:21] <jnthn> japhb: Is it actually meant to live in the setting?

[16:21] <jnthn> Not just in the mainline of the user's program?

[16:22] * jnthn had assumed it was the latter

[16:23] <japhb> IIUC, the main helper generates it, and sets it ... in *some* scope ... such that the user's MAIN and USAGE can see it.  But I don't know what that scope should be.

[16:23] <japhb> I meant "assigning it from within code that exists in the setting"

[16:24] <jnthn> ah, here's the bit of S06...

[16:24] <jnthn> This usage message is automatically generated from the signature (or

[16:24] <jnthn> signatures) of C<MAIN>.  This message is generated at compile time,

[16:24] <jnthn> and hence is available at any later time as C<$?USAGE>.

[16:24] *** Maddingue joined
[16:25] * japhb has been updating MAIN_HELPER() in src/core/Main.pm.

[16:25] <jnthn> oh

[16:25] <jnthn> it does

[16:25] <jnthn> my $m = callframe(1).my<&MAIN>;

[16:25] <japhb> right

[16:25] <jnthn> In theory

[16:26] *** lue left
[16:26] <jnthn> callframe(1).my<$?USAGE> = $the_message

[16:26] <jnthn> However, you need to make sure a $?USAGE variable exists to stick the thing in

[16:26] <jnthn> That can probably be done by editing Actions.pm

[16:26] <jnthn> There's a

[16:26] <jnthn> if $unit.symbol('&MAIN') {

[16:27] <jnthn> Which adds the call to &MAIN_HELPER

[16:27] <japhb> The current flow in my version is: 1. Fetch MAIN, 2. process cmdline args, 3. generate usage message, 4. attempt to dispatch to matching &MAIN, 5. Failing that, attempt to call &USAGE, 6. Failing that, print generated usage message and exit.

[16:27] <jnthn> It could also add code to declare the variable.

[16:27] <japhb> OK, understood so far.

[16:27] <jnthn> Thing is, the spec implies that we figure out the usage message at compile time.

[16:28] <jnthn> Heh

[16:28] <jnthn> I wonder what happens if we add a .usage() method into Routine ;)

[16:28] <jnthn> So you can generate usage for anything <grin>

[16:28] * japhb chuckles

[16:28] <jnthn> Anyway, the beneift would be that the compiler could do

[16:29] <jnthn> my $message = $*ST.find_symbol('&MAIN').usage();

[16:29] <jnthn> Then create a constant

[16:29] <jnthn> And bind it (again, at compile time) to $?USAGE

[16:29] <jnthn> :)

[16:29] <jnthn> (Just using the same static lexpad mechanism we use to install all other declarational things).

[16:29] <jnthn> That was, if somebody writes

[16:30] <jnthn> sub USAGE() {

[16:30] <jnthn>     say "OH LOOK HERE'S SOME HELP";

[16:30] <jnthn>     say $?USAGE

[16:30] <jnthn> }

[16:30] <jnthn> Then it'll all work out.

[16:30] <jnthn> s/was/way/

[16:30] <jnthn> (Essentially, you're running the code to generate the usage message at BEGIN time.)

[16:31] <japhb> Ah, I thought all that was necessary for *that* to work was to "declare" $?USAGE in the compiler, and have it *assigned* in MAIN_HELPER ... because USAGE is called from MAIN_HELPER.  Though I suppose

[16:31] <jnthn> Well, we could do that too.

[16:31] <japhb> the mainline code could have called USAGE manually, and the user might be surprised it's not there, because MAIN_HELPER never got called

[16:31] <jnthn> Right.

[16:31] <jnthn> Also

[16:31] <jnthn> We may need to twiddle the way we find &MAIN

[16:32] <jnthn> As this is also meant to work:

[16:32] <jnthn> class Foo {

[16:32] <jnthn>     sub MAIN() { ... }

[16:32] <jnthn> }

[16:32] <jnthn> e.g. MAIN is allowed to be somewhere other than in the mainline.

[16:33] <tadzik> wow, that's specced?

[16:33] <jnthn> I think the easiest way to do that is to have a :my $*MAIN; declared in comp_unit in the grammar

[16:33] <japhb> oh.  Hmmm.  So how would the compiler know which MAIN to generate $?USAGE from at compile time?

[16:33] <jnthn> And routine_def looks for if the thing is called MAIN when doing symbol installation and shoves a reference to it in $*MAIN

[16:33] <jnthn> tadzik: I thought so.

[16:33] <jnthn> tadzik: Or I seem to recall TimToady++ expecting it would work, at least.

[16:33] <tadzik> I see

[16:34] <jnthn> I guess that

[16:34] <jnthn> class A { sub MAIN() { } }

[16:34] <japhb> Would the compiler need to generate a $?USAGE for each comp_unit, and have them all separate?

[16:34] <jnthn> class B { sub MAIN() { } }

[16:34] <jnthn> Would be an error.

[16:34] <jnthn> (Ambiguous MAIN)

[16:34] <jnthn> japhb: comp_unit is kinda top-level :)

[16:34] <japhb> jnthn, I'm more worried about 

[16:34] <japhb> ...hold, child hurt

[16:34] <jnthn> ouch

[16:35] <japhb> ah, more hurt pride than body

[16:35] <jnthn> ah, phew

[16:35] <japhb> quite

[16:37] <japhb> So: My reading of the spec was that every module might define a MAIN for self-testing or magic behavior, Python-style, but they also might be 'use'd into another module or even the mainline program, all of which might define their own MAIN.  So it's only after all compiling is done and runtime begins (or according to spec, when runtime falls off the end of the "main" programs mainline, that MAIN is checked for and called.

[16:38] *** mj41 left
[16:38] <japhb> But ... the mainline code could call USAGE manually.  So when is the decision made about which MAIN the $?USAGE is set from

[16:38] <japhb> ?

[16:38] <jnthn> I don't think there's a problem (more)

[16:39] <jnthn> If $?USAGE is a lexical in the mainline, and there's one MAIN per compilation unit too, then MAIN_HELPER is going to see the correct lexical scope.

[16:40] <jnthn> e.g. it gets called from the lexical scope of the program; callframe looks 1 frame down, which will be the mainline with the correct $?USAGE in.

[16:40] <japhb> Ah, OK.  So each comp_unit gets a $?USAGE lexical.  I can see that making perfect sense

[16:40] *** uasi left
[16:40] <jnthn> Yes, I think so.

[16:41] <japhb> It also has the advantage that all modules will know the $?USAGE of their MAIN, even if they aren't the mainline.

[16:42] <jnthn> Yes.

[16:44] <jnthn> oh noes, I'm out of curry paste

[16:44] <jnthn> shop, bbl &

[16:44] <japhb> OK, so lessee.  (thinking aloud) If as you suggest we add a .usage to Routine, I could do two branches in the code: if it's a proto, pull .usage from each candidate, and join with 'or' or somesuch; if its not a proto, generate the calling info from the signature.  Hmmm, I wonder if I need to return back something more than a simple string, because

[16:44] <jnthn> oh, can wait a moment actually... :)

[16:44] <japhb> It may be desirable to have a top section of the summary and a bottom section explaining aliases and such.

[16:44] <jnthn> Hmm...I was thinking a string would be enough for now.

[16:45] <japhb> The current MAIN_HELPER code tries to do something like that, but I'm not sure yet whether to drop that and just return a string, or keep supporting it.

[16:45] <jnthn> If people want something much fancier that's what USAGE is for.

[16:45] <japhb> jnthn, sure ... but the question is, would .usage need to return more complex information that USAGE needs?

[16:45] <japhb> I guess we can play that by ear.  :-)

[16:45] <jnthn> Yeah, I think so.

[16:46] <jnthn> (play that by ear, that is)

[16:46] <japhb> thx for all the answers

[16:47] <jnthn> Welcome. Thanks for hacking on this :)

[16:50] <japhb> afk for a few &

[16:50] <jnthn> really going to shop &

[16:55] *** Trashlord left
[16:56] *** wolfman2000 left
[17:01] *** replore left
[17:08] *** wamba left
[17:08] *** risou is now known as risou_awy

[17:08] *** risou_awy is now known as risou

[17:10] *** ZapZ_ left
[17:14] *** carlin left
[17:15] *** carlin joined
[17:15] *** carlin left
[17:16] *** carlin joined
[17:16] *** carlin left
[17:17] *** lue joined
[17:17] *** carlin joined
[17:21] *** lue left
[17:24] *** risou is now known as risou_awy

[17:32] *** envi left
[17:36] *** daniel-s left
[17:51] *** lue joined
[17:53] <mberends> GUI solution for masak's matchboxes puzzle on Niecza: https://gist.github.com/1240895

[17:54] *** kaare_ joined
[17:54] <colomon> mberends++

[17:56] <mberends> sorear++

[17:56] *** lue left
[18:11] *** cognominal left
[18:11] <masak> mberends: wow -- looks cool! I wish I could run it.

[18:12] *** cognominal joined
[18:12] <mberends> masak: try installing another Ubuntu or Debian guest VM, when you have time

[18:16] *** cognominal_ joined
[18:19] *** cognominal left
[18:20] *** colomon left
[18:21] *** lue joined
[18:24] *** soh_cah_toa joined
[18:27] *** colomon joined
[18:32] <masak> mberends: will do.

[18:34] <mberends> masak: ok. I looked into audreyt's github repo list, and there is a pugs repo that looks unchanged since 2006 and a Pugs.hs that seems to be actively maintained. We probably need the latter.

[18:37] *** cognominal_ left
[18:37] *** cognominal_ joined
[18:38] <masak> nod.

[18:38] <masak> I concluded the same.

[18:41] <Tene> jnthn: you might also consider changing the spec, and divorcing "Run this when the module is loaded" from "Run this when this file is passed as the first argument to a perl interpreter"

[18:41] <Tene> Perhaps both of those are aliased to the same code by default.

[18:42] <Tene> MAIN vs LOAD or something

[18:43] *** pmurias_ joined
[18:45] *** pmurias left
[18:55] <jnthn> Tene: Hmm, interesting thought.

[19:11] <jlaire> compiling pugs on this laptop is taking a while... :)

[19:14] <jlaire> Pugs.hs on github seems to match the pugs package on hackage

[19:14] <jlaire> so it's definitely the right one

[19:15] <benabik> Looks like audreyt tried compiling it yesterday and discovered some updates were needed.

[19:16] <jlaire> hmm, I should update my ghc

[19:17] <benabik> Looks like the Haskell Platform release has been somewhat delayed.

[19:17] *** thou joined
[19:18] <jlaire> I've never tried the platform

[19:18] <benabik> It's GHC + cabal + useful libraries.  Something like:  Platform : GHC :: Star : Rakudo

[19:19] <mberends> according to pugs/README ghc 6.10 is sufficient, I'm using Ubuntu's 6.12.3 but not getting very far yet.

[19:19] <benabik> The webpage says the next release is July 2011, so I'm guessing there's a delay, but I don't see any mailing list or discussion links.

[19:19] <jlaire> yeah, but installing ghc and libraries separately has been very painless for me

[19:20] <jlaire> I have GHC 7.0.3

[19:20] <benabik> It's been convenient for me, lacking a proper package manager.  :-/

[19:20] <jlaire> :/

[19:20] <jlaire> fortunately for me, haskell is very well supported on arch linux

[19:21] *** pmurias joined
[19:22] <mberends> 'cabal install HTTP zlib' went very well, now trying 'cabal install Pugs'

[19:23] *** pmurias_ left
[19:26] *** wallberg joined
[19:30] *** furura joined
[19:31] <mberends> hmm, Pugs install failed because terminfo failed to  install, and terminfo failed because curses.h was not found. Installing libncurses5-dev in hope..

[19:31] <benabik> Down the dependency rabbit hole.

[19:34] <jlaire> real 35m22.509s

[19:34] <jlaire> works for me

[19:35] <mberends> jlaire: is that with cabal or make?

[19:35] <jlaire> mberends: cabal

[19:35] <jlaire> I ran 'cabal install' in  Pugs.hs/Pugs

[19:36] <jlaire> and have a working pugs repl now

[19:36] <jlaire> mberends: what platform are you on?

[19:36] <mberends> jlaire: here too, Ubuntu 11.04 x86. cabal seems to ignore the current directory and build everything in ~/.cabal, which is unsuitable for hacking.

[19:37] <jlaire> :S

[19:38] <masak> I was just wondering whether that might happen.

[19:38] *** abercrombie joined
[19:38] <masak> cabal is nice and all... for end users.

[19:39] *** packetknife joined
[19:39] <mberends> error [37 of 89] ... src/Pugs/AST/Internals/Instances.hs:216:9 No instance for (Typeable Unique) ...

[19:39] <masak> aww

[19:40] <mberends> since Pugs obvious builds on some platforms, I hereby deem this platform unusable. :(

[19:40] <masak> wait, but that's a *compile* error.

[19:40] <jlaire> might be differences between old/new ghc or base libraries

[19:40] <masak> shouldn't that depend more on the compiler than on the platform?

[19:41] <jlaire> yep

[19:41] <jlaire> but installing up-to-date haskell environment is easier on some platforms than others

[19:41] <mberends> base libs, most likely. There was a 'base 3.0 deprecated' warning during the building of deps.

[19:42] <benabik> Pugs.hs master says "build-depends: base >= 4"

[19:43] * mberends thinks 'cabal upgrade base'

[19:43] <jlaire> why does it start compiling with unsatisfied dependencies :?

[19:44] <masak> mberends++ # explorer

[19:51] <benabik> That is what's on github.  Perhaps it's not what cabal is using.

[19:51] <jlaire> cabal uses *.cabal in the current directory

[19:52] <masak> I thought that was the point of the Pugs.hs repo.

[19:52] <jlaire> if you say just 'cabal install'

[19:52] <benabik> I said perhaps…  Haven't used cabal myself.

[19:53] <mberends> cabal download Pugs 6.2.13-20110925, that is only a few hours old

[19:53] *** Chat4236 joined
[19:54] <dalek> Heuristic branch merge: pushed 121 commits to rakudo/optimizer by jnthn

[19:54] <Chat4236> hey

[19:54] <masak> Chat4236: hi!

[19:54] <masak> Chat4236: I see you're a Chatmosphere user. welcome.

[19:55] <Chat4236> hey

[19:55] <masak> Chat4236: this is a very friendly, accomodating channel. we like visitors. but I should warn you: it's about Perl 6.

[19:55] <Chat4236> thnx

[19:55] <masak> there, you have been warned.

[19:56] <Chat4236> perl 6?

[19:56] <Chat4236> wats dat?

[19:56] <masak> Chat4236: Chatmosphere users often miss this fact, and embarass themselves by asking "where are the chicks" and similar things.

[19:56] <masak> Chat4236: it's a programming language, like Python or C.

[19:56] <Chat4236> kBoy gets into bed :*  with a girl and notice her clean shaved vagina:O .n asks 'baal kyon nahi hain'.=-?  she replies-'tu sex karne aaya hai ya kangi ??':x

[19:57] <Chat4236> hehe

[19:57] <masak> ok, that would be an example of inappropriate behavior.

[19:57] <mberends> Chat4236: we don't want that kind of chat here

[19:57] <Chat4236> k

[19:57] *** Chat4236 left
[19:57] <flussence> good thing you got the first word in. My first instinct would be to disembowel such people with a blunt object...

[19:57] <benabik> Why do Chatmosphere users keep showing up here?

[19:57] <tadzik> a frying pan

[19:57] <tadzik> benabik: a Chatmosphere dev hates us

[19:58] <masak> tadzik: oh?

[19:58] <tadzik> masak: just a guess

[19:58] <jnthn> Good theory :)

[19:58] <masak> I thought it was just randomizing channels on freenode.

[19:58] <jnthn> "How can I make Perl 6 take even longer?" "oooh...I know..."

[19:58] <flussence> more likely it was written by someone with no clue how IRC works, so they just have a "random server/channel" option

[19:58] <masak> right.

[19:59] <benabik> flussence: The chatmosphere.org website has a big "Random selection of chatrooms" on the front page, so it seems you're likely correct.

[19:59] <benabik> "On the home screen on the app there is a random list of popular chatrooms."

[19:59] * benabik sighs.

[20:00] *** SHODAN left
[20:01] <flussence> ) # fixing that quit message

[20:02] *** saaki left
[20:02] <flussence> .oO( and now I've broken it for people who hide quit messages... )

[20:04] <masak> "Hi Chatmosphere. We'd like you to exclude our channel from your random channel selection. Neither we nor your users enjoy the others' company."

[20:05] <benabik> masak++

[20:09] <soh_cah_toa> ok, i have to ask b/c it's bothering the heck outta me: why do i always see people using .oO(blah blah blah)? what in the world is that?

[20:09] <masak> soh_cah_toa: thought bubbles.

[20:09] <masak> soh_cah_toa: like in comics.

[20:10] * mberends has no options left except 'cabal install cabal-install', to *upgrade* from the existing Ubuntu-supplied cabal-install

[20:10] <masak> :)

[20:11] *** mj41 joined
[20:12] *** fridim_ joined
[20:13] <soh_cah_toa> ah, i see

[20:15] <mberends> failed. 'cabal install base' dies with Distribution/Client/Dependency/TopDown.hs:169:37-73: Non-exhaustive patterns in lambda, and 'cabal upgrade base' dies with fromFlag NoFlag. Use fromFlagOrDefault, about which StackOverflow basically said 'ur Linux is doin it rong'. This is the end of the road for GHC 6.x on Ubuntu.

[20:15] *** lue left
[20:17] <pmurias> is Ada95 a sensible language to learn?

[20:17] <benabik> Ada?

[20:17] <tadzik> nqp: my @a := []; @a.push(2); @a.push(7); say(@a[-1]) # intentional?

[20:17] <p6eval> nqp: OUTPUT«7␤»

[20:17] <tadzik> that's not really Perl6-y

[20:17] <benabik> 95?

[20:17] <pmurias> we have a parrallel ai algorithm course in uni which uses Ada95

[20:18] <soh_cah_toa> wow

[20:18] <soh_cah_toa> i would expect common lisp or scheme for a course like that

[20:18] <jlaire> if the focus is on algorithms, ada is fine imo

[20:18] <jlaire> weird choice tho

[20:21] <soh_cah_toa> http://nopaste.snit.ch/81994

[20:21] <soh_cah_toa> i could use some advice on that. i'm trying to test that my module exports it's subroutines properly

[20:22] <mberends> pmurias: gnat, the GNU Ada compiler, is very actively maintained, which suggests a lot of use as well, so it seems a good idea. Ada support real-time processing too. Main Ada site: http://www.adaic.org/

[20:22] <benabik> I _think_ that use and export just make the names visible, not add them to the namespace.

[20:22] <benabik> *current namespace

[20:22] *** lue joined
[20:23] <im2ee> Good night! :)

[20:23] <ingy> cognominal_: strangely no Chartreuse hangover!

[20:23] *** im2ee left
[20:24] <cognominal_> :)

[20:24] *** packetknife left
[20:25] *** soh_cah_toa_ joined
[20:25] * soh_cah_toa_ hates his laptop battery

[20:25] <soh_cah_toa_> anyway...

[20:26] *** soh_cah_toa left
[20:27] *** mkramer1 joined
[20:27] *** soh_cah_toa_ is now known as soh_cah_toa

[20:28] <soh_cah_toa> so 'use' doesn't import subs into the current namespace? that's...weird

[20:28] <soh_cah_toa> then i guess the keyword 'export' is kinda inappropriate as it does not actually "export" anything

[20:28] <jnthn> Import in Perl 6 is lexical.

[20:29] <benabik> It exports it into the lexical scope, but not the class it's in.  I think.

[20:29] *** mkramer left
[20:29] <soh_cah_toa> hm...

[20:29] <jnthn> sub foo is export { } # adds foo to the export list

[20:29] <benabik> Which is really useful, because you don't want your classes sprouting a bunch of methods just because your library decided to export some stuff.

[20:29] <jnthn> use module_with_foo_in; # imports everything in the default export list into the current lexpad.

[20:30] <benabik> jnthn: But if you're inside a class, that doesn't mean they're imported into the class, right?

[20:30] <jnthn> benabik: I don't get "imported into the class"

[20:31] <jnthn> benabik: Note that writing a sub in a class doesn't put it in the method list. Importing something inside a class body doesn't make it a method either.

[20:31] <benabik> jnthn: From soh_cah_toa's example:  class A { use Foo::Bar; #`{exports baz} }

[20:31] <benabik> jnthn: Is there an A::baz after that?

[20:31] *** kaare_ left
[20:31] <jnthn> No, because the import is lexical (my scoped)

[20:31] <jnthn> There's a way to make it import into the package instead, however.

[20:32] <jnthn> We don't implement that in Rakudo yet; S11 does have it. I forget the exact syntax.

[20:32] <benabik> our use?

[20:32] <jnthn> No, I don't think it's that. :)

[20:32] <jnthn> Though could be interesting

[20:32] <jnthn> has use Foo; # adds all the imported things as methods...omgz :)

[20:32] <jnthn> Yeah, maybe too "interesting" :)

[20:33] <benabik> http://perlcabal.org/syn/S11.html#Compile-time_Importation

[20:33] <jnthn> Anyway, the syntax is something you write after use.

[20:33] <benabik> use Sense :EXPORT

[20:34] <jnthn> No, that's not going to give an A::baz, iiuc

[20:34] <jnthn> use Foo::Baz :OUR<&baz> maybe

[20:34] <jnthn> But you'd think there would be a way to say "bring 'em all in as our-scoped things"

[20:34] <benabik> Oh, that would cause A to export baz.  Buh, confusing.

[20:34] <soh_cah_toa> unless i'm misunderstanding something, doesn't that fact that 'use' is lexical imply that `package A { use Foo::Bar }` should have foobar() imported into it?

[20:34] <soh_cah_toa> package A creates a lexical scope, right?

[20:35] <jnthn> Every pair of curlies implies a lexical scope

[20:35] <soh_cah_toa> package A { ... } yes

[20:35] <jnthn> To be clear though

[20:35] <soh_cah_toa> right

[20:35] <jnthn> rakudo: module Foo { sub x() { say 42 } }; Foo::x()

[20:35] <p6eval> rakudo 8b7a2a: OUTPUT«Could not find symbol 'Foo::&x'␤  in <anon> at /tmp/MI25wdfyl3:1␤  in <anon> at /tmp/MI25wdfyl3:1␤␤»

[20:35] <jnthn> rakudo: module Foo { our sub x() { say 42 } }; Foo::x()

[20:35] <p6eval> rakudo 8b7a2a: OUTPUT«42␤»

[20:36] <jnthn> In the first case, x is my-scoped (lexical). In the second, it's also installed into the package Foo

[20:36] <soh_cah_toa> so i need to change the sub definition to 'our sub foobar is export { ... }' then?

[20:36] <jnthn> Not unless you want to be able to import it also.

[20:37] <sorear> good * #perl6

[20:37] <soh_cah_toa> ugh, this is confusing

[20:37] <benabik> o/ sorear 

[20:37] <jnthn> If you just want it visibile thorugh a fully qualified name (like Foo::x) you just need to makr it "our"

[20:37] <soh_cah_toa> what i want is Foo::Bar to export a bunch of subs but i also want to be able to test that it's doing so

[20:38] <benabik> soh_cah_toa: { use Foo::Bar; #`{ do tests here} }

[20:38] <benabik> Instead of { use Foo::Bar } #`{tests here}

[20:39] * mberends emerges from the cabal dependency rabbit-hole, ragged and defeated

[20:39] *** lue left
[20:41] <soh_cah_toa> how do i fully qualify a sub from the "default" namespace though? w/o a fqn, it's interpreted as a call

[20:41] <soh_cah_toa> i don't know the default namespace name

[20:41] <soh_cah_toa> ::foobar perhaps?

[20:42] <sorear> ping jnthn

[20:42] <jnthn> Do you mean

[20:42] <sorear> soh_cah_toa: GLOBAL::foobar

[20:42] <soh_cah_toa> ok

[20:42] <jnthn> rakudo: module Foo { our sub x() { } }; &Foo::x # if you want a ref, not a call

[20:42] <p6eval> rakudo 8b7a2a:  ( no output )

[20:42] <jnthn> sorear: pong

[20:43] <benabik> soh_cah_toa: Following on jnthn's example { use Foo; &x } (if x was exported)

[20:43] <soh_cah_toa> http://nopaste.snit.ch/81995

[20:43] <soh_cah_toa> that does not pass

[20:43] <sorear> jnthn: I am attempting to figure out how role parametricity is implemented in nom

[20:43] <jnthn> soh_cah_toa: Sorry if I'm misunderstanding a bunch of your questions. I'm a little tiredish today...

[20:43] <soh_cah_toa> :) that's alright

[20:43] <jnthn> sorear: OK.

[20:43] <sorear> jnthn: in particular, in role Foo[$x] { method bar() { $x } }, how does &bar come to close over $x?

[20:44] <sorear> I've run out of obvious places to check

[20:44] <jnthn> sorear: It's just a closure clone.

[20:44] <jnthn> sorear: See specialize_with in...ParametricRoleHOW iirc.

[20:44] <benabik> soh_cah_toa: Try ok(defined &eq_irc)

[20:44] * sorear was looking for RoleHOW

[20:45] <jnthn> src/Perl6/Metamodel

[20:45] <jnthn> sorear: No, there's not one "RoleHOW".

[20:45] <sorear> looking

[20:45] <jnthn> Been there, done that. :)

[20:45] <jnthn> sorear: See *RoleHOW.pm

[20:45] <jnthn> Also GenericHOW.pm

[20:45] <soh_cah_toa> benabik: yeah, that works. thanks

[20:45] <jnthn> Also *Applier.pm

[20:47] *** mberends left
[20:47] * sorear grumbles at the unachievable elegance of this

[20:48] <jnthn> sorear: There's 7 or 8 things in Metamodel:: that are related to making roles work in all their glory. If I can offer you any "don't make the same mistakes I've done over the years" style advice, it'd be don't conflate things that are different.

[20:49] <jnthn> By that I mean

[20:49] <jnthn> role Foo[::T] { }; class C does Foo { }

[20:49] <jnthn> So, how many forms can this show up in?

[20:50] <jnthn> Foo - well, clearly this isn't actually the "real role" itself because we can also declare a role Foo[::T1, ::T2] { }

[20:50] <jnthn> So it must be some kinda "grouping" thing

[20:50] <benabik> jnthn: Does that make T ~~ C in Foo?

[20:50] <jnthn> But we have to be able to know which one we're talking about composition time.

[20:50] <jnthn> benabik: No

[20:51] <jnthn> So we're already up to two "forms"

[20:51] <jnthn> Now consider that when we compose it into the class we need a specialized form.

[20:51] <felher> Whats the preferred way to get the indicies of elements in an array that match some condition? Like grep, just for indicies. @array.kv.map: {$^k if $^v ~~ condition};?

[20:51] <jnthn> With the generic bits - including ::?CLASS - reified.

[20:51] <jnthn> That's a third

[20:51] <jnthn> Then, just to ice the cake, Foo[Int] is also something we can talk about first class.

[20:52] <jnthn> But it's not the same as the fully specialized thing because we haven't got the information we need to specialize ::?CLASS yet.

[20:52] <jnthn> So it's a forth form.

[20:53] <jnthn> I call these four ParametricGroup, Parametric, Concrete and Curried.

[20:53] <benabik> If you have a Foo[::T], what does class Bar does Foo mean?  I'd think you'd have to give it a parameter.

[20:53] <jnthn> benabik: er, darn

[20:53] <jnthn> :)

[20:53] <jnthn> benabik: It means "compile time error"

[20:54] <jnthn> I mean class Bar does foo[Int] { } or so

[20:54] <jnthn> Sorry.

[20:54] <jnthn> *Foo[Int]

[20:54] <benabik> jnthn: That was why I was asking about T ~~ C in your example.  ;-)  Glad to know I hadn't missed something.

[20:54] <jnthn> nom: role R[::T] { }; class C does R { }

[20:54] <p6eval> nom 8b7a2a: OUTPUT«===SORRY!===␤None of the parametric role variants for 'R' matched the arguments supplied.␤No applicable candidates found to dispatch to for '_block1377'. Available candidates are:␤:(Mu, Mu)␤␤»

[20:54] <jnthn> Hmm...some error awezomization needed in the second part of that.

[20:55] <jnthn> But the first line of the eror is kinda spot on.

[20:55] <jnthn> OK, time for me to get a beer and hack on the optimizer for a little bit.

[20:56] <jnthn> This will probably screw up my sleep tonight, but given I slept 12 hours last night I'm done for anyway. :/

[20:57] <sorear> heh same here ...

[20:58] <benabik> nom: role R[::T] { }; class C does R[int] { } # curious...

[20:58] <p6eval> nom 8b7a2a:  ( no output )

[20:58] <benabik> \o/

[20:58] <jnthn> Oh my :)

[20:58] <jnthn> It's not going to handle that so cleverly as you may wish though, I suspect.

[20:59] <benabik> jnthn: Fair enough.  :-D

[20:59] <jnthn> I mean, it'll work

[20:59] <jnthn> But under the hood it's probably going to box/unbox in places it maybe shouldn't.

[20:59] <jnthn> Fixing that is a...research problem.:)

[20:59] * jnthn holds out a research problem to sorear++ to see if he bites :)

[21:00] <jnthn> I wonder if we can do anything insane on the CLR to get its generics support to do some of the lifting on that front...

[21:01] <jnthn> Figuring out the details makes my brain want to run off and hide though. :)

[21:01] <jnthn> And on the JVM it's back to square one since their generics are type erased.

[21:02] <benabik> And handle native types via boxing anyway

[21:02] <jnthn> Well, that's what passing a native type to a role will do.

[21:02] <jnthn> In Rakudo today I mean.

[21:03] <jnthn> It'd be great fun to improve/fix that some day.

[21:03] *** Kivutarrr joined
[21:06] *** newsbad_com left
[21:07] *** newsbad_com joined
[21:11] *** Kivutarrr left
[21:15] <sorear> jnthn: What problem are you holding out?  R[int]?

[21:17] <sorear> jnthn: What is type pretence

[21:18] <sorear> jnthn: What is the difference between new_type and new?

[21:21] <jnthn> sorear: R[int], yes :)

[21:21] <jnthn> sorear: Type pretence is how a role behaves like it's Any

[21:21] <jnthn> Even thought that doesn't really "make sense"

[21:21] <jnthn> new - what you expect. A new meta-object.

[21:21] <jnthn> new_type - makes a type object (and thus an s-table)

[21:22] <jnthn> We pretty much never call .new from the outside.

[21:22] <jnthn> Always new_type

[21:34] *** pmurias left
[21:37] <soh_cah_toa> perl6: sub foobar(Str:D $str) { say "$str is defined" }; foobar('qux')

[21:37] <p6eval> niecza v9-51-g493fbf9: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤In parameter declaration, typename 'Str:D' must be predeclared (or marked as declarative with :: prefix) at /tmp/hRdGoq8gOh line 1:␤------> [32msub foobar(Str:D[33m⏏[31m $str) { say "$str is defined" }; foobar[0m␤␤Parse f…

[21:37] <p6eval> ..pugs, rakudo 8b7a2a: OUTPUT«qux is defined␤»

[21:38] <sorear> pugs? really?

[21:38] <soh_cah_toa> aw darn, 2011.07 gives me "Invalid typename in parameter declaration" when i use :D or :U

[21:39] <soh_cah_toa> nom is taking too long, i'm getting antsy ;)

[21:39] <jnthn> soh_cah_toa: Yes, implementing that in nom :)

[21:39] *** zby_home_ left
[21:39] <jnthn> *implemented

[21:39] <jnthn> soh_cah_toa: Yeah, I know...we're getting there.

[21:39] *** mj41 left
[21:40] <soh_cah_toa> it's getting annoying b/c that also means i need to stay w/ parrot 3.6.0

[21:41] <soh_cah_toa> if i just install nom/HEAD, can i use 3.8.0?

[21:42] <benabik> Parrot 3.8.0 works on Rakudo HEAD.  Parrot HEAD works with nqp/kill-useless-defaults and rakudo/HEAD  (last I tried)

[21:43] <soh_cah_toa> new rakudo branch = old nom branch, right?

[21:43] <soh_cah_toa> i know something like that got changed a while ago

[21:43] <jnthn> soh_cah_toa: nom is the current branch

[21:43] <jnthn> soh_cah_toa: If you git clone Rakudo today, you get the nom branch

[21:43] <jnthn> (master is just a convention)

[21:44] <soh_cah_toa> so what branch am i on if i 'git checkout nom'?

[21:44] <jnthn> ...nom? :)

[21:44] <soh_cah_toa> and if i 'git checkout master' i'm also on nom?

[21:44] <jnthn> soh_cah_toa: No, you get "branch doesn't exist" or some such

[21:45] *** cognominal___ joined
[21:45] <soh_cah_toa> nope, i can go to master just fine

[21:45] <jnthn> Oh?

[21:45] <jnthn> :S

[21:45] <soh_cah_toa> git branch -v

[21:45] <soh_cah_toa> master d7f45ff Cool.eval

[21:45] <jnthn> huh.

[21:45] <jnthn> That sounds...kinda odd.

[21:45] <soh_cah_toa> and that's after rebasing

[21:46] <jnthn> I wonder if somebody accidentally pushed to master.

[21:46] <benabik> soh_cah_toa: Did you just clone it, or have you had it for a while?

[21:46] <sorear> jnthn: git pull won't delete branches

[21:46] <jnthn> sorear: oh.

[21:46] <soh_cah_toa> i've had it for a while

[21:46] <jnthn> ah

[21:46] <jnthn> OK.

[21:46] <soh_cah_toa> i gotta re-clone?

[21:46] <jnthn> sorear: Makes sense...

[21:46] <benabik> Also, master appears to still exist in rakudo.it

[21:46] <benabik> git

[21:46] <sorear> soh_cah_toa: no, just don't check out master anymore

[21:46] <sorear> check out b or nom

[21:48] *** cognominal_ left
[21:49] *** espadrine joined
[21:49] <soh_cah_toa> bleh...this "nom = master but master = DNE except for soh_cah_toa's machine" business is crazy

[21:49] <soh_cah_toa> i'm checking out nom

[21:49] <soh_cah_toa> installing

[21:49] <soh_cah_toa> i dont' care

[21:49] <soh_cah_toa> :P

[21:51] <benabik> 1) Your local branches don't have to correspond to anything remote.  2) master does exist in rakudo.git, but it's not the default branch.

[21:51] <soh_cah_toa> ok

[21:51] <benabik> nom = HEAD

[21:52] <sorear> jnthn: now I'm wondering a bit about ze archetypes business...

[21:52] <jnthn> sorear: heh, I shoulda gotten around to writing the blog post about those...

[21:52] <jnthn> sorear: See slides on my talk from YAPC this year

[21:52] <ingy> seen TimToady 

[21:52] <aloha> TimToady was last seen in #perl6 7 hours 34 mins ago saying "not marked as flatten".

[21:53] <jnthn> sorear: I put the best description I did so far for archetypes in there.

[21:53] <sorear> jnthn: link?

[21:53] <jnthn> http://jnthn.net/papers/2011-yapceu-rakudo.pdf

[21:53] <sorear> thanks

[21:54] <benabik> jnthn: The book from that presentation is one of my textbooks this year.

[21:54] <masak> "inheritalizable".

[21:54] <benabik> (Types and Programming Languages)

[21:54] <jnthn> benabik: It's very nice. :)

[21:54] <jnthn> Enjoy :)

[21:54] <masak> benabik: it was the book that made audreyt begin Pugs.

[21:55] <jnthn> masak: Derivational morphology. :p

[21:55] <masak> jnthn: "yesish" :)

[21:56] <jnthn> Oh stop yesishing.

[21:56] <masak> ok, so. which implementation will be the first to support infix:<%> in regexes?

[21:56] <masak> Niecza, or Rakudo?

[21:56] <tadzik> yapsi

[21:56] <jnthn> yapsi

[21:56] <masak> hah!

[21:57] <tadzik> jnthn: high five!

[21:57] <tadzik> Erm, high six i mean

[21:57] <jnthn> \o/

[21:57] <masak> yapsi doesn't even have regexes yet.

[21:57] <masak> but I'm glad you still remember Yapsi. it hasn't had a release in a while.

[21:57] <masak> dangerous with implementations with low bus numbers...

[22:12] <sorear> nqp: BEGIN { say(5) }

[22:12] <p6eval> nqp: OUTPUT«Confused at line 1, near "BEGIN { sa"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23698 (src/stage2/gen/NQPHLL.pir:6757) (src/stage2/gen/NQPHLL.pm:329)␤»

[22:12] <masak> confused from the very beginning!

[22:13] * sorear holds the most important difference of niecza to be the lack of a nqp/rakudo like split

[22:13] <tadzik> . o O ( sorear uses confusion! It's super-effective! )

[22:14] * masak .oO( 9 out of every 10 sorears recommend confusion )

[22:15] <jnthn> Not sure nqp is going to survive it out the year without learning about BEGIN, fwiw.

[22:16] <jnthn> (I'm not thrilled about making it do so, but I suspect I may need it at some point.)

[22:16] <jnthn> We'll see.

[22:16] <sorear> jnthn: if nqp does learn BEGIN, how will box operators know what type to use?

[22:17] <jnthn> sorear: Confused :)

[22:17] <jnthn> sorear: I think I'm missing something.

[22:17] <sorear> niecza's kernel keeps a bunch of globals like Kernel.StrMO; this seems the main obstacle to a more nom-like runtime/compile split

[22:17] <sorear> jnthn: does/will nqp have anything like perl6_set_parcel_type ?

[22:18] <sorear> will nqp have any ops that need to find NQPMu or something like that?

[22:19] <jnthn> sorear: I'm really not sure yet. Note that NQP on Parrot uses Parrot PMCs to break some circularities.

[22:19] <jnthn> sorear: And when I did NQP on CLR, I ran into...fun...on things like that.

[22:19] <jnthn> I can't remember exactly what happened.

[22:19] <jnthn> I must have had to deal with it somehow.

[22:20] <jnthn> Ask me again when I get somewhere with the nqpclr update/refactor. :)

[22:21] <sorear> What does $method.insantiate_generic call?

[22:21] <jnthn> Routine's instantiate_generic method.

[22:21] <sorear> What file is RoutineHOW defined in?

[22:22] <jnthn> ?

[22:22] *** wallberg left
[22:22] <jnthn> There's no RoutineHOW

[22:22] <jnthn> Routine is just a class.

[22:22] <jnthn> Routine is partially set up in BOOTSTRAP.pm

[22:23] <jnthn> And partially in src/core/Routine.pm.

[22:24] <masak> routines aren't type-y things like classes and roles and enums. that's why there's no RoutineHOW.

[22:25] <jnthn> That's a good way of looking at it.

[22:32] *** PacoLinux_ left
[22:35] *** static_perl joined
[22:36] <sorear> jnthn: is create_lexical_capture_fixup responsible for role Foo[$x] { method bar { $x } } working?

[22:36] *** aloha joined
[22:36] <jnthn> sorear: Yeah.

[22:36] <jnthn> sorear: er

[22:36] <jnthn> wait

[22:36] <jnthn> I think actually no

[22:36] <jnthn> No, it's not that. It's fixing up the role's outer pointer at fixup time.

[22:37] <jnthn> *role body's outer pointer

[22:37] <sorear> jnthn: I'm still trying to find what *is* responsible...

[22:38] <jnthn> sorear: instantiate_generic on Routine

[22:38] <jnthn> sorear: It calls self.clone() or some such

[22:38] <jnthn> sorear: That includes capturing the outer pointer.

[22:39] <jnthn> Since we just ran the body block, those were all capture_lex'd correctly.

[22:40] * sorear still thinks that is the most eewsome thing in Parrot

[22:41] <dalek> rakudo/optimizer: 8db01ef | jnthn++ | src/binder/multidispatch. (2 files):

[22:41] <dalek> rakudo/optimizer: First sketch of algorithm for considering multiple dispatches at compile time.

[22:41] <dalek> rakudo/optimizer: review: https://github.com/rakudo/rakudo/commit/8db01ef90d

[22:41] <benabik> sorear: capture_lex?

[22:42] *** replore_ joined
[22:42] <masak> good night, channel.

[22:43] <tadzik> gnightmasak

[22:43] <tadzik> ha, made it!

[22:43] <masak> :P

[22:43] <jnthn> night masak!

[22:43] <jnthn> lol me too

[22:43] <tadzik> bet he's waiting for us today

[22:43] <masak> tadzik: and no, I don't backlog to see who replied. not until the next morning :P

[22:43] <tadzik> ;P

[22:43] <jnthn> bwaha :)

[22:43] *** masak left
[22:43] <jnthn> ok, how the heck do I write this analyser up...

[22:43] <tadzik> haha, watch this

[22:43] *** replore_ left
[22:43] <tadzik> GOOD MORNING MASAK!

[22:44] <jnthn> s/write/wire

[22:47] <flussence> sorear: did you see this earlier? http://irclog.perlgeek.de/perl6/2011-09-25#i_4477224

[22:48] <sorear> flussence: yes

[22:48] <flussence> I'm guessing that's just some NYI laziness?

[22:50] <sorear> it's building a list of @_[0] through @_[Inf]

[22:51] <jnthn> That's gonna take a while, even at Niecza's speed :)

[22:52] <jnthn> oh noes, my beer bottle is empty :(

[22:52] <benabik> The horror!

[22:54] <jnthn> Thankfully the fridge can help.

[22:54] <sorear> I find x ** -100..100 to be a very troubling pattern

[22:55] <jnthn> sorear: Context?

[22:55] <jnthn> (sorry if it should be obvious...)

[22:55] <sorear> jnthn: Regexes

[22:55] <jnthn> Oh.

[22:55] <jnthn> :)

[22:55] <sorear> I'm reading the S05 patches because of masak

[22:55] <jnthn> Er, -100? :)

[22:55] <sorear> Yes, -100

[22:56] <sorear> it's in S05!

[22:56] <benabik> Apparently has been for a while.

[22:57] <flussence> ow, I think I vaguely remember what negative numbers mean and it's not pretty...

[22:57] * flussence reads spec

[22:57] <jnthn> Oh. My. Whoa.

[22:57] <jnthn> Yeah, I didn't remember that was there :)

[22:57] <sorear> I think it's bad for exactly the same reason p5ish @foo[-1] is bad

[22:58] <sorear> it creates a semantic discontinuity

[23:00] <sorear> niecza: say ?/ ^ x++ <[xy]> / for < y xy xxx >

[23:00] <p6eval> niecza v9-51-g493fbf9: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤STD parses + as a quantmod but there is nothing at all in S05 to explain what it should _do_ at /tmp/ov8M5SKk2r line 1:␤------> [32msay ?/ ^ x++[33m⏏[31m <[xy]> / for < y xy xxx >[0m␤␤Unhandled exception: Check failed␤␤  …

[23:00] <sorear> yay fixed

[23:01] <jnthn> sorear++ for underlying do 

[23:01] <jnthn> :D

[23:01] <jnthn> *underlining

[23:03] <sorear> I think that's your client's doing.

[23:03] <jnthn> oh. :)

[23:03] <jnthn> irssi

[23:03] <jnthn> What did you do?

[23:03] <sorear> prefix and suffix _

[23:03] <flussence> dwfm :/

[23:03] <jnthn> Oh.

[23:04] <jnthn> I thought you'd done something curious with ANSI escape codes :P

[23:04] <sorear> rakudo: say '_' ~ 'foo' ~ '_'

[23:04] <p6eval> rakudo 8b7a2a: OUTPUT«_foo_␤»

[23:04] <flussence> I think it's probably an option somewhere in irssi...

[23:04] <jnthn> That doesn't do it.

[23:04] <sorear> rakudo: say ' _' ~ 'foo' ~ '_ '

[23:04] <p6eval> rakudo 8b7a2a: OUTPUT« _foo_ ␤»

[23:04] <jnthn> That does.

[23:04] <flussence> (I think there's an ANSI code to do it, too...)

[23:04] <flussence> (an irc client-compatible one, that is)

[23:04] <jnthn> Yeah, I learned a little about ANSI codes when writing Grammar::Debugger.

[23:05] <jnthn> I had to go and find a patched version of the Windows terminal that supported them.

[23:05] *** molaf_ joined
[23:05] <jnthn> So I could actually run the demo.

[23:05] <tadzik> was Term::ANSIColor not sufficient>?

[23:05] <jnthn> tadzik: I used Term::ANSIColor

[23:05] <tadzik> I know, that's why I'm asking :)

[23:05] <jnthn> tadzik: The problem is that the default terminal program Windows ships with does not support ANSI color codes

[23:05] <jnthn> tadzik: It's not the module's fault.

[23:05] <tadzik> ah, true

[23:05] <tadzik> yeah, I'm aware of that

[23:06] <jnthn> I looked around for a way to fix it but failed.

[23:06] <jnthn> However, there *must* be one

[23:06] <tadzik> how did you solve that? Different terminal emulator?

[23:06] <jnthn> Yeah.

[23:06] <jnthn> But latest version of msys git gives me the colors in the out-the-box terminal.

[23:06] <jnthn> I dunno what they're doing.

[23:06] <jnthn> Unless they're using various Windows-specific console APIs.

[23:07] <flussence> the thing I don't like about terminal colour codes is that they're customisable, and there's no way for a program to figure out what palette you're using.

[23:07] <jnthn> (msysgit folks)++ anyway...they've given me an almost completely trouble-free git experience on Windows.

[23:08] *** static_perl left
[23:08] <sorear> phernny: tell TimToady My current reading of S05 tells me that % is a quantmod, and since you may only have one quantmod, this means there is no shorter way to say [ :r x+ % ',' ].  Is that correct?

[23:08] *** Trashlord joined
[23:08] <sorear> phenny: tell TimToady My current reading of S05 tells me that % is a quantmod, and since you may only have one quantmod, this means there is no shorter way to say [ :r x+ % ',' ].  Is that correct?

[23:08] <phenny> sorear: I'll pass that on when TimToady is around.

[23:09] *** molaf left
[23:09] *** bonifatio joined
[23:10] *** aloha left
[23:11] *** aloha joined
[23:22] *** Chillance left
[23:26] *** bonifatio left
[23:27] *** espadrine left
[23:30] *** soh_cah_toa left
[23:36] *** soh_cah_toa joined
[23:52] *** soh_cah_toa_ joined
[23:54] *** soh_cah_toa left
