[00:00] <jnthn> Ah, OK.

[00:00] *** kst joined
[00:00] <jnthn> Oh yeah

[00:00] <jnthn> It's aobu thte op

[00:00] <jnthn> ...about the...

[00:00] <masak> nod

[00:00] <jnthn> Not $*LEFTSIGIL

[00:00] <jnthn> So yes, it is always item assignment. :)

[00:00] <masak> I should use or= if I want list assignment.

[00:01] <masak> rakudo: my @a; @a or= 1, 2, 3, 4; say @a.perl

[00:01] <p6eval> rakudo 188755: OUTPUT«[1]␤»

[00:01] * masak submits rakudobug

[00:01] <masak> :)

[00:01] <jnthn> apart from...yeah. :P

[00:01] *** rgrau left
[00:01] <masak> either it works, and I win. or I can submit a bug from it, and I win. I like this game. :P

[00:02] <jnthn> Then I write a patch and I win. :P

[00:02] <jnthn> Oh, wait, then you still win 'cus it's fixed...darn. :)

[00:02] <masak> \o/

[00:02] <masak> everyone wins.

[00:02] <jnthn> Actually, the RT queue loses a ticket.

[00:02] <masak> the game is terribly rigged in everyone's favour.

[00:05] <snarkyboojum> hello #perl6 from linux.conf.au in sweltering brisbane, australia :)

[00:05] <jnthn> o/

[00:06] <masak> snarkyboojum: are we on a projector screen? :)

[00:06] <snarkyboojum> masak: nope :)

[00:06] <masak> awww :)

[00:06] <snarkyboojum> heh

[00:06] * jnthn won't tell his really terrible joke about Australian beer then ;)

[00:06] <masak> are we in a position to demand to be put on a projector screen?

[00:07] <snarkyboojum> I stood in line for coffee with Linus yesterday! </groupie_comments>

[00:07] <snarkyboojum> masak: heh - nope

[00:07] <masak> omg Linus?

[00:07] <masak> snarkyboojum: awww :)

[00:07] <snarkyboojum> zomg the Real Linus

[00:07] <sjohnson> snarkyboojum: for real?  did you say hi?

[00:07] <snarkyboojum> sjohnson: nope.. just tried not to stare, agog :P

[00:08] <snarkyboojum> and vint cerf was here yesterday too, so some interesting people around!

[00:08] <rindolf> Hi snarkyboojum 

[00:08] <snarkyboojum> rindolf: hello!

[00:08] <rindolf> snarkyboojum: here it's kinda cold.

[00:08] <rindolf> snarkyboojum: and it was cloudy today.

[00:09] *** c1sung joined
[00:09] <snarkyboojum> rindolf: where are you again?

[00:10] <rindolf> snarkyboojum: Israel.

[00:10] <rindolf> snarkyboojum: Tel Aviv.

[00:10] <masak> it's between Email Aviv and Fax Aviv.

[00:11] <rindolf> Heh.

[00:11] <masak> sorry, that was a phony joke.

[00:11] <rindolf> http://en.wikipedia.org/wiki/Tell

[00:13] <flussence> .oO( whee. another I-almost-dumped-my-paste-buffer-into-irssi panic moment )

[00:14] <TimToady> set the limit to one line, and it always catches any paste wit a newline

[00:14] <TimToady> *with

[00:15] <jnthn> pmichaud: In Cursor, it looks to me like $!from and $!pos becoming (native) int attrs rather than PMCs would save a bunch of boxing. Maybe $!target being a native string attr would help too. Opinions welcome. :)

[00:15] <TimToady> flussence: paste_verify_line_count = 1

[00:15] <flussence> that helped :) # TimToady++

[00:16] *** rindolf left
[00:17] <TimToady> did you hear the phony joke about the phone jack?

[00:17] <flussence> that one doesn't ring a bell, and my name's not jack

[00:17] <jnthn> TimToady: No, you should tel it... :P

[00:18] *** c1sung left
[00:20] <sjohnson> i wouldn't mind saying hi to mr torvalds

[00:22] *** cdarroch left
[00:24] *** c1sung joined
[00:25] *** bpa joined
[00:26] *** wooden joined
[00:26] <jnthn> pmichaud: Also when Match moves over to being a 6model object (didn't do that yet...) looks like we may save a couple of PMCs per match object for storing the position info too.

[00:30] <jnthn> Hmm. Match objects store a reference back to the cursor that matched them too.

[00:30] <masak> rakudo: class A { method new { self.bless(*) } }; class B is A { has $.c is rw; method new { my $obj = callsame; say $obj.WHAT; $obj.c = 42; return $obj } }; say B.new.c

[00:30] <p6eval> rakudo 188755: OUTPUT«B()␤Null PMC access in getprop()␤  in '&infix:<=>' at line 1␤  in 'B::new' at line 22:/tmp/0us_dhCy_G␤  in main program body at line 22:/tmp/0us_dhCy_G␤»

[00:30] * masak submits rakudobug

[00:30] <masak> it says it's a B, but I suspect it ain't.

[00:31] *** Franek left
[00:31] <jnthn> Hm. It should be...

[00:31] <masak> the error occurs when trying to assign to $.c, which is B-specific.

[00:32] <jnthn> yeah...

[00:33] <jnthn> 00:11 < jnthn> Somebody should fix objects. :P

[00:33] <masak> :)

[00:34] *** c1sung_ joined
[00:34] *** c1sung left
[00:34] *** bartolin left
[00:35] <jnthn> pmichaud: If we hit !cursor_pass, do we need @!bstack etc any more? If not, and given we keep the cursor around in the match object, we may be able to get some memory saving there too.

[00:38] *** drbean joined
[00:39] *** masak left
[00:40] *** whiteknight joined
[00:42] *** bartolin joined
[00:45] <jnthn> Enough for today. Nearly got native attrs nailedish. Need that, some straightforward roles implementation and the primitive to build mix-ins atop of, then it's Rakudo on 6model time.

[00:46] <jnthn> 'night o/

[00:48] <bpa> rakudo: (1,2 X 1,2).perl.say; (1,2 X 1,2).pick(1).perl.say

[00:48] <p6eval> rakudo 188755: OUTPUT«((1, 1), (1, 2), (2, 1), (2, 2))␤2␤»

[00:48] <bpa> Why doesn't the second produce a pair?

[00:49] <bpa> or tuple, not sure the proper word

[00:49] *** felliott left
[00:51] <bpa> is there a way to prevent the flattening?

[00:54] *** kst left
[00:54] *** kst joined
[00:56] *** gimix joined
[00:58] <bpa> rakudo: @a=((1,1),(2,2)); @a.say

[00:58] <p6eval> rakudo 188755: OUTPUT«===SORRY!===␤Symbol '@a' not predeclared in <anonymous> (/tmp/ejYQSj2aKT:22)␤»

[00:59] <bpa> rakudo: my @a=((1,1),(2,2)); @a.say

[00:59] <p6eval> rakudo 188755: OUTPUT«1122␤»

[01:00] <bpa> rakudo: my @a=((1,1),(2,2)); @a.perl.say

[01:00] <p6eval> rakudo 188755: OUTPUT«[1, 1, 2, 2]␤»

[01:01] *** QinGW joined
[01:03] *** woosley joined
[01:06] *** thundergnat joined
[01:06] <thundergnat> rakudo: (1,2 X=> 1,2).pick(1).perl.say

[01:06] <p6eval> rakudo 188755: OUTPUT«2 => 1␤»

[01:07] <thundergnat> bpa: ^^

[01:08] <bpa> thundergnat: thank you

[01:20] *** plobsing joined
[01:28] <TimToady> yay, 2**8 rosettacodes now :)

[01:31] <TimToady> thundergnat: probably more efficient to define powers_of as 1,[\*] $radix xx *

[01:32] <TimToady> since ** Int does repeated multiplication, iiuc

[01:32] <thundergnat> TimToady: ok. 

[01:33] <TimToady> using [\*] doesn't remultiply all the lower values

[01:38] <thundergnat> TimToady: edited with your suggestion.

[01:54] *** thundergnat left
[01:59] <colomon> wonder if that's better or worse than 1, * * $radix ... *

[02:06] <colomon> dang, that's too fast!

[02:06] <colomon> ;)

[02:09] <TimToady> yeah, doesn't really matter much one way or the other, at least until we get real Ints

[02:10] <TimToady> er...

[02:10] <colomon> huh.

[02:10] <colomon> actually, if you implement the two versions using Rat / Num math, the sequence version is drastically faster.

[02:10] * colomon has just been writing benchmarks.

[02:14] <colomon> I presume Int versions would be the same (but they outgrow current Ints too fast to benchmark).

[02:14] *** mtk left
[02:16] <colomon> woah, some sort of serious math bug here.  :(

[02:20] <colomon> rakudo: say 1.015 ** 133

[02:20] <p6eval> rakudo 188755: OUTPUT«7.2440863609305␤»

[02:20] <colomon> rakudo: say 1.015 ** 134

[02:20] <p6eval> rakudo 188755: OUTPUT«NaN␤»

[02:20] <sjohnson> nanny

[02:21] <sjohnson> NaN == nani in Japanese

[02:22] <colomon> oh, ick.

[02:22] <colomon> rakudo: say 1.015.nude

[02:22] <p6eval> rakudo 188755: OUTPUT«203200␤»

[02:22] <colomon> rakudo: say 1.015.nude.perl

[02:22] <p6eval> rakudo 188755: OUTPUT«(203, 200)␤»

[02:23] *** mtk joined
[02:23] <colomon> bother.

[02:23] <colomon> rakudo: say 203 ** 134

[02:23] <p6eval> rakudo 188755: OUTPUT«Inf␤»

[02:28] * diakopter falls out of his standing desk chair

[02:28] <diakopter> rakudo: say 203 ** 130

[02:28] <p6eval> rakudo 188755: OUTPUT«9.42941888064624e+299␤»

[02:28] <diakopter> rakudo: say 203 ** 131

[02:29] <p6eval> rakudo 188755: OUTPUT«1.91417203277119e+302␤»

[02:29] <diakopter> rakudo: say 203 ** 133

[02:29] <p6eval> rakudo 188755: OUTPUT«7.88811152984678e+306␤»

[02:29] <colomon> I'm fixing Rat ** now.

[02:31] <colomon> stupid slow compiles

[02:32] *** felliott joined
[02:37] <colomon> and the first try fails.  :\

[02:37] <colomon> guess I should stop and write tests first anyway.

[02:39] <colomon> rakudo: say 1.015.Num ** 200

[02:40] <p6eval> rakudo 188755: OUTPUT«19.6430286394751␤»

[02:43] <colomon> ack

[02:44] <colomon> I tested 203 ** 134, which of course is going to be Inf no matter what I do.

[02:44] <colomon> so actually my patch worked.

[02:46] <colomon> or at least, power.t passes even with my new test.  :)

[02:46] <colomon> so now, git stash, make, retest, git stash apply, etc.

[02:50] <colomon> oh, woah, major Test.pm bug?

[02:50] *** whiteknight left
[02:50] * colomon is not having a good numeric night

[02:51] <colomon> rakudo: use Test; is_approx(NaN, 10, "NaN is pretty close to 10");

[02:51] <p6eval> rakudo 188755: OUTPUT«ok 1 - NaN is pretty close to 10␤»

[02:51] <colomon> gack.

[02:53] *** bpa left
[02:54] <colomon> errr... anyone out there know what the official Test.pm of Rakudo is?  or where it lives?

[02:55] <colomon> I see two, Test.pm and t/spec/packages/Test.pm

[03:01] <sorear> good * #perl6

[03:01] <colomon> \o

[03:01] <sorear> colomon: the one in t/spec is Pugs', I'm prettty sure

[03:01] <colomon> agreed.

[03:02] <colomon> or at least, it's not what Rakudo is using, I don't think.

[03:02] <colomon> though to be fair, my changes to ./Test.pm don't seem to be reflected in my test results.  :\

[03:02] <sorear> did you remember to update ./Test.pir?

[03:03] <colomon> it's recompiling automatically.

[03:06] <colomon> any more sanity checking suggestions?  I've stuck says in both versions of is_approx, and neither message is printing out when I call is_approx....

[03:09] <colomon> rakudo: say NaN !~~ NaN

[03:09] <p6eval> rakudo 188755: OUTPUT«Bool::False␤»

[03:09] <colomon> rakudo: say 10 !~~ NaN

[03:09] <p6eval> rakudo 188755: OUTPUT«Bool::True␤»

[03:14] *** stkowski left
[03:14] *** _jaldhar joined
[03:21] *** ^Mike\b joined
[03:26] * sorear wonders if jnthn will succeed in making his work irrelevant soon

[03:29] <colomon> niecza irrelevant?  I doubt it greatly.

[03:31] <diakopter> sorear: all the recent work is nqp on parrot...

[03:32] *** cafesofie joined
[03:36] * diakopter intends to get back to nqpclr regexes Real Soon Now

[03:37] * ^Mike\b builds rakudo :o

[03:41] <^Mike\b> Is there a CPAN for Perl6 yet?

[03:42] <diakopter> not per se

[03:43] <diakopter> some of the programs at http://modules.perl6.org/ work with various versions/builds/editions of various implementations of Perl 6

[03:51] <dalek> roast: 4921660 | (Solomon Foster)++ | S32-num/power.t:

[03:51] <dalek> roast: Make sure 1.015 ** 200 is correct.

[03:51] <dalek> roast: review: https://github.com/perl6/roast/commit/4921660807

[03:51] <colomon> errr, that push breaks the spectest for Rakudo.  I'm currently doing a full spectest before pushing the patch to fix it.

[04:09] *** kfo joined
[04:12] *** kfo_ left
[04:12] *** stifynsemons joined
[04:12] *** stifyn joined
[04:15] *** envi joined
[04:22] *** [particle]1 joined
[04:23] *** Su-Shee_ joined
[04:24] *** [particle] left
[04:25] *** stkowski joined
[04:28] *** Su-Shee left
[04:32] *** envi left
[04:32] <dalek> rakudo: dff7e21 | colomon++ | src/core/Rat.pm:

[04:32] <dalek> rakudo: Change Rat infix:<**> to prevent spurious overflows.

[04:32] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/dff7e21153

[04:36] *** envi joined
[04:45] *** felliott left
[04:53] *** agentzh joined
[04:59] *** ponbiki left
[05:32] *** JimmyZ joined
[05:49] *** kst left
[05:50] *** kst joined
[05:54] *** stifynsemons left
[05:54] *** stifyn left
[06:08] *** bacek left
[06:15] *** JimmyZ left
[06:25] *** snarkyboojum left
[06:32] *** solarion left
[06:37] *** solarion joined
[06:39] *** justatheory left
[06:39] *** justatheory joined
[06:40] *** orafu left
[06:40] *** orafu joined
[06:44] *** justatheory left
[06:52] *** kaare_ joined
[06:54] *** wtw joined
[06:55] *** justatheory joined
[06:56] *** justatheory left
[06:58] *** justatheory joined
[06:59] *** JimmyZ joined
[07:01] *** mberends left
[07:09] <sorear> TimToady: sub foo() { BEGIN { &?ROUTINE() }; say "hi" } # What should this do?

[07:10] *** justatheory left
[07:10] *** justatheory joined
[07:13] * sorear out

[07:14] *** justatheory left
[07:15] *** ponbiki joined
[07:17] *** lue left
[07:17] *** lue joined
[07:21] *** JimmyZ left
[07:29] <TimToady> sorear: it should certainly fail, since foo's body is not yet defined when it is called

[07:31] *** drbean left
[07:36] *** jedai_ left
[07:39] *** cafesofie left
[07:41] *** kst left
[07:42] *** kst joined
[07:45] *** molaf joined
[08:01] *** Mowah joined
[08:02] *** Su-Shee_ is now known as Su-Shee

[08:02] *** shi joined
[08:02] *** xinming left
[08:03] *** shi left
[08:08] *** xinming joined
[08:10] *** viyyer joined
[08:12] *** viyyer left
[08:14] *** spq1 left
[08:15] *** spq1 joined
[08:20] <moritz_> good morning

[08:22] *** bps joined
[08:29] *** cjk101010 joined
[08:36] *** bacek joined
[08:40] <moritz_> colomon: re Test.pm changes, if you have *installed* rakudo, the installed Test.{pm,pir} might accidentally take precedence over the ./Test.p{m,ir}

[08:49] *** kst left
[08:49] *** kst joined
[08:50] *** Mowah left
[08:54] *** tzhs joined
[08:59] *** stkowski left
[09:02] *** molaf left
[09:05] *** fhelmberger joined
[09:06] *** kensanata joined
[09:16] *** daxim joined
[09:22] *** woosley left
[09:23] *** drbean joined
[09:26] *** dakkar joined
[09:29] <jnthn> morning, #perl6

[09:33] <moritz_> mornin' jnthn 

[09:34] <jnthn> moritz_: How's things? :)

[09:39] <moritz_> jnthn: first night at home with the small monster... less sleep than I am used to :-)

[09:42] *** xabbu42 joined
[09:42] <jnthn> :-)

[09:43] *** wallberg joined
[09:43] *** wallberg left
[09:47] *** snearch joined
[09:48] *** kst left
[09:49] *** kst joined
[09:54] <dalek> rakudo: d6cfc94 | moritz++ | docs/ChangeLog:

[09:54] <dalek> rakudo: [docs] update ChangeLog

[09:54] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/d6cfc94e07

[10:02] *** QinGW left
[10:02] *** mtk left
[10:05] <jnthn> ++ IPv6 release

[10:05] <jnthn> IPv6 *support* ?

[10:07] <moritz_> support, yes

[10:08] * moritz_ braindead

[10:08] <jnthn> Aww. :)

[10:08] * moritz_ fixes

[10:10] *** mtk joined
[10:11] <dalek> rakudo: d52af1a | moritz++ | docs/ChangeLog:

[10:11] <dalek> rakudo: [docs] braino, moritz--, jnthn++

[10:11] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/d52af1ab72

[10:49] *** cafesofie joined
[10:52] *** masak joined
[10:53] <jnthn> masak: Afternoon. o/

[10:53] <masak> :)

[10:54] <mathw> Morning

[10:54] <masak> mroing in ar! :)

[10:56] <moritz_> good now everybody

[10:58] *** coldhead left
[10:59] *** timbunce joined
[11:00] *** timbunce left
[11:00] *** timbunce_ joined
[11:11] *** jimbob joined
[11:16] *** JimmyZ joined
[11:27] *** gimix left
[11:54] *** agentzh left
[11:58] *** klunky left
[12:03] *** f00li5h left
[12:07] *** wallberg joined
[12:14] <colomon> moritz_++

[12:29] * colomon is more than a little scared of the spectest run he just started.

[12:30] * flussence was poking around in RT and noticed #64132 is fixed, if anyone wants to close it

[12:30] <jnthn> colomon: What's the fear? :)

[12:30] <moritz_> flussence: closing, thanks

[12:31] <colomon> jnthn: until five minutes ago, is_approx allowed NaN as a valid answer for any approximation.

[12:32] <colomon> rakudo: use Test; is_approx(NaN, 10, "NaN is approximately 10, right?");

[12:32] <p6eval> rakudo d52af1: OUTPUT«ok 1 - NaN is approximately 10, right?␤»

[12:33] <dalek> rakudo: 00f5b48 | moritz++ | src/Perl6/Compiler.pir:

[12:33] <dalek> rakudo: new year is calling, water is fine over here...

[12:33] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/00f5b48b69

[12:36] <tadzik> rakudo: say 10 ~~ NaN

[12:36] <p6eval> rakudo d52af1: OUTPUT«Bool::False␤»

[12:37] <flussence> rakudo: use Test; is_approx(NaN, 'BaNaNa'/2)

[12:37] <p6eval> rakudo d52af1: OUTPUT«ok 1 - ␤»

[12:46] *** tzhs left
[12:49] *** Lorn joined
[12:57] *** ab5tract joined
[13:00] <takadonet> morning all

[13:01] <masak> takadonet: \o

[13:02] *** tzhs joined
[13:03] <colomon> o/

[13:04] *** stifynsemons joined
[13:05] <JimmyZ> evening all

[13:06] <stifynsemons> good morning :-)

[13:07] <tadzik> good afternoon :)

[13:08] *** GinoMan joined
[13:08] <masak> good daytime, JimmyZ.

[13:09] *** felliott joined
[13:09] <JimmyZ> masak, good atfernoon

[13:09] <colomon> oh, hey, only one new test failure from fixing is_approx.

[13:09] *** stifynsemons left
[13:10] *** stifynsemons joined
[13:15] <colomon> rakudo: say 2i.exp(-3.14)

[13:15] <p6eval> rakudo d52af1: OUTPUT«NaN + NaNi␤»

[13:15] *** karupanerura joined
[13:17] *** MayDaniel joined
[13:18] <colomon> rakudo: say 2.exp(-3.14)

[13:18] <p6eval> rakudo d52af1: OUTPUT«9.8596␤»

[13:18] <flussence> rakudo: say e ** (i * pi) + 1

[13:18] <p6eval> rakudo d52af1: OUTPUT«0 + 1.22464679914735e-16i␤»

[13:18] <flussence> python screws that one up too, fwiw

[13:18] <colomon> screws what up?

[13:19] <flussence> euler identity

[13:19] <flussence> should == 0

[13:19] <colomon> it equals 0 within floating point accuracy.  what more can you ask?

[13:21] <flussence> I guess I shouldn't be so picky when there's flops involved :)

[13:21] <dalek> roast: 742fce0 | (Solomon Foster)++ | S32-num/real-bridge.t:

[13:21] <dalek> roast: Fix test so that it's not trying to use is_approx on NaN values.

[13:21] <dalek> roast: review: https://github.com/perl6/roast/commit/742fce03dc

[13:22] <dalek> rakudo: a7b6633 | colomon++ | Test.pm:

[13:22] <dalek> rakudo: Make is_approx treat $got ~~ NaN as a failure condition.  (Because otherwise returning NaN would always result in the approx test testing true.)

[13:22] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/a7b6633421

[13:23] <flussence> rakudo: say i ** 2

[13:23] <p6eval> rakudo d52af1: OUTPUT«-1 + 1.22464679914735e-16i␤»

[13:24] <flussence> I think that one's room for improvement though - python does return an integer.

[13:25] <flussence> (but at the same time, it uses "j" instead of "i"... bleh)

[13:27] <colomon> I really don't think we want to go down that path.  It's just adding a bunch of special cases to let you pretend that floating point math is more accurate than it really is -- but only in those special cases.

[13:27] <flussence> it is? oh, never mind me then.

[13:29] <[Coke]> is there a print format that would render (i**2) as an int?

[13:30] <colomon> [Coke]: not that I know of

[13:30] *** gfldex left
[13:31] <flussence> %d works, but only if .im == 0

[13:32] <flussence> rakudo: Complex.new(2, 0).fmt('%d').say; (i**2).fmt('%d').say

[13:32] <p6eval> rakudo d52af1: OUTPUT«2␤Not enough arguments supplied for the given format string␤  in 'Cool::sprintf' at line 2703:CORE.setting␤  in 'sprintf' at line 2737:CORE.setting␤  in 'Cool::fmt' at line 2525:CORE.setting␤  in main program body at line 22:/tmp/F8XvNJTeA0␤»

[13:32] *** kst left
[13:32] *** kst joined
[13:33] *** karupanerura left
[13:34] *** karupanerura joined
[13:36] *** karupanerura left
[13:38] *** karupanerura joined
[13:40] *** MayDaniel left
[13:43] <colomon> rakudo: say i * i

[13:43] <p6eval> rakudo d52af1: OUTPUT«-1 + 0i␤»

[13:44] <colomon> so, you can look at it like this:

[13:44] <colomon> you could add infix:<**>(Complex $x, 2) { $x * $x } 

[13:44] <colomon> That would give you exact results for squares of complex numbers (where possible).

[13:45] <colomon> but it wouldn't help at all with powers greater than 2

[13:45] <colomon> rakudo: say i * i * i * i; say i ** 4

[13:45] <p6eval> rakudo d52af1: OUTPUT«1 + 0i␤1 + -2.44929359829471e-16i␤»

[13:46] <colomon> you could add infix:<**>(Complex $x, Int $n where { $n >= 0 } ) { [*] $x x $n }

[13:46] <colomon> errr... $x xx $n, I mean

[13:46] *** Trashlord left
[13:46] <colomon> but that's going to be much slower for higher values of $n

[13:48] <colomon> or you could do infix:<**>(i, Int $n) { given $n % 4 { when 0 { 1 } when 1 { i } when 2 { -1 } when 3 { -1i } } }

[13:49] <colomon> which is fast and accurate, but only for powers of i.

[13:49] <flussence> ok, I get the point :)

[13:50] <colomon> yes, but it felt very good to enumerate the cases.  Perl 6 makes it easy.  :)

[13:50] *** gfldex joined
[13:51] *** cafesofie left
[13:52] <flussence> (and if someone really wants it they can go write a Math:: thing that knows stuff like this)

[13:52] *** cjk101010 left
[13:52] *** drbean left
[13:53] *** pmurias joined
[13:54] *** V15170R left
[13:55] *** stifynsemons left
[14:03] <colomon> yeah, actually, I'm tempted to do that myself.  :)

[14:05] <colomon> it actually wouldn't be that hard to add special handling for a few common cases

[14:05] <masak> colomon: that case with i ** $n could easily be generalized to an Euler's law multisub.

[14:05] <colomon> infix:<**>(Complex $x where $x.re == 0, Int $n)

[14:05] *** [particle]1 is now known as [particle]

[14:06] <masak> $n doesn't even need to be Int.

[14:07] <masak> 'course, at some point you might re-introduce the floating-point inaccuracy you were trying to avoid...

[14:07] *** plobsing left
[14:13] *** wamba joined
[14:22] *** kst left
[14:22] *** kst joined
[14:23] *** pmurias left
[14:23] *** cafesofie joined
[14:35] *** plobsing joined
[14:35] *** [hudnix] joined
[14:35] *** hudnix left
[14:43] *** kaare_ left
[14:45] *** JimmyZ left
[14:58] *** noganex_ is now known as noganex

[15:05] *** wamba left
[15:05] *** wamba joined
[15:10] <PerlJam> Huh.

[15:11] <PerlJam> I got an email asking if I'd like to do a radio interview concerning  Perl 6.

[15:11] <colomon> cool!

[15:12] <PerlJam> That is cool, but I wonder, "why me?"  It's not like I'm jnthn or pmichaud or TimToady 

[15:13] <PerlJam> I would guess that all of the people who've done some Perl 6 stuff are getting or going to get such an email.

[15:14] <PerlJam> heh.  "Episodes are ... or an interview with a well-known character from the software engineering world."

[15:14] <PerlJam> I don't think I qualify as "well-known" or a "character" :)

[15:16] * mux wishes he knew about XML::LibXML to do XPath processing before; it works significantly faster than XML::XPath and it my encoding issues have now disappeared

[15:17] *** [hudnix] left
[15:17] * masak roots for PerlJam

[15:17] <masak> PerlJam: you're more involved in Perl 6 than almost the entire rest of humanity

[15:20] *** mkramer left
[15:20] *** mkramer1 joined
[15:21] *** colomon left
[15:22] *** wamba left
[15:23] *** wamba joined
[15:23] *** hudnix joined
[15:24] *** plobsing left
[15:24] *** wolfram_ joined
[15:24] *** wamba left
[15:24] *** wamba joined
[15:25] *** kst left
[15:25] *** kst joined
[15:26] *** wolfram_ left
[15:27] *** wolfram__ joined
[15:27] *** Patterner left
[15:27] *** wamba left
[15:27] *** wtw left
[15:28] <wolfram__> masak: in"using the cute MAIN()/MAIN('text') idiom" s/text/test/

[15:28] *** kaare_ joined
[15:28] <masak> wolfram__++, thanks.

[15:28] <masak> fixing.

[15:29] *** Psyche^ joined
[15:30] *** Psyche^ is now known as Patterner

[15:33] *** wolfram__ left
[15:33] *** Kovensky left
[15:34] *** Kovensky joined
[15:34] *** getpwnam joined
[15:35] <pmichaud> good morning, #perl6

[15:35] <jnthn> morning, pmichaud \o/

[15:36] <takadonet> pmichaud: morning

[15:36] <pmichaud> jnthn: Instead of moving nqp-nom to the master branch of the nqp-rx repository, I'm thinking of just creating a new nqp (no -rx) repository where -nom is master

[15:36] <pmichaud> and leave nqp-rx as is

[15:37] <pmichaud> that way if someone feels they need to pick up nqp-rx and maintain its traditional line of development, that can be easily done

[15:37] *** colomon joined
[15:38] *** timbunce_ left
[15:38] <jnthn> pmichaud: wfm

[15:39] <jnthn> pmichaud: Would we structure that repo in anticipation of nqp on clr and nqp on jvm moving into there?

[15:39] <jnthn> Or even Just Do That?

[15:39] <pmichaud> the nqp repo?  yes, I think we would begin with the plan that it'll be multiplatform

[15:39] <pmichaud> but I'm still hoping for "one master branch" as opposed to "separate branches for each backend"

[15:40] <jnthn> Are you using branch in the source control meaning here?

[15:40] <pmichaud> yes

[15:40] <jnthn> Oh, I don't see that happening. (more)

[15:40] <masak> morning, pm.

[15:40] *** plobsing joined
[15:40] <jnthn> May aim is that NQP's Actions.pm and Grammar.pm can be shared. PAST nodes can be shared. I'm hopeful of a shared setting too.

[15:40] <jnthn> s/May/My/

[15:41] <pmichaud> we're in agreement, it seems

[15:41] <jnthn> So then just the VM-y runtime layer and code-gen is in a backends/parrot, backends/clr, etc folder.

[15:41] <pmichaud> Perfect.

[15:41] <jnthn> I think we may have a little work to make that reality but hopefully not too much.

[15:42] <jnthn> There's issues like, references to PMC names in the Parrot one, for example.

[15:42] <pmichaud> I'm working on the draft for a description of the new nqp -- is it correct to say that it no longer makes use of Parrot's Class and Object PMCs?

[15:42] <jnthn> Nearly.

[15:42] <jnthn> A few things still do.

[15:42] <jnthn> But the aim is that they won't.

[15:42] <jnthn> e.g. Match still does

[15:42] <jnthn> But only because I didn't get to migrating it yet.

[15:42] <pmichaud> right, that one won't soon enough :-)

[15:43] <jnthn> I want PAST and so forth to be migrated to 6model too

[15:43] <jnthn> Well, and NQP

[15:43] <pmichaud> at this point I'm talking about "what we're targeting" and not "what exists on Jan 26"

[15:43] <jnthn> Ah, OK 

[15:43] <jnthn> Then, it doesn't make use of Parort's Class and Object PMCs.

[15:43] <pmichaud> (since it's a roadmap doc)

[15:44] <pmichaud> it also doesn't make use of the existing PCT PAST/POST implementation, iiuc

[15:44] <pmichaud> because it'll have a new one

[15:44] <jnthn> It's use of RPA, Hash and Integer/Float/String PMCs should be considered endangered.

[15:44] <jnthn> *Its

[15:44] <pmichaud> agreed there also

[15:44] <pmichaud> how about calling conventions?

[15:44] <pmichaud> clearly it does its own multidispatch

[15:44] *** timbunce joined
[15:45] <jnthn> NQP will afaik stick what Parrot provides

[15:45] <jnthn> On the CLR/JVM there's no notion of Capture or named args and so forth

[15:45] <jnthn> So needs a little runtime support there.

[15:45] <pmichaud> the :multi flag, then?

[15:45] <jnthn> Oh, sorry.

[15:46] <jnthn> I didn't consider :multi part of Parrot's calling conventions. :)

[15:46] *** karupanerura left
[15:46] <jnthn> I meant the actual argument passing mechanism.

[15:46] <jnthn> No, multi-dispatch is done differently.

[15:46] <pmichaud> okay, so arg passing continues to use parrot's existing structure -- that's fine

[15:46] <pmichaud> but it doesn't use Parrot MultiSub then, or the :multi flag

[15:46] <jnthn> Right, there's no reason to re-invent things that are addequete.

[15:46] <jnthn> Correct.

[15:47] <pmichaud> does this mean that subs have to be annotated with multimethod data at load time, same as what we currently do for rakudo?

[15:47] <jnthn> For now, yes.

[15:47] <pmichaud> okay

[15:47] <jnthn> At the moment that is strictly only for multis.

[15:47] <jnthn> Non-multis don't get that.

[15:48] <jnthn> Wanted to keep the cost down.

[15:48] <pmichaud> does nqp do argument checking on parameters at all?

[15:48] <jnthn> In the long run that stuff should all be built once and serialized.

[15:48] <jnthn> No, it doesn't. The args only apply in multi-dispatch.

[15:48] <pmichaud> Perfect.  +1

[15:48] <jnthn> I...think we may have to change that.

[15:48] <pmichaud> we can change that if need be

[15:48] <jnthn> brb, phone

[15:48] <pmichaud> but I like not incurring the overhead if we don't have to :)

[15:52] <jnthn> back

[15:52] <jnthn> The thing that I worry about is

[15:52] <jnthn> sub foo(OhLol $x) { $x.wtf() }

[15:54] <jnthn> At compile time (in PAST::Compiler) that does something like if $invocant_node.know_type { my $idx := $invocant_node.type.^vtable_indiex_for('wtf'); if $idx >= 0 { emit_optimized_call() } }

[15:54] <jnthn> (pseudo-code :))

[15:55] <jnthn> So if it doesn't check them then we'll get bugs of the most bizzare kind. :)

[15:55] *** jimbob left
[15:55] <pmichaud> that's okay for me in nqp

[15:55] <pmichaud> perhaps we have a pessimize mode that checks

[15:55] <jnthn> Say that again when you have to track down such a bug. :P

[15:55] <pmichaud> I'll rephrase then

[15:56] <jnthn> "Huh, I call .wtf and it ends up in .omg!!" :)

[15:56] *** JimmyZ joined
[15:56] <pmichaud> perhaps we have a flag that turns off the checks :-)

[15:56] <pmichaud> when someone wants speed instead of checking :)

[15:56] <jnthn> Ah :)

[15:56] <jnthn> OK.

[15:56] <jnthn> --on-your-own-head-be-it :)

[15:56] <pmichaud> anyway, let's see if I had any other questions....

[15:56] <jnthn> Note that type checks will be a bunch of pointer comparrisions.

[15:56] <jnthn> So rather cheaper than they are today. ;)

[15:57] <pmichaud> oh, that's a plus, definitely

[15:57] <pmichaud> what will nqp rely on from Parrot as far as libraries and types go?

[15:58] <pmichaud> so far it still uses RPA, Hash, Integer, etc

[15:58] <tadzik> hello

[15:58] <pmichaud> but it won't use P6object any longer

[15:58] <jnthn> I suspect that whatever happens we'll still use Parrot's actual implementation of hashes, even if we wrap it up differently.

[15:58] <pmichaud> and Strings, too?

[15:58] <jnthn> Yes

[15:58] <pmichaud> okay

[15:58] *** wamba joined
[15:59] <jnthn> If we're talking about strings as in STRING *

[15:59] <jnthn> Not the String PMC.

[15:59] <pmichaud> how will we handle things like :slurpy and :slurpy :named ?

[15:59] <pmichaud> do those still become RPA / Hash, or will they somehow be custom type?

[15:59] <jnthn> Preferably, we work out how to get Parrot to create the type we want and do the right thing with it.

[15:59] <pmichaud> or do we always just work with :capture ?

[16:00] <jnthn> It's meant to already have the HLL mapping support to do that.

[16:00] <pmichaud> (or whatever it's called)

[16:00] <jnthn> Well, that's our other option.

[16:00] <pmichaud> what does it do now?

[16:00] <jnthn> In NQP or Rakudo?

[16:00] <pmichaud> NQP

[16:00] <pmichaud> nqp-nom

[16:00] <jnthn> NQP still creates Hash and RPA

[16:00] <jnthn> But it still uses those everywhere ATM for arrays and hashes.

[16:00] <jnthn> e.g. I'm not at the point where I've had to tackle that issue yet.

[16:01] *** masak left
[16:01] <pmichaud> right, but we plan to replace those, yes?  when we do, how will it affect RPA/Hash in calling arguments?

[16:01] <jnthn> When we do that, we'll not want RPA and Hash to leak in.

[16:01] <pmichaud> so, every nqp program will need to be in its own HLL space?

[16:01] <pmichaud> (that does mapping?)

[16:02] <jnthn> If we solve it that way. As you mention, in that case we can also just take the Capture and do what we wish with it too.

[16:02] <pmichaud> okay

[16:02] <pmichaud> I think I'd prefer to take the capture, but we can postpone that decision to later

[16:02] <pmichaud> I'm not a fan of HLL mapping atm

[16:02] <jnthn> Yes, I'm fine with postponing it.

[16:02] *** daxim left
[16:03] <jnthn> pmichaud: Ponder whether we can get a real setting too.

[16:03] <jnthn> I already have it in nqpclr and nqpjvm.

[16:03] <pmichaud> define "setting"

[16:04] <jnthn> pmichaud: Outer lexical scope.

[16:04] <pmichaud> if "setting" means "standard runtime library", I'm in favor of that.

[16:04] <pmichaud> outer lexical scope.... 

[16:04] <jnthn> As in, the setting is the outer lexical scope of the program.

[16:04] <pmichaud> right

[16:04] <jnthn> As per Perl 6 spec.

[16:04] <jnthn> I just built it like that in nqpclr from the start.

[16:04] <pmichaud> I don't see a problem with that.

[16:05] <jnthn> It was kinda easy though when I could do lexicals the way I wanted. :)

[16:05] <pmichaud> oh, that's the other question I had --- does nqp-nom change lexical handling much?

[16:05] <jnthn> No.

[16:05] <jnthn> Not at all really.

[16:05] <pmichaud> I know it changes attribute handling.

[16:05] <jnthn> Yeah

[16:05] <jnthn> But lexicals are still the same.

[16:05] <pmichaud> okay, so lexicals are much the s.... right

[16:05] <jnthn> I'm just about certain I changed nothing.

[16:05] <jnthn> That said

[16:05] <pmichaud> too bad for now :-)

[16:05] <jnthn> I think we have a problem with lexicals.

[16:07] * pmichaud waits to hear the problem :)

[16:07] <jnthn> I want static lexpad support, natively typed lexicals, don't want to allocate a PMC every call frame to hold the lexicals when a single chunk of memory will do, and think most lookups should be done by index/scope count.

[16:07] <jnthn> Which is kind of a long way from what we have today.

[16:08] <pmichaud> let's address each of those one-at-a-time (more)

[16:08] <pmichaud> index/scope count could be done with a new opcode

[16:08] <pmichaud> at least the scope count part

[16:08] <pmichaud> $P0 = find_lex 3, '$a'

[16:09] <pmichaud> or   find_lex '$a', 3    (grab $a from 3rd outer)

[16:10] <pmichaud> I don't quite follow "allocate a PMC every call frame when a single chunk of memory will do"

[16:12] *** justatheory joined
[16:13] <jnthn> pmichaud: Right now, we allocate a PMC to store the lexicals in for every invocation that uses lexicals.

[16:13] *** Franek joined
[16:13] <jnthn> pmichaud: It's GC churn that we don't need, and that wins nothing.

[16:13] <pmichaud> the PMC doesn't actually hold the lexicals though, does it?

[16:13] *** JimmyZ left
[16:14] <jnthn> Not as such.

[16:14] <jnthn> It maps names to registers.

[16:14] <pmichaud> and that mapping is static, right?

[16:14] <pmichaud> I mean, it's the same mapping for the sub

[16:14] <jnthn> I'm not sure that's the case ATM.

[16:15] <pmichaud> right now I think the LexPad actually points directly to the register, yes

[16:15] <jnthn> I'm quite sure we create that table once per invocation.

[16:15] <pmichaud> but it could just as easily hold the register offset

[16:15] <jnthn> What I'd like is that we have one static name => index/offset/whatever table, and lexicals are just stored in something arrayish.

[16:16] <pmichaud> lexicals are already stored in something arrayish (more)

[16:16] <pmichaud> all we need is to make LexPad static or re-used across sub invocations

[16:17] <pmichaud> iirc, LexPad gets created from a LexInfo structure

[16:17] <pmichaud> it seems to me we could just create it once the first time, populate it with the register offsets, and reuse that over-and-over

[16:17] <pmichaud> then adjust find_lex and store_lex and stuff to do things based on array offset instead of hash fetch/store

[16:18] <jnthn> If we can do that, and can statically know those offsets too, that'd be ideal.

[16:18] <pmichaud> we do know the offsets statically -- that's what is in LexInfo (again, iirc)

[16:18] <jnthn> I got a notable win in the nqpclr binder when I switched it to bind at indexes, not names.

[16:18] <jnthn> *nod*

[16:18] <jnthn> OK, we may be some of the way there on that one.

[16:18] <pmichaud> oh, you mean at compile time

[16:18] <jnthn> Yes, at compile time.

[16:18] <jnthn> Well, at PAST::Compiler-time is probably enough.

[16:18] *** snearch left
[16:19] <jnthn> By then the lexpad is "closed" for modification, I guess.

[16:19] <jnthn> And it is what has to emit the find_lex/store_lex.

[16:19] <jnthn> The sig binder could resolve them once at the first bind.

[16:19] *** MayDaniel joined
[16:20] <pmichaud> anyway, omitting the lexical-lookup-by-offset for the moment

[16:20] <pmichaud> I suspect we could get a big win in the very short term by eliminating the LexPad-per-invocation code

[16:20] <jnthn> Same.

[16:20] <pmichaud> as in reducing GC pressure

[16:20] <jnthn> *nod*

[16:20] <pmichaud> well.... maybe not :-(

[16:21] <pmichaud> since LexPads are user-visible (at the PIR level), we'd have to have a separate object for each invocation

[16:21] <jnthn> My overall drive here is that we shouldn't have to be in a position where we fear to port a .local int lol to a my int $lol because the second is way more costly.

[16:22] <pmichaud> but perhaps those types of LexPads could be created on-demand instead of on every invocation

[16:22] *** plobsing left
[16:22] <jnthn> Hmm.

[16:22] <jnthn> Ah! I gotta leave now for a birthday party. :)

[16:22] <jnthn> And it's mine, so I really, really shouldn't be late for it. :)

[16:22] <pmichaud> ah, have fun.  Thanks for all of the info, I'll work on writing this up a bit later.  And happy birthday!

[16:22] <jnthn> I'll catch you tomorrow or so. :)

[16:22] <jnthn> Thanks!

[16:22] <pmichaud> (today is your birthday?)

[16:22] <jnthn> o/

[16:23] <jnthn> (yes, today)

[16:23] *** timbunce left
[16:23] <pmichaud> (cool)

[16:23] <jnthn> *gone*

[16:23] <colomon> \o/

[16:29] *** tzhs left
[16:29] *** timbunce joined
[16:39] *** plobsing joined
[16:43] *** MayDaniel left
[16:43] *** timbunce left
[16:44] *** Tedd1 left
[16:48] *** kst left
[16:50] *** Tedd1 joined
[16:50] *** timbunce joined
[16:50] *** kst joined
[16:56] *** envi left
[17:01] *** Franek left
[17:11] *** mberends joined
[17:14] *** timbunce left
[17:17] *** kensanata left
[17:20] *** timbunce joined
[17:24] *** cafesofie left
[17:24] *** cdarroch joined
[17:24] *** cdarroch left
[17:24] *** cdarroch joined
[17:29] *** Trashlord joined
[17:30] *** broquaint left
[17:30] *** broquaint joined
[17:31] *** wamba left
[17:32] <moritz_> jnthn++ # or jnthn.age++ or so :-)

[17:32] <moritz_> aka "congratulations"

[17:33] <[Coke]> jnthn++

[17:33] <tadzik> jnthn.age.postfix<++>.&wrap( { say "Happy birthday!" })

[17:34] <tadzik> or should this be present.&wrap? :) Happy birthday!

[17:34] <moritz_> fail, postfix:<++> is a sub, not a method :-)

[17:34] <tadzik> darn!

[17:35] <tadzik> well, that was way tooo nerdy ;)

[17:35] *** Mowah joined
[17:36] *** impious joined
[17:37] *** impious left
[17:41] *** pmurias joined
[17:42] *** cafesofie joined
[17:56] *** dakkar left
[17:57] *** plobsing left
[18:17] *** plobsing joined
[18:19] <PerlJam> jnthn: Happy Birthday!

[18:19] *** cjk101010 joined
[18:24] *** snearch joined
[18:24] *** ab5tract left
[18:26] <dukeleto> jnthn: Birthday.new.happy!

[18:32] *** pyrimidine joined
[18:35] *** GinoMan left
[18:36] *** klunky joined
[18:41] *** felliott left
[18:42] *** nadim_ left
[18:42] *** vapace joined
[18:43] *** klunky left
[18:44] *** nadim_ joined
[18:45] *** vapace left
[18:50] *** jedai joined
[18:51] *** cognominal left
[18:52] *** cognominal joined
[18:57] *** justatheory left
[18:58] *** cjk101010 left
[18:59] *** fhelmberger left
[19:02] *** MayDaniel joined
[19:07] <pmurias> sorear: hi

[19:08] *** plobsing left
[19:08] *** kjeldahl left
[19:11] *** ^Mike\b left
[19:12] *** plobsing joined
[19:17] *** Chillance joined
[19:17] *** ^Mike\b joined
[19:18] <^Mike\b> In Perl6, can you still do Perl5-style OO where you build a data structure and then say "poof! you're an object"?

[19:19] <pmurias> yes

[19:19] <pmurias> but i'm not sure it's implemented yet

[19:19] <^Mike\b> hmm

[19:19] <^Mike\b> yes, I was sad when I did not get Perl6 for Christmas :'(

[19:20] <tadzik> ^Mike\b: I think you can, bless is still there

[19:22] *** timbunce left
[19:23] <pmurias> but it's now more intended for language interop and stuff like making a Python hash an object

[19:34] *** vmspb joined
[19:37] <pmurias> sorear: what i would like to have documented even more then the opcodes is how in the .nam file everything is serialised

[19:38] *** justatheory joined
[19:39] *** timbunce joined
[19:52] *** _buno_ joined
[19:53] *** _buno_ left
[19:59] *** colomon left
[20:01] *** cognominal left
[20:01] *** cognominal joined
[20:06] <pmichaud> I'll be late (or possibly absent) to phone today

[20:11] *** coldhead joined
[20:23] *** MayDaniel left
[20:30] *** justatheory left
[20:31] *** justatheory joined
[20:35] *** felliott joined
[20:35] *** justatheory left
[20:36] *** felliott_ joined
[20:36] *** felliott left
[20:36] *** felliott_ is now known as felliott

[20:41] *** getpwnam left
[20:41] *** getpwnam joined
[20:41] *** jevin left
[20:41] *** jevin joined
[20:52] *** plobsing left
[21:00] *** spq1 left
[21:02] *** Mowah left
[21:08] *** xabbu42 left
[21:09] *** MayDaniel joined
[21:10] *** pmurias left
[21:11] *** colomon joined
[21:16] *** justatheory joined
[21:26] *** arlinius left
[21:38] *** pyrimidine left
[21:40] *** MayDaniel left
[21:40] *** timbunce left
[21:41] *** plobsing joined
[21:42] *** Kodi joined
[21:45] *** ^Mike\b left
[21:45] <dalek> specs: 53e18dd | (Kodi Arfer)++ | S03-operators.pod:

[21:45] <dalek> specs: [S03] Updated the semantics of infix:<xor> to match those of infix<^^>.

[21:45] <dalek> specs: review: https://github.com/perl6/specs/commit/53e18dd470

[21:59] *** tomaw left
[22:00] *** kst left
[22:00] *** kst joined
[22:00] *** puge left
[22:01] *** puge joined
[22:02] *** tomaw_ joined
[22:06] *** tomaw_ is now known as tomaw

[22:06] *** jevin left
[22:07] *** dukeleto left
[22:07] *** dukeleto joined
[22:39] *** noganex_ joined
[22:42] *** noganex left
[22:44] *** donflamenco joined
[22:46] *** snearch left
[22:48] *** donflamenco left
[22:53] *** donflamenco joined
[22:59] *** kaare_ left
[23:04] *** donflamenco left
[23:05] *** mikehh left
[23:10] *** rgrau joined
[23:11] *** VXZ joined
[23:14] *** justatheory left
[23:15] *** justatheory joined
[23:18] *** Franek joined
[23:18] *** whiteknight joined
[23:21] *** Franek left
[23:21] *** dorlamm joined
[23:26] *** Vlavv left
[23:29] *** Vlavv_ joined
[23:30] *** drbean joined
[23:33] *** kst left
[23:33] *** kst joined
[23:41] *** rgrau left
[23:49] *** leprevost joined
[23:58] * jnthn had a nice birthday evening, including awesome curry, nice beer and great company. :-)

