[00:00] <jnthn> sleep &

[00:07] <dalek> rakudo: 914bd1b | KodiB++ | src/Perl6/Grammar.pm:

[00:07] <dalek> rakudo: [Perl6/Grammar] Forbid mandatory positional parameters after parameters with default values.

[00:07] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/914bd1bb60

[00:07] <dalek> roast: b896f12 | (Kodi Arfer)++ | S06-signature/optional.t:

[00:07] <dalek> roast: [S06-signature/optional.t] Added tests for RT #76022.

[00:07] <dalek> roast: review: https://github.com/perl6/roast/commit/b896f124ed

[00:08] *** rgrau left
[00:11] *** cafesofie joined
[00:17] *** dukeleto left
[00:18] *** dukeleto joined
[00:27] *** stifynsemons left
[00:35] *** felliott_ joined
[00:35] *** felliott left
[00:36] *** felliott_ is now known as felliott

[00:40] *** wallberg left
[00:41] *** mberends left
[00:44] *** molaf_ joined
[00:47] *** Grrrr joined
[00:48] *** molaf__ left
[01:11] *** tarski left
[01:51] *** drbean joined
[01:53] *** pmurias left
[02:02] *** klunky joined
[02:05] *** klunky left
[02:06] *** klunky joined
[02:09] *** klunky left
[02:14] *** kst left
[02:14] *** QinGW joined
[02:14] *** kst joined
[02:33] *** coldhead` joined
[02:33] *** coldhead left
[02:33] *** rhizo left
[02:34] *** risou joined
[02:34] *** gimix joined
[02:35] *** risou left
[02:35] *** woosley joined
[02:36] *** Limbic_Region left
[02:54] *** whiteknight left
[02:54] *** cafesofie left
[03:04] *** cosimo left
[03:18] *** woosley left
[03:28] *** agentzh joined
[03:32] *** cafesofie joined
[03:32] <dalek> sprixel: f024f78 | diakopter++ | sprixel/s (5 files):

[03:32] <dalek> sprixel: attempt to use the so-called hand-optimized FrameBase

[03:32] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/f024f786f2

[03:34] *** QinGW left
[03:47] *** QinGW joined
[03:58] *** VXZ joined
[03:58] *** stifynsemons joined
[04:04] *** envi joined
[04:11] *** dukeleto left
[04:12] *** dukeleto joined
[04:14] *** woosley joined
[04:23] *** Su-Shee_ joined
[04:27] *** Su-Shee left
[04:30] *** kfo joined
[04:34] *** kfo_ left
[04:34] *** kst left
[04:35] *** kst joined
[04:38] *** drbean left
[04:41] *** coldhead` is now known as coldhead

[04:44] *** risou joined
[04:49] *** felliott left
[05:01] *** risou left
[05:02] *** risou joined
[05:11] *** mberends joined
[05:11] *** drbean joined
[05:41] *** mberends left
[05:43] *** starcoder left
[05:43] *** Patterner left
[05:46] *** Psyche^ joined
[05:46] *** Psyche^ is now known as Patterner

[05:46] *** starcoder joined
[05:55] *** mberends joined
[05:56] *** drbean left
[06:10] *** coldhead left
[06:15] *** coldhead joined
[06:17] *** ponbiki left
[06:18] *** ponbiki joined
[06:18] *** justatheory left
[06:19] *** mberends left
[06:20] *** cjk101010 joined
[06:22] *** masak joined
[06:22] <masak> morning, zebras.

[06:23] <sorear> hello, masak.

[06:23] <TimToady> greasings

[06:23] * sorear is hacking on meta operators

[06:23] <TimToady> you should do something fun instead :)

[06:25] <diakopter> .oO is there an -O metaop

[06:27] *** stifynsemons left
[06:28] <diakopter> I was interested to read that jnthn's metamodel rewrite in nqp-nom/6model is faster (on parrot) than parrot's implementation of the same.

[06:30] <TimToady> .oO(low bar)

[06:31] *** risou left
[06:32] *** kaare_ joined
[06:32] *** mberends joined
[06:33] <sorear> diakopter: That's not really very interesting... Parrot is fairly well designed insofar as you can replace all the PMC-level and op-level functionality without hurting performance at all

[06:34] *** starcoder left
[06:34] <sorear> that's one of the reasons I'd love to see Parrot win more

[06:34] <sorear> I would love to add a few new primitive types to the CLR

[06:34] *** agentzh left
[06:39] *** starcoder joined
[06:41] *** mberends left
[06:44] *** orafu left
[06:46] *** orafu joined
[06:47] * masak --> interview

[06:47] *** masak left
[06:49] *** tarski joined
[06:51] *** starcoder left
[06:55] <dalek> niecza: e2bc2bc | sorear++ | / (3 files):

[06:55] <dalek> niecza: Fix chained multiple evaluation, add rest of infix metaop parsing

[06:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e2bc2bcd97

[06:56] *** starcoder joined
[07:13] *** cosimo joined
[07:24] <dalek> niecza: 67c4da8 | sorear++ | src/ (2 files):

[07:24] <dalek> niecza: Compile (1,2,3)¬ª.sin forms

[07:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/67c4da83dc

[07:46] *** dual left
[07:56] *** baest joined
[07:59] <dalek> niecza: 990db5c | sorear++ | src/niecza:

[07:59] <dalek> niecza: Implement prefix metaop parsing

[07:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/990db5cc0e

[08:00] <sorear> ok.  compiler work for metaops is done.

[08:00] <sorear> next week's agenda: type constraints and MMD

[08:01] <sorear> after that: Roles?  &eval?  Better CLR integration?  Steal Rakudo's setting?

[08:03] *** drbean joined
[08:05] *** wtw joined
[08:05] *** agentzh joined
[08:18] *** Su-Shee_ is now known as Su-Shee

[08:26] <Tene> building on shared work is great.

[08:26] <Tene> I think you'd have trouble using rakudo's setting without roles, though.

[08:34] *** shi joined
[08:36] *** shi left
[08:37] *** risou joined
[09:06] *** noganex_ is now known as noganex

[09:17] *** snearch joined
[09:26] *** plobsing_ left
[09:32] <jnthn> morning, #perl6

[09:32] *** drbean left
[09:32] *** tzhs joined
[09:35] *** risou_ joined
[09:38] *** risou left
[09:41] *** woosley left
[09:41] *** jlaire left
[09:43] *** jlaire joined
[09:55] *** dakkar joined
[10:05] <dukeleto> jnthn: howdy

[10:06] <jnthn> o/ dukeleto 

[10:06] <colomon> \o

[10:08] *** tarski left
[10:08] *** daxim joined
[10:09] *** QinGW left
[10:12] * dukeleto is interested in subrectangles

[10:13] <dukeleto> i don't really see that term in the spec

[10:16] *** mberends joined
[10:36] *** stifynsemons joined
[10:36] *** risou joined
[10:37] <moritz_> what are subractangles?

[10:37] <moritz_> *rect

[10:37] *** risou_ left
[10:50] *** masak joined
[10:51] <masak> dukeleto, moritz_: "subrectangles" was a term I made up on the spot.

[10:52] <masak> I meant it as the two-dimensional version of a slice, which makes it more general than a rectangle, I suppose.

[10:52] * masak boggles a bit and then tries to find something sensible in S09

[10:52] <moritz_> something like @a[1..3;2..6] ?

[10:53] <masak> exactly.

[10:53] <masak> yes, it is in S09.

[10:54] <masak> S09:391: "A multidimensional array is indexed by a semicolon list, which is really a list of lists in disguise. Each sublist is a slice of one particular dimension."

[10:55] *** kst left
[10:55] *** kst joined
[10:56] <jnthn> yayitsmasak!

[10:57] <moritz_> lolitsjnthnmasakandtherest!

[10:59] <masak> lol!

[10:59] *** agentzh left
[10:59] <mathw> YAYCOOLPEOPLE

[11:00] <jnthn> omgz what did I start... :)

[11:02] <moritz_> lol!

[11:02] <masak> metayaypeopleareshoutingyay

[11:04] *** gimix left
[11:04] *** masak left
[11:05] *** masak joined
[11:08] *** woosley joined
[11:09] * masak has an amazing thing for what to use roles for

[11:09] <masak> s/thing/idea/

[11:09] <masak> will implement it in the next few days, and then showcase it here :)

[11:09] <moritz_> std: my $x; if $x<= 2 { 1 }

[11:10] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse quote-words subscript; couldn't find right angle quote at /tmp/X881qIs9_v line 1:‚ê§------> [32mmy $x; if $x<[33m‚èè[31m= 2 { 1 }[0m‚ê§    expecting escape‚ê§Parse failed‚ê§FAILED 00:01 120m‚ê§¬ª

[11:10] <masak> moritz_: why doesn't <= win over < there?

[11:10] <masak> oh, I think I see why.

[11:10] <moritz_> masak: because = is allowed in subscripts

[11:10] <masak> right.

[11:10] <masak> any solution that allowed that would be backtracking.

[11:12] * moritz_ replies to [perl #82638]

[11:13] *** nadim_ left
[11:14] *** dip joined
[11:14] *** dip is now known as Guest54166

[11:21] *** masak left
[11:21] *** y3llow left
[11:22] *** masak joined
[11:22] *** y3llow_ joined
[11:23] *** daxim left
[11:23] *** y3llow_ is now known as y3llow

[11:23] <IllvilJa> Anyone knows if posterous.com has died or something?

[11:23] *** jql left
[11:23] *** PZt left
[11:23] *** daxim joined
[11:23] <IllvilJa> Trying to read the latest mojolicious blog entry "The truth" and the page at posterous.com refuses to load.

[11:23] *** sftp left
[11:24] *** sftp joined
[11:24] <IllvilJa> (yes, I acknowledge that I abuse the fact that this is a nice, friendly channel and use it for asking a Perl5 related question...)

[11:25] <moritz_> there's a page on the intertubes that tells you if another site is down

[11:25] <moritz_> IllvilJa: http://www.downforeveryoneorjustme.com/

[11:25] <moritz_> http://www.downforeveryoneorjustme.com/posterous.com

[11:26] * IllvilJa immediately bookmarks the page!

[11:26] <IllvilJa> moritz_: Thanks!

[11:27] <IllvilJa> (and yes, it turns out that posterous.com really IS down... grumble.  That means that "The truth" is out of reach :-/ )

[11:41] <masak> IllvilJa: the Web is very unreliable. I tend to make backups of it to store locally.

[11:41] <jnthn> Oh, so *that's* what all those boxes in your appartment contain...

[11:42] *** tzhs left
[11:51] <masak> jnthn: you wouldn't believe how bulky some TLDs are.

[11:52] *** drbean joined
[11:55] <masak> S09 says @array[@x,@y] corresponds to @array.postcircumfix:<[ ]>( ((@x,@y)) ) -- why the double parens in the signature?

[11:56] <jnthn> masak: s/signature/arguments/ ?

[11:56] <jnthn> And, not sure if that's really caller side. :S

[11:56] *** JimmyZ joined
[11:57] <jnthn> One level of parens would make sense to me but the two is...odd.

[11:59] *** am0c joined
[12:03] *** cogno joined
[12:05] <masak> right, arguments.

[12:05] *** JimmyZ left
[12:06] *** JimmyZ_ joined
[12:06] *** JimmyZ_ is now known as JimmyZ

[12:09] <jnthn> masak: OK, then I dunno. If it were sig side it'd be an extra level of unpacking.

[12:09] <arnsholt> The calling convention of posticircumfix:<{ }> and <[ ]> is supposed to be (**@slice), might have something to do with it?

[12:10] <arnsholt> Although I have to admit I'm not entirely sure what that sig actually means :/

[12:14] <masak> jnthn: no, it can't be the sig side.

[12:15] <masak> arnsholt: signature.

[12:15] <masak> er. belay that. :)

[12:15] <masak> arnsholt: right; that's what I'm wondering, too.

[12:18] <dalek> nqp-rx/push_cached_eh: bffc552 | bacek++ | t/setting/01-resizablepmcarray.t:

[12:18] <dalek> nqp-rx/push_cached_eh: Stylish change in test.

[12:18] <dalek> nqp-rx/push_cached_eh: review: https://github.com/perl6/nqp-rx/commit/bffc552e0e

[12:19] *** cogno left
[12:21] <arnsholt> masak: I found my stuff in S06, "Multidimensional argument list binding"

[12:21] <arnsholt> FWIW

[12:26] <masak> 'k

[12:27] *** risou left
[12:27] *** coldhead left
[12:32] *** jfried joined
[12:36] *** icwiener joined
[12:40] *** karupanerura joined
[12:46] *** felliott joined
[12:47] *** JimmyZ left
[13:00] *** MayDaniel joined
[13:04] *** woosley left
[13:05] <takadonet> morning all

[13:10] * [Coke] sees something nice about parrot in backscroll on #perl6.

[13:10] <[Coke]> I would dance a small jig, 'tweren't it so cold!

[13:14] *** am0c left
[13:17] *** c9s left
[13:22] *** plobsing joined
[13:26] *** masak left
[13:27] *** awwaiid_ left
[13:29] *** saaki left
[13:30] *** saaki joined
[13:30] *** jql joined
[13:34] <pmichaud> good morning, #perl6

[13:34] <jnthn> morning, pmichaud 

[13:34] <moritz_> \o/

[13:35] <pmichaud> jnthn: great article on 6guts 

[13:35] <jnthn> pmichaud: Thanks. :)

[13:35] <jnthn> pmichaud: The grammar stuff was a bit of a battle, but I won. :)

[13:35] *** MayDaniel left
[13:36] <jnthn> pmichaud: The messiest bit was with the !PREFIX__ methods.

[13:36] <pmichaud> perhaps those can go away soon

[13:37] <jnthn> pmichaud: I suspect my hack/workaround to get them .^add_method'd will go away sooner. :)

[13:37] <jnthn> Anyway, just a heads up that I know that is nasty. 

[13:37] <pmichaud> np

[13:37] <jnthn> There's still some residual mess in the repo at the moment, e.g. a Cursor and Cursor2

[13:37] <moritz_> is there any example of how I can add a command line switch to rakudo?

[13:37] <jnthn> Will clear that up soon.

[13:38] <moritz_> or a pointer to some docs that might help me?

[13:38] <pmichaud> moritz_: maybe look at how check_syntax is done

[13:38] <jnthn> moritz_: iirc, NQP adds a --parse-trace

[13:38] <moritz_> thanks to both

[13:39] <pmichaud> moritz_: ack for 'addstage'

[13:40] <pmichaud> essentially, most options in rakudo are handled as additional compiler stages (not the ideal mechanism -- just left over from some long-ago hacks that people put in place to "get things working")

[13:40] * moritz_ wants to add an option for PIR-level backtraces

[13:40] <pmichaud> oh, I think that belongs in HLL::Compiler

[13:40] <pmichaud> (which Rakudo then inherits)

[13:40] * jnthn can see it being useful there too

[13:40] <moritz_> I had another idea for a command line switch, but I forgot it :-)

[13:41] <pmichaud> ack for 'parsetrace' in the nqp-rx src/ directory

[13:42] *** hanekomu joined
[13:43] <jnthn> pmichaud: I think I'm about a week away from branching Rakudo.

[13:43] <pmichaud> jnthn: yeah, that's what it looks like to me also

[13:43] <pmichaud> I'm about 2 days behind where I'd expected to be, because of time spent in the hospital

[13:43] <[Coke]> pmichaud, jnthn, moritz_ : good morning!

[13:44] <jnthn> pmichaud: OK, no hurry, whenever you have time, help is welcome. :)

[13:44] <pmichaud> yeah, I'll see if I can have the migration roadmap by wednesday.  I noticed you had some discussion with bacek++ ?

[13:44] <pmichaud> afk for a bit -- kids to school.  bbi10

[13:47] <jnthn> pmichaud: Yeah, I'm trying to keep an eye on the PCT work he's doing.

[13:47] <jnthn> pmichaud: Oh, and more recently trying to deal with a hot-path that's rather sub-optimal (adding a return exception handler makes invocation overhead 3 times higher...)

[13:51] *** masak joined
[13:52] *** cafesofie left
[13:54] *** cafesofie joined
[13:56] *** tzhs joined
[13:57] *** kst left
[13:57] <pmichaud> jnthn: chromatic++ and I have discussed the return exception handler issue quite a bit

[13:57] *** kst joined
[13:58] <jnthn> pmichaud: OK.

[13:58] <pmichaud> one possibility is to eliminate the exception handler altogether

[13:58] <jnthn> pmichaud: I added an opt that doesn't add it when there's no return, since it was so trivial to do.

[13:58] *** cafesofie left
[13:59] <jnthn> pmichaud: And use a continuation instead?

[13:59] <pmichaud> actually, it's the continuation that is expensive

[13:59] *** Kodi joined
[13:59] <jnthn> Ah, OK.

[13:59] <pmichaud> since an exception handler isa continuation

[13:59] <jnthn> Ah, yeah. :|

[13:59] <jnthn> .oO( Can't we just copy what the CLR does here... )

[14:00] <pmichaud> what does the clr do?

[14:00] <jnthn> Just has a table with each sub saying "from this region in the bytecode to this other one, there's a handler that is at this location"

[14:00] <jnthn> So there's nothing to set up at runtime

[14:00] <pmichaud> doesn't sound dynamic enough for the general case, though

[14:00] <jnthn> Just an extent list to look in when an exception is thrown.

[14:01] <pmichaud> here's my best guess

[14:01] <jnthn> For the general case as in "what Rakudo needs" or "what other languages need"?

[14:01] <pmichaud> for the general case of "a dynamic language with exceptions"

[14:01] <jnthn> OK

[14:02] <pmichaud> here's my best guess as of this morning:  each Sub maintains a lexically scoped 'return closure' that is in charge of return value checking and packaging things up to be returned

[14:03] *** drbean left
[14:03] <pmichaud> then, instead of throwing an exception, a 'return' statement looks for the dynamically-scoped closure and invokes it with whatever it's intended to return

[14:03] <pmichaud> that closure then packages up the arguments and invokes its outer's return continuation directly

[14:04] <pmichaud> falling off the end of the sub does the same thing -- it simply invokes the return closure

[14:04] <jnthn> pmichaud: And it uses a leave-like mechanism to actually exit the block?

[14:04] <pmichaud> we could put a method on Subs to invokes the return continuation, yes.

[14:05] *** cafesofie joined
[14:05] <jnthn> nqpclr does something along those lines, fwiw.

[14:05] <pmichaud> actually, replace closure with 'leave method' above and that might work as well

[14:05] <pmichaud> the tricky part being 'find the correct Sub to leave from'

[14:05] <jnthn> I guess I solved that somehow... :)

[14:05] <pmichaud> which I guess is the outer scope of whatever invokes 'return'

[14:06] <pmichaud> i.e., return's caller's outer

[14:06] <jnthn> Well not if it's a bunch of lexically nested blocks. Then it may be some way down the outer chain.

[14:06] <pmichaud> I meant outer in the "outer until you reach a Sub" sense

[14:06] <pmichaud> (sorry, wasn't clear about that)

[14:07] <pmichaud> but yes.

[14:07] <pmichaud> return looks at its caller's outer chain for the closest Sub, then invokes the .leave method on that

[14:07] <pmichaud> the .leave method on a Sub packages its arguments up according to the Sub's return signature, and invokes the Sub's return continuation

[14:08] <jnthn> That'd also fix the issues we have with return not working lexically in Rakudo.

[14:08] *** cafesofie left
[14:08] <pmichaud> right, I'm trying to solve both problems at once :-)

[14:08] <pmichaud> no sense solving the speed without getting the semantics right too

[14:09] <jnthn> nqpclr actually has an exception handler that catches the return exception and invokes .leave. The handler's outer is actually the block to leave, so it all "just works".

[14:09] <pmichaud> overall I think we have to fix 'return' sooner rather than later

[14:09] <jnthn> But you could also do it as you suggest and save having the exception throw at all.

[14:09] <jnthn> Well, yes, it'd be nice to fix it and leave. :)

[14:09] <pmichaud> it's not the exception throw I'm trying to avoid as much as the need to create the exception handler

[14:09] <jnthn> And get the return type check back in.

[14:09] <jnthn> *nod*

[14:10] <jnthn> Yeah, if creating exception handlers costs, it's not so fun to do it that way.

[14:10] <pmichaud> oh oh oh oh oh

[14:10] <pmichaud> duh!

[14:11] * pmichaud has an idea

[14:11] <jnthn> :)

[14:11] <pmichaud> what if we just have one exception handler for return exceptions, very near the top?

[14:11] <pmichaud> (of the caller stack)

[14:11] <pmichaud> a return exception goes to that caller, which then says "okay, figure out what .leave to invoke"

[14:12] <jnthn> ...then the cost of returning is proportional to stack depth? ;)

[14:12] <pmichaud> proportional to handler depth, no?

[14:12] <pmichaud> since most subs won't have handlers at that point

[14:12] <jnthn> I don't think those are two separate stacks...

[14:12] <jnthn> But I may be wrong.

[14:12] <pmichaud> they aren't

[14:13] <pmichaud> but is chasing up the caller chain that expensive?

[14:13] <jnthn> It's at least two pointer derefs per call frame.

[14:13] <jnthn> And horrible for cache locality.

[14:13] <pmichaud> hmmm

[14:14] <jnthn> Contexts are PMCs so you gotta follow the PMC data pointer, then the pointer to the caller, which is a PMC, and so forth.

[14:15] <pmichaud> it's still tons faster than creating the exception handler, especially since 'return' is "exceptional"  :-P

[14:15] *** plobsing left
[14:15] <pmichaud> still, I guess it's cheaper to have return check each frame for a control exception handler than to have every return go up the entire caller stack

[14:16] <jnthn> Yeah. Get 500 levels of recursion deep or something and suddenly things get expensive.

[14:16] <jnthn> (if you're chasing up the whole stack)

[14:17] <pmichaud> I suppose the former could also be statically analyzed in a lot of cases

[14:17] <jnthn> Yes, we can be smarter in the compiler too, I expect.

[14:17] <jnthn> Oh

[14:18] <jnthn> We could do that you're suggesting if we have a way to chase down the lexical chain instead and put the handler in the setting, I guess.

[14:18] <pmichaud> oh, that's not too bad

[14:19] <pmichaud> the fundamental question I'm trying to resolve is   "What does a 'return' statement generate in NQP?"

[14:19] <pmichaud> currently it creates and throws a return exception

[14:19] <jnthn> oh

[14:19] <pmichaud> we can keep that, or switch it to be a method call of some sort, or switch it to be some directly generated code

[14:20] <jnthn> If we do .leave on a block

[14:20] <jnthn> Then we *know* how to find the block.

[14:20] <jnthn> It's our nth outer

[14:20] <jnthn> And we statically know n.

[14:20] <pmichaud> but .leave != return

[14:20] <jnthn> ?

[14:20] <pmichaud> you mean do .leave on the Sub ?

[14:21] <jnthn> I mean 

[14:21] <jnthn> sub foo() { if lol() { return 42 } }

[14:21] <jnthn> That return could do nqp::get_nth_outer(1).leave(42)

[14:22] <jnthn> sub foo() { if lol() { if bbq() { return 42 } } } # nqp::get_nth_outer(2).leave(42)

[14:22] <pmichaud> nqp::get_nth_outer(2) doesn't sound very primitive

[14:22] <p6eval> nqp: OUTPUT¬´Confused at line 1, near ":get_nth_o"‚ê§current instr.: 'parrot;HLL;Grammar;panic' pc 635 (src/cheats/hll-compiler.pir:206)‚ê§¬ª

[14:22] <jnthn> So yes, on the sub.

[14:22] <jnthn> pmichaud: How so?

[14:22] <jnthn> I expect it's just getting mapped directly to an op

[14:22] <pmichaud> in the sense that PIR doesn't support it yet.  I guess we could add it as a dynop

[14:22] <jnthn> Right

[14:23] <jnthn> The dynop season is open. ;-)

[14:23] <pmichaud> I'm wondering if something like that plays well with the other lexotics

[14:24] <pmichaud> perhaps something even more general than get_nth_outer

[14:24] *** felliott left
[14:24] <pmichaud> because even simpler is   nqp::get_outer_Sub

[14:24] <pmichaud> (so the compiler doesn't have to calculate the depth)

[14:24] <jnthn> Huh.

[14:24] <jnthn> Why throw away static info only re-compute it at runtime?

[14:24] <jnthn> That thinking already does us a ton of damage.

[14:25] <pmichaud> as I said, I'm wondering about the other lexotics, like 'next' and 'last' and ...

[14:25] <pmichaud> they aren't purely static

[14:25] <jnthn> Hmm, I guess not

[14:26] <jnthn> They're not tied to a sub either really though, but also to a...hmm, well, I guess today map catches them. 

[14:26] <pmichaud> Lexotic operators

[14:26] <pmichaud> in Perl 6 include:

[14:26] <pmichaud> return next last redo goto

[14:26] <jnthn> Oh.

[14:26] <pmichaud> if we're solving 'return', let's be sure to handle the other four as well.

[14:26] <jnthn> Yeah, good point. :)

[14:27] <jnthn> Our current implementation of next/last/redo relies on them being dynamic, iiuc.

[14:27] *** icwiener_ joined
[14:27] <pmichaud> correct, because:

[14:27] <pmichaud> (C<next> without a label is purely dynamic.)

[14:27] <pmichaud> (S04)

[14:27] *** JimmyZ joined
[14:27] <jnthn> Aha.

[14:28] <jnthn> I guess I can see how last and redo basically reduce to goto.

[14:28] <pmichaud> um, last and redo are basically the same as next, I think

[14:29] <jnthn> Oh, I thought the S04 comment was just about next, which actually needs to interact with map.

[14:29] <masak> I hope the same goes for last and redo.

[14:29] <pmichaud> so do 'last' and 'redo'

[14:30] *** icwiener left
[14:30] <jnthn> Yeah, it'd be a pain otherwise.

[14:30] <pmichaud> 'last' terminates a map

[14:30] *** kaare_ left
[14:30] <jnthn> *nod*

[14:30] <pmichaud> 'redo' re-executes the map block without iterating

[14:30] <jnthn> Yes, though you could also see it as a goto to the top of the map block. But I think it'd be hard to implement that way.

[14:31] <jnthn> I vastly prefer the way we have it now.

[14:31] <pmichaud> you definitely don't want it to be a goto, because the map block is independent of the map

[14:31] <pmichaud> @list.map( { ... } )

[14:31] <jnthn> Oh, true.

[14:31] <pmichaud> the block doesn't know it's part of a map

[14:31] *** GinoMan left
[14:31] <jnthn> *nod*

[14:32] <jnthn> OK, I agree the S04 comment has to apply to redo and last too.

[14:32] <pmichaud> and might also be the same for 'goto'  :-P

[14:32] <pmichaud> (haven't thought about that one yet)

[14:32] <jnthn> goto; # somewhere! :-P

[14:33] <pmichaud> anyway, S04 says that return is   &?ROUTINE.leave

[14:33] <pmichaud> which implies that the compiler knows &?ROUTINE and simply invokes .leave on it

[14:33] <jnthn> Happily, &?ROUTINE means "resolved at compile time"

[14:33] <jnthn> *nod*

[14:34] <pmichaud> but I don't see where the control exception handler comes into play if that's the case

[14:34] <jnthn> We could either actually install an &?ROUTINE in the static lexpad (oh, wait...)

[14:34] <jnthn> or do something like I suggested

[14:34] <jnthn> No, me either.

[14:34] <jnthn> Should CONTROL get return?

[14:34] <moritz_> yes

[14:34] <jnthn> :/

[14:34] <pmichaud> and next/last/redo

[14:35] <moritz_> but not leave?

[14:35] * moritz_ not sure

[14:35] <jnthn> leave isn't exceptional

[14:35] <jnthn> iirc

[14:35] <moritz_> right

[14:35] <moritz_> it's rather primitive

[14:35] <jnthn> Maybe it boils down to, in absence of a CONTROL block in the routine where a return is used, we're free to optimize it to a return.

[14:36] <jnthn> e.g. &?ROUTINE.leave(42) is an optimization. Perhaps.

[14:36] <pmichaud> that sounds icky

[14:37] <pmichaud> sub foo() { return 42;  CONTROL { ... } }

[14:37] <jnthn> I was pondering it'd be twiddled in an optimization pass.

[14:37] <pmichaud> we can't decide how to generate the return until after the sub block is done.

[14:38] <pmichaud> so, what does it generate without an optimization pass?

[14:38] <pmichaud> is it still an exception?

[14:38] *** cafesofie joined
[14:38] <pmichaud> "optimization pass" implies "optional" to me

[14:39] <jnthn> I'd guess still an exception there, which is the pessimal case.

[14:39] <pmichaud> and so we'd need a control handler.... where?

[14:40] *** elb0w left
[14:40] <jnthn> I'm pondering that it'd look about the same as today in the pessimal case, and the optimizer strips off the exception handler and twiddles the PAST generated for return.

[14:40] <pmichaud> I don't like that answer.

[14:40] <pmichaud> first, I don't think 'return' should be that exceptional in PAST

[14:40] <jnthn> https://github.com/jnthn/6model/blob/master/dotnet/compiler/NQPOptimizer.pm does something like that, fwiw.

[14:40] <pmichaud> it's just a function call

[14:41] <jnthn> But only half of it.

[14:41] <pmichaud> and I think we should avoid installing exception handlers in every Sub

[14:41] <jnthn> (e.g. there's no pasttype<return> used anywhere)

[14:41] <jnthn> (then it strips the exception handler installation)

[14:41] <jnthn> s/there's/if there's/

[14:42] <jnthn> pmichaud: I agree we should avoid it, I'm more suggesting that we pessimaly do .control('return_pir') and then the optimizer - which then has enough info to easily know if it can get away with it - removes that and, if needed, re-writes returns to something more optimal.

[14:43] *** icwiener joined
[14:43] *** Su-Shee left
[14:43] <jnthn> I'd prefer an option that didn't see us have to do that but if we have to handle CONTROL - which expects it to be an exception - I'm struggling to see a better way off hand.

[14:44] <pmichaud> I'm saying that if we eliminate the need for exception handler in every Sub invocation, we've solved 90% or more of the problem and the optimizing step is something we can figure out a bit later

[14:44] *** stifynsemons left
[14:44] *** cafesofie left
[14:44] <jnthn> *nod*

[14:44] <pmichaud> because whatever we come up with needs to work in Rakudo also, and keying off of 'return' is going to require a ton of analysis to make it work right

[14:45] <pmichaud> NQP cheats on 'return'; Rakudo doesn't have that luxury

[14:45] <jnthn> pmichaud: Well, a single handler in the outermost scope that's found lexically, as we considered earlier, would still work.

[14:45] <pmichaud> yes, I'm liking that approach a lot better

[14:45] <jnthn> Yes, I'm still not enitrely sure I consider it fortunate that return is "just a normal sub call"...

[14:45] <jnthn> That means to optimize it we have to know "there's no other return in scope overriding it" :)

[14:45] <jnthn> Which we can but... :)

[14:46] *** icwiener_ left
[14:46] <pmichaud> well, Perl 6 depends on such knowledge anyway.  we'll eventually have to crack that nut.

[14:46] <jnthn> *nod*

[14:46] <jnthn> Yeah, I'm trying to stear us towards the "have meta-objects at compile time" part of that goal.

[14:46] <jnthn> The other nut to crack is having a static lexpad that is the same thing at compile time and runtime.

[14:47] <jnthn> Well, *an* other. :)

[14:47] <pmichaud> to what extent are the things in Optimizer.pm non-optional?

[14:47] <jnthn> The one I just linked?

[14:47] <pmichaud> i.e., if I remove the optimizer stage, does it still work?

[14:47] <jnthn> It's all optional.

[14:47] <pmichaud> okay.

[14:47] <jnthn> I don't run it by defualt.

[14:47] <pmichaud> good.

[14:47] *** cafesofie joined
[14:47] <jnthn> Note it's only in nqpclr

[14:47] <jnthn> Not in nqp-rx/nom :)

[14:47] <pmichaud> ah, didn't catch that.  thanks for pointing that out

[14:47] <jnthn> Many things land up in 6model first and then either graduate out of there or flunk it. :)

[14:48] <jnthn> (in the 6model repo, that is)

[14:48] <jnthn> That repo is getting confusing. It's really the nqp-on-other-backends repo by now.

[14:48] <pmichaud> it's okay, I expect such confusion given the multi-scoped nature of what we're trying to do right now

[14:49] <jnthn> I tried to clarify how I'm using the terminology in the opening part of overview.pod in the 6model repo

[14:49] <moritz_> I have a patch for a --ll-backtrace option... do you want to review it before committing?

[14:49] <masak> oh yes!

[14:49] <moritz_> patch for compilers/pct/src/PCT/HLLCompiler.pir that is

[14:50] <jnthn> moritz_: Eek. :)

[14:50] <pmichaud> moritz_: as you wish -- I can review or you can commit and then I'll review

[14:50] *** stifynsemons joined
[14:50] <jnthn> moritz_: Someone should patch nqp-rx/nom with that too

[14:50] <pmichaud> +1 from me for commit -- I'll revert if I see an issue

[14:50] *** stifynsemons left
[14:50] <moritz_> jnthn: I can probably do that too, but I don't knwo if I'll be able to test it :-)

[14:51] <jnthn> Given that it incoprorates the stuff that is (from its POV used to be ;-)) in PCT::HLLCompiler.

[14:51] <jnthn> moritz_: If it just builds, that's fine for me. :)

[14:52] <moritz_> pmichaud: pushed to parrot

[14:53] <pmichaud> moritz_: +1

[14:53] <pmichaud> jnthn: if nqp-rx/nom uses HLLCompiler, then it's already patched once Parrot has it, no?  ;-)

[14:53] <moritz_> pmichaud: \o/ is there documentation of default options somewhere?

[14:53] <pmichaud> moritz_: there was at one time; I think it's gone now

[14:54] <pmichaud> I somewhat expect PCT::HLLCompiler to be evolved away in the near future... but the options would remain in HLL::Compiler

[14:54] <jnthn> pmichaud: Incorporates by copy-paste... :)

[14:55] <pmichaud> jnthn: oh.  then we should work to eliminate PCT::HLLCompiler asap :-)

[14:55] <jnthn> pmichaud: plz :)

[14:55] <pmichaud> it should all just be HLL::Compiler

[14:55] * pmichaud needs more hours in a day, and fewer hours in health care facilities.

[14:56] * moritz_ also spent many hours in hospitals last week. Very draining.

[14:56] <jnthn> pmichaud: (all HLL::Compiler) yes, that's what's done in nqp-rx/nom

[14:57] *** icwiener_ joined
[14:57] <jnthn> moritz_: Thanks for that change, will be useful. :-)

[14:59] <masak> moritz_: now that you've been inside PCT::HLLCompiler, what would you say about the feasibility of -n and -p?

[15:00] <masak> (never mind doing it right with an alternative setting on the first attempt)

[15:00] <jnthn> I suspect those are Rakudo specific.

[15:00] *** icwiener left
[15:00] *** kaare_ joined
[15:00] <jnthn> (so would go in Perl6::Compiler)

[15:00] <jnthn> imo, anyway

[15:01] <moritz_> masak: I still haven't figured out how to add custom options to rakudo only

[15:01] *** PacoLinux joined
[15:01] <pmichaud> I suspect -n and -p need a lot of underlying lexical changes first

[15:01] <pmichaud> but I could be wrong about that

[15:02] <masak> quite possibly.

[15:03] <masak> (it quite possibly needs lexical changes, I mean)

[15:03] * jnthn forgets exactly what they do

[15:03] <pmichaud> iiuc, -n and -p change the notion of the setting

[15:03] <masak> ideally, yes.

[15:03] <masak> jnthn: they're really nice when writing commandline oneliners.

[15:03] <pmichaud> in the sense that they cause an alternate/additional setting to be invoked

[15:03] <moritz_> -n wraps in a  for lines() { <MAIN CODE HERE> } block

[15:03] <masak> jnthn: -n loops the program for each line of input, -p does the same but prints $_

[15:04] <pmichaud> which says to me that we need some setting cleanup :)

[15:04] <jnthn> ah, OK

[15:04] <jnthn> pmichaud: On setting, I'm leaning towards NQP's setting also being one for real at some point.

[15:04] <masak> I wanted it so much for Rakudo that I wrote 'pun', now probably very defunct.

[15:04] <moritz_> does p6 have continue { } blocks?

[15:04] <jnthn> pmichaud: nqpclr and nqpjvm have it that way, fwiw.

[15:04] <jnthn> It saves polluting namespaces.

[15:05] <pmichaud> jnthn: okay.  I'm a little concerned about getting "too much runtime" in place for nqp.... but I suspect we may be stuck with that.  I need to chew on it a bit more.

[15:05] *** plobsing joined
[15:05] <jnthn> pmichaud: *nod*

[15:05] <jnthn> pmichaud: My worry is that at the moment we rely on ResizablePMCArray etc to the point they get named in some NQP code at the moment.

[15:05] <jnthn> Any code that does that blows away its portability

[15:05] <jnthn> But there's not aways a sane alternative.

[15:06] <pmichaud> we might need a NQPArray abstraction or something

[15:06] <pmichaud> to map to the underlying vm

[15:07] <pmichaud> or we just start providing our own complete runtime.... but that starts to sound like a very different animal from NQP itself

[15:07] <pmichaud> or at least from NQP's original goals

[15:07] <pmichaud> I have some errands to run here -- bbiaw

[15:08] <jnthn> k

[15:13] *** icwiener joined
[15:14] *** karupanerura left
[15:16] *** mtk joined
[15:16] *** icwiener_ left
[15:17] *** Su-Shee joined
[15:18] <dalek> rakudo: 9fdad15 | moritz++ | build/PARROT_REVISION:

[15:18] <dalek> rakudo: bump PARROT_REVISION to get new --ll-backtrace option

[15:18] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/9fdad15b18

[15:19] *** felliott joined
[15:24] *** felliott left
[15:27] <Kodi> rakudo: say ?(0 ^^ 0);

[15:27] <p6eval> rakudo 388eed: OUTPUT¬´Bool::False‚ê§¬ª

[15:27] <Kodi> rakudo: say ?(1 ^^ 1);

[15:27] <p6eval> rakudo 388eed: OUTPUT¬´Bool::False‚ê§¬ª

[15:28] <Kodi> rakudo: say (1 ^^ 1).WHAT;

[15:28] <p6eval> rakudo 388eed: OUTPUT¬´Method 'WHAT' not found for invocant of class 'Undef'‚ê§  in main program body at line 22:/tmp/m2e9nKCIW6‚ê§¬ª

[15:29] <moritz_> it goes straight to a pirop... no wonder it's screwed up the return type

[15:30] <jnthn> whoa.

[15:30] *** wtw left
[15:30] * masak submits rakudobug

[15:31] <Kodi> masak: RT #72826, actually.

[15:31] <masak> gotcha.

[15:31] <masak> it did look familiar :P

[15:32] <Kodi> I'm working on it now.

[15:32] * masak prefers to be trigger happy than to miss rakudobug opportunities

[15:32] <masak> Kodi++

[15:34] *** VXZ left
[15:36] *** icwiener left
[15:36] *** icwiener joined
[15:38] <pmichaud> what goes straight to a pirop?

[15:39] <moritz_> infix:<^^>

[15:39] <pmichaud> it should be going to a pasttype

[15:39] <moritz_> goes to pirop:xor or something

[15:39] <pmichaud> that would be really wrong

[15:39] <pmichaud> since pirop:xor is binary

[15:39] *** MayDaniel joined
[15:39] <pmichaud> token infix:sym<^^>   { <sym>  <O('%tight_or, :pasttype<xor>')> }

[15:39] <pmichaud> right

[15:40] <pmichaud> it's a pasttype, not a pirop

[15:40] <moritz_> still wrong

[15:40] <pmichaud> we can't turn it into a &infix:<^^>  until we have some way of defering evaluation of arguments

[15:40] <pmichaud> because ^^ short-circuits

[15:40] *** Kodi left
[15:41] <moritz_> right

[15:44] *** felliott joined
[15:44] <pmichaud> see also discussion at http://irclog.perlgeek.de/perl6/2011-01-07#i_3162039

[15:46] <pmichaud> jnthn: ping

[15:47] <jnthn> pmichaud: pong

[15:47] <pmichaud> I have a question about nqp-nom and nqp-clr and the like

[15:47] <jnthn> k

[15:48] <pmichaud> one of the "features" of nqp-rx was that it could be used to create Parrot subroutines that required absolutely no additional runtime support.  To what degree is this capability lost in -nom and -clr and the like -- i.e., do we _always_ need some form of runtime support now?

[15:48] <jnthn> Parrot *subs* - we're fine there still, so far as I know.

[15:48] <jnthn> Methods - different story.

[15:48] <pmichaud> so, if I wrote in nqp:

[15:49] <jnthn> Multis - need runtime support.

[15:49] <pmichaud>     sub xyz($arg) { say($arg); }

[15:49] <jnthn> That's the current state.

[15:49] <pmichaud> that could still comple and run (assuming there's a &say somewhere)

[15:50] *** cjk101010 left
[15:50] <pmichaud> okay, so very basic routines are still possible, but as soon as you ask for a multi or a method you're needing the additional stuff

[15:50] <jnthn> pmichaud: Almost (more)

[15:50] <jnthn> The sub itself is totally fine.

[15:50] <jnthn> There are a couple of .loadlib calls added to get the dynops.

[15:51] <pmichaud> right

[15:51] <jnthn> Trouble is...classes do need the runtime support.

[15:51] <pmichaud> which means it's no longer generating standalone PIR

[15:51] *** arlinius left
[15:51] <pmichaud> well, classes need runtime support even in -rx, so that's not too big a stretch

[15:51] <jnthn> Yeah, but for that particular program I can remove the .loadlib calls and it works.

[15:51] <pmichaud> in -rx you still have to load P6object

[15:51] <moritz_> well, clases have always... right

[15:51] *** dfasfdasdasfsdaf joined
[15:52] <dfasfdasdasfsdaf> how do i dwnlod it

[15:52] <jnthn> pmichaud: as for nqp-clr, it always needs a runtime library.

[15:52] <pmichaud> I'm trying to decide if we drop the idea of generating code that doesn't need additional runtime support

[15:52] <jnthn> pmichaud: However, it's not very big.

[15:53] <moritz_> dfasfdasdasfsdaf: download what?

[15:53] <sorear> dfasfdasdasfsdaf: you will need more details

[15:53] <jnthn> pmichaud: And when I see "not very big" I mean 55 KB. :)

[15:53] <sorear> good * #perl6

[15:53] *** icwiener_ joined
[15:53] <pmichaud> i.e., there's always actually a runtime library in place.  Then the question becomes "how do we decide what goes in the default runtime library and what stays out?"

[15:53] <dfasfdasdasfsdaf> hao do i dwnlod perl 6

[15:53] <pmichaud> dfasfdasdasfsdaf: see http://perl6.org

[15:53] <dfasfdasdasfsdaf> nevar mind tho. i fgurd out

[15:53] <moritz_> dfasfdasdasfsdaf: Perl 6 is a language. How do you download English?

[15:54] <dfasfdasdasfsdaf> I'm just joking.

[15:54] <dfasfdasdasfsdaf> lulz

[15:54] <masak> dfasfdasdasfsdaf: what moritz_ is trying to say is that Perl 6 has different implementations.

[15:54] <jnthn> pmichaud: We're at the point now where there is so little you can do *without* the runtime library that I have to wonder how useful the goal is.

[15:54] <dfasfdasdasfsdaf> I'm pretty sure, I know what it is.

[15:54] <dfasfdasdasfsdaf> I've seen and used Perl before.

[15:54] *** pyrimidine joined
[15:54] <pmichaud> jnthn: depends on your definition of "we" (more)

[15:54] <dfasfdasdasfsdaf> Coded with it for five years.

[15:54] <masak> dfasfdasdasfsdaf: well, Perl 5 has (mostly) only one implementation.

[15:55] <pmichaud> certainly the people writing plumage and other nqp-based tools on Parrot have been able to do so with minimal runtime libraries

[15:55] <pmichaud> (but those have gradually expanded to include the use of the runtimes...)

[15:55] <jnthn> pmichaud: "we" was too broad there, and I think you've hit on the issue that underlies all of this.

[15:56] <jnthn> What I envision: a lightweight Perl 6 that works consistently over various VMs for writing compilers, meta-objects and so forth.

[15:56] *** icwiener left
[15:56] <pmichaud> yes, that's been my vision for nqp-rx as well (more)

[15:56] <jnthn> That's not really the same vision as soemthing that's basically a nicer layer on top of Parrot.

[15:56] <pmichaud> the original nqp (no -rx)   was really targeted towards being a high-level language for Parrot

[15:56] <jnthn> Right.

[15:57] <pmichaud> with nqp-rx I've been able to somewhat have it boths ways, but I'm thinking we're at a point where that's no longer possible

[15:57] <jnthn> I fear that trying to be both of those may be increasingly hard.

[15:57] <jnthn> I agree.

[15:57] *** jpike joined
[15:57] <pmichaud> we'll, clearly "lightweight Perl 6 that works consistently" is more what we need than the latter

[15:58] <pmichaud> at least for Rakudo, and I suspect for other HLLs as well

[15:58] <jnthn> Yeah

[15:58] <pmichaud> so, NQP emphasizes its smallness (relative to Perl 6) as opposed to its "no runtime footprint"

[15:59] <pmichaud> at least, going forward that's what we emphasize

[15:59] <jnthn> *nod*

[15:59] <pmichaud> I think I'm okay with that.  I don't see another promising path, at any rate.

[15:59] <TimToady> you could call it perk

[15:59] <moritz_> maybe we should tell the #parrot folks about that decision :-)

[15:59] <pmichaud> yes, I was also wondering if we should change the name to indicate the change in scope (more)

[15:59] <pmichaud> however, what we're saying is entirely consistent with the scope of nqp-rx as defined since 2009

[16:00] * moritz_ kinda expected that :-)

[16:00] <pmichaud> and I somewhat like the name "nqp"  :-P

[16:00] <jpike> not quite perl?

[16:00] <jnthn> pmichaud: I don't think that we have to abandon having something that is the "nicer way to work with Parrot than PIR". It basically is the nqp-rx that already exists today.

[16:00] * masak wonders what happened to the Parrot HLL "close"

[16:00] <plobsing> TimToady: perk on parrot is sort of already taken (project is dormant)

[16:01] <Tene> I vaguely remember the conversation where you were asking for suggestions on the name... might be interesting to go look it up again someday.

[16:01] <jpike> perch on parrot?

[16:01] *** kst left
[16:01] *** kst joined
[16:01] <jnthn> pmichaud: Whereas -nom is kinda a "new product" that's more suited to HLL developers and with an explicit cross-VM roadmap.

[16:02] <pmichaud> jnthn: perhaps... but I'm not much interested in maintaining two lines of development (more)

[16:02] <pmichaud> I'm not enamored enough of Parrot to want to have a Parrot-specific language anymore

[16:02] <sorear> looks like I need "return optimizations", "-n/-p", "lexotics" back on my TODO

[16:02] <sorear> short term

[16:02] <pmichaud> or, put another way, who is really the target audience for nqp-rx as it exists today, then?

[16:03] <pmichaud> if it's just people targeting Parrot, then nqp is decreasingly going to be the tool for them

[16:03] * [Coke] gets ready to completely re-implement partcl again!

[16:03] <[Coke]> . o O (oh wait, no I don't. ;)

[16:03] <pmichaud> [Coke]: actually, I suspect that won't be much necessary :-)

[16:04] <pmichaud> [Coke]: but I totally understand the sentiment :)

[16:04] <[Coke]> given that both versions are regularly broken (and no longer fixed, I suspect you're correct.)

[16:04] *** mtk left
[16:05] <jnthn> pmichaud: I don't see it as "we have to maintain both", so much as we just don't encourage the non-HLL development usage of nqp-rx to migrate to the new thing.

[16:06] *** tzhs left
[16:06] <pmichaud> well, if we do that, then we need to have a good way of avoiding confusion between the two

[16:07] <jnthn> *nod*

[16:07] *** Tedd1 joined
[16:07] <pmichaud> also, if nqp-rx starts to have a significant runtime (and looks less like a Parrot-specific HLL), there becomes much less clarity about bundling it with Parrot

[16:08] <jnthn> Also true.

[16:08] <moritz_> uhm

[16:08] <pmichaud> so I wonder if the next version of rakudo should be --gen-nqp instead of --gen-parrot

[16:08] <moritz_> I would hate to have another configure.pl step in Rakudo

[16:08] <pmichaud> and then nqp is responsible for bundling or obtaining the correct version of parrot and/or clr or whatever

[16:08] <Tene> nqnqp?

[16:09] <pmichaud> i.e., instead of Rakudo targeting Parrot, Rakudo targets NQP monthly releases

[16:09] <moritz_> Tene: already taken :-)

[16:09] <pmichaud> and NQP monthly releases bundle the appropriate version of Parrot

[16:09] <Tene> :P

[16:09] *** mtk joined
[16:09] <moritz_> pmichaud: which increases the release manager's workload

[16:09] <pmichaud> and NQP's configure (and possibly runtime?) can work out Parrot / CLR / whatever underlying backend

[16:09] <jnthn> pmichaud: That makes quite a bit of sense.

[16:09] <pmichaud> moritz_: it just means NQP has a separate release cycle

[16:10] <pmichaud> and a separate release manager

[16:10] <plobsing> IIUC, parrot's view of NQP is that it is a useful tool and that is why it is bundled. It has little to do with being a runtime-less PIR generator.

[16:10] <moritz_> pmichaud: "just"

[16:10] <pmichaud> plobsing: that wasn't the case a year or so ago

[16:10] *** icwiener_ left
[16:10] <moritz_> well, things changed in parrot land too :-)

[16:10] <TimToady> I'm looking for a better way to generate slides from text into either html or OOo; anybody have any ideas?

[16:10] <JimmyZ> NQP realeases when it is ready. 

[16:10] *** icwiener_ joined
[16:11] <TimToady> or into pdf, I guess

[16:11] <pmichaud> TimToady: I'm thinking of writing a tool to do that, in Perl 6.  But not likely to happen soon.

[16:11] <moritz_> TimToady: i wrote a p5 script that creates HTML slides that are based on the 's5' HTML+JS+CSS template

[16:11] <[Coke]> TimToady: spork?

[16:11] <pmichaud> I've had slideshows done in PmWiki, and of course I'm a longtime user of spork (but only because I've been too lazy to write my own)

[16:11] <Tene> TimToady: the last time I wanted to do that, I used Beamer

[16:11] <moritz_> TimToady: https://github.com/moritz/perltalk very minimalistic in terms of features

[16:12] <pmichaud> I have fantasies of someday having a pod to slideshow generator.

[16:12] <TimToady> I want something that can do takahashi-esque, code samples, color highlighting

[16:12] *** envi left
[16:12] <masak> TimToady: I have one of those.

[16:12] <pmichaud> anyway, slideshow generation is likely to be my next "big project" when I'm at a lull with Rakudo development

[16:13] <TimToady> I'm going to India on Thursday, and I'd like something a bit more polished than my whipped-up-in-one-hour Perl script

[16:13] <TimToady> oh, and I'd like to be able to embed clickable links

[16:13] <masak> TimToady: https://github.com/masak/talks/blob/master/yapc-eu-2010-appetizers/make-presentation

[16:14] <masak> TimToady: it's in Perl 6, and it does all you said above before you said "clickable links" :)

[16:14] <TimToady> control of font sizes and colors?

[16:14] <masak> possible.

[16:14] <pmichaud> plobsing: at the beginning of 2009 there was a big push to get all of the HLLs out of the parrot repository -- i.e., unbundled from Parrot

[16:14] <TimToady> define "possible"...

[16:15] <masak> highlighting is all there.

[16:15] <TimToady> what is the final form?

[16:15] <masak> font sizes try to be good defaults, and if they're not... one needs to change the source code.

[16:15] <pmichaud> nqp-rx was then later added back in because it was a parrot-specific tool used primarily to build other HLLs

[16:15] <masak> TimToady: SVG slides, which I then convert to a single PDF.

[16:15] <plobsing> pmichaud: and nqp is unbundled in that sense. it's development is independant (although closely coupled).

[16:16] <pmichaud> plobsing: our point is that development may be about to decouple even further 

[16:16] <masak> TimToady: ISTR you were at the YAPC::EU 2010 talk where I used this.

[16:16] <pmichaud> s/point/thought/

[16:17] <TimToady> well, I'm not sure I need the zoom/pan bits of that

[16:17] <masak> no, not that one :)

[16:17] <TimToady> or was that a different talk

[16:17] <masak> yes :)

[16:17] <masak> this one does title slides, text slides, code slides.

[16:17] <masak> all very orderly and static.

[16:17] <plobsing> pmichaud: perhaps, but parrot does want a structured "middle-level" language. NQP satisfies that description even if it does have some runtime library.

[16:17] <TimToady> I seem to recall that pdf can have embedded links

[16:18] <moritz_> it can

[16:18] <pmichaud> plobsing: good to know, then

[16:18] <moritz_> pdflatex often generates them

[16:19] <jnthn> plobsing: It's worth remembering that nqp-rx/nom is very different in its usage of Parrot. It doesn't use Parrot's Class/Object to implement its classes. It doesn't use Parrot's multi-dispatch.

[16:20] <TimToady> but popping up another window every time is perhaps a problem; might just be easier to switch desktops for links...

[16:20] *** plainhao joined
[16:20] <masak> if links are a requirement, I'd recommend Beamer as well.

[16:20] <TimToady> what does Beamer do poorly?  :)

[16:20] <moritz_> syntax hilighting

[16:21] <moritz_> (latex in general)

[16:21] <plobsing> jnthn: in practice, most old-style NQP-rx programs also didn't work all that well with Parrot's underlying model. Many implemented runtimes of their own. close-lang got bogged down and turned into kakapo (yet another NQP runtime).

[16:22] <slavik> TimToady: drive on roads? :P

[16:22] <pmichaud> I think one of the first things I should do is publish a guide of standardized names for our nqp variants

[16:22] <pmichaud> much like we had rakudo-alpha and rakudo-ng

[16:22] <TimToady> I think most of my Perl driving is off-road these days

[16:23] <pmichaud> . o O( that's why it crashes so often )

[16:23] *** icwiener joined
[16:23] <slavik> I had an idea (unrelated to Perl6, feel free to flog me for this). What if the ordering of directory names in a file system didn't matter? That is: /a/b/c/file would be the same as /c/b/a/file and same as /b/c/a/file and son on.

[16:23] *** icwiener left
[16:23] *** icwiener joined
[16:23] <slavik> also /a/b/file would be valid as well

[16:23] <moritz_> slavik: I wouldn't want to work on such a system

[16:24] <huf> april's coming up, i think you should expand this idea in time for that

[16:24] <TimToady> it would be a set theory filesystem

[16:24] <pmichaud> slavik: sounds to me like the path prefix becomes unimportant, then

[16:24] <slavik> TimToady: yes

[16:24] <slavik> pmichaud: right

[16:24] <huf> the "path prefix" is a freetagging system

[16:24] <pmichaud> so, a filesystem with no namespaces

[16:24] <slavik> right, huf

[16:24] <slavik> pmichaud: yes

[16:25] <pmichaud> slavik: the first thing that will happen is that people will start writing  "a-b-c-file" to distinguish it from "c-b-a-file" and "b-c-a-file"  :-P

[16:25] <slavik> pmichaud: but they are equal ;)

[16:25] <TimToady> could be emulated with a notation that orders the set members behind the scenes

[16:25] <slavik> also /a/b/file is the same as the above, although /a/b would also include /a/b/d/file

[16:25] <slavik> :-\

[16:25] <slavik> TimToady: yeap

[16:26] <pmichaud> my point is that if you don't provide usable namespaces, people will layer their own on top

[16:26] *** icwiener_ left
[16:27] <slavik> I actually had a perl script written that did that ... it was a while ago though

[16:28] <TimToady> masak: does your system allow copy/paste of text?

[16:28] <slavik> TimToady: it should ^^

[16:28] <slavik> no wait, masak has a filesystem?

[16:28] <slavik> TimToady: or you mean mine?

[16:29] <pmichaud> slavik: different thread

[16:29] <slavik> oh

[16:29] <slavik> I'll shut up then

[16:29] <pmichaud> slavik: timtoady is talking about masak's slideshow software

[16:29] <slavik> ooh

[16:29] * colomon is overjoyed to see such an active #perl6 again.  

[16:29] *** dfasfdasdasfsdaf left
[16:29] <pmichaud> (or software that is being coerced into making slideshows)

[16:29] *** wooden joined
[16:29] *** wooden left
[16:29] *** wooden joined
[16:29] <TimToady> I would probably also be happy with something that would import to OOo Presentation

[16:30] <pmichaud> jnthn: do you think our new version of nqp should (1) be bundled like a parrot subsystem or (2) be a standalone platform that bundles a copy of parrot or (3) other?

[16:32] <pmichaud> or, more precisely:  which way would you tend to lean at this point?

[16:33] <jnthn> pmichaud: I'd like to try and work out something now that fits in with the "NQP is available on multiple VMs" goal.

[16:33] <pmichaud> that sounds like #2

[16:33] <jnthn> pmichaud: Well, the bundling is a user convenience. (more)

[16:33] <slavik> I just realized something

[16:33] <Tene> slavik: there's at least one FUSE filesystem that does this.  I know that I wrote a prototype versiont hat does it, once.

[16:33] <jnthn> I don't think we're going to start bundling a CLR or JVM implementation. :)

[16:33] <pmichaud> bundling is a user convenience for now, yes

[16:33] <tadzik> o/

[16:34] <pmichaud> eventually nqp is smart enough to detect what platform(s) you have installed and use those, I'd hope

[16:34] <jnthn> That'd be the ideal.

[16:34] <slavik> Tene: nice ... does it make sense to do this type of stuff?

[16:34] <jnthn> For now though, it's nice to make it easy to get started.

[16:34] <Tene> slavik: My prototype version used a normal directory for a backend, storing file tags as extended attributes on the files.

[16:34] <pmichaud> well, moritz++ is absolutely correct that we need to keep release management and install in mind

[16:34] <Tene> slavik: I never actually had any use for it, personally.

[16:35] <jnthn> pmichaud: Typically the dependency chain is HLL Compiler (e.g. Rakudo) ==> NQP+PCT+6model ==> VM

[16:35] <pmichaud> correct

[16:35] *** wooden left
[16:35] <jnthn> So bundling NQP with Parrot would be making an exception to what I'd expect to be the common case.

[16:35] <jnthn> OTOH, it's convenient. 

[16:35] *** mberends left
[16:35] <jnthn> And doesn't prevent NQP from having a --gen-parrot

[16:35] <masak> tadzik: \o

[16:36] <pmichaud> well, the alternative (#1)  would mean that we continue to have a --gen-parrot for rakudo and use the nqp from it.... which seems backwards now

[16:36] <slavik> Tene: as I feared, finding a real world useful application would be difficult

[16:36] <pmichaud> at least, it's backwards w.r.t. nqp's stated goals

[16:36] <jnthn> pmichaud: It feels kinda the wrong way around to me, yes.

[16:36] <slavik> although it could be done for searches ...

[16:36] <Tene> You may also want to consider alternative backends.  If you want rakudo on clr, is nqp going to bundle the clr?

[16:37] <jnthn> Tene: No. :)

[16:37] <pmichaud> 15:59 <moritz_> maybe we should tell the #parrot folks about that decision :-)

[16:38] <pmichaud> I think I'll write this up as an email or blog post (before this weekend's PDS)

[16:38] <jnthn> pmichaud: That'd be helpful.

[16:38] <pmichaud> Tene: the discussion above is about alternative backends, yes.

[16:38] <pmichaud> the only reason for bundling parrot at this stage is convenience to end users

[16:38] <pmichaud> eventually they should be separate

[16:38] <jnthn> *nod*

[16:39] *** wooden joined
[16:40] <pmichaud> and, of course, we're only really looking at nqp releases that bundle parrot.... the repo itself doesn't bundle it

[16:40] <pmichaud> same as what we do now

[16:40] <TimToady> I think control exception handlers are really just a bitmap in a word of the stack frame; very cheap to enter by setting a single (statically knowable) word

[16:40] <TimToady> and throwing a control exception is running up the dynamic stack looking for a particular bit

[16:40] *** icwiener left
[16:40] <pmichaud> TimToady: that's helpful to know

[16:41] *** icwiener joined
[16:41] <TimToady> and yes, leave is post-exception, more like a continuation invocation

[16:41] <jnthn> TimToady: leave is what actually unwinds the stack, iiuc?

[16:42] <pmichaud> TimToady: but if there's no control exception handler in place, does that mean we end up running up the dynamic stack just to find there isn't one?

[16:42] <TimToady> yes, if that's a valid concept in CPS :)

[16:42] <TimToady> there are always control exception handlers at the top

[16:42] <dalek> sprixel: e0deb14 | diakopter++ | sprixel/src/runtime/HandOptFrame. (2 files):

[16:42] <dalek> sprixel: fixup HandOptFrame for .net's/mono's x86 JIT.

[16:42] <dalek> sprixel: for some reason .net's amd64 JIT was letting the too-low .maxstack slide...

[16:42] <dalek> sprixel: also change Framebase *not* to derive from System.Object.

[16:42] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/e0deb14fb5

[16:42] <pmichaud> okay, so we end up chasing up the dynamic stack just to find the one at the top?

[16:43] *** hercynium joined
[16:43] <TimToady> but it should be cheap enough that every sub can manage its own bitmask

[16:43] <pmichaud> as jnthn++ noted earlier... that sounds expensive for the common case

[16:43] <TimToady> no, it's not

[16:43] <TimToady> it only happens if you have an unhandled exceptoin

[16:43] <TimToady> tion

[16:43] *** icwiener_ joined
[16:43] <pmichaud> an unhandled control exception?

[16:44] <jnthn> pmichaud: I think TimToady is still assuming there'll be a return exception handler per sub.

[16:44] <TimToady> yes, it's just very cheap to setup on entry, hopefully

[16:44] <pmichaud> that's our problem... currently it's very expensive to set up on entry

[16:44] <TimToady> esp if we can put off cloning CATCH/CONTROL till we need it

[16:45] * diakopter finds it hard to imagine it could be made much cheaper to set up on entry

[16:45] <TimToady> that would be after the bit check in the frame

[16:46] <pmichaud> so the bit check simply says "I catch this type of control exception", and then there's some additional logic to figure out what happens?

[16:46] <TimToady> in any case, it needs a clone only if you actually have a CONTROL, and if it refs outer lexicals

[16:46] <TimToady> yes, do it as lazily as possible at that point

[16:46] <TimToady> all you do is check the same bit in every stack frame till you find one

[16:46] <jnthn> That'd be cheap.

[16:46] <TimToady> then you do whatever work is necessary

[16:47] <TimToady> for a small number of important exceptions, this can be very fast

[16:47] <TimToady> could even promote some CATCH exceptions to this mechanism, if there are spare bits

[16:47] *** icwiener left
[16:47] <TimToady> or at least have a bit that says "there's a CATCH"

[16:48] <TimToady> is it possible in PIR to access the stack frame, or is that all encapsulated to the point of brittleness?

[16:48] <pmichaud> well, can do bits to say "I catch these control exceptions", and when found we look to see if there's a CONTROL block (if yes, invoke it, if not, then go to the default handler)

[16:49] <pmichaud> We can access the stack frame, yes

[16:49] <pmichaud> but we have limited ability to add our own attributes to it

[16:49] <jnthn> We have commit bits..

[16:49] <jnthn> ;)

[16:49] <pmichaud> well, the stack frame will point back to the original block, though, and there we could hang some attributes

[16:49] <pmichaud> since this information is largely static, iiuc

[16:50] <jnthn> pmichaud: There's also those bits that every PMC has (private bitfield)

[16:50] <jnthn> For flags

[16:50] <jnthn> Though only 7 bits and some may be in use.

[16:50] <TimToady> likewise, I think $! and $/ could be special cased to have very low-overhead creation, if an access can be generated that checks a static bit

[16:50] *** wooden left
[16:51] <pmichaud> well, it becomes a question of whether it's cheaper to set the bits in the stack frame on every sub entry or to simply set the bits on the static sub and check it when the exception is generated

[16:51] <pmichaud> since the stack frames reference the original sub

[16:51] <slavik> Tene: I got one, if you use the file system to store docs, this can be used as a basic keyword search for relevent docs (back to the filesystem), do that make sense?

[16:51] <jnthn> pmichaud: Oh.

[16:51] <jnthn> pmichaud: A custom Sub PMC subclass is very feasible.

[16:52] <pmichaud> right

[16:52] <diakopter> phenny: ask sorear is dalek okay? I pushed something to github sprixel and haven't seen it yet

[16:52] <phenny> diakopter: I'll pass that on when sorear is around.

[16:52] <jnthn> pmichaud: I'm already doing it to have a DispatcherSub for implementing proto

[16:52] <TimToady> maybe one bit in the frame for "is interested in control exceptions"

[16:52] <pmichaud> 16:49 <pmichaud> well, the stack frame will point back to the original block, though, and there we could hang some attributes

[16:52] <TimToady> and the rest one level of indiretion away

[16:52] <diakopter> phenny: ask sorear nm now I see it

[16:52] <phenny> diakopter: I'll pass that on when sorear is around.

[16:52] <TimToady> .o(level of indiscretion)

[16:52] <jnthn> pmichaud: Exactly.

[16:53] <pmichaud> of course, most of the control exceptions are lexotic, so it's not just the dynamic scope we're looking at

[16:53] <TimToady> the whole point of "exceptions" is that you optimize with the assumption they won't occur, and that you're willing to do more work later if they do

[16:54] <jnthn> pmichaud: Yes, but it's just as easy to follow the static chain.

[16:54] <pmichaud> jnthn: correct.

[16:54] <TimToady> but I don't see how we can do less than one bit per frame

[16:54] <pmichaud> TimToady: does it have to be tied to the frame itself, if the frame already reference the block?

[16:55] <pmichaud> i.e., the block can hold the bit(s) ?

[16:55] <TimToady> well, that's an implementation detail

[16:55] <pmichaud> okay, wfm

[16:55] <TimToady> just do the fastest thing :)

[16:55] <pmichaud> just wanted to make sure there wasn't some level of dynamic-exception-handling that might make it be very per-frame instead of per-block

[16:56] <TimToady> I think a registering-interest bit can be static even if the CATCH/CONTROL is completely dynamic in its decisions

[16:56] <pmichaud> perfect, wfm

[16:57] <jnthn> Sounds good.

[16:58] <pmichaud> jnthn: would all of this imply we're basically implementing our own exception handlers and avoiding the Parrot ones?

[16:58] <pmichaud> at least for the control exceptions?

[16:58] <TimToady> you still have to do the throw, even for lexotics

[16:58] *** wooden joined
[16:58] <jnthn> pmichaud: heh :)

[16:58] <jnthn> pmichaud: ...just about... :)

[16:58] *** MayDaniel left
[16:59] <TimToady> optimizing out the throw would require knowing the call graph

[16:59] <pmichaud> the corollary question is -- can we get something like this into Parrot, and is it worth the effort?

[16:59] <plobsing> fwiw, exceptions being slow hurts more than just NQP

[16:59] <pmichaud> plobsing: it's not the exceptions that are slow as much as the cost of creating the handlers

[17:00] <plobsing> yes. the overhead of using (or expecting to use) exceptions anywhere.

[17:00] <jnthn> pmichaud: Well, I am the expert at subverting Parrot... :/

[17:00] <jnthn> pmichaud: At this rate we'll mostly only use it for GC and a runloop. :)

[17:00] <TimToady> at a guess, I'd say that normal return exceptions probably merit their own bit in the frame since they're the hot path

[17:01] *** cafesofie left
[17:01] <TimToady> dynamic frame visit: check bit && call handler

[17:01] <jnthn> pmichaud: Anyway, I suspect it's do-able but may be worth seeing if we can do try and get it into Parrot in a more "official" way.

[17:02] <TimToady> lexotic frame visit: check bit && check lexotic identity guard && call handler

[17:02] *** justatheory joined
[17:02] <pmichaud> yes, I'm thinking more along the lines of "can we get parrot to migrate to this model" as opposed to subverting it :)

[17:02] <jnthn> Depends how soon we want it. :)

[17:02] <TimToady> alternately, the dynamic version is just the lexotic version with a *

[17:03] <jnthn> if Parrot migrates to it then we can have the bit in the call frame so it's a pointer follow or two less.

[17:05] <TimToady> I'm of two minds about whether the lexotic identity check should be based on smart-matching

[17:06] <TimToady> on the one hand, it is behind the "I care" bit check, so overhead is not so much an issue

[17:07] <TimToady> on the other hand, doing something as complicated as smartmatching for something so low-level is just asking for problems

[17:07] <TimToady> probably normal lexotic checks based on &?ROUTINE.WHICH can be special cased, and smartmatching provided as a backup

[17:08] <jnthn> TimToady: Nod. .ACCEPTS is no longer the ultimate type-checking primitive in 6model. It delegates to something in the meta-model, and anything that cares about a fast type check goes and straight to the meta-model for the answer.

[17:08] <TimToady> sounds good

[17:08] <jnthn> The cost was just too high going through an explicit .ACCEPTS call every time.

[17:09] <TimToady> yes, we certainly don't want .ACCEPTS in the normal return path :)

[17:09] <jnthn> Right. :)

[17:09] <jnthn> Or the parameter type checking path... :)

[17:10] <TimToady> the only question is how much we can hide that from the user, so it always looks like smartmatching

[17:10] <jnthn> Well, smart-matching would directly delegate to it, so *that* way around it works.

[17:10] <TimToady> but that's partly why we broke the symmetry of ~~

[17:10] <TimToady> so that we could optimize based on the RHS's type

[17:11] <jnthn> Yes, if we know it's just going to be a type object in there we could optmize away the .ACCEPTS call there.

[17:11] <jnthn> s/in there/on the RHS/

[17:11] <TimToady> which is why I was so steamed that p5 borrowed the symmetrical version :)

[17:12] <jnthn> :)

[17:12] <masak> they got better, though.

[17:12] <TimToady> yup, after I yelled...

[17:12] *** plobsing left
[17:13] <pmichaud> okay, I have $otherjob tasks to do now.  Then I'll work on writing up a plan for nqp that can be published and made available in time for pds

[17:13] <Tene> jnthn: afaict, parrot is glad to accept any improvements to exceptions and handlers

[17:13] <pmichaud> I think I want to start dropping the -rx from nqp now (and even perhaps change the repo)

[17:14] <Tene> Just needs someone to do the work.  Whiteknight has been interested in exceptions work lately.

[17:14] <pmichaud> there's no longer a 'nqp' in the parrot repository afaict so we don't need the -rx to make that distinction.  I'll keep -rx on the version of nqp that we have now that is bundled in parrot, though.

[17:15] <pmichaud> to distinguish it from the newer version(s) of nqp that will be coming along soon

[17:15] <jnthn> pmichaud: A way to talk about the different backends would be helpful too.

[17:16] <pmichaud> jnthn: perhaps that just nqp-parrot and nqp-clr for now

[17:16] <jnthn> e.g. nqp-clr

[17:16] <jnthn> Yeah, wfm.

[17:16] <pmichaud> where "nqp" is the overall name for the platform, and "-parrot" and "-clr" are the versions designed for specific platforms

[17:16] <jnthn> I'm happy for the stuff in the 6model repo to migrate when the time is right.

[17:16] <jnthn> It was only ever intended as a working repo.

[17:16] <pmichaud> and eventually we hope to be able to drop those extensions into a final merged product

[17:16] <jnthn> +1

[17:18] <pmichaud> I'll be a little busy with $otherjob stuff today, so will have to work on the draft either tonight or early tomorrow

[17:18] <jnthn> pmichaud: That's fine. I have $otherjob to worry about a bit this week too :)

[17:22] <TimToady> moritz_: to the first approximation, p5's "continue {}" is spelled "NEXT {}" in p6

[17:22] *** JimmyZ left
[17:23] <moritz_> TimToady: or LEAVE { }

[17:24] <moritz_> afaict after each iteration the block itself is left, no?

[17:24] <TimToady> that would also run on a last though

[17:24] <TimToady> NEXT doesn't

[17:25] <TimToady> you'll note that continue isn't called in p5 on a last

[17:26] *** plobsing joined
[17:32] <masak> put differently, calling &next doesn't always trigger NEXT {}

[17:33] <masak> though calling &last probably always triggers LAST {}

[17:33] <masak> hey, why isn't there a REDO {} block? :) is it because UNDO {} already covers that?

[17:34] *** rgrau joined
[17:35] *** plobsing left
[17:35] *** kst left
[17:35] *** kst` joined
[17:39] *** nadim_ joined
[17:40] *** Lorn left
[17:45] *** impious joined
[17:45] *** impious left
[17:46] *** kjeldahl left
[17:54] *** hanekomu left
[17:55] *** kjeldahl joined
[17:57] *** dakkar left
[17:58] *** cdarroch joined
[17:58] *** cdarroch left
[17:58] *** cdarroch joined
[17:59] *** mberends joined
[18:00] *** necrodearia joined
[18:03] <TimToady> masak: calling &next is supposed to always trigger NEXT

[18:04] <TimToady> S04:1420

[18:04] *** mikehh joined
[18:05] <masak> TimToady: you can't have it both ways. either it's always triggered, or it doesn't trigger on the last execution.

[18:06] <diakopter> but just look ahead into the future...

[18:06] <TimToady> it's not for after the test

[18:06] <TimToady> if there's some spec that implies that, it's wrong

[18:06] *** MayDaniel joined
[18:06] <masak> ah; I see now. I think I misunderstood what you said above.

[18:07] <masak> <TimToady> that would also run on a last though

[18:07] <masak> <TimToady> NEXT doesn't

[18:07] <masak> I read that "last" as "the last time through the block".

[18:07] <masak> but it means an explicit &last call.

[18:07] <masak> meant*

[18:08] * TimToady apologizes for not closing all the sheepgates

[18:08] <masak> sheepish apologies for going for the gate :P

[18:09] * TimToady doesn't apologize for stealing the sheepgate idea from C.S. Lewis

[18:12] <flussence> # Looks like you failed 6 tests of 18

[18:12] <flussence> 2 more!

[18:13] <TimToady> 2 more failed?!?

[18:13] <flussence> well I could spin that and say those tests weren't there before... but it's 2 more passes too :)

[18:14] * diakopter feels spun

[18:20] <slavik> TimToady: sheepgate?

[18:21] <slavik> here's an interesting question: would consider a developer who specializes in language X to be an expert in the X virtual machine?

[18:26] *** kst` is now known as kst

[18:27] <shortcircuit> slavik: Not strictly speaking, no.

[18:27] <shortcircuit> slavik: I wouldn't assume a developer specializing in Java knows a great deal about the JVM, for example.

[18:27] <slavik> shortcircuit: yea, that's where I was going

[18:27] *** spq1 joined
[18:29] *** Kodi joined
[18:29] <[Coke]> I know a LOT of java developers. I would assume the opposite.

[18:29] <shortcircuit> I might have to accept a distinction about a developer's being an _expert_ in X and being an expert in the XVM, as well. You might be slick with C# but never used anything but Mono, for example.

[18:30] <Kodi> S03:1337 says infix:<^^> should return Bool::False when more than one argument is true. Fine by me, but it also says False should be returned when all arguments I false. I say that in that case the last (false) argument should be returned, as in the case of infix:<||>.

[18:31] <Kodi> (I apologize for taking issue with line 1337.)

[18:31] <diakopter> shortcircuit: yeah, but that's a difference between "the clr" and "the clr implementation"

[18:32] * shortcircuit admits unfamiliarity with the number and defnition of boundaries between .Net languages and the underlying hardware.

[18:39] *** plobsing joined
[18:43] <diakopter> there are hundreds of language implementations targetting .Net/clr, probably 50 or so "production"/"commercial"-level

[18:44] <diakopter> oh, number of boundaries. heh.

[18:44] <diakopter> sry

[18:45] <slavik> shortcircuit: I'd continue that conversation, but it's outside the scope of this channel :(

[18:46] <moritz_> there's always privmsg

[18:49] <flussence> .oO( wait a minute... why am I not using multi for .indent? )

[18:49] * flussence rewrites for 5-6th time

[18:50] <dalek> nqp-rx/nom: 26e717c | moritz++ | src/HLL/Compiler.pm:

[18:50] <dalek> nqp-rx/nom: port --ll-backtrace from parrot 5e3b4d2f

[18:50] <dalek> nqp-rx/nom: review: https://github.com/perl6/nqp-rx/commit/26e717cb72

[18:50] <TimToady> slavik: http://www.suddeninaminute.org/2010/09/turning-cs-lewis-statement-on-writing.html

[18:50] <slavik> ty

[18:51] *** Mowah joined
[18:51] *** MayDaniel left
[18:51] *** Axius joined
[18:51] <slavik> TimToady: that's interesting ...

[18:53] <masak> TimToady: "Pastor of Muppets" indeed :P

[18:54] <TimToady> well, perhaps http://thegospelcoalition.org/blogs/justintaylor/2010/09/10/c-s-lewiss-advice-on-writing-well/ is a better ref

[18:54] <TimToady> but certainly Lewis was against sloppy writing in general

[18:55] <masak> "The way for a person to develop a style is (a) to know exactly what he wants to say, and (b) to be sure he is saying exactly that." -- there's an autopun in there somewhere... :)

[18:55] <TimToady> I've taken this to heart in all my writing, and assume that if I do not communicate what I want to communicate, it's my fault as a writer, not the reader's fault.

[18:55] <masak> TimToady++

[18:56] <Su-Shee> I still like "elements of style" very much.

[18:56] <masak> Su-Shee: I know a bunch of people who don't. they're over on languagelog.

[18:57] <masak> Pullum chief among them.

[18:57] <masak> and he seems to have good reason, too.

[18:57] <Su-Shee> well I also like Rilke's letters to a young poet ;)

[18:57] <TimToady> I don't much care for it myself--I'm not quite so much of a {pre,pro}scriptivist.

[18:57] <TimToady> I'm a whatever-works writer.

[18:58] <masak> Su-Shee: http://chronicle.com/article/50-Years-of-Stupid-Grammar/25497

[18:58] <Su-Shee> I found it helpful as a non native writer. 

[18:58] <TimToady> it's certainly useful for codifying the standard practices

[18:59] <TimToady> I'm not much into other people's standards, is all...

[18:59] <masak> Su-Shee: I haven't read EoS, but I recently bought http://www.amazon.com/Sin-Syntax-Craft-Wickedly-Effective/dp/0767903099/ref=sr_1_1?ie=UTF8&qid=1295895534&sr=8-1 and found it very enjoyable. it's more descriptive than prescriptive.

[18:59] *** molaf_ left
[18:59] <TimToady> I'd rather (re)learn the first principles as real principles, not as standards. :)

[19:00] <Su-Shee> I've collected a metre of docs on the subject for german and english and applied what I found useful or what improved my style. :)

[19:00] *** Mowah left
[19:01] <Su-Shee> which was easier in german as I don't really have a "style" yet in english.. ;)

[19:01] <TimToady> me no style normal

[19:02] *** snearch left
[19:03] <Su-Shee> good thing there's a short reference then. :))

[19:06] <TimToady> Kodi: I guess I'm fine with ^^ behaving as you suggest, since it might let you pass info on why it failed.

[19:06] <TimToady> feel free to fix the spec there

[19:06] <Kodi> TimToady: That I will.

[19:06] <masak> Kodi++

[19:09] <flussence> anyone: which is best, "([min] @whitespaces).chars" or "[min] @whitespaces¬ª.chars"?

[19:10] <jnthn> They do different things, I think.

[19:10] <jnthn> I think the second does what you probably want.

[19:12] <flussence> the input's all varying length strings of ' ' chars, and they seem to work identically... I'll use the latter if it's more obvious-looking though.

[19:12] <masak> the latter, then.

[19:12] <dalek> specs: a6a03fb | (Kodi Arfer)++ | S03-operators.pod:

[19:12] <dalek> specs: [S03] When a chain of ^^s gets only false arguments, return the last one.

[19:12] <dalek> specs: review: https://github.com/perl6/specs/commit/a6a03fb89b

[19:12] <masak> the former would take the length of the lexically first string.

[19:13] <flussence> rakudo: ( [min] (' 'x2, ' 'x1, ' 'x4) ).perl

[19:13] <p6eval> rakudo 9fdad1: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "( [min] ('"‚ê§¬ª

[19:13] <flussence> huh.

[19:14] <moritz_> what is x2 supposed to be?

[19:14] <flussence> rakudo: ( [min] ('  ', ' ', '    ') ).perl

[19:14] <p6eval> rakudo 9fdad1:  ( no output )

[19:14] <flussence> a missing-whitespace typo :)

[19:14] <flussence> rakudo: ( [min] ('  ', ' ', '    ') ).perl.say

[19:14] <p6eval> rakudo 9fdad1: OUTPUT¬´" "‚ê§¬ª

[19:15] <moritz_> rakudo: say ([min] ' ', * ~' ' .. *.length == 5).perl

[19:15] <p6eval> rakudo 9fdad1: OUTPUT¬´" "‚ê§¬ª

[19:15] <moritz_> should be .chars really

[19:15] <moritz_> rakudo: say 'abc'.length

[19:15] <p6eval> rakudo 9fdad1: OUTPUT¬´Method 'length' not found for invocant of class 'Str'‚ê§  in main program body at line 22:/tmp/p5bKxw6hcu‚ê§¬ª

[19:15] *** _jaldhar left
[19:16] *** _jaldhar joined
[19:16] <moritz_> rakudo: say (*.length == 5).('foo')

[19:16] <p6eval> rakudo 9fdad1: OUTPUT¬´Method 'length' not found for invocant of class 'Str'‚ê§  in <anon> at line 22:/tmp/xNVmQZX3Z2‚ê§  in <anon> at line 22:/tmp/xNVmQZX3Z2‚ê§  in main program body at line 22:/tmp/xNVmQZX3Z2‚ê§¬ª

[19:19] <masak> didn't we have an awesome error message for that one?

[19:19] <flussence> One like "please use .chars, .bytes or .graphs"? Sounds familiar...

[19:20] *** plobsing left
[19:21] *** Kodi left
[19:21] *** fhelmberger left
[19:21] *** kst left
[19:22] <TimToady> or .elems

[19:22] *** kst joined
[19:22] <jnthn> We could add a .length method that DWIMs and just gives you some natural unit based on the type...oh, wait...

[19:22] <jnthn> :)

[19:23] <masak> jnthn: no scalar/list context in Perl 6...

[19:23] <jnthn> :)

[19:23] <flussence> $str.length(:in<12pt Helvetica>) ...

[19:23] <moritz_> :-)

[19:24] <masak> flussence: your brain is fascinating.

[19:24] <TimToady> that would be .width, I suspect

[19:25] <jnthn> .width is still kinda unitless though

[19:25] <jnthn> .pixels or .cms or .inches or something could work :)

[19:25] *** plobsing joined
[19:26] *** cjk101010 joined
[19:27] <flussence> when /^(\t \s*) (.*)/ { ... } # Looks like the remaining test-fails are for this part :(

[19:30] <TimToady> .pixels could be vertical

[19:30] <TimToady> you're gonna want .height too

[19:30] <TimToady> and maybe .depth

[19:31] *** Chillance joined
[19:33] <jnthn> Troo.

[19:35] <slavik> TimToady: is logical programming similar to prolog in scope for perl6?

[19:35] * moritz_ hopes all programming is logical

[19:36] <slavik> moritz_: if it was, I wouldn't have a job

[19:36] *** MayDaniel joined
[19:36] <masak> :D

[19:36] <TimToady> slavik: eventually, though perhaps not for 6.0.0

[19:37] <moritz_> declarative aspectes are handles by multi (and nested) sigs and regexes, for example

[19:37] <TimToady> basically we need a better story on unification to get there

[19:37] * diakopter blinks to attention

[19:37] <masak> slavik: I've been thinking of it in terms of a module that imposed unification on something like signatures, and did backtracking on statements.

[19:37] <slavik> TimToady: cool. would be nice to have a language with prolog type rules that didn't have like 5-10 implementations

[19:37] <TimToady> er...

[19:37] <diakopter> slavik: hahahaha

[19:38] <masak> the 'let' declarator has Prolog-like properties, IIUC.

[19:38] *** Axius left
[19:38] * diakopter throws some more irony slavik's direction

[19:39] <TimToady> slavik: the other answer is that all other languages are really just dialects of Perl 6

[19:39] * moritz_ stopped counting Perl 6 implementations

[19:39] *** icwiener_ left
[19:40] <TimToady> biab &

[19:40] <slavik> moritz_: except that perl6 has 1 spec

[19:42] <diakopter> yeah, but... that spec is not ... how do you say ... built up from first principles.  so implementations diverge from very different starting points & emphases.

[19:44] *** nperez left
[19:45] *** daxim left
[19:45] <moritz_> that's why we have a test suite, and regular discussions in here

[19:45] <moritz_> s/regular/continuous/

[19:46] <slavik> moritz_: right, because the spec is not final

[19:46] <moritz_> and sometimes ambiguous

[19:46] <slavik> but in the end, there will be 1 spec and 1 set of spec tests ... spec can change and there will be versions, but it's not like Perl5 where you simply do what the interpreter does

[19:49] *** skipper joined
[19:50] *** PerlJam left
[19:51] *** PerlJam joined
[19:59] *** plobsing left
[19:59] *** plobsing joined
[20:03] *** flatwhatson left
[20:16] *** flatwhatson joined
[20:23] *** dukeleto left
[20:24] *** dukeleto joined
[20:27] *** mtk left
[20:28] *** skipper left
[20:29] *** mtk joined
[20:32] *** coldhead joined
[20:33] *** kjeldahl left
[20:37] *** PZt joined
[20:41] *** kjeldahl joined
[20:50] *** plainhao left
[20:53] *** kst left
[20:53] *** kst joined
[20:53] *** plobsing left
[21:02] *** snarkyboojum left
[21:02] *** cjk101010 left
[21:05] *** MayDaniel left
[21:15] *** leprevost joined
[21:19] <masak> 'night, #perl6.

[21:19] <moritz_> o/ masak 

[21:20] <colomon> \o

[21:21] *** masak left
[21:21] <moritz_> the small one is coming home tomorrow

[21:21] <colomon> \o/

[21:21] <moritz_> indeed

[21:22] <tadzik> yay :)

[21:23] <[Coke]> YAY

[21:23] <moritz_> dang, if only I could remember what the second command line option was that I wanted to implement for rakudo

[21:24] *** kst left
[21:25] *** snarkyboojum joined
[21:25] *** kst joined
[21:29] <dalek> rakudo: 7239864 | moritz++ | docs/running.pod:

[21:29] <dalek> rakudo: document --ll-backtrace option

[21:29] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/72398646f8

[21:34] *** timbunce joined
[21:37] <pmichaud> in the S03 update that was just pushed to specs, it says: 

[21:37] <pmichaud> Returns C<Bool::False> 1339	

[21:37] <pmichaud> +otherwise (when more than one argument is true).  In list context 1340	

[21:37] <pmichaud> +forces a false return to mean C<()>.

[21:38] <pmichaud> ...shouldn't it just return Nil there instead of having the "In list context forces ... " ?

[21:38] <pmichaud> i.e., is list context a bit of a fossil?

[21:38] *** plobsing joined
[21:39] <moritz_> sounds like it

[21:39] <jnthn> There is no list context as such any more.

[21:40] <pmichaud> right

[21:40] <pmichaud> so I'm thinking that phrase is a fossil that needs fixing

[21:40] <jnthn> Feels like a 5o.

[21:40] <pmichaud> I'd suggest "Returns Nil if multiple arguments are true."

[21:40] <moritz_> +1

[21:41] <pmichaud> I'll make the change now... forgiveness > permission and all that

[21:41] <pmichaud> although we have similar things for && and ||, it seems.

[21:41] <pmichaud> I'm not so comfortable about changing those.

[21:42] <pmichaud> and //

[21:43] <pmichaud> anyway, I'd like to get rid of that "In list context forces ..." clause of the short-circuiting operators.

[21:43] *** molaf joined
[21:43] *** Kodi joined
[21:43] <pmichaud> TimToady: see ^^^^

[21:43] <pmichaud> afk again

[21:46] *** leprevost left
[21:50] *** pmurias joined
[21:56] <gfldex> std: use MONKEY_TYPING; class Foo { method bar(){ augment class Foo { method lol(){} }; Foo.new().bar();

[21:56] <p6eval> std 625303c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse block at /tmp/OfFSMwbTqK line 1:‚ê§------> [32m MONKEY_TYPING; class Foo { method bar()[33m‚èè[31m{ augment class Foo { method lol(){} }; [0m‚ê§Couldn't find final '}'; gave up at /tmp/OfFSMwbTqK line 1 (EOF):‚ê§------> [32mFoo {

[21:56] <p6eval> ..method l‚Ä¶

[22:10] *** molaf_ joined
[22:12] *** molaf left
[22:16] *** jevin_ left
[22:19] *** zevpl joined
[22:27] *** starcoder left
[22:32] *** starcoder joined
[22:36] *** MayDaniel joined
[22:39] *** hercynium left
[22:39] *** noganex_ joined
[22:43] *** kaare_ left
[22:43] *** noganex left
[22:52] *** timbunce left
[22:57] *** pmurias left
[23:04] *** pyrimidine left
[23:07] *** kst left
[23:07] *** whiteknight joined
[23:07] *** kst joined
[23:19] *** rgrau left
[23:22] *** fhelmberger joined
[23:22] *** fhelmberger left
[23:23] *** fhelmberger joined
[23:27] *** _jaldhar left
[23:28] *** dual joined
[23:28] *** leprevost joined
[23:30] *** MayDaniel left
[23:32] *** felliott left
[23:40] *** felliott joined
[23:44] *** felliott left
[23:46] <sorear> good * #perl6

[23:46] <phenny> sorear: 16:52Z <diakopter> ask sorear is dalek okay? I pushed something to github sprixel and haven't seen it yet

[23:46] <phenny> sorear: 16:52Z <diakopter> ask sorear nm now I see it

[23:52] *** spq1 left
[23:53] *** starcoder left
[23:55] * flussence suddenly realises q:to() depends on a working .indent(*)... argh

[23:58] *** starcoder joined
