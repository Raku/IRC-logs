[00:00] *** static_perl left
[00:04] *** uasi joined
[00:07] *** daniel-s joined
[00:14] *** flussence_ joined
[00:15] *** flussence left
[00:19] *** sayu joined
[00:26] *** whiteknight left
[00:28] <dalek> sprixel: f4e52be | diakopter++ | src/ (3 files):

[00:28] <dalek> sprixel: 300% speedup of loops by caching a pool of instruction and state objects; zero allocations on incrementing loops now

[00:28] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/f4e52be15b

[00:29] *** kensanata left
[00:32] *** Limbic_Region left
[00:32] *** tokuhiro_ left
[00:38] <diakopter> sorear++ # pointing out that incrementing while loops shouldn't use allocations

[00:52] *** ZapZ left
[00:58] *** uasi left
[01:05] *** replore_ joined
[01:31] *** sftp left
[01:33] *** sftp joined
[01:38] *** hypolin joined
[01:46] *** thou left
[02:07] *** sayu left
[02:07] *** thou joined
[02:09] <dalek> niecza: 1a92563 | (Solomon Foster)++ | lib/ (2 files):

[02:09] <dalek> niecza: Implement naive version of unlink.

[02:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1a92563b93

[02:11] <colomon> sorear: seems like proper error handling for unlink is going to require catching C# exceptions.  Not sure if it's worth trying to do that yet, or how to go about it...

[02:12] <diakopter> colomon: did you make unlink marked as unsafe?

[02:12] <colomon> diakopter: yup.

[02:12] <sorear> niecza automatically catches C# exceptions and turns them into Perl6 exceptions

[02:12] <diakopter> oh goody :)

[02:13] <colomon> (as you could easily tell by clicking on the github link.  ;)

[02:13] <colomon> sorear: in some cases here they should probably turn into return values of False.

[02:13] <colomon> hard to say, since unlink is not spec'd at all as far as I can tell.  :(

[02:13] <dalek> sprixel: c4fed67 | diakopter++ | src/ (4 files):

[02:13] <dalek> sprixel: add lexical block descend and noop opcodes

[02:13] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/c4fed67281

[02:14] *** donri left
[02:27] * [Coke] adds 48 more files to t/spectest.data

[02:27] <[Coke]> (for niecza)

[02:28] * [Coke] kicks off a spectest run to make sure.

[02:31] <sorear> colomon: catching exceptions in C# is exactlythe same as in Java

[02:32] <[Coke]> colomon: niecza could run a lot of S32-num/atan2.t, if only I could figure out how to fudge it.

[02:43] *** am0c joined
[02:45] *** wolfman2000 joined
[02:49] <[Coke]> Files=324, Tests=9343, 899 wallclock secs ( 3.21 usr  1.92 sys + 1454.20 cusr 61.61 csys = 1520.94 CPU)

[02:49] <[Coke]> (it's really on 323 files, I had to back one out.)

[02:49] <[Coke]> *only

[02:50] <dalek> roast: 000e1e4 | Coke++ | S06-advanced/callframe.t:

[02:50] <dalek> roast: remove vim directive

[02:50] <dalek> roast: review: https://github.com/perl6/roast/commit/000e1e4964

[02:50] <dalek> roast: 3a7da94 | Coke++ | / (29 files):

[02:50] <dalek> roast: niecza fudging

[02:50] <dalek> roast: review: https://github.com/perl6/roast/commit/3a7da94883

[02:50] <dalek> niecza: c042c3c | Coke++ | t/spectest.data:

[02:50] <dalek> niecza: run fudged tests.

[02:50] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c042c3c9be

[03:00] *** Woodi left
[03:00] *** Woodi joined
[03:11] <[Coke]> Files=323, Tests=9343, 1053 wallclock secs ( 3.21 usr  1.92 sys + 1469.49 cusr 65.24 csys = 1539.86 CPU)

[03:11] <[Coke]> (there's a real run.)

[03:29] *** daniel-s left
[03:32] *** daniel-s joined
[03:40] <[Coke]> https://gist.github.com/1291893 - niecza test summary output.

[03:55] *** satyavvd joined
[03:56] *** envi_ joined
[04:01] <sorear> [Coke]: thanks

[04:02] <[Coke]> sorear: no problem.

[04:04] *** uasi joined
[04:07] *** envi_ left
[04:25] *** uasi left
[04:33] * sorear is struggling to work out the details of recursive serialized unit loading

[04:37] *** uasi joined
[05:05] <dalek> rakudo/nom: f25b3b9 | moritz++ | src/core/ (2 files):

[05:05] <dalek> rakudo/nom: use native ints in the setting

[05:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f25b3b93ff

[05:06] *** daniel-s left
[05:08] *** risou_awy is now known as risou

[05:12] *** orafu left
[05:12] *** orafu joined
[05:18] *** lestrrat left
[05:19] *** lestrrat joined
[05:20] *** soh_cah_toa left
[05:41] <moritz> std: /<[-]>/

[05:41] <phenny> moritz: 16 Oct 23:00Z <[Coke]> tell moritz that A61354_1 in S12-class/basic.t smells like the eval/try issue.

[05:41] <p6eval> std 580b69a: OUTPUT«ok 00:01 121m␤»

[05:42] *** wolfman2000 left
[05:44] <moritz> [Coke]: it does indeed

[05:44] <moritz> good morning

[05:46] <[Coke]> moritz: I still haven't gone to bed yet. Uhoh.

[05:48] <moritz> nom: say ('a'^.. 'f')

[05:48] <p6eval> nom 6f8660: OUTPUT«"a"^.."f"␤»

[05:48] <moritz> nom: say ('a'^.. 'f').list

[05:48] <p6eval> nom 6f8660: OUTPUT«b c d e f␤»

[05:51] *** dual joined
[05:51] *** uasi left
[05:54] <dalek> roast: 12561b6 | moritz++ | S12-class/basic.t:

[05:54] <dalek> roast: update test to deal with eval changes, [Coke]++

[05:54] <dalek> roast: review: https://github.com/perl6/roast/commit/12561b6ef0

[05:54] *** kaleem joined
[05:55] *** uasi joined
[06:05] *** wtw joined
[06:05] *** wtw left
[06:05] *** wtw joined
[06:05] *** kaare_ joined
[06:15] *** static_perl joined
[06:16] *** xinming joined
[06:16] *** thou left
[06:17] *** uasi left
[06:21] *** uasi joined
[06:24] <dalek> niecza/serialize: eee0cbb | sorear++ | / (8 files):

[06:24] <dalek> niecza/serialize: Add framework for detecting stale precompiled modules

[06:24] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/eee0cbbe4a

[06:31] *** koban joined
[06:31] *** koban left
[06:32] *** mkramer left
[06:32] *** mkramer joined
[06:35] *** daniel-s joined
[06:36] <Woodi> can I get mildew source from somewhere ?

[06:39] <moritz> I'm pretty sure you can

[06:40] <moritz> iirc it's in the perl6/mu repo on github

[06:40] <dalek> roast: 979e069 | moritz++ | S05-mass/rx.t:

[06:40] <dalek> roast: update hyphen-in-char-class test to match current spec

[06:40] <dalek> roast: review: https://github.com/perl6/roast/commit/979e069c9a

[06:41] <sorear> good luck getting it to run though

[06:41] <sorear> it seems to be incompatible with recent versions of gcc

[06:41] <Woodi> thanx for location

[06:42] <Woodi> just want to try to understand few things in C way.

[06:43] <sorear> last time I tried it, it OOMed while trying to build the setting

[06:43] <Woodi> it still require pugs/Haskell ?

[06:44] <sorear> no, mildew is C/Perl5

[06:50] *** uasi left
[06:54] *** agentzh joined
[06:55] <dalek> niecza/serialize: 288db48 | sorear++ | lib/ (3 files):

[06:55] <dalek> niecza/serialize: Use precompiled IL when using a precompiled module

[06:55] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/288db483af

[07:01] <dalek> niecza/serialize: cbf3a16 | sorear++ | lib/Kernel.cs:

[07:01] <dalek> niecza/serialize: Add an entry point to generated assemblies so mono obj/MAIN.exe works again

[07:01] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/cbf3a161cd

[07:02] <sorear> stefan@stefans:~/rel/niecza$ mono-sgen obj/CORE.exe

[07:02] <sorear> Hello, world (0)

[07:02] * sorear -> sleep

[07:02] <sorear> tomorrow:

[07:02] <sorear> * get the full setting to freeze/thaw correctly

[07:02] *** am0c left
[07:02] <sorear> * try and implement compiling-code-against-the-setting

[07:02] <sorear> * try and implement "use"

[07:03] <sorear> rest of the week:

[07:03] <sorear> * chase regressions

[07:03] *** baest_ joined
[07:05] *** baest left
[07:10] *** mj41 joined
[07:10] *** uasi joined
[07:14] *** wamba joined
[07:19] *** satyavvd left
[07:30] <snarkyboojum> colomon: I implemented unlink and mkdir too (on the weekend), but didn't commit them ;)

[07:30] *** baest_ is now known as baest

[07:31] <snarkyboojum> colomon: do you need to return True on line 2108? Seems redundant to me (referring to https://github.com/sorear/niecza/commit/1a92563b93)

[07:31] *** uasi left
[07:38] <dalek> roast: c7d1f65 | moritz++ | S06-other/main-usage.t:

[07:38] <dalek> roast: unfudge a passing MAIN test

[07:38] <dalek> roast: review: https://github.com/perl6/roast/commit/c7d1f6552c

[07:55] *** arthur-_ left
[08:05] *** arthur joined
[08:11] *** wk_ left
[08:26] *** cognominal joined
[08:28] *** dakkar joined
[08:31] *** [Coke] left
[08:35] *** arthur left
[08:47] <masak> morning, #perl6

[08:47] <moritz> \o masak 

[08:48] <tadzik> 'morning

[08:53] <dalek> rakudo/nom: c28552e | (Geoffrey Broadwell)++ | src/core/Main.pm:

[08:53] <dalek> rakudo/nom: DWIM better in orig-string role in MAIN_HELPER()

[08:53] <dalek> rakudo/nom: 

[08:53] <dalek> rakudo/nom: In the first snapshot orig-string was too aggressive, and in the

[08:53] <dalek> rakudo/nom: second snapshot it was too conservative.  This middle ground seems

[08:53] <dalek> rakudo/nom: to DWIM better than either extreme did.

[08:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c28552ef7d

[08:54] <dalek> rakudo/nom: 548e56a | moritz++ | src/core/Range.pm:

[08:54] <dalek> rakudo/nom: BUILD should be a submethod

[08:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/548e56a95b

[08:54] <dalek> rakudo/nom: ded7222 | moritz++ | tools/build/NQP_REVISION:

[08:54] <dalek> rakudo/nom: bump NQP revision

[08:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ded7222ce2

[09:02] *** wk joined
[09:02] *** xinming left
[09:03] *** jrockway left
[09:03] *** xinming joined
[09:03] *** jrockway joined
[09:13] *** am0c joined
[09:20] *** arthur joined
[09:25] *** am0c left
[09:26] *** am0c joined
[09:27] *** xinming left
[09:27] *** xinming joined
[09:30] <masak> t/spec/S05-mass/rx.rakudo parsefails on nom's 'make spectest'.

[09:31] <masak> Unsupported use of - as character range;in Perl 6 please use .. at line 338, near "]>/, 'unes"

[09:32] <moritz> masak: the NQP revision bump from ded7222 should fix that

[09:32] <moritz> masak: or are you already on that version?

[09:34] <masak> no, seems not. moritz++

[09:39] <moritz> $ ./perl6 -e 'class A { has $.x = "foo" }; say A.new.perl'

[09:39] <moritz> A(x => "foo")

[09:40] <moritz> oops. Should be .new

[09:40] *** am0c left
[09:40] <moritz> that's the beauty of pasting to the channel, I actually read the stuff more carefully :-)

[09:41] *** daxim joined
[09:41] <moritz> my current .perl approach doesn't try to perfectly recreate the objects, but rather just goes through all attributes with accessors, and constructs a .new call from it

[09:41] <moritz> if people would prefer that, I could also emit something like

[09:42] *** jonasbn joined
[09:42] <moritz> do { my $new := nqp::create(A); nqp::bindattr($new, A, '$!x', "foo") }

[09:42] *** jonasbn left
[09:42] <moritz> ... and return $new from that

[09:43] <moritz> that would reproduce private attributes

[09:43] <moritz> but wouldn't look so nice

[09:44] <masak> I don't think we want to reproduce private attributes anyway...

[09:45] <moritz> and the second point is that the current approach respects the classes' privacy

[09:46] <moritz> this implementation also calls the accessor instead of using nqp::getattr()

[09:47] <moritz> (by design choice, not because it's easier to implement :-)

[09:48] <moritz> nom: say 2e0.perl

[09:48] <p6eval> nom f25b3b: OUTPUT«2␤»

[09:48] <moritz> nom: say (1/2).perl

[09:48] <p6eval> nom f25b3b: OUTPUT«1/2␤»

[09:50] <moritz> nom: say 1.e

[09:50] <p6eval> nom f25b3b: OUTPUT«Method 'e' not found for invocant of class 'Int'␤  in block <anon> at /tmp/1euhPcc2ev:1␤  in <anon> at /tmp/1euhPcc2ev:1␤»

[09:51] <moritz> ... and my patch breaks Int.perl, because that currently just falls back to Mu.perl, which falls back to Mu.Str

[09:52] *** uniejo left
[09:55] <moritz> nom: say "\x25b6"

[09:55] <p6eval> nom f25b3b: OUTPUT«▶␤»

[09:55] <moritz> .u 25b6

[09:55] <phenny> U+25B6 BLACK RIGHT-POINTING TRIANGLE (▶)

[10:09] *** hypolin left
[10:11] <moritz> nom: say (1..5).roll

[10:11] <p6eval> nom ded722: OUTPUT«1␤»

[10:11] <moritz> nom: say (1..5).roll(*)

[10:12] <p6eval> nom ded722: OUTPUT«(timeout)»

[10:12] * moritz kinda hoped it would produce some values before timeouting

[10:13] <masak> is that how &say works?

[10:13] <masak> oh, I guess with a lazy list, it is.

[10:13] <moritz> well, the old say would work that way

[10:13] <moritz> nom: print (1..5).roll(*)

[10:13] * masak .oO( as the old say goes... )

[10:13] <p6eval> nom ded722: OUTPUT«(timeout)4112224123521123143544355154344345245421524425132342445325125413421532313535324422222533223144553152345251545531223122343251313135114355545354341444515521124242513514215442334512232253253115351244435554113334235552555223152125415144114442425552133315233324443…

[10:14] <moritz> but the new one .gist's, and that hangs

[10:14] <masak> wait... so you're saying... that 'print' works... but 'say' doesn't... :/

[10:15] * masak feigns great confusion for the sake of demonstration

[10:15] <masak> so confusing!

[10:15] <moritz> it could be made to work, probably

[10:16] <moritz> what's the phenny syntax for translating from en to de?

[10:16] <masak> phenny: en do "donut"?

[10:16] <phenny> masak: The en to do translation failed, sorry!

[10:16] <masak> phenny: en de "donut"?

[10:16] <phenny> masak: "Krapfen" (en to de, translate.google.com)

[10:16] <moritz> phenny: en de "one one one"?

[10:16] <phenny> moritz: "ostzonensuppenwürfel ostzonensuppenwürfel ostzonensuppenwürfel" (en to de, translate.google.com)

[10:16] <masak> haha, "Krapfen"! :)

[10:17] <moritz> we use "donut" (and sometimes even "doughnut") for the round ones with a hole though

[10:17] <masak> I know what a würfel is, but what is a würfel?

[10:17] <masak> er, what is a ostzonensuppenwürfel?

[10:17] <moritz> phenny: en de "one one"?

[10:17] <phenny> moritz: "One One" (en to de, translate.google.com)

[10:17] <masak> phenny: de en "ostzonensuppenwürfel"?

[10:17] <phenny> masak: "All Clips" (de to en, translate.google.com)

[10:18] <masak> ok, this is more confusing than print/say ;)

[10:18] <moritz> ostzone = estern germany

[10:18] <masak> right.

[10:18] <moritz> and suppenwuerfel = a cube (wuerfel) of spice you put into a soup (suppe)

[10:18] <masak> oH!

[10:18] *** envi_ joined
[10:18] <masak> like a buillon cube?

[10:19] <moritz> that's the proper word, yes

[10:19] <masak> er, bouillon*

[10:19] <moritz> not sure how that relates to "one one one" though

[10:20] <masak> well, maybe it's the recipe for the world famous Dreiostzonensuppenwürfelsuppe :)

[10:28] <masak> phenny: en de "two two two"?

[10:28] <phenny> masak: "zwei zwei zwei" (en to de, translate.google.com)

[10:29] <moritz> seems to be an easter egg; most google hits for "ostzonensuppenwürfel" seem to be about the google translate thing :-)

[10:30] *** [Coke] joined
[10:30] <masak> how did you learn about it?

[10:32] <masak> seems to be related to a band somehow: http://de.wikipedia.org/wiki/Ostzonensuppenw%C3%BCrfelmachenkrebs

[10:33] <static_perl> are you guys hungry or something

[10:34] <tadzik> yep, and just making me a breakfast

[10:34] <masak> static_perl: :D

[10:34] <static_perl> conversation ends up with wuerfen machen :p

[10:35] <masak> phenny: en de "fudge"?

[10:35] <phenny> masak: "Fondant" (en to de, translate.google.com)

[10:35] <masak> phenny: en fr "fudge"?

[10:35] <phenny> masak: "truquer" (en to fr, translate.google.com)

[10:36] <static_perl> phenny: en it "masak"?

[10:36] <phenny> static_perl: "masak" (en to it, translate.google.com)

[10:38] <masak> phenny: ms en "masak"?

[10:38] <phenny> masak: "cooked" (ms to en, translate.google.com)

[10:38] <static_perl> haha

[10:39] <masak> speaking of food...

[10:39] <static_perl> exactly

[10:39] <masak> phenny: et en "mee saak"?

[10:39] <phenny> masak: "honey harvest" (et to en, translate.google.com)

[10:39] <tadzik> what's 'ms'?

[10:39] <masak> Malay.

[10:40] <tadzik> you hope they're not into cannibalism, Mr Carl Cooked ;)

[10:41] <static_perl> well being a chef is not a bad profession too i think

[10:42] *** arthur left
[10:43] <static_perl> they must have some sort of regular expression on spices

[10:43] <masak> tadzik: if I hadn't just been on the verge of making fun of East German cuisine, I would berate you for intolerance ;)

[10:47] <tadzik> ;)

[10:48] <static_perl> can't wait for recipe being patented

[10:53] <colomon> snarkyboojum: the spectests say unlink returns True if it works.

[11:02] *** arthur-_ joined
[11:04] *** replore_ left
[11:24] <colomon> is it TEST_JOBS=4

[11:24] <colomon> ?

[11:25] <colomon> yes, yes it is.

[11:26] *** arthur-_ left
[11:27] <dalek> niecza: 8d23b25 | (Solomon Foster)++ | lib/CORE.setting:

[11:27] <dalek> niecza: Simple sub close.

[11:27] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8d23b25e24

[11:39] *** arthur-_ joined
[11:39] *** Patterner left
[11:42] *** Psyche^ joined
[11:42] *** Psyche^ is now known as Patterner

[12:08] <moritz> http://jimmycuadra.com/posts/ecmascript-5-array-methods "every" instead of all(), "some" instead of any()

[12:11] *** itz joined
[12:19] <moritz> filter vs. grep

[12:21] *** Alias joined
[12:28] <masak> lots of languages seem to choose 'filter'.

[12:30] <moritz> didn't 'grep' mean 'get regular expression' or some such?

[12:31] <moritz> thinking more about it, it would make sense to switch .comb and .grep

[12:32] <masak> moritz: Wikipedia says g/re/p (global / regular expression / print)

[12:33] <moritz> still specific to regexes

[12:33] *** zag joined
[12:34] <moritz> whereas you don't need regexes to comb for certain values

[12:36] * masak dives into macros some more

[12:36] <frettled> masak++ nice blog post about AST and macros, BTW :)

[12:36] * frettled got delayed in reading that one.

[12:37] <masak> more to come ;)

[12:37] <frettled> goodie

[12:37] <masak> frettled: a foretaste: what will this do? 'quasi { class C {} }'

[12:38] <moritz> conflict on the second application?

[12:38] <masak> correct.

[12:39] <masak> but that's not the interesting bit. there's a bunch of "events" that trigger as we parse a class declaration. these can't go to the ordinary, global World, since we don't want to register C at parse-time.

[12:39] <masak> they have to go to a sandboxed world particular to that quasi, and be stored up awaiting actual macro application.

[12:40] <moritz> $ ./perl6 -e 'quasi {class C {} }; say C'

[12:40] <moritz> C()

[12:40] * moritz submits masakbug

[12:40] <frettled> heh

[12:40] <masak> yes, I know I so deserve each one of those ;)

[12:41] <moritz> masak: I guess you'll have to add a new $*ST when starting to parse the quasi

[12:41] <masak> correct.

[12:41] <masak> good thing it's a contextual! :D

[12:41] <moritz> the question is if that's enough

[12:42] <moritz> probably not

[12:42] <masak> well, it's definitely trickier than just that.

[12:42] <frettled> masak: but in answer to your question: "confuse me" ;)

[12:42] <masak> you got it.

[12:44] <masak> whoa, src/Perl6/SymbolTable.pm is 1.7 kLOC...

[12:44] * masak attempts to take it all in in one sitting

[12:45] <moritz> std: quasi :COMPILING { }

[12:45] <p6eval> std 580b69a: OUTPUT«ok 00:01 124m␤»

[12:47] * moritz looks at S06-macros/opaque-ast.t

[12:47] <moritz> can you actually use $COMPILING::x inside a macro but outside a quasi?

[12:47] <moritz> hm, should be OK

[12:48] * moritz thinks that the macro branch can pass at least the first test in that file :-)

[12:50] <masak> Block.body ?

[12:50] <masak> seems it expects it to return an AST...

[12:50] <moritz> aye

[12:52] <masak> moritz: COMPILING is defined as "Lexical symbols in the scope being compiled", so outside of a quasi should be fine.

[12:52] <moritz> masak: afaict macros should be routines, they aren't in your branch

[12:52] <moritz> try  macro a { return quasi {} }

[12:52] <masak> not sure I had seen that particular use case before.

[12:53] <masak> (with COMPILING in the macro)

[12:53] <masak> moritz: Attempt to return outside of any Routine

[12:53] <masak> moritz: that needs fixing. thanks.

[12:53] * masak puts it on his TODO list

[12:54] <dalek> roast: 8cfef27 | moritz++ | S06-macros/opaque-ast.t:

[12:54] <dalek> roast: heavily fudge opaque-ast.t

[12:54] <dalek> roast: review: https://github.com/perl6/roast/commit/8cfef27f00

[12:55] <moritz> masak: your branch passes two subtests in that file. Congratulations!

[12:55] <masak> by the way, those tests in that file all appear fine, but I expect I will have lots more as I get going with tests.

[12:55] <masak> which should be soon.

[12:56] <moritz> those tests have all the usual characteristics of 1) being written before they were implemented and 2) being written by just reading the specs, and trying to deal with the most obvious issues

[12:57] * masak lols at the method name .steal_WHO

[12:59] <masak> moritz: exactly. I consider what I'm doing right now a very realistic prototyping of things. after which I'll be in a good position to write some sufficiently probing tests. will probably tear things down and build them up again based on the tests, but might take shortcuts here and there.

[12:59] <benabik> steal_WHO?

[13:01] <masak> benabik: covers the case when 'class A::B {}' was parsed before 'class A {}', so A already has a .WHO

[13:02] <benabik> masak: Ah.  Clever.

[13:02] <masak> mostly I just like colorful verbs in code ;)

[13:02] *** mtk left
[13:09] * masak wonders if .curry_role shouldn't be .prime_role

[13:10] <eiro> 

[13:11] <dalek> rakudo/nom: 16a3b95 | moritz++ | src/core/terms.pm:

[13:11] <dalek> rakudo/nom: prevent startup error if %*ENV<HOME> is empty

[13:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16a3b95fce

[13:11] <dalek> rakudo/nom: 4e43906 | moritz++ | src/core/ (3 files):

[13:11] <dalek> rakudo/nom: much improved Mu:D.perl

[13:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e439068d4

[13:11] *** GlitchMr joined
[13:12] <masak> ok, I see now why SymbolTable.pm is as big as it is. it handles *all* the declaration-y bits in Rakudo.

[13:13] <masak> and it's written entirely by two very prolific guys:

[13:13] <masak> someone called Jonathan Worthington, and someone called jnthn.

[13:13] <masak> ;)

[13:13] <dalek> roast: 44e9737 | moritz++ | S02-types/num.t:

[13:13] <dalek> roast: unfudge Num.perl tests that now pass

[13:13] <dalek> roast: review: https://github.com/perl6/roast/commit/44e973763f

[13:13] <masak> (with a patch in the middle by tadzik)

[13:13] <tadzik> this "Jonathan Worthington" is the one stealing all the karma from jnthn

[13:14] *** mtk joined
[13:14] <moritz> masak: I've also touched that files once or twice

[13:15] <masak> ok.

[13:15] <masak> my branch has a slightly old base...

[13:16] <masak> looking now at HLL::Compiler::SerializationContextBuilder

[13:16] *** tokuhiro_ joined
[13:16] *** wk left
[13:17] *** pmurias joined
[13:21] <moritz> I wonder if sub addr should be replaced by nqp::where in there

[13:21] *** lateau__ joined
[13:21] <masak> aha! so "fixing up" is for when we go straight for runtime after compiling, and "deserializing" is when we've persisted stuff and taken a break between compiling and running.

[13:22] *** zag left
[13:24] <masak> actually, something called "installation" seems to figure in the latter case, too.

[13:24] <moritz> and it might be that you only need to delay/intercept the installation

[13:25] *** jerome_ left
[13:25] <masak> errands &

[13:30] <colomon> t/spec/integration/advent2009-day23.t hanging on niecza?

[13:32] *** localhost left
[13:32] <moritz> colomon: the last test says   ok 4 # SKIP hangs

[13:33] *** benabik left
[13:33] <moritz> colomon: so either your copy of roast is out of date, or you're invoking the test in a way that doesn't involve fudge, but should

[13:33] *** localhost joined
[13:33] *** benabik joined
[13:33] <colomon> t/fudgeandrun t/spec/integration/advent2009-day23.t  is what I just did

[13:33] <colomon> and it sure looks like it's hung again on test 4

[13:34] <moritz> colomon: so what's your git sha1 of the t/spec/ repo?

[13:34] <moritz> [Coke]++ fudged that file yesterday

[13:35] *** benabik left
[13:38] <[Coke]> colomon;if there's an updated version of t/spectest.data, you must update roast also.

[13:38] <tadzik> (%ENV<HOME> // %ENV<HOMEDRIVE> ~ %ENV<HOMEPATH>)

[13:38] <colomon> Pretty sure I tried pulling t/spec this morning

[13:38] <tadzik> that should be File::HomeDir or so

[13:39] <colomon> oh, I see what happened

[13:39] <[Coke]> colomon;I usually start out in niecza with "make spectest" to rebuild anything in niecza that needs it.

[13:39] <[Coke]> colomon: wozzat?

[13:39] <bbkr_> What is infix:<but> for? I cannot find any sample usage for it.

[13:40] <colomon> that only works if your t/spec isn't changed locally

[13:40] <colomon> works fine now

[13:41] <tadzik> bbkr_: 0 but True for example

[13:41] <tadzik> it's like does, but for objects, or something like this

[13:41] <tadzik> or not

[13:42] <tadzik> The property can then be mixed in or, alternatively, applied using the but operator. but is like does, but creates a copy and mixes into that instead, leaving the original unmodified

[13:43] <tadzik> bbkr_: http://perlcabal.org/syn/S14.html search for "The property can"

[13:43] *** PacoLinux joined
[13:45] <bbkr_> tadzik: thanks, nicely explained in S14 (i was looking for it in S03)

[13:49] *** arthur-_ left
[13:50] *** thou joined
[13:52] *** GlitchMr left
[13:52] <colomon> niecza's still failing t/spec/S06-signature/passing-arrays.t after the update

[13:53] * [Coke] checks.

[13:53] *** GlitchMr joined
[13:55] <dalek> niecza: 2f61b1e | (Solomon Foster)++ | t/spectest.data:

[13:55] <dalek> niecza: Turn on unlink.t.

[13:55] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2f61b1e5ef

[13:55] <[Coke]> colomon: I just did a git rb/make spectest (to get a rebuild), then a git rb (pull --rebase, sorry), in t/spec ... and the tests passes except for a TODO.

[13:56] <[Coke]> so prove is happy with it.

[13:56] <[Coke]> this is on OS X 10.6.8

[13:56] <colomon> you sure?  I get two fails in a row, one of which is fudged and one isn't.

[13:56] <[Coke]> Mono JIT compiler version 2.6.7

[13:57] <colomon> [Coke]: test is "an Int is not a Hash"

[13:59] <[Coke]> ok 7 - an Int is not a Hash

[14:00] <colomon> weird

[14:01] <colomon> wonder if a full rebuild of niecza will help.

[14:01] <[Coke]> Maybe "make spectest" isn't reubilding things for me? Iunno.

[14:01] <[Coke]> It looked like it

[14:02] <[Coke]> reboot, brb.

[14:07] *** tokuhiro_ left
[14:09] <[Coke]> back.

[14:09] <[Coke]> any lucK?

[14:10] *** GlitchMr left
[14:21] *** agentzh left
[14:24] *** molaf joined
[14:25] *** alastyr left
[14:27] <ingy> TimToady: I am getting failures sending email from ingy.net to wall.org. (ingy.net is hosted by gmail...)

[14:27] <colomon> [Coke]: got myself distracted paying bills.  testing now

[14:27] <colomon> [Coke]: nope, still fails

[14:28] <colomon> [Coke]: seems a very odd error to be platform-dependent...

[14:29] <[Coke]> my roast is at:

[14:29] <[Coke]> 44e9737

[14:29] <[Coke]> and niecza: 8d23b25

[14:33] <colomon> my niecza is 2f61b1e, but the only difference is turning unlink.t on

[14:33] <colomon> and my roast is 44e9737

[14:34] *** wtw left
[14:39] *** eiro left
[14:40] <dalek> specs: 05414aa | moritz++ | S24-testing.pod:

[14:40] <dalek> specs: [S24] expand on &todo, &skip

[14:40] <dalek> specs: review: https://github.com/perl6/specs/commit/05414aa85a

[14:53] <colomon> [Coke]: my mono is Mono JIT compiler version 2.10.2

[14:54] *** arthur-_ joined
[14:54] <moritz> colomon: fwiw that test also fails here

[14:54] <moritz> not ok 7 - an Int is not a Hash

[14:54] <moritz> # /home/moritz/p6/niecza/t/spec/S06-signature/passing-arrays.niecza line 37

[14:54] <colomon> \o/    # it's not just me

[14:54] <moritz> (and the one before also fails, but that is TODO'ed

[14:55] <[Coke]> colomon: I can do a mono upgrade, but ISTR there was an upper limit on supported monos when I tried this last time.

[14:55] <[Coke]> moritz: what version of mono?

[14:55] <moritz> [Coke]: 2.10.1

[14:55] <moritz> niecza: sub f(%h) { }; f(1); say 'alive'

[14:55] <[Coke]> hokay. I'll see what macports gives me. hang on.

[14:56] <p6eval> niecza v10-54-g2f61b1e: OUTPUT«Potential difficulties:␤  %h is declared but not used at /tmp/9QJTwkEIL6 line 1:␤------> sub f(⏏%h) { }; f(1); say 'alive'␤␤alive␤»

[14:56] <moritz> p6eval suffers from the same error

[14:56] *** imarcusthis left
[14:56] <[Coke]> 2.10.6 is macport latest. give me a few hours to up, rebuild, spectest, in between $DAYJOB

[14:57] <moritz> niecza: role A { }; sub f(A $) { }; f(3); say 'alive'

[14:57] <p6eval> niecza v10-54-g2f61b1e: OUTPUT«␤Unhandled Exception: Nominal type check failed in binding A $ in MAIN f; got Int, needed A␤  at /tmp/WZI_X0YTHX line 0 (MAIN f @ 0) ␤  at /tmp/WZI_X0YTHX line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2176 (CORE C1040_ANON @ 2)…

[14:57] <[Coke]> colomon: did you see my note about fudging atan2.t?

[14:58] <colomon> [Coke]: no

[14:58] <[Coke]> phenny, you suck.

[14:58] <colomon> niecza: say atan2(2, 3)

[14:58] <p6eval> niecza v10-54-g2f61b1e: OUTPUT«0.588002603547568␤»

[14:58] <colomon> [Coke]: might have been me being oblivious rather than phenny.  :)

[14:59] <[Coke]> colomon: that file is generated, so fudging it was non-obvious. If you can figure it out, niecza is passing a lot of those tests.

[14:59] *** bluescreen10 joined
[14:59] <colomon> [Coke]: ah, sure, I'll stick it on my to-do list

[14:59] <[Coke]> colomon: danke.

[14:59] <[Coke]> meetings. see you in a day. :P

[14:59] <colomon> ugh.  I hate meetings.

[15:00] <dalek> nqp: f748de0 | moritz++ | src/HLL/SerializationContextBuilder.pm:

[15:00] <dalek> nqp: use nqp::where in SerializationContextBuilder

[15:00] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f748de0874

[15:00] *** imarcusthis joined
[15:05] *** pmurias left
[15:05] *** jerome_ joined
[15:06] *** araujo left
[15:09] *** kaleem left
[15:11] *** GlitchMr joined
[15:11] *** araujo joined
[15:15] *** amkrankruleuen joined
[15:27] *** bluescreen10 left
[15:28] *** bluescreen10 joined
[15:32] <[Coke]> mono is not light on the deps.

[15:33] <[Coke]> bah. cannot complete upgrade, libgdiplus failed.

[15:33] <flussence_> distro?

[15:34] *** flussence_ is now known as flussence

[15:34] <flussence> (gentoo claims libgdiplus is optional, at least)

[15:35] *** bluescreen10 left
[15:36] *** bluescreen10 joined
[15:43] *** bluescreen10 left
[15:44] *** bluescreen10 joined
[15:45] *** MayDaniel joined
[15:47] *** Holy_Cow joined
[15:47] *** bluescreen10 left
[15:48] *** bluescreen10 joined
[15:49] *** bluescreen10 left
[15:49] *** bluescreen10 joined
[15:50] <[Coke]> is there something I can do locally to make it MOAR OPTIMIZED?

[15:51] <[Coke]> er, *rakudo, not it.

[15:51] <[Coke]> (say I'm willing to live on the edge with optimize=3)

[15:51] <moritz> --optimize=3

[15:51] <moritz> alias perl6='perl6 --optimize'

[15:51] <[Coke]> so it's a runtime thing. thank you.

[15:52] <[Coke]> Is there a way yet to change the default optimize at config time?

[15:52] <moritz> no

[15:52] <moritz> but something like an env var shouldn't be too hard to implement

[15:52] <flussence> isn't the default supposed to be 2? or does that just mean "default when the flag is passed"?

[15:53] <moritz> the code for the decision is in src/Perl6/Compiler.nqp lines 21-25

[15:53] <[Coke]> masak++ blog post on macros.

[15:55] <[Coke]> also, jnthn++ # blog post on optimizaiton

[15:55] <flussence> oh, seems like it is 2 unless it's explicitly disabled

[15:56] *** donri joined
[16:01] <[Coke]> ugh; undeclared dependency in macports for a package mono declares on. (google "macport <lib> failure" if it happens to you.)

[16:04] *** MayDaniel left
[16:10] <TimToady> masak: your class C in a macro is probably very much like the GLOBALish unification that happens on a compunit level

[16:12] <TimToady> in a sense, a macro is a compilation unit, and instantiation requiries a "linkage" of potentially conflicting viewpoints

[16:13] <TimToady> more generally, whenever you have generic code, instantiation may require contextualization

[16:15] *** bluescreen10 left
[16:16] <TimToady> though a platonist or an aristotelean might give you very different views of what a successful contextualization looks like :)

[16:16] *** bluescreen10 joined
[16:16] *** plobsing_ joined
[16:17] *** dakkar left
[16:17] <TimToady> one could view the whole nominal/structural/duck/monkey typing issue in this light of the Philosophy of Genericity/Specificity

[16:18] *** kaleem joined
[16:18] <TimToady> macros, formal parameters, roles, methods, variables are all just ways of talking generically

[16:19] *** dual left
[16:19] <TimToady> it's the distinction between a common noun and a proper nouns too

[16:20] *** plobsing left
[16:20] *** mj41 left
[16:20] * TimToady is spouting tagmemic notions again...

[16:21] <TimToady> with macros it's just a bit more obvious that you're speaking in multiple contexts at the same time

[16:21] *** bluescreen10 left
[16:22] *** bluescreen10 joined
[16:23] * TimToady had better go try to get his email back up...

[16:25] <sorear> good * #perl6

[16:28] <[Coke]> ho, sorear.

[16:29] * [Coke] yawns waiting for mono-latest-package to build.

[16:30] *** bluescreen10 left
[16:31] *** bluescreen10 joined
[16:32] *** GlitchMr left
[16:34] *** kaleem left
[16:41] *** bluescreen10 left
[16:41] *** bluescreen10 joined
[16:48] <masak> moritz++ # todo, skip

[16:50] *** mkramer left
[16:52] <masak> TimToady: I was thinking of comp unit unification too when I wrote that.

[16:53] *** kaleem joined
[16:56] <ingy> o/

[17:06] *** kaleem left
[17:06] *** kaleem joined
[17:12] *** bluescreen10 left
[17:12] *** bluescreen10 joined
[17:18] *** daniel-s left
[17:21] <masak> \o

[17:24] *** bluescreen10 left
[17:25] <[Coke]> colomon: downloaded, rebuilding niecza...

[17:26] *** bluescreen10 joined
[17:30] *** Chillance joined
[17:30] * TimToady is desolate to have insulted masak++'s intelligence

[17:32] *** im2ee joined
[17:35] *** risou is now known as risou_awy

[17:35] *** bluescreen10 left
[17:35] *** bluescreen10 joined
[17:41] *** zby_home joined
[17:41] *** daxim left
[17:43] <masak> TimToady: not at all; however, I'm horrified how much of the spouting you wrote above makes sense to me at this point :P

[17:46] *** uasi joined
[17:47] <masak> but perhaps that's how a BDFL effectively rules the land. by planting his memes and mental models in people in the community.

[17:52] <masak> also it's both hubristic and humbling at the same time to think really hard about something, only to realize that TimToady already has quite a detailed map of that terrain. :)

[17:55] *** GlitchMr joined
[18:02] *** uasi left
[18:04] * ingy makes a note to impregnate masak soon

[18:04] *** MayDaniel joined
[18:05] <diakopter> hmm

[18:10] *** bluescreen10 left
[18:11] <araujo> masak, making sense out of TimToady .... yah, you should be horrified 

[18:11] * araujo hides

[18:11] <masak> ;)

[18:11] *** japhb_ joined
[18:11] *** bluescreen10 joined
[18:11] <moritz> I've reached that state occasionally too

[18:13] <colomon> TimToady: was catching up on the infix:<xx> change from earlier this month.  Is it too late to make a pitch for leaving the operator as it was, except with a new rule that if the left-hand side is a closure, that closure is called repeatedly?  

[18:13] *** benabik joined
[18:13] <TimToady> probably :)

[18:14] <masak> that feels less elegant.

[18:15] <colomon> masak: less elegant than requiring infix:<xx> to be special?

[18:15] <masak> we're all special.

[18:15] <masak> infix:<&&> is special.

[18:15] <colomon> I'm not

[18:16] <masak> if you're not special but everyone else is, that's quite exceptional...

[18:16] <colomon> The existence of special operators is no reason to frown open the creation of more special operators.

[18:16] <masak> you make a valid point.

[18:17] <masak> however, I'm thinking back to the times when I've wanted [ 0 xx ^$size ] xx ^$size to DWIM

[18:17] <masak> and I like the new proposal.

[18:17] <TimToady> I choose to believe in the optimizer figuring out staticness here

[18:17] <masak> er, [ 0 xx $size ] xx $size

[18:18] <masak> and if the optimizer doesn't figure out staticness, that's probably not a big deal either.

[18:19] <masak> infix:<xx> doesn't feel like a hot-path, tight-loop thing.

[18:20] <colomon> I'm not worried about speed (in this case, anyway)

[18:21] <moritz>  what are you worried about?

[18:21] <colomon> consistency

[18:21] <moritz> with what?

[18:21] <colomon> all the other x-y operators

[18:21] <colomon> ie rand-letter x 10 is one letter repeated ten times

[18:22] <moritz> note that other places that could lead to accidentally shared references already thunk

[18:22] <moritz> (default values in function, default values for attributes)

[18:22] <colomon> rand-letter xx 10 is ten letters, possibly different

[18:23] <masak> you have a point there.

[18:24] <japhb_>  TimToady: I'm a bit confused about S06:3374-3383 . It appears to me that this is ambiguous given for example two MAINs defined as: 'multi MAIN(Int $bar, Bool :$foo = False)' and 'multi MAIN(Int :$foo)' .  Am I correct in this belief?

[18:26] <TimToady> colomon: if you want that kind of consistency, we should make x thunky too

[18:27] <moritz> japhb_: I'm pretty sure that's a fossile

[18:27] <moritz> *fossil

[18:27] <moritz> grrrr

[18:28] * masak hugs moritz 

[18:28] <moritz> japhb_: arguments are passed with --name=value.  --name  now always assumes Bool

[18:28] <moritz> and doesn't inspect the next argument

[18:28] <japhb_> moritz, Ah, OK.  Is there anything in that paragraph that needs to be saved?  Otherwise, I'll nuke the whole thing.

[18:29] <moritz> japhb_: don't think so

[18:29] <moritz> also the line

[18:29] <moritz> --name "spacey value"      :name«'spacey value'»

[18:29] <japhb_> Right, I'll nuke that as well

[18:29] <moritz> is fossiled too

[18:30] <colomon> TimToady: or my proposal could be extended to infix:<x> and infix:<X> too.  ;)

[18:30] <japhb_> thanks!

[18:30] <japhb_> moritz++

[18:30] <moritz> (some of the tests might still test for the old behavior too)

[18:31] <TimToady> what is the approved way to pass a list of shell-globbed files as the argument to a --name=value

[18:32] <TimToady> the other way lets you say --foo *.ext

[18:32] <moritz> but we don't even know if the other way is computable

[18:33] <TimToady> nevertheless, that's a common idiom

[18:33] <moritz> TimToady: I don't use it often at all...

[18:33] *** shinobicl joined
[18:33] <moritz> TimToady: and with the old spec that's only possible of the shell glob expands to a single value

[18:34] *** soh_cah_toa joined
[18:34] <TimToady> no, it says all args up to the next --bar

[18:34] <moritz> it does?

[18:34] <moritz> well, then we can just autopromote an empty list to True

[18:35] <moritz> and say that --foo --bar  is the same :foo  :bar, and --foo *.ext --bar is :foo(glob('*.ext')), :bar

[18:35] *** wk joined
[18:35] <moritz> but then we can't allow options right before positional parameters

[18:36] <moritz> ie we make mixing options and arguments *really+ painful

[18:36] <moritz> ... which, IME, is the much more common idiom

[18:36] <japhb_> Another line in the same section (I forget  which), says that the first non-option *terminates option processing*.  Can't have both behaviors.

[18:37] <moritz> agreed

[18:38] <TimToady> the args are part of the option, so your logic is ill there...

[18:38] <moritz> I'm officially in favor of disabling that magic, and requiring things like --foo="$(echo *.ext)" for what TimToady wants to do

[18:38] <japhb_> Personally, I'm happy with "The default parser requires = , and if you want something different, do your own parse."

[18:39] <TimToady> O

[18:39] <japhb_> Which is an escape hatch that is already in the spec

[18:39] <moritz> TimToady: sorry, I don't understand that

[18:39] <TimToady> typo

[18:39] <moritz> TimToady: if --foo a1 a2 --bar treats a1 and a2 as arguments to foo, how can we pass positional arguments to MAIN after named params?

[18:40] <moritz> s/params/arguments/

[18:40] <TimToady> that's what -- is for

[18:40] *** mkramer joined
[18:40] <moritz> -1

[18:40] <japhb_> OK, but this still doesn't address the ambiguity I brought up at the start of the conversation.

[18:41] <japhb_> Or rather, moritz's solution did, but I don't see how TimToady's does.

[18:41] <moritz> TimToady: that makes the much more common case harder

[18:41] <TimToady> that's just sig ambiguity

[18:41] <japhb_> But the signatures aren't ambiguous per se.  They're only ambiguous when = is optional for non-Bool options

[18:41] *** mberends joined
[18:42] *** mj41 joined
[18:43] <moritz> how about we allow --foo= *.txt

[18:43] <moritz> and withoute the =, --foo is Bool

[18:44] <japhb_> Ah, just a trailing = indicating "I want to capture the args up to the next option"?

[18:44] <moritz> yes

[18:44] <TimToady> distinguish from --foo=''

[18:45] <moritz> can't be

[18:45] <moritz> you can't have it both ways *and* eat your cake

[18:45] <moritz> or you could invent --*foo for slurpy foo

[18:45] * TimToady hasta go work on his email more, but still doesn't like imposing one switch culture; don't care if it's a trait, or a canned pre-MAIN processor, but we need to support multiculuralism here

[18:46] *** envi_ left
[18:46] <TimToady> not tell people how they have to do it

[18:46] <TimToady> afk &

[18:46] <benabik> Generally these kinds of decisions are done via type information given to the option parser.

[18:46] <japhb_> There's another issue.  in '--foo= *.txt', *.txt could expand to things that have leading '--', so effectively if we try this, it has to be the last option anyway (there can be only one of these, and it must end option parsing, except that it gobbles the rest of the line.

[18:47] <japhb_> So then I don't see the value of bothering, since that's what a slurpy array is for.

[18:47] <japhb_> benabik, the signature of MAIN is that type information.  However, MAIN can be a multi -- with disagreeing type information.

[18:48] <benabik> japhb_: I'd argue it's perfectly valid for the option parser to throw up its hands at that point.

[18:49] <benabik> japhb_: Or decide to prefer Bool over non-bool or similar.

[18:49] *** Holy_Cow left
[18:51] * masak is happy to see S19 being discussed

[18:52] *** dual joined
[18:52] <japhb_> benabik, If we allow no '=' but prefer Bool, we're effectively creating action at a distance.  Whether an '=' is required on an option that does have an argument changes depending on whether an argumentless option can be found in any other MULTI.  It's not a dealbreaker, but it smells fishy to me.

[18:52] *** kaare_ left
[18:53] <japhb_> Plus then we suspiciously complicate the interaction between the command line parser and the dispatcher.

[18:53] <japhb_> Unlike the existing behavior which is: "Here is the canonical parse of the command line.  Are there any matching dispatch candidates?" we would be changing to

[18:54] <benabik> If you're going to try to parse command line options without any type information then trying to do complex things like "optional =" is probably just going to have lots of painful corners.

[18:55] <japhb_> "OK, looking at the first argument, there are a couple interpretations.  How many candidates match either interpretation *so far*?  If matches exist with both interpretations, we need to continue building a tree of interpretations, trying to find a non-conflicting, non-ambiguous parse.  Otherwise we finally throw our hands up."

[18:55] <japhb_> Too much magic for my taste.

[18:55] <benabik> It's a perfectly  reasonable level of magic in some ways.

[18:55] <benabik> It is a lot to do though.

[18:55] <japhb_> benabik, the parsing is *generating* a set of type information that it is trying to match against the type information from the dispatch candidates.

[18:56] <benabik> japhb_: The problem is creating a non-ambiguous parse without type information ahead of time.

[18:56] <japhb_> That's part of why arguments are passed through val(), which is trying to figure out what types are there, so it can inform the dispatcher.

[18:56] <japhb_> benabik, right.

[18:57] <benabik> japhb_: Option parsers that do things like optional =s and automatic --no- options tend to receive type information to inform the parse.

[18:57] <japhb_> And we either to make the parser and the dispatcher get to know each other approximately as well as Cursor and Match, or we can't DWIM like that.

[18:57] <masak> all that ever comes in from the command line is strings. we pass them through val() to "enrich" their types. this is what makes MAIN dispatch different from regular MMD.

[18:57] <japhb_> right ...

[18:57] <masak> in a way, it's similar to the problems we had with trying to unite calling context and MMD.

[18:58] <benabik> The only way to unambiguously know if --foo bar is :(:foo<bar>) or :(:foo, 'bar') is to inform it ahead of time.  Which, in this scheme requires inspection on the MULTI canidates.

[18:58] <masak> (in that you have two things each needing the outcome of the other)

[18:58] <benabik> Or a set of pragmas, or similar.

[18:58] <japhb_> benabik, right, but what if both dispatch candidates exist?

[18:59] <benabik> japhb_: Disambigation rule or explode, implementer's choice.  :-D

[18:59] <benabik> japhb_: What happens if multi candidates are ambiguous?

[18:59] *** MayDaniel left
[18:59] <benabik> Probably what needs to get done is to have a 90% parser that requires = and have the system be modular enough to have a pragma or inspection base system get `use`d

[18:59] <japhb_> I see three options: 1.  Don't DWIM, just error in that case.  2. Warn to the user that a guess is being made.  3. Require =

[18:59] <japhb_> masak, exactly

[19:00] *** kaleem left
[19:00] <japhb_> benabik, sure.  And my argument is that that escape hatch already exists in the spec, where it says that if you need non-default option parsing, use your own grammar.

[19:00] *** kaleem joined
[19:01] <moritz> 2. seems very wrong. You ship a program to the user, and he calls it in an unexpected way, and Perl 6 warns (not the program)

[19:01] <japhb_> Agreed.

[19:02] <japhb_> And also I think '--foo *.txt' magic is also much less valuable for Perl 6 programs, because A) it must be the last and only case of that usage on the command line, meaning you can't do it more than once in a single line, and B) we have slurpy arrays for that use case.

[19:03] <benabik> I'm arguing 3 for the basics and then requesting someone write something more complicated.  :-D

[19:03] <japhb_> benabik, I'm currently writing "the basics".  ;-)

[19:04] <japhb_> But it sounds like we're in some agreement.

[19:04] <masak> I really like MMD, so I wouldn't mind if MAIN dispatch got a bit weaker if it became more like regular MMD, if possible.

[19:04] <benabik> If you have non-multi MAIN, introspection is much easier.

[19:04] *** mkramer left
[19:04] <moritz> benabik: introspection makes it much harder for the user to reason about the program

[19:04] <japhb_> moritz++

[19:05] <moritz> things might feel a bit more intuitive in the beginning, but when you try to /understand/ what's going on, it hurts you.

[19:05] <benabik> moritz: sub MAIN( Int :$foo, Bool :$bar, *@files) allowing prog --foo 3 --bar * is difficult?

[19:05] <japhb_> And I'm not sure we want people to require different mental models depending on whether *internally* a program implements its MAIN variants with an only MAIN and internal logic, or using MMD and multi MAINs

[19:06] <japhb_> benabik, Essentially that dual behavior would require *users* to know how the *program* works in order to sanely feed it arguments.

[19:06] <moritz> benabik: reading just the command line, I#d think that the result of * is an argument to --bar

[19:07] <moritz> benabik: or that 3 terminates the command line processing

[19:08] <benabik> More normal might be sub MAIN( Int :f(:$foo), Bool :$bar, *@baz) allowing prog -f 3 --bar *

[19:08] *** mkramer joined
[19:08] <geekosaur> so, you do realize that * is expanded by the shell, on unix?

[19:08] * benabik doe

[19:08] <japhb_> benabik, and in fact that case would be handled correctly.  :-)

[19:08] <japhb_> (in the current '='-requiring code, I mean)

[19:09] <benabik> japhb_: If it assumes all short options take arguments, that might be a problem.  I like my `tar -xzf foo.tar.gz`

[19:10] <japhb_> benabik, I don't think anyone's suggesting clustering right now.

[19:11] <benabik> Simpler case: echo -n foo bar baz.  I really expect $n to be True, not 'foo'.  Complex option parsing without foreknowledge of types is extremely difficult.

[19:12] <moritz> and foreknowledge of types requires solving the Halting problem in the case of multi dispatch

[19:12] <benabik> Non-clustering and requiring = on long options is probably the path of least surprise.

[19:15] <benabik> moritz: determining option type by multi introspection is also extremely difficult.  Non-multi MAIN() and/or pragmas are probably going to be more likely.  I still like the idea of a OptParse::Magic module that does it by progressively narrowing multi candidates.  But, yes, as a default that's probably a bit much.

[19:26] *** mkramer left
[19:28] *** molaf left
[19:32] <japhb_> bak from interruption ...

[19:33] <GlitchMr> perl6: for 1..10000 {say "$_ is dividable by 10000" if 10000 %% $_}

[19:33] <phenny> GlitchMr: 14 Oct 03:29Z <sorear> tell GlitchMr https://github.com/sorear/niecza/issues/67

[19:33] <GlitchMr> Unoptimized code

[19:33] <p6eval> niecza v10-54-g2f61b1e: OUTPUT«1 is dividable by 10000␤2 is dividable by 10000␤4 is dividable by 10000␤5 is dividable by 10000␤8 is dividable by 10000␤10 is dividable by 10000␤16 is dividable by 10000␤20 is dividable by 10000␤25 is dividable by 10000␤40 is dividable by 10000␤50 is divid…

[19:33] <p6eval> ..pugs c943eeb: OUTPUT«*** ␤    Unexpected "%% $_"␤    expecting operator or "}"␤    at /tmp/SdMN91zp1T line 1, column 55␤»

[19:33] <p6eval> ..rakudo 4e4390: OUTPUT«1 is dividable by 10000␤2 is dividable by 10000␤4 is dividable by 10000␤5 is dividable by 10000␤8 is dividable by 10000␤10 is dividable by 10000␤16 is dividable by 10000␤20 is dividable by 10000␤25 is dividable by 10000␤40 is dividable by 10000␤50 is dividable by 1…

[19:34] <japhb_> OK, TimToady, given the above, do you agree to dropping 'no =' support in the base spec, and pushing that to module territory?

[19:34] <GlitchMr> %% is operator... pugs...

[19:34] <GlitchMr> divisable lol

[19:35] <GlitchMr> divisible*

[19:35] <GlitchMr> Very complex word

[19:35] <japhb_> GlitchMr, pugs is behind the times still.  Also, in English that statement is swapped: '10000 is divisible by $_'

[19:35] <moritz> pugs: say $_ !% 3 for 5, 6

[19:35] <p6eval> pugs c943eeb: OUTPUT«*** ␤    Unexpected "!%"␤    expecting operator, ":" or ","␤    at /tmp/gJTBZFjsBj line 1, column 8␤»

[19:36] <GlitchMr> oh right

[19:36] <moritz> GlitchMr: also it's good style not to produce too much output with p6eval here, unless there is a very good reason for doing so

[19:37] <moritz> (hint, hint)

[19:39] *** kaleem left
[19:42] *** kaleem joined
[19:43] <GlitchMr> perl6: for 'a'..'z' {say $_ %% $_}

[19:43] <p6eval> niecza v10-54-g2f61b1e: OUTPUT«␤Unhandled Exception: System.FormatException: Unknown char: a␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) […

[19:43] <p6eval> ..rakudo 4e4390: OUTPUT«Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤Bool::True␤B…

[19:43] <p6eval> ..pugs c943eeb: OUTPUT«*** ␤    Unexpected "%% $_"␤    expecting operator, ":", "," or "}"␤    at /tmp/IqKFuAxaKp line 1, column 22␤»

[19:43] <GlitchMr> (it doesn't make sense, I know)

[19:43] <GlitchMr> TRUE TRUE TRUE TRUE... what?

[19:44] <benabik> Probably 0 %% 0 == True?

[19:44] <benabik> nom: say +'a'

[19:44] <p6eval> nom 4e4390: OUTPUT«0␤»

[19:45] <colomon> benabik has it, of course.

[19:45] <colomon> perl6: say "a" == 0

[19:45] <p6eval> rakudo 4e4390: OUTPUT«Bool::True␤»

[19:45] <p6eval> ..niecza v10-54-g2f61b1e: OUTPUT«␤Unhandled Exception: System.FormatException: Unknown char: a␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) […

[19:45] <p6eval> ..pugs c943eeb: OUTPUT«1␤»

[19:46] <GlitchMr> perl6: say 0 %% 0

[19:46] <benabik> niecza appears to not like Int.String(y?)

[19:46] <p6eval> rakudo 4e4390: OUTPUT«Bool::True␤»

[19:46] <p6eval> ..niecza v10-54-g2f61b1e: OUTPUT«␤Unhandled Exception: System.DivideByZeroException: Division by zero␤  at Builtins.mod (Niecza.Variable a1, Niecza.Variable a2) [0x00000] in <filename unknown>:0 ␤  at CORE.C881_infix_3A_3C_25_25_3E (Niecza.Frame ) [0x00000] in <filename unknown>:0 ␤  at N…

[19:46] <p6eval> ..pugs c943eeb: OUTPUT«*** ␤    Unexpected "%% 0"␤    expecting operator, ":" or ","␤    at /tmp/a1FWmTXWLU line 1, column 7␤»

[19:46] <GlitchMr> ... not only that

[19:46] <benabik> Or %% 0

[19:46] <GlitchMr> 0%0 is obviously invalid

[19:46] <GlitchMr> You cannot divide by zero

[19:47] <GlitchMr> So why 0%%0 isn't...

[19:47] <benabik> nom:  2 %% 0

[19:47] <p6eval> nom 4e4390:  ( no output )

[19:47] <GlitchMr> "Performs a % and then tests the result for 0, returning Bool::True if the $x is evenly divisible by $y, and Bool::False otherwise."

[19:47] <benabik> nom: say 2 %% 0

[19:47] <p6eval> nom 4e4390: OUTPUT«Bool::False␤»

[19:47] <GlitchMr> perl6: say 0%0

[19:48] <p6eval> pugs c943eeb: OUTPUT«*** Illegal modulus zero␤    at /tmp/mHlU1Jq_0K line 1, column 5 - line 2, column 1␤»

[19:48] <p6eval> ..niecza v10-54-g2f61b1e: OUTPUT«␤Unhandled Exception: System.DivideByZeroException: Division by zero␤  at Builtins.mod (Niecza.Variable a1, Niecza.Variable a2) [0x00000] in <filename unknown>:0 ␤  at MAIN.C0_mainline (Niecza.Frame ) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.R…

[19:48] <p6eval> ..rakudo 4e4390: OUTPUT«0␤»

[19:48] <GlitchMr> rakudo doesn't seem to have problem with 0%0 it seems...

[19:48] <GlitchMr> But it's actually $x - floor($x / $y) * $y

[19:48] <GlitchMr> ...

[19:49] <GlitchMr> 0 - floor(0 / 0) * 0

[19:49] <GlitchMr> ...

[19:49] <GlitchMr> There is "0" involved in it, so 0/0 doesn't matter...

[19:49] <GlitchMr> So yeah, it kind of makes sense

[19:49] <GlitchMr> But it's weird

[19:52] *** mkramer joined
[19:54] <masak> GlitchMr: I agree.

[19:54] <masak> rakudo: say 0 / 0; say (0 / 0) * 0

[19:54] <p6eval> rakudo 4e4390: OUTPUT«Divide by zero␤  in sub infix:<div> at src/gen/CORE.setting:2312␤  in method new at src/gen/CORE.setting:5697␤  in sub infix:</> at src/gen/CORE.setting:5791␤  in block <anon> at /tmp/WyBPKxDZfI:1␤  in <anon> at /tmp/WyBPKxDZfI:1␤»

[19:54] <masak> rakudo: say 0 % 0

[19:55] <p6eval> rakudo 4e4390: OUTPUT«0␤»

[19:55] <masak> this seems like somewhat of a double standard.

[19:55] <GlitchMr> It's actually in standard

[19:55] <GlitchMr> <%> should make this calculation

[19:56] <GlitchMr> The result of floor() doesn't matter if $y is 0, because $something*0 is always 0...

[19:58] <masak> rakudo: say Inf * 0

[19:58] <p6eval> rakudo 4e4390: OUTPUT«NaN␤»

[19:58] <masak> not everything.

[20:06] <GlitchMr> <GlitchMr> !yib math 1%0.2

[20:06] <GlitchMr> <YIBot> 0.2

[20:06] *** carlin joined
[20:06] <GlitchMr> This is why I think that floats are fun

[20:06] <GlitchMr> Good thing I haven't yet found such issues in Perl 6 :).

[20:07] <masak> GlitchMr: that's because 0.2 isn't a float in Perl 6.

[20:07] <GlitchMr> What it is then

[20:08] <PerlJam> a Rat

[20:09] *** kaleem left
[20:10] <GlitchMr> perl6: say <2/4>*3

[20:10] <p6eval> pugs c943eeb: OUTPUT«6␤»

[20:10] <p6eval> ..niecza v10-54-g2f61b1e: OUTPUT«␤Unhandled Exception: System.FormatException: Unknown char: /␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) […

[20:10] <p6eval> ..rakudo 4e4390: OUTPUT«1.5␤»

[20:10] <GlitchMr> ...?

[20:12] *** GlitchMr left
[20:12] <TimToady> rakudo is correct; pugs predatest the <2/4> notation, and niecza doesn't implement it yet

[20:12] <TimToady> at least, not for rats

[20:13] <TimToady> it thinks <2/4> is just a qw

[20:15] <japhb_> TimToady, along with my previous question (are you amenable to saying that allowing option arguments without = requires a module or manual parsing?) Here's another: should val() attempt to detect constant and enum names seen in the command line args? 

[20:17] <masak> ...in which lexical scope...?

[20:18] <TimToady> presumably at the end of UNIT, where MAIN is called

[20:18] <benabik> That would probably be handy, actually.  Although getting the scoping right might be interesting.

[20:18] <TimToady> I lean slightly towards a 'yes'

[20:18] * benabik is enjoying being the peanut gallery today.

[20:18] <masak> as long as there's a lexical scope where the arguments are conceptually located, I guess that's fine.

[20:19] <PerlJam> How does one override the command line parser?

[20:19] <TimToady> the args are coming from $*ARGS

[20:19] <TimToady> it suffices to define your own $*ARGS in UNIT

[20:19] <PerlJam> Hmm.

[20:20] *** shinobicl left
[20:21] *** arthur-_ left
[20:21] <TimToady> I guess I'm okay with other preprocessors to the args coming via modules, as long as we don't mess up the semantics so thoroughly as to make certain things impossible

[20:21] <TimToady> we already mandate a val() preprocess, after all

[20:23] *** arthur-_ joined
[20:23] <TimToady> on constant names, as long as we reliably fall back to stringy types when there's no binding for the constant's type, it should not be a major issue

[20:24] <TimToady> still thinking about a way to make string bindings epsilon looser than other types

[20:24] <japhb_> Ah, so you mean two passes: One trying with constants and enum strings turned into real types, and failing dispatch there, failing them all back to Str?  Or do I need to try all combinations until one of them matches (and if that, then what order ...?)

[20:25] <japhb_> Oh, hum

[20:25] <TimToady> no, I mean one pass, but Str binding loser

[20:25] <TimToady> *looser

[20:25] <TimToady> just as constraints are epsilon tighter than nominal types

[20:25] *** MayDaniel joined
[20:25] <japhb_> Yeah, that was the 'Oh, hum', when I looked up from my typing and saw your previous statement.  :-)

[20:25] <TimToady> we had a long discussion about it a couple weeks ago

[20:26] <japhb_> 'we' meaning #perl6, I assume

[20:26] <TimToady> nodnod

[20:27] * TimToady has to go off and hack on p5camel for the rest of the week, now that email is fixed (crosses fingers)

[20:27] <japhb_> What is 'p5camel'?

[20:27] <TimToady> so I'll be somewhat scarce

[20:27] <PerlJam> TimToady: When does the camel hit the stores?

[20:27] <japhb_> Oh, the book!

[20:27] <japhb_> Can't wait for that.

[20:27] <TimToady> they'd want to get it out this year, but we'll see...

[20:28] <PerlJam> I can't believe it's been > 10 years since the last one

[20:28] <japhb_> Has the release date for the next Rakudo been picked?

[20:28] <japhb_> Yeah, amazing that

[20:28] <TimToady> won't have as much time to polish this camel, so it should be more correct, but rougher

[20:28] <PerlJam> japhb_: the compiler or the Star release?

[20:29] <TimToady> .o("You can't polish a camel.")

[20:29] <japhb_> PerlJam, compiler.  I'm trying to figure out what more I have time to fit into my MAIN work before the release

[20:29] <TimToady> later &

[20:29] <japhb_> o/

[20:29] <PerlJam> TimToady: do you guys talk about "Modern Perl" ?

[20:29] <dalek> sprixel: 7a7623e | diakopter++ | src/interp.c:

[20:29] <dalek> sprixel: optimization

[20:29] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/7a7623e872

[20:30] *** MayDaniel left
[20:30] <PerlJam> japhb_: the compiler is scheduled for the 20th.

[20:30] <japhb_> PerlJam, Besides, last I recall, R* was held up until the nebulous "the ecosystem is working again"

[20:30] <japhb_> PerlJam, ah, OK

[20:31] * japhb_ probably shouldn't add much more to nom now, but rather save it for the next cycle.

[20:31] <PerlJam> that reminds me ... anyone got any favorites for the name?

[20:31] *** mantovani joined
[20:31] <tadzik> PerlJam: Warsaw? :)

[20:31] <mantovani> hi rakdCopyright 2010 Aware (www.aware.com.br)

[20:31] <mantovani> ops

[20:31] <mantovani> sorry bad ctrl+c

[20:31] <mantovani> hi

[20:31] <mantovani> rakudo is already for production ?

[20:32] <PerlJam> mantovani: depending on what "production" means.

[20:32] <mantovani> means, developt the main software of my company 

[20:32] <japhb_> lunch &

[20:33] <mantovani> PerlJam: serving a lot of people

[20:33] <PerlJam> mantovani: at a guess, I'd say "no" 

[20:33] <mantovani> can you say why please ?

[20:34] <sjohnson> mantovani: it's not fully ready yet, would be my guess.

[20:34] <tadzik> it's slow and somewhat resource-heavy

[20:34] <PerlJam> mantovani: Check out http://perl6.org/compilers/features.html though

[20:34] <mantovani> thank you very much it is enough

[20:34] <mantovani> ^^

[20:35] * mantovani reading

[20:35] <masak> mantovani: rakudo can do a *lot* of things. however, Perl 5 is more stable, has more modules, is faster, and has a bigger user base.

[20:35] <dalek> nqp: bb30b90 | pmichaud++ | src/Q (2 files):

[20:35] <dalek> nqp: Add NQPCursor "restart match" capabilities.

[20:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bb30b90f91

[20:36] <tadzik> woo, qregex hacking

[20:36] *** mberends left
[20:36] <PerlJam> hopefully the first in a long series of improvements :)

[20:36] <masak> pmichaud++

[20:44] *** wamba left
[20:50] *** mberends joined
[20:50] <diakopter> mberends: hi

[20:51] *** dorlamm joined
[20:51] <colomon> mberends: o/

[20:52] <masak> mberends! \o/

[20:52] *** zby_home left
[20:54] *** zby_home joined
[20:57] *** zby_home left
[20:59] *** im2ee left
[20:59] <[Coke]> colomon: hey, guess what. spectest now fails that ONE TEST. nothing else. 

[20:59] <colomon> [Coke]: right, that's what I get too.

[21:01] <colomon> [Coke]: btw, remember all those test files that didn't work because of unlink?  unlink works now.  ;)

[21:02] <[Coke]> colomon: I will refudge at some point soon. Thanks!

[21:02] <[Coke]> weird that the version of mono bumped that from a pass to a fail. But at least it's reproducable.

[21:03] *** eiro joined
[21:04] <dalek> sprixel: 4c22d2a | diakopter++ | src/ (6 files):

[21:04] <dalek> sprixel: progress toward compiling variable storage/access

[21:04] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/4c22d2af5d

[21:04] <dalek> sprixel: b56c0c4 | diakopter++ | src/interp.c:

[21:04] <dalek> sprixel: Merge branch 'master' of github.com:diakopter/sprixel

[21:04] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/b56c0c4886

[21:04] <dalek> sprixel: a276704 | diakopter++ | src/ (6 files):

[21:04] <dalek> sprixel: rename node to ASTNode

[21:04] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/a27670419e

[21:09] <soh_cah_toa> what's the opposite of split() again? i forget...

[21:09] <diakopter> join?

[21:09] <soh_cah_toa> no. instead of splitting on what you don't want, it splits on what you do want

[21:09] <tadzik> comb?

[21:09] <colomon> comb, yeah

[21:09] <soh_cah_toa> ah, yes. thanks

[21:10] <dalek> niecza: a5c253d | (Solomon Foster)++ | t/spectest.data:

[21:10] <dalek> niecza: Turn on io_in_for_loops.t.

[21:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a5c253dce8

[21:12] *** smash_ joined
[21:14] *** smash_ is now known as smash

[21:15] *** y3llow_ joined
[21:15] *** pothos_ joined
[21:17] *** pothos left
[21:18] *** pothos_ is now known as pothos

[21:18] *** y3llow left
[21:18] *** y3llow_ is now known as y3llow

[21:18] <smash> hello everyone

[21:18] <soh_cah_toa> smash: howdy

[21:19] <colomon> \o

[21:21] <masak> smash! \o/

[21:21] <tadzik> hello smash

[21:22] <tadzik> niecza: async { say 1 }; say 2

[21:22] <p6eval> niecza v10-54-g2f61b1e: OUTPUT«===SORRY!===␤␤Action method statement_prefix:async not yet implemented at /tmp/0gWyv73hqC line 1:␤------> async { say 1 }⏏; say 2␤␤␤Unhandled Exception: Unable to resolve method statement_level in class Str␤  at /home/p…

[21:24] *** bluescreen10 left
[21:45] *** skangas left
[21:49] *** mj41 left
[21:50] *** carlin left
[21:58] *** mkramer left
[22:01] <masak> 'najt, #perl6

[22:05] <sorear> phenny: "najt"?

[22:05] <phenny> sorear: "find" (sl to en, translate.google.com)

[22:05] <sorear> phenny: en de "night"?

[22:05] <phenny> sorear: "Nacht" (en to de, translate.google.com)

[22:05] <sorear> phenny: en sv "night"?

[22:05] <phenny> sorear: "natt" (en to sv, translate.google.com)

[22:05] <sorear> phenny: en nl "night"?

[22:05] <phenny> sorear: "nacht" (en to nl, translate.google.com)

[22:06] <sorear> good * #perl6

[22:09] <wk> phenny: en pl "night"

[22:11] <sorear> phenny: en pl "night"?

[22:11] <phenny> sorear: "noc" (en to pl, translate.google.com)

[22:11] * sorear guessed that one

[22:11] <sorear> see also

[22:11] <sorear> phenny: en ru "night"?

[22:11] <phenny> sorear: The en to ru translation failed, sorry!

[22:11] <flussence> phenny: en eo "night"?

[22:11] <phenny> flussence: The en to eo translation failed, sorry!

[22:11] <flussence> was worth a shot...

[22:11] <wk> phenny: et en "ööd"

[22:12] <sorear> it's noch in Russian too

[22:12] <benabik> wk: I think it needs the ? at the end.

[22:12] <wk> phenny: et en "ööd"?

[22:12] <phenny> wk: "nights" (et to en, translate.google.com)

[22:12] <wk> benabik: of course :)

[22:16] *** whiteknight joined
[22:18] <wk> instead of phenny: en{night} -> ru{ноч}

[22:18] <[Coke]> did TPF work with GCI in previous years?

[22:23] <wk> like this: http://leto.net/mt/mt-search.cgi?tag=gci&blog_id=9 ?

[22:30] *** wk left
[22:32] <sorear> phenny: "ноч"?

[22:32] <phenny> sorear: "night" (ru to en, translate.google.com)

[22:45] *** Chillance left
[22:52] *** dorlamm left
[22:55] *** benabik left
[23:00] <dalek> niecza/serialize: 232da04 | sorear++ | src/ (4 files):

[23:00] <dalek> niecza/serialize: Mergeback

[23:00] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/232da04030

[23:01] <dalek> niecza/serialize: 3edbade | sorear++ | / (8 files):

[23:01] <dalek> niecza/serialize: Merge branch 'master' of github.com:sorear/niecza into serialize

[23:01] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/3edbadef6e

[23:02] <sorear> git++ # successfully executed a merge where a file was modified on one side and renamed on the other

[23:13] *** donri left
[23:15] *** cognominal left
[23:15] *** cognominal joined
[23:23] *** pernatiy left
[23:27] <dalek> sprixel: 94ef74f | diakopter++ | src/ (3 files):

[23:27] <dalek> sprixel: rename instpool to InstPool

[23:27] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/94ef74f325

[23:27] <dalek> sprixel: f5e963e | diakopter++ | src/ (3 files):

[23:27] <dalek> sprixel: TitleCase a bunch more types

[23:27] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/f5e963ea3d

[23:27] <dalek> sprixel: b69099e | diakopter++ | src/ (8 files):

[23:27] <dalek> sprixel: lots more renaming, also extend mberends' hashtable.c fetch operation to set a pointer to the hash entry in addition to setteing the values.

[23:27] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/b69099e56c

[23:28] <diakopter> sorear: there, I made it operate on pointers to avoid the double hash lookup.

[23:30] <colomon> o/

[23:30] <diakopter> hi

[23:34] *** tokuhiro_ joined
[23:37] <dalek> roast: 06d8f11 | (Solomon Foster)++ | S32-trig/generate-tests.pl:

[23:37] <dalek> roast: New version of generate-tests.pl which properly fudges atan2 for niecza.

[23:37] <dalek> roast: review: https://github.com/perl6/roast/commit/06d8f11301

[23:38] <dalek> roast: b652e36 | (Solomon Foster)++ | S32-trig/atan2.t:

[23:38] <dalek> roast: Fudged version of atan2.t.

[23:38] <dalek> roast: review: https://github.com/perl6/roast/commit/b652e36251

[23:40] <dalek> niecza: 008602e | (Solomon Foster)++ | t/spectest.data:

[23:40] <dalek> niecza: Turn on atan2.t.

[23:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/008602e8bb

