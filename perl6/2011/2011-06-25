[00:05] *** mtk left
[00:12] <dalek> niecza: 977ee15 | sorear++ | docs/DIRECTIONS:

[00:12] <dalek> niecza: Remove outdated statements from DIRECTIONS

[00:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/977ee15935

[00:12] <dalek> niecza: 58e6749 | sorear++ | / (3 files):

[00:12] <dalek> niecza: Add S03-operators/overflow.t

[00:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/58e6749367

[00:12] <dalek> niecza: efa9b51 | sorear++ | tools/unrun_tests:

[00:12] <dalek> niecza: Add a little script to find unrun test files

[00:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/efa9b513e0

[00:12] <dalek> roast: e7d9d8f | sorear++ | S03-operators/overflow.t:

[00:12] <dalek> roast: Fudge S03-operators/overflow.t for niecza

[00:12] <dalek> roast: review: https://github.com/perl6/roast/commit/e7d9d8f828

[00:13] *** cdarroch left
[00:13] <sorear> TimToady: Is it legal for niecza's $?FILE to return an absolute path?

[00:14] <sorear> A spectest doesn't like it, I'm wondering if I can fix the test :)

[00:15] *** icwiener left
[00:17] <TimToady> I suppose.  maybe that means we need to make it easier to distinguish the original argv[0] from 1) a calculated absolute path or 2) the last component

[00:18] <TimToady> then an error message can choose how specific it wants to be

[00:18] <TimToady> that particular area has always been a source of non-portability though

[00:20] <TimToady> certainly there's a sense in which an abs path is safer, though no file name is perfectly safe

[00:20] <TimToady> an abs path can become wrong if the directories change; a rel path goes wrong when you chdir, and a short name is always wrong outside of its directory

[00:22] <TimToady> I tend to think the original argv[0] name is best for error messages, neither too much information nor too little, usually

[00:24] <TimToady> I'm always a bit amused when niecza emits a completely mundane error message and then sends it off my screen with an unnecessary stack trace...

[00:26] <sorear> not helping is the ~5 lines of useless (above {YOU_ARE_HERE}) lines, and the fact that absolute file names make most of them wrap...

[00:26] <TimToady> 'course, if $?FILE is going to be the original source file of a program compiled long ago in a galaxy far away, we probably need even more info than the abs path...

[00:26] <sorear> I think niecza used note;exit for errors once, but that broke eval

[00:27] <sorear> I've been tempted to add $?SHA1

[00:29] <TimToady> I coulda used $?ORIG for http://rosettacode.org/wiki/Narcissist  :)

[00:29] *** Limbic_Region joined
[00:30] <sorear> is $?ORIG generally useful?

[00:31] <TimToady> well, if you need to translate positions to line numbers, you can get it from there :)

[00:31] <TimToady> and it makes it easier to do &foo.perl  :)

[00:31] <sorear> seems a bit extravagant

[00:31] <TimToady> I think the average size of programs with respect to memories is shrinking rapidly

[00:32] <TimToady> it also gives you ready access to any $=POD vars

[00:32] <TimToady> the pod vars could all be synthetic, based on $?ORIG, in fact

[00:33] <TimToady> and you can always give error messages by pointing to the source code :)

[00:33] <TimToady> so I think it's a Good Default

[00:33] <TimToady> even if people want 'use cloak;'

[00:34] <Limbic_Region> . o O ( we don't need no stinkin Romulans )

[00:34] <TimToady> it might be particularly important for errors coming from eval

[00:34] * Limbic_Region may have imbibed voracious amounts of potent potables and should be summarily ignored

[00:35] <TimToady> you'd think it was a Friday night or sump'n...

[00:36] <sorear> I've lost all contact with the calendar lately

[00:36] <TimToady> btw, To Whom It May Concern, http://rosettacode.org/wiki/Natural_sorting is a pretty good start for a natural sorting spec

[00:40] <sorear> gee, that looks a lot like the Unicode Collation Algorithm

[00:42] <TimToady> we just need to suck in all the Unicode algoritms, translate them to P6, and then given them all simple APIs...oh wait...

[01:01] *** noganex_ joined
[01:01] <thou> hmmm, i'm seeing chinese ideographs on the rosetta code new account page's captcha

[01:01] <lichtkind> good night

[01:03] <thou> hmmm, actually might be japanese

[01:04] *** noganex left
[01:04] *** lichtkind left
[01:06] <thou> reloading the captcha got me by -- i started looking a lists of kanji and so forth, but ... pretty challenging for me when i don't have any context for it

[01:20] *** jaldhar joined
[01:26] <TimToady> cool!  pity I already have an account....

[01:29] <TimToady> I can't do the Romanian granny, but I could do the California grampa if you send me a photo :)

[01:29] <TimToady> probably times out though...

[01:29] <Limbic_Region> @TimToady - have you ever used Rosetta Stone?

[01:30] <TimToady> yes

[01:30] <Limbic_Region> Thoughts?

[01:30] <TimToady> it seemed pretty fine, though I got sidetracked somewhere in the middle

[01:31] <TimToady> it seemed good for my weakness, which is actually understanding what was said

[01:32] <Limbic_Region> as an employee of *mumble*, I have unlimited access and have been spending an hour a night learning Tagalog but despite score 96 or above on every lesson don't feel like I am getting any closer to speaking the language

[01:32] <Limbic_Region> Having a great memory allows me to isolate and associate without comprehension

[01:33] <Limbic_Region> was just wondering if it was me or the program

[01:33] <TimToady> I don't have much trouble speaking, but then I'm a phoneticist/phonologist by training :)

[01:34] <thou> TimToady: http://postimage.org/image/49qp6938/  # Screenshot of the captcha if you're curious

[01:34] <TimToady> you probably need to live in .ph for six months or so

[01:34] <TimToady> just like I need to live in .jp for a while

[01:35] * Limbic_Region finds the phonetics like ng and mga of Tagalog a little difficult but for the most part it is a simple language

[01:35] <Limbic_Region> but I am used to learning foreign languages the classical way - this is a verb, this is how you conjugate it, this is a noun, this is how you modify it, etc

[01:36] <Limbic_Region> Rosetta Stone takes the approach of teaching as though you were an infant - total immersion with no instruction which I find frustrating because if I knew the rules without having to reverse engineer them - I would be much further along

[01:36] <Limbic_Region> *shrug*

[01:37] <TimToady> thou: 度初探

[01:38] <TimToady> degree first probe

[01:38] <thou> ;-)

[01:38] <TimToady> or times begin search

[01:39] <TimToady> but they're also valid Chinese

[01:39] <TimToady> and mean much the same there

[01:39] <thou> the third one is pretty neat, like a Whatever hanging out under an umbrella

[01:40] <TimToady> the whatever is a tree, and the umbrella is really a variant of net

[01:40] <TimToady> if it had a tick on top it'd be "hole"

[01:40] <TimToady> to the left of that is "hand"

[01:40] <TimToady> the first one is Roof.o Ubar.it dex.ib

[01:40] <TimToady> the second is clothes.l Sword.r

[01:41] <TimToady> I can pretty easily look up any character by knowing all the radicals and pseudo-radicals

[01:41] <TimToady> including many of the simpler ones in Extension B

[01:41] <thou> and i'm sure that's how the brain organizes them, too, for reading comprehension

[01:42] <thou> well, no, i'm not sure

[01:42] <thou> it'd be my first guess :-)

[01:42] <TimToady> I suspect most people do "whole word" pattern matching

[01:42] <TimToady> and don't really think about the bits, anymore than we think about the letters

[01:43] <thou> does rakudo or niecza handle Q :to('HERE')? I can't seem to find a here-doc syntax that they'll swallow.

[01:43] <TimToady> I did one earlier in niecza

[01:43] <TimToady> niecza: say q :to "EOF"␤alive␤EOF␤

[01:43] <p6eval> niecza v6-191-gefa9b51: OUTPUT«alive␤␤»

[01:44] <TimToady> niecza: say Q :to "EOF"␤alive␤EOF␤

[01:44] <p6eval> niecza v6-191-gefa9b51: OUTPUT«alive␤␤»

[01:45] <TimToady> niecza: say Q :to "EOF"␤$alive␤EOF␤

[01:45] <p6eval> niecza v6-191-gefa9b51: OUTPUT«$alive␤␤»

[01:45] <TimToady> niecza: say qq :to "EOF"␤$alive␤EOF␤

[01:45] <p6eval> niecza v6-191-gefa9b51: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $alive is not predeclared at /tmp/JXFUqrOTT8 line 2:␤------> [32m<BOL>[33m⏏[31m$alive[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at /home/p6e…

[01:45] <TimToady> looks pretty functional to me

[01:46] <thou> yeah. i was misled by a mistake elsewhere in my program, sorry

[01:47] <TimToady> called to 夕食

[01:47] <TimToady> that's evening and food

[01:47] <TimToady> &

[01:47] <thou> niecza: say qq :to('EOF')␤alive␤EOF␤

[01:47] <p6eval> niecza v6-191-gefa9b51: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Alphanumeric character is not allowed as delimiter at /tmp/RhZyDrqswb line 2:␤------> [32m<BOL>[33m⏏[31malive[0m␤␤Parse failed␤␤»

[01:49] <thou> ok, good night

[01:55] *** JimmyZ joined
[02:19] *** whiteknight left
[02:26] *** JimmyZ left
[02:52] *** jaldhar left
[02:53] *** jaldhar joined
[02:56] *** Limbic_Region left
[03:09] *** jdhore1 left
[03:16] *** cotto joined
[03:17] *** jdhore1 joined
[03:23] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:35] *** woosley joined
[03:36] *** woosley left
[03:36] *** Bzek joined
[03:44] *** lue left
[03:51] *** cooper left
[04:02] <sorear> Where is the spec for the stuff S02-magicals/submain.t tests?

[04:03] *** s1n left
[04:08] <dalek> niecza: 1466178 | sorear++ | src/niecza:

[04:08] <dalek> niecza: constant $?FOO must be my-scoped, not our

[04:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/14661780c7

[04:08] <dalek> niecza: ddfc6a3 | sorear++ | src/niecza:

[04:08] <dalek> niecza: Fix &?BLOCK et al

[04:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ddfc6a3610

[04:08] <dalek> niecza: b835604 | sorear++ | t/spectest.data:

[04:08] <dalek> niecza: 3 new passing test files

[04:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b835604cc1

[04:15] *** bkolera joined
[04:30] *** cognominal joined
[04:51] *** Chillance left
[05:00] *** cooper joined
[05:04] *** s1n joined
[05:08] *** benabik left
[05:12] *** kaare_ joined
[05:32] *** thou left
[05:45] *** frew left
[05:48] *** wamba joined
[06:01] *** bkolera left
[06:01] *** bkolera joined
[06:13] *** wamba left
[06:15] *** wamba joined
[06:26] *** cooper left
[06:42] *** molaf joined
[06:47] <pmichaud> rakudo:  my Num $a; $a = 1;

[06:47] <p6eval> rakudo b2bc99: OUTPUT«Type check failed for assignment␤    Container type: Num␤               Got: Int␤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in main program body at line 22:/tmp/bLJLIhbeMh␤»

[06:49] <pmichaud> rakudo:  my Num $a;  $a++;

[06:49] <p6eval> rakudo b2bc99: OUTPUT«Type check failed for assignment␤    Container type: Num␤               Got: Int␤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in main program body at line 1:src/gen/core.pm␤»

[07:06] <dalek> niecza: bdfdf1c | sorear++ | lib/Kernel.cs:

[07:06] <dalek> niecza: After discussion with pmichaud++, allow rw parameters to bind to variables with looser type constraints

[07:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bdfdf1c543

[07:13] *** bakedb joined
[07:13] *** bkolera1 joined
[07:13] *** bkolera left
[07:19] <moritz> pmichaud: what's the correct fix? change src/core/Num.pm line 114 to Num:D ?

[07:19] <pmichaud> master doesn't understand :D yet

[07:20] <moritz> oh, that's master

[07:20] <pmichaud> if you're asking about nom, I have an unpushed fix already committed

[07:20] * pmichaud pushes.

[07:20] <moritz> nom: my Num $x; $x++; say $x

[07:20] <p6eval> nom: OUTPUT«1␤»

[07:20] <moritz> fix for what? :-)

[07:20] <pmichaud> yeah, the previous nom has the undefined handling in the wrong place, I think

[07:20] <pmichaud> pushed.

[07:21] <pmichaud> https://github.com/rakudo/rakudo/commit/1d685b79d6d3c99bcab8afe982bb312c4514a489

[07:21] <pmichaud> handling of undefined increment is part of ++/--, not succ/pred, I think.

[07:21] <pmichaud> rakudo:  say Any.succ

[07:21] <p6eval> rakudo b2bc99: OUTPUT«Method 'succ' not found for invocant of class ''␤  in main program body at line 22:/tmp/y0uD0LDwpI␤»

[07:21] <pmichaud> that's correct.

[07:22] <moritz> niecza: say Any.succ

[07:22] <p6eval> niecza v6-194-gb835604: OUTPUT«1␤»

[07:22] <pmichaud> I believe that's wrong.

[07:22] <moritz> wouldn't surprise me if the spec was silent on that nuance

[07:22] <pmichaud> it's not.

[07:22] <pmichaud> it's pretty clear that it's the increment/decrement that has the magic, at least to my reading.

[07:23] <pmichaud> because it says "increment of an undefined bare value"

[07:23] <pmichaud> as opposed to .succ

[07:23] <pmichaud> niecza: say List.succ

[07:23] <p6eval> niecza v6-194-gb835604: OUTPUT«1␤»

[07:24] <pmichaud> I'm pretty sure that's wrong.  :)

[07:26] <dalek> rakudo/nom: 1d685b7 | pmichaud++ | src/core/ (3 files):

[07:26] <dalek> rakudo/nom: Update ++/-- handling for undefined values.

[07:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1d685b79d6

[07:28] *** geekosaur joined
[07:30] <moritz> should $filehandle.print use .gist too=

[07:30] <moritz> s/\=/?/

[07:30] <pmichaud> not .print

[07:31] <pmichaud> .say, maybe.

[07:31] *** daniel-s joined
[07:31] <pmichaud> .gist is for .say

[07:31] <moritz> huh

[07:31] <pmichaud> say does gisting, print doesn't.

[07:31] <daniel-s> hi

[07:31] <pmichaud> (unless the spec changed again :-)

[07:32] <pmichaud> although the spec doesn't actually mention that :)

[07:32] *** buubot_backup left
[07:33] <pmichaud> say() is basically defined as   sub say(|$args) { print gist(|$args), "\n" }

[07:34] <moritz> pmichaud: is there a reason why print() doesn't unbox_s its arguments?

[07:34] <pmichaud> the one that is there now is basically a "get it working" print

[07:34] <jdhore1> Can I ask a possibly loaded question?

[07:34] *** daniel-s left
[07:34] *** daniel-s joined
[07:35] <moritz> pmichaud: asked differently, should it unbox_s(@list.shift.Stringy) ?

[07:35] <moritz> or is that .Str?

[07:35] <jdhore1> Is nom going to be the last rakudo "start over from scratch"?

[07:35] <pmichaud> jdhore1: how would we know?  ;-)

[07:36] <pmichaud> moritz: not sure which it will end up being, either .String or .Str should work fine for now.  I'd go with .Str, I think.

[07:36] <pmichaud> *.Stringy

[07:36] <jdhore1> pmichaud, Which question was that an answer to?

[07:36] <pmichaud> jdhore1: either or both (but primarily the second)  :-P

[07:36] <pmichaud> jdhore1: do we have another rakudo rewrite planned?  definitely not.

[07:37] <jdhore1> Though I suppose, after/during the former rewrites, was nom "planned"? It'd surprise me.

[07:37] <pmichaud> jdhore1: but I don't know to what extent we expected nom to be a rewrite.  we expected it to be a much less of a rewrite than alpha->ng was  (and that's turned out to be correct thus far)

[07:38] <jdhore1> ah

[07:38] <pmichaud> ng was really a total rewrite.  nom has a lot of rewriting of the p6libs, but the actual compiler itself didn't get a do-over.  We're still using the same grammar and actions as master, for the most part.

[07:39] <jdhore1> ah

[07:40] <jdhore1> nom also seems to be moving significantly faster than most project rewrites which is a good sign :)

[07:40] <pmichaud> yeah

[07:40] <pmichaud> it's not a total rewrite.  mostly the setting is getting a thorough review/rewrite, and it needed it

[07:40] <pmichaud> also, we're doing a lot of "rewriting" of the parts that were previously written in PIR

[07:41] <pmichaud> and we're paying a lot more attention to efficiency issues, in some pain points (like lists/iterators)

[07:41] <moritz> nom: sub f(:$x) { say $x }; f :x

[07:41] <p6eval> nom: OUTPUT«Bool::True␤»

[07:41] <moritz> jnthn++

[07:42] <jdhore1> ah, nice

[07:42] <pmichaud> yes, jnthn++.  after I saw the patch for that one I said "oh, I should've seen that one".

[07:45] <moritz> if we had :nqpop along with :pirop in PAST, we could make the actions much more portable

[07:45] <pmichaud> that's the plan.

[07:45] <pmichaud> just haven't gotten there yet.

[07:45] <pmichaud> ETOOMUCHLHF

[07:47] *** Mowah joined
[07:49] <pmichaud> I keep typing  ?? ||   instead of ?? !! for some reason.

[07:55] <TiMBuS> ive done that so many times

[07:55] <TiMBuS> :/

[07:59] <pmichaud> I think it's because I often start thinking of an or-test, and then switch to using ?? when I decide it's really an if-else

[08:03] <sorear> pmichaud: the spec also talks about magical increment of strings

[08:03] <sorear> however, strings are magical on .succ

[08:03] <sorear> so I took "increment" to mean ".succ" rather than "++"

[08:03] <pmichaud> sorear: that's reasonable

[08:04] <sorear> I agree that the increment spec is badly worded

[08:04] <sorear> if you think there's a good argument for Any.succ dying, I'll go along with that

[08:04] <sorear> but now...sleep

[08:05] <pmichaud> List.succ  is the one I can think of

[08:05] <pmichaud> actually, any type derived from Any that isn't numeric feels like it shouldn't have a magical .succ

[08:08] *** bakedb left
[08:08] *** JimmyZ joined
[08:19] *** x19290 joined
[08:19] <x19290> hello.

[08:20] <x19290> I know this is not the right place, but please let me continue.

[08:20] <tadzik> hello

[08:20] <x19290> hello

[08:20] <x19290> I want to know about good old days (~v3) of Perl.

[08:21] <x19290> Where should I go?

[08:23] <moritz> the perl5 git repo has the old versions

[08:23] <x19290> perl3?

[08:24] <moritz> 1, 2, 3, 4

[08:24] <x19290> oh!

[08:24] <x19290> But what I know is that:

[08:25] <x19290> In old days Perl was a package of GNU. Yes or No?

[08:25] <moritz> what does "a package of GNU" mean?

[08:26] <x19290> perl was downloadable from prep.ai.mit.edu.

[08:26] <moritz> that's merely a mirror location

[08:26] *** buubot_backup joined
[08:27] <x19290> Oh, I misunderstood.

[08:27] <x19290> some Linux people say,

[08:28] <x19290> because "definition of free software" is so strict that perl cannot be packaged in GNU.

[08:28] <pmichaud> http://www.gnu.org/software/perl/perl.html  # fwiw

[08:28] <dalek> rakudo/nom: a1b813c | pmichaud++ | NOMMAP.markdown:

[08:28] <dalek> rakudo/nom: Some NOMMAP updates.

[08:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a1b813c709

[08:28] <dalek> rakudo/nom: a7fa958 | pmichaud++ | src/ (9 files):

[08:28] <dalek> rakudo/nom: Change the argument ordering for perl6_list_from_rpa so that the rpa is always the first argument/operand.

[08:28] <dalek> rakudo/nom: 

[08:28] <dalek> rakudo/nom: Otherwise I keep forgetting the order in which the arguments need to appear

[08:28] <dalek> rakudo/nom: (rpa-first means it matches perl6_iter_from_rpa).  Also update most of src/core

[08:28] <dalek> rakudo/nom: to use nqp::p6list instead of the much longer opcode name.

[08:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a7fa958527

[08:29] <x19290> freedom0 ~ freedom3

[08:30] <x19290> I thought the definition is so simple that it is loose.

[08:30] <x19290> but some linux persons say it's not right.

[08:31] <x19290> I'm a very bad English speaker, sorry.

[08:32] <huf> x19290: perl license is listed as a gpl compatible free software license on gnu.org

[08:32] <huf> x19290: http://www.gnu.org/licenses/license-list.html#GPLCompatibleLicenses

[08:32] <huf> i'd say that settles it

[08:33] <x19290> rms says, for example, X is not a GNU software but it is part of GNU.

[08:33] <x19290> right?

[08:34] * moritz doesn't understand what "GNU software" means

[08:34] <moritz> if it means "part of the linux userland", I agree

[08:34] <tadzik> it's GNU/Linux! :)

[08:35] <x19290> yes.

[08:35] <x19290> GNU software means,

[08:35] <x19290> it is a product of GNU project.

[08:35] <pmichaud> I think fsf uses "GNU package" for that.

[08:36] <x19290> Yes.

[08:36] <x19290> I will use the word "GNU package" from now.

[08:36] <Krunch> Perl has been distributed within GNU/Linux distributions for a long time but AFAIK it has never been a GNU project

[08:36] *** drbean joined
[08:37] <x19290> abount X, same thing can be said.

[08:38] <x19290> Again, rms says, X is not GNU package but X is part of GNU

[08:38] <x19290> GNU operating system, his ideal OS.

[08:39] <x19290> Abount TeX, same thing can be said.

[08:40] <x19290> Why not Perl?

[08:40] * moritz thinks the discussion is kinda pointless

[08:40] <moritz> you can say whatever you want about any software

[08:40] <moritz> and if you want to discuss GNU naming conventions, the FSF would be better than the perl people

[08:41] <x19290> I'm very sorry.

[08:42] <x19290> I was not in the right place.

[08:43] <x19290> I have not been in the right place.

[08:43] <x19290> bye.

[08:43] <moritz> nom: say gist("foo", "bar")

[08:43] <p6eval> nom: OUTPUT«foo bar␤»

[08:44] <moritz> pmichaud: I'm trying to IO.say, and I don't know what exactly to .gist

[08:44] *** sjn left
[08:44] <moritz> method say(*@list) { self.print(@list.map({ .gist}).join) } 

[08:44] *** sjn joined
[08:44] <pmichaud> can't be *@list because that will flatten.

[08:45] <pmichaud> say needs to accept a Parcel/Capture and .gist that

[08:46] <moritz> trouble is, I can't use the |$ thing easily that the say() sub uses

[08:46] <moritz> because that includes the invocant

[08:46] <pmichaud> shift the invocant

[08:46] <pmichaud> method say(|$) {

[08:46] <pmichaud>     my Mu $args := pir::perl6_current_args_rpa__P();

[08:46] <pmichaud>     nqp::shift($args);

[08:46] <pmichaud>     # now you can use $args

[08:47] <pmichaud> jnthn++ and I agreed that this would be the canonical way to handle it for now :)

[08:50] <daniel-s> does IO::Socket::INET work in perl6 the same way as it does in perl 5?

[08:50] <tadzik> I don't think so

[08:51] <daniel-s> http://pastebin.com/fhbTh0RU

[08:51] <daniel-s> line 7 doesn't seem to be working correctly

[08:51] <daniel-s> no sever responds to whatever I send it

[08:52] <huf> that's not a proper http request at all 

[08:52] <daniel-s> if I telnet to google.com on port 80, it seems to be enough to get it to spit heaps of HTML back

[08:52] <huf> dont you also press enter twice?

[08:53] <huf> or at least once

[08:54] <daniel-s> :(

[08:54] <daniel-s> thanks huf

[08:54] <tadzik> daniel-s: $socket.send("GET /\r\n\r\n"); works fine here

[08:54] <huf> daniel-s: read up on http

[08:54] <daniel-s> yea, no \r\n fixed it

[08:56] <daniel-s> I mean, putting \r\n fixed it

[08:59] *** Katibe joined
[09:04] <dalek> rakudo/nom: 4923896 | pmichaud++ | / (2 files):

[09:04] <dalek> rakudo/nom: Re-enable list (Parcel) assignment, although my() declarations still have a bug.

[09:04] <dalek> rakudo/nom: Add a LHF for Nil scalar assignment.

[09:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/492389692b

[09:04] <dalek> rakudo/nom: 29d34b5 | pmichaud++ | NOMMAP.markdown:

[09:04] <dalek> rakudo/nom: Add "my ($a, $b)" to NOMMAP todo list.

[09:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/29d34b5642

[09:06] *** x19290 left
[09:11] *** Su-Shee_ is now known as Su-Shee

[09:14] *** araujo left
[09:29] *** daniel-s left
[09:31] *** nymacro joined
[09:38] *** Tedd1 left
[09:47] *** bakedb joined
[09:51] <dalek> rakudo/nom: e99c15d | moritz++ | src/core/IO.pm:

[09:51] <dalek> rakudo/nom: IO.say and .print

[09:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e99c15d1d7

[09:51] <dalek> rakudo/nom: e91f49f | moritz++ | src/core/IO.pm:

[09:51] <dalek> rakudo/nom: open("-", :w) opens STDOUT

[09:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e91f49f148

[09:51] <dalek> rakudo/nom: ffb46dc | pmichaud++ | src/core/Str.pm:

[09:51] <dalek> rakudo/nom: Add Str.pred and Str.succ (the magical forms).

[09:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ffb46dcfc0

[09:51] <dalek> rakudo/nom: 6fd1046 | pmichaud++ | src/core/IO.pm:

[09:51] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[09:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6fd1046ee0

[09:53] <moritz> nom: my $*IN;

[09:53] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[09:54] <pmichaud> I don't think we have dynamic vars yet

[09:54] <moritz> that's right

[09:54] <pmichaud> I can put that on my lhf for today :)

[09:54] <moritz> my plans for $*IN/$*OUT world domination are srsly blocked :-)

[09:55] <pmichaud> can we assign to namespaces yet?

[09:55] * moritz has no idea

[09:56] <pmichaud> "our scoped variables not yet implemented..."

[09:56] <dalek> rakudo/nom: bd5e60e | moritz++ | NOMMAP.markdown:

[09:56] <dalek> rakudo/nom: add dynamic variable to NOMMAP

[09:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd5e60e801

[09:58] <moritz> pmichaud: when you added IO to the LHF file, what did you have in mind?

[09:58] <pmichaud> ummmmm

[09:58] <moritz> I've done IO.{open,print,say,close} now

[09:59] <pmichaud> I didn't put IO in LHF

[09:59] <pmichaud> looks like jnthn++ did that 

[09:59] <moritz> oh :-)

[09:59] <pmichaud> I'd think IO open/print/say/close/get/lines  would be a good start

[09:59] <pmichaud> maybe the file test operators could be worked on... not sure how LHF that would be

[10:00] <moritz> ah yes, lines() is also done (though not yet $limit yet)

[10:01] *** MayDaniel joined
[10:03] <pmichaud> even if 'our' declarations don't work -- just being able to get to packages via the package or hash interface would be useful

[10:03] <pmichaud> e.g.  $PROCESS::IN =    or PROCES::<$IN> = ...

[10:03] <pmichaud> don't know what jnthn has in mind for package namespaces there yet.

[10:04] * pmichaud pokes around source code a bit.

[10:08] *** MayDaniel left
[10:08] <moritz> nom: say $Inf

[10:08] <p6eval> nom: OUTPUT«Inf␤»

[10:09] <moritz> nom: say 1 < $Inf

[10:09] <p6eval> nom: OUTPUT«Bool::True␤»

[10:10] <pmichaud> nom:  say 1e0 < $Inf

[10:10] <p6eval> nom: OUTPUT«Bool::True␤»

[10:10] <pmichaud> weird.

[10:10] <pmichaud> nom:  say $Inf.WHAT

[10:10] <p6eval> nom: OUTPUT«Num()␤»

[10:10] <pmichaud> nom:  pir::say(nqp::unbox_n($Inf))

[10:10] <p6eval> nom: OUTPUT«Inf␤»

[10:11] <pmichaud> nom:  pir::say(nqp::islt_n(1, nqp::unbox_n($Inf)))

[10:11] <p6eval> nom: OUTPUT«1␤»

[10:11] <pmichaud> oh, I guess that's all right.  I definitely need sleep.

[10:12] <moritz> nom: say $Inf.Int

[10:12] <p6eval> nom: OUTPUT«-9223372036854775808␤»

[10:12] <pmichaud> rakudo:  say Inf.Int  # checking

[10:12] <p6eval> rakudo b2bc99: OUTPUT«-9223372036854775808␤»

[10:13] <pmichaud> I don't mind it doing that too much... but I wish it was at least positive.

[10:14] <pmichaud> for 32-bits I think that Inf.Int used to give MAXINT

[10:14] *** daniel-s joined
[10:17] <dalek> rakudo/nom: 77be43f | moritz++ | src/core/IO.pm:

[10:17] <dalek> rakudo/nom: add $limit to IO.lines

[10:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/77be43fcb8

[10:20] *** bkolera1 left
[10:23] *** Trashlord left
[10:24] *** nymacro left
[10:28] <gfldex> nom: say $Inf.WHAT;

[10:28] <p6eval> nom: OUTPUT«Num()␤»

[10:30] <gfldex> nom: say Inf.WHAT;

[10:30] <p6eval> nom: OUTPUT«Num()␤»

[10:30] <gfldex> nom: say $Inf === Inf;

[10:30] <p6eval> nom: OUTPUT«Could not find sub &infix:<===>␤current instr.: '_block1002' pc 82 ((file unknown):70) (:1)␤»

[10:31] <felher> morning folks. Can one instantiate class B if B does role A but A has stub-method m() { ... } and B does not override that method? Does that fail by instantiation or only if one calls $b.m() and executes the stub?

[10:39] <pmichaud> afk # nap

[10:41] <gfldex> felher: since one could define m at runtime the compiler can only warn and even that is questionable

[10:41] <gfldex> unless you use :final or :closed

[10:42] <gfldex> moritz: re: https://github.com/rakudo/rakudo/commit/77be43fcb8 are you sure you want $Inf and not Inf?

[10:43] <felher> gfldex: I see. Big thnx. :)

[10:43] <dalek> rakudo/nom: 703dd98 | pmichaud++ | / (3 files):

[10:43] <dalek> rakudo/nom: Dynamic vars -- stub in dynamic variable lookups.

[10:43] <dalek> rakudo/nom: 

[10:43] <dalek> rakudo/nom: This only handles the lookup portion of dynvars; as yet dynamic

[10:43] <dalek> rakudo/nom: variable declarations (my $*abc) don't work and afaik there's not

[10:43] <dalek> rakudo/nom: a way to create package-scoped variables (e.g. in PROCESS).

[10:43] <dalek> rakudo/nom: But the stub code is here anyway.   (Use pir::say($*AUTOPRINTPOS)

[10:43] <dalek> rakudo/nom: in interactive mode to see that dynvars are actually searching the

[10:43] <dalek> rakudo/nom: dynamic context. :-)

[10:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/703dd98bff

[10:43] <dalek> rakudo/nom: 8703efe | pmichaud++ | src/core/IO.pm:

[10:43] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[10:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8703efe0a4

[10:49] <moritz> gfldex: Inf doesn't work in the setting (yet?)

[10:49] *** woosley joined
[10:50] <gfldex> i c

[10:58] *** cognominal left
[11:00] <daniel-s> in the perl book, is there something I can put so that two lines don't seperate across page?

[11:03] <moritz> no, don't worry about typography for now

[11:04] *** karupanerura joined
[11:05] *** Trashlord joined
[11:08] *** mberends joined
[11:12] *** cognominal joined
[11:12] *** cognominal left
[11:13] *** Moukeddar joined
[11:20] *** Holy_Cow joined
[11:20] *** Holy_Cow left
[11:33] *** awoodland left
[11:49] *** donri joined
[11:53] *** mikehh joined
[11:58] *** buubot_backup left
[12:01] *** kfo_ joined
[12:04] *** kfo left
[12:11] *** orafu left
[12:13] *** orafu joined
[12:16] *** araujo joined
[12:18] <jnthn> afternoon, #perl6

[12:18] * jnthn sees pmichaud++ and moritz++ have been a-patchin'.

[12:21] <jnthn> nom: my $*abc

[12:21] <p6eval> nom: OUTPUT«Method 'scope' not found for invocant of class 'PAST;Op'␤current instr.: 'nqp;Perl6;Actions;_block1142' pc 11817 (src/gen/perl6-actions.pir:3411)␤»

[12:23] *** envi joined
[12:23] <jnthn> nom: my ($a, $b, $c)

[12:23] <p6eval> nom: OUTPUT«Method 'get_declarations' not found for invocant of class 'ResizablePMCArray'␤current instr.: 'nqp;Perl6;Actions;_block2357' pc 42045 (src/gen/perl6-actions.pir:14457)␤»

[12:23] <jnthn> aha

[12:35] *** buubot_backup joined
[12:41] <daniel-s> if somebody wouldn't mind answering for me:

[12:41] <daniel-s> http://pastebin.com/HazLn1tf

[12:41] <daniel-s> why is line 29 not say anything?

[12:41] <daniel-s> *does

[12:42] <daniel-s> I expected it to have caught 'http' 'foo' and 'bar'

[12:44] *** jt_ joined
[12:47] *** woosley left
[12:47] <daniel-s> I think I got it, the round brackets!

[13:02] <daniel-s> perl6: say hex(0xff);

[13:02] <p6eval> pugs: OUTPUT«*** No such subroutine: "&hex"␤    at /tmp/f0dGHbkyp8 line 1, column 5-14␤»

[13:02] <p6eval> ..rakudo b2bc99: OUTPUT«Could not find sub &hex␤  in main program body at line 22:/tmp/mGQtDj9Tro␤»

[13:02] <p6eval> ..niecza v6-195-gbdfdf1c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'hex' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1133 (STD P6.comp_unit @ 30) ␤  …

[13:02] <daniel-s> perl6: say hex("0xff");

[13:02] <p6eval> rakudo b2bc99: OUTPUT«Could not find sub &hex␤  in main program body at line 22:/tmp/D6GJoZuZ_b␤»

[13:02] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&hex"␤    at /tmp/ikvjjYoWSx line 1, column 5-16␤»

[13:02] <p6eval> ..niecza v6-195-gbdfdf1c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'hex' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1133 (STD P6.comp_unit @ 30) ␤  …

[13:04] <daniel-s> perl 5 has a hex function

[13:04] <daniel-s> is there an equivalent in perl6?

[13:05] <flussence> rakudo: say :16('1fc')

[13:05] <p6eval> rakudo b2bc99: OUTPUT«508␤»

[13:08] <daniel-s> flussence++ :)

[13:08] <flussence> also works for 2, 8 and 10 IIRC

[13:08] <daniel-s> rakudo: say :10('100');

[13:08] <p6eval> rakudo b2bc99: OUTPUT«100␤»

[13:09] <daniel-s> rakudo: say :10('0xff');

[13:09] <p6eval> rakudo b2bc99: OUTPUT«255␤»

[13:09] <daniel-s> rakudo: say :16('ff');

[13:09] <p6eval> rakudo b2bc99: OUTPUT«255␤»

[13:09] <daniel-s> rakudo: say :10('ff');

[13:09] <JimmyZ> rakudo: say :2('100');

[13:09] <p6eval> rakudo b2bc99: OUTPUT«Invalid character (F)! Please try again :) ␤  in main program body at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[13:09] <p6eval> rakudo b2bc99: OUTPUT«4␤»

[13:10] <flussence> rakudo: say '0xFF'.Int

[13:10] <p6eval> rakudo b2bc99: OUTPUT«255␤»

[13:10] <flussence> :\d+ is just an alternative to having a radix prefix in the string itself

[13:23] <jnthn> ooh, masak++ live at FPW! http://cite-sciences.ubicast.eu/lives/thd-live/

[13:36] *** karupas joined
[13:36] *** karupanerura left
[13:37] *** nebuchadnezzar joined
[13:37] *** jt_ left
[13:44] *** fhelmberger joined
[13:53] *** MayDaniel joined
[14:01] <sjn> rakudo: sub foo(Int :$n = 1) { say $n }; foo()

[14:01] <p6eval> rakudo b2bc99: OUTPUT«1␤»

[14:01] <sjn> rakudo: sub foo(Int :$n = 1) { say $n }; foo(23)

[14:01] <p6eval> rakudo b2bc99: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in 'foo' at line 1:/tmp/04D3ScUIjo␤  in main program body at line 22:/tmp/04D3ScUIjo␤»

[14:05] <jnthn> sjn: Did you really want the colon there?

[14:05] * sjn doesn't know

[14:05] <jnthn> :)

[14:06] <jnthn> rakudo: sub foo(Int $n = 1) { say $n }; foo(23)

[14:06] <p6eval> rakudo b2bc99: OUTPUT«23␤»

[14:06] <jnthn> rakudo: sub foo(Int $n = 1) { say $n }; foo()

[14:06] <p6eval> rakudo b2bc99: OUTPUT«1␤»

[14:06] <jnthn> : makes it a named param

[14:06] <sjn> mm

[14:07] <sjn> this is what I have: sub MAIN(Str $prefix, Str $suffix, Int $maxchars=12) { ... }

[14:08] <mikemol> I'll cast a vote in favor of divmod. At least a couple times a month, I find myself needing to do / and % in my day-job stuff (which, sadly, involves no Perl6). Most recent cast: "Ok, with a chunk size of X, how many chunks will I get out of this many bytes, and how many bytes will I have left over?

[14:08] <sjn> I want $maxchars to show up in the usage text as [--maxchars=something]

[14:08] <sjn> well, I expected it to :-P

[14:08] <sjn> that's how I put in the :

[14:09] <pmichaud> good morning, #perl6

[14:09] <sjn> o/

[14:12] <daniel-s> rakudo: my %stuff = (one => "1", two => "2"); for %stuff {say .key; say .values};

[14:12] <p6eval> rakudo b2bc99: OUTPUT«one␤1␤two␤2␤»

[14:13] <daniel-s> rakudo: my %stuff = (one => "1", two => "2"); for %stuff {say .keys; say .value};

[14:13] <p6eval> rakudo b2bc99: OUTPUT«one␤1␤two␤2␤»

[14:13] <daniel-s> is there no difference between singular .key and plural .keys

[14:14] <pmichaud> for Pair objects, no

[14:14] <daniel-s> is there a way to confirm what the key is

[14:14] <jnthn> o/ pmichaud 

[14:14] <daniel-s> if .key == "one" doesn't work

[14:14] <pmichaud> well, that's a numeric comparison

[14:15] <pmichaud> I think you meant   if .key eq 'one' 

[14:15] <pmichaud> jnthn++ # very nice work yesterday

[14:15] <daniel-s> oh yea, thanks

[14:16] <pmichaud> oh, the other difference is likely that .key is an item while .keys is a list

[14:16] <jnthn> pmichaud: :)

[14:16] <jnthn> pmichaud: Looking over your latest nommap additions.

[14:16] <pmichaud> rakudo:  my %stuff = <one 1 two 2 >;  for %stuff { say .key.WHAT; say .keys.WHAT }

[14:16] <p6eval> rakudo b2bc99: OUTPUT«Str()␤Array()␤Str()␤Array()␤»

[14:17] <pmichaud> jnthn: I suspected (and hoped) that you would :)

[14:28] *** jimmy1980 left
[14:34] *** jimmy1980 joined
[14:36] *** Moukeddar_ joined
[14:36] *** Moukeddar left
[14:38] *** Moukeddar_ left
[14:38] *** Chillance joined
[14:42] <TimToady> ooh, maybe divmod should be a listop: my ($sec, $min, $hr, $days) = divmod $num, 60, 60, 24

[14:43] <TimToady> thought maybe that should be called moddiv :)

[14:43] <TimToady> or modmod

[14:44] <flussence> div-and-show-your-working would still make that line shorter than how I'm used to doing it :)

[14:45] <TimToady> I suppose people would recognize the divmod concept, though returning the results in the "other" order is a problem

[14:45] <flussence> Rdivmod?

[14:46] <flussence> oh wait, that's for *input* bits

[14:46] <TimToady> the problem is if someone writes ($quo,$rem) = divmod $big, $little

[14:47] <TimToady> when you're really wanting to pulling a series of mods out, followed by the final quotient

[14:47] <TimToady> the right side has to be that order so you can write divmod $n, 60 xx *

[14:48] <TimToady> or divmod $n, 1000 xx *

[14:49] <TimToady> but it's the result that will surprise people used to traditional divmod

[14:50] <TimToady> so we should probably call it something else, modmod or some such

[14:50] *** Mowah left
[14:53] <TimToady> there's probably some higher-order functional pattern I'm missing here in my pre-caf state, but it seems more complicated the the usual op vs [op]

[14:53] <TimToady> since primitive divmod returns two results

[14:54] <JimmyZ> contiguous div ?

[14:57] <pmichaud> nom: say '⚀' ...^ { $_.chars > 2 }    # I never tire of this :-)

[14:57] <p6eval> nom: OUTPUT«⚀ ⚁ ⚂ ⚃ ⚄ ⚅ ⚀⚀ ⚀⚁ ⚀⚂ ⚀⚃ ⚀⚄ ⚀⚅ ⚁⚀ ⚁⚁ ⚁⚂ ⚁⚃ ⚁⚄ ⚁⚅ ⚂⚀ ⚂⚁ ⚂⚂ ⚂⚃ ⚂⚄ ⚂⚅ ⚃⚀ ⚃⚁ ⚃⚂ ⚃⚃ ⚃⚄ ⚃⚅ ⚄⚀ ⚄⚁ ⚄⚂ ⚄⚃ ⚄⚄ ⚄⚅ ⚅⚀ ⚅⚁ ⚅⚂ ⚅⚃ ⚅⚄ ⚅⚅␤»…

[15:00] <TimToady> well, in this case '⚀' ... '⚅⚅' would be rather more readable, methinks

[15:01] <TimToady> nom: say '⚀'...'⚅⚅'

[15:01] <p6eval> nom: OUTPUT«⚀ ⚁ ⚂ ⚃ ⚄ ⚅ ⚀⚀ ⚀⚁ ⚀⚂ ⚀⚃ ⚀⚄ ⚀⚅ ⚁⚀ ⚁⚁ ⚁⚂ ⚁⚃ ⚁⚄ ⚁⚅ ⚂⚀ ⚂⚁ ⚂⚂ ⚂⚃ ⚂⚄ ⚂⚅ ⚃⚀ ⚃⚁ ⚃⚂ ⚃⚃ ⚃⚄ ⚃⚅ ⚄⚀ ⚄⚁ ⚄⚂ ⚄⚃ ⚄⚄ ⚄⚅ ⚅⚀ ⚅⚁ ⚅⚂ ⚅⚃ ⚅⚄ ⚅⚅␤»…

[15:01] *** MayDaniel left
[15:01] <pmichaud> sure, but then I'd have to type '⚅⚅' (or copy/paste it from somewhere like I just did here :)

[15:01] <TimToady> nom: say 1..3

[15:01] <p6eval> nom: OUTPUT«1..3␤»

[15:01] <TimToady> nom: say 1...3

[15:01] <p6eval> nom: OUTPUT«1 2 3␤»

[15:02] <TimToady> nom: say (1,2,3)

[15:02] <p6eval> nom: OUTPUT«123␤»

[15:02] <TimToady> ^^ buglet?

[15:02] <pmichaud> I don't know

[15:02] <pmichaud> 1...3 produces a list... (1,2,3) is a Parcel

[15:02] <pmichaud> currently gist treats them differently

[15:02] <pmichaud> should they be the same?  should parcels join with spaces?

[15:03] <TimToady> probably, since it's not a list context really

[15:03] <pmichaud> that would mean that    say 1,2,3   would also have spaces

[15:03] <pmichaud> well, it doesn't have to mean it in that case

[15:03] <pmichaud> I guess we could distinguish between Parcel and arglist

[15:03] <TimToady> you don't .gist the whole parcel

[15:04] <TimToady> say's whole parcel

[15:04] <pmichaud> .gist each element of the capture, then?

[15:04] <TimToady> just its bits

[15:04] <pmichaud> okay.  the spec is a little weak on say + gist atm  :)

[15:04] <pmichaud> fixing

[15:06] <pmichaud> what about   gist 1,2,3   ?

[15:06] <pmichaud> spaces or no?

[15:06] * pmichaud guesses no.

[15:07] <TimToady> I'd been thinking of that as say without the "\n"

[15:07] <pmichaud> right... and "gist" simply returns the string, as opposed to doing any sort of output?

[15:08] <TimToady> yeah, though one could argue it the other way I suppose

[15:08] <TimToady> but this is how I thought of it first, so it must be right :)

[15:09] <pmichaud> I've been working from the hypothesis that  say is defined as    sub say(|$args) { print gist(|$args), "\n" }   or something close to that.  This would fit that.

[15:10] <TimToady> It's a bit of a disconnect form (1,2,3).gist I guess

[15:10] <TimToady> *from

[15:10] <TimToady> but we always have that disconnect

[15:10] <TimToady> well, sometimes

[15:11] <TimToady> I guess we've flattened the diconnect on map etc.

[15:11] <TimToady> *dis

[15:11] <pmichaud> yes, now that map is .flat a lot of disconnects seem to have gone away

[15:11] <pmichaud> it definitely feels cleaner than before from an implementation perspective

[15:12] *** masak joined
[15:12] <TimToady> well, what if we said that gist listop is like .gist, then we could use gist 1,2,3  to put spaces, arguably a feature

[15:12] <masak> oh lol hai talks done

[15:12] <masak> (and went well, I think)

[15:12] <TimToady> and say would then iterate its args and .gist each one

[15:12] <masak> also, I've cracked BooK's recursion problem :) https://gist.github.com/1045125

[15:13] <masak> and written slides for a lightning talk about it.

[15:13] <pmichaud> TimToady: I can certainly do it that way as well.

[15:13] <TimToady> and then gist and .gist would work similarly

[15:13] <jnthn> masak: yay :)

[15:13] <pmichaud> say and print would have more of a disconnect... but that's probably okay.

[15:13] <masak> jnthn: check it out; the mutual recursion is quite nice.

[15:13] <pmichaud> say 1,2,3;   not same as   print gist 1,2,3;

[15:14] <pmichaud> masak: o/

[15:14] <jnthn> masak: najs!

[15:14] <masak> jnthn: I can easily sympathise with gregyoung who said he didn't want to debug his eight mutually recursive methods. debugging two was mind-bending enough :P

[15:15] <masak> it was all "wait... so the actual thing happens where exactly?" :)

[15:15] <masak> (turns out the actual thing happened in the base case)

[15:16] <masak> pmichaud: you did get a few mentions in my first talk ;)

[15:17] <pmichaud> masak: should I be worried?  ;-) ;-)

[15:17] <masak> pmichaud: I quoted the IRC logs where you said that I usually embarrass you in some way or other :P

[15:17] <pmichaud> (no, I'm not, even if you say I should be)

[15:17] <pmichaud> lol

[15:17] <pmichaud> I can handle that.  :)

[15:17] <masak> thought you might like that :P

[15:17] <pmichaud> I can't wait to see the video of the talk

[15:17] <masak> the corner of that slide says "(how meta)"

[15:18] <pmichaud> are slides online?

[15:18] <masak> no, but at first opportunity.

[15:18] <masak> might even do that now, in fact.

[15:18] * masak does it

[15:19] <masak> nope, it appears I don't have FTP on this wifi net.

[15:22] <TimToady> lets make gist work like .gist, and say is print $args».gist, "\n"   # note the hyper

[15:22] <pmichaud> that's what I just did :)

[15:22] <pmichaud> testing

[15:23] <TimToady> otoh, if we used map *.gist we could output say's args lazily, which might be an advantage if they are infinitudinous

[15:24] <TimToady> or maybe it doesn't matter

[15:24] <pmichaud> ..except map flattens.

[15:24] <TimToady> right

[15:25] <TimToady> we need an infix "call" operator :)

[15:25] <masak> jnthn: I'm happy to report that your talk still works very well. I still think it's the most effective talk ever made for making people interested in Perl 6.

[15:25] <masak> jnthn++

[15:25] *** zby_home__ joined
[15:26] <masak> a good example of "keep to the specifics, and let people generalize".

[15:26] *** zby_home_ left
[15:26] <jnthn> masak: Yeah, I think it's all too easy to get lost in awesome abstract possibilities, and leave people awed but equally unable to see where to start.

[15:27] <masak> aye.

[15:27] <TimToady> that's one of the nice things about RC too

[15:27] <masak> I did a talk here last year -- in the same room, in fact -- which fell into exactly that trap.

[15:27] * jnthn wonders what masak said about *him* in his first talk :)

[15:28] <masak> jnthn: in the first talk? just that you have been working on 6model and are now driving the nom branch to completion.

[15:28] <masak> jnthn: in the second talk I pointed out that many of your examples were about alcohol... :P

[15:28] <pmichaud> TimToady: http://gist.github.com/1046587

[15:29] <pmichaud> (hey look!  a gist about gist!)

[15:31] <jnthn> masak: They are? :P

[15:31] <jnthn> masak: I...wonder how that coulda happened :P

[15:31] <TimToady> I'd tell you that's cool but it says that comments aren't allowed on anonymous gists...

[15:31] *** wamba left
[15:31] <pmichaud> nom:   say (1,2,3).gist ~~ Cool;   # nom thinks .gist is Cool also  :-)

[15:31] <p6eval> nom: OUTPUT«Bool::True␤»

[15:31] <masak> jnthn: yes. the class is called "Product", but the attribute values make it very clear what kind of product we're talking about :P

[15:32] <TimToady> nom: say gist Cool

[15:32] <p6eval> nom: OUTPUT«Cool()␤»

[15:32] * masak .oO( "klockan Product" )

[15:32] <pmichaud> evalbot rebuild nom

[15:32] <p6eval> OK (started asyncronously)

[15:32] <pmichaud> oops, forgot to push

[15:32] <masak> p6eval++

[15:32] <pmichaud> oh, wait, I pushed.  should rebuild shortly.

[15:33] <pmichaud> nom:   say (1,2,3).gist ~~ Cool;   # nom thinks .gist is Cool also  :-)

[15:33] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[15:33] <pmichaud> sorear++

[15:33] <moritz> pmichaud: you could configure the rakudo repo to use push mode for dalek

[15:33] <TimToady> you should borrow the 'make snap' semantics from some other makefile

[15:33] <masak> nom: what's in progress?

[15:33] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[15:33] <moritz> pmichaud: see misc/dalek-push.txt in mu repo

[15:33] <TimToady> then you can keep running while it's in progress

[15:33] <pmichaud> looking

[15:34] <moritz> TimToady: nom isn't installable yet, I fear

[15:34] *** whiteknight joined
[15:34] <TimToady> nor was STD, but it used 'make snap' I believe

[15:34] <pmichaud> nom *can* be installable, though.  that shouldn't be all that hard.

[15:34] <dalek> rakudo/nom: 0cde9b8 | pmichaud++ | src/core/ (2 files):

[15:34] <dalek> rakudo/nom: Update gist/.gist/say with latest specifics from TimToady++.

[15:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0cde9b8a47

[15:35] *** tokuhirom joined
[15:35] <tadzik> pmichaud: I tried that, it has some tricky bits

[15:35] <tadzik> one of the files depends on ./Something.pbc. When you remove the ./ part, it works when installed, but stops working when not installed

[15:36] <TimToady> anyway, point is you can build in a subdir and then do a dir rename to "commit" the transaction

[15:36] *** rhr joined
[15:36] <pmichaud> is 'make install' sufficient to "build in a subdir and dir rename'?

[15:36] <pmichaud> (for snap semantics)

[15:36] <pmichaud> the subsequent make shouldn't affect install until the next make install takes place

[15:37] <TimToady> well, make install doesn't usually do a dir rename, but copies several files into the install dir

[15:37] <moritz> pmichaud: 'make install' was sufficient for rakudo master

[15:37] <TimToady> but might be close enough

[15:37] <pmichaud> 'make install' just puts a copy of the latest rakudo (and all of its runtime files) into another dir :-)

[15:37] <TimToady> it's a very small race condition

[15:37] <pmichaud> yes, it is.

[15:37] <TimToady> and the stakes are low here :)

[15:38] <TimToady> if this were mission critical I'd insist on a directory rename :)

[15:38] <pmichaud> anyway, I'll fix up "make install"

[15:38] <moritz> pmichaud: in fact I could even use the same trick that I use for rakudo master: have two separate directories, and when the rebuild in one is finished, switch over to the other by changing a symlink

[15:38] <moritz> rakudo: say get

[15:38] <p6eval> rakudo b2bc99: OUTPUT«Land der Berge, Land am Strome,␤»

[15:38] <TimToady> a symlink redirect is also pretty snappy

[15:38] <pmichaud> moritz: that works for me also, if you prefer to do that

[15:39] * TimToady still thinks like an old Unix guy, pre symlink...

[15:39] <moritz> pmichaud: I prefer a working 'make install' over no working 'make install' any time :-)

[15:39] <masak> it's nice to see you reimplementing transactions. :)

[15:39] <pmichaud> I'm still going to update 'make install'

[15:39] <pmichaud> masak: why not, we're reimplementing everything else.

[15:39] <pmichaud> now all we need is a good wheel to reimplement :)

[15:40] <masak> a killer app wheel.

[15:42] *** daniel-s left
[15:45] <dalek> rakudo/nom: d2095a0 | jnthn++ | src/Perl6/ (2 files):

[15:45] <dalek> rakudo/nom: Get my ($a, $b) style declarations to work.

[15:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2095a0a64

[15:45] <dalek> rakudo/nom: 8579dcc | jnthn++ | src/Perl6/Actions.pm:

[15:45] <dalek> rakudo/nom: Unbust declaration of dynamics.

[15:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8579dcc3d8

[15:45] <dalek> rakudo/nom: 1e1fab5 | jnthn++ | NOMMAP.markdown:

[15:45] <dalek> rakudo/nom: Update nommap.

[15:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1e1fab5269

[15:54] <dalek> specs: 0a75c8b | larry++ | S29-functions.pod:

[15:54] <dalek> specs: document gist better

[15:54] <dalek> specs: review: https://github.com/perl6/specs/commit/0a75c8b205

[15:54] <moritz> what's the correct way to pass one functions argument on to another in nom?

[15:54] <pmichaud> argument?  or argument list?

[15:54] <moritz> ie I want to make say() a shortcut for $*OUT.say

[15:54] <moritz> argument list

[15:54] <pmichaud> the standard would be to use |$args -- I don't think that works quite yet.

[15:54] <moritz> or capture, for that matter :-)

[15:56] <pmichaud> easier for now is simply copy the code for say() into method say()

[15:56] <pmichaud> it's only 3-4 lines long, so live with the duplicate until we have captures in place

[15:56] <jnthn> |@pos and |%nameds

[15:56] <jnthn> both now work

[15:56] <tadzik> oh, so .gist is the new .pretty

[15:57] <masak> and .pretty is dead?

[15:57] <jnthn> So you can always do it that way for now too.

[15:57] <tadzik> masak: there is no .pretty I know of

[15:57] <pmichaud> jnthn: yes, but does   sub xyz(|$args) { ... }   work to put a capture into $args ?

[15:57] <pmichaud> S02 talks about ".pretty"

[15:57] <tadzik> ah, pun ruined

[15:57] <TimToady> there can be a .pretty too, since I don't think .gist worries much about indentation

[15:58] <moritz> pmichaud: it's not about code reuse, it's about making say() act on $*OUT, so that you can redefine it

[15:58] <pmichaud> moritz: ah

[15:58] <pmichaud> moritz: just a sec

[15:59] <pmichaud> (writing code snippet)

[16:00] <jnthn> pmichaud: Not yet.

[16:00] <pmichaud> moritz: http://gist.github.com/1046615  # maybe this

[16:00] *** rokoteko left
[16:01] <pmichaud> I'll have to think about 'make install' a bit more -- it involves getting @INC to work right.

[16:02] <moritz> pmichaud: thanks, will try

[16:02] <pmichaud> and/or getting a proper factoring for module loading between nom/nqp

[16:04] <pmichaud> jnthn: PROCESS fallback is already implemented -- we just need to be able to store things into the PROCESS package :)

[16:04] <jnthn> pmichaud: Yeah, I knowz :)

[16:04] <pmichaud> okay, the nommap makes it sound like there's more to be done there

[16:04] <jnthn> pmichaud: Just need to implement our-scoped variables and stuff. :)

[16:05] <pmichaud> even being able to do  PROCESS::{...} would be helpful :-)

[16:05] <pmichaud> (and shouldn't require "our")

[16:05] <TimToady> Real Globals™

[16:06] *** estrabd left
[16:06] <TimToady> actually, http:// and friends are the only real globals

[16:07] <pmichaud> surprisingly, realglobals.com is available :)

[16:07] <moritz> on my machine, http://127.0.0.1/ shows a different page than on yours

[16:07] <TimToady> ooh, sounds like a .com business plan

[16:08] <moritz> so much for "Real Globals" :-)

[16:08] <TimToady> none of this mushy cloud stuff for us

[16:08] <jnthn> pmichaud: Just making Stash subclass Hash at the moment

[16:08] <jnthn> pmichaud: ah, yay

[16:08] <jnthn> > module Foo { our sub bar { say 100 } }; Foo.WHO<&bar>()

[16:08] <jnthn> 100

[16:08] <pmichaud> yes.  everyone remember this time to get out of the tech bubble before it bursts :-)

[16:08] <TimToady> one could argue that github is a Real Globals site

[16:09] <jnthn> and

[16:09] <jnthn> > module Foo { }; Foo.WHO<$OUT> = 42; say $Foo::OUT

[16:09] <jnthn> 42

[16:09] <pmichaud> \o/

[16:10] <pmichaud> now we can start to put back $*IN, $*OUT, %*ENV, @*INC, etc.

[16:11] <jnthn> Feels good that Stash isa Hash :)

[16:11] <pmichaud> that's the way it should be :)

[16:11] <jnthn> Though we've well and truely tied ourselves up with circularity sticky tape now :)

[16:11] <dalek> rakudo/nom: 2301d8c | jnthn++ | src/Perl6/Metamodel/ (2 files):

[16:11] <dalek> rakudo/nom: Make it so Stash ~~ Hash, so we can introspect and install stuff into it from Perl 6 land.

[16:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2301d8cab1

[16:11] <pmichaud> jnthn: well, we couldn't delay those bindings too much longer :)

[16:11] *** karupanerura joined
[16:11] <TimToady> Ducts are often circular...

[16:11] <jnthn> :P

[16:11] <TimToady> Ducks are sorta oval...

[16:12] <pmichaud> Ducks lay oval-shaped eggs  (or is that egg-shaped ovals?)

[16:12] <jnthn> I suspect that we'll always need something at the start of the setting that pieces things together. I just hope that we can shove it in a BEGIN at some point and have it all get serialized.

[16:12] <TimToady> isn't that what they make Ovaltine out of?

[16:13] <TimToady> we could rename BEGIN to BREAKFAST and you could have a BREAKFAST serial

[16:13] <jnthn> *groan*

[16:13] <jnthn> pmichaud: Remember that dynamic should look in GLOBAL before PROCESS.

[16:14] *** karupas left
[16:14] <pmichaud> okay, no problem.  for some reason master doesn't seem to have it that way.

[16:15] * TimToady wonders if we should rename GLOBAL to INTERP or some such

[16:15] <TimToady> nah...

[16:15] <TimToady> should rename it to DUCKPOND or some such

[16:21] *** Mowah joined
[16:24] *** zby_home__ is now known as zby_home_

[16:26] <masak> time for a lightning talk. see y'all later.

[16:26] *** masak left
[16:28] *** jaldhar left
[16:29] *** jaldhar joined
[16:32] <dalek> rakudo/nom: d024ee6 | pmichaud++ | src/core/Str.pm:

[16:32] <dalek> rakudo/nom: Assignment to my ($a, $b) declarations now works -- let's use it.

[16:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d024ee6a5d

[16:32] <dalek> rakudo/nom: 561a88b | pmichaud++ | src/Perl6/Metamodel/ (2 files):

[16:32] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[16:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/561a88b08c

[16:34] <jnthn> pmichaud: Done the fix so you should be able to implement GLOBAL now. :)

[16:34] <pmichaud> jnthn: yes, I'm getting there.  ETOOMUCHLHF  here :)

[16:34] <jnthn> :)

[16:37] <jnthn> pmichaud: ooc, do you conciously avoid --rebase when pulling?

[16:37] <pmichaud> no

[16:37] <dalek> rakudo/nom: 451e80b | jnthn++ | src/Perl6/SymbolTable.pm:

[16:37] <dalek> rakudo/nom: Make mentions of GLOBAL.WHO work out (so DYNAMIC will be able to look in there).

[16:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/451e80b111

[16:37] <dalek> rakudo/nom: 089cb09 | pmichaud++ | src/core/operators.pm:

[16:37] <dalek> rakudo/nom: Argument list interpolation now works (jnthn++) -- eliminate some Q:PIR by using it!

[16:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/089cb091fd

[16:37] <dalek> rakudo/nom: f26a237 | pmichaud++ | src/Perl6/SymbolTable.pm:

[16:37] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[16:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f26a237876

[16:37] <jnthn> OK :)

[16:37] <pmichaud> I just think that if --rebase is desirable it ought to be the default :)

[16:37] <TimToady> that's why I have a gp alias :)

[16:37] <jnthn> Well, it does avoid the merge messages

[16:38] <jnthn> They don't really bother me though :)

[16:38] <pmichaud> yeah, same here

[16:38] <pmichaud> I figure they're going to happen, so okay.

[16:38] <pmichaud> I wonder when someone would *not* want to --rebase, though.

[16:38] <jnthn> heh, I love how the above commit lost the comment "# TODO: Why?" :)

[16:39] <pmichaud> since I no longer need to worry about it, yes :)

[16:39] <pmichaud> you might want to figure it out someday, though :)

[16:39] <jnthn> yeah, I'm a little curious about it

[16:40] <pmichaud> there's still a similar Q:PIR in MapIter if you want to look at it.  I briefly tried removing the Q:PIR in MapIter also but performance went way down and it failed besides, so that one isn't LHF and I'll deal with it a bit later

[16:40] <pmichaud> also need to figure out how to make Parcel interpolation a bit more efficient

[16:40] <jnthn> |@foo isn't going to be as efficient for now as the Q:PIR

[16:41] <jnthn> It's kinda a mess to handle that stuff at the moment. :/

[16:41] *** wamba joined
[16:41] <jnthn> Parrot is too helpful on the caller side.

[16:41] <pmichaud> interesting how "too helpful" translates to "not helpful"  :)

[16:42] <pmichaud> I'll leave the Q:PIR in place, then -- map iteration speed is hugely important still.

[16:42] <pmichaud> I'm a little less concerned about the speed of generating sequences at this point -- code clarity is probably better there.

[16:43] <jnthn> *nod*

[16:43] <pmichaud> where is GLOBAL:: defined?

[16:43] <pmichaud> (maybe I should look at the commits.)

[16:44] <jnthn> pmichaud: We just shove GLOBAL into the Parrot ns, because those actually *are* global, which we actually want for once. ;)

[16:44] <jnthn> pmichaud: Elsewhere there's code to make sure the current view of GLOBAL is put there.

[16:44] <jnthn> All I fixed was making sure GLOBAL was recognized as a type name.

[16:44] <jnthn> GLOBAL::foo already worked

[16:45] <pmichaud> I'm wondering where PROCESS:: should go, then.

[16:45] <jnthn> Yeah, that one is kinda magical too...

[16:46] <sorear> good * #perl6

[16:46] <jnthn> Right now we don't have a case where GLOBAL and PROCESS would be different.

[16:46] <pmichaud> oh, I'm certain they're different, though.  Can we just set up PROCESS to be side-by-side with GLOBAL?

[16:47] <jnthn> pmichaud: Oh, they're different. I just mean that we don't currently have any cases where they'd not want to be installed in the same kinda place.

[16:47] <pmichaud> right

[16:47] <pmichaud> so, side-by-side then?

[16:47] <jnthn> Yeah

[16:47] <jnthn> wfm

[16:48] <jnthn> Probably wants to be factored a bit different from GLOBAL

[16:48] <jnthn> Oh

[16:48] <jnthn> Actually I can construct a case where they'd be different today.

[16:48] <jnthn> pmichaud: Want me to set up the PROCESS bits?

[16:49] <pmichaud> jnthn: yes please.  I could figure out how to do it, but I'll learn more by seeing the patch from you I think.

[16:49] *** tokuhirom left
[16:49] <pmichaud> I'll get &DYNAMIC working for PROCESS and GLOBAL in the meantime

[16:50] *** jaldhar left
[16:51] *** jaldhar joined
[16:52] *** Pathin left
[16:53] <dalek> rakudo/nom: 0bd5420 | jnthn++ | src/Perl6/Actions.pm:

[16:53] <dalek> rakudo/nom: Apply routine and method traits.

[16:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0bd5420c00

[16:53] *** Pathin joined
[16:54] *** Pathin_ joined
[16:58] *** fhelmberger left
[17:03] <dalek> rakudo/nom: 1383361 | pmichaud++ | src/core/stubs.pm:

[17:03] <dalek> rakudo/nom: Update dynamic variables to look in GLOBAL.WHO and PROCESS.WHO namespaces (jnthn++).

[17:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1383361f04

[17:04] <jnthn> pmichaud: I'm guessing the PROCESS bit doesn't actually work yet?

[17:04] *** Pathin left
[17:05] *** Pathin joined
[17:07] <pmichaud> jnthn: it should work as soon as you do your PROCESS magic :-)

[17:07] *** tokuhirom joined
[17:07] <pmichaud> but since the result of not finding the var in PROCESS is a fail anyway, I'm not too worried about catching ENOPROCESS 

[17:08] <pmichaud> afk for a short while -- lunch

[17:09] <jnthn> > PROCESS.WHO<$IN> = 42; say PROCESS.WHO<$IN>

[17:09] <jnthn> 42

[17:09] <JimmyZ> \o

[17:12] *** Pathin left
[17:13] *** Pathin joined
[17:13] <jnthn> hi JimmyZ :)

[17:14] *** Pathin left
[17:14] *** Pathin_ left
[17:14] <JimmyZ>   hello jnthn 

[17:14] *** Pathin joined
[17:14] *** Pathin_ joined
[17:15] <sorear> hello JimmyZ

[17:15] <JimmyZ> hello sorear 

[17:15] * sorear wonders how much longer niecza will be able to get away with having typeglobs

[17:15] <JimmyZ> will go to sleep soon, it's 1:15am here ;)

[17:17] <jnthn> JimmyZ: :)

[17:17] <sorear> nom: my %foo; %foo<bar> := 5; %foo<bar>++

[17:17] <p6eval> nom: OUTPUT«Cannot use bind operator with this LHS at line 1, near " 5; %foo<b"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23569 (src/stage2/gen/NQPHLL.pir:6311)␤»

[17:17] * JimmyZ knows that sorear is working hard on niecza on his own.

[17:18] <jnthn> JimmyZ: Only a few days until I'll be in your timezone too ;)

[17:19] <JimmyZ> good, welcome to china again(or beijing again)

[17:20] *** fhelmberger joined
[17:20] *** fhelmberger left
[17:23] *** Pathin_ left
[17:24] *** pochi left
[17:24] *** pochi joined
[17:24] *** Moukeddar joined
[17:25] *** Pathin_ joined
[17:26] <jnthn> JimmyZ: Yes, will be nice to be back. Even if the weather will be very hot for me. :)

[17:29] *** jaldhar left
[17:30] <pmichaud> moritz: want me to go ahead and add the dalek post-receive hook?

[17:30] *** jaldhar joined
[17:31] <moritz> pmichaud: yes please

[17:31] <pmichaud> when it says "remove the entry from dalek-conf.json -- what do I do there exactly?  just remove the "url" entry?

[17:32] <pmichaud> no, that doesn't seem right

[17:32] <moritz> the hash that contains the url

[17:32] <pmichaud> dalek will still be aware of the branches?

[17:32] <pmichaud> oh yes, I guess it will

[17:33] <moritz> yes, of all

[17:33] <pmichaud> okay, working.

[17:34] *** Pathin_ left
[17:35] <dalek> mu: d9cc647 | pmichaud++ | misc/dalek-conf.json:

[17:35] <dalek> mu: [dalek]:  Update rakudo in dalek-conf.json to use the github post-receive hook.

[17:35] <dalek> mu: review: https://github.com/perl6/mu/commit/d9cc647e4c

[17:35] *** Pathin_ joined
[17:35] <dalek> rakudo: 4f47105 | (JD Horelick)++ | docs/announce/2011.06:

[17:35] <dalek> rakudo: Update 2011.06 announcement with the releasename and another Douglas Adams reference.

[17:35] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/4f4710590f

[17:35] <dalek> rakudo: 70c5ca4 | (JD Horelick)++ | docs/release_guide.pod:

[17:35] <dalek> rakudo: Update release_guide.pod for 2011.06 release.

[17:35] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/70c5ca49e2

[17:35] <dalek> rakudo: b2bc994 | (JD Horelick)++ | VERSION:

[17:35] <dalek> rakudo: [release] bump VERSION

[17:35] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/b2bc994069

[17:36] <pmichaud> should be done.  I used http://host04.appflux.net:5000/dalek?t=freenode,perl6+magnet,parrot  as the url -- think that's correct.

[17:36] <pmichaud> moritz++  # thanks for pointers

[17:36] <pmichaud> afk, lunch again

[17:36] <jnthn> In Texas, lunch is so big they have it twice. :P

[17:37] <JimmyZ> \o, rakudo commit reports are in #parrot again

[17:37] <dalek> rakudo/nom: 7bfc64f | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[17:37] <dalek> rakudo/nom: Get PROCESS in place. Should only ever have one of these.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7bfc64f9ec

[17:37] <dalek> rakudo/nom: baf7677 | jonathan++ | src/Perl6/ (2 files):

[17:37] <dalek> rakudo/nom: Make things like $PROCESS:IN = ... work.

[17:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/baf7677257

[17:38] <jnthn> oops, we compile GLOBAL.WHO a load too statically...

[17:40] * JimmyZ must sleep

[17:40] *** JimmyZ left
[17:44] *** Pathin_ left
[17:46] *** Pathin_ joined
[17:53] *** cbk joined
[17:55] *** Pathin_ left
[17:56] *** Pathin_ joined
[17:57] <dalek> rakudo/nom: 2c533ea | jonathan++ | src/Perl6/Actions.pm:

[17:58] <dalek> rakudo/nom: Fix GLOBAL lookups.

[17:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2c533eafc0

[17:58] <dalek> rakudo/nom: de38225 | jonathan++ | src/Perl6/SymbolTable.pm:

[17:58] <dalek> rakudo/nom: Was a little to eager in lexical => lexical_6model; still need to look for lexical in the odd place. Unbusts some lookups.

[17:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de3822530b

[17:58] <jnthn> pmichaud: Can now do:

[17:58] <jnthn> > $PROCESS::IN = 42; say $*IN

[17:58] <jnthn> 42

[17:58] * moritz looks into setting up $*IN etc.

[17:59] *** Moukeddar left
[18:03] <jnthn> Time for a break.

[18:04] <sorear> jnthn: nice

[18:06] *** Pathin_ left
[18:07] *** Pathin_ joined
[18:07] <sorear> I wonder how to represent "Mu, but initialize to Any" as a type constraint.

[18:08] <sorear> Perhaps I should separate "type constraint" and "initial value" on variable metaobjects

[18:10] <pmichaud> jnthn: ping

[18:16] *** Pathin_ left
[18:17] <jnthn> pmichaud: pong

[18:17] *** Pathin_ joined
[18:20] *** karupanerura left
[18:21] <moritz> $*IN and $*OUT work now

[18:21] <moritz> locally

[18:23] <sorear> jnthn: I'm having a crazy idea to make all Packages use the same STable

[18:25] <dalek> rakudo/nom: c66a42a | moritz++ | src/core/IO.pm:

[18:25] <dalek> rakudo/nom: update IO.say

[18:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c66a42a8c3

[18:25] <dalek> rakudo/nom: a67ebc3 | moritz++ | src/core/IO.pm:

[18:25] <dalek> rakudo/nom: set up $*IN and $*OUT

[18:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a67ebc3be5

[18:26] <pmichaud> jnthn: where's a good (canonical?) place to put initializations that need to occur asap at startup.  for example, PROCESS::IN and PROCESS::ENV ?

[18:27] *** Pathin_ left
[18:27] <jnthn> pmichaud: Well, think with PROCESS::IN is that you can't do it until IO is defined

[18:27] <jnthn> *thing

[18:28] <pmichaud> okay, ENV then :-)

[18:28] <jnthn> pmichaud: So "somewhere in the setting" is as good a bet as anything

[18:28] *** Pathin_ joined
[18:28] <pmichaud> that seems workable.

[18:28] <jnthn> Well, same story for ENV apart from s/IO/Hash/ :)

[18:28] <pmichaud> I'll start with that then.

[18:28] <pmichaud> we'll try it there and see if it's "soon enough"  :-)

[18:28] <jnthn> If you like, feel free to create a special place in the setting where we collect these things.

[18:28] <jnthn> Well, I suspect it is.

[18:29] <jnthn> Even BEGIN block comes after loading of the setting.

[18:29] <pmichaud> for now I'll go with setting them in the file where the needed type is defined.  for example, where moritz++ currently has $*IN and $*OUT

[18:29] <pmichaud> if we decide to centralize it, it'll be globals.pm or process.pm or something like that

[18:29] <jnthn> Loading the setting (unless --setting=NULL) is close to the first thing we do when compiling something.

[18:30] <pmichaud> wfm

[18:30] <jnthn> sorear: I'm mostly confused by that.

[18:30] <jnthn> sorear: OTOH, you did say it was crazy... :)

[18:30] *** Mowah left
[18:38] *** karupanerura joined
[18:38] *** Pathin_ left
[18:39] *** Pathin_ joined
[18:46] <sorear> jnthn: I'm thinking that since packages are never instantiatable, we could give them storage without causing too much confusion

[18:46] <sorear> jnthn: then store WHO and HOW in the type object, and avoid allocating a STable

[18:47] <jnthn> sorear: eww.

[18:48] <jnthn> sorear: Not worth the mess and extra checks whenever doing get_who, etc.

[18:48] <jnthn> It's hardly like an STable is big.

[18:48] *** Pathin_ left
[18:48] <sorear> How big is a 6model STable?

[18:49] *** Pathin_ joined
[18:50] <jnthn> sorear: Not sure off hand. 16ish pointers.

[18:50] <jnthn> sorear: With room for shrinkage.

[18:51] <jnthn> Could probably quite easily slash it to 10.

[18:51] <jnthn> So, 40 bytes or so.

[18:52] <TimToady> on a 32 bit machine...

[18:52] <jnthn> Sure

[18:56] *** karupas joined
[18:56] *** karupanerura left
[18:58] *** Moukeddar_ joined
[18:59] *** Pathin_ left
[19:00] *** Pathin_ joined
[19:09] *** Pathin_ left
[19:10] *** Pathin_ joined
[19:18] *** karupanerura joined
[19:20] *** Pathin_ left
[19:20] *** karupas left
[19:21] *** Pathin_ joined
[19:25] *** whiteknight left
[19:25] *** whiteknight joined
[19:26] <moritz> $PROCESS::ERR = IO.new;

[19:26] <moritz> nqp::bindattr($PROCESS::ERR, IO, '$!PIO', pir::getstderr__P());

[19:26] <moritz> what's wrong with that?

[19:26] <moritz> I get

[19:26] <moritz> P6opaque attributes NYFI 4 (attribute '$!PIO' not found)

[19:27] *** Moukeddar_ left
[19:28] <jnthn> moritz: bindattr needs explicit decontainerization of the target object.

[19:28] <moritz> jnthn: ah

[19:29] <TimToady> I hope that F stands for "fully"  :)

[19:29] <jnthn> TimToady: Yes!

[19:29] <moritz> what else could it stand for? :-)

[19:29] *** envi left
[19:29] <jnthn> TimToady: I...shoulda seen the other interpretation. :)

[19:30] <TimToady> to the pure, all things are pure... :)

[19:30] <moritz> jnthn: that you didn't honors you

[19:30] *** Pathin_ left
[19:30] <jnthn> I need to clear that up at some point, but happily nobody tried to do MI with attributes yet. ;)

[19:31] <moritz> jnthn: well, I knew about that liimtation :-)

[19:31] *** Pathin_ joined
[19:32] <jnthn> moritz: At the moment that error really means "I don't have that attribute" and/or "no MI yet"

[19:32] <jnthn> It's not that it's especially hard to implement. It just never hit the critical path of tasks yet. :)

[19:34] <moritz> nom: sub f(|$) { say |pir::perl6_current_args_rpa__P() }; f 3, 4

[19:34] <p6eval> nom: OUTPUT«Method 'ARGLIST_FLATTENABLE' not found for invocant of class 'ResizablePMCArray'␤current instr.: 'f' pc 278 ((file unknown):52219245) (:1)␤»

[19:34] <dalek> rakudo/nom: 4f8a6d9 | moritz++ | src/core/IO.pm:

[19:34] <dalek> rakudo/nom: set up $*ERR, jnthn++

[19:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f8a6d9eab

[19:35] <moritz> nom: sub f(|$) { say |pir__perl6_box_rpa__P(pir::perl6_current_args_rpa__P()) }; f 3, 4

[19:35] <p6eval> nom: OUTPUT«Could not find sub &pir__perl6_box_rpa__P␤current instr.: 'f' pc 278 ((file unknown):76216813) (:1)␤»

[19:35] <jnthn> pir::

[19:36] <moritz> src/core/Parcel.pm

[19:36] <moritz> 100:sub pir__perl6_box_rpa__PP(|$) {

[19:36] <jnthn> Also PP

[19:36] <jnthn> er, huh

[19:36] <jnthn> O.O

[19:36] * jnthn looks at pmichaud++ :)

[19:37] <moritz> I just don't see why it's not available to userland

[19:37] <jnthn> nom: pir__perl6_box_rpa__P

[19:37] <p6eval> nom: OUTPUT«Could not find symbol '&pir__perl6_box_rpa__P'␤current instr.: 'fail' pc 190872 (src/gen/CORE.setting.pir:0) (:138)␤»

[19:37] <jnthn> nom: pir__perl6_box_rpa__PP

[19:37] <p6eval> nom: OUTPUT«ResizablePMCArray: Can't shift from an empty array!␤current instr.: 'pir__perl6_box_rpa__PP' pc 192016 (src/gen/CORE.setting.pir:48073) (:459)␤»

[19:37] <jnthn> moritz: You did P, not PP

[19:37] <moritz> nom: sub f(|$) { say |pir__perl6_box_rpa__P(pir::perl6_current_args_rpa__PP()) }; f 3, 4

[19:37] <p6eval> nom: OUTPUT«Could not find sub &pir__perl6_box_rpa__P␤current instr.: 'f' pc 278 ((file unknown):73951725) (:1)␤»

[19:38] <moritz> jnthn: ah, thanks

[19:38] <moritz> still no luck

[19:38] <jnthn> ?

[19:38] <moritz> oh

[19:38] <jnthn> oh, no

[19:38] <moritz> my bad

[19:38] <jnthn> heh :)

[19:38] <moritz> nom: sub f(|$) { say |pir__perl6_box_rpa__PP(pir::perl6_current_args_rpa__P()) }; f 3, 4

[19:38] <p6eval> nom: OUTPUT«Method 'ARGLIST_FLATTENABLE' not found for invocant of class 'Parcel'␤current instr.: 'f' pc 289 ((file unknown):51612144) (:1)␤»

[19:38] <jnthn> OK, that one is fixable :)

[19:39] <jnthn> moritz: In Parcel.pm

[19:39] <jnthn> method ARGLIST_FLATTENABLE() { $!storage }

[19:40] *** Pathin_ left
[19:41] *** [particle]1 joined
[19:42] *** Bzek left
[19:42] *** Pathin_ joined
[19:43] <moritz> jnthn: thanks, will try

[19:43] *** [particle] left
[19:45] *** whiteknight left
[19:45] *** whiteknight joined
[19:46] <pmichaud> 19:39 <jnthn> method ARGLIST_FLATTENABLE() { $!storage }

[19:46] <pmichaud> probably not right, since $!storage is an RPA

[19:47] <pmichaud> oh, it might work

[19:47] <pmichaud> hmmm

[19:47] <pmichaud> oh, the problem is that it won't flatten

[19:47] <moritz> with that, calling with the same argument as  |pir__perl6_box_rpa__PP(pir::perl6_current_args_rpa__P()) "works"

[19:48] <moritz> ie seems to work, after an initial test :-)

[19:48] <pmichaud> how should:    foo(|(2,3,(4,5),6))   end up in the argument list?

[19:48] <pmichaud> is it four arguments or five ?

[19:49] <jnthn> pmichaud: That's the point

[19:49] <jnthn> pmichaud: We need an RAP or Parrot doesn't know what to do with it.

[19:49] <pmichaud> same for   foo(|(2,3,@a,5))

[19:49] <jnthn> *RPA

[19:49] <pmichaud> getting an RPA is easy -- I just am not sure it's should be Parcel's RPA :)

[19:49] <pmichaud> *it

[19:49] <jnthn> pmichaud: Ah, OK

[19:50] <pmichaud> what happens with foo(|(2,3,(4,5),6))   ?  Is that four arguments to foo, or five?

[19:50] *** whiteknight left
[19:51] <pmichaud> rakudo:  sub foo($a, $b, $c) { say "$a $b $c"; };   foo(|(1,2,(3,4)))

[19:51] <p6eval> rakudo b2bc99: OUTPUT«1 2 3 4␤»

[19:51] <pmichaud> rakudo thinks it's three.

[19:51] *** Pathin_ left
[19:51] <pmichaud> (or in my example above, it'd be four arguments)

[19:52] <TimToady> I'd think it would depend on what the (4,5) is bound to

[19:52] <TimToady> it's an embedded parcel

[19:52] <pmichaud> I'm excluding slurpies for the moment

[19:52] <TimToady> so it's 2 args in to list binding but 1 to an item binding

[19:52] *** Pathin_ joined
[19:52] <TimToady> | only does one level

[19:52] <pmichaud> okay

[19:52] <pmichaud> then RPA's $!storage is fine

[19:53] <pmichaud> sorry, Parcel's $!storage RPA is fine

[19:54] <jnthn> pmichaud: The other option is we try to teach Parrot how to cope with more stuff with its :flat

[19:54] <jnthn> pmichaud: Though I think we may need to anyway.

[19:54] <jnthn> pmichaud: Unless we want to have a big mess around with |$capture again.

[19:54] <pmichaud> I'm fine with the way it is now, at least for a while.

[19:54] <jnthn> I'm not happy with how |$cap is handled in master. :/

[19:54] <pmichaud> even |$capture shouldn't be too hard -- just put ARGLIST_FLATTENABLE method onto Capture

[19:55] <jnthn> pmichaud: Which returns what?

[19:55] <pmichaud> an rpa.... or are you worried about named captures?

[19:55] <jnthn> named

[19:55] <jnthn> oh, darn

[19:55] <jnthn> nom: sub foo(:$a) { say $a }; my %h = a => 42; foo(|%h)

[19:55] <p6eval> nom: OUTPUT«42␤»

[19:56] <jnthn> huh

[19:56] <jnthn> OK, it works, I dunno how ;)

[19:56] <moritz> magic[tm]

[19:56] <jnthn> I thought you had to :flat :named things

[19:56] <jnthn> But seems Parrot figures it out...somehow. :)

[19:56] <pmichaud> I thought you were doing that.

[19:56] <moritz> :-)

[19:56] * pmichaud re-checks the patch.

[19:56] <jnthn> I...don't think so.

[19:57] <jnthn> If I am, the beer last night was stronger than I remember...

[19:57] <tadzik> yay, I has the flight tickets to yapceu :)

[19:57] <moritz> \o/

[19:57] * moritz jealous

[19:57] <jnthn> nom: sub foo(:$a) { say $a }; foo(|{ a => 42 })

[19:57] <p6eval> nom: OUTPUT«42␤»

[19:57] <jnthn> tadzik: yay, see you there!

[19:58] <tadzik> I'll be there on 11th too, the flight ticket for 11th was >50% cheaper than for 12th

[19:58] <moritz> I guess Riga is well worth it :-)

[19:58] <tadzik> jnthn: yeah, looking forward to it :)

[19:58] <tadzik> yes, that opens some opportunities

[19:59] <moritz> tadzik: you can see if soembody wants hackathon or so :-)

[20:00] <pmichaud> jnthn: I'm not sure how/why that's working... but it's not something that worries me atm for some reason.

[20:00] <jnthn> pmichaud: I'm mostly scared about what Parrot is doing that means it works :)

[20:01] <tadzik> moritz: there's even a scheduled hackathon on 12th, so that'd be a heck-athon :P

[20:01] <pmichaud>     find_lex $P101, "%h"

[20:01] <pmichaud>     $P102 = $P101."ARGLIST_FLATTENABLE"()

[20:01] <pmichaud>     $P103 = "&foo"($P102 :flat)

[20:01] <pmichaud> you're right... no :named flag.  I have no idea what Parrot is up to there, then.  :)

[20:02] <jnthn> Some questions are better left unasked. :)

[20:02] *** Pathin_ left
[20:02] <pmichaud> maybe parrot isn't doing anything with it, and its the binder code that is seeing it correctly (because of the :flat flag?)

[20:02] <jnthn> No, the flattening is caller side

[20:02] <jnthn> Which is why you can't |@foo is @foo is infinite.

[20:02] * pmichaud tests.

[20:03] *** Pathin_ joined
[20:03] <dalek> rakudo/nom: 348b506 | moritz++ | src/core/ (2 files):

[20:03] <dalek> rakudo/nom: make say() and print() redispatch to the methods on $*OUT

[20:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/348b506977

[20:04] * moritz would like to mention that not all IO was very LHF-ish

[20:04] <tadzik> moritz++ # non-trivial patches )

[20:04] <tadzik> :)

[20:05] <pmichaud> jnthn: parrot automatically puts a flattening hash into the slurpy hash:  http://gist.github.com/1046845

[20:05] <jnthn> pmichaud: ah :)

[20:05] <pmichaud> bet they don't even realize that :)

[20:05] <jnthn> Yes, that's my worry.

[20:07] *** wooden joined
[20:12] *** Pathin_ left
[20:13] *** cbk left
[20:13] *** Pathin_ joined
[20:14] * pmichaud starts taking an axe to obsolete parts of HLL::Compiler

[20:15] *** karupas joined
[20:17] *** karupanerura left
[20:19] *** cbk joined
[20:20] <dalek> niecza: 4d8c2a8 | sorear++ | lib/ (5 files):

[20:20] <dalek> niecza: Attributes and aggregate elements default to Any with a Mu constaint

[20:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4d8c2a8527

[20:22] * TimToady wonders why people keep spelling it axe when ax is perfectly acceptable

[20:22] *** Pathin_ left
[20:23] *** Pathin_ joined
[20:23] <pmichaud> It's a "Texas ax"

[20:24] <TimToady> I thought that was a chainsaw

[20:24] <pmichaud> Kind of like an Idaho potatoe

[20:24] * TimToady keeps thinking "axe" should be pronounced like "aches"

[20:25] <pmichaud> at least I'm not using "axe" in place of "ask", as in "Don't axe me that again!"

[20:25] <TimToady> no, you're not an ax murderer :)

[20:26] <TimToady> or would that be an ask murderer?

[20:27] <TimToady> phenny: tell daniel-s "http%3A%2F%2Ffoo%20bar%2F".subst(/'%' (<[0..9A..F]> ** 2)/, -> $/ { chr(:16($0)) }, :g).say

[20:27] <phenny> TimToady: I'll pass that on when daniel-s is around.

[20:28] *** bakedb left
[20:28] *** pochi_ joined
[20:28] *** pochi left
[20:28] *** tyatpi joined
[20:29] *** pochi_ left
[20:29] *** pochi joined
[20:32] *** Pathin_ left
[20:34] *** Pathin_ joined
[20:37] *** pernatiy left
[20:39] <sorear> subst's second argument takes a parameter?

[20:40] <moritz> sorear: that's a rakudo hack. $/ should be automagically available in it

[20:40] *** kaare_ left
[20:43] *** Pathin_ left
[20:44] *** bitpart joined
[20:44] *** Pathin_ joined
[20:47] * jnthn gets curious what pmichaud is going to axe :)

[20:48] *** wooden left
[20:51] <jnthn> std: our Int $x; our Int $x;

[20:51] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[20:51] <jnthn> std: our Int $x; our Str $x;

[20:51] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 119m␤»

[20:51] <jnthn> What do type constraints on an "our" variable actually mean?

[20:52] <jnthn> Of note, what if:

[20:52] <jnthn> $Foo::x = 42; module Foo { our Str $x; }

[20:52] *** karupanerura joined
[20:53] <jnthn> Should we have set the variable in Foo's stash up at BEGINish time?

[20:53] *** karupas left
[20:54] <jnthn> If so, what do multiple our's refering to it mean?

[20:54] <jnthn> :)

[20:57] *** Pathin_ left
[20:57] <sorear> niecza: our Int $x

[20:57] <p6eval> niecza v6-196-g4d8c2a8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Common variables are not unique definitions and may not have types at /tmp/yUopoyDe_L line 1 (EOF):␤------> [32mour Int $x[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setti…

[20:57] *** Pathin_ joined
[20:58] <sorear> consider that my vote

[20:58] *** fhelmberger joined
[21:02] *** bitpart left
[21:04] <dalek> niecza: 9fa31a8 | sorear++ | / (3 files):

[21:04] <dalek> niecza: my-variables default to Any but with Mu constraint

[21:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9fa31a8d6b

[21:05] <mikemol> TimToady: I like 'moddiv' ... sounds like "Muad'dib"

[21:06] *** Pathin_ left
[21:07] *** Pathin_ joined
[21:09] *** dual left
[21:10] *** masak joined
[21:10] <masak> \o/

[21:11] <jnthn> lolitsmasak!

[21:11] <tadzik> lawlitsCarl!

[21:11] * masak resumes uploading today's slides

[21:11] <jnthn> Vive le masak!

[21:11] *** whiteknight joined
[21:12] <masak> today has been a satisfying day.

[21:12] <jnthn> :)

[21:13] <masak> I did my second lightning talk, ever.

[21:13] <jnthn> How'dit go?

[21:13] <masak> well, for such a dry topic.

[21:13] <jnthn> Mutually recursive triangle making thingies is dry? :)

[21:13] <masak> "How to mutually recurse yourself to a sierpinski DAG using Perl 6." :)

[21:14] <sorear> masak!

[21:14] <masak> sorear!

[21:15] *** dual joined
[21:16] *** Pathin_ left
[21:17] *** Pathin_ joined
[21:19] <dalek> rakudo/nom: b9b7f54 | jonathan++ | NOMMAP.markdown:

[21:19] <dalek> rakudo/nom: Remove a completed entry from nommap.

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9b7f54385

[21:19] <dalek> rakudo/nom: f83b81d | jonathan++ | / (2 files):

[21:19] <dalek> rakudo/nom: First simple cut at our-scoped variables.

[21:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f83b81d8f7

[21:25] *** Pathin_ left
[21:26] *** Pathin_ joined
[21:29] <dalek> nqp: 2f91679 | pmichaud++ | src/HLL/Compiler.pm:

[21:29] <dalek> nqp: Remove long Q:PIR section from HLL::Compiler.command_line().

[21:29] <dalek> nqp: (Will restore the exception handler in a subsequent commit.)

[21:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2f9167997b

[21:29] <dalek> nqp: 21aa0e4 | pmichaud++ | / (4 files):

[21:29] <dalek> nqp: Merge branch 'master' of github.com:perl6/nqp

[21:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/21aa0e4bd6

[21:32] <masak> my first and last talk from today: http://masak.org/carl/fpw-2011-excited/talk.pdf http://masak.org/carl/fpw-2011-sierpinski/talk.pdf

[21:35] *** Pathin_ left
[21:35] <pmichaud> oops, that commit broke something

[21:35] <pmichaud> (odd because it worked earlier)

[21:35] <pmichaud> fixing.

[21:35] <jnthn> masak: is "merci bcp" the french "kthxbai"? :)

[21:36] <jnthn> masak++ # slides

[21:36] <pmichaud> ... "have to put food on the family"?

[21:36] *** Pathin_ joined
[21:36] * pmichaud dumps a load of baguettes on his kids

[21:37] <jnthn> .oO( that'll give them a breadache... )

[21:38] <mikemol> jnthn: You run a site? (I somehow missed it)

[21:39] <mikemol> Granted the appropriate response to a question like that in a crowd like this is "which one do you mean?"

[21:39] <mikemol> It was mentioned earlier in the context of masak's second talk, or something like that.

[21:40] <pmichaud> looks like the problem was that I needed to rebuild Parrot.  I need to add mberends++ super-useful "you need to update Parrot" script to NQP

[21:40] <jnthn> mikemol: You may be looking for my slides at http://www.jnthn.net/articles.shtml or my Perl 6 blog at http://6guts.wordpress.com/

[21:40] <masak> pmichaud: it's a Bushism.

[21:40] <masak> jnthn: yes. :)

[21:40] <masak> jnthn: well, not really. but I like it for its brevity. it feels French.

[21:40] <pmichaud> masak: wow, so it is!  (Bushism)

[21:40] <mikemol> Something about aweing people, but not leaving them without a clue where to go. :)

[21:40] <tadzik> as in George Bush?

[21:41] <mikemol> I think I've seen the blog in the p6 planet. *reads the slides*

[21:41] <mikemol> Ok, there are a lot of slides. Heh.

[21:41] <pmichaud> I hadn't heard that particular one before.

[21:42] <masak> :)

[21:42] <masak> silly old George.

[21:42] <pmichaud> Hard to believe he lives only 18 miles away from me.  :-)

[21:43] <tadzik> that's like 1 ranch? :)

[21:44] <pmichaud> it can be, yes.  Although there aren't many ranches that size in this part of Texas (that I know of)

[21:45] *** Pathin_ left
[21:45] *** Patterner left
[21:46] *** Pathin_ joined
[21:46] <masak> my talk generated questions after. jnthn's talk generated questions during. interesting how that worked.

[21:47] <jnthn> "WTF was the author of these slides thinking?!"

[21:47] *** Psyche^ joined
[21:47] *** Psyche^ is now known as Patterner

[21:47] <dalek> nqp: faf34e9 | pmichaud++ | src/HLL/Compiler.pm:

[21:47] <dalek> nqp: Eliminate obsolete "astgrammar" stuff from HLL::Compiler,

[21:47] <dalek> nqp: and another 30 lines of Q:PIR code goes away.

[21:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/faf34e9590

[21:55] *** Pathin_ left
[21:56] *** Pathin_ joined
[21:57] <pmichaud> afk for a bit, errands

[22:04] *** Pathin_ left
[22:05] *** lue joined
[22:06] *** Pathin_ joined
[22:14] *** pochi left
[22:15] *** Pathin_ left
[22:16] *** Pathin_ joined
[22:22] <sorear> masak: Do you know who started the "Perl 6 has not yet been released" meme?

[22:22] *** masak left
[22:23] *** phluks_ joined
[22:25] *** Pathin_ left
[22:26] *** phluks_ left
[22:26] *** Pathin_ joined
[22:32] <dalek> rakudo/nom: 706682b | jonathan++ | src/ (3 files):

[22:32] <dalek> rakudo/nom: Fix roles in pre-compiled situation, so they work as well as in immediate-run mode.

[22:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/706682b0c1

[22:32] <dalek> rakudo/nom: dbdb675 | jonathan++ | / (6 files):

[22:32] <dalek> rakudo/nom: Add empty Associative and Positional roles; make List/Parcel/EnumMap do them appropriately.

[22:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbdb675a55

[22:32] <dalek> rakudo/nom: cc24038 | jonathan++ | NOMMAP.markdown:

[22:32] <dalek> rakudo/nom: Remove done items from nommap.

[22:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cc24038cfa

[22:35] *** Pathin_ left
[22:35] <sorear> jnthn: Why is it STORE_AT_KEY and not bind_key?

[22:36] *** Pathin_ joined
[22:36] <jnthn> sorear: Where? :)

[22:36] <jnthn> sorear: Also, probably wrong person to ask. :)

[22:37] <jnthn> pmichaud++ is working on the details of those things

[22:37] <jnthn> store and bind sound like different operations though

[22:38] <jnthn> nom: try { die 'omgz' }; say 'ok'

[22:39] <p6eval> nom: OUTPUT«Method 'blocktype' not found for invocant of class 'PAST;Op'␤current instr.: 'nqp;Perl6;Actions;statement_prefix:sym<try>' pc 37226 (src/gen/perl6-actions.pir:0)␤»

[22:40] <jnthn> *sigh* guess exceptiony stuff needs sorting out soon

[22:41] <pmichaud> in the case of Arrays, we're storing a value into a container, not binding a value.

[22:41] <pmichaud> same for Hashes

[22:43] *** pjcj_ left
[22:44] <jnthn> pmichaud: It looks like Parrot only lets us throw a Parrot exception PMC :/

[22:44] <pmichaud> jnthn: yes, we'll have to wrap it up.

[22:44] <jnthn> ffs

[22:44] <pmichaud> but it's not so bad -- we have to do similar things with hashes and arrays

[22:44] <jnthn> Well, it's more the inverse this time

[22:44] <pmichaud> I was going to work on that a bit later tonight/tomorrow

[22:44] <jnthn> Wrap the 6model Exception object up in a Parrot Exception just to throw it.

[22:44] <jnthn> And unwrap it again later.

[22:44] <jnthn> Talk about wasteful.

[22:44] *** Pathin_ left
[22:45] <pmichaud> hmmmm

[22:45] <pmichaud> I'm not sure I follow

[22:45] <jnthn> pmichaud: We can't have Parrot Exception objects leaking into Perl 6 land.

[22:45] <pmichaud> I understand that part

[22:45] <jnthn> pmichaud: But throw needs a Parrot exception.

[22:46] <pmichaud> why would we be throwing a 6model object, though?

[22:46] <jnthn> pmichaud: So if we actually want to communicate the real Perl 6 exception object, we need to bundle it inside the Parrot one.

[22:46] <pmichaud> just put the Perl6 exception object as the payload of a Parrot exception

[22:46] <jnthn> Yeah

[22:46] *** Pathin_ joined
[22:47] <pmichaud> or just attach the 6model object to the parrot exception's property hash :)

[22:47] <jnthn> Just a waste of a PMC every time we need to throw an exception...

[22:47] <jnthn> Parrot's entire exceptions implementation seems optimized to be as slow and unhelpful as possible.

[22:48] *** masak joined
[22:49] <pmichaud> ugh, HLL::Compiler needs a big refactor of its names.

[22:49] <pmichaud> people have confused "interactive mode" and "commandline"

[22:50] <pmichaud> "commandline_banner" is really "interactive_banner"

[22:50] <pmichaud> s/is/should be/

[22:51] <jnthn> OK, I cba to fight the exception stuff tonight. I either leave it for pmichaud++ or I look tomorrow :)

[22:51] <pmichaud> yes, I want to work on fail() also, so I can look at exceptions too.

[22:51] <pmichaud> also I want to fix up ll-backtrace in HLL::Compiler a bit

[22:51] <pmichaud> so tonight may just be an exceptional night for me :)

[22:51] <jnthn> \o/

[22:52] <sorear> how does fail work?

[22:52] <masak> it just returns a Failure object, no?

[22:53] <sorear> masak: it also twiddles CALLER::CALLER so that it will die on return if the failure isn't handled

[22:53] <pmichaud> and if the Failure is used, it throws an exception

[22:54] <sorear> masak: S04:1277

[22:54] <pmichaud> sorear: I think that's somethign different than what I'm describing.

[22:54] <sorear> I'm also confused by the "can be stored in any container whose type allows the Failure role to be mixed in" language

[22:55] *** Pathin_ left
[22:56] *** Pathin_ joined
[22:56] *** masak left
[22:58] *** sivoais joined
[23:01] *** mattp_ joined
[23:04] *** Pathin_ left
[23:06] *** Pathin_ joined
[23:14] *** Pathin_ left
[23:14] *** colomon left
[23:15] *** pjcj joined
[23:15] *** Pathin_ joined
[23:17] *** wamba left
[23:24] *** Pathin_ left
[23:25] *** Pathin_ joined
[23:28] *** daniel-s joined
[23:29] <daniel-s> good morning

[23:29] <phenny> daniel-s: 20:27Z <TimToady> tell daniel-s "http%3A%2F%2Ffoo%20bar%2F".subst(/'%' (<[0..9A..F]> ** 2)/, -> $/ { chr(:16($0)) }, :g).say

[23:32] <daniel-s> wow

[23:34] *** Pathin_ left
[23:35] *** Pathin_ joined
[23:36] <TiMBuS> decoding urls huh

[23:38] <daniel-s> rakudo: "http%3A%2F%2Ffoo%20bar%2F".subst(/'%' (<[0..9A..F]> ** 2)/, -> $/ { chr(:16($0)) }, :g).say

[23:38] <p6eval> rakudo b2bc99: OUTPUT«http://foo bar/␤»

[23:38] <daniel-s> http://rosettacode.org/wiki/URL_decoding

[23:38] <daniel-s> I was trying to solve that last night

[23:39] <daniel-s> I want to put his solution up there next to mine

[23:40] <daniel-s> 33 lines, vs 1 line

[23:43] <TiMBuS> http://cpansearch.perl.org/src/GAAS/URI-1.58/URI/Escape.pm scroll to bottom

[23:44] *** Pathin_ left
[23:45] *** Pathin_ joined
[23:52] *** molaf_ joined
[23:54] *** Pathin_ left
[23:55] *** Pathin_ joined
[23:55] <sorear> good morning daniel-s

[23:55] *** molaf left
