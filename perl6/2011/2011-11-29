[00:04] *** icwiener joined
[00:06] <jnthn> sleep &

[00:08] *** fridim_ left
[00:08] *** tokuhirom joined
[00:09] *** tokuhirom left
[00:11] *** ethndbst joined
[00:11] *** hundskatt left
[00:12] *** pmurias left
[00:13] *** replore_ joined
[00:54] *** tokuhirom joined
[01:09] *** tokuhirom left
[01:13] *** woosley joined
[01:33] <[Coke]> colomon: so, how DOES one generate sheet music from ABC? do you have to first convert to lilypond and then use that?

[01:33] <colomon> [Coke]: yes

[01:34] <colomon> don't tell me you're porting it to nom?

[01:35] <[Coke]> no.

[01:35] <colomon> I think the command line needs to be something like perl6 bin/abc2ly.pl <my-tune.abc >my-tune.ly

[01:35] <[Coke]> though I may have to to enable my kid's project.

[01:35] <[Coke]> for now, just trying to install lilypond via macpors.

[01:35] <[Coke]> *macports

[01:38] <colomon> I think I ended up installing it from http://lilypond.org/download.html

[01:39] <colomon> which is slightly not perfect, because as far as I can tell it doesn't install a command-line client, which would be the most convenient way to handle the next step

[01:45] *** plutoid joined
[01:55] *** wolfman2000 left
[02:01] *** benabik joined
[02:13] *** ethndbst left
[02:18] *** rgrau` left
[02:32] <dalek> niecza: 557c6d8 | sorear++ | README.pod:

[02:32] <dalek> niecza: Document LF requirement in README

[02:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/557c6d814d

[02:32] *** cooper left
[02:42] *** Guest46100 left
[03:25] <dalek> roast: fface8f | coke++ | S05-mass/properties-general.t:

[03:25] <dalek> roast: rakudo unfudging

[03:25] <dalek> roast: review: https://github.com/perl6/roast/commit/fface8f8f3

[03:26] <dalek> rakudo/nom: 51838a5 | coke++ | t/spectest.data:

[03:26] <dalek> rakudo/nom: run fudged tests  (yay!)

[03:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/51838a5258

[03:27] <[Coke]> colomon: I am STILL installing lilypond prereqs. ;)

[03:27] <colomon> [Coke]: I'm trying to get ABC working on nom.  ;)

[03:27] <[Coke]> ah, good, maybe you'll be done by the time this finishes. ;)

[03:28] <colomon> if I can figure it out.  :)

[03:28] *** molaf joined
[03:32] *** wolfman2000 joined
[03:33] <[Coke]> pretty sure all those unfudges are due to diakopter++

[03:40] *** wolfman2_ joined
[03:40] *** wolfman2000 left
[03:44] *** khisanth_ joined
[03:44] <[Coke]> colomon: oooh, finally got to lilypond itself.

[03:45] *** Khisanth left
[03:48] *** replore_ left
[03:48] <colomon> \o/

[03:48] <colomon> I don't think there's any way I'm fixing this tonight, alas.

[03:50] *** wolfman2_ is now known as wolfman2000

[03:50] <colomon> perl6: say ("This" ~~ m/a/).perl

[03:50] <p6eval> rakudo 51838a: OUTPUT¬´Match.new(orig => "This", from => 4, to => -3, ast => Mu, list => ().list, hash => EnumMap.new())‚ê§¬ª

[03:50] <p6eval> ..pugs b927740: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HAND‚Ä¶

[03:50] <p6eval> ..niecza v11-28-g557c6d8: OUTPUT¬´Bool::False‚ê§¬ª

[03:51] <colomon> b: say ("This" ~~ m/a/).perl

[03:51] <p6eval> b 1b7dd1: OUTPUT¬´Match.new(‚ê§ from => 4,‚ê§ orig => "This",‚ê§ to   => -3,‚ê§)‚ê§¬ª

[03:52] <colomon> huh.

[03:52] <colomon> ABC tests have been broken all along, in that they weren't testing what I thought they were testing.

[03:53] <colomon> perl6: say ("This" ~~ m/a/).bool

[03:54] <p6eval> niecza v11-28-g557c6d8: OUTPUT¬´Unhandled exception: Unable to resolve method bool in class Bool‚ê§  at /tmp/11Ky6EtP8J line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2224 (ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2225 (module-CORE @ 58) ‚ê§  at /home/‚Ä¶

[03:54] <p6eval> ..rakudo 51838a: OUTPUT¬´Method 'bool' not found for invocant of class 'Match'‚ê§  in block <anon> at /tmp/ym7vf7tyoW:1‚ê§  in <anon> at /tmp/ym7vf7tyoW:1‚ê§¬ª

[03:54] <p6eval> ..pugs b927740: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HAND‚Ä¶

[03:54] <[Coke]> whoops.

[03:54] <colomon> perl6: say ("This" ~~ m/a/).Bool

[03:54] <p6eval> pugs b927740: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HAND‚Ä¶

[03:54] <p6eval> ..rakudo 51838a, niecza v11-28-g557c6d8: OUTPUT¬´Bool::False‚ê§¬ª

[03:55] *** satyavvd joined
[04:01] *** sftp left
[04:03] *** wolfman2_ joined
[04:03] *** wolfman2_ left
[04:04] *** wolfman2000 left
[04:06] *** jaldhar joined
[04:11] * sorear sends out v12 announce

[04:27] <colomon> \o/

[04:44] *** overrosy left
[04:47] *** overrosy joined
[04:52] *** jerome_ left
[05:13] *** wolfman2000 joined
[05:22] *** icwiener left
[05:36] *** jerome_ joined
[05:39] *** mkramer joined
[05:51] *** kaleem joined
[05:54] <Timbus> i asked marc lehmann(author of coro, EV, anyevent) about implementing libev and coro in perl 6 and well... i thought chromatic was a downer at times

[05:54] <Timbus> :[

[05:54] <sorear> haha

[05:55] <sorear> I guess you didn't know MLEHMANN's reputation

[05:55] <Timbus> i did

[05:55] <Timbus> i was expecting something like chromatic, and i got.. mlehmann.

[05:56] * sorear is kind of curious what mlehmann's reply way

[05:56] <sorear> was

[05:57] <Timbus> summary: perl6 is bad and you should feel bad

[05:57] <Timbus> he had more qualms with the language than any of my questions about getting libev into perl 6

[05:57] <sorear> thought so.

[05:58] <Timbus> which, i just noticed, he didnt answer

[05:58] <Timbus> aaa

[05:58] <sorear> seems to me it's a bad question; libev is a C library

[06:00] <sorear> mlehmann is very good at finding the flaws in things, and he's usually right

[06:00] <Timbus> well that wasn't the issue. i was wondering if someone who was admittedly very experienced at writing event sbased programs, would have any good ideas for an event based system in perl 6, which could be better built around an event system

[06:00] <Timbus> instead of having it 'added on' later

[06:01] *** localhost left
[06:01] <sorear> too late

[06:01] <Timbus> never~

[06:01] <sorear> most of the important architectural stuff in p6 is already non-negotiable

[06:02] <Timbus> but the most slushy of the specs is specifically, coroutines, threads, signals

[06:02] *** localhost joined
[06:04] <Timbus> also having event-aware IO libraries instead of adding them later, which is what has to be done in perl 5

[06:04] *** mkramer1 joined
[06:04] <Timbus> stuff regarding the core libs

[06:04] <sorear> Timbus: did mlehmann say anything constructive about how to deal with events?

[06:04] <Timbus> not the core language itself

[06:04] <Timbus> not a peep! time to pull apart libev and anyevent

[06:05] <sorear> Timbus: note that Perl 6 has built-in coroutines.  if I were designing event stuff, I'd probably make it look more like Coro::EV

[06:05] <Timbus> he did tell me to give up on threads and use fork. which doesnt help on windows :/

[06:05] <Timbus> perl6 doesnt expose its coroutines enough for me to get anywhere :{

[06:06] *** mkramer left
[06:07] <Timbus> i tired using exceptions and resume, and the coroutine example in the spec using pipes. gather and take could work but how do you abstract the syntax away (without macros)

[06:07] <Timbus> tried*

[06:07] <Timbus> (the first two attempts didnt work)

[06:09] <Timbus> are context switches considered exceptional enough

[06:12] *** kaleem left
[06:14] <sorear> you can abstract the syntax with just ordinary functions

[06:15] <Woodi> hmm, what 'drop threads means' ?

[06:16] <Timbus> "If you want to do it right, use multiple processes, let the mmu do its work instead of trying to emulate it in software, and make sharing of variables between processes fast.  Thats actually is the future, since multi core cpus will become very common, the core number will increase, and threads are made for single-core performance and their performance hurts on multiple cores."

[06:16] <Timbus> quoting marc.

[06:16] * Timbus just slowly walks away from that one

[06:17] <sorear> niecza: my @queue; sub start($f) { push @queue, $(gather { my $*coro__yield = { take 0 }; $f() }) }; sub yield() { $*coro__yield.() }; sub rub() { loop { my $l = shift @queue; push @queue, $l; $l.shift } };  for <a b c> -> $x { start { (say $x; yield) while 1 } }; run

[06:17] <p6eval> niecza v12: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Confused at /tmp/s4N3SB2b5v line 1:‚ê§------> [32mhift @queue; push @queue, $l; $l.shift }[33m‚èè[31m };  for <a b c> -> $x { start { (say $x[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[06:17] * geekosaur thinks there's a certain amount of truth to that... and a certain amount of falsehood

[06:18] <sorear> niecza: my @q;sub start($f){push @q,$(gather{my $*coro__yield={take 0};$f()})}; sub yield(){ $*coro__yield.() }; sub run(){loop {my $l=shift @q;push @q,$l;$l.shift}};  for <a b c> -> $x { start { (say $x; yield) while 1 } }; run

[06:18] <p6eval> niecza v12: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§ 'gather' used at line 1‚ê§‚ê§‚ê§Unhandled Exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 880 (die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1139 (P6.comp_unit @ 32) ‚ê§  at /home/p6eval/n‚Ä¶

[06:18] <sorear> niecza: my @q;sub start($f){push @q,$(gather {my $*coro__yield={take 0};$f()})}; sub yield(){ $*coro__yield.() }; sub run(){loop {my $l=shift @q;push @q,$l;$l.shift}};  for <a b c> -> $x { start { (say $x; yield) while 1 } }; run

[06:18] <p6eval> niecza v12: OUTPUT¬´(timeout)a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê§b‚ê§c‚ê§a‚ê

[06:18] <sorear> \o/

[06:18] *** cognominal joined
[06:20] <sorear> Timbus: that is a very p5 response

[06:20] <Timbus> it is

[06:20] <Timbus> and only a small portion of his rant :D

[06:20] <TimToady> in my view, any lazy list is a candidate to turn into an event queue between threads

[06:20] <geekosaur> but it does depend on the thread model.  haskell's threads are designed to be a model for multiple cores, as are p6's; I wonder if he understood that

[06:20] <Woodi> can someone write gather take manual pls ? :)

[06:21] <sorear> No.

[06:21] <Woodi> why no ? :)

[06:21] <Woodi> not much in spec

[06:21] <sorear> gather and take are very primitive; they cannot be implemented correctly in terms of any other primitive

[06:21] <geekosaur> as for example POSIX threads are *not*, and as such do not map well to multicore

[06:22] <Timbus> they dont?

[06:22] <geekosaur> not really

[06:22] <TimToady> in any case, resumable exceptions are not up to the kind of threading I'm leaning towards

[06:22] *** cognominal___ left
[06:22] <sorear> I think the thing we really need to be careful of here is to avoid confusing things that shouldn't be confused

[06:23] <TimToady> I'd like to see low-level scheduling proceed much as in Erlang or Go

[06:23] <geekosaur> you can write things that work reasonably in a multicore environment, but it's not really what they're designed for

[06:23] *** envi_ joined
[06:23] <Timbus> TimToady, well, less to do with threading, more to do with a way to resume events that would otherwise freeze an event system

[06:23] <sorear> Haskell did something very very right when they decided that "parallel" and "concurrent" were not the same thing

[06:23] <TimToady> sure, you have to know what blocks

[06:23] <geekosaur> yes

[06:23] <geekosaur> (to both of those, actually :)

[06:24] <Timbus> i do know what blocks! what do i do next :v

[06:24] <Timbus> in perl 5 i use Coro::Handle

[06:26] <sorear> it depends on what your goal is, and what programming paradigm you want to use to achieve it.

[06:26] *** kaleem joined
[06:26] <TimToady> the details of that may be outside of Perl 6 proper, to the extent that our parallel ops are primitives that don't commit to a particular method, but merely specify what you want solved

[06:26] *** agentzh joined
[06:27] <sorear> [how much sense does it make to share an epoll/kqueue descriptor between kernel threads?]

[06:27] <TimToady> our parallel primitives are primarily trying to promise what you do and don't care about, and let the underlying system solve that within the constraints

[06:27] <Timbus> so what I'm picking up from this is for perl 6, the idea would be to wrap my blocking callback in an async?

[06:27] <TimToady> so it's completely bogus to say that it must be done with fork, or with green threads, or with your GPU, or your cell processor; all of these have strengths and weaknesses

[06:28] <Timbus> that's fair

[06:28] <TimToady> but as you say, we might want more syntax, maybe

[06:28] *** sftp joined
[06:28] <sorear> for the most syntactically light parallel things, like hyperops, we'll probably need pragmas to make this sane

[06:28] <TimToady> but I'd like to see event dispatch tied rather closely to function multi-dispatch, as it is in Erlang

[06:29] <Timbus> !

[06:29] <Timbus> that's what I was thinking when I made my IRC bot

[06:29] <TimToady> an event is just a funny capture

[06:29] <sorear> TimToady: I'm not very familiar with that

[06:29] <sorear> how is it related to the actor model?

[06:30] <TimToady> sorear: sure, the computer is not always going to guess right

[06:30] <TimToady> as far as I know, Erlang *is* an actor model

[06:32] <TimToady> otoh, even if the computer doesn't guess right the first time, it's probably more important to guess right when you do something more than once, and then you can remember what worked well and what didn't from run to run

[06:33] <dalek> rakudo/nom: 4269d73 | moritz++ | t/spectest.data:

[06:33] <dalek> rakudo/nom: the Unicode properties regex tests need ICU

[06:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4269d73e79

[06:34] <TimToady> on the gripping hand, there's no guarantee you'll have the same resources from run to run

[06:34] <sorear> TimToady: *not-very-useful-mode* The actor model I am most familiar with is Io's

[06:36] <sorear> Io supports an 

[06:36] <sorear> Io supports a @@method call syntax, which queues the method call on the target object's thread (lazily created if it doesn't exist yet)

[06:37] <sorear> also @method, which returns a Promise object, that can be forced to obtain the return value (putting the current thread to sleep if needed)

[06:38] *** hundskatt joined
[06:39] <sorear> what granularity does Erlang make threads for?  does it also do OO and "one thread per object"?

[06:42] <TimToady> basically any time you send an event to an event handler, it's a thread; everything is event-based, and there's a strong bias towards value semantics as you might expect in an FP language; more than that I can't say without getting more familiar

[06:44] <sorear> there is also an "abort problem"

[06:44] <sorear> I haven't fully conceptualized it, but cancelling operations in an event-driven system is not quite easy

[06:45] <TimToady> well, event-based processing is low level, and pretty much the antithesis of transactional processing

[06:45] <sorear> you need to somehow keep track of what event handlers and what blocking syscalls are connected to what high-level operations

[06:46] <TimToady> the plan as been for Perl 6 to support both levels, with some kind of scheduler in between eventually

[06:46] <TimToady> *has

[06:46] <sorear> e.g. pressing 'Stop' in a web browser needs to close sockets, cancel async-DNS, kill parser threads, etc

[06:47] <TimToady> yes, that is much more convenient to handle on a transactional level

[06:47] <sorear> could you elaborate on that?

[06:47] <Woodi> Erlang works on VM so names can mean other things. so answer is needed how Erlang shedulers work... http://stackoverflow.com/questions/605183/how-if-at-all-do-erlang-processes-map-to-kernel-threads

[06:48] <sorear> is there an established theory of network programming at the transactional level?

[06:48] <TimToady> I'm sure there are several of 'em :)

[06:49] * sorear has Erlang in the 'need to learn more about' box

[06:50] <sorear> TimToady: how much has been written about the "transactional level" in the context of blocking I/O in Perl 6?  this is the first I've heard of it

[06:50] <sorear> I'm guessing this isn't related to S1x's talk of STM, since in Haskell-land that's one of the cardinal rules - no I/O in a transaction

[06:52] <sorear> [tangentially, I have major issues with how S1x talks about dynamically thread-localizing variables]

[06:53] <Woodi> I was reading yesterday orginal paper for Actor model from 70s and all definitions/lemas/proofs was done for proceses, there was no threads yet. on the other hand maybe it was a paper about "we can use messengers/messages to do parallel computation" (messangers are actors too). probably threads should just use reading memory...

[06:53] *** Chillance left
[06:54] *** koban joined
[06:54] <sorear> Woodi: the word "process" in the 70s meant something closer to what "thread" does today

[06:55] <Woodi> didnt't know. no idea how it worked then

[06:56] <Timbus> and now, fork goes out of its way to share memory until something writes. how far we have come

[06:57] <Timbus> did fork really used to spawn an entire new process? because wow

[06:58] <Woodi> so there is confusion, let define maybe things. thread can be kernel or user space, posix is then user space

[06:58] <Woodi> ..in user space managed by kernel threads ?

[06:59] <Timbus> im actually only familiar with windows threads.

[06:59] <Timbus> but that sounds a bit crazy

[06:59] <Woodi> green threads looks like higher lvl concept

[07:00] <Woodi> in Windows threads are like proceses in unix world

[07:01] <sorear> Timbus: the first Unix limited processes to 8kb of writable data segment, so copying all of it was not insane.

[07:02] <Timbus> lol. touche

[07:02] <sorear> (this is what happens when you try to turn a PDP-7 into a multiuser system)

[07:03] *** koban left
[07:03] <Timbus> sorear, i like this gather take implementation, but can you call 'take' from $f()

[07:03] <Timbus> .. why dont I just try it

[07:03] <sorear> Timbus: man 2 vfork may also enlighten you.

[07:03] *** sftp left
[07:03] <sorear> Timbus: you can in niecza but this is a bug.

[07:03] <Timbus> oh. of course. coro_yield is calling take

[07:03] <Timbus> so yes, its doing exactly that

[07:04] *** wolfman2000 left
[07:04] <Timbus> oh. scoping

[07:04] <sorear> I don't know if it's actually in the synopses yet but the most recent Rule-1 ruling is that only 'take's lexically inside the 'gather' can couple to the 'gather'

[07:05] <Timbus> yep that's fair

[07:05] <sorear> Niecza is still using the older rule that gather/take is dynamically scoped

[07:05] <Timbus> but since coro_yield is a closure, thats alright?

[07:06] <sorear> right

[07:06] <Timbus> cool. just making sure

[07:11] <masak> morning, #perl6

[07:11] <sorear> o/ masak

[07:11] <nebuchadnezzar> morning

[07:11] <sorear> o/ nebuchadnezzar

[07:13] <sorear> randomly: I think lexically scoped but dynamically evaluated variables would be a good addition

[07:13] <sorear> it's not cool that I have to fake scoping like $*coro__yield

[07:14] <sorear> my $yield; ... temp $yield = ... is _almost_ good enough, but that way is not threadsafe

[07:19] <Woodi> maybe there should be Inter Perl6 Communication specced in some way ? :) will help to coexists betwin many v6 implementations

[07:20] <Woodi> + threads|STM in runtime and every features are in :)

[07:22] <Woodi> continuations are just rich subs ? threads are below ?

[07:26] <Woodi> everything can be coded in modules but /me things that languages take particular niche becouse of what technology is "in core"... do not missinterpret as "many features in core"

[07:30] <Woodi> ok, no one listen, I will go work some :)

[07:32] <Woodi> btw. todays Garfield is nice :)

[07:52] *** alvis left
[07:55] <colomon> ugh

[08:11] <sorear> Woodi: I hate to be this blunt, but I'm not responding because I can't make sense of what you're saying.

[08:12] * moritz neither

[08:23] *** mkramer1 left
[08:27] <Timbus> is it strange that i get it? :I

[08:28] <Timbus> sorear, does this gather/yield system require you (the event loop maker) to wrap every dispatched event inside a gather

[08:30] <Timbus> coro::handle for example, doesn't need that. a regular event sub can just wait on a handle and other events (and coro threads) all loop like normal

[08:30] <colomon> moritz: so, I've got regex accidental { '^' | '^^' | '_' | '__' | '=' }, and the debugger shows it's matching '^' and not going on to match '^^'.  What should I be doing to solve that?

[08:30] <colomon> btw, jnthn++ # Grammar::Tracer rocks

[08:32] <Timbus> put your longer tokens first?

[08:32] <colomon> Timbus: I think LTM means that shouldn't work.  But it's possible I'm completely misunderstanding it.

[08:32] <Timbus> oh i misunderstood

[08:32] * colomon is reading the spec now

[08:33] *** fhelmberger left
[08:33] <Timbus> i was just recalling ltm used to not work, but that was way ages ago

[08:33] <colomon> wait, it's *longest* -- shouldn't it automatically work, then?

[08:33] <Timbus> i assumed from what you said, it was still not working

[08:33] *** muixirt joined
[08:33] <colomon> Timbus++

[08:34] <Timbus> i got karma and i dont know how! :D

[08:34] <colomon> like I said, it was possible I was completely misunderstanding it.  I was saying longest token and thinking shortest.  :)

[08:34] <Timbus> oh

[08:36] *** fhelmberger joined
[08:36] <colomon> and reordering does indeed fix the problem in nom.  based on my reading of the spec, this is clearly a nom bug.  (And I think one that b got correct, even though it didn't have working LTM as far as I know.)

[08:37] <Timbus> odd

[08:38] <masak> nom: '^^^^' ~~ / ('^' | '^^')+ /; say $0.elems

[08:38] <p6eval> nom 4269d7: OUTPUT¬´4‚ê§¬ª

[08:38] * masak submits rakudobug

[08:39] <masak> niecza: '^^^^' ~~ / ('^' | '^^')+ /; say $0.elems

[08:39] <p6eval> niecza v12: OUTPUT¬´2‚ê§¬ª

[08:39] <colomon> masak++ # forgive me for assuming that was already known

[08:39] <Timbus> i knew it :v

[08:39] <masak> maybe it is already known. I dunno.

[08:39] <masak> niecza: '^^^^' ~~ / '^' | '^^' /; say $/.chars

[08:40] <p6eval> niecza v12: OUTPUT¬´2‚ê§¬ª

[08:40] <masak> seems there's some interaction between LTM and quantifiers and possibly capturing groups.

[08:40] <masak> oh wait, that's niecza :)

[08:40] <masak> nom: '^^^^' ~~ / '^' | '^^' /; say $/.chars

[08:40] <p6eval> nom 4269d7: OUTPUT¬´1‚ê§¬ª

[08:40] <Timbus> is the solution to properly collapse '|' in regex into an unordered list or,

[08:40] <masak> nope, it's just LTM that's hosed :)

[08:40] <Timbus> is LTM more complicated than that

[08:41] *** aindilis left
[08:41] <Timbus> is anything about regexes not complicated

[08:41] *** aindilis joined
[08:41] <masak> Timbus: short answer: all declarative prefixes of the transitive closure of alternatives and subrule calls should be treated on equal footing.

[08:43] <masak> if that's what you meant by "properly collapse", then yes.

[08:43] <masak> I believe QRegex attempts this, but I haven't looked at the source code

[08:43] <Timbus> that is what i meant, in many more words

[08:43] <colomon> Can not bind non-existant attribute '$!orig' on class 'Cursor' -- known bug?

[08:44] <Timbus> but is it a fair 'cheat' to make the longer alternatives slightly more important

[08:44] <Timbus> or does LTM happen in other cases

[08:45] <Timbus> like. would LTM be fixed just by reordering alternatives, or is there more to it? i ask mostly out of childlike curiosity

[08:45] <moritz> colomon: LTM is simply not working well enough

[08:45] <arnsholt> Timbus: As long as you've no subrule calls that'd work

[08:45] <moritz> colomon: re-ordering the alternatives is a workaround until it's fixed

[08:45] <arnsholt> But full LTM has to consider the prefixes of subrules as well

[08:45] <Timbus> ooo

[08:46] <colomon> moritz: danke.  any clue about the message Can not bind non-existant attribute '$!orig' on class 'Cursor' 

[08:46] <moritz> nom: say Curosor.^attributes

[08:46] <p6eval> nom 4269d7: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&Curosor' called (line 1)‚ê§¬ª

[08:46] <moritz> nom: say Cursor.^attributes

[08:46] <p6eval> nom 4269d7: OUTPUT¬´Method 'gist' not found for invocant of class 'NQPAttribute'‚ê§  in method gist at src/gen/CORE.setting:3700‚ê§  in sub say at src/gen/CORE.setting:5331‚ê§  in block <anon> at /tmp/MbA73BYIbI:1‚ê§  in <anon> at /tmp/MbA73BYIbI:1‚ê§¬ª

[08:47] <Timbus> oh deer

[08:47] <moritz> ouch

[08:47] <moritz> nom: say Cursor.^attributes.map(*.name)

[08:47] <p6eval> nom 4269d7: OUTPUT¬´No type check cache and no type_check method in meta-object‚ê§  in method reify at src/gen/CORE.setting:3980‚ê§  in method gimme at src/gen/CORE.setting:4341‚ê§  in method reify at src/gen/CORE.setting:4073‚ê§  in method reify at src/gen/CORE.setting:3980‚ê§  in method reify at‚Ä¶

[08:47] <moritz> oh deer ** 2

[08:47] <masak> o.O

[08:47] <moritz> nom: say Grammar.^attributes

[08:47] <p6eval> nom 4269d7: OUTPUT¬´Method 'gist' not found for invocant of class 'NQPAttribute'‚ê§  in method gist at src/gen/CORE.setting:3700‚ê§  in sub say at src/gen/CORE.setting:5331‚ê§  in block <anon> at /tmp/N19QyHaHC6:1‚ê§  in <anon> at /tmp/N19QyHaHC6:1‚ê§¬ª

[08:47] <moritz> nom: say Int.^attributes

[08:47] <p6eval> nom 4269d7: OUTPUT¬´Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'‚ê§  in method gist at src/gen/CORE.setting:3700‚ê§  in sub say at src/gen/CORE.setting:5331‚ê§  in block <anon> at /tmp/95oqbTUbEa:1‚ê§  in <anon> at /tmp/95oqbTUbEa:1‚ê§¬ª

[08:48] <moritz> jnthn: it seems that introspection is broken-ish

[08:49] * sorear -> sleep

[08:49] <colomon> o/

[08:49] <colomon> hmmm.... nqp::bindattr($match, Match, '$!orig', nqp::getattr(self, Cursor, '$!orig'));

[08:50] <Timbus> nom: say Int.^methods.grep(* eq 'gist')

[08:50] <p6eval> nom 4269d7: OUTPUT¬´gist gist‚ê§¬ª

[08:50] <Timbus> wuh

[08:50] <masak> sorear++ # v11

[08:50] <Timbus> say Cursor.^methods.grep(* eq 'gist')

[08:51] <Timbus> nom: say Cursor.^methods.grep(* eq 'gist')

[08:51] <p6eval> nom 4269d7: OUTPUT¬´Unmarshallable foreign language value passed for parameter '$_'‚ê§  in method reify at src/gen/CORE.setting:4073‚ê§  in method reify at src/gen/CORE.setting:3980‚ê§  in method reify at src/gen/CORE.setting:3980‚ê§  in method gimme at src/gen/CORE.setting:4341‚ê§  in method eage‚Ä¶

[08:51] <moritz> sorear++ # v12

[08:51] <Timbus> :I

[08:51] <masak> er, v12 :)

[08:52] <Timbus> yapsi is still gunna win :3

[08:52] *** mj41 joined
[08:53] <masak> heh ;)

[08:54] <masak> Timbus: I'm excited to see you experiment with abstracting coroutines from gather/take in the backlog.

[08:54] <masak> Timbus: people have been telling me this should be possible, but I've never succeeded either.

[08:54] *** jerome_ left
[08:55] *** jerome_ joined
[08:56] *** muixirt left
[08:57] <Timbus> i'd still prefer resumable exceptions. they feel more flexible, and already package .resume into the exception you caught

[08:57] <Timbus> except at the moment, they don't

[08:57] <Timbus> a minor detail

[08:57] <moritz> so what's the task? writing a wrapper and a yield() so that one can write   coro {  code; yield $value; code? }  ?

[08:58] <Timbus> that's a pretty good start

[08:58] *** hundskatt left
[08:59] <Timbus> and sorear already managed to do that

[08:59] <colomon> nom: grammar X { regex number { <digit>+ }; regex note_length_denominator { '/' <bottom=number>? }; regex note_length { <top=number>? <note_length_denominator>? }; };  say X.parse("2", :rule<note_length>);

[08:59] <p6eval> nom 4269d7: OUTPUT¬´=> <2>‚ê§ top => <2>‚ê§  digit => <2>‚ê§ number => <2>‚ê§  digit => <2>‚ê§‚ê§¬ª

[08:59] <moritz> nom: sub coro(&c) { gather c() }; sub yield(|$a) { take $a }; my @a := coro { say 1; take 2; say 3 }; say "done"; say @a;

[08:59] <p6eval> nom 4269d7: OUTPUT¬´done‚ê§1‚ê§3‚ê§2‚ê§¬ª

[08:59] <colomon> woah, that's exploding on my local nom

[09:00] <moritz> colomon: on what revision are you on? (or how old is it?)

[09:00] <colomon> moritz: today

[09:00] <colomon> I mean, about thirty minutes ago

[09:00] <moritz> hm

[09:00] <colomon> maybe should rebuild it from scratch?

[09:01] *** s1n left
[09:01] <moritz> maybe

[09:03] <Timbus> moritz, did.. did it work?

[09:03] <Timbus> you also didn't use yield

[09:03] <moritz> Timbus: no. I would have expect it to print 1 before done

[09:03] <Timbus> thought so

[09:03] <moritz> nom: sub coro(&c) { gather c() }; sub yield(|$a) { take $a }; my @a = coro { say 1; yield 2; say 3 }; say "done"; say @a;

[09:03] <p6eval> nom 4269d7: OUTPUT¬´1‚ê§3‚ê§done‚ê§2‚ê§¬ª

[09:04] <Timbus> hehe

[09:04] <moritz> hm, now it's too eager

[09:04] <Timbus> did you see sorear's attempt?

[09:04] <moritz> nom: sub coro(&c) { gather c() }; sub yield(|$a) { take $a }; my @a := coro { say 1; yield 2; say 3 }; say "done"; say @a;

[09:04] <p6eval> nom 4269d7: OUTPUT¬´done‚ê§1‚ê§3‚ê§2‚ê§¬ª

[09:04] <moritz> Timbus: no

[09:04] <Timbus> it required a scheduler and I don't think it made it back to the main thread

[09:05] <Timbus> since the main thread.. scheduled

[09:07] <Timbus> sub coro(&c) { gather { c({take $_}) } }

[09:08] <Timbus> maybe

[09:08] <moritz> uhm.

[09:09] <jnthn> morning

[09:09] <Timbus> sorear mentioned take needs to happen in the lexical

[09:10] <Timbus> so. bundle it up and pass it to the coro sub as 'yield'?

[09:10] <moritz> hm

[09:11] <jnthn> LTM is only done for the protoregex case so far. It can handle alternations within those, mind. The pure alternation case isn't set up yet, however.

[09:11] <moritz> nom: my &yield; sub coro(&c) { gather { &yield := sub(|$a) { take |$a }; c; } }; my @a := coro { say 1; yield 2; say 3 }; say "done"; say @a

[09:11] <p6eval> nom 4269d7: OUTPUT¬´===SORRY!===‚ê§Variable $a is not predeclared at line 1, near ") { take |"‚ê§¬ª

[09:12] <moritz> nom: my &yield; sub coro(&c) { gather { &yield := sub ($a) { take $a }; c; } }; my @a := coro { say 1; yield 2; say 3 }; say "done"; say @a

[09:12] <p6eval> nom 4269d7: OUTPUT¬´done‚ê§1‚ê§3‚ê§2‚ê§¬ª

[09:13] *** khisanth_ is now known as Khisanth

[09:15] <Timbus> https://gist.github.com/1404124 this is what sorear did, moritz 

[09:15] <Timbus> needs scheduler

[09:15] <Timbus> yes. yes i do use hard tabs. 

[09:16] <jnthn> moritz: It's not an introspection problem per se. It's just that cursors get many of their methods and attributes from a role written in NQP. So when you go introspecting, you get objects from outside of the Perl 6 type system. Thus they don't really behave as you want.

[09:16] <moritz> jnthn: say Int.^attributes

[09:16] <moritz> nom: say Int.^attributes

[09:16] <p6eval> nom 4269d7: OUTPUT¬´Method 'gist' not found for invocant of class 'BOOTSTRAPATTR'‚ê§  in method gist at src/gen/CORE.setting:3700‚ê§  in sub say at src/gen/CORE.setting:5331‚ê§  in block <anon> at /tmp/CyoHisCpmh:1‚ê§  in <anon> at /tmp/CyoHisCpmh:1‚ê§¬ª

[09:16] <jnthn> moritz: Same story.

[09:17] *** JimmyZ joined
[09:17] <moritz> but shouldn't it work on Perl 6 core types?

[09:17] <moritz> nom: say Match.^attributes

[09:17] *** s1n joined
[09:17] <p6eval> nom 4269d7: OUTPUT¬´Attribute.new() Attribute.new() Attribute.new() Attribute.new() Attribute.new() Attribute.new() Attribute.new()‚ê§¬ª

[09:17] <moritz> argl

[09:17] <moritz> nom: say Match.^attributes[0].gist

[09:17] <p6eval> nom 4269d7: OUTPUT¬´Attribute.new()‚ê§¬ª

[09:18] <jnthn> moritz: Yes, it should work in both of these cases.

[09:18] <jnthn> Just didn't get there yet

[09:19] <moritz> jnthn: ok :-)

[09:23] <colomon> Incorrect pre-compiled version of src/gen/Metamodel.pm loaded  ????

[09:24] <moritz> that means that some rest of an old installation or build are around somewhere :(

[09:25] <colomon> I completely blew away my old nom install and started from scratch here

[09:25] <colomon> maybe it's in ~/.perl6?

[09:25] <jnthn> Possibly

[09:25] <jnthn> It tends to relate to leftover .pir files.

[09:25] *** JimmyZ left
[09:26] *** JimmyZ joined
[09:26] <dalek> rakudo/nom: c285a5e | moritz++ | src/core/Attribute.pm:

[09:26] <dalek> rakudo/nom: fix Attribute.gist

[09:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c285a5e1f2

[09:27] <colomon> for what it's worth, there's no sign of a "Metamodel.pir" in my ~/.perl6 or my nom install

[09:28] *** cognominal_ joined
[09:30] *** mkramer joined
[09:30] <colomon> ./install/lib/parrot/3.10.0-devel/languages/nqp/lib/Perl6/Metamodel.pbc

[09:30] <colomon> ./src/gen/Metamodel.pm

[09:30] <colomon> ./src/Perl6/Metamodel

[09:30] <moritz> ./install/lib/parrot/3.10.0-devel/languages/nqp/lib/Perl6/Metamodel.pbc might be it

[09:31] <colomon> removing it gets me a different error

[09:31] *** cognominal left
[09:32] <moritz> which one?

[09:32] <jnthn> The problem will almost certainly be something leftover that was compiled against an older Metamodel.pm.

[09:32] <colomon> t/01-regexes.t .. Could not find Perl6::Metamodel in any of: ., blib, /Users/colomon/tools/nom/rakudo/install/lib/parrot/3.10.0-devel/languages/perl6/lib, /Users/colomon/tools/nom/rakudo/install/lib/parrot/3.10.0-devel/languages/nqp/lib

[09:32] <colomon> current instr.: 'nqp;Perl6;ModuleLoader;load_module' pc 3656 (src/gen/perl6-moduleloader.pir:1649) (src/Perl6/ModuleLoader.pm:100)

[09:32] <colomon> ca

[09:33] * jnthn really needs to look in to the error reporting for this stuff; it's not really doing what it was intended to...

[09:34] <moritz> colomon: hm, need to run 'make install' again

[09:35] <colomon> okay, did that, and now I'm back to Incorrect pre-compiled version of src/gen/Metamodel.pm loaded

[09:38] <moritz> harrumpf.

[09:38] <jnthn> Yeah, I see what's going on.

[09:38] <jnthn> It loads a pre-compiled PIR file that is old

[09:38] <jnthn> It was built against an older Metamodel.pm

[09:39] <jnthn> Which it detects and complains about.

[09:39] <jnthn> Trouble is, it's a level too deep in its complaining.

[09:39] <jnthn> What's interesting is the file that is outdated and expected an older Metamodel.pm.

[09:40] <jnthn> Which it doesn't tell you. Sorry 'bout that...braino when I was implementing that stuff I guess.

[09:42] <Timbus> https://gist.github.com/1404124 wheeee

[09:42] <colomon> jnthn: mostly I'm worried because I did a fresh install of nom from scratch, and it just doesn't work.

[09:42] <Timbus> i almost look like a real programmer :>

[09:43] <jnthn> colomon: Did you have any pre-compiled PIR hanging around in your ~/.perl6/ ?

[09:44] <colomon> might have

[09:44] <Timbus> "unyeilded" hmm it seems im not real pro at grammar

[09:44] <moritz> but understandable :-)

[09:44] *** wk left
[09:44] <colomon> jnthn: yes

[09:44] *** mkramer left
[09:45] <jnthn> colomon: That's the issue here. When you pre-compile, it's tied to the Rakudo you used to pre-compile it (more specifically, to the setting)

[09:46] <jnthn> colomon: Meaning that those .pir files are now out of date.

[09:46] <moritz> jnthn: curiously, I get the same error from an installed rakudo, but the local one works fine

[09:47] <colomon> so is that what you meant about the error message being bad?  because I never would have guessed it was a problem with a module from that message...

[09:47] <jnthn> colomon: Exactly.

[09:47] <colomon> okay.

[09:47] <moritz> ah, now I understand :-)

[09:47] <colomon> bad news is, after 45 minutes trying to get my fresh nom working, I still get the same bizarre error:

[09:47] <colomon> Can not bind non-existant attribute '$!orig' on class 'Cursor'

[09:48] <jnthn> colomon: Ah, one of those.

[09:49] <jnthn> colomon: I can probably fix that fairly quickly if I can have either instruction to reproduce or (easier) the backtrace when running with --ll-exception

[09:50] <colomon> how's this?   https://gist.github.com/1404214

[09:50] <jnthn> moritz: I can see this "need to match up" issue will cause some confusion.

[09:51] <jnthn> moritz: Need to find some good way(s) to try and Do The Right Thing.

[09:51] <jnthn> colomon: looking

[09:51] <moritz> jnthn: if the error message says "the $pir_file was compiled with an incompatible rakudo version" (and lists the correct module .pir file, not Metamodel), I think it's quite understandable

[09:53] <jnthn> moritz: Well, I was also thinking of the issue where people upgrade their Rakudo and now the .pir files the module installer made are out of date.

[09:53] <tadzik> it's worse when people don't upgrade their Rakudo and the .pir files are out of date

[09:54] <moritz> jnthn: I see two possible solutions for that

[09:54] *** PacoLinux left
[09:54] <moritz> 1) rakudo overrides the .pir files with a new, correct version (possibly with some opt in, like an env variable)

[09:54] <moritz> 2) a tool-chain solution, like 'panda recompile' or so

[09:54] *** PacoLinux joined
[09:55] <jnthn> People have tended to really dislike the idea of (1) (having Rakudo try to manage pre-compilation)

[09:55] * tadzik has an example

[09:55] <jnthn> tadzik: I'd really like instructions on how to reproduce what you're seeing.

[09:55] <moritz> jnthn: I think it fits the ".pir are just cache files" meme very well if rakudo manages them

[09:56] <tadzik> https://gist.github.com/1404231

[09:56] <tadzik> jnthn: see above

[09:56] <jnthn> moritz: That was my view too :)

[09:58] <colomon> I guess I'd worry about what I'm facing right now -- the need to have two different versions of Rakudo installed.

[09:59] *** lestrrat left
[09:59] <moritz> colomon: I guess the easiest solution is to have two separate UNIX users :/

[09:59] <moritz> each having their own ~/.perl6/

[09:59] <colomon> Ugh

[10:00] <colomon> and then do I need a third user for niecza?

[10:00] <colomon> that seems like a worst case solution.

[10:00] <moritz> aye

[10:00] <moritz> I think the solution would be not to place the .pir files next to the .pm files

[10:00] *** lestrrat joined
[10:01] *** dakkar joined
[10:01] <jnthn> tadzik: Before it fails, it does

[10:01] <jnthn> env PERL6LIB=/home/tadzik/src/perl/panda/blib/lib:/home/tadzik/src/perl/panda/lib:/home/tadzik/.perl6/lib perl6

[10:02] <jnthn> tadzik: Is it possible finding a Tiny.pir in one of the previous directories than /home/tadzik/.perl6/lib, where you just installed one?

[10:02] <jnthn> *possibly

[10:05] <jnthn> moritz: That'd work.

[10:06] <jnthn> moritz: If we can work out where they go, and name that place with some kind of Rakudo version identifier.

[10:07] <moritz> ~./perl6/cache/rakudo/2011.11-68-gc285a5e/JSON/Tiny.pir ?

[10:07] <jnthn> moritz: Something like

[10:07] <moritz> maybe add a distinction for core vs. user modules

[10:07] *** JimmyZ left
[10:08] *** JimmyZ joined
[10:09] <tadzik> jnthn: nah, it's not there

[10:13] * colomon is going to try to go back to sleep

[10:14] *** jerome_ left
[10:14] <jnthn> tadzik: OK. Wonder if it's off-by-one error reporting confusing things again.

[10:14] *** jerome_ joined
[10:14] <kranius> hello #perl6

[10:16] <jnthn> tadzik: It isn't something to do with confusion between an installed JSON::Tiny and the one in ext folder in Panda, I guess?

[10:16] <moritz> \o kranius 

[10:16] *** jerome__ joined
[10:17] <tadzik> jnthn: no, this one's not using ext at all

[10:17] <tadzik> I can move it elsewhere, Justin Case

[10:17] <tadzik> yep, still happens

[10:18] <moritz> jnthn: any idea what  "Method 'instantiate_generic' not found for invocant of class 'Undef'" could mean?

[10:19] *** jerome_ left
[10:19] <jnthn> moritz: Generic instantiation is role related.

[10:19] <jnthn> moritz: Somewhow it must be trying to instantiate something that's not there.

[10:20] <jnthn> (it goes through various things in the role as it does this)

[10:20] <moritz> jnthn: I've copied&pasted the Str.trans code from b; no 'role' or 'does' or 'but' in there

[10:20] <jnthn> moritz: Oh.

[10:20] <jnthn> moritz: Ah, does it use any type captures?

[10:20] <jnthn> ::T in signature?

[10:21] <moritz> no

[10:21] <moritz> just a submethod

[10:23] <moritz> multi submethod even

[10:23] <jnthn> moritz: --ll-exception output?

[10:24] <moritz> nom: class A { multi submethod a() { }; multi submethod a(Int) { } }

[10:25] <p6eval> nom c285a5:  ( no output )

[10:25] <moritz> hm

[10:25] <moritz> jnthn: will see that I get one

[10:25] <jnthn> moritz: I just copy-pasted it into a file locally, changed the method into a sub and compiled it...and no error.

[10:26] <moritz> jnthn: https://gist.github.com/1404328

[10:26] <moritz> might be something bootstrappy :/

[10:27] <moritz> that's with ss:g/multi submethods/multi method/

[10:27] <jnthn> ah, this is in the core setting?

[10:27] <moritz> yes

[10:27] <jnthn> moritz: It's not just that things in the setting require an explicit proto method ... ?

[10:28] <moritz> jnthn: might be, didn't remember that

[10:28] * moritz tries

[10:28] <jnthn> It looks like proto auto-gen fails.

[10:29] * moritz tries with explicit protos

[10:33] <jnthn> moritz: I think this is going to need some debugging outside of the setting, though...the version of it with the sub doesn't actually work here.

[10:34] <moritz> :(

[10:34] <moritz> probably relies on autovivification and similar sugar

[10:38] <jnthn> moritz: OK, I fixed it

[10:38] *** daxim joined
[10:38] *** agentzh left
[10:38] <jnthn> moritz: Two things. First it wrongly relies in $!source being initializable from the default .new

[10:38] <jnthn> moritz: Adding a submethod BUILD(:$!source) { } in LSM fixes that.

[10:39] <jnthn> moritz: Second, the "@to = @to xx ceiling(@from / @to);" hits the notorious "splice not implemented in Mu" list bug.

[10:39] <jnthn> moritz: Evidently, not one of the cases I fixed at the weekend. :/

[10:40] <jnthn> moritz: Workaround is easy enough though.

[10:40] <jnthn> After that, trans("abc", "b" => "d"); gives me "adc" :)

[10:40] *** satyavvd left
[10:41] <jnthn> moritz: Also, die "Don't know how to handle a {.WHAT} as a substitution key";

[10:41] <jnthn> Needs a .gist on the .WHAT

[10:41] <moritz> jnthn: what's the workaround?

[10:41] <jnthn> moritz: Just assign to a different array

[10:43] <jnthn> moritz: or even easier

[10:43] <moritz> nom: my @t = 3, 4; @t = @t xx 3

[10:43] <p6eval> nom c285a5:  ( no output )

[10:43] <jnthn> moritz: get rid of the if block

[10:43] <jnthn> and just

[10:43] <jnthn> for @from Z (@to ?? @to xx ceiling(@from / @to) !! '' xx @from) -> $f, $t {

[10:43] <jnthn> Which will perform better anyway.

[10:44] <jnthn> moritz: It's array assignment to self + infinite parts in the list that seems to cause the bug. That's why I noted my fixes at the weekend as partial.

[10:44] * moritz tries

[10:44] <jnthn> Works here

[10:44] *** JimmyZ left
[10:44] <jnthn> moritz: https://gist.github.com/1404379 fwiw

[10:44] <moritz> I need to wait for a rakudo recompile before I can try it :/

[10:44] *** JimmyZ joined
[10:48] *** bacek left
[10:58] <moritz> nom: for 1 -> $, $ { }

[10:58] <p6eval> nom c285a5: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in block <anon> at /tmp/_e4PgCgHE5:1‚ê§  in method reify at src/gen/CORE.setting:4074‚ê§  in method reify at src/gen/CORE.setting:3981‚ê§  in method reify at src/gen/CORE.setting:3981‚ê§  in method gimme at src/g‚Ä¶

[11:00] <masak> nom: for 1 -> $, $? { }

[11:00] <p6eval> nom c285a5:  ( no output )

[11:00] <masak> nom: for 1 -> $, $? { }; say "alive"

[11:00] <p6eval> nom c285a5: OUTPUT¬´alive‚ê§¬ª

[11:01] *** agentzh joined
[11:01] *** bacek joined
[11:01] *** woosley left
[11:07] *** bacek left
[11:19] *** bacek joined
[11:36] <Woodi> "Agile is the answer to the paradox that we don't know what we should make until we already have a prototype of that thing."  http://perlalchemy.blogspot.com/2011/11/thesis-simple-antythesis-easy-synthesis.html

[11:37] <Woodi> fit to Perl6 and all NQP rewrites :)

[11:38] <Woodi> btw, NQP rewrites wasn't Rakudo rewrites as ppls say on PM

[11:39] <jnthn> If anybody bothered to look at the version control for nqp-rx to latest nqp, they'd see it was a series of step by step refactors rather than "throw it away and start over"

[11:40] <daxim> so it kept compatibility?

[11:40] <masak> with what?

[11:41] <jnthn> daxim: I'd say Rakudo's grammar and actions are the biggest things written in NQP, besides NQP itself. The main things that changed were the addition of some "use" statements because NQP got proper separate compilation and modules.

[11:46] <dalek> nqp: ef5f94f | mls++ | / (3 files):

[11:46] <dalek> nqp: use parrot op to switch to the profiling runcore

[11:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ef5f94f929

[11:47] <jnthn> Yes, it was basically, just use statements and fixing an accidental nested class because nested packages got fixed. Beyond that, it seems it compiled the Rakudo grammar and actions pretty much fine. Of course, the refactor towards a three way split (Grammar/Actions/World) came after that, but that wasn't due to NQP incompatibility.

[11:47] * jnthn just dug up the relevant commits out of curiosity.

[11:57] *** wk joined
[12:05] *** benabik left
[12:13] *** Psyche^ joined
[12:16] *** Patterner left
[12:16] *** Psyche^ is now known as Patterner

[12:16] *** plutoid left
[12:31] *** tokuhirom joined
[12:44] *** cognominal___ joined
[12:46] *** Trashlord joined
[12:47] *** cognominal_ left
[12:54] <dalek> roast: da97881 | moritz++ | S05-transliteration/trans.t:

[12:54] <dalek> roast: refudge trans.t for rakudo

[12:54] <dalek> roast: review: https://github.com/perl6/roast/commit/da978811c7

[12:56] *** benabik joined
[12:57] *** molaf left
[12:58] <colomon> jnthn: btw, Grammar::Tracer is *awesome*

[13:01] <dalek> roast: b76359c | moritz++ | integration/real-strings.t:

[13:01] <dalek> roast: rakudo unfudges

[13:01] <dalek> roast: review: https://github.com/perl6/roast/commit/b76359cc94

[13:01] <dalek> rakudo/nom: 01ac0d8 | moritz++ | src/core/ (2 files):

[13:01] <dalek> rakudo/nom: bring Str.trans back

[13:01] <dalek> rakudo/nom: 

[13:01] <dalek> rakudo/nom: Mostly a copy&paste from 2011.07, plus some fixes from jnthn++

[13:01] <dalek> rakudo/nom: and a few small optimizations that avoid some box operations

[13:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/01ac0d821b

[13:01] <dalek> rakudo/nom: d2e4b02 | moritz++ | t/spectest.data:

[13:01] <dalek> rakudo/nom: enable some tests for trans, as well as another test that depended on it

[13:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2e4b02258

[13:06] <jnthn> colomon: Happy you like it :)

[13:07] <colomon> jnthn: admittedly I'll like it even better when I'm not using it to diagnose strange nom regex bugs.  ;)

[13:08] <jnthn> colomon: Yeah; I need to look into the $!orig one a bit deeper. Need to take care of some $dayjob bits first, though.

[13:09] <moritz> jnthn: when I do something like   my str $r = $StrVar,   does that unbox or call the vtable?

[13:11] <jnthn> moritz: Call the vtable. Please explicitly nqp::unbox_s(...) for now.

[13:11] <jnthn> moritz: It's a pain to deal with this side of the QAST migration.

[13:12] <moritz> that's kinda... suboptimal

[13:12] <jnthn> I'm aware.

[13:12] <colomon> nom: say "545" ~~ m/ \d+ /

[13:12] <p6eval> nom c285a5: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "say \"545\" "‚ê§¬ª

[13:12] <moritz> I wonder what   my str $x = 42;  # is supposed to do

[13:12] * jnthn wonders what it does :)

[13:13] <jnthn> nom: my str $x = 42; say $x

[13:13] <p6eval> nom c285a5: OUTPUT¬´42‚ê§¬ª

[13:13] <jnthn> heh :)

[13:13] <moritz> call the vtable, I guess

[13:13] <jnthn> Magic coercion fail.

[13:13] <colomon> b: say "545" ~~ m/ \d+ /

[13:13] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say \"545\" "‚ê§¬ª

[13:13] <moritz> colomon: that's a weird backslash you have there

[13:13] <jnthn> colomon: There's some weird character in your paste.

[13:13] <moritz> colomon: it's color-inverted here

[13:13] <colomon> b: say "545" ~~ m/ \d+ /

[13:13] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "say \"545\" "‚ê§¬ª

[13:13] <colomon> huh

[13:13] <colomon> \

[13:13] <jnthn> Same here

[13:14] <colomon> what if I say \o/

[13:14] <colomon> ?

[13:14] <moritz> colomon: that's fine

[13:14] <colomon> nom: say "545" ~~ m/ \d+ / # typed over again

[13:14] <p6eval> nom c285a5: OUTPUT¬´=> <545>‚ê§‚ê§¬ª

[13:14] <moritz> nom: say '545' ~~ m/ \d\+ /

[13:14] <p6eval> nom c285a5: OUTPUT¬´#<failed match>‚ê§¬ª

[13:14] <colomon> nom: say "545" ~~ m/ <digit>+ / # typed over again

[13:14] <p6eval> nom c285a5: OUTPUT¬´=> <545>‚ê§ digit => <5>‚ê§ digit => <4>‚ê§ digit => <5>‚ê§‚ê§¬ª

[13:15] <moritz> note that the .gist output is rather suboptimal

[13:15] <moritz> should probably be  digit => [<5>, <4>, <5>] or so

[13:17] <Woodi> do "str" works faster then "Str" ? why there are doble same types ? 

[13:18] <moritz> Woodi: please read S02 and S09

[13:18] <Woodi> oh, ok

[13:18] <moritz> (sections on native types)

[13:19] *** kaleem left
[13:19] <jnthn> You have to be extremely careful with str. There's a bunch of traps that will get you worse performance. With int and num - yes, you tend to get better performance, somethings massively better.

[13:19] <jnthn> Trick when working with native num/int is to avoid method calls.

[13:20] <jnthn> Since a method call requires an object, which requires boxing, which throws away the benefits.

[13:20] <jnthn> Or at least, some of them.

[13:20] <jnthn> (Of course, that is somewhat subject to change when we get some kind of method inlining. But method inlining almost certainly requires guards to be generated.)

[13:22] <moritz> jnthn: I'm currently doing only concatenation and nqp:: ops on my str's

[13:24] <jnthn> moritz: Yeah, your usage of them as generally been fine. It's when you start doing method calls on them that you can end up re-boxing the same string over and over again unintentionally.

[13:24] <jnthn> *has

[13:24] <dalek> rakudo/nom: 8c9caf7 | moritz++ | src/core/Str.pm:

[13:24] <dalek> rakudo/nom: [trans] use native str for collecting the result

[13:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c9caf726e

[13:25] <jnthn> moritz: If there's a lot of substitutions being made you may well get better performance by collecting the parts and then joining. in a similar style to the (fairly well optimized, iirc) Str.join method.

[13:26] <moritz> jnthn: I know, but I'm not yet ready for that level of optimization :-)

[13:26] <jnthn> OK :)

[13:27] <Woodi> is 'eq' the fastest way to compare strings ?

[13:28] *** fridim_ joined
[13:38] *** wk left
[13:39] <masak> Woodi: what are you attempting to do?

[13:39] <masak> I mean, why are you motivated to speed up 'eq'?

[13:40] *** wk joined
[13:40] <Woodi> becouse i use it frequently - probably 30k in 10k function calls

[13:40] *** ethndbst joined
[13:40] *** ethndbst left
[13:40] *** ethndbst joined
[13:41] <moritz> eq is fast, and even faster if you pass variables to it that are typed as Str

[13:41] <PerlJam> Woodi: profile first

[13:41] <Woodi> if $prefix eq '+' { if $data eq 'OK' .... } elsif $prefix eq ...

[13:41] <Woodi> that numbers are from kcachegrind :)

[13:42] <moritz> Woodi: if you have many alternatives, a hash lookup might be faster

[13:42] <Woodi> not so many, but hmm....

[13:43] <PerlJam> Woodi: hash lookup is still O(1) rather than O(n) ... did you order your conditionals such that the most likely string is tested for first?

[13:43] <PerlJam> (is there a "most likely"?)

[13:44] <masak> there's always one or several most likely :)

[13:45] <Woodi> I try use some order but, realy, I write library module and order depends on live data...

[13:45] <Woodi> first will try s/given/if/ ...

[13:46] <Woodi> oO( means more 'eq'... )

[13:46] <Woodi> but no smartmatch ?

[13:46] <moritz> Woodi: it's really hard to follow your questions

[13:49] <Woodi> i just ask 'is "eq" fastest'. you sugested hashes and no more questions. except "do given always use smartmatch ?"...

[13:49] <PerlJam> Woodi: given doesn't do it, when does :)

[13:50] <moritz> Woodi: 'eq' is fastest for checking strings for equality. Happy?

[13:50] <[Coke]> is "blah" fastest often results in a "it depends" and "did you benchmark" and "show us code".

[13:50] <Woodi> PerlJam: it's why I ask :)

[13:50] <[Coke]> but, what moritz said, in general. ;)

[13:50] <Woodi> moritz: yes!

[13:50] <moritz> Woodi: but it's always faster to not run the code at all, by avoiding the comparison in some clever way

[13:51] <PerlJam> Woodi: optimizing for speed invariably means adding lots of code to do what moritz just said.

[13:51] <moritz> PerlJam: or removing lots of code :-)

[13:52] <Woodi> "do less" is my favourite optimisation method :)

[13:52] <moritz> then use it.

[13:55] <colomon> new test file, new weird error: Method 'Str' not found for invocant of class 'CallContext'

[13:55] *** tokuhirom left
[13:56] *** JimmyZ_ joined
[13:56] <moritz> colomon: are you using caller() or so?

[13:56] <colomon> moritz: nope

[13:56] <moritz> I've never seen that one.

[13:58] *** JimmyZ left
[13:58] *** JimmyZ_ is now known as JimmyZ

[13:58] <moritz> jnthn: https://gist.github.com/1404870 is a segfault + backtrace I get from a simple script using SVG::Plot

[13:59] <moritz> (which depends on SVG, which depends on XML::Writer; I've installed both freshly with ufo + 'make install')

[13:59] <colomon> moritz: .... okay, this stuff is scary

[13:59] <colomon> First run of test file: Method 'Str' not found for invocant of class 'CallContext'

[14:00] <colomon> Tweak one statement and add debugging output: Works fine

[14:00] <colomon> Turn off the debugging output: Works fine

[14:00] <moritz> :(

[14:00] <colomon> Revert to original code: runs much further than before, then Method 'uc' not found for invocant of class 'Any'

[14:00] <moritz> that's the typical case of the compiler not having had any larger apps yet

[14:02] <colomon> it feels very non-deterministic

[14:02] <PerlJam> the debugger is your friend  ;)

[14:02] <colomon> the tweak I made should have had no effect.

[14:03] <moritz> PerlJam: erm, which one? :/

[14:03] <PerlJam> whichever one he knows how to use.

[14:04] <PerlJam> (though I guess if "inserting debug statements" is the only one, he's out of luck)

[14:05] *** JimmyZ_ joined
[14:05] *** buubot_backup left
[14:06] <moritz> oh, and it takes 18s to load SVG::Plot :(

[14:07] <moritz> (and SVG::Plot is only 714 lines, and loads only 3 other small-ish .pm files)

[14:07] *** JimmyZ left
[14:07] *** JimmyZ_ is now known as JimmyZ

[14:12] *** sayu joined
[14:12] <awwaiid> colomon, sounds like cached compiler intermediate files messing with you, offhand

[14:13] *** JimmyZ_ joined
[14:13] *** llabthgie joined
[14:15] <colomon> awwaiid: except (unless nom is doing something really weird) I ran the code the exact same way every time, ie I shouldn't have been generating new PIR files.

[14:15] <colomon> oooo, I do see part of the problem, though.

[14:15] *** JimmyZ left
[14:15] *** JimmyZ_ is now known as JimmyZ

[14:16] <colomon> yeah, my revert accidentally toasted my workaround for the LTM bug, which then caused the Method 'uc' not found for invocant of class 'Any' error.

[14:19] <colomon> now if I could only figure out how to duplicate the Method 'Str' not found for invocant of class 'CallContext' error...

[14:24] <moritz> sounds like a really nasty leak

[14:26] <moritz> colomon: is the backtrace any help? maybe with --ll-exception?

[14:26] <colomon> ignoring that, it seems like my big blocker is the Can not bind non-existant attribute '$!orig' on class 'Cursor'

[14:27] <colomon> moritz: I can't duplicate the CallContext error at all.  It only happened the once.

[14:27] <moritz> hm.

[14:28] *** buubot_backup joined
[14:30] *** sayu left
[14:30] *** daxim left
[14:30] *** fhelmberger left
[14:30] *** envi_ left
[14:30] *** Exodist left
[14:30] *** wolverian left
[14:30] *** rsimoes1 left
[14:30] *** mattp_ left
[14:30] *** Lothar left
[14:31] <colomon> also, as nearly as I can see it was a completely illogical error, by which I mean it occurred in the last test of a series, all of which were exercising the same code.

[14:35] <jnthn> That CallContext one may be a GC bug of some kind.

[14:35] *** agentzh left
[14:35] <jnthn> The same one tadzik has seen occasionally.

[14:36] *** sayu joined
[14:36] *** daxim joined
[14:36] *** fhelmberger joined
[14:36] *** envi_ joined
[14:36] *** Exodist joined
[14:36] *** wolverian joined
[14:36] *** rsimoes1 joined
[14:36] *** mattp_ joined
[14:36] *** Lothar joined
[14:36] * moritz just fixed CGI::Application to work on nom

[14:37] <moritz> not a nom regression really, but the now properly done exception stuff

[14:37] <jnthn> Ah, good

[14:37] <jnthn> moritz: Will investigate the segfault...the stack trace doesn't make that one look GCesque, thankfully.

[14:38] *** sayu left
[14:38] *** cognominal_ joined
[14:38] *** sftp joined
[14:40] <dalek> roast: de6dbd7 | coke++ | S05-transliteration/with-closure.t:

[14:40] <dalek> roast: rakudo fudge

[14:40] <dalek> roast: review: https://github.com/perl6/roast/commit/de6dbd75e9

[14:41] *** cognominal___ left
[14:41] <[Coke]> moritz++ # more unfudges

[14:41] <dalek> rakudo/nom: 8716958 | coke++ | t/spectest.data:

[14:41] <dalek> rakudo/nom: run fudged test

[14:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8716958ed9

[14:42] <[Coke]> (ok, technically those were fudges, but we can now run the test file, so, net-un-fudge)

[14:45] *** bluescreen10 joined
[14:48] * jnthn wonders what the net pass count is now if you have ICU

[14:52] <moritz> the HTML::Template is quite curious

[14:52] <moritz> oh, I know why

[14:52] <moritz> has $!in;

[14:52] <moritz> ...

[14:53] <moritz> method from_string($in) { self.new(in => $in) }

[14:53] <moritz> but since it's a private attribute, it doesn't get initialized by .new

[14:54] <jnthn> That seems like a common thing to need to fix.

[14:59] * moritz just fixed HTML::Template

[15:03] <jnthn> moritz: Was the above fix all it needed?

[15:03] <moritz> jnthn: no

[15:03] <moritz> jnthn: another exceptioin fix

[15:03] <moritz> and

[15:03] <moritz> one test that did $someException ~~ m/.../

[15:04] <moritz> where $someException was of type Exception

[15:04] <jnthn> Should that work, even if it's maybe not the best idea?

[15:04] <moritz> dunno

[15:08] *** worr left
[15:08] *** mikemol left
[15:14] *** worr joined
[15:16] * bbkr thinks about forking closure-based HTML::Template, this approach should speed it up by the factor of ~120.

[15:16] <bbkr> maybe after NOM star

[15:27] *** vifon joined
[15:39] *** alvis joined
[15:45] *** thou joined
[15:45] *** thou left
[16:00] *** slavik1 joined
[16:12] *** JimmyZ left
[16:13] *** vifon left
[16:17] *** shortcircuit joined
[16:18] *** daxim left
[16:19] *** shortcircuit is now known as mikemol

[16:19] *** mikemol left
[16:19] *** mikemol joined
[16:21] *** thou joined
[16:29] *** estrabd_afk is now known as estrabd

[16:43] *** noodles__ joined
[16:50] *** am0c left
[16:50] *** noodles__ left
[17:03] *** wolverian left
[17:05] *** wolverian joined
[17:07] <dalek> nqp: 19f994b | jnthn++ | / (329 files):

[17:07] <dalek> nqp: Merge branch 'nci'

[17:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/19f994bae4

[17:10] <[Coke]> build gets real unhappy if you delete the perl you used to build and try to reconfigure.

[17:10] <[Coke]> (switching over to using perlbrew on feather. boom.)

[17:16] <jnthn> colomon: ping

[17:19] *** thou left
[17:24] *** thou joined
[17:25] <dalek> nqp: e62d398 | jnthn++ | src/NQP/Actions.pm:

[17:25] <dalek> nqp: Ensure references to self in NQP are decontainerized.

[17:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e62d3989d9

[17:26] <dalek> rakudo/nom: b2a9370 | jnthn++ | src/ (7 files):

[17:26] <dalek> rakudo/nom: Merge branch 'nci' into nom

[17:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b2a9370a12

[17:26] <dalek> rakudo/nom: aa15f3a | jnthn++ | tools/build/NQP_REVISION:

[17:26] <dalek> rakudo/nom: Bump to latest NQP revision.

[17:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa15f3adcf

[17:27] <jnthn> phenny: tell colomon I think latest may fix the $!orig issue in ABC, though I get "Method 'at_key' not found for invocant of class 'Any'", which iirc you already have a patch for locally?

[17:27] <phenny> jnthn: I'll pass that on when colomon is around.

[17:29] *** mj41 left
[17:30] *** alester joined
[17:30] <TimToady> someone needs to ack both parrot and nqp and s/existant/existent/

[17:31] <alester> I think you can use perl for that.

[17:31] <TimToady> I don't touch implementations, generally speaking.

[17:32] <TimToady> it's a kindness to masak, who gets to file more bugs

[17:33] <TimToady> and I'm just the stuporvisor; the union requires me to stand here and watch

[17:34] <alester> TimToady: Done.

[17:35] <dalek> nqp: c1c6435 | jnthn++ | src/ (3 files):

[17:35] <dalek> nqp: Spellos; TimToady++ for noticing.

[17:35] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c1c64357c9

[17:37] *** MayDaniel joined
[17:39] <jnthn> moritz: Grr. Just tried to reproduce that SVG::Plot segfault locally and...it didn't segfault. :S

[17:40] <moritz> :(

[17:41] <jnthn> moritz: NCI stuff all merged, BTW. Testing appreciated.

[17:41] <jnthn> Though there weren't any merge conflicts at all, so I doubt much will have gone awry.

[17:41] <jnthn> Grr. I even upped it to 1..1000 rather than 1..100 and it didn't explode.

[17:41] <moritz> djanatyn: sorry, I didn't know that I had to acknowledge the claim for that NCI task

[17:43] *** MayDaniel left
[17:44] <jnthn> moritz: Hm. Even producing a much larger output graph doesn't tickle it.

[17:44] <jnthn> moritz: What platform are you on? 64-bit Linux, I guess?

[17:44] <moritz> jnthn: yes

[17:44] * jnthn is on 64-bit also, though Windows :)

[17:45] <jnthn> moritz: Was it very reproducable, or just "sometimes"?

[17:45] <moritz> jnthn: i've tried it once or twice

[17:47] *** kaleem joined
[17:47] <colomon> jnthn: yes the at_pos in Any thing was because LTM wasn't working correctly.

[17:47] <phenny> colomon: 17:27Z <jnthn> tell colomon I think latest may fix the $!orig issue in ABC, though I get "Method 'at_key' not found for invocant of class 'Any'", which iirc you already have a patch for locally?

[17:47] *** wk left
[17:47] <jnthn> colomon: Yeah, it's just NYI for the standalone alternation case...works for the protoregex one (which may have alternations...)

[17:48] <colomon> at any rate, in my case it was easy enough to work around by switching the order of the cases.  :)

[17:48] *** thou left
[17:53] <tadzik> ooh, nci :>

[17:53] *** thou joined
[17:58] <cognominal_> jnthn, are you close to get a :from<nqp> ?

[17:58] *** kaleem left
[17:58] <cognominal_> jnthn is writing code faster than I can read it.

[17:59] <cognominal_> I can't figure out, the global or whatever which hold a reference to all things loaded.

[18:00] <colomon> jnthn: looks like the patch works, at least the test is running for a LOT longer now.  (Probably because I'm tracing a bunch of complicated regex work.)

[18:00] <cognominal_> maybe the EXPORT_SYMBOL is a good place to start.

[18:01] *** tokuhirom joined
[18:02] <colomon> jnthn: hmm, new error is Method 'count' not found for invocant of class 'Continuation'

[18:03] <tadzik> ha, GC bug I guess

[18:03] <tadzik> try parrot -G perl6.pbc <code>

[18:04] <jnthn> Ugh...that's nasty.

[18:04] <jnthn> (GC bug)

[18:04] <jnthn> cognominal_: It's not especially close; there's a whole bunch of more pressing stuff right now, I'm afraid.

[18:04] *** dakkar left
[18:04] <jnthn> cognominal_: There *isn't* a single global view any more.

[18:05] <jnthn> cognominal_: That's why some kind of "use" is needed

[18:06] <cognominal_> ok, thx for the info.

[18:07] <cognominal_> I thought one things got "used", you could get them from some "root" place.

[18:08] <cognominal_> so a use becomes a noop since the second time from which you cant get at stuff?

[18:08] <jnthn> cognominal_: Well, the module loader keeps track of the stuff

[18:08] <jnthn> cognominal_: Basically, it holds on to the UNIT of the loaded module

[18:09] <jnthn> From that its view of GLOBAL and EXPORT are looked up whenever it is used.

[18:10] <tadzik> pararell build broken in nqp?

[18:12] *** icwiener joined
[18:12] <jnthn> Hopefully not...it was then moritz++ mentioned it works.

[18:12] <PerlJam> cognominal_: Would the second use be a noop or would it still import the appropriate symbols?

[18:12] <jnthn> PerlJam: the answer is the latter :)

[18:19] *** ksi joined
[18:23] <tadzik> oh, I'm on nci branch

[18:29] <colomon> jnthn: okay, looks like ABC finishes tests with no crashes other than the random GC(?) ones.

[18:30] <colomon> jnthn: (that's on my local nom branch)

[18:31] <cognominal_> ePerlJam, jnthn, I meant that if the use was called with the same parameters, it would result in the importing of the same set of symbols so it could be viewed as a noop

[18:32] <PerlJam> cognominal_: not if some other "use" had mangled those symbols in the mean time.

[18:32] <tadzik> nqp build failure: https://gist.github.com/1405864

[18:33] <cognominal_> Perljam, indeed.

[18:33] <jnthn> tadzik: oh...I upgraded to a later dyncallib and may have blown away your patch to that file

[18:34] <tadzik> we should patch it upstream probably :)

[18:34] <tadzik> can you reapply it? I have to learn the damn C++

[18:35] <jnthn> tadzik: will do

[18:35] <tadzik> thanks

[18:39] <colomon> nom: say "[K:F]" ~~ m/ '[' (<alpha>) ':' (.*) ']' /

[18:39] <p6eval> nom aa15f3: OUTPUT¬´#<failed match>‚ê§¬ª

[18:39] <colomon> nom: say "[K:F]" ~~ m/ '[' (<alpha>) ':' (.*?) ']' /

[18:39] <p6eval> nom aa15f3: OUTPUT¬´#<failed match>‚ê§¬ª

[18:39] <dalek> nqp/qbootstrap: 7508c6a | jnthn++ | tools/build/Makefile.in:

[18:39] <dalek> nqp/qbootstrap: First steps towards getting NQP bootstrapping with QRegex. This just twiddles the makefile so we always build QRegex during stage 2, and then build NQPQ as the stage 2 NQP.

[18:39] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/7508c6a987

[18:39] <dalek> nqp/qbootstrap: 6060370 | jnthn++ | src/QHLL/ (5 files):

[18:39] <dalek> nqp/qbootstrap: Add a temporary QHLL copy of HLL to help facilitate the bootstrap.

[18:39] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/6060370133

[18:39] <dalek> nqp/qbootstrap: 70ac5d0 | jnthn++ | tools/build/Makefile.in:

[18:39] <dalek> nqp/qbootstrap: Build QHLL in stage 2.

[18:39] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/70ac5d0db1

[18:40] <jnthn> tadzik: oh, it's not a straightforward application of the same patch, the file got moved/renamed

[18:41] <jnthn> tadzik: need to eat, will look after dinner

[18:41] <tadzik> sure thing

[18:41] *** hundskatt joined
[18:44] *** buubot_backup left
[18:50] <diakopter> /usr/local/bin/parrot: corrupted double-linked list

[18:51] *** fridim_ left
[18:51] <diakopter> every time

[18:52] *** wolfman2000 joined
[18:52] *** fridim_ joined
[18:52] <colomon> niecza: say "[K:F]" ~~ m/ '[' (<alpha>) ':' (.*?) ']' /

[18:52] <p6eval> niecza v12: OUTPUT¬´#<match from(0) to(5) text([K:F]) pos([#<match from(1) to(2) text(K) pos([].list) named({"alpha" => #<match from(1) to(2) text(K) pos([].list) named({}.hash)>}.hash)>, #<match from(3) to(4) text(F) pos([].list) named({}.hash)>].list) named({}.hash)>‚ê§¬ª

[18:52] <colomon> b: say "[K:F]" ~~ m/ '[' (<alpha>) ':' (.*?) ']' /

[18:52] <p6eval> b 1b7dd1: OUTPUT¬´[K:F]‚ê§¬ª

[18:58] *** ashleydev left
[18:58] <jnthn> colomon: Oh...you've found the infamous backtracking bug :/

[18:59] *** ashleydev joined
[18:59] *** ashleydev left
[19:00] <colomon> jnthn: suggested workaround?

[19:00] *** ethndbst left
[19:00] <jnthn> nom: say "[K:F]" ~~ m/ '[' (<alpha>) ':' .* ']' /

[19:00] *** ethndbst joined
[19:00] <p6eval> nom aa15f3: OUTPUT¬´=> <[K:F]>‚ê§ 0 => <K>‚ê§  alpha => <K>‚ê§‚ê§¬ª

[19:01] <jnthn> nom: say "[K:F]" ~~ m/ '[' (<alpha>) ':' $<other>=[.*] ']' /

[19:01] <p6eval> nom aa15f3: OUTPUT¬´=> <[K:F]>‚ê§ 0 => <K>‚ê§  alpha => <K>‚ê§ other => <F>‚ê§‚ê§¬ª

[19:01] <colomon> b: say "[K:F]" ~~ m/ '[' (<alpha>) ':' $<other>=[.*] ']' /

[19:01] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Confused at line 22, near "\x{2}say \"[K:F"‚ê§¬ª

[19:01] <jnthn> colomon: That one. It's backtracking into captures

[19:01] <jnthn> colomon: btw, <alpha> already captures, so (<alpha>) is capturing it twice.

[19:02] <colomon> jnthn: good point

[19:02] <colomon> perl6: say "[K:F]" ~~ m/ '[' (<alpha>) ':' $<other>=[.*?] ']' /

[19:02] <p6eval> rakudo aa15f3: OUTPUT¬´=> <[K:F]>‚ê§ 0 => <K>‚ê§  alpha => <K>‚ê§ other => <F>‚ê§‚ê§¬ª

[19:02] <p6eval> ..niecza v12: OUTPUT¬´#<match from(0) to(5) text([K:F]) pos([#<match from(1) to(2) text(K) pos([].list) named({"alpha" => #<match from(1) to(2) text(K) pos([].list) named({}.hash)>}.hash)>].list) named({"other" => #<match from(3) to(4) text(F) pos([].list) named({}.hash)>}.hash)>‚ê§¬ª

[19:02] <p6eval> ..pugs b927740: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HAND‚Ä¶

[19:04] *** ashleydev joined
[19:04] *** ashleydev left
[19:04] *** Chillance joined
[19:04] <colomon> jnthn++

[19:04] *** buubot_backup joined
[19:06] *** ashleydev joined
[19:09] <colomon> I have all ABC tests passing!

[19:10] <dalek> nqp: 47e75d0 | jnthn++ | 3rdparty/dyncall/dynload/dynload_syms_elf.c:

[19:10] <dalek> nqp: Hopefully fix the build for tadzik++.

[19:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/47e75d0d07

[19:10] <jnthn> \o/

[19:11] *** GlitchMr joined
[19:11] <jnthn> tadzik: hope that helps :)

[19:11] <jnthn> tadzik: And yeah, should probably submit upstream.

[19:13] *** arlinius joined
[19:19] *** [particle]1 joined
[19:20] *** [particle] left
[19:20] *** fsergot left
[19:21] <tadzik> jnthn: yeah, -j1 builds now :)

[19:28] *** [particle]1 is now known as [particle]

[19:29] <colomon> and I just converted seven tunes to Lilypond!

[19:37] <tadzik> jnthn: so which NativeCall branch is now functional?

[19:38] <jnthn> tadzik: v2

[19:38] *** Mowah_ joined
[19:38] <tadzik> jnthn: 1) any reason why not merge it? 2) which tests/examples should run?

[19:41] *** birdwindupbird joined
[19:41] *** birdwindupbird left
[19:41] <jnthn> tadzik: 1) none now that I've merged the other nci branches, 2) didn't have chance to triage them

[19:41] <jnthn> bbiab

[19:43] <japhb> TimToady, did you find enough brane to make a decision about http://irclog.perlgeek.de/perl6/2011-11-25#i_4755358 ?  I saw you had discussed with jnthn++ the (I assume) related question of moving Failure out of Any, but did that lead to a conclusion on the original question?

[19:45] *** Chillance left
[19:45] <masak> spec updates or it didn't happen :)

[19:46] *** Chillance joined
[19:48] *** fsergot joined
[19:48] *** kaare_ joined
[19:49] *** Mowah_ left
[19:54] <jnthn> back

[20:10] *** arlinius left
[20:18] *** fsergot left
[20:21] *** miso2217_ left
[20:23] *** cooper joined
[20:24] *** miso2217 joined
[20:37] *** wolfman2_ joined
[20:37] *** ethndbst left
[20:38] *** wolfman2_ left
[20:39] *** fsergot joined
[20:39] *** wolfman2000 left
[20:41] *** birdwindupbird joined
[20:42] *** birdwindupbird left
[20:45] <japhb> masak: <tone variant="hopefully">He could have made his decision and just not finished the spec updates ...</tone>

[20:48] <PerlJam> japhb: You should know how quickly things progress with the language spec by now  ;)

[20:50] *** fsergot left
[20:52] *** arlinius joined
[20:52] *** mj41 joined
[20:52] *** molaf joined
[20:52] <japhb> PerlJam, yeah, I know.  It's just fundamental enough to be blocking multiple different areas I've been working on, and I don't want the work I already put in to just sit and bitrot.  :-(

[20:59] <masak> japhb: do you have a favorite resolution of the issue yourself?

[21:00] * jnthn is in favor of the "Failure is outside of Any" approach.

[21:00] <jnthn> Until/unless I see a strong reason why not to do that, anyway.

[21:01] <jnthn> Thing is, that's easy enough to say, but then we need to figure out the upshot of it.

[21:01] <japhb> masak: Well, this all started with me talking myself in circles, but that was before TimToady floated the idea that jnthn favors

[21:01] <jnthn> Like, how does said failover look.

[21:02] * japhb must handle a $day-job task for the $Big-Boss, and then can think more heavily on this variant

[21:02] *** MayDaniel joined
[21:03] <PerlJam> all we need is for someone to implement "Failure outside of Any" and see what happens :)

[21:05] <japhb> PerlJam, I'm not sure I've got the core knowledge to be able to get something that pervasive right everywhere.  But if no one else offers, I may see what I can manage.

[21:05] *** ethndbst joined
[21:05] <Tene> japhb: you don't need to get it right everywhere, just get it right in enough interesting places that someone else can clean up the rest. ;)

[21:05] <japhb> Tene: well, there is that.  :-)

[21:07] <jnthn> :P

[21:08] <jnthn> I can't help but wonder if TimToady is going to come back with some generalization of out-of-Any failover that junctions and failures and each hang off.

[21:08] *** GlitchMr left
[21:10] <japhb> Well that's the other point ... I'm a bit worried about throwing non-negligible tuits at something that soon after gets redesigned

[21:12] *** Chillance left
[21:12] <jnthn> japhb: At this point I'd be inclined to wait a little.

[21:12] <PerlJam> you can't second guess the future.  You can only act on what you know to be true.

[21:12] <masak> know the feeling.

[21:12] <PerlJam> so, it depends on how urgent you feel you need something to happen.

[21:13] <japhb> Nodnod.

[21:13] <japhb> Thanks for the advice, guys, I appreciate it.

[21:13] <jnthn> japhb: This is for the numeric work, iiuc?

[21:13] <jnthn> japhb: Does it tie into val and MAIN handling too?

[21:13] <jnthn> (just trying to get a clear idea of exactly what's blocked on it...)

[21:14] <japhb> Yes, all three, and I was looking at working on some related test files.

[21:14] <japhb> But I can't even fix/write tests if I don't know what *should* be happening.  :-/ 

[21:15] <japhb> So 4 paths of hacking blocked.  However, my 5th one (trying to get OpenGL working under nom) is rapidly being unblocked by you, so I may have another -Ofun soon.

[21:16] <japhb> But I also don't want to leave the other work unfinished, it's important stuff, and I want that fine feeling of getting those items to finally be spec-compliant.

[21:17] <jnthn> japhb: Yes, I agree it's important, and I'm really glad you're working on it.

[21:17] <japhb> jnthn, thank you.

[21:18] <jnthn> The NativeCall stuff is coming along. It turns out that pondering the nature of handling C arrays led me to have to think about a load of stuff I'd been somewhat putting off thinking about.

[21:18] <TimToady> the problem with Failure outside of Any is that it prevents returning Failure from a function that returns a type like Int.

[21:18] *** MayDaniel left
[21:18] <jnthn> TimToady: Provided that doesn't just failover too...

[21:18] <Tene> TimToady: how is that any better with Failure in Any?

[21:19] <TimToady> Failure has up till now been thought of as a bottom type

[21:19] <jnthn> It's not really. AFAIK, the other serious alternative is that Failure is a role that is mixed in to any type.

[21:19] <jnthn> Oh, or that :)

[21:19] *** tokuhirom left
[21:20] <japhb> jnthn, (re NativeCall): yeah, and C arrays is probably the biggest remaining sticking point for OpenGL work.

[21:20] <japhb> "bottom type"?

[21:20] <jnthn> japhb: I got a long way with the thinking last night. It's just that it ties in to another near-term thing and multiple long-term things...

[21:20] <Tene> japhb: http://en.wikipedia.org/wiki/Bottom_type

[21:20] <PerlJam> japhb: the last turtle

[21:20] <jnthn> ...so I'd rather get it rightish.

[21:20] <japhb> jnthn, gotcha, please do.  :-)

[21:21] <Tene> TimToady: I don't actually see the relation between "Failure is a bottom type" and "Failure is in Any"

[21:22] <jnthn> TimToady: I worry a bit about bottom types.

[21:22] <japhb> PerlJam, that was my guess, which seemed like an odd way to say it, but Tene's link (thanks!) gives some useful detail to that.

[21:22] <jnthn> TimToady: From an optimization view, I'm bothered that we suddenly can't make so many assumptions.

[21:22] <Tene> Also, returning Failure doesn't seem to match with what Wikipedia discusses there, afaict.

[21:23] <PerlJam> Tene: if Failure is outside of Any it can't be used as a bottom type for those things that accept Any I expect

[21:24] <jnthn> TimToady: For example, if I see Int, I can probbly know something about representation. I can generate code that is faster because it makes assumptions.

[21:24] <jnthn> TimToady: I worry a bottom type means we'll have a bunch of extra checks to do.

[21:24] <PerlJam> sentinels are usually there to get rid of extra checks.

[21:25] *** bluescreen10 left
[21:25] <jnthn> PerlJam: Can you elaborate a little? :)

[21:25] * jnthn thinks he sort of half-ish sees that PerlJam may be saying :)

[21:26] <PerlJam> It seems to me that Failure outside of Any will result extra checks and that Failure in Any allieviates these.

[21:26] <jnthn> oh wow, the guy who supervised my degre project is one of the references on that Wikipedia page. :)

[21:26] <PerlJam> (assuming we continue using Failure as we have been)

[21:28] <jnthn> PerlJam: Maybe I'm just not thinking hard enough about it...but basically "outside of Any" means that it gets detected because a type check we'd have had to do anyway fails.

[21:28] <PerlJam> The more I  think about it, the less I like "Failure outside of Any"

[21:28] <jnthn> Of course, then we run into the issue that

[21:28] <jnthn> my Int $x = something-that-fails(); # type check fails on the assignment...then what?

[21:29] <jnthn> And if we say "oh, make it work somehow" then we're back to the same kind of problem for optimization.

[21:29] <jnthn> So they're probably both about as problematic on a sense.

[21:29] <jnthn> *in

[21:30] <jnthn> Essentially, outside of Any means that we rely on type checks failing and doing something as a fallback.

[21:31] <PerlJam> aye, I see what you're saying

[21:31] <jnthn> Bottom type means Failure can be stored pretty much all the time. So then the question is...what makes it explode?

[21:32] <PerlJam> If we had type-inference ala Haskell, Perl would make it explode in either case ;)

[21:32] <jnthn> Well, I know how outside-of-Any is going to.

[21:33] <TimToady> I think if we go with outside, the place to fudge it is in the return, depending on the caller's preferences

[21:33] <jnthn> The "bottom type" is likely not going to hit a problem in, say, +, until the bigint addition op tries to grab the bigint part out of it and fails.

[21:33] <PerlJam> So, like many things in Perl 6 land, I've thought about this enough to make my head hurt, but not enough to see a path forward that makes good sense.

[21:33] <TimToady> so that a hyperop can tell the returner that it's okay to violate the return type

[21:34] <jnthn> TimToady: What about ops, though?

[21:35] <TimToady> what about 'em?

[21:35] <jnthn> TimToady: $some-failure + 1

[21:36] <jnthn> TimToady: Is that a dispatch failure? If so, does it failover? If it fails over, what to, and how do we specify that? Is it a generic thing?

[21:36] <colomon> should be another failure, right?

[21:36] <jnthn> etc :)

[21:36] <jnthn> colomon: Seems so

[21:36] <TimToady> it fails to dispatch the +, if + is Any, and Failre is outside

[21:36] <jnthn> OK, here's my real worry

[21:36] <jnthn> $a = $b + $c;

[21:36] <TimToady> but that can probably throw, by current spec

[21:37] <jnthn> $d = $a * 2;

[21:37] <jnthn> Imagine that all of those were decalred as Int

[21:37] <TimToady> including the ops?

[21:37] <PerlJam> but then they'd be $i, $j, $k, and $l   ;)

[21:37] <jnthn> The optimizer says "oh, great, I can inline those ops!"

[21:38] <PerlJam> jnthn: but it would be wrong for failure?

[21:38] <jnthn> TimToady: As in, their return type?

[21:38] <jnthn> PerlJam: Yes.

[21:38] <jnthn> And if we can't inline reliably, we're in trouble.

[21:39] <TimToady> well, it doesn't really matter if the returner or the dispatcher fails the Int check, as long as someone throws the exception

[21:39] <jnthn> TimToady: ah, so:

[21:39] <TimToady> I'm assuming only hypers and such would suppress the Int check on return

[21:40] <jnthn> my Int $a = lol-i-fail(); # type check fail?

[21:40] <jnthn> And

[21:40] <TimToady> the inliner can inline when it sees there's another Int check in the dispatch

[21:40] <jnthn> sub foo() returns Int { fail() } # what about this?

[21:40] <[Coke]> colomon++ # just saw the abc fix message.

[21:40] <colomon> [Coke]: I even added a simple README for you.  ;)

[21:41] <colomon> [Coke]: you need to thank jnthn++ as well, he had to fix a nom bug for me and suggested a couple of work arounds as well.

[21:41] <jnthn> TimToady: I don't quite understand "another Int check"

[21:41] <TimToady> I suspect an explicit fail() also overrides the return type check

[21:41] <TimToady> there's an outgoing Int constraint on the return, and an incoming on the +

[21:42] <jnthn> TimToady: OK, agree with that bit. I'm asking what might be "violated" :)

[21:42] <jnthn> TimToady: That is, can the optimizer/type checker rely on something that is marked "returns Int" actually returning Int?

[21:43] <[Coke]> jnthn++ # sneaky ABC karma

[21:43] <jnthn> TimToady: Or does it have to assume that it may fail() unless it can prove otherwise?

[21:43] <TimToady> as long as it blows up somewhere reliably if you don't have an Int, with sufficiently localized information to determine what the error was, I don't care who throws the real exception

[21:43] <colomon> [Coke]: even better, I've basically been waiting to be able to use Grammar::Tracer to start hacking on ABC again.  There's lots of further things I'd like to implement...

[21:44] <jnthn> TimToady: Well, but I worry whether we'll be lazy enough about Failure

[21:44] <TimToady> any failure that is accidentally passed into an op should still carry the information about the original failure

[21:44] <PerlJam> Failure seems like tainting all of a sudden.

[21:44] <TimToady> the lazy failures are really a caller policy for parallelism

[21:45] <TimToady> in the non-parallel case, we're only giving the user opportunity to say foo() // die

[21:45] <TimToady> other than that, not much use case for lazy exceptions

[21:45] <jnthn> OK, gotcha.

[21:46] <TimToady> well, and also to allow your optimizer to make assumptions when the failure can be caught elsewhere reliably

[21:47] <jnthn> Well, and also to know when a variable simply can't be a failure.

[21:55] <japhb> And this brings me back to (part of) my original question.  If a Failure can float around for a while before finally throwing up, what exactly causes that to happen?  Does it propagate endlessly sort of like NaN?  Does it throw only when it falls out of scope without being handled?  Does every op have to check for it?  Only some ops?  ...

[21:55] <masak> 'night, #perl6

[21:55] <japhb> s/throwing up/throwing/ # Heh

[21:55] <japhb> o/

[21:56] <PerlJam> japhb: I think it was righter originally  ;)

[21:57] <jnthn> japhb: Well, if we're saying it's outside of Any, then only ops that explicitly want to accept Failure and do something special with it would have to care.

[21:57] <jnthn> japhb: Just as almost every op can ignore junctions.

[21:57] <jnthn> Then we'd have a failover option

[21:58] <jnthn> So it'd be like the junction auto-threader...apart from for failures.

[21:58] <jnthn> I guess it'd make another failure with the original one contained within it.

[21:58] <benabik> my $failure = fail 1; fail $failure # lolwut?

[21:59] <jnthn> At some point either a type constraint will cause it to explode becuase you're putting it into a container that can't take Failure, or some other context that can't.

[21:59] <jnthn> benabik: fail is like return :)

[21:59] <japhb> jnthn, right ... but one of your previous points was about inlining and the optimizer.  If the optimizer gets really lucky and manages to inline a lot of stuff in a row ... does it have to add checks for Failure at all the points in the original code that would have been calls?

[21:59] <jnthn> japhb: No, because if it has a variable of type Int, that variable could never have successfully been assigned a Failure.

[22:00] <benabik> jnthn: my $failure = (sub { fail })() #?  Okay, that's somewhat obviously abusing the system.

[22:00] <jnthn> benabik: If you do that, you'll get a Failure object in $failure.

[22:00] <jnthn> benabik: Since the default type constraint on a scalar is Mu.

[22:00] <benabik> jnthn: And passing it to fail causes a nested failure?

[22:00] <japhb> jnthn, hmmm ... OK, as a concrete example, how would you implement infix:<==> in this new world?

[22:00] <benabik> nested failures seem wierd.

[22:01] *** ksi left
[22:02] <PerlJam> "Failure oustide of Any" seems like we'd end up with lots of op variants with Failure arg types to DTRT (whatever that is)

[22:02] <jnthn> PerlJam: No, the idea is that we *wouldn't*

[22:02] <jnthn> japhb: Imagine we have $a == $b and one of them is a Failure

[22:02] <colomon> because failure to dispatch is a failure?

[22:02] <jnthn> japhb: The multi-dispatcher would fail to find a candidate.

[22:03] <jnthn> It would then look at whether there's a special type of handler for this kind of dispatch failure - basically, we just generalize the mechanism we already have that does exactly this for junctions.

[22:04] <PerlJam> "this kind of dispatch failure"?

[22:04] <jnthn> Presumably, the handler for failures is then called instead of any of the op variants. It probably packages up the existing failure with some extra "then you tired to do this to it" info...or maybe just tracks it.

[22:04] <jnthn> er, tracks the original error

[22:04] *** benabik left
[22:04] <jnthn> Now, if the question is, what happens if I have the (Any, Any) candidate, which does .Numeric, and one of those .Numeric calls returns Failure

[22:05] <jnthn> That candidate is $a.Numeric == $b.Numeric

[22:05] <jnthn> That second dispatch would fail, and hit the failure failover.

[22:05] <japhb> Let me rephrase my question, since I think it came out differently than I'd intended:  How would you implement infix:<==> so that it is still inlineable?

[22:05] <jnthn> japhb: ah, I've been a bit unclear here maybe.

[22:05] <jnthn> japhb: It's *individual candidates* that are inlinable.

[22:06] <jnthn> japhb: The (Int, Int) candidate, for example, would be inlinable.

[22:06] <japhb> Ah!

[22:06] <jnthn> japhb: We could never inline an (Any, Any) if there is an (Int, Int) anyway.

[22:06] <japhb> So if you ever have multiple candidates, no inlining for you

[22:06] <japhb> gotcha!

[22:07] <jnthn> japhb: The rules are a little fun for that. But basically, if you can't be sure which candidate you're heading to, no inlining.

[22:07] <japhb> OK, this is making more sense.  I at some point got the impression that you were handling the case of multiple candidates where you can define a strict ordering of types in a somewhat-more-efficient-than-normal-multi-dispatch manner

[22:08] <PerlJam> does the special failure processing interact with autoloading?

[22:09] <jnthn> PerlJam: I hadn't considered it as doing so, so far...but interesting point :)

[22:09] <jnthn> PerlJam: At the moment junction failover is basically done by looking through the capture and saying "so, do we have a junction in here that's to blame".

[22:11] *** kaare_ left
[22:15] *** imarcusthis left
[22:15] <jnthn> japhb: Well, we sort candidates statically, if that's what you mean.

[22:17] * jnthn guesses TimToady will read this lot and yell if I've told any of it really rong :)

[22:17] *** imarcusthis joined
[22:18] <japhb> jnthn, I meant something along the lines of candidates for Int, Real, Numeric, Any, and Mu, and inlining a fast ladder typecheck and jump to the body of each inlined candidate.

[22:18] <jnthn> japhb: Oh

[22:18] <jnthn> japhb: No, I'm not doing that (yet)

[22:19] <jnthn> japhb: That's kinda worthwhile if you can pull the ladder outside of a tight loop, I guess.

[22:19] <jnthn> Well, more worthwhile

[22:19] <japhb> sure.

[22:20] <japhb> I had just gotten confused and thought you were *already* doing something like that. :-)

[22:21] <jnthn> No, the optimizer isn't so adventurous yet. :)

[22:25] <cotto> jnthn: do you have any idea when 6model will be stable enough that it'll start to make sense to port it to Parrot core?

[22:27] <jnthn> cotto: Large parts of 6model are already decidedly stable. The last large change was to the REPR API, and it was sufficiently internal that the change didn't actually spill out of the interface provided by the ops.

[22:28] <jnthn> cotto: The work to come is about how 6model thinks about representations for things besides attribute-storing objects.

[22:28] <jnthn> cotto: Tied into that is how you actually bootstrap 6model from zero.

[22:29] <jnthn> I've been adding various representations, but those are just more implementations of an existing interface.

[22:29] <jnthn> And not actually in 6model core.

[22:29] <cotto> jnthn: other things like opaque chunks of memory or opaque pointers?

[22:30] <jnthn> cotto: Arrays.

[22:30] <jnthn> cotto: This has come up because I need to do C arrays.

[22:30] <japhb> jnthn, in case it comes up:

[22:30] <jnthn> cotto: I've been working on how NCI style stuff and 6model fit together. The answer is "really neatly"

[22:31] <jnthn> cotto: But the array bit...6model was just never in that business before.

[22:31] <japhb> It is really helpful to be able to have multiple array "views" (with different type info, etc.) into the same chunk of memory.

[22:32] <jnthn> cotto: If I can define where I think this is really heading, I guess I'd label it something like "ubiquitous representation polymorphism"

[22:33] <jnthn> japhb: That feels like something I can trivially provide.

[22:33] <japhb> (I guess not just type info, but stride, offset, etc.)

[22:33] <japhb> jnthn, excellent!

[22:33] *** MayDaniel joined
[22:37] <jnthn> japhb: I mean, at some level, what's an array other than a pointer and some rules about how to compute offsets from it... :)

[22:39] <japhb> jnthn, of course.  :-)  I just wanted to make sure that the API did not make assumptions that the owner of the array header (pointer + rules) was also the owner of the bits at the other end of that pointer.  :-)

[22:40] * japhb remembers that PDL had a field day with that separation

[22:40] <jnthn> japhb: Ownershp is a tricky issue in all of this.

[22:40] <jnthn> *ownership

[22:41] <japhb> I'm not surprised.

[22:41] <japhb> .oO( QueryInterface, AddRef, Release ... *shiver*)

[22:41] <jnthn> japhb: Well, "don't guess" is probably a good policy... :)

[22:41] <japhb> I can back that one. ;-)

[22:58] *** benabik joined
[23:09] *** mtk left
[23:13] * jnthn starts to twiddles that will let him get NCI arrays in over the next few days :)

[23:15] <japhb> yay!

[23:19] *** ethndbst left
[23:20] *** ethndbst joined
[23:20] *** ethndbst left
[23:20] *** ethndbst joined
[23:27] *** mj41 left
[23:29] *** alester left
[23:32] *** MayDaniel left
[23:32] *** tokuhirom joined
[23:37] *** whiteknight joined
[23:38] *** whiteknight is now known as Guest28440

[23:48] *** tokuhirom left
[23:52] *** fridim_ left
