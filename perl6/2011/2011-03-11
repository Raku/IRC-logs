[00:04] *** ilogger2 joined
[00:04] *** ChanServ sets mode: +v ilogger2

[00:12] *** stkowski joined
[00:26] *** TimToady left
[00:33] *** whiteknight joined
[00:34] *** TimToady joined
[00:46] *** stkowski left
[00:48] *** gdey_ joined
[01:04] *** woosley joined
[01:07] *** mtk joined
[01:17] *** gdey_ left
[01:20] <sorear> good * #perl6

[01:21] <sorear> TimToady: consider grammar A { multi method foo() { ... }; multi regex foo() { <...> } }

[01:21] <sorear> TimToady: A.foo is clearly a dispatcher - is it a LTM dispatcher or a nominal type dispatcher?

[01:25] <TimToady> I suspect that normal methods won't participate in LTM unless they know the secret handshake

[01:28] <sorear> phenny: tell masak STD.pm6 uses ~= to construct error messages in a few places.  I haven't figured out how to make a sane (fast!) implementation of my $x; $x ~= "x"; ok $x eq "x";

[01:28] <phenny> sorear: I'll pass that on when masak is around.

[01:29] <sorear> cpk++ # "Mo" is the best new unit I've heard this year.

[01:29] <sorear> no more "butbut 9 bit bytes" for me!

[01:30] <sorear> phenny: tell cpk I have a vague suspicion that on Windows Niecza isn't recognizing "\x0A" ~~ /\v/, and so rcrpg.pl is being interpreted as on one line, with the resulting right brace issues

[01:30] <phenny> sorear: I'll pass that on when cpk is around.

[01:31] <sorear> phenny: tell cpk [300 Mo Win64, 30 Mo Win32] Are both of those measurements for the second run?  Sounds like more confusion from the "setting autocompilation on first run" wart.

[01:31] <phenny> sorear: I'll pass that on when cpk is around.

[01:32] <TimToady> decommuting &

[01:34] <sorear> hey, I'm in a sane position to add -n and -p (correctly) now

[01:34] <sorear> I'm still hashing out the best factoring for implementing MY:: et al

[01:34] <sorear> jnthn: it's nqpnet:, and it's broken

[01:37] <sorear> TimToady: is $foo failover to package scope dependant on strict?

[01:54] <arnsholt> sorear: Octets instead of bytes seem to be the normal state of affairs in Romance languages, if you care =)

[01:59] *** [particle]1 joined
[02:00] <sorear> TimToady: Is that definition of A erroneous?

[02:05] <TimToady> maybe, and maybe...

[02:05] * PerlJam doesn't quite grok "multi regex"

[02:05] *** noganex joined
[02:06] <PerlJam> seems like that's the same thing as category matching but spelt different

[02:06] <sorear> niecza: grammar A { proto regex TOP {*}; multi regex TOP:a { a }; multi regex TOP:b { b } }; say ?(A.parse("b"))

[02:06] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Bool::True␤»

[02:06] <sorear> Right now, the proto is mandatory

[02:07] <sorear> I'd like to get rid of that while I unify multi-regex with multi-method

[02:11] <sorear> TimToady: What would you think of increasing the precedence of adverbs?

[02:11] <sorear> TimToady: currently if test1() && %hash<key>:exists { ... } has a parse that I find suprising

[02:12] <TimToady> then use 'and' instead

[02:12] <TimToady> has to be looser than =

[02:12] <sorear> why?

[02:12] <TimToady> $deleted = %foo<bar>:delete

[02:12] <sorear> HAH!

[02:13] <sorear> in that expression, :delete binds to =, not <>

[02:13] <sorear> adverb precedence suprises even TimToady :>

[02:14] <sorear> er, actually, no

[02:14] <sorear> adverbs bind *just* tighter than =

[02:14] <sorear> if they were any looser, $deleted = %foo<bar>:delete would misparse

[02:15] <sorear> tightening adverbs, possibly as high as y=, wouldn't change that parse

[02:15] <sorear> niecza: my %hash = foo => 2; my $a = ""; say $a ~ %hash<foo>:delete;

[02:15] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: Excess arguments to CORE infix:<~>, unused named delete␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE infix:<~> @ 0)␤  at /tmp/YsvPiFrVIG line 1 (MAIN mainline @ 5)␤  at /home/p6eval/niecza/lib/CORE.setting line 1261 (CORE C524_ANON @ 2)␤ 

[02:15] <p6eval> ..at /home/p6e…

[02:16] <TimToady> adverbs used to be tighter, and that causes problems too

[02:17] <sorear> we used to have many infix operators that needed adverbs

[02:17] <sorear> 1..10 :by(5) parses correctly now, but wouldn't with y= adverbs

[02:18] <sorear> ditto 2 + 2 == 4 :ok("not in 1984")

[02:18] <TimToady> tests was the other reason to make them pretty loose

[02:18] <TimToady> (but tighter than ,)

[02:19] <sorear> are there any plans to resurrect :ok?

[02:19] <PerlJam> It's still in S03

[02:19] <TimToady> yeah, but it keeps bouncing :)

[02:20] *** whiteknight left
[02:21] <PerlJam> that's not the kind of trampoline we need :)

[02:23] <PerlJam> I suspect that since the precedence rules are so inscrutable, people will use parentheses more often than not just to get the semantics right.

[02:24] <PerlJam> (for adverbs I mean)

[02:24] <PerlJam> at least for operators

[02:25] <PerlJam> maybe what's one thing should really be two things, one with a new syntactic marker :)

[02:25] <sorear> adverbs have been looser than most infix operators for as long as the specs have been in mu

[02:26] * sorear would like a more complete specs repo, one with history going back to the first drafts of each document

[02:26] <sorear> Were the apocalypses "alive" and then "frozen", or did they have their present form for as long as they have been public?

[02:26] <sorear> do they have useful history?

[02:27] <PerlJam> sorear: that apocalyses were "alive" at least until the synopses came into being.

[02:27] <sorear> PerlJam: it's already easy enough to say (%foo<bar>:delete) with the present syntax, or ($x +< 1):rotate with tightened adverbs

[02:27] <sorear> PerlJam: I am merely arguing for a different Huffman code

[02:30] <sorear> TimToady: What should the name of the -p and -n settings be?

[02:41] *** envi joined
[02:46] <TimToady> Corp and Corn, obviously :)

[03:00] *** gimix joined
[03:07] <colomon> how do you turn on Rakudo's grammar debugging?

[03:09] <colomon> (he said, optimistically thinking that he vaguely remembers such a thing exists.)

[03:11] *** jaldhar joined
[03:16] *** awj joined
[03:24] *** envi left
[03:25] *** envi joined
[03:26] *** awwaiid joined
[03:27] *** eternaleye joined
[03:32] <PerlJam> colomon: <?DEBUG>

[03:32] <PerlJam> colomon: from that point onward the rules that match will output verbose information about the matches

[03:33] <colomon> from that point onward -- forward in time, further down the stack, hmm?

[03:33] <PerlJam> further down the stack

[03:34] <colomon> PerlJam++

[03:53] *** nymacro joined
[03:53] *** nymacro left
[03:54] *** nymacro joined
[03:54] <colomon> So, the debugger is telling me where it goes wrong, but as far as I can tell there's no reason for panic there....

[04:11] *** satyavvd joined
[04:17] <sorear> TimToady: CORE, Corp, and Corn?

[04:24] <mberends> that just needs a Cork as well

[04:28] <jdhore> and Cord

[04:31] *** am0c joined
[04:50] *** benabik joined
[04:55] *** woosley left
[04:55] *** woosley1 joined
[04:59] *** woosley1 left
[05:03] *** nymacro left
[05:03] <sorear> hrm

[05:03] <sorear> role composition needs to be able to turn normal methods into multi

[05:05] <sorear> pugs: say (1 +> 1):rotate

[05:05] <p6eval> pugs: OUTPUT«pugs: Named argument found where no matched parameter expected: (rotate,Val (VBool True))␤»

[05:05] <sorear> TimToady: what should that give? :)

[05:34] *** twinshadow joined
[05:46] *** orafu joined
[05:46] *** bbkr_ joined
[05:49] *** cosimo joined
[06:07] *** bacek joined
[06:09] <mberends> \o/ sorear++ niecza passes all 786 tests on mono 2.6.7 (Debian 6.0 i386)

[06:17] *** bbkr_ left
[06:18] *** bbkr_ joined
[06:19] *** bacek left
[06:19] *** nymacro joined
[06:35] *** cosimo left
[06:37] *** bacek joined
[06:38] <sorear> \o/

[06:39] <sorear> mberends: psst. mono --aot run/*.dll run/Niecza.exe && ln -s /path/to/roast t/spec && t/run_spectests

[06:39] <mberends> ok

[06:41] * sorear is back with better ideas of how to factor MMD

[06:41] <mberends> "The assembly mscorlib.dll was not found or could not be loaded. It should have been installed in the `/usr/lib/mono/1.0/mscorlib.dll' directory." Out-the-box Debian.

[06:42] <sorear> wait, it passed 'make test', but failed like that?

[06:42] <mberends> yes :(

[06:43] <sorear> do you have mono-complete (specifically, libmono-corlib1.0-cil) installed?

[06:43] <mberends> it did choke on lack of gmcs during the first build, then finished after I apt-got mono-gmcs. maybe a clean rebuild?

[06:44] * mberends looks

[06:45] *** kaare_ joined
[06:45] <sorear> sounds like you probably don't.

[06:45] <sorear> niecza isn't Debian-mono-aware; mono-complete is recommended

[06:46] <mberends> mono-complete is not installed. OMG, installing it will bring the whole Internet into my netbook

[06:47] <sorear> how many not-obviously-Mono packages?

[06:47] <sorear> the specific missing file you just noticed should be in libmono-corlib1.0-cil

[06:47] <mberends> Firebird2.5, libmono-oracle1, libmono-oracle2, I do not really want

[06:48] *** bacek left
[06:52] <mberends> sudo apt-get -s install mono-complete lists 33 lines off package names

[06:52] <mberends> laterz, commute &

[06:55] *** wtw joined
[06:56] *** wooden joined
[06:56] *** wooden left
[06:56] *** wooden joined
[06:58] *** agentzh joined
[07:04] *** bacek joined
[07:11] *** bacek left
[07:19] *** [particle]1 left
[07:20] *** [particle] joined
[07:23] *** bacek joined
[07:26] *** fhelmberger joined
[07:37] *** nymacro left
[07:58] *** woosley joined
[08:02] *** satyavvd left
[08:05] *** meteorjay joined
[08:21] *** satyavvd joined
[08:22] *** M_o_C joined
[08:23] *** GinoMan joined
[08:30] *** Cinil joined
[08:31] *** Cinil left
[08:33] *** kvakvs joined
[08:35] *** mberends joined
[08:37] *** literal joined
[08:37] *** vert2 joined
[08:39] *** perplexa joined
[08:40] <mberends> sorear: sudo apt-get install libmono-corlib1.0-cil installs only two packages, then the mono --aot run/*.dll run/Niecza.exe succeeds to niecza/run/RxOp.dll and fails at niecza/run/SAFE.DLL

[08:41] <mberends> WARNING **: The class Niecza.DynMetaObject could not be loaded, used in Kernel, Version=0.0.0.0 etc etc

[08:41] *** hanekomu joined
[08:42] <mberends> warnings are apparently fatal when in caps

[08:45] *** mtk left
[08:53] *** mtk joined
[08:57] *** woosley left
[09:01] <mberends> sorear: for portability testing I highly recommend occasionally trying your code on one of these: http://www.debian.org/CD/live/ (I sometimes try a Live FreeBSD as well)

[09:06] *** ruderer joined
[09:13] *** dima_ joined
[09:15] *** ruderer left
[09:18] *** Tedd1 joined
[09:24] <jnthn> morning o/

[09:27] <Tene> hallo jnthn

[09:28] *** Mowah joined
[09:29] *** dakkar joined
[09:37] *** am0c left
[09:38] <mberends> morning jnthn, had enough beauty sleep?

[09:38] *** am0c joined
[09:38] <moritz_> and did it halp? :-)

[09:38] <jnthn> No, I'm really ugly today. :P

[09:40] <mberends> just write beautiful code, and all will be forgiven

[09:41] *** am0c left
[09:43] <jnthn> Right now I'm working on docs at $dayjob to avoid the ugly codebase. :P On the upside, at least somebody writes docs!

[09:44] *** Mowah left
[09:44] *** Mowah joined
[09:45] <jnthn> Oh great...writing docs = discovering security vulnerability in the thing I'm documenting. :/

[09:46] <mberends> :)

[09:57] *** cosimo joined
[10:04] *** Axius joined
[10:14] *** agentzh left
[10:22] *** Rotwang joined
[10:28] *** M_o_C left
[10:29] *** kvakvs left
[10:38] *** kvakvs1 joined
[10:39] *** kvakvs1 left
[10:40] *** pausenclown joined
[10:42] *** pausenclown left
[10:42] *** jeteve_ joined
[10:48] *** jeteve_ left
[10:51] *** cosimo left
[10:55] *** daxim joined
[10:55] *** pausenclown joined
[10:57] *** shi joined
[11:07] *** Rotwang left
[11:13] *** pausenclown left
[11:19] *** Axius left
[11:35] *** jaldhar left
[11:35] *** jaldhar joined
[11:44] *** woosley joined
[11:56] *** pausenclown joined
[12:00] *** pausenclown left
[12:52] *** [particle]1 joined
[12:54] *** [particle] left
[13:03] <[Coke]> jnthn: so, you did the hard work. Good think you have coworkers on the channel to do the hard bits.

[13:03] <takadonet> morning all

[13:03] <[Coke]> er, s/hard/boring/:2nd

[13:06] <awwaiid> Am I restricted from doing 'class Array is also { ... }'?

[13:07] <moritz_> awwaiid: 'is also' is gone. Grep for 'augment' in the specs

[13:09] <awwaiid> gracias

[13:18] <awwaiid> Though this I have now gained further insight into Whatever-star :)

[13:18] <awwaiid> wanted to see if Array got something special when you do $stuff.pick(*). But no! Just gets Whatever.

[13:18] <awwaiid> which is, of course, wonderful

[13:19] *** hanekomu left
[13:21] <awwaiid> Exploring through experiment is fun. And now when I go to look at how it's implemented in Rakduo it is even further solidified.

[13:21] *** _twitch joined
[13:25] *** arnsholt joined
[13:40] *** _twitch left
[13:47] *** woosley left
[13:50] <tadzik> hello Zebras

[13:51] <takadonet> tadzik: mroning

[13:51] <takadonet> morning*

[13:52] <tadzik> will there be Rakudo GSoC tasks?

[13:53] <Util> rakudo: my $pair = "k1" => "v1"; my $k = $pair.key; say $k; say $k.trans( ["k"] => ["z"] );

[13:53] <p6eval> rakudo a38d45: OUTPUT«k1␤z1␤»

[13:53] <Util> rakudo: my $pair =  k1  => "v1"; my $k = $pair.key; say $k; say $k.trans( ["k"] => ["z"] );

[13:53] <p6eval> rakudo a38d45: OUTPUT«k1␤too few positional arguments: 2 passed, 3 (or more) expected␤  in main program body at line 22:/tmp/xlJ8M2sS1D␤»

[13:53] <Util> rakudo: my $pair = :k1("v1");    my $k = $pair.key; say $k; say $k.trans( ["k"] => ["z"] );

[13:53] <p6eval> rakudo a38d45: OUTPUT«k1␤too few positional arguments: 2 passed, 3 (or more) expected␤  in main program body at line 22:/tmp/IcKwnMr4te␤»

[13:53] <Util> Known bug? Something magical about a auto-quoted key, like a "can be a named argument" flag?

[13:54] <flussence_> std: my $pair =  k1  => "v1"; my $k = $pair.key; say $k; say $k.trans( ["k"] => ["z"] );

[13:54] <p6eval> std 4608239: OUTPUT«ok 00:01 123m␤»

[13:54] <flussence_> those all look like they should work, to me...

[13:55] <Util> The first one works as I would expect. #2 and #3 should work the same as #1; I can't see why they die.

[13:58] *** donri joined
[14:02] *** Mowah left
[14:03] *** nymacro joined
[14:06] *** fhelmberger left
[14:06] <jnthn> tadzik: I plan to make some Rakudo GSoC suggestions that I'd be willing to mentor.

[14:07] <tadzik> jnthn: is Rakudo represented by Perl foundation? I think today's the deadline for GSoC organizations application

[14:10] *** mtk left
[14:11] *** mtk joined
[14:12] <jnthn> tadzik: I think so, yes.

[14:14] *** [particle]1 is now known as [particle]

[14:21] <Tene> jnthn: looks like I've got no commitments over the weekend; any chance you'll be available for consulting about 6model?

[14:23] <jnthn> Tene: Yes, I'm planning to do some 6model-y hacking this weekend. :)

[14:23] <Tene> Great.

[14:23] *** Bzek joined
[14:23] <Tene> I really really should get to sleep soon...

[14:25] *** kaare_ left
[14:25] <jnthn> What time is it there?!

[14:25] <[Coke]> dukeleto submitted apps for both PAFO & TPF

[14:25] <[Coke]> 4:30

[14:26] <[Coke]> </obscure 90s pop music reference>

[14:26] <jnthn> Too obscure for me :P

[14:26] <jnthn> I know only know "What time are you going to the dentist?" "2:30" :P

[14:26] <[Coke]> http://www.youtube.com/watch?v=e86omL8uzks

[14:27] * [Coke] hasn't heard the full song in a while. google++

[14:28] <Tene> jnthn: 6:30

[14:29] *** plainhao joined
[14:29] <Util> jnthn: Is your long-term intention for the Meta Object Protocol to be in: Parrot? NQP? Perl6? All three?

[14:41] *** satyavvd left
[14:41] <jnthn> Util: All three (more)

[14:41] <jnthn> Languages should supply their meta-objects that implement OO as they view it.

[14:42] *** woosley joined
[14:42] <jnthn> Parrot could contain the core

[14:42] <jnthn> That's really up to Parrot folks :)

[14:42] <jnthn> The core is pretty minimal. Doesn't even know what inheritance is, for exmaple.

[14:43] <mberends> of course not Perl6, but you bothe probably mean Rakudo instead

[14:45] <mberends> the closer the parts align, the less glue we need to put on because of impedance mismatches

[14:45] <jnthn> oh heh, I read "Rakudo" jsut because that's what I expected the question to say :)

[14:49] <Util> mberends: yes, I meant "Rakudo" instead of Perl 6. Thanks

[14:51] <Util> jnthn: which of the three will actually use MOP first?

[14:51] <twinshadow> How can I makes calls to Parrot from Rakudo or another Perl 6? Would it just be NativeCall?

[14:53] <jnthn> You can only make calls to Parrot from a Perl 6 implementation running on Parrot. :) But Rakudo is one that is. You can use pir::foo() to call Parrot opcode foo. Or Q:PIR { ... } lets you embed PIR. But you're making your code backend specific by using those.

[14:53] <jnthn> NativeCall is for calling C libraries.

[14:54] <Tene> twinshadow: at one time, Rakudo supported "use Foo :from<parrot>;", but that's been broken for quite a while afaik.

[14:54] <Tene> Same with eval "...", :lang<parrot>;

[14:54] <donri> pir::, are those only in nqp?

[14:55] <donri> rakudo: pir::say("hi");

[14:55] <p6eval> rakudo a38d45: OUTPUT«hi␤»

[14:55] <jnthn> donri: They're available in Rakudo too *at the moment*.

[14:55] *** cjk101010 joined
[14:55] <jnthn> donri: In the not too distant future they'll need a pragma to make them work.

[14:55] <donri> how does perl6 pragmas look?

[14:55] <jnthn> So people declare up front they're writing a superset of Perl 6.

[14:55] <donri> use pir;?

[14:55] <twinshadow> Fun. I found a Markdown PIR, and was considering using it in a P6 Text-Markdown module

[14:55] <jnthn> use ParrotyStuff; 

[14:55] <jnthn> or something

[14:56] *** flatwhatson_ joined
[14:57] <donri> hey does eval() take some pair for hllcompiler 'target'?

[14:57] <Tene> donri: :lang

[14:58] <Tene> oh, wait, target?  No.

[14:58] <donri> Tene: say i want to eval ruby to a past in perl6

[14:58] <Tene> It certainly could.

[14:58] <Tene> when I've wanted to do that myself, I've just grabbed the compiler object and called the methods directly

[14:58] <jnthn> That's probably the better way.

[14:59] <donri> or maybe there could be a compile() function :)

[14:59] * mberends does the TGIF dance and dashes to the de-commute &

[14:59] *** mberends left
[15:01] <donri> python does that: you can compile() to a code object that can then be eval()d or exec'd, useful if you're gonna eval the same thing more than once

[15:01] *** Mowah joined
[15:01] <donri> http://lucumr.pocoo.org/2011/2/1/exec-in-python/

[15:04] <jnthn> You can mimic that with Perl 6 eval just by evaling a closure :)

[15:04] <jnthn> Though I agree that feels less neat.

[15:04] *** shi left
[15:05] <donri> which makes me wonder, is parrot (rakudo) compile-on-run or does/will it do anything like python's .pyc?

[15:05] <donri> sure you can do that manually, compiling to .pbc

[15:05] <donri> but if you just perl6 foo.pl twice, will it compile twice?

[15:05] <moritz_> I guess in the long run we'll do something like storing the .pbcs

[15:06] *** gdey_ joined
[15:06] <moritz_> and I think there will be something like   Perl6::Compiler.compile($string), which returns a Code object

[15:06] <moritz_> which you can then invoke as $code.(@argv)

[15:06] <donri> might be worth noting that python seems to have learned that storing them next to the source is suboptimal: http://www.python.org/dev/peps/pep-3147/

[15:08] <donri> perhaps pbc's are supposed to be more backwards-compatible though, but then again, it's rather annoying to have pyc's all over your source tree

[15:09] *** wtw left
[15:13] *** nymacro left
[15:19] *** woosley left
[15:19] *** MayDaniel joined
[15:20] <flussence_> I think a good start would be $XDG_CACHE_DIR/parrot/${full_path_to_file}_${file_hash}.{pbc,pir}

[15:21] <jnthn> You'll have to deal with rolling invalidations too.

[15:21] <flussence_> rolling invalidations?

[15:21] <jnthn> gha, that was wrong wrod

[15:21] <jnthn> *word

[15:21] <jnthn> I mean

[15:22] <jnthn> if you have a Foo.pm that is pre-compiled, and a Bar.pm that does use Foo; and then Foo.pm changes, then the cache of it *and* Bar.pm is now invalid.

[15:22] <jnthn> It's all do-able, it just needs a bit more than file level :)

[15:22] <flussence_> oh, never thought of that. files that modify their caller's code...

[15:23] <jnthn> It doesn't even need to be that complicated a case

[15:24] <jnthn> If we compile calls to methods with v-table index optimizations, for example, and then the object changes, the indexes in the call are now invalid.

[15:24] <jnthn> Or if the compiler decided to inline something from another module.

[15:24] <[Coke]> jnthn: my vote is to just make compilation faster. ;)

[15:24] *** hercynium joined
[15:25] <jnthn> :)

[15:25] <jnthn> My vote is for both :P

[15:25] <moritz_> our ideas from the Copenhagen hackathon were a simple flat cache directory, and a meta data file that stores the dependency tree

[15:25] <jnthn> *nod*

[15:26] <jnthn> OK, enough $dayjob for one day. 

[15:26] * jnthn -> home :)

[15:28] *** sftp joined
[15:29] *** [particle] left
[15:30] *** synple joined
[15:30] <flussence_> completely crazy idea: have a perl6 daemon that keeps the setting persistent in memory and forks to run .p6 files

[15:31] *** [particle] joined
[15:31] <flussence_> (do we have a working fork() yet? I can imagine that being done in 2 dozen lines of code...)

[15:32] <[Coke]> jnthn: what, it's only... right, time zones. HOW DO THEY WORK!?

[15:33] *** synple_ joined
[15:35] *** synple_ left
[15:35] *** synple left
[15:37] *** Holy_Cow joined
[15:37] *** thr0w joined
[15:37] *** synple joined
[15:39] *** alester joined
[15:41] <Tene> flussence_: I wrote an implementation of async { ... }; for Rakudo over two years ago that worked fine, except for how it crashed due to a parrot bug.  It's still unfixed, and nobody's planning to work on threading in Parrot any time soon.

[15:42] <flussence_> aww :(

[15:43] *** Mowah_ joined
[15:43] *** Mowah_ left
[15:48] *** thr0w left
[15:49] *** thr0w joined
[15:50] <donri> flussence_: the point in python though is incompatible bytecode between versions; if that could be an issue in parrot the path should be versioned too

[15:51] <donri> also i don't see the point in filepath AND hash, just hash should be nuff?

[15:51] <donri> or path + syncronised mtime

[15:52] <Tene> flussence_: there are some patches submitted on trac that I wasn't able to verify correctness of; You could always take up the work yourself and try looking into the current state of this bug: http://trac.parrot.org/parrot/ticket/757

[15:52] <Tene> I would be shocked if the patches applied cleanly, but they might at least be relevant information.

[15:52] <flussence_> donri: if it has the filepath then it's easier to clean stale entries out, because there's a pointer back to the source file

[15:53] <donri> true, but then it's also fixed to a filepath and dead if you move the source, not that it might be a big issue

[15:54] <flussence_> well, it's only a cache after all

[15:55] <flussence_> Tene: that stuff looks *way* outside my area of competence :)

[15:55] <Tene> flussence_: me too :)

[16:02] *** Mowah left
[16:05] *** [particle] left
[16:08] *** gdey_ left
[16:08] *** [particle] joined
[16:12] * jnthn home :)

[16:14] <Tene> jnthn: if a simplified repr for cardinal happened to be waiting for me when I wake up later today, I wouldn't mind. ;)

[16:14] <colomon> \o/

[16:16] *** mberends joined
[16:18] *** Holy_Cow left
[16:19] *** Psyche^ joined
[16:19] *** Psyche^ is now known as Patterner

[16:20] *** [particle] left
[16:20] <jnthn> Tene: ;)

[16:26] *** [particle] joined
[16:28] *** silent_h_ joined
[16:35] <mberends> flussence_: https://github.com/jnthn/zavolaj/blob/master/examples/unix-fork.p6

[16:36] *** justatheory joined
[16:44] *** mtk left
[16:44] *** Mowah joined
[16:44] *** mtk joined
[16:45] *** gdey_ joined
[16:52] *** mj41 joined
[16:53] *** envi left
[16:57] *** silent_h_ left
[17:04] <Tene> phenny: remind me to post gsoc proposals

[17:05] <Tene> phenny: tell tene to post gsoc proposals

[17:05] <phenny> You can tell yourself that.

[17:05] <Tene> phenny: :(

[17:06] <jnthn> phenny: tell tene to post gsoc proposals

[17:06] <phenny> jnthn: I'll pass that on when tene is around.

[17:06] <jnthn> :)

[17:06] <jnthn> Tene: Don't thank me. :P

[17:14] *** am0c joined
[17:14] *** gdey_ left
[17:15] *** gdey_ joined
[17:19] *** dakkar left
[17:21] *** KyleHa joined
[17:21] *** am0c left
[17:22] <sorear> good * #perl6

[17:22] <TimToady> o/

[17:23] <jnthn> o/

[17:23] <sorear> mberends: rm run/SAFE.DLL; it's no longer used for anything

[17:23] <sorear> mberends: must be stale from an earlier build.

[17:23] <mberends> :D thanks

[17:23] <sorear> mberends: also the --aot step is optional.

[17:26] *** literal left
[17:26] *** literal joined
[17:27] <sorear> moritz_: (caching compiled modules) Are you interested in how niecza does it?

[17:27] <moritz_> sorear: sure

[17:28] *** dsp_ joined
[17:34] *** am0c joined
[17:36] *** dsp_ left
[17:38] *** gdey_ left
[17:38] *** gdey_ joined
[17:40] *** dsp_ joined
[17:44] *** shi joined
[17:44] *** shi left
[17:45] *** shi joined
[17:46] *** shi left
[17:46] *** shi joined
[17:48] *** shi left
[17:49] *** shi joined
[17:50] *** dsp_ left
[17:51] *** shi left
[17:51] *** shi joined
[17:52] *** shi left
[17:53] *** shi joined
[17:53] *** shi left
[17:54] *** shi joined
[17:54] *** shi left
[17:54] *** dsp_ joined
[17:55] *** shi joined
[17:56] *** shi left
[17:56] *** shi joined
[18:01] *** shi left
[18:01] *** shi joined
[18:02] *** shi left
[18:03] *** daxim left
[18:03] *** shi joined
[18:03] *** shi left
[18:04] <mberends> sorear++: \o/ niecza t/run_spectests passed all 1444 tests

[18:04] *** shi joined
[18:05] *** shi left
[18:05] *** shi joined
[18:06] <jnthn> Anyone know where Rakudo GSoC project suggestions should get posted?

[18:06] <moritz_> jnthn: http://epo.means.no/gsoc2011/ideas I think

[18:06] *** shi left
[18:07] *** shi joined
[18:08] *** shi left
[18:09] *** shi joined
[18:10] <tadzik> epo means no. Not a fortunate url I'd say

[18:10] *** shi left
[18:10] *** am0c left
[18:11] *** shi joined
[18:11] <mberends> shi: speak up or get banned!

[18:11] *** shi left
[18:12] <tadzik> I assume he enters and leaves again? Looks like my weechat does a good job filtering that

[18:12] <jnthn> https://gist.github.com/866304 # one of my ideas for GSoC project I'd be happy to mentor.

[18:12] *** shi joined
[18:13] *** shi left
[18:13] <tadzik> nice one

[18:13] *** lichtkind joined
[18:13] *** shi joined
[18:14] *** kaare_ joined
[18:14] <moritz_> indeed

[18:14] <tadzik> how do I run spectests in niecza?

[18:14] <diakopter> flaky connection;doesn't seem intentional

[18:14] <moritz_> ./t/run_spectests

[18:14] *** shi left
[18:14] <diakopter> two competing clients maybe :)

[18:15] <tadzik> bah, that doesn't work at all

[18:15] <KyleHa> The Test.pm dies_ok still has the Null PMC access check commented out. Why does that not work?

[18:15] <moritz_> KyleHa: probably would now

[18:15] *** shi joined
[18:15] <tadzik> http://wklej.org/id/491013/

[18:15] <KyleHa> moritz_:  I tried putting it in, and I got all kinds of fireworks.

[18:15] *** shi left
[18:15] <moritz_> tadzik: stale t/spec/ ?

[18:16] <moritz_> tadzik: it doesn't update that for your automatically

[18:16] <tadzik> moritz_: I have no t/spec

[18:16] <moritz_> tadzik: that might explain it :-)

[18:16] <tadzik> hah :)

[18:16] *** shi joined
[18:17] *** shi left
[18:17] <tadzik> yeah, for some reason that helped :)

[18:17] *** shi joined
[18:18] <jnthn> Added my GSoC idea to http://epo.means.no/gsoc2011/ideas

[18:19] *** shi left
[18:20] *** shi joined
[18:20] *** shi left
[18:21] *** shi joined
[18:22] *** shi left
[18:22] <lichtkind> rakudo: my @y; push @y[0], [<a b>];

[18:22] <p6eval> rakudo a38d45: OUTPUT«Method '!fill' not found for invocant of class ''␤  in 'List::push' at line 2905:CORE.setting␤  in main program body at line 22:/tmp/xE7sRMLT7A␤»

[18:22] *** shi joined
[18:23] <lichtkind> rakudo: my @y = 1,2; push @y[0], [<a b>];

[18:23] <p6eval> rakudo a38d45: OUTPUT«Method '!fill' not found for invocant of class 'Int'␤  in 'List::push' at line 2905:CORE.setting␤  in main program body at line 22:/tmp/VyOiYdZMOy␤»

[18:23] *** gdey- joined
[18:23] *** shi left
[18:23] <lichtkind> rakudo: my @y = [],[]; push @y[0], [<a b>];

[18:23] <p6eval> rakudo a38d45:  ( no output )

[18:24] *** shi joined
[18:24] <lichtkind> rakudo: my @y = [],[]; push @y[0], [<a b>]; @y.perl.say

[18:24] <p6eval> rakudo a38d45: OUTPUT«[[["a", "b"]], []]␤»

[18:24] <tadzik> niecza passes the tests for me too

[18:24] *** shi left
[18:25] *** shi joined
[18:25] *** shi left
[18:26] *** kaare_ left
[18:27] *** gdey_ left
[18:34] *** cdarroch joined
[18:34] *** cdarroch left
[18:34] *** cdarroch joined
[18:35] <KyleHa> rakudo: try { say 'OH HAI' }; if "$!" ~~ /OMG/ { say 'WTF' }; say 'JK!';

[18:35] <p6eval> rakudo a38d45: OUTPUT«OH HAI␤␤  in main program body at line 1␤»

[18:36] <KyleHa> Thou shalt not smartmatch an undefined stringied $!

[18:36] <rokoteko> isnt $! still unspecced anyhow?

[18:37] <takadonet> thank you perl6 for .trim :)

[18:41] <TimToady> rakudo: { say 'OH HAI'; CATCH { when /OMG/ { say 'WTF' } } }; say 'JK!'

[18:41] <p6eval> rakudo a38d45: OUTPUT«OH HAI␤Null PMC access in setprop()␤  in main program body at line 22:/tmp/rQW2DRjleS␤»

[18:41] <TimToady> o_O

[18:41] <jnthn> OMGWTF...

[18:41] <KyleHa> Is it true there's no more $! ?

[18:42] <TimToady> no

[18:42] <KyleHa> Oh good. Phew.

[18:42] <TimToady> but the standard way of dealin with $! doesn't explicitly mention it

[18:42] <TimToady> see my attempt

[18:44] <colomon> adding a CATCH phaser to a block is adding a de facto try statement to it, or something like that?

[18:44] <jnthn> rakudo: { say 'OH HAI'; CATCH { when /OMG/ { say 'WTF' } } };

[18:44] <p6eval> rakudo a38d45: OUTPUT«OH HAI␤Null PMC access in setprop()␤  in main program body at line 22:/tmp/JwfCIhJEh0␤»

[18:44] <TimToady> colomon: since about forever :)

[18:44] <jnthn> rakudo: { say 'OH HAI'; CATCH { say "in catch"; when 'OMG' { say 'WTF' } } };

[18:44] <p6eval> rakudo a38d45: OUTPUT«OH HAI␤Null PMC access in setprop()␤  in main program body at line 22:/tmp/j7MEvfgknL␤»

[18:44] <jnthn> rakudo: { say 'OH HAI'; CATCH { say "in catch"; } };

[18:44] <p6eval> rakudo a38d45: OUTPUT«OH HAI␤Null PMC access in setprop()␤  in main program body at line 22:/tmp/2fBYZ3Ttey␤»

[18:45] <jnthn> rakudo: { CATCH { say "in catch"; } };

[18:45] <p6eval> rakudo a38d45: OUTPUT«Null PMC access in setprop()␤  in main program body at line 22:/tmp/m1bVwGE7CR␤»

[18:45] <jnthn> rakudo: CATCH { say "in catch"; }

[18:45] <colomon> TimToady: I have carefully ignored exception handling in p6.  

[18:45] <p6eval> rakudo a38d45:  ( no output )

[18:45] <jnthn> rakudo: my $x = -> { CATCH { say "in catch"; } }; $x()

[18:45] <p6eval> rakudo a38d45:  ( no output )

[18:45] <takadonet> what is the different between BEGIN {} and INIT {} ?

[18:45] <jnthn> :/

[18:45] <colomon> TimToady: and since it looks like it doesn't actually work yet... ;)

[18:46] <TimToady> BEGIN runs immediately upon parsing

[18:46] <TimToady> INIT runs at INIT time when the official run-time is starting up

[18:46] <TimToady> so if you have separate compilation, BEGIN happens at compile, INIT at run

[18:47] <TimToady> CHECK happens at the end of compile time

[18:47] <takadonet> so if i wanted to initialize a package variable, it be better to set in INIT?

[18:47] <TimToady> END at the end of run time

[18:48] <rokoteko> I was mainly talking about the spec. isnt it true that stuff like $!.pending does exist?

[18:48] <TimToady> the initializer on an 'our' is defined to run at INIT time

[18:48] <rokoteko> but how does the pending queue end up in $! ? that is still a mystery to me.

[18:48] <TimToady> there have been discussions of renaming $! to @!

[18:48] <rokoteko> and what on earth is $! anyhow, is it an array, is it a variable?

[18:48] <rokoteko> TimToady: ahh.

[18:49] <rokoteko> I havent been following very closely.

[18:49] <TimToady> several months ago now

[18:49] <rokoteko> For several months I havent been following either. :)

[18:50] <rokoteko> Anyhow, Im happy to heard its proceeding.

[18:50] <TimToady> and CATCH might actually be 'for @!' rather than 'given $!'

[18:50] <takadonet> TimToady: thanks. It is exactly what I did

[18:51] <TimToady> rakudo: say $GLOBAL::foo; our $foo = 1;

[18:51] <p6eval> rakudo a38d45: OUTPUT«Null PMC access in type()␤  in main program body at line 22:/tmp/54zlEFjMdA␤»

[18:51] <TimToady> hmm

[18:52] <jnthn> Rakudo doesn't, afaik, know GLOBAL/UNIT and so on 

[18:52] <TimToady> rakudo: say our $foo; our $foo = 1;

[18:52] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Redeclaration of symbol $foo at line 22, near " = 1;"␤»

[18:52] <jnthn> std: say our $foo; our $foo = 1;

[18:52] <p6eval> std 4608239: OUTPUT«ok 00:01 121m␤»

[18:52] <jnthn> std: say my $foo; my $foo = 1;

[18:52] <p6eval> std 4608239: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $foo (see line 1) at /tmp/3dOQG8spaJ line 1:␤------> [32msay my $foo; my $foo[33m⏏[31m = 1;[0m␤ok 00:01 121m␤»

[18:53] <jnthn> Why the inconsistency?

[18:53] <TimToady> globals are meant to be shared

[18:53] <TimToady> so we expect 'our' in multiple locations for the same package var

[18:53] <jnthn> hm

[18:54] <jnthn> So we decide just on scope declarator?

[18:54] <TimToady> rakudo: { say our $foo; }; { our $foo = 1; }

[18:54] <p6eval> rakudo a38d45: OUTPUT«Any()␤»

[18:54] <TimToady> looks like rakudo is not yet initializing ours at INIT time

[18:54] <jnthn> What should that have printed?

[18:54] <jnthn> 1?

[18:54] <TimToady> yes

[18:55] <jnthn> News to me.

[18:55] <takadonet> rakudo: {our $x  INIT { $x=42 } say $x;}

[18:55] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[18:55] <TimToady> S03:4802

[18:55] <takadonet> rakudo:our $x INIT { $x=42 } say $x;

[18:55] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Confused at line 22, near "our $x INI"␤»

[18:55] <jnthn> Do we parse it any differently to a normal assignment?

[18:55] <moritz_> takadonet: that's two terms in a row

[18:56] <takadonet> ya just saw that

[18:56] <rokoteko> TimToady: do you think perl 6 is experiencing the second system syndrome?

[18:56] <takadonet> rakudo: our $x; INIT { $x=42 }; say $x;

[18:56] <p6eval> rakudo a38d45: OUTPUT«Null PMC access in getprop()␤  in '&infix:<=>' at line 1␤  in main program body at line 22:/tmp/KMJbUzIYKW␤»

[18:56] <TimToady> rokoteko: our slogan is "Second System Syndrome Done Right!"

[18:56] <rokoteko> SSSDR. That's not very far from CCCP.

[18:56] *** bbkr_ left
[18:57] <TimToady> yes, but at least it's a "democratic republic"

[18:57] <rokoteko> probably some AI system could figure out the link pretty quickly. :)

[18:57] <takadonet> rakudo:our $x; INIT { our $x=42}; say $x;

[18:57] <p6eval> rakudo a38d45: OUTPUT«42␤»

[18:57] <TimToady> should work in the other order

[18:57] *** bbkr_ joined
[18:57] <TimToady> rakudo: say our $x; INIT { our $x = 42 }

[18:58] <p6eval> rakudo a38d45: OUTPUT«42␤»

[18:58] <jnthn> Is that correct?

[18:58] <TimToady> how could it not be?

[18:58] <jnthn> So every time we see an our $foo = ..., we have to actually do the assignment at INIT time?

[18:58] <TimToady> I mean, the INIT shouldn't be necessary

[18:58] <jnthn> What if it's

[18:58] <TimToady> all assignment to declarators is special

[18:58] <TimToady> think about 'has'

[18:59] <TimToady> assignment to 'my' is the least special

[18:59] <jnthn> sub foo($x) { our $y = $x; say $y; } # what happens here?

[18:59] <jnthn> I assume Any() ?

[18:59] <TimToady> I would assume so

[19:00] <jnthn> That feels kinda weird.

[19:00] <TimToady> yes, but we're trying to avoid Unicode operators

[19:00] <jnthn> It's like making them init-time constants or something.

[19:01] <TimToady> it's consistent with other declarations; see the passage in S03

[19:01] *** masak joined
[19:01] <masak> weekend! \o/

[19:01] <phenny> masak: 01:28Z <sorear> tell masak STD.pm6 uses ~= to construct error messages in a few places.  I haven't figured out how to make a sane (fast!) implementation of my $x; $x ~= "x"; ok $x eq "x";

[19:01] <masak> sorear: ah.

[19:01] <colomon> masak!  \o/

[19:01] <mberends> \o masak

[19:02] <jnthn> TimToady: In a handwavy "as early as it makes sense given the scope" sorta sense I guess it does.

[19:02] <jnthn> Doesn't mean I'm going to like it. :)

[19:04] <TimToady> s/scope/lifetime/

[19:04] <jnthn> Yes, lifetime is a better word.

[19:04] *** [particle] left
[19:04] *** bbkr_ left
[19:04] <jnthn> Maybe it'll grow on me.

[19:04] *** bbkr_ joined
[19:05] <TimToady> masak, sorear: the specs for the semantics of ~= and friends are at S03:3987

[19:05] *** [particle] joined
[19:06] <TimToady> is that insane or non-fast?

[19:07] <tadzik> masak: o/

[19:08] <jnthn> Righty, noms, then nqp/ctmo hacking. :)

[19:08] <diakopter> TimToady: yes?

[19:08] * jnthn wonders if he can finish the branch this weekend :)

[19:08] <rokoteko> "non-fast" mentioned at the develop phase?

[19:09] <diakopter> where "fast" means "even fast enough to have a tolerable development/test cycle"

[19:09] <rokoteko> where "mentioned at the develope phase" means "who gives a fucking shit?"

[19:10] <diakopter> O

[19:10] <rokoteko> Just make it work. when there are practical applications suffering from performance, then optimize it. :)

[19:11] *** Lorn joined
[19:11] <TimToady> one of the tenets of SSSDR is to do everything all at once, even though you can't...

[19:11] <TimToady> rokoteko: and we are allowed to think about optimizability in general terms

[19:11] <diakopter> :) all you want; my point was "development *is* a practical application"

[19:12] <diakopter> (and if the development takes forever because the development/test cycle takes forever...)

[19:13] <rokoteko> Ahh. Sorry, Im not a perl6 developer. Id rather see it fully working first and people use actually use it and *then* optimize for performance where you see the need for for it. but who am I to comment?

[19:14] <TimToady> that's kinda either-or thinking, when the reality is we make a gradual transition from make-it-work to make-it-work-fast

[19:14] <moritz_> rokoteko: that was our approach at first too

[19:14] <rokoteko> moritz_: what happened?

[19:14] <TimToady> it was very slow

[19:14] <moritz_> rokoteko: and then we noticed that once we had a usable compiler (in terms of features), what people wanted next was speed

[19:14] <rokoteko> Ahh.. Ive been critizing about that also.

[19:14] <moritz_> rokoteko: long before it was "done"

[19:15] <rokoteko> "man, this is so slow, can this ever be done using Parrot" - I remember myself asking here.

[19:15] <TimToady> the fact is that your optimize later approach works well with specific applications, but for interpreters and compilers you don't really know even when you're "done" where the user's hotspots are going to be

[19:16] <TimToady> rokoteko: so now you're complaining that we're worrying about "faster"? :P

[19:16] <rokoteko> ok. so $! (THE goddamn error variable) is not implemented yet. and then you talk about lazy evaluation but the feed operators arent yet working?

[19:16] <moritz_> rakudo: try { die "foo" }; say $!

[19:16] <p6eval> rakudo a38d45: OUTPUT«foo␤»

[19:16] <rokoteko> TimToady: yes, I understand the contradiction of my comments, but it's just my comments. :)

[19:16] <TimToady> looks implemented to me

[19:17] <moritz_> who said it was NYI?

[19:17] <TimToady> and feeds are only one form of laziness

[19:17] <rokoteko> moritz_: arent they supposed to be stacked when using fail() ?

[19:17] <diakopter> perl6: try { die "foo" }; say $!

[19:17] <jnthn> rakudo: <foo bar baz> ==> map *.uc ==> say

[19:17] <p6eval> pugs, rakudo a38d45, niecza v3-65-g55abf9d: OUTPUT«foo␤»

[19:17] <p6eval> rakudo a38d45: OUTPUT«FOOBARBAZ␤»

[19:17] <moritz_> rokoteko: yes, but that's not the same as "not yet implemented"

[19:17] <rokoteko> moritz_: oh. ok.

[19:18] <TimToady> "working consensus and rough code"  :)

[19:18] <rokoteko> moritz_: so the stacking when using fail() is implemented?

[19:18] <moritz_> rokoteko: no

[19:18] <rokoteko> ...

[19:18] <moritz_> rokoteko: it's not. But that doesn't meant that $! per se is not yet implemented

[19:18] <rokoteko> Ok. who am I here to disagree.

[19:18] <rokoteko> Im just thanking you all for all the good work! :)

[19:18] <moritz_> there's a difference between "A doesn't exist" and "A isn't implemented in all details"

[19:19] <TimToady> it's not the disagreement that's disagreeable, but the all-or-nothing bits

[19:19] <moritz_> TimToady++

[19:19] <TimToady> we've been climbing the slippery slope for ten years now, so we're immune to half-empty/half-full arguments

[19:20] <rokoteko> This has just been a real mental puzzle for me. To keep on appreciating perl5 and its modernization, to wait for perl6 and it's greatness, or to just check if Haskell really would suit me the best.

[19:21] <TimToady> why do those have to be exclusive?!?!

[19:21] <moritz_> there's no need to wait, you can always speed up things yourself (hint, hint)

[19:21] <flussence_> that reminds me, I gotta go finish T-T-W today

[19:21] <TimToady> all your arguments seem to be of the either/or variety

[19:22] <TimToady> Perl has always been more about both/and.

[19:25] <dalek> roast: d38ece7 | moritz++ | fudge:

[19:25] <dalek> roast: [fudge] give a better error message for missing test files

[19:25] <dalek> roast: review: https://github.com/perl6/roast/commit/d38ece797d

[19:25] <diakopter> in my experience, deciding '[which language would] suit me the best' is often a euphemism for deciding 'which language would suit my employer's (and thus my) project the best, where I must take into account maintainability once I'm gone, and other concerns where multi-language knowledge/expertise *seem* to add costs'

[19:25] <takadonet> flussence_++

[19:26] <diakopter> (making it an either-or question)

[19:29] <diakopter> so the frank answer to a complaint such as "This has just been a real mental puzzle for me."  really ought to be "do *not* ever get your hopes up about Perl 6 unless you're willing to invest personally in it yourself, because there are precious few resources devoted/committed/invested in it (both historically and currently)."

[19:29] <sorear> rokoteko: worrying about "fast" is specifically my prerogative.  Rakudo can get away with being slow far more than "An implementation dedicated to exploring possibilities for efficient implementation"

[19:30] <sorear> diakopter: agree.

[19:30] <masak> diakopter: I told a person at $dayjob basically that AFK today.

[19:31] <masak> in some sense, you not only have to be an early adopter at this point; you have to be an early adopter with patience. :)

[19:32] <masak> (patience for frequent spec changes, for example. or for inventing your own short-term wheels.)

[19:32] <rokoteko> diakopter: were you referring to me by this 'which language would suit me the best' coment?

[19:32] *** impious joined
[19:32] <sorear> rakudo: my $x; $x++ until $x == 10000; say "alive"

[19:32] <p6eval> rakudo a38d45: OUTPUT«Use of uninitialized value in numeric context  in <anon> at line 22:/tmp/sM2E7pbIIm␤alive␤»

[19:32] <diakopter> not necessarily; I was referring to the many many other times I've heard/seen others make that query

[19:33] <sorear> rakudo: my $x = 0; $x++ until $x == 100000; say "alive"

[19:33] <p6eval> rakudo a38d45: OUTPUT«(timeout)»

[19:33] <sorear> rakudo: my $x = 0; $x++ until $x == 50000; say "alive"

[19:33] <p6eval> rakudo a38d45: OUTPUT«(timeout)»

[19:33] <sorear> rakudo: my $x = 0; $x++ until $x == 20000; say "alive"

[19:33] <p6eval> rakudo a38d45: OUTPUT«alive␤»

[19:33] <takadonet> the timeout is really short btw

[19:33] <jnthn> No, Rakudo is really slow :P

[19:34] <rokoteko> diakopter: Ok. :) If I dont find another language (besides perl5) that I love to program with I will probably stop programming and switch to some other IT related job. :)

[19:34] <takadonet> ssshh!

[19:34] <masak> takadonet: what jnthn said :)

[19:34] <sorear> niecza: my $x = 0; $x++ until $x == 1_000_000; say "alive"

[19:34] <p6eval> niecza v3-65-g55abf9d: OUTPUT«alive␤»

[19:34] <sorear> niecza: my $x = 0; $x++ until $x == 50_000_000; say "alive"

[19:34] <p6eval> niecza v3-65-g55abf9d: OUTPUT«(timeout)»

[19:34] <rokoteko> diakopter: actually my (current) *dream* is to have some kind of lobster farm! :)

[19:34] <flussence_> nice try :)

[19:34] <sorear> niecza: my $x = 0; $x++ until $x == 10_000_000; say "alive"

[19:34] *** amkrankr1leuen joined
[19:35] <p6eval> niecza v3-65-g55abf9d: OUTPUT«(timeout)»

[19:35] <sorear> niecza: my $x = 0; $x++ until $x == 5_000_000; say "alive"

[19:35] <rokoteko> diakopter: and there was even a dude suggesting me that I could get some EU financing by farming sturgeons.

[19:35] <p6eval> niecza v3-65-g55abf9d: OUTPUT«alive␤»

[19:36] <flussence_> it can't do infinite loops in 5 seconds, but it's getting there...

[19:36] <rokoteko> diakopter: but goddamn. sturgeons live like 100 years old, can weigh more than 2000 kilos, and can be taller than 5 meters. also they need a LARGE pool, atleast 30m deep.

[19:36] <masak> rokoteko: I love programming in Perl 6. but Perl 6 only exists in imperfect forms so far. many of us are willing to help to make it a reality. of course, not everyone has that time or interest... but be aware that any kind of assistance or encouragement is appreciated.

[19:36] <rokoteko> diakopter: so you kinda understand me if that sounds ridiculous. :)

[19:37] <rokoteko> masak: to be honest, Im so goddamn fucking tired after each day at work (maintaining a perl5 dinosaur) that I absolutely have no energy to help you with perl6 :(

[19:37] <rokoteko> Im desperately waiting for my next freedays which will last longer than 2 days (aka. a weekend).

[19:38] * diakopter hands out earplugs to the daintier of ears

[19:38] <masak> rokoteko: having recently gotten an 8-5 dayjob, I completely understand.

[19:38] <flussence_> hey, I'm doing perl6 to *forget* about my dayjob

[19:38] *** impious left
[19:39] <masak> I'm doing Perl 6 because I think it's the most exciting thing the programming community has to offer.

[19:39] <flussence_> I've been there years and only got to start writing tests this month :(

[19:39] <sorear> rokoteko: as you can see, niecza is currently 250 times faster than Rakudo, and I'd like it to stay that way

[19:39] <masak> sorear++

[19:39] <flussence_> (and I fixed like a dozen things as a result so far...)

[19:40] <rokoteko> sorear: niecza is the mono implementation of perl6?

[19:40] <rokoteko> (not that I really understand what mono is)

[19:40] <rokoteko> sorear: how much more features has it got implemented?

[19:41] <sorear> rokoteko: less, actually.

[19:41] <sorear> niecza: my $x = 0; $x++ until $x = 5_000_000_000_000; say "alive" # this never gets old.

[19:41] <rokoteko> sorear: but it looks like it could work very well? I was correct with the mono -thing?=

[19:41] <p6eval> niecza v3-65-g55abf9d: OUTPUT«alive␤»

[19:42] <sorear> rokoteko: yeah, mono.

[19:42] <sorear> rokoteko: it also works on .net

[19:42] <rokoteko> nods. at $work Ive been lately porting our product to work on Windows box also. :)

[19:42] <masak> sorear: 5... BILLION!?

[19:43] * masak eagerly awaits Yapsi-on-Niecza

[19:43] <TimToady> niecza: my $x = 0; $x++ until $x = 5_000_000_000_000; say "alive $x"; # even gets all the way there :)

[19:43] <jnthn> :)

[19:43] <flussence_> 5 BILLIARD‽ # does anyone even use long millions any more?

[19:43] <sorear> masak: don't use billions in international channels.  it means 10^9 in some countries and 10^12 in others. :(

[19:43] <p6eval> niecza v3-65-g55abf9d: OUTPUT«alive 5000000000000␤»

[19:43] * diakopter didn't know that

[19:44] <masak> flussence_: you mean "milliard"?

[19:44] <masak> sorear: er. I'm from a 10^12 country. I know that. :P

[19:44] <flussence_> I mean 5×10¹² :)

[19:44] <TimToady> I'm a USian; I believe in cultural imperialism, especially when I'm right.  :)

[19:44] <masak> sorear: I'm using it because it means 10^9 in English.

[19:45] <masak> sorear: and I don't much feel like saying "five thousand million" each time.

[19:46] <masak> or "five thousand thousand thousand".

[19:46] <flussence_> "5 with four lots of three Os after it"

[19:46] <masak> but I see I counted wrong. it's five TRILLION!?

[19:47] <flussence_> it's over nine thousand!

[19:47] <masak> o.O

[19:47] <flussence_> but yeah, an "infinite loop" is ^ 2**31, isn't it?

[19:48] <masak> niecza: say 2 ** 31

[19:48] <rokoteko> sorear: In our company we have a lot of people from other countries and continents. they are mainly using MS related technologies. I can only imagine their juices flowing after hearing about a Windows only implementation of perl that does all that perl6 does. :) Good luck with your work, you definitely got a market! :)

[19:48] <p6eval> niecza v3-65-g55abf9d: OUTPUT«2147483648␤»

[19:48] <flussence_> niecza: my $x = 0; $x++ until $x = 2**31; say "alive $x"; # 5 seconds?

[19:48] <p6eval> niecza v3-65-g55abf9d: OUTPUT«alive 2147483648␤»

[19:48] <flussence_> 4!

[19:49] *** synple left
[19:50] <masak> rakudo: say (2 ** 31).flip.comb(/..?.?/).reverse>>.flip.join("_")

[19:50] <p6eval> rakudo a38d45: OUTPUT«2_147_483_648␤»

[19:50] <masak> niecza: say (2 ** 31).flip.comb(/..?.?/).reverse>>.flip.join("_")

[19:50] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical &hyperunary in mainline␤␤Server stack trace: ␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ␤  at

[19:50] <p6eval> ..Niecza.CLRBackend.NamProcesso…

[19:50] <flussence_> no » yet

[19:50] <masak> aww :)

[19:51] <flussence_> niecza: say (2 ** 31).flip.comb(/..?.?/).reverse.map(*.flip).join("_")

[19:51] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: Unable to resolve method flip in class Num␤  at /tmp/zG_ZiSbjLd line 1 (MAIN mainline @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1261 (CORE C524_ANON @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1262 (CORE module-CORE @ 39)␤  at

[19:51] <p6eval> ../home/p6eval/nie…

[19:51] <flussence_> :(

[19:51] <masak> LHF?

[19:51] <flussence_> niecza: say (2 ** 31).flip.comb(/..?.?/).reverse.map(*.Str.flip).join("_")

[19:51] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: Unable to resolve method flip in class Num␤  at /tmp/2w5ptsYmHd line 1 (MAIN mainline @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1261 (CORE C524_ANON @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1262 (CORE module-CORE @ 39)␤  at

[19:51] <p6eval> ../home/p6eval/nie…

[19:51] <flussence_> huh

[19:51] <flussence_> oh.

[19:51] <masak> flussence_: read the error message.

[19:51] <masak> niecza: say (2 ** 31).comb.reverse.join.comb(/..?.?/).reverse>>.flip.join("_")

[19:51] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical &hyperunary in mainline␤␤Server stack trace: ␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ␤  at

[19:51] <p6eval> ..Niecza.CLRBackend.NamProcesso…

[19:52] <masak> er. :)

[19:52] <flussence_> I was looking at the second .flip

[19:52] <masak> niecza: say (2 ** 31).comb.reverse.join.comb(/..?.?/).reverse.map(*.flip).join("_")

[19:52] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: Unable to resolve method reverse in class Array␤  at /tmp/AX5WBHuCpr line 1 (MAIN mainline @ 3)␤  at /home/p6eval/niecza/lib/CORE.setting line 1261 (CORE C524_ANON @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1262 (CORE module-CORE @ 39)␤ 

[19:52] <p6eval> ..at /home/p6eva…

[19:52] <masak> oh :(

[19:52] <flussence_> oh well

[19:53] *** lichtkind left
[19:53] <rokoteko> so what is perl6's market? Unix -people, Windows -people, (I hope not the Mac -people), or all of them?

[19:53] <TimToady> either/or vs both/and

[19:54] <tadzik> erm, why not Mac-people?

[19:54] <tadzik> it's "all of them" currently

[19:54] *** starcoder joined
[19:54] <flussence_> tadzik: Mac's a Unix. Certified, in fact.

[19:54] <flussence_> Mac people as a separate thing would imply OS<=9 ...

[19:54] <TimToady> yeah, but Mac people aren't Unix people :)

[19:55] <tadzik> (:

[19:56] <rokoteko> there is this kthakore dude (I apologize if I forgot his exact nick) that helped me to package a Windows port (using perl) of this: http://processingjs.org/learning/topic/tree to perl5. Has anyone got any estimate when this could be actually possible in perl6?

[19:56] <sorear> masak: .flip is LHF to do KISSily

[19:57] <TimToady> Perl 6 is turing complete, so it's possible now.

[19:57] <sorear> masak: there's &reverse in the setting

[19:57] <masak> sorear: ah; only the sub form?

[19:57] <sorear> yeah

[19:57] <sorear> probably there will be a C# version of flip at some point

[19:57] <sorear> it's a simple enough operation

[19:58] <masak> niecza: say (reverse (2 ** 31).comb).join.comb(/..?.?/).reverse.map({(reverse .comb).join}).join("_")

[19:58] <p6eval> niecza v3-65-g55abf9d: OUTPUT«Unhandled exception: Unable to resolve method reverse in class Array␤  at /tmp/nSaF1UGF4z line 1 (MAIN mainline @ 6)␤  at /home/p6eval/niecza/lib/CORE.setting line 1261 (CORE C524_ANON @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1262 (CORE module-CORE @ 39)␤ 

[19:58] <p6eval> ..at /home/p6eva…

[19:58] <masak> ah. missed one.

[19:58] <rokoteko> (the source, and windows executables, are available at http://rehn.fi/tree.zip  # if you want to take a look. sorry about all these silly questions, but Im just trying to map where I should be heading at.)

[19:58] <masak> niecza: say (reverse (reverse (2 ** 31).comb).join.comb(/..?.?/)).map({(reverse .comb).join}).join("_")

[19:58] <p6eval> niecza v3-65-g55abf9d: OUTPUT«2_147_483_648␤»

[19:58] <masak> \o/

[19:59] <masak> see, children? in the end, workarounds always work.

[19:59] <sorear> masak: have you figured out the infinite loop in 5 seconds trick yet?

[19:59] <masak> sorear: I suppose it's a special optimization...

[20:00] <TimToady> ...but some are more equal than others...

[20:00] <sorear> actually it's an optical illusion

[20:00] <sorear> rakudo: my $i = 0; $i++ until $i = 1_000_000_000_000; say "alive $i"

[20:00] <p6eval> rakudo a38d45: OUTPUT«alive 1000000000000␤»

[20:00] <sorear> you want to see a counting loop, but there isn't really one

[20:00] <colomon> $x =  instead of $x ==

[20:00] <masak> oh!

[20:01] <masak> dang, I totally fell for it.

[20:01] <flussence_> that's a dirty trick :)

[20:01] <colomon> sorear++

[20:01] <TimToady> we should be able to make rocket launches easier with that

[20:01] <TimToady> you won't have to track the rocket after the first few seconds...

[20:02] <flussence_> it'd go into an infinite loop in 5 seconds

[20:02] <flussence_> well, more like a finite loop...

[20:03] <masak> rakudo: my $i = 0; $++ until $i = Inf; say $i

[20:03] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "$++ until "␤»

[20:03] <masak> rakudo: my $i = 0; $i++ until $i = Inf; say $i

[20:03] <p6eval> rakudo a38d45: OUTPUT«Inf␤»

[20:03] <TimToady> it'll end up in the finite pool

[20:03] <masak> there's your infinite loop.

[20:04] *** Tedd1^ joined
[20:05] *** plobsing joined
[20:05] <diakopter> well, it was what TimToady did with niecza above

[20:05] *** Tedd1 left
[20:05] <masak> oh. :/

[20:05] <masak> I'm out of practice reading IRC.

[20:06] <TimToady> no, I last did that with Inf a month or two ago

[20:06] <masak> two months ago is "above" :P

[20:07] <diakopter> yeah but I meant the 5e12

[20:07] <TimToady> which is not Inf in niecza

[20:07] <masak> diakopter: oh, I saw that one.

[20:07] <masak> that one's still finite, so it's not as impressive :P

[20:07] <TimToady> niecza is still cheating with floaters, last I knew

[20:07] *** cjk101010 left
[20:08] <TimToady> not that Ints are supposed to top out either...

[20:08] <diakopter> perlesque: my $x = 2_000_000_000; my $t=Diagnostics::StopWatch.StartNew();1 while --$x; say "alive "~$x; say $t.Elapsed; say $x.GetType()

[20:09] <p6eval> perlesque: OUTPUT«alive 0␤00:00:07.1678034␤System.Int32␤»

[20:09] <TimToady> niecza: say 100000000000000000000000000042

[20:09] <p6eval> niecza v3-65-g55abf9d: OUTPUT«1E+29␤»

[20:09] <diakopter> perlesque: say 100000000000000000000000000042

[20:09] <p6eval> perlesque: OUTPUT«100000000000000000000000000042␤»

[20:09] <diakopter> perlesque: say 100000000000000000000000000042 / 100000000000000000000000000041

[20:09] <p6eval> perlesque: OUTPUT«1␤»

[20:10] <diakopter> ha

[20:10] <diakopter> perlesque: say (100000000000000000000000000041).GetType()

[20:10] <p6eval> perlesque: OUTPUT«Could not resolve routine name and signature.␤»

[20:10] <diakopter> hrm

[20:11] <flussence_> that's a weird thing to say on stdout

[20:11] <diakopter> perlesque: my $a = 100000000000000000000000000042; say $a.GetType

[20:11] <p6eval> perlesque: OUTPUT«System.Numerics.BigInteger␤»

[20:11] <TimToady> maybe perlesque has been infected by Stuxnet

[20:11] <diakopter> at least ;)

[20:13] <TimToady> perlesque: my $a = 1000000000000000000000.01; say $a.GetType

[20:13] <p6eval> perlesque: OUTPUT«System.Double␤»

[20:13] <TimToady> ooh, cheaters all over the place

[20:13] <diakopter> what should that be

[20:13] <TimToady> you should smell a Rat

[20:14] <diakopter> heh

[20:14] <TimToady> rakudo: say 1000.01.WHAT

[20:14] <p6eval> rakudo a38d45: OUTPUT«Rat()␤»

[20:14] <masak> today I learned that in Common Lisp, the command for printing a newline is called (terpri) -- that looks like a name a sadistic Lojbanist might have come up with. Scheme calls the same function (newline).

[20:14] <diakopter> perlesque doesn't know about Rats, just CLR builtins that mostly overlap with p6 lowest-levels

[20:15] <diakopter> "sadistic Lojbanist"

[20:16] <sorear> TimToady: if -p is passed, what should be used instead of CORE.setting?

[20:17] <colomon> masak: classic lisp has some "wonderful" names. 

[20:17] <sorear> LAMBDA

[20:17] <rokoteko> that raises a question. are rats more advanced than squirrels or the other way around? :)

[20:17] <sorear> CDR

[20:17] <rokoteko> anyhow Im going to visit a friend soon. and therefore Ill be thanking you all for the good chat :)

[20:18] <colomon> CADR

[20:18] <rokoteko> See you next time when I feel curious about perl6! :)

[20:18] <masak> rokoteko: \o

[20:18] <sorear> I think it's funny how lispies have latched on to lambda and car despite being approximately the worst names imaginable

[20:19] <plobsing> sorear: what do you mean? cdaddaadr makes complete and total sense!

[20:19] <flussence_> lambda I'm sort of familiar with. "car"... no idea

[20:19] <masak> Arc ditches 'lambda' for 'fun', but keeps 'car' et al for hystericacl raisins.

[20:19] <masak> hysterical*

[20:19] <colomon> yeah, I'm okay with lambda, which at least has mathematical meaning.

[20:19] *** aindilis joined
[20:19] <masak> (and with the rationale that it's hard to do 'caddr' et al with any other naming scheme)

[20:19] <sorear> plobsing: once you know car and cdr, cdaddaadr is at least regular

[20:20] * diakopter preferred to read that as 'hysteric access-control-lists raisins'

[20:20] <masak> sorear: though probably not the best of ideas in any event.

[20:20] <masak> diakopter: *lol*

[20:20] <colomon> If I'm understanding the wikipedia page correctly, cdaddaadr isn't actually supported (usually)

[20:20] <masak> five levels of nested lists ought to be enough for anybody.

[20:21] <sorear> Classical LISP has one of the most insane variable models every invented

[20:21] <plobsing> colomon: I don't expect it to be. it was an extrapolation of a common pattern.

[20:21] <colomon> ooo, wait, maybe it is.  "Common Lisp and Scheme both provide forms with up to four repetitions of the a and d." might mean four each, I suppose.

[20:21] <masak> ok, I've now updated http://strangelyconsistent.org/blog/p5-find-the-longest-common-substring with small notices about colomon++ having the latest and best news on p5.

[20:22] <masak> colomon: it doesn't, IIRC.

[20:23] <plobsing> bringing the car/cdr discussion back on topic, would it be possible to augment the Perl 6 grammar to take any c[ad]+r function and autogenerate the appropriate accessor?

[20:23] <masak> ...yes. :)

[20:23] *** icwiener joined
[20:24] *** thr0w left
[20:24] <masak> plobsing: though my guess is that the autogeneration bit wouldn't end up in the grammar.

[20:24] <masak> maybe in the actions, or maybe even later on.

[20:24] <jnthn> Probably actions.

[20:25] <colomon> masak: ah, good, you're planning on saying more on it.  I think it's interesting (and nice) that the best algorithm depends on the sort of string you expect to be dealing with.

[20:25] <jdhore> Does Perl (either P5 or P6) have something like radix tries?

[20:26] <shortcircuit> I don't know what radix trees are, but suddenly I want them on Rosetta Code. >.>

[20:26] <jdhore> http://en.wikipedia.org/wiki/Radix_trie

[20:27] <plobsing> I've seen a Trie module on CPAN before

[20:27] <masak> colomon: from what I see from your new stats, fox and moritz_ are both better off than I thought, but your algorithm beats them when strings get long.

[20:27] <jdhore> I tend to call it a patricia trie, but radix trie is more accepted :(

[20:27] <masak> jdhore: I haven't seen a radix trie implementation, no.

[20:27] <masak> does STD contain anything like that? and is that part in Perl 6?

[20:29] *** KyleHa left
[20:35] <sorear> radix trees and patricia trees are not quite the same

[20:36] <sorear> masak: std used to use radix trees, but does no longer

[20:36] <masak> oh!

[20:40] <colomon> masak: that would be my summary as well.  :)

[20:40] <masak> I just like to have that summary spring out of data coming out of my runs :P no offense.

[20:41] <masak> in retrospect, I made two mistakes with collecting statistics:

[20:41] <masak> * data was a bit too one-sided, and favored certain solutions, skewing the results.

[20:42] <masak> * the timings for each solution were all collected during one single program run. should have re-started the program each time.

[20:42] <sorear> colomon: augment slang MAIN { token prefix:sym<cxxxr> { c <[ad]>+ r <O(|%named_unary)> } } should work

[20:43] <sorear> TimToady: when augmenting slangs, how do semantics get attached?  Embedded blocks with &make?

[20:43] <colomon> sorear++

[20:45] <sorear> TimToady: what should I call the file that contains the -p setting?

[20:46] * sorear is mostly trying to get multis working, today.

[20:46] <jnthn> Also, what does the MAIN refer to in augment slang MAIN?

[20:47] <sorear> jnthn: the main Perl 6 language, c.f. STD.pm6:1100

[20:47] <sorear> %*LANG hash key

[20:47] <jnthn> ah, ok

[20:48] <jnthn> Is a slang meaningful in a non-augmentation sense?

[20:49] <sorear> You could define an entirely new one

[20:50] <sorear> I'm not really happy with "slang" as a type_declarator

[20:50] <sorear> it feels more like a scope to me

[20:51] <sorear> augment slang \approx BEGIN { %*LANG<MAIN> but= role { ... } }

[20:51] <sorear> my slang \approx BEGIN { %*LANG<MAIN> = grammar { ... } }

[20:52] <sorear> supercede and my would be the same thing... I don't think any other scope makes sense

[20:58] <sorear> rakudo: my proto token bit {*}; my token bit:alpha { <.alpha>+ }; my token bit:num { \d+ }; say "abc123def456".comb(/<&bit>/).perl

[20:58] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Quantifier quantifies nothing at line 22, near "}; my toke"␤»

[20:59] <sorear> rakudo: my proto token bit {...}; my token bit:alpha { <.alpha>+ }; my token bit:num { \d+ }; say "abc123def456".comb(/<&bit>/).perl

[20:59] <p6eval> rakudo a38d45: OUTPUT«Could not find sub &bit␤  in <anon> at line 22:/tmp/UJoEHd0Z4M␤  in 'Cool::match' at line 2659:CORE.setting␤  in <anon> at line 2317:CORE.setting␤  in 'Any::join' at line 1␤  in 'List::perl' at line 2843:CORE.setting␤  in main program body at line 22:/tmp/UJoEHd0Z4M␤»

[20:59] <sorear> rakudo: my proto token bit { <...> }; my token bit:alpha { <.alpha>+ }; my token bit:num { \d+ }; say "abc123def456".comb(/<&bit>/).perl

[20:59] <p6eval> rakudo a38d45: OUTPUT«Could not find sub &bit␤  in <anon> at line 22:/tmp/lUP93KkOeD␤  in 'Cool::match' at line 2659:CORE.setting␤  in <anon> at line 2317:CORE.setting␤  in 'Any::join' at line 1␤  in 'List::perl' at line 2843:CORE.setting␤  in main program body at line 22:/tmp/lUP93KkOeD␤»

[20:59] <sorear> What does Rakudo want in proto tokens?

[21:02] *** plainhao left
[21:08] <jnthn> That looks fine

[21:08] <jnthn> I can only guess it's some oddity about it not being in a grammar.

[21:11] *** Rotwang joined
[21:25] <sorear> jnthn: oh, does rakudo not support proto regex outside grammars?

[21:25] <jnthn> sorear: Looking at the error and knowing how its prefix stashing works, I fear not.

[21:26] <jnthn> I do know it'd complain if you put the wrong thing in a proto token.

[21:26] <sorear> Is there going to be any specifically Perl 6 GSoC stuff this year?

[21:26] <jnthn> I wrote up one suggestion earlier today

[21:26] *** Vlavv joined
[21:26] <jnthn> I hope there'll be more.

[21:30] *** dorlamm joined
[21:31] *** y3llow joined
[21:31] <masak> what's the deadline?

[21:31] *** pothos joined
[21:31] <moritz_> afaict there's no real deadline for ideas

[21:32] <moritz_> it's just that more students will look at the proposal if it's there earlier

[21:32] <masak> ah, ok.

[21:43] <sorear> someone on parrot-dev said that Google is going to look at idea pages over the weekend and use that to decide which orgs get funding

[21:46] <masak> I think that was dukeleto

[21:47] <dalek> nqp/ctmo: 32f2a59 | jonathan++ | src/ops/nqp.ops:

[21:47] <dalek> nqp/ctmo: Fix error message typo.

[21:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/32f2a59fe6

[21:47] <dalek> nqp/ctmo: 13b2478 | jonathan++ | src/pmc/serializationcontext.pmc:

[21:47] <dalek> nqp/ctmo: Add quick and dirty method for getting the index of an object in an SC.

[21:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/13b2478588

[21:47] <dalek> nqp/ctmo: 929093e | jonathan++ | src/ops/nqp.ops:

[21:47] <dalek> nqp/ctmo: D'oh, another typo.

[21:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/929093e14f

[21:47] <dalek> nqp/ctmo: d17eb00 | jonathan++ | src/metamodel/ (3 files):

[21:47] <dalek> nqp/ctmo: KnowHOW and it's HOW need to live in a serialization context, so we make a core one.

[21:47] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/d17eb0041e

[21:47] <sorear> masak: I looked over yapsi from the niecza-compatibility POV yesterday

[21:48] <masak> sorear: yes?

[21:48] <sorear> masak: at_pos has to go.

[21:48] *** GinoMan left
[21:48] <sorear> so... I'm likely going to be working on a branch

[21:48] <masak> sorear: that one's a workaround for a Rakudo thing.

[21:48] <masak> sorear: would you be willing to work on a branch in the Yapsi repo?

[21:48] <prammer> Would I be doomed to failure if I tried to implement some of the p6 builtin classes/roles in p5/Moose?

[21:49] <dukeleto> sorear: yes, that was me

[21:49] <moritz_> prammer: depends on what you try

[21:49] <prammer> Something like $hash->pairs->map( sub { ... } ); seems kinda nice

[21:49] <sorear> masak: yes

[21:49] <masak> sorear: excellent. you now have commit access.

[21:49] <dukeleto> sorear: i think Perl 6 will be part of The Perl Foundation GSoC org this year

[21:50] <jnthn> sorear: at_pos has to go?

[21:50] <prammer> It seems like Parcel would be hard

[21:50] <dukeleto> sorear: as well as Rakudo. But Rakudo-folk are free to be part of TPF or Parrot, as they see fit

[21:50] <masak> sorear: my immediate plans include fixing the bug you pointed out (shouldn't be difficult), and then fixing the backtracking problems in the grammar.

[21:50] <sorear> masak: how does "has FUTURE::Node @.children is rw" work?  I thought Rakudo couldn't do typed arrays

[21:50] <masak> prammer: what is your aim?

[21:50] <masak> sorear: it parses them and then does nothing.

[21:51] <masak> sorear: consider it a piece of documentation :)

[21:51] *** hercynium left
[21:51] <moritz_> prammer: Parcel is very specific Perl 6 thing; I don't see how a Perl 5 program would benefit from it

[21:51] <sorear> jnthn: masak's code uses at_pos, which is not standard Perl 6. 

[21:51] <sorear> masak: ok.  that I can do :)

[21:51] <prammer> I think one of my aims it to figure out how all the p6 classes/roles fit together

[21:52] <masak> prammer: if you find out, let us know :P

[21:52] <sorear> masak: where does yapsi fail on rakudo, without at_pos?

[21:52] <prammer> right.  Well it could be a testing ground to see what works

[21:52] <sorear> masak: have you ever thought about integrating yapsi with gge? :D

[21:52] <jnthn> sorear: Oh, I thought it was spec.

[21:52] <moritz_> jnthn: pmichaud_ planned to spec it

[21:52] <jnthn> Ah, OK

[21:52] <moritz_> but never got around to it

[21:53] <jnthn> *nod*

[21:53] <masak> sorear: yes, that was the plan when I had only GGE and hadn't started with Yapsi.

[21:53] <moritz_> there's some sense in it

[21:53] <masak> sorear: oh, seems I'm mixing up at_pos with something else.

[21:53] <prammer> I think I'd leave out Parcel, but I was hoping I could figure out Iterator but I'm having trouble

[21:53] <moritz_> postcircumfix:<[ ]> handles things like slices and WhateverCode closures etc.

[21:53] <masak> sorear: anyway, I'd very much like to see an implementation-independent version of at_pos.

[21:53] <moritz_> and then calls at_pos for each index

[21:54] <moritz_> so if you want to provide your own array-ish type, you only have to provide the actual storage calls

[21:54] <masak> pmichaud_ seems quite proud over at_pos.

[21:54] <moritz_> for individual indexes

[21:54] * moritz_ likes it

[21:54] <moritz_> same with at_key for hashes

[21:54] <jnthn> Yeah, I like it too.

[21:54] <jnthn> It made things a bunch simpler.

[21:55] <moritz_> sorear: are you OK with speccing at_pos?

[21:56] <sorear> moritz_: possibly.

[21:56] <sorear> niecza's at_pos differs in some small details from what you just described

[21:57] <moritz_> sorear: care to elaborate?

[21:57] <sorear> prammer: Iterator is in a state of flux atm.  No major implementation follows the spec.

[21:57] <sorear> prammer: (the spec is lagging)

[21:58] <sorear> moritz_: my at_pos methods are responsible for handling WhateverCode and slices themselves

[21:59] <moritz_> sorear: so what's its advantage over postcircumfix:<[ ]> ?

[22:00] <sorear> at_pos methods don't have to handle adverbs

[22:00] <prammer> sorear: ah.  good to know.  I read some stuff about .reify but it still wasn't clear to me what the api is supposed to look like

[22:00] <sorear> also, they're methods - postcircumfix:<[ ]> is a sub

[22:00] <moritz_> not at all

[22:02] <moritz_> sorear: take a look at S13

[22:03] <prammer> is there a good place to look to figure out the direction Iterable/Iterator are going?  I guess I can look at how rakudo does it

[22:04] <sorear> niecza chooses to follow S12:416 instead.

[22:08] <moritz_> sorear: S12:416 looks to me like an example of &foo(bar) and bar.&foo being the same. I don't see how that implies that postcircumfix:<[ ]> is a sub

[22:17] *** dju joined
[22:19] *** dju left
[22:20] *** dju joined
[22:22] *** dorlamm left
[22:24] *** cosimo joined
[22:31] <donri> is foo.&bar syntax or does that work with any block-like

[22:32] <donri> rakudo: "foo".{ say $^a }

[22:32] <p6eval> rakudo a38d45: OUTPUT«Null PMC access in type()␤  in main program body at line 22:/tmp/LXgE0z0hCU␤»

[22:32] * masak submits rakudobug

[22:32] <donri> rakudo: "foo".(*.say)

[22:32] <donri> :$

[22:32] <p6eval> rakudo a38d45: OUTPUT«invoke() not implemented in class 'Perl6Str'␤  in main program body at line 22:/tmp/TyPrYjOEi7␤»

[22:33] <masak> donri: that last one is trying to invoke "foo".

[22:33] <masak> donri: I guess what you're after is "foo"."$method"()

[22:34] <donri> masak: nah, arbitrary invokable objects

[22:34] <sorear> niecza: "foo".$({ say $^a })

[22:34] <p6eval> niecza v3-65-g55abf9d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Contextualizer variables NYI at /tmp/sbNnLGTCoa line 1 (EOF):␤------> [32m"foo".$({ say $^a })[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 387 (CORE die @ 2)␤  at

[22:34] <p6eval> ../home/p6eval/niecza/sr…

[22:34] <sorear> donri: it has to be a syntactic variable.

[22:34] <donri> rakudo: *.say "foo"

[22:34] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Confused at line 22, near "*.say \"foo"␤»

[22:35] <donri> rakudo: (*.say) "foo"

[22:35] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Confused at line 22, near "(*.say) \"f"␤»

[22:35] <sorear> also, that's fixable now...

[22:35] <donri> wait what am i doing

[22:35] <masak> donri: that's two terms in a row :/

[22:35] <donri> ;)

[22:35] <donri> rakudo: (*.say)("foo")

[22:35] <p6eval> rakudo a38d45: OUTPUT«foo␤»

[22:35] <masak> \o/

[22:35] <donri> i dub it the boobie style

[22:35] <donri> rakudo: *.say("foo")

[22:35] <p6eval> rakudo a38d45:  ( no output )

[22:36] <masak> rakudo: say("foo")

[22:36] <p6eval> rakudo a38d45: OUTPUT«foo␤»

[22:36] <jnthn> rakudo: "foo".$({ say $^a })

[22:36] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "$({ say $^"␤»

[22:36] <jnthn> Aw.

[22:36] <donri> rakudo: "foo".&({say $^a })

[22:36] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "&({say $^a"␤»

[22:36] <donri> rakudo: "foo"."{say $^a }"

[22:36] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Quoted method name requires parenthesized arguments at line 22, near ""␤»

[22:38] <masak> good night, #perl6.

[22:39] *** masak left
[22:39] <jnthn> rakudo: "foo".&({say $^a })()

[22:39] <p6eval> rakudo a38d45: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 22, near "&({say $^a"␤»

[22:40] <jnthn> Nah, don't think that's gonna work. :(

[22:40] <jnthn> Not yet.

[22:41] <donri> std: "foo".&({say $^a })

[22:41] <p6eval> std 4608239: OUTPUT«ok 00:01 123m␤»

[22:42] *** coldhead joined
[22:43] *** gdey- left
[22:45] *** gdey_ joined
[22:47] *** dorlamm joined
[22:49] *** alester left
[22:51] <dalek> niecza: 129d407 | sorear++ | TODO:

[22:51] <dalek> niecza: A few TODO additions

[22:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/129d40719a

[22:51] <dalek> niecza: eec33bf | sorear++ | / (2 files):

[22:51] <dalek> niecza: $foo.&() syntax

[22:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/eec33bf7b2

[22:51] <sorear> stefan@stefans:~/rel/niecza$ mono run/Niecza.exe -e '"foo".&({say $^a })'

[22:51] <sorear> foo

[22:52] * sorear pokes donri

[22:52] <donri> sorear: and it's supposed to work? i was only making that up as i went

[22:52] <sorear> donri: yes

[22:53] <donri> cool

[22:57] *** gdey_ left
[23:00] *** franek joined
[23:06] *** nymacro joined
[23:08] *** Mowah left
[23:09] *** xabbu42 joined
[23:10] <dalek> nqp/ctmo: c8c7a6f | jonathan++ | build/Makefile.in:

[23:10] <dalek> nqp/ctmo: Seems that we have got the meta-objects and setting reified into the wrong levels of the bootstrap. :/ As a first step, this fixes up the Makefile dependencies, but it's probably not enough.

[23:10] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/c8c7a6f54a

[23:10] <dalek> nqp/ctmo: 80b8275 | jonathan++ | src/HLL/SerializationContextBuilder.pm:

[23:10] <dalek> nqp/ctmo: First bits towards SC cross-referencing. Not able to use it just yet, due to issues with bootstrap layer reificationa and separate compilation. :/

[23:10] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/80b8275f8e

[23:10] <dalek> nqp/ctmo: 765695a | jonathan++ | src/HLL/SerializationContextBuilder.pm:

[23:10] <dalek> nqp/ctmo: Little more sketching out in the SC builder.

[23:10] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/765695a82e

[23:10] <dalek> nqp/ctmo: 3100f3d | jonathan++ | src/NQP/Actions.pm:

[23:10] <dalek> nqp/ctmo: Resolve lexically installed items (e.g. don't assume they're all package scoped).

[23:10] <dalek> nqp/ctmo: review: https://github.com/perl6/nqp/commit/3100f3d83d

[23:16] *** cosimo left
[23:20] *** whiteknight joined
[23:21] *** dorlamm left
[23:34] *** gdey_ joined
[23:39] *** xabbu42 left
[23:43] *** MayDaniel left
[23:45] *** fisted joined
[23:46] *** Rotwang left
[23:47] <jnthn> More tomorrow :)

[23:47] <jnthn> phenny: tell Tene got distracted hacking on other bits, but will write the REPR for you tomorrow 

[23:47] <phenny> jnthn: I'll pass that on when Tene is around.

[23:47] <jnthn> sleep &

[23:50] *** franek left
[23:56] *** fisted_ joined
[23:58] *** fisted left
