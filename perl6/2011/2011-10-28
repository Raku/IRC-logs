[00:10] *** supernovus left
[00:10] *** MayDaniel left
[00:14] *** replore_ joined
[00:25] *** tokuhiro_ joined
[00:45] *** daniel-s joined
[00:47] *** kid51 joined
[00:51] *** benabik joined
[01:01] <awwaiid> I've noticed more perl6 code snippets using dash-separated-naming. Is that becoming a norm? One step closer to LISP?

[01:03] *** tokuhir__ joined
[01:03] *** tokuhiro_ left
[01:11] *** tokuhir__ left
[01:15] <flussence> maybe; I just see it as one less shift key to press :)

[01:32] *** natureboy joined
[01:34] *** y3llow left
[01:34] *** pothos left
[01:34] *** y3llow_ joined
[01:34] *** pothos_ joined
[01:34] *** pothos_ is now known as pothos

[01:35] *** y3llow_ is now known as y3llow

[01:44] *** whiteknight left
[01:53] *** Trashlord left
[01:54] *** arx left
[02:23] *** wolfman2000 joined
[02:29] *** soh_cah_toa left
[02:40] *** daniel_ joined
[02:54] *** mkramer joined
[03:00] *** provoc joined
[03:02] *** mkramer left
[03:24] *** am0c joined
[03:25] *** abercrombie left
[03:33] *** natureboy left
[03:35] <sorear> good * #perl6

[03:36] <shachaf> sorear: Good $TIME

[03:37] <japhb> o/

[03:37] *** daniel_ left
[03:38] <sorear> o/ shachaf

[04:03] *** wolfman2000 left
[04:05] *** envi_ joined
[04:07] *** envi_ left
[04:10] *** envi_ joined
[04:28] *** thou left
[04:35] <dalek> rakudo/nom: d264275 | (Geoffrey Broadwell)++ | src/core/Main.pm:

[04:35] <dalek> rakudo/nom: Don't treat an option prefix followed immediately by a digit or period as an option (it's probably a negative or radix-notation number)

[04:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d26427560f

[04:43] <dalek> Heuristic branch merge: pushed 16 commits to niecza by sorear

[04:44] <sorear> evalbot rebuild niecza

[04:44] <p6eval> OK (started asynchronously)

[04:56] <japhb> In https://github.com/rakudo/rakudo/blob/nom/src/core/Numeric.pm , why are some subs defined with all args backslashed (e.g. sin, cos, etc.) while others don't have backslashes (e.g. log, log10, exp)?

[04:57] <sorear> blegh.  niecza rebuild failed on host04

[04:57] <sorear> japhb: little reason not to backslash all of them imo

[04:58] <japhb> What advantage does it give in this situation?

[04:59] <japhb> sorear: ^^

[04:59] <sorear> japhb: improves inlinability

[05:00] <sorear> ... yuck

[05:00] <sorear> rerunning the build with debug flags and it SUCCEEDED

[05:00] <moritz> it's supposed to be a bit faster

[05:00] <sorear> now I can't debug it! :(

[05:00] <sorear> niecza: say "Hello from serialize"

[05:00] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´Hello from serialize‚ê§¬ª

[05:00] *** pmichaud joined
[05:00] <japhb> sorear, ah, that was my first guess.  But the question is *why* it improves the inlineability?

[05:01] <sorear> japhb: because \$x is the simplest case of a parameter, and jnthn is Lazy

[05:01] <japhb> *chuckle*

[05:02] *** SHODAN joined
[05:02] <sorear> o/ pmichaud

[05:03] <moritz> it was probably me who forgot the backslashes on some of the subs

[05:03] <sorear> masak: colomon: I've merged serialize

[05:03] <japhb> sorear++

[05:03] <sorear> phenny: tell mberends /serialize is merged

[05:03] <phenny> sorear: I'll pass that on when mberends is around.

[05:04] <sorear> japhb: note that a '$x' parameter in general requires marking $x as readonly somehow

[05:05] <japhb> sorear, explain, please ...

[05:05] <moritz> perl6: sub f($x) { $x = 3 }; f my $y

[05:05] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´Potential difficulties:‚ê§  $y is declared but not used at /tmp/zElwk09XA6 line 1:‚ê§------> [32msub f($x) { $x = 3 }; f my [33m‚èè[31m$y[0m‚ê§‚ê§‚ê§Unhandled Exception: assigning to readonly value‚ê§  at /tmp/zElwk09XA6 line 0 (f @ 0) ‚ê§  at /tmp/zElwk09XA6 line 1 ‚Ä¶

[05:05] <p6eval> ..pugs b927740: OUTPUT¬´*** Can't modify constant item: VRef <Scalar:0x7fe2ec3e8ce9>‚ê§    at /tmp/J7rgkyf_mt line 1, column 13-20‚ê§¬ª

[05:05] <p6eval> ..rakudo d26427: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in sub f at /tmp/Zs5rS8Tzjv:1‚ê§  in block <anon> at /tmp/Zs5rS8Tzjv:1‚ê§  in <anon> at /tmp/Zs5rS8Tzjv:1‚ê§¬ª

[05:06] <moritz> japhb: in order to make that an error, $x needs to be told that it's ro

[05:06] <japhb> moritz, yes, got that.  I meant I was wondering why sorear brought that up.  But I'm realizing that he may be meaning '"\$x' doesn't need that readonly marking"

[05:07] <japhb> s/'"/"'/

[05:07] <moritz> that's true too

[05:09] <japhb> You know, it occurs to me that my understanding of \$x may be close to, but not precisely, the real Perl 6 meaning.  So what is the intended exact meaning of that construction?

[05:09] <sorear> \$x is very raw

[05:10] <sorear> it binds '$x' to mean the argument, with no changes of any kind

[05:10] <sorear> in particular

[05:10] <moritz> "bind what the caller gave us, and don't do anything else to it"

[05:10] <sorear> niecza: my @foo = 1,2, 3; sub bar(\$x) { say [$x].elems }; bar @foo

[05:10] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´3‚ê§¬ª

[05:10] <sorear> you might expect [$x].elems to always be 1; with \$x you don't always have that

[05:11] <sorear> a $x parameter is never assignable, a $x is rw parameter always is - a \$x parameter might or might not be

[05:12] *** cotto left
[05:12] <moritz> niecza: sub f($y is rw) { }; f 3

[05:12] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´Potential difficulties:‚ê§  $y is declared but not used at /tmp/24Y5jedGDK line 1:‚ê§------> [32msub f([33m‚èè[31m$y is rw) { }; f 3[0m‚ê§‚ê§‚ê§Unhandled Exception: Binding $y is rw in f, cannot bind read-only value to is rw parameter‚ê§  at /tmp/24Y5jedGDK line 0 ‚Ä¶

[05:12] *** cotto joined
[05:12] <moritz> cool

[05:12] *** orafu left
[05:12] <moritz> rakudo: sub f($y is rw) { }; f 3

[05:12] <p6eval> rakudo d26427:  ( no output )

[05:12] *** orafu joined
[05:13] <moritz> rakudo current aliases  'is rw' and \ it seems

[05:13] <japhb> It turns out my ghetto thinking was effectively "close enough" to reality to match the above cases, but not technically correct.

[05:13] <moritz> *ly

[05:17] *** TiMBuS left
[05:28] <japhb> Does '$x--' in sink context get optimized to '--$x' in Rakudo yet?

[05:29] <japhb> And if so, where does this occur?

[05:29] *** envi_ left
[05:34] *** provoc left
[05:35] <moritz> no, we don't recognize sink context yet

[05:49] <japhb> In RANGEPOS() in src/core/Str.pm (starts here: https://github.com/rakudo/rakudo/blob/nom/src/core/Str.pm#L59 ), why is unboxing done repeatedly, instead of using native typed variables and unboxing just once at the top of the routine?  Is unboxing an insanely cheap op?

[05:52] <moritz> japhb: it was simply written before rakudo supported natively typed lexicals

[05:53] <moritz> japhb: want to change that, or should I?

[05:53] <japhb> Ah, so the native str on line 63 was a late change, not there from the beginning.  That's what led me to wonder

[05:53] <japhb> s/$/./

[05:53] <moritz> correct

[05:54] <moritz> also $pos can be typed int

[05:54] <japhb> moritz, hmmm, lemme work up a patch for practice.

[05:55] <japhb> While I'm there, is there any reason not to change the postdecrements to predecrements?

[05:55] <moritz> japhb: they need to become $i = $i - 1 anyway if you use native int

[05:55] *** TiMBuS joined
[05:55] <moritz> because we don't have 'is rw' for natively typed params yet

[05:57] <japhb> Ah.  So is 'my Int $pos = 2; $pos--;' or 'my int $pos = 2; $pos = $pos - 1;' faster?

[05:57] <moritz> probably the latter

[05:58] <moritz> because it never boxes, and the chances that it inlines the operator are higher too

[05:58] <japhb> OK, worth a try then.

[05:59] <dalek> rakudo/nom: 642e789 | (Geoffrey Broadwell)++ | src/core/Str.pm:

[05:59] <dalek> rakudo/nom: Delete trailing whitespace

[05:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/642e789833

[06:00] <japhb> BTW, for commits like the above, is there a convention to be used to mark them as non-functional changes, like '[CAGE]' or somesuch?

[06:01] <moritz> not really

[06:01] <sorear> japhb: I am curious about your usage of "ghetto thinking"

[06:01] <moritz> japhb: I soemtimes add "no functional changes", but that's obvious when you're only deleting trailing ws :-)

[06:01] <japhb> sorear, in what sense?

[06:03] <sorear> 22:13 < japhb> It turns out my ghetto thinking was effectively "close enough" 

[06:03] <sorear> I have not heard this construction before

[06:04] <japhb> Ah.  I'm not sure where I heard that.  Basically means building a mental model in a broken way roughly equivalent to cargo cult coding.

[06:04] * moritz has passing TODOs when niecza runs t/spec/S03-operators/subscript-adverbs.t

[06:05] <japhb> I was saying that while I had built a mental model purely from looking at usage and results, rather than understanding the core, it happened that my mental model was fairly effective at predicting effects.

[06:07] <japhb> Stylistic question: How do you prefer to name a variable that is purely caching an unboxed copy of another variable, say $foo ?

[06:07] <japhb> I was thinking perhaps $_foo

[06:07] <japhb> $foo_ub seemed to heavy weight, and $f too terse

[06:07] <moritz> I don't think it's worth caching it

[06:07] <moritz> what's your application?

[06:08] <japhb> ... the repeated unboxes in RANGEPOS, of course.  ;-)

[06:08] <moritz> sorry, I read 'boxed', not 'unboxed'

[06:08] <japhb> ah

[06:08] <moritz> japhb: just keep only the native one around

[06:08] <moritz> japhb: declare $str as str in the signature

[06:09] <japhb> Oh, DUH.

[06:09] * japhb slaps forehead

[06:10] <japhb> Typed args: not just for multi dispatch ..,

[06:10] <japhb> s/,/./

[06:13] *** kid51 left
[06:14] <sorear> moritz: what do I make of a passing TODO?

[06:14] <moritz> sorear: you unfudge it? or report that it doesn't pass for you?

[06:14] <sorear> ah

[06:16] *** drbean left
[06:21] <dalek> roast: 891aa14 | sorear++ | S03-operators/subscript-adverbs.t:

[06:21] <dalek> roast: [S03-operators/subscript-adverbs] remove a couple fudges for moritz

[06:21] <dalek> roast: review: https://github.com/perl6/roast/commit/891aa14173

[06:22] *** drbean joined
[06:22] <japhb> Is there any advantage to using nqp::iseq_s() and nqp::isge_i() rather than plain old 'eq' and '>=' operators?

[06:23] <japhb> Or is that also historical baggage?

[06:23] <sorear> either speed or historical speed

[06:23] <sorear> play with --target=pir to find out

[06:23] <japhb> sorear, hmmm, will try that.

[06:24] <sorear> how is nom memory usage these days?

[06:25] <moritz> compilation: 1.5G

[06:26] <sorear> ow

[06:28] <japhb> Yup, --target=pir confirms that the nqp:: form is way less overhed

[06:28] <japhb> *overhead

[06:29] * japhb takes a break

[06:44] <snarkyboojum> #perl6, o/

[06:46] <sorear> o/ snarkyboojum

[06:47] <sorear> just merged /serialize... now what I need to do before Mon is to rebuild the bootstrap system

[06:48] <snarkyboojum> pretty awesome milestone :D

[06:49] *** packetknife joined
[06:50] *** hypolin joined
[06:56] *** dual joined
[07:01] *** koban joined
[07:08] *** drbean left
[07:13] *** drbean joined
[07:14] *** kfo joined
[07:17] *** kfo_ left
[07:42] *** fhelmberger_ joined
[07:45] *** fhelmberger left
[07:50] *** fsergot left
[07:59] <masak> good morning, #perl6

[08:00] <sorear> good morning masak

[08:00] <japhb> https://gist.github.com/1321836

[08:00] <masak> sorear++ # merge

[08:00] <japhb> o/ masak

[08:01] <masak> I have good news about my macros grant application. I think you can guess what it is... :)

[08:02] <sorear> "it was accepted"?

[08:02] <snarkyboojum> masak: w00t - congrats :)

[08:02] <masak> \o/

[08:02] <japhb> yay!

[08:02] <sorear> did They say anythng interesting about it?

[08:03] <masak> Karen asked whether pmichaud is still fine being a grant manager.

[08:03] <masak> I replied "I think so, but I'll check".

[08:10] <masak> japhb: "As with all applied mathematics, there is nothing intrinsically magical about the definitions. They are simply chosen because they are useful." -- http://duramecho.com/Misc/WhyMinusOneInSd.html

[08:11] <masak> japhb: there's an interesting symmetry between that statement and what we talked about yesterday, about language constructs being vehicles for taking you places.

[08:18] *** mishin joined
[08:20] <japhb> masak, quite so

[08:20] <masak> mishin: –ø—Ä–∏–≤–µ—Ç!

[08:21] * japhb is headed for sleep, but if anyone has comments on, or improvements for, the second and third variants in my gist above, I'll happily backlog in the morning.  :-)

[08:21] <masak> I will look at it when time permits.

[08:22] * japhb is taking this and a few other similar functions as "small enough to understand but large enough to learn from" on the way to being able to make larger contributions to Rakudo.

[08:23] <japhb> sleep &

[08:26] <masak> 'night, japhb. dream of small functions and large contributions.

[08:31] *** am0c left
[08:34] <masak> I just replied to an email from someone who wanted to contribute to this year's Perl 6 Advent Calendar. :)

[08:35] <masak> (wrote "yes, I think there'll be one. yes, you're very welcome to contribute. please come to #perl6 on IRC.")

[08:37] *** rhapsody joined
[08:38] <tadzik> good morning #perl6

[08:38] <masak> tadzik! \o/

[08:38] <tadzik> masak: congrats for the grant!

[08:39] <masak> thanks \o/

[08:40] <masak> November will be... interesting. good thing I've decided not to blog every day, too. :P

[08:42] <mishin> 2masak:hi thank you

[08:44] *** rhapsody left
[08:46] <masak> perl6: $_ = "mishin"; s/m/–º/; s:g/i/–∏/; s/sh/—à/; s/n/–Ω/; .say

[08:46] <p6eval> pugs b927740: OUTPUT¬´decodeUTF8': bad data: '\1084'‚ê§decodeUTF8': bad data: '\1080'‚ê§decodeUTF8': bad data: '\1096'‚ê§decodeUTF8': bad data: '\1085'‚ê§Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs‚Ä¶

[08:46] <p6eval> ..rakudo 642e78, niecza v10-213-gf5dc966: OUTPUT¬´–º–∏—à–∏–Ω‚ê§¬ª

[08:46] <masak> ;)

[08:49] <mishin> ;))

[08:49] <mishin> cool

[08:50] <mishin> perl6: $_ = "mishin"; s/m/–º/; s:g/i/–∏/; s/sh/—à/; s/n/–Ω/; .say

[08:50] <p6eval> pugs b927740: OUTPUT¬´decodeUTF8': bad data: '\1084'‚ê§decodeUTF8': bad data: '\1080'‚ê§decodeUTF8': bad data: '\1096'‚ê§decodeUTF8': bad data: '\1085'‚ê§Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs‚Ä¶

[08:50] <p6eval> ..rakudo 642e78, niecza v10-213-gf5dc966: OUTPUT¬´–º–∏—à–∏–Ω‚ê§¬ª

[08:50] <mishin> i can eval perl6 code in irc?

[08:50] <mishin> beautiful

[08:51] <masak> rakudo: say "Yes We Can!"

[08:51] <p6eval> rakudo 642e78: OUTPUT¬´Yes We Can!‚ê§¬ª

[08:51] <mishin> construction  s:g/i/–∏/ similar to vi ;)

[08:51] *** odoacre left
[08:52] <masak> also, Perl 5.

[08:53] <masak> Perl 5 does it as s/i/–∏/g, but in Perl 6 we like to put regex-changing parameters up front, so the parser knows what to expect.

[08:54] <masak> otherwise, there are "interesting" consequences like using "/" in a comment in an /x regex, and the parser gets all confused.

[08:56] *** Trashlord joined
[08:58] <mishin> perl5:my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); say %months

[08:59] <mishin> perl5:say 'Good morning'

[08:59] <mishin> perl5:print 'Ok'

[09:00] <mishin> perl6:say 'Test'

[09:00] <mishin> perl6: "test".say

[09:00] <p6eval> pugs b927740, rakudo 642e78, niecza v10-213-gf5dc966: OUTPUT¬´test‚ê§¬ª

[09:00] <mishin> perl5 don't work i think

[09:01] <masak> correct.

[09:01] <masak> eval say "OH HAI"

[09:01] <buubot_backup> masak: ERROR: syntax error at (eval 20) line 1, near "say "OH HAI"" 

[09:01] <masak> eval print "OH HAI\n"

[09:01] <buubot_backup> masak: OH HAI 1

[09:02] <masak> eval "OH HAI"

[09:02] <buubot_backup> masak: OH HAI

[09:09] <mishin> eval say "Test\n"

[09:09] <buubot_backup> mishin: ERROR: syntax error at (eval 20) line 1, near "say "Test\n"" 

[09:09] *** mj41 joined
[09:10] <mishin> eval print "Test\n"

[09:10] <buubot_backup> mishin: Test 1

[09:10] <mishin> eval my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); print "%months"

[09:10] <buubot_backup> mishin: %months1

[09:10] <mishin> eval my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); print %months

[09:10] <buubot_backup> mishin: Sep08May04Jul06Jun05Jan00Nov10Aug07Feb01Mar02Dec11Apr03Oct091

[09:10] <masak> eval $]

[09:10] <buubot_backup> masak: 5.014002

[09:11] <mishin> Wow ..it's worked;)

[09:11] <masak> eval use 5.14; say "OH HAI"

[09:11] <buubot_backup> masak: ERROR: Perl v5.140.0 required (did you mean v5.14.0?)--this is only v5.14.2, stopped at (eval 20) line 1. BEGIN failed--compilation aborted at (eval 20) line 1. 

[09:11] <masak> er, oops.

[09:11] <masak> eval use 5.014; say "OH HAI"

[09:11] <buubot_backup> masak: OH HAI 1

[09:11] <masak> \o/

[09:11] <mishin> eval my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); say %months

[09:11] <buubot_backup> mishin: ERROR: Illegal modulus zero at (eval 20) line 1. 

[09:12] <masak> mishin: if you use 'say', you have to predeclare it with 'use 5.010' or similar.

[09:12] <mishin> eval use 5.014;my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); say %months

[09:12] <buubot_backup> mishin: Sep08May04Jul06Jun05Jan00Nov10Aug07Feb01Mar02Dec11Apr03Oct09 1

[09:12] <masak> also, let's stop here because people start complaining that we're using up too much backlog ;)

[09:12] <masak> s/because/before/

[09:13] <mishin> eval use 5.014;use use Data::Dumper; my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); say print Dumper(%months)

[09:13] <buubot_backup> mishin: ERROR: Bareword "Data::Dumper" not allowed while "strict subs" in use at (eval 20) line 1. 

[09:13] <mishin> eval use 5.014;use Data::Dumper; my %months;@months{qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec )} = ( '00' .. '11' ); say print Dumper(%months)

[09:13] <buubot_backup> mishin: $VAR1 = 'Sep'; $VAR2 = '08'; $VAR3 = 'May'; $VAR4 = '04'; $VAR5 = 'Jul'; $VAR6 = '06'; $VAR7 = 'Jun'; $VAR8 = '05'; $VAR9 = 'Jan'; $VAR10 = '00'; $VAR11 = 'Nov'; $VAR12 = '10'; $VAR13 = 'Aug'; $VAR14 = '07'; $VAR15 = 'Feb'; $VAR16 = '01'; $VAR17 = 'Mar'; $VAR18 = '02'; $VAR19 = 'Dec'; $VAR20 = '11'; $VAR21 = 'Apr'; $VAR22 = '03'; $VAR23 = 'Oct'; $VAR24 = '09'; 1 1

[09:14] <mishin> exuse me ..cool opportunities;))

[09:15] <mishin> 2masak, well well it's just toys

[09:15] <masak> we do use it for serious purposes much of the time, though.

[09:15] <kranius> is Perl better than a randomly generated language ? :> http://bit.ly/vOAYl9

[09:16] <moritz> nom: my %h = <Jan Feb Mar> Z 0...2; say %h.perl

[09:16] <p6eval> nom 642e78: OUTPUT¬´("Jan" => 0, "Feb" => 1, "Mar" => 2).hash‚ê§¬ª

[09:16] *** ggoebel left
[09:16] <moritz> kranius: this thing has been going round the net, even though they used very bad perl examples, had a small sample size, and no statistical significance

[09:17] <moritz> in other words, it's FUD

[09:17] <mishin> 2moritz..thanks much better

[09:17] <eiro> kewl, 

[09:17] <eiro> oops :) 

[09:17] <eiro> hello guys 

[09:17] <flussence> kranius: if you want a valid experiment, don't port average PHP code to perl then claim perl is hard to read :)

[09:17] <moritz> hei eiro

[09:18] <kranius> it's for early morning trolling purposes

[09:19] <masak> kranius: the only real conclusion if quite un-revolutionary: people who don't know better can easily make a mess in permissive languages.

[09:20] <tadzik> kranius: I've just replied to that on slashdot. I find it odd how otherwise intelligent people believe everything they read on some random site

[09:21] <moritz> though if you read thedailywtf.com, you'll see that people can easily make a mess of non-permissive languages too :-)

[09:21] *** ggoebel joined
[09:22] <masak> sure, it just takes a bit more effort.

[09:22] <masak> but yeah; in general being very unknowledgeable about something works wonders for creating a mess.

[09:23] <kranius> indeed, WWII was won with a hoaw :)

[09:24] <kranius> hoax*

[09:27] *** replore_ left
[09:32] *** ggoebel left
[09:37] *** ggoebel joined
[09:38] *** Alias left
[09:42] *** daxim joined
[09:48] <geekosaur> "you can write FORTRAN in any language"

[09:49] * moritz finds FORTRAN to be particularly well-suited to write FORTRAN code :-)

[09:52] <masak> in one assignment at uni, the skeleton Java code we were given had methods with one parameter being an array and the next being the length of the array. turns out guy who wrote the code was a FORTRAN programmer.

[09:54] <moritz> "old habits die hard", as the saying goes

[09:56] *** pnu left
[09:57] *** pnu joined
[10:02] *** hypolin left
[10:06] <moritz> nom: sub f() { my int $i = 2; return ($i, $i) }; my int ($x,$y) = f; say $x; say $y

[10:06] <p6eval> nom 642e78: OUTPUT¬´Lexical '$x' is of wrong register type in lexical lookup‚ê§  in block <anon> at /tmp/yzIJ6wokc9:1‚ê§  in <anon> at /tmp/yzIJ6wokc9:1‚ê§¬ª

[10:06] <moritz> nom: my int ($x, $y); say $x

[10:07] <p6eval> nom 642e78: OUTPUT¬´Lexical '$x' is of wrong register type in lexical lookup‚ê§  in block <anon> at /tmp/Oz04wwVBcv:1‚ê§  in <anon> at /tmp/Oz04wwVBcv:1‚ê§¬ª

[10:07] * moritz submits rakudobug

[10:07] <moritz> nom: my int ($x, $y);

[10:07] <p6eval> nom 642e78: OUTPUT¬´Lexical '$x' is of wrong register type in lexical lookup‚ê§  in block <anon> at /tmp/FX3ocH8HsO:1‚ê§  in <anon> at /tmp/FX3ocH8HsO:1‚ê§¬ª

[10:09] <moritz> nom: my int $x; my int $y; ($x, $y) = (5, 6); say $x

[10:09] <p6eval> nom 642e78: OUTPUT¬´Cannot assign to a non-container‚ê§  in method STORE at src/gen/CORE.setting:3734‚ê§  in block <anon> at /tmp/15k6zUC4yA:1‚ê§  in <anon> at /tmp/15k6zUC4yA:1‚ê§¬ª

[10:09] * moritz submits another rakudobug

[10:10] <jnthn> oh no, not list assignment with natives :(

[10:10] <jnthn> I don't really know how to make that work.

[10:10] <jnthn> Don't expect a fix in the very near future.

[10:10] <moritz> ok :-)

[10:11] <jnthn> It's the same problem as "rw" for natives

[10:11] <jnthn> but...worse.

[10:11] <moritz> thought so (and wrote as much in the ticket)

[10:11] <moritz> it's what hinders us to go all-native in Str.{succ,pred} and RANGEPOS

[10:13] <jnthn> oh, and that one ties into native return too

[10:14] <moritz> nom: sub f() { my int $i = 2; return ($i, $i) }; my ($x,$y) = f; say $x; say $y

[10:14] <p6eval> nom 642e78: OUTPUT¬´2‚ê§2‚ê§¬ª

[10:14] <moritz> it probably just boxes while putting the natives into the Parcel

[10:17] <moritz> nom: sub f() returns (int, int) { my int $i = 2; return ($i, $i) }; my ($x,$y) = f; say $x; say $y

[10:17] <p6eval> nom 642e78: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "returns (i"‚ê§¬ª

[10:17] <moritz> hm, perl 6 still isn't Haskell :-)

[10:21] *** am0c joined
[10:23] <moritz> nom: say (46 - 38) / 46

[10:23] <p6eval> nom 642e78: OUTPUT¬´0.173913043478261‚ê§¬ª

[10:26] <moritz> 18% speedup on a $str++ heavy benchmark

[10:27] <moritz> just by using mostly natives, and avoiding some calls

[10:31] <jnthn> nice :)

[10:32] <jnthn> lunch &

[10:32] *** smash left
[10:32] *** smash joined
[10:33] <moritz> I'll see if japhb comes up with a similar or nicer patch, and if not I'll push mine

[10:40] *** MayDaniel joined
[11:03] *** drbean left
[11:07] *** uniejo joined
[11:08] *** drbean joined
[11:38] *** Psyche^ joined
[11:42] *** Patterner left
[11:42] *** Psyche^ is now known as Patterner

[11:46] *** koban left
[11:46] <moritz> arg, my patch broke the spectests

[11:46] <moritz> "it's easy to come up with the wrong answer in O(1)"

[11:56] *** replore_ joined
[11:58] *** replore_ left
[12:03] *** GlitchMr joined
[12:08] *** donri joined
[12:23] <colomon> niecza: say 5 lcm 24323

[12:23] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´‚ê§Unhandled Exception: System.Exception: Unable to find lexical &infix:<lcm> in mainline‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ‚ê§  at Niecza.CL‚Ä¶

[12:24] <colomon> niecza: say 5gcd 24323

[12:24] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Whitespace is required between alphanumeric tokens at /tmp/RWZvwtUdCt line 1:‚ê§------> [32msay 5[33m‚èè[31mgcd 24323[0m‚ê§‚ê§‚ê§Unhandled Exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die‚Ä¶

[12:24] <colomon> niecza: say 5 gcd 24323

[12:24] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´‚ê§Unhandled Exception: System.Exception: Unable to find lexical &infix:<gcd> in mainline‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ‚ê§  at Niecza.CL‚Ä¶

[12:25] *** donri left
[12:26] *** donri joined
[12:26] <colomon> rakudo: say 5.0 gcd 24323

[12:27] <p6eval> rakudo 642e78: OUTPUT¬´1‚ê§¬ª

[12:27] <colomon> rakudo: say 5.4 gcd 24323

[12:27] <p6eval> rakudo 642e78: OUTPUT¬´1‚ê§¬ª

[12:30] <colomon> niecza: say (5.4).Int

[12:30] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´5‚ê§¬ª

[12:40] <[Coke]> nom: say 78/13.Int

[12:40] <p6eval> nom 642e78: OUTPUT¬´6‚ê§¬ª

[12:42] <[Coke]> masak++ # congrats.

[12:42] <[Coke]> pmichaud++ # I'm reminded to ping you on grant status. ;)

[12:42] <colomon> masak's grant came through?

[12:43] *** bluescreen10 joined
[12:43] <moritz> I think that was about pmichaud's List grant

[12:43] <colomon> "masak++ # congrats" was about pmichaud's grant?

[12:44] <moritz> oh, no

[12:44] * moritz confused

[12:44] <masak> my grant came through, yes.

[12:44] <[Coke]> colomon, yes, saw it in backscroll just now

[12:44] <colomon> \o/

[12:44] <moritz> masak++ indeed

[12:44] <colomon> masak++

[12:44] * [Coke] has to rethink his irssi don't scroll on new messages policy. ;)

[12:44] <masak> let's do this. let's implement macros :)

[12:47] <colomon> niecza: say 20 div 5

[12:47] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´4‚ê§¬ª

[12:48] *** bluescreen10 left
[12:50] <jnthn> masak++ # yay

[12:50] <masak> actually, it's more like TPF++ ;)

[12:50] <jnthn> :)

[12:51] <moritz> (Ian Hague)++

[12:53] <masak> grants++

[12:54] <jnthn> macros++ ;)

[12:54] <moritz> everybody should have one!

[12:54] <moritz> erm, that applies both to grants and macros :-)

[12:54] <colomon> moritz++

[12:55] *** am0c left
[12:57] *** pernatiy joined
[12:58] <masak> I think I could do a "macros are X" blog post with three or four different Xs.

[12:58] <masak> macros are parser callbacks.

[12:58] <moritz> macros are abstractions

[12:59] <masak> macros are a kind of late binding.

[12:59] <colomon> wait.  you're not installing Macross into Perl 6?  http://en.wikipedia.org/wiki/Macross

[13:00] <moritz> macros are a PITA to implement, unless your syntax is as regular/non-existing as lisps

[13:00] <masak> oh, space-folding for FTL! brilliant! why didn't I think of that?

[13:00] *** bluescreen10 joined
[13:01] <masak> moritz: "you can have either a syntax or simple macros, but not both"

[13:02] <donri> macros are templates for code

[13:02] * moritz wonders if the answer to extracting stuff from ASTs is pattern matching like in signatures, and not an introspection API

[13:03] <donri> haskell has a non-trivial syntax and powerful macros via template haskell

[13:03] * colomon admits he's only ever actually seen Macross Plus

[13:05] <moritz> donri: well... haskell's syntax isn't trivial, but afaict its syntax trees are rather simple

[13:06] <donri> ah, that might be true

[13:06] <moritz> for example the fancyness of $ and of `prefix_as_infix` and the other way round disappears on the AST level

[13:09] <donri> ($) isn't fancy at all, that's what's fancy about it

[13:09] <jnthn> A lot of Perl 6 syntax desugars to method calls and sub calls too, mind.

[13:10] <donri> all infix ops have fixity and associativity though, which i suppose is pointless in the AST

[13:10] <donri> because it's merely a matter of precendence

[13:10] <moritz> jnthn: yes, but a lot of stuff is much more fancy than that

[13:12] *** packetknife left
[13:12] *** MayDaniel left
[13:13] <mux> I'd say haskell's syntax is more different than it is complicated

[13:14] <moritz> aye

[13:14] <dalek> niecza: 5ec4d8d | (Solomon Foster)++ | lib/ (2 files):

[13:14] <dalek> niecza: Add fully working but not terribly optimized versions of infix:<gcd> and infix:<lcm>.

[13:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5ec4d8dd36

[13:14] <dalek> niecza: ec2d94f | (Solomon Foster)++ | t/spectest.data:

[13:14] <dalek> niecza: Turn on gcd.t and lcm.t.

[13:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ec2d94f4b0

[13:15] <masak> colomon++

[13:16] *** im2ee joined
[13:16] <colomon> masak: bonus: they work on big ints in niecza.  :)

[13:16] <mux> mmm, how is this supposed to be used ? "x <gcd> y" ?

[13:16] <jnthn> They will in Rakudo soonish too :)

[13:17] <colomon> mux: $x gcd $y

[13:17] <mux> colomon: oh ok. thanks

[13:17] <colomon> jnthn: good, then you'll soon be able to unfudge the new tests I'm adding.  ;)

[13:17] <jnthn> \o/

[13:18] <moritz> nom: say 15 gcd 20

[13:18] <p6eval> nom 642e78: OUTPUT¬´5‚ê§¬ª

[13:18] <[Coke]> nom:say 321092340234234 gcd 2134832742342342

[13:19] <masak> gcd/lcm are a bit like min/max -- they're nicer in their derived forms than in the "basic" infix form. :)

[13:19] <[Coke]> nom: say 321092340234234 gcd 2134832742342342 #evil whitespace postcolon!

[13:19] <p6eval> nom 642e78: OUTPUT¬´2‚ê§¬ª

[13:19] <mux> I assumed the bot was running the code referred to by the commit logs and wouldn't be able to handle it :)

[13:19] <moritz> nom: 1 while 1;

[13:19] <p6eval> nom 642e78: OUTPUT¬´(timeout)¬ª

[13:19] <colomon> nom: say 4312432542432423432523434252 gcd 2454353421234435325435435366241

[13:19] <p6eval> nom 642e78: OUTPUT¬´-9223372036854775808‚ê§¬ª

[13:20] <[Coke]> there you go. ;)

[13:20] <moritz> the reason for the required whitespace was that talking about nqp::foo opcodes at the start of a line would trigger syntax errors from p6eval's 'nqp:' target

[13:24] <masak> anyone else who *lurves* the foo( :$argument ) syntax for named arguments? :)

[13:24] <flussence> +1

[13:24] <moritz> it's one of the things I often wish p5 had :-)

[13:25] <masak> I find it takes the pressure of naming variables in the caller scope! :D

[13:25] <masak> off*

[13:27] <moritz> nom: my int $x = 3; $x = 'foo'.index('o') // $x; say $x

[13:27] <p6eval> nom 642e78: OUTPUT¬´1‚ê§¬ª

[13:27] <moritz> nom: my int $x = 3; $x = 'foo'.index('x') // $x; say $x

[13:27] <p6eval> nom 642e78: OUTPUT¬´3‚ê§¬ª

[13:27] *** fsergot joined
[13:27] <mux> nom: 'foo'.index('a')

[13:27] <p6eval> nom 642e78:  ( no output )

[13:27] <mux> nom: say 'foo'.index('a')

[13:27] <p6eval> nom 642e78: OUTPUT¬´Str()‚ê§¬ª

[13:27] <moritz> that's a fossil

[13:27] <flussence> masak: I usually find myself reusing names in that way anyway, it's more obvious then :)

[13:27] <mux> HELLO I HAVE NO IDEA WHAT IM DOING

[13:27] * mux chuckles

[13:27] <moritz> should probably fail('substring not found')

[13:28] <colomon> niecza: say 123123123123123123123123123 * 2

[13:28] <p6eval> niecza v10-213-gf5dc966: OUTPUT¬´Rebuild in progress‚ê§¬ª

[13:28] <mux> moritz: I expected either that or -1 or undef

[13:28] <donri> mux: i was thinking mostly of the "layout" style which is based on columnal alignment rather than just indentation

[13:28] <moritz> mux: well, it was undef

[13:28] <donri> but yea, that all is gone in the AST level

[13:28] <moritz> mux: Str is the undefined string

[13:28] <moritz> mux: aka "type object"

[13:28] <mux> donri: I think you meant to say that to someone else

[13:28] <mux> moritz: ooooh. ok

[13:28] <moritz> mux: there's not one "undef" in Perl 6, but one for every type

[13:29] <mux> dude

[13:29] <mux> one wasn't enough?!

[13:29] <donri> mux	I'd say haskell's syntax is more different than it is complicated

[13:29] <mux> donri: oh, sorry :-)

[13:29] <donri> :)

[13:29] <moritz> mux: that's like all (non-native) types being Maybe by default

[13:29] * mux points at Tony Hoare's "billion dollas mistake"

[13:29] <moritz> mux: maybeList = Just List | Nothing

[13:30] <mux> dollar*

[13:30] <colomon> niecza: say 123123123123123123123123123 * 2

[13:30] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´246246246246246246246246246‚ê§¬ª

[13:31] <colomon> niecza: say 123123123123123123123123123 * 7

[13:31] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´861861861861861861861861861‚ê§¬ª

[13:31] *** frettled left
[13:31] <mux> I suppose that in the context of dynamic typing, it's less problematic to have null references

[13:32] *** frettled joined
[13:32] <colomon> niecza: say 123123123123123123123123123 gcd 3454756432984634718571837489371489729

[13:32] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´3‚ê§¬ª

[13:33] <mux> does Perl have non-nullable types?

[13:33] <colomon> niecza: say 123123123123123123123123123 gcd 3454756432984634718571837489371489728

[13:33] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´1‚ê§¬ª

[13:33] <moritz> mux: yes, native types

[13:33] <masak> mux: there's Str:D

[13:33] <moritz> that too

[13:33] <mux> I, er...

[13:33] * mux 's brain explodes all over the topic

[13:33] <masak> you did ask ;)

[13:33] <mux> I did :)

[13:33] <colomon> niecza: say 123123123123123123123123123123 div 123 * 123123123123123123123123123

[13:33] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´123246369492615738861985108107984861738615492369246123‚ê§¬ª

[13:35] <dalek> roast: 19c97a0 | (Solomon Foster)++ | S03-operators/ (2 files):

[13:35] <dalek> roast: More tests for gcd and lcm.

[13:35] <dalek> roast: review: https://github.com/perl6/roast/commit/19c97a0c0d

[13:35] <moritz> mux: I think a big problem is people think "it's statically typed, so I don't need to be careful", and forget Null pointers

[13:36] <colomon> Could someone out there please make sure I didn't just break those test files for Rakudo?  I don't have anything like a recent build of nom handy to test on.

[13:36] <mux> moritz: which is why I like it when there are _no_ null pointers/references :-)

[13:37] <mux> (Haskell's undefined really doesn't count here, honestly)

[13:37] <mux> if I return a Maybe Something in Haskell, there is no way in hell you can treat it as a Something, it won't compile

[13:38] <mux> if I say I return a Something, there's no way for me to lie about it and return a Null-like thingie (again, forgetting about undefined but it's legitimate here)

[13:44] <masak> this concludes today's Haskell advertisement. (use GHC 7.2.1, released earlier this year!)

[13:46] <flussence> .oO( grr... gentoo never has up-to-date language runtimes for *anything* lately... )

[13:46] *** thou joined
[13:47] *** masak left
[13:47] <geekosaur> (if they ever fix the bloody haskell98 breakage in all the dependencies...)

[13:47] *** masak joined
[13:48] <mux> masak: hahaha

[13:49] <masak> :)

[13:49] *** MayDaniel joined
[13:52] *** SHODAN left
[13:53] *** grondilu joined
[13:53] <grondilu> ¬´wrong register type in lexical lookup¬ª:  http://pastebin.com/VVnPcBZ0

[13:54] <grondilu> ^ while trying a simple 'my int $n = 0'

[13:54] *** MayDaniel_ joined
[13:54] <masak> native types. they're a raw experience.

[13:54] <grondilu> funny thing is that it works fine when I run from command line:  perl6 -e 'my int $n = 0;'

[13:55] <jnthn> Yes, that was RT'd yesterday

[13:55] <slavik1> masak: can you suggest a haskell book?

[13:55] <jnthn> Don't use native types in the repl :

[13:55] <jnthn> *:)

[13:55] *** MayDaniel left
[13:57] * Woodi think that {{{ }}} was disaster :)

[13:58] <jnthn> ...quasi quoting?

[13:58] <Woodi> so how to type []o ? :)

[13:58] <masak> Woodi: please make more sense.

[13:58] <masak> I'm interested in understanding what you really mean.

[13:59] <Woodi> jnthn: no idea what but disaster...

[13:59] <masak> doom! unspecified doom, I tell you!

[13:59] <jnthn> Woodi: So, you have bugger all idea what something is. But you think it's a disaster. Wow. You're so worth listening too.

[13:59] <Woodi> masak: syntax like: {{{ $var }}} is good for template system me thinks

[13:59] * masak hugs jnthn :)

[14:00] <jnthn> Woodi: macros *are* a template system! :)

[14:00] <jnthn> ...kinda :)

[14:00] <masak> Woodi: well, quasi quotes are... what jnthn said.

[14:00] <Woodi> templating system which you cen find in _separate_ file :)

[14:01] *** daniel-s left
[14:01] <jnthn> macro foo($a) is export { ... } # can do 

[14:01] *** GlitchMr42 joined
[14:01] *** GlitchMr left
[14:01] <masak> Woodi: here's the problem we're trying to solve: we're trying to mix "ordinary code" and "placeholders". that's very similar to what a templating system tries to do.

[14:01] *** GlitchMr42 is now known as GlitchMr

[14:02] <masak> Woodi: your "separate file" argument doesn't really float because it's not code and HTML (or equiv) here, but code and code.

[14:02] <Woodi> masak: good, can i help ?

[14:02] <masak> oh yes.

[14:02] <masak> learn how macros work in Perl 6, and then come talk to me ;)

[14:03] <masak> the more brains are in on this, the better.

[14:03] <Woodi> hmm

[14:03] <jnthn> decommute &

[14:05] <Woodi> S06 have one paragraph for macro and next one for quasi. is somewhere something more ?

[14:07] <moritz> there was a post on masak's blog...

[14:07] <masak> latest one, actually.

[14:07] * Woodi looks

[14:07] <moritz> http://strangelyconsistent.org/

[14:07] <masak> also, there are a few gists, but some of that information needs revising.

[14:09] <masak> Woodi: you might be interested in reading https://gist.github.com/1148915 and https://gist.github.com/1149126 and https://gist.github.com/1156662 and https://gist.github.com/1293853

[14:09] <masak> just keep in mind that it's musings, not spec ;)

[14:09] *** grondilu left
[14:12] *** TiMBuS left
[14:12] <Woodi> noted

[14:13] *** TiMBuS joined
[14:14] <moritz>     macro metafor(Int $levels, &block) {

[14:14] <moritz>         return quasi { {{{&block}}}() } if eval($levels) < 1;

[14:14] *** cognominal_ joined
[14:15] <moritz> that doesn't make much sense

[14:15] <moritz> either $levels is an Int, then it doesn't need the eval()

[14:15] <moritz> or it's an AST, then the type constraint blows up

[14:16] *** SHODAN joined
[14:16] <moritz> (that's from the first gist)

[14:17] *** cognominal left
[14:19] *** risou_awy is now known as risou

[14:20] <TimToady> awwaiid: using hyphens might be one step closer to Lisp, but in my mind it's one step closer to English

[14:20] <TimToady> and that's why we also have apostrophes now

[14:20] <slavik1> wha?

[14:20] <slavik1> TimToady: will there be a Programming Perl 6 book or are you taking yourself out of that process?

[14:20] <masak> nom: say my $we'have'apostrophes'now = 42

[14:20] <p6eval> nom 642e78: OUTPUT¬´42‚ê§¬ª

[14:20] <moritz> masak: in https://gist.github.com/1149126, are $lhs-bound and $lhs-saved the ame thing?

[14:21] <slavik1> so, they are treated as \w ?

[14:21] <moritz> (oh, and $lhs-bound should be typed Mu

[14:21] <moritz> )

[14:21] <masak> moritz: yes; typo. fixing.

[14:21] <moritz> slavik1: no

[14:21] <TimToady> slavik1: TheDamian and I are planning to write a Perl 6 version of the camel, though it may well not have a camel on it

[14:21] <flussence> std: sub f'' { ... }

[14:21] <moritz> slavik1: they are only allowed between <alpha> characters

[14:21] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed block at /tmp/GjsmzI_pek line 1:‚ê§------> [32msub f[33m‚èè[31m'' { ... }[0m‚ê§    expecting any of:‚ê§        new name to be defined‚ê§ routine_def‚ê§    trait‚ê§Parse failed‚ê§FAILED 00:01 118m‚ê§¬ª

[14:22] <slavik1> moritz: ahh, ok

[14:22] <slavik1> TimToady: cool. can't wait for it to be avail :)

[14:22] <flussence> std: sub f‚Ä≤ { ... }

[14:22] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed block at /tmp/88mSxXQzXe line 1:‚ê§------> [32msub f[33m‚èè[31m‚Ä≤ { ... }[0m‚ê§    expecting any of:‚ê§ new name to be defined‚ê§ routine_def‚ê§    trait‚ê§Parse failed‚ê§FAILED 00:01 118m‚ê§¬ª

[14:23] <slavik1> rakudo: sub f'f {say "hello";} f'f();

[14:23] <p6eval> rakudo 642e78: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "sub f'f {s"‚ê§¬ª

[14:23] <slavik1> std: sub f'f {say "hello";} f'f();

[14:23] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Strange text after block (missing comma, semicolon, comment marker?) at /tmp/Dp35YiZO7E line 1:‚ê§------> [32msub f'f {say "hello";}[33m‚èè[31m f'f();[0m‚ê§    expecting any of:‚ê§     bracketed infix‚ê§        infix or meta-infix‚ê§    statement modifier

[14:23] <p6eval> ..lo‚Ä¶

[14:23] <slavik1> rakudo: sub f'f {say "hello";}; f'f();

[14:23] <p6eval> rakudo 642e78: OUTPUT¬´hello‚ê§¬ª

[14:23] <slavik1> :D

[14:23] *** jaldhar left
[14:23] <slavik1> isn't that technically a bug? or is that working as intended?

[14:24] <TimToady> masak: macros are kind of like space folds; things that are temporarily in two places at once

[14:24] <moritz> slavik1: what do you think is wrong with it?

[14:24] <slavik1> moritz: I did not expect to have to put a semicolon after block

[14:24] <moritz> slavik1: then you should re-read S02 :-)

[14:25] <slavik1> moritz: ok

[14:26] <TimToady> a block is a kind of term in Perl 6, so there must be either semicolon or newline between it and the next term

[14:26] <TimToady> well, something that's not a term between, anyway

[14:26] <slavik1> ahh, I see

[14:26] <slavik1> thanks

[14:26] *** thou left
[14:27] <slavik1> TimToady: is the spec fairly stable at this point when it comes to basic perl6?

[14:27] <TimToady> yes

[14:27] <masak> TimToady: now I *have* to write that blog post :)

[14:28] <masak> macros are copy-paste done right. :)

[14:28] <slavik1> cool, thanks, will download and read :D

[14:29] <moritz> functions are copy&paste done right too :-)

[14:29] <masak> yes... I keep finding things that macros have in common with functions...

[14:29] <masak> it makes functions seem all the more scary :P

[14:30] <TimToady> about the only place P6 cheats on the two-terms-in-a-row is in detecting a block or lambda following the expression of a control statement

[14:31] *** mkramer joined
[14:31] *** mkramer left
[14:31] <TimToady> well, not even a block, just a lambda

[14:31] <TimToady> std: for 1,2,3, {.say}

[14:31] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Expression needs parens to avoid gobbling block at /tmp/L2Ph09mXxF line 1:‚ê§------> [32mfor [33m‚èè[31m1,2,3, {.say}[0m‚ê§Missing block (apparently gobbled by expression) at /tmp/L2Ph09mXxF line 1:‚ê§------> [32mfor 1,2,3, {.say}[33m‚èè[3‚Ä¶

[14:32] <mux> someone said lambda?

[14:32] <TimToady> std: for 1,2,3, -> $_ {.say}

[14:32] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Expression needs parens to avoid gobbling block at /tmp/CUasSs6LYw line 1:‚ê§------> [32mfor [33m‚èè[31m1,2,3, -> $_ {.say}[0m‚ê§Missing block (apparently gobbled by expression) at /tmp/CUasSs6LYw line 1:‚ê§------> [32mfor 1,2,3, -> $_ {.s‚Ä¶

[14:32] <TimToady> std: for 1,2,3 -> $_ {.say}

[14:32] <p6eval> std be1f10e: OUTPUT¬´ok 00:01 124m‚ê§¬ª

[14:32] <TimToady> mux: yes, -> is a lambda in disguise

[14:33] <mux> nice!

[14:33] <moritz> but you just need to tilt your head a bit to see through the disguise... or not :-)

[14:33] <TimToady> but it starts a term, and 3 is a term, so 3 -> is technically TTIAR

[14:33] *** sayu joined
[14:33] <TimToady> we get around it by treating -> as a terminator for those constructs

[14:33] <mux> I now understand the given($foo) -> { ... } example I was given some time ago

[14:34] <TimToady> yes, that's why we reversed it from what P5 does: for my $x (1,2,3) {...}

[14:34] <masak> :)

[14:34] <masak> it makes a lot of sense.

[14:34] <masak> the $x in -> $x {} belongs to the block, not to the 'for' keyword.

[14:34] <TimToady> and, in fact, the -> belongs to it too, but it *looks* like an infix :)

[14:36] <masak> nom: my @a = 1, 2, 3; for @a <-> $x { $x = 42 }; say @a.perl

[14:36] <p6eval> nom 642e78: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near "; say @a.p"‚ê§¬ª

[14:36] <masak> b: my @a = 1, 2, 3; for @a <-> $x { $x = 42 }; say @a.perl

[14:36] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Missing block at line 22, near "; say @a.p"‚ê§¬ª

[14:36] <masak> alpha: my @a = 1, 2, 3; for @a <-> $x { $x = 42 }; say @a.perl

[14:36] <p6eval> alpha : OUTPUT¬´[42, 42, 42]‚ê§¬ª

[14:36] <masak> <-> has been regressed for a long time now :/

[14:36] <masak> niecza: my @a = 1, 2, 3; for @a <-> $x { $x = 42 }; say @a.perl

[14:36] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´[42, 42, 42].list‚ê§¬ª

[14:37] <masak> \o/

[14:37] <TimToady> it's because juerd++ had a concussion

[14:37] <TimToady> that's his feature :)

[14:37] <masak> yep. :)

[14:37] * mux scratches head some more

[14:37] <mux> lambda ref ?

[14:37] <TimToady> <-> is just a two-way lambda :)

[14:38] <TimToady> <-> $x means -> $x is rw

[14:38] <moritz> lambda with rw parameter

[14:39] <TimToady> which, of course, is a funny thing to call a lambda, considering

[14:39] <TimToady> maybe we should call it a wolfda

[14:39] <masak> we could make >-> mean "lambda with copy parameter" :P

[14:39] <colomon> niecza: my @a = 1, 2, 3; for @a <-> $x { $x = 42 }; say @a.perl

[14:39] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´[42, 42, 42].list‚ê§¬ª

[14:40] <mux> ok

[14:40] <moritz> masak: and ->> "parallel iteration"

[14:40] <TimToady> Haskell it ain't  :)

[14:41] <Juerd> TimToady: Unless I'm remembering it wrong, that feature idea was years older than the concussion :)

[14:41] <masak> moritz: <<->> "parallel with rw", >>->> "parallel with copy"... :P

[14:41] <mux> hahaha

[14:41] <TimToady> Juerd: we were speaking about why it regressed :)

[14:41] <Juerd> Oh, I see :)

[14:41] <mux> wouldn't that conflict with hyper-operators? :-P

[14:41] <[Coke]> Juerd: hey! can you increase the default virtual memory available on feather so I can build rakudo there?

[14:41] <masak> mux: ssshhh!

[14:41] <masak> :P

[14:42] <mux> heh

[14:42] <mux> nom: 1,2,3 <<+>> 4,5,6

[14:42] <p6eval> nom 642e78:  ( no output )

[14:42] <moritz> mux: don't spoil our ideas by exposing them to reality

[14:42] <mux> oh darn.

[14:42] <mux> nom: say(1,2,3 <<+>> 4,5,6)

[14:42] <p6eval> nom 642e78: OUTPUT¬´12756‚ê§¬ª

[14:42] * mux just had a concussion too

[14:42] <Juerd> [Coke]: How much swap do you need then?

[14:42] <TimToady> std: hyper for @x -> {...}

[14:42] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable @x is not predeclared at /tmp/SHSMG7VYGv line 1:‚ê§------> [32mhyper for [33m‚èè[31m@x -> {...}[0m‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/SHSMG7VYGv line 1:‚ê§---‚Ä¶

[14:43] <moritz> mux: I might add that previous versions of p6eval did print out return values if the program didn't produce any output. It confused the heck out of people.

[14:43] <TimToady> std: hyper for @*ARGS {...}

[14:43] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/U2BeBIxtWA line 1:‚ê§------> [32mhyper for @*ARGS [33m‚èè[31m{...}[0m‚ê§    expecting infix or meta-infix‚ê§Parse failed‚ê§FAILED 00:01 ‚Ä¶

[14:43] <TimToady> innersting

[14:43] <mux> moritz: oh it did? I guess functional people intuitvely think the bot will handle expressions and return their evaluated values, and imperative people think statements :-)

[14:44] <TimToady> hyper can't be parsed as a function

[14:44] <moritz> std: my $x = for () { }

[14:44] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Word 'for' interpreted as a listop; please use 'do for' to introduce the statement control word at /tmp/2rzqZgGCLG line 1:‚ê§------> [32mmy $x = [33m‚èè[31mfor () { }[0m‚ê§Unexpected block in infix position (two terms in a row) at /tmp/2r‚Ä¶

[14:44] <TimToady> hyper needs to parse as statement prefix

[14:44] <flussence> .oO( the use of minus greater-than for an assignment operator in that single case is starting to give me an OCD itch... )

[14:44] <TimToady> hmm, that won't work either..

[14:45] <TimToady> std: hyper do for @*ARGS {...}

[14:45] <p6eval> std be1f10e: OUTPUT¬´ok 00:01 122m‚ê§¬ª

[14:45] <TimToady> there's your parallel loop

[14:46] <moritz> how very intuitive :-/

[14:46] <masak> moritz: I'd say the big problem was that the code that checked for output interfered too much with debugging and analysis.

[14:47] <masak> TimToady: special-case 'hyper for' to mean 'hyper do for', perhaps?

[14:48] * masak pictures a 'hyper while' and gets dizzy

[14:48] <TimToady> that's why hyper is something that you put on a list, not on a loop

[14:49] <masak> yeah.

[14:49] <masak> but 'hyper for' feels like it should be syntactical...

[14:49] <TimToady> that's why I said it'd have to be a statement_prefix to work that way

[14:49] <masak> nod.

[14:49] <masak> probably it's because 'eager map' works just fine.

[14:50] <masak> there's an expectation of <adjective> <language construct> working.

[14:50] <TimToady> and hyper map is how we thought of it

[14:50] <TimToady> for is just a funny way to write a map

[14:51] <TimToady> well, in that spot, more like an adverb: hyperly do this...

[14:52] <TimToady> eagerly map, lazily map

[14:53] <[Coke]> Juerd: good question. Probably a Gig.

[14:53] *** SHODAN left
[14:53] <TimToady> but that's starting to give me Occam's Razor burn

[14:54] <masak> indeed.

[14:54] <masak> maybe just leave it as it is until the need arises.

[14:55] <TimToady> is what I was planning anyway :)

[14:55] <Juerd> [Coke]: I'll install "swapspace", which manages it in userspace by claiming disk space.

[14:55] <Juerd> [Coke]: Can you please monitor how much is used during compilation? Then I can add that amount more permanently with real swap.

[14:56] <moritz> about 1.5G on my machine

[14:56] <Juerd> [Coke]: It's installed now. You should have many GBs available now :)

[14:56] <[Coke]> moritz: there we go. ;)

[14:56] <Juerd> swapspace++

[14:56] <[Coke]> me tries to build rakudo.

[14:58] *** tokuhiro_ joined
[14:59] <[Coke]> Failed allocation of 4096 bytes

[14:59] <[Coke]> Parrot VM: PANIC: Out of mem!

[15:00] <masak> huh, attribute grammars were easier to understand than I feared. they look a whole lot like what we do when we synthesise .ast values up the parse tree in action methods.

[15:00] <[Coke]> ... ah, probably need to not do this inside a screen that is stuck at the old ulimit.

[15:00] <Woodi> quasi spec is crazy thing (on first reading) :)

[15:00] <masak> Woodi: it's a quote construct for code. :)

[15:01] <[Coke]> Juerd: if I ssh in with a fresh shell, ulimit -v still says 524288

[15:03] <Juerd> Ulimits aren't global so you must have set that yourself.

[15:04] <Juerd> Also, the swap space manager adds more as it's needed, so even the amount you see in top and free won't be reliable :)

[15:08] *** thou joined
[15:09] <TimToady> it really bugs me to see sub bar(\$x) { say [$x].elems };

[15:10] <TimToady> in my mind $ should never flatten

[15:10] <Juerd> It has the flatten operator in it, | ;)

[15:10] <masak> TimToady: where do you see that?

[15:10] <TimToady> makes me want sub bar (\x) { say [x].elems } intead

[15:10] <Juerd> So the S is a cushion to prevent that from happening? :)

[15:10] <TimToady> *stead

[15:11] <TimToady> http://irclog.perlgeek.de/perl6/2011-10-28#i_4626925

[15:11] <TimToady> or a parcel sigil

[15:11] <Juerd> Is there any ascii left?

[15:11] *** drbean left
[15:11] <TimToady> we use extended ascii these days :)

[15:11] <masak> yeah, that feels weird.

[15:11] <[Coke]> Juerd: the only ulimit I see in my startup files in ulimit -c 0

[15:12] * [Coke] digs.

[15:12] <TimToady> but since a function can return a parcel, I don't have a problem seeing [x]

[15:12] <Juerd> [Coke]: I get "unlimited" from ulimit -v

[15:12] <Juerd> [Coke]: I still get that if I do sudo su - coke

[15:13] <[Coke]> Juerd: so, where could it be coming from?

[15:13] <flussence> PAM?

[15:13] <Juerd> I guess the easiest way to find that out is to start a new, clean, ssh session without screen and such, and run ulimit -v between each pair of steps to build rakudo

[15:14] *** dual left
[15:14] <[Coke]> Juerd: as I said, I get when I do I a fresh ssh login

[15:15] <Juerd> Oh, I missed that. That's strange.

[15:15] <[Coke]> (run putty locally, ssh to feather.perl6.nl, type "ulimit -v", see the limit.)

[15:15] * jnthn home

[15:16] <masak> jnthn! \o/

[15:16] <TimToady> sorear: I would like to change sub bar(\$x) { say [$x].elems } to instead read sub bar(\x) { say [x].elems }

[15:16] <[Coke]> this is feather.perl6.nl, btw, in case there are multiple feathers.

[15:16] <Juerd> [Coke]: There are limits in /etc/security/limits.conf; I don't recall having set those up but I'll remove it.

[15:16] <TimToady> so we don't imply item semantics

[15:16] <Juerd> There are multiple but generally "feather" refers to "feather1" :)

[15:17] <Juerd> Try again

[15:17] <jnthn> TimToady: ...what? :)

[15:18] *** drbean joined
[15:18] * jnthn guesses he needs to backlog something that happened while commuting..

[15:18] <TimToady> jnthn: I hate seeing $x interpolate a list

[15:18] <[Coke]> Juerd: \o/

[15:18] <[Coke]> I'll do the build later. teeth scraping beckons.

[15:19] <[Coke]> :(

[15:19] <jnthn> TimToady: Where are you seeing it?

[15:19] * masak .oO( Teeth::Scraper )

[15:19] <jnthn> TimToady: oh, when we do parcel binding?

[15:19] <jnthn> Hm

[15:19] <TimToady> yeah

[15:19] <jnthn> Yeah, the thingy is kinda contextless

[15:20] <TimToady> and $x looks really bad in a list

[15:20] <jnthn> Isn't it rare enough that we can kinda just sweep it under the carpet? :)

[15:20] <TimToady> not if we can fix it by allowing \x parameters

[15:20] <TimToady> just a bare alias

[15:20] <jnthn> Which install...what exactly?

[15:20] <jnthn> ah

[15:20] <jnthn> OK

[15:20] <jnthn> erm

[15:21] <jnthn> sub foo(\x) { my x $y } # seems we stand a high risk of this parsing if we do so :)

[15:21] <TimToady> only after a \

[15:21] <jnthn> right, otherwise it'd be ambiguous.

[15:21] <jnthn> with sub foo(SomeType) { }

[15:22] <TimToady> so possibly it's really a sigil it's wanting

[15:22] <jnthn> I'm nervous about it being sigilless

[15:22] <jnthn> As if it's without a sigil then it becomes a name

[15:22] <jnthn> and thus parsable as a type.

[15:22] <jnthn> With all the fun consequences that entails...

[15:22] <jnthn> Oh

[15:22] <jnthn> Actually we'd explode in Rakudo if somebody tried to do that though.:)

[15:22] <jnthn> Because we don't know the value at compile time.

[15:23] <jnthn> So it can't be used as a declarative thingy

[15:23] <jnthn> So maybe sigilless isn't so scary after all.

[15:23] <TimToady> if sigilless, it needs to parse as term, not listop, fershure

[15:24] <TimToady> we haven't quite invented SSA "constants" yet, but it's a gleam in my eye

[15:24] <TimToady> so maybe my \foo ::= expr does that

[15:25] <jnthn> hm

[15:25] <TimToady> or we hack the pseudo assignment so my \foo = expr does it

[15:25] <jnthn> So many assignments are pseudo anyway...

[15:25] <jnthn> If the suggested change to parsing declarators come through, it gets less messy to handle them also.

[15:25] <TimToady> only on declarators, and we already said we'd like to handle that in the declarator parse

[15:26] <jnthn> Right.

[15:26] <TimToady> the denerate cultural case in the SSA mindset is probably just: my foo = expr

[15:26] <TimToady> where we recognize that foo doesn't exist

[15:26] <jnthn> Hm

[15:26] <TimToady> or a different declarator, but it's really the same as our signature problem

[15:27] <jnthn> It'd be a little unfortunate that it's not symmetric with in signatures though.

[15:27] *** am0c joined
[15:28] <TimToady> and it's good that it's on a parameter, not a whole sig

[15:29] <masak> that 'my \foo = expr' syntax actually isn't half-bad.

[15:29] <TimToady> it's almost pointing out that we have | and \ backwards in sigs, since |foo is kinda the opposite

[15:29] <jnthn> Well, but the symmetry is really nice with calling and taking

[15:29] <jnthn> sub foo(|$c) { bar(|$c) }

[15:31] <masak> ooh

[15:31] <masak> "declaration mirrors use"

[15:31] <TimToady> thing is, that's really doing two things

[15:32] <TimToady> first, it's saying bind the next parameter to the outer capture, and also don't do anything to it

[15:33] <TimToady> which argues that we should separate those concerns

[15:33] <jnthn> It's not bind the next parameter to the outer capture though.

[15:33] <jnthn> It used to be that and then we changed it. :)

[15:33] <jnthn> Now it's "snapshot everything we haven't yet bound"

[15:33] <TimToady> that's what I mean, but it's still a level violation

[15:34] <TimToady> and \ indicates level violation to me, not |

[15:34] <jnthn> What do you mean by "don't do anything to it"?

[15:34] <TimToady> don't itemize

[15:34] <jnthn> Well, but a Capture kinda is an item... :)

[15:34] <TimToady> but $x shouldn't flatten :)

[15:34] <jnthn> And that's what you end up with in $c

[15:34] <jnthn> It won't in the |$c case.

[15:34] <jnthn> It's only the \ one that has issues there.

[15:35] <jnthn> (which may be what you're saying...just making sure we're on the same page)

[15:35] <jnthn> Really |$c binds just as $c would. Apart from the thing we bind is a Capture

[15:38] <TimToady> perl6: sub foo(|$c) { say [$c].elems }; foo 1,2,3

[15:38] <p6eval> pugs b927740, rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´1‚ê§¬ª

[15:38] *** cognominal_ left
[15:38] *** cognominal_ joined
[15:38] <TimToady> perl6: sub foo(\$p) { say [$p].elems }; foo (1,2,3)

[15:38] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "\\$"‚ê§    expecting formal parameter or ")"‚ê§    at /tmp/e3LlaimaOM line 1, column 9‚ê§¬ª

[15:38] <p6eval> ..rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´3‚ê§¬ª

[15:38] <TimToady> I think 3 is a wrongish answer there

[15:39] <TimToady> because of the $

[15:39] <jnthn> Aye, we introduced \ as a "context suppressor" 

[15:39] <TimToady> and the most contextless rvalue we have is bare x

[15:39] <jnthn> Which it's going...but that can turn out surprising in cases like ths.

[15:39] <jnthn> *doing

[15:40] <TimToady> which leads me to believe we should shoot the $ in this use case

[15:40] <TimToady> and possibly think about a different sigil

[15:40] <TimToady> but bare seems okayish

[15:40] <TimToady> given that \x in the sig is relatively unambiguous

[15:41] <jnthn> std: sub foo(\x) { x }

[15:41] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed parameter at /tmp/oPBLEHqe7s line 1:‚ê§------> [32msub foo([33m‚èè[31m\x) { x }[0m‚ê§    expecting any of:‚ê§  name‚ê§   new name to be defined‚ê§ parameter‚ê§      routine_def‚ê§    signature‚ê§Parse failed‚ê§FAILED 00:01 120m‚ê§¬ª

[15:41] <jnthn> Guessed so.

[15:41] <jnthn> nom: sub foo(\x) { x } # hopefully thinks the same ;)

[15:41] <p6eval> nom 642e78: OUTPUT¬´===SORRY!===‚ê§Malformed parameter at line 1, near "\\x) { x } "‚ê§¬ª

[15:41] <jnthn> woo :)

[15:41] <TimToady> and then my \x = expr becomes the "sigilless" style for people who want it

[15:42] <jnthn> std: my \x = 1

[15:42] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed my at /tmp/jAP1XnxaVi line 1:‚ê§------> [32mmy [33m‚èè[31m\x = 1[0m‚ê§    expecting any of:‚ê§ scoped declarator‚ê§      statement end‚ê§  statement list‚ê§Parse failed‚ê§FAILED 00:01 118m‚ê§¬ª

[15:42] <jnthn> *nod*

[15:42] *** pernatiy left
[15:42] <TimToady> the syntax is available :)

[15:42] <jnthn> Yeah.

[15:42] <jnthn> Figured it was.

[15:42] *** djanatyn is now known as djanlovesdonri

[15:43] <TimToady> the need is there for clarity, and it enables SSA/sigilless programming

[15:43] <jnthn> Will we outlaw \$x etc?

[15:43] <TimToady> what could possibly go wrong?

[15:43] <TimToady> probably

[15:43] <jnthn> OK, good.

[15:43] <jnthn> I don't have any immediate bad feeling about these.

[15:43] <TimToady> we'll need to get a bounce off of sorear++

[15:44] <jnthn> We may get some surprises at some point :)

[15:44] <TimToady> well, that's never happened before.... :P

[15:44] <jnthn> :P

[15:45] <TimToady> interestingly, the constant declarator is currently special casing the bareword, and we might switch to constant \pi = ...

[15:46] <TimToady> then it's not a special case, but an explicit no-sigil-wanted here marker

[15:46] <TimToady> introduce-a-term marker

[15:47] <TimToady> "Unrecognized bare word found in declaration, please use \ if you meant to declare a term"

[15:47] <TimToady> and \x very nearly is just sugar for term:<x>

[15:48] *** tokuhiro_ left
[15:53] <TimToady> in fact, \ is to the actual object what :: is its type, so my ::T \x = stuff; makes sense, and x.WHAT === T after the binding

[15:55] <masak> cute.

[15:55] <TimToady> I guess my only remaining question is whether \ is the best syntax for that

[15:57] <TimToady> I don't see a better alternative, offhand

[15:57] <moritz> it might cause some confusion if we continue to use prefix \ for captures

[15:58] * masak decommutes

[15:58] <moritz> or independently I'd propose to ban \@a

[15:58] <TimToady> and introduce $@a instead?

[15:58] <moritz> yes

[15:58] <moritz> or  item @a

[15:58] <moritz> or @a.item

[15:59] <moritz> but people seem to be rather surprised that \@a doesn't do what it does in p5

[15:59] <moritz> (though I'm not really sure what it is supposed to do in p6 :-)

[16:01] <huf> doesnt it turn @a into a non list-interpolating array-ish thingie?

[16:01] <huf> or am i confused or was that ages ago :D

[16:01] <TimToady> yes, but that's a handwavy way to say it

[16:02] <huf> oh :(

[16:02] <TimToady> if it simply itemizes, then $@a is clear, or @a.item

[16:02] <huf> and the reverse is @$a or $a.list ?

[16:02] <TimToady> .oO(funny that itemizes in English means almost exactly the *wrong* thing)

[16:03] <TimToady> itemize ~~ iterate in English

[16:03] <huf> hmm, that's only an obstacle if you speak english well enough to know :D

[16:03] <huf> (i didnt, before just now)

[16:04] <tadzik> hello #perl6

[16:05] <sjohnson> Ôºà„ÄÄÔΩÄ„Éº¬¥Ôºâ

[16:05] *** sayu left
[16:06] <TimToady> when you itemize your deductions, you split them out into separate entries

[16:06] <jnthn> o/ tadzik 

[16:06] <TimToady> it means more like "items-ize", make a bunch of items

[16:06] <huf> ennumerate?

[16:06] <huf> that sort of thing?

[16:06] <TimToady> yes, that's what itemize means in English, or at least is ‚âÖ

[16:07] <moritz> nom: for \(1, 2, 3) { .say }

[16:07] <p6eval> nom 642e78: OUTPUT¬´1 2 3‚ê§¬ª

[16:07] <moritz> that does seem to itemize successfully

[16:07] <moritz> but yes, $ would be clearer for that purpose

[16:07] <TimToady> not in the English sense :)

[16:07] <moritz> but in the p6 sense :-)

[16:07] <huf> would that mean \ is just unspace then?

[16:08] <moritz> no

[16:08] <TimToady> nom: for $(1,2,3) { .say }

[16:08] <p6eval> nom 642e78: OUTPUT¬´1 2 3‚ê§¬ª

[16:08] <TimToady> nom: say $(1,2,3) === \(1,2,3)

[16:08] <p6eval> nom 642e78: OUTPUT¬´Bool::False‚ê§¬ª

[16:08] <TimToady> ooh

[16:09] <TimToady> perl6: say $(1,2,3) === \(1,2,3)

[16:09] <moritz> are captures supposed to be value types?

[16:09] <p6eval> rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Bool::False‚ê§¬ª

[16:09] <p6eval> ..pugs b927740: OUTPUT¬´‚ê§¬ª

[16:09] <moritz> perl6: say (1, 2, 3) == (1, 2, 3)

[16:09] <p6eval> rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Bool::True‚ê§¬ª

[16:09] <p6eval> ..pugs b927740: OUTPUT¬´1‚ê§¬ª

[16:09] <moritz> perl6: say (1, 2, 3) === (1, 2, 3)

[16:09] <p6eval> pugs b927740: OUTPUT¬´1‚ê§¬ª

[16:09] <p6eval> ..rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Bool::False‚ê§¬ª

[16:09] <moritz> perl6: say $(1, 2, 3) === $(1, 2, 3)

[16:09] <p6eval> rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Bool::False‚ê§¬ª

[16:09] <p6eval> ..pugs b927740: OUTPUT¬´‚ê§¬ª

[16:09] <TimToady> er

[16:09] <TimToady> right

[16:09] <TimToady> perl6: say $(1,2,3) eqv \(1,2,3)

[16:09] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 758 (warn @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 165 (Mu.Str @ 9) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting‚Ä¶

[16:09] <p6eval> ..rakudo 642e78: OUTPUT¬´Bool::False‚ê§¬ª

[16:09] <p6eval> ..pugs b927740: OUTPUT¬´‚ê§¬ª

[16:10] <moritz> nom: say (\(1, 2, 3)).WHAT

[16:10] <p6eval> nom 642e78: OUTPUT¬´Capture()‚ê§¬ª

[16:10] <TimToady> perl6: say $(1,2,3).WHAT, \(1,2,3).WHAT

[16:10] <p6eval> pugs b927740: OUTPUT¬´Array::ConstCaptSub {c_feeds = fromList [MkFeed {f_positionals = fromList [IFinite 1,IFinite 2,IFinite 3], f_nameds = []}]}‚ê§¬ª

[16:10] <p6eval> ..rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Parcel()Capture()‚ê§¬ª

[16:10] *** Sarten-X left
[16:12] <TimToady> perl6: my @x = 1,2,3; say (\@x).WHAT

[16:12] <p6eval> rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Capture()‚ê§¬ª

[16:12] <p6eval> ..pugs b927740: OUTPUT¬´Array‚ê§¬ª

[16:12] <moritz> perl6: say $(1, 2) eqv (1, 2)

[16:12] <p6eval> rakudo 642e78, niecza v10-215-gec2d94f: OUTPUT¬´Bool::True‚ê§¬ª

[16:12] <p6eval> ..pugs b927740: OUTPUT¬´1‚ê§¬ª

[16:14] <TimToady> biab &

[16:17] *** simcop2387 left
[16:17] *** Sarten-X joined
[16:17] *** simcop2387 joined
[16:25] *** daniel__ joined
[16:44] *** daniel__ left
[16:46] <[Coke]> Juerd++

[16:47] <Woodi> ¬µ ùÑû ùÖ† ‚ù§ ‚úì ‚úò ‚úà ‚úâ ‚úÑ ‚àû ‚Ä† œÄ looks usefull :) 

[16:49] <sjohnson> Juerd == perl master

[16:50] *** GlitchMr left
[16:50] <Juerd> Nonsense :)

[16:57] <[Coke]> skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?

[16:58] <[Coke]> (seeing this on some tests that are currently skipped for rakudo)

[17:01] *** cognominal_ left
[17:01] *** cognominal_ joined
[17:01] *** kaare_ joined
[17:03] *** Chillance joined
[17:03] <awwaiid> nome: $joe's = 'fish supply' ; say $joe's

[17:04] <awwaiid> nom: $joe's = 'fish supply' ; say $joe's

[17:04] <p6eval> nom 642e78: OUTPUT¬´===SORRY!===‚ê§Symbol '$joe's' not predeclared in <anonymous> (/tmp/Y1wE7juBFq:1)‚ê§¬ª

[17:04] <awwaiid> nom: my $joe's = 'fish supply' ; say $joe's

[17:04] <p6eval> nom 642e78: OUTPUT¬´fish supply‚ê§¬ª

[17:04] *** Sarten-X left
[17:04] <awwaiid> I do use ' as "prime" in ocaml a lot, like x', x''

[17:05] <TimToady> .u  π

[17:05] <phenny> U+02B9 MODIFIER LETTER PRIME ( π)

[17:05] <TimToady> you can use that one

[17:06] <awwaiid> hm!

[17:06] <TimToady> because it parses as a letter

[17:06] * awwaiid adds a  π to his keyboard

[17:07] <[Coke]> any recent changes to skip handling in fudge?

[17:07] <[Coke]> (I don't see anything obvious in the commit history)

[17:09] <moritz> [Coke]: not that I know of

[17:10] <moritz> when my fudges don't work, I've usually misspelled 'rakudo' or 'niecza', or added a semicolon after the fudge message

[17:10] <[Coke]> moritz: try to run S05-mass/rx.t (fudgeD)

[17:10] <[Coke]> #?rakudo skip ':: NYI'

[17:10] <[Coke]> (that's the line that's causing the argument reversal)

[17:11] <[Coke]> (comes out as skip (1,':: NYI'); # <original test>

[17:11] <[Coke]> and then rakudo's lib/Test.pm squawks.

[17:11] <moritz> it doesn't here

[17:12] <moritz> stale copy of roast?

[17:12] <[Coke]> I swear I updated recently. Checking...

[17:13] <[Coke]> urk? t/spec/ says I've a remote rakudo/rakudo

[17:13] <moritz> woah.

[17:13] <moritz> [Coke]: ah did you run a 'make release' in the rakudo dir?

[17:13] <[Coke]> moritz: maybe a gazillion years ago.

[17:14] <moritz> [Coke]: that removes t/spec/, and replaces it with a copy

[17:14] <[Coke]> This might be the checkout I cut the one release I did from.

[17:14] <moritz> then 'git remote' will look into ..

[17:14] <moritz> and then in ../..

[17:14] <moritz> just check if t/spec/ has a .git dir

[17:14] <[Coke]> there we go. much better.

[17:14] <[Coke]> ignore all that skip stuff for now. ;)

[17:15] * moritz hates that behavior of 'make release'

[17:15] *** am0c left
[17:16] *** MayDaniel_ left
[17:16] <[Coke]> nom: say 4&9&20

[17:16] <p6eval> nom 642e78: OUTPUT¬´all(4, 9, 20)‚ê§¬ª

[17:17] <[Coke]> (oh right)

[17:17] <moritz> nom: say 4 +& 9 +& 20

[17:17] <p6eval> nom 642e78: OUTPUT¬´0‚ê§¬ª

[17:17] *** SHODAN joined
[17:22] *** Sarten-X joined
[17:24] <sorear> good * #perl6

[17:26] <moritz> \o sorear 

[17:26] <shachaf> Wait, wasn't it * 14 hours ago?

[17:26] <sorear> TimToady: I do not have an immediate complaint with sub (\x) or my \x

[17:26] <moritz> shachaf: * is polymorphic

[17:27] *** zby_home joined
[17:35] *** daxim left
[17:35] *** xlq joined
[17:36] *** diegoviola joined
[17:36] <diegoviola> hi

[17:37] <diegoviola> can perl6 be used to develop apps already? i understand the language is still on developmenvt?

[17:37] <[Coke]> Yes, and yes.

[17:37] <diegoviola> development*

[17:37] <diegoviola> ok

[17:37] <sjn> sure, you can start developing :)

[17:37] <[Coke]> early adopters welcome. even now, after a decade.

[17:39] * [Coke] finds 5 more tests in spectest.data that are runnable.

[17:39] <diegoviola> thanks

[17:42] <masak> diegoviola: I run my blog with Perl 6.

[17:42] <masak> (and have been for over a year now)

[17:42] <diegoviola> nice

[17:43] <masak> diegoviola: besides that, I've helped write a wiki engine, a grammar engine, a compiler, and a sudoku-ish problem solver in Perl 6.

[17:43] <diegoviola> cool

[17:43] <masak> diegoviola: I'm toying with the idea of writing an editor. several people here are writing games.

[17:46] <diegoviola> nice

[17:46] <diegoviola> i've been working with databases and web apps, i currently know ruby but i want to learn other languages, i looked into perl5+moose and i like it, but perl6 seems to have better OO support, which interests me more

[17:47] <jnthn> Perl 6 OO is pretty nice. And there's a flexible meta-model beneath it all too, so you can make it even nicer :)

[17:48] <diegoviola> interesting

[17:48] <[Coke]> jnthn: I had to re-open 2 RTs just now due to nom regressions.

[17:48] <[Coke]> at least one of them was roles related.

[17:48] <masak> diegoviola: Moose is very nice. but I believe that Perl 6, in the long run, is nicer.

[17:49] <masak> diegoviola: there are also other worthy improvements 'sides OO compared to Perl 5.

[17:49] <jnthn> [Coke]: RT #s appreciated, if you have them to hand.

[17:50] <[Coke]> 72856 and 69254

[17:50] <diegoviola> masak: nice

[17:50] <[Coke]> "regressed" may not entirely be accurate, but they are failing now. ;)

[17:50] <jnthn> Thanks. I'll try and look this weekend. I kinda want to work on bigint and compact struct and other stuff this evening.

[17:51] <[Coke]> no worries.

[17:54] <diegoviola> i tried to look at python as well but their philosophy seems to clash with what i like (TMTOWTDI)

[17:56] <sjohnson> i like its batteries included thing.

[17:57] <diakopter> jnthn: compact struct or compact arrays

[17:57] <jnthn> diakopter: The first, but it's groundwork for the latter.

[17:57] <sorear> diegoviola: the main thing you need to realize is that current implementations of Perl 6 are, compared to Perl 5, slower to run, much slower to parse, and use considerably more memory

[17:58] <cognominal_> diegovidla: with Perl6, if there is still no prebuilt way to do it you can probably invent one  :)

[17:59] <diakopter> it can be somewhat strongly argued that a full p6 impl will always have those characteristics except on the most optimizable programs

[17:59] <diegoviola> sorear: interesting

[17:59] <diegoviola> cognominal_: ok

[18:01] <cognominal_> and in an Unixish way, there is a snytactically cheap (in term of typing code) default for most things.

[18:01] <sorear> diakopter: imo, a large part of the point of Perl 6 is providing things like static typing so that you can make your hot spots optimizable

[18:01] <sorear> diakopter: and I think there's large room for improvement in parsing speed, fwiw

[18:02] <[Coke]> arg. I wish "make spectest" would use the same git prefix as I used for rakudo. or ask me, or let me config it, so I don't have to change the remotes after the fact.

[18:02] <diakopter> sorear: oh.. 

[18:02] <flussence> [Coke]: check out a specific commit in t/spec and the automatic git-pull won't work, but it'll keep going

[18:02] *** GlitchMr joined
[18:03] <sorear> o/ GlitchMr

[18:03] <GlitchMr> Hi

[18:03] <masak> diegoviola: what sorear says is important. Perl 5 is more of a problem-solver right now. sometimes Perl 6 implementations themselves get in the way of solving your problem. some of us think it's still worth it because the language is kinda awesome. :)

[18:03] <masak> GlitchMr: ho

[18:03] <diegoviola> masak: i see, thanks for your advice

[18:03] <diegoviola> sorear: thanks for your advice too

[18:04] * flussence still hasn't got Text::Wrap working in any current impl.

[18:04] <[Coke]> flussence: ? That doesn't help my situation, I don't think.

[18:04] <moritz> [Coke]: what's your problem?

[18:04] <sorear> what I said in a nutshell: if you're debating whether to use Perl or C, Perl 6 isn't for you

[18:04] <flussence> [Coke]: am I understanding right?

[18:04] * moritz doesn#t know what "git prefix" means

[18:04] <sorear> (yet)

[18:04] <flussence> .oO(probably not...)

[18:05] <diegoviola> i read a lot that python is more suited to large application development such as financial applications, would perl+moose be just as good or better for that scenario?

[18:05] <moritz> I don't think python has any inherent advantage for large applications over perl 5

[18:05] <dalek> roast: c52f22b | coke++ | S14-roles/composition.t:

[18:05] <dalek> roast: rakudo fudging

[18:05] <dalek> roast: review: https://github.com/perl6/roast/commit/c52f22b474

[18:06] <moritz> [Coke]: fwiw my niecza/t/spec/ is a symlink to rakudo/t/spec/, that way the two copies never go out of sync 

[18:06] <dalek> rakudo: b2cd763 | coke++ | t/spectest.data:

[18:06] <dalek> rakudo: track failures, run (fudged) tests

[18:06] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/b2cd763206

[18:07] <[Coke]> moritz: I am a committer. I type "make spectest". I get a readonly clone of roast.

[18:07] <[Coke]> I then have to perform git surgery to push. 

[18:07] <sorear> diegoviola: the first real p5 Application I worked on was a 30,000 line perl+moose app, and it worked out pretty well.  Does that count?

[18:07] <flussence> oh, *that* problem... yeah, I dunno either :(

[18:08] <[Coke]> it comes up just frequently enough to annoy me and just infrequently enough for me to just complain instead of fixing it. ;)

[18:08] *** wolfman2000 joined
[18:09] * [Coke] hasn't run spectest in a while. lot of failures.

[18:09] * moritz thinks he knows how to fix it

[18:09] <flussence> I usually just have a good copy separate from t/spec and copy any local changes to that one...

[18:10] <diegoviola> sorear: sure :)

[18:10] <moritz> I usually add the line

[18:10] <moritz> pushurl = [email@hidden.address]
[18:10] <diegoviola> thanks

[18:10] <moritz> to the [remote "origin"] section of .git/config

[18:10] <flussence> ooh, clever

[18:10] <moritz> now I just need to automate 'make spectest' to do that when it fetches a new copy

[18:11] *** Trashlord left
[18:11] <moritz> now how do I do that with git config?

[18:11] <moritz> git config remote=origin.pushurl doesn't fetch it

[18:11] <[Coke]> moritz++

[18:12] <flussence> git config remote.origin.pushurl=xyz?

[18:12] <flussence> might be a space instead of =, can't remember

[18:12] <moritz> flussence: that seems to work, thanks

[18:12] <moritz> yes, space for supplying the value

[18:13] <flussence> git-config is similar enough and different enough from sysctl that I get it wrong every time, for both :)

[18:14] <[Coke]> anyone run a rakudo spectest recently?

[18:14] * moritz tests a patch

[18:14] <moritz> [Coke]: yes, a few hours ago. All PASS

[18:17] <[Coke]> odd. I'm getting failures all over the place.

[18:17] <[Coke]> (on feather)

[18:18] *** benabik left
[18:18] <moritz> is icu installed?

[18:19] *** colomon left
[18:21] <diegoviola> what is rakudo?

[18:21] <moritz> diegoviola: a Perl 6 compiler

[18:21] <diegoviola> rakudo runs on parrot?

[18:22] <moritz> japhb: are you still working on speeding up RANGEPOS?

[18:22] <moritz> diegoviola: yes

[18:22] <diegoviola> nice

[18:22] <diegoviola> does rakudo or parrot have a JIT?

[18:22] <moritz> no

[18:23] <moritz> parrot is planning a huge refactor that should allow an efficient JIT

[18:23] <moritz> but its result is nowhere near in sight

[18:23] <diegoviola> i see

[18:24] <flussence> perl6: my $a = now; 1..1_000_000; say now - $a;

[18:24] <p6eval> rakudo 642e78: OUTPUT¬´0.0153431133006891‚ê§¬ª

[18:24] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&now"‚ê§    at /tmp/DKj4XOjD82 line 1, column 4-12‚ê§¬ª

[18:24] <p6eval> ..niecza v10-215-gec2d94f: OUTPUT¬´‚ê§Unhandled Exception: Cannot use value like Instant as a number‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 187 (Any.Numeric @ 4) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/deSyTw18rY line 1 (mainline @‚Ä¶

[18:24] <diegoviola> i see lots of modern VM these days want to have a JIT and they want to implement their own VM in their own native language, like pypy or rubinius, etc

[18:25] * Woodi wonders how to write code that will survive decades....

[18:25] <tadzik> write good code

[18:25] <moritz> we'd be happy if parrot provided us a good JIT, and we wouldn't need to write our own JIT

[18:25] <flussence> just don't assume $year.chars == 4 and you'll be fine :)

[18:26] <Woodi> I wonder about infrastructure problem rather :)

[18:26] <moritz> Woodi: write good code, so that people will maintain it

[18:26] <diegoviola> is parrot and rakudo written in perl or C?

[18:27] *** risou is now known as risou_awy

[18:27] <moritz> diegoviola: parrot is written in C and custom DSLs

[18:27] <moritz> diegoviola: rakudo is mostly written in Perl 6

[18:27] <diegoviola> nice

[18:27] <diegoviola> cool :D

[18:27] <flussence> sorear: "now - $instant" should've worked above, according to S02:1383

[18:27] <moritz> (it also has some C parts for speed)

[18:28] <Woodi> diegoviola: why you want to learn another language ?

[18:29] * flussence heads for the New Issue button...

[18:30] <diegoviola> Woodi: i find languages interesting, i was programming in php a few years ago, then i decided to learn Ruby and it teach me some things (like object-oriented programming, etc), I realized that Perl inspired Ruby in some ways so now I would like to learn perl :)

[18:31] <diegoviola> Woodi: other than curiosity I don't have other reasons...

[18:31] <flussence> wait, how does modulus work on Instants?

[18:31] <diegoviola> Woodi: I remember when I was working with some projects and I had the ruby interpreter crash on me a few times... I'm looking to learn a good language with a stable interpreter as well

[18:32] <moritz> diegoviola: curiosity is a very fine reason

[18:32] <ashleydev> how would you output SSA constants in an interpolated "" string?

[18:32] *** Trashlord joined
[18:32] <Woodi> diegoviola: then advice gor you: stay and listen on this channel :) you will be immediatly exposed to object languages, functional languages, historical languages, languages development, language release, compiler building and more :)

[18:32] <cognominal_> diegovicla:  stability is not the forte of Perl 6 implementations at this point

[18:32] <flussence> hm, niecza doesn't have Durations, that'd explain why Instant arithmetic doesn't work...

[18:33] <diegoviola> Woodi: great, thank you

[18:33] <diegoviola> moritz: :)

[18:34] <moritz> seen japhb 

[18:34] <aloha> japhb was last seen in #perl6 10 hours 11 mins ago saying "sleep &".

[18:35] *** pnu left
[18:35] <Woodi> g* #perl6

[18:36] *** pnu joined
[18:37] <dalek> rakudo/nom: 087a68e | moritz++ | tools/build/Makefile.in:

[18:37] <dalek> rakudo/nom: [build] when cloning roast, set it up for committing too

[18:37] <dalek> rakudo/nom: 

[18:37] <dalek> rakudo/nom: [Coke]++ for complaining; I too found the old

[18:37] <dalek> rakudo/nom: behavior inconvenient, but never enough to take action.

[18:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/087a68e257

[18:38] <cognominal_> jnthn, what the deal with the fetch_method? Currently it is always set to null in set_container_spec().

[18:40] <sorear> diegoviola: Parrot used to have a JIT but it turned out it was actually making Parrot _slower_ so they removed it

[18:41] <moritz> well, there were certain conditions where it did make parrot faster

[18:41] <moritz> but it was limited to i386, and a nightmare to maintain

[18:41] <diegoviola> sorear: i see

[18:44] <[Coke]> moritz++

[18:44] <diegoviola> perl6 looks very interesting, i like how the vm is separate from the interpreter

[18:44] *** mishin left
[18:45] <jnthn> cognominal_: Support for (not yet available) custom scalar container types.

[18:45] <diegoviola> parrot and rakudo

[18:45] <diegoviola> and how they work together

[18:46] <sorear> diegoviola: your use of "the" is incorrect

[18:46] <sorear> rakudo is jnthn/pmichaud's Perl 6 interpreter; it's far from the only one

[18:46] <cognominal_> jnthn, what kind of custom scalar container type?

[18:47] <diegoviola> sorear: oh, there are many perl6 compilers?

[18:47] <[Coke]> moritz: if it's ICU related, i still shouldn't get any failures, ne? it should be skipping things that rely on ICU.

[18:48] <[Coke]> diegoviola: check out perl6.org/compilers

[18:48] <jnthn> cognominal_: Basically, the Perl 6 way to do the kind of things tie does in Perl 5.

[18:48] <diegoviola> wow nice

[18:49] <diegoviola> is there a perl6 compiler that runs on the JVM?

[18:49] <diegoviola> i see there is one for CLR

[18:49] <cognominal_> jnthn, thx

[18:50] <diegoviola> sorear: thanks for correcting me :)

[18:50] <sorear> well I kindof have an interest

[18:50] <sorear> I'm the guy behind t he #2 compiler :)

[18:51] <masak> perl6: my @a = [5, 1], [4, 4]; say @a.map({ .[0] ** 3 + .[1] ** 3}).perl; say @a.min(:by({ .[0] ** 3 + .[1] ** 3})).perl; say @a.sort(:by({ .[0] ** 3 + .[1] ** 3})).perl

[18:51] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´(126, 128).list‚ê§‚ê§Unhandled Exception: Unable to resolve method min in class Array‚ê§  at /tmp/UI2UU0EJwb line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2208 (module-CORE @ 60) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2209 (main‚Ä¶

[18:51] <p6eval> ..rakudo 642e78: OUTPUT¬´(126, 128).list‚ê§[4, 4]‚ê§([4, 4], [5, 1])‚ê§¬ª

[18:51] <p6eval> ..pugs b927740: OUTPUT¬´(126/1, 128/1)‚ê§pugs: Named argument found where no matched parameter expected: (by,Ann (Pos (MkPos "/tmp/O9OMZjejhi" 1 83 1 107)) (Syn "sub" [Val (VCode (MkCode {isMulti = False, subName = "<anon>", subType = SubBlock, subOuterPads = [PRuntime {pr_pad = MkPad (padTo‚Ä¶

[18:51] <dalek> perl6.org: a7a7c0d | diakopter++ | source/compilers/index.html:

[18:51] <dalek> perl6.org: mark sprixel as old

[18:51] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/a7a7c0d467

[18:51] <cognominal_> jnthn, I suppose this means to be able to transparently handle foreign vtable

[18:51] <masak> niecza: my @a = [5, 1], [4, 4]; say @a.map({ .[0] ** 3 + .[1] ** 3}).perl; say @a.sort(:by({ .[0] ** 3 + .[1] ** 3})).perl

[18:51] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´(126, 128).list‚ê§‚ê§Unhandled Exception: Excess arguments to List.sort, unused named by‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (List.sort @ 0) ‚ê§  at /tmp/Pjcbbb8PX8 line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2208 (module-‚Ä¶

[18:51] <masak> meh.

[18:51] <sorear> drop the :by

[18:51] <cognominal_> *vtables

[18:52] <masak> right, but then it doesn't mean the same...

[18:52] <sorear> $by is a positional argument in the method form

[18:52] <diegoviola> sorear: cool, you made a compiler that runs in Mono/CLR?

[18:52] <masak> oh!

[18:52] <masak> sorear++

[18:52] <sorear> it's only a named argument for the listop iirc

[18:52] <sorear> diegoviola: yes

[18:52] <masak> sorear: even so, a named argument should bind to a positional parameter...

[18:52] <diegoviola> sorear: interesting

[18:52] <japhb> moritz, [re: RANGEPOS] I had to put it down for the night last night, and have $day_job today (and thus have not backlogged, just noticed you highlighting me).  I can work on it later tonight, or you can commit whatever you've come up with.  Mostly I was using it as a learning experience, so no worries.

[18:52] <sorear> masak: I thought we got rid of that

[18:52] <diegoviola> sorear: is it faster than running it on parrot?

[18:52] <sorear> masak: didn't you write a manifesto or something? :)

[18:53] <sorear> diegoviola: yes, but the margin is a lot smaller than it used to be

[18:53] <jnthn> sorear: In Niecza, does Int always use BigInteger underneath, or does it "auto-upgrade" from a normal int?

[18:53] <sorear> jnthn: it auto-upgrades, but tries to hide it from the user

[18:54] <jnthn> sorear: It's still of type Int, though?

[18:54] <jnthn> e.g. it's just different on the inside?

[18:54] <diegoviola> sorear: nice

[18:55] <jnthn> niecza: say 1111111111111111111111111111111111111111111111111111111111111111111111111111.WHAT

[18:55] <sorear> jnthn: yes

[18:56] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´Int()‚ê§¬ª

[18:56] <jnthn> ok

[18:56] <jnthn> ...er, p6eval? :)

[18:56] <jnthn> oh, grr, some weird lag going on.

[18:57] <[Coke]> niecza: say 11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111

[18:57] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111‚Ä¶

[18:57] <[Coke]> O_o

[18:57] <flussence> niecza: my $n = ('1' x 300).eval; say $n.WHAT; say $n.chars;

[18:57] <jnthn> It's BIG. ;)

[18:57] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´‚ê§Unhandled Exception: Unable to resolve method eval in class Str‚ê§  at /tmp/NyR1H9OJZA line 1 (mainline @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2208 (module-CORE @ 60) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2209 (mainline @ 1) ‚ê§  at <‚Ä¶

[18:57] <masak> sorear: :)

[18:57] <flussence> nuts.

[18:57] <flussence> niecza: my $n = eval('1' x 300); say $n.WHAT; say $n.chars;

[18:57] <sorear> jnthn: internally I have an overloaded method Variable MakeInt(long value) { ... }; Variable MakeInt(int value) { ... }; Variable MakeInt(BigInteger value) { ... } which handles {up,down}grading in all cases

[18:57] <p6eval> niecza v10-215-gec2d94f: OUTPUT¬´Int()‚ê§300‚ê§¬ª

[18:58] <jnthn> sorear: OK.

[18:58] <jnthn> sorear: I'm wondering what performance hit I get from Int always being BigInteger, especially since I now have reasonable "int" support for the other thing.

[18:58] <jnthn> ...and that I can do so without any extra GC overhead.

[18:59] <jnthn> Guess the only way is to try it. :)

[18:59] <sorear> in particular arithmetic on 'int' is performed in 64-bit precision, not BigInteger (should be especially not-slow on amd64 :D )

[18:59] <jnthn> *nod*

[19:05] <dalek> rakudo/nom: 1be6534 | moritz++ | src/core/Str.pm:

[19:05] <dalek> rakudo/nom: Speed up Str.succ and .pred

[19:05] <dalek> rakudo/nom: 

[19:05] <dalek> rakudo/nom: ... by using natively typed variables, and avoiding calls

[19:05] <dalek> rakudo/nom: in favor of nqp:: opcodes

[19:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1be65342e6

[19:10] * jnthn is happy to see the natives being put to good use :)

[19:11] <diakopter> that's what the invaders said

[19:11] <jnthn> :P

[19:14] <cognominal_> diakopter++

[19:15] *** nvteighen joined
[19:20] *** nvteighen left
[19:27] *** soh_cah_toa joined
[19:30] * sorear looks into the " bug

[19:30] <sorear> o/ soh_cah_toa

[19:30] <soh_cah_toa> sorear: howdy

[19:32] <sorear> hrm, seems I had it quite wrong

[19:33] <sorear> it wasn't actually an ltm issue, it's a bug in niecza's nibbler

[19:36] *** zby_home left
[19:37] *** zby_home__ joined
[19:39] <sorear> I should have fixed this weeks ago, it's much easier than I thought and not at all a bootstrap problem

[19:40] * diakopter was doing stupid things with nested eval

[20:03] *** MayDaniel joined
[20:03] <dalek> niecza: e42a15a | sorear++ | src/niecza:

[20:03] <dalek> niecza: Fix crash with end-of-input while parsing a string

[20:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e42a15aa9c

[20:03] <dalek> niecza: 82c7878 | sorear++ | lib/Kernel.cs:

[20:03] <dalek> niecza: Add NIECZA_KEEP_IL for bootstrap project

[20:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/82c7878408

[20:05] * moritz -> sleep

[20:05] <masak> 'night, moritz. dream of sleep :)

[20:08] *** GlitchMr left
[20:10] *** dual joined
[20:10] *** wolfman2_ joined
[20:13] *** wolfman2000 left
[20:16] *** bluescreen10 left
[20:20] *** On42 joined
[20:24] *** SHODAN left
[20:25] *** SHODAN joined
[20:31] *** bluescreen10 joined
[20:33] *** wolfman2_ left
[20:46] *** colomon joined
[20:53] *** donri left
[20:57] *** sirmacik left
[20:58] *** sirmacik joined
[21:01] *** benabik joined
[21:04] <On42> /whois UTF-8

[21:04] <sjohnson> On42: our friend

[21:04] <On42> :)

[21:05] *** zby_home__ left
[21:09] *** djanlovesdonri is now known as djanatyn

[21:14] <sorear> On42: are you new here?

[21:16] *** fsergot left
[21:18] * On42 is ancient as Perl

[21:18] <sorear> heh.

[21:18] <sorear> actually, I'm three years younger than Perl...

[21:18] <On42> lol

[21:19] <sorear> you're welcome to #perl6 anyway.

[21:19] <im2ee> Good night! o/

[21:19] *** im2ee left
[21:19] <sorear> phenny: "wychodzi"?

[21:19] <phenny> sorear: "leaves" (pl to en, translate.google.com)

[21:19] * masak almost mis-tabs imarcusthis again

[21:19] <On42> Been on irc since its first server, cannot recall when it was. Then was on another #perl before this channel was created on this server. dalnet or efnet cannot recall

[21:19] <On42> thanks

[21:20] * sorear wonders if On42 knows TimToady

[21:20] <masak> On42: what do you think of Perl, of Perl 5, and of Perl 6? just curious.

[21:20] <slavik1> you mean splitnet?

[21:20] <On42> Anyone here using Perl Translate V.2?  I have some short and fast function for it - its missing on CPAN

[21:21] <On42> slavik: were they all splittnets? ;-)

[21:21] <On42> I think it was dreamnet the first server- we were only few hundreds users, then eunet and efnet came later.

[21:21] <slavik1> On42: I know that back in my youngin year (I am 26 now) dalnet was known for splitting a lot

[21:22] <On42> Google Translate v2, sorry for the mistake

[21:22] <On42> Slavik: splitting was fun :) I was in my twentees back then, it was used for irc wars LOL  nick collides kills etc

[21:23] <slavik1> oh man

[21:23] <On42> ops wars... when the splits were joined

[21:23] <slavik1> sounds like a dangerous place :)

[21:23] <On42> it was fun :)

[21:24] <slavik1> On42: what year was this? gotta ask :)

[21:24] <On42> over 12 years ago...

[21:24] <On42> 15 years ago at least :)

[21:25] <sorear> phenny: "li≈õcie"

[21:25] <sorear> phenny: "li≈õcie"?

[21:25] <phenny> sorear: "list" (pl to en, translate.google.com)

[21:25] <On42> I used phoenix back then as irc client, mirc and bitchx came later

[21:25] <sorear> phenny: "li≈õci"?

[21:25] <phenny> sorear: The pl to en translation failed, sorry!

[21:25] <sorear> phenny: "li≈õƒá"?

[21:26] <phenny> sorear: The pl to en translation failed, sorry!

[21:26] <On42>  <phenny> you need help with Google Translate API?

[21:26] <sorear> On42: ?

[21:27] <On42> my $json = decode_json($res->decoded_content);   will code you utf-8

[21:27] <sorear> On42: <nick> Text is freenode's convention for quoting someone, and it's bad form here to use it in any other way

[21:27] <On42> Ah....

[21:28] <On42> Thought you were struggelig with the v2 - there is still no API examples for Perl there - very tragic that Google forgot us :(

[21:33] *** xlq left
[21:36] <sorear> On42: I didn't write phenny

[21:36] <sorear> On42: I think it's written in Python anyway

[21:41] * colomon just tried to start a C++ function definition with "my $"... doh!

[21:41] <benabik> colomon: How'd that work out for you?

[21:41] <sorear> o/ colomon

[21:41] <colomon> \o

[21:42] <colomon> benabik: well, I didn't hit myself in the head hard enough to hurt me

[21:42] <sorear> why would anyone start a function definition with $ anyway? :)

[21:44] *** benabik left
[21:45] *** japhb_ joined
[21:47] <colomon> sorear: what benefits is the (now-merged! \o/) serialization stuff supposed to bring?  (btw, my Gtk stuff appears to work fine with the latest Niecza.)

[21:48] <sorear> colomon: actually working BEGIN

[21:48] <colomon> ooooo

[21:52] * colomon just got a double-yolked egg while cooking dinner

[21:54] *** SHODAN left
[21:56] <masak> 'night, #perl6

[21:56] <japhb_> night

[21:56] <sorear> bye

[21:56] *** mj41 left
[21:59] *** bluescreen100 joined
[22:03] <dalek> nqp/bigint: d548c21 | jnthn++ | / (126 files):

[22:03] <dalek> nqp/bigint: Bring in libtommath bigint library. Build it and link it all into an nqp_bigint.ops file (which is just a stub at the moment).

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/d548c21f93

[22:03] <dalek> nqp/bigint: bcf7a04 | jnthn++ | src/6model/sixmodelobject.h:

[22:03] <dalek> nqp/bigint: Extend the REPR API a little in preparation for supporting inlining of more complex types in objects. Most immediately this is for bigint support, but it's also the basis for compact structs, and later compact arrays and nested structs in NCI.

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/bcf7a04680

[22:03] <dalek> nqp/bigint: 65f926d | jnthn++ | src/6model/reprs/P6int.c:

[22:03] <dalek> nqp/bigint: Fix copy-pasto in an error.

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/65f926d40d

[22:03] <dalek> nqp/bigint: 22f49c1 | jnthn++ | src/6model/ (2 files):

[22:03] <dalek> nqp/bigint: A little infrastructure for dynamically registering 6model representations outside of the 6model core.

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/22f49c187f

[22:03] <dalek> nqp/bigint: fcd90db | jnthn++ | / (4 files):

[22:03] <dalek> nqp/bigint: First cut of a P6bigint REPR, plus bigint library initialization code. With this, we can declare a type with repr('bigint') and have it box/unbox native ints; it's allocating the libtommath big integer under the hood.

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/fcd90db99c

[22:03] <dalek> nqp/bigint: 9491f38 | jnthn++ | tools/build/Makefile.in:

[22:03] <dalek> nqp/bigint: Make sure bigint ops file is copied to dynext dir.

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/9491f38b8e

[22:03] <dalek> nqp/bigint: 2dcba38 | jnthn++ | src/ops/nqp_bigint.ops:

[22:03] <dalek> nqp/bigint: Add a few ops to check out some basic arithmetic functions; seems to work.

[22:03] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/2dcba38df3

[22:04] <colomon> oh my!

[22:05] *** swarles joined
[22:06] <jnthn> Some way to go yet, but good to have got it started. :)

[22:06] <jnthn> Plus this'll make me deal with the missing bits in 6model to deal with compact struct stuff.

[22:07] <[Coke]> there's a v2 translate API? last I heard they were going to sunset the xlate API

[22:08] <[Coke]> jnthn++ #unstoppable.

[22:08] *** jdv79 left
[22:08] <jnthn> [Coke]: Don't tempt fate :P

[22:08] *** jdv79 joined
[22:09] *** kaare_ left
[22:13] *** packetknife joined
[22:18] <japhb_> nom: sub foo() { say "CALLED"; return (42,) }; sub bar($q) { $q }; say bar(|foo());

[22:18] <p6eval> nom 1be653: OUTPUT¬´CALLED‚ê§CALLED‚ê§42‚ê§¬ª

[22:18] *** bluescreen100 left
[22:18] *** bluescreen10 left
[22:19] <japhb_> Why is foo() being called twice?

[22:21] <jnthn> mmm

[22:22] <jnthn> ...braino by person who implemented |?

[22:22] *** SHODAN joined
[22:22] <dukeleto> jnthn: are you planning on using parrot-gmp for bigints in nqp?

[22:23] <dukeleto> jnthn: https://github.com/bubaflub/parrot-gmp

[22:24] <diakopter> jnthn: what license was libtommath

[22:25] *** packetknife left
[22:26] <japhb_> diakopter, dual: public domain and DWTFYWT

[22:26] <japhb_> jnthn, heh

[22:26] <sorear> nom: sub foo() { return rand > 0.5 ?? \(1, :a(2)) !! \(3, :a(4)) }; sub bar(|$x) { say $x.perl }; bar(|foo);

[22:26] <p6eval> nom 1be653: OUTPUT¬´Capture.new()‚ê§¬ª

[22:26] <sorear> nom: sub foo() { return rand > 0.5 ?? \(1, :a(2)) !! \(3, :a(4)) }; sub bar($x, :$a) { say $x; say $a }; bar(|foo);

[22:26] <p6eval> nom 1be653: OUTPUT¬´Too many positional parameters passed; got 2 but expected 1‚ê§  in sub bar at /tmp/wrGXtReXgm:1‚ê§  in block <anon> at /tmp/wrGXtReXgm:1‚ê§  in <anon> at /tmp/wrGXtReXgm:1‚ê§¬ª

[22:27] <sorear> nom: sub quux(|$a) {$a}; sub foo() { return rand > 0.5 ?? quux(1, :a(2)) !! quux(3, :a(4)) }; sub bar($x, :$a) { say $x; say $a }; bar(|foo);

[22:27] <p6eval> nom 1be653: OUTPUT¬´3‚ê§4‚ê§¬ª

[22:27] <sorear> nom: sub quux(|$a) {$a}; sub foo() { return rand > 0.5 ?? quux(1, :a(2)) !! quux(3, :a(4)) }; sub bar($x, :$a) { say $x; say $a }; bar(|foo);

[22:27] <p6eval> nom 1be653: OUTPUT¬´3‚ê§4‚ê§¬ª

[22:27] <sorear> nom: sub quux(|$a) {$a}; sub foo() { return rand > 0.5 ?? quux(1, :a(2)) !! quux(3, :a(4)) }; sub bar($x, :$a) { say $x; say $a }; bar(|foo);

[22:27] <p6eval> nom 1be653: OUTPUT¬´1‚ê§2‚ê§¬ª

[22:27] <sorear> nom: sub quux(|$a) {$a}; sub foo() { return rand > 0.5 ?? quux(1, :a(2)) !! quux(3, :a(4)) }; sub bar($x, :$a) { say $x; say $a }; bar(|foo);

[22:27] <p6eval> nom 1be653: OUTPUT¬´3‚ê§2‚ê§¬ª

[22:27] <sorear> as I thought

[22:28] <jnthn> japhb_: got patch for it locally

[22:28] <japhb_> jnthn, excellent, thanks!

[22:29] <jnthn> japhb_: Just gonna spectest then will push it.

[22:29] <diakopter> niecza: "

[22:29] * japhb_ wonders if anything will get measurably faster with the fix in place.  :-)

[22:29] <p6eval> niecza v10-217-g82c7878: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Bogus statement at /tmp/aUUFWx_iiW line 1:‚ê§------> [32m<BOL>[33m‚èè[31m"[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[22:29] <jnthn> diakopter: What japhb_ said. Basically, we're free to bundle it.

[22:29] <jnthn> dukeleto: No

[22:30] <jnthn> dukeleto: I wanted something that didn't require people to deal with dependencies, and I wanted fairly deep 6model integration.

[22:31] <jnthn> dukeleto: Also, I'm wondering if I can get away without having to do the upgrade-on-demand thing.

[22:32] <jnthn> dukeleto: And the overhead of going through NCI would have almost certainly made the answer "no"

[22:36] *** bluescreen100 joined
[22:36] *** bluescreen10 joined
[22:37] <dalek> rakudo/nom: 9c6aedb | jnthn++ | src/Perl6/Actions.pm:

[22:37] <dalek> rakudo/nom: Fix double-evaluation bug in | found by japhb++.

[22:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9c6aedbd9e

[22:38] <On42> phenny: "fantastisk"?

[22:38] <phenny> On42: "fantastic" (da to en, translate.google.com)

[22:39] <On42> phenny: "hvorfor bruker jeg ikke Perl"?

[22:39] <phenny> On42: "why I do not use Perl" (no to en, translate.google.com)

[22:39] <sorear> what, C# won't let me goto into a block? :(

[22:40] <jnthn> sorear: iirc, that stems from a CLR restriction on forward jumps, so they can single-pass JIT

[22:40] <jnthn> (though I may be misremembering...)

[22:41] <tadzik> sorear: "li≈õcie" can be either "(on the) list", or "leafs"

[22:41] <jnthn> japhb_: Hope the above fix helps. Thanks for finding the bug :)

[22:41] <jnthn> One of those "omg, I did what" ones :)

[22:41] <On42> phenny: Perl: use CGI; use Encode; use JSON::XS; use LWP::UserAgent;  my $url = "https://www.googleapis.com/language/translate/v2?key=$key&q=$string&source=$from&target=$to";my $ua = LWP::UserAgent->new();my $res = $ua->get($url);my $json = decode_json($res->decoded_content);return "$json->{data}->{translations}[0]->{translatedText}";	

[22:42] <sorear> tadzik: in English, the plural of leaf is (irregular) "leaves"

[22:42] <tadzik> sorear: ah, I was considering "leaves", but then backspaced and went "leafs" :)

[22:42] <sorear> tadzik: GlitchMr's quit message was wychodzi or something like that

[22:42] <sorear> On42: what do you think you are doing?

[22:42] <tadzik> yeah, that's literally "leaves" in terms of "leave"

[22:43] <On42> <sorear> trying to convince the bot to use Perl instead? ;-)

[22:43] <sorear> I did not say that

[22:44] <On42> Useless its a Python irc bot...

[22:45] <sorear> On42: if you want to pick a fight with sbp++, do it outside.

[22:45] <On42> Who is sbp?

[22:45] <sorear> On42: we don't do language bashing here

[22:46] <sorear> phenny is sbp's bot

[22:46] <On42> phyton is a great language. Just that Google Translate v.2 is lacking a Perl example. First time Google does not provide a Perl example in its apis!

[22:47] <sorear> I'm guessing you're here because you got banned from #perl.

[22:47] <swarles> lol

[22:47] <On42> There is a need to delete/update the actuall CPAN modules... none of them works since august when it comes to fetching googel translations with Perl.

[22:48] <On42> sorear: Actually.. I got a new record, been in #perl 1 hour without being banned! LOL

[22:48] <sorear> On42: talk to the module maintainers

[22:49] <On42> sorebear: I am not complaining I wrote my little module already (see above :). 

[22:49] <On42> I am just alerting- Google is dumping Perl - I do not like that!

[22:49] <sorear> #perl6 is not responsible for the contents of http://search.cpan.org/CPAN/authors/id/E/EJ/EJS/

[22:49] <sorear> On42: YOU ARE ALERTING THE WRONG PEOPLE>

[22:49] <swarles> lol

[22:50] <tadzik> heh

[22:50] <On42> cool... he is from UiB - I also studied there! :)

[22:50] <tadzik> how is google "dumping Perl"? Like, not using it? Did they ever use it?

[22:50] <sorear> I don't think they ever did

[22:50] <sorear> does it really require that much intelligence to translate a Python sample to Perl?

[22:51] <tadzik> I don't think so

[22:51] <tadzik> it's the Dark Side that's supposed to be easier, so moving _to_ Perl shouldn't be hard

[22:51] <sorear> google has been a {Python,C,C++,Java} house since forever

[22:52] <On42> tadzik: by only providing api examples to developers in other languages see here: http://code.google.com/apis/language/translate/v2/libraries.html

[22:52] * jnthn computes factorial 1000 just for fun

[22:52] <dalek> niecza: ead51d9 | sorear++ | lib/ (3 files):

[22:52] <dalek> niecza: Skeleton of -gen-app; use named methods for builtin methods to reduce fragility

[22:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ead51d99cb

[22:53] <tadzik> oh well

[22:53] <On42> Maybe I should ask them to add my code from above? I just dont have time to go through all the documentaion of how to suggest them code examples.. too old and lazy

[22:53] <sorear> On42: if you want to talk to Google, talk to Google

[22:53] *** ggoebel left
[22:53] <dalek> ecosystem: fc00e23 | (Timothy Totten)++ | META.list:

[22:53] <dalek> ecosystem: Added Esquel to ecosystem.

[22:53] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/fc00e234fa

[22:53] <sorear> On42: if you want to talk to [email@hidden.address] talk to [email@hidden.address]
[22:53] <On42> #google is dead

[22:54] <tadzik> maybe just publish it on CPAN, who cares about what google publishes if we have a CPAN module

[22:54] <On42> :)

[22:54] <sorear> I did not say #google.  Are you even paying attention?

[22:54] <On42> tadzik: true, but its a way to get more users to use Perl

[22:54] <On42> sorear: google is also dead :p

[22:55] <sorear> Someone else take over, I can't do this anymore.

[22:55] <On42> Just having fun with you-dont take it eprsonal sorear :)

[22:56] <tadzik> sorear: just care less

[22:56] <On42> Maybe we should have a comptetion and see who gets banned first in #perl with some rules: no swearing, no flooding etc, only relevant code  discussion? :)

[22:56] <diakopter> On42: that's very much not on topic here

[22:57] <On42> nm

[22:57] <japhb_> On42: Two things: 1) This channel is about Perl 6, NOT Perl 5.  2) This channel prides itself on tolerant and kind behavior.  Please take negative behavior and trolling elsewhere; it's not who we are.

[22:58] <tadzik> esquel is quite cool

[22:58] <dalek> nqp/bigint: f75ce8f | jnthn++ | src/ops/nqp_bigint.ops:

[22:58] <dalek> nqp/bigint: String to bigint, bigint to string.

[22:58] <dalek> nqp/bigint: review: https://github.com/perl6/nqp/commit/f75ce8f317

[22:58] *** ggoebel joined
[22:58] * tadzik sleeps, o/

[22:59] *** dual left
[22:59] <jnthn> https://gist.github.com/1323796 # the current fun you go through with bigint :)

[22:59] <On42> japhn: i would be happy to help you taking trolling and negative behavior elsewhere, but i am afraid that you are talking to the wrong person. Frustartion can also be a product of pure misunderstanding as well as other socio-psychological factors.

[22:59] <flussence> ok, I'm sick of this guy now.

[23:00] <colomon> hugme: hug flussence 

[23:00] <flussence> ty

[23:00] <diakopter> On42: your reply makes no sense; please don't take this as a request to explain it, however.

[23:00] <colomon> oh noez, hugme is down!

[23:00] * tadzik hugs flussence

[23:01] <tadzik> someone needs to pick up duties

[23:01] <On42> diakopter: i was not replying to you - please do not take this as an offense.

[23:01] <colomon> tadzik++

[23:01] <diakopter> On42: why would you think I thought you were replying to me?

[23:01] *** ChanServ sets mode: +o diakopter

[23:01] * tadzik ducks

[23:01] <On42> diakopter: why would you suggest that I was thinking of you?

[23:02] <diakopter> I didn't

[23:02] <On42> neither did i :)

[23:02] *** packetknife joined
[23:02] <diakopter> On42: please go elsewhere

[23:03] <On42> no, i like this channel.

[23:03] <diakopter> or talk about Perl 6-related matters

[23:03] <flussence> actual on-topic; I want a cheap way to dump all of a function's args, (:@_, :%_).perl won't do what I want if they're all pre-declared in the signature, will it?

[23:03] <sorear> niecza: sub foo($x,$y,$z) { say callframe.args.perl }; foo(3,4,5)

[23:03] <p6eval> niecza v10-217-g82c7878: OUTPUT¬´Potential difficulties:‚ê§  $x is declared but not used at /tmp/ZAZPH06CNG line 1:‚ê§------> [32msub foo([33m‚èè[31m$x,$y,$z) { say callframe.args.perl }; f[0m‚ê§  $y is declared but not used at /tmp/ZAZPH06CNG line 1:‚ê§------> [32msub foo($x,[33m‚èè[31m$y,$z‚Ä¶

[23:03] <sorear> niecza: sub foo($x,$y,$z) { say callframe.args.perl }; foo(3,4,5) #OK

[23:03] <p6eval> niecza v10-217-g82c7878: OUTPUT¬´\(3, 4, 5)‚ê§¬ª

[23:03] <sorear> niecza: sub foo($x,$y,$z,:$pie) { say callframe.args.perl }; foo(3,4,5,:!pie) #OK

[23:04] <p6eval> niecza v10-217-g82c7878: OUTPUT¬´\(3, 4, 5, |{"pie" => Bool::False})‚ê§¬ª

[23:04] <flussence> sorear++

[23:04] <jnthn> Note you can also use |$c at any point in a sig and it collects all the as-yet unbound argument,s but doesn't prevent them from being bound to parameters afterwards.

[23:05] <colomon> rakudo: sub foo { say @_.perl; say %_.perl; }; foo(1, 2, 3);

[23:05] <p6eval> rakudo 9c6aed: OUTPUT¬´Array.new(1, 2, 3)‚ê§().hash‚ê§¬ª

[23:05] <colomon> rakudo: sub foo { say @_.perl; say %_.perl; }; foo(1, 2, 3, :sam(25));

[23:05] <p6eval> rakudo 9c6aed: OUTPUT¬´Array.new(1, 2, 3)‚ê§("sam" => 25).hash‚ê§¬ª

[23:05] <jnthn> nom: sub foo(|$c, $a, $b) { say $a; say $b; say $c.list }; foo(1,2)

[23:05] <p6eval> nom 9c6aed: OUTPUT¬´===SORRY!===‚ê§Cannot put required parameter after variadic parameters at line 1, near ", $b) { sa"‚ê§¬ª

[23:05] *** swarles left
[23:05] <On42> I will leave - just a note to TimToady in case you are here: Get rid of these ego wankers if you want to get anywhere with Perl. Their ego issues is just as long as php namespace... ciao

[23:05] <jnthn> oh heh

[23:05] <tadzik> wat

[23:05] <flussence> and he reveals his true nature :)

[23:05] <flussence> shoo.

[23:05] <On42> diakopter> shoot

[23:07] <flussence> pretty weak as far as trolls go, watch him get annoyed now when he has to leave of his own volition :)

[23:07] <tadzik> g'night

[23:07] <flussence> o/

[23:07] <jnthn> night, tadzik 

[23:07] <colomon> \o

[23:08] <On42> I did Perl long before you even sucked on you mother breast, flussence. Who are you to call me a troll?

[23:08] <flussence> heh, so cute :)

[23:08] <On42> i am sure it was.

[23:08] *** diakopter sets mode: +b *!*On42@*.bb.online.no

[23:08] *** On42 was kicked by diakopter (On42))
[23:08] <jnthn> diakopter++

[23:09] <cognominal_> jnthn++

[23:09] <jnthn> OK, will hack on bigint some more tomorrow :)

[23:10] <colomon> jnthn++

[23:10] <colomon> and yeah, diakopter++

[23:11] <japhb_> jnthn++ # And thanks for fixing the double-call bug (which is still building, sigh ...)

[23:11] *** molaf__ joined
[23:13] *** molaf_ left
[23:14] <flussence> hm, now I know exactly what args my function was called with when it dies, and I still haven't a clue where in its 50 or so lines it goes wrong...

[23:15] <flussence> std: if my $a = $str.match(rx/foo/) { $a }

[23:15] <p6eval> std be1f10e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $str is not predeclared at /tmp/mZt2C2R44Q line 1:‚ê§------> [32mif my $a = [33m‚èè[31m$str.match(rx/foo/) { $a }[0m‚ê§Check failed‚ê§FAILED 00:01 124m‚ê§¬ª

[23:15] <flussence> std: my $str; if my $a = $str.match(rx/foo/) { $a }

[23:15] <p6eval> std be1f10e: OUTPUT¬´ok 00:01 124m‚ê§¬ª

[23:23] <jnthn> ok, I'm gone for the night...hopefully I manage more than 2 hours sleep this time :) o/

[23:23] <diakopter> o/

[23:35] *** jaldhar joined
[23:36] *** packetknife left
[23:39] *** whiteknight joined
[23:49] <sorear> well that was interesting

[23:49] <sorear> o/ whiteknight

[23:49] *** MayDaniel left
[23:49] <sorear> diakopter: you can take your hat off now.

[23:49] <diakopter> :)

[23:49] *** diakopter sets mode: -o diakopter

[23:49] <whiteknight> hello sorear

[23:57] *** tokuhiro_ joined
