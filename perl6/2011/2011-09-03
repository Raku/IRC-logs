[00:24] *** jrockway left
[00:25] *** jrockway joined
[00:41] *** envi joined
[00:54] *** whiteknight left
[00:54] *** whiteknight joined
[00:55] *** donri left
[00:55] *** cexsum left
[01:15] *** whiteknight left
[01:20] *** jevin left
[01:22] *** jevin joined
[01:26] *** wolfman2000 joined
[02:26] *** skangas left
[02:38] <sorear> good * #perl6

[02:40] *** colomon joined
[03:03] *** kaare_ joined
[03:03] *** jamtech joined
[03:05] *** colomon left
[03:17] *** jaldhar joined
[03:23] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:48] *** bluescreen10 left
[03:54] *** skangas joined
[04:04] *** REPLeffect left
[04:07] *** cexsum joined
[04:17] *** REPLeffect joined
[04:23] *** jamtech_ joined
[04:23] *** jamtech left
[04:26] *** Sarten-X left
[04:28] *** jaldhar left
[04:32] *** jaldhar joined
[04:36] *** Sarten-X joined
[04:45] *** jamtech_ left
[04:51] *** jaldhar left
[04:56] *** jaldhar joined
[05:00] <moritz> good morning

[05:01] <TimToady> ö/

[05:10] *** wamba joined
[05:20] <PerlJam> it's like this channel never really sleeps.

[05:21] <lue> Probably because some people here almost never do :)

[05:23] * moritz would love to sleep more

[05:24] <PerlJam> I stayed up last night and watched Real Genius.  I hadn't seen that movie in well over 10 years.

[05:30] <lue> .oO(10 year old CPUs of an obsolete architecture are not recommended for heavy amounts of upgrading ... :/ )

[05:43] *** drbean left
[05:44] *** jamtech_ joined
[05:59] *** tewk left
[06:01] *** tewk joined
[06:08] *** JimmyZ joined
[06:12] *** drbean joined
[06:14] *** cexsum left
[06:21] *** cexsum joined
[06:25] *** cexsum_ joined
[06:29] *** jamtech_ left
[06:33] <mberends> good * friends

[06:36] <JimmyZ> good * ** *  mberends 

[06:37] <mberends> :)

[06:41] <sorear> hi mberends

[06:47] *** jevin left
[06:49] *** jevin joined
[07:06] *** cexsum left
[07:18] *** mj41 joined
[07:26] *** cexsum_ left
[07:26] * sorear thinks ey has a decent first pass at CLR interop fully figured out.  For real this time!

[07:27] <mberends> \o/

[07:38] *** wamba left
[07:40] *** wamba joined
[08:09] *** ab5tract joined
[08:17] *** ab5tract left
[08:19] *** envi left
[08:29] *** risou is now known as risou_awy

[08:32] *** Trashlord left
[08:33] *** Trashlord joined
[08:35] *** araujo left
[08:41] *** Su-Shee_ is now known as Su-Shee

[08:47] *** Trashlord left
[08:49] *** Trashlord joined
[08:59] *** Trashlord left
[09:01] *** Trashlord joined
[09:02] *** masak joined
[09:02] <masak> happy weekend, #perl6!

[09:02] <phenny> masak: 02 Sep 03:43Z <sorear> tell masak Str per se is immutable but there's... something... between Str and Cursor that is mutable.  See also <cut>.

[09:02] <tadzik> lol, it's jnthn _and_ masak!

[09:02] <masak> sorear: I was thinking of <cut> too. :)

[09:02] <masak> jnthn! \o/

[09:04] <tadzik> well, one being asleep too, but still ;)

[09:06] <masak> my #perl6 plans for this weekend: (1) blog twice about stuff, (2) put together a small guide for LittleAnimalFarm AI pioneers, (3) -Ofun

[09:06] <masak> in no particular order ;)

[09:10] *** orafu left
[09:10] *** orafu joined
[09:11] *** mj41 left
[09:13] *** Trashlord left
[09:14] <JimmyZ> and macro? :)

[09:15] <masak> I'll probably finalize my macros grant proposal, send it in, and yes, maybe even dig down and hack a little in my branch ;)

[09:16] <JimmyZ> push push push   ---- moritz

[09:16] <masak> ;)

[09:16] <masak> JimmyZ: I've run macros locally. it's wonderful. :P

[09:17] <masak> JimmyZ: but I'll push when the time is right.

[09:17] <tadzik> what do you mean run

[09:17] <JimmyZ> masak:  glad to hear that

[09:17] *** Trashlord joined
[09:17] <masak> tadzik: Perl 6 code that defines a macro and then calls it runs in my local nom-based branch.

[09:17] <tadzik> oh oh

[09:18] *** zhangkaizhao joined
[09:18] <masak> tadzik: the thing is this: I got to talking about macros during YAPC::EU with pmichaud and TimToady and jnthn. then when everyone else had left, jnthn and I were walking around Riga and discussing the practicalities of implementing macros.

[09:19] <masak> tadzik: the more we talked, the more doable it seemed.

[09:19] <tadzik> like

[09:20] <masak> so in the weekend after that, in a hotel in Tallinn, with jnthn's help, I sat down and started implementing it. a few hours later we had it working, as a proof-of-concept at least.

[09:20] *** thou left
[09:21] <JimmyZ> masak++

[09:21] <mberends> o/ masak: reading "Enough is Enough" immediately reminded me of your Yapsi 2011.03 announcement https://github.com/masak/yapsi/blob/master/doc/announce/2011.03 with your persona as a mogrified Dr. Klomp :)  I think I was Thog when you previewed it here in Vught :)

[09:22] <masak> :D

[09:23] <masak> that is still my favourite announcement.

[09:23] <tadzik> of course. I appear in it

[09:24] <mberends> did you think of that analogy at the time?

[09:26] *** Trashlord left
[09:28] <masak> mberends: no, I was more thinking of Babbage and Lovelace in this webcomic, I think: http://sydneypadua.com/2dgoggles/lovelace-the-origin-2/

[09:28] *** Trashlord joined
[09:29] <mberends> ooh!

[09:32] <masak> be sure to read that one and then http://sydneypadua.com/2dgoggles/series/economicmodel/

[09:32] <masak> I love steampunk. <3

[09:32] <JimmyZ> http://sydneypadua.com/ is blocked by GFW :(

[09:33] <masak> of course! alternate history is petty bourgeois and *must* be suppressed!

[09:34] <masak> the actual history is bourgeois enough as it is...

[09:34] * JimmyZ is always suppressed!

[09:35] * masak hugs JimmyZ, through walls and everything

[09:36] <JimmyZ> :)

[09:37] *** Trashlord left
[09:38] *** Trashlord joined
[09:44] <jnthn> mornin'

[09:44] <jnthn> Finally, a decent amount of sleep

[09:45] <masak> jnthn.power-on();

[09:46] * jnthn feels turned...no no wait...

[09:46] * jnthn turns on the coffee machine

[09:46] <jnthn> *yawn*

[09:46] *** Trashlord left
[09:48] <JimmyZ> morning, jnthn 

[09:48] <tadzik> jnthn: mo'ning

[09:48] <JimmyZ> bbl

[09:48] <jnthn> Is the while 1 { } memory leak now gone?

[09:48] *** Trashlord joined
[09:54] * jnthn is building a nom now and will be able to check for himself soon :)

[09:56] *** sayu joined
[09:57] <mberends> it still takes a while()  # /me ducks

[09:58] <mberends> but no, some leaks were fixed but not the while 1 {} one afaik

[09:59] *** Trashlord left
[10:00] *** mj41 joined
[10:01] *** Trashlord joined
[10:03] <mberends> jnthn: is a normal run of while 1 {} is expected to consume memory because of CPS maybe? It's growing in RAM locally.

[10:03] <jnthn> mberends: yeah, but I don't see the mls++ patch having been applied

[10:03] <jnthn> mberends: no, it should not leak

[10:03] *** MayDaniel joined
[10:05] <mberends> I don't equate consuming memory with leaking until the working set hits an OS memory limit, triggering GC. It will take a few minutes here to reach that limit.

[10:09] <jnthn> mberends: But iiuc mls++ did find the issue and it's a real, C-level leak, not a GC issue.

[10:09] <jnthn> Was just chekcing if things had been patched so I can do so if not. And it seems they haven't been.

[10:10] <mberends> jnthn: true. The patch seems to account for only part of the memory problem though.

[10:13] <jnthn> mberends: Got a link to the patch handy?

[10:14] <mberends> no, but I can probably get it quickly

[10:14] *** Trashlord left
[10:14] *** MayDaniel left
[10:17] *** Trashlord joined
[10:21] *** wamba left
[10:22] *** lue left
[10:26] *** Trashlord left
[10:28] <masak> I thought a leak is anything that was allocated and then didn't get reclaimed at the end of its "lifetime" -- and that the tricky part is that "lifetime" is something the C programmer has to (actively and correctly) decide about.

[10:28] *** Trashlord joined
[10:34] <mberends> masak: many GC algorithms, including Parrot's, are lazy by design. Leaks are only what those GC's *could* not reclaim if they wanted to.

[10:34] <masak> right. I'm talking about the manual memory management case.

[10:35] <masak> but I see what you mean now.

[10:36] <masak> especially with refcounting, things can live on as zombies even though they're just a cycle of references with no incoming reference.

[10:36] <mberends> anyhow, while 1 {} was killed by the OS because it continued expanding endlessly

[10:36] <masak> that can't be right :)

[10:36] *** Trashlord left
[10:38] <mberends> masak: yes, cycles are a big drawback of refcount. I'm searching for a solution for that in 6model/c, but have not found one yet.

[10:39] *** Trashlord joined
[10:39] *** dakkar joined
[10:40] <mberends> I've studied GC a lot now; the potential solution I currently like most is called 'Treadmill'

[10:43] <jnthn> mberends: For cycles, look up "trial deletion"

[10:44] <jnthn> (if you didn't already see that stuff, of course :))

[10:45] <mberends> jnthn: oh yeah, seen that before, I'll look again :)

[10:46] <mberends> .oO( if this block vanishes, does the rest vanish too? )

[10:48] <jnthn> Only if you use the block for resting on.

[10:48] <jnthn> ;)

[10:48] *** am0c joined
[10:49] *** Trashlord left
[10:49] <mberends> I cannot spend much time on that today, must do some irl housekeeping

[10:52] *** Trashlord joined
[10:52] <masak> οίκος++

[10:53] *** agentzh joined
[11:01] *** mj41 left
[11:03] *** Trashlord left
[11:04] *** renormalist left
[11:04] *** renormalist joined
[11:07] *** woosley joined
[11:07] *** Trashlord joined
[11:10] *** araujo joined
[11:18] *** Trashlord left
[11:19] *** Trashlord joined
[11:20] *** Trashlord left
[11:20] *** sivoais joined
[11:22] *** Trashlord joined
[11:30] *** Trashlord left
[11:32] *** envi joined
[11:33] *** Trashlord joined
[11:33] *** whiteknight joined
[11:39] *** Trashlord left
[11:43] *** risou_awy is now known as risou

[11:44] *** Trashlord joined
[11:44] *** Trashlord is now known as Guest3767

[11:45] *** Guest3767 left
[11:47] *** Siddy joined
[11:57] *** Siddy left
[11:58] *** Siddy joined
[11:58] *** colomon joined
[12:05] *** Siddy left
[12:07] *** Siddy joined
[12:11] *** zby_home joined
[12:15] <tadzik> phenny: "οίκος"?

[12:15] <phenny> tadzik: "house" (el to en, translate.google.com)

[12:18] <jnthn> el?

[12:18] <masak> tadzik: the source of words such as "economy" (the management of home) and "ecology" (the study of home)

[12:18] <masak> jnthn: Classical Greek.

[12:18] <jnthn> oh, greek

[12:19] <masak> hum, maybe modern Greek.

[12:19] <tadzik> el greco

[12:19] <masak> yes, modern Greek. http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes

[12:23] *** Limbic_Region left
[12:32] *** molaf_ left
[12:35] *** Siddy left
[12:37] *** Siddy joined
[12:45] *** jrockway left
[12:46] *** jrockway joined
[12:46] *** baest left
[12:48] *** Siddy left
[12:48] <masak> you people are too quiet today.

[12:49] <jnthn> HUSH I'M WRITING CODE.

[12:49] *** Siddy joined
[12:49] * masak sticks out his tongue and goes back to writing code himself :)

[12:51] *** Siddy left
[12:51] *** baest joined
[12:52] *** Siddy joined
[12:55] <masak> rakudo: class AreYouNom { method foo { $!x } }; say "no, I am not nom"

[12:55] <p6eval> rakudo 2bac6a: OUTPUT«===SORRY!===␤Attribute $!x not declared in class AreYouNom at line 1, near " } }; say "␤»

[12:55] <masak> gotcha.

[12:58] *** mj41 joined
[13:07] *** Vlavv` left
[13:07] *** Vlavv joined
[13:10] *** mj41 left
[13:32] *** woosley left
[13:38] *** tokuhirom joined
[13:38] *** mj41 joined
[13:39] *** MayDaniel joined
[13:42] <dalek> nqp: 5c84988 | jonathan++ | src/ (3 files):

[13:42] <dalek> nqp: Start to sketch out new boolification protocol, so we can portably and efficiently put things in boolean context (e.g. avoiding nested runloops in the common case).

[13:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5c8498832b

[13:42] <dalek> nqp: b53d224 | jonathan++ | src/ops/nqp.ops:

[13:42] <dalek> nqp: Correct error text.

[13:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b53d22440a

[13:42] <dalek> nqp: 1a9cdae | jonathan++ | src/pmc/sixmodelobject.pmc:

[13:42] <dalek> nqp: Update get_bool to use new boolification protocol; we fall back to a v-table override during migration (will rip that code out afterwards).

[13:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1a9cdae50a

[13:44] *** wayland76 left
[13:46] *** sayu left
[13:47] *** espadrine left
[13:47] <masak> jnthn++

[13:48] <tadzik> looks exciting

[13:48] <jnthn> pmichaud++ for nudging me to do it, even though it took me a while to work out how it should look and actually get around to it :)

[13:51] <dalek> nqp: 57988ce | jonathan++ | src/how/NQPClassHOW.pm:

[13:51] <dalek> nqp: Update NQPClassHOW to provide information for the new boolification protocol.

[13:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/57988ce92e

[13:51] <dalek> nqp: 35da528 | jonathan++ | src/ (2 files):

[13:51] <dalek> nqp: Remove now unrequired uses of is parrot_vtable('get_bool') trait.

[13:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/35da528b82

[13:51] <dalek> nqp: 4738417 | jonathan++ | src/stage0/ (6 files):

[13:51] <dalek> nqp: Update bootstrap.

[13:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/473841777a

[13:53] <masak> when'll Perl 6 be done/production-ready/6.0.0?

[13:53] <masak> I'm usually among the bunch who say "there's no way to answer that".

[13:53] <masak> but let's pretend there were a nice, short, concrete answer.

[13:53] <masak> what would it be? :)

[13:54] <tadzik> 2 years

[13:54] <flussence> it'll probably coincide with the time I finish getting this graph up to date... which isn't any less vague than the current answer we give people :)

[13:54] <masak> something like "we just need to finish up role/MMD/speed, and then you can start using it."

[13:54] <tadzik> Massively Multiple Dispatch is what always comes to me mind when I see MMD

[13:54] <flussence> I think last year my answer was "when frozen bubble runs on it" :)

[13:54] <masak> there was this guy in here the other day who sayd "when will Perl 6 be done? I'm sick of using PHP."

[13:55] <masak> tadzik: Massively Multiplayer Dispatch :P

[13:55] <masak> said*

[13:55] <tadzik> Methods for everyone!

[13:55] <masak> that guy had a clear goal with Perl 6. he wanted it to be a drop-in replacement for PHP.

[13:55] <masak> that's a pretty clear definition of "done", seemsme.

[13:56] <masak> not the only one, of course.

[13:57] <flussence> now we just need someone to write a quote circumfix op for «<? ?>»...

[13:57] <plobsing> masak: is that one of the end-goals of perl 6? most languages are not drop-in replacements for php for various reasons.

[13:58] <JimmyZ> when Perl 6 is done, Perl 7 will be borned

[13:59] <jnthn> masak: That's a challenging one, because one attraction of PHP is that it has a wide deployed base, and if he wants that part of drop-in then it's gonna be a while (e.g. that's a bigger thing that Perl 6 itself being "production"/"done")

[14:00] <masak> yeah.

[14:01] <masak> I'm not suggesting we should, or could, attempt to oust PHP in its niche.

[14:01] <masak> but it'd be nice to get somewhere close to that ease of deployability.

[14:01] <masak> as pmichaud++ has pointed out, that'd be an excellent use for a Rakudo distribution.

[14:02] <flussence> .oO( use Inline::HTML )

[14:06] *** sayu joined
[14:18] <JimmyZ> or embed Perl6 in HTML :)

[14:19] *** agentzh left
[14:19] <masak> JimmyZ: yes.

[14:20] <masak> JimmyZ: such a Rakudo distribution could do the PHP thing and consider anything that looks like HTML to be a script, with some <?...> thingies containing Perl 6 code.

[14:21] <JimmyZ> <?perl6  ... ?>

[14:21] <JimmyZ> or <%  ..  >

[14:23] <JimmyZ> I wrote code in mod_perl, the bad things is that the error can only output in logs, not in browser, which makes debugging code bad

[14:33] *** araujo left
[14:33] *** araujo joined
[14:34] <plobsing> JimmyZ: i see that as a good thing. no chances for users to know exactly what the error they are triggering is.

[14:35] <JimmyZ> plobsing: yeah, but let the user decide it

[14:36] <plobsing> that's just an opportunity to get it wrong

[14:36] <plobsing> and have your server pwned

[14:36] <masak> the default should be the secure option.

[14:36] <huf> i'm sure you could install a handler with mod_perl that can tail the error log when the server would throw back an ISE

[14:36] <JimmyZ> plobsing: I don't want to see both log and browser continually  when I am debugging code

[14:37] <JimmyZ> huf: a handler can't hand compling error

[14:38] <JimmyZ> PHP allows whether error should output to browser or not

[14:41] *** woosley joined
[14:41] *** woosley left
[14:42] *** araujo left
[14:43] *** araujo joined
[14:43] <masak> right.

[14:43] <masak> but the default should be whatever's secure.

[14:44] <masak> which happens, in this case, to be not showing the error in the browser.

[14:45] <JimmyZ> yeah, but mod_perl should give me a opportunity, let me see the whatever errors in the browser when I am developping

[14:45] <flussence> when I've done PHP stuff I usually find inline errors get in the way. It's even worse when using strict xhtml...

[14:45] <JimmyZ> I can't find a configure option to make the whatever errors outputs to browser

[14:45] *** molaf joined
[14:46] <JimmyZ> but PHP gives me the option

[14:47] <flussence> in perl5 the error display's usually handled at the web framework level... if you're writing raw CGI.pm-style code then yeah, it'll be difficult.

[14:47] <JimmyZ> yes, catalyst framework  is good, but I don't want framework 

[14:48] <JimmyZ> catalyst has a native server

[14:48] <TimToady> CATCH { .redirect } seems easy enough

[14:49] *** tokuhirom left
[14:49] <JimmyZ> TimToady: when it's a compiling error, CATCH doesn't work ;(

[14:50] <flussence> (that's why I have use_ok tests on all my web stuff now...)

[14:51] <JimmyZ> that's why I didn't use mod_perl, use mod_php instead 

[14:51] <plobsing> JimmyZ: if it is a compiling error, you can't you just perl -c your code/

[14:51] <JimmyZ> plobsing: I can't, because I'm using mod_perl

[14:52] <flussence> plobsing: he's got a point, mp code is a pain to debug outside the webserver :)

[14:52] *** MayDaniel left
[14:53] <flussence> another way $dayjob makes my work harder than it needs to be... :(

[14:53] <JimmyZ> whenever I flush browser, whenever I can't see anything in browser, I should go into the apache log

[14:57] * TimToady wonders if BEGIN CATCH can/should be made to work

[14:58] <masak> exception handlers for compile-time?

[14:58] <TimToady> nodnod

[14:58] <JimmyZ> TimToady: can't, I tried it

[14:59] <JimmyZ> TimToady:  iirc

[14:59] <masak> TimToady: isn't it enough to put CATCH in whatever BEGIN block or BEGIN-time construct where exceptions should be caught?

[14:59] <TimToady> I meant "made to work" in the other sense

[14:59] * masak fails to see why BEGIN CATCH specifically would add anything that BEGIN { CATCH } doesn't already have

[15:00] <TimToady> want to catch exceptions thrown after the BEGIN

[15:00] <TimToady> by the compiler

[15:01] <masak> it sounds like a slight mis-combination of the two features BEGIN and CATCH.

[15:01] <TimToady> it's abusing CATCH more than BEGIN

[15:01] <masak> yes.

[15:01] <TimToady> since who knows what exception mechanism the compiler is using

[15:02] <TimToady> but it'd be nice if there was some hook that could be set at use/BEGIN time

[15:02] <TimToady> "pragmas will happen"  but it'd be nice if they were portable

[15:02] <pmichaud> good morning, #perl6

[15:02] <masak> good *, pmichaud 

[15:02] *** whiteknight left
[15:03] <TimToady> \°  <-- shrunken head today

[15:03] <flussence> how about: try { compile 'file.pl'; CATCH { say $! } } # like require(), but stops before running mainline

[15:04] * TimToady wonders whether the setting should/could have charge of compilation policy

[15:05] <TimToady> YOU_WILL_BE_HERE :)

[15:05] <jnthn> o/, pmichaud 

[15:05] <pmichaud> THERE_WILL_BE_MODULES_HERE :)

[15:07] <TimToady> try eval q{YOU_ARE_HERE}

[15:07] <TimToady> try eval q'{YOU_ARE_HERE}'  # more likely

[15:07] <TimToady> s/q//

[15:08] *** uniejo_ joined
[15:08] *** colomon left
[15:08] *** colomon joined
[15:08] *** colomon_ joined
[15:08] *** colomon left
[15:08] *** colomon_ is now known as colomon

[15:11] <TimToady> which still won't work, of course...

[15:13] <TimToady> maybe we need a more general mechanism for a setting to defer an action till YOU actually IS HERE

[15:13] <TimToady> maybe YOU_ARE_HERE {...} is a phaser that defaults to the normal thing

[15:13] *** araujo left
[15:14] <JimmyZ> try { YOU_ARE_HERE; CATCH { ....  } }

[15:14] <moritz> TRY_TO_BE_HERE

[15:14] <apejens> WISH_YOU_WHERE_HERE

[15:15] <pmichaud> NEITHER_HERE_NOR_THERE

[15:15] <TimToady> :D xx *

[15:15] <moritz> A_HOBBIT'S_TALE

[15:15] <apejens> STOP_CANT_TOUCH_THIS { }

[15:15] <TimToady> apejens: you may use CAN'T

[15:15] <apejens> would be fun with a language with only pop song references

[15:15] <apejens> ahh

[15:15] <pmichaud> DON'T-USE-APOSTROPHES-OR-HYPHENS

[15:16] <JimmyZ> YOU_ARE_ON_MARS

[15:16] <TimToady> why can't we be this creative when we need something important?

[15:17] <apejens> because it's harder :)

[15:17] <TimToady> oh, well that's okay then...

[15:17] <pmichaud> because we're too creative on the "something important" part.

[15:18] <TimToady> .oO(something for everyone, a comedy tonight!)

[15:18] <pmichaud> i.e., we're more creative at making challenges than resolving them :)

[15:18] *** zhangkaizhao left
[15:18] * moritz challenges everybody to fix that :-)

[15:18] <JimmyZ> END { try { YOU_ARE_HERE; CATCH { .... } } } :)

[15:18] *** araujo joined
[15:18] <TimToady> I'd say resolving our challenges is one of our...er...challenges

[15:18] <JimmyZ> that's too end

[15:18] <pmichaud> "Hey!  What if we could modify the grammar!  At runtime!"

[15:19] <TimToady> who'd want that?

[15:20] <TimToady> hmm, you switch languages by going into a dynamic scope...hmm...

[15:21] <pmichaud> "maybe mmd can be implemented using smartmatch!"

[15:21] <pmichaud> "Let's use the 'whatever' term to do currying!"

[15:21] <TimToady> macro statement_control:BEGINCATCH { CATCH; parse_more() }

[15:21] <moritz> and signature binding too, when were'a at it

[15:22] <TimToady> there's more than one way to homoiconify a cat

[15:24] <TimToady> btw, I think "Cat" might be the answer to "what does a mutable Str look like?"

[15:24] <TimToady> Cat's are really more like ropes

[15:24] <pmichaud> makes sense, at least to a first approximation.  the devil will be in the details.

[15:24] <TimToady> s/"'"//

[15:26] <TimToady> I foresee that we've been using Str in a lot of places that we'll wish we'd used Stringy

[15:26] <pmichaud> Yes, I suspect that's true.

[15:26] <TimToady> since a Cat is Stringy, but not Str

[15:26] <pmichaud> I know the core setting has a lot of Str in places that need to be otherwise

[15:27] <moritz> agreed

[15:27] <TimToady> and if we're going to expect people to use Stringy that much, it's bad Huffman to have it that long

[15:28] <moritz> people can just use ~

[15:28] <TimToady> not in a sig

[15:28] <moritz> hm, right

[15:28] <TimToady> well, unless we allow ~ and + in a sig

[15:28] <moritz> OTOH the last time we huffmanized a type name (Object -> Mu) it turned out we didn't need it so often after all

[15:28] <moritz> at least I don't need it often in normal code

[15:29] <TimToady> that wasn't so much for huffman

[15:29] <TimToady> it was more that I didn't want people assuming they knew what Object means

[15:29] <pmichaud> "Object" was objectionable.

[15:29] <TimToady> when Any is really what they're thinking of

[15:29] <TimToady> Mu almost means something more like Concept

[15:30] <TimToady> Mu is Nouny, but not a Noun :)

[15:33] *** donri joined
[15:34] <moritz> NaN = Not a Noun :-)

[15:34] <moritz> or Not a Nun

[15:39] *** uniejo_ left
[15:40] <masak> TimToady: I wanted to write a follow-up blog post where I explained -n and -p "done right", in terms of YOU_ARE_HERE. but then I got to thinking that it seems that we mean two different things/dimensions when we talk about "the setting" -- sometimes we're talking about all of the standard builtins that are provided, and other times we're talking about code injected immediately around YOU_ARE_HERE.

[15:40] <masak> it seems to me we're confusing these two things. for example, we don't intend all the standard builtins to go away just because we use -n

[15:40] <masak> and yet we say it's a different setting.

[15:40] <TimToady> it's a nested setting

[15:41] <TimToady> lexical nesting is primarily about "what language am I using right here"

[15:41] <TimToady> everything else comes from that

[15:42] <TimToady> so if your setting needs a setting, we can do that

[15:43] <tadzik> re BEGIN CATCH vs BEGIN { CATCH }, that's what I thought about DOC use too

[15:48] *** sayu left
[15:49] *** sayu joined
[15:55] *** dakkar left
[16:03] <dalek> nqp: ca42584 | jonathan++ | src/ops/nqp.ops:

[16:03] <dalek> nqp: Add a sanity check.

[16:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ca42584055

[16:03] <dalek> nqp: 5d6850e | jonathan++ | src/pmc/sixmodelobject.pmc:

[16:03] <dalek> nqp: Fix some thinkos; drop using a get_bool v-table override as the way we implement 6modelobject's get_bool v-table.

[16:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5d6850e525

[16:10] *** araujo left
[16:13] *** _twitch joined
[16:15] *** araujo joined
[16:19] *** JimmyZ left
[16:21] <masak> TimToady: so "setting" is something that's applied, possibly several times, during the compilation process?

[16:21] <jnthn> masak: I think it's more that a setting may, itself, have a setting.

[16:22] <jnthn> masak: I think nom already supports that, fwiw.

[16:22] <masak> jnthn: I don't see how that'd work. -n might be applied with either the default builtins, or with an empty setting.

[16:22] <masak> so it's not like -n has a pre-set setting.

[16:23] <jnthn> masak: I was assuming that -n was equivalent to --setting=MINUS-N or so :)

[16:23] <jnthn> But with a decent name.

[16:25] <masak> jnthn: so several --setting=<something> will not override each other, but nest inwards wrt each other?

[16:25] <masak> my point is, what if I want -n but not the standard builtins?

[16:31] *** thou joined
[16:33] *** araujo left
[16:33] *** araujo joined
[16:35] <moritz> masak: in some sense -n *is* a standard builtin, and uses others (like print, Bool (for while()))

[16:36] <masak> well, replacing the standard builtins doesn't necessarily mean getting rid of print and Bool.

[16:38] <moritz> it does not?

[16:42] <moritz> well, wanting command line options that are implemented in the setting, but not the setting itself is like wanting all built-ins except Int

[16:42] <moritz> ie unrealistic in my mental model

[16:43] <masak> so -n and -p presuppose the standard setting?

[16:43] <moritz> I suppose

[16:43] <masak> a company with its own enhanced setting can't use it with -n and -p?

[16:44] <masak> a setting which does routine tracing or something can't be used with -n and -p?

[16:44] <moritz> maybe -n and -p presuppose *at least* the standard setting

[16:44] <masak> hm.

[16:44] <masak> anyway, I just wanted to point out what I believe to be an unclarity.

[16:45] <moritz> I believe alternate settings are very unclear right now

[16:45] *** Chillance joined
[16:45] <moritz> ie it is not clearly specced which language features are allowed to rely on the standard setting

[16:45] <masak> t/spec/S32-trig/pi.t fails during spectest locally. "no bigint lib loaded".

[16:46] <jnthn> masak: Er, you can only pass one --setting afaik

[16:46] <moritz> for example  use Foo :bar;  will probably construct a Pair for :bar

[16:47] <jnthn> moritz: Anybody who wants to create their own setting from scratch will have a LOT of work to do.

[16:47] <moritz> right

[16:47] <jnthn> moritz: Like, they'll need to resolve all the bootstrapping circularities than we do in CORE.setting

[16:47] <mberends> Niecza very elegantly implements -n and -p by adding settings for them, see CORE, CORN and CORP for example in https://github.com/sorear/niecza/blob/master/src/niecza#L95

[16:47] <jnthn> It's possible today. It's just a huge undertaking.

[16:47] <masak> I agree that "alternate setting" will probably duplicate many of the builtin types and routines.

[16:48] <masak> but given that, I still think it's a bit short-sighted to say that -n and -p only work under the default setting.

[16:48] <masak> it feels less-than-composable.

[16:48] <jnthn> masak: Then maybe Rakudo has the correct factoring of them and the spec is wrong ;)

[16:49] <moritz> in the long run, we probably want a "slim" standard setting, which resolves the bootstrapping issues

[16:49] <jnthn> (e.g. maybe they make more sense as AST transform)

[16:49] <benabik> Perhaps -n and -p wrap the program in a mini-setting that is then wrapped in the --setting?

[16:49] <jnthn> benabik: Only if you dynamically compile that mini-setting.

[16:49] <moritz> and another one, which can be completely implemented in terms of the slim setting

[16:49] *** isBEKaml joined
[16:49] <jnthn> moritz: I'd pondered that a bit. My conclusion was that it may not help as much as we hope.

[16:50] <moritz> so things like DateTime, IO::Socket::INET etc would be in the "fat" setting, and that is what one might occasionally substitute

[16:50] <masak> jnthn: interesting notion. that would make for a nice blog post :)

[16:50] <masak> moritz: I like that.

[16:51] <jnthn> moritz: Oh, *those* things we could easily pull out, yes

[16:51] <benabik> Aren't those things modules, not setting?

[16:51] <moritz> an things like Set, KeySet, KeyBag etc.

[16:51] <moritz> benabik: they are setting

[16:52] <masak> they are modules in the setting.

[16:52] <masak> with 'Set', you don't have to 'use Set' to use Set.

[16:52] * jnthn spectests updating Rakudo to the new boolification stuff.

[16:53] <masak> you do have to 'use Set' to use the unicode ops for Set, though.

[16:53] <benabik> masak: Ah, yes.  Good point.

[16:53] <moritz> masak: but that's only a Rakudo limitation, no?

[16:53] <masak> moritz: what is?

[16:53] <jnthn> if [Bool|Int|Str|Num] { ... } will no longer need a nested runloop. We should get some performance win.

[16:53] <masak> jnthn: \o/

[16:54] <moritz> masak: the need for 'use Set'

[16:54] <masak> moritz: AFAIK, TimToady has said that the unicode ops shouldn't be pulled in until one does 'use Set'. also AFAIK, this does not yet work in Rakudo.

[16:55] <moritz> my memory said me that having non-latin-1 ops made parsing very slow, and that was the reason

[17:00] <jnthn> moritz: It does (though I think QRegex helps with that)

[17:01] <jnthn> But I think masak is right here also

[17:07] <jnthn> Dang, spectests show up a slight fail to the Int/Str/Num case.

[17:07] <jnthn> But Bool case looks fine.

[17:08] <jnthn> Is there some way to make the test harness run a single test and show all the output?

[17:09] *** wamba joined
[17:09] <jnthn> --verbose doesn't do that.

[17:09] <moritz> no

[17:09] <moritz> you have to run ./perl6 $testfile

[17:10] <jnthn> moritz: Yeah, that doesn't help me. :(

[17:10] <dalek> rakudo/nom: b22077d | jonathan++ | / (6 files):

[17:10] <dalek> rakudo/nom: Implement new approach to boolification. It makes it sufficiently cheaper than in a simple integer-incrementing while loop that we do 20% or so better overall.

[17:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b22077d121

[17:10] <dalek> rakudo/nom: 6d41c62 | jonathan++ | src/Perl6/Metamodel/EnumHOW.pm:

[17:10] <dalek> rakudo/nom: EnumHOW needs same updates as ClassHOW for boolification changes.

[17:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6d41c621e6

[17:10] <moritz> jnthn: why not?

[17:11] *** whiteknight joined
[17:11] <jnthn> moritz: On my platform, all tests that use is_run work fine when run as ./perl6 $testfile

[17:11] <jnthn> moritz: However, they always fail under the harness

[17:11] <jnthn> moritz: This isn't new in nom. I've never managed to track down why.

[17:11] <moritz> jnthn: urks

[17:12] <jnthn> Though would like to at some point...

[17:12] <moritz> nom: say $*EXECUTABLE_NAME

[17:12] <moritz> rakudo: say $*EXECUTABLE_NAME

[17:12] <p6eval> rakudo 2bac6a: OUTPUT«./nom-inst/bin/perl6␤»

[17:12] <moritz> jnthn: try to diag($*EXECUTABLE_NAME) in a test

[17:12] <moritz> that should show up with --verbose

[17:14] <jnthn> doesn't :(

[17:14] <jnthn> but I can always write the value to a file

[17:15] *** finanalyst joined
[17:15] <moritz> or add it to a test description

[17:15] <jnthn> oh!

[17:15] <jnthn> ./perl6

[17:15] <moritz> (they show up, do they? :-)

[17:15] <jnthn> moritz: --verbose doesn't seem to do anything different here :S

[17:16] <jnthn> moritz: Anyway, $*EXECUTABLE_NAME seems to explain a lot

[17:16] <jnthn> perl6 from the command line, ./perl6 from the harness

[17:17] <tadzik> oh, a speedup :)

[17:17] <moritz> jnthn: I see what's wrong, seems like an easy fix

[17:18] <jnthn> moritz: yay! :)

[17:18] <jnthn> moritz++

[17:19] <finanalyst> rakudo: class A {has $.a};my A $x=.new(:a(2));class B {has $.b};my $y=.new(:b(8));class C {has A $.q; has B $.w};my $z.=new(:q($x),:w($y))

[17:19] <p6eval> rakudo 2bac6a: OUTPUT«Type check failed in assignment to '$x'; expected 'A' but got 'Any'␤  in <anon> at /tmp/YMk8a4UcZ2:1␤  in <anon> at /tmp/YMk8a4UcZ2:1␤␤»

[17:19] <jnthn> finanalyst: You wanted .= new

[17:19] <jnthn> Not =.

[17:19] <tadzik> my $z.=new(:q($x),:w($y))

[17:19] <tadzik> don't you want a Type declaration btw?

[17:19] <tadzik> my $z is Any

[17:19] <finanalyst> mistype. hang on i think I found a bug

[17:19] <moritz> jnthn: pushed, please test

[17:19] <jnthn> moritz: OK, thanks

[17:19] <dalek> rakudo: 1b7dd12 | moritz++ | t/harness:

[17:19] <dalek> rakudo: [t/harness] use backslash on windows

[17:19] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/1b7dd12a34

[17:20] <finanalyst> rakudo: class A {has $.a};my A $x=.new(:a(2));class B {has $.b};my $y.=new(:b(8));class C {has A $.q; has B $.w};my $z.=new(:q($x),:w($y))

[17:20] <p6eval> rakudo 2bac6a: OUTPUT«Type check failed in assignment to '$x'; expected 'A' but got 'Any'␤  in <anon> at /tmp/TiCJNv7Xrg:1␤  in <anon> at /tmp/TiCJNv7Xrg:1␤␤»

[17:20] <finanalyst> gggrrrr

[17:20] <jnthn> moritz: Will ahve to do another test run in just a moment for the next part of the boolification things, will check it during that :)

[17:20] <tadzik> finanalyst: read what I said

[17:20] <tadzik> rakudo: my $a .= new; say $a.WHAT

[17:20] <p6eval> rakudo 2bac6a: OUTPUT«Any()␤»

[17:20] <tadzik> rakudo: my Int $a .= new; say $a.WHAT

[17:20] <p6eval> rakudo 2bac6a: OUTPUT«Int()␤»

[17:21] <tadzik> my $a is like my Any $a

[17:21] <finanalyst> rakudo: class A {has $.a};my A $x=.new(:a(2));class B {has $.b};my $y.=new(:b(8));class C {has A $.q; has B $.w};my C $z.=new(:q($x),:w($y))

[17:21] <p6eval> rakudo 2bac6a: OUTPUT«Type check failed in assignment to '$x'; expected 'A' but got 'Any'␤  in <anon> at /tmp/LR2ng3cdpu:1␤  in <anon> at /tmp/LR2ng3cdpu:1␤␤»

[17:21] <tadzik> how about $y?

[17:22] <finanalyst> rakudo: class A {has $.a};my A $x.=new(:a(2));class B {has $.b};my $y.=new(:b(8));class C {has A $.q; has B $.w};my C $z.=new(:q($x),:w($y))

[17:22] <p6eval> rakudo 2bac6a: OUTPUT«Type check failed in assignment to '$!w'; expected 'B' but got 'Any'␤  in method BUILDALL at src/gen/CORE.setting:483␤  in method bless at src/gen/CORE.setting:473␤  in method new at src/gen/CORE.setting:458␤  in method dispatch:<.=> at src/gen/CORE.setting:619␤  i…

[17:22] <jnthn> finanalyst: my B $y ... :)

[17:22] <finanalyst> yep

[17:22] <finanalyst> rakudo: class A {has $.a};my A $x.=new(:a(2));class B {has $.b};my B $y.=new(:b(8));class C {has A $.q; has B $.w};my C $z.=new(:q($x),:w($y))

[17:23] <p6eval> rakudo 2bac6a:  ( no output )

[17:23] <finanalyst> damn

[17:23] <finanalyst> OK, what has happened to me is that $z is shown as Any and not C

[17:23] <finanalyst> rakudo: class A {has $.a};my A $x.=new(:a(2));class B {has $.b};my B $y.=new(:b(8));class C {has A $.q; has B $.w};my C $z.=new(:q($x),:w($y));$x.WHAT.say

[17:23] <p6eval> rakudo 2bac6a: OUTPUT«A()␤»

[17:24] <finanalyst> rakudo: class A {has $.a};my A $x.=new(:a(2));class B {has $.b};my B $y.=new(:b(8));class C {has A $.q; has B $.w};my C $z.=new(:q($x),:w($y));$z.WHAT.say

[17:24] <p6eval> rakudo 2bac6a: OUTPUT«C()␤»

[17:24] <finanalyst> oh!

[17:24] <finanalyst> that did not happen at home

[17:24] *** wamba left
[17:25] *** Sarten-X left
[17:26] <tadzik> (:

[17:27] <tadzik> did you remember about all the  type decls at home?

[17:27] *** frhodes joined
[17:27] <tadzik> it's usually easier to just do "my $a = A.new"

[17:27] *** kaare_ left
[17:27] *** frhodes left
[17:29] <finanalyst> tadzhik: i have a bug in a program where I have a class with multiple inheritance. I thought I had a simple case, but not quite there yet

[17:29] *** kaare_ joined
[17:29] <finanalyst> i'll get back in a minute

[17:31] <jnthn> moritz: Doesn't seem to have helped, at first glance

[17:32] <moritz> :(

[17:33] <dalek> nqp: 3d0c71a | jonathan++ | src/pmc/sixmodelobject.pmc:

[17:33] <dalek> nqp: More boolification fixes.

[17:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3d0c71a636

[17:33] <finanalyst> tadzhik: false alarm, just multiple typos

[17:34] <tadzik> finanalyst: I'm tadzik btw, but glad you have it fixed :)

[17:35] <finanalyst> tadzik: sorry. 

[17:35] <tadzik> no problem

[17:35] *** Sarten-X joined
[17:37] *** frhodes joined
[17:38] <tadzik> I have a feeling that settings compilation is now _slightly_ faster

[17:38] <tadzik> like, 8 minutes rather than 10 or so

[17:38] <jnthn> tadzik: With latest NQP improvements? Possibly :)

[17:38] <tadzik> jnthn: bools?

[17:38] <jnthn> tadzik: That'd surprise me a little but if you can measure/show it, I'd be happy to see it :)

[17:39] <tadzik> jnthn: how about "I used to be cursing aloud, now I'm only grunting?" :P

[17:39] <tadzik> I can measure it, no problem

[17:39] <jnthn> tadzik: I did notice that I seemed to have got a second or two shaved off running the NQP test suite quite consistently after the improvements.

[17:39] <jnthn> Not sure if spectest runs faster.

[17:40] <jnthn> If anybody wants to test before/after that'd be great, but wait for my next patch (coming in 5-10 hopefully) first.

[17:40] <tadzik> I'm quite happy with slow spectest as long as I can compile the setting. I could get back to settings hacking then :)

[17:40] <tadzik> and if I had enough RAM for that

[17:40] <tadzik> I'll measure "before" then

[17:40] <jnthn> OK. Before the bool patches.

[17:40] <tadzik> oh, I'd have to rollback nqp first, si?

[17:40] <jnthn> yeah

[17:41] <jnthn> Don't worry if you have better things to be working on :)

[17:41] <jnthn> Unless you're especially interested in the numbers too :)

[17:41] <tadzik> I have. I also have mutable sense of duty

[17:41] *** sayu left
[17:41] <tadzik> "You can start tomorrow!"

[17:41] <tadzik> "It's already late today!"

[17:41] <tadzik> "You are awesome, you'll make it in n-1 days!"

[17:42] <tadzik> I'm updating parrot first to make sure I have the lineof patch in place

[17:47] <dalek> rakudo/nom: 93eb7cd | jonathan++ | tools/build/NQP_REVISION:

[17:47] <dalek> rakudo/nom: Get boolification fix from NQP.

[17:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/93eb7cd3ab

[17:47] <dalek> rakudo/nom: e28a5ff | jonathan++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[17:47] <dalek> rakudo/nom: Get Str, Int and Num boolification to take advantage of the new approach, so we can handle them more efficiently.

[17:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e28a5fffb5

[17:47] <tadzik> I'm not done with nqp compilation yet :P

[17:50] *** _twitch left
[17:50] *** wamba joined
[17:50] <tadzik> running time make on the old one

[17:51] <jnthn> tadzik: OK, I'm done with the bool stuff for the time being :)

[17:51] <tadzik> a'riht :0

[17:51] <tadzik> what's next, what's next? :)

[17:51] <tadzik> oh, maybe some lexical issues? :P

[17:52] <tadzik> pardon me, weird sense of humour today

[17:53] *** mj41 left
[17:58] <flussence> .oO( ok, graph plan C: let it keep generating bad fail counts, then fix the code and redo the data using all the TAP archives it's been uploading... )

[18:02] *** wamba left
[18:04] <tadzik> hehe, I remember how mad I was during gsoc when I had to wait 6 minutes for my machine to finish a full 'make'

[18:04] <tadzik> how mad I'll be _now_ :)

[18:05] <tadzik> moritz++ for telling me about 'make perl6', I wouldn't have finished otherwise :P

[18:06] <tadzik> make  1015.31s user 8.22s system 107% cpu 15:52.83 total

[18:07] <tadzik> now trying the shiny new stuff

[18:10] *** Reaganomicon left
[18:15] <jnthn> tadzik: OK. I'm working on some further improvements to setting compilation also.

[18:15] <tadzik> jnthn: you have my personal Thank You :)

[18:23] <tadzik> jnthn: CORE.setting -> pir alone is about 15% faster

[18:23] <tadzik> that's pretty something :)

[18:24] <moritz> jnthn: turns out my fix to t/harness accidentally landed in the master branch

[18:25] <tadzik> make  852.35s user 6.06s system 109% cpu 13:06.73 total

[18:25] <jnthn> tadzik: whoa.

[18:25] <tadzik> yeah, that's around 15% overall speedup :)

[18:25] <dalek> rakudo/nom: 068cad4 | moritz++ | t/harness:

[18:25] <dalek> rakudo/nom: [t/harness] use backslash on windows

[18:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/068cad4738

[18:25] <tadzik> jnthn++ all the way

[18:26] <flussence> (agh, getting this data out of that web interface is going to be a headache)

[18:27] <moritz> jnthn: at your convenience, please re-test :-)

[18:31] <jnthn> moritz: Thanks, trying it now while spectesting a patch to try and help setting compilation a little more.

[18:33] *** cexsum joined
[18:34] *** frhodes left
[18:47] *** pernatiy joined
[18:48] <sorear> good * #perl6

[18:51] <jnthn> moritz: Patch worked \o/

[18:51] <jnthn> moritz++

[18:51] <moritz> \o/

[18:54] *** tcell joined
[18:55] *** benabik left
[18:57] *** birdwindupbird joined
[18:58] *** mj41 joined
[19:02] <masak> sorear: \o

[19:09] <dalek> nqp: a0a9213 | jonathan++ | src/ (2 files):

[19:09] <dalek> nqp: Make a way to both set an object's SC and add it to the SC in a single op.

[19:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a0a9213b8b

[19:09] <dalek> nqp: 3088455 | jonathan++ | src/NQP/SymbolTable.pm:

[19:09] <dalek> nqp: Make use of add_object_to_cur_sc_past.

[19:09] <dalek> nqp: review: https://github.com/perl6/nqp/commit/308845540a

[19:10] *** kaare_ left
[19:12] *** tcell left
[19:16] <dalek> rakudo/nom: e24dd5c | jonathan++ | src/ (4 files):

[19:16] <dalek> rakudo/nom: Lessen the code we generate for creating container descriptors; should save us a bunch of PAST nodes when compiling the setting.

[19:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e24dd5c309

[19:16] <dalek> rakudo/nom: e14544e | jonathan++ | / (2 files):

[19:16] <dalek> rakudo/nom: Bump NQP_REVISION and take advantage of add_object_to_cur_sc_past, which should save us the creation of around 12,000 PAST nodes while building the setting. Also makes the output shorter.

[19:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e14544ef55

[19:17] * tadzik measures again

[19:26] <tadzik> I just had a conversation with someone, who thought of Parrot as a reference Perl 6 implementation, and claimed it often hangs and segfaults :/

[19:27] * flussence ...facepalm

[19:28] <tadzik> what do you expect? On facebook? :P

[19:29] <tadzik> Apparently someone has tagged my fake profile on my real picture from some party. People have no common sense at all

[19:29] <masak> tadzik: I've often thought that the bandwidth out of the echo chamber is almost exactly one RTF triplet. we have Parrot *and* various Perl 6 implementations, so that's already too much information to export outside of the Perl 6 community.

[19:30] <masak> tadzik: also, if you're on Facebook (which is in the business of selling your identity), don't expect any sympathy on being identified. ;)

[19:31] <tadzik> masak: I have an "I'm a Horse" account, needed to use that to get an info on some party. Also, I sometimes use it to download some music notes which want me to "log in with facebook"

[19:31] <sorear> masak: fwiw, I use a much more general definition of "memory leak" these days

[19:32] <sorear> masak: I think a memory leak is any bug-like thing that increases the asymptotic memory usage of a calculation

[19:32] <tadzik> make  646.25s user 5.11s system 109% cpu 9:53.21 total

[19:33] <tadzik> that's another serious speedup now

[19:33] <moritz> what was it before any patches?

[19:33] <jnthn> tadzik: What did we start out at today?

[19:33] <tadzik> 2006        tadzik | make  1015.31s user 8.22s system 107% cpu 15:52.83 total

[19:33] <moritz> rakudo: say (1015.31 - 646.25) / 1015.31

[19:33] <p6eval> rakudo 068cad: OUTPUT«0.363494893185333␤»

[19:34] <tadzik> I think the memory usage dropped as well, but it ended before I noticed, which is a good sign, isn't it :)

[19:34] <jnthn> OK, so this got us about the same improvement as the boolification one earlier.

[19:35] <tadzik> jnthn: how about I bring you a good Polish beer to our next meeting? :)

[19:35] <jnthn> \o/

[19:35] <tadzik> if that one was 15%, and now we have 35%, this one was even bigger it seems

[19:35] <jnthn> Whoa. :)

[19:35] <tadzik> jnthn: a few more commits and I'll even be able to have both Rakudo compilation _and_ web browser running :>

[19:36] * tadzik tries to catch the memory usage

[19:36] <jnthn> yeah, I'd be interested to know what drop in memory usage has been.

[19:36] <tadzik> It's at least 10% in here

[19:36] <tadzik> well, 10% of my system memory

[19:36] <tadzik> so like 60% instead of 70%

[19:37] <tadzik> rechecking

[19:38] <masak> sorear: interesting definition. I don't think I disagree offhand.

[19:39] <masak> sorear: I read your reasoning about MMD with interest. while I agree with jnthn about needing a real-world use case before changing any spec, I'm intrigued by the possibility of simplification.

[19:40] *** lue joined
[19:41] <lue> hello world o/

[19:41] <moritz> well, I think it was a concious choice not to rely on the depth of inheritance hierarchies

[19:41] <moritz> because it's kinda an implementation detail if a class inherits from another directly or indirectly

[19:42] <tadzik> 63% or something

[19:42] <tadzik> rakudo: say (70 - 63) / 63

[19:42] <p6eval> rakudo 068cad: OUTPUT«0.111111111111111␤»

[19:42] <tadzik> ee

[19:43] <tadzik> rakudo: say (70 - 63) / 70

[19:43] <p6eval> rakudo 068cad: OUTPUT«0.1␤»

[19:43] * tadzik slaps tadzik

[19:43] <tadzik> that wasn't too hard to calculate

[19:43] * lue feels the need to backlog

[19:43] <tadzik> jnthn: about 10% memory usage drop then

[19:43] <tadzik> lue: TL;DR: nom is now 35% faster :)

[19:44] <tadzik> (at compiling the setting)

[19:44] <masak> \o/

[19:45] <lue> o ̮o

[19:45] <lue> erm, I meant for a smily face :)

[19:45] <dalek> rakudo/nom: 2c0badb | jonathan++ | src/Perl6/SymbolTable.pm:

[19:45] <dalek> rakudo/nom: Generate less code (and less PAST nodes as a result) for parameter deserialization.

[19:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2c0badbfd8

[19:46] <colomon> "load_language" couldn't find a compiler module for the language 'perl5' -- any idea what what means when trying to install DBDI?

[19:46] <moritz> language 'perl5' would be provided by blizkost

[19:47] <jnthn> tadzik: There's another little one. I don't expect anything dramatic from that.

[19:48] <jnthn> Oh, actually...it's about 500KB less PIR generated :)

[19:48] <moritz> jnthn: have you looked into mls++'s diagnosis of MMD mem leaks?

[19:49] <jnthn> moritz: Yeah

[19:49] <jnthn> moritz: I was kinda waiting for him to appear so I could check in on the latest there.

[19:49] * tadzik tries it out

[19:49] <jnthn> moritz: I understand what's happening, anyways.

[19:50] <jnthn> OK, time to try and improve immediate-run compilation times, so we can spectest faster...

[19:50] <jnthn> (fwiw, I expect the boolification improvements probably do help the spectests too)

[19:51] <masak> rakudo: say "I am {qx[cd nom; git branch | grep ^*].substr(2).trim}, fear me!"

[19:51] <p6eval> rakudo 068cad: OUTPUT«I am nom, fear me!␤»

[19:51] <flussence> er... evalbot allows qx?

[19:51] <masak> apparently.

[19:51] <moritz> flussence: don't tell anybody :/

[19:51] <lue> I'm going to start writing a big blog post, and part of it will list some of the compatibility-breaking changes from P5->P6. My list so far is at https://gist.github.com/1191675 . Any suggestions?

[19:52] <flussence> k.

[19:52] <moritz> nom doesn't have a safe mode :(

[19:52] <masak> lue: Perl 5 is pretty Unicode-aware.

[19:52] <lue> [not necessarily "breaking", but stuff that makes transition a bit interesting]

[19:52] <flussence> try.rakudo has a safe mode - it stops working when you send it input :D

[19:52] <tadzik> (:

[19:53] * flussence goes to fix it again...

[19:53] <lue> Hm. I was under the impression it wasn't *that* good with unicode [good to know before I make myself look foolish :)]

[19:53] <masak> lue: if you mention sigil invariance, be sure to mention how the nice advantages of the variance in Perl 5 also work with the invariance in Perl 6.

[19:53] <masak> lue: Perl 5 is still better at unicode than Ruby, or Python, or Java, or (*snigger*) PHP.

[19:54] <masak> lue: see tchrist's recent PDF on the matter.

[19:54] <moritz> lue: p5 allows Unicode identifiers (under 'use utf8;'

[19:54] <moritz> )

[19:54] <masak> lue: I like -- and look forward to -- the point about operator clarification.

[19:54] <flussence> hey, it's not fair to compare feature support against a language that doesn't even implement the feature!

[19:54] <lue> .oO(*Everything* is miles better on the Unicode front than TεX and friends)

[19:55] <masak> lue: of course, from a certain angle, that exact point is simply a foolhardy break with a tradition since at least C.

[19:55] <masak> lue: TeX does utf-8 and has for quite some time.

[19:55] <moritz> masak: but it doesn't support arbitrary codepoints

[19:55] <lue> Well, typesetting *of* utf-8 is where I turn to XeLaTeX

[19:55] <masak> moritz: nod.

[19:55] <sorear> moritz: I never introduced the depth of inheritence hierarchies.

[19:56] <flussence> huh, I imagined TeX would be good at text processing...

[19:56] <sorear> colomon!!!

[19:56] <colomon> sorear!

[19:56] <moritz> sorear: but C# does, no?

[19:56] <moritz> sorear: I just wanted to stress that we don't want to steal that part

[19:56] <sorear> moritz: no C# does not

[19:57] <moritz> sorear: then we had quite some misunderstanding yesterday

[19:57] <colomon> sorear: I've ordered the book with the Kahan article with the suggested algorithms for complex elementary functions.

[19:57] <sorear> colomon: I left a comment on your blog

[19:58] <lue> flussence: TeX hasn't gained any new features since version 3, which was, oh...1989 [from the quick search I ran]

[19:58] <colomon> sorear: yes, saw it.

[19:58] <lue> [and according to Knuth, it ain't getting any new features anymore. Ever.]

[19:59] <moritz> that's ok as long as LaTeX evolves

[20:00] <tadzik> make  635.86s user 5.15s system 107% cpu 9:54.96 total

[20:00] <colomon> sorear++ # fixing sqrt

[20:00] <tadzik> notmuch, but still nice

[20:01] <lue> LaTeX 3 is supposed to fix that (as well as introduce commands better fit for modern desktop publishing needs), but it's been ~20 years in the making.

[20:04] <masak> LaTeX... 3? really?

[20:05] <masak> oh, Wikipedia says you're right.

[20:05] <sorear> LaTeX is just a macro package, no?

[20:05] <lue> I remember looking at it as one of the options for when I wanted Unicode typesetting [and read quite a bit about it]

[20:06] <sorear> how is it possible for LaTeX to change TeX's handling of input byte encodings?

[20:06] <masak> sorear: by being a preprocessor stage to TeX.

[20:07] <lue> sorear: I'm a bit curious about that too. That's why I would prefer to see TeX itself typset utf-8. [Trying to make utf-8 work with the outdated system TeX uses has to be a nightmare]

[20:07] <sorear> lue: look up "Omega"

[20:07] <sorear> iiuc it's a fork of TeX with Unicode support.

[20:08] <sorear> the TeX license lets you do whatever you want as long as you don't call the result TeX

[20:08] <lue> Xe(La)TeX was the best choice I ever made [unicode support *and* ability to use TTF/OTF fonts!]

[20:10] *** molaf left
[20:14] <lue> what are the benefits of variance that still apply to P6 with its invariance? [/me still looking]

[20:14] *** diegoviola joined
[20:14] <diegoviola> hi

[20:15] <diegoviola> can perl6 be used right now?

[20:15] <tadzik> lue: "No one official implementation", did you accidentally a word? :)

[20:15] <tadzik> diegoviola: yes

[20:15] <tadzik> perl6: say "yes"

[20:15] <diegoviola> wow

[20:15] <moritz> diegoviola: yes (though not for all use cases yet)

[20:15] <diegoviola> nice

[20:15] <p6eval> pugs, rakudo 2c0bad, niecza v9-8-gd3b0031: OUTPUT«yes␤»

[20:15] <diegoviola> what about the libraries?

[20:15] <tadzik> yapsi: say "yes"

[20:15] <tadzik> diegoviola: see modules.perl6.org

[20:16] <p6eval> yapsi: OUTPUT«Could not parse␤»

[20:16] <tadzik> yapsi: say 1

[20:16] <diegoviola> is the language spec completed or still in progress?

[20:16] <p6eval> yapsi: OUTPUT«1␤»

[20:16] <tadzik> fair enuogh, yapsi :)

[20:16] <moritz> diegoviola: it's still in progress

[20:16] <lue> tadzik: no I didn't

[20:16] <diegoviola> ok thanks

[20:16] <moritz> very much like the Java and C++ specs are in progress too

[20:16] <tadzik> diegoviola: I don't find the changes in the spec really visible from the end-user perspective

[20:17] <tadzik> lue: oh, okay

[20:17] <lue> [although I do admit that's likely an uncommon use of English]

[20:17] <tadzik> maybe it needs a comma

[20:18] <tadzik> but I'm not a comma expert

[20:19] <lue> Nah, then you'd have an extraneous comma. "There isn't an official implementation" would like be a better wording, I wrote it as "No one..." because it suited the bullet-point format better

[20:19] *** Limbic_Region joined
[20:19] <lue> erm, s/like//

[20:20] <tadzik> I have a feeling that adjectives should be comma-separated in this particular case. But as I say, I'm not a comma expert

[20:21] <diegoviola> perl6 has better support for OO than perl5? or perl6 needs something like moose?

[20:22] <lue> Ah, I see where that "," would go now. I didn't think of it there because in my mind I didn't pause there :) But yes, a comma there might make more sense

[20:24] <jnthn> rakudo: class Reply { has $.answer; method with($exp) { say "$.answer, $exp" } }; Reply.new(answer => "yes").with("you can do stuff like this")

[20:24] <p6eval> rakudo 2c0bad: OUTPUT«yes, you can do stuff like this␤»

[20:24] <jnthn> diegoviola: ^^ better support for OO :)

[20:24] <diegoviola> nice

[20:26] *** thou left
[20:32] <dalek> nqp: c1176fb | jonathan++ | src/HLL/SerializationContextBuilder.pm:

[20:32] <dalek> nqp: Expose whether we're in pre-comp mode or not.

[20:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c1176fb544

[20:32] <dalek> nqp: abbaf88 | jonathan++ | src/NQP/SymbolTable.pm:

[20:32] <dalek> nqp: Do less work when we're in immediate-run mode. This doesn't build up PAST trees that we're only going to end up throwing away (granted we threw them away quickly, but still...)

[20:32] <dalek> nqp: review: https://github.com/perl6/nqp/commit/abbaf88ef4

[20:33] <diegoviola> perl6 wont be compatible with the CPAN libraries from perl5 right?

[20:33] <diegoviola> libs have to be written from scratch?

[20:34] <diegoviola> for perl6

[20:34] <masak> diegoviola: there's a way to hook Perl 5 into Parrot/Rakudo. it's called blizkost.

[20:35] <diegoviola> nice

[20:35] <diegoviola> what is rakudo/

[20:35] <diegoviola> ?

[20:35] *** araujo left
[20:35] <diegoviola> Rakudo, a compiler based on Parrot.

[20:35] <masak> it's a Perl 6 implementation on Parrot.

[20:35] <masak> rakudo: say "The winning lottery numbers this week are: ", (1..50).pick(6)

[20:35] <p6eval> rakudo 2c0bad: OUTPUT«The winning lottery numbers this week are: 33 42 48 49 37 15␤»

[20:37] <diegoviola> very nice

[20:37] <diegoviola> ty

[20:37] <masak> rakudo: say "你的未来是充满不确定性和薄雾。"

[20:37] <p6eval> rakudo 2c0bad: OUTPUT«你的未来是充满不确定性和薄雾。␤»

[20:42] <donri> rakudo: say (^5).pick(10)

[20:42] <p6eval> rakudo 2c0bad: OUTPUT«4 1 0 2 3␤»

[20:42] <masak> rakudo: say (^2i).pick(-7)

[20:42] <p6eval> rakudo 2c0bad: OUTPUT«Method 'Num' not found for invocant of class 'Real'␤  in method Num at src/gen/CORE.setting:5163␤  in method reify at src/gen/CORE.setting:3410␤  in method reify at src/gen/CORE.setting:3502␤  in method gimme at src/gen/CORE.setting:3839␤  in method elems at src/ge…

[20:43] <tadzik> make spectest  1620.55s user 69.73s system 99% cpu 28:22.93 total

[20:43] <tadzik> I don't remember what was it before though :0

[20:43] <tadzik> :)

[20:43] <jnthn> ah :)

[20:44] <tadzik> while you're optimizing Rakudo, I'm optimizing my household :)

[20:44] <tadzik> (for the walking distance between stuff)

[20:44] <sorear> diegoviola: Eventually we plan to have CPAN available, but the details of how haven't been fully worked out yet.

[20:44] <tadzik> funnier than it sounds

[20:47] <masak> rakudo: say e.WHAT

[20:47] <p6eval> rakudo 2c0bad: OUTPUT«Num()␤»

[20:48] <masak> rakudo: say Real.new

[20:48] <p6eval> rakudo 2c0bad: OUTPUT«Real<57136064>␤»

[20:49] <masak> rakudo: say Real.new.Num

[20:49] <p6eval> rakudo 2c0bad: OUTPUT«Method 'Num' not found for invocant of class 'Real'␤  in <anon> at /tmp/Ur7jdjMqLL:1␤  in <anon> at /tmp/Ur7jdjMqLL:1␤␤»

[20:50] <diegoviola> sorear: nice

[20:50] <sorear> niecza: say "Hi"

[20:50] <p6eval> niecza v9-8-gd3b0031: OUTPUT«Hi␤»

[20:51] <colomon> ng: say "I live!"

[20:51] <jnthn> Apparently not... :)

[20:55] <masak> 'night, #Perl6

[20:55] *** masak left
[21:01] <donri> does it make sense to do marshalling at the parrot level (P6Opaque or what are they called?)?

[21:02] *** benabik joined
[21:04] <dalek> rakudo/nom: 1780b11 | jonathan++ | tools/build/NQP_REVISION:

[21:04] <dalek> rakudo/nom: Get latest NQP so we can use the extra info it has to be smarter about code-gen.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1780b11621

[21:04] <dalek> rakudo/nom: 8dfd5e2 | jonathan++ | src/Perl6/SymbolTable.pm:

[21:04] <dalek> rakudo/nom: Start to be smarter about pre-compilation mode vs. immediate run mode, so we generate less PAST that we throw away. Should improve non-precomp case somewhat (e.g. so we get faster spectest runs). Also marks out code that we'll be able to throw away when we have full deserialization.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8dfd5e2d79

[21:04] <dalek> rakudo/nom: ea5ff6b | jonathan++ | src/Perl6/SymbolTable.pm:

[21:04] <dalek> rakudo/nom: Refactor parameter object building and deserialization code-gen so we can avoid building more PAST in pre-comp mode.

[21:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ea5ff6b909

[21:04] <dalek> rakudo/nom: 0635961 | jonathan++ | src/Perl6/SymbolTable.pm:

[21:04] <dalek> rakudo/nom: Be smarter about compilation of code objects. Should be a (little) win both for setting compilation and for immediate-run compilation.

[21:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0635961a1f

[21:06] <sorear> donri: Insufficient context to understand question.

[21:06] <sorear> diegoviola: btw, welcome

[21:07] <diegoviola> ty

[21:07] <jnthn> tadzik: May be another little win there. Maybe.

[21:07] <donri> mainly pondering the potential of a perl6/parrot version of pickle in python

[21:07] *** araujo joined
[21:07] <donri> (duno the perl5 version)

[21:07] <diegoviola> parrot is very interesting, it seems like it's a virtual machine that will host other languages too?

[21:07] <diegoviola> similar to jvm or clr?

[21:07] <sorear> donri: we spell it Storable

[21:07] <diegoviola> or rubinius

[21:07] <tadzik> jnthn: trying

[21:07] <sorear> diegoviola: that's the propaganda, but a lot of people here don't completely buy it

[21:08] <diegoviola> sorear: oh

[21:08] <diegoviola> sorear: interesting nonetheless :)

[21:08] *** envi left
[21:08] <sorear> diegoviola: parrot has been de facto limited to Rakudo for ~10 years now.  it would be lovely if this could change, but I am not hopeful.

[21:08] <diegoviola> sorear: wow that's a very long time!

[21:08] <jnthn> heh, 10 years is longer than Rakudo has existed :)

[21:09] <tadzik> (:

[21:09] <sorear> jnthn: started in 2008, ne/

[21:09] <sorear> jnthn: I mean 2003

[21:09] <tadzik> interoperability between Perl6 and Ruby worked once upon a time

[21:09] <jnthn> sorear: I don't think pmichaud++ started working on a Perl 6 on Parrot compiler until...2005 or so?

[21:10] <benabik> Lots of other parrot languages come and go, but they tend to be one person projects and not last terribly long.

[21:10] <donri> "any" vm can run "any" language, it's just an intricate part of parrot's design

[21:10] <donri> "from the ground up"

[21:10] <sorear> what benabik said.

[21:10] <sorear> most parrot languages tend to stop working three months after the only developer moves on

[21:10] <plobsing> there are some exceptions. lua is remarkably stable.

[21:10] <sorear> nobody cares enough to keep them running

[21:11] <sorear> ditto interoperability.  afaict only Tene actually cares about that.

[21:11] <donri> hm i talked to someone who was doing python on parrot as as gsoc i think

[21:11] * sorear is wearing the cynic-hat atm

[21:11] <benabik> 2011 GSoC projects included Javascript and Python.

[21:11] <tadzik> sorear: cared *

[21:11] <donri> but avoiding pct i think, using python's own ast parser instead and generating pir from that i think

[21:11] <sorear> donri: gsoc is over, python on parrot will be dead by Christmas, 90-95% certain.

[21:12] <plobsing> interop works at a shallow level. interop at a deep level might not be worth the cost

[21:12] <diegoviola> I'm currently developing with Ruby, but I'm interested in Perl as well

[21:12] <diegoviola> it seems like ruby has many things in common with perl and vice versa

[21:12] <sorear> diegoviola: ruby was created to compete with perl

[21:12] <donri> https://bitbucket.org/lucian1900/puffin/overview

[21:13] <diegoviola> sorear: oh

[21:14] <plobsing> diegoviola: most dynamic languages are superficially similar. the devil is in the details. most have their own "one true object model".

[21:15] <diegoviola> plobsing: noticed. thanks

[21:15] <donri> to totally start a war, my idea of ruby is it's the worst parts of perl and python with none of the good parts ;)

[21:15] <diegoviola> i was trying to learn about python too but i disagree with their philosophy of "There should be one-- and preferably only one --obvious way to do it." -- I prefer the Perl way

[21:16] <donri> note that it's only saying "one *obvious* way"

[21:16] <donri> python is rather pragmatic about solving practical problems

[21:16] <plobsing> donri: and decorators are obvious?

[21:17] *** masonkramer joined
[21:17] <lue> I used to use Python until its lack of binding(a.k.a. pointers) and switch statements made me switch (I do like Perl philosophy better than Python)

[21:17] <donri> duno, i'm so used to them i'm probably biased

[21:18] <donri> lue: binding?

[21:18] <lue> rakudo: my $a = 3; my $b := $a; $b = 5; say $a;

[21:18] <donri> switch is easy: case = lambda x: y == x; if case(z): ...

[21:18] <p6eval> rakudo 2c0bad: OUTPUT«5␤»

[21:18] <diegoviola> I see programming as an art and the different way of solving problems is what really makes me curious about programming, if there was only 1 obvious way then programming would be boring to me

[21:18] <tadzik> jnthn: no win on settings compilation

[21:19] <sorear> diegoviola: btw, I'm working on Perl 6 on the CLR.

[21:19] <tadzik> or 5 seconds loss, but it may be nothing

[21:19] <diegoviola> sorear: cool

[21:19] <lue> I stopped when I needed to use a switch statement for 0x100 possible values, but there was no switch statement o.o

[21:19] <donri> diegoviola: being boring is one of python's strengths ;) jokingly - it's often not boring at all

[21:19] <diegoviola> donri: :)

[21:20] <sorear> lue: you should have used an array of function objects

[21:20] <diegoviola> donri: i'm sure it isn't

[21:20] <diegoviola> donri: and i respect a lot of the python philosophies and their people

[21:20] <donri> ruby folk love to do insane metaprogrammatic magic but i think python is actually more capable in that regard

[21:20] <diegoviola> donri: they're good ones, the philosophy

[21:20] <diegoviola> donri: how to?

[21:20] <jnthn> tadzik: yeah, I didn't expect much of one.

[21:20] <jnthn> tadzik: 5 seconds is likely noise.

[21:21] <tadzik> I think so

[21:21] <donri> (we just prefer to default to predictable APIs over kitty-level cuteness, when it isn't necessary)

[21:21] <tadzik> make  617.03s user 4.91s system 111% cpu 9:19.77 total

[21:21] <tadzik> jnthn: timing the spectest now

[21:21] <diegoviola> donri: i don't like metaprogramming that much really

[21:21] <donri> i probably like it a little too much for a pythonista

[21:21] <lue> This was in the days when I was a lone, isolated programmer. I would've never thought of that! [Lack of switch was just the straw that broke the camel---snake's back]

[21:22] <diegoviola> donri: i find metaprogramming can be hard to debug and more error prone

[21:22] <donri> in deed

[21:22] <donri> it can also make *some* code easier to write and read

[21:23] <donri> used sparingly and wisely and with proper techniques (e.g. python has full support for parsing itself into ast and compiling asts to executable code, unlike the string programming used in rubyland)

[21:23] <diegoviola> interesting

[21:24] <donri> of course, perl6 beats anyone at anything in these regards :)

[21:24] <jnthn> tadzik: d'oh, I busted the delegation test...think I see why :)

[21:24] <tadzik> jnthn: I'll just continue :)

[21:24] <jnthn> tadzik: sure

[21:24] <donri> (i would expect, anyway, i don't really know and particularly i don't know how much is actually implemented)

[21:24] <tadzik> didn't get there yet

[21:26] <donri> one thing i like in python, and perl6 seems to do this too, is it encourages "declarative" APIs over imperative ones (by contrast, DSLs in ruby tend to be imperative-esque)

[21:26] <diegoviola> so I don't understand much this "There should be one-- and preferably only one --obvious way to do it." -- Does Python wants to limit my choices as a programmer?

[21:26] <donri> ..for example those dreaded decorators ;)

[21:26] <tadzik> diegoviola: you can read it that way

[21:26] <tadzik> diegoviola: you can also read it as "everyone writes stuff similarly, so when you sit to sb else's code, it's more-less like sitting to yours"

[21:27] <donri> diegoviola: it's more of a manifesto of philosophy than any limitation in the language

[21:27] <tadzik> I've heard people thinking that of Java

[21:27] <diegoviola> interesting, thanks

[21:28] <tadzik> YMMV

[21:28] *** y3llow_ joined
[21:28] *** pothos_ joined
[21:28] <donri> it's also about consistency, for example python's support for "properties" - setters and getters with the same syntax as plain public attributes

[21:29] <donri> the "obvious" way to "set a property of an object" is to set an attribute on it, not to call a setSomeThing() method

[21:29] <donri> i forgot what the perl6 version is?

[21:30] <dalek> rakudo/nom: 5aac384 | jonathan++ | src/Perl6/SymbolTable.pm:

[21:30] <dalek> rakudo/nom: Fix bug introduced in parameter compilation improvements.

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5aac38409a

[21:30] *** pothos left
[21:30] *** pothos_ is now known as pothos

[21:30] <diegoviola> if it's for consistency sake then that's not bad

[21:30] *** y3llow left
[21:30] *** y3llow_ is now known as y3llow

[21:37] <sorear> donri: don't get me started on Perl 6 and "set a property of an obect".  IMO the current way this is handled is insane.

[21:38] <donri> ok :D

[21:38] <tadzik> jnthn: I get less 5 skipped subtests: 6 okay on t/spec/S12-enums/basic.rakudo

[21:38] <tadzik> Dubious, test returned 1 (wstat 256, 0x100) too

[21:38] <tadzik> but not the blead

[21:38] <donri> in python it is actually done via operator overloading of the attribute "operations"

[21:39] <donri> and a standard "protocol" implemented by the standard top-level "object"

[21:39] <jnthn> tadzik: "not the blead"?

[21:39] <tadzik> jnthn: not the latest git pull

[21:39] <donri> ruby special-cases methods named with a suffix equal sign

[21:39] <jnthn> tadzik: ah, probably related

[21:39] <jnthn> tadzik: It runs to completion here.

[21:40] <tadzik> okay

[21:41] <donri> hey does perl6 !private methods permit a public one with the same name (minus the exclamation)?

[21:42] <jnthn> rakudo: class Foo { method m() { }; method !m() { } }

[21:42] <p6eval> rakudo 2c0bad:  ( no output )

[21:42] <jnthn> It appears so :)

[21:43] <jnthn> (That's the result I expected...)

[21:43] <jnthn> They're kinda separate namespaces, and there's no ambiguity (e.g. you use a different calling syntax)

[21:43] <donri> yea me too, just checking

[21:51] <tadzik> jnthn: make spectest  1742.80s user 80.74s system 97% cpu 31:18.17 total

[21:51] <tadzik> looks like a slowdown :/

[21:51] <jnthn> Hm. :S

[21:52] <jnthn> That's...surprising.

[21:52] <jnthn> Given we should be building a bunch less PAST

[21:52] <tadzik> 3 minutes. Noise?

[21:52] <tadzik> hmm

[21:53] <jnthn> Unlikely.

[21:53] <jnthn> I mean, it's *possible* the cost of the check if higher than I expected.

[21:53] <jnthn> But that'd be odd also.

[21:53] <tadzik> hrm

[21:55] <tadzik> maybe I was doing more things in the background this time. Last run the laptop was closed and I was moving furniture around

[21:58] *** zby_home___ joined
[21:59] *** zby_home left
[22:10] *** zby_home___ left
[22:23] <donri> I wonder if "now - now" is a reliable way to measure rakudo performance over time

[22:24] <donri> rakudo: say now - now

[22:24] <p6eval> rakudo 5aac38: OUTPUT«-0.0507454535658835␤»

[22:24] <plobsing> perl6: say now - now

[22:24] <p6eval> rakudo 5aac38: OUTPUT«-0.0408330202861197␤»

[22:24] <p6eval> ..niecza v9-8-gd3b0031: OUTPUT«Unhandled exception: Cannot use value like Instant as a number␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 43 (CORE Any.Numeric @ 4) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /tmp/_wIe5iKSVU line 1 (MAIN mainline @ 2) ␤  at /ho…

[22:24] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&now"␤    at /tmp/PZrcry8PQO line 1, column 5 - line 2, column 1␤»

[22:25] <tadzik> b: now - now

[22:25] <p6eval> b 1b7dd1:  ( no output )

[22:25] <tadzik> b: say now - now

[22:25] <p6eval> b 1b7dd1: OUTPUT«-0.31058495821727␤»

[22:25] <plobsing> b?

[22:25] <tadzik> tee-hee

[22:25] <donri> s02 says instant-instant is supposed to yield a durationm

[22:25] <tadzik> plobsing: aka rakudo master

[22:25] <tadzik> alpha: say now - now

[22:25] <p6eval> alpha : OUTPUT«Could not find non-existent sub now␤in Main (file src/gen_setting.pm, line 324)␤»

[22:26] <tadzik> alpha, if you couldn't find it, how can you tell it's non-existent?

[22:27] *** finanalyst left
[22:27] *** finanalyst joined
[22:27] <tadzik> jnthn: make spectest  1831.57s user 80.22s system 96% cpu 33:01.72 total

[22:27] <tadzik> again. Not a noise then

[22:28] <jnthn> No, seems not. Hm

[22:28] <tadzik> that also means Linux did a pretty god job on the previous run, when I was converting djvu to pdf and browsing reddit :)

[22:29] <tadzik> or just the cpu scheduler

[22:29] <donri> rakudo: say (now - now).perl  # so it is a duration, just pretends to be a real

[22:29] <p6eval> rakudo 5aac38: OUTPUT«Duration.new(-33192/818525)␤»

[22:29] <jnthn> My profiler seems to think that when we're compiling the setting, we spend a load of time in gc_gms_is_pmc_ptr

[22:30] <jnthn> This essentially boils down to chasing a linked list of arenas.

[22:30] <tadzik> ouch

[22:30] <jnthn> It's actually the arena of PMC headers

[22:30] <donri> why isn't Whatever a constant/singleton

[22:30] <jnthn> Each of those holds about 200 PMCs

[22:30] <jnthn> er, PMC headers, that is.

[22:31] <jnthn> Well, on 64 bit I guess it's about 100 PMCs.

[22:32] <jnthn> And we do this every time we trace a memory block.

[22:32] <jnthn> For each pointer we find in it.

[22:33] <jnthn> (potential pointer)

[22:35] <tadzik> what is that PMC headers area? All the PMCs available?

[22:36] <donri> rakudo: (^100).pretty

[22:36] <p6eval> rakudo 5aac38: OUTPUT«Method 'pretty' not found for invocant of class 'Range'␤  in <anon> at /tmp/C_Tsg69OWa:1␤  in <anon> at /tmp/C_Tsg69OWa:1␤␤»

[22:36] <tadzik> rakudo: say (^100).gist

[22:36] <p6eval> rakudo 5aac38: OUTPUT«0..^100␤»

[22:36] <donri> NYI or spec outdated?

[22:38] <tadzik> may be a fossil

[22:39] <tadzik> time to sleep, see you tomorrow

[22:44] *** finanalyst left
[22:57] *** PacoLinux_ joined
[23:13] *** donri left
[23:14] <jnthn> sleep...that's a good idea &

[23:19] <sorear> niecza: say now.to-posix[0] - now.to-posix[0]

[23:19] <p6eval> niecza v9-8-gd3b0031: OUTPUT«-0.00159597396850586␤»

[23:19] <sorear> niecza: say times[0] - times[0]

[23:19] <p6eval> niecza v9-8-gd3b0031: OUTPUT«0␤»

[23:19] <sorear> \o/

[23:26] *** birdwindupbird left
[23:27] <jlaire> niecza: my @xs = map { now.to-posix[0] }, 1 .. 8; say @xs[1..7] Z- @xs[0..6]

[23:28] <p6eval> niecza v9-8-gd3b0031: OUTPUT«0.00141811370849609 9.20295715332031E-05 5.88893890380859E-05 6.50882720947266E-05 7.20024108886719E-05 6.98566436767578E-05 0.000208139419555664␤»

[23:28] *** woosley joined
[23:35] *** mj41 left
[23:36] *** Patterner left
[23:40] *** Psyche^ joined
[23:40] *** Psyche^ is now known as Patterner

[23:48] *** woosley left
[23:48] *** woosley joined
[23:51] *** dual left
[23:55] *** cexsum left
[23:58] *** woosley left
