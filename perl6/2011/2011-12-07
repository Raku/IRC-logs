[00:03] *** risou is now known as risou_awy

[00:15] *** toebu joined
[00:22] *** packetknife joined
[00:24] *** tokuhirom left
[00:25] *** whiteknight joined
[00:26] *** whiteknight is now known as Guest3133

[00:28] *** toebu left
[00:29] *** replore joined
[00:38] *** hundskatt left
[00:53] *** am0c joined
[00:55] *** Radvendii joined
[01:04] *** toebu joined
[01:06] *** abercrombie left
[01:07] *** abercrombie joined
[01:25] <Radvendii> i LOVE perl6s integration of unicode :D no more annoying 0x342Fs :D

[01:27] <Radvendii> what happened to .uc?

[01:27] <Radvendii> b: say <a,b,c>».uc;

[01:27] <p6eval> b 1b7dd1: OUTPUT«A,B,C␤»

[01:27] <Radvendii> oh

[01:28] <Radvendii> huh.

[01:29] *** am0c left
[01:30] <Radvendii> question though: what happened to `command` executing a command in the command line? how do i do that now?

[01:31] <Radvendii> b: "ls".exec

[01:31] <p6eval> b 1b7dd1: OUTPUT«Method 'exec' not found for invocant of class 'Str'␤  in main program body at line 22:/tmp/wHi4N5uTBE␤»

[01:31] <Radvendii> b: `ls`

[01:31] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Confused at line 22, near "`ls`"␤»

[01:35] <Radvendii> anyone?

[01:38] <Radvendii> b: q:x[ls]

[01:38] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤Colons may not be used to delimit quoting constructs at line 22, near ":x[ls]"␤»

[01:38] <Radvendii> b: qx[ls]

[01:39] <p6eval> b 1b7dd1: OUTPUT«Operation not permitted in safe mode␤  in 'Safe::forbidden' at line 2:/tmp/kXDkKbmO4G␤  in main program body at line 1:/tmp/kXDkKbmO4G␤»

[01:40] <Radvendii> never mind. i figured it out

[01:42] *** shinobicl_ joined
[01:44] *** plutoid joined
[01:45] <shinobicl_> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say "AAA" !== "BBB" ?? "Distinct" !! "Same" ;

[01:45] <p6eval> rakudo f70f20: OUTPUT«Same␤»

[01:46] <dalek> rakudo/nom: 66edf0b | moritz++ | / (2 files):

[01:46] <dalek> rakudo/nom: properly handle bigish numbers in Num.floor and .ceiling

[01:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/66edf0b6eb

[01:47] *** am0c joined
[01:50] <Radvendii> huh?

[01:50] <Radvendii> what's with that output?

[01:51] <shinobicl_> it should say "Distinct"

[01:51] <Radvendii> i know

[01:51] <Radvendii> htats really weird

[01:51] <Radvendii> try putting parens around the "AAA" !== "BBB" part?

[01:53] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say( ("AAA" !== "BBB") ?? "Distinct" !! "Same" );

[01:53] <p6eval> rakudo f70f20: OUTPUT«Same␤»

[01:53] <shinobicl_> rakudo: our multi infix:<**>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say "AAA" ** "BBB" ?? "Distinct" !! "Same" ;

[01:53] <p6eval> rakudo f70f20: OUTPUT«Distinct␤»

[01:54] <shinobicl_> The problem is with the "!=="

[01:54] <Radvendii> ah

[01:54] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say "AAA" &[!==] "BBB" ?? "Distinct" !! "Same" ;

[01:54] <p6eval> rakudo f70f20: OUTPUT«Not enough positional parameters passed; got 0 but expected 2␤  in sub <anon> at src/gen/CORE.setting:8515␤  in block <anon> at /tmp/erevJSopZd:1␤  in <anon> at /tmp/erevJSopZd:1␤»

[01:54] <shinobicl_> somehow i can't overload it

[01:54] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say &[!==]"AAA", "BBB" ?? "Distinct" !! "Same" ;

[01:54] <p6eval> rakudo f70f20: OUTPUT«===SORRY!===␤Confused at line 1, near "say &[!==]"␤»

[01:54] <Radvendii> what's the syntax?

[01:55] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say &[!==]( "AAA", "BBB") ?? "Distinct" !! "Same" ;

[01:55] <p6eval> rakudo f70f20: OUTPUT«Distinct␤»

[01:55] <Radvendii> there we go

[01:55] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say &[!==] === *!==*;

[01:55] <p6eval> rakudo f70f20: OUTPUT«WhateverCode.new()␤»

[01:56] <Radvendii> how do we tell if two things are just references to the same thing?

[01:56] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say &[!==] ~~ *!==*;

[01:56] <p6eval> rakudo f70f20: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:638␤  in sub infix:<==> at src/gen/CORE.setting:2178␤  in block <anon> at /tmp/wWquJRqr44:1␤  in <anon> at /tmp/wWquJRqr…

[01:56] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say &[!==] ~~ (* !== *);

[01:56] <p6eval> rakudo f70f20: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:638␤  in sub infix:<==> at src/gen/CORE.setting:2178␤  in whatevercode <anon> at /tmp/EmYYfHb0yc:1␤  in method ACCEPTS a…

[01:56] <moritz> Radvendii: strings are value types, so there's no difference between "the same string" and "references to the the same string"

[01:56] <shinobicl_> that's the error i'm having

[01:57] <shinobicl_> i can't overload !== for a specific datatype. It complains about the !== needing "Numeric"

[01:58] <Radvendii> no... if you use &[!==]($s1, $s2) as the function call it works. i think it's not parsing !== as the operator you defined

[01:58] <moritz> it has to do with !== normally being a meta operator

[01:58] <shinobicl_> ohh, i see

[01:59] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say &[!==]("aaa", "bbb");

[01:59] <shinobicl_> and === is a metaoperator too?

[01:59] <p6eval> rakudo f70f20: OUTPUT«Bool::True␤»

[01:59] <Radvendii> versus

[01:59] *** Sarten-X left
[01:59] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say "aaa" !== "bbb";

[01:59] <p6eval> rakudo f70f20: OUTPUT«Bool::False␤»

[02:00] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; (* !== *)==&[!==] ;

[02:00] <p6eval> rakudo f70f20:  ( no output )

[02:00] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say (* !== *)==&[!==] ;

[02:00] <p6eval> rakudo f70f20: OUTPUT«WhateverCode.new()␤»

[02:00] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say (* !== *)==&[!==] ?? "yes" !! "no" ;

[02:00] <p6eval> rakudo f70f20: OUTPUT«WhateverCode.new()␤»

[02:01] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say ((* !== *)==&[!==]);

[02:01] <p6eval> rakudo f70f20: OUTPUT«WhateverCode.new()␤»

[02:01] <Radvendii> rakudo: our multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say ((* !== *)==&[!==] ?? "yes" !! "no");

[02:01] <p6eval> rakudo f70f20: OUTPUT«WhateverCode.new()␤»

[02:01] <Radvendii> what the hell?

[02:02] <Radvendii> whatever. im pretty sure it's not recognizing !== as the operator you defined

[02:02] *** toebu left
[02:02] <TimToady> why are you using "our"?

[02:02] <TimToady> functions are lexically scoped in Perl 6

[02:03] <TimToady> perl6: my multi infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say( ("AAA" !== "BBB")  ?? "Distinct" !! "Same" );

[02:03] <p6eval> niecza v12-4-g8c09133: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 773 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 168 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/Niec…

[02:03] <p6eval> ..rakudo f70f20: OUTPUT«Same␤»

[02:03] <p6eval> ..pugs b927740: OUTPUT«Distinct␤»

[02:03] *** toebu joined
[02:07] *** Sarten-X joined
[02:10] *** wolfman2000 joined
[02:19] <TimToady> niecza: my multi infix:<!==>(Str $, Str $) { say "HERE" }; 'a' !== 'b'

[02:19] <p6eval> niecza v12-4-g8c09133: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 773 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 168 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/Niec…

[02:19] <TimToady> niecza: my sub infix:<!==>(Str $, Str $) { say "HERE" }; 'a' !== 'b'

[02:19] <p6eval> niecza v12-4-g8c09133: OUTPUT«HERE␤»

[02:20] <TimToady> perl6: my sub infix:<!==>(Str $s1, Str $s2) { return ($s1 ne $s2); }; say( ("AAA" !== "BBB")  ?? "Distinct" !! "Same" );

[02:20] <p6eval> rakudo f70f20: OUTPUT«Same␤»

[02:20] <p6eval> ..pugs b927740, niecza v12-4-g8c09133: OUTPUT«Distinct␤»

[02:20] <TimToady> LTM failure for rakudo, methinks

[02:20] <TimToady> mind, it's bad style to override metaoperators

[02:21] <shinobicl_> i din't know it was a metaoperator, my fault

[02:21] * moritz only mentioned it half an hour ago

[02:22] <dalek> mu: 53ff291 | moritz++ | misc/perl6advent-2011/topic-brainstorming:

[02:22] <dalek> mu: [advent] clean up topic list a bit

[02:22] <dalek> mu: review: https://github.com/perl6/mu/commit/53ff291ff0

[02:23] <shinobicl_> moritz: yes i remember :), i didn't know before that....     but is === a metaoperator too?

[02:23] <TimToady> no

[02:23] <TimToady> and it's only the ! that is the meta

[02:23] <TimToady> it's ordinarly applied to == when you say !==

[02:24] <TimToady> in += the = is a metaoperator

[02:24] <TimToady> in X=> it's the X

[02:24] <shinobicl_> i thought that, if "==" is the opposite of "!=", then the opposite of "===" should be "!=="

[02:25] <TimToady> != is just an alias to !==

[02:25] <shinobicl_> i fact i din't know it existed before trying to overload it

[02:25] <TimToady> metaops don't replace characters like that though

[02:26] <TimToady> there are currently 8 metaoperators, described in http://perlcabal.org/syn/S03.html#Meta_operators

[02:27] *** orafu left
[02:28] <shinobicl_> "To avoid visual confusion with the !! operator, you may not modify any operator already beginning with !."

[02:28] <shinobicl_> i'll use eq and ne then :)

[02:29] <TimToady> that's what they're there for

[02:29] <TimToady> like !=, ne is just an alias for !eq

[02:29] *** orafu joined
[02:38] *** shinobicl_ left
[03:03] *** Guest3133 left
[03:11] *** toebu left
[03:26] *** packetknife left
[03:27] *** kst left
[03:27] *** kst joined
[03:28] *** benabik joined
[03:30] *** s1n joined
[03:32] <pat_js> if I have a regex like /<foo>* |<bar>/ in a grammar, how can I access them in a Actions-object?

[03:32] <pat_js> with them I refer to $<foo> and $<bar>

[03:33] <pat_js> oh my regex is not the one I'm asking for, it's more like /[<foo>|<bar>]*/

[03:34] *** s1n2 joined
[03:34] *** s1n left
[03:35] *** shinobicl_ joined
[03:36] <TimToady> the bits should still show up in $<foo> and $<bar>

[03:37] <TimToady> if you'd used () instead of [], you'd need $0<foo> instead

[03:37] <pat_js> and the order?

[03:37] <japhb> moritz, it looks like you pushed a bump to NQP_REVISION in rakudo 66edf0b6eb , but didn't push nqp?

[03:37] *** molaf joined
[03:38] *** jimmy1980 left
[03:38] <TimToady> the subparts will be in the order matched, but you can't tell the relative order between the two lists unless you look at match positions

[03:39] <TimToady> actually, if you'd used ()*, then $0[*] would be the order, and each of those would contain either foo or bar

[03:40] <TimToady> often if you're starting to use $0, it means you really need a named subrule though

[03:40] <TimToady> so you'd match <foobar>*, and foobar would match foo or bar

[03:41] <TimToady> the standard grammar uses very few numbered captures

[03:41] <pat_js> I don't think that will work, because <foo> is, in my case a proto token and <bar> is a recursive call

[03:45] <TimToady> I meant <foobar>* would match <foo> or <bar>, so it isn't bothered by proto or recursion

[03:45] *** jimmy1980 joined
[03:45] <TimToady> that's no different from (<foo>|<bar>)*, except with a named rule

[03:47] <shinobicl_> perl6: multi infix:<op>(Int $n1, Int $n2) { return ($n1.log10.floor == $n2.log10.floor); }; say (1 op 9) ?? "Same" !! "Distinct"; say (1 op 11) ?? "Same" !! "Distinct"; 

[03:47] <p6eval> niecza v12-4-g8c09133: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 773 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 168 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/Niec…

[03:47] <p6eval> ..pugs b927740: OUTPUT«Same␤Distinct␤»

[03:47] <p6eval> ..rakudo f70f20: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[03:47] <TimToady> from the outside a named rule is simply that; it's invisible to the caller whether it's calling a proto, or something recursive

[03:48] <shinobicl_> perl6: multi infix:<eq>(Int $n1, Int $n2) { return ($n1.log10.floor == $n2.log10.floor); }; say (1 eq 9) ?? "Same" !! "Distinct"; say (1 eq 11) ?? "Same" !! "Distinct"; 

[03:48] <TimToady> (though it does change what is returned, of course)

[03:48] <p6eval> niecza v12-4-g8c09133: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 773 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 168 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/Niec…

[03:48] <p6eval> ..pugs b927740, rakudo f70f20: OUTPUT«Same␤Distinct␤»

[03:48] <japhb> shinobicl_, you can /msg p6eval as well, if you want to just play around and try things without an audience

[03:50] <TimToady> esp since niecza doesn't like the multi

[03:55] <shinobicl_> japhb: sorry, i just want to know something about the operator overloading...

[03:56] <shinobicl_> what should it happen if i declare an operator as "multi" but has not been defined yet?

[03:56] <TimToady> huh, my nom doesn't build

[03:56] <TimToady> error: pathspec '2011.11-110-g29cc6d8' did not match any file(s) known to git.

[03:56] *** donri left
[03:57] <TimToady> shinobicl_: it should autogen a proto for you

[03:58] <shinobicl_> rakudo: multi infix:<eqmag>(Int $n1, Int $n2) { return ($n1.log10.floor == $n2.log10.floor); }; say (1 eqmag 9) ?? "Same" !! "Distinct"; say (1 eqmag 11) ?? "Same" !! "Distinct";

[03:58] <p6eval> rakudo f70f20: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[03:58] <shinobicl_> rakudo: multi infix:<eq>(Int $n1, Int $n2) { return ($n1.log10.floor == $n2.log10.floor); }; say (1 eq 9) ?? "Same" !! "Distinct"; say (1 eq 11) ?? "Same" !! "Distinct";

[03:58] <p6eval> rakudo f70f20: OUTPUT«Same␤Distinct␤»

[03:59] *** JimmyZ joined
[03:59] <shinobicl_> so,, these two should return the same even if there is no a previous "eqmag" operator ?

[04:00] <JimmyZ> Hello, TimToady 

[04:00] <colomon> nom: multi infix:<eqmag>(Int $n1, Int $n2) { return ($n1.log10.floor == $n2.log10.floor); }; say (1 eqmag 9) ?? "Same" !! "Distinct"; say (1 eqmag 11) ?? "Same" !! "Distinct";

[04:00] <p6eval> nom f70f20: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤»

[04:01] <colomon> std: multi infix:<eqmag>(Int $n1, Int $n2) { return ($n1.log10.floor == $n2.log10.floor); }; say (1 eqmag 9) ?? "Same" !! "Distinct"; say (1 eqmag 11) ?? "Same" !! "Distinct";

[04:01] <p6eval> std be1f10e: OUTPUT«ok 00:01 127m␤»

[04:01] <colomon> shinobicl: Pretty sure you're looking at a (known) nom-bug.

[04:01] <shinobicl_> oh.. i see..thanks colomon!

[04:02] <colomon> so the answer is yes, they should return the same. 

[04:02] *** s1n2 left
[04:04] <pat_js> thanks a lot, another little question, I now got the right structure of lists, I want, but it is filled with Mu()s, is that ~$/ thing still working on Rakudo?

[04:06] *** envi_ left
[04:09] *** lestrrat left
[04:10] *** lestrrat joined
[04:10] <pat_js> ah sorry, had a typo in my method declarations

[04:14] *** robins joined
[04:20] *** dayangkun joined
[04:23] *** pat_js left
[04:25] <sorear> good * #perl6

[04:25] <phenny> sorear: 06 Dec 21:51Z <[Coke]> tell sorear that "make spectest" should be green again; all failures that were blocking it now have tickets.

[04:29] <sorear> colomon: in principle, it would be possible to factor out some of the ff logic into a function, but if I did that the arguments would have to be thunkified and it wouldn't save much ugliness

[04:31] <sorear> [Coke]: awesome

[04:32] *** am0c left
[04:32] *** am0c joined
[04:34] *** JimmyZ_ joined
[04:36] *** JimmyZ left
[04:36] *** JimmyZ_ is now known as JimmyZ

[04:37] *** am0c left
[04:51] <japhb> TimToady, in case you hadn't figured it out already, moritz's most recent commit bumped NQP_REVISION, but he'd forgotten to push nqp itself.  The solution is to git checkout HEAD^ , and then you should be able to build.

[04:52] *** vlixes joined
[04:59] *** shinobicl_ left
[05:01] *** molaf left
[05:02] *** dayangkun left
[05:03] *** dayangkun joined
[05:03] *** am0c^ joined
[05:08] *** ponbiki joined
[05:09] *** pat_js joined
[05:11] *** woosley joined
[05:19] *** dayangkun left
[05:19] *** dayangkun joined
[05:30] *** vlixes left
[05:32] *** xinming joined
[05:37] *** jimmy1980 left
[05:38] *** ageis left
[05:38] *** jimmy1980 joined
[05:43] *** yake joined
[05:46] *** yake left
[05:46] *** Radvendii left
[05:47] *** dayangkun left
[05:54] *** jeffreykegler joined
[05:55] *** jeffreykegler left
[05:58] <dalek> nqp: d5649fd | moritz++ | tools/build/PARROT_REVISION:

[05:58] <dalek> nqp: bump parrot revision to one that has the is_inf_or_nan opcode

[05:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d5649fdc78

[05:58] <moritz> evalbot rebuild nom

[05:58] <p6eval> OK (started asynchronously)

[06:00] <moritz> sorry about that

[06:02] *** am0c joined
[06:04] *** fridim_ left
[06:15] *** kaleem joined
[06:26] *** ponbiki left
[06:27] *** am0c^ left
[06:34] <pat_js> rakudo: sub infix:<±> ($a,$b) {($a-$b)..($a+$b)}; say 4 ± 1

[06:34] <p6eval> rakudo f70f20: OUTPUT«===SORRY!===␤Confused at line 1, near "say 4 \x{b1} 1"␤»

[06:34] <pat_js> that had worked a year ago, i think

[06:35] <pat_js> perl6: sub infix:<±> ($a,$b) {($a-$b)..($a+$b)}; 4 ± 1

[06:35] <p6eval> rakudo f70f20: OUTPUT«===SORRY!===␤Confused at line 1, near "4 \x{b1} 1"␤»

[06:35] <p6eval> ..niecza v12-4-g8c09133:  ( no output )

[06:35] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\177'␤decodeUTF8': bad data: '\177'␤»

[06:35] <moritz> b:  sub infix:<±> ($a,$b) {($a-$b)..($a+$b)}; say 4 ± 1

[06:35] <p6eval> b 1b7dd1: OUTPUT«345␤»

[06:35] <pat_js> who's b?

[06:36] *** fridim_ joined
[06:36] <moritz> an older rakudo version

[06:36] *** hundskatt joined
[06:41] *** replore left
[06:41] *** replore_ joined
[06:56] * Woodi want to note that current law in Poland delegalized "mass netto +- a little" on wrappings. Maybe similiar happens in all EU countries ? New standard is "epsilon" marked with "e" on wrapping...

[07:02] <geekosaur> hasn't that been an eu directive for a while?

[07:03] *** wtw joined
[07:15] *** koban joined
[07:20] <Woodi> yes, forced here in 2009

[07:22] *** JimmyZ left
[07:28] *** Sarten-X left
[07:34] <japhb> Moritz, I'm not sure if the Rakudo build is still broken, or if it's just me.

[07:36] *** Sarten-X joined
[07:37] <japhb> 2011.11-110 has a different checkin SHA1 than the one in NQP_REVISION

[07:38] <japhb> s/checkin/commit/ of course

[07:38] <japhb> sleep &

[07:46] *** lestrrat left
[07:47] *** lestrrat joined
[07:51] *** stepnem left
[07:51] *** mj41 joined
[07:54] *** hundskatt left
[08:04] *** fridim_ left
[08:09] *** mkramer joined
[08:14] *** jimmy1980 left
[08:20] *** jimmy1980 joined
[08:21] *** mkramer left
[08:25] *** robins is now known as robinsmidsrod

[08:34] *** mj41 left
[08:38] *** sftp left
[08:40] *** sftp joined
[08:45] *** cognominal left
[08:47] *** mj41 joined
[08:59] *** Trashlord left
[09:04] *** Trashlord joined
[09:07] *** grondilu joined
[09:07] <grondilu> perl Configure.pl --gen-nqp  =>

[09:07] <grondilu> error: pathspec '2011.11-110-g29cc6d8' did not match any file(s) known to git.

[09:07] <grondilu> Command failed (status 256): git checkout 2011.11-110-g29cc6d8

[09:07] <grondilu> ?

[09:12] *** cognominal joined
[09:13] *** tzhs joined
[09:17] *** lestrrat left
[09:19] *** lestrrat joined
[09:23] <dalek> rakudo/nom: 735d127 | moritz++ | tools/build/NQP_REVISION:

[09:23] <dalek> rakudo/nom: fix NQP revision, moritz--

[09:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/735d127fce

[09:26] <grondilu> thks :)

[09:32] <grondilu> nom: multi sub postfix:<!> (Int $n) { $n < 2 ?? 1 !! $n*($n-1) }; say 4!;'

[09:32] <p6eval> nom f70f20: OUTPUT«===SORRY!===␤Confused at line 1, near "say 4!;'"␤»

[09:32] <grondilu> this is still not working  :(

[09:33] <grondilu> oops, I meant: multi sub postfix:<!> (Int $n) { [*] 1 .. $n }; say 4!;'

[09:38] <jnthn> hmm...wonder how hard i would be to just put back the way it worked before

[09:38] <jnthn> er, IT would be...

[09:38] *** jimmy1980 left
[09:40] *** GlitchMr joined
[09:41] *** dakkar joined
[09:44] <jnthn> maybe I get chance to try it this evening...

[09:45] *** jimmy1980 joined
[09:46] *** envi_ joined
[09:49] *** toebu joined
[09:51] *** woosley left
[09:53] *** replore_ left
[10:03] *** cognominal_ joined
[10:07] *** cognominal left
[10:08] *** tzhs left
[10:12] *** plutoid left
[10:18] *** grondilu left
[10:21] *** bacek joined
[10:29] *** cognominal_ left
[10:29] *** cognominal_ joined
[10:36] *** bacek left
[10:53] *** bacek joined
[10:59] *** toebu left
[11:10] <moritz> hm

[11:11] <moritz> precompiled PIR with NaN and Inf in it seems to be broken again :/

[11:25] <dalek> nqp: aa20f03 | moritz++ | src/PAST/NQP.pir:

[11:25] <dalek> nqp: add nqp::isspecial_n alias for pir::is_inf_or_nan__In

[11:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/aa20f03f94

[11:35] *** serk17 joined
[11:37] *** toebu joined
[11:37] *** daxim joined
[11:58] *** benabik left
[11:59] *** toebu left
[12:01] *** daemon left
[12:04] *** daemon joined
[12:13] *** mkramer joined
[12:14] *** Patterner left
[12:17] *** mkramer left
[12:18] *** Psyche^ joined
[12:18] *** Psyche^ is now known as Patterner

[12:21] *** bluescreen10 joined
[12:32] <jnthn> moritz: I think I woulda preferred the NQP iop the mention inf and nan in its name rather than "special"

[12:32] <jnthn> *op

[12:32] <moritz> jnthn: what name would you prefer?

[12:37] <jnthn> isnanorinf would be clearer

[12:37] <jnthn> I think it's obvious enough that it only applies to num too

[12:38] <moritz> ok

[12:39] <moritz> jnthn: I'll do the rename today or tomorrow

[12:40] <jnthn> ok, no hurry :)

[12:41] *** packetknife joined
[12:41] *** Trashlord left
[12:42] *** Trashlord joined
[12:44] <dalek> nqp: 987cd89 | moritz++ | src/PAST/NQP.pir:

[12:44] <dalek> nqp: rename nqp::isspecial_n to isnanorinf

[12:44] <dalek> nqp: review: https://github.com/perl6/nqp/commit/987cd8977b

[12:46] <moritz> turns out I haven't pushed the usage of the nqp:: op anyway

[12:49] *** benabik joined
[12:50] <jnthn> aha :)

[12:50] *** serk17 left
[13:04] *** jimmy1980 left
[13:12] *** mishin joined
[13:19] <jnthn> heh...I told my students they could take a break for coffee and cake, and yet the whole class is still sat here hacking away! Developers. :)

[13:26] *** GlitchMr left
[13:27] *** baest joined
[13:34] *** risou_awy is now known as risou

[13:35] *** kaleem left
[13:36] <dalek> rakudo/nom: 7cb7f2a | moritz++ | / (2 files):

[13:36] <dalek> rakudo/nom: use nqp::isnanorinf op in rounders

[13:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7cb7f2a61f

[13:38] *** icwiener joined
[13:45] <raiph> %greet<en>

[13:45] <raiph> S06:1289	 "as the flattening C<*> does" is that a fossil?

[13:46] *** f00li5h left
[13:47] *** shinobicl left
[13:47] <benabik> raiph: I don't think so.  It's discussing the difference between sub foo(**@bar) and sub foo(*@bar)

[13:47] *** shinobicl joined
[13:49] <moritz> benabik is right

[13:49] <benabik> \o/

[13:49] * benabik is always unsure with spec questions, since I never read it _that_ carefully.

[13:51] <raiph> benabik, moritz: thanks

[13:54] *** koban left
[14:01] <moritz> phenny: tell mberends that the timing code in Test.pm has a wee problem -- the assignment to $time_after changes the return value, which should be True for passing tests, and False for failed ones. Now it's just always a timestamp

[14:01] <phenny> moritz: I'll pass that on when mberends is around.

[14:05] *** kaleem joined
[14:08] <moritz> nom: proto foo(|$) {*}; sub foo() { }

[14:08] <p6eval> nom 7cb7f2: OUTPUT«===SORRY!===␤Illegal redeclaration of routine 'foo' at line 1, near ""␤»

[14:08] *** Lab-7_ joined
[14:08] *** betterworld left
[14:09] *** betterworld joined
[14:09] *** icwiener left
[14:09] *** icwiener joined
[14:12] <dalek> roast: f4e1734 | moritz++ | S (6 files):

[14:12] <dalek> roast: Merge branch 'master' of git://github.com/perl6/roast

[14:12] <dalek> roast: review: https://github.com/perl6/roast/commit/f4e1734f19

[14:12] <dalek> roast: 3654c37 | moritz++ | S (2 files):

[14:12] <dalek> roast: simplify some tests

[14:12] <dalek> roast: review: https://github.com/perl6/roast/commit/3654c37c6e

[14:17] *** Lab-7_ left
[14:24] *** zantiosx joined
[14:25] <PerlJam> Am I imagining things or is compiling Rakudo taking even longer these days?  (I'd time it myself, but I don't want to wait for the compile again :)

[14:33] <moritz> it is rather slow

[14:33] <moritz> during my bigint work I've discovered that some routines in the actions are run twice

[14:34] <moritz> I guess it'd help if we avoided that :-)

[14:34] <benabik> Possibly due to backtracking.

[14:34] <benabik> Noticed that on some toy languages I wrote with nqp.

[14:35] *** am0c left
[14:35] <moritz> benabik: src/Perl6/Actions.pm contains not a single regex, just tokens and rules (which shouldn't backtrack)

[14:35] <moritz> of course there can still be failed alternatives that aren't LTM'ed

[14:36] <benabik> moritz: I thought rules backtracked. :-/

[14:36] *** jaldhar left
[14:36] <moritz> benabik: nope

[14:36] <moritz> rule implies :s :ratchet

[14:36] <benabik> huh

[14:36] <moritz> token implies just :ratchet

[14:38] <moritz> S05:549-551

[14:41] <dalek> rakudo/nom: 9fd40d8 | moritz++ | src/core/Num.pm:

[14:41] <dalek> rakudo/nom: fix Inf.perl

[14:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9fd40d8950

[14:47] <PerlJam> rakudo++  I had accidentally typed  $:foo when I meant :$foo and the error message I got told me so!  :-)

[14:47] <pmichaud_> ...why are we checking for nan/inf in ceil/floor?  Shouldn't the ceil/floor parrot ops do this also?

[14:50] <raiph> pmichaud: o/

[14:51] <pmichaud> raiph: o/

[14:52] *** zantiosx left
[14:53] <raiph> moritz recently wrote ".WHICH ... does object identity comparsion (like the === operator), but caching needs object equivalence comparsion (like the eqv operator)."

[14:53] *** kaleem left
[14:54] *** kaleem joined
[14:54] <moritz> pmichaud: because we can't box a NaN of Inf into an Int

[14:55] <pmichaud> ...can't   nqp::p6bigint take care of that, though?

[14:55] <raiph> what would be the equivalent of WHICH that does deep eqv?

[14:55] <moritz> raiph: nothing of that sort is specced

[14:56] <pmichaud> it seems like p6bigint needs to be smart enough to handle NaN and Inf anyway

[14:56] <moritz> pmichaud: maybe, but I'm not smart enough to do that :/

[14:56] <moritz> at least not efficiently

[14:57] <pmichaud> it's in src/ops/perl6.ops, line 502

[14:57] <[Coke]> pmichaud: o/

[14:57] <pmichaud> basically, check for NaN/Inf there

[14:57] <moritz> I don't think we're using that op anymore

[14:57] <pmichaud> it's shown in the patch you just submitted

[14:58] <moritz> but rather we use the nqp_bigint_* variants

[14:58] <pmichaud> oh, nqp::p6bigint is mapped somewhere else now? looking

[14:58] <moritz> oh, that's my mistake then

[14:58] <moritz> should be a different op

[14:58] <moritz> that returns an Int, not a Num for big-ish numbers

[14:58] *** JimmyZ joined
[14:59] <pmichaud> I look forward to seeing the updated patch :)

[14:59] <pmichaud> [Coke]: o/

[15:00] <pmichaud> afk again for a while  :-/

[15:00] <moritz> should use nqp::fromnum_I(..., Int)

[15:02] <pmichaud> then nqp::fromnum_I needs to be smart enough to handle NaN/Inf, I think :)

[15:02] <pmichaud> since NaN and Inf are valid num values

[15:17] *** tzhs joined
[15:28] *** molaf joined
[15:29] *** wtw left
[15:30] *** Patterner left
[15:31] <PerlJam> The advent calendar schedule looks empty for the next 4 days.

[15:31] <PerlJam> :(

[15:32] *** Psyche^ joined
[15:32] *** Psyche^ is now known as Patterner

[15:33] * colomon is working on an emergency post

[15:33] <PerlJam> colomon++

[15:34] <colomon> dunno if it will be any good or not, mind you. 

[15:34] <PerlJam> colomon: what's the topic?

[15:34] <jnthn> I may be able to do an emergency one, but could use a topic suggestion

[15:34] <colomon> currently "Adding a Feature to Niecza"

[15:35] <PerlJam> who's taking on the "ecosystem update" topic?

[15:35] <jnthn> So if there's anything you'd really like to see me write on... :)

[15:35] <PerlJam> it's not on the scheule and I don't think I've heard anyone mention it.

[15:35] <jnthn> tadzik++ would be the logical person for that, but I think he's quite tied up with stuff at the moment

[15:36] *** stepnem joined
[15:37] <colomon> isn't the ecosystem update at the moment "ecosystem just barely functional"?

[15:37] <colomon> I'd rather push that later and fix the ecosystem in the meantime.  ;)

[15:37] <PerlJam> sure.

[15:38] *** molaf left
[15:40] <colomon> nom: say 14.3.ceiling

[15:40] <p6eval> nom 9fd40d: OUTPUT«15␤»

[15:50] *** slavik1 joined
[15:51] <dalek> niecza: 0c3157b | coke++ | t/spectest.data:

[15:51] <dalek> niecza: Run this passing test.

[15:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0c3157ba97

[15:54] *** am0c joined
[15:57] *** mtk left
[15:58] *** mtk joined
[16:00] * Util is working on a `Idiomatic Perl 6 and Perl 6 Idioms` advent post

[16:01] <PerlJam> Util++

[16:02] <Util> (I am working on-site through Thu evening, and so have not committed to a posting date)

[16:02] *** raiph left
[16:03] *** tzhs left
[16:07] *** Radvendii joined
[16:09] <tadzik> jnthn: I'll be quite free after friday

[16:10] <jnthn> tadzik: yay!

[16:10] <jnthn> tadzik: Do you know what blocks ecosystem bootstrap still?

[16:10] <jnthn> Just Test::Mock tests?

[16:10] <tadzik> json tests as well, I believe

[16:11] <jnthn> ah, I thought moritz++ had taken care of those already

[16:12] <tadzik> oh, maybe

[16:14] *** alester joined
[16:17] *** kaare__ joined
[16:17] <PerlJam> I'm refactoring ff and adding the fff variants.  Does this look like a reasonable implementation? https://gist.github.com/1443400 

[16:18] <PerlJam> (secondly to that, when I compiled it just now and attempted to test it, I keep getting complaints:  Required named parameter 'x-left' not passed   So, I think I might be doing something wrong (or there's a bug))

[16:19] <jnthn> You can't factor out callerid like that.

[16:19] <jnthn> It'll bet the location of the infix.

[16:19] <jnthn> *get

[16:19] <jnthn> And not of the thing that called it.

[16:19] <PerlJam> I figured that :)  I just haven't worked out how to fix it yet.

[16:20] <jnthn> Doesn't fff need thunking?

[16:20] <PerlJam> also, I'm guessing there's a problem just using calledid anyway if there are multiple ff in the same scope

[16:20] <jnthn> ?

[16:21] *** buubot_backup left
[16:21] <jnthn> It's global state, per program position, no? 

[16:21] <jnthn> callerid gives you unique per bytecode location, not unique per scope..

[16:21] <PerlJam> ah, then that's good.

[16:22] <TimToady> it's still a hack--long term ff wants to be a macro that declares its own state

[16:22] <TimToady> all it really needs is a text macro

[16:23] <PerlJam> sure, I just wanted to see if I could get there without macros.

[16:23] <jnthn> TimToady: yeahbut masak++ didn't get macros far enough just yet 

[16:23] <TimToady> also, it won't work right with cloned closures, I suspect

[16:23] <jnthn> it's global state, no?

[16:24] <jnthn> not unique per closure?

[16:24] <TimToady> it's supposed to work like state vars, I think

[16:24] *** simcop2387 left
[16:24] <PerlJam> don't rain on my "good enough" parade.  we'll get a "perfect" parade when masak is doneish :)

[16:25] *** kaleem left
[16:25] <TimToady> admittedly this is less than specced

[16:25] <TimToady> but the original discussion on IRC involved state vars

[16:26] <PerlJam> anyway, I'm curious why the code I have keeps complaining about a "required 'x-left' parameter"

[16:26] *** simcop2387 joined
[16:26] <PerlJam> I thought you needed a ! suffix to make named params required

[16:26] <jnthn> TimToady: Fair enough. I'm not gonna fix it in this hack version though, I'll just wait for macros to be far enough along.

[16:27] <TimToady> no problem

[16:28] <jnthn> ok, my teaching is done for the day. Back to hotel...and then maybe finding something spicy to deal with my sore throat...

[16:28] <jnthn> bbl

[16:29] * JimmyZ wonders how about http://irclog.perlgeek.de/perl6/2011-12-03#i_4786939

[16:31] <dalek> specs: c4882a6 | larry++ | S03-operators.pod:

[16:31] <dalek> specs: ff/fff use anon state vars to clone right

[16:31] <dalek> specs: 

[16:31] <dalek> specs: jnthn++ and PerlJam++ for the alert

[16:31] <dalek> specs: review: https://github.com/perl6/specs/commit/c4882a6703

[16:32] <TimToady> JimmyZ: generally, you wouldn't put cached on a function that is not pure, so it doesn't matter whether its cache is shared if the function always returns the same thing

[16:34] <TimToady> ff and fff, on the other hand, are intrinsically impure

[16:34] <TimToady> (stateful)

[16:36] <PerlJam> JimmyZ: wrap *is* called.

[16:38] * TimToady wonders which of those JimmyZ wonders...

[16:39] *** buubot_backup joined
[16:41] <PerlJam> It looks like he's confused that he never sees "process" output to the screen and so thinks wrap is never called.  But wrap is called ... just on the $r inside the sub that immediately goes out of scope.

[16:43] <TimToady> $r is the sub that was passed in, and it should wrap in place, so it should show up in output

[16:43] <dalek> roast: 2652a39 | (Solomon Foster)++ | S32-num/ (2 files):

[16:43] <dalek> roast: Refudge for forthcoming Niecza patch.

[16:43] <dalek> roast: review: https://github.com/perl6/roast/commit/2652a39d3d

[16:43] <dalek> niecza: b5cc22a | (Solomon Foster)++ | / (3 files):

[16:43] <dalek> niecza: Properly handle NaN and +-Inf in rounding functions, add Cool.truncate, turn on S32-num/rounders.t.

[16:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b5cc22ad86

[16:45] <PerlJam> TimToady: shouldn't he need an "is ref" or "is rw" or something for that?  

[16:46] <TimToady> he's not assigning to it, he's just calling an object method that happens to be a mutator

[16:47] <TimToady> so I doubt this routine can enforce anything on that level

[16:49] <PerlJam> in any case ... wrap really is being called ... :-)

[16:49] <PerlJam> rakudo: rakudo: sub cached(Routine $r) { my %cache;$r.wrap(-> |$c {say 'process';my $key := $c.gist;%cache.exists($key) ??%cache{$key} !!(%cache{$key} = callsame)}); say $r(1); say $r(7) }; cached sub foo($a) {return 2 * $a;}; say foo(1);say foo(2);

[16:49] <p6eval> rakudo 9fd40d: OUTPUT«===SORRY!===␤Confused at line 1, near "rakudo: su"␤»

[16:49] <PerlJam> oops

[16:49] <PerlJam> rakudo: sub cached(Routine $r) { my %cache;$r.wrap(-> |$c {say 'process';my $key := $c.gist;%cache.exists($key) ??%cache{$key} !!(%cache{$key} = callsame)}); say $r(1); say $r(7) }; cached sub foo($a) {return 2 * $a;}; say foo(1);say foo(2);

[16:49] <p6eval> rakudo 9fd40d: OUTPUT«process␤2␤process␤14␤2␤4␤»

[16:50] *** pat_js left
[16:50] <TimToady> perl6: my $x = 2; $x //= say "hi"

[16:50] <p6eval> pugs b927740, niecza v12-5-g0c3157b:  ( no output )

[16:50] <p6eval> ..rakudo 9fd40d: OUTPUT«hi␤»

[16:50] <JimmyZ> jnthn write a trait one, which works

[16:50] <TimToady> you can use //= rather than ??!! after nom fixes //=

[16:51] <JimmyZ> TimToady:  https://gist.github.com/1423496#file_with+wrap

[16:51] <TimToady> well, assuming 'is cached' only applies to functions returning defined values

[16:53] <JimmyZ> it should not work with no any tips

[16:54] *** pat_js joined
[16:54] <dalek> roast: e993f8d | (Solomon Foster)++ | S32-num/rounders.t:

[16:54] <dalek> roast: Add tests to make sure the rounding functions are not cheating.

[16:54] <dalek> roast: review: https://github.com/perl6/roast/commit/e993f8dc30

[16:55] <colomon> I suspect that last push may add some failing tests in Rakudo

[16:55] <colomon> looking at it now...

[16:55] <colomon> but it will take a while to rebuild

[16:56] *** apejens left
[16:57] *** apejens joined
[16:57] * JimmyZ sleeps

[16:59] *** JimmyZ left
[17:03] *** Trashlord left
[17:04] *** mishin left
[17:08] *** MayDaniel joined
[17:08] *** serk17_ joined
[17:08] *** serk17_ left
[17:08] *** ab5tract joined
[17:09] *** pat_js is now known as patjs

[17:10] <jnthn> TimToady: There's an issue with sub foo(&r) { &r.wrap(...) }

[17:10] <jnthn> TimToady: Because when we pass the routine it gets closure semantics, and thus is cloned

[17:10] <jnthn> TimToady: Meaning we pass a clone that then gets modified.

[17:11] <jnthn> e.g. even if we replace the do properly of that, as per spec, it's doing it to the clone.

[17:12] <dalek> roast: fbba653 | (Solomon Foster)++ | S32-num/rounders.t:

[17:12] <dalek> roast: Fudge for rakudo.

[17:12] <dalek> roast: review: https://github.com/perl6/roast/commit/fbba65382d

[17:12] <colomon> okay, fixed rakudo's fudging.

[17:14] <colomon> all, this is my spare p6advent post draft: http://perl6advent.wordpress.com/2011/12/07/improving-niecza/

[17:14] <colomon> errr, http://perl6advent.wordpress.com/?p=846&preview=true

[17:15] <colomon> any feedback would be appreciated.  and yes, it needs a better name.

[17:18] *** ab5tract left
[17:18] <colomon> and a last paragraph summing it up.

[17:19] <jnthn> #phasers is tonight, yes?

[17:19] * jnthn notices he's the only one who preported and is wondering if he got the rong day :)

[17:20] <colomon> it is wednesday, I think

[17:20] <colomon> ;)

[17:21] <colomon> woah, I've actually been doing p6 stuff the last week

[17:23] *** MayDaniel left
[17:25] *** Sarten-X left
[17:29] <colomon> so, is #phasers in 1 minute?

[17:30] <colomon> or is it in two hours?

[17:30] * colomon is easily confused by UTC

[17:30] *** ab5tract joined
[17:32] *** Sarten-X joined
[17:34] * colomon is feeling very lonely on #phasers

[17:34] *** wolfman2000 left
[17:47] <felher> colomon: neither link works for me.

[17:47] <colomon> felher: you probably need to be logged into wordpress to successfully preview.  

[17:48] *** imarcusthis joined
[17:48] <felher> colomon: ah, you may be right about that :)

[18:00] *** fridim_ joined
[18:10] *** dakkar left
[18:10] *** flussence left
[18:22] *** mj41 left
[18:24] *** Radvendii left
[18:25] *** flussence joined
[18:26] *** Trashlord joined
[18:31] *** Chillance joined
[18:34] <sorear> good * #perl6

[18:39] *** hundskatt joined
[18:41] *** takadonet joined
[18:41] *** takadonet left
[18:42] <[Coke]> My wife made camel-shaped sugar cookies this week without realizing the perl-significance.

[18:42] *** icwiener left
[18:42] <[Coke]> I was tempted to send a box to TimToady, but then realized we'd have to add butterfly ones. ;)

[18:47] <colomon> oh, that would be awesome.  :)

[19:09] <dalek> rakudo/nom: 1022412 | coke++ | t/spectest.data:

[19:09] <dalek> rakudo/nom: track failure modes

[19:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1022412909

[19:27] * jnthn back

[19:27] * tadzik back

[19:27] <jnthn> and now full of Indisk nom

[19:28] *** kst left
[19:33] *** kst joined
[19:34] *** colorspace joined
[19:37] <colorspace> <evalbot> bash: rakudo:: command not found ):

[19:38] <tadzik> hm?

[19:38] <tadzik> rakudo: say 'command found'

[19:38] <p6eval> rakudo 102241: OUTPUT«command found␤»

[19:39] <colorspace> oops i was messaging evalbot

[19:41] <benabik> A bash shell in IRC?  That's an interesting choice.

[19:43] <colorspace> so im trying to do this: for 1..64 -> $x, $y, $z { $x.say; } but i get an error on the final iteration because % 3 > 0; is there a way DWIM?

[19:45] <colorspace> a way to do what i mean, rather**

[19:46] <benabik> nom: for 1..64 -> $x, $y = 0, $z = 0 { $x.say }

[19:46] <p6eval> nom 102241: OUTPUT«1␤4␤7␤10␤13␤16␤19␤22␤25␤28␤31␤34␤37␤40␤43␤46␤49␤52␤55␤58␤61␤64␤»

[19:46] <tadzik> oh, I didn't know about that :)

[19:46] <benabik> nom: for 1..64 -> $x, $?y, $?z { $x.say }

[19:46] <tadzik> benabik++

[19:46] <p6eval> nom 102241: OUTPUT«===SORRY!===␤In signature parameter, '$?y', it is illegal to use '?' twigil at line 1, near ", $?z { $x"␤»

[19:47] <tadzik> nom: for 1..64 -> $x, $y?, $z? { $x.say }

[19:47] <p6eval> nom 102241: OUTPUT«1␤4␤7␤10␤13␤16␤19␤22␤25␤28␤31␤34␤37␤40␤43␤46␤49␤52␤55␤58␤61␤64␤»

[19:47] <benabik> That's what I meant.

[19:47] <benabik> tadzik++

[19:47] <tadzik> nom: for 1..62 -> $x, $y?, $z? { $x.say }

[19:47] <p6eval> nom 102241: OUTPUT«1␤4␤7␤10␤13␤16␤19␤22␤25␤28␤31␤34␤37␤40␤43␤46␤49␤52␤55␤58␤61␤»

[19:47] <tadzik> hmm

[19:47] <colorspace> ohhh nice

[19:47] <tadzik> nom: for 1..62 -> $x, $y = 0, $z = 0 { $x.say }

[19:47] <p6eval> nom 102241: OUTPUT«1␤4␤7␤10␤13␤16␤19␤22␤25␤28␤31␤34␤37␤40␤43␤46␤49␤52␤55␤58␤61␤»

[19:47] <tadzik> I'm not sure what I expect ;P

[19:47] <benabik> colorspace: The bit between -> and { is a signature.  So you can use optional and default params.

[19:48] <benabik> Named params are not so useful.  :-)

[19:48] <colorspace> thanks for the info! perl6 is very fun to play around with

[19:48] *** jferrero joined
[19:48] *** bluescreen10 left
[19:48] <tadzik> I'm glad to hear that :)

[19:50] *** molaf joined
[19:55] *** ab5tract left
[19:57] <[Coke]> bah, no readline on feather?

[20:05] *** donri joined
[20:07] *** ab5tract joined
[20:13] *** colorspace left
[20:14] <Util> (when the time comes) how do I post my day's article to perl6advent ?

[20:16] <felher> Oh, cool, take doesn't need to have a lexical gather :)

[20:18] <Util> felher: I just looked at that this morning.

[20:18] <Util> http://perlcabal.org/syn/S04.html#The_gather_statement_prefix

[20:18] <Util> if a gather lexically contains any take calls, it is marked as lexotic-only, and it will be invisible to a dynamic take.

[20:18] <Util>  If the gather contains no take lexically, it by definition cannot be the lexotic target of any take, so it can only harvest dynamic take calls.

[20:19] <felher> yeah, that is really cute :)

[20:19] <Util> I wanted to mix lexical and dynamic `take` within one `gather`.

[20:19] <Util> To make it work, just define somthing like:

[20:20] <Util>     sub take-dynamic ($item) {take $item}

[20:20] <Util> and use it in place of the lexical `take`

[20:21] <felher> Util: yep, nice one :)

[20:21] <Util> I did not actually try the code; I was just positing an example in my own notes.

[20:22] <Util> dynamic `take` allows for smoother refactoring of complex list-building code.

[20:26] <felher> yeah :)

[20:26] *** Moukeddar joined
[20:28] <colomon> "...though armed with mighty compilers and code weapons..." -- Grail, Elizabeth Bear, page 305

[20:33] *** molaf left
[20:36] *** localhost left
[20:37] *** localhost joined
[20:38] <Util> colomon: I bet a release manager will choose that as a epigram.

[20:39] <Util> (or is that epigraph?)

[20:40] <Util> Oh, it is:  http://perl5.git.perl.org/perl.git/blob/HEAD:/Porting/epigraphs.pod

[20:42] *** daxim left
[20:44] *** benabik left
[20:47] *** Moukeddar left
[20:53] <moritz> nom: my $x = (1, 2, 3); .say for nqp::p6decont($x)

[20:53] <p6eval> nom 102241: OUTPUT«1␤2␤3␤»

[20:53] <moritz> jnthn: that's the reason why take [1, 2] flattens

[20:53] <moritz> nom: my $x = (1, 2, 3); .say for $x

[20:53] <p6eval> nom 102241: OUTPUT«1 2 3␤»

[20:54] <moritz> take() calls decont to ensure that no lvalues are returned

[20:54] <moritz> and at the same time kills the "I'm a scalar" flag

[20:54] * moritz -> really sleep

[20:59] <dalek> rakudo/nom: 64fd762 | jonathan++ | src/Perl6/Grammar.pm:

[20:59] <dalek> rakudo/nom: Add back the custom operator handling as we did it in ng. It needs re-doing, but that'll take the QRegex bootstrap, which - miracles aside - isn't going to be done before the December release. In the meantime, this unregresss the feature.

[20:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/64fd762bbb

[21:19] <tadzik> jnthn++

[21:20] <jnthn> I'll hope @other worry about the spectests for that :)

[21:31] *** miso2217 joined
[21:32] *** miso2217 left
[21:47] <dalek> features: 9695c5a | jonathan++ | features.json:

[21:47] <dalek> features: Update nom features.

[21:47] <dalek> features: review: https://github.com/perl6/features/commit/9695c5abc9

[21:49] *** aindilis left
[21:50] <jnthn> moritz: Example of "combinations of % and :s"?

[21:50] *** aindilis joined
[21:58] <dalek> nqp: 73e0060 | jonathan++ | src/QRegex/P6Regex/Actions.nqp:

[21:58] <dalek> nqp: Add missing setting of ignorecase flag.

[21:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/73e006085a

[21:58] <dalek> nqp: 2695eea | jonathan++ | src/QAST/Compiler.nqp:

[21:58] <dalek> nqp: Implement ignorecase subtype in literal. Well, try to - for some reason it seems to need ICU, which I don't have to hand. :-( Testing and Rakudo version bump welcome from anyone who does.

[21:58] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2695eeadfa

[21:59] *** kaare__ left
[22:07] <jnthn> sleep &

[22:12] *** djanatyn left
[22:13] *** Tene left
[22:16] *** wolfman2000 joined
[22:19] *** djanatyn joined
[22:20] *** Tene joined
[22:20] *** Tene left
[22:20] *** Tene joined
[22:24] *** skangas left
[22:29] *** Chillance left
[22:35] *** alester left
[22:36] <tadzik> nom: my @a := 1;

[22:36] <p6eval> nom 64fd76: OUTPUT«Type check failed in binding␤  in block <anon> at /tmp/30JSV8LAgZ:1␤  in <anon> at /tmp/30JSV8LAgZ:1␤»

[22:39] <tadzik> nom: my $a = 0; { warn "blah"; CATCH { $a++ } }; { warn "blah"; CONTROL { $a++ } }; say $a

[22:39] <p6eval> nom 64fd76: OUTPUT«blah␤blah␤1␤»

[22:42] *** Radvendii joined
[22:43] *** am0c left
[22:51] *** Radvendii left
[22:51] *** Radvendii joined
[22:53] *** donri left
[22:54] *** donri joined
[22:56] *** Sarten-X left
[23:02] <sorear> good * #perl6

[23:02] <tadzik> hello sorear 

[23:03] *** donri left
[23:04] *** donri joined
[23:07] *** Sarten-X joined
[23:15] <colomon> \o

[23:17] *** SHODAN joined
[23:28] *** fridim_ left
[23:29] *** wolfman2000 left
[23:34] *** tokuhirom joined
[23:38] *** huf joined
[23:41] *** envi_ left
[23:44] *** packetknife left
[23:45] *** patjs left
[23:50] *** packetknife joined
[23:51] *** kfo left
[23:52] *** kfo joined
[23:53] <[Coke]> sorear: o/

[23:58] * sorear decides to de-prioritized grapheme mode for now

[23:58] <sorear> I'll make :codes work more like UTS18

[23:59] *** wolfman2000 joined
