[00:32] *** Chillance left
[00:47] <sorear> would anyone complain too loudly if I made . match a single codepoint in :codepoints mode?

[00:47] *** jimmy1980 left
[00:48] *** fridim_ left
[00:48] <sorear> I am mostly having :codepoints track UTS18 semantics, but UTS18 strongly encourages . be made to match CR-LF as a unit

[00:48] <sorear> CR-LF is a single extended grapheme, so I'll make . match CR-LF in :graphs mode

[00:48] *** jimmy1980 joined
[00:49] *** wolfman2000 joined
[00:50] <colomon> sorear++ # ha!

[00:52] *** snearch left
[00:52] <sorear> colomon: huh?

[00:53] <colomon> " Improve documentation of Builtins.cs functions for colomon"

[00:53] <sorear> ah

[00:53] <colomon> not saying I didn't need it.

[00:53] <colomon> just amused that you put it that way.

[00:58] *** molaf_ joined
[01:01] *** molaf left
[01:05] <djanatyn> woo, got first place at our school's programming competition.

[01:05] <djanatyn> And I made a pretty fun little webapp

[01:05] <djanatyn> now I can go back to doing perl6 GCI tasks!

[01:27] <donri> GCI?

[01:32] *** am0c joined
[01:34] *** hundskatt left
[01:49] <lichtkind> good night

[01:49] *** lichtkind left
[01:53] *** jaldhar joined
[01:55] *** jimmy1980 left
[01:56] *** jimmy1980 joined
[02:14] *** Chillance joined
[02:15] <djanatyn> donri: google code-in

[02:15] <djanatyn> GSOC for pre-university students

[02:17] *** leprevost joined
[02:25] *** orafu left
[02:29] *** orafu joined
[02:31] *** leprevost left
[02:38] *** jimmy1980 left
[02:39] *** Chillance left
[02:40] *** jimmy1980 joined
[02:47] *** tokuhirom joined
[02:47] *** donri left
[02:56] *** jimmy1980 left
[03:02] *** jimmy1980 joined
[03:05] *** Guest97044 left
[03:12] *** jimmy1980 left
[03:18] *** jimmy1980 joined
[03:29] <sorear> TimToady: ping.  Why do we have both \v and \n?

[03:31] <sorear> S05 makes clear that the only difference between the two is CRLF handling

[03:53] *** og01 joined
[03:56] *** yeltzooo joined
[04:13] *** jimmy1980 left
[04:18] *** thou left
[04:20] *** jimmy1980 joined
[04:24] *** JimmyZ joined
[04:24] *** jimmy1980 left
[04:31] *** jimmy1980 joined
[04:40] *** thou joined
[04:42] <dalek> niecza: b1b54fc | sorear++ | lib/Builtins.cs:

[04:42] <dalek> niecza: Add support for supplementary characters to chr and ord

[04:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b1b54fcd7b

[04:49] *** JimmyZ left
[04:56] *** abercrombie joined
[04:59] <Timbus> if you shouldn't use exceptions for non-exceptional situations, what do you do when you have an error, but it's not a problem? (general programming related question, not just perl 6)

[05:00] *** thou left
[05:00] <Timbus> like i have a hardware module i made in moose/p5. it queries the device and gets a numerical value, but sometimes the device can only give an 'overrange' value as a response

[05:01] <Timbus> so, the method get_value() should.. throw an exception, return undef, comedy third option?

[05:03] <sorear> 1 or 2 depending on circumstances

[05:03] <sorear> 2 is probably better here

[05:03] <sorear> or return 'overrange'

[05:03] <japhb> In straight Perl 5 I would probably return undef.  In Perl 6 I would fail

[05:03] <sorear> exceptions are useful when there's no point continuing

[05:04] <sorear> like, if the hardware module doesn't seem to be present at all, you should throw an exception

[05:04] <Timbus> well overrange just means 'ignore the result this time, try again in a second or two'

[05:04] <sorear> because it makes no sense to continue running if the hardware isn't there

[05:04] <japhb> ... and the flip side of that is if the hardware just has occasional blips, then you don't need an exception, you just need an in-band error marker

[05:05] <Timbus> like returning maxint or something?

[05:05] <japhb> Timbus, well, that's why I suggested undef.  It really means "there's nothing here that makes sense"

[05:05] <japhb> Without blowing up.

[05:05] <Timbus> what if there are multiple reasons to return undef

[05:06] <Timbus> eg, device is in use already, overrange, has nothing to say,

[05:06] <japhb> And sorear is absolutely right that actual persistent malfunction or missing hardware should throw an exception (that the higher levels should probably catch and work with the user to resolve)

[05:06] <Timbus> yeah ive got that covered

[05:06] <sorear> then return an error code

[05:07] <sorear> if there are multiple reasons to return an in-band failure

[05:07] <japhb> Also, remember that in Perl, you can return more than one value.

[05:07] <Timbus> that's my curret method

[05:07] <japhb> You can return a measurement and a status code every time

[05:07] <Timbus> return (undef, $error)

[05:07] <sorear> also consider that you might have some failures that should throw, and other failures that shouldn't

[05:08] * sorear is still dubious of the value of Failure

[05:08] <Timbus> but it feels clunky and odd to leave this up to the user to figure out what is going on

[05:08] <Timbus> even though in this case, im the user as well

[05:09] <japhb> sorear, to me Failure means "The library reports status, the caller decides policy".  Which IMO is a major improvement over the Perl 5 world of "The library tries to set policy, and the caller works around it."

[05:09] *** BooK joined
[05:09] *** awwaiid joined
[05:09] *** felher joined
[05:09] *** jjore joined
[05:10] <japhb> .oO( Minor netsplit, or coincidence? )

[05:11] *** Helios joined
[05:11] <sorear> japhb: it actually reduces encapsulation because use fatal only goes one level down

[05:12] <sorear> japhb: die "foo" and some_function_that_calls_die are the same from a user POV; not so with fail!

[05:12] <sorear> japhb: not a netsplit

[05:12] <sorear> if it were a netsplit, they'd have quit [*.net *.split]

[05:13] <japhb> sorear, fair enough -- but on my screen a half dozen users timed out in quick succession.

[05:13] <japhb> Server reboot?

[05:14] <sorear> my best guess is a glitch in the international routing system

[05:14] <japhb> Anyway ... if Failure is outside of Any, and infectious like NaN, I would think 'use fatal' begins to make more sense to the user.

[05:14] <sorear> a server reboot would manifest as a netsplit

[05:15] <sorear> japhb: neither of those assertions about Failure match my current knowledge

[05:15] * japhb shrugs ... I never studied the IRC protocol

[05:15] <sorear> this isn't something that IRC actually specs

[05:15] <sorear> it's freenode behavior

[05:15] <japhb> Ah

[05:15] <sorear> I've seen server reboots before

[05:15] <japhb> I said three things in that one message, which two were you saying don't match your understanding?

[05:16] <sorear> japhb: outside of Any & infectious

[05:17] <japhb> sorear, spec commit 3c53f87

[05:28] <dalek> niecza: a8ad0e9 | sorear++ | lib/Cursor.cs:

[05:28] <dalek> niecza: Make non-LTM regex primitives surrogate character aware

[05:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a8ad0e9954

[05:35] *** jimmy1980 left
[05:35] <moritz> good morning

[05:36] <sorear> japhb: it's an improvement but it's still far too easy to lose failures that way

[05:36] *** jimmy1980 joined
[05:37] <sorear> japhb: also, note that sinking a failure produces an exception

[05:37] <japhb> ... which makes total sense to me, since it is easy to not sink

[05:37] <sorear> japhb: so if a failure is generated inside a library, it's quite likely that what the user sees will be an exception

[05:37] <japhb> Hmmm

[05:38] <sorear> I came around on junctions.  It's possible I may yet come to support Failure

[05:38] * moritz still wonders if "use fatal" shouldn't be the default

[05:38] <japhb> IWBNI there were a way to simply say "I know this might fail, but I don't want to deal with it, just pass it directly up to my caller"

[05:41] <sorear> japhb: you can make that happen by default, all you have to do is use exceptions instead

[05:42] <sorear> { my $x = (try foo); say $x.defined } isn't that much worse than { my $x = foo; say $x.defined; }

[05:43] <sorear> failures optimize for the sites where errors are handled at the expense of making semantic analysis of propagation sites harder

[05:43] <japhb> I'm saying, without the ability to intentionally and easily pass a Failure along *as a Failure*, it takes some of the wind out of the value of 'use fatal' and 'no fatal'

[05:44] <sorear> TimToady likes to play the parallel processing card, but it has always seemed to me that if there is an unrecoverable error somewhere in an expression, it doesn't actually make sense to evaluate the rest of the subexpressions

[05:44] <sorear> japhb: s/some/most/

[05:45] <sorear> but I agree with that complaint

[05:45] <japhb> sorear, but it's not subexpressions he's worried about.  He's talking about expressions in separate data "threads" (in the GPGPU sense)

[05:46] <japhb> It is quite easy for some copies of an expression to hit a boundary condition or bad input data, and other copies to be perfectly valid.

[05:49] <sorear> japhb: if some threads are hitting a boundary condition that you didn't test for, you have buggy code

[05:49] <sorear> when I find a bug in my programs, I want them to _stop_

[05:50] *** media-786 joined
[05:50] <sorear> keep-going-after-crashes is a very bad policy

[05:51] <sorear> unless it's being done explicitly and with measures in place to contain data corruption

[05:51] <sorear> a non-handwavey, _sane_ use case is a necessary condition for me to think something is a good ide

[05:51] <sorear> a

[05:52] <Timbus> does this extend to using undef in like numeric operations and stuff?

[05:52] <Timbus> because i see a use in that

[05:53] <japhb> sorear, Imagine you are shading just the foreground objects in a graphics scene.  You draw a full-screen quad and run a pixel shader "thread" on each pixel in the scene.  The output of your shader will be written to the screen buffer if it is valid data.  The foreground is a sphere, so necessarily there are pixels that will be correctly shaded, and others that should not be shaded with this shader.  How do you cleanly run them all in paral

[05:53] <japhb> lel, making it easy to (in parallel) decide which shader outputs should be written to the screen buffer?

[05:54] <sorear> Timbus: undef and NaN are different because they have more sensible meanings

[05:54] *** birdwindupbird joined
[05:54] *** birdwindupbird left
[05:55] <Timbus> yes

[05:55] <sorear> japhb: you return rgba (0,0,0,0) from the shader when you need a hole

[05:55] <japhb> I'm saying the output of the shader, if it is a valid rgba value, is written *directly* to the screen buffer, not blended.

[05:55] <moritz> you can use $pixel // $black  or  $pixel orelse $black  for that

[05:56] <japhb> moritz, are you suggesting sending a type object through?  Or are you agreeing that Failure is the right thing to return?

[05:57] <sorear> japhb: you need to return an out-of-band value, but it would be a bad idea to make errors produce the same out-of-band value

[05:57] <moritz> japhb: nope. I have no idea how my reply made you think that.

[05:58] <japhb> (FWIW, real graphics cards either use a 'discard' instruction, which is basically fail() with no extra info carried along, or use 'writeable Z' to force the output to be outside the clip region -- and on many cards, thereby kill performance optimizations_ 

[05:58] <moritz> japhb: erm, to the first question

[05:58] <sorear> if the shader crashes, you should draw something obtrusive like bright orange on the screen, and ideally log it as well

[05:58] <moritz> japhb: but it really, really depends on how you do the whole thing

[05:59] <moritz> japhb: it is very likely that you'd use packed native arrays in performance critical operations

[05:59] <moritz> japhb: and those don't support failures anyway

[05:59] <sorear> I beleive in failing noisily

[05:59] <japhb> sorear, you just opened up the next phase of where I was going to go with this: "Now that you have decided on how to send this out of band info through, now how do you use the same mechanism as a debugging tool?"  :-)

[05:59] <moritz> ie my int @a[$x-res, $y-res]

[06:00] <japhb> moritz, the PDL solution to this was (among other things) to support infectious data values, including NaN.

[06:00] <sorear> japhb: there should be an out of band value meaning "transparent"

[06:00] <sorear> japhb: or "discard"

[06:00] <moritz> japhb: well, if you use num, you also get NaN support

[06:00] <sorear> japhb: "discard" should not be the same as "the shader crashed".  bad japhb, no cookie

[06:01] <japhb> sorear, I'm not sure how you got that from what I said.

[06:01] <japhb> I never suggested the shader crashed

[06:01] <sorear> we were talking about fail, were we not?

[06:01] <sorear> out of band values are fine, if they can be safely ignored

[06:01] <japhb> Merely that it was valid that it should discover it had crossed a boundary condition, and needed some way to indicate "I cannot continue, and no answer I can give you in my standard output would be valid here."

[06:02] <japhb> I don't think of Failure merely as "weak exception".  I think of it as "Mu with structure"

[06:02] <japhb> or "Mu with intent to not continue"

[06:03] <japhb> If Failure cannot be ignored, then as you mentioned early on in this conversation, that's a flaw in the design of Failure.

[06:04] <moritz> japhb: the point of Failure is precisely that you can ignore it, but it's still designed in a way that you usually don't lose information in the process

[06:04] <sorear> I support Failure iff S04:1295-1300 are eliminated

[06:04] <moritz> japhb: ie you can write   my @new = @values >>+>> 1   and it won't throw an eexception if one of the @values is a Failure

[06:05] <japhb> moritz, sure, which I agree with, but sorear had pointed out that Failure as currently designed may explode into Exception in your face, without you intending to allow that.

[06:05] <sorear> you've convinced me to intepret Failure as a kind of generalized NaN

[06:05] <japhb> \o/

[06:05] <japhb> I was worried I really was failing to make my case.

[06:05] <moritz> but the resulting Failure should carry the original error condition that led to the Failure in the first place

[06:05] <sorear> but there are a lot of places in the spec and in apps code that use fail that really, really, really should use die

[06:05] <Timbus> ^

[06:05] <sorear> all I/O errors should die

[06:05] <japhb> I am not surprised by that.

[06:06] <sorear> all assertion failures should die

[06:06] <Timbus> All Errors Must Hang!!

[06:06] <Timbus> er... Die

[06:06] <japhb> "That there's a hangin' offense."

[06:07] <sorear> currently in the spec Failure is a mutant halfbreed creature that tries to propagate both up the call stack and down data dependency chains

[06:07] <sorear> one or the other needs to go

[06:08] <sorear> since we already have exceptions, I'd like to see Failure become "purely infectious"

[06:08] <moritz> what's wrong with a Failure eventually becoming a loud exception?

[06:09] <japhb> I'm not sure it can be purely infectious ... I don't think you want to print Failure() to a data file and have it silently contain bogosity.  You should be forced at some point to decide how to deal with the Failures within your large data set, before sharing them with the outside world.

[06:10] <japhb> But I can see the point that merely being in sink context should not be enough to trigger the "upgrade"

[06:10] * moritz cannot

[06:10] <moritz> when you use it in sink context, you're about to lose information about what went wrong

[06:10] <moritz> and that's usually not what you want

[06:11] <japhb> moritz, I'm not saying I absolutely agree with that statement.  I'm saying I can see that it is a point valid enough to discuss further.

[06:11] <japhb> For example, is it worth having a 'use silent-sink' pragma?

[06:12] * moritz would put it into the same catgory as "no strict;"

[06:12] <sorear> moritz: uh, there are major problems with the idea of sink trapping

[06:12] <sorear> my ($c) = function;

[06:12] <japhb> moritz, hmmm, that's an interesting idea

[06:12] <sorear> suppose function returns (1, fail())

[06:12] <sorear> suppose function returns (1, 1..1e10, fail())

[06:14] * japhb imagines a function that is known to return a long list with Failure in all odd slots, and choosing to only continue computing on all the even slots.

[06:14] <sorear> sink context upgrades would require Failure-free algorithms to pay huge iteration costs

[06:14] *** woosley joined
[06:14] <japhb> Or a mathematical function that is well-behaved everywhere but at some singularities, and just grepping them away.

[06:15] <japhb> sorear, by implicitly forcing eagerness?

[06:15] <moritz> sorear: I'd still prefer to have sink context explode where we can do it efficiently

[06:15] <sorear> japhb: writing Failure to data files should throw

[06:15] <japhb> moritz, that's getting on the thin ice of "unreliable detection of error"

[06:16] <japhb> sorear, ah good, we agree there.

[06:16] <sorear> Failure.gist, and thus say Failure, should succeed

[06:16] <sorear> (another reason to like the gist change)

[06:16] <japhb> The worst case is not always exploding, or always not exploding, its exploding sometimes in a way that the normal programmer cannot make a correct mental model of when danger may occur.

[06:17] <moritz> japhb: I agree. The rules need to be simple

[06:17] <moritz> so the real question is if there are simple but effective rules

[06:18] <moritz> but I still think that serial computation is the default, and thus 'use fatal' should be default too

[06:18] * japhb is reminded of Haskell's bright line between pure and impure actions

[06:19] <moritz> japhb: which comes at the cost of making impure actions very hard to understand for the newcomer

[06:19] <japhb> moritz, NO KIDDING

[06:21] <sorear> I also really don't like the way that Failure considers itself handled after .Bool

[06:21] <japhb> sorear, you think it should only be handled after .defined?

[06:21] <sorear> japhb: No

[06:21] *** media-786 left
[06:21] <japhb> sorear, what are you suggesting then?

[06:21] * moritz was always a bit uneasy about that part too

[06:21] <sorear> japhb: .try maybe

[06:22] <sorear> .success?

[06:22] <moritz> soemthing explicit anyway

[06:22] <sorear> what we don't want to do is put users in a situation of accidentally handling failures

[06:22] <japhb> I can agree with that.

[06:22] <japhb> Though I'd argue that .defined is much stronger in intent than .Bool.

[06:22] <sorear> e.g. suppose function() returns a number or fails

[06:22] <sorear> what about if function() > 5  { ... }

[06:23] <sorear> Failure > 5 is supposed to be Failure

[06:23] <sorear> iiuc

[06:23] <japhb> Yes, just like undef propagates in Perl 5.

[06:23] <japhb> sorry, I should perhaps use 'NULL as in SQL'

[06:24] <sorear> japhb: s/Perl 5/SQL/

[06:24] <sorear> I actually think that testing a Failure for .Bool should throw

[06:24] <sorear> because there's no sensible way to propagate Failure into $y in { if foo() { $y = 1 } else { $y = 2 } }

[06:25] <japhb> Oh now that's an interesting point 

[06:25] <moritz> you could make .Bool go BOOM :-)

[06:26] * moritz tries to sleep again

[06:27] <japhb> Good luck, moritz

[06:29] <japhb> So the only safe operations on unhandled concrete Failure would be .defined and //, and looking at its metaclass

[06:29] <japhb> s/metaclass/class and metaclass info/

[06:30] <sorear> I am not so sure any of that should be "safe"

[06:30] <japhb> sorear, why not?

[06:30] <sorear> because // is short-circuiting, it allows Failure to contaminate control flow

[06:31] <japhb> So far, I am unconvinced that .defined and // are not clear indications that the programmer understands that out-of-band information is expected

[06:31] <japhb> Let me know if that had too many negatives

[06:31] <sorear> // clearly indicates "out of band" but this might be a case of "out of out of band"

[06:32] <japhb> LOL

[06:32] <sorear> I often write functions that return Any for specific reasons

[06:32] <japhb> There are only two kinds of undefined, right?  Type objects and "things that override .defined", which until the user decided to go crazy, starts with only Failure().

[06:33] <japhb> hmmm

[06:33] <sorear> yes

[06:33] <japhb> I see your OOOOB point.

[06:34] <japhb> I'm not sure I have a good response to it other than DIHWIDT

[06:34] <japhb> ... which I always find unsatisfying

[06:36] * japhb thought he would spend the evening implementing contaminating-Failure-outside-Any, not discussing all the angles on whether it's even the Right Thing

[06:36] <japhb> :-)

[06:46] <sorear> muahahaha.

[06:47] <sorear> now, if Failures are this prone to turning into real exceptions, it seems to me that they don't provide much of a useful failsoft guarantee

[06:48] <sorear> if we don't have a useful failsoft guarantee, then failsoft parallel operators need to provide their own try()

[06:48] <sorear> at which point ... why bother?

[06:48] <japhb> At this point, I see a 70% chance that we merely need to tweak the concept and spec to get to something useful (though perhaps not identical in intent to the current spec), and a 30% chance this is an unrecoverable thing that needs a major rethink.

[06:49] <sorear> I don't think this is completely unrecoverable.  NaN was pretty successful, after all.

[06:50] <sorear> We need to get colomon++ into this conversation.

[06:50] <sorear> I am to understand he has recently read quite a bit of Kahan

[06:50] <japhb> Why him in particular?

[06:50] <japhb> Ah.  I had W. Kahan for quite a few classes.

[06:51] <sorear> If anyone was likely to have written about the usefulness of NaN, it would be him.

[06:52] <japhb> I perhaps misrepresented myself.  When I said it might be conceptually unrecoverable, I meant that we might not be able to make something useful and self consistent that means much of anything like the current Failure as specced, and that it either goes away completely, or becomes nothing more than, as you said, (type-)generalized NaN.

[06:52] <[Coke]> sorear: I see spectest has new failures in niecza. will fudge them this weekend.

[06:53] <[Coke]> (unless I am beaten to it.)

[06:55] <japhb> I want to keep: 1. OOB "cannot continue" (or OOOOB, as the case may be).  2. Throws when you try to write it to the world outside the program.  3. Can be converted either to a default value, or to an Exception.  Beyond that, I'm all for negotiation and inquiry into the best behavior we can manage.

[06:57] <sorear> japhb: agreed on all points

[06:58] <japhb> And on that high note, I think this may be a good place to call it a night.

[07:00] *** drbean left
[07:01] <japhb> good night, y'all

[07:01] <japhb> sleep &

[07:02] <sorear> gnight

[07:07] *** drbean joined
[07:19] *** sayu joined
[07:30] <Woodi> http://en.wikipedia.org/wiki/Exception_handling#Restarts_separate_mechanism_from_policy

[07:37] <Woodi> small note: in RL we have numbers sets like Integers, Reals, etc. in programming world we have numbers-sets-augmented-with-undef. So undef is sometimes used as acceptable value and in other cases as failure indicator. But failures are meta-thing/lower lvl, happens during computation and do not belong to "problem domain sets". Just to clear base of problem...

[08:02] <moritz> nom: class A { method x { 'a' } }; role R { method x { 'r' } }; class B is A does R {  }; say B.x

[08:02] <p6eval> nom 68d0b8: OUTPUT«r␤»

[08:02] <moritz> thought so, good.

[08:06] *** alim joined
[08:13] *** drbean left
[08:19] *** drbean joined
[08:26] <sorear> phenny: tell [Coke] Please don't fudge regressions in niecza

[08:26] <phenny> sorear: I'll pass that on when [Coke] is around.

[08:27] <sorear> phenny: tell [Coke] Before releases I go through the spectest and fix regressions.  If you fudge them, I can't fix them.

[08:27] <phenny> sorear: I'll pass that on when [Coke] is around.

[08:28] <sorear> phenny: tell [Coke] Fudging is fine if someone changed the _test_ without bothering to check niecza

[08:28] <phenny> sorear: I'll pass that on when [Coke] is around.

[08:32] <sorear> (that probably sounds clueless)

[08:36] *** JimmyZ joined
[08:37] *** tokuhirom left
[08:38] *** JimmyZ left
[08:42] <sorear> Should "SS" match /:i ^\w$/ ?

[08:42] <sorear> Should "SS" match /:i ^<[...ß...]>$/ ?

[08:59] *** grondilu joined
[08:59] <grondilu> lol there is an article about contributing on planetsix.perl.org.   Now I have no more excuse not to help you guys :-)

[09:10] <sorear> hello, grondilu

[09:11] <grondilu> hi

[09:13] *** MayDaniel joined
[09:25] *** am0c left
[09:34] *** grondilu left
[09:41] *** MayDaniel left
[10:10] *** drbean left
[10:16] *** drbean joined
[10:23] *** jimmy1980 left
[10:28] *** fridim_ joined
[10:30] *** jimmy1980 joined
[10:37] *** Suresh joined
[10:46] *** drbean left
[10:52] *** drbean joined
[10:53] *** qnu joined
[11:01] *** dudulz left
[11:07] <qnu> panda bootstrap.sh fails while installing Test::Mock.. is this a known issue (fresh rakudo nom installation)?

[11:08] *** Chillance joined
[11:09] *** hundskatt joined
[11:14] *** dudulz joined
[11:19] *** jimmy1980 left
[11:20] *** woosley left
[11:21] <moritz> I think so

[11:23] <moritz> but I also think it's supposed to work if you install it directly

[11:23] <dalek> Heuristic branch merge: pushed 65 commits to rakudo/ex-from-actions by moritz

[11:24] <qnu> well, i installed Test::Mock manually and modified .panda/state, and rest of panda install went ok.

[11:26] <qnu> as a general best practice, i'm supposed to keep .perl6/bin in PATH and .perl6/lib in PERL6LIB envs?

[11:26] *** jimmy1980 joined
[11:26] <tadzik> yes

[11:29] *** drbean left
[11:31] *** Trashlord left
[11:32] *** dudulz left
[11:32] <moritz> .perl6/lib is automatically searched, I believe

[11:32] <moritz> nom: say @*INC

[11:32] <p6eval> nom 68d0b8: OUTPUT«lib /home/p6eval/.perl6/lib /home/p6eval/nom-inst2/lib/parrot/3.10.0-devel/languages/perl6/lib .␤»

[11:34] <qnu> yes.. good. except now I got "Incorrect pre-compiled version of lib/JSON/Tiny.pm loaded" when running panda.

[11:35] *** drbean joined
[11:35] *** jimmy1980 left
[11:36] *** jimmy1980 joined
[11:39] *** mj41 joined
[11:41] <qnu> can i remote .pir files from .perl6/lib? :)

[11:41] <moritz> yes

[11:47] * jnthn will sort out the Test::Mock failures this weekend

[11:49] <qnu> cool.. with these tweaks i got now everything up & running.. 

[11:49] *** rsimoes left
[12:00] *** alim left
[12:07] *** whiteknight joined
[12:07] *** whiteknight is now known as Guest18629

[12:22] *** donri joined
[12:24] *** sayu left
[12:45] *** drbean left
[12:47] <moritz> nom: say 1.^name

[12:47] <p6eval> nom 68d0b8: OUTPUT«Int␤»

[12:50] *** Suresh left
[12:51] *** shinobicl_ joined
[12:51] *** drbean joined
[13:05] *** replore_ joined
[13:09] <dalek> rakudo/nom: 187e23a | moritz++ | src/core/Mu.pm:

[13:09] <dalek> rakudo/nom: make uninitialized warnings a bit more verbose

[13:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/187e23aa9d

[13:11] * moritz hopes that tadzik writes his advent post soon

[13:11] <colomon> still a lot of the 10th left in this part of the world...

[13:12] <moritz> well, more than half over here

[13:13] <jnthn> Don't confuse physical timezone with individual's timezones. ;-)

[13:14] *** mkramer joined
[13:17] *** mkramer1 joined
[13:18] *** qnu left
[13:19] *** mkramer left
[13:20] *** mkramer1 left
[13:21] *** drbean left
[13:27] *** drbean joined
[13:28] *** Trashlord joined
[13:33] *** jimmy1980 left
[13:33] *** dudulz joined
[13:37] <dalek> rakudo/nom: 7e77c0c | moritz++ | src/core/Mu.pm:

[13:37] <dalek> rakudo/nom: fix previous commit

[13:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7e77c0cccf

[13:40] *** jimmy1980 joined
[13:47] *** JimmyZ joined
[14:05] *** mkramer joined
[14:06] *** sayu joined
[14:10] *** mkramer left
[14:17] *** drbean left
[14:23] <dalek> rakudo/nom: 5eed440 | jnthn++ | / (2 files):

[14:23] <dalek> rakudo/nom: Implement getting the name of a scalar container through $a.VAR.name.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5eed4409fc

[14:23] <dalek> rakudo/nom: c3d61d8 | jnthn++ | src/core/Mu.pm:

[14:23] <dalek> rakudo/nom: Dispatchy and type-checky things should not decontainerize, but just pass on invocants.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3d61d8b78

[14:23] <dalek> rakudo/nom: 1f9310d | jnthn++ | src/core/Mu.pm:

[14:23] <dalek> rakudo/nom: Include variable name (at least, in the scalar case) in uninitialized warnings.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f9310d73d

[14:24] <jnthn> > my $a; say +$a

[14:24] <jnthn> Use of uninitialized variable $a of type Any in numeric context

[14:24] <jnthn> \o/

[14:24] *** drbean joined
[14:35] *** agentzh joined
[14:35] *** jimmy1980 left
[14:37] <tadzik> winter--

[14:37] <tadzik> I wake up, and it's not _still_ dark. It's _already_ dark

[14:38] <cognominal_> change hemisphere :)

[14:39] *** cognominal_ is now known as cognominal

[14:40] *** jimmy1980 joined
[14:42] *** fridim_ left
[14:44] <jnthn> tadzik: heh. And you're further south than me. :P

[14:54] <JimmyZ> moritz: there is some typo in the commit, 'in of'

[14:56] <JimmyZ> ah, fixed by jnthn++

[15:08] *** agentzh left
[15:09] *** sayu left
[15:10] *** Bzek joined
[15:11] *** mkramer joined
[15:15] *** mkramer left
[15:17] *** gbacon joined
[15:19] *** mkramer joined
[15:25] <Woodi> good * :)

[15:25] <Woodi> maybe intermediate OOP advent post would be nice ?

[15:27] <Woodi> for example I can't find something like" self!..." anywhere. 

[15:27] <colomon> tadzik: how's your Advent post coming along?

[15:30] *** mj41 left
[15:31] *** mkramer left
[15:31] <jnthn> Hm, intermediate OO is maybe too general, though could do one on private methods, trusts, etc.

[15:31] *** mkramer joined
[15:31] *** Psyche^ joined
[15:35] *** Patterner left
[15:35] *** Psyche^ is now known as Patterner

[15:44] <Woodi> I just looked into available docs and everywhere is just how to create class and use fields. even no example how to use method in other method. so maybe "more basics" with examples :) not sure I can handle this

[15:47] *** drbean left
[15:47] *** mkramer left
[15:50] *** shinobicl_ left
[15:54] *** drbean joined
[16:13] <JimmyZ> rakudo: my $r = 2; sub cached($r is rw) { $r = 40; }; say $r; 

[16:13] <p6eval> rakudo 1f9310: OUTPUT«2␤»

[16:13] <JimmyZ> rakudo: my $r = 2; sub cached(\$r) { $r = 40; }; say $r; 

[16:13] <p6eval> rakudo 1f9310: OUTPUT«2␤»

[16:14] <jnthn> JimmyZ: You never called the sub... :)

[16:15] <JimmyZ> $r is rw is same as \$r?

[16:16] <jnthn> no

[16:16] <jnthn> Though they're similar

[16:16] <jnthn> "is rw" should fail to bind it the thing passed isn't rw

[16:17] <jnthn> \$r doesn't have such a requirement. Also it's no longer spec...you'd just write "\r" now.

[16:17] <JimmyZ> rakudo: my $r = 2; sub cached($r is rw) { $r = 40; }; cached(2); say $r; 

[16:17] <p6eval> rakudo 1f9310: OUTPUT«Cannot assign to a non-container␤  in sub cached at /tmp/Te2mSZu_7d:1␤  in block <anon> at /tmp/Te2mSZu_7d:1␤  in <anon> at /tmp/Te2mSZu_7d:1␤»

[16:17] <jnthn> But I don't think std was updated yet, and I'd kinda prefer to wait for that.

[16:17] <JimmyZ> rakudo: my $r = 2; sub cached(\$r) { $r = 40; }; cached(2); say $r; 

[16:17] <p6eval> rakudo 1f9310: OUTPUT«Cannot assign to a non-container␤  in sub cached at /tmp/dMGQzoXReu:1␤  in block <anon> at /tmp/dMGQzoXReu:1␤  in <anon> at /tmp/dMGQzoXReu:1␤»

[16:18] <JimmyZ> rakudo: my $r = 2; sub cached(\r) { $r = 40; }; cached($r); say $r; 

[16:18] <p6eval> rakudo 1f9310: OUTPUT«===SORRY!===␤Malformed parameter at line 1, near "\\r) { $r ="␤»

[16:18] <JimmyZ> std: my $r = 2; sub cached(\r) { $r = 40; }; cached($r); say $r; 

[16:18] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed parameter at /tmp/bPHOqBH_g2 line 1:␤------> [32mmy $r = 2; sub cached([33m⏏[31m\r) { $r = 40; }; cached($r); say $r;[0m␤    expecting any of:␤        name␤   new name to be defined␤ parameter␤      routine_def␤    signature␤Parse

[16:18] <p6eval> ..failed␤F…

[16:19] <jnthn> Yeah...

[16:21] <JimmyZ> \r is ugly?

[16:22] <jnthn> Well, you'd refer to it just as "r" afterwards

[16:22] <jnthn> The problem is that it's contextless

[16:22] <jnthn> Meaning that it doesn't really make sense to have a sigil on it

[16:24] <JimmyZ> so I just need to say r = 40; ?

[16:24] <jnthn> yeah, you'd do that.

[16:25] * JimmyZ doesn't like it

[16:26] *** jimmy1980 left
[16:26] <JimmyZ> something sub foo(\r) { my $b = 20; r = $b; }

[16:26] <jnthn> Well, if you're using it much in your code, you're probably doing something wrong.

[16:26] <jnthn> The vast majority of parameters should be read only.

[16:27] <jnthn> \ is for not enforcing context, which probably means you're writing some kind of dispatcher (which you won't be doing often).

[16:27] <JimmyZ> I don't like sub foo(\r) { my $b = 20; r = $b; },  r in the code block looks like a sub name

[16:27] <jnthn> iiuc, it's parsed as a term

[16:28] <JimmyZ> time and now is a term too

[16:28] <jnthn> yes

[16:28] <jnthn> Though you can't assign to those. :)

[16:28] <jnthn> now = 2220; # wooo, time travel!

[16:29] <JimmyZ> but  something  r=$b  looks like lvalue

[16:29] <jnthn> JimmyZ: But if that's what you want, you should have used "is rw"

[16:29] <jnthn> In the majority of cases.

[16:30] <jnthn> \ is about contextlessness, which normally is only useful if you want to pass the thing on

[16:30] <JimmyZ> or $b = r,  r still like a a sub name or code block

[16:30] *** gbacon left
[16:31] <jnthn> JimmyZ: But that'd be a slightly weird thing to do too. I mean, you'd often not take something in a parameter list with \ in order to not impose context, then assign it to a scalar (which does impose context)

[16:32] *** jimmy1980 joined
[16:32] <jnthn> JimmyZ: I agree it looks a little odd. It's just that I think you're overestimating how often it should be used.

[16:33] <JimmyZ> jnthn: the setting most use Mu \$self:, which will be changed to Mu \self: ?

[16:33] <jnthn> JimmyZ: Yes

[16:33] <jnthn> JimmyZ: Note that where the setting does that, it tends to be due to delaying context

[16:33] <jnthn> JimmyZ: All the uses of it I introduced today are in order to preserve the *exact* thing that the user wrote as the invocant, rather than to decontainerize it.

[16:33] <jnthn> That's not a usual thing.

[16:34] <jnthn> Note that the things I used it in were related to type checking and dispatching.

[16:34] <jnthn> (Yes, we make some uses of it in the setting as an optimization. But that's because we don't have a smart enough optimizer yet. :-))

[16:36] *** mj41 joined
[16:37] *** hrj left
[16:37] <JimmyZ> you're right, but I still like the sigil, the perl landmark  :)

[16:38] <JimmyZ> std: my $r = 2; sub cached(\%r) {  say %r }; 

[16:38] <p6eval> std be1f10e: OUTPUT«ok 00:01 124m␤»

[16:46] *** syslq joined
[16:46] <syslq> Will perl6 be eable to use perl5 cpan modules?

[16:49] *** drbean left
[16:51] <jnthn> syslq: Some Perl 6 implementations have already explored this area a bit; the goal is that yes, it will be possible (at least, for quite a few modules).

[16:51] <syslq> jnthn: thanks, cpan is huge asset

[16:52] <jnthn> Very much so.

[16:55] *** drbean joined
[16:59] *** JimmyZ left
[17:00] *** JimmyZ joined
[17:05] <cognominal> nom:  grammar A {  token list { a } };  A.parse('a', :rule<list> ) 

[17:05] <p6eval> nom 1f9310: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in method list at src/gen/CORE.setting:1012␤  in !reduce at src/stage2/QRegex.nqp:909␤  in !cursor_pass at src/stage2/QRegex.nqp:889␤  in regex list at /tmp/S8O1qlEoba:1␤  in method parse at src/gen/CORE.se…

[17:06] <JimmyZ> nom: if 42 -> *@_ { say @_.perl }

[17:06] <p6eval> nom 1f9310: OUTPUT«Array.new()␤»

[17:06] <JimmyZ> nom: sub b(*@a) { say @a; };  b(3,6,2);

[17:06] <p6eval> nom 1f9310: OUTPUT«3 6 2␤»

[17:06] <cognominal> jnthn, that should not pick the list method in CORE.setting?

[17:07] <jnthn> cognominal: er...

[17:08] <jnthn> cognominal: Yeah, you didn't specify any actions class

[17:08] <jnthn> cognominal: If you had, then it'd be legitimate.

[17:08] <JimmyZ> nom: if 42 -> *@a { say @a.perl }

[17:08] <p6eval> nom 1f9310: OUTPUT«Array.new()␤»

[17:08] <JimmyZ> how do I get @a value ?

[17:09] <jnthn> nom: if 42 -> *@a { say @a }

[17:09] <p6eval> nom 1f9310: OUTPUT«␤»

[17:09] <jnthn> hmm

[17:10] <jnthn> nom: if 42 -> $a { say $a }

[17:10] <p6eval> nom 1f9310: OUTPUT«42␤»

[17:10] <cognominal> jnthn, I don't see how it is related to an action class. Here "list: is a legitimate rule.

[17:10] <jnthn> nom: if 42 -> $a? { say $a }

[17:10] <p6eval> nom 1f9310: OUTPUT«Mu()␤»

[17:10] <jnthn> ah

[17:10] <jnthn> cognominal: Look at the stack trace more carefully. It reached your list regex just fine.

[17:10] <JimmyZ> S06:1904 said it's wrong

[17:11] *** fsergot joined
[17:11] <cognominal> ho, I get it.

[17:11] <jnthn> cognominal: Yeah...it's probably setting $*ACTIONS to Any or some such.

[17:11] <jnthn> cognominal: I think I'd consider this a bug anyway. Please file a ticket, or maybe try patching it.

[17:12] <cognominal> ok, thx

[17:13] <jnthn> JimmyZ: I'm not sure I see the relevance of that line of spec.

[17:13] <syslq> jnthn: the thing I love about pl, is not needing like five interpreter versions on the system (read python), make sure you guys keep that in mind :)

[17:13] <jnthn> JimmyZ: I do think Rakudo is kinda wrong here though.

[17:14] <jnthn> JimmyZ: I can guess why it is too. It probably goes looking at .arity.

[17:15] <JimmyZ> ah, I misunderstand that line 

[17:16] <JimmyZ> jnthn: you're right, rakudo may be wrong

[17:16] * JimmyZ sleeps

[17:16] <jnthn> JimmyZ: That said, I don't get why you'd ever actually write what you did. ;-)

[17:16] <jnthn> Since you know there's always exactly one arg. :)

[17:16] <jnthn> sleep well, JimmyZ 

[17:18] <JimmyZ> jnthn:  because that line writes if $SAYIT -> *@_ { say @_; }

[17:19] <JimmyZ> nom: if 42, 44, 22 -> *@a { say @a.perl }

[17:19] <p6eval> nom 1f9310: OUTPUT«Array.new()␤»

[17:20] <JimmyZ> niecza: if 42, 44, 22 -> *@a { say @a.perl }

[17:20] <p6eval> niecza v12-10-ga8ad0e9: OUTPUT«(42, 44, 22)␤»

[17:20] <jnthn> JimmyZ: oh, oddness...

[17:20] <jnthn> JimmyZ: Anyway, I can probably fix it. Feel free to submit a ticket.

[17:20] * JimmyZ sleeps firstly

[17:20] <JimmyZ> g' night

[17:21] *** JimmyZ left
[17:21] <szabgab> masak: ping

[17:21] <szabgab> masak: Opera tells me http://strangelyconsistent.org/blog/feed.atom fails the XML parsing

[17:22] <jnthn> szabgab: masak is on vacation and likely not following irc; suggest phenny'ing that to him :)

[17:22] <szabgab> emailing him

[17:22] <jnthn> that orks too

[17:22] <jnthn> er, works

[17:23] <szabgab> orks work too :)

[17:30] <tadzik> colomon: working on it

[17:30] <tadzik> will be online in an hour

[17:31] <moritz> jnthn++

[17:33] *** kaare_ joined
[17:40] <moritz> nom: say Any + Int

[17:40] <p6eval> nom 1f9310: OUTPUT«Use of uninitialized value of type Any in numeric context␤Use of uninitialized value of type Int in numeric context␤0␤»

[17:41] <colomon> tadzik++

[17:41] <[Coke]> sorear: I opened tickets for everything. You'd rather they were failing?

[17:41] <phenny> [Coke]: 08:26Z <sorear> tell [Coke] Please don't fudge regressions in niecza

[17:41] <phenny> [Coke]: 08:27Z <sorear> tell [Coke] Before releases I go through the spectest and fix regressions.  If you fudge them, I can't fix them.

[17:42] <phenny> [Coke]: 08:28Z <sorear> tell [Coke] Fudging is fine if someone changed the _test_ without bothering to check niecza

[17:42] <colomon> jnthn: any idea how say ~$/<chord_accidental>.WHAT; could get me "Use of uninitialized value in string context", when say ~$/<chord_accidental>.perl; gets me (Match.new(orig ... etc.  (this in nom).  Does a Parcel not have a name?

[17:43] <moritz> nom: my Int $x; my $y; $x + $y; +$x

[17:43] <p6eval> nom 1f9310: OUTPUT«Use of uninitialized variable $x of type Int in numeric context␤Use of uninitialized variable $y of type Any in numeric context␤Use of uninitialized variable $x of type Int in numeric context␤»

[17:43] <[Coke]> (when I fudged things earlier.)

[17:43] <[Coke]> seen sorear?

[17:43] <aloha> sorear was last seen in #perl6 8 hours 32 mins ago saying "hello, grondilu".

[17:43] <moritz> colomon: use .WHAT.gist

[17:43] <[Coke]> phenny: tell sorear: everything fudged so far has a ticket.

[17:43] <phenny> [Coke]: I'll pass that on when sorear is around.

[17:44] <moritz> colomon: .WHAT is just the type object, and that stringifies to '' with a warning

[17:44] <jnthn> colomon: danger precedence!

[17:44] <moritz> but it .gist's without a warning, or you can use .^name directly on the object

[17:44] <[Coke]> phenny: tell sorear it's kind of a PITA to tell the difference between things you broke and things other people didn't bother to checker.

[17:44] <phenny> [Coke]: I'll pass that on when sorear is around.

[17:44] <jnthn> ~$/<chord_accidental>.perl is ~($/<chord_accidental>.perl)

[17:44] <jnthn> Oh, maybe you know that...

[17:44] <jnthn> hm

[17:45] <jnthn> oh!

[17:45] <jnthn> Though maybe same thing

[17:45] * [Coke] will just concentrate on rakudo's tests, he supposes.

[17:45] <jnthn> ~$/<chord_accidental>.WHAT is ~($/<chord_accidental>.WHAT)

[17:45] <jnthn> And thus what moritz++ points out is the issue

[17:46] <colomon> jnthn++, moritz++

[17:47] <jnthn> [Coke]: Do you have ICU working with Parrot on Windows?

[17:47] * colomon is not sure how the ~ snuck into his code...

[18:08] *** xinming_ joined
[18:11] *** xinming left
[18:31] <jnthn> tadzik: Fixed one test in Test::Mock

[18:31] <jnthn> tadzik: And skipped the others that fail for the moment so people aren't blocked on bootstrapping the ecosystem.

[18:31] <jnthn> tadzik: Hope this helps.

[18:32] <tadzik> jnthn: great, thanks!

[18:32] <tadzik> blog post preview: http://perl6advent.wordpress.com/?p=867&preview=true

[18:32] <tadzik> suggestions will be welcome, if something is unclear or chaotic let me know

[18:32] <jnthn> tadzik: Seems that it has line breaks in wrong places.

[18:33] <[Coke]> jnthn: I thought I had at one point.

[18:33] <jnthn> "Plain, Old Documentation" - don't think the comma is meant to be there. It changes the meaning. ;-)

[18:34] *** mj41 left
[18:35] <tadzik> jnthn: yeah, fixe that

[18:35] <tadzik> okay

[18:35] <tadzik> corrected that too

[18:37] <jnthn> tadzik++ # nice post!

[18:38] <tadzik> I think I'll mention Pod test suite too

[18:39] <tadzik> ...suite, or suit?

[18:40] <tadzik> suite I think :) added

[18:41] <jnthn> suite

[18:41] <jnthn> :)

[18:41] <tadzik> ok, publishing, take cover :)

[18:41] * jnthn hides under his desk

[18:41] <tadzik> ta-da! http://perl6advent.wordpress.com/2011/12/10/documenting-perl-6/

[18:42] <jnthn> \o/

[18:43] *** molaf_ left
[18:45] *** MayDaniel joined
[18:49] <jnthn> tadzik: plz can haz commit bit for Panda?

[18:54] <tadzik> jnthn: sure thing

[18:55] <tadzik> maybe I should move it to Perl6 org

[18:55] <jnthn> tadzik: I have a bootstrap.bat

[18:55] <tadzik> jnthn: given

[18:55] <tadzik> \o/

[18:55] <jnthn> tadzik: That does what bootstrap.sh does but for Windows

[18:55] <tadzik> works on windows?

[18:55] <jnthn> tadzik: Next problem: no wget on Windows :(

[18:55] <tadzik> :\

[18:55] <tadzik> we should use LWP::Simple maybe

[18:55] <sorear> good * #perl6

[18:55] <phenny> sorear: 17:43Z <[Coke]> tell sorear everything fudged so far has a ticket.

[18:55] <phenny> sorear: 17:44Z <[Coke]> tell sorear it's kind of a PITA to tell the difference between things you broke and things other people didn't bother to checker.

[18:55] <tadzik> hello sorear 

[18:57] <dalek> panda: 253154c | jnthn++ | bootstrap.bat:

[18:57] <dalek> panda: Add a bootstrap.bat, to get us started with Windows support for Panda.

[18:57] <dalek> panda: review: https://github.com/tadzik/panda/commit/253154c464

[18:58] <jnthn> tadzik: Or some very stripped down "just the bits we need" equivalent

[18:59] <tadzik> aye

[19:00] <tadzik> ok, I'm gone for today, see you tomorrow!

[19:00] <cognominal> jnthn: in nqp, how can I distinguish a class derived from Any from the Any class itself

[19:01] <cognominal> testing that could fix the bug about $*ACTIONS

[19:02] *** MayDaniel left
[19:03] <jnthn> cognominal: I don't think that's really the right approach.

[19:03] <jnthn> cognominal: It should probably be fixed somewhere in Rakudo, not in nqp

[19:03] *** am0c joined
[19:04] <jnthn> cognominal: You can do the check there with === though

[19:04] <jnthn> nom: say Any === Any; say Int === Any;

[19:04] <p6eval> nom 1f9310: OUTPUT«Bool::True␤Bool::False␤»

[19:04] <cognominal> ok

[19:16] <dalek> panda: bdeae83 | jnthn++ | README.md:

[19:16] <dalek> panda: Add installation instructions for Windows.

[19:16] <dalek> panda: review: https://github.com/tadzik/panda/commit/bdeae831c6

[19:27] <dalek> panda: 6f00754 | jnthn++ | bin/panda:

[19:27] <dalek> panda: Fix home directory handling on Windows.

[19:27] <dalek> panda: review: https://github.com/tadzik/panda/commit/6f00754ef9

[19:30] <dalek> panda: 8beee70 | jnthn++ | README.md:

[19:30] <dalek> panda: Clarification.

[19:30] <dalek> panda: review: https://github.com/tadzik/panda/commit/8beee7037e

[19:30] <dalek> rakudo/nom: 70d7154 | jnthn++ | src/Perl6/Metamodel/SubsetHOW.pm:

[19:30] <dalek> rakudo/nom: .^find_method on a subset shouldn't throw.

[19:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/70d7154633

[19:35] *** drbean left
[19:38] <sorear> [Coke]: oh, if you're going to ticket them, that's fine

[19:40] <jnthn> phenny: tell tadzik hmm, there's quite a few not-so-Windows-friendly bits, it seems. It claims to work, but there's no .perl6 directory created! Will see if I can figure it all out, anyways...

[19:40] <phenny> jnthn: I'll pass that on when tadzik is around.

[19:41] *** drbean joined
[19:52] *** snearch joined
[20:06] <[Coke]> sorear: the only ones I'm not ticketing are one that weren't even in t/spectest.data before.

[20:06] <[Coke]> anything that was already running but has a failure was (is) getting a ticket.

[20:06] <[Coke]> excellent

[20:07] <sorear> I'm mostly just annoyed by af38363d

[20:08] <[Coke]> in roast?

[20:09] <sorear> yes

[20:12] <[Coke]> Apologies, that was an old one. I'm not sure if those were tests that were already in t/spectest.data or not.

[20:12] <[Coke]> I'll ticketify those this weekend.

[20:12] <[Coke]> son needs computer now, though.

[20:13] * sorear wonders whether in the short term it would be better to have an O(n) Str.chars that respects surrogates or an O(1) Str.chars that doesn't

[20:22] <cognominal> jnthn, I thought adding in src/core/Grammar.pm the following function would do it but it is not called.       method !reduce($name) {  $*ACTIONS.$name if $*ACTIONS !== Any and $*ACTIONS.can: $name  }

[20:24] <cognominal> The interactions between nqp code and rakudo code is still am mystery to me. need sleep. CU tomorrow.

[20:32] *** am0c left
[20:36] *** localhost left
[20:37] *** localhost joined
[21:06] *** sayu joined
[21:07] *** sayu_ joined
[21:28] *** MayDaniel joined
[21:29] *** jlaire joined
[21:42] *** fridim_ joined
[21:43] *** lichtkind joined
[21:44] <lichtkind> hope i can write the categorize text

[22:10] *** MayDaniel left
[22:10] *** drbean left
[22:16] *** Sarten-X left
[22:16] *** drbean joined
[22:26] *** jimmy1980 left
[22:27] *** Sarten-X joined
[22:28] *** fsergot left
[22:28] *** kaare_ left
[22:30] *** jimmy1980 joined
[22:51] <sorear> lichtkind: Was that a question?

[22:52] <lichtkind> no :)

[22:52] <dalek> niecza: 20a790d | sorear++ | / (3 files):

[22:52] <dalek> niecza: Properly implement &codes, use it where appropriate

[22:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/20a790df96

[22:56] *** snearch left
[23:13] *** skangas left
[23:37] *** worr joined
[23:45] *** sayu_ left
[23:45] *** sayu left
[23:47] *** alim joined
[23:57] *** am0c joined
