[00:05] *** packetknife left
[00:07] <Woodi> hmm, should be 'my' not required ? in perl5 it's needed for marking not global vars...

[00:08] <tadzik> always required in Perl 6

[00:09] <Woodi> would be nice if it will be default...

[00:09] *** fridim_ joined
[00:09] <Woodi> if possible

[00:09] <jnthn> Good Perl 5 programmers - 1-liners aside - pretty much always "use strict" in perl 5 anyway.

[00:10] <Woodi> yes, it is 'must' in p5

[00:10] <jnthn> So we're just saving everyone a line of boilerplate. :)

[00:10] <jnthn> I think in -e "..." it should be relaxed

[00:10] <jnthn> So one-liners are still convenient.

[00:10] <jnthn> But we don't implement that in Rakudo yet.

[00:11] <Woodi> do not understund - not saving by requiring it...

[00:12] <jnthn> Woodi: You don't have to write "use strict;" in Perl 6, because it's on by default.

[00:12] <sorear> Woodi: We require you to explicitly declare variables to help prevent typo bugs

[00:12] <sorear> Woodi: If 'my' wasn't required, then the compiler would accept $color = read_from_db(); say $colour; but would always output "Any"

[00:14] *** pernatiy joined
[00:14] <Woodi> perl is scripting language, not see problem in that

[00:14] <Woodi> but understud explicity boilerplate part

[00:14] <sorear> Perl is a multiparidigm language.

[00:15] <sorear> It does applications too.

[00:16] <tadzik> I'd be careful with this 'scripting' part :)

[00:17] <Woodi> oki, can someone point me to some IO::Socket::INET code/module ? need examples

[00:17] <Woodi> found

[00:22] <jnthn> sleep &

[00:23] <tadzik> g'night

[00:23] <Woodi> base64 is builtin now ?

[00:23] <tadzik> nope

[00:23] <tadzik> there's a MIME::Base64 module

[00:23] <Woodi> not working

[00:24] <Woodi> ok, gn all

[00:26] *** wolfman2000 joined
[00:27] <tadzik> gn

[00:56] <snarkyboojum> Woodi: There are now two different versions of MIME::Base64, the latest works on latest Rakudo (v1.1). v1.0 works on earlier Rakudos based on ng, like the last Star release

[00:56] *** alvis left
[00:57] *** thundergnat left
[00:57] *** ZapZ left
[00:59] <snarkyboojum> phenny: tell moritz++ thanks for the fix to MIME::Base64 on nom - not backwards compatible with ng, but at least it works :) have committed it as a new version of the module for now

[00:59] <phenny> snarkyboojum: I'll pass that on when moritz++ is around.

[01:00] <snarkyboojum> whoops - that won't work

[01:00] <snarkyboojum> phenny: tell moritz thanks for the fix to MIME::Base64 on nom - not backwards compatible with ng, but at least it works  have committed it as a new version of the module for now

[01:00] <phenny> snarkyboojum: I'll pass that on when moritz is around.

[01:04] *** ZapZ_ joined
[01:06] <tadzik> ehh

[01:07] <tadzik> niecza: sub a(:$b) {}; a(b => 7, b => 7)

[01:07] <p6eval> niecza v9-32-g380d891: OUTPUT¬´Potential difficulties:‚ê§  $b is declared but not used at /tmp/ECsuacmDsV line 1:‚ê§------> [32msub a(:[33m‚èè[31m$b) {}; a(b => 7, b => 7)[0m‚ê§‚ê§¬ª

[01:07] <tadzik> pugs: sub a(:$b) {}; a(b => 7, b => 7)

[01:07] <p6eval> pugs: OUTPUT¬´*** No compatible multi variant found: "&a"‚ê§    at /tmp/92ANqf0Lp8 line 1, column 16 - line 2, column 1‚ê§¬ª

[01:08] <tadzik> b: sub a(:$b) {}; a(b => 7, b => 7)

[01:08] <p6eval> b 1b7dd1: OUTPUT¬´duplicate named argument in call‚ê§  in main program body at line 22:/tmp/76l0mQll_c‚ê§¬ª

[01:08] *** donri left
[01:08] <tadzik> nom: sub a(:$b) {}; a(b => 7, b => 7)

[01:08] <p6eval> nom 375fa0: OUTPUT¬´duplicate named argument in call‚ê§  in <anon> at /tmp/a9AqJkAmil:1‚ê§  in <anon> at /tmp/a9AqJkAmil:1‚ê§‚ê§¬ª

[01:10] <tadzik> sorear: what do you think about it? It's not per-spec, and it causes DateTime.t to break, but it may sound like a nice feature. Maybe it ought to be a warning

[01:10] <sorear> tadzik: I am about 3/4 sure that the most useful behavior is to use the last argument, which is what niecza does

[01:10] *** alvis joined
[01:10] <sorear> tadzik: think about what?

[01:10] <JimmyZ> does phenny know moritz++ ?

[01:10] <tadzik> so you treat the set of named params similiarly to a hash?

[01:10] <tadzik> sorear: about what you just said :)

[01:10] <sorear> yes.

[01:10] <tadzik> I see

[01:11] <sorear> JimmyZ: I don't think so

[01:11] <tadzik> DateTime.t uses sub dt(*%args) { DateTime.new(year => 1984, |%args) }

[01:11] <tadzik> where |%args possibly contain year too

[01:11] <tadzik> nom: sub foo(:$a); my %h = a => 5; foo(a => 6, |%h)

[01:11] *** JimmyZ left
[01:11] <p6eval> nom 375fa0: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near "; my %h = "‚ê§¬ª

[01:12] <tadzik> nom: sub foo(:$a) {}; my %h = a => 5; foo(a => 6, |%h)

[01:12] <p6eval> nom 375fa0: OUTPUT¬´duplicate named argument in call‚ê§  in <anon> at /tmp/907YNvPNaP:1‚ê§  in <anon> at /tmp/907YNvPNaP:1‚ê§‚ê§¬ª

[01:12] <tadzik> b: sub foo(:$a) {}; my %h = a => 5; foo(a => 6, |%h)

[01:12] <p6eval> b 1b7dd1:  ( no output )

[01:12] <tadzik> huh

[01:12] <tadzik> b: sub foo(:$a) {}; my %h = a => 5; foo(a => 6, a => 5)

[01:12] <p6eval> b 1b7dd1: OUTPUT¬´duplicate named argument in call‚ê§  in main program body at line 22:/tmp/Fza_E6Q285‚ê§¬ª

[01:12] <tadzik> not too smart, b

[01:46] <lichtkind> good night, hope to be more productive soon 

[01:47] *** lichtkind left
[01:49] *** uasi joined
[01:52] <tadzik> good night

[01:52] <dalek> rakudo/nom: eb855f3 | tadzik++ | src/core/Temporal.pm:

[01:52] <dalek> rakudo/nom: Fix DateTime.now

[01:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eb855f30d1

[01:52] <dalek> rakudo/nom: 048cfd5 | tadzik++ | / (2 files):

[01:52] <dalek> rakudo/nom: Fix Date.clone. We now pass S32-temporal/Date.t

[01:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/048cfd5415

[01:55] *** wolfman2000 left
[01:58] *** thou joined
[02:06] *** envi joined
[02:07] *** whiteknight left
[02:16] *** skangas left
[02:53] *** Chillance left
[03:25] *** packetknife joined
[03:29] *** soh_cah_toa left
[03:38] *** alester joined
[03:51] *** gbacon left
[03:55] <dalek> niecza/serialize: 876ee08 | sorear++ | Makefile:

[03:55] <dalek> niecza/serialize: Fix build

[03:55] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/876ee0840c

[03:55] <dalek> niecza/serialize: 7292b3a | sorear++ | / (9 files):

[03:55] <dalek> niecza/serialize: More tweaks, can now create SubInfo objects at compile time

[03:55] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/7292b3a4a3

[03:58] *** packetkn_ joined
[04:01] *** packetknife left
[04:26] *** packetkn_ left
[04:32] *** uasi left
[04:38] *** nsh joined
[04:42] *** ZapZ_ left
[04:54] *** alester left
[05:07] *** packetknife joined
[05:10] *** packetknife left
[05:11] *** miguet left
[05:57] <cognominal_> https://github.com/perl6/specs/pull/4  # replace $?ROUTINE fossils by &?ROUTINE

[06:03] *** ZapZ joined
[06:09] *** orafu left
[06:11] *** orafu joined
[06:13] *** kaare_ joined
[06:14] *** bluescreen10 left
[06:20] *** thou left
[06:20] *** jimmy1980 joined
[06:50] <dalek> niecza/serialize: 02f306a | sorear++ | / (3 files):

[06:50] <dalek> niecza/serialize: Start on lexicals in new model

[06:50] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/02f306ac16

[06:50] * sorear sleep

[06:53] *** mberends joined
[06:55] *** _jaldhar joined
[06:56] <mberends> aww, missed sorear by 3 minutes # just arrived home in .nl

[06:56] *** jaldhar left
[07:04] <sorear> mberends: I'm not actually asleep yet, I have a moment.

[07:04] <mberends> sorear: :-)

[07:05] <mberends> I wrote a small GUI Sierpinski triangles app en route, not problems with it

[07:05] *** daniel-s joined
[07:06] <mberends> I had earlier found a blocker on Gtk menus, but cannot remember the exact problem. Will re-do. I've started writing a Gtk text editor as well, mainly to explore GUI functionality.

[07:08] <mberends> The blockers are likely to be around native types. There was the inability to resize the clock as well, because the Geometry function is meant to pass pointers to ints. I think the menus had a similar requirement.

[07:09] *** wamba joined
[07:10] <sorear> oh yes

[07:10] <sorear> I actually thought I implemented pointers-to-ints

[07:11] <sorear> please leave tickets for any issue(s) you find

[07:11] <sorear> I'm not likely to get to this stuff for a while

[07:11] <sorear> hmm, only one more week 'till the release

[07:11] * sorear wonders if /serialize will be ready by then

[07:12] <mberends> ok. generally the feel of Gtk programming is very friendly and the docs are sufficient.

[07:13] *** wamba left
[07:13] *** wamba joined
[07:13] <sorear> mberends: I just added #56 and #57 for your existing issues

[07:13] <mberends> I hope serialize goes well. I slowed down on guts documentation because I saw you were refactoring the files I was studying.

[07:14] <mberends> sorear: thanks

[07:14] <sorear> I'd be happy to talk about my plans, but unless you have something urgent I'm going to leave now.

[07:15] <mberends> I have a very free day. It's probably better for you to sleep first and talk later. I'd like to talk anyhow.

[07:19] <jlaire> .u ‚∏ò‚ÄΩ

[07:19] <phenny> U+2E18 INVERTED INTERROBANG (‚∏ò)

[07:19] <phenny> U+203D INTERROBANG (‚ÄΩ)

[07:19] <jlaire> phenny: ty

[07:21] <benabik> .u ‚∏Æ

[07:21] <phenny> U+2E2E REVERSED QUESTION MARK (‚∏Æ)

[07:22] <mberends> wow, interrobang!  Ansa da question, or teh kitty gets it!

[07:26] <mberends> another Niecza GUI idea: John Horton Conway's Game of Life

[07:29] <mberends> Niecza master 'make test' fails test number 974 - Hash.any means any(keys): got: any("a", )  expected: any("a")

[07:29] <jlaire> a hashlife implementation in Perl 6 would be interesting to see

[07:32] <mberends> hmm, yes indeed.

[07:35] *** birdwindupbird joined
[07:35] <tadzik> good morning

[07:36] <cognominal> hi, can someone apply the pull request?  [07:57]  <cognominal_> https://github.com/perl6/specs/pull/4  # replace $?ROUTINE fossils by &?ROUTINE

[07:38] <dalek> specs: 5b9b25e | (St√©phane Payrard)++ | S (2 files):

[07:38] <dalek> specs: replace $?ROUTINE fossils by &?ROUTINE

[07:38] <dalek> specs: review: https://github.com/perl6/specs/commit/5b9b25e4b4

[07:38] <dalek> specs: 83f68bd | benabik++ | S (2 files):

[07:38] <dalek> specs: Merge pull request #4 from cognominal/master

[07:39] <dalek> specs: 

[07:39] <dalek> specs: replace $?ROUTINE fossils by &?ROUTINE

[07:39] <dalek> specs: review: https://github.com/perl6/specs/commit/83f68bd6ac

[07:39] <benabik> cognominal++

[07:39] <cognominal> thx

[07:41] *** arthur-_ left
[07:43] *** arthur-_ joined
[07:45] *** Kivutarrr joined
[07:51] <tadzik> given nqp::bindpos($fia, 0, nqp::unbox_i($dt.whole-second)); I get FixedIntegerArray: index out of bounds!

[07:51] <benabik> What's the size of the FIA?  Maybe it got initialized to 0, so there's no space in it.

[07:52] <tadzik> I'll read the docs. It's just my Mu $fia := pir::new__PS('FixedIntegerArray');

[07:52] <tadzik> I think this is one of those "how did it work before" moments

[07:53] <benabik> Yes‚Ä¶  I think that just makes a size 0 array

[07:53] <benabik> It needs to be pir::new__PSi('FixedIntegerArray', $size)

[07:53] <benabik> (Or something like that.)

[07:54] <tadzik> that dies with init_pmc() not implemented in class 'FixedIntegerArray'

[07:54] <benabik> That's odd‚Ä¶

[07:55] <tadzik> but you can probably set size using assignment

[07:55] <tadzik> if the tests don't lie

[07:55] <benabik> PSi should call init_int, not init_pmc...

[07:56] <benabik> Ah‚Ä¶  the set_integer_native VTABLE does it, but I'm not sure how to get at that.

[07:56] <benabik> assign__PI?

[07:56] <tadzik> nom: pir::new__PSi('FixedIntegerArray', nqp::unbox_i(5));

[07:56] <p6eval> nom 048cfd: OUTPUT¬´init_pmc() not implemented in class 'FixedIntegerArray'‚ê§  in <anon> at /tmp/mXxZr8mb73:1‚ê§  in <anon> at /tmp/mXxZr8mb73:1‚ê§‚ê§¬ª

[07:56] <tadzik> I'll try that

[07:56] <tadzik> PI, or Pi maybe?

[07:57] <tadzik> both die with error:imcc:syntax error, unexpected PREG, expecting '(' ('$P101')

[07:57] *** mj41 joined
[07:58] <benabik> nap has moved a little farther away from PIR‚Ä¶  It's more difficult for me to figure out what'll do waht.

[07:58] *** _jaldhar left
[07:58] <tadzik> void set_integer_native(INTVAL size)

[08:00] <benabik> NQP generates odd code sometimes‚Ä¶  new__PSI('FIA', 1') creates a Float PMC, assigns 1 to it, then assigns it to an int register, then calls new.

[08:01] <tadzik>     set $S100, "FixedIntegerArray"

[08:01] <tadzik>     new $P101, $S100, 5

[08:01] <tadzik> is the code generated by pir::new__PSi('FixedIntegerArray', 5)

[08:02] <tadzik> it doesn't fail itself when ran in pir

[08:02] <benabik> I was using 2011.06-196-gf3b8f73

[08:02] <benabik> NQP, sorry

[08:04] <tadzik> maybe deserializing it crashes it

[08:05] <tadzik> ...not that I know how to debug it :P

[08:05] <tadzik> I'll wait for jnthn to wake up

[08:06] <moritz> good morning

[08:06] <phenny> moritz: 01:00Z <snarkyboojum> tell moritz thanks for the fix to MIME::Base64 on nom - not backwards compatible with ng, but at least it works  have committed it as a new version of the module for now

[08:06] <benabik> In my copy of nom, I see     nqp_get_sc_object $P101, "1316332982.94512", 6;    set $S100, $P101 ;    new $P102, $S100, 1

[08:07] <benabik> No idea why that's ending up in init_pmc

[08:10] <tadzik> good morning moritz

[08:12] *** wallberg joined
[08:13] <dalek> rakudo/nom: a48a985 | tadzik++ | src/core/Temporal.pm:

[08:13] <dalek> rakudo/nom: More Temporal fixes

[08:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a48a9851c1

[08:14] * tadzik fixing calendar.t

[08:14] <tadzik> S32-temporal/local.t suffers from the "out of bounds" case

[08:14] <benabik> tadzik: The FIA problem?

[08:14] <tadzik> now, can we agree whether it should be method day-of-year() {} or method day-of-year {}? #perl6style

[08:14] <tadzik> benabik: yes

[08:15] <moritz> tadzik: I prefer the ()

[08:18] <tadzik> hmm, I prefer without :)

[08:18] <benabik> Well, let's compromise and only use one paren.

[08:19] <tadzik> fair enough

[08:19] <moritz> tadzik++ # fixing Date.t

[08:19] <moritz> erm, the code behind Date.t

[08:20] <tadzik> oh, moritz 

[08:20] <dalek> rakudo/nom: b952372 | tadzik++ | / (2 files):

[08:20] <dalek> rakudo/nom: Uncomment Date.day-of-year. We now pass S32-temporal/calendar.t; track failure reasons

[08:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9523725b6

[08:20] <tadzik> b: sub foo(:$a) {}; my %h = a => 5; foo(a => 6, a => 5)

[08:20] <p6eval> b 1b7dd1: OUTPUT¬´duplicate named argument in call‚ê§  in main program body at line 22:/tmp/hWnrudWXyf‚ê§¬ª

[08:20] <tadzik> b: sub foo(:$a) {}; my %h = a => 5; foo(a => 6, |%h)

[08:21] <p6eval> b 1b7dd1:  ( no output )

[08:21] <tadzik> nom: sub foo(:$a) {}; my %h = a => 5; foo(a => 6, |%h)

[08:21] <p6eval> nom 048cfd: OUTPUT¬´duplicate named argument in call‚ê§  in <anon> at /tmp/9MKSCalq_s:1‚ê§  in <anon> at /tmp/9MKSCalq_s:1‚ê§‚ê§¬ª

[08:21] <tadzik> moritz: see the last two. nom is certainly smarter, but it breaks DateTime.t

[08:21] <tadzik> I already adjusted Date.clone to be smart about this limitation, but fixing the test seems wrong

[08:21] <moritz> tadzik: yep, I've seen your patch in 048cfd5 and thought that was the case

[08:22] <moritz> tadzik: hm, where is that used in a test?

[08:22] <tadzik> I like how niecza does it, it treats named params sort of like a hash keys...

[08:22] <tadzik> moritz: sub dt() iirc

[08:22] <tadzik> ...and by the force of nature the problem doesn't exist

[08:22] <tadzik> moreover, the spec doesn't say anything about such a limitation, and moremoreover, that error is a parrot error, not a rakudo error

[08:23] <tadzik> so I'll just declare it a rakudobug

[08:23] <tadzik> (and fix it, if I had a bloody idea how to do this)

[08:23] <tadzik> or rather where to do this

[08:24] <moritz> tadzik: it's ok to "fix" the test, because the test is not about argument passing, but about DateTime

[08:24] <moritz> if we want to test that feature, it should be in S06-* somewhere

[08:25] <moritz> and tests are supposed to minimize used of advanced features, except for the thing they are currently testing

[08:25] <tadzik> fair enough

[08:26] <tadzik> ok, now it fails with FixedIntegerArray: index out of bounds! too

[08:26] <benabik> \o/

[08:27] <benabik> wait‚Ä¶  /o\

[08:28] <dalek> roast: 62ecf0f | tadzik++ | S32-temporal/DateTime.t:

[08:28] <dalek> roast: [DateTime.t] Avoid passing doubled named parameters; some implementations are not okay with that, and it's not the thing being tested here

[08:28] <dalek> roast: review: https://github.com/perl6/roast/commit/62ecf0f11e

[08:28] <tadzik> close enough ;)

[08:28] <tadzik> okay, time for some breakfast shopping &

[08:29] *** miguet joined
[08:30] <tadzik> phenny: tell flussence since nom is now default, please feel free to file every Pod-related issue you have to RT; external memory is better for me to remember about stuff

[08:30] <phenny> tadzik: I'll pass that on when flussence is around.

[08:30] <tadzik> phenny: thanks

[08:40] *** im2ee joined
[08:45] *** Kivutarrr left
[09:20] <dalek> rakudo/nom: 04532d3 | moritz++ | lib/Test.pm:

[09:20] <dalek> rakudo/nom: [Test.pm] show error after a failed dies_ok

[09:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/04532d3b04

[09:42] <dalek> rakudo/nom: 2eb5b16 | moritz++ | src/core/Num.pm:

[09:42] <dalek> rakudo/nom: floor() now returns an Int when possible

[09:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2eb5b16ece

[09:46] *** SHODAN joined
[10:18] *** tokuhiro_ joined
[10:19] <dalek> rakudo/nom: ab30d74 | moritz++ | src/core/Temporal.pm:

[10:19] <dalek> rakudo/nom: [Temporal] initialize length of FixedIntegerArray

[10:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ab30d74494

[10:23] * moritz takes a break from Temporal hacking

[10:23] <tadzik> oh, this is how you do it

[10:24] <tadzik> how are the passes now?

[10:24] <moritz> tadzik: it runs up to 140 now, three failures

[10:24] <tadzik> I can give it a peek

[10:24] <moritz> nom: new__PSI('ResizableIntegerArray', 9)

[10:24] <p6eval> nom 2eb5b1: OUTPUT¬´Could not find sub &new__PSI‚ê§  in <anon> at /tmp/AYPHTfr3SE:1‚ê§  in <anon> at /tmp/AYPHTfr3SE:1‚ê§‚ê§¬ª

[10:25] <moritz> nom: pir::new__PSI('ResizableIntegerArray', 9)

[10:25] <p6eval> nom 2eb5b1: OUTPUT¬´init_pmc() not implemented in class 'ResizableIntegerArray'‚ê§  in <anon> at /tmp/CELB0Qiv_k:1‚ê§  in <anon> at /tmp/CELB0Qiv_k:1‚ê§‚ê§¬ª

[10:25] <moritz> huh, I thought that would work too

[10:25] <tadzik> don't you want that to be Fixed?

[10:25] <tadzik> but it doesn't work anyway

[10:26] <moritz> nom: pir::new__PSI('FixedIntegerArray', 9)

[10:26] <p6eval> nom 2eb5b1: OUTPUT¬´init_pmc() not implemented in class 'FixedIntegerArray'‚ê§  in <anon> at /tmp/xkNSUxBR0E:1‚ê§  in <anon> at /tmp/xkNSUxBR0E:1‚ê§‚ê§¬ª

[10:26] <tadzik> it should be using init_int, not init_pmc

[10:26] <moritz> nom: pir::new__PSP('FixedIntegerArray', 9)

[10:26] <p6eval> nom 2eb5b1: OUTPUT¬´init_pmc() not implemented in class 'FixedIntegerArray'‚ê§  in <anon> at /tmp/j8q3bMTgZK:1‚ê§  in <anon> at /tmp/j8q3bMTgZK:1‚ê§‚ê§¬ª

[10:27] *** agentzh joined
[10:38] *** lumi_ joined
[10:41] <dalek> roast: 6bbd321 | tadzik++ | S32-temporal/DateTime-Instant-Duration.t:

[10:41] <dalek> roast: [DateTime-Instant-Duration.t] Avoid some more doubled named parameters

[10:41] <dalek> roast: review: https://github.com/perl6/roast/commit/6bbd3211e9

[10:43] *** MayDaniel joined
[10:44] <dalek> roast: d9c9935 | tadzik++ | S32-temporal/DateTime.t:

[10:44] <dalek> roast: DateTime.in-timezone doesn't take named parameters, use positionals

[10:44] <dalek> roast: review: https://github.com/perl6/roast/commit/d9c993541c

[10:51] <dalek> roast: 6edbf45 | tadzik++ | S32-temporal/DateTime.t:

[10:51] <dalek> roast: [S32-temporal/DateTime.t] Avoid some named params magic.

[10:51] <dalek> roast: 

[10:51] <dalek> roast: The test was failing on some implementations due to that, and we should

[10:51] <dalek> roast: be testing DateTime's reactions, not multiple dispatching.

[10:51] <dalek> roast: review: https://github.com/perl6/roast/commit/6edbf450a2

[10:54] <tadzik> nom: say DateTime.new(time); say DateTime.now

[10:54] <p6eval> nom 2eb5b1: OUTPUT¬´DateTime.new(year => 2011, month => 9, day => 18, hour => 10, minute => 54, second => 18)‚ê§DateTime.new(year => 2011, month => 9, day => 18, hour => 10, minute => 54, second => 18, timezone => $*TZ)‚ê§¬ª

[10:55] <tadzik> nom: say DateTime.new(time); say DateTime.now.utc

[10:55] <p6eval> nom 2eb5b1: OUTPUT¬´DateTime.new(year => 2011, month => 9, day => 18, hour => 10, minute => 55, second => 12)‚ê§FixedIntegerArray: index out of bounds!‚ê§  in method offset at src/gen/CORE.setting:6486‚ê§  in method postcircumfix:<( )> at src/gen/CORE.setting:6480‚ê§  in <anon> at src/gen/Metamo‚Ä¶

[10:55] <tadzik> evalbot rebuild nom

[10:55] <p6eval> NOT OK (maybe a rebuild is already in progress?)

[10:55] <tadzik> MAYBE. OK

[10:57] <tadzik> anyway, DateTime.t assumes DateTime.new(time) and DateTime.now.utc to be equal, not sure if that's really timezone-friendly: on my box, the difference is 4 hours. I'll leave that for some DateTime wizards

[11:02] <jnthn> o/

[11:02] *** im2ee left
[11:02] <jnthn> Wow, crazy DateTime hacking \o/

[11:02] *** im2ee joined
[11:03] <tadzik> oh hai jnthn 

[11:03] <jnthn> Note from backlog: there's a difference between pir::...__Psi and pir::...PSI 

[11:03] <jnthn> If you're putting literal values in, always use the lowercase forms.

[11:03] <jnthn> pir::new__PSI('blah', 42) # wrong

[11:03] <jnthn> pir::new__Psi('blah', 42) # right

[11:05] *** buubot_backup left
[11:07] <tadzik> oh

[11:07] <tadzik> anyway, seen the doubled named params issues?

[11:07] <jnthn> No

[11:07] <moritz> nom: pir::new__Psi('ResizableIntegerArray', 9)

[11:07] <p6eval> nom ab30d7: OUTPUT¬´init_pmc() not implemented in class 'ResizableIntegerArray'‚ê§  in <anon> at /tmp/2ckgYG3O2K:1‚ê§  in <anon> at /tmp/2ckgYG3O2K:1‚ê§‚ê§¬ª

[11:07] <jnthn> nom: pir::new__Psi('FixedIntegerArray', 9)

[11:08] <p6eval> nom ab30d7: OUTPUT¬´init_pmc() not implemented in class 'FixedIntegerArray'‚ê§  in <anon> at /tmp/sczRxFXQJx:1‚ê§  in <anon> at /tmp/sczRxFXQJx:1‚ê§‚ê§¬ª

[11:08] <jnthn> hm, guess you can't do that. :S

[11:08] <tadzik> jnthn: http://irclog.perlgeek.de/perl6/2011-09-18#i_4443641

[11:08] <jnthn> nom: pir::set__0Pi(pir::new__Ps('FixedIntegerArray'), 9)

[11:08] <p6eval> nom ab30d7:  ( no output )

[11:08] <jnthn> That should do it.

[11:09] <tadzik> it did

[11:09] <moritz> jnthn: that's what I'm using

[11:09] <jnthn> OK.

[11:09] <jnthn> That's probably the Right Way

[11:09] <moritz> jnthn: but I've seen https://github.com/parrot/parrot/blob/master/t/pmc/fixedintegerarray.t#L42 and wondered if we could do it that way too

[11:10] <jnthn> tadzik: I'm not sure how much we can do abotu the dupe arg thing.

[11:10] <jnthn> Short of migrating off Parrot :P

[11:10] <jnthn> Or getting Parrot folks to change something, somehow.

[11:11] <tadzik> eh?

[11:11] <jnthn> tadzik: It's a Parrot limitation.

[11:11] <tadzik> couldn't we just take care of it before the Parrot's invocation?

[11:11] <jnthn> tadzik: How?

[11:11] <tadzik> I mean, b did it partly

[11:11] <tadzik> jnthn: I have no idea how :)

[11:11] <jnthn> In the case you mentioned, we could spot them I guess

[11:11] <tadzik> b: sub foo(:$a) { say $a }; foo(a => 7, a => 6)

[11:11] <p6eval> b 1b7dd1: OUTPUT¬´duplicate named argument in call‚ê§  in main program body at line 22:/tmp/5f86SdjyVB‚ê§¬ª

[11:11] <jnthn> In the flattening case though...we don't know what's in the hash until runtime.

[11:12] <tadzik> okay, that worked with the hash

[11:12] <jnthn> Really?

[11:12] <tadzik> b: sub foo(:$a) { say $a }; my %h = a => 5; foo(a => 6, |%h)

[11:12] <p6eval> b 1b7dd1: OUTPUT¬´5‚ê§¬ª

[11:12] <tadzik> yeah

[11:12] <tadzik> bbs

[11:12] <jnthn> nom: sub foo(:$a) { say $a }; my %h = a => 5; foo(a => 6, |%h)

[11:12] <p6eval> nom ab30d7: OUTPUT¬´duplicate named argument in call‚ê§  in <anon> at /tmp/INvgQhHryN:1‚ê§  in <anon> at /tmp/INvgQhHryN:1‚ê§‚ê§¬ª

[11:12] <jnthn> eh, wtf.

[11:13] <cognominal> nom: my %a;  %a<a> :exists

[11:13] <p6eval> nom ab30d7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "%a<a> :exi"‚ê§¬ª

[11:14] <jnthn> Hm, I don't see why on earth it works in b.

[11:15] *** woosley joined
[11:18] <jnthn> afk for a moment

[11:21] <moritz> the hash removes the duplicates before it interpolates

[11:24] <moritz> nom: say List.^mr0

[11:24] <p6eval> nom ab30d7: OUTPUT¬´Method 'mr0' not found for invocant of class 'Perl6::Metamodel::ClassHOW'‚ê§  in method dispatch:<.^> at src/gen/CORE.setting:660‚ê§  in <anon> at /tmp/pC7OHcQh_0:1‚ê§  in <anon> at /tmp/pC7OHcQh_0:1‚ê§‚ê§¬ª

[11:24] <moritz> nom: say List.^mro

[11:24] <p6eval> nom ab30d7: OUTPUT¬´List() Iterable() Cool() Any() Mu()‚ê§¬ª

[11:26] *** buubot_backup joined
[11:27] *** skangas joined
[11:31] <jnthn> back

[11:31] <jnthn> < jnthn> Short of migrating off Parrot :P -- ARGH! Critical missing words - off Parrot CALLING CONVENTIONS. 

[11:31] * jnthn should not be allowed to type before coffee

[11:31] <jnthn> :/

[11:32] <jnthn> The thing is that we only get control of...some parts.

[11:32] <jnthn> But the flattening and arg checking stuff is all handled before a language's own binder gets its shot at things.

[11:33] <jnthn> |@i-am-infinite is awkward for the same reason.

[11:33] <jnthn> Hm

[11:37] <jnthn> er

[11:37] <jnthn> something very weird is going on here

[11:38] * jnthn will have to dig a bit more in a moment.

[11:39] *** Patterner left
[11:40] *** Psyche^ joined
[11:40] *** Psyche^ is now known as Patterner

[11:43] *** jimmy1980 left
[11:45] <jnthn> OK, I think I see how on earth to fix this.

[11:51] *** jimmy1980 joined
[11:54] <snarkyboojum> cool - what's b?

[11:55] <snarkyboojum> a particular revision of rakudo?

[11:55] <jnthn> snarkyboojum: Yeah, before the big refactor.

[11:56] <snarkyboojum> oh! ok

[12:00] <woosley> perl6: say (2,4,5) <<+>> (1,1,1)

[12:00] <p6eval> pugs: OUTPUT¬´*** ‚ê§    Unexpected "<<+>>"‚ê§    expecting operator, ":" or ","‚ê§    at /tmp/xY26FDTDNS line 1, column 13‚ê§¬ª

[12:00] <p6eval> ..rakudo ab30d7, niecza v9-32-g380d891: OUTPUT¬´3 5 6‚ê§¬ª

[12:00] <woosley> perl6: say (2,4,5)<<+>>(1,1,1)

[12:00] <p6eval> pugs: OUTPUT¬´*** Odd number of elements found where hash expected: VList [VInt 2,VInt 4,VInt 5]‚ê§    at /tmp/RUzc7va1bM line 1, column 5 - line 2, column 1‚ê§¬ª

[12:00] <p6eval> ..niecza v9-32-g380d891: OUTPUT¬´Unhandled exception: Unable to resolve method ast in class Any‚ê§  at /home/p6eval/niecza/src/NieczaActions.pm6 line 19 (NieczaActions NieczaActions.FALLBACK @ 14) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 3307 (STD P6.postcircumfix:sym<<< >>> @ 19) ‚ê§  at  l‚Ä¶

[12:00] <p6eval> ..rakudo ab30d7: OUTPUT¬´Method 'at_key' not found for invocant of class 'Parcel'‚ê§  in method postcircumfix:<{ }> at src/gen/CORE.setting:972‚ê§  in <anon> at /tmp/cfEmZo12i7:1‚ê§  in <anon> at /tmp/cfEmZo12i7:1‚ê§‚ê§¬ª

[12:01] <woosley> std: say (2,4,5)<<+>>(1,1,1)

[12:01] <p6eval> std bb4f150: OUTPUT¬´ok 00:01 122m‚ê§¬ª

[12:02] <woosley> bug?

[12:03] *** masak joined
[12:03] *** MayDaniel left
[12:04] <jnthn> woosley: Whitespace matters.

[12:04] <jnthn> Always put whitespace around infixes.

[12:04] <masak> hello #perl6 from a train o/

[12:04] *** masak left
[12:04] *** masak joined
[12:05] <masak> I wonder if there's another local minimum somewhere that would please people who don't like whitespace around their operators.

[12:05] *** masak left
[12:06] *** masak joined
[12:06] <masak> probably not.

[12:06] <masak> even if there is, it probably has enough drawbacks that it could never be the default.

[12:08] <woosley> jnthn: whitespace again! Perl6 whitespace rule is confusing ...

[12:08] <snarkyboojum> what's the rule? put whitespace around infixes?

[12:09] <woosley> snarkyboojum: That's why it is confusing, you never know where you 'should' leave a whitespace

[12:10] <snarkyboojum> woosley: not sure how "put whitespace around infixes" is confusing

[12:10] <snarkyboojum> but I don't claim to know all the whitespace specific rules :)

[12:10] <jnthn> As a rule: always put whitespace around infix operators, don't put it before/after prefix/postfix/postcircumfix operators.

[12:10] <jnthn> $a < $b # whitespace, 'cus it's infix

[12:10] *** f00li5h joined
[12:10] <jnthn> $foo<bar> # no whitespace because it's a postcircumfix

[12:11] <snarkyboojum> that seems pretty easy to remember

[12:11] <woosley> snarkyboojum: I met another whitespace rule yesterday

[12:11] <snarkyboojum> woosley: ah, ok - which one?

[12:11] <jnthn> Yes, though admittedly different from what some people may be used to coming from other languages.

[12:12] <jnthn> Note that the parens for passing arguments to a call are a postcircumfix.

[12:12] <jnthn> so foo(1,2,3), not foo (1,2,3)

[12:12] <snarkyboojum> I think I've always put whitespace around infix ops and not before postfix :)

[12:12] <snarkyboojum> maybe I'm just "lucky" :P

[12:12] <jnthn> :)

[12:12] *** masak left
[12:12] * jnthn tries a patch to clear up the args stuff a bit.

[12:12] *** masak joined
[12:13] <jnthn> masak: Good connection!

[12:13] <snarkyboojum> w00t mobile interwebs :)

[12:13] <woosley> snarkyboojum: oh, not yesterday, but someday, here it is:   http://irclog.perlgeek.de/perl6/2011-09-15#i_4433366

[12:14] <masak> the whitespace rule essentially puts postfixes/postcircumfixes in a different namespace than infixes.

[12:15] <jnthn> Maybe I shoulda phrased it as "if you don't want it to be interpreted as a postfix or postcircumfix, put spaces" :)

[12:15] <masak> jnthn: better than nothing :) I have to micro-backlog a lot, though.

[12:15] <snarkyboojum> woosley: oh that kinda seems like a different rule

[12:16] <snarkyboojum> space required between trait and {

[12:16] <woosley> perl6: say (2,4,5)>>+<<(1,1,1)

[12:16] <jnthn> snarkyboojum: It's not so different.

[12:16] <p6eval> pugs: OUTPUT¬´356‚ê§¬ª

[12:16] <p6eval> ..rakudo ab30d7, niecza v9-32-g380d891: OUTPUT¬´3 5 6‚ê§¬ª

[12:17] <jnthn> snarkyboojum: The reason it doesn't work is because it thinks you're supplying a postcircumfix to the "rw" :)

[12:17] <woosley> Ha, you can omit whitespace here!

[12:17] <dalek> rakudo/nom: 69136a4 | moritz++ | src/core/ (2 files):

[12:17] <dalek> rakudo/nom: implement chrs

[12:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69136a42b1

[12:17] <woosley> is it confusing?

[12:17] <woosley> :)

[12:17] <jnthn> woosley: Yes, the point is that in places you *can*, but if you'd like to avoid surprises then you probably shouldn't.

[12:18] <masak> no, it's the same rule.

[12:18] <snarkyboojum> jnthn: sure - so you shouldn't use whitespace before a postfix, except when it's not :D

[12:18] <snarkyboojum> I'm probably tautologising :)

[12:18] <jnthn> woosley: The reason you hit trouble the other way is because there's a postcircumfix operator <...> for indexing.

[12:19] <snarkyboojum> so, space everywhere apart from before postfixes ;)

[12:19] <woosley> good to know that!

[12:20] <masak> jnthn: actually it's the <<...>> indexing operator.

[12:20] <snarkyboojum> how does unspace fit into this? :)

[12:20] <jnthn> masak: ah, yes

[12:20] <masak> snarkyboojum: unspace is necessary when you want space anyway.

[12:20] <masak> snarkyboojum: that's why it's called "unspace", because it's whitespace that doesn't actually count as whitespace.

[12:21] <snarkyboojum> masak: on a superficial reading, that sentence seems very confusing :)

[12:21] <snarkyboojum> but got ya

[12:21] <masak> well, that confusion is what the term 'unspace' captures.

[12:21] <snarkyboojum> masak: aye

[12:21] *** MayDaniel joined
[12:22] <snarkyboojum> so unspace is really, ignoredspace

[12:22] <masak> yes.

[12:23] <snarkyboojum> goody

[12:23] <snarkyboojum> I think this conversation has spaced me out nicely :)

[12:24] <masak> a lot of things in Perl 6 are <ws>, whitespace. comments are <ws>, for example. I think Pod is <ws>.

[12:24] <masak> the thing unspace does is let you say "I want whitespace here, but don't parse it as <ws> -- and thus don't switch from expecting a postcircumfix or a postfix to expecting an infix".

[12:24] <masak> : - )

[12:24] <snarkyboojum> could something like peg/leg parse perl 6?

[12:24] <masak> talk about deconstructing the jokes.

[12:24] <snarkyboojum> or bits of it?

[12:25] <masak> the answer to the second question is trivially "yes" :)

[12:25] <snarkyboojum> masak: gotya.. maybe it should be called antispace instead :)

[12:25] <snarkyboojum> trivially?

[12:26] <snarkyboojum> peg/leg as in an implementation of, (http://piumarta.com/software/peg/peg.1.html) - not the concepts

[12:26] <jnthn> Well, parsing "1234" could count as parsing bits of Perl 6 :P

[12:26] <snarkyboojum> oh

[12:26] <masak> whatever peg/leg is, it could probably parse integer literals, say.

[12:26] <snarkyboojum> how about the first question? ;)

[12:26] <snarkyboojum> sans "bits of"

[12:28] <jnthn> That's probably much harder.

[12:29] <jnthn> e.g. how to simulate LTM in that case, how to handle the non-declarative bits... I don't know PEGs well enough to be sure of the answer, but I can imagine it's hard.

[12:31] *** masak left
[12:31] <jnthn> > sub foo(:$a) { say $a }; foo(a => 69, a => 42)

[12:31] <jnthn> 42

[12:31] <jnthn> > my %h = a => 69; foo(a => 42, |%h)

[12:31] <jnthn> 69

[12:31] <jnthn> tadzik: ^^

[12:31] <jnthn> spectesting

[12:31] <woosley> perl6: my @a=(2,4,5); @a.map({.say})

[12:31] <p6eval> rakudo ab30d7:  ( no output )

[12:31] <p6eval> ..pugs, niecza v9-32-g380d891: OUTPUT¬´2‚ê§4‚ê§5‚ê§¬ª

[12:32] <jnthn> (was quite a re-work of arg handling...there may be some fallout)

[12:32] <snarkyboojum> ok - sounds interesting anyway

[12:33] <jnthn> ugh, yes, something is now very broken :(

[12:33] <woosley> \o ~~

[12:33] <moritz> perl6: my @a=(2,4,5); sink @a.map({.say})

[12:33] <p6eval> pugs: OUTPUT¬´*** No such subroutine: "&sink"‚ê§    at /tmp/KmPTudEuGT line 1, column 16 - line 2, column 1‚ê§¬ª

[12:33] <p6eval> ..niecza v9-32-g380d891: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method statement_prefix:sink not yet implemented at /tmp/LrvEqhYSVN line 1 (EOF):‚ê§------> [32mmy @a=(2,4,5); sink @a.map({.say})[33m‚èè[31m<EOL>[0m‚ê§‚ê§Unhandled exception: Unable to resolve method statement_level in cl‚Ä¶

[12:33] <p6eval> ..rakudo ab30d7: OUTPUT¬´2‚ê§4‚ê§5‚ê§¬ª

[12:34] * jnthn just managed to make every single spectest fail o/

[12:34] <jnthn> Achievement!

[12:34] <woosley> perl6: (2,4,5).map: *.say

[12:34] <p6eval> pugs: OUTPUT¬´Inf‚ê§*** Cannot cast from VList [VBool True] to Pugs.AST.Types.VCode (VCode)‚ê§    at /tmp/JxA8wl5JwC line 1, column 1 - line 2, column 1‚ê§¬ª

[12:34] <p6eval> ..niecza v9-32-g380d891: OUTPUT¬´2‚ê§4‚ê§5‚ê§¬ª

[12:34] <p6eval> ..rakudo ab30d7: OUTPUT¬´*‚ê§¬ª

[12:34] <snarkyboojum> jnthn: only one place to go from there! :)

[12:35] <jnthn> oh, I see why...

[12:35] <moritz> .oO( achievement unlocked )

[12:35] <jnthn> :P

[12:35] <woosley> perl6: (2,4,5).map: {.say}

[12:35] <p6eval> rakudo ab30d7:  ( no output )

[12:35] <p6eval> ..pugs, niecza v9-32-g380d891: OUTPUT¬´2‚ê§4‚ê§5‚ê§¬ª

[12:36] *** birdwindupbird left
[12:36] <jnthn> ah, this looks better...

[12:37] <snarkyboojum> I really like the use of colon in those cases :)

[12:37] * moritz too

[12:37] <snarkyboojum> I know masak doesn't - or didn't use to ;)

[12:37] <woosley> I wonder why {} can be omitted here with '*.say'~~

[12:38] <moritz> woosley: beause *.say creates a block, just like { } does

[12:39] <moritz> map doesn't need a block, just something callable

[12:39] <moritz> perl6: my @a = (1, 2, 3).map(&say)

[12:39] <p6eval> niecza v9-32-g380d891: OUTPUT¬´Potential difficulties:‚ê§  @a is declared but not used at /tmp/UPPzhdj6ad line 1:‚ê§------> [32mmy [33m‚èè[31m@a = (1, 2, 3).map(&say)[0m‚ê§‚ê§123‚ê§¬ª

[12:39] <p6eval> ..pugs, rakudo ab30d7: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[12:39] <woosley> moritz:  I am thinking with the perl5 way :)

[12:40] <jnthn> Dang. One test fial.

[12:40] <felher> perl6: (1,2,3,4,5).grep: { $_ % 2 }.say

[12:40] <p6eval> rakudo ab30d7: OUTPUT¬´_block1010‚ê§¬ª

[12:40] <p6eval> ..niecza v9-32-g380d891: OUTPUT¬´Unhandled exception: Unable to resolve method say in class Block‚ê§  at /tmp/gb_DLdhu6a line 1 (MAIN mainline @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2060 (CORE C968_ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2061 (CORE module-CORE‚Ä¶

[12:40] <p6eval> ..pugs: OUTPUT¬´135‚ê§¬ª

[12:40] <felher> Hm, Pugs++

[12:40] *** kaare_ left
[12:41] <moritz> woosley: even perl 5 doesn't need a block

[12:41] <moritz> buubot_backup: eval: [map $_ + 1, 1, 2, 3  ]

[12:41] <buubot_backup> moritz: [2,3,4]

[12:43] <woosley> :-(

[12:43] <snarkyboojum> is (2,4,5).map: *.say doing something like (2,4,5).map: -> $x { $x.say } ?

[12:43] * woosley perldoc -f map  ing

[12:48] <eiro> snarkyboojum, remove * 

[12:48] <eiro> (i think) 

[12:49] <eiro> p6eval, < a b c >.map: .say 

[12:49] <eiro> p6eval < a b c >.map: .say 

[12:49] <eiro> p6eval: < a b c >.map: .say 

[12:49] <eiro> ??

[12:50] <static_perl> perl6: "what".say

[12:50] <p6eval> pugs, rakudo ab30d7, niecza v9-32-g380d891: OUTPUT¬´what‚ê§¬ª

[12:51] <eiro> arf... epic fail :)

[12:52] <static_perl> :)

[12:52] *** MayDaniel left
[12:52] <snarkyboojum> I thought * was converted into a curried closure

[12:52] <dalek> rakudo/nom: 029c30f | jnthn++ | src/ (6 files):

[12:52] <dalek> rakudo/nom: Refactor of flattening and better handling of duplicate named parameters. Decidedly not perfect, but maybe the best we can easily do for now.

[12:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/029c30fcca

[12:53] <jnthn> tadzik, moritz: ^^ should help with the Temporal stuff

[12:55] *** Chillance joined
[12:58] <snarkyboojum> or it's doing (2,4,5).map: { $^x.say }

[12:58] <snarkyboojum> :)

[12:59] <moritz> yes to both :-)

[13:00] <snarkyboojum> moritz: which both? :D

[13:02] <moritz> -> $x { $x.say }  and { $^x.say }

[13:02] <moritz> both are equivalent to *.say

[13:03] <snarkyboojum> goody

[13:03] *** uasi joined
[13:05] *** wolfman2000 joined
[13:09] <snarkyboojum> so -> is kinda shorthand for a lambda

[13:10] <moritz> it is. It starts an explicit signature

[13:10] <moritz> whereas { $^x } implicitly generates a signatuer

[13:12] <snarkyboojum> so -> $x { $x.say } is kinda like \x  -> say(x)

[13:13] <snarkyboojum> I like the explicit syntax, I reckon the -> $x { $x.say } type thing

[13:20] *** uasi left
[13:20] *** uasi joined
[13:25] *** jimmy1980 left
[13:31] *** jimmy1980 joined
[13:34] *** donri joined
[13:34] <tadzik> jnthn: cool

[13:42] *** jimmy1980 left
[13:54] *** lateau_ joined
[14:00] *** _jaldhar joined
[14:07] *** wolfman2000 left
[14:10] *** bloonix joined
[14:10] *** _jaldhar left
[14:19] *** mj41 left
[14:28] *** agentzh left
[14:28] <sorear> good * #perl6

[14:30] <sorear> jnthn: I'm curious what you think of the niecza approach to identifying type objects.

[14:37] *** MayDaniel joined
[14:37] <mberends> good * sorear

[14:40] *** woosley left
[14:42] *** whiteknight joined
[14:48] <sorear> mberends: no more questions for me?

[14:49] <mberends> sorear: so far so good, menus are almost working, I had previous not configured them properly. Toolbars also work ok.

[14:52] <jnthn> sorear: Essentially, $obj =:= $obj.WHAT ?

[14:53] *** daniel-s left
[14:53] *** daniel-s joined
[14:58] <sorear> jnthn: more like ===

[14:59] <jnthn> Well, then depends how the === is implemented ;)

[14:59] <sorear> jnthn: it's up to the REPR; my equivalent of P6opaque just happens to know that it never creates more than one undefined object

[15:01] <mberends> sorear: here's one: in niecza/examples/gtk1.pl:13, what would the syntax be to refer to a named event handler instead of the inline anonymous one?

[15:02] *** whiteknight left
[15:02] <sorear> you mean like .add_Clicked(&my_sub); ?

[15:03] <mberends> sorear: yes, like that. I had tried some variation(s) before that didn't work.

[15:03] <jnthn> sorear: Well, as I have it it's also up to the REPR; we just do REPR(foo)->defined(...).

[15:04] <jnthn> sorear: If you can absoletely be sure you'll only ever create the one, it can work the way you have it.

[15:05] <sorear> jnthn: under what circumstances will jnthn:P6opaque ever create more than one type object?

[15:05] <jnthn> sorear: Clone the type object.

[15:05] <sorear> per STable

[15:05] <jnthn> sorear: Also, representation polymorphism.

[15:05] <sorear> jnthn: that doesn't make more than one per STable though

[15:05] *** _jaldhar joined
[15:06] <jnthn> sorear: True, but I've been expecting that there'll still be a "canonical" WHAT.

[15:07] <jnthn> $p6opague-dog ~~ Dog and $p6hash-dog ~~ Dog should both be true.

[15:08] <jnthn> Anyway, if you forbid cloning the type object and were able to be sure that .WHAT on an s-table always pointed off to the type object for that representation, then yeah, it can work the way you have it.

[15:08] <jnthn> As you said, it's up to the REPR.

[15:08] <jnthn> On the rep poly, I need to think a little more there...or just implement it. :)

[15:09] <jnthn> (As in, actually make it work for real.)

[15:09] <jnthn> I'll try and do that in the not too distant future.

[15:10] *** packetknife joined
[15:10] <sorear> jnthn: I could add a SAME_REPR_WHAT easily enough.  Type object cloning concerns me more - it had never occurred to me that anyone might want to do that

[15:11] * sorear grumbles that the CLR *doesn't* give em any free bits to play with

[15:11] *** replore joined
[15:12] <jnthn> I think I did it based on nullness of the attribute store or some such.

[15:12] <sorear> Yes, you talked about that in the blog. :)

[15:12] *** packetknife left
[15:12] <jnthn> A null is a bit in a twisted sense. ;)

[15:12] <sorear> which is why I brought up my approach.

[15:12] <jnthn> No, I meant in the CLR version I used that. :)

[15:13] <sorear> Oh, right.

[15:13] *** packetknife joined
[15:13] <jnthn> I need to figger out how to do P6opaque well on the CLR at some point soon I guess...

[15:13] <sorear> niecza often has defined objects with a null attribute store for memory-saving reasons

[15:13] <jnthn> What I did when prototyping was, well, sucky.

[15:13] *** _jaldhar left
[15:14] <jnthn> sorear: BTW, iiuc you're doing a CPS transform in order to support gather/take?

[15:15] <jnthn> Did you consider any other approaches?

[15:15] <sorear> jnthn: stack reification, yes.  CPS is a bit of an inexact term

[15:15] <jnthn> "stack reification"?

[15:15] <jnthn> As in, allocate stack frames on the heap?

[15:15] <sorear> Niecza's call stack is made out of System.Object subclasses, not CLR runtime magic

[15:15] <sorear> and on the heap

[15:16] <sorear> niecza uses the CLR-stack about as much as nom uses the C-stack - a runops-like function receives control constantly and passes it to many different functions

[15:17] <moritz> so it's kinda of a small VM on top of mono?

[15:17] <moritz> s/VM/runloop/

[15:18] <sorear> the main other approach I considered was fibers, until someone in #mono politely informed me that they consumed 1MB of address space each on Windows, which would have limited me to ~2k concurrent gathers on Win32, which seemed unacceptably low

[15:19] <jnthn> sorear: I was also bothered and synchronization overhead there.

[15:19] <sorear> moritz: in some ways yes

[15:19] <sorear> I also considered CLR-level threads for a few seconds, then laughed and moved on :)

[15:19] <jnthn> s/and/about/

[15:20] *** lateau_ left
[15:20] <jnthn> A fiber is far less overhead than a thread but less doesn't mean "very little", from what I've read.

[15:20] <jnthn> Also, I dunno how well they work out away from Windows.

[15:20] <jnthn> Windows does fibers at kernel level, iiuc.

[15:21] <jnthn> Gah, too many interesting things to work on ;)

[15:22] * jnthn should call family and let them know he's still alive and stuff...bbiab :)

[15:28] *** _jaldhar joined
[15:29] *** packetknife left
[15:42] *** MayDaniel left
[15:51] <dalek> niecza/serialize: 06a8815 | sorear++ | / (3 files):

[15:51] <dalek> niecza/serialize: Add support for remaining types of lexicals in new model

[15:51] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/06a8815e46

[15:51] *** shinobicl_ joined
[16:04] *** birdwindupbird joined
[16:04] *** birdwindupbird left
[16:05] *** shinobicl_ left
[16:05] *** jferrero joined
[16:11] <dalek> niecza/serialize: 90803c5 | sorear++ | / (3 files):

[16:11] <dalek> niecza/serialize: Add signatures to new model

[16:11] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/90803c5fc5

[16:20] *** tokuhir__ joined
[16:20] *** tokuhiro_ left
[16:24] <diakopter> so ... much ... scrollback

[16:26] <benabik> diakopter: I rarely read the scrollback in #perl6‚Ä¶  Just too much happening.  :-/

[16:28] <sorear> I used to.  Now I just /lastlog sorear, /lastlog niecza, and call it done

[16:31] * jnthn tends do to it if there's ~12 hours missed

[16:31] <jnthn> But it's more "skim" than "read in full". :)

[16:35] * TimToady still tries to read everything, eventually, though skim happens...

[16:35] *** thou joined
[16:36] <jnthn> :)

[16:36] * jnthn has a nose for puns, OO stuff and multi-dispatch :)

[16:42] *** daniel-s left
[16:44] *** Moukeddar joined
[16:45] *** Moukeddar left
[16:49] *** uasi left
[16:51] *** ZapZ left
[17:03] <cognominal> std: my %a;  %a<a> :exists

[17:03] <p6eval> std bb4f150: OUTPUT¬´ok 00:01 120m‚ê§¬ª

[17:03] <cognominal> std: my %a;  say %a<a> :exists

[17:03] <p6eval> std bb4f150: OUTPUT¬´ok 00:01 121m‚ê§¬ª

[17:04] <diakopter> if only

[17:05] *** MayDaniel joined
[17:06] <sorear> diakopter: if only what?

[17:08] <diakopter> if only std could do 'say'

[17:08] <diakopter> but, of course, I should point out to cognomial that niecza runs std

[17:08] <moritz> whaz would it say?

[17:08] <moritz> *what

[17:09] * diakopter doesn't know

[17:09] <sorear> I should get back on that project

[17:09] <cognominal> I forgot that std does only parse

[17:09] <diakopter> *cognominal

[17:09] <sorear> niecza: my %a; say %a<a> :exists; # should be 'Bool::False'

[17:09] <p6eval> niecza v9-32-g380d891: OUTPUT¬´Bool::False‚ê§¬ª

[17:10] *** DarthGandalf left
[17:11] <cognominal> btw, how adverb like :exists works. Are they additional named parameters, to circumfix:<{ }> here?

[17:11] *** envi left
[17:11] <sorear> cognominal: yes

[17:12] <sorear> niecza: sub postcircumfix:<{ }>(|$args) { say $args.perl }; my %a; %a<a> :exists;

[17:12] <p6eval> niecza v9-32-g380d891: OUTPUT¬´\({}.hash, "a", |{"exists" => Bool::True})‚ê§¬ª

[17:12] <sorear> hmm, that output could be simplified a bit

[17:13] <cognominal> so, they just are syntactic sugar.

[17:13] <sorear> yes.

[17:13] *** DarthGandalf joined
[17:13] <sorear> niecza: my %a; say postcircumfix:<{ }>(%a, 'a', :exists)

[17:13] <p6eval> niecza v9-32-g380d891: OUTPUT¬´Bool::False‚ê§¬ª

[17:14] <cognominal> does niecza run on Lion?

[17:14] <moritz> it runs on mono

[17:14] <cognominal> I suppose I can install mono with macbrew

[17:14] <sorear> istr someone saying that mono 2.8 doesn't run on Lion but 2.10 does

[17:17] *** thou left
[17:22] <dalek> roast: b12d943 | jnthn++ | S03-smartmatch/any-hash-pair.t:

[17:22] <dalek> roast: Turn a todo into a skip.

[17:22] <dalek> roast: review: https://github.com/perl6/roast/commit/b12d9439fa

[17:22] <jnthn> b: say (*.foo).WHAT

[17:22] <p6eval> b 1b7dd1: OUTPUT¬´WhateverCode()‚ê§¬ª

[17:22] <dalek> rakudo/nom: c41a88b | jnthn++ | src/Perl6/Actions.pm:

[17:22] <dalek> rakudo/nom: Fix up *.foo(...) becoming a closure that does the method call.

[17:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c41a88b2a5

[17:27] <sorear> b: say *(15).WHAT

[17:27] <p6eval> b 1b7dd1: OUTPUT¬´invoke() not implemented in class 'Whatever'‚ê§  in main program body at line 22:/tmp/8HcCsIbZfY‚ê§¬ª

[17:27] <sorear> niecza: say *(15).WHAT

[17:27] <p6eval> niecza v9-32-g380d891: OUTPUT¬´Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Whatever‚ê§  at /tmp/QECu0C8oS2 line 1 (MAIN mainline @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2060 (CORE C968_ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 206‚Ä¶

[17:27] <sorear> huh.

[17:27] <sorear> I thought I implemented that

[17:27] <jnthn> What're you expecting it to do?

[17:27] <moritz> I don't think so

[17:28] <sorear> same as *.postcircumfix:<( )>(15)

[17:28] <jnthn> hm

[17:28] <jnthn> Guess it could be useful.

[17:29] <moritz> right

[17:30] <dalek> rakudo/nom: 15af90f | jnthn++ | src/Perl6/Actions.pm:

[17:30] <dalek> rakudo/nom: Don't Whatever-curry macros like .WHAT.

[17:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/15af90fb53

[17:30] <jnthn> Guess we can get back some tests now :)

[17:30] <jnthn> moritz: Any idea where some *.foo tests are? Or can I leave that with you? :)

[17:31] <moritz> jnthn: I'll run autounfudge

[17:31] <jnthn> OK, thanks

[17:31] <moritz> S02-types/whatever.t has some

[17:32] <jnthn> hmm, we don't run that one at all yet.

[17:32] <dalek> rakudo/nom: 1c7dde0 | jnthn++ | NOMMAP.markdown:

[17:32] <dalek> rakudo/nom: Remove a nommap entry.

[17:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c7dde00a1

[17:32] <moritz> nom: say (*+1).WHAT

[17:32] <p6eval> nom 029c30: OUTPUT¬´_block1014‚ê§¬ª

[17:32] <moritz> should be WhateverCode

[17:33] <jnthn> moritz: 15af90f

[17:34] <jnthn> > say (*+1).WHAT

[17:34] <jnthn> WhateverCode()

[17:34] <jnthn> :)

[17:34] <moritz> \o/

[17:34] <jnthn> It was currying the .WHAT.

[17:34] * moritz still compiles that commit

[17:35] <sorear> jnthn: about how many tests/files does nom run?

[17:35] *** packetknife joined
[17:36] <jnthn> sorear: In the run I just did, Files=460, Tests=14453

[17:36] <jnthn> Though that includes skips/todo's.

[17:36] <moritz> about 500 skips, I'd guess

[17:36] <jnthn> I *think* it does, anyway.

[17:36] <moritz> yes, it does

[17:36] <jnthn> OK, so 14,000ish.

[17:36] <jnthn> We should get another one or two thousand back once Pm lands regexy things.

[17:37] <jnthn> hmm, most of the punch list is regex related now.

[17:37] <jnthn> Well, much of.

[17:37] <moritz> nom: sub infix:<quack>($a, $b) { say "$a, $b" }; 5 quack 5

[17:38] <p6eval> nom 029c30: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "5 quack 5"‚ê§¬ª

[17:38] <jnthn> That's one of the regex related things ;)

[17:38] <moritz> I know :-)

[17:38] <moritz> it's in whatever.t

[17:38] <jnthn> ah 

[17:38] <jnthn> guess we have to skip that bit.

[17:39] <jnthn> DateTime, Date is one nommap entry. Seems that's well on the way now that various blockers are cleared up.

[17:39] <moritz> indeed

[17:39] <jnthn> The parametric roles entry is just down to me having the patience to crank through a few more issues.

[17:39] <jnthn> None of them are especially hard/major.

[17:40] <moritz> nom: my $code = *.uc eq 'FOO'; say $code(5)

[17:40] <p6eval> nom 029c30: OUTPUT¬´Method 'uc' not found for invocant of class 'Whatever'‚ê§  in <anon> at /tmp/LFLOZXfWOS:1‚ê§  in <anon> at /tmp/LFLOZXfWOS:1‚ê§‚ê§¬ª

[17:40] <moritz> evalbot rebuild nom

[17:40] <p6eval> OK (started asynchronously)

[17:40] <moritz> locally that dies with

[17:40] <moritz> Too many positional parameters passed; got 1 but expected 0

[17:40] <moritz> nom: my $c = (* + 1) * 2; say $c(5)

[17:41] <p6eval> nom 029c30: OUTPUT¬´12‚ê§¬ª

[17:41] <moritz> so recursive currying works with ops, but not with *.method

[17:41] <jnthn> hm, huh. :S

[17:41] * jnthn looks

[17:41] <moritz> roast++

[17:42] *** MayDaniel left
[17:43] <jnthn> > my $code = *.uc eq 'FOO'; say $code(5)

[17:43] <jnthn> Bool::False

[17:43] <jnthn> > my $code = *.uc eq 'FOO'; say $code('foo')

[17:43] <jnthn> Bool::True

[17:44] <jnthn> Testing then will push

[17:46] <sorear> *mumble* niecza isn't ahead of nom anymore :D

[17:46] <jnthn> moritz: As an Englishman, I have to say roast++ indeed ;)

[17:46] * jnthn enjoyed his regular Sunday roast when he lived back in the UK :)

[17:47] <moritz> nom: say 1 R- 5

[17:47] <p6eval> nom 029c30: OUTPUT¬´4‚ê§¬ª

[17:47] <moritz> nom: say (1 R- *).(5); 

[17:47] <p6eval> nom 029c30: OUTPUT¬´No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:‚ê§:(Mu, Mu %_)‚ê§‚ê§  in method Numeric at src/gen/CORE.setting:560‚ê§  in sub infix:<-> at src/gen/CORE.setting:1877‚ê§  in <anon> at /tmp/VUyzBcFd_8:1‚ê§  in <anon> at /tmp/VUyzBcFd_8:1‚ê§‚ê§¬ª‚Ä¶

[17:48] <jnthn> nom: say (1 R- *).WHAT

[17:48] <p6eval> nom 029c30: OUTPUT¬´No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:‚ê§:(Mu, Mu %_)‚ê§‚ê§  in method Numeric at src/gen/CORE.setting:560‚ê§  in sub infix:<-> at src/gen/CORE.setting:1877‚ê§  in <anon> at /tmp/EwhmQpq2JJ:1‚ê§  in <anon> at /tmp/EwhmQpq2JJ:1‚ê§‚ê§¬ª‚Ä¶

[17:48] <jnthn> ah

[17:48] *** thou joined
[17:50] <dalek> rakudo/nom: 165527d | jnthn++ | src/Perl6/Actions.pm:

[17:50] <dalek> rakudo/nom: Make nested curryings of whatever-curried method calls work (moritz++ for reporting).

[17:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/165527d2bd

[17:51] <dalek> roast: f1a2a79 | moritz++ | S02-types/whatever.t:

[17:51] <dalek> roast: fudge whatever.t for rakudo

[17:51] <dalek> roast: review: https://github.com/perl6/roast/commit/f1a2a7985d

[17:51] <moritz> b: * = 5; say 'alive'

[17:51] <p6eval> b 1b7dd1: OUTPUT¬´alive‚ê§¬ª

[17:51] <moritz> b: * = 5; say 'alive'; say *

[17:51] <p6eval> b 1b7dd1: OUTPUT¬´alive‚ê§Whatever()<0x200d770>‚ê§¬ª

[17:52] <moritz> nom: * = 5; say 'alive'; say *

[17:52] <p6eval> nom 029c30: OUTPUT¬´Cannot assign to a non-container‚ê§  in <anon> at /tmp/zT_Y1ps3SY:1‚ê§  in <anon> at /tmp/zT_Y1ps3SY:1‚ê§‚ê§¬ª

[17:52] <jnthn> hm, well, it ain't a container :)

[17:52] <moritz> that's for things like  my ($first, *, $third) = $str.split('foo')

[17:52] * jnthn wonders what the right way to make that one work is.

[17:53] <moritz> special-casing = ?

[17:53] *** packetknife left
[17:53] <sorear> TomC++ # cute parrot-dev@ post

[17:53] <moritz> aye :-)

[17:54] <jnthn> moritz: Well, more special cases on the assignment critical path are kinda annoying.

[17:54] <moritz> jnthn: well, that one kicks only in if the RHS is not a container

[17:54] <jnthn> oh, I wonder if...

[17:54] <sorear> moritz: lhs you mean?

[17:54] <moritz> erm, yes

[17:54] <moritz> sorry

[17:54] <jnthn> moritz: oh, good point, it's a failover.

[17:54] <jnthn> OK, then ti's cheap enough.

[17:55] *** _jaldhar left
[18:02] <dalek> roast: 5a430b3 | moritz++ | S02-types/whatever.t:

[18:02] <dalek> roast: rakudo unfudges for whatever.t

[18:02] <dalek> roast: review: https://github.com/perl6/roast/commit/5a430b3772

[18:03] <moritz> oh noez, the OOM killer eated my thunderbird!

[18:04] <moritz> nom: my @a = 1..4; say @a[1..*].join('|')

[18:04] <p6eval> nom 1c7dde: OUTPUT¬´2|3|4‚ê§¬ª

[18:05] <moritz> \o/

[18:08] * moritz closes three long-ish standing tickets

[18:12] <moritz> jnthn++

[18:13] *** donri left
[18:13] <dalek> roast: 47a4fa9 | moritz++ | S0 (2 files):

[18:13] <dalek> roast: more rakudo unfudges

[18:13] <dalek> roast: review: https://github.com/perl6/roast/commit/47a4fa9f77

[18:14] *** SHODAN left
[18:15] *** alester joined
[18:16] <dalek> niecza/serialize: 788e3f1 | sorear++ | / (4 files):

[18:16] <dalek> niecza/serialize: Changes required for finishlex/getsig/explain_mystery

[18:16] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/788e3f1184

[18:19] *** masonkramer joined
[18:26] *** kaare_ joined
[18:30] <ingy> hi moritz 

[18:30] <moritz> hi ingy 

[18:31] <ingy> wanna play with me?

[18:31] *** donri joined
[18:31] <ingy> actually, I was wondering if you'd review some stuff for me

[18:31] <alester> ping dukeleto 

[18:31] <moritz> ingy: depends on the stuff :-)

[18:31] <alester> seen dukeleto?

[18:31] <aloha> dukeleto was last seen in #perl6 18 hours 59 mins ago joining the channel.

[18:31] <ingy> I've been polishing on the pegex all day

[18:32] <ingy> moritz: https://github.com/ingydotnet/pegex-json-pgx/blob/master/json.pgx

[18:32] <moritz> I have to eat my supper first, but after that I'll be happy to review it

[18:33] <alester> What is winxed?

[18:33] <alester> https://github.com/petdance/ack/pull/177

[18:34] <alester> Is it separate from nap?

[18:34] <ingy> moritz: that's working now, with this receiver https://github.com/ingydotnet/pegex-json-pm/blob/master/lib/Pegex/JSON/Data.pm

[18:34] <moritz> -<pair>? ** /~<COMMA>~/

[18:34] <moritz> wouldn't that allow several commas in a row?

[18:34] *** miso2217 left
[18:35] <ingy> moritz: that's [<pair> ** <COMMA>]?

[18:35] <benabik> alester: Winxed is a system-level language on Parrot.  Something like C to PIR's assembler.

[18:36] <ingy> ~ is short for <WS>*

[18:36] <ingy> effectively

[18:38] <alester> benabik: extension would be what?

[18:38] <benabik> alester: File extension?  Most people seem to use .winxed

[18:38] <alester> maybe I'll hold off on winxed

[18:38] <alester> but add nqp

[18:38] <alester> if winxed isn't standardized yet

[18:39] <alester> Then again, the only people using nqp are, what, a dozen Perl 6 devs?

[18:39] <benabik> NotFound's very good at balancing needed features vs. not.  It's pretty stable.

[18:39] <benabik> Only people using winxed are, what, a dozen parrot devs?  ;-)

[18:40] <alester> yeah, that'

[18:40] <alester> I meant swinxed

[18:40] <ingy> moritz: I had   <pair> ** <comma>   working

[18:41] <ingy> moritz: and I went to do [ <pair> ** <comma> ]?

[18:41] <benabik> winxed is rapidly becoming the main way to develop on Parrot.  We used NQP-rx for quite a while, but winxed is closer to the "metal".  If you want to work on P6 on Parrot, NQP is the way to go.  Most new projects are using winxed.

[18:41] <ingy> moritz: but noticed it compiled down to <pair>? ** <comma>  internally

[18:42] <ingy> moritz: so I thought, sure, why not? that's not so bad

[18:43] <ingy> moritz: also <p>5 **<c> could mean list of 5 and <p> ** <c>? could mean trailing separator optional

[18:50] <sorear> alester: I don't think winxed will ever be standardized, in the way C or Javascript is

[18:50] <sorear> alester: it's a small implementation-defined language like Lua

[18:51] <benabik> sorear: Lua's not standardized?  People should stop using it immediately.  ;-)

[18:51] <sorear> benabik: non sequiter

[18:52] <sorear> (today's random idea: add S33 with rules for amending the synopses and turn perl6/specs into a nomic.)

[18:52] <benabik> sorear: I just want people to move to a language with an excellent specifications.  Like Perl 6.

[18:52] <benabik> ;-)

[18:53] <sorear> Lua fills Lua's niche far better than Perl 6 can hope to

[19:00] *** wolfman2000 joined
[19:03] *** thou left
[19:07] *** miso2217 joined
[19:07] <moritz> ingy: so why does <pair>? ** <comma> not allow multiple commas in a row?

[19:08] <moritz> perl6: say ',,' =~ /[<pair>?] ** \,/

[19:08] <p6eval> pugs: OUTPUT¬´*** ‚ê§    Unexpected "/[<"‚ê§    There is no =~ operator in Perl 6 -- did you mean ~~ (match) or ~= (concat-assign)?‚ê§    at /tmp/asu0OFNHG9 line 1, column 13‚ê§¬ª

[19:08] <p6eval> ..rakudo 165527: OUTPUT¬´===SORRY!===‚ê§Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at line 1, near " /[<pair>?"‚ê§¬ª

[19:08] <p6eval> ..niecza v9-32-g380d891: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at /tmp/KcxzPpTlBI line 1:‚ê§------> [32msay ',,' =~[33m‚èè[31m /[<pair>?] ** \,/[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[19:08] <moritz> perl6: say ',,' ~~ /[<pair>?] ** \,/

[19:08] <p6eval> niecza v9-32-g380d891: OUTPUT¬´Unhandled exception: Unable to resolve method pair in class Cursor‚ê§  at /tmp/feW2pvouvu line 1 (MAIN C1_ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1543 (CORE Regex.ACCEPTS @ 3) ‚ê§  at /tmp/feW2pvouvu line 1 (MAIN mainline @ 1) ‚ê§  at /home/p6ev‚Ä¶

[19:08] <p6eval> ..rakudo 165527: OUTPUT¬´Method 'pair' not found for invocant of class 'Cursor'‚ê§  in regex <anon> at /tmp/4KxVL_YUTy:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:5919‚ê§  in <anon> at /tmp/4KxVL_YUTy:1‚ê§  in <anon> at /tmp/4KxVL_YUTy:1‚ê§‚ê§¬ª

[19:08] <p6eval> ..pugs: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HANDLE>' trapped b‚Ä¶

[19:08] <moritz> perl6: say ',,' ~~ /[a?] ** \,/

[19:09] <p6eval> niecza v9-32-g380d891: OUTPUT¬´#<match from(0) to(2) text(,,) pos([].list) named({}.hash)>‚ê§¬ª

[19:09] <p6eval> ..pugs: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.16/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HANDLE>' trapped b‚Ä¶

[19:09] <p6eval> ..rakudo 165527: OUTPUT¬´,,‚ê§¬ª

[19:09] <moritz> ingy: matches in perl 6

[19:09] <moritz> ingy: I find compiling [a ** b]? to [a? ** b] highly dubious

[19:12] <moritz> matches a zero times, then b, then a zero times, then b, then a zero times

[19:12] <PerlJam> alester: just read the recent scrollback and you might want to mention to dukeleto that he can add his own types via the .ackrc file. 

[19:15] *** gbacon joined
[19:19] <alester> PerlJam: I think it's safe to assume that he knows that.

[19:20] * moritz adds .nqp to his ackrc

[19:22] *** alester left
[19:25] <benabik> Hm.  ackrc you say?  That would be useful.

[19:28] <sorear> moritz: I've seen syntaxes like <term>? ** ',' in the wild

[19:28] <sorear> (specifically the Haskell' tuple sections proposal comes to mind)

[19:29] <moritz> sorear: that might well be the case, but it's definitive wrong for matching JSON lists

[19:30] <moritz> (which doesn't allow multiple or trailing commas)

[19:30] <ingy> hi moritz 

[19:30] * moritz waves again

[19:31] *** wolfman2000 left
[19:31] <moritz> ingy: did you see my comments above?

[19:31] <ingy> yeah

[19:31] <moritz> one more thing... where are all the character names defined?

[19:32] <ingy> well <a> ** <b> matches a or aba etc

[19:32] <ingy> ones sec

[19:32] <moritz> yes, and <a>? ** <b> matches a, b, abba, bb, bba, ...

[19:33] <ingy> no

[19:33] <moritz> why not?

[19:33] <moritz> <a>? matches ''

[19:33] <moritz> <b> matches 'b'

[19:33] <ingy> because it is a special case

[19:33] <moritz> <a>? matches ''

[19:33] <moritz> ah

[19:33] <moritz> you failed to mention that, I think :-)

[19:34] <moritz> ingy: wouldn't it make more sense to put the ? onto the operator then?

[19:34] <moritz> <a> ?** <b>

[19:34] <moritz> 20:41 < ingy> moritz: and I went to do [ <pair> ** <comma> ]?

[19:34] <ingy> moritz: I did think about that, yes

[19:34] <moritz> 20:41 < ingy> moritz: but noticed it compiled down to <pair>? ** <comma>  

[19:34] <ingy> right

[19:34] <moritz> that's just plain wrong

[19:35] <moritz> ... unless you already had the special case implemented at that point

[19:35] <ingy> I did have a special case for ** yeah

[19:35] <ingy> and it didn't allow and ?+*

[19:36] <ingy> anyway

[19:36] <ingy> it's all up for ideas

[19:36] <ingy> which is why I came here

[19:36] <ingy> one sec

[19:37] <ingy> btw, https://github.com/ingydotnet/pegex-pm/blob/master/lib/Pegex/Grammar/Atoms.pm is where those are currently

[19:37] <moritz> ok, my idea is to write it as '<a> ?** <b>' rather than '<a>? ** <b>', because it's not the same as '[<a>?] ** <b>'

[19:37] <ingy> yeah, makes sense

[19:38] <ingy> I wanted ** to do ?** and ++ to do **

[19:38] <ingy> iykwim

[19:38] <moritz> that's only nice if you never plan to do possessive quantifiers

[19:39] <ingy> https://github.com/ingydotnet/pegex-json-pgx/blob/master/json.pgx.json

[19:39] <ingy> look at the .sep under map

[19:39] <moritz> one more thing, are you restricting the regexes to ASCII?

[19:39] <ingy> no

[19:40] <ingy> just the current atoms are defined that way, but they should not be so special

[19:40] <moritz> ok

[19:40] <ingy> they are just Pegex defined rules

[19:41] <ingy> whatever I do though needs to support very many programming langs

[19:41] <moritz> then you should think about (1) how to make Unicode properties available

[19:41] <moritz> and (2) how get more concistent character names

[19:41] <moritz> maybe allow <U+2024> or so

[19:41] <ingy> I think you misunderstand

[19:42] <ingy> I really just wanted names for punctuation chars

[19:42] <ingy> but really anything between // is a plain old regex

[19:42] <moritz> ok

[19:43] <moritz> all in all I rather like the pegex syntax

[19:44] <ingy> I'm not even sure how I feel about all the NAMEs, but I'm going with it for now

[19:44] <ingy> well it is heavily influenced by p6 :)

[19:44] <moritz> I find some of the NAMES a bit weird

[19:45] <ingy> https://github.com/ingydotnet/testml-pgx/blob/master/testml.pgx

[19:45] <ingy> that is my most complex grammar

[19:45] <moritz> they are a wild mixture of HTML entities names and other stuff :-)

[19:45] <ingy> it defines TestML

[19:45] <ingy> which many of the TestML and Pegex tests are written in

[19:46] <moritz> ingy: how do error messages of parse errors look like?

[19:47] <ingy> pretty decent

[19:47] <ingy> I'll gist one

[19:47] <ingy> https://github.com/ingydotnet/pegex-pm/blob/master/t/compiler.t

[19:47] <ingy> that test has inline testml, fyi

[19:47] <ingy> the test suite is amazingly fast

[19:48] <ingy> which seems to mean that pegex is fast

[19:48] <ingy> which is nice

[19:53] <ingy> moritz: here is a simple Pegex CLI one liner

[19:53] <ingy> https://gist.github.com/1225480

[19:53] <ingy> And I'll make a syntax error...

[19:54] <ingy> https://gist.github.com/1225483

[19:54] <ingy> :)

[19:55] <ingy> The grammar actually has that msg built in

[19:55] *** Moukeddar joined
[19:55] *** Moukeddar left
[19:56] *** whiteknight joined
[19:56] <moritz> nice

[19:56] <dalek> rakudo/nom: e051c8f | jnthn++ | t/spectest.data:

[19:56] <dalek> rakudo/nom: Run S02-types/whatever.t.

[19:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e051c8f7c7

[19:56] <ingy> moritz: https://gist.github.com/1225486 is more common

[19:57] <moritz> that's... less awesome :-)

[19:58] *** soh_cah_toa joined
[19:59] *** im2ee left
[20:00] <ingy> moritz: with debugging: https://gist.github.com/1225488

[20:01] <ingy> I think I'll need to add commit syntax soon

[20:02] <ingy> I'm pretty happy with the look of that JSON grammar

[20:03] <ingy> I don't think I need to add in the magic WS matching like Regexp::Grammars now that I have ~

[20:03] <ingy> but I am less pleased with the code that receives the parse events and turns them into real data

[20:04] <moritz> that always feels like boilerplate

[20:04] *** localhost left
[20:04] <ingy> this guy: https://github.com/ingydotnet/pegex-json-pm/blob/master/lib/Pegex/JSON/Data.pm

[20:04] <ingy> could be just a bit simpler

[20:05] <ingy> currently I ast /a(b)c(d)e/ matches as a hash {1=>'b', 2=>'d'}

[20:05] *** localhost joined
[20:06] <ingy> but I should just ['b', 'd']

[20:06] <ingy> and just 'b' for /a(b)cde/

[20:07] <ingy> if a regex has no captures I don't ast the match

[20:07] <ingy> which is nice

[20:08] <ingy> anyway I'll try <a> ?** <b> for now

[20:08] <ingy> seems pretty good

[20:09] <ingy> The json parser has one serious bug

[20:09] <ingy> it barfs on 0, "" and false

[20:09] <ingy> oops!

[20:10] <ingy> very soon I'll have a Perl 6 Pegex grammar started

[20:10] <ingy> for te C'Dent model at least

[20:11] *** zb left
[20:11] <ingy> since the grammars are just data structures it makes runtime grammar mod pretty easy

[20:11] *** zb joined
[20:13] <Woodi> ingy: you plan to add plain C to C'Dent ?

[20:13] * moritz -> sleep

[20:14] <Woodi> gn moritz 

[20:16] <ingy> moritz: night but look at https://gist.github.com/1225503

[20:16] <ingy> pegex compiling the pegex grammar and using it to parse the pegex grammar :)

[20:17] <ingy> that's with no special receiver of course...

[20:18] <ingy> receiving the parse with Pegex::Compiler::AST produces this: https://github.com/ingydotnet/pegex-pm/blob/master/lib/Pegex/Grammar/Pegex.pm

[20:20] <ingy> I made a special thing: > perl -Ilib -MPegex::JSON::Grammar=compile

[20:20] <ingy> will compile that grammar and dump it into itself

[20:21] <ingy> So pegex grammar classes are always precompiled 

[20:21] <ingy> Woodi: as a backend? C++ for certain

[20:21] <ingy> also beend thinking about XS as a C'Dent backend

[20:22] <ingy> so you could write p5 xs modules in p6 python or js

[20:22] <ingy> :D

[20:23] <ingy> some kind of C backend is a really big goal though

[20:23] <ingy> because then you get people using C'Dent subsets of their language just to get fast compiled modules

[20:24] <ingy> but then every other C'Dent backend language wins

[20:24] <ingy> whether they intended that or not

[20:25] <Woodi> just clonet C'Dent repo and C marked as output langueage

[20:26] <ingy> ?

[20:26] <Woodi> so, can C'Dent replace Perl[56], Python, Ruby, etc cpmpilers ? :)

[20:26] <Woodi> *compilers

[20:27] <ingy> C'Dent is only for writing modules

[20:27] <ingy> and you have to use a the strict C'Dent langugae subset

[20:27] <ingy> but the win is that your module works everywhere

[20:28] <ingy> so I don't think it replaces anything

[20:28] <Woodi> so i can get Python module and translate it to Perl6 ?

[20:28] <ingy> correct

[20:28] <Woodi> :)

[20:28] <ingy> wait no

[20:29] <ingy> you can write a Foo.cd.py module and compile to .pm6 or .go or whatever

[20:29] <ingy> you can't compile any .py

[20:29] <Woodi> it's translate for me...

[20:30] <ingy> and currently you can't do anything more than a module that prints hello world

[20:30] <ingy> :)

[20:30] <ingy> but that's just a matter of programming

[20:31] <Woodi> damn :)

[20:31] <ingy> Pegex is now almost complete enough to start implementing C'Dent in

[20:31] <ingy> the idea is to get C'Dent on Pegex this week

[20:31] <ingy> then start adding features to C'Dent

[20:32] <Woodi> i need any working db driver in Perl6, and was hoping :)

[20:32] *** pmurias joined
[20:32] <ingy> I want to start writing CPAN p5 modules in C'Dent soon

[20:33] <ingy> acutally

[20:33] <Woodi> p6 is in bigger need for modules...

[20:33] <ingy> a huge success would be to implement all of Pegex in C'Dent

[20:34] <Woodi> can PEG parse Perl ? :)

[20:34] <ingy> it can Parse C'Dent Perl :)

[20:34] <ingy> .cd.pm

[20:34] <Woodi> k, understud

[20:35] <ingy> Woodi: any module I write for CPAN in C'Dent automatically works in P6 :)

[20:35] <ingy> so (for CPAN) is a bit misleading

[20:36] <ingy> actually I have no grammar yet for .cd.pm

[20:36] *** _jaldhar joined
[20:36] <ingy> only for .cd.pm6

[20:36] <ingy> but theoretically in can parse cdp5

[20:36] <ingy> anyway, back to the trenches...

[20:37] <Woodi> so no translation from p[56] to C'Dent, back and forth ? someone need to writr in plain C'Dent and then compile to Perl, Python and rest ?

[20:37] <Woodi> gl ingy 

[20:43] <ingy> there is no plain c'dent. there is .cd.pm6 .cd.py and .cd.js parsers

[20:43] <ingy> and .cd.yaml too :)

[20:43] <ingy> but who wants to write an ast by hand?

[20:44] <ingy> .cd.yaml is great for testing though

[20:44] <pmurias> ingy: if c'dent is supposed to be the lowest common denominator of dynamic languages won't writing in it be annoying?

[20:45] <ingy> pmurias: I hope not

[20:45] <ingy> if you've ported a lot of your own code

[20:46] <ingy> you start using idions that translate

[20:46] <ingy> c'dent is pretty much automated porting

[20:46] *** kaare_ left
[20:46] <ingy> c'dent is defined at the ast level

[20:46] *** vlixes joined
[20:47] <ingy> so anything that can compile into a given ast is ok

[20:47] *** dorlamm joined
[20:47] <ingy> so we could add a lot of tmtowtdi to the .cd.pm[56] langs

[20:48] <ingy> I mean, just because I can't use hyperoperators in .cd.pm6 is not annoying to me

[20:49] <ingy> if I planned to port it 10 times in the first place

[20:49] <ingy> it would be really dumb to use things that wouldn't work elsewhere

[20:49] <pmurias> beating manual porting shouldn't be hard

[20:50] * ingy just pulled hyperoperators out of his butt

[20:50] <ingy> that is a p6 thing, yeah? :)

[20:50] * pmurias doesn't see a reason why .cd.pm6 shouldn't support them ;)

[20:50] <Woodi> so you need cd.nqp and perl6 compiler generating nqp code :)

[20:50] <pmurias> ingy: yes

[20:51] <ingy> actually I think dukeleto and me made .cd.pir

[20:51] <ingy> as an input lang!

[20:51] <Woodi> right, pir.

[20:51] <ingy> we definitely add .pir to backends

[20:52] <ingy> and .nqp too

[20:52] <pmurias> ingy: do a lot of people actually port their code to multiple languages?

[20:52] <ingy> sadly I don't think so. I'm trying to change that

[20:53] <ingy> that's what acmeism is all about

[20:54] <ingy> with pegex we can start a p6 implementation in any lang!!

[20:54] <pmurias> no

[20:55] <pmurias> well you can start one

[20:55] <ingy> pegex is really about sharing some of the p6 goodness with everyone 

[20:55] <pmurias> but you won't be able to fullfil the spec with a grammar that is not in perl6

[20:55] <ingy> I really ‚ô•d p6 regexes 

[20:55] <ingy> pmurias: sure but hey

[20:56] <ingy> I think when rakudo adds a pcre extension I'll be able to convert a lot of p6 grammars to pegex and get 1000 times speed boost

[20:58] *** pernatiy left
[20:58] <ingy> pegex is just an approximation or p6regexes, but it's all done in very simple and extendable classes

[20:58] <tadzik> Woodi: re Perl 6 and modules, me silent dream is to bring blizkost back to life make it run more stuff than it used to

[20:59] <ingy> hi tadzik 

[20:59] <pmurias> ingy: and one other possible problem i see with c'dent is that the apis will be unpythonic/unperlish/unrubish

[20:59] <ingy> pmurias: c'dent is not for writing code, it's for writing modules :)

[21:00] <ingy> but I don't think that's true anyway

[21:00] <ingy> I've done a ton of porting

[21:00] <ingy> and everything generally matches up line for line

[21:00] <ingy> once you define your idiom set

[21:01] *** MayDaniel joined
[21:01] <tadzik> hi ingy 

[21:02] <pmurias> ingy: so you end up having the same api for your modules in all the languages you port it to?

[21:05] <ingy> oh I see what you mean

[21:05] <ingy> sorry it's late

[21:05] <Woodi> tadzik: what was a stopper on blizkost ?

[21:05] *** gbacon left
[21:05] <tadzik> Woodi: manpower I suppose

[21:06] <ingy> pmurias: yeah sure

[21:06] <Woodi> tuits-- 

[21:06] <ingy> I mean it's targeted at OO langs only

[21:09] <ingy> the cool thing is that if you generate C then when you swig or XS it back you get the exact same api

[21:12] *** MayDaniel left
[21:12] <ingy> tadzik: what is blizkost?

[21:12] <tadzik> ingy: Parrot - Perl 5 bridge

[21:13] <tadzik> so you can use CGI:from<perl5> and it works in Perl 6

[21:13] <ingy> is there current effort to implement p6 in p5?

[21:14] <diakopter> no

[21:14] <ingy> pugs had a p5 runtime, yes?

[21:14] <soh_cah_toa> that's an interesting idea...

[21:15] <ingy> audreyt once showed me that you can build a vm for function programming on top of any lang that supports closures :)

[21:15] *** dukeleto left
[21:16] <plobsing> parrot's m0 has a perl5 backend. so rakudo might conceivably runnable on p5 at some point

[21:16] *** dukeleto joined
[21:16] <ingy> that was here answer to me when I asked if Bash could possibly be a backend for C'Dent

[21:16] <ingy> *her

[21:16] <plobsing> bash has closures?

[21:17] <ingy> nope

[21:17] <ingy> :)

[21:17] <soh_cah_toa> plobsing: i think the current m0 backend is just a prototype and the final implementation won't be p5 but c

[21:17] <ingy> it doesn't even have functions that return things

[21:17] <plobsing> soh_cah_toa: there are at least some people that want multiple backends

[21:18] <ingy> still it was a great answer

[21:19] <soh_cah_toa> i don't really see any advantages to multiple m0 backends but i'm not gonna digress the conversation and debate it here ;)

[21:20] <ingy> what is m0?

[21:20] <soh_cah_toa> ingy: a rework of parrot's internal vm components

[21:20] <plobsing> ingy: maybe I've missed something. how does the fact that you can't use one implementation strategy bar the existence of any simple (not too turing tarpit) implementation?

[21:21] <ingy> plobsing: it doesn't

[21:21] <plobsing> so how does the answer given have anything to do with the question asked?

[21:22] <ingy> well audreyt didn't know if bash had closures

[21:22] <plobsing> ah

[21:23] <ingy> it was a great answer with a disappointing ending

[21:23] <ingy> I like hacking in bash sometimes. it's amazing how far you can swim in that turing tarpit

[21:28] <plobsing> wait, doesn't creating a new process close-over the environment? couldn't subshells then be treated as closures?

[21:30] <ingy> I leave this as an exercise for the reader :]

[21:30] <Woodi> or use `cat somefile` :)

[21:31] <ingy> how does one get a callable reference to a subshell?

[21:31] * plobsing will now be unable to think about anything else this afternoon. thanks a lot ingy.

[21:31] * ingy is one of the readers

[21:33] <plobsing> igny: the PID is the reference. call is done via stdin/stdout (it is a pipe-mill). you can fetch those from /proc/ if necessary.

[21:35] <ingy> plobsing: do you need a thesis topic?

[21:38] <plobsing> what institution would take such a proposal? besides an asylum?

[21:46] *** dorlamm left
[21:46] <plobsing> it does seem like an interesting (and challenging topic). I might try to implement a scheme that way sometime.

[21:57] *** wallberg left
[21:57] *** wolfman2000 joined
[22:02] *** wolfman2_ joined
[22:03] *** wolfman2_ left
[22:03] <ingy> plobsing: nice :)

[22:03] <ingy> let me know what comes of it if you do.

[22:05] *** wolfman2000 left
[22:17] *** tokuhiro_ joined
[22:20] *** tokuhir__ left
[22:22] <sorear> good * #perl6

[22:26] *** Trashlord left
[22:41] <dalek> niecza/serialize: fb5e02c | sorear++ | / (7 files):

[22:41] <dalek> niecza/serialize: Compiler-side modifications to attach code to subs and run units

[22:41] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/fb5e02c732

[22:46] <ingy> I am finding the ** syntax less and less usefu :(

[22:46] <ingy> useful

[22:47] <ingy> it seems I never want just a ** b

[22:48] <ingy> I want [a ** b]? or a [ b a ]+

[22:50] <soh_cah_toa> ingy: you're saying the ** quantifier doesn't work inside non-capturing groups?

[22:52] <ingy> no

[22:53] <ingy> I'm saying that matching one or more a's separated by b's is not useful to me yet

[22:53] <ingy> I seem to want 0 or more or 2 or more

[22:54] <ingy> so the special ** syntax for one or more feels yagni at the moment

[22:54] <ingy> I'm sure ** is more generalized in p6 than what I am using it for

[22:55] <ingy> but i feel like I wasted my time implementing it in pegex

[22:56] <soh_cah_toa> ah, ok

[22:56] <ingy> then again, a [ b a ]* has a subtle difference than a ** b

[22:57] <ingy> in that I had to return the result of the first as [a,[a,a,...]]

[22:57] <ingy> but with ** I can return [a,a,a,...]

[22:57] <ingy> which is much cleaner

[22:59] <ingy> sigh. I'll pester moritz tomorrow

[22:59] <soh_cah_toa> :)

[23:04] <plobsing> ingy: does pegex have semantic expressions, or does it always return the tree of matched terminals?

[23:07] *** [particle]1 joined
[23:07] *** vlixes left
[23:08] <sorear> plobsing: iirc, pegex uses an actions-like mechanism to make pegex files more language-independant

[23:09] <sorear> plobsing: it's a little more powerful than p6 actions because it can trigger not just on rule successful exit but also on rule start and rule failure

[23:09] *** [particle] left
[23:11] <plobsing> sorear: cool! can the actions rewrite the tree being returned?

[23:13] <sorear> plobsing: unknown

[23:14] <plobsing> I ask, because the [a, [a, [...]]] problem could easily be solved by rewritting the tree as we bubble up

[23:17] <plobsing> my experience with pegs is from ometa, where listOf is easy for users to implement (but is common enough that it became a builtin).

[23:19] <sorear> does ohmeta use combinatorial pegs like parsec?

[23:21] <plobsing> sort of. parameterized rule calls are implemented by creating a new stream with the arguments at the head and the current stream as a shared tail.

[23:21] *** egillth left
[23:22] <plobsing> it is a rather simple argument-passing mechanism, but it lets you do cool things like pattern-match on your arguments the same way you pattern-match on the input

[23:22] <plobsing> (also, most implementations, including the original, are called OMeta)

[23:22] <plobsing> only mine is ohm

[23:23] *** whiteknight left
[23:24] *** whiteknight joined
[23:25] *** dukeleto left
[23:26] *** dukeleto joined
[23:26] *** dukeleto left
[23:26] <sorear> plobsing: wait, wait, I think I confused myself.  I thought ometa was the previous name of winxed?

[23:26] *** dukeleto joined
[23:26] *** dukeleto left
[23:27] *** dukeleto joined
[23:27] *** dukeleto left
[23:27] <plobsing> no. ometa is a peg system written by alessandro warth, originally in smalltalk, but then also in javascript

[23:28] <plobsing> it has since been ported to several languages, winxed included

[23:28] *** dukeleto joined
[23:32] *** dukeleto left
[23:32] *** Exodist joined
[23:33] *** dukeleto joined
[23:44] *** molaf left
[23:46] *** pmurias left
[23:49] *** Trashlord joined
[23:51] *** Trashlord left
[23:56] *** molaf joined
[23:57] *** LoRe_ joined
