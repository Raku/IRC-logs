[00:00] <jnthn> :)

[00:00] <jnthn> OK, sleep

[00:00] <jnthn> night o/

[00:00] <jnthn> .oO( I'm so going to be making a lot of coffee at $dayjob tomorrow... )

[00:00] <jnthn> &

[00:03] <dalek> rakudo/nom: 34be331 | pmichaud++ | src/core/Mu.pm:

[00:03] <dalek> rakudo/nom: Fix default .Stringy() in Mu.

[00:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/34be3316f3

[00:03] <dalek> rakudo/nom: 94a7f2e | pmichaud++ | src/Perl6/Actions.pm:

[00:03] <dalek> rakudo/nom: Nil is a lexical symbol now.

[00:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/94a7f2e46c

[00:03] <dalek> rakudo/nom: fb1f700 | pmichaud++ | / (2 files):

[00:03] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[00:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb1f700ac4

[00:03] <dalek> rakudo/nom: b04c763 | pmichaud++ | / (3 files):

[00:03] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[00:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b04c763b87

[00:03] <dalek> rakudo/nom: 66c1021 | pmichaud++ | / (3 files):

[00:03] <dalek> rakudo/nom: Refactor Range, add the ability to exclude endpoints.  Also remove the RangeIter class.

[00:03] <dalek> rakudo/nom: 

[00:03] <dalek> rakudo/nom: Since Range is immutable, it can serve directly as its own iterator

[00:03] <dalek> rakudo/nom: and doesn't need a RangeIter helper to keep track of generated

[00:03] <dalek> rakudo/nom: elements.  This eliminates some duplication of code, and provides

[00:03] <dalek> rakudo/nom: some much nicer optimization possibilities.

[00:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/66c1021eab

[00:05] *** alyx left
[00:07] *** icwiener left
[00:08] *** kst left
[00:10] *** ymasory joined
[00:16] *** info left
[00:24] *** daniel-s left
[00:27] *** alyx joined
[00:27] *** alyx is now known as Guest54464

[00:33] *** lichtkind left
[00:42] *** kst joined
[00:50] *** Eglis joined
[00:52] <Eglis> I'm curious in when will perl 6 be ready for prod, been programming perl for 10 years and for the past 8 years i saw perl6 being developped. any time frame ?

[00:53] <pmichaud> it's ready for production now, if your idea of production is what we currently support.  :)

[00:54] <TimToady> semantically, it's already mostly a superset of Perl 5; we're mostly trying to get it faster now

[00:54] <Eglis> Can we run old perl in perl6? most of my code is 5.8 or older

[00:55] <TimToady> but realistically, when the several implementations agree on freezing a version of the spec tests at v6.0.0, that's when we have a production release of the *language* as opposed to an implementaiton

[00:55] <TimToady> *tion

[00:55] <TimToady> I think we're converging on that within a year or so

[00:56] <TimToady> nom: say 1,2,3...*

[00:56] <p6eval> nom: OUTPUT«Could not find sub &infix:<...>␤current instr.: '_block1002' pc 112 ((file unknown):63289482) (:1)␤»

[00:56] <TimToady> aw

[00:56] <pmichaud> I'm working on sequence later tonight, I think.

[00:56] <TimToady> nom: say 1..*

[00:56] <p6eval> nom: OUTPUT«1..Inf␤»

[00:56] <pmichaud> that one works, though :)

[00:57] <TimToady> haven't backlogged completely, but some of them could use the first few terms of the infinite series before giving up

[00:57] <pmichaud> yes, I was going to experiment with that too

[00:57] <Eglis> Will you be able to do the asynchron stuff like in the Go language ?

[00:58] <TimToady> something similar, though probably not identical

[00:58] <Eglis> :) reading "much better", i wear perl underwear

[00:58] <TimToady> :)

[00:59] <TimToady> that is one of the areas where different implementations will have different strengths, due to platform limitations

[00:59] <Eglis> I just hope perl6 comes out before php6 ( as the php developpers always said that for sure php6 would come out before perl6 )

[00:59] <pmichaud> technically, perl6 is out already

[01:00] <pmichaud> has been for a while

[01:00] <Eglis> not scared about linux implementation

[01:00] <Eglis> yeah but no 6.0.0 official release

[01:01] *** noganex joined
[01:01] <pmichaud> the releases of Rakudo star are "official releases".  The language spec is likely going to be somewhat larger than any given implementation for some time.

[01:02] <pmichaud> but that doesn't mean that perl 6 isn't available or that it can't be used

[01:03] <Eglis> it still needs to be adopted by linux distros 

[01:03] <pmichaud> it's already available in fedora

[01:04] <pmichaud> (fedora 14)

[01:04] <Eglis> It's crucial that enterprise level distros have it, fedora is for the basement :) 

[01:04] <Eglis> does rhel6 have it ?

[01:04] <pmichaud> that just takes time

[01:04] <pmichaud> and we don't get to tell the distros what to do.

[01:04] <pmichaud> that's entirely up to the distro.

[01:04] <Eglis> i agree

[01:04] *** noganex_ left
[01:04] <Eglis> Fedora is nice, to experiment 

[01:05] <pmichaud> of course, people used to say similar things about linux in general:  "It's nice to experiment, but no enterprise-level organization will use it"

[01:05] <pmichaud> there wasn't a specific linux release where everyone said "it's ready for the enterprise."  It depends on the nature of the enterprise as to whether it meets your needs or not.

[01:05] <Eglis> I started a new job and most of their public facing servers are rhel 8, fc 1,2,3 

[01:06] <Eglis> not updated

[01:06] <pmichaud> sure

[01:06] <TimToady> in our case, once we trim down the 6.0.0 spec to what people are actually going to implement first, the rest of it will serve as an excellent gameplan for after that.

[01:10] <Eglis> :) 

[01:11] *** Eglis left
[01:21] <jdhore1> That's funny.

[01:22] <jdhore1> Considering RHEL 8 does not exist and probably will not exist for at least 6 years (if i had to guess)

[01:29] *** ajoe47 joined
[01:29] <ajoe47> perl6: say 3

[01:29] <p6eval> pugs, rakudo 248244, niecza v6-177-g365e216: OUTPUT«3␤»

[01:30] *** ajoe47 left
[01:37] *** cooper left
[01:38] *** whiteknight left
[01:39] *** cooper joined
[01:44] <colomon> $Inf?

[01:47] <colomon> (looking at the Range patch.)

[01:50] <colomon> pmichaud: do I understand correctly that when you get the next Range iterator, it's just another Range with min incremented?

[01:54] *** thou left
[01:59] *** Guest54464 is now known as alyx

[01:59] *** alyx left
[01:59] *** alyx joined
[02:04] *** envi_laptop joined
[02:05] *** woosley joined
[02:40] *** thou joined
[02:47] <thou> perl6: my $foo = 'guten tag!'; <<a 'b c' '$foo' "$foo bar" d>>.perl.say; <a 'b c' '$foo' "$foo bar" d>.perl.say;

[02:47] <p6eval> pugs: OUTPUT«("a", "b c", "\$foo", "guten tag! bar", "d")␤("a", "\'b", "c\'", "\'\$foo\'", "\"\$foo", "bar\"", "d")␤»

[02:47] <p6eval> ..niecza v6-177-g365e216: OUTPUT«["a", "'b", "c'", "'guten", "tag!'", ""guten", "tag!", "bar"", "d"].list␤("a", "'b", "c'", "'$foo'", ""$foo", "bar"", "d")␤»

[02:47] <p6eval> ..rakudo 248244: OUTPUT«("a", "'b", "c'", "'\$foo'", "\"\$foo", "bar\"", "d")␤("a", "'b", "c'", "'\$foo'", "\"\$foo", "bar\"", "d")␤»

[02:57] <thou> is pugs right here?

[03:04] *** ajoe47 joined
[03:11] <colomon> Hmmm.... I seem to recall that rakudo doesn't implement <<    >> quoting correctly...

[03:13] <lue> rakudo: my $foo = "ouais mec!"; 􏿽xABa 'b c' '$foo' "$foo bar" d􏿽xBB.perl.say; # me is curious now

[03:13] <p6eval> rakudo 248244: OUTPUT«===SORRY!===␤Confused at line 22, near "\ufffda 'b c' '"␤»

[03:15] <lue> locally I get this: Cannot form :w list from non-constant strings (yet) at line 1, near ".perl.say;"

[03:15] <thou> rakudo, niecza and nom are all ganging up on pugs

[03:16] <lue> ASCII-ifying the guillemots gets me the same line as above [    ("a", "'b", "c'", "'\$foo'", "\"\$foo", "bar\"", "d")    ]

[03:17] <lue> Maybe the << is being seen by rakudo as < instead of 􏿽xAB ?

[03:18] <colomon> lue:  I suspect that is it.

[03:20] <lue> I wonder what breaks it, 'cos << is interpreted correctly otherwise (try    say <<a b c> <d e f>>    )

[03:23] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:30] *** ajoe47 left
[03:31] *** ajoe47 joined
[03:46] *** ajoe47 left
[03:51] *** ymasory left
[03:55] *** wamba joined
[04:02] *** yinyin joined
[04:07] *** satyavvd joined
[04:08] *** Shozan left
[04:15] *** Chillance left
[04:34] *** mberends joined
[04:36] * thou is up to S10. feeling like i'm starting to enter the inner sanctum.

[04:37] <thou> i admit i did gloss over some of the details in S09.

[04:39] <thou> i'm looking forward to S12, i think that'll help answer a lot of my current stack of questions

[04:57] *** birdwindupbird joined
[05:01] *** jaldhar left
[05:07] *** wamba left
[05:09] *** jaldhar joined
[05:11] *** koban joined
[05:25] <sorear> thou: S02 is the important one anyway

[05:26] <thou> yeah

[05:27] <thou> but i'm still understanding more of S02 as I make my way through the rest :-)

[05:28] *** jaldhar left
[05:28] <thou> that whole thing about minimizing forward references ... i guess it mostly worked, but there's still a heap o' stuff to keep on my stack :-)

[05:29] *** mberends left
[05:34] *** jaldhar joined
[05:37] *** kaare__ joined
[05:45] *** f00li5h is now known as f00li5h[squeeze]

[06:02] <dalek> rakudo/nom: e8405b0 | pmichaud++ | src/core/ (3 files):

[06:02] <dalek> rakudo/nom: Clean up some GATHER instances now that gather { ... } works again (jnthn++).

[06:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e8405b0f76

[06:02] <dalek> rakudo/nom: ddc0166 | pmichaud++ | / (2 files):

[06:02] <dalek> rakudo/nom: Add terms.pm .

[06:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ddc0166fcd

[06:02] <dalek> rakudo/nom: f991181 | pmichaud++ | src/core/MapIter.pm:

[06:02] <dalek> rakudo/nom: Improve the speed of MapIter a bit.

[06:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f991181fbf

[06:02] <dalek> rakudo/nom: 92fa939 | pmichaud++ | src/core/ (3 files):

[06:02] <dalek> rakudo/nom: Improve iterator dumpers a bit.

[06:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/92fa939ddd

[06:02] *** Woodi left
[06:02] *** Woodi joined
[06:13] *** Su-Shee_ is now known as Su-Shee

[06:13] *** wtw joined
[06:58] *** wamba joined
[07:02] *** mj41 joined
[07:08] *** wamba left
[07:14] *** zby_home_ left
[07:16] *** mj41 left
[07:17] *** mj41 joined
[07:18] *** fhelmberger joined
[07:30] *** daniel-s joined
[07:36] *** cooper left
[07:45] *** azawawi joined
[07:45] <azawawi> hi

[07:46] <azawawi> why can i find some source code for a minimal Perl 6 syntax highlighter?

[07:47] <tadzik> does perl6.vim count?

[07:48] <azawawi> something simpler.

[07:48] <azawawi> im working on Perl 6 lexer for scintilla in Wx::Scintilla

[07:49] <azawawi> I released an initial Perl 6 syntax highlighter earlier this week in http://beta.metacpan.org/module/Wx::Scintilla

[07:49] <azawawi> that's why im asking for a minimal lexer code to start with... a proof of concept to build a more complicated one

[07:50] *** wamba joined
[07:52] <sorear> perl6.vim doesn't work all that well

[07:52] <azawawi> sorear: hi

[07:52] <sorear> if you find ANYTHING that can highlight Perl 6 in real time significantly better than perl.vim... I'd love to see it

[07:52] *** wamba left
[07:53] <sorear> vim likes to rehilite files after each keypress, and, well, I type too fast for perl6.vim

[07:54] *** wamba joined
[07:54] *** daniel-s left
[07:55] <azawawi> sorear: That's what I am working at in http://api.metacpan.org/source/AZAWAWI/Wx-Scintilla-0.12/wx-scintilla/src/scintilla/src/LexPerl6.cxx

[07:56] <azawawi> it is still experimental but i hope to get done by this weekend

[07:57] <azawawi> once finished it means all wxWidgets editors (i.e. Padre, Kephra) can utilize it

[07:58] <azawawi> I can backport it afterwards to Syntax::Highlight::Perl6::Fast

[07:58] <azawawi> http://try.rakudo.org/ down?

[07:58] <sorear> AFAIK it has been for a while

[08:02] <tadzik> it's rarely up :/

[08:03] <azawawi> sorear: what's the average line count of Perl 6 files that you work on?

[08:03] <azawawi> sorear: are we talking about STD.pm6?

[08:04] <sorear> azawawi: it starts to become a problem at about 500 lines and is unusable for NieczaActions (3000) and STD

[08:05] <azawawi> sorear: any hyperlinks so I can add it to my benchmarks?

[08:05] *** aloha left
[08:05] <sorear> github.com/sorear/niecza, src/NieczaActions.pm6

[08:11] <azawawi> Thanks. I will use STD.pm6 and NieczaActions.pm6 while testing LexPerl6.cxx

[08:11] <sorear> how well does it handle something like q:s'&infix:sym<$S>' ?

[08:12] <azawawi> it doesnt handle anything at the moment.

[08:17] *** wamba left
[08:17] *** daxim joined
[08:18] *** cotto left
[08:35] *** Woodi left
[08:36] *** Woodi joined
[08:50] *** daniel-s joined
[08:58] *** thou left
[08:58] *** azawawi left
[09:00] *** aloha joined
[09:17] *** kst` joined
[09:21] *** kst left
[09:22] *** pothos joined
[09:24] *** y3llow joined
[09:37] *** cognominal_ left
[09:38] <flussence> .oO( bah, I make up easy-to-remember ssh passwords then can never remember them... )

[09:38] * moritz generates easy-to-use ssh keys

[09:39] <flussence> got it after 5 tries :)

[09:39] *** JimmyZ joined
[09:42] <flussence> hm, try.rakudo backend works fine, the website itself is down... :/

[09:44] <flussence> there, all fixed

[09:44] <moritz> was apache down?

[09:45] <flussence> seems it wasn't running

[09:45] <flussence> probably got stopped after the main site got moved, the last log on here is April 22ish

[09:46] <moritz> Rakudo REPL has timedout... reaping.

[09:47] <flussence> those are just the standard "nobody's using this process" cleanup things

[09:47] <moritz> uhm... feather3 runs sid?

[09:47] <flussence> no idea

[09:47] <moritz> Get:6 http://ftp.us.debian.org sid/main Sources/DiffIndex [2,038B]

[09:47] <flussence> oof.

[09:47] <moritz> is what 'aptitude update' is saying

[09:50] * moritz updates feather2

[09:50] <moritz> that's a debian stable, something that I dare to touch

[09:50] <flussence> if it is sid, then it apparently hasn't been updated in a *long* time - screen complains about my 21-char $TERM being too long

[09:52] <moritz> good, perl6.org still shows up after a security update of apache, openssl and perl

[09:57] *** MayDaniel joined
[10:08] *** woosley left
[10:22] *** f00li5h[squeeze] is now known as f00li5h

[10:30] *** Woodi left
[10:31] *** MayDaniel left
[10:32] *** Woodi joined
[11:12] *** JimmyZ_ joined
[11:15] *** JimmyZ left
[11:15] *** JimmyZ_ is now known as JimmyZ

[11:38] *** Moukeddar joined
[11:39] *** Moukeddar left
[11:43] *** satyavvd left
[11:48] *** JimmyZ_ joined
[11:48] *** domidumont left
[11:51] *** JimmyZ left
[11:52] *** JimmyZ_ is now known as JimmyZ

[11:53] *** domidumont joined
[11:55] <takadonet> morning all

[12:06] *** leprevost joined
[12:08] *** orafu left
[12:12] *** orafu joined
[12:12] *** Chillance joined
[12:20] <pmichaud> good morning, #perl6

[12:22] <pmichaud> question of the morning:  Is there a syntax so that a programmer can request inlining of a pblock?  (I know that the compiler will someday be smart enough to figure it out on its own... until then, an explicit request mechanism might be helpful.)

[12:23] <moritz> I don't think there is

[12:23] <pmichaud> can we make one?  :)

[12:23] <pmichaud> for now I'm thinking of just putting a comment inside the opening block marker

[12:23] <moritz> what about INLINE <blorst> ?

[12:24] <pmichaud> I'm really interested in pblock more than blorst atm

[12:24] *** MayDaniel joined
[12:24] <pmichaud> (i.e., if/else, while, and for)

[12:25] <pmichaud> or maybe xblock would be sufficient

[12:25] <moritz> something like   if $foo { #INLINE \n say $foo }  ?

[12:26] <pmichaud> yeah

[12:26] *** MayDaniel left
[12:26] <pmichaud> exactly that is what I was thinking for now :)

[12:28] *** yinyin left
[12:28] <pmichaud> iterators in nom are currently slow again... I'm thinking that inlining blocks might help (without having to resort to Q:PIR or funny parenthesized constructs)

[12:29] <moritz> how slow are they?

[12:29] <pmichaud> about 2x master

[12:29] <moritz> 2x as fast? or as slow?

[12:30] <pmichaud> 2x slow

[12:30] <moritz> wow

[12:30] <pmichaud> I'm only a little surprised -- we end up with a lot of block invocation overhead that master didn't have

[12:30] <moritz> considering how much faster the rest of nom is, I'm surprised

[12:31] <pmichaud> well, iterators in master were completely hand-tuned PIR, no extra lookups.  In nom they're just generated code, lots of extra lookups

[12:32] <pmichaud> but I still suspect it may be the block invocation overhead that is causing the slowdown

[12:32] <pmichaud> for example, in nom if we process a 10000 element array, we get at least O(10000) block invocations that master doesn't have.

[12:32] <pmichaud> (in while and if loops)

[12:32] <PerlJam> good * #perl6

[12:33] <pmichaud> and O(10000) is really O(10000 * *), since there's the cost of the while loop itself and its nested if/then blocks

[12:33] <pmichaud> but beyond that, I'd really like to get to the point someday where

[12:33] <pmichaud>     for @list { ... }

[12:33] <pmichaud> can inline the { ... }, and it would be good to start experimenting with that sooner rather than later in controlled conditions

[12:34] <pmichaud> PerlJam:  o/

[12:35] <PerlJam> pmichaud: when *wouldn't* a pblock be inlined?  

[12:35] <pmichaud> PerlJam: when it's a closure

[12:35] <pmichaud> my $x = -> { ... }

[12:36] <PerlJam> pmichaud: can't you determine that relatively easily now?

[12:36] <pmichaud> PerlJam: it's more than that, we have to have lexpads for the pblock's lexicals.

[12:36] <pmichaud> in the case of

[12:37] <pmichaud>     for @list -> $x, $y { ... }

[12:37] <JimmyZ> PerJam:  for @list { my $a;  .... }

[12:37] <pmichaud> we have to not online inline the code for the block, but we have to do a signature bind of $x and $y to the munched arguments of @list (more)

[12:38] <pmichaud> at present we don't have a way of doing that, and I don't want to wait for getting all of those invalidating assumptions in place before doing some inlining

[12:38] <pmichaud> *not only

[12:39] <pmichaud> afk for a bit

[12:46] <tadzik> hrm. What more is needed than when a block does not take any parameters or does not declare variables?

[12:48] * PerlJam looks at pictures of NPW

[12:48] <moritz> PerlJam: URL?

[12:49] <tadzik> oh, pics!

[12:49] <pmichaud> tadzik: none of its inner blocks use OUTER::, perhaps

[12:50] <tadzik> oh, that too

[12:50] <PerlJam> http://blogs.perl.org/users/claes_jakobsson/2011/06/why-community-matters.html

[12:50] <PerlJam> Those aren't the pictures, but that's where I got the link from.

[12:50] *** mtk joined
[12:51] <PerlJam> pmichaud: Perhaps it's just my ignorance, but it really feels like "someday" could be today.  Or, perhaps get you and jnthn looking at the same problem and "someday" could be in a matter of hours.

[12:51] <moritz> PerlJam: problem is that many features that might prevent inlining are NYI

[12:52] <PerlJam> moritz: that doesn't sound like a problem at all  ;)

[12:52] <moritz> PerlJam: so we kinda build up a hurdle for implementing them in future if we rely on their absence

[12:52] <pmichaud> PerlJam: and the first step for that is likely to have a way to flag a block as inlinable, no?  

[12:52] <PerlJam> pmichaud: good point.

[12:53] <pmichaud> or do we just assume that all blocks get inlined and then pessimize whenever something breaks?

[12:53] <pmichaud> that seems like... icky.

[12:53] <PerlJam> I think I've become less patient in my old age.

[12:54] <pmichaud> I'm saying I want to break the problem down into two parts:  (1) have the ability to inline blocks without having the compiler have to figure out when to do it, and (2) get the compiler to figure out when to do it :)

[12:55] *** smash joined
[12:55] <smash> hello everyone

[12:56] <PerlJam> smash: greetings

[12:57] <tadzik> 1) looks either temporal, non-specy or both, something we might want to have like now, 2) is rather a long term goal

[12:59] * PerlJam wonders if it should be specced.

[12:59] <tadzik> mebbe

[12:59] <pmichaud> thus my question :-)

[12:59] <PerlJam> I mean that's what we have $?vars 

[13:00] *** Holy_Cow joined
[13:00] *** Holy_Cow left
[13:05] <PerlJam> COMPILING::<

[13:05] <PerlJam> COMPILING::<$?INLINE> = True;  # ?

[13:05] <pmichaud> PerlJam: I don't understand, at least not for my use case.

[13:06] <tadzik> INLINE {}

[13:06] <pmichaud> tadzik: looks too much like a phaser, I think.

[13:06] <tadzik> right. Hrm

[13:06] <PerlJam> pmichaud: I was thinking you'd put that in any block you wanted inline.

[13:07] <pmichaud> PerlJam: oh, maybe.  We don't have those sorts of compile-time variables yet, I don't think.

[13:07] <moritz> PerlJam: I think that requires too much effort on behalf of the compiler

[13:07] <tadzik> if it wasn't supposed to be speccy, that wasn't a problem

[13:07] <pmichaud> also, it needs to be attached to a block, not to the overall compiler (if it's to be done on a per-block basis, which is my use case)

[13:07] <tadzik> s:2nd/wasn't/wouldn't/

[13:08] <tadzik> .u moustache

[13:08] <phenny> tadzik: Sorry, no results for 'moustache'.

[13:08] <tadzik> dang

[13:09] <moritz> .u beard

[13:09] <phenny> moritz: Sorry, no results for 'beard'.

[13:09] <tadzik> .u bear

[13:09] <phenny> tadzik: Sorry, no results for 'bear'.

[13:09] <tadzik> how boaring

[13:09] <moritz> .u panda

[13:09] <phenny> moritz: Sorry, no results for 'panda'.

[13:10] <moritz> .u tiger

[13:10] <phenny> U+2EC1 CJK RADICAL TIGER (⻁)

[13:10] <tadzik> nice square

[13:10] <tadzik> truly a radical tiger

[13:21] *** wamba joined
[13:22] *** mattp_ left
[13:26] *** Woodi left
[13:28] *** Woodi joined
[13:40] *** bkolera joined
[13:50] *** wtw left
[13:50] *** dodododo joined
[13:50] <daniel-s> .u lol

[13:50] <phenny> daniel-s: Sorry, no results for 'lol'.

[13:50] <daniel-s> .u phenny

[13:50] <phenny> daniel-s: Sorry, no results for 'phenny'.

[13:50] <daniel-s> .u perl

[13:50] <phenny> daniel-s: Sorry, no results for 'perl'.

[13:51] <daniel-s> .u irc

[13:51] <phenny> daniel-s: Sorry, no results for 'irc'.

[13:51] <daniel-s> .u anything

[13:51] <phenny> daniel-s: Sorry, no results for 'anything'.

[13:51] <daniel-s> .u suck

[13:51] <phenny> daniel-s: Sorry, no results for 'suck'.

[13:51] <moritz> .u disc

[13:51] <phenny> U+2382 DISCONTINUOUS UNDERLINE SYMBOL (⎂)

[13:51] <moritz> .u server

[13:51] <phenny> moritz: Sorry, no results for 'server'.

[13:51] <perplexa> .u swastika

[13:51] <phenny> perplexa: Sorry, no results for 'swastika'.

[13:51] <perplexa> :p

[13:51] <perplexa> it's broken

[13:53] *** PacoLinux joined
[13:54] <perplexa> .u U+534D

[13:54] <phenny> perplexa: Sorry, no results

[13:54] *** broquaint joined
[13:55] <perplexa> .u 21325

[13:55] <phenny> perplexa: Sorry, no results for '21325'.

[13:55] <moritz> .u 534D

[13:55] <phenny> U+534D CJK UNIFIED IDEOGRAPH-534D (卍)

[13:55] <perplexa> :p

[13:55] <perplexa> hmkay

[13:56] <perplexa> ლ(ಠ益ಠლ)

[13:56] <arnsholt> Mmmm. Telugu?

[14:06] *** Mowah_ left
[14:06] *** Mowah_ joined
[14:40] *** daniel-s left
[14:41] *** kaare_ joined
[14:42] *** wamba left
[14:42] *** REPLeffect left
[14:42] *** kaare__ left
[14:50] *** koban left
[14:56] *** REPLeffect joined
[14:59] *** thou joined
[15:02] *** lichtkind joined
[15:06] <TBA2> afternoon #perl6

[15:07] <moritz> \o

[15:08] *** cosimo joined
[15:09] <colomon> \o

[15:09] *** jaldhar left
[15:10] *** jaldhar joined
[15:10] <lichtkind> :)

[15:19] *** leprevost left
[15:20] <lichtkind> what do you think about the qp/../ ~~ :d    syntax?

[15:20] * moritz thinks its dangerous

[15:20] <lichtkind> moritz: why?

[15:21] <moritz> lichtkind: because history tells us that it's very hard to make a good, usable and cross-platform path handling library

[15:21] <moritz> lichtkind: and since it's unlikely we get it right, it shouldn't be in core

[15:21] <lichtkind> but qp is cor perl 6 as far as i know

[15:22] <moritz> right, that's what makes it dangerous

[15:22] <lichtkind> my question was more about to replace the .IO syntax

[15:22] <moritz> it forces us to deal with paths in core

[15:22] <lichtkind> i understand

[15:23] <lichtkind> moritz: but unless File::Spec ha broken things in it im not aware we have something to orient on

[15:23] <lichtkind> s/ha/has/

[15:24] * moritz is pretty sure that a bit of googling will show up many problems with File::Spec

[15:24] <moritz> I don't remember the exact discussions, but I do think there were good reason for not just copying its API

[15:25] <lichtkind> theres always something to improve but i mean there are also some problems solved in it so we dont have to build anything from scratch

[15:28] * lichtkind reading https://rt.cpan.org/Public/Dist/Display.html?Name=PathTools

[15:29] <colomon> moritz: I guess I don't see how saying "filename".IO ~~ :d is somehow less dangerous than qp/filename/ ~~ :d

[15:29] *** daniel-s joined
[15:30] <moritz> colomon: I never made that comparison

[15:31] <moritz> colomon: "filename".IO is likely also wrong (considering that most OS don't have APIs for specifiying filenames as character strings)

[15:33] *** leprevost joined
[15:35] *** mattp_ joined
[15:35] <moritz> the spec on it contains pearls such as:

[15:35] <moritz> The "Path" role covers both the path to the file, and the file metadata.  They

[15:35] <moritz> are usually created with the qp{/path/to/file} syntax.

[15:35] <moritz> ...

[15:35] <moritz> Note that @.Elements

[15:35] <moritz> can not be accessed unless $.Encoding is defined.

[15:35] <moritz> so I need something like

[15:35] <moritz> my $file = qp{/etc/passwd};

[15:36] <moritz> $file.Encoding = 'UTF-8';

[15:36] <moritz> say $file.Elements[0]

[15:36] <moritz> except that $.Encoding isn't declared as 'is rw', so it won't work

[15:36] <jnthn> evening, #perl6

[15:36] <moritz> \o jnthn 

[15:38] <moritz> S32/IO feels like it's doing some decent engineering, but doesn't actually solve the problems it should solve

[15:38] * moritz should stop ranting

[15:39] <jnthn> pmichaud: (inlining bare blocks) Can you point me at the code where it's an issue?

[15:40] <TBA2> lichtkind: are the p6 tablets available as pdf anywhere? wanna stick a copy on my phone for mobile reading :)

[15:41] * TBA2 thinks ranting is a good way to highlight issues (or so I tell my boss!)

[15:41] <TBA2> \o jnthn

[15:42] * moritz feels encouraged and continues... why does Path has a $.Target attribute, if it only makes sense for links?

[15:42] <TBA2> on the issue of filepaths, isn't that very OS specific, i.e. filepath handling on Amiga OS is entirely different to Linux, Windows, etc, so unless the intention is to cover *every* possibility, surely none would be better?

[15:42] <moritz> and why are all the attributes in Path capitlized, but not in the rest of the spec?

[15:42] <TBA2> was someone drunk while writing IO specs? lol

[15:43] *** dodododo left
[15:43] <lichtkind> TBA2: not yet

[15:43] <TBA2> personally I'd rather implement my own filepath handling for each OS I want to code for, rather than have Perl do it and end up spending time fighting it

[15:43] <moritz> TBA2: that is exactly the problem. If we can't cover everything, it shouldn't be core

[15:44] <TimToady> that is very non-P5-ish thinking

[15:44] <PerlJam> there's a reason the specs are editable  :)

[15:44] <TimToady> and non-URL thinking

[15:44] <colomon> So, if you can only support 99.9% of the systems out there, you shouldn't support it at all?  That's.... <deleted for politeness>

[15:44] <moritz> TBA2: otherwise we're implicitly saying things like "Perl 6 is a language for windows and UNIX only"

[15:45] <TimToady> there needs to be a universal layer that can be adequately mapped to an OS-specific layer, that's all

[15:46] <TimToady> the correct answer is not "all OR one"

[15:46] <colomon> +1

[15:46] <moritz> another thing I don't like with the current approach is that it conflates path/filename with file metadata

[15:46] <moritz> so we might end up doing an IO operation for every path construction

[15:47] <TimToady> I do agree that the OS-specific layer should be pluggable wrt the universal layer

[15:47] <moritz> or we try to be clever and lazily defer it, but then it might become very hard to understand when and if an IO operation is involved

[15:48] <TBA2> TimToady: sounds good to me if it can work in practice

[15:48] <TimToady> I believe the overriding concept here is one of identity, so as best to avoid race conditions and mutable/immutable failures

[15:48] <moritz> and the "when" can be very important in IO land (see also: race conditions)

[15:49] <TimToady> unfortunately files come in both value and object semantics

[15:49] *** daniel-s left
[15:50] <TimToady> so it will be very important, if this is an area that may evolve over time, to specify which version of io semantics we're thinking of

[15:50] <TimToady> perhaps this can be tied to p6 versions

[15:50] <TimToady> or maybe a given p6 version has a default io version

[15:50] <TimToady> but overridable

[15:51] <TimToady> I just don't want to evolve the Java way with 20 layers of indirection

[15:51] * TimToady wonders how many layers of indirection P5 as collected there

[15:51] <TimToady> *has

[15:52] <TimToady> wrt identity, the trend in Unixoid systems is to treat the file descriptor as the actual identity object, and add things like fchown

[15:54] <TimToady> the logical extreme of that, though, is that you have to open a file to do anything with it, like stat it

[15:55] *** icwiener joined
[15:56] <TimToady> but much of the P6 design is to establish stable identities with stable semantics, and then try to attach everything to the correct "peg"

[15:57] <TimToady> sounds kinda like a sociological theroy

[15:57] <TimToady> *theory even

[15:58] *** Mowah left
[15:59] <slavik1> TimToady: is there anything special being done for object serialization?

[15:59] <TimToady> we can muddy the user view with tricks like Cool, but the system should keep an accurate view of identity

[16:00] <TimToady> slavik1: you mean like making sure AOP is supported in the design? :)

[16:00] <slavik1> not sure what aop stands for

[16:00] <slavik1> I was looking for something like java does but better

[16:00] <TimToady> Aspect Oriented Design

[16:01] <slavik1> I guess, I am not familiar with that concept :(

[16:01] <TimToady> think of it as compile-time monkey patching :)

[16:01] <jnthn> pmichaud: for loops seem to leak memory

[16:02] <jnthn> pmichaud: Do my $x = 0; for 1..50000 -> $n { $x = $x + $n }; say $x and watch.

[16:02] <TimToady> the nice think about serialization is there are so many to choose from

[16:03] <slavik1> TimToady: yeah, the java kind sucks though since it doesn't appear to send the actual object through so if your object versions differ (fields don't match), it will fail

[16:05] <TimToady> I am enough of an expert on the subject to know I am not an expert on the subject.

[16:05] *** mj41 left
[16:05] <slavik1> TimToady: this is mainly in context of rmi

[16:06] <sbp> avoiding the http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect

[16:06] <TimToady> me hasn't a clue what rmi means

[16:06] <slavik1> and jmx (java management extensions), rmi (remote method invocation)

[16:06] * TimToady only collects other people's horror stories about Java, and prefers not to collect any of his own.

[16:07] <slavik1> TimToady: this is yet another one

[16:07] *** tokuhirom joined
[16:07] <slavik1> I'm not going to bother you with it since I think it will give you nightmares and stiffle perl6 progress :P

[16:08] <slavik1> TimToady: I will ask you this: Have you ever heard of MUMPS? (the language)

[16:08] <TimToady> yes

[16:09] <slavik1> Java is worse than that

[16:09] <TimToady> then why didn't MUMPS take over the world? :)

[16:09] <TimToady> I submit that Java is better at something

[16:10] <slavik1> there wasn't a vm for mumps for all platforms

[16:10] <slavik1> which is the reason .net is having a hard time, because microsoft has its head in its ass

[16:11] <slavik1> which leads me to believe that either microsoft is lazy, or they don't know how to make something that can take over the world

[16:12] <benabik> slavik1: Their view of "the world" is limited to machines running Windows.

[16:12] <slavik1> which makes me want to find the guys at ibm that designed the first AT and ask them if they would still pick intel and microsoft as their vendors

[16:12] <slavik1> benabik: yeah, which is why they can't take it over

[16:13] *** Chillance left
[16:13] <TimToady> if IBM had managed to control that market, they'd've been broken up like Ma Bell

[16:14] <TimToady> and then we'd be stuck with baby IBMs

[16:14] <slavik1> TimToady: reminds be of Stephen Colbert's AT&T map of 80s vs. today

[16:14] <gfldex> Microsoft is a closed society. If you are not on the campus you cant talk to them. If you don't talk, how could you be important.

[16:14] <TimToady> I talk to my son-in-law.  :)

[16:15] <slavik1> X.X

[16:15] <gfldex> you are not a closed society then

[16:15] *** Mowah_ left
[16:15] <TimToady> my son-in-law works in Redmond

[16:16] <slavik1> TimToady: -1 respect point

[16:16] <TimToady> now you're just being religious :P

[16:16] <PerlJam> TimToady: most of humanity seems to be so infected

[16:16] * moritz thinks that some of the Microsoft departments do really cool tech

[16:17] <slavik1> TimToady: says someone who put 'bless' as a keyword in a language to make hashes into fake objects. :P

[16:17] <PerlJam> "fake objects"?

[16:17] <slavik1> fine, blessed hashes

[16:18] <pyrimidine> I think MS set up a free VM farm for testing perl modules at one point (I think Alias helped), so they can't be completely evil

[16:18] <PerlJam> They're not so much "fake" as they expose more of the underlying machinery to the user

[16:18] <slavik1> PerlJam: that's why they are awesome

[16:19] <pyrimidine> I'm pretty sure other langs use similar mechanisms, they just aren't as exposed

[16:21] <TimToady> if you read the documents, you'll find that "bless" is actually the corporate metaphor of bless, not the religious...as in the boss giving his approval to a proposed project of the underlings

[16:22] <slavik1> that's even worse!!!

[16:22] <slavik1> :P

[16:23] <TimToady> so it really means, "Yes, I recognize that this thing officially fits into my (class) organization."

[16:23] *** JimmyZ left
[16:23] *** JimmyZ joined
[16:29] *** Moukeddar joined
[16:29] <Moukeddar> Hello :)

[16:29] <JimmyZ> hi

[16:29] <Moukeddar> how are you?

[16:32] *** wamba joined
[16:33] *** cdarroch joined
[16:33] *** cdarroch left
[16:33] *** cdarroch joined
[16:38] *** kst` is now known as kst

[16:42] *** Mowah joined
[16:44] <pmichaud> jnthn: the example you gave is almost exactly the one I've been playing with

[16:44] *** cotto joined
[16:44] <pmichaud> my $x = 0; for 1..50000 -> $n { $x = $x + $n };

[16:45] <pmichaud> I'm not sure about "leaks memory"... or at least that it leaks memory in ways that it's not supposed to leak just yet :)

[16:45] *** molaf joined
[16:46] <jnthn> pmichaud: It leaked a load but I've worked out why and fixed it.

[16:47] <jnthn> pmichaud: Along the way cached the sorted multi-dispatch list.

[16:47] <jnthn> pmichaud: Shaved 30% off loops like the above, it seems.

[16:47] <pmichaud> good

[16:47] <pmichaud> I have a few more improvements to make

[16:47] <pmichaud> the result of the for is 'leaky' too, because I don't have .sink yet

[16:47] <jnthn> brb

[16:48] <pmichaud> how costly are "isa" checks these days?

[16:48] <dalek> rakudo/nom: f6439e3 | jnthn++ | src/ (3 files):

[16:48] <dalek> rakudo/nom: Save sorted mutli-dispatch candidate list. Shaves 30% off a for 1..10000 -> $n { ... } style loop, and probably a decent bit off other bits.

[16:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f6439e3b7a

[16:50] <pmichaud> aye, 30% here also

[16:50] <pmichaud> jnthn++

[16:52] <jnthn> pmichaud: They're cheap if you hit the cache, which you should be.

[16:52] <jnthn> pmichaud: If you aren't, then it shows up in profiles. :)

[16:52] <jnthn> pmichaud: They're pointer follows/comparisions.

[16:52] <pmichaud> okay, good to know

[16:52] <pmichaud> my initial test with inlining blocks didn't show a massive improvement

[16:52] <pmichaud> that's both good and bad

[16:53] <pmichaud> it did eliminate the extra block invocations, but didn't make a significant difference in performance

[16:55] <jnthn> May make more of one with 30% gone.

[16:56] <pmichaud> well, the for 1..10000 -> $n { ... } loop was taking ~9 seconds on my machine when I startged

[16:56] *** birdwindupbird left
[16:56] <pmichaud> after changing listiter to inline its blocks and loops (where I expected most of the cost to be), it was still ~9 seconds

[16:56] <pmichaud> after your fix, it's around 6sec

[16:56] <pmichaud> so I suspect with inlining it'll be around 6sec also

[16:57] <pmichaud> current target is to make sure it's as fast as an equivalent while<> loop which is currently around 2sec

[16:57] <jnthn> I'd bet the while loop went down with my multi improvements too.

[16:57] <pmichaud> oh, and I figured out earlier a way to create 'for' in terms of 'while' -- i.e., to be able to inline the body of a for loop 

[16:58] <pmichaud> (haven't implemented it yet, but it'll be available when we get to that point)

[16:59] <pmichaud> btw, I have the Null PMC access bug again... ran across it this morning

[16:59] <jnthn> pmichaud: Boolification is costing us quite a bit.

[16:59] <jnthn> according to the profile

[16:59] <pmichaud> I'm not too surprised about that.

[17:00] <jnthn> I can probably improve on that a bit, though.

[17:01] <pmichaud> for the null pmc bug:   apply the patch in http://gist.github.com/1036004   (making a reference to a non-existent type), recompile, and then execute   my @a = 1..10;  my $b = @a.iterator

[17:01] <pmichaud> result is:

[17:01] <pmichaud> > my @a = 1..10;  my $b = @a.iterator

[17:01] <pmichaud> Null PMC access in get_pmc_keyed()

[17:03] <pmichaud> it should probably catch the non-existent MyListIter at core compile time, but seems to skip that

[17:04] *** dukeleto left
[17:04] *** avar left
[17:04] <jnthn> nom: MyListIter

[17:04] <p6eval> nom: OUTPUT«Could not find symbol '&MyListIter'␤current instr.: 'fail' pc 170302 (src/gen/CORE.setting.pir:42583) (:115)␤»

[17:04] *** dukeleto joined
[17:04] *** avar joined
[17:04] *** avar left
[17:04] *** avar joined
[17:05] <jnthn> nom: class Foo { method m { MyListIter } }; Foo.m

[17:05] <p6eval> nom: OUTPUT«Could not find symbol '&MyListIter'␤current instr.: 'fail' pc 170302 (src/gen/CORE.setting.pir:42583) (:115)␤»

[17:05] <pmichaud> I could only get it to appear when compiling the core setting

[17:05] <jnthn> Oddness.

[17:05] <pmichaud> (so far)

[17:05] <jnthn> OK, will put it on my list.

[17:06] <pmichaud> the other tests I've tried out side of the core give the errors you've listed above :)

[17:06] <JimmyZ> night

[17:06] <jnthn> night, JimmyZ 

[17:07] <jnthn> pmichaud: Yeah. It doesn't make a great deal of sense to me why core would get special treatment in that regard.

[17:07] <jnthn> oh

[17:07] <jnthn> nom: my class Foo { method m { MyListIter } }; Foo.m

[17:07] <p6eval> nom: OUTPUT«Could not find symbol '&MyListIter'␤current instr.: 'fail' pc 170302 (src/gen/CORE.setting.pir:42583) (:115)␤»

[17:07] <jnthn> no, not that either. 

[17:07] <pmichaud> tried that also :)

[17:08] <pmichaud> I tend to prototype changes and significant refactors in files outside of the core, so that I'm not constantly recompiling the core.  So things like "List" become "MyList" while I'm doing that.  Then when I have things working, I copy the new code into the core and recompile... and if I forget to switch a MyList back to a List... I get the null pmc error

[17:09] <pmichaud> although it's happened enough times now that I know what to look for :)

[17:09] <pmichaud> (the one this morning occurred when I mistyped ListIter as ListITer )

[17:09] *** ajoe47 joined
[17:09] *** JimmyZ left
[17:10] <jnthn> my $block := pir::perl6_decontainerize__PP($!block); # in MapIter - do you do this just for a little performance win, or is it needed?

[17:11] <pmichaud> appears to be needed.  take it out and you'll see the error.

[17:11] <jnthn> OK, am a tad curious why. 

[17:11] <pmichaud> I was too, at the time.

[17:11] <jnthn> I can normally spot where those are needed.

[17:12] <pmichaud> also, I didn't know if the lexical lookup would be better than the attribute lookup

[17:12] <pmichaud> (inside the loop)

[17:12] <pmichaud> I know that .munch is also a little on the slow-side

[17:12] <pmichaud> btw, I can eliminate the Q:PIR there when we have   &sub(|@foo)  working :)

[17:13] <jnthn> OK

[17:13] <jnthn> hm

[17:14] <jnthn> On .munch - it makes an RPA every time

[17:14] <jnthn> So in a 1..10000 loop we make 10000 RPAs.

[17:15] *** Sarten-X joined
[17:17] * TimToady wonders why it wouldn't just be "also is inline;"

[17:17] <pmichaud> ...because I didn't see it anywhere?  ;-)

[17:17] <jnthn> TimToady: That'd make sense :)

[17:19] *** alester joined
[17:20] <tadzik> hello

[17:22] <jnthn> o/ tadzik 

[17:24] <tadzik> dispatcher cache, nice. I wonder how will it like my stupidloop test :)

[17:25] <jnthn> tadzik: It's not a cache per se, it just avoids re-sorting every time

[17:26] <tadzik> 553         /* XXX TODO: Cache! */

[17:26] <tadzik> ah, I see

[17:26] <pmichaud> jnthn: we're going to have the RPA no matter what, whether it's explicit or implicit inside of a Parcel

[17:26] <pmichaud> oh, you mean 10000 extra RPAs. yeah.

[17:27] <pmichaud> oh, no, we still end up with the RPA

[17:27] <pmichaud> I've been thinking of switching that code to do a splice instead of shift/push though

[17:28] <pmichaud> I'm not convinced it'll be any faster to do that, however.

[17:29] <pmichaud> we can avoid the extra rpas if we have partial binding in place, though :)

[17:30] <pmichaud> and then I might not need $block(|@foo) -- i'd use the partial binder instead :)

[17:32] *** Moukeddar left
[17:34] <tadzik> 30% speedup confirmed :)

[17:35] <pmichaud> we're still slower than master, though.  I'm sure that'll get fixed too .

[17:38] <tadzik> are we? huh

[17:40] *** daxim left
[17:40] <jnthn> tadzik: On iteration.

[17:40] <tadzik> 6.75 seconds on nom, 93,02s on master. Either my stupid test is too stupid, or I like your definition of "slower" :)

[17:40] <tadzik> oh, mybe

[17:41] *** cooper joined
[17:42] *** cognominal joined
[17:42] <pmichaud> oh, I know an optimization we need ... (/me patches)

[17:42] *** smash left
[17:43] *** kaare_ left
[17:43] <tadzik> 'for (1..10000) {}' is 3.82 on master, 16.16 on nom

[17:43] <pmichaud> tadzik: right

[17:43] <pmichaud> range generation is slower right now, for one

[17:43] <pmichaud> the range generator in master is really fast

[17:43] *** ajoe47 left
[17:45] <pmichaud> on my machine, 1..10000 takes 7sec on master, 23sec on nom

[17:45] <pmichaud> sorry, 1..100000

[17:45] <pmichaud> but I can speed that up in nom :)

[17:51] <pmichaud> jnthn: I've been wanting a pir:: syntax for pir:: numeric/string constants

[17:51] <pmichaud> so that we're not unpacking a constant just to pass to a pir opcode.  worth the trouble, or do you think the current unboxing is fast enough?

[17:52] <pmichaud> e.g:    pir::int(0)   and pir::num(3.5)

[17:57] *** cognominal_ joined
[17:58] <jnthn> masak says hi

[17:58] <jnthn> he has no laptop :(

[17:58] <jnthn> pmichaud: I've been wanting that context-sensitive PAST node :)

[17:58] <jnthn> pmichaud: That's the way that the above should be fixed :)

[17:59] <jnthn> pmichaud: e.g. it'd know what to do for an I register and what to do for a P register

[17:59] <jnthn> pmichaud: Can then do natively typed attrs far better also :)

[17:59] <jnthn> Time for food - bbl

[18:00] *** cognominal left
[18:00] *** jaldhar left
[18:05] <pmichaud> jnthn: okay, I'll prototype one up.

[18:05] <pmichaud> I agree that's easier/better/more general.

[18:09] *** natureboy joined
[18:12] *** cooper left
[18:13] *** DarthGandalf left
[18:16] *** cognominal_ left
[18:16] <tadzik> ooh, idea. The Perl6::Cricic could probably be written as a Perl6::Grammar with custom (criticising) Perl6::Actions

[18:17] *** fhelmberger left
[18:17] * flussence ponders the level of insanity needed to write a HTML5::Grammar

[18:17] *** DarthGandalf joined
[18:17] <tadzik> would that be so insane?

[18:17] <thou> tadzik: almost like what STD does now

[18:18] <flussence> tadzik: the HTML5 spec's "parsing" section is about a mile long :)

[18:18] <tadzik> Besides <li> not having to be closed with </li> is there that much insanity in html5?

[18:18] <tadzik> oh :)

[18:18] <tadzik> thou: STD has actions now?

[18:18] <TimToady> viv is all actions

[18:18] <tadzik> istr it just has lots of "|| <.panic "bla bla">" in the regexes

[18:18] <tadzik> oh

[18:19] <flussence> and it specs about 20 years of browser error-tolerance cruft

[18:19] <thou> i just meant that it will warn about unused vars, etc.

[18:19] <tadzik> unused vars is more like a compiler job than a critic job, methinks

[18:20] <thou> yeah

[18:20] *** cognominal joined
[18:27] <pmichaud> jnthn: how about this as an api for a context-sensitive node handler?   http://gist.github.com/1036222

[18:27] <pmichaud> we can change the name

[18:27] <pmichaud> maybe PAST::Contextual

[18:27] * pmichaud fights to avoid "PAST::Contextual::Return"

[18:35] <dalek> rakudo/nom: 02d5f56 | pmichaud++ | NOMMAP.markdown:

[18:35] <dalek> rakudo/nom: NOMMAP update.

[18:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/02d5f56932

[18:38] <tadzik> pmichaud: about inlining blocks that use OUTER::, couldn't we just drop the OUTER:: part from them then?

[18:43] <TimToady> nom: constant @a = 'A'..'Z';

[18:43] <p6eval> nom: OUTPUT«Constant type declarator not yet implemented at line 1, near "= 'A'..'Z'"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23569 (src/stage2/gen/NQPHLL.pir:6311)␤»

[18:47] *** mj41 joined
[18:52] *** DarthGandalf left
[18:56] *** icebattle joined
[18:56] <pmichaud> I think I may optimize the numeric range case

[18:56] <pmichaud> (into pir-ish stuff)

[18:58] <lichtkind> thou: great work

[18:58] <lichtkind> for a beginning :)

[18:58] <thou> lichtkind: a small start :-)

[18:58] *** DarthGandalf joined
[18:59] <lichtkind> thou: there were some correctifying changes in between 

[19:02] <jdhore1> pmichaud, did you notice the problem in nommap?

[19:03] <pmichaud> jdhore1: which one?

[19:03] <pmichaud> (no.)

[19:03] <jdhore1> pmichaud, Last Updated 19 June 2001

[19:03] <pmichaud> oh

[19:03] <jdhore1> pmichaud, Last updated: 10 years ago

[19:03] <pmichaud> jdhore1: yes, this way we can say we've only been working on Perl 6 for a few months :-P

[19:03] *** dukeleto left
[19:03] <pmichaud> I'll fix it in my next update :)

[19:04] <jdhore1> hehe

[19:04] *** dukeleto joined
[19:04] <pmichaud> (thanks for noticing -- jdhore1++ )

[19:05] *** frettled left
[19:05] <jdhore1> You should pull a Top Gear moment and change the year to 2020

[19:05] <jdhore1> rakudo/nom: The only software project coming to you from 9 years into the future

[19:07] <TBA2> lol lets hope thats not actually true ;)

[19:07] <TBA2> rakudo/nom: 20 years in the making...

[19:07] <TBA2> it'll be older than half the developers using it :P

[19:11] *** mj41 left
[19:12] <jdhore1> :(

[19:17] *** envi_laptop left
[19:25] *** birdwindupbird joined
[19:29] <dalek> rakudo/nom: bdfbe6b | pmichaud++ | src/core/Range.pm:

[19:29] <dalek> rakudo/nom: Use Q:PIR to hotpath the generation of int/num ranges.

[19:29] <dalek> rakudo/nom: Time needed to generate 1..100000 -- was: 8.7sec   now: 0.02sec.

[19:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bdfbe6b9f8

[19:29] <dalek> rakudo/nom: e1a181c | pmichaud++ | src/core/ (2 files):

[19:29] <dalek> rakudo/nom: Add Int/Num specific versions of prefix:<++>, prefix:<-->, etc.

[19:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e1a181c85d

[19:30] <tadzik> whoa whoa

[19:32] <tadzik> I need to see this :)

[19:32] *** wamba left
[19:33] <thou> um, that sounds promising :-)

[19:34] * TBA2 updates his nom install

[19:35] <tadzik> um. 'for (1..10000) {}' was 10.32s, is 8,76s

[19:36] <tadzik> optimizations don't work for me :)

[19:36] * flussence throws his patience out the window and does a git checkout

[19:36] *** ggoebel joined
[19:37] *** miso2217 left
[19:39] <pmichaud> tadzik: try:   (1..10000).reify(*)

[19:39] <pmichaud> I didn't say for loops were faster, I just said that range generation was faster :)

[19:39] <TimToady> depending on how you count, there will only ever be 0 or 1 high-level computer languages older than me...

[19:40] <tadzik> I see :)

[19:40] <sorear> good * #perl6

[19:40] <pmichaud> I think you'll find that under the old system, (1..10000) was taking about 1.6s to generate :)

[19:40] <pmichaud> and now takes much less

[19:40] *** miso2217 joined
[19:40] <tadzik> awesome

[19:40] <pmichaud> er,  (1..10000).reify(*)

[19:40] *** natureboy left
[19:40] <tadzik> what's .reify?

[19:41] <thou> good night, sorear

[19:41] <pmichaud> that takes a list or iterator and turns it into its elements

[19:41] <pmichaud> i.e., it gets rid of the lazy parts

[19:41] *** cooper joined
[19:42] <PerlJam> TimToady: I'm sure the folks that worked on the ENIAC considered ENIAC short code a high-level computer language  :-)

[19:42] <TimToady> of course, for 1..10000 should never generate a list in the first place...

[19:43] <pmichaud> it shouldn't?

[19:43] <pmichaud> what does .map.... map then?

[19:44] <TimToady> I just mean that's something obvious to optimize into a simpler 1 variable loop

[19:44] <pmichaud> ah, optimization.  yes.

[19:44] <TimToady> loop ($_ = 1; $_ <= 10000; $_++) {...}

[19:44] <TimToady> or some such

[19:45] <TimToady> or into some special internal form like p5 does

[19:47] <TimToady> well, not suggesting we do that opt right now

[19:47] <pmichaud> either way, I'm happy with a significant speed improvement on numeric ranges :-)

[19:48] <TimToady> though it'd be nice to have *some* benchmarks blazing fast for the cheerleaders to cheer about

[19:48] <pmichaud> when the p6 code gets within 50x of the Q:PIR, we can see about removing that optimization :-)

[19:48] <pmichaud> oh, I can still make the for loop faster

[19:48] <pmichaud> that's what all of this rewriting/refactoring is about :)

[19:48] <pmichaud> right now we're just trying to figure out where the (new) slow parts are

[19:49] <TimToady> well, chances are it's something that redeciding things that only need to be decided once :)

[19:50] <TimToady> esp where the side effect of deciding is to create something...

[19:51] *** sftp left
[19:53] *** sftp joined
[20:00] *** donri left
[20:02] <sorear> 2µs per range item?  that's pretty good...

[20:02] *** MayDaniel joined
[20:02] <sorear> way better than what niecza currently has :D

[20:03] <pmichaud> yes, I needed to check several times that the range elements were actually being created :)

[20:10] *** molaf left
[20:14] *** mj41 joined
[20:15] <flussence> hm, nom doesn't like my normal build script... I have to make install *before* make spectest

[20:15] <sorear> does nom pass any spectests?

[20:15] <flussence> that's what I'm curious about :)

[20:15] <pmichaud> not yet

[20:16] <pmichaud> we're not to the point of being able to run Test.pm yet.

[20:16] <sorear> trying to implement MY:: et al in niecza has balooned into a redesign of the low-level package system

[20:16] <pmichaud> that happens a lot in p6, I've found :)

[20:17] *** wamba joined
[20:17] <flussence> bah, generating the core thingy still takes forever and a day in nom :)

[20:18] <PerlJam> flussence: are you sure you're compiling nom? Or are you speaking in relative terms?

[20:20] *** birdwindupbird left
[20:24] *** MayDaniel left
[20:28] <jnthn> pmichaud: WOW! Nice optimization

[20:28] <jnthn> pmichaud: One little request.

[20:29] <jnthn> Please can you leave the original Perl 6 code above the Q:PIR in these cases, with a "ETOOSLOW" note?

[20:29] <jnthn> pmichaud: Such things will be really useful to have to hand when it comes to working on the optimizer.

[20:32] <flussence> PerlJam: I'm on a netbook :)

[20:35] <flussence> hm, nom perl6 -e 'for (1..10000) {}' takes 34 seconds on this and master takes 11 seconds on my server (not quite the same, but it's still an Atom CPU...)

[20:35] <jnthn> flussence: With the latest patch from pmichaud++?

[20:35] <tadzik> yeah, that's related to Range iteration, not Range creation

[20:36] <sorear> flussence: do not use "for"

[20:36] <tadzik> see my doubts :)

[20:36] <sorear> flussence: try perl6 -e '(1..10000).reify(*)'

[20:36] <flussence> I'm just surprised it goes way off in the other direction compared to those numbers tadzik got

[20:36] <tadzik> no, it doesn't

[20:36] <flussence> oh, 

[20:36] <tadzik> oh, it does

[20:37] <tadzik> wait, I dunno anymore

[20:37] <tadzik> Whatever! I don't care!

[20:37] * tadzik pretends he's learning for the exam again

[20:37] <flussence> but still 11 -> 34 is a bit bigger than 8 -> 10 *shrug*

[20:37] <flussence> ooh, .reify is fast

[20:37] <tadzik> my comparison was nom-nom, yours is nom-master

[20:38] <flussence> oh, right

[20:41] <jnthn> pmichaud: API for contextual looks good. Only cooler thing could be if it took a slurpy hash

[20:41] <jnthn> pmichaud: So we could do :Ii(...), :Ss(...)

[20:42] <jnthn> pmichaud: I think I'd prefer that, if it can be made to work.

[20:42] <jnthn> nqp: foo(a => 1)

[20:42] <p6eval> nqp: OUTPUT«Could not find sub foo␤current instr.: '_block1000' pc 31 ((file unknown):32)␤»

[20:42] <jnthn> Ah, even nicer with that notation.

[20:42] <jnthn> Ii => ..., Ss => ...

[20:42] <dalek> rakudo/nom: 4cbf8cb | jnthn++ | NOMMAP.markdown:

[20:42] <dalek> rakudo/nom: Comment on a nommap item. Also, it's not 2001. :-)

[20:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4cbf8cb2e1

[20:45] <pmichaud> jnthn: I'm not sure it can be made to work well with pair notation.

[20:45] <pmichaud> that was my first attempt, yes.

[20:45] <pmichaud> but some of the signature characters aren't alphanumeric

[20:46] *** Sarten-X left
[20:46] <lichtkind> thou: ping

[20:46] <thou> pong

[20:47] <lichtkind> thou: seen my question?

[20:47] <pmichaud> I guess we could switch them to alphameric equivs if needed

[20:48] <pmichaud> jnthn: the original P6 code is in the else block

[20:48] <pmichaud> (for the range optimization)

[20:48] <jnthn> pmichaud: ah, yes :)

[20:48] <pmichaud> I can put a comment that it's the unoptimized version

[20:48] <pmichaud> I guess I can also reverse the test

[20:49] <jnthn> pmichaud: Sure, I'll probably go trawling for Q:PIR at some point when working on the optimizer.

[20:49] <pmichaud> okay

[20:49] <pmichaud> I'm doubtful that particular one will go away anytime soon

[20:49] <pmichaud> the difference between 7.5sec and 0.02sec is just too great

[20:50] <pmichaud> (7.5sec is what I get after optimizing ++/--)

[20:50] <pmichaud> my next set of optimizations are going to eliminate some O(n**2) behavior in lists :)

[20:50] <pmichaud> any opinions +/- on using opcodes for performance optimizations?  ;-)

[20:51] <jnthn> I don't have a problem with custom ops.

[20:51] <pmichaud> okay, I'm about to add another

[20:51] *** aindilis left
[20:52] *** aindilis joined
[20:53] <pmichaud> this one is converting an operation currently taking 5.3sec into one that takes 0.003sec :-)

[20:54] <pmichaud> (and it's very commonly used)

[20:54] * jnthn is curious which one :)

[20:55] <pmichaud> it's used in .iterator and .munch -- the repeated shifting of elements from an RPA

[20:55] <pmichaud> that's an O(n**2) operation in Parrot.

[20:55] <pmichaud> I'm making it linear.  

[20:55] <jnthn> \o/

[20:55] <pmichaud> and then I'll be able to use it to avoid a ton of other O(n) operations that we currently do :)

[20:56] <pmichaud> i.e, making O(20n) into about O(2n)

[20:56] *** Sarten-X joined
[21:01] *** wamba left
[21:04] <tadzik> wouldn't it be good to optimize it in Parrot instead of reimplementing it?

[21:05] <tadzik> unless we don't want that directly

[21:06] <pmichaud> it's not a reimplementation, exactly, it's an additional operation

[21:06] <tadzik> I see

[21:07] <pmichaud> it just turns out it has higher-level knowledge that enables it to be smarter about it than using the parrot primitives repeatedly

[21:07] <pmichaud> I'm working on a slightly different approach that might not need the opcode at all, though.  we'll see.

[21:15] <lichtkind> what is .munch?

[21:18] <tadzik> it's like .take methings

[21:19] <tadzik> rakudo: (1, 2, 3, 4).munch(2)

[21:19] <p6eval> rakudo 248244: OUTPUT«Method 'munch' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/fkiOR2YSdM␤»

[21:19] <tadzik> pff

[21:19] <tadzik> rakudo: (1..4).munch(2)

[21:19] <p6eval> rakudo 248244: OUTPUT«Method 'munch' not found for invocant of class 'Range'␤  in main program body at line 22:/tmp/vTcO2Bfdwd␤»

[21:19] <tadzik> aroo

[21:24] *** spq1 left
[21:29] *** dukeleto left
[21:29] *** dukeleto joined
[21:29] *** simcop2387 left
[21:31] *** simcop2387 joined
[21:34] <pmichaud> rakudo uses a somewhat different API than nom

[21:34] *** sftp left
[21:35] *** sftp joined
[21:36] <lichtkind> tadzik: thanks nevertheless :)

[21:37] <lichtkind> rakudo: (1..4).take(2)

[21:37] <p6eval> rakudo 248244: OUTPUT«Method 'take' not found for invocant of class 'Range'␤  in main program body at line 22:/tmp/SDGCRT1o2u␤»

[21:37] <lichtkind> rakudo: (1,2,3,4).take(2)

[21:37] <p6eval> rakudo 248244: OUTPUT«Method 'take' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/a9TftOVbh7␤»

[21:37] <lichtkind> :)

[21:37] <lichtkind> std: (1,2,3,4).take(2)

[21:37] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 121m␤»

[21:37] <lichtkind> std: (1,2,3,4).munch(2)

[21:37] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 121m␤»

[21:38] *** Mowah left
[21:38] *** impious joined
[21:57] *** ilogger2 joined
[21:57] *** ChanServ sets mode: +v ilogger2

[21:57] *** dukeleto joined
[21:57] *** Tanktalus joined
[21:57] *** PacoLinux joined
[21:59] *** charsbar__ joined
[22:00] *** whiteknight joined
[22:07] *** DarthGandalf joined
[22:07] *** jrockway joined
[22:10] *** chitragupt joined
[22:13] *** frettled joined
[22:31] <pmichaud> jnthn: ping

[22:32] <jnthn> pmichaud: pong

[22:32] <pmichaud> I have an patch you might want to play with a bit for performance (more)

[22:32] <pmichaud> http://gist.github.com/1036768

[22:33] <pmichaud> this patch changes the ListIter so that instead of repeatedly shifting from $!rest, it maintains an $rest_pos pointer that keeps track of the element of $!rest that is currently being processed, and then does one big shift at the end (via splice)

[22:34] <jnthn> pmichaud: Iterable.ACCEPTS($x)

[22:34] <jnthn> pir::type_check__IPP($x, Iterable)

[22:34] <pmichaud> I can change that, but that's not the interesting part

[22:34] <jnthn> pmichaud: Similar for Parcel.ACCEPTS($x)

[22:34] <pmichaud> sure thing

[22:34] <jnthn> Whatever.ACCEPTS($n) too

[22:35] <jnthn> Well, they're in the while loop

[22:35] <pmichaud> with this patch in place, the benchmark at http://gist.github.com/1036772  runs about 10% slower than before

[22:35] <jnthn> So they save a method invocation per call frame.

[22:35] <pmichaud> in other words, repeatedly shifting the RPA is faster than maintaining an index pointer

[22:36] <jnthn>  while pir::islt__III($rest_pos, pir::elements($!rest)) 

[22:36] <jnthn> I think that falls into the coercion vs unbox trap.

[22:37] <pmichaud> coercions are *that* expensive?

[22:37] <pmichaud> I can fix and find out... just a sec

[22:37] <jnthn> Well, it goes through the Parrot v-table. While the lookup over the code that overrides it is fast, that bit of code just calls .Int

[22:38] <jnthn> And then unboxes that

[22:38] <pmichaud> oh, it's resulting in a method call?

[22:38] <jnthn> Yes

[22:38] <jnthn> That's why there's explicit unbox instructions. 

[22:38] <pmichaud> is there a way that vtable method could short-circuit if it knew it already had a int repr available?

[22:39] <jnthn> Well, the repr is P6opaque, just one that knows how to unbox as an int.

[22:39] <jnthn> We *could* maybe do something like that.

[22:39] <pmichaud> building, testing with explicit unboxes

[22:39] <jnthn> But I fear it's magic that'll come back to hurt us.

[22:39] <jnthn> My separation of unboxing vs coercion was very deliberate.

[22:40] <sorear> unboxing and coercion are different things but it completely makes sense to have a "coerce and unbox" vtable

[22:41] <pmichaud> it's going to make the code really ugly if we're sprinkling pir::repr_unbox_int__IP all over the place

[22:41] <pmichaud> yeah, seems to me it'd be okay for the   get_integer_native  vtable to be smart about unboxing things it can determine to be int reprs

[22:41] <jnthn> They're *not* int reprs...

[22:42] <jnthn> It doesn't work like that.

[22:42] <pmichaud> that's not what I meant.

[22:42] <pmichaud> I meant things that it can determine are ints

[22:42] <jnthn> Yes, I could make it "just work". No, I'm not sure it's a good idea in the long run.

[22:42] <pmichaud> okay, I'm not going to push it yet.

[22:43] <jnthn> sorear: Depends what we decide the v-tables should really be doing.

[22:43] <pmichaud> okay, explicitly unboxing the repr makes the difference go down from ~10% to 1.6%

[22:44] <jnthn> sorear: If we put this in, we deny langauges a chance to intercept int coercion on any type that can just expand itself to a native int.

[22:44] <pmichaud> s/repr/int/

[22:44] <jnthn> gah

[22:44] <jnthn> s/expand/unbox/

[22:44] <sorear> I recommend adding a function (NOT an op) to Rakudo's C code that implements coercion+unboxing for Rakudo's Int type

[22:44] <jnthn> sorear: ?

[22:44] <sorear> then connect the .Int method to a NCI (rather than Sub) PMC

[22:45] <pmichaud> jnthn: I think you're looking to have the vtable do more than what I'm suggesting

[22:45] <sorear> then make the vtable override logic know how to call NCIs without runops

[22:45] <sorear> (ideally, a very direct call if the signatures match up)

[22:47] <jnthn> sorear: That sounds nasty and maybe a premature opt right now.

[22:47] <pmichaud> I'm not saying the vtable should shortcut for just any type that can unbox to a native int, I'm saying that we have a flag or something for individual types that says it does so for those.

[22:47] <jnthn> Also, whose .Int method?

[22:47] <sorear> Int's .Int

[22:47] <jnthn> pmichaud: Ah, I see

[22:47] <pmichaud> i.e., it short-circuits for an Int, but does the call to .Int for everything else.

[22:48] <pmichaud> (and I can even go so far as to say *only* an Int, and not its derived types)

[22:48] <pmichaud> is   repr_unbox_int  currently polymorphic?

[22:48] <sorear> I endorse pmichaud's proposal too.

[22:48] <jnthn> pmichaud: On the repr, yes.

[22:48] <pmichaud> i.e, if I do  repr_unbox_int on something that isn't an Int, does it still work?

[22:49] <jnthn> pmichaud: Only if it has a repr that knows how to unbox.

[22:49] <pmichaud> well, like a Num

[22:49] <jnthn> pmichaud: If you don't know that you have a type that knows how do, you shouldn't be using that op.

[22:49] <jnthn> No, a Num needs repr_unbox_num

[22:49] <pmichaud> right

[22:49] <pmichaud> that's kind of my point

[22:49] <pmichaud> the only place I'd be doing explicit unboxing is when I know I have Int

[22:50] <pmichaud> and if I know that already, it'd be nice if the vtable could detect it and do the unbox for me in that particular case

[22:50] <jnthn> Well, it's not to do with having an Int

[22:50] <jnthn> repr_unbox_int doesn't care what type you have, it just cares that the underlying representation understands unboxing to an Int.

[22:51] <jnthn> That op is 6model primitive level, not Rakudo level.

[22:51] <pmichaud> yes, I get that.

[22:51] <jnthn> s/Int/int/

[22:52] <pmichaud> when I set up the Int class in Rakudo, is there a way I can tell 6model "and it's okay for the get_integer vtable to directly grab my native int instead of going through the .Int method that everyone else has to use"?

[22:52] <jnthn> I just have a bad feeling about making some v-table overrides specialer than others, in order to deal with something that the PAST::Contextual node will deal with in the literal cases, and where we can generally be sure what we have and use repr_unbox_int in the other cases.

[22:52] <jnthn> Not unless we implement such a primitive in 6model, no.

[22:53] <jnthn> We could put it in. I'm just not sure it'll pull its weight.

[22:53] <pmichaud> I think it would make the code more portable and readable

[22:54] <jnthn> I agree with the readability argument, and don't get the portability one. :)

[22:54] <pmichaud> usable by other p6 implementors

[22:55] <pmichaud> in some sense I'm starting to see our core.setting as a likely reference implementation for Perl 6 libraries

[22:55] <jnthn> I'd kinda expect other p6 implementors to have an unbox op. ;)

[22:55] <pmichaud> I'd kinda expect unboxing to be handled at a slightly lower level :)(

[22:55] <pmichaud> and I'm hoping that these ops become nqp:: ops

[22:56] <pmichaud> I guess at that level they become  nqp::unbox_int, hopefully.

[22:57] <pmichaud> but even better would be   nqp::islt($a, nqp::elements($array))   where I don't have to worry about unboxing $a

[22:57] <pmichaud> as I said, I won't push it now (more)

[22:57] <sorear> do you expect to have a core.setting forever?

[22:58] <pmichaud> a lot of this also resolves if I can declare  $rest_pos as      my int $rest_pos    and it stays native throughout

[22:58] <jnthn> Right :)

[22:58] <jnthn> Which is another real solution :)

[22:58] <jnthn> Essentially though, it looks like adding what you're asking for is probably adding a set of flags on the S-table, if it's per type.

[22:59] <jnthn> Which means that every s-table would get a word bigger or so. No biggie but I do worry a lot about keeping the core small. :)

[22:59] <pmichaud> right

[22:59] <pmichaud> you sound disinclined to make the change and I'm happy to go with your instinct on this one

[23:00] <pmichaud> it'll make the code uglier for a while, but I suppose we can live with that.  I am also looking at hackability by others, though.

[23:00] <jnthn> Yes, and the ugly can go away when we do native types.

[23:00] <jnthn> So it's just an incentive for us to do those sooner. ;-)

[23:00] <pmichaud> any idea of eta on that?

[23:01] <jnthn> Post-nom

[23:01] <pmichaud> yeah, I was kind of afraid of that :)

[23:01] <jnthn> Well, maybe we can pull it pre-nom if you really want.

[23:01] <pmichaud> I'd like cleaner code somehow pre-nom.  :)

[23:01] <pmichaud> and reasonably fast

[23:01] <pmichaud> I can do clean but slow or ugly and fast

[23:02] <pmichaud> and I'm not sure which one I want to emphasize right now

[23:03] <jnthn> pmichaud: With PAST::Contextual I may be in a better place to take a shot at some initial native type support.

[23:03] <pmichaud> I'm going to have a PAST::Contextual tonight.

[23:03] <jnthn> OK

[23:03] <pmichaud> I still can't decide re  hash vs other interface

[23:04] <pmichaud> the hash-based interface kind of flies-in-the-face of the way other attributes are handled in PAST

[23:04] <jnthn> Yeah, true :)

[23:04] <jnthn> But it looks prettier ;)

[23:04] <pmichaud> I was thinking we wanted to get rid of using a hash to store the attributes in favor of actual attributes

[23:05] <pmichaud> but we can't really do that with  'IiNn' => ....

[23:05] <jnthn> I'm not sure I see the connection... :)

[23:05] <jnthn> class PAST::Contextual { has %!mappings; }

[23:05] <jnthn> :)

[23:05] <pmichaud> yes, and we muck with .new to do something different than the standard build

[23:05] <jnthn> Yes, true

[23:05] <pmichaud> it's the .new that is radically different.

[23:05] <jnthn> aye

[23:05] <jnthn> Maybe it's too much effort for a little cuteness

[23:06] <jnthn> Laying the code out well can get about the same effect anyway.

[23:06] <pmichaud> I also don't quite like having the string nodes in the middle of the children either, so it does go both ways :-)

[23:06] <jnthn> To me, I'll just be exceptionally happy to have such a node at all, whatever the interface. ;-)

[23:06] <pmichaud> and having a .add_mapping  on the node seems really icky

[23:07] <pmichaud> I'd really want to be able to specify most everything in the .new( ) call.

[23:07] <jnthn> yeah

[23:07] <jnthn> nom: Q:PIR { .lex '$x', $P0 }; say 1

[23:07] <p6eval> nom: OUTPUT«1␤»

[23:07] <jnthn> nom: Q:PIR { .lex '$x', $I0 }; say 1

[23:07] <p6eval> nom: OUTPUT«error:imcc:Cannot use I register with .lex␤ in file '(file unknown)' line 69␤»

[23:07] <jnthn> Dåligt.

[23:08] <pmichaud> yes, I suspect native lexicals involves (1) updating parrot support them, or (2) abandoning .lex/find_lex/store_lex in favor of our own lexical pad management.

[23:08] <pmichaud> I'm fine with either.  :)

[23:09] <sorear> *mumble* find_lex_fast

[23:09] <pmichaud> I have a slight bias towards the latter, since we may need that anyway for other VMs

[23:09] <tadzik> find_lex_fast_and_correct

[23:11] <pmichaud> jnthn: okay, that answered my questions.  thanks.

[23:18] *** cooper joined
[23:38] *** daemon joined
[23:39] *** daniel-s joined
[23:41] *** aindilis joined
[23:42] *** pjcj joined
[23:44] *** thou joined
