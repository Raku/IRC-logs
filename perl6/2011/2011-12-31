[00:03] *** drbean left
[00:07] *** Patterner left
[00:08] *** Psyche^ joined
[00:08] *** Psyche^ is now known as Patterner

[00:09] *** drbean joined
[00:31] *** fsergot left
[00:32] *** sftp left
[00:32] *** sftp joined
[00:38] *** mj41 left
[00:40] *** drbean left
[00:41] *** alvis joined
[00:47] *** drbean joined
[00:47] <[Coke]> perl6: say NaN ~~ NaN

[00:47] <p6eval> rakudo a8c513: OUTPUT¬´Bool::True‚ê§¬ª

[00:47] <p6eval> ..pugs b927740: OUTPUT¬´1‚ê§¬ª

[00:47] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´Bool::False‚ê§¬ª

[00:48] <colomon> I reckon that's a niecza bug, but I didn't try to sort it out today.  :)

[00:49] <[Coke]> I'll open a ticket.

[00:50] <colomon> and sense all the other tests were testing against 'NaN'

[00:50] <colomon> ...

[00:50] <colomon> *since

[00:50] <colomon> sigh

[00:53] *** fridim_ left
[01:00] *** PacoAir_ joined
[01:01] *** PacoAir left
[01:01] *** PacoAir_ is now known as PacoAir

[01:01] <[Coke]> sorear: ping

[01:03] <dalek> roast: f6f95b3 | coke++ | S32-num/roots.t:

[01:03] <dalek> roast: niecza fudge

[01:03] <dalek> roast: review: https://github.com/perl6/roast/commit/f6f95b33ce

[01:04] <colomon> oh, drat!

[01:05] <colomon> I made the chance and never pushed it.

[01:05] <colomon> ok(@l[0] ~~ 'NaN', 'roots(NaN,1) returns NaN');

[01:05] <colomon> that way it matches the other tests

[01:07] <[Coke]> Feel free to straighten it out.

[01:07] <[Coke]> (but please update #97 if you do.)

[01:10] <sorear> [Coke]: pong

[01:12] *** Trashlord joined
[01:14] <[Coke]> sorear: t/spec/S12-attributes/instance.t has some passing TODOs, but one regression. Wanted to ping you before fudging it.

[01:15] <sorear> which one is the regression?

[01:16] <dalek> roast: 961581e | (Solomon Foster)++ | S32-num/roots.t:

[01:16] <dalek> roast: Changed test to match others and then removed the Niecza fudging.

[01:16] <dalek> roast: review: https://github.com/perl6/roast/commit/961581ec0f

[01:16] <[Coke]>   Failed test:  115

[01:16] <[Coke]>   TODO passed:   111-112

[01:17] <[Coke]> not ok 115 - Type enforced (hash, push)

[01:17] <sorear> ah

[01:17] <sorear> go ahead and refudge

[01:18] <sorear> Hash.push didn't exist up to today, so it automatically failed

[01:20] <[Coke]> danke.

[01:20] *** benabik left
[01:20] *** benabik joined
[01:22] *** daemon left
[01:28] *** wolfman2000 joined
[01:29] *** daemon joined
[01:34] <dalek> roast: 0e33d81 | coke++ | S12-attributes/instance.t:

[01:34] <dalek> roast: niecza fudge

[01:34] <dalek> roast: review: https://github.com/perl6/roast/commit/0e33d81cd1

[01:35] *** MayDaniel left
[01:39] *** alc joined
[01:40] *** thou_ left
[01:42] *** thou left
[01:55] *** drbean left
[02:01] *** drbean joined
[02:05] *** PacoAir left
[02:09] *** PacoAir joined
[02:10] *** cooper joined
[02:11] *** icwiener joined
[02:13] *** drbean left
[02:15] *** thou joined
[02:19] <kshannon> Gah!  S08 is so old and wrong it's confusing :(

[02:19] *** drbean joined
[02:20] *** odoacre joined
[02:23] <dalek> roast: f26848e | (Solomon Foster)++ | S02-types/type.t:

[02:23] <dalek> roast: Fudge for niecza.

[02:23] <dalek> roast: review: https://github.com/perl6/roast/commit/f26848e107

[02:24] *** Trashlord left
[02:24] <dalek> niecza: d43d35a | (Solomon Foster)++ | t/spectest.data:

[02:24] <dalek> niecza: Turn on S02-types/type.t.

[02:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d43d35ae7c

[02:32] <colomon> perl6: split("", "forty-two").join(',')

[02:32] <p6eval> pugs b927740, rakudo a8c513, niecza v13-20-g4d836ba:  ( no output )

[02:32] <colomon> perl6: say split("", "forty-two").join(',')

[02:32] <p6eval> pugs b927740, rakudo a8c513: OUTPUT¬´f,o,r,t,y,-,t,w,o‚ê§¬ª

[02:32] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´,f,o,r,t,y,-,t,w,o,‚ê§¬ª

[02:32] <colomon> sorear: ping?

[02:33] *** PacoAir left
[02:38] <colomon> sorear: never mind.  I see it's a special case that needs to be added

[02:43] *** PacoAir joined
[02:43] *** PacoAir left
[02:59] *** icwiener_ joined
[03:01] *** dayangkun joined
[03:02] *** Guest79645 left
[03:03] *** icwiener left
[03:03] <colomon> perl6: say split('this $a is $a a $a test', '$a').perl

[03:03] <p6eval> niecza v13-20-g4d836ba: OUTPUT¬´["$a"].list‚ê§¬ª

[03:03] <p6eval> ..rakudo a8c513: OUTPUT¬´("\$a",).list‚ê§¬ª

[03:03] <p6eval> ..pugs b927740: OUTPUT¬´("\$a",)‚ê§¬ª

[03:04] <colomon> ?

[03:04] <colomon> perl6: say 'this $a is $a a $a test'.split('$a').perl

[03:04] <p6eval> rakudo a8c513: OUTPUT¬´("this ", " is ", " a ", " test").list‚ê§¬ª

[03:04] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´["this ", " is ", " a ", " test"].list‚ê§¬ª

[03:04] <p6eval> ..pugs b927740: OUTPUT¬´("this ", " is ", " a ", " test")‚ê§¬ª

[03:04] *** Lilpid joined
[03:04] *** kensanata left
[03:05] <colomon> perl6: say 'this . is . a . test'.split('.').perl

[03:05] <p6eval> rakudo a8c513: OUTPUT¬´("this ", " is ", " a ", " test").list‚ê§¬ª

[03:05] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´["this ", " is ", " a ", " test"].list‚ê§¬ª

[03:05] <p6eval> ..pugs b927740: OUTPUT¬´("this ", " is ", " a ", " test")‚ê§¬ª

[03:28] <sorear> colomon: last time we talked about split "" here the consensus was that niecza was right and people who want the Perl5 behavior should use comb instead

[03:28] <colomon> really?

[03:28] <colomon> spectests certainly have not been updated to reflect that.

[03:29] <colomon> hmmm... but the spec seems to favor you

[03:30] <sorear> http://irclog.perlgeek.de/perl6/2011-12-25#i_4879648

[03:33] <colomon> okay, I've undone my changes

[03:33] <colomon> and I'm pondering fixing the spectest

[03:37] *** Psyche^ joined
[03:38] <colomon> but I'm pondering going to bed even more.

[03:38] * colomon could not get Father Ted to play on netflix.  :(

[03:38] <colomon> 'night

[03:40] *** Patterner left
[03:40] *** Psyche^ is now known as Patterner

[04:00] *** tokuhirom joined
[04:29] *** thou left
[04:30] *** achromic left
[04:32] *** achromic joined
[04:38] *** drbean left
[04:40] <flussence> ha! APL's "eval" operator *isn't* in unicode :D

[04:41] <flussence> (unfortunately, now I've learned more APL than I'd like to)

[04:42] <flussence> (if anyone's wondering, I was trying to transcribe an image for someone and failed)

[04:45] *** drbean joined
[04:49] <abercrombie> Is there gonna be a rakudo star in this month (Dec)?

[04:52] *** lutok left
[04:53] *** dayangkun left
[05:03] <geekosaur> execute isn't U+234E?

[05:07] <sorear> abercrombie: I've heard rumors of a Dec star, but tbh it's looking doubtful given the date

[05:07] <sorear> if it hasn't  already happened

[05:07] *** bluescreen10 left
[05:13] *** icwiener_ left
[05:14] *** thou joined
[05:14] *** unobe joined
[05:16] *** unobe left
[05:16] <kshannon> geekosaur, flussence: yes U+234E is definitely APL execute

[05:17] <geekosaur> (it has been a looong time since I did anything with apl...)

[05:17] *** unobe joined
[05:22] *** icwiener joined
[05:22] <thou> b: say 'hello, everyone'

[05:22] <p6eval> b 1b7dd1: OUTPUT¬´hello, everyone‚ê§¬ª

[05:26] *** molaf joined
[05:26] <sorear> hello, thou

[05:26] *** kshannon left
[05:27] *** kshannon joined
[05:28] *** thou_ joined
[05:30] <sorear> hello, thou_

[05:31] <thou> hi, sorear!

[05:31] <kshannon> .u ‚çé

[05:31] <phenny> U+234E APL FUNCTIONAL SYMBOL DOWN TACK JOT (‚çé)

[05:32] <kshannon> my IRC environment is now setup properly for unicods :)

[05:33] *** Chillance left
[05:34] <flussence> kshannon++ # I missed that one, doesn't help that my character map mixes and matches a dozen different fonts in that unicode block :)

[05:37] <thou> hi, anyone here happen to know if perl6 highlighting for github is in the works by anyone?

[05:38] <flussence> that'd be up to github I guess, since it's proprietary

[05:38] <thou> i don't know much about it, looks like github is using pygments for highlighting

[05:39] <thou> right; just seems that it's a popular platform in the p6 community, would be nice to have, i might be able to whip something up

[05:44] <sorear> perl 6 is not really syntax-highlightable

[05:44] <sorear> because the lexing process is so tightly integrated with the parser ...

[05:45] <sorear> vim is basially incapable of figuring out where regexes and strings end

[05:45] <sorear> not like Perl 5 where the multi-pass design makes it possible to find the end of a regex without fully parsing it

[05:46] <sorear> there's a syntax highlighter in the STD repo, but you're never going to get the github folks to touch it because 1. it's SLOW 2. it's not based on a lexer

[05:46] <thou> i was thinking of doing as well as vim. but maybe that's not helpful.

[05:47] <sorear> tbh I think perl.vim works better on P6 than perl6.vim

[05:48] <sorear> talk to Alias if you want to know just how screwed we are on tool support

[05:48] <thou> hrm

[05:48] <thou> maybe i'd rather stay ignorant :-)

[05:49] <thou> i saw some mention of Padre giving up

[05:49] *** Patterner left
[05:49] <thou> or that's how i interpreted the comment

[05:49] <sorear> Padre is one of Alias' projects

[05:52] *** unobe left
[05:56] *** kaare_ joined
[06:01] *** drbean left
[06:08] *** drbean joined
[06:15] <dalek> roast: 681af07 | moritz++ | S32-num/roots.t:

[06:15] <dalek> roast: remove version control conflict marker

[06:15] <dalek> roast: review: https://github.com/perl6/roast/commit/681af0794a

[06:16] *** Psyche^ joined
[06:16] *** Psyche^ is now known as Patterner

[06:17] *** icwiener left
[06:19] <dalek> roast: c980908 | moritz++ | S (2 files):

[06:19] <dalek> roast: rakudo unfudges, kshannon++

[06:19] <dalek> roast: review: https://github.com/perl6/roast/commit/c980908308

[06:24] <dalek> niecza: 4420544 | moritz++ | t/spectest.data:

[06:24] <dalek> niecza: run S32-hash/push.t

[06:24] <dalek> niecza: 

[06:24] <dalek> niecza: it now passes, thanks to Hash.perl sorting the keys. sorear++

[06:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4420544fa4

[06:25] *** Patterner left
[06:25] <dalek> rakudo/nom: 8a147ae | (Kris Shannon)++ | lib/Test.pm:

[06:25] <dalek> rakudo/nom: More Test.pm cleanups

[06:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a147ae10a

[06:25] <dalek> rakudo/nom: 39aa07e | (Kris Shannon)++ | lib/Test.pm:

[06:25] <dalek> rakudo/nom: fix diag() with newlines

[06:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/39aa07ede8

[06:39] <sorear> o/ moritz

[06:53] <sorear> perl6: class A {}; class B is A {}; class C is B {}; multi foo(A $, A $) { "AA" }; multi foo(A $, B $) { "AB" }; multi foo(A $, C $) { "AC" }; multi foo(B $, A $) { "BA" }; multi foo (C $, A $) { "CA" }; say foo(C,B)

[06:53] <p6eval> rakudo a8c513, niecza v13-20-g4d836ba: OUTPUT¬´CA‚ê§¬ª

[06:53] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "A"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/dmSEFGGeF1 line 1, column 57‚ê§¬ª

[06:54] <sorear> perl6: class A {}; class B is A {}; class C is B {}; multi foo(A $, A $) { "AA" }; multi foo(A $, B $) { "AB" }; multi foo(A $, C $) { "AC" }; multi foo(B $, A $) { "BA" }; multi foo (C $, A $) { "CA" }; say foo(C,C)

[06:54] <p6eval> rakudo a8c513: OUTPUT¬´Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:‚ê§:(A, C)‚ê§:(C, A)‚ê§‚ê§  in block <anon> at /tmp/jJheYAEg7K:1‚ê§  in <anon> at /tmp/jJheYAEg7K:1‚ê§¬ª

[06:54] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´Unhandled exception: Ambiguous dispatch for &foo‚ê§  at <unknown> line 0 (&foo @ 0) ‚ê§  at /tmp/zUFozUuzKi line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2615 (ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2616 (module-CORE ‚Ä¶

[06:54] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "A"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/CdaQFgvua0 line 1, column 57‚ê§¬ª

[06:56] <kshannon> perl6: proto sub foo(Bool $); multi sub foo(True) { say "Yes" }; multi sub foo(False) { say "No" }; foo(True); foo(False);

[06:56] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "Bool"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/ThYqFvOS6n line 1, column 15‚ê§¬ª

[06:56] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Malformed block at /tmp/ZgWB6YOxZP line 1:‚ê§------> [32mproto sub foo(Bool $)[33m‚èè[31m; multi sub foo(True) { say "Yes" }; mul[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[06:56] <p6eval> ..rakudo a8c513: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near "; multi su"‚ê§¬ª

[06:56] <kshannon> perl6: proto sub foo(Bool $) { * }; multi sub foo(True) { say "Yes" }; multi sub foo(False) { say "No" }; foo(True); foo(False);

[06:57] <p6eval> rakudo a8c513: OUTPUT¬´No applicable candidates found to dispatch to for 'foo'. Available candidates are:‚ê§:(Bool)‚ê§:(Bool)‚ê§‚ê§  in block <anon> at /tmp/FCIYFcguM7:1‚ê§  in <anon> at /tmp/FCIYFcguM7:1‚ê§¬ª

[06:57] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "Bool"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/NokRluAQ8G line 1, column 15‚ê§¬ª

[06:57] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´Unhandled exception: Unable to resolve method ast in class Any‚ê§  at /home/p6eval/niecza/src/NieczaActions.pm6 line 2122 (NieczaActions.parameter @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 2931 (P6.parameter @ 234) ‚ê§  at /home/p6eval/niecza/src/STD.pm6‚Ä¶

[06:57] *** Psyche^ joined
[06:57] *** Psyche^ is now known as Patterner

[06:57] <moritz> I'd kinda expected that to work in rakudo

[06:58] <kshannon> The problem is that it's smart matching...

[06:58] <kshannon> Or at least that's part of it.

[06:59] <kshannon> I was expecting rakudo to give "Yes\nYes\n";

[06:59] <moritz> hrm

[06:59] <kshannon> I don't think that should be the answer though...

[07:02] <moritz> one could spec eqv or === comparison for the where-block

[07:04] <kshannon> as long as you left the special case for an actual block

[07:05] <moritz> erm, I meant for *constructing* the where-block from the literal

[07:05] <moritz> sure, you can't eqv-compare an invocable block, you have to invoke it

[07:05] <kshannon> perl6: proto sub foo(Bool $) { * }; multi sub foo(Bool where ?*) { say "Yes" }; multi sub foo(Bool where !*) { say "No" }; foo(True); foo(False);

[07:05] <p6eval> rakudo 39aa07: OUTPUT¬´===SORRY!===‚ê§Cannot do non-typename cases of type_constraint yet at line 1, near ") { say \"Y"‚ê§¬ª

[07:05] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "Bool"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/4WNMRReQx4 line 1, column 15‚ê§¬ª

[07:05] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Multiple prefix constraints not yet supported at /tmp/7Ol0zrIkIJ line 1:‚ê§------> [32mol $) { * }; multi sub foo(Bool where ?*[33m‚èè[31m) { say "Yes" }; multi sub foo(Bool wher[0m‚ê§‚ê§Unhandled exception: Unable to resolve me‚Ä¶

[07:06] <moritz> rakudo: multi sub foo(Bool $ where ?*) { 'y' }; multi sub foo(Bool $ where !*) { 'n' }; say foo(True), foo(False)

[07:06] <p6eval> rakudo 39aa07: OUTPUT¬´yn‚ê§¬ª

[07:06] <kshannon> Ah!  That explains it.

[07:06] *** HarryS left
[07:07] <moritz> you need the variable name there (or $)

[07:07] *** sudokode left
[07:10] *** sudokode joined
[07:10] *** HarryS joined
[07:12] <moritz> http://lambda-the-ultimate.org/node/3680

[07:28] *** packetknife left
[07:38] *** lutok joined
[07:39] *** drbean left
[07:42] *** proller joined
[07:44] *** drbean joined
[07:47] <kshannon> moritz: I agree with your comment about the .index vs regex,  but you put it on (and closed) the wrong pull request

[07:47] <moritz> kshannon: oh, sorry about that

[07:49] <moritz> kshannon: I'm about to test and merge the second one too

[07:49] <moritz> kshannon: when you're on the topic of containers, there's something else that needs attention

[07:50] <moritz> (if you're looking for other topics to hack on, that is)

[07:50] <moritz> nom: say (gather { take [1, 2]; take [4, 5] }).perl

[07:50] <p6eval> nom 39aa07: OUTPUT¬´(1, 2, 4, 5).list‚ê§¬ª

[07:50] <moritz> &take over-eagerly flattens

[07:52] <moritz> and src/core/control.pm has a comment that it should be using nqp::p6recont_ro, but that leads to a test regression where a test loops infinitely

[07:52] <moritz> that needs some attention and debugging

[07:54] <kshannon> I've already taken a quick look at that one (but I got lost in a maze of twisty passages)

[07:55] *** sivoais left
[07:55] <kshannon> I'll give it another go in a bit.

[07:55] *** sivoais joined
[08:07] *** packetknife joined
[08:08] <dalek> rakudo/nom: 2b6f86b | (Kris Shannon)++ | src/binder/container.c:

[08:08] <dalek> rakudo/nom: Only decontainerize concrete containers.

[08:08] <dalek> rakudo/nom: 

[08:08] <dalek> rakudo/nom: It doesn't make much sense to try and decontainerize a

[08:08] <dalek> rakudo/nom: container class object as it's not really a container yet.

[08:08] <dalek> rakudo/nom: 

[08:08] <dalek> rakudo/nom: The Proxy class object in particular is very hard to

[08:08] <dalek> rakudo/nom: interrogate (e.g. for --target=past dumping)

[08:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b6f86bdbe

[08:09] <moritz> kshannon: ok, both pull requests are closed now, and I've moved the comment to the right one. Thank you very much!

[08:09] *** packetknife left
[08:13] <sorear> You can move comments/

[08:14] <moritz> sorear: you can edit comments

[08:14] <moritz> which is good enough

[08:18] <guest_> I am wondering for software engineers and programmers what their favorite IDE for developing their applications is? Mine is eclipse you can do everything in it from asm to perl , python , java , c/c++ ...etc

[08:19] <guest_> and also curious what IDE you guys/girls use at work for developing

[08:19] <sorear> every IDE I've tried has been more harm than help.

[08:19] <sorear> I don't use one.

[08:19] <guest_> what about at work

[08:20] <guest_> nothing like visual studios , code:blocks , eclipse ,...?

[08:23] <dalek> niecza: ed7ed59 | sorear++ | test3.pl:

[08:23] <dalek> niecza: Test for a currently broken MMD case

[08:23] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ed7ed595e3

[08:23] <dalek> niecza: 8f6bb3b | sorear++ | / (4 files):

[08:23] <dalek> niecza: Switch type-based multis to use the new dispatcher

[08:23] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8f6bb3bb4e

[08:31] <kshannon> guest_: vim is my IDE

[08:44] <guest_> ok , curious what you use on the job for development? Also I am assuming your many programming language of choose to code in is perl? Yes /no?

[08:47] <thou> nom: my Stringy $s; say ($s ?? "Loves me some" !! "No"), " stringies.";

[08:47] <p6eval> nom 2b6f86: OUTPUT¬´get_bool() not implemented in class 'Stringy'‚ê§  in block <anon> at /tmp/46D4_LdQQ6:1‚ê§  in <anon> at /tmp/46D4_LdQQ6:1‚ê§¬ª

[08:47] <thou> perl6: my Stringy $s; say ($s ?? "Loves me some" !! "No"), " stringies.";

[08:47] <p6eval> pugs b927740: OUTPUT¬´No stringies.‚ê§¬ª

[08:47] <p6eval> ..rakudo 2b6f86: OUTPUT¬´get_bool() not implemented in class 'Stringy'‚ê§  in block <anon> at /tmp/8qeCm2KDGw:1‚ê§  in <anon> at /tmp/8qeCm2KDGw:1‚ê§¬ª

[08:47] <p6eval> ..niecza v13-20-g4d836ba: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§In my declaration, typename 'Stringy' must be predeclared (or marked as declarative with :: prefix) at /tmp/rzDGXj9Ams line 1:‚ê§------> [32mmy Stringy[33m‚èè[31m $s; say ($s ?? "Loves me some" !! "No")[0m‚ê§‚ê§Malformed my at /‚Ä¶

[08:48] <thou> b: my Stringy $s; say ($s ?? "Loves me some" !! "No"), " stringies.";

[08:48] <p6eval> b 1b7dd1: OUTPUT¬´No stringies.‚ê§¬ª

[08:52] <sorear> thou: why are you expecting a type object to ever evalutate to True?

[08:53] <kshannon> nom: my Stringy $s = '...'; say ($s ?? "Loves me some" !! "No"), " stringies.";

[08:53] <p6eval> nom 2b6f86: OUTPUT¬´Loves me some stringies.‚ê§¬ª

[08:55] *** thou_ left
[08:56] <thou> sorear, i'm not

[08:56] <thou> but i don't want it to bail out with "get_bool() not implemented"

[08:57] <thou> i ran into this trying to get WWW::App to work, running the sample from the README

[08:57] <thou> https://github.com/supernovus/perl6-www-app/blob/master/README#L116

[09:01] <dalek> niecza: 700121d | sorear++ | lib/ (3 files):

[09:01] <dalek> niecza: Cache candidate ordering information between multisub calls

[09:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/700121da3c

[09:01] <thou> it calls method get (Stringy :$default, Bool :$multiple, *@keys) {...}, which returns $default, which if undefined returns Stringy(), which should eval to False in a boolean context i think

[09:06] *** drbean left
[09:07] <moritz> guest_: (g)vim is both my editor and IDE

[09:11] *** drbean joined
[09:14] <dalek> niecza: c6854ec | sorear++ | / (2 files):

[09:14] <dalek> niecza: Implement multi foo(A, B) syntax

[09:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c6854ec99b

[09:15] <kshannon> moritz: Another pull request :)

[09:15] <kshannon> I got fed up with MMD dispatch errors listing candidates which all looked the same,  so I spent some time elaborating Parameter.perl

[09:16] *** kaare_ left
[09:16] *** kaare__ joined
[09:19] *** kaare__ left
[09:19] *** kaare__ joined
[09:20] *** kaare__ is now known as kaare_

[09:23] *** kaare_ left
[09:23] *** kaare_ joined
[09:28] *** drbean left
[09:35] *** drbean joined
[09:41] *** kaare__ joined
[09:41] *** kaare_ left
[09:44] *** sayu joined
[09:44] *** cedric joined
[09:45] <cedric> hello #perl6!

[09:45] <sorear> hello cedric!

[09:45] <cedric> o/ sorear 

[09:47] <cedric> std: my $¬• = 2

[09:47] <p6eval> std dc62e1d: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/libNFFmSLh line 1:‚ê§------> [32mmy $[33m‚èè[31m¬• = 2[0m‚ê§    expecting any of:‚ê§     POST‚ê§   bracketed infix‚ê§        constraint‚ê§     infix or meta-infix‚ê§    postfix‚ê§        postfix_prefix_meta_operator‚ê§   shape definition‚ê§      

[09:47] <p6eval> ..statement modifier loop‚ê§        t‚Ä¶

[09:47] <cedric> std: my $¬£ = 2

[09:47] <p6eval> std dc62e1d: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/xiZptUzvvP line 1:‚ê§------> [32mmy $[33m‚èè[31m¬£ = 2[0m‚ê§    expecting any of:‚ê§     POST‚ê§   bracketed infix‚ê§        constraint‚ê§     infix or meta-infix‚ê§    postfix‚ê§        postfix_prefix_meta_operator‚ê§   shape definition‚ê§      

[09:47] <p6eval> ..statement modifier loop‚ê§        t‚Ä¶

[09:47] <sorear> Category: Sc

[09:48] *** alc left
[09:48] <cedric> not allowed as variable name?

[09:48] <sorear> nope, only \w characters

[09:48] *** sayu left
[09:48] <sorear> not symbols

[09:48] *** replore_ joined
[09:48] <cedric> ¬¢ isn't in Sc?

[09:49] *** sayu joined
[09:49] <sorear> $¬¢ is a syntactic special case, like $/

[09:50] <cedric> sorear: thanks, it makes sens to me now.

[09:50] <cedric> *sense

[09:50] <sorear> "cents" would have been better :D

[09:50] <cedric> :D

[09:51] *** kaare__ is now known as kaare_

[09:52] <sorear> TimToady has speculated in the past about allowing arbitrary variable names with a sufficiently unambiguous definition

[09:52] <sorear> note, for instance, that you can do this

[09:52] <sorear> niecza: sub term:<$¬•> { 2 }; say $¬•

[09:52] <p6eval> niecza v13-25-g700121d: OUTPUT¬´2‚ê§¬ª

[09:52] *** proller left
[09:52] <sorear> but that's not really a _variable_

[09:54] <dalek> niecza: 0d05837 | sorear++ | / (3 files):

[09:54] <dalek> niecza: Add parsing support for :_ :U :D :T

[09:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0d0583754f

[09:56] *** proller joined
[09:57] * cedric is dreaming of a Xamarin-like company for Niecza/Perl6‚Ä¶

[10:04] <dalek> niecza: 6fdfdad | sorear++ | / (2 files):

[10:04] <dalek> niecza: Implement :D :U :T :_ (fixes #82)

[10:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6fdfdad6bc

[10:07] *** thou left
[10:07] <dalek> niecza: f9968eb | sorear++ | lib/CORE.setting:

[10:07] <dalek> niecza: Account for NaN in Numeric.ACCEPTS (fixes #97)

[10:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f9968eb97d

[10:10] * sorear -> sleep

[10:16] *** cedric left
[10:20] *** replore_ left
[10:30] <moritz> evalbot rebuild niecza

[10:30] <p6eval> OK (started asynchronously)

[10:32] *** mj41 joined
[10:32] <moritz> I've published my blog post, and submitted to http://news.ycombinator.com/item?id=3410637 and http://www.reddit.com/r/programming/comments/nxey4/perl_6_in_2011_a_retrospection/ -- upvotes welcome :-)

[10:34] *** odoacre left
[10:34] *** replore_ joined
[10:56] *** proller left
[10:58] *** tokuhirom left
[10:58] <masak> morning, #perl6

[10:58] *** tokuhirom joined
[10:59] <kshannon> moritz: With simply changing the p6decont to p6recont_ro all the spectests are passing (with some TODO's passing) until the integration ones.

[10:59] <kshannon> https://gist.github.com/1543671

[11:00] <kshannon> That has some of the failing tests from t/spec/integration/99problems-01-to-10

[11:00] <kshannon> pick1 and group1 are versions which work under the patched rakudo (pick1 also works under an unpatched rakudo)

[11:01] <kshannon> pick2 and group2 are the originals

[11:02] <kshannon> Can you take a look and see if you think the tests are correct, or if they're doing it wrong.

[11:02] <kshannon> o/ masak

[11:03] <moritz> b: https://gist.github.com/1543671

[11:03] <p6eval> b 1b7dd1: OUTPUT¬´[["a", "a", "a", "a"], ["b"], ["c", "c"], ["a", "a"], ["d"], ["e", "e", "e", "e"]]‚ê§[["a", "a", "a", "a"], ["b"], ["c", "c"], ["a", "a"], ["d"], ["e", "e", "e", "e"]]‚ê§(["a", "a", "a", "a"], ["b"], ["c", "c"], ["a", "a"], ["d"], ["e", "e", "e", "e"])‚ê§(["a", "a", "a", "a"]‚Ä¶

[11:03] *** tokuhirom left
[11:03] <moritz> kshannon: I can take a look, but I'll need quite some time to dig into it I fear

[11:04] <moritz> it could very well be that the tests rely on old raudo or pugs bugs

[11:04] <kshannon> I'm just getting confused about eagerness/laziness.

[11:05] <moritz> in most cases it shouldn't matter at all, because the test comparison consumes all the lists in the end

[11:05] <kshannon> That is essentially the only difference I made to them.

[11:06] <moritz> pack2 contains @list = ();, pack1 doesn't

[11:06] <kshannon> pack1 has the my @list inside the while block instead.

[11:06] <moritz> ah right

[11:07] <moritz> that's much saner

[11:07] <kshannon> and group1 just has a .eager on the internal gather,  otherwise that code is never executed.

[11:08] <kshannon> (On my patched rakudo that is)

[11:08] <kshannon> which is why it loops forever

[11:09] <moritz> that makes sense

[11:09] <moritz> I guess that conforms to the spec

[11:10] <moritz> so feel free to push the modifications to roast

[11:10] <moritz> I also want to change the tests a bit, because they use string comparsion for nested lists, which doesn't make sense

[11:16] <dalek> roast: e469777 | moritz++ | integration/99problems-01-to-10.t:

[11:16] <dalek> roast: compare sensitive to array nesting level

[11:16] <dalek> roast: review: https://github.com/perl6/roast/commit/e469777b0d

[11:18] <moritz> kshannon: so yes, your changes to the tests are correct

[11:22] <kshannon> i.e. the old tests were wrong?

[11:23] <moritz> yes

[11:28] *** whiteknight joined
[11:28] *** whiteknight is now known as Guest1122

[11:32] *** Trashlord joined
[11:37] <kshannon> perl6: my @list = 1, 2, 3; my @anon := [@list]; @list = (); say @anon.perl;

[11:37] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´[1, 2, 3].list‚ê§¬ª

[11:37] <p6eval> ..pugs b927740: OUTPUT¬´[[1, 2, 3],]‚ê§¬ª

[11:37] <p6eval> ..rakudo 2b6f86: OUTPUT¬´Array.new()‚ê§¬ª

[11:37] <kshannon> perl6: my @list = 1, 2, 3; my @anon := [@list]; @anon.eager; @list = (); say @anon.perl;

[11:37] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´[1, 2, 3].list‚ê§¬ª

[11:37] <p6eval> ..pugs b927740: OUTPUT¬´[[1, 2, 3],]‚ê§¬ª

[11:37] <p6eval> ..rakudo 2b6f86: OUTPUT¬´Array.new(1, 2, 3)‚ê§¬ª

[11:38] <kshannon> b: my @list = 1, 2, 3; my @anon := [@list]; @list = (); say @anon.perl;

[11:38] <p6eval> b 1b7dd1: OUTPUT¬´[1, 2, 3]‚ê§¬ª

[11:38] <kshannon> b: my @list = 1, 2, 3; my @anon := [@list]; @anon.eager; @list = (); say @anon.perl;

[11:38] <p6eval> b 1b7dd1: OUTPUT¬´[1, 2, 3]‚ê§¬ª

[11:43] <kshannon> The only reference I can find in the specs to circumfix:<[ ]> is S03:4484 which pretty clearly says the result is Array not list.

[11:44] <kshannon> So I think niecza is wrong here.

[11:44] <moritz> only if .list actually returns a List :-)

[11:46] <kshannon> good point.

[11:46] <kshannon> perl6: my @list = 1, 2, 3; my @anon := [@list]; @list = (); say @anon.WHAT;

[11:46] <p6eval> pugs b927740: OUTPUT¬´Array::Const‚ê§¬ª

[11:46] <p6eval> ..rakudo 2b6f86, niecza v13-29-gf9968eb: OUTPUT¬´Array()‚ê§¬ª

[11:46] <kshannon> b: my @list = 1, 2, 3; my @anon := [@list]; @list = (); say @anon.WHAT;

[11:46] <p6eval> b 1b7dd1: OUTPUT¬´Array()‚ê§¬ª

[11:52] <kshannon> perl6: my @list = 1, 2, 3; my @anon := [@list]; @anon[1]; @list = (); say @anon.perl;

[11:52] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´[1, 2, 3].list‚ê§¬ª

[11:52] <p6eval> ..pugs b927740: OUTPUT¬´[[1, 2, 3],]‚ê§¬ª

[11:52] <p6eval> ..rakudo 2b6f86: OUTPUT¬´elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:4833‚ê§  in method REIFY at src/gen/CORE.setting:5036‚ê§  in method reify at src/gen/CORE.setting:4257‚ê§  in method reify at src/gen/CORE.setting:4257‚ê§  in method reify at src/gen/CORE.se‚Ä¶

[11:53] <kshannon> Say What???

[11:55] <tadzik> rakudo: say .?WHAT

[11:55] <p6eval> rakudo 2b6f86: OUTPUT¬´===SORRY!===‚ê§Cannot use .? on a non-identifier method call at line 1, near ""‚ê§¬ª

[11:55] <tadzik> meh

[11:58] <eiro> hello

[11:58] <eiro> is there some kind of "exhaust" command in perl6 ? 

[11:59] <eiro> my $line = $f.get;

[11:59] <moritz> what would that do?

[11:59] *** fsergot joined
[11:59] <eiro> my @lines = exhausts $f.get 

[11:59] <fsergot> hi o/

[11:59] <eiro> something like this 

[11:59] <eiro> kkk

[11:59] <moritz> eiro: my @lines = $f.liens;

[11:59] <eiro> oops sory

[11:59] <moritz> erm, lines

[12:00] <eiro> moritz, sure but what i would like to have is a generic function to achieve this 

[12:00] <eiro> (as it is a current pb to exhaust an iterator in an array

[12:01] <moritz> eiro: I'm of two minds. My first opinion is "nice, and easy to do", and the second is "it would be much more perlish to expose the iterator as a lazy list int he first place"

[12:02] <moritz> sub exhaust($iter) { while $iter.get -> $x { $x } } # or so

[12:03] <eiro> perhaps using the | operator ? 

[12:03] <eiro> @lines = |$f.get ? 

[12:03] <eiro> time to eat. cya

[12:05] <masak> hi fsergot 

[12:08] <moritz> (), { $iter.get } ...^ !*.defined

[12:08] * geekosaur doesn't recall exactly, there was a unary = operator for that originally that got de-specced?

[12:09] <colomon> geekosaur: yes

[12:10] <moritz> it was never specced to the generality that eiro++ wants, and it was never specced in a way that could have actually worked

[12:12] *** sayu left
[12:16] *** fridim_ joined
[12:16] *** bluescreen10 joined
[12:17] <masak> in a way, it's comforting to see the discussion having moved on from "Perl 6 doesn't exist" to "Perl 6 isn't ready yet": http://news.ycombinator.com/item?id=3410637

[12:18] <eiro> re 

[12:18] <eiro> moritz, what the hell is that ? :) 

[12:18] <eiro> ...^ ? 

[12:19] *** kaare_ left
[12:19] *** kaare__ joined
[12:19] <masak> eiro: seems to be a way to iterate $iter using the sequence operator.

[12:19] <eiro> infinite use of the iterator while the result isn't defined ( !*.defined ) 

[12:19] <eiro> :) 

[12:19] <masak> no, until the result isn't defined.

[12:19] <eiro> (),  is a part of the expression ? 

[12:19] <masak> for loops use "while" semantics, sequence ops use "until" semantics.

[12:20] <eiro> masak, yep! my fault ?

[12:20] <masak> eiro: yes, that's just initializing the sequence with nothing.

[12:20] <eiro> :)

[12:20] <eiro> ok :) 

[12:20] <masak> eiro: need to syntactically fill that spot somehow.

[12:23] *** cognominal_ joined
[12:25] *** fridim_ left
[12:25] <eiro> just played with the moritz answer: perl6 don't need an exhaust command :) 

[12:26] <eiro> is this lazy ? 

[12:26] *** cognominal___ left
[12:26] <masak> aye.

[12:26] <eiro> \o/

[12:27] <eiro> masak, so why do i waste time with perlude ???? 

[12:27] <masak> eiro: you tell me :P

[12:27] <eiro> (i guess you don't know why ... i'm just a prick!)

[12:27] *** MayDaniel joined
[12:27] <masak> in all seriousness, though, I think perlude looks interesting.

[12:28] <masak> it's cool to see how far Perl 5 can be taken.

[12:28] <eiro> well ... it is cool when you're stuck to perl5 ... but frankly: i would like to use perl6

[12:29] <eiro> that's a point 

[12:29] <dalek> roast: 252783d | (Solomon Foster)++ | S32-scalar/defined.t:

[12:29] <dalek> roast: Fudge for niecza.

[12:29] <dalek> roast: review: https://github.com/perl6/roast/commit/252783dab3

[12:30] *** nanobyte joined
[12:30] <masak> eiro: luckily, there are several very talented people in here who work every day to bring you more of Perl 6.

[12:30] <masak> I'm more in awe of them than I can adequately express.

[12:31] <eiro> masak, i know that ... i really would like to push perl6 in my new job 

[12:31] <eiro> http://pastebin.com/AdcjUHnz

[12:32] <eiro> i still don't understand the new map syntax 

[12:32] <colomon> you need braces around the .say

[12:33] <colomon> lines('/etc/passwd')[0..4].map: { .say }

[12:33] <eiro> oh! parentheses 

[12:33] <colomon> though I prefer lines('/etc/passwd')[0..4].map({ .say })

[12:33] <tadzik> or nothing at all: $a.map: *.say :)

[12:33] <eiro> no .. doesn't work neither :(

[12:34] <eiro> tadzik, !!!

[12:34] *** cognominal_ left
[12:34] <tadzik> doesn't it?

[12:34] <tadzik> also, define "doesn't work"

[12:34] <eiro> argh! also failed 

[12:35] <moritz> you need to use lines(open('/etc/passwd'))  or so

[12:35] *** cognominal joined
[12:35] <moritz> lines() just returns the lines of a string by default

[12:35] <moritz> nom: say "a\nb\nc\n".lines.perl

[12:35] <p6eval> nom 2b6f86: OUTPUT¬´("a", "b", "c").list‚ê§¬ª

[12:36] <eiro> moritz, no: see my lines implementation: it opens the file 

[12:38] <eiro> .say for lines('/etc/passwd')[0..4];

[12:38] <eiro> (lines('/etc/passwd')[0..4]).map: *.say;

[12:38] <eiro> (lines('/etc/passwd')[0..4]).map: ({.say});

[12:38] <eiro> (lines('/etc/passwd')[0..4]).map: {.say};

[12:38] <eiro> only the first line works 

[12:39] <eiro> (last rakudo star release) 

[12:40] <eiro> nom: open('/etc/passwd').lines.map: *.say 

[12:40] <p6eval> nom 2b6f86: OUTPUT¬´open is disallowed in safe mode‚ê§  in sub restricted at src/SAFE.setting:2‚ê§  in sub open at src/SAFE.setting:5‚ê§  in block <anon> at /tmp/0bC_1JL2dA:1‚ê§  in <anon> at /tmp/0bC_1JL2dA:1‚ê§¬ª

[12:40] <eiro> nom: .say for lines('/etc/passwd')[0..4];

[12:40] <eiro> (lines('/etc/passwd')[0..4]).map: *.say;

[12:40] <eiro> (lines('/etc/passwd')[0..4]).map: ({.say});

[12:40] <p6eval> nom 2b6f86: OUTPUT¬´/etc/passwd‚ê§¬ª

[12:40] <eiro> nom: thanks anyway

[12:40] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&anyway' called (line 1)‚ê§Undefined routine '&thanks' called (line 1)‚ê§¬ª

[12:40] <colomon> eiro -- that likely means it's your lines implementation that's the problem, not map

[12:41] <eiro> colomon, how to reach this conclusion ? 

[12:41] <eiro> colomon, it's not mine: moritz's fault ;) 

[12:42] *** flussence joined
[12:42] <eiro> colomon, btw: i don't know how to fix things now

[12:42] <colomon> try  say lines('/etc/passwd')[0..4].perl

[12:43] <eiro> it's a list!

[12:44] <eiro> ("root:x:0:0:root:/root:/bin/bash", "bin:x:1:1:bin:/bin:/bin/false", ....

[12:44] <colomon> okay, I take it back -- it is map which is the problem!

[12:44] <colomon> particularly, the problem is that map is lazy

[12:45] <colomon> eager lines('/etc/passwd')[0..4].map({ .say  }); # this works

[12:46] <eiro> this is sooo tricky!

[12:47] <colomon> for lines('/etc/passwd')[0..4] { .say } # should work fine

[12:47] <Timbus> are you.. using map for its side effect???

[12:47] <colomon> Timbus: yes, that's why laziness was an issue

[12:47] <eiro> Timbus, not at all 

[12:48] <Timbus> im calling the functional police

[12:48] <eiro> just: the for loop is so '60

[12:48] <Timbus> they arrive in reverse, sometimes before and sometimes after i call them

[12:49] <eiro> \o/

[12:49] <Timbus> depending on implementation

[12:49] <eiro> Timbus++

[12:50] *** tokuhirom joined
[12:52] <masak> I think .map should be eager in that situation, due to being in sink context.

[12:52] <masak> but Rakudo doesn't always do that right yet.

[12:53] <eiro> ok ... bug ?

[12:53] <colomon> woah, perl 6 in 2011 #1 on hacker news!

[12:53] <masak> Timbus is right, but only on a shallow syntactical level. &map and for are synonymous in Perl 6.

[12:54] <colomon> but not yet in rakudo

[12:55] <Timbus> i think you should always only call map for its return tho, regardless.

[12:55] <colomon> and I for one agree pretty strongly with Timbus's instinct: use map when you're being functional, use for when you're being imperative.  

[12:56] <colomon> the language may not require it, but it will make your code clearer

[12:56] <Timbus> if yuo want crazy side effecty stuff in your sinks, why not have a .for method

[13:00] <masak> Timbus: I agree about map and lack of side effects. it's mostly a pragmatics thing.

[13:07] <Timbus> yey, im right

[13:07] <Timbus> also it is new years here, right now

[13:07] <Timbus> i can tell from the explosions

[13:07] <Timbus> so, happy new year i guess?

[13:07] *** rindolf joined
[13:07] <rindolf> Hi all.

[13:08] <colomon> happy new year!

[13:08] <rindolf> http://barzilay.org/misc/scribble-reader.pdf - I've mentioned this link before and it seems very complicated and idiosyncratic.

[13:08] <Timbus> new years and im on irc :L

[13:08] <rindolf> colomon: happy new year.

[13:08] <Timbus> thanks colomon :>

[13:14] <dalek> niecza: 824084a | (Solomon Foster)++ | t/spectest.data:

[13:14] <dalek> niecza: Turn on S32-scalar/defined.t.

[13:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/824084a00c

[13:15] <masak> Timbus: wait, where are you? .jp?

[13:16] <Timbus> au

[13:16] <Timbus> learned my perl from damien conway :3

[13:18] <rindolf> Timbus: it's "Damian" - not "Damien"

[13:18] <rindolf> Timbus: Damien is his evil twin.

[13:18] <Timbus> yeah i knew that after i typed it

[13:19] <rindolf> Timbus: ah.

[13:21] <masak> oh wow, a TheDamian disciple! o.O

[13:22] <Timbus> ha. yeah i got hooked on perl at monash university, even though it was just an elective class.

[13:23] <Timbus> easiest high distinction i ever managed. left the exam over an hour early. not because im any good at the whole education thing, perl was just that good :3

[13:24] <kshannon> rindolf: I think it's very well thought out and a great idea...

[13:24] <kshannon> as long as you accept the implied belief that SEXPR's are the one true way.

[13:25] <rindolf> kshannon: you do?

[13:25] <rindolf> kshannon: Eli claims that it's not SEXPR-specific.

[13:26] <rindolf> kshannon: anyway, I've started reading the syntax description by example, and didn't make a lot of progress, and I'm already close to giving up.

[13:26] <rindolf> He claims it's "simple" at the introduction.

[13:26] <rindolf> Maybe it's Simple like SOAP.

[13:27] *** Trashlord left
[13:27] <rindolf> The indentation handling stuff there is weird.

[13:28] <dalek> roast: c63cd09 | (Solomon Foster)++ | S02-literals/misc-interpolation.t:

[13:28] <dalek> roast: Fudge for niecza.

[13:28] <dalek> roast: review: https://github.com/perl6/roast/commit/c63cd0950f

[13:28] <dalek> niecza: 9625e2f | (Solomon Foster)++ | t/spectest.data:

[13:28] <dalek> niecza: Turn on S02-literals/misc-interpolation.t.

[13:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9625e2f798

[13:43] *** Trashlord joined
[13:44] *** muthu joined
[13:48] <masak> I like the discussion in the reddit thread.

[13:48] <masak> but this is a comment I don't know how to answer: http://news.ycombinator.com/item?id=3410852

[13:49] *** muthu left
[13:49] <masak> the kind of stability the commenter wants is perhaps Perl 6 implementation's weakest point, or at least Rakudo's.

[13:50] <masak> maybe it's simply that the time hasn't been ripe for making any demands on feature stability. there's been too much flux to root out first.

[13:51] <masak> the worst part (for me) in the master->ng and b->nom transitions have been the silent, unnanounced regressions that are almost inevitable when making a wholesale switch of that kind.

[13:51] <masak> maybe the time for those is now coming to an end... but it's hard to tell.

[13:52] *** PacoAir joined
[13:52] <moritz> unnanounced?

[13:52] <masak> hm, that should be "alpha->ng", I guess.

[13:53] <moritz> yes, we've learned from that

[13:53] <masak> moritz: well, the bigger transitions have been announced, of course. but no-one said "don't use <->, because we're not implementing it in ng"

[13:54] <masak> I know this isn't done with malice; but it does make it harder to keep the app space stable, just like the commenter writes.

[13:55] <masak> I remember mberends reacting in Oslo 2009 to the fact that the policy for handling regressions was to fudge them with TODO markers.

[13:56] <masak> that's not a TODO, that's a regression!

[13:58] <masak> but I realize that taking regressions super-seriously is an attitude that has to be phased in, as Perl 6 and its implementations reach maturity.

[13:58] <masak> alpha: my @a = 1..3; for @a <-> $e { $e++ }; say @a.perl

[13:58] <p6eval> alpha : OUTPUT¬´[2, 3, 4]‚ê§¬ª

[13:59] <masak> b: my @a = 1..3; for @a <-> $e { $e++ }; say @a.perl

[13:59] <p6eval> b 1b7dd1: OUTPUT¬´===SORRY!===‚ê§Missing block at line 22, near "; say @a.p"‚ê§¬ª

[13:59] <masak> nom: my @a = 1..3; for @a <-> $e { $e++ }; say @a.perl

[13:59] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near "; say @a.p"‚ê§¬ª

[13:59] *** cedric joined
[13:59] <cedric> Bonne ann√©e #perl6!

[13:59] <masak> pugs: my @a = 1..3; for @a <-> $e { $e++ }; say @a.perl

[13:59] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected ">"‚ê§    at /tmp/y9lV7ykWkf line 1, column 24‚ê§¬ª

[13:59] <masak> niecza: my @a = 1..3; for @a <-> $e { $e++ }; say @a.perl

[13:59] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´[2, 3, 4].list‚ê§¬ª

[13:59] <masak> cedric: bonne ann√©e!

[14:01] <cedric> I see something really strange in Parrot: the function utf8_iter_skip() is called *many* times with the *same* parameters

[14:02] <cedric> I added this trace to this function: fprintf(stderr, "0x%016lx %u\n", djb2((unsigned char *)str->strstart), (unsigned)i->charpos);

[14:02] <cedric> where djb2() is a hash function for C strings

[14:02] <cedric> then: perl6 S03-operators/basic-types.t 2>utf8_iter_skip.log

[14:03] <cedric> "wc -l utf8_iter_skip.log" reports 87535 whereas "sort -u utf8_iter_skip.log | wc -l" reports 7524 only

[14:04] <cedric> that means Rakudo/Parrot iters several times over the same C string‚Ä¶ I'm wrong?

[14:05] <masak> probably not. question is, why are you surprised? :)

[14:07] <masak> aww, reddit commenter deleted his comment :/

[14:07] <masak> s/reddit/HN/

[14:10] *** rindolf left
[14:11] <cedric> masak: I'm surprised because of the factor (10x) moreover this function is the top contributor regarding CPU time consumption. 

[14:11] <masak> oh!

[14:11] <masak> I missed the 10x part. :/

[14:12] <masak> cedric++ # finding this

[14:20] * cedric is comparing utf8_iter_skip()'s backtraces

[14:27] <kshannon> Is there any low level dump I can do in a running rakudo program to show the internals of a list without affecting it's current reification (i.e. no eagerness applied anywhere)

[14:27] *** hundskatt left
[14:30] <kshannon> rindolf: It could be applied to a non-SEXPR language,  but most of the cleverness becomes a little useless...

[14:30] *** cedric left
[14:32] <kshannon> There are some good design principles he mentions that are worthwhile emulating.  The balanced start/stop markers and allowing generic markers so that the normal ones become just literal text,  but we've already got that here :)

[14:32] <tadzik> kshannon: I think __DUMP doesn't reify and all

[14:34] <kshannon> Method '__DUMP' not found for invocant of class 'Array'

[14:34] <kshannon> How do I call it?

[14:35] *** cooper left
[14:36] <kshannon> I'm trying to track down the bug that causes this:

[14:36] <kshannon> my @list = 1, 2, 3; my @anon := [@list]; @anon[1]; @list = (); say @anon.perl;

[14:36] <kshannon> nom: my @list = 1, 2, 3; my @anon := [@list]; @anon[1]; @list = (); say @anon.perl;

[14:36] <p6eval> nom 2b6f86: OUTPUT¬´elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:4833‚ê§  in method REIFY at src/gen/CORE.setting:5036‚ê§  in method reify at src/gen/CORE.setting:4257‚ê§  in method reify at src/gen/CORE.setting:4257‚ê§  in method reify at src/gen/CORE.setti‚Ä¶

[14:44] <masak> huh.

[14:50] <tadzik> oh, it's just DUMP

[14:50] <tadzik> nom: my @a = 1..5; say @a.DUMP

[14:50] <p6eval> nom 2b6f86: OUTPUT¬´Array<2521208963817262333>(:items(Mu), :nextiter(ListIter<2521208963804634618>(:reified(‚ñ∂Mu), :rest(RPA<2521208963804634604>(Array<2521208963804627698>(:items(RPA<2521208963804692200>(‚ñ∂1, ‚ñ∂2, ‚ñ∂3, ‚ñ∂4, ‚ñ∂5)), :nextiter(‚ñ∂Mu)))), :list(Array<2521208963817262333>))))‚ê§¬ª‚Ä¶

[14:52] *** sayu joined
[14:58] <kshannon> I was pretty close to reimplementing that with a bit of Q:PIR...

[14:59] <kshannon> My output syntax was even pretty close :)

[15:02] *** RobiX joined
[15:04] *** replore_ left
[15:06] *** rindolf joined
[15:11] *** replore joined
[15:12] *** RobiX left
[15:16] *** replore left
[15:16] *** hundskatt joined
[15:28] *** thou joined
[15:32] *** replore joined
[15:37] *** replore left
[15:42] *** mj41 left
[15:43] <eiro> ba

[15:43] <eiro> back 

[15:44] <eiro> masak, for and map aren't the same thing for me: for is a way to break chainability

[15:44] <eiro> (or i have something to learn about perl6 for

[15:44] <masak> eiro: for is *literally* syntactic sugar for &map in Perl 6.

[15:45] <eiro> masak, for isn't a syntaxic suggar, it's a syntaxic conceptual error :)

[15:45] <masak> things like 'next', 'redo' and 'last' work in &map just as they do in a for loop.

[15:45] <eiro> but i understand what you mean 

[15:45] <masak> eiro: I'm not talking about how things are according to philosophical mumbo-jumbo; I'm talking about how they are according to the spec.

[15:46] <eiro> i get that

[15:51] <masak> by which I mean, you may opine that it's a syntactic conceptual error all you want; it *is* syntactic sugar, in the sense that the former is mechanically replaced by the latter behind the scenes.

[15:52] <colomon> (in theory)

[15:52] <masak> sure, conceptually.

[15:52] <masak> cheating is allowed as long as it's never discovered. :)

[15:53] <colomon> no, I meant in current practice.  ;)

[15:54] <masak> Rakudo does such a transformation, AFAIK.

[15:56] <colomon> nom: sub forever { gather loop { take 1 }; }; for forever -> $a { say $a }

[15:56] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near ""‚ê§¬ª

[15:56] <colomon> nom: sub forever { gather loop { take 1; }; }; for forever -> $a { say $a }

[15:56] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near ""‚ê§¬ª

[15:56] <colomon> nom: sub forever() { gather { loop { take 1; }; }; }; for forever -> $a { say $a }

[15:56] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near ""‚ê§¬ª

[15:56] <colomon> nom: sub forever() { gather { loop { take 1; }; }; }; for forever -> $a { say $a; }

[15:56] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Missing block at line 1, near ""‚ê§¬ª

[15:56] <colomon> :\

[15:58] <masak> colomon: need '()' after 'forever'

[15:58] <colomon> nom: sub forever() { gather { loop { take 1; }; }; }; for forever() -> $a { say $a; }

[15:58] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 2‚ê§¬ª

[15:58] <colomon> nom: sub forever() { gather { loop { take 1; }; }; }; for forever() -> $a { say $a; };

[15:58] <p6eval> nom 2b6f86: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 2‚ê§¬ª

[15:58] <colomon> dang it, it works fine locally

[15:58] <masak> you have a strange character in 'say'

[15:58] <colomon> nom: sub forever() { gather { loop { take 1; }; }; }; for forever() -> $a { say $a; };

[15:58] <colomon> there we go

[15:58] <masak> success.

[15:58] <p6eval> nom 2b6f86: OUTPUT¬´(timeout)¬ª

[15:59] <colomon> nom: sub forever() { gather { loop { take 1; }; }; }; forever().map( -> $a { say $a; })[^10];

[15:59] <p6eval> nom 2b6f86: OUTPUT¬´1‚ê§1‚ê§1‚ê§1‚ê§1‚ê§1‚ê§1‚ê§1‚ê§1‚ê§1‚ê§¬ª

[15:59] <masak> nom: .say for gather loop { take 1 }

[15:59] <p6eval> nom 2b6f86: OUTPUT¬´(timeout)¬ª

[16:00] <colomon> I guess that's not absolute proof that the implementations are different internally (modulo eagerness) but it seems suggestive

[16:00] <masak> shorter way of writing it :)

[16:05] *** Mowah left
[16:07] *** mdxi joined
[16:07] <fsergot> How can I check when the end of the program is? e.g. i want to do something at the end of the program but write this at the start.

[16:10] <tadzik> END {}?

[16:10] <tadzik> nom: END { say 'end' }; say "not end"

[16:10] *** Mowah joined
[16:10] <p6eval> nom 2b6f86: OUTPUT¬´not end‚ê§end‚ê§¬ª

[16:11] <masak> END++

[16:11] <masak> fsergot: now tell us what problem it is you're trying to solve :)

[16:11] <tadzik> hmm

[16:11] <colomon> niecza: END { say 'end' }; say "not end"

[16:11] <tadzik> that could serve as a poor man's DESTROY, maybe

[16:11] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´not end‚ê§¬ª

[16:11] <colomon> doh!

[16:11] <fsergot> masak, this is what i want! thanks masak++

[16:12] <fsergot> tadzik++

[16:12] <fsergot> colomon++

[16:12] <fsergot> thanks :)

[16:12] <tadzik> class A { method new { END { say "freeing resources"; }; self.bless(*); } }; A.new; A.new; A.new; say "wololo";

[16:12] <tadzik> nom: class A { method new { END { say "freeing resources"; }; self.bless(*); } }; A.new; A.new; A.new; say "wololo";

[16:12] <p6eval> nom 2b6f86: OUTPUT¬´wololo‚ê§freeing resources‚ê§¬ª

[16:12] <fsergot> theres no problem, i'm just playing  p6 :)

[16:12] <tadzik> meh

[16:13] <masak> fsergot: so you just became curious if there√§s a mechanism to defer code execution to the end? :)

[16:13] <fsergot> yes

[16:16] <masak> fsergot: you belong here :)

[16:16] <fsergot> thanks :)

[16:21] <colomon> perl6: sub foo(:$x) { say $x; }; foo(:x)

[16:21] <p6eval> rakudo 2b6f86, niecza v13-29-gf9968eb: OUTPUT¬´Bool::True‚ê§¬ª

[16:21] <p6eval> ..pugs b927740: OUTPUT¬´1‚ê§¬ª

[16:29] *** thou left
[16:30] *** mj41 joined
[16:36] <colomon> moritz: ping?

[16:41] *** nanobyte left
[16:44] <tadzik> a challenge appears: http://www.reddit.com/r/programming/comments/nw8ve/what_is_the_coolest_thing_you_can_do_in_10_lines/c3cqjiq?context=3

[16:46] *** Trashlord left
[16:50] <masak> I *think* this is a faithful translation:

[16:50] <masak> nom: sub sieve(@xs) { my $x = pop @xs.list; sieve grep { $_ %% $x }, @xs }; .say for sieve 2..*

[16:50] <p6eval> nom 2b6f86: OUTPUT¬´No applicable candidates found to dispatch to for 'Real'. Available candidates are:‚ê§:(Mu $v, Mu %_)‚ê§‚ê§  in method Real at src/gen/CORE.setting:656‚ê§  in sub infix:<%%> at src/gen/CORE.setting:2192‚ê§  in block <anon> at /tmp/TqSoTCAC2v:1‚ê§  in method ACCEPTS at src/gen/COR‚Ä¶

[16:50] <masak> nom: sub sieve(@xs) { my $x = pop @xs; sieve grep { $_ %% $x }, @xs }; .say for sieve 2..*

[16:50] <p6eval> nom 2b6f86: OUTPUT¬´Method 'pop' not found for invocant of class 'Range'‚ê§  in sub pop at src/gen/CORE.setting:4901‚ê§  in sub sieve at /tmp/rh_Z1h6mwT:1‚ê§  in block <anon> at /tmp/rh_Z1h6mwT:1‚ê§  in <anon> at /tmp/rh_Z1h6mwT:1‚ê§¬ª

[16:50] <masak> nom: sub sieve(@xs) { my $x = pop @xs; sieve grep { $_ %% $x }, @xs }; .say for sieve [2..*]

[16:50] <p6eval> nom 2b6f86: OUTPUT¬´No applicable candidates found to dispatch to for 'Real'. Available candidates are:‚ê§:(Mu $v, Mu %_)‚ê§‚ê§  in method Real at src/gen/CORE.setting:656‚ê§  in sub infix:<%%> at src/gen/CORE.setting:2192‚ê§  in block <anon> at /tmp/L8W86nB_AJ:1‚ê§  in method ACCEPTS at src/gen/COR‚Ä¶

[16:50] <masak> niecza: sub sieve(@xs) { my $x = pop @xs; sieve grep { $_ %% $x }, @xs }; .say for sieve 2..*

[16:50] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´Unhandled exception: Unable to resolve method pop in class Range‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/a4Xmcmugiz line 0 (sieve @ 0) ‚ê§  at /tmp/a4Xmcmugiz line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2615 (ANON @ 2) ‚ê§ ‚Ä¶

[16:51] <masak> can't pop a Range. too bad. :)

[16:51] <masak> niecza: sub sieve(@xs) { my $x = pop @xs; sieve grep { $_ %% $x }, @xs }; .say for sieve (2..100).list

[16:51] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´(timeout)¬ª

[16:51] <masak> oh, I forgot...

[16:51] <colomon> should fiddle:x("a"):y("b")() be a legal function call?

[16:51] <masak> niecza: sub sieve(@xs) { my $x = pop @xs; $x, sieve grep { $_ %% $x }, @xs }; .say for sieve (2..100).list

[16:52] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´(timeout)¬ª

[16:52] <masak> hrm :)

[16:52] * colomon is doing a complete overhaul on S03-operators/adverbial-modifiers.t

[16:53] <masak> niecza: sub sieve(@x [$x, *@xs]) { $x, sieve grep { $_ %% $x }, @xs }; .say for sieve (2..100).list

[16:53] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method post_constraint not yet implemented at /tmp/neBOxW9RMH line 1:‚ê§------> [32msub sieve(@x [$x, *@xs][33m‚èè[31m) { $x, sieve grep { $_ %% $x }, @xs }; [0m‚ê§‚ê§Unhandled exception: Unable to resolve method sorry in‚Ä¶

[16:53] <masak> nom: sub sieve(@x [$x, *@xs]) { $x, sieve grep { $_ %% $x }, @xs }; .say for sieve (2..100).list

[16:53] <p6eval> nom 2b6f86: OUTPUT¬´Not enough positional parameters passed; got 0 but expected at least 1 in sub-signature of parameter @x‚ê§  in sub sieve at /tmp/W_sJEbJ_B0:1‚ê§  in sub sieve at /tmp/W_sJEbJ_B0:1‚ê§  in sub sieve at /tmp/W_sJEbJ_B0:1‚ê§  in sub sieve at /tmp/W_sJEbJ_B0:1‚ê§  in sub sieve at /t‚Ä¶

[16:54] * masak gives up

[16:55] <colomon> niecza: sub fiddle(:$x,:$y){$x~$y}; fiddle:x("a"):y("b")();

[16:55] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'fiddle:x("a"):y("b")' used at line 1‚ê§‚ê§Potential difficulties:‚ê§  &fiddle is declared but not used at /tmp/VUmLps23jm line 1:‚ê§------> [32msub fiddle[33m‚èè[31m(:$x,:$y){$x~$y}; fiddle:x("a"):y("b")()[0m‚Ä¶

[16:55] <colomon> std: sub fiddle(:$x,:$y){$x~$y}; fiddle:x("a"):y("b")();

[16:55] <p6eval> std dc62e1d: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§ 'fiddle:x("a"):y("b")' used at line 1‚ê§Check failed‚ê§FAILED 00:01 125m‚ê§¬ª

[16:56] <colomon> okay, I'm taking that as a no

[16:57] *** replore joined
[16:57] *** replore left
[16:58] <kshannon> nom: multi sub sieve(@x []) { () }; multi sub sieve(@x [$x, *@xs]) { $x, sieve grep { $_ %% $x }, @xs }; .say for sieve (2..600).list

[16:58] <p6eval> nom 2b6f86: OUTPUT¬´2‚ê§4‚ê§8‚ê§16‚ê§32‚ê§64‚ê§128‚ê§256‚ê§512‚ê§¬ª

[16:59] <kshannon> Was that supposed to be the sieve of eratosthenes

[17:00] <kshannon> nom: multi sub sieve(@x []) { () }; multi sub sieve(@x [$x, *@xs]) { $x, sieve grep { $_ !%% $x }, @xs }; .say for sieve (2..600).list

[17:00] <p6eval> nom 2b6f86: OUTPUT¬´2‚ê§3‚ê§5‚ê§7‚ê§11‚ê§13‚ê§17‚ê§19‚ê§23‚ê§29‚ê§31‚ê§37‚ê§41‚ê§43‚ê§47‚ê§53‚ê§59‚ê§61‚ê§67‚ê§71‚ê§73‚ê§79‚ê§83‚ê§89‚ê§97‚ê§101‚ê§103‚ê§107‚ê§109‚ê§113‚ê§127‚ê§131‚ê§137‚ê§139‚ê§149‚ê§151‚ê§157‚ê§163‚ê§167‚ê§173‚ê§179‚ê§181‚ê§191‚ê§193‚ê§197‚ê§199‚ê§211‚ê§223‚ê§227‚ê§229‚ê§233‚ê§239‚ê§241‚ê§251‚ê§257‚ê§263‚ê§269‚ê§271‚ê§277‚ê§281‚ê§283‚ê§293‚ê§307‚ê§311‚ê§313‚ê§317‚ê§331‚ê§337‚ê§347‚ê§349‚ê§353‚ê§359‚ê§367‚ê

[17:00] <kshannon> There you go...

[17:00] <masak> kshannon++

[17:01] <tadzik> http://goo.gl/H8LHT

[17:01] <masak> nom: multi sub sieve(@x []) { () }; multi sub sieve(@x [$x, *@xs]) { $x, sieve grep { $_ !%% $x }, @xs }; .say for sieve (2..*).list

[17:01] <p6eval> nom 2b6f86:  ( no output )

[17:02] <masak> aww :)

[17:03] <tadzik> replied on reddit, kshannon++

[17:03] <masak> nom: multi sieve([]) {}; multi sieve(@x [$x, *@xs]) { $x, sieve @xs.grep: { $_ % $x } }; .say for sieve (2..600).list

[17:03] <p6eval> nom 2b6f86: OUTPUT¬´2‚ê§3‚ê§5‚ê§7‚ê§11‚ê§13‚ê§17‚ê§19‚ê§23‚ê§29‚ê§31‚ê§37‚ê§41‚ê§43‚ê§47‚ê§53‚ê§59‚ê§61‚ê§67‚ê§71‚ê§73‚ê§79‚ê§83‚ê§89‚ê§97‚ê§101‚ê§103‚ê§107‚ê§109‚ê§113‚ê§127‚ê§131‚ê§137‚ê§139‚ê§149‚ê§151‚ê§157‚ê§163‚ê§167‚ê§173‚ê§179‚ê§181‚ê§191‚ê§193‚ê§197‚ê§199‚ê§211‚ê§223‚ê§227‚ê§229‚ê§233‚ê§239‚ê§241‚ê§251‚ê§257‚ê§263‚ê§269‚ê§271‚ê§277‚ê§281‚ê§283‚ê§293‚ê§307‚ê§311‚ê§313‚ê§317‚ê§331‚ê§337‚ê§347‚ê§349‚ê§353‚ê§359‚ê§367‚ê

[17:03] <masak> nom: multi sieve([]) {}; multi sieve(@x [$x, *@xs]) { $x, sieve @xs.grep: * % $x }; .say for sieve (2..600).list

[17:03] <p6eval> nom 2b6f86: OUTPUT¬´2‚ê§3‚ê§5‚ê§7‚ê§11‚ê§13‚ê§17‚ê§19‚ê§23‚ê§29‚ê§31‚ê§37‚ê§41‚ê§43‚ê§47‚ê§53‚ê§59‚ê§61‚ê§67‚ê§71‚ê§73‚ê§79‚ê§83‚ê§89‚ê§97‚ê§101‚ê§103‚ê§107‚ê§109‚ê§113‚ê§127‚ê§131‚ê§137‚ê§139‚ê§149‚ê§151‚ê§157‚ê§163‚ê§167‚ê§173‚ê§179‚ê§181‚ê§191‚ê§193‚ê§197‚ê§199‚ê§211‚ê§223‚ê§227‚ê§229‚ê§233‚ê§239‚ê§241‚ê§251‚ê§257‚ê§263‚ê§269‚ê§271‚ê§277‚ê§281‚ê§283‚ê§293‚ê§307‚ê§311‚ê§313‚ê§317‚ê§331‚ê§337‚ê§347‚ê§349‚ê§353‚ê§359‚ê§367‚ê

[17:04] <masak> nice combination of a number of Perl 6 features there. :)

[17:04] *** PacoAir left
[17:04] <masak> looking forward to it working on 2..* -- that seems to be the only thing Haskell has over Rakudo at this point :)

[17:05] <kshannon> Ummm, how about a lot less crashes :)

[17:05] <masak> kshannon: be gald you weren't around three years ago :>

[17:05] <kshannon> *lol*

[17:05] <tadzik> :D

[17:06] <kshannon> I was,  but I didn't stick around...

[17:06] *** PacoAir joined
[17:07] <masak> tadzik: you *will* get comments on that magical number 600 unles syou pre-empt them yourself...

[17:07] <masak> s/unles syou/unless you/

[17:08] <tadzik> let the interest appear :)

[17:08] <kshannon> Is there any design docs on how the rakudo List/ListIter/MapIter internals are *SUPPOSED* to work.

[17:08] <tadzik> on the sad part, they probably won't run the code anyway

[17:09] <kshannon> git blame mainly points the finger at pmichaud

[17:09] *** tokuhirom left
[17:10] *** tokuhirom joined
[17:14] *** tokuhirom left
[17:15] <masak> kshannon: pmichaud meant to update S07 before he suddenly got very little online time...

[17:16] *** am0c joined
[17:19] *** replore joined
[17:19] *** replore left
[17:22] *** Trashlord joined
[17:30] <colomon> std: sub fiddle(:$x,:$y){$x~$y}; fiddle :x("a")(:y("b"));

[17:30] <p6eval> std dc62e1d: OUTPUT¬´ok 00:01 125m‚ê§¬ª

[17:31] <colomon> niecza: sub fiddle(:$x,:$y){$x~$y}; fiddle :x("a")(:y("b"));

[17:31] <p6eval> niecza v13-29-gf9968eb: OUTPUT¬´Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Pair‚ê§  at /tmp/iGn1eOMX1z line 1 (mainline @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2615 (ANON @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2616 (module-CORE @ 6‚Ä¶

[17:34] <sorear> good * #perl6

[17:34] <colomon> o/

[17:34] <tadzik> o/

[17:36] *** awoodland joined
[17:36] <masak> o/

[17:40] *** SHODAN joined
[17:40] <fsergot> o/

[17:40] *** replore joined
[17:40] *** replore left
[17:43] <TimToady> moritz: your second spec paragraph overstates the case; see S06:1012

[17:43] <phenny> TimToady: 30 Dec 09:22Z <frettled> tell TimToady The presentation paper for the exploit against PHP, Java etc. provides the information necessary for performing a successful test against a hash implementation :)  (And a merry time-of-year to you)   http://events.ccc.de/congress/2011/Fahrplan/attachments/2007_28C3_Effective_DoS_on_web_application_platforms.pdf

[17:44] *** JimmyZ joined
[17:45] <fsergot> tadzik how it goes with Bailador? :)

[17:48] *** drbean left
[17:51] <kshannon> re S07: Iterators and Laziness - "The programmer must not rely on circular side effects ..."

[17:51] <kshannon> That's fine,  but rakudo shouldn't die if you fiddle in the middle as it were.

[17:52] <masak> nod

[17:52] *** snearch joined
[17:53] *** drbean joined
[17:53] <kshannon> nom: my @list = 1, 2, 3; my @anon := [@list]; say @anon[1]; @list = (); say @anon.perl

[17:53] <p6eval> nom 2b6f86: OUTPUT¬´2‚ê§elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:4833‚ê§  in method REIFY at src/gen/CORE.setting:5036‚ê§  in method reify at src/gen/CORE.setting:4257‚ê§  in method reify at src/gen/CORE.setting:4257‚ê§  in method reify at src/gen/CORE.set‚Ä¶

[17:54] * ruoso kinda lost in how to understand why my sudoku solver keeps segfaulting... https://gist.github.com/1538015 (now with the initial sudoku game inlined, no input required)...

[17:55] <kshannon> I've traced that down to the @anon !nextiter still pointing to the @list which has been cleared, but holding onto the '3' as the rest...

[17:55] <kshannon> I think something else needs doing during Array.STORE

[17:56] <kshannon> ruoso: It's a memory leak in Rakudo.

[17:56] <kshannon> I can run it for a long time if I add lots of swap...

[17:57] <kshannon> I just didn't have the patience to run it long enough to get an answer :)

[17:57] <masak> ruoso: a good guess is that it's the array-indexing on junctions that's causing the segfault. try rewriting it without those.

[17:57] <kshannon> As far as I can tell,  the leak isn't is your perl code.

[17:58] <kshannon> I don't get segfaults,  just 'Killed' due to out of memory.

[17:59] * ruoso trying to run without calling the "cleanup-impossible-values" part

[17:59] <ruoso> hmm... maximum recursion depth exceeded

[17:59] <kshannon> I can even watch the 'free -m' and 'top' and see it chew it all up until there's none left...

[18:00] * ruoso lunch &

[18:01] *** GlitchMr joined
[18:01] *** replore joined
[18:01] *** replore left
[18:06] *** drbean left
[18:12] *** drbean joined
[18:15] <TimToady> moritz: also, splitting the ** quantiifer into ** and %/%% might be worth a mention

[18:17] <masak> +1

[18:22] *** replore joined
[18:23] *** replore left
[18:25] <TimToady> new functions/operators: val, gcm, lcd, categorize

[18:25] <TimToady> val is perhaps the most important of those

[18:29] <masak> we should have &permutations and &combinations in CORE, too -- just so we don't have to reinvent them each time in RC solutions :P

[18:29] <masak> alternatively, a "closure" operator (in the sense of "transitive closure")

[18:30] <masak> I suppose building such an operator would be easier if we had object hashes...

[18:30] <sorear> Should END ever be called in module compilation mode?

[18:31] <masak> sorear: no...?

[18:31] <masak> sorear: it doesn't in Perl 5.

[18:31] <masak> sorear: and S04 says "at run time, ALAP"

[18:32] <sorear> masak: I mean like if there's a BEGIN exit 0 in a module, do the modules' ENDs get called?

[18:32] <sorear> I guess END should only be called if compilation finishes successfully?

[18:32] <sorear> so that there is a "run time"

[18:32] * masak tests with Perl 5

[18:33] <masak> $ perl -E 'BEGIN { exit 0 } END { say "OH HAI" }'

[18:33] <masak> prints nothing.

[18:35] *** JimmyZ left
[18:35] <sorear> other way around :D

[18:35] <sorear> in that example, the END is never even parsed.

[18:35] <masak> $ perl -E 'END { say "OH HAI" } BEGIN { exit 0 }'

[18:35] <masak> OH HAI

[18:35] * sorear notes that BEGIN { say "hi" }; syntax error  elicits a hi

[18:35] <masak> guess there's your answer, then.

[18:36] <sorear> things are fundamentally different in niecza because niecza supports caching of precompiled modules

[18:36] *** thou joined
[18:36] <sorear> so the CHECK and INIT times can, in principle, be separated by a lot

[18:37] <sorear> I'm setting it up now so that ENDs are called whenever the context they exist in is unloaded or exits

[18:37] <sorear> which I think best fits the spirit of "as late as possible"

[18:38] <kshannon> rouso: http://pastebin.com/MkM1c0MM\

[18:39] <kshannon> It ran to completion but it needed a little over 15Gb of Virtual memory

[18:40] *** cognominal left
[18:41] <dalek> niecza: f166585 | sorear++ | lib/Kernel.cs:

[18:41] <dalek> niecza: Implement END running

[18:41] <dalek> niecza: 

[18:41] <dalek> niecza: END blocks are run whenever the container is unloaded, or at process exit.

[18:41] <dalek> niecza: This means you may see END blocks running during module precompilation;

[18:41] <dalek> niecza: I call this a feature (suppose you're using temp files in BEGIN-time code).

[18:41] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f16658527a

[18:43] *** pothos_ joined
[18:43] *** Lothar left
[18:43] *** PZt left
[18:44] *** replore joined
[18:44] *** replore left
[18:44] *** cxreg left
[18:44] *** fhelmberger left
[18:44] *** ashleydev left
[18:44] *** kthakore left
[18:44] *** Exodist left
[18:44] *** mattp_ left
[18:45] *** sivoais left
[18:45] *** pothos left
[18:45] *** TimToady left
[18:45] *** athomason left
[18:45] *** pothos_ is now known as pothos

[18:45] *** am0c left
[18:45] *** sorear left
[18:45] *** Exodist joined
[18:45] *** TimToady joined
[18:46] *** mattp_ joined
[18:46] *** cxreg joined
[18:46] *** Mowah left
[18:46] *** sorear joined
[18:46] *** kthakore joined
[18:46] *** ashleydev joined
[18:46] *** Lothar joined
[18:46] *** proller joined
[18:46] *** sivoais joined
[18:46] *** athomason joined
[18:47] *** fhelmberger joined
[18:47] *** Mowah joined
[18:48] *** am0c joined
[18:50] *** drbean left
[18:51] *** cognominal joined
[18:54] *** fsergot left
[18:57] *** drbean joined
[18:59] *** mj41 left
[18:59] *** awoodland left
[19:00] *** am0c left
[19:00] *** awoodland joined
[19:01] <kshannon> perl6: proto sub foo(Bool $) { * }; multi sub foo(True) { say "Yes" }; multi sub foo(False) { say "No" }; foo(True); foo(False);

[19:01] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "Bool"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/8K4QncKUec line 1, column 15‚ê§¬ª

[19:01] <p6eval> ..rakudo 2b6f86: OUTPUT¬´No applicable candidates found to dispatch to for 'foo'. Available candidates are:‚ê§:(Bool)‚ê§:(Bool)‚ê§‚ê§  in block <anon> at /tmp/f64aT3txWh:1‚ê§  in <anon> at /tmp/f64aT3txWh:1‚ê§¬ª

[19:01] <p6eval> ..niecza v13-29-gf9968eb: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Lexical True is not a package at /tmp/bd48KTwb3_ line 1:‚ê§------> [32mub foo(Bool $) { * }; multi sub foo(True[33m‚èè[31m) { say "Yes" }; multi sub foo(False) { [0m‚ê§‚ê§Lexical False is not a package at /tmp/bd48KTwb3_ line 1:‚Ä¶

[19:03] *** alvis left
[19:03] <kshannon> TimToady: Does it make sense to you that the True in 'multi sub foo(True) { ... }' should really mean 'Bool where { $_ === True }' rather than 'Bool where True'

[19:04] *** Khisanth left
[19:05] *** replore joined
[19:07] <TimToady> well, True is an enum, which functions both as a constant and as a subset type with one value, so it comes out to the same thing really

[19:08] *** Lothar left
[19:08] *** ingy left
[19:08] *** ingy joined
[19:08] *** kcwu left
[19:08] *** kcwu joined
[19:09] <TimToady> note that True is defined, so should not be matching as a type object

[19:09] *** replore left
[19:10] <TimToady> oh, wait, I see what's going on there

[19:11] <TimToady> smartmatching treats Boolean values specially

[19:11] <TimToady> where True always succeeds, and where False always fails

[19:12] <kshannon> exactly

[19:13] <TimToady> nom: say True === True

[19:13] <p6eval> nom 2b6f86: OUTPUT¬´Bool::True‚ê§¬ª

[19:13] <TimToady> nom: my Bool $x = True; say $x === True

[19:13] <p6eval> nom 2b6f86: OUTPUT¬´Bool::True‚ê§¬ª

[19:13] <masak> nom: sub foo(True) { say "OH HAI" }; foo(False)

[19:13] <p6eval> nom 2b6f86: OUTPUT¬´Nominal type check failed for parameter ''; expected Bool but got Bool instead‚ê§  in sub foo at /tmp/8CGkpZfxJg:1‚ê§  in block <anon> at /tmp/8CGkpZfxJg:1‚ê§  in <anon> at /tmp/8CGkpZfxJg:1‚ê§¬ª

[19:13] <masak> o.O

[19:13] * masak submits rakudobug

[19:14] <kshannon> Although I'm wondering for the more general case as well.  Where the literal value is not smart matched against but compared either === or eqv.

[19:14] <TimToady> well, for a subset type with multiple values, === won't work

[19:15] <kshannon> But that's still a type.

[19:16] <kshannon> Or is there some more hand wavy stuff I haven't internalized which says there's no real difference between types and values...

[19:16] <TimToady> well, they're definitely different to :D/:U

[19:17] <kshannon> Hmmm, alright I can accept that.

[19:17] <TimToady> in fact, subset types are how we express "Just" types in p6

[19:19] <TimToady> perl6: subset JustInt of Int where Any:D; my $JustInt $x = Int;

[19:19] <p6eval> rakudo 2b6f86: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "my $JustIn"‚ê§¬ª

[19:19] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "$x"‚ê§    expecting "?", "!", trait, "=", infix assignment or operator‚ê§    at /tmp/kCQ4T2GWhj line 1, column 48‚ê§¬ª

[19:19] <p6eval> ..niecza v13-32-gf166585: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Two terms in a row at /tmp/34ZtLw2lUF line 1:‚ê§------> [32mJustInt of Int where Any:D; my $JustInt [33m‚èè[31m$x = Int;[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[19:19] *** Khisanth joined
[19:19] *** proller left
[19:19] <TimToady> perl6: subset JustInt of Int where Any:D; my JustInt $x = Int;

[19:19] <p6eval> pugs b927740:  ( no output )

[19:19] <p6eval> ..rakudo 2b6f86: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&Any:D' called (line 1)‚ê§¬ª

[19:19] <p6eval> ..niecza v13-32-gf166585: OUTPUT¬´Potential difficulties:‚ê§  $x is declared but not used at /tmp/q85oQrwYlC line 1:‚ê§------> [32m JustInt of Int where Any:D; my JustInt [33m‚èè[31m$x = Int;[0m‚ê§‚ê§¬ª

[19:20] <TimToady> heh, widespread disbelief :)

[19:20] <kshannon> hehe

[19:21] <TimToady> perl6: say Any:D.WHAT

[19:21] <p6eval> pugs b927740: OUTPUT¬´*** No such subroutine: "&D"‚ê§    at /tmp/bhDHqoba8q line 1, column 9 - line 2, column 1‚ê§¬ª

[19:21] <p6eval> ..rakudo 2b6f86: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&Any:D' called (line 1)‚ê§¬ª

[19:21] <p6eval> ..niecza v13-32-gf166585: OUTPUT¬´Any()‚ê§¬ª

[19:21] <masak> niecza: sub foo(True) { say "OH HAI" }; foo(False)

[19:21] <p6eval> niecza v13-32-gf166585: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Lexical True is not a package at /tmp/dLBxrbd0HD line 1:‚ê§------> [32msub foo(True[33m‚èè[31m) { say "OH HAI" }; foo(False)[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die‚Ä¶

[19:21] <masak> niecza: sub foo(1) { say "OH HAI" }; foo(1)

[19:21] <p6eval> niecza v13-32-gf166585: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 806 (warn @ 2) ‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 170 (Mu.Str @ 9) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/src/nie‚Ä¶

[19:22] <kshannon> Is a subset type still possibly :T

[19:23] <kshannon> or is :T gone already... :)

[19:23] <TimToady> may not be necessary if we continue to move Failure out of Any

[19:23] *** rindolf left
[19:24] <TimToady> Failure seems to be turning into a conceptual type that is allowed to violate return types

[19:25] <TimToady> that is, although it is not a bottom type, it can function as one for returning values that aren't valid

[19:25] *** awoodland left
[19:26] <TimToady> it is likely that Inf and NaN may turn into conceptual types as well, in order to emulate those concepts for representations that do not support them directly, as Num does under IEEE

[19:26] *** replore joined
[19:26] *** replore left
[19:27] <dalek> roast: 868ae08 | (Solomon Foster)++ | S03-operators/adverbial-modifiers.t:

[19:27] <dalek> roast: Complete overhaul -- make tests one liners, regroup somewhat, and eliminate tests which are illegal according to std.

[19:27] <dalek> roast: review: https://github.com/perl6/roast/commit/868ae08d76

[19:32] <dalek> niecza: a211fbc | (Solomon Foster)++ | t/spectest.data:

[19:32] <dalek> niecza: Turn on S03-operators/adverbial-modifiers.t.

[19:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a211fbcaa7

[19:32] <colomon> niecza: END { say 'end' }; say "not end"

[19:32] <p6eval> niecza v13-32-gf166585: OUTPUT¬´not end‚ê§end‚ê§¬ª

[19:32] <colomon> sorear++

[19:35] <kshannon> phenny: tell rouso that I made a small change to the sudoku cleanup-impossible-values ( https://gist.github.com/1544907 ) but it still needed 15GB to run to completion even if it completed in about half the output lines.

[19:35] <phenny> kshannon: I'll pass that on when rouso is around.

[19:35] *** thou_ joined
[19:35] *** Moukeddar joined
[19:36] *** Lothar joined
[19:38] *** awoodland joined
[19:47] <ruoso> finally... I've catch the segfault on the debug

[19:48] *** replore joined
[19:48] <ruoso> https://gist.github.com/1545127

[19:48] *** replore left
[19:49] <kshannon> I wonder what's different between your setup and mine.

[19:50] <colomon> sorear: t/spec/S06-multi/type-based.t .. Unhandled exception: Unable to resolve method ast in class Any # internal p6 grammar actions error?  no .ast in the .t file...

[19:50] <ruoso> kshannon: I'm not sure your change makes any difference

[19:52] <ruoso> because it simply will run one extra time if there is a solve, but in the second solve there won't be anything new

[19:53] <kshannon> Without it it sometimes chooses to put two of the same number in a row or column or grid

[19:53] *** packetknife joined
[19:55] <kshannon> I don't think it will ever get to a solution with that,  but I did see it going down a long (i.e. about 5 levels and about 40 chooses) blind alley.

[19:55] *** fsergot joined
[19:57] <ruoso> hmm... I guess you're right... solving something down the path may solve something in the beggining of the array...

[19:58] <sorear> colomon: yes, internal error.  (Look at the stack trace)

[20:00] <dalek> roast: 6c5c1dd | (Solomon Foster)++ | S03-operators/autoincrement.t:

[20:00] <dalek> roast: Fudge for niecza.

[20:00] <dalek> roast: review: https://github.com/perl6/roast/commit/6c5c1ddc56

[20:01] <dalek> niecza: 44e2a2a | (Solomon Foster)++ | t/spectest.data:

[20:01] <dalek> niecza: Turn on S03-operators/autoincrement.t.

[20:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/44e2a2a85e

[20:02] *** cognominal left
[20:02] *** cognominal joined
[20:03] <kshannon> phenny: tell kshannon he spelt ruoso's nick wrong...

[20:03] <phenny> You can tell yourself that.

[20:04] <ruoso> heh...

[20:06] <ruoso> kshannon: but... did the solver ended in your setup?

[20:06] <kshannon> I'm tempted to change my nick just so phenny can deliver the mis-addreesed message.  Where I live physically might be a pigsty,  but I like my virtual spaces clean...

[20:08] <kshannon> yes.  both with and wihtout my patch - as long as I provided a little over 15Gb of virtual memory for it to use.

[20:09] *** replore joined
[20:09] *** replore left
[20:11] <kshannon> Before I added the extra swap space it would run until all virtual memory was used up and then be killed by the OS.

[20:11] *** kshannon is now known as rouso

[20:11] <rouso> hello phenny

[20:11] <phenny> Hey rouso!

[20:11] <phenny> rouso: 07 May 19:24Z <BrowserUk> tell rouso please no with the cooroutines! They are cooperative. One uncooperative collaborator and everything hangs. The do not scale; cannot make use of multiple cores; require endless tuning for every small change. The are a dead technology--if you experienced Windows3 you know what I mean.

[20:12] <phenny> rouso: 07 May 19:29Z <BrowserUk> tell rouso Same thing for green threads. Don't expect implementations to write their own in-process schedulers and do anything like a good job in the first 5 tries. With at least 6-18 months between iterations. They also do not scale across multiple cores/processors. (I can buy a 48 cores system from AMD for $16,000 today). 64 cores next year. Beyond?

[20:12] <phenny> rouso: 07 May 19:31Z <BrowserUk> tell rouso Same thing for green threads. Don't expect implementations to write their own in-process schedulers and do anything like a good job in the first 5 tries. With at least 6-18 months between iterations. They also do not scale across multiple cores/processors. (I can buy a 48 cores system from AMD for $16,000 today). 64 cores next year. Beyond?

[20:12] <phenny> rouso: 19:35Z <kshannon> tell rouso that I made a small change to the sudoku cleanup-impossible-values ( https://gist.github.com/1544907 ) but it still needed 15GB to run to completion even if it completed in about half the output lines.

[20:12] *** rouso is now known as kshannon

[20:12] <kshannon> I see I'm not the only one who's misspelt it...

[20:13] <sorear> o/ 

[20:13] <kshannon> \o

[20:15] <masak> hello phenny

[20:15] <phenny> Hey masak!

[20:15] <masak> \o/

[20:15] <colomon> nom: 'theXbigXbang'.split(/X/, -1)

[20:16] <p6eval> nom 2b6f86:  ( no output )

[20:16] <colomon> nom: 'theXbigXbang'.split(/X/, -1).perl.sat

[20:16] <p6eval> nom 2b6f86: OUTPUT¬´Method 'sat' not found for invocant of class 'Str'‚ê§  in block <anon> at /tmp/91Ay09UWmj:1‚ê§  in <anon> at /tmp/91Ay09UWmj:1‚ê§¬ª

[20:16] <ruoso> hah... may 07?

[20:16] <colomon> nom: 'theXbigXbang'.split(/X/, -1).perl.say

[20:16] <p6eval> nom 2b6f86: OUTPUT¬´().list‚ê§¬ª

[20:18] <colomon> niecza: 'theXbigXbang'.split(/X/, -1).perl.say

[20:18] <p6eval> niecza v13-32-gf166585: OUTPUT¬´["theXbigXbang"].list‚ê§¬ª

[20:18] <colomon> ah, right

[20:23] *** guest_ left
[20:25] <sorear> ruoso: May 7th... of which year?

[20:26] <sorear> obviously written before the 48 core MacBooks were released

[20:30] *** replore joined
[20:30] *** replore left
[20:35] *** bluescreen10 left
[20:36] *** Moukeddar left
[20:43] *** drbean left
[20:46] *** GlitchMr is now known as PolakMr

[20:48] *** bluescreen10 joined
[20:49] *** drbean joined
[20:51] *** replore joined
[20:52] *** replore left
[20:56] *** cooper joined
[20:56] *** cooper left
[20:56] *** cooper joined
[21:02] * masak .oO( but 47 cores go unused because I mostly use it to check my mail )

[21:05] *** drbean left
[21:11] *** drbean joined
[21:13] *** replore joined
[21:13] *** replore left
[21:19] *** thou left
[21:20] *** mikemol left
[21:22] *** Lilpid left
[21:25] <colomon> woah, lots of fails in the niecza spectest!

[21:26] *** snearch left
[21:28] <sorear> wah?

[21:28] *** PZt joined
[21:28] <sorear> what'd I just break?

[21:28] <sorear> probably sig parsing

[21:29] <sorear> colomon: what's a failing file?

[21:30] *** Trashlord left
[21:30] <colomon> pick.t

[21:31] <colomon> Unhandled exception: No candidates for dispatch to pick; candidates are:

[21:31] <colomon> with no list following

[21:31] <sorear> ick

[21:31] <colomon> looks like that's happening on the first .pick

[21:31] <colomon> I notice it's a multi method.

[21:33] <sorear> right.

[21:34] *** replore joined
[21:34] *** replore left
[21:36] <sorear> I think I see the problem.

[21:38] <sorear> I wish git wouldn't change the modtime on every single file across a pull

[21:38] <sorear> it really confuses vim

[21:39] <dalek> niecza: 412ed92 | sorear++ | lib/Kernel.cs:

[21:39] <dalek> niecza: Ignore optional parameters when computing min arity in new-MMD, colomon++

[21:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/412ed92a15

[21:39] <sorear> 5.pick works now

[21:43] *** moritz left
[21:43] *** moritz joined
[21:44] *** mikemol joined
[21:46] *** fsergot left
[21:52] *** REPLeffect left
[21:54] *** fsergot joined
[21:55] *** fsergot left
[21:55] *** replore joined
[21:56] *** replore left
[22:05] *** drbean left
[22:08] *** x3nU joined
[22:11] <colomon> sorear++

[22:12] *** drbean joined
[22:13] *** PolakMr is now known as GlitchMr

[22:17] *** PacoAir left
[22:22] *** mj41 joined
[22:45] *** bluescreen10 left
[22:46] *** GlitchMr left
[22:52] *** Trashlord joined
[22:54] <masak> I feel like my living room is the eye of a storm of tons of pyrotechnics.

[22:55] *** sayu left
[22:56] <flussence> free rave lighting!

[22:57] <masak> glad I didn't go to bed and try to sleep ;)

[22:57] *** drbean left
[22:58] <masak> I think Samoa moved one day ahead just to get all these fireworks over with and move on with their lives.

[22:58] <masak> oh well,

[22:58] <masak> happy new year, people o/

[22:59] <flussence> every end of year manages to completely ruin my sleep cycle. I've been doing 4pm-7am days for a week and I'll have to fix it soon :(

[22:59] <masak> here's to a prosperous 2012 for Perl 6!

[22:59] * masak raises glass

[22:59] <kshannon> *clink*

[22:59] <flussence> o/

[23:00] <masak> man, you weren't kidding about that rave lighting.

[23:02] *** drbean joined
[23:03] *** Chillance joined
[23:03] <Woodi> happy and aver better year for all :)

[23:05] <masak> \o/

[23:05] <masak> wanna see who finds the year's first rakudobug? :D

[23:06] <sorear> o/ masak

[23:06] <masak> \o

[23:06] * sorear is still on new year's eave :D

[23:06] *** x3nU left
[23:06] <sorear> if it gets too bright I'll board up my windows or something.

[23:06] * masak .oO( "I ain't been droppin' no eaves!" )

[23:07] *** x3nU joined
[23:07] <masak> sorear: I was a bit surprised that Niecza doesn't do ':(5)' -> ':(Int where { $_ ~~ 5 })' yet.

[23:09] <masak> 'course, it's just sugar, possible to live without...

[23:13] *** bkolera joined
[23:16] <kshannon> nom: sub fireworks($len) { eval '"' ~ (32 xx 32, 10017..10059).roll($len).map({ .fmt("\\x[%x]") }).join ~ '"'; }; say fireworks(70);

[23:16] <p6eval> nom 2b6f86: OUTPUT¬´ ‚ùâ‚úµ‚úæ‚úø‚úΩ  ‚ú∂ ‚ú∏‚ú∑  ‚ùã‚ùã ‚ú¥  ‚ú≠‚ú¢  ‚úæ   ‚ùÜ‚úæ ‚ú• ‚ú•‚ú∏  ‚ùà ‚ú´‚ú∂‚ú©‚úø‚ùä ‚ú™ ‚ú¢‚ùÅ‚ú¥‚úº‚ùÜ ‚ú≥‚ùÑ‚ú∏‚úº‚ú£ ‚ùá‚ùá ‚ùÖ‚ú∫ ‚úπ‚úÆ‚ùÑ‚ùá‚ùÜ‚ê§¬ª

[23:17] <kshannon> Of course,  it really needs some color...

[23:17] <sorear> masak: niecza doesn't do :() or "where" either :p

[23:20] <kshannon> nom: sub fireworks($len) { (32 xx 32, 10017..10059).roll($len).map(&chr).join }; say fireworks(70);

[23:20] <p6eval> nom 2b6f86: OUTPUT¬´‚ú± ‚ùÉ‚ú¨  ‚ú§‚ú¨  ‚ú´ ‚úÆ‚ùÖ  ‚ú§‚ú∑‚ùÖ  ‚úµ‚ú©‚ùÑ ‚ùÄ  ‚úµ‚úµ ‚ùÜ ‚ùÜ        ‚ùá‚ú∑‚ú™‚ú¶ ‚úø ‚úø  ‚ú±‚ú®‚úº‚úπ ‚ùÉ‚ùä‚úª ‚ú§ ‚úº‚ú¥ ‚ú∫   ‚ê§¬ª

[23:23] <masak> kshannon: pretty :)

[23:25] <masak> nom: say (.chr for (32 xx 32, 10017..10059).roll(70)).join

[23:25] <p6eval> nom 2b6f86: OUTPUT¬´‚ú∏‚ú≠‚úØ‚ú∫  ‚ùÅ ‚úº‚ú∞ ‚ùÖ   ‚ú¥ ‚úπ‚ú∞‚úØ‚ùä‚ùà‚úÆ ‚úæ  ‚úß ‚ùã ‚ú£ ‚ú±‚ú¢   ‚ùÜ      ‚úº ‚úº ‚ú°‚ú≠‚ùâ‚ùÜ ‚ú≤‚ú¥‚ùá‚ú´ ‚úØ  ‚úß‚ùÑ‚ùÉ‚ú£ ‚ú±  ‚ê§¬ª

[23:25] <colomon> happy new years!

[23:26] <masak> \o/

[23:28] <colomon> sorear: your last patch fixed .pick, but S02-names/pseudo.t is still failing.  

[23:28] * colomon is packing up some whistles and nom and heading down to the new year's concert / potluck.

[23:29] <sorear> colomon: will investigate

[23:30] <sorear> ahahahaha

[23:30] <sorear> it's the :D patch ... $CORE::_ is being interpreted as a modified $CORE:

[23:30] <masak> ;)

[23:32] *** integral joined
[23:33] *** drbean left
[23:34] <dalek> niecza: 6406010 | sorear++ | src/niecza:

[23:34] <dalek> niecza: $CORE::_ is not an :_-modified name

[23:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6406010663

[23:38] <masak> 'night, #perl6

[23:39] *** drbean joined
[23:42] *** replore joined
[23:42] *** x3nU left
[23:43] *** x3nU joined
[23:47] *** replore left
[23:47] *** Mowah left
[23:48] <Timbus> nom: print 3.chr ~ (1..14).pick ~ .chr for (32 xx 32, 10017..10059).roll(70)

[23:48] <p6eval> nom 2b6f86: OUTPUT¬´14‚ùà9 3 11‚ùÉ3‚úª4‚úµ4‚ùä11 11 14 6‚ùÄ3 11‚ú≥10‚ú≤13 9 8 10‚ùÖ11 5 10‚ú¶4‚úπ12‚úª12 8 13 8‚ùÉ11‚úπ2 4‚úæ6‚úΩ2‚ú∏8 9‚ú∑10‚ùÉ10 5‚ú™5‚ú∫12‚ùâ10 7‚ú≠10‚ùÇ12‚úÆ12 12‚ùá2‚ú≥10 14 3 8‚úø8‚úΩ1‚úø7‚ú≠9 3 8‚ú©7‚úΩ11‚ùÜ1‚ú¢9 4 10‚ú∂2‚ùÉ14‚ùÑ5 3‚ú¶2‚ú´12 13 5‚ú•¬ª‚Ä¶

[23:49] <Timbus> hoho

[23:49] <Timbus> first try

[23:50] <Timbus> slightly prettier

[23:50] <Timbus> nom: print 3.chr ~ (2..13).pick ~ .chr for (32 xx 32, 10017..10059).roll(70)

[23:50] <p6eval> nom 2b6f86: OUTPUT¬´6 4 4‚ùÇ8 13‚ùã2 11 4‚ú¥12 12‚úØ3 3‚ùá8‚ùÖ4 11‚ú∂6‚ùÉ11‚ú∂5 2 3 2‚úª12 10‚ùÅ8 7‚ú©11‚úÆ9‚úø11‚úª9‚ùä11‚ùÉ5 9 8 8 2 6‚ùá5‚ùà6 11 13‚ú∂11‚ùÇ13‚ú®7‚ú´11 8 12‚ùä13 4‚úΩ12‚ùÑ7‚ú≤10‚úΩ2‚ú¨6‚ùÖ3 5‚ùÉ8 13 8 7 8‚ú∂6 6‚úØ13‚ùÑ11 6‚ùä6‚ú™4 2‚ùä9 11 ¬ª‚Ä¶

[23:51] <Timbus> NOW FOR THE SOUND EFFECTS *looks up the 'bell character' ascii code*

