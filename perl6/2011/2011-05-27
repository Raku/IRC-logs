[00:03] *** silug left
[00:11] <tylercurtis> sorear++

[00:14] *** daniel-s left
[00:17] *** thou left
[00:19] *** Ali_h left
[00:19] *** Ali_h joined
[00:23] *** wamba left
[00:25] <ashleydev> what happened to the efforts of fglock?

[00:25] <sorear> fglock mostly disappeared

[00:26] <ashleydev> btw sorear++ # test passage

[00:26] <ashleydev> yeah I wonder why he disappeared...

[00:26] <sorear> common reasons for people vanishing off the internet: entering a PhD program, getting a job, raising kids

[00:26] <sorear> I doubt it's anything worrisome, it's probably something great

[00:27] *** quietfanatic joined
[00:28] <sorear> o/ quietfanatic

[00:28] <quietfanatic> hello

[00:28] <quietfanatic> I am trying to figure out what the best way to parameterize a grammar is.

[00:29] <sorear> details?

[00:29] <quietfanatic> I have a grammar that operates one one line of a file at a time

[00:29] <quietfanatic> something like: token TOP { ^ $LINE_BEGIN <directive> $LINE_END $ }

[00:29] <quietfanatic> the $LINE_END and $LINE_BEGIN things there

[00:29] <quietfanatic> are so that the lines can be embedded into comments in some other file format.

[00:30] <sorear> sounds like what you want is subclassing

[00:30] <sorear> token TOP { ^ <.line_begin> <directive> <.line_end> $ }

[00:30] <quietfanatic> Hmm.

[00:30] <quietfanatic> I see.

[00:30] <sorear> token line_begin { <?> }

[00:30] <sorear> token line_end { <?> }

[00:31] <quietfanatic> subclassing at runtime might be difficult though

[00:31] <quietfanatic> The program is supposed to sniff out the commenting format of the file before it begins parsing.

[00:31] <sorear> ...

[00:32] <sorear> I'm getting more and more confused.  Examples?

[00:32] <quietfanatic> Hm, okay

[00:32] <quietfanatic> it needs to see lines like "name: Yadda yadda"

[00:32] <quietfanatic> but

[00:32] <tylercurtis> quietfanatic: presumably you only have some predictable set of options. In which case you could just dynamically choose one of several subclasses.

[00:32] <quietfanatic> in some files, that line will look like "#name: Yadda yadda"

[00:33] <quietfanatic> Or it could even look like "#?name: Yadda yadda

[00:33] <quietfanatic> I don't want it locked into a predefined set of formats.

[00:34] <sorear> quietfanatic: please un-handwave youir "sniffing out"

[00:34] <quietfanatic> When it reads the file

[00:34] <quietfanatic> it looks for an introductory line that says "tcml: v1.0" or something like that

[00:34] <quietfanatic> and if that line also has extra stuff around it

[00:34] <tylercurtis> rakudo: grammar Foo { has $.a; token TOP { $.a; } }; say Foo.new(a => "a").parse("a")

[00:35] <quietfanatic> like " /* tcml: v1.0 */"

[00:35] <p6eval> rakudo 369665: OUTPUT¬´===SORRY!===‚ê§Malformed regex at line 22, near "TOP { $.a;"‚ê§¬ª

[00:35] <tylercurtis> rakudo: grammar Foo { has $.a; token TOP { $!a; } }; say Foo.new(a => "a").parse("a")

[00:35] <quietfanatic> then it'll use that format for all of its parsing from then on.

[00:35] <p6eval> rakudo 369665: OUTPUT¬´===SORRY!===‚ê§Malformed regex at line 22, near "TOP { $!a;"‚ê§¬ª

[00:35] <tylercurtis> rakudo: grammar Foo { has $.a; token TOP { $.a } }; say Foo.new(a => "a").parse("a")

[00:35] <p6eval> rakudo 369665: OUTPUT¬´‚ê§¬ª

[00:35] <tylercurtis> rakudo: grammar Foo { has $.a; token TOP { $.a } }; say so Foo.new(a => "a").parse("a")

[00:35] <p6eval> rakudo 369665: OUTPUT¬´Bool::False‚ê§¬ª

[00:35] <quietfanatic> oh, .parse can be used on instantiations of the grammar and not just the class?

[00:35] <tylercurtis> rakudo: grammar Foo { has $.a; token TOP { $.a } }; say Foo.new(a => "a").a

[00:35] <p6eval> rakudo 369665: OUTPUT¬´a‚ê§¬ª

[00:35] <sorear> quietfanatic: then, you need a variable

[00:35] <quietfanatic> ooh, that is just what I wanted.

[00:36] <quietfanatic> In fact I should have tried that.

[00:36] <tylercurtis> except that it doesn't appear to work...

[00:36] <sorear> tylercurtis' example will not work in nontrivial cases

[00:36] <quietfanatic> oh

[00:36] <sorear> this, however, will

[00:36] <sorear> rakudo: my $x = "a"; grammar Foo { token TOP { $x } }; say Foo.parse("a")

[00:36] <p6eval> rakudo 369665: OUTPUT¬´a‚ê§¬ª

[00:37] <sorear> why are you using a grammar anyway?

[00:37] <tylercurtis> sorear: In fact, my example didn't even work in trivial cases. :)

[00:37] <sorear> if you only have one regex, just write it directly

[00:37] <quietfanatic> Because it's way too complex for a single regex

[00:37] <quietfanatic> The grammar is currently about 50 lines long and will eventually be several hundred.

[00:38] *** leprevost joined
[00:38] <quietfanatic> and if the grammar is in a seperate module from the routine that's calling it, using a my-scoped variable to control the grammar would be a bit difficult.

[00:39] <tylercurtis> rakudo: grammar Foo { our $x = "a"; token TOP { $x; } }; say Foo.parse("a") # I think this should work.

[00:39] <p6eval> rakudo 369665: OUTPUT¬´===SORRY!===‚ê§Malformed regex at line 22, near "TOP { $x; "‚ê§¬ª

[00:39] <tylercurtis> rakudo: grammar Foo { our $x = "a"; token TOP { $x } }; say Foo.parse("a") # I think this should work.

[00:39] <p6eval> rakudo 369665: OUTPUT¬´a‚ê§¬ª

[00:40] <sorear> quietfanatic: then use a dynamically scoped variable

[00:40] <sorear> $*opener, $*closer

[00:40] <tylercurtis> rakudo: grammar Foo { our $x = "a"; token TOP { $x } }; say Foo.parse("a"); $Foo::x = "b"; say Foo.parse("b");

[00:40] <p6eval> rakudo 369665: OUTPUT¬´a‚ê§b‚ê§¬ª

[00:40] <quietfanatic> rakudo: grammar Foo { our $x = "a"; token TOP { $x } }; $Foo::x = "b"; say Foo.parse("b")

[00:40] <p6eval> rakudo 369665: OUTPUT¬´b‚ê§¬ª

[00:40] <quietfanatic> I see

[00:40] <quietfanatic> I thought I tried using our-scoped variables, but it errored on me

[00:41] <quietfanatic> maybe it's something else that was wrong.

[00:42] <tylercurtis> sorear: To what extent would having a $x in a rule prevent optimizations of a grammar that would otherwise be possible? (I'm guessing "a large extent".)

[00:42] <quietfanatic> well, it works now.

[00:43] <quietfanatic> I don't know what was wrong before, but I'm not going to complain.

[00:43] *** aindilis` left
[00:43] *** aindilis` joined
[00:45] *** ymasory joined
[00:49] <pmichaud> seems hard to fathom that a recursive quicksort in PIR could be faster than Parrot's builtin sort.

[00:50] <pmichaud> wrong chan

[00:50] <sorear> tylercurtis: I haven't thought of any significant optimizations that having $x would significantly effect, actually

[00:50] <sorear> ARGGGHH

[00:50] <sorear> affect

[00:50] <sorear> there goes my perfect a/effect record :(

[00:51] <tylercurtis> sorear: Would it not impact LTM?

[00:51] <sorear> tylercurtis: it stops LTM outright

[00:51] <sorear> but I don't consider LTM an optimization

[00:52] *** perplexa joined
[00:52] <sorear> it has such large constant factors that I try to avoid using it

[00:52] <quietfanatic> At the most it'd just be another sequence point, right?

[00:52] <sorear> although it really comes in handy for some things

[00:52] <sorear> quietfanatic: yes

[00:53] <sorear> pmichaud: ping

[00:53] * tylercurtis realizes that he has forgotten most of what little he knew about Perl 6 LTM.

[00:54] <quietfanatic> Though I suppose if there were some more formal way of parameterizing it, it wouldn't have to be a sequence point.

[00:54] <sorear> quietfanatic: there is, but it's NYI in Rakudo

[00:54] <sorear> IIRC

[00:55] <pmichaud> sorear: pong, but heading out the door

[00:55] <sorear> 16:57 < sorear> pmichaud: I would like to hear your thoughts on OUTER.

[00:55] <pmichaud> in rakudo I think it's mostly tied to callframe

[00:56] <sorear> perl6: grammar A { token TOP { <.begin> \d+ <.end> } }; role b_e[$b,$e] { token begin { $b }; token end { $e } }; say (A but b_e["x","y"]).parse("x123y") # quietfanatic

[00:56] <p6eval> rakudo 369665: OUTPUT¬´Attempt to use rebless_subclass where the new class was not a subclass‚ê§  in 'infix:<does>' at line 7658:CORE.setting‚ê§  in 'infix:<but>' at line 634:CORE.setting‚ê§  in main program body at line 22:/tmp/mLclfct6Ev‚ê§¬ª

[00:56] <p6eval> ..pugs: OUTPUT¬´*** ‚ê§    Unexpected "[$"‚ê§    expecting "::", "-" or trait‚ê§    at /tmp/sbkzwUOlvO line 1, column 58‚ê§¬ª

[00:56] <p6eval> ..niecza v5-85-ga828415: OUTPUT¬´Unhandled exception: Unable to resolve method at-pos in class b_e‚ê§  at  line 0 (ExitRunloop @ 0)‚ê§  at /tmp/EyuEcliQcE line 1 (MAIN mainline @ 2)‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1421 (CORE C595_ANON @ 2)‚ê§  at /home/p6eval/niecza/lib/CORE.setting line

[00:56] <p6eval> ..1422 (CORE module‚Ä¶

[00:56] <pmichaud> in nom we should be able to resolve OUTER at compile time

[00:56] <sorear> perl6: grammar A { token TOP { <.begin> \d+ <.end> } }; role b_e[$b,$e] { token begin { $b }; token end { $e } }; say (A but OUR::b_e["x","y"]).parse("x123y") # quietfanatic

[00:56] <pmichaud> (that's not exactly easy to do in rakudo master at the moment)

[00:56] <p6eval> niecza v5-85-ga828415: OUTPUT¬´x123y‚ê§¬ª

[00:56] <p6eval> ..rakudo 369665: OUTPUT¬´Cannot find sub OUR::b_e‚ê§  in main program body at line 1‚ê§¬ª

[00:56] <p6eval> ..pugs: OUTPUT¬´*** ‚ê§    Unexpected "[$"‚ê§    expecting "::", "-" or trait‚ê§    at /tmp/B_Yja3Bgpf line 1, column 58‚ê§¬ª

[00:57] <sorear> quietfanatic: ^^^ more formal way to parameterize, does NOT create a LTM sequence point

[00:57] <pmichaud> anyway, I don't have any profound to say about OUTER at the moment -- it's just another pseudonamespace that the compiler has to deal with

[00:58] <pmichaud> afk, errands

[01:00] <quietfanatic> It uses the parametric role system, eh?

[01:01] *** keeth left
[01:19] *** am0c joined
[01:44] *** huf left
[01:48] *** Chillance left
[01:59] *** whiteknight left
[02:00] *** lichtkind left
[02:10] *** [particle] left
[02:11] *** [particle] joined
[02:15] *** bbkr_ left
[02:15] *** bbkr_ joined
[02:22] *** am0c left
[02:36] *** am0c joined
[02:42] *** silug joined
[02:46] *** keeth joined
[02:49] *** silug left
[02:52] *** am0c left
[02:53] *** GinoMan[A] joined
[03:06] *** am0c joined
[03:09] *** GinoMan[A] left
[03:13] *** zorgnax left
[03:23] *** GinoMan[A] joined
[03:36] *** GinoMan[A] left
[03:50] *** keeth left
[04:03] *** cdarroch left
[04:04] <dalek> rakudo: 0d3c71c | pmichaud++ | src/builtins/ (10 files):

[04:04] <dalek> rakudo: Add :subid to :vtable entries so they can be profiled via RAKUDO_SUBLOG.

[04:04] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/0d3c71cd22

[04:04] *** satyavvd joined
[04:36] <sorear> at this point I think I could be dealing with a mono bug

[04:36] *** ymasory left
[04:36] <sorear> I just added debugging code to print a hexdump of the serialized blob - and it printed a hexdump of the *recent debug messages* instead

[04:37] <benabik> sorear: Mono's a pretty bad bug.

[04:37] <sorear> hugme: hug benabik

[04:37] * hugme hugs benabik

[04:37] *** birdwindupbird joined
[04:39] <benabik> sorear: What?  I know people who had to drop out of college because of mono.

[04:40] <sorear> I still think you're trolling.

[04:40] *** GinoMan[A] joined
[04:41] <benabik> I suppose punning is a form of trolling.

[04:42] <sorear> oh, that was actual humor

[04:42] <sorear> sorry, I was getting ready to deploy the ops

[04:43] <sorear> I am so sick of RMS fanboys and their secondary targetting schemes

[04:44] <benabik> sorear: I know lots of people who can't tell when I'm being funny IRL too, so don't worry about it.

[04:44] <benabik> I don't mind mono the program...  Just never had a use for it.

[04:49] *** mtk left
[04:53] *** d4l3k_ joined
[04:54] *** stepnem left
[04:54] *** dalek left
[04:55] <sorear> nah, I take that back

[04:55] <sorear> it's OBVIOUS now that I'm looking at a Mono bug

[04:55] *** d4l3k_ is now known as dalek

[04:55] *** ChanServ sets mode: +v dalek

[04:58] <sorear> there's no way that new byte[1920] should be resulting in an array of bytes filled with what appears to be MonoObject structs

[04:59] *** mtk joined
[04:59] <sorear> I said it was filled with debug messages before.  Well, the 3 words before that were 1. the message length 2. 0 3. a data segment pointer (clearly System.String's vtable)

[04:59] *** stepnem joined
[05:01] <benabik> That does sound poor.

[05:03] *** p6eval left
[05:05] *** p6eval joined
[05:05] *** ChanServ sets mode: +v p6eval

[05:13] *** koban` joined
[05:13] <quietfanatic> Is it supposed to guarantee zero-initialization?

[05:14] <sorear> quietfanatic: actually I'm using a form with explicit initialization

[05:14] <quietfanatic> ah

[05:15] *** ymasory joined
[05:15] <sorear> I'm using the newarr opcode together with the InitializeArray runtime function

[05:16] <sorear> newarr is supposed to zero-initialize

[05:16] <sorear> the Mono JIT has a hack which suppresses zero-initialization if the array is immediately being passed to InitializeArray with a matching size

[05:19] <quietfanatic> So it seems that InitializeArray is not doing its job

[05:25] *** LaVolta joined
[05:35] <sorear> also, it only fails with the genrational GC enabled

[05:43] <dalek> niecza: af8a3f2 | sorear++ | / (4 files):

[05:43] *** leprevost left
[05:43] <dalek> niecza: Make my A::B $x work, add lots of debugging code to the blob loader

[05:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/af8a3f2780

[05:48] *** pamera joined
[05:55] *** silug joined
[05:56] *** wtw joined
[05:59] *** silug left
[06:10] <sorear> and with mono 16fc336 from earlier today... NOT REPRODUCABLE \o/ (?)

[06:11] * sorear feels slighted out of a chance to debug Mono :P

[06:13] <dalek> niecza: be60cde | sorear++ | test2.pl:

[06:13] <dalek> niecza: Test :: in parameters

[06:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/be60cdefb7

[06:14] *** wamba joined
[06:18] <sorear> perl6: sub foo(@bar) { say +@bar }; foo <a b c>;

[06:18] <p6eval> pugs, rakudo 0d3c71: OUTPUT¬´3‚ê§¬ª

[06:18] <p6eval> ..niecza v5-85-ga828415: OUTPUT¬´Unhandled exception: Excess arguments to MAIN foo, used 1 of 3 positionals‚ê§  at /tmp/M4ZOk45CMw line 0 (MAIN foo @ 0)‚ê§  at /tmp/M4ZOk45CMw line 1 (MAIN mainline @ 1)‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1421 (CORE C595_ANON @ 2)‚ê§  at

[06:18] <p6eval> ../home/p6eval/niecza/lib/CORE.setting l‚Ä¶

[06:20] <tadzik> benabik: how would people be dropped out of college because of mono?

[06:21] <tadzik> Souns like RMS being one of the proffesors

[06:21] <sorear> tadzik: benabik was punning.  https://secure.wikimedia.org/wikipedia/en/wiki/Infectious_mononucleosis

[06:23] <tadzik> hehe, I see

[06:24] *** fhelmberger joined
[06:27] *** Mowah joined
[06:28] *** ponbiki left
[06:34] <dalek> niecza: fbf986f | sorear++ | / (2 files):

[06:34] <dalek> niecza: foo <a b c> is only one formal argument

[06:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/fbf986f176

[06:37] <sorear> rakudo: say index("pie", "i")

[06:37] <p6eval> rakudo 0d3c71: OUTPUT¬´1‚ê§¬ª

[06:37] <sorear> rakudo: say index("i", "pie")

[06:37] <p6eval> rakudo 0d3c71:  ( no output )

[06:50] *** amkrankruleuen left
[06:51] *** amkrankruleuen joined
[07:01] <dalek> niecza: 6c42d59 | sorear++ | lib/CORE.setting:

[07:01] <dalek> niecza: Add index()

[07:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6c42d59819

[07:01] <dalek> niecza: 6bf4ff8 | sorear++ | / (2 files):

[07:01] <dalek> niecza: Fix build

[07:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6bf4ff8bd6

[07:04] <sorear> phenny: tell masak yapsi/niecza 52d74c6 passes all tests on niecza/master 6bf4ff8

[07:04] <phenny> sorear: I'll pass that on when masak is around.

[07:06] <sorear> currently at 56.5 changed lines

[07:08] <sorear> std: 1.^.^.^.^foo

[07:08] <p6eval> std 4b1b100: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Confused at /tmp/YRkBAt61YM line 1:‚ê§------> [32m1.^[33m‚èè[31m.^.^.^foo[0m‚ê§    expecting dotty method or postfix‚ê§Parse failed‚ê§FAILED 00:01 113m‚ê§¬ª

[07:13] *** hanekomu joined
[07:24] *** mj41 joined
[07:30] *** amkrankruleuen left
[07:33] *** quietfanatic left
[07:37] <sorear> rakudo: $*OUT.^parents(:all).say

[07:37] <p6eval> rakudo 0d3c71: OUTPUT¬´too many named arguments: 1 passed, 0 used‚ê§  in main program body at line 22:/tmp/fk3RDmbMmF‚ê§¬ª

[07:37] <sorear> rakudo: $*OUT.^parents.say

[07:37] <p6eval> rakudo 0d3c71: OUTPUT¬´Cool()Any()Mu()‚ê§¬ª

[07:37] <sorear> rakudo: $*OUT.^methods.say

[07:37] <p6eval> rakudo 0d3c71:

[07:37] <p6eval> ..OUTPUT¬´closeeofgetinslinesopenprintprintfsayreadwritegetcslurptdefslzcreatedmodifiedaccessedchangedmovechmodcopylinkautoflushpathstatNumericRealIntRatNumabsconjugateexploglog10sqrtrootsto-radiansfrom-radiansfloorceilingroundtruncatesigncisunpolarchrchrsrandsincostanseccoseccotansinhcoshta‚Ä¶

[07:37] <sorear> rakudo: $*OUT.^methods.join(", ").say

[07:37] <p6eval> rakudo 0d3c71: OUTPUT¬´close, eof, get, ins, lines, open, print, printf, say, read, write, getc, slurp, t, d, e, f, s, l, z, created, modified, accessed, changed, move, chmod, copy, link, autoflush, path, stat, Numeric, Real, Int, Rat, Num, abs, conjugate, exp, log, log10, sqrt, roots, to-radians,

[07:37] <p6eval> ..from-r‚Ä¶

[07:37] <sorear> rakudo: $*OUT.^methods(:local).join(", ").say

[07:37] <p6eval> rakudo 0d3c71: OUTPUT¬´close, eof, get, ins, lines, open, print, printf, say, read, write, getc, slurp, t, d, e, f, s, l, z, created, modified, accessed, changed, move, chmod, copy, link, autoflush, path, stat‚ê§¬ª

[07:39] <dalek> niecza: 3b56aac | sorear++ | / (2 files):

[07:39] <dalek> niecza: Implement .?

[07:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3b56aace0a

[07:39] <dalek> niecza: 9e75e8d | sorear++ | lib/CORE.setting:

[07:39] <dalek> niecza: Add first cut at $*OUT

[07:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9e75e8d3b3

[07:40] *** wamba left
[07:44] *** wamba joined
[07:46] *** amkrankruleuen joined
[07:48] <sorear> down to 37 lines changed

[07:48] *** wamba left
[07:53] <sorear> rakudo: say +[ hash a => 3, b => 5 ]

[07:53] <p6eval> rakudo 0d3c71: OUTPUT¬´2‚ê§¬ª

[08:15] *** amkrankruleuen left
[08:16] *** amkrankruleuen joined
[08:19] <dalek> niecza: b084a1e | sorear++ | / (2 files):

[08:19] <dalek> niecza: Add &hash, 1-arg .substr, .subst with Str lhs, allow assigning .kv to hashes

[08:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b084a1e555

[08:23] * sorear calls a night

[08:38] *** am0c left
[08:54] *** daniel-s joined
[08:54] *** silug joined
[08:56] <daniel-s> is there a text editor that does syntax highlighting for pir?

[08:56] *** mberends joined
[08:57] <moritz> vim does

[08:57] <moritz> there's a pir.vim in the parrot repo somewhere

[09:01] *** daniel-s_ joined
[09:03] *** daniel-s left
[09:05] *** huf joined
[09:13] *** noganex_ joined
[09:16] <jdhore1> is there any language that a syntax hilight script doesn't exist for vim?

[09:16] *** amkrankruleuen left
[09:16] *** noganex left
[09:17] *** amkrankruleuen joined
[09:19] *** awoodland joined
[09:21] <yath> jdhore1: RPG.

[09:22] <jdhore1> Actually, you're right.

[09:23] <arnsholt> jdhore1: I had to write my own syntax file for the Xerox finite state tools =)

[09:27] *** amkrankruleuen left
[09:29] *** amkrankruleuen joined
[09:31] *** Mowah_ joined
[09:35] *** amkrankruleuen left
[09:40] *** silug left
[09:42] *** snearch joined
[09:46] *** amkrankruleuen joined
[10:09] *** c1sung left
[10:16] *** c1sung joined
[10:16] *** daniel-s joined
[10:19] *** daniel-s_ left
[10:22] *** ponbiki joined
[10:27] *** LaVolta left
[10:34] *** _jaldhar left
[10:44] *** gbacon joined
[10:45] *** stepnem left
[10:47] *** stepnem joined
[10:48] *** orafu joined
[11:05] *** _jaldhar joined
[11:07] *** jaldhar_ joined
[11:10] *** _jaldhar left
[11:12] *** wamba joined
[11:18] *** pernatiy left
[11:19] *** ab5tract joined
[11:27] *** jaldhar_ left
[11:28] *** wamba left
[11:28] *** jaldhar_ joined
[11:29] *** wamba joined
[11:33] *** og01 left
[11:33] *** satyavvd left
[11:33] *** donri joined
[11:39] *** wamba left
[12:08] *** wknight8111 joined
[12:13] *** Mowah left
[12:14] *** Mowah_ left
[12:15] *** hanekomu left
[12:17] *** pernatiy joined
[12:17] *** wamba joined
[12:21] *** amkrankruleuen left
[12:22] *** amkrankruleuen joined
[12:23] *** silug joined
[12:26] *** ab5tract left
[12:28] *** silug left
[12:29] *** silug joined
[12:31] *** birdwindupbird left
[12:33] *** silug left
[12:41] *** satyavvd joined
[12:42] *** Holy_Cow joined
[12:42] *** Holy_Cow left
[12:59] *** birdwindupbird joined
[13:00] *** ymasory left
[13:01] *** ab5tract joined
[13:02] *** pamera left
[13:06] *** donri left
[13:06] *** donri joined
[13:24] <daniel-s> hello

[13:24] <daniel-s> anyone around?

[13:24] <takadonet> daniel-s: yo

[13:25] <daniel-s> hey

[13:25] <daniel-s> what are you up to?

[13:26] <daniel-s> also, you know grammers and defining regex rules in perl6, is that all new to perl6 compared to 5?

[13:26] <sbp> yep. that and most of the rest of the language... :-)

[13:26] <sbp> try http://perl6advent.wordpress.com/ for an overview of some differences

[13:27] <sbp> might also find http://rosettacode.org/wiki/Category:Perl_6 useful for direct comparisons

[13:27] <takadonet> daniel-s: In p5 regular expression are just string in P6 they are soo much more

[13:27] *** wamba left
[13:27] <sbp> oh sorry, I think I misunderstood your question now that I read it back

[13:28] <sbp> most of the grammar and regular expression stuff is changed beyond recognition, yes, if that was your question

[13:28] <sbp> you can still bootstrap perl5 regexps into perl6 though if you so want

[13:30] *** [Sec] joined
[13:32] <[Sec]> Maybe I'm just stupid. I want to print all "odd-numbered" elements from an aerray, but neither @a[1,3 ... *] nor @a[1,*+2..+@a] work for me?

[13:33] *** bacek left
[13:34] *** JimmyZ_ joined
[13:34] <sbp> rakudo: say [1, 3 ... 15].join(", ")

[13:34] <p6eval> rakudo 0d3c71: OUTPUT¬´1, 3, 5, 7, 9, 11, 13, 15‚ê§¬ª

[13:34] <sbp> hmm, lemme think

[13:36] *** daxim_ left
[13:39] *** Chillance joined
[13:40] <sbp> rakudo: for [1, 3 .. 7] { say <a b c d e f g h i j k>[$_] }

[13:41] <p6eval> rakudo 0d3c71: OUTPUT¬´bdefgh‚ê§¬ª

[13:41] <sbp> [Sec]: how's that?

[13:41] <sbp> (zero based of course)

[13:41] <sbp> er, and with ... instead of .. of course too

[13:41] <sbp> rakudo: for [1, 3 ... 7] { say <a b c d e f g h i j k>[$_] }

[13:41] <p6eval> rakudo 0d3c71: OUTPUT¬´bdfh‚ê§¬ª

[13:42] <sbp> le typo magnifique

[13:42] <sbp> wonder if it works lazily

[13:42] <sbp> rakudo: for [1, 3 ... *] { say <a b c d e f g h i j k l m n o p>[$_] }

[13:42] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[13:42] <sbp> nope

[13:42] *** wamba joined
[13:43] <sbp> rakudo: say <a b c d e f g h i j k>[$_] for [1, 3 ... 7]

[13:43] <p6eval> rakudo 0d3c71: OUTPUT¬´bdfh‚ê§¬ª

[13:44] <[Sec]> sbp: it just doesn't return for me

[13:45] <sbp> hmm?

[13:45] <[Sec]> rakudo: my @a=<<eins zwei drei vier fuenf sechs>>;say @a[1,3 ... +@a].perl

[13:45] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[13:45] <JimmyZ_> rakudo: say (gather for 1, 3 ... * { take <a b c d e f g h i j k l m n o p>[$_] })[2]

[13:46] <p6eval> rakudo 0d3c71: OUTPUT¬´f‚ê§¬ª

[13:46] <JimmyZ_> rakudo: say (gather for 1, 3 ... * { take <a b c d e f g h i j k l m n o p>[$_] })[1,3,7]

[13:46] <p6eval> rakudo 0d3c71: OUTPUT¬´dhp‚ê§¬ª

[13:46] <JimmyZ_> rakudo: say (gather for 1, 3 ... * { take <a b c d e f g h i j k l m n o p>[$_] })[1,3,4]

[13:47] <p6eval> rakudo 0d3c71: OUTPUT¬´dhj‚ê§¬ª

[13:47] * JimmyZ_ thinks it works lazily

[13:48] <sbp> thanks JimmyZ_

[13:48] <JimmyZ_> rakudo: say (gather for 1, 3 ... * { take <a b c d e f g h i j k l m n o p>[$_] })[100]

[13:48] <p6eval> rakudo 0d3c71: OUTPUT¬´Any()‚ê§¬ª

[13:49] <JimmyZ_> rakudo: my @a; say @a[100];

[13:49] <p6eval> rakudo 0d3c71: OUTPUT¬´Any()‚ê§¬ª

[13:49] * JimmyZ_ wonders whether it's a bug or not.

[13:49] <[Sec]> rakudo: my @a=<<eins zwei drei vier fuenf>>;say @a[1,3 ... +@a].perl

[13:49] <p6eval> rakudo 0d3c71: OUTPUT¬´("zwei", "vier", Any)‚ê§¬ª

[13:50] <[Sec]> with odd number of elements, it works, with even, it hangs.

[13:50] *** foomator joined
[13:50] <foomator> hi

[13:50] <[Sec]> well, works is rleative. I get "Any" appended. But at least it does something.

[13:51] <foomator> da sec :)

[13:51] <sbp> rakudo: my @a = <eins zwei drei vier fuenf sechs>; say @a[1, 3 ... 5].perl

[13:51] <p6eval> rakudo 0d3c71: OUTPUT¬´("zwei", "vier", "sechs")‚ê§¬ª

[13:51] <sbp> I dunno why it works with 5 but not +@a

[13:51] <sbp> rakudo: my @a = <eins zwei drei vier fuenf sechs>; say @a[1, 3 ... 6].perl

[13:51] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[13:52] <sbp> guess it does screw up the arithmetic progression generator

[13:52] *** snearch left
[13:52] <sbp> rakudo: say [1, 3 ... 5].perl

[13:52] <p6eval> rakudo 0d3c71: OUTPUT¬´[1, 3, 5]‚ê§¬ª

[13:52] <sbp> rakudo: say [1, 3 ... 6].perl

[13:52] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[13:53] <sbp> there's a reduced testcase

[13:53] <[Sec]> was about to paste exactly that :)

[13:53] *** ponbiki left
[13:55] <colomon> 1, 3 ... 6 is the same as 1, 3 ... *

[13:55] <colomon> you have to hit the terminating value exactly to terminate

[13:56] <colomon> you probably want something like 1, 3 ... * > 4

[13:56] <[Sec]> so there is currently no nice way to select all odd elements in an array?

[13:56] <colomon> The final "Any" above is actually a Rakudo bug, I think

[13:56] <sbp> rakudo: my @a = <eins zwei drei vier fuenf sechs>; say @a[1, 3 ... * > +@a].perl

[13:56] <p6eval> rakudo 0d3c71: OUTPUT¬´("zwei", "vier", "sechs", Any)‚ê§¬ª

[13:56] <colomon> rakudo: my @a=<<eins zwei drei vier fuenf>>;say (1,3 ... +@a).perl

[13:56] <p6eval> rakudo 0d3c71: OUTPUT¬´(1, 3, 5)‚ê§¬ª

[13:57] *** jaldhar_ left
[13:57] <JimmyZ_> rakudo: my @a=<<eins zwei drei vier fuenf>>;say +@a;

[13:57] <p6eval> rakudo 0d3c71: OUTPUT¬´5‚ê§¬ª

[13:57] <colomon> @a[5] = Any, but I think it's supposed to be automatically ignored if it's @a[1, 3, 5]

[13:58] *** daniel-s left
[13:58] <colomon> I think what you're looking for is probably more like

[13:58] <colomon> rakudo: my @a = <eins zwei drei vier fuenf sechs>; say @a[1, 3 ...^ * >= +@a].perl

[13:58] <p6eval> rakudo 0d3c71: OUTPUT¬´("zwei", "vier", "sechs")‚ê§¬ª

[13:58] <colomon> rakudo: my @a = <eins zwei drei vier fuenf sechs>; say @a[0, 2 ...^ * >= +@a].perl

[13:58] <p6eval> rakudo 0d3c71: OUTPUT¬´("eins", "drei", "fuenf")‚ê§¬ª

[13:59] <[Sec]> colomon: yay!

[13:59] <[Sec]> @a[1,3...*] would've been nice, though. :)

[14:00] <JimmyZ_> rakudo: my @a=<<eins zwei drei vier fuenf>>;say @a[1,3 ... (+@a-1)].perl

[14:00] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[14:00] <colomon> [Sec]: I'm not sure @a[1, 3 ... *] will ever work, because the series there is infinite.

[14:01] <sbp> is this step stuff taken from haskell?

[14:01] <foomator> why shouldn't it work?

[14:01] <colomon> even if we were smart enough to ignore values over +@a, there's still an infinite number of those values to ignore

[14:01] <[Sec]> colomon: but the array isn't, and the series should be lazy?

[14:02] <colomon> the sequence is lazy, but we're still going to ask for an infinite number of terms from it.

[14:02] <foomator> hm, according to what i heard yesterday it should work afair

[14:03] <colomon> I mean, it's obvious to us that once the sequence is past +@a, it's never going to be less than +@a again. 

[14:03] <colomon> but that's not obvious to the compiler

[14:03] <foomator> the array implementation should know how to handle the range, shouldn't it?

[14:03] <JimmyZ_> sbp: I dunno why it works with 5 but not +@a #because the last elems is +@a - 1

[14:03] <colomon> It's not a range, it's a sequence.

[14:03] <colomon> If it were a range, it should work, yes.

[14:03] <foomator> gotcha :)

[14:04] <colomon> @a[1..*] should work

[14:04] <colomon> In fact...

[14:04] <colomon> rakudo: my @a = <eins zwei drei vier fuenf sechs>; say @a[2..*].perl

[14:04] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[14:04] <colomon> urk.  well, that definitely should work

[14:05] <colomon> but @a[2...*] shouldn't.  Or at least, will require a much more sophisticated framework to handle

[14:06] <[Sec]> colomon: i might be spoiled from playing with functional languages which "just manage" this correctly %)

[14:08] <colomon> are there functional languages that have array slicing?

[14:10] <[Sec]> colomon: no. but stopping on lazy list evaluation when no more elements will match :)

[14:11] <sbp> perl6: my @a = <eins zwei drei vier fuenf sechs>; say @a[2..*].perl

[14:11] <JimmyZ_> rakudo: my @a=<<eins zwei drei vier fuenf>>; say @a[1,3 ... ((+@a)-1)].perl # why time out?

[14:12] <p6eval> rakudo 0d3c71, niecza v5-93-gb084a1e: OUTPUT¬´(timeout)¬ª

[14:12] <p6eval> ..pugs: OUTPUT¬´("drei", "vier", "fuenf", "sechs")‚ê§¬ª

[14:12] <p6eval> rakudo 0d3c71: OUTPUT¬´(timeout)¬ª

[14:12] *** MayDaniel joined
[14:12] <colomon> JimmyZ_: +@a - 1 == 4.  1, 3 ... 4 is an infinite sequence

[14:13] <JimmyZ_> oh

[14:13] <colomon> [Sec]: errr... that's not even theoretically possible in the general case, is it?  it's the halting problem. 

[14:14] <colomon> obviously it's possible in simpler cases...

[14:16] *** zamolxes left
[14:17] <JimmyZ_> rakudo: my @a=<<eins zwei drei vier fuenf a b c>>; say @a[1,3 ... @a - 1 ].perl

[14:17] <p6eval> rakudo 0d3c71: OUTPUT¬´("zwei", "vier", "a", "c")‚ê§¬ª

[14:22] *** wtw left
[14:23] *** buubot_backup left
[14:33] *** mberends left
[14:36] *** kaare_ joined
[14:36] *** dual left
[14:42] *** kjeldahl joined
[14:45] *** ymasory joined
[14:46] *** buubot_backup joined
[14:51] *** koban` left
[14:52] *** MayDaniel left
[14:55] *** kjeldahl left
[14:57] *** hercynium joined
[15:03] *** mkramer1 joined
[15:05] *** mkramer1 left
[15:05] *** mkramer1 joined
[15:07] *** silug joined
[15:08] *** ab5tract left
[15:12] *** silug left
[15:12] *** silug joined
[15:18] *** mkramer1 left
[15:24] *** silug left
[15:25] *** silug joined
[15:31] *** silug left
[15:31] *** silug joined
[15:33] *** JimmyZ_ left
[15:33] *** JimmyZ__ joined
[15:35] *** molaf joined
[15:37] *** envi joined
[15:45] *** thou joined
[15:46] *** silug left
[15:46] *** bluescreen10 joined
[15:47] *** MayDaniel joined
[15:47] *** silug joined
[15:48] *** JimmyZ__ left
[15:49] *** mberends joined
[15:51] *** ymasory left
[15:51] *** silug left
[15:51] *** silug joined
[15:52] *** mj41 left
[16:05] <sorear> colomon: it ought to work

[16:05] <colomon> sorear: what ought to work?

[16:05] <sorear> S09:218

[16:05] <sorear> @array[1,3...*]

[16:06] <sorear> the operative word here is "truncated"

[16:06] <sorear> as opposed to "filtered"

[16:06] <sorear> this means that after the first invalid subscript, it does a last;

[16:06] <colomon> ah

[16:06] *** tomaw left
[16:07] <sorear> does anyone else think masak has been out an uncharacteristically long time?

[16:07] <colomon> agreed on masak

[16:07] *** silug left
[16:08] <colomon> sorear: where do you something suggesting "truncated" is allowed to work the way you suggest?  (I mean, what you suggest makes sense, but I'm not sure I understand where it actually says that in the spec.)

[16:09] *** molaf left
[16:11] <colomon> sorear: specifically, it looks to me like that section was written for ranges (which always increment, and are thus trivial to truncate), and then someone added "sequence" to it without clarifying any of the sequence-specific things.

[16:12] <colomon> or putting it a different way, it seems to me we should be modifying the spec so that it (more?) explicitly says what you are claiming it does say.  :)

[16:13] <colomon> and not just for sequences -- for any list argument to [ ]

[16:13] <sorear> probably I got it from truncate(2)

[16:14] <sorear> which removes bytes from the end of files, never the middle

[16:14] <sorear> it might even be in a real dictionary, I dunno

[16:17] *** GinoMan[A] left
[16:19] *** tomaw joined
[16:31] *** MayDaniel left
[16:32] *** kjeldahl joined
[16:32] <dalek> niecza: 18545a8 | sorear++ | src/niecza:

[16:32] <dalek> niecza: Fix /< foo bar >/

[16:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/18545a8ca5

[16:33] *** kaare_ left
[16:35] <mberends> It is interesting that the software interpretations of "truncate" all drift around minimizing, fixing or setting some variable length, which has drifted some way from the original "eliminate branches" (keep only trunk) concept.

[16:36] <mberends> http://en.wiktionary.org/wiki/truncate

[16:36] <sorear> mberends: consider the truncated icosahedron

[16:36] <mberends> yep, that's the classic meaning

[16:38] <PerlJam> mberends: consider perldoc -f truncate  #  :-)

[16:39] <mberends> PerlJam: that one at least reduces, the Unix one is emulates will even lengthen a file :/

[16:39] <PerlJam> perhaps if it had been called "entrunken" or something, the meaning wouldn't have been diluted.

[16:40] <thou> sorear: does your announcement up there mean that niecza is feature complete (as defined by the roast test suite)?

[16:41] <sorear> thou: no

[16:42] <sorear> thou: yapsi is a Perl 6 app with its own tests (about 100 of them)

[16:42] <sorear> yapsi was developed for Rakudo alpha; I just got it to work in niecza yesterday

[16:44] <mberends> .oO( don't use SQL data types in C. There is no 'unsigned small' ) :P

[16:45] *** pernatiy left
[16:46] <thou> sorear: ah, OK, got it. thanks.

[16:48] *** fhelmberger left
[16:51] <sorear> mberends: did you do that?

[16:51] *** dual joined
[16:52] <sorear> my main problem seems to be writing Vector<int> in C# and std::list<int> in C++

[16:52] <mberends> sorear: just finished $work on SQL server and then switched to developing a bigint library for  Perlduino.

[16:53] <sorear> can't just use bigint.pm?

[16:53] <mberends> nope, I have severe NIH syndrome

[16:55] <mberends> add and multiply are done and tested, next will be subtract and divide

[16:55] <sorear> how fancy is it?

[16:57] <mberends> small^Wshort int arrays, very streamlined, pure C, max capacity +/- 2^524272.

[16:58] <mberends> and prettier source code than that C# one you just pasted into niecza ;)

[16:59] <sorear> I mean more like, does it know about subquadratic division?

[17:00] <mberends> no, long multiplication and long division algorithms (this is destined to cross compile to tiny 8 bit CPU's).

[17:03] *** satyavvd left
[17:04] <mberends> I hope implementing a bigrat library on top of bigint will not be too hard.

[17:04] *** cdarroch joined
[17:04] *** cdarroch left
[17:04] *** cdarroch joined
[17:05] *** birdwindupbird left
[17:10] *** masak joined
[17:11] <masak> hola, zebry.

[17:11] <phenny> masak: 07:04Z <sorear> tell masak yapsi/niecza 52d74c6 passes all tests on niecza/master 6bf4ff8

[17:11] <mberends> o/ masak!  We were missing you!

[17:11] <colomon> masak!

[17:11] * masak is... *drum roll* ...on a train

[17:11] <mberends> !!

[17:11] <masak> sorear: wow!

[17:12] <masak> well, guys. I've missed you too ;)

[17:13] <masak> the backside of the coin of a terribly successful life is that one's time gets more limited :P

[17:13] <dalek> niecza: 7745f0d | sorear++ | / (2 files):

[17:13] <dalek> niecza: repeat, until, while, unless take pointy blocks

[17:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7745f0d606

[17:13] * masak <-- happy bevause a course he taught went well

[17:13] *** ymasory joined
[17:13] <sorear> It's MASAK!

[17:13] <sorear> I was just beginning to wonder/worry about you :D

[17:14] <masak> sorear: congratulations on making yapsi/niecza work!

[17:14] *** Moukeddar joined
[17:15] <Moukeddar> Hello Perl6 \∞

[17:15] <masak> Moukeddar, sir!

[17:15] <sorear> HI Moukeddar!

[17:15] <Moukeddar> it's been a while

[17:15] <Moukeddar> how are you all doing?

[17:16] <sorear> awesome

[17:16] <sorear> finals ended yesterday

[17:16] <PerlJam> masak: hey!  how's it going?  (besides happy :)

[17:16] <Moukeddar> me getting started in learning UML clarified a lot of things :)

[17:17] <masak> PerlJam: tired ;)

[17:17] <masak> I miss Perl 6. and #perl6. :)

[17:17] <PerlJam> Moukeddar: was one of those things "don't use UML"?

[17:17] <Moukeddar> i wasn't , i just didn't get to really understand how important it is

[17:17] <masak> Moukeddar: don't pay too much attention to UML, IMO. just learn what you need, and move on to actual stuff.

[17:17] * masak is liberal with advice :P

[17:18] <colomon> sorear: assuming you're correct on what is meant by truncate, what do you do if you are using @a[1..*] as an lvalue?

[17:18] <masak> Moukeddar: ...not terribly important. :P

[17:18] <Moukeddar> masak, that's exactly what i'm doing , learning what'll be usefull to me

[17:18] <sorear> colomon: replaces the array's contents but doesn't change its length

[17:18] <sorear> colomon: unassigned values become Any, excess values are discarded

[17:18] <masak> I haven't been this behind with backlogging in I don't know how long.

[17:19] *** jaldhar_ joined
[17:20] <Moukeddar> masak, any book on how to alanylse real world problems ?

[17:21] <colomon> sorear: "(When used as an lvalue, any non-existent subscripts generate WHENCE proxies that can receive new values and autovivify anything that needs it.)"  That sounds to me like changing the length is allowed?

[17:21] <Moukeddar> and apply design patterns while designing the solution

[17:21] <Moukeddar> analyse*

[17:21] <colomon> rakudo: my @a = 1..10; @a[2,3,4] = <a b c>; say @a.perl

[17:21] <p6eval> rakudo 0d3c71: OUTPUT¬´[1, 2, "a", "b", "c", 6, 7, 8, 9, 10]‚ê§¬ª

[17:21] <sorear> colomon: that line is impossible

[17:22] <colomon> sorear: why?

[17:22] * colomon has a deer in his backyard

[17:23] <sorear> because 1. it would require expressions to know if they are lvalues 2. it would require creating an infinitely large Parcel with an infinite number of WHENCes

[17:23] * Moukeddar prepares for some Deer Hunt

[17:23] <colomon> oh, that line of the spec, you mean?

[17:24] <sorear> yes

[17:25] *** masak left
[17:25] <colomon> okay, then I'm going to try to implement truncating in Rakudo and see what I break.  :)

[17:25] <colomon> oh, ack, what a minute.

[17:26] <PerlJam> sorear: I don't think so ... it could generate a WHENCE generator that lazily fills the parcel as needed  

[17:26] <colomon> *wait

[17:26] <PerlJam> :-)

[17:26] <sorear> PerlJam: parcels are not lazy.

[17:26] <sorear> s/^/Nice try, but /

[17:27] <colomon> sorear: does it ever say @a[blah] returns a parcel?

[17:28] <colomon> rakudo: my @a = 1..*; @a[2,3,4] = <a b c>; say @a[^10].perl

[17:28] <p6eval> rakudo 0d3c71: OUTPUT¬´(1, 2, "a", "b", "c", 6, 7, 8, 9, 10)‚ê§¬ª

[17:28] <sorear> it's the only way to make list assignment work.

[17:28] <colomon> yeah, that's the catch with the sorear++ solution

[17:31] <colomon> (the catch: either the array or the slice might be infinite.  if I naively check subscript members against the length of the array, I might trigger an infinite loop getting that length)

[17:32] <sorear> IIRC you can do something like !pir::isnull($array!fill(1000)) which will return true iff $array has >=1000 elements

[17:33] <sorear> been a while since I hacked on the Rakudo list guts though

[17:33] *** masak joined
[17:33] <colomon> unfortunately, postcircumfix:<[ ]>(@pos) is on Any, not Array

[17:34] *** stephanepayrard_ left
[17:34] <colomon> hmmm... maybe that's not a stopping point, though

[17:34] <masak> trains. they move in and out of the Internet.

[17:35] <mberends> Moukeddar: before you practically program a computer, you will only know what others write about programming and you will learn very little that is usable. After you regularly program a computer, you will see which theoretical information is useful to you, but your practical experience will have a far higher value.

[17:35] <colomon> rakudo: my $a = 10; say $a[0]

[17:35] <p6eval> rakudo 0d3c71: OUTPUT¬´10‚ê§¬ª

[17:35] <masak> Moukeddar: what mberends said.

[17:35] <colomon> rakudo: my $a = 10; say $a[100]

[17:35] <p6eval> rakudo 0d3c71:  ( no output )

[17:35] <colomon> rakudo: my $a = 10; say $a[100].perl

[17:35] <p6eval> rakudo 0d3c71: OUTPUT¬´undef‚ê§¬ª

[17:35] <masak> Moukeddar: I reached for something similar, but mberends got there before me and said it better, too. :)

[17:35] <colomon> rakudo: my $a = 10; say $a[100].WHAT

[17:36] <p6eval> rakudo 0d3c71: OUTPUT¬´Failure()‚ê§¬ª

[17:36] * masak would be hard pressed to recommend a Patterns book

[17:36] * mberends is not in a train

[17:36] <Moukeddar> let me see if i get your point , i have to get into the business ?

[17:37] * colomon is inclined to agree with the folks who argue that Patterns are basically attempts to work around major holes in some popular programming languages.

[17:37] <Moukeddar> colomon, your idea is quite familial

[17:37] <masak> I'm more of a "classics" guy: TAoCP, SICP, Little Schemer...

[17:38] <Moukeddar> so design patterns are useless or what ?

[17:38] *** masak left
[17:38] <PerlJam> colomon: yes and no.  Patterns aren't meant to be some kind of "universal answer", they're just "stuff that works when you it"

[17:38] *** masak joined
[17:38] <PerlJam> sometimes you need it because your programming environment has some shortcoming or other.

[17:39] <Moukeddar> i'm very aware that design patterns can't be used anywhere and anytime

[17:39] <PerlJam> It's the *idea* of patterns that is really important IMHO

[17:39] <Moukeddar> but they're good to learn , right?

[17:40] <PerlJam> Moukeddar: common solutions to common problems?  Absolutely!

[17:41] <Moukeddar> good, so i'm on the right way ,still , i think i didn't quite get what Mr mberends meant , can someone rephrase it ?

[17:41] <mberends> Moukeddar: they might help you only later in your learning curve, because you should understand quite a lot of the concrete implementations that the patterns describe. (more)

[17:41] *** masak left
[17:41] <sorear> Moukeddar: (familial) Did you mean "familiar"?

[17:41] *** masak joined
[17:42] <Moukeddar> mberends, so the patterns are the tree that hides the forest right ?

[17:42] <PerlJam> Moukeddar: no

[17:42] <colomon> http://hackerne.ws/item?id=2291417

[17:42] <Moukeddar> sorear, yes familiar , French syndrom :p

[17:42] * sorear needs to learn that soonish

[17:42] <mberends> Moukeddar: for example, there are many ways of sorting data. You will appreciate the theory of sorting much, much better if you try to write a few sort routines yourself.

[17:43] <Moukeddar> sorear, no rush , learn it for romance :p

[17:43] <Moukeddar> mberends, i got me a book called 

[17:43] <Moukeddar> wait a sec

[17:43] <Moukeddar> Introduction to Algorithms

[17:43] <Moukeddar> it has all this stuff

[17:43] <PerlJam> and if you study big-O notation you'll appreciate that you can sometimes use a bubble sort (because it's the only algorithm you can remember for sorting) in an environment where there is no built-in sorting routines

[17:44] <mberends> +1

[17:44] <masak> Moukeddar: I like both reading theory/principles, and trying out things in practice. I think mberends++' point is something like doing the latter with make you appreciate the former more fully.

[17:44] <masak> if that's his point, I agree fully. :)

[17:44] <masak> toying around with Perl 6 has taught me loads about languages and compilers.

[17:44] <masak> Moukeddar: is it red, white and green on the outside?

[17:45] <Moukeddar> masak, it's CHM , books are like Aids cure here :p

[17:46] <pmichaud> good afternoon, #perl6

[17:46] <Moukeddar> so ,what you say is learn what's under the hood right ?

[17:46] <colomon> pmichaud: good afternoon!

[17:46] <masak> Moukeddar: I should ask: is it this one? http://www.amazon.com/Introduction-Algorithms-Thomas-H-Cormen/dp/0262033844/

[17:46] <masak> pmichaud: \o

[17:46] <Moukeddar> like all the algorithms and data structures

[17:46] <colomon> pmichaud: and I was just poking through your code....

[17:46] <PerlJam> Moukeddar: as much as you can, yes.

[17:46] <Moukeddar> understood , that was my plan for this summer :)

[17:47] <Moukeddar> masak, that's the one :)

[17:47] <Moukeddar> is it good ?

[17:47] <masak> Moukeddar: I've never learned an algorithm or data structure and then thought "OH NOES! why did I learn *that*?". (barring, perhaps, AVL trees.)

[17:47] <masak> Moukeddar: yes, it's quite alright.

[17:47] <masak> Moukeddar: I haz it. I come back to the section on graphs quite a lot, because I like its explanations about graph algorithms.

[17:47] <Moukeddar> lol masak 

[17:47] <Moukeddar> i have a long way to go :)

[17:48] <masak> Moukeddar: have you seen ufo? it uses a topological sort from that book ;)

[17:48] <colomon> pmichaud: in particular, trying to figure out how to make @a[1, 3 ... *] work

[17:49] <Moukeddar> masak, i haven't started reading yet , i'm just collecting resources and preparing for the exams

[17:49] <Moukeddar> my internet subscription will end this month

[17:51] <Moukeddar> this sucks

[17:52] <pmichaud> colomon: I've been round-and-round with TimToady many times about truncation of subscript indexes

[17:52] <pmichaud> it's still not resolved, afaict

[17:52] *** ymasory left
[17:52] <masak> PerlJam: I explained patterns yesterday and this morning. I gave the example of, instead of giving 75 detailed steps of how I moved through town, just being able to say "I went to work". that's a pattern, focusing on some things and clearing away innessentials.

[17:52] <colomon> pmichaud: sorear and I were discussing it, and I'm reasonably happy with his suggestion... though maybe I'm missing something

[17:53] <pmichaud> I backlogged, but might've missed it, so give me the latest version of his suggestion :-)

[17:53] <PerlJam> masak: excellent!

[17:53] <masak> PerlJam: also, good pattern descriptions tend to contain a "Forces" section, describing what'd make you want to use the pattern, and what'd make you avoid using it.

[17:53] <masak> humble, self-deprecating patterns :)

[17:54] <Moukeddar> lol

[17:54] <PerlJam> masak: it's that crazy "designs don't live in a vacuum" thing  :)

[17:54] <Moukeddar> self what?

[17:54] <colomon> pmichaud: his notion (as I understand it, anyway) is  that as you process @pos (in postcircumfix:<[ ]>(@pos)), once you hit an index which is outside the current range of the array, you stop.

[17:54] <masak> Moukeddar: the patterns contain instructions on when not to use them. that's very self-deprecating.

[17:55] <pmichaud> doesn't work for lvalues

[17:55] <pmichaud> my @a;  @a[5] = 'hello';

[17:55] <masak> PerlJam: yes, that's what makes every new project... new and interesting :)

[17:55] <Moukeddar> lol , things like that exist?

[17:55] <Moukeddar> when to no use?

[17:56] <masak> Moukeddar: you said that you understood that patterns are not to be used all the time. this is just an example of the patterns containing that information.

[17:56] <colomon> pmichaud: understood, and I don't know how to resolve that.

[17:56] <pmichaud> I know that TimToady already decided once before that truncating on first non-existing wouldn't work in the lvalue case.

[17:56] <sorear> colomon: you only stop when the current index came from a range or sequence

[17:56] <pmichaud> (Looking fr the reference now)

[17:57] <pmichaud> sorear: you don't always know that it comes from a range or sequence

[17:57] <Moukeddar> i meant ,"with only not to use cases"?

[17:57] <Moukeddar> what about  when to use :p

[17:57] <PerlJam> I'm (still) of the opinion that software systems need to be built with the idea of some sort of periodic-ish review process to make sure that, say, 5 years after its been in production, the conditions under which is was designed are still valid and useful.

[17:57] *** lumi_ left
[17:57] <colomon> sorear: I'd argue that should be anything @-ish, not just ranges and sequences

[17:57] <masak> Moukeddar: no, it's generally both. :)

[17:58] <colomon> anything iterable with more than one element?  I'm not sure the best way to say that.

[17:58] <masak> PerlJam: what you just said was basically on slide 2 of yesterday's class :P

[17:58] <pmichaud> note that a parcel can be iterable and have more than one element.

[17:59] <Moukeddar> interesting talk

[17:59] <pmichaud> TimToday has said that ranges are supposed to autotrim.  He's never explained how.

[17:59] <dalek> niecza: 673862f | sorear++ | src/ (4 files):

[17:59] <dalek> niecza: Mergeback, start on is copy

[17:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/673862f457

[17:59] <dalek> niecza: 5967651 | sorear++ | / (5 files):

[17:59] <dalek> niecza: Implement 'is copy'

[17:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/59676515ac

[18:00] <colomon> pmichaud: ranges and sequences, as I read the current spec

[18:00] <masak> PerlJam: or rather, that it's an architect's role to look not just at the situation now, but to anticipate concerns 1, 5, or 10 years into the future.

[18:00] <pmichaud> colomon: yes, but I've come up with examples using ranges and sequences that obviously can't autotrim

[18:00] <pmichaud> I think the latest version was that the subscript autotrims if @pos is detectably infinite

[18:01] <masak> pmichaud: do you have such an example handy?

[18:01] <colomon> pmichaud: using ranges?  really?  other than the case where the @array[ ] is infinite?

[18:01] <pmichaud> colomon: yes, using ranges.

[18:01] <PerlJam> masak: yep.  (and since we can't actually predict the future with 100% accuracy, when 5 or 10 years in the future becomes "now", we should revisit our designs)

[18:01] <pmichaud> colomon: because it's pretty clear that   my @a;  @a[0..5] = $IN.lines;   should grab six lines.

[18:02] <masak> PerlJam: full ACK.

[18:02] *** pernatiy joined
[18:02] <pmichaud> people would be very surprised if  @a[0..5]  doesn't work the same as @a[0,1,2,3,4,5]

[18:02] <masak> rakudo: say "hello pernaity!"

[18:02] <p6eval> rakudo 0d3c71: OUTPUT¬´hello pernaity!‚ê§¬ª

[18:02] <colomon> pmichaud: considering how easy it is to say $IN.lines[^6], I'd certainly be willing to throw that one under the bus.

[18:02] <tadzik> masak o/

[18:02] <masak> tadzik: \o!

[18:03] <PerlJam> colomon: waterbed

[18:03] <colomon> pmichaud: yeah, I'm arguing @[0, 1, 2, 3, 4, 5] shouldn't work either.  :)

[18:03] <pmichaud> colomon: my @a;  @a[0..5] = ($IN.lines, $IN2.lines);

[18:03] <masak> PerlJam: you can't throw things under a waterbed :P

[18:03] <PerlJam> colomon: (you've just moved the problem around)

[18:03] <pmichaud> and $IN.lines[^6]  doesn't solve the case I just gave.

[18:03] <PerlJam> masak: clearer? :)

[18:03] <colomon> pmichaud: does ($IN.lines, $IN2.lines)[^6] not work?

[18:03] <pmichaud> namely, that of assigning to the first six elements of @a.

[18:04] <pmichaud> colomon: doesn't matter.  The subscript is on @a, not on $IN.

[18:04] <masak> PerlJam: I'm overjoyed with explanation. :)

[18:04] <pmichaud> my @a;  ... ;   @a = $IN.lines[^6]    is certainly not the same as   @a[^6] = $IN.lines;

[18:04] <pmichaud> (the first truncates @a if it already had more than six elements)

[18:05] <PerlJam> yeah, I'd be surprised if the rest of @ disappeared

[18:05] <PerlJam> er, @a

[18:05] <colomon> ah, true

[18:05] <masak> me too.

[18:05] <masak> I think we've established once before that we have a set of irreconcilable wishes in this area.

[18:06] <pmichaud> TimToady: there's supposed to be some way of asking an iterator if it's *ish, but rakudo doesn't do that yet, afaik

[18:06] <pmichaud> sorry

[18:06] <pmichaud> that's supposed to be a quote, not a request

[18:06] <colomon> masak++

[18:06] <pmichaud> (cut/paste fail)

[18:06] <pmichaud> http://irclog.perlgeek.de/perl6/2011-02-08#i_3267485

[18:06] <PerlJam> masak: That's why we have a language designer make the hard decisions for us  :)

[18:06] <masak> PerlJam: I wish him all the best in this case ;)

[18:07] <pmichaud> the 2011-02-08 repeats the notion that we have to be able to ask an iterator for *-ishness in order to determine when we truncate

[18:08] <masak> someone should write the irreconcilable wishes down, so that we can look at them and take a pick.

[18:08] <Moukeddar> anyone here had a experience with the one-man Army case?

[18:08] <pmichaud> which means that iterators have to figure it out somewhat transitively or lazily, since  we can't know from   @a[foo(), bar(), baz()]   which if any of the things returned are *-ish

[18:08] *** mkramer joined
[18:08] <Moukeddar> where you have to do everything

[18:09] <colomon> Moukeddar: you mean, to put together a program?

[18:09] <masak> Moukeddar: I'm not sure why you're asking that here. :)

[18:09] *** pmurias joined
[18:09] <pmichaud> anyway, the idea that subscripts stop upon encountering the first non-existent element has been nixed already.

[18:09] <masak> Moukeddar: sounds more like hiring issue than a programming issue.

[18:09] <Moukeddar> hiring?

[18:09] <Moukeddar> nah

[18:10] <masak> Moukeddar: right. you agree to some terns, and then work according to those.

[18:10] <Moukeddar> how does it feel when you're doing all the work ? from graphics to code to design

[18:10] <masak> if the terms say "do everything", you do that :P

[18:10] <masak> Moukeddar: it can feel quite nice.

[18:10] <masak> Moukeddar: gives a lot of personal control, for sure.

[18:11] <pmichaud> I can work on autotrimming a bit

[18:11] <pmichaud> need to dive into the List stuff anyway

[18:11] <Moukeddar> true

[18:12] <masak> hm, maybe it's called "artistic control", I dunno.

[18:12] <PerlJam> Moukeddar: we are always a one-man-army ... it's just the enemy that changes :)

[18:12] * pmichaud wants to be a one-man air force.

[18:12] <Moukeddar> who's your enemy now?

[18:13] <masak> PerlJam: against a sea of troubles? to die, to sleep?

[18:13] <PerlJam> pmichaud: not a one-man space force?

[18:13] <pmichaud> PerlJam: air force is sufficient for now.  :-)

[18:13] * colomon suspects he is a one-man air farce

[18:13] <PerlJam> pmichaud: is that humility I sense?  ;)

[18:13] <masak> pmichaud: I've heard it requires replacing one's heart with a nuclear reactor...

[18:13] <pmichaud> PerlJam: unlikely.  :)

[18:14] <pmichaud> right now I could use a new throat and lungs  (have a really nasty cold)  :-(

[18:14] <PerlJam> colomon: as long as it really is air and not methane that you're generating

[18:14] * masak suddenly wishes he had a photo montage of Iron Man pmichaud 

[18:14] <Moukeddar> lol @ farce

[18:14] <Moukeddar> good pun

[18:14] <pmichaud> okay, so others can help me prioritize tasks

[18:15] <pmichaud> 1.  Make a new Star release    (nobody seems terribly excited about this one)

[18:15] <masak> 1. buy nuclear reactor

[18:15] <PerlJam> pmichaud: make rakudo faster.  :)

[18:15] <pmichaud> 2. Work on rakudo speed

[18:15] <pmichaud> 3.  Improve nom/nqp build system

[18:15] <pmichaud> 4.  Work on lists/iterators/subscripts

[18:15] <pmichaud> 5.  Work on nom/nqp

[18:15] <PerlJam> pmichaud: if you wait long enough on #4 the design will change anyway  ;)

[18:15] <pmichaud> PerlJam: on #4 I'm currently in charge of the design

[18:15] <Moukeddar> masak, i heard QUADAFI has an unused one , i cal talk him to sell it cheap :p

[18:16] <pmichaud> at least for lists and iterators

[18:16] <masak> Moukeddar: I forgot to mention it has to be really small. like, really small.

[18:16] <PerlJam> oh that's right ... just wait until you've changed your mind at least once, then do something.

[18:16] <pmichaud> all of the above are -Ofun for me, so I'm interesting in working on whatever people think is best for progress

[18:16] <pmichaud> *interested

[18:16] <Moukeddar> masak, he carries is in his costumes , ever wondered why they're so vast

[18:16] <PerlJam> at least you'd cut out one round of rewrites

[18:16] <pmichaud> I'm a little hesitant to work too much on Rakudo speed if we're going to throw a bunch of stuff out in nom anyway

[18:17] <masak> +1

[18:17] <pmichaud> (unless I work on it *in nom*, but there are other more pressing tasks there before we can get down to optimization)

[18:17] <sorear> well, there's always Niecza speed :D

[18:18] <PerlJam> heh

[18:18] <pmichaud> oh,  6.   Plagiarize niecza's LTM engine

[18:18] <pmichaud> (that one is less -Ofun for me at the moment, for some reason)

[18:18] <PerlJam> I guess I'm implicitly assuming that nom will land soonish.  (whatever "land" means)

[18:18] <sorear> please, call it "research"

[18:19] * pmichaud hums a Tom Lehrer tune

[18:19] <PerlJam> pmichaud: if I were you, I'd probably go with #5.  But, that's just me.

[18:19] <masak> Lobachevsky!

[18:20] <colomon> pmichaud: IMO, your priorities should be help with nom strictly as needed and sorting out #4 otherwise

[18:20] <pmichaud> PerlJam: wfm.  Although I might do #3 first, to simplify the install/build path for others wanting to play with nom

[18:21] <pmichaud> right now it's fairly convoluted (not surprising, given the history of the projects)

[18:21] <PerlJam> pmichaud: yeah, if I were me, I'd want to you do #3.  Wait ... I am me!   do #3  ;)

[18:22] <PerlJam> But I have no plans on hacking on nom, so it doesn't much matter to me.

[18:23] <pmichaud> speaking of nom, time for lunch

[18:23] <PerlJam> pmichaud: isn't #4 tied to a grant ?

[18:23] <pmichaud> I'll focus on #3 and #4

[18:23] <pmichaud> PerlJam: yes, and I should finish that too.

[18:23] <pmichaud> so #3 and #4 it is.

[18:24] <masak> \o/

[18:24] * sorear tries to figure out what hyperoperators are supposed to do.

[18:25] <pmichaud> they make everyone say "oh!  Perl 6 has just reinvented APL!"

[18:26] <pmichaud> "Including the impenetrable syntax!"

[18:27] <masak> or "This is why Perl 6 will never be anything but an *academic* language."

[18:27] <pmichaud> news.google.com is coming up blank for me.

[18:28] <pmichaud> maybe Paypal froze Google's accounts.

[18:28] <masak> there were no news today. ;)

[18:29] <pmichaud> http://pmichaud.com/sandbox/nonews.jpg

[18:31] <masak> maybe you accidentally turned of JavaScript, or something.

[18:31] <pmichaud> no, it's working now

[18:31] <pmichaud> well, with only a limited set of news

[18:32] <masak> well, you know what they say about no news.

[18:32] <pmichaud> afk, nom

[18:33] <sorear> masak: I'd be more than happy to ignore them.  I don't like them either.  But... yapsi uses them.

[18:35] <masak> sorear: oh! sorry about that.

[18:35] * masak isn't very sorry. not really. :)

[18:38] <sorear> down to 29 lines changed, most of them involving hyperops, junctions, or the "use package bug"

[18:39] <masak> sorear: nice. that's better than I'd have thought.

[18:39] <masak> sorear: also happy you're focusing on convergence. that's good for everyone.

[18:40] <masak> someone(TM) should continue to enumerate/explain the results from running the Contest entries on Niecza, too.

[18:40] <masak> probably me.

[18:42] <sorear> hmm

[18:42] <sorear> was there ever a yapsi 2011.04?

[18:43] <sorear> or 05 for that matter

[18:43] *** MayDaniel joined
[18:44] <masak> no .04, yes .05

[18:44] <masak> but I might've forgot to tag it :/

[18:44] *** masak left
[18:44] *** masak joined
[18:46] <masak> sorear: there. now Yapsi 2011.05 has a tag.

[18:47] * sorear tosses masak http://feather.perl6.nl/~sorear/Yapsi-2011.05-niecza.zip

[18:47] <masak> thanks.

[18:47] * masak investigates

[18:48] <masak> sorear: hmm? Windows executable?

[18:49] <sorear> CLR executable

[18:49] <masak> ah.

[18:49] <sorear> will run with mono

[18:50] <masak> mono MAIN.exe 

[18:50] <masak> >>> say 42

[18:50] <masak> 42

[18:50] <masak> \o/

[18:50] <masak> that is so cool!

[18:50] <masak> and *fast*!

[18:50] <masak> sorear++

[18:50] *** ymasory joined
[18:50] * masak now anticipates making the 2011.06 announcement quite a bit more

[18:51] <masak> "Yapsi -- the only Perl 6 implementation with cross-Perl6-implementation support!"

[18:55] <pmurias> how fast is yapsi on niecza compared to rakudo?

[18:56] <masak> I just timed the niecza variant for -e 'say 42'. it took .2 seconds on the Ubuntu VM of my laptop.

[18:57] <masak> the rakudo variant will take... longer. hold on.

[18:58] *** lumi_ joined
[18:58] *** Moukeddar left
[18:59] <masak> not sure any comparison I can make will be very fair.

[18:59] <masak> the niecza version is all precompiled; the reakudo version has a bin/yapsi script.

[18:59] *** mkramer left
[19:00] <masak> but, apart from that... running the rakudo variant takes 4 seconds, quite exactly.

[19:01] <masak> so Niecza's Yapsi is about an order of magnitude faster.

[19:05] <sorear> "reakudo" eh

[19:09] * sorear is very dubious about the claims in S03 that hyperops will be the fastest way to operate on lists

[19:13] <pmurias> sorear: what would be faster?

[19:14] <sorear> &map, for one

[19:15] <pmurias> why should that be faster?

[19:15] *** wallberg left
[19:15] *** cognominal joined
[19:15] <sorear> it has much less magic

[19:16] *** wallberg joined
[19:16] *** silug joined
[19:16] <Tene> isn't map specced as strictly ordered?

[19:17] <pmurias> sorear: hyper ops have magic?

[19:23] *** birdwindupbird joined
[19:27] *** Holy_Cow joined
[19:27] *** Holy_Cow left
[19:28] <sorear> Tene: yes

[19:28] *** envi left
[19:28] <sorear> Tene: but automatic threading is a pipe dream

[19:30] <sorear> What stops (0, @array) ¬ª+¬´ (@array, 0) from being a shape error?

[19:31] *** masak` joined
[19:31] <sorear> my current interpretation of S04 tells me that (0, @array) ¬´+¬ª (@array, 0)  ==>  (@array, @array)

[19:31] *** silug left
[19:32] *** masak left
[19:32] <sorear> pmichaud: how confident do you feel about the correctness of Rakudo's current hyper-op implementation?

[19:32] *** pernatiy left
[19:34] *** masak` left
[19:34] *** PacoLinux left
[19:35] *** masak` joined
[19:35] <pmurias> sorear: what's unrealistic about automatic threading?

[19:36] <sorear> pmurias: there's no way to tell the difference between -¬´[1,2] and [&expensive1,&expensive2]¬ª()

[19:37] <sorear> pmurias: creating threads in the first case would destroy performance.  as would setting a timer

[19:37] *** snearch joined
[19:37] <sorear> I've figured out how to make an efficient hyperop, but I still think that parallelization requires user input

[19:37] <sorear> maybe a use hyper :threaded; pragma

[19:38] <mberends> pmurias: if an array has, for example, 32 elements, is it performant to create 32 threads to process it?  That will depend on the hardware.

[19:39] <pmurias> my impression is that the intent is to parallelize for loads of elements

[19:39] <pmurias> if the array has 32000000 elements the choise is more obvious

[19:40] <mberends> sure, but it's hard to work out where to draw the lines

[19:41] <pmurias> doing it manually doesn't seem much easier

[19:42] *** masak`` joined
[19:42] *** mkramer joined
[19:43] <pmurias> and people seem to have some success in doing it in haskell (and moving computation to the GPU)

[19:44] *** masak` left
[19:45] <mberends> we could probably learn a lot from their experiences, because we are all n00bs in that area.

[19:46] *** masak`` left
[19:46] <sorear> I was semi-involved in the Data Parallel Haskell design work

[19:46] <sorear> if that's what you're talking about

[19:46] *** masak`` joined
[19:46] <sorear> although most of Roman's work still blows my mind

[19:48] <sorear> S03-metaops/hyper.t:687 makes no sense

[19:48] <sorear> why should eval accept a Buf, *ever*?

[19:49] * sorear pokes masak`` in eir capacity as Buf person

[19:51] *** masak`` left
[19:51] *** masak`` joined
[19:51] <pmurias> sorear: wouldn't it cast it to uft8?

[19:52] *** mkramer left
[19:53] *** mkramer joined
[19:54] <pmurias> sorear: the intent of the test is to check that latin1 operators in source file don't work without predeclaration

[19:54] *** wamba left
[20:02] *** masak`` left
[20:04] *** snearch left
[20:04] *** mkramer left
[20:06] <sorear> Why are 'isa' and 'does' separate?

[20:15] <mberends> someone once said 'isa' = class = instance management, 'does' = role = behaviour management. You may not need classes because if you create an object that does a role, the compiler or runtime  is supposed to create a private anonymous class that does that role, exclusively for use by that object.

[20:17] <mberends> oh, classes have an inheritance hierarchy, roles do not.

[20:21] *** MayDaniel left
[20:21] *** ymasory left
[20:28] <sorear> In niecza I shall make isa/does and is/does synonymous in every case

[20:28] *** wknight8111 left
[20:33] *** PacoLinux joined
[20:34] *** orafu left
[20:34] <pmurias> perl6: role Foo {method a {}};role Bar {method a {}};class Baz is Foo is Bar {}

[20:34] <p6eval> pugs, rakudo 0d3c71:  ( no output )

[20:34] <p6eval> ..niecza v5-97-g5967651: OUTPUT¬´Unhandled exception: Unable to resolve method linearized_mro in class Role‚ê§  at /home/p6eval/niecza/src/Metamodel.pm6 line 339 (Metamodel Class.close @ 27)‚ê§  at /home/p6eval/niecza/src/NieczaPassBegin.pm6 line 412 (NieczaPassBegin C175_ANON @ 14)‚ê§  at

[20:34] <p6eval> ../home/p6eval/niecza/src/Niecza‚Ä¶

[20:34] *** mberends left
[20:34] <pmurias> rakudo: role Foo {method a {}};role Bar {method a {}};class Baz does Foo does Bar {}

[20:34] <p6eval> rakudo 0d3c71: OUTPUT¬´===SORRY!===‚ê§Method 'a' collides and a resolution must be provided by the class‚ê§¬ª

[20:34] *** orafu joined
[20:34] <pmurias> sorear: that's one difference

[20:35] *** mberends joined
[20:45] *** dukeleto left
[20:45] *** dukeleto joined
[20:50] *** birdwindupbird left
[20:52] *** bluescreen10 left
[20:56] *** wooden joined
[20:57] *** benabik left
[20:59] *** meteorjay left
[20:59] *** meteorjay joined
[21:00] *** mberends left
[21:06] *** bluescreen10 joined
[21:11] <Util> New RC solution: http://rosettacode.org/wiki/Anagrams/Deranged_anagrams#Perl_6

[21:17] *** Gruber joined
[21:18] *** frank joined
[21:18] *** Grrrr left
[21:19] *** BinGOs left
[21:19] *** aesop left
[21:19] *** BinGOs joined
[21:19] *** nrr left
[21:19] *** nrr joined
[21:21] *** Gruber is now known as Grrrr

[21:24] *** MayDaniel joined
[21:32] *** bluescreen10 left
[21:46] *** noganex_ left
[21:49] *** Patterner left
[21:51] *** noganex joined
[21:53] *** hercynium left
[21:54] *** Psyche^ joined
[21:54] *** Psyche^ is now known as Patterner

[21:55] <sorear> bah, niecza's STD chokes on <<+>>

[21:55] <sorear> the "LTM" component is adamnt that there's some bit shifting going on

[22:00] *** silug joined
[22:09] *** donri left
[22:10] *** dukeleto left
[22:10] *** dukeleto joined
[22:18] *** breatharian joined
[22:19] <breatharian> Howdy

[22:19] <sorear> Hello.

[22:19] <breatharian> It appears that Perl 6 allows "block expressions". By block expression I mean: https://gist.github.com/996274

[22:19] <breatharian> My question is, does Perl 5?

[22:20] <sorear> yes

[22:20] <breatharian> sorear, Yes to 5 or 6? :-)

[22:20] <sorear> buubot_backup: say 1 + (do { my $x = 5; $x })

[22:20] <buubot_backup> sorear: Couldn't match input.

[22:20] <sorear> buubot_backup: eval: say 1 + (do { my $x = 5; $x })

[22:20] <buubot_backup> sorear: ERROR: syntax error at (eval 28) line 1, near "say 1" syntax error at (eval 28) line 1, near "$x }" 

[22:20] <sorear> buubot_backup: eval: print 1 + (do { my $x = 5; $x })

[22:20] <buubot_backup> sorear: 61

[22:20] <sorear> buubot_backup: eval: 1 + (do { my $x = 5; $x })

[22:20] <buubot_backup> sorear: 6

[22:21] <sorear> breatharian: also, if you wrap the C example in parens so that it becomes ({ ... }), it will become legal[1]

[22:22] <sorear> [1] actually a gcc extension, but icc, clang and I think also msvc have added it also

[22:24] <breatharian> sorear, Aha! So the example above is legal Perl 5. Is it also legal Perl 6?

[22:26] <sorear> yes

[22:26] <sorear> but mostly by accident

[22:26] <sorear> the meaning of "do" has changed fairly significantly

[22:27] <sorear> a Perl 5/Perl 6 polyglot is about as hard as a Perl 5/Ruby polyglot; don't try to write them, except as a game

[22:27] *** MayDaniel left
[22:28] <sorear> welcome, btw

[22:31] <breatharian> sorear, I updated the gist with the Perl example.

[22:33] <breatharian> sorear, By the ({...}), are you referring to this?  http://en.wikipedia.org/wiki/Blocks_%28C_language_extension%29

[22:34] *** silug left
[22:34] <breatharian> sorear, The page says it's an Objective-C only extension.

[22:34] <breatharian> sorear, Er... I mean an Apply only extension.

[22:34] <sorear> breatharian: http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/Statement-Exprs.html

[22:35] <sorear> it's a gcc extension, it's been around since 2.x if not before

[22:35] <breatharian> sorear, Aha!!!

[22:35] <sorear> I know for a fact icc and clang have it; glibc and linux use it massively

[22:35] <jlaire> those blocks you linked to are more like lambda functions

[22:36] <jlaire> and very non-portable

[22:36] <breatharian> sorear, The C example in the gist wasn't quite legal with the ( and ). I needed to remove the 'return'.

[22:37] <sorear> in perl 6 it's really easy

[22:37] <sorear> niecza: say (my $x = 5; $x)

[22:37] <p6eval> niecza v5-97-g5967651: OUTPUT¬´5‚ê§¬ª

[22:38] <tadzik> niecza: say { my $a = 5 }

[22:38] <p6eval> niecza v5-97-g5967651: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/5pRMrXdnfU line 1:‚ê§------> [32msay { my $a[33m‚èè[31m = 5 }[0m‚ê§‚ê§Sub()<instance>‚ê§¬ª

[22:38] <tadzik> perl6: say { my $a = 5 }

[22:38] <p6eval> rakudo 0d3c71: OUTPUT¬´_block131‚ê§¬ª

[22:38] <p6eval> ..niecza v5-97-g5967651: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/yr1Phjsi6F line 1:‚ê§------> [32msay { my $a[33m‚èè[31m = 5 }[0m‚ê§‚ê§Sub()<instance>‚ê§¬ª

[22:38] <p6eval> ..pugs: OUTPUT¬´<SubBlock(<anon>)>‚ê§¬ª

[22:38] <tadzik> hrm

[22:38] <sorear> perl6: say { my $a = 5; $a }()

[22:38] <p6eval> rakudo 0d3c71, niecza v5-97-g5967651: OUTPUT¬´5‚ê§¬ª

[22:38] <p6eval> ..pugs: OUTPUT¬´<SubBlock(<anon>)>‚ê§*** Cannot cast from VBool True to Pugs.AST.Types.VCode (VCode)‚ê§    at /tmp/DEQxBTYidI line 1, column 1 - line 2, column 1‚ê§¬ª

[22:39] *** wallberg left
[22:39] <breatharian> Does Python support block expressions?

[22:39] <sorear> doubt it

[22:39] <sorear> that's not Guido's style

[22:42] <breatharian> What about Ruby?

[22:47] <sorear> nice, I'm already finding bugs in the hyperop tests

[22:47] <sorear> no clue

[22:47] *** am0c joined
[22:47] <sorear> also, I've lost the ability to type "nice" quickly

[22:48] <sorear> I send n+i+c+e to my fingers and it comes out "niec..."

[22:48] <sorear> sometimes "niecza"

[22:48] <breatharian> sorear, Thanks alot for the help. Dinner time.

[22:48] *** breatharian left
[22:52] <pmurias> sorear: what bugs did you find?

[22:53] <sorear> pmurias: my @a = 1,4,9; @a¬ª++; is_deeply @a, (2,5,9) # NO

[22:54] <pmurias> perl6: my @a = 1,4,8;@a>>++; say @a;

[22:54] <p6eval> niecza v5-97-g5967651: OUTPUT¬´Unhandled exception: System.Exception: Unable to find lexical &hyperunary in mainline‚ê§‚ê§Server stack trace: ‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ‚ê§  at

[22:54] <p6eval> ..Niecza.CLRBacken‚Ä¶

[22:54] <p6eval> ..rakudo 0d3c71: OUTPUT¬´259‚ê§¬ª

[22:54] <p6eval> ..pugs: OUTPUT¬´148‚ê§¬ª

[22:54] <pmurias> perl6: my @a = 1,4,9;@a>>++; say @a;

[22:54] <p6eval> niecza v5-97-g5967651: OUTPUT¬´Unhandled exception: System.Exception: Unable to find lexical &hyperunary in mainline‚ê§‚ê§Server stack trace: ‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ‚ê§  at

[22:54] <p6eval> ..Niecza.CLRBacken‚Ä¶

[22:54] <p6eval> ..pugs: OUTPUT¬´149‚ê§¬ª

[22:54] <p6eval> ..rakudo 0d3c71: OUTPUT¬´2510‚ê§¬ª

[22:54] <pmurias> sorear: any idea why they weren't detected?

[22:55] <pmurias> sorear: i think the rationale behind eval(Buf) is to allow something like eval('use latin1;...');

[22:56] <pmurias> does perl6 have a way to specify buf as a literal?

[23:03] <sorear> yes

[23:03] <sorear> :256{0,1,234,92,32...}

[23:04] <sorear> they were not detected because they were skipped for Rakudo

[23:04] <sorear> rakudo apparently has issues with ¬ª++

[23:04] <sorear> (niecza doesn't :D)

[23:08] *** kid51 joined
[23:08] <sorear> o/ kid51

[23:10] *** whiteknight joined
[23:15] *** dukeleto left
[23:16] *** dukeleto joined
[23:17] *** pmurias left
[23:35] *** cdarroch left
[23:54] *** benabik joined
