[00:00] <Moukeddar> i'm stuck too, i have an OSS freak teaching us, what a pain 

[00:09] *** Moukeddar left
[00:17] *** dorlamm joined
[00:20] <Timbus> sorear, that's a good point. I was going to use gtk and anyevent, maybe with coro, but since I need serial port communication, it might be a serious blocker

[00:20] <Timbus> what a terrible unintended pun

[00:22] <sorear> Timbus: if it's all going with serial ports anyevent should work fine

[00:24] <Timbus> I'm only used to working with Device::Serialport, which is terrible. and it blocks.

[00:25] <Timbus> and with the possibility that this will need to run on windows, can I access the serial like it was a normal filehandle? I don't know

[00:29] *** silug joined
[00:31] <sorear> on Linux there is nothing special about accessing the serial port; it's just /dev/ttyS0, open it and access it as a filehandle

[00:31] <sorear> you'll need to use POSIX::tcsetattr and friends to set up I/O parameters

[00:32] <sorear> I don't know about Windows serial port access, but the existance of System.IO.Ports makes me doubt you can just treat the serial port as a file under Windows

[00:33] <sorear> because if you could, people would just use the ordinary classes in System.IO...

[00:37] *** replore joined
[00:37] <Timbus> probably the wrong words. 'as a file' => 'as an IO handle'

[00:37] <Timbus> specifically one that I can wait on

[00:39] <Timbus> because a GUI shouldnt freeze waiting for IO

[00:40] <sorear> AnyEvent will definitely work with serial port FDs on Unixes

[00:41] <sorear> it has to, because serial ports are considered a kind of terminal, and when you run irssi on a terminal it has to wait for either a key press or socket input

[00:42] <Timbus> good point

[00:42] <Timbus> guess I'll convince my work to run an ubuntu box

[00:42] <Timbus> won't be hard to do

[00:47] *** tokuhirom left
[00:51] *** dorlamm left
[00:53] <sorear> Timbus: I'm not saying it's hard to do on Windows, only that I have no experience

[01:02] *** hypolin joined
[01:09] *** woosley joined
[01:09] *** woosley left
[01:10] *** woosley joined
[01:10] *** woosley left
[01:13] *** packetknife joined
[01:24] *** mkramer joined
[01:25] *** pluto_ joined
[01:25] *** mkramer left
[01:25] *** mkramer joined
[01:26] *** woosley joined
[01:31] *** daniel-s joined
[01:36] *** mkramer left
[01:48] *** packetknife left
[02:10] *** overrosy left
[02:11] *** overrosy joined
[02:43] *** cooper left
[02:46] *** benabik joined
[03:08] *** Guest74144 left
[03:10] <diakopter> in case anyone wants to see method quant for NFA.nqp (it won't be committed unless we get some good tests for it by tomorrow)  https://gist.github.com/1372240

[03:10] <diakopter> WFM though

[03:19] *** wolfman2000 joined
[03:56] *** mkramer joined
[03:57] *** mkramer left
[04:12] *** packetknife joined
[04:20] *** birdwindupbird joined
[04:29] *** satyavvd joined
[04:31] *** packetknife left
[04:35] *** replore left
[04:35] *** replore__ joined
[04:42] *** envi_|2 joined
[04:48] *** sili joined
[05:02] *** _jaldhar joined
[05:13] *** kaleem joined
[05:13] *** hypolin left
[05:22] *** risou_awy is now known as risou

[05:23] *** twinshadow joined
[05:28] *** envi_|2 left
[05:33] *** hypolin joined
[05:37] *** sftp left
[05:51] *** hypolin left
[05:54] *** Exodist left
[06:12] <Woodi> do Perl allows load modules at runtime ?

[06:12] <sorear> yes

[06:13] <sorear> require Foo;

[06:13] <sorear> both 5 and 6

[06:23] *** risou is now known as risou_awy

[06:24] <Woodi> right, checked only eval( use ... )... anyway strange question :)

[06:29] *** fsergot left
[06:35] *** koban joined
[06:40] *** mkramer joined
[06:45] *** Exodist joined
[06:50] *** fsergot joined
[06:51] *** molaf joined
[06:51] <sorear> Woodi: it needs to be eval(" use ... ")

[06:54] *** mkramer left
[06:54] *** wtw joined
[06:54] *** flussence left
[06:55] *** mkramer joined
[06:55] *** mberends left
[07:07] *** fsergot left
[07:08] *** sivoais left
[07:08] *** molaf left
[07:09] *** woosley left
[07:13] * Woodi say nothing

[07:22] *** flussence joined
[07:29] *** fsergot joined
[07:29] *** mishin joined
[07:31] *** flussence left
[07:32] *** flussence joined
[07:40] *** Sarten-X joined
[07:42] *** koban left
[07:54] *** fsergot left
[07:56] *** wolfman2000 left
[08:05] *** sili left
[08:07] *** mishin left
[08:14] *** fsergot joined
[08:17] *** mj41 joined
[08:18] *** am0c left
[08:30] *** fsergot left
[08:31] <masak> morning, #perl6

[08:32] <masak> ok, follow-up to Woodi's question: is there a way to re-require a module, in the event its file changed on disk? module hotswapping, in effect.

[08:33] <masak> ISTR buubot_backup does it, and is written in Perl 5. I have no idea how to go about it in Perl 6.

[08:51] *** fsergot joined
[09:05] *** fsergot left
[09:20] *** mkramer left
[09:22] *** mkramer joined
[09:22] <moritz> masak: I think the solution is to assign the new module a new version, and load that

[09:24] *** mkramer1 joined
[09:24] *** mkramer left
[09:26] *** fsergot joined
[09:27] <masak> fair enough.

[09:29] <masak> has there been a parrot release yet this week?

[09:29] <masak> I don't see any release announcement.

[09:29] <moritz> #parrot topic says 3.10.0

[09:30] * moritz disappears again

[09:35] *** mkramer1 left
[09:43] *** mkramer joined
[09:45] *** replore__ left
[09:47] *** mkramer1 joined
[09:47] *** replore_ joined
[09:48] *** mkramer left
[09:49] *** dakkar joined
[09:50] *** pluto_ left
[09:51] *** mkramer1 left
[09:51] *** bazqux joined
[09:51] *** mkramer joined
[09:52] *** replore_ left
[09:59] *** fsergot left
[10:02] *** mkramer left
[10:06] *** Trashlord joined
[10:07] *** daxim_ joined
[10:08] *** BooK left
[10:08] *** BooK joined
[10:08] *** daxim left
[10:15] *** kfo joined
[10:16] *** worr joined
[10:18] *** kfo_ left
[10:22] *** fsergot joined
[10:25] *** kst` joined
[10:26] *** kst left
[10:28] *** envi_|2 joined
[10:35] *** fsergot left
[10:37] *** envi_|2 left
[10:38] *** envi_ joined
[10:40] *** risou_awy is now known as risou

[10:57] *** heleana joined
[10:58] *** heleana left
[11:15] *** mtk left
[11:20] *** fsergot joined
[11:29] * felher just noticed there is a new protoregex branch o/. jnthn++

[11:29] *** fsergot left
[11:30] <jnthn> felher: Plan to merge it this evening.

[11:30] <felher> jnthn: great :)

[11:30] <felher> jnthn: then i can test a few of my old programs on nom rather than on ng :)

[11:33] <jnthn> felher: Yeah. There's still other regex engine stuff that'll need looking at too.

[11:33] <jnthn> But, I'll be picking them off best I can.

[11:35] <bbkr> awesome news, JSON::Tiny should work again with proto

[11:36] <felher> jnthn: nice. great work :)

[11:36] <jnthn> bbkr: Not sure how well that's going to work yet...but yeah, that's what I'm shooting for.

[11:37] *** worr left
[11:40] *** JimmyZ joined
[11:40] *** satyavvd left
[11:51] *** mkramer joined
[11:53] *** worr joined
[11:54] *** Je joined
[11:55] <Je> Say 3

[11:56] *** mkramer left
[11:57] *** Je left
[11:57] *** mkramer joined
[12:05] *** mkramer1 joined
[12:05] *** mkramer left
[12:07] *** benabik left
[12:10] *** HarryS left
[12:12] *** HarryS joined
[12:12] *** Psyche^ joined
[12:15] *** icwiener joined
[12:16] *** Patterner left
[12:16] *** Psyche^ is now known as Patterner

[12:36] *** bluescreen10 joined
[12:37] *** mkramer1 left
[12:38] *** [Coke] left
[12:38] *** [Coke] joined
[12:38] *** pmichaud left
[12:38] *** masak left
[12:38] *** pmichaud joined
[12:39] *** mkramer joined
[12:40] *** masak joined
[12:40] *** PerlJam left
[12:41] *** PerlJam joined
[12:45] *** worr left
[12:45] *** worr joined
[12:51] *** worr left
[12:58] *** benabik joined
[12:58] *** JimmyZ_ joined
[12:58] *** JimmyZ_ left
[12:59] *** JimmyZ left
[13:16] *** kaleem left
[13:20] *** mkramer1 joined
[13:20] *** mkramer left
[13:22] *** colomon left
[13:23] *** kaleem joined
[13:37] <[Coke]> jnthn: how's protoregex going?

[13:37] <[Coke]> jnthn++ # unblocking modules

[13:37] *** JimmyZ joined
[13:39] *** mkramer1 left
[13:42] *** colomon joined
[13:44] *** mkramer joined
[13:48] <jnthn> [Coke]: At $dayjob for the next couple of hours. But the branch passes all tests nom does, plus protoregex.t. :)

[13:48] <jnthn> [Coke]: So plan to merge it ahead of tonight's release

[13:49] <jnthn> Bit last minute but the release manager didn't scream at me :)

[13:49] <jnthn> ...though that could be because we don't have one ;)

[13:49] <colomon> ;)

[13:50] <jnthn> Generally though, I'm all for getting it into people's hands if they follow compiler releases.

[13:53] *** mtk joined
[13:56] <[Coke]> Agreed. in general, star releases we should be more careful of (except the next one which we know will be a jolt because of nom)

[14:00] *** vmspb joined
[14:03] *** sivoais joined
[14:04] <arnsholt> nom: sub foo(*@args) { say @args.join(", "); }; my @a = <a b c>; foo(|@a);

[14:04] <p6eval> nom 8f1f5d: OUTPUT¬´a, b, c‚ê§¬ª

[14:05] <arnsholt> nom: sub foo(*@args) { say @args.join(", "); }; my @a = <a b c>; foo(d, |@a);

[14:05] <p6eval> nom 8f1f5d: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&d' called (line 1)‚ê§¬ª

[14:05] <arnsholt> nom: sub foo(*@args) { say @args.join(", "); }; my @a = <a b c>; foo('d', |@a); # Oh, do understand what I mean :p

[14:05] <p6eval> nom 8f1f5d: OUTPUT¬´d, a, b, c‚ê§¬ª

[14:05] <arnsholt> Huh. Must be something else wrong with my code then

[14:06] <[Coke]> paypal--

[14:10] *** mkramer left
[14:12] *** mkramer joined
[14:18] *** mkramer left
[14:20] *** mkramer joined
[14:20] *** Sarten-X left
[14:24] *** mkramer left
[14:24] <jnthn> [Coke]: Yeah, but I'm hoping to make it a softish jolt :) Or at least a "ooh, it's faster at least" one :)

[14:25] <arnsholt> Is it possible to have both the default constructor and a constructor that takes positional arguments?

[14:26] <arnsholt> multi method new($a, $b) { ... } doesn't seem to do the trick

[14:26] <jnthn> arnsholt: yes, just multi it

[14:26] <arnsholt> Then I'm doing something else wrong =)

[14:26] *** mkramer joined
[14:27] <jnthn> nom: class A { has $!a; has $!b; multi method new($a, $b) { self.bless(:$a, :$b) } }; say A.new(1,2).a; say A.new(:a(1), :b(2)).a

[14:27] <p6eval> nom 8f1f5d: OUTPUT¬´Not enough positional parameters passed; got 1 but expected at least 2‚ê§  in method bless at src/gen/CORE.setting:533‚ê§  in method new at /tmp/aYxTBROcFM:1‚ê§  in block <anon> at /tmp/aYxTBROcFM:1‚ê§  in <anon> at /tmp/aYxTBROcFM:1‚ê§¬ª

[14:27] <jnthn> oh, yes

[14:27] *** bazqux left
[14:27] <jnthn> bless needs a candiate

[14:27] <jnthn> nom: class A { has $!a; has $!b; multi method new($a, $b) { self.bless(*, :$a, :$b) } }; say A.new(1,2).a; say A.new(:a(1), :b(2)).a

[14:27] <p6eval> nom 8f1f5d: OUTPUT¬´Method 'a' not found for invocant of class 'A'‚ê§  in block <anon> at /tmp/biq5LAHKm1:1‚ê§  in <anon> at /tmp/biq5LAHKm1:1‚ê§¬ª

[14:27] <jnthn> oh, and I meant .

[14:27] <jnthn> nom: class A { has $.a; has $.b; multi method new($a, $b) { self.bless(*, :$a, :$b) } }; say A.new(1,2).a; say A.new(:a(1), :b(2)).a

[14:27] <p6eval> nom 8f1f5d: OUTPUT¬´1‚ê§1‚ê§¬ª

[14:28] <jnthn> arnsholt: Like ^

[14:28] <jnthn> Your new just transforms nameds into positionals for bless to use.

[14:28] *** mkramer left
[14:28] <arnsholt> Coll

[14:28] <arnsholt> Or, cool

[14:29] *** mkramer joined
[14:31] *** Sarten-X joined
[14:33] *** mkramer left
[14:35] *** tokuhirom joined
[14:35] *** sftp joined
[14:37] *** mkramer joined
[14:37] *** mkramer left
[14:43] <felher> Is map eager in current nom? 

[14:44] <masak> nom: my @a := map { say "OH HAI" }, 1, 2, 3; say "alive!"

[14:44] <p6eval> nom 8f1f5d: OUTPUT¬´alive!‚ê§¬ª

[14:44] <masak> doesn't seem like it.

[14:44] <masak> nom: multi foo($a) { say "OH HAI" }; multi foo(:$a) { say "OH named HAI" }; foo(5); foo( :a(5) )

[14:44] <p6eval> nom 8f1f5d: OUTPUT¬´OH HAI‚ê§OH named HAI‚ê§¬ª

[14:45] <masak> nom++

[14:45] <colomon> niecza: multi foo($a) { say "OH HAI" }; multi foo(:$a) { say "OH named HAI" }; foo(5); foo( :a(5) )

[14:45] <p6eval> niecza v11-24-gcdd4e66: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/W8DtKGd0og line 1:‚ê§------> [32mmulti foo([33m‚èè[31m$a) { say "OH HAI" }; multi foo(:$a) { s[0m‚ê§‚ê§OH HAI‚ê§Unhandled exception: Ambiguous dispatch for &foo‚ê§  at <unknown> line 0 (&foo @ 0) ‚ê§  at ‚Ä¶

[14:45] <colomon> ah, not caught up with the spec changes yet, eh?

[14:46] <felher> Hm.. 'why does for (1..*) { .say; }' work as expected but 'for ((1..*).map({$_ + 1})) { .say; }' doesn't?

[14:47] <felher> The first print all the numbers, the second doesn't print anything here.

[14:48] <felher> s/as expected/as i expected/ :)

[14:48] <masak> colomon: frankly, I expected some kind of ambiguous dispatch when I tired it in nom as well...

[14:49] <colomon> that is the latest spec, though, right?  You can't call positional arguments by name anymore.

[14:49] <jnthn> The positional one was ruled out on arity.

[14:49] *** sayu joined
[14:49] <jnthn> That left one candidate

[14:49] <jnthn> Well, the multi-dispatcher was, iirc, never spec'd to do named to positonal mapping.

[14:49] <masak> nom: .say for 1..Inf

[14:50] <p6eval> nom 8f1f5d: OUTPUT¬´(timeout)1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§6‚ê§7‚ê§8‚ê§9‚ê§10‚ê§11‚ê§12‚ê§13‚ê§14‚ê§15‚ê§16‚ê§17‚ê§18‚ê§19‚ê§20‚ê§21‚ê§22‚ê§23‚ê§24‚ê§25‚ê§26‚ê§27‚ê§28‚ê§29‚ê§30‚ê§31‚ê§32‚ê§33‚ê§34‚ê§35‚ê§36‚ê§37‚ê§38‚ê§39‚ê§40‚ê§41‚ê§42‚ê§43‚ê§44‚ê§45‚ê§46‚ê§47‚ê§48‚ê§49‚ê§50‚ê§51‚ê§52‚ê§53‚ê§54‚ê§55‚ê§56‚ê§57‚ê§58‚ê§59‚ê§60‚ê§61‚ê§62‚ê§63‚ê§64‚ê§65‚ê§66‚ê§67‚ê§68‚ê§69‚ê§70‚ê§71‚ê§72‚ê§73‚ê§74‚ê§75‚ê§76‚ê§77‚ê§78‚ê§79‚ê§80‚ê§81‚ê§82‚

[14:50] <masak> nom: .say for map * + 1, 1..Inf

[14:50] <PerlJam> felher: insufficient eager on the second one?

[14:50] <p6eval> nom 8f1f5d: OUTPUT¬´(timeout)¬ª

[14:50] <jnthn> That looks rong.

[14:50] <masak> PerlJam: more like too eager.

[14:50] <colomon> insufficient laziness

[14:50] <PerlJam> yeah, that's what I meant

[14:50] <PerlJam> :)

[14:50] <felher> :)

[14:51] <PerlJam> (insufficent caffiene for me at the moment)

[14:53] * felher afk

[14:54] <mux> too eager/ insufficient laziness - I swear to god I thought I was in #haskell just now

[14:54] <PerlJam> you know what the neat thing is about not messing with perl 6 for about a month?  ...     Rakudo seems much faster than I remember :)

[14:55] <masak> PerlJam: as you get older, time appears to speed up :P

[14:56] <masak> or rather, mental perception points get sparser.

[14:56] <PerlJam> masak: yeah, and back when I was a kid, pi was just 3  :)

[14:56] <masak> those were the days.

[14:56] *** shinobicl joined
[14:56] <masak> circles looked like hexagons.

[14:57] <PerlJam> The perceptual resolution of reality increases with time

[14:58] <PerlJam> mid-life crisis is when you become aware of the fractal nature of everything.

[14:58] <masak> oh, that's what it is?

[14:59] *** am0c joined
[14:59] * masak .oO( omg, it's full of crises )

[15:00] <PerlJam> I think there's a relativity principle in play here.  While rakudo's execution speed seems much faster, compilation still seems to take forever

[15:00] <masak> well, remember the November stats from 2008: we brought the time for a GET request down from 17 seconds to 3 seconds by precompiling everything to PIR.

[15:01] <masak> so, nihil novo.

[15:05] <arnsholt> If I may pick a nit, it's novi. =) The classic example of partitive genitive (which is quite cool)

[15:05] <jnthn> ...which language are we in? :)

[15:05] <masak> arnsholt: much appreciated. I did hesitate, but didn't check. :/

[15:05] <masak> jnthn: Latin.

[15:05] <jnthn> ah :)

[15:06] <masak> arnsholt: partitive genitive because "nothing of new"?

[15:06] <jnthn> (compile time) well, step 1 is parse faster. step 2 is build ast nodes faster :)

[15:06] <PerlJam> And then when you get older people start speaking funny languages and you think that you're having an aneurism

[15:06] <PerlJam> ;)

[15:08] *** wtw left
[15:09] *** simcop2387 left
[15:10] <masak> PerlJam: here in Europe we're pretty used to people speaking "funny languages" :)

[15:11] <jnthn> Nikdy nehovorim komicke jazyky! :P

[15:12] *** simcop2387 joined
[15:18] <arnsholt> masak: Yeah, nothing of the new kind under the sun

[15:21] *** kaleem left
[15:22] <masak> arnsholt: I feel like each time I encounter the partitive genitive, I understand it but it feels like the first time I learn it. I should learn it for real some time. :)

[15:23] *** alester joined
[15:29] *** ethndbst joined
[15:29] *** ethndbst left
[15:29] *** ethndbst joined
[15:29] <arnsholt> It's a bit tricky to remember. But learning French is useful, since they still use it (sort of)

[15:33] <masak> I learned French long ago, but I'm pretty sure they didn't mention partitive genitive.

[15:35] <arnsholt> Yeah, it's a bit hidden

[15:35] <mux> I'm french and I have no idea what partitive genitive is

[15:36] <arnsholt> "une bouteille d'eau" is partitive genitive, essentially

[15:36] <cognominal> partitive genetive, hidden, that's sound like private parts to the average french pervert

[15:36] <arnsholt> It's the de and something without an article

[15:36] <mux> oh, that has a name? ;-)

[15:36] <arnsholt> Yeah, us foreigners need to name things to remember them properly =D

[15:37] <mux> this "d'" (contraction of de) here is just like the "of" in english to me - like in a bottle of water

[15:38] <arnsholt> Yeah, that's the same use case

[15:38] <mux> okay then

[15:38] <masak> so "a bottle of water" is partitive genitive too? :)

[15:38] <mux> it would seem so

[15:38] <arnsholt> But IIRC the article or no article decision is a bit fiddly for foreigners

[15:38] <arnsholt> At least it is for me as a Norwegian

[15:39] <arnsholt> masak: You might be able to call it that

[15:39] <arnsholt> But the article de in French is a very direct successor of the genitive case. Not sure if it's that straightforward in Germanic

[15:39] * mux cannot think of a better way to spend the last hour of his working day than to research grammatical constructs on wikipedia

[15:40] <arnsholt> Indeed!

[15:40] <mux> if only there wasn't the face of Jimmy creepy Wales up there, it creeps the shit out of me

[15:40] <arnsholt> Yeah, that's a bit unnerving

[15:40] <mux> this guy would make a very successful stalker

[15:41] *** Gothmog_ left
[15:42] <masak> his face looks stranger the more you stare at it.

[15:42] <masak> kind of assymetrical.

[15:43] *** JimmyZ left
[15:44] <mux> http://i.imgur.com/bZKqt.png -- I thought you guys would enjoy that as much as I did

[15:45] <arnsholt> Ah, the internet. Helping me procrastinate, as always =D

[15:46] <arnsholt> Speaking of which, writing abstracts is hard (let's go shopping?)

[15:46] *** PlusYan joined
[15:47] *** tokuhirom left
[15:47] <masak> shopping abstracts is hard too.

[15:48] <arnsholt> True, true =D

[15:49] <Util> FYI: nom regression

[15:49] <Util> While pondering http://rosettacode.org/wiki/Hofstadter_Q_sequence , I reduced it to:

[15:49] <Util>     my @h := 1, 1, { @h[*-@h[*-1]] + @h[*-@h[*-2]] } ... *; say @h[^10];

[15:49] <Util> which works with Niecza and Rakudo_2011.04, but fails with Rakudo_2011.10 .

[15:49] <Util> This reduced case also fails with Rakudo_2011.10:

[15:49] <Util>     my @h := 1, 1, { @h[*-1] } ... *; say @h[^5];

[15:49] <Util> This case hangs forever with Rakudo_2011.10, but generates `1 1 Any Any Any` on Niecza and Rakudo_2011.04:

[15:49] <Util>     my @h := 1, 1, { @h[2] } ... *; say @h[^5];

[15:49] <Util> EOR

[15:50] <jnthn> If anyone wants to turn that into an RT, please do

[15:50] *** plobsing_ joined
[15:51] <benabik> Is * supposed to be "current position" when building an infinite list?

[15:52] <colomon> benabik: errr... no?

[15:53] <Util> benabik: @foo[*-3] is the new way to say Perl 5's $foo[-3], or "third element from the end"

[15:53] <benabik> Util: And the end of an list defined as ‚Ä¶ * is?

[15:53] <colomon> but (for instance) if you pass a Whatever (thing that we used to call curry) to @a[ ], then it evaluates it using the current number of elements as the argument

[15:53] <Util> Since inf lists have no end, a useful interpretation would be "third element from the end of what we have generated so far"

[15:53] <colomon> ... * means "go on forever"

[15:53] *** plobsing left
[15:54] <colomon> oooo, yeah, I see what benabik is getting at

[15:54] <colomon> that does seem kind of dodgy

[15:55] <masak> agree about the dodgy.

[15:55] <colomon> rakudo: my @h := 1, 1, -> @h2 { @h2[*-@h2[*-1]] + @h2[*-@h2[*-2]] } ... *; say @h[^10];

[15:55] <p6eval> rakudo 8f1f5d: OUTPUT¬´Nominal type check failed for parameter '@h2'; expected Positional but got Int instead‚ê§  in block <anon> at /tmp/NWHOaGZz7p:1‚ê§  in sub coro at src/gen/CORE.setting:4154‚ê§  in method reify at src/gen/CORE.setting:4129‚ê§  in method reify at src/gen/CORE.setting:3914‚ê§  ‚Ä¶

[15:55] <colomon> b: my @h := 1, 1, -> @h2 { @h2[*-@h2[*-1]] + @h2[*-@h2[*-2]] } ... *; say @h[^10];

[15:55] <masak> is that spec'd at all? what does the * refer to when indexing a not-fully-evaluated lazy list?

[15:55] <p6eval> b 1b7dd1: OUTPUT¬´Nominal type check failed for parameter '@h2'; expected Positional but got Int instead‚ê§  in <anon> at line 22:/tmp/NnA517xBbT‚ê§  in <anon> at line 872:src/gen/core.pm‚ê§  in 'List::at_pos' at line 1:src/metamodel/RoleToInstanceApplier.nqp‚ê§  in 'Any::postcircumfix:<[ ]>' at‚Ä¶

[15:56] <colomon> masak: pretty sure that's not spec'd at all

[15:56] <colomon> or at least, we definitely want it to refer to the fully-evaluated list

[15:56] <colomon> otherwise it would break all sorts of normal usages

[15:57] <Util> Since you can never generate element# N without already having element# N-1, I think it is safe to allow the generating function to access the size of the bound array so far (when the generating func is referencing the bound array).

[15:58] <colomon> it's safe to allow, sure.

[15:58] <Util> I just want this use of * to work *within* the generating function. colomon: point taken on normal use *outside* the generating function.

[15:59] <colomon> but * has the same meaning in either place

[15:59] <Util> Not usefully so.

[16:00] <colomon> If I understand you correctly, you're asking that the generating closure containing @h[ ] know that it is a generating closure and therefore change the meaning of @h[ ]

[16:01] <colomon> b: my @h := 1, 1, -> *@h2 { @h2[*-@h2[*-1]] + @h2[*-@h2[*-2]] } ... *; say @h[^10];

[16:01] <p6eval> b 1b7dd1: OUTPUT¬´1123345566‚ê§¬ª

[16:02] <Util> colomon: I *think* so; I had not thought of it in those terms until this conversation.

[16:02] <colomon> rakudo: my @h := 1, 1, -> *@h2 { @h2[*-@h2[*-1]] + @h2[*-@h2[*-2]] } ... *; say @h[^10];

[16:02] <p6eval> rakudo 8f1f5d: OUTPUT¬´No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:‚ê§:(Mu, Mu %_)‚ê§‚ê§  in method Numeric at src/gen/CORE.setting:614‚ê§  in sub infix:<-> at src/gen/CORE.setting:1976‚ê§  in whatevercode <anon> at /tmp/ZnhUJVAHrU:1‚ê§  in method postcircum‚Ä¶

[16:02] <jnthn> decommute

[16:02] *** bluescreen10 left
[16:02] <colomon> I believe that code I just tried definitely represents a nom-bug

[16:03] <colomon> niecza: my @h := 1, 1, -> *@h2 { @h2[*-@h2[*-1]] + @h2[*-@h2[*-2]] } ... *; say @h[^10];

[16:03] <p6eval> niecza v11-24-gcdd4e66: OUTPUT¬´1 1 2 3 3 4 5 5 6 6‚ê§¬ª

[16:03] <Util> But what is the alternative? Force finite-but-lazy lists to generate their entire sequence whenever anything outside the gen.func. uses [*-5]?

[16:03] <colomon> Util: yes

[16:04] <colomon> I mean, consider   my @a := $str.comb;  say @a[*-1]

[16:04] <colomon> shouldn't that return the same value as my @a = $str.comb;  say @a[*-1]

[16:04] <colomon> ?

[16:06] <Util> colomon: hmmm. Yes. And, ($fh.lines)[*-5] would have to read the whole file to work as expected.

[16:06] <colomon> right

[16:07] *** jnthn left
[16:07] *** vmspb left
[16:08] <Util> colomon: I see your point. Can you think of any situation where a generating function could usefully access * where * is the last element?

[16:09] <colomon> Util: the real last element?  not really.

[16:09] <benabik> Hm.  Rakudo doesn't like slurpy blocks for generators.

[16:09] <benabik> nom, at least.

[16:09] <colomon> but remember, there's nothing at all special about a generating function.

[16:09] <colomon> benabik: yeah, that would be a nom bug.

[16:10] <benabik> It's a useful trick though.

[16:11] <Util> I think that having * mean "size so far" withing a sequence's code block (gen.func.) is agreeable, given that *'s usual meaning is not useful (and maybe even nonsensical) there.

[16:11] <benabik> But would you transform every * inside the generator?  Or do you want to spec that generator functions have to know what variable they're operating on?

[16:12] <benabik> niecza: my @x := 0,1,-> *@x { +@x } ... *; say @x[10] # works, but you have to be explicit

[16:12] <p6eval> niecza v11-24-gcdd4e66: OUTPUT¬´10‚ê§¬ª

[16:14] <colomon> I really think that, as much as it would be elegant, having @h[ ] behave specially if you are generating @h at the time seems like a very bad idea.

[16:14] *** bluescreen10 joined
[16:14] *** sayu left
[16:15] <colomon> I mean, what if instead of saying 1, 1, { @h[*-@h[*-1]] + @h[*-@h[*-2]] }, you said sub generate() { @h[*-@h[*-1]] + @h[*-@h[*-2]] }; 1, 1, &generate

[16:16] * colomon is imagining the nightmare of trying to implement this...

[16:16] <sorear> what is @h?

[16:16] *** am0c left
[16:16] <colomon> b: my @h := 1, 1, -> *@h { @h[*-@h[*-1]] + @h[*-@h[*-2]] } ... *; say @h[^10];

[16:16] <p6eval> b 1b7dd1: OUTPUT¬´1123345566‚ê§¬ª

[16:17] <sorear> @h doesn't even exist until ... returns

[16:17] <Util> colomon: What nightmare? It *used* to work! (and still does in Niecza) :)

[16:17] <masak> sure it exists.

[16:17] <sorear> you have to use the temp value that ... gives you, via the slurpy param

[16:17] <Util> sorear: it is bound, not assigned.

[16:17] <masak> it exists from the point of its declaration.

[16:17] <sorear> my @h := 1, 1, { @h[*-1] } will never work

[16:17] <colomon> Util: that would be what is known as an accident

[16:17] <sorear> masak: the variable exists, but the array that will become known as @h doesn't

[16:18] <sorear> s/variable/name/

[16:18] <benabik> The two "simple" ways I see to do it is to special case generators on the RHS of bindings or to set a flag in the list before calling the generator.

[16:18] <Util> BTW, The Q sequence (as opposed to Fibonacci) needs this because each next element does not rely on the last element, nor the last two, nor even the last N elements. It uses the last two elements to *find* which two elements to add together to get the next number.

[16:18] <Util> Now that I write that, I see that it could shorten the solution to:

[16:18] <Util>     my @h := 1, 1, { @h[*-$^a] + @h[*-$^b] } ... *; say @h[^10];

[16:18] <colomon> niecza: my @h := 1, 1, { @h[*-1] } ... *; say @h[^10]

[16:18] <p6eval> niecza v11-24-gcdd4e66: OUTPUT¬´1 1 1 1 1 1 1 1 1 1‚ê§¬ª

[16:18] *** kaare_ joined
[16:18] <masak> sorear: you can bind infinite lazy lists to array variables in Perl 6.

[16:19] <sorear> cute accident

[16:19] <sorear> cognominal: pong

[16:19] <masak> sorear: the question here is only whether @h[*-1] means "length so far" or "infinite length" for such an array.

[16:19] <benabik> I wonder why it works.

[16:19] <masak> er, whether the '*' means that.

[16:20] <sorear> masak: I'm suprised it works, I thought I implemented * to be eager.

[16:20] <colomon> Util: If you just add -> *@h  to your generator function, it should work fine (not the latest version).

[16:20] <masak> sorear: yes, eagerness was what I assumed as well.

[16:20] <cognominal> sorear? I did not ping you.

[16:21] <benabik> It seems to be eager outside the generator and lazy inside.  Somehow.

[16:21] <benabik> niecza: my @x := 1, { @x[*-1] } ... *; say @x[1]; say @x[*-1]

[16:21] <p6eval> niecza v11-24-gcdd4e66: OUTPUT¬´(timeout)1‚ê§¬ª

[16:22] <sorear> cognominal: oh, hmm

[16:22] <colomon> Going off at a slight angle here: it seems to me what is really wanted is a way to find out how many elements currently exist in a lazy list/array.  That would provide a potential solution here and enable other useful code, too.

[16:22] <sorear> cognominal: I got an email from github with the From: line munged to St√©phane Payrard.  github--

[16:23] <sorear> masak: having re-checked the code, eagerness looks like it's correctly implemented.  WTF?

[16:23] <Util> colomon: hmmm. interesting (re: -> *@h). Would that also require a special case, since a slurpy array would change the lazy list to eager?

[16:24] <benabik> Util: I believe the generator isn't passed the full list.  It's explicitly passed "the list so far".

[16:24] <colomon> Util: no, because in a generating function, -> *@h gets everything generated so far, by spec

[16:24] <benabik> (Or rather, the last N elements of the list so far, which is all of them in the slurpy case)

[16:25] <colomon> right, -> $a { } gets the last element, -> $a, $b { } gets the last two, -> *@a { } gets everything so far

[16:25] <sorear> gotta go now, sorry

[16:26] <cognominal> sorear, I understand, I played with the note interface but I never confirmed anything. Strange because I have never looked the nieca sources.

[16:27] <cognominal> *niecza

[16:27] <colomon> I should add, that's not something special about the generating closure; rather, that's how ... calls it.

[16:28] <benabik> It's odd that the list currently reacts differently to *-1 inside and outside the generators.  I wonder what's causing it.

[16:29] * masak decommutes

[16:29] <Util> colomon, benabik: aha! I missed that in the spec. Thanks!

[16:30] <benabik> It's not just @x[*-1], it's also (perhaps unsurprisingly) +@x that changes.

[16:30] <benabik> niecza: my @x := 0, { +@x } ... *; say @x[1]; say +@x

[16:30] <p6eval> niecza v11-24-gcdd4e66: OUTPUT¬´(timeout)1‚ê§¬ª

[16:30] <benabik> Apologies to whatever machine that's running p6eval.

[16:38] <[Coke]> I don't think *'s meaning changing depending on how far you happen to have gotten is useful.

[16:40] <[Coke]> I could see having some sort of "are you sure you meant to do that eagerly?" warning (similar to a stack depth error)

[16:40] <benabik> [Coke]: The special case seems obnoxious to add to spec.  I'm mostly curious about how it happened by accident in b and niecza.

[16:40] *** sftp left
[16:40] <benabik> I do like that warning though.

[16:41] *** sftp joined
[16:41] <benabik> With lists that are explicitly infinite.  Detecting it in the accidentally infinite case may be difficult.

[16:41] *** mj41 left
[16:50] *** jnthn joined
[16:51] *** bluescreen10 left
[16:54] *** vmspb joined
[16:56] *** sftp left
[17:00] <Util> [Coke]: Now that I know the spec allows for passing the array-so-far, I no longer need * to mean anything special within a sequence's code block.

[17:01] *** Gothmog_ joined
[17:01] *** sftp_ joined
[17:01] * colomon just noticed it has started to snow...

[17:01] <jnthn> ooh

[17:01] <jnthn> none here yet

[17:02] *** donri left
[17:02] <colomon> This is actually our second snowfall of the season.  The first was very, very wet snow, and melted instantly on contact with the ground.  :)

[17:04] *** bluescreen10 joined
[17:04] <colomon> jnthn: where should I add uniq in nom?  List.pm?

[17:04] <[Coke]> we had 2 snowstorms before Halloween.

[17:04] <arnsholt> jnthn: I think the first snow is rapidly approaching though

[17:04] <arnsholt> At least here in Oslo

[17:04] <[Coke]> Can we spell it unique? :P

[17:05] *** birdwindupbird left
[17:05] <jnthn> arnsholt: Yeah, I'm a little south of that... ;)

[17:05] <arnsholt> Yeah, I remembered =)

[17:05] <arnsholt> (The benefits of thinking after talking)

[17:06] <colomon> [Coke]: if you want to change the spelling in roast and the spec, I don't mind changing it.  ;)

[17:09] <jnthn> colomon: Yes, and probably a coercer in Any, as with the other list things

[17:12] *** cognominal left
[17:20] *** MayDaniel joined
[17:20] *** MayDaniel left
[17:20] *** MayDaniel joined
[17:20] <dalek> nqp/nfa: 6395eaf | jnthn++ | tools/build/Makefile.in:

[17:20] <dalek> nqp/nfa: Don't build nqpq by default for now.

[17:20] <dalek> nqp/nfa: review: https://github.com/perl6/nqp/commit/6395eaf854

[17:20] <dalek> nqp/nfa: 1a0cd9f | jnthn++ | t/nqp/50-regex.t:

[17:20] <dalek> nqp/nfa: Revert changes to a test so it works with nqp, rather than nqpq.

[17:20] <dalek> nqp/nfa: review: https://github.com/perl6/nqp/commit/1a0cd9fef0

[17:23] *** mj41 joined
[17:29] <dalek> nqp: 46e0f9e | jnthn++ | src/QRegex/Cursor.nqp:

[17:29] <dalek> nqp: Fix an LTM tie-breaking bug; diakopter++ for spotting.

[17:29] <dalek> nqp: review: https://github.com/perl6/nqp/commit/46e0f9e4ea

[17:29] <dalek> nqp: cecd970 | diakopter++ | src/QAST/ (2 files):

[17:29] <dalek> nqp: move node() from QAST::Regex to QAST::Node; add $!node to QAST::Node

[17:29] *** dalek left
[17:29] <jnthn> heuristic merge detekshun fail

[17:29] *** dalek joined
[17:29] *** ChanServ sets mode: +v dalek

[17:33] <dalek> rakudo/nom: 88f6945 | jnthn++ | src/Perl6/Grammar.pm:

[17:33] <dalek> rakudo/nom: Parse current protoregex syntax; keep older deprecated ones for now, though we'll put a warning in the next * release about them.

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/88f6945e43

[17:33] <dalek> rakudo/nom: 829f9d3 | jnthn++ | src/Perl6/Actions.pm:

[17:33] <dalek> rakudo/nom: Update actions so we can, in theory, handle protoregexes, though the NFA construction explodes for some reason.

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/829f9d3d10

[17:33] <dalek> rakudo/nom: a8b2873 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[17:33] <dalek> rakudo/nom: Add nqpattr cheat used for now by protoregexes implementation, so the NFA builder can get at NFAs for subrules. And with this, we seem to have workingish protoregexes - to the limit of the NFA engine (which still means more powerful than the literal only we had before).

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a8b2873499

[17:33] <dalek> rakudo/nom: e41953a | jnthn++ | src/Perl6/Grammar.pm:

[17:33] <dalek> rakudo/nom: Ensure that regex compiler sees the name of the regex. Fixes use of <sym> in protoregexes, and protoregex.t now passes all but one test (which seems to be unrelated to protoregexes themselves).

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e41953a3b5

[17:33] <dalek> rakudo/nom: 1f3e863 | jnthn++ | tools/build/NQP_REVISION:

[17:33] <dalek> rakudo/nom: Bump to NQP revision with protoregex support.

[17:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f3e863339

[17:33] *** sftp_ left
[17:34] *** sftp_ joined
[17:35] *** orafu left
[17:37] *** orafu joined
[17:40] <dalek> roast: 4418dc5 | jnthn++ | S05-grammar/protoregex.t:

[17:40] <dalek> roast: Todo one test in protoregex.t for Rakudo.

[17:40] <dalek> roast: review: https://github.com/perl6/roast/commit/4418dc57a8

[17:41] <dalek> rakudo/nom: 0fa6613 | jnthn++ | t/spectest.data:

[17:41] <dalek> rakudo/nom: Turn on protoregex.t.

[17:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0fa6613057

[17:41] <dalek> rakudo/nom: de79bac | jnthn++ | docs/ChangeLog:

[17:41] <dalek> rakudo/nom: ChangeLog entry for protoregexes.

[17:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de79bac371

[17:41] <dalek> nqp: e8e4511 | jnthn++ | src/QRegex/ (2 files):

[17:41] <dalek> nqp: Don't emit debug data when doing protoregexes.

[17:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e8e45119d2

[17:46] <colomon> dang, nom compiles slowly

[17:51] *** dakkar left
[17:52] <dalek> nqp: d2b7838 | jnthn++ | tools/build/PARROT_REVISION:

[17:52] <dalek> nqp: Bump to Parrot 3.10 release.

[17:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d2b7838ce8

[17:53] <dalek> rakudo/nom: f50f538 | jnthn++ | tools/build/NQP_REVISION:

[17:53] <dalek> rakudo/nom: Bump to NQP revision which targets the relesae Parrot.

[17:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f50f53886f

[17:54] <colomon> go jnthn!  

[17:54] *** Chillance joined
[17:57] <jnthn> colomon: Relesae won't be for several hours yet.

[17:57] <dalek> rakudo/nom: 9bc820b | jnthn++ | docs/ChangeLog:

[17:57] <dalek> rakudo/nom: Case consistency fix in ChangeLog.

[17:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9bc820beb0

[17:57] <dalek> rakudo/nom: 98d8d9e | jnthn++ | docs/announce/2011.11:

[17:57] <dalek> rakudo/nom: Start to sketch out the 2011.11 announce.

[17:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/98d8d9e710

[17:58] <jnthn> I'm still open to offers to do it, but I've made a start on the process. :)

[17:59] <tadzik> so we have like, nfa and LTM now?

[17:59] <jnthn> tadzik: We have limited NFA/LTM support for protoregexes.

[17:59] <jnthn> tadzik: I have a patch from diakopter++ that adds quantifier support.

[17:59] <colomon> tadzik: I'm working on uniq for you.

[17:59] <tadzik> great!

[18:00] <tadzik> I'll have to do my sql homework first, but then I'm back on panda probably

[18:00] <jnthn> tadzik: There's probably some weird bugs and certainly various missing declarative constructs.

[18:00] *** mberends joined
[18:00] <jnthn> tadzik: Will get onto those post-release.

[18:00] *** mantovani left
[18:00] <jnthn> My plan for up to the release is

[18:00] <jnthn> 1) Fix bigint boolification bug that moritz++ found

[18:00] <colomon> tadzik: IO.copy will be trickier, I think, as the old version calls into pir

[18:01] <jnthn> 2) Some tests for the protoregex LTM stuff that works so far

[18:01] <tadzik> jnthn: is JSON working now?

[18:01] <jnthn> 3) More protoregex LTM stuff all being well, probably diakopter++'s patch if I can

[18:01] <jnthn> tadzik: Not had chance to try it yet.

[18:01] <tadzik> I'll try it after nom

[18:01] <jnthn> tadzik: There are still other regex issues though

[18:01] <jnthn> I'd be surprised if it works right off.

[18:02] <jnthn> But I'm optimistic we can get it working in the near future.

[18:02] <jnthn> (I've got most of tomorrow and the weekend available for Perl 6 stuff :))

[18:02] <tadzik> o/

[18:02] <tadzik> \o/

[18:02] *** cognominal joined
[18:04] <jnthn> colomon: Lemme know if you run into trouble with copy

[18:04] <colomon> jnthn: will do.  not even sure if I'll get that far today, probably depends on how fast I can finish off uniq at this point.

[18:04] <tadzik> most of the brokeness in panda is, suprisingly or not, $! not being inherited and not being set by the default .new

[18:05] <tadzik> I didn't test stuff that it breaks, I thought roast does :>

[18:05] <jnthn> tadzik: er, both of those are Rakudo conforming to the current Perl 6 spec :)

[18:05] *** mantovani joined
[18:05] <colomon> jnthn: what does     proto pick(|$) { * }      mean, anyway?

[18:06] <tadzik> jnthn: I know that :)

[18:06] <colomon> I mean, I think I understand the proto idea, but the |$ and { * } are unclear to me

[18:06] <jnthn> colomon: * means "call into the multi-dispatcher"

[18:06] <tadzik> I wouldn't mind .new doing callsame, tbh

[18:06] <tadzik> oh, that's not the case

[18:06] <jnthn> colomon: |$ means "I take whatever arguments and don't care about binding them"

[18:06] <colomon> ah

[18:07] <jnthn> colomon: Outside of the setting, we auto-generate a proto

[18:07] <jnthn> colomon: Within the setting we need to write them explicitly for now, iirc.

[18:07] <colomon> auto-generation++

[18:07] *** shinobicl left
[18:08] *** sftp_ left
[18:09] *** sftp_ joined
[18:09] <tadzik> oh, I usually used *@a for that

[18:10] <jnthn> tadzik: That only eats positionals though, not names

[18:10] <jnthn> And if you name it, it actually has to allocate an array.

[18:10] <tadzik> I see

[18:10] <tadzik> I use it only for the EVIL 'BUILD-like-moose' hack anyway :)

[18:12] <colomon> > my @array = <a b b c d e b b b b f b>

[18:12] <colomon> a b b c d e b b b b f b

[18:12] <colomon> > @array.uniq

[18:12] <colomon> a b c d e f

[18:12] <colomon> > @array .= uniq

[18:12] <colomon> splice() not implemented in class 'Mu'

[18:12] <colomon> ??????

[18:13] <jnthn> hm

[18:13] <jnthn> colomon: does @array = @array.uniq work?

[18:13] <colomon> no

[18:14] <tadzik> oh, I've seen this bug

[18:14] *** ethndbst left
[18:14] <jnthn> colomon: OK. I doubt it's your .uniq method's fault

[18:14] <colomon> splice isn't called by .uniq

[18:14] <tadzik> nom: my @a = 1, 2, 3; @a = @a.map: { $_ + 1 }

[18:14] <p6eval> nom 8f1f5d: OUTPUT¬´splice() not implemented in class 'Mu'‚ê§  in method reify at src/gen/CORE.setting:3914‚ê§  in method gimme at src/gen/CORE.setting:4276‚ê§  in method eager at src/gen/CORE.setting:4251‚ê§  in method STORE at src/gen/CORE.setting:4690‚ê§  in block <anon> at /tmp/Rgchn2mGoe:1‚ê§  ‚Ä¶

[18:14] *** daniel-s left
[18:14] <jnthn> tadzik: nqp::splice

[18:14] <jnthn> tadzik: The Parrot level op

[18:16] <dalek> roast: 500ac96 | (Solomon Foster)++ | S32-list/uniq.t:

[18:16] <dalek> roast: Fudge for nom.

[18:16] <dalek> roast: review: https://github.com/perl6/roast/commit/500ac965ee

[18:17] <tadzik> I suppose so

[18:21] *** PlusYan left
[18:29] *** sftp_ left
[18:31] *** sftp_ joined
[18:32] *** imarcusthis left
[18:34] *** molaf joined
[18:36] *** imarcusthis joined
[18:36] *** sftp joined
[18:39] <tadzik> t/01-parse.t ...... Failed 1/85 subtests

[18:39] <tadzik> not bad, json

[18:39] *** sftp_ left
[18:39] <tadzik> it fails all the other tests though

[18:39] <jnthn> Only passes parse?

[18:39] <jnthn> But fails actions?

[18:39] <jnthn> OK, probably due to capturing bugs.

[18:39] <tadzik> dunno

[18:40] <tadzik> yes, it seems so

[18:41] <tadzik> also, it seems to have parsed '{' :)

[18:41] *** localhost left
[18:41] <dalek> rakudo/nom: 813c6ae | (Solomon Foster)++ | src/core/ (2 files):

[18:41] <dalek> rakudo/nom: Bring uniq over from b.

[18:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/813c6ae2af

[18:41] <tadzik> colomon++

[18:41] <jnthn> tadzik: Just '{' ?

[18:41] <jnthn> Hm

[18:41] <tadzik> jnthn: so say the tests

[18:42] <jnthn> tadzik: Does it ever fail to parse when it should? :)

[18:42] <tadzik> jnthn: nope

[18:42] <jnthn> As in, it's not just saying everything is ok?

[18:42] *** localhost joined
[18:42] <dalek> rakudo/nom: aa25165 | (Solomon Foster)++ | t/spectest.data:

[18:42] <dalek> rakudo/nom: Turn uniq.t back on.

[18:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa2516554c

[18:43] <tadzik> out of 50 tests that ought to parse, 50 parse

[18:43] <dalek> nqp: 4ec1bdf | jnthn++ | / (3 files):

[18:43] <dalek> nqp: Boolification support for bigints.

[18:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/4ec1bdf93a

[18:44] <dalek> rakudo/nom: 21fcfa3 | jnthn++ | / (2 files):

[18:44] <dalek> rakudo/nom: Switch Int to use bigint boolification, to fix bug found my moritz++.

[18:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/21fcfa3c3f

[18:44] <jnthn> er, by :)

[18:44] <tadzik> :)

[18:47] <dalek> rakudo/nom: adb4caa | jnthn++ | docs/ChangeLog:

[18:47] <dalek> rakudo/nom: Note uniq() in ChangeLog (colomon++).

[18:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/adb4caa1e5

[18:47] <masak> (my moritz)++

[18:48] <jnthn> OK, dinner time, then more regexy stuffs

[18:51] <colomon> jnthn: is there a nom/nqp equivalent to pir::new__PS('File').copy($.path, $dest)  ?

[18:51] *** risou is now known as risou_awy

[18:51] <colomon> (Shoot, wish I'd seen he was going to dinner the second he posted that...)

[18:51] <jnthn> colomon: no

[18:52] <jnthn> colomon: You want something like

[18:52] *** ethndbst joined
[18:52] <jnthn> pir::new__Ps('File').copy(nqp::unbox_s($.path), nqp::unbox_s($dest))

[18:52] <colomon> jnthn++

[18:52] <jnthn> er, be sure that $.path and $dest are already Str before you do that

[18:52] <jnthn> If not, coerce them first

[18:52] <jnthn> ~

[18:52] <colomon> yeah

[18:53] <colomon> okay, I can probably make some sense of this, with those terrific clues.  :)

[18:54] *** sftp left
[18:55] *** sftp joined
[19:02] <colomon> are there tests for copy somewhere?

[19:03] <colomon> tadzik: you're using copy something like "source-file".IO.copy("destination-filename"), right?

[19:04] <tadzik> colomon: I think so, yes

[19:05] <colomon> Are you doing error checking on the results?  I don't seem to have the return value working yet.  :)

[19:05] <tadzik> doesn't matter :>

[19:05] <tadzik> (for me)

[19:05] <tadzik> it's non-specced anyway

[19:05] <colomon> okay, I can commit what I've got, then.

[19:06] <tadzik> wfm

[19:06] <jnthn> Maybe just try nqp::p6bool around the the thing I gave you for the return value for a start

[19:06] <jnthn> Though should probably fail

[19:06] <colomon> it's doing a try right now, and then looking at $!

[19:06] <colomon> same as in b

[19:08] <jnthn> ah, that's probably ok too :)

[19:08] *** MayDaniel left
[19:08] <jnthn> er, right even. :)

[19:08] <jnthn> (since Parrot probably throws)

[19:09] <colomon> except I tried "not a file".IO.copy("hah!"), and it dutifully returned True.

[19:09] <benabik> Did it create hah!?

[19:09] <colomon> so something in there isn't signaling an error properly.

[19:09] <colomon> nope

[19:11] <dalek> rakudo/nom: c294ae6 | (Solomon Foster)++ | src/core/IO.pm:

[19:11] <dalek> rakudo/nom: Add IO.copy.

[19:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c294ae6bf7

[19:13] *** eiro_ left
[19:13] *** sjn left
[19:13] *** geekosaur left
[19:13] *** Khisanth left
[19:13] *** Grrrr left
[19:13] *** Util left
[19:13] *** nsh_ left
[19:13] *** shachaf left
[19:13] *** breinbaas left
[19:13] *** Bucciarati left
[19:13] *** diakopter left
[19:13] *** charsbar__ left
[19:13] *** LoRe left
[19:13] *** kranius left
[19:13] *** chitragupt left
[19:13] *** Grrrr joined
[19:13] *** diakopter joined
[19:13] *** sjn joined
[19:13] *** breinbaas joined
[19:13] *** shachaf joined
[19:13] *** Bucciarati joined
[19:13] *** kranius joined
[19:13] *** nsh_ joined
[19:13] *** Khisanth joined
[19:13] *** Util joined
[19:13] *** LoRe joined
[19:13] *** charsbar__ joined
[19:13] *** chitragupt joined
[19:14] *** geekosaur joined
[19:14] <colomon> tadzik: okay, you have uniq and IO.copy.  :)

[19:14] <tadzik> colomon: thanks you :)

[19:15] <tadzik> now panda/builder.t hangs :)

[19:18] <colomon> progress!

[19:18] <[Coke]> we have a hanging spectest in t/spectest.data also (that's commented out and not normally run)

[19:19] * [Coke] will find which one...

[19:19] *** molaf left
[19:19] <[Coke]> .... whoops. no, just super slow. ;)

[19:20] <[Coke]> jnthn: t/spec/S05-grammar/protos.t is now running (but failing 3/4 tests.)

[19:23] * [Coke] will hold off on fudging that one just yet.

[19:38] *** pyrimidine joined
[19:54] *** mj41 left
[19:54] <jnthn> [Coke]: Yeah, the underlying bug there really needs fixing

[20:08] *** fsergot joined
[20:08] <fsergot> hi o/

[20:08] <fsergot> :)

[20:08] <jnthn> hi, fsergot 

[20:09] *** Transformer joined
[20:12] *** Transformer left
[20:12] <masak> hi, fsergot 

[20:15] <dalek> roast: 8917946 | jnthn++ | S05-grammar/protoregex.t:

[20:15] <dalek> roast: A few basic protoregex LTM tests.

[20:15] <dalek> roast: review: https://github.com/perl6/roast/commit/8917946edf

[20:23] <dalek> nqp: 89ecefb | jnthn++ | src/QRegex/NFA.nqp:

[20:23] <dalek> nqp: Apply patch from diakopter++ that adds support for ?, + and * quantifiers to LTM.

[20:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/89ecefb345

[20:23] <tadzik> nom: try { die; CATCH {} }

[20:23] <p6eval> nom c294ae: OUTPUT¬´‚ê§  in block <anon> at /tmp/yWJWrwcd6v:1‚ê§  in block <anon> at /tmp/yWJWrwcd6v:1‚ê§  in <anon> at /tmp/yWJWrwcd6v:1‚ê§¬ª

[20:23] <dalek> roast: 31d0182 | jnthn++ | S05-grammar/protoregex.t:

[20:23] <dalek> roast: Some basic LTM plus quantifier tests.

[20:23] <dalek> roast: review: https://github.com/perl6/roast/commit/31d01820a2

[20:23] <tadzik> huh?

[20:24] <tadzik> hangs locally

[20:24] *** ksi joined
[20:24] <tadzik> also, eats CPU like crazy

[20:24] <jnthn> tadzik: You are running Parrot 3.10, not Parrot head, yes?

[20:24] <tadzik> head

[20:24] <jnthn> that's why

[20:24] <tadzik> I shouldn't

[20:24] <tadzik> ?

[20:25] <jnthn> mls++ landed a branch related to exceptions

[20:25] <jnthn> and Rakudo needs a patch for it

[20:25] <jnthn> But we can't apply it until post release.

[20:25] <tadzik> I understand

[20:25] <tadzik> damn, I created the 'list' tag again

[20:25] <jnthn> heh

[20:26] <tadzik> I fall for that one all the time

[20:26] * jnthn has created the 'delete' branch at least twice by now ;)

[20:26] <tadzik> I shouldn't drink and read IRC at the same time

[20:27] <tadzik> another words, I lol'd ;0

[20:27] <tadzik> :)

[20:27] *** cooper joined
[20:28] <colomon> as long as that doesn't involve beer coming out of your nose, no worries, I figure!

[20:31] <dalek> nqp: 1db768d | jnthn++ | src/QRegex/NFA.nqp:

[20:31] <dalek> nqp: Add missing handling in NFA engine of CODEPOINT_NEG and CHARLIST_NEG.

[20:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1db768d1b9

[20:38] *** snearch joined
[20:40] *** eiro joined
[20:41] <dalek> nqp: 131f8e7 | jnthn++ | src/QRegex/NFA.nqp:

[20:41] <dalek> nqp: Handle CHARCLASS and CHARCLASS_NEG case in NFA engine, so things like \d and \W work with LTM.

[20:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/131f8e791b

[20:43] <dalek> rakudo/nom: 6178be7 | jnthn++ | tools/build/NQP_REVISION:

[20:43] <dalek> rakudo/nom: Bump to NQP revision with latest NFA bits.

[20:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6178be7082

[20:44] <dalek> roast: e3a23f0 | jnthn++ | S05-grammar/protoregex.t:

[20:44] <dalek> roast: Couple more LTM tests.

[20:44] <dalek> roast: review: https://github.com/perl6/roast/commit/e3a23f0a63

[20:48] *** MayDaniel joined
[20:48] <tadzik> t/panda/builder.t t/panda/fetcher.t and t/panda/tester.t all pass :)

[20:49] <tadzik> colomon++ # picking up LHF

[20:49] <jnthn> \o/

[20:49] <tadzik> some failungs in installer.t, plus the lack of Test::Mock

[20:50] <masak> phenny: de "failung"?

[20:50] <phenny> masak: "failung" (de to en, translate.google.com)

[20:50] <masak> :)

[20:50] <tadzik> :)

[20:50] <tadzik> does that mean anything in german?

[20:50] <jnthn> OK so...the release

[20:50] <jnthn> Anybody want it? :)

[20:50] <masak> jnthn++ # volunteering

[20:51] <jnthn> :P

[20:51] <tadzik> lol

[20:51] <jnthn> I was asking if anybody wanted to do it :)

[20:51] <masak> jnthn: it's great of you to just step up like that.

[20:51] <jnthn> OK, I'll take that as a "no, jnthn, go ahead and find out how the release process doesn't work on Windows"

[20:51] <jnthn> er

[20:51] <jnthn> If somebody wants to help me

[20:51] <jnthn> Please could they run tools/contributors.pl

[20:52] <masak> oh, it's your first release? nice!

[20:52] <PerlJam> When was the last time anyone did a release on windows?

[20:52] <jnthn> Since that doesn't seem to work out here

[20:52] <jnthn> PerlJam: er, Inf ago I suspect ;)

[20:52] <tadzik> jnthn: I can pick it up after I finish my sqls

[20:52] <jnthn> tadzik: OK

[20:52] <jnthn> hmm...and we need a Pm group too :)

[20:52] <jnthn> er

[20:52] <jnthn> PM group

[20:52] <jnthn> :)

[20:53] <PerlJam> That's always the hardest part about the release -- choosing the name

[20:53] <tadzik> make it Warsaw :)

[20:53] <jnthn> oh

[20:53] <jnthn> London.pm hasn't had one named for it

[20:53] <jnthn> And the LPW was pretty good :)

[20:54] <tadzik> oh, and someone could run the spectests for me, it'll take like 45 minutes here

[20:54] <jnthn> And there were Perl 6 talks

[20:54] <tadzik> ...on linux too, if you could :)

[20:54] <tadzik> can be London

[20:54] <jnthn> +1

[20:54] <tadzik> but first, oraclefun

[20:54] <jnthn> will udpate stuffs

[20:54] <jnthn> tadzik: -Oenterprise ;)

[20:54] <jnthn> Or -Oevil ;)

[20:54] <arnsholt> I can run the spectests on Linux if it's needed

[20:54] <jnthn> arnsholt: the more the merrier :)

[20:54] <arnsholt> I've some cores to spare, now I'm just writing stuff

[20:55] <tadzik> jnthn: -Ohomework :)

[20:55] <PerlJam> Hmm.  distributed release ... "construction" is interesting.

[20:55] <arnsholt> Just test on HEAD, or some particular revision?

[20:55] <ethndbst> Perl makes me laugh. </random>

[20:55] <tadzik> arnsholt: HEAD I suppose

[20:55] <jnthn> PerlJam: ?

[20:55] <arnsholt> M'kay

[20:55] <tadzik> as in, the release'd be on HEAD

[20:56] <tadzik> oh, and nqp release

[20:56] <tadzik> gah

[20:56] <PerlJam> jnthn: doing the individual parts of a release on different machines.

[20:56] <jnthn> tadzik: I can take care of the NQP one

[20:56] <jnthn> tadzik: well, maybe :)

[20:56] <jnthn> The tagging at least

[20:56] <tadzik> (:

[20:56] <tadzik> would be great

[20:56] <tadzik> well, I'll start that in an hour at best

[20:57] <tadzik> depending on the bugability of my ENTERPRISE SQL QUERIES

[20:59] <PerlJam> It would also be interesting if we had a "release machine".  A box (virtual or otherwise) somewhere that you could issue a single command and it would run through the automatable parts of the release process,  then submit a package for a human to okay.  Once the human checks off, it automatically creates the release, updates wikipedia, rakudo.org, etc.

[20:59] <PerlJam> might make a good gsoc project :)

[21:00] <moritz> \o

[21:00] <jnthn> o/ moritz 

[21:00] <tadzik> PerlJam: maybe the individual scripts would be a good gci projects

[21:00] <dalek> rakudo/nom: d0f6d27 | jnthn++ | docs/ (2 files):

[21:00] <dalek> rakudo/nom: Update release guide and announce with choice of London.pm.

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d0f6d27946

[21:00] <PerlJam> tadzik: could be.

[21:00] <moritz> quick note re JSON::Tiny: it relies on ~ in a few places, so protoregex suport alone won't make it run

[21:01] <moritz> (though it's easy-ish to patch not to rely on it)

[21:04] * moritz disappears again

[21:07] <jnthn> tadzik: The ChangeLog and announce should be largely in shape-ish

[21:07] <jnthn> Everyone: feel free to check the announce

[21:07] <dalek> rakudo/nom: 5390ac6 | jnthn++ | docs/ChangeLog:

[21:07] <dalek> rakudo/nom: Note copy in the ChangeLog.

[21:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5390ac6ec2

[21:07] <jnthn> https://github.com/rakudo/rakudo/blob/nom/docs/announce/2011.11

[21:07] <tadzik> jnthn: thanks

[21:08] *** daxim_ left
[21:09] <jnthn> NQP release tagged

[21:10] <dalek> rakudo/nom: b9526c6 | jnthn++ | tools/build/NQP_REVISION:

[21:10] <dalek> rakudo/nom: Set NQP_REVISION to 2011.11.

[21:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b9526c650d

[21:10] <masak> "amongst the schedule" -- it's fine English, but I just want to point out how silly English is to allow "amongst" to mean "in" :P

[21:11] <jnthn> :P

[21:11] <arnsholt> jnthn: Linux spectest is pass on HEAD

[21:11] <masak> jnthn: you could also fill yourself in as the release manager for #46 in the release guide.

[21:12] <jnthn> masak: er, I think tadzik++ intends to finish it up :)

[21:12] <masak> oh, ok.

[21:12] <masak> tadzik++

[21:12] <jnthn> Yeah, the remaining bits are...er...not so fun on Windows ;)

[21:13] <jnthn> evalbot rebuild nom

[21:13] <p6eval> OK (started asynchronously)

[21:14] <benabik> Rakudo passes basic tests on OS X 10.7.  Starting spectest.

[21:14] <tadzik> oh, we pass basic test :)

[21:15] <tadzik> benabik: did that run podtest?

[21:15] <benabik> tadzik: Whatever make test runs.

[21:15] <benabik> I'll run podtest too, but it'll be a bit slow with the parallel spectest in the other Terminal.

[21:17] <benabik> tadzik: It passes other than t/pod/why.t which failed to parse.

[21:20] <tadzik> oh!

[21:21] <tadzik> works locally

[21:21] <benabik> The extra 4GiB of memory really help out running spectest in parallel.

[21:21] <tadzik> benabik: can you paste the output?

[21:22] <benabik> Hm.  GC failure now...

[21:22] <tadzik> not this shit again

[21:22] <jnthn> :/

[21:22] * jnthn thought we'd caught those

[21:22] <jnthn> benabik: Got a bt?

[21:23] <benabik> https://gist.github.com/1374579 <-- failures under prove and directly.

[21:23] *** buubot_backup left
[21:25] <tadzik> the parsefails are new, I didn't see that yet :)

[21:25] <tadzik> also, it seems to be running under Perl 5

[21:25] <benabik> That would probably do it.  :-D

[21:25] <tadzik> te errors are too readable :P

[21:25] <jnthn> benabik: grr...it passes here

[21:26] <jnthn> Under the debugger too

[21:27] <benabik> :-/  Spectest is clean so far.

[21:28] <colomon> benabik: prove -e ./perl6 -v t/pod/why.t   works fine for me.

[21:28] <jnthn> benabik: Platform? bitness?

[21:28] <jnthn> er, I mean, wordsize :)

[21:28] <benabik> OS X 10.7, x86_64

[21:29] <benabik> System libffi, icu4c 4.8.1 from perlbrew

[21:29] <benabik> homebrew, not perlbrew

[21:31] <tadzik> ok, sqls done

[21:31] <tadzik> on to the release

[21:31] <benabik> I compile parrot with --ccflags=-DPARROT_GC_VALIDATE, --optimize, and --debugging=0.  Don't know if those make a difference.

[21:32] <benabik> spectest passed.

[21:32] <tadzik> I do just --optimize

[21:32] <[Coke]> ISTR trying a release on windows and giving up.

[21:33] * benabik rebuilds without PARROT_GC_VALIDATE.  Probably doesn't help the point of "being faster" with optimize.

[21:35] *** MayDaniel left
[21:38] <tadzik> Michael Schroeder is mls?

[21:38] <jnthn> tadzik: yes

[21:39] <tadzik> I assume coto is cotto. Hrm

[21:39] <tadzik> moritz: ping

[21:40] <benabik> t/pod/why.t runs fine without PARROT_GC_VALIDATE

[21:40] <tadzik> odd

[21:41] <benabik> Not unexpected.  It failed at a GC assertion.

[21:41] * jnthn should try building with that at some point

[21:42] <benabik> I like using it because it's caught some "interesting" _before_ segfaults.

[21:42] <benabik> *interesting behavior

[21:43] <dalek> rakudo/nom: 617fef9 | tadzik++ | docs/ (2 files):

[21:43] <dalek> rakudo/nom: Add a new release announcement, update release_guide

[21:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/617fef96eb

[21:44] <tadzik> look through if interested

[21:45] <dalek> rakudo/nom: 90347c1 | tadzik++ | VERSION:

[21:45] <dalek> rakudo/nom: [release] bump VERSION

[21:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90347c1816

[21:45] *** buubot_backup joined
[21:48] <jnthn> nom: grammar yay { proto token TOP { * }; token TOP:sym<x> { proto }; token TOP:sym<y> { \w+ } }; say '\o/ ' ~ yay.parse('protoregexes');

[21:48] <p6eval> nom b9526c: OUTPUT¬´\o/ protoregexes‚ê§¬ª

[21:48] <diakopter> \o/

[21:51] *** fsergot left
[21:55] *** kaare_ left
[22:04] <tadzik> release done

[22:05] <jnthn> yay!

[22:05] <jnthn> tadzik++

[22:06] <tadzik> jnthn++

[22:06] <tadzik> oh, LHF: IO.chmod

[22:06] <tadzik> colomon: still looking for some? :)

[22:07] *** ksi left
[22:13] *** fsergot joined
[22:19] <colomon> tadzik: maybe tomorrow.  got 4 hours of musical activities ahead of me at the moment.  :)

[22:19] <colomon> tadzik++

[22:19] <colomon> \

[22:19] <tadzik> colomon: almost done here, np :)

[22:21] <dalek> rakudo/nom: ecc46f4 | tadzik++ | src/core/IO.pm:

[22:21] <dalek> rakudo/nom: Copy non-specced IO.chmod from b

[22:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ecc46f4bbb

[22:22] <tadzik> aaand installer.t passes :)

[22:22] <jnthn> \o/

[22:22] <jnthn> tadzik: Guess we're blocking on the JSON bits?

[22:22] <jnthn> tadzik: I'll see what I can do about that tomorrow.

[22:22] <tadzik> jnthn: well, I plan on starting a branch using eval and use it for now :)

[22:22] <tadzik> jnthn: how many tadzik-hours is fixing Test::Mock?

[22:23] <jnthn> tadzik: Well, the problem is mostly that $cap ~~ $sig isn't yet re-implemented in nom

[22:23] <jnthn> tadzik: Once that's done, Test::Mock is probably only a tadzik hour or so

[22:23] <jnthn> :)

[22:23] <tadzik> :) how is MAIN working around this?

[22:23] <tadzik> (or is it? :))

[22:24] <jnthn> It's relying on the sig being attached to a sub. Or something. :)

[22:24] <tadzik> (:

[22:25] <jnthn> After a few more regex bits, I'll probably start looking at NCI too

[22:25] <tadzik> hmm, that blocker should only apply when using :$with

[22:25] <tadzik> which I don't

[22:25] <jnthn> Oh.

[22:25] <jnthn> In that case

[22:26] <jnthn> You probably just have to change the meta-object stuff

[22:26] <tadzik> I suppose so

[22:26] <jnthn> A .new probably needs to become .new_type, for example

[22:27] <tadzik> anything special about add_method?

[22:28] <tadzik> as in, how should it cope with $!stuff?

[22:28] <tadzik> self.stuff maybe

[22:29] <masak> $cap ~~ $sig stopped working? oh noes :/

[22:29] <tadzik> err

[22:29] <tadzik> how is the sub in https://github.com/jnthn/test-mock/blob/master/lib/Test/Mock.pm#L76 supposed to have access to private methods?

[22:30] <jnthn> my $mocker = ClassHOW.new; # Metamodel::ClassHOW.new_type;

[22:30] <jnthn> tadzik: her, I guess we cheated back then ;)

[22:30] <tadzik> :P

[22:30] <jnthn> *er

[22:30] <jnthn> tadzik: Remove that for now

[22:31] <tadzik> the privateness I guess?

[22:31] <jnthn> tadzik: yeah

[22:31] <jnthn> oh!

[22:31] <jnthn> Or remove the method entirely

[22:31] <jnthn> And use attribute introspection

[22:31] <tadzik> sounds fun

[22:31] <jnthn> $mock.^attributes(:local)[0].get_value($mock)

[22:31] <jnthn> You know it's [0] because you only added one :)

[22:32] <jnthn> That is, use that in place of $mock!mock_log

[22:32] <jnthn> You can do a similar trick for replacing the broken $!log access I suspect

[22:32] <jnthn> But s/$mock/self/

[22:33] <tadzik> ===SORRY!===

[22:33] <tadzik> Could not find sub 226_1321569184.58398

[22:33] <tadzik> promising :)

[22:33] <jnthn> masak: If you knew how it was implemented in ng, you'd be less "oh noes" :/

[22:33] <jnthn> tadzik: whoa!

[22:34] <tadzik> also, $!log needs to be $.log so we can initialize it in .new

[22:34] <tadzik> but then, has_accessor => False looks odd ;)

[22:35] <jnthn> you leave it as $!log

[22:35] <jnthn> But just pass True instead

[22:35] <jnthn> Well, or initialize it differently :)

[22:35] <jnthn> If you're going to give it an accessor you needn't do all the .^attributes rigmarole

[22:36] <jnthn> But OTOH if the thing has a log method that you're trying to mock, it'll be a problem

[22:36] <jnthn> So I'd call it something a bit less likely ;)

[22:36] <tadzik> :)

[22:36] <tadzik> well, we callsame in it anyway, don't we?

[22:37] <jnthn> callsame?

[22:37] *** kent\n left
[22:37] <tadzik> or not

[22:37] <jnthn> No, we don't callsame :)

[22:37] <tadzik> no, I mixed up

[22:37] <tadzik> nom: my $a = Metamodel::ClassHOW.new_type

[22:37] <p6eval> nom b9526c: OUTPUT¬´Type check failed in assignment to '$a'; expected 'Mu' but got '<anon>'‚ê§  in block <anon> at /tmp/uiRioQjnYj:1‚ê§  in <anon> at /tmp/uiRioQjnYj:1‚ê§¬ª

[22:37] <jnthn> whee

[22:37] <jnthn> Use binding :)

[22:38] <jnthn> And file a Rakudo bug. :)

[22:38] <tadzik> :)

[22:38] * jnthn really needs to write a meta-programming test suite or something

[22:38] <tadzik> then dispatch:<.^> fails on it

[22:38] <tadzik> just .?

[22:39] <jnthn> Do

[22:39] <jnthn> .HOW.

[22:39] <jnthn> e.g. $a.HOW.add_method($a, ...)

[22:39] <jnthn> Both of those are the same issue in a sense

[22:39] <jnthn> It doesn't know it's a Mu by default.

[22:39] <jnthn> well

[22:39] <tadzik> I see

[22:39] <jnthn> It's meant ot be an Any

[22:40] <jnthn> At the moment a newly created type is still "outside of the type system" 

[22:40] <jnthn> Probably need to fine an elegant way to lie, in order to make meta-programming unpainful.

[22:43] <tadzik> hmm, cannot dispatch Foo === Mu

[22:44] <tadzik> nom: class Foo {}; say Foo === Mu

[22:44] <p6eval> nom ecc46f: OUTPUT¬´No applicable candidates found to dispatch to for 'infix:<===>'. Available candidates are:‚ê§:(Any $a)‚ê§:(int $a, int $b)‚ê§:(num $a, num $b)‚ê§:(Int $a, Int $b)‚ê§:(Num $a, Num $b)‚ê§:(Str $a, Str $b)‚ê§:(Any $a, Any $b)‚ê§‚ê§  in block <anon> at /tmp/nNNWxkheDY:1‚ê§  in <anon> at /tmp‚Ä¶

[22:44] <tadzik> b: class Foo {}; say Foo === Mu

[22:44] <p6eval> b 1b7dd1: OUTPUT¬´Bool::False‚ê§¬ª

[22:44] <jnthn> nom: class Foo {}; say Foo =:= Mu

[22:44] <p6eval> nom ecc46f: OUTPUT¬´Bool::False‚ê§¬ª

[22:44] <jnthn> nom: class Foo {}; say Mu =:= Mu

[22:44] <p6eval> nom ecc46f: OUTPUT¬´Bool::True‚ê§¬ª

[22:44] <tadzik> is that a regression, or was it wrong?

[22:45] <jnthn> I suspect we'd want it to auto-thread, so we probably shouldn't define it for Mu.

[22:45] * jnthn vaguely recalls a discussion on this not so long ago

[22:45] <jnthn> Pretty sure the outcome was === should auto-thread.

[22:46] <jnthn> (and so it's defined up to Any === Any)

[22:46] *** envi_ left
[22:54] *** ethndbst left
[23:01] <masak> 'night, #perl6

[23:02] <diakopter> o/

[23:03] <tadzik> o/

[23:03] <tadzik> nom: my $a := Metamodel::ClassHOW.new_type(); $a.HOW.add_attribute($a, Attribute.new(name => '$!foo', has_accessor => True)); my $b = $a.HOW.compose($a); $b.new;

[23:03] <p6eval> nom ecc46f: OUTPUT¬´(signal SEGV)¬ª

[23:04] <tadzik> in-field I get Cannot look up attributes in a type object in Attribute.compose

[23:04] <tadzik> I suppose I'll leave it for jnthn++ :)

[23:04] <jnthn> tadzik: Will give it a look.

[23:05] <jnthn> (though tomorrow)

[23:06] <tadzik> great, thanks

[23:16] <felher> perl6: my $whatevercode = (*-1); say (1,2,3,4)[$whatevercode];

[23:16] <p6eval> rakudo ecc46f, niecza v11-24-gcdd4e66: OUTPUT¬´4‚ê§¬ª

[23:16] <p6eval> ..pugs b927740: OUTPUT¬´1‚ê§¬ª

[23:16] *** sivoais left
[23:16] <felher> nom++, niecza++

[23:16] <felher> Thats nice :)

[23:21] *** icwiener left
[23:25] <tadzik> g'night #perl6

[23:25] <felher> o/ tadzik 

[23:25] <jnthn> 'night, tadzik++

[23:33] <colomon> tadzik++ indeed

[23:37] <diakopter> why is there no way to download parrot 3.10

[23:38] <diakopter> benabik: ^^

[23:38] *** whiteknight joined
[23:38] <diakopter> whiteknight: why is there no way to download parrot 3.10

[23:38] <benabik> ftp://ftp.parrot.org/pub/parrot/releases/devel/3.10.0/

[23:38] <whiteknight> ...there isn't?

[23:38] *** whiteknight is now known as Guest5617

[23:38] <diakopter> it's not linked from http://www.parrot.org/download

[23:39] <Guest5617> hmmm...weird. 3.9.0 directory doesnt seem to be there either

[23:39] <benabik> It's linked to from the release announcement, but the download page still points at 3.8.0!

[23:39] <benabik> 3.9.0 is ftp://ftp.parrot.org/pub/parrot/releases/supported/3.9.0

[23:39] <diakopter> I need to 3.10.0 to work on nqpq

[23:39] * diakopter ftps it

[23:40] <Guest5617> Okay, I verified the tarball is on the server. I'm going to re-trigger the sync

[23:40] <Guest5617> ftp://ftp.parrot.org/pub/parrot/releases/devel/3.10.0/

[23:41] *** Guest5617 is now known as wknight8111

[23:42] *** wknight8111 left
[23:42] *** wknight8111 joined
[23:42] <benabik> I updated the link on /downloads.  diakopter++

[23:45] <dukeleto> what is nqpq ?

[23:46] <felher> is there a way to increase the maximum recursion depth in nom?

[23:46] <jnthn> dukeleto: A (temporary) version of nqp we build with the new regex engine.

[23:46] <jnthn> dukeleto: We can't build it as the actual nqp yet since it's not capable of building itself yet.

[23:46] <dukeleto> also, is the London release cut from nom ?

[23:46] <dukeleto> jnthn: good to know

[23:47] <jnthn> dukeleto: It's all in the same repo as nqp, it's not some big nqp-rx => nqp style transition again. :)

[23:47] <dukeleto> diakopter: in case this happens in the future, there is always: https://github.com/parrot/parrot/tags

[23:47] <jnthn> dukeleto: yes, tadzik++ did it a couple of hours ago :)

[23:48] <dukeleto> tadzik++ # nom.London()

[23:48] <wknight8111> actually, the only file there is the .bz2. I know I definitely uploaded the other archive too

[23:48] <wknight8111> something strange is afoot

[23:50] <benabik> I see a 3.10 .tar.gz as well.

[23:50] *** tokuhirom joined
[23:50] <wknight8111> I just re-uploaded it

[23:50] <diakopter> jnthn: what blocks nqpq from building itself?

[23:51] <jnthn> diakopter: regex engine incompleteness :)

[23:51] <jnthn> diakopter: And then probably a few grammar updates to handle us having real LTM.

[23:52] * diakopter waits patiently for broken tests from jnthn++

[23:53] <jnthn> diakopter: Didn't do them as actual tests, just a file of fail output with a bunch of comments. 

[23:54] <jnthn> diakopter: Here you go: https://gist.github.com/1375006

[23:54] <jnthn> :)

[23:55] *** benabik_ joined
[23:56] <diakopter> jnthn: one way to do ** would be to explode out all the states for each repetition from 0 to min as mandatory then from min+1 to max as optional

[23:56] <jnthn> diakopter: Yeah, explode is perhaps the operative word there ;)

[23:56] <jnthn> But it would indeed work :)

[23:56] <jnthn> diakopter: I didn't put that one in the file, fwiw.

[23:57] <diakopter> I mean, who's going to do repetition ranges of 65536..1048576

[23:58] <jnthn> I suspect that 1, 3, 4, 7 and 8 don't need to actually do anything in the NFA itself, but rather just cope with some extra stuff that can appear in the QAST tree for the regex and know not to bail out and say it's fate.

[23:58] *** benabik left
[23:59] <diakopter> QRegex is so fatalist

[23:59] <jnthn> (e.g. the NFA builder needs to be made aware that some consturcts shouldn't cause nodes to be put in the NFA, but can be safely ignored)

[23:59] <diakopter> k

