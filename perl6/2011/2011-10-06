[00:03] *** icwiener joined
[00:12] *** replore joined
[00:13] *** abercrombie joined
[00:14] <abercrombie> anyone just heard of the apple news?

[00:14] <jnthn> yes :(

[00:18] *** cggoebel left
[00:18] *** risou is now known as risou_awy

[00:18] *** risou_awy is now known as risou

[00:19] <jnthn> sleep time &

[00:19] <dalek> rakudo/nom: dc9ffc4 | jnthn++ | src/ops/perl6.ops:

[00:19] <dalek> rakudo/nom: Avoid spending so much time in realloc. Shaves another ~12% off 'for 1..1000000 { $i++ }'.

[00:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc9ffc44e3

[00:22] *** guidj0s joined
[00:23] *** cggoebel joined
[00:32] <colomon> :(

[00:32] <cognominal> http://www.apple.com/stevejobs/

[00:34] <jlaire> on the front page, too http://www.apple.com/

[00:34] *** risou is now known as risou_awy

[00:35] <cognominal> the nyt has an obituary

[00:37] *** whiteknight joined
[00:43] <dalek> niecza/serialize: 7c3e0f7 | sorear++ | / (4 files):

[00:43] <dalek> niecza/serialize: Reimplement ltm generation, is unsafe trait

[00:43] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/7c3e0f7a0b

[00:45] <colomon> sorear: ping?

[00:48] <sorear> colomon: pong?

[00:48] <colomon> sorear: just wanted to check on the status of the open :w patch.  

[00:48] <colomon> I understand if it's too hacky to add.

[00:48] <colomon> but I need to know whether I should keep my version hacked into my local niecza.  :)

[00:49] <sorear> no it's fine.  I haven't been paying much attention to niecza/master issues

[00:50] <sorear> warning: 4 lines applied after fixing whitespace errors

[00:50] <colomon> hmmm.... I need to remember how to get the "don't commit with whitespace errors" flag set for niecza.

[00:51] <dalek> niecza: 64c5778 | (Solomon Foster)++ | lib/C (2 files):

[00:51] <dalek> niecza: Greatly improved (but still very simplistic) TextWriter class, plus open :w support.

[00:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/64c5778378

[00:51] <colomon> sorear++

[00:51] <sorear> btw, /serialize can now parse the complete setting

[00:52] <colomon> \o/

[00:55] *** Chillance left
[00:58] *** cognominal left
[00:59] *** cognominal joined
[01:05] *** cognominal_ joined
[01:06] *** donri joined
[01:07] *** cognominal___ joined
[01:07] *** cognominal_ left
[01:08] *** cognominal left
[01:23] *** jlaire_ joined
[01:23] *** jlaire_ left
[01:26] *** whiteknight left
[01:37] <dalek> niecza/serialize: 4648202 | sorear++ | / (4 files):

[01:37] <dalek> niecza/serialize: Miscellaneous fixes, setting completely compiled

[01:37] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/4648202d60

[01:38] *** benabik joined
[01:54] <sorear> o/ benabik

[01:54] <benabik> o/ sorear 

[02:00] <benabik> sorear: How's things?

[02:00] *** Sarten-X left
[02:01] <sorear> good

[02:04] *** kmwallio joined
[02:08] *** Sarten-X joined
[02:22] *** Trashlord left
[02:22] *** Trashlord joined
[02:24] *** Trashlord left
[02:25] *** Trashlord joined
[02:26] *** wolfman2000 left
[02:33] *** cggoebel left
[02:39] *** static_perl joined
[02:43] *** silug left
[03:09] *** kmwallio left
[03:43] *** icwiener left
[03:49] *** vlixes joined
[03:57] *** abercrombie left
[03:58] *** molaf joined
[03:59] *** envi_laptop joined
[04:04] *** flussence_ joined
[04:07] *** flussence left
[04:25] *** envi_ joined
[04:27] *** envi_laptop left
[04:33] *** daniel-s joined
[04:40] *** silug joined
[04:41] *** guidj0s left
[04:44] *** envi_ left
[04:52] <dalek> niecza/serialize: febfdd9 | sorear++ | / (4 files):

[04:52] <dalek> niecza/serialize: More misc fixes, can now run q[ say "Hello, world" ]

[04:52] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/febfdd9fe2

[04:55] *** envi_ joined
[05:00] *** alvis left
[05:01] <sorear> Phase 1 complete.

[05:01] <TimToady> \o/

[05:03] <sorear> Phase 2 will involve implementing serialization

[05:04] *** sftp left
[05:09] *** sftp joined
[05:17] *** alvis joined
[05:45] *** SHODAN joined
[06:02] <moritz> wow, every single headline on the hackernews front page is about steve jobs somehow

[06:03] <m6locks> aye, g+ also filled

[06:03] <m6locks> seems like he had an impact

[06:07] <tadzik> yeah, 10 first links

[06:11] <m6locks> a nice quote from the man

[06:11] <m6locks> “Your time is limited, so don't waste it living someone else's life. Don't be trapped by dogma - which is living with the results of other people's thinking. Don't let the noise of other's opinions drown out your own inner voice. And most important, have the courage to follow your heart and intuition. They somehow already know what you truly want to become. Everything else is secondary.” 

[06:11] * moritz resist the urge to write a "Steve Jobs is dead. Now get over it" post

[06:12] <m6locks> well i guess we need to give them this day 

[06:22] *** koban joined
[06:33] * sorear sleep

[06:44] *** replore left
[06:54] *** GlitchMr joined
[06:58] *** sftp left
[07:07] *** amkrankruleuen left
[07:10] *** envi_ left
[07:27] <masak> sorear: the O(A^-1(N)) bound is with "both optimizations" on the naive version of that algorithm. someday I'd like to understand the proof of that, but your talk about mortals sounds discouraging. :)

[07:27] *** dark_x left
[07:27] <masak> sjohnson: I'm on the third book of TAoCP now. it is what you make of it, I'd say. there's just so much in there, but at least for me reading isn't enough -- I have to do some of the exercises to grok the chapter text.

[07:27] *** dark_x joined
[07:30] *** baest joined
[07:35] *** vlixes left
[07:45] *** baest left
[07:45] <moritz> flussence_: re https://gist.github.com/1179681 what does :ignore mean? that the ignored thing is passed through? or that it is caught, but not counted as an exception?

[07:47] *** dark_x left
[07:48] *** dark_x joined
[07:53] *** baest joined
[08:05] <masak> moritz: your answer is here, it seems: https://github.com/sorear/niecza/blob/master/lib/Test.pm6#L127

[08:06] <masak> the ignored things are caught, but still counted as success.

[08:13] *** sftp joined
[08:15] *** Trashlord left
[08:40] *** static_perl left
[08:41] <moritz> I think we've discussed shell aliases before

[08:41] <moritz> alias g=git

[08:41] <moritz> I found I never use it, because if I do, the tab completion for the git command stops working

[08:42] <moritz> is there an easy-ish way to enable them for the alias?

[08:42] <moritz> ie I want  g fet<tab>  to give me  g fetch  just like it works with  git fet<tab>

[08:43] <avar> complete -p git

[08:43] <avar> then enter that command with s/git$/g/

[08:43] <avar> w ~ (master=) $ complete -p git

[08:43] <avar> complete -o bashdefault -o default -o nospace -F _git git

[08:43] <avar> w ~ (master=) $ complete -o bashdefault -o default -o nospace -F _git g

[08:43] <avar> w ~ (master=) $ g sta

[08:43] <avar> sta      stage    staged   stash    status

[08:44] <masak> avar++

[08:44] <moritz> avar++

[08:44] <avar> alias g=git

[08:44] <avar> $(complete -p git | sed s/git$/g/)

[08:44] <moritz> #perl6 is always good for general programming-related knowledge :-)

[08:44] <avar> should work if you put it in your .bashrc

[08:45] <masak> moritz: it's where having a hundred lurkers pays off :)

[08:45] <moritz> masak: aye :-)

[08:46] * masak would like to sometimes give a talk on the disjoint-set data structure

[08:46] <masak> sometime*

[08:46] <moritz> masak: please do that at the GPW 2012 in March in Erlangen, Germany :-)

[08:47] <masak> could do :)

[08:47] <masak> it's an important algorithm in maze-making, but also in Hex and (to a lesser extent) Go.

[08:49] <masak> the speed gets important when one does a lot of move analysis.

[08:55] <dalek> rakudo/convergent-num-rat: 0e351b2 | moritz++ | src/core/Num.pm:

[08:55] <dalek> rakudo/convergent-num-rat: try not to loop infinitely in Num.Rat

[08:55] <dalek> rakudo/convergent-num-rat: review: https://github.com/rakudo/rakudo/commit/0e351b2aec

[08:56] <moritz> could somebody on a 32 bit system please check if the 'now' term still loops on the convergent-num-rat branch?

[08:58] <moritz> it causes some few regression (on the order of 10 failing subtests) which might be worth fixing if that branch actually helps us

[08:59] <moritz> 4 subtests actually :-)

[09:01] *** dakkar joined
[09:03] *** dakkar left
[09:03] * flussence_ does

[09:03] *** flussence_ is now known as flussence

[09:04] *** dakkar joined
[09:22] *** HarryS left
[09:27] <moritz> flussence: any results?

[09:27] <flussence> still compiling :)

[09:27] <moritz> wow.

[09:28] *** orafu left
[09:28] *** orafu joined
[09:29] *** wamba joined
[09:37] <masak> rakudo: role A[] {}; role A[::T] {}; say A[A].new

[09:37] <p6eval> rakudo dc9ffc: OUTPUT«A<-2625399358932644392>␤»

[09:42] <masak> nom: given <row your boat gently down the stream merrily life is like a drem> { say (.[0] x 3, .[1, 2]); say .[3..6]; say .[7] x 4; say .[8..12] }

[09:42] <p6eval> nom dc9ffc: OUTPUT«rowrowrow your boat␤gently down the stream␤merrilymerrilymerrilymerrily␤life is like a drem␤»

[09:42] <masak> hm.

[09:42] <masak> nom: given <row your boat gently down the stream merrily life is like a drem> { say (.[0] xx 3, .[1, 2]); say .[3..6]; say .[7] xx 4; say .[8..12] }

[09:42] <p6eval> nom dc9ffc: OUTPUT«row row row your boat␤gently down the stream␤merrily merrily merrily merrily␤life is like a drem␤»

[09:42] <masak> \o/

[09:42] <moritz> masak++ # perl 6 poetry

[09:42] <masak> :)

[09:43] <masak> seems I can't spell "dream", however...

[09:43] <moritz> artistic freedom

[09:45] *** mishin joined
[09:45] <felher> masak: yeah, mortiz is right. As a poet, just call it neologism ;)

[09:47] <sbp> it's occasionally spelt that way in Scots

[09:47] <moritz> sbp: I only know 'dram' in the context of Scotland, and that's usually used when referring to beverages :-)

[09:48] <sbp> hehe. I'm assuming it's dream in "His drem all hail he haith disclosit, / The houre, the nyght, and al the circumstans"

[09:48] *** dark_x left
[09:49] <masak> "drem" sounds like a power drill brand.

[09:50] <masak> but sbp++ clearly wins in the poetry department.

[09:50] <moritz> indeed :-)

[09:51] <masak> you know it's good poetry when you can spot quality right through centuries of spelling changes.

[09:53] <sbp> pearl in the Dictionary of the Scots Language has the spellings "perl(l, peirl(e, peirll, peyrl; pearl(e; per(r)il(l; pairill"

[09:53] <sbp> so you could claim that perl is Scots too

[09:53] <sbp> perhaps TimToady has a secret kilt

[09:54] <sbp> (Scots for "cult" no doubt)

[09:54] <masak> "Perl 6: my secret kilt"

[09:55] <sbp> Peyrl6's syntax he haith disclosit

[09:55] * moritz has a Kilt at home, and wears it once per year

[09:55] *** replore joined
[09:55] <sbp> Burns Night?

[09:56] <moritz> sbp: correct :-)

[09:57] <masak> mmm, haggis.

[09:57] <moritz> tasty stuff

[09:57] *** skangas joined
[09:57] <moritz> and the desserts.... sticky toffee pudding is very nice :-)

[09:58] <masak> ooh

[09:58] <sbp> there's a restaurant in Cartmel, not quite in Scotland, where they do a molecular gastronomy meal of sticky toffee pudding: they call it stiffy taffy pudding, and it's the ingredients of one of those puddings served in gelatinous balls

[09:59] <sbp> you put them in your mouth one by one, slowly building up the flavour, making the recipe in your mouth

[09:59] <sbp> sorry, stiffy tacky. photo at http://www.flickr.com/photos/simonrudkin/2546099696/

[10:00] <moritz> nice idea :-)

[10:01] <felher> I guess arrays don't like me, lately... Is this problem already known? :) 

[10:01] <felher> nom: my @array = <a b c d>; @array .= grep: { $_ ~~ /<[a..c]>/ };

[10:01] <p6eval> nom dc9ffc: OUTPUT«splice() not implemented in class 'Mu'␤  in method reify at src/gen/CORE.setting:3657␤  in method gimme at src/gen/CORE.setting:4015␤  in method eager at src/gen/CORE.setting:3991␤  in method STORE at src/gen/CORE.setting:4409␤  in method dispatch:<.=> at src/gen/CORE…

[10:06] *** ggoebel joined
[10:10] <TiMBuS> i uh

[10:10] <TiMBuS> nom: my @array = <a b c d>; @array = @array;

[10:11] <p6eval> nom dc9ffc: OUTPUT«maximum recursion depth exceeded␤  in method infinite at src/gen/CORE.setting:4015␤  in method infinite at src/gen/CORE.setting:3713␤  in method infinite at src/gen/CORE.setting:4025␤  in method infinite at src/gen/CORE.setting:3713␤  in method infinite at src/gen/COR…

[10:11] <moritz> TiMBuS: that one is already submitted

[10:11] <TiMBuS> i see

[10:11] <TiMBuS> but i dont :L

[10:12] <moritz> src/core/ListIter.pm lines 64 to 70

[10:13] <moritz> that can only loop infinitely if nqp::atpos($!rest, 0) is the same as self

[10:14] <TiMBuS> i see now

[10:14] <moritz> both errors seems to imply that there's something fishy about parts of the array being shared in assignment

[10:15] <moritz> nom: my @array = <a b c d>; say @array.DUMP

[10:15] <p6eval> nom dc9ffc: OUTPUT«Array<917942372475947312>(:items(RPA<917942372475951394>(▶"a", ▶"b", ▶"c", ▶"d")), :nextiter(▶Mu))␤»

[10:15] <TiMBuS> and here i thought it might be a low fruit

[10:16] <moritz> it might be, if you're familiar with the list/iterator thingy in general

[10:16] <TiMBuS> augh!

[10:16] <TiMBuS> (thats a no)

[10:17] *** replore left
[10:18] <TiMBuS> when i made my language i just made every list lazy. problem solved

[10:18] <TiMBuS> i also made the entire language lazy

[10:19] <TiMBuS> i built it in my image

[10:19] *** Trashlord joined
[10:20] <felher> Shall i submit the splice()-bug? (email at [email@hidden.address] with subject being the subject of the bug, i guess?)

[10:21] <TiMBuS> needs an rt irc bot

[10:21] <felher> TiMBuS: +1

[10:24] *** HarryS joined
[10:30] *** tzhs joined
[10:41] *** dark_x joined
[10:43] *** dark_x left
[10:46] *** im2ee joined
[10:47] <im2ee> Hello! :)

[10:49] <masak> im2ee: greetings, human!

[10:50] *** envi joined
[10:59] *** benabik left
[11:01] <masak> im2ee: any Perl 6 plans for the day?

[11:01] *** mj41 joined
[11:01] <masak> felher: yes, please do if you haven't already.

[11:02] <masak> felher: quick subject line course: '[BUG] <what doesn't work> in Rakudo'

[11:03] <felher> masak: k, thnx :) i'll do it as soon as i get postfix working with my relay-host :)

[11:04] <masak> nom: sub postfix:<o.O>($value) { say "$value? really!?" }; 42o.O

[11:04] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Confused at line 1, near "42o.O"␤»

[11:05] <masak> std: sub postfix:<o.O>($value) { say "$value? really!?" }; 42o.O

[11:05] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 127m␤»

[11:05] <masak> who's right here?

[11:05] <masak> niecza: sub postfix:<o.O>($value) { say "$value? really!?" }; 42o.O

[11:05] <p6eval> niecza v10-39-g64c5778: OUTPUT«42? really!?␤»

[11:05] <masak> seems STD.pm6 and Niecza are right.

[11:05] * masak submits rakudobug

[11:06] <masak> felher: your "get postfix working" comment just found us a rakudobug! :P

[11:07] <felher> masak: :D!

[11:07] <masak> nom: sub postfix:<!>($n) { [*] 1..$n }; say 5!

[11:07] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Confused at line 1, near "say 5!"␤»

[11:07] <masak> ok, so it's postfix ops in general that don't work yet.

[11:07] <masak> b: sub postfix:<!>($n) { [*] 1..$n }; say 5!

[11:07] <p6eval> b 1b7dd1: OUTPUT«120␤»

[11:09] <masak> nom: our sub postfix:<!>($n) { [*] 1..$n }; say 5!

[11:09] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Confused at line 1, near "say 5!"␤»

[11:09] <masak> ...and it's not that. good.

[11:09] <masak> nom: sub infix:<%%%>($a, $b) { $a / 2 + $b * 3 }; say 4 %%% 7

[11:09] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 1, near "% 7"␤»

[11:10] <masak> ok, so it's not just postfix, it's operator overloading in general.

[11:10] <masak> nom: sub infix:<+>($a, $b) { say "OH overloaded HAI" }; 2 + 2

[11:10] <p6eval> nom dc9ffc: OUTPUT«OH overloaded HAI␤»

[11:11] <masak> ...but it works with operators that already exist.

[11:12] *** espadrine left
[11:26] <felher> masak: is it okay that way: https://rt.perl.org/rt3/Public/Bug/Display.html?id=100830 ?

[11:27] <masak> TimToady: "Everyone is allowed to panic, once." -- you mentioned that the saying has been around from the start of Perl 6, i.e. 2000. but the spec patch about panic is from 2010-01-01...

[11:27] <masak> felher: looks good.

[11:28] <im2ee> masak, hmm, i have to learn physics today, so i don't know that i'll have enought time. :)

[11:28] <felher> felher: good :)

[11:28] <moritz> masak: it wasn't official before, but still best practice (to panic only once)

[11:28] * felher is afk for quite a while

[11:29] <masak> im2ee: if only there were some way to dilate time... :P

[11:29] <masak> moritz: I get that. even better practice, it would seem, would be not to panic at all.

[11:29] <moritz> masak: but that's rather hard, I think

[11:29] * moritz has been close to panic a few times

[11:29] <masak> but I can't recall hearing it before 2010, even unofficially.

[11:31] *** mj41 left
[11:31] *** jferrero left
[11:32] *** mishin left
[11:37] *** Psyche^ joined
[11:39] *** jferrero joined
[11:41] *** Patterner left
[11:41] *** Psyche^ is now known as Patterner

[11:51] <masak> ooh, I actually found a mention from May 2009.

[11:51] *** replore_ joined
[11:52] *** benabik joined
[11:52] <masak> but that's the earliest mention I can find in writing.

[11:56] <masak> given a script file, is there a way to ask the question "is there a process running this script file?" in bash?

[11:56] * masak asks in #bash

[12:00] <masak> I like the FAQ system that they're using over at #bash. it's a bit less human than replying at length in person, but boy is it effective!

[12:00] <masak> for example, the answer to my question was http://mywiki.wooledge.org/BashFAQ/045

[12:00] <masak> triggered by the bot command '!faq mutual > masak'

[12:04] <masak> we should think of getting something like that :)

[12:05] <benabik> masak: That sounds awesome.  I also liked the bot in the #yapc channel that displayed a title for links posted in channel.  I think it also shortened long URLs as well.

[12:06] <masak> we used to have that. it can be nice.

[12:07] <benabik> I suppose it's slightly less needed in a channel where people are unlikely to post horrible things.

[12:07] <masak> yeah.

[12:07] <masak> we don't have that problem. the closest we have is Chatmosphere users ;)

[12:08] <masak> ooh, usink `mkdir` as an exclusive locking mechanism!

[12:08] <masak> using*

[12:12] *** flussence_ joined
[12:12] *** gbacon joined
[12:13] *** flussence left
[12:15] *** kaleem joined
[12:16] *** bluescreen10 joined
[12:18] *** GlitchMr left
[12:21] *** _flussence joined
[12:21] <_flussence> bah, stupid router's gone dead and I can't ssh in :(

[12:21] <_flussence> moritz: tests ran fine, no hangs this time

[12:22] *** flussence_ is now known as flussence

[12:22] <flussence> ah, there we go

[12:22] *** _flussence left
[12:27] <flussence> I'm thinking of writing Text::Tabs from a clean slate, to get rid of the existing baggage ($separator2 is a horrible var name), but I can't figure out what the heck the original algorithm is just by looking at the tests.

[12:30] <flussence> (and at this point, I'm not sure perfectly reproducing it is a great idea)

[12:32] <masak> this is where tests are a nice thing to have.

[12:32] <masak> I'm pretty sure I wouldn't have been able to port PGE to Perl 6 without the ample test suite.

[12:34] <flussence> just wondering if I'm going insane, do the input/output strings on this look reasonable? https://github.com/flussence/Text-Tabs-Wrap/blob/master/t/37000.t

[12:34] <flussence> I'm not sure where it decides to strip an \n off...

[12:35] *** kaleem left
[12:35] *** wamba left
[12:36] <flussence> (99% of these tests are from the p5 original)

[12:40] <flussence> (also note that most of the tests don't currently pass, I was in the middle of a big refactoring)

[12:41] <masak> I have this idea to implement Perl6::Trans for CPAN, providing the .trans function of Perl 6 in Perl 5. is anyone aware of any prior art?

[12:46] <benabik> …  I read that at first as "I want to port Perl6::Trans to perl 6".  The other way around makes more sense.

[12:46] <flussence> I did a quick search; turns up about 2 things that sounded like they *might* be string-related, but they aren't. I say go for it :D

[12:55] <masak> what I want is the one-pass search-and replace with LTM-like behaviour. I wouldn't know how to do that in Perl 5 except for implementing the algorithm I wrote for Rakudo. that tells me there's a need for a module.

[12:57] *** kmwallio joined
[13:00] *** im2ee left
[13:08] <masak> perl6: class A { method x { say "A" } }; class B is A { method x { say "B" } }; class C is A { method x { say "C" } }; class D is B is C { method x { say "D" } }; class E is C { method x { say "E" } }; class F is D is E { method x { say "F" } }; F.new.*x

[13:08] <p6eval> niecza v10-39-g64c5778: OUTPUT«===SORRY!===␤␤NYI dottyop form .* at /tmp/Dr6zDT0kT9 line 1 (EOF):␤------>  is E { method x { say "F" } }; F.new.*x⏏<EOL>␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (COR…

[13:08] <p6eval> ..pugs: OUTPUT«F␤E␤C␤A␤»

[13:08] <p6eval> ..rakudo dc9ffc: OUTPUT«F␤D␤E␤B␤C␤A␤»

[13:08] <masak> rakudo++

[13:08] <masak> niecza: class A { method x { say "A" } }; class B is A { method x { say "B"; nextsame } }; B.new.x

[13:08] <p6eval> niecza v10-39-g64c5778: OUTPUT«B␤A␤»

[13:10] <masak> niecza: class A { method x { say "A" } }; class B is A { method x { say "B"; nextsame } }; class C is A { method x { say "C"; nextsame } }; class D is B is C { method x { say "D"; nextsame } }; class E is C { method x { say "E"; nextsame } }; class F is D is E { method x { say "F"; nextasme } }; F.new.x

[13:10] <p6eval> niecza v10-39-g64c5778: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'nextasme' used at line 1␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 3…

[13:10] <masak> niecza: class A { method x { say "A" } }; class B is A { method x { say "B"; nextsame } }; class C is A { method x { say "C"; nextsame } }; class D is B is C { method x { say "D"; nextsame } }; class E is C { method x { say "E"; nextsame } }; class F is D is E { method x { say "F"; nextsame } }; F.new.x

[13:10] <p6eval> niecza v10-39-g64c5778: OUTPUT«F␤D␤B␤E␤C␤A␤»

[13:10] <masak> rakudo: class A { method x { say "A" } }; class B is A { method x { say "B"; nextsame } }; class C is A { method x { say "C"; nextsame } }; class D is B is C { method x { say "D"; nextsame } }; class E is C { method x { say "E"; nextsame } }; class F is D is E { method x { say "F"; nextsame } }; F.new.x

[13:10] <p6eval> rakudo dc9ffc: OUTPUT«F␤D␤E␤B␤C␤A␤»

[13:11] <masak> hah!

[13:11] <masak> now. should I submit a rakudobug, or a nieczabug? :)

[13:11] * masak submits rakudobug

[13:11] * masak submits nieczabug

[13:12] <masak> actually, from what I know of C3MRO, Rakudo is right here.

[13:13] *** im2ee joined
[13:15] *** _jaldhar joined
[13:16] *** jaldhar left
[13:19] *** _jaldhar left
[13:19] *** _jaldhar joined
[13:21] *** frettled left
[13:27] *** bluescreen10 left
[13:27] <masak> in submitting that ticket, I could find nothing in the spec mentioning C3. but the Wikipedia article about C3 says that Perl 6 uses it, quoting an old Pugs blog post.

[13:27] *** bluescreen10 joined
[13:31] <flussence> rakudo: class A { method a {} }; class B is A { method b {} }; class C is A { method c {} }; class D is B is C { method d {} }; say D.^methods».name

[13:31] <p6eval> rakudo dc9ffc: OUTPUT«d b c a eager elems end classify infinite flat hash list pick roll reverse sort values keys kv pairs Array grep first join map min max minmax postcircumfix:<[ ]> at_pos all any one none postcircumfix:<{ }> reduce ACCEPTS WHERE WHICH WHY Bool so not defined new CREA…

[13:32] <flussence> (I noticed the specs say "^methods lists in MRO order", just checking :)

[13:32] <masak> that appears to work, then.

[13:33] <flussence> and knowing that makes it easier for me to make sense of that huge list it usually returns

[13:34] <flussence> rakudo: class A { method a {} }; class B is A { method b {} }; class C is A { method c {} }; class D is B is C { method d {} }; say D.^methods(:local(3))».name

[13:34] <p6eval> rakudo dc9ffc: OUTPUT«d␤»

[13:34] <flussence> erm

[13:34] <flussence> shouldn't that show more than d()?

[13:35] <masak> maybe :local($n) isn't implemented.

[13:35] <masak> I didn't know such a thing existed...

[13:35] <flussence> niecza: class A { method a {} }; class B is A { method b {} }; class C is A { method c {} }; class D is B is C { method d {} }; say D.^methods(:local(3))».name

[13:35] <p6eval> niecza v10-39-g64c5778: OUTPUT«␤Unhandled Exception: Unable to resolve method methods in class ClassHOW␤  at /tmp/ckfUdpxARi line 1 (MAIN mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2133 (CORE C1024_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2134 (CORE m…

[13:36] <flussence> b: class A { method a {} }; class B is A { method b {} }; class C is A { method c {} }; class D is B is C { method d {} }; say D.^methods(:local(3))».name

[13:36] <p6eval> b 1b7dd1: OUTPUT«d␤»

[13:36] <masak> oh, look S12 has it. cool.

[13:36] <flussence> I think it was one of the more recent additions

[13:37] <masak> though the description 'out $n levels' leaves open the question of whether :local(3) involves the class itself and two levels of parents, or the class itself and *three* levels of parents.

[13:37] <masak> I think the former one would be the sane/consistent one.

[13:38] <flussence> "same as caller()" would be sane, imo :)

[13:38] <masak> also, I can't think of a single use for :private, not even a contrived one.

[13:39] <masak> it's like asking what 'my' subs a class has. even with that information, I can't call them.

[13:39] <flussence> unless you're within the class...

[13:39] *** wamba joined
[13:40] <masak> then I would use a little technique known as "reading the source code" :P

[13:41] <colomon> Gasp!  Not the source code!!

[13:41] <masak> but yeah, point. maybe I have some weirdo use case where I need to iterate over all the private methods and call each one once...

[13:42] <masak> as moritz++ once blogged, lack of imagination is not grounds for forbidding a given usage ;)

[13:45] *** GlitchMr joined
[13:45] <moritz> you generally want information about private stuff when serializing an object or a class

[13:46] <masak> http://perlgeek.de/blog-en/perl-6/real-world-strikes-back.html

[13:47] <masak> moritz: right, but private methods generally don't partake in serialization, do they? conceptually, they sit on the class, not on individual objects.

[13:47] <moritz> masak: so, what if you want to serialize the class?

[13:47] <moritz> sent it to a remote host, deserialize and use it there?

[13:47] *** localhost left
[13:47] <moritz> the class is just an object after all

[13:49] *** dark_x joined
[13:49] *** localhost joined
[13:50] <masak> ah, you mean the ClassHOW object?

[13:50] <moritz> no, the YourClass type object

[13:50] <moritz> ClassHOW will hopefully exist on the remote host too :-)

[13:50] <masak> nom: my @cards = [1, 11], 4, [1, 11]; say @cards.reduce({ @($^a) X+ @($^b) }).perl

[13:50] <p6eval> nom dc9ffc: OUTPUT«(6, 16, 16, 26).list.item␤»

[13:51] <masak> moritz: but type objects are just ordinary objects, except without attributes.

[13:51] <masak> nom: my @cards = [1, 11], 4, [1, 11]; say @cards.reduce({ @^a X+ @^b }).perl

[13:51] <p6eval> nom dc9ffc: OUTPUT«(6, 16, 16, 26).list.item␤»

[13:51] <masak> moritz: ^ simplification in http://perlgeek.de/blog-en/perl-6/blackjack-and-perl-6.html

[13:51] <moritz> masak: hm, maybe we need need to serialize a a ClassHOW object then

[13:51] <masak> you don't need to call the variables $^x and then cast to @, you can just call them @^x :)

[13:54] <masak> I had not seen that blog post before. it seems a nice post to redirect people to who think that junctions are the answer to everything.

[13:58] *** SHODAN left
[14:02] <masak> niecza: .say for [X+] [1, 11], 4, [1, 11]

[14:02] <p6eval> niecza v10-39-g64c5778: OUTPUT«8␤»

[14:02] <masak> oh, the arrays are numified to 2.

[14:02] <masak> niecza: .say for [X+] (1, 11), 4, (1, 11)

[14:02] <p6eval> niecza v10-39-g64c5778: OUTPUT«28␤»

[14:02] <dalek> rakudo/eval-throws: 817dcc2 | moritz++ | src/core/Exception.pm:

[14:02] <dalek> rakudo/eval-throws: make Exception False for now

[14:02] <dalek> rakudo/eval-throws: review: https://github.com/rakudo/rakudo/commit/817dcc277f

[14:02] <dalek> rakudo/eval-throws: f56944f | moritz++ | docs/ChangeLog:

[14:02] <dalek> rakudo/eval-throws: update ChangeLog

[14:02] <dalek> rakudo/eval-throws: review: https://github.com/rakudo/rakudo/commit/f56944fa96

[14:04] <masak> niecza: say ([X+] (1, 11), 4, (1, 11)).perl

[14:04] <p6eval> niecza v10-39-g64c5778: OUTPUT«28␤»

[14:04] *** frettled joined
[14:04] <masak> frettled! \o/

[14:08] <m6locks> any web frameworks for perl6 yet?

[14:09] <m6locks> like this http://snapframework.com

[14:14] <masak> the one listed on modules.perl6.org is https://github.com/supernovus/perl6-www-app/

[14:14] <masak> I haven't tried it.

[14:15] <masak> I know there was some effort, and that mberends++ was a part of it, to port Dancer to Perl 6.

[14:15] *** GlitchMr left
[14:15] <masak> haven't seen any code for that, though.

[14:15] <moritz> I think HTTP::Server::Simple was part of that effort

[14:15] <masak> oh, ok.

[14:19] *** koban left
[14:22] <tadzik> there's my silly port: https://github.com/tadzik/bailador

[14:22] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; .say for 25, { collatz $_ } ... 1

[14:22] <p6eval> nom dc9ffc: OUTPUT«25␤76␤38␤19␤58␤29␤88␤44␤22␤11␤34␤17␤52␤26␤13␤40␤20␤10␤5␤16␤8␤4␤2␤1␤»

[14:23] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; .say for 25, *.&collatz ... 1

[14:23] <p6eval> nom dc9ffc: OUTPUT«25␤76␤38␤19␤58␤29␤88␤44␤22␤11␤34␤17␤52␤26␤13␤40␤20␤10␤5␤16␤8␤4␤2␤1␤»

[14:23] <masak> \o/

[14:24] <moritz> why not just &collatz?

[14:24] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; .say for 25, &collatz ... 1

[14:24] <p6eval> nom dc9ffc: OUTPUT«25␤76␤38␤19␤58␤29␤88␤44␤22␤11␤34␤17␤52␤26␤13␤40␤20␤10␤5␤16␤8␤4␤2␤1␤»

[14:24] <masak> ooh!

[14:24] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; .say for 27, &collatz ... 1

[14:24] <moritz> extra currying considered extra

[14:24] <p6eval> nom dc9ffc: OUTPUT«27␤82␤41␤124␤62␤31␤94␤47␤142␤71␤214␤107␤322␤161␤484␤242␤121␤364␤182␤91␤274␤137␤412␤206␤103␤310␤155␤466␤233␤700␤350␤175␤526␤263␤790␤395␤1186␤593␤1780␤890␤445␤1336␤668␤334␤167␤502␤251␤754␤377␤1132␤566␤283␤850␤425␤1276␤638␤319␤958␤479␤1438␤719␤2158␤1079␤3238␤1619␤4858␤24…

[14:25] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; .say for (27, &collatz ... 1).elems

[14:25] <p6eval> nom dc9ffc: OUTPUT«112␤»

[14:25] <masak> er, that was silly.

[14:25] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; say (27, &collatz ... 1).elems

[14:25] <p6eval> nom dc9ffc: OUTPUT«112␤»

[14:25] <masak> :)

[14:26] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; .say ($_, &collatz ... 1).elems for 2..100

[14:26] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Confused at line 1, near ".say ($_, "␤»

[14:26] <masak> nom: sub collatz($n) { $n % 2 ?? 3*$n + 1 !! $n / 2 }; say ($_, &collatz ... 1).elems for 2..100

[14:26] <p6eval> nom dc9ffc: OUTPUT«2␤8␤3␤6␤9␤17␤4␤20␤7␤15␤10␤10␤18␤18␤5␤13␤21␤21␤8␤8␤16␤16␤11␤24␤11␤112␤19␤19␤19␤107␤6␤27␤14␤14␤22␤22␤22␤35␤9␤110␤9␤30␤17␤17␤17␤105␤12␤25␤25␤25␤12␤12␤113␤113␤20␤33␤20␤33␤20␤20␤108␤108␤7␤28␤28␤28␤15␤15␤15␤103␤23␤116␤23␤15␤23␤23␤36␤36␤10␤23␤111␤111␤

[14:27] <masak> Collatz is a nice example of how very little it takes to create some chaos.

[14:27] <moritz> this is where I start to wish we had SVG output for IRC :-)

[14:28] <masak> hey, it's your logs :P

[14:29] <moritz> but just the logs

[14:36] *** pothos left
[14:37] *** pothos_ joined
[14:37] *** pothos_ is now known as pothos

[14:40] <moritz> nom: enum SVG::Plot::AxisPosition <Zero SmallestValue LargestValue>;

[14:40] <p6eval> nom dc9ffc:  ( no output )

[14:40] *** bluescreen10 left
[14:40] <moritz> weird thing is, putting the same file in lib/SVG/Plot.pm and running 'make' throws the weiredest compilation error

[14:40] <moritz> PAST::Compiler can't compile node of type SVG::Plot::AxisPosition

[14:40] <moritz> make: *** [blib/lib/SVG/Plot.pir] Error 1

[14:41] <moritz> maybe that's related to --target

[14:42] <moritz> yep

[14:44] * moritz submits rakudobug

[14:44] <sorear> masak: I'd like to understand that proof [disjoint-set-forests] someday too.  I enjoy ignoring my limitations

[14:46] <moritz> jnthn: and you now have "owner" privs on the 'perl6' github organization

[14:46] <slavik1> rm -rf *

[14:46] <slavik1> :D

[14:46] <slavik1> ?

[14:46] <slavik1> moritz: does jnthn own you now?

[14:47] <moritz> OWNOEZ

[14:47] <moritz> slavik1: it's slightly less convenient than rm -rf *, but as an owner you can delete all repos from your organization

[14:48] <moritz> nom: my $ = 3; my $ = 5

[14:48] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Redeclaration of symbol $ at line 1, near " = 5"␤»

[14:50] *** slavik1 left
[14:50] *** slavik2 joined
[14:51] <TimToady> maybe we should rename $_ to $   :)

[14:51] <masak> sorear: I had the idea to make a list of things I'd like to grok before 2012 is over :) http://en.wikipedia.org/wiki/Deutsch%E2%80%93Jozsa_algorithm would be on that list.

[14:51] <masak> nom: my $; my $

[14:51] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes at line 1, near " my $"␤»

[14:51] <masak> wtf

[14:51] * moritz would like to grok Perl 6 by end of 2012

[14:52] <masak> std: my $; my $

[14:52] *** wtw left
[14:52] <p6eval> std 20ae3bd: OUTPUT«===SORRY!===␤Unsupported use of $; variable; in Perl 6 please use real multidimensional hashes at /tmp/co7uGWP9VI line 1:␤------> my $;⏏ my $␤Parse failed␤FAILED 00:01 119m␤»

[14:52] <moritz> masak: RT #76986

[14:52] <masak> oh, I guess it doesn't make much sense to declare a $ that way anyway ;)

[14:52] <masak> moritz: yeah; I half-remembered that one.

[14:54] <masak> nom: my @ = 1, 2, 3; my @ = 4, 5, 6

[14:54] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Redeclaration of symbol @ at line 1, near " = 4, 5, 6"␤»

[14:54] <masak> nom: my % = foo => 1; my % = bar => 2

[14:54] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Redeclaration of symbol % at line 1, near " = bar => "␤»

[14:54] <masak> nom: my & = {;}; my & = {; say "OH NOES!" }

[14:54] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Redeclaration of symbol & at line 1, near " = {; say "␤»

[14:55] <moritz> nom: my (@, $);

[14:55] <p6eval> nom dc9ffc:  ( no output )

[14:55] <masak> nom: my (@, @)

[14:55] <p6eval> nom dc9ffc:  ( no output )

[14:55] <moritz> nom: my ($, $);

[14:55] <p6eval> nom dc9ffc:  ( no output )

[14:55] <moritz> nom: my @ ; my @ ;

[14:55] <masak> nom: my ($, @, %, $, @, @, &, &)

[14:55] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Redeclaration of symbol @ at line 1, near " ;"␤»

[14:55] <p6eval> nom dc9ffc:  ( no output )

[14:56] <moritz> nom: my ($a, $a)

[14:56] <p6eval> nom dc9ffc: OUTPUT«===SORRY!===␤Redeclaration of symbol $a at line 1, near ")"␤»

[14:56] *** bluescreen10 joined
[14:56] * masak .oO( eight anonymous variables walk into a sigil )

[14:57] <masak> er, signature*

[14:57] <TimToady> std: my ($a, $a)

[14:57] <p6eval> std 20ae3bd: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $a (see line 1) at /tmp/KMWNsYECJR line 1:␤------> my ($a, ⏏$a)␤ok 00:01 121m␤»

[14:57] <TimToady> STD doesn't consider it a fatal

[14:57] <moritz> rakudo doesn't have compile time warnings at all

[14:58] *** kaleem joined
[14:59] <moritz> does t/spec/S02-lexical-conventions/sub-block-parsing.rakudo fail for anybody besides me?

[15:00] *** tzhs left
[15:00] <ingy> TimToady: you coming to PPW?

[15:01] *** slavik2 left
[15:01] *** slavik1 joined
[15:01] <TimToady> nope

[15:03] <ingy> :'(

[15:05] *** kaleem left
[15:06] <TimToady> t/spec/S02-lexical-conventions/sub-block-parsing.rakudo ... Failed 1/4 subtests  (less 2 skipped subtests: 1 okay)

[15:07] * masak learns that etymologically, "complex" has to do with braiding, while "complicated" has to do with folding

[15:08] *** baest left
[15:09] *** mtk left
[15:09] *** mtk joined
[15:11] * moritz is about to get sick

[15:12] <moritz> sore throat, weird warm/cold perception etc *sneeze*

[15:13] *** GlitchMr joined
[15:13] <PerlJam> moritz: quick! drink some orange juice

[15:13] <dalek> rakudo/nom: 1c2c2d4 | moritz++ | src/Perl6/Actions.pm:

[15:13] <dalek> rakudo/nom: do not complain about double declared anon variables

[15:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c2c2d4545

[15:13] <masak> moritz: gesuntheit

[15:14] <moritz> PerlJam: I have only water available right now, but will be back home in ~30min, then I'll try that

[15:14] <moritz> masak: danke

[15:15] *** espadrine joined
[15:16] *** espadrine left
[15:17] *** espadrine joined
[15:17] <moritz> nom: *.()

[15:17] <p6eval> nom dc9ffc: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Whatever'␤  in <anon> at src/gen/Metamodel.pm:3164␤  in block <anon> at /tmp/WUCKN0KIf7:1␤  in <anon> at /tmp/WUCKN0KIf7:1␤»

[15:17] <masak> PerlJam: 'cus of antioxidants?

[15:17] <moritz> we should give that a better error message

[15:17] <PerlJam> masak: vitamin C

[15:17] *** espadrine left
[15:18] <moritz> along the lines of "you tried to invoke a Whatever, which means your ideas of currying likely don't match ours. See http://short/url for an in-depth explanation"

[15:19] <masak> PerlJam: right. because of vitamin C's role as an antioxidant? :)

[15:20] <TimToady> nom: my $x = *.[2]; say $x([<a b c d>]);

[15:20] <masak> lately I've learned that currying and partial function application are almost opposite things.

[15:20] <p6eval> nom dc9ffc: OUTPUT«c␤»

[15:20] *** espadrine joined
[15:20] <masak> don't remember now where I read it.

[15:20] <PerlJam> masak: they aren't opposites, they just aren't the same thing.

[15:20] <moritz> well, currying is a bit like partial application with a negative arity :-)

[15:21] <PerlJam> There was an article about it recently on one of the perl blogs I do believe

[15:21] <masak> yes.

[15:21] <moritz> the result of currying has more parameters than the input

[15:21] <moritz> the result of partial application has fewer parameters than the input

[15:21] <PerlJam> moritz: that jibes with how I'd describe it:  currying is a specific type of partial function application  :)

[15:22] <masak> currying had something to do with getting away with your language having only one-parameter functions.

[15:23] <masak> this is actually implicit in Haskell's syntax, IIRC.

[15:23] <PerlJam> masak: rampant use of function composition ala Haskell

[15:23] <moritz> my languages has not only one-parameter functions :-)

[15:23] <masak> moritz: :P

[15:23] <moritz> s/es/e/

[15:24] *** espadrine left
[15:24] <mux> having currying support in the language ala haskell, is what allows you to have partial application working without adding any specific feature; they're not the same but they are intimately related

[15:25] <moritz> .oO( they are in the same idea line, but in different quadrants )

[15:25] <masak> hey! a line doesn't have quadrants! :P

[15:25] <mux> "currying supoprt in the language" may be better expressed as masak said, that is saying the currying is implicit in haskell

[15:25] <moritz> masak: well, two

[15:26] <moritz> well, duants more than quadrants

[15:26] <masak> yes. duants.

[15:26] <moritz> just imagine the line being inside a plane :-)

[15:26] <masak> duants singing a duet and having a duel.

[15:26] *** dark_x left
[15:26] <masak> or possibly biants.

[15:27] <PerlJam> dead ants?

[15:27] <PerlJam> adam ants?

[15:27] <sjohnson> bionic ants

[15:27] <masak> fancy ants

[15:27] <sjohnson> ant0r

[15:28] <TimToady> "currying" and "partial function application" are badly huffman coded, relatively speaking

[15:29] <PerlJam> inversely huffman coded (relatively)

[15:29] <PerlJam> :-)

[15:30] <TimToady> the specs use "curry" the wrong way in various places

[15:30] <mux> oh well, some libs even have a curry function/method that actually does partial application

[15:30] <mux> (prototype.js does IIRC)

[15:31] <TimToady> pfa needs a better name

[15:31] *** kmwallio left
[15:31] <mux> it's this kind of things that everyone gets wrong for some reason

[15:31] * TimToady doesn't recall where he picked up the usage

[15:32] <PerlJam> TimToady: it had to have been one of the FP languages.

[15:33] *** espadrine joined
[15:34] <mux> http://www.prototypejs.org/api/function/curry

[15:35] <mux> someone should tell them, some day

[15:36] <PerlJam> if you google "currying partial function application" you'll see lots of articles where people explain the difference or admit confusing about the difference, etc.

[15:39] <masak> I think Perl 6 should set a high standard here.

[15:39] <masak> let's start with the spec.

[15:40] <TimToady> no, I started with rosettacode :)

[15:40] <mikemol> ^^

[15:40] <masak> fairynuff.

[15:41] <TimToady> http://rosettacode.org/mw/index.php?title=Partial_function_application&curid=9391&diff=122352&oldid=114056

[15:42] <TimToady> but before we fix the spec, I'd like to think a bit about whether we can come up with a shorter term for it, like we did for hashes

[15:42] <masak> "uncurry" :)

[15:42] <TimToady> partial function application is even worse than associative array

[15:42] <PerlJam> TimToady: acronyming isn't good enough?

[15:42] <TimToady> pfa!

[15:42] <masak> :P

[15:42] <masak> I think there's prior art for "uncurry", even.

[15:43] <benabik> masak: uncurrying is also wrong.  In functional languages, currying is taking a function (x,y) -> z and getting x -> y -> z and uncurry is the reverse.

[15:43] <TimToady> yes, this ain't uncurrying

[15:43] <masak> ah. dang.

[15:43] <masak> I still don't grok this. :)

[15:43] *** espadrine left
[15:44] <TimToady> partial function application would obviously be funapp or some such :)

[15:45] <masak> ok, currying/uncurrying refers to how the arguments are represented: as distinct arguments, or as tuples. http://www.haskell.org/haskellwiki/Currying

[15:45] <PerlJam> associative array -> hash   was awesome because it became a single, short word.   I don't see that happening for PFA

[15:45] <TimToady> unfortunately, "assuming" is the wrong valence, since you're assuming the args, not the function

[15:46] * TimToady has a gut feeling there's a word there that'll work

[15:46] <mikemol> "Assemble" seems obvious to me.

[15:47] *** Holy_Cow joined
[15:47] *** Holy_Cow left
[15:47] <TimToady> but you're not assembling the function, you're assembling (some of) its arguments

[15:47] <TimToady> so same trouble as "assuming"

[15:47] <mikemol> Freezing?

[15:47] <mikemol> Sticking? Locking?

[15:47] <TimToady> slushing :)

[15:48] <benabik> I seem to recall there was some language that used "with".  &g = &f.with($a)

[15:48] <flussence> .preset?

[15:48] <mikemol> benabik: That seems withering.

[15:48] <TimToady> forcing

[15:48] <mikemol> Feeding?

[15:48] <mikemol> Preparing?

[15:48] <TimToady> mix-uppable with feed operators

[15:48] <PerlJam> conceptual confusion with ... what TimToady said

[15:48] * PerlJam needs to read and type faster :)

[15:49] <mikemol> Prepping. Readying. Priming.

[15:49] <TimToady> priming is nice

[15:50] <mikemol> Kinda opens the way to the title for masak's explanation blog post. "Primer on priming..."

[15:50] <masak> priming! \o/

[15:50] <PerlJam> Are all of the candidates going to be gerunds?

[15:50] <PerlJam> That seems ... odd.

[15:50] *** GlitchMr left
[15:50] <TimToady> "currying"

[15:50] <TimToady> has to also work as a verb

[15:51] * TimToady continues to unashamedly split his infinitives

[15:52] <benabik> TimToady: In public?

[15:52] <masak> "the usefulness of a map is not necessarily a matter of its literal truthfulness, but its having a structure analogous, for the purpose at hand, to the territory" -- paraphrased, Gregory Bateson

[15:52] <PerlJam> Well, I was thinking more like "fill" or something

[15:53] <PerlJam> maybe "bias" ?

[15:53] <TimToady> could be something in that metaphor-space, but filling implies it gets full

[15:53] <TimToady> bias implies you can unbias later

[15:54] <PerlJam> okay, so "priming " sounds best so far  :)

[15:54] <TimToady> maybe something in the "defaulting" space, but that's pretty heavily overloaded

[15:55] <TimToady> and also implies undefaulting, which is wrongish

[15:55] <TimToady> in the sense that an assumed param can't be overridden

[15:55] <flussence> .given? or would the parser flip out at seeing that? :)

[15:55] <TimToady> givening?

[15:55] <flussence> give

[15:55] <TimToady> works not for me :)

[15:56] <sjohnson> heh, reminds me of givening

[15:56] <sjohnson> err, havening

[15:56] <sjohnson> havening from: http://chroniclesofgeorge.nanc.com/

[15:56] <flussence> .oO( argh, seeing that word 3 times in a row made it look odd )

[15:57] <masak> sjohnson: I was thinking of George too! sjohnson++

[15:57] <PerlJam> TimToady: wield?

[15:57] <benabik> Random thought…  Does .assuming (or whatever we're calling it now) accept Whatevers?  so (sub($a, $b, $c) {…}).assuming(1,*,3) gives a one arg function?

[15:57] <sjohnson> oh that silly george

[15:58] <PerlJam> heh ...   &func.apply(a => 3)  #  PFA indeed :)

[15:58] <TimToady> benabik: I had the same thought a minute ago; we'd have to teach .assuming to treat * as a missing arg, is all

[15:59] <PerlJam> or, continuing with mangling PFA ...   partial/partialed

[15:59] <TimToady> but I don't think we can overload apply like that, since "partial application" includes the word "partial" for a reason

[15:59] *** Alias joined
[15:59] <PerlJam> parted? 

[15:59] <masak> TimToady: that solves the age-old problem of .assuming positionals in any order you want! \o/

[16:00] *** risou_awy is now known as risou

[16:00] <moritz> then how do you partially-apply a Whatever?

[16:00] <TimToady> masak: well, in theory Nil would work the same already

[16:00] <TimToady> a Whatever is what you *don't* apply

[16:01] <TimToady> but we could say that Nil is a real arg to .assuming, and forces use of the function's default

[16:01] <TimToady> and use * for skipped arg

[16:02] <masak> moritz: just enclose it in parentheses :P

[16:02] * masak decommutes

[16:02] *** nebuchadnezzar left
[16:03] *** Alias_ joined
[16:04] *** Alias_ left
[16:04] <TimToady> you could always pass a Whatever instead of a *, and make .assuming only respond to defined whatevers

[16:04] *** nebuchadnezzar joined
[16:05] <PerlJam> words to think about :  mould, construct, build, contract, abridge, rive    ... you have to use your imagination a bit to see where I'm going with these :)

[16:06] * TimToady wonders if there's a word that means the opposite of "whatevering"

[16:06] *** preflex_ joined
[16:06] <TimToady> well, since the function is "thinner", you could have "extruding" :)

[16:06] <mikemol> specifying

[16:06] *** preflex left
[16:06] *** preflex_ is now known as preflex

[16:06] <TimToady> specifying is, unfortunately, too overloaded in the culture already

[16:07] <mikemol> exacting. *consults thesaurus*

[16:07] <TimToady> refining

[16:07] <mikemol> +1

[16:07] *** Alias left
[16:07] <mikemol> Has refined taste, unlike my puns.

[16:09] <mikemol> stern

[16:09] <PerlJam> prescribe?  :)

[16:11] *** kaare_ joined
[16:11] *** mberends joined
[16:12] <TimToady> constrain is taken, alas

[16:12] <PerlJam> maybe it's time to troll spanish or french or something

[16:14] <PerlJam> according to google, "zwingen" is german for constrain  :)

[16:15] <Patterner> I'd rather say "forcing someone to do something"

[16:17] <TimToady> .o( arguing with a function :)

[16:20] <TimToady> persuading a function by giving it arguments :)

[16:21] <TimToady> coaxing

[16:21] *** MayDaniel joined
[16:21] <TimToady> teasing

[16:22] <TimToady> priming still works about as well as anything

[16:25] <TimToady> perl6: my &grepʹ = &grep.assuming(* %% 2); say grepʹ 0..9;

[16:25] <p6eval> pugs: OUTPUT«decodeUTF8': bad data: '\697'␤decodeUTF8': bad data: '\697'␤*** ␤    Unexpected "&grep\697"␤    expecting "=", operator, ":", ")", context or "("␤    at /tmp/GFfxe4ABup line 1, column 4␤»

[16:25] <p6eval> ..rakudo 1c2c2d: OUTPUT«0 2 4 6 8␤»

[16:25] <p6eval> ..niecza v10-39-g64c5778: OUTPUT«===SORRY!===␤␤Confused at /tmp/nM7P8VbLm9 line 1:␤------> my &grep⏏ʹ = &grep.assuming(* %% 2); say grepʹ 0.␤␤Parse failed␤␤»

[16:25] <TimToady> rakudo++

[16:26] <moritz> .u ʹ

[16:26] <phenny> U+02B9 MODIFIER LETTER PRIME (ʹ)

[16:26] <TimToady> nom: say 'ʹ' ~~ /\w/

[16:26] <p6eval> nom 1c2c2d: OUTPUT«=> <ʹ>␤␤»

[16:27] <TimToady> nom: say so 'ʹ' ~~ /\w/

[16:27] <p6eval> nom 1c2c2d: OUTPUT«Bool::True␤»

[16:27] <TimToady> nom: say so '′' ~~ /\w/

[16:27] <p6eval> nom 1c2c2d: OUTPUT«Bool::False␤»

[16:27] <TimToady> is what's going on there

[16:28] *** ponbiki left
[16:28] * TimToady cheating by using the wrong prime

[16:29] <benabik> .u ′

[16:29] <phenny> U+2032 PRIME (′)

[16:32] <TimToady> ⁗  <- primal scream therapy

[16:32] <TimToady> .u ⁗

[16:32] <phenny> U+2057 QUADRUPLE PRIME (⁗)

[16:33] <colomon> not a letter?

[16:33] <benabik> nom: say so '⁗' ~~ /\w/

[16:33] <p6eval> nom 1c2c2d: OUTPUT«Bool::False␤»

[16:33] <TimToady> no, alas

[16:34] <TimToady> it would take a special dispensation from the identifier token to recognize them, as we did for - and ' medially

[16:38] <TimToady> and I'm not *quite* ready to throw open the doors to Unicode that wide, but in the long run, I'll want the set opertors in there by default, probably

[16:38] <TimToady> *rat

[16:39] <TimToady> and we should probably recognize civilized single and double quotes for when someone cuts and pastes from an e-book with an over-zealous copyeditor...

[16:43] <TimToady> but our implementations need to get a better handle on processing Unicode efficiently before we force that issue

[16:47] <[Coke]> moritz: auto-unfudge is your baby, yes?

[16:48] <moritz> [Coke]: yes

[16:49] <[Coke]> trying to run it on niecza, and it insists that the tests don't pass in the current state. I commented out the -keep-exit-code (the test does have an exit value of 1), but it's still complaining. Any suggestions?

[16:49] <[Coke]> (I have made a shell script so I can invoke ./perl6, and have copied over tools/perl6-limited.pl)

[16:50] <moritz> [Coke]: I'll look into it later

[16:50] <[Coke]> (only real change to autounfudge was the impl name.

[16:50] <[Coke]> moritz: ok. nothing's committed, so don't go crazy.

[16:50] <[Coke]> I'll have some time to dig in later this evening localtime.

[16:51] <moritz> [Coke]: which OS?

[16:53] *** GlitchMr joined
[16:55] *** dakkar left
[16:59] *** molaf left
[16:59] <dalek> specs: d1124cf | larry++ | S (6 files):

[16:59] <dalek> specs: s/currying/priming/

[16:59] <dalek> specs: 

[16:59] <dalek> specs: Currying really means treating multi-arg functions as compositions

[16:59] <dalek> specs: of single-arg functions, so we should avoid misusing it the way most

[16:59] <dalek> specs: other people misuse it.  :)

[16:59] <dalek> specs: review: https://github.com/perl6/specs/commit/d1124cfe4c

[17:00] <TimToady> next question, should we rename .assuming to .priming?

[17:00] <TimToady> it's shorter :)

[17:00] <colomon> and less clear.  :)

[17:00] <TimToady> indeed, a good argument for not doint ig

[17:00] <TimToady> o.O

[17:01] <TimToady> wow, that was a real brane short-circuit

[17:01] <PerlJam> .assuming has always read well

[17:01] <TimToady> since there are two forms of priming, it's probably just as well not to confuse one of them with the whole

[17:02] <colomon> TimToady: might be worth mentioning currying once or twice next to priming just so people looking for currying don't get lost in the spec.

[17:02] <colomon> afk

[17:02] <PerlJam> why would people look for currying ?  :)

[17:02] <TimToady> they should look for partial function application :)

[17:08] *** mj41 joined
[17:09] <masak> \o/ # home

[17:10] *** PAAC37B joined
[17:11] <tadzik> o/

[17:11] *** pyrimidine joined
[17:13] *** Chillance joined
[17:13] <masak> congratulations on the addition of 'priming' to the vocabulary.

[17:14] <masak> sometimes I feel that the whole Perl 6 effort is as much creating a set of concepts to program by, as it is building a set of implementations to program with ;)

[17:14] <PerlJam> sometimes?

[17:14] <masak> er.

[17:14] <PerlJam> isn't that what language design *is*?

[17:15] <masak> I mean that less inanely than it came out. :P

[17:15] <jasonmay> I know what you mean

[17:15] <masak> maybe that's what language design is. it... it just feels like we do it more than most.

[17:15] * TimToady spreads a layer of anity onto masak++'s utterance

[17:15] <masak> but maybe I'm exhibiting cultural bias and nothing else.

[17:16] <masak> python people: "hey, we invent stuff too! look, we have iterators *and* generators!"

[17:16] <TimToady> we are certainly trying to err on the side of making too many distinctions with Perl 6, on the assumption that if two things are really the same thing underneath, this will become obvious from the implementations

[17:16] <PerlJam> masak: don't forget "look, we have real closures now too"  :)

[17:17] <TimToady> and also on the assumption that we can hide most of the subtler distinctions from newbies at the beginning

[17:17] * mikemol muses over the variety of langauges he's seen, what their purpose is, and what they add.

[17:18] <PerlJam> masak: Perl 6 culture benefits from TimToady's broad experience, where most other languages tend to have a more narrow focus or even if their focus is wide reaching they haven't got the technical know-how to quite pull it all together (PHP for instance)

[17:19] <TimToady> part of Perl's mandate is to change the culture (including the human language) in addition to the computer language

[17:20] <TimToady> but when we coin new usages, we do try to be very careful not to add to the overloading problem that is already rampant in CS culture

[17:22] * PerlJam hands TimToady an spherical object of uniform density.

[17:22] * TimToady has already had many cows in the past

[17:23] <PerlJam> masak: perhaps that's the defining characteristic of Perl 6 culture: it's meta-aware of itself.  :)

[17:23] <TimToady> .oO(Perl 6 is a hyperbolic object of fluctuating destiny...)

[17:24] <mikemol> Beware the hyperbole.

[17:24] <TimToady> You speak too elliptically...

[17:24] *** arthur-_ left
[17:24] <mikemol> I follow the general arc.

[17:25] * TimToady circles the wagons...

[17:25] * mikemol sighs. Sine of the times...

[17:26] <TimToady> hey, that's not a conic section!

[17:26] <mikemol> Heh. Well, enough of this tangent. I've got to focus on work some more.

[17:26] * TimToady tries to make a pun on parables but fales

[17:28] *** daniel-s left
[17:28] *** daniel-s joined
[17:32] *** arthur-_ joined
[17:32] <colomon> PerlJam: Maybe people will be looking for currying because we spent the last N years telling them that was the word for partial function application in p6?  ;)

[17:42] <dalek> specs: 2b77c58 | larry++ | S02-bits.pod:

[17:42] <dalek> specs: mention currying for searchability, colomon++

[17:42] <dalek> specs: review: https://github.com/perl6/specs/commit/2b77c581f9

[17:45] *** daniel-s left
[17:46] *** GlitchMr left
[17:48] <PerlJam> currying:   this is not the word you are looking for.

[17:51] * masak waves an optional parameter suggestively

[17:53] *** zink joined
[17:55] *** mberends left
[17:59] *** MayDaniel left
[18:00] *** Fuad joined
[18:01] <Fuad> hello

[18:03] *** domm joined
[18:04] <sjohnson> Fuad: hi

[18:05] *** mkramer1 joined
[18:08] <[Coke]> moritz: OS X

[18:09] <masak> Fuad: hey man!

[18:10] <Fuad> masak: yo!

[18:10] <masak> yo bro

[18:10] <Fuad> how have you been, bro ?

[18:11] <masak> Fuad: pretty fine. what about you, bro?

[18:11] <Fuad> masak: glad to hear that:) Im doing fine, thanks!

[18:12] <masak> wonderful.

[18:22] *** risou is now known as risou_awy

[18:22] *** risou_awy is now known as risou

[18:25] *** slavik1 left
[18:27] *** mkramer1 left
[18:37] <colomon> TimToady++

[18:39] <sjohnson> colomon: hi

[18:39] <colomon> sjohnson: o/

[18:40] *** risou is now known as risou_awy

[18:43] *** mberends joined
[18:53] *** itz left
[18:54] *** kst` left
[18:58] <[Coke]> ugh. 747 tickets. 40 tickets blocking on tests. wrong direction!

[18:59] <[Coke]> Hey, TimToady, can I throw a spec ticket at you?

[19:00] <TimToady> well, if the answer's not obvious, I'll probably ignore it :)

[19:01] <[Coke]> picking one at mostly random:

[19:01] <[Coke]> https://rt.perl.org/rt3/Ticket/Display.html?id=63778

[19:01] *** GlitchMr joined
[19:01] <[Coke]> Just want to make sure the spec tickets don't starve.

[19:02] <masak> love the title.

[19:03] <masak> pmichaud++

[19:03] <TimToady> that one is not obvious :)

[19:04] <TimToady> but it's probably good to stick it back into my subconscious

[19:04] <masak> sort, min, max

[19:04] <masak> they all have this problem. something about those functions and types that doesn't mesh.

[19:04] <TimToady> all cmp, really

[19:05] <masak> well, yeah.

[19:05] <masak> maybe infix:<cmp> is just a pipe dream.

[19:05] <masak> you can't compare heterogenous types, no matter how much it'd be nice to.

[19:06] <TimToady> well, but one would at least like to not astound the user occasionally

[19:06] <masak> by the way, how do those little val() monsters cmp?

[19:07] <TimToady> which probably means forcing some semantics in the Numeric domain and the Stringy domain

[19:07] <masak> the only time I've seen Perl 6 users astounded by cmp semantics was back in 2009 on szabgab++'s course when some people tried to &sort a list of numbers from lines()

[19:07] *** kst` joined
[19:08] <TimToady> they are considered first of all to be the intuitied type, and stringy as as afterthought

[19:08] <masak> and they got infix:<leg> semantics, of course.

[19:09] <masak> well, that takes care of that problem, at least.

[19:09] <[Coke]> masak: your job is to summarize TimToady's ramblings here into something coherent on the ticket. ;)

[19:09] * TimToady is not going to ramble on the subject of cmp today, having circumnavigated that globe several times already

[19:09] <masak> [Coke]: nothing we've said so far is really relevant to the ticket... :)

[19:10] <TimToady> be happy my backbrane will work on it some more

[19:10] <masak> well, pmichaud's is a really pointed, really good question.

[19:10] <masak> and our answer so far is "ummm...."

[19:10] <masak> :)

[19:11] <masak> this isn't me panicking, by the way. I'm just kvetchin'

[19:11] <TimToady> I don't mind you asking kvetchin's.  :)

[19:11] <masak> I knew you'd say that :P

[19:12] * prammer is reminded of a recent talk that included: doing min() right is actually kinda hard

[19:12] <TimToady> if I'm so predictable, you should tell me what I'll decide about cmp :P

[19:12] <masak> TimToady: maybe I do know but I don't like your decision :P

[19:13] <TimToady> there's something not to like about any way it comes out, like all the various voting systems

[19:13] * masak .oO( the battle... for the FUTURE )

[19:14] <TimToady> maybe we should give cmp instant runoff semantics :)

[19:14] <masak> *lol*

[19:14] <masak> put cmp inside a booth which cannot be compromised.

[19:14] <TimToady> problem is, machine voting is very difficult to secure

[19:14] <masak> so is cmp, it seems.

[19:15] <TimToady> and another problem is that if we ask multiple cores to vote, we're likely to have an even number of cores, and then who gets the tiebreaker?

[19:15] <masak> or rather, there isn't much of a middle ground between "it does too little" and "it does too much".

[19:15] *** espadrine joined
[19:16] <masak> TimToady: the GPU!

[19:16] * masak tweets this

[19:17] <sjohnson> heh

[19:17] <sjohnson> tweeter and the perl6 man

[19:20] <TimToady> If tweeters tweet on twitter, do woofers woof on wiffer?

[19:20] <sjohnson> i think so

[19:21] <tadzik> so _that_'s what a subwoofer is...

[19:21] <sjohnson> Martin Luther King once said, "You've no need to light a nightlight on a light night like tonight."

[19:22] <TimToady> .oO(A Little Night Light Music...)

[19:24] * masak has a light night snack

[19:25] <sjohnson> mmm /me is hungry

[19:25] <TimToady> The narcolpsis strikes! <more>

[19:25] * TimToady falls over asleep.

[19:26] <masak> oh noes, TimToady was struck down by a narcoleptician!

[19:28] * sjohnson pops a brown paper bag

[19:33] *** kst` left
[19:33] *** kst` joined
[19:34] <sjohnson> A tutor who tooted the flute

[19:34] <sjohnson> Tried to tutor two tooters to toot

[19:34] <sjohnson> Said the two to the tutor

[19:34] <sjohnson> "Is it tougher to toot

[19:34] <sjohnson> Or to tutor two tooters to toot?"

[19:35] <tadzik> woot

[19:37] <sjohnson> heh

[19:37] *** bluescreen10 left
[19:37] *** Trashlord left
[19:37] <sjohnson> i would like the know the answer to that question

[19:47] <masak> nom: $_ = 'toot'; s/$/er/; .say; s/oo(.)e/u $0 o/; .say

[19:47] <p6eval> nom 1c2c2d: OUTPUT«tooter␤tu  or␤»

[19:48] <masak> is that a known/submitted bug?

[19:49] *** bluescreen10 joined
[19:55] <[Coke]> when you submit that, you can golf it down to just the 2nd regexp

[19:55] <masak> of course :)

[19:56] <masak> nom: $_ = 'a'; s/(.)/$0/; .say

[19:56] <p6eval> nom 1c2c2d: OUTPUT«␤»

[19:56] * masak submits rakudobug

[19:56] <masak> sjohnson: your poem just found us a rakudobug! :)

[19:56] <sjohnson> nice!

[19:57] <sjohnson> masak++

[19:58] <sjohnson> Masak the Buggy Hunter

[19:59] <masak> it's a doity job. but somebuddy's goita do it.

[20:00] <sjohnson> haha

[20:06] *** gbacon left
[20:06] *** GlitchMr left
[20:09] *** sftp left
[20:11] *** hamza joined
[20:11] *** mkramer joined
[20:11] <hamza> is there any interface to redis or mongo db written in perl6?

[20:12] <masak> it's funny you should ask.

[20:13] <masak> https://github.com/slunski/perl6-simple-redis

[20:14] <hamza> what is funny?

[20:15] <masak> well it's a bit of a coincidence because it was written quite recently.

[20:15] <hamza> oh lol well i guess am lucky man

[20:16] <im2ee> Have to go. :)

[20:16] <im2ee> Good night #perl6! :)

[20:16] <im2ee> 'branoc ! :)

[20:16] <masak> 'branoc!

[20:16] <im2ee> o/

[20:16] <jnthn> 'branoc!

[20:16] <im2ee> \o

[20:16] *** im2ee left
[20:16] <masak> \o/

[20:17] <frettled> masak: Sorry to disappoint you, my imitation of activity came from an auto-rejoin after a server FU. :)

[20:17] *** donri left
[20:18] <sjohnson> phenny: "branoc"?

[20:18] <phenny> sjohnson: Language guessing failed, so try suggesting one!

[20:18] <sjohnson> phenny: "branoc"? esperonto

[20:19] <sjohnson> phenny: "branoc"? esperanto

[20:19] <sjohnson> BAH!

[20:19] <jnthn> sjohnson: Good luck with that. ;-) It's a multi-language pun.

[20:19] <jnthn> sjohnson: dobranoc is Polish for "goodnight"

[20:19] <jnthn> sjohnson: But "bra" in Swedish means good/well. :)

[20:19] <jnthn> So the abbreviation 'branoc sounds kinda cute :)

[20:21] <masak> I had made the connection to Swedish, but I don't think tadzik (who originated the expression here) had.

[20:21] <masak> frettled: doesn't diminish the happiness I feel seeing you :)

[20:21] *** kaare_ left
[20:21] <jnthn> masak: oh :)

[20:21] <tadzik> 'branoc is like 'night

[20:21] <jnthn> Well, I just assume everything is a pun :P

[20:22] <masak> to you, it is :P

[20:22] <frettled> masak: yay \o/

[20:24] *** Fuad left
[20:24] <masak> bra natt, #perl6!

[20:25] *** hamza left
[20:27] *** sftp joined
[20:34] <sjohnson> bronoc => "night 'bros"

[20:34] *** envi left
[20:57] *** huf left
[20:58] *** slavik1 joined
[21:01] *** soh_cah_toa joined
[21:15] *** huf joined
[21:15] *** mkramer left
[21:17] *** bluescreen10 left
[21:17] *** soh_cah_toa left
[21:18] *** soh_cah_toa joined
[21:22] *** espadrine left
[21:28] *** lue joined
[21:41] *** zink left
[21:51] <soh_cah_toa> perl6: class Foo { method foo() { say 'foobar' } }; class Bar { has Foo $.foo .= new handles 'foo' }; my $bar = Bar.new; $bar.foo

[21:51] <p6eval> rakudo 1c2c2d: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[21:51] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ".="␤    expecting trait, "handles", default value or "}"␤    at /tmp/I0i5qETKAZ line 1, column 72␤»

[21:51] <p6eval> ..niecza v10-39-g64c5778: OUTPUT«===SORRY!===␤␤Two terms in a row (method call requires colon or parens to take arguments) at /tmp/6y7dLmEF1A line 1:␤------> ' } }; class Bar { has Foo $.foo .= new ⏏handles 'foo' }; my $bar = Bar.new; $bar␤␤Parse faile…

[21:52] <soh_cah_toa> you can't give a default value to an attribute that handles a method?

[21:53] <soh_cah_toa> or, instantiate in this case. whatever

[21:54] <soh_cah_toa> though, i suppose i could just give $.foo a default value in the signature for new() and still have it handle foo()

[21:54] *** djanatyn joined
[21:56] <soh_cah_toa> perl6: class Foo { method foo() { say 'foobar' } }; class Bar { has Foo $.foo handles 'foo'; submethod BUILD($.foo = Foo.new) { } }; my $bar = Bar.new; $bar.foo

[21:56] <p6eval> niecza v10-39-g64c5778: OUTPUT«===SORRY!===␤␤Action method trait_mod:handles not yet implemented at /tmp/G8HhNN2Es6 line 1:␤------>  class Bar { has Foo $.foo handles 'foo'⏏; submethod BUILD($.foo = Foo.new) { } }␤␤␤Unhandled Exception: Cannot use ha…

[21:56] <p6eval> ..pugs:  ( no output )

[21:56] <p6eval> ..rakudo 1c2c2d: OUTPUT«===SORRY!===␤Package 'Bar' already has a method 'foo'; did you mean to declare a multi-method?␤»

[21:57] *** S11001001 joined
[22:01] <jnthn> has Foo $.foo handles 'foo' = Foo.new

[22:01] <jnthn> The trait has to come before the =

[22:01] <soh_cah_toa> ah, whoops ;)

[22:02] <jnthn> You wouldn't be the first person to trip up on this one :)

[22:02] *** alvis left
[22:02] <soh_cah_toa> btw, why can't 'our' variables be typed?

[22:02] <jnthn> Because it doesn't make sense.

[22:02] <benabik> std: our Int $x; 

[22:02] <p6eval> std 20ae3bd: OUTPUT«ok 00:01 120m␤»

[22:03] <jnthn> Well, yes, it's easy to make it make sense if you don't have to run any code :P

[22:03] <soh_cah_toa> why not?

[22:03] <jnthn> { our Int $foo; } ...far far away but in the same package... { our Str $foo; }

[22:03] <benabik> jnthn: Often std has informative error messages if you try to do something that doesn't make sense.

[22:04] <jnthn> benabik: Yes, though more for parse-y things.

[22:04] <jnthn> I'm pretty sure niecza doesn't let you stick types on our-scoped variables either.

[22:04] <jnthn> niecza: our Str $foo

[22:04] <p6eval> niecza v10-39-g64c5778: OUTPUT«===SORRY!===␤␤Common variables are not unique definitions and may not have types at /tmp/Ua4a5_sK05 line 1 (EOF):␤------> our Str $foo⏏<EOL>␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.se…

[22:04] <soh_cah_toa> jnthn: what are you trying show w/ that example?

[22:05] <jnthn> soh_cah_toa: That "our" declarations are lexical aliases to a variable stored in a package.

[22:05] <jnthn> soh_cah_toa: And you can declare that alias in multiple lexical scopes, and have it refer to the same thing.

[22:05] <jnthn> So you could feasibly end up saying it's Str in one place and Int in another.

[22:05] <jnthn> Which doesn't make a load of sense.

[22:06] <soh_cah_toa> ah, interesting

[22:06] <jnthn> We maybe could find a way to handle is, somehow. Perhaps. But it'd be kinda messy for one, and for another I just don't really see people use our-scoped variables that much.

[22:07] <soh_cah_toa> so when you say 'our $foo' in a lexical scope like in a sub, that doesn't actually declare a new package scoped variable but instead aliases an already declared one?

[22:07] <jnthn> (in Perl 6)

[22:07] <jnthn> soh_cah_toa: Well, it's more like auto-vivification.

[22:07] *** Trashlord joined
[22:07] *** benabik left
[22:07] <jnthn> The package's stash is really just a hash.

[22:07] *** benabik joined
[22:07] <soh_cah_toa> so if there isn't one, then it does create a package-scoped variable

[22:07] <jnthn> Yes.

[22:07] <soh_cah_toa> ok

[22:08] <benabik> .oO( Auto-declaration )

[22:08] <jnthn> It's like you can do

[22:08] *** benabik left
[22:08] <jnthn> nom: module Foo { }; $Foo::x = 42; say $Foo::x

[22:08] <p6eval> nom 1c2c2d: OUTPUT«42␤»

[22:08] *** benabik joined
[22:08] <jnthn> nom: module Foo { }; $Foo::x = 42; say $Foo.WHO<$x>

[22:08] <p6eval> nom 1c2c2d: OUTPUT«===SORRY!===␤Symbol '$Foo' not predeclared in <anonymous> (/tmp/zbL62CT_1c:1)␤»

[22:08] <jnthn> nom: module Foo { }; $Foo::x = 42; say Foo.WHO<$x>

[22:08] <p6eval> nom 1c2c2d: OUTPUT«42␤»

[22:08] <jnthn> Or that.

[22:09] <jnthn> .WHO gives you that underlying hash for the package.

[22:10] <soh_cah_toa> $Foo::x = 42 auto-vivifies, correct?

[22:10] <jnthn> Yes

[22:10] <soh_cah_toa> even outside it's scope? cool

[22:10] <jnthn> $Foo::x = 42 really does compile to Foo.WHO<$x> = 42

[22:11] <jnthn> nom: module Foo { }; say Foo.WHO.^mro # also telling :)

[22:11] <p6eval> nom 1c2c2d: OUTPUT«Stash() Hash() EnumMap() Iterable() Cool() Any() Mu()␤»

[22:11] <jnthn> It really is just a hash.

[22:12] <soh_cah_toa> this may be a noob question but how does Foo.WHO<$x> and $Foo.WHO<$x> differ?

[22:12] <jnthn> $Foo would refer to a variable Foo

[22:12] <jnthn> I thinko'd when I wrote it above

[22:13] <jnthn> Foo refers to a package (provided one is declared)

[22:13] <soh_cah_toa> ah, i thought you need :: for that. as in ::Foo

[22:14] <jnthn> When we compile something like $Foo::x we actually have to pull of the $ and shuffle it over to the $x.

[22:14] <soh_cah_toa> i see

[22:14] <jnthn> *off

[22:15] <jnthn> And $Foo::Bar::x is compiled to something like Foo.WHO<Bar>.WHO<$x>

[22:15] <soh_cah_toa> so does Foo.WHO<$x> = $Foo::x?

[22:15] <soh_cah_toa> ah, you beat me

[22:15] <soh_cah_toa> ok

[22:16] <jnthn> Yeah, $Foo::x is really just a bit of sugar :)

[22:16] <soh_cah_toa> neat ;)

[22:17] <jnthn> Of course, getting Stash.WHO to work took a little knot tying.. :)

[22:17] *** sivoais left
[22:17] <soh_cah_toa> yeah, i can imagine

[22:17] <jnthn> Well, it's still not as bad as knowhow_bootstrapper.c :)

[22:17] <cognominal___> is there a pod2html-ator?

[22:18] <jnthn> cognominal___: As in, Perl 6 Pod?

[22:18] <cognominal___> yes

[22:18] <jnthn> Pretty sure tadzik++ made one as part of his Pod work

[22:18] <jnthn> And used it to render S26 :)

[22:19] <cognominal___> I see only a Pod::To::Text in rakudo.

[22:19] <benabik> https://github.com/perl6/Pod-To-HTML

[22:20] <cognominal___> nice

[22:20] <jnthn> ah, there it is

[22:20] * jnthn was looking on modules.perl6.org

[22:20] * benabik just googled "tadzik pod html". :-)

[22:20] <jnthn> tadzik: Any reason Pod::To::HTML is missing on modules.perl6.org? :)

[22:30] *** mj41 left
[22:33] *** alvis joined
[22:34] * lue debates porting NQP to LLVM to compile rakudo to LLVM or just creating a new P6 compiler on LLVM with himself

[22:36] *** S11001001 left
[22:37] <arnsholt> lue: Effort-wise, porting NQP to LLVM is probably the easier out

[22:37] <arnsholt> And even that is a decidedly non-trivial task I think

[22:38] * soh_cah_toa kinda likes that idea

[22:38] <jnthn> It's strongly desired, but certainly non-trivial.

[22:38] *** Trashlord left
[22:39] * jnthn has spent a little time looking into it

[22:40] <jnthn> LLVM looks really awesome, but it sure is LL. :)

[22:40] *** Trashlord joined
[22:43] <TimToady> maybe .WHO should really be .WHO'S-WHO

[22:44] *** cooper joined
[22:45] <jnthn> o.O

[22:46] <diakopter> the biggest challenge to doing anything like that on LLVM is rolling your own GC

[22:47] <jnthn> diakopter: Yeah.

[22:47] <jnthn> diakopter: LLVM provides appropriate hooks for you to do quite a range of them.

[22:47] <diakopter> oh, good

[22:47] * jnthn has got to the generational chapter in shiny new GC handbook, but didn't get to the concurrent ones yet :)

[22:47] <benabik> http://llvm.org/docs/GarbageCollection.html

[22:48] <jnthn> If I'm gonna write a GC, I at least want the fun of writing a concurrent one. )

[22:48] <jnthn> :)

[22:48] <soh_cah_toa> jnthn: which book?

[22:48] * jnthn fondly remembers his concurrency lecturer

[22:48] <lue> GC==Garbage Collection, right? [just making sure, I'm 99% sure of this]

[22:49] <jnthn> soh_cah_toa: The Garbage Collection Handbook, iirc

[22:49] <jnthn> soh_cah_toa: Was released this August.

[22:49] <jnthn> http://www.crcpress.com/product/isbn/9781420082791

[22:49] <soh_cah_toa> jnthn: richard jones, antony hosking, and eliot moss?

[22:49] <jnthn> yup

[22:50] <jnthn> Certainly the first 7 or 8 chapters are very readable.

[22:50] <soh_cah_toa> nice, i just got it myself. was reading it about 3 minutes ago outside ;)

[22:50] <jnthn> :)

[22:50] * soh_cah_toa was reading about the two-finger compacting algorithm

[22:51] *** replore_ left
[22:51] <soh_cah_toa> would it even be possible for rakudo to use it's own gc and ignore parrot's?

[22:52] <jnthn> heh, you get to bash the threaded compaction into your head next :)

[22:52] <soh_cah_toa> yikes

[22:52] <jnthn> I had to read that one about 3 times before I got it. Then they point out all the disadvantages

[22:52] <jnthn> It's not threaded as in multi-threaded.

[22:53] <jnthn> Just some...exquisite...pointer fiddlery :)

[22:53] <soh_cah_toa> yeah, it's definitely not a light read

[22:53] <jnthn> It could be a much heavier one too; the authors seem good at explaining stuff clearly.

[22:54] <soh_cah_toa> indeed

[22:54] <benabik> soh_cah_toa: With some carefully written ops and dynpmcs you could probably manage a second GC inside of Parrot.  Doesn't sound like a good idea though.

[22:54] <jnthn> I...wouldn't fancy that.

[22:55] <benabik> It probably would be more work than just improving Parrot's GC.  :-)

[22:55] <soh_cah_toa> at that rate, there'd be very little left of rakudo that would be "parrot"

[22:57] <TimToady> old parrot, anyway

[22:58] <TimToady> it might look a lot like new parrot

[22:58] <jnthn> "new parrot"?

[22:58] * jnthn is pretty detached from the Parrot world these days

[22:58] <TimToady> just depends on how much gets borrowed back from Perl 6

[22:58] <TimToady> they're already thinking about 6model

[22:59] <jnthn> Ah, I knew that bit.

[23:00] <TimToady> I think long term Perl 6 is the only thing that is going to save Parrot, because people just aren't that interested in interoperability unless it can be efficient

[23:00] <soh_cah_toa> agreed

[23:01] <jnthn> *nod*

[23:01] <TimToady> and Parrot can't get there without solving the gradual typing problem

[23:02] <jnthn> ...which 6model goes a long way towards doing.

[23:02] <jnthn> But yeah, it'd need pushing deeper, and 6model-JIT integration, I suspect.

[23:02] <TimToady> or something pre-jittable like, presumably something LLVMish

[23:03] <TimToady> modulo grammar

[23:03] <jnthn> Or that.

[23:06] <jnthn> That said, $a + $b if both are native ints actually compiles down to the Parrot add_i_i_i op in the optimizer branch

[23:06] <jnthn> (Compile time resolution of multi-dispatch, followed by inlining)

[23:10] <lue> I think my own P6 compiler would be more fun, but the NQP porting seems, theoretically, to be slightly easier

[23:12] *** wamba left
[23:23] *** aloha left
[23:23] *** aloha joined
[23:23] *** benabik left
[23:37] *** aloha left
[23:38] *** aloha joined
[23:57] *** Chillance left
