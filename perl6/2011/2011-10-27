[00:01] <dalek> std: be1f10e | larry++ | STD.pm6:

[00:01] <dalek> std: parse <[...]> as unbalanced text, not balanced

[00:01] <dalek> std: review: https://github.com/perl6/std/commit/be1f10ee4b

[00:12] <japhb_> Why is Rakudo so much faster starting a REPL session than executing an empty file or empty -e ?

[00:13] <japhb_> On my system, time (echo | ./perl6) => 0.152s while time (echo | ./perl6 -e '') => 0.930s and time (echo | ./perl6 ./test-empty) => 0.939s

[00:21] *** replore_ joined
[00:28] *** shinobicl_ joined
[00:36] <flussence> try running those more than once each

[00:36] *** pat____________ joined
[00:42] <pat____________> perl6: my $foo = {*+*} but "+"

[00:43] <p6eval> niecza v10-66-g71325b0: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/yRms4raP4u line 1:␤------> [32mmy [33m⏏[31m$foo = {*+*} but "+"[0m␤␤␤Unhandled Exception: RoleApply with superclasses NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE infix:<but>…

[00:43] <p6eval> ..pugs b927740: OUTPUT«*** Cannot cast from VStr "+" to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[00:43] <p6eval> ..rakudo 158bd0:  ( no output )

[00:43] <sorear> hello pat

[00:43] <sbp> std: my $foo = {*+*} but "+"

[00:43] <p6eval> std 580b69a: OUTPUT«ok 00:01 122m␤»

[00:43] <pat____________> perl6: my $foo = {*+*} but "+"; say "{~$foo"} ||  {$foo(3,4)}"

[00:44] <p6eval> niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row at /tmp/DOO2l1pQwx line 1:␤------> [32mmy $foo = {*+*} but "+"; say "{~$foo[33m⏏[31m"} ||  {$foo(3,4)}"[0m␤␤Parse failed␤␤»

[00:44] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "\"}"␤    expecting "::", term postfix, operator or "}"␤    at /tmp/U2MpORBoAT line 1, column 37␤»

[00:44] <p6eval> ..rakudo 158bd0: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 1␤»

[00:44] <sbp> /tmp/U2MpORBoAT sounds like a request for Bono to be admitted to Parliament or banished

[00:45] <japhb_> flussence, I did.  Those times were the minimum of 3 for each (and the first in each case was only a few percent worse).

[00:46] <flussence> hm, my bad

[00:46] <japhb_> flussence, no worries, it's an obvious braino check.  ;-)

[00:47] <pat____________> sorry had a date

[00:49] <pat____________> benabik: (from 4 hours ago) yes, but the symbol should be any not used

[00:49] <dalek> niecza/serialize: 9c51257 | sorear++ | lib/ (2 files):

[00:49] <dalek> niecza/serialize: Fix indirect-name package autovivification

[00:49] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/9c51257b31

[00:54] <sorear> down to four failing files

[00:57] *** pernatiy left
[00:57] *** pernatiy joined
[00:57] *** daniel-s joined
[01:17] *** fod joined
[01:18] *** shinobicl_ left
[01:18] *** shinobicl_ joined
[01:25] *** bady joined
[01:27] *** bady left
[01:32] *** alc joined
[01:41] *** pat____________ left
[01:41] *** orafu left
[01:42] *** pat_______ joined
[01:43] *** orafu joined
[01:46] *** fod left
[01:47] *** cognomore left
[01:47] *** cognomore joined
[01:48] *** donri left
[01:49] *** djanatyn is now known as djanatyn|afl

[01:49] *** djanatyn|afl is now known as djanatyn|afk

[01:56] *** alc left
[01:56] *** benabik joined
[01:58] *** fod joined
[01:59] *** alc joined
[02:00] *** whiteknight left
[02:03] *** orafu left
[02:07] *** orafu joined
[02:10] *** japhb_ left
[02:33] <dalek> niecza/serialize: 9f04acf | sorear++ | src/ (4 files):

[02:33] <dalek> niecza/serialize: mergeback

[02:33] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/9f04acf64a

[02:33] <dalek> niecza/serialize: 52fdc3b | sorear++ | / (2 files):

[02:33] <dalek> niecza/serialize: Reimplement compilation of subsets

[02:33] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/52fdc3b020

[02:35] <sorear> perl6: my $foo = Nil; say $foo.perl

[02:35] <p6eval> niecza v10-66-g71325b0: OUTPUT«Any␤»

[02:35] <p6eval> ..rakudo 158bd0: OUTPUT«Nil␤»

[02:35] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/6hsK5Wm3G0 line 1, column 6-14␤»

[02:37] <sorear> Does my $x mean my Any $x?

[02:37] <sorear> niecza/master seems to think so

[02:38] <sorear> niecza/serialize thinks my $x means my Mu $x = Any

[02:38] <sorear> which I thought was correct?

[02:43] *** alester joined
[02:51] *** pat_______ left
[02:54] *** shinobicl_ left
[03:05] <sorear> niecza: "foo" ~~ /<sym>/

[03:05] <p6eval> niecza v10-66-g71325b0: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 613 (CORE warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 21 (CORE Mu.Str @ 12) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/Rx…

[03:05] <sorear> boom

[03:06] *** colomon joined
[03:06] <sorear> o/ colomon 

[03:06] <colomon> \o

[03:07] <sorear> down to 3 failing test files

[03:09] <colomon> in serialization?

[03:09] <colomon> \

[03:09] <sorear> yes

[03:09] <colomon> \o/

[03:12] *** thou left
[03:14] <sorear> colomon: did you see it's fast now too? :D

[03:14] <colomon> no, what?

[03:15] <sorear> the factor-of-3 compile speed regression has been fixed

[03:15] <TimToady> sorear++

[03:15] <colomon> in your branch, right?

[03:15] <sorear> yes

[03:15] <colomon> sorear++

[03:15] <colomon> (because compile time is quite fast on the master branch)

[03:16] <dalek> niecza/serialize: 67f9b80 | sorear++ | src/ (3 files):

[03:16] <dalek> niecza/serialize: Fix /(x|y)/ case; tracking :dba immediately while parsing

[03:16] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/67f9b805ca

[03:16] <sorear> 2 more

[03:16] <sorear> TimToady: what's the current ruling on my $x versus my Any $x versus my Mu $x = Any ?

[03:17] <TimToady> as we last left it, the default value for a container was allowed to be different from its most general type

[03:17] <TimToady> this particularly makes sense for 0-def arrays

[03:17] <TimToady> but nobody implements defaults yet

[03:18] <TimToady> but defaults are required for KeyHash semantics in any case

[03:18] <colomon> afk # bed after a long day of chasing a 3-year-old among fantastic steam engines

[03:18] <TimToady> that it, autodelete semantics when the value goes to the default

[03:20] <sorear> TimToady: niecza/serialize thinks my $x; $x = Nil; results in $x === 

[03:20] <sorear> Mu

[03:28] <TimToady> in terms of where we're headed, normal containers will achieve default values much like S02:2274 talks about parameters

[03:28] <TimToady> they just have to be hung on the declaration somehow

[03:30] <dalek> niecza/serialize: 853ca5d | sorear++ | lib/Kernel.cs:

[03:30] <dalek> niecza/serialize: Fix class A::B {}; class A {}

[03:30] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/853ca5dd09

[03:31] <sorear> TimToady: I'm trying to avoid adding an extra word fo containers

[03:32] <sorear> for now I'll just switch it back to my Any $x semantics

[03:32] <sorear> I didn't intend to change it in any case

[03:33] <TimToady> defaulting containers can mix in

[03:35] <sorear> well there's the question of "my $x" versus "my Mu $x"

[03:36] <sorear> ..weird, it looks like niecza/master actually implemetns an inconsistant mixture of both definitions .:)

[03:42] * sorear begins to wonder what the use case for this is

[03:42] *** soh_cah_toa left
[03:50] *** [particle] left
[03:51] *** alvis left
[03:51] *** [particle] joined
[03:59] *** fod left
[04:02] <sorear> TimToady: what is the anticipated use case for $x = Nil ?

[04:14] *** thou joined
[04:14] *** envi_ joined
[04:27] *** abercrombie left
[04:32] <dalek> niecza/serialize: 9ceaa8e | sorear++ | / (7 files):

[04:32] <dalek> niecza/serialize: Regularize Any/Mu variable handling

[04:32] <dalek> niecza/serialize: 

[04:32] <dalek> niecza/serialize: It turned out that 'type' was not a necessary part of the public

[04:32] <dalek> niecza/serialize: API.  Removing it simplified other things.  Also fixes coretest;

[04:32] <dalek> niecza/serialize: changes Nil to reset variables to Any default.

[04:32] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/9ceaa8e1cc

[04:32] <sorear> all spectest regressions should now be fixed.  running another run to confirm this...

[04:34] <dalek> niecza/serialize: 2a9f24b | sorear++ | / (2 files):

[04:34] <dalek> niecza/serialize: Merge branch 'master' of github.com:sorear/niecza into serialize

[04:34] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/2a9f24b29a

[04:46] <moritz> good morning

[05:04] <sorear> good morning moritz

[05:05] <sorear> looks like I did cause a fail with my fixes for the other fails

[05:05] *** sftp left
[05:07] <sorear> uhm

[05:07] <sorear> S05-grammar/methods.t and RT73680 look bogus

[05:12] *** orafu left
[05:13] *** orafu joined
[05:27] *** packetknife joined
[05:29] <moritz> sorear: what looks bogus about it?

[05:32] <moritz> a grammar is just a class that also inherits from Grammar

[05:33] <moritz> does niecza's Grammar override Mu's .new?

[05:39] <sorear> yeah, I figured that there's no real reason *not* to allow it, even if it won't be very useful

[05:39] <dalek> niecza/serialize: f5dc966 | sorear++ | / (2 files):

[05:39] <dalek> niecza/serialize: Rename Cursor.new to avoid conflicting with code that pretends grammars are classes

[05:39] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/f5dc966e71

[05:39] <sorear> hopefully now there are no spectest failures

[05:40] <sorear> can anyone think of a reason not to merge the branch now?

[05:45] *** lestrrat left
[05:46] *** lestrrat joined
[05:47] *** replore__ joined
[05:48] *** replore_ left
[05:48] *** alester left
[05:51] *** packetknife left
[05:56] *** mtk left
[05:59] *** wtw joined
[06:12] <moritz> moon phase?

[06:22] *** thou left
[06:23] *** mkramer joined
[06:23] *** mkramer left
[06:24] *** wamba joined
[06:26] *** mj41 joined
[06:26] *** mj41_nb joined
[06:28] <tadzik> good morning

[06:29] <sorear> morning tadzik

[06:30] * sorear sleep

[06:32] <masak> good night sorear, good morning tadzik 

[06:33] <masak> random question: which concept do you consider more difficult to grok: OO, or testing?

[06:34] <tadzik> http://en.wiktionary.org/wiki/grok#Verb

[06:34] <tadzik> which variant should I use?

[06:34] <tadzik> To have an intuitive understanding of, or to fully and completely understand?

[06:35] <masak> meant the latter, but the former sounds fine too.

[06:36] <masak> of course, it really means "to drink" :P

[06:36] *** envi_ left
[06:36] <tadzik> I don't think I completely understand either :)

[06:36] <tadzik> when we're at intuitively understanding, I think I'm more towards testing

[06:37] <masak> I'm discussing testing with @quietfanatic on Twitter. a fascinating exchange.

[06:38] <masak> I'm realizing (again) that my view on testing has changed a lot in the past year, much thanks to CQRS.

[06:40] <masak> for example, @quietfanatic said "my app is a game, so my external API is keystrokes and pixels". a year or so ago, I might have thought "oh, right". now I'm thinking "that just isn't so -- the GUI isn't the API".

[06:44] <masak> anyway, the reason for my original question is that I heard a prospective client say yesterday "I spent five years getting used to the idea of OO -- I hope tests don't take as long to learn. :)" and I realize Pugs (and my first experience with immersive testing) happened six years ago.

[06:46] <masak> moritz: [backlogging #phasers more carefully] the Set operators do have ASCII equivalents. TimToady has said that these are the only ones that get imported by default, and for the Unicode ones you have to 'use Set;'

[06:48] *** mj41_nbx joined
[06:48] <Woodi> masak: probably both concepts have few layers... first one for testing is very simple: testing... ok, wil ldo tests :) but first layer of OO is broader i think... and next layers include more teory and more practics so answers can be different. IMO: 'testsing' is simpler, but on your question i will be answer 'testing' becouse there is more unknown behind that...

[06:51] *** SHODAN joined
[06:52] <masak> I guess both concepts are pretty simple if one counts all the un-learning that needs to be done as negative complexity ;)

[06:53] *** koban joined
[06:55] <moritz> masak: I found testing much easier to learn, but then I already had much more programming experience

[06:55] <moritz> masak: I know for sure that testing is easier to explain to my wife

[06:56] <moritz> "we put some data in, and see if the program behaves the right way. We can automate that."

[07:00] <masak> OO could be made quite easy to explain too, I think.

[07:01] <masak> "a program consists in part of what we want to do, and how we do things. if we separate these, it's easier to change (and protect) the how without affecting the what."

[07:02] <masak> ok, that's quite abstract, I guess. :)

[07:04] <masak> diakopter: what I find the most alarming about http://search.cpan.org/~lichtkind/Perl6-Doc-0.36/lib/Perl6/Doc/FAQ/FUD.pod isn't that answers have bitrotted or gotten harder to answer, but that *several of the questions are unanswered*, and that module was last updated in 2008. any casual observer can see that, and draw his own conclusions.

[07:04] <masak> in fact, must draw his own conclusions.

[07:05] <masak> "here, let's make a document where we assuage the concerns of people with doubts -- *alarming question* -- lack of answer"

[07:08] <moritz> masak: you've described modularization, not OO

[07:16] <moritz> at least the way I've learned it, OO needs polymorphism, which doesn't appear in that explanation

[07:23] <masak> also true.

[07:23] <masak> I'll try to do better. :)

[07:25] <masak> "we let data and code travel together, in logical bundles called 'objects'. we know early on about an object's capabilities, but which code is actually run depends on the state and type of the object."

[07:30] <masak> that doesn't cover encapsulation, but encapsulation is not an absolute necessity for OO -- as Perl 5 shows.

[07:34] * moritz still finds the explanatioin for testing much simpler

[07:35] <masak> aye.

[07:36] <moritz> and the mere fact that the first OO explanation didn't cover some essential OO component is also telling :-)

[07:37] <masak> well, it didn't *explicitly* cover it. one could argue that polymorphism is a kind of "changing the how".

[07:44] <masak> nom: class A { method foo { say "OH HAI" } }; A.new.foo

[07:44] <p6eval> nom 158bd0: OUTPUT«OH HAI␤»

[07:44] <masak> nom: class A { method foo($self:D :) { say "OH HAI" } }; A.new.foo

[07:44] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤invoke() not implemented in class 'Capture'␤»

[07:44] <masak> hm.

[07:44] <masak> nom: class A { method foo($self:D:) { say "OH HAI" } }; A.new.foo

[07:44] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤invoke() not implemented in class 'Capture'␤»

[07:45] <masak> D:

[07:45] <masak> I'm assuming this isn't expected behaviour.

[07:45] <masak> is it a bug, or a NYI thing?

[07:47] <masak> nqp: class A { method foo($self:D:) { say("OH HAI") }; A.new.foo

[07:47] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 1, near "($self:D:)"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23698 (src/stage2/gen/NQPHLL.pir:6757) (src/stage2/gen/NQPHLL.pm:329)␤»

[07:47] <masak> ok, that didn't make things clearer :)

[07:50] <moritz> nom: class A { method foo($?CLASS:D:) { say 'oh hai' } }; A.new.foo; A.foo

[07:50] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤In signature parameter, '$?CLASS', it is illegal to use '?' twigil at line 1, near ":D:) { say"␤»

[08:01] *** wamba left
[08:02] <masak> is there any substance to my intuition that the late binding of OO polymorphism is somehow "later" or looser than that of procedural programming?

[08:04] <moritz> well, which procedural programming languages do runtime dispatch?

[08:04] <masak> I guess because if you'd want to emulate run-time polymorphism in procedural code, you'd have to write it out explicitly with (the moral equivalent of) a switch statement. and that's a static thing, in code.

[08:04] <masak> moritz: hm, interesting question. I guess the pattern matching in Haskell is a sort of runtime dispatch, for example.

[08:04] <masak> Erlang has similar facilities.

[08:05] <masak> basically anything with powerful enough multimethods has it.

[08:05] <moritz> does either allow dispatch based on the actual type of something, and not just the declared type?

[08:06] <masak> I don't know about types. I keep thinking of fib as the prototypical example, but it just dispatches on values.

[08:06] <masak> come to think of it, all multi variants of something in Haskell needs to have the same type signature...

[08:06] <masak> (I think.)

[08:07] *** envi_ joined
[08:07] <moritz> the second aspect is that method dispatch looks in different scopes then procedural dispatch

[08:09] <moritz> so somebody can load another class at runtime, and give me an object of that class, and when I call a method on it, it will dispatch to that newly loaded class

[08:09] <masak> oh yes, scoping.

[08:11] *** ab5tract joined
[08:11] <masak> that's what the dot twigil does to attributes and methods -- it switches the scope from being along the 'OUTER' axis to being along the 'nextsame' axis. ish.

[08:11] <moritz> I don't see how that could work in a procedural lang, except by emulating method dispatch tables

[08:11] <masak> right.

[08:19] *** dual joined
[08:25] *** mj41_nb left
[08:25] *** mj41_nbx left
[08:28] *** ab5tract left
[08:34] *** alvis joined
[08:36] *** mberends left
[08:42] *** molaf joined
[08:52] *** am0c left
[08:56] *** dakkar joined
[09:03] <masak> interesting: http://perlmonks.org/?node_id=933680

[09:04] <masak> I'm writing a(nother) talk about languages, parsers, and parsing right now. the kind of input this thread gives is very valuable.

[09:04] <masak> especially seeing the incomprehension of the OP as he tries to understand the replies.

[09:06] <masak> ooh, someone recommended a jnthn++ talk, and (naturally) it helped a lot!

[09:06] <tadzik> :)

[09:06] <tadzik> yeah, noticed that too

[09:08] <masak> many other great recommendations in there too. following up on them now.

[09:10] *** ggoebel left
[09:22] <masak> oh wow, BrowserUk and ikegami can really push each other's testosterone buttons.

[09:22] <moritz> yes, that happens with quite some regularity

[09:23] <moritz> which is rather sad, since both usually have very good replies otherwise

[09:23] <masak> yeah.

[09:23] <moritz> it kinda spoils their record :(

[09:23] <masak> whatever made either, much less both, of them think that the status of "glob" as a word was worth a mud-slinging comment war? :/

[09:24] <masak> it globbles the imagination.

[09:24] <moritz> very globbing indeed

[09:25] * moritz thinks about scraping perlmonks for replies of a depth >= 2, and doing a statistic of how often either or both of them are involved

[09:25] <moritz> erm, depth >= 20

[09:26] <moritz> though on the more productive side, I've been pondering a blog post about the different forms of polymorphism

[09:26] <moritz> inheritance vs. roles/interfaces vs. duck typing vs. structural typing

[09:28] <masak> ooh

[09:38] <mux> vs. parametric polymorphism maybe?

[09:38] <moritz> what is parametric polymorphism? :-)

[09:38] <mux> what procedural people call generics ;-)

[09:39] <jnthn> What parametric roles do.

[09:39] <mux> jnthn: not really no

[09:39] <moritz> mux: the part that I wanted to describe (not too deeply) doesn't really need generics

[09:39] <moritz> I wondered about haskell's typeclasses though

[09:39] <mux> but... that's my favourite form of polymorphism :-P

[09:40] <mux> haskell's type-classes are ad-hoc polymorphism

[09:40] <mux> which is implemented using subtyping in OO languages, at least most of the time

[09:40] <moritz> but decided that they are, in some sense, isomorophic to java's interfaces (people will kill me for that statement, I know)

[09:40] <mux> which is not to say those are equivalent

[09:41] <moritz> mux: ok, I'll make sure to give you a draft of that post to read before publishing it :-)

[09:41] <mux> moritz: cool!

[09:41] <masak> mux: what you say sounds intriguing. maybe you should write a blog post, too! :)

[09:42] <mux> masak: what's intriguing about what I say?

[09:43] <masak> you seem to have a good grasp of how the different types of polymorphism are represented in various programming paradigms.

[09:43] <mux> I just read TAPL ;-)

[09:43] <masak> and also how they (the types of polymorphism) differ from each other.

[09:43] <tadzik> TAPL?

[09:43] <masak> oh, I should totally do that! I started reading it in 2005.

[09:43] <mux> types and programming languages by B. Pierce

[09:44] <masak> tadzik: au++ read it, found exercise at the end saying "implement something", and then went and wrote Pugs.

[09:44] <tadzik> :)

[09:44] <mux> it has all you ever wanted to know about lambda calculus (untyped, simply typed, System F...), type system formalisation, subtyping (nominal and structural and possibly bounded), and so on

[09:45] <mux> quite possibly the greatest CS book I ever read

[09:45] <tadzik> wishlist'd

[09:46] <mux> the follow-up (advanced types and programming languages) is very cool too, though it hurt my brain multiple times and there are still stuff in there that I don't get

[09:47] <tadzik> http://search.cpan.org/dist/HOP-Lexer/lib/HOP/Lexer/Article.pod is an awesome readt

[09:48] <moritz> tadzik: when I read that in the book, I kept thinking "there must be a simpler and more efficient way to do that" all the time

[09:49] * tadzik grumbles something about pdf being free and Kindle edition costing more than a paperback

[09:50] <moritz> like, having a single closure that knows about all the lexing regexes, and applies them all in parallel upon request, returning one token

[09:50] <tadzik> moritz: I'd like to learn, one day, about writing parsers step-by-step, tokenizing, lexing, building ast. It's quite easy with grammars, sure, but the result is that I can't write a parser in something else than Perl :)

[09:51] *** mkramer joined
[09:51] <moritz> tadzik: tokenizing == lexing afaict :-)

[09:51] *** mkramer left
[09:51] <tadzik> well, that's quite my understanding after reading that article :)

[09:52] <moritz> tadzik: I've written a recursive descending parser for a turing-complete toy language with not-too-awful syntax

[09:52] <tadzik> was it fun?

[09:53] <moritz> tadzik: it taught me two things: 1) it's not too hard to do and 2) it's so much repetition that I almost went off to write a wrapper that generates a parser from a data spec

[09:53] <tadzik> :Y

[09:53] <tadzik> (:

[09:53] <moritz> but yes, it was fun

[09:54] <moritz> tadzik: a part of that code lives on in https://github.com/moritz/math-expression-evaluator/blob/master/lib/Math/Expression/Evaluator/Parser.pm

[09:55] *** daxim joined
[09:55] <tadzik> moritz: typo in #170 :)

[09:57] <moritz> tadzik: thanks

[09:58] * mux wonders if he should voice his opinion on regexps in here :-P

[09:59] <moritz> mux: please do, it'll be entertaining :-)

[09:59] <mux> heh

[09:59] *** replore__ left
[10:00] <moritz> tadzik: typo fixed

[10:00] <mux> I think they're a great tool for sysadmins, in the command line; but I also think they're not fit for development and I find that they are "only" a very obfuscated domain-specific language taht wuold be better expressed using parsing combinators

[10:00] <moritz> mux: do you find Perl 6 grammars comparable obfuscated and inferior to parsing combinators?

[10:01] <mux> moritz: I don't know perl6 grammars :-(

[10:02] <mux> I really should get up to speed with perl6

[10:02] <moritz> mux: see for example https://github.com/moritz/json/blob/master/lib/JSON/Tiny/Grammar.pm for an example

[10:02] <moritz> that's a complete grammar for JSON

[10:03] <mux> I'm surprised you cannot just write BNF grammars directly in Perl6 :D

[10:03] <moritz> in short, grammars are classes. They can contain "special" methods that are basically regexes, and which can call other (regex-)methods by name

[10:03] <moritz> mux: it's very much BNF, just with different syntax :-)

[10:04] <mux> moritz: anyways, I find tht more readable that ad-hoc code that would deal with tokenization/etc itself

[10:04] <mux> than*

[10:04] <mux> work calls, bbl &

[10:17] *** pnu left
[10:19] *** pnu joined
[10:26] *** ggoebel joined
[10:27] *** leprevost joined
[10:39] <masak> aye. Perl 6 grammars are essentially BNF, but for Perl 6.

[10:39] <masak> the "for Perl 6" part is quite important. they really fit in well.

[10:42] <masak> tadzik: there's a *lot* of theory behind parsing, all the way up to finite automata theory and beyond. I don't understand much of it yet, but I find that the general principles are quite sane and easy to grasp. writing a decent parser probably isn't that difficult.

[10:43] <masak> doing it well with LTM and stuff seems a little tricky, but also achievable.

[10:43] <snarkyboojum> Perl 6 grammars are essentially parsing expression grammars in Perl 6 :)

[10:47] *** pnu left
[10:47] *** pnu joined
[10:47] <masak> one question I haven't really tried to answer yet is "Why does everyone else think it's a good idea to separate out lexing and building an AST, but Perl 6 mixes them together?"

[10:50] *** sivoais left
[10:51] *** sivoais joined
[10:54] <geekosaur> what everyone else?  most haskell parsers combine them

[10:55] <geekosaur> I think it's generally done because you get an explosion of states if you do it the usual low level way, so it makes sense to lex first into tokens (using a simpler state machine) and then parse those (which again simplifies the state machine)

[10:56] <geekosaur> ...it helps that computers are faster now so it doesn't cost so much to use a higher level approach

[10:56] <cognominal_> masak, when you conceptually separate lexing and parsing you end up with language like javascript. You can't use keywords as for other usages like variable names.

[10:56] <geekosaur> (yacc-like parsers go back to the pdp11)

[10:57] <masak> cognominal_: good point.

[10:57] <masak> oh, I guess lex and yacc pretty much set the standard for a few decades.

[10:57] <geekosaur> yes

[10:58] <cognominal_> perl solves partially that specific conflict with the use of sigils but the discussion yesterday shows you need some context to recognize a key of a fat arrow and not a keyword. 

[10:58] <masak> nice to hear that Haskell parsers combine them, too.

[10:58] <geekosaur> go count how many parsers on cpan are basically translations of yacc :)

[10:58] <masak> cognominal_: yes.

[10:59] <cognominal_> masak, I think this is a case of choice made by tools (yacc, lex) shaping people thought.

[10:59] <masak> geekosaur: without having studied lex/yacc too much, I think the way Perl 6/Haskell does it is significantly saner, and I don't currently feel very tempted to study the old way :)

[11:00] <masak> cognominal_: I think so too. just as make had/has a hegemony, so did/does lex/yacc.

[11:00] <geekosaur> as I said, the main davantage of the lex/yacc way was saving memory

[11:00] <geekosaur> much easier to force stuff to fit into a 64K (!) address space

[11:00] <cognominal_> The infamous Whorf hypothesis could be applied besides languages.

[11:01] <geekosaur> modern parsers use considerably more state storage than that, conveniently we have more than that :)

[11:01] <cognominal_> geekosaur. This is probably true that many tool we are using todays were shaped by constraint irrelevant today.

[11:01] <geekosaur> (also, yacc was itself something of a revolution *at the time*)

[11:02] <geekosaur> in large part because it went to a lot of effort to optimize the state table (again, in the interests of saving memory)

[11:03] <masak> tools surviving the usefulness of their optimizations. interesting.

[11:03] <geekosaur> perl has a certain history of busting that particular wall down :)

[11:04] <masak> :)

[11:05] *** nek joined
[11:05] <cognominal_> Speaking of automata, I wish someone had explained to me that a NFA was just a DFA on the powerset. When I read that, it made obvious things I had trouble to grasp.

[11:06] <mux> cognominal_: you might enjoy the type signature of the 'determinize' function there: http://code.mumux.org/automata/src/120d63e6991e/Data/Automaton/NFA.hs

[11:06] <mux> haskell is pretty like that ;-)

[11:06] <mux> -- Convert the NFA into a DFA using the powerset-construction algorithm.

[11:06] <mux> determinize :: (Ord a, Ord s) => NFA s a -> DFA (Set s) a

[11:07] *** alc left
[11:07] <masak> cognominal_: that is indeed a nice explanation. it also explains why NFAs are sometimes expensive to build.

[11:07] *** benabik left
[11:07] <mux> the Ord constraints are implementation details

[11:07] <cognominal_> I need to work haskell. I can read it but I have trouble writing it when composing monads.

[11:08] <cognominal_> mux++ # thx for the link

[11:08] <mux> you can do tons of stuff in haskell without monads though

[11:08] <mux> cognominal_: yw; tht code is a bit messy though, I have to warn you

[11:08] <masak> determinize :: (Ord a, Ord s) => NFA s a -> DFA (Set s) a

[11:08] <masak> ♥

[11:09] <mux> heh :D

[11:09] <mux> you gotta love when a type signature precisely matches the mathematical formalisation of something

[11:10] <masak> mux: do you really need to nest 'where' clauses like that? can't just just carry on on the same indentation level with just one 'where'?

[11:10] <mux> masak: I could, but when the were clause really only pertains to a sub-clause, I like it better to have a sub-sub-clause; this way when you move code around, it has more chances of working

[11:11] <masak> I thought that might be the reason.

[11:11] <masak> fair enough.

[11:11] <mux> but I agree this is not very pretty

[11:13] *** pernatiy left
[11:13] <tadzik> .u u umlaut

[11:13] <phenny> tadzik: Sorry, no results for 'u umlaut'.

[11:13] <tadzik> pff

[11:14] *** koban left
[11:14] <tadzik> oh, I need ö anyway :)

[11:14] <tadzik> could've taken Camelia's head

[11:14] <masak> noooooooo

[11:17] <gfldex> nom: my @a = 1,2,3; my @b = <a b c>; say @a Z @b Z "\n" xx *

[11:17] <p6eval> nom 158bd0: OUTPUT«1 a ␤ 2 b ␤ 3 c ␤␤»

[11:17] *** arx joined
[11:18] <gfldex> any way to get rid of the extra space before the NL?

[11:19] *** nek left
[11:19] <masak> there's extra spaces everywhere because you're .gist-ing a List.

[11:19] <masak> nom: my @a = 1,2,3; my @b = <a b c>; say (@a Z @b Z "\n" xx *).join

[11:19] <p6eval> nom 158bd0: OUTPUT«1a␤2b␤3c␤␤»

[11:20] <gfldex> now there are to few spaces :)

[11:21] <masak> nom: say "1 a\n2 b\n3 c\n\n" # there you go

[11:21] <p6eval> nom 158bd0: OUTPUT«1 a␤2 b␤3 c␤␤␤»

[11:21] <gfldex> tyvm :D

[11:22] <masak> problems. I solve them.

[11:22] <masak> nom: my @a = 1,2,3; my @b = <a b c>; for @a Z @b -> $a, $b { say "$a $b" } # this also works

[11:22] <p6eval> nom 158bd0: OUTPUT«1 a␤2 b␤3 c␤»

[11:23] <gfldex> that does work

[11:23] <gfldex> is there a forEach method in List?

[11:23] <masak> nom: my @a = 1,2,3; my @b = <a b c>; .say for map { "$^a $^b" }, (@a Z @b) # this works, too

[11:23] <p6eval> nom 158bd0: OUTPUT«1 a␤2 b␤3 c␤»

[11:24] <masak> gfldex: there's "for", and "map". we've theorized about an "each" pseudo-junction.

[11:25] <gfldex> my @a = 1,2,3; my @b = <a b c>; (@a Z @b).each(&say) # looks neat to me

[11:26] <masak> actually, it would be say each map { "$^a $^b" }, (@a Z @b), I think.

[11:26] <masak> actually, I think it's perfectly possible to *build* the Each type with what nom has already, without necessarily sticking it inside the Rakudo repo.

[11:26] <masak> someone should do that. ;)

[11:28] <gfldex> my @a = 1,2,3; my @b = <a b c>; @a Z @b each .say # may work as an operator too

[11:34] <masak> even assuming it did, it'd probably be tigher than Z, so you'd still need the parens.

[11:34] <masak> but I'd prefer it to be a listop just like any, all, one, and none.

[11:35] <gfldex> Confused at line 8, near "@a Z @b ea"

[11:35] <gfldex> nom is so easy to confuse these days :)

[11:35] <masak> I take it back about 'each' being implementable outside of Rakudo. I don't see it anymore.

[11:36] <gfldex> can i define the precedence of custom operators?

[11:36] <gfldex> or better is tha speced?

[11:37] <tadzik> b: use MONKEY_TYPING; augment class List { method each(&call) { self.map: { &call(|$_) } } }; (1, 2, 3, 4).each(&say)

[11:37] <p6eval> b 1b7dd1: OUTPUT«Method 'each' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/Nnp0sw9Ku5␤»

[11:37] <tadzik> pff

[11:37] <tadzik> b: use MONKEY_TYPING; augment class List { method each(&call) { self.map: { &call(|$_) } } }; (1, 2, 3, 4).list.each(&say)

[11:37] <p6eval> b 1b7dd1:  ( no output )

[11:38] *** Psyche^ joined
[11:38] <masak> gfldex: yes, and yes.

[11:38] <masak> gfldex: I believe it only works in Niecza so far.

[11:39] <gfldex> i cant wait for Xmas!

[11:40] <masak> tadzik: right, but the thing with 'each' (as far as I understand it) is that it isn't a method on List taking a closure, but rather (just like junctions) a sub on a list returning an kind of object that when passed as a parameter dispatches to possibly many repetitions of the same call but with different values.

[11:40] <masak> tadzik: the main difference with each is that it guarantees sequencing.

[11:41] <tadzik> mhm

[11:41] *** Patterner left
[11:41] *** Psyche^ is now known as Patterner

[11:42] <moritz> and that it returns something from which you can extract the eigenstates

[11:44] <gfldex> nom: my @a = 1,2,3; my @b = <a b c>; (@a Z @b)>>.say;

[11:44] <p6eval> nom 158bd0: OUTPUT«c␤a␤3␤1␤2␤b␤»

[11:45] <gfldex> wut?

[11:45] <gfldex> shouldn't >>. be in order?

[11:45] <jnthn> no

[11:45] <moritz> gfldex: it just returns itse results in order

[11:45] *** MayDaniel joined
[11:45] <gfldex> we need each then :)

[11:45] <jnthn> The compiler is allowed to parallelize it.

[11:46] <jnthn> In which case order of side-effects really can't be relied on

[11:48] <masak> pmichaud++ # for randomizing the results of >>

[11:49] <jnthn> yeah but >> has the wrong semantics now because the spec went and changed after pmichaud implemented it.

[11:49] <masak> not for method calls, I think.

[11:49] <moritz> (but it's not the random part that's wrong)

[11:49] <moritz> masak: yes, for method calls too

[11:49] <jnthn> I thought it was the method call part that was wrongest?

[11:49] <masak> oh, where's the dividing line, then?

[11:50] * jnthn needs to read those changes more closely

[11:50] * masak re-reads that spec patch

[11:50] <jnthn> Well, I'll preserve the randomizing order provided I don't have to go out of my way to do it.

[11:50] <jnthn> That is, if nobody else takes this on. In which case it's up to them. :)

[11:51] *** pernatiy joined
[11:51] <jnthn> (If anybody wants to work on it, that would be much appreciated, btw.)

[11:51] *** benabik joined
[11:51] <moritz> I might, but I have no idea how to do a dispatch that excludes Cool/Any/Mu

[11:52] <jnthn> we...huh...what

[11:52] <moritz> exactly.

[11:52] <moritz> lemme dig out the relevant lines...

[11:53] * jnthn pushes it down his task list some way, as that sounds like something he REALLY can't be bothered with.

[11:53] * masak comes back up out of the spec

[11:53] <masak> I must say I'm not really sold on fallback semantics.

[11:53] <jnthn> Two more words I don't like hearing. :/

[11:54] <masak> also, I've come to accept Cool and why we have it, but I don't like it becoming special-cased in other features. doesn't feel like a design that scales.

[11:54] <moritz> (For this meaning of "responds to",

[11:54] <moritz> we ignore any multi candidates defined in Cool, or the negation

[11:54] <moritz> above would not work, since Array responds to negation via Cool.

[11:54] <jnthn> Like, in .^methods et al

[11:55] <moritz> from S03

[11:55] <jnthn> We ignore...multi candidates defined in...pfft, so it's not just about method dispatch being affected, it wants the multi-dispatcher to get involved too?

[11:55] <masak> :(

[11:55] <jnthn> OK, I need to look at it much more closely.

[11:56] <moritz> nom: class A { method defined() }; say A.^can('defined')[0] === Any.^can('defined')[0]

[11:56] <p6eval> nom 158bd0: OUTPUT«===SORRY!===␤Missing block at line 1, near "}; say A.^"␤»

[11:56] * masak takes a skeptical stance to the "duck mapping" idea

[11:56] <moritz> nom: class A { method defined() {} }; say A.^can('defined')[0] === Any.^can('defined')[0]

[11:56] <p6eval> nom 158bd0: OUTPUT«Bool::False␤»

[11:56] <moritz> nom: class A { method defined() {} }; say Cool.^can('defined')[0] === Any.^can('defined')[0]

[11:56] <p6eval> nom 158bd0: OUTPUT«Bool::True␤»

[11:57] * moritz has a nasty idea

[11:57] <masak> moritz: ah, a test for "is this method from Cool/Any/Mu?"

[11:57] <moritz> masak: correct

[11:57] * masak cackles evilly

[11:57] <jnthn> Yes but...that won't tell you anything about the multi candidates

[11:58] <masak> true.

[11:58] <moritz> nom: class A { method defined() { 42 } }; say A.^can('defined')[0].(A.new)

[11:58] <p6eval> nom 158bd0: OUTPUT«42␤»

[11:58] <moritz> well, the spec doesn't say it's a normal dispatch, but a weird dispatch

[11:58] * moritz finds excuses

[11:58] <jnthn> weird = slow, of course :)

[11:58] *** eiro joined
[11:58] <eiro> hello

[11:58] <jnthn> well, slower

[11:59] <masak> heiro!

[12:07] <masak> moritz: one slightly disturbing thing is that extensions to Mu/Any/Cool in later Perl 6 spec versions might break previously working uses of >>

[12:07] <moritz> masak: example?

[12:08] <moritz> masak: since they are excluded from dispatch, that shouldn't happen

[12:08] <moritz> masak: but I agree it's a general problem with this approach, it relies on the absence of methods in certain classes

[12:10] <masak> right.

[12:15] *** bluescreen10 joined
[12:19] *** MayDaniel left
[12:23] *** sftp joined
[12:26] *** djanatyn|afk is now known as djanatyn

[12:28] <jnthn> I see Parrot folks are planning to merge the green threads branch. Did the sizable slowdown to mandelbrot get resolved?

[12:28] <tadzik> they claim so

[12:28] <jnthn> ok

[12:28] <moritz> the last report was that the slowdown decreased to 0.8%

[12:28] <moritz> I'll test that :-)

[12:28] <jnthn> OK, that's more acceptable.

[12:28] <jnthn> Please do

[12:28] <benabik> Hasn't merged yet.  Testing welcome.  :-D

[12:29] <jnthn> 0.8% should be a fraction of a second's difference.

[12:30] <moritz> nom: say 35 * 8e-3

[12:30] <p6eval> nom 158bd0: OUTPUT«0.28␤»

[12:31] <tadzik> worth it, I suppose

[12:31] *** icwiener joined
[12:32] <[Coke]> aye. much like the nom rewrite is worth it even though we have regressions. ;)

[12:33] *** replore_ joined
[12:33] <jnthn> Well, with the small difference that the nom re-write made some things significantly faster, rather than a little slower ;)

[12:33] <[Coke]> I was referring more to the "made some things possible that would have been reallly hard otherwise" portion.

[12:34] *** tokuhiro_ joined
[12:34] <[Coke]> existing parrot threads have been nigh-useless since...

[12:34] <tadzik> they're like the Matrix sequels

[12:35] <tadzik> you just assume they don't exist

[12:35] <[Coke]> bah. they were perfectly fine action movies. :P

[12:36] <[Coke]> I remember whiteknight trying to get me to rip them out in a release, was probably 2.6

[12:36] <masak> thought-provoking quotes: http://en.wikipedia.org/wiki/Object-oriented_programming#Criticism

[12:37] <[Coke]> (but it was a gsoc thing, and the request to merge came in just before the release was due, so I said no.

[12:38] <moritz> masak: the one from Paul Graham immediately made the word "Java" pop into my mind :-)

[12:38] <tadzik> hehe, how so? :>

[12:38] <masak> moritz: I'm pretty sure that wasn't a design goal of Java... but it might be argued that that was the result, yes.

[12:38] <tadzik> my head reacted quite similarly

[12:39] <masak> moritz: in essence, there are lots of companies out there who want both Java and some sort of programmer herding/replaceability at the same time.

[12:39] <colomon> I think OOP is a great tool.  But people who try to make it THE paradigm of their programming language are insane.

[12:39] <masak> moritz: though in Sweden, that role seems to be increasingly filled by C#/.NET -- admittedly a slightly nicer solution.

[12:40] <jnthn> I think it's a bit better than "slightly"

[12:41] <jnthn> You can do higher order programming reasonably nicely in C# these days

[12:41] <jnthn> Admittedly, that probably means the average C# developer gets a headache over a bunch of the stuff I write... :)

[12:42] * moritz wonders if jnthn belongs to the High Order of Programming

[12:42] <jnthn> No, just the ones who studied a functional language at uni, rather than just Java :)

[12:42] <masak> hey! :)

[12:42] <jnthn> hehe :P

[12:43] <masak> though I must admit that I snuck into the functional language lectures at uni, even though I technically shouldn't be there...

[12:43] <jnthn> masak: You're not average or typical. :)

[12:44] <masak> I'll interpret that as a compliment.

[12:44] <masak> ;)

[12:46] <jnthn> :)

[12:49] <masak> those were ML lectures, IIRC. a bit too basic, but still nicer than the Java lectures we got in the Engineering track.

[12:53] <jnthn> yeah, ML was what I got

[12:54] <masak> ooh, ML is written by Milner or Hindley-Milner fame.

[12:54] <jnthn> The usual lecturer for the course was the author of "ML for the working programmer", but he was on leave the year I did the course. His stand-in poked a little fun at the book title, but actually did the course pretty well. :)

[12:54] <masak> "the working programmer is currently on leave" *ba dum dish*

[12:57] <mls_> Hah! Success! nqp passes with most blocks as :blocktype("inline") !

[12:58] <mls_> (I know why I don't build compilers as my main job, debugging is really time consuming)

[12:58] <moritz> \o/

[12:58] <mls_> Now I've got to do some time measurements and a bit of code cleanup

[12:58] <jnthn> mls_: Is this related to stacked lexpads?

[12:59] <mls_> It *is* stacked lexpads

[12:59] <jnthn> :)

[12:59] <mls_> lots of push_pad and pop_pad in the generated code

[12:59] <mls_> It works really well with the driectaccess patch I did end of last day

[13:00] <mls_> week

[13:00] <mls_> Thus it doesn't generate find_lex/store_lex for the lexicals it can access directly

[13:00] <benabik> mls_: Thank you for doing a lot of the PCT work I had on my list.  Both of those were high on the "should be done" list.

[13:01] <masak> mls_: ooc, which lexicals can it access directly?

[13:01] <mls_> wait until I know if it really makes things faster ;)

[13:01] <mls_> all of the ones from the current sub

[13:01] *** daxim left
[13:01] <moritz> just be careful about lexicals that can be modified from an eval()

[13:02] *** daxim joined
[13:02] <moritz> nom: my $x = 3; say $x; eval '$x = 6'; say $x

[13:02] <p6eval> nom 158bd0: OUTPUT«3␤6␤»

[13:02] <mls_> (except $_, $/, ... because you treat them special in the lexpad)

[13:02] <moritz> that needs to re-fetch the $x

[13:02] <mls_> that's a different sub

[13:02] <masak> well, a different block, at least.

[13:02] <mls_> but it uses the same register

[13:02] <masak> what does 'eval "return"' do?

[13:02] <moritz> yes, but the re-fetching needs to happen in the mainline, because a sub we called modified the lexicals

[13:03] <mls_> the eval changes the correct register

[13:03] <moritz> nom: eval 'return'

[13:03] <p6eval> nom 158bd0:  ( no output )

[13:03] <moritz> mls_: that's cool

[13:03] <benabik> moritz: Nope.  Parrot uses the register you declared in .lex as the storage location for the lexical.  So if you say $P25 is $x, then $P25 is always always the value of $x

[13:03] <moritz> nom: eval 'return'; say 3

[13:03] <p6eval> nom 158bd0: OUTPUT«3␤»

[13:03] <mls_> that's how fetch_lex/store_lex work, they mess with the registers of another context

[13:03] <masak> perl6: sub foo { eval 'return'; say "OH HAI" }; foo

[13:03] <benabik> moritz: (In that routine, of course.)

[13:03] <p6eval> pugs b927740, rakudo 158bd0, niecza v10-66-g71325b0:  ( no output )

[13:03] <masak> \o/

[13:03] <masak> so, not a different sub.

[13:03] <jnthn> eval implies a block not a sub.

[13:03] <buubot_backup> jnthn: ERROR: Illegal declaration of anonymous subroutine at (eval 20) line 1. 

[13:04] <mls_> parrot sub

[13:04] * masak slaps buubot_backup 

[13:04] <benabik> buubot_backup: shush

[13:04] <buubot_backup> benabik: Couldn't match input.

[13:04] <jnthn> buubot_backup: THOU SHALT NOT SPEAK UNLESS SPOKEN TO, BOT

[13:04] <buubot_backup> jnthn: Couldn't match input.

[13:04] <masak> buubot_backup: Could you match inpu?

[13:04] <buubot_backup> masak: Couldn't match input.

[13:04] <masak> buubot_backup: what couldn't you match?

[13:04] <buubot_backup> masak: Couldn't match input.

[13:04] <mls_> anyway, I'll do some benchmarks now...

[13:04] <masak> buubot_backup: you could do everything, except...

[13:04] <buubot_backup> masak: Couldn't match input.

[13:05] <mls_> (I hope things get faster, otherwise it a week's work was useles...)

[13:05] <jnthn> mls_: It *should* help plenty (more)

[13:05] <benabik> mls_: Avoiding calling subs and find/store_lex should just be doing less work.

[13:05] <masak> jnthn: admittedly, it uses a fixed prefix 'eval ', which is still better than purl...

[13:05] <jnthn> One of the things that the optimizer does is inline basic blocks.

[13:06] <jnthn> That doesn't declare lexicals

[13:06] <jnthn> It makes a notable difference

[13:06] <mls_> yes, I saw that

[13:06] <jnthn> Since it saves multiple GC-ables

[13:06] <benabik> That inlining can still avoid creating the lexpad.

[13:06] <jnthn> (the CallContext and a Continuation)

[13:06] <mls_> I still have to allocate one PMC though, the lexpad

[13:06] <jnthn> benabik: Yes, true. It's worth doing even with the mls++ patch.

[13:06] <jnthn> They're complementary :)

[13:07] <mls_> blocktype inline doesn't create the lexpad if it's not needed

[13:07] <benabik> mls_: !!!

[13:07] <mls_> (not needed == no lexicals declared)

[13:07] <jnthn> Oh :)

[13:07] <jnthn> Wow :)

[13:08] <mls_> (that was an easy optimization)

[13:08] <jnthn> Smart. :)

[13:08] <mls_> I still have a bit of a problem with contextuals, they use find/store_dynamic_lex

[13:09] <mls_> Now, find/store_dynamic_lex ignores the current lexpad, I don't know what the correct semantics should be in this case

[13:09] <mls_> Hmm, that souned confusing, let's try again

[13:10] <mls_> currently find_dynamic_lex starts with with lexpad of the caller context

[13:10] <mls_> I don't know if I should change that to "skip the current lexpad"

[13:10] <mls_> as a sub now has a chain of lexpads

[13:11] <mls_> (For now I've just added two new ops: find/store_dynamic_lex_current to make contextuals work)

[13:12] <mls_> (cause with $/ et al we don't need to skip the current pad)

[13:12] <mls_> anyway, benchmarks first ;)

[13:13] <jnthn> For contextual I think it's tied to scope depth

[13:13] <jnthn> And you've just changed the unit of scope.

[13:13] <jnthn> So yes, it'd be skip the current lexpad, not skip all lexpads (scopes) in the current context.

[13:17] *** mtk joined
[13:17] <mls_> afk for a while...

[13:20] *** am0c joined
[13:24] <benabik> Is there a particular reason the failing tests in NQP haven't been marked TODO?

[13:24] <moritz> benabik: there should only be regex tests failing, and there the answer is probably that we thought the regex engine was still in too much flux

[13:25] <moritz> (unless you are missing ICU; we haven't gone the lengths to skip ICU-dependent tests in NQP yet)

[13:25] <benabik> moritz: Have ICU, only getting failures in qregex.  I'm just tired of going "oh yes, it's those tests again."  ;-)

[13:26] <moritz> benabik: feel free to TODO them if they annoy you

[13:26] <PerlJam> so once green threads are available in parrot ... who is planning to use them in rakudo/nqp ?

[13:26] <masak> benabik: if it's possible to TODO them in such a way to show that they're *regressions*, that's good too.

[13:27] * masak is not too hot about the practice of regressing and then just slapping TODO on things

[13:27] <benabik> masak: `:todo<regression>` ?

[13:27] <masak> somethinglikethat

[13:28] <benabik> masak: For me "todo" means "these tests are expected to fail right now".  I also note that I'm getting a pile of passing TODOs as well.  :-D

[13:29] <masak> masak: I'm fine with that definition of TODO... it's just that I don't think that's sufficient reaction to a regression.

[13:29] <masak> unless it's a completely private project with no downstream users, I guess.

[13:30] *** im2ee joined
[13:31] <im2ee> Hi! o/

[13:32] <masak> hi im2ee 

[13:33] *** wtw left
[13:41] *** mtk left
[13:42] *** JimmyZ joined
[13:46] *** SHODAN left
[13:46] *** drbean left
[13:47] *** drbean joined
[13:47] *** mtk joined
[13:53] *** GlitchMr joined
[13:56] *** thou joined
[14:02] *** daniel___ joined
[14:03] <benabik> Huh.  qregex test failing hid from me the fact that the p6regex test hangs.  Excellent.  :-(

[14:04] <moritz> oh, that might be my fault

[14:04] *** MayDaniel joined
[14:04] <benabik> Uh, it hangs after emitting the done testing line?

[14:04] <benabik> Hm.

[14:05] * benabik hopes this isn't due to green_threads.

[14:05] <moritz> nope

[14:05] <moritz> I think I've seen that on top of master too

[14:05] *** envi_ left
[14:06] <benabik> I'm somewhat confused why it hangs at the end of the script.

[14:07] *** SHODAN joined
[14:07] <moritz> benabik: it might have started to hang around commit 05affcfdbebee1f74faf63969ee6d1b393b248f3

[14:08] <moritz> not sure if that's any help to you

[14:08] <benabik> moritz: I'll look into it after my test this afternoon.

[14:12] <dalek> nqp: 1f3891e | moritz++ | t/p6regex/01-regex.t:

[14:12] <dalek> nqp: work around hang of p6regex tests at end of file

[14:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1f3891e627

[14:12] <moritz> benabik: this is somewhat ugly...

[14:13] <benabik> moritz: That's one way to "solve" it...

[14:14] <moritz> benabik: I remember that rakudo had a similar hack, because the final teardown caused segfaults back in the days

[14:15] <jnthn> Could be worth attaching the debugger to see where it's hanging.

[14:15] <jnthn> Or run it under the debugger and break when it hangs

[14:16] <benabik> jnthn: That was on my todo list, yes.

[14:16] <benabik> jnthn: But I should be studying for a test right now, and debugging takes much longer than mucking with TODOs.  :-D

[14:16] <jnthn> :)

[14:17] <mls_> might be a runloop problem, i.e. some finalize ops missing

[14:22] *** cognomor` joined
[14:22] *** cognomore left
[14:24] *** cognomor` left
[14:24] *** cognomor` joined
[14:29] <moritz> nom: say so 'a' ~~ /<?alpha>/

[14:29] <p6eval> nom 158bd0: OUTPUT«Bool::True␤»

[14:36] <dalek> nqp: fa9f991 | moritz++ | src/QRegex/Cursor.nqp:

[14:36] <dalek> nqp: try to implement <before>

[14:36] <dalek> nqp: 

[14:36] <dalek> nqp: It seems a bit wrong since it never captures, but it does look-ahead

[14:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fa9f991ced

[14:36] <jnthn> afk...vaguely work related beer drinking opportunity arose &

[14:36] <moritz> have fun jnthn 

[14:36] <jnthn> L(

[14:36] <jnthn> *:)

[14:36] <jnthn> probably back in a few hours

[14:37] <moritz> phenny: ask pmichaud to please review https://github.com/perl6/nqp/commit/fa9f991cedc8620f9642cc641d27a220f76fe6d9 when he has a spare minute. My first regex built-in, so I'm not sure at all if that's the right approach

[14:37] <phenny> moritz: I'll pass that on when pmichaud is around.

[14:38] <masak> moritz: nice!

[14:39] <moritz> I figured it can't be too hard, since look-ahead is a *very* simple operation

[14:39] <dalek> nqp: 9ce492d | benabik++ | t/p6regex/01-regex.t.old:

[14:39] <dalek> nqp: Remove t/p6regex/01-regex.t.old

[14:39] <dalek> nqp: 

[14:39] <dalek> nqp: It's not being used and if someone wants to refer to it, it's still

[14:39] <dalek> nqp: available in the git history.

[14:39] *** dalek left
[14:39] <moritz> you just do a normal regex match, and "forget" to bump the position

[14:39] *** dalek joined
[14:39] *** ChanServ sets mode: +v dalek

[14:39] <masak> apparently :)

[14:40] <masak> and since 'tis all immutable Cursor objects, it's a bit like doing an experimental branch in git, I guess...

[14:40] <benabik> Did dalek get lost mid-commit?

[14:40] <moritz> benabik: kicked for flodding, I'd guess

[14:40] <masak> aye.

[14:40] <benabik> Oh.

[14:41] <moritz> benabik: never mind, not your fault

[14:41] <masak> in such a case, dalek always emits five lines and then gets kicked.

[14:41] <benabik> Well the NQP test suite now completes for me, which is useful for noticing bad tests are actually bad.  If anyone disagrees with the set of TODOed tests, that's a useful data point.  :-D

[14:41] *** SHODAN left
[14:41] <moritz> masak: I'm not sure how immutable cursors actually are

[14:42] <moritz> masak: the qregex code is full of things like $cur.'!cursor_pass'($pos, $name)

[14:42] <moritz> where the return value is ignored

[14:42] *** am0c left
[14:43] <moritz> if the cursor was immutable, why would one do a method call and throw away the result?

[14:43] <masak> I think it's "immutable for all you know". :P

[14:43] <masak> which is a kind I like.

[14:43] <moritz> "just don't look carefully"

[14:44] <moritz> IME it creates a new cursor for each branch in an alternation, for each backtracking etc.

[14:44] <moritz> so for all the things that look like they might need one

[14:44] <moritz> hm, wait, that's just a guess

[14:46] <masak> but it sounds sane.

[14:46] *** cognominal joined
[14:46] <masak> technically, for an alternation you'd only need to create one new branch.

[14:47] <masak> but it might be nicer from a model perspective to create both in nqp, I dunno.

[14:47] <moritz> my mental model is "each point where a decision is made that could be revised later on, we create a list of cursors, one for each possible choice"

[14:48] <moritz> s/each/at each/

[14:48] <moritz> taking a branch in an alternation is such a choice

[14:48] <masak> nod.

[14:48] <moritz> not sure how closely qregex follows that model

[14:49] *** cognominal_ left
[14:49] *** cognomor` left
[14:50] <masak> the PGE model was "push to @ustack and do a local_branch for each possible future backtrack-oid choice": https://github.com/masak/gge/blob/master/lib/GGE/Exp.pm#L586

[14:51] <moritz> masak: how was @ustack scoped?

[14:52] <masak> globally.

[14:52] <[Coke]> question: the setting is currently compiled as a single unit why? so they all have the same OUTER?

[14:52] <masak> moritz: well, global for the match process.

[14:52] <masak> [Coke]: because it's a single unit.

[14:53] <moritz> [Coke]: we've been discussing a staged setting, but it'd need a good, clear cutting point

[14:55] <[Coke]> masak: I understand it's a single unit, but why does that matter to parrot is the part I'm trying to tease out.

[14:57] <[Coke]> but, meetings.

[14:57] *** daniel___ left
[14:59] *** donri joined
[15:00] <masak> [Coke]: the mainline code conceptually has the setting as its OUTER. so it needs to be a single unit.

[15:00] * JimmyZ introduces Perl 6 to his new colleague, and his colleague likes it very much

[15:01] <moritz> masak: I'm not convinced. The REPL has code to copy two nested scopes into a single scope. That might be reusable for having nested settings appear to be a single one

[15:05] <masak> I thought what the REPL did was descend into new inner scopes all the time...

[15:05] <moritz> it'd leak memory like hell if it did

[15:06] <masak> I'd always wondered about that ;)

[15:06] <moritz> like, at least one lexpad per line

[15:07] <masak> right.

[15:07] *** envi_ joined
[15:08] <masak> grammars and thread safety -- where do I put the variables that pertain to my ongoing grammar match, if I don't want them to collide with other matches going on concurrently?

[15:08] <moritz> in the cursor :-)

[15:09] <moritz> not only for thread safety

[15:09] <moritz> consider  /foo { 'a' ~~ /./ }/

[15:09] <moritz> you have to take care that the inner match doesn't mess up the outer one

[15:09] <moritz> so you'd better not use globals :-)

[15:14] <masak> aye.

[15:14] <masak> oh, can I store things in my immutable Cursor? great!

[15:15] <moritz> in your immutable-ish Cursor, yes

[15:15] <masak> moritz: your example doesn't apply, since it's not a grammar that's re-entrant there.

[15:15] <moritz> masak: then modify it accordingly *handwave*

[15:15] <masak> but point taken.

[15:17] <moritz> the cursor also has to cache the Match object, otherwise the Match'es .ast goes lost

[15:17] <sorear> hello #perl6

[15:18] <masak> sorear! \o/

[15:18] <moritz> hello sorear. How (im)mutable are your cursors?

[15:19] <colomon> o/

[15:20] <colomon> niecza: say Array.new(4, 5, 6).STR

[15:20] <p6eval> niecza v10-66-g71325b0: OUTPUT«␤Unhandled Exception: Excess arguments to CORE List.new, used 1 of 4 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE List.new @ 0) ␤  at /tmp/tx6oYsO2JQ line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2193 (COR…

[15:20] <colomon> STUPID CAPS LOCK

[15:20] <colomon> niecza: say Array.new(4, 5, 6).Str

[15:20] <p6eval> niecza v10-66-g71325b0: OUTPUT«␤Unhandled Exception: Excess arguments to CORE List.new, used 1 of 4 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE List.new @ 0) ␤  at /tmp/QPiyR8e_2h line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2193 (COR…

[15:20] <colomon> niecza: say [4, 5, 6].Str

[15:21] <p6eval> niecza v10-66-g71325b0: OUTPUT«4 5 6␤»

[15:21] <colomon> niecza: say (4, 5, 6).list

[15:21] <moritz> niecza: say Array.new((4, 5, 6)).Str

[15:21] <sorear> moritz: when a Cursor is presented to Perl6-space, it's immutable

[15:21] <p6eval> niecza v10-66-g71325b0: OUTPUT«␤Unhandled Exception: Excess arguments to CORE List.new, used 1 of 2 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE List.new @ 0) ␤  at /tmp/9NLV4GIrlk line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2193 (COR…

[15:21] <p6eval> niecza v10-66-g71325b0: OUTPUT«4 5 6␤»

[15:21] <moritz> niecza: sub f($x) { say $x }; f((1, 2, 3))

[15:21] <p6eval> niecza v10-66-g71325b0: OUTPUT«1 2 3␤»

[15:22] <sorear> moritz: however it holds a back-reference to the RxFrame, which is mutable and holds the ast field, as well as backtrack control info

[15:22] <sorear> so $¢.commit will DWIM (or would if commit were implemented)

[15:22] <colomon> gang, t/spec/S32-array/create.t  -- should Array.new(4, 5, 6) work?  list(4, 5, 6) ?  Those are both syntaxes I don't ever recall seeing before.

[15:23] <moritz> std: list 1

[15:23] <sorear> "it's in roast, so yes"

[15:23] <p6eval> std be1f10e: OUTPUT«ok 00:01 119m␤»

[15:23] <moritz> colomon: I'm pretty sure the 'list' listop is in the specs

[15:23] <colomon> std: dsfsdfs(1, 2, 3)

[15:23] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'dsfsdfs' used at line 1␤Check failed␤FAILED 00:01 121m␤»

[15:24] * sorear pops back out

[15:24] <colomon> niecza: say (4, 5, 6).list.Str

[15:24] <p6eval> niecza v10-66-g71325b0: OUTPUT«4 5 6␤»

[15:26] <[Coke]> (setting is the single outer unit) - pbc_merge fails to address this?

[15:26] <moritz> I'm pretty sure it does

[15:27] <masak> colomon: I think I've seen Array.new(4, 5, 6) a few times.

[15:27] <masak> though how it works bootstrap-ly I have no idea.

[15:28] <moritz> it's positionals all the way down :-)

[15:29] <masak> :)

[15:30] <benabik> pbc_merge just puts the subs and constants together in one file.  Since P6 has more complex ideas about namespaces and scoping than parrot, you'd have to add more code to tie everything together at that level.

[15:30] <JimmyZ> perl6: sub f(:$x, :&x) { say $x }; f(:x(min(6,2,3)), :x(1, 2, 3))

[15:30] *** mj41 left
[15:30] <p6eval> niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'min' used at line 1␤␤Potential difficulties:␤  &x is declared but not used at /tmp/JqYiXINZ05 line 1:␤------> [32msub f(:$x, :[33m⏏[31m&x) { say $x }; f(:x(min(6,2,3)), :x(1, [0m␤␤␤Unhandled Excepti…

[15:30] <p6eval> ..pugs b927740: OUTPUT«123␤»

[15:30] <p6eval> ..rakudo 158bd0: OUTPUT«1 2 3␤»

[15:30] * moritz is kinda surprised that it doesn't blow up

[15:30] <JimmyZ> perl6: sub f(:$x, :$x) { say $x }; f(:x(min(6,2,3)))

[15:30] <p6eval> niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'min' used at line 1␤␤Potential difficulties:␤  Useless redeclaration of variable $x (see line 1) at /tmp/8B3kFxpiJZ line 1:␤------> [32msub f(:$x, :$x[33m⏏[31m) { say $x }; f(:x(min(6,2,3)))[0m␤␤␤Un…

[15:31] <p6eval> ..pugs b927740: OUTPUT«2␤»

[15:31] <p6eval> ..rakudo 158bd0: OUTPUT«===SORRY!===␤Redeclaration of symbol $x at line 1, near ") { say $x"␤»

[15:31] *** MayDaniel left
[15:31] *** simcop2387 left
[15:31] * JimmyZ thinks it's a bug

[15:31] <masak> it is.

[15:32] <masak> such a signature with two named parameters save for the sigil is illegal.

[15:32] <masak> I remember moritz and me spec'ing the rules for that.

[15:32] <moritz> std: -> :$x, :&x { }

[15:32] <p6eval> std be1f10e: OUTPUT«ok 00:01 122m␤»

[15:32] <masak> STD is lagging :)

[15:32] <JimmyZ> std: -> :$x, :$x { }

[15:32] <p6eval> std be1f10e: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $x (see line 1) at /tmp/FKzWHzu2P5 line 1:␤------> [32m-> :$x, :[33m⏏[31m$x { }[0m␤ok 00:01 121m␤»

[15:32] <masak> that's too lenient, if you ask me.

[15:33] <masak> it's fine for lexicals in general, but not for a siggie.

[15:33] <JimmyZ> perl6: sub f(:$x, :%x) { say $x }; 

[15:33] <p6eval> pugs b927740, rakudo 158bd0:  ( no output )

[15:33] <p6eval> ..niecza v10-66-g71325b0: OUTPUT«Potential difficulties:␤  %x is declared but not used at /tmp/UvwYaQgjMv line 1:␤------> [32msub f(:$x, :[33m⏏[31m%x) { say $x };[0m␤  &f is declared but not used at /tmp/UvwYaQgjMv line 1:␤------> [32msub f[33m⏏[31m(:$x, :%x) { say $x };[0m␤␤»…

[15:33] <masak> binding is serious business :)

[15:34] <moritz> and signatures are complex beasts

[15:34] <JimmyZ> niecza has this bug too

[15:34] *** simcop2387 joined
[15:42] *** preflex left
[15:43] *** preflex joined
[15:50] *** cognominal_ joined
[15:50] <moritz> masak: I think you were referring to 60657ebc7f9d9410a7fcc3769fd268fcad732127, which is only about positional parameters :/

[15:51] <JimmyZ> nom: class A { multi fun() { say 'zero' ; }; multi sub fun(2) { say 'two'; }; method hi() { fun(); fun(2); } }; my A $a .=new; $a.hi();

[15:51] <p6eval> nom 158bd0: OUTPUT«zero␤two␤»

[15:52] <masak> moritz: no, I'm referring to S06:705

[15:53] <masak> moritz: the commit you refer to is a precursor to what ended up there.

[15:53] *** MayDaniel joined
[15:53] <moritz> ok :-)

[15:54] *** cognominal left
[15:59] * masak decommutes

[16:02] <PerlJam> masak: whenever you decommute, does that mean you are no longer commutative?

[16:05] <daxim> perl6: (masak ⊕ masak).say

[16:05] <p6eval> rakudo 158bd0: OUTPUT«===SORRY!===␤Confused at line 1, near "(masak \u2295 m"␤»

[16:05] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\8853'␤*** ␤    Unexpected "\8853"␤    expecting bare or pointy block construct, ":", identifier, operator or ")"␤    at /tmp/SN20dnC73O line 1, column 8␤»

[16:05] <p6eval> ..niecza v10-66-g71325b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/rZppPdK7eE line 1:␤------> [32m(masak [33m⏏[31m⊕ masak).say[0m␤␤Undeclared routine:␤        'masak' used at line 1␤␤Parse failed␤␤»

[16:06] <tadzik> nom: <masak ⊕ masak>.say

[16:06] <p6eval> nom 158bd0: OUTPUT«masak ⊕ masak␤»

[16:06] <benabik> daxim: masak knows perl6, but perl6 doesn't know masak.

[16:07] <benabik> .oO( mask may commute, but knowledge doesn't? )

[16:07] <benabik> *masak, stupid autocorrect

[16:08] *** am0c joined
[16:09] *** tokuhiro_ left
[16:11] <JimmyZ> nom: sub f(:&x) { say &x }; f(:x(min))

[16:11] <p6eval> nom 158bd0: OUTPUT«Nominal type check failed for parameter '&x'; expected Callable but got Num instead␤  in sub f at /tmp/WYVvIUDWfr:1␤  in block <anon> at /tmp/WYVvIUDWfr:1␤  in <anon> at /tmp/WYVvIUDWfr:1␤»

[16:11] <donri> alla känner apan men apan känner ingen

[16:12] <moritz> phenny: se "apan"?

[16:12] <phenny> moritz: "monkey" (se to en, translate.google.com)

[16:12] <moritz> ah right, "ape"

[16:12] <JimmyZ> why expected Callable but got Num ?

[16:13] <moritz> JimmyZ: because you called min, not returned a reference to it

[16:13] * moritz anticommutes

[16:13] <JimmyZ> moritz: thanks

[16:13] <benabik> nom: sub f(:&x) { say &x }; f(:x(&min))

[16:13] <p6eval> nom 158bd0: OUTPUT«Sub.new()␤»

[16:16] <JimmyZ> nom: sub f(:&x) { say &x(5, 3,6) }; f x => &min

[16:16] <p6eval> nom 158bd0: OUTPUT«3␤»

[16:17] <JimmyZ> nom: sub f(:&x, |$c) { say &x(|$c) }; f x => &min, 5,2,3

[16:17] <p6eval> nom 158bd0: OUTPUT«2␤»

[16:18] *** wolfman2000 left
[16:29] *** JimmyZ left
[16:50] *** pernatiy left
[16:53] <TimToady> masak: I'm thinking of changing the macro placeholder syntax to something more like $term:ast($x) to indicate the desired category

[16:53] <TimToady> possibly it wants a new sigil

[16:54] <moritz> .u §

[16:54] <phenny> U+00A7 SECTION SIGN (§)

[16:54] <TimToady> §term:ast($x)

[16:54] <TimToady> you beat me to it :)

[16:54] <moritz> that one's still free :-)

[16:55] <TimToady> I'm also rethinking whether we really need a no-non-Latin-1-by-default rule

[16:56] <TimToady> or whether that's just a sop to the Unicode-haters

[16:56] <TimToady> and a relatively meaningless one

[16:56] *** risou is now known as risou_awy

[16:57] <TimToady> I'm not sure that built-in types like sets should be deprived of their natural operators by default

[16:58] <TimToady> and after helping with the Unicode chapter in camel4, I see that Perl is getting starting to get a reputation for being the best langauge for Unicode

[16:58] <TimToady> and I'd hate to work against that with an artificial rule

[16:59] <TimToady> with a new sigil, we could remove the 'ast' and just have §term:($x), which is pretty concise

[17:00] <TimToady> and then you can have §infix:($y) or §parameter:($p)

[17:01] <TimToady> we'd have to smarten the parsers to allow such a substitution at any proto in the grammar

[17:01] <TimToady> (not that parameter is currently parsed with a proto...)

[17:02] <sjohnson> hi

[17:03] <tadzik> （　° ー°） <( hi sjohnson! )

[17:03] *** Je joined
[17:03] <TimToady> § looks too much like $ maybe, so ¶term:($x) might be better

[17:03] <sjohnson> haha

[17:03] <sjohnson> tadzik: yo, how's life

[17:03] <tadzik> pretty cool. I got a day off today, feels good

[17:04] <tadzik> well, more like "I decided not to go to my classes", but still :)

[17:04] * sjohnson is envious

[17:04] <TimToady> or ¤term:($x)

[17:04] <tadzik> maybe €term

[17:04] <tadzik> or <the-pound-sign>

[17:04] <TimToady> I kinda like ¤, since it's generic currency

[17:05] <TimToady> and it looks like a "hole" :)

[17:05] *** dakkar left
[17:05] <TimToady> actually, it looks like a round peg in a square hole :)

[17:06] <PerlJam> What's the criterion of choice for these characters?

[17:06] <PerlJam> (they have no mnemonic value or anything to me)

[17:07] <TimToady> well, I just mentioned a couple of possibilities

[17:07] <TimToady> something that is generically fungible is like a macro parameter

[17:08] <TimToady> and the placeholders have already been called holes

[17:08] <TimToady> and placeholders are like square pegs in round holes, or vice versa

[17:09] <TimToady> I wasn't just saying those things randomly... :)

[17:09] <TimToady> it's also rather visually distinct from anything else

[17:09] <TimToady> and being up in the Latin-1 range, unlikely to be used accidentally, like $¢

[17:10] <PerlJam> there's no unicode char that's a square circumscribed by a circle?

[17:11] <TimToady> well, there's ⌼

[17:11] <TimToady> but that's the other way around

[17:12] <TimToady> ㉤

[17:12] *** ksi joined
[17:12] <benabik> .u ㉤

[17:12] <phenny> U+3264 CIRCLED HANGUL MIEUM (㉤)

[17:13] <TimToady> but things in the Latin-1 range are usually a bit handier on the compose key, or the vim digraphs

[17:18] <ashleydev> .u ⽊

[17:18] <phenny> U+2F4A KANGXI RADICAL TREE (⽊)

[17:18] <masak> TimToady: aww, but I'd just started to see the merits of the ugly {{{ $ast }}} syntax! :/

[17:19] <masak> (namely, if you ever want to nest quasi blocks, it's indispensible)

[17:22] *** Je left
[17:23] <TimToady> not at all

[17:23] <masak> oh right, it falls out of lexical lookup, I guess.

[17:23] <masak> no, wait.

[17:24] <masak> you still have to specify to *which* quasi the placeholder belongs.

[17:24] *** SHODAN joined
[17:24] <TimToady> ¤term:( quasi { stuff } ) seems straightforward

[17:24] <masak> because it's not at all a given that what's inside the {{{ }}} is a single variable.

[17:24] <masak> er.

[17:25] <TimToady> that's why its ()

[17:25] <TimToady> *it's

[17:25] <TimToady> so you can have an expression in there

[17:25] <masak> I feel we're talking past each other a bit.

[17:26] <masak> quasi { {{{$a}}} ... quasi [ {{{$b}}} [[[$c]]] ] }

[17:26] <masak> please show this with the new syntax.

[17:27] <PerlJam> TimToady: is the category mandatory or just for "hinting" ?

[17:28] <TimToady> it would be mandatory

[17:28] <masak> yes.

[17:29] <masak> grrr, and we're supposed to get *fewer* non-ASCII symbols in core Perl 6, not more...

[17:29] <TimToady> sez hoo?

[17:29] <PerlJam> under the current universe categories are implicit by where the macro shows up in the parse?

[17:29] <masak> well, the FUD FAQ from 2008 sez it, for one... :)

[17:30] <TimToady> I'm not worried about FUD anymore

[17:30] <masak> my point wasn't really about FUD, but about ASCII.

[17:30] <TimToady> http://irclog.perlgeek.de/perl6/2011-10-27#i_4623544

[17:31] <masak> oh, didn't see that when I skimmed the backlog.

[17:31] <TimToady> it was part of what was addressed to you :)

[17:31] <masak> I see :)

[17:32] *** fsergot left
[17:32] <PerlJam> TimToady: do you think writing macros will be rampant in Perl 6 or mostly just the use of macros?

[17:32] <masak> I can only give anecdotal counterarguments. most people think it's a PITA to enter non-ASCII (or, more exactly, non-keyboard) characters in their editor.

[17:32] <masak> I'd hate for that to hinder macro adoption.

[17:32] <TimToady> macros should be a pita, in some sense :)

[17:32] <masak> I definitely don't buy that argument.

[17:33] <TimToady> we don't want people overusing htem

[17:33] <masak> "hey, we put this PITA character here to deter you. good luck finding how to type it!"

[17:33] <TimToady> yup

[17:33] <PerlJam> TimToady: the thing is, I expect people will want to use macros quite a bit.

[17:33] <masak> I'd suggest Lisp's prefix:<,> except I see that it doesn't really fit in Perl 6.

[17:33] <PerlJam> (use them for Good I mean  :)

[17:34] <TimToady> and then maybe they'll be dragged kicking and screaming into the 21st century

[17:34] <PerlJam> or just complain about having to type the funny characters

[17:34] <TimToady> let 'em complain

[17:35] <TimToady> they can always write their own ¤sigil macro

[17:36] <PerlJam> feels like an embedded second system

[17:36] <TimToady> they can write a 'use ASCII-ONLY-DAMNIT;' module if they want

[17:36] <masak> TimToady: my vote is on something easy-to-type and entirely innocuous, such as keeping {{{ }}}, or an all-caps identifier, like AST($x)

[17:36] <TimToady> won't fly, unless you only ever want terms

[17:37] <PerlJam> masak: I'd be fine with a unicode sigil as long as it's not too big of a pain to type or (more importantly) discover how to type

[17:37] <masak> I'm having enough trouble figuring out how to implement only terms :/

[17:37] <TimToady> nobody will hold you to implementing ¤infix:() just yet :)

[17:37] <TimToady> since in general it'll take more parsing hooks than we've done yet

[17:37] <masak> PerlJam: good for you. I think no matter which one we find, it'll keep some people back.

[17:38] <TimToady> anyone who can't figure out how to copy/paste the first ¤ has NO BUSINESS writing macros, it could be argued

[17:39] <PerlJam> masak: perhaps.  Seems like this is one of those delicate balancing acts.  (and it makes me glad that TimToady is the language designer :)

[17:39] <masak> quick general poll: people who know/don't know by hand how to type ¢ in their day-to-day editor?

[17:39] <TimToady> and {{{ }}} is really very cluttery, when you get down to it

[17:39] <masak> s/by hand/by heart/

[17:40] <TimToady> quick poll, how many people are worried about Cursor objects directly?

[17:40] <PerlJam> heh

[17:40] <masak> TimToady: I'd always thought that {{{ }}} is cluttery, but that's not purely a disadvantage. it stands out, especially with proper color coding.

[17:40] *** bluescreen10 left
[17:40] <TimToady> ¤ is really easy for a highlighter to recognize

[17:40] <TimToady> and the following word will tell it what state to be in after the ()

[17:40] <masak> any highlighter that isn't a Perl 6 parser will be toast highlighting Perl 6 anyway...

[17:40] <TimToady> {{{ }}} can't

[17:41] * masak should be making supper...

[17:41] <TimToady> I hope we've helped you develop an appetite :)

[17:41] <TimToady> not lost it :)

[17:42] <PerlJam> TimToady: how do you type ¤  ?

[17:42] <TimToady> compose x o

[17:42] <arnsholt> PerlJam: I hit the ¤ key on my keyboard =)

[17:42] <TimToady> I have a program like the unicode looker upper that greps the compose database instead

[17:42] <masak> TimToady: look, you make the rules. :) my initial reaction to the ¤ suggestion is that it's ugly and will have low adoption. {{{ }}} may be ugly, but it's really easy to type.

[17:43] <tadzik> I'm with masak, if that matters :)

[17:43] <TimToady> IT WON'T WORK!!!

[17:43] <TimToady> except for terms...

[17:43] <masak> besides, I'm not sure you ever responded to my nested-quasis use case.

[17:43] <PerlJam> "low adoption" sounds like a feature  :)

[17:43] <masak> PerlJam: I disagree.

[17:43] <TimToady> I don't know why you're putting an AST as the endpoint of a ...

[17:44] <masak> the '...' aren't literal, for once.

[17:44] <masak> put a ';' in places where needed, if that helps.

[17:44] <PerlJam> masak: perhaps that should have been a 1/2  :)   I go back and forth on it.  But I do think that "macro writers" will proliferate once the technology is in place.

[17:44] <masak> the point is that the inner quasi can placeholder the outer quasi.

[17:45] <masak> PerlJam: that remains to be seen. but I do dislike "let's make this a little uncomfortable because it's a dangerous feature"-type arguments.

[17:45] <TimToady> ¤OUTER::term:() then :)

[17:46] <masak> yeech :/

[17:46] <TimToady> the non-negotiable here is that we have to get the grammar rule that we're clobbering in there somewhere

[17:46] <masak> well, assuming it's on the top level of the inner quasi...

[17:46] <TimToady> at some point it's better to write separate quasis or macros and just compose them

[17:47] <TimToady> nested {{{ [[[ ]]] }}} is atrocious engineering

[17:47] <masak> TimToady: I always thought it was quite fitting that we only did terms in quasis, since we can only pass in terms as macro arguments anyway.

[17:47] <TimToady> you can parse anything an 'is parsed' can return, much more than terms

[17:48] <TimToady> terms is just the default

[17:48] <masak> I hear what you're saying. this is doing some violence to my mental model of macros.

[17:48] <masak> I need nutrition.

[17:48] * masak cooks

[17:48] <TimToady> o/

[17:49] <PerlJam> masak: maybe it's a good thing TPF is taking so long on your grant proposal  :)

[17:50] <TimToady> .oO(no battle plan survives first contact with the implementor)

[17:50] <TimToady> .oO(or with the language designer)

[17:54] *** Chillance joined
[17:55] *** bluescreen10 joined
[17:56] <TimToady> std: macro foo($a,$b,$c) { quasi { {{{$a}}} ... quasi [ {{{$b}}} [[[$c]]] ] } }

[17:56] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/u0YJqAbZeg line 1:␤------> [32m { quasi { {{{$a}}} ... quasi [ {{{$b}}}[33m⏏[31m [[[$c]]] ] } }[0m␤    expecting any of:␤   bracketed infix␤        infix or meta-in…

[17:56] <TimToady> what I thought, doesn't even parse

[17:58] <TimToady> fundamentally, the parser must know what reduction a macro is replacing, and a quasi-unquote is just a funny looking macro

[17:59] <TimToady> well, the parser must know that for hygienic macros, not text macros, to be precise

[18:00] <TimToady> text macros can get away with it because the reparse to put parser into the correct final state

[18:00] <TimToady> s/the/they/

[18:00] *** Je joined
[18:01] <moritz> TimToady: in your mental model, what kind of syntaxes can be replaced with {{{$placeholder}}}, or whatever syntax we'll chose for them?

[18:01] *** im2ee left
[18:01] *** benabik left
[18:01] <moritz> things that the OPP parses for you?

[18:01] <TimToady> any named rule in the grammar

[18:02] <moritz> wow.

[18:02] *** benabik joined
[18:02] <TimToady> that's why I said it'd require a bit more work on the parser

[18:02] <masak> std: macro foo($a,$b,$c) { quasi { {{{$a}}}; quasi [ {{{$b}}}; [[[$c]]] ] } }

[18:02] <moritz> so even stuff like the identifier in a sigiled variable

[18:02] <p6eval> std be1f10e: OUTPUT«ok 00:03 140m␤»

[18:02] *** im2ee joined
[18:02] <TimToady> it's fine to implement just terms for now, but I want the syntax that expressive

[18:02] <masak> <masak> put a ';' in places where needed, if that helps.

[18:02] <TimToady> otherwise we have no argument to bring against the homoiconophiles

[18:03] <masak> I'm also worried about the homoiconophiles.

[18:03] <masak> but mostly because they'll always win on minimal syntax, and maybe on minimal semantics, too.

[18:04] <TimToady> otherwise they'll just say "Well, you can't really do anything interesting with just the nouns"

[18:04] <TimToady> but also because some of our thunky infixes are already macro-y, and we need to handle that eventually

[18:05] <TimToady> well, they'll always win the argument that they've pushed the waterbed down maximally in one spot

[18:05] <masak> I'm not planning to do 'is parsed' during my grant. but of course we should plan for it.

[18:05] *** sivoais left
[18:07] <TimToady> btw, the semicolon is not sufficient; it's parsing {{{$b}}} is three nested blocks

[18:07] <TimToady> *as

[18:07] <TimToady> no other quotes can reach inside other quotes

[18:09] <[Coke]> masak: I have no idea how to type ¢ in my editor of choice.

[18:09] <masak> TimToady: what!? then what is all this futuristic fancy nibbler-based parser architecture *for*?

[18:09] <masak> TimToady: I thought it was *just* these kinds of things it took care of without blinking.

[18:09] * TimToady is tempted to channel MJD

[18:10] <masak> seriously, I'm surprised about this.

[18:10] <TimToady> std: qq[ { "]]]]]]]]

[18:10] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse double quotes at /tmp/yaPNH6pmRF line 1:␤------> [32mqq[ { [33m⏏[31m"]]]]]]]][0m␤Couldn't find final '"'; gave up at /tmp/yaPNH6pmRF line 1 (EOF):␤------> [32mqq[ { "]]]]]]]][33m⏏[31m<EOL>[0m␤Parse failed␤FAILED …

[18:10] <TimToady> std: qq[ { "]]]]]]]]" } ]

[18:10] <p6eval> std be1f10e: OUTPUT«ok 00:01 119m␤»

[18:11] <masak> right, sure. but those are string quotes.

[18:11] <TimToady> and these are quasi quotes

[18:11] <TimToady> they're still quotes

[18:11] <masak> I guess I assumed that *because* there was this {} <-> {{{}}} sympathy, it would reach through blocks. guess not.

[18:11] <[Coke]> masak: though I was able to google it in under a minute, and it'll work on my editor on the 3 platforms I tend to use.

[18:12] <TimToady> no place else in Perl 6 tracks multiple start/stop delimiters at the same spot

[18:14] <TimToady> and if {} <-> {{{}}} makes you expect that, then maybe that's another reason for breaking it

[18:15] <TimToady> and the scoping should be determined by the variable's you reference inside, anyway, methinks

[18:16] <TimToady> s/'//

[18:16] <TimToady> the parser knows where $a, $b, and $c come from

[18:17] *** sivoais joined
[18:19] <masak> right, but that only works for the simple case, where there's just a variable inside.

[18:20] <masak> also, variables are not really tied to quasis, they're tied to scopes in general. outside macro, inside macro, inside quasi...

[18:21] <TimToady> I think you're still mixing up the quasi-unquasi levels, they're very either-or, whether your in quasi or not, and a nested macro will make that clear

[18:22] *** Je left
[18:24] *** daniel-s left
[18:24] <TimToady> *you're

[18:24] *** envi_ left
[18:34] <cognominal_> so far, macros are very quasi-modo.

[18:34] <[Coke]> cognominal_: ugh. I had a hunch someone would make that pun.

[18:35] <sjohnson> .u music

[18:35] <phenny> U+0749 SYRIAC MUSIC (◌݉)

[18:35] <colomon> boy, that rings a bell

[18:36] <TimToady> odd that I don't find this conversation bazaar...

[18:36] <cognominal_> [Coke] :)

[18:46] <cognominal_> nqp: say('a')

[18:46] <p6eval> nqp: OUTPUT«a␤»

[18:47] *** leprevost left
[18:48] *** daxim left
[18:49] *** Gruber_ joined
[18:51] *** Je joined
[18:51] *** Grrrr left
[18:51] *** Gruber_ is now known as Grrrr

[18:58] * colomon just suddenly realized PerlJam might be a reference to the band.  Sigh....

[19:01] <[Coke]> You beat me to it.

[19:01] <[Coke]> (no pun intended. I never made that cxn either

[19:01] *** araujo left
[19:01] <TimToady> That's okay, I laugh three times at every joke: once when it's told, once when it's explained, and once when I get it.  :)

[19:02] *** araujo joined
[19:03] <colomon> :)

[19:05] *** kaare_ joined
[19:18] *** bluescreen10 left
[19:19] *** packetknife joined
[19:23] *** Je left
[19:28] <masak> TimToady: ok, I've internalized my new understanding of how quasis work. it's still an open question to me whether the semantics I thought was there can be emulated somehow.

[19:29] <masak> TimToady: also the fact that {{{}}}s don't nest makes me slightly less attached to them. doesn't make me like ¤ better, though. I hope there's a cuter solution out there somewhere.

[19:29] *** packetknife left
[19:30] <PerlJam> .oO( what I laugh at 3 times is funny? )

[19:31] <PerlJam> colomon: no, PerlJam isn't a reference to the band.  It was more of a "happy accident" that I chose my nick right around the same time as they were becoming popular.

[19:31] <PerlJam> colomon: Though my brother actually chose the nick and he probably listened to them at the time while I was oblivious.

[19:32] <masak> you let your brother choose IRC nick for you...?

[19:33] <PerlJam> aye.  I had a few options, he went with this one, I liked it, it stuck.

[19:33] <masak> perl6: say <perl ruby python>.roll ~ <jam hack jazz>.roll

[19:33] <p6eval> pugs b927740: OUTPUT«*** No such method in class Array: "&roll"␤    at /tmp/tz2AeUKQTX line 1, column 5 - line 2, column 1␤»

[19:33] <p6eval> ..rakudo 158bd0, niecza v10-66-g71325b0: OUTPUT«rubyhack␤»

[19:33] <PerlJam> later I went with perlpilot and there was a time I tried "OpenSourceror"  :)

[19:33] <masak> oops, .roll wasn't fair to Pugs.

[19:34] <PerlJam> but ... I'm just too used to PerlJam to change :)

[19:34] <masak> PerlJam: sir, I would've been honored to address you as OpenSourceror :P

[19:34] <colomon> wait, rakudo and niecza both came up with the same random choices?

[19:34] <PerlJam> colomon: not very random, eh?

[19:34] <masak> colomon: yeah, but the chances for that weren't astronomical.

[19:34] <masak> colomon: 1 in 9.

[19:35] <colomon> perl6: say <perl ruby python>.roll ~ <jam hack jazz>.roll

[19:35] <p6eval> niecza v10-66-g71325b0: OUTPUT«rubyjam␤»

[19:35] <p6eval> ..rakudo 158bd0: OUTPUT«rubyhack␤»

[19:35] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Array: "&roll"␤    at /tmp/8iPxc57Mfr line 1, column 5 - line 2, column 1␤»

[19:35] *** packetknife joined
[19:35] <masak> perl6: say <perl ruby python>.pick ~ <jam hack jazz>.pick

[19:35] * colomon is relieved.

[19:35] <p6eval> pugs b927740: OUTPUT«pythonjam␤»

[19:35] <p6eval> ..niecza v10-66-g71325b0: OUTPUT«rubyjazz␤»

[19:35] <p6eval> ..rakudo 158bd0: OUTPUT«perlhack␤»

[19:35] <masak> \o/

[19:35] <PerlJam> heh

[19:35] <masak> nice distribution :)

[19:35] * masak wishes perlhack were here

[19:37] *** bluescreen10 joined
[19:38] *** SHODAN left
[19:43] <masak> hm, I wonder if I can create an Epimenides paradox...

[19:44] <masak> perl6: say "What ", <rakudo niecza pugs>.pick, " says isn't true."

[19:44] <p6eval> pugs b927740: OUTPUT«What niecza says isn't true.␤»

[19:44] <p6eval> ..rakudo 158bd0, niecza v10-66-g71325b0: OUTPUT«What rakudo says isn't true.␤»

[19:44] <masak> Rakudo went Epimenides.

[19:45] <masak> I don't know about the status of the other two, but it's possible that paradoxicity is contagious.

[19:45] *** soh_cah_toa joined
[19:46] *** packetknife left
[19:48] <masak> is there a more general name for the "forwards compatibility" afforded by OO/interfaces/polymorphism and closures, but not by "regular" procedural programming?

[19:49] <masak> maybe the answer I'm looking for is "IoC", but I'm not sure...

[19:50] <PerlJam> I'm not sure what you mean by "forwards compatibility", but it doesn't soundlike IoC

[19:51] <masak> when you write code that's able to call on code that hasn't been written yet.

[19:52] <masak> I can see how such a property might be really nice for big code bases, because it allows you to compensate for changing requirements to some extent.

[19:52] <masak> without having to re-model, I mean.

[19:54] <colomon> That's really pretty standard for C code too, you know.

[19:54] <PerlJam> okay ... still wouldn't call that IoC

[19:54] <japhb> masak, that property is in fact one of the most common reasons I write things in OO form  when that would be more complex than the procedural form.

[19:54] <japhb> "Don't like the way I did it?  Derive a subclass and enjoy."

[19:55] <japhb> It's not infinitely powerful that way, of course, but it helps with the easy cases.

[19:55] <PerlJam> masak: maybe  "defensive design"  :)

[20:01] *** supernovus joined
[20:01] *** GlitchMr left
[20:03] <masak> japhb: sounds like convenience bordering on misuse... :)

[20:04] <masak> PerlJam: there was a paper that I read that talked about joining-points in the model where things were liable to change. paper said "put your interfaces there". sounded like a good rule of thumb.

[20:06] <japhb> masak, don't forget that virtually every advance in computer language design over the last 50 years was to make something easier or less bug-prone or both.  Having learned programming philosophy from Michael Abrash's works at a critical point in my life, I aim to see such constructs for what they can do for me, not what the axe-grinder who invented them thought they should be used for.  ;-)

[20:07] <masak> japhb: oh, sans doute.

[20:08] *** packetknife joined
[20:08] <masak> japhb: I like to think that way too. the more one sees the various constructs as vehicles that will take you places, the better, I think.

[20:08] * japhb chuckles

[20:08] <japhb> quite.

[20:08] <masak> japhb: but there are also "patterns of misuse" that are worth paying attention to.

[20:09] * japhb returns the 'sans doute' comment, with extra emphasis.

[20:09] <PerlJam> .oO( patterns of abuse? )

[20:09] <masak> PerlJam: I was so close to writing that!

[20:09] <masak> sounded wrong, though.

[20:09] <colomon> Michael Abrash!!!

[20:09] <japhb> sadly, bad connotations to that phrasing in this part of the world

[20:10] <masak> yeah, I figgered.

[20:10] <colomon> I adored the Zen of Assembly Language.

[20:11] <japhb> colomon, One of my favorites, easily.

[20:11] <colomon> japhb: I haven't read it in ages, and I never really directly applied its contents, but I hope that at least some of the philosophy rubbed off.

[20:12] <japhb> I used to wonder what kind of amazing would come from having Michael Abrash and Jon Bentley on the same project.

[20:12] <japhb> colomon, heh.  I think that's the important part anyway.

[20:13] <japhb> Heck, I think one of the biggest value of that book is taking some simple concepts and driving them home so completely that by the end you practically feel them in your bones.

[20:15] <colomon> You have to actually time it, not just guess where it's slow.  :)

[20:15] <japhb> That's a really big one.  :-)

[20:17] *** Je joined
[20:19] *** Je left
[20:22] <colomon> The other thing that really stands out in my memory is the program (from Zen of Graphics, maybe?) which optimized the Game of Life by generating custom machine code for each possible board size (as needed).

[20:23] <PerlJam> japhb: you might find that Jon Bentley and Michael Abrash can't stand each other and fight constantly  :)

[20:24] <japhb> One of the things I loved about that Game of Life contest was that when he discovered some people had broken some of the rules to go faster, he was all ready to put his foot down and disqualify them, until he discovered that EVERY entrant would have been disqualified.  :-)

[20:24] <japhb> PerlJam, LOL

[20:24] <japhb> Well, the mix of Abrash and Carmack was pretty powerful.

[20:24] <japhb> But then they were both ASM experts ....

[20:27] <japhb> colomon, regarding generating code for each board size ... I'm reminded of a Chuck Moore rant about programmers trying to write general code that is "highly configurable" and "runs everywhere".  He argued that you can write an entire OS in a few K if it only has to run on one system -- but that's not as rare as most people think.

[20:29] <japhb> I never go quite that far, but it does serve as a nice reminder when I'm about to make my configuration files Turing complete or decide that I have to run on 16- and 64-bit CPUs or somesuch.

[20:29] <PerlJam> that "entire OS" sounds mostly like a scheduler :)

[20:29] <japhb> PerlJam, he wrote his disk drivers in a couple hundred bytes!

[20:30] <japhb> The core of Forth is like 4K, and it's a lot more complex than you'd think.

[20:30] <colomon> heh, Thinking Forth was another very influential book for me.  :)

[20:30] * masak keeps close notes

[20:30] <PerlJam> japhb: I can't imagine that it'd ve more complex than I'd think  ;)

[20:30] <PerlJam> s/ve/be/

[20:31] <japhb> PerlJam, you're a Forthwright I take it?

[20:31] <masak> japhb: what complexity is one likely to miss when thinking of the Forth core?

[20:32] <PerlJam> indeed.

[20:32] <japhb> does>

[20:34] <japhb> Also, the Forth core is conceptually compressed in a way that I found mind-bending the first time around.  It's like someone had zipped the source to an OS and an editor and somehow kept the output as readable 7-bit ASCII text

[20:34] * japhb shrugs

[20:35] <japhb> But like most moments of enlightenment, it will be obvious to some, and world-changing to others ....

[20:35] <cognominal_> For one year, I had a job programmaing that beast http://oldcomputers.net/Panasonic_HHC.html using SnapForth using an Apple II

[20:36] <japhb> That thing looks awesome!

[20:36] <colomon> I think I've said it before here, but lately I've started to think that the world of programming languages is like a circle Lisp and Forth, which seem like they ought to be complete opposites, are disturbingly close -- and honestly, I usually like Chuck Moore's choices better than whoever designed Lisp.  :)

[20:37] <japhb> NOD

[20:37] * colomon lost a sentence-ending period in there, but hopefully it is still relatively clear.

[20:38] <colomon> cognominal_: yow.

[20:39] <cognominal_> In the same small company, the had also a portable panasonic PC probably around 20kg. They made a point that each pixel was visible instead of desiginng some convolution so that a white screen would be uniservally white

[20:40] <japhb> An odd optimization choice.  Why?

[20:40] <cognominal_> White is not the appropriate word because phosphor displays were not white.

[20:40] <masak> colomon: I think it was Paul Graham who said that Lisp and C stand out as the two "pure" languages around which all the others flock.

[20:41] <colomon> masak: but Forth is actually much more "pure" than C, and not in C's orbit at all.

[20:41] <cognominal_> japhb: I don't know. But that striked me as odd. I think they thought this was some form of high precision.

[20:41] <masak> colomon: no, Forth is probably in Lisp's orbit, like you say.

[20:42] <colomon> masak: but it's not.

[20:42] <colomon> it's hard to explain.

[20:42] <japhb> It really is a world of its own.

[20:42] <masak> heh. snobs :P

[20:42] <cognominal_> Doing forth helped me immensely when I programmed with NeWS at Sun which was a window system based on PostScript.

[20:43] <colomon> Forth was the first structured language I ever programmed in, I loved it on my Commodore 64.

[20:43] <cognominal_> Doing windowing programming using  exch, pop and roll was weird.

[20:43] <japhb> Now there's an image.

[20:43] <masak> has any one checked out False?

[20:44] <masak> it feels a bit like APL, Forth, and Perl all mixed together.

[20:44] <cognominal_> So NeWS was years ahead as an imaging system, even if the implementation was very bad, but sucked as a language.

[20:44] <cognominal_> http://en.wikipedia.org/wiki/NeWS

[20:45] *** packetknife left
[20:46] <colomon> masak: False looks like the ugly predecessor of Factor

[20:50] <masak> Factor looks like a modern Forth to me.

[20:52] <masak> niecza: my @a = 1; push @a, $_ if any(@a) * any(2, 3, 5) == $_ for 2..1000; say @a.perl

[20:52] <p6eval> niecza v10-66-g71325b0: OUTPUT«[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50, 54, 60, 64, 72, 75, 80, 81, 90, 96, 100, 108, 120, 125, 128, 135, 144, 150, 160, 162, 180, 192, 200, 216, 225, 240, 243, 250, 256, 270, 288, 300, 320, 324, 360, 375, 3…

[20:53] <masak> O(N ** 2) way to generate the Hamilton sequence ;)

[20:54] <masak> er, Hamming sequence.

[20:54] <colomon> masak: Forth old timers won't like that, but it seems like a pretty fair summary.  :)

[20:55] <colomon> dynamically typed, higher order Forth.  :)

[20:57] *** prammer joined
[21:01] *** explorer__ joined
[21:01] <masak> let the pair (X, Y) denote the assertion "language X drinks very deeply from the well of programming concept Y"

[21:01] <masak> (Forth, stacks)

[21:01] <masak> (Lisp, ASTs)

[21:02] <masak> (APL, operators)

[21:02] <sbp> APL drank so deeply from the well of programming concept operators that it passed out

[21:02] <TimToady> (Perl,_)

[21:03] <masak> TimToady: what, trailing commas? :P

[21:03] *** jferrero left
[21:03] <masak> underscores?

[21:03] <TimToady> I'm thinking in Prolog

[21:03] <masak> yes, I realize.

[21:03] <masak> so, "Perl, whatever"

[21:04] <masak> which is quite fitting, considering.

[21:04] <masak> "In Perl, you can go overboard with any programming concept you like!"

[21:04] <masak> "We let *you* pick the foot to shoot yourself in!"

[21:04] *** am0c left
[21:05] <masak> :P

[21:05] <tadzik> . o O ( everything is a subject )

[21:05] <sjohnson> .oO ( fat face )

[21:05] <masak> "Perl gives you enough rope to shoot yourself in the foot!"

[21:06] <sbp> ugh, I need a #perl6-overflow to pipe all my bad jokes to

[21:06] <sbp> ("in Soviet Russia, everything *subjects* you!")

[21:06] <sbp> somebody make things happen

[21:07] <masak> perl6: say "things, happen"

[21:07] <sjohnson> 14( 13*14≖‿≖13*14)

[21:07] <p6eval> pugs b927740, rakudo 158bd0, niecza v10-66-g71325b0: OUTPUT«things, happen␤»

[21:08] <sbp> you know, I've been lurking here for about a year now hoping that one day I would feel guilty enough to actually sit down and write a whole perl6 library or weave together a whole book getting people into perl6. at least every bad joke I make does make me feel one infintesimally small step closer to that goal

[21:08] <sbp> programming, Zeno's way

[21:08] *** bluescreen10 left
[21:09] <masak> sbp: lurkers are like neutrons. suddenly, one day they transform into a charged particle and get busy :)

[21:09] <sjohnson> masak: i'm a late blooping electron

[21:09] <masak> sjohnson: :)

[21:09] <sbp> I don't know, I'm quite thankful for my neutrons as well as my protons and other charged particles

[21:10] <sbp> I wouldn't feel the same without them

[21:10] <masak> I'm not sure my analogy landed intact.

[21:11] <sbp> I read some article years ago about learning new natural languages, that said you have to work especially hard compared to most other tasks because if you already know a language your brain doesn't really see any particular reason to learn a new one, so it complains extra hard

[21:11] <sbp> I wonder if something similar is true of programming languages

[21:11] <sbp> I learned a lot of languages more or less simultaneously, and now... hard to gather the momentum

[21:11] <bonsaikitten> sbp: immersion

[21:11] <sbp> what do you think I'm doing *here*? :-)

[21:12] <bonsaikitten> if you try to learn something just to pad your resume it's hard... get forced to learn or die and you will refuse to just die :)

[21:12] * bonsaikitten is just starting to absorb Mandarin ... nice brain teaser 

[21:12] <masak> I'll say.

[21:13] <masak> sbp: for me, it was "have I tried to write X in Perl 6 yet?" -- I'm still coming up with stuff I haven't tried. ;)

[21:13] <sbp> it is interesting to see how people learn programming languages. lots of different approaches. I learn most from just sitting down and tinkering by trial and error, or osmosis from places like this; but some people like strong guides

[21:13] <bonsaikitten> masak: I get distracted too easily ... "hey, how does agetty work?"

[21:13] <sbp> I'd like to see animated code that has two columns

[21:14] <masak> bonsaikitten: 你住在哪里？

[21:14] <sbp> one column is syntax highlighted code, the other is some structure that the code is operating on. then for each step of the process, the code that performs that action, and the relevant section in the operated-upon data, are simultaneously highlighted

[21:14] <sbp> (I did make something similar for a small bit of JavaScript once, but it wasn't really for educational purposes)

[21:15] <sbp> but I don't know if that's too passive. it's also quite hard work to set up

[21:15] <bonsaikitten> masak: not yet :) let me learn pinyin and a base vocabulary to a sane level before I escalate to hansi

[21:16] <masak> bonsaikitten: fair enough -- don't wait too long with the hanzi, though :)

[21:16] <masak> they're 1/3 of the words, besides sound and meaning.

[21:16] * masak yawns

[21:16] <japhb> Oh, that reminds me: every so often in the last couple years I've seen code presented on the web in some variant of literate programming: the prose goes in one column, the source next to it, and each block of code and section of text are aligned horizontally, so you can scroll down to the part you are interested in, and look directly to one side to read the commentary.  Anyone remember what program does this (assuming my description was cl

[21:16] <japhb> ear enough)?

[21:17] <bonsaikitten> yes,one thing at a time :) 

[21:17] <masak> 'night, bonsai butterflies

[21:17] <cognominal_> japhb: docco

[21:17] <sbp> same guy who made CoffeeScript

[21:17] <masak> http://jashkenas.github.com/docco/

[21:18] <sbp> @lazyweb p6occo!

[21:18] <cognominal_> it spwaned a cottage industry cuz it has been translated in many languages.

[21:18] <sbp> cameliocco?

[21:19] <sbp> they should have called the Java one doccocino

[21:19] <japhb> cognominal_, masak, thanks!

[21:23] <cognominal_> japbh: I have written some stuff to dynamically view a parse tree that is inspired from docco. It is in standby. I am waiting for nom to be fixed    https://github.com/cognominal/code-viewer

[21:24] *** ksi left
[21:28] <im2ee> Good night! :)

[21:28] <im2ee> o/

[21:28] *** im2ee left
[21:30] *** fsergot joined
[21:34] *** kaare_ left
[21:38] *** fod joined
[21:42] *** fod left
[21:49] *** abercrombie joined
[21:54] *** icwiener left
[22:04] *** dalek left
[22:05] *** y3llow left
[22:06] *** dalek joined
[22:06] *** ChanServ sets mode: +v dalek

[22:06] *** y3llow joined
[22:07] *** drbean left
[22:07] *** aindilis left
[22:13] *** drbean joined
[22:16] *** cognominal_ left
[22:18] *** cognominal joined
[22:21] *** dalek left
[22:22] *** dalek joined
[22:22] *** ChanServ sets mode: +v dalek

[22:31] *** cognominal left
[22:31] *** cognominal joined
[22:50] *** replore_ left
[22:54] *** whiteknight joined
[22:59] *** Chillance left
[23:00] <jnthn> ...well, that was more than a few hours. And more than a couple of beers... :)

[23:02] <jnthn> Hm, and I have meetingish thingy in the morning. Guess I don't get Rakudo tuits tonight then. But it was good to go and relax for a while.

[23:02] *** drbean left
[23:09] *** drbean joined
[23:12] *** molaf_ joined
[23:13] *** molaf left
[23:19] *** dual left
[23:28] <[Coke]> jnthn: there is no problem beers more better.

[23:37] *** donri left
[23:43] *** worr left
[23:47] *** benabik left
[23:52] <supernovus> what is the best way to empty an array without splice?

[23:56] <abercrombie> @a=()

[23:57] <supernovus> abercrombie: thanks, that'll work just fine. I still hope splice gets fixed soon though :-)

