[00:00] *** jferrero left
[00:00] <sorear> niecza can now build itself again...

[00:01] <lichtkind> shhh blogs.perl is broken

[00:01] *** cdarroch left
[00:15] <TimToady> colomon: typo: [&&}

[00:17] <colomon> ?

[00:17] <colomon> oh, right

[00:17] <colomon> (at this distance, both brackets look the same.  stupid eyes.)

[00:17] <TimToady> also, how does your solution compare with [lcm] 2..20

[00:18] <colomon> very poorly

[00:18] <colomon> though I haven't timed them carefully

[00:21] <colomon> well... [lcm] is twice as fast as my fastest, I think

[00:23] <sorear> Bollman's solution works by considering each prime separately

[00:23] <sorear> log(20, 7).floor is the highest power of 7 that fits in 20

[00:24] <sorear> therefore, it is the highest power of 7 that fits in any number less than 20

[00:24] <sorear> therefore, it is the power of 7 in [lcm] 1..20

[00:29] *** cotto left
[00:31] *** icwiener left
[00:32] *** daniel-s left
[00:42] <lichtkind> good night 

[00:42] *** wamba left
[00:42] *** beekar left
[00:42] *** lichtkind left
[00:44] <colomon> sorear: ...... damn, that's slick.

[00:44] <colomon> thanks for the explanation.  sorear++

[00:49] *** jaldhar left
[00:50] *** jaldhar joined
[00:51] <colomon> niecza: say 232 gcd 16

[00:51] <p6eval> niecza v6-184-g55ff541: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical &infix:<gcd> in mainline␤␤Server stack trace: ␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknow…

[00:52] <colomon> bother

[00:53] <sorear> rakudo: say "ﬀ" ~~ /ff/i

[00:53] <p6eval> rakudo b2bc99: OUTPUT«===SORRY!===␤Unsupported use of /i; in Perl 6 please use :i at line 22, near ""␤»

[00:54] <sorear> rakudo: say "ﬀ" ~~ m:i/ff/

[00:54] <p6eval> rakudo b2bc99: OUTPUT«␤»

[00:54] <sorear> rakudo: say "ß" ~~ m:i/SS/

[00:54] <p6eval> rakudo b2bc99: OUTPUT«␤»

[00:54] <sorear> rakudo: say "ß" ~~ m:i/ss/

[00:54] <p6eval> rakudo b2bc99: OUTPUT«␤»

[00:55] <sorear> rakudo: say "Σ" ~~ m:i/σ/

[00:55] <p6eval> rakudo b2bc99: OUTPUT«Σ␤»

[00:55] *** Garda joined
[00:55] *** Garda left
[00:57] *** takadonet left
[01:01] *** noganex_ joined
[01:04] *** noganex left
[01:06] *** thou left
[01:20] *** cotto joined
[01:27] *** daniel-s joined
[01:28] <daniel-s> \o

[01:28] <sorear> o/

[01:32] <colomon> \oo/

[01:45] <daniel-s> this is kinda more general than perl6

[01:45] <daniel-s> but after learning the basic parts of the syntax of a language, what should I do to become a better programmer

[01:46] <daniel-s> I never studied computer science

[01:46] <colomon> daniel-s: program!  :)

[01:46] <daniel-s> is that all?

[01:46] <colomon> seriously, actually trying to do stuff with a programming language is huge

[01:47] <colomon> I don't know if it's all, but it's probably 80-90% of it, anyway.

[01:47] <colomon> there's more to learn, but it's hard to appreciate it without getting your hands dirty, IMO.

[01:47] <colomon> (there's always more to learn.)

[01:48] <sorear> the hard part is finding something to do.

[01:50] <colomon> sorear: you think?  for me, the hard part is usually finding time to do it.

[01:51] * sorear needs a direction suggestion

[01:51] <colomon> for niecza, or in general?

[01:52] <daniel-s> well, I have been looking at stuff on github or sourceforge

[01:52] <sorear> niecza... I have trouble prioritizing

[01:52] <daniel-s> but almost all of them look to daunting

[01:52] <daniel-s> the longest thing I've created has been about 30 lines

[01:53] <sorear> start small.

[01:53] <sorear> if you can't find something useful to do, do something useless

[01:54] <sorear> make something useless, because if it's useful you might be tempted to keep it

[01:54] *** cognominal_ joined
[01:55] <sorear> rule of thumb: anything that you make in your first few months will be a maintance nightmare

[01:55] <sorear> alternatively, contribute to someone else's project; then they can clean stuff up

[01:55] <sorear> niecza has a nice long TODO list :D

[01:57] *** cognominal left
[01:57] *** whiteknight left
[02:00] *** cotto left
[02:00] *** cotto joined
[02:04] *** krakan left
[02:07] <colomon> niecza: macros?  module compatibility?  

[02:07] <p6eval> niecza v6-184-g55ff541: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Confused at /tmp/Mcl2bt4FhT line 1:␤------> [32mmacros[33m⏏[31m?  module compatibility?[0m␤␤Undeclared routine:␤        'macros' used at line 1␤␤Parse failed␤␤»

[02:07] <colomon> *sorear:

[02:07] <colomon> (sigh)

[02:09] <sorear> confused eh.  apt.

[02:10] <sorear> right, macros and tests and stuff

[02:10] <colomon> macros are sort of a crazy wish

[02:10] <colomon> but tests and modules would be really nic

[02:10] <colomon> nice.

[02:11] <colomon> and automatically would create additional test code to run, additional issues to fix, etc....

[02:12] <sorear> daniel-s: could I interest you in the Get Niecza Passing More Tests project?  lots of pieces big and small

[02:13] * colomon is hoping YAPC::NA week means more time for him to hack on Rakudo and Niecza.

[02:16] <sorear> daniel-s: rosettacode might also be fun, although it has fewer big tasks

[02:28] <sorear> colomon: Did anything ever become of your attempt at **?

[02:28] <sorear> daniel-s: still here?

[02:28] <colomon> sorear: It's sitting around halfway done.  Maybe further, hard to know what I'm missing.  :)

[02:29] <daniel-s> hey

[02:29] <daniel-s> sorry, I'm at work atm

[02:29] <daniel-s> sorear: I wouldn't mind helping with niecza

[02:35] <daniel-s> do you mean implement some of the things on rosettacode that haven't been done in perl6 yet?

[02:41] <TimToady> or you could turn some of the rosettacode entries into Tests

[02:43] <sorear> that's what I meant by "rosettacode might also be fun", yes.

[02:50] *** cotto left
[02:52] *** takadonet joined
[03:08] *** Chillance left
[03:19] *** zby_home__ left
[03:22] *** cotto joined
[03:23] *** Su-Shee_ joined
[03:24] <mikemol> (On converting RC entries into unit tests) TimToady++

[03:25] <mikemol> Hm. That gives me an idea.

[03:27] *** Su-Shee left
[03:28] <daniel-s> yea, what does that mean exactly?

[03:28] <daniel-s> write code implementing something from RC, using parts of perl6 that may or may not have been implemented yet

[03:29] <daniel-s> so that when they are an implementation passes the test?

[03:29] <mikemol> daniel-s: I take it to possibly mean two different things.

[03:29] <TimToady> more like, set up tests that one of the implementations passes already, such that other implementations do the same thing

[03:30] <mikemol> One, you might take the output of an existing snippet, and test that future versions of compilers give the same result.

[03:30] <TimToady> plus check for regressions in the implementations that do it already

[03:30] <mikemol> The other is to test that the language behaves nicely for the problem space, but I think TimToady covers most of that ground.

[04:02] *** Bzek joined
[04:03] *** thou joined
[04:12] *** molaf_ left
[04:18] *** lue joined
[04:22] <dalek> rakudo/nom: ca7573c | pmichaud++ | src/core/ (2 files):

[04:22] <dalek> rakudo/nom: Add infix:<~~> and things needed for given/when to work.

[04:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ca7573cb17

[04:22] <dalek> rakudo/nom: 134f52e | pmichaud++ | src/ (5 files):

[04:22] <dalek> rakudo/nom: jnthn++ recommends "istype" instead of "p6isa".

[04:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/134f52e905

[04:22] <dalek> rakudo/nom: 7233ca4 | pmichaud++ | src/core/ (5 files):

[04:22] <dalek> rakudo/nom: Initial infix:<...> sequencing operator.

[04:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7233ca4d28

[04:23] *** satyavvd joined
[04:39] <TimToady> http://rosettacode.org/wiki/Vigen%C3%A8re_cipher#Perl_6   <-- massive use of hypers

[04:41] <TimToady> only 3 more and we'll have 300

[04:45] <jdhore1> THIS! IS! PERL! 6!

[04:45] <jdhore1> Nope, doesn't work.

[04:46] <sorear> TimToady++ # I finally understand soundex

[04:46] <benabik_> "This is line noise!"  "No.  This is PERL!!!"

[04:47] *** benabik_ is now known as benabik

[04:48] <jdhore1> benabik, that works fairly well

[04:55] <pmichaud> good evening, #perl6

[04:55] <TimToady> howdees

[04:55] <pmichaud> nom: my @a = 1,1,{$^a + $^b} ... * ;   say @a[^10];   # checking

[04:55] <p6eval> nom: OUTPUT«This type cannot unbox to a native integer␤current instr.: 'exists' pc 213673 (src/gen/CORE.setting.pir:0) (:1413)␤»

[04:56] <pmichaud> grrr

[04:56] <pmichaud> nom: my @a = 1,1,{$^a + $^b} ... * ;   say @a[(^10,)];   # checking

[04:56] <p6eval> nom: OUTPUT«This type cannot unbox to a native integer␤current instr.: 'exists' pc 213673 (src/gen/CORE.setting.pir:0) (:1413)␤»

[04:56] <pmichaud> nom: my @a = 1,1,{$^a + $^b} ... * ;   say @a[0,1,2,3,4,5];   # checking

[04:56] <p6eval> nom: OUTPUT«Any()Any()Any()Any()Any()Any()␤»

[04:56] <pmichaud> *sigh*

[04:56] <pmichaud> not yet, I guess.

[04:56] <sorear> helloes pmichaud

[04:56] <sorear> needs a rebuild?

[04:57] <pmichaud> no, looks like a bugger.

[04:57] <pmichaud> oh, probably a problem with array assignment.

[04:59] * sorear is afraid to start culling the LHF because daniel-s might come back

[04:59] <pmichaud> nom:  my $x := 1,1,{$^a+$^b} ... *;  say $x[20];  # testing

[04:59] <p6eval> nom: OUTPUT«Method 'at_pos' not found for invocant of class 'Parcel'␤current instr.: 'postcircumfix:<[ ]>' pc 202892 (src/gen/CORE.setting.pir:0) (:248)␤»

[05:00] <pmichaud> bah

[05:00] <pmichaud> nom:  my $x := (1,1,{$^a+$^b} ... *).flat;  say $x[20];  # testing

[05:00] <p6eval> nom: OUTPUT«10946␤»

[05:01] <TimToady> .oO(It's a good thing there's more than one way to do it, because most of them don't work...)

[05:01] <pmichaud> lol

[05:03] <TimToady> sorear: pity you had to learn this jaw-cracker of a language first in order to understand soundex  :)

[05:05] <pmichaud> TimToady: got a keynote yet?  ;-)

[05:05] <TimToady> I've got about six lines in my ideas file so far... :/

[05:06] <TimToady> but since they want me to talk about "community", I can always just open it up for questions :)

[05:06] <daniel-s> hey

[05:06] * daniel-s is back

[05:06] <sorear> Hi!

[05:06] <TimToady> Lo!

[05:07] <daniel-s> [13:00]  * sorear is afraid to start culling the LHF because daniel-s might come back

[05:07] <daniel-s> were you looking for me?

[05:07] <sorear> daniel-s: We never finished talking earlier.  But work is more important

[05:08] <daniel-s> well, I'm supposed to finish at 4:30

[05:08] <daniel-s> it's just after 1 at the moment

[05:09] <daniel-s> but since it's my last friday, my boss hinted she might let me go earlier

[05:09] <daniel-s> i'll PM you when I'm home

[05:09] <sorear> Your last friday?

[05:09] * sorear had planned to sleep in 2h... but there are other #perl6ers

[05:10] <daniel-s> yea, my contract finishes on 30th of June

[05:19] <sorear> TimToady: do you remember how fudge works?

[05:19] <benabik> Fudge works in a tasty way.

[05:20] <TimToady> sorear: vaguely

[05:20] <sorear> I don't really follow the $PENDING and block logic

[05:21] <sorear> it bears a certain superficial similarity to gimme5.  perhaps if I had ever bothered to study that this would make more sense :)

[05:22] <sorear> I was hoping maybe I could have the globals explained to me...

[05:24] <TimToady> $PENDING lets you say how many tests the # directive covers; a block is counted as one test for that purpose

[05:25] * sorear wants to add #?if #?elsif #?endif to fudger

[05:25] <sorear> mainly because of the module tests, which do BEGIN { @*INC.push(...) }

[05:25] *** birdwindupbird joined
[05:26] <sorear> I can have "use lib" working in niecza within an hour probably, but BEGIN and @*INC will take a lot longer

[05:27] *** woosley joined
[05:28] <pmichaud> just put them in a block and #?niecza skip it ?

[05:28] <pmichaud> or am I misremembering how that works?

[05:29] <pmichaud> (probably.)

[05:29] <sorear> maybe it would work together with #?DOES 0

[05:29] <sorear> and I'd have to skip the use lib for all other implementations

[05:30] <pmichaud> you could do #?niecza emit  for the use lib lines

[05:32] <sorear> #?niecza emit screws up line numbers

[05:33] <TimToady> how so?  wouldn't it just replace the #? line?

[05:34] *** bakedb joined
[05:34] <TimToady> or s/would/should/

[05:34] <sorear> not quite

[05:35] <sorear> although, fixable

[05:35] <TimToady> the original design of fudge was that it never changed line numbers

[05:35] <sorear> #?niecza emit foo\n  becomes  foo

[05:35] <TimToady> we may have broken that

[05:36] <sorear> I wonder if I would break anything by fixing that

[05:36] <sorear> oh

[05:36] <sorear> yes, roast depends on the line gluing

[05:37] <sorear> S01-perl-5-integration/modify_inside_p5_p6.t lines 15 and 17 for instance

[05:37] <TimToady> maybe we could leave the comment there as well

[05:39] <TimToady> that would work in that case

[05:51] *** TOGoS joined
[05:55] *** TOGoS left
[06:06] <sorear> std: "foo" ~~ m/o{1,3}/

[06:06] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of {1,3} as general quantifier; in Perl 6 please use X**1..3 at /tmp/WuHMWHbxKy line 1:␤------> [32m"foo" ~~ m/o{1,3}[33m⏏[31m/[0m␤Check failed␤FAILED 00:01 121m␤»

[06:06] *** wamba joined
[06:07] <dalek> roast: 448f109 | sorear++ | S05-metasyntax/repeat.t:

[06:07] <dalek> roast: [S05-metasyntax/repeat] Fix syntax in an eval_dies_ok

[06:07] <dalek> roast: review: https://github.com/perl6/roast/commit/448f1099e0

[06:08] *** Su-Shee_ is now known as Su-Shee

[06:09] <pmichaud> .u infinity

[06:09] <phenny> U+221E INFINITY (∞)

[06:10] *** bakedb left
[06:11] *** Tedd1 left
[06:22] <sorear> pmichaud: is it just me, or is quantifier compilation actually really annoying?

[06:22] <pmichaud> it was annoying the first time I did it :)

[06:23] *** koban joined
[06:23] <sorear> I'm revisiting it to add a couple features, and the explosion of combinations is hurting my head

[06:24] *** donri joined
[06:24] <daniel-s> .u a hat

[06:24] <phenny> daniel-s: Sorry, no results for 'a hat'.

[06:25] <daniel-s> .u a

[06:25] <phenny> U+0061 LATIN SMALL LETTER A (a)

[06:25] <benabik> .u â

[06:25] <phenny> U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX (â)

[06:25] <daniel-s> .u a with circumflex

[06:25] <phenny> U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX (â)

[06:25] <benabik> Did I guess the right one?

[06:25] <daniel-s> yep

[06:26] <benabik> I knew how to type it, but not what it was called.  :-D

[06:26] * pmichaud was looking for an actual head covering.

[06:26] <benabik> .u hat

[06:26] <phenny> U+A271 YI SYLLABLE HAT (ꉱ)

[06:26] <benabik> Ah, well.

[06:26] <daniel-s> .u circumflex

[06:26] <phenny> U+005E CIRCUMFLEX ACCENT (^)

[06:34] <sorear> heh, C# thinks (int) double.PositiveInfinity is -2147483648

[06:34] <sorear> NOT POLS

[06:37] <pmichaud> bedtime here... may not be around much on fri due to all-day-travel

[06:38] <dalek> rakudo/nom: ead83d4 | pmichaud++ | src/core/Parcel.pm:

[06:38] <dalek> rakudo/nom: Let Parcels participate in postcircumfix:<[ ]>.

[06:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ead83d45cc

[06:38] <dalek> rakudo/nom: eed7142 | pmichaud++ | src/core/List (2 files):

[06:38] <dalek> rakudo/nom: ListIter should not discard its infinite sublists when it doesn't

[06:38] <dalek> rakudo/nom: want to deal with them yet.

[06:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eed7142a73

[06:43] *** wamba left
[06:50] *** Tedd1 joined
[06:58] *** ttxyr joined
[07:02] <dalek> niecza: fa199e9 | sorear++ | / (3 files):

[07:02] <dalek> niecza: Implement x ** {3} syntax

[07:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/fa199e9d6b

[07:03] *** mj41 joined
[07:11] <dalek> niecza: 9c59f52 | sorear++ | / (2 files):

[07:11] <dalek> niecza: Implement "spaces bordering **" rule

[07:11] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9c59f52762

[07:13] <sorear> +1 spectest

[07:13] <sorear> (well, +22, +1 file)

[07:16] * sorear sleep

[07:24] *** daxim joined
[07:33] *** hanekomu joined
[07:45] *** mj41 left
[07:46] *** thou left
[07:50] *** bakedb joined
[07:59] *** jferrero joined
[08:05] <ttxyr> sleep

[08:06] *** daniel-s left
[08:08] *** woosley left
[08:10] *** Pathin joined
[08:26] *** molaf joined
[08:28] <mathw> Dear C++, please let me declare two variables of different types in the initialisation part of my for loop. Pretty please!

[08:29] *** molaf left
[08:34] *** ttxyr left
[08:35] *** Mowah joined
[08:41] *** cbk left
[08:44] <jdhore1> Dear mathw, No. Love C++.

[08:44] *** wamba joined
[08:44] *** satyavvd left
[08:45] *** icwiener joined
[08:50] <mathw> bah

[08:50] * mathw goes looking for a job as a Lisp programmer

[08:50] <jdhore1> Have any of y'all ever taken a look at the Pike programming language, out of curiousity?

[08:50] <mathw> I've heard of it, but that's about it

[08:51] <moritz> same here

[08:51] *** satyavvd joined
[08:52] <jdhore1> It feels to me like if it wasn't so damn obscure, it's like the perfect cross between C and Perl IMO

[08:53] <mathw> I just read the Wikipedia entry

[08:53] <mathw> it looks quite interesting

[08:53] <tadzik> yeah, it looks like Haskell of systems programming :)

[08:53] <mathw> nonsense, Haskell is the Haskell of systems programming

[08:53] <tadzik> pardon

[08:54] * moritz likes the composite types

[08:54] <moritz> int|float number;

[08:54] *** cbk joined
[08:54] <mathw> yeah

[08:54] <tadzik> it's number int|float;, no?

[08:55] * mathw waves his magic code-manipulation wand and eliminates 14 warnings by changing one line.

[08:55] <mathw> sometimes this 'make it compile cleanly' business is very satisfying...

[08:55] <mathw> although then I stop to thinka bout it and get cross that somebody used an int instead of a size_t

[08:58] *** Transformer joined
[09:01] *** Transformer left
[09:03] *** cbk left
[09:03] *** daniel-s joined
[09:03] *** cbk joined
[09:03] *** slavik left
[09:04] <daniel-s> ahh, home :)

[09:19] *** cbk left
[09:24] *** awoodland joined
[09:26] *** mj41 joined
[10:08] *** jerome_ joined
[10:08] *** jerome_ left
[10:20] *** wamba left
[10:22] *** [particle] left
[10:27] *** MayDaniel joined
[10:30] *** REPLeffect left
[10:31] *** MayDaniel left
[10:33] *** REPLeffect joined
[10:48] *** pernatiy joined
[10:49] *** [particle] joined
[10:55] *** HarryS joined
[11:01] *** mj41 left
[11:05] <jnthn> ohai :)

[11:08] *** Teedev joined
[11:10] *** hanekomu left
[11:15] <moritz> \o

[11:18] *** daniel-s left
[11:24] *** ab5tract joined
[11:31] *** satyavvd left
[11:33] *** Grrrr left
[11:37] *** Grrrr joined
[11:38] *** Teedev left
[11:44] *** awoodland left
[11:48] *** JimmyZ joined
[11:51] *** Teedev joined
[11:57] *** Mowah left
[11:58] *** lichtkind joined
[12:00] <lichtkind> moritz: what perl 6 topic you want to talk about in GPW?

[12:01] <moritz> lichtkind: I probably won't attend any perl-related conferences/workshops this year

[12:02] <lichtkind> moritz: allright because i want to speak about lists in perl 6 ans wanted be shure there is no overlap

[12:02] <moritz> lichtkind: does that mean you understand lists?

[12:02] <lichtkind> i hope so

[12:03] <moritz> lichtkind: then you're a step ahead of me

[12:04] <lichtkind> moritz: whats so difficult on lazy lists?

[12:04] <moritz> to know when/if they flatten, when/if they reify or stay lazy, how they deal with infinity

[12:05] <moritz> just to name the three most obvious problems

[12:05] <lichtkind> moritz: you propably know more about that and yes there are some tricky cornercases

[12:06] <moritz> my @a = 1...10; # layz?

[12:06] <moritz> erm, lazy

[12:06] <lichtkind> i would think so

[12:06] <moritz> my @a = 1...*; # lazy? or loops?

[12:06] <moritz> and if those cases are lazy, what about

[12:07] <moritz> my @a = 1 ... 10; my @b = @a; push @a, 20; # does that affect @b?

[12:07] <lichtkind> it doesnt :)

[12:07] <moritz> why not?

[12:07] <lichtkind> because its a copy

[12:08] *** orafu left
[12:08] <lichtkind> not a reference to the same array

[12:08] <moritz> but if it's lazy, it must use the same generator internally, no?

[12:08] *** orafu joined
[12:08] *** fhelmberger left
[12:09] <lichtkind> only when bound or as long optimzation would aloow

[12:09] <lichtkind> allow

[12:11] <moritz> what about  my $x = 5; my @a = gather { take $x for ^5 }; $x = 6; my @b = @a; # what's in @b?

[12:13] <lichtkind> mom

[12:14] <moritz> perl6: my $x = 5; my @a = gather { take $x for ^5 }; $x = 'NEW'; say ~@a

[12:14] <p6eval> pugs, rakudo b2bc99, niecza v6-186-g9c59f52: OUTPUT«5 5 5 5 5␤»

[12:14] <moritz> perl6: my $x = 5; my @a := gather { take $x for ^5 }; $x = 'NEW'; say ~@a

[12:14] <p6eval> rakudo b2bc99, niecza v6-186-g9c59f52: OUTPUT«NEW NEW NEW NEW NEW␤»

[12:14] <p6eval> ..pugs: OUTPUT«5 5 5 5 5␤»

[12:15] <moritz> ah, the default pugs backend isn't lazy, it seems

[12:16] <lichtkind> why dont let me think for  a min

[12:16] <moritz> you can think however long you want :-)

[12:16] <lichtkind> i think rakudo is right

[12:16] <moritz> it gets more interesting if you put an infinite loop inside the gather

[12:18] <moritz> perl6: my $x = 5; my @a := gather { loop { take $x }  }; $x = 'NEW'; say ~@a[^5]

[12:18] <moritz> perl6: my $x = 5; my @a = gather { loop { take $x }  }; $x = 'NEW'; say ~@a[^5]

[12:18] <p6eval> pugs: OUTPUT«(timeout)»

[12:18] <p6eval> ..rakudo b2bc99: OUTPUT«NEW NEW NEW NEW NEW␤»

[12:18] <p6eval> ..niecza v6-186-g9c59f52: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Confused at /tmp/Zrk2lABym2 line 1:␤------> [32m = 5; my @a := gather { loop { take $x }[33m⏏[31m  }; $x = 'NEW'; say ~@a[^5][0m␤␤Parse failed␤␤»

[12:18] <p6eval> pugs, rakudo b2bc99: OUTPUT«(timeout)»

[12:18] <p6eval> ..niecza v6-186-g9c59f52: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Confused at /tmp/nZeh4KVVHk line 1:␤------> [32mx = 5; my @a = gather { loop { take $x }[33m⏏[31m  }; $x = 'NEW'; say ~@a[^5][0m␤␤Parse failed␤␤»

[12:19] <moritz> std: my $x = 5; my @a = gather { loop { take $x }  }; $x = 'NEW'; say ~@a[^5]

[12:19] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/MzMTG6VHYv line 1:␤------> [32mx = 5; my @a = gather { loop { take $x }[33m⏏[31m  }; $x = 'NEW'; say ~@a[^5][0m␤    expecting horizontal whitespace␤Parse failed␤FAILED 00:01 123m␤»

[12:19] <moritz> what's confusing there?

[12:19] * moritz confused at the confusion

[12:20] <lichtkind> they dont do it like spec demands it

[12:26] <jnthn> moritz: Confuses me also.

[12:26] <jnthn> moritz: STD bug maybe...odd one though.

[12:27] <moritz> std: my $x = 5; my @a = loop { take $x }; $x = 'NEW'; say ~@a[^5]

[12:27] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'loop' used at line 1␤Check failed␤FAILED 00:01 123m␤»

[12:27] <moritz> std: my $x = 5; my @a = gather loop ()  { take $x }; $x = 'NEW'; say ~@a[^5]

[12:27] <p6eval> std 37a0cdd: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed loop spec at /tmp/2TsfaMS8Dj line 1:␤------> [32mmy $x = 5; my @a = gather loop ([33m⏏[31m)  { take $x }; $x = 'NEW'; say ~@a[^5][0m␤    expecting term␤Parse failed␤FAILED 00:01 122m␤»

[12:28] *** wamba joined
[12:29] <moritz> STD.pm6 even uses loop {  } itself

[12:30] <moritz> std: loop { }

[12:30] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 117m␤»

[12:30] <moritz> std: loop { take my $x }

[12:30] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 120m␤»

[12:30] <moritz> std: gather loop { }

[12:30] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 118m␤»

[12:30] <moritz> std: my @a = gather loop { }

[12:30] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 122m␤»

[12:30] <moritz> std: my @a = gather loop { take my $x }

[12:30] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 122m␤»

[12:30] <moritz> std: my @a = gather loop { take my $x }; 1

[12:30] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 122m␤»

[12:31] <moritz> all the simpler variants of the same thing seem to work

[12:33] *** Teedev left
[12:37] *** bluescreen10 joined
[12:44] *** molaf joined
[12:47] *** Holy_Cow joined
[12:47] *** Holy_Cow left
[12:50] *** Mowah joined
[12:55] *** kanishka joined
[12:56] *** karupanerura joined
[12:57] *** skangas left
[12:57] *** Chillance joined
[12:59] *** mtk left
[13:03] * PerlJam wonders why people still feel the need to express their opinion that "Perl 6 is a bad name"

[13:04] *** wamba left
[13:05] *** mtk joined
[13:14] <lichtkind> camelia is much worse name

[13:14] <lichtkind> its something here  have woman between their legs :)

[13:15] <moritz> (there's a German sanitary towel which is called "Camelia")

[13:15] <jnthn> oh...lichtkind made me think it was worse than that :)

[13:16] <moritz> ... which is why I tried to explain :-)

[13:16] <jnthn> :)

[13:22] *** kanishka left
[13:23] <pmichaud> good morning, #perl6

[13:23] *** wamba joined
[13:23] <pmichaud> (on the road)

[13:25] <lichtkind> pmichaud: moinsen

[13:27] <PerlJam> pmichaud: good morning  (and watch out for traffic! :)

[13:29] <pmichaud> it's probably better if I don't watch.  :)

[13:30] <moritz> depends on who does the driving :-)

[13:30] *** Mowah left
[13:31] <jnthn> o/ pmichaud 

[13:31] <moritz> pmichaud: 10 of the files in src/core/ already have ACCEPTS methods - should I remove adding ACCEPTS methods from LHF.markdown?

[13:32] <pmichaud> moritz:  sure thing

[13:33] *** estrabd joined
[13:34] <jnthn> pmichaud: Have we any Nil support?

[13:34] <moritz> nom: fail(3)

[13:34] <p6eval> nom: OUTPUT«3␤current instr.: 'fail' pc 186280 (src/gen/CORE.setting.pir:0) (:124)␤»

[13:35] <jnthn> pmichaud: Or, what is Nil?

[13:35] <moritz> nom: say "foo\n".chomp

[13:35] <p6eval> nom: OUTPUT«Method 'chomp' not found for invocant of class 'Str'␤current instr.: '_block1002' pc 78 ((file unknown):101) (:1)␤»

[13:35] <pmichaud> nom:  say (1, 2, Nil, 3, 4, Nil, Nil, <eggs and>, Nil)

[13:35] <p6eval> nom: OUTPUT«12Nil34NilNileggsandNil␤»

[13:35] <moritz> nom: say "foo\n".substr(-1)

[13:35] <p6eval> nom: OUTPUT«␤␤»

[13:35] <pmichaud> oops

[13:35] <jnthn> nom: Nil

[13:35] <p6eval> nom:  ( no output )

[13:35] <pmichaud> nom:  say Nil ~~ Iterable

[13:36] <p6eval> nom: OUTPUT«Bool::True␤»

[13:36] <pmichaud> hmmmmmm

[13:36] <pmichaud> oh, I know what's wrong

[13:36] <pmichaud> anyway, we have Nil defined, yes.

[13:36] <jnthn> pmichaud: OK...I worked out what's going on

[13:36] <pmichaud> (it's currently an Iterator)

[13:37] <jnthn> We were getting away with looking up lexicals that weren't declared before.

[13:37] <jnthn> I twiddled Perl 6's lexpad to complain loudly about that...maybe I shouldn't do that :)

[13:37] <dalek> rakudo/nom: b03bf28 | moritz++ | LHF.markdown:

[13:37] <dalek> rakudo/nom: ACCEPTS is not a LHF anymore

[13:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b03bf28fd5

[13:38] <pmichaud> maybe it should complain not loudly :)

[13:38] *** grandmoun joined
[13:38] <grandmoun> Hi guys! 

[13:38] <pmichaud> btw, I may lose my connection at any time :)

[13:39] <moritz> hello grandmoun 

[13:39] <grandmoun> I'm a bit confused! I'm searching for a way to parse google result using perl

[13:39] <grandmoun> hi moritz!

[13:39] *** pernatiy left
[13:39] <jnthn> pmichaud: Initial patches for natively typed leixcals not far off. :)

[13:40] <pmichaud> jnthn: coool

[13:40] *** pernatiy joined
[13:40] <moritz> that would make some parts of the setting much faster, I hope

[13:40] <grandmoun> I found those perl module HTML::TreeBuilder and HTML::TreeBuilder::Xpath

[13:40] <jnthn> moritz: hm, maybe :)

[13:41] <PerlJam> grandmoun: first, a sanity check.  when you say "using perl" do you mean Perl 5 or Perl 6 ?

[13:41] <jnthn> moritz: Maybe a smaller win until we get handling of them in more places, and big win will be when we can inline ops.

[13:41] <moritz> jnthn: hm right, the ops still (un)box all over the place

[13:41] <grandmoun> perl 5.8 for the moment

[13:41] <pmichaud> ...we can get a win from nested blocks, perhaps?

[13:42] <moritz> grandmoun: then this is not the right channel for you

[13:42] <PerlJam> grandmoun: then you probably want #perl or #perlhelp

[13:42] <grandmoun> ok!

[13:42] <grandmoun> thanks

[13:42] <PerlJam> grandmoun: good luck!

[13:44] * moritz wonder why people join #perl6 when they want to talk about Perl 5 problems

[13:44] <jnthn> pmichaud: Perhaps so. If we use nqp::add_i and such with them, it'll be a nice win.

[13:45] *** grandmoun left
[13:45] <moritz> do they just think this is the 6th perl channel?

[13:45] <jnthn> moritz: Becasue they don't know that Perl 6 is sufficiently different from Perl 5 to think it'd matter, perhaps.

[13:46] <pmichaud> jnthn: yes.  we might be able to inline the register cases fairly quickly -- not as much analysis required there (and the type of the variable is explicitly declared)

[13:46] <jnthn> pmichaud: Well, it's kinda the same amount of analysis in a sense - but we do have the type info, yes :)

[13:47] <PerlJam> moritz: perhaps they search for "perl", get a list of channels, then randomly choose one because they have no way to distinguish the relative merits of each.

[13:47] *** jaldhar left
[13:48] *** ab5tract left
[13:48] *** pernatiy left
[13:51] <moritz> PerlJam: sounds plausible

[13:52] <moritz> nom: my Str $x = 4;

[13:52] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[13:52] <moritz> sorear++ I assume :-)

[13:55] *** pernatiy joined
[13:56] * JimmyZ just saw a website: rakurakupress.com, which looks like rakudo.org

[13:58] *** frew joined
[13:58] *** cogno joined
[13:59] <jnthn> nom: my Str $x = 4;

[13:59] <p6eval> nom: OUTPUT«Type check failed in assignment to '$x'; expected 'Str' but got 'Int'␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[13:59] <jnthn> nom: my str $x = 4;

[14:00] <p6eval> nom: OUTPUT«Type check failed in assignment to '$x'; expected 'str' but got 'Int'␤current instr.: '_block1002' pc 28 ((file unknown):0) (:1)␤»

[14:00] <jnthn> heh :)

[14:01] <moritz> nqp: say(pir::open('nonexistent').error)

[14:01] <p6eval> nqp: OUTPUT«error:imcc:The opcode 'open_p' (open<1>) was not found. Check the type and number of the arguments␤ in file '(file unknown)' line 34␤»

[14:01] <moritz> nqp: say(pir::open__ps('nonexistent').error)

[14:01] <p6eval> nqp: OUTPUT«Unable to open filehandle from path 'nonexistent'␤current instr.: '_block1000' pc 0 ((file unknown):1)␤»

[14:01] <moritz> nqp: say(pir::open__ps('nonexistent'))

[14:01] <p6eval> nqp: OUTPUT«Unable to open filehandle from path 'nonexistent'␤current instr.: '_block1000' pc 0 ((file unknown):1)␤»

[14:02] <moritz> nqp: try { say(pir::open__ps('nonexistent')) }

[14:02] <p6eval> nqp:  ( no output )

[14:02] <moritz> nqp: try { say(pir::open__ps('nonexistent')); say "Error: $!" }

[14:02] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3863 (src/Regex/Cursor.pir:239)␤»

[14:03] <pmichaud> does try { } work in nqp eyt?

[14:03] <pmichaud> *yet?

[14:03] <jnthn> Think so

[14:03] <jnthn> But that say needs parens.

[14:03] <pmichaud> oh, nqp

[14:03] <pmichaud> I was thinking "nom"

[14:03] <pmichaud> ETOOSIMILAR

[14:03] <jnthn> ah, no idea :)

[14:03] <moritz> nqp: try { say(pir::open__ps('nonexistent')); say("Error: $!") }

[14:03] <p6eval> nqp: OUTPUT«Symbol '$!' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[14:03] <jnthn> Similar? Only one letter in common :P

[14:03] *** molaf left
[14:04] <moritz> nqp: try { say(pir::open__ps('nonexistent')); say("Error: $_") }

[14:04] <p6eval> nqp: OUTPUT«Symbol '$_' not predeclared in <anonymous>␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[14:04] <moritz> nqp: try { say(pir::open__ps('nonexistent')); CATCH { say("Error: $_") } }

[14:04] <p6eval> nqp: OUTPUT«Error: Unable to open filehandle from path 'nonexistent'␤»

[14:04] <pmichaud> they're all ascii characters.  both a 3 letters long.  I can find plenty of similarities :)

[14:04] <moritz> \o/

[14:04] <jnthn> Try saying "om nqp nqp" out loud. :P

[14:04] <moritz> nom: try { die "foo"; CATCH { say $! } }

[14:04] <p6eval> nom: OUTPUT«Method 'blocktype' not found for invocant of class 'PAST;Op'␤current instr.: 'nqp;Perl6;Actions;push_block_handler' pc 22073 (src/gen/perl6-actions.pir:7210)␤»

[14:08] <pmichaud> nom:  say "om nqp nqp" <out loud>;

[14:08] <p6eval> nom: OUTPUT«Confused at line 1, near "say \"om nq"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23569 (src/stage2/gen/NQPHLL.pir:6311)␤»

[14:09] <jnthn> :P

[14:10] * jnthn tries to add lexical_6model to go with our attribute_6model scope in PAST::Var.

[14:10] <pmichaud> yes, redeveloping past into nqp is moving higher on my priority list :)

[14:10] *** mantovani left
[14:11] <moritz> JimmyZ: fwiw I see no similarity to rakudo.org at all

[14:12] <jnthn> pmichaud: Yes, then I can write an optimizer... :)

[14:13] *** spq1 joined
[14:14] *** cogno left
[14:16] *** pernatiy left
[14:16] *** cogno joined
[14:16] <JimmyZ> moritz: the site is called 楽楽钥匙,  which is a bit similar with 楽土,

[14:18] *** wamba left
[14:19] *** pernatiy joined
[14:23] <TimToady> that's a strange mix of japanese and chinese characters...

[14:24] * JimmyZ saw it today morning, from a journal

[14:25] <TimToady> 楽 is 樂 or 乐 in chinese, normally

[14:25] <JimmyZ> yes

[14:25] <TimToady> and 钥匙 is simplified

[14:25] <TimToady> well, the first one

[14:27] <JimmyZ> I don't know why, that journal is written in japanese

[14:27] <TimToady> the japanese like to think that all chinese characters are part of japanese too :)

[14:27] <TimToady> even if they only use 2000 or so of them for most things

[14:29] <JimmyZ> I guess that journal was written by chinese people, who may be not good enogh at japanese 

[14:29] *** PacoLinux left
[14:29] <TimToady> I can see why that notion is attractive; I've been having enormous fun going through the Unicode CJK extension B and classifying all the characters

[14:29] <JimmyZ> *enough

[14:29] *** cogno left
[14:29] *** PacoLinux joined
[14:30] <JimmyZ> and Korean?

[14:30] <TimToady> some of them are pretty easy to classify, like 𪚥

[14:30] <TimToady> don't do much korean yet

[14:30] <TimToady> just know a few phrases

[14:30] <TimToady> though I should learn the syllabary someday

[14:31] * jnthn looked at the syllabary a while ago and found it awesome :)

[14:31] <jnthn> Suspect I forget a most of it again by now though.

[14:31] <jnthn> s/a//

[14:31] <TimToady> it's pretty well designed, by the standards of "philosophical languages"

[14:32] <TimToady> otoh, sometimes you want a language in which similar things look different

[14:32] <JimmyZ> Korean is a good language, it learned advantage from chinese and japanese 

[14:33] <JimmyZ> yes, it's very pretty well designed

[14:34] <TimToady> an English syllabary would have to do something similar to account for all the consonant clusters

[14:34] <TimToady> you can get away with an arbitrary syllabary in Japanese only because it's a CV language

[14:34] <TimToady> as it is, syllable-final n is thought of as a separate syllable

[14:35] <TimToady> well, mora

[14:36] <TimToady> same for doubled vowels and consonants

[14:36] <TimToady> but the structure is easy enough to to a simple syllabary

[14:36] <TimToady> in English you'd have to account for words like strengths

[14:37] <pmichaud> losing network signal soon

[14:37] <pmichaud> bbl

[14:37] <TimToady> peddle hard

[14:37] *** masak joined
[14:37] <masak> oh hai from FPW

[14:38] <pmichaud> bonjour

[14:38] <masak> I have a mystery question.

[14:38] <masak> for the old-timers around here.

[14:38] <masak> what's "skip" and how did it work?

[14:38] * TimToady looks around for old-timers...

[14:38] <masak> specifically, how did it differ from "next"?

[14:38] <masak> it's documented as implemented in https://github.com/parrot/parrot/blob/RELEASE_0_3_1/languages/perl6/README

[14:39] <masak> I looked around in the source code, but can't find anything substantial besides the fact that it's being parsed.

[14:39] <jnthn> o/ masak 

[14:39] <masak> jnthn: \o

[14:39] <jnthn> masak: How's FPW?

[14:39] <masak> it's very French :)

[14:40] <TimToady> masak: I suspect it was what we now call "succeed"

[14:40] <jnthn> masak: Ой ля ля!

[14:40] <masak> I'm enjoying myself. but I can't get my brain to parse everything.

[14:40] <masak> TimToady: oh!

[14:40] <masak> TimToady: that congrues with it being used in a 'when' statement.

[14:40] <masak> so it was 'skip' -> 'break' -> 'succeed'?

[14:41] <TimToady> yeah, and p5 picked it up at the 'break' point

[14:41] *** mj41 joined
[14:41] <masak> :P

[14:41] <TimToady> alas

[14:41] <masak> well, they can't wait around forever for us to find the right word...

[14:41] <masak> Perl 5 needs to snapshot our progress on the way to our eventual goal.

[14:42] <masak> anyway, thanks for clearing up that mystery.

[14:44] <masak> other news: BooK gave a talk at a .nl PM meeting where he showed how to build Sierpinski triangles using git commits and their "parent" relation. he then said that it couldn't be done recursively.

[14:44] <masak> this morning when I saw him again, I sat down and figgered out how to do it recursively. :)

[14:44] <masak> now the only thing that remains is to implement it.

[14:45] *** koban left
[14:47] <TimToady> niecza: constant @foo = 1,@foo; say @foo[3]

[14:47] <p6eval> niecza v6-186-g9c59f52: OUTPUT«Any()␤»

[14:47] <TimToady> aw

[14:48] <masak> isn't that correct?

[14:48] <masak> I mean, wouldn't the assignment happen only once?

[14:48] <TimToady> it's not really assignment

[14:48] <TimToady> it's initialization

[14:48] <masak> it's not a binding, and there's no delayed evaluation.

[14:48] <TimToady> it is a binding, really...

[14:48] <masak> ok.

[14:49] <TimToady> most initializers are more like binding

[14:49] <masak> so the 'constant' imposes binding semantics?

[14:49] <masak> what about the delayed evaluation? I don't see any curly braces or whatevers...

[14:50] <TimToady> if it's binding, it's not eager

[14:50] <masak> does 'constant' impose a thunk on the RHS?

[14:50] <masak> ooh.

[14:50] <masak> right, so the binding semantics imposes (mostly?) lazy semantics on the RHS.

[14:51] <TimToady> niecza: constant @integers = 0..*;  say @integers[42]

[14:51] <p6eval> niecza v6-186-g9c59f52: OUTPUT«42␤»

[14:51] <TimToady> otoh, I think pseudoassignment = borrows flat from assignment

[14:52] <TimToady> flat and lazy, like a slime mold

[14:52] <masak> :P

[14:53] <TimToady> rakudo: my @foo; @foo.plan: 1, @foo; say @foo[3]

[14:53] <p6eval> rakudo b2bc99: OUTPUT«Method 'plan' not found for invocant of class 'Array'␤  in main program body at line 22:/tmp/lSS6Jex4NC␤»

[14:54] <TimToady> niecza: my @foo; @foo.plan: 1, @foo; say @foo[3]

[14:54] <p6eval> niecza v6-186-g9c59f52: OUTPUT«Any()␤»

[14:54] <TimToady> um...

[14:54] <TimToady> niecza: my @foo; @foo.plan: 1..5; say @foo[3]

[14:54] <p6eval> niecza v6-186-g9c59f52: OUTPUT«4␤»

[14:55] <TimToady> niecza: my @foo; @foo.plan: 1..5, @foo; say @foo[3]

[14:55] <p6eval> niecza v6-186-g9c59f52: OUTPUT«4␤»

[14:56] <TimToady> niecza: my @foo; @foo.plan: 1, |@foo; say @foo[3]

[14:56] <p6eval> niecza v6-186-g9c59f52: OUTPUT«Any()␤»

[14:56] <TimToady> looks like .plan is clobbering the identity of the array somehow

[14:56] <TimToady> or somethin'

[14:57] *** cogno joined
[14:57] *** daxim left
[14:59] *** mj41 left
[14:59] *** woosley joined
[15:00] <Util> TimToady++  # for http://rosettacode.org/wiki/Vigenère_cipher#Perl_6

[15:03] <TimToady> I just wish we had a .nfkd so I could use the accented name as the key...

[15:05] *** mkramer joined
[15:05] *** mkramer left
[15:06] <masak> sorry, .nfkd ?

[15:07] <TimToady> canonical decomposition

[15:07] <TimToady> er, compatible

[15:08] <TimToady> if .nfkd does that...

[15:08] *** ab5tract joined
[15:08] <TimToady> anyway, I can't think of a good way to look up the base char

[15:09] <masak> somewhere in Perl 6 that functionality has to exist.

[15:09] <masak> even if it's in a module or other.

[15:09] <moritz> maybe .normalize(Normalization::NKFD)

[15:09] * moritz doesn't want another 4 methods in Str or Cool

[15:10] <masak> no, indeed.

[15:10] *** cogno left
[15:10] <TimToady> well, it would be less of an issue if .^methods worked as specced

[15:10] <TimToady> at least for Cool

[15:10] <masak> @quietfanatic on Twitter asked the other day "How many primitives are too many, and how will you know when to stop?" or something in that vein.

[15:11] <moritz> TimToady: only less of an issue for introspection

[15:11] <TimToady> how many words are there in English?

[15:11] <masak> then he an @luqui got into a discussion about modularization.

[15:13] <TimToady> we are primarily designing a human language here, not an axiomatic system, despite the computer's sincere desire for such...

[15:13] <masak> fwiw, I personally can accept that the setting is quite big. having things like 'max' and 'lcm' in there is very good, I think.

[15:13] <masak> it not only helps when writing one-liners, but also to prevent redesigning of wheels, etc.

[15:13] <TimToady> if a concept is universal, it should have a universal-ish word, is one approach

[15:14] <TimToady> it's when 20 different concepts compete for the same slot that we get phpitis.

[15:14] <masak> or 20 different slots competing for variations of the same concept... :)

[15:14] <TimToady> when you can't express the universal concept generically enough, it causes a name explosion

[15:15] <TimToady> we'd certainly like to avoid that

[15:15] *** PhatEddy joined
[15:15] <TimToady> but uni-code is going to be pretty uni-versal

[15:16] <TimToady> so one should avoid knee-jerk reactions on both sides of the issue

[15:16] <masak> TimToady: did you read tchrist's recent StackOverflow rant? anything in there which applies to how we're doing things in Perl 6?

[15:17] <TimToady> doubtless, which I will consider when I'm revising that chapter of the Camel.  :)

[15:18] <masak> mathw's reaction was "Unicode is hard", which I guess was tchrist's intent.

[15:18] <TimToady> at the moment I'm stuck in the middle of chapter 4

[15:18] <masak> control structures?

[15:18] <TimToady> Unicode, like Perl 6, is trying to do something impossible, and largely succeeding.

[15:18] <masak> :P

[15:18] <TimToady> yes

[15:18] <mathw> yes but unicode is inevitably going to be hard

[15:18] <masak> hah, I know the chapters of the Camel thanks to Sxx.

[15:19] <masak> how backward.

[15:19] <masak> mathw: right. as will computing in general, up to accidental complexity.

[15:19] <mathw> right

[15:19] <TimToady> "For one so backward, you're far too forward." --TROTGTSOTC

[15:19] *** jimmy1980 left
[15:19] <mathw> but a single encoding system for every script on the planet... that's head-bending

[15:20] <huf> what's this crazy acronym?

[15:20] <huf> ah

[15:21] <PhatEddy> Since we seem to have a good crowd I would like to announce that I am getting close to preparing a new version of the Perl6 URI module from the github branch here https://github.com/ihrd/uri/tree/uri_iface_01a

[15:21] <huf> google found the channel logs

[15:21] <TimToady> .oO(a single computer language for every script on the planet... that's head-bendinger)

[15:21] <PhatEddy> I am interested in any feedback I can get before merging with master.

[15:22] <masak> wow, I could actually decipher that acronym. haven't seen the musical, tho'.

[15:22] <TimToady> I've played it (in the orchestra)

[15:22] *** mkramer joined
[15:22] <masak> TimToady: drums?

[15:22] *** mkramer left
[15:22] <TimToady> no, concertmaster

[15:22] <masak> ah; maestro.

[15:23] <TimToady> only when the director hands me the baton

[15:23] <TimToady> which never happened in that musical

[15:23] <masak> oh.

[15:23] <TimToady> I've conducted several others though

[15:24] <masak> in a way a task very analogous to your job here in the Perl 6 community :)

[15:24] <TimToady> Oklahoma, My Fair Lady for instance

[15:24] *** jimmy1980 joined
[15:24] *** slavik joined
[15:25] <PhatEddy> The new URI module version has a description of what's new here in the ChangeLog - https://github.com/ihrd/uri/blob/uri_iface_01a/ChangeLog

[15:25] *** kaare_ joined
[15:26] <TimToady> looks sane, but I'm not a URI expert...

[15:26] <masak> PhatEddy: nice.

[15:26] <masak> PhatEddy: what do you mean by "parsing constructor"?

[15:26] <masak> does it simply mean that all the computations are done at object creation?

[15:27] <TimToady> as an orchestra conductor I only know how to speak loudly and carry a small stick...

[15:27] <PhatEddy> masak: just my URI $x .= new('http://www.perl.com') as opposed to the old way where you would "new" and then "init"

[15:27] <masak> TimToady: I would laugh out loud, but I'm in BooK's audience... :)

[15:28] <masak> PhatEddy: ah. tres bien.

[15:29] <PhatEddy> Thanks to all for looking and if you have any suggestions I can be reached from github or (ocassionally) here ...

[15:29] <masak> #perl6 early, #perl6 often...

[15:31] <Su-Shee> ouch :)

[15:32] <masak> maybe I need to work on the precise wording of that.

[15:32] *** bakedb left
[15:35] *** karupas joined
[15:37] *** karupanerura left
[15:38] *** cognominal_ left
[15:42] *** pernatiy left
[15:45] *** noganex_ left
[15:48] *** cotto left
[15:52] *** bakedb joined
[15:54] *** Mowah joined
[15:55] <colomon> TimToady: You've conducted My Fair Lady?!

[15:56] <TimToady> the 2nd chair violist did not like the Hungarian Rhapsody solo sprung on her suddenly.  :)

[15:56] <TimToady> *violinist

[15:57] <TimToady> I guess I did No, No, Nanette too

[15:59] <colomon> I've played in the pit for about twenty shows, but certainly never conducted.\

[15:59] *** noganex joined
[16:00] <masak> oh crap. BooK just promised everyone that I will do a lightning talk to show off my yet-to-be-written mutually recursive Sierpinski-DAG-creating functions... :)

[16:01] <masak> I shouldn't have said anything to him.

[16:01] <TimToady> the first time I did the dream sequence in Oklahoma, I made the ballet dancers go too fast :)

[16:01] <slavik> lol

[16:01] *** skangas joined
[16:01] *** thou joined
[16:01] <masak> maybe someone in here would like to write the functions? I have to write a talk until tomorrow...

[16:01] * TimToady had better clean up brush before the sun gets too hot

[16:02] <masak> I can give specific instructions. I've already worked it out on paper.

[16:02] * masak prepares a gist

[16:07] <tadzik> colomon: played what?

[16:07] <tadzik> or: on what

[16:08] <colomon> tadzik: bassoon is my normal instrument, and I've also frequently been tasked with covering bari sax and (bass?) clarinet parts on it.  I've also played a little bit of keyboard, whistles, and misc trivial percussion instruments in the pit.

[16:10] *** buubot_backup left
[16:11] <tadzik> I got back to playing the piano for the last few days

[16:11] <tadzik> wondering if it will last, or will I stop again

[16:15] *** mkramer joined
[16:15] *** mkramer left
[16:17] <Util> masak: oh crap indeed. RosettaCode has lots of different solutions for Sierpinski triangle and Sierpinski carpet, if you need inspiration.

[16:17] *** karupas left
[16:18] * Util is still writing talk for YAPC::NA Monday :(

[16:19] <masak> Util: is any of them recursive and DAG-based?

[16:20] * colomon hasn't even started writing his talk for YAPC::NA Wednesday.

[16:20] *** zby_home_ joined
[16:21] <Util> masak: recursive: http://rosettacode.org/wiki/Sierpinski_triangle#BASIC

[16:22] *** wolfman2000 left
[16:23] <masak> here are my loose thoughts on the subject: https://gist.github.com/1045125

[16:23] * masak looks at Util's link

[16:23] <masak> Util: yes, but no :)

[16:23] <masak> Util: BooK is using Git, so the basic assumption is that we're using DAGs. :)

[16:24] <tadzik> better dags than kgs

[16:24] <masak> doing it recursively with coordinates is arguably a simpler problem.

[16:24] * Util looks at masak's Gist

[16:25] <masak> the interesting thing with the DAG problem is that the subtriangles have nontrivial interdependencies.

[16:26] <masak> oh, and I should be clear: if you help me solve this before tomorrow afternoon, you'll most likely be in a lightning talk at FPW. :)

[16:27] <masak> the gist contains all I know about the solution, and I think it completely outlines an actual implementation.

[16:27] <masak> optional parameters in Perl 6 come in handy with all the nodes needing to be passed around.

[16:27] <Util> Would it be simpler to rotate the diagram/conceptual-model 90deg counter-clockwise?

[16:28] <Util> Reminder: Merges have two parents.

[16:28] * Util might have no idea what he is taking about :(

[16:29] <masak> Util: in my pictures, parents point upwards. so we might be meaning the same thing.

[16:29] <masak> sometimes Git commit diagrams are drawn top-down, sometimes left-to-right.

[16:29] *** buubot_backup joined
[16:29] *** kaare_ left
[16:29] <masak> buubot_backup: eval say "hooray!"

[16:29] <buubot_backup> masak: ERROR: syntax error at (eval 28) line 1, near "say "hooray!"" 

[16:29] <Util> I wish I had more time; The coding group at Atlanta.pm has been hacking on Tree::DAG_Node module for over a year

[16:29] *** ab5tract left
[16:30] <moritz> buubot_backup: eval: use 5.010; say 'hooray';

[16:30] <buubot_backup> moritz: hooray 1

[16:30] <Util> so I am rather steeped in DAGs by now.

[16:30] <masak> moritz++

[16:30] <moritz> buubot_backup: eval: use 5.010; say 'hooray ';

[16:30] <buubot_backup> moritz: hooray  1

[16:30] <moritz> buubot_backup: eval: use 5.010; print 'hooray';

[16:30] <buubot_backup> moritz: hooray1

[16:30] <masak> Util: the Node class in this case can be simple: it just needs to do .new(:@parents)

[16:30] <moritz> buubot_backup: eval: use 5.010; print 'hooray ';

[16:30] <buubot_backup> moritz: hooray 1

[16:33] <masak> buubot_backup: eval: use 5.010; print "I will always end my utterances with the number ";

[16:33] <buubot_backup> masak: I will always end my utterances with the number 1

[16:34] <masak> buubot_backup: eval: use 5.010; say "for me, you are the only "

[16:34] <buubot_backup> masak: for me, you are the only  1

[16:34] <masak> awww

[16:36] <dalek> nqp: abb69d9 | jonathan++ | / (3 files):

[16:36] <dalek> nqp: Bump to latest Parrot version to get natively typed lexical support and update NQPLexInfo/NQPLexPad to cope with that.

[16:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/abb69d9359

[16:36] <dalek> nqp: 97315f3 | jonathan++ | src/PAST/SixModelPASTExtensions.pir:

[16:36] <dalek> nqp: Add lexical_6model scope that knows how to look at the type and pick the correct register type when fetching/storing lexicals.

[16:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/97315f3266

[16:36] <masak> natively typed lexicals! \o/

[16:36] <tadzik> o-ho

[16:36] <masak> World Domination grows ever closer.

[16:37] <jnthn> Calm down, there's still plenty of work to do yet before they're useful :P

[16:38] <masak> I'm sorely tempted to attack the Sierpinski problem myself, mind. but I need to dedicate tuits towards getting my talk done for tomorrow.

[16:39] <jnthn> Sleep is overrated ;)

[16:39] <masak> point.

[16:39] <colomon> really, it's not overrated.  in the least.

[16:39] <jnthn> hehe :)

[16:39] * jnthn spent this morning catching up on sleep lost over the past week and a half :)

[16:40] <masak> time to disappear. see y'all later.

[16:40] * colomon is catching a 6:30 AM flight to YAPC::NA, mind you, so he's apparently not practicing what he preaches.

[16:40] *** masak left
[16:40] *** sivoais left
[16:40] <jnthn> colomon: ugh, early

[16:42] <dalek> rakudo/nom: b697a48 | jnthn++ | src/pmc/perl6lexpad.pmc:

[16:42] <dalek> rakudo/nom: Update Perl6LexPad to know about natively typed lexicals. Note, this doesn't mean they work yet, just that the underlying storage support is updated.

[16:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b697a488c8

[16:42] <dalek> rakudo/nom: fd11858 | jnthn++ | tools/build/NQP_REVISION:

[16:42] <dalek> rakudo/nom: Bump NQP revision to get bits needed for native lexicals support.

[16:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd11858585

[16:43] <colomon> jnthn: I've at least gotten a hotel near the airport, so I only have to get up silly-early rather than insanely early.

[16:44] <jnthn> colomon: Oh, that's not so bad.

[16:44] * jnthn needs to remember to book travel to YAPC.

[16:44] <tadzik> oh, thanks

[16:45] <tadzik> a travel and a hotel

[16:45] <jnthn> Ah, the hotel bit I did :)

[16:45] <colomon> jnthn: yeah, I only very briefly considered waking up at 2:30 am to drive to the airport.   ;)

[16:45] <tadzik> jnthn: any hints?

[16:45] <jnthn> Waking up at 2:30am sounds so odd. That's the time I often go to sleep :P

[16:45] <tadzik> I wouldn't go to sleep then :)

[16:46] <jnthn> tadzik: Some of us are staying at http://www.booking.com/hotel/lv/konventasetariga.html

[16:47] <tadzik> Free! Wi-fi is available in the entire hotel and is free of charge

[16:47] <tadzik> like

[16:47] <colomon> but does it actually work?  I've had lots of bad experiences with hotel wi-fi (free or not)...

[16:48] <tadzik> I guess I'll go for 13-17

[16:53] <jnthn> colomon: It depends on the hotel, and also on the country and what laws they have.

[16:54] <colomon> also on how many geeks are using their laptops at once.

[16:55] <jnthn> colomon: I've seen all sorts. Open wifi network, places where it's free and reception gives you access tokens, places where they carefully make a copy of your passport when giving you the tokens for wifi access so they know who did what...

[16:55] <jnthn> (not because the hotel cares, but because that's the law in some silly countries)

[16:58] <tadzik> "Pets are allowed on request. No extra charges". Funny, I thought about zebras...

[16:58] <jnthn> I'm...er...not sure they'd consider that a pet :)

[17:00] *** woosley left
[17:01] *** cotto joined
[17:01] *** cdarroch joined
[17:01] *** cdarroch left
[17:01] *** cdarroch joined
[17:03] *** birdwindupbird left
[17:05] <PerlJam> pmichaud: ping

[17:05] <TimToady> nom:  say (1, 2, Nil, 3, 4, Nil, Nil, <eggs and>, Nil).gist

[17:05] <p6eval> nom: OUTPUT«1 2 Nil 3 4 Nil Nil eggs and Nil␤»

[17:06] <TimToady> nom:  say (1, 2, Nil, 3, 4, Nil, Nil, <eggs and>, Nil)

[17:06] <p6eval> nom: OUTPUT«12Nil34NilNileggsandNil␤»

[17:06] * TimToady wonders why that arg to say isn't .gisting

[17:06] <jnthn> nom: Nil.gist.say

[17:06] <p6eval> nom: OUTPUT«Nil␤»

[17:07] <PerlJam> pmichaud: a minor thing ... your document on "relationship mangagers" still has <person1> and <person2> further down in the text from where you added your and moritz's names

[17:08] *** JimmyZ_ joined
[17:08] <TimToady> pm is in travel mode

[17:09] *** bakedb left
[17:10] *** JimmyZ left
[17:10] *** JimmyZ_ is now known as JimmyZ

[17:12] <PerlJam> he'll back log at some point

[17:13] *** kanishka joined
[17:17] *** cotto left
[17:18] <sorear> good * #perl6

[17:18] <slavik> sorear: likewise

[17:19] <dalek> rakudo/nom: 90aa408 | jnthn++ | src/Perl6/ (3 files):

[17:19] <dalek> rakudo/nom: Start to more properly support natively typed lexicals, including assignment to them. This also fixes assignment to natively typed attributes. An assignment from a natively typed attribute to a natively typed lexical, or an assignment with int and num literals on the RHS, never boxes along the way and always works in terms of natives. Boxing is done in many situations as needed, including calls (so you don't tend to want to use natives yet unless 

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90aa408c91

[17:21] *** hanekomu joined
[17:21] <jnthn> pmichaud: (for when you backog) See 90aa408. Note that for now if you want to use these and do ops, I advise using nqp::add_i and so forth. We need to build the inliner before we get infix:<+> really working there.

[17:21] <jnthn> pmichaud: It works now but boxes on demand, which is a bunch of waste.

[17:22] <sorear> moritz: what is confusing is the } }

[17:22] <jnthn> pmichaud: BTW, PAST::Want is a wonderful thing. pmichaud++

[17:23] <jnthn> o/ sorear 

[17:29] *** cotto joined
[17:34] *** PhatEddy left
[17:36] *** awoodland joined
[17:43] *** mj41 joined
[17:43] *** wamba joined
[17:53] <felher> std: my @array = 1,2,3,4; sub change(@array) { @array.pop(); } ; change(@array);

[17:53] <p6eval> std 37a0cdd: OUTPUT«ok 00:01 124m␤»

[17:55] <felher> Hm... How is that 'ok'? Aren't containers also immutable by default according to S06?

[17:58] <sorear> felher: STD is just a parser

[17:59] *** mkramer1 joined
[18:00] *** mkramer1 left
[18:02] <felher> sorear: Ah, okay. And niecza, rakudo and pugs just don't implement immutable containers at the moment?

[18:03] <jnthn> felher: If all the implementations agree, it may also be that your expectations are wrong. :)

[18:04] <sorear> felher: we consider S06 dubious there; passing arrays needs to be cheap and it's not at all obvious how to cheaply make an array readonly

[18:05] *** mantovani joined
[18:05] <flussence> can't you just swap out all the mutator methods for "{ !!! }" bits?

[18:05] <felher> jnthn: Yeah, sure, and most of the time they indeed are :) But i thought sorear implied my expectations to be correct :)

[18:05] *** mantovani left
[18:05] <felher> sorear: Ah, okay, thnx.

[18:11] <TimToady> http://rosettacode.org/wiki/First-class_functions/Use_numbers_analogously#Perl_6

[18:16] *** JimmyZ left
[18:16] *** mkramer joined
[18:16] *** mkramer left
[18:18] <TimToady> rakudo: say *.sin === &sin

[18:18] <p6eval> rakudo b2bc99: OUTPUT«_block1092␤»

[18:18] <TimToady> o_O

[18:18] <colomon> ha!

[18:19] <TimToady> how do I do that?

[18:19] <TimToady> rakudo: say [===] *.sin, &sin

[18:19] <p6eval> rakudo b2bc99: OUTPUT«Bool::False␤»

[18:19] <sorear> rakudo: say &infix:<===>(*.sin, &sin)

[18:19] <p6eval> rakudo b2bc99: OUTPUT«Bool::False␤»

[18:19] <TimToady> seems like that could be optimized

[18:20] <TimToady> well, maybe not so easily

[18:21] <colomon> &sin / *.sin could be optimized, you mean?

[18:21] <TimToady> with enough knowledge, yeah

[18:21] <colomon> sure, with enough knowledge and power.  :)

[18:21] <sorear> problem 1: WhateverCode adds an additional binder, which changes the semantics by disallowing extra arguments (you can't pass :base() to the WhateverCode)

[18:21] <TimToady> in the typical program they'd be identical

[18:22] <TimToady> hmm

[18:22] <sorear> problem 2: &sin is statically bound to the current $?TRIGBASE setting, while *.sin uses CALLER::<$?TRIGBASE>

[18:22] <TimToady> well, maybe the mythical method inliner will save the day

[18:22] <jnthn> TimToady: I think === is turning into a curried block there.

[18:23] <TimToady> yes, we figgered

[18:23] <colomon> jnthn: right.

[18:23] <jnthn> (because the LHS is a WhateverCode)

[18:23] <sorear> problem 3: What if somebody defines a sin method that doesn't behave the same as the sin multi?

[18:23] <jnthn> Dunno if it belongs on the exclusion list or not ;)

[18:23] <TimToady> that's the "enough knowledge" part

[18:24] <TimToady> perl6: say [===] (sin *), &sin

[18:24] <p6eval> niecza v6-186-g9c59f52: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'sin' used at line 1,1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 469 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1133 (STD P6.comp_unit @ 30) ␤…

[18:24] <p6eval> ..rakudo b2bc99: OUTPUT«Method 'sin' not found for invocant of class 'Whatever'␤  in 'sin' at line 2137:src/gen/core.pm␤  in main program body at line 22:/tmp/F3w5803Mgq␤»

[18:24] <p6eval> ..pugs: OUTPUT«␤»

[18:25] <colomon> :\

[18:25] <colomon> oh, I see

[18:25] <TimToady> the Q is whether prefix:<sin> is considered a unary operator

[18:26] <TimToady> I guess it's not

[18:26] *** snarkyboojum left
[18:27] <sorear> there are only a handful of unary operators in Rakudo and STD

[18:27] <colomon> rakudo: say [===] (abs *), &abs

[18:27] <p6eval> rakudo b2bc99: OUTPUT«Bool::False␤»

[18:28] <sorear> I think this is a bug; I wonder if it would cause problems if I went through perlop/perlsyn and made unary all the operators that were unary in Perl5 (and haven't changed in an invalidating way)

[18:28] <sorear> rakudo: say [===] *.&sin, &sin

[18:28] <p6eval> rakudo b2bc99: OUTPUT«Method 'sin' not found for invocant of class 'Whatever'␤  in 'sin' at line 2137:src/gen/core.pm␤  in main program body at line 22:/tmp/A8DXyz3Q61␤»

[18:28] <colomon> sorear: Just so we're on the same wavelength, you think sin not being a unary operator is a bug?

[18:28] <TimToady> I've been trying to get rid of named unaries, except for traditional math ops

[18:28] <PerlJam> sorear: you think it's a bug that there aren't more unaries?

[18:29] <sorear> PerlJam: the only unaries in STD are abs, sleep, so, and not IIRC

[18:29] <sorear> this list makes no sense

[18:29] <PerlJam> ah.

[18:30] <PerlJam> you don't want more unaries as much as you wan a conceptual hook to hang them on.

[18:30] <TimToady> there is no list that actually does make sense, in the sense of not being rather arbitrary

[18:31] <colomon> defined is a unary in rakudo, it appears...

[18:31] <TimToady> and I'd like the user not to have to memorize a long list of unaries

[18:31] <TimToady> quick, is mkdir a unary?

[18:31] *** snarkyboojum joined
[18:31] <PerlJam> no!

[18:31] <PerlJam> :)

[18:31] <TimToady> is sin a unary?

[18:32] <TimToady> if it has a :base?

[18:32] <sorear> TimToady: adverb

[18:32] <TimToady> nevertheless, it's a second arg

[18:33] <sorear> niecza: say abs 1 :foo

[18:33] <p6eval> niecza v6-186-g9c59f52: OUTPUT«Unhandled exception: Excess arguments to CORE prefix:<abs>, unused named foo␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE prefix:<abs> @ 0) ␤  at /tmp/m8CRXhIbu6 line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1780 (COR…

[18:33] <sorear> perl6: say defined 1 && 0 # I really do not like this inconsistency

[18:33] <p6eval> niecza v6-186-g9c59f52: OUTPUT«Bool::True␤»

[18:33] <p6eval> ..pugs, rakudo b2bc99: OUTPUT«0␤»

[18:34] *** Bzek left
[18:35] <TimToady> and if we drive it merely off of having one positional argument, you get many accidental unaries

[18:35] *** mj41 left
[18:35] <TimToady> which are suddenly no longer unary if you add another arg

[18:36] <PerlJam> TimToady: so, for clarity, a short list of named unaries to memorize is okay?

[18:36] <PerlJam> (a *really* short list I would hope)

[18:37] <TimToady> druther not have to memorize any list, but if there's a natural place to cut it, I'm all ears

[18:37] <sorear> Why are abs, sleep, so, and not unaries?

[18:38] <TimToady> note the comment: ## named unary examples

[18:38] <TimToady> the intent is that most all such operators be defined in the setting eventually, not the grammar

[18:39] <TimToady> I'm not opposed to having named unaries, but I'd like a rule I can tell people so they can at least guess right most of the time

[18:39] <TimToady> I guess if we have too many, and they guess wrong, they'll just get a "useless use of" warning

[18:40] <TimToady> or a misplaced arg

[18:40] <PerlJam> so and not feel like they should be unary

[18:40] <TimToady> define "feel"

[18:40] <PerlJam> I wish I could.  :)

[18:40] <PerlJam> It just seems like those would get used in contexts where "unariness" would be appropriate

[18:41] *** mj41 joined
[18:41] <TimToady> people are always carping about the ($) proto in p5 changing the syntax

[18:41] <TimToady> so unaries really need to be put explicitly into the prefix category

[18:41] <TimToady> not just rely on the sig

[18:43] <TimToady> but we do have the named unary category, carried over from P5, and we should either grow it to the boundaries of "feely" unaries, or turn 'em all into listops

[18:43] <TimToady> I'd also like to understand the failure modes a bit more

[18:45] <TimToady> and are there any current "feely" listops "foo" that could use to be foo« instead

[18:48] <TimToady> iow, do a similar analysis of mappy operations into scalar ops like we did with min LIST vs [min] LIST

[18:49] <TimToady> only instead of foo LIST becoming [foo] LIST it becomes foo« LIST

[18:49] <TimToady> we won't do this, but suppose for the sake of argument that print was a unary

[18:49] <TimToady> current print would become print«

[18:50] <PerlJam> or  print(...)

[18:50] <TimToady> well, only if there was a multi to handle it

[18:51] <PerlJam> for things like abs or sleep, that seems like a "natural" way to write it in absense of unary

[18:51] <TimToady> the natural unaries are close to the natural "argumentless" *.foo

[18:52] <TimToady> but the fact that you can unambigously write 42.sin takes some pressure off of getting sin 42 right

[18:52] <PerlJam> yeah, but it looks weird  ;)

[18:53] <PerlJam> makes me suddenly think I'm writing ruby

[18:53] <tadzik> I'd prefer Math.sin(42) to 42.sin any time

[18:53] <TimToady> bletch

[18:53] <PerlJam> what TimToady said

[18:54] <tadzik> 42.sin just doesn't feel right to me

[18:54] <TimToady> there's that "feel" thing again...

[18:54] <TimToady> you'd be fine with it if mathematicians had been writing it that way for donkey's years

[18:54] <colomon> not only is 42.sin right, it's more likely to work on weird types, and it is (at the moment) more efficient, at least in rakudo.

[18:54] <tadzik> probably, yes

[18:55] <tadzik> but that makes me feel that Int, Num or whatever should be capable of calling any common math function on itself

[18:56] <colomon> also -- we've got sin(42), too.  It's just sin 42 that's at question.

[18:56] <colomon> tadzik: errr... Int, Num or whatever (if whatever is Real) is capable of calling any common math function on itself.

[18:56] <TimToady> "common math function" means it's already in the language, and hence should be in the language :)

[18:57] <colomon> TimToady: actually, I've been meaning to add a few new ones at some point.  ;)

[18:57] <TimToady> I really don't like importing universal concepts from Math

[18:58] <TimToady> sure, if you want to use OEIS-582, that's worth importing

[18:58] <TimToady> but not things they teach in high school

[18:58] <TimToady> they should just be there

[19:00] <TimToady> rakudo: say i.sin

[19:00] <p6eval> rakudo b2bc99: OUTPUT«0 + 1.1752011936438i␤»

[19:00] * PerlJam wanders off to a "web design" meetings

[19:00] <PerlJam> er, meeting

[19:00] <TimToady> o/

[19:04] <TimToady> huh, Figurate numbers based on 9-dimensional regular simplex

[19:05] <TimToady> http://oeis.org/A000582

[19:05] <moritz> "interesting"

[19:06] *** mkramer1 joined
[19:06] * colomon hopes TimToady isn't getting ideas about having the sequence operator look up sequences from OEIS...

[19:07] <moritz> sounds like a nice module.

[19:08] <TimToady> oeis-42 is cute

[19:08] <TimToady> perl6: .say for [\~] 1 xx *

[19:09] <tadzik> colomon: yeah, I know, that bothers me a bit to. But I'm not the one who is to complain

[19:09] <p6eval> rakudo b2bc99: OUTPUT«(timeout)1␤11␤111␤1111␤11111␤111111␤1111111␤11111111␤111111111␤1111111111␤11111111111␤111111111111␤1111111111111␤11111111111111␤111111111111111␤1111111111111111␤11111111111111111␤111111111111111111␤1111111111111111111␤11111111111111111111␤111111111111111111111␤1111…

[19:09] <p6eval> ..pugs: OUTPUT«(timeout)»

[19:09] <p6eval> ..niecza v6-186-g9c59f52: OUTPUT«(timeout)1␤11␤111␤1111␤11111␤111111␤1111111␤11111111␤111111111␤1111111111␤11111111111␤111111111111␤1111111111111␤11111111111111␤111111111111111␤1111111111111111␤11111111111111111␤111111111111111111␤1111111111111111111␤11111111111111111111␤11111111111111111…

[19:11] <TimToady> funny, niecza blows up with I run that in the repl

[19:12] <TimToady> System.NullReferenceException: Object reference not set to an instance of an object

[19:12] <TimToady> sorear: ^^

[19:12] <TimToady> All Systems Are Go For Lunch

[19:13] *** kanishka left
[19:16] *** mkramer1 left
[19:17] <TimToady> not to be confused with Gopher Lunch...

[19:17] <diakopter> Argot 4 Lunch

[19:19] *** birdwindupbird joined
[19:19] <diakopter> TimToady: which version of mono do you have these days

[19:20] <diakopter> not to be confused with nucleosis

[19:26] <TimToady> 2.8.2

[19:28] *** mtk left
[19:29] *** mtk joined
[19:30] *** jdhore1 left
[19:34] *** mj41 left
[19:39] <sorear> TimToady: yeah, the repl doesn't like code that uses $_

[19:39] <moritz> nom: say "foo" if 1

[19:39] <p6eval> nom: OUTPUT«foo␤»

[19:39] <sorear> I think what's going on is that the repl isn't correctly binding to the setting, so "is dynamic" outer variables follow a null pointer

[19:43] *** jdhore1 joined
[19:48] <TimToady> sorear: your hyper function has a funny argument order

[19:48] <TimToady> any particular reason?

[19:51] <sorear> TimToady: consistency with .assuming, I think

[19:51] <TimToady> jnthn: and what is the :path arg in rakudo's hyper function?

[19:51] <jnthn> TimToady: No idea, I didn't write it. Lemme see if I can work out how it's used...

[19:52] * TimToady thinks we should agree on the general hyper api, y'see

[19:52] <sorear> if the user writes [»+«], hyper(False, False, &infix:<+>, ...) needs to be wrapped in a function

[19:52] <sorear> TimToady: Rakudo's :path is just used for error messages

[19:52] <jnthn> Ah

[19:52] <jnthn> sorear++ # knows Rakudo better than me :)

[19:52] <TimToady> let's you and him fight about the API then  :)

[19:53] <moritz> rakudo: { a => [1, 2] } >>+<< { a => [1,] }

[19:53] <p6eval> rakudo b2bc99: OUTPUT«Sorry, lists on both sides of non-dwimmy hyperop are not of same length:␤    left:  2 elements␤    right: 1 elements␤At .{"a"}␤  in 'hyper' at line 192:src/gen/core.pm␤  in <anon> at line 264:src/gen/core.pm␤  in 'hyper' at line 1:src/metamodel/RoleToInstanceApplie…

[19:53] <TimToady> 'cause I'd sure like to mention hyper() on RC

[19:53] <sorear> more generally, I think it would be cool if there were a standard API for metaops

[19:54] <sorear> because then I could make infix_prefix_meta_operator and all that work in add_categorical

[19:54] <sorear> which would be awesome

[19:54] <TimToady> and there should be a standard meta-API for that too... :P

[19:54] *** mtk left
[19:54] <TimToady> what's the opposite of turtles all the way down?

[19:55] <jnthn> Cheetahs all the way up?

[19:55] <moritz> turtles all the way up?

[19:55] *** mtk joined
[19:55] <colomon> butterflies all the way up

[19:55] <TimToady> obviously, turtles only halfway down

[19:55] *** mtk left
[19:56] *** mtk joined
[19:58] *** pernatiy joined
[20:00] *** bluescreen10 left
[20:04] <dalek> niecza: ad86d69 | sorear++ | / (7 files):

[20:04] <dalek> niecza: Remove content-free "bif_" prefix, reduce requirement for explicit _cgop use

[20:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ad86d69808

[20:04] <colomon> bif means built-in function, right?

[20:04] * colomon figured that out just a day before it got removed

[20:06] <moritz> nom: my $x; $x++; say $x

[20:06] <p6eval> nom: OUTPUT«Method 'succ' not found for invocant of class 'Any'␤current instr.: 'postfix:<++>' pc 187091 (src/gen/CORE.setting.pir:47015) (:278)␤»

[20:06] *** wolfman2000 joined
[20:07] <moritz> nom: my $x = Mu; $x++; say $x

[20:07] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'postfix:<++>'. Available candidates are:␤:(Int $a)␤:(Num $a)␤:(Any $a)␤␤current instr.: 'postfix:<++>' pc 187047 (src/gen/CORE.setting.pir:46995) (:275)␤»

[20:07] <moritz> rakudo: say Any.succ

[20:07] <p6eval> rakudo b2bc99: OUTPUT«Method 'succ' not found for invocant of class ''␤  in main program body at line 22:/tmp/pbHp7kqRYt␤»

[20:07] <moritz> niecza: say Any.succ

[20:07] <p6eval> niecza v6-186-g9c59f52: OUTPUT«1␤»

[20:13] *** Mowah left
[20:18] *** MayDaniel joined
[20:19] <dalek> rakudo/nom: 6565c9a | moritz++ | / (3 files):

[20:19] <dalek> rakudo/nom: implement .chomp, note .chop as LHF

[20:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6565c9aadd

[20:19] <dalek> rakudo/nom: 0b1bea7 | moritz++ | / (5 files):

[20:19] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[20:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0b1bea765e

[20:19] <dalek> rakudo/nom: 6db95e2 | moritz++ | src/core/ (3 files):

[20:19] <dalek> rakudo/nom: make "my $x; $x++" work.

[20:19] <dalek> rakudo/nom: 

[20:19] <dalek> rakudo/nom: I am not so sure this is the right approach, so pmichaud++ or jnthn++ please review it

[20:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6db95e2f37

[20:20] *** birdwindupbird left
[20:22] <sorear> colomon: your asking me about it was the clue that made me realize it was useless

[20:23] <TimToady> http://rosettacode.org/wiki/Element-wise_operations#Perl_6  <-- more hypers

[20:24] <dalek> rakudo/nom: 07f2abd | jnthn++ | src/ (4 files):

[20:24] <dalek> rakudo/nom: Start to put BEGIN/CHECK/INIT/END back together. They run at the right times, though BEGIN and CHECK don't yet see the lexical environment (will be fixed when those issues are dealt with generally). Also need to twiddle a bit more with END in pre-compilation mode, but it's fine for the Test.pm case that we immediatley need it for.

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/07f2abdad8

[20:24] <dalek> rakudo/nom: bb4567a | jnthn++ | src/Perl6/Actions.pm:

[20:24] <dalek> rakudo/nom: Fix binding to natives error.

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bb4567a2a6

[20:24] <dalek> rakudo/nom: 47daf70 | jnthn++ | Test.pm:

[20:24] <dalek> rakudo/nom: Use my instead of our variables in Test.pm; they were likely at least partly workarounds for END blocks not seeing the lexical environment, which they do now.

[20:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/47daf702b3

[20:24] <jnthn> moritz: Seems sane

[20:25] <jnthn> moritz: Like that we end up with less protos too ;)

[20:26] <sorear> token infix:sym<` `> { '`' ~ '`' <EXPR> <O(%additive)> } # Discuss.

[20:26] <mikemol> The image processing tasks ought to be very good demonstrations of hypers with measurable differences in performance between different implementations of Perl 6.

[20:26] <moritz> you mean slow-ish and "awefully slow"?

[20:26] <sorear> niecza's hypers are probably very slow atm

[20:27] <mikemol> More, "processes single-threaded" vs "passes to a thread pool" vs "passed to some OpenCL-like backend"

[20:27] <mikemol> Since one of the suggested uses of hypers is automatic parallelization of operations.

[20:27] <sorear> OpenCL hypers: now *that* is funny...

[20:28] <mikemol> I really don't see how you'd do the cross-compile yet, but TimToday's the one who suggested it might get run on a GPU...

[20:29] <sorear> At this time it looks pretty unlikely that hypers will be parallel *by default*, since most real-world use of hypers is on small data sets and I don't want to pessimize the common case

[20:29] <sorear> OpenCL hypers will probably make more sense once we have understood typed compact arrays

[20:29] <moritz> you can still decide based on the size of the already-reified parts

[20:31] <sorear> but the cutoff needs to depend on the operator

[20:31] <jnthn> moritz: Think main think we're missing for Test.pm to be vaguely usable is "is export" now

[20:31] <sorear> «+» shouldn't parallelize below (quite a few) items, ».&mandel should start parallelizing sooner because each call is more expensive

[20:32] *** Moukeddar joined
[20:32] <Moukeddar> Hello o/

[20:33] <TimToady> sorear: obviously you just start it both ways and see who wins :)

[20:34] <TimToady> and certainly machines can generate some rules of thumb for various signatures

[20:35] <jnthn> o/ Moukeddar 

[20:35] <Moukeddar> how are you all doing ?

[20:35] <TimToady> much like the old configurators that would run several different sort routines to see which one was faster

[20:35] <moritz> nom: sub f($x = 5) { say $x }

[20:35] <p6eval> nom:  ( no output )

[20:35] <moritz> nom: sub f($x = 5) { say $x }; f

[20:35] <p6eval> nom: OUTPUT«5␤»

[20:37] <TimToady> or the first time you try to call such a routine, you start it in the CPU, and if it returns quickly, you leave it there

[20:37] *** masak joined
[20:37] <masak> y0 #perl6

[20:37] <TimToady> if it's been N milliseconds and you haven't got an answer, then start up the GPU

[20:37] <masak> I vote for no named unaries.

[20:37] *** MayDaniel left
[20:37] <masak> mostly just to see what happens. :)

[20:37] <TimToady> you might or might not still beat the GPU

[20:37] <TimToady> CPU

[20:38] <TimToady> okay, that's one vote for named unaries...anyone else

[20:38] <masak> no, against. :P

[20:38] <TimToady> if you're against it, it counts as a vote for

[20:38] <masak> dang.

[20:38] <jnthn> :)

[20:38] <masak> still haven't figured out this voting system.

[20:38] <jnthn> o/ masak 

[20:38] <masak> \o

[20:38] * moritz votes exactly oposite to masak++'s vote

[20:38] <moritz> just 'cause

[20:39] <masak> moritz: it's a trap! :)

[20:39] <TimToady> are you a cretan?

[20:39] <masak> we're all a bit epimedic sometimes.

[20:39] <sorear> TimToady: I'm wary of starting races.  seems like a waste of joules

[20:39] <moritz> pmichaud: btw statement-modifying for doesn't seem to work (properly?) in nom

[20:39] <moritz> nom: .say for 1, 2, 3

[20:40] <p6eval> nom: OUTPUT«Null PMC access in find_method('new')␤current instr.: 'nqp;Perl6;Actions;_block1837' pc 30162 (src/gen/perl6-actions.pir:10118)␤»

[20:40] <TimToady> you only start it if it looks like the CPU is being slow, and you only try the race once

[20:40] <TimToady> then you remember

[20:40] *** prammer left
[20:40] <masak> is pmichaud still in transit? I wanted to ask him about the exact reason perl6-on-parrot was canceled in 2004.

[20:40] <TimToady> but hopefully the switchover points can be precalculated for most common operators and types

[20:41] *** prammer joined
[20:41] <jnthn> moritz: Looks like Actions just didn't get updated there yet.

[20:41] <sorear> masak: I think Perl6 on Parrot is still actively developed

[20:41] *** alester joined
[20:42] <TimToady> you're thinking of Perl6 *over* Parrot :)

[20:42] <masak> :P

[20:42] <TimToady> there's some interturtles...

[20:42] <masak> sorear: sure, but alpha is not genealogically related to 2004's perl6-on-parrot.

[20:43] <moritz> btw I'm working on IO in nom now

[20:43] <TimToady> IO is good

[20:43] <moritz> IO is necessary

[20:44] <masak> sorear: and pmichaud was actually "hired" because the Parrot people realized that this Perl 6 bit was too much to chew off while also making Parrot. or sump'n.

[20:44] <Moukeddar> Hello masak 

[20:44] <masak> Moukeddar: hi.

[20:44] <jnthn> moritz: Excellent, thanks.

[20:44] <masak> Moukeddar: I'm closer to Morocco than usual :) I'm in Paris.

[20:45] <TimToady> Gay Paris, not to be confused with Pairs...

[20:45] <Moukeddar> nice :)

[20:45] <Moukeddar> not gay :@

[20:45] <masak> this place looks fairly gay to me.

[20:45] <huf> is it full of scotsmen?

[20:45] <Moukeddar> the kisses?

[20:45] <masak> phenny: "c'est une ville gaie"?

[20:46] <phenny> masak: "is a gay city" (fr to en, translate.google.com)

[20:46] <tadzik> for some meaning of gay, yes

[20:46] <masak> huh :)

[20:46] <jnthn> rakudo: { say 'lol' } for 1..5

[20:46] <p6eval> rakudo b2bc99: OUTPUT«lol␤lol␤lol␤lol␤lol␤»

[20:46] <jnthn> Is this correct?

[20:46] <jnthn> niecza: { say 'lol' } for 1..5

[20:46] <p6eval> niecza v6-187-gad86d69:  ( no output )

[20:46] <jnthn> pugs: { say 'lol' } for 1..5

[20:46] <Moukeddar> it's a nice city

[20:46] <p6eval> pugs:  ( no output )

[20:46] <tadzik> why shouldn't it be?

[20:46] <masak> phenny: "est-ce que tu connais la difference entre 'gai' et 'hereux'?"?

[20:46] <phenny> masak: "est-ce que la difference between your connais 'gai' et 'hereux'?" (es to en, translate.google.com)

[20:46] <moritz> jnthn: I don't think it should execute the block... at least not according to the spec I remember

[20:47] <TimToady> it's in there somewhere

[20:47] <jnthn> moritz: Yeah, that was my feeling too

[20:47] <Moukeddar> enjoy it

[20:47] <masak> thanks.

[20:47] <jnthn> Rakudo master actually goes to some effort to make sure it executes it...

[20:47] <jnthn> nom: .say given 42;

[20:47] <p6eval> nom: OUTPUT«42␤»

[20:47] <TimToady> it's considered a bare block

[20:47] <jnthn> TimToady: Which'd mean it's executed?

[20:47] <masak> jnthn: there's a spectest against that somewhere.

[20:48] <tadzik> rakudo: { say 'lol' }.() for 1..5

[20:48] <masak> or for.

[20:48] <p6eval> rakudo b2bc99: OUTPUT«lol␤lol␤lol␤lol␤lol␤»

[20:48] <masak> it's changed a few times. :)

[20:48] <jnthn> heh ;)

[20:48] <tadzik> niecza: { say 'lol' }.() for 1..5

[20:48] <p6eval> niecza v6-187-gad86d69: OUTPUT«lol␤lol␤lol␤lol␤lol␤»

[20:48] <masak> but there's a test is the important message.

[20:48] <masak> outlining the latest decision, methinks.

[20:49] *** PacoLinux left
[20:49] <jnthn> https://github.com/perl6/roast/blob/master/S04-statement-modifiers/for.t#L62

[20:49] *** PacoLinux joined
[20:49] <TimToady> mostly as a degenerate case of S04:691

[20:49] <jnthn> OK, current Rakudo does what the test wants. I'll preserve that.

[20:50] *** daemon left
[20:50] <tadzik> a-ha

[20:50] <Moukeddar> masak, you should drop by :)

[20:50] *** tomize left
[20:50] <dalek> rakudo/nom: fd62049 | moritz++ | src/core/IO.pm:

[20:50] <masak> I "almost" managed to implement https://gist.github.com/1045125

[20:50] <dalek> rakudo/nom: implement open()

[20:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd62049111

[20:50] <dalek> rakudo/nom: 5307d26 | moritz++ | src/core/IO.pm:

[20:50] <dalek> rakudo/nom: start with implementing basic IO

[20:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5307d26a4e

[20:50] <Moukeddar> El-Massira Airport :|

[20:50] <masak> so anyone who wants to beat me to it has to hurry :)

[20:51] <masak> Moukeddar: already have tickets home... :)

[20:51] <Moukeddar> you miss Moma ?

[20:51] *** PacoLinux left
[20:51] <masak> Moukeddar: well, 'home' means 'where I live', not 'where Moma lives' :P

[20:52] <Moukeddar> i thought they were the same , they're here :p

[20:52] *** PacoLinux joined
[20:52] <masak> depends on your age and stuff, I guess.

[20:52] <Moukeddar> could be

[20:52] *** tomize joined
[20:52] <Moukeddar> so, did you enjoy your Parisien ?

[20:52] <Moukeddar> croissant?

[20:53] <masak> hm, no croissant yet.

[20:53] <masak> but I am enjoying it.

[20:53] <masak> now I understand what all the fuss about l'arc de triomphe is about. it's massive.

[20:53] <masak> I mean, wow.

[20:53] <moritz> nom: sub f($x, :$named = 1.Bool) { say $named }; f('foo', :!named);

[20:53] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[20:53] <masak> p6eval++

[20:54] <Moukeddar> just a big block of Marbel i guess , or regular stone, nothing fancy

[20:54] <moritz> Unexpected named parameter 'named' passed

[20:54] <masak> nom: say "Rebuild in progress"

[20:54] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[20:54] <tadzik> touche

[20:54] <masak> Moukeddar: you say that after you've made one yourself :)

[20:55] <Moukeddar> they didn't made it :)

[20:55] <Moukeddar> make*

[20:55] <masak> I maintain they did, fsvo "they". :)

[20:55] <tadzik> moritz: why 1.Bool rather than True?

[20:55] <jnthn> ENOTrue

[20:55] <masak> True NYI?

[20:55] <masak> right.

[20:55] <Moukeddar> Oh! they Di-Idnt :p

[20:56] <moritz> tadzik: because True doesn't work in the setting

[20:57] <tadzik> oh, I see

[20:57] <Moukeddar> anyway masak have a nice flight :)

[20:58] <Moukeddar> thanks for using le herp de la Derp airlines

[21:00] <masak> :)

[21:01] <masak> Niecza appears to have been born on 2010-06-22. oh right, sorear was talking about an anniversary a few days ago...

[21:02] <masak> Niecza truly has come a long way in a year.

[21:03] <masak> people, could you help me enumerate large-scale Perl 6 features? then I/we can check if Pugs/Rakudo/Niecza have them.

[21:03] <masak> I'll start. classes. :)

[21:03] <masak> all three have them, as far as I know.

[21:04] <jnthn> roles :)

[21:04] <masak> what about heredocs?

[21:04] <masak> ooh

[21:04] <jnthn> multis

[21:04] <masak> perl6: role A }

[21:04] <masak> argh

[21:04] <p6eval> niecza v6-187-gad86d69: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Unable to parse role definition at /tmp/awN0DherMZ line 1:␤------> [32mrole A [33m⏏[31m}[0m␤␤Parse failed␤␤»

[21:04] <p6eval> ..rakudo b2bc99: OUTPUT«===SORRY!===␤Malformed package declaration at line 22, near "}"␤»

[21:04] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "}"␤    expecting trait␤    at /tmp/a_ofCFe2r7 line 1, column 8␤»

[21:04] <masak> perl6: role A {}; class C does A {}; say "alive"

[21:04] <p6eval> niecza v6-187-gad86d69: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method trait_mod:does not yet implemented at /tmp/Qu0IruJI5H line 1:␤------> [32mrole A {}; class C does A [33m⏏[31m{}; say "alive"[0m␤␤Cannot use hash access on an object of type Str at /tmp/Qu0IruJI5H line 1:␤--…

[21:04] <p6eval> ..pugs, rakudo b2bc99: OUTPUT«alive␤»

[21:05] <masak> jnthn++ # nice

[21:05] *** Moukeddar left
[21:06] <masak> pugs: say q:to:"EOF"

[21:06] <p6eval> pugs: OUTPUT«*** No such subroutine: "&q"␤    at /tmp/PCqIkbt_Cb line 1, column 5-9␤»

[21:06] <masak> no heredocs.

[21:06] <masak> but Niecza has 'em, ISTR.

[21:07] <TimToady> niecza: say q:to:"EOF"␤alive␤EOF␤

[21:07] <p6eval> niecza v6-187-gad86d69: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Colons may not be used to delimit quoting constructs at /tmp/ezXxGbBEG7 line 1:␤------> [32msay q:to[33m⏏[31m:"EOF"[0m␤␤Parse failed␤␤»

[21:07] <masak> oops

[21:07] <TimToady> niecza: say q :to "EOF"␤alive␤EOF␤

[21:07] <p6eval> niecza v6-187-gad86d69: OUTPUT«alive␤␤»

[21:07] <masak> \o/

[21:07] <masak> sorear++

[21:08] <masak> macros. none of the implementations have that.

[21:08] <jnthn> nom: sub f($x, :$named = 1.Bool) { say $named }; f('foo', :!named);

[21:08] <p6eval> nom: OUTPUT«Unexpected named parameter 'named' passed␤current instr.: 'f' pc 281 ((file unknown):195) (:1)␤»

[21:08] <jnthn> nom: sub f($x, :$named) { say $named }; f('foo', :!named);

[21:08] <p6eval> nom: OUTPUT«Unexpected named parameter 'named' passed␤current instr.: 'f' pc 255 ((file unknown):153) (:1)␤»

[21:08] <sorear> pugs: macro foo($x) { say $x; $x }; foo(2)

[21:08] <p6eval> pugs: OUTPUT«2␤*** ␤    Unexpected end of input␤    expecting ":"␤    Macro did not return an AST, a Str or a Code!␤    at /tmp/WhcDvL5hnF line 1, column 37␤»

[21:08] <jnthn> nom: sub f($x, :$named) { say $named }; f('foo', :named(1));

[21:08] <p6eval> nom: OUTPUT«1␤»

[21:08] <TimToady> pugs: macro foo { "bar" }; foo

[21:08] <p6eval> pugs: OUTPUT«*** No such subroutine: "&bar"␤    at MACRO { "/tmp/QMKw01QiXm" (line 2, column 1) } line 1, column 1 - line 2, column 1␤»

[21:09] <TimToady> ^^

[21:09] <jnthn> nom: sub f($x, :$named) { say $named }; f('foo', :named);

[21:09] <p6eval> nom: OUTPUT«Unexpected named parameter 'named' passed␤current instr.: 'f' pc 255 ((file unknown):153) (:1)␤»

[21:09] <jnthn> er, hm.

[21:09] <moritz> so :foo doesn't work?

[21:09] <jnthn> looks like

[21:09] <sorear> nom: sub f(:$named) { say $named }; f(|{ '$named' => 5 })

[21:09] <p6eval> nom: OUTPUT«Could not find sub &prefix:<|>␤current instr.: '_block1002' pc 112 ((file unknown):57542892) (:1)␤»

[21:10] <moritz> ./perl6 -e 'say open("README", :chomp(0.Bool)).lines'

[21:10] <moritz> works in nom

[21:10] <masak> sorear: I remember at least one big Niecza refactor; the one that made Niecza bootstrap. have there been others?

[21:10] <tadzik> oh, chromatic responded to the naming story

[21:10] <TimToady> "big" is a fractal

[21:10] <masak> ooh

[21:11] <masak> tadzik: url?

[21:11] <sorear> ==TimToady

[21:11] <sorear> it's more of a power-law thing

[21:11] <sorear> like big earthquakes

[21:12] <masak> oki, so it's not three distinct phases like with Rakudo? fair enough.

[21:12] <tadzik> masak: http://www.modernperlbooks.com/mt/2011/06/perl-perl-5-perl-6-and-names.html

[21:12] <sorear> I've had a couple of refactors big enough that I had to split them between commits with non-working states in between

[21:13] <sorear> the bootstrappification was the biggest one, it required translating the entire compiler to Perl 6...

[21:14] <sorear> recently I remember /mm (which did away with most automatic INIT blocks, moving them into a Begin compiler phase) and /immediate (which combined Begin with the parse)

[21:15] <masak> tadzik: thanks. I found it by logging into Twitter :)

[21:15] <tadzik> :)

[21:16] <masak> ergh. truly, I dislike the name "Perl++" and its connotations a bit extra.

[21:16] <tadzik> let's name it Zebra

[21:16] <moritz> "Just as bad as C++"?

[21:17] <masak> sorear: ok, so either zero big refactors, or one, or lots of them?

[21:17] <tadzik> we could also use the 'package Foo;' syntax again

[21:17] <TimToady> Obviously Perl++ would be Perm, then Pern, Pero, Perp, Perq, Perr, Pers, Pert, Peru, Perv, Perw, Perx, Pery, and Perz

[21:17] <sorear> can't use Pern

[21:18] <TimToady> sure we can, different domain

[21:18] <TimToady> and Pero is a roasted-grain drink

[21:18] <TimToady> I hear Peru is available

[21:18] <TimToady> but actually it's Perl--, so Perk

[21:18] <tadzik> Peru++ would be Perv

[21:19] <TimToady> perk would be the JVM one, obviously

[21:20] <tadzik> wasn't there something on Parrot called Perk?

[21:20] <TimToady> Perk should be the real name of nqp

[21:20] <masak> :P

[21:21] <tadzik> https://github.com/chrisdolan/perk

[21:23] <masak> I'll add "real LTM" as a point in favor of Niecza.

[21:24] <masak> sorear: https://github.com/sorear/niecza/blob/master/docs/DIRECTIONS -- on line 47, you can strike <.SUPER::name>; it's no longer spec.

[21:24] *** daemon joined
[21:25] <sorear> uh... that file is so out of date, I forgot it existed :|

[21:25] <masak> I'm slowly realizing that :)

[21:26] <masak> things further down look out of date too.

[21:26] <masak> where can I find more current information? the release announcements?

[21:26] <sorear> yes

[21:28] * masak goes through them

[21:30] *** masak` joined
[21:33] *** masak left
[21:37] *** masak` left
[21:38] <dalek> rakudo/nom: 067b038 | jnthn++ | src/Perl6/Actions.pm:

[21:38] <dalek> rakudo/nom: Fix statement modifying for, make way statement modifying given is done more consistent with that way.

[21:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/067b0387ba

[21:38] <dalek> rakudo/nom: 6f054ba | jnthn++ | src/Perl6/Actions.pm:

[21:38] <dalek> rakudo/nom: Fix old-think lookup.

[21:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6f054ba751

[21:38] <dalek> rakudo/nom: 7963293 | jnthn++ | src/Perl6/Actions.pm:

[21:38] <dalek> rakudo/nom: Fix :foo and :!foo breakage spotted by moritz++.

[21:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/79632930d6

[21:39] *** cotto left
[21:42] *** Patterner left
[21:42] *** Psyche^ joined
[21:42] *** Psyche^ is now known as Patterner

[21:44] <tadzik> AAAAAAAAAAAAAAAA http://search.cpan.org/~mschwern/AAAAAAAAA-1.00/

[21:46] <tadzik> we need to have this ported to Perl6

[21:46] <jnthn> AAA?!

[21:46] <tadzik> AAAAAAAAAA!

[21:48] <tadzik> hopefully he will have a yapc talk about this module

[21:51] <slavik> lol

[21:53] * tadzik resists the temptation to Rate this distribution

[21:54] <thou> "works as advertised"

[21:58] *** Holy_Cow joined
[21:58] <lichtkind> thou: hai

[21:58] <thou> hello!

[21:58] *** Holy_Cow left
[22:03] *** wamba left
[22:05] <lichtkind> thou: please not remove the spam i need it show the problem :)

[22:08] *** cotto joined
[22:15] <dalek> niecza: 4c4f12a | sorear++ | / (7 files):

[22:15] <dalek> niecza: Move most builtin definitions into the setting

[22:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4c4f12a9d9

[22:16] *** sjn left
[22:19] *** sjn joined
[22:19] *** alester left
[22:29] * felher just found the '...' operator ( big thnx to all rosettacode writers) and _really_ likes it :)

[22:36] *** hanekomu left
[22:41] *** neaer joined
[22:42] *** masak joined
[22:43] <masak> g'ah. not even deadlines instill the right kind of industrious fear in me anymore... :)

[22:43] <sorear> hello masak!

[22:43] <sorear> what kind of deadlines?

[22:43] <masak> well, I have this talk tomorrow.

[22:43] <jnthn> masak: You have TWO. :P

[22:43] <masak> actually two, but jnthn++'s slides were easy enough to adapt.

[22:43] <sorear> is YAPC::EU started yet? I noticed an anomalous spike in my github new-follower rate

[22:44] <masak> sorear: no no, that's in August.

[22:44] <masak> sorear: but we had NPW last weekend and I'm at FPW this weekend.

[22:44] <lichtkind> thou: next there will be action

[22:46] <masak> I propose we kill off infix:<max>. together, &max and List.max already the same semantic space, and are less confusing. ditto infix:<min>, of course.

[22:46] <masak> s/already/already cover/

[22:46] *** cotto left
[22:46] <jnthn> masak: [max]

[22:46] <masak> jnthn: .max

[22:47] <jnthn> inte så söt :P

[22:47] <masak> I beg to differ.

[22:47] <jnthn> :)

[22:47] * jnthn isn't sure if he prefers the op or the meth.

[22:47] <masak> oh, and if you want the listop behavior, there's &max.

[22:47] <masak> having all three is nonsensical.

[22:48] <masak> or at least highly redundant.

[22:48] <masak> more so than is common in Perl. :P

[22:48] <jnthn> hm, true.

[22:48] <masak> and truthfully, 'max' never felt like an infix operator to me.

[22:49] <masak> 4 max 5? hmmm?

[22:49] <masak> what do you want me to do? max out 4 so it becomes 5? :)

[22:49] <jnthn> Yeah, it's a stretch.

[22:49] <masak> though... oh

[22:49] <masak> I do like '$a max= 4'

[22:49] <TimToady> @a Zmax @b

[22:49] <masak> yeah.

[22:50] <jnthn> And that. :)

[22:50] <masak> I'd like to have all the metaop behavior, but not the ops themselves :P

[22:50] <TimToady> and [\max]

[22:50] <jnthn> :P

[22:50] <masak> ooh

[22:50] <TimToady> I think you're just not used to it

[22:51] <masak> I'll give it three more years, then.

[22:51] <TimToady> heheh

[22:51] <TimToady> is that three years max?

[22:51] <masak> :P

[22:51] <masak> why do we have minmax, but not divmod? :P

[22:51] <TimToady> round tuits

[22:52] <masak> o.O

[22:52] <masak> I was *joking*!

[22:52] <sorear> I accidentally added divmod, quot, rem, and quotrem to the niecza runtime

[22:53] <sorear> but they're not bound to any names in the setting

[22:53] <TimToady> it does seem like seriously wrong to force the programmer to do two divisions when one would do

[22:53] * sorear volunteers to read masak's report

[22:53] *** masak` joined
[22:54] <sorear> TimToady: I suspect it would only be a win for bignums

[22:54] <TimToady> and it's a bit of a stretch to say that the optimizer will figure it out

[22:54] <masak`> yes, probably.

[22:54] *** donri left
[22:55] <masak`> though it would be fun to try :)

[22:55] <TimToady> well, we could just memoize all divisions  :P

[22:55] <masak`> all of them? all 447 of them? :)

[22:56] <masak`> hrm, les parisiens are howling to the moon outside of my window...

[22:56] <dalek> rakudo/nom: 4566436 | jnthn++ | src/Perl6/Actions.pm:

[22:56] <dalek> rakudo/nom: Start to refactor the various funky dispatches.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4566436972

[22:56] <dalek> rakudo/nom: 3ceb232 | jnthn++ | src/ (3 files):

[22:56] <dalek> rakudo/nom: First cut implementation of |@foo, |%bar.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ceb2321e2

[22:56] <dalek> rakudo/nom: d9abccf | jnthn++ | src/core/Mu.pm:

[22:56] <dalek> rakudo/nom: $foo.&bar(), $foo.^bar and $foo.?bar.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d9abccfbe0

[22:56] <dalek> rakudo/nom: 067831f | jnthn++ | NOMMAP.markdown:

[22:56] <dalek> rakudo/nom: Update nommap.

[22:56] *** masak left
[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/067831fdc3

[22:56] * sorear volunteers to read masak`'s report

[22:57] <masak`> sorear: thanks. I doubt I will publish any slides before giving my talk, though.

[22:57] *** masak` is now known as masak

[22:58] <masak> hm, didn't http://rakudo.org/status previously contain lots of good stuff about implemented features?

[22:58] * masak hits the internet archive

[22:59] <TimToady> lessee, what shall we do for #300 on RC..

[22:59] <masak> Sparta!

[23:00] <TimToady> well, I was just looking at "Program termination", which is kinda about everyone dying...

[23:01] <masak> :)

[23:02] <masak> two things in life are guaranteed: GC and taxes...

[23:02] <masak> timely GC, however...

[23:04] <masak> found it. http://web.archive.org/web/20090322092459/http://rakudo.org/status

[23:04] <masak> ISTR a nice pastel-colored slide with all those listed. don't know from whose presentation, though.

[23:04] <masak> was thinking of making my own, similar, slide.

[23:04] <masak> it brings the point home quite nicely: Rakudo has features.

[23:06] *** masak left
[23:07] *** masak joined
[23:09] <TimToady> http://rosettacode.org/wiki/Program_termination#Perl_6  <-- #300

[23:11] *** cooper left
[23:12] <masak> \o/

[23:14] <dalek> specs: cdb1b72 | larry++ | S29-functions.pod:

[23:14] <dalek> specs: spec exit at least as well as rosettacode does :)

[23:14] <dalek> specs: review: https://github.com/perl6/specs/commit/cdb1b72700

[23:14] <TimToady> okay, you guys can do the next 300 :)

[23:15] *** cotto joined
[23:15] <TimToady> well, okay, I had help with the first 300 :)

[23:15] <TimToady> well, okay, I *helped* with the first 300...

[23:16] <TimToady> Util: ^^

[23:17] <TimToady> colomon: you still owe us a pi :)

[23:19] <masak> ...and I had better go to bed.

[23:19] <masak> 'night, #perl6.

[23:19] <TimToady> o/

[23:20] *** cotto left
[23:20] *** masak left
[23:20] <lichtkind> good night

[23:37] * lichtkind submits another wxperl bug

[23:51] <jnthn> sleep &

[23:53] *** cooper joined
[23:53] <dalek> rakudo/nom: ef1aecf | jnthn++ | src/Perl6/SymbolTable.pm:

[23:53] <dalek> rakudo/nom: Cache literals that we build at compile time, so we don't build the same thing twice. Shaves ~65K off the setting PBC.

[23:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef1aecfa8b

[23:53] *** s1n left
[23:54] *** s1n joined
[23:57] *** whiteknight joined
