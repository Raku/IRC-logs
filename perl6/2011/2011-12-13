[00:06] *** packetknife left
[00:16] *** ksi left
[00:16] *** drbean left
[00:22] *** packetknife joined
[00:23] *** drbean joined
[00:31] *** lestrrat left
[00:33] *** lestrrat joined
[00:34] *** replore_ joined
[00:34] *** alim left
[00:37] *** stepnem left
[00:38] *** drbean left
[00:43] *** wolfman2000 joined
[00:44] <dalek> roast: 32452ff | coke++ | S05-m (2 files):

[00:44] <dalek> roast: Niecza - unfudge bugfixed.

[00:44] <dalek> roast: review: https://github.com/perl6/roast/commit/32452ffdc2

[00:45] *** drbean joined
[00:55] *** Radvendii joined
[00:56] <Radvendii> hey guys

[00:56] <Radvendii> ive got a bug

[00:56] <Radvendii> b: say (0,1,*+*...*)[1477]

[00:56] <p6eval> b 1b7dd1: OUTPUT«Inf␤»

[00:56] <sorear> Radvendii: Stop using b.

[00:56] <Radvendii> :(

[00:56] <Radvendii> why?

[00:56] <sorear> b does not support large integers

[00:57] <sorear> perl6: say (0,1,*+*...*)[1477]

[00:57] <p6eval> rakudo 92f383: OUTPUT«2114752986979021852557858619611791355705525027468032521749562265586340243239476666371378239325243976118646715662119083302633774252045520741882086869936691237540043402509431087092122991804222930097654049305082429757737746121400215994779830067135361065494411613234990…

[00:57] <p6eval> ..niecza v12-17-g8ff7b21: OUTPUT«2114752986979021852557858619611791355705525027468032521749562265586340243239476666371378239325243976118646715662119083302633774252045520741882086869936691237540043402509431087092122991804222930097654049305082429757737746121400215994779830067135361065494411…

[00:57] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "["␤    at /tmp/9tIwDqaSin line 1, column 18␤»

[00:58] <Radvendii> so is niecza just superior?

[00:59] <sorear> No. Why do you say that?

[01:00] <[Coke]> Radvendii: are you using b because you're on the last version of rakudo star?

[01:02] <Radvendii> yeah

[01:02] *** hundskatt left
[01:03] <[Coke]> so, that code path isn't getting updated; best you can do is check against nom to see if it's likely to be fixed in the next release of star.

[01:03] <[Coke]> Sorry for the inconvenience, but nom is better than b in a lot of respects.

[01:04] <Radvendii> in the meantime, every error ive run up against has been fixed in niecza

[01:04] <sorear> fixed in Rakudo, too

[01:05] <Radvendii> in nom?

[01:05] <sorear> Rakudo means nom now

[01:05] *** tokuhirom left
[01:05] <Radvendii> wha..?

[01:05] <Radvendii> how do i get a version on my computer that is fairly easy to update?

[01:06] <Radvendii> i want to use the language with fairly little interference from updating the compiler every couple of months...

[01:06] <Radvendii> or weeks. or however often

[01:06] <Radvendii> (not that the crazy big numbers is *that* much of an issue

[01:06] <Radvendii> :P

[01:10] <colomon> Radvendii: if you were doing all your work in niecza, you'd be running into niecza bugs which work in b and/or nom.  That's why I've got projects going on both niecza and nom...

[01:10] <sorear> colomon++ # perfect responce

[01:11] <[Coke]> if you don't want churn, stick with the star releases.

[01:11] <[Coke]> you're just at a bad point because there was a series of refactors that changed a lot fo the code underneath.

[01:11] <[Coke]> wait for the next star, which is based on the new line of rakudo development.

[01:12] <benabik> Which should be soon, right?

[01:12] <benabik> FSVO soon

[01:15] <[Coke]> I've heard as early as this month, but it really depends on jnthn++'s tuits.

[01:16] *** whiteknight joined
[01:16] *** whiteknight is now known as Guest87244

[01:17] *** thou left
[01:20] <colomon> jnthn seemed pretty determined to get it out this month, for what that is worth.  (As of last week.)

[01:24] *** stepnem joined
[01:29] *** lestrrat left
[01:29] *** hrj left
[01:29] *** lestrrat joined
[01:32] *** Radvendii left
[01:36] *** preflex left
[01:36] *** preflex_ joined
[01:37] *** preflex_ is now known as preflex

[01:37] *** cooper left
[01:41] *** Radvendii joined
[01:50] *** am0c joined
[01:55] *** cooper joined
[01:55] *** cooper left
[01:55] *** cooper joined
[01:55] *** cooper left
[01:55] *** cooper joined
[01:55] *** cooper left
[01:56] *** cooper joined
[02:05] *** stepnem left
[02:13] *** stepnem joined
[02:20] *** noidea joined
[02:20] <noidea> I looked at perl5 a while ago and it looked horrendous. I looked at perl6 today, and it has a beauty

[02:25] *** orafu left
[02:25] *** alvis left
[02:30] *** orafu joined
[02:30] *** geekosaur left
[02:30] *** geekosaur joined
[02:37] *** leprevost left
[02:38] *** icwiener joined
[02:39] *** alvis joined
[02:40] <sorear> noidea: hello and welcome

[02:41] *** DarthGandalf left
[02:43] *** Patterner left
[02:46] *** DarthGandalf joined
[02:59] *** Guest87244 left
[03:00] *** drbean left
[03:07] *** packetknife left
[03:08] *** drbean joined
[03:14] *** jaldhar joined
[03:24] *** drbean left
[03:27] *** volkove joined
[03:29] *** drbean joined
[03:34] *** Psyche^ joined
[03:34] *** Psyche^ is now known as Patterner

[03:39] *** Psyche^ joined
[03:39] *** Patterner left
[03:39] *** Psyche^ is now known as Patterner

[04:17] *** mikemol left
[04:21] *** mikemol joined
[04:21] *** mikemol left
[04:33] *** mikemol joined
[04:38] *** icwiener left
[04:39] *** donri left
[04:48] *** cooper left
[05:26] <dalek> niecza: 4659c86 | sorear++ | src/ (3 files):

[05:26] <dalek> niecza: Implement new character class syntax

[05:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4659c865de

[05:34] *** koban joined
[05:45] *** kaleem joined
[06:03] <dalek> niecza: e31c8eb | sorear++ | lib/Cursor.cs:

[06:03] <dalek> niecza: Support supplementary characters in LTM

[06:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e31c8eb035

[06:06] *** alim joined
[06:09] *** alim left
[06:18] *** Radvendii left
[06:26] *** drbean left
[06:32] *** drbean joined
[06:35] *** gfldex left
[06:36] *** gfldex joined
[06:38] *** thou joined
[06:56] *** sftp left
[07:23] *** birmjin joined
[07:26] *** wtw joined
[07:32] *** grondilu joined
[07:32] <grondilu> Hi, here is the error log from panda:  http://pastebin.com/82nMWaUV

[07:33] <grondilu> ahh sorry I don't think pastebin accepted it

[07:33] <grondilu> hang on

[07:36] <grondilu> http://s0.barwen.ch/~grondilu/err-log.panda.txt

[07:36] <dalek> niecza: 049fd3d | sorear++ | src/niecza:

[07:36] <dalek> niecza: Refactor, optimize, allow multi-character codes in character classes

[07:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/049fd3dbf8

[07:37] * sorear -> sleep

[07:38] <sorear> tomorrow: proper CRLF handling, other random regex stuff

[07:38] *** thou left
[07:39] *** grondilu left
[07:50] *** stepnem left
[07:52] *** araujo left
[07:53] *** fridim_ left
[07:54] *** stepnem joined
[07:58] *** mkramer joined
[08:01] *** araujo joined
[08:05] *** stepnem left
[08:11] *** stepnem joined
[08:29] <TiMBuS> non perl6 question but since im here: how do you provide an extra lib folder to cpan (for it to then pass to dmake)?

[08:33] <moritz> TiMBuS: PERL5LIB=$path/to/your/lib

[08:35] *** mkramer left
[08:36] *** mj41 joined
[08:36] <TiMBuS> does that work on windows

[08:36] <moritz> TiMBuS: the syntax is different on windows, iirc

[08:37] <moritz> but if you want it cross-platform, do   use lib '...'; inside the module

[08:37] <TiMBuS> nah its a dll

[08:38] <TiMBuS> i'm compiling gtk (ugh)

[08:38] <TiMBuS> setting make_arg should do it i think

[08:39] *** cognominal left
[08:41] *** flussence left
[08:41] *** cognominal joined
[08:41] *** flussence joined
[08:42] *** alim joined
[08:44] *** drbean left
[08:48] *** alim left
[08:51] *** drbean joined
[08:54] *** chra joined
[09:01] *** am0c left
[09:09] *** araujo left
[09:10] *** volkove left
[09:22] *** hundskatt joined
[09:37] *** dakkar joined
[09:39] *** mkramer joined
[09:44] *** birmjin left
[09:47] *** drbean left
[09:53] *** drbean joined
[10:02] *** bacek joined
[10:04] *** bacek left
[10:08] <moritz> nom: my $!x

[10:08] <p6eval> nom 92f383:  ( no output )

[10:08] <moritz> nom: class A { $!foo }

[10:08] <p6eval> nom 92f383: OUTPUT«===SORRY!===␤Attribute $!foo not declared in class A at line 1, near " }"␤»

[10:13] *** mkramer left
[10:15] *** mkramer joined
[10:15] *** kaare_ joined
[10:19] *** noidea left
[10:19] *** noidea joined
[10:25] *** mkramer left
[10:26] *** mkramer joined
[10:28] *** baest joined
[10:30] *** mkramer left
[10:31] <moritz> evalbot rebuild nom

[10:31] <p6eval> OK (started asynchronously)

[10:31] <moritz> evalbot rebuild nom

[10:31] <p6eval> NOT OK (maybe a rebuild is already in progress?)

[10:31] <dalek> rakudo/nom: 3504a85 | moritz++ | src/ (2 files):

[10:31] <dalek> rakudo/nom: throw a X::Attribute::Undeclared when encountering an undeclared attribute

[10:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3504a85c47

[10:32] <moritz> good, that mechanism still works

[10:39] *** snearch joined
[10:39] *** tokuhirom joined
[10:42] *** replore_ left
[10:45] *** snearch left
[10:45] *** snearch joined
[10:46] *** snearch left
[10:46] *** snearch joined
[10:48] *** mkramer1 joined
[10:52] *** mkramer1 left
[10:53] *** mkramer joined
[11:00] *** snearch left
[11:16] *** Mowah_ joined
[11:17] *** araujo joined
[11:17] *** araujo left
[11:17] *** araujo joined
[11:40] *** envi_ left
[11:40] *** lestrrat left
[11:41] *** lestrrat joined
[11:44] *** envi_ joined
[12:02] *** mkramer left
[12:05] *** mkramer joined
[12:08] *** tokuhirom left
[12:15] <colomon> moritz: do we have an Advent post plan for today?

[12:16] <jnthn> afternoon o/

[12:16] <colomon> \o

[12:19] * jnthn had to hide away this morning to get a $dayjob-task out of the way

[12:19] <jnthn> Hopefully I get at least some Perl 6 tuits later today.

[12:20] <colomon> \o/

[12:27] <moritz> colomon: not a plan yet; I might write about operator precedence

[12:29] <tadzik> I have a handful of time-tuits today, may write something

[12:29] *** packetknife joined
[12:29] *** packetknife left
[12:30] <moritz> tadzik: that would be nice too

[12:31] <tadzik> any wanted topic not yet taken?

[12:34] <moritz> NCI (though it might make sense to wait until jnthn++ does the array passing stuff)

[12:34] <tadzik> maybe advertising bailador a bit? :)

[12:34] <moritz> tadzik: sure

[12:34] <tadzik> okay

[12:35] <tadzik> the implementation is short enough to be explained statement by statement :)

[12:38] *** orafu left
[12:38] *** orafu joined
[12:47] <moritz> tadzik: should I add your topic to the schedule for today?

[12:48] *** grondilu joined
[12:49] <jnthn> +1 to a bailador post

[12:49] <tadzik> moritz: sure

[12:50] <dalek> mu: fbfd11d | moritz++ | misc/perl6advent-2011/ (2 files):

[12:50] <dalek> mu: update schedule and topics, tadzik++

[12:50] <dalek> mu: review: https://github.com/perl6/mu/commit/fbfd11d1f8

[12:52] *** baest left
[12:52] *** baest joined
[12:54] <tadzik> ok, doomed :P

[12:57] *** baest left
[13:01] *** baest joined
[13:03] *** baest_ joined
[13:06] *** baest left
[13:12] *** drbean left
[13:12] *** baest_ is now known as baest

[13:18] *** drbean joined
[13:22] *** Moukeddar joined
[13:26] *** hundskatt left
[13:36] *** mkramer left
[13:38] *** CoreX_ left
[13:39] *** mkramer joined
[13:39] *** mkramer left
[13:42] * [Coke] tries to remember why he quit #parrot.

[13:44] *** skangas joined
[13:44] *** Moukeddar left
[13:50] *** drbean left
[13:51] <[Coke]> "Why do Python classes have both _mro_ and mro() ? What was I thinking at the time? Does anyone remember?" -guido. mmhehehe.

[13:55] *** CoreX_ joined
[13:56] *** drbean joined
[14:03] *** benabik left
[14:05] *** wolfman2000 left
[14:06] <[Coke]> niecza: say 1 ** Inf;

[14:06] <p6eval> niecza v12-20-g049fd3d: OUTPUT«NaN␤»

[14:06] *** risou_awy is now known as risou

[14:06] <[Coke]> nom: say 1 ** Inf;

[14:06] <p6eval> nom 3504a8: OUTPUT«1␤»

[14:06] *** icwiener joined
[14:07] <colomon> [Coke]: is that in the spectest somewhere?

[14:08] <jnthn> nom: say 2 ** Inf

[14:08] <p6eval> nom 3504a8: OUTPUT«Inf␤»

[14:08] <jnthn> nom++

[14:08] <jnthn> well, (the folks who did numeric stuff in nom)++ :)

[14:08] <colomon> niecza: say 2 ** Inf

[14:08] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Infinity␤»

[14:08] <djanatyn> sorry I haven't been here for a while ^_^

[14:09] *** Mowah_ left
[14:09] <djanatyn> any interesting new perl6 tasks?

[14:10] <PerlJam> djanatyn: want to write an advent post on perl 6? :)

[14:11] <[Coke]> colomon: yes.

[14:11] <colomon> :)

[14:11] *** cosimo left
[14:11] <[Coke]> updating the comment to make it an issue instead of just "WTF"

[14:11] * colomon wishes he understood the issues enough to figure out which approach is better...

[14:12] <djanatyn> PerlJam: ooh! Sure.

[14:12] <djanatyn> Is that on the list?

[14:12] <colomon> djanatyn: not yet

[14:13] <djanatyn> ah, okay.

[14:14] <[Coke]> niecza: say 2«1.1*:2<10>**:2<10>»

[14:14] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 773 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 168 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/boot/li…

[14:16] <[Coke]> I give up, what's that supposed to do?

[14:16] <[Coke]> niecza: say 1.1*:2<10>**:2<10>

[14:16] <p6eval> niecza v12-20-g049fd3d: OUTPUT«22/5␤»

[14:17] <dalek> roast: f16c416 | coke++ | S32-num/power.t:

[14:17] <dalek> roast: niecza re-fudge with ticket.

[14:17] <dalek> roast: review: https://github.com/perl6/roast/commit/f16c41611f

[14:17] *** kaleem left
[14:24] <[Coke]> nom:say 2«1»

[14:24] <[Coke]> nom: say 2«1»

[14:24] <p6eval> nom 3504a8: OUTPUT«===SORRY!===␤Confused at line 1, near "say 2\x{ab}1\x{bb}"␤»

[14:24] <[Coke]> nom: say 2<<1>>

[14:25] <p6eval> nom 3504a8: OUTPUT«Method 'at_key' not found for invocant of class 'Int'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1145␤  in block <anon> at /tmp/PcqRX2cIXA:1␤  in <anon> at /tmp/PcqRX2cIXA:1␤»

[14:25] <colomon> [Coke]: I think you're forgetting the : before the 2 sometimes there?

[14:25] <colomon> nom: say :2<1>

[14:25] <p6eval> nom 3504a8: OUTPUT«1␤»

[14:25] <colomon> nom: say :2<1011>

[14:25] <p6eval> nom 3504a8: OUTPUT«11␤»

[14:26] <[Coke]> colomon: not me: t/spec/S02-literals/radix.t

[14:26] <[Coke]> Look for "WTF" - it's fudged for pugs, rakudo & niecza.

[14:26] *** icwiener left
[14:27] *** icwiener joined
[14:28] <moritz> std: :2«1.1*:2<10>**:2<10>»

[14:28] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed radix number at /tmp/CEw7JcKbH3 line 1:␤------> [32m:2[33m⏏[31m«1.1*:2<10>**:2<10>»[0m␤    expecting any of:␤  statement end␤  statement list␤Parse failed␤FAILED 00:01 118m␤»

[14:28] <moritz> std: :2«1.1»

[14:28] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed radix number at /tmp/KVtzBXidyD line 1:␤------> [32m:2[33m⏏[31m«1.1»[0m␤    expecting any of:␤ statement end␤  statement list␤Parse failed␤FAILED 00:01 118m␤»

[14:29] <moritz> std: :2<1.1>

[14:29] <p6eval> std be1f10e: OUTPUT«ok 00:01 118m␤»

[14:29] *** daxim joined
[14:29] <colomon> std: 2«1.1*:2<10>**:2<10>»

[14:29] <p6eval> std be1f10e: OUTPUT«ok 00:01 118m␤»

[14:29] <colomon> wonder what std thinks it means?!

[14:29] <moritz> colomon: it just parses it as 2.{'some text here}

[14:29] <moritz> as in %hash<some text here>

[14:30] * [Coke] hopes the test is removed so he doesn't have to create a niecza ticket. ;)

[14:30] <moritz> [Coke]: we can safely remove that test

[14:30] <colomon> :2«1.1*:2<10>**:2<10>»   is in the spec

[14:31] <colomon> 2«1.1*:2<10>**:2<10>» is not

[14:31] <moritz> well, std doesn't like it

[14:31] <moritz> it should be harmonized one way or another

[14:32] <colomon> as far as I'm concerned, the important part is that that test is wrong.  :)

[14:32] <moritz> (and I'm all for killing the feature; I don't see us winning anything by yet more crazy literals

[14:32] <colomon> +1

[14:33] <[Coke]> +1

[14:34] *** sftp joined
[14:34] <colomon> std: :2«101»

[14:34] <p6eval> std be1f10e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed radix number at /tmp/4WZRKMAomc line 1:␤------> [32m:2[33m⏏[31m«101»[0m␤    expecting any of:␤ statement end␤  statement list␤Parse failed␤FAILED 00:01 118m␤»

[14:35] <grondilu> test

[14:35] <yath> failed

[14:36] <grondilu> perl6: sub postfix:<²>($x) { $x * $x }; say $x²

[14:36] <colomon> moritz:  in particular, what kind of maniac would write :2«1.1*:2<10>**:2<10>»  when  :2<1.1> * :2<10> ** :2<10> is available to do the same thing?

[14:36] <p6eval> rakudo 3504a8: OUTPUT«===SORRY!===␤Variable $x is not predeclared at line 1, near "\x{b2}"␤»

[14:36] <p6eval> ..niecza v12-20-g049fd3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $x² is not predeclared at /tmp/2aK5n2ZNFH line 1:␤------> [32msub postfix:<²>($x) { $x * $x }; say [33m⏏[31m$x²[0m␤␤Potential difficulties:␤  &postfix:<²> is declared but not used at /tmp/2aK5n2ZNFH line 1:␤----…

[14:36] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\178'␤decodeUTF8': bad data: '\178'␤*** ␤    Unexpected end of input␤    expecting "::"␤    Variable "$x\194\178" requires predeclaration or explicit package name␤    at /tmp/Tk65aOTP2l line 1, column 41␤»

[14:37] <moritz> perl6: sub postfix:<²>($x) { $x * $x }; say 5²

[14:37] <p6eval> rakudo 3504a8: OUTPUT«25␤»

[14:37] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\178'␤decodeUTF8': bad data: '\178'␤25␤»

[14:37] <p6eval> ..niecza v12-20-g049fd3d: OUTPUT«Potential difficulties:␤  &postfix:<²> is declared but not used at /tmp/3Pfj2vYzh8 line 1:␤------> [32msub postfix:<²>[33m⏏[31m($x) { $x * $x }; say 5²[0m␤␤Unhandled exception: System.Exception: invalid digit in 5²␤  at Niecza.EmitUnit.ExactNum (Int32 …

[14:37] <grondilu> perl6: sub postfix:<²>($x) { $x * $x }; say 4²

[14:37] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Potential difficulties:␤  &postfix:<²> is declared but not used at /tmp/4pD2g5NFwt line 1:␤------> [32msub postfix:<²>[33m⏏[31m($x) { $x * $x }; say 4²[0m␤␤Unhandled exception: System.Exception: invalid digit in 4²␤  at Niecza.EmitUnit.ExactNum (Int32 …

[14:37] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\178'␤decodeUTF8': bad data: '\178'␤16␤»

[14:37] <p6eval> ..rakudo 3504a8: OUTPUT«16␤»

[14:37] <jnthn> std: sub postfix:<²>($x) { $x * $x }; say 5²

[14:37] <p6eval> std be1f10e: OUTPUT«ok 00:01 128m␤»

[14:38] *** icwiener left
[14:38] *** benabik joined
[14:38] <grondilu> Being able to define ² is really cool :)

[14:38] *** icwiener joined
[14:38] <moritz> colomon: probably somebody who wants guranteed execution at compile time

[14:43] *** kaleem joined
[14:45] <[Coke]> niecza: my @a = 1,2,3,4; say @a.=pick(*);

[14:45] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Unhandled exception: Cannot use value like Whatever as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 191 (Any.Numeric @ 4) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[14:45] <[Coke]> nom: my @a = 1,2,3,4; say @a.=pick(*);

[14:45] <p6eval> nom 3504a8: OUTPUT«2 1 4 3␤»

[14:47] *** am0c joined
[14:49] <colomon> [Coke]: I skipped the pick(*) bit when I did pick, because Whatever wasn't actually defined yet at that point in the setting.  Probably LHF, but definitely wrong atm.

[14:55] <[Coke]> colomon: there are a lot of skips in spectest for niecza about not being able to use <some type> as a number.

[14:55] <moritz> niecza: say +Cool

[14:56] <p6eval> niecza v12-20-g049fd3d: OUTPUT«0␤»

[14:56] <colomon> ?

[14:56] <[Coke]> I'll see if I can handle the Whatever ones.

[14:56] <[Coke]> niecza: say +Sub

[14:56] <p6eval> niecza v12-20-g049fd3d: OUTPUT«0␤»

[14:56] <colomon> [Coke]: something like MyType as a number?

[14:56] <[Coke]> moritz: presumably it's like the pick situation where it's an argument that is defined as a Numeric.

[14:57] <moritz> [Coke]: ah right, missing special cases

[14:57] <[Coke]> colomon: e.g. "Cannot use value like Block as a number"

[14:58] <colomon> eqv.t, eh?

[15:00] <colomon> Huh.  I don't think that's a number issue at all, is it?

[15:00] <colomon> niecza: my $a = { 3 }; my $b = { 3 }; say $a eqv $b

[15:00] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Unhandled exception: Cannot use value like Block as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 191 (Any.Numeric @ 4) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting l…

[15:00] <moritz> eqv should fall back to ===

[15:01] <colomon> yeah, it's an eqv bug

[15:01] <colomon> errr.. cmp bug, actually

[15:02] <colomon> sub infix:<eqv> is equiv<==> ($a, $b) { ($a cmp $b) == 0 }

[15:02] * colomon apparently picked a good morning to update his ack-in-textmate to search .setting files.  ;)

[15:03] <colomon> yeah, in niecza, if cmp can't figure out what to do it just tries subtracting the two arguments

[15:03] <[Coke]> colomon: if that's a simple fix, you might be able to get a few tests back.

[15:03] <[Coke]> I'm happy to do the unfudge work.

[15:04] <colomon> I dunno, I've no idea what the correct implementation is.

[15:04] <colomon> all I can say with authority is that the current implementation of cmp is really screwed up.

[15:06] *** grondilu left
[15:06] <colomon> right now, it does numeric comparison if both sides are numbers; that's right

[15:06] <colomon> then it does a string compare on the .WHATs if the .WHATs are not ===

[15:07] <colomon> does that make any sense to any of you?

[15:07] <colomon> then it does a string compare on the arguments if the first is a Str

[15:08] <colomon> and wow, cmp.t is nearly completely useless.  seems like it needs 100s more tests...

[15:08] <moritz> colomon: makes sense-ish

[15:10] <colomon> moritz: please explain, because I'm finding the spec here to be completely opaque

[15:11] *** koban left
[15:12] <moritz> colomon: I must confess I don't know how cmp works for non-Cool types

[15:12] <moritz> colomon: I just know how eqv works

[15:13] <moritz> and that checks type equality first, and then for value types compares equality, and uses === for everything else

[15:13] <moritz> but I wouldn't know how cmp works on two code blocks

[15:13] <moritz> but I'm pretty sure that eqv just returns False

[15:14] <moritz> so I'd rather dispatch-fail infix:<cmp>(Code, Code)

[15:14] <colomon> actually, you're wrong on eqv, according to roast

[15:15] <colomon> eqv.t, for instance, has ok ($a eqv $a), "eqv on sub references (1-1)";  

[15:15] <colomon> as well as ok ($a eqv $b), "eqv on sub references (1-3)";

[15:15] <colomon> the latter is todo'd for rakudo

[15:15] <moritz> I'm not really sure these tests are correct

[15:16] <colomon> gack, what a mess

[15:16] <moritz> are these blocks really equivalent?

[15:16] <colomon> hell if I know

[15:16] <moritz> I mean, they produce different line numbers in backtraces, for one

[15:16] *** wtw left
[15:17] <moritz> comparing two code blocks for equivalence could be turing complete

[15:19] <arnsholt> Isn't that actually halting-equivalent?

[15:19] <arnsholt> Or, I suppose that's what you meant

[15:19] <moritz> that's what I meant, yes

[15:19] <benabik> NP-Complete

[15:19] <colomon> not NP-Complete

[15:19] <moritz> benabik: harder than NP :-)

[15:20] <arnsholt> Undecidable, in fact

[15:22] <arnsholt> There's a theorem whose name I've forgotten that states that in the general case it's impossible to characterise any run-time property of a program simply by analysing the code

[15:22] <arnsholt> The halting problem is a specific instance

[15:24] <arnsholt> This is why virus scanners are so hard to make. They're impossible ^_^

[15:26] <colomon> hmmm, may have the start of a patch

[15:26] <benabik> Oh, yes.  Blah.  Say "complete" and jumped to NP.  Need coffee

[15:26] <benabik> *Saw

[15:28] <colomon> so, I've just modified niecza's infix:<eqv> to check to see if its arguments are infix:<===> first, and return true if === is true.

[15:28] <colomon> I believe that will get us back a lot of the skipped tests.

[15:29] <sorear> good * #perl6

[15:29] <colomon> but the ones which are todo'd for rakudo will need to be skipped for niecza, because it still gives you the 'Cannot use value like Block as a number' message if you compare two different blocks.

[15:30] <colomon> of course, if those tests are actually wrong anyway, as per moritz's argument...

[15:30] <moritz> well, not all of them are wrong :-)

[15:31] *** icwiener left
[15:32] <sorear> arnsholt: Rice

[15:32] <sorear> colomon: I have NFI how cmp is supposed to be implemented, but I do know what it is supposed to do

[15:33] <colomon> sorear: you're doing better than the rest of us, then.

[15:33] <sorear> colomon: per TimToady, $a cmp $b means, roughly, $a.perl leg $b.perl

[15:33] <moritz> urks

[15:33] <sorear> it defines a total order on the _value_ of two objects, deeply

[15:33] <colomon> WTF?

[15:33] <sorear> not using .perl per se

[15:34] <sorear> ([2,1] cmp [1,2]) > 0

[15:34] <dalek> roast: 5a51d4d | moritz++ | S03-operators/eqv.t:

[15:34] <dalek> roast: correct an eqv test

[15:34] <dalek> roast: review: https://github.com/perl6/roast/commit/5a51d4d2e5

[15:34] <colomon> right, so two arrays with the same values will be equal, correct?

[15:34] <moritz> colomon: yes

[15:35] <moritz> positionals compare as $a.elems == $b.elems && @$a >>eqv<< @$a

[15:36] <colomon> moritz: for eqv -- that won't work for cmp

[15:36] <colomon> but I take your point.

[15:36] <moritz> colomon: well, for cmp it still cmp's element by element

[15:37] <moritz> so something like [||] @$a >>cmp<< @$b, modulo handling the end

[15:37] <colomon> sorear: actually, so that's what the comparing WHATs is about?  the short version of comparing .perls for different types?

[15:37] <arnsholt> sorear: That's the one. Cheers!

[15:39] <colomon> sorear: perhaps it should literally do $a.perl leg $b.perl for the "we don't know what to do!" case?  Seems like that would be quite a bit more robust than the current $a - $b approach.

[15:39] <colomon> it being infix:<cmp>, I mean

[15:40] <moritz> but then Hash.perl would need to sort its output

[15:41] <colomon> or just define its own infix:<cmp>

[15:41] <moritz> or that, yes

[15:41] <colomon> or I suppose its own special case line in the general cmp implementation.  :)

[15:42] <moritz> I just hate the idea, because .perl is so very non-canonical

[15:42] <colomon> how is it supposed to compare, anyway?  sorting its keys?

[15:42] <moritz> you can make (1, 2, 3).perl produce   reverse(3, 2, 1)  if you want

[15:42] <colomon> you mean different implementations might compare differently

[15:42] <moritz> and if you leg-compare them, you'll get fubar

[15:43] <moritz> I mean that .perl is so very non-canonical that you shouldn't base any semantics on the exactly emitted form

[15:44] <colomon> First note that I'm not proposing this as a be-all, end-all solution.

[15:44] <colomon> I'm just trying to find something a little bit better than the current broken implementation.

[15:45] <moritz> nom: say { 3 } cmp { 5 }

[15:45] <p6eval> nom 3504a8: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu $v, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:638␤  in sub infix:<==> at src/gen/CORE.setting:2196␤  in sub infix:<cmp> at src/gen/CORE.setting:1163␤  in block <anon>…

[15:45] <moritz> that's broken too

[15:46] <colomon> yup

[15:46] *** baest left
[15:46] <sorear> colomon: I dislike using .perl for the same reasons moritz gives

[15:46] <moritz> I'd expect it to error out, because I can't think of a way to compare those two blocks

[15:47] <moritz> what about { 1 + 1 } cmp { 2 } ?

[15:47] <moritz> it's just futile to try to provide useful semantics, so I'd rather fail() or die()

[15:47] <colomon> moritz: we've already agreed its impossible to eqv two blocks.

[15:47] <sorear> colomon: I think the proper solution is something closer to sub infix:<cmp>($a,$b) { ($a.WHAT leg $b.WHAT) || $a.CMP($b) }

[15:47] *** ab5tract joined
[15:48] <moritz> colomon: but the approach with .perl tries exactly that

[15:48] *** thou joined
[15:48] <sorear> colomon: last time I discussed this with TimToady, there was talk of making 4e0 eqv 4, which aaaaa

[15:48] <moritz> sorear: nonono

[15:48] <moritz> sorear: there was a talk about introducing a looser comparison op

[15:49] <moritz> which would do that, and also compares List and Array with the same contents equally, etc.

[15:50] <colomon> moritz: no, the .perl approach just gets those answers wrong.

[15:50] * moritz prefers no answer to wrong answer

[15:53] <sorear> niecza's === is also quite under-implemented

[15:53] <colomon> perl6: my @a = 1, 2, 3; say @a eqv @a.map({ $_ })

[15:54] <p6eval> pugs b927740: OUTPUT«1␤»

[15:54] <p6eval> ..niecza v12-20-g049fd3d: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 775 (warn @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 169 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting …

[15:54] <p6eval> ..rakudo 3504a8: OUTPUT«Bool::False␤»

[15:54] <colomon> what's the correct answer there?

[15:54] <benabik> Once you allow values of different types to compare, things get… hazy.  I look forward to Perl6 getting it less wrong than everyone else.  :-D

[15:55] <moritz> colomon: false, because .map returns a List or a Parcel or so, not an Array

[15:56] <moritz> perl6: my @a = 1, 2, 3; say @a eqv @a.map({ $_ }).Array

[15:56] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Unhandled exception: Unable to resolve method Array in class List␤  at /tmp/T2Z13l_m4Q line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2226 (ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2227 (module-CORE @ 58) ␤  at /home…

[15:56] <p6eval> ..rakudo 3504a8: OUTPUT«Bool::True␤»

[15:56] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Array: "&Array"␤    at /tmp/glEt94qjbm line 1, column 22 - line 2, column 1␤»

[15:58] <[Coke]> https://gist.github.com/1472657 - colomon, sorear; if I try to reference Whatever in pick() (either here or creating a new multi), I get a similar error. Any suggestions?

[15:59] <colomon> [Coke]: the only thing I could think of was moving pick's implementation to the sub form of pick, and putting it after Whatever is defined.  But maybe sorear has a better suggestion.

[15:59] <moritz> in rakudo, you'd stub Whatever

[15:59] <moritz> my class Whatever { ... }  # with literal ...

[16:00] *** icwiener joined
[16:01] <colomon> ah, yes, looks like that's in niecza as well.  moritz++

[16:01] <colomon> [Coke]: look at the top of CORE.setting

[16:02] <sorear> question: if two unrelated classes have the same string name, what should cmp do?

[16:03] <sorear> my $a = (anon class Foo { }).new; my $b = (anon class Foo { }).new; say $a cmp $b;

[16:04] <jnthn> I highly doubt we could ever be comparing classes on the name.

[16:04] <jnthn> *should

[16:04] *** drbean left
[16:05] <colomon> should we have is antisymmetric as well as is symmetric?  

[16:06] <sorear> colomon: what does is symmetric do?

[16:07] <sorear> jnthn: We need some way to stably order classes

[16:07] *** molaf joined
[16:07] <jnthn> sorear: Hm. Memory address of the type object is fragile in the light of copying GCs.

[16:08] <colomon> sorear: my multi infix:<+>(Rat $r, Int $i) is symmetric also defines infix:<+>(Int $i, Rat $r) with the same body

[16:08] <colomon> Do we need to stably order classes?  Why not just have the cmp fail?

[16:08] <sorear> jnthn: I would just use MMD type cache IDs but that's not very stable across runs

[16:09] <jnthn> sorear: Yeah, I was gonna suggest that too

[16:09] <jnthn> sorear: It's stable in 6model if the runs are identical 

[16:09] <jnthn> sorear: Taht is, identical in the types they create and the order they do it in.

[16:09] <sorear> colomon: 1. eqv is defined in terms of cmp 2. AIUI, cmp falls back to cmping the classes if the classes are different

[16:09] <jnthn> *that

[16:09] <sorear> 1 cmp "foo" means Int cmp Str

[16:09] <colomon> sorear: in niecza eqv is defined in terms of cmp.  in the spec, it's the other way around

[16:10] <sorear> not so much AIUI as as I'm planning to do it

[16:10] <sorear> colomon: how do you define cmp using eqv?

[16:10] <sorear> seems rather impossible to me

[16:10] <colomon> defined in the "this is what it means" sense, not in the "is implemented in terms of" sense

[16:11] *** drbean joined
[16:11] <colomon> literally: "The cmp is just like the eqv above except..."

[16:11] <sorear> ah, yeah.

[16:11] <sorear> cmp is a more or less arbitrary total order consistant with eqv

[16:12] <colomon> well... that's the catch, right?

[16:13] <colomon> we've just been discussing how it can't be a total ordering

[16:13] <sorear> [Coke]: are you sure 1 ** Inf should be 1?  that's one of the classic indeterminate forms, along with Inf - Inf, 0 * Inf, 0 / 0, and 0 ** 0

[16:14] <sorear> colomon: it can be a total ordering on all types except Code, and even there it can be total if you're willing to lose extensionality.

[16:17] *** drbean left
[16:18] <colomon> there's also the 4e0 eqv 4 thing -- 4e0 cmp 4 should definitely be Order::Same

[16:18] <moritz> eqv returns True or False, not Order::*

[16:21] *** drbean joined
[16:21] <colomon> moritz: yes, but the point here is that "consistent with eqv" implies that if $a cmp $b is Order::Same, then $a eqv $b should be true.  (or at least, that's what I thought was meant by it...)

[16:21] <moritz> yes, I think that's what it means

[16:23] <sorear> 07:48 < sorear> colomon: last time I discussed this with TimToady, there was  talk of making 4e0 eqv 4, which aaaaa

[16:23] <sorear> 07:48 < moritz> sorear: nonono

[16:23] <sorear> 07:48 < moritz> sorear: there was a talk about introducing a looser comparison  op

[16:25] <colomon> right, that's why I was bringing it up in this context.

[16:27] <colomon> I'm trying to make sense of the relationship between cmp and eqv.  (At least in my own head.)

[16:27] <colomon> s/make sense of/understand/

[16:33] <colomon> hmm... I'm also not seeing why I shouldn't be able to meaningfully cmp a List and an Array -- doing an element-by-element by and ignoring the overall type.  (Whereas I can see not making them eqv.)

[16:34] *** kaleem left
[16:36] *** drbean left
[16:39] <colomon> https://gist.github.com/1472831 # random thoughts...

[16:39] *** kaleem joined
[16:40] *** tokuhirom joined
[16:43] *** drbean joined
[16:48] *** hrj joined
[16:49] <TimToady> a few more ideas: the roles are slightly off from what is wanted semantically

[16:49] <TimToady> we want the Real domain, the Unicode domain, not Numeric/Stringy

[16:50] *** hrj left
[16:51] <TimToady> and Positional is perhaps too restrictive, if Complex wants to be considered a list of two elements for ordering purposes

[16:51] <TimToady> hashes might be ordered on cardinality only

[16:52] <TimToady> though that doesn't fit with eqv meaning Order::Same

[16:53] *** mj41 left
[16:53] <TimToady> to do that would requiring ordering the keys and then using listy comparisons

[16:53] <TimToady> but Buf should be considered listy, not stringy

[16:53] <TimToady> not unicodey, really

[16:54] <TimToady> with the possible exception of a utf8 buf

[16:54] <benabik> Hashes are somewhat set like.  Sets can be equal or not, but usually aren't ordered.

[16:55] <TimToady> yes, but we've already committed to imposing an ordering on things like Complex that aren't conventionally considered ordered, just so they are sortable

[16:55] *** icwiener left
[16:56] <TimToady> and since <=> will fail on Complex, treating them as listy is what makes sense there

[16:56] <benabik> cmp is the "sort it somehow" ordering?

[16:57] <colomon> TimToady++

[16:58] <colomon> err.... wait, should <=> fail on Complex?  that strikes me as a slightly odd choice

[16:59] <benabik> colomon: There is no total order for Complex.

[16:59] <colomon> benabik: yes, I know that.  but I would think the logic which makes it want to work for cmp would also hold for <=>

[16:59] <TimToady> one thing cmp will not do is try to do natural sorting, since that intermixes the comparison domains

[17:00] <benabik> colomon: Personally, I'd want at least one notion of comparison that fails when it should.

[17:00] <TimToady> I'm thinking <=> should imply Real domain, and leg should imply Unicode

[17:00] *** cogno joined
[17:01] <TimToady> which is why I think the cmp categories should be those, not Numeric/Stringy

[17:02] <TimToady> I am also suspecting that, since we have MI and mixins, we need the ability for a type to choose which domain it wants to be compared in

[17:02] <colomon> +1 for choosing!

[17:03] <benabik> class Foo extends Real, Unicode is cmp(Real)?

[17:03] <colomon> is Unicode actually a p6 type now?

[17:04] <TimToady> well, it's supposed to be eventually, but Unicode is more like "is known to represent Unicode somehow or other"

[17:05] <TimToady> as for an actual type used for comparison, it's something like NFD

[17:06] <TimToady> comparison of two NFG characters probably compares the two NFD strings pointed to by that code point, unless the NFG codes are equal

[17:06] <colomon> I can certainly live with <=> implying Real.  not 100% sure I want Complex to sort as Positional-ish

[17:06] <TimToady> if NFG codes are equal, the NFC or NFD are implied equal

[17:07] <TimToady> you want it to blow up the rocket instead?

[17:07] *** MayDaniel joined
[17:07] <TimToady> I think this is somewhere where Perl wants to be failsoft

[17:08] <TimToady> most sorting of numbers is for human consumption, if you're using cmp

[17:08] <colomon> TimToady: I thought the goal was that comparing any two unrelated types would failsoft

[17:08] <TimToady> if you're trying to be type safe, you're probably using <=> anyway

[17:09] <colomon> cmp comparing, I mean.

[17:09] <TimToady> there are many conflicting goals that are possible with cmp :)

[17:09] <TimToady> it's all tradeoffs

[17:09] <TimToady> but we'd like it to failsoft that way, yes

[17:10] <TimToady> the question is whether there's any sense to sorting Complex in with the other scalar Real numbers

[17:10] <TimToady> that would imply sorting compound Numerics more like surreal numbers

[17:12] <colomon> my objection was more to the idea that [3 4] might equal 3+4i.  That seems weird and unexpected.

[17:12] <TimToady> well they aren't eqv because the types are not the same

[17:12] <TimToady> this is the point where cmp Same diverges from eqv

[17:13] <colomon> right, I'm all for cmp diverging from eqv.  :)

[17:13] <TimToady> cmp-Same just says throw 'em into the same bin

[17:13] <TimToady> cmp-Same must ignore types if we're to base it on domains

[17:13] <colomon> you know, I guess if you're crazy enough to compare [3 4] with 3+4i, they might as well cmp equal.  :)

[17:14] <colomon> it's a bit bizarre, but I can't see a downside

[17:14] <TimToady> it might be a feature :)

[17:14] <colomon> errr... though what happens if you compare [3 4] with 3?

[17:15] <TimToady> well, I've been thinking listy dominates in any case

[17:15] <colomon> so 3 is like [3]?

[17:15] <TimToady> that implies we also know where Nil fits into to listy comparisons in each domain

[17:16] <colomon> always first, right?  (he guessed...)

[17:16] <TimToady> for Unicode, obviously, but not so obvious for Real

[17:17] * TimToady can imagine vectors that want to assuming missing elements are 0

[17:17] <TimToady> but maybe that just falls out of declared defaults, if needed

[17:19] *** hrj joined
[17:19] *** cogno left
[17:19] *** cogno joined
[17:19] <TimToady> but overall, +1 to the idea of general comparison domains

[17:20] *** stepnem left
[17:20] <TimToady> biab &

[17:20] <colomon> and they're something like positionalish, Real, and Unicode?

[17:20] <colomon> and maybe hashish?

[17:23] *** stepnem joined
[17:24] <benabik> Setish?

[17:24] <colomon> I just like saying hashish.  ;)

[17:25] <colomon> or was that another suggestion?

[17:25] <colomon> (I mean, as another type)

[17:26] <benabik> Well, I was pondering based on my hashes are like sets comment earlier.  Although sets may cmp as positional…  *shrug*

[17:26] <benabik> And hashes may want to cmp values.

[17:27] <colomon> hashes are kind of like sets.... I guess if you define a set as being a hash with a value of true for everything, they're exactly the same.

[17:27] <colomon> https://gist.github.com/1472831 # now with a comment outlining my understanding of TimToady++'s suggestions, with additional input from benabik++

[17:28] <benabik> colomon: You can edit the gist directly and the history will be shown on the right.

[17:29] *** hrj left
[17:29] <colomon> benabik: yeah, I suppose I should have done it under the first attempt.  ah, well

[17:30] *** felipe left
[17:30] <colomon> fixed.  benabik++

[17:34] *** sayu joined
[17:38] *** jerome__ left
[17:41] *** cogno left
[17:44] *** cogno joined
[17:53] *** felipe joined
[17:58] *** risou is now known as risou_awy

[17:59] *** Chillance joined
[17:59] *** cogno left
[18:00] <tadzik> 'evening

[18:00] <colomon> o/

[18:00] <felher> o/

[18:00] <colomon> tadzik: Advent?

[18:01] <tadzik> yeah, working on it

[18:01] <tadzik> just got back home

[18:01] *** dakkar left
[18:01] <tadzik> I guess I missed 13th in some timezones? :)

[18:01] <colomon> doesn't worry me, it's still the 13th here.  :)

[18:02] <tadzik> okay :)

[18:03] *** risou_awy is now known as risou

[18:06] *** icwiener joined
[18:07] *** MayDaniel left
[18:10] *** ksi joined
[18:10] *** kaleem left
[18:13] <[Coke]> sorear: (1**Inf) Pulling from the roast test on that one, but 1**Inf==1 makes sense to me. More 1's aren't going to change the value

[18:14] *** thou left
[18:14] *** cogno joined
[18:15] <[Coke]> colomon: I know Whatever is defined at the top of the CORE setting there, aye. I still can't reference it at pick definition time.

[18:16] <colomon> [Coke]: oh.  bother.

[18:16] <[Coke]> oh!

[18:16] <[Coke]> No, it's defined below pick. my bad.

[18:20] <[Coke]> sorear,colomon: so, this solves my immediate problem:

[18:20] <[Coke]> http://feather.perl6.nl/~coke/pick.diff

[18:21] *** thou joined
[18:26] <colomon> [Coke]: oh!  That does seem like a pretty simple solution.

[18:26] <colomon> spectests okay?

[18:27] *** cogno left
[18:27] *** icwiener left
[18:27] <benabik> Isn't CORE.setting a generated file though?

[18:28] *** envi_ left
[18:28] *** icwiener joined
[18:28] <moritz> benabik: in rakudo yes, not in niecza

[18:29] *** localhost left
[18:29] *** GlitchMr joined
[18:29] <benabik> moritz: Oh.  :-[

[18:30] <[Coke]> colomon: running them now.

[18:30] <[Coke]> so much faster to put stuff in core in niecza to test. ;)

[18:31] *** localhost joined
[18:33] *** GlitchMr left
[18:37] *** tokuhirom left
[18:47] <colomon> though it does make for a pretty darned long file.  :)

[18:48] <tadzik> blog post preview: http://perl6advent.wordpress.com/?p=940&preview=true

[18:48] <tadzik> please review :)

[18:49] *** kaleem joined
[18:49] <jnthn> s/a simpliest/the simplest/

[18:50] <tadzik> sure, thanks

[18:52] <jnthn> tadzik++ # nice post :)

[18:52] <PerlJam> tadzik: in that last code snippet, I'd use ??!! rather than if..else  but other than that, it looks good to me.

[18:52] <PerlJam> tadzik++

[18:58] <tadzik> PerlJam: if $/ looks less magical and more obvious, but I don't mind changing it in the original Bailador codebase :)

[18:58] <tadzik> ok, publishing

[18:58] *** drbean left
[18:59] <tadzik> http://perl6advent.wordpress.com/2011/12/13/bailador-a-small-dancer-clone/

[19:03] <PerlJam> "looks less magical"?  I like my Perl6 to look magical  ;)

[19:04] *** drbean joined
[19:04] <colomon> tadzik++

[19:06] *** fridim_ joined
[19:09] *** sayu left
[19:10] *** kmwallio joined
[19:14] *** supernovus joined
[19:15] <supernovus> Okay, I am working on getting all of my modules working on nom. This is reminding me of the alpha to ng migration. I may have a few questions.

[19:16] <colomon> naturally!

[19:17] * colomon should get around to more migrating as well

[19:17] <tadzik> \o/

[19:17] *** kaleem left
[19:17] <supernovus> Question 1, say a method returns an array. Now say I use something like this: my @results = $object.method();   Previously, the @results would contain the array returned by the method. Now it appears the first element of @results contains the array returned by method()... is this an intentional change?

[19:18] <jnthn> supernovus: What exactly does the return statement look like?

[19:18] <jnthn> supernovus: That is, is it return @foo;, or return [1,2,3] ?

[19:19] <supernovus> jnthn: In this case it's 

[19:19] <supernovus> return %.types{$type}

[19:19] *** snearch joined
[19:19] <supernovus> where %.types contains arrays.

[19:19] <supernovus> Do I need to do a return @(%.types{$type}) instead?

[19:20] *** MayDaniel joined
[19:20] <jnthn> nom: class C { method m1 { [1,2,3] }; method m2 { my @a = 1,2,3 } }; my @x = C.m1; say @x.elems; my @y = C.m2; say @y.elems;

[19:20] <p6eval> nom 3504a8: OUTPUT«1␤3␤»

[19:21] <jnthn> supernovus: Yes, that will make it work

[19:21] <supernovus> jnthn: Yup, that worked. It's clearer too. Hurray!

[19:22] <sorear> good * #perl6

[19:22] <tadzik> hey sorear 

[19:22] <supernovus> hello sorear 

[19:22] <jnthn> o/ sorear 

[19:26] <TimToady> tadzik: s/simpliest/simplest/

[19:26] <sorear> [Coke]: lim x->Inf 1**x = 1, but lim x->1+ x**Inf = Inf and lim x->1- x**Inf = 0

[19:27] <sorear> [Coke]: the power function is discontinuous at (1,Inf) 

[19:27] <[Coke]> sorear: ah.

[19:27] <supernovus> I'll update the module status page as I get thing working. Mime::Types is now in the "working" list thanks to a single @() wrapper in a return statement :-D

[19:27] <[Coke]> sorear: any issues with my pick patch? gives us a few tests back.

[19:28] <jnthn> supernovus: Hope the rest are relatively painless.

[19:29] <sorear> and lim x->Inf (1 + 1/x) ** x = e :)

[19:29] <sorear> [Coke]: looks fine to me.

[19:29] *** icwiener left
[19:30] *** icwiener joined
[19:30] <dalek> niecza: 9548a6d | coke++ | lib/CORE.setting:

[19:30] <dalek> niecza: Support .pick(*)

[19:30] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9548a6da7d

[19:31] <supernovus> I think Exemel will be the toughest to debug, but one of the more important ones to get migrated. If anyone still uses XML these days that is ;-)

[19:31] <jnthn> No, the whole world already migrated to JSON. :)

[19:31] <jnthn> ;-)

[19:32] <supernovus> JSON++ :-)

[19:32] <[Coke]> niecza: my $result; for ^20 {my ($a,$b)=<AT CG>.pick.comb.pick(*); my ($c,$d)=sort map({6+4*sin($_/2)},($_,$_+4)); $result ~= sprintf "%{$c}s%{$d-$c}s\n",$a,$b}; say $result.chars();

[19:32] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Unhandled exception: Cannot use value like Whatever as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 191 (Any.Numeric @ 4) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[19:33] <[Coke]> oops. once the rebuild happens, that gives 170, but the test expects 169.

[19:34] <supernovus> Oh, and as far as I know, the "xml" library (not to be confused with the Exemel library) is abandoned. It hasn't worked since the 'alpha' branch.

[19:35] *** drbean left
[19:36] <sorear> colomon, TimToady: shouldn't 'cmp' somehow delegate to the object for unknown things?

[19:36] <[Coke]> nom: my $result; for ^20 {my ($a,$b)=<AT CG>.pick.comb.pick(*); my ($c,$d)=sort map({6+4*sin($_/2)},($_,$_+4)); $result ~= sprintf "%{$c}s%{$d-$c}s\n",$a,$b}; say $result.chars();

[19:36] <p6eval> nom 3504a8: OUTPUT«169␤»

[19:36] <sorear> colomon, TimToady: how does 'eqv' fit into that draft?

[19:37] <dalek> niecza: 09e2f5d | sorear++ | src/CClass.pm6:

[19:37] <dalek> niecza: Sync \h \v \s up with new spec

[19:37] <dalek> niecza: review: https://github.com/sorear/niecza/commit/09e2f5dd28

[19:37] <dalek> roast: 6873594 | coke++ | integration/advent2009-day1 (2 files):

[19:37] <dalek> roast: niecza unfudge

[19:37] <dalek> roast: review: https://github.com/perl6/roast/commit/6873594a25

[19:37] *** itz left
[19:41] *** drbean joined
[19:41] <[Coke]> nom: say (1, 2, 3, * Z+ 10, 20, 30, 40, 50)

[19:41] <p6eval> nom 3504a8: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu $v, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:638␤  in sub infix:<+> at src/gen/CORE.setting:2148␤  in sub <anon> at src/gen/CORE.setting:8520␤  in sub coro at src/ge…

[19:41] <[Coke]> niecza: say (1, 2, 3, * Z+ 10, 20, 30, 40, 50)

[19:41] <p6eval> niecza v12-20-g049fd3d: OUTPUT«Unhandled exception: Cannot use value like Whatever as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 191 (Any.Numeric @ 4) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[19:42] <colomon> sorear: my understanding of it was that you can always add another multi for cmp for your own types, if desired.

[19:42] <supernovus> Oh, the other thing I seem to get is errors like "Incorrect pre-compiled version of lib/HTTP/Easy.pm6 loaded".

[19:43] <colomon> sorear: and I would assume (based on today's conversations) eqv is stricter about type than cmp.

[19:43] <supernovus> replacing lib/HTTP/Easy.pm6 which whatever library you may have installed via a "ufo" generated makefile.

[19:46] <supernovus> Removing all .pir files from ~/.perl6/lib seems to work, but that seems counter-productive to the whole idea of pre-compiling modules.

[19:47] <jnthn> supernovus: If module A is pre-compiled against module B, then the versions must match up

[19:47] <jnthn> supernovus: Note that CORE.setting is also a module, so a fresh Rakudo build invalidates existing pre-compiled modules.

[19:48] <[Coke]> niecza: join(',', [Z+] [1, 2], [20, 10], [100, 200]).say

[19:48] <p6eval> niecza v12-20-g049fd3d: OUTPUT«6␤»

[19:48] <jnthn> Which is by design, but we really need to make this more transparent.

[19:49] *** itz joined
[19:49] <supernovus> jnthn: I recompile all of my modules right after recompiling rakudo. I'll play with this some more.

[19:49] <jnthn> supernovus: If you get some really odd behavior with it, I'd appreciate instructions on reproducing it.

[19:53] <supernovus> Okay, I'll let you know. I'm going to try recompiling them all now.

[19:56] <supernovus> Yeah, right off the bat, immediately after compiling the modules cleanly, I get "Incorrect pre-compiled version of lib/HTTP/Easy.pm6".  I'm going to remove all pir files and try compiling the modules one by one and see if it's only certain modules exhibiting this behavior.

[19:56] <jnthn> supernovus: Oh, one question. Does HTTP::Easy have dependencies?

[19:56] <jnthn> supernovus: If so, are they pre-compiled?

[19:57] <supernovus> Yes, it depends on HTTP::Status, which is also pre-compiled (before the compilation of HTTP::Easy).

[19:57] *** ggoebel left
[20:00] <supernovus> Okay, if I pre-compile HTTP::Status alone, the test works. Once I pre-compile HTTP::Easy, things fail. I'm going to try pre-compiling HTTP::Easy without pre-compiling HTTP::Status and see what happens.

[20:01] <supernovus> nope, still doesn't work

[20:01] *** bluescreen10 joined
[20:08] *** daxim left
[20:09] <jnthn> supernovus: OK, thanks for the info. I'll try and reproduce it here soon and see if I can figure out what's going on.

[20:10] *** ggoebel joined
[20:19] *** icwiener left
[20:21] <supernovus> I have tracked it down to the HTTP::Easy::PSGI library (which is a part of the HTTP::Easy distribution.) If I remove ~/.perl6/lib/HTTP/Easy/PSGI.pir and leave all the others, the test then runs.

[20:22] *** drbean left
[20:22] *** MayDaniel left
[20:23] *** donri joined
[20:28] *** drbean joined
[20:28] *** molaf left
[20:29] *** cooper joined
[20:29] *** icwiener joined
[20:30] <sorear> colomon: If a user wants to modify comparison behavior for their favorite class, they should not have to lexically override cmp - because lexical overrides to cmp cannot be made available to all _other_ modules

[20:32] <colomon> Err... it can be made available to .... crap, you're right, aren't you?  

[20:32] <colomon> what were you saying about $a.CMP($b)?

[20:33] <sorear> lift is an incomplete solution, I feel

[20:33] <tadzik> TimToady: thanks, fixing

[20:33] <sorear> colomon: yes, I was proposing $a.CMP($b), mostly because that's what Java, C#, and Perl 5 do

[20:34] <colomon> I'm still inclined to think p6 is broken if lift isn't the default.  but I don't seem to ever win that debate.

[20:41] *** icwiener left
[20:41] *** icwiener joined
[20:42] <sorear> colomon: please elaborate

[20:42] <sorear> colomon: I agree with you that statement_prefix:lift is broken by design

[20:43] <colomon> my particular problem comes with issues just like this one.

[20:43] <benabik> lift?

[20:43] <colomon> part of the philosophy of p6 is that operators have a single meaning, which might get distributed across different classes.  ie infix:<+> is always addition.

[20:45] <sorear> The Perl 6 MMD system is a shattered-mirror image of CLOS's system; AIUI in CLOS multis have no scope

[20:45] <sorear> they are visible everywhere the corresponding proto is

[20:45] <colomon> that means it's very, very natural to write code which will work for any objects that can do infix:<+>

[20:46] *** hrj joined
[20:46] <colomon> having the limitation that you can only use infix:<+>s you have already seen when you write the code completely shatters that

[20:46] <sorear> however jnthn gets very touchy when I so much as suggest that MMD needs to be changed

[20:46] <PerlJam> sorear: it's just that he's thinking of all the work he put into the existing system  :)

[20:46] *** hrj left
[20:47] <sorear> colomon: agree completely

[20:47] <jnthn> *systems*

[20:47] *** hrj joined
[20:47] *** raiph joined
[20:47] <PerlJam> sorry.  systems.

[20:47] *** tokuhirom joined
[20:47] <PerlJam> you've built one to throw away and you've built your "second system",  what are you at now? :)

[20:48] <jnthn> A major difference with CLOS and Perl 6 is that the Perl 6 multi-dispatch approach doesn't favor any particular parameter.

[20:48] <jnthn> Whereas CLOS favors leftmost first.

[20:48] *** cosimo joined
[20:49] <TimToady> operators are defined by the current language, and that will always be lexically scoped in Perl 6

[20:49] <colomon> sorear: it's interesting, because I feel that for most subs, I'm completely okay with the way it works now.  but for operators I always want the most specific version of the operator out there.

[20:50] <TimToady> it's fine if those operators default/failover to single dispatch, but that's still part of the def of the current language

[20:50] <TimToady> if you want to import operators, import 'em

[20:50] <TimToady> we're not going to play the One Language to Rule Them All game

[20:51] <TimToady> not unless you say 'use My_Perfect_Language;' first :)

[20:52] * jnthn wonders if lift can is somewhat do-able as "import CALLER::<< &infix:<+> >>", or something

[20:52] <TimToady> global mmd is just another way for magical action at a distance to wipe you out

[20:52] <TimToady> delegating semantics to objects is the province of the single dispatcher, not the operators

[20:53] <jnthn> +1 on lexically scoped MMD. That's why we have a good shot at compile time decisions and thus inlining.

[20:53] <jnthn> Amongst all of the other issues TimToady++ points out :)

[20:53] <TimToady> if it results in the occasional can't-get-there-from-here problem, maybe you don't want to go there anyway...

[20:53] <colomon> nom: sub foo($a, $b) { lift $a + $b }; say foo(10, 11)

[20:53] <p6eval> nom 3504a8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&lift' called (line 1)␤»

[20:54] <colomon> maybe I'd feel better about it all if lift actually existed...

[20:54] <colomon> niecza: sub foo($a, $b) { lift $a + $b }; say foo(10, 11)

[20:54] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method statement_prefix:lift not yet implemented at /tmp/teADDtOyCP line 1:␤------> [32msub foo($a, $b) { lift $a + $b [33m⏏[31m}; say foo(10, 11)[0m␤␤Unhandled exception: Unable to resolve method statement_level …

[20:54] <jnthn> Does lift simply replace the definition of + with the caller's one?

[20:55] <jnthn> (for the scope of the lift)

[20:56] <jnthn> ah, yes, S03 makes it seem so

[20:56] <TimToady> it's kind of a chintzy macro

[20:57] <jnthn> *nod*

[20:57] <sorear> TimToady: I fail to see why delegation of semantics to objects must always use single dispatch.

[20:57] * jnthn wonders how to preserve enough info about the presence of lift, or the transformation that it did, to make sure that when something that lifts gets inlined it just ends up back as a totally normal lexical dispatch again.

[20:58] <sorear> jnthn: +1 to keeping lexically scoped MMD, possibly even by default.  I am currently campaigning to provide multiple-delegation functionality

[21:00] *** wolfman2000 joined
[21:01] *** kmwallio left
[21:02] <TimToady> "How do we determine the winner?" ~~ "What language am I in?"

[21:03] <TimToady> you can't have any kind of complicated voting without a constitution of some sort

[21:03] <TimToady> and constitutions are "lexically" scoped by polity

[21:04] <TimToady> there is no reason you can't define such a dispatcher in P6, but the use of it will be lexically scoped

[21:06] <sorear> I see.

[21:06] *** snearch left
[21:07] <TimToady> "No accidental genericity" is bedrock to Perl 6.

[21:16] *** mj41 joined
[21:19] <colomon> I don't suppose we could at least get a "use lift" to lift an entire module at once?

[21:20] <sorear> colomon: that doesn't make a whole lot of sense, I think?

[21:20] <sorear> another problem with lift is the need to qualify _what_ is lifted

[21:20] *** am0c left
[21:21] <colomon> I'm assuming it would mean something like "lift every block".  But maybe that's worse than I was thinking...

[21:21] <sorear> colomon: the current spec for lift says that everything not in the immediately surrounding scope is lifted

[21:22] <sorear> so, imagine 'use lift; sub foo($x) { $x }; sub bar($x) { foo($x) }'

[21:22] <sorear> in bar(), 'foo' is lifted ($x is not)

[21:22] <sorear> now, if bar() is called from a scope with no foo... boom

[21:22] *** drbean left
[21:23] <colomon> ah, ick

[21:23] <benabik> Would `sub bar($x) { lift foo($x) }` do the same?

[21:23] <sorear> Yes.

[21:23] * sorear doesn't like lift much

[21:23] *** kaare_ left
[21:25] * colomon is really wishing someone would implement lift, so he could code with it and find out what it is like in practice.

[21:25] <benabik> It seems simultaneously very useful and very painful.

[21:27] *** bluescreen10 left
[21:27] <benabik> Is there an inverse of that?  Instead of "everything in {} is from CALLER", is there something that says "I want to use X, Y, and Z from CALLER"?

[21:29] *** drbean joined
[21:32] <supernovus> Hmm, now there's a bit of a change. Using say or print on an object used to call the Str() method if it existed, now it does not appear to do so. So any calls like: say $object; now need to be say "$object";  Not a biggy, but it certainly was a bit of a head scratcher. :-)

[21:33] <benabik> supernovus: It now calls .gist

[21:33] *** tokuhirom3 left
[21:33] *** molaf joined
[21:34] <supernovus> Ah, and none of the Exemel classes have a .gist method. It just kinda locked up solid. Nice to know :-)

[21:35] *** thou left
[21:35] <supernovus> So, Str() is for when you want a string representation, perl() is for when you want something that can be evaled back into the object in question, and gist() is a friendly description of the object?

[21:35] <benabik> Yes.

[21:36] <supernovus> Awesome! :-)

[21:39] <sorear> example:

[21:39] <sorear> perl6: say 1..*

[21:39] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«1..Infinity␤»

[21:39] <p6eval> ..pugs b927740: OUTPUT«Stack space overflow: current size 8388608 bytes.␤Use `+RTS -Ksize -RTS' to increase it.␤»

[21:39] <p6eval> ..rakudo 3504a8: OUTPUT«1..Inf␤»

[21:40] <benabik> perl6: print 1..*; say

[21:40] <benabik> That wasn't nice of me.  :-D

[21:40] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/OL73xYQXd2 line 1 (EOF):␤------> [32mprint 1..*; say[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check …

[21:40] <p6eval> ..pugs b927740: OUTPUT«Stack space overflow: current size 8388608 bytes.␤Use `+RTS -Ksize -RTS' to increase it.␤»

[21:40] <p6eval> ..rakudo 3504a8: OUTPUT«(timeout)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211…

[21:41] <benabik> niecza: print 1..*, "\n"

[21:41] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«1..Infinity␤»

[21:41] <benabik> Hm.

[21:41] <benabik> niecza: say (1..*).Str

[21:41] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«1..Infinity␤»

[21:41] <worr> how much of the perl6 spec does pugs support?

[21:43] <noidea> Which interpreter is prefered? 

[21:43] <worr> rakudo and niecza are being actively developed

[21:44] <worr> I don't think pugs has anyone working on it

[21:44] <noidea> pugs isnt? I know its written in haskell and thats about it

[21:44] <noidea> aj

[21:44] <noidea> ah*

[21:44] <benabik> There have been some motions towards updating pugs, but they haven't gotten very far yet.

[21:45] <worr> does pugs support the complete spec? I know it was the first implementation

[21:45] <sorear> The Perl 6 spec has changed a great deal since pugs was developed.

[21:48] *** cooper left
[21:49] *** tokuhirom left
[21:52] <moritz> and it was never complete either

[21:53] *** cooper joined
[21:54] <colomon> nom: given "Hello" { when /e(\w\w)/ { say $0; }; };

[21:54] <p6eval> nom 3504a8: OUTPUT«Nil␤»

[21:54] <colomon> niecza: given "Hello" { when /e(\w\w)/ { say $0; }; };

[21:54] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«#<match from(2) to(4) text(ll) pos([].list) named({}.hash)>␤»

[21:54] <colomon> nom bug?

[21:55] *** drbean left
[21:55] <jnthn> colomon: yeah, and in RT

[21:56] <jnthn> I thought a previous fix I did had taken care of it, but evidently not :(

[21:56] <colomon> is there a work around?

[21:58] <colomon> it's stupid, but this is in one of my $work p6 scripts...

[21:58] <colomon> ps... does qqx work yet in nom?

[21:58] <supernovus> Okay, so the XML grammar has things like:  regex comment { '<--' <content> '-->' }  token content { .*? }  which worked in ng, but is not matching in nom. Any suggestions for a replacement (I'm guessing it's the "content" bit that isn't liked anymore.)

[21:59] <jnthn> colomon: Hm, can't think of a workaround. I do have a couple of tuits in a moment though...

[22:00] <colomon> qqx does appear to work, \o/

[22:02] *** drbean joined
[22:05] *** mj41 left
[22:06] <sorear> worr: I would not say that any implementation has ever implemented more than 40% of the spec

[22:07] <sorear> supernovus: combine the two

[22:08] <sorear> supernovus: backtracking into subrules is NYI (and I suspect that in this case it shouldn't work, because of :ratchet)

[22:08] <moritz> .*? overrides :ratchet, no?

[22:09] <supernovus> I had been using <content> rules in a few places, I'm looking at replacing it with regex comment { '<--' $<content>=[.*?] '-->' }  instead.

[22:09] <sorear> perl6: note 5;

[22:09] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&note"␤    at /tmp/dmhPAL_qhZ line 1, column 1-7␤»

[22:09] <p6eval> ..rakudo 3504a8, niecza v12-22-g09e2f5d: OUTPUT«5␤»

[22:10] <sorear> rakudo: note 1..5;

[22:10] <p6eval> rakudo 3504a8: OUTPUT«1..5␤»

[22:10] <supernovus> woot, that seems to work!

[22:10] <sorear> supernovus: $<content>=(.*?), however, won't work

[22:10] <sorear> because (.*?) is treated more like a subrule than [.*?] is

[22:11] <supernovus> Yeah, that's why I picked [.*?] instead. :-)

[22:12] <supernovus> Basically, the only part I'm interested in is the content of the comment as a string. I'm not even sure people care about being able to preserve comments in XML documents, so the next version may have a "strip-comments" option.

[22:15] <dalek> niecza: b0f1579 | sorear++ | lib/CORE.setting:

[22:15] <dalek> niecza: CORE::print should not have been using gist

[22:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b0f15791b4

[22:16] *** ksi left
[22:17] *** drbean left
[22:19] <jnthn> colomon: testing a patch for the when nombug now.

[22:19] <colomon> jnthn++

[22:23] *** drbean joined
[22:23] <jnthn> In theory, my tuits for the weekend will be decent, since my last major $dayjob task will be over by Friday. 

[22:25] <sorear> niecza: say "foo\d"

[22:25] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unrecognized backslash sequence: '\d' at /tmp/F70B9CEwpD line 1:␤------> [32msay "foo\d[33m⏏[31m"[0m␤␤Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 773 (warn @ 2) ␤  at …

[22:27] *** hrj left
[22:27] <dalek> rakudo/nom: ad9e72c | jnthn++ | src/Perl6/Actions.pm:

[22:27] <dalek> rakudo/nom: Fix when, so $/ will be properly set.

[22:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad9e72cdd0

[22:28] <jnthn> colomon: ^^

[22:28] <jnthn> Tagged the related ST as testneeded also.

[22:32] <japhb> [Coke], moritz, colomon: re: http://irclog.perlgeek.de/perl6/2011-12-13#i_4827767 , note that the str-numeric branch already has that syntax working; see http://irclog.perlgeek.de/perl6/2011-12-05#i_4794000 for an example.  It just can't be merged into nom until Failure handling is resolved, otherwise the new implementation will trigger spec failures in tests that expect soft-fails and whatnot.

[22:32] <colomon> jnthn++

[22:32] <jnthn> japhb: Was it you who had the curious "failure doesn't throw properly" issue?

[22:33] <japhb> jnthn, ISTR I was one of those, yes.

[22:33] <jnthn> japhb: ah...was just going ot have a quick look at it, but I don't see an RT for it...I'm guessing it didn't make it there.

[22:33] <jnthn> japhb: Don't suppose you remember how to make it happen? :)

[22:33] <japhb> Last I left the discussion of Failure with sorear++, we had found some common ground for agreement about Failure(), but had more discussion to go to reach consensus.

[22:34] <japhb> jnthn, I'll see if I can find it for you.  (I've had my head in other stuff for a week)

[22:35] *** drbean left
[22:36] *** hundskatt joined
[22:36] <dalek> niecza: b273daf | sorear++ | / (2 files):

[22:36] <dalek> niecza: Allow \n ^^ $$ to match any vertical whitespace, including CRLF as a unit

[22:36] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b273dafb2b

[22:37] <colomon> jnthn: any feelings on where a test for the given when $/ bug should go?

[22:39] <jnthn> colomon: Well, the bug was with the implementation of when...

[22:41] *** drbean joined
[22:41] *** envi_ joined
[22:43] *** syslq left
[22:44] *** wolfman2000 left
[22:44] <japhb> jnthn, Were you referring to this one: http://irclog.perlgeek.de/perl6/2011-12-04#i_4792222  (note that you golf that a lot farther down)

[22:45] *** icwiener left
[22:45] *** icwiener joined
[22:46] <Tene> japhb: can you explain your assertion that people shoudl be able to call fail in mainline code to bind failure objects?

[22:46] <Tene> as specced, fail *returns* a failure.

[22:46] <jnthn> nom: sub foo() { fail "boo" }; my $val = foo(); try { ~$val }; try { ~$val; }; say "ok"

[22:46] <p6eval> nom 3504a8: OUTPUT«boo␤  in sub foo at /tmp/uN1YojTyEu:1␤  in block <anon> at /tmp/uN1YojTyEu:1␤  in <anon> at /tmp/uN1YojTyEu:1␤»

[22:46] <jnthn> ok, that's a valid program that does it.

[22:47] * jnthn tries the fix mls_++ suggested

[22:51] <dalek> niecza: 758356b | sorear++ | src/niecza:

[22:51] <dalek> niecza: Fix compilation of CORE::infix:<*>(3, 3) (Radvendii)

[22:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/758356b730

[22:51] <japhb> Tene: I don't really object if fail() itself doesn't work in the mainline (though I think "idioms that work in one place and not another without an obvious reason why it can't be made to work" is a smell), as long as there is *some* way to bind a properly intialized Failure object in the mainline.

[22:53] <Tene> nom: my $x = Failure.new(); try { ~$x }; say "Foo: $!"

[22:53] <p6eval> nom 3504a8: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at src/gen/CORE.setting:6839␤  in block <anon> at /tmp/Jqs0P8Tx1s:1␤  in <anon> at /tmp/Jqs0P8Tx1s:1␤»

[22:53] <Tene> nom: my $x = Failure.new("wtf"); try { ~$x }; say "Foo: $!"

[22:53] <p6eval> nom 3504a8: OUTPUT«Foo: Method 'rethrow' not found for invocant of class 'Str'␤»

[22:53] <Tene> oh, right, it should have an exception in there.

[22:53] <dalek> roast: 5913dd5 | sorear++ | S02-names/pseudo.t:

[22:53] <dalek> roast: [S02-names/pseudo] Unfudge for niecza

[22:53] <dalek> roast: review: https://github.com/perl6/roast/commit/5913dd554c

[22:54] <Tene> anyway, $x = fail() is equivalent to $x = return(), and would ideally be caught as invalid by the compiler.

[22:54] <japhb> Tene, I should also point out that my examples were in the mainline mostly because I was golfing down from something much bigger and had forgotten that removing the last layer of surrounding Routine would make a difference.

[22:55] <japhb> None of which negates the fact that I did actually stumble across a real bug.  ;-)

[22:55] <Tene> japhb: I was specifically responding to "Because someone *should* be able to do what I did in mainline code", perhaps I misunderstood "what I did"

[22:55] <Tene> two bugs, really.  Anything happening after fail() is also a bug.

[22:56] <Tene> nom: sub foo { fail("wtf"); say "lol ohai" }; my $x = foo(); try { ~$x }; say "Foo: $!"

[22:56] <p6eval> nom 3504a8: OUTPUT«Foo: wtf␤»

[22:56] <dalek> rakudo/nom: 32dc1ed | jnthn++ | src/core/Failure.pm:

[22:56] <dalek> rakudo/nom: Fix double-stringification of Failure causing death bug; fix suggested by mls++.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32dc1edea1

[22:56] <japhb> .oO( Is there an emoticon for "bowing in acknowledgement"? )

[22:56] <jnthn> orz

[22:57] <japhb> What an odd emoticon.  

[22:57] <jnthn> Well, maybe that's a bit more than acknowledgement :)

[22:57] <japhb> heh

[22:57] <jnthn> It does look like somebody bowing though :)

[22:57] <japhb> I kindof meant at about the level of "touche"

[22:57] <jnthn> oh :)

[22:58] <supernovus> This is going to drive me insane. It recognizes elements with no attributes, and elements with a single attribute, but if you put more than one attribute, it says there are none... I'm wondering how much the previous grammar was relying on "misfeatures"... uhg!

[22:58] <Tene> jnthn: any ideas about what fail in mainline is doing there?

[22:58] <sorear> niecza: my $x; say ~($x++)

[22:58] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 781 (warn @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 169 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/ZIk2JQa_cw line 1 (mainline @ 1)…

[22:59] <Tene> nom: use fatal; say 1; fail(2); say 3;

[22:59] <p6eval> nom ad9e72: OUTPUT«1␤2␤  in block <anon> at /tmp/GKi_5TLH82:1␤  in <anon> at /tmp/GKi_5TLH82:1␤»

[22:59] <sorear> perl6: my $x; say $x++

[22:59] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«Any()␤»

[22:59] <p6eval> ..pugs b927740, rakudo ad9e72: OUTPUT«0␤»

[23:00] <japhb> Oooh, sneaky

[23:00] <sorear> perl6: my $x; say $x--

[23:00] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«Any()␤»

[23:00] <p6eval> ..rakudo ad9e72: OUTPUT«0␤»

[23:00] <p6eval> ..pugs b927740: OUTPUT«␤»

[23:00] <sorear> perl6: my $x = Bool; say $x++

[23:01] <p6eval> niecza v12-22-g09e2f5d: OUTPUT«Bool()␤»

[23:01] <p6eval> ..pugs b927740, rakudo ad9e72: OUTPUT«0␤»

[23:01] * japhb is boggled by how few characters it takes, time and time again, in order to come across something important that merits discussion

[23:02] <jnthn> Tene: Throwing something that something else considers resumable, I guess.

[23:02] <Tene> Hmm, could be...

[23:06] *** PacoLinux left
[23:06] <japhb> TimToady, ping

[23:08] <japhb> Is there some place that we can submit/track "questions that require a ruling by $Larry"?

[23:09] <dalek> niecza: 8114adc | sorear++ | lib/Builtins.cs:

[23:09] <dalek> niecza: $x++ should never return undef (fixes #81)

[23:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8114adc115

[23:09] <dalek> roast: 10cc21e | sorear++ | S04-statements/for.t:

[23:09] <dalek> roast: [S04-statements/for] Unfudge for Unfudges for sorear/niecza#81

[23:09] <dalek> roast: review: https://github.com/perl6/roast/commit/10cc21e804

[23:10] <sorear> japhb: pm.txt was the old way.  I think now we file tickets against specs?

[23:10] *** thou joined
[23:12] <japhb> sorear, ah, github issue against perl6/specs, yes?

[23:12] <sorear> ues

[23:13] <sorear> rakudo: say i > 1

[23:13] <p6eval> rakudo ad9e72: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&i' called (line 1)␤»

[23:13] <sorear> rakudo: say 5i > 1

[23:13] <p6eval> rakudo ad9e72: OUTPUT«No applicable candidates found to dispatch to for 'Real'. Available candidates are:␤:(Mu $v, Mu %_)␤␤  in method Real at src/gen/CORE.setting:646␤  in sub infix:<>> at src/gen/CORE.setting:2212␤  in sub infix:<>> at src/gen/CORE.setting:2212␤  in block <anon> at /t…

[23:17] <dalek> niecza: 358e1f9 | sorear++ | lib/Builtins.cs:

[23:17] <dalek> niecza: Disallow numeric comparison on Complex (fixes #79)

[23:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/358e1f91f0

[23:17] *** rjbs joined
[23:17] <rjbs> Accidentally did /join #perl5, was shocked to learn that it *is* dead!

[23:17] <phenny> rjbs: 05 Dec 15:12Z <[Coke]> ask rjbs if we can get a perl5 advent calendar RSS feed that will show all years, not just the current year.

[23:17] <rjbs> [Coke]: perladvent.org/RSS.xml (although not actually RSS) will work "forever"

[23:18] <dalek> roast: 73505a2 | sorear++ | S32-num/complex.t:

[23:18] <dalek> roast: [S32-num/complex] Unfudge for sorear/niecza#79

[23:18] <dalek> roast: review: https://github.com/perl6/roast/commit/73505a2f4f

[23:18] <sorear> hello rjbs

[23:18] *** hundskatt left
[23:18] <rjbs> [Coke]: I need to update the Feed link to point to that, in the page header, but they point to the same resource.  Fixign the pointer will require WWW::AdventCalendar tweaking that I have not prioritized.

[23:18] <rjbs> sorear: Hi!

[23:18] <dalek> rakudo/nom: 483b3fc | jnthn++ | docs/ROADMAP:

[23:18] <dalek> rakudo/nom: Take a crack at getting us a ROADMAP that isn't over a year out of date. Patches welcome - this sure won't be perfect.

[23:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/483b3fc2cf

[23:19] <rjbs> Is there any support for grammars that can be used for productions?

[23:20] <sorear> rjbs: What do you mean?

[23:21] <supernovus> I am finding grammars to be very buggy at the moment. :(

[23:21] <rjbs> sorear: Please forgive the following extremely pseudo code...

[23:22] <rjbs> TOP { noun verb }  noun { "The cow" | "The farmer" | "The pig" } verb { "eats" | "plays" | "works" | "bathes" }

[23:22] <jnthn> rjbs: Did you see http://perl6advent.wordpress.com/2011/12/12/exploratory-parsing-with-perl-6/ ?

[23:22] <rjbs> sorear: while grammar.next_possible_valid_string -> x { ... }

[23:22] <rjbs> jnthn: No, I'm not caught up.  Looking.

[23:23] <sorear> rjbs: The functionality exists but I'm not aware of a standard API for it

[23:23] <rjbs> jnthn: This doesn't seem on topic.

[23:23] <sorear> rjbs: oh, wait, you mean _generating_ strings?

[23:23] <rjbs> Yes.

[23:24] <jnthn> Oh, *generating*.

[23:24] <jnthn> Ok, then it's not on topic :)

[23:24] * jnthn misunderstood

[23:24] <tadzik> jnthn: how is "2 **    inlining of method calls" different from "2 ***   method call inlining"? :)

[23:24] <sorear> rjbs: That's... not something Perl 6 grammars will do

[23:24] <rjbs> sorear: Okay.  I will use something else.  Thanks. :)

[23:25] <jnthn> tadzik: er, I know what I menat :)

[23:25] <tadzik> okay :)

[23:26] <jnthn> tadzik: tried to clarify it :)

[23:26] <jnthn> That was crappy wording

[23:26] <dalek> rakudo/nom: 81a1031 | jnthn++ | docs/ROADMAP:

[23:26] <dalek> rakudo/nom: Attempt a clarification (tadzik++).

[23:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/81a10312ee

[23:27] <sorear> I'm now breaking S05-grammar/protoregex.t for Rakudo

[23:28] *** birmjin joined
[23:28] <tadzik> okay, that looks clearer :)

[23:28] <tadzik> good night #perl6

[23:29] <japhb> o/

[23:29] <colomon> \o

[23:29] <jnthn> sorear: How so?

[23:29] <jnthn> sorear: And if you know you are, why not add #?rakudo 'skip' for the tests you're adding? :)

[23:29] <sorear> jnthn: updating it to use proto token foo {*} syntax

[23:30] <jnthn> sorear: oh, +1...

[23:30] <jnthn> ...but...I thought Rakudo supported that already. :)

[23:30] <jnthn> nom: grammar Foo { proto token bar {*} }

[23:30] <sorear> rakudo: grammar G { proto token foo {*} }

[23:30] <p6eval> nom 483b3f:  ( no output )

[23:30] <p6eval> rakudo 483b3f:  ( no output )

[23:30] <sorear> I guess I'm not breaking it, then.

[23:30] <jnthn> :)

[23:30] <jnthn> I'll toss the older syntax at some point.

[23:31] <colomon> jnthn: looks like my $work script works now. \o/ I think this means I'll switch my system's perl6 to nom.

[23:31] <jnthn> well, or make it warn :)

[23:31] <jnthn> and then toss it a bit after

[23:31] <jnthn> colomon: \o/

[23:32] *** rjbs left
[23:33] <japhb> Where in the ROADMAP would I put each of: Str.Numeric, val(), MAIN, Failure changes?

[23:33] <slavik1> japhb: what's the b for?

[23:34] <japhb> In my name?

[23:34] <japhb> er nick?

[23:35] <slavik1> yes

[23:35] <jnthn> japhb: MAIN and Failure can go under langauge features, the other two under built-ins. Though it's hazy. I was trying to draw out "stuff that needs work in CORE.setting" (e.g. the builtins) vs "stuff that'll need wider changes or compiler work"

[23:35] <japhb> OK, that makes sense

[23:36] <japhb> slavik1, My old nick was 'geoffb', but that caused nick collisions on FreeNode.  So, since I'm a Perl guy and don't mind a pun, I changed it to 'japhb'.

[23:37] <slavik1> I see

[23:37] <slavik1> ok

[23:40] <jnthn> Time for some rest. night o/

[23:42] <japhb> o/

[23:42] *** Chillance left
[23:42] <supernovus> In a grammar a rule like { <subrule1> <subrule2>* } should match zero or more instances of <subrule2> should it not?

[23:43] <Tene> yes

[23:43] *** Trashlord left
[23:43] <dalek> rakudo/nom: 6fd6552 | (Geoffrey Broadwell)++ | docs/ROADMAP:

[23:43] <dalek> rakudo/nom: Add four of my projects to the ROADMAP

[23:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6fd6552090

[23:43] <japhb> (git diff)++ # Understanding the format of ROADMAP well enough to correctly show which section each edit was contained in.

[23:44] *** icwiener left
[23:46] <supernovus> I know it used to work in the ng/b branch. I don't know what's wrong with it in nom. I need to walk away for a while. Exemel is closer to working under nom, but until I figure out why <rule>* refuses to match more than one item, it's stalled.

[23:49] *** drbean left
[23:50] *** supernovus left
[23:55] <sorear> rakudo:  /::/

[23:55] <p6eval> rakudo 483b3f: OUTPUT«===SORRY!===␤:: not yet implemented at line 1, near "/"␤»

[23:55] *** drbean joined
[23:58] <sorear> rakudo: grammar G { rule TOP { } }; say G.parse("x")

[23:58] <p6eval> rakudo 6fd655: OUTPUT«=> <>␤␤»

[23:59] <sorear> jnthn: I would like to make the case that this behavior is wrong.

[23:59] *** tokuhirom joined
