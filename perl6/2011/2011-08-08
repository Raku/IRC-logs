[00:00] <tadzik> ep

[00:00] *** bluescreen10 joined
[00:01] *** tyatpi left
[00:02] <jnthn> That's probably going to prove hard to find :(

[00:03] *** sili left
[00:04] <tadzik> :(

[00:05] *** alyx_ left
[00:05] *** alyx_ joined
[00:06] *** alyx_ is now known as alyx

[00:06] <tadzik> want a patch to investigate, would that help?

[00:08] <jnthn> Yes, though it'll be tomorrow - wanna sleep soon. :)

[00:10] <tadzik> oh, that's an idea :)

[00:10] <tadzik> I'm afraid to remove the commented out code now, it may impact the bug :P

[00:11] <jnthn> Trouble is that different memory layout on my machine may well hide the bug too :/

[00:12] <tadzik> I should be able to provide a shell on my laptop if that helps

[00:12] <tadzik> jnthn: want this pushed to a branch, or just a patch?

[00:12] <jnthn> tadzik: Branch is easier for me.

[00:13] <tadzik> okay

[00:15] <tadzik> shit, removing one of the say()s changed the bug

[00:15] <tadzik> to Method 'WHY' not found for invocant of class 'NQPLexPad'

[00:16] <tadzik> evil enough, so I'll keep it that way

[00:16] <jnthn> Well, yeah, it confirms it's something being unmarked and getting GC'd

[00:17] <dalek> rakudo/wherefore-gc-bug: 396201b | tadzik++ | / (6 files):

[00:17] <dalek> rakudo/wherefore-gc-bug: Fix Pod::Block::Declarator ordering. Reveals an ugly GC bug

[00:17] <dalek> rakudo/wherefore-gc-bug: review: https://github.com/rakudo/rakudo/commit/396201be71

[00:18] <tadzik> I'm using the file from https://gist.github.com/1130921

[00:19] <jnthn> ok, thanks; I investigate tomorrow.

[00:20] <tadzik> ++jnthn++

[00:21] *** Alias left
[00:26] *** tyatpi joined
[00:27] *** isBEKaml left
[00:32] *** bluescreen10 left
[00:37] * tadzik falls asleep

[00:38] <tadzik> g'night

[00:40] <jnthn> night, tadzik 

[00:41] *** tyatpi left
[00:45] *** moritz joined
[00:53] *** PacoLinux__ joined
[00:54] *** ranott left
[00:54] *** PacoLinux left
[00:54] *** PacoLinux__ is now known as PacoLinux

[00:58] * diakopter is amazed jnthn is still awake

[00:58] * moritz has parental insomnia

[00:58] <diakopter> aha

[00:59] <diakopter> oh wait you're not jnthn

[00:59] * jnthn is just a late night person and doesn't have to get up too early tomorrow :)

[00:59] <dalek> rakudo/nom: 31e7121 | jonathan++ | src/core/traits.pm:

[00:59] <dalek> rakudo/nom: Harden export trait a bit to avoid hard to find issues.

[00:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/31e712148f

[00:59] <dalek> rakudo/nom: d2bfaa5 | jonathan++ | t/spectest.data:

[00:59] <dalek> rakudo/nom: 3 more tests that we can pass now Test::Util works again.

[00:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d2bfaa5a15

[00:59] <dalek> rakudo/nom: ab4eacb | jonathan++ | NOMMAP.markdown:

[00:59] <dalek> rakudo/nom: Remove some completed entries from nommap (tadzik++ for noticing).

[00:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ab4eacb944

[00:59] <dalek> rakudo/nom: ed3094f | jonathan++ | src/ (4 files):

[00:59] <dalek> rakudo/nom: Make sure we give appropriate method names to auto-generated accessors and delegation methods, so introspection works out. Also try to handle multi exporting a bit more sanely.

[00:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ed3094f1a9

[00:59] *** tokuhirom left
[00:59] <jnthn> The various tests that use Test::Util pass for me when run directly, but fail under the harness. :/

[01:00] *** tokuhirom joined
[01:00] <jnthn> That was the way in master too, so I guess @other are seeing the same kind of thing.

[01:00] <jnthn> But only one some platforms.

[01:01] <jnthn> Anyway, can look more tomorow. The advent day11 one, I'm not sure how ever passed before...fixed now, anyways.

[01:01] <moritz> jnthn: got an example of a Test::Util based file?

[01:02] <jnthn> moritz: Any on those added in d2bfaa5

[01:02] <moritz> ok

[01:02] <jnthn> S02-magicals/pid.t for example

[01:02] <jnthn> I turned on various augment ones too :)

[01:03] <jnthn> S32-scalar/undef.t looks close to passing - just one clump of fail, iirc.

[01:03] *** PacoLinux left
[01:03] <jnthn> Anyway, I should sleep a bit. :)

[01:03] <jnthn> night, all o/

[01:04] *** tokuhirom left
[01:07] *** envi joined
[01:08] <dalek> roast: fe922ea | moritz++ | S32-str/trim.t:

[01:08] <dalek> roast: fudge a .trim test for rakudo

[01:08] <dalek> roast: review: https://github.com/perl6/roast/commit/fe922ea9cd

[01:10] <dalek> rakudo/nom: b6e553a | moritz++ | / (2 files):

[01:10] <dalek> rakudo/nom: trim-trailing, trim

[01:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6e553ac96

[01:15] <moritz> when I work around the missing MAIN thing, ufo works again

[01:15] *** donri joined
[01:16] *** Chillance left
[01:21] <moritz> nom: say (1 + *).WHAT

[01:21] <p6eval> nom: OUTPUT«_block1014␤»

[01:27] <diakopter> nom: say '.'.IO.X

[01:27] <p6eval> nom: OUTPUT«Method 'X' not found for invocant of class 'IO'␤current instr.: '_block1002' pc 91 ((file unknown):78104768) (/tmp/S6w2xEt5qa:1)␤»

[01:27] <diakopter> nom: say '.'.IO.x

[01:27] <p6eval> nom: OUTPUT«Bool::True␤»

[01:28] <diakopter> moritz: are the uppercase -R -W -X -O still spec'd in p6

[01:28] <diakopter> real uid

[01:28] <tadzik> great, not only I can't sleep, but I'm also hungry :/

[01:30] <moritz> diakopter: dunno

[01:44] *** moritz left
[01:45] <[Coke]> looks like we just got about 5 tests passing again.

[01:45] <[Coke]> well, running, I mean. fudges coming shortly

[01:45] <dalek> rakudo/nom: d601bb0 | moritz++ | / (3 files):

[01:45] <dalek> rakudo/nom: Cool.trim, Str.words, run words.t

[01:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d601bb0b9a

[01:45] <dalek> rakudo/nom: 5b9a992 | moritz++ | NOMMAP.markdown:

[01:45] <dalek> rakudo/nom: note state of Whatever-currying

[01:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5b9a99230c

[01:45] <dalek> rakudo/nom: 30a9776 | moritz++ | src/core/Any.pm:

[01:45] <dalek> rakudo/nom: generalize .[Whatever] case to .[Callable]

[01:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/30a977677f

[01:45] <dalek> rakudo/nom: 4a50e0a | moritz++ | / (4 files):

[01:45] <dalek> rakudo/nom: put CallFrame back into place

[01:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4a50e0acfe

[01:47] <[Coke]> ... /me reups to make sure he catches moritz's changes.

[01:50] <soh_cah_toa> didn't somebody mention the other day how to install rakudo w/o the parrot 3.6 release? i forget :\

[01:54] *** woosley joined
[02:06] *** Moukeddar joined
[02:06] *** jaldhar_ left
[02:06] *** jaldhar_ joined
[02:18] *** Moukeddar left
[02:28] <dalek> roast: 7805860 | Coke++ | / (8 files):

[02:28] <dalek> roast: nom fudge

[02:28] <dalek> roast: review: https://github.com/perl6/roast/commit/7805860121

[02:37] *** daniel-s joined
[02:40] <dalek> roast: 8bdc636 | Coke++ | integration/advent2009-day11.t:

[02:40] <dalek> roast: unfudge

[02:40] <dalek> roast: review: https://github.com/perl6/roast/commit/8bdc636a74

[02:50] *** sili joined
[03:09] <dalek> roast: f735ef3 | Coke++ | S06-operator-overloading/imported-subs.t:

[03:09] <dalek> roast: nom fudge

[03:09] <dalek> roast: review: https://github.com/perl6/roast/commit/f735ef3ba6

[03:09] <[Coke]> Files=393, Tests=10870, 1517 wallclock secs ( 6.11 usr  2.80 sys + 1494.17 cusr 138.79 csys = 1641.87 CPU)

[03:10] <dalek> rakudo/nom: ad24903 | Coke++ | t/spectest.data:

[03:10] <dalek> rakudo/nom: run more fudged tests/track failures

[03:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad24903059

[03:15] *** Trashlord left
[03:17] <[Coke]> and that's missing.... one test file, I think.

[03:17] *** thou left
[03:17] *** thou joined
[03:23] *** Su-Shee_ joined
[03:26] *** Trashlord joined
[03:27] *** Su-Shee left
[03:33] *** shinobicl left
[03:37] *** programming joined
[03:43] *** shinobicl__ joined
[03:44] *** wolfman2000 left
[03:46] *** pushStack joined
[03:53] *** shinobicl__ left
[03:58] *** pushStack left
[04:04] *** bpalmer joined
[04:07] *** satyavvd joined
[04:21] *** soh_cah_toa left
[04:24] *** birdwindupbird joined
[04:26] *** jaldhar_ left
[04:26] *** jaldhar_ joined
[05:07] *** jaldhar_ left
[05:23] *** programming left
[05:24] *** odoacre joined
[05:31] *** agentzh joined
[05:40] *** jaldhar_ joined
[05:52] *** daniel-s left
[05:52] *** fbass joined
[05:53] *** daniel-s joined
[05:53] *** fbass left
[05:53] *** fbass joined
[05:59] *** agentzh left
[06:02] *** jaldhar_ left
[06:02] *** jaldhar_ joined
[06:06] *** Su-Shee_ is now known as Su-Shee

[06:07] *** _jaldhar_ joined
[06:08] *** jaldhar_ left
[06:14] *** moritz joined
[06:19] *** koban joined
[06:22] <moritz> \o

[06:22] <moritz> nom: say ?(0 & 1)

[06:22] <p6eval> nom: OUTPUT«Bool::False␤»

[06:22] <moritz> nom: say ?(0 S& 1)

[06:22] <p6eval> nom: OUTPUT«Bool::True␤»

[06:22] * moritz finds that dubious

[06:23] *** bpalmer left
[06:36] *** SHODAN joined
[06:37] *** birdwindupbird left
[06:44] *** birdwindupbird joined
[06:49] *** Mowah joined
[06:51] <cognominal> I am not to sure if i can submit that to github. This is camelia transmogrified in an octocat :  https://gist.github.com/1131321

[07:06] *** am0c joined
[07:10] *** pernatiy left
[07:12] <dalek> roast: 754bc98 | moritz++ | / (23 files):

[07:12] <dalek> roast: rakudo unfudges

[07:12] <dalek> roast: review: https://github.com/perl6/roast/commit/754bc98de7

[07:22] *** thou left
[07:58] *** mj41 joined
[08:05] <jnthn> morning, 

[08:05] <jnthn> #perl6

[08:06] <moritz> mrnng jnthn 

[08:06] <jnthn> :)

[08:06] <jnthn> moritz++ # overnight hacking 

[08:07] *** timbunce joined
[08:11] *** im2ee joined
[08:12] *** moritz left
[08:12] *** moritz joined
[08:12] *** im2ee left
[08:22] *** sivoais left
[08:39] *** agentzh joined
[08:39] *** ribasushi joined
[08:41] *** timbunce left
[08:41] *** wtw joined
[08:56] *** dakkar joined
[08:57] <moritz> nom: my @a = (1, {a => 2, b => 3 }, 4), say -<<@a;

[08:57] <p6eval> nom: OUTPUT«␤»

[09:02] *** odoacre left
[09:02] *** odoacre joined
[09:04] *** Alias joined
[09:13] *** Trashlord left
[09:23] <dalek> 6model: 2bed502 | (Martin Berends)++ | c/t (7 files):

[09:23] <dalek> 6model: [6model/c] patches for OS X (bbkr++ for server shell account) and MinGW

[09:23] <dalek> 6model: review: https://github.com/jnthn/6model/commit/2bed5025c3

[09:34] *** ab5tract joined
[09:36] <dalek> roast: c1ac92d | moritz++ | S03-metaops/hyper.t:

[09:36] <dalek> roast: fudge hyper.t for rakudo

[09:36] <dalek> roast: review: https://github.com/perl6/roast/commit/c1ac92d032

[09:37] <dalek> rakudo/nom: 95e209b | moritz++ | t/spectest.data:

[09:37] <dalek> rakudo/nom: run (heavily fudged) hyper.t

[09:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/95e209bdfd

[09:41] *** Trashlord joined
[09:42] *** MayDaniel joined
[09:43] <moritz> nom: say 'uc' ~~ .uc

[09:43] <p6eval> nom: OUTPUT«Bool::False␤»

[09:44] <moritz> perl6: say 'uc' ~~ .uc

[09:44] <p6eval> pugs: OUTPUT«1␤»

[09:44] <p6eval> ..rakudo 922500, niecza v8-45-g366d65b: OUTPUT«Bool::False␤»

[09:44] <moritz> somehow I have my trouble with that response

[09:44] <sorear> I am very certain pugs is wrong wrt the current spec

[09:44] <sorear> ~~ is a topicalizer now

[09:44] <moritz> right, so response is 'uc'.uc

[09:45] <sorear> 'uc' ~~ .uc means 'uc' ~~ 'UC'

[09:45] <moritz> uhm

[09:45] <sorear> which means 'uc' eq 'UC'

[09:45] <moritz> does it really smartmatch the result again?

[09:45] <jnthn> It only does one smart-match

[09:45] <jnthn> When .uc is evaluated (before we call ACCEPTS) then the LHS is in $_

[09:45] *** dual left
[09:46] <jnthn> nom: say 'UC' ~~ .uc

[09:46] <p6eval> nom: OUTPUT«Bool::True␤»

[09:46] <moritz> ah right, the syntactic forms where removed

[09:46] <jnthn> Yes.

[09:46] <moritz> then S03-smartmatch/any-method needs to be adjusted

[09:47] <moritz> nom: say 'abc' ~~ m/./

[09:47] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'ACCEPTS'. Available candidates are:␤:(Mu, Mu $topic, Mu %_)␤␤current instr.: 'ACCEPTS' pc 702744 (src/gen/CORE.setting.pir:178165) (src/gen/CORE.setting:427)␤»

[09:47] *** woosley left
[09:50] *** Mowah left
[09:50] <dalek> roast: a96285b | moritz++ | S03-smartmatch/any-method.t:

[09:50] <dalek> roast: rewrite smart-matching test to conform to current spec

[09:50] <dalek> roast: review: https://github.com/perl6/roast/commit/a96285b02f

[09:52] *** sunnavy joined
[09:52] *** ribasushi_ joined
[09:54] *** ribasushi left
[09:54] *** ribasushi_ is now known as ribasushi

[09:56] *** dual joined
[10:07] <moritz> nom: my %h = a => 1; say 'a' ~~ %h

[10:07] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'ACCEPTS'. Available candidates are:␤:(Mu, Mu $topic, Mu %_)␤␤current instr.: 'ACCEPTS' pc 702744 (src/gen/CORE.setting.pir:178165) (src/gen/CORE.setting:427)␤»

[10:08] <moritz> nom: say [1, 2, 3].any.perl

[10:08] <p6eval> nom: OUTPUT«any(1, 2, 3)␤»

[10:10] <moritz> S03 has

[10:10] <moritz> Scalar    Hash      hash entry existence    X.{$_}:exists

[10:10] <moritz> should that be s/Scalar/Cool/ ?

[10:11] <jnthn> Cool or Any, I guess.

[10:12] <moritz> there's another entry for Any

[10:12] <jnthn> ah

[10:12] <jnthn> Yeah, Cool seems reasonable.

[10:15] <dalek> specs: e874ee4 | moritz++ | S03-operators.pod:

[10:15] <dalek> specs: [S03] remove Scalar from the smart matching table

[10:15] <dalek> specs: review: https://github.com/perl6/specs/commit/e874ee45bd

[10:19] <dalek> roast: c887819 | moritz++ | S03-smartmatch/scalar-hash.t:

[10:19] <dalek> roast: fix test descriptions

[10:19] <dalek> roast: review: https://github.com/perl6/roast/commit/c8878196eb

[10:26] <dalek> rakudo/nom: 3ea71cf | moritz++ | / (2 files):

[10:26] <dalek> rakudo/nom: add missing :Ds to EnumMap, start with EnumMap.ACCEPTS

[10:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ea71cf82f

[10:27] *** envi left
[10:33] *** envi joined
[10:34] *** nbrown left
[10:34] *** [particle]1 left
[10:35] *** nbrown joined
[10:39] *** jferrero left
[10:40] *** Aridai joined
[10:40] *** jferrero joined
[10:40] *** _jaldhar_ is now known as jaldhar

[10:46] *** mj41 left
[10:58] *** amkrankr1leuen joined
[10:59] *** amkrankruleuen left
[11:01] *** kjeldahl left
[11:02] *** mj41 joined
[11:03] *** Aridai left
[11:11] *** SHODAN left
[11:12] *** kboga left
[11:15] *** Woodi joined
[11:25] *** Woodi left
[11:29] <tadzik> good noon

[11:30] <jnthn> o/ tadzik 

[11:30] * tadzik has a new bike

[11:31] * mberends likes bikes

[11:33] *** im2ee joined
[11:34] <tadzik> cognominal++ # hilarous

[11:34] <tadzik> an actual laughter was produced, aloud

[11:37] <frettled> tadzik: so now there's more bikeshedding on the horizon?

[11:37] <tadzik> aye :)

[11:39] *** kjeldahl joined
[11:39] *** pernatiy joined
[11:48] <moritz> nom: my $a = [1, 2, 3]; my %h = 1 => 3; say %h.exists($a.any)

[11:48] <p6eval> nom: OUTPUT«Nominal type check failed for parameter '$key'; expected Str but got Int instead␤current instr.: 'exists' pc 760093 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:3955)␤»

[11:49] <jnthn> Not Cool

[11:49] *** satyavvd left
[11:50] *** Woodi joined
[11:52] *** noganex left
[11:52] *** crked joined
[11:54] *** mattp_ left
[11:54] <crked> Morning, perl6. Is there a fixed date for the new Rakudo to come out? 

[11:55] <tadzik> it was supposed to be before the YAPC I think

[11:56] *** mj41 left
[11:56] *** sayu joined
[11:59] <crked> So it means it will be released before 15th. Thanks.

[12:00] *** Woodi left
[12:01] *** Woodi joined
[12:02] <frettled> That will be nice.

[12:03] <tadzik> 15th is also my suggested Pencils Down on the GSoC

[12:03] <moritz> quel coincidence

[12:05] *** noganex joined
[12:08] *** rdesfo joined
[12:09] *** Trashlord left
[12:12] *** rlb3_ joined
[12:19] <takadonet> morning all

[12:19] <tadzik> morning takadonet 

[12:19] *** PacoLinux joined
[12:20] *** wamba joined
[12:21] *** am0c left
[12:22] *** rlb3_ left
[12:23] *** Trashlord joined
[12:33] *** am0c joined
[12:34] <jnthn> nom: say Method ~~ Code

[12:34] <p6eval> nom: OUTPUT«Bool::True␤»

[12:36] *** ingy joined
[12:36] *** hanekomu joined
[12:39] <dalek> rakudo/nom: 169baab | moritz++ | src/core/EnumMap.pm:

[12:39] <dalek> rakudo/nom: handle non-Str case of EnuMap.exists

[12:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/169baab25e

[12:39] <dalek> rakudo/nom: b4296cb | moritz++ | src/core/Match.pm:

[12:39] <dalek> rakudo/nom: Match.ACCEPTS

[12:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b4296cbfbc

[12:46] <takadonet> sorear: ping

[12:47] <moritz> PAST::Compiler can't compile node of type SVG::Plot::AxisPosition

[12:47] <moritz> WHAT?

[12:47] <tadzik> hihi

[12:47] <tadzik> jnthn: btw, any progress on the GC bug?

[12:47] <jnthn> tadzik: no :(

[12:48] <jnthn> tadzik: I'm stuck on a roles-in-the-setting bug :/

[12:48] <tadzik> moritz: sounds familiar to my "DEBUG: attaching .WHY to class 'Sub'" and later "method .WHY not found for class NQPLexPad" :)

[12:48] <tadzik> jnthn: ah

[12:48] <moritz> fwiw SVG::Plot::AxisPosition is an enum

[12:49] <foomator> hrm

[12:49] <jnthn> Somehow it must be landing up in the PAST tree.

[12:49] <foomator> wie implementier ich denn am besten nen syntaxcheck fuer funktionen, die ein user in einem config file hinterlegen koennen sollt

[12:49] <foomator> soll

[12:50] <foomator> also sowas wie substitute("AAA","BBB")

[12:50] <foomator> mir gehts eigentlich nur um Klammern und korrektes Quoting

[12:50] <foomator> security is in dem Fall vernachlaessigbar

[12:50] <moritz> foomator: wrong channel?

[12:50] <foomator> ich koennte natuerlich einfach eval machen

[12:51] <foomator> uh

[12:51] <foomator> sh**

[12:51] <moritz> foomator: or wrong language at least :-)

[12:51] <foomator> totally wrong channel :)

[12:51] * foomator kicks screen and the problem between chair and keyboard

[12:52] *** im2ee left
[12:53] *** bluescreen10 joined
[12:55] *** im2ee joined
[12:56] <tadzik> Files=397, Tests=11183, 1418 wallclock secs

[12:56] <tadzik> \o/

[12:57] <moritz> nom: my token wc { \w }

[12:57] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[12:58] *** drbean left
[13:04] *** kemono left
[13:07] <moritz> tadzik: what does MAIN block on? capture-to-signature binding check?

[13:07] <tadzik> yes

[13:07] <tadzik> I think it's the one last thing

[13:08] <tadzik> I can paste the MAIN.pm I figured up to this point

[13:08] <moritz> tadzik: we could omit that for now, and just call &MAIN(|@processed_arglist)

[13:08] <tadzik> mebbe. Should I commit that?

[13:08] <moritz> tadzik: that way we won't get USAGE messages, but at least basic MAIn

[13:08] <moritz> yes, plese

[13:08] <moritz> *please

[13:08] <tadzik> well, we'll get a random/first MAIN()

[13:08] <tadzik> we're not able to choose the best one

[13:09] <tadzik> is that what you mean, the first one available?

[13:10] <moritz> can't we get a reference to the proto?

[13:10] <moritz> then it'll just dispatch to the tighted multi

[13:10] <tadzik> so far we were cycling through $main.candidates

[13:10] *** odoacre left
[13:10] <tadzik> do hyperops now fully work?

[13:10] <moritz> I know, and that's wrong

[13:10] <moritz> not fully

[13:11] <jnthn> Why do we loop over the candidates?

[13:11] <tadzik> okay, I'll just leave my workarounds

[13:11] <tadzik> jnthn: no eye deer

[13:11] <jnthn> I mean, it feels like you're poorly re-inventing the multi-dispatcher.

[13:11] <moritz> jnthn: because that was the only way back in the days when I wired it up

[13:11] <tadzik> https://gist.github.com/1131716

[13:11] <tadzik> #126

[13:12] <moritz> jnthn: oh, I think because the processing of command line arguments depends on the signature

[13:13] <moritz> which is really a bit bogus

[13:13] <tadzik> I find this whole code a bit bogus :)

[13:14] * moritz should re-read the spec

[13:14] <tadzik> what comes to my mind is: get positionals, get nameds, put the hard work on the dispatcher's back

[13:14] *** PacoLinux left
[13:14] <moritz> tadzik: it's not that easy

[13:14] *** PacoLinux joined
[13:15] <moritz> tadzik: if you have a  Bool $foo  in a signature, then a --foo in the argument list doesn't look for a value

[13:16] <tadzik> hmm, true

[13:16] <jnthn> Does it have to be that way?

[13:16] <jnthn> I mean, if you see

[13:16] <jnthn> --foo --bar

[13:16] <jnthn> Then you know what comes next is a switch, not a value

[13:16] <jnthn> So you stick a Bool in the capture

[13:17] <moritz> there are basically two approaches to fix that

[13:17] * jnthn would be much more comfortable if somehow we could do this with MAIN(|process-args-into-capture(@*ARGS))

[13:17] <tadzik> that'd be great, yes

[13:17] <moritz> the first is jnthn++'s suggestions, make the argument parsing indepenent of the signature

[13:18] <moritz> the second is to say that we only consider the signature of the proto

[13:18] <jnthn> I concede the current spec may not make that plausible.

[13:18] <pmichaud> good morning, #perl6

[13:18] <jnthn> o/ pmichaud 

[13:18] <tadzik> good morning pmichaud 

[13:18] <moritz> good morning pmichaud 

[13:18] * tadzik off for bikeshedding

[13:18] <moritz> I'm kinda in favor of removing the Bool special-case

[13:19] *** sayu left
[13:19] <takadonet> pmichaud: morning

[13:19] <pmichaud> 13:10 <tadzik> do hyperops now fully work?

[13:19] <pmichaud> 13:10 <moritz> not fully

[13:19] <pmichaud> ...what's missing, ooc?

[13:19] <moritz> pmichaud: look through the latest roast commits, I fudged hyper.t for rakudo

[13:20] <pmichaud> moritz++  # thanks

[13:20] <moritz> nom: my %h; %h<a b c>>>++; say %h.perl

[13:20] <p6eval> nom: OUTPUT«("a" => 1, "b" => 1, "c" => 1).hash␤»

[13:20] <moritz> hm, that one works

[13:20] <moritz> nom: nom: my @a = (1, {a => 2, b => 3 }, 4), say -<<@a;

[13:20] <p6eval> nom: OUTPUT«Confused at line 1, near "nom: my @a"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[13:20] <moritz>  nom: my @a = (1, {a => 2, b => 3 }, 4), say -<<@a;

[13:20] <p6eval> nom: OUTPUT«␤»

[13:21] <moritz> that one is dubious, for example

[13:21] <pmichaud> nom: my @a = (1,2,3,4);  say -<<@a;

[13:21] <p6eval> nom: OUTPUT«-1 -2 -3 -4␤»

[13:21] <moritz> nom: say <a b c d> >>+>> (1, 2, 3)

[13:21] <p6eval> nom: OUTPUT«Sorry, lists on both sides of non-dwimmy hyperop are not of same length:␤    left: 4 elements, right: 4 elements␤␤current instr.: 'die' pc 662759 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:370)␤»

[13:21] <pmichaud> nom: my @a = (1,{a=>2, b=>3},4);  say -<<@a;

[13:21] <p6eval> nom: OUTPUT«Default constructor only takes named arguments␤current instr.: 'die' pc 662759 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:370)␤»

[13:21] <pmichaud> okay, there we're missing Hash.new

[13:22] *** Mowah joined
[13:22] <moritz> perl6: say ~(<a b c d> >>+>> (1, 2, 3))

[13:22] <p6eval> niecza v8-45-g366d65b: OUTPUT«Unhandled exception: System.FormatException: Unknown char: a␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) [0x…

[13:22] <p6eval> ..rakudo 922500: OUTPUT«1 2 3 1␤»

[13:22] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ">>+>>"␤    expecting operator or ")"␤    at /tmp/6wMNCg35mX line 1, column 17␤»

[13:33] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @a != @b };   xyz(<a b c d>, (1,2,3));

[13:33] <p6eval> nom: OUTPUT«Bool::True␤»

[13:33] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @a.elems != @b.elems };   xyz(<a b c d>, (1,2,3));

[13:33] <p6eval> nom: OUTPUT«Bool::False␤»

[13:33] <dalek> specs: 5f35620 | moritz++ | S06-routines.pod:

[13:33] <dalek> specs: make MAIN more robust and less magic

[13:33] <dalek> specs: 

[13:33] <dalek> specs: The problem with the previous approach was that it made the parsing

[13:33] <dalek> specs: of command lines dependent on the signature of each multi MAIN

[13:33] <dalek> specs: candidate, making it impossible to first process @*ARGS and then

[13:33] <dalek> specs: do a multi dispatch.

[13:33] <dalek> specs: 

[13:33] <dalek> specs: A different approach at fixing that would be to use the signature of

[13:33] <dalek> specs: the proto of MAIN as reference instead. If somebody feels strongly

[13:33] <dalek> specs: about preserving the old magic, please revert this commit and clarify

[13:33] <dalek> specs: that magic command line parsing needs an explicit proto MAIN.

[13:33] <dalek> specs: review: https://github.com/perl6/specs/commit/5f3562023c

[13:33] <jnthn> sanity++

[13:34] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @a.Numeric; say @b.Numeric };   xyz(<a b c d>, (1,2,3));

[13:34] <p6eval> nom: OUTPUT«4␤12␤»

[13:34] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @a.WHAT; say @b.WHAT };   xyz(<a b c d>, (1,2,3));

[13:34] <moritz> I feel the hubris of skipping the p6l discussion altogether, and put the foregone conclusion into the commit message :-)

[13:34] <p6eval> nom: OUTPUT«List()␤Parcel()␤»

[13:35] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @a.Numeric; say @b.Numeric };   xyz(<a b c d>, (1,2,3));

[13:35] <p6eval> nom: OUTPUT«4␤12␤»

[13:35] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).flat.munch(4);  say @a.Numeric; say @b.Numeric };   xyz(<a b c d>, (1,2,3));

[13:36] <p6eval> nom: OUTPUT«4␤4␤»

[13:36] <moritz> nom: sub MAIN { say "MAIN" }; sub MAIN_HELPER() { callframe(1).my<&MAIN>() }

[13:36] <p6eval> nom: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: 'MAIN_HELPER' pc 437 ((file unknown):60005096) (/tmp/ofjKjaPXeW:1)␤»

[13:36] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).flat.munch(4);  say @a == @b };   xyz(<a b c d>, (1,2,3));

[13:36] <p6eval> nom: OUTPUT«Bool::True␤»

[13:36] <moritz> nom: sub M { say "MAIN" }; sub MH() { callframe(1).my<&M>() }; MH

[13:36] <p6eval> nom: OUTPUT«MAIN␤»

[13:36] <moritz> \o/

[13:37] *** anbz joined
[13:37] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).flat.munch(4);  say @b.perl };   xyz(<a b c d>, (1,2,3));

[13:37] <p6eval> nom: OUTPUT«(1, 2, 3, 1)␤»

[13:37] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @b.perl };   xyz(<a b c d>, (1,2,3));

[13:37] <p6eval> nom: OUTPUT«((1, 2, 3), (1, 2, 3), (1, 2, 3), (1, 2, 3))␤»

[13:37] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b xx *).munch(4);  say @b.elems };   xyz(<a b c d>, (1,2,3));

[13:37] <p6eval> nom: OUTPUT«4␤»

[13:40] *** thou joined
[13:40] <pmichaud> nom:  sub xyz(\$a, \$b) { my @a := $a.flat; my @b := ($b.flat xx *).munch(4);  say @b.perl };   xyz(<a b c d>, (1,2,3));

[13:40] <p6eval> nom: OUTPUT«(1, 2, 3, 1)␤»

[13:42] *** shinobicl joined
[13:47] <pmichaud> > my @a = (1, {a => 2, b => 3}, 4);  say (-<<@a).perl

[13:47] <pmichaud> (-1, {"a" => -2, "b" => -3}, -4).list

[13:47] <pmichaud> > say (<a b c d> >>+>> (1,2,3)).perl

[13:47] <pmichaud> (1, 2, 3, 1).list

[13:47] <pmichaud> > 

[13:47] <pmichaud> de-fudging hyper.t now

[13:47] <[Coke]> pmichaud++

[13:47] <[Coke]> moritz++ for previous defudging

[13:48] <shinobicl> rakudo: sub some-func { say "3" }; some-func; sub some-3func { say "3" }; some-3func;

[13:48] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Confused at line 22, near "sub some-3"␤»

[13:49] <[Coke]> shinobicl: "An identifier may also contain isolated apostrophes or hyphens provided the next character is alphabetic."

[13:49] <[Coke]> http://feather.perl6.nl/syn/S02.html#Names

[13:49] <sorear> good * #perl6

[13:49] <shinobicl> oh... then i can forget calling a function "in-24h"...

[13:49] <[Coke]> sorear: o/

[13:50] <sorear> takadonet: i

[13:50] <[Coke]> shinobicl: in_24h would work, methinks.

[13:50] *** mattp_ joined
[13:50] <[Coke]> or in24h

[13:50] *** thou left
[13:56] <moritz> how do I construct a capture from an Array and a Hash?

[13:57] <pmichaud> \(|@a, |%h)   # maybe?

[13:57] *** isBEKaml joined
[13:57] <sorear> = pmichaud

[13:57] *** JimmyZ joined
[13:58] <moritz> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return |@a, |%h }; f(c)

[13:58] <p6eval> nom: OUTPUT«AAny()␤»

[13:59] <moritz> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return \(|@a, |%h) }; f(|c)

[13:59] <p6eval> nom: OUTPUT«Could not find sub &prefix:<|>␤current instr.: 'c' pc 515 ((file unknown):286) (/tmp/Fk0V8OBVhR:1)␤»

[13:59] <moritz> hm

[14:00] <moritz> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return @a, %h; }; my (@a, %h) := c; f |@a, |%h

[14:00] <p6eval> nom: OUTPUT«Cannot use bind operator with this LHS at line 1, near " c; f |@a,"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[14:00] <moritz> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return @a, %h; }; my (@a, %h) = c; f |@a, |%h

[14:00] <p6eval> nom: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤current instr.: 'f' pc 448 ((file unknown):24018708) (/tmp/9TtR1gg_Cs:1)␤»

[14:01] <jnthn> moritz: I tink the @a slurps up both things there.

[14:01] <jnthn> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return @a, %h; }; my ($a, $h) = c; f |$a, |$h

[14:01] <p6eval> nom: OUTPUT«Method 'ARGLIST_FLATTENABLE' not found for invocant of class 'Str'␤current instr.: '_block1002' pc 119 ((file unknown):16494275) (/tmp/Q4ktbcYeG6:1)␤»

[14:01] <jnthn> grr

[14:03] <jnthn> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return \@a, \%h; }; my ($a, $h) = c; f |$a.list, |$h.hash

[14:03] <p6eval> nom: OUTPUT«AAny()␤»

[14:03] <jnthn> oh, duh.

[14:04] <jnthn> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return \@a.Capture, %h.Capture; }; my ($a, $h) = c; f |$a, |$h

[14:04] <p6eval> nom: OUTPUT«flattened parameters must be a hash or array␤current instr.: '_block1002' pc 134 ((file unknown):158) (/tmp/hIDURAcUZG:1)␤»

[14:04] <jnthn> :S

[14:04] <jnthn> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return \@a.Capture, %h.Capture; }; my ($a, $h) = c; f |$a, |$h.hash

[14:04] <[Coke]> funky beard!

[14:04] <p6eval> nom: OUTPUT«A1␤»

[14:04] <jnthn> heh

[14:04] <[Coke]> (jnthn's emoticon)

[14:05] <jnthn> Anyway, |$c doesn't really work yet

[14:05] *** anbz left
[14:07] * tadzik is back

[14:07] <moritz> jnthn: I'd be fine with having a method-ish API for creating a capture

[14:07] <moritz> something like   Capture.new(@positional, %named) or so

[14:09] <sorear> wait, what is return |%h supposed to do !?

[14:09] <jnthn> sorear: I'm not cure :)

[14:09] <jnthn> *sure

[14:09] <pmichaud> returns named arguments

[14:10] <pmichaud> similar to    return a=>1, b=>2

[14:10] <moritz> right; what else could it mean? :-)

[14:10] <pmichaud> (assuming %h == { a=>1, b=>2 }

[14:12] <jnthn> moritz: Well, \(1, a => 2) should do it, and the | interpolation should work there too, but I didn't fix that up for nom yet

[14:13] *** kaare_ joined
[14:17] <moritz> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return @a, %h; }; my ($a, $h) = c; f |@$a, |%$h

[14:17] <p6eval> nom: OUTPUT«Non-declarative sigil is missing its name at line 1, near "@$a, |%$h"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[14:17] <moritz> nom: sub f($a, :$b) { say $a, $b }; sub c { my @a = 'A'; my %h = b => 1; return @a, %h; }; my ($a, $h) = c; f |@($a), |%($h)

[14:17] <p6eval> nom: OUTPUT«A1␤»

[14:17] <moritz> \o/

[14:17] <jnthn> :)

[14:18] *** [particle] joined
[14:18] <tadzik> jnthn: not sure if I remember correctly, when I want to add a custom code object as a phaser, I need to do this in Grammar.pm.comp_unit, before the lexpads get popped out?

[14:19] <jnthn> tadzik: Yeha, though really you should add an grammar rule in there that triggers an action method, since you'll want to make use of make_thunk or something, I guess.

[14:19] <jnthn> And call that from comp_unit

[14:19] <jnthn> Rather than putting more stuff in comp_unit :)

[14:19] <tadzik> I get it

[14:19] <tadzik> so another <.install_doc_phaser> inside, si?

[14:20] <jnthn> that'll do.

[14:20] <tadzik> acknowlegded, thanks

[14:22] <dalek> rakudo/nom: 38be712 | jonathan++ | src/Perl6/Metamodel/RoleToRoleApplier.pm:

[14:22] <dalek> rakudo/nom: Avoid a bunch of work when the role to role applier has an empty list of roles to apply.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38be7128f3

[14:22] <dalek> rakudo/nom: f2aabfa | jonathan++ | src/Perl6/Metamodel/RoleTo (2 files):

[14:22] <dalek> rakudo/nom: Avoid some (weird, hard to nail down) circularity issue in getting method names (we can't always do .name as NQP methods are Parrot subs, which we need to stringify...)

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f2aabfa56f

[14:22] <dalek> rakudo/nom: 8fd1a35 | jonathan++ | src/core/Submethod.pm:

[14:22] <dalek> rakudo/nom: Add missing Submethod.pm.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8fd1a35f19

[14:22] <dalek> rakudo/nom: e0867f0 | jonathan++ | / (3 files):

[14:22] <dalek> rakudo/nom: Start to port over socket stuff from master. This doesn't quite work yet, but builds. Also will need to fix up packages.

[14:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e0867f021c

[14:27] <jnthn> BTW, anybody who's tried doing stuff with roles in the setting and had issues should find the above patches help.

[14:27] * moritz did, with Date and DateTime

[14:29] <jnthn> moritz: Had issues? :)

[14:29] <moritz> yes

[14:29] <jnthn> infinite recursion-ish issues?

[14:29] <moritz> aye

[14:29] <jnthn> Yeah, the above help with that one.

[14:31] <tadzik> that should help for Buf too, iirc

[14:34] *** colomon joined
[14:34] *** jaldhar left
[14:37] *** wtw left
[14:38] *** PacoLinux left
[14:41] <moritz> $ ./perl6 -e 'sub MAIN($x) { say $x }' \\o/

[14:41] <moritz> \o/

[14:42] <tadzik> \o/

[14:42] <JimmyZ> \\oo//

[14:42] <jnthn> nice :)

[14:42] <jnthn> moritz++

[14:42] <moritz> tadzik++ did a good chunk of the actual work

[14:43] <isBEKaml> \\o//

[14:43] *** koban left
[14:44] *** birdwindupbird left
[14:44] <tadzik> moritz: does it choose the more-less-matching one?

[14:45] *** timbunce joined
[14:45] <moritz> tadzik: haven't tried with multis yet :-)

[14:46] <tadzik> looking forward to seeing the patch :) moritz++

[14:46] <moritz> tadzik: but it just calls &MAIN(|@pos, |%named), so I guess the dispatcher does its job

[14:46] <moritz> oh and I simplified the command line processing a lot, courtesy of the latest spec change

[14:46] <tadzik> that's awesome

[14:47] *** fbass left
[14:47] * moritz doesn't wait for the full spectest run

[14:47] * tadzik just implemented a default DOC INIT phaser :)

[14:47] <dalek> rakudo/nom: 99f5ce9 | moritz++ | / (2 files):

[14:47] <dalek> rakudo/nom: first attempt to put MAIN back, tadzik++ did lot of the early work

[14:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99f5ce972c

[14:48] <jnthn> wow, patches all around :)

[14:48] <tadzik> now to only make it print something more sophisticated than 'dupa'...

[14:48] <pmichaud> moritz: what's the motivation behind https://github.com/rakudo/rakudo/commit/30a977677f5604948f52d93c41bc548d779586e9 ?  ( WhateverCode -> Callable in postcircumfix:<[ ]>)

[14:49] <moritz> pmichaud: removing an arbitrary limitation

[14:49] <pmichaud> ...why is it arbitrary?

[14:49] <pmichaud> should we really expect     @a[{...arbitrary block}]  to work?

[14:49] <moritz> pmichaud: why should I be allowed to write @a[* % 2] but not @a[-> $x { $x % s }] ?

[14:50] <TimToady> it's more of a problem when we get object hashes

[14:50] <TimToady> you can never have a closure as a key

[14:50] <moritz> array != hash

[14:50] <TimToady> (if hashes follow the same policy)

[14:51] <TimToady> they don't have to be the same, I guess

[14:51] <moritz> well, we can't have WhateverCode keys either

[14:51] <jnthn> Does hash even have a WhateverCode case?

[14:51] <pmichaud> I'm fine if we state somewhere (in the spec) that blocks in postcircumfix:<[ ]>  are invoked.  I just want it explicit.

[14:52] <moritz> jnthn: not that I'm aware of

[14:52] <TimToady> is it any more expensive?

[14:52] <pmichaud> than a whatevercode?  not presently.

[14:52] <TimToady> then I'd be inclined to generalize it

[14:52] <pmichaud> my $c = { ... };     say @a[$c]    # might surprise someone.

[14:52] <TimToady> it's gonna suprise 'em anyway

[14:52] <moritz> aye

[14:52] <tadzik> true

[14:53] <tadzik> well, but an error message is less suprising that unknown behaviour

[14:53] <pmichaud> nom:  my $c = { $^a + 1 };   say $c.Int;

[14:53] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[14:54] <pmichaud> yeah... currently would give   'Method 'Int' not found for invocant of class 'Block''

[14:54] <tadzik> INITs are FIFO?

[14:54] <TimToady> yes

[14:54] <pmichaud> tadzik: yes.

[14:54] <tadzik> ok, thanks

[15:04] <dalek> roast: 82ab11f | pmichaud++ | S03-metaops/hyper.t:

[15:04] <dalek> roast: Some hyper.t de-fudging.

[15:04] <dalek> roast: review: https://github.com/perl6/roast/commit/82ab11f95f

[15:04] <dalek> rakudo/nom: 429a183 | pmichaud++ | src/core/ (3 files):

[15:04] <dalek> rakudo/nom: Some hyper metaop and hash updates.

[15:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/429a183d57

[15:08] *** am0c left
[15:09] <moritz> rakudo: say 1; sub MAIN() { say 2 }

[15:09] <p6eval> rakudo 922500: OUTPUT«1␤2␤»

[15:09] <moritz> rakudo: say 1; sub MAIN() { say 2 }; say 3

[15:09] <p6eval> rakudo 922500: OUTPUT«1␤3␤2␤»

[15:09] <moritz> is that correct?

[15:09] <TimToady> yes

[15:10] <tadzik> jnthn: what do I need, aside from $*ST.load_module('Pod::To::Text', $*GLOBALish); to be able do :pasttype<call>, :name<Pod::To::Text::pod2text>?

[15:10] <jnthn> You can't do that with name.

[15:10] *** shinobicl left
[15:10] *** shinobicl joined
[15:10] <TimToady> rakudo: @*ARGS = '42'; sub MAIN (Int $n) { say $n }

[15:10] <p6eval> rakudo 922500: OUTPUT«Usage:␤/tmp/52blBCQoJN n␤»

[15:10] <TimToady> that is not correct

[15:11] <tadzik> why not?

[15:11] <tadzik> (to jnthn, not to TimToady)

[15:11] <moritz> rakudo doesn't do magic parsing of @*ARGS yet

[15:11] <jnthn> tadzik: Because it doesn't do multi-level lookups

[15:11] <TimToady> moritz: I know, just pointing at the val semantics that are specced

[15:11] <tadzik> how do I do this? I tried importing and calling just pod2text, but that didn't find it too

[15:11] <TimToady> moritz: your MAIN patch actually brings us closer to that, i think

[15:12] <jnthn> load_module won't import

[15:12] <tadzik> yes, I know

[15:12] <jnthn> You need another call to do that

[15:12] <tadzik> I copypasted the importing part from Grammar.pm

[15:12] <jnthn> Did you do :name<pod2text> ?

[15:12] <tadzik> yes

[15:12] <jnthn> It needs an & on the start, if so :)

[15:12] <tadzik> oh :)

[15:12] <moritz> TimToady: rakudo nearly has what it takes to make it DWIM in the case of numbers

[15:12] *** am0c joined
[15:13] <moritz> but not yet things like colonpairs

[15:15] * moritz tries to get rid of the additional $MAIN lexikal

[15:16] * TimToady is still pondering the exact nature of allomorphic literals, but knows we need something like current val spec

[15:17] <TimToady> Go just delays conversion of the string form till actual use, but they're not trying to do multi dispatch

[15:18] <tadzik> yay, --doc works

[15:18] <moritz> speaking of other languages, 'kotlin' has a few interesting design choices

[15:18] <flussence> is anyone currently working on a Pod::To::HTML? :)

[15:19] <TimToady> moritz: haven't heard of it.  any choices that we might be interested in?

[15:19] <tadzik> flussence: well volunteered!

[15:19] <moritz> TimToady: for example they close classes by default, and you have to mark them as inheritable

[15:20] <moritz> if you want to be able to inherit from it

[15:20] <TimToady> that's just wrong, I think :)

[15:20] <moritz> with the argument that inheritance from classes that weren't designed for inheritance leads to more problems

[15:20] <TimToady> we don't close classes by default till CHECK time

[15:20] <TimToady> :)

[15:20] <moritz> TimToady: I said "interesting", not "good" :-)

[15:21] <moritz> oh, and it's a statically typed language for the JVM, with reified generics

[15:21] <moritz> http://confluence.jetbrains.net/display/Kotlin/Welcome

[15:21] <moritz> not much to steal from, but interesting to look at, IMHO

[15:22] <moritz> on the plus side they use keywords for defining routines (and they are 'fun' :-)

[15:22] <moritz> on the minus side they have optional semicolons at line end (javascript and go, I'm looking at you)

[15:23] * TimToady is curious, how do you *not* design a class for inheritance?

[15:24] *** mj41 joined
[15:24] <TimToady> "unwarranted chumminess with the memory system", I'll warrant...

[15:25] <moritz> TimToady: if some method calls some other public method under the hood, and that's not obvious, overriding that second public method can cause unexpected behavior

[15:26] <TimToady> okay, so in P6 terms that's using $.foo when you should have said $!foo

[15:26] <moritz> TimToady: if many of the public methods are that tightly coupled (and the abstractions are a bit off), you get a mess when inheriting

[15:28] <TimToady> I think one of the important things to teach new P6 programmers will be when to write to the virtual interface and when to write to the storage directly

[15:28] <TimToady> but arguably, that's also the fault of the derived class overriding the method without properly wrapping the parent method

[15:28] <tadzik> jnthn: how can I import stuff lexically?

[15:30] <jnthn> tadzik: Same way use does?

[15:30] <moritz> spec LHF: ack for 'Scalar' and remove every mention of it that doesn't refer to an actual container

[15:30] <tadzik> well, hrm

[15:31] <tadzik> I don't really get how use does this :)

[15:31] <tadzik> my $EXPORT := $module<EXPORT>.WHO; if pir::exists($EXPORT, 'DEFAULT') { $*ST.import($EXPORT<DEFAULT>); }

[15:31] <jnthn> right.

[15:31] <jnthn> Taht imports into the current lexical scope.

[15:31] <tadzik> hmm, so I have to set my scope to a shiny new Block before calling that?

[15:32] *** daniel-s left
[15:32] <jnthn> ah

[15:32] <jnthn> Yeah, $*ST.push_lexpad()

[15:32] <jnthn> And later $*ST.pop_lexpad()

[15:32] <jnthn> iirc

[15:32] <jnthn> It imports into the current pad

[15:32] <jnthn> It only wants a PAST::Block though

[15:33] <jnthn> (import, that is)

[15:33] <jnthn> If you already have one of those to hand, we could always refactor import to take the import target block explicitly.

[15:33] <jnthn> Think I'd maybe prefer not to though

[15:33] <jnthn> Alternatively, you could skip the import and just look up the fully qualified name

[15:34] <tadzik> well, I should probably load the module lexically too

[15:34] <tadzik> so outside of my new Block, it's not visible

[15:34] <jnthn> Just loading the module doesn't import anything.

[15:34] <jnthn> It only does any globals merging

[15:34] <jnthn> Which you can't skip

[15:34] <tadzik> mhm

[15:34] <tadzik> so, how is the full name different from Foo::bar()?

[15:35] <jnthn> $*ST.symbol_lookup(['Pod','To','Text','&foo'], $/) # gets you PAST to look up the sub &Pod::To::Text::foo

[15:35] <tadzik> cool, thanks

[15:35] <jnthn> You could just put that in a PAST node

[15:35] <tadzik> yes, that sounds good

[15:35] <jnthn> Import approach works too but...probably not worth the hassle.

[15:36] <jnthn> oh, note that only works if it's an our sub :)

[15:36] <jnthn> If you want to leave it lexical you've no choice but the import :)

[15:37] <tadzik> it's an exported sub

[15:37] <tadzik> I could probably make it our

[15:40] <moritz> btw the MAIN spec patch silently swept arguments like '-foo' under the rug

[15:40] <tadzik> hmm

[15:40] <moritz> we could either make it mean the same thing as --foo, *or* -f -o -o

[15:40] *** agentzh left
[15:40] <moritz> but we'd need to decide ahead of time

[15:40] <tadzik> nom: module A { our sub b {} }; A::b()

[15:40] <p6eval> nom:  ( no output )

[15:40] <tadzik> hrm

[15:40] <moritz> and I didn't want to make the decision, so I just deleted the associated lines

[15:41] <TimToady> or -f='oo'

[15:41] <moritz> if anybody has a strong opinion either way, speak up

[15:41] <moritz> TimToady: or that

[15:41] <dalek> rakudo/nom: ac51b44 | moritz++ | src/Perl6/Actions.pm:

[15:41] <dalek> rakudo/nom: remove superfluous $MAIN lexical

[15:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac51b44fa7

[15:41] <tadzik> nom: package A { module B { our sub C {} } }; A::B::C()

[15:41] <p6eval> nom:  ( no output )

[15:41] * tadzik scratches head

[15:41] <TimToady> if we pick one, someone can always munge $*ARGS beforehand to get a differen interpretation

[15:42] <moritz> TimToady: but the mere fact that we come up with 3 different interpretations means that it might be best not to pick one

[15:42] <TimToady> it seems relatively useless to have both -foo and --foo

[15:42] <TimToady> if -foo just means --foo

[15:43] <moritz> agreed

[15:43] <TimToady> so I think if we do pick one it has to be a single letter interpretation

[15:45] <TimToady> the one thing we can't do is to make it depend on the actual switch

[15:46] *** im2ee left
[15:46] <moritz> we could, if we consulted the proto

[15:46] <tadzik> dear #perl6, do I miss something obvious? https://gist.github.com/1131995

[15:46] <moritz> but... it's a rather bad idea IMHO

[15:46] * jnthn isn't fond of that idea either

[15:46] <TimToady> so things like perl -pe 's/foo/bar/' are problematic

[15:46] <jnthn> We just got rid of the need to introspect...

[15:47] <jnthn> tadzik: odd.

[15:48] <tadzik> no, I don't have nom installed

[15:48] <moritz> TimToady: IMHO MAIN is a convenient solution to the 90% common problems, and that's one that is out of its scope

[15:48] <jnthn> yeah, but even if so...

[15:48] <jnthn> shoulda been OK

[15:48] <moritz> TimToady: likewise subcommands with options etc.

[15:48] * mberends votes for -foo == -f -o -o, principle of least surprise

[15:49] <tadzik> +1

[15:49] <crked> +1

[15:50] <mberends> it does mean perl6 -doc should probably be perl6 --doc

[15:50] <tadzik> it is

[15:50] <mberends> ok

[15:50] <moritz> tadzik: how new is your nom?

[15:51] <tadzik> nom: module Pod::To::Zebra { our sub pod2zebra(@a) {} }; Pod::To::Zebra::pod2zebra([])

[15:51] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[15:51] <tadzik> nom: goddamnit

[15:51] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[15:51] <tadzik> moritz: I'm on 3ea71cf82fe9efc07119e8388bda9244ce739f0e

[15:51] <tadzik> add missing :Ds to EnumMap, start with EnumMap.ACCEPTS

[15:51] * moritz should really make nom install on the p6eval server

[15:51] <moritz> should be new enough

[15:52] *** noganex_ joined
[15:52] <tadzik> > module Pod::To::Zebra { our sub pod2zebra(@a) {} }; Pod::To::Zebra::pod2zebra([])

[15:52] <tadzik> Could not find symbol 'Pod::To::Zebra::&pod2zebra'

[15:52] <moritz> before jnthn++'s fixes from yesterday night I had some weird errors in ::-y modules when loaded from .pir files

[15:52] <tadzik> does it work for you, locally?

[15:52] <tadzik> moritz: mine are not precompiled even

[15:53] <moritz> no

[15:53] <moritz> tadzik: I've seen that problem before

[15:53] <tadzik> yay, a bug!

[15:53] <tadzik> oh, with XML::Writer or so?

[15:53] <moritz> nom: say X::Base; say ::('X::Base')

[15:53] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[15:53] <moritz> tadzik: no, when implementing ::()

[15:53] <tadzik> mhm

[15:53] <moritz> hm, seems that particular instance is gone

[15:54] <tadzik> module Zebra { our sub pod2zebra(@a) {} }; Zebra::pod2zebra([]) # that works

[15:54] <tadzik> so it's something with :: names

[15:54] <jnthn> hm

[15:54] <jnthn> ugh.

[15:55] <tadzik> I seem to find a plenty of bugs recently

[15:55] <jnthn> nqp: module Pod::To::Zebra { our sub pod2zebra(@a) {} }; Pod::To::Zebra::pod2zebra([])

[15:55] <p6eval> nqp:  ( no output )

[15:55] <jnthn> nqp: module Pod::To::Zebra { our sub pod2zebra(@a) { say('ok') } }; Pod::To::Zebra::pod2zebra([])

[15:55] <p6eval> nqp: OUTPUT«ok␤»

[15:55] *** noganex left
[15:55] <jnthn> hm, I thought we handled things same way in nom.

[16:08] *** rdesfo left
[16:09] <jnthn> nom: module Pod::To::Zebra { our sub pod2zebra(@a) { say('ok') } }; Pod::To::Zebra::pod2zebra([])

[16:09] <p6eval> nom: OUTPUT«Could not find symbol 'Pod::To::Zebra::&pod2zebra'␤current instr.: 'die' pc 678745 (src/gen/CORE.setting.pir:159616) (src/gen/CORE.setting:370)␤»

[16:09] <dalek> 6model: d7d1a10 | (Martin Berends)++ | c/ (5 files):

[16:09] <dalek> 6model: [6model/c] gather returned data from multiple threads, Configure fixes

[16:09] <dalek> 6model: review: https://github.com/jnthn/6model/commit/d7d1a1075d

[16:09] <jnthn> nom: module Pod2::To::Zebra { our sub pod2zebra(@a) { say('ok') } }; Pod2::To::Zebra::pod2zebra([])

[16:09] <p6eval> nom: OUTPUT«ok␤»

[16:09] <jnthn> tadzik: Related what's going on.

[16:09] <jnthn> tadzik: In CORE.setting, we have a package Pod. Installed lexically.

[16:09] <tadzik> oh

[16:10] <jnthn> When we load a Pod:: ... from a module, the global merger gets it.

[16:10] <tadzik> it's a bug, or a feature?

[16:10] <jnthn> But the lexical Pod package in the setting means we never go look in the GLOBAL one.

[16:10] <jnthn> I'm not sure. :)

[16:10] <moritz> uhm

[16:11] <tadzik> module Pod::To::Zebra { our sub pod2zebra(@a) {say('ok') } }; ::Pod::To::Zebra::pod2zebra([])

[16:11] * jnthn scours S10 and S11 :)

[16:11] <tadzik> nom: module Pod::To::Zebra { our sub pod2zebra(@a) {say('ok') } }; ::Pod::To::Zebra::pod2zebra([])

[16:11] <moritz> if it were a feature, it would be pretty hard to add more X::thing classes, no?

[16:11] <p6eval> nom: OUTPUT«Could not locate compile-time value for symbol To::Zebra::pod2zebra␤current instr.: 'nqp;Perl6;SymbolTable;_block1843' pc 26033 (src/gen/perl6-symboltable.pir:9085) (src/Perl6/SymbolTable.pm:1378)␤»

[16:11] <tadzik> ekh

[16:11] *** JimmyZ left
[16:11] <moritz> or does it need to be 'my module Pod::To::Text'?

[16:11] <tadzik> moritz: probably, yes

[16:11] <jnthn> moritz: Right. Something's gotta be adrift here.

[16:11] <jnthn> I'm guessing when you do

[16:11] <jnthn> oh hm

[16:12] <jnthn> Well, we're not really meant to merge lexical packages, afaik.

[16:12] <tadzik> I could probably make Pod::To::Text core as a workaround, but I'm quite allergic to making core bigger

[16:12] <tadzik> if not me, then my RAM is

[16:13] <jnthn> no, we shouldn't have to do that

[16:19] * jnthn just re-read S10 and looked for anything in S11 and is still none the wiser.

[16:19] *** shinobicl left
[16:20] <ashleydev> moritz: re -foo, why can't it be configurable as to the meaning?

[16:20] *** shinobicl joined
[16:20] <jnthn> tadzik: For now I'd go tthe import root ;)

[16:20] *** Transformer joined
[16:21] <tadzik> jnthn: that's less than awesome in a way, that when you use --doc, pod2text() is globally visible

[16:21] <jnthn> Huh?

[16:21] <jnthn> No, import is lexical

[16:21] <jnthn> you lexically import it into your phasesr, then call it

[16:21] <tadzik> oh, I didn't do the push_lexpad thing yes

[16:21] <moritz> ashleydev: it's primarily about a sane default

[16:21] <tadzik> *yet

[16:21] <ashleydev> moritz: i.e. if -f takes args it's -f=oo, if it doesn't it's -f -o

[16:22] <jnthn> tadzik: ah, ok :)

[16:22] <tadzik> so what do pass to push_lexpad again?

[16:22] <tadzik> a fresh Block object?

[16:22] <moritz> ashleydev: because if -f takes arguments depends on the invididual multi MAIN candidate

[16:22] <moritz> ashleydev: but to do the multi dispatch, we need to process @*ARGS independently of individual candidates

[16:22] *** Transformer left
[16:23] *** shinobicl left
[16:23] <moritz> "too much magic considered harmful"

[16:23] * moritz -> decommute

[16:23] <ashleydev> moritz: does that mean there's going to be a get opt long some were?

[16:23] <ashleydev> and use built in for default stuff?

[16:23] <ashleydev> *somewhere

[16:24] <jnthn> tadzik: No

[16:24] <moritz> ashleydev: there'll be probably lots of modules that modify MAIN behavior, and others that provide different mechanisms

[16:24] <jnthn> tadzik: It creates one

[16:24] <jlaire> requiring that an option either always takes an arg or never takes an arg feels reasonable to me

[16:24] <jnthn> tadzik: And returns it to you.

[16:24] <moritz> in the far future, that is :-)

[16:24] * moritz -> really gone

[16:24] <tadzik> okay

[16:24] <jlaire> so it wouldn't depend on individual MAIN multis

[16:24] <jnthn> tadzik: Then you push your stuff into it

[16:24] <jnthn> tadzik: And do the import

[16:25] <tadzik> god it

[16:25] <jnthn> tadzik: And the pop when you're done and create a code object from it

[16:34] *** TiMBuS left
[16:36] <tadzik> setting now needs about 1.33 GBs of ram to compile

[16:37] * tadzik wonders if he'll be able to buy another 2 before the YAPC

[16:37] *** TiMBuS joined
[16:42] <tadzik> okay, works :)

[16:43] <jnthn> \o/

[16:45] * tadzik spectests, dishes won't wash themselves

[16:53] * mberends makes some nom while his computer makes nom

[16:55] *** thou joined
[17:02] *** ab5tract left
[17:05] *** rdesfo joined
[17:06] *** crked left
[17:11] <jnthn> std: module Foo { constant Bar = 42 }; Foo::Bar

[17:11] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'Foo::Bar' used at line 1␤Check failed␤FAILED 00:01 120m␤»

[17:11] <jnthn> std: my module Foo { constant Bar = 42 }; Foo::Bar

[17:11] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'Foo::Bar' used at line 1␤Check failed␤FAILED 00:01 121m␤»

[17:12] <dalek> rakudo/nom: 9ca7ef7 | moritz++ | / (3 files):

[17:12] <dalek> rakudo/nom: partially put back Temporal

[17:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ca7ef7712

[17:12] <jnthn> std: module Foo { constant Bar = 42; Bar }

[17:12] <p6eval> std 516268a: OUTPUT«ok 00:01 120m␤»

[17:12] <jnthn> TimToady: ^

[17:13] <moritz> woah, my vim hangs when opening t/spec/S32-temporal/DateTime.t

[17:13] *** pyrimidine joined
[17:13] <jnthn> ouch!

[17:13] *** benabik left
[17:13] *** benabik joined
[17:14] <tadzik> :P

[17:14] <moritz> oh, and the authors of those tests seem to have a fundamental misunderstanding on how unit tests are supposed to work

[17:15] <jnthn> When you do 

[17:15] <TimToady> jnthn: you haven't exported the constant, or imported it

[17:15] <TimToady> hmm, but you shouldn't need to...

[17:15] <jnthn> my module Foo { constant Baz = 42 }; say Foo::Baz

[17:15] <moritz> instead of providing a list of samples, they recreate the algorithm they want to test, and compare both the algorithm in the tests and in the compiler/setting

[17:15] <jnthn> Then the 'my' is leaking through to constant there.

[17:16] <jnthn> TimToady: Yeah, they're our scoped by default.

[17:16] <jnthn> TimToady: Seems $*SCOPE isn't being reset.

[17:16] <flussence> moritz: wow, I just looked at that file in gvim. I've never seen a program where all but the cursor and scrollbar are frozen...

[17:17] <TimToady> niecza: module Foo { constant Bar = 42 }; Foo::Bar

[17:17] <p6eval> niecza v8-45-g366d65b:  ( no output )

[17:17] <TimToady> niecza: module Foo { constant Bar = 42 }; say Foo::Bar

[17:17] <p6eval> niecza v8-45-g366d65b: OUTPUT«42␤»

[17:17] <TimToady> looks like niecza fixed it with the symbol table integration

[17:17] <TimToady> STD's symbol tables are kind of a kludge to work around not having real symbol tables

[17:18] <flussence> (and after looking at the file in `less`, I have no idea why vim would freeze)

[17:18] <jnthn> TimToady: It looks like $*SCOPE leakage in this case. 

[17:18] <dalek> roast: d8786c3 | moritz++ | S32-temporal/DateTime.t:

[17:18] <dalek> roast: [DateTime.t] avoid passing the same named argument twice

[17:18] <dalek> roast: 

[17:18] <dalek> roast: also remove "perl6" vim filetype, since it makes my vim freeze

[17:18] <dalek> roast: review: https://github.com/perl6/roast/commit/d8786c3eae

[17:19] <jnthn> TimToady: The symbol just never gets stuck in the package in the first place in nom because it sees the scope as "my" when it should see it as empty.

[17:19] <TimToady> that doesn't explain the non-my case

[17:20] <mberends> moritz: I wrote those Temporal tests. The algorithm in the test file is *different*.

[17:20] <jnthn> TimToady: no, but the non-my case works in nom :)

[17:20] *** dakkar left
[17:21] <jnthn> It is a bit curious because I'd expect us to go through termish and that does set $*SCOPE 

[17:21] <moritz> mberends: still an algorithm for calculating the same thing has no place in a test suite, IMHO

[17:23] <moritz> it's a classical case of over-design

[17:23] <mberends> moritz: there was a method behind that madness, to dynamically generate different test cases when run at different times, thus increasing coverage. I was not convinced that a few static points would suffice.

[17:23] * flussence runs that gvim command through callgrind and finds "regtry" taking up most of the CPU time

[17:23] <moritz> mberends: I'm not really convinced

[17:23] <flussence> .oO( whee. vimscript debugging. )

[17:23] <mberends> i see

[17:24] <PerlJam> moritz: He's successfully tested that those two algorithms produce the same output.   :-)

[17:24] <moritz> mberends: for example if both suffer from a similar kind of problem in the math implementation, both algorithms could have the same errors

[17:24] <moritz> mberends: like sign of $negative % $positive, just as a common example

[17:25] <moritz> even two very different algorithms might boil down to the same error

[17:26] <mberends> the tests for the math implementation will certainly cover those problems

[17:27] <moritz> mberends: this particular problem (in niecza) was found by an RC entry, not by the test suite

[17:28] <tadzik> Result: PASS

[17:28] <tadzik> yay :)

[17:30] <mberends> moritz: the cross check algorithm was made deliberately simple, not optimized, so that it would be easier to verify. I get your point that some people prefer absolute comparisons to variable ones.

[17:30] <jnthn> tadzik: And working --doc? :)

[17:30] <tadzik> jnthn: yes :)

[17:30] <dalek> rakudo/nom: ff8d46f | tadzik++ | src/Perl6/ (2 files):

[17:30] <dalek> rakudo/nom: Implement a default DOC INIT phaser

[17:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ff8d46f104

[17:30] <jnthn> \o/

[17:30] <jnthn> tadzik++

[17:31] <tadzik> now, S26 talks about something around: perl6 --doc LWP::Simple, but I'd rather see it in some userspace tool to be honest

[17:31] <tadzik> partly because it makes everything weird

[17:31] *** hanekomu left
[17:32] <tadzik> as in: if above works, then perl6 LWP::Simple should work too

[17:32] <tadzik> so I'd rather see it as a userspace tool that locates LWP::Simple in PERL6LIB and calls perl6 --doc on that file

[17:33] *** impious joined
[17:33] *** [Coke] left
[17:33] <jnthn> tadzik: makes some kinda sense, yes

[17:33] <tadzik> so it's my third bullet on spec tuning

[17:33] <tadzik> shame that I forgot the first one

[17:33] <PerlJam> tadzik: why not an option to perl6 for locating modules?

[17:34] <tadzik> PerlJam: I think the usecase is pretty narrow. You don't often run modules

[17:34] *** [Coke] joined
[17:34] <tadzik> I don't think it's worth it for --doc alone

[17:35] <PerlJam> Practically every perl program will "run modules"

[17:36] <PerlJam> since lots of "perldoc" functionality is being folded into perl6, why not that one too?

[17:36] <tadzik> well, not in a 'perl6 DBI' sense I think

[17:37] <PerlJam> besides, perl6 has to be able to locate the modules anyway

[17:37] <tadzik> but maybe it's a wanted feature, hence I'm asking :)

[17:37] <tadzik> that's correct

[17:37] *** thou left
[17:37] <PerlJam> It seems like a 2 birds 1 stone situation to me.

[17:38] <tadzik> and that may end up in useful stuff actually. As in no need for ~/.perl6/bin. Then we go for stuff like 'perl6 ufo', 'perl6 Module::Starter::start' or so

[17:39] <tadzik> I wonder if any other Synopsis mentions something like this

[17:39] <jnthn> nom: say pi

[17:39] <p6eval> nom: OUTPUT«3.14159265␤»

[17:40] <tadzik> nom: say pi.WHAT

[17:40] <p6eval> nom: OUTPUT«Num()␤»

[17:40] <mberends> moritz: you'll notice that only some of the Temporal tests use dynamically generated dates, and many more use fixed ones anyway. The intent of the dynamic ones was to use many tests over a long period to probe for yet untried corner cases. I've read it somewhere described as 'Monte Carlo Testing'. So far the Temporal code seems to have stood up to all those semi-random vectors.

[17:41] <tadzik> there's nothing close to 'perldoc perlrun' in Synopses it seems

[17:41] *** pernatiy left
[17:42] <pmichaud> tadzik: S19 would be the closest, I think.

[17:42] <tadzik> huh

[17:42] <tadzik>  Week #9, 17 – 23 July

[17:42] <tadzik> Make the documentation for classes, methods and subroutines accesible

[17:42] <tadzik> with the .WHY method.

[17:42] *** masak joined
[17:42] <moritz> mberends: I'll rest the case, I just don't want that paradigm to be over-used

[17:42] <masak> \o/

[17:42] <tadzik> I didn't mention all the other stuff, which means I'm pretty much done :)

[17:43] <moritz> tadzik: what about B<...> escapes etc?

[17:43] <tadzik> moritz: yes, that's still on my list

[17:43] <jnthn> masak! \o/

[17:43] <[Coke]> tadzik++ # looks like a very successful GSOC

[17:43] <masak> jnthn! \o/

[17:43] <pmichaud> tadzik++ indeed

[17:43] <tadzik> hey, I'm nod done yet! :P

[17:43] <tadzik> I meant the .WHYs

[17:44] <masak> tadzik++ # you'll get another karma when you finish :P

[17:44] <tadzik> nom nom nom

[17:44] <colomon> tadzik++

[17:44] <pmichaud> tadzik: even though you aren't done, we can count the GSOC as a big success

[17:44] <tadzik> I left formatting codes for the very end, since it's the most predictable thing

[17:44] <jnthn> tadzik++ # again, excellent work

[17:44] <moritz> agreed

[17:44] <jnthn> :)

[17:44] <tadzik> it probably won't reveal any double bacon bugs, GC bugs or so

[17:44] <tadzik> it's plain parsing, I mean, what can go wrong? :P

[17:45] <tadzik> that's why I moved the later stuff sooner, for more time to sort it out

[17:45] * jnthn suspects the GC bug is everpresent, just rare enough that we don't run into it much. :/

[17:45] <tadzik> yeah

[17:45] <tadzik> good that I ran into it

[17:45] <jnthn> I've a horrible suspicion it's something to do with mixins.

[17:45] <tadzik> moritz: I'm planning to open a list of tickets (maybe in the gsocmess repo), as a sort of countdown

[17:45] <jnthn> But a couple of goes over the code and it's hard to see what's up.

[17:45] <PerlJam> "double bacon bugs"?

[17:45] <tadzik> I'm planning to have everything done by the beginning of the YAPC

[17:45] <pmichaud> Double bacon bugs.

[17:46] <PerlJam> "double bacon" sounds more like a good thing than a buggy thing

[17:46] <pmichaud> YAPC is in.... 1 week?  ;-)

[17:46] <jnthn> I may put together some kinda stress test for that to try and trigger the GC issue.

[17:46] <tadzik> PerlJam: my @a = Array.new('bacon'); say @a # bacon bacon

[17:46] <pmichaud> PerlJam: if we're going to have bugs, we might as well have double-bacon.  :)

[17:46] <tadzik> like, two days of headscratching. "I must be doing this serialization stuff _so_ wrong"

[17:47] <colomon> pmichaud++

[17:52] *** bluescreen10 left
[17:54] <mberends> moritz: I agree, I would not recommend Monte Carlo tests very often either, because they lack some rigor. I would recommend that approach, however, when it comes to our Trig tests, because the probability of failure is very low, and our number of almost redundant passing tests is very high and costs us a too much spectest time.

[17:55] <dalek> rakudo/nom: c49a3c9 | pmichaud++ | src/core/ (2 files):

[17:55] <dalek> rakudo/nom: Re-enable hyperop assignment metaops.

[17:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c49a3c9f34

[17:55] <dalek> roast: 410d696 | pmichaud++ | S03-metaops/hyper.t:

[17:55] <dalek> roast: Unfudge hyperop assignment metaop tests.

[17:55] <dalek> roast: review: https://github.com/perl6/roast/commit/410d696f2f

[17:55] <moritz> mberends: I think a once-chosen random sample is good enough for the trig tests to

[17:56] <moritz> o

[17:56] <moritz> mberends: and yes, it should be much smaller than what we have now

[17:57] <mberends> we agree to agree, then :)

[17:57] *** noganex_ left
[17:57] *** shinobicl joined
[17:57] <jnthn> Got socket IO working again \o/

[17:58] <jnthn> Need to sort out package issues but that aside, it seems to work.

[17:59] <colomon> errr.... you guys realize the trig tests do not use a random sample, and right now they are getting close to the minimum possible to test that the many possible permutations of the functions are actually tested?

[17:59] <masak> jnthn++

[18:00] <jnthn> BTW, the trig tests now actually fail due to missing trig functions rather than inability to load the trig test support library :)

[18:00] <moritz> colomon: no

[18:00] <mberends> colomon: yes

[18:01] <moritz> colomon: since the trig implementations always use the same method under the hood, there's not much point in testing more than one combination of values for a given tuple of (function, input type)

[18:01] <colomon> moritz: which is exactly what it does

[18:01] <moritz> last time I ran them that wasn't the case

[18:01] <colomon> except for the two cases of Num and Complex, which are the core methods "under the hood"

[18:02] <colomon> moritz: that's been the case for over a year

[18:02] <colomon> I was working on that change at YAPC::NA 2010.

[18:03] <TimToady> expert testers I've heard prefer tests of selected boundary conditions over random tests, since if things are correct at the boundaries they tend to be correct away from the boundaries too

[18:03] <moritz> colomon: for example the tan.t tests repeat all Num and Complex tests for the sub and the method form

[18:03] <TimToady> and it can take a lot of random tests to trigger a boundary-condition bug

[18:04] <TimToady> so one gets a false sense of security from random testing

[18:04] <mberends> colomon: it's not a serious suggestion, but since the code is *very* stable and the failure rates are almost nil, it is almost unnecessary to test every possible permutation before every commit unrelated to trig.

[18:04] <PerlJam> is DOC a general statement prefix?

[18:04] <moritz> colomon: so there's a redundancy of a factor of nearly 2 in those tests alone

[18:05] <mberends> we're oversimplifying when we use the same suite for commit tests and spec tests.

[18:05] <PerlJam> I mean could I say  "DOC say 'foo';"  and have that only run when --doc is specified?

[18:05] <moritz> PerlJam: it's a phaser, just like BEGIN and INIT etc.

[18:05] <TimToady> mberends: well, if Perl 6 were fast enough, it wouldn't matter :P

[18:05] <moritz> nom: BEGIN say 'foo'

[18:05] <p6eval> nom: OUTPUT«foo␤»

[18:06] <moritz> and phasers work with either statements or blocks

[18:07] <mberends> TimToady: therefore you're saying it does matter :P

[18:07] *** PZt joined
[18:07] <TimToady> everything always matters, at least a little...

[18:07] <PerlJam> except antimatter

[18:08] <jnthn> Does anybody else get a hang on instants-and-durations.t?

[18:08] <jnthn> It does it to me every time...

[18:08] <moritz> jnthn: never for me

[18:08] *** bluescreen10 joined
[18:08] <jnthn> nom: say now

[18:08] <p6eval> nom: OUTPUT«Instant:1312826970.62952␤»

[18:09] <jnthn> youch! *that* hangs for me. :/

[18:09] *** noganex joined
[18:10] <jnthn> nom: say pir::time__n

[18:10] <p6eval> nom: OUTPUT«Method 'gist' not found for invocant of class 'Float'␤current instr.: 'say' pc 721306 (src/gen/CORE.setting.pir:178315) (src/gen/CORE.setting:4290)␤»

[18:10] <moritz> nom: pir::say pir::time__n

[18:10] <p6eval> nom: OUTPUT«1312827029.69941␤»

[18:11] <mberends> jnthn: it would probably hang here as well, on a win32 platform, its system time rounds to a fairly coarse granularity.

[18:11] <PerlJam> jnthn: I just ran command-line nom  and "say now" hangs for me.

[18:12] <jnthn> ouch

[18:13] <PerlJam> and when I eventually interrupt it ....

[18:13] <PerlJam> Failed allocation of 124320 bytes

[18:13] <PerlJam> Parrot VM: PANIC: Out of mem!

[18:13] <moritz> PerlJam: what about  pir::say pir::time__n  ?

[18:13] <PerlJam> (which I find odd)

[18:13] <jnthn> yeah, it noms the stack

[18:13] <moritz> PerlJam: does that also hang?

[18:13] <jnthn> The op doesn't hang here

[18:13] <PerlJam> moritz: no, that works fine

[18:14] <moritz> huh

[18:14] * jnthn is looking at the code and struggling to see how it could hang.

[18:14] <moritz> nom: pir::say pir::time__i

[18:14] <p6eval> nom: OUTPUT«1312827284␤»

[18:15] <mberends> .oO( it was so mean, it wouldn't even give you the time of day )

[18:16] <moritz> jnthn: when I uncomment the attribute declarations in src/core/Temporal.pm class DateTime, I get infinite recursion during setting compilation

[18:18] <moritz> jnthn: maybe it's the default values...

[18:18] <jnthn> meh

[18:19] <jnthn> I'm getting it doesn't happen outside of the setting?

[18:19] <moritz> correct

[18:19] <jnthn> Default values shouldn't do it

[18:20] <jnthn> moritz: Does it make a difference if they're public vs private?

[18:20] *** envi left
[18:20] <moritz> jnthn: haven't tried yet

[18:20] *** envi joined
[18:21] <jnthn> moritz: Can I see the bottom bit of the bt also?

[18:21] <jnthn> argh, I was just about to go to the shop and it's started raining really heavily :/

[18:21] <jnthn> weather--

[18:22] <mberends> jnthn: that's the cloud that was soaking .nl this morning

[18:22] <moritz> jnthn: will give you the bottom when I get it again

[18:24] <jnthn> mberends: Couldn't you have kept it? :P

[18:25] <mberends> jnthn: I tried to dispatch it to Texas, but ran out of breath

[18:26] <PerlJam> mberends: Texas appreciates the effort :)

[18:26] <flussence> mberends: that'd explain the gale-force winds here today :)

[18:28] <dalek> rakudo/nom: 362dac2 | jonathan++ | src/Perl6/Grammar.pm:

[18:28] <dalek> rakudo/nom: Prevent scope leakage, which caused my module Foo { constant Bar = 42 } to end up declaring the constant my scoped.

[18:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/362dac2e34

[18:28] <dalek> rakudo/nom: e76d280 | jonathan++ | src/Perl6/SymbolTable.pm:

[18:28] <dalek> rakudo/nom: Make a comment more accurate.

[18:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e76d280878

[18:28] <dalek> rakudo/nom: 98408a8 | jonathan++ | src/core/IO/Socket/INET.pm:

[18:28] <dalek> rakudo/nom: Get socket IO working again, or at lesat enough for it to do a HTTP request and get the result.

[18:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/98408a8e41

[18:29] <tadzik> moritz, masak: please criticise https://github.com/tadzik/gsocmess/issues

[18:29] <tadzik> everyone: feel free to add new things which you'd like to see done, I'll probably do them, GSoC or not :)

[18:30] *** y3llow_ joined
[18:30] <mberends> tadzik++

[18:30] <colomon> moritz: "for example the tan.t tests repeat all Num and Complex tests for the sub and the method form" -- what are you talking about?  Took me a while to have the time to look, but there's exactly one test of tan(Num) (not counting the tan(Inf) and tan(-Inf) tests) and tan(Complex) in the tan.t in roast.  (Exactly one test == the number needed to make sure the sub forms actually are hooked up.)

[18:31] *** sbp left
[18:32] *** Tedd1^ left
[18:32] <moritz> colomon: I was wrong about Num, but for Complex I see

[18:32] *** sbp joined
[18:32] *** Tedd1 joined
[18:32] <moritz> ok 154 - Complex.atan - 6.80678408284103

[18:32] <moritz> ok 155 - atan(Complex) - 6.80678408284103

[18:32] <moritz> ok 156 - Complex.atan - 6.80678408284103

[18:32] <moritz> ok 157 - atan(Complex) - 6.80678408284103

[18:32] <moritz> etc.

[18:33] <moritz> jnthn: not related to private vs. public - the default values go through radcalc, which loops through Str, Stringy and infix:<~>

[18:34] *** y3llow left
[18:34] *** y3llow_ is now known as y3llow

[18:37] *** soh_cah_toa joined
[18:40] <PerlJam> wrt nom's time problems, here's some thing interesting: https://gist.github.com/1132392

[18:42] *** pernatiy joined
[18:43] *** birdwindupbird joined
[18:44] <tadzik> nom: pir::time__n.WHAT.say

[18:44] <p6eval> nom: OUTPUT«Can only use get_what on a SixModelObject␤current instr.: '_block1002' pc 61 ((file unknown):13483696) (/tmp/BWaIFop9SQ:1)␤»

[18:44] <tadzik> that's probably the failreason

[18:46] <PerlJam> you mean in binding pir::time__n to a parameter of Instant.from-posix?

[18:47] <jnthn> The binder will marshall it there, but yeah, it's not ideal.

[18:47] <jnthn> moritz: Yeah, I got that too :/

[18:48] <jnthn> I spent a couple of hours trying to understand that weird loop this morning. I failed.

[18:49] <jnthn> (And just re-wrote to avoid it.)

[18:51] <dalek> specs: 35e20e2 | larry++ | S02-bits.pod:

[18:51] <dalek> specs: define coercion types, value/impl types better

[18:51] <dalek> specs: 

[18:51] <dalek> specs: We were using two different meanings of "value type", so now

[18:51] <dalek> specs: value vs implementation type is "of" type vs "container" type.

[18:51] <dalek> specs: 

[18:51] <dalek> specs: We also now have a coercive type syntax, so there's no longer

[18:51] <dalek> specs: any need for a separate 'as' trait for subs.

[18:51] <dalek> specs: review: https://github.com/perl6/specs/commit/35e20e2e4e

[18:51] <jnthn> In this case it's the literal cache.

[18:51] <pmichaud> back from lunch

[18:52] <jnthn> omg

[18:53] <TimToady> I don't expect this to be implemented right away

[18:53] <TimToady> but we've been talking about it for months

[18:54] <jnthn> TimToady: Any chance you can flesh our what coercion really means while on this?

[18:55] <colomon> moritz: you're right, you've managed to find the one case I missed eliminating.  moritz++

[18:55] <jnthn> TimToady: As in, that does Array($foo) actually do? Who gets flow of control?

[18:56] <jnthn> And is an exact type match, or just a normal type match, required in order to not need to do the coercion?

[18:56] <TimToady> normal, I'd think

[18:57] <jnthn> Yeah, that's what I did in nom.

[18:57] <jnthn> Nobody yelped yet :)

[18:57] <TimToady> the main type is just a constraint

[18:57] <jnthn> Well, the upshot is that

[18:57] <jnthn> given S < T

[18:57] <jnthn> sub foo($x as T) { }; foo(S) # doesn't need to coerce, since $x ~~ T

[18:58] <TimToady> yes, same thing, we're mostly just changing the notation, which was hateful to me

[18:58] <jnthn> Which strikes me as fine, but I'm not sure if it's what you had in mind :)

[18:58] <pmichaud> I'm confused by the new notation (more)

[18:58] <pmichaud> or, at least, I see a potential for confusion.

[18:58] <jnthn> Well, the problem is that it's not a notation change at all.

[18:58] <jnthn> You've introduced a new kind.

[18:58] <pmichaud> sub foo(Int $x) { ... }    $x must be ~~ Int

[18:59] <pmichaud> sub foo(Int() $x) { ... }   $x is Any

[18:59] <TimToady> sub foo(T() $x) is how you write that 'as T' now

[18:59] <jnthn> e.g. $x as Int was just spec'd on parameters before really

[18:59] <moritz> who do I write 'Cool $x as Int' now?

[18:59] <pmichaud> it feels weird that   Int and  Int() specify different constraints.

[18:59] <jnthn> So the coercion type just gets a slot in Parameter

[18:59] <TimToady> Int(Cool)

[18:59] <pmichaud> moritz: Int(Cool) $x

[18:59] <moritz> ok

[18:59] <TimToady> because the typ eof $x is really Int, not Cool

[19:00] <colomon> TimToady++

[19:00] <TimToady> which is why the Cool $x as Int is bogus, because it looks like you're declaring $x to be Cool, not Int

[19:00] <pmichaud> so, it's really more like  Int $x from Cool

[19:00] <tadzik> Int(Cool) looks like "make Int given Cool"

[19:01] <TimToady> just like an Int() coercion does elsewhere

[19:01] <pmichaud> okay.

[19:01] <pmichaud> and   sub foo(Int $x)  is really   sub foo(Int(Int) $x)

[19:01] <PerlJam> it's just weird to see it in a declarative spot

[19:02] <TimToady> pmichaud: you could look at it that way

[19:02] <pmichaud> so, we're talking about three types now.  There's the container type, the 'of' type, and the coercian type.

[19:02] <pmichaud> or really the "constraint" type.

[19:02] <pmichaud> (for the latter)

[19:03] <TimToady> well, constraint is probably too generic a term to use just for that

[19:03] <colomon> Util: ping?

[19:03] <pmichaud> the constraint type is the one that gets used for multidispatch

[19:03] <TimToady> that's just one place constraints are used

[19:03] <pmichaud> I'm fine if we call it something else.

[19:03] <TimToady> the of type also constrains what can be there

[19:04] <pmichaud> it does?

[19:04] <jnthn> TimToady: Do you see Foo(Bar) syntax as purely sugar for setting a container's constraint and coercion type?

[19:04] <jnthn> TimToady: Or do you see them as a first-class kind of type?

[19:04] <jnthn> (more)

[19:04] <jnthn> To eleborate, given

[19:04] <jnthn> role Foo[::T] { }

[19:04] <jnthn> Would you expect it to be possible to instantiate the role as Foo[Int(Cool)] ?

[19:05] <pmichaud> jnthn: I think it has to be more first class-ish.   my Int(Cool) @a;

[19:05] <jnthn> pmichaud: That situation isn't a problem to desugar.

[19:05] <jnthn> pmichaud: The role one would be.

[19:05] <TimToady> I'd think we should push for first class to the until we run into obstacles

[19:05] <TimToady> s/to the//

[19:05] <jnthn> (I'm not leaning either way at the moment, I'm just trying to get a good enough grip on what's needed so I can ponder it.)

[19:06] <pmichaud> jnthn: since   my Int(Cool) @a   ultimately involves  Positional[Int(Cool)], I suspect it's there.

[19:06] <pmichaud> I'm not sure how to do that without having Int(Cool) as first-class-ish.

[19:07] <TimToady> as long as we can optimize things that are known to be constant at compile time, I'm fine with making it as first class as possible

[19:07] <TimToady> my $new-wonder-type = $narrow($inner);  # :)

[19:07] <TimToady> s/inner/wide/

[19:07] <PerlJam> hmm  ....  Foo[Int](Foo[Any])

[19:08] <TimToady> PerlJam++  :D

[19:08] <masak> o.O

[19:08] <masak> I leave for like five minutes, and you guys change everything!? :P

[19:09] <jnthn> pmichaud: Aye

[19:09] <tadzik> we also renamed my to Mine

[19:09] <pmichaud> "The of type specifies what kinds of values may be stored in the 1577	

[19:09] <pmichaud> +variable"

[19:09] <masak> tadzik: and 'our' to 'Enterprise'? :)

[19:09] <pmichaud> that seems ambiguous.

[19:09] <jnthn> I suspect it means we have a CoerciveTypeHOW, like we have a GenericHOW, and various places just have to know what it means to them.

[19:10] <tadzik> masak: no, to Everyone's

[19:10] <tadzik> note the apostrophe

[19:10] <pmichaud> is it specifying the kind of value that exists in the variable after an assignment, or the type that can occur on the rhs of an assignment?

[19:10] <masak> tadzik: ooh

[19:10] <pmichaud> (or both?)

[19:10] <moritz> jnthn: I'm now trying to rewrite Mu.Str with nqp:: ops isntead of infix:<~>

[19:10] <pmichaud> my Int(Cool) $x = '13'

[19:10] <jnthn> moritz: OK, but the problem I was seeing was that we should never hit that candidate for Str

[19:10] <tadzik> you can also omit, a package, e.g. instead of $Foo::bar you can do 'DO WANT $bar'

[19:10] <jnthn> moritz: But instead should be hitting one in a subclass

[19:11] <moritz> jnthn: hm, right

[19:11] <pmichaud> ....why rewrite Mu.Str ?

[19:12] <moritz> pmichaud: a failed attempt to avoid a circularity issue while compiling constants in Temporal.pm

[19:14] <PerlJam> pmichaud: I would expect your example to mean that $x.WHAT.perl eq 'Int'

[19:14] <dalek> specs: 5645947 | larry++ | S02-bits.pod:

[19:14] <dalek> specs: some disambiguation

[19:14] <dalek> specs: review: https://github.com/perl6/specs/commit/5645947b2c

[19:14] <pmichaud> PerlJam: so, the "of" type specifies the type of the value after it's been stored in the container

[19:15] <pmichaud> but not the restriction of the values that can be passed for storage in the container

[19:15] <pmichaud> (unless the "of" type actually refers to both)

[19:15] <TimToady> unless it's coercive, in which case it specs that too

[19:15] <pmichaud> okay, so if I say    my Int(Cool) $x;   and then ask for $x.of   I'll get something that indicates both Int and Cool

[19:15] <jnthn> moritz: The underlying issue needs fixing.

[19:16] <pmichaud> (may be  VAR($x).of )

[19:16] <TimToady> in a sense, my Int() $x = expr;  is really more like my Int $x = Int(expr);

[19:16] <jnthn> It'd need VAR, yes

[19:16] <jnthn> TimToady: Yes, but what does Int($expr) really mean? :)

[19:17] <pmichaud> well, not exactly

[19:17] <pmichaud> my Int(Num) $x = 3/4;   # should fail

[19:17] <jnthn> Also, it'd affect every assignment to the variable.

[19:17] <jnthn> pmichaud: Yes, true.

[19:18] *** rdesfo left
[19:18] <pmichaud> unless, of course, the coercion only refers to binding, not assignment.

[19:19] <TimToady> coercion might imply copy semantics

[19:19] <jnthn> Then it'd never affect the initial assignment ;)

[19:19] <pmichaud> jnthn: unless that's not really an "assignment".  TimToady++ has often said that '=' in a declaration is macro-ish.

[19:19] <TimToady> I always call it pseudo-assignment

[19:20] <pmichaud> so, does the coercion apply to assignment also?

[19:20] <pmichaud> my Int(Cool) $x;    $x = prompt 'hello';

[19:20] <TimToady> why not?

[19:20] <pmichaud> I'm just verifying that it does.

[19:20] <pmichaud> If it does, then the constraint and coercion have to attach to the variable (that's fine)

[19:20] <TimToady> if anything, coercion makes binding more like assignment, if it implies "is cpoy"

[19:21] <TimToady> *copy

[19:21] <pmichaud> and "of type" really means a combination of "constraint" and "coercion"

[19:21] <jnthn> pmichaud: I suspect we'll somehow denormalize at lesat the presence of a coercion into the container.

[19:21] <jnthn> er, container descriptor

[19:21] * TimToady thinks we might even get rid of 'is copy' if that's what Foo() means

[19:21] <jnthn> s/we'll/we'd/

[19:22] <pmichaud> jnthn: I agree

[19:22] *** rdesfo joined
[19:22] <PerlJam> TimToady: except that "is copy" makes for better documenation IMHO

[19:22] <pmichaud> TimToady: well, except that  Foo $x is copy  really needs to mean  Foo(Foo) $x   somehow

[19:22] <TimToady> and we don't necessarily copy if no coercion is necessary

[19:22] <TimToady> so readonly is probably still the correct default

[19:23] <pmichaud> right

[19:23] <pmichaud> "is copy" makes what would otherwise be readonly into rw

[19:23] <TimToady> but readonly does not preclude copy

[19:23] <TimToady> well, except rw means something else

[19:23] <pmichaud> right

[19:23] <pmichaud> I meant "read write" as opposed to "is rw"

[19:23] <pmichaud> sorry.

[19:24] <pmichaud> sub abc(Foo $x is copy)   is really    sub abc(Foo(Foo) $x is copy)

[19:25] <jnthn> We do as just find today without affecting rw-ness or needing is copy.

[19:25] <jnthn> 'as' :)

[19:25] <pmichaud> is the thing in parens constrained to be a typename in order to specify an 'of type'?

[19:25] *** [Coke] left
[19:26] <pmichaud> i.e.,    Int(Cool)   and Int($x)   mean different things and likely parse differently?

[19:26] <jnthn> pmichaud: typename as in, the rule in the grammar?

[19:26] <pmichaud> jnthn: perhaps

[19:26] <jnthn> pmichaud: I was assuming we'd have the typename rule parse coercion types

[19:26] <jnthn> We'd better have

[19:26] <pmichaud> I'm trying to know how we distinguish  Int(Cool)  versus Int($x)

[19:26] <jnthn> Hm

[19:28] *** [Coke] joined
[19:29] *** donri left
[19:29] <jnthn> pmichaud: We already have to distinguish SomeSub($x) and SomeType($x), iirc.

[19:30] <pmichaud> jnthn: yes, I'm saying we now need a third case.

[19:30] <pmichaud> SomeSub($x), SomeType($x), and SomeType(OtherType)

[19:31] <jnthn> *nod*

[19:31] <jnthn> True

[19:31] <jnthn> And they all do different things

[19:31] <jnthn> Two are verbs and one is a noun for one. :)

[19:33] *** Chillance joined
[19:36] <masak> it's never really ambiguous though, as far as I can see.

[19:38] <dalek> roast: 7bf42b2 | (Solomon Foster)++ | S32-trig/generate-tests.pl:

[19:38] <dalek> roast: Remove unneeded inverse sub test, and use a better information string for the surviving equivalent test.

[19:38] <dalek> roast: review: https://github.com/perl6/roast/commit/7bf42b25e7

[19:40] <PerlJam> ::T in the context of Foo(::T) or ::T(Foo) seems weird.

[19:42] <pmichaud> yeah, it's the edge cases I'm wanting to make sure are nailed down

[19:42] <jnthn> I'm not sure Foo(::T) is meaningful

[19:42] <jnthn> oh

[19:43] <jnthn> maybe it is in the context of a signature

[19:43] <pmichaud> yeah

[19:43] <jnthn> Generally, anything generic is only valid in a context where it's got some hope of being resolved.

[19:44] <jnthn> nom: role Foo[::T] { BEGIN { T.say } }

[19:44] <p6eval> nom: OUTPUT«Cannot call a method on type variable T␤current instr.: 'nqp;Perl6;Metamodel;GenericHOW;find_method' pc 28220 (src/gen/perl6-metamodel.pir:6074) (src/gen/Metamodel.pm:181)␤»

[19:44] *** M_o_C joined
[19:44] <pmichaud> although it's more likely to be    Foo(Any) ::T $x

[19:44] <jnthn> Doubtful, that'd imply multiple prefix types.

[19:45] <pmichaud> isn't that how we do    sub(Foo ::T $x) now  ?

[19:45] <pmichaud> or is the syntax ::T Foo $x    (I never can remember)

[19:45] <PerlJam> it's Foo ::T $x

[19:45] <pmichaud> right

[19:45] <jnthn> std: sub(Foo ::T $x) { }

[19:45] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse argument list at /tmp/8A95QjbAQC line 1:␤------> [32msub[33m⏏[31m(Foo ::T $x) { }[0m␤Couldn't find final ')'; gave up at /tmp/8A95QjbAQC line 1:␤------> [32msub(Foo ::T [33m⏏[31m$x) { }[0m␤    expecting any of:␤  …

[19:46] <jnthn> nom: sub(Foo ::T $x) { }

[19:46] <p6eval> nom: OUTPUT«Could not locate compile-time value for symbol T␤current instr.: 'nqp;Perl6;SymbolTable;_block1843' pc 26033 (src/gen/perl6-symboltable.pir:9085) (src/Perl6/SymbolTable.pm:1378)␤»

[19:46] <jnthn> std: sub(Int ::T $x) { }

[19:46] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse argument list at /tmp/xLu3rVr0oz line 1:␤------> [32msub[33m⏏[31m(Int ::T $x) { }[0m␤Couldn't find final ')'; gave up at /tmp/xLu3rVr0oz line 1:␤------> [32msub(Int :[33m⏏[31m:T $x) { }[0m␤    expecting any of:␤  …

[19:46] <jnthn> oh duh

[19:46] <jnthn> std: sub foo(Int ::T $x) { }

[19:46] <pmichaud> std:  sub abc(Foo ::T $x) { }

[19:46] <p6eval> std 516268a: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/7e65W7SWVz line 1:␤------> [32msub foo(Int ::T [33m⏏[31m$x) { }[0m␤ok 00:01 120m␤»

[19:46] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤In parameter declaration, typename 'Foo' must be predeclared (or marked as declarative with :: prefix) at /tmp/3kaXEEPzwf line 1:␤------> [32msub abc(Foo[33m⏏[31m ::T $x) { }[0m␤Parse failed␤FAILED 00:01 120m␤»

[19:46] <jnthn> nom: sub foo(Int ::T $x) { }

[19:46] <p6eval> nom:  ( no output )

[19:46] <jnthn> oh, it accepts it

[19:46] <jnthn> OK

[19:46] <pmichaud> right

[19:46] <pmichaud> so

[19:47] <pmichaud> with

[19:47] <jnthn> .oO( nom is smarter than me already, dammit )

[19:47] <pmichaud> sub foo(Int(Cool) ::T $x) { }

[19:47] <pmichaud> what does the ::T capture?

[19:47] <pmichaud> the type of $x after the coercion, or the type of the argument?

[19:48] <PerlJam> pm: or both.  maybe we should start thinking of types as Foo(Foo) instead of just Foo 

[19:48] <jnthn> Tssk. Could argue it both ways :)

[19:48] <pmichaud> I don't think it can be "both"

[19:48] <jnthn> PerlJam: I find that result unlikely.

[19:49] <pmichaud> sub foo(Int(Cool) ::T $x) { ... };   foo("12")

[19:49] <jnthn> It's gonna be what $the_passed_val.WHAT returns

[19:49] <PerlJam> That's what I'm here for ... to suggest crazy things :)

[19:49] <pmichaud> ::T has to be either Int or Str, it can't be both.

[19:49] <jnthn> It's just a case of when we evaluate that, I guess.

[19:49] *** bluescreen10 left
[19:49] <pmichaud> and, of course, in the case of

[19:49] <jnthn> nom: sub foo(::T Int $x) { }

[19:49] <p6eval> nom:  ( no output )

[19:49] <jnthn> Note that

[19:49] <pmichaud> sub foo(Numeric(Cool) ::T $x) { ... };   foo($x)

[19:49] <jnthn> we could have

[19:50] <jnthn> sub foo(::B Int(Cool) ::A $x) { } # ;-)

[19:50] <pmichaud> we know that T.WHAT is almost certainly not Numeric :-)

[19:50] <jnthn> (Before and After)

[19:50] <pmichaud> I'd prefer  Int(Cool ::B) ::A

[19:50] <jnthn> (no, I don't want to implement that)

[19:50] <jnthn> :)

[19:50] <jnthn> pmichaud: hm

[19:50] <PerlJam> Is there a valid use-case for both capturing the coerced type and capturing the argument-as-passed type?

[19:50] <pmichaud> ::B captures the type of the argument, ::A captures the type of the parameter

[19:50] <jnthn> That scares me in other ways :)

[19:50] <pmichaud> PerlJam: sure

[19:51] <pmichaud> in fact, one could say

[19:51] <PerlJam> What's the use-case for the second one?

[19:51] <pmichaud> PerlJam: whenever you want to make sure that two arguments have the same type

[19:51] <pmichaud> sub abc(Int(Any) ::T $x, Int(T) $y)

[19:52] <jnthn> That argues for it being the first

[19:52] <jnthn> oh, duh

[19:52] <jnthn> You *know* what the type will be after the coercion because you had to write it right there :)

[19:52] <PerlJam> That would be:   sub abc(Int(Any) ::T $x, T $y) though, wouldn't it?

[19:52] <jnthn> (The subtype case aside)

[19:52] <pmichaud> PerlJam: no, because then $y isn't an Int

[19:52] *** birdwindupbird left
[19:53] <pmichaud> jnthn: you don't know the type of the coercion

[19:53] <pmichaud> Str.Numeric doesn't tell you the type

[19:53] <pmichaud> you just know that it's ~~ Numeric, but you don't know what  .WHAT will be.

[19:53] <pmichaud> same for Stringy

[19:54] <pmichaud> indeed, many of the core places that we'd use coercers are because we're coercing to Numeric or Stringy

[19:54] <jnthn> pmichaud: true

[19:55] *** envi left
[19:56] <pmichaud> lest there be any confusion -- I'm not at all opposed to the Int(XYZ) syntax... I just want to know exactly what it *means* (from an implementation perspective).

[19:57] <jnthn> Yes, me too

[19:57] <jnthn> And especially it's interaction with generics.

[19:57] *** rgrau joined
[19:57] <dalek> roast: 5c6b8e3 | (Solomon Foster)++ | S32-trig/ (13 files):

[19:57] <dalek> roast: Actual trig tests generated by running the "Remove unneeded inverse sub test, and use a better information string for the surviving equivalent test." patch.

[19:57] <dalek> roast: review: https://github.com/perl6/roast/commit/5c6b8e3f61

[19:59] <PerlJam> pmichaud: I still don't quite see when you'd want foo(1,4);  and foo("1","4");  but not  foo(1,"4");

[20:00] <colomon> BTW, after that change lopped another 25% of the number of trig tests, the S32-trig tests run in 50 seconds total (single threaded) on my laptop.

[20:00] <tadzik> compared to how many?

[20:02] *** bluescreen10 joined
[20:02] <pmichaud> PerlJam: many functions want to constrain the arguments to being of like types

[20:02] <pmichaud> infix:<eqv>  being one of the more obvious

[20:03] <colomon> tadzik: it was down under 2 minutes before, I'm not sure what exactly.  go back far enough, and there used to be around 1500 tests per trig function; now it's more like 150.

[20:03] <masak> 'night, #perl6

[20:03] <tadzik> masak: gnight

[20:03] <tadzik> ha, I was fast enough :)

[20:03] <tadzik> colomon: cool

[20:03] * masak stuck around a bit this time :P

[20:04] *** masak left
[20:04] <pmichaud> PerlJam: indeed, that's one of the reasons that ::T exists -- so one can capture a type and use it as a type constraint for subsequent parameters.

[20:06] <jnthn> .oO( so you know when you drew paper-rock-scissor :) )

[20:07] <PerlJam> pmichaud: what's "like type" mean?  is it the same as "same type"?

[20:08] *** am0c left
[20:09] <PerlJam> infix:<eqv> doesn't constrain it's arguments to being the same type.  It seems to care more about the "after coercion" type than the "before coercion" type

[20:12] <pmichaud> PerlJam: S06:1623

[20:13] *** wamba left
[20:16] <mberends> colomon++ # trig test golfing

[20:16] *** shinobicl left
[20:16] <colomon> mberends: eh, moritz++ noticed the redundancy.  

[20:17] <jnthn> moritz: ping

[20:19] <jnthn> moritz: I don't think I can hunt down your Temporal blocker in a short space of time, but this will avoid the issue: https://gist.github.com/1132621

[20:19] <tadzik> jnthn: simple :nocache works too

[20:19] *** MayDaniel left
[20:19] *** shinobicl joined
[20:19] <jnthn> tadzik: not in nqp

[20:19] <tadzik> I think it does

[20:19] <jnthn> nqp: foo(:a)

[20:19] <p6eval> nqp: OUTPUT«Could not find sub foo␤current instr.: '_block1000' pc 31 ((file unknown):34) (/tmp/YleomNPT6w:1)␤»

[20:19] <jnthn> huh

[20:19] <tadzik> at least I use it

[20:19] <tadzik> and it doesn't crash :P

[20:20] <jnthn> nqp: sub foo(:$a) { say($a) }; foo(:a)

[20:20] <p6eval> nqp: OUTPUT«1␤»

[20:20] <jnthn> When'd that sneak it!

[20:20] <jnthn> nqp: sub foo(:$a) { say($a) }; foo(:!a)

[20:20] <p6eval> nqp: OUTPUT«0␤»

[20:20] <jnthn> wow!

[20:20] <jnthn> How did I not know that. :)

[20:20] <tadzik> :)

[20:22] <jnthn> Dinner done...time for evening hacking.

[20:24] <pmichaud> :a and :!a have been in nqp for sometime, iirc

[20:25] * jnthn should pay more attention

[20:33] *** im2ee joined
[20:39] *** wamba joined
[20:43] <moritz> jnthn: that patch gets us a bit further, but if I uncomment more of the stuff in Temporal.pm, I get a similar infinite loop

[20:43] <jnthn> Shit.

[20:43] <moritz> this time through trait_mod<is>

[20:44] *** wolfman2000 joined
[20:44] <jnthn> OK, probably not worth any more workarounds if the underlying issue is going to show up this much.

[20:44] <jnthn> Though I've no idea what it could be.

[20:55] *** timbunce left
[20:57] *** kaare_ left
[20:59] *** george_z0rwell left
[21:01] <BinGOs> a/win 58

[21:01] *** timbunce joined
[21:03] *** miso2217 left
[21:04] *** miso2217 joined
[21:08] *** amkrankr1leuen left
[21:10] *** sivoais joined
[21:10] *** bluescreen10 left
[21:20] *** M_o_C left
[21:24] *** impiou1 joined
[21:26] *** impious left
[21:31] *** lue left
[21:33] *** timbunce left
[21:39] <dalek> 6model: 7a6f96e | (Martin Berends)++ | c/ (10 files):

[21:39] <dalek> 6model: [6model/c] add a generic threads library with simple tests

[21:39] <dalek> 6model: review: https://github.com/jnthn/6model/commit/7a6f96e4b2

[21:40] *** Mowah left
[21:40] *** timbunce joined
[21:41] *** im2ee left
[21:47] *** Patterner left
[21:49] *** Psyche^ joined
[21:49] *** Psyche^ is now known as Patterner

[22:05] *** miso2217 left
[22:06] *** miso2217 joined
[22:07] *** mj41 left
[22:11] <shinobicl> sub func(Int $x = 0, Int $y = $x + 1) { return $y }; say func; say func(3); say func(3,20);

[22:11] <shinobicl> rakudo: sub func(Int $x = 0, Int $y = $x + 1) { return $y }; say func; say func(3); say func(3,20);

[22:11] <p6eval> rakudo 922500: OUTPUT«1␤4␤20␤»

[22:12] *** tty234 left
[22:12] *** tty234 joined
[22:15] *** saaki left
[22:16] *** saaki joined
[22:18] <ruz> what are :Ds?

[22:20] <jnthn> Means the object is defined

[22:20] <jnthn> (as in, an instance, not a type-object)

[22:20] <ruz> ah

[22:21] *** timbunce left
[22:21] *** saaki left
[22:24] *** Chillance left
[22:24] *** Chillance joined
[22:32] *** rdesfo left
[22:32] *** saaki joined
[22:33] *** am0c joined
[22:42] *** tokuhirom joined
[22:53] *** rdesfo joined
[22:57] *** wamba left
[23:00] *** PacoLinux joined
[23:09] *** PacoLinux left
[23:14] *** whiteknight joined
[23:16] *** jaldhar joined
[23:18] *** PacoLinux joined
[23:21] *** molaf__ joined
[23:25] *** molaf_ left
[23:25] *** tokuhirom left
[23:25] *** tokuhirom joined
[23:30] *** tokuhirom left
[23:34] *** PacoLinux left
[23:38] *** molaf_ joined
[23:40] *** molaf__ left
[23:42] *** Alias left
[23:43] *** molaf_ left
[23:46] *** thou joined
[23:48] <dalek> roast: d30a73e | jonathan++ | S12-construction/new.t:

[23:48] <dalek> roast: Fudge a test that we probably passed for the wrong reasons.

[23:48] <dalek> roast: review: https://github.com/perl6/roast/commit/d30a73e804

[23:48] <dalek> roast: 20e88c0 | jonathan++ | S12-subset/subtypes.t:

[23:48] <dalek> roast: De-cruft subtypes.t (still assumed Int ~~ Num, had a mistake, made a bad scoping assumption). Also remove all Rakudo fudges - we pass this one in full now.

[23:48] <dalek> roast: review: https://github.com/perl6/roast/commit/20e88c020b

[23:49] <dalek> rakudo/nom: af72bd3 | jonathan++ | src/Perl6/ (3 files):

[23:49] <dalek> rakudo/nom: Start to improve and clean up package and type installation to fix some bugs and make various things work that didn't before.

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/af72bd34da

[23:49] <dalek> rakudo/nom: 1701656 | jonathan++ | src/Perl6/Actions.pm:

[23:49] <dalek> rakudo/nom: Simplify installation part of constant action method to re-use more SymbolTable code.

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1701656719

[23:49] <dalek> rakudo/nom: 53133a7 | jonathan++ | src/Perl6/SymbolTable.pm:

[23:49] <dalek> rakudo/nom: Simplify install_package_symbol; it now need only concern itself with direct, not nested, installation.

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/53133a729e

[23:49] <dalek> rakudo/nom: 6544695 | jonathan++ | src/Perl6/SymbolTable.pm:

[23:49] <dalek> rakudo/nom: Couple of symbol handling fixes.

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/65446952c0

[23:49] <dalek> rakudo/nom: bf856cd | jonathan++ | src/core/IO/Socket (2 files):

[23:49] <dalek> rakudo/nom: Move Socket to be IO::Socket and INET to be IO::Socket::INET.

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf856cd264

[23:49] <dalek> rakudo/nom: 918e8c6 | jonathan++ | src/Perl6/ (2 files):

[23:49] <dalek> rakudo/nom: Get need in place. Sketch out import, though export is a bit too incomplete for it to really work out yet.

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/918e8c64cf

[23:49] <dalek> rakudo/nom: 8863d55 | jonathan++ | t/spectest.data:

[23:49] <dalek> rakudo/nom: Run S12-subset/subtypes.t

[23:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8863d55976

[23:53] <dalek> roast: 38ff5f7 | jonathan++ | S12-methods/what.t:

[23:53] <dalek> roast: Corrections to comments and code in what.t; remove a couple of Rakudo todos. Still needs some more fixing though (both to test and to Rakudo).

[23:53] <dalek> roast: review: https://github.com/perl6/roast/commit/38ff5f7a72

[23:55] *** thou left
[23:57] *** Woodi left
[23:57] *** molaf_ joined
