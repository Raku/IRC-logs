[00:00] <[Coke]> I figured it was either c++ esoterica or a "ZOMG of course we shouldn't do that".

[00:01] * [Coke] wonders if there's a way to get tadzik's name to show up on win7's git log

[00:01] <tadzik> :)

[00:01] <tadzik> ah, this So??nierz guy...

[00:02] <[Coke]> So<C5><9B>nierz

[00:02] * tadzik sleeps

[00:05] <jnthn> tadzik: night, and segv fix pushed :)

[00:09] <dalek> rakudo/nom: 2542366 | jonathan++ | tools/build/NQP_REVISION:

[00:09] <dalek> rakudo/nom: Another NQP revision bump, to get a fix for a segfault reported by tadzik++.

[00:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2542366a2a

[00:11] <[Coke]> jnthn: makefile fix also pushed.

[00:11] <jnthn> \o/

[00:11] <jnthn> [Coke]++ [Coke]++

[00:11] <dalek> rakudo/nom: 30b59b1 | Coke++ | tools/build/Makefile.in:

[00:11] <dalek> rakudo/nom: Fix dynext build targets

[00:11] <dalek> rakudo/nom: This avoids continual re-builds on win32.

[00:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/30b59b1445

[00:12] <jnthn> [Coke]: Curious.

[00:12] <jnthn> [Coke]: Why does the patch work, ooc?

[00:14] <[Coke]> the original dynext target was for the PMCs, but also installed the ops.

[00:15] *** Alias joined
[00:15] <[Coke]> I just split it into 2 targets. less magic.

[00:17] <jnthn> nmake can't take the magic, I guess :)

[00:17] *** mj41 left
[00:20] *** fbass joined
[00:21] *** fbass left
[00:21] *** fbass joined
[00:25] <[Coke]> aye

[00:26] * sorear wonders why ruz is using perl 5.8 when 5.14 is out

[00:28] * flussence notices that other merge request that's been sitting there for months

[00:28] <dalek> roast: fa782c1 | flussence++ | fudge:

[00:28] <dalek> roast: Merge pull request #2 from felher/master

[00:28] <dalek> roast: 

[00:28] <dalek> roast: make fudge print usage instead of complaining about '' not being an file

[00:28] <dalek> roast: review: https://github.com/perl6/roast/commit/fa782c15a1

[00:28] *** ab5tract joined
[00:28] <flussence> felher++ # he wrote that

[00:29] *** nbrown left
[00:31] *** brownn joined
[00:32] <flussence> (seems like github sets Author = Committer = whoever clicks the merge button. LTA, having access to metadata like that is the reason git even exists...)

[00:34] <masak> indeed, that is a strange design choice.

[00:35] <[Coke]> 'hello'.subst('h','f').say

[00:35] <[Coke]> nom: 'hello'.subst('h','f').say

[00:35] <p6eval> nom: OUTPUT«(timeout)»

[00:37] <masak> 'night, #perl6

[00:37] *** masak left
[00:39] <[Coke]>     method substr(Str:D: $start, $length? is copy) {

[00:40] <[Coke]> the first parameter there is "self" in the method body?

[00:40] <jnthn> Yes

[00:40] <jnthn> I think the issue was actually golfed to the .match call earlier.

[00:43] <[Coke]> ? no .match in that method

[00:43] *** brownn is now known as nbrown

[00:43] *** thundergnat left
[00:43] <jnthn> [Coke]: I'm a bit confused - you showed a hang in .subst then pasted method subst*r* :)

[00:44] <[Coke]> jnthn: you're not the confused one. ;)

[00:44] <jnthn> ;)

[00:44] *** PacoLinux left
[00:48] <[Coke]> nom: 'hello'.match('h').say

[00:48] <p6eval> nom: OUTPUT«(timeout)»

[00:48] <[Coke]> jnthn: danke.

[00:48] <jnthn> nom: 'hello'.match(/h/).say

[00:48] <p6eval> nom: OUTPUT«␤»

[00:48] <jnthn> hm

[00:50] <[Coke]> Str's .match is defined as taking a Regex. will a 'h' fit in that, or is it going to some other multi?

[00:51] <jnthn> nom: 'h' ~~ Regex # I'd expect false

[00:51] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[00:51] <jnthn> It shouldn't fit in that, I'm sure

[00:51] <[Coke]> aye, false.

[00:51] <[Coke]> so it's going somewhere else. Cool's?

[00:52] <[Coke]> ah. cool is calling Str.match... with a stringy, which is probably going back to Cool...

[00:53] <[Coke]> I suspect we just need to define another match that takes a string. If that makes sense.

[00:53] *** wolfman2000 joined
[00:53] <[Coke]> or, convert a string to a Regex, then call it?

[00:53] <[Coke]> (that makes more sense to me.)

[00:54] <jnthn> hmm...not immediately sure what the semantics of .match with a string are

[00:54] <[Coke]> "Treat it as a literal" ?

[00:55] <jnthn> Could do /$the_str/

[00:55] <[Coke]> make 'asdf' match like /asdf/ ? 

[00:55] <jnthn> But not sure if that's possible in nom yet.

[00:55] <[Coke]> would make the spec test pass, I'd wager.

[00:55] *** daniel-s joined
[00:55] <jnthn> nom: my $a = 'bar'; say 'foobarbaz' ~~ /$a/

[00:55] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[00:55] <[Coke]> nom: my $a='h'; 'hello'.subst(/$a/,'f').say

[00:55] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[00:56] <jnthn> heh, I'd try it but rebuild in progress here too ;)

[00:56] <[Coke]> Method 'rxtype' not found for invocant of class 'PAST;Regex'

[00:59] <jnthn> ah.

[01:00] <jnthn> I guess nyi then.

[01:00] <[Coke]> nom: 1.say

[01:00] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[01:01] <[Coke]> zzzish

[01:02] <[Coke]> ... or not

[01:10] <dalek> rakudo/nom: d0475ef | jonathan++ | src/Perl6/Module/ (3 files):

[01:10] <dalek> rakudo/nom: Remove no longer used module-related code to avoid confusion.

[01:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d0475effb7

[01:10] <dalek> rakudo/nom: 851a48b | jonathan++ | src/Perl6/ModuleLoader.pm:

[01:10] <dalek> rakudo/nom: First cut of being able to use a module without pre-compilation. Still uses PIR or PBC if it finds it along the way; need to put back timestamp checks. Also factored in preparation for auth and version handling going back in later.

[01:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/851a48b429

[01:22] *** woosley joined
[01:25] <jnthn> Got an @*INC fix in the works but need sleep...will finish it up later

[01:25] <jnthn> night &

[01:26] <[Coke]> jnthn++

[01:27] *** isBEKaml joined
[01:29] *** whiteknight left
[01:33] *** soupified2011 left
[01:34] *** shinobicl_ joined
[01:42] *** shinobicl__ joined
[01:42] *** shinobicl_ left
[01:57] *** cooper left
[02:21] *** colomon left
[02:38] *** ab5tract left
[02:41] *** thou joined
[03:05] *** woosley left
[03:13] <isBEKaml> pugs: take 15 [1..*]

[03:13] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "["␤    expecting operator, ":" or ","␤    at /tmp/6PJtdFgsz5 line 1, column 9␤»

[03:13] <isBEKaml> pugs: take 15, [1..*]

[03:13] <p6eval> pugs: OUTPUT«Stack space overflow: current size 8388608 bytes.␤Use `+RTS -Ksize -RTS' to increase it.␤»

[03:13] <isBEKaml> :)

[03:13] <isBEKaml> rakudo: take 15, [1..*]

[03:13] <p6eval> rakudo 922500: OUTPUT«take without gather  in '&take-rw' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[03:14] <isBEKaml> niecza: take 15, [1..*]

[03:14] <p6eval> niecza v8-41-g3421bd8: OUTPUT«(timeout)»

[03:15] <isBEKaml> hey, why isn't pugs and niecza evaluating the [1..*] lazily ?

[03:15] <isBEKaml> (to anyone that's alive at this time)

[03:23] *** Su-Shee_ joined
[03:24] *** HarryS left
[03:24] <sorear> laziness

[03:25] <isBEKaml> sorear: niecza isn't evaluating it lazily out of sheer laziness? OIC. :)

[03:26] <isBEKaml> niecza: (1..*).take(15).say

[03:26] <p6eval> niecza v8-41-g3421bd8: OUTPUT«Unhandled exception: Unable to resolve method take in class Range␤  at /tmp/Q3ZXdnRQp6 line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1983 (CORE C930_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1984 (CORE module-COR…

[03:26] <isBEKaml> hmm, take not present in Range... 

[03:27] <sorear> that's spelled .[^15] now

[03:27] <isBEKaml> rakudo: Range.^methods(:local).sort.join(",").say;

[03:27] <p6eval> rakudo 922500: OUTPUT«ACCEPTS,at_pos,bounds,excludes_max,excludes_min,from,iterator,max,min,new,of,perl,pick,postcircumfix:<[ ]>,roll,to␤»

[03:27] *** Su-Shee left
[03:28] *** shinobicl__ left
[03:28] <isBEKaml> niecza: (1..*).[^15].say;

[03:28] <p6eval> niecza v8-41-g3421bd8: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15␤»

[03:29] <isBEKaml> sorear: one quick question, the ^15 -- doesn't it mean a right open range? 

[03:29] <isBEKaml> sorear:  like in ^15 == [0,15)

[03:29] <isBEKaml> sorear:  or 0<=x < 15

[03:33] <isBEKaml> rakudo: (1 .. ^15).perl.say;

[03:33] <p6eval> rakudo 922500: OUTPUT«1..15␤»

[03:33] <isBEKaml> rakudo: (1..^15).perl.say;

[03:33] <p6eval> rakudo 922500: OUTPUT«1..^15␤»

[03:35] <isBEKaml> rakudo: (^15).perl.say;

[03:35] <p6eval> rakudo 922500: OUTPUT«0..^15␤»

[03:35] *** wolfman2_ joined
[03:36] <sorear> isBEKaml: yes

[03:36] <sorear> isBEKaml: but in this context it means the list 0,1 ... 14

[03:36] <isBEKaml> niecza: [^15].perl.say

[03:36] <p6eval> niecza v8-41-g3421bd8: OUTPUT«[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]␤»

[03:37] <isBEKaml> sorear: but the list in my case starts from 1, not 0. 

[03:37] *** wolfman2000 left
[03:37] *** wolfman2_ left
[03:37] <isBEKaml> rakudo: (1..*).[^15].say

[03:37] *** Chillance left
[03:37] <p6eval> rakudo 922500: OUTPUT«123456789101112131415␤»

[03:41] *** shinobicl__ joined
[03:42] <isBEKaml> sorear: so it's like saying "with take, fetch me 15 numbers out of this infinite list" and it does so upto 15. 

[03:43] <isBEKaml> sorear: OTOH, [^15].say means "fetch me the first 15 numbers from the infinite range starting from zero" and it give me 0..14. Now, that's confusing. 

[03:43] <sorear> isBEKaml: (1..*)[5] == 6

[03:44] <isBEKaml> sorear: I see where you're coming from. My point is assigning ^ to contextual usage is very confusing. 

[03:44] *** fbass left
[03:46] <isBEKaml> like you saw above, it can lead to obi-wan errors. :)

[04:02] *** kaare_ joined
[04:12] *** am0c joined
[04:13] *** buubot_backup left
[04:17] *** tokuhirom joined
[04:18] *** shinobicl__ left
[04:31] *** shinobicl__ joined
[04:33] *** fbass joined
[04:34] *** buubot_backup joined
[04:35] *** isBEKaml left
[04:38] *** tokuhirom left
[04:39] *** am0c left
[04:39] *** tokuhirom joined
[04:40] <sorear> TimToady: ping

[04:43] *** tokuhirom left
[04:43] <TimToady> pong

[04:43] <phenny> TimToady: 06 Aug 20:38Z <sorear> tell TimToady an unreified control exception in niecza contains an int, an optional Frame (for lexotic throws), and an optional string (label).  Pass a tuple to CONTROL?

[04:44] <TimToady> seems fine, can be optimized later

[04:45] <sorear> ok

[04:48] <sorear> I wonder if we should set a spec for what next/last/redo do in CATCH

[04:48] <sorear> (or does S04:1028 count as a spec of that?)

[04:52] <TimToady> probably

[04:52] *** am0c joined
[04:54] <TimToady> as long as we consider SIMPLECATCH to not see control exceptions

[04:56] <sorear> TimToady: is the ordering of exceptions in @! semantically significant?  (Can I choose an implementation that sometimes presents them to the user in a different order?)

[04:57] <sorear> TimToady: is SIMPLECATCH a user-facing feature/

[04:58] <TimToady> not user-facing

[04:58] <TimToady> I think we should be consistent on @!, but the actual order (if it's just a linked list) could be arbitrary

[04:58] <TimToady> bbl &

[05:01] *** fbass left
[05:01] *** fbass joined
[05:03] *** soh_cah_toa left
[05:10] *** noam left
[05:26] <benabik> tadzik: Thanks for name dropping.  Ensured I grabbed the change quickly.

[05:32] *** envi joined
[05:36] *** fbass left
[05:36] *** fbass joined
[05:36] *** fbass left
[05:42] *** isBEKaml joined
[05:45] <dalek> niecza: 7afc5d4 | sorear++ | / (3 files):

[05:45] <dalek> niecza: Draft of RunCATCH, add compiler hooks to report whether CATCH/CONTROL left via &succeed

[05:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7afc5d4876

[06:04] <dalek> niecza: 1878ba3 | sorear++ | lib/Kernel.cs:

[06:04] <dalek> niecza: Complete implementation of CATCH/CONTROL

[06:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1878ba3964

[06:05] * sorear wonders if anyone would complain too loudly if niecza's version of CONTROL appeared in the spectests.

[06:07] *** mdxi joined
[06:14] <sorear> rakudo: say { die 12; CATCH { default { } } }

[06:14] <p6eval> rakudo 922500: OUTPUT«_block1092␤»

[06:14] <sorear> rakudo: say { die 12; CATCH { default { } } }.()

[06:14] <p6eval> rakudo 922500: OUTPUT«12␤»

[06:37] <ranott> why does the CATCH block not have a form that is like: try { this; } catch { that; }

[06:38] <dalek> niecza: 65df472 | sorear++ | lib/ (3 files):

[06:38] <dalek> niecza: Reimplement lives_ok and friends using CATCH/CONTROL.  Fix exposed bugs.

[06:38] <dalek> niecza: review: https://github.com/sorear/niecza/commit/65df472f42

[06:38] <sorear> ranott: to allow you to access variables from inside the tryt

[06:38] <benabik> ranott: We do have try { this; CATCH { that; } }.

[06:39] <benabik> ranott: It also matches things like BEGIN, INIT, etc.

[06:40] <sorear> also, roast contains woefully few tests for CATCH and CONTROL

[06:40] <sorear> I will have to fix this

[06:40] <sorear> (and probably find even more bugs in the latest nieczapatch along the way)

[06:40] <benabik> FIRST and LAST inside loops are also handy.  for @list { FIRST { print "List: " } print $_; LAST { say "." } }

[06:45] <isBEKaml> benabik: mkString. :P

[06:45] <benabik> isBEKaml: You can do more complex things than print in there.

[06:46] <isBEKaml> benabik: Exactly. 

[06:46] <benabik> But coming up with a complex example is somewhat difficult for me at nearly 3 AM.

[06:47] <sorear> benabik: does any implementation support FIRST and LAST yet?

[06:47] <benabik> sorear: Sadly, I don't think so.

[06:47] *** soupified2011 joined
[06:48] <benabik> Although I think they'll be most useful on the command line for -ne snippets.

[06:48] <sorear> benabik: that sounds like a feature request to me :>

[06:48] <isBEKaml> benabik: not really, implicit named values to the help. What is useful is that it could take on any iterable. Again, implicits. 

[06:48] <sorear> (actually I was planning to attack FIRST/LAST/NEXT tomorrow anyway)

[06:49] <isBEKaml> so, in that context, FIRST|LAST looks like they can take anything to be evaluated. 

[06:50] <isBEKaml> BTW, question to anyone here: Do we have join with prefix and suffixes?

[06:51] <benabik> isBEKaml: Implicit named values will help you run something at the beginning of a one liner?  I'm thinking: perl6 -ne 'FIRST { connect_to_web_service } do_thing_with_line END { close_socket }'

[06:51] <benabik> s/END/LAST

[06:52] <isBEKaml> benabik: excellent usage of Loan pattern. :)

[06:52] <isBEKaml> benabik: erm, no. Implicit named values => I was referring to Scala's mkString. 

[06:53] <sorear> benabik: I think that's more a job for INIT/END

[06:53] <benabik> isBEKaml: Yes, in a full program Loan would be good.  In a one-liner, it's nice to be able to put the initialization code somewhere.

[06:54] <sorear> What's Load?

[06:54] <sorear> n

[06:54] <isBEKaml> benabik: that's INIT block. yes. 

[06:54] <ranott> LAST phaser not yet implemented at line 1, near " }\n"

[06:54] <isBEKaml> sorear: One of the Design Patterns. From teh GoF book. 

[06:54] <benabik> When I'm writing code that's supposed to go into a loop, FIRST/LAST make more sense to me.

[06:55] <benabik> TIMTOWTDI

[06:55] <ranott> is the LAST only in nom or newer release?

[06:55] <benabik> ranott: It's only in the spec at the moment, I think.

[06:55] <sorear> ranott: LAST is not in any compiler yet

[06:55] <sorear> pugs: for 1..10 { say $_ }

[06:55] <p6eval> pugs: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[06:55] <benabik> I pay more attention to P6 the language than any implementation...

[06:55] <sorear> pugs: for 1..10 { say $_; LAST { say 5 } }

[06:55] <p6eval> pugs: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤5␤»

[06:55] <sorear> looks like Pugs has it.

[06:55] <benabik> pugs++

[06:56] <sorear> but pugs was way ahead on a lot of stuff

[06:57] <benabik> The first example I can think of for the loan pattern is in ruby:  File.open('data.txt'){|f| f.lines.map { stuff } } # file opened, passed to block, then closed

[06:57] <benabik> Scala uses it regularly too, IIRC.

[06:58] <isBEKaml> benabik: What I'm thinking of is, given the usage of Phasers, it'd be really useful for abstraction if we can pass around functions as first class parameters. 

[06:58] <benabik> isBEKaml: We can, I think.

[06:58] <benabik> nom: say &infix:<=>

[06:58] <p6eval> nom: OUTPUT«infix:<=>␤»

[06:59] <benabik> nom: my &f = { say 'hi'; }; f()

[06:59] <isBEKaml> benabik: sub abs_away(fun1, fun2, fun3) { INIT { fun1() }; fun2(); LAST { fun3() }; };

[06:59] <p6eval> nom: OUTPUT«hi␤»

[07:00] <isBEKaml> benabik: fun1, fun2, fun3 can be either in a single place or simply be different functions to do their own tasks. 

[07:00] <benabik> nom: sub test(&f) { f() }; test({ say 'hi' });

[07:00] <p6eval> nom: OUTPUT«hi␤»

[07:00] <benabik> nom: sub test(&f) { say f() }; test({ return 'hi' });

[07:00] <isBEKaml> right, the &prefix. I forgot about that. :)

[07:00] <p6eval> nom:  ( no output )

[07:01] <benabik> huh.  I bet the return returned from the wrong thing.

[07:01] <benabik> Probably the right thing, but not the one I was trying for.  :-D

[07:01] <sorear> niecza already uses the loan pattern in a couple places

[07:01] <isBEKaml> benabik: I think blocks are not treated as functions. 

[07:01] <sorear> I may never have heard of it, but... :)

[07:02] <isBEKaml> sorear++ # blind maestro with the guitar. :)

[07:02] <benabik> sorear: The GoF patterns are supposed to be "people do these things in code", not "this is how you write code."

[07:02] <benabik> But making you more aware of the common patterns helps with clean design.

[07:02] <sorear> benabik: I think the first place I saw the loan pattern and recognized it as a pattern was when I was reading SICP

[07:02] <benabik> I just heard about SICP recently…  It's on my "to read" list.

[07:03] <isBEKaml> sorear: Expanding on what benabik++ said, the goal was to present best solutions to recurrent problems in software engineering. Not exactly a "Best Practices" book. 

[07:03] <sorear> isBEKaml: the technical term for stuff you can return from is 'routine'.

[07:03] <benabik> There's a way to say "this block is a function", but I don't remember P6's syntax for it right now.

[07:04] <isBEKaml> rakudo: sub foo(&f) { f(); }; foo({say "Hi!"}.() };

[07:04] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 22␤»

[07:04] <benabik> Something like Haskell's   \x -> x + 1   stuff.

[07:04] <sorear> benabik: all blocks are functions.  I don't know what you mean.

[07:04] <isBEKaml> benabik: yes, that's what I was thinking too. lambdas.

[07:04] <sorear> {say "Hi!"} is a lambda

[07:05] <sorear> rakudo: say {say "Hi!"}.WHAT

[07:05] <p6eval> rakudo 922500: OUTPUT«Block()␤»

[07:05] <isBEKaml> sorear: look at my example hitting rakudo. 

[07:05] <benabik> Block isn't quite a Sub.

[07:05] <sorear> isBEKaml: try matching your braces correctly

[07:05] <benabik> nom: say -> { return "hi" }

[07:05] <p6eval> nom: OUTPUT«_block1010␤»

[07:05] <isBEKaml> rakudo: sub foo(&f) { f(); }; foo({say "Hi!"}.() );

[07:05] <sorear> rakudo: sub foo(&f) { f(); }; foo({say "Hi!"}.() );

[07:05] <p6eval> rakudo 922500: OUTPUT«Hi!␤Nominal type check failed for parameter '&f'; expected Callable but got Bool instead␤  in 'foo' at line 22:/tmp/6uhGeNCLdW␤  in main program body at line 22:/tmp/6uhGeNCLdW␤»

[07:05] <p6eval> rakudo 922500: OUTPUT«Hi!␤Nominal type check failed for parameter '&f'; expected Callable but got Bool instead␤  in 'foo' at line 22:/tmp/5sL6ei7pX6␤  in main program body at line 22:/tmp/5sL6ei7pX6␤»

[07:05] <benabik> nom: say (-> { return "hi" }).WHAT

[07:05] <p6eval> nom: OUTPUT«Block()␤»

[07:05] <sorear> rakudo: sub foo(&f) { f(); }; foo({say "Hi!"});

[07:05] <p6eval> rakudo 922500: OUTPUT«Hi!␤»

[07:05] <isBEKaml> rakudo: sub foo(&f) { f(); }; foo({say "Hi!"} );

[07:06] <sorear> rakudo: sub foo(&f) { say "Before"; f(); say "After"; }; foo({say "Hi!"});

[07:06] <p6eval> rakudo 922500: OUTPUT«Hi!␤»

[07:06] <p6eval> rakudo 922500: OUTPUT«Before␤Hi!␤After␤»

[07:06] <isBEKaml> sorear: nice. so that .() suffix is gone?

[07:06] <sorear> -> $a, $b { } allows you to give parameters to a block

[07:06] <benabik> nom: sub foo(&f) { print "foo" ~ f(); }; foo(-> {return "bar"})

[07:06] <p6eval> nom:  ( no output )

[07:06] <sorear> isBEKaml: you use .() where you are invoking the sub

[07:06] <sorear> isBEKaml: f() is short for &f.()

[07:07] <benabik> sorear: ^^ return seems to be returning from the line, not the block.

[07:07] <benabik> rakudo: sub foo(&f) { print "foo" ~ f(); }; foo(-> {return "bar"})

[07:07] <p6eval> rakudo 922500:  ( no output )

[07:07] <isBEKaml> sorear: Ah, I see. 

[07:07] <sorear> benabik: "return" doesn't return from blocks

[07:08] <sorear> benabik: "return" returns from routines, which are a subset of functions

[07:08] <benabik> rakudo: sub foo(&f) { print "foo" ~ f(); }; foo({"bar"})

[07:08] <p6eval> rakudo 922500: OUTPUT«foobar»

[07:08] * benabik isn't entirely thrilled with the way return works, but can live with it.

[07:08] <sorear> benabik: this is intended to support the visitor pattern.  visit(-> $node { return if condition($node) })

[07:09] <benabik> sorear: I understand that, but how do I early exit from a block.

[07:10] <sorear> benabik: use { leave 5 }

[07:10] <sorear> NYI, I think

[07:10] <benabik> rakudo: sub foo(&f) { print "foo" ~ f(); }; foo({leave "bar"})

[07:10] <p6eval> rakudo 922500: OUTPUT«Could not find sub &leave␤  in <anon> at line 22:/tmp/YYK6CkxrpJ␤  in 'foo' at line 22:/tmp/YYK6CkxrpJ␤  in main program body at line 22:/tmp/YYK6CkxrpJ␤»

[07:10] <benabik> perl6: sub foo(&f) { print "foo" ~ f(); }; foo({leave "bar"})

[07:10] <p6eval> pugs: OUTPUT«foobar»

[07:10] <p6eval> ..rakudo 922500: OUTPUT«Could not find sub &leave␤  in <anon> at line 22:/tmp/vtc3xceJc6␤  in 'foo' at line 22:/tmp/vtc3xceJc6␤  in main program body at line 22:/tmp/vtc3xceJc6␤»

[07:10] <p6eval> ..niecza v8-43-g1878ba3: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'leave' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 685 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤ …

[07:10] <sorear> usually blocks are short enough that you don't need that.

[07:11] <benabik> Heh.  pugs understood it.

[07:11] <sorear> if you want to early exit from a bloock, make it a routine

[07:11] <sorear> rakudo: sub foo(&f) { print "foo" ~ f(); }; foo(sub () {return "bar"})

[07:11] <p6eval> rakudo 922500: OUTPUT«foobar»

[07:11] <sorear> sub () isn't much of a price to pay for now

[07:11] <benabik> I've lived in ruby land for a long time.  blocks can be an entire file.

[07:11] <benabik> Ah!  sub can be expression level.

[07:11] <sorear> benabik: perl 6 blocks are not ruby blocks

[07:12] <benabik> sorear: Sure, but saying "blocks are short" isn't always true.  :-D

[07:12] <isBEKaml> pugs: sub foo(&f) { print "foo" ~ f(); print "baz";}; foo({leave "bar"})

[07:12] <p6eval> pugs: OUTPUT«foobarbaz»

[07:12] <isBEKaml> heh. pugs was cheating. :P

[07:12] <sorear> benabik: you can also have expression level methods and regexes

[07:13] <sorear> I think the only kind of Code object you can't have at the expression level is submethod

[07:13] <benabik> submethod confuses the benabik.  He should read the spec.

[07:13] <sorear> maybe you could, but it wouldn't make any sense

[07:14] <sorear> benabik: submethods are non-inheritable methods

[07:14] <isBEKaml> IIRC, submethods are private methods. 

[07:14] <sorear> niecza: class A { submethod foo() { } }; class B is A { }; A.foo; B.foo

[07:14] <p6eval> niecza v8-43-g1878ba3: OUTPUT«Unhandled exception: Unable to resolve method foo in class B␤  at /tmp/67cLeK1OIT line 1 (MAIN mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1983 (CORE C930_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1984 (CORE module-CORE @ 5…

[07:14] <sorear> isBEKaml: no

[07:14] <isBEKaml> of course, you could create private methods by prefixing ! to the method names too. 

[07:15] <sorear> submethods can be called from outside the class, but only on the exact type

[07:15] <sorear> see above

[07:15] <benabik> That's odd.

[07:15] <sorear> private methods cannot be called from outside the class (except with trusts)

[07:15] <isBEKaml> sorear: tell more. that looks like protected. 

[07:16] <isBEKaml> sorear: but you also mentioned that they canot be inherited. 

[07:16] <isBEKaml> that's odd.

[07:16] <sorear> isBEKaml: I don't think submethod has anything whatsoever to do with access control

[07:17] <benabik> It's inheritance control, which is… odd.

[07:17] <sorear> A.foo cannot ever be called in such a way that self ~~ B

[07:17] <sorear> ever

[07:17] <sorear> private or protected methods restrict CALLER::, submethods restrict self

[07:18] <sorear> benabik: yeah.  I understand how submethods work, but not why anyone would ever want one

[07:18] <isBEKaml> sorear: from what you say, it's like submethods are meant to be in just one place, never to be called from self but from other classes of the same type. 

[07:18] <benabik> no clue

[07:19] <isBEKaml> sorear: I don't see why that's needed... 

[07:19] <sorear> isBEKaml: neither do I.

[07:19] <sorear> note however that BUILD is required to be a submethod

[07:21] * isBEKaml goes looking at spec

[07:24] *** thou left
[07:26] <isBEKaml> rakudo: class A { submethod foo { say "A"; }; }; class B is A { submethod foo { say "B"; }; }; A.foo; B.foo

[07:26] <p6eval> rakudo 922500: OUTPUT«A␤B␤»

[07:29] <isBEKaml> rakudo: class A { method foo { say "foo A"; }; submethod foo { say "A"; }; }; class B is A { submethod foo { say "B"; }; }; A.foo; B.foo

[07:29] <p6eval> rakudo 922500: OUTPUT«A␤B␤»

[07:29] <isBEKaml> rakudo: class A { method !foo { say "foo A"; }; submethod foo { say "A"; }; }; class B is A { submethod foo { say "B"; }; }; A.foo; B.foo

[07:29] <p6eval> rakudo 922500: OUTPUT«A␤B␤»

[07:29] <isBEKaml> sorear: this is in conflict with the spec in S12:652

[07:30] <isBEKaml> ?

[07:30] <sorear> isBEKaml: 'Conjecture:' means proposed future change, not a currently binding part of the spec

[07:31] <isBEKaml> sorear: I understood that to be a proposed usecase/scenario. 

[07:31] *** Mowah joined
[07:33] <sorear> walk&

[07:42] *** moritz_ joined
[07:42] <moritz_> \o

[07:43] <mberends> o/

[07:44] <ranott> how do I have the for loop assign to an array with n at a time?

[07:45] <ranott> right how I am using the simplified: for @j -> $x,$y,$z

[07:47] <moritz_> my @copy = @orig; while @copy.splice(0, $n) -> @var { say @var.join } 

[07:47] <ranott> thanks moritz_

[07:48] *** moritz_ is now known as moritz

[07:51] *** woosley joined
[07:53] <moritz> phenny: tell jnthn re bumping PARROT_REVISION in nqp, i thought we were supposed to stick to parrot 3.6.0 in order to allow a release of nom on top of latest released parrot

[07:53] <phenny> moritz: I'll pass that on when jnthn is around.

[07:54] *** agentzh joined
[08:03] *** wamba joined
[08:04] *** shinobicl__ left
[08:04] <sorear> moritz: hi

[08:05] <moritz> hi sorear, glad to see that you've made much progress on phasers and exceptions

[08:25] *** Mowah left
[08:29] *** Su-Shee_ is now known as Su-Shee

[08:29] *** agentzh left
[08:30] *** pernatiy left
[08:31] *** pernatiy joined
[08:31] *** SHODAN joined
[08:34] *** HarryS joined
[08:42] *** agentzh joined
[08:48] *** soupified2011 left
[09:02] *** tokuhirom joined
[09:37] *** im2ee joined
[09:45] *** whiteknight joined
[09:57] *** amster joined
[10:03] *** amster left
[10:10] *** amster joined
[10:17] *** mj41 joined
[10:19] *** kaare_ left
[10:22] *** xinming joined
[10:26] *** masak joined
[10:26] <masak> good day, #perl6

[10:29] <masak> sorear++ # blazing a trail into exceptions and stuff

[10:29] <sorear> o/ masak

[10:29] <masak> \o

[10:29] * masak makes himself some breakfast

[10:33] <amster> allo #perl6

[10:34] <masak> allo allo, amster 

[10:34] <sorear> masak: short term agenda: write tests for newly-concrete CATCH and CONTROL semantics. play with FIRST/LAST/NEXT.

[10:35] *** jlaire joined
[10:36] <masak> sounds wonderful.

[10:36] <masak> I enjoy every little step of the progress, so make sure to develop noisily ;)

[10:38] <amster> i wonder what language is NQP... is it bnf-able ? and is Rakudo (near) completly written in it ?

[10:40] <jnthn> NQP is a subset of Perl 6.

[10:40] <phenny> jnthn: 07:53Z <moritz> tell jnthn re bumping PARROT_REVISION in nqp, i thought we were supposed to stick to parrot 3.6.0 in order to allow a release of nom on top of latest released parrot

[10:40] <jnthn> moritz: Hm, I don't remember hearing that. :S

[10:41] <jnthn> amster: A lot of Rakudo is written in NQP.

[10:41] <sorear> virtually all of Rakudo proper is written in NQP

[10:41] <jnthn> amster: It's built-ins are mostly written in full-blown Perl 6. But the parser, actions, meta-objects etc is in NQP

[10:41] <sorear> the term "Rakudo" refers to a compiler and a standard library

[10:42] <amster> is it easy write NQP parser ?

[10:42] <sorear> NQP's parsers are as powerful as those of Perl 6

[10:42] <sorear> ooooh, another one from .pl

[10:44] <amster> hmm ?

[10:44] * sorear out

[10:44] <jnthn> amster: Do you meant, easy to write a parser in NQP, or a parser for NQP? :)

[10:47] <amster> i had hope nqp is simpler then perl6 and that can be simpler to write plain c/c++ compiler for it

[10:49] <jnthn> It's simpler

[10:50] <amster> but still not lexable/bisonable ? :)

[10:50] <jnthn> Well, it's parsed using itself, using a Perl 6 grammar. :)

[10:50] <jnthn> I'm not sure how far you'd get with lex/bison.

[10:50] <tadzik> good morning Rakudae

[10:50] <moritz> \o

[10:50] <jnthn> Trouble is that, depending on what you want to do, that path doesn't tend to lead to the right place.

[10:51] * moritz just finished the HPMoR podcasts

[10:51] <jnthn> o/ tadzik 

[10:51] <tadzik> moritz: podcasts?

[10:51] <moritz> tadzik: http://hpmor.libsyn.com/

[10:51] <moritz> only up to chapter 17 so far

[10:53] <moritz> phenny: tell sorear that 'make test' dies with 'Unhandled Exception: No value for parameter @y in Test rxtest'

[10:53] <phenny> moritz: I'll pass that on when sorear is around.

[10:59] *** Trashlord left
[11:04] <tadzik> jnthn: comments on https://gist.github.com/1130292 ?

[11:12] <masak> amster: lex and bison are not really comparable to the parsing of NQP and Perl 6. they slice up the problem space differently.

[11:14] <moritz> maybe somebody[tm] should write a blog post about who different the approach is

[11:14] <moritz> s/who/how/

[11:14] <moritz> the question/suggestion comes up with some regularity after all

[11:17] <masak> aye.

[11:18] <masak> we don't want to compare ourselves to lex and bison, we want to supplant them :)

[11:18] *** woosley left
[11:21] *** im2ee left
[11:22] *** im2ee joined
[11:23] <tadzik> Tested and works. And I remember doing the same thing for master (ng?) few months ago :)

[11:23] <tadzik> dalek, make an entrance

[11:23] <tadzik> hmm

[11:23] * jnthn pokes dalek 

[11:23] <tadzik> oh

[11:23] <jnthn> I want my pre-breakfast karma!

[11:23] <tadzik> no no, it's not pushed

[11:24] <tadzik> oh, it is

[11:24] <dalek> rakudo/nom: c1fdc43 | jonathan++ | src/Perl6/M (2 files):

[11:24] <dalek> rakudo/nom: Fix usage of @*INC for locating modules.

[11:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c1fdc4368e

[11:24] <tadzik> dalek: what about me?

[11:24] <jnthn> tadzik: That's most of the way there. (more)

[11:25] <jnthn> When we do load_setting, I think we should note the mod time of the setting, and make sure the PIR is newer than that too.

[11:25] <dalek> rakudo/nom: 065f220 | tadzik++ | src/Perl6/ModuleLoader.pm:

[11:25] <dalek> rakudo/nom: [ModuleLoader] Load pirs or pbcs only if they aren't older than the pm file

[11:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/065f220d49

[11:26] <jnthn> That'll avoid issues where people pre-compiled against an older version of the setting.

[11:26] <tadzik> hmm

[11:27] <tadzik> omkay, breakfast first :)

[11:27] <jnthn> Same :)

[11:30] <dalek> rakudo/nom: a31ca33 | jonathan++ | NOMMAP.markdown:

[11:30] <dalek> rakudo/nom: Remove a completed item from nommap.

[11:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a31ca33bff

[11:33] *** REPLeffect left
[11:36] *** amster left
[11:42] <moritz> running a module from precompiled PIR produces an IMCC syntax error

[11:42] <moritz> it doesn't seem to know about the  fixiup_outer_ctx  opcode

[11:45] * moritz doesn't know about it either

[11:45] <moritz> *fixup

[11:46] <jnthn> Oddness.

[11:46] <moritz> where does that op come from?

[11:46] <jnthn> What do you mean by "running it from precompiled PIR"?

[11:47] <jnthn> It's in perl6.ops

[11:47] <moritz> 'use XML::Writer;', when it's precompiled from PIR

[11:47] <jnthn> Curious - we use Test.pir just fine.

[11:47] *** REPLeffect joined
[11:48] <jnthn> moritz: Does it have any dependencies? Where can I find it?

[11:48] *** bbkr1 left
[11:48] <moritz> curious indeed... it dies from the test harness, but works when I simply do PERL6LIB=... perl6 -e 'use XML::Writer'

[11:48] *** Trashlord joined
[11:48] <jnthn> oh.

[11:48] * moritz tries  git clean -xdf

[11:49] *** bbkr1 joined
[11:49] <moritz> seems to be false alarm

[11:49] <moritz> .u checkmark

[11:49] <phenny> moritz: Sorry, no results for 'checkmark'.

[11:50] <moritz> ☑ XML::Writer is nom-ready

[11:50] <moritz> now if only ufo worked with nom... :-)

[11:50] <tadzik> it almost works

[11:50] <moritz> it needs MAIN

[11:50] <moritz> iirc

[11:50] <tadzik> it needs .match

[11:51] <tadzik> MAIN can be workedaround, I did that

[11:51] <tadzik> .match is broken

[11:51] <tadzik> nom: "foo bar baz".match('bar'); say 'alive'

[11:51] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[11:51] <tadzik> well, it hangs

[11:51] <moritz> oh.

[11:51] <tadzik> maybe that can be workearound too with regexes

[11:52] <tadzik> it's the .match from .substr

[11:52] <tadzik> * .subst

[11:52] <moritz> oh I see

[11:52] <moritz> it's just NYI

[11:52] <jnthn> aha :)

[11:52] <jnthn> Glad it was false alarm :)

[11:52] <moritz> master just wrapped the matcher in a regex

[11:53] *** im2ee left
[11:53] *** im2ee joined
[11:53] *** JimmyZ joined
[11:54] <moritz> jnthn: do private multis work in nom?

[11:55] <jnthn> moritz: Hm. I fear they may not right off.

[11:56] <moritz> ah well, I'll make the method public for nwo

[11:58] <jnthn> nom: class A { multi !m() { } } # curious...

[11:58] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[11:58] <tadzik> LOONG

[11:58] <moritz> it needed to rebuild nqp too

[11:58] <jnthn> We have make install now, so in theory that's fixable :)

[11:59] <tadzik> > perl6  

[11:59] <tadzik> Incorrect pre-compiled version of src/stage2/gen/nqp-mo.pm loaded

[11:59] <tadzik> hrm

[12:00] *** kaare_ joined
[12:00] <jnthn> Ouch.

[12:00] * moritz spectests a patch for Str.match(Str)

[12:01] <jnthn> tadzik: Can happen if you end up with a different NQP installed than the one you built against, somehow.

[12:02] <moritz> would you like to have $haystack.index($needle) return a Match object?

[12:02] *** JimmyZ left
[12:02] <jnthn> I'd expect an integer I guess :)

[12:03] <tadzik> too

[12:03] <moritz> and the Match object from self.match($str) then, ok

[12:08] *** JimmyZ joined
[12:08] <JimmyZ> nom: class A { multi !m() { } }

[12:08] <p6eval> nom: OUTPUT«Malformed block at line 1, near "!m() { } }"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[12:08] <JimmyZ> nom: class A { multi method !m() { } }

[12:08] <p6eval> nom: OUTPUT«Private multi-methods are not supported at line 1, near "}"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23611 (src/stage2/gen/NQPHLL.pir:6348) (src/stage2/gen/NQPHLL.pm:329)␤»

[12:11] <tadzik> nom: my $a = "foo bar baz"; $a ~~ s:g/bar/zebar/; say $a

[12:11] <p6eval> nom: OUTPUT«Method 'clone' not found for invocant of class 'Sub'␤current instr.: '_block1002' pc 122 ((file unknown):58114447) (/tmp/CRXewoC78D:1)␤»

[12:12] <JimmyZ> nom: say [1..10].[{*-1}(*)] # JimmyZ  wrote this code, but he doesn't know what it means

[12:12] <p6eval> nom: OUTPUT«10␤»

[12:13] <tadzik> I don't get the {*-1}(*) part

[12:13] <tadzik> nom: say [1..10].[{*-1}]

[12:13] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:13] <JimmyZ> me too

[12:14] <moritz> {...} is a closure

[12:15] <moritz> and (*) calls it with * as its argument

[12:15] <moritz> so it binds $_ to *, but since $_ isn't use, that part is ignored

[12:15] <moritz> it just return *-1

[12:15] <flussence> nom: say ([1..10].[*]).perl

[12:15] <moritz> which works just as  .[*-1]

[12:15] <p6eval> nom: OUTPUT«(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)␤»

[12:15] <JimmyZ> nom: say [1..10].[{$^a-1}(*)] # but this one  doesn't work

[12:15] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:15] <flussence> nom: say {*-1}([1..10].[*]).perl

[12:16] <p6eval> nom: OUTPUT«_block1014␤»

[12:16] <flussence> nom: say {*-1}([1..10].[*])

[12:16] <p6eval> nom: OUTPUT«_block1014␤»

[12:16] <flussence> nom: say [1..10].[{*-1}([1..10].[*])]

[12:16] <p6eval> nom: OUTPUT«10␤»

[12:16] <flussence> nom: say {*-1}([1..10].[*]).()

[12:16] <p6eval> nom: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤current instr.: '_block1014' pc 407 ((file unknown):50384380) (/tmp/7YkjGm9Y2u:1)␤»

[12:16] <flussence> something like that.

[12:17] <flussence> the second * gets evaluated first

[12:18] * flussence wants to be able to write something like { [1..10].[{*-1}(*)] }.perl.ast.pretty to figure out what order that runs in

[12:20] <JimmyZ> nom: say [1..10].[{$_-1}(*)]

[12:20] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:22] <masak> flussence: you're more likely to get .ast directly from the block than from the .perl Str.

[12:22] <flussence> hm, you're right :)

[12:23] <JimmyZ> nom: say {$_-1}(10)

[12:23] <p6eval> nom: OUTPUT«9␤»

[12:23] <masak> flussence: more generally, treating code as a one-dimensional string is sinful :P

[12:23] <JimmyZ> nom: say [1..10].[{$_-1}(*)] # JimmyZ wonders why it doesn't work :(

[12:23] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:25] <JimmyZ> nom: say [1..10].[{$_-1}(10)]

[12:25] <p6eval> nom: OUTPUT«10␤»

[12:26] <moritz> something is decidedly broken in rakudo's module loading

[12:26] <moritz> I have a copy of rakudo in which I ran 'make install'

[12:26] <flussence> .oO( maybe .perl return the parse tree, which stringifies to the code... )

[12:26] <moritz> I modified an src/core/ file

[12:26] <moritz> and after 'make', I get

[12:27] <moritz> $ /perl6 -e 'say 1'

[12:27] <moritz> Could not find Perl6::Metamodel in any of: /home/moritz/.perl6/lib, /home/moritz/p6/rakudo/install/lib/parrot/3.6.0-devel/languages/perl6/lib, .

[12:27] <masak> JimmyZ: probably because an *actual* Whatever gets sent in to that closure. the .[] doesn't get to intercept it, as usually happens.

[12:27] <flussence> .oO( maybe I shouldn't be trying to perl6 before I'm fully awake :)

[12:27] <moritz> then I ran 'make install'

[12:27] <moritz> now I get

[12:27] <moritz> $ ./perl6 -e 'say 1'

[12:27] <moritz> Could not locate Perl 6 code object

[12:27] <JimmyZ> masak:  my bug or rakudo bug? or how can I fix it?

[12:28] <kboga> moritz: I can confirm that.

[12:28] <flussence> +1

[12:28] <moritz> JimmyZ: a bug in your code

[12:28] <JimmyZ> ./perl6 -e '' goes into Interactive Mode

[12:28] *** rdesfo joined
[12:29] <JimmyZ> moritz: I doesn't know how to fix it 

[12:29] <JimmyZ> s/doesnt/don't/

[12:29] *** am0c left
[12:29] <moritz> JimmyZ: just don't write {$_ - 1}(*) :-)

[12:29] <moritz> the whatever-currying happens at compile time

[12:30] <moritz> so it really needs a syntactic *, not a variable which is later bound to a Whatever at run time

[12:30] <JimmyZ> nom: say [1..10].[(-> $a {$a -1} )(*) ] #this one doesn't work too.

[12:30] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:30] <moritz> JimmyZ: same problem, except that you now wrote $a instead of $_

[12:31] <moritz> JimmyZ: what do you want to achieve?

[12:31] <moritz> why not just  *-1  or { $_ - 1} ?

[12:31] <JimmyZ> moritz: something my $result = @array[func(*)];

[12:33] <moritz> JimmyZ: then just write @array[&func]

[12:33] <JimmyZ> nom: say [1..10].[{$_ -1}]

[12:33] <moritz> JimmyZ: @array's postcircumfix:<[ ]> will call it with the right arguments

[12:33] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:33] <moritz> hm, I think that should work

[12:34] <masak> me too.

[12:34] <moritz> nom: say WhateverCode ~~ Callable

[12:34] <p6eval> nom: OUTPUT«Bool::True␤»

[12:34] <masak> nom: say WhateverCode ~~ Cool

[12:34] <p6eval> nom: OUTPUT«Bool::False␤»

[12:34] <moritz> changing s/WhateverCode/Callable/ in src/core/Any.pm line 115 might fix that

[12:35] <JimmyZ> nom: sub func($a) { $a/2}; [1..10].[&func(*)];

[12:35] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤current instr.: 'Numeric' pc 677673 (src/gen/CORE.setting.pir:171927) (src/gen/CORE.setting:445)␤»

[12:35] <moritz> but I'm spectesting an unrelated thing right now

[12:35] <JimmyZ> well, seems &func doesn't work too

[12:35] <moritz> so that needs fixing

[12:35] <JimmyZ> rakudo: sub func($a) { $a/2}; [1..10].[&func(*)];

[12:36] <p6eval> rakudo 922500: OUTPUT«Cannot take numeric value for object of type Whatever␤  in 'Any::Numeric' at line 1496:src/gen/core.pm␤  in 'infix:</>' at line 1:src/gen/core.pm␤  in 'func' at line 22:/tmp/YsRWzLudSh␤  in main program body at line 22:/tmp/YsRWzLudSh␤»

[12:36] <JimmyZ> rakudo: sub func($a) { $a/2}; [1..10].[&func];

[12:36] <p6eval> rakudo 922500:  ( no output )

[12:36] <jnthn> moritz: Hmm, some breakage after installation?

[12:37] <moritz> jnthn: yes

[12:37] <JimmyZ> rakudo: sub func($a, $b) { $a/2}; say [1..10].[&func];

[12:37] <p6eval> rakudo 922500: OUTPUT«6␤»

[12:37] <JimmyZ> rakudo: sub func($a, $b) { $a/2; $b/3}; say [1..10].[&func];

[12:37] <p6eval> rakudo 922500: OUTPUT«4␤»

[12:37] <jnthn> moritz: What breaks? The installed version, or any future builds you do in the build directory?

[12:38] <moritz> jnthn: running ./perl6 after another build

[12:38] <moritz> from within the build dir

[12:38] <jnthn> ok, so make install, make, ./perl6 = boom?

[12:39] * jnthn tries it

[12:39] <moritz> after make install; change some core files; make; ./perl6 == boom

[12:39] <moritz> and a 'make install' doesn't help

[12:39] <moritz> s/a/another/

[12:39] <moritz> just changes the error mode

[12:40] <jnthn> OK. I somewhat suspect the @*INC patch.

[12:41] <moritz> I suspected that it looks for files in the install dir before the build dir

[12:42] <jnthn> nom: say @*INC

[12:42] <p6eval> nom: OUTPUT«lib /home/p6eval/.perl6/lib /home/p6eval/nom/install/lib/parrot/3.6.0-devel/languages/perl6/lib .␤»

[12:42] <jnthn> er

[12:42] <jnthn> Well, yeah, if we shove . on the end it's gonna.

[12:43] <jnthn> oh, actually there's a simpler breakage

[12:43] <jnthn> run perl6 in the build directory immediately after make install.

[12:43] <moritz> why does *that* break?

[12:44] <moritz> I mean it should get the same versions of the same files, regardless of where it looks

[12:44] <jnthn> Right, that's what's confusing me lots.

[12:44] *** woosley joined
[12:44] <jnthn> And the error is "Could not locate Perl 6 code object"

[12:45] *** PacoLinux joined
[12:45] *** PacoLinux left
[12:45] <moritz> that's what I got after a repeated 'make install' too

[12:45] *** PacoLinux joined
[12:47] <jnthn> oh

[12:47] <jnthn> I have a horrible feeling that at some point we load two different versions of the setting or something.

[12:47] * jnthn adds a bunch of debug stuff

[12:50] *** Mowah joined
[12:52] <jnthn> moritz: I think I see what's going on. @*INC contains one search order.

[12:53] *** amster joined
[12:53] <jnthn> Before we have a setting loaded, though, we just have a "should at least find us the setting" list of places to look.

[12:54] *** ssqq joined
[12:54] <ssqq> hello all

[12:54] <jnthn> @*INC we've seen. The other one is: ., blib, the perl6 language directory and the nqp language directory

[12:54] <jnthn> ssqq: hello

[12:56] <jnthn> moritz: https://gist.github.com/1130351 dumps some info about what it's looking for and finding, which may help clarify things.

[12:56] <masak> ssqq: hi!

[12:56] <ssqq> I came from china ,and i first use IRC. I am learnin Perl about one year pass half

[12:57] <ssqq> I want to know how to input the symbol of like '<<' in Perl6

[12:57] <moritz> ssqq: on linux, Compose < <

[12:58] <moritz> ssqq: for me, AltGr + x also produces «

[12:58] <moritz> ssqq: it depends on your system, really

[12:58] <flussence> (oh wait, I'm an idiot. That merge yesterday didn't lose any metadata at all, it just added a commit for the merge itself...)

[12:58] <dalek> roast: 0fbf292 | flussence++ | fudge:

[12:58] <dalek> roast: Merge pull request #5 from ruz/fudge-perl-5.8-compat

[12:58] <dalek> roast: 

[12:58] <dalek> roast: [fudge] return back compatibility with perl 5.8

[12:58] <dalek> roast: review: https://github.com/perl6/roast/commit/0fbf29215b

[12:58] <flussence> (which dalek doesn't show for some reason...)

[12:58] <ssqq> I used vim on Windows xp

[12:59] <moritz> vim allows Ctrl-k < <

[12:59] <ssqq> I try it now

[12:59] <flussence> ssqq: ":help digraphs" might be useful

[12:59] <moritz> or :digraphs

[13:01] *** athomason left
[13:01] <jnthn> moritz: I see what's going on. Ew.

[13:01] *** PacoLinux left
[13:01] <jnthn> # Locating setting CORE

[13:01] <jnthn> #    ... found setting at ./CORE.setting.pbc

[13:01] <jnthn> # Looking for Perl6::Metamodel ...

[13:01] <jnthn> #    ...chosen pre-comp candidate blib/Perl6/Metamodel.pbc

[13:01] <jnthn> # Locating setting CORE

[13:01] <jnthn> #    ... found setting at C:/Consulting/rakudo/install/lib/parrot/3.6.0-devel/languages/perl6/lib/CORE.setting.pbc

[13:02] <jnthn> moritz: After default @*INC is set up it finds a different CORE.setting

[13:02] <jnthn> But of course it brings in all the same Parrot subs we already loaded, which explodes

[13:02] <jnthn> moritz: Is there a reason that '.' is on the end of @*INC?

[13:03] <JimmyZ> ssaa: 你好，来自北京？

[13:04] <mj41> hi, the first dashboard of my GoodData.com Perl 6 project ... https://github.com/mj41/Perl-6-GD/raw/master/export/Summary%20-%20Compilers%27%20features%20-%20GoodData.png

[13:04] <flussence> jnthn: so that "use ModuleInCurrentDir" works?

[13:04] <jnthn> flussence: That'd work if it was on the start of @*INC too :)

[13:04] <jnthn> (I'm asking why it's where it is, not why it's there at all. :))

[13:05] <ssqq> Thanks a lots I can input it

[13:05] <ssqq> Jimmmy I came from Shenzhen

[13:05] <JimmyZ> ssqq: me too

[13:06] <ssqq> O, thats great

[13:06] <moritz> jnthn: I think people dislike the idea of having it in front, because of accidentally loading the wrong module

[13:06] <JimmyZ> :)

[13:06] <jnthn> .oO( Shenzhen.pm )

[13:06] <moritz> jnthn: but I fear we have to put it in front, just like master does

[13:06] <moritz> rakudo: say ~@*INC

[13:06] <p6eval> rakudo 922500: OUTPUT«lib /home/p6eval/.perl6/lib /home/p6eval//p2/lib/parrot/3.6.0-devel/languages/perl6/lib .␤»

[13:06] <moritz> huh?

[13:06] <moritz> oh, but it also suffers from some problems

[13:06] <jnthn> Well, master doesn't have a loadable setting so it won't hit the problem so immediately.

[13:07] <jnthn> but yes, it'll suffer somewhre.

[13:07] <moritz> like prefering the installed Test.pm over the the local one

[13:07] <jnthn> Right. That's what we'd get here - apart from the installed Test.pm will actually not work at all.

[13:07] <moritz> which people didn't complain about much, because Test.pm isn't touched very often

[13:07] <jnthn> Yeah, but nom can't load versions of pre-compiled stuff that weren't compiled against the exact same build of the compiler.

[13:08] <jnthn> Which tends to be a blessing because you can't get weird accidents from left around PIR files.

[13:08] <jnthn> But does kinda force us to deal with the issue. :)

[13:08] <ssqq> The new branch of perle6 develop planning will be more faster than rakudo?

[13:09] <ssqq> If have any planning to run Perl5 code in perl6 compiler?

[13:09] <jnthn> moritz: The other thing I can do is stash loaded settings just under the name, not the path they were loaded from.

[13:09] <moritz> there's a module that embeds a perl5 compiler in Perl 6

[13:09] <jnthn> That'll alleviate the immediate issue I guess...

[13:10] <jnthn> ssqq: Yes, it's faster in many areas. But it's also just a first step - we now have capability to write an optimizer. That's when we'll get big wins. :)

[13:10] <flussence> I'm ok with @*INC having ./lib at the start and . at the end. It gives users a way to have both module overrides and fallbacks

[13:11] <JimmyZ> ssqq:  yes , see https://github.com/jnthn/blizkost

[13:11] <flussence> (just as long as it's visibly pointed out in docs somewhere - I can see the current @*INC confusing people)

[13:12] <masak> ssqq: that said, right now it's still easier to write Perl 6 than to try to run Perl 5 in Rakudo. at least in my experience.

[13:13] <jnthn> flussence: Yeah, good point

[13:13] <jnthn> I'm wondering if we shouldn't move Test.pm and so forth into lib.

[13:13] <ssqq> If have any planning to share symbol and sub namespace with other Language in Perl6,like Python?

[13:15] <ssqq> As Larry said, Parrot core only have 100-200k size, If it still so small now?

[13:15] <JimmyZ> ssqq: yes, if someone want to write the code 

[13:16] *** donri left
[13:16] <ssqq> If have any planning to run the parrot on embed system like iphone or Android?

[13:16] *** donri joined
[13:16] <JimmyZ> ssqq:  you're in 2001, now it's 2011 :)

[13:17] <JimmyZ> ssqq: give up the 2001 news :)

[13:18] <JimmyZ> ssqq:  most the chinese news  about Perl6 and parrot is from 2001 or 2005

[13:19] <masak> still, neither iPhone nor Android existed back then.

[13:19] <isBEKaml> VM in a VM? 

[13:20] <ssqq> Today,someone ask me,Perl6 can connect SQL with dbi?

[13:21] <isBEKaml> IIRC, android's already a VM in a VM. Putting parrot on android is three levels down. :)

[13:22] <JimmyZ> ssqq :  there was a dbdi :)   https://github.com/timbunce/DBDI/

[13:23] <masak> even some physical architectures nowadays can be seen as VMs.

[13:23] <isBEKaml> masak: are you talking about clusters?

[13:24] <isBEKaml> masak: btw, hi! :)

[13:24] *** drbean left
[13:26] <ssqq> my english if pool, I want to say with Chinese..

[13:27] <ssqq> If larry and conway came here to say something?

[13:28] <jnthn> moritz: Try the patch I just pushed.

[13:28] <jnthn> (when you've time :))

[13:28] <masak> isBEKaml: hi!

[13:29] <dalek> rakudo/nom: d438bdd | jonathan++ | src/Perl6/ModuleLoader.pm:

[13:29] <dalek> rakudo/nom: Tweak setting loading to avoid running into issues post-installation where we sometimes loaded two different versions of the setting.

[13:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d438bdd562

[13:29] <isBEKaml> masak: goes how you? :)

[13:29] <masak> isBEKaml: goes well I. you and?

[13:29] <masak> ssqq: Larry comes here occasionally. Conway seems to be more email-based.

[13:30] <tadzik> I thought they're Mister Wall and Mister Conway :)

[13:30] <isBEKaml> masak: well too I. bugs more rakudo in submitting?

[13:30] <ssqq> o, I heard about it, conway have not mobile even

[13:31] <isBEKaml> ssqq: so does quite a few folks here. 

[13:31] <masak> isBEKaml: now right many not. branch nom master merge waiting.

[13:31] <masak> isBEKaml: happening things many branch nom in exclusively though.

[13:31] *** nebuchadnezzar left
[13:32] <isBEKaml> masak: more so bugs nom in? more so nom faster or ?

[13:32] <masak> isBEKaml: times exciting joy for jump want I.

[13:32] <isBEKaml> \o/

[13:32] <masak> isBEKaml: nom faster not faster know I not. see will have to simply.

[13:32] *** fbass joined
[13:32] <JimmyZ> wow,  https://github.com/quietfanatic/link-c/ is awesome :)

[13:32] <masak> isBEKaml: optimizer future depend will on also.

[13:33] <isBEKaml> masak: times good, times good. 

[13:33] <masak> deed in.

[13:33] <isBEKaml> it's funny how we tend to speak in quirky Engreesh. :)

[13:33] <masak> I don't know what you're talking about. :P

[13:34] <isBEKaml> acknowledged. :P

[13:34] <jnthn> oh finally, a sentence I can understand :P

[13:34] *** tokuhirom left
[13:34] <masak> jnthn: learn English! :P

[13:34] <isBEKaml> jnthn: More english! :P

[13:34] <jnthn> masak: English learning hard is.

[13:34] <masak> aye.

[13:34] <isBEKaml> jnthn: finally a sentence I can understand! :P

[13:34] <jnthn> *lol*

[13:35] <masak> months many school in spent I English learning.

[13:35] <isBEKaml> all and I was got this. 

[13:35] <masak> *lol*

[13:35] <jnthn> masak: teacher Yoda called was?

[13:35] <masak> jnthn: Mr Yoda to you.

[13:36] <jnthn> form polite fails it I

[13:36] <masak> wow, Forth lolspeak.

[13:36] <jnthn> oops!

[13:36] <jnthn> :)

[13:36] <ssqq> Jimm

[13:36] <ssqq> 你在Perl6项目中有什么参与吗？

[13:37] <masak> phenny: zh en "你在Perl6项目中有什么参与吗？"?

[13:37] <phenny> masak: "You have any projects in the Perl6 in it?" (zh to en, translate.google.com)

[13:37] <masak> ssqq: yes, many.

[13:37] <masak> phenny: en zh "There are many projects written in Perl 6 already."?

[13:38] <phenny> masak: The en to zh translation failed, sorry!

[13:38] * masak grumbles

[13:38] <tadzik> masak: I think ssqq meant Link::C

[13:38] <ssqq> O, i want do somthing for perl6,Jimm what can I do?

[13:38] <masak> 在Perl6已经写了很多项目。

[13:38] <jnthn> moritz, tadzik: How do you feel about moving Test.pm and Pod/To/Test.pm under a "lib" directory? That's the start of @*INC, unlike .

[13:39] <ssqq> I means Jimm attend some project in perl6?

[13:39] <masak> "attend"?

[13:39] <masak> please rephrase.

[13:39] <isBEKaml> I think he meant "did he do any project in perl6?"

[13:39] <ssqq> sorry , I download a translator

[13:40] <jnthn> Otherwise at the moment we do make spectest after installation, but it finds the installed version, notes that the PIR is older and re-compiles Test.pm per test.

[13:40] <ssqq> isBEKaml said is right

[13:40] <masak> ssqq: 请不要使用翻译。请填写您的问题在中国。

[13:40] <masak> hm, that can't be right...

[13:41] <masak> 请写您的问题，使用普通话。

[13:41] <isBEKaml> jnthn: any idea on why it's trying to load Setting twice? 

[13:41] *** mj41 left
[13:42] <masak> yeah, I see the irony. using Google Translate to ask someone not to use a translator. :)

[13:42] <tadzik> jnthn: wfm

[13:42] <tadzik> pmichaud will probably be happy about it too :)

[13:42] <ssqq> masak,where are you from?

[13:43] <masak> 我住在瑞典。我学习普通话一点点。

[13:43] *** fbass left
[13:43] <jnthn> isBEKaml: Yeah, patch shoulda dealt with the issue.

[13:43] *** fbass joined
[13:44] *** nebuchadnezzar joined
[13:44] <jnthn> isBEKaml: It sholdn't load it twice, but multiple things may ask for a reference to it.

[13:44] <isBEKaml> masak: you're using Google Translate? or native to language trnaslator? :P

[13:44] <ssqq> masak, That is good, You said very well

[13:44] <masak> isBEKaml: I'm using Google Translate, and then trying to verify by looking at the sentence whether it came out right.

[13:45] <masak> isBEKaml: when I write phonetically, I tend to use a lot of wrong homonyms.

[13:45] *** whiteknight left
[13:45] <isBEKaml> masak: talk about checks and balances. :)

[13:46] <masak> 更多的人应该学习普通话。

[13:47] <isBEKaml> masak: no translator got I. lol.

[13:48] <JimmyZ> ssqq: want to share some contribution?

[13:48] <jnthn> tadzik: Trying it

[13:48] <isBEKaml> jnthn: the patch is on a different branch?

[13:48] <ssqq> jimmyz,no I just learning 语法 of Perl6,I have many question

[13:48] <jnthn> isBEKaml: ?

[13:49] <isBEKaml> jnthn: ah, nm. I thought I didn't see your commit. Just curious about the patch. :)

[13:49] <jnthn> isBEKaml: In nom branch, where all development is at the moment :)

[13:49] <JimmyZ> ssqq: 你现在在做什么？

[13:49] <ssqq> I interest the module of combin pod to chm of Parrot src

[13:49] <JimmyZ> java 开发？

[13:49] <masak> ssqq: it's fine to ask questions here about Perl 6 语法. we'll be happy to answer them.

[13:49] <ssqq> 我是网管，用Perl来做工具

[13:50] <JimmyZ> 在腾讯吗？

[13:50] <ssqq> 不是，一家手机方案公司。

[13:50] <JimmyZ> 所以你比较熟悉 Perl 5 ？

[13:51] <masak> ah, hence the question about iPhone and Android...

[13:51] <ssqq> Software is writing by C, and use perl as the common makefile tools

[13:51] <isBEKaml> masak: 的意思，但一直没有得到身边。

[13:51] * isBEKaml curses uxterm. :/

[13:51] <JimmyZ> ssqq ，你 比较熟悉 C 和 Perl 5？

[13:51] <masak> isBEKaml: did you jumble that before translating it? :)

[13:51] <ssqq> 是的，我写的所有代码，都是用Perl5

[13:52] <masak> \o/

[13:52] <isBEKaml> masak: no, jumbling is natural. Mandarin is hard. 

[13:52] <ssqq> C不是很熟悉，不过熟悉git,pod,

[13:52] <masak> isBEKaml: as far as I know, you don't start a sentence with 的. Chinese people here may correct me on that.

[13:53] <ssqq> We'd better write with english.

[13:53] <masak> ssqq: 你并不需要C时下很多。

[13:53] <isBEKaml> masak: Did I ? Google did! :)

[13:53] <masak> isBEKaml: that's one of the things it does wrong.

[13:54] <masak> isBEKaml: it's not very good at putting things in an order that a Mandarin speaker will recognize as grammatical.

[13:54] <JimmyZ> rakudo: class Foo { sub event (&method) is export { say &method.name; };  event method hello() { ... } };

[13:54] <ssqq> C is suitable with parrot

[13:54] <p6eval> rakudo 922500: OUTPUT«hello␤»

[13:55] <isBEKaml> masak: sentence structure is different in Asian languages. Google messes that one up. 

[13:55] *** agentzh left
[13:56] <JimmyZ> ssqq:  you maybe want http://perlgeek.de/blog-en/perl-5-to-6/

[13:56] <masak> isBEKaml: sentence structure is different in most languages. but the gap is so big between Germanic languages and the Sino-Tibetan languages that it's hard for an automatic translator to do anything sensible.

[13:56] <ssqq> In Asian Language, Attribute is before keyword,just like perl

[13:56] <masak> isBEKaml: it's probably even harder if the approach is based on statistics and corpora.

[13:56] <masak> ssqq: :)

[13:56] <isBEKaml> masak: NLP fails right there. :)

[13:57] <masak> ssqq: 是的

[13:57] <ssqq> yes, I need read it for many times

[13:57] <JimmyZ> nom: class Foo { sub event (&method) is export { say &method.name; };  event method hello() { ... } }; #JimmyZ thinks this one is evil :)

[13:57] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[13:57] <JimmyZ> ssqq: how about the Perl 6 book ?

[13:58] <isBEKaml> masak: AFAIK, flow based context is what makes languages so difficult. 

[13:58] <masak> JimmyZ: I think it's a nice little pattern.

[13:58] <masak> isBEKaml: well, humans have an excellent ability to connect together parts of sentences that refer to each other implicitly.

[13:58] <isBEKaml> masak: something machines are poor at, but humans pick them up very easily. 

[13:58] <ssqq> The grammar of Perl6 is strange for me, And i dont know if it will change later

[13:59] <JimmyZ> ssqq: https://github.com/perl6

[13:59] <JimmyZ> ssqq: sorry, this one https://github.com/perl6/book

[13:59] <isBEKaml> masak: I see we are in agreement there. (or I'm slow at typing)

[14:00] <tadzik> ssqq: what's strange for you?

[14:00] <tadzik> and I don't think it's going to change much

[14:00] <ssqq> «»

[14:01] <ssqq> this symbol can not type with keyboard

[14:01] <tadzik> you can always use << and >>

[14:01] <masak> and you can type it with the keyboard, too.

[14:01] <tadzik> nom: say [1, 2, 3] >>+<< [4, 5, 6]

[14:01] <masak> different ways, depending on the editor.

[14:01] <p6eval> nom: OUTPUT«5 7 9␤»

[14:02] <JimmyZ> masak: I say it's evil because I didn't see a language that can do class A { publice $a; func b() {};  b($a); } 

[14:02] <ssqq> tadzik you means it is eq << eq « >> eq «»

[14:03] <ssqq> I believe Perl6 will be an great language,

[14:05] <ssqq> It will connect and communication with all language

[14:06] <jnthn> tadzik: Pushed patches to move Test.pm and Pod/To/Test.pm into lib, and put lib into @*INC.

[14:06] <jnthn> tadzik: Testing/feedback on how it feels appreciated. 

[14:06] *** im2ee left
[14:06] <masak> JimmyZ: I don't get it.

[14:06] <JimmyZ> ssqq: did you read  http://perlcabal.org/syn/  ?

[14:06] <dalek> rakudo/nom: 1349b46 | jonathan++ | / (6 files):

[14:06] <dalek> rakudo/nom: Move Test.pm and Pod/To/Text.pm into lib directory.

[14:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1349b46747

[14:06] <dalek> rakudo/nom: 0ad2d79 | jonathan++ | src/core/terms.pm:

[14:06] <dalek> rakudo/nom: Add lib to default @*INC, ahead of installed paths. Avoids hitting stuff in the CWD ahead of installed things, but still gives a way for module developers to try development versions, and also for us to find the non-installed pre-compiled Test.pm.

[14:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ad2d794a0

[14:06] <ssqq> no

[14:06] *** im2ee joined
[14:07] <jnthn> tadzik: I discussed the module cache thing with Pm and he wanted us to discuss it and think about it further first, so for now things work as in master - we use a .pir file if it's there. So installer can still do that.

[14:07] <jnthn> tadzik: We'll plot World Domination...er, I mean, a better solution...at YAPC::EU :)

[14:08] <ssqq> o i have read it,and I think the final grammar will have a few change

[14:08] <tadzik> jnthn: the module cache thing?

[14:08] <isBEKaml> jnthn: where's the WTOP? :P

[14:08] <JimmyZ> masak: or class A {

[14:08] <JimmyZ> func b() {} 

[14:08] <JimmyZ> b($a); # usually, we can't call code there

[14:08] <JimmyZ>  }  

[14:09] <jnthn> tadzik: As in, Rakudo full managing the pre-compilation cache, rather than us doing it at module install time.

[14:09] <JimmyZ> s/there/here/

[14:09] <jnthn> *fully

[14:09] <tadzik> jnthn: oh, so we won't need to figure out the best order when doing few perl6 --target=pirbc in a row?

[14:09] <JimmyZ> masak: s/b($a)/b()/

[14:10] <ssqq> goodbye I will test some perl6 pm

[14:10] <tadzik> o/

[14:10] <JimmyZ> bye ssqq

[14:10] *** ssqq left
[14:10] <isBEKaml> o/

[14:11] <jnthn> tadzik: er, that will need sorting out.

[14:11] <tadzik> jnthn: I don't know what you mean by rakudo managing pre-compilation cache

[14:12] <jnthn> Don't worry about it then.

[14:12] <tadzik> okay :)

[14:12] <tadzik> oh oh, so no installing .pirs or .pbcs, Rakudo will care about it all?

[14:12] <jnthn> But if you have A using B and C, then it's important B and C and pre-compiled before A is.

[14:12] <jnthn> tadzik: For now we should go on installing them.

[14:13] <tadzik> yeah, sure, but not in a dreamworld, right?

[14:13] <jnthn> I think that should be a possibility, yes.

[14:13] <jnthn> Maybe even the default.

[14:13] <jnthn> It's a bit tricky to get right though. :)

[14:13] <tadzik> I see

[14:14] <isBEKaml> jnthn: if by precompiled, you mean rakudo doesn't check timestamps to see if they need any re-compilation? 

[14:14] <isBEKaml> jnthn: just that precompiled forms take first precedence in face of multiple sources?

[14:14] <isBEKaml> s/face/view/

[14:16] <isBEKaml> that doesn't seem quite right to me since we(as mortal programmers) don't see .pbc files. 

[14:16] <JimmyZ> nom: class JimmyZ { sub event (&method) is export { print &method.name; };  event method hello() { say  ' #perl6' } }; JimmyZ.hello; # just interesting

[14:16] <p6eval> nom: OUTPUT«hello #perl6␤»

[14:17] <masak> obra++! http://www.slideshare.net/obrajesse/oscon-2011-perl-516-and-beyond

[14:17] <masak> wow, Perl 5 is *awesome*.

[14:17] <masak> oh wow oh wow

[14:17] <tadzik> JimmyZ: wow, what?

[14:18] <tadzik> that's pretty neat

[14:18] <JimmyZ> tadzik: what's what?

[14:18] * JimmyZ can't follow tadzik

[14:19] <tadzik> JimmyZ: the example. It's pretty cool

[14:20] <JimmyZ> tadzik: I just steal it from https://github.com/quietfanatic/gamebase :)

[14:20] *** tokuhirom joined
[14:20] *** im2ee left
[14:21] *** im2ee joined
[14:21] <masak> yes, quietfanatic++ was the first one to use that pattern.

[14:22] <masak> it's one of those "obvious in retrospect" things. S06 talks about sub/method declarators being ordinary expressions returning the object declared.

[14:22] <masak> makes for a very "DSL"-ish syntax.

[14:23] * JimmyZ is pleased it's written in Perl6 instead of Java,  so he can understand it

[14:24] <jnthn> isBEKaml: We check time stamps

[14:24] *** Mowah_ joined
[14:25] <jnthn> Nice, a bunch of my exit code 1's have vanished from make spectest.

[14:26] <jnthn> In fact, all of them

[14:26] <jnthn> Anybody know why radcalc in Actions.pm sometimes explodes with "no bigint lib loaded"?

[14:27] <masak> rakudo: my %event_subs; sub event { %event_subs{&^sub.name} = &sub }; event sub foo {}; event sub bar {}; say %event_subs.perl

[14:27] <p6eval> rakudo 922500: OUTPUT«{"foo" => { ... }, "bar" => { ... }}␤»

[14:27] *** donri left
[14:27] *** donri_ joined
[14:33] <JimmyZ> nom: class JimmyZ { sub prefix:<@>(&method) { print &method.name; };  @method hello() { say  ' #perl6' } } # bug ?

[14:33] <p6eval> nom: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3863 (src/Regex/Cursor.pir:244)␤»

[14:33] <JimmyZ> rakudo: class JimmyZ { sub prefix:<@>(&method) { print &method.name; };  @method hello() { say  ' #perl6' } } # bug ?

[14:33] <p6eval> rakudo 922500: OUTPUT«hello»

[14:33] *** birdwindupbird joined
[14:34] <JimmyZ> though that's a little pythonic :)

[14:35] <isBEKaml> rakudo: class JimmyZ { sub prefix:<@>(&method) { print &method.name; }; @ method hello() { say ' #perl6' } }

[14:35] <p6eval> rakudo 922500: OUTPUT«hello»

[14:35] <isBEKaml> rakudo: class JimmyZ { sub prefix:<@>(&method) { print &method.name; }; (@)method hello() { say ' #perl6' } }

[14:35] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 22␤»

[14:35] <JimmyZ> isBEKaml:  nom doesn't work 

[14:36] *** shinobicl__ joined
[14:36] <isBEKaml> JimmyZ: pythonic? decorators? :)

[14:36] <JimmyZ> isBEKaml:  yes

[14:36] <JimmyZ> nom: class JimmyZ { sub event (&method) { print &method.name; };  event method hello() { say  ' #perl6' } }

[14:36] <p6eval> nom: OUTPUT«hello»

[14:37] <JimmyZ> rakudo: class JimmyZ { sub prefix:<@>(&method) { print &method.name; };  @method hello() { say  ' #perl6' } } # I think it's a nom bug

[14:37] <p6eval> rakudo 922500: OUTPUT«hello»

[14:37] <JimmyZ> nom: class JimmyZ { sub prefix:<@>(&method) { print &method.name; };  @method hello() { say  ' #perl6' } } # I think it's a nom bug

[14:37] <p6eval> nom: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3863 (src/Regex/Cursor.pir:244)␤»

[14:38] <isBEKaml> nom: class JimmyZ { sub event (&method) { print &method.name; };  event sub hello() { say ' #perl6'; } }

[14:38] <p6eval> nom: OUTPUT«hello»

[14:39] <jnthn> We didn't put custom operators back in nom yet.

[14:40] <JimmyZ> ah

[14:40] <isBEKaml> JimmyZ: well, <@> is abuse since we have @ prefixes for arrays. ;)

[14:40] <isBEKaml> I don't even want to see perl6 accidentally wander into C++ zones. :)

[14:40] * JimmyZ thought it did

[14:41] *** Mowah_ left
[14:52] *** [particle]1 joined
[14:53] *** [particle] left
[14:56] *** donri_ left
[14:57] <JimmyZ> rakudo:  sub prefix:<@>(&sub) { print ' ', &sub.name; return sub perl6 { &sub; } }; @@@@@@@@@@@sub hello() {  } # what do you feel like it?

[14:57] <p6eval> rakudo 922500: OUTPUT« hello perl6 perl6 perl6 perl6 perl6 perl6 perl6 perl6 perl6 perl6»

[14:58] <JimmyZ> rakudo:  sub event (&method) { print ' ', &method.name;  return sub perl6 { &method; } };  event event event event sub hello() { }; # or this

[14:58] <p6eval> rakudo 922500: OUTPUT« hello perl6 perl6 perl6»

[14:58] *** MayDaniel joined
[15:00] *** fbass left
[15:01] *** mj41 joined
[15:02] <amster> 

[15:03] *** shinobicl__ left
[15:07] <pmichaud> good morning, #perl6

[15:08] <jnthn> morning, pmichaud 

[15:13] <JimmyZ> masak	it's one of those "obvious in retrospect" things. S06 talks about sub/method declarators being ordinary expressions returning the object declared.

[15:14] <JimmyZ> masak: which line :)

[15:14] <JimmyZ> masak:  I couldn't find it

[15:16] *** fbass joined
[15:17] *** frew joined
[15:18] <pmichaud> commit 0ad2d7 (adding 'lib' directory to search path)  introduces more trojans.

[15:18] <pmichaud> it needs to go after the other dirs

[15:19] <jnthn> Please see commit message for why not.

[15:19] *** frew left
[15:19] <pmichaud> I did see the commit message.

[15:19] <pmichaud> That doesn't change what I just said.  :)

[15:21] <jnthn> OK, then we need a different way to solve the problem.

[15:21] <pmichaud> right.

[15:21] <pmichaud> we could perhaps get 'use lib' to work.

[15:21] <jnthn> And sprinkle it all over every .t file?

[15:22] <pmichaud> oh, for tests we should be able to do a command line option in the harness

[15:22] <jnthn> OK

[15:22] <jnthn> oh, or the existing environment variable.

[15:22] <jnthn> If we can reliably set it in a cross-platform way :/

[15:30] <[Coke]> pmichaud: anyone break spectest on you since you complained? 

[15:31] *** daniel-s left
[15:32] <pmichaud> [Coke]: not that I've noticed

[15:32] <pmichaud> running make spectest now :)

[15:32] <jnthn> BTW, did anyone else often get exit code 1's on a bunch of passing tests?

[15:33] <jnthn> Those have all vanished for me, it seems. I'm thinking it may have been last night's memory corruption fix.

[15:33] * jnthn figures out how to handle implementing handles.

[15:33] <pmichaud> I'm guessing the memory corruption fix is indeed it.

[15:34] <pmichaud>     symtable = clone symtable

[15:34] <jnthn> Nice :)

[15:34] <pmichaud> jnthn: did you come up with a workaround for ^^ ?

[15:34] <jnthn> Yeah, I wrote a sub to shallow clone it

[15:34] <pmichaud> okay, good.

[15:34] <masak> JimmyZ: S06:273.

[15:34] <jnthn> Then outlawed the code path that led to the issues.

[15:34] <[Coke]> jnthn: yah, I used to.

[15:35] <JimmyZ> masak:  thanks

[15:35] <[Coke]> also got odd failures when running t/harness directly versions exec'ing it inside of another process. wonder if that's fixed.

[15:35] <jnthn> Maybe. It was all very memory layout sensitive. It took us ages to get an example where it segfaulted.

[15:36] <jnthn> Then thankfully 10 minutes of staring at the functions in the backtrace made it clear what has going on.

[15:38] <jnthn> BTW, [Coke]++ again for fixing the Makefile issue :)

[15:39] <pmichaud> jnthn: huh.... the deep cloning of symtable was already reported: http://trac.parrot.org/parrot/ticket/1015

[15:39] *** JimmyZ left
[15:40] <jnthn> pmichaud: I don't see a mention of symtable in that ticket?

[15:40] <jnthn> oh, "symbol table"

[15:41] <jnthn> Though the ticket was about a more general Parrot issue.

[15:41] <pmichaud> right

[15:42] <jnthn> In this case the issue was that SixModelObject doesn't support cloning, but Parrot tries to provide a default clone v-table, which can explode. Turns out the only place we ever tried to clone one was when symtable got cloned and it was attached as a value. 

[15:43] <jnthn> So I made that shallow clone and then shoved an exception throw into the SixModelObject clone v-table

[15:43] <jnthn> I'm not sure what we'll want it to do yet: whatever repr_clone does, or be the HLL interface for whatever the langauge considers cloning (and thus have it overridable).

[15:44] *** woosley left
[15:44] <pmichaud> the correct answer is that PCT should be doing shallow cloning.

[15:44] <pmichaud> the _really_ correct answer is that Parrot should be doing shallow cloning.  See http://lists.parrot.org/pipermail/parrot-dev/2010-March/003958.html

[15:45] <jnthn> Right, agree fully on that.

[15:45] *** shinobicl__ joined
[15:45] <jnthn> I've whined about it a couple of times recently. :)

[15:45] <masak> is there a bug report about it?

[15:46] <pmichaud> I don't think it ever got promoted to a trac ticket, no.

[15:49] <masak> then it can't be that important :P

[15:50] <pmichaud> there was a parrot branch created for shallow cloning

[15:51] <pmichaud> http://irclog.perlgeek.de/parrot/2010-03-22#i_2135494

[15:51] <pmichaud> ...but the branch never got merged.  :(

[15:52] <jnthn> Did the deprecation notice make it in, I wonder...

[15:52] *** noganex left
[15:53] <pmichaud> looks like "no".

[15:53] *** JimmyZ joined
[15:53] <JimmyZ> 	How can I define a sub dynamically like this? my $sub_name = 'foo'; sub $sub_name()  { .... } ;

[15:54] *** noganex joined
[15:55] <benabik> Do all Parrot types deep clone?  Or is it just hash?

[15:55] <pmichaud> Just Hash that I know of.  All of the others shallow clone.

[15:55] <masak> JimmyZ: &::($sub_name) = sub { ... }

[15:55] <masak> std: my $sub_name; &::($sub_name) = sub { ... }

[15:55] <p6eval> std 516268a: OUTPUT«ok 00:01 121m␤»

[15:56] <jnthn> Where's that actually installing it? :)

[15:56] <jnthn> Current package I guess.

[15:56] <masak> that was my guess.

[15:56] <pmichaud> I don't think there's a way to dynamically create 'my' subs.

[15:56] <pmichaud> (since that would involve dynamically modifying the lexpad)

[15:56] <masak> oh!

[15:56] <masak> good point.

[15:57] <jnthn> Right, and we don't look anywhere other than the lexpad for subs

[15:57] <masak> sub lookup is s'posed to be statically determinable.

[15:57] <JimmyZ> rakudo: sub event (&method) { my $sub = &method.name; print ' ', &method.name; return &::($sub) = sub { ... }; }; event event event event sub hello() { };

[15:57] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Indirect name lookups not yet implemented at line 22, near " = sub { ."␤»

[15:57] <JimmyZ> NYI :(

[15:58] <masak> JimmyZ: also, what pmichaud and jnthn said.

[15:59] *** amster left
[16:00] <pmichaud> afk for a bit

[16:02] <JimmyZ> oh, I didn't see what pmichaud++  and jnthn++  said

[16:03] * JimmyZ sleeps

[16:03] *** JimmyZ left
[16:09] *** perlhack joined
[16:11] <ruz> rakudo: <a b>.fooo

[16:11] <p6eval> rakudo 922500: OUTPUT«Method 'fooo' not found for invocant of class 'Parcel'␤  in main program body at line 22:/tmp/5cuT9svCoJ␤»

[16:13] *** tokuhirom left
[16:13] *** perlhack left
[16:13] <masak> perlhack! \o/

[16:13] <masak> oh shucks. :)

[16:13] *** tokuhirom joined
[16:14] <masak> tokuhirom: こんにちは

[16:17] *** isBEKaml left
[16:18] *** MayDaniel left
[16:18] *** tokuhirom left
[16:19] *** shinobicl__ left
[16:21] <pmichaud> are parrot hashes defaulting to ordered again?

[16:21] <sorear> good * #perl6

[16:21] <phenny> sorear: 10:53Z <moritz> tell sorear that 'make test' dies with 'Unhandled Exception: No value for parameter @y in Test rxtest'

[16:21] <jnthn> pmichaud: Don't recall seeing anything about that.

[16:21] <pmichaud> nom:  my %x;  for 'a'..'az' { %x{$_} = 10.rand };  say %x.keys

[16:21] <p6eval> nom: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az␤»

[16:21] <pmichaud> nom:  my %x;  for 'a'..'bz' { %x{$_} = 10.rand };  say %x.keys

[16:22] <p6eval> nom: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z aa ab ac ad ae af ag ah ai aj ak al am an ao ap aq ar as at au av aw ax ay az ba bb bc bd be bf bg bh bi bj bk bl bm bn bo bp bq br bs bt bu bv bw bx by bz␤»

[16:22] <jnthn> They're certainly coming out again ordered.

[16:22] <jnthn> Don't think I'd depend on it though :)

[16:22] <pmichaud> I'm worried that others might start to do so.

[16:22] <pmichaud> I'm also curious why they're coming out ordered again.

[16:22] <jnthn> Yeah 

[16:23] <jnthn> Same.

[16:23] <pmichaud> rakudo:  my %x; for 'a'...'bz' { %x{$_} = 10.rand }; say %x.keys

[16:23] <p6eval> rakudo 922500: OUTPUT«abcdefghijklmnopqrstuvwxyzaaabacadaeafagahaiajakalamanaoapaqarasatauavawaxayazbabbbcbdbebfbgbhbibjbkblbmbnbobpbqbrbsbtbubvbwbxbybz␤»

[16:26] *** MayDaniel joined
[16:26] <jnthn> rakudo:  my %x; for ('a'...'bz').pick(*) { %x{$_} = 10.rand }; say %x.keys

[16:26] <p6eval> rakudo 922500: OUTPUT«aczdbbabrbhaobnbupamblntayahasalboatfgaibzsaquajanwbjavbpawbeobfbdmaaeagakybvbmiazaehrbckapbgbsabbqbtcbwlvbxafjaxbybaxbaubiadbkqar␤»

[16:27] <pmichaud> well, that doesn't really tell us anything :-)

[16:27] <jnthn> Well, it tells us that it doesn't sort the keys when iterating ;)

[16:27] <pmichaud> okay, it tells us that :)

[16:27] <jnthn> Which is a relief. :)

[16:29] <pmichaud> nom: my %x; for 1..100 { %x{"key_$_"} = 1 };  say %x.keys

[16:29] <p6eval> nom: OUTPUT«key_1 key_2 key_3 key_4 key_5 key_6 key_7 key_8 key_9 key_10 key_11 key_12 key_13 key_14 key_15 key_16 key_17 key_18 key_19 key_20 key_21 key_22 key_23 key_24 key_25 key_26 key_27 key_28 key_29 key_30 key_31 key_32 key_33 key_34 key_35 key_36 key_37 key_38 key_39 key_40 key_…

[16:29] <pmichaud> nom: my %x; for 1..100 { %x{"$_"} = 1 };  say %x.keys

[16:29] <p6eval> nom: OUTPUT«1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95…

[16:34] <masak> I'm not worried so much about insertion-order per se. I'm worried about how that impacts performance.

[16:34] <pmichaud> well, Parrot had ordered hashes by default for a long time

[16:35] <pmichaud> then it got changed in 2009, I think -- I'm wondering when it switched back.

[16:41] <pmichaud> they were unordered in rakudo-star-2010.07:  http://gist.github.com/1130515

[16:44] <jnthn> nom: say Parcel ~~ Iterable

[16:44] <p6eval> nom: OUTPUT«Bool::False␤»

[16:44] <jnthn> nom: say Parcel ~~ Positional

[16:44] <p6eval> nom: OUTPUT«Bool::True␤»

[16:44] <jnthn> nom: for <a b c> { .say }

[16:44] <p6eval> nom: OUTPUT«a␤b␤c␤»

[16:49] <pmichaud> "Iterable" is the class of things that interpolate in list context.

[16:50] <pmichaud> (non-flattening list context, that is.)

[16:50] <jnthn> pmichaud: Ah, yes :)

[17:02] <dalek> rakudo/nom: d0f04e9 | jonathan++ | src/Perl6/ModuleLoader.pm:

[17:02] <dalek> rakudo/nom: Corrections and enhancements to GLOBAL handling on module usage.

[17:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d0f04e9bcc

[17:02] <dalek> rakudo/nom: 5cb58be | jonathan++ | src/ (3 files):

[17:02] <dalek> rakudo/nom: Implement various basic cases of the handles trait. Gets us the first 33 tests of delegation.t.

[17:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5cb58be2d8

[17:08] <tadzik> hello again

[17:09] *** fbass left
[17:09] <jnthn> hi tadzik 

[17:12] *** thou joined
[17:13] *** aindilis left
[17:13] *** fbass joined
[17:13] <jnthn> nom: say ?()

[17:13] <p6eval> nom: OUTPUT«Bool::True␤»

[17:13] <jnthn> pmichaud: Is the above correct?

[17:13] *** aindilis joined
[17:14] * jnthn was fairly sure an empty Parcel would be false.

[17:14] *** amster joined
[17:15] *** thundergnat joined
[17:16] <jnthn> S02:

[17:16] <jnthn>  C<Nil.defined> returns

[17:16] <jnthn> C<False> (whereas C<().defined> returns C<True>).  C<Nil.so> also

[17:16] <jnthn> returns C<False>.

[17:16] <thundergnat> Hi #perl6

[17:16] <jnthn> I'm not sure wether to read that as "also returns C<Flase> like ().so" or not.

[17:16] <dalek> niecza: 366d65b | sorear++ | test.pl:

[17:16] <dalek> niecza: Update builtin tests to latest gist/Nil spec

[17:16] <dalek> niecza: review: https://github.com/sorear/niecza/commit/366d65b52a

[17:16] <sorear> hello thundergnat.

[17:17] <thundergnat> Are autogenerated attribute setter methods always slurpy in rakudo?

[17:18] <thundergnat> rakudo: class B { has $.w is rw; has $.h is rw; }; my $b = B.new; ($b.w, $b.h) = '100 200'.split(' '); .say for $b.w, $b.h, $b.w.WHAT;

[17:18] <p6eval> rakudo 922500: OUTPUT«100 200␤Any()␤Seq()␤»

[17:18] <thundergnat> I want to split into 2 attributes but the first always slups up all the parameters.

[17:18] <thundergnat> *slurps

[17:20] <jnthn> nom: class B { has $.w is rw; has $.h is rw; }; my $b = B.new; ($b.w, $b.h) = '100 200'.split(' '); .say for $b.w, $b.h, $b.w.WHAT; # curius...

[17:20] <p6eval> nom: OUTPUT«100␤200␤Str()␤»

[17:20] <jnthn> Hmm, behaves the way you want it in the nom dev branch.

[17:20] <jnthn> Which I think is correct also.

[17:20] <thundergnat> That's good news.

[17:20] <jnthn> So, Rakudo bug.

[17:21] <jnthn> nom: class B { has @.w is rw; has $.h is rw; }; my $b = B.new; ($b.w, $b.h) = '100 200'.split(' '); .say for $b.w, $b.h, $b.w.WHAT; # guess this would slurp...

[17:21] <p6eval> nom: OUTPUT«100␤200␤Nil␤Array()␤»

[17:22] <jnthn> pmichaud++ # improved list assignment in nom 

[17:22] <thundergnat> pmichaud++ indeed

[17:22] *** Chillance joined
[17:24] *** fbass left
[17:30] <thundergnat> niecza: class B { has $.w is rw; has $.h is rw; }; my $b = B.new; ($b.w, $b.h) = '100 200'.split(' '); .say for $b.w, $b.h, $b.w.WHAT; #curious

[17:30] <p6eval> niecza v8-45-g366d65b: OUTPUT«100␤200␤Unhandled exception: System.InvalidCastException: Cannot cast from source type to destination type.␤  at CORE.C216_Str_2Esay (Niecza.Frame ) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.RunCore (Niecza.Frame& cur) [0x00000] in <filename unk…

[17:31] <thundergnat> sorear++ 

[17:49] <sorear> jnthn: don't tell me you're seriously considering moving . to the front of the search path.

[17:52] <jnthn> heh :)

[17:53] <jnthn> No, I'm seriously leaving such issues for @other. :)

[17:55] <jnthn> sorear: Remember that I've got about zero background on Unix/Linux-y systems, and that the current directory is pretty much top of the pecking order when doing e.g. DLL searches on Windows.

[17:56] <jnthn> sorear: So it's completely natural to me that it'd be searched first. I have this vague awareness that there's other ways to look at the issue. :)

[17:57] <sorear> jnthn: I thought that the top of the Windows pecking order was dirname($*EXECUTABLE_FILE)

[17:58] <jnthn> Yes. Then cwd. Then the path.

[17:58] <sorear> hmm, how are system dlls found?

[17:58] <jnthn> C:\Windows\System32 is in the path I guess :)

[17:58] <sorear> I don't STR C:\Windows\System32 being in %PATH% last time I was doing serious windows prograsmming

[17:59] <sorear> -s

[17:59] <jnthn> oh, no

[17:59] * sorear wonders how much ey dates eirself with that path

[17:59] <jnthn> It actully goes to the registry for the Windows install directory too

[17:59] <jnthn> (Before searching the path)

[18:00] <jnthn> heh, so it tries just about everything it could before looking through the PATH environment variable. :)

[18:02] <jnthn> Seems there's also a safe mode and unsafe mode with puts the CWD after and before the system directories respectively. :)

[18:02] <sorear> anyways, if I have an unrelated file in . named CORE.setting (say, niecza's setting), I'd kind of like it if Rakudo Perl 6 continued to work

[18:03] <sorear> I only spent 14 months fighting to get Parrot to work in directories with unrelated Regex.pbc files...

[18:03] <jnthn> Well, . hasn't been moved to the front of the path, and almost certainly won't be.

[18:04] <pmichaud> (and it's still marked as "we need to remove this")

[18:04] *** MayDaniel left
[18:04] <sorear> *phew*

[18:05] <sorear> I was worried that you thought it was a good idea :D

[18:05] *** ggoebel left
[18:07] *** isBEKaml joined
[18:09] <jnthn> hunger strikes...store &

[18:10] *** SAA22WV joined
[18:13] <dalek> rakudo/nom: 795f6a6 | pmichaud++ | src/core/metaops.pm:

[18:13] <dalek> rakudo/nom: Add hyper metaops for hash arguments.

[18:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/795f6a6dad

[18:13] *** ggoebel joined
[18:13] <dalek> features: 929c012 | pmichaud++ | features.json:

[18:13] <dalek> features: Nom now supports hyper metaops.

[18:13] <dalek> features: review: https://github.com/perl6/features/commit/929c0129ee

[18:15] <moritz> evalbot rebuild nom

[18:15] <p6eval> OK (started asynchronously)

[18:17] * [Coke] is looking at trying to merge kboga's spectest data PR. if I try to grab the .patch file from github, the email address looks foobar.

[18:18] <kboga> hmm

[18:19] <[Coke]> From: kboga <kristof@PCHOME.(none)>

[18:20] <kboga> oh, looks like I didn't add that info there or something

[18:20] *** ggoebel left
[18:21] <kboga> bad?

[18:21] <[Coke]> I imagine it's not going to like that as an author email. We'll see.

[18:22] <jnthn> pmichaud: If you're in features, can give us + on nested siggies too :)

[18:23] <dalek> features: 7cf058c | pmichaud++ | features.json:

[18:23] <dalek> features: nom has nested siggies (jnthn++)

[18:23] <dalek> features: review: https://github.com/perl6/features/commit/7cf058ccf9

[18:24] <[Coke]> kboga: what's your actual email addy for commits?

[18:24] <[Coke]> (I can update this one by hand, and you can fix it on github)

[18:25] *** ggoebel joined
[18:25] <pmichaud> anyone know why we have +- on "Introspection" for nom?

[18:25] <pmichaud> and +- for Whatever-currying?

[18:26] <benabik> nom: (* + 1).WHAT.say

[18:26] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[18:26] <jnthn> pmichaud: On introspection, I've still 3 tests to look at in S12-introspection

[18:27] <jnthn> pmichaud: .WALK is easy. .can is blocked on ?() being True.

[18:27] <jnthn> The roles one I think I just need to play with the API a bit. :)

[18:27] <jnthn> So, legit that we're +- but we can be + with a small effort :)

[18:28] <pmichaud> ?() being true?

[18:28] <jnthn> nom: say ?()

[18:28] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[18:28] <jnthn> rakudo: say ?()

[18:28] <p6eval> rakudo 922500: OUTPUT«Bool::False␤»

[18:28] <jnthn> pmichaud: nom says Bool::True there.

[18:28] <jnthn> pmichaud: And I can't find a clear answer either way in the spec.

[18:28] <pmichaud> it almost certainly should be false.

[18:28] <jnthn> My intuition tells me it should be false. :)

[18:28] <jnthn> ah, OK

[18:29] <jnthn> I guessed it should be

[18:29] <jnthn> If you're almost certain too that's good enough to fix it :)

[18:29] <pmichaud> need a Parcel.Bool

[18:29] *** ggoebel left
[18:30] <jnthn> k

[18:30] <pmichaud> working on it

[18:31] <jnthn> ah, thanks

[18:31] * jnthn debugging while his delegation thingy almost but not quite works.

[18:31] <benabik> jnthn: You seem to have delegated to pmichaud just fine.  :-D

[18:32] <[Coke]> jnthn: glad the makefile fix is working. it bugged me a few weeks ago but I don't spend enough time on windows/rakudo for it to bother me, usually.

[18:34] <jnthn> [Coke]: It's bugged me for quite a while and I tried a few things.

[18:34] <jnthn> benabik: ;-)

[18:35] *** ggoebel joined
[18:37] <masak> slightly off-topic: the company that jnthn and I work for is hiring. if you like hanging out with us, and if you know Perl, privmsg or email me or jnthn. :)

[18:37] <[Coke]> workfromhome?

[18:38] <masak> strong preference that you move to southern Sweden.

[18:38] <jnthn> Don't worry, it's the bit without the polar bears.

[18:38] <masak> jnthn is right.

[18:38] <masak> haven't seen one polar bear down here.

[18:38] <benabik> Just normal bears?

[18:39] <tadzik> grizzlies

[18:39] <dalek> roast: 8d1595b | pmichaud++ | S02-builtin_data_types/parcel.t:

[18:39] <dalek> roast: Add tests for Parcel.Bool.

[18:39] <dalek> roast: review: https://github.com/perl6/roast/commit/8d1595b832

[18:39] <dalek> rakudo/nom: 7d55a9f | pmichaud++ | src/core/Parcel.pm:

[18:39] <dalek> rakudo/nom: ?() should return False (jnthn++).

[18:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d55a9f1f3

[18:40] <jnthn> \o/

[18:40] *** ggoebel left
[18:40] *** mj41 left
[18:40] <jnthn> .can has

[18:47] <sorear> masak: if only..

[18:47] <masak> sorear: oh, that would be AWESOME.

[18:49] <masak> "They work on Perl 6. For some reason, each of them is building his own compiler, too!"

[18:50] <jnthn> oh heh, then we'd have Niecza, Rakudo AND Yapsi developers :P

[18:50] <masak> what I said.

[18:50] <jnthn> no, what *she*...oh wait

[18:50] <masak> oh wait, this isn't privmsg...? :P

[18:51] <jnthn> :)

[18:51] <jnthn> No, I knew it wasn't this time :)

[18:51] <masak> right.

[18:51] <sorear> that expression tickles my sexism gag reflex

[18:51] <jnthn> That's why it wasn't full of Swedish :P

[18:51] <jnthn> sorear: It's a meme. They're all kinda silly :)

[18:51] <masak> I agree about the risk, though.

[18:52] <masak> if nothing else, it's a meme mostly for hetero males in a certain age-band.

[18:52] <jnthn> Wow, can't even *refer* to a meme jokingly. :/

[18:53] <masak> jnthn: well, when the referring takes the form of use, I guess it is a bit of a thin line.

[18:53] <masak> jnthn: it's like when people just quote stuff on Twitter, without saying whether they agree or not. agreement is usually presupposed. sometimes with LTA consequences.

[18:55] <masak> then again, the part of me that thinks sorear is overreacting thinks that the TWSS meme could well be used in a very non-sexist context, by someone relatively aware of such issues.

[18:55] <masak> the problem is more something like the fact that there's no corresponding TWHS meme.

[18:57] <masak> the desire to put innuendo into innocent comments is probably age-old. the "...in bed" meme rides on that same force.

[18:57] <tadzik> hmm

[18:57] * tadzik thinks about documenting subroutine parameters

[18:58] <jnthn> tadzik: Should be do-able. They get traits applied.

[18:59] <benabik> sub foo( $bar is why('explanation ) # ?

[18:59] *** ron__ joined
[18:59] <pmichaud> jnthn: guess how many lines of code are in the first two subs of CORE.setting.pir :-) :-)

[18:59] <benabik> But with the closing quote and karen, obviously.

[18:59] <tadzik> oh, so I'll just set %PARAM_INFO in method parameter(), even though the parameter object is constructed elsewhere. Easy peasy

[19:00] * tadzik guesses 0 or something ;)

[19:00] <[Coke]> all the Merging\ GLOBAL\ symbols\ failed errors have changed.

[19:00] <benabik> 42000

[19:00] <jnthn> pmichaud: Probably LOADS in the second.

[19:00] <pmichaud> 149,659.

[19:00] <jnthn> pmichaud: Given it's basically the serialization of the entire setting.

[19:01] *** ggoebel joined
[19:01] <jnthn> pmichaud: That's...sizable.

[19:01] <pmichaud> the second sub has 5636 .const declarations.

[19:02] <jnthn> Refers to every PAST block in the file, yes.

[19:02] <kboga> Why do some multi method ACCEPTS's signatures have a Mu type constraint for their topic in nom? (I only see Any in the spec http://feather.perl6.nl/syn/S03.html#Smart_matching)

[19:03] <kboga> Well I understand the Mu:U: Mu $topic one (type checking), but others? =/

[19:03] <pmichaud> kboga:    Int.ACCEPTS(Mu)

[19:03] <pmichaud> aka    Mu ~~ Int

[19:04] <kboga> yea, that I do understand :)

[19:04] <pmichaud> some of the others are similar.  

[19:04] <kboga> but all other cases

[19:04] <kboga> hmm

[19:04] <pmichaud> I suspect many can/should be Any.

[19:04] <pmichaud> But we still need to figure out how to make &infix:<~~> autothread.

[19:04] *** wolfman2000 joined
[19:04] <kboga> oh ic

[19:05] <pmichaud> 5636 .const declarations in one sub == 5636 register allocations == "Doctor, it always hurts when I use imcc."

[19:05] <pmichaud> gone for a while -- soccer game

[19:05] <kboga> So some should be Any, thanks for the clarification pmichaud++

[19:08] <ron__> nom: my $m = '34' ~~ /<digit>+|<alpha>+/; say $m<alpha>.perl; say Nil.perl; my $x = $m<alpha> // 4; say 'x is ', $x

[19:08] <p6eval> nom: OUTPUT«()␤Nil␤x is ␤»

[19:08] <ron__> Think x isn't right there ...

[19:11] <ron__> Shouldn't $m<alpha> come back with something undefined like Nil?  Is it too early to raise nom bugs here?

[19:12] <[Coke]> kboga: will apply your changes shortly, have some on my own on top of that, will push them all after next run.

[19:12] <benabik> ron__: FWIW, I'd expect $m<alpha> to be undef as well.

[19:12] <kboga> cool, thanks [Coke]

[19:13] *** amster left
[19:13] *** soh_cah_toa joined
[19:18] *** whiteknight joined
[19:18] <ron__> thx benabik

[19:20] <benabik> nom: say Nil.defined

[19:20] <p6eval> nom: OUTPUT«Bool::False␤»

[19:20] <benabik> nom: say ()

[19:20] <p6eval> nom: OUTPUT«␤»

[19:20] <benabik> nom: say ().per

[19:20] <p6eval> nom: OUTPUT«Method 'per' not found for invocant of class 'Parcel'␤current instr.: '_block1002' pc 85 ((file unknown):35909303) (/tmp/8KCtdgI9Jf:1)␤»

[19:20] <benabik> nom: say ().perl

[19:20] <p6eval> nom: OUTPUT«()␤»

[19:22] <[Coke]> nom: ().perl.gist.perl.gist.perl.say

[19:22] <p6eval> nom: OUTPUT«"\"()\""␤»

[19:24] *** envi left
[19:32] *** birdwindupbird left
[19:36] <dalek> rakudo/nom: b999db7 | kboga++ | t/spectest.data:

[19:36] <dalek> rakudo/nom: enable passing testfiles: S11-modules/lexical.t, integration/advent2009-day12.t and track some failure messages

[19:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b999db707e

[19:36] <dalek> rakudo/nom: 4b0bc18 | kboga++ | t/spectest.data:

[19:36] <dalek> rakudo/nom: enable passing test: S02-builtin_data_types/instants-and-durations.t

[19:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4b0bc184ac

[19:36] <dalek> rakudo/nom: 4b66f8a | Coke++ | t/spectest.data:

[19:36] <dalek> rakudo/nom: track failure modes & run fudged test.

[19:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4b66f8aad5

[19:37] <moritz> http://moritz.faui2k3.org/tmp/0001-allow-Str.match-Str-which-in-turn-also-restores-Str..patch this is my patch for Str.match(Str)

[19:37] <moritz> sadly it causes lots of regressions

[19:38] <moritz> I'll need to track down why it causes failures, but if anybody beats me to it, I'd appreciate it :-)

[19:38] <jnthn> on no not instants-and-durations.t again!

[19:39] <jnthn> (it reliably hung here before)

[19:39] <jnthn> (maybe something changed though... :))

[19:40] *** tyatpi__ joined
[19:40] <jnthn> wow

[19:40] <jnthn> loads of "Nominal type check failed for parameter '$input'; expected Str but got Hash instead"

[19:40] <sorear> moritz: the one loose end I have is, what should $_ be in CONTROL?  TimToady initially suggested it should be Int, when I said I also needed a CallFrame and a Str hey said a tuple would be fine

[19:41] <benabik> sorear: Int but CallFrame but Str?

[19:41] <jnthn> ouch!

[19:41] *** Mowah_ joined
[19:42] <jnthn> By that point an object woulda been just as cheap :)

[19:42] <jnthn> Or cheaper :)

[19:42] <jnthn> Well, Int is an object :)

[19:42] <sorear> jnthn: by what point, having a tuple, or benabik's joke?

[19:43] <jnthn> sorear: benabik's joke :)

[19:43] <jnthn> I...guess it was one ;)

[19:43] <jnthn> Though it would in theory work with current S14 ;)

[19:43] <moritz> sorear: what could you do with the $_ in a CONTROL block? rethrow?

[19:43] <[Coke]> jnthn: yah, those all use to be issues with GLOBAL mumble.

[19:44] <jnthn> [Coke]: Yeah. They all load Test::Util

[19:44] <sorear> moritz: smartmatch it against stuff

[19:44] <jnthn> [Coke]: And used to have trouble with that. Now they have trouble when calling something in there.

[19:44] <sorear> rethrowing in CATCH is a bad idea

[19:44] <moritz> why?

[19:44] <moritz> (and I thought we played about CONTROL, not CATCH)

[19:45] <moritz> s/played/talked/

[19:45] * moritz distracted

[19:45] <sorear> niecza: sub f() { die "moo"; CATCH { die $_ } }; { f(); CATCH { default { say $_ } } }; say "alive"

[19:45] <p6eval> niecza v8-45-g366d65b: OUTPUT«moo␤moo␤alive␤»

[19:45] <jnthn> Why does it moo twice?

[19:45] <sorear> if a CATCH handler throws an exception, the current exception is treated as "unhandled" and the new exception is pushed on the end

[19:45] <tadzik> double bacon!

[19:46] <jnthn> tadzik: no, beef ;)

[19:46] <sorear> I suspect niecza is the first to handle multiple simultaneously pending exceptions

[19:46] <moritz> maybe there should be a separate .rethrow

[19:46] <sorear> moritz: that's "fall of the end of the CATCH", also "proceed"

[19:47] *** Tedd1^ joined
[19:48] *** ron__ left
[19:49] *** Tedd1 left
[19:49] *** Chillance left
[19:50] *** Chillance joined
[19:50] <moritz> nom: say Match.new(orig => 'abcdefg', from => 0, to => 3)

[19:50] <p6eval> nom: OUTPUT«␤»

[19:51] <moritz> why oh why does that print the empty string?

[19:52] <jnthn> nom: Match.^attrbibutes(:local)>>.has-accessor>>.say

[19:52] <p6eval> nom: OUTPUT«Method 'attrbibutes' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤current instr.: 'dispatch:<.^>' pc 691465 (src/gen/CORE.setting.pir:176061) (src/gen/CORE.setting:589)␤»

[19:52] <jnthn> nom: Match.^attributes(:local)>>.has-accessor>>.say

[19:52] <p6eval> nom: OUTPUT«Bool::True␤Bool::True␤Bool::True␤Bool::True␤»

[19:52] <jnthn> hm

[19:52] <jnthn> Not because of that then.

[19:52] <moritz> nope

[19:52] <moritz> nom: say Match.new(orig => 'abcdefg', from => 0, to => 3).orig

[19:53] <p6eval> nom: OUTPUT«abcdefg␤»

[19:53] <moritz> nom: say Match.new(orig => 'abcdefg', from => 0, to => 3).Bool

[19:53] <p6eval> nom: OUTPUT«Bool::True␤»

[19:53] <jnthn> nom: say Match.new(orig => 'abcdefg', from => 0, to => 3).Str

[19:53] <p6eval> nom: OUTPUT«abc␤»

[19:53] <jnthn> nom: say Match.new(orig => 'abcdefg', from => 0, to => 3).gist

[19:53] <p6eval> nom: OUTPUT«␤»

[19:53] <jnthn> There you go.

[19:53] <jnthn> Note that Match ~~ Capture, and Capture defines a .gist

[19:53] <moritz> nom: class A { method Str() { 'foo' } }; say A

[19:54] <p6eval> nom: OUTPUT«A()␤»

[19:54] <moritz> nom: class A { method Str() { 'foo' } }; say A.new

[19:54] <p6eval> nom: OUTPUT«foo␤»

[19:56] <moritz> oh, I think I found my problem

[19:56] *** fbass joined
[19:57] <moritz> I was calling a public method as self!foo

[19:57] *** rdesfo left
[19:57] <moritz> nom: class A { method b() { 1 }; method doit() { self!b } }; say A.new.doit

[19:57] <p6eval> nom: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Mu'␤current instr.: '_block3723' pc 58682 (src/gen/perl6-metamodel.pir:19376) (src/gen/Metamodel.pm:2567)␤»

[19:57] <moritz> jnthn: that's a LTA error

[19:58] <jnthn> It is indeed.

[20:01] <tadzik> huh

[20:01] <tadzik> Method 'pos' not found for invocant of class 'ResizablePMCArray'

[20:01] <tadzik> current instr.: 'nqp;Perl6;Grammar;package_def'

[20:01] <tadzik> in line: <.attach_docs>

[20:01] <tadzik> what would that be?

[20:01] <moritz> a quantified capture

[20:01] <tadzik> I thought that wouldn't capture

[20:02] <moritz> which is accessed as though it wasn't quantified

[20:02] <tadzik> should I use <.docs()> if it's a method, not a token?

[20:02] <jnthn> I think <.foo> doesn't capture?

[20:03] <moritz> tadzik: something else must be wrong then

[20:03] <tadzik> hmm

[20:09] <dalek> rakudo/nom: 703b1ef | jonathan++ | src/Perl6/Metamodel/ (3 files):

[20:09] <dalek> rakudo/nom: Add a way for adding dispatch fallbacks to a class, for use in implementing handles.

[20:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/703b1ef9fb

[20:09] <dalek> rakudo/nom: 705ae4b | jonathan++ | src/core/traits.pm:

[20:09] <dalek> rakudo/nom: Implement package RHS case of handles.

[20:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/705ae4bfe0

[20:09] <jnthn> That's up to 43 of delegation.t

[20:09] <jnthn> pmichaud++ for fixing ?() so .can works \o/

[20:10] * jnthn tries for the rest of the tests

[20:16] *** timbunce joined
[20:17] <dalek> rakudo/nom: 9ce5cf1 | jonathan++ | src/core/traits.pm:

[20:17] <dalek> rakudo/nom: Match case of delegation.

[20:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9ce5cf1acd

[20:25] <dalek> rakudo/nom: 69b45a2 | jonathan++ | src/core/traits.pm:

[20:25] <dalek> rakudo/nom: Should not enforce ro-ness on things we delegate to.

[20:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69b45a2deb

[20:25] *** mj41 joined
[20:26] <moritz> $ ./perl6 -e 'say "foo".subst("o", "a", :g)'

[20:26] <moritz> faa

[20:26] <dalek> rakudo/nom: b6c6e5b | moritz++ | src/core/ (2 files):

[20:26] <dalek> rakudo/nom: allow Str.match(Str), which in turn also restores Str.subst(Str)

[20:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6c6e5ba03

[20:26] <dalek> rakudo/nom: 516a34d | moritz++ | src/core/Match.pm:

[20:26] <dalek> rakudo/nom: add Match.gist

[20:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/516a34df20

[20:27] <tadzik> moritz++!

[20:27] <tadzik> you may want to see if ufo works now

[20:27] <tadzik> after you add MAIN() at the end of course

[20:28] <jnthn> \o/

[20:28] <jnthn> moritz++

[20:28] <tadzik> Could not find Perl6::Metamodel in any of: /home/tadzik/.perl6/lib, /home/tadzik/.perl6/lib, /home/tadzik/src/parrot/install/parrot/lib/3.6.0-devel/languages/perl6/lib, .

[20:28] <tadzik> uhh

[20:28] <jnthn> tadzik: Old installed version maybe?

[20:28] <tadzik> oh, yes

[20:29] <jnthn> I'm sure I fixed that one up earlier today.

[20:29] <tadzik> Could not locate Perl 6 code object

[20:29] <tadzik> current instr.: '_block6135' pc 633560 (src/gen/CORE.setting.pir:0) (src/gen/CORE.setting:152)

[20:29] <tadzik> now wth is this :/

[20:29] *** soh_cah_toa_ joined
[20:29] <jnthn> The other error message that was cleared up by the fix I did earlier.

[20:30] <masak> so, where do we stand on the whole 'merge nom' thing?

[20:31] <jnthn> hmm...this test is dubious.

[20:31] <jnthn>     class TypePseudoHash { has %!data handles Associative }

[20:31] <jnthn>     my $h = TypePseudoHash.new;

[20:31] <jnthn>     $h<a> = 'c';

[20:31] <jnthn> That handles Associative is a fallback there.

[20:31] *** soh_cah_toa left
[20:32] <jnthn> But we don't hit it because there's a default postcircumfix:<{ }> that we hit in Any

[20:32] <jnthn> Which then wants .at_key, which we don't delegate because it's not in Associative.

[20:32] <tadzik> jnthn: any ideas on https://gist.github.com/1130762 ?

[20:33] <moritz> jnthn: I (and other test authors) kinda assume that Associative and Positional are responsible for access by name/index

[20:33] <jnthn> moritz: Yeah, but I think it's the wrong thing to delegate here.

[20:33] <jnthn> moritz: handles EnumMap or handles Hash would work out just fine though.

[20:33] <tadzik> do only suspiscious thing I did is 'use Perl6::Pod' in Grammar.pm

[20:33] <flussence> masak: if it can run at least some of Text-Tabs-Wrap's t/* then I'm OK with that happening

[20:34] <jnthn> tadzik: Yeah, but didn't we do that for ages?

[20:34] <tadzik> jnthn: no, Actions.pm was using that

[20:34] *** soh_cah_toa_ is now known as soh_cah_toa

[20:34] <flussence> (going to see if it does now)

[20:34] <jnthn> masak: See the punchcard in nommap

[20:34] <tadzik> I only use serialize_aos though, I could remove it

[20:34] <masak> jnthn: ok.

[20:34] <jnthn> tadzik: I'm not sure that's the issue.

[20:34] <jnthn> tadzik: I suspect more a lingering installed version or soemthing.

[20:34] <moritz> jnthn: I'm fine with changing the test

[20:34] <tadzik> gah

[20:35] <tadzik> hmm, fixing the makefile seems to have helped

[20:35] <moritz> jnthn: though in the long run I'd like some spec clarification about the scope of Positional and Associative

[20:35] <masak> jnthn: um... where's nommap? :)

[20:35] *** molaf left
[20:36] <jnthn> masak: NOMMAP.markdown in root of the nom branch :)

[20:36] <masak> oh!

[20:36] <jnthn> :)

[20:36] <masak> found it.

[20:37] <jnthn> moritz: yay. And with that, we pass all of delegation.t :)

[20:38] <moritz> \o/

[20:38] *** molaf joined
[20:38] <moritz> I think we never did before, did we?

[20:38] <dalek> roast: 8f9fd27 | jonathan++ | S12-attributes/delegation.t:

[20:38] <dalek> roast: Since we find a postcircumfix:<{ }> in Any, we never delegate to any method in Any; instead, we really want to delegate to all those in a full-blown Hash implementation if we're trying to act like a hash.

[20:38] <jnthn> It's not fudged, so I presume we did in master.

[20:38] <dalek> roast: review: https://github.com/perl6/roast/commit/8f9fd27d6d

[20:39] <tadzik> what should method foo() in Grammar.pm return, not to cause parsefails?

[20:39] *** kaare_ left
[20:39] <dalek> rakudo/nom: 4c1dbaf | masak++ | NOMMAP.markdown:

[20:39] <dalek> rakudo/nom: [NOMMAP.markdown] fixed faulty markdown

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4c1dbafa13

[20:39] <tadzik> ending it with 1; causes the Method 'pos' not found for invocant of class 'Integer'

[20:40] *** thundergnat left
[20:40] <jnthn> masak: eww, we have to backslash those?

[20:40] <tadzik> returning 0; otoh, causes parsefails

[20:41] <jnthn> tadzik: Some kind of match object I guess...

[20:41] <tadzik> hmm

[20:41] <jnthn> tadzik: You could always make it not a method but instead be

[20:41] <jnthn> token foo() {

[20:41] <jnthn>     { ...block with code in... }

[20:41] <tadzik> yeah

[20:41] <jnthn>    <?>

[20:41] <jnthn> }

[20:42] <jnthn> The <?> means "yeah, this is success"

[20:42] <masak> jnthn: stars are metacharacters in Markdown.

[20:42] <masak> jnthn: vim was helpful enough to color-code to make that abundantly clear. :/

[20:43] <jnthn> masak: Ah, I thought they only played that role at the start of the line.

[20:43] <masak> that's for lists.

[20:43] <masak> they also do italics and bold.

[20:43] <jnthn> oh

[20:43] *** timbunce left
[20:43] <jnthn> yeah

[20:43] <jnthn> d'oh

[20:43] <moritz> Method 'trim-trailing' not found for invocant of class 'Str'

[20:43] <masak> jnthn: seems it might not be necessary to backwhack one or two stars in isolation, but I figgered consistency might be good.

[20:44] <moritz> that's how ufo fails now

[20:44] <jnthn> Ah, a NYI.

[20:44] <pmichaud> back, briefly

[20:45] <jnthn> pmichaud: One more punchcard item down :)

[20:45] <pmichaud> 19:08 <ron__> nom: my $m = '34' ~~ /<digit>+|<alpha>+/; say $m<alpha>.perl; say Nil.perl; my $x = $m<alpha> // 4; say 'x is ', $x

[20:45] <dalek> rakudo/nom: 7cf8457 | jonathan++ | t/spectest.data:

[20:45] <dalek> rakudo/nom: We now pass delegation.t.

[20:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7cf845732f

[20:45] <dalek> rakudo/nom: ea9929d | jonathan++ | NOMMAP.markdown:

[20:45] <dalek> rakudo/nom: Remove delegation from punchcard.

[20:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ea9929da84

[20:45] <pmichaud> since <alpha> is quantified, it's guaranteed to be an Array (possibly empty)

[20:48] <tadzik> yay, I got Declarator blocks in the right order

[20:49] *** timbunce joined
[20:50] <jnthn> tadzik: nice :)

[20:50] *** ggoebel left
[20:51] <pmichaud> can I mark "Delegation" as being complete in features.json?

[20:51] <jnthn> pmichaud: Yes, we pass all that master does.

[20:51] <jnthn> And the implementation is cuter. :)

[20:51] <pmichaud> master is currently marked with +-

[20:52] <pmichaud> (with no reason given why it's +- versus +)

[20:52] <tadzik> aagh. How do I make vim not jump to the beginning of the line when I type '#', am I the only one annoyed?

[20:53] <dalek> features: 3e54256 | pmichaud++ | features.json:

[20:53] <dalek> features: Nom now handles delegation.  jnthn++

[20:53] <dalek> features: review: https://github.com/perl6/features/commit/3e54256881

[20:53] <jnthn> pmichaud: Ah well. nom can be green, then it looks awesomer ;)

[20:54] <pmichaud> we can change it to +- when we know why.  :)

[20:54] <tadzik> nom: class A { method b { sub nested {} } }

[20:54] <p6eval> nom: OUTPUT«Rebuild in progress␤»

[20:54] <tadzik> sigh

[20:54] <tadzik> error:imcc:syntax error, unexpected '\n', says locally

[20:55] <masak> never has imcc been so displeased.

[20:55] <jnthn> hm

[20:55] <tadzik> for all the nested subs actually

[20:55] <tadzik> sub a { sub b {} } fails too

[20:56] <jnthn> tadzik: What happens if you put ; 1 after the nested sub?

[20:56] <tadzik> works then

[20:56] <tadzik> funny :)

[20:56] * jnthn can guess...

[20:56] <tadzik> okay, so the order is fine even for nested subs!

[20:56] <tadzik> now I only need to attach .WHEREFORE appropriately

[20:57] <tadzik> sip of cake

[20:57] <flussence> tadzik: (vim) ...I have no idea. I distinctly remember adding a line to fix exactly that but it's not in my vimrc. (still trying to figure this one out)

[20:58] <jnthn> tadzik: you...sip cake? What's a skill :)

[20:59] *** jaldhar left
[21:00] <pmichaud> nom: my $m = '34' ~~ /<digit>|<alpha>/;  say $m<alpha>.perl

[21:00] <p6eval> nom: OUTPUT«Any␤»

[21:01] <flussence> tadzik: have you installed the vim-perl stuff from github? I think something in there fixes that behaviour for me.

[21:04] *** SHODAN left
[21:07] <tadzik> flussence: I think something there causes that behaviour :)

[21:08] <tadzik> jnthn: that depends on a cake :)

[21:08] <tadzik> I think I may be able to make such :P

[21:09] *** mj41 left
[21:12] <dalek> rakudo/nom: f7e3377 | pmichaud++ | NOMMAP.markdown:

[21:12] <dalek> rakudo/nom: Remove hyperoperators from the punch list.

[21:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7e3377588

[21:13] <dalek> rakudo/nom: f27ddd0 | pmichaud++ | NOMMAP.markdown:

[21:13] <dalek> rakudo/nom: Add "augment" to the punch list.

[21:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f27ddd0fbe

[21:14] <jnthn> pmichaud: Really?

[21:14] <jnthn> pmichaud: How much of the module ecosystem uses augment, ooc?

[21:15] * masak is pretty sure he does, somewhere

[21:15] <jnthn> hm

[21:15] <pmichaud> I don't know off hand.  But I know it's a feature that got used a fair bit.

[21:15] <pmichaud> whether it made it in modules... not sure.

[21:15] <jnthn> Yeah

[21:15] <pmichaud> it'd definitely be seen as a regression from master, I think.

[21:15] <jnthn> I'm not actually sure how to handle it.

[21:15] <jnthn> OK

[21:15] * jnthn checks S12 for hints

[21:15] <pmichaud> Note that I put it in as a "2"  (ought to have) and not a "1" (must have)

[21:16] <jnthn> ok

[21:16] <pmichaud> but it definitely falls somewhere between "1" and "2", and I suspect many people will be sad to see it missing.

[21:16] <masak> agreed :(

[21:17] <pmichaud> http://perl6advent.wordpress.com/2009/12/22/day-22-operator-overloading/  # uses augment

[21:17] <pmichaud> http://perl6advent.wordpress.com/2009/12/17/day-17-making-snowmen/ # uses augment

[21:17] <pmichaud> afk, more errands

[21:17] <jnthn> "It is also possible to extend classes via the augment declarator, but that is considered somewhat antisocial and should not be used for forward declarations." :)

[21:17] <jnthn> How many of our uses are forward decls, I wonder. :)

[21:20] <moritz> nom: say nqp::p6bool(pir::is_cclass__IISI(pir::const::CCLASS_WHITESPACE, '1 2', 2)

[21:20] <p6eval> nom: OUTPUT«Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 1␤current instr.: 'nqp;Regex;Cursor;FAILGOAL' pc 3863 (src/Regex/Cursor.pir:244)␤»

[21:20] <moritz> nom: say nqp::p6bool(pir::is_cclass__IISI(pir::const::CCLASS_WHITESPACE, '1 2', 2))

[21:20] <p6eval> nom: OUTPUT«Class '!macro_const' not found␤current instr.: '_block1002' pc 69 ((file unknown):140) (/tmp/s0lv19WDF8:1)␤»

[21:20] <moritz> what's the problem here?

[21:20] <tadzik> $docee.set_docs($doc);

[21:21] <tadzik> $doc.set_docee($docee);

[21:21] <tadzik> awesome :P

[21:21] <jnthn> :)

[21:21] <moritz> doc, it hurts!

[21:21] <tadzik> docee is a beatiful word

[21:21] <tadzik> it just suits, everywhere :)

[21:22] *** fbass left
[21:22] <masak> looks wrong phonetically, though.

[21:22] <masak> looks like the 'c' should sound like an 's'.

[21:22] <tadzik> shushee

[21:22] <masak> :P

[21:22] <tadzik> "dokii"

[21:22] <masak> okii

[21:22] <dalek> rakudo/nom: b0f733e | moritz++ | src/core/Str.pm:

[21:22] <dalek> rakudo/nom: Str.trim-leading - more efficient than in master

[21:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b0f733e8a6

[21:23] <jnthn> masak: Does it?

[21:24] <masak> jnthn: it's not a hard-and-fast rule, but yes.

[21:24] <masak> 'docent', for example.

[21:24] <jnthn> troo but...stop spoiling the fun :P

[21:25] * moritz -> sleep

[21:25] <masak> jnthn: sorry :P

[21:26] <jnthn> moritz: sleep well :)

[21:27] <tadzik> moritz: g'night

[21:29] <tadzik> get_string() not implemented in class 'Str'

[21:29] <tadzik> oh the irony :P

[21:29] <masak> moritz: dream of a module ecosystem that works under nom.

[21:29] *** moritz left
[21:36] *** tyatpi__ left
[21:37] *** jaldhar joined
[21:38] *** rdesfo joined
[21:41] *** Mowah_ left
[21:41] *** Mowah left
[21:41] *** _jaldhar joined
[21:41] *** jaldhar left
[21:44] *** Psyche^ joined
[21:46] *** meteorjay left
[21:46] *** _jaldhar left
[21:47] *** Patterner left
[21:47] *** Psyche^ is now known as Patterner

[21:48] *** _jaldhar joined
[21:53] *** jaldhar_ joined
[21:53] *** _jaldhar left
[21:59] *** Moukeddar joined
[21:59] <Moukeddar> Hello Perlers o/

[21:59] <tadzik> hello Moukeddar!

[22:00] <Moukeddar> how are you doing Gentlemen ?

[22:00] <tadzik> not bad. Tracking some ugly bugs

[22:01] <Moukeddar> arghhh, nasty work :p

[22:01] <tadzik> yep

[22:01] <tadzik> especially when backtrace looks wrongish :>

[22:02] <jnthn> tadzik: The get_string one?

[22:02] <tadzik> jnthn: yep

[22:03] <jnthn> bt?

[22:03] <tadzik> it's somewhere in SymbolTable.pm

[22:03] <tadzik> say("$type,$primitive,"~pir::join(',', @value)~$namedkey); fails for @value = ['']

[22:03] <tadzik> even say(@value[0])

[22:03] <tadzik> maybe it's not really ''

[22:04] <jnthn> tadzik: Things can appear to be in SymbolTable if you're hitting a path that needs to compile code on-demand

[22:04] <jnthn> tadzik: Are you getting it while compiling the setting?

[22:04] <tadzik> jnthn: yes

[22:05] *** jedai joined
[22:05] <tadzik> but how on earth Perl6::Pod::serialize_aos is supposed to be affected, I don't know

[22:06] <jnthn> tadzik: Where'd you put the say?

[22:07] <jnthn> tadzik: Might it get called before we're done compiling class Str in the setting?

[22:07] *** PacoLinux joined
[22:07] <tadzik> that's not supposed to be a Str anyway

[22:07] <tadzik> it's a call from attach_docs

[22:08] *** shinobicl__ joined
[22:08] *** PacoLinux left
[22:08] <jnthn> tadzik: Maybe I could see the patch and/or backtrace

[22:08] *** PacoLinux joined
[22:09] <tadzik> jnthn: I want to make sure it's not my fault

[22:09] *** tyatpi joined
[22:09] <jnthn> tadzik: Well, even if it is, I may be able to help you see where :)

[22:11] <tadzik> trying one more thing...

[22:12] <tadzik> ETOOMANYNAMES. $*DECLARATOR_DOCS, $*DOC, $*DOCEE...

[22:13] <tadzik> okay, seems that it works :)

[22:13] <tadzik> well, doesn't break :)

[22:14] <tadzik> I'll know if it works in like 8 minutes

[22:17] <bbkr1> i'm stuck at unicode in BSON. if I have string "€" (euro sign) what should I do to unpack it into Buf([0xe2, 0x82, 0xac ])? 

[22:17] *** rdesfo left
[22:18] <sorear> uhh

[22:18] <bbkr1> pack* into buff

[22:18] <sorear> .u €

[22:18] <phenny> U+20AC EURO SIGN (€)

[22:18] <sorear> 20AC really?

[22:18] <sorear> they couldn't have chosen a more reasonable number?

[22:18] <sorear> you want .encode("utf-8") or so

[22:19] <bbkr1> 20AC, wiki confirms

[22:20] <bbkr1> .encode works like charm, thanks

[22:21] <masak> 'night, #perl6.

[22:21] *** masak left
[22:21] <tadzik> he always leaves to fast to say 'gnight'

[22:25] * jnthn has an augment that, er, sometimes works :/

[22:26] <tadzik> :)

[22:27] <tadzik> I could maybe make a pun if I knew what 'augment' means

[22:27] *** Moukeddar left
[22:29] <jnthn> oh, I worked it out

[22:38] <dalek> roast: 27617a5 | jonathan++ | S02-builtin_data_types/lists.t:

[22:38] <dalek> roast: Fix a couple of syntax fails in a recently added test.

[22:38] <dalek> roast: review: https://github.com/perl6/roast/commit/27617a52a0

[22:44] <jnthn> pmichaud: S02-builtin_data_types/list.t looks close to passing; may be worth a quick review, if you have a moment for it.

[22:48] *** shinobicl__ left
[22:48] *** im2ee left
[22:55] <jnthn> pmichaud: Seems I've busted advent2009-day11.t when adding the delegation stuff, somehow missed it.

[22:55] *** fbass joined
[22:56] *** tokuhirom joined
[23:00] <dalek> rakudo/nom: f279a51 | jonathan++ | src/Perl6/Grammar.pm:

[23:00] <dalek> rakudo/nom: First cut of augment support. Seems to work for augmenting trivial classes, but any of the built-in ones seem to have issues post-augment. Also, this will need a re-visit when we get real serialization.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f279a51e98

[23:00] <dalek> rakudo/nom: e15779c | jonathan++ | src/Perl6/Metamodel/MultiMethodContainer.pm:

[23:00] <dalek> rakudo/nom: Clear the list of multi methods to incorporate once we've done so, otherwise we'll hit problems if we come to augment.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e15779c380

[23:00] <dalek> rakudo/nom: 113da42 | jonathan++ | t/spectest.data:

[23:00] <dalek> rakudo/nom: Three more test files passing.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/113da4271e

[23:00] <dalek> rakudo/nom: c7b6534 | jonathan++ | NOMMAP.markdown:

[23:00] <dalek> rakudo/nom: Implemented augment; remove from punch card list.

[23:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c7b65345b1

[23:01] *** PacoLinux left
[23:01] <tadzik> exciting times

[23:02] <jnthn> :)

[23:02] *** Moukeddar joined
[23:04] *** fbass left
[23:04] *** whiteknight left
[23:06] *** lmarcetic joined
[23:07] *** PacoLinux joined
[23:08] *** lmarcetic left
[23:08] *** Moukeddar left
[23:10] *** timbunce left
[23:10] *** drbean joined
[23:11] *** Moukeddar joined
[23:17] <tadzik> jnthn: I think Meta-operators and Missing object model bits can be removed from NOMMAP

[23:18] <tadzik> okay, my patch is non-deterministic and features random segfaults :/

[23:19] *** Moukeddar left
[23:21] <jnthn> congrats!

[23:22] *** wamba left
[23:22] <tadzik> jnthn: want to take a look?

[23:22] *** molaf_ joined
[23:23] <dalek> roast: d8050f5 | jonathan++ | packages/Test/Util.pm:

[23:23] <dalek> roast: Get Test::Util to export a proto rather than dubiously exporting each of the multi individual candidates. This makes it, and tests that use it, usable again.

[23:23] <dalek> roast: review: https://github.com/perl6/roast/commit/d8050f5e9f

[23:24] <tadzik> jnthn: see https://gist.github.com/1130921 test file in a comment

[23:24] <jnthn> tadzik: sure

[23:25] <tadzik> the debug output says it documents a 'Sub' all the time, but the for loop says "not a SixModelObject" in the third one

[23:25] <tadzik> if you remove the for and run with --doc, you can see that it ends up being a CallContext

[23:25] <tadzik> if you just run with --doc, it segfaults

[23:25] <tadzik> say, aren't you intrigued? :)

[23:26] *** molaf left
[23:27] <jnthn> ouch

[23:28] <jnthn> Generally, objects changing under you indicates GC marking issue.

[23:28] <jnthn> Got a gdb bt for the segfault?

[23:28] <tadzik> can get one, yep

[23:29] <jnthn> May or may not help. :)

[23:29] <tadzik> it didn't. It didn't segfault under gdb

[23:30] <tadzik> now it doesn't segfault at all

[23:30] <jnthn> :/

[23:30] <tadzik> okay, got it

[23:30] <tadzik> ...no

[23:30] <tadzik> doesn't segfault under gdb

[23:32] <jnthn> :(

[23:32] <jnthn> Heisgenbug.

[23:32] *** baest left
[23:33] *** ab5tract joined
[23:33] <tadzik> can you reproduce it?

[23:34] <jnthn> I'd have to apply the patch, and I've got a bunch of local diff/test here.

[23:34] <jnthn> Just checked one thing but it looked fine...

[23:35] <jnthn> oh, hmm, I wonder...

[23:36] <jnthn> tadzik: It's a long shot but https://gist.github.com/1130934 applied to nqp could feasibly help

[23:36] *** ab5tract left
[23:36] * tadzik checks out

[23:37] <jnthn> It probably needs doing anyway

[23:37] <jnthn> Though your mixins have attrs so I'd be surprised if this was it

[23:37] *** baest joined
[23:44] <dalek> roast: bb0d7a9 | jonathan++ | S12-class/extending-arrays.t:

[23:44] <dalek> roast: An unfudge for Rakudo.

[23:44] <dalek> roast: review: https://github.com/perl6/roast/commit/bb0d7a93dd

[23:52] <tadzik> jnthn: well, it fixed almost everything :0

[23:52] <tadzik> :)

[23:53] <tadzik> some of the .WHEREFOREs still appear to be a Continuation rather than a Sub

[23:53] *** PacoLinux left
[23:53] <tadzik> even though the compile-time output says it's a Sub

[23:53] *** PacoLinux joined
[23:53] <jnthn> wait, what

[23:54] <jnthn> How can that even happen?

[23:54] <tadzik> why, I'm wondering for like half an hour now

[23:54] <jnthn> You're not somehow exposing the Parrot sub rather than the code object?

[23:55] <tadzik> no way

[23:55] <jnthn> ok

[23:55] <jnthn> Then it sounds like at most the patch moved the bug rather than fixed it.

[23:55] <tadzik> I'll show you something

[23:55] <jnthn> Does running it under Parrot (e.g. run the Perl 6 PBC) and giving -G to Parrot help?

[23:56] <tadzik> hold on

[23:56] <tadzik> jnthn: see https://gist.github.com/1130952

[23:56] <tadzik> I'll check

[23:57] <tadzik> jnthn: yes, it fixes that

[23:57] <tadzik> fixes everything

[23:57] <tadzik> a GC bug, yeah?

[23:59] <jnthn> Yes.

[23:59] <jnthn> Well, mark bug at lesat.

