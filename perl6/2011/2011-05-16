[00:03] *** _jaldhar_ is now known as jaldhar

[00:22] <pmichaud> I'm thinking that it should be a method

[00:22] <pmichaud> .isitem or .is_item might be good first approximations to a name

[00:22] <pmichaud> could even be .flattens

[00:23] <pmichaud> .isflattening

[00:27] *** Chillance left
[00:31] <sorear> pmichaud: what's your favorite .perl syntax for the List type?

[00:35] *** xinming_ joined
[00:37] *** xinming left
[00:43] *** silent_h_ joined
[00:44] *** benabik left
[00:45] *** donri left
[00:52] *** masonkramer joined
[00:56] *** thou joined
[01:07] *** silent_h_ left
[01:08] <pmichaud> goooood question

[01:08] <sorear> I'm going with (1, 2, 3).list for now

[01:08] <sorear> .list.item if needed :)

[01:08] <pmichaud> I'd guess either List.new(...)   or (...).list

[01:12] <TimToady> something that always flattens in list context and doesn't in item context might just be (1,2,3), me would think; the question is whether we expect the resulting value to be forced into list/item context, the avoiding of which I thought this was about

[01:15] * TimToady wonders if that implies eval_list(), eval_item()...

[01:16] <TimToady> or whether eval() can be lazy on that...

[01:24] *** thou left
[01:39] <dalek> niecza: 116226c | sorear++ | / (2 files):

[01:39] <dalek> niecza: New flattening-aware .perl (pmichaud++ for design help)

[01:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/116226c818

[01:40] *** whiteknight left
[01:40] <pmichaud> I think sorear is guarding against the fact that (1,2,3) is in fact a Parcel, and not a list

[01:40] <pmichaud> *not a List

[01:40] <pmichaud> but that's a guess on my part.

[01:41] <sorear> right.

[01:42] <sorear> the idea is that .perl should expose as many fine distinctions as possible

[01:42] <sorear> (1,2,3) and @(1,2,3) are not quite the same - .HOW.name is different - so they should .perl different

[01:43] <sorear> I wonder if the standard .perl methods should actually be submethods

[01:43] *** Khisanth left
[01:43] <sorear> so user-defined subclasses of List or whatever .perl non-misleadingly

[01:44] <pmichaud> well, I'm wondering if (1,2,3) and @(1,2,3) can actually be the same, though -- I mean, a Parcel in list context is still a Parcel

[01:44] *** benabik joined
[01:45] <pmichaud> i.e., the @ doesn't force any additional interpretation on the bare parcel, afaik

[01:45] <pmichaud> (and that's why I was a little hesitant about using .list to mean "List" earlier, too)

[01:45] <pmichaud> rakudo:  say (1,2,3).WHAT

[01:45] <p6eval> rakudo be887a: OUTPUT«Parcel()␤»

[01:45] <pmichaud> rakudo:  say @(1,2,3).WHAT

[01:45] <p6eval> rakudo be887a: OUTPUT«List()␤»

[01:45] <pmichaud> apparently Rakudo currently recasts it as a list, yes.

[01:46] <pmichaud> *List

[01:47] <pmichaud> (darn capitalization puns.  In Texas, we know that "texas" and "Texas" both really mean "TEXAS".  :-P )

[01:47] <pmichaud> (for an avowed non-Texas, I sure like to act like one at times.  Hmm. )

[01:47] <pmichaud> *non-Texan

[01:53] *** dur-randir joined
[01:56] *** Khisanth joined
[02:09] *** flatwhatson left
[02:13] *** agentzh joined
[02:23] *** flatwhatson joined
[02:31] *** masonkramer left
[02:48] *** [particle] left
[02:49] *** [particle] joined
[02:53] *** woosley joined
[03:02] *** alester joined
[03:05] *** woosley left
[03:05] *** bluescreen10 left
[03:18] *** thou joined
[03:19] *** woosley joined
[03:23] *** Su-Shee_ joined
[03:26] *** jlaire left
[03:26] *** Su-Shee left
[03:50] <dalek> niecza: ddee5a5 | sorear++ | / (4 files):

[03:50] <dalek> niecza: Implement term:<rand>

[03:50] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ddee5a5303

[03:53] <sorear> niecza: my @foo = 1,2,3; say @foo.perl;

[03:53] <p6eval> niecza v5-11-g116226c: OUTPUT«[1, 2, 3].list␤»

[03:53] <sorear> niecza: my @foo = 1,2,3; my $x = @foo; say $x.perl;

[03:53] <p6eval> niecza v5-11-g116226c: OUTPUT«[1, 2, 3]␤»

[03:57] *** dur-randir left
[04:08] *** satyavvd joined
[04:44] *** [particle] left
[04:45] *** [particle] joined
[04:48] *** ymasory left
[04:50] *** alester left
[04:50] *** [particle] left
[04:58] *** kaare_ joined
[04:58] *** wamba joined
[05:02] *** risou_awy is now known as risou

[05:02] *** dur-randir joined
[05:12] *** noganex left
[05:13] *** noganex joined
[05:13] <dalek> niecza: a2b2f37 | sorear++ | / (8 files):

[05:13] <dalek> niecza: $_ defaults to $OUTER::_

[05:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a2b2f3782d

[05:15] <dalek> niecza: 622e5dc | sorear++ | / (2 files):

[05:15] <dalek> niecza: Implement validation for "is rw"

[05:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/622e5dc09a

[05:16] *** [particle] joined
[05:17] <pmichaud> sorear: what method name or other did you choose to distinguish between item/list ?

[05:17] <pmichaud> (so I can choose a similar name in Rakudo, and in the List docs that I'm still planning to write someday soon)

[05:18] <sorear> .flattens

[05:18] <sorear> niecza: say [1,2,3].flattens

[05:18] <p6eval> niecza v5-12-gddee5a5: OUTPUT«Bool::False␤»

[05:19] <pmichaud> wfm... we'll use that.

[05:19] <sorear> niecza's $_-handling is a lot closer to spec now

[05:19] <pmichaud> sorear++

[05:20] <sorear> niecza: $_ = 5; if $_ { say $_ } # this will work once p6eval updates

[05:20] <p6eval> niecza v5-12-gddee5a5: OUTPUT«Any()␤»

[05:23] <sorear> I wonder if "ア".."ン" should be treated as an increment range, skipping over "ゲ" etc

[05:29] <TimToady> the song I know puts ン between ワ and ヲso I dunno

[05:32] *** birdwindupbird joined
[05:32] <sorear> I haven't seen iroha used with katakana before

[05:33] *** wamba left
[05:33] <TimToady> metoo, but I just went with what you started :)

[05:34] *** wamba joined
[05:34] <sorear> my current teacher does all of eir bulleting with katakana in gojuuon order

[05:34] <sorear> was hoping I could extrapolate a rule

[05:35] <sorear> for the Perl 6 i18n features we might have a chicken/egg problem - need to reach out to other linguistic communities somehow

[05:36] *** ruoso left
[05:36] <TimToady> was just going to suggest 日本人に話いる。。。

[05:43] *** wamba left
[05:43] *** wamba joined
[05:51] *** wtw_ joined
[06:08] *** nsh left
[06:10] *** nsh joined
[06:12] *** Baggio joined
[06:14] *** Baggio left
[06:20] *** Su-Shee_ is now known as Su-Shee

[06:24] *** baest_ is now known as baest

[06:30] <moritz> sorear: I get a regression in t/spec/S06-multi/lexical-multis.t on niecza

[06:30] <sorear> TimToady: my dictionary does not have /hanairu/, /hanashiiru/, or /wairu/ and I do not know any relevant conjugation patterns

[06:30] <moritz> not ok 9 - inner multi conflicts with outer one

[06:30] <moritz> # /home/moritz/p6/niecza/t/spec/S06-multi/lexical-multis.t line 41

[06:31] <moritz> sorear++ # line numbers for failed tests

[06:31] <moritz> t/spec/S03-operators/relational.t also fails some tests, but iirc pmichaud++ added some in there

[06:31] <sorear> I hold that that test is in conflict with the spec prose

[06:31] <moritz> so probably not a regression

[06:32] <moritz> sorear: should inner multis win?

[06:32] <sorear> the inner and outer multis have the same long name, so the inner multi should completely shadow the outer one, not conflict with it

[06:32] <sorear> (niecza cheats at this by saying "inner multis win ties", which is not quite right)

[06:34] <sorear> yes, S12:1077 says that multis hide outer or less derived multis with the same long name

[06:35] *** woosley left
[06:36] <sorear> rakudo: my $x = 'aaa'; $x--; say $x.perl

[06:36] <p6eval> rakudo be887a: OUTPUT«undef␤»

[06:37] <moritz> how does the "same long name" work out for params with constraints?

[06:37] <sorear> moritz: I keep asking that to no use

[06:38] <sorear> also, I question Rakudo's behavior on the last line

[06:38] <sorear> it does not seem very useful, even if it is what roast looks for

[06:39] <sorear> (the spec itself is rather vague, saying only "fails.")

[06:39] <moritz> perl6: my %h = ( o => 1, 1 => 0 }; my ($a, $b); $a = 1 if %h{0}; $b = 1 if %h{1}; say $a, $b

[06:39] <p6eval> rakudo be887a: OUTPUT«===SORRY!===␤Confused at line 22, near "my %h = ( "␤»

[06:39] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "%h"␤    expecting "=", operator, ")", context, ":" or "("␤    at /tmp/XrLjHdSbHY line 1, column 4␤»

[06:39] <p6eval> ..niecza v5-14-g622e5dc: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Unable to parse parenthesized expression at /tmp/jszl8s3ozx line 1:␤------> [32mmy %h = ([33m⏏[31m o => 1, 1 => 0 }; my ($a, $b); $a = 1 i[0m␤Couldn't find final ')'; gave up at /tmp/jszl8s3ozx line 1:␤------> [32mmy %h = ( o

[06:39] <p6eval> ..=> 1, 1 => 0 …

[06:40] * TimToady just mistyped something between 話す and 話します.

[06:40] <moritz> perl6: my %h = ( 0 => 1, 1 => 0 ); my ($a, $b); $a = 1 if %h{0}; $b = 1 if %h{1}; say $a, $b

[06:40] <p6eval> pugs: OUTPUT«1␤»

[06:40] <p6eval> ..rakudo be887a, niecza v5-14-g622e5dc: OUTPUT«1Any()␤»

[06:41] <moritz> sorear: (unrelated) niecza fails in t/spec/S04-statement-modifiers/values_in_bool_context.t, might be a LHF

[06:41] <dalek> niecza: 772e83c | moritz++ | t/spectest.data:

[06:41] <dalek> niecza: run another integration test

[06:41] <dalek> niecza: review: https://github.com/sorear/niecza/commit/772e83ce8a

[06:41] <moritz> sorear: feel free to fix the multi test according to your spec interpretation, I'd do it myself but i have to leave right now

[06:42] <moritz> bbl

[06:44] <tadzik> hello #perl6

[06:44] <sorear> hi tadzik !

[06:45] <sorear> TimToady: ah

[06:46] <dalek> roast: 98a4c10 | sorear++ | S06-multi/lexical-multis.t:

[06:46] <dalek> roast: Inner multis should hide, not conflict (S12:1077)

[06:46] <dalek> roast: review: https://github.com/perl6/roast/commit/98a4c10bee

[06:50] *** ershov joined
[06:53] * sorear out

[07:01] *** domidumont joined
[07:08] *** fhelmberger joined
[07:22] *** nrr left
[07:29] *** mj41 joined
[07:30] *** nrr joined
[07:35] *** thou left
[07:36] *** woosley joined
[07:50] *** risou is now known as risou_awy

[07:52] *** awoodland joined
[08:00] *** risou_awy is now known as risou

[08:06] *** mberends joined
[08:32] *** dakkar joined
[08:39] *** Mowah joined
[08:41] *** wamba left
[08:49] *** daxim joined
[08:52] *** ershov_ joined
[08:52] *** ershov left
[08:57] *** wamba joined
[09:13] *** bacek left
[09:31] *** bacek joined
[09:33] *** awoodland left
[09:34] *** satyavvd left
[09:35] *** satyavvd joined
[09:37] *** Mowah left
[09:38] *** wamba left
[09:47] *** dju__ joined
[09:47] *** dju_ left
[09:53] *** ershov_ left
[09:54] *** ershov joined
[09:54] *** wamba joined
[10:18] *** ershov left
[10:25] *** icwiener joined
[10:45] <DarthGandalf> perl6: my @a = 1,2,3,4; my @b = 11,12,13,14; @a Z @b

[10:45] <p6eval> pugs, rakudo be887a, niecza v5-15-g772e83c:  ( no output )

[10:45] <DarthGandalf> perl6: my @a = 1,2,3,4; my @b = 11,12,13,14; my @x = @a Z @b; say @x

[10:45] <p6eval> rakudo be887a, niecza v5-15-g772e83c: OUTPUT«111212313414␤»

[10:45] <p6eval> ..pugs: OUTPUT«1234␤»

[10:46] <DarthGandalf> perl6: my @a = 1,2,3,4; my @b = 11,12,13,14; my @x = @a Z @b; say "@x"

[10:46] <p6eval> niecza v5-15-g772e83c: OUTPUT«1 11 2 12 3 13 4 14␤»

[10:46] <p6eval> ..pugs, rakudo be887a: OUTPUT«@x␤»

[10:46] <mberends> .oO( who is right there? )

[10:47] <DarthGandalf> perl6: my @a = 1,2,3,4; my @b = 11,12,13,14; my @c = 21,22,23,24; my @x = @a Z @b Z @c; say "@x"

[10:47] <p6eval> pugs: OUTPUT«@x␤»

[10:47] <p6eval> ..rakudo be887a: OUTPUT«No applicable candidates found to dispatch to for 'infix:<Z>'. Available candidates are:␤:()␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/8lNVfwtWji␤»

[10:47] <p6eval> ..niecza v5-15-g772e83c: OUTPUT«1 11 21 2 12 22 3 13 23 4 14 24␤»

[10:48] <DarthGandalf> Why do they give different output?

[10:49] <DarthGandalf> s/they/rakudo, pugs and niecza/

[10:49] <TiMBuS> It's particularly handy because Perl 6 (unlike Perl 5) won't interpolate a bare array without bracket

[10:49] <TiMBuS> excerpt from s09

[10:50] <TiMBuS> say "@x = @x[]";    # prints @x = 1 2 3

[10:50] <DarthGandalf> perl6: my @a = 1,2,3,4; my @b = 11,12,13,14; my @x = @a Z @b; say "@x[]"

[10:51] <p6eval> rakudo be887a: OUTPUT«1 11 2 12 3 13 4 14␤»

[10:51] <p6eval> ..niecza v5-15-g772e83c: OUTPUT«Unhandled exception: No value for parameter $index in CORE postcircumfix:<[ ]>␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE postcircumfix:<[ ]> @ 0)␤  at /tmp/QyB561ITXa line 1 (MAIN mainline @ 10)␤  at /home/p6eval/niecza/lib/CORE.setting line 1374 (CORE

[10:51] <p6eval> ..C562_ANON @ 2)␤ …

[10:51] <p6eval> ..pugs: OUTPUT«1 2 3 4␤»

[10:52] *** morten__ joined
[10:52] <DarthGandalf> perl6: my @a = 1,2,3,4; my @b = 11,12,13,14; my @c = 21,22,23,24; my @x = @a Z @b Z @c; say "@x[]"

[10:52] <TiMBuS> victory goes to rakudo

[10:52] <p6eval> niecza v5-15-g772e83c: OUTPUT«Unhandled exception: No value for parameter $index in CORE postcircumfix:<[ ]>␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE postcircumfix:<[ ]> @ 0)␤  at /tmp/m94Bhe0ulJ line 1 (MAIN mainline @ 13)␤  at /home/p6eval/niecza/lib/CORE.setting line 1374 (CORE

[10:52] <p6eval> ..C562_ANON @ 2)␤ …

[10:52] <p6eval> ..rakudo be887a: OUTPUT«No applicable candidates found to dispatch to for 'infix:<Z>'. Available candidates are:␤:()␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/Ujbp_7KTxs␤»

[10:52] <p6eval> ..pugs: OUTPUT«1 2 3 4␤»

[10:52] <DarthGandalf> TiMBuS: except few Zs

[10:54] *** morten__ left
[10:54] <TiMBuS> what the heck doesnt match Any

[10:54] <TiMBuS> =/

[10:54] *** mikemol left
[10:55] *** masonkramer joined
[10:55] <mberends> rakudo: my @a = «the rain in Spain»; say @a; say "\@a:@a"; # should interpolate but doesn't

[10:55] <p6eval> rakudo be887a: OUTPUT«theraininSpain␤@a:@a␤»

[10:55] *** masonkramer left
[10:56] <DarthGandalf> oO Does it understand non-" quotes?

[10:57] <mberends> rakudo: my @a = «the rain in Spain»; say @a; say qq/\@a:@a/; # same problem

[10:57] <TiMBuS> oh.. so its calling infix<Z>(@a, @b, @c)

[10:57] <p6eval> rakudo be887a: OUTPUT«theraininSpain␤@a:@a␤»

[10:58] <DarthGandalf> perl6: say «foo», „bar“, “baz”

[10:58] <p6eval> niecza v5-15-g772e83c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Any()Confused at /tmp/QmLPEf4MKz line 1:␤------> [32msay «foo», [33m⏏[31m„bar“, “baz”[0m␤␤Parse failed␤␤»

[10:58] <p6eval> ..pugs: OUTPUT«decodeUTF8': bad data: '\171'␤decodeUTF8': bad data: '\187'␤decodeUTF8': bad data: '\8222'␤decodeUTF8': bad data: '\8220'␤decodeUTF8': bad data: '\8220'␤decodeUTF8': bad data: '\8221'␤*** ␤    Unexpected "\8222"␤    expecting bare or pointy block construct, ":", identifier or opera…

[10:58] <p6eval> ..rakudo be887a: OUTPUT«===SORRY!===␤Confused at line 22, near "say \x{ab}foo\x{bb},"␤»

[10:58] <TiMBuS> destroyed it

[10:59] <TiMBuS> its better to use std: for that stuff

[10:59] <DarthGandalf> std: my @a = 1,2,3,4; my @b = 11,12,13,14; my @c = 21,22,23,24; my @x = @a Z @b Z @c; say "@x[]"

[10:59] <p6eval> std a71faea: OUTPUT«ok 00:01 117m␤»

[10:59] <DarthGandalf> Really?

[10:59] <TiMBuS> yes. if you're checking syntax

[10:59] <DarthGandalf> Ah

[11:00] *** takesako left
[11:02] *** Psyche^ joined
[11:02] *** _jaldhar joined
[11:03] *** tzhs joined
[11:03] *** Patterner left
[11:03] *** Psyche^ is now known as Patterner

[11:04] *** jaldhar left
[11:05] *** jaldhar_ joined
[11:05] *** woosley left
[11:06] *** _jaldhar left
[11:07] *** SHODAN joined
[11:10] *** jaldhar_ left
[11:10] *** jaldhar_ joined
[11:13] *** Trashlord left
[11:14] *** _jaldhar_ joined
[11:14] *** jaldhar_ left
[11:17] <mberends> oh, I misremembered S02:3858: "In order to interpolate an entire array, it's necessary now to subscript with empty brackets:"

[11:17] <mberends> rakudo: my @a = «the rain in Spain»; say @a; say qq/\@a:@a[]/; # no problem

[11:17] <p6eval> rakudo be887a: OUTPUT«theraininSpain␤@a:the rain in Spain␤»

[11:19] *** _jaldhar_ left
[11:22] *** ggoebel left
[11:22] <TiMBuS> rakudo: my @a = «the rain in Spain»; say qq/\@a:\@a[]/;

[11:22] <p6eval> rakudo be887a: OUTPUT«@a:@a[]␤»

[11:22] <TiMBuS> cool

[11:27] *** ggoebel joined
[11:30] *** ab5tract joined
[11:37] *** phenny left
[11:38] *** MayDaniel joined
[11:38] *** _jaldhar_ joined
[11:39] *** nsh left
[11:39] *** sbp left
[11:41] *** phenny joined
[11:42] *** _jaldhar_ left
[11:42] *** _jaldhar_ joined
[11:44] *** _jaldhar_ left
[11:44] *** _jaldhar_ joined
[11:45] *** _jaldhar_ left
[11:45] *** _jaldhar_ joined
[11:49] *** jaldhar joined
[11:50] *** _jaldhar_ left
[11:51] *** phenny left
[11:51] *** Ali_h left
[11:51] <moritz> jdhore: you've been quiet lately... are you still up for the rakudo release on Thursday?

[11:51] <dalek> rakudo: ee21f4b | moritz++ | tools/sublog-report.pl:

[11:51] <dalek> rakudo: [tools] document output format of sublog-report.pl

[11:51] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/ee21f4b746

[11:51] <dalek> rakudo: 577b759 | moritz++ | docs/ChangeLog:

[11:51] <dalek> rakudo: [docs] update ChangeLog

[11:51] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/577b7592f8

[11:52] *** Ali_h joined
[11:54] *** jaldhar left
[11:57] *** phenny joined
[11:57] *** PacoLinux joined
[11:57] *** satyavvd left
[11:57] *** nsh joined
[11:58] *** sbp joined
[12:00] <pmichaud> I'm still seeking comments for http://pmichaud.com/sandbox/relman-draft.txt, if there are any

[12:00] <moritz> pmichaud: my comment is "+1"

[12:01] *** ershov joined
[12:02] *** ab5tract left
[12:02] *** donri joined
[12:03] *** pernatiy joined
[12:04] <pmichaud> also, there's a small chance we'll have to delay the rakudo release on thursday depending on what happens with the parrot release this week

[12:05] *** jaldhar joined
[12:06] <pmichaud> I'm thinking we may want a 2011.05 star release to get some of the performance wins of the past couple of weeks

[12:07] *** jaldhar left
[12:07] *** jaldhar joined
[12:07] <tadzik> speedup smart-matching against numbers and Str.comb with default arguments -- what commit was that?

[12:08] <moritz> two different ones

[12:08] <moritz> 7e81699bf017ff81e6b164fabc971b19d39f0dba

[12:08] <moritz> and

[12:08] <moritz> 6ca6140a4683a66b9f7d54e9a336051d5f564924

[12:09] <tadzik> oh, one is even mine :)

[12:10] *** _jaldhar joined
[12:10] *** jaldhar left
[12:10] <takadonet> morning all

[12:11] <moritz> indeed :-)

[12:13] *** _jaldhar left
[12:13] *** jaldhar_ joined
[12:13] *** tzhs left
[12:14] *** ab5tract joined
[12:15] *** MayDaniel left
[12:20] *** _jaldhar_ joined
[12:20] *** jaldhar_ left
[12:26] *** _jaldhar_ left
[12:31] <daxim> $ xulrunner http://feather.perl6.nl/~audreyt/osdc/vb.xul

[12:31] <daxim> Error: unrecognized application.ini path.

[12:31] <daxim> does this work for you?

[12:33] <tadzik> ENOXULRUNNER

[12:36] <moritz> daxim: I think I just loaded it in firefox

[12:40] <pmichaud> I think I see a bug with the Str.comb patch

[12:41] <pmichaud> rakudo:  say 'hello'.comb(/./, :limit(10)).elems

[12:41] <p6eval> rakudo 577b75: OUTPUT«5␤»

[12:41] <pmichaud> rakudo: say 'hello.comb(:limit(10)).elems

[12:41] <p6eval> rakudo 577b75: OUTPUT«===SORRY!===␤Confused at line 22, near "say 'hello"␤»

[12:41] <pmichaud> rakudo: say 'hello'.comb(:limit(10)).elems

[12:41] <p6eval> rakudo 577b75: OUTPUT«10␤»

[12:41] *** woosley joined
[12:42] *** woosley left
[12:43] <pmichaud> rakudo: sub xyz(:$limit) { $limit min 5 };  say xyz();  say xyz(3);  say xyz(8);

[12:43] <p6eval> rakudo 577b75: OUTPUT«5␤Too many positional parameters passed; got 1 but expected 0␤  in 'xyz' at line 1:/tmp/OE0NH2Nekp␤  in main program body at line 22:/tmp/OE0NH2Nekp␤»

[12:43] <pmichaud> rakudo: sub xyz(:$limit) { $limit min 5 };  say xyz();  say xyz(:limit(3));  say xyz(:limit(8));

[12:43] <p6eval> rakudo 577b75: OUTPUT«5␤3␤5␤»

[12:43] <pmichaud> that works better

[12:43] * pmichaud creates a (failing) test for someone to fix :)

[12:44] *** wknight8111 joined
[12:45] <pmichaud> ...after he takes kids to school.

[12:47] <tadzik> great. I thought there might be something buggy about this, but there was no spectests to prove it :)

[12:47] *** agentzh left
[12:47] <tadzik> the implementation is a bit LTA, I agree

[12:47] *** _jaldhar_ joined
[12:48] * moritz wonders if it would be easier to handle in a single routine body

[12:48] <moritz> and just make the matcher optional, and check if a value has been supplied

[12:49] *** orafu left
[12:53] <daxim> moritz, xul does not work anymore in firefox 4, else I wouldn't ask

[12:56] *** PacoLinux left
[12:56] <moritz> it must have advantages to run Debian stable :-)

[12:59] *** Holy_Cow joined
[13:03] *** Holy_Cow left
[13:05] <pmichaud> rakudo: sub xyz($c) { 3 < $c };  say xyz(5);

[13:05] <p6eval> rakudo 577b75: OUTPUT«Bool::True␤»

[13:05] <pmichaud> rakudo: sub xyz($c) { 3 < $c };  say xyz(*);

[13:05] <p6eval> rakudo 577b75: OUTPUT«Cannot take numeric value for object of type Whatever␤  in 'Any::Numeric' at line 1485:CORE.setting␤  in 'infix:<<>' at line 7654:CORE.setting␤  in 'xyz' at line 22:/tmp/D4QBSEe_js␤  in main program body at line 22:/tmp/D4QBSEe_js␤»

[13:06] <moritz> rakudo: say Whatever ~~ Cool

[13:06] <p6eval> rakudo 577b75: OUTPUT«Bool::False␤»

[13:06] <moritz> I guess it should be infix:<< < >>(Cool $a, Cool $b)

[13:06] <moritz> and thus do a dispatch failure

[13:07] <pmichaud> well, there still needs to be an Any

[13:07] <moritz> why?

[13:07] <pmichaud> not every (user-defined) numeric thingy will be Cool

[13:07] <moritz> if it's neither Numeric nor Cool, it should better provide its own comparison operators

[13:08] <pmichaud> checking

[13:08] <moritz> because those are the tools we offer for automagic handling of custom types that are similar-ish to built-in types

[13:10] <pmichaud> according to S03, all that a type has to do is provide a way to convert to Num

[13:10] <pmichaud> I think S03 is wrong there.

[13:11] * moritz too

[13:11] <pmichaud> (or fossiled)

[13:11] <pmichaud> As in Perl 5, converts to C<Num> before comparison.  C<!=> is short for C<!==>.

[13:11] <moritz> but what does it convert?

[13:12] <pmichaud> currently Rakudo uses prefix:<+> to convert each side to a numeric form before comparing

[13:12] <moritz> rakudo: say + rx/a/

[13:12] <p6eval> rakudo 577b75: OUTPUT«maximum recursion depth exceeded␤  in 'Cool::Numeric' at line 1910:CORE.setting␤  in 'Cool::Numeric' at line 1910:CORE.setting␤  in 'Cool::Num' at line 7654:CORE.setting␤  in 'Cool::Numeric' at line 1910:CORE.setting␤  in 'Cool::Numeric' at line 1910:CORE.setting␤  in

[13:12] <p6eval> ..'Cool::Num' a…

[13:13] <mathw> fun

[13:13] <moritz> pingpong between .Num and .Numeric

[13:13] <mathw> so rakudo expects a meaningful prefix:<+> and S03 says you need conversion to Num... fight!

[13:13] <pmichaud> currently Rakudo uses .Numeric for prefix:<+>

[13:14] <pmichaud> which means it's not necessary for a type to ~~ Numeric to participate in numeric operators

[13:14] <mathw> What's the difference between Num and Numeric?

[13:14] <pmichaud> Numeric is the role for numbers

[13:14] <moritz> mathw: Num is floating-point

[13:14] <colomon> Num is floating point

[13:14] <pmichaud> Num is specifically for floating-point stuff

[13:14] <colomon> Numeric is abstract concenpt of number

[13:14] <mathw> Okay

[13:14] * moritz notes: discussions about numebers in rakudo conjure colomon++ out of thin air :-)

[13:15] <mathw> :)

[13:15] * colomon suddenly feels like one of the Three Witches

[13:15] <pmichaud> anyway, even if S03 is changed to be C<Numeric>, I'd hold that the numeric comparisons aren't limited to ~~ Numeric

[13:15] <mathw> My inner Haskell programmer says all number-ish things should do Numeric

[13:15] <colomon> S03 should definitely say Numeric, IMO

[13:15] *** mtk joined
[13:15] <pmichaud> just like the string comparisons aren't limited to ~~ Stringy

[13:15] <mathw> But 'be convertible to Numeric' is more Perlish

[13:16] <colomon> that's certainly how I pictured things when I was re-arranging them last spring.

[13:16] <mathw> if Num's specific on floating point then it seems like the wrong choice here

[13:16] <colomon> rakudo: say 4 < "5"

[13:16] <p6eval> rakudo 577b75: OUTPUT«Bool::True␤»

[13:17] *** mikemol joined
[13:18] <colomon> what's pir::set__NP(self) do?

[13:18] <pmichaud> creates a num register with the value of self

[13:18] <pmichaud> basically   $N99 = self

[13:19] <colomon> would that implicitly call .Num?

[13:19] <pmichaud> well, it calls the get_number vtable

[13:19] <pmichaud> which in turn calls .Num

[13:19] <moritz> ... which in turns calls .Numeric

[13:19] <moritz> or something

[13:19] <colomon> right, Cool.Num definitely calls .Numeric

[13:19] <moritz> it's a problem that we depend on the parrot vtables for string -> number conversions and the other way round

[13:20] <pmichaud> well, not so much "depend on" as "support"

[13:20] <moritz> we depend on it, in the current code

[13:20] <pmichaud> we can do it without the dependency if we want.  but if we want non-Rakudo types to participate in Perl 6 programs, we have to support the vtables

[13:20] <moritz> the actual conversion of +"3.4" happens in the get_number vtable

[13:20] <moritz> agreed

[13:21] <moritz> what I wanted to say that the usage of the vtables internally is the problem

[13:21] <moritz> it was convenient and efficient back then

[13:21] <moritz> but it leads to circularity issues as in the case demonstrated above

[13:21] <pmichaud> actually, it's never been convenient nor efficient :-)

[13:22] <moritz> and it means that +"3" returns a Num and not an Int

[13:22] <pmichaud> at the time it was necessary because we didn't have .Numeric worked out, or an easy way to convert string to num

[13:22] *** ab5tract left
[13:22] <mathw> Why do I get the impression every time I witness one of these conversations that the goal is always to rely on Parrot less and less?

[13:23] <pmichaud> mathw: that's generally been a goal (more)

[13:23] <pmichaud> mathw: but more importantly, Parrot's object and vtable model is often completely backwards from what Perl 6 expects

[13:23] <pmichaud> this is one of those cases

[13:23] <moritz> mathw: a way to look at it is that parrot provides something vaguely p6ish. The more we refine the semantics of rakudo, the less we can rely on those defaults

[13:24] <pmichaud> a better way to look at is is that parrot provides something vaguely p5ish.

[13:24] <pmichaud> *it

[13:24] <colomon> and we're (understandably) faster at changing when the p6 spec changes.

[13:24] <pmichaud> parrot has little intention of changing in response to the p6 spec

[13:24] <pmichaud> that's been true for several years no.

[13:24] <pmichaud> *now

[13:25] *** larsen_ left
[13:25] <mathw> well of course

[13:25] <mathw> they don't exist just to service Rakudo

[13:25] <colomon> pmichaud: understanding that we will definitely need get_number for "foreign" objects, does it make any sense calling it from Cool?  Are foreign objects intended to be Cool?

[13:25] <mathw> also it helps with the possibility of running Rakudo on something else I suppose :)

[13:26] <pmichaud> colomon: I'm a little uncertain why Cool.Num calls .Numeric

[13:27] <pmichaud> (looking at code now)

[13:27] <pmichaud> an, it gets a Numeric, and takes the Num of that

[13:27] <colomon> because it relies on the Numeric  .Num method

[13:27] <colomon> yes

[13:27] <pmichaud> okay, that makes sense

[13:28] *** JimmyZ joined
[13:29] <pmichaud> while I believe that foreign objects can act Cool, I don't think they default to being ~~ Cool

[13:29] <pmichaud> that's what the vtables do right now

[13:30] <colomon> seems like the appropriate factoring (at least for this) would be something like:

[13:31] <colomon> Cool.Numeric does nothing by default

[13:31] <colomon> There's a Foreign.Numeric which does pir::set__NP(self)

[13:31] <colomon> and Foreign is a role which foreign objects are expected to do.

[13:32] <pmichaud> I'm not sure about the Foreign role

[13:32] <pmichaud> at one time numeric and string conversion were tied to prefix:<+> and prefix:<~>

[13:33] *** _jaldhar_ left
[13:33] *** mtk left
[13:33] <pmichaud> could be that Foreign is some sort of type definition

[13:33] <pmichaud> i.e., anything that isn't Mu|Any|Cool|something

[13:33] <moritz> can't we check if $thing ~~ Mu, and if not, it's foreign and goes through the vtable?

[13:34] <pmichaud> I'm not sure that Mu is the type for perl6-only objects

[13:34] <pmichaud> I think Mu has to encompass foreign objects also

[13:34] <pmichaud> otherwise you can never pass a foreign object to a subroutine that has Mu as its type

[13:34] <pmichaud> same for scalar assignment

[13:34] <moritz> right

[13:34] <colomon> I suggest a Foreign role merely because it does make sense that foreign objects call the Parrot vtable functions, and it should be easy to do.

[13:35] <colomon> they should probably be Any, too, shouldn't they?

[13:35] <pmichaud> colomon: it's not easy to get all of the foreign subroutines to return values that ~~ Foreign

[13:35] <colomon> pmichaud: ah

[13:35] <moritz> we do need a simple-ish way to check if an object is a Perl 6 object

[13:35] <moritz> maybe we can abstract that out into some function, and use that everywhere

[13:36] <moritz> where "everywhere" is hopefully only a handful of places :-)

[13:36] <pmichaud> anyway, I'm fine if Cool.Numeric doesn't exist

[13:37] <pmichaud> all of which gets back to my original question -- what should be the result of    infix:«<»(3, *)   ?

[13:37] <colomon> moritz: you're thinking something like Any.Numeric { if self.foreign { pir::set__NP(self) }   ?

[13:37] <moritz> colomon: yes

[13:38] <colomon> moritz: makes sense

[13:38] *** mtk joined
[13:38] <pmichaud> note that we also have the vtables in case any other Parrot languages want to use Perl 6 objects :-)

[13:39] <colomon> pmichaud: is that "*" in the formal Whatever sense, or in the generic wildcard sense?

[13:39] <moritz> the Whatever object

[13:39] <pmichaud> I mean * as a Whatever argument, yes.

[13:40] <moritz> something that's ~~ Any but !~~ Cool

[13:40] <colomon> seems like it's an error?  you're not expecting Whatever currying there, right?

[13:40] <pmichaud> no, that's different

[13:40] <pmichaud> (to moritz)

[13:41] <moritz> colomon: only operators curry, not function calls

[13:41] <pmichaud> if I pass a ~~ Any object that doesn't have .Numeric, I expect infix:<+> to fail with "cannot get numeric value of object"

[13:41] <pmichaud> but it seems weird to say "cannot get numeric value of Whatever" when in fact we do it in a lot of places

[13:41] <moritz> colomon: and only at compile time, ie my $x = *; $x < 3  will not curry

[13:42] <moritz> pmichaud: we don't, strictly speaking

[13:42] <moritz> pmichaud: we supply default numeric values for * based on context

[13:42] <pmichaud> well, "supply a default numeric value" then

[13:43] <colomon> pmichaud: are you suggesting Whatever might translate to Inf in this case?

[13:43] <pmichaud> clearly we're in a numeric context with infix:«<»

[13:43] <moritz> or -Inf, or NaN

[13:43] <pmichaud> colomon: I'm thinking Whatever might always return true in this case

[13:43] <moritz> like the opposite of NaN

[13:43] *** brill joined
[13:43] <pmichaud> because  while   3 < *   it's also true that 3 > *   :-)

[13:44] <pmichaud> (not syntactically)

[13:44] <moritz> we write that  * <3  in modern language :-)

[13:44] <moritz> s/that/that as/

[13:44] <pmichaud> rephrase:   my $x = *;   say $x < 3;  say $x > 3;

[13:45] <pmichaud> an interesting question might be infix:<min>(3, *) 

[13:45] <colomon> Huh.  It obviously can be done, but I'm not sure why we'd want to have it work that way?

[13:45] <pmichaud> colomon: I'm seeing a lot of places where we check if an argument is Whatever and then have to do something weird based on that

[13:45] <pmichaud> especially for, say, the $limit parameter to .comb

[13:46] * moritz would prefer it if * only had a special meaning in cases where its meaning is pretty much obvious

[13:46] <pmichaud> whatever.  :-P

[13:46] <pmichaud> (scnr)

[13:46] <moritz> :-)

[13:48] *** wamba left
[13:48] <colomon> pmichaud: looking at .comb, for instance, you'd also have to define prefix:<-->(Whatever)

[13:49] <pmichaud> colomon: I would?

[13:49] <pmichaud> no.

[13:50] <colomon> .comb counts down based on $limit

[13:50] <pmichaud> yes, but it doesn't decrement $limit

[13:50] *** brill left
[13:50] <moritz> you could just as well count up, and check against 0..$limit

[13:50] <colomon> yes, but it decrements $l, which is the copy of $limit

[13:50] <moritz> that way you don't even need to special-case $limit

[13:51] <pmichaud> colomon: I'm saying that I'd like $l to be set to something else

[13:51] <pmichaud> I'm not looking at the regular case, I'm looking at the optimized case, where we know the maximum limit ($str.chars)

[13:51] *** woosley joined
[13:51] <pmichaud> I can then write

[13:52] <pmichaud>     method comb(:$limit) {  my $to = min(self.chars, $limit); ... }

[13:52] *** brill joined
[13:52] <pmichaud> but that doesn't work if someone writes    $str.comb(:limit(*))

[13:52] *** PacoLinux joined
[13:53] <pmichaud> it fails with "cannot take numeric value of Whatever"

[13:53] <pmichaud> which feels inconsistent to me somehow

[13:53] *** ershov left
[13:54] <pmichaud> but I think I agree that ambiguity is best handled with an explicit exception than with a  possibly surprising outcome

[13:54] <colomon> maybe I'm missing something (I vaguely feel like I am) but to me this discussion pretty strongly argues against the idea that Whatever should have magic properties in this way.

[13:54] *** MayDaniel joined
[13:55] <pmichaud> rakudo:  my $x = *;   say 3 ~~ ^$x

[13:55] <p6eval> rakudo 577b75: OUTPUT«Cannot take numeric value for object of type Whatever␤  in 'Any::Numeric' at line 1485:CORE.setting␤  in 'prefix:<^>' at line 7654:CORE.setting␤  in main program body at line 22:/tmp/Vjb1zdJRic␤»

[13:55] <colomon> because what you've just said makes me think that you really want min($a, *) to be $a always.

[13:56] <pmichaud> colomon: right, that's why I said min is an interesting case... and why I'm now thinking it's not a good idea :)

[13:56] <pmichaud> rakudo:  my $x = *;  say 3 ~~ 0 .. $x

[13:56] <p6eval> rakudo 577b75: OUTPUT«Bool::True␤»

[13:56] <pmichaud> rakudo:  my $x = *;  say 3 ~~ 0 ..^ $x

[13:56] <p6eval> rakudo 577b75: OUTPUT«Bool::True␤»

[13:56] <pmichaud> rakudo:  my $x = *;  say 3 ~~ ^ $x

[13:56] <p6eval> rakudo 577b75: OUTPUT«Cannot take numeric value for object of type Whatever␤  in 'Any::Numeric' at line 1485:CORE.setting␤  in 'prefix:<^>' at line 7654:CORE.setting␤  in main program body at line 22:/tmp/j0o0kheJLt␤»

[13:57] <pmichaud> that looks like a bug

[13:57] <moritz> aye

[13:57] <colomon> I fear it's an optimization

[13:57] <pmichaud> why would that want optimizing?

[13:57] <colomon> our multi sub prefix:<^>($max) {

[13:57] <colomon>     0..^+$max;

[13:57] <colomon> }

[13:57] <colomon> not optimization

[13:57] <colomon> sorry

[13:58] <colomon> the idea was that ^"10" should be 0..^10, not an error

[13:58] <colomon> or rather, 0 .. ^"10"

[13:58] *** brill left
[13:58] <moritz> add a  multi sub prefix:<^>(Whatever $) { 0..* }

[13:58] <pmichaud> I prefer to take away, rather than add :-)

[13:58] * moritz too, but that's not always how Perl 6 workds

[13:59] <colomon> I'm pretty sure we really want ^"10" to take the Numeric value there, because ^$a doesn't make sense otherwise

[13:59] <colomon> and that's likely to be a common case, too, with user input and such

[14:00] <moritz> maybe +* should just return * # probably totally insane

[14:00] <colomon> I can see where adding moritz's multi makes sense

[14:00] <pmichaud> that's another case that argues in favor of    Whatever.Numeric returns +Inf, though.

[14:00] <colomon> moritz: nope, that's totally insane.  :)

[14:01] <colomon> pmichaud: I like Whatever.Numeric returns +Inf much better than I like the idea of having Whatever be magic in Numeric comparison operations.

[14:02] <colomon> pmichaud: though in the case of ^*, Whatever already has a specific meaning of +Inf in that context. 

[14:02] *** mkramer joined
[14:02] <moritz> rakudo: say +Inf / 2

[14:02] <p6eval> rakudo 577b75: OUTPUT«Inf␤»

[14:03] *** bluescreen10 joined
[14:03] *** woosley left
[14:07] * pmichaud files tickets, to deny masak++ the chance to do it :)

[14:07] *** mkramer left
[14:07] <colomon> pmichaud++ # masak denial

[14:08] *** mkramer joined
[14:08] *** slavik1 joined
[14:10] <moritz> pmichaud: locally I implemented an --ignore-parrot-rev option to Configure.pl which skips the PARROT_REVISION check (useful for checking parrot branches)

[14:10] <moritz> pmichaud: should I push it?

[14:11] <pmichaud> option might want a different name, but that's fine for now

[14:11] <moritz> I also have a t/harness patch that allows you RAKUDO_SUBLOG all spectest files, but I think that one isn't very useful

[14:11] <moritz> because most sublogs look very similar

[14:13] *** lateau joined
[14:17] <dalek> rakudo: 631085c | pmichaud++ | src/ (2 files):

[14:17] <dalek> rakudo: Move Mu.item to builtins/Mu.pir; results in 8%+ overall speed improvement.

[14:17] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/631085c98d

[14:17] <dalek> rakudo: ec5cdf5 | pmichaud++ | / (2 files):

[14:17] <dalek> rakudo: Merge branch 'master' of github.com:rakudo/rakudo

[14:17] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/ec5cdf5fe7

[14:18] <pmichaud> forgot to push that fix yesterday

[14:23] <dalek> rakudo: ca8731c | moritz++ | Configure.pl:

[14:23] <dalek> rakudo: [build] add --ignore-parrot-rev option to Configure.pl which allows you to build parrot branches which are behind build/PARROT_REVISION

[14:23] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/ca8731c189

[14:27] *** Mowah joined
[14:29] *** Trashlord joined
[14:33] *** satyavvd joined
[14:35] *** ymasory joined
[14:38] *** nymacro left
[14:38] *** wtw_ left
[14:39] *** ymasory left
[14:40] *** ymasory joined
[14:40] *** Trashlord left
[14:41] <sorear> good * #perl6

[14:42] *** spq joined
[14:43] *** Trashlord joined
[14:43] *** MayDaniel left
[14:44] <TimToady> good morning #sorear :)

[14:44] <moritz> \o

[14:46] <colomon> o/

[14:49] *** bluescreen10 left
[14:50] *** Trashlord left
[14:52] <sorear> niecza: my @foo = 1,2,3; say "@foo"

[14:52] <p6eval> niecza v5-15-g772e83c: OUTPUT«1 2 3␤»

[14:52] <sorear> ...

[14:52] <moritz> BUG

[14:52] *** Trashlord joined
[14:53] <moritz> sorear: did you see my comments about a potentially LHF test file earlier?

[14:53] <sorear> see, yes, pay attention to, no

[14:53] <sorear> I'll check that now

[14:53] <moritz> ok :-)

[14:55] <PerlJam> have person1 and person2 been identified from http://pmichaud.com/sandbox/relman-draft.txt ?

[14:57] * mberends rules himself out

[14:58] * moritz doesn't feel qualified about low-level parrot stuff

[14:59] <moritz> otherwise I could do it, I hang out in #parrot anyway :-)

[14:59] <PerlJam> I don't think low-level knowledge is required.

[14:59] <PerlJam> moritz: I was thinking that you and jnthn would be the perfect people for this job.

[14:59] <colomon> Seems like low-level knowledge would be very helpful.

[14:59] <sorear> std: say "$_." ~ "(undef)"

[14:59] <p6eval> std a71faea: OUTPUT«ok 00:01 115m␤»

[15:00] <PerlJam> colomon: it's always helpful  :)

[15:00] <sorear> std: say "$_."~"(undef)"

[15:00] <p6eval> std a71faea: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of undef as a value; in Perl 6 please use something more specific:␤  Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  Nil as an empty list,␤  :!defined as a matcher,␤        Any:U as a type constraint␤

[15:00] <p6eval> ..    or fail() as…

[15:00] <PerlJam> But this is a "relationship manager" position.  It's all about the people.

[15:00] <sorear> what's the difference here?

[15:01] <TimToady> ."~" is a method call

[15:01] <sorear> ." ~ " isn't?

[15:01] <PerlJam> not with whitespace

[15:01] <TimToady> whitespace is disallowed

[15:01] <sorear> whitespace in a quoted string is disallowed?

[15:01] <TimToady> otherwise any quote ending with ." tends to misfire

[15:01] *** Trashlord left
[15:02] <TimToady> and a lot of quotes end with a period

[15:02] *** Trashlord joined
[15:02] <TimToady> if you want whitespace, you can just put the whole thing into {...}

[15:03] <sorear> ah, '# dwim on "$foo."'

[15:03] <TimToady> and it's another spot where Perl is prejudiced against people who don't put whitespace around their infixes :)

[15:04] <TimToady> the @foo interpolate is determined by $*QSIGIL in termish, in std STD

[15:04] *** woosley joined
[15:04] <TimToady> s/te/tion/

[15:04] *** bluescreen10 joined
[15:04] <TimToady> I suspect it's one of those spots where your parser is divergent

[15:04] <TimToady> since it's close to EXPR :)

[15:05] <sorear> AFAICT std STD will parse @foo in "", it just sets $*VAR to 0

[15:06] <sorear> cf. line 2047

[15:09] <TimToady> hmm, well, it probably needs to pass more info back up to the nibbler, or fail <escape> outright

[15:11] <pmichaud> PerlJam: no, <person1> and <person2> have not been identified yet.  That's one of the things I'm especially looking for feedback on :)

[15:11] *** Trashlord left
[15:11] <TimToady> those have different semantics, if you have "@(stuff)", since stuff is reparsed if <escape> fails

[15:11] *** Trashlord joined
[15:12] <TimToady> oh wait, @(stuff) passes the bracket rule, so never mind

[15:12] *** woosley left
[15:15] *** SHODAN left
[15:17] <pmichaud> and, I'm not ruling myself out as a candidate for <person1> or <person2> -- just didn't want to imply that I should be one.

[15:18] <TimToady> hmm, wait, it requires + postfixes, so no

[15:19] <TimToady> maybe it should require * postfixes so that @(...) works, or @() should force QSIGIL to $

[15:21] *** Trashlord left
[15:22] <TimToady> simplest would be to change + to * in termish

[15:22] *** Trashlord joined
[15:22] * TimToady suspects

[15:26] *** Trashlord left
[15:27] *** benabik left
[15:28] <sorear> pmichaud: do you want a public nomination process or..

[15:34] *** lateau left
[15:35] <PerlJam> sorear: whiteknight and cotto self-selected from the parrot side of the house.  Maybe if someone would volunteer ?

[15:36] <pmichaud> I'm just looking for opinions who who people would like to see

[15:36] <pmichaud> doesn't have to be a formal process -- I think we can get to a consensus opinion easily enough

[15:37] <pmichaud> my off-the-top-of-my-head candidates would be (no particular order):  jnthn, moritz, masak, PerlJam, myself

[15:37] <sorear> mine too.

[15:38] <sorear> rakudo: say join " ", Mu.^methods(:locall).sort

[15:38] <moritz> aka "the people that hang out in #parrot and are involved a bit longer"

[15:38] <p6eval> rakudo 577b75: OUTPUT« BUILD BUILDALL Bool CREATE Capture PARROT WALK WHENCE WHERE WHICH bless clone defined item new not notdef note perl print say so␤»

[15:38] * moritz hopes that Mu doesn't have any methods that are not :local :-)

[15:38] <pmichaud> I say that even sorear++ could be a candidate, although he's a bit niecza focused (as he should be)

[15:39] <sorear> How many of those should be in Mu, and how many are missing?

[15:39] <moritz> rakudo: say join " ", Mu.^methods.sort

[15:39] <p6eval> rakudo 577b75: OUTPUT« BUILD BUILDALL Bool CREATE Capture PARROT WALK WHENCE WHERE WHICH bless clone defined item new not notdef note perl print say so␤»

[15:39] <sorear> rakudo: say join " ", Mu.^methods(:local).sort

[15:39] <p6eval> rakudo 577b75: OUTPUT« BUILD BUILDALL Bool CREATE Capture PARROT WALK WHENCE WHERE WHICH bless clone defined item new not notdef note perl print say so␤»

[15:39] <sorear> rakudo: say join " ", Mu.^parents

[15:39] <p6eval> rakudo 577b75: OUTPUT«␤»

[15:40] <sorear> what, no parrot;Object ?

[15:40] <moritz> iirc WHICH shouldn't be a method

[15:40] <moritz> and PARROT is non-spec, obviously

[15:40] *** alester joined
[15:41] <sorear> right now niecza doesn't have Mu.item, leading to certain problems

[15:41] <pmichaud> would Mu need Str & Stringy ?

[15:42] <pmichaud> (Mu.^methods doesn't display its vtable methods.)

[15:42] <sorear> niecza's mu has head, flattens, typename, Str, succ, pred, notdef, ACCEPTS, perl, defined, and Bool

[15:43] <sorear> waitasecond

[15:43] <sorear> rakudo: say Mu.^methods(:local).grep(* eq "")

[15:43] <p6eval> rakudo 577b75: OUTPUT«␤»

[15:43] <sorear> rakudo: say Mu.^methods(:local).grep(* eq "").perl

[15:43] <p6eval> rakudo 577b75: OUTPUT«({ ... })␤»

[15:44] <sorear> a single nameless method!

[15:44] <moritz> sorear: known artifact from vtables

[15:44] <moritz> sorear: parrot vtables couldn't be :anon last I looked

[15:44] <moritz> sorear: so we install them with name ''

[15:45] *** jfried joined
[15:45] <sorear> oh my Mu also has so, not, RAWCREATE, CREATE, new

[15:57] <sorear> I thought my %foo declared a Hash[Any]?

[15:57] <TimToady> .o(Mu should not have anything that should autothread...)

[15:58] <TimToady> by default, Hash[Str]

[15:58] <moritz> but should it have everything that should not autothread?

[15:58] <sorear> TimToady: Hash[Str,Any]?

[15:58] <moritz> rakudo: my %h = a => Mu, b => 2; say %h.perl

[15:58] <p6eval> rakudo 577b75: OUTPUT«{"a" => Mu, "b" => 2}␤»

[15:58] <sorear> urk

[15:58] * moritz thinks that's sensible

[15:59] <moritz> scalars and arrays accept Mu too

[15:59] <moritz> why not hashes?

[15:59] <moritz> and what would it mean if  %h<a> = 1|2|3  autothreads?

[15:59] <moritz> or would it typecheck-fail?

[16:00] <sorear> scalars don't accept Mu unless you specifically ask them to

[16:00] <TimToady> it arguably should fail

[16:00] <sorear> the default type of scalars is "Any"

[16:00] <moritz> sorear: I thought the compromise was that scalars are typed to Mu, but default to Any

[16:00] <TimToady> I think rakudo makes a distinction between "default" and "accepts", which I'm not sure I believe in

[16:01] <sorear> I'm not sure I beleive in it either

[16:01] * moritz hates the whole junctions business

[16:01] *** domidumont left
[16:02] <moritz> they are neat in places, but probably not neat enough to warrant so much confusion and deep design implications

[16:02] <sorear> also, I'm planning to implement Parcel Seqification as a part of the assign type checking path

[16:02] <moritz> don't worry, I'm not seriously suggesting to toss junctions, I just rant a bit

[16:03] * TimToady woudn't toss 'em anyway :P

[16:03] <moritz> thought so :-)

[16:03] <TimToady> cuz I are a lingrist

[16:03] <PerlJam> TimToady: as long as you don't have any linguistic surprises waiting in the wings ... :)

[16:03] <sorear> niecza: anon method foo($x:) { self }

[16:03] <p6eval> niecza v5-15-g772e83c: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/T0auWivVlO line 1:␤------> [32manon method foo([33m⏏[31m$x:) { self }[0m␤␤Unhandled exception: System.Exception: Unable to find lexical self in foo␤␤Server stack trace: ␤  at

[16:03] <p6eval> ..Niecza.CLRBackend.NamProcessor.ResolveLex…

[16:05] <dalek> niecza: 3fd8a5d | sorear++ | / (2 files):

[16:05] <dalek> niecza: Do not interpolate bare @vars

[16:05] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3fd8a5db5c

[16:05] <dalek> niecza: 2af2593 | sorear++ | lib/ (2 files):

[16:05] <dalek> niecza: Greatly increase usable range of Mu

[16:05] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2af2593672

[16:07] <dalek> niecza: d96efe7 | sorear++ | t/spectest.data:

[16:07] <dalek> niecza: S04-statement-modifiers/values_in_bool_context.t now passes

[16:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d96efe7566

[16:07] <sorear> moritz++

[16:08] *** kjeldahl joined
[16:08] <sorear> I feel the need to catalog #perl6 users by non-English native/high proficiency language

[16:09] <sorear> I already have de_DE, fr_FR, and es_ES accounted for

[16:09] *** s1n left
[16:09] * moritz points to tadzik and mentions Polish

[16:10] *** s1n joined
[16:12] <sorear> for instance, I'm still looking for a nontrivial CharLingua

[16:13] <sorear> NotFound(es) says that "ch".chars should == 2

[16:15] <moritz> norwegian has the fun thing to sort AA behind Z

[16:15] <moritz> not sure if that's what CharLingua would do

[16:15] <moritz> (because AA basically means A with circle above)

[16:25] <pmichaud> (default/accepts)  I'm willing to accept a new default behavior; we arrived at this one because all of the others seemed to bring about surprising results

[16:27] <pmichaud> if  my $x   initializes $x to Mu, then $x++ doesn't dwim

[16:27] <pmichaud> if my $x  constrains $x to Any, then it's hard to assign anything that isn't Any to $x  (e.g. Junctions)

[16:29] <pmichaud> (also potentially foreign objects)

[16:29] <PerlJam> Mu should auto-transmogrify to whatever is needed.  Ordinarily this would be a coercion I think, but I'm not sure about the Junction case give the threading behavior

[16:30] <pmichaud> PerlJam: I'm pretty sure we decided that any transmogrification belongs in Any, not Mu

[16:30] <pmichaud> otherwise *everything* transmogrifies

[16:31] <pmichaud> again, I'm not committed to one answer or another-- but we arrived at the current situation for specific reasons, and not really by accident

[16:32] <PerlJam> sounds like a Schroedinger's cat situation then.  my $x; is "nothing" until you look at it.

[16:32] <sorear> Every time I've seen someone assign a junction to a variable, they've been doing something stupid like try to use Junction as Set

[16:32] <PerlJam> sorear: that doesn't mean there aren't valid reasons to do so however :)

[16:33] <pmichaud> of the two options, I think that  having my $x  default to my Any $x;  will ultimately be the lesser of the evils

[16:33] <pmichaud> and then assignment of a junction to an Any-constrained slot should simply fail

[16:33] <PerlJam> at least you wouldn't get accidental threading that way.

[16:33] <pmichaud> if you want to store a junction, you have to explicitly    my Mu $x   or my Junction $x

[16:34] *** pernatiy left
[16:34] *** satyavvd left
[16:35] <sorear> niecza: my $x = Mu;

[16:35] <p6eval> niecza v5-18-gd96efe7: OUTPUT«Unhandled exception: Nominal type check failed for scalar store; got Mu, needed Any or subtype␤  at /tmp/Zw4zWsMHLA line 1 (MAIN mainline @ 1)␤  at /home/p6eval/niecza/lib/CORE.setting line 1374 (CORE C562_ANON @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1375

[16:35] <p6eval> ..(CORE module-C…

[16:35] <PerlJam> Any still seems so much like a misnomer.  It's more like we have normal things and abnormal things and Any means any of the normal things.

[16:36] <PerlJam> I'd want to call it "Norm" then :)

[16:36] <pmichaud> Norm!  </cheers>

[16:36] <sorear> rakudo: say Parcel.^parents

[16:36] <p6eval> rakudo ca8731: OUTPUT«Iterable()Cool()Any()Mu()␤»

[16:36] <sorear> I thought we had decided that Parcel !~~ Any

[16:37] <pmichaud> noway

[16:37] <pmichaud> or, if we did, I wasn't present for that decision :)

[16:38] <jdhore> moritz, yep, i'm still up for doing the release

[16:38] <sorear> What's up with inviZible_frmae?

[16:38] <sorear> frame

[16:39] <pmichaud> frames that don't show up in backtraces, I think.

[16:39] <PerlJam> :q1

[16:39] <sorear> yeah, but why is it 'misspelled'?

[16:39] <pmichaud> I don't know... maybe because it's l33t?

[16:40] <pmichaud> :-)

[16:40] <sorear> perl6: * = say 5;

[16:40] <p6eval> pugs: OUTPUT«5␤*** Can't modify constant item: VNum Infinity␤    at /tmp/qTbTCkY6En line 1, column 1-10␤»

[16:40] <p6eval> ..rakudo ca8731: OUTPUT«5␤»

[16:40] <p6eval> ..niecza v5-18-gd96efe7: OUTPUT«5␤Unhandled exception: assigning to readonly value␤  at /tmp/fEGw1qohzm line 1 (MAIN mainline @ 3)␤  at /home/p6eval/niecza/lib/CORE.setting line 1374 (CORE C562_ANON @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1375 (CORE module-CORE @ 39)␤  at

[16:40] <p6eval> ../home/p6eval/niecza/lib/CORE.…

[16:40] <sorear> Is Rakudo in the wrong here?

[16:41] <pmichaud> I think anything can be assigned to Whatever

[16:41] *** JimmyZ left
[16:41] <pmichaud> I know that   (3, *, 5) = @foo;   is supposed to work

[16:41] <sorear> rakudo: my $wh = *; $wh = 5; say $wh;

[16:41] <p6eval> rakudo ca8731: OUTPUT«Whatever()<0x366da38>␤»

[16:41] <pmichaud> that's probably wrong.

[16:41] <PerlJam> sorear: perhaps a non-native-speaker-of-english named it ?

[16:42] <pmichaud> so, whatever term can be assigned to.... not a container with whatever in it.

[16:42] <pmichaud> and sorry, I meant

[16:42] <pmichaud>    ($a, *, $b) = @foo;   above

[16:42] <pmichaud> (obviously can't assign to constants)

[16:43] <sorear> pr'aps I'll make * return a lvalue that eats STORE

[16:46] <sorear> pmichaud: do Seq, List, and Array really need to be separate types?

[16:46] <pmichaud> List and Array certainly do

[16:46] <pmichaud> Seq and List certainly do

[16:46] <pmichaud> so I think yes

[16:46] <sorear> why?

[16:46] <pmichaud> List is a list of values

[16:46] <pmichaud> Array is a list of containers

[16:47] <pmichaud> wait

[16:47] <pmichaud> List is a list of objects.  they may be either values or containers

[16:47] <pmichaud> Array is definitely a list of containers -- they get assigned to

[16:47] <pmichaud> the difference between the two is in how they reify

[16:49] <pmichaud> Seq is a list of rvalues -- any containers in the generator get stripped

[16:49] <pmichaud> I'm much less certain about the need for a separate Seq type... but so far the distinction has been useful

[16:49] <pmichaud> also, Seq forces some flattening that List doesn't necessarily force

[16:50] <pmichaud> say Seq.^parents

[16:50] <pmichaud> rakudo: say Seq.^parents

[16:50] <p6eval> rakudo ca8731: OUTPUT«List()Iterable()Cool()Any()Mu()␤»

[16:50] <pmichaud> rakudo: say Array.^parrents

[16:50] <p6eval> rakudo ca8731: OUTPUT«Method 'parrents' not found for invocant of class 'ClassHOW'␤  in main program body at line 22:/tmp/9TjdH5v3x9␤»

[16:50] <pmichaud> rakudo: say Array.^parents

[16:50] <p6eval> rakudo ca8731: OUTPUT«List()Iterable()Cool()Any()Mu()␤»

[16:50] *** bluescreen10 left
[16:50] <pmichaud> yeah, that's about what I remembered.

[16:52] *** _jaldhar_ joined
[16:53] <sorear> rakudo: say (1,).item.WHAT

[16:53] <p6eval> rakudo ca8731: OUTPUT«Seq()␤»

[16:56] *** birdwindupbird left
[16:58] *** _jaldhar_ left
[16:58] *** sirelander joined
[17:02] *** cdarroch joined
[17:02] *** cdarroch left
[17:02] *** cdarroch joined
[17:03] *** snearch joined
[17:03] *** bluescreen10 joined
[17:03] <sjn> seen masak

[17:03] <aloha> masak was last seen in #perl6 1 days 3 hours ago saying "pivo &".

[17:09] *** mj41 left
[17:14] *** dakkar left
[17:15] *** sirelander left
[17:23] *** bluescreen10 left
[17:24] *** thou joined
[17:25] *** mberends left
[17:27] *** MayDaniel joined
[17:38] *** bluescreen10 joined
[17:40] <colomon> rakudo: say "Hello" ~~ /<upper>/

[17:41] <p6eval> rakudo ca8731: OUTPUT«H␤»

[17:47] *** mj41 joined
[17:51] *** MayDaniel left
[17:53] *** impious joined
[17:53] *** impious left
[17:58] *** pernatiy joined
[18:05] *** mberends joined
[18:11] *** sirelander joined
[18:11] *** sirelander left
[18:13] *** sirelander joined
[18:13] <sirelander> rakudo: say "Hello World";

[18:13] <p6eval> rakudo ca8731: OUTPUT«Hello World␤»

[18:14] <sirelander> rakudo: say 35+25;

[18:14] <p6eval> rakudo ca8731: OUTPUT«60␤»

[18:18] *** jlaire joined
[18:19] *** Chillance joined
[18:21] *** nymacro joined
[18:23] *** starcoder left
[18:23] *** starcoder joined
[18:24] *** awoodland joined
[18:27] *** newbee joined
[18:28] <tadzik> hello zebras

[18:28] <colomon> \o

[18:31] *** alester left
[18:34] *** p6eval left
[18:35] *** IllvilJa joined
[18:36] *** starcoder left
[18:36] *** starcoder joined
[18:36] *** p6eval joined
[18:36] *** ChanServ sets mode: +v p6eval

[18:37] <IllvilJa> One way to get some training on Perl6: solve the problems in Project Euler, but only use Perl 6 programs for any necessary calculations.

[18:37] *** p6eval left
[18:39] *** p6eval joined
[18:39] *** ChanServ sets mode: +v p6eval

[18:46] <TimToady> I think my $x should default to Any (failing on Mu or Junction assigment), and that foreign objects should probably come in under Any as sisters of Cool, where the name of the root object type for a given language is the name of the language itself

[18:47] <TimToady> Any -> Java  means Java's Object type...mebbe...

[18:47] <TimToady> or maybe Any -> Java::Object -> Java::OtherType  or some such...

[18:49] <TimToady> numerifying * to +Inf by default feels wrongish to me, but I can't put my finger on why it does yet

[18:49] <colomon> well, it's certainly wrong when doing * .. 10 (for instance)

[18:50] <TimToady> something like, failure to dwim expectedly does not justify dwimming unexpectedly

[18:50] <TimToady> and all such dwimmery should be controlled by multi dispatch anyway

[18:51] <TimToady> (even the compile-time currying is supposed to be controlled by whether there's a Whatever multi to override)

[18:51] *** risou is now known as risou_awy

[18:51] <TimToady> which is how the compiler is supposed to know not to curry 1..*

[18:51] *** risou_awy is now known as risou

[18:51] <TimToady> there may also yet be a solution in there that involves currying with a parameter that defaults to Inf

[18:53] <TimToady> but only if we can call WhateverCode with 0 args in the appropriate places to trigger the default, and that seems problematic

[18:54] <colomon> I guess my inclination is for as little additional dwimmery as possible here.

[18:54] <TimToady> $x ~~ 1..*  # somehow this would have to know to pass 0 args to WhateverCode instead of 1, and I don't see how that can work

[18:55] <TimToady> anyway, that's a side issue for whether * should numerify

[18:59] *** pernatiy left
[19:02] <colomon> It seems to me it would be somewhat confusing if +* was Inf, but * .. 10 was -Inf .. 10

[19:03] <TimToady> I think +* and -* should definitely curry

[19:03] <TimToady> rakudo: say join ' ', map -*, 1..10;

[19:03] <p6eval> rakudo ca8731: OUTPUT«-1 -2 -3 -4 -5 -6 -7 -8 -9 -10␤»

[19:03] <TimToady> like that

[19:04] <colomon> particularly if whatever currying requires you to have operator infix<..>($num, Whatever) anyway.

[19:04] <TimToady> which is how it's specced

[19:04] <TimToady> it's not supposed to be a hard-wired list of exceptions

[19:05] <TimToady> except insofar as the multis are "hard-wired"

[19:05] <colomon> and that certainly is an elegant way to handle currying on new operators, too.

[19:05] <TimToady> yes, that's the main motivation

[19:05] <colomon> user-defined ops, I mean.

[19:05] <colomon> TimToady++

[19:06] <colomon> so going back to my mis-statment, I mean, it would be confusing if * numified to Inf, but * .. 10 was -Inf .. 10

[19:06] <TimToady> a large majority of the p6 design boils down to extensibility, hopefully without loss of efficiency

[19:07] <colomon> Put another way, numifying * to Inf feels like a logical extension of the more common 0 .. * case; but that extension it just muddles the * .. 0 case.

[19:07] <TimToady> rakudo: say (1 < * < 10).WHAT

[19:07] <p6eval> rakudo ca8731: OUTPUT«WhateverCode()␤»

[19:08] <TimToady> rakudo: say (1 < * < 10)(5)

[19:08] <p6eval> rakudo ca8731: OUTPUT«Bool::True␤»

[19:08] <TimToady> rakudo: say (1 < * < 10)(1)

[19:08] <p6eval> rakudo ca8731: OUTPUT«Bool::True␤»

[19:09] <colomon> :\

[19:09] <TimToady> whoopsie

[19:09] <colomon> oh, I think that may be a known bug.  where's jnthn when you need him?

[19:09] <TimToady> apparently doing (1 < *) < 10

[19:09] <TimToady> chained ops have to be considered all at once

[19:10] *** wamba joined
[19:10] <colomon> right

[19:10] *** pernatiy joined
[19:11] <colomon> my guess is there's special code for the chained ops and special code for the currying, and so far the twain have not met.

[19:11] <TimToady> hopefully it won't be as problematic as QM and relativity...

[19:14] *** meteorjay joined
[19:15] *** snearch left
[19:27] *** alester joined
[19:27] *** birdwindupbird joined
[19:30] <thou> perl6: ([+](3, 6 ... 99)) + ([+](5, 10 ... 99))

[19:31] <p6eval> niecza v5-18-gd96efe7: OUTPUT«Unhandled exception: Series op NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 430 (CORE die @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1271 (CORE infix:<...> @ 2)␤  at /tmp/MafIcwq49A line 1 (MAIN mainline @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting

[19:31] <p6eval> ..line 1374 (CORE …

[19:31] <p6eval> ..rakudo ca8731: OUTPUT«(timeout)»

[19:31] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "99"␤    expecting operator, ":" or ")"␤    at /tmp/d4sBL3XXus line 1, column 15␤»

[19:31] <TimToady> you want a say

[19:31] <thou> perl6: ([+](3, 6 ... 99)) + ([+](5, 10 ... 99)).say

[19:31] <p6eval> rakudo ca8731: OUTPUT«(timeout)»

[19:31] <p6eval> ..niecza v5-18-gd96efe7: OUTPUT«Unhandled exception: Series op NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 430 (CORE die @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1271 (CORE infix:<...> @ 2)␤  at /tmp/xsluGBUL93 line 1 (MAIN mainline @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting

[19:31] <p6eval> ..line 1374 (CORE …

[19:31] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "99"␤    expecting operator, ":" or ")"␤    at /tmp/k3ecrs51g1 line 1, column 15␤»

[19:31] <TimToady> the second one won't terminate though

[19:32] <thou> oh

[19:32] *** wamba left
[19:32] <PerlJam> hence rakudo's timeout

[19:32] <thou> yeah, i was finding that in my local rakudo, wanted to see what others did. i see now that it's my misunderstanding of ...

[19:33] <TimToady> it used to dwim that, but we decided it was a bad idea because it's too hard to figure out whether the comparison should be > or <

[19:33] <TimToady> perl6: ([+](3, 6 ... 99)) + ([+](5, 10 ...^ * > 99)).say

[19:33] <PerlJam> thou: you probably want  5, 10 ...^ * > 99

[19:33] <p6eval> niecza v5-18-gd96efe7: OUTPUT«Unhandled exception: Series op NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 430 (CORE die @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting line 1271 (CORE infix:<...> @ 2)␤  at /tmp/nVRY0pmC6h line 1 (MAIN mainline @ 2)␤  at /home/p6eval/niecza/lib/CORE.setting

[19:33] <p6eval> ..line 1374 (CORE …

[19:33] <p6eval> ..rakudo ca8731: OUTPUT«950␤»

[19:33] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "99"␤    expecting operator, ":" or ")"␤    at /tmp/SoEodQhBs4 line 1, column 15␤»

[19:33] <thou> PerlJam: yes, thanks!

[19:34] <TimToady> thing is, not all serieseses even keep the same sign from term to term...

[19:34] *** wamba joined
[19:34] <TimToady> so the right side is now just a smartmatch

[19:36] <PerlJam> It's too bad you need those "extra" concepts to get that behavior though

[19:36] <TimToady> the whole point of smartmatching is to be a single "extra" concept that is reused over and over

[19:36] <thou> i really want ($n, 2*$n ...^ * >= $lim)

[19:37] <TimToady> if you want to include the limit, leave out the ^

[19:37] <thou> i don't want to include the limit

[19:37] <TimToady> ok

[19:37] <thou> (project euler #1)

[19:37] <PerlJam> sure, but it'd be nice if you could do  5, 10 ... upto 99  (or something)

[19:37] <thou> :-)

[19:38] <TimToady> sure, but that's spelled * > 99  :P

[19:38] <thou> :-)

[19:38] <colomon> rakudo: sub upto($n) { * > $n }; say ~(5, 10 ... upto 99)

[19:38] <PerlJam> I'm just looking for more baby talk I guess.  

[19:38] <p6eval> rakudo ca8731: OUTPUT«5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100␤»

[19:39] <TimToady> showoff :)

[19:39] <PerlJam> perl6++  :)

[19:41] <PerlJam> counting by 5s as long as you haven't passed a certain number is something I could explain adequately to my kids.   I'm not sure I could explain * > 99 to them quite as well and then relate that to the other thing.

[19:41] <PerlJam> (kids are 5, 9, 12)

[19:42] <PerlJam> I guess you could pull a Feynman on me and say that I don't understand * > 99 well enough then  :)

[19:42] *** bluescreen10 left
[19:42] <TimToady> I'd rather play the congas.

[19:46] <PerlJam> colomon: Did you see http://xkcd.com/899/ ?

[19:46] <colomon> PerlJam: yes, I think e & pi (observed) might be my new favorite number.  :)

[19:47] <colomon> rakudo: say (e + pi) / 2

[19:47] <p6eval> rakudo ca8731: OUTPUT«2.92993724102442␤»

[19:47] <PerlJam> :)

[19:49] <mberends> wait, so nobody else minds that 100 falls within the definition "up to 99" ?

[19:51] <PerlJam> mberends: colomon didn't have enough thought time to work out the magic to make it work like  5, 10 ...^ * > 99

[19:52] <PerlJam> mberends: give him a few more seconds and I'm sure he could do it.   :)

[19:52] <mberends> it seems to work as a kind of "until false" condition then

[19:54] *** bluescreen10 joined
[19:56] <colomon> mberends: the thing is, the "up to" part is exactly what the ...^ is, if you know what I mean.  

[19:57] *** Ali_h left
[19:57] <TimToady> rakudo: sub upto($lim) { -> $n { fail if $n > $lim } }; .say for 5, 10 ... upto 99

[19:57] <p6eval> rakudo ca8731:

[19:57] <p6eval> ..OUTPUT«(timeout)0␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤100␤105␤110␤115␤120␤125␤130␤135␤140␤145␤150␤155␤160␤165␤170␤175␤180␤185␤190␤195␤200␤205␤210␤215␤220␤225␤230␤235␤240␤245␤250␤255␤260␤265␤270␤275␤280␤285␤290␤295␤300␤305␤310␤315␤320␤325␤330␤335␤340␤345␤350␤355␤360␤365␤370␤

[19:58] <TimToady> hmm

[19:58] <tadzik> seen jnthn 

[19:58] <aloha> jnthn was last seen in #perl6 1 days 7 hours ago saying "masak is so impure... :P".

[19:58] <TimToady> rakudo: sub upto($lim) { -> $n { Nil if $n > $lim } }; .say for 5, 10 ... upto 99

[19:58] <p6eval> rakudo ca8731:

[19:58] <p6eval> ..OUTPUT«(timeout)0␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤100␤105␤110␤115␤120␤125␤130␤135␤140␤145␤150␤155␤160␤165␤170␤175␤180␤185␤190␤195␤200␤205␤210␤215␤220␤225␤230␤235␤240␤245␤250␤255␤260␤265␤270␤275␤280␤285␤290␤295␤300␤305␤310␤315␤320␤325␤330␤335␤340␤345␤350␤355␤360␤365␤370␤

[19:58] <tadzik> phenny: please tell jnthn can we close http://rt.perl.org/rt3/Ticket/Display.html?id=65396 ?

[19:58] <TimToady> rakudo: sub upto($lim) { -> $n { die if $n > $lim } }; .say for 5, 10 ... upto 99

[19:58] <p6eval> rakudo ca8731: OUTPUT«5␤10␤15␤20␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤Died␤␤  in <anon> at line 22:/tmp/0DB0p9HKnl␤  in 'Block::ACCEPTS' at line 6354:CORE.setting␤  in <anon> at line 899:CORE.setting␤  in main program body at line 1␤»

[19:59] <mberends> colomon: aye, I wonder if the implementation would be more dwimmy if it popped off the last value in the series when the terminating condition is met.

[19:59] <tadzik> phenny: tell jnthn can we close http://rt.perl.org/rt3/Ticket/Display.html?id=65396 ?

[19:59] <phenny> tadzik: I'll pass that on when jnthn is around.

[19:59] <tadzik> phenny-- # deaf to kindness

[20:01] <TimToady> rakudo: sub upto($lim) { -> $n { last if $n > $lim } }; .say for 5, 10 ... upto 99

[20:01] <p6eval> rakudo ca8731: OUTPUT«5␤10␤15␤20␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤»

[20:01] <colomon> rakudp

[20:01] <TimToady> that's what I was looking for

[20:01] <colomon> TimToady++

[20:01] <colomon> I forgot that was supposed to work

[20:01] * TimToady had to look in the spec...

[20:01] <colomon> and didn't know that it actually would work in Rakudo, for that matter.  is that tadzik++  ?

[20:02] <PerlJam> Doesn't that require you to know a little much about how ... is implemented?

[20:02] <tadzik> colomon: sorry, could you refactor your question?

[20:02] <TimToady> it suffices to know that it is considered a loop

[20:03] <colomon> tadzik: was it you who did all the additional work on the sequence operator, or is my brain muddled again

[20:03] <PerlJam> so, it's specced that ... must be some sort of loop?

[20:03] <colomon> PerlJam: the spec says you can call last like TimToady did

[20:03] *** Ali_h joined
[20:03] <tadzik> colomon: nah, I don't think so

[20:04] <TimToady> rakudo: say ~map { last when 100; $_ }, 5, 10 ... 200

[20:04] <p6eval> rakudo ca8731: OUTPUT«No candidates found to invoke for method 'map' on object of type 'Array'; available candidates have signatures:␤:(Mu : &block;; *%_)␤␤  in 'map' at line 1887:CORE.setting␤  in main program body at line 22:/tmp/Qls5KsRhWF␤»

[20:04] <tadzik> I was as suprised with the spec change as everyone else :)

[20:04] <tadzik> I'm not sure how to treat http://rt.perl.org/rt3/Ticket/Display.html?id=62244 NCI has had (is that correct English?) so many adventures recently anyway

[20:05] <TimToady> rakudo: say ~map { last when 100; $_ }, (5, 10 ... 200)

[20:05] <p6eval> rakudo ca8731: OUTPUT«5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95␤»

[20:05] <TimToady> that too

[20:05] * sjohnson writes those numbers down

[20:05] <TimToady> rakudo: say ~map { next when 100; $_ }, (5, 10 ... 200)

[20:06] <p6eval> rakudo ca8731: OUTPUT«5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200␤»

[20:06] <PerlJam> sjohnson: 8 6 7 5 3 0 9  ;)

[20:06] <TimToady> :D

[20:06] <colomon> oh, patrickas++ # thank you blame

[20:06] <TimToady> what area code?

[20:08] * TimToady goes to drill more holes in his house

[20:08] <tadzik> I think http://rt.perl.org/rt3/Ticket/Display.html?id=63408 can be closed

[20:09] *** mikemol left
[20:09] *** mikemol joined
[20:09] <tadzik> rakudo: say "foo" ~~ /<[f] #[comment] + [o]>/

[20:09] <p6eval> rakudo ca8731: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 22, near ""␤»

[20:10] *** risou is now known as risou_awy

[20:11] <tadzik> rakudo: class class {}; say class.new.perl

[20:11] <p6eval> rakudo ca8731: OUTPUT«===SORRY!===␤Malformed package declaration at line 22, near ".new.perl"␤»

[20:12] *** mikemol left
[20:12] *** mikemol joined
[20:13] <tadzik> rakudo: regex foo { foo }; say foo('foo').perl

[20:13] <p6eval> rakudo ca8731: OUTPUT«Useless declaration of has-scoped regex in a module; add our or my to install it in the lexpad or namespace␤Could not find sub &foo␤  in main program body at line 22:/tmp/6aXxQJ0J1h␤»

[20:13] <tadzik> rakudo: my regex foo { foo }; say foo('foo').perl

[20:13] <p6eval> rakudo ca8731: OUTPUT«Method '!cursor_start' not found for invocant of class 'Str'␤  in 'foo' at line 10:/tmp/aTCnAK3fiO␤  in main program body at line 22:/tmp/aTCnAK3fiO␤»

[20:13] *** PacoLinux left
[20:14] <tadzik> rakudo: caffeine(eval('sub caffeine($a){say $a}'));

[20:14] <p6eval> rakudo ca8731: OUTPUT«Could not find sub &caffeine␤  in main program body at line 22:/tmp/BX9vC2E6Z5␤»

[20:16] <tadzik> enough of ticketwork today

[20:17] *** kaare_ left
[20:24] *** birdwindupbird left
[20:31] *** [particle]1 joined
[20:32] *** mj41 left
[20:32] *** [particle] left
[20:33] *** [particle]1 is now known as [particle]

[20:33] *** risou_awy is now known as risou

[20:36] *** newbee left
[20:36] *** wknight8111 left
[20:42] <cognominal> is it possible to do call stack introspection from user code today?

[20:44] <cognominal> I see that  one can get a stack trace when dying...

[20:45] *** ymasory left
[20:48] <mberends> cognominal: it is only when you are about to die that you can see your whole life flash before your eyes. So you have to die.

[20:49] <mberends> chartreuse!

[20:50] <mberends> You have to hand it to Ruby. They make a nice Port. :)

[20:50] <cognominal> gnole++

[20:50] <cognominal> karma gnole?

[20:50] <aloha> gnole? has karma of 0.

[20:50] *** mkramer left
[20:50] <cognominal> karma gnole

[20:50] <aloha> gnole has karma of 1.

[20:50] <mberends> better :)

[20:51] *** bluescreen10 left
[20:54] *** spq left
[20:54] *** PacoLinux joined
[20:59] <mberends> cognominal: I speculate that although the stack trace is only currently emitted when dying, it should be free of side effects, and therefore might work in a well crafted pir call without terminating the running program. Proof is left as an exercise for the reader.

[21:03] <moritz> cognominal: callframe()

[21:03] <moritz> rakudo: say callframe().line

[21:03] <p6eval> rakudo ca8731: OUTPUT«22␤»

[21:04] <moritz> rakudo: f();␤ sub f { say callframe().line; say callframe(1).line }

[21:04] <p6eval> rakudo ca8731: OUTPUT«23␤22␤»

[21:12] *** Mowah left
[21:22] <cognominal> moritz, thx I will try it

[21:22] *** bluescreen10 joined
[21:26] *** sirelander left
[21:32] *** mtk left
[21:38] *** mtk joined
[21:41] *** wamba left
[21:44] *** kjeldahl left
[21:58] <pmichaud> cognominal: I think CALLER and or callframe() work in Rakudo to some extend

[21:58] <pmichaud> *extent

[21:59] <pmichaud> http://gist.github.com/975473   # zavolaj almost works

[22:23] *** [particle]1 joined
[22:23] <jasonmay> ah yes, I'm working on porting Term::VT102 to XS, I should extract the C and write a p6 library with it using zavolaj or something

[22:24] *** [particle] left
[22:26] *** bluescreen10 left
[22:32] <Tene> wasn't someone working on an llvm-based runtime thunk builder?

[22:37] *** icwiener left
[22:40] *** risou_ joined
[22:45] <colomon> http://tirania.org/blog/archive/2011/May-16.html  # sounds like, in the foreseeable future, we might be able to run niecza on our phones....

[22:47] <colomon> errr... or can we do that already?

[22:47] <colomon> http://mono-android.net/

[22:50] <pmichaud> do we have any mysqlclient/zavolaj-knowledgeable people here?

[22:52] <thou> perl6: my %h = 1..10; %h.say; %h{3} :delete; %h.say;

[22:52] <p6eval> rakudo ca8731: OUTPUT«===SORRY!===␤Confused at line 22, near "%h{3} :del"␤»

[22:52] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ":delete"␤    expecting operator␤    at /tmp/yhU4VDVZBs line 1, column 30␤»

[22:52] <p6eval> ..niecza v5-18-gd96efe7: OUTPUT«Unhandled exception: Attempted to access slot key of type object for Num␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE Hash.LISTSTORE @ 0)␤  at /tmp/Ms97R5Do8U line 1 (MAIN mainline @ 3)␤  at /home/p6eval/niecza/lib/CORE.setting line 1374 (CORE C562_ANON @

[22:52] <p6eval> ..2)␤  at /home/p6…

[22:56] <thou> can anyone point me to how to remove an element from a hash?

[22:57] *** estrabd left
[22:58] *** estrabd joined
[22:59] <thou> actually, i'm trying to remove a single element from a Set. my $s = Set.new(3, 5 ...^ *>100); my @primes = $s.min; $s.delete\   #`[ That doesn't work ]  ($s.min);

[23:04] *** benabik joined
[23:05] *** benabik left
[23:08] *** PacoLinux left
[23:09] *** PacoLinux joined
[23:11] *** whiteknight joined
[23:11] *** dur-randir left
[23:13] *** [particle]1 left
[23:14] *** PacoLinux left
[23:18] *** PacoLinux joined
[23:19] *** [particle] joined
[23:33] *** ajr joined
[23:34] *** ajr left
[23:35] *** donri left
[23:49] *** Chillance left
[23:56] *** risou_ left
