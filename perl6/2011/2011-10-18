[00:00] *** smash left
[00:10] *** ranguard left
[00:15] *** benabik joined
[00:23] *** replore joined
[00:25] <dalek> niecza: 0f30c0b | (Solomon Foster)++ | t/spectest.data:

[00:25] <dalek> niecza: Turned on S16-filehandles/io_in_while_loops.t.

[00:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0f30c0b8d8

[00:32] *** bacek_at_work left
[00:33] *** aloha left
[00:43] *** Woodi left
[00:43] *** lestrrat left
[00:43] *** Woodi joined
[00:44] *** aloha joined
[00:44] *** tokuhiro_ left
[00:44] *** pnu left
[00:44] *** lestrrat joined
[00:45] *** japhb_ left
[00:45] *** jferrero left
[00:51] *** imarcusthis left
[00:51] *** Vlavv_ left
[00:51] *** Exodist left
[00:51] *** Tene left
[00:51] *** yath left
[00:51] *** _ilbot left
[00:51] *** lumi_ left
[00:51] *** sjn left
[00:51] *** tomaw left
[00:51] *** cxreg left
[00:51] *** miso2217 left
[00:51] *** daemon left
[00:51] *** BooK left
[00:51] *** bloonix left
[00:51] *** broquaint left
[00:51] *** felipe left
[00:51] *** mdxi_ left
[00:51] *** Bucciarati left
[00:51] *** yahooooo left
[00:51] *** literal left
[00:51] *** cognominal left
[00:51] *** flussence left
[00:51] *** buubot_backup left
[00:51] *** risou_awy left
[00:51] *** jevin left
[00:51] *** tokuhirom3 left
[00:51] *** Gothmog_ left
[00:51] *** betterworld left
[00:51] *** cosimo left
[00:51] *** revdiablo left
[00:51] *** krakan_ left
[00:51] *** eiro left
[00:51] *** arthur-_ left
[00:51] *** soh_cah_toa left
[00:51] *** huf left
[00:51] *** pyrimidine left
[00:51] *** tewk left
[00:51] *** BinGOs left
[00:51] *** ascent__ left
[00:51] *** jfried left
[00:51] *** ruz left
[00:51] *** TimToady left
[00:51] *** sbp left
[00:51] *** nsh left
[00:53] <dalek> niecza: c851cf8 | (Solomon Foster)++ | t/spectest.data:

[00:53] <dalek> niecza: Add open.t and filetest.t.

[00:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c851cf80ba

[00:55] <diakopter> ooo filetest

[00:55] *** cognominal joined
[00:55] *** pnu_ joined
[00:55] *** eiro joined
[00:55] *** arthur-_ joined
[00:55] *** soh_cah_toa joined
[00:55] *** imarcusthis joined
[00:55] *** flussence joined
[00:55] *** tokuhirom3 joined
[00:55] *** Vlavv_ joined
[00:55] *** buubot_backup joined
[00:55] *** risou_awy joined
[00:55] *** Exodist joined
[00:55] *** Tene joined
[00:55] *** jevin joined
[00:55] *** huf joined
[00:55] *** pyrimidine joined
[00:55] *** AAABKJS joined
[00:55] *** _ilbot joined
[00:55] *** yath joined
[00:55] *** tewk joined
[00:55] *** Gothmog_ joined
[00:55] *** betterworld joined
[00:55] *** cosimo joined
[00:55] *** revdiablo joined
[00:55] *** BinGOs joined
[00:55] *** literal joined
[00:55] *** yahooooo joined
[00:55] *** Bucciarati joined
[00:55] *** mdxi_ joined
[00:55] *** broquaint joined
[00:55] *** felipe joined
[00:55] *** bloonix joined
[00:55] *** BooK joined
[00:55] *** daemon joined
[00:55] *** miso2217 joined
[00:55] *** cxreg joined
[00:55] *** tomaw joined
[00:55] *** sjn joined
[00:55] *** krakan_ joined
[00:55] *** ascent__ joined
[00:55] *** nsh joined
[00:55] *** sbp joined
[00:55] *** TimToady joined
[00:55] *** ruz joined
[00:55] *** jfried joined
[00:55] * diakopter had a bit of a hand in that (though sorear had to redo it)

[00:55] <colomon> diakopter++

[00:55] <diakopter> heh sorear++

[01:14] *** skangas joined
[01:16] *** wolfman2000 joined
[01:20] *** ranguard joined
[01:23] *** skangas left
[01:25] *** thou left
[01:26] *** skangas joined
[01:27] *** miso2217_ joined
[01:29] *** miso2217 left
[01:36] *** whiteknight left
[01:49] <dalek> sprixel: ba9ce21 | diakopter++ | src/ (6 files):

[01:49] <dalek> sprixel: refactor variable storage/retrieval to use arrays instead of hashtables.

[01:49] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/ba9ce21582

[01:54] <dalek> sprixel: b9a09fd | diakopter++ | src/ (2 files):

[01:54] <dalek> sprixel: eliminate unnecessary cast

[01:54] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/b9a09fde95

[01:56] <diakopter> nom: 1 while (my $a++) < 100;

[01:56] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Redeclaration of symbol $a at line 1, near "++) < 100;"␤»

[01:57] <diakopter> !

[01:59] <TimToady> those parens are unneeded

[01:59] <TimToady> the ++ already blew it out of the my declaration

[01:59] <diakopter> nom: 1 while my $a++ < 100;

[01:59] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Redeclaration of symbol $a at line 1, near "++ < 100;"␤»

[02:00] <TimToady> doesn't fix the bug, of course :)

[02:00] <diakopter> niecza: 1 while my $a++ < 100;

[02:00] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/0cYfZvC7zz line 1:␤------> [32m1 while my [33m⏏[31m$a++ < 100;[0m␤␤»

[02:00] <TimToady> Nil

[02:00] <TimToady> (already tried it :)

[02:01] <TimToady> should be (1,1,1,1,1,1...1) of course

[02:01] <diakopter> niecza: 1 while my $a++ < 100; say $a

[02:01] <p6eval> niecza v10-58-gc851cf8: OUTPUT«101␤»

[02:01] <diakopter> er... shouldn't that be 100

[02:01] <TimToady> niecza: say (1 while my $a++ < 100)

[02:01] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/fyOTpqVjPB line 1:␤------> [32msay (1 while my [33m⏏[31m$a++ < 100)[0m␤␤Nil␤»

[02:02] <TimToady> it's a postincrement

[02:02] <benabik> diakopter: No, it increments after returning the value.

[02:02] <diakopter> right, and the last time through it's 99

[02:02] <diakopter> oh, no

[02:02] <diakopter> OFFBYONE

[02:06] *** uasi joined
[02:06] * diakopter tries to think of something non-snippy to reply to benabik

[02:06] <benabik> sorry?

[02:07] <TimToady> yes, "sorry?" would be non-snippy :)

[02:08] <diakopter> sorry, I shouldn't feel affronted that someone thought I didn't know what a postincrement was.

[02:09] <benabik> Just because you know what it is doesn't mean you're thinking about it right then.  :-D

[02:11] <TimToady> you'll note that I pointed out the same thing, and I'm sure you know what a postincrement is too :)

[02:11] <TimToady> but I have many times mistaken a postincrement for a preincrement, so I'm sure other people can too

[02:12] <diakopter> niecza: 1 while ++my $a < 100; say $a

[02:12] <benabik> Generally when I make that mistake I'll go "of course it's a postincrement" but not realize _what that means_.

[02:12] <p6eval> niecza v10-58-gc851cf8: OUTPUT«100␤»

[02:14] <diakopter> std: 1 while ++my $a++ < 100; say $a

[02:14] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤"++" and "++" are not associative at /tmp/1xoZO_vo4O line 1:␤------> [32m1 while ++my $a++[33m⏏[31m < 100; say $a[0m␤"++" and "++" are not associative at /tmp/1xoZO_vo4O line 1:␤------> [32m1 while ++my $a++[33m⏏[31m < 100; say $…

[02:14] <diakopter> eh

[02:14] *** ranguard left
[02:14] *** ranguard joined
[02:26] <soh_cah_toa> are rt tickets rendered as plain text only? i just opened a ticket that contained some code samples but the lack of indentation and brackets make it a little less readable

[02:52] *** jferrero joined
[02:56] *** agentzh joined
[03:01] *** plobsing_ left
[03:02] *** plobsing joined
[03:05] <diakopter> agentzh: haven't seen you in a while; hi

[03:09] <agentzh> diakopter: halo :)

[03:09] <agentzh> diakopter: been busy with nginx related C & Lua hacking :P

[03:16] *** xinming left
[03:17] *** yuryss joined
[03:17] *** yuryss left
[03:18] <sorear> diakopter: I constantly forget the simplest things too

[03:19] <diakopter> argh. I didn't forget about the post-increment. I confused myself with the while

[03:34] *** envi_ joined
[03:46] <TimToady> well, that's a simple thing too :P

[03:52] * sorear notes that /serialize is about 3x slower to compile large files than /master

[03:55] <TimToady> maybe it's a simple thing :)

[04:01] *** thou joined
[04:10] *** sivoais left
[04:10] *** sivoais joined
[04:15] *** daniel-s joined
[04:15] *** lateau__ left
[04:18] *** satyavvd joined
[04:41] *** shinobicl_ joined
[04:47] <dalek> niecza/serialize: 7ae298f | sorear++ | / (5 files):

[04:47] <dalek> niecza/serialize: Make CC, LIHint serializable

[04:47] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/7ae298f4e9

[04:50] <moritz> nqp: my %h := nqp::atpos(pir::getinterp, pir::const::IGLOBALS_CONFIG_HASH); say(%h<osname>);

[04:50] <p6eval> nqp: OUTPUT«linux␤»

[04:59] *** GlitchMr joined
[05:01] *** shinobicl_ left
[05:01] *** cognominal left
[05:10] *** cognominal joined
[05:12] *** orafu left
[05:12] *** orafu joined
[05:13] *** SHODAN joined
[05:16] *** pyrimidine left
[05:17] *** SHODAN left
[05:17] *** pyrimidine joined
[05:19] *** SHODAN joined
[05:21] <dalek> niecza/serialize: 19ada5b | sorear++ | lib/ (2 files):

[05:21] <dalek> niecza/serialize: Implement variable-length coding for serialization

[05:21] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/19ada5bdce

[05:22] *** cyfi left
[05:29] *** soh_cah_toa left
[05:30] *** shinobicl_ joined
[05:30] <masak> morning, #perl6

[05:36] <moritz> good morning masak 

[05:37] <sorear> good morning masak y moritz.

[05:38] <masak> sorear: "'najt" was no more than English pronunciation expressed in sane-ish spelling. sorry to lead you on a goose chase ;)

[05:41] * masak commutes

[05:41] *** dual left
[05:41] <sorear> "j" should not be confused with sanity, between French Jean, Spanish abajo, German ja, and English jar I count four entirely different phonemes

[05:42] <sorear> seems you used the German phoneme there.  Does Swedish use the same one?

[05:49] *** cyfi joined
[05:50] <SHODAN> pretty much, yes (sort of like the y in yes)

[06:01] *** kaleem joined
[06:05] *** kaare_ joined
[06:06] *** daniel-s left
[06:10] <mberends> morning m* s*

[06:10] *** wtw joined
[06:10] <sorear> o/ mberends 

[06:14] <mberends> I plan to improve the functionality of niecza/examples/gtk-tetris.pl a little and then do a talk about its workings in London at http://conferences.yapceurope.org/lpw2011. It will be completely off-topic of the Industrial Strength Perl theme.

[06:17] <sorear> hehee

[06:20] *** mberends left
[06:21] <Woodi> mberends: how you think - what should go to multi-GUI (abstract) base package ? something like DBI for GUIs. probably DBI wasn't limited by smallest common denominator...

[06:27] *** mberends joined
[06:30] <dalek> niecza/serialize: 054561b | sorear++ | lib/ (4 files):

[06:30] <dalek> niecza/serialize: Thaw code for all LAD, Variable, ViviHook subclasses

[06:30] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/054561b145

[06:30] <sorear> Woodi: +1, but next time say it while mberends++ is actually in the room.

[06:31] <sorear> mberends: you may want to check teh clogs...

[06:31] * mberends is about 3.5 days behind on clogs

[06:32] <sorear> /serialize can now thaw the true setting, but it fails while running the constant pi = ... INIT

[06:34] *** koban joined
[06:35] <sorear> "You can use any aspect of Perl such as Camelia, Rakudo, Raptor, etc."  what.

[06:37] *** sayu joined
[06:38] <mberends> sorear: that is the attitude of mst trickling through

[06:38] <sorear> mst is cluefuller than that

[06:44] *** im2ee joined
[06:55] <mberends> 20 minute talk proposal submitted :)

[06:56] <dalek> niecza/serialize: 46c5be5 | sorear++ | lib/Kernel.cs:

[06:56] <dalek> niecza/serialize: Serialize exception-handling tables too (oops)

[06:56] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/46c5be51fe

[06:56] <sorear> \o/ mberends

[06:56] <mberends> wow, the other talks are mainly 90 minutes or longer

[06:57] <moritz> mberends: not completely off-topic. Perl 6 compilers approaching industrial strength... :-)

[06:57] <mberends> :-) and -Ofun for sure

[07:01] <masak> sorear: correct, German phoneme. and I didn't aim to imply any objective/global spelling -- it's just that most things are saner than English orthography.

[07:01] <masak> sorear: where did you read that "any aspect of Perl" quote?

[07:01] <sorear> masak: mberends's lpw link

[07:03] <masak> guessed as much, followed it.

[07:03] <masak> ah, I see it now.

[07:03] <dalek> niecza/serialize: deaa100 | sorear++ | lib/Kernel.cs:

[07:03] <dalek> niecza/serialize: When we run the mainline code, GLOBAL is MAIN's GLOBAL at first

[07:03] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/deaa1007b0

[07:03] <masak> yes, mst is pushing the distinction Camelia/Raptor for 5/6.

[07:04] <sorear> \o/ "Hello World"

[07:04] <sorear> masak: but Rakudo does not belong in that list.

[07:04] <masak> the fact that Rakudo got thrown in there probably means there's a Telephone Game going on.

[07:04] <sorear> Rakudo \in Camelia

[07:04] <masak> nodnod

[07:04] <sorear> or is that \subset

[07:04] <masak> it's \in

[07:04] <masak> oh wait, I see what you mean :)

[07:04] <masak> it's really a category error, I think :P

[07:05] <masak> Rakudo R Camelia, where 'R' is defined as "aims to implement"

[07:06] <sorear> calling it a night.  next week aims to get multiple-unit programs working, including the all-important special case of "-L CORE"

[07:07] <masak> shall I email the organizers about the "aspects" phrasing?

[07:07] <sorear> single-unit case now appears to be mostly-working

[07:07] * sorear -> sleep

[07:09] <masak> sorear++ # steady progress with /serialize

[07:10] *** GlitchMr left
[07:13] <masak> I don't know who to contact about the "Rakudo, Camelia aspects" phrasing, so leaving it be for now.

[07:14] <masak> it's worth remembering that the sentiment is friendly. they're saying people from our camp are welcome ;)

[07:17] *** shinobicl_ left
[07:21] *** im2ee left
[07:21] *** am0c joined
[07:26] <tadzik> dzień dobry

[07:27] <masak> 'bry

[07:30] *** thou left
[07:32] *** koban left
[07:37] <masak> moritz: re your "rearranging furniture" post to parrot-dev: whoa.

[07:37] <masak> it was... honest.

[07:38] <masak> specifically, "You're not fixing the deep issues with parrot (slow calling conventions, no JIT compiler, very limited NCI, ...), you're rearranging furniture."

[07:40] *** Chat2454 joined
[07:41] *** Chat2454 left
[07:43] *** sayu left
[07:43] <masak> let's hope the Parrot people decide to take that as constructive criticism... :)

[07:43] <masak> cotto: ping

[07:46] * diakopter looks for said thread

[07:48] <masak> http://groups.google.com/group/parrot-dev/browse_thread/thread/41771ff893798fa5

[07:54] <diakopter> has any rakudo person tried rakudo out on the green_threads branch of parrot/parrot at github?  I'm curious whether it noticeably affects performance.

[07:56] * diakopter finds the "Parrot is a foundering project on top of a wonderful vision." thread from last month

[07:56] *** mj41 joined
[07:57] <diakopter> "We're going to be gutting PIR"

[07:57] <masak> I was thinking of that one too.

[07:58] *** risou_awy is now known as risou

[08:03] <diakopter> hunh.

[08:06] <masak> that thread, I mean.

[08:06] <diakopter> yeah

[08:06] <moritz> masak: I usually refrain from such frank answers, but ... not this time. The balance of that thread just felt so wrong.

[08:07] <diakopter> I really wonder what "We're going to be gutting PIR" means

[08:07] <snarkyboojum> "I don't want to hear the straw man" seems to be a popular phrase in both threads too :)

[08:08] <diakopter> if I were a rakudo developer, "We're going to be gutting PIR" would make me shiver in my boots

[08:08] <masak> moritz: it was refreshing to read. I sure woke up a bit and realized "hey, yeah, this isn't important!"

[08:08] <moritz> why? We've been working on reducing the dependence on PIR

[08:08] <diakopter> having recently read through lots of jnthn's code in 6model and MetaModel

[08:09] <moritz> and that's mostly in C and nqp, no?

[08:09] <diakopter> nqp that calls pir:: routines.  would those interfaces stay the same?

[08:09] <snarkyboojum> gutting PIR would affect Rakudo via NQP though right?

[08:10] <tadzik> mostly

[08:10] <moritz> diakopter: well, pir:: is just a way to access opcodes. If PIR goes away, we'll need to access the opcodes without going through PIR explicitly, but we can still use the pir:: form in our source code

[08:10] <moritz> diakopter: and just have the compiler translate them to something else

[08:11] <diakopter> oh

[08:11] <moritz> diakopter: yes, it's going to be a lot of work, but we rely much less on PIR than we used to

[08:11] <diakopter> that makes me hypothetically shiver less

[08:12] <moritz> and I'm quite sure we'll be able to convince the parrot folks to *first* provide alternatives, and wait with the gutting until we've had time to switch

[08:13] <masak> otherwise we'd simply have to stay with an older Parrot.

[08:14] <masak> to no-ones joy.

[08:14] <masak> *no-one's

[08:20] * diakopter continues plowing through all the variants of 6model trying to make heads or tails.

[08:21] <masak> moritz: maybe the effects of cotto++'s firebrand speech have worn off, and rearranging furniture starts to seem like a good thing to do again.

[08:27] *** dakkar joined
[08:34] <diakopter> oooo I'm starting to grok P6Opaque, barely

[08:35] <moritz> diakopter: are you planning to steal bits of it for sprixel?

[08:35] * masak idly wonders if there are many Frank answers on the Sinatra mailing list

[08:36] <diakopter> moritz: yep, I'd like to steal AMAP

[08:36] <diakopter> of 6model, that is

[08:36] <moritz> diakopter: you should really join up with mberends; he's working on a C runtime for Perl 6 too (though with slightly different goals, iiuc)

[08:37] <diakopter> yes; his will depend on a C compiler at runtime

[08:37] <moritz> it will?

[08:37] <diakopter> yes; he told me today

[08:37] <moritz> for eval()?

[08:37] <diakopter> yesterday for you :)

[08:37] <diakopter> for compiling all code; he's planning to emit C for everything

[08:38] <diakopter> very similar to how his vill project did it

[08:39] <diakopter> I'm taking the exact opposite tack; not wanting to optimize hardly anything from the get-go... going with an inefficient interpreter design on purpose.

[08:42] <diakopter> moritz: mberends++ has been teaching me C the last month or so; you can consider this 4th or 5th reuse of the sprixel name my grand attempt to learn lots more C.

[08:42] <moritz> diakopter: sounds nice

[08:42] <diakopter> still though, I read jnthn's source to 6model in nqp, and I just get lost in all the parrot-specific stuff

[08:43] <diakopter> so many defines and macros that I'm sure jnthn has memorized but I don't even know where to begin to look up

[08:44] <mberends> I like the idea of having different irons in the fire

[08:45] <diakopter> the overall gist of what's going on at a high level is documented in jnthn's code, but I'm having trouble picturing how I would implement the same thing in my interpreter design... which means I don't have a good understanding of the details of 6model.

[08:46] *** pnu_ left
[08:47] <masak> I like the idea of more people getting a good understanding of the details of 6model.

[08:47] *** pnu joined
[08:48] <moritz> wow, I never realized how much stuff is inside an s-table

[08:48] <moritz> and at least sixmodelobject.h is really well commented

[08:50] *** wk joined
[08:51] <diakopter> jnthn tells me an s-table is simply a pairing of a HOW and a REPR (but those obviously contains lots each)

[08:53] <moritz> well, an s-table also hold the method cache, a method finder and various flags

[08:53] <diakopter> oh yeah; :( forgot

[08:54] <diakopter> in my eyes and out the other side after 1-2 days

[08:54] <mls_> morning perl6!

[08:54] <masak> morn', mls_!

[08:55] <mberends> btw, working on 6model/C gives me new hope for vill, except that indeed 6model/C needs a C compiler at runtime, whilst vill would use llvm for runtime code generation.

[08:56] <masak> hihi -- https://github.com/jnthn/6model/commit/8f6a5f60535be83d7e1f617336bf5a9c73daa26d

[08:56] <cognominal> vill?

[08:56] <moritz> masak: :-)

[08:56] <mberends> cognominal: a stalled project to connect viv to llvm

[08:57] <cognominal> I am dizzy with all these v6 related project

[08:57] * moritz too

[08:58] <moritz> but the important ones get mentioned often enough that you keep their names at least :-)

[08:58] <masak> consider it a living example of Zips's law :)

[08:59] <masak> argh, *Zipf's

[08:59] <masak> http://en.wikipedia.org/wiki/Zipf%27s_law

[09:02] *** packetknife joined
[09:05] *** Mowah_ joined
[09:08] <flussence> perl6: my $a = 5; my $text = "abcdefg"; say ($text ~~ /. ** {$a}/).perl

[09:08] <p6eval> rakudo 4e4390: OUTPUT«Match.new(orig => "abcdefg", from => 0, to => 7, ast => Mu, list => ().list, hash => EnumMap.new())␤»

[09:08] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«#<match from(0) to(5) text(abcde) pos([].list) named({}.hash)>␤»

[09:08] <p6eval> ..pugs c943eeb: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[09:09] <flussence> oh, nombug. Thought I was going insane for a minute...

[09:09] * masak submits rakudobug

[09:09] <flussence> b: my $a = 5; my $text = "abcdefg"; say ($text ~~ /. ** {$a}/).perl

[09:09] <moritz> uhm

[09:09] <p6eval> b 1b7dd1: OUTPUT«Match.new(␤ from => 0,␤ orig => "abcdefg",␤ to   => 7,␤)␤»

[09:10] <moritz> what's the bug exactly?

[09:10] <flussence> or maybe it's a nieczabug and I *am* insane

[09:10] <masak> moritz: that it matches 7 chars in nom and not 5.

[09:10] <moritz> {$a} is just executed for its side effects

[09:10] <masak> yes...?

[09:10] <moritz> so it's just . ** ''

[09:10] <masak> what? no.

[09:11] <masak> the return value of {$a} is $a is 5.

[09:11] <masak> that's what's used.

[09:11] <moritz> but doesn't it need to return a range?

[09:11] <masak> nope.

[09:11] <moritz> ok, then it's a known bug

[09:11] <masak> :)

[09:11] <masak> but is it tikkited?

[09:11] <moritz> (that rakudo doesn't implement the closure form of the range quantifier)

[09:11] <moritz> masak: I think so

[09:11] <masak> dang!

[09:12] <masak> someone already submitted all the good ones! :P

[09:12] <masak> curse you, unknown bug predecessor!

[09:13] <moritz> https://rt.perl.org/rt3/Ticket/Display.html?id=73172

[09:13] * moritz feels cursed

[09:13] <moritz> rakudo: * + * * *

[09:13] <p6eval> rakudo 4e4390:  ( no output )

[09:15] <moritz> nom: my $c; my $name; BEGIN { $c = { say "OH HAI $name" } }; $name = "masak"; $c()

[09:15] <p6eval> nom 4e4390: OUTPUT«Use of uninitialized value in string context␤OH HAI ␤»

[09:19] <masak> nom: my $c; my $name; BEGIN { $c = { say $name.WHICH } }; say $name.WHICH; $c()

[09:19] <p6eval> nom 4e4390: OUTPUT«6798962962383454502␤6798962962383454502␤»

[09:20] <masak> hm, no, wasn't that easy.

[09:20] <masak> nom: my $c; my $foo = 1; BEGIN { $c = { $foo = 42 } }; say $foo; $c(); say $foo

[09:20] <p6eval> nom 4e4390: OUTPUT«1␤1␤»

[09:21] <masak> but the $foo in the closure in the BEGIN block clearly points somewhere else than the $foo in the mainline.

[09:22] <moritz> nom: my $c; my $foo = 1; BEGIN $c = { $foo = 42 }; say $foo; $c(); say $foo

[09:22] <p6eval> nom 4e4390: OUTPUT«1␤42␤»

[09:27] <masak> interesting post: http://neugierig.org/software/blog/2011/10/why-not-haskell.html

[09:28] <masak> moritz: I find I can't account for the difference in behaviour above. any ideas?

[09:29] <moritz> masak: does "some weird bug" count?

[09:32] <masak> oh, I just assumed there was some goodish reason.

[09:32] <masak> ah well, it's bugtracked.

[09:34] * moritz wonders if he should re-read the infamous "when is a closure not a closure" section

[09:35] <masak> it does mention BEGIN in some slightly unsettling way, doesn't it?

[09:36] <moritz> I think so

[09:36] <masak> I remember reading it thinking "well, that makes BEGIN and END rather useless, doesn't it?"

[09:36] <moritz> nom: use Test; is BEGIN { 'foo' }, 'foo'

[09:36] *** xinming joined
[09:36] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'is' will never work with argument types (str) (line 1)␤    Expected any of:␤    :(Mu $got, Mu $expected, Any $desc)␤    :(Mu $got, Mu $expected)␤»

[09:37] <moritz> nom: use Test; is (BEGIN  'foo' ), 'foo'

[09:37] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'Undef'␤»

[09:38] <masak> huh.

[09:38] <masak> nom: say (BEGIN { 'foo' }) eq 'foo'

[09:38] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'Undef'␤»

[09:38] <masak> nom: say (BEGIN 'foo') eq 'foo'

[09:38] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'Undef'␤»

[09:39] <moritz> nom: say (BEGIN 'foo')

[09:39] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'Undef'␤»

[09:39] <moritz> nom: BEGIN 'foo'

[09:39] <masak> nom: say (BEGIN)

[09:39] <p6eval> nom 4e4390:  ( no output )

[09:39] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&BEGIN' called (line 1)␤»

[09:39] * masak hasn't gotten used to CHECK FAILED in Rakudo yet ;)

[09:41] <moritz> nom: our $x; BEGIN { $x = 3 }

[09:41] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤Cannot assign to a non-container␤»

[09:41] * moritz writes a few tests

[09:47] <moritz> masak: oh, read that section again, the fourth paragraph sounds relevant to macros

[09:47] <moritz> you might notice that I've made it to the 4th paragraph without giving up :-)

[09:47] <masak> \o/

[09:48] * masak makes an attempt, too

[09:48] <mls_> ("returns" is a PAST method)

[09:51] <mls_> (could also be POST, actually)

[09:51] <moritz> Some closures produce Block objects at compile time that cannot be cloned, because they're not attached to any runtime code that can actually clone them. BEGIN, CHECK, INIT, and END blocks fall into this category. Therefore you can't reliably refer to run-time variables from these closures even if they appear to be in the scope.

[09:52] * moritz wonders if he should reject masak's bug report

[09:52] <masak> dang.

[09:52] <masak> I knew it says that. I just don't viscerally accept it. :/

[09:53] <masak> so sometimes I "forget" it.

[09:54] * moritz still hasn't understood it at a gut level either

[09:54] <cognominal> masak/moritz  what document are you talking about?

[09:54] <masak> S04, last section.

[09:54] <moritz> cognominal: S04, last section

[09:54] <masak> spooky :)

[09:55] <cognominal> in cauda venenum

[09:56] <masak> it's like, Perl 6 proudly proclaims that the boundary between compile time and run time has been erased. and then, in a place where it would matter most, suddenly one can't count on that fact any more...

[09:56] <moritz> let's try to walk through this, and sees if it makes any sense

[09:56] <masak> cognominal: "poison in the tail"?

[09:57] <cognominal> http://fr.wiktionary.org/wiki/in_cauda_venenum

[09:57] <moritz> normally if I do   my $shared; my $c; do { $c = { $shared } }

[09:57] <moritz> the closure is "cloned" on entering the 'do {' block

[09:58] <moritz> and with "clone", we mean that a snapshot of the current outer lexical scope is attached to the Code object

[09:59] <moritz> so if we do s/do/BEGIN/, the outer scope's lexpad isn't available

[10:00] <moritz> just a static lexpad under construction

[10:01] <moritz> so, what happens then? no cloning? or does the "cloning" stop to clone, and attaches the static lexpad?

[10:02] <cognominal> what is a static lexpad?

[10:03] <moritz> the compiler needs to keep track of all the lexicals that are in scope (but not of their values)

[10:03] <moritz> it does that in the static lexpad

[10:04] *** daniel-s joined
[10:04] <cognominal> so that's the compiling time counterpart of a lexpad?

[10:04] <moritz> yes

[10:06] *** lateau__ joined
[10:06] <moritz> masak: does that make any sense so far?

[10:07] * masak reads

[10:08] <mls_> (actually the static lexpad is used at runtime to initialize the lexpad)

[10:08] *** uasi left
[10:08] <masak> makes sense.

[10:09] <masak> yes, static lexpads are a sort of early form of lexpads, mostly used during compilation.

[10:10] <masak> moritz: your hypothesis so far matches the one I had, but doesn't explain the different results from BEGIN { $c = {...} } and BEGIN $c = {...}

[10:10] <masak> or maybe it does, I'm not sure :)

[10:11] <moritz> masak: well, having those extra { } results in triggering a clone operation that doesn't work

[10:11] <moritz> masak: though I don't understand why it works without it in the case without the extra {}

[10:11] <moritz> masak: and why whatever mechanism is used to make it work doesn't work in the block case

[10:12] <masak> right.

[10:12] <masak> that's the weird bug, I guess.

[10:19] *** daxim joined
[10:24] <flussence> just before I go updating nom on my netbook - did the fix for `now` get merged?

[10:24] <moritz> no

[10:24] *** kfo_ joined
[10:25] <moritz> the algorithm sometimes converged on *really* wrong values, and I didn't have tuits/energy to fix it

[10:25] <moritz> and nothing happened on the other proposed fixes

[10:26] <flussence> ah well, I'm only doing text-munging stuff at the moment anyway. I'll live without it :)

[10:28] *** kfo left
[10:30] *** skangas left
[10:30] *** skangas joined
[10:33] *** dakkar left
[10:37] *** dakkar joined
[10:42] *** benabik left
[10:48] *** mj41 left
[11:03] *** mj41 joined
[11:07] *** tewk left
[11:08] *** tewk joined
[11:10] *** smash joined
[11:12] <smash> hello everyone

[11:12] *** smash left
[11:14] *** smash joined
[11:14] <sjn> on behalf of everyone, hello smash :)

[11:14] <smash> sjn: thank you :)

[11:18] *** replore left
[11:20] *** Mowah_ left
[11:25] *** am0c left
[11:26] *** xinming left
[11:27] *** xinming joined
[11:32] *** Guest9002 joined
[11:32] <moritz> nom: say Range ~~ Positional

[11:32] <p6eval> nom 4e4390: OUTPUT«Bool::True␤»

[11:34] <masak> nom: say Range ~~ List

[11:34] <p6eval> nom 4e4390: OUTPUT«Bool::False␤»

[11:34] <masak> nom: say Range ~~ KitchenSink

[11:34] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&KitchenSink' called (line 1)␤»

[11:34] *** kaare_ left
[11:34] <masak> std: say Range ~~ KitchenSink

[11:34] <p6eval> std 580b69a: OUTPUT«ok 00:01 120m␤»

[11:35] <masak> std: BathroomSink

[11:35] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'BathroomSink' used at line 1␤Check failed␤FAILED 00:01 118m␤»

[11:35] <moritz> nom: sub a(@a) { say @a.WHAT }; a 1..5

[11:35] <p6eval> nom 4e4390: OUTPUT«Range()␤»

[11:35] <moritz> that is kinda funny, but not really wrong afaict

[11:35] *** Guest9002 left
[11:36] *** leprevost joined
[11:36] <masak> we should probably take STD's cue and go with "Undeclared name" for identifiers starting with a capital.

[11:38] *** Guest9002 joined
[11:38] *** Guest9002 left
[11:39] *** Patterner left
[11:42] *** Psyche^ joined
[11:43] *** Psyche^ is now known as Patterner

[11:47] <moritz> nom: Foo

[11:47] <p6eval> nom 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Foo' called (line 1)␤»

[11:47] <mberends> masak: you lost me there. Should identifiers starting with a capital be treated differently from identifiers starting with a lowercase letter?

[11:47] <masak> mberends: only in error messages.

[11:47] <moritz> mberends: only in error messages

[11:48] * moritz too slow

[11:48] <masak> hey, stop that! :P

[11:48] <mberends> mberends: only in error messages.

[11:48] <moritz> mberends: you're not half as creepy as masak :-)

[11:48] <masak> mberends: it's a heuristic to make the compiler appear less clueless.

[11:49] <masak> oh, I'm the creepy one? :)

[11:49] * moritz already wrote two "in Perl 6 this is not a problem" answers on perlmonks today

[11:49] <masak> that interpretation requires an interesting view on causality...

[11:50] <moritz> and now you're going to bring that causality strawman...

[11:50] <masak> moritz: I read a TimToady talk from 2005 where he says that the then Perl 6 adherents had gotten tired of writing "fixed in Perl 6" perlmonks replies ;)

[11:50] <masak> moritz: *lol*

[11:51] <moritz> masak: well, it's just too tempting to write such replies when you can provide running runing code :-)

[11:51] <masak> moritz: extra points for giving that retort before I even mention causality ;)

[11:51] <masak> moritz: running code FTW.

[11:51] *** benabik joined
[11:53] <mberends> "using no-longer-vaporware Perl 6, it's no-longer-problem."

[11:54] <masak> only some relatively uninteresting parts of Perl 6 are vaporware.

[11:54] <moritz> like, concurrency and IPC?

[11:54] <moritz> and NCI?

[11:54] * moritz wouldn't discount them as "relatively uninteresting"

[11:56] <mberends> perl as army knife and duct tape needs all the interoperability it can get

[11:56] <moritz> aye

[11:56] <moritz> which is why I did a Buf sprint some weeks ago

[11:57] <mberends> that reminds me to try to reactivate the favicon code in my Perl 6 webserver

[11:58] <moritz> mberends: if you encounter any missing Buf operations in nom, please let me know

[11:58] <mberends> moritz: will do, thanks :)

[11:59] <masak> moritz++ # Buf sprint

[11:59] <masak> of course, I initially read that as "Buf sprintf"...

[11:59] *** uasi joined
[11:59] <mberends> moritz: will you be at home for a possible visit on Saturday evening?

[12:00] <moritz> mberends: yes, but the house is full :/ (Signe's birthday)

[12:00] <mberends> \o/

[12:00] <masak> and by the way, I agree that IPC and NCI and concurrency and parallelism shouldn't be discounted. on the other hand, I'm glad that we're now at the point where we can start paying attention to such things.

[12:01] <masak> getting events and concurrency and parallelism in place will be a big thing.

[12:01] * mberends will find something birthday-nommable to bring

[12:01] <masak> mberends: it's your birthday?

[12:02] <masak> perl6: say "three cheers for mberends:"; say "hooray!" xx 3

[12:02] <p6eval> pugs c943eeb: OUTPUT«three cheers for mberends:␤hooray!hooray!hooray!␤»

[12:02] <p6eval> ..rakudo 4e4390, niecza v10-58-gc851cf8: OUTPUT«three cheers for mberends:␤hooray! hooray! hooray!␤»

[12:02] * moritz thinks that masak missed a part of the discussion

[12:02] <masak> oh wait. I fail at backlogging :)

[12:02] <masak> perl6: say "three cheers for Signe:"; say "hooray!" xx 3

[12:03] <p6eval> pugs c943eeb: OUTPUT«three cheers for Signe:␤hooray!hooray!hooray!␤»

[12:03] <p6eval> ..rakudo 4e4390, niecza v10-58-gc851cf8: OUTPUT«three cheers for Signe:␤hooray! hooray! hooray!␤»

[12:03] <moritz> :-)

[12:03] <mberends> hooray for  masak++'s hoorays :)

[12:03] <masak> Pugs hoorays a bit more tersely than the other implementations...

[12:04] <moritz> well, it predates several hundred spec changes :-)

[12:05] <moritz> (though only about one relevant for this case)

[12:06] *** odoacre left
[12:06] *** donri joined
[12:08] *** Maddingue left
[12:08] <masak> I hope to be able to fix such things soonish.

[12:09] <masak> what was the conclusion of the Great Pugs Build Hubub, by the way?

[12:10] <masak> is there now a set of unambiguous instructions for building Pugs on a modern normalish Debian install?

[12:10] <moritz> on a modern normalish Debian installation, ghc 7.0.3 + haskell-platform should[tm] work

[12:11] <moritz> ingy also posted an url to a gist which contained instructions (including patches) to get the relevant cabal stuff running on ghc 7.2.1

[12:11] * mberends will try building Pugs again Real Soon™

[12:11] <moritz> pugs: say 'now from git'

[12:11] <p6eval> pugs c943eeb: OUTPUT«now from git␤»

[12:12] <donri> people trying to revive pugs?

[12:13] * mberends whistles, apropos of nothing

[12:13] * masak whistles in tune with mberends 

[12:13] <masak> I'm not sure [Coke] is here to whistle, but I'm sure he would...

[12:14] * moritz whistels the tune of "scotland the brave"

[12:14] <donri> revivePugs :: [Coke] -> Maybe whistle

[12:14] <moritz> that's one of the most contagious ear catchers I know

[12:16] <masak> phenny: de en "orenwurm"?

[12:16] <phenny> masak: "orenwurm" (de to en, translate.google.com)

[12:16] <masak> phenny: de en "ohrenwurm"?

[12:16] <phenny> masak: "ear worm" (de to en, translate.google.com)

[12:16] <moritz> "ohrwurm"

[12:16] <masak> phenny: de en "ohrwurm"?

[12:16] <phenny> masak: "earwig" (de to en, translate.google.com)

[12:16] <masak> huh!

[12:17] <donri> :D

[12:17] <moritz> oh, dict.leo.org suggests "haunting melody"

[12:17] * moritz likes that one

[12:19] <masak> I've come to think of it as "jukebox sabotage", at least when it's done by someone else.

[12:19] *** mdxi_ is now known as mdxi

[12:19] <moritz> curious, in school we learned that you can say both "ear catcher" and "eye catcher" in English

[12:20] <moritz> it seems I need to retroactively question more stuff I've been taught

[12:20] <masak> indeed.

[12:21] <masak> one of my favorite such stories is about a Japanese school where some Western didacticians went to observe. they spent a full hour in a class without figuring out what the subject was. at the end they had to ask the teacher, who looked flustered and said "English!"

[12:22] <moritz> ouch.

[12:23] <masak> yeah. kinda shows the echo chamber effect of language learning/teaching.

[12:25] <moritz> iirc the teacher in question was married to a native English speaker

[12:25] <moritz> which makes it even odder

[12:25] <moritz> erm, "more odd" probably?

[12:26] <masak> both are fine, but...

[12:26] <donri> odditarian

[12:26] <masak> ...suddenly I don't dare trust my instincts either! :P

[12:26] <moritz> http://en.wikipedia.org/wiki/Odder

[12:27] <moritz> we've learned that for words with only one syllable, you can append the -er

[12:28] <benabik> The Odder Otter.

[12:28] <donri> the utterly odd otter

[12:29] <masak> moritz: that sounds wronger.

[12:30] <moritz> (... with the exception of some irregular adjectives, like good/better, bad/worse)

[12:31] <snarkyboojum> true - for those you should append -era e.g. goodera

[12:31] <benabik> More gooder ain't proper English?

[12:31] <moritz> benabik: no, it's either "more good" or "gooder" :-)

[12:31] <snarkyboojum> it's "more goodera" down here

[12:31] <mux> more bestest

[12:31] <mdxi> "odder" is fine, but has a bit of a colloquial feel. if you wanted to sound academic, i'd go with something like "makes it all the more surprising" :)

[12:31] <snarkyboojum> heh, or "much more bestest"

[12:32] <mdxi> english is just a ramshackle collection of grammatical fragments at this point, anyway :)

[12:32] <moritz> http://www.englisch-hilfen.de/grammar/adjektive_steig.htm # that's one example that says one syllable => append -er

[12:34] <masak> mdxi: I'll have a go. "makes it not conform to conventional expectations" ;)

[12:34] *** satyavvd left
[12:34] <snarkyboojum> "much more goodera" is often followed by "but then I've never been larned proper"

[12:34] <snarkyboojum> without the punctuation

[12:37] <masak> rakudo: sub without-punctuation($s) { $s.comb(/ \w | \s/).join }; say without-punctuation "but then I've never been larned proper"

[12:37] <p6eval> rakudo 4e4390: OUTPUT«but then Ive never been larned proper␤»

[12:37] <flussence> .oO( Perl 5 emulates bits of English grammar, PHP emulates the size of its vocabulary... )

[12:38] *** TimTitiesToady joined
[12:38] <TimTitiesToady> ladies

[12:39] <donri> in case it interests anyone, pugs fails to cabal install for me on fedora 16 with: * Missing (or bad) header file: perl5/p5embed.h

[12:40] <moritz> donri: you need libperl-devel or perl-devel or whatever that package is called on your platform

[12:40] <moritz> and also the ncurses devel files

[12:40] <donri> have it, but p5embed is bundled with hsperl5, a hackage

[12:40] <donri> i'll try ncurses

[12:40] <moritz> ncurses won't help you when it carps on perl5/p5embed.h

[12:40] <donri> already installed too

[12:42] <masak> donri++ # Pugs build explorations

[12:42] <donri> ^_^

[12:42] <donri> let's try a clean ~/.ghc ~/.cabal environment

[12:43] *** replore joined
[12:44] *** TimTitiesToady left
[12:45] <dalek> roast: dff3691 | moritz++ | S04-phasers/begin.t:

[12:45] <dalek> roast: test file for BEGIN phasers

[12:45] <dalek> roast: review: https://github.com/perl6/roast/commit/dff3691126

[12:48] <donri> nope http://hpaste.org/52793

[12:49] <donri> oh wait it's this Embed.pm business isn't it

[12:49] <masak> a nice read. moritz++

[12:49] <masak> donri: what Embed.pm business

[12:49] <donri> Can't locate ExtUtils/Embed.pm in @INC 

[12:50] <moritz> $ corelist ExtUtils::Embed

[12:50] <moritz> ExtUtils::Embed was first released with perl 5.00307

[12:50] <donri> perl-ExtUtils-Embed.noarch : Utilities for embedding Perl in C/C++ applications

[12:50] <moritz> if your perl installation misses core modules, I declare it broken.

[12:51] <moritz> if it's older than 5.3.something, I declare it broken too

[12:51] <donri> that may well be the case, since fedora 16 is beta

[12:51] <donri> but it might also be that they split up the perl install

[12:51] <moritz> might be

[12:51] <donri> 5.14.1

[12:51] <moritz> maybe there's a perl-modules package or so that draws in all the core modules

[12:51] <moritz> if so, I'd recommend to install it

[12:52] <masak> http://www.merriam-webster.com/dictionary/do-gooder is interesting, not because of the article about the word "do-gooder", but because it's followed by comments by 8 commenters about how "gooder" (standalone) is not a word, and how hearing it used as such in commercials annoys them.

[12:52] *** packetknife left
[12:53] <masak> I find word rage slightly fascinating as a phenomenon.

[12:54] <moritz> well, I used to label new mainstream grammar patterns as "wrong"

[12:54] <donri> $ pugs -V

[12:54] <donri> This is Perl6 User's Golfing System, version 6.2.13.20111008, October 8, 2011 built for darwin-2level

[12:54] <donri> \o/

[12:54] <moritz> it took me quite some time to grok that language is a living thing, and if enough people speak it, it becomes "right" by definition, even if I don't like it

[12:54] <masak> donri: \o/

[12:55] <donri> sourcedir: /Users/audreyt/work/pugs  # artifact? :P

[12:55] <masak> moritz: then you've graduated from prescriptivist to descriptivist.

[12:55] <donri> i mean i just compiled it myself, but there's all sorts of references to audrey's install

[12:56] <masak> donri: that sounds ungood, yes.

[12:56] <donri> maybe accidentally bundling a build config?

[12:56] <benabik> Some languages have an official definition.  French has the Académie française, for example.

[12:56] <moritz> donri: quite possible

[12:56] <benabik> There is no such institution for English, however.

[12:57] <benabik> (And I imagine many French-speakers ignore the Académie, but have no proof of that.)

[12:57] <moritz> German has the Duden, which is then as a very authorotative dictionary and grammar collection

[12:57] <moritz> s/then/seen/

[12:57] <masak> benabik: still, even for the French (who really try IIUC), it's a bit of a fiction to attempt to control language that way.

[12:57] <benabik> masak: Very agreed.

[12:57] <moritz> benabik: it seems to work surpringly well on the account of keeping anglicisms out of the language

[12:57] <masak> most likely no-one "approved" the new words for "satellite" or "Internet" in any given language.

[12:58] <masak> moritz: only because the French care in the first place ;)

[12:58] <masak> it's a cultural thing.

[12:58] <benabik> There are a couple English dictionaries (OED, M-W) widely viewed as authoritative.  But the people who write them generally simply grab words that are commonly used and add them to the list.

[12:59] <benabik> Every year or so there's a pile of news articles about such-and-such word being added to English, when they really mean "these words have been used long enough that they're getting added to a Dictionary".

[12:59] <masak> you mean the big headlines about "MILLIONTH WORD ADDED" are basically bogus? :P

[12:59] <donri> what's some standard p6 lib that should be "use"-able?

[13:00] <moritz> donri: Test

[13:00] <masak> Test.pm?

[13:00] <masak> dang! :)

[13:00] <moritz> masak: stop doing that! :-)

[13:00] <masak> yeah, you were first this time...

[13:02] <donri> huh, that worked

[13:02] <moritz> pugs: use Test; plan 1; ok 1, 'foo';

[13:02] <p6eval> pugs c943eeb: OUTPUT«pugs: *** Unsafe function 'use' called under safe mode␤    at /tmp/JCz8WT7ZFG line 1, column 1␤»

[13:02] <donri> well my @*INC is messed up so i wanted to "prove" that it's an issue

[13:02] <donri> but then it isn't ... :D

[13:03] * masak wonders whether donating money at this point will cause another HPMoR episode to materialize... :/

[13:03] <moritz> donri: mkdir -p /Users/audreyt/work/pugs; touch /Users/audreyt/work/pugs/Test.pm; pugs -e 'use Test;'

[13:04] <moritz> masak: I know that sounds creepy, but I asked myself the same thing (though I wouldn't donate)

[13:04] *** Holy_Cow joined
[13:04] <donri> no it's actually all /usr/local but i have a non-root install

[13:04] <moritz> probably just ENOTUITS on EY's part

[13:05] *** Holy_Cow left
[13:07] <masak> moritz: I've gotten vibes that he has trouble tying arcs together somehow. though maybe he's past that stage.

[13:07] <donri> can't "use" anything in the pugs/perl6/lib directory anyway

[13:12] *** GlitchMr joined
[13:26] *** [Coke] left
[13:27] *** pnu left
[13:32] *** localhost left
[13:33] <dalek> Pugs.hs: b927740 | au++ | Pugs/src/Pugs/Prim/Numeric.hs:

[13:33] <dalek> Pugs.hs: * Fixed (8 ** 8 ** 8) by courtesy of ingy++

[13:33] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/b927740203

[13:33] <dalek> Pugs.hs: 039bfa7 | (Ingy dot Net)++ | Pugs/src/Pugs/Prim/Numeric.hs:

[13:33] <dalek> Pugs.hs: Merge branch 'master' of https://github.com/audreyt/Pugs.hs

[13:33] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/039bfa75c3

[13:33] *** localhost joined
[13:34] <masak> \o/

[13:35] <moritz> pugs: say 2 ** 3 ** 4

[13:35] <p6eval> pugs c943eeb: OUTPUT«2417851639229258349412352␤»

[13:35] <moritz> niecza: say 2 ** 3 ** 4

[13:35] <p6eval> niecza v10-58-gc851cf8: OUTPUT«2417851639229258349412352␤»

[13:36] <ingy> I should add instructions for getting 7.2.1 working

[13:38] *** pnu joined
[13:39] <masak> please do.

[13:41] *** kaleem left
[13:49] <GlitchMr> perl6: print pi * 7 - pi - pi - pi - pi - pi - pi - pi

[13:49] <p6eval> pugs c943eeb, rakudo 4e4390: OUTPUT«0»

[13:49] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«2.66453525910038E-15»

[13:51] <moritz> niezca: say pi.WHAT

[13:51] <moritz> niecza: say pi.WHAT

[13:51] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Num()␤»

[13:52] *** SHODAN left
[13:53] <GlitchMr> perl6: print 0.3333333333333333333333333333333333-0.333333333333333333333

[13:53] <p6eval> niecza v10-58-gc851cf8: OUTPUT«5.55111512312578E-17»

[13:53] <p6eval> ..rakudo 4e4390: OUTPUT«===SORRY!===␤bigint_get_long: number too big␤»

[13:53] <p6eval> ..pugs c943eeb: OUTPUT«0.0000000000000000000003333333333333»

[13:53] <GlitchMr> I love abusing floats! :)

[13:53] <GlitchMr> number too big... what\

[13:54] <moritz> no floats involved here

[13:55] <masak> GlitchMr: you keep assuming that 0.33333 et as are floats in Perl 6. they're not.

[13:55] <benabik> GlitchMr: You're abusing rats, good sir.  :-D

[13:55] <masak> et al*

[13:55] <benabik> …  Which just sounds wierd.

[13:55] <GlitchMr> 5.55111512312578E-17

[13:56] <GlitchMr> ... there is no way it could be this...

[13:56] <benabik> I guess niecza is actually using floats.  :-/

[13:56] <moritz> for pi, yes

[13:57] <moritz> but nto for 0.333...

[13:57] <moritz> *not

[13:57] <benabik> Numbers like that usually mean "0 as far as the FPU can tell"

[13:57] <moritz> you can easily find out

[13:57] <benabik> niecza: say 0.3333333333333333333333333333333333.WHAT

[13:57] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Num()␤»

[13:57] <benabik> Not Rat().  :-(

[13:57] * moritz loses

[13:57] <moritz> niezca: say 0.33333.WHAT

[13:58] <moritz> niecza: say 0.33333.WHAT

[13:58] <moritz> gree

[13:58] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Rat()␤»

[13:58] <moritz> gree

[13:58] <moritz> I'm going to install an alias one day

[13:58] <GlitchMr> ...

[13:58] <moritz> it just implements overflow-to-Num as specced

[13:58] <moritz> read S02 for the gory details

[13:58] <benabik> It's overflowing int and going to Num.  Bleh, but acceptable.

[13:59] <colomon> huh?

[13:59] <colomon> oh, because it's bigint over bigint

[13:59] <colomon> that's spec, actually

[13:59] <benabik> niecza: say 0.333333.numerator.WHAT

[13:59] *** pnu left
[13:59] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Int()␤»

[13:59] <colomon> not just "acceptable", but what p6 is supposed to do

[13:59] <donri> ah, the sdist includes src/Pugs/Config.hs which maybe it should not

[13:59] <moritz> it's Rat[Int, uint64] or some such

[14:00] <dalek> Pugs.hs: 3d86197 | (Ingy dot Net)++ | HACKING:

[14:00] <dalek> Pugs.hs: Add GHC 7.2.1 instructions to HACKING

[14:00] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/3d861971a7

[14:00] <moritz> check S02

[14:00] <benabik> niecza: say 0.333333.denominator.WHAT

[14:00] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Int()␤»

[14:00] <colomon> moritz: but the denominator is much bigger than an uint64 in 0.3333333333333333333333333333333333

[14:00] <colomon> (errr... I think?  how big can a uint64 get?)

[14:01] <moritz> colomon: that's why it returns a Num

[14:01] <moritz> colomon: and not a Rat

[14:01] <benabik> nom: say 2**64-1

[14:01] <p6eval> nom 4e4390: OUTPUT«9223372036854775807␤»

[14:01] <flussence> perl6: say 2**63

[14:01] <p6eval> pugs c943eeb, niecza v10-58-gc851cf8: OUTPUT«9223372036854775808␤»

[14:01] <p6eval> ..rakudo 4e4390: OUTPUT«-9223372036854775808␤»

[14:01] <donri> https://github.com/audreyt/Pugs.hs/blob/master/Pugs/src/Pugs/Config.hs even in git

[14:01] <dalek> Pugs.hs: c5840ed | (Ingy dot Net)++ | HACKING:

[14:01] <dalek> Pugs.hs: Note sources for the new instructions.

[14:01] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/c5840ed8b2

[14:02] <colomon> right, so by spec, 0.3333333333333333333333333333333333 should be a Num

[14:02] <flussence> rakudo: say 2**33

[14:02] <p6eval> rakudo 4e4390: OUTPUT«8589934592␤»

[14:02] <flussence> rakudo: say 2**63 # wtf?

[14:02] <masak> nom: say 2 ** 64

[14:02] <p6eval> rakudo 4e4390: OUTPUT«-9223372036854775808␤»

[14:02] <p6eval> nom 4e4390: OUTPUT«-9223372036854775808␤»

[14:02] <GlitchMr> -9223372036854775808

[14:02] <masak> flussence: yeah, was just thinking the same.

[14:02] <GlitchMr> ...

[14:02] <colomon> :\

[14:03] <masak> ENOBIGINT

[14:03] <colomon> perl6: say 2**62

[14:03] <p6eval> pugs c943eeb, rakudo 4e4390, niecza v10-58-gc851cf8: OUTPUT«4611686018427387904␤»

[14:03] <GlitchMr> > 2**64

[14:03] <GlitchMr> 1.84467440737096e+19

[14:03] <GlitchMr> ...

[14:03] <colomon> perl6: say 2**63

[14:03] <p6eval> pugs c943eeb, niecza v10-58-gc851cf8: OUTPUT«9223372036854775808␤»

[14:03] <p6eval> ..rakudo 4e4390: OUTPUT«-9223372036854775808␤»

[14:03] <colomon> perl6: say 2**64

[14:03] <p6eval> pugs c943eeb, niecza v10-58-gc851cf8: OUTPUT«18446744073709551616␤»

[14:03] <p6eval> ..rakudo 4e4390: OUTPUT«-9223372036854775808␤»

[14:03] <colomon> perl6: say 2**65

[14:03] <p6eval> pugs c943eeb, niecza v10-58-gc851cf8: OUTPUT«36893488147419103232␤»

[14:03] <p6eval> ..rakudo 4e4390: OUTPUT«-9223372036854775808␤»

[14:04] *** pnu joined
[14:04] <colomon> I guess as long as it's broken, it can be broken that way.

[14:04] <masak> that's the spirit!

[14:05] <ingy> masak: instructions in HACKING. good luck.

[14:05] <GlitchMr> perl6: print <2/6>+1

[14:05] <p6eval> rakudo 4e4390: OUTPUT«1.33333333333333»

[14:05] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«␤Unhandled Exception: System.FormatException: Unknown char: /␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) […

[14:05] <p6eval> ..pugs c943eeb: OUTPUT«3»

[14:05] <GlitchMr> rakudo print (<2/6>+1).WHAT

[14:06] <GlitchMr> rakudo: print (<2/6>+1).WHAT

[14:06] <masak> ingy: thank you sir. will try tonight after $dayjob.

[14:06] <p6eval> rakudo 4e4390: OUTPUT«Use of uninitialized value in string context␤»

[14:06] <GlitchMr> oh right

[14:06] <donri> ingy, should Pugs/Config.hs be there?

[14:07] *** daniel-s left
[14:09] <GlitchMr> perl6: print 'NY' if 1<3

[14:09] <p6eval> niecza v10-58-gc851cf8: OUTPUT«␤Unhandled Exception: System.IndexOutOfRangeException: Array index is out of range.␤  at Lexer.Run (System.String from, Int32 pos) [0x00000] in <filename unknown>:0 ␤  at Lexer.RunDispatch (Niecza.Frame fromf, Niecza.P6any cursor) [0x00000] in <filename un…

[14:09] <p6eval> ..pugs b927740, rakudo 4e4390: OUTPUT«NY»

[14:09] *** arnsholt joined
[14:10] <GlitchMr> ...

[14:10] <ingy> donri: I believe so

[14:10] *** daniel-s joined
[14:10] <colomon> so, I'm renewing my call for a postifx:<F> which makes interprets a numeric token as a FatRat.  Otherwise there's no reasonable way to get 0.33333333333333333333333333333 exactly as a FatRat.

[14:10] <colomon> Guess I should do a blog post on it.  :)

[14:10] <moritz> FatRat.new(1, 3)

[14:10] <moritz> not very hard :-)

[14:10] <moritz> or (1/3) # doesn't need to be Fat

[14:11] <colomon> not exact

[14:11] <benabik> "0.3333333333333333333333333333333333".FatRat?

[14:11] <moritz> colomon: point taken

[14:11] <colomon> benabik: nope

[14:11] <ingy> donri: well not sure, we just forked from au

[14:11] <donri> ingy, but it's an autogenerated file specifically for audrey's system (as it were in 2010 even)

[14:11] <benabik> colomon: Yeah, I didn't like it either.

[14:11] <ingy> nod

[14:11] <GlitchMr> More like FatRat.new(3333333333333333333333333333333333, 10000000000000000000000000000000000)

[14:11] <colomon> it's not a matter of like, I'm pretty sure it won't work

[14:11] <ingy> just looked

[14:11] <colomon> Well, we could make it work

[14:12] <GlitchMr> If it's done this way, it works...

[14:12] <GlitchMr> At least on Niecza...

[14:12] <GlitchMr> perl6: print FatRat.new(3333333333333333333333333333333333, 10000000000000000000000000000000000) - 0.33333333333333333333333

[14:12] <p6eval> niecza v10-58-gc851cf8: OUTPUT«0»

[14:12] <p6eval> ..rakudo 4e4390: OUTPUT«===SORRY!===␤bigint_get_long: number too big␤»

[14:12] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&FatRat"␤    at /tmp/AxTqM3YlNP line 1, column 7 - line 2, column 1␤»

[14:12] <colomon> GlitchMr: right, but see "reasonable" in my prior statement

[14:12] <GlitchMr> ... I see...

[14:13] <benabik> Rakudo's bigints need to get bigger.

[14:13] <moritz> well, I do think we should have a way to write high precision literals

[14:13] *** SHODAN joined
[14:13] <moritz> not sure if a postfix is the solution

[14:13] <ingy> donri: I can look into adding it into the Makefile

[14:13] <ingy> or you can

[14:13] <colomon> at a bare minimum, we should have a FatRat constructor which takes a string.  (which is another way of looking at benabik's suggestion.)

[14:13] <ingy> doesn't seem to be breaking things over here :\

[14:13] <colomon> afk # gotta rake  :(

[14:14] <moritz> though TimToady++ will probably propose to not lose precision as the default, and create a FatRat from the start if the conversion to Rat would lose precision

[14:14] <moritz> ... it can be detected at compile time, after all

[14:14] <GlitchMr> perl6: print (1..26 Z 'a'..'z').perl

[14:14] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(1, "a", 2, "b", 3, "c", 4, "d", 5, "e", 6, "f", 7, "g", 8, "h", 9, "i", 10, "j", 11, "k", 12, "l", 13, "m", 14, "n", 15, "o", 16, "p", 17, "q", 18, "r", 19, "s", 20, "t", 21, "u", 22, "v", 23, "w", 24, "x", 25, "y", 26, "z").list»

[14:14] <p6eval> ..rakudo 4e4390: OUTPUT«((1, "a"), (2, "b"), (3, "c"), (4, "d"), (5, "e"), (6, "f"), (7, "g"), (8, "h"), (9, "i"), (10, "j"), (11, "k"), (12, "l"), (13, "m"), (14, "n"), (15, "o"), (16, "p"), (17, "q"), (18, "r"), (19, "s"), (20, "t"), (21, "u"), (22, "v"), (23, "w"), (24, "x"), (25, "y")…

[14:14] <p6eval> ..pugs b927740: OUTPUT«((1, "a"), (2, "b"), (3, "c"), (4, "d"), (5, "e"), (6, "f"), (7, "g"), (8, "h"), (9, "i"), (10, "j"), (11, "k"), (12, "l"), (13, "m"), (14, "n"), (15, "o"), (16, "p"), (17, "q"), (18, "r"), (19, "s"), (20, "t"), (21, "u"), (22, "v"), (23, "w"), (24, "x"), (25, "y"),…

[14:14] <donri> ingy, well it builds but @*INC ends up focused on /usr/local where my install is nto

[14:14] <GlitchMr> ... ok...

[14:14] <donri> not

[14:14] <moritz> GlitchMr: please chose examples that produce less output when experimenting with p6eval.

[14:14] <GlitchMr> ok

[14:14] <GlitchMr> sorry

[14:15] <GlitchMr> perl6: print (1..4 Z 'a'..'d').perl

[14:15] <p6eval> pugs b927740: OUTPUT«((1, "a"), (2, "b"), (3, "c"), (4, "d"))»

[14:15] <p6eval> ..rakudo 4e4390: OUTPUT«((1, "a"), (2, "b"), (3, "c"), (4e0, "d")).list»

[14:15] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«(1, "a", 2, "b", 3, "c", 4, "d").list»

[14:15] <GlitchMr> 4e0?

[14:15] <GlitchMr> I know it's 4, but why "e0". It's useless in this case.

[14:15] <benabik> nom: 4e0.WHAT

[14:15] <p6eval> nom 4e4390:  ( no output )

[14:15] <moritz> looks like a bug

[14:15] <benabik> nom: 4e0.WHAT.say

[14:15] <p6eval> nom 4e4390: OUTPUT«Num()␤»

[14:15] <benabik> It's not useless, it changes the type.

[14:16] <benabik> Still a bug.

[14:16] <GlitchMr> Makes sense...

[14:16] <GlitchMr> I was wondering why rakudo and pugs produces different output...

[14:16] <GlitchMr> And last position looked interesting...

[14:17] <benabik> pugs will often be slightly different than everything else.

[14:17] *** wtw left
[14:17] *** wolfman2000 left
[14:19] <ingy> donri: I can't loacte util/PugsConfig.pm

[14:19] <donri> me either :(

[14:20] <donri> the repo is supposedly an import from hackage, maybe it's in the original (svn?) repo

[14:20] <donri> (and then why isn't it an import from that?)

[14:20] <donri> or am i missing something

[14:30] <ingy> donri: audrey sez it needs to be redone :)

[14:31] *** arnsholt_ joined
[14:31] *** arnsholt_ left
[14:32] <ingy> in Configure.PL preferably

[14:32] <ingy> I wonder if we can find the old svn version...

[14:32] <moritz> cd perl6/mu

[14:32] <moritz> git checkout 6f0203060f

[14:32] <moritz> cat util/PugsConfig.pm

[14:34] <benabik> https://github.com/perl6/mu/blob/6f0203060f2ff65dfd1227e927b5c87d77640970/util/PugsConfig.pm

[14:35] <moritz> benabik++

[14:35] <moritz> (keeping information)++

[14:35] <ingy> https://github.com/audreyt/pugs/blob/master/util/PugsConfig.pm

[14:40] *** risou is now known as risou_awy

[14:40] *** SHODAN left
[14:47] <masak> ooh, got HN'd! :) http://news.ycombinator.com/item?id=3124920

[14:49] <masak> that's a great question -- how *would* we code do-in-reverse with Perl 6 macros? suggestions welcome.

[14:49] <masak> (the point of the question being, of course, that Lisp has it easy modifying ASTs, since they're just more lists)

[14:50] <flussence> $thing.ast.reverse? ;)

[14:50] <moritz> well, that's where the need for an introspection and construction API for ASTs comes up

[14:50] <moritz> is there a practical application for do-in-reverse?

[14:52] <sorear> good * #perl6

[14:52] <masak> no, but the principle is important, I would say.

[14:52] <masak> sorear: *

[14:54] <moritz> the best I can come up with is

[14:54] <moritz> $ast.clone(statemnts => $ast.statements.reverse);

[14:55] *** tty234 left
[14:56] *** tty234 joined
[14:56] <moritz> otoh if we pass a list to do-in-reverse, you can just do @asts.reverse.map(*.execute) or so

[14:57] <masak> well, "pass a list to do-in-reverse", I'm not sure that's possible through the common macro mechanism.

[14:57] <moritz> a list of statements in Perl 6 is really a block

[14:57] <masak> hm, maybe if the macro takes a slurpy.

[14:58] <masak> but no, you meant it at that level. so no.

[14:58] <masak> moritz: as far as I can tell, the only things you can even macro over in the first place are things that can be operands and funcall arguments.

[14:58] <masak> you can't macro over a bunch of statements.

[14:59] <moritz> masak: you can macro over anything with 'is parsed'

[14:59] <masak> that's why I won't go near 'is parsed' :P

[14:59] <moritz> so can we get the AST of a block in a macro?

[15:00] <masak> aye.

[15:02] <eiro> a

[15:02] <eiro> oops 

[15:04] * masak wouldn't mind reading a longish treatise on in-band vs out-of-band values in domain modeling

[15:04] <masak> in-band: "no-one will ever use this value in actual practice!" (later: "d'oh!")

[15:05] <masak> out-of-band: "this extra bit of abstractionality won't hurt..." (later: "d'oh!")

[15:06] <moritz> see also: XML. "XML is great, because we can just stuff more data into attributes later on" (later: "d'oh!")

[15:06] *** Maddingue joined
[15:10] <masak> :D

[15:11] <moritz> fwiw I've replied: http://news.ycombinator.com/item?id=3125489

[15:11] <masak> I've never really seen the use of attributes in XML. they're like storing values directly in the markup, except that you don't get the choice of nesting. and suddenly you have to decide for every new thing whether to make it an attribute or a subelement.

[15:12] <masak> moritz: nice reply.

[15:12] <masak> and yes, it's already turned out not to be that simple.

[15:13] <mux> there is one legitimate use of attributes: id=""

[15:13] <masak> moritz: a Perl6::AST is an implementation-independent wrapper, containing the actual AST as an attribute.

[15:13] <moritz> masak: well, attributes make a lot of sense if you view it as a markup language, not as a serialization or data storage format

[15:14] <masak> that is true.

[15:14] <moritz> and that's the ML in XML stand for

[15:14] <moritz> everything else is abuse

[15:14] <masak> it's just that there's a lot of abuse.

[15:14] <donri> pugs: quasi { say "O HAI" }

[15:14] <p6eval> pugs b927740:  ( no output )

[15:14] <donri> pugs: say quasi { say "O HAI" }

[15:14] <p6eval> pugs b927740: OUTPUT«<obj:Code::Exp>␤»

[15:20] <sorear> pugs: say quasi { 5 }

[15:20] <p6eval> pugs b927740: OUTPUT«<obj:Code::Exp>␤»

[15:21] <sorear> masak: how much do you ant to allow the user to manipulate ast objects?

[15:21] <sorear> masak: is quasi { has $.x is rw } a possible thing in your model?

[15:21] <sorear> the first thing I wanted to use quasi for was methods, actually

[15:22] <moritz> isn't that what roles are for?

[15:23] *** im2ee joined
[15:28] <donri> perl6: say quasi { 5 }

[15:28] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method quasiquibble not yet implemented at /tmp/BLUhETKGiK line 1 (EOF):␤------> [32msay quasi { 5 }[33m⏏[31m<EOL>[0m␤␤Action method quote:quasi not yet implemented at /tmp/BLUhETKGiK line 1 (EOF):␤------> [32msa…

[15:28] <p6eval> ..pugs b927740: OUTPUT«<obj:Code::Exp>␤»

[15:28] <p6eval> ..rakudo 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&quasi' called (line 1)␤»

[15:28] <donri> quasiquibble? :D

[15:29] <masak> donri: STD.pm6 terminology.

[15:30] <masak> expect it to be exactly as silly as the situation calls for :P

[15:30] <donri> :)

[15:30] <masak> sorear: I don't think that would do what you want it to, no.

[15:31] <masak> sorear: because parsing the 'has' will probably go looking for a metaclass object *immediately* at parse time.

[15:31] <masak> which is too early for what you want.

[15:32] <masak> sorear: as to how much I want to allow the user to manipulate AST objects -- 100%. but I fear we'll run up against implementation-dependencies pretty fast. :/

[15:42] <masak> perl6: has $.x is rw

[15:42] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Attribute x declared outside of any class at /tmp/aTjnVZW8th line 1 (EOF):␤------> [32mhas $.x is rw[33m⏏[31m<EOL>[0m␤␤Potential difficulties:␤  'has' declaration outside of class at /tmp/aTjnVZW8th line 1:␤------> [32m…

[15:42] <p6eval> ..rakudo 4e4390: OUTPUT«===SORRY!===␤A  cannot have attributes at line 1, near ""␤»

[15:42] <p6eval> ..pugs b927740: OUTPUT«pugs: *** Can't modify constant item: VUndef␤    at /tmp/TaLvVl4XWg line 1, column 1␤»

[15:43] <masak> sorear: the rule is something like "if it fails standalone, it probably won't make it inside a quasi either".

[15:45] *** risou_awy is now known as risou

[15:46] <moritz> pugs: quasi { has $.x }

[15:46] <p6eval> pugs b927740: OUTPUT«pugs: *** Can't modify constant item: VUndef␤    at /tmp/dR8OFxaRD9 line 1, column 1␤»

[15:47] <donri> why does anything look for any sort of object at parse time?

[15:47] <donri> that sounds so wrong i'm obviously missing something

[15:47] <masak> donri: welcome to how Perl 6 parses things :)

[15:47] <TimToady> because declarations always take effect as soon as possible

[15:47] <donri> xD

[15:48] <masak> donri: all the declaration-y bits in OO actually trigger method calls on various HOW objects in the background.

[15:48] <donri> at parse time?

[15:48] <masak> sure, why not?

[15:48] <masak> you might do a BEGIN right after and use the class.

[15:48] <PerlJam> donri: "as soon as possible" :)

[15:48] <donri> or am i misinterpreting what "parse time" means

[15:49] <masak> donri: when you reach the '}' of a class, it's "composed" with a ClassHOW.compose method call. that's when all the roles are flattened in, etc.

[15:49] <donri> isn't "parse time" where you turn strings into "dumb" ASTs?

[15:49] <TimToady> anything in the quasi that has to be generic needs a COMPILING:: style declaration to make it so

[15:50] <masak> donri: not just ASTs.

[15:50] <TimToady> that would include the current class

[15:50] <moritz> rakudo: class A { has $.x = 4 }; BEGIN { say A.new.x }

[15:50] <p6eval> rakudo 4e4390: OUTPUT«4␤»

[15:50] <TimToady> which is automatically generic in a role, but not in a macro

[15:50] <masak> donri: ASTs, action method calls, World method calls.

[15:50] <moritz> BEGIN is run directly after it is parsed

[15:50] <donri> but that's still post-parse-time?

[15:50] <masak> no :)

[15:50] <masak> BEGIN runs during parse time.

[15:51] <masak> well, it takes a short break from parse time, I guess... :)

[15:51] <masak> but then it gets right back to it.

[15:51] <donri> weird :) but i'm sure for good reasons

[15:51] <TimToady> anything that might change the current language *must* happen synchronously in Perl 6, or you've subtly introduced multiple pass parsing

[15:51] <PerlJam> donri: during "parse-time" for the whole program, but "immediately after it's parsed" for things like BEGIN

[15:52] <TimToady> and certainly introducing a new symbol into the symbol table changes the language

[15:52] *** packetknife joined
[15:53] <masak> donri: in the past year or two, I've had my view of "parse time" as being something pure and syntax-only thoroughly smashed by the Perl 6 view of things.

[15:53] <donri> hehe

[15:53] <masak> donri: it's not only very sensible, it's probably necessary.

[15:54] <moritz> it is necessary when you want a language to be as mallable as Perl 6 is

[15:54] <PerlJam> masak: But "parse time" has never been that in Perl.  Why would you start from that position?

[15:54] <donri> but at least you seem to understand my confusion and i'm not just being completely stupid :)

[15:54] <masak> PerlJam: because it works in so many other places?

[15:54] <TimToady> PerlJam: eh?  Perl 5's BEGIN is also immediate

[15:54] <TimToady> use is immediate

[15:54] <TimToady> and that's how you change the language in Perl 5

[15:55] <GlitchMr> __halt_compiler() in PHP is also processed in parse time...

[15:55] <PerlJam> TimToady: certainly not "pure and syntax-only"

[15:55] <TimToady> P6 is just taking that to its logical conclusion

[15:55] <masak> GlitchMr: :D

[15:55] <masak> GlitchMr: way to go with "different things should look different"...

[15:55] <masak> *two* underscores!

[15:56] <masak> then it must not be a regular function call... ;)

[15:56] <PerlJam> masak: it's *ultra* private  :)

[15:56] <TimToady> which is why 'my $x = $x' means very different things in Perl 5 and 6

[15:56] <GlitchMr> http://php.net/manual/en/function.halt-compiler.php

[15:56] <GlitchMr> Yeah...

[15:57] <masak> the PHP compiler is so wild you have to have a special keyword with two underscores to get it to halt...

[15:57] <GlitchMr> Exactly.

[15:57] <moritz> BEGIN exit;

[15:58] <TimToady> immediate introduction of symbols is why you can refer to previous formal parameters in signatures

[15:58] <TimToady> but I can see why it causes a bit of a conundrum for macros

[15:58] <donri> i suppose python's __future__ imports are "parse-time" but those are compiler pragmas basically

[15:58] <moritz> nom: say .chars for ('BEGIN exit;', '__halt_compiler()')

[15:58] <p6eval> nom 4e4390: OUTPUT«11␤17␤»

[15:58] <PerlJam> TimToady: the only problem with "my $x = $x" is that people (in general) find the P5 semantics more sensible  :)

[15:58] <moritz> so even there Perl 6 is shorter, even though PHP has introduce an extra feature for it

[15:59] <GlitchMr> It's not as bad as (Perl 5):

[15:59] <TimToady> only because that's what they've been trained to expect

[15:59] <GlitchMr> whatever  / 25 ; # / ; die "this dies!";

[15:59] <masak> when I get home to my macros branch, I will try to define 'macro __halt_compiler() { exit }' :)

[15:59] <PerlJam> TimToady: indeed, and not just by perl

[15:59] <TimToady> PerlJam: I've always been the tail trying to wag the dog; you only just now noticed?  :)

[15:59] <moritz> PerlJam: no. Think of  my $fib = sub { ... recurse into $fib ... }

[16:00] <moritz> PerlJam: people do expect that to work, even in perl 5

[16:00] <TimToady> in fact, I think that's a FAQ in Perl 5

[16:00] <GlitchMr> masak, not exactly. __halt_compiler(); works more like parser stops to take more data.

[16:00] <masak> oh, ok.

[16:00] <moritz> like __END__ in p5?

[16:00] <GlitchMr> Yeah

[16:00] <moritz> hey, even that is shorter :-)

[16:01] <PerlJam> moritz: I don't know how many people tend to do that though.  

[16:01] <GlitchMr> I found __halt_compiler() trick interesting when I've found it

[16:01] <PerlJam> er, want to do that 

[16:01] <GlitchMr> Also list() in PHP which works like our() in Perl 5...

[16:01] <moritz> PerlJam: all those who read HOP :-)

[16:02] <GlitchMr> list($hello, $world) = array('Hello', 'World');

[16:02] <GlitchMr> ...

[16:02] <PerlJam> I know *I* have wanted it a few times, but I tend to think that it's the "power users" who want it and the general population are just confused.

[16:02] <masak> I don't think you can use =END in a macro either... :/

[16:02] <masak> maybe there's a way to build the AST for it, though...

[16:02] <masak> maybe.

[16:02] * masak decommutes

[16:02] <PerlJam> GlitchMr: list() doesn't work at all like our.  It just does grouping.

[16:03] <GlitchMr> ... well...

[16:03] <GlitchMr> our() also does it

[16:03] <PerlJam> GlitchMr: our has nothing to do with grouping :)

[16:03] <TimToady> masak: perhaps the sane thing for your current project is to say that generic declarations may only be done as textual macros for now

[16:03] <GlitchMr> Can you do $var, $bar = $foo;

[16:03] <GlitchMr> (even without strict mode)?

[16:04] <GlitchMr> our($hello, $world) = ('Hello', 'World');

[16:04] <GlitchMr> ...

[16:04] <TimToady> our is not a function in Perl

[16:04] <GlitchMr> It's not in PHP too...

[16:05] <GlitchMr> list() isn't function in PHP... it's trick made on parser level...

[16:05] *** mj41 left
[16:05] <PerlJam> GlitchMr: but all list() does is grouping a bunch of things together. our doesn't do that.

[16:05] <GlitchMr> ...

[16:06] <GlitchMr> Yeah, PHP doesn't really have local variables...

[16:06] <GlitchMr> So there is no our() or my() like words...

[16:06] <PerlJam> GlitchMr: it's the parens in your examples that have handled grouping.

[16:06] <GlitchMr> ok, ok

[16:07] <GlitchMr> I haven't really programmed in Perl 5

[16:07] *** bluescreen10 joined
[16:07] *** mkramer1 joined
[16:08] <TimToady> because of certain mental idiosyncracies on the part of its designer, Perl 6 won't allow you to say our() if you really mean our ()

[16:08] <TimToady> perl6: our($hello, $world) = ('Hello', 'World');

[16:08] <p6eval> rakudo 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&our' called (line 1)␤»

[16:08] <p6eval> ..pugs b927740:  ( no output )

[16:08] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $hello is not predeclared at /tmp/TqiPfaugaE line 1:␤------> [32mour([33m⏏[31m$hello, $world) = ('Hello', 'World');[0m␤␤Variable $world is not predeclared at /tmp/TqiPfaugaE line 1:␤------> [32mour($hello, [33…

[16:08] <TimToady> perl6: our ($hello, $world) = ('Hello', 'World');

[16:08] <p6eval> pugs b927740, niecza v10-58-gc851cf8:  ( no output )

[16:08] <p6eval> ..rakudo 4e4390: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:Multiple declarations of lexical '$hello'␤␤     in file '(file unknown)' line 158␤»

[16:08] <GlitchMr> I really don't care. I haven't really used list().

[16:09] <TimToady> eh, what's up with rakudo there?

[16:09] <PerlJam> rakudo's interpretation is ... interesting  :)

[16:09] <GlitchMr> And the only time I've used grouping in Perl 5 is subroutine arguments.

[16:09] <TimToady> perl6: our ($hello, $world);

[16:09] <p6eval> rakudo 4e4390: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:Multiple declarations of lexical '$hello'␤␤     in file '(file unknown)' line 10519434␤»

[16:09] <p6eval> ..pugs b927740, niecza v10-58-gc851cf8:  ( no output )

[16:09] <GlitchMr> I only use grouping for subroutine arguments.*

[16:09] <TimToady> perl6: my ($hello, $world);

[16:10] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Potential difficulties:␤  $hello is declared but not used at /tmp/kyDDtgmX70 line 1:␤------> [32mmy [33m⏏[31m($hello, $world);[0m␤  $world is declared but not used at /tmp/kyDDtgmX70 line 1:␤------> [32mmy [33m⏏[31m($hello, $world);[0m␤␤»…

[16:10] <p6eval> ..pugs b927740, rakudo 4e4390:  ( no output )

[16:10] <GlitchMr> Perl 6 can specify arguments of function like in C++ or PHP, so I guess I won't have to use grouping in Perl 6.

[16:11] <TimToady> I think you're using the term "grouping" more specifically than most folks here would

[16:11] <TimToady> (1+2)*3 is also grouping

[16:11] <TimToady> not just the optional function parens

[16:12] <TimToady> perl6: state ($hello, $world);

[16:12] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Potential difficulties:␤  $hello is declared but not used at /tmp/WJ88virKia line 1:␤------> [32mstate [33m⏏[31m($hello, $world);[0m␤  $world is declared but not used at /tmp/WJ88virKia line 1:␤------> [32mstate [33m⏏[31m($hello, $world);[0m␤␤»…

[16:12] <p6eval> ..pugs b927740, rakudo 4e4390:  ( no output )

[16:13] <TimToady> rakudo: our($hello, $world) = 1,2;

[16:13] <p6eval> rakudo 4e4390: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&our' called (line 1)␤»

[16:14] <TimToady> why doesn't that die of defined $hello first?

[16:14] <TimToady> *undef

[16:14] <TimToady> variables aren't allowed to be postdeclared like 'our' is

[16:14] *** MayDaniel joined
[16:15] <TimToady> niecza: our($hello, $world) = 1,2;

[16:15] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $hello is not predeclared at /tmp/SQ7zuXgOja line 1:␤------> [32mour([33m⏏[31m$hello, $world) = 1,2;[0m␤␤Variable $world is not predeclared at /tmp/SQ7zuXgOja line 1:␤------> [32mour($hello, [33m⏏[31m$world) …

[16:16] <PerlJam> nom: say $a; my $a  = 1;  # same problem

[16:16] <p6eval> nom 4e4390: OUTPUT«Any()␤»

[16:16] <TimToady> oh, maybe it's just that rakudo does not correctly dump its accumulated 'sorry's

[16:16] *** agentzh left
[16:16] <PerlJam> (at least I think it's the same)

[16:16] <TimToady> ah, right, I'd forgotten about that bug

[16:17] <TimToady> otoh, as a language designer one can certainly imagine postdeclaration of variables for things like list comprehensions

[16:17] <TimToady> and Haskell makes a virtue of it

[16:17] <TimToady> (with where clauses)

[16:21] <donri> also http://www.python.org/dev/peps/pep-3150/

[16:21] *** GlitchMr left
[16:25] <PerlJam> I think "self declaration" makes more sense ($^a and friends)

[16:26] <PerlJam> (granted that doesn't help list comprehensions)

[16:26] <TimToady> well, mathematicians are actually lousy language designers, I think :)

[16:30] <Woodi> depends on language definition :)

[16:30] <donri> they tend to be lousy at language anyway, at least math teachers

[16:30] <TimToady> masak: otoh, there might be an easyish way to make macros generic in the current class; obviously roles can do that already

[16:31] <Woodi> btw. earlier was talking about Parrot guts-something in PIR context... it was about refactoring or removing or... ?

[16:33] *** thou joined
[16:35] <TimToady> rakudo is trying to get rid of the PIR abstraction layer, which is both too low-level and too high-level

[16:36] <TimToady> npq is the new intended abstraction layer

[16:36] <TimToady> this will make it more portable to new VMs, including whatever Parrot will become eventually

[16:39] <Woodi> PIR was bytecode, so looks for me Parrot without bytecode will be Perl6 backend

[16:39] *** kaleem joined
[16:40] <TimToady> I was interested above that there was an imcc error, which is even lower-level than pir

[16:40] <TimToady> rakudo: our ($hello, $world);

[16:40] <p6eval> rakudo 4e4390: OUTPUT«Use of uninitialized value in string context␤Use of uninitialized value in string context␤===SORRY!===␤error:imcc:Multiple declarations of lexical '$hello'␤␤     in file '(file unknown)' line 18924426␤»

[16:40] <benabik> PIR isn't bytecode.  PIR is a layer of magic on top of bytecode.

[16:41] <Woodi> hmm, ok.

[16:41] *** wk left
[16:41] <Woodi> is it hard to just write Perl6 -> C translator ? :)

[16:41] <benabik> TimToady: That is odd.  Rakudo is doing something bad there.

[16:42] <TimToady> Woodi: various people are thinking about that :)

[16:42] * Woodi stop yesterday :)

[16:43] <Woodi> err, stoped dreaming about trying to do it. not thinking :)

[16:43] <TimToady> whew!

[16:44] <TimToady> but in all honesty we should point out that, yes, it is likely to be hard, for various reasons

[16:44] <Woodi> can part of Perl6 spec be declared stable ?

[16:45] <TimToady> the P6 spec does JIT stability

[16:45] <TimToady> implement it, and it becomes stable :)

[16:45] <TimToady> well, stabler... :)

[16:45] <PerlJam> How to build a Perl 6 compiler, step 1:  First, find or build a VM that mostly does what you need

[16:45] <Woodi> ok, you wanted it :)

[16:46] <Woodi> step 1. write Perl6 spec in PEBNF

[16:47] <PerlJam> P for perl ?

[16:47] <TimToady> Problem Exists Between New Friends?

[16:47] <Woodi> (BNF with Perl scripts where needed) :)

[16:47] <Woodi> Perl Extended BNF :)

[16:48] <PerlJam> Woodi: I guess that's what NQP is 

[16:48] <TimToady> there are probably easier ways to bootstrap that then writing your own Perl6 parser

[16:48] <Woodi> step 2. ask TimToady how big/small part of spec require to be writed in Perl :)

[16:48] <TimToady> *than

[16:49] <Woodi> PerlJam: problems is: if someone want to learn Perl spec then he must spend few years on #perl6 or memoize STD.pm...

[16:49] <TimToady> at this point it would be much easier to retarget the backend of an existing compiler

[16:49] <Woodi> and STD.pm realy exploded in size in last 2 years...

[16:50] <Woodi> so PEBNF would be just 'manual'...

[16:51] <Woodi> STD.pm: line 1068: grammar P6 is STD {

[16:52] <PerlJam> It's really amazing how tasty this chicken is seasoned with tomato sauce, cumin, salt, pepper, and garlic 

[16:52] <Woodi> it is not textual point of reference...

[16:52] <TimToady> I don't know what you mean by that; you need to learn to unpack just a bit more for those of us who are slow

[16:53] <Woodi> ok. I just try to point problems and, as usual. i can be wrong :)

[16:54] *** thou left
[16:54] <PerlJam> Woodi: and the problem is ... ?

[16:54] *** daniel-s left
[16:55] <Woodi> it is hard to implement Perl6 becouse it is no 'big picture' in any form

[16:55] <PerlJam> Woodi: Perl 6 is fractal.  It looks the same from 50,000 feet as it does from 10 feet

[16:55] <mls_> heh, 12% speedup on perl6 startup by adding a Hash.update method to parrot

[16:55] <Woodi> eg.: do Perl6 if/elsif/else can be wroted as EBNF ?

[16:56] <Woodi> how many points in spec are type "can be parsed only by Perl" ?

[16:56] <PerlJam> mls++

[16:56] <Woodi> classes ?

[16:56] <PerlJam> Woodi: everything?

[16:57] <benabik> mls_: %h1.update(%h2) ?

[16:57] <mls_> PerlJam: (I know this is optimizing the wrong pieces of code, as it all is moot when jnthn++ does the serialization change)

[16:57] <mls_> yes, %h1.update(%h2)

[16:57] <Woodi> PerlJam: just was writing question about this...

[16:58] <PerlJam> Woodi: so, you think Perl 6 is too complex?

[16:58] <benabik> mls_: 12% faster now is nicer than X% faster at some point in the future.

[16:58] <tadzik> 'evening

[16:58] <colomon> \o

[16:58] <PerlJam> mls_: what benabik said.  :)

[16:59] <diakopter> benabik: that's a great point.

[16:59] <Woodi> PerlJam: no. i would like to find easy way to implement perl6 :)

[17:00] <diakopter> Woodi: it's impossible; the spec is huge; there's no easy way about it.

[17:00] <Woodi> PerlJam: by abstracting standard functionalities like if/while/class and marking few (hope) things as 'only can be done in Perl itself)

[17:00] *** GlitchMr joined
[17:00] <PerlJam> Woodi: See NQP  :)

[17:00] <mberends> Woodi: there is no easy way, because of the complexity of Perl 6. I would suggest searching for an easy way to implement a useful subset of Perl 6.

[17:01] <Woodi> NQP is such thing that it is git clone longer then rakudo.... so i think about BNF for standard things with perl additions...

[17:02] <Woodi> mberends: i just do this by wanting picture in BNF notation :)

[17:02] *** molaf joined
[17:02] *** dakkar left
[17:02] <benabik> The fun thing about parsing P6 is that the spec requires a _dynamic_ parser instead of a static one.  There are not a lot of existing tools or types that do such a thing.

[17:03] <Woodi> it is imposible !

[17:03] <PerlJam> benabik: yet!  :)

[17:04] <Woodi> few language things must be easier

[17:05] *** daxim left
[17:05] <Woodi> ok, then NQP is answer. but it less documented then Perl6

[17:05] * diakopter tries to backlog

[17:05] <benabik> The nice part is that, AFAICT, all the dynamic bits are protos and symbol table lookups.  Makes life easier.

[17:06] <benabik> I wonder if I could get a paper out of extending bison or parser derivatives with protos.

[17:06] <Woodi> so what features NEED to be in Perl tself ?

[17:06] <PerlJam> benabik: you include object construction in that?

[17:06] <PerlJam> Woodi: all of them!  ;)

[17:07] <benabik> PerlJam: Object construction is orthogonal to parsing, I think...

[17:07] <Woodi> pls, understand me, just looking a way to write teoretical plan for writing Perl6 compilers

[17:07] <benabik> Woodi: I'm off on a digression, don't mind me.

[17:08] *** mkramer1 left
[17:08] <Woodi> benabik: volontires only :)

[17:09] <Woodi> volunteers :)

[17:09] <benabik> Hm, wait…  the is parsed trait is an issue.  :-/

[17:09] <benabik> Although that only triggers wherever the method would fit into the grammar naturally, no?

[17:15] <Woodi> PerlJam: i read somewhere: there are two kind of ppls: humanists and 'strict mind' ppls. humanists like to finish with questions or unknow and strict ppls like answers or plan to do...

[17:16] <Woodi> saying Perl is like fractal kills every hope...

[17:16] <benabik> Ah, well.  My thesis is on optimization, not parsing, so moving on.

[17:18] <PerlJam> Woodi: I think you're just looking down the wrong axis  :)

[17:19] <Woodi> not think so - just trying to place things in hierarchy...

[17:20] *** Chillance joined
[17:21] <TimToady> note that tools like yacc assume a fixed lexer, while Perl 6 requires JIT lexers to be autogenerated

[17:22] <Woodi> TimToady: on every language feature ?

[17:22] <PerlJam> Woodi: sounds like you're one of those "strict mind" people  :)

[17:22] <TimToady> I don't know what you mean by "feature", but Perl 6 requires a new lexer every time there a new alternation with a different set of "longest tokens"

[17:23] * diakopter would love some elucidation on that

[17:23] <TimToady> what *do* you mean by "feature", anyway?

[17:24] <Woodi> feature == syntax, eg.: if/else or while {...}

[17:24] <Woodi> such things require change language lexer ?

[17:24] <Woodi> statement

[17:25] <Woodi> just want to abstract statements rwquiring dynamic parsing

[17:25] <jasonmay> masak++ # never having done any functional stuff, your post was quite effective for enlightening me on macros

[17:26] <TimToady> okay, Perl 6 parsing is based on the notion of "syntactic category", which some folks refer to as "protos"

[17:26] <TimToady> when you add a feature like if/else, you likely add it into a particular syntactic category

[17:26] <TimToady> in this case the statement_control category

[17:27] <TimToady> that category is effectively an alteration of the | kind

[17:27] <TimToady> and P6 guarantees LTM (longest token matching) semantics across all | alternations

[17:27] <TimToady> including the implicit alt for categories

[17:28] <TimToady> but note that statement_control is just one category

[17:28] <TimToady> it gets subsumed into larger alternative, when you include statements that are not controls, for instance

[17:29] <TimToady> at the start of a statement, you can have various nouns or prefix operators as well as controls

[17:29] <TimToady> all of those participate in a JIT lexer that knows all those possible longest terms, and does the right thing

[17:30] <TimToady> if you derive a new grammar, and add entries to any of those categories, a new lexer must be calculated

[17:30] <TimToady> in theory, if you even add a symbol to the symbol table, you effectively have a new language, but we cheat on that, since it's inefficient to change your lexer that frequently

[17:31] <TimToady> does any of that make sense to you?

[17:31] <Woodi> i look for way to simplify a bit :)

[17:31] <Woodi> assume grammar P6...

[17:31] *** lateau__ left
[17:32] <TimToady> most such simplifications produce something that isn't quite P6 :)

[17:32] <Woodi> can lexer can be static + var names + function names ?

[17:32] <TimToady> it's okay for practical purpose to program in a subset, of course

[17:33] <PerlJam> (See NQP ;)

[17:33] <Woodi> just want perl6 in practice...

[17:34] <TimToady> but you can't call it Perl 6 if it isn't, is all :)

[17:35] <TimToady> Standard Perl 6 requires the ability to create non-standard Perl 6

[17:35] <Woodi> TimToady: but maybe do this in small steps ?

[17:36] <TimToady> all steps are created equal, but some are more equal than others

[17:36] <Woodi> first working subset to start system-programming...

[17:36] <TimToady> I strongly suggest using an existing parser, and retargeting it

[17:37] <diakopter> Woodi: hint: viv

[17:37] <TimToady> trying to write your own P6 grammar to do what you want is probably an XY problem

[17:37] <TimToady> diakopter: or niecza, or nom

[17:38] <TimToady> but niecza is closer to the STD parser so far

[17:38] <Woodi> actual compilers are haevy...

[17:38] <diakopter> hm, maybe I should use niecza instead of viv for the initial front-end to sprixel.

[17:38] <Woodi> will not replace Perl5 in Linux distro

[17:38] <TimToady> we don't plan to

[17:38] <tadzik> none will

[17:39] <TimToady> we do plan to replace python and ruby though :P

[17:39] <TimToady> and hopefully JS, Java, and PHP while we're at it

[17:39] <Woodi> raw speed is needed... and niche

[17:39] <PerlJam> that'll never happen due to the large group of people who are allergic to sigils

[17:40] <TimToady> modules will happen :)

[17:40] <TimToady> and sigilless will be one of the first attempted :)

[17:40] <tadzik> that'd be fun

[17:40] <Woodi> btw. got idea today: can Perl6 be better buildtools then actual ./configure --prefix=....

[17:41] <TimToady> we're actually not so far from sigilless right now, if we assume that foo can look for $foo internally

[17:41] <TimToady> you can program sigilless now, if sub foo() is rw { $foo }

[17:41] <PerlJam> That's an odd way to declare vars though

[17:41] <diakopter> one could use a macro to replace..

[17:42] *** packetknife left
[17:42] <TimToady> diakopter: precisely

[17:42] <TimToady> I don't know what standard perl 6 will look like 50 years from now, other than "different"

[17:43] <tadzik> it will be "this thing we use for 20 years waiting for Perl 7 to actually be implemented"

[17:43] <TimToady> Woodi: sure, all current build tools suck dead gerbils through a garden hose

[17:43] <diakopter> masak: that's a good test for your macro project: whether it can make same-named rw subs from variables

[17:43] <diakopter> we need a TimToady quote bot

[17:43] <TimToady> not original with me, that one

[17:44] <diakopter> just imagine how many hours it would take to backlog all of #perl6 to find all the quotable gems

[17:45] <diakopter> I suppose moritz could make a TimToady-only view of the clogs

[17:45] <TimToady> in fact, it gets 62,000 hits on google

[17:45] * Woodi realy want to have high performance Perl6 compiler with grammars NIY :)

[17:45] <TimToady> well, starting at "suck"

[17:46] * Woodi tee (flee!)

[17:46] *** shi joined
[17:46] <PerlJam> Woodi: We'll likely need a few more decades to get to "high performance" just like fortran did  :)

[17:48] *** donri left
[17:48] <dalek> nqp: 514d0fe | mls++ | / (2 files):

[17:48] <dalek> nqp: use parrot's new Hash.update method to speed up method cache generation

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/514d0fe722

[17:48] *** wk joined
[17:49] *** static_perl left
[17:54] <moritz> diakopter: you can already filter the IRC logs by nick, if you have JS enabled

[17:55] *** risou is now known as risou_awy

[17:57] <diakopter> oo

[18:00] <moritz> and there's also the search (though it's slow)

[18:01] <TimToady> any proposed rules for -er in English are stupider than most native speakers, who know English betterer than that :)

[18:04] *** shi is now known as ksi

[18:04] *** benabik_ joined
[18:04] <mls_> moritz: the update patch for rakudo: https://gist.github.com/1296162

[18:05] <mls_> (you must also update to the latest nqp version)

[18:07] <TimToady> Rat should probably mean Rat[Int, Uint64], to avoid assuming that the denominator must be stored in 64 bits no matter how small

[18:07] <TimToady> note, Uint64, not uint64

[18:08] <TimToady> to at least allow for space/time tradeoffs

[18:08] *** benabik left
[18:08] *** benabik_ is now known as benabik

[18:08] <TimToady> implementation of Uint64 as uint64 is of course acceptable

[18:10] *** wk left
[18:16] *** libertyprime joined
[18:18] <masak> jasonmay: thanks for the encouragement. I will write more on macros ;)

[18:21] <dalek> specs: 5e98222 | larry++ | S02-bits.pod:

[18:21] <dalek> specs: Rat has Uint64 for a denom, for repr flexibility

[18:21] <dalek> specs: review: https://github.com/perl6/specs/commit/5e98222c5c

[18:22] <diakopter> niecza: class A { ... }; BEGIN { say A.new }; class A { has $!x; };

[18:22] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Package was stubbed but not defined at /tmp/rBqTECgFr5 line 1:␤------> [32mclass A { ... }[33m⏏[31m; BEGIN { say A.new }; class A { has $!x[0m␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.s…

[18:24] *** cognominal_ joined
[18:25] <diakopter> niecza: class A { ... }; BEGIN { class A { has $!x; }; say A.new }

[18:25] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two definitions found for symbol ::GLOBAL::A␤␤  first at /tmp/hcdACDuK5C line 1␤  second at /tmp/hcdACDuK5C line 1 at /tmp/hcdACDuK5C line 1:␤------> [32mclass A { ... }; BEGIN { class A [33m⏏[31m{ has $!x; }; say A.new }…

[18:27] *** cognominal left
[18:28] <diakopter> nom: class A { ... }; BEGIN { class A { has $!x; }; say A.new }

[18:28] <p6eval> nom 4e4390: OUTPUT«A.new()␤»

[18:29] <diakopter> nom: class A { ... }; { class A { has $!x } }; say A.new

[18:29] <p6eval> nom 4e4390: OUTPUT«A.new()␤»

[18:30] * Woodi found nice looking NQP docs...

[18:32] <tadzik> im2ee: ping

[18:33] <im2ee> hello tadzik ! :)

[18:33] <tadzik> oh, hey

[18:33] <tadzik> I tried to examine your TCP server using Select today

[18:34] *** wamba joined
[18:34] <tadzik> I have a feeling that Select in Parrot is broken possibly at C level

[18:34] *** envi_ left
[18:34] <benabik> hah

[18:34] <tadzik> I may dive at some deep level, possibly hack in Pir/winxed and see if the behaviour is similar. For now it's segfaulting randomly, and randomly spewing something that reminds me of GC bugs I've seen this summer

[18:36] <tadzik> although there _were_ cases when it worked, like "returned the filehandles it should have", so maybe there's hope :)

[18:36] <im2ee> tadzik, thanks. So there is a hope. :)

[18:36] <tadzik> aye

[18:36] *** wk joined
[18:36] <tadzik> I now have to learn winxed, parrot's sockets and try to write a server like yours :)

[18:37] <tadzik> may be a cure for my recent programming stagnation

[18:41] *** uasi left
[18:46] <diakopter> std: sub checklastval ($passwd) is rw { return new Proxy: FETCH => method { return lastval() }, STORE => method ($val) { die unless $passwd); lastval() = $val } } # TimToady this is an example from S06

[18:47] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse block at /tmp/CtokvkNI0B line 1:␤------> [32murn lastval() }, STORE => method ($val) [33m⏏[31m{ die unless $passwd); lastval() = $val [0m␤Couldn't find final '}'; gave up at /tmp/CtokvkNI0B line 1:␤------> [32mRE =>…

[18:47] <diakopter> er

[18:47] <diakopter> oops

[18:47] <diakopter> nm

[18:47] <tadzik> eww, you know what?

[18:48] <tadzik> Parrot's Socket already has poll() method, which, as far as I understand, gives us non-blocking IO capabilities for I don't know how long

[18:48] <tadzik> Watches the socket for sec seconds and usec milliseconds. which is a bitmask representing the states you want to watch for. Or together 1 for readable, two for writeable, and four for exceptions

[18:51] *** im2ee left
[18:51] <TimToady> Anyone using select for anything has already got an XY problem on their hands... :)

[18:51] *** im2ee joined
[18:53] <TimToady> with the possible exception of anyone struggling to implement a sane interface on top of it

[18:54] <diakopter> niecza: say hash pair 1

[18:54] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'pair' used at line 1␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤…

[18:56] *** wk left
[18:58] *** molaf left
[18:58] <diakopter> niecza: dispatch sub foo { }

[18:59] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'dispatch' used at line 1␤␤Potential difficulties:␤  &foo is declared but not used at /tmp/K5SKfnHFHU line 1:␤------> [32mdispatch sub foo [33m⏏[31m{ }[0m␤␤␤Unhandled Exception: Check failed␤␤  at /h…

[18:59] <diakopter> eh

[18:59] <diakopter> std: dispatch sub foo { }

[18:59] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'dispatch' used at line 1␤Check failed␤FAILED 00:01 119m␤»

[19:00] <diakopter> TimToady: should the above parse? S06 has that example

[19:02] <tadzik> im2ee: yay! Got something working

[19:03] <tadzik> im2ee: https://gist.github.com/1296356

[19:03] <tadzik> im2ee: it's still blocking on $a.recv, but that I leave as an exercise for the reader :)

[19:03] <tadzik> who opposes to implementing a real IO::Socket::poll?

[19:06] *** wooden left
[19:08] <masak> oppose? what's the downside?

[19:08] <tadzik> thank you

[19:08] <tadzik> I'll just check if it really solves all problems I can think of :)

[19:09] *** [Coke] joined
[19:09] <tadzik> I find it quite funny for how long we did have a non-blocking sockets in Parrot, and no one noticed, heck, we spent like half a year arguing over Select

[19:09] <flussence> I'm sure there's a technical reason to use something else instead of poll(), but right now there's no "something else" :)

[19:09] <tadzik> _sri prefers epoll() istr

[19:10] <flussence> libev, that way you get half a dozen things-better-than-poll through one interface

[19:10] <_sri> or even libuv

[19:11] <_sri> then you get windows too

[19:11] <benabik> ISTR that several platforms implement poll on top of epoll these days.

[19:11] * flussence hadn't heard of libuv until now

[19:11] <TimToady> events from registered objects are much saner than anything poll based

[19:11] <_sri> mozillas Rust language uses libuv

[19:11] <_sri> and of course node.js

[19:12] *** leprevost left
[19:13] *** benabik_ joined
[19:13] *** benabik left
[19:13] *** benabik_ is now known as benabik

[19:15] *** donri joined
[19:19] <tadzik> nom: say Rat.^methods # bleh

[19:19] <p6eval> nom 4e4390: OUTPUT«Method.new() Submethod.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Method.new() Metho…

[19:19] <tadzik> nom: say Rat.^methods.sort

[19:19] <p6eval> nom 4e4390: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu, Mu %_)␤␤  in method Numeric at src/gen/CORE.setting:604␤  in sub infix:<==> at src/gen/CORE.setting:2003␤  in sub infix:<cmp> at src/gen/CORE.setting:1043␤  in method sort at …

[19:20] <flussence> nom: say Rat.^methods».name

[19:20] <p6eval> nom 4e4390: OUTPUT«new BUILD nude Num Int Bridge Rat succ pred Str perl numerator denominator Rat abs sign conjugate sqrt sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh floor ceiling unpolar c…

[19:20] <flussence> don't they stringify that way any more?

[19:20] <moritz> tadzik: easy to fix

[19:20] *** mj41 joined
[19:21] <moritz> tadzik: just needs a multi method Str(Method:D:) { self.name } in Method.pm

[19:21] <moritz> (probably fallout from my earlier Mu.perl changes)

[19:22] *** jlaire left
[19:22] <masak> if someone promises to patch it immediately, I won't file a ticket.

[19:23] <masak> unless someone feels it needs a spectest...

[19:24] <dalek> sprixel: e591a06 | diakopter++ | src/ (4 files):

[19:24] *** jlaire joined
[19:24] <dalek> sprixel: optimize pre- and post- increment a bit more

[19:24] <dalek> sprixel: review: https://github.com/diakopter/sprixel/commit/e591a06ddc

[19:25] *** ggoebel left
[19:28] <cotto> masak++ for getting some hacker news love

[19:29] <tadzik> nom: my $seconds = 0.25; my $usecs = (($seconds - $seconds.floor) * 1000).Int; pir::say(nqp::unbox_i($usecs))

[19:29] <p6eval> nom 4e4390: OUTPUT«250␤»

[19:29] <tadzik> huh

[19:29] *** bluescreen10 left
[19:29] <tadzik> oh, nvm

[19:31] *** thou joined
[19:38] <masak> tadzik: 'u' is generally an ASCIIfication of μ, which stands for 10 ** -6, not 10 ** -3.

[19:39] *** saaki left
[19:39] *** uasi joined
[19:40] <tadzik> masak: an opportunity to fix Parrot docs :)

[19:40] <benabik> There is no dearth of opportunities to improve those.  :-/

[19:42] <tadzik> poll(INTVAL which, INTVAL sec, INTVAL usec)

[19:42] <tadzik> Watches the socket for sec seconds and usec milliseconds

[19:42] <tadzik> oh, ok, I'm wrong

[19:44] <tadzik> im2ee: https://gist.github.com/1296356 looks way better, and like what you might want to do

[19:44] <masak> what, why?

[19:44] *** bluescreen10 joined
[19:45] <masak> it's either "usec" or "milliseconds". not both.

[19:45] <tadzik> oh, so I'm not wrong, ok

[19:45] <masak> you wrongly thought you were wrong.

[19:46] *** wk joined
[19:48] *** kaleem left
[19:50] *** SHODAN joined
[19:54] *** MayDaniel left
[19:57] *** uasi left
[20:01] *** GlitchMr left
[20:01] <im2ee> tadzik++, i'll check it tomorrow! Thank You

[20:01] <im2ee> What is PIR exactly?

[20:02] <tadzik> Parrot intermediate representation

[20:02] <tadzik> some sort of Parrot assembly

[20:02] <tadzik> I managed to live w/o it

[20:03] <im2ee> And how to use it? :)

[20:03] <tadzik> do not :)

[20:05] <tadzik> I'll try to write a Perl 6 poll() on IO::Socket, to remove the need for crappy workarounds like this one in the gist

[20:08] *** soh_cah_toa joined
[20:09] *** im2ee left
[20:10] *** im2ee joined
[20:10] <[Coke]> soh_cah_toa: my copy of nqp is so old I apparently don't have $*OSNAME.

[20:10] <[Coke]> C:\sandbox\nqp>.\nqp -e "say($*OSNAME)"

[20:11] <[Coke]> Contextual $*OSNAME not found

[20:18] *** slavik1 left
[20:22] <soh_cah_toa> [Coke]: wow

[20:22] <soh_cah_toa> that's ok. i think it's MSWin32 anyway

[20:23] *** xinming left
[20:23] *** sivoais left
[20:23] *** cotto left
[20:23] *** jdhore left
[20:23] *** s1n1 left
[20:23] *** spacebat left
[20:23] *** mattp_ left
[20:23] <masak> argh. tired. need to regenerate.

[20:23] <masak> 'branoc, #perl6.

[20:24] *** xinming joined
[20:24] *** sivoais joined
[20:24] *** cotto joined
[20:24] *** jdhore joined
[20:24] *** s1n1 joined
[20:24] *** spacebat joined
[20:29] <sjohnson> masak: cya

[20:36] *** mberends left
[20:42] *** skangas left
[20:47] *** tokuhiro_ joined
[20:48] *** slavik1 joined
[20:48] *** dual joined
[20:50] *** mberends joined
[21:00] *** mkramer joined
[21:01] *** benabik_ joined
[21:01] *** benabik left
[21:01] *** benabik_ is now known as benabik

[21:05] *** mkramer1 joined
[21:06] *** SHODAN left
[21:08] *** [Coke] left
[21:08] *** mkramer left
[21:10] *** [Coke] joined
[21:18] <benabik> nom Q: Is perl6 --target=pir file.pl6 > file.pir && parrot file.pir expected to work?

[21:18] <benabik> I get Contextual $*ST not found

[21:18] <tadzik> that may be broken, yes

[21:18] <benabik> "Fun"

[21:18] <im2ee> Good night!

[21:19] *** im2ee left
[21:19] <tadzik> dobranoc imarcusthis 

[21:19] <tadzik> eeps, sorry imarcusthis 

[21:19] <tadzik> ETOOSMARTTAB

[21:23] *** thou left
[21:42] <dalek> rakudo/nom: bed705e | tadzik++ | src/core/IO/Socket.pm:

[21:42] <dalek> rakudo/nom: Implement IO::Socket.poll (unspecced)

[21:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bed705e1b3

[21:42] <tadzik> phenny: tell im2ee https://gist.github.com/1296356 is the best I've got, works with rakudo bed705e

[21:42] <phenny> tadzik: I'll pass that on when im2ee is around.

[21:44] *** ggoebel joined
[21:45] *** aindilis joined
[22:00] *** bluescreen10 left
[22:09] *** mj41 left
[22:14] *** tokuhiro_ left
[22:15] *** tokuhiro_ joined
[22:22] *** libertyprime left
[22:22] *** mattp_ joined
[22:23] *** ksi left
[22:27] *** dual left
[22:28] *** benabik left
[22:47] *** replore left
[22:53] *** whiteknight joined
[23:01] *** am0c joined
[23:08] *** benabik joined
[23:37] *** Chillance left
[23:47] <diakopter> ..

