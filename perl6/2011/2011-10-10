[00:24] *** replore_ left
[00:29] *** Exodist left
[00:31] *** Exodist joined
[00:35] *** shabble joined
[00:36] *** kst joined
[00:44] *** shabble left
[00:47] <japhb> perl6: (42 but role { method gist { 69 } }).WHAT.say

[00:47] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Int but ANON()␤»

[00:47] <p6eval> ..rakudo f6eb61: OUTPUT«69␤»

[00:47] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&role"␤    at /tmp/OHgLijeQrI line 1, column 2-36␤»

[00:47] <japhb> Ah, looks like rakudobug then

[00:51] <sorear> japhb: I doubt that

[00:51] <japhb> perl6: (42 but role { method gist { 69 }; method Str { '28' } }).perl.say

[00:52] <p6eval> rakudo f6eb61: OUTPUT«28␤»

[00:52] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&role"␤    at /tmp/_f8NPJ5ABQ line 1, column 2-57␤»

[00:52] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«Int but ANON␤»

[00:52] <japhb> sorear, why would WHAT defer to .gist?

[00:52] <japhb> And .perl defer to .Str?

[00:52] <sorear> japhb: WHAT doesn't defer to anything

[00:52] <sorear> WHAT doesn't return a string

[00:52] <japhb> Look at rakudo's output above ...

[00:52] <sorear> *say* defers to gist

[00:53] <sorear> $foo.say means $foo.gist.say, I think

[00:53] <sorear> but it looks like I didn't finish implementing that in niecza

[00:53] <sorear> also, having gist return a non-string like that is a bad idea imo

[00:54] <sorear> perl6: say (42 but role { method gist { 69 } }).WHAT

[00:54] <japhb> But why are .WHAT and .perl returning odd things in Rakudo?

[00:54] <p6eval> pugs: OUTPUT«*** No such subroutine: "&role"␤    at /tmp/DTaJx9OYeu line 1, column 6-40␤»

[00:54] <p6eval> ..rakudo f6eb61, niecza v10-40-ga57ed3d: OUTPUT«69␤»

[00:54] <sorear> japhb: you seem fundamentally confused about what WHAT does

[00:54] <japhb> Quite possible.

[00:55] <sorear> .WHAT returns a type

[00:55] <sorear> not a string

[00:55] <japhb> sorear, yes, fine.  So how is 69 in any way the correct type?

[00:56] <sorear> japhb: 69 is not the type

[00:56] <sorear> japhb: say calls .gist to convert the type into a string

[00:56] <sorear> japhb: the type is not a string, so it cannot be directly printed

[00:56] <sorear> japhb: all non-string objects must be converted into strings before they can be printed

[00:57] <japhb> OK, let me try again, a tad more precisely: Why is the *type* carrying the .gist of the *object*?

[00:57] <sorear> because Perl 6 unifies class and instance methods

[00:57] <sorear> MyGrammar.parse(...) works *because* MyGrammar is an object of type MyGrammar

[00:58] <sorear> it is, specifically, the unique undefined object of that type

[00:58] <sorear> in particular, $anything.WHAT.WHAT is the same as $anything.WHAT

[00:59] <japhb> Hmmm.

[00:59] <japhb> perl6: (42 but role { method gist($self :D:) { 69 } }).WHAT.say

[00:59] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Colonpair traits NYI at /tmp/RThQBCoRI3 line 1:␤------> [32m(42 but role { method gist($self :D[33m⏏[31m:) { 69 } }).WHAT.say[0m␤␤Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.settin…

[00:59] <p6eval> ..rakudo f6eb61: OUTPUT«===SORRY!===␤invoke() not implemented in class 'Capture'␤»

[00:59] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "D"␤    expecting space or ")"␤    at /tmp/dxlmaDEKs5 line 1, column 35␤»

[01:01] <japhb> perl6: (42 but role { method gist(Mu:D $self:) { 69 } }).WHAT.say

[01:01] <p6eval> rakudo f6eb61: OUTPUT«Parameter '$self' requires an instance, but a type object was passed␤  in method gist at /tmp/vt6FGjn3aK:1␤  in sub say at src/gen/CORE.setting:4957␤  in method say at src/gen/CORE.setting:620␤  in block <anon> at /tmp/vt6FGjn3aK:1␤  in <anon> at /tmp/vt6FGjn3aK:1␤…

[01:01] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&role"␤    at /tmp/Lh4KrJLJzb line 1, column 2-49␤»

[01:01] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤In parameter declaration, typename 'Mu:D' must be predeclared (or marked as declarative with :: prefix) at /tmp/6c2ZACTzcJ line 1:␤------> [32m(42 but role { method gist(Mu:D[33m⏏[31m $self:) { 69 } }).WHAT.say[0m␤␤Parse…

[01:02] <japhb> I seem to be digging the hole rather deeper

[01:03] <japhb> perl6: (42 but role { method gist(Mu:D:) { 69 } }).WHAT.say

[01:03] <p6eval> rakudo f6eb61: OUTPUT«Parameter '(null)' requires an instance, but a type object was passed␤  in method gist at /tmp/0CXhRVBcTi:1␤  in sub say at src/gen/CORE.setting:4957␤  in method say at src/gen/CORE.setting:620␤  in block <anon> at /tmp/0CXhRVBcTi:1␤  in <anon> at /tmp/0CXhRVBcTi:1…

[01:03] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤In parameter declaration, typename 'Mu:D' must be predeclared (or marked as declarative with :: prefix) at /tmp/85PkHYV6w0 line 1:␤------> [32m(42 but role { method gist(Mu:D[33m⏏[31m:) { 69 } }).WHAT.say[0m␤␤Parse faile…

[01:03] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "Mu"␤    expecting word character, "|", ":", "*", parameter name or ")"␤    at /tmp/y3uU6WgFBw line 1, column 28␤»

[01:03] <sorear> it'd be less spammy if you just used rakudo:.  pugs doesn't implement gist and niecza doesn't implement :D

[01:03] <japhb> fairy nuff

[01:04] *** kst left
[01:05] <japhb> sorear, any ideas how to say "I want to override the .gist for object instances, but not for the type"?

[01:06] *** ZapZ left
[01:07] <japhb> Because without that separation, debugging my val() implementation is a pain in the keister.

[01:08] *** colomon joined
[01:13] <sorear> japhb: in rakudo I think you can do "multi method gist(Class:D :) { ... }"

[01:13] <sorear> niecza's current idiom is self // nextsamel

[01:15] <japhb> rakudo: (42 but role { multi method gist(Mu:D:) { 69 } }).WHAT.say

[01:15] <p6eval> rakudo f6eb61: OUTPUT«Int+{<anon>}()␤»

[01:15] <japhb> \o/

[01:17] <japhb> So in all of that I think the thing I had not internalized was the unification of instance and class methods, and how that can be a pain when you are overriding a method that makes sense for both.

[01:17] <japhb> Anyway, thank you sorear++ for finding the eventual solution

[01:18] <japhb> And on that note, 

[01:18] <japhb> dinner &

[01:20] *** shabble joined
[01:28] <sorear> o/ colomon

[01:28] <colomon> \o

[01:29] <colomon> back home.  :(

[01:29] <sorear> oh?

[01:29] <sorear> what happened?

[01:29] <colomon> son with upset stomach, wife has 10am doctor's appointment for tomorrow morning.

[01:29] <colomon> I'll survive, but I was hoping for one more morning wandering the woods.

[01:30] <colomon> colors are fantastic at the moment.

[01:30] <colomon> so, I just happened to be working on the GTK stuff again

[01:30] <sorear> nom: say (method () { }).signature.perl

[01:30] <p6eval> nom f6eb61: OUTPUT«:(Mu, Mu %_)␤»

[01:31] <sorear> nom: class Pie { say (method () { }).signature.perl }

[01:31] <p6eval> nom f6eb61: OUTPUT«:(Mu, Mu %_)␤»

[01:31] <sorear> nom: class Pie { method pizza() { } }; say Pie.^find_method('pizza').signature.perl

[01:31] <p6eval> nom f6eb61: OUTPUT«:(Pie, Mu %_)␤»

[01:31] <colomon> I just figured out my TreeIter issue, I think, but ListStore.new is giving me trouble.

[01:32] <sorear> RFC

[01:32] * sorear checks how nom is implementing this

[01:32] <sorear> colomon: care to share the trouble?

[01:32] <colomon> my $store = ListStore.new(3, $G_TYPE_STRING, $G_TYPE_STRING, $G_TYPE_STRING);

[01:33] <colomon> No candidates for dispatch to CLR::Gtk::ListStore.new; candidates are:     params GLib.GType[]   &    params System.Type[]

[01:33] <sorear> what's the 3?

[01:33] <colomon> number of columns

[01:33] <colomon> errr.... though I may be completely wrong about that

[01:34] <colomon> http://www.pygtk.org/docs/pygtk/class-gtkliststore.html#constructor-gtkliststore

[01:34] <sorear> the error appears to say that there is no possibility for a System.Int32 argument

[01:34] <colomon> huh

[01:35] <colomon> does that mean the value__ (from last night) is probably unneeded?

[01:35] <sorear> probably

[01:35] <colomon> hmmm, that doesn't seem to help

[01:36] <sorear> there's no parameter to match the 3 though

[01:36] <sorear> 3 cannot be coerced to GType nor Type

[01:36] <colomon> right, I've already dumped it

[01:36] <colomon> my $store = ListStore.new($G_TYPE_STRING, $G_TYPE_STRING, $G_TYPE_STRING);

[01:36] <sorear> how is $G_TYPE_STRING set?

[01:36] <colomon> constant $G_TYPE_STRING = CLR::("GLib.TypeFundamentals,$GLIB").TypeString;

[01:38] <sorear> oh

[01:38] <sorear> GLib.TypeFundamentals.TypeString is of type TypeFundamentals

[01:38] <sorear> for the signature, you need an object of type GType

[01:38] <sorear> such as GType.String

[01:39] * sorear monop -r:/usr/local/lib/mono/gtk-sharp-2.0/glib-sharp.dll GLib.GType

[01:41] *** kst joined
[01:43] <colomon> constant $G_TYPE_STRING = CLR::("GLib.GType.String,$GLIB");  makes things blow up spectacularly.

[01:44] <sorear> CLR::("GLib.GType,$GLIB").String;

[01:44] <colomon> yay!  different error now!  :)

[01:45] <colomon> involving ListStore.Set

[01:45] *** packetkn_ joined
[01:49] *** packetknife left
[01:52] <colomon> oooo, looks like it works if I use SetValue instead.

[01:52] <colomon> or at least, it runs and doesn't give an error.  now to figure out how to use the ListStore I create.

[01:59] *** shabble left
[02:14] <sorear> colomon: any errors you want help with?

[02:14] <colomon> sorear: nope, taking a little break before I try to figure out how to convert the view creation code.

[02:18] <sorear> apparently, I've managed to make a SubInfo class with *34* attributes

[02:18] <colomon> *blink*  34?!

[02:19] <sorear> yes, writing serialization code has made me aware of just how bloated this class is...

[02:42] <colomon> sorear: goodnight.  Thanks for your help again, I'll probably have more questions in the morning.  :)

[03:04] *** daniel-s joined
[03:23] <tadzik> good day, internets

[03:29] <japhb> o/

[03:29] <japhb> rakudo: (True but role {}).say

[03:29] <p6eval> rakudo f6eb61: OUTPUT«(signal SEGV)»

[03:29] <japhb> Boo-yah.

[03:29] <japhb> Known?

[03:35] *** skangas joined
[03:36] *** jaldhar_ left
[03:36] <japhb> bug filed then

[03:38] *** envi_ joined
[03:49] <sorear> o/ tadzik

[03:49] <tadzik> hello sorear 

[03:52] *** skangas left
[03:52] *** replore_ joined
[03:56] *** jaldhar_ joined
[04:06] <moritz> good morning

[04:06] <sorear> good morning moritz!

[04:07] <tadzik> good morning

[04:17] *** satyavvd joined
[04:17] *** molaf_ left
[04:18] *** pnu left
[04:20] *** pnu joined
[04:45] *** packetkn_ left
[04:49] *** gp66 joined
[04:49] <gp66> hello

[04:52] *** skangas_ joined
[04:52] <gp66> use Net::SSH::Perl;

[04:52] <gp66> my $ssh = Net::SSH::Perl->new($host,debug=>1,use_pty=>1);

[04:53] <gp66> Name "main::pass" used only once: possible typo at Untitled2 line 17.

[04:53] <gp66> Can't locate object method "new" via package "Net::SSH::Perl" (perhaps you forgot to load "Net::SSH::Perl"?) at Untitled2 line 15.

[04:53] <gp66> error here

[04:53] <gp66>  anybody help

[04:53] <gp66> ????

[04:53] <gp66> how to run....................

[04:55] *** gp66 left
[04:56] *** gpk joined
[04:56] <gpk> hello

[04:56] <gpk> Can't locate object method "new" via package "Net::SSH::Perl" (perhaps you forgot to load "Net::SSH::Perl"?) at Untitled2 line 15.

[04:57] <gpk> Can't locate object method "new" via package "Net::SSH::Perl" (perhaps you forgot to load "Net::SSH::Perl"?) at Untitled2 line 15.

[04:57] <gpk> my $ssh = Net::SSH::Perl->new($host);   

[04:58] <gpk> antbody help

[04:58] <gpk> ????????

[04:59] <moritz> gpk: this is the wrong channel for Perl 5 help. We discuss Perl 6 here

[05:05] <gpk> i want to login to unix server using perl

[05:05] <gpk> perl 6

[05:06] <gpk> how to do this

[05:13] *** kaleem joined
[05:14] *** gpk left
[05:17] *** pnu left
[05:19] *** pnu joined
[05:20] *** beekor joined
[05:21] *** koban joined
[05:25] *** pochi left
[05:26] *** pochi joined
[05:30] *** kmwallio joined
[05:31] *** kmwallio left
[05:35] *** Sarten-X joined
[05:54] *** dual joined
[06:09] *** wtw joined
[06:10] *** envi_ left
[06:12] *** pnu left
[06:14] *** pnu joined
[06:15] *** pnu left
[06:19] *** pnu joined
[06:29] *** dual left
[06:37] *** yves_ left
[06:41] <masak> morning, #perl6

[06:41] <phenny> masak: 07 Oct 05:19Z <sorear> tell masak After a careful rereading of http://192.220.96.201/dylan/linearization-oopsla96.html , I beleive niecza is doing it right and Rakudo is only C2.  I would like to discuss how you think Niecza is getting it wrong, and add tests.

[06:41] <phenny> masak: 09 Oct 16:10Z <[Coke]> ask masak to look at RT#77184

[06:41] <masak> ooh, interesting.

[06:41] <masak> seems I need to backlog a bit. :)

[06:41] *** jkeats left
[06:41] <mberends> o/ masak

[06:41] * masak has been srsly recharging batteries in the weekend and is... a bit behind

[06:44] <moritz> \o

[06:45] *** jkeats joined
[06:52] *** sirmacik left
[06:53] *** sirmacik joined
[06:53] <sorear> MASAK!

[06:53] <sorear> o/

[06:57] *** pnu left
[06:59] *** pnu joined
[07:03] *** pnu left
[07:04] *** pnu joined
[07:06] <masak> sorear: I'll read http://192.220.96.201/dylan/linearization-oopsla96.html carefully too and get back to you during the day.

[07:07] <masak> it would be just as wonderful to get to submit a rakudobug on C3 ;)

[07:10] <masak> I see that [Coke]++ has attacked my part of the RT queue :)

[07:10] *** sirmacik left
[07:16] *** baest joined
[07:19] *** SHODAN joined
[07:20] *** mberends left
[07:26] *** wamba joined
[07:28] *** sirmacik joined
[07:28] *** sirmacik left
[07:28] *** sirmacik joined
[07:39] <moritz> is C3 linearization any different than visiting the inheritance graph in breath-first search?

[07:40] <masak> would breadth-first be monotonic?

[07:40] <masak> seems it would stumble on adding an aunt class.

[07:41] <tadzik> hi masak 

[07:41] <masak> cz tadzik 

[07:41] <masak> hm, maybe I'm imagining a case that doesn't happen.

[07:42] <moritz> what is an "aunt class"?

[07:43] <masak> the daughter class of a granny class ;)

[07:45] <masak> but I think I'm worrying too much -- a granny class isn't an ancestor.

[07:46] <masak> er, an *aunt* class isn't an ancestor, rather.

[07:47] <moritz> I just tried the grids example from the OOPSLA paper

[07:48] <moritz> rakudo allows it serialize

[07:48] <moritz> niecza says "C3-MRO wedged!"

[07:48] <masak> error message win! \o/

[07:51] *** ab5tract joined
[07:52] <moritz> all the examples of valid C3 linearizations that I've seen coincide with breadth-first search

[07:52] <moritz> (I've gone through http://www.python.org/getit/releases/2.3/mro/ right now)

[07:53] <masak> moritz: what about the nieczabug I submitted that sorear says Niecza is right on?

[07:53] <moritz> masak: got a link?

[07:53] <sorear> class A {}; class B is A {}; class C is B {}; class D is C is A {}; # D C B A (ok, contrived)

[07:53] * sorear sleep

[07:53] <masak> moritz: yes, hold on

[07:54] <masak> https://github.com/sorear/niecza/issues/65

[07:56] <moritz> rakudo: class A {}; class B is A {}; class C is B {}; class D is C is A {}; say D.^mro

[07:56] <p6eval> rakudo f6eb61: OUTPUT«D() C() B() A() Any() Mu()␤»

[07:57] <masak> that's breadth-first.

[07:57] <moritz> nope

[07:57] <masak> hm.

[07:57] <moritz> in breadth-first, A comes directly after C

[07:57] <masak> oh, right!

[07:58] <masak> yeah, it turns out that my intuition doesn't just say breadth-first.

[07:58] <moritz> sorear++ # nice example

[07:59] <masak> my intuition also says something like "ancestors after all their descendents". don't know if that's actually true, but it says that.

[07:59] <moritz> mine did, but I expect that to give D C A B for a while

[07:59] <moritz> masak: I hope it does :-)

[08:00] <masak> oh, was that trivial? maybe it was.

[08:00] <masak> anyway, that's why A can't come directly after C.

[08:00] <masak> I guess it does in Perl 5, though.

[08:00] <masak> but Perl 5 does depth-first IIRC.

[08:04] *** pnu left
[08:06] *** pnu joined
[08:08] <moritz> unless you   use mro 'c3';

[08:09] <masak> nod.

[08:09] <masak> no, I meant the language, vanilla.

[08:12] <moritz> hm, rakudo is closer to breadth first

[08:16] <masak> I've read the C3 article once now. I'm more confused than before I started reading it. :/

[08:17] <moritz> same here

[08:17] <masak> the C3 algorithm at the end looks promising for understanding things.

[08:17] <masak> but I think in order to grok this, I'd need to sit down and TDD my way through the whole thing.

[08:19] <masak> this is a new concept to me: http://en.wikipedia.org/wiki/Precedence_graph

[08:19] <masak> interesting to see it used in the context of inheritance.

[08:38] *** dakkar joined
[08:47] <masak> rakudo: say so 'aa' ~~ /(.)$1/

[08:47] <p6eval> rakudo f6eb61: OUTPUT«Bool::False␤»

[08:47] <masak> \o/

[08:47] <mls_> morning perl6!

[08:47] <masak> mls_! \o/

[08:48] <mls_> C3 problems?

[08:48] <masak> catching the above thinko at compile time sounds worthy and interesting.

[08:48] <masak> and probably not that difficult. I might give it a try at some point.

[08:48] <masak> mls_: yeah, mostly in understanding C3 ;)

[08:49] <masak> who's right here, Rakudo or Niecza? https://github.com/sorear/niecza/issues/65

[08:49] <mls_> AFAIK rakudo's c3 implementation is pretty much the one given in the paper

[08:50] <masak> then you have something to discuss with sorear++

[08:50] <mls_> uh, confusing. Does niecza have a mro method?

[08:50] <mls_> (to rule out that nextsame is broken)

[08:51] *** yves_ joined
[08:52] <masak> niecza: class A {}; say A.^mro

[08:52] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«␤Unhandled Exception: Unable to resolve method mro in class ClassHOW␤  at /tmp/G9j8G08Ydi line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2133 (CORE C1024_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2134 (CORE modul…

[08:54] <mls_> mro in rakudo also says F, D, E, B, C, A

[08:58] <mls_> Oh wait, I don't know rakudo uses the algorithm from the paper. I compared it to the python implementation

[08:58] <mls_> http://www.python.org/download/releases/2.3/mro/

[08:58] <masak> still, if the paper describes C3 and Python claims to use C3...

[08:59] <masak> that's a pretty authoritative claim that they're the same.

[08:59] <mls_> true ;)

[09:03] <mls_> Oooh, python agrees with Niecza!

[09:03] <mls_> debugging...

[09:08] <masak> mls_++

[09:08] <masak> I think there might be a blog post in here somewhere.

[09:09] <masak> rakudo: say 1 ^^ 1

[09:09] <p6eval> rakudo f6eb61: OUTPUT«Nil␤»

[09:09] <masak> should be Bool::False, right?

[09:11] *** F joined
[09:11] <masak> rakudo: role A { my $!foo; }; role B { my $!foo; }; class C does A does B {}; say 'alive'

[09:11] <p6eval> rakudo f6eb61: OUTPUT«alive␤»

[09:13] *** daniel-s left
[09:17] <mls_> regarding 1 ^^ 1: pmichaud++ added a xor_nqp PAST node to nqp to fix a parrot problem

[09:17] <mls_> xor_nqp lets you specify the return value if all args are true (as in your case)

[09:18] <mls_> so Nil is returned on purpose

[09:19] <mls_> see commit cefbda4b

[09:19] <moritz> masak: the spec previously had the "False in item context, empty list in list context" fossil

[09:23] *** Trashlord left
[09:23] * moritz wants a precdence cutoff operator

[09:24] <moritz> 1, 2 Z+ 5, 6 $ .join.say

[09:24] <moritz> where the $ basically puts parens out the previous construct

[09:24] <moritz> of course $ is probably a bad idea

[09:25] <masak> moritz++ # "fossil" spelling

[09:25] *** Trashlord joined
[09:25] <masak> moritz: you can do precedence cutoff with statement_mod given

[09:25] <masak> perl6: .join.say given 1, 2 Z+ 5, 6

[09:25] <p6eval> rakudo f6eb61, niecza v10-40-ga57ed3d: OUTPUT«68␤»

[09:25] <p6eval> ..pugs: OUTPUT«1 52 6␤»

[09:26] <moritz> troo

[09:27] <moritz> not sure it is as awesome as it could be though

[09:31] *** orafu left
[09:31] *** pnu left
[09:32] <masak> I haven't felt a strong need for it in Perl 6 so far.

[09:32] <masak> I'm used to the idea of $ working *forwards* as in Haskell, eliminating the need for parentheses.

[09:32] <masak> but we already have that with listops in Perl.

[09:32] *** pnu joined
[09:33] *** orafu joined
[09:33] <masak> the big mistake I tend to make with the Z and X metaops is forgetting that &map et al bind tighter than they do :)

[09:33] <masak> wouldn't mind a parse-time warning for that one.

[09:37] *** pnu left
[09:38] *** pnu joined
[09:40] *** ab5tract left
[09:41] *** envi_ joined
[10:00] <mls_> regarding C3: rakudo's answer is not really wrong, it just doesn't use the first merge candidate

[10:02] <mls_> the fix is pretty simple, I'm currently testing it

[10:05] <mls_> Argh, spoke too soon...

[10:07] <moritz> nom: say (1, 2, 3).flattens

[10:07] *** wamba left
[10:07] <p6eval> nom f6eb61: OUTPUT«Method 'flattens' not found for invocant of class 'Parcel'␤  in block <anon> at /tmp/iLg3wYL_NS:1␤  in <anon> at /tmp/iLg3wYL_NS:1␤»

[10:08] <moritz> nom: say (1, 2, 3).list.flattens

[10:08] <p6eval> nom f6eb61: OUTPUT«Mu()␤»

[10:08] <moritz> nom: say [1, 2, 3].flattens

[10:08] <p6eval> nom f6eb61: OUTPUT«1␤»

[10:08] <moritz> huh?

[10:08] <moritz> shouldn't that be just the other way round?

[10:11] *** lateau__ joined
[10:20] <mls_> fix for the C3 issue: https://gist.github.com/1275002

[10:24] *** sftp left
[10:26] <mls_> spectesting

[10:33] *** kaleem left
[10:34] <TiMBuS> hrm.

[10:34] <mls_> moritz: can you also do a spectest? I've git an old version of rakudo here with some uncommitted changes. Thanks!

[10:34] <TiMBuS> nom: 1, 2 Z+ 5, 6 ==> join ==> say #???

[10:34] <p6eval> nom f6eb61: OUTPUT«␤»

[10:34] <moritz> mls_: already running

[10:34] <TiMBuS> well, its not an error

[10:34] <TiMBuS> nom: 1, 2 Z+ 5, 6 ==> .join ==> say #???

[10:34] <p6eval> nom f6eb61: OUTPUT«===SORRY!===␤Sorry, do not know how to handle this case of a feed operator yet. at line 1, near " say #???"␤»

[10:40] <masak> moritz: also, why are the "truth" values returned Mu() and 1, not Bool::False and Bool::True?

[10:44] *** molaf joined
[10:45] *** wamba joined
[10:49] <masak> today's proposed topic: direct attribute access vs. accessors (where either is possible) -- pros and cons. :)

[10:49] <moritz> masak: I have no idea. Ask pmichaud 

[10:49] <moritz> masak: topic rejected

[10:49] <moritz> mls_: spectests PASS

[10:49] *** skangas_ is now known as skangas

[10:50] <masak> phenny: ask pmichaud why are the return values of .flattens not Bool::True and Bool::False?

[10:50] <phenny> masak: I'll pass that on when pmichaud is around.

[10:50] <masak> moritz: uhm? I didn't mean /topic, I meant that I'm genuinely curious what forces lie behind that choice and would like to discuss it.

[10:51] <mls_> moritz: \o/

[10:51] <moritz> masak: ah

[10:51] <mls_> afk -> lunch

[10:51] <masak> moritz: if you don't, that's fine, but rejecting the topic outright seems a bit harsh :P

[10:51] <moritz> masak: I just thought we had that discussion a few times

[10:52] <masak> we probably have.

[10:52] <moritz> use accessors when you want the virtual meaning, and the attributes for writing or for direct storage access

[10:52] <masak> the general consensus seems to be something like "accessors in methods, direct attr access in submethods".

[10:53] <flussence> I prefer "do the simplest thing that could possibly work" :)

[10:53] <masak> combined with what you said, I guess that means that methods are more "virtual" per default, and submethods decidedly aren't (because they don't inherit).

[10:53] <masak> flussence: well, doing it with accessors when you can do it with private attributes goes against YAGNI in some sense.

[10:53] <dalek> rakudo/nom: abc6874 | moritz++ | src/Perl6/Metamodel/C3MRO.pm:

[10:53] <dalek> rakudo/nom: fix c3 MRO, patch by mls++

[10:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abc6874fff

[10:53] *** F left
[10:53] <moritz> when reading an attribute, the question you have to ask is "if somebody subclasses and overwrites this, do I want the overwritten meaning?"

[10:53] <masak> flussence: but *not* preparing for being overridden seems silly as well, if you know it's going to happen.

[10:54] <masak> moritz: right.

[10:54] <moritz> if the answer is "yes", then you $.foo. Otherwise use $!foo

[10:54] <masak> it's a pretty deep decision to make. I often don't feel "ready" to make it as I write the code the first time.

[10:54] <masak> traditionally I've had $!foo as the default for flussence's reason. it's conceptually simple.

[10:55] <masak> but I'm coming around to $.foo in methods.

[10:57] *** pnu left
[10:58] <masak> moritz: when would be a case of the answer being "no"?

[10:59] *** pnu joined
[10:59] *** kaleem joined
[11:02] <moritz> masak: when your algorithms rely on the result of the access being the same as you put into the attribute

[11:06] <masak> hm.

[11:07] <moritz> and for performance reasons

[11:07] <masak> right. virtuality costs performance.

[11:07] <masak> but if *that's* an issue, maybe Perl 6 isn't an ideal choice of language for one's problem.

[11:08] <moritz> Complex and Rat use direct attribute access a lot

[11:08] <moritz> dunno if it would make sense to use the virtual accessors there

[11:09] <moritz> what would be a use case for overriding Rat.numerator?

[11:09] <masak> I consider both those immuatable objects, so for me the answer is "there isn't any".

[11:11] <moritz> you wouldn't sub Rat or Complex at all?

[11:11] <masak> think not.

[11:11] <moritz> *subclass

[11:12] <masak> would probably use composition or something if I wanted (parts of) their semantics.

[11:12] <masak> say, for an Amplitude class for making a quantum computer simulator :)

[11:12] <masak> not that I would be secretly doing something like that.

[11:14] <flussence> .oO( /me wonders if someone'll one day come to complain that Rat is named too similarly to perl5's Mouse )

[11:15] <moritz> masak: denial won't help :-)

[11:15] <masak> moritz: dang. :P

[11:16] * masak .oO( good thing I didn't let slip about my wormhole simulator too )

[11:17] <dalek> roast: ba6e5a0 | moritz++ | S (2 files):

[11:17] <dalek> roast: get rid of those passing TODO tests (rakudo)

[11:17] <dalek> roast: review: https://github.com/perl6/roast/commit/ba6e5a05c3

[11:19] <dalek> roast: 24927b5 | moritz++ | S12-class/mro.t:

[11:19] <dalek> roast: MRO tests

[11:19] <dalek> roast: review: https://github.com/perl6/roast/commit/24927b5597

[11:25] <moritz> I guess you've all seen http://www.dartlang.org/ by now..

[11:25] <masak> ooh

[11:26] <moritz> (google's JS replacement project)

[11:26] <moritz> looks like a java/javascript hybrid with gradual typing

[11:28] <masak> how exactly does it manage to have a lot of browser support already?

[11:28] <moritz> it doesn't

[11:28] <moritz> but you can (or will can) compile it to JS

[11:29] <moritz> erm, I guess "will can" isn't allowed in English, is it?

[11:29] <moritz> "will be able to"

[11:29] <masak> :)

[11:29] <masak> "can" totally should have an infinitive form in English...

[11:30] <moritz> maybe it will... :-)

[11:30] <masak> ok, so Dart sits in the same categorical slot as CoffeeScript.

[11:30] <moritz> then we shall can use it

[11:30] <masak> moritz: let's start to can right away :)

[11:31] * masak .oO( canned response )

[11:31] <moritz> masak: with the slight difference that google will push a Dart VM to chrome

[11:31] <jnthn> .oO( It's for sure that a brewery will can beer... )

[11:31] * moritz just waited for something like that

[11:32] <masak> moritz: I've seen talk about running CoffeeScript directly too.

[11:32] <masak> thought the Chrome bit is nice, of course.

[11:33] <masak> hm, String and RegExp are both a kind of Pattern...

[11:33] <masak> I must say that that interface hierarchy looks really neat.

[11:33] <moritz> masak: I still don't see them in the same category, because I think that the gradual typing will allow kick-ass performance

[11:33] * moritz wondered why Date isn't Hashable

[11:34] <masak> maybe it's mutable.

[11:34] <moritz> maybe

[11:35] <masak> moritz: time will tell. with enough distinctions, everything is in its own category. ;)

[11:35] <moritz> masak: aye :-)

[11:36] *** Gothmog_ left
[11:36] <moritz> it could be a nice target to compile Perl 6 to

[11:38] *** Patterner left
[11:38] <jnthn> More interesting than JavaScript.

[11:38] <jnthn> (From a performance perspective)

[11:38] <jnthn> (Due to the gradual typing.)

[11:39] *** y3llow left
[11:39] *** y3llow joined
[11:39] <moritz> that's what I meant :-)

[11:42] *** Psyche^ joined
[11:42] *** Psyche^ is now known as Patterner

[11:52] <dalek> nqp: fbe7f0b | mls++ | src/how/NQPClassHOW.pm:

[11:52] <dalek> nqp: backport C3 fix from rakudo

[11:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fbe7f0b076

[11:53] <mls_> (back from lunch)

[11:58] <masak> mls_++

[12:05] *** pnu left
[12:07] *** pnu joined
[12:15] *** satyavvd left
[12:19] <masak> mls_: do you know if any spectests cover the fix you made to rakudo?

[12:20] <mls_> you mean the C3 fix? motitz++ added a test

[12:20] <mls_> moritz++

[12:20] <masak> moritz++

[12:21] *** pnu left
[12:21] *** pnu joined
[12:28] <moritz> nom: say 'a' ~~ /b/

[12:28] <p6eval> nom abc687: OUTPUT«=> <>␤␤»

[12:30] <masak> nom: say ''

[12:30] <p6eval> nom abc687: OUTPUT«␤»

[12:31] <masak> why two newlines when the match fails?

[12:31] <masak> nom: print 'a' ~~ /b/

[12:31] <p6eval> nom abc687:  ( no output )

[12:31] <moritz> masak: because the way Match.gist works. I'm changing that...

[12:31] <moritz> will be #<failed match>

[12:32] <masak> ok, nice.

[12:32] <masak> that looks like Niecza's .perl syntax.

[12:32] <masak> maybe Rakudo should converge on that?

[12:32] <moritz> you should looka at the .gist of a succeeding match with a larger tree

[12:32] <moritz> masak: no, that's wrong as .perl

[12:32] <moritz> it doesn't eval back to the same object

[12:32] <masak> right.

[12:33] <moritz>  nom: say ('a' ~~ /<alpha>/).perl

[12:33] <p6eval> nom abc687: OUTPUT«Match.perl(orig => "a", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new("alpha", Match.perl(orig => "a", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new()), ))␤»

[12:33] <masak> sorear countered that Match object can't be .new'd in userspace anyway. I don't know if that's right or not.

[12:33] <moritz> why ever not?

[12:34] <masak> moritz: is that output right? it says 'Match.perl('

[12:34] <moritz> oh, should be Match.new

[12:34] <moritz> masak++

[12:34] <masak> \o/

[12:34] <masak> I don't need to submit that as a rakudobug, do I?

[12:34] <moritz> no

[12:34] *** jaldhar_ left
[12:34] <masak> then I'll skip it.

[12:37] <moritz> nom: say eval q[Match.new(orig => "a", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new("alpha", Match.perl(orig => "a", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new()), ))

[12:37] <p6eval> nom abc687: OUTPUT«===SORRY!===␤Confused at line 1, near "say eval q"␤»

[12:37] <moritz> nom: say eval q[Match.new(orig => "a", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new("alpha", Match.perl(orig => "a", from => 0, to => 1, ast => Mu, list => ().list, hash => EnumMap.new()), ))]

[12:37] <p6eval> nom abc687: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:513␤  in block <anon> at /tmp/VOZu8ESKAB:1␤  in <anon> at /tmp/VOZu8ESKAB:1␤  in sub eval at src/gen/CORE.setting:428␤  in block <anon> at /tmp/VOZu8ESKAB:1␤  in <anon> at /tmp/VOZu…

[12:37] <moritz> nom: say EnumMap.new('a', 1).perl

[12:37] <p6eval> nom abc687: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:513␤  in block <anon> at /tmp/v9w17h6bLQ:1␤  in <anon> at /tmp/v9w17h6bLQ:1␤»

[12:37] <moritz> oh

[12:37] <moritz> that's why it doesn't work

[12:37] <moritz> nom: say EnumMap.new(a => 1).perl

[12:37] <p6eval> nom abc687: OUTPUT«EnumMap.new()␤»

[12:38] <moritz> nom: say EnumMap.new(a => 1).keys

[12:38] <p6eval> nom abc687: OUTPUT«␤»

[12:38] <moritz> how does one build an EnumMap?

[12:38] <masak> what's an EnumMap? :)

[12:41] <moritz> an immutable hash

[12:43] <masak> rakudo: say Hash.new(a => 1).perl

[12:43] <p6eval> rakudo abc687: OUTPUT«().hash␤»

[12:43] <masak> well, that doesn't seem to work either.

[12:44] <moritz> for hashes you can simply use {}

[12:45] <moritz> nom: say {}.EnumMap

[12:45] <p6eval> nom abc687: OUTPUT«Method 'EnumMap' not found for invocant of class 'Hash'␤  in block <anon> at /tmp/G2YCryeN6u:1␤  in <anon> at /tmp/G2YCryeN6u:1␤»

[12:46] <masak> if an EnumMap is an ImmutableHash, that really should work :)

[12:46] <masak> by the way, EnumMap is kind of a silly name for ImmutableHash, isn't it?

[12:47] <moritz> it's the thing used in an enum

[12:47] <masak> well. that's like deciding to call Array LoopyThing

[12:48] <masak> I use enums a lot. I've never used an EnumMap in code.

[12:48] *** donri joined
[12:48] <masak> ImmutableHash would carry more recognition and suggestiveness than EnumMap does.

[12:49] <masak> also, it's kinda confusing that it's called 'Hash' (or 'Stash') in all other parts of the language, and suddenly 'Map' shows up.

[12:50] <PerlJam> Seems fairly normal to me.  A generic term to describe what it is (Hash) and a more specific term to describe how it's use (EnumMap)

[12:51] <masak> so, you're suggesting EnumMap is a kind of Hash?

[12:52] <dalek> rakudo/nom: 38907e7 | moritz++ | src/core/Match.pm:

[12:52] <dalek> rakudo/nom: improve Match.gist for failed matches. Also correct Match.perl, masak++

[12:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38907e7f56

[12:53] <PerlJam> Well ... is-ness isn't so important as does-ness these days so ...  I don't know.

[12:53] *** donri left
[12:53] *** donri joined
[12:54] <PerlJam> It's a hash by reverse duck typing in a sense :)

[12:54] <masak> PerlJam: turns out a Hash ISA EnumMap.

[12:54] <masak> rakudo: say Hash ~~ EnumMap

[12:54] <p6eval> rakudo abc687: OUTPUT«Bool::True␤»

[12:55] *** jjore joined
[12:56] *** SHODAN left
[12:56] *** donri left
[12:56] *** donri joined
[12:59] *** GlitchMr joined
[13:19] *** pnu left
[13:20] *** wooden left
[13:21] *** pnu joined
[13:26] *** pnu left
[13:27] *** pnu joined
[13:28] *** Gothmog_ joined
[13:32] *** Shozan joined
[13:33] *** am0c joined
[13:37] *** jaldhar_ joined
[13:45] *** PacoLinux joined
[13:52] *** satyavvd joined
[13:55] *** satyavvd_ joined
[13:55] *** skangas left
[13:55] *** sftp joined
[13:56] <jlaire> < masak> ok, so Dart sits in the same categorical slot as CoffeeScript.

[13:56] <jlaire> dart seems fundamentally different from js in many ways, while CoffeeScript is just syntactic sugar (and not even good sugar, imo)

[13:56] <jlaire> but if your slot are big enough, they can be in the same one :P

[13:57] *** satyavvd left
[13:57] *** satyavvd_ is now known as satyavvd

[13:58] <moritz> "programming language" is a nice slot, no? :-)

[13:58] *** skangas joined
[14:01] <masak> I meant "languages which compile down to JavaScript but provide better abstractions than JavaScript"

[14:03] <jlaire> ok. never thought about coffeescript that way

[14:04] <Shozan> is anyone at gotocon?

[14:04] <masak> jlaire: that seems to be the impetus for it. some things that should be easy and straightforward in JavaScript aren't.

[14:04] <Shozan> am i able to watch the keynote online somehow?

[14:05] *** wtw left
[14:05] <moritz> masak: example?

[14:05] *** grondilu joined
[14:05] <jlaire> well, it does provide 'class' and other similar things

[14:06] <grondilu> perl6: sub erat(Int $n) { grep none( map { $_+$_,$_+$_+$_ ...^ *>$n }, 2 .. $n ),  2 .. $n }; erat 100

[14:06] <masak> moritz: most of the examples at http://jashkenas.github.com/coffee-script/ I guess.

[14:06] <p6eval> pugs: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[14:06] <p6eval> ..rakudo 38907e, niecza v10-40-ga57ed3d:  ( no output )

[14:06] <grondilu> perl6: sub erat(Int $n) { grep none( map { $_+$_,$_+$_+$_ ...^ *>$n }, 2 .. $n ),  2 .. $n }; say erat 100

[14:06] <jlaire> but most of it is just syntax and some comparisions are a bit unfair

[14:06] <p6eval> pugs: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[14:06] <p6eval> ..rakudo 38907e, niecza v10-40-ga57ed3d: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97␤»

[14:07] <jlaire> this js: (typeof elvis !== "undefined" && elvis !== null)  should be written as  (elvis != null)

[14:07] <jlaire> that long form sure does make the 'elvis?' syntax nicer

[14:07] <masak> :)

[14:07] <jlaire> s/nicer/look nice/

[14:08] <masak> sometimes "just syntax" does matter. there's a point at which quantitative improvements become qualitative, so to speak.

[14:08] <grondilu> How do I relax raduko?

[14:08] <grondilu> s/raduko/rakudo/

[14:08] <masak> grondilu: do you mean 'no strict'?

[14:09] <grondilu> no strict doesn't work, does it?

[14:09] <masak> no, not yet.

[14:09] <masak> there doesn't seem to be a screaming demand, either. :)

[14:09] <grondilu> well, I'd like to have it.

[14:10] <grondilu> perl6: sub prefix:<°>(Int $n) { return ^($n+1) }; °10

[14:10] <jlaire> I also think CoffeeScript's implicit 'var' is a definite step backwards

[14:10] <p6eval> pugs: OUTPUT«decodeUTF8': bad data: '\176'␤decodeUTF8': bad data: '\176'␤»

[14:10] <p6eval> ..rakudo 38907e: OUTPUT«===SORRY!===␤Confused at line 1, near "\x{b0}10"␤»

[14:10] <p6eval> ..niecza v10-40-ga57ed3d:  ( no output )

[14:11] <grondilu> niecza: sub prefix:<°>(Int $n) { return ^($n+1) }; say °10

[14:11] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«0..^11␤»

[14:11] <masak> grondilu: out of curiosity, why would you like to have it?

[14:12] <grondilu> masak: because often when I want to try something I run a 'perl -e' oneliner.  I would spare some typing if I oculd skip the 'my' declarations.

[14:12] <jlaire> .oO( CoffeePerl6 )

[14:13] <jlaire> or Coffee6

[14:13] <grondilu> niecza: sub prefix:<°>(Int $n) { return ^($n+1) }; say ' '«~«°10

[14:13] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«␤Unhandled Exception: System.IndexOutOfRangeException: Array index is out of range.␤  at Lexer.Run (System.String from, Int32 pos) [0x00000] in <filename unknown>:0 ␤  at Lexer.RunDispatch (Niecza.Frame fromf, Niecza.P6any cursor) [0x00000] in <filename un…

[14:13] <grondilu> niecza: sub prefix:<°>(Int $n) { return ^($n+1) }; say ' ' «~« °10

[14:13] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 613 (CORE warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 21 (CORE Mu.Str @ 12) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/ST…

[14:13] * grondilu gives u

[14:14] <grondilu> (p)

[14:14] <masak> grondilu: ok. that seems a legitimate reason.

[14:14] <grondilu> basically a '-r' options would be nice

[14:15] <grondilu> (-r === --relax)

[14:16] <grondilu> I find quite little documentation about junctions in the synopsises.  Should I keep reading or is there a better place to look at?

[14:19] <m6locks> how much documentation you want? short intro or in-depth?

[14:19] <grondilu> in-depth.  It's quite an interesting concept and I like to understand it fully.

[14:20] <grondilu> I did read that junctions might allow parallelism in control flows.  I'd like to learn more about that too.

[14:21] *** pmurias joined
[14:21] <m6locks> have you read this? http://www.perl.com/pub/2003/07/29/exegesis6.html

[14:22] <tadzik> *yawn*, good morning

[14:23] <m6locks> good *

[14:23] <grondilu> m6locks: no.  Of course I should read the exegesis more.  Silly of me.  I'll read that.

[14:24] <jlaire> how much of that is still relevant?

[14:24] <grondilu> oh indeed 2003 is quite old

[14:26] <grondilu> Check out my erathosthene implementation:  sub erat($n) { grep none( map { $_+$_,$_+$_+$_ ...^ *>$n }, 2 .. $n ),  2 .. $n };   How would you shorten that?   :)

[14:27] <pmurias> grondilu: re -r isn't "no strict" the default in one liners?

[14:28] <[Coke]> pmurias: no strict doesn't work anywhere in rakudo.

[14:28] <[Coke]> even if that is the spec.

[14:28] <grondilu> pmurias: 'no such option -r'

[14:29] <jlaire> niecza: sub erat($n) { grep none(map { $_+$_,$_+$_+$_ ...^ *>$n }, 2 .. $n), 2 .. $n }; .say for erat(100)

[14:29] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«2␤3␤5␤7␤11␤13␤17␤19␤23␤29␤31␤37␤41␤43␤47␤53␤59␤61␤67␤71␤73␤79␤83␤89␤97␤»

[14:29] <jlaire> grondilu: cute

[14:29] <grondilu> :)

[14:29] <pmurias> [Coke]: the spec is conflicted about that

[14:30] <pmurias> [Coke]: it mentions that S01:148

[14:30] <jlaire> looks more like trial division, though

[14:30] <pmurias> s/that/in

[14:31] <pmurias> [Coke]: that -e relaxes

[14:31] <jlaire> (most haskell implementations of erathosthene's sieve are actually a different algorithm)

[14:31] <grondilu> jlaire: it's the very naive implementation of erath.  I'm sure there has to be a very elegant Perl6 implementation

[14:31] <pmurias> [Coke]: while it gives an example of a starting 6 literal turing off the strict mode in -e '6;...' 

[14:32] *** lateau__ left
[14:32] *** koban left
[14:32] *** baest left
[14:35] *** am0c left
[14:36] <GlitchMr> niecza: (1 ≠ 0).perl

[14:36] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/9BUV3eJv0p line 1:␤------> [32m(1 [33m⏏[31m≠ 0).perl[0m␤␤Parse failed␤␤»

[14:36] <GlitchMr> :(

[14:40] <grondilu> perl6: sub erat(Int $n) { grep none(2..sqrt($n).Int X* 2..$n), 2..$n }; say erat 50

[14:41] <p6eval> rakudo 38907e, niecza v10-40-ga57ed3d: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47␤»

[14:41] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "X"␤    expecting operator, ":" or ")"␤    at /tmp/sIFyufY41W line 1, column 46␤»

[14:42] <colomon> grondilu: I believe you can use the sqrt on both sides of the X*

[14:42] <grondilu> colomon: no, it wouldn't work

[14:44] <grondilu> it didn't work when I tried anyway.  I need some brain power to figure out why

[14:44] <moritz> if you check 8, 8 = 2 * 4, and 4 > 8.sqrt

[14:44] <moritz> or formulated differently, if you search for two divisors of $n, and $n is not a square, then one is always larger than $n.sqrt, and the other is always smaller

[14:45] <colomon> ah, fair enough

[14:45] <colomon> I've spent all my life reasoning on more efficient (and much less elegant) versions of the sieve, and this one hurts my brain.  :)

[14:46] <grondilu> moritz: indeed, so why doesn't this work: sub erat(Int $n) { my $r = sqrt($n).Int; grep none(2..$r X* 2..$r), 2..$n }; say erat 20

[14:46] <grondilu> ?

[14:46] <grondilu> rakudo: sub erat(Int $n) { my $r = sqrt($n).Int; grep none(2..$r X* 2..$r), 2..$n }; say erat 20

[14:46] <p6eval> rakudo 38907e: OUTPUT«2 3 5 7 10 11 13 14 15 17 18 19 20␤»

[14:47] <colomon> grondilu: it's like moritz++ says with needing one divisor less than sqrt($n) and one greater

[14:47] <grondilu> oh ok I get it now

[14:47] *** am0c joined
[14:48] <colomon> rakudo: sub erat(Int $n) { my $r = sqrt($n).Int; grep none(2..$r X* $r..$n), 2..$n }; say erat 20

[14:48] <p6eval> rakudo 38907e: OUTPUT«2 3 4 5 6 7 9 11 13 17 19␤»

[14:48] <grondilu> so indeed the sqrt can be on only one side

[14:48] <colomon> heh, that one almost works.  :)

[14:48] <grondilu> I wrote it already at 16:41

[14:48] <colomon> ah

[14:50] <grondilu> such a function could be fast if 'none' parallelizes and evaluates lazily.  I guess.

[14:50] <colomon> I don't think it reasonably can evaluate lazily

[14:51] <grondilu> I meant the 'grep', not the none.  But I'm no expert.

[14:51] <colomon> I mean, we know that * won't return results smaller than its arguments in this case, but it's asking a lot for none to know that.

[14:52] <moritz> the grep is layz, yes. But as soon as you use the list, the laziness is over

[14:52] <grondilu> true

[14:52] <colomon> all the effort goes to calculating the none expression anyway

[14:53] <moritz> which you could at least memorize

[14:53] <moritz> my Mu $matcher = none(2..$r X* $r..$n)

[14:53] <moritz> grep $matcher, 2..$n

[14:54] <colomon> you don't need to memorize it in the grep expression, do you?

[14:54] <colomon> it's not an eval, it's a single object

[14:54] <grondilu> +colomon

[14:54] * grondilu agrees to colomon 

[14:54] <grondilu> s/to/with/

[14:55] <moritz> ah right, it's not a closure

[14:55] <grondilu> the recursive version would be interesting too, anyway.

[14:56] <grondilu> colomon: I did not notice you use $r as a start for the second list.  Nice idea  :)

[14:57] <colomon> grondilu: but it doesn't actually work, so it's not that nice an idea.

[14:57] <colomon> though it will be correct for all primes greater than $n.sqrt / 2, I think, so it's *mostly* right.  :)

[14:58] <grondilu> I confess I don't understand exactly why

[15:00] *** grondilu left
[15:01] <moritz> nom: say 20.sqrt

[15:01] <p6eval> nom 38907e: OUTPUT«4.47213595499958␤»

[15:01] <moritz> how do you filter out 4?

[15:01] <moritz> 4 = 2 * 2

[15:01] <moritz> but the right list starts at 4

[15:02] <moritz> 2..$x X* 2..$n

[15:02] <jlaire> it wasn't filtered out?

[15:03] <moritz> 16:48 <+p6eval> rakudo 38907e: OUTPUT«2 3 4 5 6 7 9 11 13 17 19␤»

[15:05] <jlaire> yeah.

[15:09] *** mtk joined
[15:09] *** kaleem left
[15:10] *** Chillance joined
[15:14] *** im2ee joined
[15:16] <TimToady> nom: 1, 2 Z+ 5, 6 ==> join '' ==> say()

[15:16] <p6eval> nom 38907e: OUTPUT«68␤»

[15:20] <TimToady> TiMBuS: ^^

[15:22] *** am0c left
[15:23] *** risou_awy is now known as risou

[15:27] <TimToady> masak: note that the main beneficiary of S12:2132 is to allow $.foo to be optimized to $!foo, so there is such an optimization, you should usually write $.foo where there's any possibility of derivation, and you mean the abstract attribute

[15:28] *** bluescreen10 joined
[15:28] *** bluescreen100 joined
[15:30] <TimToady> i.e. writing $!foo for performance should probably be considered a premature optimization

[15:30] <TimToady> (eventually)

[15:31] *** Shozan left
[15:32] *** BudiantoWang joined
[15:33] *** kaare_ joined
[15:33] <BudiantoWang> helo everyone

[15:34] <TimToady> howdy

[15:35] <BudiantoWang> :) this is my first time visit

[15:35] <TimToady> how did you get here?  :)

[15:35] *** kfo_ joined
[15:35] <BudiantoWang> coincidence :D

[15:36] <TimToady> ooh, I like simple Venn diagrams

[15:36] <BudiantoWang> looking for any perl scripts to work with lpadmin in unix

[15:37] <TimToady> you're likelier to find them with Perl 5; Perl 6 is still a bit of a research project, and thin on useful code

[15:37] <TimToady> so maybe try #perl or #perlhelp

[15:38] <BudiantoWang> ah okay 

[15:38] <BudiantoWang> thanks Tim :)

[15:38] <TimToady> that's Toady... :)

[15:38] <TimToady> Tim is the other name :)

[15:39] *** kfo left
[15:39] <BudiantoWang> ah :) okay , thanks Toady

[15:39] <BudiantoWang> :) 

[15:39] *** Aridai joined
[15:45] <TimToady> sorear: why wasn't http://irclog.perlgeek.de/perl6/2011-10-10#i_4547875 a parsefail?

[15:45] <TimToady> std: sub prefix:<°>(Int $n) { return ^($n+1) }; say ' '«~«°10

[15:45] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse quote-words subscript; couldn't find right double-angle quote at /tmp/uqCKiT73rN line 1 (EOF):␤------> [32mnt $n) { return ^($n+1) }; say ' '«~«°10[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 130m␤»

[15:45] *** donri left
[15:49] <TimToady> niecza: sub prefix:<°>(Int $n) { return ^($n+1) }; say ' ' «~« °10;

[15:49] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 613 (CORE warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 21 (CORE Mu.Str @ 12) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/ST…

[15:49] <TimToady> that appears to a nieczabug

[15:50] <TimToady> niecza: sub prefix:<°>(Int $n) { return ^($n+1) }; say ' ' X~ °10;

[15:50] <p6eval> niecza v10-40-ga57ed3d: OUTPUT« 0  1  2  3  4  5  6  7  8  9  10␤»

[15:50] <TimToady> speaking of hypers, TimToady is still thinking about unary hyper policy

[15:51] *** tyatpi joined
[15:52] * TimToady wonders whether $x».foo should adopt a policy of attempting to dispatch .foo before trying to recurse, and only recurse if the dispatch to .foo fails

[15:53] <TimToady> then things like ».[0] would work as expect, but the dispatch to a tree would be a bit more duck-typed

[15:53] *** Aridai left
[15:53] <TimToady> so that in $pond».quack only the ducks would quack

[15:54] *** donri joined
[15:55] <TimToady> note that, for compact arrays of numbers, we can still optimize the heck out of it, since we'll know that all or none of the values can quack

[15:55] <TimToady> do sorear++ or jnthn++ see any problem with this?

[15:55] <TimToady> or anyone else, for that matter?

[15:57] *** envi_ left
[15:59] <moritz> perl6: say Any.[0]

[16:00] <p6eval> pugs: OUTPUT«Any␤»

[16:00] <p6eval> ..rakudo 38907e: OUTPUT«Nil␤»

[16:00] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«Any()␤»

[16:00] <PerlJam> TimToady: what happens if the .foo() calls fail at the leaves?

[16:01] <im2ee> Hello! :)

[16:01] <moritz> TimToady: I think it's not robust under addition of methods to container classes

[16:03] <moritz> if Array of Duck learns to .quack, $tree>>.quack stop quacking as it did before

[16:03] *** skangas left
[16:04] <moritz> and in general for tree traversal we should designate some mechanism to mark and recognize objects as containers that are traversible

[16:04] <moritz> (or ist that ~~ Positional|Associative ?)

[16:07] <colomon> Iterable?

[16:08] <moritz> nom: sayh Hash ~~ Iterable

[16:08] <p6eval> nom 38907e: OUTPUT«Could not find sub &sayh␤  in block <anon> at /tmp/sRmxrjXMsw:1␤  in <anon> at /tmp/sRmxrjXMsw:1␤»

[16:08] <moritz> nom: say Hash ~~ Iterable

[16:08] <p6eval> nom 38907e: OUTPUT«Bool::True␤»

[16:13] <TimToady> well, ».[0] is not robust under addition of structure :)

[16:13] <PerlJam> I just worry a little bit about heterogeneity.

[16:14] <TimToady> and I think the chances that your structure is going to get more complicated is much, much greater than the chances you're going to add a .quack to array objects

[16:14] *** pnu left
[16:15] <TimToady> PerlJam: with regard to your question, we could have those leaves return Nil or some such, and leave interpretation of that till later

[16:15] <TimToady> er, no pun intended

[16:16] <TimToady> also, the user is much more likely to be cognizant of the nature of shallow objects than deep objects

[16:16] *** pnu joined
[16:16] <TimToady> so it seems likelier to be what they're thinking to stop on first success, depthwise

[16:17] <TimToady> the method called may well wish to go deeper on its own

[16:17] <PerlJam> true

[16:18] <TimToady> the more I think about this, the righter it feels, which is a good sign...usually...

[16:19] <PerlJam> so, when you say "recurse", you're only talking about one level?

[16:19] <PerlJam> and is there still a »» op for "all the way down" ?

[16:19] *** BudiantoWang left
[16:19] <TimToady> each level makes the decision whether to quack or to look for more ducks lower down

[16:20] <TimToady> I suspect a .leafwalk would be more appropriate than »»

[16:20] <TimToady> or whatever it's called

[16:20] <TimToady> .oO(operators will happen)

[16:21] <TimToady> .leafmap, more likely

[16:22] <PerlJam> so ... the only place where this fails is when you have an aggregate with a same named method as the components and they mean different things, right?

[16:22] <TimToady> maybe a .leafgrep, that prunes away branches without matching leaves

[16:23] <TimToady> yes, though of course there are common methods like .[]

[16:24] <TimToady> but my experience meshes with want .[] at the shallow level mostly

[16:24] <TimToady> *wanting

[16:25] <TimToady> and, in fact, it's impossible to use .[] at all in the current setup

[16:27] <TimToady> but I used ».<foo> heavily in my scorekeeping program, and had to rewrite all those as .map: *.<foo> to get them to work under current rules

[16:30] <mls_> perl6: my $i; { $i++; next; $i--; }

[16:30] <p6eval> pugs: OUTPUT«*** Cannot use this control structure outside a 'loop' structure␤    at /tmp/qvRUPFPVvi line 1, column 16-20␤»

[16:30] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«␤Unhandled Exception: Illegal control operator: next␤  at /tmp/flbntEVTb3 line 1 (MAIN mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2133 (CORE C1024_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2134 (CORE module-CORE @ 58) ␤  …

[16:30] <p6eval> ..rakudo 38907e: OUTPUT«Warning␤»

[16:32] <mls_> perl6: my $i; { $i++; next; $i--; CATCH { default {} }}

[16:32] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«␤Unhandled Exception: Illegal control operator: next␤  at /tmp/4MRista9Xh line 1 (MAIN C1_ANON @ 2) ␤  at /tmp/4MRista9Xh line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2133 (CORE C1024_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CO…

[16:32] <p6eval> ..rakudo 38907e: OUTPUT«Warning␤»

[16:32] <p6eval> ..pugs: OUTPUT«*** Cannot use this control structure outside a 'loop' structure␤    at /tmp/Uj8txqEMlP line 1, column 16-20␤»

[16:33] <tadzik> Warning

[16:33] <mls_> (that warning is from the control exception being caught)

[16:33] <mls_> perl6: my $i; { $i++; next; $i--; CONTROL { default {} }}

[16:33] <p6eval> rakudo 38907e, niecza v10-40-ga57ed3d:  ( no output )

[16:33] <p6eval> ..pugs: OUTPUT«*** Cannot use this control structure outside a 'loop' structure␤    at /tmp/BdvtchLB2n line 1, column 16-20␤»

[16:34] <mls_> perl6: my $i; try { $i++; next; $i--; }

[16:34] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«␤Unhandled Exception: Illegal control operator: next␤  at /tmp/WKTSHtjGbl line 1 (MAIN C1_ANON @ 1) ␤  at /tmp/WKTSHtjGbl line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2133 (CORE C1024_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CO…

[16:34] <p6eval> ..pugs, rakudo 38907e:  ( no output )

[16:35] <mls_> (I made try {} behave like CATCH in my branch, so it doesn't catch control exceptions anymore)

[16:37] <moritz> \o/

[16:38] <pmurias> TimToady: is 'no strict' the default under -e?

[16:39] <mls_> moritz: btw your try {} return value problem seems to be already solved with the pct changes, right?

[16:39] <TimToady> pmurias: supposed to be

[16:39] <TimToady> but nobody implements no strict yet

[16:39] <moritz> mls_: yes

[16:40] <TimToady> I have discovered one potential problem with duck-typed unary hypers

[16:40] <moritz> everybody, what do you think of returning a Failure (just like fail() does) from a failed try { } block?

[16:40] <pmurias> TimToady: ok, the spec represents too different opinios so i should fix that

[16:40] <pmurias> s/too/2

[16:40] <moritz> that has the advantage of the return value not being .defined and not True either

[16:41] <TimToady> which is that composite structures respond to things like prefix:<->

[16:41] <moritz> but that $!, the actual exception, can be both

[16:41] <moritz> so you can both say

[16:41] <moritz> if not defined( try { ... }) { ... }

[16:41] <moritz> and 

[16:41] <moritz> try { ... }; if ! $! { ... }

[16:41] <moritz> *and* have all the information in the return value of try

[16:42] <TimToady> actually returning the failure means it's likely to blow up in sink context

[16:42] <TimToady> unless we make people say try {...} // nop;

[16:42] <moritz> hm, I hadn't thought of that

[16:43] <moritz> or maybe the failure is marked as handled already

[16:43] <TimToady> what about returning Nil, and leaving the info in $!

[16:44] <TimToady> we're not really trying to be bulletproof with the $! mechanism in any case

[16:44] <moritz> nom: sub f(*@a) { say @a.elems }; f 1, Nil, 2

[16:44] <TimToady> bulletproof is the bailiwick of CATCH

[16:44] <p6eval> nom 38907e: OUTPUT«2␤»

[16:47] <sorear> masak: a part of the question is how much should Match.perl print.  For instance what about .orig?

[16:47] <TimToady> it would be simpler if we can always treat Failure as unhandled, and $! as non-dangerous info

[16:47] <moritz> TimToady: yes, I agree

[16:47] * moritz retracts his proposal

[16:48] <sorear> moritz: Niecza's EnumMap is a relation with two indexes because I wanted both Int->Enum->Str and Str->Enum->Int coercion sequences to be fast

[16:48] <TimToady> such that "handling" a Failure means throwing it in the proper recepticle :)

[16:49] <TimToady> it's also a bit like Haskell's Map

[16:50] *** kaleem joined
[16:51] *** mberends joined
[16:51] <sorear> TimToady: I don't see why it should be a parsefail.  It's no different from $x + -$y, ne?

[16:51] <TimToady> it's a subscript with no trailing »

[16:52] <TimToady> looking at the non-WS case

[16:53] <TimToady> perl6: say (-«[[1,2,3],4,5]).perl

[16:53] <p6eval> rakudo 38907e: OUTPUT«([-1, -2, -3], -4, -5)␤»

[16:53] <p6eval> ..pugs: OUTPUT«decodeUTF8': bad data: '\171'␤((-1, -2, -3), -4, -5)␤»

[16:53] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«[[-1, -2, -3], -4, -5].list␤»

[16:53] <TimToady> this would break with a naïve implementation of duck hypers

[16:54] <TimToady> I wonder if there's any easy way to dispatch without Any/Cool dwimmery

[16:54] <dalek> specs: cbb7273 | moritz++ | S12-objects.pod:

[16:54] <dalek> specs: [S12] be explicit that Perl 6 uses C3 mro

[16:54] <dalek> specs: review: https://github.com/perl6/specs/commit/cbb72731f1

[16:54] <sorear> TimToady: your 1h-ago statement about ».foo's main "problem" is that it requires ».foo to be a special case - currently it compiles to something like hyperunary({ $^a.foo }, $LHS) - but this doesn't allow hyperunary to "see" the dispatch so a new ABI is needed - I don't know if this is a real problem

[16:55] <TimToady> I'm kinda turning that argument around and saying that, if the desugar is easy, the user can do it instead with .leafmap or some such

[16:55] <TimToady> and » ought to do the harder thing

[16:55] <TimToady> esp since type info lets us optimize it anyway

[16:56] *** satyavvd left
[16:57] <TimToady> one not-very-palatable way to solve the -« problem would be to say that prefixes always do .leafmap, and only postfixes do the duck mapping

[16:57] <sorear> TimToady: fwiw, "returning Nil, and leaving the info in $!" is niecza's current behavior

[16:57] <TimToady> I'd rather keep them symmetrical though

[16:57] <TimToady> which implies some way of forcing -« not to use - on an Array

[16:58] <moritz> nom: my @a = 1, 2, 3; say @a.uc

[16:58] <p6eval> nom 38907e: OUTPUT«1 2 3␤»

[16:59] <moritz> nom: say Array ~~ Cool

[16:59] <p6eval> nom 38907e: OUTPUT«Bool::True␤»

[17:00] <TimToady> possibly prefix/postfix symmetry breaking is the most practical answer

[17:00] <TimToady> otoh, +«[[1,2,3], 4,5] probably doesn't do what the user expects, if they're hoping for ».elems

[17:01] <TimToady> if we go deep on the prefixes

[17:03] *** dakkar left
[17:13] *** GlitchMr left
[17:16] *** gbacon joined
[17:19] * sorear reads the last few spec patches

[17:19] <sorear> So it's no longer possible to prime a function with Whatever?

[17:20] <TimToady> you can prime it with Whatever, but not with *

[17:21] <TimToady> :D vs :U

[17:21] <moritz> nom: say * === *

[17:21] <p6eval> nom 38907e: OUTPUT«_block1010␤»

[17:21] <TimToady> or other way around

[17:21] <sorear> niecza: say * === *

[17:21] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«{ ... }␤»

[17:21] <sorear> niecza: say (*) === (*)

[17:21] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Bool::False␤»

[17:21] <moritz> nom: say (*).WHAT

[17:21] <p6eval> nom 38907e: OUTPUT«Whatever()␤»

[17:22] <moritz> niecza: say (*).WHAT

[17:22] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Whatever()␤»

[17:22] <moritz> nom: say (*) === (*)

[17:22] <p6eval> nom 38907e: OUTPUT«_block1010␤»

[17:22] <sorear> niecza allows using extra parens to subvert (most) syntactic rewrites

[17:22] <moritz> nom: say (my $ = *) === (my $ = *)

[17:22] <p6eval> nom 38907e: OUTPUT«Bool::True␤»

[17:22] <sorear> (*) appears as a Paren node so syntactic rewrites don't apply

[17:22] <moritz> sorear: I think * should be a singleton

[17:23] <moritz> sorear: so it should be True like in rakudo

[17:23] <sorear> exception: if the interior of () is a WhateverCode, () does not create a Paren node

[17:23] <TimToady> that's kinda what I meant with :D vs :U

[17:23] <sorear> moritz: should be, yeah, but where to stash the value?

[17:24] <sorear> something like Whatever::<$INSTANCE>?

[17:26] <moritz> well, however you implement a singleton

[17:26] <sorear> fiar

[17:26] <TimToady> constant '*' of Whatever .= new;   :)

[17:26] <moritz> class Whatever { method new() { state $ = self.bless(self.CREATE) }} }

[17:26] <moritz> or something

[17:27] <sorear> what happens if you pass an existing object to bless?

[17:28] <moritz> dunno

[17:28] <moritz> I just didn't want to write self.bless(*) :-)

[17:29] <[Coke]>  -> (13:24) From Sue D. Nymme [-.-], to perl:

[17:29] <[Coke]>  - Is it petty that I want a 'sayf' command (formatted 'say'), to auto-newline

[17:29] <[Coke]>  - printf?

[17:30] <TimToady> well, given it saves only 1 character...

[17:30] <moritz> .fmt.say

[17:31] <TimToady> anyway, * feels more like a constant to me

[17:32] * TimToady has been tempted to allow the constant '@#$#' syntax

[17:33] <moritz> TimToady: thank you for resisting

[17:34] <TimToady> but it's not clear to me that * is anything other than constant '*' = Whatever.new;

[17:35] <TimToady> .oO(the simplest thing that could possibly work)

[17:35] *** risou is now known as risou_awy

[17:35] <sorear> * is syntactically special in a couple places though :)

[17:37] <TimToady> good reason for it to be a BEGIN-time entity, then :)

[17:40] <dalek> Heuristic branch merge: pushed 22 commits to rakudo/optimizer by moritz

[17:40] <TimToady> seriously, though, in thinking ahead to wanting to define unicode symbols, there are many mathematical symbols that are not alphanumeric, so I wonder whether there's a rule in definitions that can deal with parsing space-delimited terms at their point of definition

[17:40] <TimToady> in which case it would just be constant * = Whatever.new;

[17:41] <TimToady> perl6: constant term:<*> = Whatever.new;  # but we do have this, I guess

[17:41] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Colonpair traits NYI at /tmp/NRXrMWn3xD line 1:␤------> [32mconstant term:<*> [33m⏏[31m= Whatever.new;  # but we do have this, [0m␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line …

[17:41] <p6eval> ..rakudo 38907e: OUTPUT«===SORRY!===␤Cannot handle constant term with non-literal value yet at line 1, near "= Whatever"␤»

[17:41] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "<*>"␤    expecting word character, ":" or "("␤    at /tmp/AlbBNpLZwR line 1, column 15␤»

[17:42] <TimToady> but for constants, the term:<> is redundant

[17:44] *** GlitchMr joined
[17:45] <TimToady> std: sub ∰ ($x) {...}

[17:45] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/xXsR1Iu3hJ line 1:␤------> [32msub [33m⏏[31m∰ ($x) {...}[0m␤    expecting any of:␤       name␤   routine_def␤    trait␤Parse failed␤FAILED 00:01 118m␤»

[17:46] <TimToady> many folks would like such declarations to Just Work

[17:46] <TimToady> .u ∰

[17:46] <phenny> U+2230 VOLUME INTEGRAL (∰)

[17:53] <TimToady> the most elegant prime generator we have currently is probably the one at http://rosettacode.org/wiki/Count_in_factors#Perl_6

[17:54] <TimToady> though maybe we can use nested ... now

[17:54] <TimToady> also, it arguably depends on a b bug

[17:54] <TimToady> should be defined not as my @primes := but as constant @primes =

[17:55] <TimToady> in order to avoid blowing away @primes ref we're using recursively

[17:55] * [Coke] wonders if there is a rosetta code test target that makes sure all these timtoady snippets work.

[17:55] <mikemol> [Coke]: No. Not easy right now, because RC is not very programmatically readable.

[17:56] <[Coke]> TimToady: splice() not implemented in class 'Mu'

[17:56] <[Coke]> (from your URL)

[17:56] <mikemol> However, I can vouch for the Count_in_factors example working back when he revised my initial go at it.

[17:56] * mikemol really likes that prime generator

[17:56] <TimToady> and, of course 'my @primes =' doesn't work because that's eager, though I guess ...* would force it lazy in nom

[17:57] <TimToady> unfortunately, as sorear++ pointed out once, the := should change the referent of @primes, which would break it

[17:58] <TimToady> so it needs the more definitional = supplied by constant

[17:58] <TimToady> or the forced laziness of ... *

[17:59] <mikemol> However, the code on RC should be reasonably-well-formed(tm) XHTML, and you should be able to pick out any Perl6 snippets by taking the inner content of any div with a 'perl6' class and stripping out the syntax highlighting code. So, two passes against DOM manipulations.

[17:59] <TimToady> nom: my @x = 1 ... *; say @x[10]

[17:59] <p6eval> nom 38907e: OUTPUT«11␤»

[17:59] <TimToady> which works there

[17:59] <mikemol> By "code on RC", I mean "HTML-ish stuff generated by MediaWiki"

[17:59] <TimToady> so nom could do it with 'my @primes =' if the other bug weren't there

[18:01] *** benabik joined
[18:02] <sorear> mikemol: why would it not be easier to attack the database dump directly?

[18:03] <sorear> it's not like this is wikia :D

[18:03] <mikemol> sorear: Well, for starters, I'd have to make the db dump available. :)

[18:03] <mikemol> Beyond that, you'd have to parse wikicode, rather than HTML.

[18:03] <mikemol> er. Rather than XHTML.

[18:03] <mikemol> And XHTML is much, much prettier.

[18:03] <mikemol> Writing a parser for wikicode would give me nightmares.

[18:06] <mikemol> Though if you're comfortable parsing wikicode, you could grap URIs like this: http://rosettacode.org/mw/index.php?title=Count_in_factors&action=raw

[18:07] <mikemol> (Because that's what I expect you'll find in the database)

[18:07] <mikemol> As I understand it, MW keeps the latest version in wikicode, and keeps diffs between versions so you can go and view page history.

[18:09] <mikemol> Now, I recall there were committments I made in making it easier to grab code from RC. That's dependent on me getting this server migration finished, and that can't happen until I get this stupid SSL+squid+apache thing working right. :-|

[18:09] <mikemol> Anyway, I'm focusing on work again

[18:13] <mls_> afk -> home

[18:23] *** replore_ left
[18:27] <ashleydev> Any interest in upcoming talk: "Writing a compiler in Haskell and LLVM"?

[18:27] *** kmwallio joined
[18:28] <ashleydev> in Mt. View wednesday evening: http://accu.org/index.php/accu_branches/accu_usa/next

[18:28] <ashleydev> who's coming?

[18:29] <benabik> ashleydev: I'm interested but the commute's a little painful.  :-D

[18:31] <[Coke]> Mt. View... CA?

[18:38] *** tyatpi left
[18:40] <TimToady> I could walk there in about 20 minutes, but have a prior commitment, alas

[18:40] *** PacoLinux_ joined
[18:41] <moritz> masak: I'm surprised by your reply to RT #76466

[18:41] <moritz> rakudo: sub foo { my $y; our sub bar { say $y } }; bar

[18:41] <p6eval> rakudo 38907e: OUTPUT«Could not find sub &bar␤  in block <anon> at /tmp/bc6n2itWko:1␤  in <anon> at /tmp/bc6n2itWko:1␤»

[18:42] <moritz> "For what it's worth, I don't think it's incorrect behavior. Perl 6 

[18:42] <moritz> semantics *used* to find &bar in the above case, but no longer does. 

[18:42] <moritz> (This is part of a general trend of Perl 6 leaning more and more heavily 

[18:42] <moritz> on lexical scoping as a guiding principle.)"

[18:42] <moritz> ... that's why I said 'our'

[18:47] *** Holy_Cow joined
[18:48] *** Holy_Cow left
[18:48] <GlitchMr> niecza: (1 ≠ 0).perl

[18:48] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/fymEi0VEK2 line 1:␤------> [32m(1 [33m⏏[31m≠ 0).perl[0m␤␤Parse failed␤␤»

[18:49] <GlitchMr> niecza: (1 ≠ 0).perl; "€ Unicode ł force €"

[18:49] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/Lmg11PaHcM line 1:␤------> [32m(1 [33m⏏[31m≠ 0).perl; "€ Unicode ł force €"[0m␤␤Parse failed␤␤»

[18:49] <GlitchMr> Just testing if my client uses Unicode and not Windows-1252...

[18:49] <benabik> .u ≠

[18:49] <phenny> U+2260 NOT EQUAL TO (≠)

[18:49] <benabik> Seems to.

[18:51] <GlitchMr> OK, is it possible to implement ≠ as alternative to !=...?

[18:52] <GlitchMr> Silly proposal, but whatever

[18:52] <benabik> By spec, you can implement your own infix:<≠> operator, but I don't know if any implementation supports that yet.

[18:52] <GlitchMr> OK :)

[18:54] <moritz> nom: sub infix:<≠>($a, $b) { $a != $b }; say 5 ≠ 8

[18:54] <p6eval> nom 38907e: OUTPUT«===SORRY!===␤Confused at line 1, near "say 5 \u2260 8"␤»

[18:54] <moritz> b: sub infix:<≠>($a, $b) { $a != $b }; say 5 ≠ 8

[18:54] <p6eval> b 1b7dd1: OUTPUT«Bool::True␤»

[18:54] <GlitchMr> :)

[18:54] <benabik> niecza: sub infix:<≠> { $^a != $^b }

[18:54] <GlitchMr> More Unicode is always awesome.

[18:54] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Potential difficulties:␤  &infix:<≠> is declared but not used at /tmp/wyUnHLFR96 line 1:␤------> [32msub infix:<≠> [33m⏏[31m{ $^a != $^b }[0m␤␤»

[18:54] <benabik> niecza: sub infix:<≠> { $^a != $^b }; say 5 ≠ 8

[18:55] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«Bool::True␤»

[18:55] <GlitchMr> rakudo: sub infix:<≠>($a, $b) { $a != $b }; say 5 ≠ 8

[18:55] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Confused at line 1, near "say 5 \u2260 8"␤»

[18:55] <GlitchMr> .u 2AEC

[18:55] <phenny> U+2AEC DOUBLE STROKE NOT SIGN (⫬)

[18:55] <GlitchMr> .u FF62

[18:56] <phenny> U+FF62 HALFWIDTH LEFT CORNER BRACKET (｢)

[18:56] <GlitchMr> .u FF63

[18:56] <phenny> U+FF63 HALFWIDTH RIGHT CORNER BRACKET (｣)

[18:56] *** bluescreen100 left
[18:56] *** bluescreen10 left
[18:56] <GlitchMr> STD.pm is weird...

[18:56] <benabik> nom regression, but unsurprising.  nom has some parsing work to go. 

[18:56] *** bluescreen10 joined
[18:56] <benabik> GlitchMr: Howso?

[18:56] <GlitchMr> constant %open2close = (

[18:56] <GlitchMr> There is a lot of pairs

[18:56] <GlitchMr> What is point of this

[18:57] *** dual joined
[18:58] <benabik> So the parser knows what will close the current bracket.

[18:58] *** alester joined
[19:03] <GlitchMr> > <>

[19:03] <GlitchMr> Unsupported use of <>; in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list at line 1, near "<>\n"

[19:03] <GlitchMr> :(

[19:03] <GlitchMr> I liked <> abuse

[19:07] <benabik> Since we <use angle brackets for lists>, the syntax was ambiguous.

[19:08] *** cognominal left
[19:08] *** kaleem left
[19:10] *** cognominal joined
[19:14] *** mberends left
[19:15] <GlitchMr> < > is valid, huh?

[19:20] <benabik> nom: say < >.perl

[19:20] <p6eval> nom 38907e: OUTPUT«()␤»

[19:20] <benabik> Empty list

[19:21] <moritz> empty Parcel

[19:21] <benabik> nom: <foo bar baz>.WHAT.say

[19:21] <p6eval> nom 38907e: OUTPUT«Parcel()␤»

[19:21] <benabik> Huh, so it is.

[19:33] <GlitchMr> nom: my @words = <Forking is very fun thing in Perl 6>; @words».say

[19:33] <p6eval> nom 38907e: OUTPUT«6␤very␤thing␤is␤Forking␤Perl␤fun␤in␤»

[19:37] *** pnu left
[19:38] <moritz> pmichaud++

[19:42] <dalek> roast: a238bb3 | moritz++ | / (24 files):

[19:42] <dalek> roast: remove bogus test

[19:42] <dalek> roast: review: https://github.com/perl6/roast/commit/a238bb3bb7

[19:44] *** pnu joined
[19:45] *** tyatpi joined
[19:52] <[Coke]> ooh, green threads nearly ready to hit in parrot.

[19:53] * PerlJam didn't even know people were working on green threads for parrot

[19:54] <benabik> PerlJam: nine decided to update the GSoC code after whiteknight pulled out all the broken threading stuff.

[19:54] <[Coke]> basis for upcoming more awesomer thread stuff. dev says parrot & rakudo spec tests pass on his branch.

[19:56] <im2ee> Good night! :)

[19:56] <im2ee> o/

[19:56] *** im2ee left
[19:57] *** geekosaur left
[19:57] <[Coke]> nom: [+]274,448,7,-65

[19:57] <p6eval> nom 38907e:  ( no output )

[19:57] *** allbery_b joined
[19:57] <[Coke]> nom: say[+]274,448,7,-65

[19:57] <p6eval> nom 38907e: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 1␤»

[19:57] <[Coke]> nom: say [+]274,448,7,-65

[19:57] <p6eval> nom 38907e: OUTPUT«664␤»

[19:57] <[Coke]> #blah.

[19:58] *** allbery_b is now known as geekosaur

[20:01] *** GlitchMr left
[20:12] <masak> evening, #perl6.

[20:13] <[Coke]> ho, masak.

[20:14] <masak> I'm glad about the fallout of the C3 stuff.

[20:16] *** tyatpi left
[20:21] <[Coke]>  http://www.modernperlbooks.com/mt/2011/10/the-jfdi-theory-of-language-adoption.html (ties into p6 at the end.)

[20:21] <benabik> Does JFDI stand for something?

[20:22] <masak> there's this nice website called acronymfinder.com

[20:22] <benabik> Which I usually find gives too much information, as I can't provide context.

[20:23] <masak> too much information, as in the answer to your question? :P

[20:23] <masak> hate when that happens...

[20:24] *** f00li5h left
[20:25] <[Coke]> "just **** do it"

[20:35] *** skangas joined
[20:35] *** Exodist_ joined
[20:35] *** Exodist left
[20:37] <moritz> here in #perl6 we use the adaption "JDFI", Just Duckin' Foo It!

[20:41] <masak> it originated from TimToady making fun of a typo I made in a blog post.

[20:42] <moritz> TDP, Typo-driven punning

[20:42] * moritz typoes himself to sleep

[20:42] <TimToady> duck typoing...

[20:43] <masak> good nicht, moritz. dream of fortuitous typos.

[20:44] <TimToady> "Ducktor, it hurts when I do this!"  "Then don't call me a quack!"

[20:45] <[Coke]> Ugh. I'd hate to see the bill for that pun.

[20:46] <[Coke]> nom: say [+]274,448,7,-66

[20:46] <p6eval> nom 38907e: OUTPUT«663␤»

[20:46] <TimToady> .oO(or for the world wide webbed feet...)

[20:46] <TimToady> that's wrong

[20:46] <TimToady> std: say [+]274,448,7,-66

[20:46] <p6eval> std 580b69a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (listop with args requires whitespace or parens) at /tmp/NaxtJfFwrg line 1:␤------> [32msay [+][33m⏏[31m274,448,7,-66[0m␤    expecting any of:␤       POST␤   bracketed infix␤        infix or meta-infix␤    postfix␤       

[20:46] <p6eval> ..postfix_prefix_m…

[20:47] <masak> I never really understood what makes it wrong.

[20:47] <masak> kinda feels wrong to me that it's wrong.

[20:47] <masak> unless I'm wrong about that.

[20:52] <TimToady> it's an LTM thing; by including the whitespace or paren in the token, we allow user-defined functions to compete with built-ins, which typically require whitespace.

[20:52] <TimToady> it's perhaps a stronger policy than it needs to be

[20:55] <masak> feels so to me.

[20:55] <TimToady> and it arguably lets the DFA run more efficiently when we aren't in the position of failing matches because we didn't happen to find a word boundary

[20:56] <masak> I think of [+] as a \W+ listop, and as such it shouldn't need a word boundary.

[20:56] <TimToady> mostly because it feels vaguely like not require whitespace will adversely impact future extensibility.

[20:57] <TimToady> but also stylistically, if a list is going to have whitespace inside it, as it typically does, it's probably a good idea not to glue the listop to the first element of the list

[20:57] <TimToady> so on that level it's more of a Take Your Medicine It's Good For You

[20:57] *** kaare_ left
[20:57] <masak> bah, restrictions :/

[20:58] <masak> lots of people seem to have the expectation that [+]1,2,3 will work.

[20:58] <[Coke]> my @a = (1,2,3,4); @a>>.say

[20:58] <[Coke]> rakudo: my @a = (1,2,3,4); @a>>.say

[20:58] <p6eval> rakudo 38907e: OUTPUT«1␤3␤2␤4␤»

[20:58] <masak> I sometimes expect just [+] to work ;)

[20:58] <[Coke]> my @a = (1,2,3,4); @a.>>.say

[20:58] <[Coke]> rakudo: my @a = (1,2,3,4); @a.>>.say #ARGH

[20:58] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Confused at line 1, near "@a.>>.say "␤»

[20:59] <[Coke]> Should that work, btw?

[21:00] <[Coke]> if so, I'll just mark the ticket unchanged in the past 18 months.

[21:00] <[Coke]> rakudo: say $*a; my $*a = 42;

[21:00] <p6eval> rakudo 38907e: OUTPUT«Any()␤»

[21:01] * [Coke] will just mark the ticket unchanged (RT#74890)

[21:02] <[Coke]> rakudo: role R { method bar { say "bar" } }; my $foo = class { method foo { say "foo" } }; $foo does R; $foo.foo; $foo.bar

[21:02] <p6eval> rakudo 38907e: OUTPUT«(signal SEGV)»

[21:02] <[Coke]> BOOYHA

[21:03] <masak> /o\

[21:04] <[Coke]>  rakudo: class A {has @.s}; my %h='n'=><a1 a2 a3>; say  %h<n>.perl;my A $x.=new(:s(%h<n>));say $x.s.perl

[21:04] <p6eval> rakudo 38907e: OUTPUT«("a1", "a2", "a3")␤Array.new("a1", "a2", "a3")␤»

[21:04] <masak> \o/

[21:05] <[Coke]> per the ticket, that's wrong.

[21:05] <[Coke]> RT#74636 if you disagree.

[21:05] <masak> oh!

[21:05] * masak looks

[21:07] <masak> two things.

[21:07] <masak> in the original bug description, I don't see an array wrapped in another array. I see a List wrapped in an Array.

[21:08] <masak> that's probably wrong, but it doesn't feel very wrong, as Lists tend to evaporate in various circumstances.

[21:08] <masak> secondly, above I don't see any double wrapping at all.

[21:08] <masak> it's quite natural that what ends up in the @-typed attribute is an Array.

[21:09] <masak> because @-typed attributes are never Lists.

[21:09] <[Coke]> please comment on ticket and mark it as testneeded, then ;)

[21:09] <[Coke]> I am mostly just a ticket robot.

[21:09] <[Coke]> decommuting

[21:09] <masak> [Coke]++

[21:09] <masak> I'm a ticket robot too, but probably not in the same way.

[21:21] *** [Coke] left
[21:22] *** carlin left
[21:23] *** [Coke] joined
[21:36] *** wamba left
[21:45] *** pnu left
[21:47] *** pnu joined
[21:50] *** pnu left
[21:52] *** pnu joined
[21:56] <sorear> good * #perl6

[21:57] <diakopter> o/

[21:59] <masak> \o

[21:59] *** sunnavy left
[22:01] *** sunnavy joined
[22:01] *** alester left
[22:01] *** alester joined
[22:01] *** benabik left
[22:03] *** carlin joined
[22:03] <sorear> masak: fwiw, I support your drive to make whitespace rules simple.

[22:04] <colomon> sorear: do you know of any sort of a reference for Gtk in C#?  I find I'm googling Python examples and then trying to guess the translation to C# and then hack it into niecza. 

[22:05] <masak> sorear: oh wow, I had my nose much closer to the ground than that :)

[22:05] <masak> but by all means, let's make whitespace rules simple.

[22:05] <sorear> colomon: I'm mostly looking at gtk-sharp.dll (via monop) while helping

[22:08] <masak> 'night, lambda butterflies.

[22:09] <sorear> colomon: I'm tempted to try and write something ... better than monop

[22:10] *** sftp left
[22:11] *** sftp joined
[22:11] <colomon> monop is some sort of library examining tool?

[22:11] <sorear> yes

[22:12] <colomon> wow, google searches for it are really sucking for me.

[22:13] <colomon> ah, there it is

[22:13] <colomon> no, that's someone's monopoly game.  :(

[22:13] <sorear> it's part of the mono suite

[22:13] <sorear> do you have a /usr/{local/,}bin/monop?

[22:13] <colomon> yes

[22:13] <colomon> yeah, just man monop gets it for me locally

[22:14] <sorear> monop has very few useful options

[22:14] <colomon> so how would you look up Gtk.TreeView (for instance?)

[22:17] <colomon> ah, as simple as monop Gtk.TreeView  ?

[22:19] <colomon> So, Gtk.TreeViewColumn's constructor can take an "Array attrs" argument.  How would I create that in niecza?

[22:19] <colomon> though hmmm, might be unnecessary....

[22:21] <colomon> Unhandled Exception: No candidates for dispatch to CLR::Gtk::TreeViewColumn.new; candidates are:

[22:21] <colomon>     System.String, Gtk.CellRenderer, params System.Object[]

[22:22] <colomon> monop claims it has both

[22:22] <colomon> 	public TreeViewColumn (string title, CellRenderer cell, Array attrs);

[22:22] <colomon> 	public TreeViewColumn (string title, CellRenderer cell, params object [] attrs);

[22:22] <colomon> though I guess I'm trying to get away with passing nothing as the third argument.

[22:22] <diakopter> hunh; I don't know what that Array could be

[22:22] <sorear> you ought to be able to.  what are you passing to new?

[22:22] <sorear> diakopter: any array

[22:22] <sorear> diakopter: System.Array

[22:23] <diakopter> I didn't know you could do that :/

[22:23] <diakopter> or maybe I did a while ago but forgot.

[22:23] <colomon> TreeViewColumn.new($title, $renderer)

[22:23] <colomon> sorear: does a p6 Array translate to a System.Array automatically for these purposes?

[22:24] <colomon> though the CellRenderer I'm passing is actually a CellRendererText, now that I look at it.

[22:25] <sorear> colomon: no.

[22:27] *** soh_cah_toa joined
[22:27] *** replore joined
[22:29] <sorear> o/ soh_cah_toa

[22:32] <soh_cah_toa> sorear: hey

[22:32] <sorear> colomon: Array->CLR array marshalling is problematic due to mutability, so I decided not to do it until I see what people are using it *for*

[22:33] <sorear> colomon: try monop 'System.Int32[]' - this will give you the methods that are available on a typical 1-D array object

[22:33] *** pmurias left
[22:33] *** dual left
[22:33] <sorear> colomon: array classes are procedurally generated so you can't find documentation, but monop can see them since it's using reflection

[22:34] <colomon> sorear: so how does params object [] attrs translate

[22:34] <colomon> ?

[22:35] <sorear> colomon: 'params' is handled (optionally) like a slurpy.

[22:36] <colomon> ah.

[22:37] *** plobsing_ left
[22:39] *** tyatpi joined
[22:40] *** kmwallio left
[22:45] *** Trashlord left
[22:47] *** Trashlord joined
[22:47] *** replore left
[22:51] *** alester left
[22:53] *** tyatpi left
[22:57] <colomon> sorear: why does the "no candidates for dispatch" error message sometimes not list all the candidates (according to monop)?  are the others unavailable?

[23:00] <sorear> colomon: can you give an example?  I guess it might be prefiltering on arity

[23:05] <[Coke]> anyone remember how to fix "/Search/Results.html not found" on rt?

[23:06] <[Coke]> rakudo: eval 'waddle()'; say "pending: " ~ $!.pending.perl;

[23:06] <p6eval> rakudo 38907e: OUTPUT«Could not find sub &waddle␤  in block <anon> at /tmp/mjgdVtfK8o:1␤  in <anon> at /tmp/mjgdVtfK8o:1␤  in sub eval at src/gen/CORE.setting:428␤  in block <anon> at /tmp/mjgdVtfK8o:1␤  in <anon> at /tmp/mjgdVtfK8o:1␤»

[23:07] <[Coke]> rakudo: try eval 'waddle()'; say "pending: " ~ $!.pending.perl;

[23:07] <p6eval> rakudo 38907e: OUTPUT«Method 'pending' not found for invocant of class 'Exception'␤  in block <anon> at /tmp/bQT6MmUmQC:1␤  in <anon> at /tmp/bQT6MmUmQC:1␤»

[23:08] <[Coke]> rakudo: if 1 <-> $x {}

[23:08] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Missing block at line 1, near ""␤»

[23:09] * [Coke] notes that [BUG] is not appropriate when you mean [TODO].

[23:10] <[Coke]> rakudo: say %("foo" ~~ /foo/).exists("foo")

[23:10] <p6eval> rakudo 38907e: OUTPUT«Bool::False␤»

[23:12] *** whiteknight joined
[23:12] <ingy> masak: you ever get pugs working?

[23:13] <ingy> masak: I cabal installed a working copy on my laptop. needed a couple tweaks from au++, but smooth now

[23:14] <dalek> roast: 890bc5f | Coke++ | S05-match/capturing-contexts.t:

[23:14] <dalek> roast: rakudo fudging

[23:14] <dalek> roast: 

[23:14] <dalek> roast: :syntax isn't relevant to this test, so rewrite test to avoid it.

[23:14] <dalek> roast: review: https://github.com/perl6/roast/commit/890bc5fd28

[23:15] <ingy> masak: au++ thinks that on modern ghc, it can compile in < 1 min

[23:16] <[Coke]> rakudo: sub f($t?) { say defined($t).Int }; f("a" => 3)

[23:16] <p6eval> rakudo 38907e: OUTPUT«Method 'Int' not found for invocant of class 'Pair'␤  in sub f at /tmp/Szt0vkNBsZ:1␤  in block <anon> at /tmp/Szt0vkNBsZ:1␤  in <anon> at /tmp/Szt0vkNBsZ:1␤»

[23:19] *** molaf left
[23:19] <[Coke]> rakudo: my $b; $b!SomeClass::xyz

[23:19] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol SomeClass␤»

[23:21] <[Coke]> rakudo: say 9 !% 3

[23:21] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Cannot negate % because it is not iffy enough at line 1, near " 3"␤»

[23:23] <[Coke]> perl6: my $b = &time; say &$b();

[23:23] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Symbol '&time' not predeclared in <anonymous> (/tmp/dn2TAIIfgZ:1)␤»

[23:23] <p6eval> ..niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'time' used at line 1␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤…

[23:23] <p6eval> ..pugs: OUTPUT«371604200.399291␤»

[23:23] <[Coke]> std: my $b = &time; say &$b();

[23:23] <tadzik> [Coke]: time is a term, not a sub

[23:23] <p6eval> std 580b69a: OUTPUT«ok 00:01 126m␤»

[23:24] <[Coke]> tadzik: RT #74654

[23:25] <[Coke]> rakudo: my @a = 1, 2, 3; @a X*= 5; say @a.perl; @a = @a X* 5;say @a.perl;

[23:25] <p6eval> rakudo 38907e: OUTPUT«Array.new(1, 2, 3)␤splice() not implemented in class 'Mu'␤  in method reify at src/gen/CORE.setting:3657␤  in method gimme at src/gen/CORE.setting:4015␤  in method eager at src/gen/CORE.setting:3991␤  in method STORE at src/gen/CORE.setting:4409␤  in block <anon> a…

[23:25] *** soh_cah_toa left
[23:26] <[Coke]> rakudo: my $d; class A {method x { $d }}; for () { sub }

[23:26] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Missing block at line 1, near "}"␤»

[23:26] <tadzik> hrm

[23:27] <[Coke]> that one is righter. ;)

[23:27] <[Coke]> rakudo: sub s { try { return 1; CATCH { return 2 } } }; say s

[23:27] <p6eval> rakudo 38907e: OUTPUT«1␤»

[23:30] <dalek> roast: a1e114c | Coke++ | S04-exception-handlers/catch.t:

[23:30] <dalek> roast: rakudo fudging

[23:30] <dalek> roast: 

[23:30] <dalek> roast: Remove unneeded skip.

[23:30] <dalek> roast: review: https://github.com/perl6/roast/commit/a1e114c76c

[23:32] <[Coke]> rakudo: say (1..10).reduce({$^a + $^b + $^c})

[23:32] <p6eval> rakudo 38907e: OUTPUT«can only reduce with arity 2 for now␤  in method reduce at src/gen/CORE.setting:4233␤  in method reduce at src/gen/CORE.setting:1020␤  in block <anon> at /tmp/YiVJzRSHTb:1␤  in <anon> at /tmp/YiVJzRSHTb:1␤»

[23:34] *** molaf joined
[23:34] <[Coke]> masak: ping.

[23:35] <[Coke]> rakudo: class A { enum B <c d e>; ::c = B::c }; say A::c

[23:35] <p6eval> rakudo 38907e: OUTPUT«Cannot assign to a non-container␤  in <anon> at /tmp/Hw7cFnRkA1:1␤  in block <anon> at /tmp/Hw7cFnRkA1:1␤  in <anon> at /tmp/Hw7cFnRkA1:1␤»

[23:35] <[Coke]> masak: unping, just check ticket-mails.

[23:35] <[Coke]> rakudo: enum A::B <c d e>; constant B = A::B; say B::c

[23:35] <p6eval> rakudo 38907e: OUTPUT«A::B::c␤»

[23:36] <[Coke]> niecz: enum A::B <c d e>; constant B = A::B; say B::c

[23:36] <[Coke]> niecza: enum A::B <c d e>; constant B = A::B; say B::c

[23:36] <p6eval> niecza v10-40-ga57ed3d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'B::c' used at line 1␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36) ␤  a…

[23:37] <sorear> *possibly* a nieczabug

[23:37] <[Coke]> rakudo: class A { method pack($_) { s/c// }}; A.new.pack("ccc")

[23:37] <p6eval> rakudo 38907e: OUTPUT«Cannot assign to a readonly variable or a value␤  in sub infix:<=> at src/gen/CORE.setting:7361␤  in method pack at /tmp/5h1grLXx6g:1␤  in block <anon> at /tmp/5h1grLXx6g:1␤  in <anon> at /tmp/5h1grLXx6g:1␤»

[23:38] <[Coke]> rakudo: "foo$(my $x = 42)bar"; say $x

[23:39] <p6eval> rakudo 38907e: OUTPUT«===SORRY!===␤Redeclaration of symbol $x at line 1, near " = 42)bar\""␤»

[23:40] <[Coke]> rakudo: my $a = 2;$a := $a; say $a

[23:40] <p6eval> rakudo 38907e: OUTPUT«2␤»

[23:40] <[Coke]> std: my $a = 2;$a := $a; say $a

[23:40] <p6eval> std 580b69a: OUTPUT«ok 00:01 122m␤»

[23:41] <[Coke]> rakudo: my Array of Int @box

[23:41] <p6eval> rakudo 38907e:  ( no output )

[23:41] <[Coke]> rakudo: my Array of Int @box; @box[0] = 3; say @box.perl;

[23:41] <p6eval> rakudo 38907e: OUTPUT«Array.new(3)␤»

[23:55] *** icwiener joined
[23:56] *** pnu left
[23:56] *** pnu joined
[23:59] <[Coke]> rakudo: ([ [ 5], [3] ].sort: *[0] ).perl

[23:59] <p6eval> rakudo 38907e:  ( no output )

[23:59] <[Coke]> rakudo: ([ [ 5], [3] ].sort: *[0] ).perl.say

[23:59] <p6eval> rakudo 38907e: OUTPUT«([3], [5])␤»

[23:59] <[Coke]> rakudo: ([ { :pos<5>}, { :pos<4> } ].sort: *.<pos> ).perl

[23:59] <p6eval> rakudo 38907e:  ( no output )

[23:59] <[Coke]> rakudo: ([ { :pos<5>}, { :pos<4> } ].sort: *.<pos> ).perl.say

[23:59] <p6eval> rakudo 38907e: OUTPUT«({"pos" => "4"}, {"pos" => "5"})␤»

[23:59] *** replore joined
