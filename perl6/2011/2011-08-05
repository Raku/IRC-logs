[00:01] *** Moukeddar joined
[00:02] *** noganex left
[00:04] *** Moukeddar left
[00:07] *** noganex joined
[00:07] *** dorlamm left
[00:10] *** ab5tract left
[00:13] *** rdesfo left
[00:17] *** PacoLinux left
[00:29] *** nbrown left
[00:29] *** nbrown joined
[00:32] *** benabik_ joined
[00:33] *** benabik left
[00:33] *** benabik_ is now known as benabik

[00:34] <[Coke]> assymetry?

[00:34] <[Coke]> froodion slip.

[00:37] *** wolfman2000 joined
[00:42] *** silug_ left
[00:44] *** rdesfo joined
[00:52] *** shinobicl left
[01:04] *** noganex_ joined
[01:07] *** noganex left
[01:15] *** Reaganomicon left
[01:16] *** Reaganomicon joined
[01:19] *** tokuhirom left
[01:19] *** tokuhirom joined
[01:23] *** tokuhirom left
[01:26] <dalek> rakudo/nom: 0756691 | Coke++ | t/spectest.data:

[01:26] <dalek> rakudo/nom: run some fudged tests

[01:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/07566912e6

[01:26] <dalek> rakudo/nom: 57db83c | Coke++ | t/spectest.data:

[01:26] <dalek> rakudo/nom: track failure modes

[01:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/57db83c4c3

[01:26] <pmichaud> Coke++

[01:26] <[Coke]> whoops. one of those is old.

[01:27] <[Coke]> still safe, though. *whew8

[01:32] *** whiteknight left
[01:44] *** woosley joined
[02:05] *** jaldhar joined
[02:06] *** jaldhar left
[02:06] *** jaldhar joined
[02:18] <sorear> TimToady: what is the behavior of PRE { (POST @arr[$_] == $x) for ^10 } ?

[02:19] <sorear> TimToady: inside PRE, is POST an executable statement?  does it care whether it is reached in execution, or how many times?  Is POST valid in sub-blocks of PRE, or only in the PRE itself?

[02:24] <TimToady> general rule: anything UPPERCASE is not an executable statement, per se

[02:25] <TimToady> since it's not executable, there's no point in putting it more innerly than necessary, except possibly to add more lexicals around it for some reason

[02:26] <TimToady> things like my $x = BEGIN expr are a slight exception to the general rule, but by the time the = happens, the BEGIN is long gone

[02:37] <sorear> what about TEMP?  is it possible to put TEMP in a loop and queue up multiple restoration closures?

[02:39] *** silug_ joined
[02:41] <TimToady> dunno, maybe something with 'will temp' will be more apropros

[02:41] <TimToady> need to think about it

[02:54] *** Moukeddar joined
[03:01] *** ranott left
[03:02] *** mkramer1 joined
[03:15] *** colomon joined
[03:19] *** rdesfo left
[03:21] *** rdesfo joined
[03:23] *** Chillance left
[03:23] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:28] *** sili is now known as TiffanyButterfly

[03:30] *** TiffanyButterfly is now known as TiffanyBfly23

[03:33] *** TiffanyBfly23 is now known as TiffanyAngel87

[03:53] *** donri left
[04:01] *** birdwindupbird joined
[04:04] *** envi joined
[04:07] *** rdesfo left
[04:08] *** satyavvd joined
[04:23] *** odoacre joined
[04:24] *** araujo joined
[04:24] *** daemon_ is now known as daemon

[04:26] *** kaare_ joined
[04:47] *** [particle]1 joined
[04:50] *** [particle] left
[05:05] <dalek> niecza: ee90805 | sorear++ | lib/ (2 files):

[05:05] <dalek> niecza: Implement basic ENTER/LEAVE/KEEP/UNDO/PRE/POST phasers; no exception integration yet

[05:05] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ee908055ac

[05:19] *** daniel-s joined
[05:22] *** molaf_ left
[05:23] *** daniel-s_ joined
[05:24] *** daniel-s left
[05:28] *** Moukeddar left
[05:35] <dalek> niecza: 82a1cc6 | sorear++ | / (2 files):

[05:35] <dalek> niecza: Call LEAVE etc hooks during exceptional unwind

[05:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/82a1cc6e24

[05:35] <sorear> evalbot rebuild niecza

[05:35] <p6eval> OK (started asynchronously)

[05:38] *** wolfman2000 left
[05:50] <dalek> features: 62c40fa | larry++ | features.json:

[05:50] <dalek> features: add matrix exponentiation as op overload example

[05:50] <dalek> features: review: https://github.com/perl6/features/commit/62c40fa65a

[05:54] *** thou left
[05:54] <TimToady> we now have more RC pages than there were RFCs :)

[05:54] <TimToady> a milestone of sorts

[05:56] <diakopter> kewl

[05:57] <diakopter> sorear: I read through that ee90805 commit; it's truly remarkable and mysterious, yet readable

[05:57] <diakopter> I almost followed what was occuring

[05:58] <diakopter> even without knowing what all those single-letter functions do; lolz

[06:03] *** mberends left
[06:09] <sorear> ...heh, I'm not sure whether that's a complement

[06:12] <sorear> but I'm not terribly happy with the design of that part

[06:12] *** koban joined
[06:13] <sorear> the JSON parse-tree-to-op-tree converter has too many responsibilities

[06:18] *** Su-Shee_ is now known as Su-Shee

[06:21] <dalek> niecza: f755930 | sorear++ | / (2 files):

[06:21] <dalek> niecza: Fix PRE compilation, add 3 new test files

[06:21] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f7559300bc

[06:22] <dalek> roast: 7d8245f | sorear++ | S04-phasers/ (2 files):

[06:22] <dalek> roast: [S04-phasers] Fudge pre-post, enter-leave, and keep-undo for niecza

[06:22] <dalek> roast: review: https://github.com/perl6/roast/commit/7d8245f16a

[06:33] *** [particle]1 is now known as [particle]

[06:46] <sorear> TimToady: 1 for gather { ENTER { say 1 }; LEAVE { say 2 }; take 5 for ^20 }

[06:46] <sorear> TimToady: how many times is output generated?  IOW, do ENTER/LEAVE have dynamic-wind semantics?

[06:46] * sorear thinks the answer is "no" but wants to be sure

[06:49] * TimToady thinks the answer is no too

[06:49] <moritz> good morning

[06:49] <TimToady> no

[06:49] <TimToady> not morning here for another 10 minutes :)

[06:50] <sorear> dynamic-windy LEAVE would cause gather { my $fh will leave {.close} = open(...); while $fh.get { take $_ } } to fail hard

[06:52] <TimToady> we don't do take by pretending to return

[06:54] <TimToady> in fact, the run-time should feel free to put the coroutine into another thread if it thinks it can get away with it, and that it'd be beneficial

[06:55] * sorear was under the impression 'gather' guaranteed fully lazy semantics

[06:55] <TimToady> esp if it wants to work ahead and make a batch of values

[06:55] <TimToady> no, only mostly lazy

[06:59] <TimToady> we probably need a way to block when some expected input is not there yet though

[07:00] <sorear> eval('') makes a new block, right?

[07:00] <TimToady> yes

[07:00] <TimToady> we can't have it stuffing new things into the current lexical scope

[07:02] <TimToady> it's a dynamic scope as well, if you're thinking about ENTER/LEAVE

[07:03] *** kjeldahl left
[07:05] <sorear> TimToady: specifically I'm looking at tests that do my $x = 4; { eval('temp $x = 5'); is $x, 5; }; is $x, 4

[07:05] <TimToady> that's not right, I don't think

[07:06] <sorear> I'm fixing the tests

[07:08] <sorear> ...

[07:08] <sorear> temp.t contains unconditional calls to flunk.

[07:08] <sorear> And they're fudged for pugs.

[07:09] <TimToady> ...

[07:10] *** mj41 joined
[07:10] <sorear> I think temp.t is using TEMP wrong

[07:11] <sorear> TEMP adds to the *current* sub's LEAVE queue, right?

[07:11] <sorear> stack

[07:14] <TimToady> it says something about it in S06, but my eyes are going crossed

[07:16] *** SHODAN joined
[07:16] <sorear> TimToady: should temp $x invoke $x.TEMP or $x.VAR.TEMP?

[07:16] *** am0c joined
[07:17] <TimToady> well, it has to restore the variable

[07:18] *** kjeldahl joined
[07:28] <dalek> niecza: 28de0b8 | sorear++ | / (4 files):

[07:28] <dalek> niecza: Implement let, temp, TEMP

[07:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/28de0b83e5

[07:29] <dalek> roast: 0573f18 | sorear++ | S04-blocks-and-statements/ (2 files):

[07:29] <dalek> roast: [S04-blocks_and_statements/{let,temp}.t] Remove ill-placed evals and other minor fixes, fudge for Niecza

[07:29] <dalek> roast: review: https://github.com/perl6/roast/commit/0573f181fe

[07:29] <moritz> sorear++

[07:30] *** wamba joined
[07:30] <sorear> TimToady: there's another problem with the TEMP {{ ... }} syntax - the inner block is parsed as a bare block and run immediately, defeating the purpose

[07:31] <TimToady> ah well, that part of the spec was probably written by an idiot :)

[07:36] <moritz> TEMP {{ ... }} ?

[07:37] <moritz> ah

[07:39] * TimToady must sleep, and will likely wake up even stupider tomorrow...

[07:39] <TimToady> zzz &

[07:39] <sorear> night

[07:41] *** Mowah joined
[07:53] <sorear> we/I need a better spec/understanding for what happens when there are more than one pending exceptions

[07:53] <sorear> after a LEAVE dies, or in a situation with multiple fails, etc

[07:53] *** Tedd1 left
[08:02] *** timbunce joined
[08:03] * sorear -> sleep

[08:06] *** Tedd1 joined
[08:10] *** am0c left
[08:12] *** cooper joined
[08:26] *** drbean left
[08:40] <baest> does master not support things like: /(\') [<!before $0> .]* $0/? It seems like the $0 in the end works, but not the before thing

[08:41] <moritz> could be, yes

[08:42] <moritz> rakudo: say "'foo'bar'" ~~ /(\') [<!before $0> .]* $0/

[08:42] <p6eval> rakudo 922500: OUTPUT«␤»

[08:42] <moritz> rakudo: say "'foo'bar'" ~~ /(\') [<!before($0)> .]* $0/

[08:42] <p6eval> rakudo 922500: OUTPUT«Null PMC access in can()␤  in <anon> at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in 'Cool::match' at line 2684:src/gen/core.pm␤  in 'Regex::ACCEPTS' at line 6418:src/gen/core.pm␤  in main program body at line 22:/tmp/ANKLPMLJ3q␤»

[08:43] <moritz> rakudo: say "'foo'bar'" ~~ /(\') [<!"$0"> .]* $0/

[08:43] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Confused at line 22, near "say \"'foo'"␤»

[08:43] <moritz> nom: say "'foo'bar'" ~~ /(\') [<!before($0)> .]* $0/

[08:43] <p6eval> nom: OUTPUT«Method 'before' not found for invocant of class 'Cursor'␤current instr.: '_block1010' pc 470 ((file unknown):19739228) (/tmp/2rK0GbgwzC:1)␤»

[08:43] <baest> moritz: except STD do you of some grammar matching strings. I need to match several different types of strings and would like not to have to repeat myself too much

[08:44] <moritz> baest: you could try it with evil metaprogramming thingies

[08:44] <moritz> my @delimiters = <" ' !>;

[08:45] *** Mowah left
[08:45] <moritz> for @delimiters -> $d { YourGrammar.|^add_method("quote:sym<$d>", token { $d ~ $d [<!before $d> .]* } )

[08:46] <moritz> }

[08:46] <moritz> not sure if that works out at all

[08:47] <baest> nice :) Sadly I need to have support for string like $RANDOM$sdfsfsdfsd$RANDOM$, that is the user can decide what to put inside $$ as delimiter (including nothing). 

[08:48] <moritz> well, you can always go with   .*?  inbetween

[08:48] <baest> yes, that is most likely the best way right now

[08:49] <baest> moritz++ 

[08:49] <moritz> I generally don't like backtracking solutions, but given the current limitations, I think it's easiest

[08:49] *** betterworld left
[08:52] <baest> I agree

[08:52] *** im2ee joined
[09:17] *** zamolxes left
[09:22] *** zamolxes joined
[09:29] *** am0c joined
[09:32] *** ab5tract joined
[09:41] *** woosley left
[09:46] <moritz> public service announcement: the server hosting the IRC logs will go down in a few hours for a software upgrade; all its services will be unavailable for some time

[09:47] <moritz> sorry for the inconvenience

[09:47] <LoRe_> famous last words?

[09:48] <moritz> so far it has survived all upgrades :-)

[09:48] <moritz> which included one 32 bit -> 64 bit

[09:51] <tadzik> good morning

[09:54] <tadzik> oh, this is still alive: http://tjs.azalayah.net/

[09:54] <tadzik> I wonder if it's as outdated as projects.list, or more

[09:58] *** satyavvd left
[09:58] *** satyavvd joined
[10:05] *** agentzh joined
[10:07] *** MayDaniel joined
[10:12] <Woodi> hi #perl6

[10:12] <Woodi> is it still possible to register on YAPC::EU 2011 ?

[10:13] <moritz> maybe look at the website?

[10:13] <moritz> or ask the organizers if it's not on the website

[10:15] *** MayDaniel left
[10:16] *** MayDaniel joined
[10:21] <Woodi> k

[10:23] *** drbean joined
[10:30] <tadzik> nom: BEGIN { /\d/ }

[10:30] <p6eval> nom: OUTPUT«error:imcc:syntax error, unexpected DOT ('.')␤      in file '(file unknown)' line 43824002␤error:imcc:syntax error ... somewhere␤   in file '(file unknown)' line 43824038␤syntax error ... somewhere␤»

[10:31] <tadzik> nom: BEGIN { /<[0..9]>/ }

[10:31] <p6eval> nom:  ( no output )

[10:43] <tadzik> std: :16(5)

[10:43] <p6eval> std 516268a: OUTPUT«ok 00:01 118m␤»

[10:43] <tadzik> rakudo: :16(5)

[10:43] <p6eval> rakudo 922500:  ( no output )

[10:43] <tadzik> nom: :16(5)

[10:43] <p6eval> nom: OUTPUT«NYI form of number litereal encountered␤current instr.: 'nqp;Perl6;Actions;rad_number' pc 85691 (src/gen/perl6-actions.pir:30879) (src/Perl6/Actions.pm:2993)␤»

[10:45] *** timbunce left
[10:51] *** timbunce joined
[11:00] <tadzik> moritz: in the "maximum recursion depth exceeded" which occured when compiling Temporal in the setting, were you using Pod by any chance?

[11:06] <tadzik> I think the bug is in raw block handling in Pod

[11:16] *** pernatiy left
[11:18] <tadzik> nom: "     " ~~ / \N+ /

[11:18] <p6eval> nom:  ( no output )

[11:19] <tadzik> nom: say so "     " ~~ / \N+ /

[11:19] <p6eval> nom: OUTPUT«Bool::True␤»

[11:20] *** odoacre left
[11:22] <moritz> tadzik: at first, yes

[11:22] <moritz> tadzik: I then removed it, and got another error, related to role composition

[11:25] <tadzik> oh, ok

[11:26] <tadzik> I'm just fixing that one. Apparently, Pod already managed to get a few fossils of ancient thinking :)

[11:26] <tadzik> (in my implementation)

[11:33] <tadzik> fyi, I'm working on Buf

[11:40] <moritz> I hope you're not mimicking the crappy implementation from master :-)

[11:44] <moritz> jnthn, pmichaud: can I somehow pass a parrot-level object to a p6 routine?

[11:44] <moritz> I tried it with (Mu \$interp)

[11:44] <moritz> but I got Unmarshallable foreign language value passed for parameter '$interp'

[11:46] <mls_> hello perl6!

[11:47] <moritz> \o mls_ 

[11:48] <mls_> seem like pm had no time to look at my exception patch ;(

[11:48] *** satyavvd left
[11:48] *** MayDaniel left
[11:50] *** MayDaniel joined
[11:59] <mls_> I've updated the patch with a comment about the opcode: https://gist.github.com/1127381

[12:00] <mls_> How about applying it for now until we find a better solution?

[12:07] *** satyavvd joined
[12:07] <moritz> mls_: sorry, I don't feel qualified reviewing that part of exception handling, sorry

[12:10] *** pernatiy joined
[12:18] <bbkr> hi. what is the faster way now to convert bytes to ascii char (string "01010100" to char "T" for example)? pack("B", "01010100") says "B" token is not recognized.

[12:18] *** satyavvd left
[12:18] <flussence> rakudo: say chr(:2("01010100"))

[12:18] <p6eval> rakudo 922500: OUTPUT«T␤»

[12:18] <flussence> there's one way...

[12:18] <moritz> flussence++

[12:19] <bbkr> wow!

[12:19] <bbkr> thanks

[12:20] <moritz> nom: class A { has $!a; method a() { $!a } }; say A.new(a => 23).a

[12:20] <p6eval> nom: OUTPUT«Mu()␤»

[12:20] <moritz> ah

[12:21] *** daniel-s_ left
[12:22] <moritz> nom: class A { has Mu $.x }; A.new(x => pir::getinterp__P)

[12:22] <p6eval> nom: OUTPUT«Cannot assign a non-Perl 6 value to a Perl 6 container␤current instr.: '_block12668' pc 665404 (src/gen/CORE.setting.pir:168779) (src/gen/CORE.setting:429)␤»

[12:24] *** bluescreen10 joined
[12:30] *** am0c left
[12:32] *** skangas left
[12:35] *** skangas joined
[12:36] <bbkr> rakudo: say $*IN.comb(/.*/)

[12:36] <p6eval> rakudo 922500: OUTPUT«IO()<0x3e49f60>␤»

[12:37] <bbkr> why does it stringify object name instead of descriptor content? known bug?

[12:37] <moritz> NYI

[12:37] <bbkr> rakudo: say $*IN.comb(/.**4/)

[12:37] <p6eval> rakudo 922500: OUTPUT«IO()<0x4728f␤»

[12:37] <bbkr> ok

[12:37] <moritz> it's non-trivial

[12:38] <moritz> how to know how many characters to read for matching?

[12:38] *** takadonet left
[12:39] <moritz> we basically need to have a callback from the RE engine when it examines the end of the string

[12:39] <bbkr> spec says "Reads everything into a string", but I assume it's efficiency killer

[12:42] *** Woodi left
[12:42] *** Woodi joined
[12:49] *** molaf joined
[12:52] <moritz> should be easy enough to delegate IO.comb to IO.slurp.comb

[12:54] *** takadonet joined
[12:54] <takadonet> morning all

[12:55] *** am0c joined
[12:55] <moritz> brb, system upgrade

[12:57] <moritz> hm, not yet :-)

[13:00] <moritz> https://gist.github.com/1127491 # my attempts to put CallFrame back

[13:02] <jnthn> Afternoon, #perl6

[13:03] <moritz> \o jnthn 

[13:03] <jnthn> moritz: I'd really, really rather we didn't start passing non-Perl 6 objects around between functions.

[13:03] <jnthn> er, between routines

[13:04] <jnthn> morning spent in JavaScript land ;)

[13:04] <moritz> jnthn: CallFrame becomes a wee bit painful without it, but I guess I can handle

[13:04] <moritz> https://gist.github.com/1127491 is my current attempt

[13:04] *** SHODAN left
[13:04] <jnthn> lemme look :)

[13:05] <jnthn> moritz: Where were you needing to do the passing?

[13:06] <moritz> jnthn: I've eliminated it from that

[13:06] <jnthn> ok

[13:06] <jnthn> hm

[13:06] <jnthn> Did you work out why it gives the wrong line?

[13:06] <moritz> jnthn: before I used to create pir::getinterp__PP() in callframe(), and pass it on CallFrame.new

[13:06] <moritz> no, not yet

[13:07] <jnthn> Think I can see that one

[13:07] <jnthn> !annotations fetches the annotations afresh 

[13:07] <jnthn> Rather than capturing them once at callframe creation

[13:08] <jnthn> getinterp doesn't give a snapshot

[13:08] <moritz> that wasn't a problem in master, was it?

[13:08] <moritz> or maybe I didn't notice

[13:08] <jnthn> I'm guessing the latter. :)

[13:08] <moritz> is there any way to turn a p6 lexpad into a hash

[13:08] <moritz> rakudo: my $a = callframe; say $a.line

[13:08] <p6eval> rakudo 922500: OUTPUT«22␤»

[13:08] <jnthn> Mutable or immutable?

[13:09] <moritz> rakudo: my $a = callframe; say $a.line␤␤ $a.line

[13:09] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Confused at line 22, near "say $a.lin"␤»

[13:09] <moritz> immutable should be enough

[13:09] <moritz> rakudo: my $a = callframe; say $a.line; ␤␤ $a.line

[13:09] <p6eval> rakudo 922500: OUTPUT«22␤»

[13:09] <moritz> rakudo: my $a = callframe; say $a.line; ␤␤ say $a.line

[13:09] <p6eval> rakudo 922500: OUTPUT«22␤24␤»

[13:09] <moritz> ah yes, same problem in master

[13:10] <jnthn> moritz: Could always try like

[13:11] <jnthn> my $h := nqp::create(EnumMap);

[13:11] <jnthn> nqp::bindattr($h, EnumMap, '$!storage', $the_lexpad)

[13:11] <jnthn> Note, binding there matters.

[13:11] <moritz> I'll try

[13:11] <moritz> and yes, I notice that binding matters :-)

[13:14] * jnthn is relieved that $teaching_gig is done and that he's only one really serious day of $dayjob between now and YAPC :)

[13:17] *** shinobicl joined
[13:26] <mls_> back...

[13:26] <mls_> hi jnthn!

[13:27] *** Moukeddar joined
[13:27] <mls_> did you see my other patch from yesterday, the one adding "has_block_handler"?

[13:27] <Moukeddar> Hello \o

[13:28] <jnthn> hi mls_ :)

[13:28] <jnthn> mls_: Was a little distracted yesterday. 

[13:29] <mls_> no prob. Here's the patch agin: https://gist.github.com/1125226

[13:29] <jnthn> Thanks.

[13:30] <mls_> I also tried to change statement_prefix:sym<try> so that it uses a block handler instead of a try node, but couldn't make it to work

[13:31] <mls_> Currently try {} also catches CONTROL exceptions, which is IMHO wrong

[13:31] <jnthn> mls_: On line 7 did you mean CHECK?

[13:32] <mls_> You mean CATCH? No, CATCH is defined as "not CONTROL". That's what the trailing 1 does.

[13:32] <jnthn> gah, CATCH, yes

[13:33] <mls_> (it makes has_block_handler look at handle_types_except() instead of handle_types() )

[13:33] <jnthn> oh, I see.

[13:34] *** alyx left
[13:35] <jnthn> I'd have been tempted to make the third parameter a named one just so what's on line 7 of the match a little clearer :)

[13:35] <jnthn> I agree it seems to be doing the right thing.

[13:35] <mls_> I wasn't sure if nqp supports named parameters ;)

[13:36] <jnthn> Yes, it does :)

[13:36] <mls_> Please go ahead and clean up the patch...

[13:36] <jnthn> On line 81, any reason not to return?

[13:36] <jnthn> Anyway, I understand the checking part of the patch and it looks sane.

[13:36] <jnthn> Now I need to try and work out this middle part :)

[13:37] *** jedai left
[13:37] <mls_> (Regarding return: I wan't sure if return is slower that falling off the end of a function, and as there normally is just one handler...)

[13:37] <mls_> slower than

[13:38] <jnthn> Less so once we get the lexotic return in, and when we get an optimizer it'd probably be faster :)

[13:39] <mls_> The middle part is pretty simple, it's just so big because I changed the indent of some lines

[13:39] *** jedai joined
[13:39] *** tokuhirom joined
[13:40] <mls_> One thing I'm not sure about is the need of the block_closure() call

[13:40] *** Chillance joined
[13:40] *** onedirection joined
[13:40] <onedirection> hi all 

[13:41] <jnthn> mls_: Yeah, I was wondering about that too.

[13:41] <mls_> statement_prefix:sym<do> seems to work without it

[13:41] <onedirection> wondering about what?------- zayn

[13:42] <jnthn> mls_: Indeed. Guess could try removing it and seeing if tests fail. It doesn't make much sense to me.

[13:42] <mls_> in both cases?

[13:42] <onedirection> what you all going on about?--------- harry x

[13:43] <onedirection> do u know who we are guys? -----------liam

[13:43] <jnthn> mls_: Anyway, iiuc the middle part says "if we already have something that cateches the exception, don't do anything else here?

[13:43] <jnthn> onedirection: I think you're in the wrong place.

[13:44] <jnthn> onedirection: Unless you *want* to discuss Perl 6. :)

[13:44] <mls_> The middle part is: if there's a CATCH block, treat "try" as "do"

[13:44] <onedirection> where should we be? -------------harry

[13:44] <moritz> $ ./perl6 -e 'say callframe.line'

[13:44] <moritz> 1

[13:44] <moritz> $ ./perl6 -e 'my $x = 3; say callframe.my<$x>'

[13:44] <moritz> 3

[13:44] <moritz> \o/

[13:44] <jnthn> moritz: yay! :)

[13:44] *** tokuhirom left
[13:44] <mls_> |o

[13:45] <onedirection> what is perl6?-----------louis 

[13:45] *** onedirection left
[13:45] <moritz> does t/spec/S02-builtin_data_types/bool.rakudo fail for anybody else?

[13:45] <jnthn> oh, phew, I thought I was about to have to find my @ :)

[13:45] * moritz was about to

[13:45] <jnthn> mls_: Yeah, that's what I was trying to say :)

[13:45] <jnthn> mls_: It seems sensible.

[13:46] <jnthn> moritz: pulling latest 

[13:46] <jnthn> And will run a spectest.

[13:46] <moritz> anyway, gotta run, bbl

[13:49] *** drbean left
[13:49] *** stkowski joined
[13:51] * tadzik is back

[13:52] *** alyx joined
[13:52] *** alyx is now known as Guest26274

[13:53] <jnthn> Eho worked on Temporal recently?

[13:53] <tadzik> moritz: 

[13:53] <jnthn> instants-and-durations.t hangs for me during make spectest :(

[13:53] <jnthn> moritz: t\spec\S02-builtin_data_types\bool.rakudo ...................... ok

[13:53] <tadzik> 1322        moritz | tadzik: I then removed it, and got another error, related to role composition

[13:54] <jnthn> oh

[13:54] <jnthn> OK, well, either way, the test still hangs.

[13:54] <jnthn> mls_: I think that patch looks sane. Your other one, pmichaud++ should review.

[13:55] <mls_> Thanks jnthn!

[13:55] <tadzik> 3 files changed, 3 insertions(+), 26 deletions(-)

[13:55] <tadzik> I like coding that way :)

[13:56] <PerlJam> tadzik: You know you're doing something right when removing code adds functionality  :)

[13:57] <jnthn> mls_: Oddness. git apply tells me the patch is corrupt :S

[13:58] <jnthn> Just grabbed it from https://raw.github.com/gist/1125226/12493c9593ab2c93623eb74096b8d9ccbff4f46b/has_block_handler.diff and get "fatal: corrupt patch at line 5"

[13:59] *** Guest26274 left
[14:00] *** alyx_ joined
[14:00] <mls_> Probably my mistake, I manually removed the "rethrow exception" part

[14:00] <PerlJam> mls_: btw, the first if statement in has_block_handler jumps out at me that it should be a ternary op instead

[14:01] <tadzik> @anded-contents.push: 0 xx ($a.elems - @anded-contents.elems); # what is that supposed to mean?

[14:01] <mls_> It's proably easier if you reimplement it. And the code will be more perl6ish, too

[14:01] <tadzik> nom: say 0 xx "foo"

[14:01] <p6eval> nom: OUTPUT«␤»

[14:01] <tadzik> nom: say 0 xx 5

[14:01] <p6eval> nom: OUTPUT«0 0 0 0 0␤»

[14:01] <tadzik> ah

[14:02] <tadzik> I'd _really_ prefer '0' in this case

[14:02] <PerlJam> tadzik: but that would mean that +"foo" == 1 

[14:02] <mls_> PerlJam: my $ltype := pir::defined($except) ?? $_.handle_types_except() !! $_.handle_types();

[14:02] <mls_> like this?

[14:02] <PerlJam> mls_: yes

[14:03] <tadzik> PerlJam: no, I mean:

[14:03] <tadzik> nom: say '0' xx 5

[14:03] <p6eval> nom: OUTPUT«0 0 0 0 0␤»

[14:03] <tadzik> 0 xx 5 looks confusing at least

[14:03] <tadzik> nom (0 xx 5).perl.say

[14:03] <PerlJam> oh, I see

[14:03] <tadzik> nom: (0 xx 5).perl.say

[14:03] <p6eval> nom: OUTPUT«(0, 0, 0, 0, 0).list␤»

[14:04] <tadzik> oh

[14:04] <tadzik> nom: ('0' xx 5).perl.say

[14:04] <p6eval> nom: OUTPUT«("0", "0", "0", "0", "0").list␤»

[14:04] <tadzik> so there's a difference

[14:05] <PerlJam> nom:  (~0 xx 5).perl.say

[14:05] <p6eval> nom: OUTPUT«("0", "0", "0", "0", "0").list␤»

[14:05] <PerlJam> I think it's one of those "say what you mean" situations.

[14:06] *** masak joined
[14:06] <masak> sorear++ # phasers!

[14:07] *** cotto left
[14:09] *** alyx_ left
[14:09] *** kemono joined
[14:10] <tadzik> masak: is ./S03-operators/buf.t the only Buf test we have?

[14:11] <tadzik> oh, also pack and unpack

[14:11] <jnthn> I'm assuming .read and .write on IO were also tested.

[14:12] <tadzik> nom: +"5".base(16)

[14:12] <p6eval> nom: OUTPUT«Method 'base' not found for invocant of class 'Str'␤current instr.: '_block1002' pc 84 ((file unknown):35616239) (/tmp/7yu8nkN8u5:1)␤»

[14:13] <tadzik> nom: "5".Numeric.base(16)

[14:13] <p6eval> nom:  ( no output )

[14:13] <masak> tadzik: did you know that Perl 5 has something like 17e3 tests just for unpack? makes ours feel a bit wanting. :)

[14:14] <tadzik> :)

[14:14] <PerlJam> masak: someone should write a program to convert P5's unpack tests into P6  ;)

[14:14] <mls_> jnthn: should I redo the patch so that git doesn't complain? Or do you prefer to apply it manually?

[14:15] <masak> PerlJam: the thought has crossed my mind. :)

[14:15] <masak> ah; 14700: https://github.com/mirrors/perl/blob/blead/t/op/pack.t

[14:15] <masak> PerlJam: also, I don't think it's a crazy idea at all. I think it should be done.

[14:15] *** _ilbot left
[14:15] <masak> but wisely, somehow.

[14:16] <masak> it would be a little project in itself.

[14:16] <PerlJam> masak: lots of P6 ideas /are/ crazy ... but in a good way  :)

[14:16] <jnthn> mls_: If you have time, feel free to grab latest and re-diff.

[14:16] <jnthn> mls_: Looking at something else at the moment.

[14:16] <mls_> will do.

[14:16] <jnthn> thanks.

[14:16] <masak> PerlJam: ok, then it is crazy. in either a good way or a bad way :P

[14:16] <jnthn> o/ masak

[14:17] <masak> jnthn \o

[14:17] <masak> would be a cool theme for a hackathon, I think.

[14:17] <masak> "steal all of p5's pack tests"

[14:17] <jnthn> .oO( packathon )

[14:17] <masak> would raise a lot of interesting questions about how p6 wants to do pack/unpack.

[14:18] <masak> there's this unfinished idea floating around that some of what p5's pack/unpack do will be taken over by compact classes/data structures.

[14:18] *** alyx_ joined
[14:19] *** Eevee left
[14:19] *** Eevee joined
[14:20] <PerlJam> but pack/unpack could be another interface to the compact data structures too

[14:20] *** ab5tract left
[14:21] <masak> open field of research. papers welcome :P

[14:21] <moritz> now that I've seen compact classes in action, I do agree it's an interesting approach

[14:21] <jnthn> masak: That's an idea I find interesting, 'cus it intersects with NCI too :)

[14:21] <flussence> I was thinking of writing a role thingy that adds a .pack/.unpack that DWIM...

[14:21] <masak> everything, stop being so interesting! :)

[14:21] <jnthn> :P

[14:21] <jnthn> I know, it's so distracting being surrounded by interesting things. :)

[14:22] * jnthn tries to deal with another test on his triage list

[14:22] <masak> I don't even have time for the things that are distracting me nowadays...

[14:23] <tadzik> . o O ( Whatever is Cool )

[14:23] <masak> tadzik: that's a great name for a Perl 6 blog.

[14:24] <moritz> it's also false :-)

[14:24] <moritz> nom: say Whatever ~~ Cool

[14:24] <p6eval> nom: OUTPUT«Bool::True␤»

[14:24] <moritz> oh?

[14:24] <masak> moritz: so is "God Plays Dice". still a good blog. :P

[14:24] * moritz surprised

[14:24] * masak too

[14:24] * tadzik not :)

[14:24] <tadzik> I just saw it, hence I said it

[14:25] <masak> I don't see a case for it.

[14:25] <masak> it's probably a mistake.

[14:25] <tadzik> me neither

[14:25] <jnthn> rakudo: say Whatever ~~ Cool

[14:25] <p6eval> rakudo 922500: OUTPUT«Bool::False␤»

[14:25] <jnthn> Mistake, almost certainly.

[14:25] <masak> someone please spectest a removal of Whatever ~~ Cool :)

[14:25] *** _ilbot joined
[14:25] <PerlJam> then the blog will be "When Whatever was Cool"

[14:26] <tadzik> back in my days, Whatever was Cool

[14:27] *** PacoLinux joined
[14:27] <masak> or 'Whatever but Cool' :)

[14:28] <[Coke]> jnthn: mmm, javascript.

[14:29] <[Coke]> (the me from 10 years ago is very surprised to hear this, no doubt.)

[14:29] <jnthn> [Coke]: jQuery made me not hate it. :)

[14:29] <jnthn> Well

[14:29] <jnthn> I never really hated the langauge

[14:29] <jnthn> Just doing anything with it :)

[14:30] *** molaf left
[14:30] <moritz> pure JS (without jQuery) is just so wrongly huffmanized for DOM manipulation

[14:30] *** _ilbot left
[14:30] <masak> aye.

[14:30] <masak> I keep hearing good things about CoffeeScript.

[14:30] <masak> want to try it out sometime.

[14:31] <dalek> roast: 68d409b | jonathan++ | S06-multi/unpackability.t:

[14:31] <dalek> roast: Update a test to match current spec on type object stringification.

[14:31] <dalek> roast: review: https://github.com/perl6/roast/commit/68d409b912

[14:31] <jnthn> nom: multi foo(@a) { }; multi foo(*@a) { }; foo([1,2])

[14:31] <p6eval> nom: OUTPUT«Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:␤:(Positional @a)␤:(Positional @a)␤␤current instr.: 'foo' pc 481 ((file unknown):23568141) (/tmp/zbvrBDrPZu:1)␤»

[14:31] <jnthn> nom: multi foo(@a) { }; multi foo(*@a) { }; foo(1,2)

[14:31] <p6eval> nom:  ( no output )

[14:31] <jnthn> Hm

[14:31] <jnthn> wtf. 

[14:31] <jnthn> I saw the code last night that was meant to make the non-slurpy one narrower...

[14:31] *** jedai left
[14:32] <PerlJam> jnthn: but does it ever get executed?  :)

[14:32] <masak> guess that code wasn't convincing enough.

[14:32] <jnthn> PerlJam: At some point, though maybe not in that case :P

[14:33] <jnthn> oh, I wonder...

[14:33] <[Coke]> jnthn: (jquery) exactly.

[14:33] <moritz> maybe the nom build is out of date

[14:33] <flussence> (I think the over-wordiness of DOM manipulation is mostly the W3C's fault, not javascript itself)

[14:33] <jnthn> moritz: no, mine just finished

[14:33] <[Coke]> my biggest problem with coffee is that I have to add tools to my build to make it work.

[14:33] <jnthn> moritz: And I can reproduce here too

[14:33] <moritz> jnthn: I mean the one on p6eval 

[14:33] <moritz> ok

[14:34] *** _ilbot joined
[14:34] <[Coke]> (and i have lots of other developers to deal with.)

[14:35] <tadzik> Whatever but Cool. It's just me who doesn't have a fancy blag name? Now I do

[14:35] <jnthn> oh, short answer is we don't reach that code. Reason is...involved

[14:36] <tadzik> Could not find sub &postfix:<++>

[14:36] <tadzik> ...what

[14:38] <tadzik> did I just break circularity?

[14:39] <jnthn> tadzik: No, you probably just use ++ before it was defined

[14:39] <jnthn> Well, that is circularity issue I guess

[14:39] <tadzik> hmm

[14:42] <jnthn> how'd you hit it?

[14:43] <tadzik> adding encode to Str

[14:43] <tadzik> it doesn't use ++, no

[14:43] <jnthn> oddness

[14:44] * masak .oO( when all you have is a circularity saw, everything looks like a strange loop )

[14:44] <jnthn> Grr. This narrowness analysis code would be really simple if we didn't want to have our cake and eat it when it comes to optionals and slurpies. :)

[14:45] <masak> jnthn: you're saying that, as an implementor, you're feeling tortured on behalf of the user? :)

[14:45] <jnthn> masak: I fear that once in a while we'll torture a user too.

[14:46] *** birdwindupbird left
[14:46] *** koban left
[14:46] <jnthn> masak: It's all find until the DWIM doesn't. :)

[14:46] <masak> the "too clever" syndrome in software.

[14:47] <jnthn> That's kinda my fear.

[14:47] <masak> jnthn: do you have an example of this?

[14:47] <jnthn> I'm reading rules I implemented and I don't understand them :P

[14:47] <PerlJam> That's why it's the educator's job to introduce the user to that "aha" moment where it all just makes sense.

[14:48] <jnthn> masak: Well, the reason the example I tried out above doesn't work is because at the moment the code considers any two things with different minimum arity to be tied.

[14:50] <moritz> IRC logs going down in 2 minutes, hope it'll back up soonish

[14:50] <masak> that can't be the only rule. a :() is tighter than a :(*@a)

[14:50] *** cosimo joined
[14:51] <jnthn> masak: In that case they have the same minimum arity

[14:51] <jnthn> masak: So we fall through to another rule.

[14:51] <jnthn> Which does what you described.

[14:52] *** _ilbot left
[14:53] <masak> ah.

[14:54] <masak> sorry, I misread what you wrote...

[14:56] <tadzik> jnthn: oddness: the lack of postfix:<++> appear After the setting is compiled, when compiling Test.pm

[14:57] *** jaldhar left
[14:58] *** donri joined
[14:58] <tadzik> in method REIFY

[14:59] <jnthn> WTF.

[15:00] <tadzik> patch?

[15:00] <jnthn> ?

[15:00] <tadzik> want a patch?

[15:00] <tadzik> I sticked Buf.pm between Stringy.pm and Str.pm in Makefile.oin

[15:01] <sorear> good * #perl6

[15:01] <tadzik> hello sorear 

[15:01] <jnthn> tadzik: Which REIFY, ooc?

[15:01] <jnthn> tadzik: wait, while *compiling* Test.pm?

[15:01] <tadzik> method REIFY(Parcel \$parcel)

[15:01] <tadzik> yes

[15:02] <tadzik> # From src/core/Array.pm

[15:02] <jnthn> I can see it uses ++

[15:02] <tadzik> and it's Str.encode added who broke it

[15:02] <jnthn> OK, I want to see the patch :)

[15:02] <tadzik> I'll push it to a branch, ok?

[15:03] <jnthn> ok

[15:03] <Moukeddar> masak, :)

[15:03] <Moukeddar> Hi Sir

[15:04] <dalek> rakudo/nom: 03125c3 | jonathan++ | src/Perl6/Actions.pm:

[15:04] <dalek> rakudo/nom: Refactor handling of nested signatures so taht in a routine the parameters in them default to Any, not Mu.

[15:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/03125c30bf

[15:04] <tadzik> jnthn: pushed to nom-buf

[15:04] <masak> Moukeddar: hi there, sir.

[15:05] <Moukeddar> how are you doing?

[15:05] <Moukeddar> and what's cooking?

[15:05] <tadzik> nom :P

[15:05] <masak> Moukeddar: going to a curry place tonight. nothing cooking. :)

[15:05] <Moukeddar> lazy dev :)

[15:05] <dalek> rakudo/nom-buf: 59a91b9 | tadzik++ | src/Perl6/ (3 files):

[15:05] <dalek> rakudo/nom-buf: Cleanup raw block handling in Pod, remove some old-thinking fossils

[15:05] <dalek> rakudo/nom-buf: review: https://github.com/rakudo/rakudo/commit/59a91b9a10

[15:05] <dalek> rakudo/nom-buf: 86b601f | tadzik++ | / (4 files):

[15:05] <dalek> rakudo/nom-buf: Import Buf.pm, add Str.encode. Compiles the setting, breaks on Test.pm

[15:05] <dalek> rakudo/nom-buf: review: https://github.com/rakudo/rakudo/commit/86b601f1d5

[15:07] <TimToady> is the irclog down?

[15:07] <masak> can we say whatever we want with no consequences whatsoever?

[15:07] <masak> :)

[15:07] <Moukeddar> masak, we're celebrating Ramadan here :)

[15:08] <masak> Moukeddar: oh, right!

[15:08] <jnthn> TimToady: yes

[15:08] <tadzik> TimToady: yes

[15:08] <jnthn> TimToady: Server maint

[15:08] <masak> Moukeddar: it started on Monday, I think.

[15:08] <Moukeddar> tuesday for us

[15:08] <jnthn> TimToady: Make spec suggestions that you want to be able to deny later now. :P

[15:08] <masak> Moukeddar: but you're in Morocco, so sunset comes quite early for you :P

[15:08] <Moukeddar> 7:25-30 pm :)

[15:09] <Moukeddar> not early

[15:09] <dalek> rakudo/nom: 0773b30 | tadzik++ | src/Perl6/ (3 files):

[15:09] <dalek> rakudo/nom: Cleanup raw block handling in Pod, remove some old-thinking fossils

[15:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0773b3067f

[15:09] <Moukeddar> dawn is 3:55 am

[15:09] <jnthn> Moukeddar: Heh. I know a friend here in Sweden who is fasting and it's after 9pm here. :)

[15:09] <Moukeddar> 15 hrs :)

[15:10] *** bluescreen10 left
[15:10] <tadzik> oopsie, I commited stuff twice

[15:10] <jnthn> tadzik: Don't worry, it'll git sorted out :)

[15:10] *** thou joined
[15:10] *** bluescreen10 joined
[15:11] <tadzik> :P

[15:11] <Moukeddar> good Pun

[15:11] <jnthn> I make them occasionally. :)

[15:12] <masak> I hadn't noticed.

[15:12] <mls_> jnthn: new version of the patch: https://gist.github.com/1127740

[15:13] *** mj41 left
[15:13] <tadzik> masak: I assume you're talking about the 'occasionally' part :)

[15:14] <Moukeddar> it's a really good one :)

[15:14] <Moukeddar> i Salute you Sir

[15:15] *** wooden joined
[15:15] <masak> tadzik: heh :)

[15:15] <masak> Moukeddar: how's the coding going? learned anything new lately?

[15:16] <Moukeddar> masak, going quite good, learned better use of generics :)

[15:16] <masak> sounds nice.

[15:16] *** Trashlord left
[15:16] <Moukeddar> and never never use premature optimization

[15:16] <Moukeddar> it just adds unnecessary complexity

[15:17] <masak> :P

[15:17] <masak> it's hard to resist, is all :)

[15:17] <Moukeddar> oh, and  : Use a goddamn source control 

[15:17] *** Trashlord joined
[15:19] <masak> indeed.

[15:20] <masak> rakudo: role FactoryJoke[$type] { method make { say "Help, I'm trapped inside a $type factory!" } }; FactoryJoke["role"].new.make

[15:20] <p6eval> rakudo 922500: OUTPUT«Help, I'm trapped inside a role factory!␤»

[15:20] <Moukeddar> the good thing is i'm learning :)

[15:20] <masak> Moukeddar: I'm glad.

[15:20] <masak> you seem to be doing well, too!

[15:21] <jnthn> mls_: applied cleanly

[15:21] <Moukeddar> and many thanks go to you, Sir

[15:21] <masak> Moukeddar: I think coding katas would suit you well. you might want to look them up.

[15:22] *** bluescreen10 left
[15:22] <Moukeddar> like martial arts?

[15:22] <masak> that's the analogy, yes.

[15:22] <masak> "practice makes perfect"

[15:23] <mls_> jnthn: good. I used :except like you said, and also fixed a bug (I needed to use $block<past_block> instead of $block)

[15:24] <mls_> Hmm, instants-and-durations.t hangs...

[15:25] <mls_> nom: now

[15:25] <p6eval> nom:  ( no output )

[15:25] <Moukeddar> masak, another interesting site

[15:25] <Moukeddar> challengine problems:)

[15:25] <mls_> ./perl6 -e 'now' hangs for me...

[15:25] <masak> Moukeddar: yup :)

[15:25] <masak> mls_: how poetic.

[15:26] <masak> mls_: perhaps it's a Long Now :P

[15:27] *** PacoLinux__ joined
[15:27] *** PacoLinux left
[15:27] *** PacoLinux__ is now known as PacoLinux

[15:27] *** s1n left
[15:30] *** s1n joined
[15:30] <jnthn> mls_: That's not your patch, I don't think.

[15:30] <jnthn> It hangs for me too.

[15:30] <jnthn> Even without your patch

[15:30] <jnthn> :(

[15:31] <pmichaud> good morning, #perl6

[15:31] <jnthn> got mor...no, it's evening already here!

[15:31] <jnthn> o/ pmichaud 

[15:31] <masak> o/ pmichaud 

[15:31] <mls_> Hi pmichaud!

[15:31] <masak> this slide from an old-but-good-presentation http://web.archive.org/web/20080907185122/http://prometheus.frii.com/~gnat/yapc/2000-stages/slide13.html feels odd from a Perl 6 perspective...

[15:32] <mls_> It seems to loop... method Num(Int:D:) is involved.

[15:32] <mls_> from class Int

[15:33] <Moukeddar> masak, i'm making a video to demonstrate Dependency Injection adn IoC :)

[15:34] <Moukeddar> and*

[15:34] *** bluescreen10 joined
[15:36] <dalek> rakudo/nom: 29a3568 | jonathan++ | src/binder/multidispatch.c:

[15:36] <dalek> rakudo/nom: Try to be a bit smarter about slurpy in the narrowness analysis in multi-dispatch.

[15:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/29a3568afc

[15:36] <dalek> rakudo/nom: ba477df | jonathan++ | t/spectest.data:

[15:36] <dalek> rakudo/nom: We now pass S06-multi/unpackability.t.

[15:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba477dfc65

[15:36] <masak> Moukeddar: you do seem to prefer the architectural patterns :)

[15:36] <jnthn> nom: my @a = 2, 3, 4, 5; say @a.Capture.WHAT

[15:36] <p6eval> nom: OUTPUT«Capture()␤»

[15:36] <masak> Moukeddar: IoC is a very wide and general topic. DI is just a small fraction of that.

[15:36] <jnthn> nom: my @a = 2, 3, 4, 5; say @a[0..2].Capture.WHAT

[15:36] <p6eval> nom: OUTPUT«Parcel()␤»

[15:37] <jnthn> WHAT?!

[15:37] <Moukeddar> i just love those topics, i wish i can study them 

[15:37] <pmichaud> Might need to remove Parcel.Capture

[15:37] <mls_> (afk for a while...)

[15:37] *** mls_ left
[15:37] <Moukeddar> IoC is wide, agreed, but one must know the principle at least

[15:38] <masak> Moukeddar: http://c2.com/cgi/wiki?HollywoodPrinciple is an example of IoC that is not DI.

[15:39] <jnthn> pmichaud: too cheaty :)

[15:39] <masak> though on the page they say that it's often called DI. I'm not sure I agree.

[15:39] <jnthn> pmichaud: Gotta head out now

[15:39] <pmichaud> jnthn: okay

[15:39] *** im2ee left
[15:39] <jnthn> pmichaud: I'll spectest a patch for that. Also mls++'s patch

[15:39] <jnthn> pmichaud: Note, the one that forbids duplicate CATCH/CONTROL

[15:40] <pmichaud> jnthn: okay

[15:40] <jnthn> pmichaud: I won't touch the opcode-adding one until you've reviewed it.

[15:40] <pmichaud> I didn't see the point of the opcode.

[15:40] <Moukeddar> masak, interesting, i need to understand that term of Container

[15:40] *** im2ee joined
[15:40] <Moukeddar> is it like dependency resolver?

[15:41] <pmichaud> (maybe the patch has changed since I last looked at it)

[15:42] <pmichaud> ENOIRCLOG?

[15:42] <TimToady> down for maint

[15:42] <pmichaud> okay, thanks.

[15:42] <pmichaud> I guess I could've looked that up in the ircl.... oh.

[15:42] <TimToady> I did a quick scan with irssi but missed the announcement

[15:43] <TimToady> so I asked too :)

[15:43] <masak> Moukeddar: to me, "DI Container" is .NET (or possibly Java) term.

[15:43] <masak> Moukeddar: I usually do DI by hand, without a dedicated Container.

[15:43] <Moukeddar> that's what i do too

[15:43] <Moukeddar> but having a tool that do that work at runtime for you

[15:43] <Moukeddar> is tempting

[15:44] <masak> Moukeddar: this seems to summarize it: http://tutorials.jenkov.com/dependency-injection/dependency-injection-containers.html

[15:44] <jnthn> masak: I don't think it needs to be a .Net or Java term.

[15:44] <jnthn> masak: I think there's such things for Perl too.

[15:44] <TimToady> maybe someone should add an RC task for that

[15:44] <masak> jnthn: oh, ok.

[15:44] <masak> still, I don't tend to use it.

[15:44] <Moukeddar> masak, http://salaty.codeplex.com/SourceControl/list/changesets this is the library

[15:45] <Moukeddar> i'm trying to imply what i learn there

[15:49] <masak> oh, so that's how CodePlex looks.

[15:49] <Moukeddar> yes :)

[15:49] <Moukeddar> look at the latest changeset

[15:49] <masak> Moukeddar: we need Windows people around. too few of them in the Open Source world.

[15:50] <Moukeddar> i had a hard time chosing a license type :p

[15:51] <Moukeddar> i'll buy  a new HDD, then install OpenSuse 

[15:51] <Moukeddar> i need to port this to Perl :)

[15:52] <TimToady> "Lifecycle of Singletons" sounds an awful lot like what people want RAII for...

[15:53] <TimToady> a DI Container sounds a lot like a transaction manager

[15:53] <TimToady> in the "knowing when we're done" sense, not the commit/rollback sense

[15:54] * jnthn afk

[15:54] <TimToady> I'm still wondering how we can make transactions more natural in P6 other than throwing a dynamic scope at each transaction

[15:54] <TimToady> well, maybe that *is* the natural way, but DI implies the dynamic scope is "held" somewhere else

[15:55] <masak> maybe approaching from the other direction is easier. with these syntactic/semantic features, write something transactional in Perl 6 that feels natural.

[15:55] <TimToady> we kinda have that notion already with the way gather/take can spawn off a dynamic scope that keeps spitting out values after the official return

[15:56] <masak> yes.

[15:56] <TimToady> actually, gather has two official returns :)

[15:56] <masak> sort of greenthread-ish.

[15:57] <TimToady> the first when it returns the lazy list, and the second when the lazy list completes

[15:57] <TimToady> the outer return and the inner return, as it were

[15:57] <TimToady> and that's the answer to when LEAVE fires off

[15:58] <Moukeddar> http://imgs.xkcd.com/comics/good_code.png

[15:58] <TimToady> outside gather, LEAVE fires on the first return; inside on the last return

[15:58] <dalek> rakudo/nom: a596b54 | pmichaud++ | NOMMAP.markdown:

[15:58] <dalek> rakudo/nom: Add another punchlist item to NOMMAP.

[15:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a596b54295

[15:59] *** PacoLinux left
[16:00] <masak> Moukeddar: bit of a false dichotomy, I think.

[16:01] <TimToady> however, that's a problem for using LEAVE to close a file that is opened outside a gather

[16:01] <masak> Moukeddar: with tests, I can go fast/right, and then asymptotically converge on maintainable.

[16:01] <Moukeddar> TDD?

[16:01] <masak> Moukeddar: oh yes.

[16:02] <masak> gotta go. curry with jnthn :)

[16:02] <Moukeddar> you seem to be a big Fan :)

[16:02] *** masak left
[16:02] <Moukeddar> yep, he is ;)

[16:02] *** PacoLinux joined
[16:02] * TimToady wonders what kind of rock masak++ is testing...

[16:04] <Moukeddar> bazalt probably 

[16:04] <TimToady> you may thinks it's gneiss, but I take it for granite...

[16:05] <Moukeddar> one more type and i'll have another Geology crysis  Episode

[16:06] <TimToady> you don't have to start feeling all sedimental over it

[16:07] *** agentzh left
[16:07] <Moukeddar> Good Pun, sir

[16:08] <TimToady> "Good Pun" is a contradiction, I'm told

[16:09] <Moukeddar> how so?

[16:09] <TimToady> puns are all bad

[16:09] <TimToady> even the good ones are bad

[16:09] <Moukeddar> no, they're good

[16:09] <pmichaud> at least, the good puns are all bad :)

[16:10] <Moukeddar> mind Asploded

[16:13] *** crked joined
[16:13] <Moukeddar> They're Good

[16:13] <Moukeddar> that's it

[16:14] <crked> Is there something wrong with the Rakudo website now? I cannot access it.

[16:15] *** crked left
[16:16] *** cotto joined
[16:16] <pmichaud> rakudo.org is working for me

[16:19] *** kaare_ left
[16:21] *** Moukeddar_ joined
[16:23] *** PacoLinux left
[16:23] <TimToady> maybe we need a way to attach a LEAVEish thing to the end of a lazy list as it's being returned

[16:24] <TimToady> so we can say "close this file when you hit the end of the list"

[16:24] * TimToady will think about this in the shower

[16:24] <Moukeddar_> talking about obsessions

[16:25] <Moukeddar_> how about solving problems while sleeping?

[16:25] *** Moukeddar left
[16:28] *** Moukeddar_ is now known as Moukeddar

[16:30] *** molaf joined
[16:33] *** alester joined
[16:36] <dalek> rakudo/nom: 3bfa2cf | pmichaud++ | src/ (2 files):

[16:36] <dalek> rakudo/nom: Add hyper method dispatch, stub in hyper infix generation.

[16:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3bfa2cf8fa

[16:47] *** pernatiy left
[16:48] *** rdesfo joined
[16:51] <sorear> good * #perl6

[16:51] *** stkowski left
[16:52] <sorear> phenny: tell moritz I have irc logs right now.  Can we inject stuff into ilbot's database, for the sake of people browsing the logs in five years' time?

[16:52] <phenny> sorear: I'll pass that on when moritz is around.

[16:53] *** Moukeddar left
[16:53] <sorear> TimToady: doesn't the contend { } block make a dynamic scope?

[16:54] <PerlJam> sorear: I just noticed that you haven't updated features with your phasers changes.  Was that intentional?

[16:54] <sorear> PerlJam: I was expecting someone else to do it, didn't want to race

[16:54] <sorear> I'll do it now.

[16:55] <PerlJam> oh, okay

[16:55] <PerlJam> sorear++

[16:55] <sorear> TimToady: Why does niecza have ± for PROCESS et al?

[16:57] <dalek> features: 0aecd5d | sorear++ | features.json:

[16:57] <dalek> features: Update ENTER/PRE data points for niecza

[16:57] <dalek> features: review: https://github.com/perl6/features/commit/0aecd5d67b

[17:03] *** mls_ joined
[17:03] *** cooper left
[17:03] <mls_> back...

[17:04] <mls_> irclog.perlgeek.de is still down?

[17:05] <sorear> hey mls_

[17:06] <sorear> niecza: try { die 5; LEAVE { say "left!" } }

[17:06] <p6eval> niecza v8-37-g28de0b8: OUTPUT«left!␤»

[17:06] <mls_> \o/

[17:07] <mls_> I currently have no clue how to implement that in parrot

[17:07] <mls_> (I should say: without patching parrot)

[17:08] <pmichaud> do you know to do it with patching parrot?

[17:08] <pmichaud> that would be significant :)

[17:10] * [Coke] has an evil thought.

[17:10] <mls_> well, we have access to the call chain over the continuation

[17:10] <[Coke]> we could have --gen-parrot not only grab a specific version of parrot but patch it in situ.

[17:10] <pmichaud> what about in the case of exceptions?

[17:10] <mls_> I'm talking about the exception case

[17:10] <pmichaud> ah

[17:11] <mls_> so we need a way to get to the LEAVE block from the call ctx

[17:11] <pmichaud> seeing a prototype working in a patched parrot would be really useful.

[17:13] <mls_> Well, I'm on vacation for the next two weeks with no internet access, so I can only help with it after I'm back

[17:13] *** sshc left
[17:14] <pmichaud> that would be fine

[17:14] *** colomon left
[17:15] <[Coke]> mls_++

[17:15] <mls_> Ok, maybe I've some good while I'm relaxing on the beach ;)

[17:15] <mls_> ideas

[17:15] <sorear> I don't know about you, but I find Intenet outages extremely helpful for deep focussed hacking.

[17:16] <mls_> yes, no distracting code ;)

[17:16] <[Coke]> ... if I have everything git fetch'd before I leave, yes. otherwise, it's verrrry frustrating. ;)

[17:17] <pmichaud> afk, lunch and errands

[17:17] <mls_> pmichaud: did you already look at my exception patch?

[17:17] <mls_> too late...

[17:17] <pmichaud> mls_: I didn't have a link to it.

[17:18] <mls_> and the irclog is gone... Let's see if I can find it on gist.githup

[17:19] *** cooper joined
[17:19] *** cooper left
[17:19] *** cooper joined
[17:20] <pmichaud> can you just re-post it to gist?

[17:22] <pmichaud> nom: say 'hello'

[17:22] <p6eval> nom: OUTPUT«"load_bytecode" couldn't find file 'CORE.setting.pbc'␤current instr.: 'nqp;Perl6;ModuleLoader;_block1142' pc 2995 (src/gen/perl6-moduleloader.pir:1203) (src/Perl6/ModuleLoader.pm:127)␤»

[17:22] <pmichaud> :(

[17:22] <mls_> I fear not, I have it at work, and I can' access the pc right now

[17:22] <pmichaud> okay, I'll look when someone can send me the patch.  :)

[17:23] <pmichaud> afk, lunch

[17:24] <pmichaud> (if someone can look into why nom isn't building for p6eval, that'd be great.  kthxbye)

[17:26] *** cooper left
[17:29] <mls_> maybe jnthn has it in his browser history

[17:31] *** [Coke] left
[17:32] *** [Coke] joined
[17:35] <TimToady> https://gist.github.com/1124942 ?

[17:35] <TimToady> https://gist.github.com/1125226 ?

[17:36] *** cosimo left
[17:36] <TimToady> the first, probably

[17:36] <sorear> TimToady: after try { throws_two_exceptions; } what is the type and contents of $! ?

[17:37] <sorear> TimToady: is there a syntax for throwing multiple exceptions?

[17:37] <TimToady> $! is not the main star of the show anymore

[17:38] <TimToady> S04:1024

[17:39] *** cooper joined
[17:39] <TimToady> $! only links to the last thrown exception, and no longer tracks all unhandled exceptions

[17:39] *** cooper left
[17:39] *** cooper joined
[17:39] <TimToady> last failure, rather

[17:40] <TimToady> $! has almost nothing to do with throwing anymore

[17:40] <sorear> after 'try' there are no unhandled exceptions

[17:41] <sorear> after 'try' finishes, are the exception(s) that try ate visible anywhere?

[17:42] <TimToady> maybe @! is visible along with $! at that point

[17:43] <sorear> is @! automatically declared in every Routine?

[17:43] <TimToady> if so, $! would just be an alias to its head or tail

[17:45] <sorear> perhaps it could be the other way around, the exceptions could be hidden in $! somewhere and @! an alias

[17:45] <TimToady> or, horrors, $! is an any(@!)  :)

[17:45] <mls_> https://gist.github.com/1124942 works TimToady++

[17:45] <TimToady> but I'm a bit leary of mixing the handler @! notion with the $! notion

[17:46] * sorear wants to allow die()ing with a Set or Array of exceptions somehow

[17:46] <TimToady> people should really be using handlers, not testing stuff after try

[17:46] <sorear> TimToady: I am leary of the mixing too

[17:46] <mls_> I just added some comments today and renamed the op to rethrow_skipnextctx

[17:46] <TimToady> maybe try only catches one exception, and rethrows if there are multiple

[17:46] <sorear> I think that we should at least make try { ... }; note $! if $!;  DTRT

[17:47] <sorear> or something similar to that

[17:47] <TimToady> which would still presumably work if try catches a single exception

[17:48] <sorear> I have a lot of code like if (try do_something) { ... }

[17:48] <TimToady> actually, I think my @undead already has those semantics

[17:49] <TimToady> the SIMPLECATCH will just propagate those by bypassing the @! loop

[17:49] <sorear> usually, with try I don't care about the exact details of the exception thrown, but I do care 1. that all exceptions are caught 2. that I can know if an exception occurred 3. that I can dump the exceptions for debugging

[17:51] <TimToady> well, maybe fail just sets $! to one exception, but try sets $! to a super-exception when there are multiple, but generally I think try is intended to catch a particular exception that the user has in mind

[17:52] <TimToady> of course, in that case you should still probably write an explicit CATCH

[17:53] <TimToady> since a single exception might be the "wrong" one

[17:55] <TimToady> maybe a good middle ground is to return a $! handled exception when there's only one, but make $! an unhandled failure if there are multiple, so it blows up if you don't treat it right

[17:56] <TimToady> except, of course, that such a try is likely to be in a sink context, and blow up immediately

[17:57] <sorear> usually with try my code doesn't care what exceptions there are, only "did it work?"

[17:57] <sorear> imagine a long-running server thing

[17:58] <sorear> loop { try iterate; note $! if $! }

[17:58] <sorear> it would be *very bad* if 'try' only caught one exception

[17:58] <sorear> because it would seem to work, as long as iterate throws singly

[17:58] <sorear> but as soon as the user gets a double fault, the app crashes

[17:58] <sorear> not good

[17:59] <sorear> I'd like to find a way without such traps

[18:00] <TimToady> nodnod, it's a useful invariant

[18:01] *** [Coke] left
[18:03] *** [Coke] joined
[18:03] <TimToady> the SIMPLECATCH code distinguishes multiple exceptions thrown from within the try from extra exceptions thrown while trying to CATCH

[18:03] <TimToady> it's only the latter which are propagated outward automatically

[18:04] <TimToady> and I think that's what most languages do, if there's an exception in the CATCH code

[18:04] <TimToady> but for try, we have a canned CATCH that presumably doesn't throw much

[18:05] *** kboga joined
[18:05] <TimToady> so the code in S04 does, in fact, catch multiple failures if they are propagated up the call stack

[18:05] <TimToady> as long as the new failure isn't in the CATCH itself

[18:06] <TimToady> that's why CATCH now implicitly loops over multiple exceptions

[18:07] <TimToady> and, as written, the handler can access @! if it wants to, or just ignore it and process exceptions one at a time

[18:07] <TimToady> we just need to figure out what the default CATCH in a try does with @! to poke a $!-ish value into the caller

[18:08] <TimToady> it's not exactly a fail()

[18:09] *** mj41 joined
[18:10] <TimToady> I think it's probably fine to say that $! is the last handled failure, and try can return a last-handled failure of "Multiple failures, here they are:"

[18:11] *** mls_ left
[18:11] <TimToady> "Multiple exceptions" rather

[18:12] <TimToady> trying hard to keep my failures (unthrown) distinct from my exceptions (thrown)

[18:13] *** mls_ joined
[18:15] <TimToady> we might need a 'handle' predicate for use in CATCH, since 'fail' says "this is unhandled" to a caller

[18:15] <TimToady> handle would set the caller's $! but mark it handled

[18:17] *** _ilbot joined
[18:17] <TimToady> or maybe the snippet in S04 around the user's switch handles that automatically

[18:17] <TimToady> I mean, we would make it do that :)

[18:17] <tadzik> nom: class A{}; say so A ~~ Any

[18:17] <p6eval> nom: OUTPUT«Bool::True␤»

[18:18] <TimToady> so any CATCH puts handled exceptions into $!, not just try

[18:18] <tadzik> nom: class A is Mu {}; say so A ~~ Any

[18:18] <p6eval> nom: OUTPUT«No applicable candidates found to dispatch to for 'trait_mod:<is>'. Available candidates are:␤:(Attribute $attr, Any $rw)␤:(Attribute $attr, Any $readonly)␤:(Routine $r, Any $rw)␤:(Parameter $param, Any $readonly)␤:(Parameter $param, Any $rw)␤:(Parameter $param, Any $copy)␤:…

[18:18] <tadzik> tee hee

[18:25] <TimToady> the problem with my snippet's switch is that it's hard to capture the handling of an exception, when that's represented by a 'succeed' in the switch just iterating the loop without falling through to the "didn't handle" code

[18:26] *** impious joined
[18:28] *** moritz joined
[18:28] <moritz> ~o~

[18:28] <phenny> moritz: 16:52Z <sorear> tell moritz I have irc logs right now.  Can we inject stuff into ilbot's database, for the sake of people browsing the logs in five years' time?

[18:29] <moritz> not easily :(

[18:30] <moritz> did anything significant happen that the people in five years absolutely can't miss?

[18:31] <mls_> sorear: can you gist the log?

[18:37] *** PacoLinux joined
[18:39] <dalek> specs: 15c37f8 | larry++ | S04-control.pod:

[18:39] <dalek> specs: refine relationship of CATCH to outer caller's $!

[18:39] <dalek> specs: 

[18:39] <dalek> specs: Now if there are multiple caught exceptions in a try, they

[18:39] <dalek> specs: should all be passed to set_outer_caller's_bang and show up

[18:39] <dalek> specs: in some form in $!.  Note it's not the caller's bang, since

[18:39] <dalek> specs: we're called by some die deep down (CATCH is pre unwind).

[18:39] <dalek> specs: It's whatever called the OUTER of the CATCH, so is a bit lexotic

[18:39] <dalek> specs: review: https://github.com/perl6/specs/commit/15c37f83a4

[18:47] <moritz> btw the logging continues now, it's just the webserver that's not up yet

[18:47] <moritz> and my admin seems unreachable :(

[18:48] *** kboga left
[18:49] *** birdwindupbird joined
[18:53] <moritz> can anyobdy build nom?

[18:53] <moritz> I get

[18:53] <moritz> Method 'infinite' not found for invocant of class 'Parcel'

[18:54] <moritz> when compiling Test.pm and Pod/To/Text.pm

[18:54] *** impious left
[18:56] <TimToady> trying

[19:00] *** kboga joined
[19:02] <TimToady> now takes 1.3G to compile CORE.setting...

[19:02] <TimToady> success

[19:03] <TimToady> that was just with a pull and a make, no clean

[19:05] <mls_> phenny: tell pmichaud https://gist.github.com/1124942 is yesterday's version. I just changed the name of the op to rethrow_skipnextctx and added some comments today.

[19:05] <phenny> mls_: I'll pass that on when pmichaud is around.

[19:07] <mikemol> phenny: tell thundergnat++ Many thanks for uploading images of output graphical tasks on RC. Pretty things are pretty.

[19:07] <phenny> mikemol: I'll pass that on when thundergnat++ is around.

[19:07] <mikemol> Hm. I'm rather disturbed that that's literally true.

[19:08] <rdesfo> is there any way to use perl5 libqtgui4 module in perl6?

[19:08] <mls_> phenny: tell pmichaud the opcode makes rethrow skip all exception handlers from the current context and the next context

[19:08] <phenny> mls_: I'll pass that on when pmichaud is around.

[19:09] *** envi left
[19:10] *** mberends joined
[19:15] *** rdesfo left
[19:15] *** tyatpi joined
[19:19] <dalek> rakudo/nom: c52595a | tadzik++ | src/ (2 files):

[19:19] <dalek> rakudo/nom: Fix "is doc()" trait

[19:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c52595af00

[19:21] <pmichaud> mls_: I think that rethrow already skips the current handler.

[19:21] <phenny> pmichaud: 19:05Z <mls_> tell pmichaud https://gist.github.com/1124942 is yesterday's version. I just changed the name of the op to rethrow_skipnextctx and added some comments today.

[19:21] <phenny> pmichaud: 19:08Z <mls_> tell pmichaud the opcode makes rethrow skip all exception handlers from the current context and the next context

[19:22] * pmichaud looks at patch

[19:22] <mls_> Yes, I mean the next handler in the context-

[19:22] <mls_> (In the rakudo case, there are no other handlers in the current context)

[19:24] <pmichaud> I don't think this patch can be correct.  It's hard to say exactly, though, because the indentation is wrong.

[19:24] <pmichaud> But it's adding a 'try' node where one didn't previously exist.

[19:24] *** gabiruh left
[19:24] <pmichaud> so, that's a big confusing.

[19:24] <pmichaud> *bit

[19:25] *** gabiruh joined
[19:27] <mls_> Yes, it adds another try node in the handler function. If there's an exception in the handler, the extra try will catch it and rethrow it with the new op. The op will then meddle with the exception so that all handlers in the next context (where the orig exception happened) get skipped

[19:28] <pmichaud> that feels wrong also.

[19:29] <pmichaud> what if the exception in the handler is one that would've been normally caught by some other handler?  It feels wrong to skip/remove it in that case.

[19:29] <mls_> Oh, it just rethrows, so other handlers will get it. Just not the ones from the next context.

[19:30] <pmichaud> what if there are other handlers in the next context?

[19:30] *** slavik left
[19:30] <TimToady> you might look at how SIMPLECATCH works in S04:1028

[19:31] <mls_> (The approach can be modified so that just the original handler is skipped)

[19:31] <TimToady> it assumes there the 'thrower' is passing lists of exceptions back and forth to the handlers

[19:31] <TimToady> so instead of rethrowing new exceptions it just adds them to the list of currently-being-thrown exceptions

[19:32] *** moritz left
[19:34] *** mj41 left
[19:34] *** moritz joined
[19:36] <pmichaud> why the * twigils?

[19:40] <mls_> TimToady: yes, the patch is a start in the SIMPLECATCH direction. Still, we need the special opcode to rethrow without getting caught by the original handler

[19:40] <pmichaud> I think the point is to change the thing that is doing the catching.

[19:40] <pmichaud> not to add more layers of catchers

[19:44] <mls_> I don't think it makes a difference which handler cathes the exception. By doing a a new push_eh in the handler function we're sure that we don't interfere if the exception gets seumed, because the continuation does not see the handler

[19:44] <mls_> resumed

[19:44] <pmichaud> I'm not sure that's the case.  

[19:45] <pmichaud> (Maybe that's supposed to be the case, but I'm not sure that it actually *is* the case.  I'd want to see proof in code.)

[19:45] <pmichaud> either way, I'm biased against creating the extra handler for now.

[19:46] <pmichaud> afk, errands

[19:46] <mls_> I don't see why the extra handler matters. Is the push_eh really that expensive?

[19:46] <TimToady> the * twigil is just there so user routines can see the variable if they want to do something weird; it's negotiable

[19:46] <pmichaud> actually, it is.

[19:46] <pmichaud> (push_eh expensive)

[19:46] <pmichaud> but more than that, I don't like convoluted "check this, skip this, etc." solutions.  They aren't robust and are prone to breakage.

[19:47] <mls_> Oh, but it's much easier that searching the call chain for the handler function.

[19:47] <mls_> than

[19:48] <TimToady> I think it's important not to switch back and forth between normal code and throwing code in a convoluted fashion

[19:48] <mls_> It's actually a pretty simple solution.

[19:49] <TimToady> that why when you're in throw mode, you stay in throw mode until you're done in the SIMPLECATCH code

[19:49] <shinobicl> hi... .how could i write this condition using junctions??

[19:49] <shinobicl> rakudo: my $start = 5; my $end = 10; my $x = 0; for (1..20) ->$i { if $i >= $start && $i <= $end { say $i } };

[19:49] <p6eval> rakudo 922500: OUTPUT«5␤6␤7␤8␤9␤10␤»

[19:50] *** PacoLinux left
[19:50] <TimToady> why do you want a junction?  sounds like an XY problem

[19:50] <PerlJam> TimToady: because junctions are shiny!  :)

[19:50] <shinobicl> yes :D

[19:50] <TimToady> $start <= $i <= $end is also shiney

[19:51] <TimToady> shiny even

[19:51] <shinobicl> rakudo: my $start = 5; my $end = 10; my $x = 0; for (1..20) ->$i { if $start <= $i <= $end { say $i } };

[19:51] <p6eval> rakudo 922500: OUTPUT«5␤6␤7␤8␤9␤10␤»

[19:51] <shinobicl> that is not a junction?

[19:51] <PerlJam> no

[19:51] <flussence> rakudo: my $start = 5; my $end = 10; say for grep { $start <= $^i <= $end } 1..20;

[19:51] <TimToady> just a chained comparison

[19:51] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Confused at line 22, near "say for gr"␤»

[19:51] <flussence> grr

[19:51] <flussence> rakudo: my $start = 5; my $end = 10; .say for grep { $start <= $^i <= $end } 1..20;

[19:51] <PerlJam> you could also us a smart match

[19:51] <TimToady> comma

[19:51] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Confused at line 22, near ".say for g"␤»

[19:52] <flussence> rakudo: my $start = 5; my $end = 10; .say for grep { $start <= $^i <= $end }, 1..20;

[19:52] <p6eval> rakudo 922500: OUTPUT«5␤6␤7␤8␤9␤10␤»

[19:52] <shinobicl> rakudo: my $start = 5; my $end = 10; for (1..20) ->$i { if $i == any($start .. $end) { say $i } };

[19:52] <p6eval> rakudo 922500: OUTPUT«5␤6␤7␤8␤9␤10␤»

[19:52] <TimToady> rakudo: my $start = 5; my $end = 10; .say for grep $start..$end, 1..20

[19:52] <p6eval> rakudo 922500: OUTPUT«5␤6␤7␤8␤9␤10␤»

[19:52] <TimToady> the junction only slows it down

[19:53] <TimToady> and grep already does a smartmatch, so a range works

[19:53] <shinobicl> i had the silly idea that chained comparisons were junctions

[19:54] <shinobicl> i mean, implemented as junctions

[19:54] * TimToady hopes not

[19:54] <TimToady> they're supposed to short-circuit, for one

[19:54] <flussence> rakudo: my $start = 5; my $end = 10; for 1..20 { say $^i if {$^i==$start} ff {$^i==$end} } # am I doing this right?

[19:54] <p6eval> rakudo 922500: OUTPUT«===SORRY!===␤Flip flip operators are not yet implemented at line 22, near " {$^i==$en"␤»

[19:54] <flussence> hm...

[19:54] <flussence> niecza: my $start = 5; my $end = 10; for 1..20 { say $^i if {$^i==$start} ff {$^i==$end} } # am I doing this right?

[19:54] <p6eval> niecza v8-37-g28de0b8: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤$i has already been used as a non-placeholder in the surrounding block,␤  so you will confuse the reader if you suddenly declare $^i here at /tmp/eAC_RmQLD9 line 1:␤------> [32m; my $end = 10; for 1..20 { say $^i if {[33m⏏…

[19:55] <TimToady> say 1 > 10 > die "Phooey"

[19:55] <TimToady> perl6: say 1 > 10 > die "Phooey"

[19:55] <flussence> niecza: my $start = 5; my $end = 10; for 1..20 -> $i { say $i if {$i==$start} ff {$i==$end} }

[19:55] <p6eval> rakudo 922500, niecza v8-37-g28de0b8: OUTPUT«Bool::False␤»

[19:55] <p6eval> ..pugs: OUTPUT«␤»

[19:55] <p6eval> niecza v8-37-g28de0b8: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤»

[19:56] <TimToady> flussence: you can't use $^i both inside and outside of {}

[19:56] <flussence> oh well, there's always the brute-force option,

[19:57] <TimToady> the lambda form works fine

[19:57] <TimToady> as you demonstrated

[19:57] <mls_> ok, back in two weeks. Happy hacking!

[19:57] <TimToady> enjoy!

[19:58] <mls_> Thanks! -oo

[19:58] *** mls_ left
[19:58] <flussence> .oO( curses, I never got as far as defining a infix:<∩> in that module to copy+paste from... }

[19:58] *** dual joined
[20:00] <TimToady> the error message from niecza (from STD originally) is LTA though, since $i actually *was* a placeholder in the outside block

[20:00] <pmichaud> 19:47 <mls_> Oh, but it's much easier that searching the call chain for the handler function.

[20:01] <pmichaud> "much easier" isn't much easier if it involves introducing holes into the solution space. (more)

[20:01] <pmichaud> by that reckoning, simply adding a "pop_eh" after catching the exception is "easier".

[20:01] <pmichaud> (back from errands)

[20:02] <pmichaud> nom: (1..10)>>.say

[20:02] <p6eval> nom: OUTPUT«2␤5␤9␤4␤7␤8␤3␤10␤6␤1␤»

[20:03] <pmichaud> \o/

[20:03] <TimToady> tell me it didn't actually do a shuffle on that... :)

[20:06] * TimToady has been thinking about the close-after-reading problem, and wondering whether we're basically missing a phase that needs phasing

[20:07] <TimToady> if a scope returns a lazy list, the lifetime of that list is determined elsewhere, but we might well want something to happen when that lazy list is exhausted

[20:07] <tadzik> nom: [1, 2, 3] «+&» [4, 5, 6]

[20:07] <p6eval> nom: OUTPUT«Could not find sub &METAOP_HYPER␤current instr.: '_block1002' pc 90 ((file unknown):15277720) (/tmp/iyaK74jHqF:1)␤»

[20:07] <TimToady> to be consistent with the existing .plan method, I'm thinking of a PLAN {...} phaser that adds to the end of the currently returning lazy list

[20:08] <TimToady> and then my $handle will plan *.close = open $filename;  $handle.lines

[20:08] <TimToady> or some such

[20:09] <pmichaud> it did actually do a shuffle on that.  :)

[20:09] <TimToady> and the close just gets tacked onto the lazy list and runs when the handle runs out of lines

[20:09] <TimToady> or some similar way of scheduling something at the end of whatever is gathering inside

[20:10] <TimToady> without having to compose a new gather outside

[20:10] <TimToady> just to tack something on the end

[20:10] <pmichaud> what exactly do we mean by "when the lazy list is exhausted"?  do we really mean "when all the lazy parts are gone"?

[20:10] *** tyatpi left
[20:10] <pmichaud> in the case of a gather, it's pretty easy to add a close to the end within the gather

[20:11] <TimToady> no

[20:11] <TimToady> not if the gather is in someone else's code

[20:11] <TimToady> see .lines above

[20:11] <pmichaud> (thinking)

[20:12] <TimToady> there's an outer and an inner dynamic scope, and we want to capture control right when the inner dynamic scope leaves

[20:12] <TimToady> it's the natural time to do things like close a file

[20:13] <TimToady> and it's the one situation where we can't actually control the dynamic context in question, because someone else is doing it

[20:13] <TimToady> and yes, it'd only be useful for finite lists :)

[20:13] <pmichaud> in the .lines above, does the 'plan' attach to the variable or to the value?

[20:14] <TimToady> it's just a closure that runs at the end of the list; I have it attached to the variable

[20:14] <TimToady> but its effect is not there at all

[20:14] <TimToady> its PLAN {} effect is at LEAVE time, only it's basically a lazy LEAVE

[20:15] <pmichaud> but the list is from .lines, not from the IO object

[20:15] <pmichaud> opening a file doesn't create a list.

[20:15] <TimToady> I don't care where the list is from, as long as I can tack an action onto its end

[20:16] <TimToady> in this case the exhaustion of lines would imply the exhaustion of the filehandle

[20:16] <pmichaud> so, it needs to be something that decorates .lines or its return value

[20:16] <TimToady> I was thinking of it as modifying the returned lazy list en passant

[20:16] <TimToady> just push another plan onto its un-reified iterators

[20:17] <TimToady> it just happens to return () and have a side effect

[20:17] <TimToady> that seems like the simplest thing to me

[20:17] <TimToady> but I could be wrong about that, and wouldn't mind

[20:18] <pmichaud> having side-effects on a list seems okay to me.

[20:18] <pmichaud> but attaching the side effects to the variable does not.

[20:18] <TimToady> well, simplest might be to compose another gather, but that'll get slow

[20:18] <TimToady> it's not attaching side effects to the variable

[20:18] <TimToady> it's just expressed as a trait so we know what to close at PLAN time

[20:19] <TimToady> but maybe there's a way to mark the value instead

[20:19] <pmichaud> yeah, doing a .push of some sort on the result of lines might work

[20:20] <TimToady> well, .push is reifying, so I said .plan

[20:20] <pmichaud> then just .plan 

[20:20] <pmichaud> $handle.lines.plan(...)

[20:20] <PerlJam> why is .plan named so?  Just for the future aspect of it?

[20:20] <TimToady> yeah, and it starts with p like push

[20:20] <pmichaud> and we put something onto the list that executes and returns ()

[20:20] <pmichaud> (and that something is Iterable, so it flattens)

[20:21] <TimToady> anyhoo, I was kinda horrified to realize we had a lifetime we couldn't easily talk about in Perl 6

[20:21] <pmichaud> class Plan is Iterator { has $!code; method reify() { $!code; return () } }

[20:21] <pmichaud> er, $!code()

[20:22] <pmichaud> then you can put a Plan anywhere in a list, and when its interpolated it executes $!code and returns ()

[20:22] <pmichaud> *it's

[20:22] <TimToady> course, conceivably you express a plan by just saying .lines; plan()...yeah, that

[20:22] <pmichaud> s/Plan/NilCode/  # perhaps

[20:22] <TimToady> er, comma, not semi

[20:22] <pmichaud> similar to Whatever and WhateverCode

[20:23] *** moritz left
[20:23] <pmichaud> I have to depart.  Anyway, having some sort of Iterable that executes code might be a cleaner approach.

[20:23] <TimToady> something to think on

[20:24] <pmichaud> it would also mean that we can do code executions at the beginning of lists, in the middle of lists, etc.

[20:24] <pmichaud> as well as being able to have multiple such phasers in a list

[20:24] <pmichaud> "phasers"

[20:24] <TimToady> that seems like a useful primitive

[20:24] <pmichaud> okay, gotta run -- bbl

[20:25] <TimToady> even if we have sugar for open

[20:25] <TimToady> o/

[20:28] * jnthn back

[20:28] <jnthn> Aww. I just missed pmichaud++

[20:31] <tadzik> oh, I just catched jnthn++ :)

[20:32] <tadzik> if I may, in https://gist.github.com/1128443 the argument to :WHEREFORE seems to be treated as a string - for a module, it dies with 'get_string() not implemented in class <modulename>', do you know what may cause this?

[20:33] *** Mowah joined
[20:36] *** Trashlord left
[20:41] <jnthn> tadzik: looking

[20:42] *** timbunce left
[20:42] <jnthn> Also, grr, I've busted a bunch of tests by fixing something...

[20:43] <jnthn> tadzik: No, not off hand. Hm

[20:43] <jnthn> tadzik: When does it actually die with that?

[20:44] <tadzik> jnthn: when the parser gets to the module declaration

[20:46] <jnthn> tadzik: OK...but what's it doing? Is it dying in serialize_object?

[20:47] <tadzik> no, not really. Let me tell you by example:

[20:47] <tadzik> module Foo; everything gets documented, bla bla, but when I send the $what to :WHEREFORE(), it's somehow turning $what into a string or so

[20:48] <tadzik> well, it's dying when calling serialize_object, yes

[20:48] *** timbunce joined
[20:48] <tadzik> oh, wait

[20:48] <tadzik> I think add_constant uses the string value of a thing as a cache key

[20:48] <tadzik> so maybe that's what fails

[20:49] <jnthn> yes, it does

[20:49] *** masak joined
[20:49] <masak> whoa. that was one *spicy* Vindaloo.

[20:49] <jnthn> Another reason why new_type and add_constant should probably be split out. :)

[20:49] <jnthn> masak: :)

[20:50] <masak> IRC logs still down?

[20:50] <jnthn> aye

[20:50] <masak> then how am I supposed to find out what you were talking about while I was gone? :)

[20:50] <tadzik> I knew that masak++ would be confused :)

[20:51] <masak> oh yeah? bet you said it too, in the nonexistent backlog!

[20:51] <tadzik> YOU WILL NEVER KNOW

[20:51] <masak> gaaah

[20:55] <tadzik> jnthn: is that a ModuleHOW or something like this?

[20:56] <jnthn> tadzik: yes

[20:58] *** birdwindupbird left
[20:59] <tadzik> sub foo {}; $=POD[0].WHEREFORE.() # quite cool

[20:59] <tadzik> jnthn: any idea to solve this in a sane way?

[20:59] <jnthn> :)

[20:59] <tadzik> bonus points for being solvable by me :)

[20:59] <jnthn> tadzik: I still think add_constant and new_type need splitting up.

[21:00] <tadzik> sounds like a job for a Splitting Man!

[21:00] <jnthn> tadzik: And new_type wouldn't cache

[21:00] <jnthn> Maybe that works out.

[21:00] <jnthn> Though

[21:00] <tadzik> hmm

[21:00] <jnthn> nom: module Foo { }; say Foo

[21:00] <p6eval> nom: OUTPUT«Foo()␤»

[21:00] <jnthn> nom: module Foo { }; pir::say(Foo)

[21:00] <p6eval> nom: OUTPUT«get_string() not implemented in class 'Foo'␤current instr.: '_block1002' pc 93 ((file unknown):116) (/tmp/F2SvScvmkt:1)␤»

[21:00] <tadzik> as a first step, we can just omit caching when 'type_new' is the argument

[21:00] <jnthn> nom: class Foo { }; pir::say(Foo)

[21:00] <p6eval> nom: OUTPUT«Use of uninitialized value in string context␤␤»

[21:00] <jnthn> ah, I see...

[21:01] <jnthn> tadzik: Well, thing is, when objects reference other complex objects, the caching is not quite going to work out.

[21:01] <jnthn> tadzik: Or add a :$nocache

[21:02] <jnthn> I guess for Rat and Complex we'd like to keep the cache.

[21:02] <tadzik> probablu

[21:02] <tadzik> so, :nocache then?

[21:02] <jnthn> Do that for now.

[21:02] <tadzik> okay

[21:03] *** jaldhar joined
[21:03] <tadzik> nqp: sub foo(:$nope) { if $nope { say(1) } }; foo(); foo(:nope)

[21:03] <p6eval> nqp: OUTPUT«1␤»

[21:04] <tadzik> oh crap, I have to add that to serialize_object too :)

[21:04] <tadzik> or just don't use it in this case

[21:04] *** jaldhar left
[21:05] *** jaldhar joined
[21:07] *** jaldhar left
[21:08] *** jaldhar joined
[21:09] *** am0c left
[21:12] *** PacoLinux joined
[21:13] <tadzik> huh, my unless %*COMPILING<%?OPTIONS><setting> eq 'NULL' appears to die with Method 'exists' not found for invocant of class 'Hash'

[21:14] <tadzik> but only when I use classes :/

[21:15] *** mls_ joined
[21:16] <tadzik> or not. Fun stuff

[21:16] *** wolfman2000 joined
[21:18] <mls_> seen pmichaud

[21:18] <aloha> pmichaud was last seen in #perl6 53 mins 27 seconds ago saying "okay, gotta run -- bbl".

[21:19] <masak> aloha: OR SO YOU CLAIM

[21:19] *** slavik joined
[21:21] <mls_> phenny: tell pmichaud earlier today we discussed what happens if a block both has a CATCH and a CONTROL handler and a control exception is thrown when processing the catch handler. There was agreement that it should not be caught by the handler

[21:21] <phenny> mls_: I'll pass that on when pmichaud is around.

[21:22] *** mj41 joined
[21:25] <mls_> phenny: tell pmichaud so checking if the same handler was already active is and rethrowing is not enough. all handlers in the context must be "disabled" if one handler is active. That's basically what my patch does.

[21:25] <phenny> mls_: I'll pass that on when pmichaud is around.

[21:27] <masak> 'night, #perl6ers.

[21:27] *** masak left
[21:28] <jnthn> rakudo: say \(1,2,3).WHAT

[21:28] <p6eval> rakudo 922500: OUTPUT«Capture()␤»

[21:28] <jnthn> rakudo: say \(1,2,3).Str

[21:28] <p6eval> rakudo 922500: OUTPUT«Capture()<0x25cbd00>␤»

[21:28] <jnthn> rakudo: say \(1,2,3).String

[21:28] <jnthn> rakudo: say \(1,2,3).Stringy

[21:28] <p6eval> rakudo 922500: OUTPUT«Method 'String' not found for invocant of class 'Capture'␤  in main program body at line 22:/tmp/PcpHF2b55T␤»

[21:28] <p6eval> rakudo 922500: OUTPUT«Method 'Stringy' not found for invocant of class 'Capture'␤  in main program body at line 22:/tmp/gmoKnLGgzp␤»

[21:28] <jnthn> rakudo: say \(1,2,3)

[21:28] <p6eval> rakudo 922500: OUTPUT«Capture()<0x2da3178>␤»

[21:28] <mls_> phenny: tell pmichaud if speed is really an issue, we can also do this with a parrot patch by adding a flag to the context that tells parrot to skip all handlers of the next context. The handler function would then set this flag with an opcode. 

[21:28] <phenny> mls_: I'll pass that on when pmichaud is around.

[21:28] *** mj41 left
[21:29] <jnthn> rakudo: my @array = <a b c>; my $ref = \@array; say $ref.WHAT

[21:29] <tadzik> nom: class A {}; say so A.HOW ~~ Metamodel::ClassHOW # jnthn?

[21:29] <p6eval> rakudo 922500: OUTPUT«Capture()␤»

[21:29] <p6eval> nom: OUTPUT«Segmentation fault␤»

[21:29] <mls_> back to bed... good night...

[21:29] *** jaldhar left
[21:29] <tadzik> or maybe there's a better way to tell if something is a class, a module or what?

[21:29] <jnthn> night, mls_ 

[21:29] <tadzik> mls_: g'night

[21:29] <mls_> quit

[21:30] <mls_> oops

[21:30] <jnthn> fail

[21:30] *** mls_ left
[21:30] <jnthn> :)

[21:30] *** jaldhar joined
[21:30] <jnthn> nom: class A {}; A.HOW ~~ Metamodel::ClassHOW

[21:30] <p6eval> nom:  ( no output )

[21:30] <jnthn> nom: class A {}; pir::say(A.HOW ~~ Metamodel::ClassHOW)

[21:30] <p6eval> nom: OUTPUT«1␤»

[21:31] <tadzik> nom: class A {}; say(A.HOW ~~ Metamodel::ClassHOW).WHAT

[21:31] <p6eval> nom: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤current instr.: 'say' pc 648959 (src/gen/CORE.setting.pir:161026) (src/gen/CORE.setting:4077)␤»

[21:31] <tadzik> Parrot leaking through, eh?

[21:31] <jnthn> Yeah

[21:31] <jnthn> Though not obvious where really.

[21:31] <tadzik> smartmatching?

[21:31] *** ranott joined
[21:31] <jnthn> No

[21:31] *** jaldhar left
[21:31] <jnthn> Oh

[21:31] *** Mowah left
[21:31] *** jaldhar joined
[21:32] <jnthn> It's finding NQP's ACCEPTS since Metamodel::ClassHOW is written in NQP I guess

[21:32] <tadzik> nom: say Metamodel::ClassHOW.WHAT

[21:32] <p6eval> nom: OUTPUT«Method 'gist' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤current instr.: 'say' pc 648959 (src/gen/CORE.setting.pir:161026) (src/gen/CORE.setting:4077)␤»

[21:32] <tadzik> probably, yes

[21:32] * jnthn still needs to fix that lot up

[21:32] <jnthn> Evil bootstrapping fun.

[21:33] <jnthn> rakudo: my @array = <a b c>; my $ref = \@array; say $ref.WHAT

[21:33] <p6eval> rakudo 922500: OUTPUT«Capture()␤»

[21:33] <jnthn> rakudo: my @array = <a b c>; my $ref = \@array; say $ref

[21:33] <p6eval> rakudo 922500: OUTPUT«Capture()<0x637fdf0>␤»

[21:33] <tadzik> nom: class A {}; say so pir::isa(A, 'ClassHOW')

[21:33] <p6eval> nom: OUTPUT«Segmentation fault␤»

[21:33] <jnthn> rakudo: my @array = <a b c>; my $ref = \@array; say ~$ref

[21:33] <p6eval> rakudo 922500: OUTPUT«Capture()<0x49360a8>␤»

[21:33] <jnthn> tadzik: er, do *not* use pir::isa on 6model objects :)

[21:33] <jnthn> It won't even sort of work

[21:33] <tadzik> oopsie :)

[21:33] <tadzik> nom: class A {}; say so pir::isa(A.HOW, 'ClassHOW')

[21:33] <p6eval> nom: OUTPUT«Segmentation fault␤»

[21:33] <jnthn> .HOW is a 6model object

[21:33] <tadzik> ah

[21:33] <jnthn> pir::isa is Parrot object model only.

[21:34] <tadzik> but still not a Perl 6 object :)

[21:34] <jnthn> Well, it's not an object that derives from Mu.

[21:34] <tadzik> nom: class A {}; say so A.HOW.isa('ClassHOW')

[21:34] <p6eval> nom: OUTPUT«too few positional arguments: 2 passed, 3 (or more) expected␤current instr.: 'nqp;Perl6;Metamodel;MROBasedTypeChecking;isa' pc 36676 (src/gen/perl6-metamodel.pir:9926) (src/gen/Metamodel.pm:729)␤»

[21:34] <jnthn> that'll work.

[21:34] <jnthn> nom: class A {}; say so A.HOW.isa(A, 'ClassHOW')

[21:34] <p6eval> nom: OUTPUT«Bool::False␤»

[21:34] <jnthn> But not with a string of course. :)

[21:34] <jnthn> nom: class A {}; say so A.HOW.isa(A, Metamodel::ClassHOW)

[21:35] <p6eval> nom: OUTPUT«Bool::False␤»

[21:35] <jnthn> hm

[21:35] <jnthn> oh

[21:35] <tadzik> nom: class A {}; say so A.HOW.isa(A.HOW, Metamodel::ClassHOW)

[21:35] <p6eval> nom: OUTPUT«Bool::False␤»

[21:35] <jnthn> yeah, that's asking about A

[21:35] <jnthn> Not it's meat-boject :)

[21:35] <jnthn> ...meta-object

[21:35] <tadzik> still rong

[21:35] <jnthn> easy way

[21:36] <jnthn> nqp::istype(A.HOW, Metamodel::ClassHOW

[21:36] <jnthn> )

[21:36] <jnthn> nom: class A { }; say nqp::p6bool(nqp::istype(A.HOW, Metamodel::ClassHOW))

[21:36] <p6eval> nom: OUTPUT«Bool::True␤»

[21:36] <jnthn> nom: role A { }; say nqp::p6bool(nqp::istype(A.HOW, Metamodel::ClassHOW))

[21:36] <p6eval> nom: OUTPUT«Bool::False␤»

[21:37] <tadzik> ok, nice

[21:40] <sorear> un-nap.

[21:43] *** thundergnat joined
[21:43] *** pernatiy joined
[21:44] *** Psyche^ joined
[21:45] *** jaldhar left
[21:46] <tadzik> oh, pushing the declarators to $=POD breaks order anyway :/

[21:46] <tadzik> methods get there before classes

[21:47] *** slavik left
[21:48] *** slavik joined
[21:48] <sorear> flussence: that error message is wrong

[21:48] *** Patterner left
[21:48] *** Psyche^ is now known as Patterner

[21:49] <sorear> TimToady: I think your PLAN {} is just LEAVE.  Can you give a case where they would differ?

[21:49] <sorear> TimToady: Why is { my $i; { $^i == 5 } } illegal?

[21:50] <sorear> TimToady: I mean, why should it be.  I think 'why' is because of a bug, the OUTER::<$i> alias is being created too eagerly

[22:04] *** drbean joined
[22:15] *** tuku joined
[22:16] <tuku> This may be a common question, but where can I find a decent perl6 tutorial?

[22:17] <sorear> tuku: do you know perl 5?

[22:17] *** mkramer1 left
[22:17] <tuku> Currently not much, just can read and write basic programs in it.

[22:18] *** Moukeddar joined
[22:18] <sorear> ah.

[22:18] <sorear> http://github.com/perl6/book/downloads is well regarded

[22:19] *** mkramer joined
[22:19] <sorear> masak did a tutorial blog series last month with a target audience of "completely new to programming"

[22:20] <sorear> http://perl6.org/documentation/ is the main directory

[22:21] *** noam joined
[22:21] <tuku> thanks for the links.

[22:22] <tuku> And I shall be off now.

[22:22] *** tuku left
[22:26] <dalek> rakudo/nom: 4b19d47 | tadzik++ | src/Perl6/SymbolTable.pm:

[22:26] <dalek> rakudo/nom: [SymbolTable] Add a :nocache option to add_constant

[22:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4b19d4724d

[22:26] <dalek> rakudo/nom: 2e38c54 | tadzik++ | src/Perl6/Actions.pm:

[22:26] <dalek> rakudo/nom: Don't attempt to document class attributes

[22:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e38c54135

[22:26] <dalek> rakudo/nom: 71df76f | tadzik++ | src/ (2 files):

[22:26] <dalek> rakudo/nom: Push declarator blocks to $=POD as a Pod::Block::Declarator objects

[22:26] <dalek> rakudo/nom: 

[22:26] <dalek> rakudo/nom: The order is messed up unfortunately. Given a class with a method in it,

[22:26] <dalek> rakudo/nom: the method declarator is added before the class declarator.

[22:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/71df76fa1f

[22:26] <dalek> rakudo/nom: 4472ab8 | tadzik++ | Pod/To/Text.pm:

[22:26] <dalek> rakudo/nom: Add declarator blocks support to Pod::To::Text

[22:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4472ab814b

[22:26] <jnthn> perl6: my @array = <a b c>; my $ref = \@array; say +$ref

[22:26] <p6eval> rakudo 922500: OUTPUT«maximum recursion depth exceeded␤  in 'Cool::Numeric' at line 1921:src/gen/core.pm␤  in 'Cool::Numeric' at line 1922:src/gen/core.pm␤  in 'Cool::Num' at line 1:src/gen/core.pm␤  in 'Cool::Numeric' at line 1921:src/gen/core.pm␤  in 'Cool::Numeric' at line 1923:src/g…

[22:26] <p6eval> ..pugs: OUTPUT«3␤»

[22:26] <p6eval> ..niecza v8-37-g28de0b8: OUTPUT«Unhandled exception: Cannot use value like Capture as a number␤  at /home/p6eval/niecza/lib/CORE.setting line 696 (CORE die @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 43 (CORE Any.Numeric @ 4) ␤  at  line 0 (ExitRunloop @ 0) ␤  at /tmp/R1j67JPrjs …

[22:27] <jnthn> If \@foo is like \(@foo) I'd kinda expect that to be 1.

[22:27] <jnthn> Since in an argument list that wouldn't flatten.

[22:27] <tadzik> I wonder if there's any smarter way than sorting the declarator blocks by their $/.from

[22:28] <jnthn> tadzik: Perhaps just pushing them in the right order in the first place? :)

[22:28] <jnthn> Can see that may be tricky in some cases

[22:29] <jnthn> Package on should be fixable though.

[22:29] <jnthn> *one

[22:30] <tadzik> jnthn: well, that'll require them to be pushed when they appear in the code rather than when their coresponding object action method is called

[22:30] <tadzik> and the object needs to be constructed when they're pushed (see WHEREFORE)

[22:33] <tadzik> https://gist.github.com/1128691 # current behaviour example

[22:34] <TimToady> sorear: yes, it should allow it syntactically (though $^i is otherwise illegal in a bare block, but that's a different issue)

[22:34] <TimToady> on the other thing...

[22:35] <TimToady> niecza: sub foo() { LEAVE { say "now" }; gather { LEAVE { say "then" }; take $_ for 1..10 } }; .say for foo;

[22:35] <p6eval> niecza v8-37-g28de0b8: OUTPUT«now␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[22:35] <TimToady> a PLAN at the point of the first leave would print at the point of the second LEAVE, if that LEAVE actually worked correctly

[22:37] <tadzik> I wonder why t/00-parrot/09-pir.t stopped working in nom

[22:37] <TimToady> got tired

[22:38] <jnthn> tadzik: Probably because it doesn't box/marshall stuff appropriately.

[22:38] <tadzik> jnthn: it gets confused when pir has a trailing whitespace

[22:38] <tadzik> still, the only difference between nom and master is the .value in <quote_EXPR>.ast.value. Nom doesn't like .value

[22:39] <jnthn> no, it sure won't :)

[22:39] <tadzik> like?

[22:39] <tadzik> yeah, no .value in Past::Op

[22:39] <jnthn> right

[22:40] <jnthn> The trailing whitespace thing is odd. 

[22:41] <tadzik> nom: Q:PIR { say 'ok 1' };

[22:41] <p6eval> nom: OUTPUT«ok 1␤»

[22:41] <tadzik> oh, hm

[22:42] <tadzik> I wonder how mad is to strip the trailing \h* manually

[22:48] <tadzik> whatever, it doesn't work anyway:)

[22:49] <tadzik> the multiline PIR seems to be Just Broken

[22:49] <jnthn> TimToady: Is \@foo equivalent to \(@foo) ?

[22:49] <jnthn> Failing to find a spec ref...

[22:50] <TimToady> I believe so

[22:50] <jnthn> OK

[22:50] <jnthn> \@foo.elems is always 1?

[22:50] <TimToady> and @$foo is equivalent to @($foo)  :)

[22:50] <TimToady> presumably

[22:51] <jnthn> I've got some tests that seem to expect $c = \@foo; $c.elems == @foo.elems

[22:51] <TimToady> sounds wrong to me

[22:51] <jnthn> OK, good.

[22:51] <jnthn> We were passing them because Parcel.Capture was busted...

[22:52] *** noam left
[22:53] <jnthn> Presumably \%hash is just \(%hash) and just making it a positonal too?

[22:54] <dalek> specs: a7170aa | larry++ | S04-control.pod:

[22:54] <dalek> specs: no need to set $! if we're rethrowing past it

[22:54] <dalek> specs: review: https://github.com/perl6/specs/commit/a7170aa66e

[22:54] <TimToady> yes

[22:54] <TimToady> \(|%hash) would, of course, be different

[22:55] <jnthn> Aye, makes sense.

[22:55] <tadzik> phenny: tell moritz given https://github.com/rakudo/rakudo/commit/71df76fa1f and https://gist.github.com/1128691 do you see any better way to solve this but to sort the block according to their $/.from?

[22:55] <phenny> tadzik: I'll pass that on when moritz is around.

[22:56] <jnthn> tadzik: BTW, are we still doing the doc trait call for every single method and package whether or not it's documented?

[22:56] <TimToady> I probably dinged you for not having PROCESS::<$PID>

[22:56] <tadzik> jnthn: yes :)

[22:57] <tadzik> I should probably make that smarter

[22:57] <TimToady> sorear: ^^

[22:57] <jnthn> tadzik: Please do. It's likely having a negative effect on startup time and setting compilation time.

[22:58] <jnthn> (Since we don't really serialize yet...once we do the startup time bit of it will cease to be a problem...)

[22:58] <jnthn> Unless you're not doing the doc emission in the setting...but then I can say same story but for spectests ;-)

[22:59] <TimToady> nom, on the other hand, has $*PID but not PROCESS::<$PID>

[23:00] <TimToady> well, what it really doesn't have is PROCESS::{}

[23:00] <tadzik> jnthn: what's better: making .WHY writable, or setting in with Black Magic in traits.pm?

[23:01] <TimToady> it does have $PROCESS::PID

[23:04] <jnthn> nom: say $PROCESS::PID

[23:04] <p6eval> nom: OUTPUT«19598␤»

[23:04] <jnthn> TimToady: Yeah, we don't have that other form of lookup yet.

[23:04] <TimToady> nom: say PROCESS::<$PID>

[23:04] <p6eval> nom: OUTPUT«Method 'at_key' not found for invocant of class 'Any'␤current instr.: 'nqp;Perl6;Metamodel;MethodDelegation;find_method' pc 27431 (src/gen/perl6-metamodel.pir:5691) (src/gen/Metamodel.pm:90)␤»

[23:05] <TimToady> niecza: say PROCESS::<$PID>

[23:05] <p6eval> niecza v8-37-g28de0b8: OUTPUT«Any()␤»

[23:05] *** noam joined
[23:05] <TimToady> but that's really a nitpick, so maybe I should make it green

[23:06] *** timbunce left
[23:06] *** bluescreen10 left
[23:08] <dalek> features: 01328ab | larry++ | features.json:

[23:08] <dalek> features: say niecza has PROCESS, etc.

[23:08] <dalek> features: 

[23:08] <dalek> features: It's missing PROCESS::<$PID> but that's not the namespace's fault...

[23:08] <dalek> features: review: https://github.com/perl6/features/commit/01328ab57d

[23:09] <TimToady> niecza: say PROCESS::<$IN>.get

[23:09] <p6eval> niecza v8-37-g28de0b8: OUTPUT«Land der Berge, Land am Strome,␤»

[23:09] <tadzik> jnthn: well, the trait call will have to stay unless there is a way to set a default value of a metamodel property as a Perl 6 object

[23:09] <tadzik> as in, foo.HOW.docs would have to be Any

[23:12] <jnthn> tadzik: Ah. Though that's only true for packages.

[23:13] <tadzik> I should be able to avoid doing a role mixin for every object though :)

[23:14] <dalek> roast: a8b638a | jonathan++ | S06-signature/unpack-array.t:

[23:14] <dalek> roast: Update test for latest stringification spec; correct one test to what it probably shoulda been.

[23:14] <dalek> roast: review: https://github.com/perl6/roast/commit/a8b638a236

[23:14] <dalek> roast: 53d2c03 | jonathan++ | S02-literals/autoref.t:

[23:14] <dalek> roast: Correct a bunch of wrong assumptions about \ capture former.

[23:15] <dalek> roast: review: https://github.com/perl6/roast/commit/53d2c03527

[23:15] <jnthn> .oO( How is Capture formed? )

[23:15] <tadzik> jnthn: hmm, to add an attribute to Mu I have to mess with BOOTSTRAP.pm, right?

[23:16] <jnthn> wait what

[23:16] <jnthn> Do NOT add an attribute to Mu!

[23:16] <tadzik> okay, but why not? :)

[23:16] <jnthn> Because you make every object everybody ever instantiates 8 bytes larger.

[23:16] <jnthn> (on 64-bit)

[23:16] <sorear> jnthn: notionally, captures are created by the procedure call mechanism

[23:17] <jnthn> sorear: I was meme-reffing, not actually asking :)

[23:17] <tadzik> jnthn: okay, then where do I keep .WHY contents for every object around?

[23:17] <jnthn> tadzik: You mix it in *when* it exists

[23:18] <jnthn> Then have a default method WHY() { Any } # or whatever we settled on it returning when there's no docs

[23:18] <jnthn> The role that is mixed in for documented things overrides that

[23:18] <jnthn> And returns the doc.

[23:18] <tadzik> okay, that makes stuff simplier

[23:18] <jnthn> :)

[23:18] <sorear> role WHY { has $.WHY }; $object does WHY; $object.WHY = ...

[23:19] <jnthn> Along those lines

[23:19] <tadzik> that's more-less what the trait does now

[23:19] <jnthn> tadzik: btw, thanks for fixing inheritance.t regression :)

[23:19] *** lue joined
[23:19] <tadzik> well, that was my bug :)

[23:20] *** bluescreen10 joined
[23:20] <lue> hello world o/

[23:20] <jnthn> Yes, but I'm still happy it's fixed :)

[23:20] <tadzik> hello lue o/

[23:20] <jnthn> hi lue :)

[23:20] <lue> nom: say 35.base(16) # please work

[23:20] <p6eval> nom: OUTPUT«23␤»

[23:20] <tadzik> I think by adding more unshift tests and not fixing them someone wants me to feel obliged to fix unshift again :)

[23:21] <dalek> rakudo/nom: 855106b | jonathan++ | src/core/Parcel.pm:

[23:21] <dalek> rakudo/nom: Fix Parcel.Capture.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/855106bb2b

[23:21] <dalek> rakudo/nom: 01c7286 | jonathan++ | src/core/Capture.pm:

[23:21] <dalek> rakudo/nom: Turns out that some tests relied on the Parcel.Capture returning Parcel hack, because certain things in Capture were not implemented. This adds .elems, .Str and .gist on Capture.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/01c72868dc

[23:21] <dalek> rakudo/nom: 2b00770 | jonathan++ | src/Perl6/Actions.pm:

[23:21] <dalek> rakudo/nom: Apply patch from mls++ that forbids duplicate CATCH and CONTROL blocks, and saves adding a handler to a try block if it already has a CATCH.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b007701de

[23:21] <dalek> rakudo/nom: 3ee1e23 | jonathan++ | src/core/Capture.pm:

[23:21] <dalek> rakudo/nom: Some missing 'multi's.

[23:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ee1e23faf

[23:21] <sorear> TimToady: what do you think of http://pastie.org/2327632 ?

[23:22] *** revdiablo left
[23:30] *** nbrown left
[23:31] *** nbrown joined
[23:34] <dalek> rakudo/nom: ef02d7d | jonathan++ | src/core/Capture.pm:

[23:34] <dalek> rakudo/nom: Oops, bit overzealous multi-ing.

[23:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef02d7d0be

[23:35] *** PacoLinux left
[23:36] *** PacoLinux joined
[23:37] <TimToady> sorear: I think any use of $! for something mission critical is a mistake, plus the $! doesn't belong to you anyway, since you're just a lambda

[23:37] <lue> I wonder what needs to change to allow "make install" to work properly (i.e. make rakudo work in directories besides rakudo/)

[23:38] <sorear> TimToady: please elaborate your opinion of $!.

[23:38] <sorear> TimToady: me, I'm trying to get rid of SIMPLECATCH - I think it seems a lot like what try{} is doing

[23:40] <TimToady> but try *isn't* a simple catch, and the catch inside it is going to have a try, and the catch inside that is going to have a try...it's trytles all the way down

[23:42] <TimToady> plus checking $! after try has had any number of hidden race conditions crop up; I'd rather just put it where I want it exactly in the catch

[23:42] *** molaf left
[23:44] *** Moukeddar left
[23:45] *** im2ee left
[23:46] *** jaldhar joined
[23:47] <pmichaud> back again

[23:47] <phenny> pmichaud: 21:21Z <mls_> tell pmichaud earlier today we discussed what happens if a block both has a CATCH and a CONTROL handler and a control exception is thrown when processing the catch handler. There was agreement that it should not be caught by the handler

[23:47] <phenny> pmichaud: 21:25Z <mls_> tell pmichaud so checking if the same handler was already active is and rethrowing is not enough. all handlers in the context must be "disabled" if one handler is active. That's basically what my patch does.

[23:47] <phenny> pmichaud: 21:28Z <mls_> tell pmichaud if speed is really an issue, we can also do this with a parrot patch by adding a flag to the context that tells parrot to skip all handlers of the next context. The handler function would then set this flag with an opcode. 

[23:55] *** molaf joined
[23:57] *** wamba left
