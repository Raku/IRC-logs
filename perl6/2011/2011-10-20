[00:13] *** tokuhiro_ joined
[00:46] *** replore joined
[01:09] *** drbean left
[01:10] *** tokuhiro_ left
[01:10] *** bluescreen10 joined
[01:16] *** drbean joined
[01:19] *** benabik joined
[01:21] *** jaldhar joined
[01:22] *** benabik left
[01:22] *** benabik joined
[01:26] *** uasi joined
[01:31] *** japhb_ joined
[01:33] <dalek> niecza/serialize: 604037a | sorear++ | lib/Serialize.cs:

[01:33] <dalek> niecza/serialize: Fix generic thawing of array objects

[01:33] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/604037a0ec

[01:33] <dalek> niecza/serialize: c52005a | sorear++ | / (4 files):

[01:33] <dalek> niecza/serialize: Implement unit linking

[01:33] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/c52005ae1d

[01:35] <japhb_> jnthn, it looks to me that https://rt.perl.org/rt3/Ticket/Display.html?id=92986 is indeed solved, though I note that 'say "main $n { $n.WHAT }";' needs to be 'say "main $n { $n.WHAT.gist }";' to work as intended

[01:36] <japhb_> I can't find my bitcard credentials and need to run at the moment, but anyone is free to do the needful to the ticket.

[01:38] *** japhb_ left
[01:40] *** drbean left
[01:45] <dalek> niecza/serialize: 29191f9 | sorear++ | lib/ (2 files):

[01:45] <dalek> niecza/serialize: Recursively initialize units

[01:45] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/29191f989c

[01:45] *** drbean joined
[01:46] <dalek> niecza/serialize: 8983cfc | sorear++ | lib/Kernel.cs:

[01:46] <dalek> niecza/serialize: Remove left-in debugging statement

[01:46] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/8983cfc42e

[01:46] <sorear> stefan@stefans:~/rel/niecza$ mono run/Niecza.exe -e 'say "Hello world"'         

[01:46] <sorear> Hello world

[01:47] *** shinobicl_ joined
[02:01] *** whiteknight left
[02:07] <colomon> \o/

[02:10] <sorear> today's example of a subtle bug introduced by an editing error: $*CURLEX<!sub>.set_signature(<multisig> ?? $<multisig>[0].ast !! Any);

[02:10] <diakopter> $

[02:24] <dalek> niecza/serialize: 3842922 | sorear++ | / (3 files):

[02:24] <dalek> niecza/serialize: Reimplement "is export"

[02:24] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/3842922144

[02:27] <dalek> niecza/serialize: ba7d08c | sorear++ | lib/ (2 files):

[02:27] <dalek> niecza/serialize: Finish implementation of CATCH/CONTROL

[02:27] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/ba7d08ca58

[02:38] <dalek> niecza/serialize: 3a27812 | sorear++ | / (2 files):

[02:38] <dalek> niecza/serialize: Reduce spurious nonuse warnings

[02:38] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/3a27812c10

[02:38] <sorear> niecza can now compile Test.pm6

[02:38] <diakopter> :)

[02:38] <diakopter> how big is the serialized output

[02:38] <diakopter> compared to Test.pm6

[02:39] <sorear> stefan@stefans:~/rel/niecza$ ls -lh obj/Test.* lib/Test.*

[02:39] <sorear> -rw-r--r-- 1 stefan stefan 5.0K Sep 29 23:01 lib/Test.pm6

[02:39] <sorear> -rwxr-xr-x 1 stefan stefan  26K Oct 19 19:37 obj/Test.dll

[02:39] <sorear> -rw-r--r-- 1 stefan stefan  29K Oct 19 19:37 obj/Test.ser

[02:39] <sorear> for comparison:

[02:39] <sorear> stefan@stefans:~/rel/niecza$ ls -lh /tmp/niecza/obj/Test.*

[02:39] <sorear> -rwxr-xr-x 1 stefan stefan 44K Sep 28 20:05 /tmp/niecza/obj/Test.dll

[02:39] <sorear> -rw-r--r-- 1 stefan stefan 59K Sep 28 20:05 /tmp/niecza/obj/Test.nam

[02:40] <sorear> (that's a master checkout)

[02:41] <sorear> for fairness, note that Test.dll was self-contained in master but serialize requires the .ser at runtime

[02:42] <sorear> I wonder if it should be possible to catch WORRYs from eval using some kind of CONTROL thing

[02:44] *** yves left
[02:44] *** envi_ joined
[02:47] * ingy is @ the bay area haskell mongers meeting :)

[02:47] <ingy> O HAI sorear 

[02:47] <sorear> ...yes, ingy?

[02:48] * sorear needs to move out of the middle of nowhere someday

[02:48] <ingy> do you have a msg for the bahaskell peeps?

[02:48] <ingy> and do you have a spare couch in the middle of nowhere? :)

[02:49] <sorear> not really.  I've been absent for a while, and moreover, if they remember me it's as a teenager

[02:49] <diakopter> ingy: where do you need a couch

[02:49] <sorear> Sadly our couch is not sparable.

[02:50] *** yves joined
[02:50] <sorear> Why, is ingy going to pay the middle of nowhere a visit? :)

[02:51] <ingy> sorear: always on the move I am

[02:52] <sorear> Oh right, I remember now, you were the homeless ascetic.

[02:52] <ingy> :D

[02:52] <ingy> s/were/are

[02:53] <diakopter> ingy: there's even a spare bed/bath here. just sayin'.  10 min from SFO

[02:53] <sorear> ingy: now you're making me wonder if there's some interesting Perl/OSS event going on in my backyard

[02:54] <sorear> or if all you care about is me?  <flattered/>

[02:54] *** uasi left
[02:55] <dalek> roast: b6a2dde | Coke++ | S (3 files):

[02:55] <dalek> roast: rakudo fudging

[02:55] <dalek> roast: review: https://github.com/perl6/roast/commit/b6a2dde13a

[02:56] <dalek> rakudo/nom: 5af761e | Coke++ | t/spectest.data:

[02:56] <dalek> rakudo/nom: run more tests.

[02:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5af761e3de

[02:56] *** donri left
[02:58] *** shinobicl_ left
[03:00] *** envi_ left
[03:00] *** envi_ joined
[03:25] <dalek> niecza/serialize: 2e191e7 | sorear++ | / (2 files):

[03:25] <dalek> niecza/serialize: Implement the "use" statement

[03:25] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/2e191e79fd

[03:37] *** TimToady left
[04:01] *** molaf_ left
[04:04] *** benabik_ joined
[04:04] *** pomysl joined
[04:04] *** pomysl left
[04:04] *** pomysl joined
[04:04] *** moritz_ joined
[04:04] *** masak_ joined
[04:05] *** Yappoko___ left
[04:05] *** breinbaas left
[04:05] *** tty234 left
[04:05] *** Yappoko___ joined
[04:05] *** masak left
[04:05] *** sirmacik left
[04:05] *** moritz left
[04:05] *** benabik left
[04:05] *** PZt left
[04:05] *** benabik_ is now known as benabik

[04:06] *** breinbaas joined
[04:06] *** wolfman2000 left
[04:07] *** tty234 joined
[04:10] *** satyavvd joined
[04:10] <dalek> niecza/serialize: c7a98e8 | sorear++ | lib/CodeGen.cs:

[04:10] <dalek> niecza/serialize: Fix compilation of state-names

[04:10] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/c7a98e8756

[04:16] *** PZt joined
[04:16] <dalek> Pugs.hs/deprecations: 501306f | (Shachaf Ben-Kiki)++ | Pugs/src/ (82 files):

[04:16] <dalek> Pugs.hs/deprecations: Remove most pragma-related deprecation warnings.

[04:16] <dalek> Pugs.hs/deprecations: 

[04:16] <dalek> Pugs.hs/deprecations: Mainly by removing unneeded OPTIONS declarations (and replacing them with the

[04:16] <dalek> Pugs.hs/deprecations: appropriate LANGUAGE declarations where needed).

[04:16] <dalek> Pugs.hs/deprecations: review: https://github.com/perl6/Pugs.hs/commit/501306f62c

[04:16] <dalek> niecza/serialize: a2beb89 | sorear++ | / (2 files):

[04:16] <dalek> niecza/serialize: Fix qualified private method call compilation

[04:16] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/a2beb89d84

[04:16] <sorear> o/ shachaf

[04:16] *** satyavvd left
[04:17] <shachaf> sorear: Hello.

[04:17] * shachaf is also at bahaskell.

[04:21] *** satyavvd joined
[04:34] <dalek> Pugs.hs/deprecations: d4c5c2a | (Ingy dot Net)++ | Pugs/src/Pugs/ (7 files):

[04:34] <dalek> Pugs.hs/deprecations: Make compile on 7.2

[04:34] <dalek> Pugs.hs/deprecations: review: https://github.com/perl6/Pugs.hs/commit/d4c5c2a8d5

[04:35] <sorear> shachaf: pity, I'm not.

[04:39] <shachaf> sorear: Is the middle of nowhere in San Diego?

[04:41] *** thou joined
[04:43] *** TimToady joined
[04:49] *** moritz_ is now known as moritz

[04:50] <moritz> good morning

[04:50] <moritz> masak_: pong

[04:50] <sorear> shachaf: yes

[04:51] <dalek> roast: cc1b81e | moritz++ | S04-phasers/begin.t:

[04:51] <dalek> roast: test that BEGIN happens indeed at parse time

[04:51] <dalek> roast: review: https://github.com/perl6/roast/commit/cc1b81e67a

[04:52] <moritz> nom: say $*FATAL

[04:52] <p6eval> nom 5af761: OUTPUT«Failure.new()␤»

[04:53] <moritz> nom: use fatal; say $*FATAL

[04:53] <p6eval> nom 5af761: OUTPUT«Bool::True␤»

[04:53] <dalek> niecza/serialize: 3da8e40 | sorear++ | src/niecza:

[04:53] <dalek> niecza/serialize: Fix {} in regexes

[04:53] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/3da8e40f8f

[04:56] *** PerlJam joined
[05:00] *** amkrankruleuen left
[05:00] *** amkrankruleuen joined
[05:00] *** pnu left
[05:01] *** kfo left
[05:01] *** pochi left
[05:01] *** overrosy left
[05:01] *** pochi joined
[05:02] *** pnu joined
[05:02] *** kfo joined
[05:03] *** overrosy joined
[05:11] *** orafu left
[05:12] *** orafu joined
[05:22] <dalek> niecza/serialize: a77df2e | sorear++ | lib/Kernel.cs:

[05:22] <dalek> niecza/serialize: Fix error when protopad is created while >10 lexicals already exist

[05:22] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/a77df2e410

[05:22] <dalek> niecza/serialize: f2453c4 | sorear++ | lib/CodeGen.cs:

[05:22] <dalek> niecza/serialize: Implement defining parametric roles

[05:22] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/f2453c42b5

[05:24] *** soh_cah_toa left
[05:38] *** sftp left
[05:45] *** apejens joined
[05:47] *** preflex left
[05:49] *** dual joined
[05:50] *** mberends joined
[05:57] *** kaleem joined
[06:00] *** kfo left
[06:00] *** kfo joined
[06:06] *** koban joined
[06:13] *** MayDaniel left
[06:21] *** wtw joined
[06:23] <dalek> niecza/serialize: e7d3f3f | sorear++ | lib/ (3 files):

[06:23] <dalek> niecza/serialize: Reimplement regex_infix:<|> table generation

[06:23] <dalek> niecza/serialize: review: https://github.com/sorear/niecza/commit/e7d3f3fdcf

[06:30] * sorear wonders if it would be possible in general to assign numbers to () at the momemnt they are parsed

[06:31] <moritz> () = 1 ?

[06:32] <sorear> (foo) [ (bar) | (baz) ] (quux) / kind of thing

[06:32] <sorear> in that case yes

[06:32] <sorear> s|^|/ | # irc fail

[06:34] <moritz> iirc the numbering scheme is designed to make that possible, yes

[06:35] <moritz> [ (foo)|(b)(a)(r) ] (baz) # baz is always in $3, right?

[06:35] <sorear> right

[06:36] <sorear> currently niecza delays the numbering a bit, but it turns out /serialize potentially needs the numbers very soon indeed

[06:36] <sorear> I'm done for tonight

[06:36] * sorear sleep

[06:37] <moritz> good night

[06:45] *** SHODAN joined
[06:57] *** koban left
[07:09] *** mj41 joined
[07:34] *** mj41 left
[07:37] *** am0c joined
[07:40] *** thou left
[07:46] *** mj41 joined
[08:13] * masak_ yawns

[08:13] *** masak_ is now known as masak

[08:13] <masak> g'm #p6

[08:15] *** wk left
[08:16] <masak> "old [ticket] doesn't a priori mean irrelevant" -- [Coke]++

[08:16] <masak> also... a *year*? that's nothing. if it was five years, I might start agreeing.

[08:23] <masak> (use IO::Logging).assuming(logfile => ".log");

[08:23] <masak> now that's just crazy.

[08:27] <masak> moritz: why I pinged you. yesterday jnthn++ and I recreated the breakfast-in-Copenhagen question about "the trouble with macros and lexicals".

[08:28] <masak> aka "how the heck will that work?"

[08:29] <masak> consider

[08:29] <masak> macro foo() { my $a = 42; quasi { say $a } }; foo()

[08:30] <masak> (doesn't work in my branch yet, and now I understand a lot better why not)

[08:30] <masak> moritz: what, according to normal rules of macro expansion, does 'foo()' expand to?

[08:32] <moritz> to the same as  quasi { say 42 }, no?

[08:32] <masak> depending what you mean exactly by that, no.

[08:32] <moritz> ie references to outer lexicals are reified (replaced by their values) before applying the quasi

[08:33] <masak> nope.

[08:33] <masak> that's exactly what they're not.

[08:33] <moritz> just like if you returned "say $a"

[08:33] *** dakkar joined
[08:33] <moritz> wasn't that what you said a few days ago?

[08:33] <moritz> that we should see quasis as analog to quoted strings?

[08:33] <diakopter> what does 'quasi' mean there

[08:33] <moritz> diakopter: "give me an AST"

[08:33] <moritz> see S06/Macros

[08:34] <masak> moritz: oh, but that is what happens to *placeholders*, not ordinary variables.

[08:34] <masak> moritz: I'm sorry I made you apply the analogy too far.

[08:34] <masak> diakopter: like backquote in Lisp.

[08:34] <moritz> just to be sure I get this straight, placeholders are {{{$a}}}, right?

[08:34] <masak> aye.

[08:34] <masak> I've called them "holes" up until now.

[08:34] <masak> "placeholders" is a better term.

[08:35] <moritz> I thought "holes" were $COMPILING::a

[08:35] <masak> no, no, no :)

[08:35] <moritz> what do you call those?

[08:35] <masak> unhygiene :P

[08:35] <moritz> "pulp"

[08:35] <masak> "filth"

[08:35] <masak> "gross"

[08:36] <moritz> back to the actual question... so it's a compile-the-macro-time error?

[08:36] <masak> nope.

[08:36] <masak> it actually works and prints 42.

[08:37] <masak> by actually going and getting the $a in the macro body.

[08:37] <moritz> that would have been my next guess

[08:37] <masak> :P

[08:37] <masak> and this is what we must've realized in Copenhagen.

[08:37] <masak> that it does this, and that it's *insane*.

[08:37] <moritz> so the quasi is a closure that closes over the $a?

[08:37] <masak> yup.

[08:38] <masak> but that's not enough.

[08:38] <moritz> even though it doesn't stay in an inner scope of the macro when flattened out?

[08:38] <masak> since the AST is a "serialization" of the code and doesn't retain closure-ness.

[08:38] <masak> right.

[08:38] <masak> that's the trouble.

[08:38] <masak> so it can't just be 'say $a' or equiv out in the mainline after expansion.

[08:39] <masak> it has to be 'say SPECIAL_MACRO_MAGIC("$a")'

[08:39] <masak> er, q[$a]

[08:39] <moritz> LOOKUP_VAR_IN_FOREIGN_SCOPE('$a', :scope_id(1234567890))

[08:40] <masak> yeah.

[08:40] <moritz> that's... scary.

[08:40] <masak> as far as I can tell, it's the quasi Perl6::AST that carries around the closure.

[08:40] <moritz> action at a distance at its best

[08:41] <masak> and all lookups have to be vetted against that closure to see if they "stick" inside an OUTER chain that the mainline doesn't see.

[08:41] <masak> and then they have to be magicalized in the above way.

[08:41] <moritz> macro term:<global> { my $a; quasi { $a } }; global = 5; global = 8; say global; # doctor, it hurts when I do this

[08:41] <masak> now this is an interesting one.

[08:42] <masak> recall that there are two invocations of the macro here.

[08:42] <moritz> three :-)

[08:42] <masak> thus, two call frames and two fresh lexical pads.

[08:42] <masak> oops, yes.

[08:42] <masak> so it prints 'Any()'.

[08:42] <masak> because the 'my $a' is fresh with every macro call.

[08:42] *** molaf joined
[08:43] <masak> but the assignments work, no problem.

[08:43] <masak> they just assign to a container that you will never see again.

[08:43] <moritz> but this means you don't need to actually close over $a

[08:43] <masak> sure you do.

[08:43] <masak> you need the container.

[08:44] <moritz> so you need to create an anon container when you interpolate the macro

[08:44] <masak> well, I guess a reasonable alternative would be to fake the... right.

[08:44] <moritz> and you need to initialize it with the value that $a has at macro call time

[08:44] <moritz> but it doesn't need to reference the $a in the macro body

[08:44] <masak> I'd consider that an "optimization" or whatever.

[08:44] <moritz> because when you run the macro again, it gets a fresh $a anyway

[08:45] <masak> the real semantics are as I outlined them.

[08:45] * moritz considers it a road to sanity

[08:45] <masak> also consider

[08:45] <masak> { my $a; macro globalish() { quasi { $a } } }; globalish = 3; say globalish # 3

[08:46] <moritz> is that supposed to work?

[08:46] <masak> you ask that at every step, it seems :P

[08:46] <moritz> that's the math background

[08:46] <masak> note that my model covers this just fine.

[08:46] <masak> :)

[08:47] <masak> the AST takes a closure and stores it somewhere.

[08:47] <moritz> "is it defined? is it unique?"

[08:47] <masak> 'globalish' gets translated into the magical lookup for '$a' inside the block.

[08:50] <jnthn> morning o/

[08:50] <phenny> jnthn: 19 Oct 23:42Z <[Coke]> tell jnthn that to get the # of tickets iwth testneeded, to login to rt, then go to http://rakudo.org/rt/testneeded

[08:51] <mls_> morning jnthn!

[08:51] <moritz> that link doesn't work for me :(

[08:52] <moritz> I use https://rt.perl.org/rt3/Search/Results.html?Rows=50&Page=1&Format=%27%20%20%20%3Cb%3E%3Ca%20href%3D%22%2Frt3%2FTicket%2FDisplay.html%3Fid%3D__id__%22%3E__id__%3C%2Fa%3E%3C%2Fb%3E%2FTITLE%3A%23%27%2C%0A%27%3Cb%3E%3Ca%20href%3D%22%2Frt3%2FTicket%2FDisplay.html%3Fid%3D__id__%22%3E__Subject__%3C%2Fa%3E%3C%2Fb%3E%2FTITLE%3ASubject%27%2C%0A%27__Status__%27%2C%0A%27__QueueName__%27%2C%0A%27__OwnerName__%27%2C%0A%27__Priority__%27%2C%0A%27__NEWLINE__%27%2C%0A%27%27

[08:52] <moritz> urk, cut off

[08:53] <moritz> http://tinyurl.com/testneeded

[08:53] <jnthn> That one owrks for me :)

[08:53] <jnthn> moritz++

[08:53] <moritz> also available from http://rakudo.de/testneeded

[08:54] * jnthn wonders why the rakudo.org one only works for some people :)

[08:54] <moritz> jnthn: RT URLs changed; it used to work for me too

[08:55] <masak> it's a meritocracy, so it only works for some.

[08:55] <moritz> :-)

[09:03] <masak> moritz: reading the spec, I think calling COMPILING:: variables "variables in the compiling scope" makes the most sense.

[09:04] <dalek> roast: e42a6ad | moritz++ | S02-types/whatever.t:

[09:04] <dalek> roast: tests for RT #77000

[09:04] <dalek> roast: review: https://github.com/perl6/roast/commit/e42a6ad352

[09:04] <masak> macros are fun because they involve three actors: the macro routine, the quasi, and the compiling scope.

[09:08] <moritz> mls_: your parrot patch to IO::Select fixed the problem segfaults

[09:08] <moritz> s/problem/

[09:08] <moritz> mls_: at least I haven't seen any since then

[09:08] <jnthn> .oO( there are non-problem segfaults? :) )

[09:09] <masak> jnthn: that was an alternative ending to Independence Day: they caused a segfault in the mothership.

[09:10] <moritz> poor aliens

[09:10] *** jedai_ left
[09:10] <snarkyboojum> I'm trying to imagine the mothership dropping a huge core dump

[09:11] <snarkyboojum> btw, hi #perl6 :D

[09:12] <masak> snarkyboojum! \o/

[09:12] *** jedai joined
[09:12] <dalek> roast: b653885 | moritz++ | S06-signature/optional.t:

[09:12] <dalek> roast: test for RT #76728, assigning to optional hash param

[09:12] <dalek> roast: review: https://github.com/perl6/roast/commit/b6538850f5

[09:12] <snarkyboojum> masak: hey! enjoying your macro posts/comments...

[09:15] <jnthn> moritz++ # eating into testneeded

[09:15] <snarkyboojum> masak: also linked off from a url you posted yesterday, a couple of very interesting video talks by the creator or Ioke - http://blip.tv/carlfk/ioke-a-folding-language-1-of-2-2240400 etc

[09:15] <snarkyboojum> so cheers for that :)

[09:17] <masak> \o/

[09:17] <masak> I have two more macro posts in the (mental) pipe.

[09:18] <masak> one is "how abstractions and late binding are *everywhere* and on every level"

[09:18] <masak> the other is "Frequenty (and not so frequently) Asked Questions about macros"

[09:19] <moritz> I'd be particularly interested in the first one

[09:19] <masak> me too. I'm currently researching it.

[09:20] <moritz> :-)

[09:20] <snarkyboojum> masak: awesome - check out those Ioke vids if you get the time.. he talks about macros in there too :D

[09:20] <masak> snarkyboojum: ok, thanks. I will.

[09:20] <snarkyboojum> masak: some crazy/clever Swedish dude :)

[09:20] <masak> oh, that guy :P

[09:20] <snarkyboojum> heh

[09:21] <masak> moritz: variables are a late binding of values. subroutines are a late binding on code structure. classes/inheritance/roles are a late binding on algorithms. macros are a late binding on syntax.

[09:21] <masak> something like that.

[09:22] <masak> s/<<on>>/of/

[09:22] <moritz> dispatch tables are late binding of dispatch

[09:22] <masak> yeah. multi subs factor in there somehwere too, true.

[09:23] <masak> looking at the past 60-70 years of computer programming from this perspective is intriguing.

[09:23] <masak> in the olden days, everything was hard-coded. even the programs where wired into the machine.

[09:24] <masak> nowadays we're finding abstractions to make the right things soft so that we can change them more easily.

[09:25] * flussence misread that first bit as "60-70 days"...

[09:27] *** wk joined
[09:27] <moritz> and curiously, whenever somebody proposes to make another things soft, the first reaction is "I wonder what that will break"

[09:29] <snarkyboojum> been thinking about similar things dealing with virtualised hardware/platforms at work lately a la the elastic cloud amazon is/has been building

[09:37] *** preflex joined
[09:42] <dalek> roast: 6e4c316 | moritz++ | S03-operators/binding-scalars.t:

[09:42] <dalek> roast: test for RT #76508, binding variable to itself

[09:42] <dalek> roast: review: https://github.com/perl6/roast/commit/6e4c316249

[09:42] * masak emailed karen@tpf

[09:43] <masak> moritz: yes, because this tower-building isn't trivial. it takes decades to find out what abstractions are stable and pull their own weight. cf. OO

[09:44] <jnthn> .oO( Frequently Questions Answers About Macros )

[09:44] <jnthn> *questione

[09:44] <jnthn> gah

[09:44] <jnthn> questioned...

[09:44] <jnthn> Can't even type on the one keyboard I actually like now...

[09:44] <masak> actually, this process of finding new late-bind cuts is complemented by the process of chunking things down into smarter syntax.

[09:45] <masak> for example, structured programming allowed us to start reasoning properly about loops and conditions, even though it was "just" syntactic sugar.

[09:46] <colomon> pretty much everything in higher level langauges is "just" syntactic sugar.  :)

[09:47] <moritz> hm... no.

[09:50] <masak> I think I used to think so :)

[09:52] <snarkyboojum> how about semantic sugar :D

[09:53] <masak> I find your ideas fascinating and I want to subscribe to your newsletter.

[09:56] *** uasi joined
[09:56] * moritz grins

[09:59] <colomon> anyone know the right syntax for hash :exists off the top of their head?

[10:00] <moritz> %h<key>:exists

[10:00] <moritz> niecza: my %h; say %h<key>:exists

[10:00] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Bool::False␤»

[10:00] <moritz> niecza: my %h = key => Mu; say %h<key>:exists

[10:00] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Bool::True␤»

[10:00] <moritz> or %h{'key'}>exists if you prefer that

[10:01] <colomon> niecza: my $h; say %h{'key'}:exists

[10:01] <p6eval> niecza v10-58-gc851cf8: OUTPUT«===SORRY!===␤␤Variable %h is not predeclared at /tmp/4opglomVLI line 1:␤------> my $h; say ⏏%h{'key'}:exists␤␤Potential difficulties:␤  $h is declared but not used at /tmp/4opglomVLI line 1:␤------> my ⏏$…

[10:01] <colomon> niecza: my $h; say %h{'key'}>exists

[10:01] <p6eval> niecza v10-58-gc851cf8: OUTPUT«===SORRY!===␤␤Variable %h is not predeclared at /tmp/Bk7nGRcvdY line 1:␤------> my $h; say ⏏%h{'key'}>exists␤␤Undeclared routine:␤  'exists' used at line 1␤␤Potential difficulties:␤  $h is declared but not used at /tmp/B…

[10:02] <colomon> niecza: my %h; say %h{'key'}>exists

[10:02] <p6eval> niecza v10-58-gc851cf8: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'exists' used at line 1␤␤␤Unhandled Exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 766 (CORE die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1136 (STD P6.comp_unit @ 36)…

[10:02] <colomon> niecza: my %h; say %h{'key'}:exists

[10:02] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Bool::False␤»

[10:02] <colomon> niecza: my %h; say !%h{'key'}:exists

[10:02] <p6eval> niecza v10-58-gc851cf8: OUTPUT«␤Unhandled Exception: Excess arguments to CORE prefix:<!>, unused named exists␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CORE prefix:<!> @ 0) ␤  at /tmp/073DhM95aj line 1 (MAIN mainline @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2176 (COR…

[10:02] <moritz> needs parens

[10:02] <colomon> niecza error, std error, or colomon error?

[10:02] <colomon> yes, it works fine with parens

[10:03] <jnthn> Or use "not" and avoid the parens

[10:05] <moritz> colomon: spec nastiness, I assume

[10:05] <colomon> man, I've got something weird going on in my code here.

[10:06] <moritz> colomon: there are rules based on operator precdence about where the adverbs belong to. They sometimes surprise you.

[10:07] <colomon> niecza: say <"a", "b", "c", "d", "e", "f">.pick(5).perl

[10:07] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(""f"", ""d",", ""c",", ""a",", ""e",").list␤»

[10:07] <colomon> duh

[10:07] <colomon> niecza: say <a, b, c, d, e, f>.pick(5).perl

[10:07] <p6eval> niecza v10-58-gc851cf8: OUTPUT«("d,", "c,", "f", "e,", "a,").list␤»

[10:08] <masak> sorear: that .perl output is wrong. submitting nieczabug.

[10:08] <colomon> no it's not

[10:08] <masak> the quotes aren't escaped.

[10:08] <colomon> ... okay, yes it is

[10:08] <masak> the one two evals back is clearly wrong.

[10:08] <colomon> niecza: say <a b c d e f>.pick(5).perl

[10:08] <p6eval> niecza v10-58-gc851cf8: OUTPUT«("d", "e", "b", "a", "f").list␤»

[10:09] <colomon> I think .pick is slightly broken, but for some reason I can't get it to duplicate here, and it happens all the time in my code.  :\

[10:09] <masak> perl6: say "\"".perl

[10:09] <p6eval> niecza v10-58-gc851cf8: OUTPUT«"""␤»

[10:09] <p6eval> ..pugs b927740, rakudo 5af761: OUTPUT«"\""␤»

[10:11] <colomon> niecza: say <a b c d e f>.pick(6).perl

[10:11] <p6eval> niecza v10-58-gc851cf8: OUTPUT«("f", "c", "d", "b", "e", "a").list␤»

[10:11] <colomon> niecza: say (2, 13, 18, 12, 24, 31, 30, 15, 39, 38, 35, 23, 33, 37, 36, 21, 48, 5, 47, 0, 49, 3, 40, 41, 43).pick(5).perl

[10:11] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(30, 5, 36, 48, 39).list␤»

[10:11] <colomon> niecza: say (2, 13, 18, 12, 24, 31, 30, 15, 39, 38, 35, 23, 33, 37, 36, 21, 48, 5, 47, 0, 49, 3, 40, 41, 43).pick(5).perl

[10:11] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(0, 47, 12, 23, 24).list␤»

[10:13] <colomon> niecza: my @a = <a b c d e>; my %f = @a X 1; say @a.perl

[10:13] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Potential difficulties:␤  %f is declared but not used at /tmp/ULeWst6_K1 line 1:␤------> my @a = <a b c d e>; my ⏏%f = @a X 1; say @a.perl␤␤["a", "b", "c", "d", "e"].list␤»

[10:16] <colomon> niecza: my @a = <f s h w d r t>; my @b = @a.pick(5); say @b.perl; @a = @a.sort; say @b.perl;

[10:16] <p6eval> niecza v10-58-gc851cf8: OUTPUT«["d", "t", "w", "r", "f"].list␤["d", "t", "w", "r", "f"].list␤»

[10:16] * colomon is getting spooky action-at-a-distance in his code, but is having trouble golfing it

[10:17] * colomon is also listening to his 3-year-old gently singing in his bed, when by all reasonable measures they both should be asleep

[10:19] *** uasi left
[10:19] *** mtk left
[10:25] *** saaki left
[10:26] *** saaki joined
[10:27] <colomon> it seems like .pick is giving me a reference into the original array rather than just the Int values in the array.  

[10:27] <colomon> hmmm, int values;

[10:28] *** envi_ left
[10:28] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; my @b = @a.pick; say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl;

[10:28] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[5].list␤[5].list␤»

[10:29] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; my @b = @a.pick(5); say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl;

[10:29] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[9, 6, 8, 1, 4].list␤[9, 6, 8, 1, 4].list␤»

[10:30] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; sub test(@b) { say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl }; test(@a.pick(5));

[10:30] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(9, 3, 8, 1, 7).list␤(4, 2, 2, 4, 5).list␤»

[10:30] <colomon> bingo!

[10:31] <moritz> rakudo: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; sub test(@b) say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl }; { test(@a.pick(5));

[10:31] <p6eval> rakudo 5af761: OUTPUT«===SORRY!===␤Malformed block at line 1, near "say @b.per"␤»

[10:31] *** envi_ joined
[10:31] <moritz> rakudo: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; sub test(@b) { say @b.perl }; @a = @a.sort({ $^a <=> $^b }); say @b.perl; test(@a.pick(5));

[10:31] <p6eval> rakudo 5af761: OUTPUT«===SORRY!===␤Symbol '@b' not predeclared in <anonymous> (/tmp/77WVyaIYMm:1)␤»

[10:32] * moritz can't even copy&paste

[10:33] <colomon> rakudo: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; sub test(@b) { say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl }; test(@a.pick(5));

[10:33] <p6eval> rakudo 5af761: OUTPUT«(6, 9, 1, 7, 2).list␤(6, 9, 1, 7, 2).list␤»

[10:35] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; my @b = @a.pick(5); say @b.perl

[10:35] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[10, 3, 6, 5, 1].list␤»

[10:35] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; my @b = @a.pick(5); say @a.perl; say @b.perl

[10:35] <p6eval> niecza v10-58-gc851cf8: OUTPUT«[10, 9, 8, 7, 6, 5, 4, 3, 2, 1].list␤[5, 10, 1, 9, 6].list␤»

[10:35] <colomon> okay, I completely don't understand how this can be happening

[10:36] <colomon> .... or I guess, if everything is a very shallow clone ...

[10:36] <colomon> what a terrible thing to find at 2am sorear++ time...

[10:37] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; sub test(@b) { say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl }; test(@a.pick(5));

[10:37] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(9, 10, 4, 1, 7).list␤(3, 2, 3, 3, 5).list␤»

[10:37] <colomon> sorear: ^^ 

[10:47] *** uasi joined
[10:50] *** benabik left
[10:58] *** Alias left
[10:59] *** Alias joined
[10:59] <colomon> niecza: my @a = 10, 9, 8, 7, 6, 5, 4, 3, 2, 1; sub test(@b) { say @b.perl; @a = @a.sort({ $^a <=> $^b }); say @b.perl }; test(@a.pick(5).map(*+0));

[10:59] <p6eval> niecza v10-58-gc851cf8: OUTPUT«(8, 10, 5, 1, 7).list␤(8, 10, 5, 1, 7).list␤»

[11:12] *** kaleem left
[11:15] *** kaleem joined
[11:18] *** wk left
[11:19] *** pomysl is now known as sirmacik

[11:21] *** lestrrat left
[11:22] *** mtk joined
[11:22] *** lestrrat joined
[11:25] *** uasi left
[11:35] *** replore left
[11:39] *** benabik joined
[11:41] *** Patterner left
[11:43] *** Psyche^ joined
[11:43] *** Psyche^ is now known as Patterner

[11:51] *** whiteknight joined
[11:54] *** GlitchMr joined
[11:56] <masak> sorear: how feasible is it to implement 'my @a[ 10 ; 10 ]' in Niecza currently?

[12:05] *** abercrombie joined
[12:25] <flussence> rakudo: my $chars = 4; my $text = 'abcdefghij'; my $rx = rx/(\N ** {0..$chars}) $ /; say $text.match($rx, :pos(0)).perl;

[12:25] <p6eval> rakudo 5af761: OUTPUT«Match.new(orig => "abcdefghij", from => 0, to => 10, ast => Mu, list => (Match.new(orig => "abcdefghij", from => 0, to => 10, ast => Mu, list => ().list, hash => EnumMap.new()),).list, hash => EnumMap.new())␤»

[12:25] <flussence> rakudo: my $chars = 4; my $text = 'abcdefghij'; my $rx = rx/(\N ** {0..$chars}) $ /; say $text.match($rx).perl;

[12:25] <p6eval> rakudo 5af761: OUTPUT«Match.new(orig => "abcdefghij", from => 0, to => 10, ast => Mu, list => (Match.new(orig => "abcdefghij", from => 0, to => 10, ast => Mu, list => ().list, hash => EnumMap.new()),).list, hash => EnumMap.new())␤»

[12:26] <flussence> I know /. ** {5}/ isn't working, but I'm sure at least ranges like that were working a few days ago...

[12:26] *** sftp joined
[12:28] *** im2ee joined
[12:28] <im2ee> Hello! :)

[12:28] <tadzik> hello im2ee 

[12:30] <im2ee> tadzik, i saw Your solution to my problem. :) Thanks :)

[12:30] <tadzik> you're welcome

[12:31] <im2ee> I will continue my work this weekend. :)

[12:34] <masak> hello im2ee :)

[12:55] <dalek> ecosystem: 61b0e91 | (Aliaksandr Zahatski)++ | META.list:

[12:55] <dalek> ecosystem: add plosurin - Perl 6 implementation of Closure Templates

[12:55] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/61b0e918d7

[12:55] <dalek> ecosystem: c2180ce | tadzik++ | META.list:

[12:55] <dalek> ecosystem: Merge pull request #7 from zag/master

[12:55] <dalek> ecosystem: 

[12:55] <dalek> ecosystem: add Plosurin - Perl 6 implementation of Closure Templates

[12:55] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/c2180ce858

[12:57] * moritz gives zag a commit bit

[12:57] *** kaleem left
[12:59] *** satyavvd left
[13:03] <tadzik> good idea

[13:05] *** smash joined
[13:05] *** replore joined
[13:06] <smash> hello everyone

[13:06] <moritz> \o smash 

[13:09] <dalek> roast: ea311cc | moritz++ | S05-substitution/subst.t:

[13:09] <dalek> roast: RT #76664

[13:09] <dalek> roast: review: https://github.com/perl6/roast/commit/ea311cc6f1

[13:10] *** shinobicl joined
[13:11] *** Holy_Cow joined
[13:11] *** GlitchMr left
[13:14] <colomon> tadzik: do you understand what Plosurin is?

[13:15] <colomon> ah, http://code.google.com/closure/templates/ -- maybe?

[13:15] <tadzik> colomon: unsure. I think it generates Perl 5 code or so

[13:16] <PerlJam> What's Plosurin?

[13:16] <moritz> 14:55 <+dalek> ecosystem: add Plosurin - Perl 6 implementation of Closure Templates

[13:17] <moritz> PerlJam: how's the release going?

[13:17] <PerlJam> moritz: not at all yet.  Probably not going to get started for several hours

[13:18] <moritz> PerlJam: ok; let me know if you need any help, I might have tuits

[13:18] *** JimmyZ joined
[13:20] <JimmyZ> Is there a bool type? 

[13:20] <moritz> no, just Bool

[13:20] *** cognominal left
[13:20] <PerlJam> There's one thing I can do right now though ...

[13:21] <dalek> rakudo/nom: e17c139 | duff++ | docs/release_guide.pod:

[13:21] <dalek> rakudo/nom: Choose a release name

[13:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e17c139a37

[13:22] *** uasi joined
[13:23] <JimmyZ> maybe int1

[13:24] <moritz> unit1 iirc

[13:25] *** whiteknight left
[13:26] <masak> no, there's an int1 too.

[13:26] <masak> and a joke about it in the spec.

[13:26] <masak> (it has the values 0 and -1)

[13:26] <moritz> b: my $x = do { class X {} }; say $x

[13:26] <p6eval> b 1b7dd1: OUTPUT«!class_init_72␤»

[13:27] <jnthn> nom: my $x = do { class X {} }; say $x

[13:27] <p6eval> nom 5af761: OUTPUT«X()␤»

[13:27] <JimmyZ> nom++ ?

[13:27] <jnthn> yes, nom is correct here

[13:31] *** bluescreen100 joined
[13:32] <moritz> b: my $x = class X {}; say $x

[13:32] <p6eval> b 1b7dd1: OUTPUT«!class_init_72␤»

[13:32] <moritz> b: my $x = class X {}; say $x ~~ X

[13:32] <p6eval> b 1b7dd1: OUTPUT«Bool::False␤»

[13:32] <moritz> ok, that's how I can test it

[13:32] <JimmyZ> nom: my $x = class X {} ; say $x

[13:33] <p6eval> nom 5af761: OUTPUT«X()␤»

[13:33] *** bluescreen10 left
[13:38] *** ponbiki left
[13:40] <dalek> roast: 15664cb | moritz++ | S12-class/basic.t:

[13:40] <dalek> roast: test for RT #76270, named class declaration should return the class

[13:40] <dalek> roast: review: https://github.com/perl6/roast/commit/15664cb53b

[13:43] <moritz> pmichaud: are there any nqp changes you want to make today that should go into the rakudo release?

[13:44] *** SHODAN left
[13:44] <moritz> ("don't know yet" is also a fine answer)

[13:45] *** GlitchMr joined
[13:46] *** bluescreen10 joined
[13:48] <pmichaud> don't know yet; I have nqp changes coming soonish but I can't give a good enough time estimate to warrant holding the release for them

[13:48] <pmichaud> so, if they make it, great; if not, we'll just get them in the next (possibly 'special') release

[13:49] <jnthn> Yes, I'd really like us to get back to time-based releases.

[13:49] <moritz> pmichaud: that's fine; the background was just that if you hadn't planned NQP changes at all, I would have tagged nqp now

[13:49] <pmichaud> well, I think we're fine with time-based releases.  I thought we were going to give ourselves a bit more time between parrot and regular release, but it looks like we're sticking with the 2-days-later approach?

[13:50] <moritz> as is, PerlJam++ will do it close to the rakudo release

[13:50] <pmichaud> I think that nqp tagging should (for now) be close to the rakudo release, yes.

[13:51] <tadzik> yeah, I was supposed to have an eye on that, so we won't get the madness from the last month

[13:51] <jnthn> afk for half an hour or so

[13:52] *** kaare_ joined
[13:54] <masak> (time-based releases)++

[13:55] <masak> turned out it was important for morale not just within the Perl 6 group, but within the larger Perl community as well.

[13:55] *** Sarten-X left
[13:57] *** thou joined
[13:58] <pmichaud> so, we're all agreed about time-based releases.   Are we also sticking to the 2-days-after-parrot-release timing?

[13:58] *** thou left
[13:58] <masak> dontmuchcare

[13:59] <masak> do whatever makes sense.

[13:59] <moritz> I'm +1 to the current practise, which seems to be "target 2 days after parrot release, bug let it slack for a few days if necessary. Stay within the same month as the parrot release"

[13:59] <moritz> s/bug/but/

[13:59] <pmichaud> I'm fine with that.

[13:59] <masak> +1 for "same month" :)

[13:59] <pmichaud> should we change the text to read "shortly after Parrot monthly releases", then?

[13:59] <moritz> yes

[14:00] <moritz> nom: say (1 Z 2).[0].WHAT

[14:00] <p6eval> nom e17c13: OUTPUT«Parcel()␤»

[14:01] <pmichaud> that looks like a bug to me

[14:01] <masak> nom: say (1 Z 2)[0][0][0].WHAT

[14:01] <p6eval> nom e17c13: OUTPUT«Int()␤»

[14:01] <pmichaud> nom:  say (1 Z 2).perl

[14:01] <dalek> rakudo/nom: bfedd99 | moritz++ | src/core/List.pm:

[14:01] <dalek> rakudo/nom: Implement simplest form of List.tree

[14:01] <dalek> rakudo/nom: 

[14:01] <dalek> rakudo/nom: You can now say

[14:01] <dalek> rakudo/nom: 

[14:01] <dalek> rakudo/nom:    for (1, 2 Z 10, 20).tree { }

[14:01] <dalek> rakudo/nom: 

[14:01] <p6eval> nom e17c13: OUTPUT«((1, 2),).list␤»

[14:01] <dalek> rakudo/nom: and have the loop bind $_ to the parcels (1, 10) and (2, 20) in turn

[14:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bfedd995b5

[14:01] <moritz> nom: say 1[0].perl

[14:01] <p6eval> nom e17c13: OUTPUT«1␤»

[14:02] <pmichaud> nom:  say ((1,2),).[0]

[14:02] <p6eval> nom e17c13: OUTPUT«1␤»

[14:02] <pmichaud> nom:  say ((1,2),).[0].WHAT

[14:02] <p6eval> nom e17c13: OUTPUT«Int()␤»

[14:02] <moritz> evalbot rebuild nom

[14:02] <p6eval> OK (started asynchronously)

[14:02] <masak> now I agree with pmichaud. looks like bug.

[14:02] <moritz> waitwaitwait

[14:03] <moritz> do () around literals flatten?

[14:03] <JimmyZ> I'm curious, what does my $ = $_  means ?

[14:03] <pmichaud> fwiw,   $_ should never bind to a parcel.

[14:03] <JimmyZ> and sometimes it doesn't work 

[14:03] <moritz> JimmyZ: it's a way to put stuff in scalar context

[14:03] <moritz> pmichaud: why not?

[14:04] <pmichaud> parcels are "invisible" -- they tend to flatten out

[14:04] <JimmyZ> nom: my $ = $_

[14:04] <p6eval> nom e17c13:  ( no output )

[14:04] <moritz> maybe .item would have worked too

[14:04] <JimmyZ> hmm, last time I tried it ,but didn't work

[14:05] <pmichaud> let me re-check the .tree spec.... but if you do .tree then it should result in $_ binding to individual Lists

[14:05] *** Sarten-X joined
[14:05] <moritz> pmichaud: well, I can't stick to the spec in your head until it's written down, and the currently written spec seems to disagree with rakudo on quite many points

[14:06] <pmichaud> well, the currently written spec disagrees with TimToady++ on most of these points also :)

[14:06] <moritz> I think it says List, but I don't see why it'd need to be List

[14:06] <JimmyZ> nom: $_ = 1, 2, 3, 5; say my $ = $_; 

[14:06] <p6eval> nom e17c13: OUTPUT«1␤»

[14:06] <pmichaud> because Parcels tend to be invisible.  that's not just in my head, that's the way all of the discussions have been.

[14:06] <moritz> ie why should .tree involve type conversion, when it's really about flattening and non-flattening, which (IIUC) isn't tied to types at all

[14:06] <JimmyZ> nom: $_ = 6, 2, 3, 5; say my $ = $_; 

[14:06] <p6eval> nom e17c13: OUTPUT«6␤»

[14:06] <pmichaud> .tree is all about converting things into LoLs

[14:07] <pmichaud> which is a type conversion

[14:07] <moritz> pmichaud: so should infix:<Z> return parcels in the first place?

[14:07] <pmichaud> I think so, yes.

[14:07] <moritz> then I don't understand the "Parcels tend to be invisible" statement

[14:08] <masak> they tend to collapse into other things.

[14:08] <pmichaud> S02:2139

[14:08] <pmichaud> Unlike C<Capture> objects, C<Parcel> objects are ephemeral, insofar as the

[14:08] <pmichaud> user almost never sees one as a real standalone object, since binding or

[14:08] <pmichaud> assignment always turns a parcel into something else.

[14:09] <moritz> so if assignment is fixed in rakudo, my code stops returning parcels :-)

[14:09] <moritz> s/if/when/

[14:10] <pmichaud> anyway, .tree should return a LoL, where each element at the top level is a List

[14:11] <moritz> nom: say MapIter.new(:list(1, 2 Z 10, 20), :block({ my $ = .list })).list.[0]

[14:11] <p6eval> nom e17c13: OUTPUT«1 10␤»

[14:12] <moritz> nom: say MapIter.new(:list(1, 2 Z 10, 20), :block({ my $ = .list })).list.[0].WHAT

[14:12] <p6eval> nom e17c13: OUTPUT«List()␤»

[14:12] <JimmyZ> nom: my @a = 1 ... 5; say my $ = @a

[14:12] <p6eval> nom e17c13: OUTPUT«1 2 3 4 5␤»

[14:12] <moritz> though probably needs to be  $_ ~~ Parcel ?? list !! $_

[14:13] <pmichaud> that ~~ Parcel is suspect, though.

[14:13] <moritz> nom: my @a = 1 ... 5; my $counter = 0; for my $ = @a { $counter++ }; say $counter

[14:13] <p6eval> nom e17c13: OUTPUT«1␤»

[14:13] <moritz> nom: my @a = 1 ... 5; my $counter = 0; for @a { $counter++ }; say $counter

[14:13] <p6eval> nom e17c13: OUTPUT«5␤»

[14:14] <moritz> pmichaud: the spec explicitly talks about Parcel sublists

[14:14] * moritz feels the pain of low communication bandwith

[14:15] <moritz> thing is, if I just call .list, it will also convert hashes

[14:15] <pmichaud> sure, Parcels exist -- they just aren't typically visible via variables.

[14:15] <JimmyZ> nom: my @a = 1 ... 5; my $counter = 0; for my $ = @a { .say };

[14:15] <p6eval> nom e17c13: OUTPUT«1 2 3 4 5␤»

[14:16] <pmichaud> I don't think you need to call .list at all -- just .item should do it.

[14:16] <moritz> nom: say Parcel.new.item.WHAT

[14:16] <p6eval> nom e17c13: OUTPUT«Parcel()␤»

[14:17] <moritz> should I change that to do a .list.item?

[14:17] <pmichaud> hrm

[14:17] <pmichaud> I'm thinking that Parcel's  "item" method should do .list.item

[14:17] <pmichaud> maybe.

[14:18] *** wtw left
[14:18] <pmichaud> fwiw, there's not a grand design in my head on the list spec -- I'm just parroting things that TimToady has said in the past about lists (and the logical consequences of things that were said)

[14:18] <JimmyZ> nom: my @a = 1 ... 5; my $counter = 0; for my $ = @a { .WHAT.say };

[14:18] <p6eval> nom e17c13: OUTPUT«Array()␤»

[14:19] <moritz> nom: my @a = 1, 2; say @a.flattens; say (my $ = @a).flattens

[14:19] <p6eval> nom e17c13: OUTPUT«1␤1␤»

[14:19] <JimmyZ> it's still a Array()?

[14:19] <pmichaud> note that nom's .flattens doesn't mean the same as niecza's .flattens

[14:19] <moritz> this is not the droi^W method I'm looking for

[14:20] <pmichaud> there's not a method that tells you if an expression interpolates in list context

[14:20] <JimmyZ> nom: my @a = 1 ... 5; my $counter = 0; for my $ = @a { .perl.say };

[14:20] <p6eval> nom e17c13: OUTPUT«[1, 2, 3, 4, 5]␤»

[14:20] <pmichaud> at least, not yet.

[14:20] <moritz> such a thing would be very useful

[14:20] <JimmyZ> nom: my @a = 1 ... 5; my $counter = 0; @a.perl.say

[14:20] <p6eval> nom e17c13: OUTPUT«Array.new(1, 2, 3, 4, 5)␤»

[14:20] <moritz> given that type introspection doesn't tell me

[14:20] <pmichaud> what's the use case, ooc?

[14:21] <moritz> nom: my @a = (1, 2); say nqp::iscont(@a); say nqp::iscont(my $ = @a)

[14:21] <p6eval> nom e17c13: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤  in sub say at src/gen/CORE.setting:5251␤  in block <anon> at /tmp/oHeOCTWHvk:1␤  in <anon> at /tmp/oHeOCTWHvk:1␤»

[14:21] <moritz> pmichaud: the first I can think of is debugging

[14:21] <pmichaud> right; I'm curious about "besides debugging"  I guess.

[14:21] <pmichaud> (not that debugging is unimportant)

[14:21] <moritz> nom: my @a = (1, 2); pir::say nqp::iscont(@a); pir::say nqp::iscont(my $ = @a)

[14:21] <p6eval> nom e17c13: OUTPUT«0␤1␤»

[14:21] <moritz> @a is not a container? :-)

[14:22] <pmichaud> actually, there's a bug with @a in general

[14:22] * [Coke] ponders adding a skype channel or something to phasers.

[14:22] <pmichaud> I've mentioned it to jnthn++ before but it's not a trivial fix.

[14:22] <moritz> pmichaud: recursive traversal of stuff

[14:22] * [Coke] is kind of freaked out to see all this pmichaud++ activity today!

[14:22] <pmichaud> nom:  my @a;  say @a.defined;   # wrong

[14:22] <p6eval> nom e17c13: OUTPUT«Bool::True␤»

[14:22] <[Coke]> . o O (In a good way!)

[14:23] <moritz> pmichaud: say I want to create a (modified) recursive copy of a data structure. I need to preserve the interpolating/non-interpolating bits

[14:23] <pmichaud> when done correctly, I suspect that @a needs to become a flattening container

[14:24] <pmichaud> moritz: yeah, at that point the Parcels have to become visible somehow.

[14:25] <moritz> how, if both binding and assignment kills them? :-)

[14:25] <pmichaud> well, nom currently belives that binding in the := sense doesn't kill a Parcel

[14:25] <pmichaud> although binding in the ::=  sense does.

[14:25] <pmichaud> (or should)

[14:25] <pmichaud> so, if you use := bindings, then you can get to the Parcels

[14:26] <pmichaud> (and note that parameter passing / pointy blocks use ::= binding, which would kill the Parcel)

[14:26] *** whiteknight joined
[14:26] * jnthn back

[14:27] <jnthn> := binding is very primitive

[14:27] <[Coke]> ~/ the gangs all here /~

[14:29] <[Coke]> nom: say 706 - 85

[14:29] <p6eval> nom e17c13: OUTPUT«621␤»

[14:29] <jnthn> moritz++ # down to 84 tickets with testneeded

[14:30] <[Coke]> rakudo: multi f ($ (Int :$value)) { say "Int $value" }; multi f($ (Str :$value)) { say "Str $value" }; f('a' => 3); f('a' => 'foo')

[14:30] <p6eval> rakudo e17c13: OUTPUT«No applicable candidates found to dispatch to for 'f'. Available candidates are:␤:(Any)␤:(Any)␤␤  in block <anon> at /tmp/VKxxeUL8D4:1␤  in <anon> at /tmp/VKxxeUL8D4:1␤»

[14:31] <[Coke]> rakudo: (1/2).Capture.perl.say

[14:31] <p6eval> rakudo e17c13: OUTPUT«Capture.new()␤»

[14:31] <jnthn> Those $ are a bit superstitious.

[14:31] <jnthn> It won't bind because there's a key named argument too

[14:31] <[Coke]> jnthn: it's an old ticket.

[14:31] <moritz> rakudo: (1/2).Capture.keys.perl

[14:31] <p6eval> rakudo e17c13: OUTPUT«SixModelObject does not support the clone v-table; consider using the repr_clone op instead␤  in method list at src/gen/CORE.setting:3563␤  in method keys at src/gen/CORE.setting:3620␤  in block <anon> at /tmp/GECKp2180y:1␤  in <anon> at /tmp/GECKp2180y:1␤»…

[14:31] <[Coke]> https://rt.perl.org/rt3/Ticket/Display.html?id=77950

[14:32] <jnthn> wtf...

[14:32] <pmichaud> ....clone?

[14:32] <pmichaud> clone is Evil.

[14:32] <[Coke]> moritz! I'm trying to CLOSE tickets here. ;)

[14:32] <jnthn> pmichaud: Yes, should never happen.

[14:32] <jnthn> pmichaud: 6model objects throw an exception if you try.

[14:32] <moritz> [Coke]: I guess that Capture.perl is broken-ish

[14:32] <moritz> rakudo: (1/2).Capture.hash.perl

[14:32] <p6eval> rakudo e17c13:  ( no output )

[14:32] <[Coke]> jnthn: anyway, if you want to comment on #77950 (it was your code in the first place! ;) I'd appreciate it.

[14:32] <moritz> rakudo: say (1/2).Capture.hash.perl

[14:32] <p6eval> rakudo e17c13: OUTPUT«EnumMap.new("numerator", 1, "denominator", 2, )␤»

[14:33] <jnthn> nom: multi f ((Int :$value, *%)) { say "Int $value" }; multi f((Str :$value, *%)) { say "Str $value" }; f('a' => 3); f('a' => 'foo')

[14:33] <p6eval> nom e17c13: OUTPUT«Int 3␤Str foo␤»

[14:33] <jnthn> [Coke]: The code in the ticket would need to be the above to work; note the extra *%

[14:33] <moritz> .hash returns an EnumMap. How amusing :-)

[14:33] <pmichaud> phenny: tell PerlJam  if you could work on RT #97102 as part of the release it would be really awesome.  msg me if you need some ideas.  kthx

[14:33] <phenny> pmichaud: I'll pass that on when PerlJam is around.

[14:33] <jnthn> (to slurp up key)

[14:33] <jnthn> moritz: It's .hash, not .Hash :)

[14:34] <jnthn> Maybe we need to make them reflect associative and positional better

[14:34] <[Coke]> jnthn: so, given that, we can reject the ticket? ;)

[14:34] <jnthn> .ass and .pos :)

[14:34] <moritz> jnthn: that's why I said "amusing" and not "wrong"

[14:34] <jnthn> ...er, no, NOT .ass :)

[14:34] <moritz> ... and NOT .pos

[14:34] <pmichaud> .keyed and .posed

[14:35] <pmichaud> iiuc, a .pos is what comes out of most people's .ass   (SORRY!)

[14:35] * moritz thinks of _keyed_ vtables and wants to run

[14:35] <jnthn> [Coke]: I'd consider it fixed

[14:35] <colomon> masak: just found a bug that had been in my $work code since the 1990s because I wrote a new test

[14:35] <[Coke]> moritz: there's no vtables. it's perl6 all the way down.

[14:35] <[Coke]> jnthn: needs test, you think?

[14:35] <jnthn> [Coke]: It gave the wrong error before, now it gives the right one

[14:35] <masak> colomon: I love such tests.

[14:36] <jnthn> And it was the wrong code

[14:36] <jnthn> [Coke]: I can blieve we need a test for the correct version of it.

[14:36] <moritz> agreed

[14:36] <jnthn> pmichaud: ouch! :P

[14:36] <masak> colomon: that's why I'm not totally demoralized by brownfield development; because I can make things better using things like tests and facades and new interfaces.

[14:37] <colomon> masak: basically wrote the test to check new behavior of library Y, but said, hey, it ought to work library X too, and then it didn't. 

[14:37] <[Coke]> rakudo: say (1..2) | (4..5)

[14:37] <p6eval> rakudo e17c13: OUTPUT«any(1, 2, 4, 5)␤»

[14:37] <moritz> [Coke]: anyway, I'm writing those tests right now; feel free to close the ticket without explicit test coverage

[14:38] <[Coke]> rakudo: say (1..23) | (1000..2000)

[14:38] <p6eval> rakudo e17c13: OUTPUT«any(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014, 1015, 1016, 1017, 1018, 1019, 1020, 1021, 1022, 1023, 1024, 1025, 1026, 1027, 1028, 1029…

[14:38] <[Coke]> moritz: too late, already updated to needtestz.

[14:38] <masak> colomon: this summer when I was going through a 1000-line file and generating tests out of it *automatically*, I *still* found tests that broke and told me about years-old bugs in the code. shouldn't be possible, but it happened, several times.

[14:38] <[Coke]> well, more like "too lazy".

[14:39] <moritz> [Coke]: 's ok

[14:39] *** whiteknight left
[14:40] <[Coke]> rakudo: say $*ARGFILES.slurp

[14:40] <p6eval> rakudo e17c13: OUTPUT«Method 'slurp' not found for invocant of class 'ArgFiles'␤  in block <anon> at /tmp/maAkjzf3p0:1␤  in <anon> at /tmp/maAkjzf3p0:1␤»

[14:40] <moritz> that's probably a LHF

[14:40] <[Coke]> rakudo: say $*ARGFILES.WHAT

[14:40] <p6eval> rakudo e17c13: OUTPUT«ArgFiles()␤»

[14:40] <dalek> roast: 340ff7d | moritz++ | S06-signature/unpack-object.t:

[14:40] <dalek> roast: test for typed object unpacking in subsignatures

[14:40] <dalek> roast: review: https://github.com/perl6/roast/commit/340ff7d1c0

[14:41] <[Coke]> rakudo: say eval(("a","b").Seq.perl ).WHAT

[14:41] <p6eval> rakudo e17c13: OUTPUT«Method 'Seq' not found for invocant of class 'Parcel'␤  in block <anon> at /tmp/hiXW8eZ29W:1␤  in <anon> at /tmp/hiXW8eZ29W:1␤»

[14:41] <pmichaud> .Seq is (hopefully) gone

[14:42] <[Coke]> https://rt.perl.org/rt3/Ticket/Display.html?id=76596 is obsolete, then?

[14:42] <pmichaud> looking

[14:42] <[Coke]> (danke)

[14:43] <masak> yay .Seq is gone!

[14:43] <moritz> .Seq is stil in the specs

[14:43] <pmichaud> I call obsolete.  The meaning of Seq and .perl have changed since that ticket was filed.

[14:43] <pmichaud> yes, .Seq is still in the specs; I need to get to work on my spec updsates

[14:43] <pmichaud> *updates

[14:44] <pmichaud> .Seq is in the specs but is likely a fossil.

[14:44] <pmichaud> at least, I'm hoping it'll be a fossil.

[14:45] * [Coke] kills the ticket.

[14:45] <[Coke]> pmichaud++

[14:45] <pmichaud> rakudo:  say eval(('a','b').perl).WHAT

[14:45] <p6eval> rakudo e17c13: OUTPUT«Parcel()␤»

[14:45] <pmichaud> rakudo:  say eval(('a','b').list.perl).WHAT

[14:45] <p6eval> rakudo e17c13: OUTPUT«List()␤»

[14:46] <pmichaud> rakudo:  say eval(('a','b').list.item.perl).WHAT

[14:46] <p6eval> rakudo e17c13: OUTPUT«List()␤»

[14:46] *** cognominal joined
[14:46] <pmichaud> hmmmm

[14:46] <pmichaud> not sure about that last one.

[14:46] <[Coke]> rakudo: for 1,2,3, { say $_ }

[14:46] <p6eval> rakudo e17c13: OUTPUT«===SORRY!===␤Missing block at line 1, near ""␤»

[14:46] <pmichaud> std:  for 1,2,3, { say $_ }

[14:46] <p6eval> std 580b69a: OUTPUT«===SORRY!===␤Expression needs parens to avoid gobbling block at /tmp/LVrMJLXlRk line 1:␤------> for ⏏1,2,3, { say $_ }␤Missing block (apparently gobbled by expression) at /tmp/LVrMJLXlRk line 1:␤------> for 1,2,3, { say $_ }…

[14:46] <[Coke]> is that good enough or do we need to duplicate std's error?

[14:47] <pmichaud> what ticket?

[14:47] <[Coke]> https://rt.perl.org/rt3/Ticket/Display.html?id=66776

[14:47] * [Coke] doesn't mean to be hogging pmichaud's time, btw.

[14:47] <pmichaud> I don't see it as hogging.  :)  Closing tickets has been on my list for a while :)

[14:48] <pmichaud> I could go either way on this one.

[14:48] <moritz> btw, long standing parsing bug:

[14:48] <moritz> nom: say 1, , 3

[14:48] <p6eval> nom e17c13: OUTPUT«13␤»

[14:48] <moritz> std: say 1, , 3

[14:48] <p6eval> std 580b69a: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix , instead at /tmp/jbvlirySyo line 1:␤------> say 1, ⏏, 3␤Parse failed␤FAILED 00:01 121m␤»

[14:48] <[Coke]> there's another ticket open for that one that I've seen recently.

[14:48] <moritz> I know

[14:49] <moritz> it's one of our oldest open tickets

[14:49] <pmichaud> std:  say(1,,3)   # curious

[14:49] <p6eval> std 580b69a: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix , instead at /tmp/4jo3LjnKJa line 1:␤------> say(1,⏏,3)   # curious␤Parse failed␤FAILED 00:01 121m␤»

[14:49] <pmichaud> okay

[14:49] *** kmwallio joined
[14:49] <pmichaud> that's newish to me

[14:50] <moritz> maybe related:

[14:50] <[Coke]> someone just fixed https://rt.perl.org/rt3/Ticket/Display.html?id=58592, didn't they? did we update to require whatever version had that change?

[14:50] <moritz> nom: say ~~ 1

[14:50] <p6eval> nom e17c13: OUTPUT«1␤»

[14:50] *** thou joined
[14:50] <moritz> std: say ~~ 1

[14:50] <p6eval> std 580b69a: OUTPUT«===SORRY!===␤Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/RtDG7Qcule line 1:␤------> say ~~⏏ 1␤Parse failed␤FAILED 00:01 121m␤»

[14:50] *** cognominal left
[14:50] *** cognominal joined
[14:51] <moritz> [Coke]: we haven't updated yet

[14:51] <moritz> [Coke]: will happen as part of the release process anyway

[14:51] <pmichaud> false

[14:51] <pmichaud> rakudo and nqp no longer use PCT::HLLCompiler

[14:51] <pmichaud> so the fix that was applied in Parrot has no impact on rakudo/nqp

[14:52] <moritz> pmichaud: it was an nqp commit (05b7873eda74cb0ae1d038736098af0c3bc00dfd) "Based on a patch" to PCT::HLLCompiler

[14:52] <pmichaud> ah, I missed that then.

[14:52] <pmichaud> looking.

[14:52] <moritz> but the commit did modify HLL::Compiler

[14:52] <moritz> it's nqp master

[14:52] <moritz> HEAD

[14:52] <benabik> pmichaud: I made the identical fix to nap that I did to Parrot, modulo language (PIR v NQP).

[14:53] <benabik> *nqp, stupid autocorrect

[14:53] <pmichaud> there was a reason I didn't make that patch... not sure that I remember what it was.

[14:53] <pmichaud> iirc, it causes something else important to fail.

[14:54] <benabik> It seems very limited in scope.  Skips no vital code, changes no variables.  Not sure what it could break.

[14:55] <[Coke]> we'll find out when we update. ;)

[14:55] <pmichaud> had something to do with what was produced with other combinations of command line options

[14:55] <benabik> Feel free to revert, but let me know so I can try to fix PCT as well.

[14:55] * moritz builds it to see if anything fails

[14:56] <pmichaud> well, I won't revert unless/until I remember what the problem was.

[14:56] <masak> by the way, hakank++ pointed out AFK that the --optimize flags aren't reported in Rakudo's --help

[14:57] <masak> want me to submit a rakudobug for that?

[14:58] <pmichaud> a commit would be cool, too :)

[14:58] <pmichaud> (yes, rakudobug is fine)

[14:58] <pmichaud> (mark it as LHF)

[14:58] * moritz again wishes for a method to pass command line arguments to p6eval 

[14:59] * masak submits LHF rakudobug

[14:59] <pmichaud> benabik/others:  I think the problem I had with the patch were due to other problems with '-e' that have since been fixed in nqp in the past couple of months.  So I'm guessing the patch can stay.

[14:59] *** pmurias_ joined
[14:59] *** pmurias_ left
[14:59] <pmichaud> I don't know what the equivalent -e fixes would be for PCT::HLLCompiler -- might need to check nqp's commit history on HLL::Compiler to find them

[14:59] *** pmurias joined
[14:59] <pmurias> sorear: hi

[15:00] <pmurias> sorear: where should i store a list of passing p5 integration spec tests?

[15:00] <dalek> roast: 7dd36e1 | (Paweł Murias)++ | S01-perl-5-integration/subs.t:

[15:00] <dalek> roast: test for calling p5 subs from perl6

[15:00] <dalek> roast: review: https://github.com/perl6/roast/commit/7dd36e15aa

[15:00] <dalek> roast: f6d832a | (Paweł Murias)++ | S01-perl-5-integration/subs.t:

[15:00] <dalek> roast: basic test for calling p5 subs

[15:00] <dalek> roast: review: https://github.com/perl6/roast/commit/f6d832ad23

[15:02] <pmichaud> re:  message in makefile about long compilation step -- I think it's okay to make the change pre-release.  Seems like it should just be an @echo line in Makefile.in

[15:04] * moritz does it so

[15:04] *** sftp left
[15:04] *** sftp joined
[15:05] <benabik> pmichaud: Looking at git-log, I don't see any changes that would affect the --target patch…  *shrug*  The patch was three years old, so perhaps it was an old issue.  Thanks for looking at it though.

[15:05] <pmichaud> returning to List.tree for a moment -- I'm fine with what was committed for now.  It likely needs some changing (and MapIter may be going away with other upcoming changes), but it's fine as-is for now until we get some bug reports against it or see other issues.

[15:05] * benabik had considered just submitting a pull request for nap, but decided to go with the old axiom "forgiveness > permission"

[15:06] <pmichaud> benabik: +1

[15:06] <moritz> pmichaud: ok

[15:06] * benabik just teaches Lion that nqp is a word, darn it.

[15:06] <pmichaud> benabik: I know that originally I didn't apply the three-year-old patch because I expected to make a significant refactor in how PCT::HLLCompiler dumps its output and the patch wouldn't have been applicable under the refactor.  But the refactor never occurred.

[15:07] <moritz> pmichaud: the "real .tree" has much more bells and whistles anyways, this was just for making nested list available to the user /somehow/

[15:07] <pmichaud> moritz: +2

[15:07] <moritz> nom: for (1, 2 Z 10, 20).tree -> $x { say $x.fmt('%02d', ',') }

[15:07] <pmichaud> iwbni if the simple .tree could at least return a LoL, though :)

[15:07] <p6eval> nom bfedd9: OUTPUT«01,10␤02,20␤»

[15:08] <pmichaud> (if it's not doing so already)

[15:08] <pmichaud> oh!

[15:08] <benabik> pmichaud: Ah.  Fair enough.  Some changes to dumping in nqp should probably still be on the list…  --target=p[ao]st failes trying to dump 6model objects.  I've occasionally thought about targeting it, but I'm spending too much time away from homework as it is.  :-)

[15:08] <moritz> nom: say (1, 2 Z 10, 20).tree.WHAT

[15:08] <p6eval> nom bfedd9: OUTPUT«List()␤»

[15:08] <pmichaud> method tree(**@lol) { @lol }    # might work

[15:08] * moritz doesn't think so

[15:09] <moritz> it needs to do some work with the invocant at least

[15:09] <pmichaud> oh, yeah.

[15:09] <pmichaud> ummmm

[15:10] <pmichaud> method tree() { sub foo(**@lol) { @lol };  foo(self) }

[15:10] <pmichaud> :-P

[15:11] <pmichaud> method tree() { ( -> **@lol { @lol } )(self) }

[15:11] <moritz> nom: use MONKEY_TYPING; augment class List { method treeish() { sub foo(**@lol) { @lol };  foo(self) }}; given (1, 2 Z 10, 20).treeish { say .WHAT; say .[0].perl }

[15:11] <p6eval> nom bfedd9: OUTPUT«LoL()␤((1, 10), (2, 20)).list.item␤»

[15:11] <moritz> that doesn't look right

[15:11] <TimToady> it seems to me that if it defaults to lol then that is a useless redundancy

[15:12] <TimToady> I think a deeper default would make sense on .tree

[15:12] <moritz> should Z returns a LoL in the first place?

[15:12] <moritz> *return

[15:12] <TimToady> no

[15:12] <pmichaud> agreed, "no"

[15:13] <pmichaud> don't pre-itemize things

[15:14] <moritz> huh, is LoL the itemization?

[15:14] <pmichaud> elements of a LoL are itemized

[15:14] <TimToady> it prevents flattening of the top layer

[15:14] <pmichaud> basically, LoL is like an Array but without the flattening of deeper layers

[15:15] <moritz> so would @lol.push: 1, 2  add a single sublist with two elems?

[15:15] <TimToady> and I think .tree should do that all the way down

[15:15] <TimToady> by dfeault

[15:15] <pmichaud> I'm fine with tree defaulting to deep itemization

[15:15] <pmichaud> moritz: I would expect @lol.push: 1,2 to add two elems

[15:16] * moritz isn't sure what to expect anymore

[15:16] <pmichaud> if you want to add a sublist, you use  @lol.push:  (1,2).item

[15:17] <pmichaud> @lol.push: 1,2   would be the same as  @lol.push(1,2)

[15:19] <pmichaud> (and .push is defined as method push(*@values), which flattens)

[15:21] <pmichaud> okay, I'm afk for a while

[15:28] <kmwallio> Is there an online guide for doing NativeCalls from Perl6?

[15:28] <moritz> kmwallio: not really, the current state is rather sad

[15:29] <moritz> kmwallio: there are some approaches, but they only work with rather old versions of rakudo

[15:29] <kmwallio> lame

[15:29] <kmwallio> thanks for the information

[15:30] <moritz> lame indeed; efforts to improve the situations are greatly appreciated

[15:30] *** GlitchMr left
[15:30] <moritz> https://github.com/jnthn/zavolaj/ is what used to work, but what I belive is broken now

[15:31] <kmwallio> does that mean I should learn PIR?

[15:31] <moritz> no, I think the next iteration will use nqp (and maybe C)

[15:31] <masak> \o/

[15:32] <jnthn> I started working on that. 

[15:32] <moritz> but I think jnthn has a plan, I'm just parroting things I've heard

[15:32] <jnthn> I'm mostly just undecided whether ot use Parrot's NCI or wrap something like libffi directly from NQP

[15:32] <jnthn> Or something else.

[15:32] <benabik> jnthn: If libffi is available, Parrot's NCI is basically a wrapper around it.

[15:33] <kmwallio> thanks for the information, I have to go.

[15:33] *** kmwallio left
[15:33] <benabik> Although I guess Parrot NCI knows nothing about 6model, which might be awkward.

[15:34] <jnthn> Well, yeah, that's the reason I'm wondering what to do.

[15:34] <jnthn> Will it be easier to do 6model => libffi integration than go via Parrot's existing binding. I didn't look closely enough yet.

[15:35] <benabik> If 6model objects used get_pointer to return the start of where data is stored, then you might be able to use 'p' NCI type to pass them as structs.  Dunno.

[15:35] * benabik digs back into XS.

[15:36] <PerlJam> jnthn: when you say "6model => libffi integration", do you mean at the NQP level or lower?

[15:36] <phenny> PerlJam: 14:33Z <pmichaud> tell PerlJam  if you could work on RT #97102 as part of the release it would be really awesome.  msg me if you need some ideas.  kthx

[15:36] <benabik> (Well, pointers to structs.)

[15:40] *** mj41 left
[15:41] *** risou_awy is now known as risou

[15:45] *** pmurias left
[15:51] *** wamba joined
[16:01] *** donri joined
[16:01] * masak decommutes

[16:09] *** wk joined
[16:10] *** JimmyZ left
[16:15] *** whiteknight joined
[16:15] *** wk left
[16:29] <[Coke]> decommutes == "leave work to head for home" or "arrive home having left from work" ?

[16:30] *** GlitchMr joined
[16:30] *** drbean left
[16:31] <jnthn> [Coke]: The first, I think

[16:31] <diakopter> leaving work is how I use it

[16:32] <jnthn> same

[16:36] *** finanalyst_ joined
[16:37] <[Coke]> thank you. ;)

[16:37] <finanalyst_> yesterday I updated rakudo and found that it broke a lot of my code, including fairly standard regexes

[16:37] <finanalyst_> what happened?

[16:39] <[Coke]> finanalyst_: how old was your older version?

[16:40] *** alester joined
[16:40] <finanalyst_> maybe a month or so

[16:40] *** kaleem joined
[16:40] <[Coke]> it is quite possible that you upgraded past the transition to the nom branch, which brings great improvements in the object model, but hasn't quite caught up yet in regex.

[16:40] <[Coke]> Are you going against releases?

[16:40] <finanalyst_> that would explain it

[16:40] <[Coke]> I believe there was a note in the release announcement about this. checking.

[16:42] <finanalyst_> Also I have found that IO isnt working, eg. my @arr = lines('path/to/data/data');

[16:42] *** daniel-s left
[16:43] <[Coke]> Hurm. I don't actually see the latest release announcement anywhere.

[16:44] <finanalyst_> i rewrote to my $fn=open('filename',:r); my @arr= $fn.lines, which works, but only the second time

[16:44] <finanalyst_> for some reason I get a segmentation error on the first attempt

[16:45] <finanalyst_> should i be filing bug reports on these things?

[16:45] <[Coke]> gah.

[16:45] <[Coke]> Yes, pleaes.

[16:45] <[Coke]> definitely for segvs.

[16:46] <[Coke]> For things that nom has regressed on, yes. Hopefully, aside from the regex, these are low hanging fruit that we can bring back.

[16:49] <jnthn> lines('path/to/data/data') will not do IO now - that's Rakudo following a spec change

[16:50] <jnthn> Need to coerce the filename to an IO object, e.g. 'path/to/data/data'.IO

[16:50] <finanalyst_> jnthn: i missed that change.

[16:51] <jnthn> finanalyst_: Well, I think it happened a little bit ago, but took until the nom branch to switch it over.

[16:51] <jnthn> segv is *always* wrong, so certainly that wants a ticket.

[16:51] <finanalyst_> btw I really miss the full patches the cvs used to give. git only gives the log comment, which is not always helpful

[16:52] <[Coke]> finanalyst_: I also dislike having to click through to see the commits.

[16:54] <finanalyst_> jnthn: what is an elegant idiom now for what used to be: my @arr=lines('fn',:r) ?

[16:55] <benabik> finanalyst_: In general, -p will give you patches out of git.

[16:55] <benabik> finanalyst_: i.e. git log -p

[16:55] <finanalyst_> [Coke]: how long for regexes to return to bleeding edge rakudo?

[16:55] <jnthn> my @arr = 'fn'.IO.lines; # not so bad

[16:56] <[Coke]> finanalyst_: we have a low bus number there. unsure.

[16:56] <finanalyst_> jnthn: is that read only, or has readonly become OS dependent?

[16:56] <[Coke]> I mean, they're there now, they're just not as full featured.

[16:57] <[Coke]> nom: say "abcd" ~~ /d/

[16:57] <p6eval> nom bfedd9: OUTPUT«=> <d>␤␤»

[16:57] <TimToady> perl6: say '/etc/passwd'.IO.lines[0]

[16:57] <p6eval> pugs b927740: OUTPUT«*** No such method in class Str: "&IO"␤    at /tmp/SRFGmfb7Ey line 1, column 5 - line 2, column 1␤»

[16:57] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«␤Unhandled Exception: Unable to resolve method lines in class IO␤  at /tmp/WwUWpWIDhi line 1 (MAIN mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2176 (CORE C1040_ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2177 (CORE module-CO…

[16:57] <p6eval> ..rakudo bfedd9: OUTPUT«root:x:0:0:root:/root:/bin/bash␤»

[16:57] <[Coke]> nom: say ?("abcd" ~~ /e/)

[16:57] <p6eval> nom bfedd9: OUTPUT«Bool::False␤»

[16:57] *** dakkar left
[16:57] <finanalyst_> [Coke]: how would I get a rakudo with more/better/old regex?

[16:57] <[Coke]> bad rakudo!

[16:58] <[Coke]> finanalyst_: don't upgrade to the latest release?

[16:58] <finanalyst_> just upgraded!!! :(

[16:58] <finanalyst_> i want to go back. Not sure of syntax

[16:58] <[Coke]> We could always use another pair of hands, if you'd rather upgrade and hack on rakudo. ;)

[16:58] <TimToady> rakudo: my @arr = '/etc/passwd'.IO.lines; @arr[0] = 123; say @arr[1];  # why do you think it's readonly?

[16:58] <p6eval> rakudo bfedd9: OUTPUT«daemon:x:1:1:daemon:/usr/sbin:/bin/sh␤»

[16:59] <TimToady> rakudo: my @arr = '/etc/passwd'.IO.lines; @arr[0] = 123; say @arr[0];  # why do you think it's readonly?

[16:59] <p6eval> rakudo bfedd9: OUTPUT«123␤»

[16:59] *** Trashlord left
[16:59] <finanalyst_> TimToady: what is the default for IO.lines? 

[16:59] <jnthn> oh my...a leak 

[17:00] <TimToady> IO.lines returns a lazy list of strings.  I don't know what you're trying to do.

[17:00] *** Trashlord joined
[17:01] <TimToady> you aren't expecting lines = $new to change a file in place are you?

[17:02] <finanalyst_> TimToady: sorry for stupid questions: I should go and look at the latest syntax. In general, I try to keep input data files readonly and output files write only

[17:02] <TimToady> lines() with no argument is supposed to default to $*ARGFILES

[17:02] <TimToady> but IO.lines isn't that

[17:02] <TimToady> perl6: for lines() { .say }

[17:02] <p6eval> rakudo bfedd9: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmi…

[17:02] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&lines"␤    at /tmp/6vBKBkCTBv line 1, column 5-13␤»

[17:02] <p6eval> ..niecza v10-58-gc851cf8: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdtei…

[17:02] *** ksi joined
[17:02] <TimToady> lines with an argument splits a string into lines

[17:03] <TimToady> perl6: say lines("a\nb\nc\n")[1]

[17:03] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&lines"␤    at /tmp/dyUciplGte line 1, column 5 - line 2, column 1␤»

[17:03] <p6eval> ..rakudo bfedd9, niecza v10-58-gc851cf8: OUTPUT«b␤»

[17:03] <TimToady> which is why the .IO is mandatory if you want the string to mean a filename

[17:04] <jnthn> shop &

[17:04] <[Coke]> lunch&

[17:05] <finanalyst_> TimToady: now I remember the change to the IO syntax being discussed.

[17:06] <finanalyst_> Always seemed to be a change from IO being on IO objects, to IO being done to string objects

[17:06] *** Chillance joined
[17:07] <finanalyst_> Even though filenames are strings, I always thought of them as names for some different to strings

[17:07] <finanalyst_> s/some/somthing/

[17:08] <finanalyst_> sorry. need to go.

[17:08] *** finanalyst_ left
[17:12] *** MayDaniel joined
[17:21] *** bombworm joined
[17:22] *** bombworm left
[17:22] *** thou left
[17:39] *** MayDaniel left
[17:41] *** drbean joined
[17:47] *** donri left
[17:53] *** replore left
[17:57] *** thou joined
[17:58] *** uasi left
[17:58] *** MayDaniel joined
[18:02] *** risou is now known as risou_awy

[18:07] *** packetknife joined
[18:10] <masak> filenames are Bufs sometimes, IIRC.

[18:10] <masak> I remember something about Py3k having trouble because it assumed that all filenames are utf-8-encoded strings; and they aren't.

[18:13] <flussence> that's not an unreasonable assumption, as long as you don't care about working on OSes besides Linux :)

[18:14] <flussence> (or foreign filesystems, or...)

[18:21] *** shinobicl left
[18:34] *** envi_ left
[18:43] *** drbean left
[18:49] *** drbean joined
[18:54] <TimToady> perl6: say 3.5 ~~ (1..5) | (10..50)

[18:54] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Bool::True␤»

[18:54] <p6eval> ..rakudo bfedd9: OUTPUT«Bool::False␤»

[18:54] <p6eval> ..pugs b927740: OUTPUT«any(VBool False)␤»

[18:54] <TimToady> niecza is correct, rakudo is wrong

[18:54] <colomon> Nice variety!

[18:55] <colomon> perl6: say 3.5 ~~ (1..5)

[18:55] <p6eval> rakudo bfedd9, niecza v10-58-gc851cf8: OUTPUT«Bool::True␤»

[18:55] <p6eval> ..pugs b927740: OUTPUT«␤»

[18:55] <jnthn> nom: say 3.5 ~~ (1..5)

[18:55] <p6eval> nom bfedd9: OUTPUT«Bool::True␤»

[18:56] <[Coke]> is there a more descriptive spec for range than: http://perlcabal.org/syn/S32/Containers.html#Range ?

[18:56] <jnthn> nom: say 3.5 ~~ (10..50)

[18:56] <p6eval> nom bfedd9: OUTPUT«Bool::False␤»

[18:56] <[Coke]> the problem with the junction is that it's flattening them.

[18:56] <[Coke]> nom: say (1..2) | (10..12)

[18:56] <p6eval> nom bfedd9: OUTPUT«any(1, 2, 10, 11, 12)␤»

[18:56] <jnthn> yeah

[18:56] <colomon> oh, ick

[18:57] <[Coke]> there's a ticket for that that I just marked "no change" on recently.

[18:58] *** kaleem left
[18:58] <[Coke]> https://rt.perl.org/rt3/Ticket/Display.html?id=76422

[19:02] <PerlJam> I'm starting on the release and I'd like to update the release_guide.pod.  Step 2 is to update build/P

[19:02] <PerlJam> ARROT_REVISION

[19:02] <PerlJam> what should be the appropriate procedure now?

[19:05] <moritz> PerlJam: tag nqp, and put the tag in tools/build/NQP_REVISION

[19:05] * moritz -> sleep

[19:06] <jnthn> 'night, moritz

[19:08] <jnthn> > say 3.5 ~~ (1..5) | (10..50)

[19:08] <jnthn> Bool::True

[19:08] <jnthn> > say 3.5 ~~ (1..5) & (10..50)

[19:08] <jnthn> Bool::False

[19:08] <masak> 'nacht, moritz 

[19:09] <dalek> rakudo/nom: cc4f39e | jnthn++ | src/core/Junction.pm:

[19:09] <dalek> rakudo/nom: Make sure |, & and ^ don't go flattening the arguments.

[19:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cc4f39e16a

[19:10] <jnthn> [Coke]: Verified the above patch resolves #76422 and tagged it test needed. :)

[19:10] <[Coke]> jnthn: sweet. I'll mark the ticket.

[19:10] <[Coke]> ... even sweeter!

[19:10] <jnthn> :)

[19:13] <[Coke]> wow, that was a simple fix.

[19:13] <jnthn> nom: say 704 - 85

[19:13] <p6eval> nom bfedd9: OUTPUT«619␤»

[19:14] <[Coke]> I can probably close 4 tickets this evening. ;)

[19:14] <jnthn> Wonder if we can break 600 in the next couple of weeks :)

[19:14] <[Coke]> 600 total, or taking testneeded into account?

[19:15] <jnthn> Taking testneeded into account :)

[19:15] <jnthn> Mostly depends if the fixers can fix faster than the masak can file ;)

[19:16] <TimToady> perl6: say 3.5 ~~ (1..5) & (1..5)

[19:16] <p6eval> niecza v10-58-gc851cf8: OUTPUT«Bool::True␤»

[19:16] <p6eval> ..pugs b927740: OUTPUT«all(VBool False)␤»

[19:16] <p6eval> ..rakudo bfedd9: OUTPUT«Bool::False␤»

[19:16] <japhb> jnthn, do you backlog, and did you get my answer from yesterday that the ticket appears fixed, but the code in the ticket seems out of date?

[19:16] <phenny> japhb: 19 Oct 20:55Z <jnthn> tell japhb Does your work on MAIN resolve https://rt.perl.org/rt3/Ticket/Display.html?id=92986 ?

[19:18] <jnthn> japhb: I tend to backlog the time I was sleeping. Though if I'm away for some days I tend not to manage.

[19:18] <japhb> nodnod

[19:19] <jnthn> Anyway, saw the answer :)

[19:19] <japhb> ah, good

[19:19] <jnthn> Happy it's fixed

[19:19] <jnthn> And yes, needs .gist to actually output the type name.

[19:20] * jnthn updates the ticket

[19:20] <japhb> thank you!

[19:21] <jnthn> Thank you for making it work! 

[19:21] <jnthn> Ticket tagged testneeded :)

[19:24] <mberends> jnthn: have you submitted a talk proposal to http://conferences.yapceurope.org/lpw2011 ?  I've proposed a 20 minute Niecza GUI talk.

[19:24] <jnthn> mberends: Submitted a couple, yes

[19:24] <jnthn> nom: class C { has %!p; submethod BUILD(:%!p) {} }; C.new; say 'alive'

[19:24] <p6eval> nom bfedd9: OUTPUT«alive␤»

[19:24] <[Coke]> jnthn: taking testneeded into account, I can probalby hit that tonight just by trolling the queue more.

[19:24] <jnthn> oh, heh, 95340 already says "fixed in nom" :)

[19:25] *** GlitchMr left
[19:25] <jnthn> That's one more testneeded :)

[19:25] <[Coke]> \o/

[19:27] * [Coke] notes that non-hague grants are open again this quarer.

[19:27] <[Coke]> *quarter

[19:27] * [Coke] eagerly anticipates some requests.

[19:29] <[Coke]> rakudo: say 3.5 ~~ 1..5

[19:29] <p6eval> rakudo bfedd9: OUTPUT«Bool::True␤»

[19:29] <[Coke]> rakudo: say 3.5 ~~ (1..5|7..10)

[19:29] <p6eval> rakudo bfedd9: OUTPUT«Bool::False␤»

[19:29] <TimToady> 5|7

[19:29] <TimToady> in fact...

[19:29] <[Coke]> so, now it's failing some new interesting reason.

[19:30] <TimToady> std: say 3.5 ~~ (1..5|7..10)

[19:30] <p6eval> std 580b69a: OUTPUT«===SORRY!===␤".." and ".." are non-associative and require parens at /tmp/wok9dLsVMO line 1:␤------> say 3.5 ~~ (1..5|7..⏏10)␤Check failed␤FAILED 00:01 121m␤»

[19:30] <[Coke]> rakudo: say 3.5 ~~ (1..5)|(7..10)

[19:30] <p6eval> rakudo bfedd9: OUTPUT«Bool::False␤»

[19:30] <TimToady> your precedence is rong

[19:30] <TimToady> that should work better

[19:30] <TimToady> and does work in my local copy now

[19:31] <TimToady> jnthn++

[19:31] <[Coke]> ah, so it does.

[19:31] <[Coke]> p6eval: rebuild nom

[19:31] <[Coke]> evalbot: rebuild nom

[19:31] * [Coke] shrugs.

[19:32] <[Coke]> say (1..5|7).perl

[19:32] <[Coke]> nom: say (1..5|7).perl

[19:32] <p6eval> nom bfedd9: OUTPUT«any(1, 2, 3, 4, 5e0, 1, 2, 3, 4, 5, 6, 7e0)␤»

[19:33] <TimToady> heh

[19:33] <jnthn> Nice auto-threading :)

[19:33] <jnthn> But...wtf happened to the end fo the range? :)

[19:34] <TimToady> looks like a p5ism

[19:34] <jnthn> 5e0

[19:34] <colomon> niecza: say  (1..5|7).perl

[19:34] <p6eval> niecza v10-58-gc851cf8: OUTPUT«any(1..5, 1..7)␤»

[19:34] <[Coke]> that seems less surprising.

[19:34] <TimToady> nom: say 1..5

[19:35] <p6eval> nom bfedd9: OUTPUT«1..5␤»

[19:35] <TimToady> nom: say flat 1..5

[19:35] <p6eval> nom bfedd9: OUTPUT«1 2 3 4 5␤»

[19:35] <jnthn> nom: say (flat 1..5).perl

[19:35] <p6eval> nom bfedd9: OUTPUT«(1, 2, 3, 4, 5).list␤»

[19:35] <TimToady> nom: say flat(1..5)[*-1].WHAT

[19:35] <p6eval> nom bfedd9: OUTPUT«Int()␤»

[19:36] <[Coke]> phenny: tell masak I can't read https://rt.perl.org/rt3/Ticket/Display.html?id=77746

[19:36] <phenny> [Coke]: I'll pass that on when masak is around.

[19:37] <dalek> rakudo/nom: 9d2f113 | jnthn++ | src/binder/multidispatch.c:

[19:37] <dalek> rakudo/nom: Fix required named parameter optimization in multi dispatcher.

[19:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9d2f1136ea

[19:37] <jnthn> That's one more :)

[19:38] *** wk joined
[19:39] <masak> jnthn++

[19:39] <phenny> masak: 19:36Z <[Coke]> tell masak I can't read https://rt.perl.org/rt3/Ticket/Display.html?id=77746

[19:40] * masak looks

[19:41] <masak> that is an odd bug. how did it end up like that? :/

[19:42] <masak> anyway, I think I can read it.

[19:44] *** packetknife left
[19:44] <masak> [Coke]: �,� should be «,»

[19:45] * jnthn closes one more, and tags a couple of others testneeded :)

[19:45] <[Coke]> masak: can you mark that on the ticket? Thanks.

[19:46] <jnthn> nom: say 703 - 90

[19:46] <p6eval> nom bfedd9: OUTPUT«613␤»

[19:46] <jnthn> closer ;)

[19:46] <masak> [Coke]: will do.

[19:46] <TimToady> while you're at it, rewrite the ticket system to support the 21st century

[19:46] <[Coke]> jnthn: heh. I'm at work, you might beat me to it!

[19:46] <[Coke]> TimToady: we have bigger fish to fry. :P

[19:48] <TimToady> Bye, and thanks for all the bigger fish...  :)

[19:48] <masak> TimToady: I can't really blame the ticket system; it's gotten all my other tickets right...

[19:48] <masak> just can't think what I got wrong that one time... :)

[19:49] *** drbean left
[19:49] <TimToady> maybe it got it right by accident the other times...

[19:51] <masak> Mr Bayes frowns.

[19:51] <TimToady> Mr Holmes grins

[19:52] <masak> ;)

[19:52] <tadzik> . o O ( A day of very low probabiity )

[19:52] <TimToady> {3,5,7,9,11,13}  # obviously 9 is prime :)

[19:53] * masak .oO( Accidentally, Mr Watson )

[19:53] *** wk left
[19:56] *** drbean joined
[19:57] <masak> huh! the *emails* I got back about #77746, a year ago, are encoded right.

[19:58] <masak> maybe it was just a temporary glitch in RT?

[20:01] <dalek> nqp: 7eda54b | duff++ | docs/release_guide.pod:

[20:01] <dalek> nqp: Add a simple release guide

[20:01] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7eda54bbf6

[20:19] <masak> PerlJam++

[20:23] <dalek> rakudo/nom: 59332ae | duff++ | docs/release_guide.pod:

[20:23] <dalek> rakudo/nom: update release guide

[20:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59332ae42a

[20:25] *** soh_cah_toa joined
[20:34] *** dorlamm joined
[20:38] *** mberends left
[20:38] *** mtk left
[20:42] <japhb> It looks to me like some of the tests in S06-other/main-usage.t are bogus and/or out of date.  What's the normal process for changing them?  Just commit?  Submit a patch to someone?  Discuss here and then implement?

[20:42] <tadzik> which tests?

[20:42] <masak> I don't speak for everyone, but if you have a commit bit, just commit.

[20:42] <masak> we can fix up chaos after the fact.

[20:43] <masak> if you feel like discussing beforehand, discuss.

[20:43] <jnthn> japhb: Unless you're unsure, don't hesitate to commit. 

[20:43] <jnthn> japhb: Discussion is always fine too, of coruse.

[20:43] <japhb> masak, jnthn: fair enough, thanks.

[20:44] *** mtk joined
[20:44] <japhb> tadzik: For example, two tests test putting options after positional params, and expect that to work, which is converse to spec

[20:44] <japhb> *counter

[20:49] *** mberends joined
[20:49] <masak> mberends! \o/

[20:52] *** localhost left
[20:53] *** localhost joined
[20:55] <dalek> rakudo/nom: 63326f6 | duff++ | docs/announce/2011.10:

[20:55] <dalek> rakudo/nom: The beginnings of a release announcement

[20:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/63326f645a

[20:55] *** abercrombie left
[20:55] <PerlJam> looks like I won't get the release out until several hours from now ... probably around 10pm-ish localtime (it's ~4pm now)

[20:56] <jnthn> That's still today somewhere :)

[21:00] <PerlJam> until then feel free to comment on the release announcement I just committed

[21:00] * PerlJam afk 

[21:00] <masak> 'night, everyone. happy releasing, PerlJam.

[21:00] <japhb> Anything special that must be done when adding a new test file?

[21:01] <japhb> *(spec test file)

[21:01] <jnthn> japhb: If you want Rakudo to run it, it'll need to go in t/spectest.data also.

[21:01] *** MayDaniel left
[21:01] <jnthn> (in the Rakudo repo)

[21:02] <japhb> jnthn, OK, thansk

[21:02] <japhb> *thanks

[21:05] *** bluescreen100 left
[21:05] *** bluescreen10 left
[21:06] *** molaf left
[21:17] *** bluescreen10 joined
[21:17] *** bluescreen100 joined
[21:20] *** im2ee left
[21:24] *** y3llow_ joined
[21:24] *** pothos_ joined
[21:26] *** y3llow left
[21:26] *** y3llow_ is now known as y3llow

[21:26] *** pothos left
[21:26] *** pothos_ is now known as pothos

[21:29] *** ksi left
[21:45] <dalek> roast: 86de197 | (Geoffrey Broadwell)++ | S06-other/main-usage.t:

[21:45] <dalek> roast: S06-other/main-usage.t cleanup/revamp stage 1

[21:45] <dalek> roast: 

[21:45] <dalek> roast: * Reorder tests to group them more logically

[21:45] <dalek> roast: * Move spacey value tests to end, with comment pointing to relevant spec discussion

[21:45] <dalek> roast: * Fix a couple tests that were out of spec or testing too many things at once

[21:45] <dalek> roast: * Fix test reasons and program output to be more consistent and clear

[21:45] <dalek> roast: * Add three more tests; many more still needed

[21:45] <dalek> roast: review: https://github.com/perl6/roast/commit/86de197f31

[21:51] *** kaare_ left
[21:55] *** dual left
[22:03] *** bluescreen100 left
[22:04] *** bluescreen10 left
[22:06] *** Holy_Cow left
[22:09] *** wamba left
[22:12] *** stepnem left
[22:15] *** replore joined
[22:15] *** stepnem joined
[22:16] *** bluescreen10 joined
[22:17] *** bluescreen100 joined
[22:19] *** dorlamm left
[22:25] *** Chillance left
[22:26] *** benabik left
[22:46] *** replore left
[22:51] *** abercrombie joined
[23:16] *** drbean left
[23:21] *** tokuhiro_ joined
[23:23] *** drbean joined
[23:34] *** benabik joined
[23:49] *** smash left
[23:54] *** daniel-s joined
