[00:16] *** Limbic_Region joined
[00:49] <dalek> rakudo/nom: 81a7e84 | pmichaud++ | src/core/ (7 files):

[00:49] <dalek> rakudo/nom: Refactor operators, add degenerate forms for reductions.

[00:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/81a7e84cfc

[01:21] <jnthn> morning, #pelr6

[01:21] <jnthn> er, #perl6

[01:33] *** [Coke] left
[01:34] <smallfoot-> is Parrot fucking awesome?

[01:34] *** [Coke] joined
[01:35] *** araujo left
[01:35] *** whiteknight joined
[01:55] *** Limbic_Region left
[01:59] *** [perlhack] joined
[02:00] <[perlhack]> nice to meet you.

[02:00] <[perlhack]> :-)

[02:02] *** araujo joined
[02:04] *** whiteknight left
[02:05] <[perlhack]> Enhancing English fluent,and we talk.

[02:07] <colomon> woah, crazy number of nom changes tday.

[02:07] <colomon> *today

[02:10] <[perlhack]> :-) You talking to himself ?

[02:17] *** lichtkind left
[02:23] <jnthn> colomon: Some in nqp also :)

[02:23] <jnthn> Though I didn't bump NQP_REVISION yet

[02:23] <jnthn> Maybe after flight :)

[02:27] <jnthn> phenny: tell moritz in BackTrace you put subname and subtype into the BackTraceLine but not the actual Sub object itself, which would seem more general. Any reason why not?

[02:27] <phenny> jnthn: I'll pass that on when moritz is around.

[02:27] <jnthn> phenny: tell moritz_ or maybe consider having those but including the sub too

[02:27] <phenny> jnthn: I'll pass that on when moritz_ is around.

[02:37] *** mattp_ left
[02:38] *** bluescreen10 joined
[02:46] *** [Coke] left
[02:47] * jnthn -> airport o/

[02:47] <colomon> safe flight!

[02:47] <jnthn> Thanks!

[02:47] *** mattp_ joined
[02:48] *** zostay joined
[02:49] *** mattp_ left
[02:49] *** mattp_ joined
[02:52] *** bluescreen10 left
[02:59] *** natureboy joined
[02:59] *** natureboy left
[03:08] *** agentzh joined
[03:12] *** [perlhack] left
[03:17] *** Bzek joined
[03:18] *** [Coke] joined
[03:23] *** Su-Shee_ joined
[03:25] *** Su-Shee left
[03:30] *** jaldhar joined
[03:34] <dalek> roast: 493dd60 | pmichaud++ | S32-num/rat.t:

[03:34] <dalek> roast: Fudge S32-num/rat.t for infinite rats in nom.

[03:34] <dalek> roast: review: https://github.com/perl6/roast/commit/493dd604de

[03:35] <dalek> rakudo/nom: c4ca652 | pmichaud++ | src/core/metaops.pm:

[03:35] <dalek> rakudo/nom: Handle assignment metaop on undefined lhs.

[03:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c4ca652056

[03:35] <dalek> rakudo/nom: 25b3ee6 | pmichaud++ | / (2 files):

[03:35] <dalek> rakudo/nom: Rat updates, add another spectest.

[03:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/25b3ee67f7

[03:43] <thou> phenny: tell masak this is confusing: Jun 22 blog post: "Whereas the %d is for integers, the %f is for floating-point values. (It's probably best to avoid confusing oneself by thinking of the non-integers as "decimal numbers" in this case.)"; instead try something like "it's probably best to not think of the non-integer numbers as "decimal numbers" in this case, which would be confusing."

[03:43] <phenny> thou: I'll pass that on when masak is around.

[03:49] *** smallfoot- left
[03:58] *** zostay_ joined
[04:01] *** zostay left
[04:04] <thou> phenny, tell masak looks like is_prime() is broken in Jun 23 blog post (always returns true). should be defined as:  sub is_prime($n) { return ?($n %% none( 2 .. $n - 1 )); }

[04:04] <phenny> thou: I'll pass that on when masak is around.

[04:11] *** everbrew joined
[04:16] *** everbrew left
[04:23] *** satyavvd joined
[04:37] *** f00li5h left
[04:37] *** benabik left
[04:37] *** benabik joined
[04:38] <thou> phenny: tell masak your connect four board_is_full() has an off-by-one error (doesn't check the first column). it should be defined as:  sub board_is_full { pile_is_full(all(^$WIDTH)); }

[04:38] <phenny> thou: I'll pass that on when masak is around.

[05:07] *** koban joined
[05:07] *** koban left
[05:07] *** soh_cah_toa left
[05:12] *** daniel-s joined
[05:13] *** drbean left
[05:31] *** satyavvd left
[05:32] *** satyavvd joined
[05:35] *** drbean joined
[05:36] *** jaldhar left
[05:36] *** _jaldhar joined
[05:40] *** envi joined
[05:51] <pmichaud> now passing 4,263 tests.

[05:51] <pmichaud> afk, sleep

[05:51] <dalek> rakudo/nom: bf81ce6 | pmichaud++ | src/core/Str.pm:

[05:51] <dalek> rakudo/nom: Add Str.perl.

[05:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf81ce6e5b

[05:51] <dalek> rakudo/nom: 49e19c5 | pmichaud++ | src/core/Numeric.pm:

[05:51] <dalek> rakudo/nom: Add prefix:<-> for non-numeric types.

[05:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/49e19c57a6

[05:51] <dalek> rakudo/nom: 96cb354 | pmichaud++ | NOMMAP.markdown:

[05:51] <dalek> rakudo/nom: NOMMAP update for  my ($, $) = ...;

[05:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/96cb354efb

[05:51] <dalek> rakudo/nom: f7f0c00 | pmichaud++ | / (2 files):

[05:51] <dalek> rakudo/nom: More fixes for Range class, now pass S03-operators/range-basic.t .

[05:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7f0c00505

[05:55] *** donri left
[05:59] *** Su-Shee_ is now known as Su-Shee

[06:00] *** Chillance joined
[06:05] *** wtw joined
[06:23] *** mj41 joined
[06:25] *** zby_home_ left
[06:26] <moritz_> good morning

[06:26] <phenny> moritz_: 02:27Z <jnthn> tell moritz_ or maybe consider having those but including the sub too

[06:26] <moritz_> in class Rat: +    method Int() { self.Num.Int }

[06:27] <moritz_> wouldn't  $!nuemrator div $denominator  be better?

[06:30] <moritz_> phenny: tell jnthn I was not sure if includiing the sub in the backtrace object might lead to memory leakage somehow - maybe that was overly pessimistic

[06:30] <phenny> moritz_: I'll pass that on when jnthn is around.

[06:32] <moritz_> what I thought just now is that maybe I should create include all the callframes

[06:33] <moritz_> and then offer different stringification/filter methods that select only some frames (only Routines, only non-setting)

[06:35] *** kst left
[06:37] *** noganex_ is now known as noganex

[06:40] *** kst joined
[06:44] *** mj41 left
[06:52] *** fhelmberger joined
[07:04] <pmichaud> 06:26 <moritz_> in class Rat: +    method Int() { self.Num.Int }

[07:05] <pmichaud> I just tended to follow master here.  I'm certainly okay with changing it to something better.

[07:19] <moritz_> will investigate

[07:28] *** f00li5h joined
[07:30] *** wamba joined
[07:46] *** alim joined
[07:47] *** Helios left
[07:49] *** Helios joined
[07:51] *** alim is now known as fingolfin

[07:55] *** fingolfin is now known as fimgolfin

[08:07] <pmichaud> phenny: tell jnthn something about commit 9928a0d causes the REPR to fail on second and subsequent lines with "Can only use nqp_get_sc_for_object with a SixModelObject

[08:07] <phenny> pmichaud: I'll pass that on when jnthn is around.

[08:17] <pmichaud> phenny: tell jnthn I meant REPL, not REPR.  (bad commit found using 'git bisect')

[08:17] <phenny> pmichaud: I'll pass that on when jnthn is around.

[08:24] *** ab5tract joined
[08:24] *** wamba left
[08:32] *** ab5tract left
[08:32] *** ab5tract joined
[08:32] *** Mowah joined
[08:33] *** dakkar joined
[08:45] *** daxim joined
[08:54] <dalek> rakudo/nom: baaef99 | pmichaud++ | src/core/operators.pm:

[08:54] <dalek> rakudo/nom: Handle reversing sequences (e.g., 'z'...'a').

[08:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/baaef99674

[08:54] <dalek> rakudo/nom: 602c0af | pmichaud++ | src/core/ (4 files):

[08:54] <dalek> rakudo/nom: Some additional Range methods.

[08:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/602c0afd26

[08:57] <daxim> http://mail.pm.org/pipermail/moscow-pm/2011-July/010305.html

[08:57] <daxim> [Moscow.pm] perl 6 vs utf8

[09:07] <tadzik> good morning

[09:13] *** tokuhirom left
[09:13] *** thou left
[09:30] *** lichtkind joined
[09:31] *** mls joined
[09:33] <mls> src/core/Bool.pm contains "multi infix:<?|>(Mu $x = Bool::False) { $x.Bool }" in the section for "?^". Seems like a copy'n'paste bug.

[09:47] <mls> Hmm, same with Numeric.pm, "multi infix:<==>($x?)        { Bool::True }" in the "!=" section.

[09:53] *** Trashlord left
[09:57] *** JimmyZ joined
[10:06] *** am0c^ joined
[10:08] *** tzhs joined
[10:12] *** wamba joined
[10:13] *** am0c^ left
[10:19] *** birdwindupbird joined
[10:21] *** whiteknight joined
[10:30] *** Trashlord joined
[10:36] *** JimmyZ_ joined
[10:40] *** JimmyZ left
[10:41] *** JimmyZ_ is now known as JimmyZ

[10:44] *** jimmy1980 left
[10:47] *** fimgolfin left
[10:53] *** jimmy1980 joined
[11:00] *** wamba left
[11:07] <nebuchadnezzar> SIGCOFFEA

[11:09] *** wamba joined
[11:15] *** daniel-s left
[11:20] <colomon> nom: say True ?^ True == False

[11:20] <p6eval> nom: OUTPUT«Segmentation fault␤»

[11:20] <colomon> mis++

[11:20] <colomon> nom: say True ?^ True

[11:20] <p6eval> nom: OUTPUT«Method 'gist' not found for invocant of class 'Undef'␤current instr.: 'say' pc 335032 (src/gen/CORE.setting.pir:87419) (src/gen/CORE.setting:2864)␤»

[11:22] *** mtk joined
[11:30] <flussence> .oO( oh dear, I'm reading the awk manpage all of a sudden... )

[11:35] *** jferrero left
[11:36] *** agentzh left
[11:41] <dalek> roast: e693fe6 | (Solomon Foster)++ | S03-operators/boolean-bitwise.t:

[11:41] <dalek> roast: Add tests for single and zero argument forms of infix:<?|>, infix:<?&>, and infix:<?^>.

[11:41] <dalek> roast: review: https://github.com/perl6/roast/commit/e693fe6f01

[11:41] *** [Coke] left
[11:42] *** stephanmg left
[11:42] <dalek> rakudo/nom: e6f88ff | (Solomon Foster)++ | src/core/Bool.pm:

[11:42] <dalek> rakudo/nom: Fix infix:<?^> copy/paste glitch.

[11:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e6f88fffc0

[11:42] *** stephanmg joined
[11:43] *** stephanmg left
[11:43] *** [Coke] joined
[11:43] *** jferrero joined
[11:51] *** [Coke] left
[11:53] *** [Coke] joined
[11:58] *** satyavvd left
[11:59] *** [Coke] left
[12:01] *** [Coke] joined
[12:05] *** [Coke] left
[12:06] <dalek> roast: 16c3770 | (Solomon Foster)++ | S03-operators/equality.t:

[12:06] <dalek> roast: Add tests for single argument versions of infix:<==> and infix:<!=>.

[12:06] <dalek> roast: 

[12:06] <dalek> roast: Someone with more time could go through and repeat this process for the other operators tested in this file...

[12:06] <dalek> roast: review: https://github.com/perl6/roast/commit/16c3770e4c

[12:07] *** [Coke] joined
[12:08] <dalek> rakudo/nom: 5cd26f6 | (Solomon Foster)++ | src/core/Numeric.pm:

[12:08] <dalek> rakudo/nom: Fix infix:<!=> copy/paste glitch.

[12:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5cd26f6cb2

[12:08] <colomon> mis++

[12:09] <colomon> darn, that felt good

[12:09] <mls> m*l*s actually, but nevermind ;-)

[12:12] <colomon> sorry!  mls++ mls++

[12:14] * [Coke] seems to be disconnecting an awful lot.

[12:19] *** [Coke] left
[12:21] *** [Coke] joined
[12:26] *** masak joined
[12:27] <masak> daxim: utf-8 is the default encoding for Rakudo -- both source and files.

[12:27] <phenny> masak: 03:43Z <thou> tell masak this is confusing: Jun 22 blog post: "Whereas the %d is for integers, the %f is for floating-point values. (It's probably best to avoid confusing oneself by thinking of the non-integers as "decimal numbers" in this case.)"; instead try something like "it's probably best to not think of the non-integer numbers as "decimal numbers" in this case, which would be confusing."

[12:27] <phenny> masak: 04:04Z <thou> tell masak looks like is_prime() is broken in Jun 23 blog post (always returns true). should be defined as:  sub is_prime($n) { return ?($n %% none( 2 .. $n - 1 )); }

[12:27] <phenny> masak: 04:38Z <thou> tell masak your connect four board_is_full() has an off-by-one error (doesn't check the first column). it should be defined as:  sub board_is_full { pile_is_full(all(^$WIDTH)); }

[12:27] <masak> thou: thanks you very much. will handle those when I get home.

[12:28] *** mls left
[12:29] <masak> daxim: what the poster wants to do could be done with something like 'sub MAIN($filename) { open $filename, :w; $filename.say(.flip) for lines("test"); }

[12:29] <masak> '

[12:30] <masak> (we could do without the MAIN, but then we'd have to manually read from @*ARGS)

[12:30] <masak> (we could also do without the 'open', by feeding into $filename.IO, but Rakudo doesn't implement that yet. the above should work.)

[12:32] <masak> daxim: also, the poster writes 'use utf8;' at the top of his source code, and then uses nothing but ASCII in the source code.

[12:33] <masak> hm, oops. I seem to have gotten 'test' and $filename turned around. it's difficult with such uninformative names ;)

[12:34] *** mj41 joined
[12:34] <masak> 'sub MAIN($filename) { given open 'test', :w { .say(.flip) for lines($filename.IO); .close } }'

[12:36] <TimToady> for is also a topicalizer

[12:41] *** bluescreen10 joined
[12:43] <Util> rakudo: my %a; my %b = %a.map({ .say;   .key => (.value + 9)   });

[12:43] <p6eval> rakudo 72d158:  ( no output )

[12:43] <Util> rakudo: my %a; my %b = %a.map({       ( .key => (.value + 9) ) });

[12:43] <p6eval> rakudo 72d158:  ( no output )

[12:43] <Util> rakudo: my %a; my %b = %a.map({         .key => (.value + 9)   });

[12:44] <p6eval> rakudo 72d158: OUTPUT«Method 'key' not found for invocant of class ''␤  in main program body at line 22:/tmp/5BSo6AP6tJ␤»

[12:44] *** matthias_ joined
[12:44] <Util> What is wrong with that 3rd version?

[12:45] <JimmyZ> bug?

[12:45] <matthias_> Util: maybe it thinks of the {...} as a Hash?

[12:45] <masak> TimToady: g'ah! yes.

[12:46] <masak> 'sub MAIN($filename) { given open 'test', :w -> $fh { $fh.say(.flip) for lines($filename.IO); $fh.close } }'

[12:46] <JimmyZ> rakudo: my %a; my %b = %a.map({ .key; (.value + 9) });

[12:46] <p6eval> rakudo 72d158:  ( no output )

[12:47] <JimmyZ> rakudo: my %a; my %b = %a.map({ .key + (.value + 9) });

[12:47] <p6eval> rakudo 72d158:  ( no output )

[12:48] <Util> matthias_: Aha! => alone makes the parser think "Hash", but anything like () or another statement pushes it over the edge to Code. Thanks!

[12:48] <masak> Util: yes.

[12:49] <masak> Util: I also fall into that trap more often than I'd like.

[12:49] <masak> Util: the only real safe recourse is to write map {; ... }, @array

[12:50] <JimmyZ> oh, ugly but must 

[12:50] * JimmyZ says to masak :)

[12:50] <masak> that's what I tend to do anyway when I discover the blog turned out to be a Hash.

[12:51] <masak> rakudo: say { $_ => 1 }.WHAT

[12:52] *** M_o_C joined
[12:52] <p6eval> rakudo 72d158: OUTPUT«Hash()␤»

[12:52] <masak> that's a case that trips me up often enough.

[12:52] <JimmyZ> rakudo: say {; $_ => 1 }.WHAT

[12:52] <p6eval> rakudo 72d158: OUTPUT«Block()␤»

[12:52] <matthias_> masak: reading your post about Roles; I wonder if there is a way to check if a class implements a bunch of methods which are also defined in a role (with same signatures) but that class does not need to "does" the role

[12:52] <JimmyZ> rakudo: say { $_ => 1; }.WHAT

[12:52] <p6eval> rakudo 72d158: OUTPUT«Hash()␤»

[12:53] <matthias_> for example the following returns false: "role R { method foo { say "foo" } }; class A { method foo { say "bar" } }; say A ~~ R"

[12:55] <masak> matthias_: maybe .can and subtypes?

[12:56] <masak> matthias_: no, the above will fail. the 'does' is required.

[12:56] <masak> maybe I should add that to the post.

[12:56] <masak> it didn't occur to me that that might be ambiguous :)

[12:57] <matthias_> I got the idea from Go, that google language. It is a nice idea :)

[12:57] <masak> right. feels very duck-typey.

[12:57] <masak> as I said, I would emulate that behavior with .can and subtypes in Perl 6.

[12:58] <matthias_> ok :)

[12:58] <matthias_> thanks

[12:59] *** Holy_Cow joined
[13:11] *** whiteknight left
[13:12] *** whiteknight joined
[13:12] *** drbean left
[13:18] <tadzik> masak: turns out the algorithm for finding cells isn't sufficient :/ That won't do for the whitespace separators, I'll need moritz's bitwise and technique

[13:18] <dalek> gsocmess: 25f8af8 | tadzik++ | / (3 files):

[13:18] <dalek> gsocmess: Post-process rows instead of trying to parse them with the grammar. Handle multi-line headers properly

[13:18] <dalek> gsocmess: review: https://github.com/tadzik/gsocmess/commit/25f8af8f1b

[13:21] *** mj41 left
[13:22] *** M_o_C left
[13:24] <masak> tadzik: interesting, but not altogether surprising.

[13:27] <matthias_> hm.. I don't seem to get signature checking to work. This is how I try to do it:

[13:27] <matthias_> rakudo: use MONKEY_TYPING; augment class Mu { method acts-like-a($role) { for $role.^methods -> $method { my $own-method = self.can($method); return Bool::False if ! $own-method or $own-method.signature !~~ $method.signature; }; return Bool::True; }; }; role R { method foo { say "foo" }; }; class A { method foo { say "bar" }; }; say A.acts-like-a(R);

[13:27] <p6eval> rakudo 72d158: OUTPUT«Method 'signature' not found for invocant of class 'P6Invocation'␤  in <anon> at line 22:/tmp/7xF5Fb44PT␤  in 'Mu::acts-like-a' at line 1:src/metamodel/RoleToInstanceApplier.nqp␤  in main program body at line 22:/tmp/7xF5Fb44PT␤»

[13:30] *** Su-Shee_ joined
[13:30] *** barika_ joined
[13:30] *** [Coke]_ joined
[13:30] *** dju_ joined
[13:30] *** huf_ joined
[13:33] *** kfo joined
[13:34] *** masak left
[13:34] *** [Coke] left
[13:34] *** Su-Shee left
[13:34] *** huf left
[13:34] *** Vlavv left
[13:34] *** barika left
[13:34] *** dju left
[13:34] *** dju_ is now known as dju

[13:37] *** kfo_ left
[13:39] <matthias_> I figured it's the can() that doesn't work as I expected, because I cannot call .signature() on it. Anyway, I have to do some housework now, see you

[13:39] <TimToady> rakudo is just wrong about { $_ => 1 }, according to S04:1584

[13:39] *** wamba left
[13:39] *** matthias_ left
[13:40] *** Jackneill joined
[13:40] *** Jackneill left
[13:40] *** Jackneill joined
[13:41] *** Vlavv joined
[13:43] *** daniel-s joined
[13:48] *** everbrew joined
[13:49] *** JimmyZ left
[13:54] *** Holy_Cow left
[13:54] *** wamba joined
[13:58] *** daniel-s left
[14:02] <[Coke]_> getting some failings in nom's spectest.

[14:02] <[Coke]_> er, failures.

[14:02] *** [Coke]_ is now known as [Coke]

[14:02] <tadzik> chomp?

[14:03] <[Coke]> t/spec/S02-literals/sub-calls.rakudo; t/spec/S03-operators/equality.t ; t/spec/S32-str/chomp.t

[14:04] <tadzik> I got failures in chomp only, some TODO's passed in some other files

[14:05] <[Coke]> hurm. those 2 work fine if you run them individually.

[14:05] <[Coke]> wonder if something's getting unhappy about TEST_JOBS=5

[14:06] <[Coke]> er, the first one works fine.

[14:06] <[Coke]> 2nd is complaining about infix:<==>

[14:07] <[Coke]> ah, just missing some of the degenerate infixen.

[14:09] <[Coke]> any docs on how to prototype things outside of the setting?

[14:10] *** daniel-s joined
[14:13] <[Coke]> (argh. behind a few revs)

[14:14] <tadzik> is the default .new already in nom?

[14:14] *** mkramer joined
[14:18] <dalek> specs: f30cc88 | larry++ | S03-operators.pod:

[14:18] <dalek> specs: cmp does not throw exceptions, just fails

[14:18] <dalek> specs: 

[14:18] <dalek> specs: Also discuss "mass production" ops that tend to pass failures

[14:18] <dalek> specs: through rather than throw them.  Which ops are so considered

[14:18] <dalek> specs: is of course a matter for ongoing negotiation.

[14:18] <dalek> specs: review: https://github.com/perl6/specs/commit/f30cc88051

[14:18] <dalek> specs: 1a67e98 | larry++ | S02-bits.pod:

[14:18] <dalek> specs: nail down return types of colon radix notation

[14:18] <dalek> specs: review: https://github.com/perl6/specs/commit/1a67e98abc

[14:19] *** mkramer left
[14:26] *** wamba left
[14:26] *** wamba joined
[14:27] *** mj41 joined
[14:28] *** wtw left
[14:31] *** Su-Shee_ is now known as Su-Shee

[14:32] <TimToady> oh, hey! today is 7/6, the day "if you catch my drift" will start drifting into the past finally...

[14:33] <TimToady> or 6/7 if you're .eu-ish

[14:33] <TimToady> 2011-07-06 ftw

[14:33] *** buubot_backup left
[14:37] *** ruz_ joined
[14:37] *** ruz_ is now known as ruz

[14:39] <ruz> explicitly required close on fhs you write to. is it a know bug?

[14:41] <TimToady> probably, but I'm not a bug knowledge expert

[14:41] <flussence> sounds familiar

[14:42] <TimToady> in any case, at the least, an IO should autoclose during global destruction, if not GC'd earlier

[14:42] *** kaare_ joined
[14:42] <flussence> oh, I remember now

[14:42] <flussence> rakudo doesn't *have* destructors yet

[14:42] <flussence> that's why

[14:42] <TimToady> well, that would do it...

[14:43] <TimToady> so definitely a "known" but, whether or not it's in the database

[14:43] <TimToady> *bug

[14:43] <TimToady> well, it's a "but" too

[14:43] <TimToady> in any case, it's not going to do timely destruction by refcount standards

[14:45] <TimToady> that does imply the need for more explicit close control, however it's expressed, in cases where that matters

[14:46] <dalek> roast: f712dbc | Coke++ | S32-str/lc.t:

[14:46] <dalek> roast: untodo passing rakudo test.

[14:46] <dalek> roast: review: https://github.com/perl6/roast/commit/f712dbc71b

[14:48] <TimToady> probably some sugar over: my $fh will leave *.close = open $filename

[14:52] <[Coke]> bah. need to get a separate git-repo for running spectest and for editing spectest. :P

[14:53] <tadzik> suddenly, Null PMC Accesses. Everywhere

[14:55] *** buubot_backup joined
[14:58] * TimToady thinks Instant should have a .gist but not a .Str, or people will start relying on the conversion

[14:58] <TimToady> (they might anyway, even with .gist)

[14:59] *** _jaldhar left
[15:00] *** wamba left
[15:10] *** mattp_ left
[15:14] *** daniel-s left
[15:15] *** daniel-s joined
[15:17] *** mattp_ joined
[15:20] *** tokuhirom joined
[15:20] <flussence> .Str could return a TAI64 timestamp, it's a bit obscure but at least it's well-defined and parseable.

[15:20] <TimToady> +1

[15:24] <arnsholt> Def'nitely

[15:27] <TimToady> it's def'ed more often than nitely...

[15:30] *** tzhs left
[15:32] *** daniel-s left
[15:34] *** daniel-s joined
[15:44] <dalek> roast: 8d5f971 | Coke++ | S32-num/rat.t:

[15:44] <dalek> roast: untodo passing rakudo tests.

[15:44] <dalek> roast: review: https://github.com/perl6/roast/commit/8d5f971fad

[15:44] <slavik> TimToady: do you have an approach to learning a new language?

[15:44] <tadzik> oh crap, I commited to nom instead of a branch

[15:44] <tadzik> git wizards?

[15:44] <slavik> language == a human language

[15:44] <slavik> rebase it to a commit before yours

[15:45] <slavik> http://stackoverflow.com/questions/373812/rollback-file-to-much-earlier-version

[15:45] <tadzik> hmm, I can start a new branch out of nom now, and just hardreset nom, right?

[15:45] <slavik> git reset --hard SHA1_HASH

[15:45] <slavik> yes

[15:45] <tadzik> thanks

[15:45] <slavik> tadzik: more than always, google will have an answer :)

[15:46] <tadzik> probably, yes :)

[15:46] <tadzik> maybe I was subconsciously hoping for "go ahead, push it to nom anyway!" :P

[15:47] <dalek> roast: 77bbd5b | Coke++ | S02-whitespace_and_comments/minimal-whitespace.t:

[15:47] <dalek> roast: untodo a passing rakudo test.

[15:47] <dalek> roast: (looks like nom switched which one was passing...)

[15:47] <dalek> roast: review: https://github.com/perl6/roast/commit/77bbd5b0b2

[15:48] *** barika_ is now known as barika

[15:49] <TimToady> slavik: only obsessive commitment to learning it every way possible

[15:49] <slavik> the only thing I don't have :(

[15:50] <TimToady> the only other way is to live there

[15:50] *** JimmyZ joined
[15:50] <JimmyZ> Hello, videos of jnthn's talks in beijing are downloadable, http://vps.syshacker.com:8000/Perl6_Quicker_hacks_more_maintainable_apps.flv and http://vps.syshacker.com:8000/Rakudo_The_story_of_a_compiler.flv 

[15:50] <tadzik> slavik: oh, but won't my new branch now be a parent of a non-existing commit?

[15:51] <slavik> tadzik: I would say, get the file, rollback to previous commit, branch there, then commit the file you got to the new branch

[15:52] <tadzik> okay, I got it I think :)

[15:52] <tadzik> without recommiting even

[15:53] *** daniel-s left
[15:53] <tadzik> or not

[15:56] *** JimmyZ left
[15:57] <everbrew> slavik, same way 2 year olds learn their native language -- 80 hours a week of Sesame Street ;-)

[15:58] <slavik> :(

[15:59] <everbrew> I think Sesame Street is in every major language family now.  At least I've seen Mandarin, German, Japanese, and Spanish.

[15:59] *** donri joined
[15:59] <everbrew> Now we just need Elmo to do a weekly podcast on Perl for kids.

[15:59] <sbp> perl...                                             ...six?

[15:59] <sbp> perl...                                     ...six?

[15:59] <sbp> perl...                            ...six?

[15:59] <sbp> perl...                ...six?

[15:59] <sbp> perl...      ...six?

[15:59] <everbrew> heh

[15:59] <sbp> perl... ...six?

[15:59] <sbp> perl... six!

[16:00] <sbp> PERL6!

[16:00] <sbp> they should do a Sesame Street special for programming languages

[16:00] <sbp> Bert and Ernie could teach binary

[16:01] <sbp> Mr. Snuffleupagus and the Von Neumann Machine

[16:01] <sbp> this could be a thing, you know

[16:02] <dalek> rakudo/podparser: e258ef5 | tadzik++ | src/Perl6/SymbolTable.pm:

[16:02] <dalek> rakudo/podparser: Allow named parameters to new_type in add_constant()

[16:02] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/e258ef5a68

[16:02] <dalek> rakudo/podparser: 9d33af3 | tadzik++ | / (2 files):

[16:02] <dalek> rakudo/podparser: Import as little Pod classes as needed, less hacky than before due to default .new working again

[16:02] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/9d33af3969

[16:02] <dalek> rakudo/podparser: e653b7f | tadzik++ | src/Perl6/ (2 files):

[16:02] <dalek> rakudo/podparser: Build (empty so far) $POD variable

[16:02] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/e653b7fb4b

[16:04] <tadzik> moritz_: fyi, the podparser branch now is not the podparser branch that was there yesterday, I did some mangling around it and you may want to remove & refetch it, sorry for that

[16:06] <pmichaud> good morning, #perl6

[16:07] <[Coke]> speaking of multilingual, I am enjoying my new forkchops immensely.

[16:07] *** ab5tract left
[16:07] <tadzik> good morning pmichaud 

[16:09] <[Coke]> pmichaud: o/

[16:12] *** Bzek left
[16:12] *** Bzek joined
[16:17] <tadzik> seen jnthn

[16:17] <aloha> jnthn was last seen in #perl6 13 hours 30 mins ago saying "Thanks!".

[16:22] *** mattp_ left
[16:27] *** whiteknight left
[16:27] *** whiteknight joined
[16:30] *** wamba joined
[16:31] <tadzik> yay, I tracked down the serializing Pod bug. Unfortunately, it happens to be a SymbolTable bug of some sort :(

[16:35] <tadzik> pmichaud: could you take a look at https://gist.github.com/1067686 ?

[16:37] <tadzik> oh, I think I got it :)

[16:37] <tadzik> my $cache_key := "$type,$primitive," ~ pir::join(',', @value);

[16:39] <pmichaud>         :name($name<compile_time_value>),

[16:39] <pmichaud> ....why are you adding a constant PAST back into $*ST ?

[16:39] <pmichaud> that seems... wrong.

[16:40] <pmichaud> well, it's not a constant PAST... but it still looks weird.

[16:40] <pmichaud> and why the :name() ?

[16:40] <pmichaud> I don't think that .add_constant takes a :name() parameter.

[16:41] <tadzik> I'm creating a Pod::Block, as in https://github.com/rakudo/rakudo/commit/9d33af

[16:41] <tadzik> pmichaud: I fixed that, see the url in the gist

[16:41] <tadzik> but I didn't fix the cache key creation, it still bases on @values only

[16:41] <tadzik> and $.name is a child of Pod::Block, so it needs to be serialized before, and then the block is referring to it

[16:42] <pmichaud> okay, it makes more sense.  Yes, both st entries are ending up with a common key, because it only uses @value in the key.

[16:43] <tadzik> yes, I'm fixing that. How do I listify a hash in nqp somehow?

[16:44] *** cdarroch joined
[16:44] *** cdarroch left
[16:44] *** cdarroch joined
[16:44] <pmichaud> currently with a for loop.

[16:44] <tadzik> okay

[16:44] <pmichaud> I'm planning to make list and hash interpolation into nqp:: primitives, but nyi

[16:48] *** pyrimidine joined
[16:48] <tadzik> yes, fixed!

[16:50] *** birdwindupbird left
[16:53] <tadzik> phenny: "uwzględniać"?

[16:53] <phenny> tadzik: "include" (pl to en, translate.google.com)

[16:55] *** MayDaniel joined
[16:57] <dalek> rakudo/podparser: 6a71d46 | tadzik++ | src/Perl6/SymbolTable.pm:

[16:57] <dalek> rakudo/podparser: [SymbolTable] Include the %named parameter signature in the cache key creation

[16:57] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/6a71d46fbe

[16:59] *** mj41 left
[17:00] *** daxim left
[17:01] *** whiteknight left
[17:01] *** whiteknight joined
[17:02] *** tokuhirom left
[17:02] *** dakkar left
[17:05] *** MayDaniel left
[17:07] *** zby_home joined
[17:08] * moritz_ back online

[17:09] *** bluescreen10 left
[17:10] <tadzik> \o/

[17:10] <moritz_> driving for more than an hour with a baby can be quite exhausting :-)

[17:11] <pyrimidine> moritz_: try flying with one :)

[17:11] <tadzik> pyrimidine: like, being a pilot? :P

[17:12] <pyrimidine> tadzik: that would be even more interesting!  Nope, as a passenger

[17:13] *** noganex left
[17:14] *** noganex joined
[17:17] * [Coke] does not miss the days of travelling with young kids.

[17:19] *** mj41 joined
[17:29] <moritz_> nom: my $name = "sqrt"; say 2."$name"

[17:29] <p6eval> nom: OUTPUT«Quoted method name requires parenthesized arguments at line 1, near ""␤current instr.: 'nqp;HLL;Grammar;panic' pc 23666 (src/stage2/gen/NQPHLL.pir:6380) (src/stage2/gen/NQPHLL.pm:328)␤»

[17:29] <moritz_> nom: my $name = "sqrt"; say 2."$name"()

[17:29] <p6eval> nom: OUTPUT«1.4142135623731␤»

[17:30] *** wamba left
[17:30] *** jonn joined
[17:31] <moritz_> nom: say True === True

[17:31] <p6eval> nom: OUTPUT«Bool::True␤»

[17:31] *** Mowah left
[17:32] <moritz_> nom: say (1, 2).list eqv (1, 2).list

[17:32] *** leprevost joined
[17:32] <p6eval> nom: OUTPUT«Bool::True␤»

[17:32] <moritz_> nom: say (1, 2).list eqv (1, 2.0).list

[17:32] <p6eval> nom: OUTPUT«Bool::True␤»

[17:32] <moritz_> :(

[17:39] <[Coke]> nom: say 2 eqv 2.0

[17:39] <p6eval> nom: OUTPUT«Bool::False␤»

[17:40] *** Mowah joined
[17:42] *** mj41 left
[17:43] *** saaki left
[17:43] <moritz_> nom: say 0.Bool

[17:43] <p6eval> nom: OUTPUT«Bool::False␤»

[17:43] <moritz_> nom: say 0.5.floor

[17:43] <p6eval> nom: OUTPUT«0␤»

[17:43] *** Jackneill left
[17:43] <moritz_> nom: say 0.5.Bool

[17:43] <p6eval> nom: OUTPUT«Bool::True␤»

[17:44] <moritz_> wtf?

[17:44] <moritz_> nom: say 0.5.floor.WHAT

[17:44] <p6eval> nom: OUTPUT«Num()␤»

[17:44] <moritz_> oh

[17:44] <moritz_> nom: say 0.0.Bool

[17:44] <p6eval> nom: OUTPUT«Bool::True␤»

[17:44] <moritz_> nom: say 0.0e0.Bool

[17:44] <p6eval> nom: OUTPUT«Bool::True␤»

[17:44] <flussence> nom: say (0.0).Bool

[17:44] <p6eval> nom: OUTPUT«Bool::True␤»

[17:44] <benabik> 0.0.Bool == True?

[17:44] <flussence> False.

[17:45] <pmichaud> I'm guessing Num.Bool isn't defined.

[17:45] <pmichaud> nom:  say Num.^methods

[17:45] <p6eval> nom: OUTPUT«Num Bridge Int Rat atan2 succ pred isNaN abs exp log sqrt rand ceil floor sin asin cos acos tan atan sec asec sinh cosh tanh sech Str abs sqrt sin cos tan sinh cosh tanh floor ceiling unpolar cis log exp Numeric log log10 exp ACCEPTS bytes chars fmt substr uc lc ucfirst lcfi…

[17:45] <pmichaud> nom:  say Num.^methods(:local)

[17:45] <p6eval> nom: OUTPUT«Num Bridge Int Rat atan2 succ pred isNaN abs exp log sqrt rand ceil floor sin asin cos acos tan atan sec asec sinh cosh tanh sech Str␤»

[17:45] <pmichaud> nom:  say Real.^methods(:local)

[17:45] <p6eval> nom: OUTPUT«abs sqrt sin cos tan sinh cosh tanh floor ceiling unpolar cis log exp␤»

[17:45] <pmichaud> nom:  say Numeric.^methods(:local)

[17:45] <p6eval> nom: OUTPUT«Numeric log log10 exp ACCEPTS␤»

[17:45] <pmichaud> Since there's no .Bool method defined, it defaults to   0.0.defined

[17:46] * moritz_ fixes

[17:46] <moritz_> I guess it should go into Numeric

[17:46] <pmichaud> I know that there's an Int.Bool already

[17:46] <pmichaud> but I'm fine with it going into Numeric

[17:46] <pmichaud> (probably worthwhile to have an Int.Bool that is hotpath-optimized)

[17:46] <moritz_> rakudo: say NaN.Bool

[17:46] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[17:47] <moritz_> rakudo: say Inf.Bool

[17:47] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[17:47] *** saaki joined
[17:48] <moritz_> background was that I was just testing my newly Pair.ACCEPTS

[17:48] <moritz_> so I needed a a method where the result boolified to false

[17:48] <moritz_> rakudo: say 0.5 ~~ :sqrt

[17:48] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[17:48] <moritz_> rakudo: say 0.5 ~~ :floor

[17:48] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[17:49] <moritz_> and that was true in my local tests, and I wondered why... :-)

[17:49] <moritz_> fix forthcoming

[17:49] <pmichaud> probably need a spectest for Num.Bool, also.

[17:50] <moritz_> might already be in S03-operators/context.t or so

[17:50] <tadzik> https://gist.github.com/1067867 -- I could use some nqp help

[17:53] <tadzik> moritz_, pmichaud, could you take a look please?

[17:53] <moritz_> tadzik: say("produced: ", $cheatpast<compile_time_value>);

[17:53] <moritz_> tadzik: aren't you more interested in $produced<compile_time_value> here?

[17:53] <moritz_> erm

[17:54] <moritz_> $content<compile_time_value> I mean

[17:54] <tadzik> oh, sure

[17:55] <tadzik> yeah, it produces "bacon bacon"

[17:55] <tadzik> so it gets duplicated inside add_constant

[17:56] <moritz_> nom: say Array.new('bacon').perl

[17:56] <p6eval> nom: OUTPUT«Array.new("bacon")␤»

[17:56] <tadzik> thanks moritz_ 

[17:56] <moritz_> nom: say List.new('bacon').perl

[17:56] <p6eval> nom: OUTPUT«("bacon",).list␤»

[17:58] <moritz_> might be worth checking $name<compile_time_value>

[17:59] <tadzik> that one's ok. It's just "pod" or "otherpod"

[17:59] <pmichaud> one of the problems with using string keys like this is that we'll end up with collisions.

[18:00] *** cooper left
[18:00] *** Chillance left
[18:06] <tadzik> I think they're expected, so you can look up identical objects in a cache and create them once

[18:06] <pmichaud> no, I mean collisions for things that are definitely different.

[18:07] <pmichaud> $*ST.add_constant('MyType', 'type_new', :xyz(123))

[18:07] <pmichaud> and

[18:07] <pmichaud> $*ST.add_constant('MyType', 'type_new', 'xyz,123;')

[18:08] <pmichaud> the first is a named argument, the second is a positional argument, but they both end up with the same cache key.

[18:08] <tadzik> true

[18:08] <tadzik> that's the same problems with positionals

[18:08] <tadzik> 'xyz,123' and 'xyz', '123'

[18:08] <pmichaud> agreed, that's a problem also.

[18:09] <pmichaud> you can potentially fix it by forcing a string onto each value

[18:09] *** dual left
[18:09] <pmichaud> i.e., positionals become  'p:123'  and named becomes  n:xyz,123

[18:09] *** Krunch_ is now known as Krunch

[18:10] <pmichaud> then   'xyz,123'  ends up being  p:xyz,123   while 'xyz', '123'  becomes  'p:xyz,p:123'.  Still some collisions there, though.

[18:11] *** jonn is now known as someone_else

[18:11] *** someone_else is now known as pyrexkidd

[18:17] <dalek> rakudo/nom: b20c00f | pmichaud++ | src/core/Cool.pm:

[18:17] <dalek> rakudo/nom: Add Cool.rand.

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b20c00f317

[18:17] <dalek> rakudo/nom: 9e91676 | pmichaud++ | src/core/ (3 files):

[18:17] <dalek> rakudo/nom: Add List.pick, Any.pick, and Range.at_pos.

[18:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9e916766df

[18:20] * jnthn home

[18:20] <phenny> jnthn: 06:30Z <moritz_> tell jnthn I was not sure if includiing the sub in the backtrace object might lead to memory leakage somehow - maybe that was overly pessimistic

[18:20] <phenny> jnthn: 08:07Z <pmichaud> tell jnthn something about commit 9928a0d causes the REPR to fail on second and subsequent lines with "Can only use nqp_get_sc_for_object with a SixModelObject

[18:20] <phenny> jnthn: 08:17Z <pmichaud> tell jnthn I meant REPL, not REPR.  (bad commit found using 'git bisect')

[18:20] *** dual joined
[18:21] <tadzik> oh, jnthn, just when I tracked the SymbolTable bug :)

[18:21] <tadzik> jnthn: how was your flight?

[18:21] <pmichaud> jnthn: o/

[18:23] <jnthn> pmichaud: Thanks for bisecting the REPL bustage...I had noticed it but didn't get to working it out yet. Unfortunatley, looking over the commit doesn't make the reason jump out either...anyway, will find and fix it soon.

[18:23] <pmichaud> yes, I looked over the commit and couldn't quite figure out why either.

[18:24] <jnthn> tadzik: Was fine, just long, but that's nothing unexpected. A bit hot at first, but cooled off after a bit.

[18:24] <tadzik> jnthn: could you look at https://gist.github.com/1067948 in some spare time?

[18:25] <jnthn> tadzik: I'm doubtful that it's 748

[18:26] <jnthn> tadzik: oh

[18:26] <jnthn> wtf

[18:26] <tadzik> yeah, that's what I said

[18:26] <tadzik> I end up having Array.new("bacon", "bacon")

[18:27] <jnthn> Does one say after another exhibit this?

[18:27] <jnthn> nom: my $x = Array.new("bacon"); say $x; say $x;

[18:27] <tadzik> let me see

[18:27] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[18:27] <jnthn> er.

[18:27] <tadzik> oh crap

[18:27] <jnthn> It's not the SC.

[18:27] <jnthn> It's the array constructor

[18:27] <jnthn> !!!

[18:27] <tadzik> O_O

[18:27] <jnthn> nom: my $x = List.new("bacon"); say $x; say $x;

[18:27] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[18:28] <pmichaud> it's not the constructor.

[18:28] <jnthn> nom: my $x = List.new("bacon"); say $x; say $x; say $x;

[18:28] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤bacon bacon␤»

[18:28] <jnthn> hm, it does max out on bacon after a while...

[18:28] <pmichaud> nom: my $x = List.new('bacon');  say $x.perl;  say $x.perl;

[18:28] <p6eval> nom: OUTPUT«("bacon",).list.item␤("bacon",).list.item␤»

[18:28] <tadzik> ah, I almost thought it'd be perpetuum-beconae

[18:28] <pmichaud> nom: my $x = List.new('bacon');  say $x.perl;  say $x; say $x.perl;

[18:28] <p6eval> nom: OUTPUT«("bacon",).list.item␤bacon␤("bacon",).list.item␤»

[18:28] <pmichaud> nom: my $x = List.new('bacon');  say $x.perl;  say $x; say $x.perl; say $x;

[18:28] *** cooper joined
[18:28] <p6eval> nom: OUTPUT«("bacon",).list.item␤bacon␤("bacon",).list.item␤bacon␤»

[18:29] <pmichaud> nom: my $x = List.new('bacon');  say $x.perl;  say $x;  say $x;

[18:29] <p6eval> nom: OUTPUT«("bacon",).list.item␤bacon␤bacon␤»

[18:29] <jnthn> nom: my @a = 'bacon'; say @a; say @a;

[18:29] <p6eval> nom: OUTPUT«bacon␤bacon␤»

[18:29] <pmichaud> nom: my $x = List.new('bacon');  say $x;  say $x;

[18:29] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[18:30] <pmichaud> nom: my $x = List.new('bacon');  say $x;  say $x;  say $x.perl;

[18:30] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤("bacon",).list.item␤»

[18:30] <pmichaud> nom: my $x = List.new('bacon');  say ~$x;  say ~$x;

[18:30] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[18:30] <pmichaud> nom: my $x = List.new('bacon');  say $x.Str;  say $x.Str;

[18:30] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[18:31] <pmichaud> nom: my $x = List.new('bacon');  print $x.Str;  print $x.Str;

[18:31] <p6eval> nom: OUTPUT«baconbacon bacon»

[18:31] <pmichaud> nom: my $x = List.new('bacon');  nqp::print($x.Str);  nqp::print($x.Str);

[18:31] <p6eval> nom: OUTPUT«baconbacon bacon»

[18:31] <pmichaud> nom: my $x = List.new('bacon');  my $y := $x.Str;  my $z := $x.Str;  say $y, $z

[18:31] <p6eval> nom: OUTPUT«baconbacon bacon␤»

[18:32] <pmichaud> nom: my $x = List.new('bacon');  my $y := $x.Str;  my $z := $x.Str;  say $y, $z, $x

[18:32] <p6eval> nom: OUTPUT«baconbacon baconbacon bacon␤»

[18:32] <pmichaud> that's just.... weird

[18:32] <tadzik> I spent like 2 days on that :)

[18:33] <pmichaud> nom: my $x = List.new('bacon');  my $y := $x.Str;  my $z := $x.Str;  say $x.elems

[18:33] <p6eval> nom: OUTPUT«1␤»

[18:33] <pmichaud> I'm suspicious of .join

[18:34] <pmichaud> or maybe .shift

[18:34] <flussence> my poking through the source points to .join too, but I've no idea where .join is actually defined :(

[18:34] <pmichaud> nom: my $x = List.new('bacon');  my $y = ($x,).flat.eager

[18:34] <p6eval> nom:  ( no output )

[18:34] <pmichaud> nom: my $x = List.new('bacon');  my $y = ($x,).flat.eager; say $y

[18:34] <p6eval> nom: OUTPUT«bacon␤»

[18:35] <pmichaud> nom: my $x = List.new('bacon');  my $y = ($x,).flat.eager; say $y.shift; say $y.shift;

[18:35] <p6eval> nom: OUTPUT«bacon␤Element shifted from empty list␤current instr.: 'rethrow' pc 384545 (src/gen/CORE.setting.pir:110053) (src/gen/CORE.setting:3369)␤»

[18:35] <pmichaud> nom: my $x = List.new('bacon');  my $y = ($x,).flat.eager; say $y.gimme(0);

[18:35] <p6eval> nom: OUTPUT«1␤»

[18:35] <pmichaud> (testing locally)

[18:36] * jnthn bbiab, need to sort out a few things now I'm home :)

[18:36] *** donaldh joined
[18:37] <pmichaud> reproduced locally with a new 'join' sub

[18:37] <pmichaud> so now to investigate

[18:42] <moritz_> nom: say 0i.Bool

[18:42] <p6eval> nom: OUTPUT«Bool::True␤»

[18:42] <moritz_> that's especially weird

[18:42] <tadzik> nom: say Complex.^methods(:local)

[18:42] <p6eval> nom: OUTPUT«re im new BUILD reals isNaN Real Num Int Rat Complex conjugate abs polar sqrt Bool Str perl log exp␤»

[18:42] *** impious joined
[18:42] <tadzik> oh

[18:43] <moritz_> since it has Bool method

[18:43] <tadzik> nom: say 0i.WHAT

[18:43] <p6eval> nom: OUTPUT«Complex()␤»

[18:43] <moritz_>     multi method Bool(Complex:D:) {

[18:43] <moritz_>         $!re != 0e0 || $!im != 0e0;

[18:43] <moritz_>     }

[18:43] <tadzik> nom: say 0i == 0e0

[18:43] <p6eval> nom: OUTPUT«Bool::True␤»

[18:43] *** masak joined
[18:43] <masak> goood evening, #perl6.

[18:43] <tadzik> good evening masak 

[18:43] <pmichaud> nom:  say 0e0 != 0e0;

[18:44] <p6eval> nom: OUTPUT«Bool::False␤»

[18:44] <benabik> nom: 1i.Bool

[18:44] <p6eval> nom:  ( no output )

[18:44] <benabik> nom: 1i.Bool.say

[18:44] <moritz_> I suspect that somehow .Bool doesn't dispatch the way we want it

[18:44] <p6eval> nom: OUTPUT«Bool::True␤»

[18:44] *** mj41 joined
[18:44] *** alester joined
[18:44] <pmichaud> nom:  my num $x = 0;   say $x != 0e0

[18:44] <moritz_> nom: say ().Bool

[18:44] <p6eval> nom: OUTPUT«Bool::False␤»

[18:44] <p6eval> nom: OUTPUT«Bool::True␤»

[18:45] <moritz_> nom: say ().Bool

[18:45] <p6eval> nom: OUTPUT«Bool::True␤»

[18:45] <pmichaud> Parcel.Bool probably not defined.

[18:45] <TimToady> nom: say Nil.Bool

[18:45] <p6eval> nom: OUTPUT«Bool::False␤»

[18:45] <moritz_> nom: say ().list.Bool

[18:45] <p6eval> nom: OUTPUT«Bool::False␤»

[18:45] <TimToady> probably using Mu's def

[18:47] *** donaldh left
[18:47] <moritz_> adding some debug output to Complex.Bool shows that it's never called on 0i.Bool

[18:48] * moritz_ guess it's something that jnthn++ needs to take a look at

[18:50] <pmichaud> several of the Bool method defs look like they need to be turned into multis

[18:50] <pmichaud> but that doesn't appear to explain the Complex.Bool case

[18:50] <pmichaud> moritz_: did you add a Bool def to Cool or Real or Numeric?

[18:51] <TimToady> what was the nature of the Bool hack mentioned earlier?

[18:51] <pmichaud> which Bool hack?  ;)

[18:52] <TimToady> just wonder if something could be rewriting .Bool somewhere

[18:52] *** am0c joined
[18:52] <masak> you're probably thinking of that hack, George Boole :P

[18:52] <pmichaud> the one I did rewrites  'Bool::True' into a constant true object

[18:52] *** cdarroch left
[18:53] <dalek> rakudo/nom: 1f8fe70 | moritz++ | src/core/Pair.pm:

[18:53] <dalek> rakudo/nom: Pair.ACCEPTS

[18:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f8fe70bf3

[18:53] <dalek> rakudo/nom: 8aa37ff | moritz++ | src/core/Numeric.pm:

[18:53] <dalek> rakudo/nom: add Numeric.Bool -- but it does not seem to get called at all

[18:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8aa37ffbcc

[18:55] *** Mowah left
[18:56] <pmichaud> yeah, feels like a bug with the multidispatch somewhere.

[18:56] *** envi left
[18:57] <TimToady> does .Type get rewritten to Type()?

[18:58] <pmichaud> no

[18:58] * TimToady wonders why it's a multi

[18:59] <pmichaud> because Complex.Bool is false :-)

[18:59] <pmichaud> while (1i).Bool is true

[18:59] <TimToady> when there's only an

[18:59] <TimToady> invocant

[18:59] <TimToady> which single dispatch already finds

[18:59] <pmichaud> you're saying we should test definedness in Bool?

[19:00] <pmichaud> i.e.,    method Bool() { self.defined && ... }

[19:00] <TimToady> no, I'm saying single dispatch would already hand off :U to the parents without the multi

[19:01] <TimToady> or :A rather :)

[19:01] <pmichaud> right now we have it defined as

[19:01] <pmichaud> (in Complex)

[19:02] <pmichaud>     multi method Bool(Complex:D:) { $!re != 0e0 || $!im != 0e0 }

[19:02] <TimToady> I'm just saying 'multi' relies on double dispatch, which we don't need if the first dispatch finds the right proto/only

[19:02] *** mj41 left
[19:02] <pmichaud> if we eliminate the multi there

[19:02] <pmichaud>     method Bool(Complex:D:) { $!re != 0e0 || $!im != 0e0 }

[19:02] <pmichaud> won't   Complex.Bool   fail to dispatch?

[19:03] <TimToady> it dispatches to Mu

[19:03] <TimToady> where it's false

[19:03] <pmichaud> so, "method Bool"  doesn't hide other instance of .Bool in the parent classes?

[19:04] <TimToady> hmm, one could argue it both ways, but I see what you're saing

[19:04] <TimToady> *y

[19:04] <pmichaud> which one does the spec expect?

[19:05] <TimToady> the invocant is a bit vague when it comes to invocant types

[19:05] <TimToady> but I'd say it probably leans toward your interpretation, in the sense that the invocant is just an arg at that point

[19:05] <jnthn> Multi method dispatch works like this.

[19:05] <jnthn> It's a completely normal single dispatch which finds the proto

[19:06] <jnthn> Which then chooses the appropriate multi candidate.

[19:06] <pmichaud> \o/   jnthn is here to save me :)

[19:06] <jnthn> There's no handing off anywhere.

[19:06] <jnthn> Ever.

[19:06] <masak> jnthn! \o/

[19:06] <jnthn> Unless you explicitly hand off with nextsame/callsame/etc

[19:06] <TimToady> so maybe the proto isn't finding the Bool multi

[19:06] <jnthn> That may well be the case.

[19:06] <TimToady> rakudo: say 0i.Bool

[19:06] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[19:06] <[Coke]> rakudo, nom: say "what?"

[19:06] *** Mowah joined
[19:06] <TimToady> nom: say 0i.bool

[19:06] <p6eval> nom: OUTPUT«Method 'bool' not found for invocant of class 'Complex'␤current instr.: '_block1002' pc 75 ((file unknown):8310176) (/tmp/wH84jfPVDm:1)␤»

[19:07] <TimToady> nom: say 0i.Bool

[19:07] <p6eval> nom: OUTPUT«Bool::True␤»

[19:07] <jnthn> nom: say Complex.^mro

[19:07] <p6eval> nom: OUTPUT«Complex() Numeric() Cool() Any() Mu()␤»

[19:07] <jnthn> Numeric?!

[19:07] <jnthn> Oh, we had it as a class as a hack rather than a role...

[19:08] <pmichaud> shouldn't make a difference here, though.

[19:08] <jnthn> yeah, I was just wondering why a role ended up in the MRO :P

[19:08] <pmichaud> I need lunch.  I'll figure out the "bacon bacon" bug when I get back.  It's a Parcel and/or List bug somewhere.

[19:12] <tadzik> \o/

[19:13] <jnthn> moritz_: OK, need to look deeper at what's going on. I don't see why it'd not call the subclass one...

[19:15] <masak> there's a "bacon bacon" bug? :)

[19:16] <tadzik> yeah. It actually made me abandon all monday's work, for I was sure I was doing something fundamentally wrong

[19:16] <tadzik> nom: my $x = Array.new("bacon"); say $x; say $x;

[19:16] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[19:16] <[Coke]> there is nothing fundamentally wrong with bacon.

[19:17] <flussence> it shouldn't be undergoing mitosis though

[19:17] <tadzik> turns out self-replicating bacon isn't as good as you thought it'd be :)

[19:17] <flussence> (that means you haven't cooked it enough)

[19:17] * TimToady refrains from making a pun on "long bacon"

[19:19] <TimToady> nom: my $x = List.new("bacon"); say $x.munch(1); say $x

[19:19] <p6eval> nom: OUTPUT«elements() not implemented in class 'Mu'␤current instr.: 'munch' pc 372520 (src/gen/CORE.setting.pir:104365) (src/gen/CORE.setting:2204)␤»

[19:20] <TimToady> nom: my $x = Array.new("bacon"); say $x.shift; say $x

[19:20] <p6eval> nom: OUTPUT«bacon␤␤»

[19:20] *** Holy_Cow joined
[19:20] *** Holy_Cow left
[19:20] <TimToady> nom: my $x = Array.new("bacon"); say $x; $x.shift; say $x

[19:20] <p6eval> nom: OUTPUT«bacon␤bacon␤»

[19:21] <TimToady> hmm

[19:21] <TimToady> nom: my $x = Array.new("bacon"); say $x; $x.shift; $x.shift; say $x

[19:21] <p6eval> nom: OUTPUT«bacon␤␤»

[19:22] <TimToady> nom: my $x = Array.new("bacon"); $x.gist; say $x

[19:22] <p6eval> nom: OUTPUT«bacon bacon␤»

[19:22] <TimToady> looks to me like .gist is doing it

[19:22] <jnthn> nom: my $x := ['bacon']; say $x; say $x;

[19:22] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[19:22] <TimToady> except .Str was doing it too

[19:23] <TimToady> nom: my $x = Array.new("bacon"); $x[0].say; say $x

[19:23] <p6eval> nom: OUTPUT«bacon␤bacon␤»

[19:23] <TimToady> nom: my $x = Array.new("bacon"); $x[*].say; say $x

[19:23] <p6eval> nom: OUTPUT«bacon␤bacon␤»

[19:24] <TimToady> nom: my $x = Array.new("bacon"); say @($x); say $x

[19:24] <p6eval> nom: OUTPUT«bacon␤bacon bacon␤»

[19:24] *** wamba joined
[19:24] <TimToady> subscripting seems to suppress it

[19:25] <TimToady> nom: my $x = Array.new("bacon"); $x[0]; say $x

[19:25] <p6eval> nom: OUTPUT«bacon␤»

[19:25] <TimToady> nom: my $x = Array.new("bacon"); $x[0]; say $x; say $x;

[19:25] <p6eval> nom: OUTPUT«bacon␤bacon␤»

[19:25] <TimToady> you don't have to say the subscript to suppress it

[19:27] <TimToady> nom: my $x = Array.new("bacon"); $x.elems; say $x; say $x;

[19:27] <p6eval> nom: OUTPUT«bacon␤bacon␤»

[19:27] <TimToady> that works too

[19:28] <TimToady> almost as if the reified bit was leaking into the planned bit

[19:29] <TimToady> or vice versa

[19:29] <benabik> It looks like it depends on how it's getting iterated over.

[19:29] <tadzik> funny :)

[19:30] <TimToady> nom: my $x = List.new("bacon", "bits"); say $x; say $x;

[19:30] <p6eval> nom: OUTPUT«bacon bits␤bacon bits bacon bits␤»

[19:30] <diakopter> someone should write a paper on how interactive mostly-synchronous builds (p6eval) affects the language design process

[19:31] <masak> +1

[19:31] <masak> it affects bug reporting and implementations as well.

[19:32] <diakopter> or at least a series of blog entries

[19:33] <TimToady> nom: my $x = List.new("bacon", "bits"); say $x.munch; say $x;

[19:33] <p6eval> nom: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤current instr.: 'munch' pc 372520 (src/gen/CORE.setting.pir:104365) (src/gen/CORE.setting:2204)␤»

[19:33] <TimToady> nom: my $x = List.new("bacon", "bits"); say $x.munch(1); say $x;

[19:33] <p6eval> nom: OUTPUT«elements() not implemented in class 'Mu'␤current instr.: 'munch' pc 372520 (src/gen/CORE.setting.pir:104365) (src/gen/CORE.setting:2204)␤»

[19:33] <TimToady> nom: my $x = List.new("bacon", "bits"); say $x.munch(*); say $x;

[19:33] <p6eval> nom: OUTPUT«This type cannot unbox to a native integer␤current instr.: 'munch' pc 372636 (src/gen/CORE.setting.pir:104411) (src/gen/CORE.setting:2214)␤»

[19:34] <benabik> .munch doesn't seem to work.

[19:35] <TimToady> rakudo: my $x = List.new("bacon", "bits"); say $x.munch(1); say $x;

[19:35] <p6eval> rakudo 72d158: OUTPUT«bacon␤bits␤»

[19:46] <[Coke]> I need a bot I can ask what .munch (e.g.) does.

[19:46] <colomon> rakduo: my @a = 1..10; say ~@a.munch(2); say ~@a

[19:47] <colomon> rakudo: my @a = 1..10; say ~@a.munch(2); say ~@a

[19:47] <p6eval> rakudo 72d158: OUTPUT«1 2␤3 4 5 6 7 8 9 10␤»

[19:49] <flussence> [Coke]: I imagine one of those will be pretty easy to make once tadzik++ has this Pod stuff working :)

[19:50] <tadzik> dreamworld: say Array.munch.WHY # :)

[19:50] <[Coke]> tadzik++

[19:55] <colomon> Sometime while I was out at YAPC::NA, my little boy learned to ask "Why?"

[19:56] <benabik> colomon: Do you just respond with NYI?

[19:56] <colomon> No, in the long tradition of semi-patient parents, I response with an explanation, which of course immediately gets me another "Why?"

[19:58] <moritz_> to which you answer "Mu"

[20:05] <pmichaud> back

[20:05] <colomon> rakudo: say True ?^ True

[20:05] <p6eval> rakudo 72d158: OUTPUT«Bool::False␤»

[20:05] <colomon> rakudo: say True ?^ True == False

[20:05] <p6eval> rakudo 72d158: OUTPUT«Bool::True␤»

[20:06] <pmichaud> back from lunch

[20:06] <colomon> ooo, fixed! \o/

[20:06] <dalek> roast: 649b3a7 | moritz++ | S (2 files):

[20:06] <dalek> roast: start to fudge int.t for rakudo; segfaults after 67 tests

[20:06] <dalek> roast: review: https://github.com/perl6/roast/commit/649b3a79a2

[20:08] <dalek> rakudo/nom: 3763c60 | pmichaud++ | src/core/Any.pm:

[20:08] <dalek> rakudo/nom: Add sub pick().

[20:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3763c604c6

[20:08] <jnthn> Can somebody pop that Bool multi-dispatch thing in nommap? I'm just too tired after the flight to dare touch any code tonight :)

[20:09] <moritz_> jnthn: will do

[20:09] <tadzik> oh, that's my call! My first Rakudo patch was optimizing Range.pick :)

[20:09] *** mattp_ joined
[20:10] <dalek> roast: faefe72 | moritz++ | S32-num/power.t:

[20:10] <dalek> roast: fudge power.t for rakudo

[20:10] <dalek> roast: review: https://github.com/perl6/roast/commit/faefe728b1

[20:11] <moritz_> nom: say List.Bool

[20:11] <p6eval> nom: OUTPUT«Cannot access attributes in a type object␤current instr.: 'gimme' pc 371914 (src/gen/CORE.setting.pir:104169) (src/gen/CORE.setting:2175)␤»

[20:11] <moritz_> ah, that's why ().list.Bool works - it's not a multi

[20:12] <pmichaud> right.

[20:13] <pmichaud> for now you could define Complex.Bool() as (non-multi)    { self.defined && ( $!re || $!im ) }

[20:14] <TimToady> except that doesn't return a Bool...

[20:15] <TimToady> but I'm sure moritz++ can locate a 'so' or so to throw in there

[20:16] <pmichaud> change to ?| then :-)

[20:16] <pmichaud> or a 'so'

[20:17] <pmichaud> found the double-bacon bug

[20:17] <tadzik> yes!

[20:17] <benabik> double-bacon is never a bug.

[20:18] <tadzik> benabik: it was my blocker for 2 gsoc days :)

[20:18] <colomon> benabik++

[20:18] <pmichaud> depends on the state of one's arteries.

[20:19] * TimToady waits for pmichaud to bring home the bacon

[20:19] <colomon> apparently tadzik's arteries have had issues

[20:20] <tadzik> well, I hope that bug is my bug. It may be only the beginning :)

[20:20] <tadzik> if it is, I may start passing 01-delimited.t in nom quite soon

[20:24] <masak> TimToady: to put food on his family? :)

[20:25] <pmichaud> surprisingly, bacon is one of those foods that gives me headaches when I eat it :)

[20:26] *** impious left
[20:27] <tadzik> :)

[20:29] *** Bzek left
[20:30] *** ab5tract joined
[20:31] <tadzik> seems that nom can run Acme::Meow :)

[20:33] *** wolfman2000 left
[20:36] <dalek> ecosystem: 1b30f90 | tadzik++ | / (4 files):

[20:36] <dalek> ecosystem: Remove ingy++'s modules from the SHELTER, they have their META.infos now

[20:36] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/1b30f90858

[20:37] <everbrew> $tadzik->pet();

[20:38] *** am0c left
[20:38] <tadzik> "purr"

[20:42] <flussence> .oO( $tadzik->pet(); $tadzik->pet(); # "purr bacon" )

[20:42] <benabik> flussence++

[20:44] <dalek> roast: 1b0fdc4 | pmichaud++ | S02-builtin_data_types/lists.t:

[20:44] <dalek> roast: regression test for nom's duplicate-reification bug ("bacon bacon").

[20:44] <dalek> roast: review: https://github.com/perl6/roast/commit/1b0fdc48fb

[20:45] <pmichaud> > my $x = List.new('bacon');  say $x;  say $x;

[20:45] <pmichaud> bacon

[20:45] <pmichaud> bacon

[20:46] <dalek> rakudo/nom: 9209833 | moritz++ | t/spectest.data:

[20:46] <dalek> rakudo/nom: four more passing test files

[20:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9209833f97

[20:46] <dalek> rakudo/nom: 537ad6b | moritz++ | NOMMAP.markdown:

[20:46] <dalek> rakudo/nom: note MMD failure in NOMMAP

[20:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/537ad6b496

[20:47] <jnthn> pmichaud++ # and looking forward to seeing the patch :)

[20:47] <pmichaud> it was a case of double-reification

[20:48] <pmichaud> pushed.

[20:48] <dalek> rakudo/nom: 45465fa | pmichaud++ | src/core/List (2 files):

[20:48] <dalek> rakudo/nom: Fix handling of $!nextiter in lists when a third-party triggers reification.

[20:48] <dalek> rakudo/nom: Fixes the  my $x = List.new('bacon'); say $x; say $x;   bug that would

[20:48] <dalek> rakudo/nom: duplicate the elements of the List.

[20:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45465fab19

[20:50] <tadzik> now let's see if it fixes my problems :)

[20:50] <moritz_> tadzik++ # finding bugs

[20:51] <tadzik> funny that I had to reach so deep into the guts to see that in action

[20:52] * masak .oO( reach deep into the guts to fix the "bacon problem"... )

[20:52] <tadzik> pmichaud++ # thank you

[20:52] <tadzik> masak: that may be even funnier without the quotation marks :)

[20:53] <masak> tadzik: :)

[20:53] <pmichaud> tadzik: you're welcome, and apologies that the bug cost you a lot of hours.  But I'm really glad you found it and were able to golf it down so well.  tadzik++

[20:53] <pmichaud> made my job a lot easier :)

[20:53] <masak> tadzik++, our new Tiger Woods! \o/

[20:54] <tadzik> now I have a tough time removing dozens of say()s all around nom :P

[20:54] <moritz_> that's why most editors have a "search" function

[20:54] <tadzik> vim++

[20:54] <moritz_> in vim you just hit * when you're on one say()

[20:54] <moritz_> then dd

[20:54] <moritz_> then n

[20:55] <moritz_> then dd

[20:55] <moritz_> etc. :-)

[20:55] <masak> that's why git has 'git checkout'.

[20:55] <tadzik> I commented the say()s, Justin Case :)

[20:55] <tadzik> but I strongly hope everything will be fine now

[20:55] <pmichaud> oh, NQP is about to have a new debugging facility built-in.

[20:55] <masak> I'm never that merciful to debug output.

[20:55] <tadzik> masak: I may need that again :(

[20:55] <pmichaud> nqp::event(code, str)    # sends a debug message if debugging enabled, no-op otherwise

[20:56] <masak> if I have to add it more than twice, it probably means I need a more permanent mechanism for debugging anyway.

[20:56] <tadzik> why 'event'?

[20:56] <pmichaud> it's for logging multiple types of events, not just debugging :)

[20:56] <tadzik> masak: you didn't have to cope with doubled bacon, so shh! :P

[20:56] <jnthn> pmichaud: That's what we can build profiler on too?

[20:56] <pmichaud> and "log"  might mean "logarithm"

[20:56] <masak> tadzik: :P

[20:56] <pmichaud> jnthn: yes, it's the same stuff as the call profiler

[20:56] <jnthn> pmichaud: nice

[20:57] <pmichaud> note that if str is more than a constant, though, you pay the cost of constructing the str :)

[20:57] <masak> tadzik: yeah, let's compare rakudobug war stories, see who wins... :P

[20:57] <tadzik> yyyes!

[20:57] <pmichaud> i.e.:   nqp::event(code, $foo ~ $bar ~ $baz);    # still does the concatenation :(

[20:58] <pmichaud> I might clean that up a bit at some point... but it's definitely intended to be low-level-ish and not macro-ish at the moment.

[20:58] <tadzik> masak: okay, okay ;)

[20:58] * masak thought so

[20:58] <masak> ;)

[20:59] <dalek> rakudo/nom: 5327931 | moritz++ | t/spectest.data:

[20:59] <dalek> rakudo/nom: another passing integration test

[20:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5327931c39

[20:59] *** tokuhirom joined
[20:59] * jnthn wonders how many tests we're up to now

[20:59] <moritz_> tadzik: you didn't have to deal with the "recursion and for-loops interact badly" bug that haunted masak++ to no end :-)

[20:59] <TimToady> nom: note 'note'

[20:59] <p6eval> nom: OUTPUT«note␤»

[20:59] <masak> moritz_: do you remember the RT ticket number by heart? :)

[20:59] <pmichaud> .oO(should've been 'do re mi')

[20:59] <moritz_> masak: no

[20:59] <masak> moritz_: I think it was 78392.

[20:59] <moritz_> jnthn: about 4.3k last I spectested... might be about 4.5k now

[21:00] <pmichaud> masak has finally expunged that number from his memory... like a bad dream.

[21:00] <tadzik> moritz_: sounds terrifying

[21:00] <jnthn> masak: You'll be happy to know that man-or-boy already passes in nom :)

[21:00] * moritz_ checks RT #78392

[21:00] <masak> apparently I remember it wrong.

[21:00] * tadzik prepares the showoff

[21:00] <masak> jnthn: yay!

[21:00] <tadzik> da-da-dam!

[21:01] <jnthn> moritz_: Wow. Awesome progress

[21:01] <tadzik> $POD showoff: https://gist.github.com/1064604

[21:02] <jnthn> tadzik++

[21:02] <moritz_> tadzik++ indeed

[21:02] <jnthn> tadzik: And just to check...does it work if you --target=pir the file?

[21:02] <tadzik> "from now on, everything should be easy"

[21:02] <moritz_> tadzik: I think it woudl make sense to make that s:g/Array/List/

[21:02] <jnthn> And run the output PIR?

[21:02] <tadzik>  -- famous last words

[21:02] <tadzik> let's see indeed

[21:02] <masak> moritz_: it was https://rt.perl.org/rt3/Ticket/Display.html?id=58392

[21:02] <moritz_> btw last I looked, nom didn't have @*ARGS

[21:02] <masak> that old!

[21:03] <tadzik> jnthn: parrot foo.pir gives me "Contextual $*ST not found"

[21:03] <pmichaud> nom doesn't have @*ARGS yet, no.

[21:03] <pmichaud> I need to refactor HLL::Compiler a bit for that.

[21:03] <moritz_> masak: but you remembered all but the first digit correctly

[21:03] <tadzik> moritz_: which one?

[21:03] <jnthn> tadzik: er, ouch.

[21:03] <moritz_> tadzik: IMHO Pod blocks should contain lists, not arrays

[21:03] <jnthn> tadzik: Leave that one with me.

[21:03] <moritz_> jnthn: seems to be a general nom problem

[21:03] <tadzik> jnthn: roger

[21:04] *** mj41 joined
[21:05] <jnthn> moritz_: grr. We need a regression test for pre-comp really...

[21:05] <masak> moritz_: yes :) it has a certain nice rythm to it, ever since you shouted it out your window :P

[21:05] *** wubo` joined
[21:05] *** wubo left
[21:05] <tadzik> nom: my $a = List.new([1, 2], [3, 4]); say $a.perl

[21:05] <p6eval> nom: OUTPUT«([1, 2], [3, 4]).list.item␤»

[21:05] <moritz_> jnthn: maybe I can get to that tomorrow

[21:06] * moritz_ notices that reading https://rt.perl.org/rt3/Ticket/Display.html?id=58392 doesn't properly reflect the pain associated with that issue, and with fixing it

[21:07] <tadzik> moritz_: someone should maybe write a tale to scare children

[21:08] <moritz_> tadzik: I'd be surprised if that tale wasn't in masak's old blog posts somewhere

[21:08] <masak> tadzik: you jest, sir. I should have you go back and read the logs from that time. the horrors! :P

[21:09] <moritz_> only do that after GSOC finishes :-)

[21:09] <masak> tadzik: imagine not being able to trust the veracity of the compiler you're running. and we were writing web software!

[21:11] *** kaare_ left
[21:11] * masak could easily imagine himself telling scary lexical bug stories to little children

[21:11] <[Coke]> moritz_++ # never knew about * in vi before.

[21:11] <pmichaud> "Listen my children for a tale that's true / about the pain of 5 8 3 9 2..."

[21:11] <masak> *lol*

[21:11] <masak> pmichaud++

[21:12] <moritz_> [Coke]: and # is the same but searching backwards

[21:12] <moritz_> pmichaud++ indeed

[21:13] <masak> pmichaud: reminds me of the limerick prime, 2077311001024001207

[21:13] <masak> (two last comments on http://www.johndcook.com/blog/2011/03/08/limerick-primes/ )

[21:14] <dalek> rakudo/podparser: b20c00f | pmichaud++ | src/core/Cool.pm:

[21:14] <dalek> rakudo/podparser: Add Cool.rand.

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/b20c00f317

[21:14] <dalek> rakudo/podparser: 9e91676 | pmichaud++ | src/core/ (3 files):

[21:14] <dalek> rakudo/podparser: Add List.pick, Any.pick, and Range.at_pos.

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/9e916766df

[21:14] <dalek> rakudo/podparser: 1f8fe70 | moritz++ | src/core/Pair.pm:

[21:14] <dalek> rakudo/podparser: Pair.ACCEPTS

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/1f8fe70bf3

[21:14] <dalek> rakudo/podparser: 8aa37ff | moritz++ | src/core/Numeric.pm:

[21:14] <dalek> rakudo/podparser: add Numeric.Bool -- but it does not seem to get called at all

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/8aa37ffbcc

[21:14] <dalek> rakudo/podparser: 3763c60 | pmichaud++ | src/core/Any.pm:

[21:14] <dalek> rakudo/podparser: Add sub pick().

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/3763c604c6

[21:14] <dalek> rakudo/podparser: 9209833 | moritz++ | t/spectest.data:

[21:14] <dalek> rakudo/podparser: four more passing test files

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/9209833f97

[21:14] <dalek> rakudo/podparser: 537ad6b | moritz++ | NOMMAP.markdown:

[21:14] <dalek> rakudo/podparser: note MMD failure in NOMMAP

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/537ad6b496

[21:14] <dalek> rakudo/podparser: 45465fa | pmichaud++ | src/core/List (2 files):

[21:14] <dalek> rakudo/podparser: Fix handling of $!nextiter in lists when a third-party triggers reification.

[21:14] <dalek> rakudo/podparser: Fixes the  my $x = List.new('bacon'); say $x; say $x;   bug that would

[21:14] <dalek> rakudo/podparser: duplicate the elements of the List.

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/45465fab19

[21:14] <dalek> rakudo/podparser: 2780997 | tadzik++ | / (10 files):

[21:14] <dalek> rakudo/podparser: Merge branch 'nom' into podparser

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/278099715b

[21:14] <dalek> rakudo/podparser: 728d0f8 | tadzik++ | src/Perl6/ (3 files):

[21:14] <dalek> rakudo/podparser: Construct Pod blocks from delimited blocks, use Lists instead of Arrays per moritz++'s suggestion

[21:14] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/728d0f8124

[21:14] *** am0c^ joined
[21:14] <BinGOs> dalek attack!

[21:15] <masak> "Merge branch 'nom' into podparser"? podparser runs on nom now?

[21:15] <pmichaud> other way 'round

[21:15] <pmichaud> podparser merged in the latest nom commits

[21:15] <masak> right, I meant that.

[21:15] <tadzik> masak: yeah, that's kinda the point :)

[21:15] <masak> wow, I'm really not keeping up :)

[21:15] <masak> "carry on, lads."

[21:16] <masak> :P

[21:16] <tadzik> masak: I actually tried to serialize pod nodes in master, that was... inspiring

[21:16] <masak> oh?

[21:16] <tadzik> it was basically the same stuff: constructing the PAST nodes which would be constructing the pod nodes

[21:16] <pmichaud> where "inspiring" should mean "motivating to switch to 'nom' instead"  :-P

[21:16] <tadzik> truly :)

[21:17] <jnthn> Well, master kinda lacks an easy way to share stuff build at compile time with runtime

[21:17] <jnthn> Your only choice is to always build the stuff at runtime in master

[21:17] <moritz_> in master you'd have to build the whole PAST thing yourself, and not have it available at compile time

[21:18] <tadzik> well, if you look closely enough, nom builds stuff in runtime too

[21:18] <moritz_> right

[21:18] <pmichaud> NO PEEKING!

[21:18] <moritz_> but it's hidden behind a nice-ish API

[21:18] <jnthn> It does fixups

[21:18] <jnthn> Note the PAST that you make for deserialization does not apply unless you're doing pre-compilation.

[21:18] <moritz_> which means that once we have "real" serialization, it can stop do that stuff at run time

[21:18] <pmichaud> fixups will always be needed.  That's the price of dynamic linking.

[21:18] <jnthn> Right.

[21:19] <jnthn> But if you compile and run code straight away, the Perl 6 Array you built up at compile time really will be the same one that is used at runtime.

[21:19] *** Mowah left
[21:19] <masak> \o/

[21:19] <jnthn> All that'll happen when we get real serialization is all that deserialization PAST we build will go away.

[21:20] *** Mowah joined
[21:20] <jnthn> In favor of a chunk of a serializer.

[21:20] <jnthn> Which somebody needs to design and implement after nom is landed and in shape :)

[21:20] * [Coke] ponders rewriting partcl on perl6/nom instead of nqp.

[21:20] <pmichaud> [Coke]: not a bad idea, that.

[21:21] <pmichaud> it will help when nom has grammars and regexes, though :)

[21:21] <pmichaud> (expected sometime in the next few days)

[21:21] <jnthn> fwiw, the serialization stuff will live in NQP

[21:21] <jnthn> It'll be fairly intimately related to 6model

[21:21] <masak> what did circumfix:«< >» mean before it meant "quote words"?

[21:21] <jnthn> Or may just go in the core

[21:22] <moritz_> masak: not-so-smart quote words

[21:22] * jnthn is gradually working out what he wants there :)

[21:22] * moritz_ thinks that serializing a Complex shouldn't be all that complex :-)

[21:22] <jnthn> OK, conciousness is getting too hard, and it's a sensible sleep time.

[21:22] <masak> jnthn: sleep well.

[21:22] <masak> jnthn: see you tomorrow, ready for hacking!

[21:22] <jnthn> masak: I should, after however many hours awake ;)

[21:23] <jnthn> I, er, wait, what? :)

[21:23] <masak> :D

[21:23] * masak waves the magic sleeping wand over jnthn 

[21:25] <tadzik> nqp: say(subst("foo", /o/, 'b'))

[21:25] <p6eval> nqp: OUTPUT«fbo␤»

[21:25] *** jevin left
[21:25] * moritz_ feels the results many hundreds of kilometers away, and also fades to sleep

[21:26] <tadzik> moritz_: sleep tight

[21:27] <dalek> roast: 9251fc3 | pmichaud++ | S02-builtin_data_types/range.t:

[21:27] <dalek> roast: Fudge out Range.from and Range.to tests... do we still need .from/.to ?

[21:27] <dalek> roast: review: https://github.com/perl6/roast/commit/9251fc311d

[21:30] <pmichaud> We're now at 4,506 spectests.

[21:30] <tadzik> woosh!

[21:30] <dalek> rakudo/nom: bd3df2f | pmichaud++ | src/core/ (2 files):

[21:30] <dalek> rakudo/nom: Add List.roll, Any.roll, &roll and &join.

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd3df2f88d

[21:30] <dalek> rakudo/nom: a4a40c0 | pmichaud++ | src/ (2 files):

[21:30] <dalek> rakudo/nom: Make Range smart enough to return Int instead of Num, add temporary opcode

[21:30] <dalek> rakudo/nom: for making really large integers into Nums.

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a4a40c01c4

[21:30] <dalek> rakudo/nom: 91f014c | pmichaud++ | t/spectest.data:

[21:30] <dalek> rakudo/nom: Add S02-builtin_data_types/range.t .

[21:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/91f014c7a7

[21:30] <masak> I... I'm feeling the effects of the sleeping wand too. I think I should heed it.

[21:31] <masak> no edublog post tonight, I'm afraid. still need to hack a bit more on "crypt", the text adventure game.

[21:32] <masak> 'night, #perl6

[21:32] <tadzik> oh, I must now think of some clever way to test these pod things

[21:32] <tadzik> 'night masak 

[21:32] *** masak left
[21:34] *** wubo` left
[21:43] *** amkrankruleuen left
[21:44] *** Patterner left
[21:45] *** amkrankruleuen joined
[21:48] *** Psyche^ joined
[21:48] *** Psyche^ is now known as Patterner

[21:49] *** mj41 left
[21:51] <tadzik> nqp: my @a; my @b; @b.push(5); @b.push(7); @a.push(@b); say(@a[0]);

[21:51] <p6eval> nqp: OUTPUT«2␤»

[21:51] <tadzik> is there any way to make it flatten, in nqp?

[21:51] <tadzik> oh, |@b. Nevermind :)

[21:51] <tadzik> nqp: my @a; my @b; @b.push(5); @b.push(7); @a.push(|@b); say(@a[0]);

[21:51] <pmichaud> actually, I bet that doesn't work.

[21:51] <p6eval> nqp: OUTPUT«too many positional arguments: 3 passed, 2 expected␤current instr.: '_block1000' pc 115 ((file unknown):65) (/tmp/z_jy44a0gG:1)␤»

[21:51] <tadzik> oh, no

[21:51] <pmichaud> the .push method comes from Parrot's ResizablePMCArray

[21:51] <pmichaud> and it only knows how to push one thing.

[21:52] <pmichaud> but you can splice

[21:52] <tadzik> can I flatten an array in nqp?

[21:52] <pmichaud> nqp::splice(@a, @b, nqp::elems(@a), 0)

[21:52] <pmichaud> adds the contents of @b to the end of @a

[21:52] <tadzik> at the moment of pushing I don't know whether I push an array or something else

[21:52] <pmichaud> nqp doesn't know anything about "flattening"

[21:52] <tadzik> damn

[21:54] *** neaer left
[21:55] <pmichaud> if you want to flatten something (and |@flat won't do it), then you have to flatten it yourself.

[21:55] *** wamba left
[21:57] <tadzik> I made a dirty if "pir::isa($_.ast, 'ResizablePMCArray')" trick

[21:57] <pmichaud> that works.

[21:57] <pmichaud> well, it maybe works.

[21:57] <pmichaud> normall $_.ast is a PAST node.

[21:57] <pmichaud> *normally

[21:58] <pmichaud> (depending on what you're storing there)

[21:58] <tadzik> in this case it's either a PAST node, or an array of those

[21:59] <mikemol> Someone a little more authorative than myself might want to step in here: http://rosettacode.org/wiki/Talk:Unicode_variable_names

[21:59] *** am0c^ left
[22:01] *** Mowah left
[22:02] <dalek> rakudo/nom: 8d597c2 | pmichaud++ | / (3 files):

[22:02] <dalek> rakudo/nom: Add infix:<=:=>, a major cheat for Parcel.Capture(), and three more spectest files.

[22:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8d597c2861

[22:03] <tadzik> nom: class A {}; class B is A {}; use Test; my $a = B.new; isa_ok $a, A, 'foo';

[22:03] <p6eval> nom: OUTPUT«not ok 1 - foo␤Use of uninitialized value in string context␤# Actual type: ␤»

[22:04] <tadzik> am I missing something?

[22:05] *** huf_ is now known as huf

[22:06] <pmichaud> mikemol: I added a note.

[22:07] <mikemol> ty

[22:09] <tadzik> pmichaud: could you look at my doubt above?

[22:09] <pmichaud> tadzik: I don't see what you're missing, no.

[22:10] <tadzik> ok, thanks

[22:10] <pmichaud> nom:  my class A {};  my class B is A {};  use Test;  my $a = B.new;  say $a.WHAT;  isa_ok $a, A, 'foo';

[22:10] <p6eval> nom: OUTPUT«B()␤not ok 1 - foo␤Use of uninitialized value in string context␤# Actual type: ␤»

[22:10] <pmichaud> nom:  my class A {};  my class B is A {};  use Test;  my $a = B.new;  say $a.WHAT;  isa_ok $a, B, 'foo';

[22:10] <p6eval> nom: OUTPUT«B()␤ok 1 - foo␤»

[22:10] <pmichaud> nom:  my class A {};  my class B is A {};  use Test;  my $a = B.new;  say $a.WHAT;  isa_ok B, A, 'foo';

[22:10] <p6eval> nom: OUTPUT«B()␤not ok 1 - foo␤Use of uninitialized value in string context␤# Actual type: ␤»

[22:10] <pmichaud> nom:  my class A {};  my class B is A {};  use Test;  my $a = B.new;  say A;  isa_ok B, A, 'foo';

[22:10] <p6eval> nom: OUTPUT«A()␤not ok 1 - foo␤Use of uninitialized value in string context␤# Actual type: ␤»

[22:10] <pmichaud> nom:  my class A {};  my class B is A {};  use Test;  my $a = B.new;  say A;  isa_ok A, A, 'foo';

[22:10] <p6eval> nom: OUTPUT«A()␤ok 1 - foo␤»

[22:11] <pmichaud> maybe a bug with isa_ok

[22:11] <tadzik> seems so, yes

[22:11] <pmichaud> perhaps a decontainerization problem

[22:11] <tadzik> nom: class A {}; class B is A {}; my $a = B.new; say $a.isa(B)

[22:11] <p6eval> nom: OUTPUT«Bool::True␤»

[22:11] <tadzik> hrm

[22:12] <pmichaud> nom: class A {};  class B is A {};  my $a = B.new;  say $a.isa(A);

[22:12] <p6eval> nom: OUTPUT«Bool::False␤»

[22:16] <pmichaud> nom:  class A {};  class B is A {};  say nqp::p6bool(B.HOW.isa(B, A));

[22:16] <p6eval> nom: OUTPUT«Bool::False␤»

[22:16] <pmichaud> ...that looks like the fundamental problem.

[22:16] <tadzik> it's the second one today :)

[22:16] <pmichaud> nom:  class A {};  class B is A {};  nqp::say(B.HOW.isa(B, A));

[22:16] <p6eval> nom: OUTPUT«0␤»

[22:21] *** dorlamm joined
[22:23] <dalek> rakudo/podparser: 46bcffa | tadzik++ | src/Perl6/Actions.pm:

[22:23] <dalek> rakudo/podparser: Handle paragraphs properly

[22:23] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/46bcffa1e2

[22:23] <dalek> rakudo/podparser: 959cd2b | tadzik++ | t/pod/01-delimited.t:

[22:23] <dalek> rakudo/podparser: Add first Pod tests, not all of them yet, just those working

[22:23] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/959cd2b16f

[22:23] <tadzik> another small milestone: pod tests :)

[22:25] *** everbrew left
[22:27] *** thou joined
[22:28] <colomon> tadzik++

[22:31] <tadzik> and I discovered how to lean back in my chair \o/ Great day, after all the tough moments :)

[22:34] *** ZaphrodZenovka left
[22:36] *** drbean joined
[22:38] <lichtkind> thou: around?

[22:39] *** ZaphrodZenovka joined
[22:41] <thou> hi, lichtkind

[22:43] <tadzik> could someone build the podparser branch and see if anything breaks horribly?

[22:46] <tadzik> loliblug: http://ttjjss.wordpress.com/2011/07/07/gsoc-first-easily-visible-results/

[22:49] <lichtkind> thou: or i come better tomorrow :) ?

[22:51] *** ssotka joined
[23:01] *** alester left
[23:02] *** dorlamm left
[23:19] <dalek> rakudo/podparser: c26b9d5 | tadzik++ | src/Perl6/ (2 files):

[23:19] <dalek> rakudo/podparser: Get back to using Arrays instead of Lists. Lists generate some weird Null PMC Access errors

[23:19] <dalek> rakudo/podparser: review: https://github.com/rakudo/rakudo/commit/c26b9d5775

[23:28] *** orafu left
[23:29] *** orafu joined
[23:37] <lue> LHF.markdown talks about an .ords method, but I don't seem to find it in the specs.

[23:38] <flussence> S29:312

[23:39] *** soh_cah_toa joined
[23:40] <lue> thanks.

[23:55] *** molaf__ joined
[23:55] *** Limbic_Region joined
[23:56] *** ab5tract left
[23:58] *** molaf_ left
