[00:08] <sorear> what?

[00:09] <sorear> Util: curses.  I thought that was an impossible error.

[00:09] <dalek> panda: 214b05b | dukeleto++ | README.md:

[00:09] <dalek> panda: Add a panda icon to our readme

[00:09] <dalek> panda: review: https://github.com/tadzik/panda/commit/214b05b360

[00:10] <Util> sorear: I guess I just bring out the worst in compilers.

[00:11] *** bluescreen10 left
[00:13] *** bbkr1 joined
[00:13] *** Holy_Cow joined
[00:13] *** bbkr1 left
[00:14] *** lichtkind_ joined
[00:15] *** lichtkind left
[00:15] *** lichtkind_ is now known as lichtkind

[00:21] *** lichtkind left
[00:23] *** woosley joined
[00:27] *** lichtkind joined
[00:28] *** woosley left
[00:31] *** [particle] left
[00:42] *** [particle] joined
[00:43] *** Holy_Cow left
[00:43] *** Holy_Cow joined
[00:49] *** fhelmberger left
[01:00] *** whiteknight left
[01:00] *** noganex_ joined
[01:04] *** noganex left
[01:10] *** tokuhirom left
[01:11] *** lichtkind left
[01:40] *** [particle]1 joined
[01:42] *** [particle] left
[01:47] *** Holy_Cow left
[01:59] *** beek_ is now known as beekor

[02:14] *** cooper left
[02:16] *** cooper joined
[02:49] <Util> perl6: my @a = ^2; say @a  X @a;

[02:49] <p6eval> rakudo b4486e, niecza v7-30-gaf607ad: OUTPUT«00011011␤»

[02:49] <p6eval> ..pugs: OUTPUT«01␤»

[02:49] <Util> perl6:             say ^2  X ^2;

[02:49] <p6eval> rakudo b4486e: OUTPUT«00011011␤»

[02:49] <p6eval> ..pugs: OUTPUT«01␤»

[02:49] <p6eval> ..niecza v7-30-gaf607ad: OUTPUT«WRONG ExitRunloop TAKEN:␤  at  line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1165 (CORE infix:<X> @ 2) ␤  at /tmp/WXzgkgBY6u line 1 (MAIN mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1890 (CORE C885_ANON @ 2) ␤  a…

[02:49] <Util> Odd that Niecza would fail there.

[03:09] *** f00li5h left
[03:15] *** cooper left
[03:23] *** Su-Shee_ joined
[03:26] *** xinming left
[03:26] *** am0c left
[03:27] *** Su-Shee left
[03:31] *** jaldhar joined
[03:39] *** Holy_Cow joined
[03:43] *** am0c joined
[03:44] *** Holy_Cow left
[03:48] *** molaf joined
[03:50] <sorear> yes, odd.

[04:01] *** woosley joined
[04:08] *** satyavvd joined
[04:15] *** karb joined
[04:15] *** shinobicl joined
[04:19] *** karb left
[04:21] <sorear> ...weird.  1 X gather... is fine, but 1 X ^2 fails

[04:23] *** cooper joined
[04:25] *** [particle]1 left
[04:26] *** drbean left
[04:31] *** satyavvd left
[04:31] *** molaf left
[04:34] *** kaare__ joined
[04:35] *** f00li5h joined
[04:37] <dalek> nqp: abdf378 | pmichaud++ | src/ (2 files):

[04:37] <dalek> nqp: Refactor building of match object.

[04:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/abdf37836a

[04:37] <dalek> nqp: 985fd7d | pmichaud++ | src/QRegex/Cursor.nqp:

[04:37] <dalek> nqp: Cache a match object once we've built it.

[04:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/985fd7db7d

[04:39] *** thou joined
[04:44] *** shinobicl left
[04:45] <dalek> rakudo/nom: 5aecd55 | pmichaud++ | / (10 files):

[04:45] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[04:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5aecd55de2

[04:45] <dalek> rakudo/nom: d5a8c7e | pmichaud++ | / (4 files):

[04:45] <dalek> rakudo/nom: Update Match, Cursor, and Capture objects.  Indexed access to

[04:45] <dalek> rakudo/nom: match objects now works.

[04:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d5a8c7e2a7

[04:47] <sorear> pmichaud: every time I see "Merge branch 'nom' of ... into ..." I get falsely excited :/

[04:48] *** drbean joined
[04:52] *** sivoais joined
[05:02] *** satyavvd joined
[05:03] *** mberends left
[05:11] *** donri joined
[05:13] *** Enzo_ joined
[05:17] *** birdwindupbird joined
[05:22] *** Enzo_ left
[05:46] *** wtw joined
[06:01] *** [particle] joined
[06:03] <dalek> niecza: 212ba5b | sorear++ | / (2 files):

[06:03] <dalek> niecza: Fix ^2 X ^2 (Util)

[06:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/212ba5ba67

[06:04] *** jaldhar left
[06:04] *** jaldhar joined
[06:05] *** beekor left
[06:06] *** aindilis left
[06:06] *** jaldhar left
[06:06] *** beekor joined
[06:07] *** jaldhar joined
[06:11] *** odoacre joined
[06:11] <moritz> sorear: the siwtchover from nom to master probably won't be a merge commit

[06:23] *** soh_cah_toa left
[06:30] *** daniel-s joined
[06:30] *** Su-Shee_ is now known as Su-Shee

[06:31] *** thou left
[06:32] *** cooper left
[06:35] *** noganex_ is now known as noganex

[06:42] <TimToady> http://rosettacode.org/wiki/Undefined_values#Perl_6

[06:46] <pmichaud> blog post!  http://pmthium.com/2011/07/14/new-regex-engine-for-nqp-and-nom-now-passing-7k-spectests/

[06:47] <pmichaud> sleep time!  bbiaw

[06:48] <TimToady> o/

[06:51] * TimToady always wonders what G Cables are, though... :)

[06:55] *** wamba joined
[07:04] *** mberends joined
[07:10] *** mj41 joined
[07:10] *** Jackneill joined
[07:10] *** Jackneill left
[07:10] *** Jackneill joined
[07:23] *** fhelmberger joined
[07:24] *** fhelmberger left
[07:25] *** fhelmberger joined
[07:27] *** Trashlord left
[07:37] *** im2ee joined
[07:40] *** Mowah joined
[07:52] *** cipherte1t left
[07:53] *** Trashlord joined
[07:56] *** wamba left
[07:57] *** ciphertext joined
[08:00] <dalek> niecza: 355a78a | sorear++ | lib/ (2 files):

[08:00] <dalek> niecza: Simplify RUN_ONCE handling a bit, fixes $_ assignment at top level

[08:00] <dalek> niecza: review: https://github.com/sorear/niecza/commit/355a78a174

[08:00] * sorear otu

[08:27] <tadzik> good morning

[08:27] <tadzik> is nom now on qregex, completely?

[08:29] <TimToady> no, only the regexes in nom, not the grammars, according to the blog

[08:32] <moritz> nom: say 'abc' ~~ /abc/

[08:32] <p6eval> nom: OUTPUT«abc␤»

[08:32] <tadzik> cool

[08:32] <moritz> nom: say 'abc' ~~ /(a)b(c)/

[08:32] <p6eval> nom: OUTPUT«abc␤»

[08:32] <moritz> nom: say ('abc' ~~ /(a)b(c)/)[0]

[08:32] <p6eval> nom: OUTPUT«a␤»

[08:32] <moritz> nom: say ('abc' ~~ /(a)b(c)/)[0].WHAT; say $1

[08:32] <p6eval> nom: OUTPUT«Match()␤Could not find sub !postcircumfix:<[ ]>␤current instr.: '_block1002' pc 158 ((file unknown):157) (/tmp/8M0fEPtcDS:1)␤»

[08:32] <moritz> nom: say ('abc' ~~ /(a)b(c)/)[0].WHAT

[08:32] <p6eval> nom: OUTPUT«Match()␤»

[08:33] <tadzik> nom: say ('abc' ~~ /(a)b(c)/).list[0].WHAT; say $1

[08:33] <p6eval> nom: OUTPUT«Match()␤Could not find sub !postcircumfix:<[ ]>␤current instr.: '_block1002' pc 170 ((file unknown):29621359) (/tmp/ifpD8IAbEv:1)␤»

[08:33] <moritz> it's the $1 the causes problems

[08:33] <moritz> not the .WHAT

[08:33] <jlaire> nom: 'a' ~~ /(a)/; say $/

[08:33] <p6eval> nom: OUTPUT«a␤»

[08:34] <jlaire> nom: 'abc' ~~ /(a)b(c)/; say $/.perl

[08:34] <p6eval> nom: OUTPUT«abc␤»

[08:34] *** betterworld left
[08:35] <jlaire> nom: 'abc' ~~ /(a)b(c)/; say $/.WHAT

[08:35] <p6eval> nom: OUTPUT«Match()␤»

[08:37] <moritz> I might be able to fix $1 etc.

[08:38] <moritz> nom: say 'abc' ~~ /<alpha>/; say $<alpha>

[08:38] <p6eval> nom: OUTPUT«a␤a␤»

[08:39] <moritz> nom: say 'abc' ~~ /<alpha>../; say $<alpha>

[08:39] <p6eval> nom: OUTPUT«abc␤a␤»

[08:42] *** dakkar joined
[08:43] *** betterworld joined
[08:52] <TimToady> http://rosettacode.org/wiki/Pythagorean_triples#Perl_6 <-- added fast algorithm with several nifty p6 idioms

[08:53] <moritz> rakudo: say +{a => 1, b => 2}

[08:53] <p6eval> rakudo b4486e: OUTPUT«2␤»

[08:53] <moritz> no need for the .keys in +%trips.keys

[08:54] <moritz> that's p5 think :-)

[08:55] *** am0c left
[08:56] <TimToady> eep, 2am, almost

[08:56] <TimToady> RC is addictive...

[08:56] <moritz> oh, that's the old solution

[08:56] <TimToady> don't remember who added the slow one...

[08:56] <moritz> I'll change it

[08:57] <TimToady> thanks

[08:57] <dalek> rakudo/nom: 88f4119 | moritz++ | src/Perl6/Actions.pm:

[08:57] <dalek> rakudo/nom: fix $0, $1 etc.

[08:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/88f4119371

[08:59] <TimToady> .zZ(...)

[09:00] *** birdwindupbird left
[09:00] <jnthn> morning o/

[09:00] <moritz> \o

[09:02] <felher> TimToady++ for Rosetta-Codes

[09:02] <felher> pmichaud++ for blogpost (and hacking of course)

[09:04] <moritz> indeed, pmichaud++ TimToady++ jnthn++

[09:05] * jnthn reads the pmichaud++ blog post while having is mornin' coffee

[09:05] <jnthn> Gotta do a little $dayjob and pack for vacation, but hope to sneak another hour or so in on enums too :)

[09:06] <tadzik> why doesn't that work on Rakudo?

[09:07] <tadzik> it works

[09:07] *** drbean left
[09:07] <moritz> then comment on it :-)

[09:07] *** Chillance joined
[09:07] *** am0c joined
[09:08] <tadzik> I'm trying to understand this RC markup

[09:09] *** birdwindupbird joined
[09:10] <moritz> good news, enabling regexes in nom wins us back quite a few test files

[09:10] <moritz> a few directly related to regexes

[09:10] <moritz> and others that use regexes to verify some data

[09:10] <jnthn> nice

[09:10] *** birdwindupbird left
[09:11] <moritz> currently +6 test files, and counting

[09:12] *** Jackneill left
[09:14] <moritz> most of them aren't huge, but it still looks like a win

[09:14] *** birdwindupbird joined
[09:15] <jnthn> Guess the regex engine needs more features before we can get S05-regex/maß.t back

[09:16] <moritz> mass with sharp s? :-)

[09:16] * jnthn is just thinking of beer as usual :)

[09:17] <moritz> :: not yet implemented at line 37, near " not | ify"

[09:17] <moritz> is the error it produces right now

[09:18] <moritz> wait, that wasn't implement in master eitehr

[09:18] * moritz should run the fudged version

[09:18] <jnthn> :)

[09:18] * jnthn hopes that one gets a bit further

[09:18] <moritz> aliasing to key

[09:18] <moritz> Null PMC access in invoke()

[09:18] <moritz> current instr.: 'nqp;Perl6;RegexActions;codeblock' pc 82792 (src/gen/perl6-actions.pir:0) (src/Perl6/Actions.pm:3597)

[09:18] <moritz> called from Sub 'nqp;Regex;Cursor;!reduce' pc 2703 (src/Regex/Cursor.pir:1023)

[09:18] <moritz> called from Sub 'nqp;Regex;Cursor;!cursor_pass' pc 2116 (src/Regex/Cursor.pir:660)

[09:19] <moritz> the "aliasing to key" looks like debugging output left over

[09:19] <jnthn> yeah, compile time

[09:25] *** im2ee left
[09:26] *** im2ee joined
[09:27] <dalek> rakudo/nom: 45c0697 | moritz++ | t/spectest.data:

[09:27] <dalek> rakudo/nom: 6 more passing test files

[09:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/45c0697a9d

[09:35] *** wamba joined
[09:41] *** wamba left
[09:59] <tadzik> rakudo: say (1000/1).WHAT

[09:59] <p6eval> rakudo b4486e: OUTPUT«Rat()␤»

[09:59] <tadzik> rakudo say (1000/1) div 5

[09:59] <tadzik> rakudo: say (1000/1) div 5

[09:59] <p6eval> rakudo b4486e: OUTPUT«No applicable candidates found to dispatch to for 'infix:<div>'. Available candidates are:␤:(Int $a, Int $b)␤␤  in main program body at line 22:/tmp/V2HsXfFJXD␤»

[10:00] <tadzik> nom: (10, 100, 1000 ... *)[3].WHAT.say

[10:00] <p6eval> nom: OUTPUT«Rat()␤»

[10:00] <tadzik> a-ha

[10:00] <moritz> yep, known bug

[10:00] <tadzik> okay

[10:01] <moritz> fixing it should be quite possible - it's all Perl 6 code

[10:01] <moritz> (note that master special-cases that; I fear you need to do that)

[10:02] <tadzik> oh, looks like I volunteered to fix it :)

[10:02] <jnthn> tadzik++ ;)

[10:02] <tadzik> damn :)

[10:03] <tadzik> I mean, yay!

[10:03] <tadzik> where is it implemented?

[10:03] <moritz> operators.pm sub SERIES iirc

[10:08] *** Kivutarrr joined
[10:09] *** woosley left
[10:10] *** MayDaniel joined
[10:14] *** mberends left
[10:14] *** Jackneill joined
[10:16] *** mberends joined
[10:20] <moritz> rakudo: my $a = 5; say "yes" if 3 <= $a <= 10;

[10:20] <p6eval> rakudo b4486e: OUTPUT«yes␤»

[10:21] <moritz> perl6: my $a = 5; say "yes" if 3 <= $a <= 10;

[10:21] <p6eval> pugs, rakudo b4486e, niecza v7-32-g355a78a: OUTPUT«yes␤»

[10:21] <moritz> seems like all major compilers get chained operators right

[10:23] <jlaire> nom: my $a = 5; say "yes" if 3 <= $a <= 10;

[10:23] <p6eval> nom: OUTPUT«yes␤»

[10:24] *** JimmyZ joined
[10:24] *** drbean joined
[10:25] *** am0c left
[10:27] <JimmyZ> rakudo: class pmichaud { }; say \pmichaud; my $a = \pmichaud++; say $a;

[10:27] <p6eval> rakudo b4486e: OUTPUT«Capture()<0x67b3980>␤Capture()<0x66daa10>␤»

[10:29] <JimmyZ> rakudo: class Foo { }; say \Foo ; say \Foo; 

[10:29] <p6eval> rakudo b4486e: OUTPUT«Capture()<0x58f2ea0>␤Capture()<0x5bdf980>␤»

[10:29] *** wamba joined
[10:29] <jnthn> \ forms capture :)

[10:30] *** odoacre left
[10:30] <moritz> JimmyZ has captured pmichaud and pmichaud++ :-)

[10:31] * moritz has the feeling that at least half of the tests involving  + variable or literal are bogus

[10:32] <JimmyZ> rakudo: sub postfix:<++>($a) { }; sub pmichaud { };  pmichaud++; # ++ with no errors :)

[10:32] <p6eval> rakudo b4486e:  ( no output )

[10:36] <JimmyZ> rakudo: sub postfix:<++>($a) { }; class pmichaud { }; class jnthn { }; loop { pmichaud++;  jnthn++ } # another one

[10:37] <p6eval> rakudo b4486e: OUTPUT«(timeout)»

[10:37] <JimmyZ> so, can class++ ?

[10:37] *** am0c joined
[10:37] *** MayDaniel left
[10:38] <moritz> if you define a postifix:<++> that can, why not?

[10:39] <JimmyZ> well, I thought postfix only is used by $var or sub is rw

[10:39] <jnthn> It's just an operator.

[10:39] <jnthn> It does whatever you tell it to :)

[10:40] <jnthn> The thing that demands something rw is inside of the default postfix:<++> implementations.

[10:40] <JimmyZ> rakudo: grammer foo {}; foo++;

[10:40] <p6eval> rakudo b4486e: OUTPUT«Could not find sub &foo␤  in main program body at line 22:/tmp/7QoZnZ8qAc␤»

[10:40] <JimmyZ> grammer can't  ++

[10:40] <jlaire> s/grammer/grammar/ # :)

[10:41] <jnthn> JimmyZ: No, you spelt grammar wrong :)

[10:41] <jnthn> Common mistake. :)

[10:41] <JimmyZ> oh

[10:41] <jnthn> (english spelling)-- :)

[10:42] <jnthn> nom: grammar foo {}; foo++;

[10:42] <p6eval> nom: OUTPUT«Cannot assign to a non-container␤current instr.: 'postfix:<++>' pc 417673 (src/gen/CORE.setting.pir:100247) (src/gen/CORE.setting:671)␤»

[10:46] *** kaare__ left
[10:46] *** JimmyZ left
[10:47] *** im2ee left
[10:48] *** im2ee joined
[11:01] *** Jackneill left
[11:01] <dalek> rakudo/nom: 064bcc4 | jonathan++ | src/Perl6/ (2 files):

[11:01] <dalek> rakudo/nom: Flesh out actions a bit for enumerations. Very much a first cut - only handles a few simple cases.

[11:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/064bcc415b

[11:01] <dalek> rakudo/nom: fed99c4 | jonathan++ | src/Perl6/Metamodel/BaseType.pm:

[11:01] <dalek> rakudo/nom: Need .^parents in BaseType role.

[11:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fed99c40ba

[11:01] <dalek> rakudo/nom: 74c67f8 | jonathan++ | src/core/Enumeration.pm:

[11:01] <dalek> rakudo/nom: Sketch out a few bits in the Enumeration role.

[11:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/74c67f86fc

[11:01] <dalek> rakudo/nom: 9c760e1 | jonathan++ | src/Perl6/Metamodel/EnumHOW.pm:

[11:01] <dalek> rakudo/nom: Create enumeration values at enum compose times, and include the key.

[11:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9c760e1c3f

[11:04] *** daxim joined
[11:05] *** Holy_Cow joined
[11:06] <mberends> tadzik: when earlier I could not reproduce your Zavolaj test failures, I must have been running and older Rakudo or Parrot, because I now do get the same failures. No idea what to do about them, and I don't want to ask other devs to steal tuits from nom.

[11:08] <mberends> I guess I'll turn the tests into todo's, that way the failures will be expected

[11:15] <tadzik> okay, I fixed that :)

[11:17] <dalek> rakudo/nom: ef31cef | tadzik++ | src/core/operators.pm:

[11:17] <dalek> rakudo/nom: Make n/1 Rats be Ints in sequence generation

[11:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef31ceff9b

[11:17] <tadzik> nom: my $a = 5; my $b = 5/1; say $a.?denominator; say $b.?denominator

[11:17] <p6eval> nom: OUTPUT«Nil␤1␤»

[11:17] <tadzik> hmm

[11:17] <tadzik> should I go for that approach in the patch?

[11:18] <tadzik> maybe not, someone can create a class that is not a Rat but has a .denominator

[11:18] *** wamba left
[11:19] *** wamba joined
[11:21] <jnthn> mberends: Zavolaj will also need a good looking at for nom.

[11:21] <jnthn> mberends: I suspect it may make some master-y assumptions. It is quite a gutsy module.

[11:22] *** im2ee left
[11:27] *** im2ee joined
[11:28] *** slavik1 left
[11:31] <moritz> nqp: say(nqp::substr("abc", -1))

[11:31] <p6eval> nqp: OUTPUT«c␤»

[11:36] <moritz> nqp: say(nqp::substr("abc", 0, -1))

[11:36] <p6eval> nqp: OUTPUT«␤»

[11:36] <moritz> nqp: say(pir::chop__Ssi("abc", 1))

[11:36] <p6eval> nqp: OUTPUT«error:imcc:syntax error, unexpected SREG, expecting '(' ('$S100')␤  in file '(file unknown)' line 33␤error:imcc:syntax error ... somewhere␤ in file '(file unknown)' line 103␤syntax error ... somewhere␤»

[11:36] <moritz> nqp: say(pir::chopn__Ssi("abc", 1))

[11:36] <p6eval> nqp: OUTPUT«ab␤»

[11:41] *** Holy_Cow left
[11:50] *** tokuhir__ joined
[11:51] *** satyavvd left
[12:08] *** Gambit joined
[12:10] *** Gambit left
[12:14] *** pnu left
[12:15] *** JimmyZ_ joined
[12:16] *** pnu joined
[12:16] <JimmyZ_> good evening, #perl6

[12:16] <takadonet> JimmyZ_:  yo

[12:16] <JimmyZ_> takadonet: aloha

[12:18] *** im2ee left
[12:19] *** bluescreen10 joined
[12:19] <[Coke]> Wanshang hao, JimmyZ_.

[12:20] <JimmyZ_> Coke 好

[12:21] *** Jackneill joined
[12:21] <[Coke]> xiexiene

[12:26] <moritz> perl6: say :16<DEAD_BEEF>;

[12:26] <p6eval> niecza v7-32-g355a78a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method alnumint not yet implemented at /tmp/QInlPTRzD3 line 1:␤------> [32msay :16<DEAD_BEEF[33m⏏[31m>;[0m␤␤Action method rad_number not yet implemented at /tmp/QInlPTRzD3 line 1:␤------> [32msay :16<DEAD_BEEF>[3…

[12:26] <p6eval> ..pugs, rakudo b4486e: OUTPUT«3735928559␤»

[12:27] <[Coke]> aluminum integers.

[12:27] <dalek> rakudo/nom-num: f7e4cec | moritz++ | src/Perl6/Actions.pm:

[12:27] <dalek> rakudo/nom-num: (re-)introduce radcalc, but smarter than before

[12:27] <dalek> rakudo/nom-num: review: https://github.com/rakudo/rakudo/commit/f7e4cecfbf

[12:27] <dalek> rakudo/nom-num: 64fe676 | moritz++ | src/Perl6/Actions.pm:

[12:27] <dalek> rakudo/nom-num: allow arbirary number of trailing zeros. Wins back the few tests that the previous commit regressed

[12:27] <dalek> rakudo/nom-num: review: https://github.com/rakudo/rakudo/commit/64fe6768a7

[12:27] <dalek> rakudo/nom-num: 8097419 | moritz++ | src/Perl6/Actions.pm:

[12:27] <dalek> rakudo/nom-num: hopefully speed up stripping of trailing zeros

[12:27] <dalek> rakudo/nom-num: review: https://github.com/rakudo/rakudo/commit/80974191c5

[12:27] <dalek> rakudo/nom-num: 09a43b7 | moritz++ | src/Perl6/Actions.pm:

[12:27] <dalek> rakudo/nom-num: remove (mostly PIR) functions that are now mostly unused

[12:27] <dalek> rakudo/nom-num: review: https://github.com/rakudo/rakudo/commit/09a43b7f1f

[12:27] <dalek> rakudo/nom-num: e939a8b | moritz++ | src/Perl6/Actions.pm:

[12:27] <dalek> rakudo/nom-num: get :16<DEAD_BEEF> style literals working

[12:27] <dalek> rakudo/nom-num: review: https://github.com/rakudo/rakudo/commit/e939a8bee9

[12:29] <moritz> rakudo: say :16('a0')

[12:29] <p6eval> rakudo b4486e: OUTPUT«160␤»

[12:29] <moritz> perl6: say :16('a0')

[12:29] <p6eval> niecza v7-32-g355a78a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method rad_number not yet implemented at /tmp/a8jEZIQryt line 1 (EOF):␤------> [32msay :16('a0')[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 570 (CORE di…

[12:29] <p6eval> ..pugs, rakudo b4486e: OUTPUT«160␤»

[12:35] <[Coke]> moritz++

[12:35] <jnthn> nom-num :)

[12:37] * moritz gets better at branch naming :-)

[12:37] <[Coke]> oh, those aren't in nom proper!?

[12:37] * [Coke] sighs.

[12:37] <[Coke]> jnthn: aren't you off being a redneck this week?

[12:38] <jnthn> ...a redneck? :)

[12:38] <jnthn> [Coke]: Only if I get sunburnt while hiking :)

[12:38] <[Coke]> er, off in the woods, away from technology...

[12:38] <jnthn> ah :)

[12:38] <jnthn> Yeah

[12:38] <jnthn> Going to the alps.

[12:38] <[Coke]> when do you leave?

[12:38] <jnthn> Just packing stuff at the moment

[12:39] <jnthn> Should probably leave in about 2.5 hours

[12:40] <jnthn> (Taking sleeper train from CPH, but gotta get over there first...and I don't trust the local trains to be on time when it matters...)

[12:45] <moritz> where is our action method for circumfix:<( )> defined?

[12:45] *** smash joined
[12:45] <smash> hello everyone

[12:45] <moritz> I see one in NQP::Actions, but I don't know if rakudo actually picks it up

[12:46] <moritz> \o smash 

[12:48] <moritz> never mind, found it

[12:49] <jnthn> I thought Rakudo had one...

[12:49] <jnthn> ah, good

[12:49] * jnthn was sure he saw it yesterday :)

[12:50] <moritz> jnthn: when we parse thing like :16('123'), there probably isn't a good way to see if the contents of that circumfix is a single constant known at compile time, is there?

[12:50] *** _twitch joined
[12:51] <jnthn> moritz: On any past node you can try $node<has_compile_time_value>

[12:51] * moritz tries

[12:51] <jnthn> If that is true, you may safely use $node<compile_time_value>

[12:51] <jnthn> Which will be the actual object, not a PAST node.

[12:52] <jnthn> The enum action method uses it, amongst other places.

[12:52] <jnthn> constant also, iirc

[12:58] *** xinming joined
[13:00] <moritz> doesn't seem to work the way I tried, I guess there are more levels of indirection involved

[13:00] <jnthn> Mebbe

[13:01] <jnthn> May be wrapped up in a PAST::Stmts for example

[13:01] <jnthn> I foudn that yesterday with enum.

[13:02] *** Holy_Cow joined
[13:03] <moritz> I'd love to see a mechanism that automatically strips unnecessary wrappings, and/or propagates information known at compile time up in the tree (towards the root)

[13:05] <[Coke]> ISTR someone was working on such a past filter for parrot.

[13:05] <moritz> I tried that back in the days when tcurtis was still working on his tree-optimizations lib

[13:09] <pmichaud> good morning, #perl6

[13:09] <moritz> good morning, pmichaud 

[13:12] *** pochi left
[13:12] <jnthn> morning, pmichaud 

[13:12] *** pochi joined
[13:15] <moritz> in the nom-num branch, I have some cases where I construct Int and Num literals inside radcalc()

[13:16] <moritz> should I apply the same PAST::Want magic there as method numish() does?

[13:16] <pmichaud> if it's not painful, yes.

[13:16] <moritz> it would be less painful if I refactored it into and add_numeric_constant

[13:17] <moritz> s/and/an/

[13:31] *** drbean left
[13:31] *** [Coke] left
[13:33] *** [Coke] joined
[13:38] *** [Coke] left
[13:40] *** [Coke] joined
[13:41] *** molaf joined
[13:43] *** Holy_Cow left
[13:44] *** pedram joined
[13:45] *** pedram left
[13:50] <dalek> rakudo/nom-num: 01df600 | moritz++ | src/Perl6/ (2 files):

[13:50] <dalek> rakudo/nom-num: refactor numeric constants to do the PAST::Want magic in a single place

[13:50] <dalek> rakudo/nom-num: review: https://github.com/rakudo/rakudo/commit/01df600ad2

[13:50] <moritz> pmichaud: at your convience I'd like to hear your opinion on the nom-num branch

[13:50] <moritz> *convenience

[13:50] * moritz can't type

[13:51] <moritz> pmichaud: it mostly tries to unify compile time number handling, eliminates PIR code, and adds back :16<DEAD_BEEF> style literals

[13:52] *** [Coke] left
[13:53] *** mtk joined
[13:53] *** [Coke] joined
[13:55] *** Chillance left
[13:57] <pmichaud> moritz: definitely planning to review it here in a bit

[14:08] <pmichaud> for the tests in S05-mass/rx.t, are we making any attempt to autogen that file (or otherwise synchronize it) with the rx tests in nqp, or are they basically separate?

[14:09] <pmichaud> (I'm fine with any answer.. just want to know if it's okay for me to be editing rx.t directly :)

[14:09] <jnthn> OK, time for me to be leaving.

[14:10] <jnthn> Happy hacking! I look forward to seeing how awesome nom is by the time I get back. :)

[14:10] <moritz> jnthn: have fun!

[14:10] <pmichaud> jnthn: happy travels!

[14:10] <moritz> pmichaud: it was originally autogenerated, and then edited by hand

[14:11] <moritz> pmichaud: so it's fine to edit it directly

[14:11] <pmichaud> moritz: perfect, thanks.

[14:11] <jnthn> Thanks! Bye o/

[14:12] <moritz> ~o~

[14:12] *** Chillance joined
[14:12] <JimmyZ_> jnthn: bye

[14:18] *** woosley joined
[14:20] <pmichaud> is it okay for me to split rx.t into smaller files?  

[14:21] <moritz> yes

[14:22] <moritz> you're also welcome to move the chunks to the correct sections

[14:22] <pmichaud> should I leave rx.t as-is and just create the new files, or should I remove things from rx.t also?

[14:22] <moritz> the latter

[14:22] <pmichaud> okay, will do

[14:22] <pmichaud> thanks

[14:22] <moritz> I don't want duplicate tests sprinkled around roast

[14:22] <pmichaud> first, a short break, then nom-num code review

[14:24] <PerlJam> moritz: since my ADD made me look at your code, when would you have .add_constant with differing $type and $primitive?

[14:25] <PerlJam> (technically that's not your code, but you used it so I figured the odds are good that you'd know the answer)

[14:26] <moritz> PerlJam: it allows you to create other wrapper types for same storage type

[14:27] <moritz> PerlJam: for example you might want to serialize List, Array and Parcel both with ResizablePMCArray as storage

[14:27] <moritz> PerlJam: or Int and Bool both as int

[14:27] <PerlJam> moritz: thanks, I just needed a good example.

[14:27] <pmichaud> hrm

[14:27] <pmichaud> this is going to be expensive, at least initially :-(

[14:27] <moritz> a more advanced serializer would figure that out by looking at the class

[14:28] <PerlJam> moritz: yeah, I was contemplating something "more advanced" and that's what led me to ask.

[14:28] <moritz> PerlJam: actually there's one example that uses different primitives/types already

[14:28] <moritz> PerlJam: Rat and Complex both use type_new and primitive

[14:29] <moritz> s/and/as/

[14:32] <pmichaud> moritz: be aware that (iiuc) nqp doesn't do anything special with   "my int $i".  I.e., it's still a Parrot PMC.

[14:32] <moritz> ouch

[14:33] <pmichaud> jnthn has plans to fix this... (as it works in nom), but I don't think it's been done for nqp yet.

[14:33] <moritz> it explains why I had to (partially) use nqp::mul_n instead of *

[14:34] <ingy> greetings

[14:34] <pmichaud> even assuming it does work, won't radcalc quickly go out of the range of integers for nums and stuff like that?

[14:35] <PerlJam> hello ingy

[14:35] <moritz> pmichaud: not quicker than the current solution, if we can trust roast

[14:35] <pmichaud> current solution being... ?

[14:36] <moritz> the code in nom

[14:36] <pmichaud> yes, it's wrong also.

[14:36] <pmichaud> I did say that the existing solutions all have something wrong with them.

[14:36] <moritz> I know

[14:36] <pmichaud> better might be to follow something closer to what master does

[14:36] <moritz> what I tried to do was to put it all into one place, so that it's easier to fix eventually

[14:37] <pmichaud> okay, the question I have at this point becomes -- how does Str.Numeric ultimately access this code?

[14:38] <moritz> how smart is Str.Numeric supposed to be?

[14:38] <pmichaud> almost as smart as the compiler, iiuc.

[14:38] <pmichaud> it certainly has to be able to handle radix conversions.

[14:38] <moritz> then it needs to call back into the compiler

[14:38] <pmichaud> call back into the compiler is probably too inefficient.

[14:38] <pmichaud> string-to-number conversion is too common an operation for that.

[14:39] <moritz> and reimplementing parsing of all possible number formats is insane

[14:39] <pmichaud> I don't think we have to do it for all number forms

[14:39] <moritz> so, optimize for the common case, and detect when to call back into the compiler?

[14:39] <pmichaud> yes

[14:39] <moritz> for example radcalc is capable for handling things of the form '0xAB'

[14:40] <pmichaud> but it should be the same code for both runtime and compile time conversions

[14:40] <moritz> that would involve reparsing

[14:40] <pmichaud> well, except that radcalc seems to return PAST trees

[14:40] <moritz> which we also avoid

[14:40] <pmichaud> ...reparsing?

[14:40] <pmichaud> why so?

[14:40] <moritz> currently the grammar handles cases like :16<DEADBEEF>

[14:41] <moritz> oh, never mind

[14:41] <moritz> I had a logic error

[14:42] <moritz> the only thing where we can't take the same code path is when deciding whether to call back into the compiler or not

[14:42] <moritz> beccause the compiler will never do that

[14:42] *** envi left
[14:42] <pmichaud> that's a good point

[14:42] <moritz> re returns PAST: that's easy-ish to fix

[14:42] <moritz> what I'm a bit worried about

[14:42] <moritz> is '3+4i'.Numeric

[14:43] <pmichaud> is that supposed to become a complex number?

[14:43] <moritz> I fear so

[14:44] <moritz> note sure, we should ask TimToady++

[14:44] <pmichaud> it is.

[14:45] <moritz> but since we don't have a rule to parse it as a literal in the grammar, we need diverting code paths

[14:45] <pmichaud> S02:3325

[14:45] <pmichaud> not necessarily.  the string-to-number converter can have an option for converting complexes that the grammar never calls.

[14:46] <moritz> so, different code paths

[14:46] <pmichaud> how many different forms of numbers do we have?

[14:46] <pmichaud> let's make a list.

[14:46] <moritz> plain integers: 1234

[14:46] <moritz> rationals:  123.56

[14:47] <moritz> nums: 123.45e6

[14:47] <moritz> radixed numbers: :16<DEAD.BEEF> # I think also allows exponents somehow

[14:48] <moritz> complex/imag: 3+4i, or just 4i

[14:48] <moritz> autobase:  0xBEEF

[14:48] *** kaare__ joined
[14:49] <moritz> other nums: Inf, NaN, +-Inf

[14:49] <moritz> maybe complex inf? Inf\i

[14:50] <moritz> I think :16($thing) doesn't count, because it's not a real literal

[14:50] <pmichaud> correct, that's runtime.

[14:50] <pmichaud> so, is that about it?

[14:51] <moritz> unless I forgot something

[14:51] <pmichaud> that's all I see.

[14:51] <moritz> (was from memory here :-)

[14:51] <pmichaud> It doesn't seem like it would be too hard to write a string-to-number conversion that could handle all of the above cases.

[14:52] <moritz> well, to me it seems we need two functions:

[14:52] <moritz> 1) a string-tokens-to-number convert, used both in Str.Numeric and at compile time

[14:53] <moritz> 2) a parser for strings that is only used in Str.Numeric

[14:53] <pmichaud> I don't understand why we need #2.

[14:53] <pmichaud> wait, rephrase.

[14:53] <pmichaud> I don't understand why #2 can't be just part of #1.

[14:54] <pmichaud> and by "parser" I'm specifically thinking "not regexes"

[14:54] <moritz> a parsers is not the same as a converter. By separating the two, we probably get cleaner code, and it will be easier to see which parts are reused by both compile time and run time

[14:55] <moritz> s/parsers/parser/

[14:55] <pmichaud> let's assume I have a string-to-number converter that can handle all of the cases we identified.  Why can't the compiler use that?

[14:56] <moritz> it can, but then we get reparsing

[14:56] <pmichaud> if the "reparsing" in the string-to-number converter is fast, why is that a problem?

[14:56] <pmichaud> and it's at compile time... so why is that an issue?

[14:57] <moritz> maintenance

[14:57] <pmichaud> technically radcalc is even now doing "reparsing"

[14:57] <moritz> what if you change the number formats in one of the parsers?

[14:58] <pmichaud> we update the string to number converter... but we'd have to do that anyway.

[14:58] <moritz> pmichaud: it does probably too much

[14:58] <moritz> perl6: say +' 5'

[14:58] <p6eval> pugs, rakudo b4486e, niecza v7-32-g355a78a: OUTPUT«5␤»

[15:03] <moritz> pmichaud: so, do you want me to merge nom-num for now, as an incremental improvement, and continue working on the more general parser?

[15:03] <pmichaud> +1

[15:03] <moritz> (though I'm not sure I have enough experience with non-regex based parsers to come up with a good one)

[15:04] <moritz> what I at least can do is to collect test cases

[15:04] <moritz> perl6: say +'1.4e5x'

[15:04] <p6eval> pugs, rakudo b4486e: OUTPUT«140000␤»

[15:04] <p6eval> ..niecza v7-32-g355a78a: OUTPUT«Unhandled exception: System.FormatException: Unknown char: x␤  at System.Double.Parse (System.String s, NumberStyles style, IFormatProvider provider) [0x00000] in <filename unknown>:0 ␤  at System.Double.Parse (System.String s, IFormatProvider provider) [0x…

[15:04] <pmichaud> for numbers, a dfa-based solution tends to work well

[15:04] <pmichaud> number parsing rarely involves backtracking

[15:05] <moritz> so, write a big regex, and hand-translate to a DFA?

[15:05] <pmichaud> we have a big regex already

[15:05] <pmichaud> it's in the grammar :)

[15:05] <moritz> that's not complete (see the 3+4i case)

[15:05] <pmichaud> so, add that case

[15:06] <pmichaud> (mentally, not actually into std.pm)

[15:06] * moritz is a bit scared :-)

[15:06] <pmichaud> maybe I can prototype the parsing bit in nqp

[15:07] <pmichaud> that will at least let us both see what I'm aiming at, and then maybe you can work on integrating it into rakudo

[15:09] <sorear> good * #perl6

[15:09] <sorear> pmichaud: did studying niecza help at all with qregex?

[15:09] <pmichaud> sorear: it helped a ton.  thanks.

[15:10] <pmichaud> the ltm stuff was a lot easier to follow in niecza than in Cursor.pmc

[15:10] <TimToady> someday soon LTM dfa will hopefully be fast enough to do number parsing, and then we'll want extensible number literals

[15:11] <pmichaud> TimToady: yes, I'm thinking that as well.  the slowdown (for Rakudo at least) is in the captures.

[15:12] <TimToady> might be an appropriate spot to throw in a tagged DFA instead, so that captures are just offsets into the string

[15:12] <TimToady> not expecting that right away though

[15:12] <pmichaud> right

[15:12] <pmichaud> I think a fully-grammar based solution is ultimately possible... just not likely in the near future.

[15:13] <pmichaud> (where "near future" means "2011")

[15:13] <sorear> pmichaud: STD.pm6 has a rule 'strtonum' with a comment that suggests it's intended to be the definition of Str.Numeric

[15:13] <TimToady> also, we might have an arrangement whereby, instead of actually using LTM for everything, we just notice that something looks funny about a normal number, and only invoke the grammar when we're not sure

[15:13] <TimToady> yeah, we had some stuff in there, but it's likely bitrotted

[15:13] <pmichaud> sorear++  # excellent catch, thanks!

[15:14] <pmichaud> moritz: I need to take a short walk, then I'll come back and see what I can put together for a parser

[15:15] <TimToady> you'll note that strtonum is still not handling whitespace

[15:16] <sorear> should it?

[15:16] <TimToady> probably not

[15:16] <TimToady> but there should be some other rule that does

[15:16] <pmichaud> we allow leading whitespace in strings but not in the middle of the constant, yes?

[15:16] <moritz> so should +' 5' be 0?

[15:16] <TimToady> or the conversion routine does

[15:17] <TimToady> moritz: certainly not

[15:17] <sorear> another question....should Perl6 keep the "silently ignore trailing garbage" that Perl5 does?

[15:17] <pmichaud> +' 5+4i'   # complex

[15:17] <pmichaud> +' 5 + 4i'   # int with warning about extra stuff

[15:17] <pmichaud> in a sixperl call long ago, I think we leaned away from "silently ignore trailing garbage"

[15:17] <moritz> sorear: I'd say we should require a word boundary at least

[15:17] <sorear> I'm inclined to call +' 5' an error, but I'm biased to strictness like that

[15:17] <TimToady> thinking of the <5+4i> case, yes, I think we should be picky about wordiness

[15:17] *** am0c left
[15:18] <TimToady> but not about leading trailing

[15:18] <TimToady> (whitespace)

[15:18] <moritz> +'5isnotgood' # 0, 5 or 5i?

[15:18] <sorear> or exception?

[15:18] <sorear> Failure

[15:18] <pmichaud> at least a warning.

[15:18] <pmichaud> failure is fine with me.

[15:19] <TimToady> hmm, .comb(/<strtonum>/)  :)

[15:19] <TimToady> that expresses the intent to ignore garbage

[15:19] <pmichaud> afk for a bit

[15:20] <PerlJam> +'5e3' and  +'5e3blah'  #  ?

[15:21] <TimToady> as long as the user can invoke strtonum directly, there's no reason to allow trailing garbage by default

[15:21] <TimToady> other than ws

[15:21] <moritz> so no Inf\i in strtonum

[15:21] <TimToady> after all, trailing garbage may indicate a number conversion that they thought they were importing but didn't

[15:21] * moritz can live with that

[15:22] <sorear> How should strtonum be exposed to the user?

[15:22] <flussence> Str.parseInt? :) /me ducks

[15:22] <sorear> Should +~(Inf\i) be made to work?

[15:23] <sorear> flussence: ITYM int.Parse :p

[15:23] <TimToady> why shouldn't 'Inf\i' parse?

[15:23] *** thou joined
[15:23] <moritz> which subrule would match the \ ?

[15:24] <TimToady> nobody has claimed that strtonum is correct yet :)

[15:24] <moritz> oh wait, it's even in there

[15:24] <sorear> let's work out a working strtonum *today*

[15:24] <TimToady> if we can allow "prefix" +/- on the front, we can all "postfix" \i on the back

[15:24] * moritz is just too blind

[15:25] <TimToady> *allow

[15:27] <TimToady> why, so it is...fancy that...

[15:28] <moritz> sorry for being rash

[15:29] * TimToady is never rash, except when he is

[15:30] *** am0c joined
[15:30] *** thou_ joined
[15:30] <moritz> S02-builtin_data_types.t has  isa_ok(+"0b0101", Rat)

[15:30] <moritz> that's wrong, should be an Int, right?

[15:30] <TimToady> das ist richtig

[15:31] <moritz> erm, s/b/d/ (but doesn't really matter here)

[15:31] <moritz> es ist richtig, dass es falsch ist? :-)

[15:31] <TimToady> Hai, sou desu!

[15:33] *** thou left
[15:33] <TimToady> now if it were Real, that would be okay

[15:34] <TimToady> maybe that's what they were thinking

[15:34] <TimToady> except for the 'isa' part

[15:34] <TimToady> I don't suppose we have a does_ok...

[15:35] <pmichaud> back again

[15:36] *** woosley left
[15:36] <pmichaud> TimToady: are you suggesting that <strtonum> is a standard rule, like <alpha> or <digit>?

[15:36] <TimToady> possibly

[15:36] <pmichaud> or is that just a place holder for something like  <Perl6::strtonum>  ?

[15:36] <TimToady> or something

[15:37] <pmichaud> I vote for <number> instead of <strtonum>, if we do that.

[15:37] <TimToady> that's taken

[15:37] <pmichaud> we can change the existing <number>  :-)

[15:37] <pmichaud> <strtonum> as a name probably doesn't quite work.

[15:37] <TimToady> yes, we could

[15:38] <pmichaud> maybe <stdnum>

[15:38] <TimToady> <numeric>

[15:38] <pmichaud> <numeric> works for me.

[15:38] <[Coke]> Whenever TimToady says "possibly", I hear it as "mayyyyyyyyyyyyyyyyyyyyyybe".

[15:38] <pmichaud> [Coke]: you are perceptive.  :)

[15:39] <[Coke]> ah, I was going for silly. ;)

[15:39] <TimToady> possibly means possibly <mutter>not</mutter>

[15:39] <pmichaud> <numeric>  is the set of things that Str.Numeric recognizes

[15:39] <TimToady> that's why I suggested it :)

[15:39] <pmichaud> you gave the name but not the reason :)

[15:40] <TimToady> okay, then pmichaud++ gets the credit :)

[15:40] <pmichaud> not all of us automatically see the connections in your brane :)

[15:40] <TimToady> you and me both

[15:41] *** _twitch left
[15:43] <dalek> std: 516268a | larry++ | STD.pm6:

[15:43] <dalek> std: s/strtonum/numeric/

[15:43] <dalek> std: review: https://github.com/perl6/std/commit/516268a11c

[15:43] *** mj41 left
[15:45] *** wtw left
[15:49] *** mberends left
[15:51] <pmichaud> do we expect this to work?      say +":16< ffff #`(hah!) >"

[15:51] *** molaf left
[15:53] <pmichaud> moritz: okay, I'm convinced we need two codepaths.  Str.Numeric will use a fast converter when it recognizes the string, and fall back to eval(self) when it doesn't.

[15:54] <pmichaud> it would be nice if the compiler could also use the fast converter, but that's not necessary.

[15:54] *** jferrero left
[15:55] *** jferrero joined
[15:56] <pmichaud> or, more likely,   eval(self) if $_ ~~ /<numeric>/

[15:56] <pmichaud> or something like that <waves hands about in a TimToady++ like fashion>

[16:02] <pmichaud> for me, "fast converter" should handle decimal ints, rats, and nums.  If it can easily handle the predefined radix forms ('0x', '0o, ...)   that's fine too, but I'm not as picky about that.

[16:02] <TimToady> obviously you don't want to set up for a code injection

[16:02] <pmichaud> right, that's why we need the <numeric> test.

[16:03] <pmichaud> and eval(...) doesn't have to be a real eval -- it just needs to get into the current parser and compiler somehow.

[16:03] <TimToady> if we're doing constant folding right, the .ast should be easily foldable

[16:04] <TimToady> if not prefolded by the parser

[16:04] <pmichaud> yes, I suppose we could do some variation of    (self ~~ /<numeric>/).ast

[16:05] *** cognominal_ joined
[16:05] <pmichaud> that makes a lot more sense

[16:05] <TimToady> and if a number doesnt fold itself, then there's an indication of a security hole, or something marked impure that shouldn't be

[16:07] <sorear> TimToady: If I put "say 2" in CORE.setting and then ran a program consisting of "use Test;", how many times would you expect 2 to be printed?

[16:07] <pmichaud> need lunch.. bbiah

[16:08] *** cognominal left
[16:08] *** benabik left
[16:10] <cbk> How can I push|access|update the last element in an muti-dimensional hash of arrays?  I have tried everything and completely at a lost here.

[16:11] <cbk> so far i have %materialPriceHistory = ( XFine => [40], Fine => [30], Std => [20], );

[16:11] <sorear> cbk: Hashes are unordered, they don't have last elements.

[16:12] <PerlJam> cbk: perhaps you wanted to use an array instead of a hash?

[16:12] <cbk> I want a hash of arrays, and need to update/push a value to the last elem 

[16:12] <moritz> %hash.values>>.push($new_elem)

[16:13] <moritz> %hash.values>>.[*-1] = $new_elem xx *

[16:13] <PerlJam> cbk: the last element of all of the arrays?

[16:13] *** al_form joined
[16:14] <moritz> that would be %hash.values>>.[*-1]

[16:14] <cbk> PerlJam no each key will have different value in its array (this reps. price history)

[16:15] <cbk> so each month I will update the current price for each key in the hash

[16:15] *** al_form left
[16:16] *** donri left
[16:16] <moritz> so you have a list of new prices?

[16:16] *** donri joined
[16:17] <cbk> moritz that gets calc. based on other values

[16:18] <PerlJam> cbk: do you have the list of values all at once (like in an array or an analogous hash structure) ?

[16:18] *** cognominal_ left
[16:18] *** cognominal_ joined
[16:19] <moritz> so something like   for %hash.kv -> $k, $v { %hash{$k}.push: calculate_new_price($v) } ?

[16:19] <cbk> PerlJam I have the values all at once

[16:19] <cbk> moritz, yes i think

[16:20] <PerlJam> moritz++ your ESP-fu is great today  :)

[16:20] <cbk>  moritz so is there a space between .push: calculate...? 

[16:22] <moritz> cbk: yes

[16:22] *** ab5tract joined
[16:22] <cbk> moritz, ok

[16:24] *** jerome joined
[16:24] <JimmyZ_> rakudo: my %hash9; %hash9{1} = 2;  for %hash9 -> $k, $v { say $k; $v; } # why it doesn't work?

[16:24] <p6eval> rakudo b4486e: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in <anon> at line 22:/tmp/YvaoJ_kUBR␤  in main program body at line 1:src/metamodel/RoleToInstanceApplier.nqp␤»

[16:25] *** JimmyZ_ left
[16:28] <jlaire> because of missing .kv, but that's LTA

[16:29] <cbk> moritz, Thank you! that worked flawless: output form say %history.perl {"xFine" => [40, 50, 9999], "fine" => [30, 9999], "std" => [20, 9999]}

[16:29] <cbk> someone should give you that ++ thingy!

[16:29] <TimToady> sorear: the setting is intended to provide only a lexical context, not a dynamic context.  I'd not expect a say to do anything except when actually compiling the setting

[16:29] *** zby_home_ joined
[16:29] <moritz> cbk: you do it :-)

[16:30] <cbk> moritz++

[16:30] <moritz> cbk: and wow, you're prices are sure going up :-)

[16:30] <TimToady> sorear: the specced way to get the setting to do dynamic stuff is by defining (lexically) a MAIN

[16:30] <cbk> moritz thats just testing code

[16:42] *** masak joined
[16:42] <masak> greetings, pandas.

[16:43] *** daxim left
[16:43] *** lichtkind joined
[16:45] *** daniel-s left
[16:53] *** envi joined
[16:55] <dukeleto> tadzik: ping

[16:59] <sorear> o/ masak

[17:01] <masak> \o

[17:01] <thou_> masak: have you looked at plackdo? at first blush, it looks nicely coded and like a lot of work has been done already; it's more complete than Web.pm + HTTP::Server::Simple combined, at this point.

[17:02] <dalek> niecza: 02fae77 | sorear++ | / (4 files):

[17:02] <dalek> niecza: eval code runs with eval caller as root of protopads, not just runtime

[17:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/02fae7728a

[17:02] <masak> thou_: I'm not sure I've even heard of it, but the news makes me happy. who is coding it?

[17:02] <thou_> is lopnor (plackdo author) on irc? i saw a talk from him about plackdo on the 'net.

[17:03] <masak> ah ,lopnor.

[17:03] <masak> s/ ,/, /

[17:03] <masak> I think I've seen em around, yes.

[17:03] <thou_> you've been hanging around with Moukkedar too much

[17:03] <masak> :P

[17:03] *** dakkar left
[17:03] <masak> (sorry, moritz) :/

[17:04] * masak learns the appropriate spelling of 'pedestal'

[17:04] <thou_> https://github.com/lopnor/p6-plackdo

[17:04] *** thou_ is now known as thou

[17:06] * dukeleto likes plack for perl 6. Somebody asked me if it existed at my perl 6 talk yesterday

[17:06] <eiro>  /plack/ and wake-up($eiro)

[17:06] <thou> re: plackdo, all the tests pass with current rakudo-master

[17:06] <eiro> thou, is there a plack version of perl6 ?

[17:06] <eiro> OMG awesome!

[17:06] <thou> eiro: that's what plackdo seems to be going for -- it's pretty much a straight port

[17:07] *** ab5tract left
[17:07] *** jevin left
[17:09] *** jevin joined
[17:09] <thou> imo it makes sense to put effort into that project (add more Plackdo::Handler::*, Middleware, etc.). from what i could tell from lopnar's talk in taipei, i think he'd be open to contributions and making it a community project.

[17:09] <thou> i'd like to see some modules moved up a level (Plackdo::HTTP::* -> HTTP::*, for example)

[17:11] <pmichaud> moritz: I'm going to create a nqp opcode that will do basic radix conversions for us as a primitive.  We can then build up more complex sequences from that.

[17:11] <moritz> pmichaud: where "basic radix conversion" means (str, base) -> int ?

[17:12] <masak> a Container has @.contents, but what does a Platform have?

[17:12] <pmichaud> (str, base) -> (value, denominator, pos)

[17:12] <moritz> @.rails

[17:12] <masak> (i.e. a thing which you can put things "on", not "in".)

[17:12] <moritz> @.parking-lots

[17:12] <pmichaud> "denominator" is basically radix ** number of digits in the str

[17:12] <pmichaud> (excluding trailing zeroes)

[17:12] <masak> maybe I should call it Base, but that's a bit OO-overloaded too.

[17:13] <moritz> and pos?

[17:13] <pmichaud> pos is the number of characters it consumed

[17:13] <moritz> ok

[17:13] <pmichaud> or, more accurately, it's the position at which it stopped consuming

[17:13] * masak goes with @.things for the now

[17:13] <thou> eiro: i think it'd be awesome to have a solid, community-supported implementation that is basically Plackdo + LWP on perl6, to cover the complete web development space from server > middleware > web app + user-agent/foo; i think it's pretty attainable right now with a bit of organization

[17:14] <moritz> where should tests for the Str.Numeric conversion go?

[17:14] *** jferrero left
[17:14] <pmichaud> make a new test file, perhaps?

[17:14] *** MayDaniel joined
[17:14] <moritz> probably best

[17:14] <pmichaud> basic_data_types/str-something

[17:14] <pmichaud> 02-basic_data_types/str-numeric.t

[17:14] <moritz> or maybe S32-str/numeric.t ?

[17:15] <pmichaud> could go there too, I suppose.

[17:15] * moritz doesn't like the proliferation of S02-builtin_data_types tests

[17:15] <pmichaud> there's not a clear line between what goes into 02-basic_data_types and S32-*

[17:15] *** jferrero joined
[17:15] <pmichaud> and I absolutely abhor the name "S02-basic_data_types", especially the mixing of hyphen and underscores part

[17:15] <pmichaud> plus it's so long for something so... basic

[17:15] <pmichaud> it's improperly huffmanized

[17:16] <pmichaud> if the S02-basic_data_types found their way into S32-* equivalents, I think I'd be pretty happy.  :)

[17:16] <thou> eiro: i've never used plack/rack/wsgi for anything serious, but i'm hacking on November wiki as a way to deepen my perl6 knowledge (and contribute to the community), so i've got some motivation for being part of such an effort. are you involved in porting Dancer to perl6? or do i mis-remember?

[17:20] <sorear> dukeleto: perl 6 talk yesterday, where?

[17:21] <thou> moritz, pmichaud: imo S02 is too big already, so i'm +1 on the idea of moving at least whatever tests make sense in a different section out of the S02-* namespace

[17:21] <masak> alpha: class C { has $.name = self.WHAT.perl }; say C.new.name

[17:21] <p6eval> alpha : OUTPUT«C␤»

[17:21] <masak> rakudo: class C { has $.name = self.WHAT.perl }; say C.new.name

[17:21] <p6eval> rakudo b4486e: OUTPUT«C␤»

[17:21] <masak> nom: class C { has $.name = self.WHAT.perl }; say C.new.name

[17:21] <p6eval> nom: OUTPUT«Symbol 'self' not predeclared in <anonymous> (/tmp/EUlC244vWj:1)␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 146 (compilers/pct/src/PCT/HLLCompiler.pir:107)␤»

[17:21] <masak> awww

[17:21] <eiro> thou, i'm just a plack user. i never developped anything for plack 

[17:21] <masak> eiro: salut! \o

[17:22] <thou> eiro: ok. maybe you can check out plackdo's current state, and see what things you're used to in plack that are missing there, to set some priorities on what to implement next

[17:22] <eiro> but basically, i'm playing with tatsumaki, Template::Declare and MooseX::Declare to make long-polled powered webapp. perl6 version would be awesome

[17:22] *** mj41 joined
[17:23] <eiro> hello masak! i oversold nom at #rmll so i expect it to be the next rakudo star :)

[17:23] <masak> eiro: :)

[17:23] <thou> hmmm, i bet tatsumaki-style backend for perl6 would be pretty hard to implement at the moment

[17:23] * masak kinda liked the name "Rakudo Moon"

[17:23] <eiro> ok

[17:24] <eiro> thou, it's just an idea. i don't think i will have time to play with it actually (i have stuff to do and i'm stuck with perl5) 

[17:24] <eiro> but i'll watch your work :)

[17:24] <thou> eiro: ok, that's good :-)

[17:25] <masak> eiro: Rakudo on nom will be great -- but it probably won't astonish until the optimizer lands a few months later.

[17:26] *** patrickas joined
[17:26] <patrickas> o/

[17:26] <masak> patrickas! \o

[17:26] *** perlhack joined
[17:26] <masak> perlhack! \o/

[17:26] <perlhack> long time no see

[17:26] <perlhack> masak

[17:26] * thou is excited about the non-optimization things it'll open up, too; consistent underlying object model should make it eas<y ier> to implement some of perl6's more esoteric introspection and other features

[17:26] <masak> 还久不见了

[17:26] <thou> ni hao, perlhack!

[17:27] <patrickas> I am trying to build nom on win32 (for the first time) and getting an error : opcode index out of bounds on library `core_ops'. Found 1084, expected 0 to 1070.

[17:27] <dalek> roast: b32ed21 | moritz++ | S03-operators/boolean-bitwise.t:

[17:27] <dalek> roast: fudge boolean-bitwise.t for rakudo

[17:27] <dalek> roast: review: https://github.com/perl6/roast/commit/b32ed21af5

[17:27] <dalek> roast: 0fd99d3 | moritz++ | S (2 files):

[17:27] <dalek> roast: start to systematically test string numification

[17:27] <dalek> roast: 

[17:27] <dalek> roast: Also corrects a test in num.t, and removes another wrong test

[17:27] <dalek> roast: review: https://github.com/perl6/roast/commit/0fd99d317c

[17:27] <perlhack> thou: ni hao 

[17:28] <moritz> patrickas: sounds like an outdated parrot or rakudo build interfering

[17:28] <patrickas> am I out of luck since jnthn++ is on vacation ?

[17:28] <perlhack> it's a nice day 

[17:28] <perlhack> masak

[17:28] <patrickas> I'll make clean

[17:28] <masak> perlhack: yes, it is. :)

[17:28] <patrickas> maybe even realclean

[17:29] <moritz> patrickas: and don't forget to delete the installation folder too

[17:29] <patrickas> which folder ?

[17:30] *** Jackneill left
[17:30] <moritz> the 'isntall' subfolder of rakudo

[17:30] <moritz> erm, install

[17:30] <moritz> minus typos :-)

[17:30] *** Jackneill joined
[17:30] <flussence> if you're using a git checkout the easiest way is git clean -xdf

[17:30] <flussence> (and the same in ./parrot if you do it that way)

[17:30] <perlhack> i'm still sleepy.

[17:30] <moritz> perl6: say 0x123

[17:31] <p6eval> pugs, rakudo b4486e, niecza v7-33-g02fae77: OUTPUT«291␤»

[17:31] <perlhack> pugs  Audrey Tang

[17:32] <sorear> huh.

[17:32] *** mj41 left
[17:32] <sorear> use Test; $_ = 5 dies

[17:32] <sorear> remove use Test and it works

[17:32] <moritz> where? niecza?

[17:32] <sorear> ya

[17:33] <patrickas> sorear you have to contact the guy who wrote niecza for help with that :-p

[17:35] *** perlhack left
[17:39] <dukeleto> phenny: tell tadzik panda error https://gist.github.com/1081878

[17:39] <phenny> dukeleto: I'll pass that on when tadzik is around.

[17:40] *** perlhack joined
[17:40] <perlhack> I share with you how much vocabulary

[17:40] *** jaldhar left
[17:41] <masak> perlhack: "How much vocabulary do I share with you?"

[17:42] <masak> perlhack: note the reversed word order, and the word "do" because of it.

[17:42] <masak> perlhack: that's common for questions in English.

[17:42] <perlhack> yes. thanks .

[17:43] *** mberends joined
[17:43] <perlhack> masak, how much vocabulary ??

[17:43] *** MayDaniel left
[17:43] <masak> perlhack: I am not sure how to answer that question.

[17:43] *** benabik joined
[17:44] <masak> perlhack: you seem to be picking up English fairly quickly, though.

[17:44] <patrickas> same error after cleaning / deleting / re making !

[17:45] <perlhack> thinks  .4000 can do ?

[17:45] <perlhack> masak

[17:45] <masak> perlhack: I always find such measures more or less meaningless.

[17:46] <masak> perlhack: are you asking because you refuse to learn word 4001? or because you won't do it if it turns out you need 5000 words to get by?

[17:46] <masak> perlhack: or because you think word 4000 is really good to know, but word 4001 is useless?

[17:47] <lucs> About 500 words can be enough for everyday conversation.

[17:47] <perlhack> it 's useful.

[17:47] <perlhack> masak

[17:47] <perlhack> a !!!! 500?

[17:47] <masak> perlhack: if you say so :P

[17:48] <masak> perlhack: but I can't answer it for you, I'm afraid.

[17:48] <lucs> perlhack: Sure. Not too many technical terms in those, but still :)

[17:48] <perlhack> haha 

[17:48] <moritz> perl6: say 0o77

[17:49] <p6eval> pugs, rakudo b4486e, niecza v7-33-g02fae77: OUTPUT«63␤»

[17:49] <perlhack> masak, thanks

[17:50] <perlhack> lucs, thanks

[17:53] <perlhack> :-) i often exchange and Audrey Tang.

[17:56] <masak> &

[17:57] <perlhack> masak, what mean "&" ?

[17:57] <perlhack> opreator ?

[17:58] <lucs> It means he is now in the "background" (like when it's used in a shell command).

[17:58] *** [Coke] left
[18:00] *** [Coke] joined
[18:00] <perlhack> ouch! i am a Linux administrator.i see it

[18:00] <perlhack> lucs

[18:00] <lucs> :)

[18:00] *** mberends left
[18:00] <perlhack> i would like to exchange with you for 10 years

[18:01] <lucs> One day at a time :)

[18:01] *** awwaiid joined
[18:01] <perlhack> yes.haha

[18:02] <perlhack> i will be very good native english speaker.

[18:02] *** tokuhir__ left
[18:10] <moritz> perl6: say :36<az>

[18:10] <p6eval> pugs, rakudo b4486e: OUTPUT«395␤»

[18:10] <p6eval> ..niecza v7-33-g02fae77: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method alnumint not yet implemented at /tmp/wl6rxRQx1R line 1:␤------> [32msay :36<az[33m⏏[31m>[0m␤␤Action method rad_number not yet implemented at /tmp/wl6rxRQx1R line 1 (EOF):␤------> [32msay :36<az>[33m⏏[31m<…

[18:13] <dalek> roast: a207da9 | moritz++ | S32-str/numeric.t:

[18:13] <dalek> roast: more numification tests

[18:13] <dalek> roast: review: https://github.com/perl6/roast/commit/a207da9b9a

[18:14] *** mberends joined
[18:14] *** [Coke] left
[18:14] *** perlhack left
[18:17] <moritz> std: 1e1_0

[18:17] <p6eval> std 516268a: OUTPUT«ok 00:01 118m␤»

[18:18] *** [Coke] joined
[18:20] <dalek> roast: cbe385a | moritz++ | S32-str/numeric.t:

[18:20] <dalek> roast: more numification tests

[18:20] <dalek> roast: review: https://github.com/perl6/roast/commit/cbe385aa7d

[18:23] *** birdwindupbird left
[18:26] *** impious joined
[18:30] <dalek> niecza: 8d724eb | sorear++ | lib/ (2 files):

[18:30] <dalek> niecza: Fix use Test; $_ = 5

[18:30] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8d724eb4d9

[18:30] *** mberends left
[18:33] *** patrickas left
[18:36] <moritz> std: :1_0<34>

[18:36] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Extra argument not allowed; pair already has argument of 1 at /tmp/X43Gsgk2SH line 1:␤------> [32m:1_0[33m⏏[31m<34>[0m␤Check failed␤FAILED 00:01 118m␤»

[18:37] <moritz> pugs: :8<42.35>

[18:37] <p6eval> pugs:  ( no output )

[18:37] <moritz> pugs: say :8<42.35>

[18:37] <p6eval> pugs: OUTPUT«34.453125␤»

[18:38] *** im2ee joined
[18:43] <pmichaud> moritz: are you working on string literals or also on Str.Numeric ?

[18:43] <pmichaud> wait

[18:43] <pmichaud> are you working on numeric literals (compile time) or also on Str.Numeric (run time)?

[18:44] <pmichaud> I'll have some code together for the "fast converter" of runtime strings in a couple of hours ($otherjob is in the way)

[18:44] *** envi left
[18:46] <tadzik> dukeleto: pong

[18:46] <phenny> tadzik: 17:39Z <dukeleto> tell tadzik panda error https://gist.github.com/1081878

[18:47] <tadzik> phenny: tell dukeleto that's because of too old prove, no -e switch in it

[18:47] <phenny> tadzik: I'll pass that on when dukeleto is around.

[18:47] <tadzik> phenny: thank you darling

[18:48] <TimToady> sorear: the new 2nd entry for http://rosettacode.org/wiki/Pythagorean_triples#Perl_6 shows that niecza can be pretty fast at some things :)

[18:49] <TimToady> it can count all pythagorean triples with perimeter less than a billion

[18:49] <mikemol> Some of p6eval's output is really screwing with irssi->screen->PuTTY. Weird.

[18:52] <[Coke]> can you see the butterfly in the topic?

[18:52] <mikemol> Yeah

[18:52] <[Coke]> (that'll rule out generic utf8 issues)

[18:52] <mikemol> http://img219.imageshack.us/img219/5812/p6evalirssiscreenputty.png

[18:53] <TimToady> sorear: mind you, it heated up my laptop for an hour or so to get the last line, so it'd take longer on your machine...

[18:54] <pmichaud> I remember when Juerd++ once reported that an early version of PGE was able to handle a regex that choked P5 (although it took a really time to do it)  :)

[18:54] <pmichaud> anyway, niecza++, as always

[18:54] <TimToady> your long is too short

[18:54] *** ng1962 joined
[18:55] <TimToady> I think rakudo could run it too if it didn't die on the recursion limit

[18:55] <pmichaud> indeed, it is.

[18:55] <pmichaud> (my long is too short, that is)

[18:55] <PerlJam> he accidentally his long.

[18:55] <pmichaud> oh, we could probably bump the recursion limit in Rakudo.

[18:57] <tadzik> oh, you stumbled upon that too? :)

[18:57] <mikemol> I wonder if it would be possible to detect cycles(infinite recursion) in recursive algorithms, and have that as a useful means of triggering a stack-overflow-like exception.

[18:57] <mikemol> With detection of cycles, it might be generally acceptable to otherwise bump recursion limits.

[18:57] <dukeleto> tadzik: ok, I will let my buddy know. I gues we need a newer TAP::Harness

[18:57] <phenny> dukeleto: 18:47Z <tadzik> tell dukeleto that's because of too old prove, no -e switch in it

[18:58] <tadzik> dukeleto: I was considering defaulting to parrot_prove in panda, but never tried that in action

[18:58] *** skangas left
[18:59] <dukeleto> tadzik: also, some people from PDX.pm that a switch be added to prove to tell it we are running perl 6 tests

[18:59] <dukeleto> tadzik: i.e. making -l work for perl 6 stuff

[18:59] * dukeleto dreams of typing prove -6 -rv t/

[19:00] <tadzik> dukeleto: you remember the first thing I mentioned as a desired feature for panda? :)

[19:01] *** wamba left
[19:01] <dukeleto> tadzik: indeed.

[19:02] <dukeleto> tadzik: that panda should be able to run tests? or just removing the prove dependency?

[19:02] <tadzik> removing the prove dependency. It can run tests now, it does :)

[19:03] <dukeleto> tadzik: yes, but you need Makefiles to run tests. Yuck.

[19:03] <tadzik> why so?

[19:03] <tadzik> I don't

[19:03] <dukeleto> tadzik: ufo && make test ?

[19:03] <dukeleto> tadzik: it requires makefiles, no?

[19:03] <tadzik> dukeleto: why would you need to use ufo?

[19:04] <tadzik> panda does not depend on ufo nor make

[19:04] <dukeleto> tadzik: how does one run panda tests without ufo, make or prove?

[19:05] <tadzik> ha, one doesn't. You need prove

[19:05] <tadzik> in a dreamworld you don't

[19:05] <dalek> roast: 270340f | moritz++ | S32-str/numeric.t:

[19:05] <dalek> roast: more Str -> Rat,Complex tests

[19:05] <dalek> roast: review: https://github.com/perl6/roast/commit/270340fbb8

[19:05] <dalek> nqp: 6a6285f | pmichaud++ | src/QRegex/P6Regex/Actions.nqp:

[19:05] <dalek> nqp: Remove some debugging output.

[19:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6a6285f0dc

[19:05] <dalek> nqp: 30ed7ec | pmichaud++ | src/ops/nqp.ops:

[19:05] <dalek> nqp: Add nqp_radix opcode for simplifying string->number conversions.

[19:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/30ed7ec0d5

[19:05] <dalek> nqp: 0eea302 | pmichaud++ | src/ops/nqp.ops:

[19:05] <dalek> nqp: Fix underscore bug in nqp_radix opcode.

[19:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0eea302ae6

[19:05] <dukeleto> tadzik: sure. So if you want to remove the prove dependency, what do you replace it with? It seems like a TAP::Harness for Perl 6 is needed

[19:05] <tadzik> aye

[19:06] <dukeleto> tadzik: we have a TAP::Harness in parrot, so rakudo benefits from that, but other Perl 6 implementations don't

[19:06] <tadzik> maybe we could reuse parrot's TAP::Harness

[19:06] <tadzik> or we may want a pureperl6 harness

[19:06] *** ng1962 left
[19:06] <[Coke]> pmichaud: something like https://github.com/partcl/partcl/blob/master/runtime/tcllib.pir#L338 will work.

[19:06] <dukeleto> tadzik: sure. that would be much nicer. It feels wrong to know that we have TAP::Harness implemented at the VM level, but it would need to be rewritten at a higher level to be useful for Perl 6 implementation other than Rakudo

[19:07] <tadzik> that doesn't sound too hard to do

[19:07] *** cipherte1t joined
[19:07] *** Jackneill left
[19:07] <pmichaud> [Coke]++  # thanks

[19:07] <dukeleto> tadzik: here is my version of TAP::Harness in PIR: https://github.com/leto/tapir

[19:07] *** ciphertext left
[19:07] <dukeleto> tadzik: it at least has some tests that you can steal

[19:08] <dukeleto> tadzik: beware, it was last developed on parrot 1.8.0, so it is composting

[19:09] * dukeleto likes to say composting instead of bitrotting. It is closer to reality, where old code provides mental nutrients for coders to write new code

[19:09] <tadzik> I'll cover me nose

[19:09] <tadzik> but for now, I'm gone :) see you later

[19:14] *** cooper joined
[19:14] *** cooper left
[19:14] *** cooper joined
[19:15] <[Coke]> in general, I can't see perl6 really taking advantange of things written in PIR.

[19:15] <slavik> I agree

[19:15] <slavik> wait, [Coke], what do you mean?

[19:18] <dalek> roast: 0aa6858 | moritz++ | S32-str/numeric.t:

[19:18] <dalek> roast: more Str -> Complex conversion tests

[19:18] <dalek> roast: review: https://github.com/perl6/roast/commit/0aa6858eec

[19:19] *** Trashlord left
[19:19] <moritz> 131 tests for Str.Numeric

[19:20] <pmichaud> cool, I'm writing up a version now.

[19:20] *** Trashlord joined
[19:20] <moritz> ok, what type should +'Inf' return?

[19:20] <moritz> Num? Int?

[19:20] <TimToady> er...Cool?

[19:21] <moritz> then Cool would need storage

[19:21] <pmichaud> It could just be a defined type.

[19:22] * TimToady thinks about Inf as a role

[19:23] <moritz> should +'' also fail? (just to be sure)

[19:23] <[Coke]> slavik: well, rakudo, specifically, obviously; but I don't think the perl6 community gets a lot of bang using .net or parrot specific functionality. Seems like it would have to be something pretty specific to the machine to make it worthwhile.

[19:24] <TimToady> moritz: we don't require a leading 0 on any other number, so why do we require one on '0'?  :)

[19:25] <dalek> niecza: 4fc3649 | sorear++ | lib/CLRBackend.cs:

[19:25] <dalek> niecza: Implement labels and multisubs for protopad use

[19:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4fc36494d8

[19:25] <moritz> TimToady: because we don't parse +   as +0 :-)

[19:25] <[Coke]> ... ew.

[19:25] <moritz> TimToady: I'd be fine with numifying the empty string to 0, just want to know

[19:26] <sorear> TimToady: I think Inf is an antirole

[19:26] <TimToady> it's more of a failure

[19:26] <sorear> TimToady: Int ~~ Numeric but Inf ~~ Int

[19:26] <sorear> the order of subtyping is reversed from the regular roles

[19:26] <TimToady> .o(interesting values of 'bottom')

[19:27] <sorear> I imagine you've already thought about this, since you talked about "Failure roles"

[19:27] <sorear> how does Failure ~~ Int come to be true, implementationally speaking?

[19:29] <TimToady> I think of it as Failure getting mixed in, so Int is a parent

[19:29] <masak> pmichaud: I once found a million-character string that Perl 5 choked on but Rakudo/PGE could handle just fine (but slowly).

[19:29] <sorear> how does Failure know to do that?

[19:30] <masak> Failure but Int but Num but Rat but Str... # p'haps not...

[19:31] <masak> sorear: could you say a bit more about the concept of an 'antirole'?

[19:32] <TimToady> that's backwards, it'd be Int but Failure

[19:32] <masak> ah, but of course.

[19:32] <TimToady> like the typical jazz musician: Cool but Failure

[19:32] <masak> :P

[19:33] <sorear> masak: my Numeric $x = Int works because Numeric is a role.  my Int $x = Failure  is required to work, so Failure must be the opposite of a role

[19:33] *** wamba joined
[19:33] <sorear> I don't actually know how this is supposed to work

[19:33] <sorear> it might not even make any sense

[19:33] <TimToady> what about Int but Failure doesn't make sense?

[19:33] <masak> seems Failure would be the only such entity, though.

[19:34] <slavik> [Coke]: rakudo can't load .pir at the moment :(

[19:34] <TimToady> Failure would just be 'bottom'-colored paint

[19:34] <sorear> masak: my Int $x = Inf; my Num $x = Inf

[19:34] <sorear> masak: NaN, too

[19:34] <masak> sorear: oh! true! they're like "small bottoms".

[19:34] <masak> local bottoms.

[19:34] <TimToady> Inf and NaN would likely be considered defined bottoms

[19:35] <TimToady> perl6: say Inf.defined

[19:35] <sorear> TimToady: the process by which "Failure" promotes itself to "Int but Failure" is ill-defined and might turn out to be undefinable

[19:35] <p6eval> rakudo b4486e, niecza v7-35-g4fc3649: OUTPUT«Bool::True␤»

[19:35] <p6eval> ..pugs: OUTPUT«1␤»

[19:35] <dalek> roast: b29fccf | sorear++ | S (2 files):

[19:35] <dalek> roast: S32-num/power, S12-class/lexical: refudge tests for niecza

[19:35] <dalek> roast: review: https://github.com/perl6/roast/commit/b29fccfff5

[19:35] <moritz> TimToady: so, +'' == 0 ?

[19:36] <TimToady> I think that's probably relatively harmless, and likely to be the proper degenerate case for certain algorithms

[19:36] <PerlJam> Also very Perl5y

[19:37] <PerlJam> (in a good way IMHO)

[19:37] <TimToady> I was somewhat serious about the funny exception that 0 requires a leading 0

[19:37] * masak .oO( if there were a prefix:<*>, *'' would be 1... )

[19:38] <TimToady> perl6: say [*] ''.comb

[19:38] *** Holy_Cow joined
[19:38] <p6eval> pugs, rakudo b4486e: OUTPUT«1␤»

[19:38] <p6eval> ..niecza v7-35-g4fc3649: OUTPUT«0␤»

[19:38] <TimToady> ooh, nieczabug

[19:38] <sorear> (niecza is broken here, not making a statement)

[19:39] <dalek> roast: 220b45a | moritz++ | S (2 files):

[19:39] <dalek> roast: shuffle numification tests, and move one to S32-str/numeric.t

[19:39] <dalek> roast: review: https://github.com/perl6/roast/commit/220b45a754

[19:39] <dalek> roast: 2a981f3 | moritz++ | S (2 files):

[19:39] <dalek> roast: remove duplicate Str -> Numeric tests, move others to numeric.t

[19:39] <dalek> roast: review: https://github.com/perl6/roast/commit/2a981f3b65

[19:39] *** felliott joined
[19:39] <masak> rakudo: our sub prefix:<*>($n) { [*] $n }; say *''

[19:39] <p6eval> rakudo b4486e: OUTPUT«0␤»

[19:40] <masak> rakudo: our sub prefix:<*>($n) { $n || 1 }; say *''

[19:40] <p6eval> rakudo b4486e: OUTPUT«1␤»

[19:41] <felliott> Good aftersomething, #perl6!

[19:41] <masak> felliott, happy greetings!

[19:41] <felliott> hey, masak!

[19:41] <TimToady> Good beforechristmas!

[19:41] <masak> enjoy your afternovember!

[19:42] <felliott> Have a nice betwixtevents!

[19:42] <masak> :P

[19:42] <felliott> rakudo: ?{say "mooo";};

[19:42] * masak .oO( between transitions )

[19:42] <p6eval> rakudo b4486e:  ( no output )

[19:42] <masak> felliott: not an immediate block.

[19:43] <felliott> Should blocks be eval'd in boolean context?

[19:43] <masak> nope.

[19:43] <felliott> ah-ha!

[19:43] <masak> rakudo: ?{say "mooo"}()

[19:43] <p6eval> rakudo b4486e: OUTPUT«mooo␤»

[19:43] <masak> rakudo: say ?{say "mooo"}()

[19:43] <p6eval> rakudo b4486e: OUTPUT«mooo␤Bool::True␤»

[19:44] <felliott> rakudo: if {say "moo"; 0;}() && {say "grr";}() { say "yay"; } else { say "boo"; }

[19:44] <p6eval> rakudo b4486e: OUTPUT«moo␤boo␤»

[19:45] <felliott> cool.

[19:46] <TimToady> nom: my $x = 42; $x //= say "oops, didn't short circuit"

[19:46] <p6eval> nom: OUTPUT«oops, didn't short circuit␤»

[19:46] <TimToady> nom: my $x = 42; $x = $x // say "oops, didn't short circuit"

[19:46] <p6eval> nom:  ( no output )

[19:46] <dalek> roast: 9dc48a0 | moritz++ | S (2 files):

[19:46] <dalek> roast: move tests for Inf and NaN Str.Numeric

[19:46] <dalek> roast: review: https://github.com/perl6/roast/commit/9dc48a057e

[19:47] <dalek> roast: e49f7bb | moritz++ | S03-operators/context-forcers.t:

[19:47] <dalek> roast: fix plan

[19:47] <dalek> roast: review: https://github.com/perl6/roast/commit/e49f7bb486

[19:47] <TimToady> assign metaop needs to be transparent to thunkification

[19:49] <moritz> it's sentences like that that make me think I never learned English :-)

[19:51] *** spq1 joined
[19:51] <PerlJam> moritz: it's just jargon.  Words like "transparent" suddenly become highly specialized and when mixed with made-up words like "thunkification",  you suddenly don't know what anyone is saying  :-)

[19:52] *** mtk left
[19:53] *** bluescreen10 left
[19:53] <felliott> I'm still working on flipflop, and I've updated flip-flop.t.  Can I push to roast or will that goof up nom?

[19:54] <moritz> felliott: you can

[19:54] <felliott> flipflop.t is still commented out in spectest.data

[19:54] <felliott> thanks, moritz

[19:54] <moritz> felliott: I hope you're working on the flipflop implementation in nom?

[19:54] <felliott> no, currently in master.

[19:55] <felliott> After I get master done, I'd update it to nom,

[19:55] <TimToady> I don't believe there's anything in the test suite that actually checks that //= short circuits

[19:55] <TimToady> that's LHF for someone

[19:55] <moritz> 244:   for @array1 { .key //= ++$i }

[19:55] <moritz> in S04-statements/for.t

[19:55] <TimToady> in a comment

[19:55] <TimToady> or a string

[19:56] <TimToady> unless I'm out of date

[19:56] * moritz just ack'ed, could very well be in a comment

[19:57] <TimToady> oh, okay, new version is different

[19:57] *** mtk joined
[19:58] <sorear> how many spectests does nom currently pass?

[19:58] <moritz> ~7k

[19:58] <TimToady> funny it says rakudo doesn't implement [+]

[19:59] *** mj41 joined
[19:59] <dalek> roast: 4213c39 | moritz++ | S (2 files):

[19:59] <dalek> roast: move some tests out of numeric-context.t, and delete the file (the tests are now in S32-str/numeric.t

[19:59] <dalek> roast: review: https://github.com/perl6/roast/commit/4213c393a7

[20:00] <TimToady> still, that's not the right file to be testing //= in

[20:00] <moritz> agreed

[20:01] <dalek> roast: 3f8b669 | (Fitz Elliott)++ | S03-operators/flip-flop.t:

[20:01] <dalek> roast: [S03/flip-flop] rewrite flip-flop tests

[20:01] <dalek> roast: review: https://github.com/perl6/roast/commit/3f8b669423

[20:01] <TimToady> nap &

[20:04] <dalek> rakudo/nom: f7e4cec | moritz++ | src/Perl6/Actions.pm:

[20:04] <dalek> rakudo/nom: (re-)introduce radcalc, but smarter than before

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7e4cecfbf

[20:04] <dalek> rakudo/nom: 64fe676 | moritz++ | src/Perl6/Actions.pm:

[20:04] <dalek> rakudo/nom: allow arbirary number of trailing zeros. Wins back the few tests that the previous commit regressed

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/64fe6768a7

[20:04] <dalek> rakudo/nom: 8097419 | moritz++ | src/Perl6/Actions.pm:

[20:04] <dalek> rakudo/nom: hopefully speed up stripping of trailing zeros

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/80974191c5

[20:04] <dalek> rakudo/nom: 09a43b7 | moritz++ | src/Perl6/Actions.pm:

[20:04] <dalek> rakudo/nom: remove (mostly PIR) functions that are now mostly unused

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/09a43b7f1f

[20:04] <dalek> rakudo/nom: e939a8b | moritz++ | src/Perl6/Actions.pm:

[20:04] <dalek> rakudo/nom: get :16<DEAD_BEEF> style literals working

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e939a8bee9

[20:04] <dalek> rakudo/nom: 01df600 | moritz++ | src/Perl6/ (2 files):

[20:04] <dalek> rakudo/nom: refactor numeric constants to do the PAST::Want magic in a single place

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/01df600ad2

[20:04] <dalek> rakudo/nom: 9c93942 | moritz++ | src/Perl6/ (2 files):

[20:04] <dalek> rakudo/nom: Merge branch 'nom-num' into nom

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9c93942a59

[20:04] <dalek> rakudo/nom: 76d6591 | moritz++ | t/spectest.data:

[20:04] <dalek> rakudo/nom: remove testfile from spectest.data, because it is gone from roast

[20:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/76d6591bb3

[20:05] *** bluescreen10 joined
[20:05] <dalek> roast: 881b41e | moritz++ | S03-operators/short-circuit.t:

[20:05] <dalek> roast: test that //= and ||= short-circuit, TiimToady++

[20:05] <dalek> roast: review: https://github.com/perl6/roast/commit/881b41e617

[20:06] *** mtk left
[20:07] <moritz> felliott: fwiw, currently rakudo master currently checks out a specific revision of the tests

[20:07] *** y3llow left
[20:07] *** pothos left
[20:08] <moritz> felliott: I guess the easist way to get new tests into master is to make a branch is roast, and use that

[20:09] *** mtk joined
[20:09] * moritz does that

[20:09] *** y3llow joined
[20:09] *** pothos_ joined
[20:10] <dalek> roast/rakudo-master: eb0e2b9 | (Fitz Elliott)++ | S03-operators/flip-flop.t:

[20:10] <dalek> roast/rakudo-master: [S03/flip-flop] rewrite flip-flop tests

[20:10] <dalek> roast/rakudo-master: review: https://github.com/perl6/roast/commit/eb0e2b9f5d

[20:10] *** pothos_ is now known as pothos

[20:12] <felliott> Nice!  Thanks, moritz++!

[20:14] <moritz> there you go...

[20:14] <dalek> rakudo: 1ddda5e | moritz++ | build/Makefile.in:

[20:14] <dalek> rakudo: track branch rakudo-master of the roast repository

[20:14] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/1ddda5e4cd

[20:20] *** Holy_Cow left
[20:21] <moritz> enough test hacking for now

[20:21] <felliott> Here is my second take at flipflop-as-macro, built off of pmichaud++'s code from 2011-07-04

[20:21] *** Vlavv` left
[20:21] <felliott> https://github.com/felliott/rakudo/commit/b4ce84a00c8

[20:21] <felliott> I had to complicate it a lot to get all the cases to work, but it's still about 40 lines shorter than my original version.

[20:21] <felliott> Plus, it's a lot more correct!

[20:22] *** kaare__ left
[20:27] <felliott> I wrote some pir (line 2486) to save the state, but I'm not confident in it.  Does it look reasonable?

[20:28] <sorear> felliott: does it work?

[20:29] <felliott> yep.

[20:29] <sorear> felliott: I'm suprised you have so much code in the actions there.

[20:29] *** impious left
[20:29] <sorear> I would have expected most of the logic to be in src/builtins somewhere

[20:30] <felliott> handling the excluders and the sedlike flags complicate things a bunch.

[20:30] <PerlJam> sedlike?

[20:31] <felliott> fff won't flip and flop on the same input (like sed)

[20:31] <PerlJam> oh

[20:32] <felliott> sorear: src/builtins are for classes, right?

[20:32] *** Vlavv` joined
[20:33] <PerlJam> felliott: you're checking the symbol twice as much, once to call make_flipflop and then once again inside make_flipflop

[20:34] <PerlJam> felliott: perhaps you could pass $excl_lhs, $excl_rhs, $sedlike as parameters to make_flipflop ?

[20:34] <felliott> ooh, good point.  I can compress that.

[20:37] *** Vlavv` left
[20:38] <felliott> hmm, that would mean 8 elsifs inside method EXPR($/).  Wouldn't it be better to keep the EXPR logic shorter and accept the repeated eqs?

[20:40] *** Mowah left
[20:40] <sorear> felliott: what will your code do with, say, [ff]?

[20:41] <dalek> panda: ae46ebc | dukeleto++ | README.md:

[20:41] <dalek> panda: Add a note to the readme about needing a recent TAP::Harness

[20:41] <dalek> panda: review: https://github.com/tadzik/panda/commit/ae46ebc153

[20:41] *** tokuhir__ joined
[20:41] <felliott> Not sure.

[20:41] <felliott> I just realcleaned, rebuilding now.

[20:41] <pmichaud> we'll need an &infix:<ff> sub as well.

[20:42] <pmichaud> to handle the reduction cases.

[20:42] <pmichaud> same as we do for [||] and [&&]

[20:44] <felliott> Ah, I hadn't considered that at all.  Let me give it a whack.

[20:45] * moritz doesn't think that's important at all for now

[20:45] <pmichaud> the &infix:<ff> sub ought to be as easy to do as the &infix:<||> and &infix:<&&> subs are.  And I agree it's not important for the first cut.

[20:45] <moritz> I'm not even sure that a reduction metaop makes sense for an operator that keeps state internally

[20:45] *** im2ee_ joined
[20:46] <moritz> if you have  [ff] @a  inside a loop where the length of @a varies

[20:46] <sorear> felliott: for 0,1 { sub has_flop($x) { True ^ff False }; say has_flop() }

[20:46] <sorear> # ?

[20:46] <moritz> what happens? is a separate state kept for each position?

[20:47] <moritz> sorear: signature binding error

[20:47] <PerlJam> yeah, you'd need +@a - 1 state vars

[20:47] <sorear> erp

[20:47] <sorear> felliott: for 0,1 { sub has_flop() { True ^ff False }; say has_flop() }

[20:47] <sorear> # ?

[20:47] <moritz> PerlJam: but +@a isn't even constant

[20:47] <PerlJam> for each iteration

[20:48] <sorear> probably better to forbid ff-derived operatorsa

[20:48] <moritz> so... the state vanishes between iterations? then what's the point of having state inside the operator?

[20:48] * moritz agrees with sorear

[20:48] <felliott> not sure (and still building)

[20:49] *** im2ee left
[20:50] <sorear> in Perl 5, the ff operator uses an ordinary lexical variable to track state

[20:50] <PerlJam> scoped to what?

[20:51] <sorear> the sub

[20:52] <sorear> it might be closer to a state var

[20:52] *** Vlavv` joined
[20:52] <sorear> but it probably doesn't share between recursive levels, and it definitely doesn't share between clones of a closure

[20:52] *** LoRe left
[20:52] <sorear> which is what I was showing felliott 

[20:52] <sorear> felliott's implemention keeps state in GLOBAL::

[20:52] <sorear> which might be wrong

[20:53] <sorear> S02 doesn't say a whole lot about fff

[20:54] <sorear> looks like TimToady specified 'state' semantics in Nov05

[20:54] <felliott> sorear: my code uses the same state for both invocations

[20:56] <felliott> wrt for 0,1 { sub has_flop() { True ^ff False }; say has_flop() }

[20:56] *** LoRe joined
[20:56] *** ng1962 joined
[20:57] <moritz> pugs: say True ^ff False

[20:57] <p6eval> pugs: OUTPUT«*** No such subroutine: "&ff"␤    at /tmp/fEeEw4N6QL line 1, column 5 - line 2, column 1␤»

[20:57] <moritz> pugs: say True ff False

[20:57] <p6eval> pugs: OUTPUT«*** No such subroutine: "&infix:ff"␤    at /tmp/fpAbMDf4LH line 1, column 5 - line 2, column 1␤»

[20:57] <sorear> pugs: say True till False

[20:57] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "till"␤    expecting "=", "(", ":", operator or ","␤    at /tmp/YZ2TOFnLrQ line 1, column 10␤»

[20:58] <sorear> felliott: I'll add a test for that then

[21:02] *** spq1 left
[21:05] *** soh_cah_toa joined
[21:05] <felliott> rakudo: for 0,1 { sub has_flop() { say "moo"; }; has_flop() };

[21:05] <p6eval> rakudo 1ddda5:  ( no output )

[21:05] <felliott> why doesn't it say moo?

[21:07] *** ng1962 left
[21:07] <felliott> rakudo: for 0,1 { say "moo"; };

[21:07] <p6eval> rakudo 1ddda5: OUTPUT«moo␤moo␤»

[21:07] <felliott> rakudo: for 0,1 { say "moo"; sub hello() { say "hello"; }; };

[21:07] <p6eval> rakudo 1ddda5:  ( no output )

[21:09] <moritz> rakudo: say 1

[21:09] <p6eval> rakudo 1ddda5: OUTPUT«1␤»

[21:09] <moritz> felliott: you need the colon after 'rakudo'

[21:10] <felliott> ?

[21:10] <moritz> sorry, I can't read anymore

[21:10] <moritz> I should go to bed

[21:11] <moritz> rakudo: for 0, 1 { say $_ }

[21:11] <p6eval> rakudo 1ddda5: OUTPUT«0␤1␤»

[21:11] <felliott> bed sounds nice.

[21:11] <moritz> rakudo: for 0, 1 { say "moo"; sub hello() { say "hello"; }; }

[21:11] <p6eval> rakudo 1ddda5:  ( no output )

[21:11] <moritz> rakudo: for 0, 1 { say "moo"; }

[21:11] <p6eval> rakudo 1ddda5: OUTPUT«moo␤moo␤»

[21:11] * moritz wonders if he or rakudo is WTFy here

[21:12] <felliott> any idea what x_enter_sublog is?  It shows up in the pir.

[21:12] <PerlJam> looks like a rakudo context mishap

[21:12] <felliott> I'm grepping through parrot now.

[21:12] <pmichaud> x_enter_sublog is a rakudo opcode for keeping track of sub entry

[21:12] <[Coke]> doesn't sound like a parrot thing.

[21:13] <[Coke]> pmichaud++

[21:13] <pmichaud> it's been around for a while, so it's not likely the culprit

[21:13] <sjn> moritz: did you intend to call hello() there?

[21:13] <PerlJam> rakudo: for 0, 1 { sub hello() { say "hello"; }; say "moo" }

[21:13] <p6eval> rakudo 1ddda5:  ( no output )

[21:14] <felliott> curses.  it had proximity in it's favor.

[21:14] <sorear> perl6: for 0, 1 { sub hello() { say "hello"; }; say "moo" }

[21:14] <p6eval> niecza v7-35-g4fc3649: OUTPUT«Potential difficulties:␤  &hello is declared but not used at /tmp/GdZNEUDP0V line 1:␤------> [32mfor 0, 1 { sub hello[33m⏏[31m() { say "hello"; }; say "moo" }[0m␤␤moo␤moo␤»

[21:14] <p6eval> ..rakudo 1ddda5:  ( no output )

[21:14] <p6eval> ..pugs: OUTPUT«moo␤moo␤»

[21:14] <dalek> roast: c1ee42c | sorear++ | S03-operators/flip-flop.t:

[21:14] <dalek> roast: Test "state" semantics of ff, $x ff * handling

[21:14] <dalek> roast: review: https://github.com/perl6/roast/commit/c1ee42cdd3

[21:15] <sorear> I think niecza's result is the most awesome one here.

[21:15] <PerlJam> niecza++  indeed  :)

[21:15] <pmichaud> I don't know why rakudo is having trouble with that.

[21:16] <PerlJam> I bet --target=PAST would show it.

[21:16] <PerlJam> (or at least give good clue)

[21:16] <pmichaud> clue: 

[21:17] * sjn neverminds

[21:17] <lichtkind> TimToady: did you looked into the concept of a channel in Go ?

[21:17] <pmichaud> rakudo:  for 0,1 { sub hello() { say 'hello'; }; say 'moo'; };  say 'alive';

[21:17] <p6eval> rakudo 1ddda5: OUTPUT«alive␤»

[21:17] <pmichaud> so, it's not dying.

[21:18] <pmichaud> I'm guessing it's a problem with lexicals somewhere.

[21:20] <PerlJam> lexicals?  how so?

[21:21] *** mkramer joined
[21:21] *** mkramer left
[21:21] <felliott> How can I run the pir generated by target=pir?

[21:21] <felliott> I'd like to sprinkle some "say"s in there and rerun it.

[21:21] <PerlJam> I was thinking it was a context problem.  The sub declaration is in void (or whatever) context and that got mis-propagated to the for loop

[21:24] <pmichaud> felliott: not currently possible in master, I don't think.

[21:25] <felliott> drat

[21:26] <felliott> nom: for 0,1 { sub hello() { say 'hello'; }; say 'moo'; };  say 'alive';

[21:26] <p6eval> nom: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤current instr.: '_block1010' pc 433 ((file unknown):156) (/tmp/7D3BisFsrN:1)␤»

[21:29] *** mj41 left
[21:38] *** wolfman2000 left
[21:42] *** wamba left
[21:43] *** Psyche^ joined
[21:46] <felliott> rakudo: say "before"; my $a = 2; while $a-- { say "woof"; sub hello() { say "hello";}; }; say "alive";

[21:46] <p6eval> rakudo 1ddda5: OUTPUT«before␤woof␤woof␤alive␤»

[21:47] *** Patterner left
[21:47] *** Psyche^ is now known as Patterner

[21:49] <felliott> rakudo: ./perl6 -e 'say "before"; for 0,1 -> $a { say "woof"; sub hello() { say "hello";}; }; say "alive";'

[21:49] <p6eval> rakudo 1ddda5: OUTPUT«===SORRY!===␤Confused at line 22, near "./perl6 -e"␤»

[21:49] <felliott> rakudo: say "before"; for 0,1 -> $a { say "woof"; sub hello() { say "hello";}; }; say "alive";

[21:49] <p6eval> rakudo 1ddda5: OUTPUT«before␤woof␤woof␤alive␤»

[21:50] *** drbean joined
[21:53] <TimToady> std: [ff] 1,2,3

[21:53] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Can't reduce with ff because conditional operators are too fiddly at /tmp/_Q84S6lEPP line 1:␤------> [32m[ff][33m⏏[31m 1,2,3[0m␤Check failed␤FAILED 00:01 120m␤»

[21:53] <TimToady> that's what I thought...

[21:56] <TimToady> lichtkind: yes, they're basically just named message queues

[21:56] <lichtkind> TimToady: so far i undersand yes but i like the concept

[21:56] <TimToady> it's not clear we want to tie message sending that closely with the function interface in p6 though

[21:56] <TimToady> much like we detangled coroutines from functions, I'd like to keep feeds separate too

[21:57] <TimToady> it's not clear whether ==> my @queue serves the same purpose

[21:57] <TimToady> or my @queue ==>

[21:58] <lichtkind> hej i thought almost the same way about ===> :)

[21:58] <TimToady> we might want something a bit more declarey to create a "real" channel

[21:58] <lichtkind> the syntax in go sucked a bit but the functional simplicity sttrikes

[21:59] <TimToady> certainly we want to be able to end an event queue in a multi dispatch

[22:00] <TimToady> also maybe need to think about how the endpoint of a feed can handle events serially or parallely

[22:01] <TimToady> the latter might just be a hyper feed

[22:03] <TimToady> the interesting thing about the typical feed op is that it turns a noun (the list) into a verb (the operator), which tends to make one think inside out

[22:03] <lichtkind> they solved that my an additional keyword a kind of switch statemend which whom you knot these things together

[22:04] <TimToady> I think we might just get it all to fall out of available concepts in p6

[22:04] <lichtkind> im not shure i got the ladder half of the last sentence

[22:04] <lichtkind> with the inside out

[22:05] <lichtkind> so its no topic for perl 6?

[22:05] <TimToady> ordinary you can't treat the @list of push @array, @list as a verb

[22:06] <TimToady> but with @list ==> push @array, the feed looks like an infix

[22:06] <TimToady> which, as an operator, is a kind of verb idea

[22:07] <lichtkind> so far i got it :)

[22:07] <lichtkind> even at the first time :)

[22:07] *** cipherte1t left
[22:07] *** ciphertext joined
[22:07] *** mkramer joined
[22:08] <TimToady> it's hard to say a concept like X==> when the lazy list remains simply an argument to push

[22:08] *** masak left
[22:08] <TimToady> though maybe X doens't make much sense, just as it doesn't with assignment

[22:10] <TimToady> anyway, if { ... } ==> &eventloop

[22:10] <TimToady> then I suspect eventloop is dispatched each event

[22:10] <TimToady> and eventloop can be a multi

[22:11] <TimToady> eventloop functions something like a go routine here

[22:12] <TimToady> with lazy semantics, the feed doesn't run another instance of eventloop until the previous one finishes

[22:12] <TimToady> and requests a new one

[22:13] <TimToady> or may that's just eager

[22:13] <sorear> should I be paying attention to this?

[22:13] <TimToady> but hyper would fire off a bunch of eventloops in parallel

[22:13] <TimToady> sorear: maybe, it's just some longterm brainstorming

[22:14] <TimToady> that is, something I've been mulling for a long time

[22:15] <TimToady> anyway, I think firing off parallel event handlers probably falls out of hyper

[22:15] *** im2ee_ left
[22:15] *** felliott left
[22:16] <TimToady> and named channels probably comes from naming ==> endpoints with functions

[22:16] <TimToady> if that's not too confusing

[22:16] <lichtkind> i was thinking about because i prepare a talk about new langs la go factor and rebol and how new there ideas really are and how it compares to perl 5/6

[22:17] <TimToady> there may be special status for block components of feeds too

[22:17] *** mkramer left
[22:17] <TimToady> {...} ==> {...} ==> {...} considered akin to a Unix shell pipeline

[22:17] <lichtkind> i would think so

[22:18] <TimToady> esp with respect to not sharing innards easily

[22:18] <TimToady> assumed async

[22:18] <TimToady> and private

[22:18] <TimToady> probably with a lexical barrier looking outward, in addition to the usual inward looking barrier

[22:18] * sorear is dubious of anything that requires the compiler to modify variable lookup semanticx

[22:19] <TimToady> async itself might need such discipline

[22:19] <sorear> runtime, I mean

[22:19] <TimToady> "You used a lexical from outside this thread; please confirm."   :)

[22:20] <TimToady> otherwise we probably have to slap locks around shared lexicals

[22:20] <sorear> uh, &infix:<+> is a shared lexical

[22:21] <sorear> and what about $GLOBAL::x?

[22:21] *** whiteknight joined
[22:23] *** mkramer joined
[22:25] *** cipherte1t joined
[22:27] *** ciphertext left
[22:27] <lichtkind> TimToady: thank you for the thought so far i might write when ideas should appears some about that :)

[22:32] <lichtkind> i just liked the concept to make it ease to write code thay runs if something happens or make it simple to ask a slot if a value arrived

[22:36] *** dual left
[22:36] *** dorlamm joined
[22:36] *** wolfman2000 joined
[22:37] *** felliott joined
[22:39] *** dual joined
[22:40] *** masak joined
[22:44] <felliott> sorear: I just tried your new flipflop test in p5 and got a different answer (xBCABC).

[22:45] <felliott> I think p5 is reusing the ff, too.

[22:47] <masak> TimToady: re http://rosettacode.org/wiki/Pythagorean_triples#Perl_6 , I am happy to see you are also enjoying subs-in-subs and "passing" things through lexical scopes instead of as parameters. very Lisp-y, in a way.

[22:47] *** am0c left
[22:48] * lichtkind listens to http://www.youtube.com/watch?v=ju1IMxGSuNE&feature=relmfu :)

[22:48] <felliott> sorear: nevermind, didn't realize p5 had different sub scoping rules.

[22:51] <masak> OTOH, every time I see complex numbers being used as 2-tuples (as opposed to being used for their properties as complex numbers), I sigh inwards and wonder if a dedicated tuple type would not be preferable.

[22:53] *** whiteknight left
[22:53] *** whiteknight joined
[22:54] *** cognominal_ is now known as cognominal

[22:55] <dukeleto> here are the slides from my talk about perl 6 modules yesterday : https://github.com/leto/presentations/blob/master/2011/intro_to_perl6_modules/pres.pdf (click 'view raw' for the pdf)

[22:56] <pmichaud> > say (+"1.2").WHAT

[22:56] <pmichaud> Rat()

[22:56] <pmichaud> > say (+'1').WHAT

[22:56] <pmichaud> Int()

[22:56] <masak> pmichaud: \\\ooo///

[22:56] <pmichaud> > say (+'1.25e4').WHAT

[22:56] <pmichaud> Num()

[22:56] <masak> how I've waited! :D

[22:57] <pmichaud> > say (+'0xff').WHAT

[22:57] <pmichaud> Int()

[22:57] *** whiteknight left
[22:57] <dalek> nqp: 134720b | pmichaud++ | src/ (2 files):

[22:57] <dalek> nqp: Add a few more useful option flags to nqp_radix opcode.

[22:57] <dalek> nqp: review: https://github.com/perl6/nqp/commit/134720b114

[22:57] *** whiteknight joined
[22:57] <pmichaud> now let's see how many spectests break :)

[22:58] <masak> heh. :)

[22:58] <benabik> All of them.

[22:58] <benabik> I meant none.  Obviously.

[22:58] <pmichaud> quite a lot, actually.

[22:59] <sorear> What was the old semantics?

[22:59] <masak> I've been trying out what it's like to practice does-based OO in Perl 6. so far: it's working surprisingly well. the only thing I miss being able to do is override methods. but it's usually not necessary.

[22:59] <pmichaud> the spec semantics haven't changed... rakudo has never gotten it right

[23:00] <pmichaud> (until now :)

[23:00] <masak> rakudo: say (+"42").WHAT

[23:00] <p6eval> rakudo 1ddda5: OUTPUT«Num()␤»

[23:00] <sorear> What were Rakudo's old semantics?

[23:00] <pmichaud> ^^^^

[23:00] <masak> sorear: see above.

[23:00] <sorear> rakudo: say (+"1/2").perl

[23:00] <masak> sorear: (always Num)

[23:00] <p6eval> rakudo 1ddda5: OUTPUT«1␤»

[23:01] <pmichaud> I think I'll go ahead and commit this fix and then others can help me fix the spectest breakages

[23:01] *** Kivutarrr left
[23:03] <masak> +1

[23:03] <pmichaud> especially since I'll likely have to leave in a few minutes

[23:03] <pmichaud> I'm just verifying the build before pushing the commits.

[23:04] <pmichaud> (don't want to push a broken build :)

[23:05] *** soh_cah_toa left
[23:08] <dalek> rakudo/nom: 3cf23af | pmichaud++ | / (3 files):

[23:08] <dalek> rakudo/nom: Update Str.Numeric to be a lot more correct.  Numifying strings now

[23:08] <dalek> rakudo/nom: tend to return Int/Rat/Num instead of always being a Num.  This

[23:08] <dalek> rakudo/nom: code is intended to handle the common cases; uncommon cases are

[23:08] <dalek> rakudo/nom: likely to ultimately be handled by the compiler somehow.

[23:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3cf23afdeb

[23:08] <pmichaud> also:

[23:08] <pmichaud> > say +"1 and other stuff besides"

[23:08] <pmichaud> trailing characters after number

[23:09] <masak> std: if 42 {} elsif {}

[23:09] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Expression needs parens to avoid gobbling block at /tmp/Lu6hwCU9bE line 1:␤------> [32mif 42 {} elsif [33m⏏[31m{}[0m␤Missing block (apparently gobbled by expression) at /tmp/Lu6hwCU9bE line 1:␤------> [32mif 42 {} elsif {}[33m⏏[3…

[23:09] <masak> pmichaud: nice!

[23:10] <pmichaud> please feel free to start cleaning up spectests and/or reporting bugs.  I'll be back in a couple of hours.

[23:11] <TimToady> wow, the block was gobbled by the expression that isn't there :)

[23:11] <masak> yeah :)

[23:11] <masak> rakudo has the worse error, though:

[23:11] <masak> rakudo: if 42 {} elsif {}

[23:11] <p6eval> rakudo 1ddda5: OUTPUT«===SORRY!===␤Missing block at line 22, near ""␤»

[23:11] <masak> that is, "missing block" right after the block :(

[23:12] <TimToady> yes, STD used to produce that error too :)

[23:13] <TimToady> but missing blocks have to be reanalyzed just like ttiar

[23:13] <TimToady> std:  if 42 {} elsif 43

[23:13] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/hW3vi6nsuA line 1 (EOF):␤------> [32mif 42 {} elsif 43[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 118m␤»

[23:13] <TimToady> but sometimes it's just a missing block...

[23:14] <sorear> std: if 1 2

[23:14] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/WpnMGSJfGY line 1:␤------> [32mif 1 [33m⏏[31m2[0m␤    expecting any of:␤   bracketed infix␤        infix or meta-infix␤Parse failed␤FAILED 00:01 120m␤»

[23:14] <TimToady> std: if 1{}

[23:14] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/qqxdqCdS12 line 1 (EOF):␤------> [32mif 1{}[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 119m␤»

[23:15] <TimToady> std: if 1{} else {}

[23:15] <p6eval> std 516268a: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block at /tmp/dU505SmdBo line 1:␤------> [32mif 1{} [33m⏏[31melse {}[0m␤    expecting any of:␤   bracketed infix␤        infix or meta-infix␤Parse failed␤FAILED 00:01 121m␤»

[23:15] <TimToady> ah well

[23:16] <flussence> just curious, if anyone knows: what's the correct way to write «perl Configure.pl --parrot-option=--ccflags="$CFLAGS -g"»? Everything I've tried mangles it.

[23:21] *** zby_home_ left
[23:22] *** soh_cah_toa joined
[23:25] *** dorlamm left
[23:28] *** whiteknight left
[23:29] *** orafu left
[23:29] *** orafu joined
[23:32] *** bluescreen10 left
[23:34] <masak> the adventure game, now at 944 LoC, is now playable from beginning to end.

[23:35] <masak> I expect to write all the scene and object descriptions tomorrow, and make a few subsequent improvements to game "look and feel".

[23:35] <masak> after that, it would be nice to get a number of volunteers to play the game and give a few comments about it.

[23:36] <felliott> \o/

[23:36] <felliott> I'll give it a try, masak.

[23:36] <felliott> masak++, that is.

[23:36] <masak> yay

[23:37] <masak> http://github.com/masak/crypt

[23:37] <masak> due to the above, there are still lots of [Description of X] scattered everywhere. please disregard those.

[23:38] <masak> I'll be especially interested in commands you tried and expected to work.

[23:40] <felliott> you are eaten by a bug :) :  https://gist.github.com/1083733

[23:40] * masak looks

[23:41] <felliott> is this for nom or master?

[23:41] <masak> master.

[23:42] <felliott> good, that was master

[23:42] <masak> felliott: all of those are reasonable and should work. I'll make sure they do in the "next release" -- sometime tomorrow.

[23:42] <masak> thanks for the early feedback :)

[23:42] <masak> ooh, and then there's an actual bug! :)

[23:42] * masak fixes that one immediately

[23:43] <felliott> Also, I haven't played an  adventure game in ~20 years, so my verb expectations may be off.

[23:43] <masak> no, I think not.

[23:43] <masak> fwiw, 'examine' and 'x' work for now.

[23:44] <felliott> ah-ha!  examine I shall.

[23:47] <masak> felliott: pushed bug fix.

[23:47] <felliott> https://gist.github.com/1083745

[23:47] <felliott> I took the rope, and ended up with the flashlight too? 

[23:47] <felliott> pulling...

[23:47] * masak looks

[23:48] <masak> huh.

[23:49] <felliott> ah. there are two flashlights.

[23:49] <felliott> (just figured out "i")

[23:49] <masak> yeah.

[23:49] *** bluescreen10 joined
[23:49] <felliott> one in inventory and one in the car.

[23:49] <masak> pushed removal of that, too.

[23:49] <masak> I used that for debugging.

[23:49] <masak> sorry 'bout that :/

[23:49] <felliott> No worries!

[23:50] <felliott> This game comes with an adventure and a meta-adventure.

[23:50] <masak> ;)

[23:50] <felliott> how do I examine the tiny disk?

[23:50] <felliott> x disk & x tiny disk don't work

[23:50] <masak> good point -- will fix too.

[23:51] <masak> though it's not supposed to be with you now.

[23:51] *** jferrero left
[23:53] <dalek> niecza: 49322b4 | sorear++ | lib/ (2 files):

[23:53] <dalek> niecza: Use primitives for the other three ++-like cases

[23:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/49322b4725

[23:53] <dalek> niecza: 20310bc | sorear++ | / (2 files):

[23:53] <dalek> niecza: Implement flipflop operators

[23:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/20310bc88a

[23:53] *** wolfman2000 left
[23:54] <dalek> roast: f2fad85 | sorear++ | S03-operators/flip-flop.t:

[23:54] <dalek> roast: [S03-operators/flip-flop] Simplify and fix scoping

[23:54] <dalek> roast: review: https://github.com/perl6/roast/commit/f2fad85393

[23:55] *** Trashlord left
[23:56] <felliott> sorear++

[23:57] <felliott> flip-flop-fury!

[23:57] <felliott> masak: how many rooms are there?  I made it to the chamber, but I'm stuck.

[23:57] <masak> ooh, nice :)

[23:58] <masak> there are six rooms: clearing, hill, chamber, hall, cave, crypt.

