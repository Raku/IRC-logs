[00:00] *** Trashlord joined
[00:09] *** cooper joined
[00:14] <[Coke]> tadzik: (build before install) except I had already done a build. ;)

[00:20] *** [particle]1 joined
[00:21] *** [particle] left
[00:21] *** [particle]1 is now known as [particle]

[00:29] *** CBro2007 left
[00:41] *** [particle] left
[00:41] *** [particle] joined
[00:44] *** stepnem left
[00:46] *** tokuhir__ left
[00:47] *** stepnem joined
[01:03] *** woosley joined
[01:06] *** woosley left
[01:08] *** bluescreen100 joined
[01:44] *** woosley joined
[01:47] *** cooper left
[02:02] *** bluescreen__ joined
[02:28] *** bluescreen100 left
[02:28] *** bluescreen10 left
[02:28] *** LaVolta joined
[02:29] *** bluescreen__ left
[02:51] *** cooper joined
[03:01] *** uvtc joined
[03:10] *** am0c joined
[03:28] *** ilogger2 joined
[03:28] *** ChanServ sets mode: +v ilogger2

[03:33] <uvtc> TimToady: thanks. Hm. Will try to digest that. So, instead of using `tee`, maybe better to just do: `make 2>&1 > ~/temp/rakudo-make.log` ?

[03:35] <uvtc> TimToady: (seems to work fine)

[03:41] <sorear> no

[03:42] <sorear> 2>&1 >file will cause stderr to screen

[03:42] <sorear> it reads from left to right

[03:42] <sorear> start with 1:tty 2:tty

[03:42] <sorear> after 2>&1, 1:tty 2:tty (1 has been copied to 2 with no effect)

[03:42] <sorear> after >file, 1:file 2:tty

[03:43] <sorear> you need >file 2>&1, or >&file

[03:43] <sorear> pipes are the one case where it's not read left to right

[03:43] <sorear> you need  prog1 2>&1 | prog2 to send both to prog2

[03:43] <uvtc> sorear: Will try that out. Thank you!

[03:51] <uvtc> sorear: Sorry, was afk. Works. :) Thanks.

[04:05] *** satyavvd joined
[04:16] *** dju joined
[04:28] *** HarryS joined
[05:21] *** beek joined
[05:27] *** birdwindupbird joined
[05:31] *** im2ee joined
[05:31] *** im2ee left
[05:43] *** wtw joined
[05:45] *** thou joined
[05:45] *** molaf joined
[05:45] <Tene> sorear: itym &>file

[05:46] *** molaf left
[06:14] <sorear> Tene: no

[06:14] <moritz> good morning

[06:15] <sorear> I can no longer find the relevant log snippet, but last time I suggested &>file someone politely informed me that foo &>file  is interpreted like { foo& }; { >file } by many shells

[06:15] <sorear> and that >&file was the correct/works on not-bash-or-zsh way

[06:16] *** daxim joined
[06:23] <sorear> Tene: curious.  POSIX.1 doesn't list any form other than >x 2>&1

[06:23] <sorear> in particular, for 2>&word, behavior is "unspecified" unless word expands to a decimal number or "-"

[06:23] <sorear> s/2//

[06:29] <sorear> o/ moritz 

[06:32] *** kjeldahlw joined
[06:36] *** kjeldahlw left
[06:37] *** kjeldahlw joined
[06:43] <moritz> sorear: do you have an example of threads in niecza?

[06:44] *** kjeldahlw_ joined
[06:51] * sorear fiddles a bit

[06:52] <sorear> niecza: use Threads; my $p = Threads::ObjectPipe.new; for 1..3 { Thread.new({ $p.put($_) while 1 }) };   loop { state $old = -1; state $ct = 0; my $val = $p.get; if $val == $old { $ct++ } else { say "$old x $ct" if $old > 0; $ct=1; $old=$val } }

[06:52] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«(timeout)1 x 4616â¤2 x 4202â¤3 x 2970â¤1 x 1198â¤3 x 3037â¤2 x 1058â¤1 x 3791â¤3 x 3585â¤1 x 1130â¤2 x 2040â¤3 x 3442â¤2 x 2944â¤1 x 4877â¤2 x 4019â¤1 x 1299â¤3 x 4730â¤1 x 1938â¤2 x 1775â¤3 x 1039â¤1 x 3911â¤3 x 3663â¤2 x 3138â¤3 x 1053â¤1 x 2484â¤3 x 2411â¤2 x 4793â¤3 x 2551â¤1 x 4â€¦

[06:53] <TimToady> http://rosettacode.org/wiki/Calendar_-_for_%22real%22_programmers#Perl_6

[06:56] <sorear> TimToady: I think you forgot to save

[06:57] <TimToady> don't think so

[06:58] <benabik> sorear: It seems to take a moment to update.  If you click too fast you don't get the right version.

[07:00] <TimToady> having got that far, I'm pretty sure it could be done without numbers too

[07:01] <TimToady> since any number can be replaced by +<* * * * *> or some such

[07:04] <moritz> rakudo: say ["\0"..."~"].elems

[07:04] <p6eval> rakudo f63b82: OUTPUTÂ«127â¤Â»

[07:05] <moritz> rakudo: say ["\0"..."~"][99, 104, 114, 115]

[07:05] <p6eval> rakudo f63b82: OUTPUTÂ«chrsâ¤Â»

[07:05] <sorear> My only misgiving with âˆ… := {}; is that we need a more efficient way to add categoricals

[07:05] <jlaire> rakudo: say (* ** *)(<* * * * * * * * * *>, <* *>) + (* * *)(<* * * * * * *>, <* *>)

[07:05] <TimToady> coulda just used a slice instead...

[07:05] <p6eval> rakudo f63b82: OUTPUTÂ«114â¤Â»

[07:06] <sorear> Subclassing the grammar won't cut it

[07:07] *** daniel-s joined
[07:09] * TimToady wanders off to find some hay to hit... &

[07:11] *** daniel-s__ joined
[07:11] *** daniel-s left
[07:16] *** CBro2007 joined
[07:16] *** _daniel-s__ joined
[07:16] <sorear> o/ CBro2007

[07:16] *** daniel-s__ left
[07:17] <sorear> rakudo: say asin i

[07:17] <p6eval> rakudo f63b82: OUTPUTÂ«0 + 0.881373587019543iâ¤Â»

[07:19] * sorear observes with incredulity that Rakudo master's asinh takes a $base parameter

[07:19] <sorear> what does sinh(41 degrees) even mean

[07:20] <sorear> nothing geometrically relevant I bet

[07:20] * sorear out

[07:20] <daxim> doin' trigonometry LIKE A $BASE

[07:20] *** daniel-s joined
[07:21] *** _daniel-s__ left
[07:24] *** daniel-s__ joined
[07:25] *** daniel-s left
[07:27] *** am0c joined
[07:28] *** daniel-s__ left
[07:29] *** daniel-s__ joined
[07:32] *** _daniel-s__ joined
[07:32] *** daniel-s__ left
[07:36] *** daniel-s joined
[07:36] *** _daniel-s__ left
[07:41] *** mj41 joined
[07:50] *** wamba joined
[07:57] *** Util joined
[08:01] *** Jackneill joined
[08:01] *** Mowah joined
[08:02] *** donri joined
[08:02] *** Jackneill left
[08:41] *** buubot_backup joined
[08:44] *** timbunce joined
[08:50] *** dakkar joined
[09:01] *** bs338 joined
[09:12] *** daniel-s left
[09:17] *** nymacro joined
[09:21] *** ab5tract joined
[09:30] *** wamba left
[09:42] *** CBro2007 left
[10:16] *** xinming joined
[10:24] *** WAAZG4A joined
[10:24] *** PAAB49V joined
[10:24] *** CBro2007 joined
[10:39] *** DarthGandalf joined
[10:42] *** nymacro left
[11:02] *** dayangkun joined
[11:02] *** MayDaniel joined
[11:17] *** Trashlord joined
[11:25] *** Jackneill joined
[11:25] *** Jackneill left
[11:25] *** Jackneill joined
[11:26] *** wamba joined
[11:33] *** satyavvd left
[11:38] *** JimmyZ joined
[11:38] <JimmyZ> good evening

[11:47] *** CBro2007 left
[11:47] *** betterworld joined
[11:47] *** JimmyZ_ joined
[11:49] *** colomon joined
[11:49] *** JimmyZ left
[11:49] *** JimmyZ_ is now known as JimmyZ

[11:50] *** Su-Shee joined
[11:57] *** timbunce left
[11:57] *** JimmyZ left
[11:59] *** timbunce joined
[12:03] <takadonet> morning all

[12:14] *** dayangkun left
[12:31] *** bluescreen10 joined
[12:36] <Util> Morning, takadonet 

[12:55] *** Holy_Cow joined
[13:03] *** smash_ joined
[13:04] *** smash_ is now known as smash

[13:05] <smash> hello everyone

[13:16] *** kid51 joined
[13:17] *** Holy_Cow left
[13:18] *** wamba left
[13:28] <takadonet> smash: hey

[13:31] *** MayDaniel left
[13:48] *** Mowah left
[13:56] <sorear> good * #perl6

[13:59] *** CBro2007 joined
[13:59] *** pernatiy joined
[14:07] <colomon> sorear: apologies for not getting to the trig stuff yet.  I do have a plan for both implementation and improving tests, but I'm getting mauled at $work at the moment, which is taking all my free time.  Things should be better by the weekend.

[14:17] *** awoodland joined
[14:19] *** wtw left
[14:19] *** daxim left
[14:19] *** _twitch joined
[14:23] *** perlhack joined
[14:24] <sorear> colomon: would you mind if I 1. expanded sin to utransc and have it handle all 24 cases  2. worked on making the trig tests pass ?

[14:24] * moritz emerges

[14:25] *** icwiener joined
[14:27] *** _twitch left
[14:27] *** mkramer joined
[14:27] *** mkramer left
[14:28] * moritz just helped his parents move out of the house where he grew up. That's tough.

[14:29] *** _twitch joined
[14:29] <colomon> sorear: 1. is certainly your baby, and I won't object to anything you want to do to it.  I don't think it's a great idea -- seems to me it will both be slower and uglier -- but it's your baby.  2. ack, I really do have a plan for simplifying the tests that would probably make your efforts a lot easier....

[14:29] <colomon> moritz++

[14:32] *** wamba joined
[14:32] *** perlhack left
[14:40] *** frettled joined
[14:41] *** ggoebel joined
[14:42] *** _twitch left
[14:43] <sorear> colomon: (1) what's your plan?

[14:43] <sorear> colomon: I think a 2 switches with 24 cases would be prettier than 24 copies of the transcedental unary boilerplate

[14:44] <colomon> 1. write a simple script to automatically generate each of the needed functions.

[14:44] *** _twitch joined
[14:44] *** CBro2007 left
[14:46] * jlaire dreams about macros

[14:47] *** wolfman2000 joined
[14:48] *** colomon left
[14:55] *** CBro2007 joined
[14:58] *** colomon joined
[15:00] *** awoodland left
[15:00] *** colomon left
[15:01] *** spq1 joined
[15:02] *** colomon joined
[15:07] <pmichaud> good morning, #perl6

[15:08] *** _twitch left
[15:10] <moritz> good am, pm

[15:21] *** noganex_ joined
[15:29] *** noganex_ is now known as noganex

[15:30] *** Mowah joined
[15:32] *** bluescreen10 left
[15:32] *** CBro2007 left
[15:36] *** rjbs joined
[15:37] <rjbs> pmichaud: Hey, I see you're going to be in Philly.  When do you arrive?

[15:40] <pmichaud> I arrive Friday afternoon, depart Sunday evening

[15:40] *** yuanzhao0501 joined
[15:42] *** wamba left
[15:43] *** yuanzhao0501 left
[15:47] *** bluescreen10 joined
[15:51] *** kaare__ joined
[15:53] *** [particle] joined
[15:55] *** kjeldahl joined
[15:55] *** wolfman2000 left
[16:08] <moritz> rakudo: say ~("abc".match(:g, :p(0), /./))

[16:08] <p6eval> rakudo f63b82: OUTPUTÂ«a b câ¤Â»

[16:08] <moritz> rakudo: say ~("abc".match(:g, :p(1), /./))

[16:08] <p6eval> rakudo f63b82: OUTPUTÂ«b câ¤Â»

[16:08] <moritz> rakudo: say ~("abc".match(:g, :c(1), /./))

[16:08] <p6eval> rakudo f63b82: OUTPUTÂ«b câ¤Â»

[16:09] *** Adrieuxo joined
[16:12] <colomon> niecza: say 2 ** 64

[16:12] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«18446744073709551616â¤Â»

[16:13] <rjbs> pmichaud: If you're interested in lunch (or maybe dinner; not sure what my plans have to be pre-OSCON), let me know.  My office is in downtown PHL (Chinatown).

[16:14] <pmichaud> rjbs: will do.  I may also be meeting up with kid51 for dinner; we're staying out by the airport

[16:15] <pmichaud> (cheaper than center city lodging :)

[16:16] <rjbs> I bet :)

[16:17] <rjbs> there's actually a decent only-slightly-dumpy hotel right by my office for $99/night, but that's probably only a big improvement if you want to be in my neighborhood :)

[16:20] *** mj41 left
[16:21] *** meteorjay joined
[16:26] *** Adrieuxo left
[16:27] *** wamba joined
[16:28] *** cooper joined
[16:31] <moritz> nom: say 'abc'.match(/./, :c(3))

[16:31] <p6eval> nom: OUTPUTÂ«â¤Â»

[16:31] <moritz> nom: say 'abc'.match(/./, :c(2))

[16:31] <p6eval> nom: OUTPUTÂ«câ¤Â»

[16:35] *** Anaeluxo joined
[16:36] *** molaf joined
[16:36] <moritz> nom: say 'abc'.match(/./, :c(2)).Bool

[16:36] <p6eval> nom: OUTPUTÂ«Bool::Trueâ¤Â»

[16:36] <moritz> nom: say 'abc'.match(/./, :c(3)).Bool

[16:36] <p6eval> nom: OUTPUTÂ«Bool::Trueâ¤Â»

[16:36] <moritz> gotcha

[16:36] <moritz> nom: say 'abc'.match(/./, :c(3))

[16:36] <p6eval> nom: OUTPUTÂ«â¤Â»

[16:36] <moritz> nom: say 'abc'.match(/./, :c(3)).from

[16:36] <p6eval> nom: OUTPUTÂ«3â¤Â»

[16:36] <moritz> nom: say 'abc'.match(/./, :c(3)).to

[16:36] <p6eval> nom: OUTPUTÂ«-3â¤Â»

[16:37] <benabik> moritz: test golfing?

[16:37] <moritz> benabik: hunting a bug

[16:38] <moritz> I'm trying to implement Str.match(Regex, :global)

[16:38] <moritz> and my loop for matching ran infinitely

[16:38] <moritz> and when I added debugging output, it died mysteriously

[16:39] <moritz> now I know why - because it continued to run even if no match was found, because Match.Bool is wrong

[16:39] *** rjbs left
[16:39] <moritz> this might have lead to a few falsly passing tests

[16:39] <moritz> nom: say "OH NOEZ" if 'a' ~~ /b/

[16:39] <p6eval> nom: OUTPUTÂ«OH NOEZâ¤Â»

[16:42] *** birdwindupbird left
[16:43] *** pernatiy_ joined
[16:44] <moritz> nom: say 'abc'.match(/<?alpha>/, 'abc', :c(30))

[16:44] <p6eval> nom: OUTPUTÂ«No applicable candidates found to dispatch to for 'match'. Available candidates are:â¤:(Str, Regex $pat, Any $c, Any $p, Mu %_)â¤:(Cool, Cool $target, Associative %adverbs)â¤â¤current instr.: 'match' pc 469785 (src/gen/CORE.setting.pir:125003) (src/gen/CORE.setting:967)â¤Â»â€¦

[16:44] <moritz> nom: say 'abc'.match(/<?alpha>/, :c(30))

[16:44] <p6eval> nom: OUTPUTÂ«â¤Â»

[16:44] *** pernatiy left
[16:44] <moritz> nom: say 'abc'.match(/<?alpha>/, :c(30)).from

[16:44] <p6eval> nom: OUTPUTÂ«30â¤Â»

[16:44] <moritz> nom: say 'abc'.match(/<?alpha>/, :c(30)).to

[16:44] <p6eval> nom: OUTPUTÂ«30â¤Â»

[16:45] *** CBro2007 joined
[16:45] <benabik> I wonder if anyone bothered to add a spectest for "failed match .Bools to False"

[16:45] <dalek> rakudo/nom: a331d3c | moritz++ | src/core/Match.pm:

[16:45] <dalek> rakudo/nom: fix Match boolification

[16:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a331d3c099

[16:45] <moritz> pmichaud: that's a bug, it amtches a zero-width regex outside the length of the string

[16:47] <moritz> benabik: I'd be surprised if we missed such a test, but since rakudo doesn't yet run most of the regex related tests, we probably just haven't encountered it

[16:47] *** bluescreen10 left
[16:48] *** kid51 left
[16:52] <moritz> otoh the tests are still a bit incomplete

[16:53] *** timbunce left
[16:53] *** hatsefla1s joined
[16:54] *** xinming_ joined
[16:54] *** orevdiabl joined
[16:55] *** Sid joined
[16:56] *** Trashlord left
[16:56] *** Sid is now known as Trashlord

[16:58] <moritz> .u 0xa4#

[16:58] <phenny> moritz: U+0030 U+0078 U+0061 U+0034 U+0023

[16:58] <moritz> .u 0xa4

[16:58] <phenny> U+00A4 CURRENCY SIGN (Â¤)

[16:59] <benabik> I've always liked using Âµ as the replacement for an unknown Monetary Unit.

[16:59] *** xinming left
[16:59] *** bluescreen10 joined
[17:00] *** timbunce joined
[17:00] *** Yappoko___ joined
[17:00] *** mattp_ joined
[17:00] <CBro2007> guys am just reading through the article perl 5 to 6, wondering how I can start to learn how to use it all? :) Any ideas?

[17:01] <CBro2007> moritz: yeah its your article

[17:02] <moritz> CBro2007: install rakudo and/or niecza, and write Perl 6 code

[17:02] <moritz> the best way to learn a language is always to use it

[17:02] <CBro2007> yeah I got rakudo installed on my mac

[17:02] <moritz> (both for natural and for programming languages)

[17:02] <CBro2007> but don't know what to use it on

[17:02] <CBro2007> or for what 

[17:02] <moritz> what do you use other programming languages for?

[17:02] <PerlJam> CBro2007: you could try to read and understand rosetta code problems and try to solve some of your own

[17:02] <CBro2007> was thinking of writing a p5 module to p6

[17:02] <moritz> sure, that's an option

[17:03] <moritz> what interests you, in terms programming?

[17:03] <CBro2007> but would it be too soon to get into doing that

[17:03] <moritz> why?

[17:03] <moritz> databases? web? math? games? graphics?

[17:03] <CBro2007> mostly algorithmics

[17:03] <CBro2007> or data mining

[17:03] <CBro2007> to be more accurate

[17:04] <moritz> so do something with Perl 6 that interests you

[17:04] <moritz> I'd have plenty ideas for algorithms, not so many for data mining

[17:04] <CBro2007> k but I was hoping to contribute the code too

[17:04] <CBro2007> can you share some?

[17:04] *** pernatiy_ left
[17:05] <CBro2007> I was thinking of containers like c++ std library

[17:05] <moritz> for example, implement Dancing Links in Perl 6

[17:05] <CBro2007> I suggested that last time

[17:05] <CBro2007> Is that useful?

[17:05] <PerlJam> CBro2007: modules.perl6.org might be useful to you

[17:05] <moritz> I'd write a Sudoku solver on top of that :-)

[17:05] <CBro2007> heh

[17:05] <moritz> so for me it would be useful

[17:05] *** Yappoko___ left
[17:05] *** mattp_ left
[17:05] <moritz> or you could implement red/black trees

[17:06] <moritz> or... whatever you'd like

[17:06] <CBro2007> yeah or b+ trees

[17:06] <benabik> R/B trees are fun.

[17:06] *** Yappoko___ joined
[17:06] *** mattp_ joined
[17:06] <CBro2007> but a library would be cool yeah?

[17:06] <moritz> or a packrat parser

[17:06] <moritz> sure

[17:06] <CBro2007> like a collection of all sortsa search trees etc

[17:07] <moritz> so many interesting algorithms, so little time... :-)

[17:07] <CBro2007> do they have to be modules?

[17:07] <moritz> well, modules are easy to reuse (and easy to test)

[17:07] <moritz> so it kinda makes sense to write them as modules (which of course can be classes)

[17:07] <CBro2007> ok maybe when I write something up I will ask you guys for help

[17:07] <moritz> sure

[17:07] <CBro2007> hopefully its ok with you all ;)

[17:08] <CBro2007> i think fter the article 5 to 6 I should be ok to start up something

[17:08] <moritz> that's what #perl6 is for, developing stuff in and for Perl 6 :-)

[17:08] <CBro2007> just hope it doesn't look like dog shit

[17:08] <CBro2007> :)

[17:08] <CBro2007> kewl

[17:08] <moritz> and if it does, we'll tell you why it looks like dog shit, and what you can do to change that :-)

[17:09] <CBro2007> k

[17:09] <CBro2007> just don't be too critical mate :)

[17:09] <moritz> :-)

[17:12] <benabik> CBro2007: We try to be just critical enough.

[17:13] <CBro2007> yeah I know .. it'll be cool. I just have to get off my ass and get around writing something first :)

[17:17] <CBro2007> moritz: can you help me make sense of "context"?

[17:17] <CBro2007> I don't quite get it

[17:17] <CBro2007> $x = @a

[17:18] <CBro2007> is that saying $x = number of elements in a?

[17:19] <colomon> rakudo: my @a = 5..10; my $x = @a; say $x.perl

[17:19] <p6eval> rakudo f63b82: OUTPUTÂ«[5, 6, 7, 8, 9, 10]â¤Â»

[17:19] <colomon> rakudo: my @a = 5..10; my $x = +@a; say $x.perl

[17:19] <p6eval> rakudo f63b82: OUTPUTÂ«6â¤Â»

[17:21] <CBro2007> so saying just $x = @a is like assigning $x to a reference of @a?

[17:21] <CBro2007> and then +@a is the number of items in @a?

[17:22] <colomon> hmmm

[17:22] <colomon> rakudo: my @a = 5..10; my $x = @a; @a[3]=10000; say $x.perl

[17:22] <p6eval> rakudo f63b82: OUTPUTÂ«[5, 6, 7, 10000, 9, 10]â¤Â»

[17:22] <colomon> reference, yup.

[17:22] <benabik> nom: my @a = 5..10; my $x = @a; @a[3]=10000; say $x.perl

[17:22] <p6eval> nom: OUTPUTÂ«[5, 6, 7, 10000, 9, 10]â¤Â»

[17:23] <benabik> nom: my @a = 5..10; my @x = @a; @a[3]=10000; say @x.perl

[17:23] <p6eval> nom: OUTPUTÂ«Array.new(5, 6, 7, 8, 9, 10)â¤Â»

[17:23] <CBro2007> whats ~stuff

[17:23] <CBro2007> ?stuff

[17:23] <CBro2007> I am not getting where I would use this?

[17:23] <benabik> ~stuff = stuff as string

[17:24] <benabik> ?stuff = stuff as bool (IIRC)

[17:24] <benabik> nom: my $stuff = 42; say ~$stuff; say ?$stuff

[17:24] <p6eval> nom: OUTPUTÂ«42â¤Bool::Trueâ¤Â»

[17:24] <benabik> nom: my $stuff = 42; say ~$stuff.perl; say ?$stuff

[17:24] <p6eval> nom: OUTPUTÂ«42â¤Bool::Trueâ¤Â»

[17:24] <benabik> nom: my $stuff = 42; say (~$stuff).perl; say ?$stuff

[17:24] <p6eval> nom: OUTPUTÂ«"42"â¤Bool::Trueâ¤Â»

[17:26] <benabik> CBro2007: In P5 you had to know what operators would convert values to what types.  In P6 you can explicitly state these things.

[17:26] <CBro2007> @( <a b> Z <c d> )     # <a c b d>

[17:26] <CBro2007>     @@( <a b> Z <c d> )     # (['a', 'c'], ['b', 'd'])

[17:27] *** isBEKaml joined
[17:27] <CBro2007> what is the "Z"?

[17:27] <benabik> zip operator

[17:27] <CBro2007> hm 

[17:27] <benabik> `@a Z @b` takes the first element of @a and pairs it with the first of @b and so on.

[17:28] <benabik> rakudo: say (<a b> Z <c d>).perl

[17:28] <p6eval> rakudo f63b82: OUTPUTÂ«("a", "c", "b", "d")â¤Â»

[17:28] <isBEKaml> rakudo: my @a=<1 2 3>, @b = <4 5 6>; say @a Z+ @b;

[17:28] <p6eval> rakudo f63b82: OUTPUTÂ«===SORRY!===â¤Symbol '@b' not predeclared in <anonymous> (/tmp/hGXeypBUo1:22)â¤Â»

[17:28] <isBEKaml> rakudo: my @a=<1 2 3>;my @b = <4 5 6>; say @a Z+ @b;

[17:28] <p6eval> rakudo f63b82: OUTPUTÂ«579â¤Â»

[17:28] <CBro2007> was < > to make a list?

[17:28] <CBro2007> I thought it wasn't needed yeah?

[17:29] <isBEKaml> CBro2007: that's akin to qw() in p5

[17:29] <CBro2007> ah i see

[17:29] *** dakkar left
[17:29] <CBro2007> how do i run code here?

[17:30] <isBEKaml> CBro2007: you can also do Zop with Z where op is any operator applicable. 

[17:30] <CBro2007> just "rakudo: ... "?

[17:30] <isBEKaml> yes

[17:31] <CBro2007> rakudo: my @a = 1 2 3; my @b = 4 5 6; say @a Z+ @b;

[17:31] <p6eval> rakudo f63b82: OUTPUTÂ«===SORRY!===â¤Confused at line 22, near "my @a = 1 "â¤Â»

[17:31] <CBro2007> hmm so I have to say < > around the 1 2 3?

[17:31] <isBEKaml> CBro2007: there has to be some way for rakudo to realise that it's a list you're providing. 

[17:31] *** Chillance joined
[17:31] <benabik> rakudo: my @a = 1, 2, 3; my @b = 4, 5, 6; say @a Z+ @b; # commas should be enough

[17:31] *** Jackneill left
[17:31] <CBro2007> hmm coz the tutorial didn't need any < > around

[17:31] <p6eval> rakudo f63b82: OUTPUTÂ«579â¤Â»

[17:32] <isBEKaml> benabik++ #forgot p6 for quite a while. :)

[17:32] <CBro2007> ah ofcourse

[17:32] <CBro2007> sorry

[17:33] <CBro2007> this zip looks like something I came across in Haskell

[17:33] <CBro2007> i think its the same deal

[17:33] <benabik> Yup!

[17:33] <isBEKaml> std: my @a=<1 2 3>,@b = <1 2 3>;

[17:33] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Variable @b is not predeclared at /tmp/ehPZIx9XS2 line 1:â¤------> [32mmy @a=<1 2 3>,@b[33mâ[31m = <1 2 3>;[0mâ¤Check failedâ¤FAILED 00:01 122mâ¤Â»

[17:33] <isBEKaml> CBro2007: yes, that's the same. 

[17:33] <benabik> std: my (@a, @b) = (<1 2 3>, <1 2 3>)

[17:33] <p6eval> std 516268a: OUTPUTÂ«ok 00:01 124mâ¤Â»

[17:33] <isBEKaml> std: my $a=1,$b=2;

[17:33] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Variable $b is not predeclared at /tmp/qRPIF0iz0_ line 1:â¤------> [32mmy $a=1,$b[33mâ[31m=2;[0mâ¤Check failedâ¤FAILED 00:01 122mâ¤Â»

[17:34] <benabik> std: my ($a, $b) = (1,2)

[17:34] <p6eval> std 516268a: OUTPUTÂ«ok 00:01 124mâ¤Â»

[17:34] *** Anaeluxo left
[17:34] <benabik> nom: my ($a, $, $c) = <a b c>; say $a; say $c

[17:34] <CBro2007> am just thinking that in p5, if I wanted to build a complicated Hash of hash of hashes or something.. I would read in lines from say a file and build this structure on the fly using references 

[17:34] <isBEKaml> benabik: yes, I can do that. But the compiler should be able to assign variables as I give them right beside the variables?

[17:34] <p6eval> nom: OUTPUTÂ«aâ¤câ¤Â»

[17:34] <CBro2007> how would one do the same in p6

[17:34] <CBro2007> I haven't seen references anywhere yet

[17:35] <CBro2007> have they gotten rid of refs in p6?

[17:35] <benabik> isBEKaml: The compiler could, if that was valid P6.  But it's not.

[17:35] <isBEKaml> benabik: It's not? int a=5,b = 6; ?

[17:35] <isBEKaml> like in C?

[17:35] <benabik> isBEKaml: Nope.  It's `my ($a, $b) = 5, 6` like in Perl 5

[17:36] <isBEKaml> benabik: p5 doesn't complain. :)

[17:36] <benabik> CBro2007: It's a bit more like refs are the default.  See how `$x = @a` worked above.

[17:36] <CBro2007> so just about my qn.. how would you do that in p6?

[17:36] <CBro2007> yeah I see that

[17:36] <isBEKaml> buubot_backup: my $a=1, $b = 2; say $a; say $b;

[17:36] <buubot_backup> isBEKaml: Couldn't match input.

[17:37] <isBEKaml> how do you use buubot?

[17:37] <CBro2007> just not sure how I could build something complicated using this "inbuilt" reference stuff

[17:38] *** Yappoko___ left
[17:38] *** mattp_ left
[17:38] <pmichaud> CBro2007: in general, it "just works" without having to think about references.

[17:38] <isBEKaml> buubot_backup: say 42;

[17:38] <buubot_backup> isBEKaml: Couldn't match input.

[17:38] <isBEKaml> buubot_backup: eval(print 42)

[17:38] <buubot_backup> isBEKaml: Couldn't match input.

[17:38] <isBEKaml> boo

[17:38] <benabik> isBEKaml: I stand corrected.  But `my ($a, $b) = 1,2` seems far more common than `my $a = 1, $b = 2`

[17:39] <CBro2007> so if you wanted to have say a hash of hashes... could you show me a sample. In p5, I would have done.  $href->{key}->{key2} = val

[17:39] <isBEKaml> benabik: my ($a, $b) is list assignment to lvalues. my $a=1,$b=2 is just variable assignment. 

[17:39] <pmichaud> nom:  my %hoh = a => { able => 123, andy => 140 }, b => { ben => 1, bob => 4 };   say %hoh.perl

[17:39] <p6eval> nom: OUTPUTÂ«("a" => {"able" => 123, "andy" => 140}, "b" => {"ben" => 1, "bob" => 4}).hashâ¤Â»

[17:40] <pmichaud> rakudo:  my %h;  %h<a><able> = 124;  say %h.perl;

[17:40] <p6eval> rakudo f63b82: OUTPUTÂ«{"a" => {"able" => 124}}â¤Â»

[17:40] <isBEKaml> pmichaud: why doesn't p6 accept my $a=1, $b=2  while p5 does?

[17:40] <CBro2007> ah i see

[17:40] <pmichaud> isBEKaml: likely because of the differing precedence of assignment

[17:40] <CBro2007> I haven't seen ... %h<a><able>.... I mean the use of < and > like that

[17:41] <isBEKaml> pmichaud: comma has higher precedence than assignment? :O

[17:41] <benabik> isBEKaml: Yes.  So `@a = 1,2,3` works.

[17:41] <pmichaud> isBEKaml: in list assignment, yes.

[17:41] <isBEKaml> pmichaud: Ah, I see. 

[17:41] <pmichaud> rakudo:  my %h;  %h{'a'}{'able'} = 123;  say %h.perl;

[17:41] <p6eval> rakudo f63b82: OUTPUTÂ«{"a" => {"able" => 123}}â¤Â»

[17:41] <benabik> std: my ($a = 1), ($b = 2)

[17:41] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Variable $b is not predeclared at /tmp/hy3w2nad40 line 1:â¤------> [32mmy ($a = 1), ($b[33mâ[31m = 2)[0mâ¤Check failedâ¤FAILED 00:01 125mâ¤Â»

[17:41] <pmichaud> %hash<a>  is a shorter way of writing  %hash{'a'}

[17:42] <CBro2007> ah yeah I remember now

[17:42] <isBEKaml> std: my {$a = 1}, {$b = 2}

[17:42] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Malformed my at /tmp/w1PgnYVUGz line 1:â¤------> [32mmy [33mâ[31m{$a = 1}, {$b = 2}[0mâ¤    expecting scoped declaratorâ¤Parse failedâ¤FAILED 00:01 117mâ¤Â»

[17:42] <CBro2007> in the hash key had to be wrapped with the ' ' yeah

[17:42] <pmichaud> rakudo:  my $x;   $x{'name'}[3]{'foo'} = 'test';  say $x.perl;

[17:42] <p6eval> rakudo f63b82: OUTPUTÂ«{"name" => [Any, Any, Any, {"foo" => "test"}]}â¤Â»

[17:43] <pmichaud> CBro2007: see, it "just works".  I ended up with a hash entry that was an array of hashes :-)

[17:43] <pmichaud> (and $x was even declared as a scalar variable :-)

[17:43] <CBro2007> what is "Any"?

[17:43] <CBro2007> a placeholder?

[17:43] <benabik> Wow.  Any() can autoviv to a hash?

[17:43] <pmichaud> "Any" is the new "undef"

[17:43] <isBEKaml> std: my $a = (1), $b = (2);

[17:43] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Variable $b is not predeclared at /tmp/QXaUxAWnbo line 1:â¤------> [32mmy $a = (1), $b[33mâ[31m = (2);[0mâ¤Check failedâ¤FAILED 00:01 123mâ¤Â»

[17:43] <CBro2007> wicked

[17:43] <pmichaud> we now have typed undefs

[17:44] <pmichaud> Any is the generic undef for most common objects

[17:44] <CBro2007> so Any is kind of where all types inherit from yeah?

[17:44] <CBro2007> so its like a super type?

[17:44] <pmichaud> for the most part, yes.  There's a type above Any

[17:44] <pmichaud> (Mu)

[17:44] <isBEKaml> CBro2007: yeah, Any equivalent to Object in java and C#

[17:44] <CBro2007> is "Object" above Any?

[17:44] <isBEKaml> CBro2007: as pm says, Mu stands above all. though rarely used. 

[17:44] <CBro2007> is that the one?

[17:44] <pmichaud> "Mu" is above Any.

[17:44] <CBro2007> ah Mu

[17:44] <pmichaud> nom:  say Any.^parents;

[17:44] <p6eval> nom: OUTPUTÂ«Mu()â¤Â»

[17:44] <CBro2007> ok haven't read about it

[17:45] <pmichaud> nom: say Match.^parents

[17:45] <p6eval> nom: OUTPUTÂ«Capture() Any() Mu()â¤Â»

[17:45] <pmichaud> nom: say Int.^parents  # nom gives the wrong answer here for now, but it illustrates the point

[17:45] <p6eval> nom: OUTPUTÂ«Real() Numeric() Cool() Any() Mu()â¤Â»

[17:45] <benabik> I tend to think of Any more like AnyRef in Scala.  :-D

[17:45] <CBro2007> also why are the regular expressions in p6 moving towards more like the java style?

[17:45] <CBro2007> with a matcher class

[17:45] <isBEKaml> pmichaud: ^parents is pretty cool. Generating accurate documentation would be more easier. 

[17:45] <isBEKaml> benabik: Scala, you too? :D

[17:45] <pmichaud> CBro2007: match objects hold more than just the string they matched

[17:46] <pmichaud> they hold the contents of any submatches as well.

[17:46] <benabik> isBEKaml: Scala is my cure for Java.  :-D  It's more Perly and more Haskelly than Java.

[17:46] <CBro2007> pmichaud: but could we not capture patterns in p5?

[17:46] <isBEKaml> benabik: Agreed. I feel the same. :)

[17:46] <pmichaud> CBro2007: it's a bit deeper than that, even.

[17:46] <CBro2007> pmichaud: sorry just trying to understand the need. 

[17:47] <CBro2007> ok

[17:47] <pmichaud> CBro2007: basically, the parser for Perl 6 is implemented using Perl 6 regular expressions.

[17:47] <pmichaud> we no longer get back a simple set of strings -- it gives back an entire parse tree.

[17:47] <CBro2007> and its more optimized?

[17:47] *** mattp_ joined
[17:47] <CBro2007> ok

[17:47] <[Coke]> moritz: (good am, pm) GROOOOOOOOOOOOOAN

[17:47] <CBro2007> so its more like a parser 

[17:47] <pmichaud> Perl 6 grammars and regexes are more like Parse::RecDescent, or Grammar::Regexp

[17:48] <benabik> The parse tree stringifies to the correct things, of course.  :-D

[17:48] <pmichaud> (indeed, those were developed contemporaneously with Perl 6 regexes and grammars)

[17:48] <CBro2007> k

[17:48] <CBro2007> now I can go back to reading further :)

[17:48] <isBEKaml> benabik: do you happen to be one of those lucky ones that use Scala at work? 

[17:48] <CBro2007> thanks for the explanations

[17:49] <[Coke]> whoa, rjbs is in PHL?!? I wish I had known that before I spent a week there.

[17:49] <benabik> isBEKaml: I was a contractor for a while and my main customer didn't care what it was written in as long as it worked.

[17:49] <isBEKaml> benabik: lucky fella. When was that?

[17:49] <isBEKaml> benabik: pre 2.8 days? :)

[17:50] <moritz> [Coke]: I've been using that "joke" for ages now :-)

[17:50] *** impious joined
[17:51] <isBEKaml> [Coke]: so has sorear (though not a joke, more a meme) :P

[17:52] <benabik> isBEKaml: It was a year or so ago.  2.8 either was just released or was released early during the project.

[17:53] <isBEKaml> benabik: that's cool. I kind of grew used to 2.7 when 2.8 came and quickly got overwhelmed by those huge changes. Now, it's 2.9. :)

[17:54] <isBEKaml> benabik: anyway, it would be pretty awesome to see some libraries in p6 like those of collections or Actors in Scala. 

[17:54] <benabik> isBEKaml: It would.  Get coding.  ;-)

[17:55] <isBEKaml> benabik: :-) # waiting for the enlightenemnt and collaborators. 

[17:56] <moritz> rakudo: 'abc' =~ 1

[17:56] <p6eval> rakudo f63b82: OUTPUTÂ«===SORRY!===â¤Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at line 22, near " 1"â¤Â»

[17:56] <moritz> nom: 'abc' =~ 1

[17:56] <p6eval> nom: OUTPUTÂ«Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at line 1, near " 1"â¤current instr.: 'nqp;HLL;Grammar;panic' pc 23533 (src/stage2/gen/NQPHLL.pir:6314) (src/stage2/gen/NQPHLL.pm:328)â¤Â»

[17:57] <isBEKaml> rakudo: 'abc' ~= 1

[17:57] <p6eval> rakudo f63b82: OUTPUTÂ«Cannot modify readonly valueâ¤  in '&infix:<=>' at line 1:src/metamodel/RoleToInstanceApplier.nqpâ¤  in main program body at line 1:/tmp/dwaAJdpvzxâ¤Â»

[17:57] <isBEKaml> :D

[17:57] <isBEKaml> std: 'ab' ~~=1

[17:57] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Can't make assignment out of ~~ because chaining operators are diffy at /tmp/Mznmgw5DHQ line 1:â¤------> [32m'ab' ~~=[33mâ[31m1[0mâ¤Check failedâ¤FAILED 00:01 120mâ¤Â»

[17:57] <isBEKaml> std: 'ab' ~~ 1

[17:58] <p6eval> std 516268a: OUTPUTÂ«ok 00:01 120mâ¤Â»

[17:58] <moritz> nom: eval '"abc" =~ 1'; say $!.WHAT

[17:58] <p6eval> nom: OUTPUTÂ«Exception()â¤Â»

[17:58] <moritz> nom: eval '"abc" =~ 1'; say $!

[17:58] <p6eval> nom: OUTPUTÂ«Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at line 1, near " 1"â¤Â»

[17:58] <moritz> nom: eval '"abc" =~ 1'; say $! ~~ /'~~'/

[17:58] <p6eval> nom: OUTPUTÂ«â¤Â»

[17:59] <moritz> nom: eval '"abc" =~ 1'; say "$!" ~~ /'~~'/

[17:59] <p6eval> nom: OUTPUTÂ«â¤Â»

[17:59] <moritz> nom: say "~~" ~~ /'~~'/

[17:59] <p6eval> nom: OUTPUTÂ«~~â¤Â»

[17:59] *** Holy_Cow joined
[17:59] <moritz> nom: eval '"abc" =~ 1'; say "$!"

[17:59] <p6eval> nom: OUTPUTÂ«Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at line 1, near " 1"â¤Â»

[17:59] <moritz> nom: eval '"abc" =~ 1'; say "$!".WHAT

[17:59] <p6eval> nom: OUTPUTÂ«Exception()â¤Â»

[17:59] <moritz> meh.

[17:59] *** Holy_Cow left
[17:59] <benabik> moritz: What are you trying to track down?

[17:59] <moritz> nom: eval '"abc" =~ 1'; say $!.Str

[17:59] <p6eval> nom: OUTPUTÂ«Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at line 1, near " 1"â¤Â»

[18:00] <moritz> benabik: test failure in S03-operators/brainos.t

[18:00] <moritz> nom: eval '"abc" =~ 1'; say $!.Str ~~ /'~~'/

[18:00] *** pjcj joined
[18:00] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:00] <isBEKaml> moritz: brainos? really? :)

[18:00] <moritz> isBEKaml: yes :-)

[18:01] *** Yappoko___ joined
[18:01] <benabik> isBEKaml: Typo : Typing :: Braino : Braining.  Thinking.  Whatever.

[18:02] <isBEKaml> benabik: yeah, * :)

[18:04] <benabik> I wonder where A : B :: C : D came from.  Was it invented for the SAT?

[18:04] <isBEKaml> benabik: proportions. Ratio and proportions. 

[18:05] * moritz knows the concept, but is unfamiliar with the notations

[18:05] <benabik> I've never seen :: used mathmatically.  Odd.

[18:05] <isBEKaml> moritz: I'd just read them as A is to B as C is to D. 

[18:05] * moritz would use <=> instead of :: there

[18:05] <moritz> for logical equivalence

[18:05] <benabik> moritz: The SAT uses ::

[18:05] *** Tpot joined
[18:06] <isBEKaml> benabik: more generally, all entrance tests. ;)

[18:06] <moritz> nom: say ~&infix:<+>

[18:06] <p6eval> nom: OUTPUTÂ«infix:<+>â¤Â»

[18:06] <moritz> nom: say ~&infix:<+> ~~ /\+/

[18:06] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:07] <moritz> nom: say (~&infix:<+>) ~~ /\+/

[18:07] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:07] <moritz> nom: say (~&infix:<+> ~~ /\+/).Bool

[18:07] <p6eval> nom: OUTPUTÂ«Bool::Falseâ¤Â»

[18:07] <moritz> pmichaud: see above - another regex bug in nom?

[18:07] <moritz> nom: say '+' ~~ /\+/

[18:07] <p6eval> nom: OUTPUTÂ«+â¤Â»

[18:08] <moritz> nom: say (~&infix:<+>).WHAT

[18:08] <p6eval> nom: OUTPUTÂ«Str()â¤Â»

[18:08] <moritz> nom: say (~&infix:<+>)

[18:08] <p6eval> nom: OUTPUTÂ«infix:<+>â¤Â»

[18:08] <moritz> nom: say 'infix:<+>' ~~ /\+/

[18:08] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:08] <moritz> nom: say 'a+' ~~ /\+/

[18:08] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:08] * [Coke] gets dizzy.

[18:08] <isBEKaml> nom: say 'a\+' ~~ /\+/

[18:08] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:08] <moritz> nom: say 'abc' ~~ /b/

[18:08] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:09] <isBEKaml> nom: ('ab' ~~ /b/).say

[18:09] <p6eval> nom: OUTPUTÂ«â¤Â»

[18:09] * [Coke] would love an irssi rule of some kind that took messages to p6eval and their responses and made them less prominent.

[18:09] <moritz> so... it implicitly anchors to the start of string?

[18:09] <isBEKaml> nom: ('ab' ~~ /a/).say

[18:09] <p6eval> nom: OUTPUTÂ«aâ¤Â»

[18:09] <pmichaud> could be a bug in Regex.ACCEPTS, yes.

[18:10] <pmichaud> yes, Regex.ACCEPTS is missing the :c(0) argument.

[18:10] <pmichaud> although we have to do a bit more than that ultimately, because it depends on the form of the regex as to the anchoring to be done.

[18:10] <moritz> and in absense of :c(0), does it assume :p(0)?

[18:10] <isBEKaml> [Coke]: add an ignore rule for p6eval. ;)

[18:10] <pmichaud> yes, it assumes :p(0) for now.  I can switch that if we need to.

[18:11] <moritz> it really doesn't matter, because we only use that interface in a few places

[18:11] <dalek> rakudo/nom: 01b163b | moritz++ | src/core/Str.pm:

[18:11] <dalek> rakudo/nom: implement :g for Str.match

[18:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/01b163b637

[18:11] <moritz> currently Str.match, Regex.ACCEPTS

[18:11] <moritz> and I plan to base Str.{split,comb,words} on Str.match

[18:12] <pmichaud> wfm

[18:13] *** impious left
[18:13] <moritz> spectesting now with :c(0) added

[18:15] <CBro2007> just tried "say @@( <a b> Z <c d> );" in a .pl file and got the error : "Non-declarative sigil is missing its name at line 10, near "@@( <a b> "

[18:15] <CBro2007> wondering what that means?

[18:15] <moritz> it means that @@ is not yet implemented in rakudo

[18:15] <moritz> std: say @@( <a b> Z <c d> );

[18:15] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Non-declarative sigil is missing its name at /tmp/hEfn0FBB2w line 1:â¤------> [32msay [33mâ[31m@@( <a b> Z <c d> );[0mâ¤Confused at /tmp/hEfn0FBB2w line 1:â¤------> [32msay @[33mâ[31m@( <a b> Z <c d> );[0mâ¤    expecting twigilâ¤Otheâ€¦

[18:16] <moritz> oh, or is the @@ syntax gone?

[18:16] <mberends> #phasers in 44 min!

[18:16] *** Tpot left
[18:16] <CBro2007> was working earlier when pmichaud showed it to me

[18:16] *** Tpot joined
[18:16] <CBro2007> or was he using something else? nom?

[18:16] <pmichaud> I didn't use @@ earlier... must've been someone else :)

[18:17] <moritz> or something else :-)

[18:17] <isBEKaml> the error message reads like it expects a var name there. @@varname or so. 

[18:18] <moritz> @varname or so :-)

[18:18] <moritz> std: my @@varname

[18:18] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Invalid hard reference syntax at /tmp/nA_hshmcWh line 1:â¤------> [32mmy @[33mâ[31m@varname[0mâ¤    expecting any of:â¤     desigilnameâ¤    twigilâ¤Parse failedâ¤FAILED 00:01 118mâ¤Â»

[18:18] <isBEKaml> @varname@varname1

[18:18] <[Coke]> isBEKaml: that only removes half the conversation.

[18:18] *** Jackneill joined
[18:18] <isBEKaml> [Coke]: Add those violators of your peace too! ;)

[18:18] <CBro2007> so is this feature not implemented? or is there something wrong with the syntax?

[18:18] <isBEKaml> std: my @var@varname;

[18:18] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Two terms in a row at /tmp/DKPkheoD4o line 1:â¤------> [32mmy @var[33mâ[31m@varname;[0mâ¤    expecting any of:â¤    POSTâ¤   bracketed infixâ¤        constraintâ¤     infix or meta-infixâ¤    postfixâ¤        postfix_prefix_meta_operatorâ¤   shape

[18:18] <p6eval> ..definitionâ¤       statementâ€¦

[18:19] *** Tpot left
[18:19] <pmichaud> I see no reference to '@@' in the specs, so I'm guessing it's a fossil.

[18:19] <CBro2007> i got it from moritz's article

[18:19] <CBro2007> @( <a b> Z <c d> )     # <a c b d>

[18:19] <CBro2007>     @@( <a b> Z <c d> )     # (['a', 'c'], ['b', 'd'])

[18:19] <pmichaud> ("fossil" == something we once had in the Perl 6 specs but is now outdated or removed)

[18:19] <CBro2007> slice context

[18:20] <pmichaud> it's now called "lol context"

[18:20] <CBro2007> heh

[18:20] <CBro2007> so how do you go about doing this now?

[18:20] <moritz> where LoL = List of Lists

[18:20] <pmichaud> nom:  say (<a b> Z <c d>).perl;

[18:20] <p6eval> nom: OUTPUTÂ«(("a", "c"), ("b", "d")).listâ¤Â»

[18:20] <moritz> nom: say (<a b> Z <c d>)[0]

[18:20] <CBro2007> sorry why the .perl in the end?

[18:20] <p6eval> nom: OUTPUTÂ«a câ¤Â»

[18:20] <isBEKaml> CBro2007: pretty printer. 

[18:20] <moritz> CBro2007: are you familiar with Data::Dumper in perl 5?

[18:21] <CBro2007> yeah roughly 

[18:21] <pmichaud> without the .perl, the say function will flatten out the elements

[18:21] <CBro2007> i c

[18:21] <CBro2007> ok

[18:21] <pmichaud> nom:  say <a b> Z <c d>

[18:21] <p6eval> nom: OUTPUTÂ«a c b dâ¤Â»

[18:21] <moritz> .perl is the same in Perl 6, but built-i

[18:21] <moritz> n

[18:21] <pmichaud> nom:  say (<a b> Z <c d>).list.perl

[18:21] <p6eval> nom: OUTPUTÂ«(("a", "c"), ("b", "d")).listâ¤Â»

[18:21] <pmichaud> oops

[18:21] <pmichaud> nom:  say (<a b> Z <c d>).flat.perl

[18:21] <p6eval> nom: OUTPUTÂ«("a", "c", "b", "d").listâ¤Â»

[18:22] <TimToady> nom:  say (<a b> Z <c d>).lol.perl

[18:22] <p6eval> nom: OUTPUTÂ«Method 'lol' not found for invocant of class 'List'â¤current instr.: '_block1002' pc 123 ((file unknown):33678224) (/tmp/zfp6SyY7Mr:1)â¤Â»

[18:23] <pmichaud> (nyi, I think)

[18:23] <pmichaud> not hard to implement... just haven't gotten tuit yet.

[18:23] <isBEKaml> there's a .lol? i can haz lol?

[18:23] <TimToady> can not yet haz that cheezburger

[18:24] <pmichaud> nom:  sub xyz(**@l) { say @l.perl };  xyz( <a b> Z <c d> );   # checking

[18:24] <p6eval> nom: OUTPUTÂ«LoL.new((("a", "c"), ("b", "d")).list.item)â¤Â»

[18:24] <CBro2007> on raduko for "say (<a b> Z <c d>).perl;" I got "("a", "c", "b", "d")"

[18:24] <CBro2007> it seems to have flattened it there

[18:24] <pmichaud> rakudo doesn't know about LoL yet

[18:24] <pmichaud> that's only a feature of the new compiler ("nom")

[18:24] <pmichaud> LoL showed up after Rakudo was released, and we've not had the infrastructure to fix it until nom

[18:24] <CBro2007> hmm

[18:25] <CBro2007> so should I be using nom or rakudo for dev and just mucking around with p6?

[18:25] <pmichaud> I'm writing a blog post about that right now :)

[18:25] <CBro2007> so it gets fixed in rakudo you mean?

[18:25] <TimToady> somehow I think that LoL.new((("a", "c"), ("b", "d")).list.item is not actually telling me what I want to know

[18:25] <felher> TimToady: What does 'cal -h' do?

[18:26] <PerlJam> CBro2007: my personal choice for a little while now has been to use nom.

[18:26] <pmichaud> TimToady: I think it's actually wrong.

[18:26] <TimToady> felher: suppresses highlighting today's date

[18:26] <PerlJam> CBro2007: it only sucks when you run into the less-than-implemented portions of nom, but those are fewer and fewer over time

[18:27] <pmichaud> CBro2007: it's hard to give a precise answer.  nom is much closer to the current Perl 6 specification, but is missing some features that Rakudo has

[18:27] <CBro2007> i thought rakudo was the more complete one?

[18:27] <CBro2007> ok

[18:27] <felher> TimToady: Oh, okay. So what cal are you using? My cal (util-linux) doesn't have that option.

[18:27] <benabik> CBro2007: nom is the next version of Rakudo.

[18:27] <pmichaud> within the next few weeks we hope that situation will reverse however, and that nom will have at least as many features (and fewer bugs) than rakudo master

[18:28] <CBro2007> benabik: ok i didn't get that part :)

[18:28] <TimToady> felher: ubuntu linux, and -h is the very first option on the manpage

[18:28] <CBro2007> i suppose while writing code then its best to use stuff that works in both

[18:28] *** bluescreen10 left
[18:30] <pmichaud> the existing rakudo will be "end of lifed" very soon.

[18:30] <pmichaud> as in, next week.  :)

[18:30] <isBEKaml> TimToady: I was confused about the reference to cal. I use util-linux too and -h isn't one of those options. 

[18:31] <TimToady> well, I suppose the example doesn't really need it

[18:31] <dalek> 6model: 12a4dbf | (Martin Berends)++ | c/ (7 files):

[18:31] <dalek> 6model: [6model/c] test C compiling and library loading on Windows

[18:31] <dalek> 6model: review: https://github.com/jnthn/6model/commit/12a4dbfc86

[18:31] <TimToady> not that it's terribly portable as it is...

[18:32] <TimToady> if anyone wants to put up the real calendar algorithm, it would just turn into more numbers

[18:32] <CBro2007> pmichaud: so you recommend downloading nom?

[18:33] <pmichaud> CBro2007: if you're primarily interested in playing with the languages, and don't mind the high likelihood that you'll run into things that aren't yet implemented in nom, I'd suggest it, yes.

[18:33] <pmichaud> *language

[18:33] <CBro2007> k

[18:33] <TimToady> but it is likely to be a bit more frustrating for the next little bit

[18:33] <pmichaud> ...what TimToady++ said.

[18:33] <CBro2007> i mean since you said rakudo will be gone next week... I am just wondering if everyone will be on nom next week?

[18:33] <TimToady> master still more of the things that "ought" to be there

[18:34] <pmichaud> I'm certain not everyone will be on "nom" next week.

[18:34] <CBro2007> ok

[18:34] <TimToady> by "end of life" he means no longer a teenager, and slowly dying :)

[18:34] <pmichaud> but that's where most of the developers are going to be :)

[18:34] <CBro2007> will stick to rakudo for now :)

[18:35] <CBro2007> i still have a long way to go before I get the hang of all these p6 tricks anyway 

[18:35] <tadzik> hello

[18:35] <CBro2007> hi tadzik 

[18:37] *** isBEKaml left
[18:38] <felher> TimToady: k, thnx. seems like Ubuntu is using ncal instaed of util-linux :)

[18:39] <tadzik> CBro2007: hey, how is the Perl 6 experience?

[18:40] <CBro2007> tadzik: still reading through that article in my spare time.. 

[18:40] <CBro2007> tadzik: getting the hang of it slowly

[18:40] <CBro2007> am reading rules now 

[18:40] <CBro2007> I don't quite get the "literal" and "metasyntactic" drama :)

[18:40] <CBro2007> Letter characters (ie underscore, digits and all Unicode letters) match literally, and have a special meaning (they are metasyntactic) when escaped with a backslash. For all other characters it's the other way round - they are metasyntactic unless escaped.

[18:41] <pmichaud> CBro2007: basically, if you want to match punctuation, you have to quote or escape it.

[18:41] <TimToady> it means you don't have to memorize which characters are meta like you do in Perl 5

[18:41] <TimToady> Perl 6 treats all punctuation as meta

[18:42] <CBro2007> in p5 you kind of know which characters to escape in a regex... basically the ones that are used to mean something ... like [ or \ etc 

[18:43] <pmichaud> CBro2007: yes, but do you know the list of all characters that "mean something"?  ;-)

[18:43] <CBro2007> so if we have to match a comma... would you say \, in the regex?

[18:43] <pmichaud> CBro2007: yes.

[18:43] <pmichaud> CBro2007: or ','

[18:43] <TimToady> very nearly all of them mean something anyway, so we decided to reserve them all

[18:43] <CBro2007> , wrapped in single quotes

[18:43] <pmichaud> CBro2007: or double quotes.

[18:44] <CBro2007> ok

[18:44] <CBro2007> will obviously take some getting used to :)

[18:44] <pmichaud> it's *much* simpler than p5 regexes

[18:44] <pmichaud> (from experience)

[18:44] <CBro2007> i like the nested capture syntax of p6

[18:45] <pmichaud> rakudo:   '1,2,345,6,8' ~~ / (\d+) ** ',' /;   say $/.perl;

[18:45] <p6eval> rakudo f63b82: OUTPUTÂ«Match.new(â¤ from => 0,â¤ orig => "1,2,345,6,8",â¤ to   => 11,â¤ positional => [â¤[â¤    Match.new(â¤     from => 0,â¤     orig => "1,2,345,6,8",â¤     to   => 1,â¤    ),â¤    Match.new(â¤     from => 2,â¤     orig => "1,2,345,6,8",â¤     to   => 3,â¤    ),â¤    Match.new(â¤     frâ€¦

[18:45] <pmichaud> well, the dump wasn't so useful there.

[18:45] <CBro2007> so say I used p6 for a project and realized that something that isn't there now but available in p5 as a module.. can I use the p5 module easily? or are there dramas?

[18:45] *** im2ee joined
[18:45] <pmichaud> CBro2007: there are dramas.

[18:46] <pmichaud> mostly black comedies.

[18:46] *** bluescreen10 joined
[18:46] <CBro2007> heh

[18:46] <CBro2007> crap

[18:46] *** ab5tract left
[18:46] <pmichaud> p6 breaks compatibility with p5... in ways that we haven't easily restored yet

[18:46] <CBro2007> maybe thats what would make me give this second thoughts

[18:46] <CBro2007> coz syntax wise.. p6 is bloody way more wicked

[18:47] <pmichaud> if "wicked" means "easier to deal with", I agree.  :)

[18:47] <CBro2007> I see things borrowed from haskell, lisp etc... which will make programming much easier

[18:47] <CBro2007> yeah more feature rich

[18:47] <pmichaud> http://pmichaud.com/sandbox/rel.txt # draft blog post for rakudo.org, comments/suggestions wanted

[18:48] <pmichaud> #phasers in 12

[18:49] <mberends> CBro2007: project blizkost is an experimental bridge that can call some Perl 5 modules from Rakudo master, during some undocumented phases of the moon (YMMV). https://github.com/jnthn/blizkost

[18:49] <CBro2007> ok

[18:50] <CBro2007> oh and I can use C code in p6 yeah?

[18:50] <CBro2007> like call C libraries in p6 i mean

[18:50] *** masak joined
[18:50] <CBro2007> i cannot remember if I read that somewhere or someone mentioned it here

[18:52] *** beek left
[18:52] *** beek_ joined
[18:52] <mberends> CBro2007: you can compile some C code into Parrot, and then call your code from Rakudo, but it's complicated work, so not often done

[18:53] <CBro2007> hmm i thought it was simpler to use C in p6 than in p5. I think in p5 there is a FFI module that helps

[18:53] <pmichaud> it will be simpler to use C, yes.

[18:53] <pmichaud> we have a few hurdles in place yet that need to be removed.

[18:53] <CBro2007> ok

[18:53] *** jaldhar joined
[18:54] *** masak__ joined
[18:54] <mberends> CBro2007: oh, and project zavolaj shows you how to do limited FFI, for example https://github.com/jnthn/zavolaj/blob/master/t/03-customlib.t

[18:55] <CBro2007> ok

[18:55] <CBro2007> this will come handy later on in the future

[18:55] <pmichaud> better example might be:  https://github.com/jnthn/zavolaj/blob/master/examples/mysqlclient.p6

[18:55] <masak__> oh hai, #perl6.

[18:55] <masak__> life is good at tadzik++'s place. we're eating pierogi. :D

[18:55] <mikemol> pics of gtfo? :P

[18:56] <colomon> pierogi!!

[18:56] * colomon drools...

[18:56] *** masak left
[18:57] <masak__> mikemol: working on pics. hold on.

[18:57] <pmichaud> http://gist.github.com/1093407  # latest bench marks

[18:57] <pmichaud> http://gist.github.com/1093408 # latest bench marks, different machine

[18:58] <nine> awwaiid: interesting read: http://fdmanana.files.wordpress.com/2010/06/combining_events_and_threads.pdf

[18:58] <sorear> o/ CBro2007

[18:58] <masak__> o/ CBro2007 

[18:59] <sjohnson> heh

[19:00] <pmichaud> #phasers in 0

[19:00] <CBro2007> so is that to say that Haskell rocks? 

[19:00] <nine> moritz: Could http://fdmanana.files.wordpress.com/2010/06/combining_events_and_threads.pdf be the model for concurrency that is mentioned as suggested by you in S17? The URL in S17 404s

[19:00] <masak__> Haskell rocks, lazily.

[19:00] <tadzik> proof: http://i.imgur.com/ByPnO.jpg

[19:00] <masak__> mikemol: ^

[19:01] <CBro2007> masak__: wondering if erlang would do better

[19:01] <mikemol> Yumm

[19:01] <masak__> CBro2007: do better on what?

[19:02] <CBro2007> with the concurrency model

[19:02] <CBro2007> its throughput could be better maybe?

[19:02] <awwaiid> nine: fancy

[19:03] <masak__> I think Erlang was mentioned as an ideal during some hallway discussion at YAPC::EU 2010. pmichaud was there.

[19:03] <CBro2007> aha

[19:03] <moritz> nine: iirc it had "unification" in the title

[19:04] *** masak__ is now known as masak

[19:05] <TimToady> Erlang is a fairly large lamppost that some people find their problems under.

[19:06] <TimToady> Perl 6 is a whole street full of lampposts

[19:07] <moritz> pmichaud: adding :c(0) to Regex.ACCEPTS did not remove the automatic anchoring to start-of-string

[19:07] *** am0c left
[19:07] <nine> moritz: "A language-based approach to unifying events and threads"?

[19:07] <pmichaud> moritz: noted, I'll take a look at it shortly.

[19:07] <awwaiid> nine: it sounds like that paper is kinda like AnyEvent=events, Coro=threads. It doesn't address multi-cpu processing, though I'm not sure if that is immediately relevant

[19:07] <sjohnson> TimToady: well said

[19:07] <moritz> nine: sounds roughly correct

[19:08] <TimToady> philosophically, you need a monadish translator between the transactional view of processing and the event view

[19:08] <nine> moritz: ok, then I guess that the one I found is a follow up on yours

[19:08] <pmichaud> Perl 6 is a whole street full of lampposts, some of which are lit and some of which we (the implementors) still bang our heads against in the dark.

[19:08] <moritz> nom: say /b/(Cursor."!curosr_init"("abc"), :c(0)).MATCH

[19:08] <p6eval> nom: OUTPUTÂ«Method '!curosr_init' not found for invocant of class 'Cursor'â¤current instr.: '_block1002' pc 105 ((file unknown):336) (/tmp/hqzlJJV7po:1)â¤Â»

[19:08] <moritz> nom: say /b/(Cursor."!cursor_init"("abc"), :c(0)).MATCH

[19:08] <p6eval> nom: OUTPUTÂ«â¤Â»

[19:09] *** Jackneill left
[19:09] <nine> awwaiid: still reading :)

[19:09] <pmichaud> moritz: the :c(0) is part of the cursor init.

[19:09] <pmichaud> (at least currently it is)

[19:09] <pmichaud> it's not part of the regex invocation.

[19:10] <pmichaud> nom:  say /b/(Cursor."!cursor_init"("abc", :c(0))).MATCH

[19:10] <p6eval> nom: OUTPUTÂ«bâ¤Â»

[19:10] <moritz> oh

[19:10] *** birdwindupbird joined
[19:10] <moritz> pmichaud: then disregard my comment, I did it wrongly :-)

[19:11] *** beek_ is now known as Guest83181

[19:11] <masak> Guest18398: I liked 'beek_' better :)

[19:11] <moritz> $ ./perl6 -e 'say "abcbd".match(/b/, :g)'

[19:11] <moritz> b b

[19:11] <moritz> \o/

[19:12] <pmichaud> \o/  moritz++

[19:12] *** kolibrie_ is now known as kolibrie

[19:13] *** im2ee left
[19:18] *** [particle] left
[19:18] *** thou is now known as thou__

[19:21] *** [particle] joined
[19:22] <dalek> rakudo/nom: 5ee4881 | moritz++ | src/core/ (2 files):

[19:22] <dalek> rakudo/nom: unanchor regexes

[19:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5ee48814dd

[19:23] <moritz> nom: /a+ +/

[19:23] <p6eval> nom: OUTPUTÂ«Method 'rxtype' not found for invocant of class 'Integer'â¤current instr.: 'nqp;QRegex;P6Regex;Actions;capnames' pc 63943 (src/stage2/QRegex.pir:19825) (src/stage2/QRegex.nqp:1338)â¤Â»

[19:23] *** thou__ left
[19:23] *** soh_cah_toa joined
[19:23] *** am0c joined
[19:23] *** pyrimidine joined
[19:24] <dalek> roast: e5d54f6 | moritz++ | S05-metasyntax/unknown.t:

[19:24] <dalek> roast: fudge a test that nom accidentally passed before

[19:24] <dalek> roast: review: https://github.com/perl6/roast/commit/e5d54f6745

[19:26] <dalek> rakudo/nom: c2d9fe3 | moritz++ | t/spectest.data:

[19:26] <dalek> rakudo/nom: comment out arrayhash.t again, it only passed by sheer luck before

[19:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2d9fe3883

[19:27] <CBro2007> was just wondering if there is something along the lines of Python Bindings in the pipeline for p6?

[19:27] <moritz> CBro2007: didn't I point you to Zavolaj/NativeCall.pm already?

[19:28] <moritz> or is "Bindings" something else than foreign function interface?

[19:28] <CBro2007> i thought that NativeCall.pm would work only for C code

[19:29] <CBro2007> Python has bindings for several languages

[19:29] <CBro2007> so yeah some sort of a FFI

[19:29] *** birdwindupbird left
[19:29] <masak> moritz, CBro2007: you were talking about Dancing Links in the backlog. I have a YAPC::EU talk lined up about that algorithm, and a corresponding github project. the implementation languages are Perl 5/Moose, C, and Perl 6. have only gotten to the Perl 5/Moose part yet, but there's already a working Dancing Links that you can look at.

[19:29] <CBro2007> masak: ok that was moritz's example ;)

[19:30] <masak> yes.

[19:30] <masak> it's a good one, though, because Dancing Links is frightfully applicable :)

[19:31] <masak> if you want to implement data structures, I'll be happy to discuss ways to make such a project more useful for Rakudo.

[19:31] <masak> er, s/Rakudo/the Perl 6 implementations/

[19:31] <CBro2007> masak: yeah I would like that

[19:31] <CBro2007> masak: I am sure they will come super handy to me in the future too

[19:32] <CBro2007> masak: its just that I might need a library like CGAL (written in C++) - which I could very easily use if I implemented my stuff in Python

[19:32] <masak> CBro2007: I have this feeling about Set and Bag and the other types, that they are an underappreciated force in Perl 6 that don't really come to their right because arrays and hashes have long since established themselves in that semantic niche.

[19:32] <CBro2007> or maybe even p5

[19:33] <CBro2007> masak: yeah but I am thinking more in terms of things like - trees, priority queues etc

[19:33] <masak> CBro2007: so what would be needed would be someone to think long and hard how to make Set and Bag et al. dead easy to use -- such that they are on par with arrays and hashes. that's a challenvge, I think, but one that would pay off big time.

[19:33] <masak> CBro2007: ok, those are nice too. not as central, though.

[19:34] <CBro2007> masak: if you explain how exactly you envision writing Set and Bag then I don't mind working on it with you

[19:34] <CBro2007> though I still have to learn more p6

[19:34] <TimToady> oh, you mean like, make them as much like arrays and hashes as we can while preserving their essential nature...we'll that's what we already have, for the most part

[19:34] <masak> CBro2007: there's already a simple Set implementation in Rakudo master's setting. you can look at it.

[19:34] <TimToady> s/we'll/well

[19:35] <CBro2007> and this I assume is written in p6 yeah?

[19:35] <masak> CBro2007: it's a bit stupd though, and uses uniq which superfluously stringifies everything.

[19:35] <TimToady> if you want to think of a set as a bunch of hash keys, you can

[19:35] <TimToady> and if not, you can't...er...

[19:35] *** wolfman2000 joined
[19:35] <masak> TimToady: yes, I know. I see the potential and the general idea. we're not there yet in practice.

[19:35] <masak> wolfman2000! \o/

[19:36] <wolfman2000> afternoon

[19:36] <CBro2007> masak: can you give me a link to this implementation?

[19:36] <wolfman2000> I keep on forgetting: rakudo is now being replaced or phased out for which interpreter/compiler?

[19:36] <CBro2007> masak: so basically in the set you just want the set of elements to be UNIQUE

[19:36] <TimToady> wolfman2000: for rakudo

[19:36] <moritz> hm, can Kakuro be represented as an exact cover problem?

[19:37] <wolfman2000> TimToady: last time I was active in here, I thought something else was being developed to replace Rakudo. Guess I misread

[19:37] <masak> CBro2007: https://github.com/rakudo/rakudo/blob/master/src/core/Set.pm

[19:37] <TimToady> wolfman2000: it's all rakudo, except where it isn't

[19:37] <tadzik> wolfman2000: maybe the nom branch of rakudo

[19:37] <masak> wolfman2000: Rakudo is getting a new Rakudo, is all.

[19:37] <wolfman2000> tadzik: THAT was it. nom

[19:37] <tadzik> nom nom nom

[19:37] <masak> om nom nom!

[19:38] <wolfman2000> ...either way, don't think it matters. I'll probably wait until Lion comes out before I install Perl 6 again.

[19:38] <masak> awww

[19:38] <pmichaud> wolfman2000: http://rakudo.org/2011/07/19/upcoming-rakudo-releases/

[19:38] <TimToady> just don't wait for Witch, or it'll never be Christmas

[19:38] <benabik> wolfman2000: In theory, that might be tomorrow.

[19:38] *** ciphertext joined
[19:39] *** alexanderpine joined
[19:39] <wolfman2000> benabik: I've heard that too.

[19:39] <tadzik> we'll have to type pretty fas

[19:39] * masak .oO( witchisism )

[19:39] <tadzik> tt

[19:39] <CBro2007> masak: how do you intend to make this implementation better? use some other data structure?

[19:39] *** alexanderpine left
[19:40] <masak> CBro2007: yes, that would be one option. on a total order type, a tree impl would be better, for example.

[19:40] <CBro2007> hm

[19:40] <masak> CBro2007: and there are many cases like that, not just with Set.

[19:40] <masak> Bag isn't even implemented yet in Rakudo.

[19:41] <masak> neither are KeyHash and KeySet, or whatever they're called.

[19:41] <CBro2007> masak: i still have to get to the level where I can understand the code already written here :)

[19:41] <TimToady> but you can define circumfix:<âŸ… âŸ†> at least...

[19:41] <masak> CBro2007: oh, you'll get there in a jiffy. :)

[19:42] <masak> TimToady: looks like two halves of a harp.

[19:42] <sorear> .u âŸ…

[19:42] <tadzik> .u âŸ†

[19:42] <phenny> U+27C5 LEFT S-SHAPED BAG DELIMITER (âŸ…)

[19:42] <phenny> U+27C6 RIGHT S-SHAPED BAG DELIMITER (âŸ†)

[19:42] <tadzik> sorear: high five :)

[19:42] <sorear> o/

[19:42] <tadzik> or maybe, high-six

[19:42] <tadzik> it looks like a pair of snakes to me

[19:42] <TimToady> oâŸ…âŸ†o

[19:42] <benabik> Looks like boxes to me.  Bad font.  :-(

[19:43] <TimToady> try the browser

[19:43] <CBro2007> masak: why isn't a perl hash used?

[19:43] <TimToady> supposed to look like a bag: âŸ…_âŸ†

[19:44] <masak> CBro2007: I think I used that initially, but wanted to avoid the stringification of the objects in the Set.

[19:44] <TimToady> you don't want to have to think about .keys just to get the set elements out

[19:44] <masak> CBro2007: little did I know that uniq used hashes underneath :(

[19:44] <moritz> what else should it use?

[19:44] <TimToady> yes, well, hashes are supposed to allow === semantics

[19:45] <moritz> O(n^2) comparisons?

[19:45] <masak> moritz: it should respect the immutability of non-Str types.

[19:45] <moritz> nom: say 2.WHICH

[19:45] <p6eval> nom: OUTPUTÂ«45605280â¤Â»

[19:45] <moritz> nom: say 2.WHICH; 2.WHICH

[19:45] <p6eval> nom: OUTPUTÂ«61706536â¤Â»

[19:45] <moritz> nom: say 2.WHICH; say 2.WHICH

[19:45] <p6eval> nom: OUTPUTÂ«73871656â¤73871656â¤Â»

[19:45] <masak> yes, probably something with .WHICH

[19:46] <TimToady> nom: say 2.WHICH; say (1+1).WHICH

[19:46] <p6eval> nom: OUTPUTÂ«64528680â¤52133728â¤Â»

[19:46] <moritz> :o/

[19:46] <masak> TimToady and I discussed it a few weeks ago, but neither of us spec'd it.

[19:46] <TimToady> nom: say 2 === 1+1

[19:46] <p6eval> nom: OUTPUTÂ«Bool::Trueâ¤Â»

[19:46] <moritz> whoa

[19:47] <CBro2007> I assume that the Set can have any type of objects in it yeah and so how do you propose we make a comparison to check if objects are equal?

[19:47] <TimToady> that's what === means

[19:47] <masak> yes, uniq should use ===, which uses .WHICH

[19:47] <TimToady> but see above

[19:47] <CBro2007> ah i see

[19:47] <masak> aye.

[19:48] <TimToady> methinks === is cheating

[19:48] <CBro2007> so are we saying that this implementation is ok now? 

[19:48] <pmichaud> of course it's cheating :)

[19:48] <sorear> niecza: say 2 === 1+1

[19:48] <TimToady> CBro2007: universals are problemantic

[19:48] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«Bool::Falseâ¤Â»

[19:49] <TimToady> oopsie

[19:49] <TimToady> niecza: say 2.WHAT; say (1+1).WHAT

[19:49] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«Int()â¤Int()â¤Â»

[19:50] <TimToady> niecza: say 2.WHICH; say (1+1).WHICH

[19:50] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«Unhandled exception: Unable to resolve method WHICH in class Intâ¤  at /tmp/u7d82Y4anU line 1 (MAIN mainline @ 1) â¤  at /home/p6eval/niecza/lib/CORE.setting line 1891 (CORE C885_ANON @ 2) â¤  at /home/p6eval/niecza/lib/CORE.setting line 1892 (CORE module-COREâ€¦

[19:52] <CBro2007> just while you guys are at it : 

[19:52] <CBro2007> our multi sub  infix:<(|)>(    @a, %b) { Set.new(|@a).union(%b) }

[19:52] <CBro2007> our multi sub  infix:<(|)>(    @a, @b) { Set.new(|@a).union(@b) }

[19:52] <CBro2007> is that like C++ operator overloading?

[19:53] <CBro2007> so  "a|b" means a union b?

[19:53] <masak> (|)

[19:53] <masak> yes

[19:53] <TimToady> a (|) b

[19:53] <CBro2007> gotcha

[19:53] <CBro2007> ok

[19:53] <CBro2007> hmm

[19:53] *** timbunce_ joined
[19:53] <TimToady> but unlike C++ new operators are encouraged over reusing unrelated old operators

[19:54] <TimToady> << for IO (shudder)

[19:54] <sorear> TimToady: In 'my @a[EXPR]; ' when is EXPR evaluated?

[19:54] <masak> unless the new type is actually a number. :)

[19:54] <sorear> I can make arguments for BEGIN, ENTER, and DO

[19:54] <CBro2007> and it would be stupid to write separate implementations for the different types using multi?

[19:54] <CBro2007> so a Set of Numeric would behave differently from a Set of Strings maybe

[19:54] <TimToady> sorear: so can I :)

[19:54] <masak> CBro2007: what do you mean? that's what's done above.

[19:55] <CBro2007> guess that would be a lot of work

[19:55] <TimToady> I figure, though, that if it's DO, and a constant, we can promote it to BEGIN

[19:55] <TimToady> likewise ENTER if it's a ro param

[19:55] <TimToady> and most such declarations will be constants anyway

[19:56] <TimToady> so I think DO is more general, if a bit more tormenty

[19:56] *** timbunce left
[19:56] *** timbunce_ is now known as timbunce

[19:56] <CBro2007> masak: I mean that we didn't want to use hashes and we said there is a problem in using === , then can it be resolved if we looked at the types in a case by case basis?

[19:56] <CBro2007> masak: coz right now the implementation is trying to do this in a generic manner yeah? I could be wrong

[19:57] <masak> CBro2007: I think uniq should use ===, and that Rakudo maybe shouldn't cheat with .WHICH :)

[19:57] <masak> CBro2007: (but the fact that it does doesn't really matter in this case)

[19:57] <pmichaud> masak: patches welcome.

[19:57] <sorear> TimToady: DO is probably easiest, actually, although it raises the question of what   say @*foo.perl; my $x = rand; my @*foo[$x]; does

[19:57] <CBro2007> ok

[19:58] <masak> pmichaud: ok, noted. will think about a solution in my copious spare time :P

[19:58] <pmichaud> masak: :)

[19:58] <sorear> masak: are you familiar with the gist embed widget?

[19:58] <masak> sorear: nopes.

[19:58] <TimToady> CBro2007: it would certainly be possible to define set as a generic role that can be instantiated to accept only a particular type

[19:59] <TimToady> and just autopuns to Any if you don't supply a type

[19:59] * TimToady thinks about a Bag of Candy

[19:59] <CBro2007> well you are the champ here mate.. I just started looking at p6 2 days ago :)

[20:00] * TimToady floats off cross-legged and smashes into a lamppost

[20:00] <masak> :P

[20:01] <masak> TimToady: be glad there are no flying cars yet!

[20:01] <sorear> o/ CBro2007

[20:01] <sorear> fresh blood is always useful

[20:01] * TimToady sharpens his fangs

[20:01] *** mkramer joined
[20:01] <CBro2007> hehe

[20:01] *** mkramer left
[20:02] *** spinclad left
[20:02] <masak> wow. hasty jump from a floating-guru metaphor to a vampire metaphor there. :)

[20:02] * TimToady blames the lamppost

[20:02] <masak> but some vampires fly, I guess.

[20:06] <TimToady> TheDamian never mentioned *how* I manage to be thousands of years old...

[20:09] <TimToady> why do you think I sleep so much during the day? :)

[20:09] <TimToady> nap &

[20:12] <masak> I always thought it had to do with time travel, like the Italian Perl Mongers suggested.

[20:12] *** spinclad joined
[20:14] *** supernovus joined
[20:16] *** tokuhirom joined
[20:18] <supernovus> So, to call a method that you don't know the name at runtime, you can do $object."$method"();  What if I want to create an instance of an object where I don't know it's class up front. Say $classname contains the string name of the class, it does not appear possible to do $classname.new(); or "$classname".new();  The only way I've found to do this is $object = eval("$classname.new");  which seems rather hackish. Is there a better 

[20:18] <supernovus> way?

[20:19] *** molaf left
[20:20] <moritz> ::($classname).new, once it's implemented

[20:20] <masak> std: my $classname = "Foo"; ::($classname).new

[20:20] <p6eval> std 516268a: OUTPUTÂ«ok 00:01 121mâ¤Â»

[20:20] <masak> niecza: class Foo {}; my $classname = "Foo"; say ::($classname).new

[20:21] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Cannot make a compile time reference to the semantic root package at /tmp/1DIQrUw_db line 1:â¤------> [32my $classname = "Foo"; say ::($classname)[33mâ[31m.new[0mâ¤â¤Unhandled exception: Check failedâ¤â¤  at /home/p6eval/nieczâ€¦

[20:21] <benabik> nom: ::('List').new

[20:21] <p6eval> nom: OUTPUTÂ«Indirect name lookups not yet implemented at line 1, near ".new"â¤current instr.: 'nqp;HLL;Grammar;panic' pc 23533 (src/stage2/gen/NQPHLL.pir:6314) (src/stage2/gen/NQPHLL.pm:328)â¤Â»

[20:21] <moritz> nom: say pir::find_lex('Int')

[20:21] <p6eval> nom: OUTPUTÂ«error:imcc:The opcode 'find_lex_p' (find_lex<1>) was not found. Check the type and number of the argumentsâ¤ in file '(file unknown)' line 12512675â¤Â»

[20:21] <moritz> nom: say pir::find_lex__PS('Int')

[20:21] <p6eval> nom: OUTPUTÂ«Int()â¤Â»

[20:21] <masak> sorear: what does that mean?

[20:21] <moritz> nom: say pir::find_lex__PS('Unknown')

[20:21] <p6eval> nom: OUTPUTÂ«Null PMC access in find_method('gist')â¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:22] <supernovus> Awesome, I'll document that in the comments, and leave it with the eval for now. I figured there would be some plan to cover this kind of functionality.

[20:22] <pmichaud> seems like nom could implement ::(EXPR) interpolation relatively easily.

[20:23] <moritz> nom: class A { }; say pir::find_lex__PS('A')

[20:23] <p6eval> nom: OUTPUTÂ«A()â¤Â»

[20:23] <moritz> pmichaud: that's what I just concluded too :-)

[20:25] <supernovus> I haven't been brave enough to test nom yet.

[20:25] <PerlJam> supernovus: soon you won't have to be brave as it'll be the default  :-)

[20:25] <moritz> pmichaud: what's the best way? a builtin that uses find_caller_lex ?

[20:26] <pmichaud> moritz: that's what I'd try first, yes.

[20:26] <moritz> nom: class A::B { }; say pir::find_lex__PS('A::B')

[20:26] <p6eval> nom: OUTPUTÂ«Null PMC access in find_method('gist')â¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:26] <moritz> nom: class A::B { }; say pir::find_lex__PS('A')

[20:26] <p6eval> nom: OUTPUTÂ«Null PMC access in find_method('gist')â¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:26] <masak> ah, so not "works in nom", but "relatively easy to implement in nom" :)

[20:26] <moritz> ah well, it's a first shot

[20:26] <pmichaud> I'm a little surprised that second one didn't work.

[20:27] * moritz too

[20:27] <moritz> could be our-scoped though

[20:27] <supernovus> PerlJam: Awesome! I hope... :-)

[20:27] <benabik> nom: class A::B { }; say pir::find_lex__PS('B') # shouldn't work

[20:27] <p6eval> nom: OUTPUTÂ«Null PMC access in find_method('gist')â¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:27] <pmichaud> nom: our class A::B { };  say pir::find_lex__Ps('A');

[20:27] <p6eval> nom: OUTPUTÂ«Null PMC access in find_method('gist')â¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:27] *** jaldhar left
[20:27] <moritz> nom: package A { class B { } }; say pir::find_lex__PS('A')

[20:27] <p6eval> nom: OUTPUTÂ«No method cache and no find_method method in meta-objectâ¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:27] <moritz> wow

[20:28] <benabik> nom: package A { }; say A

[20:28] <p6eval> nom: OUTPUTÂ«No method cache and no find_method method in meta-objectâ¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:28] <benabik> Consistent, at least.

[20:28] <moritz> seems that 'package' isn't really well implemented

[20:28] <pmichaud> nom: package A { };  say A.WHAT;

[20:28] <p6eval> nom: OUTPUTÂ«No method cache and no find_method method in meta-objectâ¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:28] *** jaldhar joined
[20:28] <pmichaud> it's still bootstrappish, so might be incomplete.

[20:28] <pmichaud> nom:  package A { };  say A.^parents;

[20:28] <p6eval> nom: OUTPUTÂ«No method cache and no find_method method in meta-objectâ¤current instr.: '_block1002' pc 79 ((file unknown):525) (/tmp/5KtqsG3IzX:1)â¤Â»

[20:30] <sorear> masak: I think it means that it parsefailed and got very confused.

[20:30] <masak> ah.

[20:30] <moritz> nom: my Mu $x := pir::null__P(); say 'alive'

[20:30] <p6eval> nom: OUTPUTÂ«aliveâ¤Â»

[20:31] <masak> nom: my Mu $x := pir::null__P(); say $x

[20:31] <p6eval> nom: OUTPUTÂ«Null PMC access in find_method('gist')â¤current instr.: 'say' pc 446947 (src/gen/CORE.setting.pir:114083) (src/gen/CORE.setting:3509)â¤Â»

[20:31] <[Coke]> Anything rakudo needs from parrot before 3.7?

[20:32] <[Coke]> (well, /in/ 3.7)

[20:32] *** Holy_Cow joined
[20:33] <moritz> a fast JIT compiler

[20:33] <moritz> subroutine exit hooks

[20:34] <moritz> faster exceptions

[20:34] <masak> ability to implement DESTROY methods

[20:34] <moritz> that might already be there

[20:35] <moritz> but so far I didn't dare to touch the 6model code to try it out

[20:35] <masak> that's a no-op, then :)

[20:36] <[Coke]> those sound more like wants. ;)

[20:36] *** timbunce left
[20:36] <flussence> I want the \d$ thing in sprintf!

[20:36] <moritz> [Coke]: don't go all nit-picky :-)

[20:36] <masak> I want Perl 6 to be as fully implemented as possible, as soon as possible. :)

[20:36] *** Mowah left
[20:37] *** Chillance left
[20:37] <tadzik> and as correctly as possible

[20:39] <moritz> std: A::('x')::B

[20:39] <p6eval> std 516268a: OUTPUTÂ«ok 00:01 119mâ¤Â»

[20:39] <moritz> urks

[20:39] <moritz> supporting that kind of lookup will not fall out easily from the current factoring

[20:40] <masak> why not?

[20:41] <pmichaud> for now, just focus on the ::( )  form with the leading ::, I think.

[20:41] <moritz> pmichaud: that's what I do

[20:41] <tadzik> [Coke]: oh, and no forbidden-in-C practices :)

[20:41] <tadzik> [Coke]: see http://wklej.org/id/561555/

[20:41] <benabik> I'd think A::('x')::B would end up translating to A::('x')::('B') behind the scenes.

[20:42] <moritz> masak: because the easist approach is to installl a lookup for token morename, which parses ::(<EXPR>)

[20:42] <masak> I see.

[20:42] <masak> well, what pmichaud said :)

[20:42] <moritz> and A::B is basically parsed as <name> <morename>

[20:42] <moritz> what I could do is fiddling the action methods for token name

[20:43] <moritz> but that's something for later, yes

[20:46] <moritz> $ ./perl6 -e 'say INDIRECT_NAME_LOOKUP("Int")'

[20:46] <moritz> Int()

[20:46] <moritz> first step :-)

[20:47] <masak> moritz++

[20:50] <tadzik> oh, moritz++ indeed

[20:50] <tadzik> that'll help Pod too!

[20:50] <tadzik> The Pod::Block::Named::Foo thingy

[20:50] <masak> \o/

[20:50] *** donri left
[20:51] <moritz> tadzik: ... which my current patch won't do :(

[20:51] <masak> not evern with INDIRECT_NAME LOOKUP("Pod::Block::Named::$name")?

[20:52] <moritz> masak: no, I don't know how to look up such a type

[20:52] <masak> oh.

[20:52] <tadzik> aw

[20:52] <masak> neither do I.

[20:52] <tadzik> oh wait, I think I patched that in SymbolTable in the podparser branch

[20:52] <tadzik> maybe it's that thing, let me look it up

[20:53] <moritz> tadzik: is the SymbolTable accessable at run time?

[20:53] <sorear> masak: I'm kinda at a loss for what to do.  colomon++ is tackling trig

[20:53] <tadzik> moritz: see https://github.com/rakudo/rakudo/commit/82b7267d78178

[20:53] <tadzik> maybe that'll help

[20:53] <tadzik> moritz: oh, probably not really

[20:54] *** Holy_Cow left
[20:54] <masak> sorear: I guess you mean that you don't have a clear idea what to tackle next. I can't imagine that there's a lack of options. :)

[20:54] *** lichtkind joined
[20:55] <moritz> look at a spectest file that doesn't pass; make it pass; repeat until done

[20:57] *** wamba left
[21:00] <moritz> $ ./perl6 -e 'say ::(Int)'

[21:00] <moritz> Could not locate compile-time value for symbol (Int)

[21:00] <moritz> :(

[21:00] <moritz> oh, I'm doing it RONG

[21:01] <moritz> still the same error if you say ::("Int")

[21:01] *** am0c left
[21:02] <moritz> seems like some action method does something token morename that it shouldn't

[21:04] <masak> rakudo: s/ /_/g

[21:04] <p6eval> rakudo f63b82: OUTPUTÂ«===SORRY!===â¤Unsupported use of /g; in Perl 6 please use :g at line 22, near ""â¤Â»

[21:04] <masak> rakudo++

[21:06] <moritz> std: s/ /_/g

[21:06] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Null pattern not allowed at /tmp/64hme9uuMg line 1:â¤------> [32ms/ [33mâ[31m/_/g[0mâ¤    expecting quantifierâ¤Parse failedâ¤FAILED 00:01 119mâ¤Â»

[21:06] <moritz> thought so :-)

[21:06] <moritz> std++

[21:07] <sorear> niecza: s/ /_/g

[21:07] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Null pattern not allowed at /tmp/bg6izzAGwD line 1:â¤------> [32ms/ [33mâ[31m/_/g[0mâ¤â¤Parse failedâ¤â¤Â»

[21:07] <sorear> niecza: s/./_/g

[21:07] <p6eval> niecza v7-39-gfe88724: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤â¤Unsupported use of suffix regex modifiers; in Perl 6 please use prefix adverbs at /tmp/PA_T1ztkH9 line 1 (EOF):â¤------> [32ms/./_/g[33mâ[31m<EOL>[0mâ¤Other potential difficulties:â¤  Unsupported use of /g; in Perl 6 please â€¦

[21:07] <moritz> niecza++

[21:07] <sorear> std: s/./_/g

[21:07] <p6eval> std 516268a: OUTPUTÂ«[31m===[0mSORRY![31m===[0mâ¤Unsupported use of suffix regex modifiers; in Perl 6 please use prefix adverbs at /tmp/A9hIDr2xXc line 1:â¤------> [32ms/./_/g[33mâ[31m<EOL>[0mâ¤Other potential difficulties:â¤  Unsupported use of /g; in Perl 6 please use :g at /tmp/A9â€¦

[21:10] <dalek> rakudo/nom-indirect-name-lookup: fcd142d | moritz++ | src/ (3 files):

[21:10] <dalek> rakudo/nom-indirect-name-lookup: first attempt at indirect name loookup.

[21:10] <dalek> rakudo/nom-indirect-name-lookup: 

[21:10] <dalek> rakudo/nom-indirect-name-lookup: Does not work yet, method term:sym<name> in Actions.pm needs to learn

[21:10] <dalek> rakudo/nom-indirect-name-lookup: not to touch indirect name lookups first

[21:10] <dalek> rakudo/nom-indirect-name-lookup: review: https://github.com/rakudo/rakudo/commit/fcd142d9ce

[21:10] * moritz should make shorter branch names

[21:12] * moritz -> sleep

[21:12] <sorear> ooh, sleep, this is my chance! :D

[21:14] *** am0c joined
[21:16] <masak> perchance to dream. ay, there's the rub.

[21:17] *** kaare__ left
[21:22] *** bluescreen10 left
[21:22] *** supernovus left
[21:24] <masak> rakudo: my @a = "OH HAI"; say so "OH HAI" ~~ /<@a>/

[21:24] <p6eval> rakudo f63b82: OUTPUTÂ«Bool::Falseâ¤Â»

[21:24] <masak> I think this is wrong.

[21:24] * masak submits rakudobug

[21:25] <masak> The default way in which the engine handles a string scalar is to match it as a C<< '...' >> literal (i.e. it does not treat the interpolated string as a subpattern).

[21:25] <masak> (from S05)

[21:26] <masak> rakudo: my @a = "OH\\sHAI"; say so "OH HAI" ~~ /<@a>/

[21:26] <p6eval> rakudo f63b82: OUTPUTÂ«Bool::Trueâ¤Â»

[21:26] <masak> uurgh,

[21:26] <masak> .

[21:27] <masak> rakudo: my $x = "OH\\sHAI"; say so "OH HAI" ~~ /<$x>/

[21:27] <p6eval> rakudo f63b82: OUTPUTÂ«Bool::Trueâ¤Â»

[21:27] <masak> oh! it occurs for scalars as well.

[21:28] <benabik> rakudo: my @a = "string?"; say @a.perl

[21:28] <p6eval> rakudo f63b82: OUTPUTÂ«["string?"]â¤Â»

[21:29] <benabik> Ah.  It becomes a one element list.  Makes sense.

[21:29] <sorear> masak: I think <@a> is quite completely unimplemented

[21:30] <masak> sorear: it felt like it worked when I tried it on one-word strings.

[21:30] <masak> and ISTR someone working on it in Rakudo around the time ng landed.

[21:32] <tadzik> ennnnnnnd: http://redmine.ruby-lang.org/issues/5054

[21:33] <masak> reminds me of ] in Lisp for "close all open parentheses".

[21:34] *** kjeldahl left
[21:36] <benabik> tadzik: I like comment #20: "I think the phrase "fold up" is more descriptive of what this is attempting to do."

[21:37] *** bluescreen10 joined
[21:37] * flussence sees that, almost falls out of chair

[21:37] <masak> I think a feature like that would at least complicate code refactoring.

[21:38] <masak> s/at least/in the best case/

[21:42] <flussence> it's easier to condense to one line when you have punctuation instead of words, but it's still pretty nasty to maintain: https://gist.github.com/1093796

[21:42] <[Coke]> bah. Just make your editor a compiler, and have it dynamically replace ] with the appropriate # of )'s

[21:45] <flussence> {I even caught myself writing a /(}\s+)+/ mess today at $dayjob, made the inside a sub instead which was much nicer.}

[21:45] *** bluescreen10 left
[21:46] <flussence> I try to follow Linus' guideline of (loosely paraphrased): "if you're using more than 3 levels of indentation, you're doing it wrong"

[21:47] <[Coke]> that's

[21:47] <[Coke]>   not

[21:48] <masak> I find that doesn't always hold. see what you think of array multiplication, for example.

[21:48] <[Coke]>     entirely

[21:48] <[Coke]>       crazy.

[21:48] <masak> [Coke]: sorry, for barging in on your visual pun :)

[21:48] *** Psyche^ joined
[21:48] *** Psyche^ is now known as Patterner

[21:48] <[Coke]> o/~~

[21:48] <masak> s/,//

[21:48] <[Coke]> nope, that doesn't look a fist shaking.

[21:48] <[Coke]> more like armpit hair.

[21:48] <masak> eww

[21:50] <[Coke]> one line ascii art is hard.

[21:51] <flussence> Unicode doesn't have a "MAN SHAKING FIST IN AIR" glyph either :(

[21:51] <sjohnson> unicode art is easier

[21:51] <sjohnson> .u ying yang

[21:51] <phenny> sjohnson: Sorry, no results for 'ying yang'.

[21:51] <tadzik> speaking of unicode art, sjohnson...

[21:51] <sjohnson> ï¼ˆã€€ï½€ãƒ¼Â´ï¼‰

[21:52] <sjohnson> .u ï¼ˆã€€ï½€ãƒ¼Â´ï¼‰

[21:52] <phenny> sjohnson: U+FF08 U+3000 U+FF40 U+30FC U+00B4 U+FF09

[21:52] <sjohnson> (FAT FACE)

[21:52] <tadzik> yeah :)

[21:52] <[Coke]> .u yin

[21:52] <phenny> U+262F YIN YANG (â˜¯)

[21:52] <[Coke]> .u there

[21:52] <phenny> U+2203 THERE EXISTS (âˆƒ)

[21:53] <flussence> .oO( I wish there was a tool that lists which local fonts have a given codepoint... ) 

[21:54] <sjohnson> .u trollfeace

[21:54] <phenny> sjohnson: Sorry, no results for 'trollfeace'.

[21:54] <sjohnson> oops

[21:55] <sjn> hehe

[21:55] * sjn wonders what it takes to get that image into the spec :)

[21:57] <sjohnson> .u FOREVER ALONE

[21:57] <phenny> sjohnson: Sorry, no results for 'FOREVER ALONE'.

[21:57] <masak> RT is down :(

[21:58] <[Coke]> seen robrt?

[21:58] <aloha> Sorry, I haven't seen robrt.

[22:00] <[Coke]> hurm. it's responding slooooooooooooooooooooooooowly.

[22:08] <[Coke]> masak: did you open a ticket ?

[22:08] <[Coke]> you know, metaphorically?

[22:08] <[Coke]> if not, I can ping Robrt.

[22:11] <masak> [Coke]: I didn't. please do.

[22:11] *** drbean joined
[22:13] <[Coke]> masak?

[22:13] <[Coke]> phenny, masak?

[22:13] <[Coke]> bot hell.

[22:14] <[Coke]> no cc for you.

[22:15] <masak> that's fine. I'll notice when it's up again :)

[22:17] <masak> 'night, #perl6

[22:17] *** masak left
[22:18] <[Coke]> should be back now

[22:18] <[Coke]> ask++

[22:55] *** miso2217__ left
[22:56] *** miso2217 joined
[22:59] *** impious joined
[23:18] *** impious left
[23:20] *** ggoebel left
[23:24] *** ggoebel joined
[23:29] *** ggoebel left
[23:30] *** orafu joined
[23:33] *** Khisanth joined
[23:34] <dalek> book: 0e7afd7 | (Sveinn Sandvik Svendsen)++ | src/basics.pod:

[23:34] <dalek> book: Corrected a spelling mistake in a label

[23:34] <dalek> book: review: https://github.com/perl6/book/commit/0e7afd7d5c

[23:34] <dalek> book: 5b40d35 | smash++ | src/basics.pod:

[23:34] <dalek> book: Merge pull request #57 from sveinns/master

[23:34] <dalek> book: 

[23:34] <dalek> book: A small spelling mistake corrected.

[23:34] <dalek> book: review: https://github.com/perl6/book/commit/5b40d3540f

[23:34] <sorear> smash: is Sveinn on iRC?

[23:35] *** ggoebel joined
[23:39] *** ggoebel left
[23:43] <smash> sorear: sorry, don't know

[23:45] <smash> bbt

[23:45] *** ggoebel joined
[23:45] *** smash left
[23:46] *** thou__ joined
[23:48] *** CBro2007 left
[23:58] *** dayangkun joined
