[00:02] <TimToady> one can find many philosophers who will tell you it's okay to be selfish, but even Jesus said "Love your neighbor as yourself" meaning much the same thing: you can't love other people if you haven't learned how to love yourself.

[00:04] <ahmad_> TimToady: well it is not easy to love yourself more than anyone.. for example i love my children more than myself. i do make my life harder to make sure their life will be easier.. so the human should be giving by nature..

[00:05] <TimToady> sure, I think the saying is more about quality than quantity. :)

[00:06] <ahmad_> agreed.. 

[00:07] *** wolfman2000 joined
[00:23] *** zby_home__ left
[00:27] <ahmad_> i guess the best quotes i ever read were by Nietzsche.. like “Amor Fati – “Love Your Fate”, which is in fact your life.” 

[00:27] <ahmad_> good night all

[00:29] *** ahmad_ left
[00:30] *** proller_ left
[00:32] *** thou joined
[00:33] *** shinobicl___ left
[00:34] *** bluescreen100 joined
[00:35] *** ksi left
[00:38] *** lutok left
[00:38] <dalek> nqp/qbootstrap: fed8d1f | jnthn++ | tools/build/Makefile.in:

[00:38] <dalek> nqp/qbootstrap: A couple more dependency fixes.

[00:38] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/fed8d1f80f

[00:38] <dalek> nqp/qbootstrap: 4223af2 | jnthn++ | src/QHLL/Compiler.pm:

[00:38] <dalek> nqp/qbootstrap: Remove currently unused rxtrace arg.

[00:38] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/4223af283c

[00:38] <dalek> nqp/qbootstrap: 3ec2f33 | jnthn++ | src/ (3 files):

[00:38] <dalek> nqp/qbootstrap: Some tweaks, one very much a hack, to get us through the build again.

[00:38] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/3ec2f334e7

[00:38] <dalek> nqp/qbootstrap: 9b81195 | jnthn++ | src/NQPQ/Grammar.pm:

[00:38] <dalek> nqp/qbootstrap: Temporary hack during migration to NQP::Grammar.TOP. With this, we actually get a little way into parsing.

[00:38] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/9b81195849

[00:38] <dalek> nqp/qbootstrap: 0815cde | jnthn++ | src/QHLL/Grammar.pm:

[00:38] <dalek> nqp/qbootstrap: Fix MARKER/MARKED to work with QRegex.

[00:38] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/0815cdea01

[00:38] <dalek> nqp/qbootstrap: a0c3e8a | jnthn++ | src/QRegex/Cursor.nqp:

[00:38] <dalek> nqp/qbootstrap: Implement missing ww.

[00:38] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/a0c3e8a12d

[00:40] *** bluescreen100 left
[00:42] *** bluescreen10 left
[00:42] *** az5112 left
[00:42] * jnthn wonders if he can crack the QRegex migration during the weekend...

[00:42] <jnthn> Anyway, should rest a bit... &

[00:43] *** huf left
[00:53] *** huf joined
[00:58] *** am0c left
[01:06] <kshannon> jnthn: I hope we can bring rxtrace back after you get the bootstrap working - I've found it be invaluable.

[01:08] *** buubot_backup left
[01:10] *** proller joined
[01:11] <dalek> specs: 02361b0 | larry++ | S32-setting-library/Numeric.pod:

[01:11] <dalek> specs: spec stringified forms of Complex and Rat

[01:11] <dalek> specs: review: https://github.com/perl6/specs/commit/02361b0967

[01:13] *** nebuchad` joined
[01:13] *** nebuchadnezzar left
[01:13] *** MayDaniel left
[01:14] *** proller left
[01:24] *** japhb_ joined
[01:27] <japhb_> TimToady, your latest spec commit seems to have a copy paste error; line 533 says "complex literals" when it appears you meant "rational literals" or "Rat literals".

[01:29] *** buubot_backup joined
[01:30] <sorear> What's the correct syntax to use for L<> in roast files, or should I just not worry about it?

[01:37] <colomon> nom: (1, 1, -> $a, $b { say $a.perl; say $b.perl; $a + 1, $b * 2 } ... *)[^4]

[01:37] <p6eval> nom 975b6b: OUTPUT«1␤1␤2␤2␤»

[01:37] <dalek> niecza: 142a619 | sorear++ | lib/ (2 files):

[01:37] <dalek> niecza: Implement new Rat/Complex stringification spec

[01:37] <dalek> niecza: review: https://github.com/sorear/niecza/commit/142a619390

[01:37] <colomon> sorear++

[01:39] <colomon> errr... I take it parsing them doesn't work yet?

[01:40] <colomon> nom: (1, 1, -> $a, $b { say $a.perl; say $b.perl; $a + 1, $b * 2 } ... *)[^10]

[01:40] <p6eval> nom 975b6b: OUTPUT«1␤1␤2␤2␤3␤4␤4␤8␤5␤16␤6␤32␤7␤64␤8␤128␤»

[01:40] <sorear> mm?

[01:42] <colomon> <1/2> isn't a Rat yet

[01:42] <sorear> no

[01:42] <colomon> (the sequence is the other thing I'm working on)

[01:42] *** jaldhar joined
[01:43] <colomon> nom: say (1, 1, { $^a + 1, $^b * 2 } ... *)[^10]

[01:43] <p6eval> nom 975b6b: OUTPUT«1 1 2 2 3 4 4 8 5 16 6 32 7 64 8 128 9 256␤»

[01:44] <colomon> niecza: (1, 1, -> $a, $b { say $a.perl; say $b.perl; $a + 1, $b * 2 } ... *)[^10]

[01:44] <p6eval> niecza v13-144-gf7281f0: OUTPUT«1␤1␤1␤$(2, 2)␤$(2, 2)␤$(2, 4)␤$(2, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤$(3, 4)␤»

[01:44] <colomon> there we go

[01:46] *** skids joined
[01:47] <skids> nom: class A is IO { has $chomp = False; }; my A $a .= new; $a.perl.say;

[01:47] <p6eval> nom 975b6b: OUTPUT«A.new()␤»

[01:48] <skids> hrm.

[01:48] * skids golfs

[01:48] <sorear> niecza: say (4.5**60).perl

[01:48] <p6eval> niecza v13-144-gf7281f0: OUTPUT«1797010299914431210413179829509605039731475627537851106401/1152921504606846976␤»

[01:49] <sorear> rakudo: say (4.5**60).perl

[01:49] <p6eval> rakudo 975b6b: OUTPUT«1797010299914431210413179829509605039731475627537851106401/1152921504606846976␤»

[01:51] <skids> nom: class A is IO { has $.chomp = False; }; my A $a .= new; $a.perl.say;

[01:51] <p6eval> nom 975b6b: OUTPUT«A.new(chomp => Bool::False)␤»

[01:52] <skids> nom: class B { has $.a = 0; }; class A is B { has $.a = 1; }; my A $a .= new; $a.perl.say

[01:52] <p6eval> nom 975b6b: OUTPUT«A.new(a => 1, a => 1)␤»

[01:52] <skids> OK, so is that supposed to be the right way to override a default value for an attribute, and if so, why the extra pair?

[01:53] *** japhb_ left
[01:54] *** kaleem joined
[01:54] <dalek> niecza: ae314ef | sorear++ | t/spectest.data:

[01:54] <dalek> niecza: Run S32-num/stringify.t

[01:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ae314efb3d

[01:54] <dalek> roast: 1596c94 | sorear++ | S32-num/stringify.t:

[01:54] <dalek> roast: Add tests for perl6/specs@02361b0

[01:54] <dalek> roast: review: https://github.com/perl6/roast/commit/1596c9438f

[01:54] <colomon> skids: no, you've just sayid that both A and B have a $.a

[01:56] <colomon> *said

[01:56] <skids> Hrm... well, out of curiosity, how would you distinguish $a.a (A's a) and $a.a (B's a)? And is there a way to override defaults other than writing a constructor?

[01:57] <colomon> niecza: class B { has $.a = 0; }; class A is B { has $.a = 1; }; my A $a .= new; $a.perl.say

[01:57] <p6eval> niecza v13-144-gf7281f0: OUTPUT«A.new(...)␤»

[01:58] <sorear> colomon: the answer you're looking for is no, Niecza doesn't implement two-keyed attribute names yet.

[01:59] <colomon> two-keyed?

[01:59] <colomon> doesn't handle this case, you mean?

[01:59] <sorear> class+name

[01:59] <sorear> nom: class B { has $.a = 0; }; class A is B { has $.a = 1; }; my A $a .= new; $a.perl.say

[01:59] <p6eval> nom 975b6b: OUTPUT«A.new(a => 1, a => 1)␤»

[01:59] <sorear> hah

[01:59] <sorear> looks like it's a little broken in nom too :D

[02:00] <sorear> colomon: btw, 76 new spectests for niecza :p

[02:00] <sorear> (should be LHF for Rakudo too)

[02:00] <colomon> yeah, I noticed.  :)

[02:00] <colomon> sorear++

[02:02] <kshannon> nom: class B { has $.a = 0; }; class A is B { has $.a = 1; }; my A $a .= new; $a.B::a = 3; $a.perl.say

[02:02] <p6eval> nom 975b6b: OUTPUT«===SORRY!===␤Cannot assign to a readonly variable or a value␤»

[02:02] *** fsergot joined
[02:03] <TimToady> I would not worry about L<> at the moment, since we're rapidly approaching the point at which we should restructure the entire spec and make it wikifiabler.

[02:03] <kshannon> nom: class B { has $.a = 0; method set_a ($new_a) { $!a = $new_a; } }; class A is B { has $.a = 1; }; my A $a .= new; $a.set_a(3); $a.perl.say

[02:03] <p6eval> nom 975b6b: OUTPUT«A.new(a => 1, a => 1)␤»

[02:03] <kshannon> :)

[02:03] <kshannon> nom: class B { has $.a = 0; method set_a ($new_a) { $!a = $new_a; } }; class A is B { has $.a = 1; }; my A $a .= new; $a.set_a(3); $a.perl.say; say $a.B::a;

[02:03] <p6eval> nom 975b6b: OUTPUT«A.new(a => 1, a => 1)␤3␤»

[02:04] <kshannon> Hmm,  I think that's a bug in .perl

[02:04] <dalek> specs: dc9dfec | larry++ | S32-setting-library/Numeric.pod:

[02:04] <dalek> specs: pasto noted by japhb++

[02:04] <dalek> specs: review: https://github.com/perl6/specs/commit/dc9dfecdeb

[02:05] <colomon> kshannon: yeah, that's what I was thinking.

[02:05] <sorear> TimToady: wait, wait, what?

[02:06] <TimToady> most of the synopses are still of the form "here's what we changed from Perl 5"

[02:07] <TimToady> we need to reorganize the spec to be more standalone

[02:07] <TimToady> while we're at it, a lot of bullet points need to turn into headings, though diakopter++ has been working on that already

[02:08] <TimToady> but we probably need permanent links that don't rely so much on line numbers or text searches

[02:09] <TimToady> some of the synopses probably could use to be split up too, so eventually we may have to abandon the S\d\d naming

[02:09] *** tokuhirom joined
[02:09] <TimToady> certainly when we come out with a new Camel-equivalent, it won't have the same chapter numbers anyway

[02:10] <TimToady> I think this is one of the things we need to do to productize Perl 6 over the next year or two

[02:10] <TimToady> just one of many

[02:11] <ruoso> TimToady: how is the parsing of "map { } <== map { } <== grep { },1..10 " supposed to be? <== is an infix, so it's getting parsed as map(({ } <== (map(({ } <== (grep { }, 1..10))))))

[02:12] *** tokuhir__ joined
[02:12] *** tokuhirom left
[02:13] <sorear> ruoso: how did b do it?

[02:14] <ruoso> b?

[02:14] <colomon> rakudo ng

[02:15] <skids> S10 and S11 are such an anticlimax to open after reading the monster-sized ones before them.  Should probably break Names out of S02 and throw those three in a blender.

[02:15] <TimToady> ruoso: <== is of looser precedence than listops

[02:15] <TimToady> see S03:58

[02:20] *** stevan_ left
[02:23] <sorear> TimToady: How do you think $obj does Role(12) should be parsed/translated?

[02:23] <sorear> TimToady: jnthn thinks it's special syntax and Role(12) is not meaningful in isolation

[02:24] *** stevan_ joined
[02:24] <skids> nom: class B { has $.a = 0; }; class A is B { has $.A::a = 1; }; my A $a .= new; $a.perl.say 

[02:24] <p6eval> nom 975b6b: OUTPUT«A.new(A::a => 1, a => 0)␤»

[02:28] <TimToady> yes, it's special, though I suppose we might possibly be able to think of it as a WHENCE

[02:29] <skids> nom: class B { has $.a = 0; }; class A is B { has $.B::a = 1; }; my A $a .= new; $a.perl.say; $a.a.say; $a.B::a.say;

[02:29] <p6eval> nom 975b6b: OUTPUT«A.new(B::a => 1, a => 0)␤0␤0␤»

[02:34] *** arlinius left
[02:35] *** arlinius joined
[02:36] *** thou left
[02:36] <skids> (Oddly the same does not happen when doing the above eval and fiddling with .IO::chomp)

[02:37] <dalek> roast: f852369 | (Solomon Foster)++ | S (2 files):

[02:37] <dalek> roast: Comment out obsolete tests, fudge for niecza.

[02:37] <dalek> roast: review: https://github.com/perl6/roast/commit/f852369299

[02:37] <ruoso> niecza: sub infix:<a>($, *@a) { say @a.perl() }; 1 a 1..20

[02:37] <p6eval> niecza v13-146-gae314ef: OUTPUT«(1, ).list␤»

[02:37] <ruoso> how do I capture the range itself?

[02:38] <skids> (oh wait, nm, it does.)

[02:42] *** jaldhar left
[02:44] <ruoso> hmmm... 

[02:44] <ruoso> niecza: use Threads; say my @a <== 1..20; say @a

[02:44] <p6eval> niecza v13-146-gae314ef: OUTPUT«[1]..20␤1␤»

[02:45] <colomon> niecza: sub list(*@a) { @a.list }; say list(10).WHAT

[02:45] <p6eval> niecza v13-146-gae314ef: OUTPUT«List()␤»

[02:45] <colomon> niecza: sub list(*@a) { @a.list }; say list(10).perl

[02:46] <p6eval> niecza v13-146-gae314ef: OUTPUT«(10, ).list␤»

[02:46] <colomon> niecza: sub list(*@a) { @a.list }; say list(10, 12).perl

[02:46] <p6eval> niecza v13-146-gae314ef: OUTPUT«(10, 12).list␤»

[02:52] <dalek> roast: 75caa74 | (Solomon Foster)++ | S03-operators/context.t:

[02:52] <dalek> roast: Fudge for niecza.

[02:52] <dalek> roast: review: https://github.com/perl6/roast/commit/75caa74bf8

[02:53] <dalek> niecza: 45d2b42 | (Solomon Foster)++ | / (2 files):

[02:53] <dalek> niecza: Turn on S03-operators/context.t.

[02:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/45d2b42e69

[02:56] *** kshannon left
[03:00] *** kshannon joined
[03:01] <colomon> niecza: say '{'.perl

[03:01] <p6eval> niecza v13-146-gae314ef: OUTPUT«"{"␤»

[03:02] <colomon> niecza: say 'a'.perl

[03:02] <p6eval> niecza v13-146-gae314ef: OUTPUT«"a"␤»

[03:03] <colomon> niecza: say '{'.perl.eval

[03:03] <p6eval> niecza v13-146-gae314ef: OUTPUT«Unhandled exception: Unable to resolve method eval in class Str␤  at /tmp/SDkXT_idFv line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2831 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2832 (module-CORE @ 58) ␤  at /home/…

[03:04] <TimToady> perl6: say '$x'.perl

[03:04] <p6eval> niecza v13-146-gae314ef: OUTPUT«"$x"␤»

[03:04] <p6eval> ..pugs b927740, rakudo 975b6b: OUTPUT«"\$x"␤»

[03:04] <TimToady> oops :)

[03:05] <colomon> yeah, I was just getting there here.  :)

[03:05] <colomon> perl6: say '{'.perl

[03:05] <p6eval> pugs b927740, rakudo 975b6b: OUTPUT«"\{"␤»

[03:05] <p6eval> ..niecza v13-146-gae314ef: OUTPUT«"{"␤»

[03:05] <colomon> niecza: say "\{

[03:05] <p6eval> niecza v13-146-gae314ef: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/H71BZ2b7N4 line 1:␤------> [32msay[33m⏏[31m "\{[0m␤␤Confused at /tmp/H71BZ2b7N4 line 1:␤------> …

[03:05] <colomon> niecza: say "\{".eval

[03:05] <p6eval> niecza v13-146-gae314ef: OUTPUT«Unhandled exception: Unable to resolve method eval in class Str␤  at /tmp/rNM5i3GYRm line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2831 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2832 (module-CORE @ 58) ␤  at /home/…

[03:05] <sorear> ruoso: to capture the range itself, use @a instead of *@a

[03:05] <colomon> niecza: say eval("\{")

[03:05] <p6eval> niecza v13-146-gae314ef: OUTPUT«Unhandled exception: Unable to parse block at (eval) line 1 (EOF):␤------> [32m{[33m⏏[31m<EOL>[0m␤Couldn't find final '}'; gave up at (eval) line 1 (EOF):␤------> [32m{[33m⏏[31m<EOL>[0m␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die…

[03:06] <sorear> colomon: what are you doing?

[03:06] <colomon> trying to get S02-names-vars/perl.t to run

[03:06] <colomon> (fudging, in other words)

[03:08] *** thou_ joined
[03:09] <skids> nom: class B { has $.a = 0; }; class A is B { submethod BUILD ($!a = 1) {} }; my A $a .= new; $a.a.say;

[03:09] <p6eval> nom 975b6b: OUTPUT«===SORRY!===␤Null PMC access in get_pmc_keyed_str()␤»

[03:23] <kshannon> skids: if you want BUILD to take positional args,  you have to write your own new

[03:23] <kshannon> nom: class B { has $.a = 0; }; class A is B { submethod BUILD (:$!a = 1) {} }; my A $a .= new; $a.a.say;

[03:23] <p6eval> nom 975b6b: OUTPUT«===SORRY!===␤Null PMC access in get_pmc_keyed_str()␤»

[03:24] <kshannon> Hmmm,  but I see that's not actually the problem.  Bad nom!

[03:25] *** thou joined
[03:27] <skids> kshannon: Thanks.  What I want is a subclass with a different default value for an inherited attribute.  The rest is just fun in the rabbit hole.

[03:28] <TimToady> colomon: you could test your fancy pi spigot against nom now and see if it works

[03:29] <TimToady> the one with the sublist matching

[03:29] <TimToady> (I don't think niecza does that yet, but nom has bigints now)

[03:29] <colomon> yes

[03:29] <TimToady> if so, you could install it as the 400th entry on RC :)

[03:30] *** Guest40 left
[03:35] <kshannon> nom: class B { has $.a = 0; }; class A is B { method new (:$a = 1, *%_) { nextwith :$a, |%_; } }; my A $a .= new; $a.a.say;

[03:35] <p6eval> nom 975b6b: OUTPUT«1␤»

[03:35] <colomon> TimToady: looks like it works fine in nom

[03:36] <colomon> If you'd like, I'll try to install it on RC tomorrow -- I'm going to bed now.  

[03:36] <kshannon> skids: like that ^^ ?

[03:36] <kshannon> nom: class B { has $.a = 0; }; class A is B { method new (:$a = 1, *%_) { nextsame; } }; my A $a .= new; $a.a.say;

[03:36] <p6eval> nom 975b6b: OUTPUT«0␤»

[03:37] <colomon> TimToady: 3.14159265358979323846264338327950288419716939937510582097494 took 5.7 seconds to generate

[03:37] <colomon> I've only checked the first 40 digits of that.  ;)

[03:38] *** Psyche^ joined
[03:38] <kshannon> colomon: looks right to me.

[03:39] <TimToady> \o/

[03:39] <skids> kshannon: perfect.  thanxo mucho!

[03:40] <kshannon> skids: I think the nextsame should work,  but is currently not...

[03:41] *** Patterner left
[03:41] *** Psyche^ is now known as Patterner

[03:44] <sorear> colomon: http://stuff.mit.edu/afs/sipb/contrib/pi/pi-billion.txt

[03:45] <kshannon> or http://3.141592653589793238462643383279502884197169399375105820974944592.com/

[03:46] * japhb wonders if there is a similar website for tau

[03:53] *** orafu left
[03:53] *** orafu joined
[03:54] <skids> heh.  All that trouble and .open('foo') on the 'is IO' class resets .chomp to True.

[03:54] <sorear> Why are you doing this?

[03:55] <skids> Investigating subclassing IO for specific formats.

[03:55] <sorear> I do not think subclassing IO is a good idea

[03:56] <sorear> for a start, there is still dissent on what the IO type hierarchy should be

[03:56] <skids> For sure, but if I waited for that to get sorted...

[03:57] <sorear> I'm sure there's a better, easier, more portable way to accomplish your goals.

[03:57] <skids> Well, if I took the easy way, that would be totally out of character for me :-)

[04:00] <skids> (As far as type heirarchy, I wasn't creating an IO::Foo but rather a Foo::File)

[04:02] <kshannon> Should nextsame be incorporating the defaults from the current signature?  or passing through the exact same arguments that were passed?

[04:02] *** allahu is now known as jakk

[04:02] <sorear> kshannon: Exact same.

[04:03] <kshannon> nom: class B { has $.a = 0; }; class A is B { method new (:$a = 1, *%_) { nextsame; } }; my A $a .= new; $a.a.say;

[04:04] <p6eval> nom 975b6b: OUTPUT«0␤»

[04:04] <kshannon> So 0 is correct?

[04:04] <sorear> yes

[04:04] <benabik> nom: class B { has $.a = 0; }; class A is B { method new (:$.a = 1, *%_) { nextsame; } }; my A $a .= new; $a.a.say;

[04:05] <p6eval> nom 975b6b: OUTPUT«===SORRY!===␤Cannot look up attributes in a type object␤»

[04:05] <sorear> if you want to modify the arguments, use nextwith

[04:05] *** jakk left
[04:05] <benabik> Oh, new gets an undefined self.  Blah.

[04:05] <benabik> nom: class B { has $.a = 0; }; class A is B { method new (:$a = 1, *%_) { next with(:a($a), *%_); } }; my A $a .= new; $a.a.say;

[04:06] <p6eval> nom 975b6b: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&_' called (line 1)␤Undefined routine '&with' called (line 1)␤»

[04:06] <benabik> nom: class B { has $.a = 0; }; class A is B { method new (:$a = 1, *%_) { nextwith(:a($a), *%_); } }; my A $a .= new; $a.a.say;

[04:06] <p6eval> nom 975b6b: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&_' called (line 1)␤»

[04:06] <benabik> Nevermind.

[04:06] <sorear> |%_

[04:06] <sorear> not *%_

[04:12] *** jakky joined
[04:13] *** jakky left
[04:28] *** Mowah left
[04:30] *** Mowah joined
[04:30] *** jaldhar joined
[04:47] *** risou is now known as risou_awy

[05:05] *** jakky joined
[05:07] *** kaleem left
[05:19] *** thou_ left
[05:22] *** wooden joined
[05:22] *** wooden left
[05:22] *** wooden joined
[05:24] *** mkramer joined
[05:24] *** mkramer left
[05:27] *** jakky left
[05:35] <dalek> niecza: fd65896 | sorear++ | lib/ (2 files):

[05:35] <dalek> niecza: Add Niecza::toggle_mono_trace which does raise(SIGUSR2), man mono for why this might be useful

[05:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/fd65896cf0

[05:35] <dalek> niecza: bf6b78c | sorear++ | lib/ (2 files):

[05:35] <dalek> niecza: Implement $foo ~~ Bar[5]

[05:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bf6b78ce28

[05:59] *** Mowah left
[06:01] *** Mowah joined
[06:12] *** wooden left
[06:12] *** wooden joined
[06:12] *** wooden left
[06:12] *** wooden joined
[06:13] *** japhb left
[06:13] *** orevdiabl left
[06:13] *** japhb joined
[06:14] *** spacebat joined
[06:14] *** revdiablo joined
[06:14] *** revdiablo left
[06:14] *** revdiablo joined
[06:31] *** bkolera left
[06:46] *** bkolera joined
[06:47] <sorear> niecza: class { has $.x is rw }

[06:47] <p6eval> niecza v13-149-gbf6b78c:  ( no output )

[06:59] *** kaare__ joined
[07:00] <sorear> niecza: sub foo(pi) { }

[07:00] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Lexical pi is not a package at /tmp/gxm79mKXs3 line 1:␤------> [32msub foo(pi[33m⏏[31m) { }[0m␤␤Potential difficulties:␤  &foo is declared but not used at /tmp/gxm79mKXs3 line 1:␤------> [32msub foo[33m⏏[31m(pi) { }…

[07:23] *** risou_awy is now known as risou

[07:48] *** Salaysia joined
[07:59] *** xinming joined
[08:03] *** Chillance left
[08:17] *** Salaysia left
[08:35] *** molaf joined
[09:19] *** benabik left
[09:26] *** kaare__ left
[09:44] *** thou left
[09:51] *** tokuhir__ left
[10:23] *** spine joined
[10:25] *** raiph left
[10:28] <spine>  /msg p6eval perl6: sub MAIN() {}

[10:43] <spine> The MAIN subs stopped working for me in current nom

[10:43] <spine> perl6 -e "sub MAIN($n){}" 100

[10:43] <spine> Method 'package' not found for invocant of class 'BOOTSTRAPATTR'

[10:46] <spine> only numerical arguments seem to cause the error

[10:49] <fsergot> nom: sub MAIN() {}

[10:49] <p6eval> nom 975b6b:  ( no output )

[10:51] *** sayu joined
[10:51] *** fusidany joined
[10:51] *** fusidany left
[10:51] <masak> mornin', #perl6

[10:53] <kshannon> \o masak

[10:54] <Woodi> hallo masak 

[10:55] <jnthn> morning, #perl6

[10:55] <Woodi> hi jnthn 

[10:55] <kshannon> o/ jnth

[10:55] <kshannon> s/$/n/

[10:55] <jnthn> spine: Ah, I'll bet I busted that yesterday. D'oh.

[10:56] <jnthn> o/ kshannon 

[10:56] <jnthn> I patched the nqp bootstrap bustage last night.

[10:56] <jnthn> Probably not the final solution, but makes it work again.

[11:04] <kshannon> I saw.

[11:04] *** Mowah left
[11:05] *** aindilis left
[11:06] *** aindilis joined
[11:06] *** Mowah joined
[11:09] *** xinming left
[11:15] *** xinming joined
[11:30] <spine> p6eval nom: my role a {}; say 1 but a;

[11:30] <p6eval> spine: nom 975b6b: OUTPUT«===SORRY!===␤Method 'package' not found for invocant of class 'BOOTSTRAPATTR'␤»

[11:31] <spine> giving a role to an Int seems to be the problem

[11:31] <jnthn> > my role a {}; say 1 but a;

[11:31] <jnthn> 1

[11:31] <jnthn> Locally

[11:31] <jnthn> (just fixed the issue)

[11:31] <spine> nice :)

[11:39] *** donri joined
[11:41] <dalek> rakudo/nom: 70e5fae | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[11:41] <dalek> rakudo/nom: Ensure that attributes in the bootstrap get correctly set up with a package.

[11:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/70e5faeb91

[11:41] <dalek> rakudo/nom: cfe49f0 | jnthn++ | src/core/Parcel.pm:

[11:41] <dalek> rakudo/nom: Fix incorrect proto signature introduced yesterday.

[11:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cfe49f0098

[11:53] *** mj41 joined
[11:55] *** Woodi left
[11:57] *** Woodi joined
[11:57] *** risou is now known as risou_awy

[11:58] *** risou_awy is now known as risou

[12:00] *** JimmyZ joined
[12:00] <dalek> nqp/qbootstrap: e879f27 | jnthn++ | src/QRegex/Cursor.nqp:

[12:00] <dalek> nqp/qbootstrap: Add missing orig method to NQPMatch.

[12:00] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/e879f277a7

[12:00] <dalek> nqp/qbootstrap: 308d64a | jnthn++ | src/QRegex/Cursor.nqp:

[12:00] <dalek> nqp/qbootstrap: Get make and .ast working with QRegex NQP match object.

[12:00] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/308d64ac2b

[12:00] <dalek> nqp/qbootstrap: f34a0f8 | jnthn++ | src/QHLL/Grammar.pm:

[12:00] <dalek> nqp/qbootstrap: Fix panic and...we successfully fail to parse anything.

[12:00] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/f34a0f8e34

[12:00] <Woodi> so, it is new year so I would like to promote some idea :) I was mentioning about it once before...

[12:01] <Woodi> it is about two hands programming - two threads

[12:02] <Woodi> threads are not educated much so basic usage will make them more common and allow to spread knowledge

[12:03] <Woodi> here is nice and simple example of having two hands :) http://pastebin.com/h0d3vBGh

[12:07] <masak> I don't understand your concept, but thus far into the explanation it doesn't sound like something Perl 6-related.

[12:15] *** fsergot left
[12:19] *** JimmyZ left
[12:21] *** preflex left
[12:21] *** snearch joined
[12:22] *** preflex joined
[12:33] *** fsergot joined
[12:38] *** bkolera left
[12:50] *** fsergot left
[12:52] *** whiteknight joined
[12:53] *** whiteknight is now known as Guest34262

[12:56] *** birdwindupbird joined
[13:08] *** fsergot joined
[13:18] *** nebuchad` is now known as nebuchadnezzar

[13:34] *** zhangkaizhao joined
[13:34] *** zhangkaizhao left
[13:35] *** zhangkaizhao joined
[13:36] *** zhangkaizhao left
[13:37] *** zhangkaizhao joined
[13:39] * colomon keeps on thinking this morning's pancakes look like fractals....

[13:56] *** risou is now known as risou_awy

[13:57] *** risou_awy is now known as risou

[14:09] *** mdxi left
[14:10] *** mdxi joined
[14:10] *** mdxi is now known as sboyette

[14:16] *** xinming left
[14:19] *** risou is now known as risou_awy

[14:22] *** sayu left
[14:23] *** sayu joined
[14:25] *** aindilis left
[14:25] *** spine left
[14:25] *** molaf left
[14:25] *** carlin left
[14:25] *** shachaf left
[14:25] *** mls left
[14:25] *** sunnavy left
[14:25] *** tokuhirom3 left
[14:25] *** TimToady left
[14:25] *** doy left
[14:25] *** ranguard left
[14:25] *** aindilis joined
[14:25] *** spine joined
[14:25] *** molaf joined
[14:25] *** doy joined
[14:25] *** carlin joined
[14:25] *** shachaf joined
[14:25] *** mls joined
[14:25] *** sunnavy joined
[14:25] *** tokuhirom3 joined
[14:25] *** TimToady joined
[14:25] *** ranguard joined
[14:25] *** shachaf left
[14:26] *** shachaf joined
[14:31] *** GlitchMr joined
[14:45] * moritz back

[14:47] <jnthn> o/ moritz 

[14:48] <masak> moritz! \o/

[14:49] <moritz> driving for a long time is exhausting. Especially if you have a 1-year-old complaining that it's boring, BORING :-)

[14:49] <masak> wow, 1 year already?

[14:49] <masak> she speaks better than she types :P

[14:50] <moritz> one year in a week, actually

[14:50] <moritz> well, she didn't say "boring", but it was quite apparent what she meant :-)

[14:51] *** PacoAir joined
[14:51] <masak> moritz++ # parsing baby

[14:52] <masak> that's "for his ability to parse baby", not "such a baby at parsing", just to be clear. :P

[14:53] <masak> "I speak baby." -- 11th Doctor

[14:54] <ruoso> niecza: sub infix:<a>($, @a) { say @a.perl() }; 1 a 1..20

[14:54] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«Unhandled exception: Nominal type check failed in binding @a in infix:<a>; got Int, needed Positional␤  at /tmp/cHnnEp7wsS line 0 (infix:<a> @ 1) ␤  at /tmp/cHnnEp7wsS line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2833 (ANON @ 3) ␤…

[14:55] <ruoso> sorear: ^ 

[14:55] <moritz> niecza: sub infix:<a>($, @a) { say @a.perl() }; 1 a (1..20)

[14:55] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«1..20␤»

[14:55] <moritz> precdence. It's not magic.

[14:55] <ruoso> the default precedence will be higher then ..?

[14:56] <masak> yes.

[14:56] <moritz> niecza: sub infix:<a>($, @a) is looser(&infix:<..>) { say @a.perl() }; 1 a 1..20

[14:56] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«1..20␤»

[14:56] <masak> infix:<a> gets infix:<+> as default precedance.

[14:56] <masak> I haven't thought about why that should be the default.

[14:56] <moritz> I thought it was *, but they are close

[14:56] * masak reads his own Advent post

[14:57] <masak> "Per default, an operator gets the same precedence as infix<+>."

[14:57] <masak> masak says so, so it must be true.

[14:57] <masak> that guy does his research.

[14:58] <moritz> masak++ # research

[15:02] <masak> do the 'tighter'/'looser'/'equiv' have any significance outside of operators?

[15:02] <masak> s/have/traits have/

[15:03] <masak> could they be made to make sense for listop subs, for example?

[15:04] <jnthn> Just for ops, afaik

[15:05] <masak> I think those traits should be conservatively made to throw an error on non-ops at parse time.

[15:06] *** shinobicl___ joined
[15:07] <kshannon> niecza: sub foo ($x) is looser(&infix:<..>) { ... }

[15:07] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Target does not seem to be an operator at /tmp/hjpwiocvdK line 1:␤------> [32msub foo ($x) is looser(&infix:<..>) [33m⏏[31m{ ... }[0m␤␤Potential difficulties:␤  $x is declared but not used at /tmp/hjpwiocvdK line 1:␤---…

[15:07] <kshannon> You mean like that ^^

[15:08] *** risou_awy is now known as risou

[15:08] <shinobicl___> hi.... is it _really_ needed to have "my" and "has"? I mean, why would you want to use "my" inside a class declaration?

[15:08] <masak> shinobicl___: I do that all the time...

[15:08] <ruoso> niecza: sub infix:<a>($, @a) is looser(&infix:<or>) { say @a.perl() }; 1 a 1..20

[15:08] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤No precedence available for reference target at /tmp/9udJjCiRoP line 1:␤------> [32minfix:<a>($, @a) is looser(&infix:<or>) [33m⏏[31m{ say @a.perl() }; 1 a 1..20[0m␤␤Undeclared routine:␤  'infix:<or>' used at line 1␤␤Unh…

[15:08] <masak> kshannon: and once again, Niecza rocks. :)

[15:09] <shinobicl___> masak: what's the difference on using my against a private "has" declaration?

[15:09] <masak> shinobicl___: the former is shared between all instances, and even outside of the method bodies.

[15:10] <masak> 'my' cuts across all artificial instance mumbo-jumbo. 'has' adheres to it.

[15:11] <kshannon> The same reason you'd use a 'my' variable in P5 'class'es

[15:11] <masak> nom: class C { method foo { my $x = 42; method bar { say $x } }; C.new.bar; C.new.foo; C.new.bar

[15:11] <p6eval> nom cfe49f: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[15:11] <masak> nom: class C { method foo { my $x = 42; method bar { say $x } } }; C.new.bar; C.new.foo; C.new.bar

[15:11] <shinobicl___> i see. Thanks masak!

[15:11] <p6eval> nom cfe49f: OUTPUT«Any()␤42␤»

[15:12] <masak> today is the last day before the deadline to sign up for p6cc!

[15:13] <masak> 32 people signed up so far! \o/

[15:13] <masak> that's almost twice as many as last year (18).

[15:22] *** lutok joined
[15:23] <dalek> nqp/qbootstrap: 2d18985 | jnthn++ | src/QHLL/Grammar.pm:

[15:23] <masak> lutok: greetings.

[15:23] <dalek> nqp/qbootstrap: Update various rules in QHLL::Grammar for new !cursor_start API.

[15:23] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/2d1898561b

[15:23] <dalek> nqp/qbootstrap: abb07dc | jnthn++ | src/QHLL/Grammar.pm:

[15:23] <dalek> nqp/qbootstrap: Get EXPR at least somewhat fixed up for QRegex.

[15:23] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/abb07dc41d

[15:23] <dalek> nqp/qbootstrap: c84aaf0 | jnthn++ | src/QHLL/Grammar.pm:

[15:23] <dalek> nqp/qbootstrap: Another bunch of updates to EXPR. Gets us closer to working OPP with QRegex.

[15:23] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/c84aaf02f2

[15:25] <masak> Q Boots. they're the latest fashion.

[15:27] <jnthn> It's a trap!

[15:28] <masak> no, it's a strap! :P

[15:28] <sjn> it's a tarp!

[15:28] <dalek> niecza: a17d4eb | (Daniel Ruoso)++ | / (2 files):

[15:28] <dalek> niecza: define the precedence for the feed op, now I can use $a <== 1..20

[15:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a17d4eb467

[15:30] <ruoso> but map is not declared as a list prefix in niecza... so "map {} <== 1..20" can't really work...

[15:30] <masak> what's it defined as?

[15:31] <ruoso> plain sub

[15:32] *** kaare__ joined
[15:34] <masak> don't plain subs have listop precedence, though?

[15:34] <masak> or is "list prefix" something different from "listop"?

[15:36] *** risou is now known as risou_awy

[15:39] <masak> how do I use IO.read to read all of the bytes?

[15:39] <jnthn> In a loop?

[15:40] <jnthn> Or just get the file length and pass that...

[15:40] <masak> ooh, file length.

[15:41] <masak> how do I get the file length, in bytes, from an IO object? :)

[15:41] <masak> I guess .s will do it...

[15:43] <masak> method read(IO:D: Int:D $bytes) {

[15:43] *** JimmyZ joined
[15:43] <masak> I think Int:D should be Cool:D here...

[15:43] <masak> for the usual reasons.

[15:44] <jnthn> Probably.

[15:45] *** GlitchMr left
[15:46] <masak> oh no, .s returns a boolean -- "is the size non-zero?"

[15:46] <jnthn> oh

[15:46] <masak> and there's no other way to get the file size :(

[15:47] * masak compromizes and copies the mechanism from src/core/IO.pm into his own code

[15:47] <masak> OO -- it's all about re-use :P

[15:49] <dalek> nqp/qbootstrap: 999c0e4 | jnthn++ | src/Q (2 files):

[15:49] <dalek> nqp/qbootstrap: Another round of fixes to OPP with QRegex; actually seems to work now.

[15:49] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/999c0e46f7

[15:55] <dalek> nqp/qbootstrap: 3efe24b | jnthn++ | src/NQPQ/Actions.pm:

[15:55] <dalek> nqp/qbootstrap: Fix compilation of rules with parameters.

[15:55] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/3efe24bc70

[15:58] <shinobicl___> what am i doing wrong here? 

[15:58] <shinobicl___> rakudo: class A { has Str $!stuff; method new(Str $stuff){$!stuff = $stuff}; method pr{say $!stuff} }; my A $thing = A.new("abc"); $thing.pr; 

[15:58] <p6eval> rakudo cfe49f: OUTPUT«Cannot look up attributes in a type object␤  in method new at /tmp/o6k4pmKsSE:1␤  in block <anon> at /tmp/o6k4pmKsSE:1␤  in <anon> at /tmp/o6k4pmKsSE:1␤»

[16:00] <kshannon> The object doesn't exist yet in new(), you want to provide your own submethod BUILD

[16:00] *** Mowah left
[16:01] *** birdwindupbird left
[16:01] <skids> .oO(Str has a lot of methods.  A rather heavy interface to require non-strings to tie to for ~~ when only a few like substr are actually used.)

[16:02] <colomon> rakudo: class A { has Str $!stuff; method new(Str $stuff){ bless(*, :$stuff); }; method pr{say $!stuff} }; my A $thing = A.new("abc"); $thing.pr;

[16:02] <p6eval> rakudo cfe49f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&bless' called (line 1)␤»

[16:02] *** Mowah joined
[16:03] <colomon> rakudo: class A { has Str $!stuff; method new(Str $stuff){ self.bless(*, :$stuff); }; method pr{say $!stuff} }; my A $thing = A.new("abc"); $thing.pr;

[16:03] <p6eval> rakudo cfe49f: OUTPUT«Str()␤»

[16:03] *** birdwindupbird joined
[16:03] <kshannon> nom: class A { has Str $!stuff; method new(Str $stuff) { nextwith stuff => $stuff; }; submethod BUILD(Str :$!stuff) {}; method pr {say $!stuff} }; my A $thing .= new("abc"); $thing.pr;

[16:03] <p6eval> nom cfe49f: OUTPUT«abc␤»

[16:04] <skids> colomon: fine as long as $!stuff isn't many megabytes long.

[16:04] <colomon> ???

[16:05] *** JimmyZ left
[16:07] <kshannon> skids: BTW unless you REALLY need .new to take postional arguments for some reason,  you're usually better off going with named.

[16:07] <kshannon> nom: class A { has Str $!stuff; submethod BUILD(Str :$!stuff) {}; method pr {say $!stuff} }; my A $thing .= new(stuff => "abc"); $thing.pr;

[16:07] <p6eval> nom cfe49f: OUTPUT«abc␤»

[16:11] <skids> colomon: sorry I thought you were responding to me.

[16:12] <shinobicl___> that looks better. And, i think is not that bad to "force" named arguments on constructors... But it should be simpler to declare "simple" constructors like in, say, object pascal.

[16:12] <kshannon> The list/map/iterator reify/REIFY interface:  is there a specific reason for it to be the way it is (i.e. compatibility with something else) or can I have a go at cleaning it up.

[16:12] <kshannon> For example, the list iterator really shouldn't have a reference to the list it was iterating which it calls REIFY on as a side effect.

[16:13] <kshannon> shinobicl___: If you're willing to have public accessors,  then it is.

[16:14] <kshannon> nom: class A { has Str $.stuff; method pr {say $.stuff} }; my A $thing .= new(:stuff("abc")); $thing.pr;

[16:14] <p6eval> nom cfe49f: OUTPUT«abc␤»

[16:16] <skids> let "genex" be to pack what regex/grammar is to unpack <-- was there ever a serious effort to flesh out something like that, and if so, anyone got links?

[16:18] <masak> not to my knowledge, but it feels like a really worthy thing to try.

[16:18] <masak> there's been mumblings about linking this up with compact types somehow, too.

[16:19] <masak> even the unpack/pack spec mentions something like that. but it's all hot air so far.

[16:19] <flussence> wouldn't that just be a templating language?

[16:19] <kshannon> skids: you mean genex GENerates EXamples?

[16:20] <kshannon> Ah, yeah templating makes more sense.

[16:20] <skids> I offer no excuses for that coinage, other than it allows for bad Generation X jokes.

[16:21] <skids> (And rhymes)

[16:21] <jnthn> kshannon: pmichaud designed the interface there...I don't think he considers it perfect, so if you have ideas for improvements feel free to try them out. I'd be happy to look over any patches...

[16:21] <kshannon> I was thinking skids was talking about something like the haskell QuickCheck Arbitrary type

[16:22] *** wallberg joined
[16:22] <masak> wallberg! \o/

[16:22] <flussence> oh, that makes sense...

[16:23] <kshannon> I was going to paste an example that was NULL PMC'ing because of the design,  but it looks like it doesn't anymore...

[16:23] *** thou_ joined
[16:27] <moritz> nom: say pir::null__P

[16:27] <p6eval> nom cfe49f: OUTPUT«Null PMC access in find_method('gist')␤  in sub say at src/gen/CORE.setting:5692␤  in block <anon> at /tmp/_3VfAQkwtE:1␤  in <anon> at /tmp/_3VfAQkwtE:1␤»

[16:27] <moritz> :-)

[16:27] <jnthn> :P

[16:28] <masak> that's a Null PMC access from inside the MOP. if we wanted, we could plug that one.

[16:28] <skids> masak: yeah, that was the concept I was thinking of.  I just get an icky feeling when writing regex to read data into an object and thinking "I'll have to duplicate a lot of this for a write-back-to data function."  But it is definitely No Small Task(tm) to come up with something elegant in this area.

[16:29] <jnthn> masak: Don't see the point.

[16:30] <flussence> .oO( isn't that the whole point of null__P? )

[16:31] <moritz> jnthn: what do you run to try to bootstrap in the qbootstrap branch?

[16:31] <moritz> is that just 'make bootstrap-files'?

[16:31] <moritz> and then 'make' again?

[16:32] <dalek> nqp/qbootstrap: 5d63533 | jnthn++ | src/QRegex/Cursor.nqp:

[16:32] <dalek> nqp/qbootstrap: Match objects should have the cursor associated with them.

[16:32] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/5d63533462

[16:32] <dalek> nqp/qbootstrap: 33cc834 | jnthn++ | src/QHLL/Grammar.pm:

[16:32] <dalek> nqp/qbootstrap: Get quote parsing to work again under QRegex. Now we parse and pass some of NQPs test suite again.

[16:32] <masak> skids: no, which is maybe why no-one's done it yet.

[16:32] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/33cc83447d

[16:32] <jnthn> moritz: It's not that far along yet

[16:32] <masak> skids: still, it sounds like a worthwhile thing to have.

[16:32] <jnthn> moritz: Current work is to make it pass make test again :)

[16:32] <jnthn> moritz: Only then is it time to consider make bootstrap-files

[16:33] <jnthn> moritz: Basically, in that branch stage1 is the equivalent of what nqpq builds in master.

[16:33] <moritz> masak, skids: a good first step might be to make regexes/tokens introspectable

[16:33] <moritz> jnthn: ok

[16:34] <jnthn> moritz: stage2 is thus built fully with QRegex (e.g. NQP::Grammar is compiled with QRegex)

[16:34] <jnthn> moritz: There's a src/QHLL which is only used in stage2 - it's where I'm doing the updates to HLL::Grammar mostly.

[16:34] <moritz> masak, skids: then you could write a generator that takes something of the same structure as the parse tree, and turn it back into something that the grammar would match

[16:34] <jnthn> moritz: Once we're done, NQPQ and HLLQ go away, they're just around during migration.

[16:35] <jnthn> moritz: Now we can run various of the test suite using QRegex, feel free to join in triage.

[16:36] <moritz> jnthn: I'll take a look, but will also look at testneeded tickets -- maybe I can be more productive in that area

[16:36] <jnthn> moritz: Probably easier to be productive there, yes.

[16:38] <masak> grrr... dir() and open() don't follow least-surprise when it comes to paths. dir() returns pathless filenames, and open() expects pathful filenames.

[16:40] <skids> moritz: I suppose the true sticking point would be reversing { make <expr> } which might be an indication that more reversable alternative constructs for putting stuff in .ast might be desireable.

[16:42] <moritz> skids: right, that bit isn't very declarative at the moment

[16:45] <moritz> nom: ::T;

[16:45] <p6eval> nom cfe49f: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[16:45] <moritz> nom: ::T; class T { };

[16:45] <p6eval> nom cfe49f: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol T␤»

[16:46] <moritz> nom: class T { }; ::T

[16:46] <p6eval> nom cfe49f:  ( no output )

[16:50] *** shinobicl___ left
[16:51] <dalek> roast: 8c77b69 | moritz++ | S14-roles/parameterized-type.t:

[16:51] <dalek> roast: RT #68134

[16:51] <dalek> roast: review: https://github.com/perl6/roast/commit/8c77b692f3

[16:55] *** shinobicl___ joined
[17:02] *** zhangkaizhao left
[17:03] <dalek> rakudo/nom: 054d533 | masak++ | src/core/IO.pm:

[17:03] <dalek> rakudo/nom: [src/core/IO.pm] .read should accept Cool:D

[17:03] <dalek> rakudo/nom: 

[17:03] <dalek> rakudo/nom: Not just Int:D.

[17:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/054d5337db

[17:03] <masak> I spectested the above patch, but it's possible there's no spectest for .read("42") or whatever.

[17:04] <masak> I'll test that locally now.

[17:04] <fsergot> nom: sub s( @ints ){ return [+] @ints; }; say "1: {s((1,2,3))}";

[17:04] <p6eval> nom cfe49f: OUTPUT«1: 6␤»

[17:04] <fsergot> nom: sub s( @ints ){ return [+] @ints; }; say "1: {s(1,2,3)}";

[17:04] <p6eval> nom cfe49f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 's' will never work with argument types (int, int, int) (lines 1, 1)␤    Expected: :(Positional @ints)␤»

[17:05] <fsergot> Maybe We can do something with this?

[17:05] <masak> ah. getting "This type cannot unbox to a native integer"

[17:05] <fsergot> nom: my @ints = 1,2,3; say @ints.perl;

[17:05] <p6eval> nom cfe49f: OUTPUT«Array.new(1, 2, 3)␤»

[17:05] <masak> jnthn: given a Cool, how do I cast it into an Int that can later be unboxed to a native integer. .Int ?

[17:05] <fsergot> It is Array :)

[17:05] <jnthn> .Int

[17:05] * masak fixes

[17:06] <jnthn> fsergot: That compile time failure is correct. You're passing it three args. Write *@ints in the signature to do what you want.

[17:07] <fsergot> jnthn++: thanks

[17:07] <TimToady> and you got an Array from the assignment, not from the RHS, which is a Parcel

[17:08] <fsergot> TimToady++

[17:09] <TimToady> well, actually you got an Array from the declaration, and the assignment merely populated it :)

[17:09] <dalek> nqp/qbootstrap: 66618fc | jnthn++ | src/ (2 files):

[17:09] <dalek> nqp/qbootstrap: Restore some basic rxtrace functionality. Unlike the previous version, this is zero cost if you don't enable it.

[17:09] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/66618fcb76

[17:09] <TimToady> TimToady--

[17:09] <jnthn> Also, nice that Rakudo caught that one at compile time ;)

[17:09] <TimToady> .oO("That trick never works!")

[17:10] <TimToady> though in this case it'd be nice if it said "Too many arguments"

[17:11] <jnthn> Yeah

[17:11] <TimToady> not every newbie is going to be able to read signatures that well

[17:12] <TimToady> and fsergot++'s mistake is quite natural, even if you aren't a newbie anymore

[17:14] <kshannon> jnthn++ # rxtrace :)

[17:15] *** wallberg left
[17:16] <kshannon> Here's a silly nom bug:

[17:16] <kshannon> nom: say 27 ** 0.33333333333333333333333

[17:16] <p6eval> nom cfe49f: OUTPUT«3␤»

[17:16] <kshannon> nom: say 27 ** 1/3

[17:16] <p6eval> nom cfe49f: OUTPUT«9␤»

[17:17] <dalek> rakudo/nom: 02ddac6 | masak++ | src/core/IO.pm:

[17:17] <dalek> rakudo/nom: [src/core/IO.pm] accept Cool but cast to Int

[17:17] <dalek> rakudo/nom: 

[17:17] <dalek> rakudo/nom: There, that should make us Postel-compliant. :-)

[17:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/02ddac6f99

[17:17] <masak> "Be liberal in what you accept, and conservative in what you send." -- jon postel

[17:17] <masak> kshannon: precedence.

[17:17] <masak> kshannon: ** binds tighter than /

[17:17] <kshannon> nom: say 27 ** (1/3)

[17:17] <p6eval> nom cfe49f: OUTPUT«3␤»

[17:17] <masak> kshannon: and whitespace isn't significant.

[17:17] <kshannon> I swear I already tried that :(

[17:18] <kshannon> That's what I get for coding at 4am

[17:23] <masak> some enterprising soul could eradicate 'rule multisig' from src/Perl6/Grammar.pm in Rakudo.

[17:23] <jnthn> Is it gone from STD?

[17:24] <jnthn> kshannon: Yes, just used it to find an issue :)

[17:24] *** birdwindupbird left
[17:24] <masak> jnthn: no, it's still in STD.pm6.

[17:25] <TimToady> given that these days we consider sigs to be intermixable with other traits, it's a completely unnecessary syntax

[17:25] <TimToady> if we really want multiple signatures, we can just put two of 'em

[17:25] *** birdwindupbird joined
[17:26] <TimToady> std: sub foo ($a,$b) ($b,$a) {...}

[17:26] <p6eval> std dc62e1d: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $b (see line 1) at /tmp/oCNQvcvIQr line 1:␤------> [32msub foo ($a,$b) ([33m⏏[31m$b,$a) {...}[0m␤  Useless redeclaration of variable $a (see line 1) at /tmp/oCNQvcvIQr line 1:␤------> [32msub foo ($a,$b…

[17:26] <TimToady> heh

[17:26] <TimToady> well, the syntax is allowed

[17:26] <TimToady> don't need to implement it for 6.0 though

[17:27] <masak> TimToady: I de-spec'd that part in 2011, though.

[17:27] <dalek> nqp/qbootstrap: 814b46f | jnthn++ | src/how/NQPClassHOW.pm:

[17:27] <dalek> nqp/qbootstrap: Implement non-:local case of .^methods in NQP's ClassHOW.

[17:27] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/814b46f07c

[17:27] <dalek> nqp/qbootstrap: 682544b | jnthn++ | src/NQPQ/Grammar.pm:

[17:27] <dalek> nqp/qbootstrap: Remove stray proto in NQP grammar.

[17:27] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/682544bfc5

[17:27] <dalek> nqp/qbootstrap: 862bcc7 | jnthn++ | src/QRegex/Cursor.nqp:

[17:27] <dalek> nqp/qbootstrap: Don't need to explicitly pass :local(0) - it's the default.

[17:27] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/862bcc7832

[17:27] <TimToady> yes, I know

[17:28] <TimToady> you despec'd the | syntax

[17:28] <TimToady> but treating the sig like just another trait remains

[17:28] <TimToady> and there are good reasons for wanting traits in front of the sig from time to time

[17:28] <masak> oh, I thought the | syntax and multisig were exactly the same thing.

[17:29] <TimToady> multisig is the name of the | syntax

[17:29] <masak> wright.

[17:29] <masak> right*

[17:29] <TimToady> but I realized a few weeks ago that we still had multiple sigs possible without |

[17:29] *** Trashlord joined
[17:29] <TimToady> for now we can just block it, until we decide it's implementable

[17:29] <masak> as above. yes, I just realized too, reading STD.pm6 :)

[17:30] <masak> I don't mind traits before the signature, but I don't see the point of multiple signatures.

[17:30] <masak> I think they're a bad idea.

[17:31] <TimToady> I think they're a better idea than either repeating yourself or defining a single-use trait

[17:31] <moritz> what's so bad about  multi sub infix:<+>(Date $d, Int $n) | (Int $n, Date $d) { Date.new($d.Int + $n) } # or so?

[17:31] <TimToady> effectively, it's just two subs sharing a body

[17:32] <moritz> rakudo: multi foo() { nextsame }; foo()

[17:32] <p6eval> rakudo 02ddac:  ( no output )

[17:32] <moritz> is that right?

[17:32] <masak> moritz: think so.

[17:32] <jnthn> We've been back and forth quite a few times on nextsame. I seem to remember that we ended up with the tests and Rakudo in a consistent state, but I forget which one it was :P

[17:33] <masak> it's consistent with how 'next' works.

[17:33] <TimToady> yes, next turns into last at the end :)

[17:33] <masak> lastsame ;)

[17:34] <TimToady> lastcall discards the rest of the list but returns

[17:35] <masak> I can definitely see the allure of 'infix:<+>(Date $d, Int $n) | (Int $n, Date $d)' and similar small examples. I still think it's a feature with only marginal benefit and lots of implementation complexity.

[17:35] <TimToady> which is why we're not requiring it yet

[17:35] <masak> considering how the alternative 'infix:<+>(Int $n, Date $d) { $d + $n }' isn't so bad.

[17:35] <TimToady> it might turn out to be trivial

[17:36] <masak> or someone could write a module to generate such signatures, and do a better job at it.

[17:36] <jnthn> Somebody already did implement is symmetric trait (colomon++ iirc)

[17:36] <masak> I for one would like to see an 'is commutative' trait.

[17:37] * TimToady hates it as insufficiently general, even though I originally proposed it

[17:37] <masak> 'symmetric' is a weird name for that, symmetric is things like '$x == $x'

[17:42] <TimToady> and I feel sorry for generations of math pupils whose teachers misprounounced it as "communative" :)

[17:45] <masak> huh! doesn't seem to happen here in .se

[17:48] <ruoso> thinking about "map { } <== ... ", IIUC, that parses as "(map { }) <== ...", which means that map gets invoked without a list... and in that case should return a new closure which will actually run the map with the items received by the closure... does that make sense?

[17:49] <ruoso> Or the compilation should do something completely different?

[17:51] <jnthn> dinner &

[17:51] <ruoso> std: (map { }).(1,2,3)

[17:51] <p6eval> std dc62e1d: OUTPUT«ok 00:01 122m␤»

[17:52] <ruoso> perl6: (map { .say }).(1,2,3)

[17:52] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class List␤  at /tmp/wFk1fSD9Cq line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2833 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2834 (module-CORE @ …

[17:52] <p6eval> ..rakudo 02ddac: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'List'␤  in <anon> at src/gen/Metamodel.pm:3368␤  in block <anon> at /tmp/C6ukQ6jiQi:1␤  in <anon> at /tmp/C6ukQ6jiQi:1␤»

[17:52] <p6eval> ..pugs b927740: OUTPUT«*** Cannot cast from VList [] to VCode (VCode)␤    at /tmp/8GVD9ZbkPH line 1, column 1 - line 2, column 1␤»

[17:58] <moritz> perl6: &map.assumming({ .say }).(1, 2, 3)

[17:58] <p6eval> rakudo 02ddac: OUTPUT«Method 'assumming' not found for invocant of class 'Sub'␤  in block <anon> at /tmp/tbcaIO8wVV:1␤  in <anon> at /tmp/tbcaIO8wVV:1␤»

[17:58] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Sub: "&assumming"␤    at /tmp/dRgYzwmG7Y line 1, column 1 - line 2, column 1␤»

[17:58] <p6eval> ..niecza v13-149-gbf6b78c: OUTPUT«Unhandled exception: Unable to resolve method assumming in class Sub␤  at /tmp/6Z9aFn4TCs line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2833 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2834 (module-CORE @ 58) ␤  at /…

[17:59] <kshannon> ruoso, no <== provides the list.

[17:59] <kshannon> "(map { }) <== ..." is not correct.

[18:00] <kshannon> The precedence is correct,  but the feed operators need special treatment as their arguments aren't complete expressions,  or at least the one it's pointing at isn't.

[18:01] <moritz> wow, we don't seem to have tests for {call,next}{with,same} with subroutines at all

[18:01] <kshannon> "map { } <== ..."  sorta parses as "map { } ( ... )"

[18:01] <moritz> just methods

[18:02] <moritz> ... except together with wrap

[18:04] <moritz> probably because it's not explicitly mentioned in S06 that those should work with subs too

[18:04] <moritz> they should, right?

[18:04] <moritz> nom: multi a($) { say 'Any' }; multi a(Int $) { say 'Int'; nextsame }; a(3)

[18:04] <p6eval> nom 02ddac: OUTPUT«Int␤Any␤»

[18:08] <kshannon> for @lazy { ... }

[18:09] <kshannon> What's the best way to rewrite that so for doesn't eagerly grab all of @lazy before it runs the body

[18:09] <moritz> it... shouldn't

[18:09] <kshannon> Well nom is...

[18:10] <kshannon> golfing...

[18:10] <moritz> nom: my @lazy = gather for 1..10 { take $_; say $_ } ; for @lazy { last }

[18:10] <p6eval> nom 02ddac: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[18:10] <moritz> nom: my @lazy := gather for 1..10 { take $_; say $_ } ; for @lazy { last }

[18:10] <p6eval> nom 02ddac: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[18:11] *** thou joined
[18:11] <moritz> indeed :/

[18:12] <kshannon> I'm a bit worried it was my patch to .[ ]

[18:12] * moritz doesn't see any .[ ] in that code

[18:16] <kshannon> Oops, I meant circumfix:<[ ]>,  and I'm thinking it might be called somewhere in the implementation of 'for'

[18:16] <colomon> nom's for has been doing that for quite a while now

[18:17] <kshannon> quite a while = days, weeks, or months ?

[18:18] <colomon> months, I think

[18:18] *** birdwindupbird left
[18:18] <kshannon> Oh.  Well that lets me off the hook :)

[18:19] <colomon> for *is* lazy for known infinite sources, so I assumed the current status was intentional.

[18:22] <TimToady> it is allowed to work ahead in batches for efficiency; maybe this falls in that category

[18:22] <kshannon> well,  how can I massage a gather into "known infinite" :)

[18:23] <colomon> TimToady: that actually vaguely rings a bell, now that you mention it.  I vaguely recall pmichaud doing something about batching 1000 at a time...

[18:24] <kshannon> Which reminds me, https://github.com/perl6/roast/blob/master/integration/99problems-01-to-10.t#L172

[18:25] <kshannon> Is that still correct,  as it only works when the take [ ... ] is eager.

[18:28] <TimToady> should not matter, since the join will eventually eager it

[18:31] <kshannon> Yeah,  but the while loops forever producing lazy lists...

[18:31] <kshannon> the outer while.

[18:32] *** shinobicl___ left
[18:37] <TimToady> well, you can always throw in an explicit 'eager'

[18:37] <TimToady> you are, after all, relying on side effects there...

[18:39] *** benabik joined
[18:39] <dalek> roast: b7433f7 | (Kris Shannon)++ | integration/99problems-01-to-10.t:

[18:39] <dalek> roast: Shouldn't be relying on laziness side effects.

[18:39] <dalek> roast: review: https://github.com/perl6/roast/commit/b7433f7e5b

[18:41] <dalek> roast: 43749dc | (Kris Shannon)++ | integration/99problems-01-to-10.t:

[18:41] <dalek> roast: Shouldn't be relying on side effects here either.

[18:41] <dalek> roast: review: https://github.com/perl6/roast/commit/43749dc70a

[18:55] <moritz> nom: multi b(Int $) { say 1; callsame; say 3 }; multi b($) { say 2 }; b(2);

[18:55] <p6eval> nom 02ddac: OUTPUT«1␤2␤3␤»

[18:55] <moritz> nom: multi b(Int $) { say 1; nextsame; say 3 }; multi b($) { say 2 }; b(2);

[18:55] <p6eval> nom 02ddac: OUTPUT«1␤2␤»

[19:00] <dalek> roast: caf3d2c | moritz++ | S06-multi/redispatch.t:

[19:00] <dalek> roast: tests for multi subs + {next,call}l}{with,same}

[19:00] <dalek> roast: review: https://github.com/perl6/roast/commit/caf3d2cb12

[19:00] <ruoso> kshannon: in that case <== is not simply a infix op... it needs to be a completely different category

[19:02] *** sayu left
[19:05] *** snearch left
[19:06] <kshannon> ruoso: S06:Feed Operators:  "Syntactically, feed operators expect to find a statement on either end"

[19:06] *** kaare__ left
[19:07] *** buubot_backup left
[19:08] <dalek> rakudo/nom: 327fc92 | moritz++ | t/spectest.data:

[19:08] <dalek> rakudo/nom: run new redispatcher tests

[19:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/327fc92b41

[19:09] <ruoso> so it's not the same as any other infix op

[19:10] <moritz> correct

[19:10] <TimToady> I don't think that S06 quote is correct anymore, however

[19:10] <TimToady> but feeds are a bit macroish

[19:10] <ruoso> ok... but does the current infix logic allow such macroish behavior? 

[19:11] <TimToady> well, && and || are macros too :)

[19:11] <TimToady> so, yes and no

[19:11] <ruoso> because the macroish subst of <== is quite substantial

[19:12] <moritz> down to 691 open rakudo tickets

[19:14] <ruoso> later&

[19:16] <moritz> what does infix fff do?

[19:16] <moritz> S03 says "sed style", but I don't know sed

[19:16] <TimToady> the difference is whether you check again on the same entry, or wait till the next time

[19:17] <sorear> good * #perl6

[19:17] <TimToady> with the one it's possible to go true and then false again on one entry

[19:17] <colomon> o/

[19:17] <moritz> "on one entry"?

[19:18] <TimToady> one call to ff or fff

[19:21] <kshannon> nom doesn't seem to have fff :(

[19:21] <TimToady> niecza: for 1..10 { if $_ == 4 fff $_ == 4 { .say } }

[19:21] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«4␤5␤6␤7␤8␤9␤10␤»

[19:21] <TimToady> niecza: for 1..10 { if $_ == 4 ff $_ == 4 { .say } }

[19:21] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«4␤»

[19:21] <TimToady> that's the difference

[19:21] <moritz> so... fff always checks the left and right side and xors, whereas ff only checks one side?

[19:21] <TimToady> it's not xor

[19:22] <TimToady> niecza: for 1..10 { if $_ == 4 fff $_ == 5 { .say } }

[19:22] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«4␤5␤»

[19:22] <TimToady> note you still get the 5

[19:22] <TimToady> the right side says whether it flips state *after* this time

[19:22] <TimToady> the only difference is when it starts checking the right side

[19:22] <TimToady> think of it in terms of line number ranges

[19:23] <TimToady> if you want 4..5 then it includes line 5

[19:23] <sorear> EOBACKLOG

[19:24] <TimToady> usually you want ff semantics, so it's the shorter one

[19:25] <TimToady> same in p5 with .. vs ...

[19:39] *** GlitchMr joined
[19:39] <GlitchMr> bash-3.1$ echo {P,p}{{erl,hp},ython}

[19:39] <phenny> GlitchMr: 25 Dec 21:22Z <tadzik> tell GlitchMr you should've tried qwebirc on a Kindle ;)

[19:39] <GlitchMr> Perl Php Python perl php python

[19:39] <GlitchMr> I still don't understand...

[19:39] <GlitchMr> wait...

[19:39] <GlitchMr> :P

[19:39] <GlitchMr> That's serious delay :P.

[19:40] <GlitchMr> Whatever.

[19:40] <GlitchMr> (I guess it's because I haven't said anything since then...)

[19:46] <colomon> right

[19:49] <GlitchMr> Personally, I like Perl because of good documentation :).

[19:49] *** thou left
[19:49] <GlitchMr> Compare: http://search.cpan.org/~makamaka/Text-CSV-1.21/lib/Text/CSV.pm

[19:49] <GlitchMr> and: http://docs.python.org/library/csv.html

[19:49] <GlitchMr> And that isn't core module... :P

[19:49] <GlitchMr> http://perldoc.perl.org/CGI.html :P

[19:50] <GlitchMr> http://docs.python.org/library/cgi.html

[19:50] <GlitchMr> And this

[19:56] <moritz> nom: sub t($c, @a) { my $r = ''; for @a { $r ~= $c($_) ?? $_ !! 'x' } }; say t { /B/ ff /D/ }, <A B C D E F>;

[19:56] <p6eval> nom 327fc9: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in method Bool at src/gen/CORE.setting:7239␤  in sub infix:<ff> at src/gen/CORE.setting:8502␤  in block <anon> at /tmp/v4klOM4CwO:1␤  in block <anon> at /tmp/v4klOM4CwO:1␤  in method reify at src/gen/CORE.setting:…

[19:56] <moritz> nom: sub t($c, @a) { my $r = ''; for @a { $r ~= $c($_) ?? $_ !! 'x' } }; say t { .say;  /B/ ff /D/ }, <A B C D E F>;

[19:56] <p6eval> nom 327fc9: OUTPUT«A␤Method 'match' not found for invocant of class 'Any'␤  in method Bool at src/gen/CORE.setting:7239␤  in sub infix:<ff> at src/gen/CORE.setting:8502␤  in block <anon> at /tmp/J7zrdkZXIC:1␤  in block <anon> at /tmp/J7zrdkZXIC:1␤  in method reify at src/gen/CORE.settin…

[19:56] <moritz> nom: sub t($c, @a) { my $r = ''; for @a { $r ~= $c($_) ?? $_ !! 'x' } }; say t { .say;  /B/ ff True }, <A B C D E F>;

[19:56] <p6eval> nom 327fc9: OUTPUT«A␤Method 'match' not found for invocant of class 'Any'␤  in method Bool at src/gen/CORE.setting:7239␤  in sub infix:<ff> at src/gen/CORE.setting:8502␤  in block <anon> at /tmp/eT4SzDlv3M:1␤  in block <anon> at /tmp/eT4SzDlv3M:1␤  in method reify at src/gen/CORE.settin…

[19:57] <moritz> hurm

[19:57] <moritz> somehow the /B/ match doesn't get the right $_, even though .say sees it

[19:57] <moritz> or any other idea what might be wrong here?

[19:57] <GlitchMr> ff?

[19:58] <moritz> GlitchMr: flip flop. See S03

[19:58] <GlitchMr> Some Perl 6 operators are weird for me... whatever :).

[19:59] <GlitchMr> It gives flexibility...

[19:59] *** thou joined
[20:00] <GlitchMr> @a >>>>> $b

[20:00] <GlitchMr> ... ok...

[20:00] <moritz> nom: sub t($c, @a) { my $r = ''; for @a { $r ~= $c($_) ?? $_ !! 'x' } }; say t { .say;  /B/ || True }, <A B C D E F>;

[20:00] <p6eval> nom 327fc9: OUTPUT«A␤B␤C␤D␤E␤F␤ABCDEF ABCDEF ABCDEF ABCDEF ABCDEF ABCDEF␤»

[20:01] <moritz> nom: sub t($c, @a) { my $r = ''; for @a { $r ~= $c($_) ?? $_ !! 'x' }; $r }; say t { .say;  /B/ || True }, <A B C D E F>;

[20:01] <p6eval> nom 327fc9: OUTPUT«A␤B␤C␤D␤E␤F␤ABCDEF␤»

[20:01] <moritz> nom: sub t($c, @a) { my $r = ''; for @a { $r ~= $c($_) ?? $_ !! 'x' }; $r }; say t { .say;  /B/ ff True }, <A B C D E F>;

[20:01] <p6eval> nom 327fc9: OUTPUT«A␤Method 'match' not found for invocant of class 'Any'␤  in method Bool at src/gen/CORE.setting:7239␤  in sub infix:<ff> at src/gen/CORE.setting:8502␤  in block <anon> at /tmp/v2G_Y9mp9n:1␤  in block <anon> at /tmp/v2G_Y9mp9n:1␤  in method reify at src/gen/CORE.settin…

[20:01] <GlitchMr> But seriously, who will use so many operators... many of those have limited usage...

[20:03] <sorear> std: sub foo(Any ::T $x) { }

[20:03] <p6eval> std dc62e1d: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/7Ds6nAqqgA line 1:␤------> [32msub foo(Any ::T [33m⏏[31m$x) { }[0m␤ok 00:01 121m␤»

[20:03] <sorear> rakudo: sub foo(Any ::T $x) { }

[20:03] <p6eval> rakudo 327fc9:  ( no output )

[20:03] <moritz> GlitchMr: http://www.google.com/search?q=site%3Aperlmonks.org+flip+flop # lots of people do

[20:04] <moritz> nom: $_ = 'a'; /a/ ff /a/;

[20:04] <p6eval> nom 327fc9: OUTPUT«Method 'match' not found for invocant of class 'Any'␤  in method Bool at src/gen/CORE.setting:7239␤  in sub infix:<ff> at src/gen/CORE.setting:8502␤  in block <anon> at /tmp/YknKE09sGg:1␤  in <anon> at /tmp/YknKE09sGg:1␤»

[20:04] <sorear> Perl 6 has been described as an operator-oriented language

[20:04] <moritz> nom: $_ = 'a'; /a/ || /a/;

[20:04] <p6eval> nom 327fc9:  ( no output )

[20:05] * moritz submits rakudobug

[20:05] <sorear> nom: $_ = 'a'; m/a/ ff m/a/

[20:05] <p6eval> nom 327fc9:  ( no output )

[20:05] <sorear> I think I see the problem

[20:06] <moritz> sorear: what is it?

[20:07] <moritz> ah, probably the   sub infix:<ff>($a as Bool, $b as Bool)

[20:07] <sorear> moritz: 'ff' is probably calling a helper sub, which calls .Bool on the arguments ... but $_ doesn't exist in the helper sub

[20:08] <moritz> tries to coerce the regex to Bool, but no $_ present anymore

[20:08] <sorear> nom: (say 1) ff (say 2)

[20:08] <p6eval> nom 327fc9: OUTPUT«1␤2␤»

[20:08] <sorear> niecza: (say 1) ff (say 2)

[20:08] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«1␤2␤»

[20:08] <sorear> niecza: (say 1; False) ff (say 2)

[20:08] <moritz> niecza: $_ = 'a'; /a/ ff /a/

[20:08] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«Rebuild in progress␤»

[20:09] <sorear> niecza: (say 1; False) ff (say 2)

[20:09] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«1␤»

[20:09] <sorear> nom: (say 1; False) ff (say 2)

[20:09] <p6eval> nom 327fc9: OUTPUT«1␤2␤»

[20:10] <sorear> std: my $x (5);

[20:10] <p6eval> std dc62e1d: OUTPUT«ok 00:01 122m␤»

[20:11] <moritz> what is that?

[20:11] <moritz> a sub-signature?

[20:13] <sorear> yes

[20:14] <sorear> why are sub-signatures allowed on variable_declarators?

[20:14] <moritz> nom: my $x (6)

[20:14] <p6eval> nom 327fc9: OUTPUT«===SORRY!===␤Confused at line 1, near "my $x (6)"␤»

[20:14] <moritz> sorear: probaby just an omission

[20:14] <sorear> Not a comission?

[20:23] <moritz> rakudo: $a = (my $a)

[20:23] <p6eval> rakudo 327fc9: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near " = (my $a)"␤»

[20:23] * Woodi started to like ff :)

[20:24] <tadzik> you see? :) Not that bad after all

[20:24] <Woodi> is there a multi-stage ff maybe ? :)

[20:24] *** snearch joined
[20:25] <Woodi> tadzik: found nice tutorial :) http://www.perlmonks.org/?node_id=525392

[20:27] <Woodi> eg. /^start/ ff /^level 1/ ff [more levels] ff /^end/ # ?

[20:28] <sorear> well, you need to use p6regex syntax there ... /^ 'level 1' /

[20:28] <moritz> Woodi: and what would that do?

[20:29] <Woodi> eg. parse area file for mud :)

[20:29] <Woodi> [ff] [/^ 'start' ], ..., /^ 'end' /] ?

[20:30] <Woodi> MUD like Diku or ROM :)

[20:32] <Woodi> something like that wont keep 0/1 state but rather keep state of actual matcher

[20:34] <Woodi> hmm, then branching can be added :) so probably should be called 'module Graph' or 'Automata' :)

[20:38] *** Patterner left
[20:41] *** shinobicl___ joined
[20:43] *** ksi joined
[20:43] *** Psyche^ joined
[20:43] *** Psyche^ is now known as Patterner

[20:45] *** zby_home joined
[20:46] *** birdwindupbird joined
[20:57] *** sudokode joined
[21:01] *** ponbiki joined
[21:02] *** snearch left
[21:04] *** GlitchMr left
[21:08] <[Coke]> 815 test failures in spectest on niecza.

[21:09] <[Coke]> masak: (be liberal in what you accept) - no. that way lies madness.

[21:12] *** thou left
[21:13] *** shinobicl___ left
[21:20] <sorear> bah

[21:20] <dalek> niecza: 45ad814 | sorear++ | / (3 files):

[21:20] <dalek> niecza: Make signature-setting system a bit more flexible

[21:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/45ad814ed2

[21:20] <dalek> niecza: fc233bd | sorear++ | src/ (6 files):

[21:20] <dalek> niecza: Mergeback; add some new Sig fields

[21:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/fc233bd09e

[21:26] <sorear> [Coke]: got a list of failing files?

[21:27] <colomon> woah, 815?!

[21:27] <[Coke]> sorear: it was from test_summary; doing an update and a regular spectest to see what's what.

[21:28] <sorear> integration/advent2009-day14 has some tests that are just plain wrong

[21:28] <sorear> like testing that the result of 1/60000 + 1/60001 is a Num

[21:28] *** yath left
[21:28] <[Coke]> ... and that just finished with a single failure in  t/spec/S02-types/parcel.t (#14)

[21:28] *** yath joined
[21:29] * [Coke] will rerun that test summary output.

[21:29] <[Coke]> sorry about the false alarm. :P

[21:29] *** spine left
[21:30] <colomon> sorear: that reminds me, I was thinking we might want to add a FatRat.t module.  :)

[21:32] <masak> [Coke]: I'd be interested to hear more about that. to me, that's the raison d'être for Cool -- we want the strictness of a type system but also the flexibility and promiscuous punning of the Perl 5 core types.

[21:33] <sorear> rakudo: sub foo ($x (1) (2)) { }

[21:33] <p6eval> rakudo 327fc9: OUTPUT«===SORRY!===␤Cannot have more than one sub-signature for a parameter at line 1, near ") { }"␤»

[21:34] <[Coke]> masak: ah, but if Cool is spec'd, then you can still be strict.

[21:34] <[Coke]> I'm referring to the madness of, say, HTML.

[21:36] *** birdwindupbird left
[21:37] <masak> [Coke]: ah, you see, my quote was to be taken in context.

[21:37] <masak> :)

[21:38] <masak> I was going to give an explanation of why HTML turned out to be so bad. but I can't actually envision a way in which it could've turned out better... :)

[21:39] <masak> browsers all had an evolutionary advantage from being liberal with tag soup.

[21:39] <doy> well, that's the problem

[21:40] <doy> "be liberal in what you accept" makes your software in particular a lot better

[21:40] <masak> and the web probably wouldn't have been as successful as it is today if it weren't for the liberalness.

[21:40] <doy> it just makes things as a whole worse

[21:41] <masak> so you're saying it's a zero-sum game between your software and... everything else? :)

[21:43] <doy> i'm saying it's a tragedy of the commons type situation

[21:43] <doy> (:

[21:47] <masak> the more I develop, the more I find I want my applications to fail fast during development, yet be very robust during production.

[21:47] <masak> and I find that the former leads to the latter.

[21:48] <sorear> ==masak

[21:48] <masak> but it's a challenge to teach novices that both sides of the coin are necessary :)

[21:48] <sorear> it's useful to have switches available to control robustness

[21:49] <sorear> -Werror and use warnings ':FATAL' are both awesome but shouldn't appear in shipped code

[21:49] <masak> actually, the kind of robustness needed during production still doesn't mean "ignore errors", it just means that the program no longer pretends that the user and the developer are the same person.

[21:49] <masak> so it should smile at the user and scream at the developer :P

[21:50] * jnthn back from dinner and beer

[21:50] <sorear> o/ jnthn

[21:50] <masak> jnthn! \o/

[21:50] <jnthn> masak! \o/

[21:50] <jnthn> d'y know, I just had a nice stout in Malmoe ;)

[21:51] <masak> hey, me too! :)

[21:51] <jnthn> ooh, I can type Malmö now :)

[21:51] <masak> that's better.

[21:51] <sorear> mäsak, too?

[21:52] <jnthn> yäs.

[21:52] <sorear> silly freenode not allowing utf-8 nicks

[21:52] <sorear> anyways, jnthn, I was thinking about the "but" issue

[21:53] <sorear> if we're going to allow things like $obj does (EXPR)($arg), then it's not really possible to improve on AST munging

[21:54] <sorear> the nextterm solution would most likely restrict us to the identifier case, which I think would be Bad

[21:54] <sorear> in particular I'm thinking of $obj does func($arg)($role-arg) ; you can't know where the role ends and the argument begins without using EXPR in some way

[21:55] <jnthn> Well, it'd have to be more than the identifier case anyway, since you can supply a list of roles to compose

[21:55] <jnthn> I've *no* idea how you'd initialize an attribute of them in that case though...

[21:56] *** PacoAir left
[21:56] <masak> I don't think I would've preferred "mäsak". "masak" feels like my online identity, "mäsak" feels like my last name and the way someone would address me in military service... :)

[21:58] <masak> moritz++ # ticket triaging

[22:01] <fsergot> nom: say (1,2) Z (3,4) Z (5,6);

[22:01] <p6eval> nom 327fc9: OUTPUT«1 3 5 2 4 6␤»

[22:01] <fsergot> nom: say (1,2) X (3,4) X (5,6);

[22:01] <p6eval> nom 327fc9: OUTPUT«1 3 5 1 3 6 1 4 5 1 4 6 2 3 5 2 3 6 2 4 5 2 4 6␤»

[22:02] *** mj41 left
[22:07] <colomon> niecza: say (1,2) Z (3,4) Z (5,6);

[22:07] <p6eval> niecza v13-149-gbf6b78c: OUTPUT«1 3 5 2 4 6␤»

[22:09] *** az5112 joined
[22:13] *** Kharec joined
[22:13] <Kharec> hi there

[22:13] * Kharec is a new perl6 adept :)

[22:14] <tadzik> hello Kharec !

[22:14] <Kharec> I'm building my rakudo for squeeze :)

[22:16] <masak> hi Kharec!

[22:17] <az5112> "1" + "1" = 2; "1" div "1" CHECK FAILED Calling 'infix:<div>' will never work with argument types (str, str) (line 1)

[22:17] <az5112> Is this by design? Why + works and div does not?

[22:17] <az5112> (rakudo)

[22:17] <Kharec> masak: hi

[22:19] <masak> az5112: div only works on specific types, for example Int/Int.

[22:19] <jnthn> I think the spec has some language on that too.

[22:19] <Kharec> maybe you can convert your str as int?

[22:20] <masak> az5112: whereas the usual + - * / tend to coerce to Numeric first.

[22:20] * Kharec hasn't wrote any line of perl6 right now. I'm about to learn it.

[22:20] <jnthn> Yes, just do .Int on it

[22:20] <jnthn> S03 says "Not coercive" for div

[22:20] <az5112> OK, I was expecting all operators would do type coercion.

[22:20] <jnthn> Which suggests Rakudo is doing what the spec says here

[22:21] <az5112> Ok, just checking :)

[22:21] <az5112> And what is the best way to turn a string to an int (I multiplied by 1)

[22:21] <Woodi> Kharec: you know Perl5 ?

[22:21] <tadzik> nom: say "55".Int.perl

[22:21] <p6eval> nom 327fc9: OUTPUT«55␤»

[22:21] <tadzik> az5112: ^

[22:22] <az5112> tadzik: thanks

[22:23] <Kharec> Woodi: Yes! I'm writing C, perl5 and python3 code

[22:23] <Kharec> and a bit of C++

[22:24] <Woodi> so you will have no start problems with Perl6 :)

[22:24] <Kharec> I hope so, thanks :)

[22:25] <Woodi> btw. why you just today want P6 ? :)

[22:25] <Kharec> It seems to be a very powerful and beautiful language :)

[22:26] <Kharec> It's not for professional purposes.

[22:26] <Woodi> good :) so you can hobbystic help in development :)

[22:27] <masak> nom: say (+"55").^name

[22:27] <p6eval> nom 327fc9: OUTPUT«Int␤»

[22:27] <masak> az5112: that's another way.

[22:27] <masak> az5112: prefix:<+> "numifies", but it does it in quite a smart way and finds the narrowes type that'll fit.

[22:27] <Kharec> Woodi: maybe. I've got a lot of job in dev yet, i'm a mageia contributor

[22:28] <Woodi> Kharec: the central point of perl6 is documentation/specyfication. you can check it at perl6.org

[22:28] <masak> Kharec: Perl 6 is indeed powerful and beautiful. I don't think that much about it any more, except when I switch over to other languages :P

[22:28] <Woodi> and ask here too

[22:29] <Kharec> ok! Is there a complete PDF to learn it correctly?

[22:29] <Woodi> the enciclopedia size html pages :)

[22:29] *** fsergot left
[22:30] <x3nU> there's book https://github.com/perl6/book/

[22:30] <az5112> masak: I first tried Int $aa and int $a (thought I say it somewhere on the web) but that did not work. "1".Int looks quite elegant.

[22:30] <x3nU> and synopsis

[22:30] <x3nU> http://perlcabal.org/syn/

[22:31] <masak> az5112: 'Int $a' used to be the way you did casting. it's deprecated.

[22:31] <Kharec> thanks all!

[22:31] <Kharec> good night!

[22:31] *** Kharec left
[22:32] <masak> phenny: tell Kharec may I humbly recommend http://strangelyconsistent.org/blog/june-1-2011-input-and-output for learning Perl 6? all of the posts can be found at http://strangelyconsistent.org/blog/list-of-posts

[22:32] <phenny> masak: I'll pass that on when Kharec is around.

[22:32] <masak> man, I need to build an index of those posts :)

[22:32] <masak> or even, *shudder*, a category system...

[22:48] *** Salaysia joined
[22:51] *** fsergot joined
[22:52] *** donri left
[22:52] <fsergot> How can I calculata an expression contained in string?

[22:52] <fsergot> e.g. "2+2"

[22:52] <tadzik> either write an expression parser, or use eval :)

[22:53] <Woodi> 2GB is to small to compile rakudo ??

[22:53] <tadzik> shouldn't be

[22:53] <tadzik> close your web browser though :)

[22:54] <fsergot> tadzik, would You like to show me how do it using eval? :)

[22:55] <tadzik> nom: say eval "2+2"

[22:55] <p6eval> nom 327fc9: OUTPUT«4␤»

[22:55] <tadzik> that way I guess :)

[22:55] <fsergot> nom: my $expr = "2+2; say eval $expr;

[22:56] <Woodi> I compile remote, free 1500+ MB, OpenBSD

[22:56] <p6eval> nom 327fc9: OUTPUT«===SORRY!===␤Confused at line 1, near "my $expr ="␤»

[22:56] <fsergot> ehh

[22:56] <jnthn> missing @

[22:56] <jnthn> er

[22:56] <fsergot> nom: my $expr = "2+2"; say eval $expr;

[22:56] <jnthn> missing "

[22:56] <p6eval> nom 327fc9: OUTPUT«4␤»

[22:56] <sorear> isn't the rakudo build around 3GB now?

[22:56] <tadzik> is it?

[22:56] <jnthn> Not heard anybody give that kind of figure

[22:57] <sorear> dunno, I try to avoid building rakudo ...

[22:57] <tadzik> moritz was saying something about 1.8 some time ago

[22:57] *** pochi left
[22:58] <jnthn> tadzik: Sounds more like it, for 64-bit.

[22:58] <Woodi> is such amount of memory realy necessary ?

[22:59] *** bkolera joined
[22:59] <jnthn> Woodi: At the moment, that's what building Rakudo needs. I'll be less in the future.

[23:00] <Woodi> jnthn: you stated actual state :)

[23:00] *** thou joined
[23:01] <Woodi> but I say 'OK', becouse no idea how to help

[23:01] <jnthn> er, it'll be less...

[23:02] <jnthn> Woodi: Well, some of the top ROADMAP items will help. Beyond that I probably need to hack up a memory profiler to understand the usage better.

[23:05] <Woodi> jnthn: I hoped about some magic-build-time-split-output trick...

[23:06] <jnthn> Woodi: I'd rather spend my time solving the real underlying issues. If Rakudo can't reasonably compile an amount of code the size of the setting without needing tricks, that's a problem.

[23:08] <Woodi> anyway two more notes from openbsd try: nqp test with parrot optimized failed on bigint test and something openbsd-security specific: http://pastebin.com/CrGXUQSW

[23:08] <Woodi> no chance some Makefile-lvl changes can change mem usage ?

[23:09] <tadzik> maybe if you remove --optimize=3?

[23:09] <jnthn> Woodi: no

[23:10] <Woodi> tadzik: you saying about mem or bigint ? :)

[23:10] <tadzik> Woodi: mem

[23:11] <jnthn> Woodi: (openbsd-security) if those functions are suitably portable, patches to switch to them are fine

[23:12] <Woodi> jnthn: at least two of them are strict openbsd. probably pragmas/macros in C code needed

[23:12] <jnthn> ah

[23:13] *** packetknife joined
[23:14] <Woodi> I will try to look closer on that strlcpy/strlcat tomorow.

[23:15] <Woodi> but now good night ppl

[23:15] <tadzik> g'night

[23:15] <jnthn> 'night, Woodi 

[23:16] *** Salaysia left
[23:20] <sorear> I'm not calling Perl 6 production-ready until it's possible to compile and load 100,000 lines of code in <256 MB of memory in 5 minutes or less

[23:21] *** jferrero left
[23:21] *** jferrero joined
[23:22] *** HarryS left
[23:22] <masak> a reasonable goal, I think.

[23:26] <masak> sorear: what's the memory consumption and total time right now?

[23:27] <sorear> masak: I haven't tried on anything quite that large yet ... STD.pm6 (~6500 loc) takes just under a minute with about 300MB

[23:27] <sorear> actually it's probably more like 1.5 minutes now, compiler speed has regressed a bit and I'm not sure why :|

[23:27] <sorear> (niecza)

[23:32] <masak> so... 6.5 kLOC in 1.5 minutes. that would make 100 kLOC take 23 minutes.

[23:32] *** az5112 left
[23:32] <masak> so a 5x speedup would be required.

[23:33] *** Mowah left
[23:34] <masak> I wouldn't mind a page like http://perl6.org/compilers/features but for these kinds of numbers, and goals.

[23:36] *** wolfman2000 left
[23:39] *** ponbiki left
[23:44] <colomon> sorear: have you looked at implementing parsing portion of the <2/3> change?  right now it's causing failures in  rat.t and complex.t.

[23:45] <dalek> niecza: 323ddd3 | sorear++ | src/ (2 files):

[23:45] <dalek> niecza: Implement parser/translation for sub-signatures and where

[23:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/323ddd3bc8

[23:45] <dalek> niecza: 29d510e | sorear++ | lib/ (2 files):

[23:45] <dalek> niecza: Refactor binder to allow binding standalone signatures

[23:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/29d510e59d

[23:45] <sorear> colomon: what parsing portion?

[23:45] <colomon> niecza: say <2/3>

[23:45] <p6eval> niecza v13-152-gfc233bd: OUTPUT«2/3␤»

[23:46] *** thou left
[23:46] <colomon> niecza: say <2/3>.WHAT

[23:46] <p6eval> niecza v13-152-gfc233bd: OUTPUT«Str()␤»

[23:46] <sorear> colomon: Why are you inserting <2/3> into the source code?

[23:46] <colomon> I'm not.  But the number tests check if you can eval the output of .perl and get the same thing

[23:46] <sorear> oh, rat.t is using eval :(

[23:46] <colomon> and right now, you can't in niecza

[23:47] <sorear> rakudo: say <2/3>.perl

[23:47] <colomon> fudging it isn't a major issue, mind you

[23:47] <p6eval> rakudo 327fc9: OUTPUT«"2/3"␤»

[23:47] <sorear> I'll get on that later ... it depends on val() and constant folding, but I think i have those mostly figured out

[23:48] <colomon> sorear++

[23:48] <sorear> constant folding because I really don't want to make for <a b c> { ... } any slowe

[23:50] *** ksi left
[23:52] <sorear> rakudo: sub foo(2) {}; foo(3)

[23:52] <p6eval> rakudo 327fc9: OUTPUT«Constraint type check failed for parameter ''␤  in sub foo at /tmp/luUHmnf87I:1␤  in block <anon> at /tmp/luUHmnf87I:1␤  in <anon> at /tmp/luUHmnf87I:1␤»

