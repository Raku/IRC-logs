[00:00] *** zby_home_ left
[00:05] <colomon> well, why don't we start with shell, then?

[00:05] <colomon> there are like 20 test files that depend on Test::Util...

[00:06] <sorear> mm

[00:07] <colomon> I'm willing to take a stab at implementing it if you're busy with something else.

[00:07] <sorear> right now I'm stabbing at MMD+junctions, so yeah

[00:08] <colomon> do you have any quick pointers to the relevant C# library functions?

[00:08] <sorear> you want Mono.Unix.Native.Stdlib.system (public static int system(string string);)

[00:09] <sorear> eventually we should also support the native C# System.Diagnostics.Process API

[00:09] <sorear> which is very close to the native Windows API, and rather poorly suited for Linux

[00:09] <sorear> (in particular, Windows and thus C# has no API for "invoke program given string[] args")

[00:16] *** zby_home joined
[00:19] *** replore_ joined
[00:20] <colomon> is it okay for niecza to be using Mono.Unix.Native.Stdlib?

[00:20] <colomon> The type or namespace name `Unix' does not exist in the namespace `Mono'. Are you missing an assembly reference?

[00:20] <colomon> bother

[00:22] <geekosaur> don't see it offhand in the mono build from macports

[00:23] <colomon> I'm actually using a mono binary which came straight from the mono project.

[00:23] <colomon> (on OS X)

[00:26] *** bluescreen10 left
[00:27] *** zby_home__ joined
[00:28] *** zby_home left
[00:28] <sorear> colomon: niecza loads Mono.Unix.Native.Stdlib at runtime

[00:28] <colomon> yeah, just looking at that

[00:28] <sorear> you can probably follow the example of the delegate functions

[00:29] <colomon> seems like I want to m_system = Syscall.GetMethod("system")

[00:29] <sorear> system would be in Stdlib

[00:30] <colomon> right

[00:30] *** leprevost_ left
[00:30] *** Maddingue joined
[00:30] <LlamaRider> Any idea how I can make a Pair inside a {} block? Example:

[00:30] <LlamaRider> rakudo: my @a=(1,2);  say @a.map({ 2*$_ });  say @a.map({ $_ => 2*$_ });

[00:30] <p6eval> rakudo 38165a: OUTPUT«2 4␤use of uninitialized variable $_ of type Any in numeric context␤use of uninitialized variable $!key of type Any in string context␤Method 'count' not found for invocant of class 'Hash'␤  in method reify at src/gen/CORE.setting:4380␤  in method reify at src/gen/C…

[00:31] <sorear> but you could also copy the Deelegate.CreateDelegate version

[00:31] <sorear> LlamaRider: any way but that

[00:31] <LlamaRider> Such a mathematical answer ^^

[00:31] <sorear> for instance, $( $_ => 2 * $_ ) would work

[00:32] <LlamaRider> O_O never seen that syntax before

[00:32] <LlamaRider> how do you plug it in a map, and what is $() ?

[00:32] <sorear> $() is a mostly noop expression

[00:32] <sorear> any noop will do

[00:32] *** Lothbot joined
[00:32] <sorear> just... don't have => at the top level

[00:33] <sorear> what ways did you try before asking for help?

[00:33] <LlamaRider> the one I mentioned. I know the explicit one via Pair.new, but that isn't pretty

[00:34] *** Lothar left
[00:34] <sorear> that would have worked too

[00:34] <diakopter> perl6: class A { has $!b; say $!b }

[00:34] <p6eval> pugs b927740: OUTPUT«*** Undeclared variable: ("$__SELF__",MkPad (padToList [("$_",PELexical {pe_type = (mkType "Scalar"), pe_proto = <Scalar:0x7f334e8e51f9>, pe_flags = MkEntryFlags {ef_isContext = True}, pe_store = <ref:0x7f334e8e7199>}),("@_",PELexical {pe_type = (mkType "Array"), pe…

[00:34] <p6eval> ..niecza v13-194-gf409a86: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $!b used where no 'self' is available at /tmp/4lEUitm6uh line 1:␤------> [32mclass A { has $!b; say [33m⏏[31m$!b }[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 …

[00:34] <p6eval> ..rakudo 38165a: OUTPUT«Can only use repr_get_attr_obj on a SixModelObject␤  in <anon> at /tmp/MeEUQS0ULK:1␤  in block <anon> at /tmp/MeEUQS0ULK:1␤  in <anon> at /tmp/MeEUQS0ULK:1␤»

[00:34] *** Lothbot is now known as Lothar

[00:35] <sorear> diakopter!  Are you feeling better?

[00:35] <diakopter> meh

[00:35] <diakopter> pugs response is funny

[00:36] * sorear offers hugs as appropriate

[00:37] <LlamaRider> rakudo: my @a=(1,2); say @a.map({ ($_ => 2*$_ ) });

[00:37] <p6eval> rakudo 38165a: OUTPUT«1 2 2     4␤»

[00:37] <LlamaRider> this works, but it is slowly turning into a bracket onion :)

[00:42] *** LlamaRider left
[00:43] <colomon> ooo, I got a compile....

[00:46] <benabik> nom: my $a = 1,2; say @a.map: (2 * *)

[00:46] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Variable @a is not predeclared at line 1, near ".map: (2 *"␤»

[00:46] <benabik> nom: my @a = 1,2; say @a.map: (2 * *)

[00:46] <p6eval> nom 38165a: OUTPUT«2 4␤»

[00:47] <benabik> nom: my @a = 1,2; say @a.map: { $^n => 2 * $^n }

[00:47] <p6eval> nom 38165a: OUTPUT«1    2 2     4␤»

[00:48] <colomon> \o/

[00:49] *** bacek left
[00:53] <colomon> oh, blast

[00:54] <colomon> Test::Util fails with is export(:DEFAULT) -- Export tags NYI now.  :(

[00:54] * [Coke] wonders if https://rt.perl.org/rt3/Ticket/Display.html?id=76648 is a bug.

[00:55] <[Coke]> rakudo: class Foo { has $.bar; has $.baz; has $.biff }; Foo.^methods.join(", ").say;

[00:55] <p6eval> rakudo 38165a: OUTPUT«bar, baz, biff␤»

[00:55] <[Coke]> rakudo: class Foo { has $.bar; has $.baz; has $.biff }; Foo.^methods.join(", ").say;

[00:55] <p6eval> rakudo 38165a: OUTPUT«bar, baz, biff␤»

[00:55] <[Coke]> rakudo: class Foo { has $.bar; has $.baz; has $.biff }; Foo.^methods.join(", ").say;

[00:56] <p6eval> rakudo 38165a: OUTPUT«bar, baz, biff␤»

[00:56] <[Coke]> (jut making sure it didn't change order.)

[00:57] *** replore_ left
[00:57] *** jupp1 left
[00:57] <dalek> niecza: 981626c | sorear++ | lib/ (2 files):

[00:57] <dalek> niecza: Refactor MMD a bit, add junction support

[00:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/981626cc62

[00:57] <dalek> roast: 9ba6fa4 | sorear++ | S03-junctions/autothreading.t:

[00:57] <dalek> roast: [S03-junctions/autothreading] Unfudge MMD tests

[00:57] <dalek> roast: review: https://github.com/perl6/roast/commit/9ba6fa4118

[00:57] <sorear> This gets a few more.  Hopefully without breaking anything else.

[00:58] <colomon> I'm spectesting with my patch at the moment, but I'll run another with yours as soon as this is done.

[00:59] <[Coke]> rakudo: %*h.push: 1 => 2; %*h.perl.say

[00:59] <p6eval> rakudo 38165a: OUTPUT«Method 'push' not found for invocant of class 'Failure'␤  in block <anon> at /tmp/f6IrtEzwYb:1␤  in <anon> at /tmp/f6IrtEzwYb:1␤»

[00:59] <[Coke]> colomon: ooh, lemme know hen I can do another comparison run.

[00:59] <colomon> [Coke]: my patch hasn't gotten us any new tests yet  :(

[01:00] <[Coke]> rakudo: role A[::T] { state $foo; say ++$foo }; A[Int]; A[Str]

[01:00] <p6eval> rakudo 38165a:  ( no output )

[01:02] <sorear> [Coke]: I see what's going on there

[01:02] <[Coke]> rakudo: class AB{has @.x; method aa { my @y=1,2,3; .say for @y[1 .. +@y]; .say for @.x; .say for @.x[1 ..^ +@.x] } };my AB $y.=new(:x(1,2,3)); $y.aa;

[01:02] <p6eval> rakudo 38165a: OUTPUT«2␤3␤Any()␤1␤2␤3␤2␤3␤»

[01:02] <dalek> niecza: cda492b | (Solomon Foster)++ | lib/ (2 files):

[01:02] <dalek> niecza: Stab at implementing shell using Stdlib.system.

[01:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/cda492b751

[01:03] <[Coke]> sorear: I'm going through some old rakudo tickets, FYI.

[01:04] <[Coke]> rakudo: my %h = {"a" => "b"}; %h{"a"} = %h.delete("a"); say %h.perl;

[01:04] <p6eval> rakudo 38165a: OUTPUT«().hash␤»

[01:04] <[Coke]> sorear: so, where now?

[01:05] <[Coke]> rakudo: say (1..10).sort(&rand)

[01:05] <p6eval> rakudo 38165a: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in sub rand at src/gen/CORE.setting:3053␤  in method reify at src/gen/CORE.setting:4380␤  in method reify at src/gen/CORE.setting:4285␤  in method gimme at src/gen/CORE.setting:4649␤  in method eager at …

[01:06] <[Coke]> rakudo: 1 / 10000000000000000000000000000000 ; say "alive"

[01:06] <p6eval> rakudo 38165a: OUTPUT«alive␤»

[01:07] <sorear> [Coke]: do you mean my next project?  two-level attribute storage

[01:07] <sorear> *naming rather

[01:08] <[Coke]> you said, "i see what's going on there.", I didn't know which there you were.

[01:08] <[Coke]> rakudo: my @a = <one two>; @a[-1] = 'zero'; @a.perl

[01:08] <p6eval> rakudo 38165a: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/55lCbf7U7p:1␤  in <anon> at /tmp/55lCbf7U7p:1␤»

[01:08] <sorear> [Coke]: A[Str]; A[Int]

[01:11] <colomon> sorear: spectest passes with your latest changes too

[01:12] <[Coke]> rakudo: say %( \( (:a(2)) )).WHAT

[01:12] <p6eval> rakudo 38165a: OUTPUT«EnumMap()␤»

[01:13] <colomon> Unhandled exception: Niecza.Serialization.ThawException: dated sources

[01:13] <colomon> sorear: ^^  ??????

[01:13] <[Coke]> rakudo: say %( \( (:a(2)) )).isa(Positional)

[01:13] <p6eval> rakudo 38165a: OUTPUT«Bool::False␤»

[01:15] <sorear> colomon: how did you pull THAT one off?

[01:15] <[Coke]> rakudo: class foo { has $!baz = 'ipsum'; method bar { my $!baz = 'lorem'; say $!baz; }; }; my $foo = foo.new; $foo.bar;

[01:15] <p6eval> rakudo 38165a: OUTPUT«ipsum␤»

[01:16] <colomon> I changed Test::Util just a tad and then reran the test file I've been trying to get to work.

[01:16] <[Coke]> rakudo: say (my $a) = 1,2,3; say $a

[01:16] <p6eval> rakudo 38165a: OUTPUT«1 2 3␤1 2 3␤»

[01:16] <[Coke]> rakudo: say ((my $a) = 1,2,3);

[01:16] <p6eval> rakudo 38165a: OUTPUT«1 2 3␤»

[01:17] <[Coke]> rakudo: (say (my $a)) = 1,2,3;

[01:17] <p6eval> rakudo 38165a: OUTPUT«Any()␤Cannot assign to a non-container␤  in block <anon> at /tmp/df58A5abKz:1␤  in <anon> at /tmp/df58A5abKz:1␤»

[01:18] <sorear> colomon: sounds like you've found a way to break the compilation cache :(

[01:19] <colomon> make realclean?

[01:19] <[Coke]> rakudo: 1 .. 2 .. 3

[01:19] <p6eval> rakudo 38165a:  ( no output )

[01:19] <[Coke]> st: 1 .. 2 .. 3

[01:19] <[Coke]> std: 1 .. 2 .. 3

[01:19] <p6eval> std dc62e1d: OUTPUT«[31m===[0mSORRY![31m===[0m␤".." and ".." are non-associative and require parens at /tmp/Ap8Q2Xqvcf line 1:␤------> [32m1 .. 2 .. [33m⏏[31m3[0m␤Check failed␤FAILED 00:01 109m␤»

[01:19] <sorear> colomon: probably

[01:20] <sorear> colomon: are you doing anything with BEGIN in your Test::Util?

[01:20] <[Coke]> rakudo: 01

[01:20] <p6eval> rakudo 38165a:  ( no output )

[01:20] <[Coke]> rakudo: NaN.Rat

[01:21] <p6eval> rakudo 38165a: OUTPUT«(timeout)»

[01:22] <[Coke]> rakudo: say { $^x }.assuming(1).signature

[01:22] <p6eval> rakudo 38165a: OUTPUT«Method 'assuming' not found for invocant of class 'Block'␤  in block <anon> at /tmp/sGW5kK1mNs:1␤  in <anon> at /tmp/sGW5kK1mNs:1␤»

[01:22] *** dku left
[01:23] <colomon> There's no BEGIN that I can see, the only "weird" thing I notice is a proto

[01:24] *** tokuhirom left
[01:24] *** tokuhirom joined
[01:25] <[Coke]> rakudo: say 684-76

[01:25] <p6eval> rakudo 38165a: OUTPUT«608␤»

[01:25] <colomon> still getting it after make realcvlean

[01:26] <colomon> other things work fine

[01:26] <[Coke]> rakudo: "foo" ~~ /<B::TOP>/

[01:26] <p6eval> rakudo 38165a: OUTPUT«Method 'B' not found for invocant of class 'Cursor'␤  in regex <anon> at /tmp/A3AivIfbMB:1␤  in method ACCEPTS at src/gen/CORE.setting:7260␤  in block <anon> at /tmp/A3AivIfbMB:1␤  in <anon> at /tmp/A3AivIfbMB:1␤»

[01:29] <[Coke]> akudo: my ($a is readonly) = 5; say $a; $a = 42; say $a

[01:29] <[Coke]> rakudo: my ($a is readonly) = 5; say $a; $a = 42; say $a

[01:29] <p6eval> rakudo 38165a: OUTPUT«5␤42␤»

[01:29] <sorear> colomon: :(  I'll look at it later

[01:29] *** tokuhirom left
[01:29] <[Coke]> rakudo: my @a=0..*; @a[Inf]=3; say @a[Inf]; # found by lue

[01:29] <p6eval> rakudo 38165a: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(\$v, Mu *%_)␤␤  in method Numeric at src/gen/CORE.setting:646␤  in sub infix:<+> at src/gen/CORE.setting:2192␤  in method exists at src/gen/CORE.setting:4634␤  in method at_pos…

[01:42] *** Trashlord left
[01:43] <colomon> niecza: my @a = <a b c d>; say @a.WHAT

[01:43] <p6eval> niecza v13-198-gcda492b: OUTPUT«Array()␤»

[01:43] *** Trashlord joined
[01:44] <dalek> niecza: 938e43f | sorear++ | lib/ (6 files):

[01:44] <dalek> niecza: Track what classes various attributes came from, and add overloads of GetSlot/SetSlot that check for matches

[01:44] <dalek> niecza: review: https://github.com/sorear/niecza/commit/938e43fd2a

[01:44] <sorear> this is only the lead-up to an eventual relaxation of the "unique attribute names" rule

[01:45] *** Trashlord left
[01:47] *** Trashlord joined
[01:48] *** jferrero joined
[01:48] *** jferrero left
[01:49] *** jferrero joined
[02:09] *** replore_ joined
[02:14] *** leprevost joined
[02:28] <dalek> niecza: 67bd4e6 | sorear++ | lib/ (9 files):

[02:28] <dalek> niecza: Specify types when accessing attributes in the C# code

[02:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/67bd4e657b

[02:29] *** zby_home__ left
[02:29] *** zby_home_ joined
[02:33] *** panterax_ left
[02:38] *** abercrombie joined
[02:47] *** abercrombie left
[02:55] *** jeffreykegler joined
[02:57] *** jeffreykegler left
[02:59] <colomon> woah, a whole batch of test failures after those last two patches, sorear 

[03:02] <colomon> sorear: look at t/spec/S14-roles/attributes.t

[03:02] <colomon> (for example)

[03:06] <dalek> niecza: 0c7c992 | sorear++ | / (6 files):

[03:06] <dalek> niecza: Now also specify the types for Perl 6 accesses

[03:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0c7c992f3f

[03:07] *** zjmarlow joined
[03:07] *** zjmarlow left
[03:07] *** zjmarlow_ joined
[03:08] <[Coke]> https://gist.github.com/1476841 - # 01/10/2012 - niecza at 97.37%

[03:08] <sorear> colomon: thanks

[03:10] <dalek> niecza: 2fbf907 | sorear++ | lib/Kernel.cs:

[03:10] <dalek> niecza: Reset AttrInfo.owner when composing roles, fixes S14-roles/attribute.t

[03:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2fbf90791e

[03:13] <sorear> owwww

[03:14] <sorear> all of S14 works now except anonymous.t - which had a bug in the tests that is just now discovered!

[03:14] *** zjmarlow_ left
[03:14] <sorear> colomon: any fails outside S14?

[03:14] *** zjmarlow_ joined
[03:16] <colomon> t/spec/S32-str/capitalize.t and uc.t

[03:16] <colomon> t/spec/S12-construction/autopairs.t

[03:16] <colomon> rest are S14

[03:16] <colomon> afk # bed

[03:20] <sorear> good night

[03:20] *** abercrombie joined
[03:20] <dalek> roast: b4bf84f | sorear++ | S14-roles/anonymous.t:

[03:20] <dalek> roast: [S14-roles/anonymous] Do not try to mutate 3; refude for niecza

[03:20] <dalek> roast: review: https://github.com/perl6/roast/commit/b4bf84f7ad

[03:21] <sorear> all the colomon-reported fails are working now

[03:24] *** replore_ left
[03:25] <dalek> niecza: 11e7c79 | sorear++ | lib/ (2 files):

[03:25] <dalek> niecza: Remove old typeless Get/SetSlot

[03:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/11e7c79714

[03:26] *** motherbrain joined
[03:26] <motherbrain> http://pastebin.com/kKGBa1nC

[03:26] <motherbrain> have fun :)

[03:29] <sorear> motherbrain: Why are you posting that here?  It's not Perl 6.

[03:29] <motherbrain> its perl maybe not version 6

[03:29] <geekosaur> this channel is for perl 6 development

[03:30] <motherbrain> sorry

[03:31] * sorear is having trouble finding the backdoor installer

[03:34] <motherbrain> nc -l 5000  on the shell :)

[03:35] <sorear> your current behavior is very suggestive of someone who is trying to recruit zombies

[03:37] <motherbrain> no just joking around

[03:38] *** Psyche^ joined
[03:38] <motherbrain> plus that wouldn't work very well for long term 

[03:38] *** orafu left
[03:39] *** orafu joined
[03:42] *** Patterner left
[03:42] *** Psyche^ is now known as Patterner

[03:45] *** thou joined
[03:45] *** zjmarlow_ left
[03:45] *** zjmarlow__ joined
[03:48] *** zjmarlow_ joined
[03:48] *** zjmarlow__ left
[03:58] <dalek> niecza: 2a36cd1 | sorear++ | lib/ObjModel.cs:

[03:58] <dalek> niecza: Enable using the same attribute name twice in one inheritence hierarchy

[03:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2a36cd1e35

[04:03] <sorear> rakudo: say Pair.^attributes

[04:03] <p6eval> rakudo 38165a: OUTPUT«$!key $!value␤»

[04:06] <sorear> rakudo: class Foo { has $.foo } ; say Foo.^attributes

[04:06] <p6eval> rakudo 38165a: OUTPUT«$!foo␤»

[04:08] *** HarryS left
[04:11] *** HarryS joined
[04:14] *** zjmarlow_ left
[04:14] *** zjmarlow_ joined
[04:22] *** lestrrat left
[04:23] *** lestrrat joined
[04:33] *** zjmarlow joined
[04:35] *** zjmarlow_ left
[04:39] *** zjmarlow left
[04:53] <kshannon> In regards to LTM, according to the specs atm as I understand them https://gist.github.com/1593074 should be matching via rule b.

[04:53] <kshannon> It is possible to do that way,  but it's not easy.  The current implementations (including the new NFA stuff in the new nqp branch) don't because it's a giant pain in the ass.

[04:53] <kshannon> I reckon most real life grammars won't be trying to take advantage of the spec as is,  and will actually likely be fine with the current implementation.

[04:53] <kshannon> Do you think we should change the spec to match the implementations?

[04:55] <sorear> niecza: https://gist.github.com/1593074

[04:55] <p6eval> niecza v13-204-g2a36cd1: OUTPUT«#<match from(0) to(5) text(xxxxx) pos([].list) named({"a" => #<match from(0) to(5) text(xxxxx) pos([].list) named({}.hash)>}.hash)>␤»

[04:55] *** birdwindupbird joined
[04:56] <kshannon> Yeah,  it matches via the second branch of <a>,  but TOP only chooses <a> because of LTM for the first branch.

[04:57] <sorear> niecza: grammar LTM-Hell { rule TOP { [ <a> | <b> ] }; token a { [ xxxxx <!> | xxx <?> xx ] }; token b { [ xxxx <?> x ] } }; say LTM-Hell.parse('xxxxx').keys

[04:57] <p6eval> niecza v13-204-g2a36cd1: OUTPUT«a␤»

[04:57] <sorear> niecza: grammar LTM-Hell { token TOP { [ <a> | <b> ] }; token a { [ xxxxx <!> | xxx <?> xx ] }; token b { [ xxxx <?> x ] } }; say LTM-Hell.parse('xxxxx').keys

[04:57] <p6eval> niecza v13-204-g2a36cd1: OUTPUT«b␤»

[04:57] <sorear> LTM doesn't work in rules in niecza

[04:57] <kshannon> Hmmm...

[04:58] <kshannon> So it isn't such a pain in th ass for you :)

[04:58] <kshannon> I guess I'm going to have to checkout niecza...

[04:59] <sorear> that said, I'm planning to change it to a for performance reasons

[05:00] *** Lothar left
[05:00] <kshannon> lol

[05:01] <kshannon> So I guess my question still stands.

[05:01] <sorear> it works in niecza because <!> is a little bit special

[05:01] <TimToady> the <ws> rules have changed recently so that rules should be much saner on LTM

[05:01] *** Lothar joined
[05:02] <sorear> most zero-width assertions are completely ignored during declarative analysis, by deuterospec

[05:02] <sorear> but for some reason niecza respects <!> in LTM

[05:02] <TimToady> but <!> and <?> are short lookaheads, it can be argued

[05:02] <TimToady> so we ignore ! and take the ? path

[05:03] <kshannon> Well,  replace them with appropriate fail and pass sequence points...

[05:03] <kshannon> My question is not actually about the <?> and <!>

[05:04] <TimToady> but the LTM is supposed to allow backoff to the next best case, which STD's fate system allowed, so it would have picked b

[05:04] <TimToady> (I think)

[05:05] <kshannon> Yeah,  I agree that the answer should be b as currently specced,  I'm just saying that being able to do that efficiently is not easy.

[05:05] <kshannon> (That's efficient in both space and time)

[05:05] <sorear> TimToady: But <a> doesn't fail.

[05:05] <sorear> TimToady: <a> has a longer declarative prefix, and <a> succeeds

[05:06] <sorear> TimToady: but the path within <a> that succeeds is shorter than the declarative prefix of <b>, because <a> matches *less* than its declarative prefix

[05:06] <TimToady> with fates, it only succeeds down into the first branch of a

[05:06] <TimToady> that's why they're called "fates"

[05:07] <TimToady> you don't have to keep rerunning the LTM at each level; the top level figgers it all out

[05:08] <sorear> interesting

[05:08] <sorear> this is the first actual problem I've seen resulting from abandoning fates

[05:09] <kshannon> The top level figuring it all out is easy.  Passing that knowledge into the regex subs requires interesting gymnastics.

[05:09] <dalek> niecza: c3a0699 | sorear++ | / (8 files):

[05:09] <dalek> niecza: Change the true names of attributes to include the sigil

[05:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c3a0699b32

[05:09] <TimToady> it doesn't occurs so much when using regex for a well-bahaved language, but I see it arising rather more often in user-defined langauges

[05:09] <TimToady> kshannon: well, STD did exactly that

[05:09] <sorear> kshannon: in TimToady's grammar engine, there's a list of pre-decided LTM choices tacked onto the cursor object

[05:10] <TimToady> so at least there's prior art, for some definition of "art"

[05:10] <kshannon> sorear:  Is your version in niecza currently using the TimToady engine from STD?

[05:11] <sorear> kshannon: No

[05:11] <kshannon> OK,  two things to look at then :)

[05:12] <sorear> It's STRONGLY based on the TimToady engine

[05:12] <sorear> but one of the changes I made was to get rid of fates

[05:12] <kshannon> I'll check out STD first then.

[05:12] *** raiph joined
[05:13] <TimToady> it seemed to me that fates solved both an efficiency problem and a correctness problem

[05:18] *** dk_ joined
[05:21] *** raiph left
[05:46] *** mkramer joined
[05:53] *** PZt joined
[06:10] *** kaleem joined
[06:10] *** sayu joined
[06:12] *** koban joined
[06:17] *** dk_ left
[06:35] *** tokuhirom3 joined
[06:51] *** molaf joined
[06:53] <sorear> nom: class Foo { has $!x }; say $(Foo.new)!Foo::x

[06:53] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Cannot call private method 'x' on package Foo because it does not trust GLOBAL at line 1, near ""␤»

[06:55] <sorear> o/ kst

[06:55] *** s1n joined
[06:56] <dalek> rakudo/staged-settings: c4303e3 | moritz++ | / (3 files):

[06:56] <dalek> rakudo/staged-settings: move some operators to second setting

[06:56] <dalek> rakudo/staged-settings: review: https://github.com/rakudo/rakudo/commit/c4303e341b

[06:56] *** sayu left
[06:58] *** zby_home_ left
[07:02] <dalek> niecza: 0d27950 | sorear++ | / (5 files):

[07:02] <dalek> niecza: Implement "trusts" and checking thereof

[07:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0d27950c81

[07:02] <sorear> only +4 tests though.

[07:04] *** birdwindupbird left
[07:05] *** wtw joined
[07:08] <dalek> features: 259cdf2 | moritz++ | features.json:

[07:08] <dalek> features: niecza trusts

[07:08] <dalek> features: review: https://github.com/perl6/features/commit/259cdf23dd

[07:13] *** nornagest joined
[07:13] <dalek> niecza: 0ab28e3 | sorear++ | / (2 files):

[07:13] <dalek> niecza: $!x is a direct ref, not a private method call

[07:13] <dalek> niecza: 

[07:13] <dalek> niecza: The private-method accessors are still created for use on other objects.

[07:13] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0ab28e31ca

[07:17] *** snearch joined
[07:18] <sorear> moritz: What do "Adding methods" and "Role composition" under MOP mean?

[07:20] <dalek> features: 0b734d7 | sorear++ | features.json:

[07:20] <dalek> features: Fill out blanks on niecza column, updates, acknowledge regressions

[07:20] <dalek> features: review: https://github.com/perl6/features/commit/0b734d7e1c

[07:21] <moritz> sorear: if you can do these things through the MOP

[07:29] *** nornagest left
[07:59] *** panterax_ joined
[08:03] * sorear -> sleep

[08:10] *** bacek joined
[08:18] *** mkramer left
[08:36] *** Guest73178 joined
[08:36] <Guest73178> :D

[08:36] *** mj41 joined
[08:39] *** Guest73178 left
[08:39] *** snearch left
[08:40] *** snearch joined
[08:41] *** snearch left
[08:44] *** snearch joined
[08:45] *** snearch left
[08:46] *** snearch joined
[08:46] *** cognominal left
[08:47] *** cognominal joined
[08:47] *** snearch left
[08:47] *** snearch joined
[08:49] <moritz> phenny: tell LlamaRider re pair in a block, you can use a semicolon to disambiguate a block with a pair from a hash literal: @a.map: {; $_ => 2 * $_ } # fewer parentheses for the win

[08:49] <phenny> moritz: I'll pass that on when LlamaRider is around.

[08:49] *** snearch left
[08:49] <moritz> though of course you can write that as  @a Z=> (2 X* @a)  too :-)

[08:50] *** snearch joined
[08:55] *** snearch left
[08:56] *** snearch joined
[08:58] *** snearch left
[08:58] *** snearch joined
[09:08] *** daxim joined
[09:09] *** thou left
[09:14] *** carlin left
[09:18] <tadzik> good morning :)

[09:20] *** xinming joined
[09:20] <moritz> \o tadzik 

[09:23] *** jupp joined
[09:25] *** xinming left
[09:27] *** dakkar joined
[09:36] <kshannon> this fates stuff in STD is a wonderful way to do the LTM...

[09:37] <kshannon> now if only I could make sesnse of it :)

[09:38] <moritz> :-)

[09:38] *** jupp left
[09:47] *** birdwindupbird joined
[09:55] <masak> mornin', #perl6

[09:55] *** cognominal left
[09:55] *** cognominal joined
[09:56] *** jupp joined
[09:57] <moritz> it's masak!

[09:58] <tadzik> hello masak 

[10:03] <masak> hello tadzik

[10:04] <masak> late. I woke up it today.

[10:04] <tadzik> took me a while to parse

[10:04] <tadzik> while. Too me it to parse

[10:05] <tadzik> * Took

[10:05] <tadzik> ah, I fail at this :)

[10:05] <moritz> did you mean "fail. I at it"? :-)

[10:06] <tadzik> mean. I did it

[10:07] <moritz> speaking of "fail"...

[10:07] <moritz> the staged-settings branch fails in some rather curious ways

[10:08] <moritz> for example I've moved Grammar to the second setting

[10:08] <moritz> and when you write grammar A { }, the code that adds Grammar as a superclas to A silently fails

[10:08] <moritz> *superclass even

[10:09] <moritz> which means that not only do you not get Grammar as a parent class...

[10:09] <moritz> but also not Any or Mu

[10:09] <moritz> which leads to curious test failures

[10:12] <masak> tadzik: http://en.wikipedia.org/wiki/Topic%E2%80%93comment

[10:14] <moritz> $_ # for short :-)

[10:15] <moritz> or more elaborately: given $topic { .comment }

[10:15] <moritz> erm, .comment given $topic; # :-)

[10:17] <masak> aye :)

[10:17] <moritz> nom: class Topic is Str { method new($_) { nqp::box_s(nqp::unbox_s(.Str), self) }; method comment { say "Talking about {self}" } }; .comment given Topic.new('Perl 6')

[10:17] <p6eval> nom 38165a: OUTPUT«Talking about Perl 6␤»

[10:18] <masak> nom: class Topic is Str { method new($_) { nqp::box_s(nqp::unbox_s(.Str), self) }; method comment { say "Talkin' 'bout {self}" } }; .comment given Topic.new("you and me, and the games people play")

[10:18] <p6eval> nom 38165a: OUTPUT«Talkin' 'bout you and me, and the games people play␤»

[10:20] <moritz> masak++ # cultural reference that I get, for once :-)

[10:20] *** xinming joined
[10:21] <moritz> anyway, the example of inheriting from base types IMHO demonstrates that boxing and unboxing should be somehow exposed to the user space

[10:21] <moritz> nom: say Str.new('foo')

[10:21] <p6eval> nom 38165a: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:558␤  in block <anon> at /tmp/TfnUcTW2ke:1␤  in <anon> at /tmp/TfnUcTW2ke:1␤»

[10:22] <masak> moritz: fun trivium: the song was inspired by the pop-psychology book "Games people play" by Eric Berne

[10:22] <moritz> we could of course provide such constructors, but it forces you to create more GCables

[10:22] <masak> we got a thank-you comment on the Perl 6 Advent calendar: http://perl6advent.wordpress.com/2011/12/25/day-25-merry-christmas/#comment-1288

[10:23] <moritz> masak: have you read that book?

[10:23] <masak> yes.

[10:23] <masak> moritz: boxing and unboxing *is* exposet to user space. it's just not very pretty :)

[10:23] <masak> exposed*

[10:24] <moritz> masak: erm, I meant in a portable fashion :-)

[10:24] <moritz> masak: can you recommend it?

[10:24] <masak> "portable"?

[10:24] <moritz> nqp:: ops aren't portable across implementations

[10:24] <masak> I can recommend the book. it has a curious but interesting definition of "game" in a social setting.

[10:26] <masak> don't know how to explain it simply, but it's a little something like "con" or "trick" -- except with feelings instead of money.

[10:26] <masak> and with the con man not being fully conscious of the exploit.

[10:27] <masak> the book is a tad old and a bit US-centric. but still interesting.

[10:29] * moritz puts it on his amazon wishlist

[10:29] *** xinming left
[10:30] * masak enjoys seeing diakopter in the backlog

[10:31] * moritz enjoys backlogging the abstruse goose comics :-)

[10:34] <moritz> perl6: https://gist.github.com/1586644

[10:35] <p6eval> rakudo 38165a: OUTPUT«(timeout)3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564…

[10:35] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "[$"␤    expecting formal parameter or ")"␤    at /tmp/mCv536W7YX line 16, column 10␤»

[10:35] <p6eval> ..niecza v13-207-g0ab28e3: OUTPUT«(timeout)3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712…

[10:35] <moritz> rakudo got *further* than niecza before timeouting?

[10:37] <masak> moritz: "Assume the cow is a solid ball. Banach-Tarski the hell out of it. Rinse. Repeat." :P

[10:41] *** cognominal_ joined
[10:41] *** cognominal left
[10:41] *** snearch left
[10:42] <moritz> :-)

[10:43] <moritz> the abstruse goose comics are often a bit more abstruse than XKCD, but they quite often resonate with some part of me

[10:44] <masak> aye.

[10:45] *** panterax__ joined
[10:46] <moritz> nom: say (42, 'foo', Any).grep: &defined

[10:46] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Symbol '&defined' not predeclared in <anonymous> (/tmp/EulyycuoWH:1)␤»

[10:46] <moritz> nom: say (42, 'foo', Any).grep: &prefix:sym<defined>

[10:46] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Symbol '&prefix:sym<defined>' not predeclared in <anonymous> (/tmp/tMywm_nlXy:1)␤»

[10:46] <moritz> nom: say (42, 'foo', Any).grep: &prefix:defined

[10:46] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Symbol '&prefix:defined' not predeclared in <anonymous> (/tmp/U8RztJ9VJR:1)␤»

[10:49] *** panterax_ left
[10:53] <masak> nom: say &defined

[10:53] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Symbol '&defined' not predeclared in <anonymous> (/tmp/gRcOxOlczE:1)␤»

[10:53] <masak> b: say &defined

[10:53] <p6eval> b 1b7dd1: OUTPUT«Could not find sub &defined␤  in main program body at line 22:/tmp/kq3M4ReDMZ␤»

[10:54] <masak> nom: say (42, 'foo', Any).grep: *.defined

[10:54] <p6eval> nom 38165a: OUTPUT«42 foo␤»

[10:54] *** skids left
[10:54] <masak> nom: say &foo; sub foo {}

[10:54] <p6eval> nom 38165a: OUTPUT«sub foo() { ... }␤»

[10:54] <masak> nom: say &foo

[10:54] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Symbol '&foo' not predeclared in <anonymous> (/tmp/7YmgXCNZA0:1)␤»

[10:54] <moritz> and not postdeclared either :-)

[10:55] <masak> I don't really like the error message, because the symbol '&foo' is not predeclared even in the former... right.

[10:55] * masak submits rakudobug for LTA error message

[10:56] <masak> the issue with the error message has something to do with that it doesn't correctly identify the error.

[10:56] <masak> '&foo' doesn't need to be predeclared; it just needs to be declared.

[10:58] <moritz> aye; rakudo just has a single code path for all the undeclared symbol errors

[10:58] <moritz> and everything else needs to be predeclared

[10:58] <moritz> we could just change it to "not declared"

[10:59] <moritz> and then the user needs to know in each case if post-declaration is sufficient

[10:59] *** arnsholt left
[11:08] *** xinming joined
[11:10] *** Tene left
[11:15] *** arnsholt joined
[11:16] <masak> heh -- based on the server logs to my blog, I should really write a post called "longest common substring" :)

[11:17] <moritz> :-)

[11:18] <moritz> when I wrote a German Perl 6 beginner's tutorial, I got lots of hits from google for search terms like "perl if", "perl while", "perl for"

[11:18] <moritz> and I kinda felt bad, because 99% of them were looking for the Perl 5 forms, not the Perl 6 ones

[11:20] <masak> yeah, that's kind of what I'm thinking here as well.

[11:21] <masak> maybe I'd do the world a service by writing a really approachable introduction to LCS with suffix trees.

[11:21] <masak> that'd probably by fun to write up as well.

[11:21] <masak> in my abundant spare time. :/

[11:24] *** wolv is now known as wolverian

[11:32] *** spine_ joined
[11:34] *** djanatyn joined
[11:34] *** Tene joined
[11:34] *** Tene left
[11:34] *** Tene joined
[11:37] *** m0ck joined
[11:38] *** m0ck left
[11:43] *** birdwindupbird left
[11:43] *** tokuhirom3 left
[11:43] *** mtk left
[11:43] *** baest left
[11:43] *** kcwu left
[11:47] *** birdwindupbird joined
[11:47] *** tokuhirom3 joined
[11:47] *** mtk joined
[11:47] *** baest joined
[11:47] *** kcwu joined
[11:47] *** japhb joined
[11:47] *** wooden joined
[11:52] *** xinming left
[12:02] <arnsholt> masak: Don't you have a time-travelling debugger? =)

[12:02] <arnsholt> You can manufacture spare time =D

[12:03] *** replore joined
[12:04] *** xinming joined
[12:06] *** rsimoes1 joined
[12:06] <masak> I wish... :)

[12:06] *** benabik left
[12:10] <masak> suffix trees are so wonderful that in order to do them justice, I'd probably have to write a blog post only about them.

[12:10] <masak> with an adjoining Perl 6 implementation, of course.

[12:10] <masak> that would probably make the LCS blog post easier to write, as well.

[12:10] <felher> masak: +1

[12:12] <masak> here's a problem I've always liked: given that we can do .comb.rotate($N).join with any $N on a given string, find the lexicographically smallest such rotated string.

[12:13] <masak> nom: given "pancakes" { say [min] (.comb.rotate($_).join for ^.chars) }

[12:13] <p6eval> nom 38165a: OUTPUT«0␤»

[12:13] <masak> hrm.

[12:13] <masak> nom: given "pancakes" { say (.comb.rotate($_).join for ^.chars) }

[12:13] <p6eval> nom 38165a: OUTPUT«0 1 2 3 4 5 6 7␤»

[12:14] <masak> not... what I expected.

[12:14] <masak> oh!

[12:14] <masak> nom: given "pancakes" -> $s { say ($s.comb.rotate($_).join for ^$s.chars) }

[12:14] <p6eval> nom 38165a: OUTPUT«pancakes ancakesp ncakespa cakespan akespanc kespanca espancak spancake␤»

[12:14] <masak> I often expect $_ to mean two loop current-elements at once :P

[12:14] <masak> nom: given "pancakes" -> $s { say [min] ($s.comb.rotate($_).join for ^$s.chars) }

[12:15] <p6eval> nom 38165a: OUTPUT«akespanc␤»

[12:15] <cognominal_> LCS?

[12:15] <masak> cognominal_: "Longest Common Substring"

[12:15] <masak> cognominal_: since a year back, that's been the most common set of search words to find my blog.

[12:16] <masak> now, the above algorithm is O(N**2) where N is the length of $s. with suffix trees, it can be solved in O(N) time.

[12:17] <masak> I've managed to explain to myself how, but it still tickles my intuition sometimes. :)

[12:19] <masak> even with LCS, I have some kind of intuition that the problem "should" be O(N**2). I guess that's why suffix trees are relatively unknown outside some fairly specific circles.

[12:19] <colomon> moritz: in my informal tests here, rakudo was quite competitive speed-wise with niecza out until about digit 1900, when it seemed like some sort of awkward garbage collection (guess) slowed rakudo down a bit.

[12:22] *** _jaldhar left
[12:25] *** jaldhar joined
[12:26] *** replore left
[12:26] *** replore joined
[12:26] *** bluescreen10 joined
[12:26] <kshannon> from S05: "The first || in a regex makes the token patterns on its left available to the outer longest-token matcher"

[12:27] <kshannon> In "A [ B1 || B2 ] C" does the outer LTM grab all the way to C?  (i.e. A B1 C)

[12:27] <kshannon> That seems wrong somehow...

[12:27] <kshannon> and not at all intuitive

[12:27] *** mtk left
[12:28] <masak> well, C still has to match if B1 matches.

[12:28] *** mtk joined
[12:28] <masak> but then C would have to match "procedurally" if B2 matches, since we're then in procedural mode.

[12:28] <kshannon> exactly.

[12:29] <masak> I can't condemn it as wrong, but I agree it feels slightly odd.

[12:30] *** jupp left
[12:31] <kshannon> I'm just trying to get it all straight in my head to work out what needs to be done to do it correctly. https://gist.github.com/1594445 is my current braindump.

[12:32] <kshannon> I was re-reading S05 and discovered I was wrong about how || and && interact with LTM.

[12:32] *** rsimoes1 left
[12:33] <kshannon> (The reason for introducing the term P.P. - Partially Proedural was because of my thoughts on NFA construction anc caching)

[12:34] * moritz brains the read-dump

[12:34] <moritz> erm, the other way round

[12:34] *** rsimoes1 joined
[12:34] <kshannon> Also, it seems that eager (non-greedy) quantifiers don't participate at all in LTM;  I had assumed that they would allow up to the minimum repetitions.

[12:35] <moritz> ah, LTMP is what I've called "declarative prefix" in http://perlgeek.de/en/article/longest-token-matching

[12:35] <cognominal_> I am not sure what "braining the read-dump" would mean, but I am sure it would be cool.

[12:35] <kshannon> :)

[12:36] <moritz> hm

[12:37] <moritz> if you   token foo { a+ }, can you consider <foo> declarative?

[12:37] <moritz> because it actually translates to a+:

[12:37] *** hanekomu joined
[12:38] *** bluescreen10 left
[12:40] <kshannon> OK,  I haven't seen that specced anywhere.

[12:40] <kshannon> That does change things.

[12:41] <masak> moritz, cognominal_: the best spam I ever got was a dissociated-press word salad of various computer books. somewhere in there it had the phrase "at any given moment, brain in a way that sticks". this message has always stayed with me somehow.

[12:41] *** kaleem left
[12:41] <moritz> kshannon: well, it is specced that 'token' implies :ratchet

[12:41] <masak> moritz: why would :ratchet conflict with declarative?

[12:42] <kshannon> Except,  as far as I can tell ratcheted doesn't stop LTM.

[12:42] <kshannon> typing too slow... :(

[12:42] <masak> moritz: it's not backtracking (or the lack of it) that conflicts with declarative, it's other types of decisions.

[12:42] <moritz> masak: because there are no possessive quantifiers are not present in regular languages

[12:42] <masak> please rephrase :)

[12:42] <moritz> erm, yes

[12:43] <moritz> because there are no possessive quantifiers in regular languages

[12:43] <cognominal_> masak, smartly constrained randomness is a well know surrealist device :  http://en.wikipedia.org/wiki/Surrealist_techniques

[12:43] <masak> cognominal_: oh yes. I really enjoyed "The Policeman's Beard Is Half-Constructed".

[12:44] <cognominal_> "le cadavre exquis boira le vin nouveau"

[12:44] <masak> moritz: you may have a point.

[12:44] <masak> cognominal_: :)

[12:44] *** benabik joined
[12:44] <masak> cognominal_: talk about a waste of wine :P

[12:48] <kshannon> The synopsis doesn't actually say we're talking about a regular language.  It uses the terms pure and declarative.

[12:48] <kshannon> Of course,  if it's not regular you need more than a DFA or NFA to parse it.

[12:49] <masak> right.

[12:49] <moritz> I thought the plan had always been to spec LTM in a way that a DFA can handle the LTM part

[12:51] <kshannon> I don't think you need much more to do ratchet semantics - possibly even a quick and simple postprocess of the DFA results. 

[12:51] <kshannon> I'll need to do more thinking about that one.

[12:53] * moritz too

[12:53] *** donri joined
[12:53] *** bluescreen10 joined
[12:54] <kshannon> moritz: "declarative prefix" <-- I like that term,  I'll use it from now on

[13:01] *** jupp joined
[13:15] <masak> \o/

[13:19] <masak> it's a best-of-both worlds thing. NFAs are awesome, but limited in scope. we've become accustomed to and dependent on the parts of "regexes" that aren't really (NFA) "regular expressions", but those slow things down.

[13:19] <masak> so Perl 6 grammars, through declarative prefixes, stay in NFA land as long as they can and (transparently) switch over to procedural land when they have to.

[13:19] *** moritz joined
[13:26] *** jaldhar left
[13:28] <rsimoes1> Is there somewhere in the docs that explain how junctions are different from sets?

[13:29] <moritz> rsimoes1: junctions are basically sets plus a rule to evaluate that set for truthness

[13:30] <moritz> for example any(True, False) evaluates to True, all(True, False) evaluates to False

[13:30] <rsimoes1> truthness = set membership/absense/etc?

[13:30] *** panterax__ left
[13:30] <moritz> rsimoes1: no; evaulating the whole set in boolean context

[13:31] <rsimoes1> oh, okay

[13:31] <moritz> the purpose of junctions is always to give you a boolean answer in the end

[13:31] <masak> well, and to distribute dispatch.

[13:31] <moritz> you ask   if $value == any('yes', 'no', 'y', n') { ... }

[13:32] <moritz> masak: that's a means to get that boolean answer, not the purpose

[13:32] <rsimoes1> hm

[13:32] <masak> moritz: yes, just realized that :)

[13:32] <masak> moritz: that's the means to the end.

[13:32] <moritz> rsimoes1: if you want to test set membership, you should really be using a proper set, not a junction

[13:33] <rsimoes1> maybe that's just a simple case, but it seems like I'm just doing "$value ∈ any('yes', 'no', 'y', n')"

[13:33] <masak> rsimoes1: people often want junctions to be sets, and expect to get subsets from junctions by manipulating them somehow. this is counter to the intent of junctions.

[13:33] <masak> rsimoes1: it's not always about set membership.

[13:33] <rsimoes1> okay

[13:33] <masak> rsimoes1: think about all(@a) > all(@b), for example.

[13:34] <moritz> if you ask   $answer ~~ none(/expletive1/, /expletive2/), that's not all a set membership test

[13:35] *** jupp1 joined
[13:35] <masak> sub prime($n) { none(2..sqrt $n) %% $n }

[13:35] *** jupp left
[13:36] <kshannon> The current S05 is littered with the idea of ratcheted atoms participating in LTM.

[13:36] <masak> I guess that one can be formulated as set membership :)

[13:36] <masak> but I don't think of it that way.

[13:36] <moritz> $n %% none(2..sqrt(%n)  please

[13:36] <masak> oh right. :/

[13:36] <masak> I always get that one in the wrong order...

[13:36] <masak> I even stopped and thought about it this time. :/

[13:37] *** panterax joined
[13:37] <masak> nom: sub prime($n) { $n %% none 2..sqrt $n }; .say for grep &prime, 2..100

[13:37] <p6eval> nom 38165a: OUTPUT«2␤3␤5␤7␤11␤13␤17␤19␤23␤29␤31␤37␤41␤43␤47␤53␤59␤61␤67␤71␤73␤79␤83␤89␤97␤»

[13:38] <masak> \o/

[13:38] <masak> should probably'a named it "is-prime" :)

[13:38] <rsimoes1> you can express "all(@a) > all(@b)" with set notation and quantifiers

[13:39] <rsimoes1> I see it might get more complicated, though

[13:39] <masak> sure.

[13:39] <moritz> rsimoes1: sure you can, but the fact remains that the primitives by which junctions work are not the same as the set primitives

[13:40] <masak> rsimoes1: I use junctions sometimes in my Perl 6 code, but much *less* than I thought I would five years ago.

[13:40] <moritz> all(@a) > all(@b) in terms of set memebership tests and quantors is simply  FORALL a IN @a FORALL b IN @B: a > b

[13:40] <masak> rsimoes1: I use them in "static" situations, such as if statements or loop conditions.

[13:41] <masak> rsimoes1: I don't pass them around a lot at all.

[13:41] * moritz thinks "how are junctions and sets related" would make a worthwhile FAQ entry

[13:41] <masak> indeed.

[13:42] <masak> rsimoes1: also note that junctions DWIM with negated infix operators, in a way that set objects don't do at all.

[13:42] <masak> rsimoes1: the spec has some wording on that. I don't dare explain it, because I don't have a good mental model of it :)

[13:44] <moritz> basically the spec says that  $a !foo $b should behave as  !($a foo $b) under autothreading

[13:44] <rsimoes1> oh awesome

[13:44] <masak> oh, right.

[13:45] <masak> rsimoes1: here's the kind of expectation people have on junctions: https://rt.perl.org/rt3/Ticket/Display.html?id=61676

[13:45] <rsimoes1> I popped a blood vessel trying to figure out what was going on with $foo !~~ @bar in perl 5

[13:46] <rsimoes1> I can see how junctions only allow for "sets" that are trivially decidable, too

[13:46] <masak> rsimoes1: we used to think smartmatching against arrays meant any() semantics on the array. we don't anymore. but you probably know this.

[13:46] <moritz> rsimoes1: (p5) well, junctions are rather broken in p5

[13:47] <masak> smartmatching is rather broken in p5 :)

[13:47] <moritz> erm, yes, that's what I meant

[13:47] <moritz> sorry

[13:47] <rsimoes1> it's gotten better each major release since 5.10

[13:47] <masak> glad to hear it.

[13:47] <moritz> but it's still fundamentally flawed

[13:47] <rsimoes1> yeah, I agree

[13:48] <moritz> smart matching needs user-exposed types to DWIM in any predictable way

[13:48] <moritz> and p5 doesn't expose core types to the user

[13:48] <rsimoes1> I used $ ~~ @ smart matching in a cpan module that required v5.10

[13:48] <rsimoes1> but I release-tested it with v5.14

[13:48] <rsimoes1> and then got all sorts of interesting smoke failure reports

[13:49] <moritz> ah, I read the "I love CPAN testers" blog post :-)

[13:49] <rsimoes1> bah, Conway's talk of quantum superpositions seems a bit over-the-top

[13:50] <moritz> there's really nothing quantum in superpositions

[13:50] <masak> I've been studying quantum computing a little bit, and I'll say this. junctions are *not* like quantum superpositions.

[13:50] <masak> neither is TheDamian's CPAN module.

[13:51] <moritz> quantum is... much weirder

[13:51] <rsimoes1> probably just wanted to add some flair a la popular science magazines

[13:51] <rsimoes1> gets wider circulation that way :D

[13:51] <moritz> aye...

[13:51] <dalek> niecza: 614790f | coke++ | t/spectest.data:

[13:51] <dalek> niecza: Run more tests.

[13:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/614790faaf

[13:51] <masak> probably.

[13:53] <masak> "OMG it's on and off at the same time!"

[13:54] <moritz> I thought more of "LOL I MAKED YOU A QUANTUM!" :-)

[13:54] <rsimoes1> "DUDE, this cat's, like, nine kinds of alive and dead!"

[13:54] <moritz> but I still find it quite amusing and ingenious

[13:55] <masak> nom: class Button { has Bool $.on }; my $b = one Button.new(:on), Button.new(:!on); if $b { say "it's on" }; if !$b { say "it's off" }

[13:55] <p6eval> nom 38165a: OUTPUT«it's off␤»

[13:55] <masak> dang :)

[13:55] *** mkramer joined
[13:55] <masak> ...but expected.

[13:55] <masak> nom: class Button { has Bool $.on }; my $b = any Button.new(:on), Button.new(:!on); if $b { say "it's on" }; if !$b { say "it's off" }

[13:55] <p6eval> nom 38165a: OUTPUT«it's on␤»

[13:56] <masak> I can't think of a case where a junction can be its own boolean negation.

[13:56] <masak> because it always boolifies to *something*, either True or False.

[13:56] <moritz> well, you can ask it to boolify in different ways

[13:56] <[Coke]> perl6: eval "%ENV"

[13:56] <p6eval> rakudo 38165a: OUTPUT«===SORRY!===␤Variable %ENV is not predeclared at line 1, near ""␤»

[13:56] <p6eval> ..pugs b927740:  ( no output )

[13:56] <p6eval> ..niecza v13-207-g0ab28e3: OUTPUT«Unhandled exception: Variable %ENV is not predeclared␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 5675 (STD.sorry @ 4) ␤  at /home/p6eval/niecza/src/STD.pm6 line 5435 (ANON @ 34) ␤  at /home…

[13:57] <masak> [Coke]: %*ENV

[13:57] <moritz> if $j { ... }; if !$j { ... }

[13:57] <[Coke]> masak: S02-magicals/env.t

[13:57] <masak> moritz: that's what I did above.

[13:57] <moritz> or even  if $j == True { ... } # urks

[13:57] <masak> yuck.

[13:58] <[Coke]> explicitly tests that line; and expects it to eval OK, but to set $!. Trying to figure out if it should die instead.

[13:58] *** LlamaRider joined
[13:58] <moritz> [Coke]: that's old eval semantics

[13:58] *** mtk left
[13:58] <moritz> [Coke]: might as well use   eval_dies_ok '%ENV';

[13:58] <masak> also, what's the point of testing for the absence of a variable?

[13:59] *** mtk joined
[13:59] <[Coke]> moritz: done.

[13:59] <tadzik> so eval does not catch exceptions these days, eh?

[13:59] <moritz> tadzik: correct

[13:59] <moritz> masak: well, there's an %ENV in GLOBAL or PROCESS or whatever it's called

[14:00] <moritz> masak: so if some compiler writer accidentally installs that as a setting, that test catches it

[14:01] <masak> fair enough.

[14:02] <moritz> roast is full of weird tests; but many are weird for a reason

[14:02] <moritz> you wouldn't believe how much the early compilers got wrong...

[14:02] <moritz> masak: oh wait, you wrote November, you would know :-)

[14:03] <TimToady> LlamaRider: according to spec, the fact that rakudo turns { $_ => 2*$_ } into a hash, is a bug; see S04:1590, end of paragraph

[14:03] <TimToady> well, the fact isn't a bug...

[14:04] <moritz> is that distinction meant to be syntactic?

[14:04] <TimToady> perl6: say { $_ => 2*$_ }.WHAT

[14:04] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 961 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 215 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/bgA66mxh8d line 0 (mainli…

[14:04] <p6eval> ..pugs b927740: OUTPUT«pugs: Missing required parameters: $_␤»

[14:04] <p6eval> ..rakudo 38165a: OUTPUT«use of uninitialized variable $_ of type Any in numeric context␤use of uninitialized variable $!key of type Any in string context␤Hash()␤»

[14:06] <dalek> roast: cbcc367 | coke++ | S02-magicals/env.t:

[14:06] <dalek> roast: fudge for niecza, update oldstyle eval test

[14:06] <dalek> roast: review: https://github.com/perl6/roast/commit/cbcc367245

[14:06] <TimToady> all closures should know if they have parameters semantically, though we treat the $_ parameter specially so it can be omitted

[14:06] <TimToady> perl6: my $c = { $_ => 2*$_ }; say $c.WHAT

[14:06] <p6eval> pugs b927740: OUTPUT«pugs: Missing required parameters: $_␤»

[14:06] <p6eval> ..niecza v13-207-g0ab28e3: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 961 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 215 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/1cBQk64y3m line 0 (mainli…

[14:06] <p6eval> ..rakudo 38165a: OUTPUT«use of uninitialized variable $_ of type Any in numeric context␤use of uninitialized variable $!key of type Any in string context␤Hash()␤»

[14:07] <dalek> niecza: 9b38fb8 | coke++ | t/spectest.data:

[14:07] <dalek> niecza: run S02-magicals/env.t

[14:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9b38fb8941

[14:07] <LlamaRider> I guess that part of the spec is yet to receive more attention.

[14:07] <phenny> LlamaRider: 08:49Z <moritz> tell LlamaRider re pair in a block, you can use a semicolon to disambiguate a block with a pair from a hash literal: @a.map: {; $_ => 2 * $_ } # fewer parentheses for the win

[14:08] <moritz> iirc pmichaud++ pointed out several problems with that piece of spec

[14:08] *** mkramer left
[14:08] *** alvis left
[14:08] <masak> oh? I'm interested to hear what those problems are.

[14:09] <LlamaRider> nice, moritz++ great syntax there, although the semicolon looks a little bit werd :) but I can get used to that

[14:09] <masak> I've had the feeling that if Rakudo only conforms to the the spec there, all will be well.

[14:09] *** mkramer joined
[14:09] <masak> LlamaRider: I also don't like the semicolon there. :(

[14:09] <masak> LlamaRider: but it's temporary, until Rakudo gets its act together.

[14:09] <moritz> masak: they are in logs somewhere... but not easy to search for, I fear

[14:10] <LlamaRider> rakudo: my @a=(1,2); say @a.map: { $_ => 2 * $_ ;;}

[14:10] <p6eval> rakudo 38165a: OUTPUT«1 2 2     4␤»

[14:10] <LlamaRider> there, it's prettier :)

[14:10] <masak> weird output.

[14:10] <dalek> roast: d5f4f03 | coke++ | S02-magicals/env.t:

[14:10] <dalek> roast: unfudge for rakudo

[14:10] <dalek> roast: review: https://github.com/perl6/roast/commit/d5f4f0368d

[14:10] <masak> rakudo: my @a=(1,2); say @a.map({ $_ => 2 * $_ ;;}).perl

[14:11] <p6eval> rakudo 38165a: OUTPUT«(1 => 2, 2 => 4).list␤»

[14:11] <moritz> nom: my @a = 1, 2; say (@a Z=> (@a X* 2)).perl

[14:11] <p6eval> nom 38165a: OUTPUT«(1 => 2, 2 => 4).list␤»

[14:11] <LlamaRider> oO what sorcery is thiz? Z? lots to learn xD

[14:12] <TimToady> it's just a zip

[14:12] <TimToady> or a zipwith, in this case

[14:12] <masak> nom: my @a = 1..5; my @b = 'a' .. 'e'; .say for @a Z @b

[14:12] <p6eval> nom 38165a: OUTPUT«1␤a␤2␤b␤3␤c␤4␤d␤5␤e␤»

[14:13] <masak> LlamaRider: there you go, that's what happens.

[14:13] <moritz> take one element from each list, connect them with =>. Rinse and repeat

[14:13] <masak> LlamaRider: Z takes an element from each list, and connects them with a comma.

[14:13] <LlamaRider> interesting combinator

[14:13] <TimToady> zip as in combine values like a zipper

[14:13] <masak> LlamaRider: Z=> does the same with =>

[14:13] *** mkramer left
[14:13] <masak> nom: my @a = 1..5; my @b = 100, 200 ... 500; .say for @a Z+ @b

[14:13] <moritz> hey, we should start zcombinator.com and xcombinator.com and have them both point to perl6.org :-)

[14:13] <p6eval> nom 38165a: OUTPUT«101␤202␤303␤404␤505␤»

[14:14] <masak> moritz: :P

[14:14] *** mkramer joined
[14:15] <LlamaRider> 1. I am amazed declaring @b like this works... what are the limits of inferring sequences?

[14:15] <LlamaRider> 2. I understand Z now, thanks masak++ moritz++ TimToady++

[14:15] *** mkramer left
[14:16] *** mkramer joined
[14:16] <moritz> LlamaRider: just arithmetic and geometric sequences are recognized

[14:16] *** skids joined
[14:16] <moritz> LlamaRider: if you need something more fancy, you can provide a custom generator

[14:16] <masak> has anyone done that yet?

[14:16] <moritz> nom: say (1, 2, 4 ... 128)

[14:16] <p6eval> nom 38165a: OUTPUT«1 2 4 8 16 32 64 128␤»

[14:16] <moritz> masak: done what? custom generators?

[14:16] <masak> yes.

[14:17] <moritz> sure

[14:17] <masak> I completely missed that.

[14:17] <masak> is there a blog post somewhere?

[14:17] <moritz> nom: say (1, 5, { $^a + 2 * $^b } ... * > 100 )

[14:17] <p6eval> nom 38165a: OUTPUT«1 5 11 27 65 157␤»

[14:17] <LlamaRider> wow.

[14:18] <moritz> nom: say (1, 1, { $^a + $^b } ...^ * > 100)

[14:18] <p6eval> nom 38165a: OUTPUT«1 1 2 3 5 8 13 21 34 55 89␤»

[14:18] <dalek> roast: 04db5dc | coke++ | S05-match/perl.t:

[14:18] <dalek> roast: fudge for niecza

[14:18] <dalek> roast: review: https://github.com/perl6/roast/commit/04db5dc4f2

[14:18] <benabik> nom: say (1,1, * + * …^ * > 100) # extra starry

[14:18] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2␤»

[14:18] <dalek> niecza: 5e077dc | coke++ | t/spectest.data:

[14:18] <dalek> niecza: run (heavily fudged) S05-match/perl.t

[14:18] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5e077dc66c

[14:18] *** kaleem joined
[14:18] <TimToady> LlamaRider: sequence operators are described at S03:1787

[14:19] <benabik> nom: say (1,1, * + * ...^ * > 100) # extra starry

[14:19] <p6eval> nom 38165a: OUTPUT«1 1 2 3 5 8 13 21 34 55 89␤»

[14:19] <masak> moritz: sorry, I misunderstood you.

[14:19] <moritz> nom: say (1, 1, &[+] ... * > 100) # extra un-starry :-)

[14:19] <p6eval> nom 38165a: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144␤»

[14:19] * LlamaRider is now thinking if one can solve t3 of p6cc in such a one-liner

[14:19] <masak> moritz: I was thinking about adding a multi somehow to modify the intrinsic behaviour of infix:<...> so that it recognized more than artith and geom sequences.

[14:20] <moritz> masak: ah

[14:20] <moritz> masak: no, that hasn't been done to the best of my knowledge

[14:20] <benabik> moritz++

[14:21] <moritz> maybe we should spec a dispatch to a SEQUENCE_INFER subroutine that gets a sequence and returns a closure that continues the sequence

[14:21] <moritz> and ... could use that under the hood

[14:21] <masak> nom: my &plus := &[+}; say (1, 1, &plus ... * > 100)

[14:21] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Unable to parse variable, couldn't find final ']' at line 2␤»

[14:21] <masak> nom: my &plus := &[+]; say (1, 1, &plus ... * > 100)

[14:21] <p6eval> nom 38165a: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144␤»

[14:21] <masak> \o/

[14:21] <moritz> then you could add that without having to bother with the actual sequence generation (which can be a PITA)

[14:22] <benabik> Add a multi that queries oeis.org for the sequence.

[14:22] <TimToady> that way lies madness, probably better just to have an OEIS module

[14:22] <masak> moritz: hm, I was thinking making SEQUENCE_INFER a set of multis (with arith and geom being provided through the setting)

[14:22] <masak> moritz: but maybe it's better to handle it with wrapping and nextsame?

[14:23] <moritz> masak: not sure; MMD isn't really suitable for sequence recognition

[14:23] *** alvis joined
[14:24] <TimToady> sequence recognition is terribly ambiguous, and should not go much past what it already does

[14:24] <moritz> TimToady: I know, but it's tempting

[14:25] <TimToady> yes, and many of us have been tempted in the past, and pulled back

[14:25] <moritz> I always have the feeling that there's a nice, simple and powerful sequence recognizer around the corner

[14:25] <masak> :)

[14:26] <moritz> something that calculates differences and quotients of two numbers, and auto-correlates that with the original sequence (possibly shifted)

[14:26] <moritz> and then recurses

[14:26] * masak yanks moritz back hard

[14:26] <masak> :P

[14:26] <TimToady> search oeis for a sequence you think it should recognize, and then see how many hits you get :)

[14:26] <moritz> that should catch arithmetic, geometric, fib, and many combinations thereof

[14:27] <moritz> TimToady: been there, done that

[14:27] <moritz> it's still itching, but I'm not tempted to bring it into p6 core

[14:27] <TimToady> the only one I've seriously considered adding is 2,3,5...*

[14:28] <TimToady> but @primes is shorter and more informative

[14:28] <moritz> because it's nontrivial to implement in a fast way?

[14:28] *** jupp1 left
[14:28] <masak> +1 for @primes in the setting.

[14:28] <masak> but I'm also curious which implementation it'd use under the hood.

[14:29] *** tokuhirom joined
[14:30] <moritz> @first_1000_primes_hardcoded, grep &rabin_miller, $lower, *+2 ... *

[14:30] <masak> or maybe we leave @primes out of the setting because (1) there is no trivial, fast implementation of it, (2) implementing something like that is like implementing postfix:<!>, something people enjoy.

[14:30] *** replore left
[14:30] <moritz> masak: convincing

[14:31] <masak> moritz: a... probabilistic algorithm in the setting? :)

[14:31] <masak> "works most of the time!"

[14:31] <arnsholt> I'd be in favour of a probabilistic algorithm in the setting

[14:31] *** x3nU left
[14:31] <arnsholt> If nothing else, just to argue that Monte Carlo methods actually are useful

[14:32] <masak> aye. I'm just being a bigot. :)

[14:32] <arnsholt> The number of iterations to do can be controlled with a dynvar or optional argument, for those that want that

[14:32] <arnsholt> I know =)

[14:32] <moritz> "works most of the time" is a pretty good description of most perl 6 compilers out there :-)

[14:33] *** sayu joined
[14:33] * skids wondering why crippling Buf seems so popular

[14:33] <moritz> crippling? in what way?

[14:33] <skids> Well, for example, casting Buf to Str should be possible.

[14:33] <skids> IMO.

[14:34] <masak> it *is* possible. it's called .decode

[14:34] <TimToady> niecza: constant @primes = 2, 3, -> $n is copy { repeat { $n += 2 } until $n %% none @primes ... * > sqrt $n; $n; } ... *; say @primes[^20]

[14:34] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Kernel.IterFlatten (Niecza.VarDeque inq) [0x00000] in <filename unknown>:0 ␤  at Run.CORE.C504Iterator.flat (Niecza.Frame ) [0x00000] in <…

[14:34] <dalek> roast: 94faae3 | coke++ | S16-io/say.t:

[14:34] <dalek> roast: awkwardly fudge for niecza

[14:34] <dalek> roast: review: https://github.com/perl6/roast/commit/94faae32cd

[14:34] <moritz> what masak++ said

[14:34] <dalek> niecza: 09d9cda | coke++ | t/spectest.data:

[14:34] <dalek> niecza: run fudged S16-io/say.t

[14:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/09d9cdae72

[14:34] <skids> No, I mean just coercing.  If you have to do everything with Buf through special interfaces, it makes it incompatible with many other constructs.

[14:35] <arnsholt> skids: Enforcing a distinction between "sequence of bytes" and "sequence of characters" is a very concious choice

[14:35] <arnsholt> And a good one, IMO

[14:35] <moritz> skids: that was one of the lessons from p5

[14:35] <masak> skids: everything you've said so far indicates you're not appreciating the distinction arnsholt just mentioned.

[14:35] <skids> Well, to be proper, Buf isn't a sequence of bytes exactly.

[14:35] <masak> to a first approximation, it is.

[14:35] *** birdwindupbird left
[14:35] <moritz> mixing bytes and characters is a sure way to make you cry

[14:36] <masak> skids: perhaps http://strangelyconsistent.org/blog/str-and-buf-i-think-i-get-it-now will help.

[14:36] <moritz> Buf8 is a sequence of bytes; I think it should be the default in a lot of places that now spec Buf

[14:36] <moritz> for example IO.read sould really return Buf8, not Buf

[14:36] <moritz> and rakudo's Buf is actually a Buf8

[14:37] <arnsholt> Joel Spolsky's bare minimum Unicode post was on HN earlier today, always good reading as well

[14:38] <moritz> in p5 there are always modules that don't document if they return and/or expect bytes or characters

[14:38] <masak> I'm not sure why we bother with distinctions like Buf8. I'd be happy with Buf being a byte buffer, and everything else being provided through libraries.

[14:38] <moritz> masak: me too

[14:38] <masak> we have a tendency to overgeneralize sometimes. this seems to be one of those cases.

[14:39] * moritz makes masak++ his spec slimming king

[14:39] <skids> I have no problem with enforcing distinctions, but that doesn't mean walling the construct off from interacting with other things.

[14:39] <tadzik> I just implemented isa as a method in C++. I need vacation

[14:39] <arnsholt> masak: Or Buf8 and Buf-int

[14:40] <moritz> skids: is requiring a .decode really "walling off"?

[14:40] <dalek> roast: 9f4b11f | coke++ | S32-list/create.t:

[14:40] <dalek> roast: fudge for niecza

[14:40] <dalek> roast: review: https://github.com/perl6/roast/commit/9f4b11fb2d

[14:40] <arnsholt> But maybe Buf-int is just as well handled as a special case handling for Array[int]

[14:40] <TimToady> Bufs are required to be compact arrays

[14:40] <dalek> niecza: 270a262 | coke++ | t/spectest.data:

[14:40] <dalek> niecza: run (fudged) S32-list/create.t

[14:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/270a262253

[14:41] <colomon> [Coke]++

[14:41] <moritz> skids: p5 shows that making Buf and Str interchangable is a really bad idea. Where would you draw the line that neither mixes up the two, nor walls off?

[14:41] <arnsholt> Right. So Buf-int might be a good idea then

[14:42] <skids> Well, my current point of frustration is really that ~~ doesn't like to work with Buf directly.

[14:43] <moritz> skids: ~~, or regexes?

[14:43] <dalek> roast: a1b034a | coke++ | integration/advent2009-day22.t:

[14:43] <dalek> roast: fudge for niecza

[14:43] <dalek> roast: review: https://github.com/perl6/roast/commit/a1b034aa55

[14:43] <skids> regexes

[14:43] *** kmwallio joined
[14:43] <TimToady> and what should it do if it sees a high bit?

[14:43] <dalek> niecza: 22efcfd | coke++ | t/spectest.data:

[14:43] <moritz> skids: well, what would Buf.new(1 ... 256) ~~ m:g/\w/  do?

[14:43] <dalek> niecza: run fudged integration/advent2009-day22.t

[14:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/22efcfd65d

[14:44] <moritz> TimToady: and what should it do if it sees a low bit? :-)

[14:44] <[Coke]> colomon: just some LHF. maybe 30 passes for all that. ;)

[14:44] <[Coke]> though the L is getting higher and higher. :P

[14:44] <colomon> [Coke]: nothing at all wrong with LHF

[14:45] <skids> moritz: complain that m:bytes wasn't specified, for one, assuming buf8.

[14:46] <[Coke]> hey, rakudo: I gave you one more passing test. ;)

[14:46] <moritz> skids: and if m:bytes was specified (assuming that such a modifier makes sense), what semantics would \w have?

[14:46] *** Trashlord left
[14:47] *** snearch joined
[14:47] <moritz> what would Buf.new(1..255) ~~ m:bytes/a/  do?

[14:47] <skids> Those constructs that make sense should be sensibly mapped, I would think.  Those that don't should fail based on incompatibility.  But all of the regex engine shouldn't be off limits.

[14:47] *** snearch left
[14:47] *** nornagest joined
[14:48] *** snearch joined
[14:48] <moritz> skids: my point is that "those that make sense" is much smaller than you might think

[14:48] <masak> skids: we're trying to conservatively make the distinction really sharp, and then evolve towards mulddling it up where it doesn't hurt us. thus, all proposals for muddlings are welcome, but heavily scrutinized.

[14:48] <TimToady> we look at 'em hard too

[14:48] *** nornagest left
[14:48] <moritz> skids: with :bytes, . and quantifiers make sense. But what else?

[14:48] <moritz> m:bytes/a/ doesn't make sense, because a is a character, not a byte

[14:49] <TimToady> the buf might be ascii, or it might not

[14:49] <moritz> well, if it's ascii, decode it as ASCII

[14:49] <skids> m:bytes/ \x[42 43 13]/ for one.

[14:49] <moritz> if you want latin-1 semantics, decode it as latin-1

[14:49] <moritz> skids: iirc \x is also specced to mean characters, not bytes

[14:50] *** mkramer left
[14:50] <skids> Really, I don't want any character semantics at all, the data I'm working with is binary.

[14:50] <arnsholt> But regexes don't really work with bytes

[14:50] <moritz> skids: I'm not really experienced with binary data, but I'd think that unpack would be much more useful than regexes for binary data, no?

[14:51] <skids> Noarnsholt: they indeed do, and very well.

[14:51] <masak> I'm with arnsholt here. everything I've seen about regexes is in terms of chars, not byts.

[14:51] <masak> bytes*

[14:51] <masak> skids: do you simply avoid things like \w and \s and \d ?

[14:51] <skids> moritz: personally I'm of the opinion that unpack should die in favor of regex constructs.

[14:51] <masak> skids: not to mention character classes and Unicode properties.

[14:52] <skids> more like do not use them, rather than avoid them.

[14:52] <moritz> masak: and characters themselves

[14:52] <masak> skids: what's left? I'm not even sure C<.> is defined!

[14:52] <moritz> well, under the hypthetical :bytes, . would be defined to match one byte

[14:52] <arnsholt> No, unpack definitely serves a purpose. Things like integer decoding of different kinds of byte-order and such are definitely not trivially implementable with regexes

[14:52] <skids> masak: code blocks (when they work) and .ast (when that works)

[14:52] <masak> skids: what do you mean when you say to arnsholt that regexes work well with binary data? :)

[14:53] <arnsholt> I'm not convinced regexes are a good match for fixed-with data at all, really

[14:53] <skids> masak: subpattern matching, taking that result and feeding it back into a new expression, all more flexible than unpack.

[14:53] <skids> arnsholt: binary != fixed-width

[14:53] <skids> For example, TLVs

[14:54] <arnsholt> That's true. But most of the use-case of unpack is for fixed-width

[14:54] <TimToady> I actually kinda with skids here, if you consider regex as finite automata

[14:54] <TimToady> there are many uses for those down in the bytes world

[14:55] <arnsholt> Yeah, it's true that some kind of generalization into bytes would be nice

[14:55] <moritz> aye, but I don't think that p6 regexes are well suited to be just magically applied to Bufs

[14:56] <TimToady> skids isn't talking about magic, but about sufficiently advance technology :)

[14:56] <arnsholt> Yeah, I don't see a good way to use straight regexes on bytes

[14:56] <skids> (and grammars are much prettier and more flexiblle than sequences of unpack statements)

[14:56] <TimToady> hardware folks do it all the time

[14:57] <moritz> one way you can always take is decode the Buf as Latin-1, and then take care yourself not to apply character semantics where you don't mean to

[14:58] <masak> I also want to use my grammars for parsing binary data if that's possible. I simply don't see how to do it yet. how do I specify what bytes I want to match if all regexes specify is characters?

[14:58] <TimToady> you change the definition of "character", obviously :)

[14:58] <benabik> "Any technology distinguishable from magic is insufficiently advanced."

[14:58] <moritz> TimToady: and I think that's the very approach that got p5 deep into trouble

[15:00] *** nornagest joined
[15:00] <Util> masak , moritz : t4-description =~ s/(If there is) (possible solution)/$1 no $2/ ;

[15:00] <skids> masak: \xe8 is pretty unambiguously a byte containing the (unsigned) value 232.  Though now that you make me think of it, buf8 doesn't really indicate signedness.  Might be room for growth there.

[15:00] <arnsholt> It might be conjectured that m:bytes// actually entails a severe restriction of allowed regex syntax?

[15:01] <TimToady> arnsholt: yes, and it's even specced at S05:4479

[15:01] <arnsholt> Allowing only ., \xdeadbeef and friends, and ranges of same at a first approximation

[15:01] <arnsholt> TimToady: Aha =)

[15:01] <moritz> plus captures and quantifiers

[15:01] <arnsholt> Yah, obviously

[15:01] <benabik> I think bufs are explicitly unsigned.  Determining signedness involves figuring out an encoding.  (Although via unpack, not via decode.)

[15:02] <arnsholt> (It just turns out that my browser search function is completely broken. Bah.)

[15:02] <masak> Util: thanks -- I'm disinclined to change the descriptions after releasing them, but maybe I'll make a note in NOTES.

[15:03] <Util> masak: great, thanks!

[15:03] <skids> .oO(from the perspective of a low level programmer, it is pretty funny that the word "endianness" appears only once in the synopsis)

[15:05] *** groky joined
[15:05] *** koban left
[15:07] <TimToady> and that paragraph is rather suspect in confusing characters with codepoints...

[15:07] <TimToady> and looks like an end-run around .encode

[15:07] <masak> Util: updated. http://strangelyconsistent.org/p6cc2011/NOTES

[15:07] *** jupp joined
[15:08] <masak> Util++ # discovering and reporting

[15:09] *** groky left
[15:09] *** hanekomu left
[15:11] * [Coke] kind of wishes the contest was in a git repo so I could clone it. ;)

[15:12] <moritz> [Coke]: it is... but it's not public, because it also contains our solutions and notes :-)

[15:12] <moritz> [Coke]: but we could make a copy of the public part and it put it into a repo, for your convenience

[15:12] <[Coke]> ok, that could be problematic. ;)

[15:13] <[Coke]> moritz: eh. I already have a repo. maybe next year. ;)

[15:13] <masak> next year we'll probably go the githib repo route, yes.

[15:13] <masak> github*

[15:13] <moritz> maybe together with the winner of this year's contest

[15:13] <masak> that would be nice :)

[15:14] <masak> I'm really glad I have moritz along this year. the contest has scaled almost exactly 2x since last year.

[15:14] <moritz> I think I've learned that 1) I'm not too well suited for managing the contest and 2) that I envy the contestants

[15:14] <masak> :P

[15:14] <masak> what makes you say (1)?

[15:15] <masak> I understand (2) compeltely.

[15:15] <moritz> and 3) although I've never done it alone, I'm pretty sure it's important to have somebody to talk to (about the tasks to chose etc.)

[15:15] <TimToady> he only has half as much experience as you :)

[15:15] <moritz> masak: well, all the interesting task ideas were yours

[15:15] <masak> yeah, full ACK on (3). I actually need several people to talk to.

[15:15] <[Coke]> niecza: say 18159 / 18587 #not finished yet.

[15:16] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«0.97697315327917367␤»

[15:16] <skids> arnsholt: BTW, endianness (and alignment thereof) as you pointed out is one of the more challenging aspects of regex on binary data, especially when it flips midstream e.g. you have a network-order area embedded in a host-order structure.  However, that is not much prettier to do with unpack than with a suitably well defined grammar.

[15:17] <masak> moritz: they were only mine until I mentioned them to you. :) you definitely helped improve them.

[15:19] *** molaf left
[15:19] <moritz> I have two more thoughts on regex/grammars for binary data

[15:20] <moritz> 1) we might have an :encoding adverb that lets you use character literals to match bytes

[15:21] <moritz> ie if you write m:bytes:encoding<ASCII>/'AB'/, you mean the bytes 0x41, 0x42

[15:21] <[Coke]> rakudo: sub postfix:<!>($n) { [*] 1..$n }; say (1, 2, 3)>>!

[15:21] <p6eval> rakudo 38165a: OUTPUT«1 2 6␤»

[15:21] <[Coke]> rakudo: sub postfix:<!>($n) { [*] 1..$n }; say (1, 2, 3)>>!

[15:21] <p6eval> rakudo 38165a: OUTPUT«1 2 6␤»

[15:21] <[Coke]> argh.

[15:21] <[Coke]> rakudo: sub infix:<+++>($a, $b) { ($a + $b) div 2 }; say 10 >>+++<< 14

[15:21] *** PacoAir joined
[15:21] <p6eval> rakudo 38165a: OUTPUT«===SORRY!===␤Missing << or >> at line 1, near "++<< 14"␤»

[15:22] <moritz> 2) I guess for many binary formats it would make sense to extract an integer out of a capture, and use the result as a quantifier

[15:22] <masak> looks like an LTM issue.

[15:22] <masak> std: sub infix:<+++>($a, $b) { ($a + $b) div 2 }; say 10 >>+++<< 14

[15:22] <p6eval> std dc62e1d: OUTPUT«ok 00:01 114m␤»

[15:22] <masak> [Coke]: is that an RT ticket already?

[15:22] <colomon> niecza: sub infix:<+++>($a, $b) { ($a + $b) div 2 }; say 10 >>+++<< 14

[15:22] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«12␤»

[15:23] <moritz> failing test at least, iirc

[15:23] <masak> moritz: for many binary formats it makes sense to talk about ASCII literals, too.

[15:23] <moritz> that's why I proposed :encoding<ASCII> to allow that

[15:23] <moritz> :-)

[15:23] <TimToady> that's why it's default

[15:24] <moritz> and that's where I disagree

[15:24] <[Coke]> rakudo: my @a = 1; for 1..10 { my $last = @a[*-1]; say $last; push @a, (sub ($s) { $s + 1 })($last) }; say @a.perl

[15:24] <p6eval> rakudo 38165a: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤Array.new(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)␤»

[15:24] <[Coke]> masak: yes. 

[15:24] <TimToady> moritz: our job is not always to protect the user

[15:25] <moritz> TimToady: no, only where we learned that it's necessary (see also: p5)

[15:25] *** jupp1 joined
[15:26] *** jupp left
[15:26] <[Coke]> rakudo: try { warn "foo"; say "alive" }

[15:26] <p6eval> rakudo 38165a: OUTPUT«foo␤alive␤»

[15:26] <moritz> [Coke]: that one only works by cheating

[15:27] <TimToady> moritz: p6 is very far from giving the user the kind of rope that p5 does

[15:27] <mls> moritz: what cheating?

[15:27] <moritz> (rakudo doesn't throw an exception as it should, it merely writes to $*ERR)

[15:27] <TimToady> you're basically going for a slippery slop argument here

[15:27] <moritz> mls: warn

[15:27] <TimToady> *slope

[15:27] <mls> moritz: no, I changed that. It uses a control exception (like it should)

[15:27] <masak> moritz: shouldn't &warn abort the try block there? isn't that why we invented CONTROL?

[15:27] <TimToady> but I would like Perl 6 to be useful in addition to being safe

[15:28] <moritz> TimToady: I just think we have different ideas how steep our slopes are

[15:28] <mls> masak: try doesn't catch control exceptions

[15:28] <masak> oh!

[15:28] <moritz> mls: oh cool

[15:28] <moritz> I missed that part

[15:28] <masak> but wait. 'warn' isn't a control exception, it's a CATCH exception.

[15:28] <masak> no?

[15:28] *** tokuhirom left
[15:29] <TimToady> warn is control

[15:29] <mls> rakudo: warn("hi") ; CONTROL { default { say "cauight" }}

[15:29] <p6eval> rakudo 38165a: OUTPUT«cauight␤»

[15:29] <moritz> mls++

[15:29] <[Coke]> rakudo: my @a := 1; say @a ~~ Positional

[15:29] <p6eval> rakudo 38165a: OUTPUT«Type check failed in binding␤  in block <anon> at /tmp/FTvvrgwEwx:1␤  in <anon> at /tmp/FTvvrgwEwx:1␤»

[15:29] <TimToady> S04:1198

[15:30] <moritz> [Coke]: I hope I closed that one

[15:30] <masak> ah, ok.

[15:30] <[Coke]> moritz: you didn't. email on its way.

[15:31] <moritz> [Coke]: aw crap. I remember writing a test for it...

[15:31] <moritz> or unfudging one

[15:31] *** kshannon joined
[15:31] <[Coke]> rakudo: { say $^x } if 1;

[15:31] <p6eval> rakudo 38165a:  ( no output )

[15:32] <[Coke]> rakudo: if 1 -> $x { say $x }

[15:32] <p6eval> rakudo 38165a: OUTPUT«1␤»

[15:34] *** wtw left
[15:35] <masak> rakudo: if 1 { say $^x }

[15:35] <p6eval> rakudo 38165a: OUTPUT«1␤»

[15:35] <masak> rakudo: -> $x { say $x } if 1

[15:35] <p6eval> rakudo 38165a:  ( no output )

[15:35] <masak> rakudo: -> $x { say $x } for 1..5

[15:35] <p6eval> rakudo 38165a: OUTPUT«1␤2␤3␤4␤5␤»

[15:35] <[Coke]> $ cat A/B.pm

[15:35] <[Coke]> class A::B {}

[15:35] <[Coke]> 2;0 coke@feather:~/sandbox/rakudo$ ./perl6 -e 'use A::B; class A {}; say "alive"'

[15:35] <[Coke]> alive

[15:35] <[Coke]> ACK. Sorry.

[15:36] <masak> TimToady: why does the 'for' form work but not the 'if' form?

[15:36] <[Coke]> rakudo: use MONKEY_TYPING; augment class Any { method invoke {1} }; .()

[15:36] <p6eval> rakudo 38165a: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Any'␤  in <anon> at src/gen/Metamodel.pm:3368␤  in block <anon> at /tmp/lFGNk09Kyt:1␤  in <anon> at /tmp/lFGNk09Kyt:1␤»

[15:37] <[Coke]> rakudo: use MONKEY_TYPING; augment class Any { method postcircumfix:<( )>($c) { 1 } }; .()

[15:37] <p6eval> rakudo 38165a:  ( no output )

[15:37] <[Coke]> rakudo: use MONKEY_TYPING; augment class Any { method postcircumfix:<( )>($c) { 1 } }; .().say

[15:37] <p6eval> rakudo 38165a: OUTPUT«1␤»

[15:38] *** wolfman2000 left
[15:38] <[Coke]> # 01/11/2012 - niecza at 97.69%

[15:38] <TimToady> masak: it would probably break list comprehensions

[15:39] <masak> how?

[15:39] <[Coke]> niecza: say 18587-18159 # almost there.

[15:39] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«428␤»

[15:39] <masak> oh well, it's not that important. it just seemed like a discontinuity to me.

[15:40] <cognominal_> nom: say Bool.parents

[15:40] <p6eval> nom 38165a: OUTPUT«Method 'parents' not found for invocant of class 'Bool'␤  in block <anon> at /tmp/wMdbZijFHP:1␤  in <anon> at /tmp/wMdbZijFHP:1␤»

[15:40] <cognominal_> nom: say Bool.^parents

[15:40] <p6eval> nom 38165a: OUTPUT«␤»

[15:40] <[Coke]> rakudo: say 685-83 # almost down to 600 tickets if you squint.

[15:40] <p6eval> rakudo 38165a: OUTPUT«602␤»

[15:40] <cognominal_> nom: say Int.^parents

[15:40] <p6eval> nom 38165a: OUTPUT«Real() Numeric()␤»

[15:40] <masak> 600 tickets! wow.

[15:41] <[Coke]> rakudo: say for 1..3

[15:41] <p6eval> rakudo 38165a: OUTPUT«␤␤␤»

[15:42] <TimToady> std: say for 1..3

[15:42] <p6eval> std dc62e1d: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/9MTlNIkg_n line 1:␤------> [32msay[33m⏏[31m for 1..3[0m␤Check failed␤FAILED 00:01 109m␤»

[15:43] <masak> TimToady: long-standing parsing bug in nom.

[15:43] <masak> b: say for 1..3

[15:43] <p6eval> b 1b7dd1: OUTPUT«␤␤␤»

[15:43] <masak> alpha: say for 1..3

[15:43] <p6eval> alpha : OUTPUT«say requires an argument at line 10, near "for 1..3"␤in Main (file src/gen_setting.pm, line 2610)␤»

[15:44] <[Coke]> rakudo: rakudo: say :a<>

[15:44] <p6eval> rakudo 38165a: OUTPUT«===SORRY!===␤Confused at line 1, near "rakudo: sa"␤»

[15:44] <[Coke]> rakudo: say :a<>

[15:44] <p6eval> rakudo 38165a: OUTPUT«===SORRY!===␤Unsupported use of <>; in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list at line 1, near "<>"␤»

[15:45] <[Coke]> rakudo: say 1%^^1

[15:45] <p6eval> rakudo 38165a: OUTPUT«0␤»

[15:46] <[Coke]> rakudo: my $b = &time; say &$b();

[15:46] <p6eval> rakudo 38165a: OUTPUT«===SORRY!===␤Symbol '&time' not predeclared in <anonymous> (/tmp/rmvYisn_Ne:1)␤»

[15:46] <[Coke]> std: my $b = &time; say &$b();

[15:46] <p6eval> std dc62e1d: OUTPUT«ok 00:01 114m␤»

[15:46] <masak> niecza: AGAIN: say "OH HAI"; goto AGAIN

[15:46] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«(timeout)OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤OH HAI␤O…

[15:47] <masak> niecza: say "A"; goto FOO; say "B"; if 42 { say "C"; FOO: say "D" }; say "E"

[15:47] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤       'FOO' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1143 (P6.comp_unit @ 32) ␤  at /home/p6…

[15:47] <masak> niecza: say "A"; goto "FOO"; say "B"; if 42 { say "C"; FOO: say "D" }; say "E"

[15:47] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«A␤Unhandled exception: Illegal control operator: goto(FOO, dynamic)␤  at /home/p6eval/niecza/lib/CORE.setting line 1120 (_lexotic @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1122 (goto @ 3) ␤  at /tmp/CjwJZAF1Z2 line 1 (mainline @ 3) ␤  at /home/…

[15:47] <[Coke]> rakudo: use Test; eval_lives_ok '1<&1'

[15:47] *** alester joined
[15:47] <p6eval> rakudo 38165a: OUTPUT«use of uninitialized value of type Nil in numeric context␤ok 1 - ␤»

[15:47] <masak> sorear: "Illegal control operator"?

[15:50] *** pmurias joined
[15:50] <pmurias> sorear: ping

[15:50] <[Coke]> rakudo: break

[15:50] <p6eval> rakudo 38165a: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&break' called (line 1)␤»

[15:51] <[Coke]> rakudo: succeed

[15:51] <p6eval> rakudo 38165a: OUTPUT«succeed without when clause␤  in block <anon> at /tmp/bkp6JWCw3l:1␤  in <anon> at /tmp/bkp6JWCw3l:1␤»

[15:51] <masak> are 'succeed' keywords specific to 'when' clauses? I think not.

[15:52] <TimToady> masak: niecza does not implement goto as specced in S04:1220, which makes it problematic for use to skip into a different 'when' condition

[15:52] <masak> a 'given' could 'succeed' outside of a 'when' clause, no?

[15:52] <masak> rakudo: given 42 { when 5 {}; succeed; when 42 { say "OH NOES" } }

[15:52] <p6eval> rakudo 38165a:  ( no output )

[15:52] <[Coke]> rakudo: "foo" ~~ / foo {make "foo"} /; say "What kind of $()l am I?"

[15:52] <p6eval> rakudo 38165a: OUTPUT«Cannot bind attributes in a type object␤  in sub make at src/gen/CORE.setting:7190␤  in block <anon> at /tmp/aQlAtwqe7P:1␤  in regex <anon> at /tmp/aQlAtwqe7P:1␤  in method ACCEPTS at src/gen/CORE.setting:7260␤  in block <anon> at /tmp/aQlAtwqe7P:1␤  in <anon> at /…

[15:53] <mls> masak: feel free to fix the error message ;)

[15:53] <TimToady> succeed escapes the current 'when' and then looks for a topicalizer block

[15:53] <masak> mls: at $dayjob right now. maybe later tonight.

[15:53] <[Coke]> rakudo: sub foo ( $f = rand ) { say $f; }; say Capture.new() ~~ &foo.signature;

[15:53] <p6eval> rakudo 38165a: OUTPUT«Bool::False␤»

[15:54] <masak> TimToady: oh, so the 'when' is necessary?

[15:54] <TimToady> S04:931

[15:54] <[Coke]> rakudo: sub foo ( $f = 0.132412414 ) { say $f; }; say Capture.new() ~~ &foo.signature;

[15:54] <p6eval> rakudo 38165a: OUTPUT«Bool::False␤»

[15:54] <benabik> nom: sub foo ( $f = rand ) { say $f }; say &foo.signature.perl

[15:54] <p6eval> nom 38165a: OUTPUT«:(Any $f?)␤»

[15:54] <[Coke]> rakudo: sub foo ( $f = substr('string',0) ) { say $f; }; say Capture.new() ~~ &foo.signature;

[15:54] <p6eval> rakudo 38165a: OUTPUT«Bool::False␤»

[15:55] <benabik> nom: sub foo ( $f = rand ) { say $f }; say &foo.signature.WHAT

[15:55] <p6eval> nom 38165a: OUTPUT«Signature()␤»

[15:56] <[Coke]> benabik: RT#77164. If you can reject it, we are at 600. ;)

[15:57] <[Coke]> nom: say 18597*.98-18159 #for colomon

[15:57] <p6eval> nom 38165a: OUTPUT«66.06␤»

[15:57] <colomon> oh, man, so tempting....

[16:00] <masak> I wonder what I got that Easter estimate from...

[16:01] <benabik> [Coke]: Well, as you note, rejecting all of them is probably not desired...

[16:02] <benabik> nom: say :().^methods

[16:02] <p6eval> nom 38165a: OUTPUT«Method 'gist' not found for invocant of class 'Sub'␤  in method gist at src/gen/CORE.setting:4005␤  in sub say at src/gen/CORE.setting:5734␤  in block <anon> at /tmp/ro5P3TYaeg:1␤  in <anon> at /tmp/ro5P3TYaeg:1␤»

[16:02] * benabik is always displeased when the REPL dies.

[16:02] <colomon> #phasers in 148 min?

[16:05] <benabik> Am I doing something wrong, or is that a bug ^^

[16:05] <colomon> nom: say :().^methods>>.name

[16:05] <p6eval> nom 38165a: OUTPUT«(signal SEGV)»

[16:06] <colomon> ye-ha!

[16:06] <benabik> nom: say 1.^methods

[16:06] <p6eval> nom 38165a: OUTPUT«Int Num Rat abs Bridge chr succ pred sqrt base floor round ceiling WHICH perl Bool Str Rat abs sign conjugate sqrt sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh floor ceili…

[16:06] *** sayu left
[16:06] <colomon> niecza: my @a = 1, 2, 3; my @b = 4, 1, 1313; say @a »min« @b

[16:06] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 806 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 170 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/ST…

[16:06] <colomon> sorear: ^^

[16:07] <benabik> [Coke]: I think the problem with Capture.new() ~~ &foo.signature is that Signature doesn't have an ACCEPTS

[16:09] <colomon> niecza: my @a = 1, 2, 3; say @a >>~>> ', ';

[16:09] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 806 (warn @ 2) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 170 (Mu.Str @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/ST…

[16:10] <masak> nom: say ().^methods>>.name

[16:10] <p6eval> nom 38165a: OUTPUT«Parcel Capture flat item list lol at_pos postcircumfix:<[ ]> STORE FLATTENABLE_LIST FLATTENABLE_HASH fmt of Bool Numeric Str ACCEPTS gist perl DUMP␤»

[16:10] <masak> nom: say (:()).^methods>>.name

[16:10] <p6eval> nom 38165a: OUTPUT«(signal SEGV)»

[16:10] <masak> nom: say (:()).^name

[16:10] <p6eval> nom 38165a: OUTPUT«Signature␤»

[16:10] <Woodi> hallo, maybe someone have new idea which can be put into security synopsis ? taint mode, data flow ?

[16:11] <dalek> roast: 1fd6098 | (Solomon Foster)++ | integration/advent2009-day05.t:

[16:11] <dalek> roast: Fudge for niecza.

[16:11] <dalek> roast: review: https://github.com/perl6/roast/commit/1fd6098838

[16:12] <dalek> niecza: 6f9dbe9 | (Solomon Foster)++ | t/spectest.data:

[16:12] <dalek> niecza: Turn on integration/advent2009-day05.t.

[16:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6f9dbe942f

[16:12] <colomon> [Coke]: there's 15 of the 67

[16:12] *** cognominal joined
[16:14] <[Coke]> colomon: \o/

[16:15] *** cognominal_ left
[16:19] <dalek> specs: 1945a6b | util++ | S32-setting-library/Containers.pod:

[16:19] <dalek> specs: [S32/Containers] fixed typo in negative .rotate

[16:19] <dalek> specs: review: https://github.com/perl6/specs/commit/1945a6bf4c

[16:22] *** jferrero left
[16:22] *** mkramer joined
[16:22] *** mkramer left
[16:23] *** jferrero joined
[16:28] <dalek> roast: 4363cc3 | (Solomon Foster)++ | S05-grammar/inheritance.t:

[16:28] <dalek> roast: Fudge for niecza.

[16:28] <dalek> roast: review: https://github.com/perl6/roast/commit/4363cc3c00

[16:28] <dalek> roast: 134127c | (Solomon Foster)++ | S05-grammar/inheritance.t:

[16:28] <dalek> roast: Add tests so that we're actually testing inheritance on the current versions of Rakudo and Niecza.

[16:28] <dalek> roast: review: https://github.com/perl6/roast/commit/134127cd46

[16:28] <dalek> niecza: 9d69852 | (Solomon Foster)++ | t/spectest.data:

[16:28] <dalek> niecza: Turn on S05-grammar/inheritance.t.

[16:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9d69852ad2

[16:29] <colomon> [Coke]: There's another 18.  Now it's time for a whistle lesson.

[16:29] <[Coke]> halfway there!

[16:31] *** cooper left
[16:32] *** cooper joined
[16:34] *** kaleem left
[16:35] *** mkramer joined
[16:35] *** kaleem joined
[16:36] *** mkramer left
[16:39] *** cognominal_ joined
[16:39] <TimToady> kshannon, moritz: re ratchet vs DFA, I don't see a problem, since the regex itself serves as the check to see if it matches with ratcheting, and fails over to a different solution if the DFA was too optimistic

[16:39] <TimToady> no need for a postprocess pass; it's already there :)

[16:40] <TimToady> and by DFA I also mean parallel NFA :)

[16:42] *** cognominal left
[16:43] <masak> can't say I grok it but it sounds like what I thought would be the case.

[16:43] *** colomon joined
[16:44] *** nornagest left
[16:48] * masak decommutes

[16:51] <TimToady> moritz: if you're still wondering about http://irclog.perlgeek.de/perl6/2012-01-11#i_4968234, I'd suggest thinking about whether the truncated string includes the name :)

[17:02] *** donri left
[17:03] <kshannon> TimToady: Duh!  Silly me...  

[17:06] *** donri joined
[17:08] *** cooper left
[17:08] <moritz> TimToady: hm, I'm not used to backtracking DFAs, so I'm not sure (how) that works

[17:08] *** MayDaniel joined
[17:09] <kshannon> The DFA doesn't backtrack.

[17:10] <kshannon> But if one of the LTM it ends up using doesn't really match because of the ratcheting,  then it will fail during the procdural pass.

[17:11] <moritz> that doesn't quite reassure me (more)

[17:11] <moritz> suppose you have

[17:11] *** cooper joined
[17:11] <moritz> token word { \w+ };   'abc' ~~ /<word><word>/

[17:12] <moritz> when transformed to a DFA, the first <word> will match 'ab', and the second <word> matches 'c'

[17:12] <TimToady> then it will fail in the grammar, as it should

[17:12] <moritz> ah, so each DFA match always require a re-parse?

[17:13] <TimToady> yes

[17:13] <moritz> that's the part I was missing

[17:13] <kshannon> It already has to do that to make sure that zero-width assertions match properly.

[17:14] <TimToady> even with fates, they only influence alteration choices, not normal matching

[17:14] <TimToady> *alternation

[17:15] *** jupp1 left
[17:16] <kshannon> It may be able to optimize the re-parse somewhat, using info (like fates) from the [DN]FA run, but it has to be careful to make sure all the original semantics still hold.

[17:17] <TimToady> nodnod

[17:18] <TimToady> for parsing the typical computer language, however, it's not that much faster to skip N chars than to match N chars that are already probably in the cache

[17:18] <TimToady> other parsing problems may show greater benefit from such an optimization though

[17:19] *** snearch left
[17:19] <kshannon> I think tomorrow I'm going to write some tests to stress test these corner cases...

[17:19] *** snearch joined
[17:22] <sorear> good * #perl6

[17:22] <kshannon> TimToady: http://irclog.perlgeek.de/perl6/2012-01-11#i_4968552  -  Do you think that's really the right semantics for ||

[17:25] <sorear> moritz: No, Rakudo has a shorter version number, so p6eval cut off less of its output

[17:25] <moritz> sorear: yes, I've seen that too (after TimToady++'s hint)

[17:30] <TimToady> kshannon: are you asking about C or about B2?

[17:30] <kshannon> C

[17:31] <cognominal_> nom: sub a { callframe }; a

[17:31] <p6eval> nom 38165a:  ( no output )

[17:31] <kshannon> B2 not being in LTM makes sense.

[17:31] <cognominal_> nom: sub a { callframe }; say a

[17:31] <p6eval> nom 38165a: OUTPUT«Method 'perl' not found for invocant of class 'CallContext'␤  in method reify at src/gen/CORE.setting:4380␤  in method reify at src/gen/CORE.setting:4285␤  in method reify at src/gen/CORE.setting:4285␤  in method gimme at src/gen/CORE.setting:4649␤  in method eager at…

[17:31] <kshannon> I was actually suprised at B1 being part of LTM as well,  but I'm willing to accept that.

[17:31] <TimToady> if || is mostly used to express failure (and that's the case in STD), then it makes some sense to include C, but I could argue that the || is procedural, so should stop there

[17:32] *** jupp joined
[17:33] <TimToady> I don't actually recall which way STD did/does that; perhaps sorear++ knows

[17:34] <TimToady> sorear: something broke, maybe in constant folding:

[17:34] <TimToady> niecza: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; say @primes[^20];

[17:34] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Kernel.IterFlatten (Niecza.VarDeque inq) [0x00000] in <filename unknown>:0 ␤  at Run.CORE.C504Iterator.flat (Niecza.Frame ) [0x00000] in <…

[17:34] <moritz> #phasers time

[17:34] <TimToady> btw, ^^ is a completely FP prime finder

[17:34] <kshannon> Hmmm, so it gets transformed into the equivalent of A [ B1 C | ] for LTM, and then if the B1 C doesn't match, A does and it falls into the B2 arm.

[17:35] <TimToady> you shouldn't rely on my memory when I have the flu...

[17:35] <kshannon> s/match, A does/match, but A does/

[17:35] <kshannon> :)

[17:36] <TimToady> this should not be taken to imply that you should rely on my memory when I *don't* have the flue... :)

[17:36] <TimToady> or the flu...

[17:36] <kshannon> I can sorta see the reasoning.  I'll have to re-read some of the grammars and think about it more.

[17:36] <TimToady> these decisions tend to go off into pragmatics rather than theory...

[17:37] <TimToady> though sometimes it comes down to "If we make it this way, then it's possible to express both ideas, but if we make it that way, we can't..."

[17:38] <kshannon> Which this falls under I guess.  adding a sequence point before the temporal alternation gives the semantics I was imagining.

[17:38] <TimToady> there's also the consideration (depending on how smart your NFA is) that recombining tails of alternations can result in combinatorial explosions of states

[17:39] <TimToady> which tends to argue against Cish decisions

[17:40] <TimToady> but including B1 is important for the ||-as-error use case, I think

[17:42] <TimToady> anyway, that seems to work out best so far

[17:42] <kshannon> The interesting thing is my intuition had the || and && not contributing to LTM at all,  and the non-greedy quiantifiers contributing as much as they could (i.e. if the minimum repetitions was > 0)

[17:43] *** cognominal_ left
[17:43] *** JimmyZ joined
[17:43] *** cognominal_ joined
[17:43] <kshannon> And then I was re-reading S05 and found them the other way around.

[17:43] *** mls_ joined
[17:45] *** wolfman2000 joined
[17:46] *** jupp left
[17:46] *** Chillance joined
[17:49] *** thou joined
[17:50] *** spine_ left
[17:51] <sorear> pmurias: pong

[17:53] *** molaf joined
[17:53] *** nornagest joined
[17:53] *** daxim left
[17:54] *** dakkar left
[17:56] *** mj41 left
[17:59] *** mj41 joined
[17:59] *** kaleem left
[18:03] <LlamaRider> perl6: my &s = sub ($a,*@a) { say $a; say @a; exit }; 1,2,3, &s ... 5;

[18:03] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "5"␤    expecting operator␤    at /tmp/wtkBEiaNKG line 1, column 62␤»

[18:03] <p6eval> ..rakudo 38165a, niecza v13-207-g0ab28e3:  ( no output )

[18:04] <LlamaRider> oO

[18:04] <LlamaRider> rakudo: my &s = sub ($a,*@a) { say $a; say @a; exit }; 1,2,3, &s ... 5;

[18:04] <p6eval> rakudo 38165a:  ( no output )

[18:04] <LlamaRider> again different output on my local machine, I get a lonely "3" printed.

[18:04] <LlamaRider> in any case - slurpy arguments don't work with sequence subs?

[18:04] <LlamaRider> or am I missing something

[18:04] *** Trashlord joined
[18:06] *** mj41 left
[18:10] *** LlamaRider left
[18:12] *** LlamaRider joined
[18:13] *** xinming left
[18:18] *** GlitchMr joined
[18:18] <moritz> LlamaRider: a lazy list in void context doesn't have any reason to generate more elements

[18:19] <moritz> LlamaRider: if you run the code in your REPL, it'll try to generate enough elements to print the sequence though

[18:19] <moritz> which is probably why you see the lone 3

[18:19] <LlamaRider> aha!

[18:19] *** jupp joined
[18:19] <LlamaRider> how do I get my hands on the entire list then?

[18:19] *** thou left
[18:20] <moritz> not at all, if you exit() in the generator :-)

[18:20] <LlamaRider> :-)

[18:20] <LlamaRider> i want the current subsequence accessible inside the generator

[18:20] <LlamaRider> (justs for the heck of trying to get something similar to t3 in a one-liner)

[18:21] <LlamaRider> and I see it there

[18:21] <sorear> EOBACKLOG

[18:21] <LlamaRider> if I ask for $^x, $^y, $^z i see 3,2,1

[18:21] <moritz> nom: eager 1, 2, 3, -> *@a { say @a.perl; 4 } ... 4;

[18:21] <p6eval> nom 38165a: OUTPUT«Array.new()␤»

[18:22] <moritz> doesn't seem to be working with slurpies yet :-)

[18:22] <moritz> erm, s/)/(/

[18:22] <LlamaRider> nom: eager 1, 2, 3, -> *@a { say @a; 4 } ... 4;

[18:22] <p6eval> nom 38165a: OUTPUT«␤»

[18:22] *** xinming joined
[18:22] <LlamaRider> I see

[18:23] <LlamaRider> so then it's impossible :-(

[18:24] <moritz> nom: my @a := 1, 2, 3, { say @a; 4 } .. 4; @a.eager

[18:24] <p6eval> nom 38165a: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(\$v, Mu *%_)␤␤  in method Numeric at src/gen/CORE.setting:646␤  in sub infix:<==> at src/gen/CORE.setting:2240␤  in sub infix:<cmp> at src/gen/CORE.setting:1186␤  in method reify …

[18:24] <moritz> meh :(

[18:24] <moritz> nom: my @a := 1, 2, 3, { say @a; 4 } ... 4; @a.eager

[18:24] <p6eval> nom 38165a: OUTPUT«␤splice() not implemented in class 'Mu'␤  in method reify at src/gen/CORE.setting:4285␤  in method gimme at src/gen/CORE.setting:4649␤  in method eager at src/gen/CORE.setting:4624␤  in block <anon> at /tmp/vwsBl4bPJM:1␤  in <anon> at /tmp/vwsBl4bPJM:1␤»

[18:24] <moritz> meh :((

[18:24] <moritz> LlamaRider: no, seems to be broken right now :(

[18:25] <LlamaRider> any introspection backdoor ?

[18:25] <LlamaRider> that i ask for the parcel of the current sub?

[18:25] <LlamaRider> or smth

[18:26] <LlamaRider> s/parcel/capture/

[18:31] <colomon> nom: eager 1, 2, 3, -> @a { say @a; 4 } ... 4;

[18:31] <p6eval> nom 38165a: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Int instead␤  in block <anon> at /tmp/Ftl0_1W9S9:1␤  in sub coro at src/gen/CORE.setting:4527␤  in method reify at src/gen/CORE.setting:4502␤  in method reify at src/gen/CORE.setting:4285␤  in m…

[18:31] <colomon> nom: eager 1, 2, 3, -> *@a { say @a; 4 } ... 4;

[18:31] <p6eval> nom 38165a: OUTPUT«␤»

[18:31] <colomon> nieacza: eager 1, 2, 3, -> *@a { say @a; 4 } ... 4;

[18:31] <colomon> niecza: eager 1, 2, 3, -> *@a { say @a; 4 } ... 4;

[18:31] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤    'eager' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1143 (P6.comp_unit @ 32) ␤  at /ho…

[18:32] <colomon> niecza: say 1, 2, 3, -> *@a { say @a; 4 } ... 4;

[18:32] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«1 2 3␤1 2 3 4␤»

[18:32] <sorear> colomon: How do you reproduce the Test::Util failure?

[18:32] <LlamaRider> WOW

[18:32] *** spine joined
[18:32] <LlamaRider> go niecza! :)

[18:32] <colomon> sorear: give me a moment to reproduce, I rebooted before skyping this morning.

[18:34] <LlamaRider> btw, is it considered bad use of resources if I open a private chat with p6eval and try to make a niecza one-liner? :)

[18:34] <colomon> sorear: prove --verbose -e t/fudgeandrun t/spec/S32-scalar/undef.t

[18:35] <[Coke]> private chats with p6eval are probably a good thing.

[18:35] * geekosaur would think golfing is a really good reason to use a private chat

[18:35] <[Coke]> (says the guy who send about 100 public messages to it this morning.)

[18:36] <sorear> colomon: I golfed your failure earlier to just '1»~«1'

[18:36] <colomon> though public chats have the benefit of kibitzing.

[18:36] <LlamaRider> I'll share the results ;)

[18:37] <colomon> sorear: sorry for not trying to golf it more, I was trying to sneak in a couple of quick spectest adds before my lesson.  :)

[18:38] <moritz> LlamaRider: (private p6eval chat) feel free

[18:38] <LlamaRider> (do they timeout on infinite loops? *guilty look*)

[18:38] <moritz> sure

[18:39] <[Coke]> nom: loop {}

[18:39] <moritz> otherwise I'd be restarting that thing 5 to 20 times a day :-)

[18:39] <p6eval> nom 38165a: OUTPUT«(timeout)»

[18:39] * moritz is too lazy for that

[18:40] *** kaleem joined
[18:40] <[Coke]> nom: "30".print

[18:40] <p6eval> nom 38165a: OUTPUT«30»

[18:40] <[Coke]> niecza: "30".print

[18:40] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Unhandled exception: Unable to resolve method print in class Str␤  at /tmp/tT0kWiYS7w line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2988 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2989 (module-CORE @ 59) ␤  at /home…

[18:41] *** jupp left
[18:42] *** kaleem left
[18:42] <colomon> sorear: to get the Niecza.Serialization.ThawException: dated sources exception, I had to delete change line 7 of Test::Util.pm to 

[18:43] <colomon> proto sub is_run(|$) is export { * }

[18:43] <colomon> (ie lose the (:DEFAULT))

[18:44] <[Coke]> # 01/11/2012 - niecza at 97.88% 

[18:45] <[Coke]> b: say 18587-18193 ; say 18597*.98-18193

[18:45] <p6eval> b 1b7dd1: OUTPUT«394␤32.06␤»

[18:45] <LlamaRider> "Unsupported use of [-1] subscript to access from end of array; in Perl 6 please use [*-1]"

[18:45] <LlamaRider> kudos to whoever decided to turn the error messages into a textbook for P6 :)

[18:45] <[Coke]> Aye.

[18:47] <LlamaRider> done. I give you the non-deterministic, non-minimal, addition chain construction one-liner (~ t3 for p6cc):

[18:47] <LlamaRider> niecza: my $n=11; say 1, 2, -> *@a { my $next=$n+1; $next = @a.pick+@a.pick while ($next>$n || $next <= @a[*-1]) ; $next;} ... $n;

[18:47] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«1 2 3 4 6 7 11␤»

[18:48] <LlamaRider> (though I agree it's almost illegible :D)

[18:48] *** thou joined
[18:49] * moritz likes it :-)

[18:50] <LlamaRider> I am sure one can estimate the times you need to run the line to be "almost sure" you found a minimal chain

[18:51] * [Coke] tries to ignore that send. :P

[18:53] <LlamaRider> it's very tempting, since it's a one-liner :D

[18:53] *** JimmyZ left
[18:55] <LlamaRider> moritz: do you know if there are "slurpy arguments in sequence subs" tests in the P6 test suite? I would vote for adding one if not (seems like one of those things one might forget to think about)

[18:56] <dalek> niecza: 2aab48f | sorear++ | lib/Kernel.cs:

[18:56] <dalek> niecza: Add missing case to list circularity checker for TimToady

[18:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2aab48fd2e

[18:57] <sorear> TimToady's latest generator needs to be primed with 2, 3, 5, 7 to work

[18:58] <sorear> colomon: and then what?  run a test file that uses it?

[18:58] <colomon> prove --verbose -e t/fudgeandrun t/spec/S32-scalar/undef.t

[18:58] <colomon> is the particular command line I've been using to trigger it

[18:59] * sorear has not much clue what's going on with 1»~«1

[19:01] *** LlamaRider left
[19:02] *** LlamaRider joined
[19:06] <TimToady> niecza: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; my @x.plan: @primes; say @x[^20];

[19:06] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71␤»

[19:06] <TimToady> then why does that work?

[19:06] <TimToady> sorear: ^^

[19:07] *** xinming left
[19:07] <sorear> TimToady: because that version allows $n to vary in the inner loop

[19:08] <sorear> niecza: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; say  @primes[^20];

[19:08] <p6eval> niecza v13-207-g0ab28e3: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Kernel.IterFlatten (Niecza.VarDeque inq) [0x00000] in <filename unknown>:0 ␤  at Run.CORE.C504Iterator.flat (Niecza.Frame ) [0x00000] in <…

[19:08] <benabik> @x.plan ?

[19:08] <sorear> wait, what IS the difference between these?

[19:08] <sorear> oh

[19:09] <TimToady> thing is, it used to work

[19:10] * TimToady suspects overagressive constant folding somewhere or other

[19:10] <TimToady> *agg

[19:10] <TimToady> but only because that's one of the things you were just working on...

[19:11] <sorear> it used to be that if you tried to iterate past the reified end of a list recursively, the recursive calls would see the list just end

[19:11] <sorear> now it errors

[19:11] <sorear> I suspect this is it

[19:11] <sorear> the old behavior, while inconsistant, helped the primers

[19:14] <sorear> TimToady: what did you think of the latest specs pull-request?

[19:14] <TimToady> I don't understand what you're asking

[19:17] <sorear> https://github.com/perl6/specs/pull/10

[19:17] *** xinming joined
[19:18] *** nebuchadnezzar left
[19:18] <dalek> niecza: f65c77a | sorear++ | src/ (3 files):

[19:18] <dalek> niecza: Fix »~«, add NIECZA_STD_DEBUG

[19:18] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f65c77a728

[19:20] *** nebuchadnezzar joined
[19:20] *** nebuchadnezzar left
[19:22] *** nebuchadnezzar joined
[19:24] *** birdwindupbird joined
[19:25] <dalek> roast: ab6ab0b | (Solomon Foster)++ | S13-overloading/typecasting-long.t:

[19:25] <dalek> roast: Fudge for niecza.

[19:25] <dalek> roast: review: https://github.com/perl6/roast/commit/ab6ab0b48f

[19:27] *** jupp joined
[19:31] <[Coke]> ooh, 12 more.

[19:32] <colomon> slowly but surely.  :)

[19:32] *** LlamaRider left
[19:32] <dalek> niecza: 698b0d6 | (Solomon Foster)++ | t/spectest.data:

[19:32] <dalek> niecza: Turn on S13-overloading/typecasting-long.t.

[19:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/698b0d6541

[19:33] <[Coke]> I need to avoid IRC for a bit. good luck, colomon. :)

[19:34] *** MayDaniel left
[19:35] <dalek> roast: e54f3fa | (Solomon Foster)++ | integration/advent2009-day05.t:

[19:35] <dalek> roast: Unfudge tests that work now in niecza, sorear++.

[19:35] <dalek> roast: review: https://github.com/perl6/roast/commit/e54f3fac13

[19:36] <sorear> nom: class A { method postcircumfix:<( )>($x) { say $x.perl } }; A(5)

[19:36] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&A' called (line 1)␤»

[19:37] <sorear> nom: class A { method postcircumfix:<( )>($x) { say $x.perl } }; (A.new)(5)

[19:37] <p6eval> nom 38165a: OUTPUT«Capture.new()␤»

[19:37] <sorear> bleh

[19:37] <sorear> why?

[19:37] <sorear> I need to talk to jnthn on this

[19:38] <sorear> I think it makes vastly more sense for postcircumfix:<( )> to simply receive the arguments

[19:38] <benabik> If you want a capture, there's syntax for it already.

[19:38] <colomon> +1

[19:42] *** jupp1 joined
[19:42] *** jupp left
[19:43] *** kmwallio left
[19:44] *** arlinius left
[19:47] <TimToady> niecza: say 2,3 ... * >= sqrt 5

[19:47] <p6eval> niecza v13-216-g2aab48f: OUTPUT«2 3␤»

[19:47] <TimToady> sorear: I'm not sure I'm buying the notion that you're running into the end of @primes

[19:48] <TimToady> 3 is already reified, and the inner loop terminates on it

[19:48] <sorear> niecza: 2, 3, gather { die } ... * >= sqrt 5

[19:48] <p6eval> niecza v13-216-g2aab48f:  ( no output )

[19:48] <sorear> niecza: say 2, 3, gather { die } ... * >= sqrt 5

[19:48] <p6eval> niecza v13-216-g2aab48f: OUTPUT«2 3␤»

[19:49] <sorear> niecza: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; say  @primes[^20];

[19:49] <p6eval> niecza v13-216-g2aab48f: OUTPUT«Unhandled exception: Circular data dependency in list iteration, or last fetch threw exception␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Iterator.flat @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1201 (Parcel.flat @ 4) ␤  at /home/p6eval/n…

[19:49] <sorear> niecza: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; .say for @primes;

[19:49] <p6eval> niecza v13-216-g2aab48f: OUTPUT«(timeout)2␤3␤5␤7␤11␤13␤17␤19␤23␤29␤31␤37␤41␤43␤47␤53␤59␤61␤67␤71␤73␤79␤83␤89␤97␤101␤103␤107␤109␤113␤127␤131␤137␤139␤149␤151␤157␤163␤167␤173␤179␤181␤191␤193␤197␤199␤211␤223␤227␤229␤233␤239␤241␤251␤257␤263␤269␤271␤277␤281␤283␤293␤307␤311␤313␤317␤331␤337␤347…

[19:49] <TimToady> it's more like it's trying to reify out of order maybe

[19:50] <sorear> niecza: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; for ^20 { say @primes[$_] }

[19:50] <p6eval> niecza v13-216-g2aab48f: OUTPUT«2␤3␤Unhandled exception: Circular data dependency in list iteration, or last fetch threw exception␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Iterator.flat @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1201 (Parcel.flat @ 4) ␤  at /home/p6ev…

[19:50] <sorear> niecza: constant @primes = 2, 3, gather { die }; my $p = 3; say ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1]

[19:50] <p6eval> niecza v13-216-g2aab48f: OUTPUT«5␤»

[19:51] <sorear> I suspect some lag is being introduced by the sequence operator

[19:52] <sorear> I thought I fixed that, but maybe there's other lag.

[19:52] <sorear> niecza: say (2, 3, gather { die } ... *)[1]

[19:52] <p6eval> niecza v13-216-g2aab48f: OUTPUT«3␤»

[19:53] * sorear doesn't really get what's going on here, either

[19:53] *** thou left
[19:53] * TimToady blames Hofstadter's Law

[19:55] *** thou joined
[19:57] <dalek> roast: 3e8f57b | (Solomon Foster)++ | S06-multi/proto.t:

[19:57] <dalek> roast: Fudge for niecza.

[19:57] <dalek> roast: review: https://github.com/perl6/roast/commit/3e8f57bb38

[19:57] <dalek> niecza: d461515 | (Solomon Foster)++ | t/spectest.data:

[19:57] <dalek> niecza: Turn on S06-multi/proto.t.

[19:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d461515ba3

[19:58] *** Trashlord left
[19:58] *** wolfman2000 left
[20:00] <TimToady> It's just a good thing he formulated it in that order, or it would have come out: Even when you take into account Hofstadter's Law, even when you take into account Hofstadter's Law, even when you take into account Hofstadter's Law...

[20:02] <dalek> roast: 0f9c6e3 | (Solomon Foster)++ | S06-currying/mixed.t:

[20:02] <dalek> roast: Fudge for niecza.

[20:02] <dalek> roast: review: https://github.com/perl6/roast/commit/0f9c6e3369

[20:02] <dalek> niecza: 0e6968c | (Solomon Foster)++ | t/spectest.data:

[20:02] <dalek> niecza: Turned on S06-currying/mixed.t.

[20:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0e6968cb8d

[20:02] *** nebuchadnezzar left
[20:06] <colomon> niecza: say 8, */2 ... *-* < 2

[20:06] <p6eval> niecza v13-216-g2aab48f: OUTPUT«8 4 2 1␤»

[20:06] <colomon> niecza: say 8, */2 ... abs(*-*) < 2

[20:06] <p6eval> niecza v13-216-g2aab48f: OUTPUT«Unhandled exception: Cannot use value like WhateverCode as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 214 (Any.Numeric @ 5) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.s…

[20:08] <sorear> abs isn't syntactically an operator, so it doesn't whatever-crry

[20:08] <sorear> niecza: say 8, */2 ... (*-*).abs < 2

[20:08] <p6eval> niecza v13-216-g2aab48f: OUTPUT«8 4 2 1␤»

[20:09] <GlitchMr> ...

[20:09] <GlitchMr> I still think who would make code like "say 8, */2 ... (*-*).abs < 2"...

[20:10] <GlitchMr> Perl 6 is more confusing than Perl 5...

[20:10] *** nebuchadnezzar joined
[20:11] <sorear> colomon: the problem is the conflict between packages/Test.pm and niecza's native Test.pm

[20:12] <sorear> colomon: the 'use Test' in Test::Util is resolved to the native Test.pm, because each module has its own @*INC

[20:12] <masak> GlitchMr: definitely.

[20:12] <masak> GlitchMr: I also prefer its capacities to Perl 5.

[20:12] <GlitchMr> Some parts are nice... but some look like GolfScript...

[20:12] *** bluescreen10 left
[20:13] <sorear> Didn't Perl 5 *invent* Gold?

[20:13] <sorear> f

[20:13] *** BinGOs joined
[20:13] <geekosaur> arguably that was apl

[20:14] <GlitchMr> for me that was java

[20:14] <GlitchMr> But seriously. Regular expressions were made popular by Perl, but wasn't made by it.

[20:15] <GlitchMr> weren't*

[20:15] <TimToady> Regexen aren't really bad...they're just drawn that way...

[20:15] <GlitchMr> But yeah, I can agree with APL...

[20:16] <GlitchMr> x[⍋x←6?40]

[20:16] <GlitchMr> really?

[20:16] <GlitchMr> really...

[20:16] *** Trashlord joined
[20:16] <GlitchMr> This picks 6 non-repeating numbers from the range 1-40...

[20:16] <GlitchMr> This... is... golf :P.

[20:17] <tadzik> GlitchMr: no one forces you to write like this

[20:17] <tadzik> you can write obfuscated code in C too. What's the point?

[20:17] <GlitchMr> Weird characters...

[20:17] <GlitchMr> I don't know...

[20:17] <TimToady> x[ ⍋ x ← 6 ? 40 ]    fixed it for ya

[20:18] <tadzik> whatever that means

[20:18] <cognominal_> rakudo people may find this patch interesting :  controlling backtrace with env var RAKUDO_BACKTRACE   https://gist.github.com/1596551

[20:18] *** arlinius joined
[20:18] <GlitchMr> http://en.wikipedia.org/wiki/APL_(codepage)

[20:19] <GlitchMr> I guess that Perl 6 will need separate keyboard soon... :P

[20:19] <TimToady> only if you're into set theory

[20:20] <GlitchMr> There is only « for now (it's good that it can be replaced with <<, but still)...

[20:20] <GlitchMr> What will happen in Perl 7... if it will exist...

[20:21] <TimToady> this is already specced at S01:93

[20:21] <GlitchMr> What is 93?

[20:21] <TimToady> line number, but if you visit the irclog, it'll have a link

[20:21] <GlitchMr> Line number in POD file?

[20:22] <TimToady> which points to http://perlcabal.org/syn/S01.html#line_93

[20:23] *** jupp1 left
[20:23] *** mj41 joined
[20:23] * cognominal_ notes that 7 is the figure before 8, which is infinity sideways

[20:24] <TimToady> you just need the "TURN SIDEWAYS" modifier :)

[20:25] <GlitchMr> Actually, I think I will return to MOV X, Y coding... it's easier to understand...

[20:25] <TimToady> or if you're in Haskell, use the compareTwoGraphemesAndDoTheSameThingToAnother operator

[20:26] <TimToady> simple matter of finding the fixed point

[20:27] *** thou left
[20:27] *** kaare_ joined
[20:27] <cognominal_> the mathematician Jean Yves Girard (the guy who designed System F) assimilates infinity to imperfection.

[20:28] <cognominal_> So 7 is perfection and 8 imperfection if I continue this kabbalist thread.

[20:29] <cognominal_> TimToady: extra points if you find the fixed point with pointfree programming

[20:30] <cognominal_> maybe pointless would be appropriate here.

[20:30] <geekosaur> p6 gematria?

[20:30] *** benabik left
[20:30] <TimToady> or pointalist...

[20:31] *** benabik joined
[20:31] <GlitchMr> I don't like sigils with dots... it looks weird...

[20:31] <TimToady> *pointillist

[20:31] <benabik> Makes cents to me...

[20:32] <masak> GlitchMr: you're disgusted because different languages allow you to abbreviate code until it's unreadable. I'm enthralled because so many languages allow me to think in new ways, and express solutions sometimes verbosely, sometimes tersely.

[20:32] <GlitchMr> Maybe that's true...

[20:32] <masak> GlitchMr: do you mean the dot twigil, like in @.legs ?

[20:32] <GlitchMr> No, I mean $a.print

[20:32] <TimToady> I believe it was a pun

[20:33] <GlitchMr> I don't know why, but $a->print looks OK for me, a.print looks OK... but $a.print doesn't... it's probably something weird with me...

[20:33] <masak> GlitchMr: some people love that feature. they say "ooh, everything is an object!", and moritz says "auugh!" :P

[20:33] <TimToady> maybe it's because you're used to what you're used to...

[20:34] <masak> GlitchMr: I think it'll pass. I don't find it strange at all.

[20:34] <GlitchMr> But it's maybe because dot operator is used for sideeffects. Whatever :).

[20:35] <masak> huh? :)

[20:35] <GlitchMr> I like ~ operator usage. It looks clever and nice. It's way better that dot in such usage...

[20:35] *** jupp joined
[20:35] <GlitchMr> JS doesn't have stuff like [0,1,2].alert() but it has stuff like 2..sin()...

[20:36] <GlitchMr> 'abc' ~ 'def' # looks nice

[20:36] <GlitchMr> 'abc' . 'def' # looks weird for me...

[20:36] <GlitchMr> It doesn't have ambiguity of "+" operator used in various programming languages and it doesn't look weird.

[20:37] <benabik> nom: say('abc'.'comb')

[20:37] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Quoted method name requires parenthesized arguments at line 1, near ")"␤»

[20:38] <masak> GlitchMr: there's a guy who, when I meet him at Perl events, complains a lot about the fact that he can't put whitespace between 'foo' and '()' in 'foo()' in Perl 6. there will always be some features of syntax that displease some people.

[20:38] <GlitchMr> Tilde is rarely used in programming languages aside of bitwise NOT, so it's pretty nice :).

[20:38] <GlitchMr> masak, it reminds me Ruby and CoffeeScript for some reason :).

[20:39] <GlitchMr> But I don't care. It's actually pretty nice. Why you would want to use space in middle of function call... I don't know...

[20:39] <TimToady> we decided NOT was a variant of XOR with 0, so they both use ^ in Perl 6

[20:39] <tadzik> masak: I don't like it either, TBH

[20:39] <masak> CoffeeScript -- now there's a weird pony. half of the dev world seems to love it, the other half seems to find it completely inane.

[20:40] <GlitchMr> I don't like Ruby, but I like CoffeeScript... yeah... I'm weird...

[20:40] <masak> tadzik: I don't *like* it either -- I just dislike the TTIAR rule less.

[20:40] <arnsholt> masak: And he doesn't like unspace either, I assume? =)

[20:40] <masak> arnsholt: oh, he detests it!

[20:40] <masak> arnsholt: he's insulted I even suggested it (which I do every time).

[20:40] <colomon> (*-*) # TIE Bomber operator...

[20:41] <arnsholt> You should keep on suggesting it as well =)

[20:41] <GlitchMr> irb(main):005:0> puts ()

[20:41] <GlitchMr> (irb):5: warning: don't put space before argument parentheses

[20:41] <masak> arnsholt: naturally :)

[20:41] <GlitchMr> CoffeeScript makes it syntax error...

[20:41] <GlitchMr> And I actually think it's good thing.

[20:42] <masak> nom: say(42)+1 say (42)+1

[20:42] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Confused at line 1, near "say(42)+1 "␤»

[20:42] <masak> nom: say(42)+1; say (42)+1

[20:42] <p6eval> nom 38165a: OUTPUT«42␤43␤»

[20:42] <masak> there's the difference in Perl 6.

[20:42] <GlitchMr> I actually think it's good thing in background of stuff from Perl 5 like print (2 + 3), 5

[20:42] <dalek> roast: d78ab6f | (Solomon Foster)++ | S03-sequence/limit-arity-2-or-more.t:

[20:42] <dalek> roast: Fudge for niecza, add versions of fudged tests that niecza has no problem passing.

[20:42] <dalek> roast: review: https://github.com/perl6/roast/commit/d78ab6f6a7

[20:42] <masak> nom: print (2 + 3), 5

[20:42] <p6eval> nom 38165a: OUTPUT«55»

[20:43] <dalek> niecza: e411c4a | (Solomon Foster)++ | t/spectest.data:

[20:43] <dalek> niecza: Turn on S03-sequence/limit-arity-2-or-more.t.

[20:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e411c4a8a3

[20:44] <GlitchMr> I'm using following rule when deciding to use () or not... if function gives sideffects don't use it, otherwise use it.

[20:44] <cognominal_> I note that when I open in gmail the bug I submitted for rakudo nom, google advertises me "typesafe Scala traning"

[20:44] <GlitchMr> I personally like this rule

[20:44] <TimToady> if a function gives side effects, it's not a function :P

[20:44] <GlitchMr> What is "print" from Perl then?

[20:45] <GlitchMr> It has side effects of putting stuff to STDOUT or other file handle.

[20:45] <benabik> A subroutine

[20:45] <cognominal_> it is dysfunctional function.

[20:45] <GlitchMr> Oh, right... I forgot it has different name in Perl...

[20:45] <TimToady> at least it's functional

[20:47] <masak> GlitchMr: don't worry -- I call 'em functions too sometimes :)

[20:47] <GlitchMr> In most programming languages I have used it's called function, even if it makes sideeffects... that's weird...

[20:47] <GlitchMr> Like... alert("") from JS...

[20:48] <GlitchMr> (not like you should use alert() in your programs)

[20:48] <awwaiid> rakudo: my $x = say 5 ; say $x.perl

[20:48] <p6eval> rakudo 38165a: OUTPUT«5␤Bool::True␤»

[20:48] *** birdwindupbird left
[20:50] *** ksi joined
[20:50] <cognominal_> worse, js makes "function" a keyword.

[20:51] <GlitchMr> PHP does it too... and...

[20:51] <geekosaur> you just want it to use lambda as the keyword

[20:51] <GlitchMr> But yeah, Perl is way better than PHP...

[20:52] <GlitchMr> JS is weird... it has anonymous named functions... whatever it means...

[20:52] <benabik> ...  Anonymous named function?

[20:52] <tadzik> it just means that sub foo {} is just foo = sub { }

[20:52] <GlitchMr> var func = function f1() {

[20:52] <GlitchMr> More like this

[20:52] <flussence> function declarations return themselves

[20:53] <geekosaur> so?  p5 has my $foo = sub {}, same thing

[20:53] *** LlamaRider joined
[20:54] <GlitchMr> > (function named(arg){if(arg==1)return 1;return named(arg-1)*arg}(3))

[20:54] <GlitchMr> 6

[20:54] <GlitchMr> It's more like this

[20:54] <masak> ah, cognominal_++ reported that -n is broken. I found that out the other day, but maybe I didn't RT it.

[20:54] <GlitchMr> The function name is only seen inside the function.

[20:55] <geekosaur> so, hack for recursive anonymous functions

[20:55] <GlitchMr> Something like this

[20:56] * geekosaur tries to imagine p6 using Whatever for that, on top of its other uses, feels brain explode

[20:56] <benabik> GlitchMr: That's just nested functions.  Nothing odd there.

[20:57] <GlitchMr> Yes, except named() isn't defined outside the function

[20:57] *** LlamaRider_ joined
[20:57] <flussence> perl6: sub x { my $y = sub z { return 5 }; return $y }; my $y = x; say $y.()

[20:57] <p6eval> niecza v13-220-g0e6968c: OUTPUT«Potential difficulties:␤  &z is declared but not used at /tmp/jiUFL5X0o4 line 1:␤------> [32msub x { my $y = sub z [33m⏏[31m{ return 5 }; return $y }; my $y = x; sa[0m␤␤5␤»

[20:57] <p6eval> ..rakudo 38165a: OUTPUT«5␤»

[20:57] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "$y"␤    expecting "=", subroutine parameters, trait, block, context, ":" or "("␤    at /tmp/n4QHDorXcl line 1, column 12␤»

[20:57] *** LlamaRider left
[20:58] *** LlamaRider_ left
[20:58] *** LlamaRider joined
[20:58] <flussence> nom: sub x { my $y = sub z($i) { return $i > 3 ?? $i !! z($i + 1) }; return $y }; my $y = x; say $y.(1)

[20:58] <p6eval> nom 38165a: OUTPUT«4␤»

[20:58] <flussence> nom: sub x { my $y = sub z($i) { return $i > 3 ?? $i !! z($i + 1) }; return $y }; my $y = x; say $y.(1); say z(1)

[20:58] <GlitchMr> Except if I would skip parenthesis at end and beginning in this example, it would create named() variable

[20:58] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&z' called (line 1)␤»

[20:58] <GlitchMr> function named(arg){if(arg==1)return 1;return named(arg-1)*arg}(3)

[20:58] <GlitchMr> (function named(arg){if(arg==1)return 1;return named(arg-1)*arg}(3))

[20:58] <GlitchMr> are different

[20:59] <TimToady> perl6: (anon sub foo ($n) { say $n; foo($n-1) if $n })(5)

[20:59] <p6eval> niecza v13-220-g0e6968c: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤    'foo' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1143 (P6.comp_unit @ 32) ␤  at /home…

[20:59] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "foo"␤    expecting "=", subroutine parameters, trait or block␤    at /tmp/shtUeyefYX line 1, column 11␤»

[20:59] <p6eval> ..rakudo 38165a: OUTPUT«===SORRY!===␤Cannot use 'anon' scope with a sub at line 1, near ")(5)"␤»

[20:59] <GlitchMr> First is global function which is instantly activated. Second is named anonymous function which is instantly activated.

[21:03] *** benabik left
[21:05] <flussence> nom: ((sub z($i) { return $i > 3 ?? $i !! z($i + 1) }).(1)); say &z.WHAT

[21:05] <p6eval> nom 38165a: OUTPUT«Sub()␤»

[21:05] <flussence> nom: {(sub z($i) { return $i > 3 ?? $i !! z($i + 1) }).(1)}; say &z.WHAT

[21:05] <p6eval> nom 38165a: OUTPUT«===SORRY!===␤Symbol '&z' not predeclared in <anonymous> (/tmp/vNgH2xLpWW:1)␤»

[21:08] <masak> technically, it was declared. you just can't see it in the current scope. :P

[21:08] *** GlitchMr left
[21:09] <masak> g'ah, I really missed #phasers today :/

[21:09] <flussence> (doesn't nom's parser keep a list of declared things somewhere? maybe that error message could be made nicer...)

[21:10] <masak> flussence: it probably could, but one would have to be careful to actually make the more helpful message more helpful :)

[21:11] *** localhost left
[21:13] *** localhost joined
[21:13] <sorear> niecza: (anon sub foo($n) { say $n; &?ROUTINE($n-1) if $n })(5)

[21:13] <p6eval> niecza v13-220-g0e6968c: OUTPUT«5␤4␤3␤2␤1␤0␤»

[21:14] <flussence> bah, there's always a better way than the one I come up with :)

[21:14] <sorear> I could make &foo visible inside foo easily enough

[21:14] <sorear> GlitchMr would -1 it; does anyone +1? :D

[21:16] <flussence> can't see a reason why not, +1

[21:16] *** skids left
[21:18] <masak> the only time it would be a nuisance is when there is already an outer &foo

[21:18] <sorear> how bouts we steal this feature, TimToady?

[21:18] <masak> and I don't really have a notion of what would be Least Surprise in this case ;)

[21:18] <flussence> hm, S02:2008 should be tweaked to say "names that only exist within that statement" or somesuch

[21:19] <masak> but yeah, it seems a cute variant of &?ROUTINE

[21:20] <arnsholt> What does the return value of ~~ s/// indicate?

[21:20] <arnsholt> On nom, it seems to return true regardless of match or not

[21:23] *** ocharles joined
[21:24] <sorear> arnsholt: on niecza - true if match, false if not

[21:27] *** y3llow left
[21:27] <[Coke]> niecza: use Test; is 1, 1|2, "junctive"

[21:27] <p6eval> niecza v13-220-g0e6968c: OUTPUT«not ok 1 - junctive␤# /tmp/dSuOYPCkia line 1␤#    Failed test␤#           got: 1␤#      expected: any(1, 2)␤»

[21:28] *** jupp left
[21:29] *** y3llow joined
[21:29] *** pothos joined
[21:30] <dalek> roast: 14c5d9a | coke++ | integration/advent2009-day02.t:

[21:30] <dalek> roast: fudge for niecza

[21:30] <dalek> roast: review: https://github.com/perl6/roast/commit/14c5d9a7e4

[21:30] <dalek> niecza: 6972b24 | coke++ | t/spectest.data:

[21:30] <dalek> niecza: run integration/advent2009-day02.t

[21:30] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6972b24df3

[21:30] <masak> nom: my $s = "foo"; say $s ~~s/oo/alalalala/

[21:30] <p6eval> nom 38165a: OUTPUT«Bool::True␤»

[21:30] <masak> nom: my $s = "foo"; say $s ~~s/uu/alalalala/

[21:30] <p6eval> nom 38165a: OUTPUT«Bool::True␤»

[21:30] <masak> well, that's useless.

[21:30] *** y3llow left
[21:31] <arnsholt> sorear: Yeah, that's sort of the behaviour I was expecting =)

[21:31] *** y3llow joined
[21:31] *** LlamaRider left
[21:32] *** pothos left
[21:32] <masak> niecza++

[21:32] *** pothos joined
[21:32] <arnsholt> Hmm. Let's see if I can't figure out how Rakudo does substitution

[21:33] *** y3llow left
[21:33] *** y3llow joined
[21:34] *** leprevost left
[21:35] *** pothos left
[21:35] *** snearch left
[21:35] *** pothos joined
[21:35] *** y3llow left
[21:35] *** y3llow joined
[21:37] <arnsholt> Heh. I always have to smile when I encounter the wonderful rule name blorst

[21:39] *** LlamaRider joined
[21:39] *** cognominal_ left
[21:40] <masak> :)

[21:40] <sorear> blast!

[21:41] *** cognominal joined
[21:41] <masak> it was once named "blast", yes.

[21:41] <sorear> still is, no?

[21:42] <sorear> STD.pm6 still has it as blast

[21:43] <LlamaRider> rakudo: our $a = 1; say $a; our @b = (1,2); say @b;

[21:43] <p6eval> rakudo 38165a: OUTPUT«1␤Method 'STORE' not found for invocant of class 'Any'␤  in block <anon> at /tmp/sVLCxKGx3m:1␤  in <anon> at /tmp/sVLCxKGx3m:1␤»

[21:43] <spine> MAIN(Int n) {

[21:43] <spine> oops

[21:43] <LlamaRider> what happened to 'our' and why is it only the case for arrays?

[21:44] *** molaf left
[21:44] <spine> MAIN(Int $n) {say $n+1} doesn't work in current rakudo

[21:44] <sorear> spine: that's because command line arguments are strings

[21:44] <spine> well, $n.WHAT says Int+{orig-string}()

[21:44] <LlamaRider> sorear: wait, what? It has been working for me perfectly fine.

[21:45] <spine> The output is 5, so somehow the addition fails

[21:45] <sorear> LlamaRider: ...I didn't reply to you?

[21:45] <sorear> spine: oh, strange then.  talk to japhb

[21:45] <sorear> LlamaRider: I'm confused now

[21:46] <LlamaRider> sorear: the MAIN (Int $n) is working well for me

[21:46] <sorear> I have no idea what's up with our in rakudo, but it certainly looks like a bug

[21:46] *** nebuchadnezzar left
[21:46] <arnsholt> nom: my $a = "foo"; say($a ~~ s/foo/bar/)

[21:47] <p6eval> nom 38165a: OUTPUT«Bool::True␤»

[21:47] *** nebuchad` joined
[21:47] <arnsholt> nom: my $a = "bar"; say($a ~~ s/foo/bar/)

[21:47] <p6eval> nom 38165a: OUTPUT«Bool::True␤»

[21:47] *** nebuchad` is now known as nebuchadnezzar

[21:47] <sorear> Do we have any tests for arnsholt's s/// bug or LlamaRider's our bug?

[21:47] * ocharles compiles rakudo star for the perl 6 competition

[21:47] <ocharles> exciting!

[21:48] <sorear> o/ ocharles

[21:48] <masak> ocharles: hello! :)

[21:48] <ocharles> hi :)

[21:48] <LlamaRider> ocharles: happy building :)

[21:48] <sorear> how old is your star?

[21:48] <ocharles> can't get it to build though

[21:48] <ocharles> "Failed to load libpcre" during Configure.pl

[21:48] <ocharles> not sure what's up with that, as I have libpcre installed (I'm on Gentoo)

[21:49] <sorear> Do you have libpcre-dev installed?

[21:49] <spine> sorear: thanks will do

[21:49] <masak> is it Parrot that needs libpcre?

[21:49] <ocharles> I think so

[21:50] <ocharles> it finally errors saying it can't find parrot_config

[21:50] <[Coke]> parrot can use libpcre, but doesn't require I, I think.

[21:50] <ocharles> so I assume --gen-parrot bit is failing. I just did a "make clean" in my parrot dir, maybe that'll help

[21:50] <ocharles> (I didn't have libpcre installed when I did my first run)

[21:50] <[Coke]> ocharles: Do you need star specifically, rather than the latest compiler release?

[21:50] <ocharles> I dunno, I just thought star was recommended

[21:50] <sorear> star USED to be recommended.

[21:51] <masak> star is fine, but latest nom has its merits too.

[21:51] <sorear> but it hasn't been updated in a year and a half.

[21:51] <masak> not to mention Niecza :)

[21:51] <ocharles> Neicza is .net right?

[21:51] <masak> sorear: um. surely there were Star releases in 2010.

[21:51] <sorear> right.

[21:51] <sorear> masak: this is 2012.

[21:51] <ocharles> yea, I'd rather like to avoid having to build mono

[21:51] <masak> sorear: um. surely there were Star releases in 2011.

[21:51] <sorear> And yet you're fine with having to build parrot.

[21:51] <sorear> :)

[21:51] <ocharles> sure

[21:52] <ocharles> smaller than mono :)

[21:52] <ocharles> I'll try with nom, maybe that works better..

[21:52] <sorear> masak: I wasn't told about them.  If anyone has more accurate info on star, that would be nice

[21:52] <masak> I wouldn't be surprised if you get the same libpcre error with nom. but it's worth a shot.

[21:52] <sorear> star: ;

[21:52] <p6eval> star 2011.04:  ( no output )

[21:52] <ocharles> masak: yea

[21:53] <sorear> ok, 8 months.

[21:53] <ocharles> I had star 2011.07

[21:53] <masak> ocharles: what's worse, I don't see you among the 35 registered for the Perl 6 Coding Contest...

[21:53] <ocharles> masak: I only decided on the train home :)

[21:53] <masak> oh :/

[21:53] <ocharles> I'll email when I complete the first challenge (which is sketched out on the back of an envelope next to me)

[21:53] <masak> the two weeks of registration are up :/

[21:53] <ocharles> oh

[21:54] <ocharles> oh well, might as well solve for fun :)

[21:54] <masak> that's the spirit :)

[21:54] <ocharles> though I'll probably just use haskell if I'm only getting solutions :P

[21:54] <sorear> hmm, I wonder what caused the setting to regress from 40s to 46s

[21:54] <arnsholt> Argh. I think fixing Rakudo will require some rewiring to fix this

[21:54] <masak> you're free to send me solutions (in any language) -- I'll be happy to read them.

[21:55] <LlamaRider> damn, rakudo started going crazy. Any hints how I can test MAIN through the chat bot? I can declare the sub, but how do I pass it an input parameter?

[21:55] <sorear> MAIN($x)

[21:55] <LlamaRider> yes, how do I provide a test value for $x via p6eval

[21:56] <sorear> rakudo: sub MAIN($x) { say $x }; MAIN(5)

[21:56] <p6eval> rakudo 38165a: OUTPUT«5␤Usage:␤  --setting=SAFE <x>␤»

[21:56] <LlamaRider> duh. lame question. thanks

[21:56] <masak> rakudo: sub MAIN($x) { say $x }; MAIN(5); exit

[21:56] <p6eval> rakudo 38165a: OUTPUT«5␤»

[21:56] <masak> :)

[21:56] <[Coke]> sorear: trying to add splice to CORE.setting: how do these lines look:

[21:56] <[Coke]> sub splice(@array, $offset = 0, $size?, *@values) is Niecza::builtin('splice', 1) { @array.splice($offset,$size,@values) }

[21:56] <[Coke]>     method splice( @array is rw: Int $offset = 0, Int $size?, *@values ) {

[21:57] <masak> 'night, #perl6

[21:57] <[Coke]> hurm. I think I should not have cargo culted the "is builtin"

[21:58] <sorear> Is there a .splice in List already?

[21:58] <arnsholt> sorear: Do you happen to remember roughly how niecza does substitution, off hand?

[21:58] <sorear> arnsholt: s/x/y/ becomes $_.subst(/x/, 'y', :inplace)

[21:58] <[Coke]> sorear: not in CORE.setting, anyway.

[21:59] <LlamaRider> sorear: ok, sorry, validated the command line bug for MAIN (Int $n). But I wonder how come it worked when I used it before oO...

[21:59] <arnsholt> Right.

[21:59] * arnsholt goes to dig into Rakudo's Str.pm

[22:00] <sorear> [Coke]: that definition of &splice is fine if you remove the builtin

[22:00] <sorear> you'll need to define List.splice, of course

[22:00] <LlamaRider> ha, I never did any operations to the value given, just used it for loop bounds. lucky me xD

[22:01] <[Coke]> ah, I was adding it to Array - I can move it up one.

[22:01] <spine> well I worked around it with my $m = 0+$n; for the moment

[22:02] <spine> $m is a normal int then, which wirks for any operations

[22:02] <ocharles> fwiw, nom builds fine :)

[22:03] <[Coke]> sorear: hurm. why on List and not Array?

[22:03] <sorear> [Coke]: Because List is the supertype

[22:04] <sorear> Niecza allows shift/push on List; why not splice?

[22:04] <sorear> or: consistency

[22:05] <[Coke]> fair enough.

[22:05] *** LlamaRider left
[22:05] *** LlamaRider joined
[22:07] *** LlamaRider left
[22:07] *** LlamaRider joined
[22:08] *** mj41 left
[22:08] <LlamaRider> spine: that's a good trick, well played :)

[22:09] <LlamaRider> after the last git pull on rakudo, my perfectly working t2 is now segfaulting for values >3 :((( worst luck ever

[22:16] *** ksi left
[22:17] <dalek> niecza: d330da0 | sorear++ | / (7 files):

[22:17] <dalek> niecza: Small refactor of source-position handling

[22:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d330da0939

[22:28] *** kaare_ left
[22:29] *** skids joined
[22:31] *** kaare_ joined
[22:33] <LlamaRider> can't isolate the segfault, when I remove (seemingly unrelated) patches of code, it allows me to go up to higher input values before crashing. But eventually crashes. Shockingly, if I remove a "say" statement in a loop it's completely gone.

[22:34] *** molaf joined
[22:35] <LlamaRider> anyway, good night. Segfaults are part of life :)

[22:35] *** LlamaRider left
[22:37] <sorear> What would people say if I made 'Any.new' illegal?

[22:40] *** kaare_ left
[22:40] <PerlJam> sorear: that's not very perlish 

[22:43] *** colomon left
[22:47] *** nornagest left
[22:49] *** spine left
[22:49] *** panterax left
[22:50] *** panterax joined
[22:52] *** panterax left
[22:53] *** Chillance left
[22:53] *** panterax joined
[22:59] *** localhost left
[23:00] *** alester left
[23:04] * sorear tries something very different

[23:04] <sorear> I've split the niecza setting up into 1000-character blocks and timed compilation of each one

[23:05] <sorear> &hyper, which falls almost exactly between two block boundaries, accounts for 2 seconds, 4% of compile time, 1% of the file

[23:15] *** cognominal left
[23:16] <sorear> ...

[23:16] *** cognominal joined
[23:16] <sorear> My poor excuse for a profiler has just informed me that the most called function in Niecza (9.8%) is ...

[23:16] <sorear> "ANON"

[23:17] <arnsholt> Heh. I'm sure that's a great help =)

[23:17] <arnsholt> How far down the long tail is the runner-up?

[23:18] <sorear> Str.ACCEPTS (3.8%)

[23:20] *** whiteknight joined
[23:21] <arnsholt> Not too bad, I suppose

[23:21] <arnsholt> But ANON is an aggregate of several lambdas I suppose?

[23:21] *** localhost joined
[23:21] * arnsholt supposes many things

[23:23] <sorear> Right, most likely

[23:23] *** cognominal left
[23:24] <TimToady> that might be yet another use for naming anonymous functions :)

[23:25] *** cognominal joined
[23:25] <TimToady> on having the name visible inside, seems like a win to me, and any sub decl has have set up the symbol table for the formal params by then anyway, so doesn't seem like a hardship

[23:32] <dalek> specs: 23e517f | larry++ | S02-bits.pod:

[23:32] <dalek> specs: allow anon name to be used for recursion

[23:32] <dalek> specs: review: https://github.com/perl6/specs/commit/23e517fc91

[23:41] *** PacoAir left
[23:41] <dalek> specs: be88f7f | larry++ | S02-bits.pod:

[23:41] <dalek> specs: be more accurate about anon in the table

[23:41] <dalek> specs: review: https://github.com/perl6/specs/commit/be88f7f8fd

[23:42] *** groky joined
[23:46] <sorear> aargh this is so frustrating... why is it so slow

[23:48] *** donri left
[23:53] *** raiph joined
[23:55] *** mtk left
