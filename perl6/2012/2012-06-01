[00:00] <TimToady> p6: https://gist.github.com/2847343

[00:00] <p6eval> pugs: OUTPUT«*** No such subroutine: "&temp"␤    at /tmp/5zc0Kon5ul line 5, column 9-25␤»

[00:00] <p6eval> ..rakudo b2068e: OUTPUT«[[], [], [2, 4]]␤[[2], [], [1, 4]]␤[[3, 4], [], [1, 2]]␤[[4], [], [1, 3]]␤»

[00:00] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«[[1, 2], [], [3, 4]]␤[[1, 3], [], [2, 4]]␤[[1, 4], [], [2, 3]]␤[[2, 3], [], [1, 4]]␤[[2, 4], [], [1, 3]]␤[[3, 4], [], [1, 2]]␤»

[00:00] <TimToady> rakudo doesn't seem to like --temp @mask[$k]

[00:01] <diakopter> phenny ask moritz what if rn: or nr: invoked both rakudo and niecza

[00:01] <diakopter> phenny ask sorear what if rn: or nr: invoked both rakudo and niecza

[00:02] <jnthn> TimToady: It looks weird to my eyes :P

[00:02] <TimToady> well, it doesn't like temp @mask[$k] -= 1 either

[00:02] <sorear> diakopter: you need more colons

[00:02] <jnthn> That surprises me a bit more.

[00:02] <diakopter> phenny: ask moritz what if rn: or nr: invoked both rakudo and niecza

[00:02] <phenny> diakopter: I'll pass that on when moritz is around.

[00:02] <jnthn> What does "doesn't like" mean?

[00:03] <TimToady> see output above

[00:03] <TimToady> niecza produces the correct output

[00:03] <jnthn> r: my $x = 2; { temp $x -= 1; say $x; }; say $x

[00:03] <p6eval> rakudo b2068e: OUTPUT«1␤2␤»

[00:03] <sorear> diakopter: I proposed r: n: syntax once.  I think I got assent but noone could be bothered to actually do it, including me

[00:04] <jnthn> r: my @x = 1,2,3; { temp @x[1] -= 1; say @x[1]; }; say @x[1]

[00:04] <p6eval> rakudo b2068e: OUTPUT«1␤2␤»

[00:04] <TimToady> jnthn: it might have more to do with the semantics of the @mask is copy parameter

[00:05] <sorear> I keep wanting to read that as @masak

[00:05] <jnthn> sorear: Same!

[00:05] <jnthn> TimToady: Maybe

[00:05] <TimToady> sorear: yer the one wrote @mask first!

[00:05] <jnthn> TimToady: I'm too tired to golf it righ tnow...

[00:06] <sorear> also, I am somewhat amused that the algorithm I came up with looks rather different from what everyone else is doing

[00:08] * jnthn -> sleep

[00:09] *** lestrrat left
[00:09] *** lestrrat joined
[00:10] *** cognominal_ joined
[00:13] *** cognominal left
[00:21] *** skids left
[00:26] *** cognominal joined
[00:28] *** cognominal_ left
[00:38] *** skids joined
[00:46] *** aesundstrom joined
[01:01] *** scott_ joined
[01:01] *** scott_ is now known as Guest48656

[01:05] *** vlixes joined
[01:05] *** aesundstrom left
[01:05] *** fgomez left
[01:08] *** thou left
[01:39] *** Guest65270 left
[01:45] *** fgomez joined
[01:46] *** tokuhiro_ joined
[02:10] *** vlixes left
[02:11] *** immortal joined
[02:11] *** immortal left
[02:11] *** immortal joined
[02:11] *** erkan left
[02:23] *** aesundstrom joined
[02:24] *** fgomez left
[02:26] * diakopter tries to golf it

[02:26] *** alvis joined
[02:28] <dalek> nqp: 0631f83 | duff++ | src/PAST/NQP.pir:

[02:28] <dalek> nqp: Add nqp::stat

[02:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0631f83778

[02:28] <dalek> nqp: 0d86ce0 | duff++ | src/PAST/NQP.pir:

[02:28] <dalek> nqp: Add nqp::does

[02:28] *** dalek left
[02:29] <diakopter> poor dalek

[02:29] *** dalek joined
[02:29] <dalek> rakudo/nom: 4aea135 | duff++ | src/ (2 files):

[02:29] <dalek> rakudo/nom: s/pir::stat\w+/nqp::stat/g

[02:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4aea1353bd

[02:29] <dalek> rakudo/nom: f4357fd | duff++ | src/ (4 files):

[02:29] <dalek> rakudo/nom: Use nqp::does

[02:29] *** dalek left
[02:29] <diakopter> poor dalek

[02:29] <diakopter> too triggery happ

[02:29] <diakopter> er

[02:29] <diakopter> trigger happy

[02:29] *** dalek joined
[02:29] *** ChanServ sets mode: +v dalek

[02:30] <diakopter> dalek: wb

[02:31] <diakopter> as I golf it, I'll just assume niecza's behavior is consistently correct, and as long as rakudo differs, I'm still golfing

[02:31] *** fgomez joined
[02:43] *** xinming left
[02:43] *** xinming joined
[03:00] *** tokuhiro_ left
[03:04] *** broquaint joined
[03:06] *** masonkramer left
[03:12] *** cognominal left
[03:22] *** aesundstrom left
[03:25] *** lestrrat left
[03:26] *** lestrrat joined
[03:28] <diakopter> TimToady: I golfed it

[03:28] <diakopter> rakudo's LEAVE blocks aren't called enough

[03:31] <diakopter> erm, I take that back

[03:31] <diakopter> still not sure

[03:53] *** odoacre joined
[03:55] *** am0c left
[04:06] <dalek> rakudo/nom: 696a71d | duff++ | docs/ (2 files):

[04:06] <dalek> rakudo/nom: Start on release announcement for June

[04:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/696a71d936

[04:46] *** estebann joined
[05:04] * TimToady wishes again that there were a .take form of take

[05:06] <TimToady> would make https://gist.github.com/2847343 a bit cleaner

[05:07] <PerlJam> you do wield the power of the spec  ;)

[05:08] <TimToady> well, .take already occurs twice in the spec

[05:08] <diakopter> TimToady: 

[05:08] <diakopter> r: https://gist.github.com/2848989

[05:08] <p6eval> rakudo 696a71: OUTPUT«c is 3 at depth 3␤c is 3 at depth 2␤c is 3 at depth 1␤»

[05:08] <TimToady> S02:4822 for instance

[05:09] <diakopter> n: https://gist.github.com/2848989

[05:09] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«c is 3 at depth 3␤c is 2 at depth 2␤c is 1 at depth 1␤»

[05:09] <diakopter> I golfed your golf

[05:10] <diakopter> niecza is right here, I assume

[05:10] <TimToady> yes

[05:10] *** woosley left
[05:10] *** woosley joined
[05:11] <diakopter> took me two hours of golfing, I dare confess.

[05:11] <TimToady> it's a good think you only dared to confess it, and didn't really confess it

[05:14] <diakopter> while sipping a frappucino listening to tinny music

[05:15] <diakopter> *frappuccino

[05:15] *** slavik1 left
[05:16] <TimToady> as long as you weren't listening to frappuccini

[05:16] *** birdwindupbird joined
[05:16] *** birdwind1pbird joined
[05:18] <diakopter> phenny: ask jnthn I golfed yer thingamabob. compare r: with n: https://gist.github.com/2848989

[05:18] <phenny> diakopter: I'll pass that on when jnthn is around.

[05:18] *** fhelmberger joined
[05:22] <diakopter> so you want .take to be a method on Mu?

[05:22] <diakopter> or a special form like .WHICH

[05:22] <diakopter> er

[05:22] <diakopter> whatever that uppercase special form is

[05:22] <TimToady> I don't see why it has to be that special

[05:23] * PerlJam is waiting on his compile with method take { take self } in Mu

[05:23] <TimToady> Take me! Take me!

[05:24] <dalek> rakudo/qrpa: 6e7868e | pmichaud++ | / (2 files):

[05:24] <dalek> rakudo/qrpa: QRPA: Add init, destroy, mark, elements, unshift_pmc, and some native variants.

[05:24] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/6e7868e12a

[05:24] <dalek> rakudo/qrpa: c42e429 | pmichaud++ | / (2 files):

[05:24] <dalek> rakudo/qrpa: Add defined_*, exists_*, and unshift_* for native types.

[05:24] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/c42e429d5d

[05:24] <dalek> rakudo/qrpa: 07ced37 | pmichaud++ | / (2 files):

[05:24] <dalek> rakudo/qrpa: QRPA:  Add clone, get_iter, splice.

[05:24] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/07ced374cc

[05:24] <dalek> rakudo/qrpa: f57053a | pmichaud++ | src/pmc/qrpa.pmc:

[05:24] <dalek> rakudo/qrpa: Add some useful optimizations.

[05:24] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/f57053acc7

[05:24] <diakopter> I'm surprised dalek didn't get booted for that outburst

[05:24] <PerlJam> whoa, someone left the Pm on tonight

[05:25] <TimToady> or the dalek is in wayback mode

[05:27] <pmichaud> it's the Pm

[05:28] <PerlJam> pmichaud: is that everything a RPA replacement needs?  It looks fairly complete.

[05:28] *** cognominal joined
[05:30] <pmichaud> I don't know if it's everything.  When I try to switch List to use it, though, I get some weird exceptions.  I'll work on it more tomorrow

[05:30] <TimToady> pmichaud++

[05:31] <pmichaud> There's certainly not much left to do if it's not complete.  It should be a *ton* more performant for queue-like operations, which is what Lists and iterators basically are

[05:31] <diakopter> tomorrow++

[05:31] <TimToady> mañana, mañana, I love you, mañana, you're always a day away...

[05:32] <pmichaud> I don't know why it didn't hit me before today that having a O(n) shift_pmc operation on RPA would be detrimental to our list model

[05:32] <pmichaud> I mean, I knew it at some level... but didn't really think it through properly.

[05:32] <diakopter> "tomorrow's just a future yesterday..." -Craig Ferguson song

[05:33] <TimToady> well, tomorrow is certainly unevenly distributed

[05:33] <TimToady> well, except at midnight on the date line

[05:35] <TimToady> I kinda think of iterator lists as Lisp cons lists with fancy car nodes for batched items

[05:35] <TimToady> s/batched/batched or delegated/

[05:36] <TimToady> but yeah, if it's expensive to shift, that's gonna bite

[05:36] <pmichaud> yes, I think of it conceptually that way also

[05:36] <pmichaud> (cons lists and car nodes)

[05:37] <pmichaud> anyway, the new shift code replaces the O(n) memmove function with a couple of integer ops

[05:37] <pmichaud> we also get some performance improvements in splice and unshift in the process

[05:37] <moritz> \o

[05:37] <phenny> moritz: 00:02Z <diakopter> ask moritz what if rn: or nr: invoked both rakudo and niecza

[05:37] <TimToady> o/

[05:38] <moritz> phenny: tell diakopter +1 to rn|nr

[05:38] <phenny> moritz: I'll pass that on when diakopter is around.

[05:38] <diakopter> o/

[05:38] <phenny> diakopter: 05:38Z <moritz> tell diakopter +1 to rn|nr

[05:38] <TimToady> maybe p5: should just do that, and reserve perl5: for "everyone"

[05:38] <pmichaud> hmmm, I remember "rn".  Once used that program quite a lot :)

[05:38] <TimToady> I've heard of that one

[05:39] <TimToady> code was pretty grotty, I hear....

[05:39] <diakopter> read news?

[05:39] * PerlJam mumbles something about being doomed to repeat rn

[05:39] <TimToady> sacrificed readability to get the bytes up on the screen faster...

[05:41] <TimToady> funny thing is that I dropped rn in order to work on Perl because I thought I might rewrite rn in Perl to be able to do bitwise ops on article ranges better...

[05:42] <TimToady> took a while before Perl got there though

[05:44] <diakopter> n: ++temp .say

[05:44] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Any()␤Internal error in exception dispatch: Writing to readonly scalar␤  at <unknown> line 0 (KERNEL Scalar.TEMP @ 0) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤»

[05:44] <diakopter> r: ++temp .say

[05:44] <p6eval> rakudo 696a71:  ( no output )

[05:45] <diakopter> on ho I feel a bout of fuzzing coming on

[05:45] <dalek> rakudo/nom: 50b77f3 | duff++ | src/core/Mu.pm:

[05:45] <dalek> rakudo/nom: Give TimToady .take

[05:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/50b77f3674

[05:45] <TimToady> now if only temp worked... :)

[05:46] <diakopter> n's error is cute

[05:46] <diakopter> writing to readonly scalar in exception dispatch?

[05:47] <diakopter> phenny: ask sorear try n: ++temp .say

[05:47] <phenny> diakopter: I'll pass that on when sorear is around.

[05:48] <diakopter> n: ++.say

[05:48] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Any()␤Unhandled exception: Writing to readonly scalar␤  at /tmp/wXR4TZRS2R line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3910 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (module-CORE @ 558) ␤  at /home/p6eval/niec…

[05:48] <diakopter> oh.

[05:50] <diakopter> r: say "alive"; my $a = let $a;

[05:50] <p6eval> rakudo 696a71:  ( no output )

[05:50] <diakopter> erm

[05:52] <diakopter> std: temp temp temp temp $_

[05:52] <p6eval> std f179a1b: OUTPUT«ok 00:00 41m␤»

[05:52] <dalek> roast: fcd46f4 | duff++ | S04-statements/gather.t:

[05:52] <dalek> roast: Added a test that uses .take

[05:52] <dalek> roast: review: https://github.com/perl6/roast/commit/fcd46f4382

[05:57] *** wtw joined
[05:58] <diakopter> well that's odd.

[05:58] <diakopter> rakudo just exits with no eror on that input

[05:58] <diakopter> errorlevel/exitcode 0

[05:59] *** kaleem joined
[05:59] <pmichaud> goodnight, all -- bbt

[05:59] <PerlJam> g'night pm

[06:04] * PerlJam didn't realize that p5p has also been talking about a 'safe deref' 

[06:05] <diakopter> PerlJam: did you merge nqp's pull request

[06:06] <PerlJam> no, I didn't.

[06:06] <PerlJam> Didn't know there was one.

[06:07] <diakopter> from kboga

[06:07] <diakopter> adding nqp defined and such

[06:07] <PerlJam> aye, I see it now

[06:07] <PerlJam> (I don't normally look at repos through the lens of github)

[06:07] *** estebann left
[06:07] <diakopter> hm it seems it conflicts with your commit

[06:08] <diakopter> since it can't automatically be merged

[06:08] <PerlJam> yeah, he used some slightly different names than I did

[06:23] *** am0c joined
[06:23] *** woosley left
[06:43] *** Entonian joined
[06:44] *** Entonian left
[06:45] <dalek> nqp: b1fb4b3 | kboga++ | / (16 files):

[06:45] <dalek> nqp: pir::defined to nqp::defined, pir::find_not_cclass__Iisii to nqp::findnotcclass, pir::find_method__PPs to nqp::findmethod

[06:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b1fb4b3098

[06:57] *** lestrrat left
[06:58] *** lestrrat joined
[07:03] *** brrt joined
[07:11] *** bbkr1 joined
[07:31] *** terrence joined
[07:35] *** immortal left
[07:35] *** erkan joined
[07:39] *** viji joined
[07:40] <viji> hi

[07:40] <moritz> hello viji 

[07:40] <brrt> hello viji

[07:40] <viji> Hello

[07:41] <viji> Hi guys, this is the first time joining

[07:42] <moritz> welcome to #perl6

[07:42] <brrt> i'm not going to repeat moritz :-) what brings you here?

[07:43] <viji> I really don't know where I can start up with

[07:44] <moritz> http://perl6.org/ has lots of good links

[07:44] <viji> I have around 4 years of working experience in perl

[07:44] <viji> Enthusiastic to explore more.

[07:45] <brrt> thats good :-)

[07:46] <brrt> but as a word of warning, perl6 is much unlike perl 5

[07:47] <brrt> if you expect to learn it as a 'new' language you should be fine.. if you expect an 'extended perl5' then you might not

[07:47] *** xinming left
[07:47] <viji> Ok, I think starting step would be to go through the perl6 documentation.

[07:48] <brrt> .. probably

[07:48] <brrt> there is a book

[07:48] <moritz> the starting step should be to install a Perl 6 compiler, rakudo or niecza

[07:48] <moritz> and then get the 'Using Perl 6' book (pdf download is free), and start to play with it

[07:48] *** kresike joined
[07:49] <kresike> morning all you happy perl6 people

[07:49] <brrt> small snippets of perl6 can also be sent to p6eval

[07:49] <brrt> (the irc bot)

[07:50] <brrt> as in:

[07:50] <brrt> p6: say 4 ~~ 1 .. 10;

[07:50] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«True␤»

[07:50] <p6eval> ..pugs: OUTPUT«␤»

[07:50] <moritz> r: say <hello hi greetings>.roll, ', viji'

[07:50] <p6eval> rakudo 50b77f: OUTPUT«hello, viji␤»

[07:50] <brrt> i do like the roll method

[07:51] *** woosley joined
[07:52] *** fgomez left
[07:54] <viji> When do you think full fledged perl6 version will be released.

[07:54] <brrt> the question of the beast :-)

[07:55] <brrt> personally i have no idea

[07:55] <brrt> perl6 is positively huge

[07:55] <brrt> (the specification)

[07:55] <brrt> but most of it is 'usable' right now in the form of rakudo star releases

[07:59] *** rafl joined
[08:00] <dalek> evalbot: 683d255 | moritz++ | evalbot.pl:

[08:00] <dalek> evalbot: install 'rn' and 'nr' aliases for rakudo+niecza

[08:00] <dalek> evalbot: 

[08:00] <dalek> evalbot: also refactor the aliasing mechanism to handle multiple implementations

[08:00] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/683d255c35

[08:00] <moritz> and niecza is often much faster at run time, though less of the ecosystem works with it

[08:01] <brrt> oh, btw

[08:01] <brrt> i was under the impression that 'nom' was the new 'master'?

[08:02] <moritz> well, the main development branch, yes

[08:02] <brrt> so the documentation on rakudo.org is just old?

[08:03] *** viji left
[08:03] <moritz> it might be

[08:03] <moritz> what does it say?

[08:04] <moritz> ah, it still has the 'How to get Rakudo nom' links

[08:06] * moritz removes it

[08:06] *** p6eval left
[08:06] *** p6eval joined
[08:06] *** ChanServ sets mode: +v p6eval

[08:06] <moritz> rn: say "fast at {<run compile>.pick} time"

[08:07] <moritz> hm, first executiong after restart taking ages again

[08:07] <moritz> I'd really like to know what's going on there

[08:07] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«fast at compile time␤»

[08:07] <brrt> hey, its fixed

[08:08] <brrt> rn: say "i'm quick"

[08:08] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«i'm quick␤»

[08:08] <brrt> thats much faster

[08:08] <moritz> curiously, I run two instances of p6eval, one for freenode, one for irc.perl.org

[08:08] <moritz> and only the freenode instance takes ages on the first execution

[08:16] *** lestrrat left
[08:18] *** lestrrat joined
[08:38] *** Khisanth joined
[08:42] <jnthn> morning o/

[08:42] <phenny> jnthn: 05:18Z <diakopter> ask jnthn I golfed yer thingamabob. compare r: with n: https://gist.github.com/2848989

[08:44] <jnthn> I'm very happy folks are jumping on the pir -> nqp effort. This one can't live though:

[08:44] <jnthn> https://github.com/perl6/nqp/commit/0d86ce0898d3a4e0e78549e84f69692a32fdfc9f

[08:45] <jnthn> That pir::does is nothing to do with 6model and calls down to Parrot's object system. Which we need to further eliminate our usage of, not abstract away.

[08:45] <moritz> fwiw I hadn't done 'pir::defined' => 'nqp::defined', because I thought that maybe the repr_defined thing might be a better match

[08:48] *** masonkramer joined
[08:55] <jnthn> moritz: Yeah, I was wondering what to do on that one.

[08:57] *** mucker joined
[09:00] *** sergot joined
[09:00] <sergot> hi o/ ! :)

[09:01] *** am0c left
[09:03] <moritz> \o sergot 

[09:18] <tadzik> hello #perl6

[09:19] <jnthn> o/ sergot, tadzik 

[09:23] *** kaleem left
[09:34] *** masonkramer left
[09:57] *** mucker left
[09:57] *** mucker joined
[10:02] *** mucker left
[10:05] *** mucker joined
[10:08] *** snearch joined
[10:10] *** woosley left
[10:18] *** birdwind1pbird left
[10:18] *** birdwindupbird left
[10:23] *** JimmyZ joined
[10:26] *** birdwindupbird joined
[10:26] *** birdwind1pbird joined
[10:28] *** snearch left
[10:28] *** Guest48656 left
[10:31] *** birdwind1pbird left
[10:31] *** birdwindupbird left
[10:46] *** birdwindupbird joined
[10:46] *** birdwind1pbird joined
[10:59] *** daxim joined
[11:01] *** ab5tract joined
[11:02] *** brrt left
[11:04] *** MichalWriter joined
[11:04] <MichalWriter> hello

[11:06] *** bbkr1 left
[11:07] <MichalWriter> Culd someone tell me where I can find some reliable history about perl6 and perl5, I would like to write some articles concerning How it came to being:) 

[11:10] *** kaleem joined
[11:14] <JimmyZ> hello MichalWriter, I think most people are not here now. 

[11:19] *** kboga left
[11:20] <gfldex> MichalWriter: you can read up on the early history here: blob.perl.org/perlweb/dev/perl6/talks/2001/dconway-Perl6.pdf

[11:21] <daxim> MichalWriter, http://strangelyconsistent.org/blog/happy-10th-anniversary-perl-6

[11:21] <daxim> and for perl 5:  http://history.perl.org/PerlTimeline.html http://perldoc.perl.org/perlhist.html https://socialtext.net/perl5/history  http://www.shlomifish.org/lecture/Perl/Newbies/vhll-slides.pdf

[11:24] *** MichalWriter left
[11:25] *** birdwindupbird left
[11:25] *** birdwind1pbird left
[11:26] *** kaleem left
[11:26] *** kaleem joined
[11:26] *** terrence left
[11:27] *** terrence joined
[11:27] *** cognominal left
[11:27] *** cognominal joined
[11:28] *** birdwindupbird joined
[11:33] *** birdwind1pbird joined
[11:37] *** snearch joined
[11:41] <pmichaud> good morning, #perl6

[11:42] <terrence> it's already evening in china :)

[11:43] * JimmyZ is in China :)

[11:43] <moritz> good am, pm

[11:47] <jnthn> o/ pmichaud 

[11:47] *** JimmyZ left
[11:47] *** JimmyZ joined
[11:48] <dalek> rakudo/qrpa: 02b5ec6 | pmichaud++ | src/Perl6/Actions.pm:

[11:48] <dalek> rakudo/qrpa: Add nqp::qlist() to obtain QRPA instead of RPA.

[11:48] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/02b5ec68be

[11:48] <dalek> rakudo/qrpa: f4373c6 | pmichaud++ | src/pmc/qrpa.pmc:

[11:48] <dalek> rakudo/qrpa: QRPA: Fix pointer typo in QRPA.clone.

[11:48] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/f4373c6192

[11:49] <moritz> so, how far along is qrpa?

[11:50] <pmichaud> the PMC itself I think is pretty much complete.  When I start trying to use it in List, though I get "WarningWarning" and everything stops.  I'm just starting to look into that now.

[11:50] <jnthn> Oh

[11:51] <jnthn> There's an islist op iirc

[11:51] <pmichaud> it checks directly for RPA?

[11:51] <jnthn> Yeah

[11:51] <jnthn> perl6_is_list

[11:51] <pmichaud> oh, if it's perl6_is_list I can probably do something with that

[11:52] <jnthn> I added it because I was tired of whatever was there before slowing down list guts.

[11:52] <jnthn> (Change based on profile data.)

[11:53] <pmichaud> yes, I'm also a little concerned that there may be other C code that is looking specifically for RPA 

[11:54] *** birdwindupbird left
[11:54] <dalek> roast: b1c5468 | moritz++ | S09-autovivification/autovivification.t:

[11:54] <dalek> roast: unfudge a few autovivification tests

[11:54] <dalek> roast: review: https://github.com/perl6/roast/commit/b1c54685a1

[11:54] <moritz> .. for rakudo.

[11:54] * moritz hates it when he fails to add information to commit messages, and finds out one second after 'git push'

[11:54] *** skids left
[11:55] *** krunen left
[11:55] <jnthn> pmichaud: the type mapping stuff does

[11:55] <jnthn> pmichaud: We may also need to teach the serializer about this new PMC.

[11:55] <jnthn> pmichaud: But that'll be very easy.

[11:55] <pmichaud> oh!

[11:55] <pmichaud> I forgot to write freeze/thaw

[11:55] <jnthn> ?

[11:56] <pmichaud> in qrpa

[11:56] <jnthn> Oh, bs doesn't use freeze/thaw

[11:56] <jnthn> You may get away with it :)

[11:56] *** birdwind1pbird left
[11:56] *** birdwindupbird joined
[11:57] *** birdwind1pbird joined
[12:01] <pmichaud> https://github.com/parrot/parrot/pull/778   # huh? wish parrot folks could make up their minds :-) :-)

[12:02] <moritz> *shrug* not much effort remove a .loadlib line...

[12:02] <felher> r: while True { say (0 but True); }

[12:02] <p6eval> rakudo 50b77f: OUTPUT«(signal ABRT)0␤0␤0␤0␤0␤0␤0␤0␤»

[12:02] <felher> :/

[12:02] <felher> But at least i golfed it down :D

[12:03] <pmichaud> [Coke]++  already noted that parrot went through a fair bit of effort to move the OS pmc to a dynpmc, now someone is moving it back.  Weird.

[12:03] <pmichaud> felher: maybe that's just Rakudo's way of refusing to do contrived code.  :-) :-)

[12:03] <moritz> r: say (0 but True);

[12:03] <p6eval> rakudo 50b77f: OUTPUT«0␤»

[12:04] <moritz> r: loop { say (0 but True); }

[12:04] <p6eval> rakudo 50b77f: OUTPUT«(signal ABRT)0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[12:04] <felher> pmichaud: :D

[12:04] <moritz> felher++ # golfing segfaults

[12:04] <jnthn> That's the same thing as the bool.t segv 

[12:04] <pmichaud> r: say (0 but True); say (0 but True); say (0 but True); say (0 but True); say (0 but True); say (0 but True); say (0 but True); say (0 but True); say (0 but True); 

[12:04] <p6eval> rakudo 50b77f: OUTPUT«(signal ABRT)0␤0␤0␤0␤0␤0␤0␤»

[12:05] <pmichaud> looks like it always occurs on the eighth one.

[12:05] <jnthn> It explodes during the GC run, I think.

[12:05] <jnthn> It's not clear why :/

[12:05] <moritz> r: for ^10 { say $_ but True }

[12:05] <p6eval> rakudo 50b77f: OUTPUT«(signal ABRT)0␤1␤2␤3␤4␤5␤6␤»

[12:06] <jnthn> I need to golf it further; "but" does quite a bit

[12:06] <felher> On my maschine i can say it ~~ 200 times :)

[12:06] <jnthn> Yeah, it's probabalistic-y.

[12:06] <jnthn> Such is heap corruption.

[12:06] <jnthn> It looks like it may be double-freeing of libtommath things

[12:06] <jnthn> (Almost certainly the fault of P6opaque or P6bigint though)

[12:11] * moritz is glad to have a reproducable case

[12:11] <moritz> it seems that I've occasionally run into segfaults that then went away when unrelated stuff changed

[12:11] <moritz> like the one in qbootstrap that went away when merged into nom

[12:12] <moritz> r: role A { }; say 0 but A for ^20

[12:12] <p6eval> rakudo 50b77f: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[12:12] <moritz> r: enum A <b c>; say 0 but A for ^20

[12:12] <p6eval> rakudo 50b77f: OUTPUT«(signal ABRT)0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤»

[12:14] <jnthn> r: say 0 but 'foo' for ^20

[12:14] <p6eval> rakudo 50b77f: OUTPUT«(signal ABRT)foo␤foo␤foo␤foo␤foo␤foo␤foo␤»

[12:14] <jnthn> r: say 'x' but 1 for ^20

[12:14] <p6eval> rakudo 50b77f: OUTPUT«x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤»

[12:14] <jnthn> r: say 'x' but 1 for ^2000

[12:14] <p6eval> rakudo 50b77f: OUTPUT«x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x␤x

[12:15] <jnthn> The target of the mixin has to be an Int.

[12:16] <moritz> and it needs to be not a role, but something else

[12:17] <jnthn> r: role A { }; say 0 but A for ^200

[12:17] <p6eval> rakudo 50b77f: OUTPUT«0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0␤0

[12:17] <jnthn> Hmm.

[12:18] *** ab5tract left
[12:20] *** nwc10 joined
[12:21] *** xinming joined
[12:26] *** birdwind1pbird left
[12:26] *** birdwindupbird left
[12:26] *** birdwindupbird joined
[12:27] *** birdwind1pbird joined
[12:31] *** replore joined
[12:32] *** fgomez joined
[12:35] *** snearch left
[12:53] <[Coke]> +# 05/31/2012 - rakudo++ (22355); niecza (91.47%); pugs (34.66%)

[12:54] <dalek> rakudo/qrpa: cf75879 | pmichaud++ | src/ops/perl6.ops:

[12:54] <dalek> rakudo/qrpa: QRPA:  Update nqp::islist to be QRPA-aware.

[12:54] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/cf7587996f

[13:02] *** birdwindupbird left
[13:03] *** snearch joined
[13:04] *** birdwind1pbird left
[13:08] *** wtw left
[13:10] *** Patterner left
[13:12] *** Psyche^ joined
[13:12] *** Psyche^ is now known as Patterner

[13:13] *** replore left
[13:14] *** kaleem left
[13:17] *** replore_ joined
[13:19] *** kaleem joined
[13:22] *** kaleem left
[13:24] <dalek> rakudo/qrpa: 725acab | pmichaud++ | / (2 files):

[13:24] <dalek> rakudo/qrpa: QRPA:  Add QRPA.get_number().

[13:24] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/725acab27f

[13:24] <dalek> rakudo/qrpa: 94483a2 | pmichaud++ | / (2 files):

[13:24] <dalek> rakudo/qrpa: QRPA: Add QRPA.get_bool, get_bool and get_number tests.

[13:24] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/94483a2888

[13:25] *** terrence left
[13:28] *** thou joined
[13:31] *** skids joined
[13:31] *** terrence joined
[13:34] *** kaleem joined
[13:36] <dalek> nqp: bfea0f7 | duff++ | / (15 files):

[13:36] <dalek> nqp: Use new nqp ops

[13:36] <dalek> nqp: 

[13:36] <dalek> nqp: nqp::defined, nqp::typeof, nqp::rindex, nqp::find_not_cclass, nqp::open,

[13:36] <dalek> nqp: nqp::new, nqp::isa, nqp::find_method, nqp::does, nqp::stat

[13:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bfea0f7975

[13:37] <pmichaud> Hmmm.... I'm not sure there should be a nqp::new

[13:37] <pmichaud> actually, I'm not comfortable with several of those.

[13:38] <moritz> nqp::defined is a bit suspicious because it's the parrot defined that's tested, not the repr thingy

[13:38] <pmichaud> right

[13:38] <pmichaud> these are all too parrot-specific to be in the nqp:: space.

[13:38] <moritz> and find_not_cclass depends on parrot-specific constants

[13:38] <pmichaud> I'm going to request that one be reverted.

[13:38] <moritz> find find_method violates the 'no underscore' principle

[13:38] <moritz> that we held up so far

[13:38] <pmichaud> This is bringing the nqp:: namespace waaaaaaay too close to parrot.

[13:39] <moritz> PerlJam: please revert :-)

[13:39] <pmichaud> I also want those nqp:: opcodes to go away.  If we're doing something Parrot specific, then pir:: is the proper place.

[13:39] <pmichaud> the nqp:: space should be reserved only for those things that are going to be vm-independent.

[13:40] <moritz> +1

[13:41] *** isBEKaml joined
[13:41] <pmichaud> for example, the correct way to verify type in NQP is by using nqp::istype, not nqp::typeof

[13:42] <jnthn> arrrghh...please everybody stop doing the nqp ops!!!

[13:42] <pmichaud> yes, these are very wrong.

[13:42] <jnthn> I'm going to have to revert half of this. 

[13:42] <pmichaud> well, someone needs to revert it, yes.

[13:42] <jnthn> I want Parrot specific things taht I want to kill left looking Parrot specific.

[13:43] <pmichaud> right -- see above

[13:43] <pmichaud> 13:39 <pmichaud> I also want those nqp:: opcodes to go away.  If we're doing something Parrot specific, then pir:: is the proper place.

[13:43] <jnthn> Right.

[13:43] <pmichaud> jnthn: out of curiosity, why did you add nqp::can, though?

[13:44] <jnthn> pmichaud: Because nqp::can makes sense at a 6model level.

[13:44] <pmichaud> as in, 6model properly implements vtable can?

[13:44] <jnthn> pmichaud: Think so, but even looking to VMs beyond Parrot, I would want an nqp::can

[13:44] <moritz> r: nqp::say pir::defined(Int)

[13:44] <p6eval> rakudo 50b77f: OUTPUT«0␤»

[13:45] <moritz> r: nqp::say pir::defined(1)

[13:45] <p6eval> rakudo 50b77f: OUTPUT«1␤»

[13:45] <jnthn> pmichaud: The alternative is to just expose an nqp::findmethod and then use nqp::isnull on the result or something

[13:45] <moritz> it also seems that it implements the defined vtable :-)

[13:45] <jnthn> pmichaud: But it's just too common.

[13:45] <jnthn> moritz: It does...but I'm not too happy on that.

[13:45] <pmichaud> I'm fine if there's an nqp::can, as long as it's consistent with 6model objects

[13:45] <moritz> jnthn: I know

[13:45] <pmichaud> for example, we also have nqp::clone which is the same way

[13:46] <jnthn> pmichaud: clone I'm not happy with at the moment

[13:46] <jnthn> pmichaud: 6model does not handle the clone vtable

[13:46] <jnthn> pmichaud: There's a representation level clone operation.

[13:46] <pmichaud> okay, so that one we might need some work on.

[13:46] <jnthn> The problem we have at the moment is that half the things are 6model-y and half are not.

[13:46] <pmichaud> Anyway,  new/defined/typeof/etc all have to go.

[13:46] <jnthn> In NQP land, that is.

[13:46] <jnthn> Indeed.

[13:47] *** mucker left
[13:47] <jnthn> I appreciate the effort and intent behind these patches, but nqp:: needs careful design, not to be the same mess pir:: is.

[13:48] *** felher left
[13:48] <pmichaud> right... the purpose is not to simply make the word "pir" go away but keep all of its warts.

[13:48] *** crazedpsyc left
[13:48] <jnthn> *nod*

[13:48] *** crazedpsyc joined
[13:48] <moritz> so, we're all in violent agreement

[13:49] <jnthn> :)

[13:49] <moritz> and just have to tell PerlJam++ and kboga++

[13:49] <jnthn> Aye.

[13:49] <pmichaud> well, except the commits haven't been reverted yet.  :-)

[13:49] *** crazedpsyc is now known as Guest29889

[13:49] <jnthn> Note that a bunch of the commits were OK

[13:49] <jnthn> This latest one not, but kboga++ did many pir -> existing nqp ops that were sensible.

[13:49] <pmichaud> as opposed to a full-scale revert, I propose simply removing the nqp:: opcodes we disagree with and then patch things to work again :-)

[13:50] <jnthn> +1

[13:50] *** felher joined
[13:50] <nwc10> I don't see any comment in src/PAST/NQP.pir explaining this policy

[13:50] <nwc10> (the policy makes total sense to me. But that's not saying much, as I'm likely very out of context)

[13:51] <jnthn> pmichaud: Hah! Guess how many gigabytes of RAM this allocates?

[13:51] <jnthn> my $string = 'x' x 30000;

[13:51] <jnthn> my @matches = $string.match(/./, :global);

[13:51] <jnthn> :)

[13:51] *** terrence left
[13:51] * jnthn thinks he knows why too :)

[13:51] <pmichaud> no guess

[13:51] <jnthn> 4GB!

[13:51] <pmichaud> only 4?

[13:52] <jnthn> Exhaust all the 32-bit address space :)

[13:52] <jnthn> pmichaud: It's transcoding to ucs4 for every single match

[13:52] <jnthn> pmichaud: And then keeping target around in the Cursor

[13:52] <moritz> ouch

[13:52] <jnthn> So we end up with 30000 * 4 * 30000 :)

[13:52] <jnthn> r: say 30000 * 4 * 30000 

[13:52] <p6eval> rakudo 50b77f: OUTPUT«-694967296␤»

[13:53] <jnthn> uh :)

[13:53] <moritz> r: say 30000 * 4 * (30000)

[13:53] <jnthn> Also, the optimizer needs to be smacked...

[13:53] <p6eval> rakudo 50b77f: OUTPUT«3600000000␤»

[13:53] <pmichaud> I can certainly release $!target at the end, if that's not being done already.

[13:53] <jnthn> pmichaud: Or !cursor_init gets a :target to set it explicitly? (more)

[13:53] <pmichaud> but really things improve greatly when our native string type can handle fixed-width unicode natively

[13:54] <jnthn> I'm also bothered that LANG suffers the same thing.

[13:54] <nwc10> when smacking the optimiser, I'm not sure if there is a mathematically reliable way to determine whether integer multiply has overflowed

[13:54] <jnthn> That is, every time we hit a regex in CORE.setting compilation, for example, we do a LANG switch, and re-transcode the entire of CORE.setting.

[13:55] <jnthn> That's probably part of why S05-mass/rx.t apparently takes an age to compile too :)

[13:55] *** Guest29889 is now known as crazedpsyc

[13:55] <flussence> jnthn: is that a new bug or something that's always been there?

[13:55] <moritz> nwc10: oh, there is

[13:56] <moritz> nwc10: just do the computation in bigint land

[13:56] <moritz> nwc10: and look if the result can safely be unboxed

[13:56] <jnthn> flussence: It's been there a while...it's over-eager "make it native"

[13:56] <isBEKaml> and suffer the penalty of boxing types. :)

[13:56] <isBEKaml> s/of/for/

[13:57] <flussence> one of my biggest gripes right now is how slow string munging is in rakudo. maybe I won't have anything to complain about soon :)

[13:57] <moritz> nwc10: alternatively, on the CPU level the result of a multiplication is always twice as wide, so you can just look at the upper half to detect overflow

[13:57] <pmichaud> jnthn: I agree that LANG is an issue; I'm not sure that :target is the right answer.

[13:58] <pmichaud> I'll think about it a bit today, though.  That one needs solving soon-ish.

[13:58] <jnthn> pmichaud: Ah, your suggestion may not help for the /./ case above (more)

[13:58] <nwc10> moritz: I'm not convinced about that.

[13:58] <jnthn> pmichaud: We can easily release $!target if we know we won't backtrack into the thing again, but for normal regexes I guess backtracking is enabled.

[13:59] <nwc10> moritz: oh, you can in the upper half, if you have a multiply that's twice as wide, available for you to use

[13:59] <pmichaud> well, that's as much a problem with the implementation of :global as anything else then

[14:00] <moritz> nwc10: is there any modern instruction set where that's not the case?

[14:00] <nwc10> I don't know. I tend to think "what can C give you?"

[14:00] * colomon keeps on thinking this would be a fun Niecza project: http://www.makershed.com/Getting_Started_with_Netduino_Kit_p/msgsn.htm?Click=37845

[14:00] <nwc10> also, if you are already using 64 bit integers on a 64 bit machine, no good idea

[14:00] <moritz> nwc10: C can't. The CPU can.

[14:01] <jnthn> .oO( Some assembly required )

[14:01] <moritz> anyway, we have a bigint library available

[14:02] <jnthn> For constant folding that works out fine

[14:02] <jnthn> I think TimToady expects our native multiply to throw if it overflows, though...

[14:02] <moritz> aye :(

[14:02] <moritz> and I think then it's not 'native' anymore :/

[14:02] <jnthn> I did try to argue that :)

[14:03] <nwc10> but overflow as wrap isn't useful to anyone

[14:03] <pmichaud> can the native multiply simply do nextsame on overflow?

[14:03] <moritz> uhm

[14:04] <jnthn> nwc10: Yes, but C performance is useful to many people ;)

[14:04] <moritz> you can only do really efficient calculations with natives if you can determine at compile time that the return type is a native one

[14:04] <jnthn> What moritz said

[14:04] <moritz> and a nextsame means that you always potentially get a boxed Int back

[14:05] <moritz> so you need one GCable per operation :(

[14:05] <jnthn> Right. Then the optimizer can't inline the next operation.

[14:05] <nwc10> jnthn: yes. Although for some, advice from Klortho #11912 seems to be the key part. :-(

[14:05] *** SHODAN left
[14:06] <pmichaud> well, clearly 30000 * 4 * 30000  as optimized is less good than if the optimization wasn't there.

[14:06] <moritz> I'm fine with never overlflowing operations from literals

[14:06] <pmichaud> that *has* to be fixed somehow.

[14:06] <jnthn> Agreed

[14:06] <moritz> but if the programmer explicitly requests native types, he should get them, with all the problems they have

[14:06] <jnthn> But we should actually be constant folding that in the first place, I suspect

[14:06] <moritz> pmichaud: I don't think anybody contests that

[14:06] <pmichaud> same if we have   my int $a = 30000;  my int $b = 4;   $a * $b * $a

[14:07] <pmichaud> r:  my int $a = 30000;  my int $b = 4;   say $a * $b * $a

[14:07] <p6eval> rakudo 50b77f: OUTPUT«-694967296␤»

[14:07] <jnthn> pmichaud: There you've declared you're working in native types.

[14:07] <moritz> and native types overflow.

[14:07] <jnthn> pmichaud: If you didn't declare it then yeah, big integer semantics.

[14:07] *** SHODAN joined
[14:07] <pmichaud> r:  my int $a = 30000;   say $a * foo() * $a

[14:07] <p6eval> rakudo 50b77f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&foo' called (line 1)␤»

[14:08] <pmichaud> oops

[14:08] <pmichaud> but you get the point -- how do I know how foo() was declared?

[14:08] <moritz> by looking it up in a lexical scope

[14:09] <jnthn> r:  my int $a = 30000; sub foo() { 4 };  say $a * foo() * $a

[14:09] <p6eval> rakudo 50b77f: OUTPUT«3600000000␤»

[14:09] <moritz> one approach that could work is to default literals to the non-native type

[14:09] <jnthn> r:  my int $a = 30000; sub foo() returns int { 4 };  say $a * foo() * $a

[14:09] <p6eval> rakudo 50b77f: OUTPUT«Type check failed for return value; expected 'int' but got 'Int'␤  in sub foo at /tmp/fWPl9Tddb4:1␤  in block <anon> at /tmp/fWPl9Tddb4:1␤␤»

[14:09] <jnthn> Ah...that that bit is NYI...

[14:09] <moritz> and allow unboxing when assigning them to natively-type variables

[14:09] <jnthn> moritz: That could work, yes

[14:10] <moritz> r:  my int $a = 30000; sub foo() returns int { nqp::unbox_i(4) }; say $a * foo() * $a

[14:10] <p6eval> rakudo 50b77f: OUTPUT«Type check failed for return value; expected 'int' but got 'Int'␤  in sub foo at /tmp/cLOezGpqiw:1␤  in block <anon> at /tmp/cLOezGpqiw:1␤␤»

[14:10] <pmichaud> what happens with   $a + 1, then?

[14:10] <pmichaud> is the 1 boxed or unboxed?

[14:10] <moritz> that would be boxed in my proposal

[14:10] <pmichaud> so do we not get the    infix:<+>(int,int) version?

[14:10] <jnthn> pmichaud: Right now, it emits that as an (already unboxed) 1

[14:10] <jnthn> pmichaud: And then we hit the int,int version

[14:11] <pmichaud> jnthn: right, I'm asking about what happens in moritz' proposal

[14:11] <jnthn> pmichaud: It'd have to unbox the 1 every time, iiuc.

[14:11] <jnthn> pmichaud: Which doesn't seem desirable, but isn't an allocation at least...

[14:12] <nwc10> Oh, confident that you can be sure they won't overflow if both values are less than the square root of the largest permissble value. (ie fit in 16 bits, if you have a 32 bit multiply, etc)

[14:12] <moritz> at some point we'll realize that you can't have speed, safety *and* magic (all boxing/unbox implicit)

[14:18] <pmichaud> afk for a bit

[14:18] <pmichaud> somewhere QRPA is causing a segfault :-|

[14:21] *** fhelmberger left
[14:21] *** PacoAir joined
[14:22] <pmichaud> back again, I think I know where the error(s) may be

[14:22] <pmichaud> yup

[14:25] <dalek> rakudo/qrpa: eadaa34 | pmichaud++ | src/pmc/qrpa.pmc:

[14:25] <dalek> rakudo/qrpa: QRPA:  Restore the custom_mark_destroy flags that were in init().  Oops.

[14:25] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/eadaa34679

[14:27] <jnthn> :)

[14:28] *** tokuhiro_ joined
[14:33] <dalek> rakudo/qrpa: c5b2ca2 | jnthn++ | src/binder/types.c:

[14:33] <dalek> rakudo/qrpa: Ensure the type mapper knows how to map a QRPA to Parcel.

[14:33] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/c5b2ca293c

[14:33] <jnthn> pmichaud: Did ^^ for you :)

[14:33] <tadzik> argh. Is it just me, or every train reservation website around is absolutely terrible?

[14:34] <moritz> I can certainly attest that the German one is

[14:34] <isBEKaml> that's supposedly a *feature* :P Train journey's *supposed* to be terrible

[14:35] <tadzik> well, a roundtrip air ticket from WAW to SXB almost exceeds my monthly salary... ;)

[14:35] *** domidumont joined
[14:35] <tadzik> or maybe I fail at searching again

[14:35] * moritz generally likes travelling by train, as compared to its alternatives

[14:36] <tadzik> trains, when done right, are pretty cool

[14:36] * colomon wishes traveling by train was even occasionally a sane move in North America

[14:36] <moritz> tadzik: which days do you want to travel?

[14:36] <tadzik> leg room, electricity, no wireless communication limitations, almost seamless movement (compared to buses for example)

[14:36] <tadzik> moritz: I was thinking about 28 June - 2 July

[14:37] <tadzik> or something of this sort

[14:37] <tadzik> there is supposed to be a train from WAW to Karlsruhe, EuroNight

[14:38] <moritz> tadzik: 334 EUR wound trip

[14:38] <tadzik> ugh

[14:38] <tadzik> thanks. Where did you find that?

[14:38] <moritz> http://www.swoodoo.com/de/flugsuche/Warschau-Strassburg-WAW-SXB-2012-06-28-0-0-0/Strassburg-Warschau-SXB-WAW-2012-07-02-0-0-0/1/E/0#details:916e0f0d0dc6f2f3d7b961a8a755891e

[14:39] <tadzik> oh, that's even flugzug

[14:40] <isBEKaml> phenny: flugzug?

[14:40] <tadzik> phenny: "flugzug"?

[14:40] <phenny> tadzik: "Flugzug" (de to en, translate.google.com)

[14:41] <tadzik> phenny: "flugzeug"?

[14:41] <phenny> tadzik: "plane" (de to en, translate.google.com)

[14:42] <pmichaud> wow, after that last fix only four spectest files fail with qrpa

[14:42] <moritz> isBEKaml: train to the airport

[14:43] <tadzik> I guess I'll go with a bus again :)

[14:43] <jnthn> pmichaud: Oh, we're using qrpa?

[14:43] <jnthn> pmichaud: I didn't see the thing to enable use of it in the branch.

[14:43] *** adu joined
[14:43] <pmichaud> I haven't committed/pushed those

[14:43] <isBEKaml> moritz: ah, okay. 

[14:43] <jnthn> Oh :)

[14:43] <pmichaud> and I'm only using it in one place at the moment

[14:43] <jnthn> 4 spectests feels rather triagable.

[14:44] <tadzik> but then I'll have to skip one of my exams :/

[14:44] <pmichaud> well, considering it was a lot more an hour ago, I'm happy.

[14:44] <jnthn> moritz: Are you ging to FPW?

[14:45] <pmichaud> I'll go ahead and push the other qrpa changes now.  I'm not really planning to do a branch merge with this branch, tho -- it's just to explore how well it works.  When things work out, qrpa will move to nqp and I'll cherry-pick items back into the nom branch

[14:45] <moritz> jnthn: no

[14:45] <jnthn> pmichaud: ah, ok

[14:46] <jnthn> Makes sense.

[14:50] *** fgomez left
[14:51] *** kaleem left
[14:57] *** cognominal_ joined
[15:00] *** cognominal left
[15:00] *** fgomez joined
[15:00] *** GlitchMr joined
[15:00] <diakopter> nr: my $a=1; { temp $a=2; temp $a=3 }; say $a # golfed further

[15:00] <p6eval> rakudo 50b77f: OUTPUT«2␤»

[15:00] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«1␤»

[15:01] <GlitchMr> perl6: my @s = 1, 2, 3; print (@s.pick(*)while![<=]@s).perl

[15:01] <p6eval> rakudo 50b77f: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')'␤»

[15:01] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "while"␤    expecting term postfix, operator or ")"␤    at /tmp/JuMtco5ee7 line 1, column 35␤»

[15:01] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Two terms in a row (listop with args requires whitespace or parens) at /tmp/8sKRgHCYeV line 1:␤------> s = 1, 2, 3; print (@s.pick(*)while![<=]⏏@s).perl␤␤Parse failed␤␤»

[15:01] *** fhelmberger joined
[15:01] <GlitchMr> perl6: my @s = 1, 2, 3; @s.pick(*)while![<=]@s; print @s

[15:01] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Two terms in a row (listop with args requires whitespace or parens) at /tmp/lAbnJe5yOR line 1:␤------> my @s = 1, 2, 3; @s.pick(*)while![<=]⏏@s; print @s␤␤Parse failed␤␤»

[15:01] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "@s"␤    expecting dot, ":", "(", term postfix or operator␤    at /tmp/C3cCawZ54u line 1, column 38␤»

[15:01] <p6eval> ..rakudo 50b77f: OUTPUT«===SORRY!===␤Confused␤at /tmp/RjUH_wCcGe:1␤»

[15:01] <GlitchMr> ok...

[15:01] <moritz> GlitchMr: but whitespaces between terms and infix operators

[15:01] <moritz> s/but/put/

[15:01] <moritz> GlitchMr: and also between terms and keywords

[15:01] <GlitchMr> I know

[15:02] <diakopter> nr: my @s = 1, 2, 3; @s.pick(*)while![<=] @s; print @s

[15:02] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«123»

[15:02] <jnthn> hah, calling temp twice in the same block :)

[15:02] <GlitchMr> I was just checking how it worked for that guy: http://codegolf.stackexchange.com/a/398/3103

[15:02] <GlitchMr> But I think it's because it was working long time ago

[15:02] *** cognominal___ joined
[15:02] <jnthn> s/block/scope/

[15:03] <diakopter> jnthn: I think it's the same problem as the the recursed temp

[15:03] <diakopter> I mean, it makes sense that the fix for one would fix the other one

[15:03] <moritz> r: my @s = 3, 1, 2;  @s=.pick(*) while ![<=]@s

[15:03] <p6eval> rakudo 50b77f: OUTPUT«===SORRY!===␤Confused␤at /tmp/m1WV6gUHYl:1␤»

[15:03] <moritz> r: my @s = 3, 1, 2;  @s=.pick(*) while ![<=] @s

[15:03] <p6eval> rakudo 50b77f:  ( no output )

[15:03] <moritz> r: my @s = 3, 1, 2;  @s=.pick(*) while ![<=] @s; say @s

[15:03] <p6eval> rakudo 50b77f: OUTPUT«use of uninitialized value of type Any in string context  in block <anon> at /tmp/_6_WKViX2L:1␤␤␤»

[15:03] <pmichaud> I'm getting a test failure in nqp/qregex

[15:04] <moritz> pmichaud: I think I also got one last I ran those tests

[15:04] <moritz> pmichaud: something about an error message being off

[15:04] * jnthn thought he'd fixed everything at one point...

[15:04] <diakopter> it's been there a week or more

[15:04] <moritz> r: my @s = 3, 1, 2;  @s=.pick(*) until [<=] @s; say @s

[15:04] <p6eval> rakudo 50b77f: OUTPUT«use of uninitialized value of type Any in string context  in block <anon> at /tmp/p4M4zQFOuI:1␤␤␤»

[15:04] <colomon> there's a method form of take?

[15:04] <moritz> r: my @s = 3, 1, 2;  @s.=pick(*) until [<=] @s; say @s

[15:04] <p6eval> rakudo 50b77f: OUTPUT«1 2 3␤»

[15:05] <moritz> r: my @s = 3, 1, 2;  @s.=pick:* until [<=] @s; say @s

[15:05] <p6eval> rakudo 50b77f: OUTPUT«===SORRY!===␤Confused␤at /tmp/dLHiRUPaE0:1␤»

[15:05] <diakopter> colomon: PerlJam added it to Mu last night

[15:05] <moritz> r: my @s = 3, 1, 2;  @s.=pick: * until [<=] @s; say @s

[15:05] <TimToady> \o/ bogosort

[15:05] <p6eval> rakudo 50b77f: OUTPUT«1 2 3␤»

[15:05] <GlitchMr> I've already optimized it into @s.=pick(*)until[<=] @s

[15:05] <moritz> GlitchMr++

[15:05] *** cognominal_ left
[15:05] <colomon> diakopter: why?

[15:06] <GlitchMr> I've noticed that even while he called it "code golf", it wasn't really optimized

[15:06] <jnthn> colomon: I think there was some discussion of it in the backlog

[15:06] <diakopter> colomon: because TimToady said it was already mentioned a couple times in the syn

[15:06] *** tokuhiro_ left
[15:07] <dalek> nqp: 69d548e | jnthn++ | / (17 files):

[15:07] <dalek> nqp: Toss various nqp:: ops that are too Parrot-specific.

[15:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/69d548ecb9

[15:07] <GlitchMr> Bogosort is really easy to implement in Perl 6.

[15:07] <GlitchMr> But I really like this:

[15:07] <GlitchMr> [min] @array

[15:08] *** fhelmberger left
[15:09] <pmichaud> or even  @array.min  :-)

[15:09] <GlitchMr> Oh right

[15:09] <colomon> jnthn, diakopter, TimToady: I see "(Using the term "label" loosely, to include other solutions besides the label syntax, such as .gather and .take methods on some identity object.)" which seems to be the opposite of what has been implemented.

[15:09] <GlitchMr> There is more than one way to do it

[15:09] <GlitchMr> Or:

[15:09] <GlitchMr> min @array

[15:10] <GlitchMr> Why "min" is operator anyways?

[15:10] <TimToady> so you can compose it more ways

[15:11] <TimToady> $x min= 42

[15:11] <moritz> r: say <42 -3 4>.min

[15:11] <p6eval> rakudo 50b77f: OUTPUT«-3␤»

[15:11] <TimToady> @a Zmin @b

[15:11] <colomon> or @x >>min<< @y

[15:11] <pmichaud> @a >>min<< @b

[15:11] <TimToady> Xmin has to be good for something...

[15:12] <pmichaud> I think that Xmin is some sort of league of mutant heroes or something like that.  :-P

[15:12] <tadzik> ;)

[15:12] <benabik> A very small league.

[15:12] <GlitchMr> What about Xmax?

[15:12] <diakopter> a minimal size league

[15:12] <tadzik> small step for humanity

[15:12] <tadzik> or from humanity...

[15:13] <isBEKaml> oh, they are not humans at all.... 

[15:13] <GlitchMr> And what about Xminmax?

[15:13] <TimToady> Perl 6 will be done by Xmax

[15:13] <GlitchMr> So it's no longer Xmas, but Xmax?

[15:14] <diakopter> 'twas a joke's eve

[15:14] <GlitchMr> Also, I'm not sure, but what is the difference between ..., !!! and ???

[15:15] <pmichaud> jnthn: I was going to reject nqp::findmethod altogether

[15:15] <TimToady> fail, die, warn

[15:15] <pmichaud> jnthn: if you're comfortable with keeping it, though, I'm okay with that.

[15:15] <jnthn> pmichaud: What do you plan to replace it with?

[15:15] <timotimo> how far are the perl6es to get debuggers?

[15:15] <jnthn> pmichaud: I'm not thrilled with the name.

[15:15] <pmichaud> jnthn: what's the p6 equivalent?

[15:15] <jnthn> pmichaud: But I don't ahve a better one.

[15:15] <GlitchMr> rakudo: ???; print 3

[15:15] <p6eval> rakudo 50b77f: OUTPUT«Stub code executed  in block <anon> at /tmp/3H9AgrnreJ:1␤␤3»

[15:15] <GlitchMr> rakudo: !!!; print 3

[15:15] <p6eval> rakudo 50b77f: OUTPUT«Stub code executed␤  in block <anon> at /tmp/I8sb6gaoa2:1␤␤»

[15:16] <GlitchMr> niecza: ???; print 3

[15:16] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: >>>Stub code executed␤  at /tmp/sLonKb0Ywp line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3910 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (module-CORE @ 558) ␤  at /home/p6eval/niecza/lib/CORE…

[15:16] <jnthn> pmichaud: There kinda ain't one...you'd really do $obj.^find_method('blah')

[15:16] <jnthn> pmichaud: But that skips the method cache

[15:16] <GlitchMr> Makes sense

[15:16] <pmichaud> I'm fine with findmethod for now, then

[15:16] <jnthn> pmichaud: In Perl 6 a bunch of the cases we use it for are covered by things like $obj.Foo::bar(), $obj."$foo"(), etc. too

[15:16] <pmichaud> the nice thing about an ugly name is that we don't have many qualms with changing it later :)

[15:16] <jnthn> OK

[15:16] <TimToady> looks like niecza isn't trapping the ??? warning right

[15:17] <pmichaud> jnthn: oh, and ARGGGGGH   your patch conflicts with mine :-)

[15:17] <pmichaud> jnthn: you *just* beat me to the push

[15:17] <jnthn> oy noes! 

[15:17] <pmichaud> I'll adopt yours and fold my changes in

[15:18] <GlitchMr> At least Git is somewhat clever about changes happening while you modify your code.

[15:18] <jnthn> :)

[15:18] <jnthn> pmichaud: I've got a Rakudo patch to do similar cleanup almost done

[15:18] <pmichaud> usually, yes.  In this case jnthn++ and I were both making almost identical changes

[15:18] <pmichaud> jnthn: I'm only changing src/PAST/NQP.pir; I'll let others (you) take care of the rest :)

[15:19] <kresike> bye all

[15:19] *** kresike left
[15:19] <GlitchMr> You can make branches and merges usually work.

[15:19] <jnthn> pmichaud: Oh, I did :)

[15:19] <pmichaud> jnthn: I'm going to list the explicitly rejected opcodes in PAST/NQP.pir (and we can comment them out or make them throw exceptions at some point)

[15:20] <pmichaud> that way someone else will hopefully not be tempted to do the same thing again, and also to note that there are some opcodes that we don't want

[15:20] <jnthn> pmichaud: +1

[15:21] <pmichaud> and if we set them to throw exceptions we can use those to point to the correct opcode

[15:21] <dalek> nqp: 365eda1 | jnthn++ | src/HLL/Compiler.pm:

[15:21] <dalek> nqp: Toss a method that assumes Parrot namespaces, and is unused.

[15:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/365eda13d2

[15:21] <pmichaud> Heh.  That method was actually an early version of PDD31.

[15:21] <jnthn> Oh :)

[15:21] <GlitchMr> I guess that it will be possible to make bad code in Perl 6?

[15:22] <pmichaud> GlitchMr: and not only that, but there will be more than one way to do so.

[15:22] <GlitchMr> But good code will be possible too?

[15:22] <jnthn> You don't even have to be talented to make bad code in Perl 6! :)

[15:23] <jnthn> In fact, if you can make bad code in any other language, you're perfectly qualified!

[15:23] <pmichaud> Of course.  There's a ton of good code in Perl 6.  :-)

[15:23] <jnthn> ;)

[15:23] <TimToady> what we hope is that it will be harder to make bad code by accident when you're trying to make good code

[15:24] <GlitchMr> I guess that because of this, Perl 5 will be more useful for golf except for certain cases (bogosort).

[15:25] <TimToady> Perl 6 is not optimized for golf, 'tis true.

[15:26] <dalek> rakudo/nom: abd4abf | jnthn++ | / (15 files):

[15:26] <dalek> rakudo/nom: Eliminate some uses of nqp:: opcodes that we've outlawed.

[15:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/abd4abfbe1

[15:26] <GlitchMr> But who would use Bogosort if in worst case it's O(∞).

[15:26] <jnthn> Optimists :)

[15:26] <TimToady> nonetheless, the typical Perl 6 solution might still be smaller than the typical Perl 5 solutions

[15:27] <jnthn> pmichaud: Cleared up nqp:: bits in Rakudo now too :)

[15:27] <GlitchMr> Default "use strict" makes things more difficult for code golf.

[15:27] <GlitchMr> And many edge cases simply don't exist in Perl 6.

[15:28] <GlitchMr> perl6: print so (True but False)

[15:28] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«False»

[15:28] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VBool False to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[15:28] <GlitchMr> perl6: print True but False

[15:28] <p6eval> rakudo 50b77f: OUTPUT«False»

[15:28] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«True»

[15:28] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VBool False to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[15:28] <GlitchMr> What should be result of this?

[15:29] <TimToady> mass confusion, obviously :)

[15:30] <TimToady> I'd like to hear arguments from both camps as to why their answer is correct.  :)

[15:31] <GlitchMr> What True but False should be on stringify?

[15:31] <TimToady> but this is too near the boolean circularity saw for me to rush in

[15:31] <GlitchMr> perl6: print False but True

[15:31] <p6eval> pugs: OUTPUT«*** Cannot cast from VBool True to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[15:31] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«False»

[15:31] <p6eval> ..rakudo 50b77f: OUTPUT«True»

[15:31] <GlitchMr> perl6: print so (False but True)

[15:31] <p6eval> pugs: OUTPUT«*** Cannot cast from VBool True to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[15:31] <p6eval> ..rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«True»

[15:31] <GlitchMr> Makes sense

[15:32] <TimToady> now nr is available to leave pugs out

[15:32] <TimToady> nr: say False but True

[15:32] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«False␤»

[15:32] <p6eval> ..rakudo 50b77f: OUTPUT«True␤»

[15:32] <GlitchMr> I'm not sure, but I think that "False but True" should retrun "False" on stringify

[15:33] <jnthn> TimToady: The Rakudo store on this is almost certainly tied to how unboxing works in 6model

[15:33] <colomon> nr++

[15:33] <jnthn> *story

[15:33] <jnthn> TimToady: It might be a moderate pain to change.

[15:34] <GlitchMr> nr: print False but role { method Bool() { return True } }

[15:34] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«False»

[15:34] <p6eval> ..rakudo 50b77f: OUTPUT«True»

[15:34] <jnthn> Right, that's what "False but True" desugars to.

[15:34] <colomon> TimToady: I dunno, I kind of thing Pugs is right here....

[15:35] <GlitchMr> nr: print +(42 but ("string", False))

[15:35] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«string»

[15:35] <p6eval> ..rakudo 50b77f: OUTPUT«No such method 'specialize' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in <anon> at src/gen/Metamodel.pm:2125␤  in <anon> at src/gen/Metamodel.pm:2121␤  in any compose at src/gen/Metamodel.pm:2119␤  in any mixin at src/gen/Metamodel.pm:959␤  in sub infix:<…

[15:36] <colomon> nr: print +(42 but 42.1)

[15:36] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«42»

[15:36] <GlitchMr> ... haven't I asked to use it in numeric context?

[15:36] <colomon> nr: print (42 but 42.1).Rat

[15:36] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«42.1»

[15:36] <jnthn> I don't even know what you just tried to do :)

[15:36] *** SatoAmbush joined
[15:36] <colomon> nr: print (42 but 42.1).Real

[15:36] *** SatoAmbush left
[15:36] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Unable to resolve method Real in type Int+{Rat}␤  at /tmp/sqAdiKZZ0f line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3910 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (module-CORE @ 558) ␤  at /h…

[15:36] <p6eval> ..rakudo 50b77f: OUTPUT«42»

[15:37] <colomon> nr: print 42.Real

[15:37] <p6eval> rakudo 50b77f: OUTPUT«42»

[15:37] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Unable to resolve method Real in type Int␤  at /tmp/Usz_FtpvF9 line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3910 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (module-CORE @ 558) ␤  at /home/p6…

[15:37] <colomon> whoops

[15:38] <cognominal___> jthn, will we eventually have a way to dump parse trees of Perl 6 programs? It is currently broken.

[15:38] <cognominal___> it has been for a while.

[15:38] *** cognominal___ is now known as cognominal

[15:38] <GlitchMr> nr: so (42 but (True, False))

[15:38] <p6eval> niecza v18-1-gc86e3f0:  ( no output )

[15:38] <p6eval> ..rakudo 50b77f: OUTPUT«No such method 'specialize' for invocant of type 'Perl6::Metamodel::ClassHOW'␤  in <anon> at src/gen/Metamodel.pm:2125␤  in <anon> at src/gen/Metamodel.pm:2121␤  in any compose at src/gen/Metamodel.pm:2119␤  in any mixin at src/gen/Metamodel.pm:959␤  in sub infix:<…

[15:38] <GlitchMr> niecza: print so (42 but (True, False))

[15:38] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«False»

[15:38] <GlitchMr> False?

[15:39] <colomon> n: say (42 but (True, False).WHAT

[15:39] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Unable to parse parenthesized expression at /tmp/c2wgkjEZZF line 1:␤------> say (⏏42 but (True, False).WHAT␤Couldn't find final ')'; gave up at /tmp/c2wgkjEZZF line 1 (EOF):␤------> say (42 but (True, …

[15:39] <colomon> n: say (42 but (True, False)).WHAT

[15:39] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Int+{Bool},{Bool}()␤»

[15:40] <dalek> niecza: ea3d97a | (Solomon Foster)++ | lib/CORE.setting:

[15:40] *** adu left
[15:40] <dalek> niecza: Add Mu.take.  (Not 100% convinced it is a good idea, but it is in spec and roast and was dead easy to do.)

[15:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ea3d97a8c5

[15:40] <dalek> roast: d1bba41 | (Solomon Foster)++ | S04-statements/gather.t:

[15:40] <dalek> roast: Fix test not to use .munch and unfudge it for Niecza.

[15:40] <dalek> roast: review: https://github.com/perl6/roast/commit/d1bba41f2e

[15:42] <pmichaud> I'm a little uncomfortable that the method form calls the sub form there, fwiw.  (Not uncomfortable enough to say it ought to be changed... but it feels a little backward.)

[15:42] <GlitchMr> nr: print ('cake' does Int(42)).perl

[15:42] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Cannot use 'does' operator with an immutable object␤  at /home/p6eval/niecza/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1340 (infix:<does> @ 8) ␤  at /tmp/owdWM82qWp line 1 (mainline @ 3) ␤  at …

[15:42] <p6eval> ..rakudo 50b77f: OUTPUT«Cannot mix in non-composable type Int into object of type Str␤  in sub infix:<does> at src/gen/CORE.setting:11057␤  in block <anon> at /tmp/4TOkNoHvHW:1␤␤»

[15:43] <PerlJam> Ah ... good $localtime all.

[15:43] <PerlJam> Sorry about the trouble.  (I read the scrollback already)

[15:43] <pmichaud> np, we're fixing it :)

[15:43] <pmichaud> I'm adding references to nqp-opcode.txt in the NQP.pir file, too.

[15:44] * PerlJam promises not to be so bull-in-china-shop in the future  :)

[15:44] <GlitchMr> perl6: print 'e' == 'f' # I know that I should use eq or ===

[15:45] <p6eval> pugs: OUTPUT«1»

[15:45] <p6eval> ..rakudo 50b77f: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏e' (indicated by ⏏)␤  in method Numeric at src/gen/CORE.setting:9309␤  in sub infix:<==> at src/gen/CORE.setting:2451␤  in sub infix:<==> at src/gen/CORE.setting:2451␤  in bloc…

[15:45] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Cannot parse number: e␤  at /home/p6eval/niecza/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3473 (ANON @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3475 (NumSyntax.str2num @ 5) ␤  at /ho…

[15:45] <dalek> nqp: d63dec6 | pmichaud++ | / (2 files):

[15:45] <dalek> nqp: Update notes about rejected nqp:: operations -- no functional changes.

[15:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d63dec6bae

[15:45] <GlitchMr> Error messages are good enough :)

[15:46] <GlitchMr> perl6: package Cake

[15:46] <p6eval> pugs:  ( no output )

[15:46] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Unable to parse package definition at /tmp/GQNd69W3sI line 1 (EOF):␤------> package Cake⏏<EOL>␤␤Parse failed␤␤»

[15:46] <p6eval> ..rakudo 50b77f: OUTPUT«===SORRY!===␤Unable to parse $*PKGDECL definition at line 2, near ""␤»

[15:46] <GlitchMr> perl6: package Cake;

[15:46] <p6eval> pugs:  ( no output )

[15:46] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Semicolon form of package definition indicates a Perl 5 module; unfortunately,␤  STD doesn't know how to parse Perl 5 code yet at /tmp/OLoHUC7sPW line 1:␤------> package Cake⏏;␤␤Parse failed␤␤»…

[15:46] <p6eval> ..rakudo 50b77f: OUTPUT«===SORRY!===␤This appears to be Perl 5 code. If you intended it to be Perl 6 code, please use a Perl 6 style package block like "package Foo { ... }", or "module Foo; ...". at line 2, near ""␤»

[15:47] <GlitchMr> Parsing Perl 5 code doesn't look hard if you want to also run it... but there may be problems like "wantarray".

[15:47] <colomon> About gather / take -- it seems like there are a lot of cases which are better documented in the spec than method .take, but don't appear in roast at all.  Like take-rw.  Or the value returned by take.

[15:47] <dalek> rakudo/nom: 0f9975c | jnthn++ | src/Perl6/World.pm:

[15:47] <dalek> rakudo/nom: Fix typo spotted by diakopter++.

[15:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f9975c782

[15:48] <GlitchMr> return wantarray ? @a : "@a"

[15:48] <GlitchMr> Perl 6 doesn't have wantarray, am I right?

[15:48] <tadzik> right

[15:48] <jnthn> Right.

[15:48] <jnthn> It does context the opposite way around to Perl 5.

[15:48] <GlitchMr> The way which makes more sense?

[15:49] <TimToady> makes more sense for Perl 6 :P

[15:49] <GlitchMr> But this could be problem when dealing with Perl 5 code, but I'm sure that some way will be found.

[15:49] <jnthn> Well, the Perl 6 way makes more sense when your language also has multiple dispatch :)

[15:50] *** cognominal left
[15:50] *** cognominal joined
[15:51] <dalek> rakudo/nom: 1886ee9 | pmichaud++ | src/core/Parcel.pm:

[15:51] <dalek> rakudo/nom: Use nqp::shift($rpa) instead of $rpa.shift.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1886ee9525

[15:52] <GlitchMr> http://paste.uk.to/52dd9a4d

[15:52] <GlitchMr> This could be a problem...

[15:52] <GlitchMr> If Perl 5 code would work in Perl 6, wantarray would have to be implemented.

[15:53] <diakopter> s/wantarray/lots/

[15:53] <moritz> there could be syntax for explicitly calling a p5 routine in a certain context

[15:55] <Juerd> p5list(...)

[15:55] <pmichaud> I suspect wantarray in that context would end up returning 'false' or throwing an exception :-)

[15:56] <pmichaud> or, if we know that we're calling a p5-sub, then perhaps context becomes available again.

[15:56] <pmichaud> (since there's no multisub involved)

[15:57] <pmichaud> just speculatin

[15:58] <GlitchMr> perl6: print (* * *)(3, 4)

[15:58] <p6eval> pugs: OUTPUT«*** Cannot cast from VNum Infinity to VCode (VCode)␤    at /tmp/p6MsxpKrYy line 1, column 7 - line 2, column 1␤»

[15:58] <p6eval> ..rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«12»

[15:59] <moritz> rn: print (* * *)(3, 4)

[15:59] <p6eval> rakudo 50b77f, niecza v18-1-gc86e3f0: OUTPUT«12»

[15:59] <Juerd> wantwantarray

[15:59] <pmichaud> jnthn: (binder/types.c)  I've been thinking that we might use  QRPA_is_list()  (or some other global function) throughout rather than constantly looking up qrpa_id and doing a test for == qrpa_id and == enum_class_ResizablePMCArray

[16:00] <GlitchMr> Why * is used for that anyways

[16:00] <pmichaud> I'm fine if we call it nqp_islist(), too.

[16:00] <jnthn> pmichaud: +1

[16:00] <GlitchMr> But well, ok, $ would be too confusing

[16:00] <GlitchMr> $ * $ would confuse everybody

[16:00] *** nwc10 left
[16:01] <pmichaud> GlitchMr: "*" is often used in a "wildcard" sense

[16:01] <pmichaud> e.g., in filename globs and the like

[16:01] <pmichaud> so it somewhat makes sense as the marker for "Whatever"

[16:01] <GlitchMr> Single * is whatever

[16:01] <GlitchMr> But when connected to some operator, it's closure

[16:02] <pmichaud> it's actually a WhateverClosure :)

[16:02] <pmichaud> rn:   say (* * *).WHAT

[16:02] <p6eval> rakudo 50b77f: OUTPUT«WhateverCode()␤»

[16:02] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«{ ... }␤»

[16:02] <pmichaud> er, WhateverCode.  Whatever.  :)

[16:03] <GlitchMr> It reminds me Python's lambda keyword... except more simple to use.

[16:03] <GlitchMr> And less flexible, but if you want flexibility there is sub {} and -> {}

[16:03] <GlitchMr> And of course, $^a

[16:05] <TimToady> nr: https://gist.github.com/2847343

[16:05] <p6eval> rakudo 50b77f: OUTPUT«Cannot call 'push'; none of these signatures match:␤:(Any:U \$self, *@values, Mu *%_)␤␤  in method push at src/gen/CORE.setting:1169␤  in block <anon> at /tmp/0067Ejdx1Q:6␤  in method reify at src/gen/CORE.setting:5045␤  in method reify at src/gen/CORE.setting:4940…

[16:05] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«[[1, 2], [], [3, 4]]␤[[1, 3], [], [2, 4]]␤[[1, 4], [], [2, 3]]␤[[2, 3], [], [1, 4]]␤[[2, 4], [], [1, 3]]␤[[3, 4], [], [1, 2]]␤»

[16:05] <GlitchMr> niecza: http://paste.uk.to/52dd9a4d

[16:05] <p6eval> niecza v18-2-gea3d97a: OUTPUT«===SORRY!===␤␤Confused at /tmp/vRp9bOTtNq line 1:␤------> http⏏://paste.uk.to/52dd9a4d␤␤Undeclared routine:␤ 'http' used at line 1␤␤Parse failed␤␤»

[16:05] <GlitchMr> ok, expected :P

[16:06] <GlitchMr> It's not possible to implement every single pastebin ever invented

[16:07] <dalek> rakudo/nom: 6365270 | jnthn++ | src/core/operators.pm:

[16:07] <dalek> rakudo/nom: Make let/temp cope sanely with temp'ing/let'ing the same variable twice.

[16:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/636527047f

[16:08] <pmichaud> afk, errands

[16:08] *** fgomez left
[16:08] <dalek> roast: 38cc5b7 | diakopter++ | S04-blocks-and-statements/temp.t:

[16:08] <dalek> roast: test recursive nested and multiple temps; rakudo will need these fudged unless jnthn++ fixes them soon

[16:08] <dalek> roast: review: https://github.com/perl6/roast/commit/38cc5b7dd0

[16:08] <dalek> roast: c3b1c0e | diakopter++ | / (3 files):

[16:08] <dalek> roast: Merge branch 'master' of git://github.com/perl6/roast

[16:08] <dalek> roast: review: https://github.com/perl6/roast/commit/c3b1c0ea66

[16:09] <dalek> roast: 4f873a6 | diakopter++ | S04-blocks-and-statements/temp.t:

[16:09] <dalek> roast: increment plan twice

[16:09] <dalek> roast: review: https://github.com/perl6/roast/commit/4f873a6496

[16:11] <diakopter> rn: https://gist.github.com/2853248

[16:11] <p6eval> niecza v18-2-gea3d97a: OUTPUT«ok 1 - recursive nested temps are restored properly␤ok 2 - multiple temps in the same scope are restored properly␤»

[16:11] <p6eval> ..rakudo 50b77f: OUTPUT«not ok 1 - recursive nested temps are restored properly␤#      got: '3'␤# expected: '1'␤not ok 2 - multiple temps in the same scope are restored properly␤#      got: '2'␤# expected: '1'␤»

[16:12] *** jaldhar left
[16:15] *** fgomez joined
[16:17] *** GlitchMr left
[16:17] *** replore_ left
[16:20] *** aesundstrom joined
[16:22] <diakopter> moritz++ nr|rn

[16:25] *** spider-mario joined
[16:26] *** Vlavv_ joined
[16:30] *** aesundstrom left
[16:38] <TimToady> diakopter: jnthn's patch appears to fix test 2 but not test 1

[16:40] <diakopter> oh

[16:40] *** daxim left
[16:41] <jnthn> They're separate issues.

[16:41] <jnthn> I suspect the recursion one is actually about LEAVE phasers more generally too.

[16:53] *** not_gerd joined
[16:54] <not_gerd> jnthn: my cleanup branch got finally merged, so no mor --intval="long long" on Windows

[16:57] <jnthn> \o/

[16:57] <jnthn> not_gerd++

[17:02] *** spaceships joined
[17:03] <JimmyZ> not_gerd++ indeed

[17:04] <not_gerd> JimmyZ++ for making the merge happen

[17:05] <JimmyZ> github++, click merge button is very easy :P

[17:07] *** JimmyZ left
[17:16] *** Chillance joined
[17:30] <sorear> good * #perl6

[17:30] <phenny> sorear: 05:47Z <diakopter> ask sorear try n: ++temp .say

[17:30] *** majrmovies joined
[17:31] *** brrt joined
[17:32] <pmichaud> back from errands, lunch

[17:33] <dalek> rakudo/qrpa: e2a9ed3 | pmichaud++ | src/core/List.pm:

[17:33] <dalek> rakudo/qrpa: Switch List.gimme to initialize $!items with QRPA.

[17:33] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/e2a9ed3636

[17:34] <dalek> rakudo/qrpa: 4fc8fa0 | pmichaud++ | src/core/Parcel.pm:

[17:34] <dalek> rakudo/qrpa: Use nqp::shift($rpa) instead of $rpa.shift().

[17:34] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/4fc8fa0304

[17:43] *** colomon joined
[17:44] <sorear> o/ colomon, majrmovies

[17:44] <colomon> \o

[17:49] <colomon> sorear: what do you think of the idea of a Mu.take method?

[17:50] <dalek> nqp/altnfa: 32d6a49 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[17:50] <dalek> nqp/altnfa: Start saving per-alternation NFAs.

[17:50] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/32d6a493b6

[17:50] <dalek> nqp/altnfa: 1aa896e | jnthn++ | src/QRegex/NFA.nqp:

[17:50] <dalek> nqp/altnfa: Split merging part of mergesubrules out into mergesubstates.

[17:50] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/1aa896e3cf

[17:50] <dalek> nqp/altnfa: 72fc431 | jnthn++ | src/QRegex/Cursor.nqp:

[17:50] <dalek> nqp/altnfa: Sketch out alternation NFA running.

[17:50] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/72fc431415

[17:52] <sorear> colomon: it's a little strange to have Mu.take but not Mu.return

[17:52] *** birdwindupbird joined
[17:52] <sorear> colomon: but I see nothing technically wrong with it

[17:52] <colomon> sorear: logical, but I fear it just means even more Mu methods!  ;)

[17:53] <sorear> Mu methods are cheap

[17:54] <colomon> easy to implement, for sure, but they do pollute the entire P6 class namespace once they are there.

[17:55] *** kaare_ joined
[17:56] <sorear> so do Cool and Any methods, and we have a million of those.

[17:56] <colomon> Cool methods only pollute cool classes; by default user-defined classes don't get them.

[17:57] <colomon> sorear: btw, what's your take on Mu.take-rw?  (It's not implemented or spec'd anywhere so far as I know.)

[17:57] <colomon> actually, gotta go for a few minutes, but will backlog

[17:58] *** colomon left
[17:58] <sorear> Also not technically problematic.

[18:05] *** majrmovies left
[18:08] <pmichaud> down to two failing spectest files, both likely due to changes in nom not folded into the qrpa branch.

[18:08] *** colomon joined
[18:08] *** majrmovies joined
[18:10] <dalek> rakudo/qrpa: 80d406d | pmichaud++ | src/ (3 files):

[18:10] <dalek> rakudo/qrpa: QRPA:  Update binder to know about QRPA as well as RPA.

[18:10] <dalek> rakudo/qrpa: Now almost everything passes with the simple nqp::qlist change,

[18:10] <dalek> rakudo/qrpa: now to spread it more widely throughout List and ListIter

[18:10] <dalek> rakudo/qrpa: and see if anything breaks.

[18:10] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/80d406de39

[18:10] <awwaiid> pmichaud++ # failing (less) spectests ftw

[18:16] *** am0c joined
[18:17] *** mtk left
[18:17] *** thou left
[18:20] <dalek> rakudo/qrpa: 2ef6948 | pmichaud++ | src/core/List (2 files):

[18:20] <dalek> rakudo/qrpa: Migrate more nqp::list -> nqp::qlist for testing.

[18:20] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/2ef6948355

[18:22] <dalek> specs: 8f29a46 | diakopter++ | S02-bits.pod:

[18:22] <dalek> specs: 5

[18:22] <dalek> specs: review: https://github.com/perl6/specs/commit/8f29a46cdb

[18:23] *** thou joined
[18:27] *** mtk joined
[18:28] *** thou left
[18:31] *** adu joined
[18:33] *** thou joined
[18:34] *** cognominal left
[18:35] *** cognominal joined
[18:38] <dalek> nqp/altnfa: 51c3726 | jnthn++ | src/ops/nqp.ops:

[18:38] <dalek> nqp/altnfa: Add an op for pushing a label onto a label stack.

[18:38] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/51c372640f

[18:38] <dalek> nqp/altnfa: fbb1811 | jnthn++ | src/QRegex/Cursor.nqp:

[18:38] <dalek> nqp/altnfa: Use NFA run results to push marks for possible branches onto the bstack.

[18:38] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/fbb1811f5d

[18:38] <dalek> nqp/altnfa: c774ec8 | jnthn++ | src/QAST/Compiler.nqp:

[18:38] <dalek> nqp/altnfa: Update QAST::Compiler's alt handling to use LTM. The NQP it builds will actually parse enough to try an 'aa' ~~ /a|\w+/ style example and get it right! However, it chokes right after a semicolon...thus failing all the tests.

[18:38] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/c774ec8b85

[18:38] *** cognominal left
[18:40] *** cognominal joined
[18:40] <brrt> or, how do i call a VTABLE something on a PMC?

[18:40] <brrt> because i can call methods

[18:41] *** thou left
[18:41] <sorear> channel?

[18:41] <brrt> very much so

[18:41] <brrt> sorry :-)

[18:44] <pmichaud> huh.  Just switching to use qrpa makes things a bit slower (0.05sec on $N == 100000) than before

[18:44] <pmichaud> that's.... a little surprising.  maybe something pathological going on somewhere

[18:45] * pmichaud tries with $N == 1000000

[18:45] <jnthn> That's a little surprising.

[18:46] <pmichaud> yes, for $N == 1000000  I get 13.278 (nom)   versus 13.964 (qrpa)

[18:46] *** thou joined
[18:56] <pmichaud> yeah, the more things I convert to QRPA, the slower the 1..1000000 test gets.  Something must be slowing things down somewhere.

[18:56] <pmichaud> I wonder if it's the GET_ATTR_* stuff being slower

[18:58] *** snearch left
[18:58] <pmichaud> or maybe   new $P0, "QRPA" takes significantly longer than new $P0, "ResizablePMCArray"

[18:59] *** alester joined
[19:02] <pmichaud> new $P0, "QRPA" seems faster than new $P0, "ResizablePMCArray"

[19:02] <pmichaud> (about 3%)

[19:02] <pmichaud> so....

[19:03] <pmichaud> get_pmc_keyed(_int) is slower

[19:04] <pmichaud> that would explain it.

[19:06] *** not_gerd left
[19:22] *** thou left
[19:23] *** kaare_ left
[19:28] *** thou joined
[19:32] <pmichaud> http://gist.github.com/2854610   # get_pmc_keyed_int speed, qrpa versus rpa

[19:32] <pmichaud> now to figure out why

[19:36] * jnthn back

[19:37] <jnthn> r: say 0.3 / 0.42

[19:37] <p6eval> rakudo 636527: OUTPUT«0.714286␤»

[19:39] <pmichaud> http://gist.github.com/2854662   # qrpa code

[19:39] <pmichaud> http://gist.github.com/2854676   #  rpa code

[19:41] <pmichaud> I'm thinking it _has_ to be the GET_ATTR_* that slows things down :-/

[19:41] <jnthn> I...right.

[19:41] <jnthn> But that's easy to circumvent.

[19:41] <pmichaud> well, in this case, yes.  :)

[19:41] <jnthn> At the start just do

[19:41] <pmichaud> are we using GET_ATTR_* in some of our other classes?

[19:41] <pmichaud> s/classes/PMCs?

[19:41] <jnthn> Parrot_QRPA_attributes *stuff = PARROT_QRPA(SELF);

[19:41] <jnthn> And then look at stuff

[19:41] <jnthn> Probably

[19:42] <jnthn> Though they probably ain't so hot-path as this.

[19:42] <pmichaud> we might want to adjust those too, if there's a 33% performance difference to be had

[19:42] <jnthn> True.

[19:42] <jnthn> Hm. LexPad/LexInfo. :)

[19:42] <pmichaud> exactly what I was thinking.

[19:42] <pmichaud> anyway, let me adjust this and see if I get the performance back, first :)

[19:43] <diakopter> sorry for the dumb/naive question - why are they ATTR? does that just make them end up being a part of a struct?

[19:43] <pmichaud> well, not "just"

[19:43] <jnthn> diakopter: It checks if we're really look at an object subclass of a PMC and then delegates to getattribute or something if so...

[19:44] <jnthn> In the common case it's just overhead of flag checking.

[19:44] <pmichaud> ...but that overhead seems overbroad here

[19:44] <jnthn> Plus we're doing more pointer chasing than we need to, probably.

[19:44] <jnthn> pmichaud: You're paying for it 3 times, in an otherwise rather cheap routine.

[19:45] <pmichaud> jnthn: yeah, I guess so.

[19:45] <pmichaud> afk for a bit

[19:46] <diakopter> surely there's a way to get at the attribute without going through those checks

[19:46] <pmichaud> diakopter: yes, what jnthn++ posted above.  But that doesn't work for inherited PMC types

[19:46] <jnthn> diakopter: Yes, that's what I just suggested :)

[19:46] <pmichaud> however, I don't expect anything to inherit from QRPA, so I'll remove the checks.

[19:46] <jnthn> pmichaud: We're never gonna inherit from this using Parrot's inheritance. :)

[19:47] <jnthn> pmichaud: And if we were, how would storing a pointer to a C array ever work out?

[19:47] <diakopter> I wasn't suggesting the idea; I knew that jnthn already suggested it. I was wondering whether there was already a facility in parrot for doing so.

[19:47] <pmichaud> diakopter: well, the PARROT_QRPA(self) is provided by Parrot.

[19:48] <pmichaud> so then I can just do    stuff->elems, stuff->start, etc.

[19:48] <pmichaud> and PARROT_QRPA(self) is also quite cheap.

[19:48] <diakopter> oh

[19:49] <pmichaud> anyway, afk and I'll adjust things when I get back.

[19:52] <diakopter> jnthn: the semicolon thing is weird

[19:52] <jnthn> Ain't it just...

[19:56] <jnthn> Well, comparing --rxtrace of the new and old is interesting :)

[19:57] *** brrt left
[19:57] <jnthn> Firstly because we eliminate a few more choices earlier on

[19:57] <jnthn> But for debugging this mostly because master in eat_terminator doesn't end up calling terminator, and altnfa does.

[19:58] <jnthn> oh.

[19:59] <jnthn> terminator doesn't parse a ;, it just checks we are before one.

[19:59] <diakopter> but eat_terminator eats one

[20:00] <jnthn> Did when we considered the branches in order.

[20:00] <diakopter> oh yeah.

[20:00] <jnthn> We're meant to tie-break on that though...

[20:01] <jnthn> oh, I get I'm not...

[20:01] <jnthn> *bet

[20:01] * jnthn tries something

[20:03] *** Teratogen left
[20:03] <diakopter> the ? in eat_terminator and those in terminator: are redundant

[20:04] <jnthn> I think they're deliberate

[20:04] <jnthn> Oh, I see what you mean...

[20:04] <jnthn> We only need one of them.

[20:04] <diakopter> (not that that would cause the problem)

[20:04] <jnthn> Right

[20:04] <diakopter> std has  <?before ')' | ']' | '}' >

[20:05] <diakopter> it doesn't have a ?;

[20:08] <diakopter> it must be getting MARKED

[20:08] <diakopter> eh

[20:13] <diakopter> in !alt_nfa

[20:13] <diakopter> why is the increment $fate line before the next line

[20:15] <jnthn> diakopter: Following what happens in !protoregex_nfa

[20:15] *** fibo joined
[20:16] *** thou left
[20:18] <jnthn> ah, what the heck...

[20:18] <jnthn> Calling value

[20:18] <jnthn> Pushing fate 14140840 - 1

[20:18] <jnthn> ...the same branch twice? o.O

[20:21] *** thou joined
[20:22] * geekosaur so wants to read that as "tempting fate..."

[20:24] <pmichaud> okay, so now I have

[20:24] <pmichaud> http://gist.github.com/2854928   # new get_pmc_keyed_int for QRPA

[20:25] <pmichaud> and with that code I get

[20:25] <pmichaud> http://gist.github.com/2854930

[20:25] <pmichaud> :-(

[20:26] <diakopter> jnthn: try this: https://gist.github.com/2854944

[20:27] <jnthn> r: say 0.32 / 0.41

[20:27] <p6eval> rakudo 636527: OUTPUT«0.780488␤»

[20:27] <jnthn> Hm. No real improvement...

[20:28] *** thou left
[20:28] <pmichaud> which tells me that the speed loss must be from something like dispatch to a dynpmc, or.... I dunno.

[20:28] <jnthn> That seems strange.

[20:28] <jnthn> I mean, I can't imagine why the dispatch to a v-table would be any slower.

[20:29] * jnthn guesses it can't be any difference in optimization level when compiling...

[20:29] <pmichaud> I can't either.  I can't imagine any reason that there'd be a 33% difference between the two.

[20:29] <pmichaud> oh, wait

[20:29] <pmichaud> maybe

[20:29] <jnthn> I was gonna ask what GC marking looks like, but just saw it...looks fine.

[20:30] <pmichaud> my minimum allocation might be too small

[20:30] <pmichaud> just a sec

[20:30] <diakopter> jnthn: note the example I gave

[20:30] <pmichaud> (also doesn't seem likely, but perhaps it's a alignment issue, or ... I dunno.)

[20:31] <pmichaud> also, both of these arrays have exactly one element

[20:32] <pmichaud> pmichaud@kiwi:~/p6/rakudo-qrpa$ make dynext/perl6_group.so && install/bin/parrot z.pir

[20:32] <jnthn> diakopter: yeah but the NQP I get out ain't good enough to compile it...so I'd have to run the stage 1 on it...trying to fathom what on earth is going on with the NFA for value at the moment though...

[20:32] <pmichaud> make: `dynext/perl6_group.so' is up to date.

[20:32] <pmichaud> qrpa[$I0] = 0.459558010101318 rpa[$I0] = 0.304605960845947

[20:32] <diakopter> jnthn: mine compiles it

[20:33] *** thou joined
[20:35] <jnthn> pmichaud: Is it really re-building each time there?

[20:35] * jnthn notes the "is up to date"

[20:35] <jnthn> Doesn't that normally mean "I did nothing"?

[20:35] <pmichaud> I just re-ran it a second time.

[20:35] <pmichaud> yes, it was compiled correctly.

[20:35] <jnthn> OK.

[20:36] <pmichaud> http://gist.github.com/2854999  # the full compile and results

[20:36] <diakopter> jnthn: your nqp won't run my gist?

[20:37] *** skids left
[20:37] <jnthn> diakopter: No, due to local patches

[20:37] <diakopter> ohh; it reproduces the problem just fine in mine from that branch

[20:39] <diakopter> jnthn: commenting out the ; line in terminator: makes nqp pass the whole test suite except 1 file

[20:40] <jnthn> diakopter: Which line exactly

[20:40] <jnthn> ?

[20:40] <jnthn> The

[20:40] <jnthn> | ';'

[20:40] <jnthn> one?

[20:40] <diakopter> no

[20:40] <diakopter> the ; in terminator:

[20:40] <diakopter> token terminator:sym<;> { <?[;]> }

[20:40] <diakopter> to make it more like std

[20:41] <diakopter> and it parses most of the one file it fails on

[20:41] *** PacoAir left
[20:42] <diakopter> I think that indicates it's a problem with <?

[20:44] <jnthn> No, I think the problem is tie-breaking fail

[20:45] <jnthn> The <?terminator> and ';' have equal length prefixes.

[20:45] <diakopter> <?terminator>'s prefix should be the empty string

[20:45] <jnthn> But ';' should win by two different tie-breaking rules.

[20:46] <jnthn> I don't think it works like that. A zero-width assertion counts, but terminates LTM beyond it.

[20:47] <jnthn> The ; literal, however, should win by virtue of (a) being first, but also (b) by being a longer *literal* prefix.

[20:48] <diakopter> it doesn't make sense to me that a zero-width assertion like <? would count what it sees

[20:48] <pmichaud> consider   /  <?[abc]>  . /

[20:48] <pmichaud> you definitely want the [abc] to be part of the ltm

[20:49] <pmichaud> if it doesn't count at all, then you get no benefit

[20:49] *** BlueT_ joined
[20:50] *** thou left
[20:56] <diakopter> jnthn: this is interesting. the outcome differs depending on whether I add --rxtrace

[20:56] *** thou joined
[20:57] <pmichaud> if there's an unbroken tie, different results can occur just depending on hash entry ordering (i.e., somewhat random)

[20:57] <jnthn> oh, I think it is getting ordering right already for tie-breaking...

[21:00] <diakopter> pmichaud: someday you'll want to look at the mess I made of quant in NFA.nqp and do it right..

[21:01] *** thou left
[21:01] <diakopter> although I fiddled with it for many hours trying to make it more eficient and/or written more elegantly. any change I made would break some rakudo test somewhere, surprisingly.

[21:02] <pmichaud> diakopter: okay, I'll take a look sometime

[21:04] <pmichaud> jnthn: think the qpra slowness might be related to Parrot hll segregation somehow?  (e.g., hll_map and friends?)

[21:05] *** bruges joined
[21:05] <jnthn> pmichaud: hll_map would only have an effect when you create a new instance, iirc.

[21:05] <pmichaud> yeah, I'm grasping at straws here a bit

[21:06] *** birdwindupbird left
[21:08] <jnthn> My profiler ain't crazily informative.

[21:08] *** thou joined
[21:09] <jnthn> oh, I don't have your other changes here, mind.

[21:09] <jnthn> ah, they ain't pushed

[21:09] <jnthn> Oddly though, it puts a bunch of the cost on pmichaud@kiwi:~/p6/rakudo-qrpa$ cat z.pir

[21:09] <jnthn> .loadlib 'perl6_group'

[21:09] <jnthn> .sub 'main' :main

[21:10] <jnthn> .local int N

[21:10] <jnthn>     .local num t0, t1

[21:10] <jnthn>     .local pmc p, q

[21:10] <jnthn>     p = new "ResizablePMCArray"

[21:10] <jnthn>     q = new "QRPA"

[21:10] <jnthn>     $P0 = box 'abc'

[21:10] <jnthn>     $I0 = 0

[21:10] <jnthn>     p[$I0] = $P0

[21:10] <jnthn>     q[$I0] = $P0

[21:10] <jnthn>     N = 10000000

[21:10] <jnthn> arrrgh"!

[21:10] <jnthn> It puts a bunch of the cost on:

[21:10] <jnthn> return slots[start + pos];

[21:10] <jnthn> Like, 10% of runtime on the one line

[21:11] <diakopter> what about on the same line in RPMCA

[21:12] <pmichaud> I can test it without the +

[21:13] <jnthn> The inclusive samples found in the profiler shows the same kinda difference as we're measuring in wallclock time.

[21:14] <diakopter> pmichaud: if you double N in your test, do the times double?

[21:14] <jnthn> oh, this profile doesn't really pikc out the line with + one either

[21:15] <jnthn> It does pick out GETATTR_QRPA_elems(interp, _self, elems); though

[21:15] <pmichaud> pmichaud@kiwi:~/p6/rakudo-qrpa$ make dynext/perl6_group.so && install/bin/parrot z.pir

[21:15] <pmichaud> make: `dynext/perl6_group.so' is up to date.

[21:15] <pmichaud> qrpa[$I0] = 0.826143980026245 rpa[$I0] = 0.635416030883789

[21:15] <pmichaud> yes, the times double.

[21:16] <pmichaud> oh, and this one is *without* the cost of the addition

[21:16] <pmichaud> i.e.

[21:16] <pmichaud>         return qrpa->slots[pos];

[21:16] <pmichaud> (assuming that qrpa->start is zero, which it should be in this test)

[21:17] <pmichaud> I'll fix the PMC code and push

[21:18] <dalek> rakudo/qrpa: 138fcb2 | pmichaud++ | src/pmc/qrpa.pmc:

[21:18] <dalek> rakudo/qrpa: QRPA:  Try to make get_pmc_keyed_int as fast as RPA's, fail so far.

[21:18] <dalek> rakudo/qrpa: review: https://github.com/rakudo/rakudo/commit/138fcb25c4

[21:19] <jnthn> pmichaud: OK, I'm confused...

[21:19] <jnthn> I just did a patch locally and managed to get my profiler to show 'em equal

[21:19] *** bacek left
[21:19] <jnthn> Well, within 5% or so of each other anyway

[21:20] <jnthn> https://gist.github.com/2855195

[21:20] <jnthn> Hm, your patch looks...just the same.

[21:21] <jnthn> pmichaud: Crazy. My patch and your seemingly identical one make different amounts of difference.

[21:22] <jnthn> I'd have thought yours was better...

[21:22] <pmichaud>  rpa[$I0] = 0.61777400970459

[21:22] <pmichaud> qrpa[$I0] = 0.821776866912842

[21:22] <pmichaud> (after reversing them)

[21:22] <pmichaud> jnthn: can I see your patch, ooc?  

[21:23] <jnthn> gisted it several lines  ago :)

[21:23] <jnthn>  < jnthn> https://gist.github.com/2855195

[21:23] <pmichaud> yeah, our patches look the same to me

[21:23] <jnthn> Semantically

[21:23] <jnthn> Mine reads all of the things from the struct together at the top

[21:24] <jnthn> I wonder if that hits better with the cache, or there's some multi-word copy that can happen, or something...

[21:24] <jnthn> Or just pre-fetching.

[21:24] <jnthn> But you'd tend to think they'd all be on one cache line...

[21:25] <diakopter> is the order of ->elems ->start ->slots relevant?

[21:25] *** Telgalizer joined
[21:26] * jnthn is curious if pmichaud gets closer results with his patch

[21:27] <jnthn> diakopter: ordering stuff in a struct can matter...but normally to get related stuff on a single cache line

[21:27] <pmichaud> I can try it with the cache, yes.  Although RPA doesn't do any such ordering/caching.

[21:27] <pmichaud> i.e, RPA does the fetches in the middle of the function, not all-at-beginning

[21:29] <jnthn> pmichaud: Yeah...it's a bit of a mystery.

[21:30] <pmichaud> http://gist.github.com/2855237   # with this version, I get

[21:31] <pmichaud> http://gist.github.com/2855240

[21:31] <jnthn> r: say 0.64 / 0.78

[21:31] <p6eval> rakudo 636527: OUTPUT«0.820513␤»

[21:31] <jnthn> :S

[21:31] <pmichaud> re-running it again gives

[21:31] <pmichaud>  rpa[$I0] = 0.714040040969849

[21:31] <pmichaud> qrpa[$I0] = 0.879395961761475

[21:31] <jnthn> Closer but still dunno if it's noise...

[21:31] <jnthn> r: say 0.71 / 0.88

[21:32] <diakopter> you can put the 2nd comparison of pos with 0 inside the block of the first comparison

[21:32] <p6eval> rakudo 636527: OUTPUT«0.806818␤»

[21:32] <pmichaud> it doesn't seem like noise.  qrpa is consistently slower than rpa

[21:32] <jnthn> pmichaud: No, I mean the difference between my patch and your one.

[21:32] <pmichaud> oh, yeah.

[21:32] <pmichaud> that's probably noise-ish.

[21:33] <jnthn> pmichaud: On a slightly different topic: after we match an alternation, do I need to clear the backtracking stack of the things I pushed?

[21:33] <diakopter> the second comparison can only be true if the first comparison was true

[21:33] <jnthn> pmichaud: 'cus I'm not and I'm wondering if that's having...consequences...

[21:33] <pmichaud> diakopter: yes, that's a good point but I was also following the structure of the RPA code there

[21:33] <pmichaud> jnthn: you clear the backtracking if ratcheting is on

[21:33] <jnthn> pmichaud: OK, and if I am failing to do so...I may get oddnes? :)

[21:33] <pmichaud> i.e., you need a mark_commit

[21:34] <jnthn> After the end label of the alternation, yes?

[21:34] <pmichaud> yes

[21:34] <pmichaud> (mark_commit clears backtracking up to a known mark point)

[21:34] <diakopter> pmichaud: maybe qrpa is 20-30% slower for accesses but loads faster for shift/unshift/pop/push

[21:35] <jnthn> ah, so I push a mark before any alternation work, then mark_commit after...

[21:35] <pmichaud> so, you keep track of the first mark you push, and mark_commit to that mark when you exit the alternation

[21:35] <pmichaud> or yes, you can push a mark rather than keep track of the first one

[21:35] <pmichaud> mark_commit discards backtracking up to a mark, but keeps any captures that may have occurred

[21:36] <jnthn> Well, we don't always know the first one, 'cus that's what the LTM is dynamically deciding :)

[21:36] <diakopter> pmichaud: also, the third comparison (pos >= elems) can be put in an else block of the first comparison

[21:36] <diakopter> but you have tested negative accesses. :)

[21:37] <pmichaud> diakopter: also a good point, I'm still wondering why the difference though.

[21:37] <pmichaud> I'll try those changes and see if they affect the timing.

[21:39] <pmichaud> with those changes

[21:39] <pmichaud>  rpa[$I0] = 0.643483877182007

[21:39] <pmichaud> qrpa[$I0] = 0.770877122879028

[21:39] <pmichaud> :-(

[21:40] <pmichaud> diakopter: I suspect that qrpa is loads faster for shift/unshift/pop/push.  But since get_pmc_keyed_int is *the* most common operation on any of our arrays (by far more common than the others).... well, it seems like fixing the 25% problem is pretty high priority first before going that path

[21:41] <diakopter> is get_pmc_keyed_int dispatched any differently for non-built-in pmcs?

[21:42] <jnthn> Shouldn't be...it's just a call thorugh a function pointer, afaik

[21:44] <pmichaud> yes, this is all very disappointing somehow :-|

[21:45] *** fibo left
[21:45] * jnthn is running out of guesses 

[21:47] *** b1rkh0ff left
[21:47] * PerlJam stubbornly clings to his extra deref idea.

[21:48] <jnthn> Unless it really is just calling across the compilation unit boundary.

[21:48] <pmichaud> PerlJam: I think the number of derefs is effectively the same between the two.

[21:48] *** am0c left
[21:48] <jnthn> http://www.gentoo.org/proj/en/hardened/pic-guide.xml

[21:48] <PerlJam> jnthn: is there a way to test that?  Just make QRPA built-in?

[21:48] *** anon___ joined
[21:49] <pmichaud> oh, I suppose I could try it in pure parrot, yes.

[21:49] <pmichaud> that would be interesting.

[21:49] <pmichaud> and not hard.

[21:49] <pmichaud> brb, need dp

[21:49] <diakopter> mmm in Texas you can get cane sugar Dr. Pepper

[21:50] <diakopter> so much better.

[21:50] <diakopter> I haven't had that in 10 years

[21:51] <pmichaud> indeed we can and do.  And I live about 3 miles from Dr Pepper HQ

[21:52] <pmichaud> http://goo.gl/maps/Aw8d   :-)

[21:56] *** jtpalmer joined
[21:59] *** anon___ left
[21:59] *** b1rkh0ff joined
[22:02] *** Gothmog_ joined
[22:12] <pmichaud> oh!  perhaps the headerizer  makes a difference here somewhere?

[22:12] <pmichaud> rpa has been headerized, qrpa hasn't (afaik)

[22:14] <jnthn> hmmm

[22:14] <jnthn> It adds a bunch of annotations.

[22:14] <pmichaud> I'm wondering if those annotations tell gcc about optimization possibilities (or prevent certain checks)

[22:15] <pmichaud> anyway, that's another difference between the two

[22:15] <jnthn> .u 119 104 105

[22:15] <phenny> jnthn: Sorry, no results for '119 104 105'.

[22:15] <jnthn> oops

[22:28] *** thou left
[22:33] <diakopter> pmichaud: did you try building parrot with qrpa as part of its built-ins?

[22:34] *** thou joined
[22:36] *** whiteknight joined
[22:36] *** fridim_ joined
[22:36] *** majrmovies left
[22:36] *** whiteknight is now known as Guest67605

[22:37] *** mdmkolbe joined
[22:45] <dalek> nqp/altnfa: ddf6d6b | jnthn++ | src/NQP/Grammar.pm:

[22:45] <dalek> nqp/altnfa: eat_terminator needs sequential alternation (STD has it that way too; vaguely reassuring that we also need it now we have LTM for alternations).

[22:45] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/ddf6d6bc4d

[22:45] <dalek> nqp/altnfa: bb0350f | jnthn++ | src/QAST/Compiler.nqp:

[22:45] <dalek> nqp/altnfa: Don't leave leftovers on the bstack after an alternation.

[22:45] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/bb0350f710

[22:45] <dalek> nqp/altnfa: dc8561c | jnthn++ | src/QRegex/ (2 files):

[22:45] <dalek> nqp/altnfa: We sometimes accidentally lost alternation branches if we could not build an NFA for them. Make sure we don't do this.

[22:45] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/dc8561c9d6

[22:46] <sergot> good night! o/

[22:46] *** sergot left
[22:48] *** adu left
[22:51] *** skids joined
[22:51] *** alester left
[22:55] <pmichaud> diakopter: I'm going to add qrpa to parrot and see what happens; haven't done that yet and may be leaving shortly for the evening

[22:55] <pmichaud> but yes, I'll do that next.

[22:56] <jnthn> pmichaud: NQP passes all t/nqp now with altnfa

[22:56] <jnthn> pmichaud: A copule of tests in t/qregex fail but I think they may be wrong

[22:56] <pmichaud> jnthn: that's entirely possible

[22:56] <spider-mario> what is that branch supposed to improve?

[22:57] <spider-mario> I don’t know much about nqp :/

[22:57] <pmichaud> spider-mario: it gets alternations to use "real" ltm semantics

[22:57] <spider-mario> ok :)

[22:57] <pmichaud> previously the regex engine would not recognize that     a | aaa   should prefer 'aaa' over 'a'

[22:57] <spider-mario> oh

[22:58] <spider-mario> thanks

[22:59] <pmichaud> jnthn++  # altnfa branch working

[22:59] <diakopter> jnthn++

[22:59] <spider-mario> jnthn++

[23:03] <jnthn> in NQP now, for example:

[23:03] <jnthn> > say('aa' ~~ /a|\w+/)

[23:03] <jnthn> aa

[23:04] <jnthn> > say('aa' ~~ /\w+|a/)

[23:04] <jnthn> aa

[23:04] <jnthn> ...not cheating ;)

[23:12] <diakopter> nr: my $b = 4; repeat while $b-- { $^a.defined }

[23:12] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: No value in ANON available for parameter $a␤  at /tmp/h66JwHxDX8 line 1 (mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3912 (module-CORE @ 558) ␤  at /home/…

[23:12] <p6eval> ..rakudo 636527:  ( no output )

[23:12] <diakopter> jnthn: which do you deem correct, so I can fudge the proper one

[23:14] <diakopter> commute to coffeeshop&

[23:15] <spider-mario> good night \o

[23:15] *** spider-mario left
[23:16] <pmichaud> I'll keep the discussion mainly on #parrot for now, but when qrpa is compiled into parrot as a builtin, I get

[23:16] <pmichaud>  rpa[$I0] = 0.658792972564697

[23:16] <pmichaud> qrpa[$I0] = 0.609246969223022

[23:17] <jnthn> whoa

[23:17] <pmichaud> so, it looks like something related to dynpmc may be the culprit.

[23:17] <pmichaud> I'll create a dynpmc version of qrpa in my parrot repo and then we can test the three side-by-side

[23:17] <pmichaud> but that will have to be later or tomorrow --w e're going out for the evening here.  bbl

[23:17] <jnthn> pmichaud++

[23:17] <jnthn> Have a nice evening o/

[23:18] <dalek> rakudo/altnfa: f335c7f | jnthn++ | src/Perl6/Grammar.pm:

[23:18] <dalek> rakudo/altnfa: Update a couple of places in the grammar that need || insted of |.

[23:18] <dalek> rakudo/altnfa: review: https://github.com/rakudo/rakudo/commit/f335c7f2e0

[23:18] <dalek> rakudo/altnfa: fb45990 | jnthn++ | src/Perl6/Grammar.pm:

[23:18] <dalek> rakudo/altnfa: Add ident so we can LTM on it.

[23:18] <dalek> rakudo/altnfa: review: https://github.com/rakudo/rakudo/commit/fb45990048

[23:19] <jnthn> I've had enough for now, but that branch needs some work.

[23:20] <jnthn> Current failure is line 80 of CORE.setting compilation. It chooses the wrong branch in variable, it seems.

[23:20] <jnthn> (token variable, that is)

[23:22] *** spaceships left
[23:22] *** spaceships joined
[23:25] *** fridim_ left
[23:39] * diakopter goes to work on altnfa

[23:43] * jnthn goes to bed

[23:43] <jnthn> 'ngiht o/

[23:43] <diakopter> o/

[23:45] *** stephenlb joined
[23:48] <diakopter> hrm. compiling CORE.setting is taking forever. probably looping.

[23:51] <PerlJam> CORE.setting always takes forever

[23:51] <diakopter> not this long

[23:52] <diakopter> starting it over ,timing it this time

[23:57] <diakopter> it's worrisome b/c jnthn said it fails on line 80 of CORE.setting, but surely it gets past line 80 in 5 minutes

