[00:03] *** benabik joined
[00:09] *** cognominal left
[00:18] <dalek> doc: 923f9e1 | (Geoffrey Broadwell)++ | htmlify.pl:

[00:18] <dalek> doc: htmlify.pl: Minor code readability improvements, no functional changes

[00:18] <dalek> doc: review: https://github.com/perl6/doc/commit/923f9e1417

[00:18] <dalek> doc: a7d2b13 | (Geoffrey Broadwell)++ | htmlify.pl:

[00:18] <dalek> doc: htmlify.pl: Factor two major Pod file processing blocks out of MAIN; no functional changes

[00:18] <dalek> doc: review: https://github.com/perl6/doc/commit/a7d2b13d2f

[00:18] <dalek> doc: 3fb2dfe | (Geoffrey Broadwell)++ | htmlify.pl:

[00:18] <dalek> doc: Fix naive refactoring bug in previous commit

[00:18] <dalek> doc: review: https://github.com/perl6/doc/commit/3fb2dfe214

[00:19] *** gfldex left
[00:19] *** gfldex joined
[00:23] *** benabik left
[00:23] *** dayangkun joined
[00:29] *** fgomez left
[00:31] *** _jaldhar left
[00:37] *** fgomez joined
[00:38] *** cognominal joined
[00:46] *** cognominal left
[00:47] <dalek> specs: 65c3a06 | larry++ | S11-modules.pod:

[00:47] <dalek> specs: spec both ::() and :file() require forms

[00:47] <dalek> specs: review: https://github.com/perl6/specs/commit/65c3a06592

[00:47] <dalek> specs: 0a50011 | larry++ | S11-modules.pod:

[00:47] <dalek> specs: semantic clarifications of new require forms

[00:47] <dalek> specs: 

[00:47] <dalek> specs: fixes #23

[00:47] <dalek> specs: review: https://github.com/perl6/specs/commit/0a500111a4

[00:48] *** cognominal joined
[00:49] *** _jaldhar joined
[00:51] *** immortal left
[00:53] <[Coke]> https://gist.github.com/3628577 

[00:54] *** scott_ joined
[00:54] *** scott_ is now known as Guest38681

[00:55] <[Coke]> (getting an error trying to compile array.pm)

[00:55] *** scottdware joined
[01:03] *** sisar joined
[01:04] *** scottdware left
[01:08] *** benabik joined
[01:09] *** spider-mario left
[01:12] *** hypolin joined
[01:15] *** whiteknight left
[01:17] * [Coke] wonders if it's a pod commenting issue.

[01:22] *** sisar left
[01:27] *** fgomez left
[01:29] *** fgomez joined
[01:31] *** topologist joined
[01:31] *** MikeFair_ joined
[01:40] *** topologist left
[01:40] *** Cofyc joined
[01:42] *** tokuhiro_ joined
[01:42] <[Coke]> I'm seeing this a lot: Error while compiling block : ResizableStringArray: Can't shift from an empty array!

[01:44] <[Coke]> (trying to use nqp latest)

[01:45] <[Coke]> https://gist.github.com/3629000

[01:46] <MikeFair_> [Coke]: I saw that too

[01:46] <MikeFair_> I fixed that one

[01:47] <MikeFair_> It had to do with the implemention of say I believe

[01:47] <MikeFair_> I'm currently dealing with either:

[01:47] <MikeFair_> Method 'parse' not found for invocant of class 'NQPMu'

[01:47] <MikeFair_> (when I get it to compile and run

[01:47] <MikeFair_> or 

[01:48] <MikeFair_> method 'blocktype' not found for QAST::CompUnit

[01:48] <MikeFair_> or something close to that

[01:49] <MikeFair_> But i'm not sure how much of this is NQP and how much of this is Parrot and how much of this is my not unerstanding what _should_ be happening -- so I've tried not to make so much noise about this

[01:50] <MikeFair_> Especially here on #Perl6 :)

[01:51] <benabik> QAST is largely #perl6 territory.

[01:52] <MikeFair_> [Coke]: One change I had to make to Grammar / Actions / Compiler - that instead of the Compiler instantiation being a statement it's now a class

[01:52] <MikeFair_> so this should be at the top of those .pms : grammar safire::Grammar is HLL::Grammar {

[01:52] <MikeFair_> With the corresponding } at the bottom

[01:53] <MikeFair_> The can't shift from empty array had something to do with the command line ARGS IIRC

[01:53] <MikeFair_> So I just commented that line out to get passed compilation and would deal with it later

[01:55] <MikeFair_> benabik: Yeah, but it seems that what I'm dealing with is that the deafult shell language Parrot comes with doesn't seem to instantiate the language in the same way NQP does.  I'm not sure if this a problem or not though

[01:55] <MikeFair_> benabik: So I'm not clear on the separation between the two domains. :)

[01:56] *** dayangkun left
[01:59] <MikeFair_> [Coke]: I also had to add a: use NQPHLL; line to the top of each .pm as well

[02:00] <[Coke]> You mentioned a lot of issues that I already addresses, yah.

[02:00] <MikeFair_> [Coke]: Grammar for say had to be rewritten from [ <EXPR> ] ** ','  }

[02:00] <MikeFair_> to [ <EXPR> ]* %','  }

[02:00] * MikeFair_ nods.

[02:00] <MikeFair_> [Coke]: Figured you would have as these are the stupid obvious ones. :)

[02:01] <[Coke]> partcl-nqp/nqp2 now builds again, but I've gutted the grammar so that the only thing that parses is 'three' which generates a '3'. 

[02:01] <MikeFair_> I gleaned a lot of this from the examples/json.nqp

[02:01] <[Coke]> but at least now I have something that builds and runs, and I can slowly add functionality back in.

[02:02] *** dayangkun joined
[02:03] <MikeFair_> [Coke]: Any ideas what my "method 'parse' not found for 'NQPMu'" message might be about

[02:04] <[Coke]> you need to register your compiler.

[02:05] <[Coke]> https://github.com/partcl/partcl-nqp/blob/nqp2/src/Partcl.pm#L96

[02:07] *** sisar joined
[02:07] <MikeFair_> [Coke]: Yeah I saw that function but I'm not sure what file it should go in.. my main is currently in a 'setup.pir' module

[02:08] * MikeFair_ will poke around partcl-nqp and learn.  Thanks!

[02:08] <[Coke]> I moved my main file from a .pir to a .pm

[02:09] <[Coke]> I am sorry for you if that's your best example. ;)

[02:11] <[Coke]> where can I find a list of nqp opcodes?

[02:12] *** Vlavv` left
[02:13] <MikeFair_> hehe - there doesn't seem to be much in the way of docs, I've jsut been grepping -ri through the source tree

[02:13] <MikeFair_> [ <EXPR> ]* %','  }

[02:13] <MikeFair_> err

[02:13] <MikeFair_> grep -ri t/qast/pirt.t 

[02:13] <MikeFair_> err grep -ri pirop t/qast/pirt.t 

[02:14] <MikeFair_> That might not be all of them, but it's a start ;)

[02:19] *** orafu left
[02:19] *** orafu joined
[02:23] *** dayangkun left
[02:23] *** tokuhiro_ left
[02:27] <pmichaud> nqp opcodes:  https://github.com/perl6/nqp/blob/master/docs/nqp-opcode.txt

[02:29] *** popl joined
[02:29] <MikeFair_> pmichaud: Even better :)

[02:30] <pmichaud> that list is fairly up-to-date

[02:31] <sorear> o/ pmichaud

[02:31] <phenny> sorear: 02:31Z <zort-> tell sorear 4

[02:31] <pmichaud> the complete list would be in src/QAST/Operations.nqp

[02:31] <phenny> sorear: 02:31Z <zort-> tell sorear 5

[02:31] <phenny> sorear: 02:31Z <zort-> tell sorear 6

[02:31] <phenny> sorear: 02:31Z <zort-> tell sorear 7

[02:32] <phenny> Further messages sent privately

[02:32] <pmichaud> o/ sorear

[02:32] <sorear> who is zort-

[02:33] *** dayangkun joined
[02:34] <benabik> Someone who likes to count?

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 65

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 66

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 67

[02:34] <benabik> uhhhh

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 68

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 69

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 70

[02:34] <phenny> benabik: 02:34Z <zort-> tell benabik 71

[02:35] <benabik> Someone trying to crash phenny?

[02:35] <phenny> benabik: 02:35Z <zort-> tell benabik 72

[02:35] <phenny> benabik: 02:35Z <zort-> tell benabik 73

[02:35] <phenny> benabik: 02:35Z <zort-> tell benabik 74

[02:36] <sorear> hmm

[02:36] <phenny> sorear: 02:36Z <zort-> tell sorear 105

[02:36] <phenny> sorear: 02:36Z <zort-> tell sorear 106

[02:36] <phenny> sorear: 02:36Z <zort-> tell sorear 107

[02:36] <phenny> sorear: 02:36Z <zort-> tell sorear 108

[02:36] <phenny> Further messages sent privately

[02:38] *** ChanServ sets mode: +o sorear

[02:38] *** phenny was kicked by sorear (phenny))
[02:42] <benabik> I wonder where he's sending them...  PM to phenny?

[02:42] <sorear> or another channel

[02:42] <sorear> phenny is in quite a few places

[02:42] <sorear> I sent off a ping to sbp

[02:43] <benabik> sorear++

[02:47] *** daniel-s__ joined
[02:50] * TimToady wonders if it was a python injection attack of some sort

[02:51] *** daniel-s_ left
[02:53] <TimToady> probably not, since the time changes

[03:34] *** skids left
[03:36] *** jaldhar_ joined
[03:37] *** _jaldhar left
[03:41] <MikeFair_> pirs pirs everywhere but not an nqp :)

[03:47] <dalek> doc: 1f37c81 | (Geoffrey Broadwell)++ | app.pl:

[03:47] <dalek> doc: Trivial Mojolicious::Lite app to serve static content from html dir; currently uses redirects instead of content negotiation

[03:47] <dalek> doc: review: https://github.com/perl6/doc/commit/1f37c81b2f

[04:08] *** dayangkun left
[04:08] *** colomon left
[04:08] <MikeFair_> [Coke]: Did you get your error figured out?

[04:09] *** kaleem joined
[04:13] *** jaldhar_ left
[04:16] *** colomon joined
[04:21] *** jaldhar_ joined
[04:22] *** Cofyc left
[04:25] <__sri> japhb: stay away from $ENV{MOJO_APP}!

[04:27] <__sri> just use the app function instead

[04:29] <__sri> MOJO_APP actually doesn't work anymore in newer Mojolicious releases, since putting data structures into %ENV was never a Perl feature and has been broken in 5.17.3

[04:31] <__sri> you may want to visit #mojo :)

[04:35] *** marmay joined
[04:43] *** colomon left
[04:45] *** colomon joined
[04:52] <geekosaur> wat.  that should never have worked

[05:07] *** cognominal left
[05:11] <sorear> geekosaur: that's what #p5p said too.  sri was not amused

[05:12] <__sri> yea :,(

[05:19] <__sri> it was only a side effect of a mojolicious detection feature, but many people have actually been depending on it

[05:34] <japhb> __sri, that's because old versions of Mojolicious::Lite had no other obvious way to grab the app object.  :-/

[05:34] <__sri> perldoc Mojolicious::Lite

[05:34] <__sri> the app function existed since day 1

[05:36] <japhb> Ah, my bad.  It is documented near the end, but confusing in the first few sections of the doc (where it appears to be only some magic to make app->start work)

[05:36] <japhb> But I understand now, fixing ...

[05:37] <__sri> you must be using a very old version

[05:37] <__sri> i don't think there are any examples without app->start anymore

[05:38] <__sri> http://mojolicio.us/perldoc/Mojolicious/Lite#SYNOPSIS # :)

[05:38] <japhb> Yeah, the box I'm working on is very out of date.

[05:38] <japhb> No worries.

[05:38] *** popl left
[05:40] <dalek> doc: ba8b767 | (Geoffrey Broadwell)++ | app.pl:

[05:40] <dalek> doc: Replace Mojolicious guts-evilness with normal API/attribute access

[05:40] <dalek> doc: review: https://github.com/perl6/doc/commit/ba8b767bfb

[05:40] <japhb> There you go ^^

[05:40] <__sri> \o/

[05:41] *** cognominal joined
[05:41] <japhb> __sri, while you're here -- what is the "proper" way to do what I did in that app?  (Emulate Apache doing .../ => .../index.html and .../file => .../file.html)

[05:41] <__sri> word of warning, ->root() is gone for like 6 months, we now support multiple ->paths() ;)

[05:42] <japhb> Gone as in "old API no longer exists" or gone as in "deprecated and not documented, but still exists for back compat"?

[05:42] *** benabik left
[05:42] *** benabik joined
[05:42] <__sri> it was deprecated and then removed 6 months ago :)

[05:42] <japhb> *sigh*

[05:43] <__sri> redirect seems fine i guess

[05:44] <japhb> OK, question for the 6'ers: Is there a way to use multi *subs* from a Role?  Or does a Role even have a way of feeding multi subs to a composer?

[05:44] <__sri> i'm not quite understanding the problem, but maybe all you want is default values for placeholders

[05:45] <japhb> __sri, Well, I guess what I mean is "How would you make that just one route?"

[05:45] <__sri> default values i suppose, the lite tutorial should have all you need

[05:45] <japhb> I found the lite tutorial to be a bit ... lite.

[05:45] <japhb> Too terse.

[05:46] <japhb> Not enough descriptions of edge cases and interactions between things.

[05:46] <japhb> I found myself thinking "Do I really need to go to the full Mojolicious just to do this sanely?"

[05:47] <__sri> lite and full are 99% the same, you can use the exact same features

[05:47] <japhb> What I ended up with was my best guess (from the M::Lite doc) of how to capture the "spirit" of a M::Lite app while still handling the task.

[05:47] <__sri> anyway, we are quite off topic, you should join #mojo over on irc.perl.org

[05:48] <japhb> Fair enough.

[05:48] * benabik sometimes wonders if #p6 has an on topic.

[05:49] <japhb> benabik, I've asked two on-topic questions tonight.  They were both Warnocked.  ;-/

[05:49] <tadzik> I think the rule is mostly "talk about whatever you want as long as you don't interrupt any ongoing on-topic discussion"

[05:50] <japhb> tadzik, Ah, you're awake, coo.

[05:50] <japhb> er cool.

[05:50] <tadzik> my problem with Mojo vs Mojo::Lite was that the documentation for libraries always covers only the Lite part, same with tests

[05:50] <tadzik> it's sometimes hard to figure out how to do the same thing in full mojolicious

[05:51] <japhb> My question above about multi subs from Roles was because I'm hacking at a possible refactorization of Pod::To::*

[05:51] <__sri> tadzik: it gets much easier later on

[05:51] <tadzik> __sri: what do you mean by later on?

[05:51] <__sri> once you've worked a bit with both, lite and full apps

[05:51] <sorear> japhb: if you'd just ask questions I know the answer to...

[05:52] <japhb> sorear, *chuckle*

[05:52] <tadzik> I see

[05:52] <__sri> tadzik: usually i only hear that complaint from those who skipped the lite tutorial :)

[05:52] <tadzik> hehe

[05:53] <__sri> you're kinda supposed to learn lite and move on to full

[05:53] <tadzik> which says "this is what lite does under the hood"

[05:53] *** sorear sets mode: -o sorear

[05:53] *** cognominal left
[05:53] *** cognominal joined
[05:54] <japhb> tadzik, Why do you use multis in Pod::To::HTML and not in Pod::To::Text?  Was one just a newer design than the other?

[05:55] <tadzik> japhb: Pod::To::HTML is not really written by me :)

[05:55] <japhb> Oh.

[05:55] * japhb fail

[05:55] <tadzik> I started it, but flussence++ wrote most of it I think

[05:56] <japhb> Ah, OK

[05:57] <japhb> phenny, ask jnthn Is there a way to use multi *subs* from a Role?  Or does a Role even have a way of feeding multi subs to a composer?

[05:57] <japhb> Oh right, phenny got kicked.

[05:57] <japhb> Is it safe to bring phenny back?

[06:00] <TimToady> stop asking hard question!  :)

[06:00] <TimToady> *tions

[06:00] <__sri> free phenny!

[06:04] <benabik> Did phenny used to cost something?

[06:05] <sorear> aloha: msg japhb we have two tellbots here

[06:05] <sorear> msg japhb we have two tellbots here

[06:06] <sorear> aloha: tell japhb we have two tellbots here

[06:06] <benabik> aloha is somewhat crippled here...

[06:06] <sorear> :/

[06:06] * japhb wonders if aloha knows I'm here

[06:06] <japhb> Apparently not.

[06:06] <sorear> aloha: seen japhb

[06:06] <aloha> sorear: japhb was last seen in #perl6 1 seconds ago saying "Apparently not.".

[06:06] <benabik> seen japhb 

[06:06] <aloha> japhb was last seen in #perl6 2 seconds ago saying "Apparently not.".

[06:06] <japhb> heh

[06:06] *** lambdabot joined
[06:06] * benabik thinks aloha is just here so we in #parrot can tell if someone is over here.

[06:07] <sorear> ok, that worked at least.

[06:07] <sorear> @tell japhb the old standby.

[06:07] <lambdabot> Consider it noted.

[06:07] <japhb> @tell jnthn Is there a way to use multi *subs* from a Role?  Or does a Role even have a way of feeding multi subs to a composer?

[06:07] <lambdabot> Consider it noted.

[06:07] <sorear> I'm a little suprised I still have my special-command bit

[06:07] <japhb> Hopefully he gets that message ...

[06:07] <lambdabot> japhb: You have 1 new message. '/msg lambdabot @messages' to read it.

[06:07] <sorear> '/msg lambdabot @join #perl6'

[06:08] <japhb> break &

[06:25] *** aindilis left
[06:38] <moritz> \o

[06:42] <MikeFair_> Hey moritz

[06:42] *** dayangkun joined
[06:43] <moritz> oh hai MikeFair_ 

[06:44] <MikeFair_> moritz: You have any experience with using nqp to implement another language on parrot.  For the life of me I can't figure out how to get the thing to actually build (I keep running into various 'I don't know about that' kind of errors

[06:44] <MikeFair_> or perhaps can point to something that does?  Some example perhaps that I can copy.

[06:45] <MikeFair_> I've built nqp and gotten it installed, and it works, but I'm just not able to use it successfully during the build process of my language

[06:51] *** xinming_ left
[06:55] <moritz> MikeFair_: my only experience with using NQP is rakudo

[06:55] <MikeFair_> Yeah that's what I figured ppl's experience would be

[06:55] <moritz> MikeFair_: so I'd copy the interesting parts of rakudo's src/main.nqp

[06:56] <moritz> and then the heads of src/Perl6/{Grammar,Actions}.pm

[06:56] <MikeFair_> I'm just not sure what the build process is.  Actually I just did that!  It had the bits in PIR that I'd only been seeing in a .pm file before

[06:56] <MikeFair_> The problem I'm encountering now is nqp seems to want Grammar.pbc which doesn't exist because it hasn't been built

[06:56] <MikeFair_> :)

[06:57] * MikeFair_ looks at the heads of actions/Grammar to make sure he's not missing anything

[06:58] *** FROGGS__ joined
[06:58] *** FROGGS joined
[06:58] <MikeFair_> Hmm, I've got use NPQHLL at the heads now (stolen from the json.nqp example)

[06:58] <FROGGS> good morning

[06:58] <MikeFair_> hello FROGGS

[06:59] *** fgomez left
[07:00] <MikeFair_> moritz: I clearly don't have the rest of that stuff in top and those methods though

[07:00] <MikeFair_> :)

[07:01] *** xinming joined
[07:01] <sergot> hi o/ !

[07:07] *** brrt joined
[07:07] *** stepnem joined
[07:11] <tadzik> hellllo

[07:11] <frettled> hiho!

[07:11] <MikeFair_> hello

[07:11] <moritz> MikeFair_: well, you can compile .pir to .pbc with  parrot -o file.pbc file.pir

[07:14] *** SamuraiJack joined
[07:14] <FROGGS> will it be again a bit faster then?

[07:14] *** kresike joined
[07:14] <kresike> good morning all you happy perl6 people

[07:14] <FROGGS> .pbc is portable, right?

[07:15] <FROGGS> gmorning

[07:17] <tadzik> FROGGS: portablish

[07:18] <FROGGS> k, thanks

[07:19] <tadzik> well, as it's essentialy pir, you probably don't want to ship it

[07:23] <dalek> roast: e40bbd1 | moritz++ | S05-match/capturing-contexts.t:

[07:23] <dalek> roast: fudge a changed test that rakudo does not like in its current form

[07:23] <dalek> roast: review: https://github.com/perl6/roast/commit/e40bbd140c

[07:24] <FROGGS> tadzik: speed matters a lot, and as it seems than when I ship A.pm6, A.pir and A.bpc it will pick the last one, I am fine with that

[07:24] <FROGGS> but it might should compile the stuff when compiling, if it is able to, otherwise skip

[07:25] <tadzik> FROGGS: it may just not work

[07:25] <moritz> FROGGS: the problem with shipping compiled .pir and .pbc files is that they depend on exact revision of rakudo and all dependencies

[07:25] <tadzik> see also: panda not working after recompiling rakudo

[07:25] <FROGGS> ohh, thats mad

[07:26] <FROGGS> so it will just be helpful for some kind of staticperl6 later on

[07:26] <FROGGS> or there must be an automatic rebuilt when it detects changes

[07:27] <moritz> well, it just means you have to precompile when you install a new rakudo

[07:27] <moritz> and only the hardcore developers do that very often

[07:28] <moritz> but we plan to change the whole precompilation thing

[07:28] <moritz> to make it a cache managed by rakudo, not by the user

[07:28] <FROGGS> that sounds like somthing I wanna have ;o)

[07:28] <FROGGS> (some day)

[07:29] <moritz> and you will

[07:29] <moritz> (some day)

[07:29] <moritz> :-)

[07:29] <FROGGS> **g

[07:34] <TimToady> http://rosettacode.org/wiki/Roots_of_a_function#Perl_6  # 450 entries now

[07:39] <MikeFair_> wooot

[07:39] * MikeFair_ built and installed perl6

[07:40] <MikeFair_> Wish it was getting my language working but as all I really need/want right now is mostly Grammar.pm, i'm thinking I might just do it straight in P6 instead of Parrot

[07:41] *** Cofyc joined
[07:54] <MikeFair_> Goodnight all!

[07:54] * MikeFair_ sleeps.

[08:05] *** BenBE left
[08:16] <masak> 'ning, #perl6

[08:16] <FROGGS> \o masak

[08:16] <masak> TimToady++ # 450

[08:19] *** leont joined
[08:19] *** Psyche^ joined
[08:19] *** Patterner left
[08:19] *** Psyche^ is now known as Patterner

[08:19] <masak> I like http://rosettacode.org/wiki/Roots_of_a_function#Perl_6 -- the NEXT happens in a narrower scope than the for loop itself, and somehow that surprises me, even though it shouldn't feel strange at all at this point.

[08:27] *** sivoais left
[08:32] *** dakkar joined
[08:34] *** Circlepuller_ joined
[08:35] *** Circlepuller left
[08:36] *** fhelmberger joined
[08:59] *** glosoli joined
[08:59] *** glosoli left
[09:01] <masak> hm. looking at my last attempt at hygienifying D2 at https://github.com/rakudo/rakudo/commit/1ac5431b62bd313bde32417e387881584ea291f3 , I can only assume I was horribly confused, or tired, or both.

[09:01] * masak reverts that commit and makes a new attempt

[09:01] <masak> today is my Perl 6 day for the week, by the way. expect lots of ramblings about macros.

[09:02] <tadzik> hooray

[09:04] *** hoelzro|away is now known as hoelzro

[09:04] <masak> jnthn is unfortunately busy today. so if someone else wants to act as vict^Wsounding board for my heinous ideas, that would help a lot.

[09:08] * masak draws ASCII art to make things clear to himself

[09:09] * moritz can act as macro victim, yes

[09:09] <masak> \o/

[09:09] * masak was hoping for moritz++

[09:10] <masak> moritz: let me draw this ASCII art for you; then we can talk over that

[09:10] <masak> r: macro twice($code) { quasi { {{{$code}}}; {{{$code}}} } }; my $counter = 0; twice $counter++; say $counter

[09:10] <p6eval> rakudo cc1858: OUTPUT«0␤»

[09:10] <masak> :(

[09:11] <masak> r: macro twice($code) { my $counter = 4; quasi { {{{$code}}}; {{{$code}}}; say $counter } }; my $counter = 0; twice $counter++; say $counter

[09:11] <p6eval> rakudo cc1858: OUTPUT«6␤0␤»

[09:11] <masak> well, *something* gets incremented twice...

[09:11] *** hoelzro is now known as hoelzro|away

[09:15] <moritz> r: macro twice($code) { my $counter = 4; quasi { {{{$code}}}; {{{$code}}}; say $counter } }; my $counter = 0; twice $counter += 2; say $counter

[09:15] <p6eval> rakudo cc1858: OUTPUT«8␤0␤»

[09:15] <moritz> r: macro twice($code) { my $counter = 4; quasi { {{{$code}}}; {{{$code}}}; say $counter } }; my $counter = 0; twice say $counter; say $counter

[09:15] <p6eval> rakudo cc1858: OUTPUT«4␤4␤4␤0␤»

[09:15] <moritz> r: macro twice($code) { my $counter = 4; quasi { {{{$code}}}; {{{$code}}}; say $counter } }; my $counter = 0; twice say ++$counter; say $counter

[09:15] <p6eval> rakudo cc1858: OUTPUT«5␤6␤6␤0␤»

[09:18] <masak> heh, my ASCII art turned out to be words rather than pictures. but writing this down seems to help.

[09:28] <masak> moritz: https://gist.github.com/3634046

[09:34] <masak> it's two worlds. the parse world and the runtime world. macros and quasis are all about safely handing values over from one world to the other.

[09:34] <masak> essentially, the parse world deals in QAST trees, and the runtime world deals in Perl6::AST trees. the latter are a kind of monadic wrapper around the former.

[09:35] <masak> the only place where this isn't quite true is at (2), where parsetime packages the QAST arguments into Perl6::AST objects. but that's just a kind of polite hand-over from parse to runtime.

[09:39] <moritz> masak: ah, I see the problem

[09:39] <moritz> masak: and I see why it is related to hygiene

[09:40] <masak> well, it's less of a problem and more of an "it goes both ways" thing.

[09:40] <moritz> (the problem in the example with macro twice, I mean)

[09:40] <moritz> that is a bug, IMHO

[09:41] <masak> there are Perl6::ASTs going into the macro and Perl6::ASTs going out of the macro. both kinds must close over their parsed context. only the latter does, currently.

[09:43] <masak> <moritz> that is a bug, IMHO

[09:43] <masak> could you be more specific?

[09:44] <moritz> well, the argument to twice is supposed to be a *value*, not a thunk

[09:45] <moritz> correct?

[09:45] <moritz> and you don't evaluate the argument before passing it

[09:45] <moritz> hence the variable gets the wrong context

[09:45] <moritz> and hence double execution

[09:46] <masak> oh, the double execution is correct.

[09:46] <moritz> why?

[09:47] <masak> and if you're thinking thunk, then you're too far ahead in the compilation process.

[09:47] <masak> at this point `$count++` is an AST.

[09:47] <moritz> why?

[09:47] <moritz> I mean, why should it be an AST?

[09:47] <masak> because ASTs are what's passed into a macro as arguments.

[09:47] <masak> macros are AST manipulators.

[09:48] <moritz> r: macro a($x) { say $x }; a 2

[09:48] <p6eval> rakudo cc1858: OUTPUT«AST.new()␤===SORRY!===␤too few positional arguments: 2 passed, 3 (or more) expected␤»

[09:48] <moritz> what am I doing wrong here?

[09:48] <masak> nothing. you just found a bug, I think.

[09:48] <masak> but you also showed that $x is an AST.

[09:48] <moritz> no, I didn't

[09:48] <masak> r: macro a($x) { say $x; Nil }; a 2

[09:48] <p6eval> rakudo cc1858: OUTPUT«AST.new()␤»

[09:49] <moritz> I showed that, somewhere in the process, it tries to generate an AST :-)

[09:49] <moritz> r: macro a($x) { say {{{$x}}}; Nil }; a 2

[09:49] <p6eval> rakudo cc1858: OUTPUT«Block.new()␤»

[09:49] <masak> point of order: AST.new() is what the gist calls Perl6::AST.

[09:49] <moritz> hm, so you can't pass a string to a macro?

[09:50] <masak> moritz: I'm not implementing string macros. I'm implementing AST macros.

[09:50] <masak> moritz: you "can't" use {{{}}} outside quasi blocks.

[09:50] <masak> moritz: in the sense that they will just be three block inside each other.

[09:50] <moritz> yes, I figured

[09:50] <moritz> but I'm stil not convinced about macro arguments being ASTs

[09:51] <masak> this half surprises and half amuses me.

[09:51] <moritz> I mean, not automatically

[09:51] <masak> because it's totally clear to me that they are.

[09:52] <masak> though I hadn't factored textual macros into it before, I admit. because I'm not implementing those.

[09:52] <moritz> I'm not talking about textual macros either

[09:53] <masak> ok.

[09:54] * moritz wonders if him being the victim does more harm than good

[09:55] <masak> no, this is interesting so far.

[09:55] <masak> though I'm a little scared of where the discussion is going. I do hope I'm right ;)

[09:55] <masak> I got the feeling above that you didn't expect `$counter++` to run only once. I wonder why you thought that.

[09:56] <moritz> because that's what routines do :-)

[09:56] <masak> r: run-twice(&c) { &c(); &c() }; my $counter = 0; run-twice { $counter++ }; say $counter

[09:56] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Confused␤at /tmp/FTGEZVVqdh:1␤»

[09:56] <moritz> erm

[09:56] <masak> r: sub run-twice(&c) { &c(); &c() }; my $counter = 0; run-twice { $counter++ }; say $counter

[09:56] <p6eval> rakudo cc1858: OUTPUT«2␤»

[09:56] <masak> even in the case where the macro is a sub, it runs twice.

[09:56] <moritz> only if you add a block around it

[09:57] <masak> the biggest difference is that the above sub makes two *calls*, whereas our example macro makes two *code insertions*.

[09:57] <masak> moritz: the macro arguments have implicit blocks around them.

[09:57] <moritz> masak: that's what I meant with "thunking"

[09:57] <masak> moritz: those blocks must be there for there to be somewhere to attach the surrounding context to.

[09:57] <masak> moritz: right, but they're ASTs.

[09:58] * masak .oO( here, I'll be Abbott, and you'll be Costello )

[09:59] <moritz> ok, I think you convinced me

[09:59] * masak .oO( who's on thunk? yes. )

[09:59] <moritz> so, on with the show

[09:59] <masak> \o/

[10:00] <masak> moritz: some of the things I know today about this, I've discovered in earlier excellent conversations with you.

[10:00] <masak> moritz: but I don't blame you for forgetting and rediscovering details. I keep doing that, too.

[10:01] <masak> macro implementation seems to be a steep, and slippery, learning curve ;)

[10:02] <masak> moritz: so, ASTs going in and coming out of a macro are really tree representations of code, pretending to be thunks/closures.

[10:02] <moritz> aye

[10:02] <masak> the "pretending to be thunks/closures" bit is the important part to get hygiene right.

[10:02] <masak> it currently only works in the outwards direction.

[10:02] <masak> the patch I need to apply today is a fixup that sets the context correctly in the inwards direction.

[10:03] <masak> https://github.com/rakudo/rakudo/commit/1ac5431b62bd313bde32417e387881584ea291f3 is a failed attempt.

[10:03] <masak> I think it mixes up layers and levels that are much more clearly exaplained in https://gist.github.com/3634046

[10:03] <cognominal> TimToady, what is the relationship between the Summer Institute of Linguistic and tagmemics? 

[10:03] <masak> cognominal: ooh, I was wondering that too, after reading about tagmemics on Wikipedia.

[10:03] <cognominal> Did Kenneth Pike was teaching there

[10:04] <cognominal> Were you one of his people?

[10:04] <cognominal> Question for TimToady when he wakes up :)

[10:04] <cognominal> s/people/pupils/

[10:05] <cognominal> oops, my english is so broken

[10:05] * masak .oO( minions )

[10:05] <moritz> masak: reading the failed patch I have no idea how it tried to do what it should do

[10:06] <masak> moritz: well, it was essentially a blind copy-and-paste of the things that worked for context-anchoring the quasi.

[10:06] <masak> moritz: I might start by explaining to you how that works, in fact.

[10:06] <moritz> yes please

[10:06] *** sivoais joined
[10:07] <moritz> it doesn't work that way the because context-anchoring the quasi is simply anchoring to the outer scope of the quasi, which is the state that $*W currently reflects

[10:07] <moritz> but for context-anchoring the unquote you need the context where the AST came from

[10:08] *** hypolin left
[10:08] <masak> right.

[10:08] <moritz> so, not the same thing at all

[10:08] *** Guest38681 left
[10:08] <masak> I think I need to do something when passing in the arguments, not where I'm doing it there.

[10:08] <masak> i.e. at (2)

[10:09] <moritz> that sounds sane

[10:10] <masak> let's jump straight to the deep-weird magic: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/World.pm#L837

[10:11] <masak> well, https://github.com/rakudo/rakudo/blob/nom/src/Perl6/World.pm#L834 , really.

[10:12] <moritz> looks... overwhelming at first, sensible but opaque at second glance

[10:12] <masak> this $*W method, add_quasi_fixups, takes a Perl6::AST and a block (an actual runtime block, I think), and says "hey $block, your outer is now what this Perl6::AST tells you it is!"

[10:13] <masak> in a sense, this is the invasive surgery version for ASTs of what falls out naturally with closures.

[10:14] <masak> again, the reason this has to be done is that AST fragments being passed back and forth between a macro and its calling context aren't meant to be evaluated in their surrounding context, but in the context where they were first built.

[10:15] <masak> and before macros, this never happens, because AST fragments don't move around like that in a pre-macros world.

[10:16] <masak> hm. correction. $block is a QAST::Block.

[10:16] *** spider-mario joined
[10:16] <moritz> right, doesn't need to be an actual Perl 6 level block

[10:16] <masak> jnthn spoke about the need to simultaneously think of code as text, AST, and runtime objects. I feel that now :)

[10:17] <masak> here's one of the three loci where $*W.add_quasi_fixups is called: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.pm#L3440

[10:18] *** dayangkun left
[10:18] <masak> (three loci because there are three ways to call a macro: paren call, listop call, and operator call. the code ought probably be unified into one code path.)

[10:19] <masak> as you see, that's pretty straightforward as well. the lines above wrap the QAST from the Perl6::AST into a block. the line in question "blesses" the block with the right context.

[10:20] * masak is a bit influenced by Io right now, and feels that the line between prototypal inheritance and lexical scoping has blurred

[10:21] <moritz> because both walk (outer/parent) chains?

[10:21] *** sivoais left
[10:21] <masak> right. inner scopes essentially perform a sort of differential inheritance on outer scopes.

[10:22] <masak> now, if instead of blindly copy-pasting code, I would attempt to blindly transfer the ideas across the itemized list of the gist... :)

[10:22] <masak> at (2), I need to correctly set the $!quasi_context of the Perl6::AST. man, that's a misleading attribute name.

[10:23] <moritz> it is, if you reuse it for that purpose

[10:23] <masak> at (3), I need to either make a call to $*W.add_quasi_fixups, or at least do the corresponding thing to what that method does.

[10:23] <masak> the method call is also misnamed. this is not about quasis at all.

[10:24] <moritz> I wonder if you can't do the call to add_quasi_fixups in (2) too

[10:24] <masak> I don't think so. I need to carry code around in a Perl6::AST until it's time to unpack it.

[10:25] <masak> and add_quasi_fixups is executed at unpack-time.

[10:25] <moritz> but in principle you already have all the necessary information in step (2), right?

[10:25] <masak> so, here's a better way to highlight the symmetry between macro arguments and macro return values: both are packed, and both are unpacked.

[10:26] <masak> so the order is: pack arguments, unpack arguments, pack return value, unpack return value.

[10:26] <moritz> so it's only a question of implementation where you put the 'unpack arguments' step

[10:26] <masak> moritz: yes. but there's some cloning of QAST trees going on here, so I don't think this is an over-complicated solution.

[10:27] <moritz> ok, I won't press the point

[10:28] <sjn> \o

[10:28] <sjn> moritz: any thoughts on architecture.html? :)

[10:30] <masak> moritz: the two {{{$code}}} insertions are a good example.

[10:30] <moritz> sjn: sorry, I totally forgot about that

[10:30] * sjn has at least one typo fix in the pipeline

[10:30] <masak> moritz: it turns into two identical but distinct AST fragments.

[10:30] <moritz> masak: oh, I didn't realize there were other operations that might not commute with the context fixing

[10:31] <moritz> "identical but distinct"?

[10:31] <moritz> did you mean s/identical/equivalent/ ?

[10:32] *** brrt left
[10:33] <masak> heh, yes. :) I hesitated for exactly the same reason when I wrote that.

[10:33] <masak> it's two equivalent subtrees with distinct-enough identities.

[10:33] <masak> (i.e. we can cheat and not clone everything if we know we can get away with it)

[10:34] *** leont left
[10:34] <masak> moritz: unless it's perfectly clear, this discussion helped *a lot*. thank you. I know what to try now.

[10:34] *** sivoais joined
[10:35] <moritz> you're very welcome

[10:35] <moritz> I learned that thunking with macros is easier than I feared

[10:35] <moritz> and a lost of other details

[10:36] <masak> heh, "a lost of other details" is how I feel about macros, too :P

[10:36] * masak .oO( how to get unstuck: (1) make a gist with a concrete example, (2) discuss it with moritz++, (3) ???, (4) profit! )

[10:41] <Juerd> .oO( WD40 )

[10:43] *** M_o_C joined
[10:48] *** pat_js joined
[10:48] <moritz> lunsj

[10:49] <tadzik> hello Ronja :)

[10:49] <masak> no, that's Norwegian ;)

[10:49] <pat_js> hey, how can i make hash slices in perl6 (equvalent to p5's @hash{qw[hello what is up]}

[10:50] <masak> r: my %hash = <hello 1 what 2 is 3 up 4 yo 5>; say %hash{<hello what is up>}.perl

[10:50] <p6eval> rakudo cc1858: OUTPUT«("1", "2", "3", "4")␤»

[10:51] <masak> that's one way.

[10:51] <masak> r: my %hash = <hello 1 what 2 is 3 up 4 yo 5>; say %hash<hello what is up>.perl

[10:51] <p6eval> rakudo cc1858: OUTPUT«("1", "2", "3", "4")␤»

[10:51] <masak> oh, that works too, of course.

[10:51] <pat_js> thanks, ok my problem is an other one.

[10:51] <masak> so the answer is, "just put several space-separated things in the <>"

[10:51] <masak> pat_js: hehe. X/Y. :P

[10:52] <pat_js> yeah thought that, but forgot that p6-objects aren't hashes anymore

[10:53] *** hoelzro|away is now known as hoelzro

[10:53] <masak> they may be, but you're not supposed to care anymore.

[10:54] <masak> that is, objects are opaque even if their repr is just a normal hash.

[10:54] <pat_js> i wanted to do sth. like DateTime.now<year month day hour minute second>»...

[10:55] <masak> r: say .year, .month, .day, .hour, .minute, .second given DateTime.now

[10:55] <p6eval> rakudo cc1858: OUTPUT«201295125520␤»

[10:55] <masak> r: (.say for .year, .month, .day, .hour, .minute, .second) given DateTime.now

[10:55] <p6eval> rakudo cc1858: OUTPUT«2012␤9␤5␤12␤55␤49␤»

[10:56] <cognominal> TimToady http://bigthink.com/ideas/21744   I suppose the transcription is wrong and you meant Cobol? "the old Cobalt (sic) language sort of had stock phrases that you plugged things into it, that was sort of cargo-cult natural language". Also the assertion should stand for AppleTalk?

[10:56] <masak> r: my $d = DateTime.new; say $d."$_"() for <year month day hour minute second>

[10:56] <p6eval> rakudo cc1858: OUTPUT«Int()␤1␤1␤0␤0␤0␤»

[10:56] <masak> hrm.

[10:57] <masak> r: my $d = DateTime.new; say $_ for <year month day hour minute second>

[10:57] <p6eval> rakudo cc1858: OUTPUT«year␤month␤day␤hour␤minute␤second␤»

[10:58] <masak> why doesn't the `$d."$_"()` variant work?

[10:59] *** daxim joined
[11:00] <dalek> rakudo/macros-d2: fa46512 | masak++ | src/ (2 files):

[11:00] <dalek> rakudo/macros-d2: Revert "halfway commit, does not work"

[11:00] <dalek> rakudo/macros-d2: 

[11:00] <dalek> rakudo/macros-d2: This reverts commit 1ac5431b62bd313bde32417e387881584ea291f3.

[11:00] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/fa46512654

[11:00] *** M_o_C left
[11:00] <masak> oh!

[11:01] <masak> r: my $d = DateTime.now; say $_ for <year month day hour minute second>

[11:01] <p6eval> rakudo cc1858: OUTPUT«year␤month␤day␤hour␤minute␤second␤»

[11:01] <masak> r: my $d = DateTime.now; say $d."$_"() for <year month day hour minute second>

[11:01] <p6eval> rakudo cc1858: OUTPUT«2012␤9␤5␤13␤1␤11␤»

[11:01] <masak> simple s/now/new/ typo :)

[11:02] <pat_js> p6eval: (given DateTime.now {.year,.month,.day,.hour,.minute,.second}).join('-') 

[11:03] <pat_js> but i could just use DateTime.now.Str instead

[11:03] <masak> r: say Date.new

[11:03] <p6eval> rakudo cc1858: OUTPUT«2012-12-24␤»

[11:03] <masak> moritz: it's a bit weird that we have this default for Date.new, but not for DateTime.new

[11:04] <masak> r: say DateTime.new.Date

[11:04] <p6eval> rakudo cc1858: OUTPUT«Cannot unbox a type object as a native int␤  in any  at src/gen/BOOTSTRAP.pm:97␤  in sub sprintf at src/gen/CORE.setting:2106␤  in method gist at src/gen/CORE.setting:11087␤  in sub say at src/gen/CORE.setting:7140␤  in block  at /tmp/Y2qX9eZb0D:1␤␤»

[11:04] <masak> oh wow.

[11:04] <masak> we have some ways to go to get proper type conversion.

[11:04] <masak> a DateTime should effortlessly convert to a Date, IMO.

[11:04] * masak submits rakudobug

[11:13] *** Gesh left
[11:15] *** Gesh joined
[11:21] *** JimmyZ joined
[11:28] <moritz> r: say DateTime.new

[11:28] <p6eval> rakudo cc1858: OUTPUT«use of uninitialized value of type Int in string context  in block  at /tmp/7kDir3GHgy:1␤␤DateTime.new(year => , month => 1, day => 1, hour => 0, minute => 0, second => 0/1)␤»

[11:32] *** sisar left
[11:34] <moritz> sjn: re architecture.html, looks good

[11:36] <moritz> it still doesn't quite capture how actions and grammar are interleaved, but it's better than before

[11:36] *** hoelzro is now known as hoelzro|away

[11:37] *** Cofyc left
[11:41] <sjn> moritz: I'd love to look into that, if I can have someone's time to probe and ask stupid quesions :)

[11:43] <moritz> "The Parser creates a parse tree out of the Perl 6 source code and then gives control to appropriate action methods that annotate the parse tree"

[11:44] <moritz> Might be better to say "For each syntactic rule, the parser creates a ..."

[11:44] *** brrt joined
[11:44] <moritz> so that it's clear that the scope for that step is rather small

[11:44] *** jaldhar_ is now known as jaldhar

[11:44] <moritz> the next sentence makes it clearer, but I think by that time the reader already has an inaccurate image in his head

[11:45] <FROGGS> r: say DateTime.new( now )

[11:45] <p6eval> rakudo cc1858: OUTPUT«DateTime.new(year => 2012, month => 9, day => 5, hour => 11, minute => 45, second => 19.640998840332e0)␤»

[11:45] <FROGGS> thats what I would expect to get when just calling new

[11:46] <moritz> r: say DateTime.now

[11:46] <p6eval> rakudo cc1858: OUTPUT«DateTime.new(year => 2012, month => 9, day => 5, hour => 13, minute => 46, second => 0, timezone => $*TZ)␤»

[11:46] <moritz> that's what I would expect you to write if that's what you mean

[11:46] <masak> hm, micro-nit: "parser" should not be spelled with a capital "P", unless it's revered or holy in some way.

[11:46] <moritz> aye

[11:47] <FROGGS> but IMO DateTime.new should be the same like DateTime.now, when passing no args

[11:47] *** JimmyZ left
[11:48] <masak> same argument could be made for Date.new and Date.today, I guess.

[11:48] <pmichaud> good morning, #perl6

[11:48] <FROGGS> r: say Date.new

[11:48] <masak> pmichaud! \o/

[11:48] <p6eval> rakudo cc1858: OUTPUT«2012-12-24␤»

[11:48] <masak> so there are three symmetry relations here.

[11:48] <FROGGS> r: say Date.today

[11:48] <p6eval> rakudo cc1858: OUTPUT«2012-09-05␤»

[11:49] <masak> Date.new<->Date.today, DateTime.new<->DateTime.now, and Date.new<->DateTime.new

[11:49] <FROGGS> Date.new gives me december the 24th?

[11:49] <moritz> next Christmas eve

[11:49] <FROGGS> but why?

[11:49] <masak> seems to me we need either back down on Date.new being next Christmas eve (and make it today), or make DateTime.new next Christmas eve, too.

[11:50] <moritz> a Christmas egg :-)

[11:50] <masak> FROGGS: because you didn't specify the date.

[11:50] <moritz> FROGGS: you asked for a Date, and I gave you one

[11:50] <FROGGS> pah

[11:50] <FROGGS> so Int x; might give me 42?

[11:50] <moritz> no, there's a very precise spec for that

[11:50] <masak> FROGGS: Int has a natural origin. Date doesn't.

[11:51] <moritz> nr: my Int $x; say $x.perl

[11:51] <p6eval> rakudo cc1858, niecza v21-1-ga8aa70b: OUTPUT«Int␤»

[11:51] <moritz> nr: my Date $x; say $x.perl

[11:51] <p6eval> rakudo cc1858: OUTPUT«Date␤»

[11:51] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed my at /tmp/UDQQ0IFpmI line 1:␤------> [32mmy[33m⏏[31m Date $x; say $x.perl[0m␤␤Parse failed␤␤»

[11:51] <masak> FROGGS: it's a slightly frivolous way to discourage use of Date.new -- we consider Date.today to be clearer.

[11:51] <FROGGS> well, somebody could say that beginning of unix epoch might be the natural origin...

[11:51] <FROGGS> (for unix ppl)

[11:52] <masak> FROGGS: somebody else could say that the birth of Mohammed might be the natural origin. for Muslim ppl.

[11:52] <pmichaud> the beginning of the Perl epoch might be more natural.  :-)

[11:52] <FROGGS> hehe, ya

[11:52] <moritz> and so we return the old joke about the Perl 6 release date

[11:52] <masak> FROGGS: or the formation of the solar system. that's a pretty special date.

[11:52] <moritz> or of the Universe

[11:52] <masak> r: say Date.new(-13e9, 1, 1)

[11:53] <p6eval> rakudo cc1858: OUTPUT«Type check failed in assignment to '$!year'; expected 'Int' but got 'Num'␤  in block  at src/gen/CORE.setting:656␤  in method BUILDALL at src/gen/CORE.setting:640␤  in method bless at src/gen/CORE.setting:630␤  in method new at src/gen/CORE.setting:11005␤  in metho…

[11:53] <FROGGS> its just that "time" gives me the current time, I expected DateTime.new to give me the same

[11:53] <masak> heh :)

[11:53] <moritz> we just don't want to change our code whenever there's a new scientific paper on the age of either

[11:53] <masak> r: say Date.new(-13_000_000_000, 1, 1)

[11:53] <p6eval> rakudo cc1858: OUTPUT«-115098112-01-01␤»

[11:53] <masak> o.O

[11:53] <moritz> r: say Date.new(-13_000_000_000, 1, 1).day-of-week

[11:53] <p6eval> rakudo cc1858: OUTPUT«7␤»

[11:53] <masak> haha

[11:53] * masak .oO( and God rested )

[11:53] <FROGGS> *g*

[11:54] <masak> I suppose -115098112 above is a bug?

[11:54] <masak> r: say -13_000_000_000

[11:54] <p6eval> rakudo cc1858: OUTPUT«-13000000000␤»

[11:54] * masak submits rakudobug

[11:57] * flussence tries "printf '@%024d' 0 | tai64nlocal" and gets a segfault ...guess 96 bits isn't enough for everyone. :)

[12:02] *** mtk left
[12:04] *** lizmat joined
[12:09] *** mtk joined
[12:14] *** jaldhar left
[12:21] <masak> ah yes.

[12:21] <masak> add_macro_arguments in Perl6::Actions creates Perl6::AST objects, and gives them $!past attribute values, but not $!quasi_context attribute values.

[12:22] <masak> from a more modern, enlightened viewpoint, that is clearly Wrong.

[12:23] *** sisar joined
[12:24] <mst> POSTing upload for Rakudo-Star-2012.08_001.tar.gz

[12:25] <mst> now with more installing to the right f*cking place :)

[12:25] <masak> mst++

[12:28] *** spider-mario left
[12:31] <dalek> ecosystem: b2abe53 | (Yecheng Fu)++ | META.list:

[12:31] <dalek> ecosystem: Add Redis module.

[12:31] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/b2abe531eb

[12:31] <dalek> ecosystem: 66171fe | tadzik++ | META.list:

[12:31] <dalek> ecosystem: Merge pull request #11 from Cofyc/redis

[12:31] <dalek> ecosystem: 

[12:31] <dalek> ecosystem: Add Redis module.

[12:31] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/66171febc0

[12:32] <masak> whoa, redis!

[12:32] <masak> is Yecheng Fu on #perl6?

[12:32] <tadzik> we now have 2 redis drivers, but this one is said to work on new Star :)

[12:35] *** dayangkun joined
[12:36] <[Coke]> MikeFair_: (error) the partcl-nqp/nqp2 branch is now building, yes. (it only understands one command, "three", which returns a 3. more to come.)

[12:36] <tadzik> :)

[12:37] <moritz> but it's a very useful command :-)

[12:37] <flussence> that reminds me, I've got a perfectly good repo sitting all alone on github that I've been meaning to add...

[12:38] * moritz considers uploading Acme::Three

[12:38] <dalek> ecosystem: 92e7ceb | flussence++ | META.list:

[12:38] <dalek> ecosystem: Add XMMS2 module

[12:38] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/92e7ceb5b8

[12:39] <moritz> nr: class My::3ish { }

[12:39] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Name My:: ends with '::' and cannot be used as a package name␤»

[12:39] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Illegal explicit declaration of a symbol table at /tmp/TeAuZ9VK8_ line 1:␤------> [32mclass My::[33m⏏[31m3ish { }[0m␤␤Unable to parse class definition at /tmp/TeAuZ9VK8_ line 1:␤------> [32mclass My::[33m⏏[31m3ish { }…

[12:39] <moritz> eval: package My::3ish;

[12:39] <buubot_backup> moritz: No output.

[12:39] <moritz> p5 allows that

[12:39] * moritz learned that while appling for a job at 123people.com

[12:40] <masak> moritz: it was an interview question?

[12:40] <masak> well, with that company name, they should know :P

[12:41] <moritz> masak: no, just normal conversation

[12:41] *** PacoAir joined
[12:42] <flussence> I'm curious, has anything in an Acme:: module ever been promoted into core p5? :)

[12:43] *** sbp joined
[12:44] *** sbp left
[12:46] <moritz> I don't think so

[12:46] <moritz> but last I looked, there were two Acme:: modules included in Debian stable

[12:47] *** Targen left
[12:49] *** snearch joined
[12:52] * moritz chases a change in behavior of a CPAN module

[12:52] <moritz> the release that changed in an incompatible way was issues in 2008.

[12:56] *** ijkkk joined
[12:58] *** guest01 joined
[12:59] *** ijkkk left
[12:59] <[Coke]> oh, redis++ . we are now one step closer to letting me use perl6 at work. ;)

[13:01] <colomon> \o/

[13:01] *** guest01 left
[13:01] <[Coke]> nqp: pir::sleep__vN(1)

[13:01] <p6eval> nqp:  ( no output )

[13:02] <[Coke]> I am stunned this works, as: https://github.com/partcl/partcl-nqp/commit/5a368f7cfc was needed to make that file compile.

[13:02] <[Coke]> the --target=pir worked but trying to "use" it later failed.

[13:02] * colomon is taking his $work p6 involvement to new levels with https://github.com/colomon/perl6-ISO_10303-21 and wishes he had time to do a blog post on it.

[13:04] * masak is making progress

[13:04] <FROGGS> progress++

[13:06] *** kaleem left
[13:06] <masak> 'maximum recursion depth exceeded' -- dang. seems I jinxed the progress.

[13:06] <sjn> so...

[13:06] <sjn> Anyone want to give me a short and sensible (beginner-level) definition of what a "parse tree" is? :)

[13:07] <arnsholt> It's a tree describing a parse O:)

[13:07] <sjn> hehe

[13:07] <arnsholt> But more seriously

[13:07] <PerlJam> sjn: did you ever have t o do those sentence diagrams in English class where  they said "this is the noun, this the verb, etc." ? 

[13:08] <arnsholt> Given a rule A -> B C D, the root node will be labelled A and have three children labelled B, C and D

[13:08] <sjn> a parsemonius definition if there ever was one :)

[13:08] <sjn> PerlJam: nah

[13:08] <arnsholt> Essentially, it describes the decisions the parser made to create the parse

[13:09] <masak> sjn: imagine the string to be parsed divided into "regions" of what goes with what. like "5 + 5 * 10" gets divided like this: "(5 + (5 * 10))". the tree is just a representation of that definition.

[13:09] <masak> s/definition/division/

[13:10] <masak> so, from a procedural point of view, the parse tree tells you which pieces of the text are related.

[13:11] * sjn vaguely remembers polish notation being a good way of illustrating the tree stucture in code. E.g. (+ 5 (* 5 10))

[13:11] <masak> an AST for the above would be something like :add[ :const(5), :multiply[ :const(5), :const(10) ]]

[13:11] <sjn> lisp++ # teachability

[13:11] <masak> sjn: aye, what you just wrote and what I just wrote are isomorphic.

[13:12] <frettled> RPN++ # practical for calculations when you've learned it

[13:12] <frettled> But now sjn++ got me wondering what reverse Hungarian notation would look like.

[13:13] <colomon> sumPI

[13:13] *** bluescreen10 joined
[13:13] <colomon> .... actually, I kind of prefer that to normal Hungarian notation.

[13:14] <sjn> hungarian notation, eh :-6

[13:15] * sjn can't imagine reversing it would ever improve it :)

[13:15] <masak> frettled: reverse hungarian notation must be what some BASIC dialects use for typing: A$ for strings, etc.

[13:15] <moritz> double-reversed hungarian notation \o/

[13:15] <frettled> ho ho ho

[13:16] <frettled> moritz: what about out-of-order Hungarian notation?

[13:16] *** PacoAir left
[13:17] <moritz> if it's out of order, I don't care for it. I have enough trouble keeping up with all the working notations :-)

[13:18] <frettled> Massively parallel notation?

[13:18] <masak> moritz: how do I refer to an nqp class such as QAST::Block from the setting? is there prior art?

[13:18] *** PacoAir joined
[13:18] *** PacoAir left
[13:18] <moritz> masak: erm, you (almost certainly) don't. What are you trying to do?

[13:19] *** PacoAir joined
[13:19] <frettled> sjn: on a more serious note: is that explanation going to be made for Norwegians, native English-speakers, non-native English-speakers, or some other language group?  And is that going to be a written explanation, an illustrated one, or a verbal explanation?

[13:19] <frettled> verbal?  yikes, Norwenglish FTW.

[13:20] <masak> in the method evaluate_unquotes in core/AST.pm, I need to wrap the QAST contained in $!past in a QAST::Block and a QAST::Stmts before I pass it on to $!past.evaluate_unquotes

[13:20] <masak> moritz: this is the "unpack arguments" step I mentioned above.

[13:21] <masak> i.e. as part of the unpacking, I need to wrap the QAST tree in a QAST::Block, and twiddle the context of that QAST::Block.

[13:21] <moritz> masak: make the wrapping a method in whatever object is in $!past ?

[13:21] <sergot> I need some help. :)

[13:21] <moritz> (maybe QAST::Node)

[13:21] <masak> moritz: there are arbitrary QAST objects in $!past.

[13:21] <masak> moritz: that sounds like a good idea.

[13:21] <frettled> sjn: I think Wikipedia's explanation is fairly okay, FWIW: http://en.wikipedia.org/wiki/Parse_tree

[13:22] *** pat_js left
[13:22] <moritz> sergot: then shout HALP! HALP! and run around in circles

[13:22] <moritz> or ask your question here :-)

[13:22] <masak> moritz: there's also a call to $*W.add_quasi_fixups in there. that's the twiddling part.

[13:22] <masak> moritz: calling $*W from core feels even more wrong.

[13:22] <masak> moritz: but I might simply inline that logic.

[13:23] <sergot> I'm working on an article titled "Who may I speak with?" - where I'll write some information about people connected to Perl 6 and theirs responsibilities.

[13:23] <sergot> e.g.

[13:23] <PerlJam> sergot++

[13:23] <sergot> Juerd, moritz are responsible for feathers.

[13:23] <masak> sorear: "feather", not "feathers" :)

[13:23] <Juerd> Responsible? :|

[13:23] <moritz> feathers

[13:23] <PerlJam> masak: there is more than one :)

[13:24] <moritz> there are 3.5 of them

[13:24] <masak> fairenuf.

[13:24] <Juerd> moritz: .5?

[13:24] <masak> sorear: oops, sorry, mistab. :/

[13:24] <moritz> Juerd: I count the host for the VMs as .5

[13:24] <sergot> "You my talk to them to ... get an account on feather.perl6.nl"

[13:24] <Juerd> moritz: That one isn't feather specific anymore.

[13:24] <moritz> Juerd: oh, so 3 it is

[13:24] <Juerd> moritz: Feather[123] now run on a shared virtual hosting platform

[13:25] <masak> sergot: also, the title sounds slightly off to my (non-native) ears. maybe "Who can I talk to?"

[13:25] <sirrobert> hi =)

[13:25] <tadzik> or just "who is who"

[13:25] <masak> sergot: "Who may I speak with?" sounds like we mostly don't allow people to speak to us :)

[13:25] <sergot> masak: Yes, that sounds better. :)

[13:25] <moritz> shouldn't that be "Whom can I talk to?" :-)

[13:25] <moritz> \o sirrobert 

[13:26] <sergot> o/ sirrobert

[13:26] <masak> moritz: yes, in a world where people still care about the word "whom" :P

[13:26] <PerlJam> How about just "Help!"  :)

[13:26] <masak> "Halp!"

[13:26] <sergot> nevertheless that's not the point. :D

[13:26] <masak> "People who know stuff"

[13:26] <PerlJam> People. Stuff.  Perl 6.

[13:27] <sergot> You know better than me who is responsible for. :)

[13:27] <Juerd> What's this in /etc/sudoers?

[13:27] <Juerd> # for some community games and stuff

[13:27] <Juerd> ALL ALL=(nobody) ALL

[13:27] <daxim> Butterfly. Onion. Beer.

[13:27] <masak> sergot: you came with an idea for a useful document and expected us *not* to bikeshed over the name? :P

[13:27] <masak> daxim: tits. onion. trash.

[13:27] <sirrobert> heh

[13:27] <masak> daxim: FIVE!

[13:27] <PerlJam> more like punning than bikeshedding.

[13:27] <PerlJam> But there's a fine line.

[13:28] *** marmay left
[13:28] <Juerd> I think the fine line should be green

[13:28] <PerlJam> blue!

[13:29] <Juerd> Compromise on teal?

[13:29] <PerlJam> :)

[13:29] <flussence> oh wow, rakudo just compiled without me having to hack the makefile!

[13:30] <Juerd> Blog it!

[13:30] <sergot> masak: of course You can do this. :P

[13:30] <sergot> masak: I just wanted to start writing. :)

[13:30] <arnsholt> flussence: Which platform have you been having trouble on?

[13:31] <flussence> x86-32 gentoo with 1GB RAM

[13:31] <PerlJam> "And then there's sergot ... he just wanted to start writing and now look what's happened!"

[13:31] <sirrobert> it's extremely awesome that eval closes over sub refs

[13:31] <sirrobert> ++whoever-did-that

[13:31] <sirrobert> karma whoever-did-that

[13:31] <aloha> whoever-did-that has karma of 0.

[13:31] <sjn> frettled: the explanation is for $anyone who's interested in rakudo/docs/architecture.html :)

[13:32] <moritz> sirrobert: we only give out pre-increment karma for stuff people have promised to do

[13:32] <flussence> (not really 1GB either, since chrome's eating 150MB of that)

[13:32] <sirrobert> moritz: ahh =)

[13:32] <moritz> sirrobert: and postfix ++ for things that have actually been done

[13:32] <masak> sirrobert: (re eval closing over sub refs) we do like lexical scoping in here.

[13:32] <sirrobert> heh

[13:32] <flussence> who do I postfix:<++> for having a working perl6 again? :D

[13:32] *** sisar left
[13:32] <moritz> flussence: jnthn++ found a fix for some GC trouble in NQP

[13:32] <flussence> jnthn++

[13:33] <arnsholt> Right. 1 gig of RAM, I can see how that might be tricky =)

[13:33] <sirrobert> fluessence: did it compile with <1GB?

[13:34] <arnsholt> 32-bit has smaller pointers, so that'll help a bit compared to 64-bit, but I can imagine it'd be a bit cramped for physical memory

[13:35] <flussence> sirrobert: it used to, but it was broken for a few months after parrot 4.$someversion

[13:35] *** GlitchMr joined
[13:35] * sjn wonders if the glossary definition for NQP could be improved: "NQP: Not Quite Perl 6, a small subset of Perl 6 that is used for tree transformations in compilers."

[13:35] <flussence> it just worked now

[13:36] <sirrobert> fluessence: nice!  That's been a little hangup for a co-worker of mine

[13:36] <mst> sjn: you there

[13:36] <sirrobert> was compiling on my computer with a matching disk image and porting it over

[13:36] <sjn> Where can one read up on what NQP can do?

[13:36] <sjn> mst: I'm here! \o/

[13:36] <mst> sjn: cpan/cpanm http://trout.me.uk/perl/Rakudo-Star-2012.08_001.tar.gz please

[13:36] <moritz> in the source

[13:36] <mst> sjn: then try 'eval $(perl -MRakudo::Star::Paths); perl6'

[13:36] <mst> sjn: and see if it works

[13:37] <sjn> clever :)

[13:37] * sjn checks

[13:39] *** Chillance joined
[13:39] <sjn> moritz: hm. nothing in prose? :-/

[13:42] <sergot> moritz: who else is responsible for feather.perl6.nl

[13:43] <mst> sjn: I'm hoping 002 can lose the _ :)

[13:43] <masak> moritz: ugh. adding that method to QAST::Node feels Wrong for two reasons. (1) the classes QAST::Block and QAST::Stmts need to be stubbed in QAST::Node's file, which is at least a code smell.

[13:43] <PerlJam> sergot: define "responsible"

[13:43] <masak> (2) there are ties to Perl6::World's .add_fixup_task, which I don't seem to be able to get rid of.

[13:44] <PerlJam> sergot: in some sense everyone who has an account on feather is responsible for it.

[13:44] <sergot> PerlJam: I mean who can create an account there. :)

[13:44] <arnsholt> sjn: I'm not aware of any significant docs for NQP. When I've been dabbling it's been mostly finding similar stuff in the NQP or Rakudo sources

[13:44] <sjn> hm

[13:44] <sjn> ok

[13:45] <PerlJam> Didn't pmichaud start an NQP book at one point?

[13:45] <moritz> PerlJam: yes, but last I looked it was empty

[13:45] <moritz> masak: point taken

[13:45] <mst> PerlJam: could I put upon you to test the dist as well please?

[13:45] <sergot> The same with perl6 organization on github - who can give an access?

[13:46] *** fhelmberger left
[13:46] <PerlJam> mst: sure

[13:46] *** stopbit joined
[13:46] <moritz> masak: other code from the setting that calls back into the compiler goes through pir::compreg__Ps('perl6') (which gets the Perl6::Compiler object). Not sure if that's of any help

[13:46] <mst> PerlJam: preferably into a perlbrewed perl since that's what went wrong for leont yesterday

[13:46] <mst> PerlJam: I'm pretty sure local::lib installs are fine

[13:47] <moritz> sergot: (re perl6 organization) iirc it's TimToady, pmichaud, jnthn, sorear and me

[13:47] <moritz> and it used to work via hugme, but I think it bitrotted

[13:49] <masak> moritz: thanks. I might have a look at how those other bits do it, and if I can do the same.

[13:49] <masak> moritz: I'm very much inclined to make something work now, and put the bits in more appropriate places later.

[13:50] <moritz> masak: fwiw I'm aware of two such bits, &eval (in src/core/control.pm) and the backtrace printer (src/core/Exception.pm)

[13:50] <masak> oh, ok.

[13:50] <moritz> another evil idea

[13:50] <moritz> write a sub that does in the actions

[13:50] <sergot> moritz++ thanks

[13:50] <moritz> and assign it to a contextual variable

[13:50] <moritz> and invoke that from within the setting

[13:54] <masak> could work.

[13:54] <masak> moritz++

[13:55] <masak> kind of like a dynamically accessed closure.

[13:55] *** Chillance left
[13:55] *** skids joined
[13:56] <moritz> don't tell anybody it was my idea :-)

[13:57] <sjn> quick! kill the irc logger! :)

[13:58] *** FROGGS__ left
[13:58] *** FROGGS left
[13:59] <sergot> Who is the head rakudo's developer? :)

[13:59] *** gongyiliao left
[13:59] *** FROGGS__ joined
[14:00] <sirrobert> moritz?

[14:00] <sirrobert> I think

[14:00] <[Coke]> I think it's a tie between jnthn & pmichaud.

[14:00] <sirrobert> oh =)

[14:00] <[Coke]> moritz++ is up there.

[14:00] <sergot> So, those 3? :)

[14:00] <sergot> these(?)

[14:00] <sirrobert> those

[14:01] *** tokuhiro_ joined
[14:01] <moritz> sergot: pmichaud is

[14:02] *** benabik left
[14:02] <[Coke]> huh. I just got an offer for 100$ of free advertising from google. Wonder if I can use it for perl6.

[14:02] <mst> sjn: still installing?

[14:02] <sergot> moritz: only he?

[14:02] <kresike> bye folks

[14:02] *** Chillance joined
[14:02] *** kresike left
[14:02] *** nickA joined
[14:02] <moritz> sergot: well, he's the project leader

[14:03] <moritz> and pmichaud and jnthn implement most of the features

[14:03] <moritz> I make many commits too, but mostly small (or mechanic) stuff

[14:03] <sjn> mst: yeah, my computer is slow :-\

[14:03] <mst> sjn: 's cool, was just checking

[14:03] <mst> sjn: I'll have to bounce shortly but /msg me the outcome :)

[14:04] <masak> sergot: pmichaud is the project leader. during the later parts of the nom refactor, and the time following it, jnthn was doing most of the commits on Rakudo.

[14:04] <sjn> running tests now

[14:04] <sergot> What is masak "responsible" for? :)

[14:04] *** dayangkun left
[14:05] <moritz> breaking stuff

[14:05] <moritz> and submitting reports

[14:05] <moritz> and macros

[14:05] <mst> sjn: ooh, then it's almost done :)

[14:05] <nickA> hi perl6.what's the diffrence between #my ($a,$b) = ('a','b')>>.IO>>.open; 

[14:05] <nickA> my ($a,$b) = ('a','b')>>.IO.open; 

[14:05] <mst> sergot: we prefer to say "blamed" ;)

[14:05] <sergot> hah, so s/responsible/blamed/ :)

[14:05] <moritz> nickA: the latter calls .open on a list of IO objects

[14:06] <masak> sergot: I'm more irresponsible than responsible, actually.

[14:06] <moritz> nickA: and fails, because there's no such method open

[14:06] <sergot> And for YAPSI, right? :)

[14:06] <nickA> moritz:why it fail?my ($a,$b) = ('a','b')>>.IO.open; 

[14:07] <masak> sergot: yeah. I should probably get my vast development team to start releasing Yapsi regularly again.

[14:07] <sergot> masak++ : very good idea. :)

[14:07] <sirrobert> nickA:  ('a','b')>>.IO creates a list of IO objects after 'a' and 'b'

[14:07] <GlitchMr> nickA: It means my ($a, $b) = (('a', 'b')>>.IO).open

[14:07] <moritz> nickA: because there's no method 'open' in class List

[14:07] <[Coke]> nqp: say(nqp::new('OS').'cwd'();

[14:07] <p6eval> nqp: OUTPUT«Confused at line 2, near "say(nqp::n"␤current instr.: 'panic' pc 19998 (src/stage2/gen/NQPHLL.pir:7314) (src/stage2/gen/NQPHLL.pm:325)␤»

[14:07] <sirrobert> nickA: .open is not a list method

[14:07] <GlitchMr> So it .opens list, not IO

[14:08] <[Coke]> nqp: say(nqp::new('OS').'cwd'());

[14:08] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op call: Error while compiling op callmethod: Error while compiling op new: No registered operation handler for 'new'␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[14:08] <moritz> nqp: say(pir::new__Ps('OS').cwd())

[14:08] <p6eval> nqp: OUTPUT«Class 'OS' not found␤current instr.: '' pc 49 ((file unknown):161309279) (/tmp/19wb6fbgKr:7)␤»

[14:08] <[Coke]> nqp: say(nqp::new('OS').'cwd'()); INIT { nqp::loadlib('OS'); }

[14:08] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op loadlib: No registered operation handler for 'loadlib'␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[14:08] <moritz> nqp: say(pir::new__Ps('os').cwd())

[14:08] <p6eval> nqp: OUTPUT«Class 'os' not found␤current instr.: '' pc 49 ((file unknown):167322207) (/tmp/blU32xIoi_:8)␤»

[14:08] <moritz> nqp: nqp::loadlib('os'); say(pir::new__Ps('OS').cwd())

[14:08] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op loadlib: No registered operation handler for 'loadlib'␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[14:09] <moritz> nqp: pir::loadlib__vs('os'); say(pir::new__Ps('OS').cwd())

[14:09] <p6eval> nqp: OUTPUT«error:imcc:The opcode 'loadlib_sc' (loadlib<1>) was not found. Check the type and number of the arguments␤  in file '(file unknown)' line 167980855␤»

[14:09] <GlitchMr> ('a', 'b')>>.IO.open working as ('a', 'b')>>.IO>>.open would be nice, but it's probably too late for that

[14:09] <mst> sjn: tests finished?

[14:09] <[Coke]> moritz: fun, innit! ;)

[14:09] <moritz> nqp: pir::loadlib__Ps('os'); say(pir::new__Ps('OS').cwd())

[14:09] <p6eval> nqp: OUTPUT«/home/p6eval␤»

[14:09] <moritz> [Coke]: there ya go

[14:09] <moritz> [Coke]: I guess there won't be nqp:: opcodes for that, because it's very parrot-specific

[14:10] <sjn> mst: yeah, installing now

[14:10] <nickA> any GlitchMr:why you say that?

[14:10] <mst> sjn: \o/

[14:10] <PerlJam> mst: Successfully installed Rakudo-Star-2012.08_001

[14:10] <nickA> GlitchMr:why you say that?

[14:11] <sergot> Is there any person who is blamed for official Perl 6 doc? TimToady? :)

[14:11] <PerlJam> mst: that's on my perlbrewed perl 5.16.0

[14:11] <mst> PerlJam: right. does 'eval $(perl -MRakudo::Star::Paths); perl6' work?

[14:11] *** oops left
[14:11] *** FROGGS joined
[14:11] <moritz> sergot: I'm irresponsible for doc.perl6.org, kinda

[14:11] <PerlJam> mst: yep

[14:11] <sjn> mst: it works! :)

[14:11] <GlitchMr> Rakudo::Star on CPAN?

[14:11] <mst> \o/

[14:11] <mst> GlitchMr: that's what I've been working on :)

[14:12] <PerlJam> mst++ quite awesome.

[14:12] <GlitchMr> Well, I find it nice... but Rakudo::Star doesn't have anything with Perl 5, does it?

[14:12] <PerlJam> GlitchMr: yet

[14:12] <frettled> mst++ very nice

[14:13] <mst> GlitchMr: I'm going to be writing an http://perl.org/Object::Remote backend for rakudo

[14:13] <mst> GlitchMr: so you can do Some::Perl6::Class->new::on(v6, @constructor_args);

[14:13] <mst> GlitchMr: I figured that that would be more fun if people could get all their deps via CPAN, including rakudo

[14:13] <GlitchMr> oh, ok

[14:13] <GlitchMr> This would be fun

[14:14] <masak> "Namespaces are obsolete". a programming language design opinion. http://weblogs.asp.net/bleroy/archive/2012/09/03/namespaces-are-obsolete.aspx -- what do y'all think?

[14:14] <sjn> mst: perl6-debug works too

[14:14] <mst> sjn: I've not done anything particularly clever; if it works at all, I'd hope it works entirely :)

[14:14] <mst> sjn: however, please od play in case I'm wrong :)

[14:15] <[Coke]> nqp: pir::loadlib__Ps('os'); say (nqp::new('OS').cwd())

[14:15] <p6eval> nqp: OUTPUT«Confused at line 2, near "say (nqp::"␤current instr.: 'panic' pc 19998 (src/stage2/gen/NQPHLL.pir:7314) (src/stage2/gen/NQPHLL.pm:325)␤»

[14:15] * sjn wonders where the Perl6 modules are installed

[14:15] <mst> sjn: it's all under the Rakudo/Star/Install/ directory

[14:15] <GlitchMr> Cannot you do stuff like import __future__ as __past__ in Python too?

[14:15] <[Coke]> ah well.

[14:17] <moritz> [Coke]: space after 'say'

[14:17] <moritz> nqp: pir::loadlib__Ps('os'); say(nqp::new('OS').cwd())

[14:17] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op call: Error while compiling op callmethod: Error while compiling op new: No registered operation handler for 'new'␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[14:17] *** mucker joined
[14:18] <sirrobert> masak: I like the picture.  I *really* like Node's package management as well.  I'm not sure what the impact is on namespacing in general, but I do like the pattern a lot.

[14:19] <moritz> masak: Perl 6 goes a bit into the "deprecate namspaces" direction by doing much more lexically than Perl 5

[14:20] <sergot> Who is mostly irresponsible for p6eval?

[14:20] <moritz> sergot: sorear and me (mostly me)

[14:21] <masak> moritz: right. seems to me the post is advocating replacing namespaces by... lexical scoping.

[14:22] <nickA> so ?any other code for this my ($a,$b) = ('a','b')>>.IO>>.open; if I want to write it one line?

[14:23] <mst> you still need something approximating it though

[14:23] <[Coke]> moritz: that's one 3 line file reclaimed. thanks. ;)

[14:23] <mst> "I want to import X from Y" requires some way of finding Y

[14:23] <sirrobert> r: :test

[14:23] <p6eval> rakudo cc1858:  ( no output )

[14:23] <sirrobert> r: say :test.WHAT

[14:23] <p6eval> rakudo cc1858: OUTPUT«Pair()␤»

[14:23] <sirrobert> what's the intended purpose of that?

[14:23] <moritz> [Coke]: you're welcome

[14:23] <masak> mst: troo.

[14:23] *** jaldhar joined
[14:24] <sirrobert> r: say :test

[14:24] <p6eval> rakudo cc1858: OUTPUT«␤»

[14:24] <moritz> nickA: my ($a, $b) = <a b>.map: *.IO.open;

[14:24] <mst> masak: I quite like doing 'use aliased "Some::Namespace::Containing::AClass";'

[14:24] <mst> masak: and then doing AClass->new(...)

[14:24] <sirrobert> err.. that it puts:  'test' => Bool::True

[14:24] <nickA> moritz:wonderful!thanks!

[14:24] *** oops joined
[14:24] <mst> masak: that way the name is only used once

[14:25] <moritz> sirrobert: note that :test is a named argument

[14:25] <moritz> nr: say (:test); # positional argument

[14:25] <p6eval> rakudo cc1858, niecza v21-1-ga8aa70b: OUTPUT«"test" => Bool::True␤»

[14:25] <masak> mst: nice! I want https://metacpan.org/module/aliased for Perl 6 now.

[14:25] <sirrobert> moritz: used outside of that context it's the same?

[14:25] <sirrobert> I'm cool with that, just trying to understand =)

[14:25] <nickA> bye perl6 ! thanks your help!

[14:25] *** nickA left
[14:26] *** tokuhiro_ left
[14:26] *** atrodo joined
[14:26] <sirrobert> moritz: ah, I see it better now.  thanks

[14:27] <[Coke]> BY THE POWER OF PERLSIX!

[14:27] <moritz> sirrobert: the difference is only in argument lists

[14:28] <sirrobert> ok

[14:28] <moritz> masak: I'm pretty sure I could make that happen by patching rakudo. Not sure about a separate module.

[14:29] *** wtw left
[14:30] <masak> hm.

[14:31] <sergot> Who is irresp* for perl6 wiki, p6 on rosettacode, perl6 book? :)

[14:31] <mst> sergot: why does this matter?

[14:32] <mst> sergot: generally it being an open source project "whoever's had time and thought it looked like fun to work on"

[14:32] <[Coke]> the "who to talk to" can be summed up with "this irc channel" for now.

[14:33] * TimToady is mostly responsible for the p6 rosettacode stuff

[14:33] <masak> I agree with mst when it comes to wikis. the idea of wikis is that anyone with tuits can be responsible for the content.

[14:33] <moritz> sergot: uvtc did much of the wiki stuff. The perl 6 book is dead, I'm afraid

[14:33] <masak> who is taking charge at the moment is largely ephemeral and irrelevant. maybe even harmful to note it down.

[14:33] <TimToady> but there must generally be a champion until you get critical mass

[14:34] <masak> aye.

[14:34] <sergot> I know, but if someone new (begginer) or from "outside" wants to know or do something, he can ask for sth particular person. :)

[14:34] <sergot> that was to mst. :)

[14:35] <PerlJam> sergot: if he shows up here, he/she can ask anyone and get help 

[14:35] <sergot> That's right.

[14:35] <TimToady> which is why IRC is nice, because nobody can be on on the time, and some info is better than none

[14:36] <sergot> If someone has an idea about panda, he can write straight to tadzik.

[14:36] <[Coke]> and I'd rather folks came here with questions than pinged pmichaud directly.

[14:36] <TimToady> there are many answers of the form "I think it works like this, but ask such and so for more"

[14:36] <[Coke]> sergot: that's not always a good thing.

[14:37] <TimToady> we try to turn the knob to a point where we rarely have to tell someone "I'm too busy"

[14:37] <[Coke]> if you said "see timtoady about the spec" and folks did that directly, how much of his tuits does that eat into?

[14:37] <sergot> So there's no need to write this article. :)

[14:37] <masak> moritz: g'ah. figuring out where to declare the contextual closure hurts my brane. I think it should be declared at (2).

[14:37] <TimToady> there's tight coupling and loose coupling

[14:38] <TimToady> (with a developer, in the sense you can have a conversation, or just put something into their queue)

[14:38] <moritz> masak: well, it must be in a caller of the routine where the wrapping occurs

[14:39] <moritz> masak: like, the location where the macro is called is a pretty safe bet

[14:39] <masak> right. that's (2).

[14:39] <TimToady> sergot: if the main point ends up explaining how the culture works rather than just being a Who's Who, it can be useful to name names as an example of how it works currently

[14:40] <masak> moritz: I started defining it at (4), which made sense for a while, and then went "hey, waaaaitaminute..."

[14:40] <TimToady> and to the extent that we are not interchangeable parts, each of us has to provide something that nobody else can

[14:41] <masak> sergot: frettled once made a list of bots and who were responsible for each. it's in the blogosphere somewhere.

[14:41] <masak> s/frettled/frettled++/

[14:41] <moritz> it moved on the the perl6 wiki

[14:42] <moritz> http://wiki.perl6.org/IRC%20bots

[14:42] <moritz> seems to be a bit incomplete

[14:42] <sergot> Great, thanks. :)

[14:44] <masak> moritz: just found https://github.com/rakudo/rakudo/commit/39cc71e0a06d769c65230cc0aaf399fb96313e7b#L0R3528 -- what would happen if that line wasn't changed. (trying to understand what it does)

[14:44] <masak> moritz: once I understand what it does, I will probably add it to the two other macro-call code paths.

[14:46] <moritz> masak: erm, which line? the hiliting doesn't seem to work here :(

[14:49] <FROGGS> moritz: I guess first diff, fourth from bottom

[14:49] <FROGGS> 3528 that is

[14:50] <masak> moritz: my $quasi_ast := $*W.ex-handle($/, { $routine(|@argument_quasi_asts) });

[14:50] <masak> moritz: (the id part of the URL, #L0R3528, also gives the line)

[14:51] <moritz> masak: it calls the block  (i.e. invokes the routine), catches exceptions, adds line/file info, rethrows

[14:51] <masak> aha.

[14:52] <masak> so it's a kind of "add line/file info" exception wrapper?

[14:53] <moritz> yes

[14:54] <moritz> (it adds a bit more info, but that's the essence)

[14:54] <moritz> anyway, that's the actual invocation of the macro body

[14:54] <masak> right.

[14:54] <masak> there's three of them in Actions, currently.

[14:56] <masak> g'ah, another 'maximum recursion depth exceeded'!

[14:58] <[Coke]> time to bump up the limit again, or are you going off into the weeds?

[14:58] <moritz> I guess it's the latter

[14:58] <masak> [Coke]: no, it's clearly a thinko on my part, considering the stacktrace.

[15:00] <masak> furthermore, I suspect the stacktrace is of trying and failing to serialize an error message that occurs during compilation. because the routines in the stacktrace are stringifying methods, and my added code isn't doing any stringification.

[15:02] <masak> it's exciting to be so close to having things working, though.

[15:02] <[Coke]> masak++ # hey, is your grant done yet?

[15:02] <[Coke]> masak++ # hey, is your grant done yet?

[15:02] <[Coke]> masak++ # hey, is your grant done yet?

[15:02] * [Coke] hides.

[15:03] <moritz> masak: --ll-exception

[15:03] <moritz> not sure if it'll help, but it's worth a shot

[15:03] <masak> [Coke]: no, but after I get this working, I will consider it 50%, and take the appropriate blogging actions.

[15:04] <masak> moritz: ah, good idea.

[15:04] <moritz> masak: and look at the bottom of the backtrace

[15:04] *** snearch left
[15:05] <moritz> sometimes the calling location tells you what's wrong

[15:05] * FROGGS .oO( how it would look like at the bottom of the backtrace? )

[15:06] <masak> moritz: this is during 'make'.

[15:06] <moritz> masak: and?

[15:06] <arnsholt> Hack the Makefile, I guess =)

[15:06] <moritz> copy the command that fails

[15:06] <moritz> add an --ll-exception

[15:06] <masak> ah, yes.

[15:07] <TimToady> on passing strings to macros, it should be about as common as Action rules in the grammar dealing in strings rather than ASTs; that is, it happens occasionally, but only with when something forces it to be text explicitly rather than AST, which is the default

[15:08] <TimToady> in fact, I think that thinking of macros as user-define action rules is probably a good thing

[15:08] <TimToady> because that's more or less what they are

[15:09] <TimToady> (I mean, that's what hygienic macros are)

[15:10] <TimToady> which makes me thing that we might find some way of making P6 grammar actions look more like macros, once we figure out what macros look like :)

[15:10] <TimToady> *think

[15:12] <TimToady> I am pretty much convinced that the triple rule must die; they are very cluttery and actively confusing to the eye

[15:13] <masak> hygienic != AST-based

[15:13] <moritz> triple rule?

[15:13] <TimToady> {{{$stuff}}}

[15:13] <masak> --ll-exception didn't shed any new light :/

[15:13] <moritz> masak: then try the bottom-of-the-stacktrace thing

[15:14] <masak> but I know which line in src/core/AST.pm causes the infinite recursion: '$past := &*wrap_and_recontext($_);'

[15:14] *** erkan joined
[15:14] *** erkan left
[15:14] *** erkan joined
[15:14] <masak> I don't see why it should; it looks perfectly innocent to me.

[15:14] <masak> hey, wait! probably needs a 'my'! :)

[15:15] <arnsholt> I hate those bugs

[15:15] <moritz> well, you probably also see what function it calls

[15:15] <arnsholt> So hard to find >.<

[15:16] <moritz> and one of those (compile-time) callees is what throws the error

[15:17] <masak> that fixed it \o/

[15:17] <moritz> \o/

[15:21] <masak> bah, I keep tripping on the three-code-paths-instead-of-one thinko myself the whole time. making it more urgent to actually unify them.

[15:23] <moritz> The Mystery of the Three Code Paths, by Carl Masak

[15:23] <moritz> or maybe *Mastery

[15:23] <TimToady> cognominal: Ken Pike was one of the founders of SIL, so I was indirectly his pupil.  I only saw him for a day or so in real life, but he did a monolingual demonstration that was quite impressive

[15:24] *** thou joined
[15:24] <TimToady> they put him up with a speaker of some African language he'd never studied, and by the end of the hour was having rudimentary conversations with him

[15:25] <TimToady> they both knew English, but neither spoke it

[15:25] <TimToady> Pike spoke and took notes on the blackboard in Aztec

[15:26] <TimToady> well, and IPA :)

[15:26] *** jaldhar left
[15:26] <moritz> wow, that's impressive

[15:27] <TimToady> as for the relationship of SIL with tagmemics, well, Pike invented tagmemics, at least its early forms

[15:27] <TimToady> some later philosophical creations went rather beyond his original vision, and I don't know that he entirely approved

[15:27] <TimToady> he was mostly a practical linguist :)

[15:28] <cognominal> :)

[15:28] <cognominal> TimToady, thx for the answer

[15:30] <rjbs> Wow.

[15:33] <TimToady> but the important concepts in tagmemics are about how people actually think about language (and just as importantly, which bits they don't think about)

[15:34] <cognominal> fishes don't theorize about water

[15:34] * masak is having much use for --ll-exception as he keeps debugging his still-not-working patch

[15:34] <TimToady> when you use a word, that word has a number of different contexts, and people naturally work with all those contexts simultaneously

[15:34] <TimToady> like multiple dimensions of water

[15:36] *** crab2313 joined
[15:36] <TimToady> Pike liked to use a particle/wave/field analogy for some of the most important contexts

[15:37] <cognominal> btw did you see sigils like flexions in flexionnal language (with the proviso that with identifiers, there is no root to be flexed,  just lexed maybe :)

[15:38] <TimToady> I have no idea what you're saying.  :)

[15:38] <cognominal> anyway, they literally have a role in Perl 6.

[15:38] <BooK> speaking of sigils, is that an invented word?

[15:39] <moritz> no, sigil exists outside of programming too

[15:39] <flussence> .oO( but all words are invented! )

[15:39] <geekosaur> @wn sigil

[15:39] <lambdabot> No match for "sigil".

[15:39] <geekosaur> bah

[15:39] <BooK> oh right

[15:40] <BooK> got some wikipedia article about them

[15:40] <BooK> weird that I never found that before, or rather, that I don't remember finding it

[15:40] <frettled> masak: I don't think that was me, that IRC bots thingy, but I could just be suffering from dementia.  :)

[15:40] <TimToady> sigil is a good example of a word that means one thing in the dictionary but we use it for something else

[15:41] <cognominal> ho that's fussional language in english  http://en.wikipedia.org/wiki/Fusional_language

[15:41] <TimToady> we know "dog" is a noun, but we can also use it as a verb or as an adjective

[15:41] * PerlJam stamps a butterfly-shaped piece of wood into hot wax

[15:41] <BooK> no only is perl stealing ideas from other languages, but also words from the dictionary!

[15:42] <TimToady> we all steal words all the time

[15:42] <TimToady> that's how language works, according to tagmemics

[15:43] <cognominal> so english is less a fusional language than french because there is less fusion so more ambiguity when a word is taken alone

[15:44] <cognominal> That's probably why the english wikipedia is so short compared to the french one.

[15:45] <PerlJam> cognominal: I thought it was more because the french are obsessed with language more than english-speaking peoples

[15:45] <moritz> or maybe because the English wikipedia simply has more contributors

[15:46] *** kaare_ joined
[15:47] <cognominal> anyway my analysis of sigil is wrong according to this criteria. Adding a sigil does not modify the "root" form of the identifier, so by this token perl is an analytic language  http://en.wikipedia.org/wiki/Analytic_language#Analytic_languages

[15:47] <cognominal> anyway I have strayed far away from tagmemics

[15:48] <TimToady> but in Perl 5, adding {} to $foo changes the root form to %foo, by one way of thinking

[15:48] *** crab2313 left
[15:49] <TimToady> but computers force us to be rather analytical at the best of times

[15:49] *** hoelzro|away is now known as hoelzro

[15:50] <cognominal> well, by root, I meant "foo" here, changing @ or % would be a grammatical way to convay the accessing action :)

[15:50] <TimToady> that would be a highlander variable interpetation, which was proposed for Perl 6 but rejected

[15:51] <TimToady> we include the sigil with the root, and bare 'foo' has no meaning

[15:51] <TimToady> we can, however, use bare foo to mean &foo in some situations

[15:52] <TimToady> or you can look at the other way around, 'foo' is a verb, and & is noun marker

[15:53] <cognominal> btw I am tempted in Perl 6 when argument(s) of a function fun is/are string(s), to write  fun< a b >

[15:53] <cognominal> probably ambiguous because < is an operator

[15:53] <masak> hm. so. it successfully finds and calls the magical dynamic subroutine &*wrap_and_recontext

[15:53] <masak> but it fails inside of it, for unknown reasons.

[15:53] <masak> the error I get is "get_attr_str() not implemented in class 'Undef'"

[15:54] <masak> from a line which appears to be a nqp::getattr call.

[15:55] <cognominal> r: sub fun { … }; fun< a b >

[15:55] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2, near "\u2026 }; fun< "␤»

[15:55] <masak> oh, btw, this is no longer during compilation. macros-d2 compiles now. this is during the macro call.

[15:55] <masak> cognominal: your client turns '...' into '…'.

[15:56] <masak> cognominal: tell it not to do that :)

[15:56] <cognominal> yup the error I got here was   postcircumfix:<{ }> not defined for type Failure

[15:56] <cognominal> so it parses "well" after all but fails later

[15:57] <TimToady> it parses as (fun){'a','b'}

[15:57] <cognominal> ha!

[15:57] <TimToady> that would only have worked if we had unified function invocation with hash subscripting

[15:58] <masak> or as fun()<a b>

[15:58] *** brrt left
[15:59] <TimToady> and if we had unified those, we probably couldn't have a decent multi-dimensional slice syntax for subscripting

[16:00] <TimToady> (not that anyone implements the latter yet)

[16:00] *** FROGGS left
[16:00] *** FROGGS__ left
[16:00] <cognominal> but you already carved a syntactical space for it :)

[16:01] <masak> I wanted to unify hash/array lookup with argument passing in the language I'm designing, but I'm having serious second thoughts now.

[16:03] <cognominal> masak, or we can apply the rule to make things easier to user and harder to the implement and treat … like the triple dot :)

[16:03] <cognominal> *implementer

[16:04] <masak> cognominal: I'd hate introducing a synonym there just because some people have silly IRC clients.

[16:05] <TimToady> one could think of macro args vs return as a kind of CPS in the compiler

[16:05] <masak> TimToady: they sure feel very symmetrical to me.

[16:06] <masak> TimToady: that's been the insight of late -- "hey, there are *two* cases of AST insertions!"

[16:06] <masak> we don't think of it with HTML templates, because those encompass whole HTML documents most of the time.

[16:07] *** benabik joined
[16:07] *** kaare__ joined
[16:07] *** kaare_ left
[16:08] <TimToady> hmm, if we replace {{{}}} with ¤, should that be called "ox" or "xo", I wonder...

[16:08] <TimToady> (those are the chars in the compose key map, for those wondering)

[16:08] <dalek> rakudo/macros-d2: 7fb2693 | masak++ | src/ (2 files):

[16:08] <dalek> rakudo/macros-d2: partial commit

[16:08] <dalek> rakudo/macros-d2: 

[16:08] <dalek> rakudo/macros-d2: almost working... getting this error:

[16:08] <dalek> rakudo/macros-d2: 

[16:08] <dalek> rakudo/macros-d2: $ ./perl6 --ll-exception -e \

[16:08] <dalek> rakudo/macros-d2:   'macro twice($code) { quasi { {{{$code}}}; {{{$code}}} } };

[16:08] <dalek> rakudo/macros-d2:    my $counter = 0; twice $counter++; say $counter'

[16:08] <dalek> rakudo/macros-d2: get_attr_str() not implemented in class 'Undef'

[16:08] <dalek> rakudo/macros-d2: [...]

[16:08] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/7fb2693d6e

[16:08] <masak> I feel stuck. anyone want to build macros-d2 and help me debug?

[16:09] *** hoelzro is now known as hoelzro|away

[16:09] <masak> TimToady: 'ox' is easier to pronounce, and more in line with #perl6's fondness for animals.

[16:11] <TimToady> .oO(rename AST to Ox)

[16:11] *** marmay joined
[16:12] <daxim> /usr/share/X11/locale/en_US.UTF-8/Compose suggests both the mnemonics <o> <x> and <x> <o>

[16:12] <TimToady> which is why I was asking

[16:12] <TimToady> or wondering, more precisely :)

[16:12] <masak> :)

[16:13] <TimToady> it's ^KCu in vim

[16:13] *** benabik left
[16:14] <TimToady> .oO(macros are wired with copper)

[16:15] <cognominal> :)

[16:17] <TimToady> and yes, I said "COBOL"

[16:18] <masak> "New technologies come and go, but COBOL is forever." -- http://abstrusegoose.com/323

[16:22] *** Vlavv joined
[16:22] <marmay> Out of curiosity, is there something similar to .^methods for modules and subs? Something that lists all subs of a module?

[16:23] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say Foo.HOW.^name

[16:23] <p6eval> rakudo cc1858: OUTPUT«Perl6::Metamodel::ModuleHOW␤»

[16:24] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say Foo.HOW.^methods

[16:24] <p6eval> rakudo cc1858: OUTPUT«No such method 'gist' for invocant of type 'NQPRoutine'␤  in method gist at src/gen/CORE.setting:4730␤  in sub say at src/gen/CORE.setting:7140␤  in block  at /tmp/l8YZYbApAG:1␤␤»

[16:24] <masak> heh.

[16:24] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say Foo::

[16:24] <p6eval> rakudo cc1858: OUTPUT«("\&foo" => sub foo() { ... }).hash␤»

[16:25] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say Foo::<foo>

[16:25] <p6eval> rakudo cc1858: OUTPUT«Any()␤»

[16:25] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say (Foo::)<foo>

[16:25] <p6eval> rakudo cc1858: OUTPUT«Any()␤»

[16:25] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say (Foo::).perl

[16:25] <p6eval> rakudo cc1858: OUTPUT«("\&foo" => sub foo() { ... }).hash␤»

[16:25] <masak> r: module Foo { our sub foo { say "OH HAI" } }; say (Foo::).keys

[16:25] <p6eval> rakudo cc1858: OUTPUT«&foo␤»

[16:25] <masak> marmay: like that?

[16:26] <masak> marmay: only our subs, though.

[16:26] <marmay> masak: Yes, thank you!

[16:26] *** Vlavv_ joined
[16:29] *** Vlavv left
[16:30] <dalek> rakudo/macros-d2: 8c85e7a | masak++ | src/Perl6/ (2 files):

[16:30] <dalek> rakudo/macros-d2: fix embarrassing typo

[16:30] <dalek> rakudo/macros-d2: 

[16:30] <dalek> rakudo/macros-d2: Also comment out some code.

[16:30] <dalek> rakudo/macros-d2: Yes, I expect to rebase these commits later.

[16:30] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/8c85e7afc6

[16:31] <masak> this gets me a little further.

[16:31] *** stopbit left
[16:31] <masak> now the only problem is that the custome op perl6_get_outer_ctx gets a String where it expected a Parrot Sub.

[16:31] <masak> custom*

[16:31] <masak> which should be a relatively easy problem to track down.

[16:32] <masak> yay! :)

[16:32] *** stopbit joined
[16:32] <tadzik> \o/

[16:32] <masak> my problems get smaller and smaller :)

[16:32] <TimToady> wow, that's that only problem?  cool!

[16:32] <TimToady> everything else should be a piece of cake

[16:32] <TimToady> pity I'm allergic to cake...

[16:33] <masak> I would have been more afraid of that custom op, if I hadn't been sitting at the keyboard as it was created ;)

[16:33] <masak> I would've said "if I hadn't authored it", but that feels a bit too strong.

[16:34] <GlitchMr> perl6: IDENTIFICATION DIVISION.

[16:34] <masak> for those interested, that custom op is essentially the unholy rite you have to perform in order to make AST behave as closures.

[16:34] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Confused␤at /tmp/6Rcp4ggmEh:1␤»

[16:34] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/7Ed_fvdhLd line 1:␤------> [32mIDENTIFICATION DIVISION[33m⏏[31m.[0m␤␤Undeclared names:␤      'DIVISION' used at line 1␤      'IDENTIFICATION' used at line 1␤␤Parse failed␤␤»

[16:35] <TimToady> what about the rest of us?  :P

[16:35] <masak> for the rest of you, it's absolutely no cause for concern.

[16:36] <TimToady> oh oh...

[16:39] * masak tries to treat the type error as a retrograde analysis problem

[16:44] *** benabik joined
[16:44] *** phenny joined
[16:44] *** benabik left
[16:45] *** leont joined
[16:48] *** benabik joined
[16:49] <sorear> .u 44

[16:49] <phenny> U+4400 CJK UNIFIED IDEOGRAPH-4400 (䐀)

[16:49] <masak> hm. that seemed to lead me somewhere. unexpected.

[16:49] <sorear> phenny: tell sorear hi

[16:49] <phenny> You can tell yourself that.

[16:49] <masak> phenny++

[16:50] <sorear> in query with sbp now.  once phenny is operational, I'll have lambdabot leave

[16:51] <masak> \o/

[16:51] <sorear> good * #perl6

[16:51] <masak> sorear! \o/

[16:51] *** FROGGS__ joined
[16:52] <masak> heh. trying to print the offending value causes multi dispatch of 'print' to fail ;)

[16:53] <sorear> hii

[16:53] <phenny> sorear: 16:53Z <sbp> tell sorear this is a test. please let me know if it succeeded!

[16:56] *** sbp joined
[16:58] <sorear> um, wtf

[16:58] <sorear> I kicked phenny last night

[16:58] <sorear> phenny is in the channel now

[16:58] <sorear> I don't have a phenny join or nick-change-to-phenny in my log

[16:58] <sbp> I made her join a few minutes ago, just after you asked

[16:58] <sbp> phenny!

[16:58] <phenny> sbp!

[16:59] <sbp> and she's operational

[16:59] <benabik> Dr. Scott!

[16:59] <sbp> benabik!

[16:59] <tadzik> phenny!

[16:59] <phenny> tadzik!

[16:59] <sbp> .u circ kat tu

[16:59] <phenny> U+32E1 CIRCLED KATAKANA TU (㋡)

[16:59] <sorear> oh

[16:59] <sorear> .u circ kat tu

[16:59] <phenny> U+32E1 CIRCLED KATAKANA TU (㋡)

[16:59] <sbp> apologies to all here for the disruption last night

[16:59] * masak goes for a brief run

[16:59] <sorear> sorry for dragging you into this just now, sbp

[16:59] <benabik> sbp: What happened?

[17:00] <sorear> the most recent problem:

[17:00] <sorear> phenny was spamming me in pm, so I did /ignore phenny

[17:00] <benabik> More of the zort- stuff, or something new?

[17:00] <sbp> benabik: there was spam from some chap who was passing on messages using the wildcard ("*") syntax in the tell feature. I made the wildcards more restrictive as a result. it affected at least one other channel too, annoyingly

[17:00] <sbp> just the zort- stuff

[17:00] <sorear> @part #perl6

[17:00] *** lambdabot left
[17:00] <benabik> wildcards in tell?  Eep.

[17:01] <tadzik> phenny: tell bena* foo

[17:01] <phenny> tadzik: I'll pass that on when bena* is around.

[17:01] *** dakkar left
[17:02] <sbp> * now matches 0123456789_-[]` — prepended and appended. circumfix!

[17:02] *** FROGGS joined
[17:02] <benabik> I guess that's useful for foo{,_,-work,-away,etc}

[17:02] <sbp> yeah

[17:02] * benabik notes that bena* is around.  :-/

[17:03] <sbp> "bik" aren't in 0123456789_-[]` :-)

[17:03] <tadzik> :)

[17:03] <benabik> Ahhhh.

[17:04] <sbp> anyway, enjoy and apologies again. I do plan to reside here again when I actually learn #perl6 and start writing some software in it—otherwise I'll just run my mouth off unnecessarily

[17:04] * sbp waves

[17:04] *** sbp left
[17:05] *** gongyiliao joined
[17:05] *** marmay left
[17:09] *** azawawi joined
[17:09] <azawawi> hi #perl6

[17:09] <azawawi> Just wanted to showcase http://feather.perl6.nl:4040/  # Frabi web-based Perl editor

[17:10] <azawawi> Hopefully we can use it also for Perl 6 via Perlito 6

[17:11] <sirrobert> azawawi: looking

[17:12] <azawawi> brb

[17:12] <sirrobert> nice =)

[17:18] <FROGGS> is it possible to share code like a gist?

[17:19] <FROGGS> or better like a no-paste

[17:20] *** SamuraiJack left
[17:20] *** SamuraiJack joined
[17:24] <benabik> FROGGS: Like with gist.github.com or http://nopaste.snit.ch/ ?

[17:25] <benabik> r: https://gist.github.com/1524863

[17:25] <p6eval> rakudo cc1858: OUTPUT«test␤t e s t␤»

[17:25] <benabik> FROGGS: And p6eval will even take gists and run them.

[17:27] <sorear> benabik: I think the context here is generating gists *directly from azawawi 

[17:27] <sorear> benabik: I think the context here is generating gists *directly from azawawi's p6 code editor*

[17:27] *** nodmonkey joined
[17:27] <benabik> sorear: Oh.  Sorry. Totally spaced.

[17:27] <benabik> FROGGS: nvm then

[17:29] *** MayDaniel joined
[17:29] <FROGGS> benabik: I just wanted to know if I would be able to give someone a link, he/she clicks on it and get to your page, with my code sample present

[17:29] <FROGGS> like I can give somebody a no-paste link

[17:30] <benabik> FROGGS: Yes.  I somehow missed the bit about the editor.

[17:31] <FROGGS> right, azawawi's page... but you are right, you can share gists and run that here too

[17:33] <GlitchMr> Just wondering, does Perl 6 have sets like Python?

[17:33] <GlitchMr> Python has sets which use: {1, 2, 3} syntax

[17:35] <FROGGS> do you mean something like an enum?

[17:35] <GlitchMr> No, I don't mean dictionary

[17:35] <GlitchMr> I mean sets

[17:36] <GlitchMr> >>> {1, 2, 3} & {1, 2, 4}

[17:36] <GlitchMr> set([1, 2])

[17:38] <sorear> n: say set(1,2,3) (&) set(1,2,4)

[17:38] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«set(1, 2)␤»

[17:40] <GlitchMr> Nice

[17:40] <GlitchMr> (&) looks ugly, but I guess it's good enough

[17:40] <GlitchMr> & is junction

[17:41] <sirrobert> n: say set(1,2,3) & set(1,2,4)

[17:41] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«all(set("1", "2", "3"), set("1", "2", "4"))␤»

[17:41] <sirrobert> ah

[17:41] <sorear> .u intersec t

[17:41] <phenny> sorear: Sorry, no results for 'intersec t'.

[17:41] <sorear> .u intersect

[17:41] <phenny> U+2229 INTERSECTION (∩)

[17:41] <sorear> n: say set(1,2,3) ∩ set(1,2,4)

[17:41] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«set(1, 2)␤»

[17:41] <sirrobert> nice

[17:44] *** benabik_ joined
[17:44] *** benabik left
[17:44] *** benabik_ is now known as benabik

[17:44] <GlitchMr> .u negation

[17:44] <phenny> U+2AEE DOES NOT DIVIDE WITH REVERSED NEGATION SLASH (⫮)

[17:45] <daxim> .u ¬

[17:45] <phenny> U+00AC NOT SIGN (¬)

[17:45] <sirrobert> what does the $bar here mean:   token foo ($bar) { ... }

[17:46] <GlitchMr> n: say set(1, 2, 3) ∖ set(1, 2, 4)

[17:46] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/dUhmqKuMWV line 1:␤------> [32msay set(1, 2, 3) [33m⏏[31m∖ set(1, 2, 4)[0m␤␤Parse failed␤␤»

[17:46] <GlitchMr> :(

[17:46] <GlitchMr> If it supports ∩, why not ∖?

[17:46] <sirrobert> what is \?

[17:46] <GlitchMr> oh wait, that's ASCII

[17:46] <GlitchMr> lol

[17:46] <GlitchMr> .u ∖

[17:46] <phenny> U+2216 SET MINUS (∖)

[17:46] <GlitchMr> or not

[17:47] <GlitchMr> This looks confusing in console

[17:47] <sirrobert>  n: say set(1, 2, 3) ∖ set(1, 2, 4)

[17:47] <GlitchMr> But it's still set minus

[17:47] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/DDQc707DoY line 1:␤------> [32msay set(1, 2, 3) [33m⏏[31m∖ set(1, 2, 4)[0m␤␤Parse failed␤␤»

[17:47] <sirrobert>  n: say set(1, 2, 3) \∖ set(1, 2, 4)

[17:47] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/vrhp3nhTNt line 1:␤------> [32msay set(1, 2, 3) [33m⏏[31m\∖ set(1, 2, 4)[0m␤␤Parse failed␤␤»

[17:47] <sirrobert> huh

[17:50] <sorear> (-) is allowed

[17:50] <GlitchMr> But is there any reason why ∖ isn't?

[17:50] *** benabik left
[17:51] <sorear> colomon didn't add an infix:<∖> definition to the setting, most direct reason

[17:51] <TimToady> didn't know there was a character for that

[17:51] <sirrobert> neither did I =)

[17:52] <sorear> but if you ask me set(1,2,3) ∖ 2 looks too much like an unspace

[17:54] <TimToady> well, in context it might not, if you're doing a lot of set stuff

[17:54] <[Coke]> I would say too confusing for core, but easily addable if you're using sets all the time and speak that dialect.

[17:55] <GlitchMr> So, we have ∪, but we don't have ∖

[17:55] <GlitchMr> This sort of makes sense

[17:55] <TimToady> n: my &infix:<∖> := &infix:<(-)>; say set(1, 2, 3) ∖ set(1, 2, 4)

[17:55] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«set(3)␤»

[17:56] <daxim> where's the documentation for set?

[17:56] <GlitchMr> Also

[17:56] <GlitchMr> There is × operator

[17:57] <TimToady> S32-setting-library/Containers

[17:57] <GlitchMr> set(1, 2) × set(3, 4) eqv set((1, 3), (1, 4), (2, 3), (2, 4))

[17:57] <sirrobert> What is ~$ ?

[17:57] <sirrobert> in a grammar's action class

[17:57] <GlitchMr> But I guess that Perl 6 has perfectly fine X operator

[17:58] <TimToady> also bits of S02 and S03

[17:58] <TimToady> but you'd have to make it back into a set

[17:58] <sirrobert> or:  what does "text => ~$<text>" mean?

[17:59] <TimToady> stringify the node and make a pair of it

[17:59] <sirrobert> ohh

[17:59] <arnsholt> Makes a pair, .key is "text" and .value is whatever the <text> subrule matched

[17:59] *** araujo left
[17:59] <TimToady> stringified

[17:59] <sirrobert> I was confused by ~$

[17:59] <sirrobert> makes sense now

[17:59] <[Coke]> pmichaud: my latest nqp issue is errors like "Error while compiling block : Error while compiling op bind: Error while compiling block gets: Error while compiling op lexotic: Error while compiling op bind: Cannot infer type from ''

[18:00] <[Coke]> " - they don't tell me where in the code the problem is.

[18:00] <sirrobert> Oh, $<text> is a shorthand for $/<text>

[18:00] <sirrobert> thanks

[18:00] <GlitchMr> It saves one character, but it's always one character

[18:00] <TimToady> less visual clutter, is the main thing

[18:00] <[Coke]> (and the backtrace is basically "QAST errored out")

[18:00] <GlitchMr> When you make lots of operation on grammar, this is helpful

[18:01] <GlitchMr> I guess

[18:01] *** Chillance left
[18:02] *** Chillance joined
[18:02] *** nodmonkey left
[18:02] <[Coke]> AHA. new NQP is much finickier about pir opcode modifiers. pir::readline__sp dies horribly, but pir::readline__SP works.

[18:05] <FROGGS> TimToady: an example using SDL: http://rosettacode.org/wiki/Mouse_position#Perl

[18:05] <masak> does :$<text> expand to text => $<text> ? :)

[18:08] *** araujo joined
[18:09] <sorear> n: "foo" =~ /$<text> = [o*]/; :$<text>.perl.say

[18:09] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of =~ to do pattern matching; in Perl 6 please use ~~ at /tmp/Pt6EF_L9Yt line 1:␤------> [32m"foo" =~[33m⏏[31m /$<text> = [o*]/; :$<text>.perl.say[0m␤␤Parse failed␤␤»

[18:09] <sorear> n: "foo" ~~ /$<text> = [o*]/; :$<text>.perl.say

[18:09] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«"text" => #<match from(0) to(0) text() pos([].list) named({}.hash)>␤»

[18:09] <sorear> masak: looks like so in niecza :D

[18:10] <TimToady> but doesn't do the stringify

[18:10] <GlitchMr> perl6: grammar cake { token TOP { <text> }; token text { a } }; cake.parse('a'); (:$<cake>).perl.say

[18:10] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«"cake" => Any␤»

[18:10] <p6eval> ..rakudo cc1858: OUTPUT«===SORRY!===␤Confused␤at /tmp/5nS1Joi8d0:1␤»

[18:10] <GlitchMr> Doesn't look like it

[18:11] <GlitchMr> It's more like cake => Any

[18:11] <GlitchMr> perl6: grammar cake { token TOP { <text> }; token text { a } }; cake.parse('a'); (:$<cake>)['cake'].say

[18:11] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Confused␤at /tmp/v9jTHTrRsU:1␤»

[18:11] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«Unhandled exception: Cannot parse number: cake␤  at /home/p6eval/niecza/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3525 (ANON @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3527 (NumSyntax.str2num @ 5) ␤  at …

[18:11] <GlitchMr> perl6: grammar cake { token TOP { <text> }; token text { a } }; cake.parse('a'); (:$<cake>)<cake>.say

[18:11] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Confused␤at /tmp/UI2ISXyM5g:1␤»

[18:11] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«Unhandled exception: Cannot use hash access on an object of type Pair␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 352 (Any.at_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/d7CbhxAn7V line 1 (mainlin…

[18:11] <GlitchMr> ok...

[18:12] <sorear> n: grammar cake { token TOP { <text> }; token text { a } ; cake.parse('a'); (:$<cake>).value.say

[18:12] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unable to parse block at /tmp/wS2kGc4nCT line 1:␤------> [32mgrammar cake {[33m⏏[31m token TOP { <text> }; token text { a } [0m␤Couldn't find final '}'; gave up at /tmp/wS2kGc4nCT line 1 (EOF):␤------> [32m ; cake.parse(…

[18:12] <sorear> n: grammar cake { token TOP { <text> }; token text { a } }; cake.parse('a'); (:$<cake>).value.say

[18:12] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«Any()␤»

[18:13] <sorear> n: grammar cake { token TOP { <text> }; token text { a } }; cake.parse('a'); say $/

[18:13] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({"text" => #<match from(0) to(1) text(a) pos([].list) named({}.hash)>}.hash)>␤»

[18:13] <sorear> n: grammar cake { token TOP { <text> }; token text { a } }; cake.parse('a'); (:$<text>).value.say

[18:13] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[18:13] <sorear> there's no "cake" capture anywhere.

[18:14] <GlitchMr> lolright

[18:19] *** jevin left
[18:23] *** mucker left
[18:23] *** jevin joined
[18:29] *** jevin left
[18:32] *** jevin joined
[18:47] *** FROGGS__ left
[18:49] *** FROGGS left
[18:53] *** FROGGS__ joined
[18:55] <azawawi> FROGGS__: the idea is to build a fully featured editor

[18:56] <azawawi> FROGGS__: perl mojo backend

[18:56] <azawawi> FROGGS__: js frontend

[18:57] <sorear> good luck making a syntax-aware editor for perl 6

[18:57] <sirrobert> azawawi: nice =)

[18:57] <azawawi> sorear: hi... long time no see :)

[18:58] *** daxim left
[18:58] <sorear> azawawi: hello.  i've been here the whole time, I think...

[18:59] <sorear> even when I was 1.5e7 m from home, I was here.

[18:59] <azawawi> sorear: i know. Sadly i havent been here lately :(

[19:05] *** FROGGS joined
[19:08] *** azawawi left
[19:16] *** am0c joined
[19:17] *** benabik joined
[19:29] *** benabik left
[19:30] *** benabik joined
[19:39] <lizmat> rn: infix:<+>(1, 2) 

[19:39] <p6eval> rakudo cc1858, niecza v21-1-ga8aa70b:  ( no output )

[19:39] *** benabik left
[19:39] <lizmat> infix:<+>(1, 2).say

[19:39] <colomon> rn: infix:<+>(1, 2).say

[19:39] <lizmat> rn: infix:<+>(1, 2).say

[19:39] <p6eval> rakudo cc1858, niecza v21-1-ga8aa70b: OUTPUT«3␤»

[19:39] <p6eval> rakudo cc1858, niecza v21-1-ga8aa70b: OUTPUT«3␤»

[19:39] <colomon> ;)

[19:40] <lizmat> thanks :-)

[19:40] <sorear> o/ colomon, lizmat

[19:40] <colomon> \o

[19:40] <tadzik> oh hello

[19:40] <lizmat> hi sorear

[19:40] <lizmat> hi tadzik

[19:40] <sorear> o/ tadzik 

[19:40] * lizmat was just trying some example code

[19:41] <lizmat> rn: circumfix:«( )»('a', 'b', 'c').say

[19:41] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&circumfix:<( )>' called (line 1)␤»

[19:41] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'circumfix:«( )»' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) …

[19:41] <lizmat> rn: circumfix:«( )»('a', 'b', 'c')

[19:41] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&circumfix:<( )>' called (line 1)␤»

[19:41] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'circumfix:«( )»' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) …

[19:42] <lizmat> rn: circumfix:<( )>('a', 'b', 'c')

[19:42] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'circumfix:<( )>' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) …

[19:42] <p6eval> ..rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&circumfix:<( )>' called (line 1)␤»

[19:44] *** erkan left
[19:44] *** snearch joined
[19:45] *** erkan joined
[19:45] *** erkan left
[19:45] *** erkan joined
[19:47] *** amkrankruleuen joined
[19:47] <lizmat> rn: circumfix:« ( ) »('a', 'b', 'c')

[19:47] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'circumfix:« ( ) »' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37…

[19:47] <p6eval> ..rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&circumfix:<( )>' called (line 1)␤»

[19:47] <lizmat> rn: circumfix:«( )»('a', 'b', 'c')

[19:47] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&circumfix:<( )>' called (line 1)␤»

[19:47] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'circumfix:«( )»' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) …

[19:49] *** immortal joined
[19:49] *** immortal left
[19:49] *** immortal joined
[19:50] *** erkan left
[19:50] <GlitchMr> perl6: 26, 32, 35, 48, 12, 11 ==> grep * %% 2 ==> sort ==> my @array; print @array.join(' ')

[19:50] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Preceding context expects a term, but found infix ==> instead at /tmp/5_XEOQMICF line 1:␤------> [32m35, 48, 12, 11 ==> grep * %% 2 ==> sort [33m⏏[31m==> my @array; print @array.join(' ')[0m␤␤Parse failed␤␤»…

[19:50] <p6eval> ..rakudo cc1858: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix ==> instead␤at /tmp/_mv0HVP0hC:1␤»

[19:50] <GlitchMr> What's wrong with sort ==>?

[19:51] <sorear> you need sort() in current rakudo

[19:51] <masak> and current niecza, it seems.

[19:51] <sorear> after sort, the parser is looking for a term, and rakudo doesn't yet handle ==> in term context

[19:51] <sorear> masak: niecza doesn't support ==> at all

[19:51] <tadzik> probably also in current pugs :)

[19:51] <diakopter> phenny: ask TimToady have you seen http://rosettacode.org/wiki/Category:Draft_Programming_Tasks

[19:51] <sorear> pugs: 1 ==> sort

[19:51] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ">"␤    at /tmp/BL2C6vTadE line 1, column 5␤»

[19:51] <phenny> diakopter: I'll pass that on when TimToady is around.

[19:52] <lizmat> can someone explain me why "circumfix:«( )»('a', 'b', 'c')" complains about circumfix not being defined?

[19:52] <lizmat> it is an example from doc.perl6.org

[19:52] <masak> lizmat: looks kosher to me.

[19:52] <diakopter> rn: circumfix:«( )»('a', 'b', 'c')

[19:53] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&circumfix:<( )>' called (line 1)␤»

[19:53] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'circumfix:«( )»' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) …

[19:53] <tadzik> hrm

[19:53] <tadzik> rn: sub circumfix:«( )»('a', 'b', 'c')

[19:53] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Missing block␤at /tmp/fz1oyu9jrs:1␤»

[19:53] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed block at /tmp/2Ft5ZTGWBA line 1 (EOF):␤------> [32msub circumfix:«( )»('a', 'b', 'c')[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[19:53] <tadzik> rn: sub circumfix:«( )»('a', 'b', 'c') {}

[19:53] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«Potential difficulties:␤  &circumfix:<( )> is declared but not used at /tmp/749M5vAuEd line 1:␤------> [32msub circumfix:«( )»[33m⏏[31m('a', 'b', 'c') {}[0m␤␤»

[19:53] <p6eval> ..rakudo cc1858:  ( no output )

[19:53] <tadzik> rakudo's fine with this one

[19:53] <tadzik> rn: sub circumfix:«( )»('a', 'b', 'c') { say (a) }; (5)

[19:53] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a' called (line 1)␤»

[19:53] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'a' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/p6…

[19:54] <diakopter> a

[19:54] <tadzik> r: sub circumfix:«( )»('a', 'b', 'c') { say "asd!" }; (5)

[19:54] <p6eval> rakudo cc1858:  ( no output )

[19:54] <tadzik> the rest is left as an exercise for the reader :P

[19:54] <sorear> lizmat: in niecza, circumfix:<( )> is treated specially by the parser and does not exist as a sub/macro

[19:57] *** fibo joined
[19:57] <lizmat> r: infix:<+> { say "foo" }; 1 + 2

[19:57] <p6eval> rakudo cc1858: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v, Mu *%_)␤␤  in method Numeric at src/gen/CORE.setting:706␤  in sub infix:<+> at src/gen/CORE.setting:2505␤  in block  at /tmp/Oh4DDFjU3u:1␤␤»

[19:57] <lizmat> n: infix:<+> { say "foo" }; 1 + 2

[19:57] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«Unhandled exception: Cannot call infix:<+>; none of these signatures match:␤    Any, Any␤    ␤  at /tmp/83PTpRtofc line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4138 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4139 (mo…

[19:57] <moritz> if you don't tive it a signature, it doesn't take any arguments

[19:58] <moritz> nr: sub infix:<+>($a, $b) { say 'foo' }; 1 + 2

[19:58] <lizmat> rn: infix:<+> (1,2) { say "foo" }; 1 + 2

[19:58] <p6eval> rakudo cc1858: OUTPUT«foo␤»

[19:58] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/FjhCPipb7i line 1:␤------> [32msub infix:<+>([33m⏏[31m$a, $b) { say 'foo' }; 1 + 2[0m␤  $b is declared but not used at /tmp/FjhCPipb7i line 1:␤------> [32msub infix:<+>($a, [33m⏏[31m$b) { …

[19:58] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Confused␤at /tmp/YVJjCUBuVt:1␤»

[19:58] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/qmrYbhlFV4 line 1:␤------> [32minfix:<+> (1,2) [33m⏏[31m{ say "foo" }; 1 + 2[0m␤␤Parse failed␤␤»

[19:58] <sorear> more to the point, "sub" is missing

[19:58] <moritz> nr: sub infix:<+>($, $) { say 'foo' }; 1 + 2

[19:58] <lizmat> aha

[19:58] <p6eval> rakudo cc1858, niecza v21-1-ga8aa70b: OUTPUT«foo␤»

[19:58] <lizmat> I'm trying to make sense of the examples on http://doc.perl6.org/language/operators

[19:59] <lizmat> they are not as enlightening as they should, I think

[20:00] *** amkrankruleuen left
[20:01] <moritz> lizmat: you have to understand that they are calls to operators, not definitions

[20:01] <lizmat> well, I was just being stupid and copy/pasting what looks like examples  :-)

[20:01] <sorear> which examples?

[20:02] <moritz> r: say infix:<+>(1, 2)

[20:02] <p6eval> rakudo cc1858: OUTPUT«3␤»

[20:02] <moritz> lizmat: anyway, if you have ideas on how to improve them, please tell

[20:02] <moritz> (or patch; I'm happy to give anybody commit access)

[20:03] <lizmat> I will push some patches later ok?

[20:03] <moritz> sure

[20:03] <lizmat> I already have a commit bit  :-)

[20:03] <moritz> great

[20:04] <lizmat> did feather just die ?

[20:04] <moritz> I know I suck at writing examples

[20:04] <moritz> no

[20:04] *** GlitchMr left
[20:04] <lizmat> indeed, it just hung for ~ minute for me

[20:05] <sorear> feather does that a lot

[20:05] <sorear> although Juerd says it's actually the router messing up and feather itself is unaffected during the downtime

[20:05] <lizmat> so anybody against upgrading feather to some more RAM and some more CPU ?

[20:05] <sorear> iirc

[20:06] *** am0c left
[20:06] <Juerd> sorear: That was ages ago.

[20:07] <moritz> fwiw feather1 is a horrible mixture of debian unstable and ... unspeakable things

[20:07] <tadzik> sergot: mind updating the modules page? Cronjobs seem not to be running

[20:07] <tadzik> :)

[20:07] <Juerd> sorear: The router has no such issues anymore. If feather still hangs, it's something else.

[20:07] <lizmat> I'll take that silence as a "no" then

[20:07] *** sivoais left
[20:07] <tadzik> some say, that silence means agreement :)

[20:07] <Juerd> lizmat: Why would anyone be against upgrading?

[20:07] <lizmat> indeed

[20:07] <lizmat> :-)

[20:07] <moritz> the proper thing to do would be to set up a new machine, migrate all the services and users, and kill the old one

[20:07] <moritz> but currently I don't have time for such fun

[20:08] <sorear> Juerd: The people who are against upgrading are the people who 1. would have to pay for the new hardware 2. would have to spend time installing/migrating/fixing breakage

[20:08] <Juerd> moritz: Why the "proper" thing? Sure, feather has accumulated a lot of cruft and dust over the years, but it's mostly manageable because the changes were made in /usr/local for the largest part.

[20:09] <lizmat> point 1 is taken care of, I think

[20:10] <moritz> Juerd: running a debian/unstable as a publicly available server on the internet should only be done if security updates are regularly installed

[20:10] <moritz> Juerd: much more regular than what I do now

[20:10] <moritz> Juerd: so it would be better to run something less volatile, but debian doesn't support downgrades

[20:11] <tadzik> debian testing is alright, I think

[20:11] <moritz> yes, I would be fine with that

[20:11] <moritz> but feather is mixed sid/experimental

[20:13] <Juerd> moritz: I strongly disagree for feather1

[20:13] <Juerd> moritz: For things that are important and that shouldn't crash or be broken into, there's feather2

[20:14] <Juerd> moritz: Remote exploits in packaged software are incredibly rare, and local users can['t]? be trusted anyway, regardless of the availability of local exploits.

[20:14] <Juerd> My password for feather1 has been "insecure", without the quotes, for over a year. That says a lot about how I feel about feather1.

[20:15] <Juerd> On a machine that is used for development of bleeding edge stuff, you need a bleeding edge platform, IMO.

[20:15] * PerlJam logs in as Juerd and prepares to wreak havoc

[20:15] <Juerd> Even if it does actually bleed from time to time ;D

[20:16] <moritz> Juerd: I'm fine with that. If I felt more responsible for it, I'd do things differently though

[20:17] <Juerd> Consider that it has been up and running without major security incidents since 2005.

[20:17] <diakopter> security by obscurity

[20:17] <Juerd> Upgrades have caused real trouble about three times. That would have happened with stable Debian too.

[20:18] <moritz> diakopter: security by being unimportant enough

[20:18] <Juerd> diakopter: I'd say feather1 has no real security at all.

[20:18] <moritz> diakopter: same as p6eval 

[20:18] <tadzik> in stable debian updates will happen about 3 times :P

[20:18] <Juerd> diakopter: If something bad happens, we find who did it, bash the bastard, and restore a backup :)

[20:18] <diakopter> :P 'twas a joke guys

[20:18] <Juerd> This has happened once, and it wasn't security related. It was an honest mistake.

[20:19] <tadzik> in our small community we could as well just raid somebody's house if one did a security breakage :P

[20:19] <Juerd> The other abuse of feather was someone hosting a movie in their ~public_html

[20:19] <Juerd> That caused a looooot of bandwidth usage.

[20:19] <diakopter> ick

[20:20] *** Targen joined
[20:21] * lizmat assumes Juerd watches bandwidth usage ?

[20:22] <PerlJam> he does *now*  :)

[20:23] <sorear> Juerd: What was the first thing?

[20:24] *** MikeFair_ left
[20:24] <Juerd> lizmat: Nah, our ISP does that, and warns us :)

[20:24] <lizmat> cool

[20:24] <Juerd> lizmat: We do have bandwidth counters but we don't actively monitor that.

[20:25] <Juerd> Most of our contracts are "fair use" based anyway.

[20:25] <Juerd> sorear: The first feather abuse recorded was that pirated movie in someone's ~/public_html

[20:25] <sorear> I have to admit I've used feather as a largish file host before (0.1 - 10MB files and not for anything I expect to be popular)

[20:26] <Juerd> sorear: And the second one was -probably- a password that had leaked; someone used the same password everywhere.

[20:26] <Juerd> sorear: At least that's not a 800 MB file that's wildly popular.

[20:28] <sorear> a password that had leaked?  you mean like how juerd@feather's password is now on perlgeek.de?

[20:28] <Juerd> No

[20:28] <Juerd> My password has been "insecure", but I changed it to something else a few years ago.

[20:29] *** MikeFair_ joined
[20:29] * masak is generally paranoid enough not to leak old passwords either :)

[20:29] <Juerd> And the other password had probably leaked from somewhere else than feather itself, or IRC. Possibly a key logger, or a website that had its user database opened by accident :)

[20:30] <Juerd> masak: I'm quite sure that I haven't used this particular password anywhere else :P

[20:30] <sorear> "Anyone caught spamming, hosting pirated bits or kiddypr0n, etcetera, " # now I wonder if the other two ever happened.

[20:30] <Juerd> sorear: Not that I know of.

[20:31] <Juerd> The etcetera hasn't happened either, by the way, even though the pirated bits were clearly there.

[20:34] <Juerd> afk

[20:35] *** MayDaniel left
[20:44] *** immortal left
[20:45] *** erkan joined
[20:45] *** erkan left
[20:45] *** erkan joined
[20:46] *** sivoais joined
[20:46] <sirrobert> in a grammar's actions, does TOP always get called last?

[20:47] <sirrobert> I'm guessing that's the only time it can be known whether the whole matches... am I missing something in my reasoning?

[20:47] <arnsholt> As long as you don't recurse back into TOP, that should hold I think

[20:48] <sirrobert> ahh, good point.  ok, I'm pretty safe on that, I think

[20:49] <sirrobert> is there a way to auto-create an action for each grammar element?

[20:49] <sirrobert> like ... call a generic sub/method with the symbol name

[20:49] <sirrobert> or something

[20:50] <sirrobert> maybe a "call this method if there's no explicitly matching action"

[20:51] <sorear> you would do that using the fallbacks mechanism.

[20:52] <sirrobert> What's the fallbacks mechanism?  where can I read about it?

[20:52] <sirrobert> (esp. syntax)

[20:52] <sergot> tadzik: There's a little bug in mkjson.p6. I was working on it today, ll be repaired this evening. :)

[20:52] <tadzik> okay, awesome :)

[20:52] <tadzik> I'll have fresh smoketest results soonish

[20:52] <TimToady> diakopter: I usually get at that view http://rosettacode.org/wiki/Reports:Tasks_not_implemented_in_Perl_6

[20:52] <phenny> TimToady: 19:51Z <diakopter> ask TimToady have you seen http://rosettacode.org/wiki/Category:Draft_Programming_Tasks

[20:52] <sorear> n: grammar G { token TOP { x } }; class A { method FALLBACK($name,$/) { say $name } }; G.parse('x', :actions(A)) # here's how it works in niecza

[20:52] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«TOP␤»

[20:52] <sirrobert> sorear: thanks

[20:53] <sorear> rakudo has an incompatible (IMO better) system using the .^add_fallback meta method

[20:53] <sorear> but I don't know offhand how to use it

[20:53] <sirrobert> sorear: ok, thanks

[20:53] <diakopter> ha; no one's attempted http://rosettacode.org/wiki/Unicode_polynomial_equation

[20:53] <TimToady> read the talk page for why

[20:55] * lizmat will continue some more spelunking in the docs tomorrow

[20:59] <TimToady> meeting &

[21:03] *** skids left
[21:08] *** lizmat left
[21:11] *** kaare__ left
[21:16] *** Targen left
[21:17] *** atrodo left
[21:17] *** FROGGS left
[21:17] *** FROGGS__ left
[21:18] *** Targen joined
[21:20] <masak> jnthn++ # figured out what's wrong with my macros-d2 code, and hinted at what to do instead

[21:22] <masak> has this one ever gone on record as an autopun? "A Freudian slip is meaning one thing but saying your mother."

[21:25] <masak> good night, #perl6

[21:25] <diakopter> o/

[21:30] <sorear> oo/

[21:30] <sorear> masak: it hasn't, but it absolutely is one.

[21:30] <sorear> \oo/ # two headed sorear

[21:33] *** SamuraiJack left
[21:33] *** Circlepuller joined
[21:34] *** Circlepuller_ left
[21:41] <PerlJam> sorear: two heads is great, but don't you also need more hands to type code?

[21:41] <diakopter> Abby & Brittney type just fine sharing two hands

[21:42] <diakopter> *Brittany

[21:42] *** cognominal left
[21:44] *** cognominal joined
[22:00] <sergot> tadzik: done. :)

[22:01] <sergot> New feature added to modules.perl6.org ! 

[22:01] <sergot> http://feather.perl6.nl/~sergot/modules/

[22:01] <sergot> http://feather.perl6.nl/~sergot/modules/module/Acme::Addslashes.html

[22:02] <sergot> \o/

[22:02] <sergot> TODO: parsing markdown.

[22:05] *** whiteknight joined
[22:05] *** snearch left
[22:06] <[Coke]> nqp: say(Q:PIR{ %r = 3});

[22:06] <p6eval> nqp: OUTPUT«Null PMC access in set_integer_native()␤current instr.: '' pc 49 ((file unknown):162810055) (/tmp/Sb0knkHtxE:10)␤»

[22:06] <[Coke]> nqp: say(Q:PIR{ %r = box 3});

[22:06] <p6eval> nqp: OUTPUT«3␤»

[22:08] *** sHACHAF is now known as Shachaf

[22:09] <[Coke]> nqp: nqp::existkey(); say("alive");

[22:09] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op existkey: No registered operation handler for 'existkey'␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[22:10] <[Coke]> phenny: tell pmichaud that "existkey" is metioned in the docs but doesn't exist.

[22:10] <phenny> [Coke]: I'll pass that on when pmichaud is around.

[22:14] *** cognominal_ joined
[22:17] *** cognominal left
[22:17] *** fgomez joined
[22:24] <[Coke]> nqp: pir::print__vPS($*OUT,"3")

[22:24] <p6eval> nqp: OUTPUT«get_pointer_keyed_int() not implemented in class 'NQPMu'␤current instr.: '' pc 92 ((file unknown):169239368) (/tmp/FM3XAjhBXd:1)␤»

[22:24] <[Coke]> nqp: pir::print__VPS($*OUT,"3")

[22:24] <p6eval> nqp: OUTPUT«get_pointer_keyed_int() not implemented in class 'NQPMu'␤current instr.: '' pc 92 ((file unknown):158208840) (/tmp/wkDLfjpdjE:1)␤»

[22:24] <[Coke]> HALP. :)

[22:27] <[Coke]> nqp: print("HI");

[22:27] <p6eval> nqp: OUTPUT«HI»

[22:27] <[Coke]> "close enough".

[22:27] <[Coke]> nqp: $*OUT.print("HI")

[22:27] <p6eval> nqp: OUTPUT«Method 'print' not found for invocant of class 'NQPMu'␤current instr.: '' pc 96 ((file unknown):149734207) (/tmp/UCa1O__yMH:1)␤»

[22:27] <sorear> I think there is no $*OUT in NQP

[22:28] <sorear> nqp: print $*OUT

[22:28] <p6eval> nqp: OUTPUT«Confused at line 2, near "print $*OU"␤current instr.: 'panic' pc 19998 (src/stage2/gen/NQPHLL.pir:7314) (src/stage2/gen/NQPHLL.pm:325)␤»

[22:28] <sorear> nqp: print($*OUT)

[22:28] <p6eval> nqp:  ( no output )

[22:28] <sorear> nqp: print($*OUT.WHAT)

[22:28] <p6eval> nqp:  ( no output )

[22:28] <sorear> nqp: print($*OUT === NQPMu)

[22:28] <p6eval> nqp: OUTPUT«Confused at line 2, near "print($*OU"␤current instr.: 'panic' pc 19998 (src/stage2/gen/NQPHLL.pir:7314) (src/stage2/gen/NQPHLL.pm:325)␤»

[22:28] <sorear> nqp: print($*OUT =:= NQPMu)

[22:28] <p6eval> nqp: OUTPUT«1»

[22:28] <sorear> nqp: print($*OUT =:= NQPInt)

[22:28] <p6eval> nqp: OUTPUT«1»

[22:28] <sorear> nqp: print($*OUT =:= moof)

[22:28] <p6eval> nqp: OUTPUT«1»

[22:28] <sorear> nqp: print($*OUT =:= 3)

[22:28] <p6eval> nqp: OUTPUT«0»

[22:29] <sorear> $*OUT compares equal to any undefined name, hmm.

[22:29] <sorear> (I thought that NQP would throw on undefined names nowadays ??)

[22:30] *** Shachaf is now known as shachaf

[22:30] <[Coke]> I'd like a way to call pir's print opcode from nqp.

[22:33] *** stopbit left
[22:35] <sorear> nqp: pir::print__vS("foo")

[22:35] <p6eval> nqp: OUTPUT«foo»

[22:35] <sorear> nqp: pir::print__vPS(pir::getstdout__P(), "foo")

[22:35] <p6eval> nqp: OUTPUT«foo»

[22:35] *** skids joined
[22:35] <sorear> like so?

[22:38] *** bluescreen10 left
[22:39] *** stepnem left
[22:40] <[Coke]> wtf.

[22:40] <sorear> ?

[22:42] <sorear> nqp: my $err := pir::getstderr__P(); $err.print("Foo\n")

[22:42] <p6eval> nqp: OUTPUT«Foo␤»

[22:43] <sorear> nqp: pir::getinterp__P().stdout_handle().print("foo\n")

[22:43] <p6eval> nqp: OUTPUT«foo␤»

[22:43] <[Coke]> nqp: https://gist.github.com/3646684

[22:43] <p6eval> nqp:  ( no output )

[22:43] <[Coke]> so if you uncomment out the last pir::print there, horrible failure.

[22:44] <[Coke]> nqp: https://gist.github.com/3646696

[22:44] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op bind: Error while compiling block puts: Error while compiling op if: Cannot infer type from ''␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[22:44] <sorear> nqp: 1 if 1;

[22:44] <p6eval> nqp:  ( no output )

[22:44] <sorear> nqp: pir::print__vPS(pir::getstdout__P(), "foo\n");

[22:44] <p6eval> nqp: OUTPUT«foo␤»

[22:44] <sorear> nqp: pir::print__vPS(pir::getstdout__P(), "foo\n") if 1;

[22:44] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op if: Cannot infer type from ''␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[22:45] <sorear> ah

[22:45] <sorear> the problem is the if.

[22:45] *** fibo left
[22:45] <sorear> because it means $nl ?? pir::stuff !! NQPMu

[22:45] <[Coke]> that looks like reasonable code, though, yes?

[22:45] <sorear> the left side is void, though

[22:45] <diakopter> r: 1 if 1 if 1 { }

[22:45] <p6eval> rakudo cc1858:  ( no output )

[22:45] <sorear> the right side returns a PMC

[22:46] <sorear> it cannot infer the type.

[22:46] <diakopter> sorear: ^^ what does that mean, do you know?

[22:46] <sorear> nqp: pir::print__vPS(pir::getstdout__P(), "foo\n"), NQPMu if 1;

[22:46] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op if: Error while compiling op list: Cannot infer type from ''␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[22:46] <[Coke]> you get the same error if you do if 1 { ... }

[22:46] <sorear> what if you add an else?

[22:46] <sorear> nqp: pir::print__vPS(pir::getstdout__P(), "foo\n"), NQPMu;

[22:46] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op list: Cannot infer type from ''␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[22:46] <diakopter> r: 1 if 1 if 1 { say 4 }

[22:46] <p6eval> rakudo cc1858: OUTPUT«4␤»

[22:47] <sorear> nqp: (pir::print__vPS(pir::getstdout__P(), "foo\n"); 1)

[22:47] <p6eval> nqp: OUTPUT«Confused at line 2, near "(pir::prin"␤current instr.: 'panic' pc 19998 (src/stage2/gen/NQPHLL.pir:7314) (src/stage2/gen/NQPHLL.pm:325)␤»

[22:47] <sorear> nqp: do { pir::print__vPS(pir::getstdout__P(), "foo\n"); 1 }

[22:47] <p6eval> nqp: OUTPUT«Confused at line 2, near "do { pir::"␤current instr.: 'panic' pc 19998 (src/stage2/gen/NQPHLL.pir:7314) (src/stage2/gen/NQPHLL.pm:325)␤»

[22:47] <sorear> nqp: if 1 { pir::print__vPS(pir::getstdout__P(), "foo\n"); 1 }

[22:47] <p6eval> nqp: OUTPUT«foo␤»

[22:47] <sorear> nqp: if 1 { pir::print__vPS(pir::getstdout__P(), "foo\n") }

[22:47] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op if: Cannot infer type from ''␤current instr.: '' pc 42779 (src/stage2/QAST.pir:14984) (src/stage2/QAST.nqp:2244)␤»

[22:47] <sorear> [Coke]: workaround: add block with a ; 1

[22:47] <sorear> std: 1 if 1 if 1 { say 4 }

[22:47] <p6eval> std b87ea13: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing semicolon at /tmp/GKaFRsgI0G line 1:␤------> [32m1 if 1[33m⏏[31m if 1 { say 4 }[0m␤Parse failed␤FAILED 00:00 43m␤»

[22:47] <[Coke]> lame but effective. danke.

[22:47] <sorear> diakopter: It means that rakudo's parser is too lax :D

[22:48] <diakopter> yeah; I'm just wondering how it's parsing it

[22:48] *** Targen left
[22:49] <sorear> r: say (1 if 1 if 1 { } )

[22:49] <p6eval> rakudo cc1858: OUTPUT«Nil␤»

[22:49] <sorear> r: say ((1 if 1) if 1 { } )

[22:49] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2, near "if 1 { } )"␤»

[22:49] <sorear> r: say (1 if (1 if 1 { }))

[22:49] <p6eval> rakudo cc1858: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2, near "if 1 { }))"␤»

[22:49] <tadzik> sergot: woow, that's super awesome

[22:53] * [Coke] wonders, if I have nqp-rx code that calls PAST::Compiler.compile, if it's sufficient to s/P/Q/

[22:55] <tadzik> http://feather.perl6.nl/~sergot/modules/module/Typed::Subroutines.html \o/

[22:55] <tadzik> ossum

[22:56] * diakopter wonders when VMs will be relatively as lightweight as threads

[22:57] *** benabik joined
[22:57] <diakopter> hardware/OS VMs, I mean

[22:58] *** xinming left
[22:58] <tadzik> when computers become so fast that it won't matter :)

[22:58] <tadzik> good knight #perl6

[22:59] *** xinming joined
[23:00] <diakopter> sorear: I've tried tons of parentheses pairings without finding on that works

[23:00] * diakopter gives up and hopes masakbot will submit a rakudobug if it's not already

[23:02] <sorear> diakopter: i suppose you are already familiar with VM/CMS?

[23:03] <geekosaur> heh

[23:03] <leont> Don't say such scary things in the channel!

[23:05] <TimToady> then there's MVS and VMS...

[23:05] <tadzik> and CVS! \o/

[23:05] <geekosaur> bah

[23:05] <tadzik> yeah, I should be sleeping

[23:06] <geekosaur> VM/SP was doing al this virtualization stuff years ago and way better than the Intel-based stuff ever did.  and still does, Ibelieve the same technology is still in the z/OS virtualization products

[23:08] *** PacoAir left
[23:10] <Tene> diakopter: you can get pretty close with linux namespaces.

[23:10] *** Celelibi left
[23:12] *** Celelibi joined
[23:12] <sorear> [Coke]: I'm curious what partcl-nqp's current state of working is

[23:16] <[Coke]> nqp2 branch. the grammar still only recognizes "three". I'm patching up a bunch of code that compiled in nqp-rx but doesn't in nqp. but I'm not actually calling any of it yet.

[23:17] *** ashleyde1 is now known as ashleydev

[23:20] *** leont left
[23:26] *** Targen joined
[23:33] <felher> 'night, #perl6

[23:39] <colomon> o/

[23:41] *** thundergnat joined
[23:46] <thundergnat> Good * #perl6.

[23:47] <colomon> \o

[23:48] *** erkan left
[23:56] <thundergnat> I recently updated one of my perl6 modules that has been failing for a while so that it no longer ( theoretically ) does.

[23:56] <thundergnat> https://github.com/thundergnat/Sort-Naturally

[23:56] <thundergnat> But panda still won't install it, even though it seems to work ok for me when installed manually.

[23:57] <thundergnat> panda fails during the pir generation step  (e.g.  perl6 --target=pir --output=foo.pir foo.pm6 )

[23:57] <thundergnat> ===SORRY!=== Serialization Error: unknown static lexical info type for 'infix:sym<ncmp>'

[23:57] <thundergnat> I know I should probably ask this when tadzik / jnthn is around, but my schedule doesn't don't overlap theirs very well.

