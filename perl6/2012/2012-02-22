[00:01] *** [particle]1 left
[00:02] *** benabik left
[00:02] *** benabik_ left
[00:14] *** [particle] joined
[00:34] *** [particle] left
[00:35] *** [particle] joined
[00:52] *** replore_ joined
[00:58] *** Gazzonyx is now known as Gazzonyx|AFK

[01:01] *** scott___ joined
[01:13] *** alester joined
[01:15] *** NamelessTee left
[01:19] *** jferrero joined
[01:19] *** leprevost joined
[01:23] *** benabik joined
[01:24] <sorear> good * #perl6

[01:24] <colomon> \o

[01:26] *** jlaire joined
[01:27] <[Coke]> git assist? How do I convert a readwrite github clone to a readonly one?

[01:28] <sorear> Go into .git/config and remove the push URL

[01:28] <timotimo> alternative: git remote rm whateveritscalled; git remote add whateveritscalled [email@hidden.address]
[01:28] <sorear> The only difference is the default push URL

[01:37] <[Coke]> I actually want to change the default /pull/ url.

[01:37] <[Coke]> (so it won't prompt me for my password)

[01:37] <timotimo> oh, that's the point

[01:38] <timotimo> you could use a second ssh key that doesn't have a passphrase or you could use ssh-agent

[01:39] <colomon> isn't that just a matter of changing [remote "origin"] url to a readonly one?

[01:39] * colomon has only done it the other way to make a readonly clone readwrite

[01:40] <timotimo> oh, i didn't even consider that question, if you can have separate push and pull URLs

[01:40] <timotimo> well, worst case, you make an alias

[01:41] <benabik> [remote "origin"] \n url = git://github.com/name/project.git \n pushurl = [email@hidden.address]
[01:41] <benabik> I assume there's some kind of git-remote way of setting that, but I've always just edited .git/config

[01:41] <[Coke]> sorear++ - editing .git/config was the quickest way.

[01:57] *** wolfman2000 left
[01:58] *** alc joined
[02:01] *** sisar joined
[02:02] *** lutok joined
[02:12] *** sisar left
[02:14] <[Coke]> # 02/21/2012 - niecza++ ; pugs (14.83%); rakudo (99.04%)

[02:14] <[Coke]> (same results as before, just automatically generated.)

[02:15] <TimToady> [Coke]++

[02:16] *** alc left
[02:16] <[Coke]> and redone to make it trivial if I have to add a /fourth/ implementation. :P

[02:24] *** Trashlord left
[02:25] *** am0c joined
[02:25] <colomon> [Coke]++

[02:26] *** Trashlord joined
[02:27] *** c1sung left
[02:27] <dalek> roast: 748c80b | coke++ | S03-operators/value_equivalence.t:

[02:27] <dalek> roast: pugs fudge

[02:27] <dalek> roast: review: https://github.com/perl6/roast/commit/748c80bdfd

[02:28] <dalek> Pugs.hs: bb05f13 | coke++ | t/spectest.data:

[02:28] <dalek> Pugs.hs: run test

[02:28] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/bb05f136ca

[02:29] *** alc joined
[02:40] *** Alias left
[02:51] *** am0c_ joined
[02:51] *** am0c left
[02:53] *** am0c_ is now known as am0c

[02:54] *** whiteknight left
[03:13] *** lutok left
[03:13] <bacek_at_work> phenny, tell moritz cont_reuse branch is merged.

[03:13] <phenny> bacek_at_work: I'll pass that on when moritz is around.

[03:14] *** skids joined
[03:16] *** bluescreen10 left
[03:17] *** replore_ left
[03:20] *** benabik left
[03:20] *** benabik joined
[03:27] *** toddr_ joined
[03:29] *** orafu left
[03:31] *** orafu joined
[03:31] <sorear> [Coke]++

[03:39] *** alester left
[03:41] <dalek> features: 3f68424 | (Solomon Foster)++ | features.json:

[03:41] <dalek> features: Niecza has rand, pick, roll, Sets, KeySet, Bag, and KeyBag now.

[03:41] <dalek> features: review: https://github.com/perl6/features/commit/3f684248f4

[03:47] *** alc left
[04:00] *** alvis left
[04:33] *** alvis joined
[04:34] <TimToady> heh, just got a work email saying I'm required to take courses in Logic/Problem Solving, Written Communication, Verbal Communication, and Time Management

[04:34] <TimToady> from which I derive much hilarity...

[04:38] <sorear> most of my written communication is also verbal.

[04:38] <sorear> I guess it's an art class of some kind.

[04:39] *** alc joined
[04:40] *** mucker joined
[04:40] * shachaf wonders where TimToady works.

[04:43] <sorear> the bay area

[04:46] *** [particle] left
[04:59] *** [particle] joined
[05:03] <shachaf> sorear: I didn't mean geographically.

[05:03] * shachaf dropped ingy off at TimToady's house once.

[05:05] * TimToady is not interested in naming names

[05:08] *** birdwindupbird joined
[05:10] <shachaf> OK.

[05:25] *** att_ left
[05:26] <sorear> (o/ shachaf)

[05:36] <shachaf> sorear: (Hoy.)

[05:47] *** mucker left
[05:51] *** mucker joined
[05:53] *** kaleem joined
[05:55] *** skids left
[06:03] <moritz> o/

[06:03] <phenny> moritz: 21 Feb 23:28Z <bacek_at_work> tell moritz I'm going to merge parrot's cont_reuse branch really soon. You'll need take_recon branch merged with bumping up PARROT_REVISION.

[06:03] <phenny> moritz: 03:13Z <bacek_at_work> tell moritz cont_reuse branch is merged.

[06:03] <sorear> o/ moritz 

[06:04] <bacek_at_work> moritz, \o

[06:04] *** mucker left
[06:05] <dalek> nqp: 052bc4b | moritz++ | tools/build/PARROT_REVISION:

[06:05] <dalek> nqp: bump parrot requirement to 4.1 release

[06:05] <dalek> nqp: review: https://github.com/perl6/nqp/commit/052bc4b116

[06:06] <moritz> bacek_at_work: the bumping will only happen after the Rakudo release on Thursday

[06:07] <bacek_at_work> moritz, no worries. Just make sure when merge take_recon branch bump it again.

[06:08] <moritz> sure

[06:28] *** toddr_ left
[06:49] *** takesako left
[06:52] *** takesako joined
[06:53] *** NamelessTee joined
[06:59] *** wtw joined
[07:08] <moritz> perl6: multi unfix:bla($x)  { say $x }; unfix:bla(3)

[07:08] <p6eval> niecza v14-57-gd05a5fe: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§System.Exception: Unable to find lexical $x in ANON‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ‚ê§  at Niecza.CLRBack‚Ä¶

[07:08] <p6eval> ..rakudo 4130f6: OUTPUT¬´===SORRY!===‚ê§Cannot add tokens of category 'unfix' with a sub‚ê§¬ª

[07:08] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected ":bla"‚ê§    expecting "::", "handles", "is", bare trait, subroutine parameters, trait or block‚ê§    at /tmp/gQytNGHniz line 1, column 12‚ê§¬ª

[07:08] <moritz> rakudo++ # most awesome error message of the three

[07:12] <sorear> while awesome, rakudo's error message is wrong, iiuc

[07:12] <bacek_at_work> "unfix"?

[07:12] <sorear> "unfix" isn't a special category name, so unfix:bla<...> is just a sub name

[07:13] <sorear> the error is in :bla($x) - $x is not defined yet, it should be an undeclared variable error

[07:13] <sorear> if you wanted a signature, you need to use unfix:bla ($x) {...}

[07:14] <sorear> this has bit me a couple times in niecza, when I write method term:variable($/) { ... } in the actions and then wonder why the parser explodes

[07:14] <sorear> need a space

[07:14] <sorear> bacek_at_work: Fuzz testing - deliberate typo of "infix"

[07:15] <bacek_at_work> sorear, thanks! It's kind of clear weirdness :)

[07:15] <sorear> IMO niecza's error is righter, although less useful

[07:15] <sorear> what really

[07:16] <sorear> what's really needed is some kind of integration of explain_mystery into the name extension mechanism, like what's already done for BEGIN

[07:16] <sorear> niecza: BEGIN $x

[07:16] <p6eval> niecza v14-57-gd05a5fe: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Variable $x is not predeclared at /tmp/xEHAy3vWZM line 1:‚ê§------> [32mBEGIN [33m‚èè[31m$x[0m‚ê§‚ê§Unhandled exception: System.Exception: Unable to find lexical $x in ANON‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.‚Ä¶

[07:17] <sorear> I need to fudge the ResolveLex thing into a real error, and handled at the correct time

[07:17] <sorear> niecza: sub foo() { bar if 0 }; BEGIN { foo }; sub bar() { say "hi" } # iirc, last time I asked TimToady, this is explicitly OK

[07:17] <p6eval> niecza v14-57-gd05a5fe: OUTPUT¬´Unhandled exception: System.Exception: Unable to find lexical &bar in foo‚ê§  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ‚ê§  at Niecza.CLRBackend.NamPro‚Ä¶

[07:18] <sorear> nom: if 0 { foo }

[07:18] <p6eval> nom 4130f6: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&foo' called (line 1)‚ê§¬ª

[07:18] <sorear> b: if 0 { foo }

[07:18] <p6eval> b 1b7dd1:  ( no output )

[07:18] <sorear> walk&

[07:19] *** xinming left
[07:32] *** xinming joined
[07:38] *** tarch joined
[07:47] *** NamelessTee left
[07:47] *** NamelessTee joined
[07:58] *** Jerkwad joined
[08:02] *** am0c left
[08:10] *** [particle] left
[08:11] *** [particle] joined
[08:12] *** aindilis` joined
[08:12] *** aindilis left
[08:15] *** pernatiy left
[08:24] *** mj41 joined
[08:26] *** xinming left
[08:28] *** NamelessTee left
[08:34] *** xinming joined
[08:37] *** proller_ left
[08:45] *** noam left
[08:46] *** noam joined
[08:52] <jnthn> morning, #perl6

[08:53] <moritz> \o jnthn 

[09:06] *** ab5tract joined
[09:12] *** kaleem left
[09:12] *** Jerkwad left
[09:12] *** kaleem joined
[09:27] *** dakkar joined
[09:30] *** pmurias joined
[09:32] <pmurias> if I have "class Foo {...}" in Foo.pm6 and I have "use Foo" in my program Foo gets imported into my lexical scope 

[09:36] <pmurias> ?

[09:37] <moritz> classes are our-scoped by default, so they are merged into your GLOBAL while loading

[09:37] <moritz> not sure if they also get a lexical alias

[09:37] *** stepnem left
[09:48] <jnthn> It'll only be lexically imported if you mark it "is export"

[09:48] <jnthn> Otherwise what moritz said.

[09:49] *** stepnem joined
[09:50] * moritz can imagine the "fun" in bridging the gap between lexical export in Perl 6 and the package based Perl 5 stuff

[09:52] <masak> antenoon, #perl6

[09:52] <moritz> good *, masak

[09:52] <masak> *, indeed.

[09:55] <au> good ambinoon masak :)

[09:57] <jnthn> o/ masak 

[09:58] <masak> "ambinoon" sounds like how I felt waking up this antenoon. :)

[09:59] <au> :)

[10:03] *** am0c joined
[10:04] *** alc left
[10:06] *** MayDaniel joined
[10:06] *** MayDaniel left
[10:15] <pmurias> jnthn: so if the class isn't marked with is export I have to take it out from GLOBAL?

[10:16] <moritz> even if it is exported, it needs to be GLOBAL merged

[10:17] <moritz> only if it's 'my', it's not

[10:19] *** fsergot joined
[10:20] <fsergot> o/ :)

[10:20] <pmurias> moritz: Foo.new() avoids looking into GLOBAL?

[10:21] *** kaleem left
[10:21] <masak> fsergot! \o/

[10:21] <moritz> pmurias: I don't think so, but I'm not sure

[10:22] <pmurias> $foo.new doesn't look into GLOBAL unless we use 'no strict' right?

[10:24] * masak doesn't even understand the question

[10:24] <jnthn> pmurias: What moritz said. And yeah, Foo.new() in that case comes from GLOBAL, but it's declarative so we can statically resolve that reference at compile time. So Rakudo actually only does the GLOBAL lookup during the compile.

[10:25] <pmurias> masak: we can do a lexical lookup or a package lookup or both

[10:25] <jnthn> In "no strict" I'm not sure what scope we'll auto-declare with.

[10:25] <moritz> our-scope, just like in Perl 5

[10:25] <jnthn> OK :)

[10:25] <pmurias> moritz: our-scope?

[10:26] <moritz> otherwise things like { $x }; { $x }  would be rather surprising

[10:27] <pmurias> moritz: our both declares a package variable and creates an lexical alias to it

[10:28] <masak> nom: { our $a = 42 }; say $a

[10:28] <p6eval> nom 4130f6: OUTPUT¬´===SORRY!===‚ê§Variable $a is not declared‚ê§at /tmp/_0FYRayuIK:1‚ê§¬ª

[10:28] <moritz> right

[10:28] <masak> perhaps the easiest way to demonstrate that.

[10:28] <moritz> under 'no strict', that would print 42

[10:28] <masak> nom: { our $a = 42 }; say our $a

[10:28] <p6eval> nom 4130f6: OUTPUT¬´Any()‚ê§¬ª

[10:28] <masak> huh!

[10:29] <pmurias> nom: {our $a = 42};our $a; say $a;

[10:29] <p6eval> nom 4130f6: OUTPUT¬´Any()‚ê§¬ª

[10:29] <masak> I call bug.

[10:29] <pmurias> me too

[10:29] * masak submits rakudobug

[10:29] *** alim_ joined
[10:29] <masak> b: { our $a = 42 }; say our $a

[10:29] <moritz> because either the outer $a is looked up in the package, or a lexical alias is installed in the outer most scope that makes any sense

[10:29] <p6eval> b 1b7dd1: OUTPUT¬´42‚ê§¬ª

[10:29] <masak> niecza: { our $a = 42 }; say our $a

[10:29] <p6eval> niecza v14-57-gd05a5fe: OUTPUT¬´42‚ê§¬ª

[10:29] <moritz> I could have sworn that one worked in nom

[10:30] <masak> rewind and check :)

[10:30] <moritz> niecza: { our sub a { 42 } }; (our &a).()

[10:30] <p6eval> niecza v14-57-gd05a5fe:  ( no output )

[10:30] <moritz> perl6: { our sub a { 42 } }; (our &a).()

[10:30] <p6eval> pugs b927740: OUTPUT¬´*** Cannot use Undef as a Code object‚ê§    at /tmp/80v29q0aur line 1, column 23 - line 2, column 1‚ê§¬ª

[10:30] <p6eval> ..rakudo 4130f6, niecza v14-57-gd05a5fe:  ( no output )

[10:30] <moritz> perl6: { our sub a { say 42 } }; (our &a).()

[10:30] <p6eval> rakudo 4130f6, niecza v14-57-gd05a5fe: OUTPUT¬´42‚ê§¬ª

[10:30] <p6eval> ..pugs b927740: OUTPUT¬´*** Cannot use Undef as a Code object‚ê§    at /tmp/IOV3ixLUgf line 1, column 27 - line 2, column 1‚ê§¬ª

[10:30] <pmurias> niecza: {our class Foo {}};say Foo.new.perl

[10:30] *** kaleem joined
[10:30] <p6eval> niecza v14-57-gd05a5fe: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared name:‚ê§        'Foo' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ‚ê§  at /home/p6‚Ä¶

[10:30] <pmurias> niecza: our class Foo {};say Foo.new.perl

[10:31] <p6eval> niecza v14-57-gd05a5fe: OUTPUT¬´Foo.new(...)‚ê§¬ª

[10:32] <pmurias> jnthn: you agree with niecza on "{our class Foo {}};say Foo.new.perl" not working?

[10:32] <moritz> nom: {our class Foo {}}; say Foo.new.perl

[10:32] <p6eval> nom 4130f6: OUTPUT¬´Foo.new()‚ê§¬ª

[10:33] *** scott___ left
[10:34] <jnthn> pmurias: no

[10:34] <moritz> std: {our class Foo {}}; say Foo.new.perl

[10:34] <p6eval> std 52f3895: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[10:34] <moritz> niecza is clearly outnumbered here :-)

[10:35] <jnthn> pugs: {our class Foo {}}; say Foo.new.perl

[10:35] <p6eval> pugs b927740: OUTPUT¬´Foo.new()‚ê§¬ª

[10:35] <jnthn> Completely :)

[10:36] <moritz> perlito: {our class Foo {}}; say Foo.new.perl

[10:36] <masak> moritz: re "or a lexical alias is installed in the outer most scope that makes any sense" -- do you have an example of that? I can't think of one.

[10:36] <masak> ENOPERLITO

[10:37] <moritz> masak: it's really just an implementation detail on how one might handle 'no strict;' -- I don't think there's any user visible code that would behave differently

[10:37] <masak> oh, you were talking about the 'no strict' case.

[10:38] <masak> I immediately got to thinking about my old http://strangelyconsistent.org/blog/where-in-the-world-is-the-package-lexpad post.

[10:38] <masak> where I mistakenly think that package variables are in a lexpad somewhere along the lexical lookup chain.

[10:39] <pmurias> jnthn: so Foo is treated differently from $foo in {our $foo=12};say $foo.perl?

[10:39] <moritz> well, it were murky waters in the earlier Perl 6 days, iirc

[10:39] <moritz> pmurias: correct

[10:40] <moritz> pmurias: $foo is always only lexically looked up (except maybe under 'no strict;')

[10:40] <moritz> type names fall back to GLOBAL if not found in the lexical scope

[10:40] <jnthn> Right. It's all consistent, given that type names default to installing in the package, and variables don't.

[10:40] *** am0c left
[10:50] *** [particle] left
[11:01] *** [particle] joined
[11:02] *** daxim joined
[11:04] *** noam left
[11:04] *** noam joined
[11:09] *** ab5tract left
[11:11] *** noam left
[11:11] *** noam joined
[11:21] *** JimmyZ joined
[11:25] <fsergot> Is directories handling implemented in rakudo?

[11:26] * JimmyZ pulls requests to nqp

[11:27] <moritz> fsergot: depends on what you mean by that

[11:28] <moritz> fsergot: there's a &dir function that gives you a directory listing

[11:28] <fsergot> Opening, removing etc. :)

[11:28] <moritz> in the world of lazy lists, explicit opening and iterating is a poor abstraction

[11:28] <moritz> whis is why we have &dir

[11:29] <jnthn> nom: { our $a = 42 }; { our $a; say $a }

[11:29] <p6eval> nom 4130f6: OUTPUT¬´42‚ê§¬ª

[11:29] <jnthn> Thought so...

[11:31] *** sisar joined
[11:33] <masak> jnthn: why does that one work but not the other one?

[11:33] <jnthn> masak: Just plain old auto-viv semantics.

[11:34] <jnthn> masak: It binds the lexical to $?PACKAGE.WHO<$a> at block entry

[11:35] <jnthn> Which isn't quite what we want here...

[11:35] <jnthn> .oO( why can't anything ever be simple... )

[11:35] <moritz> because it's not assembler :-)

[11:36] <jnthn> oh, but we can leave it as it is

[11:36] <jnthn> The problem solves itself if we do that assignment at INIT time, as we should.

[11:37] <jnthn> so, it needn't get more complicated after all :)

[11:37] <dalek> roast: d85265c | (Pawe≈Ç Murias)++ | S01-perl-5-integration/context.t:

[11:37] <dalek> roast: Fix test plan.

[11:37] <dalek> roast: review: https://github.com/perl6/roast/commit/d85265cf10

[11:40] *** PerlJam left
[11:41] <dalek> niecza: ad83416 | (Pawe≈Ç Murias)++ | t/spectest_p5.data:

[11:41] <dalek> niecza: Do not run a spec test I forgot to commit and lost in a laptop failure.

[11:41] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ad834163d0

[11:41] <dalek> niecza: 5868454 | (Pawe≈Ç Murias)++ | lib/ (2 files):

[11:41] <dalek> niecza: Load the perl5 side interop support from a directory relative to the

[11:41] <dalek> niecza: .net side dll.

[11:41] <dalek> niecza: review: https://github.com/sorear/niecza/commit/586845481b

[11:42] <pmurias> what should i turn a p5 undef into? i currently turn it into a Nil but i'm not sure it's correct

[11:43] *** Util left
[11:45] <fsergot> nom: my $list = 1,2,3; say $list.perl;

[11:45] <p6eval> nom 4130f6: OUTPUT¬´1‚ê§¬ª

[11:45] <fsergot> nom: my $list = 1,2,3; .say for $list;

[11:45] <p6eval> nom 4130f6: OUTPUT¬´1‚ê§¬ª

[11:48] *** NamelessTee joined
[11:50] *** Trashlord left
[11:57] *** [Coke] joined
[11:59] *** Util joined
[12:01] *** masak joined
[12:01] *** pmichaud joined
[12:01] *** PerlJam joined
[12:01] <au> pmurias: Any perhaps (closer to item semantic of undef in p5)?

[12:01] *** benabik left
[12:03] *** aindilis` left
[12:03] *** aindilis` joined
[12:06] <colomon> pmurias: https://gist.github.com/1884535 is what I get when I run p5test now.

[12:14] * colomon has suddenly wondered if the tech that makes pmurias++'s p5 interop work with niecza could also implement Zavolaj-niecza....

[12:14] <colomon> \

[12:15] *** p6eval left
[12:15] *** tadzik joined
[12:17] *** awwaiid left
[12:18] *** leprevost left
[12:18] *** awwaiid joined
[12:18] *** pernatiy joined
[12:19] *** aindilis` left
[12:20] <pmurias> colomon: hi

[12:20] *** leprevost joined
[12:21] <pmurias> colomon: the problem seems to be we can load a shared library into niecza, but we can't load a shared library using p5 into niecza

[12:23] <colomon> hmmm... does that mean that pure-Perl (5) stuff ought to work for me?

[12:25] <pmurias> no

[12:25] <pmurias> colomon: it means that pure-C stuff could work but we don't have any support for that yet ;)

[12:26] <colomon> oh

[12:26] <pmurias> according to sorear there might be a problem with loading a static perl into a shared library

[12:26] <pmurias> on some platforms

[12:27] <colomon> what can I do to help?

[12:27] <pmurias> building perl as shared library would help check that

[12:28] * pmurias is writing a test that loads perl5 into a shared library from a c program to test that

[12:28] *** kaleem left
[12:29] *** am0c joined
[12:29] *** kaleem joined
[12:31] * colomon tries to remember if he has perlbrew installed on his mac

[12:31] *** tokuhirom joined
[12:37] *** p6eval joined
[12:37] *** ChanServ sets mode: +v p6eval

[12:39] <dalek> niecza: 0cf5e60 | (Pawe≈Ç Murias)++ | p5test/p5test.pl:

[12:39] <dalek> niecza: Add a test for calling p5 code from a shared library.

[12:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0cf5e60049

[12:39] <pmurias> colomon: i commited the test, not sure if gcc tmp/test6lib$so_extension} test6.c works on mac os x

[12:41] *** Juerd joined
[12:47] <cognominal> (grammar { token TOP {  <a>? $<b>='b' }; token a  {  a  } }).parse: 'ab'; say $/<b>.keys;

[12:48] <cognominal> nom: (grammar { token TOP {  <a>? $<b>='b' }; token a  {  a  } }).parse: 'ab'; say $/<b>.keys;

[12:48] <p6eval> nom 4130f6: OUTPUT¬´a‚ê§¬ª

[12:48] <cognominal> nom: (grammar { token TOP {  <a> $<b>='b' }; token a  {  a  } }).parse: 'ab'; say $/<b>.keys;

[12:48] <p6eval> nom 4130f6: OUTPUT¬´‚ê§¬ª

[12:49] <cognominal> jnthn, this does not make any sense to me that $/<b>.keys  returns anything different than a void Parcel

[12:49] <cognominal> should I file a bug?

[12:51] *** NamelessTee left
[12:51] <moritz> nom: (grammar { token TOP {  <a> $<b>='b' }; token {  a  } }).parse: 'ab'; say $/<b>.keys.WHAT;

[12:51] <p6eval> nom 4130f6: OUTPUT¬´Method 'a' not found for invocant of class '<anon>'‚ê§  in regex TOP at /tmp/fZXy8AXoHU:1‚ê§  in method parse at src/gen/CORE.setting:8019‚ê§  in block <anon> at /tmp/fZXy8AXoHU:1‚ê§‚ê§¬ª

[12:51] <moritz> nom: (grammar { token TOP {  <a> $<b>='b' }; token a {  a  } }).parse: 'ab'; say $/<b>.keys.WHAT;

[12:51] <p6eval> nom 4130f6: OUTPUT¬´List()‚ê§¬ª

[12:52] <moritz> cognominal: it's returns an empty List, not an empty Parcel. Is that your problem?

[12:52] <cognominal> see the first example, it prints "a\n".

[12:53] <cognominal> I don't care if it is a parcel or a list. Whatever it is should be empty.

[12:53] <moritz> agreed

[12:54] <cognominal> it does not happen when I delete the '?' suffix.

[12:55] <moritz> though of course the ? quantifier on <a> should not affect $<b>

[12:55] <cognominal> yes, that's my point.

[12:55] <moritz> agreed. Bug it is.

[12:56] *** sftp left
[12:57] *** benabik joined
[12:57] <cognominal> it took me a while to golf it. Probably because my code hits other bugs as well.

[12:59] *** sftp joined
[13:02] * masak submits rakudobug

[13:11] <flussence> it's impossible to search for punctuation-heavy strings like $*OUT in the ir clogs :(

[13:12] <masak> flussence: can we help you?

[13:12] <masak> nom: my $*OUT = class { method say { die "hehehe" } }; say 42

[13:12] <p6eval> nom 4130f6: OUTPUT¬´Too many positional parameters passed; got 2 but expected 1‚ê§  in method print at src/gen/CORE.setting:692‚ê§  in sub say at src/gen/CORE.setting:6078‚ê§  in block <anon> at /tmp/ignWXVf8SR:1‚ê§‚ê§¬ª

[13:12] <masak> nom: my $*OUT = class { method say(*@) { die "hehehe" } }; say 42

[13:12] <p6eval> nom 4130f6: OUTPUT¬´Too many positional parameters passed; got 2 but expected 1‚ê§  in method print at src/gen/CORE.setting:692‚ê§  in sub say at src/gen/CORE.setting:6078‚ê§  in block <anon> at /tmp/iSTrDYAOCf:1‚ê§‚ê§¬ª

[13:12] <moritz> flussence: I accept patches for a better search facility

[13:13] <moritz> flussence: I have a branch that revamps the search based on KinoSearch, but that won't help you with punctuation stuff

[13:13] <masak> nom: my $*OUT = class { method print(*@) { die "hehehe" } }; say 42

[13:13] <p6eval> nom 4130f6: OUTPUT¬´hehehe‚ê§  in method print at /tmp/aQgO9nmRF8:1‚ê§  in sub say at src/gen/CORE.setting:6078‚ê§  in block <anon> at /tmp/aQgO9nmRF8:1‚ê§‚ê§¬ª

[13:14] <cognominal> masak, I submitted a ticket as well. Do you know how to merge them?

[13:14] <flussence> it doesn't really need better search, it needs a way to do *dumber* search :)

[13:14] <moritz> flussence: I also accept patches for dumber search :-)

[13:15] <masak> cognominal: I'm on it.

[13:15] <cognominal> masak: and my subject was useless compared to yours

[13:15] * flussence looks at the code

[13:15] <moritz> flussence: right now it just uses the mysql fulltext search. That sucks.

[13:16] <masak> cognominal: done.

[13:16] <cognominal> masak++

[13:16] <flussence> moritz: I'm painfully aware of that, I've had to use it myself at work this week :)

[13:16] <moritz> flussence: the 'kinosearch' branch is more interesting; maybe change it to create a second index with no stemmer and a really simple tokenizer

[13:22] <cognominal> Moritz, I don't understand what the "Any(Str)" means in  "my Mu %hash{Any(Str)}"

[13:23] <moritz> cognominal: that's the new coercion syntax

[13:23] <moritz> cognominal: accepts Any, and coerces to Str

[13:23] <masak> NYI

[13:24] <moritz> nom: say Str(4)

[13:24] <p6eval> nom 4130f6: OUTPUT¬´4‚ê§¬ª

[13:24] <flussence> does that work anywhere?

[13:24] <cognominal> ha, I keep forgetting about the coercion syntax. thx.

[13:24] <moritz> that one works, but that's really just a tiny bit of it

[13:24] <masak> good news: wrote three new macro tests. they all pass.

[13:24] <moritz> flussence: no

[13:24] <masak> bad news: got a segfault at program exit. :/

[13:24] <moritz> :/

[13:24] <masak> been a while since I created one of those.

[13:25] <masak> figures that mucking with lexpads and contexts would create one. :)

[13:25] <moritz> masak: well, I've created test failures for lexically adding multi operators by changing totally unrelated setting code

[13:25] <jnthn> Well, the usual treatment. See if it works with -G. If so, look for missing write barrier. :)

[13:25] <masak> oh!

[13:26] <masak> there's a procedure. nice.

[13:26] <jnthn> masak: We added a dynop. It may well be missing a WB.

[13:26] <dalek> roast: d217498 | masak++ | S06-macros/macros-d1.t:

[13:26] <dalek> roast: [S06-macros/macros-d1.t] three new tests

[13:26] <dalek> roast: 

[13:26] <dalek> roast: These cover lexical lookup from inside the quasi block.

[13:26] <dalek> roast: review: https://github.com/perl6/roast/commit/d217498c6c

[13:26] <masak> aye.

[13:28] <masak> jnthn: by "with -G", do you mean this?

[13:28] <masak> $ install/bin/parrot -G perl6.pbc t/spec/S06-macros/macros-d1.t 

[13:28] <jnthn> ja

[13:29] *** kaleem left
[13:29] *** am0c left
[13:30] <masak> 'cus that still segfaults at end.

[13:31] <moritz> +XXX HAHAHA DISREGARD THAT

[13:31] <moritz> erm, what?

[13:31] <masak> hahaha.

[13:31] <masak> disregard that :)

[13:32] <masak> it was late at night, and I punted writing a real comment till later.

[13:34] <masak> fixed now :)

[13:35] <dalek> rakudo/macros2: 913dc7b | masak++ | src/ops/perl6.ops:

[13:35] <dalek> rakudo/macros2: [perl6.ops] wrote a real comment

[13:35] <dalek> rakudo/macros2: 

[13:35] <dalek> rakudo/macros2: moritz++ for noticing.

[13:35] <dalek> rakudo/macros2: review: https://github.com/rakudo/rakudo/commit/913dc7b513

[13:36] <masak> jnthn: that WB stuff now stands between the macros2 branch and release.

[13:37] <masak> well, "and merge", I should say.

[13:40] <jnthn> masak: er, if it still segfaults with -G then it's not a missing WB.

[13:41] <jnthn> masak: Time to break out gdb.

[13:41] <masak> oki

[13:41] * masak does so

[13:41] <colomon> pmurias: test6lib.c -- no such file

[13:42] *** snearch joined
[13:42] <masak> jnthn: https://gist.github.com/1885215 -- gdb session

[13:44] <moritz> Rakudo_cont_decontainerize seems like a magnet for segfaults

[13:45] <cognominal> http://knowyourmeme.com/memes/fcking-magnets-how-do-they-work  :)

[13:46] <benabik> http://science.howstuffworks.com/magnet.htm :)

[13:46] <moritz> :-)

[13:47] <moritz> but that link doesn't answer the fundamental question of how magnets work

[13:47] <jnthn> moritz: It's called a *lot*, so largely just probability :)

[13:48] <jnthn> masak: Hm...so what gets called after all tests?

[13:48] <moritz> and I'm not even sure that question even has a sensible answer

[13:48] <benabik> Why magnetic domains exist relates to the spin of electrons and other fun quantum mechanical properties, so it's not surprising it doesn't go into that level of detail.

[13:49] <moritz> at some level, things just are the way they are, and "why?" doesn't reveal any more interesting relevations

[13:49] <benabik> moritz: People at the LHC disagree.  :-D

[13:50] <moritz> benabik: I beg to differ

[13:50] <dalek> niecza: 4994ff0 | (Pawe≈Ç Murias)++ | p5test/test6 (2 files):

[13:50] <dalek> niecza: Add missing files.

[13:50] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4994ff0a63

[13:51] <moritz> they try to come up with / verify new models

[13:51] <moritz> but those models don't answer the question of "why?" any more than the Maxwell equations do

[13:51] <masak> jnthn: nuth'n'

[13:52] <jnthn> masak: Something must somewhere - it explodes *inside* the multi-dispatcher.

[13:52] <moritz> and neither the "how?". It's only taken one level further

[13:52] <masak> moritz: Feynman is with you there.

[13:52] <masak> moritz: models, in that sense, are highly unsatisfactory.

[13:52] <pmurias> colomon: sorry, i keep forgetting to add files :(

[13:52] <masak> which is why it's easiest to just let go of "that sense" and focus on what we can find out :)

[13:53] * moritz wants a tshirt saying "Feynman is on my side" or "Feynman is with me" :-)

[13:53] <masak> :D

[13:53] <masak> "I'm Feynman, and I approve of this moritz"

[13:54] <gfldex> in 2012.01-155-g4130f6f on cygwin make install fails with "/bin/cp: omitting directory `docs/announce'"

[13:54] <gfldex> i think there should be a /bin/cp -r instead

[13:54] <masak> jnthn: oh! I wrote 10 tests, but it explodes after the ninth!

[13:55] <jnthn> Aha!

[13:56] <jnthn> You should at-ten-d to that test count :P

[13:57] <dalek> roast: c677b73 | masak++ | S06-macros/macros-d1.t:

[13:57] <dalek> roast: [S06-macros/macros-d1.t] fixed a test a bit

[13:57] <dalek> roast: 

[13:57] <dalek> roast: Rakudo presently fails this one; fixed so that it fails

[13:57] <dalek> roast: it in a nicer way.

[13:57] <dalek> roast: review: https://github.com/perl6/roast/commit/c677b73b49

[13:58] <masak> jnthn: I know why it happens now.

[13:59] <masak> remember how there were three places in Actions.pm which handled macros...?

[13:59] <masak> and how we PoC'd one of the places... :)

[13:59] <masak> guess which use case the test isn't using?

[13:59] <pmurias> PoC?

[13:59] <masak> proof-of-concept.

[14:00] * masak <== suffering from a combination of laziness and amnesia, it appears

[14:00] <jnthn> :P

[14:00] <masak> ah well. easily fix'd.

[14:00] <jnthn> masak: That's what happens when one slips off the Ballmer peak. :P

[14:00] <gfldex> as long as you forget to be lazy it's all fine

[14:01] * moritz often adds TODO comments to not forget such stuff

[14:06] <masak> yeah, that would've helped here.

[14:09] * jnthn is just happy that there's not a super-evil segfault to track down. Well, hopefully :)

[14:10] <cognominal> guys, the french Perl workshop will be in Jun 29-30 (that's Friday-Saturday), there should be a parallel haskell hackathon event too. The organizers would like the third track to be English.  p6er talkers welcome. I don't think there is any web site yet.

[14:11] * masak hopes he can be there

[14:11] <cognominal> the parallel haskell event is ok with serial programmers too.

[14:11] <cognominal> :)

[14:12] <cognominal> That will be in Strasbourg too. So the food should be good.

[14:12] <fsergot> Is it hard to implement mkdir, opendir and rmdir functions in rakudo nom?

[14:13] <jnthn> fsergot: mkdir and rmdir should be easy. Why not use "dir" instead of opendir et al?

[14:13] <jnthn> cognominal: Will see if I can make it. Hopefully. :)

[14:14] <fsergot> jnthn: I use "dir", but how to remove a dir?  :)

[14:14] <fsergot> jnthn: unlink is only for files, isn't it? :)

[14:14] <jnthn> fsergot: By implemetning rmdir ;-)

[14:14] <cognominal> jnthn, masak: I hope with your macro and serialization stuff, rakudo will be exciting by then

[14:15] <fsergot> jnthn: I want to do this, but I don't know where to start. :)

[14:15] <cognominal> but it would be nice to have someone talking about niecza.

[14:15] <cognominal> ...as well

[14:15] <fsergot> jnthn: Could You teach me? :)

[14:16] <jnthn> fsergot: I'd love to but sadly have to catch a train really soon.

[14:16] <fsergot> jnthn: I don't know how this process looks. :)

[14:16] <jnthn> fsergot: In short though, I suspect Parrot already provides the operations

[14:17] <jnthn> fsergot: Look at sub unlink in src/core/IO.pm

[14:17] <jnthn> fsergot: It woudln't surprise me if mkdir and rmdir wnat to look very much liek that.

[14:17] <jnthn> *like

[14:18] <fsergot> jnthn: Thank You. :)

[14:18] <masak> cognominal: who would that be? all the niecza people are on the other side of a big ocean.

[14:18] <cognominal> I don't know.

[14:18] <masak> of course, if jnthn talks about Rakudo, I could talk about Niecza.

[14:19] <cognominal> maybe with sponsoring, we can make someone cross the atlantic. I will talk with eiro about that.

[14:19] <cognominal> Depends on the sponsoring...

[14:19] <jnthn> masak: I thought you'd talk about macros? :)

[14:19] <masak> "Niecza: the compiler for der √ºber-programmer"

[14:20] <masak> jnthn: that's Erlangen. I haven't decided what to talk about in Paris yet :)

[14:21] <cognominal> I suppose that with a English track, you will have plenty of time.

[14:21] <cognominal> masak: and that's in downtown Strasbourg, not Paris.

[14:21] <masak> ah, right.

[14:22] <masak> so used to thinking Paris when I think FPW. :)

[14:22] <cognominal> which is way more insteresting than the area around the Cit√© des sciences

[14:22] <moritz> fsergot: I guess the first step is to look if parrot has a solution for deleting directories

[14:23] <fsergot> moritz: I'm looking for this. Could You hint me, where to look?

[14:23] <moritz> fsergot: I'd use ack in the parrot repo

[14:23] <fsergot> moritz: is there any website? Or just google it? :)

[14:24] <jnthn> station &

[14:24] *** Tedd1^ left
[14:24] *** tokuhirom left
[14:24] *** Tedd1 joined
[14:24] <masak> jnthn: bon voyage!

[14:26] <jnthn> dans le premier classe de le tren...tres tres elite... :P

[14:26] <jnthn> back this evening o/

[14:26] <benabik> The rm method on the OS dynpmc will do rmdir if given a directory path.

[14:27] <moritz> benabik: just found that too. But do we really want to spoil the fun for fsergot++? :-)

[14:28] <benabik> moritz: Generally, I find poking around PMC sources to be more irritating that required.  :-D

[14:28] <benabik> Although reading them is far less pain the writing them.

[14:28] <moritz> aye

[14:28] <moritz> but I find it's the only efficent-ish way to find out if something is implemented

[14:29] <moritz> would I look in 'file' or 'os' dynpmc? or maybe in core, not dynpmc? or maybe as a dynop?

[14:29] <moritz> browsing the documentation is just pain, because there's nearly never one obvious place to look

[14:29] <benabik> moritz: Also, ack won't search .pmc files by default.  It would return the information from the generated .c file, which is far harder to trace back to something useful.

[14:30] <flussence> ack --parrot will :)

[14:30] <moritz> benabik: ah, my ack does search .pmc files by default :-)

[14:31] <masak> std: sub foo(:x($y), :z($y)) { $y }; foo

[14:31] <p6eval> std 52f3895: OUTPUT¬´Potential difficulties:‚ê§  Useless redeclaration of variable $y (see line 1) at /tmp/rCfDT1Tjnh line 1:‚ê§------> [32msub foo(:x($y), :z([33m‚èè[31m$y)) { $y }; foo[0m‚ê§ok 00:01 111m‚ê§¬ª

[14:31] <benabik> flussence: Is --parrot in there by default.  I've added it to my .ackrc

[14:31] <benabik> s/\./?/

[14:31] <masak> nom: sub foo(:x($y), :z($y)) { $y }; say foo(:x(42), :z(5))

[14:32] <p6eval> nom 4130f6: OUTPUT¬´===SORRY!===‚ê§Redeclaration of symbol $y‚ê§at /tmp/XRIGCnS5ej:1‚ê§¬ª

[14:32] <flussence> ack --help gives me "This is version 1.96 of ack.", and I don't have any perl6 stuff in ackrc, so you should be good to go

[14:32] <benabik> huh, whadda know

[14:33] *** PacoAir joined
[14:33] <tadzik> doesn't Shell::Command have rmtree()?

[14:33] <tadzik> Maybe stubbed :

[14:34] <fsergot> tadzik: stubbed. :)

[14:34] <tadzik> well volunteered! :)

[14:34] <fsergot> I'd like to. :)

[14:35] <tadzik> go ahead then :)

[14:35] *** Tedd1 left
[14:35] <fsergot> I work on it :P

[14:35] <masak> fsergot++

[14:35] <fsergot> Theres some problems. Parrot hasn't built-in funtions which remove dirs. :(

[14:36] <moritz> well, it has.

[14:36] <moritz> the 'rm' method in the 'os' dynpmc

[14:36] <fsergot> Right, I found the 'rm' method.

[14:36] <moritz> it doesn't work recursively, but you can implement the recursion yourself

[14:37] <flussence> or `man 3 ftw`, if you want to cheat :)

[14:37] <fsergot> It removes dirs, but only empty.

[14:37] <cognominal> nom: [|] <a b c>

[14:37] <p6eval> nom 4130f6:  ( no output )

[14:37] <cognominal> nom: say [|] <a b c>

[14:37] <p6eval> nom 4130f6: OUTPUT¬´any(any(a, b), c)‚ê§¬ª

[14:37] <moritz> fsergot: yes, so you might need to empty it first

[14:38] <fsergot> moritz: I thought about it, but I was looking for another way, is there any?

[14:39] <moritz> fsergot: I don't think so. Most operating systems just offer unlink() and rmdir() functions in their APIs, so recursive deletion must be implemented somewhere in the user space

[14:39] <cognominal> nom: say ([|] <a b c>) eq 'a'

[14:39] <p6eval> nom 4130f6: OUTPUT¬´any(any(True, False), False)‚ê§¬ª

[14:39] *** Tedd1 joined
[14:39] <moritz> nom: say so ([|] <a b c>) eq 'a'

[14:39] <p6eval> nom 4130f6: OUTPUT¬´True‚ê§¬ª

[14:39] <cognominal> hum, I forget how do I collapse a superposition

[14:39] <cognominal> ha!!

[14:39] <moritz> just put it in boolean context

[14:41] <cognominal> also [|] <a b c> should probably be  any('a', 'b', 'c') , not that it makes any difference in the end.

[14:41] <fsergot> moritz++ , thank You. :)

[14:41] <masak> nom: say ([|] <a b c>) eq 'a'

[14:41] <p6eval> nom 4130f6: OUTPUT¬´any(any(True, False), False)‚ê§¬ª

[14:42] <masak> this looks wrongish to me.

[14:42] <benabik> nom: say ('a' | 'b' | 'c')

[14:42] <p6eval> nom 4130f6: OUTPUT¬´any(a, b, c)‚ê§¬ª

[14:42] <benabik> nom: say (('a' | 'b') | 'c')

[14:42] <p6eval> nom 4130f6: OUTPUT¬´any(any(a, b), c)‚ê§¬ª

[14:42] <masak> right.

[14:42] *** sisar left
[14:43] <fsergot> nom: say ('a' ^ 'z';

[14:43] <p6eval> nom 4130f6: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2‚ê§¬ª

[14:43] <fsergot> nom: say ('a' ^ 'z');

[14:43] <p6eval> nom 4130f6: OUTPUT¬´one(a, z)‚ê§¬ª

[14:44] <dalek> roast: 3128346 | masak++ | S06-macros/macros-d1.t:

[14:44] <dalek> roast: [S06-macros/macros-d1.t] now the tenth test works

[14:44] <dalek> roast: 

[14:44] <dalek> roast: I keep forgetting that macros receive ASTs of things, not the

[14:44] <dalek> roast: values of the things.

[14:44] <dalek> roast: review: https://github.com/perl6/roast/commit/312834685d

[14:45] <dalek> rakudo/macros2: 161f188 | masak++ | src/Perl6/Actions.pm:

[14:45] <dalek> rakudo/macros2: [Perl6::Actions] fixed remaining two macro call types

[14:45] <dalek> rakudo/macros2: 

[14:45] <dalek> rakudo/macros2: The recent stuff only worked for calling macros as terms.

[14:45] <dalek> rakudo/macros2: Now it works for identifiers, terms, and ops.

[14:45] <dalek> rakudo/macros2: review: https://github.com/rakudo/rakudo/commit/161f188b53

[14:50] <fsergot> What means 'new__PS'? 

[14:50] <fsergot> Or where can i learn more about pir and nqp? :)

[14:50] <moritz> it calls the 'new' PIR opcode

[14:50] <flussence> new = function name, P = pointer, S = string

[14:51] <moritz> returning a PMC, taking an String (S) as the only argument

[14:51] <moritz> that's what you use in rakudo to instantiate a parrot PMC

[14:51] <flussence> it's hungarian notation :)

[14:51] <moritz> it'd make me hungry, if I hadn't just eaten three cookies.

[14:51] <masak> of the silly kind.

[14:52] <masak> the hungarian notation, not the cookies.

[14:52] <fsergot> flussence++

[14:52] <fsergot> moritz++

[14:52] <moritz> not really

[14:52] <moritz> it's more part of the type system

[14:52] <moritz> hungarian notation of the silly kind is what the type system should do, but does not

[14:55] <masak> I was referring to http://www.joelonsoftware.com/articles/Wrong.html -- where a case is presented that "real" Hungarian Notation is actually not that well-known or well-used.

[14:56] <masak> tl;dr: it's about "kinds", not types.

[14:57] <moritz> yes. And my point was that __PS is not really Hungarian Notation at all

[14:57] <moritz> because the compiler doesn't ignore it

[14:57] <flussence> ooh, I didn't know that

[14:58] *** xinming left
[14:59] <benabik> The parrot opcodes need to know the register types they're handling.  Something which is not always obvious from the results of NQP expressions.

[15:00] <moritz> and there are also multi opcodes

[15:00] <moritz> add__III vs add__NNN vs. add__PPP

[15:00] <benabik> Right, which operate based on the type information, which is completely lacking in NQP.  So it has to be re-added when dealing with the raw opcodes.

[15:01] *** bluescreen10 joined
[15:02] <moritz> it's strangely consistent, in some ways :-)

[15:03] <masak> moritz: oh. good point. it can't be Hungarian notation if it's used by the compiler, rather than just part of the name.

[15:03] <masak> what it is is more like wonky syntax for a type system.

[15:04] *** xinming joined
[15:04] <moritz> aye

[15:04] <moritz> (though I don't find it all that wonky; it's a simply way to have it not conflict with any Perl 6 syntax)

[15:05] *** birdwindupbird left
[15:05] <moritz> masak: in macros-d1.t, why does macro donner return an Int, but macro blitzen an AST?

[15:06] <moritz> that looks... suspicious, in the very least

[15:07] *** jaldhar left
[15:08] * masak checks

[15:08] <masak> no, that's correct.

[15:09] <moritz> why?

[15:09] <masak> because $counter is an Int, whereas $param is an AST.

[15:09] <moritz> is the quasi { } around $param necessary at all?

[15:10] <masak> that's what I'm testing!

[15:10] <masak> and no, it wouldn't be a no-op to remove it.

[15:10] <moritz> why not?

[15:11] <moritz> does quasi { $param } return an AST, that, when evaluated, returns an AST?

[15:11] <masak> in this case, yes.

[15:12] <moritz> so    macro blitzen($param) { $param };  blitzen('onwards') would return 'onwards'?

[15:12] *** skids joined
[15:12] <masak> right.

[15:13] <moritz> does it work?

[15:13] <masak> all tests pass.

[15:13] <moritz> well, that's not in the tests, afaict

[15:13] <masak> $ ./perl6 -e 'macro foo($param) { $param }; say foo "OH HAI"'

[15:13] <masak> Segmentation fault

[15:13] <masak> :(

[15:13] <moritz> :(

[15:13] <fsergot> :(

[15:14] <masak> still some kinks to iron out...

[15:14] * masak runs gdb again

[15:15] <masak> this time the SEGV comes from within our new dynop.

[15:15] <benabik> Does `macro infix:<comet>($r, $l) { quasi { "comet!" } }` never evaluate $r and $l ?

[15:16] * moritz hopes so

[15:16] <masak> https://gist.github.com/1885496

[15:16] <benabik> neat

[15:16] <masak> benabik: it never evaluates $r and $l.

[15:16] <dalek> roast: 544c9af | moritz++ | S06-macros/macros-d1.t:

[15:16] <dalek> roast: macros should be able to return their parameter(s) directly

[15:16] <dalek> roast: review: https://github.com/perl6/roast/commit/544c9affd5

[15:16] <masak> benabik: that's the reason short-circuiting ops like || and && are sometimes described as "macroish" over here.

[15:17] <masak> moritz: thanks.

[15:17] <moritz> masak: you're welcome

[15:20] <masak> ah -- starting to see why that one SEGVs.

[15:20] <moritz> missing sanity check?

[15:21] <moritz> no outer set up yep, or something?

[15:22] <masak> the ASTs created by quasis do a few extra tricks right now. the ASTs created during the macro call -- don't.

[15:23] <masak> so the latter kind is probably totally unprepared for the treatment they get when being returned from the macro.

[15:23] <masak> or something like that.

[15:23] *** simcop2387 left
[15:24] <moritz> so maybe the magic should happen at macro application time, not at quasi construction time?

[15:25] *** simcop2387 joined
[15:25] <masak> well, macro application time is "too late" for the new magic that happens at quasi AST construction time.

[15:26] <[Coke]> # 02/22/2012 - niecza++ ; pugs (15.18%); rakudo (99.04%)

[15:26] <[Coke]> "niecza",     20283,     8,   751,  1549, 22591, 23465

[15:26] <[Coke]> "pugs"  ,      3079,     4,  1724,    16,  4823, 23256

[15:26] <[Coke]> "rakudo",     20090,    28,   604,  1869, 22591, 23475

[15:26] <masak> the new magic consists of wiring up a context for it to carry around. that context doesn't really exist anymore at macro application time, which is why we need to carry it with us in the first place.

[15:26] <masak> wow, Pugs at 15! [Coke]++

[15:27] <masak> because Rakudo and Niecza are so close, in a way the Pugs figure is the only interesting one :P

[15:27] <PerlJam> [Coke]: you always ++ the "winner"?

[15:27] <masak> seems fitting.

[15:27] <[Coke]> I'm sure some of the regex passes don't count. I'm looking for you to make them count. ;)

[15:27] <[Coke]> PerlJam: yes.

[15:27] <[Coke]> ;(as of a few minutes ago.)

[15:27] <PerlJam> nice

[15:28] * PerlJam just made a 6 character change to some Perl 5 code and got a 700% performance improvement  :)

[15:28] <PerlJam> (now if only I could figure out how to do that for Rakudo  ;)

[15:28] * au hopes these 6 chars were not "exit()" :)

[15:29] <masak> or "dump()"

[15:29] * moritz thought 'last if', but that's 7

[15:29] <PerlJam> nah, it was to add a field to an index on table creation so that now my queries run way faster

[15:30] <moritz> so not really perl :/

[15:30] <PerlJam> yeah, I guess that's true.    But Perl is my interface to the underlying database, so it's kinda perl

[15:31] <PerlJam> (or just suspend disbelief and pretend it's all perl and rejoice in it  :-)

[15:34] <masak> whee

[15:35] <masak> moritz: I think the proper fix is this: just like quasi ASTs have to be incarnated with the surrounding macro context, so param ASTs have to be incarnated with the surrounding mainline context.

[15:35] <masak> I hadn't thought of this until now, but it seems quite evident now.

[15:36] <moritz> well, the context has to be attached at some point anyway

[15:36] <masak> macro params are AST closures going inwards, and quasi ASTs are AST closures going outwards. both kinds need to be incarnated in a context.

[15:36] <masak> moritz: yeah. it's probably because the new code at apply-time does the "fix up context" that this now blows up. it didn't used to.

[15:37] * masak hates the phrase "it didn't used to", but that seems to be the way to say it in English

[15:37] <PerlJam> This is the only primarily english-speaking channel where at any given moment, I will not understand *at all* what people are talking about.

[15:37] <PerlJam> :)

[15:38] * JimmyZ hopes somebody could take a look at https://github.com/perl6/nqp/pull/29

[15:38] <moritz> JimmyZ: have you tested NativeCall.pm with these changes?

[15:39] <masak> PerlJam: I'm glad for once to be on that end of an inscrutable #perl6 conversation :)

[15:39] <JimmyZ> moritz: I have not 

[15:40] <moritz> JimmyZ: that would make patch application a bit faster

[15:40] <JimmyZ> moritz: will try it  later

[15:44] *** am0c joined
[15:47] *** Trashlord joined
[15:47] *** Patterner left
[15:48] *** Psyche^ joined
[15:48] *** Psyche^ is now known as Patterner

[15:49] <masak> PerlJam: if you're interested, I think you might find https://gist.github.com/1853560 elucidating.

[15:50] * PerlJam looks

[15:59] * PerlJam re-reads the last bit about macros 

[16:00] <cognominal> masak, eiro is thinking of a two days Perl 6 class at fpw. He would prefer to show working code than presnetation ex-cathedra.

[16:00] <cognominal> what do you think of it?

[16:01] <masak> I'm thinking it sounds interesting.

[16:02] <cognominal> I told him that we should make it a numerus clausus and ask people to come with a compiled rakudo. That would save time.

[16:02] <cognominal> we could help the weeks before on that channel to get it compiled.

[16:03] <moritz> aye

[16:03] <colomon> pmurias: https://gist.github.com/1884535 is now the latest output ... note that test 11 worked!

[16:03] <moritz> mystery quiz: what do infix -, *, ==, <=, <, > and >= have in common in rakudo? (as opposed to +, %, **, div, mod, gcd, lcm, !=, !==, <=>, le, lt, gt, ge, leg)

[16:04] <masak> moritz: they can't be redefined?

[16:04] <masak> or they can be redefined? :)

[16:04] <colomon> masak: nope

[16:04] <moritz> masak: correct. But why?

[16:04] <colomon> wait, what?

[16:05] <colomon> since when?

[16:05] <pmurias> colomon: so we need a 32bit perl?

[16:05] <moritz> colomon: dunno.

[16:05] <moritz> colomon: I'd like to know.

[16:05] <PerlJam> colomon: for a while now I think.  We were talking about this last week or the week before

[16:05] <moritz> I can think of two hypotheses to test: return annotations, presence of natively typed ops

[16:05] <colomon> moritz: you certainly could redefine them in alpha and ng

[16:06] <moritz> apart from that, I have not the slightlest idea

[16:06] <JimmyZ> how can I run zavolaj/t ?

[16:06] <colomon> .... what, what exactly is meant by redefine?

[16:06] <moritz> colomon: add a multi in an inner scope, and have it called

[16:06] <colomon> moritz: okay, we're on the same page there, then

[16:07] <JimmyZ> never mind

[16:07] * colomon thinks we need a better word than "redefine" for that, but he doesn't have one handy

[16:07] <colomon> pmurias: maybe?

[16:07] *** tokuhirom joined
[16:07] <colomon> pmurias: I don't understand what the tests are testing in any detail.

[16:10] <masak> moritz: I have no idea either. I don't see any pattern whatsoever.

[16:12] <JimmyZ> moritz: all tests pass in zavolaj

[16:12] <moritz> JimmyZ: that's great. Thank you.

[16:13] <JimmyZ> moritz: np

[16:14] <colomon> masak, moritz: surely there's just been some mistake?  it just doesn't make any sense to be able to redefine + but not - (or vice versa, not sure what the state of things is).

[16:15] <moritz> colomon: yes, and I'm trying to track down that mistake. No luck so far.

[16:16] <moritz> I'v added a debug say() to the routine_def action method. The name of the operator is correctly constructed in both cases

[16:16] <colomon> moritz: you mean you're trying to track down what is causing the problem, or why the code got to be that way in the first place?

[16:16] <moritz> colomon: tracking down the problem

[16:16] <TimToady> the difference might be a proto sig of |$ vs $a?, $b?

[16:16] <moritz> I've triggered dispatch failures. The candidate isn't in the candidate list that's shown in the error message

[16:17] <moritz> TimToady: good idea

[16:18] <moritz> ...but it doesn't fit the pattern of the failures

[16:18] *** leprevost left
[16:18] <moritz> both infix + and - have a ($a?, $b?) proto, but + is fine and - is not

[16:19] <TimToady> could it be implicitly generating some conflicting proto by earlier use?

[16:20] <TimToady> it does feel very much like a proto issue to me

[16:20] <moritz> TimToady: unlikely. My demonstration program uses neither + nor - before, and the setting uses both

[16:20] <TimToady> I meant used earlier in the setting

[16:20] <moritz> ah

[16:20] <moritz> used before proto declared

[16:20] <dalek> rakudo/match-refactor: dd27465 | moritz++ | src/core/Int.pm:

[16:20] <dalek> rakudo/match-refactor: fix signature of an infix:<!=> candidate. No idea if it makes any difference

[16:20] <dalek> rakudo/match-refactor: review: https://github.com/rakudo/rakudo/commit/dd27465036

[16:20] <moritz> I could check that

[16:21] <masak> moritz++ # investigating this

[16:21] <TimToady> does the proto declarator check that there's not one generated already?

[16:21] <moritz> yes

[16:21] <moritz> though that test could be buggy in subtle ways in the setting, maybe

[16:21] <TimToady> and does it carp or go silent?

[16:22] <moritz> the proto generator is silent

[16:22] <TimToady> sure, but what about the other way?

[16:23] <tadzik> "Lists are only one-dimensional.  Sigh." -- "Whaddya want, APL?"

[16:23] <tadzik> :)

[16:23] * tadzik discovered http://groups.google.com/group/comp.sources.d/browse_thread/thread/40fb76f3cc9ad102/e605e989bcb15f22

[16:23] <moritz> TimToady: which other way?

[16:23] * moritz confused

[16:24] <colomon> moritz: he means explicit proto declaration if there's already been one generated

[16:24] <moritz> ah

[16:24] <TimToady> if some semantics are autogenerated, then an explicit proto is seen, do we check for conflict

[16:24] <TimToady> moving a proto up to the front might be a test

[16:24] <moritz> nom: multi a() { }; proto a() { }

[16:24] <p6eval> nom 4130f6: OUTPUT¬´===SORRY!===‚ê§Redeclaration of routine a‚ê§at /tmp/32ts4axtXD:1‚ê§¬ª

[16:25] <JimmyZ> nom: proto a() { }; multi a() { }; 

[16:25] <p6eval> nom 4130f6:  ( no output )

[16:25] <TimToady> nom: a(); proto a() { * }; multi a() { }

[16:25] <p6eval> nom 4130f6:  ( no output )

[16:25] <TimToady> might the a() call generate a proto?

[16:30] <cognominal> in rakudo, how is it possible to get a stack trace on a warn?

[16:30] *** leprevost joined
[16:30] <moritz> both infix:<+> and infix:<-> are called before the proto occurs

[16:31] <moritz> nom: CONTROL { default { say $!.message; say ~$!.backtrace } }; 1 + Any

[16:31] <p6eval> nom 4130f6: OUTPUT¬´Method 'message' not found for invocant of class 'Any'‚ê§  in block <anon> at /tmp/3HshnwmyJp:1‚ê§‚ê§¬ª

[16:31] <moritz> nom: CONTROL { default { say .message; say ~.backtrace } }; 1 + Any

[16:31] <p6eval> nom 4130f6: OUTPUT¬´use of uninitialized value of type Any in numeric context‚ê§  in method Numeric at src/gen/CORE.setting:662‚ê§  in sub infix:<+> at src/gen/CORE.setting:2249‚ê§  in block <anon> at /tmp/ixJzDWES8Y:1‚ê§‚ê§¬ª

[16:31] <moritz> cognominal: like this

[16:32] <TimToady> though won't that also catch returns and such?

[16:32] <TimToady> I think you need a better 'when'

[16:32] <moritz> yes, but if you do it at the mainline, you won't have that many returns to catch :-)

[16:33] <TimToady> hmm, is exit a control exception?

[16:33] <moritz> nom: CONTROL { default { } }; exit; say 'alive'

[16:33] <p6eval> nom 4130f6:  ( no output )

[16:33] <moritz> nom: CONTROL { default {say "caught" } }; exit; say 'alive'

[16:33] <p6eval> nom 4130f6: OUTPUT¬´caught‚ê§¬ª

[16:33] <moritz> heh

[16:34] <moritz> oh wait. normal behavior

[16:34] <cognominal> expect, I need that in a program. At the shell, don't need that much to know what line is the problem

[16:34] <moritz> it doesn't resume

[16:34] <cognominal> *except that

[16:34] <moritz> cognominal: well, you can add that CONTROL phaser to your program.

[16:34] <TimToady> nom: CONTROL { default {say "caught" } }; exit; END { say "goody" }

[16:34] <p6eval> nom 4130f6: OUTPUT¬´caught‚ê§goody‚ê§¬ª

[16:35] <moritz> nom: CONTROL { default {say "caught" } }; { exit }; say 'alive'

[16:35] <p6eval> nom 4130f6: OUTPUT¬´caught‚ê§¬ª

[16:35] <moritz> nom: { CONTROL { default {say "caught" } }; exit }; say 'alive'

[16:35] <p6eval> nom 4130f6: OUTPUT¬´caught‚ê§alive‚ê§¬ª

[16:35] <moritz> that's what I wanted to demonstrate, actually :-)

[16:36] <cognominal> like says TimToady, I don't want to print backtrace for anything but warnings.

[16:36] <moritz> then you need to wait (or contribute) until we have a better mechanism for distinguishing warnings and non-warnings

[16:37] * moritz decommutes

[16:38] <cognominal> in the mean time I recompile rakudo to die instead to warn.

[16:39] *** leprevost left
[16:39] * TimToady wonders how a pragma like 'use warnings :fatal' will install and/or tweak the CONTROL phaser...

[16:43] <PerlJam> How does one get a  list of signatures for a multi?

[16:43] *** thou joined
[16:44] <TimToady> phenny: tell moritz Any(Str) doesn't make sense; you want Str(Any) to coerce to string

[16:44] <phenny> TimToady: I'll pass that on when moritz is around.

[16:51] *** leprevost joined
[16:52] *** wtw left
[16:55] *** noam_ joined
[16:56] <flussence> perl6: multi a() { }; multi a(Int $) { }; say &a.candidates

[16:56] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "Int"‚ê§    expecting "|", ":", "*", parameter name or ")"‚ê§    at /tmp/pZNZIcFB1v line 1, column 24‚ê§¬ª

[16:56] <p6eval> ..rakudo 4130f6, niecza v14-57-gd05a5fe: OUTPUT¬´sub a() { ... } sub a(Int ) { ... }‚ê§¬ª

[16:56] * TimToady is kinda amazed that rakudo++ and niecza++ came up with identical answers

[16:57] <TimToady> though I'm not sure I like the space after the Int

[16:57] <flussence> perl6: multi a() { }; multi a(Int $named) { }; say &a.candidates

[16:57] <p6eval> rakudo 4130f6: OUTPUT¬´sub a() { ... } sub a(Int $named) { ... }‚ê§¬ª

[16:57] <p6eval> ..pugs b927740: OUTPUT¬´*** No such method in class Sub: "&candidates"‚ê§    at /tmp/nR4mQ_qGqc line 1, column 45 - line 2, column 1‚ê§¬ª

[16:57] <p6eval> ..niecza v14-57-gd05a5fe: OUTPUT¬´Potential difficulties:‚ê§  $named is declared but not used at /tmp/8w88N8mgx8 line 1:‚ê§------> [32mmulti a() { }; multi a(Int [33m‚èè[31m$named) { }; say &a.candidates[0m‚ê§‚ê§sub a() { ... } sub a(Int $named) { ... }‚ê§¬ª

[16:57] <flussence> perl6: multi a() { }; multi a(Int $named) { }; say &a.candidates # OK not used

[16:57] <p6eval> rakudo 4130f6: OUTPUT¬´sub a() { ... } sub a(Int $named) { ... }‚ê§¬ª

[16:57] <p6eval> ..pugs b927740: OUTPUT¬´*** No such method in class Sub: "&candidates"‚ê§    at /tmp/wXeMNS9MJd line 1, column 45 - line 2, column 1‚ê§¬ª

[16:57] <p6eval> ..niecza v14-57-gd05a5fe: OUTPUT¬´Potential difficulties:‚ê§  $named is declared but not used at /tmp/KK21IJ7mdN line 1:‚ê§------> [32mmulti a() { }; multi a(Int [33m‚èè[31m$named) { }; say &a.candidates # OK not [0m‚ê§‚ê§sub a() { ... } sub a(Int $named) { ... }‚ê§¬ª

[16:57] <flussence> that trick doesn't work?

[16:57] <TimToady> #OK

[16:58] <TimToady> no space

[16:58] <flussence> whoops

[16:58] <flussence> perl6: multi a() { }; multi a(Int $named) { }; say &a.candidates #OK

[16:58] <p6eval> rakudo 4130f6, niecza v14-57-gd05a5fe: OUTPUT¬´sub a() { ... } sub a(Int $named) { ... }‚ê§¬ª

[16:58] <p6eval> ..pugs b927740: OUTPUT¬´*** No such method in class Sub: "&candidates"‚ê§    at /tmp/qJUJ3N0Zit line 1, column 45 - line 2, column 1‚ê§¬ª

[16:58] *** noam left
[16:58] <flussence> there we go

[16:58] <flussence> (I'm surprised it worked too; last time I tried anything moppy in niecza was when it was still NYI)

[16:58] *** simcop2387 left
[16:59] <TimToady> I just don't think it should put the space unless it is going to put a variable

[17:00] *** simcop2387 joined
[17:00] * TimToady practices his micromanagement skills

[17:01] *** simcop2387 left
[17:01] <masak> +1

[17:02] * masak decommutes

[17:04] *** alim_ left
[17:04] *** simcop238 joined
[17:04] *** kaare_ joined
[17:06] *** simcop238 left
[17:08] <flussence> after some random wandering around, I've decided to blame src/core/Parameter.pm:139 for the trailing space

[17:08] *** MayDaniel joined
[17:09] <flussence> it should be moved about 3 lines down, I think

[17:09] *** simcop2387 joined
[17:13] *** simcop2387 left
[17:14] <benabik> Shouldn't it output (Int $) ?

[17:14] *** simcop2387 joined
[17:15] <flussence> yeah

[17:15] <TimToady> only if there was a $ originally, I'd think

[17:16] <benabik> std: sub a(Int, $x)

[17:16] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed block at /tmp/mSUrljWGvy line 1 (EOF):‚ê§------> [32msub a(Int, $x)[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:01 110m‚ê§¬ª

[17:16] <flussence> is (Int) the same as (Int $) there?

[17:16] <benabik> std: sub a(Int, $x) { ... }

[17:16] <p6eval> std 52f3895: OUTPUT¬´Potential difficulties:‚ê§  $x is declared but not used at /tmp/m9Oommq85q line 1:‚ê§------> [32msub a(Int, [33m‚èè[31m$x) { ... }[0m‚ê§ok 00:01 111m‚ê§¬ª

[17:16] <benabik> Bah, std is smarter than I expect sometimes.

[17:17] *** simcop2387 left
[17:17] *** Gazzonyx|AFK is now known as Gazzonyx

[17:18] <flussence> > multi a() { }; multi a(Int $) { }; say &a.candidates

[17:18] <flussence> sub a() { ... } sub a(Int) { ... }

[17:18] <TimToady> the $ is kind of an extra assertion that the parameter can be bound to a container with anti-flattening characteristics; not sure whether this is meaningful, or might be someday

[17:18] <flussence> one down, now I just need to make that say "multi"

[17:18] *** simcop2387 joined
[17:18] <flussence> oh wait, I think sub is currect there

[17:18] <flussence> I'm confused.

[17:19] <TimToady> if the original has a sigil, it needs to show up, especially if it's not $

[17:19] <flussence> .oO( what the heck does "currect" mean anyway? )

[17:19] *** Gazzonyx left
[17:20] *** NamelessTee joined
[17:30] * PerlJam is confused

[17:31] <moritz> it's #phasers time

[17:31] <phenny> moritz: 16:44Z <TimToady> tell moritz Any(Str) doesn't make sense; you want Str(Any) to coerce to string

[17:31] <flussence> tl;dr: you can get a list of multi signatures, but it's buggy :)

[17:31] <moritz> TimToady: ah right

[17:31] <PerlJam> I just tried to build a fresh rakudo and it complains about "NEED_CONTINUATION"

[17:31] <flussence> --gen-parrot?

[17:31] <moritz> PerlJam: you need to use the parrot release version

[17:31] <PerlJam> I've a fresh parrot already

[17:31] <PerlJam> ah

[17:31] <PerlJam> it's too fresh

[17:32] <moritz> PerlJam: or merge rakudo's cont_reuse branch

[17:32] <moritz> (locally, that is)

[17:32] <benabik> And this is why I wanted to delay that merge until post Rakudo release.

[17:32] <PerlJam> that's right ... I remember now.

[17:32] * benabik doesn't like it when master/master doesn't work.  It's confusing.

[17:32] *** kaleem joined
[17:33] <PerlJam> benabik: it's not master/master, it's master/nom  ;)

[17:33] *** daxim left
[17:33] <PerlJam> benabik: but, you are correct sir!

[17:33] <benabik> PerlJam: See!  Confusing!  ;-)

[17:33] <flussence> #perl6: where everyone's confused

[17:33] <PerlJam> confusion is the natural human condition.

[17:35] *** pmurias left
[17:36] *** Jerkwad joined
[17:36] * TimToady is usually confused about being confused

[17:37] <PerlJam> If you're not confused, that's what you should really start to worry

[17:37] *** simcop2387 left
[17:37] *** simcop2387 joined
[17:38] *** simcop2387 left
[17:40] *** noam__ joined
[17:40] *** simcop2387 joined
[17:40] *** simcop2387 left
[17:40] *** simcop2387 joined
[17:41] <gfldex> could a kind soul test this on *x? https://gist.github.com/1886254

[17:43] *** simcop2387 left
[17:44] *** noam_ left
[17:44] *** JimmyZ left
[17:44] *** simcop2387 joined
[17:45] *** carlin joined
[17:56] *** Chillance joined
[17:58] *** kaleem left
[17:59] *** mj41 left
[18:01] *** ksi joined
[18:02] *** tokuhirom left
[18:04] *** perimoso1ordiae is now known as perimosocordiae

[18:06] *** am0c left
[18:09] *** dakkar left
[18:11] *** carlin is now known as glass

[18:11] *** pernatiy left
[18:13] *** tarch left
[18:15] *** noam joined
[18:18] *** noam__ left
[18:37] *** MayDaniel left
[18:44] *** MayDaniel joined
[18:48] *** MayDaniel left
[19:28] *** birdwindupbird joined
[19:30] *** fridim_ joined
[19:33] <[Coke]> is today phasers?

[19:33] <PerlJam> it was

[19:33] <PerlJam> activity was next to nil though

[19:35] <colomon> crap, forgot it again

[19:37] *** fridim_ left
[19:37] *** mj41 joined
[19:38] *** GlitchMr joined
[19:40] *** noam left
[19:41] *** noam joined
[19:50] <[Coke]> whoops.

[19:50] * masak forgot #phasers too

[19:51] <PerlJam> #phasers might need a re-think on its timing.

[19:54] <[Coke]> tehre's some webs ite where you can suggest a range of times and then let individuals sign up for the ones that work.

[19:54] <tadzik> doodle.com

[19:55] *** fridim_ joined
[19:55] <PerlJam> (I think I may have even volunteered to setup a doodle, but forgot about it)

[19:55] * [Coke] pings au.

[19:58] *** bluescreen10 left
[20:07] <jnthn> evenin'

[20:07] <felher> o/

[20:09] * [Coke] unpings au

[20:10] <[Coke]> jnthn: *pounce*

[20:10] <jnthn> uh-oh :)

[20:10] <jnthn> hi [Coke] 

[20:12] *** bluescreen10 joined
[20:14] <[Coke]> nah, I got nothin. Just that niecza is ahead of rakudo and pugs is catching up.

[20:15] <masak> :)

[20:15] *** NamelessTee left
[20:16] <[Coke]> masak: so, is it worth at this point opening issues for pugs.

[20:16] <[Coke]> ?

[20:16] <au> wow, I never thought there's still so much gravitational potential in pugs :) [Coke]++

[20:16] <masak> [Coke]: sure!

[20:17] <[Coke]> Ok. if I find anything obvious that will be a big win, I'll open a ticket for it.

[20:17] <[Coke]> au, I was going to ping youthe same question. ;)

[20:18] *** thou left
[20:19] <au> whatever you do, you have all my preemptive blessing and/or forgiveness as appropriate :)

[20:19] <[Coke]> au++ # the fact that we can still /run/ pugs after all these years helps.

[20:19] <TimToady> pugs was a supernova that produced many of the heavy elements we are now made of :)

[20:19] <[Coke]> I'm just trying to avoid learning haskell.

[20:19] <PerlJam> [Coke]: bu, but ... you should learn a new programming lanugage each year :)

[20:20] <jnthn> [Coke]: Well, need to get the serialization stuff in before I worry too much about hacking on moar features. :) Will be able to do various things thanks to it, though :)

[20:22] <[Coke]> PerlJam: java's on my list for this year.

[20:22] <[Coke]> (again)

[20:23] <PerlJam> .oO( why ?!? )

[20:24] <[Coke]> PerlJam: because I get a paycheck?

[20:24] *** y3llow_ joined
[20:25] *** pothos_ joined
[20:25] <PerlJam> well ... at least that's a good (enough) reason  :)

[20:26] *** pothos left
[20:26] *** y3llow left
[20:27] <[Coke]> I was just asked if we should do something in perl, so that's good.

[20:27] <[Coke]> (sadly, I had to say no.)

[20:27] *** y3llow_ left
[20:28] *** pothos_ left
[20:28] *** y3llow joined
[20:28] *** pothos joined
[20:30] *** y3llow left
[20:30] *** y3llow joined
[20:31] *** tarch joined
[20:31] *** pothos left
[20:31] *** pothos joined
[20:33] *** localhost left
[20:35] *** localhost joined
[20:35] <masak> Java isn't so bad. it's a fine language. it has its drawbacks, to be sure. but most languages do.

[20:36] <PerlJam> Java is too wordy.  reminds me of cobol sometimes 

[20:37] <jnthn> .oO( lowercase cobol, with objects... )

[20:38] * au kinda likes Xtend (CoffeeScript for Java) t[Dhese days...

[20:39] <au> *these

[20:40] <benabik> I like Scala, but that's less "Java without noise" as "a functional language on the JVM"

[20:41] <masak> I like Java, even though I agree it's wordy.

[20:41] <masak> I've been productive and created nice things in Java.

[20:42] <masak> writing "lean" code in Java is possible, though trickier than in Perl, say.

[20:43] <LoRe> quickfix!

[20:47] <dalek> specs: 524d26c | moritz++ | S09-data.pod:

[20:47] <dalek> specs: [S09] fix coercion syntax usage, TimToady++

[20:47] <dalek> specs: review: https://github.com/perl6/specs/commit/524d26c448

[20:48] <moritz> nqp: my $x := 3; say(:$x)

[20:48] <p6eval> nqp: OUTPUT¬´Confused at line 1, near "say(:$x)"‚ê§current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)‚ê§¬ª

[20:49] *** birdwindupbird left
[20:50] *** mj41 left
[20:50] <jnthn> moritz: NQP don't have that sugar.

[20:50] <jnthn> Though I sometimes wish it did...

[20:50] <moritz> jnthn: I'm thikning about adding it

[20:51] <jnthn> moritz: No objections.

[20:52] <jnthn> It's only a little syntax sugar, and zero porting cost.

[20:52] <moritz> std: :$/

[20:52] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Bogus statement at /tmp/9hQjSNyeec line 1:‚ê§------> [32m<BOL>[33m‚èè[31m:$/[0m‚ê§Parse failed‚ê§FAILED 00:01 109m‚ê§¬ª

[20:53] <moritz> std: :$_

[20:53] <p6eval> std 52f3895: OUTPUT¬´ok 00:01 107m‚ê§¬ª

[20:53] <moritz> std: :$!

[20:53] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Bogus statement at /tmp/20btJKjk7o line 1:‚ê§------> [32m<BOL>[33m‚èè[31m:$![0m‚ê§Parse failed‚ê§FAILED 00:01 109m‚ê§¬ª

[20:54] <jnthn> std: sub foo(:$!) { }

[20:54] <p6eval> std 52f3895: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[20:54] <jnthn> nom: sub foo(:$!) { }

[20:54] <p6eval> nom 4130f6:  ( no output )

[20:54] <jnthn> nom: sub foo(:$!) { say $! }; foo(|{ '!' => 'lol'})

[20:54] <p6eval> nom 4130f6: OUTPUT¬´lol‚ê§¬ª

[20:55] <moritz> I think it wouldn't hurt to allow :$/ and :$! in NQP

[20:55] <jnthn> moritz: Only if we allow :$! and :$/ in the parameter lists too... :)

[20:55] <jnthn> wait, why'd be want to do this? :)

[20:56] <moritz> why not? :-)

[20:56] <jnthn> moritz: Is it more work to disallow it? :)

[20:57] <moritz> jnthn: seems so

[20:57] <jnthn> ah, jfdi then :)

[20:57] <jnthn> I dobut anybody will actually use :$!

[20:59] *** pochi joined
[21:10] *** snearch left
[21:12] *** GlitchMr left
[21:21] *** zby_home_ joined
[21:27] *** bluescreen10 left
[21:28] <dalek> nqp: 7b8137f | moritz++ | / (3 files):

[21:28] <dalek> nqp: implement :$var colonpair syntax

[21:28] <dalek> nqp: 

[21:28] <dalek> nqp: Also adds a single test.

[21:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7b8137fb91

[21:39] *** pmurias joined
[21:41] <pmurias> colomon: re what the tests are testing it turns out we can link a 64bit shared library with a 64bit executable

[21:41] <pmurias> colomon: but we can't with 32bits

[21:41] <pmurias> colomon: and mono only loads 32bit shared libraries

[21:42] <colomon> so... anyone who wants to do it is going to have to build a 32bit shared library of perl?

[21:45] <pmurias> or a 64bit mono

[21:45] <pmurias> colomon: on mac os x

[21:46] <pmurias> colomon: http://www.perlmonks.org/?node_id=910271 has the command line

[21:47] *** pernatiy joined
[21:47] <colomon> pmurias: that's the perlbrew line?

[21:47] <pmurias> colomon: yes

[21:48] <colomon> okay, I'll take a look at doing that ASAP

[21:52] * colomon is installing perlbrew...

[21:53] <PerlJam> perl6brew?

[21:53] <colomon> PerlJam: I don't think you've written perl6brew yet...

[21:53] <pmurias> colomon: i never had a mac, so i can only guess how to fix things them and search on google ;)

[21:54] <colomon> pmurias: :)

[21:54] <pmurias> colomon: you can use --notest to install a perl much faster

[21:55] <pmurias> why do perl programmers use macs?

[21:55] <tadzik> I think programmers in general use macs, because they work well for them

[21:56] <benabik> The system perl on OS X is universal.

[21:56] <benabik> (i.e. should be able to be linked to 32 and 64 bit programs)

[21:56] <pmurias> tadzik: you have a mac?

[21:57] <colomon> benabik: it's entirely possible my default perl is from Macports rather than the system perl

[21:58] <colomon> right, the system perl is 5.10, my perl is 5.12.3

[21:58] <benabik> colomon: That would do it.  Depressingly few packaging programs bother with making the things they install universal.  Which is a shame because it seems much better than the /lib /lib64 split.

[21:58] <tadzik> pmurias: nah

[21:58] <tadzik> but I've seen plenty enough people doing good job on macs to be suprised :)

[21:59] <PerlJam> if I weren't using linux, I'd use a mac.  Macs are most unix-like but with a nice UI

[22:00] <benabik> If I weren't on a laptop, I'd use Linux.  Hardware support for laptops has always burned me.

[22:00] *** skids left
[22:01] <colomon> pmurias: on using the mac: It's easily the nicest windowing UI I've ever used, and it's got a *nix shell as powerful as any Linux.  There are a few rough edges, sure, but it's still an order of magnitude nicer than any other system I've used.

[22:04] <colomon> pmurias: for instance, Macports leaves something to be desired, for sure, but I've never had better luck with any of the Linux equivalents.

[22:06] *** kaare_ left
[22:06] <colomon> huh, installed perlbrew but don't seem to have its perl5 directory.

[22:09] *** dorlamm joined
[22:09] <colomon> probqably need init

[22:10] *** alim joined
[22:16] *** kaare_ joined
[22:18] * [Coke] wishes someone would track down the idiot spamming messages from 2007 and make him stop.

[22:18] <[Coke]> Received: from mda.wombatsecurity.local (c-24-131-84-205.hsd1.pa.comcast.net. [24.131.84.205]) by mx.google.com with ESMTP id n5si7810013qct.205.2012.02.21.16.10.59; Tue, 21 Feb 2012 16:11:00 -0800 (PST)

[22:19] <fsergot> Could somebody take a look: https://gist.github.com/1887806

[22:19] <fsergot> ?

[22:19] <fsergot> :)

[22:19] <fsergot> tadzik: What do You think about this?

[22:20] <masak> interesting.

[22:20] <masak> you are aware that that's 'rm -r', not 'rmdir', right? :)

[22:20] <[Coke]> (and it's not just parrot/perl6, it looks like this idiot is devouring lots of groups emails incorrectly)

[22:20] <tadzik> cute

[22:21] <tadzik> fsergot: does it work? I don't remember if File::Find really is depth-first :)

[22:21] * [Coke] points at https://groups.google.com/forum/#!topic/sf2g/o5jSIvppTr4 - same address, even.

[22:22] <fsergot> masak: what do You mean? :)

[22:22] <fsergot> tadzik: works for me.

[22:22] *** ksi left
[22:22] <tadzik> fsergot: for bonus points: find(), as dir(), is lazy. Assigning it to an array loses all advantage laziness gives us

[22:22] <tadzik> (I think)

[22:22] <tadzik> you could probably do this with just one for {}

[22:23] *** kaare_ left
[22:23] <fsergot> tadzik: Can You show me how? I was trying a lot of ways. :)

[22:25] <tadzik> fsergot: I think just for find().foo.foo.foo { unlink $_ }; unlink $path

[22:25] <fsergot> masak: Yes, I'm aware. :)

[22:28] <fsergot> tadzik: hmm, I must think it over.

[22:31] *** dorlamm left
[22:31] <tadzik> sure

[22:31] <fsergot> tadzik: find() return a list, right?

[22:31] <fsergot> returns*

[22:32] <fsergot> nom: use File::Find;

[22:32] <p6eval> nom 4130f6: OUTPUT¬´===SORRY!===‚ê§Could not find File::Find in any of: lib, /home/p6eval/.perl6/lib, /home/p6eval/nom-inst2/lib/parrot/4.0.0-devel/languages/perl6/lib, .‚ê§¬ª

[22:32] <benabik> star: use File::Find

[22:32] <p6eval> star 2012.01:  ( no output )

[22:32] <fsergot> benabik++ thanks

[22:32] <tadzik> fsergot: yes, a lazy one

[22:33] <benabik> tadzik: I think the .reverse will cause it to be eager.

[22:33] <pmurias> colomon: any luck with the new perl?

[22:33] <benabik> Lazily reversing a list is quite difficult.  :-D

[22:34] <colomon> pmurias: it just finished building a second ago

[22:34] <tadzik> benabik: oh, true

[22:34] <fsergot> So, what to do? :)

[22:35] <tadzik> submit a pull request for Shell::Command :)

[22:35] <tadzik> don't forget tests 

[22:35] <colomon> pmurias: oooo, your p5test passes with flying colors

[22:35] <masak> remember that you have to fail the rmdir as soon as an unlink fails.

[22:35] <masak> which it might do for a host of reasons.

[22:36] <fsergot> masak: of course, this was only a "beta" version :)

[22:38] <colomon> pmurias: how do I test if p5 interop now works?

[22:40] * TimToady thinks about hyperops applied to directory structures, and the fact that our manycores are still talking to a single disk drive normally

[22:41] <masak> fsergot: yes, of course. just giving you feedback and forward directions ;)

[22:41] <masak> 'night, #perl6

[22:41] <fsergot> masak: thanks, I really appreciate this. :)

[22:41] <fsergot> masak++ 

[22:41] <fsergot> good night masak! :)

[22:42] <tadzik> g'night masak 

[22:46] <pmurias> colomon: make and make perl5

[22:46] <pmurias> perl t/run_spectests_p5

[22:48] <fsergot> tadzik: Could this be? : https://gist.github.com/1888091

[22:52] <tadzik> fsergot: I think so, yes

[22:53] <fsergot> So, now it's time for rmdir and then I'll submit a pul request.

[22:53] <fsergot> :)

[22:53] <fsergot> tadzik++

[22:55] <fsergot> pull*

[22:56] *** benabik left
[23:03] <fsergot> tadzik: Could rmdir use an external module if it'll be in src/core/IO.pm? 

[23:04] <pmurias> colomon: or mono run/Niecza.exe examples/term-ansicolor.pl

[23:04] *** lestrrat left
[23:05] <pmurias> sleep&

[23:05] *** pmurias left
[23:05] *** lestrrat joined
[23:09] *** PacoAir left
[23:11] <fsergot> nn pmurias

[23:12] <tadzik> fsergot: I don't think so

[23:13] <tadzik> fsergot: I think it belongs in Shell::Command as rmtree

[23:13] <fsergot> tadzik: Theres no rmtree in yours Shell::Command 

[23:16] <fsergot> tadzik: It's late, I'll come back to this tomorrow. :)

[23:17] <colomon> phenny: tell pmurias "Can't locate Package/Stash.pm"

[23:17] <phenny> colomon: I'll pass that on when pmurias is around.

[23:24] <colomon> phenny: tell pmurias Oh, just had to install Package::Stash for my new perlbrew p5.

[23:24] <phenny> colomon: I'll pass that on when pmurias is around.

[23:33] *** skids joined
[23:40] *** tarch left
[23:42] *** mtk left
[23:48] *** literal_ joined
[23:48] *** au__ joined
[23:48] *** ascent__ joined
[23:49] *** BooK__ joined
[23:50] <sorear> good * #perl6

[23:51] *** jevin joined
[23:52] *** doy_ joined
[23:52] *** itz_ joined
[23:53] *** pjcj_ joined
[23:54] *** kthakore_ joined
[23:54] *** alim left
[23:54] *** doy left
[23:54] *** itz left
[23:55] *** Chillance left
[23:55] *** alim joined
[23:55] *** tokuhirom joined
[23:55] *** lestrrat left
[23:56] *** lestrrat joined
[23:56] *** lestrrat left
