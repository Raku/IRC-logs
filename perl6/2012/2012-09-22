[00:05] *** fgomez joined
[00:09] <colomon> timotimo: gist the code?

[00:24] *** snearch left
[00:33] *** Guest29702 left
[00:59] *** mucker joined
[01:00] <timotimo> i'm a bit ashamed of it :|

[01:00] <timotimo> and the linear algebra portion is hardly self-explanatory :)

[01:01] <colomon> are you making any progress debugging it?  3D lines intersection?

[01:15] <TimToady> sigh, is-prime seems to work correctly up to base 11, but uses up 15GB trying to do base 12, which is only about 800th the size of the base 18 case, which will obviously be hopeless

[01:15] <TimToady> (in rakudo here)

[01:17] <TimToady> 17000 big integers should not take 15GB of memory...

[01:21] <TimToady> is-prime is not what is chewing up the memory, just to be clear about; moritz++

[01:21] <TimToady> *about that

[01:28] *** whiteknight left
[01:29] <colomon> depends on how big, no?

[01:31] <TimToady> is there a way to force a GC run from within rakudo?

[01:32] <TimToady> the following appears to grow continually:

[01:32] <TimToady> r: my @current; loop { my @next = (1..100000).roll(10000); @current := @next; 0; }

[01:33] <TimToady> should timeout...

[01:33] <p6eval> rakudo 2e3365: OUTPUT«(timeout)»

[01:33] <au> drop to PIR level and run "sweep 1"?

[01:35] <TimToady> it doesn't grow if I take out the @current := @next

[01:37] <MikeFair_> Hey all

[01:38] <MikeFair_> TimToady: Does it grow if you take out the 0; at the end?  (that zero might prevent tail recursion detection)

[01:38] <MikeFair_> TimToady: Or is it needed

[01:38] <MikeFair_> TimToady: Or do you think it might the "my" inside the loop

[01:39] <raiph> r: my @current; my @next; loop { @next = (1..100000).roll(10000); @current := @next; }

[01:39] <p6eval> rakudo 2e3365: OUTPUT«(timeout)»

[01:39] <MikeFair_> hehe - go raiph

[01:39] <raiph> r: my @current; my @next; loop { @next = (1..10).roll(10); @current := @next; }

[01:40] <p6eval> rakudo 2e3365: OUTPUT«(timeout)»

[01:40] <TimToady> well, I was trying to avoid something collecting the results of the loop, but I shoulda put the 0 on the outside to do that

[01:40] <TimToady> but even an explicit sink on the loop doesn't prevent the leek

[01:40] <TimToady> *leak

[01:40] <TimToady> nor does the sweep 1, au++

[01:40] <MikeFair_> That last example from raiph is shocking to me

[01:41] *** FROGGS_ joined
[01:41] <MikeFair_> one iteration times out??

[01:41] <raiph> r: my @current; my @next; loop { @next = (1..1).roll(1); @current := @next; }

[01:41] <TimToady> no, the loop times out

[01:41] <colomon> MikeFair_: loop is infinite loop

[01:41] <p6eval> rakudo 2e3365: OUTPUT«(timeout)»

[01:41] <MikeFair_> colomon: oh, duh

[01:42] <TimToady> you can't see the memory growth with evalbot, you have to try it on your own machine

[01:42] <MikeFair_> colomon: Thx

[01:43] <TimToady> dunno if this is the leak that is causing my 15GB, but it could be, since I have the same sort of "last time through" array

[01:43] <TimToady> also leaks with =, not just with :=

[01:44] *** flightrecorder left
[01:44] *** FROGGS left
[01:45] *** flightrecorder joined
[01:45] <TimToady> afk &

[02:05] *** flightrecorder left
[02:05] *** FROGGS_ left
[02:14] *** HarryS left
[02:21] *** kurahaupo left
[02:22] *** PacoAir left
[02:26] *** FROGGS joined
[02:29] *** flightrecorder joined
[02:36] *** am0c joined
[02:42] *** am0c left
[02:42] *** am0c joined
[02:45] <dalek> roast: 6aff7bd | (Solomon Foster)++ | S32-num/expmod.t:

[02:45] <dalek> roast: Add some basic tests for expmod.

[02:45] <dalek> roast: review: https://github.com/perl6/roast/commit/6aff7bd150

[02:46] *** FROGGS left
[02:46] <colomon> TimToady: is the expmod in rc yours?

[02:47] *** flightrecorder left
[02:50] *** yarp joined
[02:50] <dalek> niecza: 1760451 | (Solomon Foster)++ | / (2 files):

[02:50] <dalek> niecza: Borrow TimToady++'s implementation of expmod.

[02:50] <dalek> niecza: review: https://github.com/sorear/niecza/commit/17604511ff

[02:51] <TimToady> colomon: I believe so.

[02:52] <colomon> That was my conclusion, as you can see.  :)

[02:54] <sorear> n: (1 .. 10**1000).roll.say

[02:54] <p6eval> niecza v21-15-gf226bf6: OUTPUT«Inf␤»

[02:54] <sorear> n: say 10**1000

[02:54] <p6eval> niecza v21-15-gf226bf6: OUTPUT«1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000…

[02:54] <sorear> n: (1 .. 10**100).roll.say

[02:54] <p6eval> niecza v21-15-gf226bf6: OUTPUT«2133311737390845811379582797551885492279278014655713661890031696021502921418274361246204385883586561␤»

[02:55] <colomon> sorear!  \o/

[02:55] *** FROGGS joined
[02:55] <colomon> oooo, bug

[02:55] <sorear> colomon: want to take a crack at https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test ?  If you can get Range.roll working properly for bignums, it will be trivial

[02:55] <colomon> that one probably *is* my fault.

[02:56] *** flightrecorder joined
[02:56] <colomon> sorear: I was planning on just importing TimToady's version as a first step.

[02:56] <colomon> but not tonight, I should be getting to bed.

[02:59] <sorear> sleep well

[02:59] * colomon is in a great mood tonight, because someone posted "John McKenna: His Original Recordings" and "Fluters of Old Erin" to the web in their entirety.  As a result, been listening to nothing but old 78 recordings all evening.

[03:06] *** fgomez left
[03:07] *** yarp left
[03:09] *** FROGGS left
[03:09] *** flightrecorder left
[03:10] * [Coke] wonders how old you have to be to know what a 78 is.

[03:11] <[Coke]> too young, they're from "1978". ;)

[03:12] <TimToady> 45s are the thing now

[03:13] *** yarp joined
[03:16] *** benabik left
[03:17] *** benabik joined
[03:18] <sorear> [Coke]: they're round things that spin at 78rpm and have a groove on them encoding audio, from back in the sad days before people discovered audio could be encoded as 1s and 0s

[03:21] <MikeFair_> sorear: And even before '8-Tracks

[03:23] *** fgomez joined
[03:24] * TimToady remembers when 33⅓ was introduced...

[03:31] *** mucker left
[03:32] <TimToady> and the very short reign of "HiFi" before "Stereo" became the rage

[03:33] *** FROGGS joined
[03:33] * benabik wonders how many people think "HiFi" is a new kind of "WiFi"

[03:41] <MikeFair_> benabik: HiFi clearly must be the next gen thing after "BluRay" :)

[03:42] <MikeFair_> beyond HD

[03:45] *** FROGGS left
[03:58] *** FROGGS joined
[04:35] *** FROGGS left
[04:36] *** FROGGS joined
[04:46] *** thou joined
[04:48] *** flightrecorder joined
[05:09] *** raiph left
[05:26] <TimToady> aside from the minor memory leak above, I find out why it's chewing up memory; last statement of two nested loops was a push

[05:27] *** FROGGS left
[05:27] *** flightrecorder left
[05:27] <TimToady> rakudo doesn't realize the for loops are in sink context, so collects all those pushes for the current base, and doesn't realize it doesn't need them

[05:27] <TimToady> when I change the inner push to a gather/take (or put a () after the push), it doesn't grow huge

[05:28] <TimToady> moral: sink context can be really important for avoiding unnecessary work

[05:30] <TimToady> the other weird thing I've figured out is that libtommath's is_prime is mostly just doing trial division by the first 256 primes, so it almost never gets into the Miller-Rabin part

[05:30] <TimToady> I kinda wish there was a way to bypass that trial division...

[05:31] <TimToady> when it does get into Miller-Rabin, the "random" numbers it chooses are the first N primes from the very same table...not sure if that is a good thing, numerically speaking...

[05:35] <TimToady> so, like, if you say is-primes(1), it always uses 2

[05:35] <sorear> probably not safe, but probably not an issue

[05:35] *** FROGGS joined
[05:36] *** flightrecorder joined
[05:36] <sorear> Kolmogorov says almost all numbers are random

[05:36] <TimToady> er, I don't follow; if it's not safe, how is it not an issue?

[05:37] <sorear> I mean there's probably some number that will be falsely passed by tommath is_prime 100% of the time

[05:37] <sorear> but I'm never going to find it unless you can hook me up with an NP-oracle

[05:38] <TimToady> one can never find that darn NP-oracle when you need her...

[05:39] *** jaldhar joined
[05:50] *** popl left
[05:50] *** Chillance left
[05:51] <TimToady> nr: print "1234"; $*OUT.flush; exit

[05:51] <p6eval> niecza v21-16-g1760451: OUTPUT«1234Unhandled exception: Unable to resolve method flush in type TextWriter␤  at /tmp/oqg91Uva1i line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4155 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4156 (module-CORE @ 572) ␤…

[05:51] <p6eval> ..rakudo 2e3365: OUTPUT«No such method 'flush' for invocant of type 'IO'␤  in block  at /tmp/dT1bU9XBrY:1␤␤1234»

[05:53] <TimToady> doesn't seem to be any concept of autoflush either

[05:56] <TimToady> (and prompt still doesn't flush either in rakudo on my box, which makes it next to useless)

[06:05] <moritz> \o morning

[06:05] <phenny> moritz: 21 Sep 22:05Z <raiph> tell moritz there's a typo in https://github.com/moritz/ilbot/blob/master/cgi/template/day.tmpl -- "<TMPL_UNLESS NAME=IS_SUMAMRY>" tried to fix and pull request via github but there's something going on that seems to break when i try.

[06:09] *** am0c left
[06:09] <TimToady> o/

[06:09] *** am0c joined
[06:09] <moritz> phenny: tell raiph thanks, fixed

[06:09] <phenny> moritz: I'll pass that on when raiph is around.

[06:09] *** flightrecorder left
[06:11] <TimToady> is-prime seems to be working pretty well

[06:11] *** FROGGS left
[06:14] <moritz> \o/

[06:14] <moritz> except for negative numbers

[06:14] <moritz> r: say (-2).is-prime

[06:14] <p6eval> rakudo 2e3365: OUTPUT«False␤»

[06:14] <moritz> should be True, no?

[06:15] <TimToady> uh, why?

[06:15] <TimToady> I've never heard of negative primes...

[06:15] <moritz> because -2 is only divisble by -2 and 1

[06:15] <moritz> ok, I'm wrong

[06:15] <moritz> never mind then

[06:16] <moritz> anyway, I'll do the sub forms next

[06:16] <moritz> should they coerce from Real and Cool?

[06:17] <TimToady> well, I guess

[06:17] <moritz> oh, one more question

[06:17] <moritz> the spec lists many multis, but usually omits the protos

[06:17] <TimToady> though you almost want a coercion that will fail if the Real isn't an integer

[06:18] <moritz> so the question is, should something like proto sub chr  have a signature of ($) or (|) ?

[06:18] <moritz> thing is, (|) makes it much more extensible, if you ever want that

[06:18] <moritz> but it means that saying map &chr, @list;   will not work as you might wish it to

[06:19] <moritz> because if the proto is (|), then &chr accepts arbitrarily many arguments

[06:19] <TimToady> my inclination has been to have the more restrictive protos, since you can always shadow it with your own proto if you want to extend

[06:20] <TimToady> and maybe that gives more for the optimizer to work with too

[06:20] <moritz> ok

[06:20] <moritz> and if I shadow a proto, how do I dispatch to the original one? with OUTER?

[06:20] <TimToady> maybe nextsame?

[06:21] <TimToady> OUTER would probably work

[06:21] *** yarp left
[06:21] * moritz considers nextsame/nextwith

[06:22] <TimToady> presumably it'd have to be called directly from the shadowing proto

[06:23] <TimToady> except, of course, that the proto has been compiled as an "only", so the outer proto doesn't really know about it

[06:24] <moritz> regarding the more restrictive protos: currently it'll slow down things a bit

[06:24] <moritz> (I think)

[06:24] <moritz> because it means the signature of the proto and of the multi need to be checked

[06:25] <TimToady> could be, unless we can use that to factor out checks from all the multis

[06:26] <TimToady> or we figure out to ignore a proto sig that's redundant with its multis

[06:26] <moritz> maybe if the optimizer can proof that all the candidate's signatures imply the same restriction as the proto

[06:26] <TimToady> then it's just there for arity

[06:27] <TimToady> but if it's just for arity, then we could probably deduce that from the multis as well

[06:27] <TimToady> that would lead to instability in the face of imports, however

[06:28] <moritz> arit yand autothreading

[06:28] <TimToady> since an import could add args

[06:29] <TimToady> anyway, I'm okay with protos being specific about arity in the core langauge, I think, and let the people who want to override that work a little harder

[06:30] <moritz> ok

[06:30] <TimToady> at least for the functions it makes sense to have an arity for

[06:30] <moritz> I'll do it that way, and write a deprecation notice for the next release

[06:30] <moritz> sure

[06:31] <TimToady> long term, I'd like to get to the point where introspecting arity is considered kinda wrongish

[06:31] <TimToady> and we just bind it and see how many args actually get bound

[06:31] <TimToady> looking at arity is kinda like checking eof

[06:31] *** wk joined
[06:35] *** yarp joined
[06:40] <cognominal> r: sub a { say 'called' };  a{}; a.{}; a[]; a.[]

[06:40] <p6eval> rakudo 2e3365: OUTPUT«called␤called␤called␤called␤»

[06:41] <sorear> moritz: -2 is a prime in ring theory, but not in number theory :D

[06:41] <cognominal> r: sub a { say 'called' };  a.()

[06:41] <p6eval> rakudo 2e3365: OUTPUT«called␤No such method 'postcircumfix:<( )>' for invocant of type 'Bool'␤  in  at src/gen/BOOTSTRAP.pm:825␤  in any  at src/gen/BOOTSTRAP.pm:809␤  in block  at /tmp/B8yI57zATl:1␤␤»

[06:41] <cognominal> weird

[06:41] <TimToady> r: sub a { say 'called' };  &a.()

[06:41] <p6eval> rakudo 2e3365: OUTPUT«called␤»

[06:42] <TimToady> as a special form, a only takes (), not .()

[06:42] <sorear> in the more general context, it doesn't make sense to restrict to positive elements, because elements of a general ring don't have a notion of positiveness

[06:42] *** Celelibi left
[06:42] <sorear> but you still have primes in a sense of non-factorizability: x is prime if you cannot write  x = y*z where y and z are non-invertable

[06:43] <sorear> (I know I'm being loose with the distinction between primes and irreducables)

[06:43] <cognominal> apparently that channel has mutated to number theory

[06:43] <TimToady> .oO(one ring to rule them all)

[06:43] *** FROGGS joined
[06:45] <cognominal> by that Tolkien, you can unite many things.

[06:49] *** flightrecorder joined
[06:51] * TimToady is wondering how niecza manages to avoid flushing problems without mentioning 'flush' anywhere

[06:52] <sorear> TimToady: MicrosoftCamelCaseNaming

[06:52] <TimToady> ah

[06:53] <TimToady> stdout.AutoFlush = true; return stdout;

[06:53] <diakopter> have your plunger handy

[06:54] <cognominal> TimToady should learn to be insensitive

[06:54] <cognominal> …in that case

[06:55] * TimToady will continue to run his quiz editor in niecza till rakudo learns to flush or Flush or whatever...

[06:55] <TimToady> (quiz tomorrow, y'see)

[06:55] <moritz> actually we have a pull request for something like that

[06:55] <sorear> r: say $*OUT.^methods(:local)

[06:55] <p6eval> rakudo 2e3365: OUTPUT«open close eof get getc lines read seek tell write opened t print slurp copy chmod Str d e f l r s w x z modified accessed changed say <anon> <anon> <anon>␤»

[06:56] <TimToady> there's no flush in CORE

[06:56] <moritz> TimToady: https://github.com/rakudo/rakudo/pull/71

[06:56] <TimToady> and parrot only knows about "autoflush" on close, which seems like it shouldn't be optional...

[06:56] <moritz> TimToady: a comment on the proposed API would be welcome

[06:57] <sorear> .oO( implement flush with ITS semantics )

[06:57] <dalek> rakudo/nom: e095de4 | moritz++ | / (2 files):

[06:57] <dalek> rakudo/nom: sub forms of is-prime and expmod

[06:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e095de4ec2

[06:57] <moritz> (you have to check the patch for that)

[06:58] <sorear> "method DESTROY()" is obviously wrong

[06:59] <TimToady> well, regardless of the merits of autoflushing on close, an autoflushed filehandle should be flushing it after every output

[07:00] <TimToady> the whole un/line/full-buffering underneath that is orthogonal

[07:00] <moritz> I thought unbuffering had the same effect as flushing

[07:01] <TimToady> and prompt() probably needs an explicit flush in any case, unless the handle is already autoflushed

[07:01] <TimToady> no

[07:01] <TimToady> autoflushing is "command buffering"

[07:01] <TimToady> buffer till we get done with this command, then flush

[07:01] <TimToady> unbuffering usually means put out each character as generated

[07:02] <TimToady> the distinction is probably not meaningful at the Perl 6 level however

[07:02] <TimToady> it's the lower-level routines that would be sending every char directly to output

[07:02] <TimToady> stderr is historically unbuffered

[07:04] <TimToady> if your smallest command outputs a string as 'print' does, then you can't really know whether the STDIO layer is putting it out one char at a time, or waiting till the end and autoflushing

[07:04] <TimToady> though the latter is considerably more efficient for multichar strings

[07:05] <TimToady> mostly Perl ignores the STDIO-level distinction of un/line/full and just worries about autoflush or not

[07:06] <diakopter> Perl including 6?

[07:06] <TimToady> "mostly"

[07:06] <diakopter> heh

[07:06] <TimToady> meaning we want to provide ways to set the underlying strata, but not force people to worry about them most of the time

[07:06] <TimToady> and that is the same for 6

[07:08] <sorear> note that perl 5 mostly doesn't use stdio these days

[07:09] <TimToady> yes, well...line buffering was always kind of a sad proxy for command buffering

[07:09] <moritz> öööööööööööööööööl 5~

[07:09] <sorear> Good morning Ronja

[07:10] *** thou left
[07:10] * TimToady hopes that wasn't moritz's keyboard shorting out on puke

[07:11] <TimToady> I also note that rakudo uses line buffering on output of $*OUT to a disk file, which could be construed as inefficient

[07:12] <TimToady> maybe it doesn't matter so much with modern OSes though

[07:13] <TimToady> back in the day when one VAX syscall could cost a million instructions, you tried to avoid those...

[07:13] <TimToady> well, 10,000 anyway

[07:13] <diakopter> I was gonna say; 1 second

[07:13] <TimToady> whatever the number was for a minimal system call, it was significant

[07:14] <sorear> it's still fairly bad

[07:15] <sorear> trapping from user mode into supervisor mode produces a rather big pipeline stall

[07:15] <sorear> I imagine SYSENTER et al improved things, but probably it still hurts

[07:16] <TimToady> so we might want to look at the default buffering characteristics of output files wrt filesystems vs terminals at some point

[07:17] <TimToady> well, looks like rakudo might get through the base 18 case in a day or so

[07:18] <TimToady> though due to the lack of autoflushing I have to print out each progress report on separate lines...which is what originally inspired this rant :)

[07:20] *** kaare_ joined
[07:21] <TimToady> but it's 2/3 of the way to the high-water mark, and only using 40% of my memory, so will likely fit, unless everything doubles when it exceeds 64bit integers

[07:21] <diakopter> quick buy more memory

[07:23] <TimToady> I suspect the niecza blowup is related only to the size of the bigints; it actually got past the high water with less memory than rakudo is already using, but blew up partway down the descending part of the number-of-candidates curve when ints get really long

[07:23] <TimToady> (that actual answer is supposed to be 55 digits decimal)

[07:24] * diakopter gets curious how perlesque would do

[07:25] <TimToady> so probably tickling a bug in microsoft's bigint routines, but hard to reproduce, since it takes more than a day of compute time

[07:26] *** spider-mario joined
[07:28] <cognominal> r: $/ = 'foo'

[07:28] <p6eval> rakudo e095de:  ( no output )

[07:29] <cognominal> TimToady, is there any use to accept $/ set to values that are not Matches?

[07:29] <cognominal> this invite misuses

[07:30] <TimToady> one of the tests sets it to Any, which gives STD fits

[07:30] <TimToady> since it then thinks it's P5 code

[07:31] <TimToady> n: $/ = 'foo'

[07:31] <p6eval> niecza v21-16-g1760451: OUTPUT«===SORRY!===␤␤Unsupported use of $/ variable as input record separator; in Perl 6 please use the filehandle's :irs attribute at /tmp/kNtgJyozbs line 1:␤------> $/⏏ = 'foo'␤␤Parse failed␤␤»

[07:31] <cognominal> I can understand that it is set explictely, preferably with :=,  to previous matches.

[07:33] *** FROGGS left
[07:33] *** flightrecorder left
[07:33] *** Psyche^ joined
[07:37] *** Patterner left
[07:37] *** Psyche^ is now known as Patterner

[07:44] *** M_o_C joined
[07:45] <TimToady> zzz &

[07:46] *** cognominal left
[07:47] *** cognominal joined
[07:51] *** pmurias joined
[07:51] *** birdwindupbird joined
[07:51] <pmurias> jnthn: ping

[07:53] *** cognominal left
[07:59] *** cognominal joined
[08:01] *** skids left
[08:01] *** HarryS joined
[08:08] *** cognominal left
[08:15] <moritz> nqp: say(pir::typeof__SP(pir::getstdout__P()))

[08:15] <p6eval> nqp: OUTPUT«FileHandle␤»

[08:16] *** cognominal joined
[08:17] <pmurias> should basic IO be moved into nqp rather than escaping to parrot?

[08:18] <moritz> interesting question

[08:18] <moritz> I'd say +1, but I'd also wait for jnthn & pmichaud 

[08:18] *** FROGGS joined
[08:18] <FROGGS> good morning

[08:19] *** wamba joined
[08:21] *** flightrecorder joined
[08:23] *** cognominal_ joined
[08:24] <dalek> rakudo/nom: b72c434 | moritz++ | src/core/IO.pm:

[08:24] <dalek> rakudo/nom: flush $*OUT in &prompt

[08:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b72c434660

[08:24] <moritz> \o FROGGS 

[08:25] <FROGGS> moin moritz

[08:25] <moritz> wow, $*IN.get seems to be broken

[08:25] <moritz> it doesn't return after reading one line

[08:25] <pmurias> it's not tested?

[08:25] <moritz> well

[08:25] *** cognominal left
[08:26] <moritz> it's tested, but only with streams that produces an EOF eventually

[08:26] <FROGGS> btw, I gave up trying to get multi trait symbol importing working, I spend four days debugging World.pm and friends, but I cant find the right place where I have to tweak something

[08:27] <moritz> :(

[08:27] <moritz> .oO( the World.pm is not enough )

[08:28] <FROGGS> ya, looked at traits.pm too, there I can see the export groups

[08:28] <masak> morning, #perl6

[08:28] <FROGGS> but what is calling into World.pm? do I have to it the dispatcher? or earlier?

[08:28] <FROGGS> morning masak

[08:28] <moritz> \o masak 

[08:29] <moritz> FROGGS: Actions.pm, Grammar.pm and some few built-ins (src/core/*) call into World.pm

[08:29] <moritz> FROGGS: you can juts nqp::die() in there and look at the backtrace

[08:29] <FROGGS> its a bit complex though

[08:30] <FROGGS> maybe a bit too complex for me :/

[08:30] <moritz> any part which you're particularly interested in?

[08:30] <moritz> I don't know all of World.pm, but I did work with importing a bit

[08:31] *** GlitchMr joined
[08:31] <FROGGS> moritz: in a module I use NativeCall together with Inline.pm

[08:31] <FROGGS> both export trait_mod:<is>

[08:32] <FROGGS> if I remove the "die, duplicate symbol trait_mod:<is>" I still dont have both symbols in the dispatcher list

[08:33] <FROGGS> NativeCall exports "is natice", "is symbol" and another one I dont know right now, my Inline.pm exports "is inline"

[08:33] <moritz> X::Export::NameClash.new(symbol => exp_name).throw # this one?

[08:34] <FROGGS> this: self.throw($/, 'X::Import::Redeclaration',

[08:34] <FROGGS>                 symbols             => @clash,

[08:34] <FROGGS>                 source-package-name => $source_package_name,

[08:34] <FROGGS>             );

[08:34] <moritz> ah, ok

[08:34] <moritz> all 'is' multis share the same routine name

[08:34] <FROGGS> the list of non-matching signatures shows only the trait_mod:<is>'s from the module that was imported at last 

[08:35] <FROGGS> ya, &trait_mod:<is>

[08:35] *** birdwindupbird left
[08:35] <FROGGS> my problem is: where is this signature-list?

[08:36] <moritz> that I can answer, I hope

[08:36] <FROGGS> cool

[08:36] <moritz> if you can get your hands on the routine object, you can call .candidates

[08:36] <moritz> and that's a list of candidates, and each has a .signature

[08:36] <moritz> though you don't need the signatures

[08:37] <FROGGS> how can I print information about the candidates?

[08:37] <moritz> r: say &infix:<+>.candidates.perl

[08:37] <p6eval> rakudo e095de: OUTPUT«(sub infix:<+>($x = { ... }) { ... }, sub infix:<+>(\a, \b) { ... }, sub infix:<+>(Real \a, Real \b) { ... }, sub infix:<+>(Int:D \a, Int:D \b) { ... }, sub infix:<+>(int $a, int $b) { ... }, sub infix:<+>(Num:D \a, Num:D \b) { ... }, sub infix:<+>(num $a, num $b) …

[08:37] <FROGGS> do I have .perl in World.pm? thats nqp, right?

[08:37] <moritz> the object is a Perl 6 Routine

[08:37] <moritz> so you can call .perl

[08:37] <FROGGS> k

[08:38] <moritz> FROGGS: look at src/core/Routine.pm for what a Routine supports

[08:38] <moritz> r: sub f() { }; say &f.is_dispatcher

[08:38] <p6eval> rakudo e095de: OUTPUT«False␤»

[08:39] <FROGGS> k

[08:39] <moritz> FROGGS: I think the merging should only happen if both routines have .is_dispatcher return True

[08:39] <moritz> r: proto f() { }; say &f.is_dispatcher

[08:39] <p6eval> rakudo e095de: OUTPUT«True␤»

[08:39] <moritz> r: multi f() { }; say &f.is_dispatcher

[08:39] <p6eval> rakudo e095de: OUTPUT«True␤»

[08:39] <FROGGS> ahh, cool

[08:40] <FROGGS> r: &trait_mod:<is>.is_dispatcher.say

[08:40] <p6eval> rakudo e095de: OUTPUT«True␤»

[08:40] <moritz> one way forward is to create a new proto, and attach the candidates from both conflicting objects

[08:40] <moritz> as a first step

[08:41] <moritz> in the long run, I think that we're still missing a piece, but I'll have to discuss that with jnthn

[08:41] <moritz> I think it should be a difference whether you export a proto or a candidate

[08:42] <moritz> and candidates should be auto-merged, but protos only if they are onlystar

[08:43] *** cognominal_ left
[08:43] <moritz> but don't worry about that yet, that's a topic for a future development

[08:44] *** cognominal joined
[08:45] <FROGGS> k

[08:46] <moritz> r: say &trait_mod:<is>.onlystar

[08:46] <p6eval> rakudo e095de: OUTPUT«False␤»

[08:47] <moritz> r: proto foo(|) { * }; say &foo.onlystar

[08:47] <p6eval> rakudo e095de: OUTPUT«True␤»

[08:48] <masak> r: say {;}.is_dispatcher

[08:48] <p6eval> rakudo e095de: OUTPUT«Can not get attribute '$!dispatchees' declared in class 'Routine' with this object␤  in any  at src/gen/BOOTSTRAP.pm:579␤  in block  at /tmp/Wu8lQnVML4:1␤␤»

[08:48] <masak> hm, LTA.

[08:48] <moritz> jnthn: ^^ why isn't &trait_mod:<is>.onlystar True? the declaration is proto trait_mod:<is>(|) { * }

[08:48] <masak> r: say {;}.onlystar

[08:48] <p6eval> rakudo e095de: OUTPUT«No such method 'onlystar' for invocant of type 'Block'␤  in block  at /tmp/GvB4eQ4kNn:1␤␤»

[08:49] *** cognominal left
[08:49] <moritz> it seems that method is_dispatcher is installed in the wrong level

[08:49] <moritz> yes, installed in Code

[08:50] *** cognominal joined
[08:51] <moritz> I'll move it into Routine and spectest

[08:52] <moritz> if it doesn't work, we can always have the one in Code return False, and leave the more specific one in Routine

[08:52] * moritz loves mro

[08:54] <masak> mro++

[08:54] <masak> moritz++

[08:55] <moritz> it compiles with is_dispatcher in Routine

[08:55] <moritz> I don't think we'll see failures in the spectests then

[08:56] <moritz> but it's still worth checking

[08:57] <moritz> btw yesterday was my day in Parliament

[08:57] <moritz> I learned a lot

[08:57] <moritz> for example that I'm not suited for politics

[08:57] <moritz> and that the IT infrastructure of the administration is far worse than I feared

[08:58] <moritz> and that flying business class is something I could get used to

[08:58] <masak> :)

[08:58] <FROGGS> hehe

[09:03] <moritz> the video coverage from the first session that day is already up

[09:03] *** cognominal left
[09:03] <moritz> I guess the one from "my" session will follow soon

[09:04] <FROGGS> post the linky then please

[09:04] <moritz> will do

[09:05] <moritz> woah, 1.7GB video for ~2h

[09:06] <masak> it's because Parliamentary deliberations are so information-dense.

[09:06] <masak> :P

[09:06] <moritz> :-)

[09:07] * sorear supposes it was probably not conducted in English

[09:07] <moritz> sorear supposes correctly

[09:07] <masak> given that it's Germany...

[09:07] <moritz> though the effort to get video coverage was quite impressive

[09:08] <moritz> with three professionally-looking cameras

[09:08] <masak> is there an example of a country where Parliament matters are not conducted in one/the official language of the state?

[09:08] <masak> I would think not.

[09:08] <sorear> I think that by definition any language used by Parliament is an official language

[09:09] <masak> well, for a long time Sweden didn't have an official language.

[09:09] <sorear> although there are some funny places like the US and India where local governments can do business in languages that are not official nationally

[09:09] <masak> I think it was like that until 2006.

[09:09] * moritz could imagine that the Finnish Parliament might hear international experts in English

[09:10] <masak> oh, sure, hearing international experts in English is probably common. but that's not what I meant.

[09:10] *** am0c left
[09:10] <moritz> right

[09:10] <moritz> well, it was an expert hearing (though not internal), not a debate

[09:11] *** cognominal joined
[09:11] <moritz> http://www.bundestag.de/Mediathek/index.jsp?action=search&ids=1912841&instance=m187&mask=search&contentArea=details

[09:12] <moritz> FROGGS: ^^ that's the video coverage. I thought it was for the other hearing, but it's actually for "mine"

[09:12] <sorear> masak: what language does the Swedish parliament debate in?

[09:13] *** wk left
[09:15] <masak> Swedish.

[09:15] <masak> we're very English-friendly over here, but not that much ;)

[09:15] <dalek> rakudo/nom: cfd5e72 | moritz++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[09:15] <dalek> rakudo/nom: move is_dispatcher from Code to Routine

[09:15] <dalek> rakudo/nom: 

[09:15] <dalek> rakudo/nom: it did not work in Code anyway, because it uses an attribute from Routine

[09:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cfd5e72b3e

[09:17] <masak> ah. Swedish was declared the "main" language of Sweden on 2009-07-01.

[09:17] <masak> before that, the joke was that Swedish was one of the officially recognized languages in the European Union because it was an official language in Finland. :)

[09:18] <sorear> offically, the US does not have a main language.  nobody cared about this until about five years ago

[09:19] <masak> I doubt that nobody cared until five years ago.

[09:19] <masak> but politics is a sluggish thing, and it takes lots of effort to get any proposed law accepted.

[09:19] <diakopter> I doubt that the amount of people who care about it changes much over time

[09:21] <diakopter> urp

[09:22] <moritz> r: proto a() {*}; multi a() { }; say &a.onlystar

[09:22] <p6eval> rakudo b72c43: OUTPUT«True␤»

[09:39] <sorear> whee, finally tracked down the bizarre set bug from this morning.

[09:39] <sorear> will fix it tomorrow

[09:39] <sorear> sleep&

[09:39] <FROGGS> gnight

[09:45] * masak .oO( "[bizarre set] bug" or "bizarre [set bug]"? )

[09:59] <tadzik> good morning #perl6

[09:59] <FROGGS> hi tadzik

[10:00] <cognominal> sorear, 20 years ago, when I got the driver exam in california, I could have taken it in spanish and some other languages. I was told DMV was a mess. I did everything and got my DMV licence in 3 hours, Visibly, my informers did not  ever dealt with French administrations. It was for me a model of efficient administration. Driver licenses in France are just an organized racket,  random, painful and costly.

[10:01] <masak> huh! I was contacted about providing advertising space on strangelyconsistent.org.

[10:02] <masak> my gut reaction is to politely decline.

[10:02] <cognominal> you have polite guts :)

[10:02] <masak> well, the email making the request was polite.

[10:35] *** wamba left
[10:43] *** cognominal left
[10:49] *** tgt joined
[10:50] *** MayDaniel joined
[10:53] <jnthn> afternoon, #perl6

[10:54] <tadzik> good afternoon jnthn 

[10:54] <tadzik> so I barely made it in the morning. Awesome :)

[10:55] <moritz> masak: you can politely point out that if they are interested in ad space on programming blogs, perlgeek.de/blog-en/ might be an option :-)

[10:55] <moritz> (for text links only)

[10:58] <masak> I might do that. haven't replied to them yet.

[10:59] <masak> they say that the ads would be unobtrusive, and I believe them.

[10:59] <masak> but I still have a nagging feeling that the extent to which they will annoy/invonvenience *me* (even if slight) will exceed the monetary compensation I will get for it.

[11:00] <masak> that's my rationale for my gut feeling, anyway :)

[11:05] *** Su-Shee_ joined
[11:07] <dalek> roast: f29377c | (Solomon Foster)++ | S32-num/expmod.t:

[11:07] <dalek> roast: Add tests for sub form of expmod.

[11:07] <dalek> roast: review: https://github.com/perl6/roast/commit/f29377ceba

[11:08] <moritz> wait what, we have tests already?

[11:08] <moritz> colomon++

[11:08] <colomon> moritz: I added them so I knew the niecza version was working.

[11:08] <colomon> Could probably use more / better tests, but they're a start, anyway.

[11:08] <moritz> aye

[11:09] <moritz> rakudo passes them \o/

[11:09] <colomon> \o/

[11:09] <dalek> niecza: 83d732c | (Solomon Foster)++ | lib/CORE.setting:

[11:09] <dalek> niecza: Loosen argument types on Int.expmod, add sub expmod.

[11:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/83d732c264

[11:09] *** Su-Shee left
[11:24] <dalek> rakudo/nom: c8b1982 | moritz++ | t/spectest.data:

[11:24] <dalek> rakudo/nom: run expmod tests by colomon++

[11:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c8b198286c

[11:44] <colomon> moritz: are there is-prime tests yet?

[11:50] *** M_o_C left
[11:51] * colomon is now writing is-prime tests

[11:53] <moritz> colomon: no

[11:58] <diakopter> halp. what does this mean: .sort(-*)

[11:58] <colomon> diakopter: sort numerically backwards

[11:58] <diakopter> kthxbai

[11:59] <colomon> ie sort on numerical negation of each term

[12:11] * colomon is kind of shocked how fast the pure-perl6 Miller-Rabin is in Niecza.  sorear++ TimToady++

[12:12] *** birdwindupbird joined
[12:13] * colomon just tested 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151

[12:14] <dalek> roast: 67af080 | (Solomon Foster)++ | S32-num/is-prime.t:

[12:14] <dalek> roast: Some basic tests for is-prime.

[12:14] <dalek> roast: review: https://github.com/perl6/roast/commit/67af08032a

[12:14] <diakopter> colomon: how long did that test take

[12:14] <colomon> The entire is-prime.t test file (including that one) takes 4.3 seconds to fudge and execute in Niecza.

[12:15] <colomon> And I'm not even close to having all the optimizations in I hope to have by the end of today.

[12:16] <moritz> nr: say is-prime 6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151

[12:16] <p6eval> niecza v21-17-g83d732c: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'is-prime' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at …

[12:16] <p6eval> ..rakudo c8b198: OUTPUT«True␤»

[12:17] * colomon hasn't checked in niecza's is-prime yet.

[12:17] <moritz> fwiw rakudo takes 0.87s for that one-liner here

[12:17] <moritz> of which 0.4..0.5s is startup time

[12:18] <diakopter> what does .base do

[12:18] <moritz> nr: say 255.base(16)

[12:18] <p6eval> rakudo c8b198, niecza v21-17-g83d732c: OUTPUT«FF␤»

[12:18] <pmichaud> good morning, #perl6

[12:18] <colomon> \o

[12:18] <moritz> good am, pm

[12:18] <pmichaud> I think I would've expected the isprime opcode to go into rakudo instead of nqp.

[12:19] <moritz> pmichaud: well, we have all the libtommath bindings in nqp

[12:19] * pmichaud looks closer.

[12:20] <moritz> and all that nqp does is wrap it, and catch one special case that tommath doesn't handle well

[12:20] <dalek> niecza: ea871cb | (Solomon Foster)++ | lib/CORE.setting:

[12:20] <dalek> niecza: is-prime borrowed from TimToady++.

[12:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ea871cb55b

[12:20] <dalek> niecza: 8e3a364 | (Solomon Foster)++ | t/spectest.data:

[12:20] <dalek> niecza: Turn on is-prime.t test.

[12:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8e3a3643db

[12:20] <pmichaud> okay.

[12:20] <pmichaud> I can go with that, then.

[12:20] <moritz> (it thinks 1 is a prime :-)

[12:20] <moritz> glad to hear that

[12:21] <jnthn> o/ pmichaud 

[12:21] <pmichaud> moritz++

[12:23] <dalek> rakudo/nom: 80f73bb | moritz++ | t/spectest.data:

[12:23] <dalek> rakudo/nom: run is-prime tests by colomon++

[12:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/80f73bb971

[12:25] <masak> pmichaud! \o/

[12:27] <colomon> hmmm, finding all primes up to 1,000,000 is slow (niecza)

[12:28] <colomon> making it a good candidate for optimization, I guess.  :)

[12:30] <dalek> rakudo/nom: f39ec7c | moritz++ | docs/deprecations:

[12:30] <dalek> rakudo/nom: schedule some deprecations for 2012.11

[12:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f39ec7cd0d

[12:32] <spacebat_> star: <one two three>.grep({ "two" eq $_ })

[12:32] <p6eval> star 2012.07:  ( no output )

[12:32] <masak> spacebat_: 'say'

[12:33] <moritz> star: say <one two three>.grep({ "two" eq $_ })

[12:33] <p6eval> star 2012.07: OUTPUT«two␤»

[12:33] <spacebat_> d'oh :)

[12:33] <moritz> star: say <one two three>.grep('two')

[12:33] <p6eval> star 2012.07: OUTPUT«two␤»

[12:33] <moritz> grep doesn't just accepts blocks, but anything that you can smartmatch against

[12:33] <masak> star: say <one two three>.grep(/^t/)

[12:33] <p6eval> star 2012.07: OUTPUT«two three␤»

[12:33] <spacebat_> star: say <one two three>.grep({ "two" ~~ m:i/$_/ })

[12:33] <p6eval> star 2012.07: OUTPUT«one two three␤»

[12:33] <masak> star: say <one two three>.grep(/w/)

[12:33] <p6eval> star 2012.07: OUTPUT«two␤»

[12:34] <masak> star: say <one two three>.grep(*.chars > 4)

[12:34] <p6eval> star 2012.07: OUTPUT«three␤»

[12:34] <moritz> seems I've forgotten to update p6eval to star 2012.08

[12:34] <moritz> but now I'll just wait for this month's star release

[12:34] <moritz> who's doing that anyway?

[12:34] <spacebat_> does anyone know why <one two three>.grep({ "two" ~~ m:i/$_/ }) gives <one two three>?

[12:34] <spacebat_> 2012.09 now

[12:35] <spacebat_> oh wait

[12:35] <masak> star: say <one two three>.grep({ state $i++ == 1 })

[12:35] <p6eval> star 2012.07: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix + instead␤at /tmp/txSqemsV1J:1␤»

[12:35] <spacebat_> that's just the compiler sorry

[12:35] <masak> star: say <one two three>.grep({ (state $i)++ == 1 })

[12:35] <p6eval> star 2012.07: OUTPUT«two␤»

[12:35] <masak> star: say <one two three>.grep({ (state $)++ == 1 })

[12:35] <p6eval> star 2012.07: OUTPUT«two␤»

[12:35] <moritz> spacebat_: because ~~ sets $_ of the right-hand side to the value of the left-hand side

[12:35] <moritz> r: 'foo' ~~ say $_

[12:35] <p6eval> rakudo c8b198: OUTPUT«foo␤»

[12:36] <pmichaud> I can likely do the star release again.

[12:36] <spacebat_> ok guess I need to read up on ~~

[12:36] <pmichaud> probably a good idea, since I need to figure out how to update the git subprojects and add that to the docs

[12:36] <spacebat_> I've been reading that recent post about loading the perl6 log with LWP::Simple

[12:36] <moritz> ++pmichaud

[12:36] <spacebat_> it has a construct like that

[12:37] <moritz> then it's likely wrong

[12:37] <spacebat_> yeah trying to get my head around it

[12:38] <spacebat_> @strings.grep({ $html ~~ m:i/$_/ })

[12:38] <moritz> yes, that's wrong

[12:38] <spacebat_> how would you perform that grep/match without clobbering $_

[12:39] <moritz> well, first of all I'd this instead:

[12:40] <moritz> my $re = @strings.join('|'); $re = rx/<$re>/

[12:40] <moritz> and then get rid of the grep entirely

[12:41] <moritz> but if you want to do it with grep, you just have to use a different variable than $_

[12:42] <spacebat_> fair enough

[12:43] <moritz> @strings.grep(-> $pat { $html ~~ $pat })

[12:43] <spacebat_> ~~ as it was introduced into P5 was deemed too magickal and complex

[12:43] <spacebat_> is it more sane in P6?

[12:43] <masak> yes.

[12:44] <moritz> yes, modulo that one snag that you can't smart-match against $_

[12:44] <spacebat_> w00t :)

[12:44] <masak> thanks, mainly, to many other things in Perl 6 being more sane.

[12:44] <spacebat_> heh always hit the one snag

[12:44] <spacebat_> or always remember hitting it

[12:44] <moritz> the problem with p5 is that it doesn't have a user-exposed type system

[12:44] <moritz> but in Perl 6 the operatioin that the smart-match performs is determined by the type

[12:45] <moritz> you can see how that can lead to trouble when porting the feature from 6 to 5

[12:45] <spacebat_> yes

[12:45] <moritz> anyway, I'll email szabgab and point him to this discussion

[12:45] <moritz> so that he can fix the article

[12:46] <spacebat_> I was going to fix it and post a comment

[12:46] <moritz> you can do that too

[12:46] <spacebat_> :)

[12:47] <moritz> mail sent

[12:51] <GlitchMr> > ('ab', 'bd', 'ac', 'def') »~~» /a/

[12:51] <GlitchMr> True False True False

[12:51] <GlitchMr> :-)

[12:52] <GlitchMr> But... there is more than one way to do it

[12:52] <GlitchMr> > 'ab', 'bd', 'ac', 'def' X~~ /a/

[12:52] <GlitchMr> True False True False

[12:52] <GlitchMr> :-)

[12:55] <GlitchMr> rn: +'e'.perl.say

[12:55] <p6eval> rakudo c8b198, niecza v21-17-g83d732c: OUTPUT«"e"␤»

[12:55] <GlitchMr> rn: (+'e').perl.say

[12:55] <p6eval> niecza v21-17-g83d732c: OUTPUT«Unhandled exception: Cannot parse number: e␤  at /home/p6eval/niecza/lib/CORE.setting line 1449 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3539 (ANON @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3541 (NumSyntax.str2num @ 5) ␤  at /h…

[12:55] <p6eval> ..rakudo c8b198: OUTPUT«Failure.new(exception => X::Str::Numeric.new(source => "e", pos => 0, reason => "base-10 number must begin with valid digits or '.'"))␤»

[12:56] <GlitchMr> rn: ('e'.Num).perl.say

[12:56] <p6eval> rakudo c8b198: OUTPUT«Cannot convert string to number: base-10 number must begin with valid digits or '.' in '⏏e' (indicated by ⏏)␤  in method Num at src/gen/CORE.setting:9869␤  in method Num at src/gen/CORE.setting:3574␤  in block  at /tmp/qMVNgm21x9:1␤␤»

[12:56] <p6eval> ..niecza v21-17-g83d732c: OUTPUT«Unhandled exception: Cannot parse number: e␤  at /home/p6eval/niecza/lib/CORE.setting line 1449 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3539 (ANON @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3541 (NumSyntax.str2num @ 5) ␤  at /h…

[12:59] *** wamba joined
[13:03] <dalek> niecza: 27543db | (Solomon Foster)++ | lib/CORE.setting:

[13:03] <dalek> niecza: Add deterministic shortcut rules for numbers less than 341,550,071,728,321.

[13:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/27543db1f1

[13:04] <masak> 341,550,071,728,321 ought to be enough for anyone.

[13:05] <masak> :P

[13:05] <spacebat_> outside the cantor cabal

[13:05] *** leprevost joined
[13:05] *** wamba left
[13:06] <masak> most positive integers are huge, in fact.

[13:06] <spacebat_> like, at least 90%

[13:06] <moritz> you can a rabin-miller test up to 341e12 with only 7 tests reliably?

[13:06] <moritz> *can do

[13:07] <masak> rn: say (2 ..^ 10).pick(3)

[13:07] <p6eval> niecza v21-19-g8e3a364: OUTPUT«9 7 8␤»

[13:07] <p6eval> ..rakudo c8b198: OUTPUT«2 9 3␤»

[13:07] <moritz> time ./perl6 -e 'say +(^50_000).grep: *.is-prime' # takes 25s on my machine

[13:07] <moritz> just iterating the numbers takes about 3s

[13:10] <colomon> moritz: really?

[13:11] <colomon> moritz: say +(1..100000).grep({ ($_ + 10000000).is-prime }); takes 20s on my machine under niecza, and that's with expmod implemented in pure p6

[13:12] <colomon> up to 50_000 takes 9.2s

[13:12] *** wamba joined
[13:12] <TimToady> note that libtommath is doing 256 trial divisions in addition to a bunch of RM

[13:12] <TimToady> *MR

[13:13] <diakopter> TimToady: ahoy

[13:13] <colomon> TimToady!  

[13:14] <colomon> TimToady: dividing by the first 256 primes?

[13:14] <diakopter> TimToady: how many elements in the high-water mark of base 18

[13:14] <diakopter> it's to 949341 after 15min

[13:15] <TimToady> 1449405

[13:15] <TimToady> colomon: yes

[13:15] <diakopter> 15min of bases 3-18

[13:15] <TimToady> not too shabby

[13:15] <dalek> doc: 586deab | (Felix Herrmann)++ | lib/Int.pod:

[13:15] <dalek> doc: [Int] correct return behavior of Miller-Rabin

[13:15] <dalek> doc: review: https://github.com/perl6/doc/commit/586deab1b0

[13:16] <diakopter> it will be interesting to see if it crashes halfway down 18 like on mono

[13:16] <diakopter> this is .NET

[13:18] * masak imagines diakopter saying that and then pushing an emissary down an infinite well

[13:19] <colomon> rn: say (10 ** 1000).rand

[13:19] <p6eval> rakudo f39ec7, niecza v21-19-g8e3a364: OUTPUT«Inf␤»

[13:19] <colomon> whoops

[13:19] <masak> close enough. :P

[13:19] <moritz> rn: say (10 ** 1000).Num

[13:19] <p6eval> rakudo f39ec7, niecza v21-19-g8e3a364: OUTPUT«Inf␤»

[13:19] <moritz> that's why

[13:20] <moritz> rn: say (10 ** 1000).pick

[13:20] <p6eval> niecza v21-19-g8e3a364: OUTPUT«1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000…

[13:20] <p6eval> ..rakudo f39ec7: OUTPUT«1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000…

[13:20] * diakopter is proud of the bigint pick I wrote

[13:21] <moritz> diakopter: where is it? can we steal it for rakudo?

[13:21] <colomon> and niecza?

[13:21] <TimToady> hafta go do stats for quizzing now

[13:21] <TimToady> afk &

[13:21] <diakopter> you couuld steal it for niecza, yes, since it uses BigInteger.new(byte[]) and System::Security::Cryptography::RNGCryptoServiceProvider

[13:22] <diakopter> https://gist.github.com/275b3728b6fb750ee4ee

[13:22] <colomon> woah

[13:22] *** leont joined
[13:23] <diakopter> oh wait, that's the broken verison; lemme update the gist

[13:25] <diakopter> there, updated

[13:27] *** cognominal joined
[13:28] *** mucker joined
[13:29] <diakopter> the pick is actually horribly inefficient

[13:29] *** jaldhar left
[13:29] *** _jaldhar joined
[13:30] *** PacoAir joined
[13:30] <colomon> diakopter: what is that written for/in?

[13:30] <diakopter> perlesque

[13:31] <diakopter> we used to have a p6eval target for it

[13:31] <diakopter> afaik, the syntax is a mostly valid subset of P6

[13:32] <colomon> with a BigInteger type

[13:32] <diakopter> though more properly, it's a subset of C# with perl-esque syntax

[13:33] <colomon> basically you're taking a set of random bytes and trying to make sure it's in the range you're looking for?

[13:33] <diakopter> yeah

[13:33] *** cart_ joined
[13:33] <diakopter> to be far more efficient, it needs to clear all the bits that are clear in the topmost contiguous string of 0s in the limit

[13:34] <diakopter> including the negative

[13:34] <colomon> I'm sure RNGCryptoServiceProvider is better, but couldn't we just use 256.rand to do that portably in p6?

[13:34] *** Pleiades` joined
[13:34] <spacebat_> I'd like to syntax highlight perl6 code, is this the best place to start https://github.com/perl6/std/blob/master/std_hilite/STD_syntax_highlight

[13:34] <diakopter> yeah, but you'd still need the raw CLR byte[]

[13:36] *** cart left
[13:37] <colomon> hurm.  isn't niecza and rakudo's current Int.rand going to have many, many numbers it can never possibly generate if the Int is, say 10 ** 100?

[13:37] <diakopter> yeah; it really needs something native

[13:39] * diakopter goes to fix the pick so it's not braindead inefficient

[13:39] <colomon> couldn't we do something like.... (10 ** 10).rand + (10 ** 10).rand * 10 ** 10 + ...  ?

[13:40] <diakopter> might as well generate it in base 256 

[13:40] <diakopter> or higher

[13:40] *** Pleiades` left
[13:40] *** cart_ left
[13:42] <diakopter> (256**1).rand+(256**2).rand*256+(256**3).rand*256**2+(256**4)....

[13:43] <diakopter> wait.

[13:43] *** fgomez left
[13:44] <colomon> no, 256.rand + 256.rand * 256 + 256.ran * 65536 ...

[13:44] <masak> right.

[13:44] <diakopter> yeah that

[13:44] <diakopter> :D

[13:44] <moritz> if you just add them, you create a normal distribution

[13:44] <GlitchMr> $int.rand is ugly for me

[13:45] *** Pleiades` joined
[13:45] <masak> GlitchMr: don't do that, then.

[13:45] <GlitchMr> Shouldn't it be (^256).pick or something

[13:45] *** cognominal left
[13:45] <masak> that works, too.

[13:45] <GlitchMr> Oh, .rand returns floating point

[13:45] *** cognominal joined
[13:46] <masak> oh, right.

[13:47] <moritz> hm

[13:47] <moritz> libtommath has an mp_rand function

[13:47] <moritz> which I can use to make arbitrary large random numbers

[13:47] <moritz> but only in digit-size resolution

[13:47] <moritz> and digit is 48 bit on 64bit systems

[13:49] *** Pleiades` left
[13:52] <moritz> now I have to come up with a clever algorithm to create a bigint <= a given one

[13:54] *** Pleiades` joined
[13:57] <colomon> knuth?

[13:59] <moritz> worth checking I guess :-)

[14:00] <GlitchMr> perl6: my $a = {}; $a<a> = $a; $a.perl.say;

[14:00] <p6eval> rakudo f39ec7, niecza v21-19-g8e3a364: OUTPUT«(timeout)»

[14:12] <masak> GlitchMr: I believe we have an old RT ticket about that one.

[14:13] <masak> GlitchMr: what would you prefer it print, ooc?

[14:14] <moritz> it could print do { my $a = { }; $<a> = $a }

[14:14] <masak> aye; it could do that.

[14:15] <masak> though the $a would more likely be $anon_ref_001 or something.

[14:19] <moritz> $VAR1

[14:19] <GlitchMr> If anything, it's $a<a>

[14:19] <GlitchMr> Not $<a> which is $/<a>

[14:19] <moritz> well yes

[14:20] <GlitchMr> perl6: $_ = 1, 2, 3, 4; .[1].print

[14:21] <p6eval> niecza v21-20-g27543db: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1301 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[14:21] <p6eval> ..rakudo f39ec7: OUTPUT«Index out of range. Is: 1, should be in 0..0␤  in method Str at src/gen/CORE.setting:9871␤  in method print at src/gen/CORE.setting:7379␤  in sub print at src/gen/CORE.setting:7189␤  in method print at src/gen/CORE.setting:759␤  in block  at /tmp/iq57PQ7M8s:1␤␤»…

[14:21] <GlitchMr> It works with parens. Am I doing something incorrectly?

[14:21] <moritz> only if you expect it to print 2

[14:22] <GlitchMr> perl6: $_ = (1, 2, 3, 4); .[1].print

[14:22] <p6eval> rakudo f39ec7, niecza v21-20-g27543db: OUTPUT«2»

[14:22] <moritz> GlitchMr: http://doc.perl6.org/language/operators#Item+Assignment+Precedence

[14:22] <GlitchMr> what the

[14:22] <GlitchMr> = precedence varies?

[14:22] <GlitchMr> what

[14:23] <moritz> GlitchMr: I do recommend that you start reading the synopsis if you want to learn Perl 6

[14:24] *** xinming_ left
[14:26] <GlitchMr> So, I should do that?

[14:26] <GlitchMr> duckduckgo.com/?q=!perl+S03

[14:26] *** xinming joined
[14:27] <GlitchMr> std: 2 but 3 but 4

[14:27] <p6eval> std 77327a4: OUTPUT«===SORRY!===␤"but" and "but" are non-associative and require parens at /tmp/CdCvSN0fNg line 1:␤------> 2 but 3 but ⏏4␤Check failed␤FAILED 00:00 42m␤»

[14:27] <GlitchMr> What if I want to make something like 3 but 'string' but False

[14:29] <GlitchMr> Why 'but' is non-associative anyways?

[14:30] <colomon> std: (2 but 3) but 4

[14:30] <p6eval> std 77327a4: OUTPUT«ok 00:00 43m␤»

[14:31] <GlitchMr> I know that I can use parens, but why?

[14:31] <GlitchMr> 3 but 'string' but False sort of makes sense

[14:34] <diakopter> colomon: I updated the gist again with the vastly improved pick

[14:34] <spacebat_> hmm, rakudo star doesn't seem to have a STD module, and 2012.08 doesn't like the STD.pm from github

[14:35] <diakopter> rakudo can't handle STD yet

[14:36] <spacebat_> is there a nice way to get rakudo to parse some perl6 source and give the parse tree

[14:38] <spacebat_> well, I want to use rakudo to support an emacs mode for perl6

[14:38] <diakopter> afaik, your best bet is to use STD+viv

[14:38] <diakopter> (not rakudo)

[14:38] <diakopter> it can output a parse tree

[14:39] <diakopter> in yaml

[14:39] <spacebat_> ah, sounds promising

[14:39] <spacebat_> not sure what STD+viv is though

[14:39] <diakopter> TimToady has updated it recently

[14:39] <diakopter> https://github.com/perl6/std

[14:39] <GlitchMr> for own own of own own then own own

[14:39] <GlitchMr> CoffeeScript :-)

[14:40] <diakopter> spacebat_: I'll be glad to help you get viv running

[14:40] <spacebat_> I just cloned that, will look in to how to use it

[14:40] <diakopter> read the whole README first to get the general idea

[14:41] <diakopter> viv by default compiles to p5, but it can also output yaml

[14:41] <spacebat_> cool

[14:42] <diakopter> spacebat_: how experienced are you at writing syntax highlighters for emacs?

[14:42] *** not_gerd joined
[14:42] <diakopter> (curious)

[14:42] <spacebat_> not really at all

[14:42] <spacebat_> I've fiddled with the emacs lisp regexes of a few modes

[14:43] <not_gerd> hello, #perl6

[14:43] <spacebat_> tried the cperl6-mode branch but don't like it

[14:43] <spacebat_> I kindof know my way around emacs lisp though

[14:44] <diakopter> I hope you have fun learning/trying stuff

[14:44] <spacebat_> figure that emacs lisp isn't what you want to be parsing perl with

[14:44] <spacebat_> better to parse perl5/6 with perl/PPI/STD

[14:45] <diakopter> pugs and mp6 (kp6?) compiled to some lisp at some point(s)

[14:45] <spacebat_> yeah nice

[14:46] <diakopter> masak: I can't remember - did you include v6/mp6/kp6 in your history of p6 summary blog post?

[14:46] <spacebat_> but I like the idea of having a perl subprocess that parses the file and sends back the structure needed for highlighting

[14:47] <diakopter> it'll be huge

[14:47] <diakopter> even for "small" programs

[14:47] <not_gerd> perlito has a Lisp backend as well  no idea how complete that is, though...

[14:48] <diakopter> perlito grew out of mp6/kp6 iirc

[14:49] <spacebat_> I figure if padre can do it, emacs can use similar machinery in a subprocess

[14:54] * not_gerd needs help writing grammars

[14:54] <not_gerd> how do I factor tokens expression and squares of https://gist.github.com/3766337 so I  won't get infinite recursion?

[14:55] *** zby_home joined
[15:00] <diakopter> I think you'll want to use a postcircumfix there

[15:03] <diakopter> actually,

[15:04] * moritz doesn't see where the infinite recursion comes from

[15:04] <diakopter> I'd put the '[' <list> ']' in its own rule as "square tail" then refer to it in expression

[15:04] <diakopter> with a * on it

[15:04] <diakopter> <square_tail>*

[15:05] <diakopter> (and if you need to add more kinds of tails, put them all in one right_tail rule as alternations)

[15:05] *** mucker left
[15:06] *** mucker joined
[15:06] <moritz> oh, it's left recursion

[15:06] <diakopter> then expression will be more complex, but it has all it needs right there - you'll just need to be careful to construct the ast properly in expression's action rule

[15:07] <diakopter> not_gerd: you see what I'm saying? remove <expression> from squares, rename squares to squares_tail, put the 3 match options in <expression> in an alternation, followed by <squares_tail>*

[15:08] <moritz> token expression { [<atom> | <parens> ] <postfix>?`}

[15:08] <moritz> token postfix { '[' <list> ']' }

[15:08] <moritz> something like that

[15:08] <diakopter> that's what I said.

[15:08] <diakopter> (twice)

[15:09] <not_gerd> diakopter, moritz: thanks, I got it

[15:10] *** zby_home left
[15:10] *** zby_home_ joined
[15:10] <diakopter> moritz must have ignored me

[15:13] <moritz> diakopter: no, I haven't

[15:13] <moritz> diakopter: I just put it into code

[15:13] <moritz> diakopter: you did too, but not as concise maybe

[15:14] <diakopter> oh

[15:15] *** sivoais left
[15:16] <dalek> Perlito: f9a20c8 | (Flavio S. Glock)++ | t5/01-perlito/17-hash-autovivify.t:

[15:16] <dalek> Perlito: Perlito5 - add autovivification test

[15:16] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/f9a20c82bb

[15:19] *** flightrecorder left
[15:21] *** FROGGS left
[15:21] *** Gothmog_ left
[15:21] *** Gothmog_ joined
[15:27] *** sivoais joined
[15:34] *** Celelibi joined
[15:44] *** raiph joined
[15:48] *** wamba left
[15:50] <raiph> moritz: re *IN.get: http://irclog.perlgeek.de/perl6/2012-09-19#i_6002246

[15:50] <phenny> raiph: 06:09Z <moritz> tell raiph thanks, fixed

[15:51] <moritz> raiph: thanks

[15:59] *** kaare_ left
[16:00] *** kaare_ joined
[16:00] *** wamba joined
[16:06] *** yarp_ joined
[16:09] *** yarp left
[16:09] *** yarp_ is now known as yarp

[16:11] *** mucker left
[16:17] <raiph> moritz: more re *IN.get: concluding at http://irclog.perlgeek.de/perl6/2012-09-19#i_6002337

[16:19] <raiph> (er, well, properly golfed at rather than concluding at; discussion continues after that line)

[16:20] *** Circlepuller_ joined
[16:21] <Ulti> is there any libraries for IRC knocking around for Rakudo?

[16:22] *** Circlepuller left
[16:22] *** yarp left
[16:24] <timotimo> GlitchMr: re your panda blogpost: in zsh, you'd put stuff like $PATH in .zshenv, no?

[16:26] <not_gerd> Ulti: according to http://modules.perl6.org/ , there's IRC::Utils and Net::IRC::Bot, but they might have bitrotten

[16:31] <GlitchMr> timotimo: hmmm... possibly

[16:31] <GlitchMr> I haven't used zsh

[16:31] <GlitchMr> I'm using my totally incompatible with anything shell

[16:31] <timotimo> hm, not so sure about putting the panda and perl6 path in front of all others.

[16:32] <GlitchMr> Why not?

[16:32] <GlitchMr> This way you can avoid system's Perl 6

[16:32] <GlitchMr> Let me guess, the only reason is performance?

[16:32] <GlitchMr> Isn't this optimized anyways?

[16:34] <timotimo> hm, i read that in some article some time

[16:34] <timotimo> but it *may* have been just an argument against having . in the path

[16:34] <masak> this thought seems to pop up everywhere nowadays: https://twitter.com/richhickey/status/249545807718670336

[16:34] <GlitchMr> Well, `.` in PATH couldn't be optimized

[16:34] <masak> something like Make Everything Lexically Scoped.

[16:35] <GlitchMr> But otherwise, it could store stuff in hash tables and use inotify to know when some PATH directory updates

[16:35] <timotimo> the argument was more about security and unexpected things though, but it's been too long now.

[16:35] <GlitchMr> I wouldn't ever put . to PATH

[16:35] <timotimo> neither would I, nor the author of that article, if i remember that correctly

[16:36] <GlitchMr> But, I would like to see actual benchmarks. Weren't hash tables O(log n)?

[16:37] <GlitchMr> Oh, wait, they weren't

[16:37] <GlitchMr> It's... average of O(1 + n / k)

[16:37] <timotimo> supposed to be constant time

[16:37] <timotimo> access, that is.

[16:37] <GlitchMr> What was "k" anyways?

[16:37] <GlitchMr> https://en.wikipedia.org/wiki/Hash_table

[16:37] <timotimo> probably number of buckets

[16:37] <GlitchMr> According to Wikipedia, it isn't

[16:38] <GlitchMr> There is reason why Perl 5 randomizes hash order

[16:39] <dalek> rakudo/nom: e015e40 | moritz++ | / (5 files):

[16:39] <dalek> rakudo/nom: remove LAZY, which has long been deprecated

[16:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e015e40f73

[16:39] <timotimo> languages should always select a random hash function from a global family (is that what they're called) anyway!

[16:42] <timotimo> ah, universal hash families is what they're called

[16:42] *** integral left
[16:42] <dalek> nqp: 8ae6f20 | moritz++ | src/ (2 files):

[16:42] <dalek> nqp: implement bigint rand op

[16:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8ae6f20892

[16:43] <GlitchMr> Of course, it doesn't have to be actually hash table

[16:44] <GlitchMr> It could be some alternative approach such as https://en.wikipedia.org/wiki/Judy_array

[16:44] *** thou joined
[16:44] <GlitchMr> I don't know what bash actually does, but caching would make sense

[16:45] <colomon> rn: say (10 ** 1000).ln * 2

[16:45] <p6eval> rakudo f39ec7: OUTPUT«No such method 'ln' for invocant of type 'Int'␤  in block  at /tmp/B3r75KPSwO:1␤␤»

[16:45] <p6eval> ..niecza v21-20-g27543db: OUTPUT«Inf␤»

[16:45] <colomon> rn: say (10 ** 1000).log * 2

[16:45] <p6eval> rakudo f39ec7, niecza v21-20-g27543db: OUTPUT«Inf␤»

[16:45] <colomon> not a glorious showing here!

[16:45] <moritz> I know :(

[16:46] <GlitchMr> Hmmm... I actually wonder what is actual performance of PATH in bash

[16:46] *** whiteknight joined
[16:47] <GlitchMr> perl -e'print join ":", ("/bin", "/usr/bin") x 10000'

[16:47] <GlitchMr> Perhaps...

[16:47] <GlitchMr> I meant

[16:47] <GlitchMr> export PATH=$(perl -e'print join ":", ("/bin", "/usr/bin") x 10000')

[16:47] *** tgt left
[16:49] <GlitchMr> The answer being:

[16:49] <GlitchMr> glitchmr@feather ~> perl

[16:49] <GlitchMr> -bash: /usr/bin/perl: Argument list too long

[16:49] <GlitchMr> wow - very long ENV could cause failures to run applications - makes sense

[16:50] <moritz> garbage in, garbage out :-)

[16:51] <GlitchMr> Anyways, with 2000 paths in PATH

[16:51] <GlitchMr> glitchmr@feather ~> time q 

[16:51] <GlitchMr> -bash: q: command not found

[16:51] <GlitchMr> real    0m0.012s

[16:51] *** thou left
[16:51] <GlitchMr> With 0 paths in PATH

[16:51] <GlitchMr> glitchmr@feather ~> time q

[16:51] <GlitchMr> -bash: q: command not found

[16:51] <GlitchMr> real    0m0.012s

[16:51] <GlitchMr> wait...

[16:52] <GlitchMr> I CAN STILL RUN python WITH 0 PATHS?

[16:52] <GlitchMr> What?

[16:52] <GlitchMr> glitchmr@feather ~> time q

[16:52] <GlitchMr> -bash: q: No such file or directory

[16:52] <GlitchMr> real    0m0.004s

[16:52] <GlitchMr> Ok, real stats

[16:53] <GlitchMr> (before you will ask why time works - it's shell builtin)

[16:54] *** felipe left
[16:54] <GlitchMr> It's probably builtin so it could be used to time shell piping

[16:55] <moritz> does 'time' includes the search in $PATH?

[16:55] <GlitchMr> Well, it looks like it does

[16:55] <GlitchMr> It was slower with 2000 paths

[16:57] <GlitchMr> But I ran tests with CAKE variable instead of PATH and I don't have any slowdown

[16:57] <Ulti> thanks not_gerd 

[16:57] *** birdwindupbird left
[16:57] <GlitchMr> 0.01s is rather fast

[16:58] <GlitchMr> But when running multiple programs or running loops...

[16:58] <GlitchMr> Probably not really

[16:58] <moritz> iirc $PATH lookups are cached anyway

[16:59] *** integral joined
[16:59] *** integral left
[16:59] *** integral joined
[16:59] <GlitchMr> I'm almost sure it's just hash performance

[16:59] <GlitchMr> Hashes aren't O(1) in accessing performance

[16:59] <Ulti> not_gerd: Net::IRC::Bot had an update two months ago so might be good

[17:00] <GlitchMr> I could think of O(1) algorithms, except that algorithm is so wasteful that you would need Turing machine to run it or something

[17:00] <GlitchMr> those*

[17:00] <GlitchMr> are*

[17:00] <GlitchMr> them*

[17:01] <GlitchMr> I have found something - http://lwn.net/Articles/419826/

[17:01] *** thou joined
[17:07] <Ulti> awesome   panda install Net::IRC::Bot   and my do nothing bot works :)

[17:08] <masak> cool.

[17:09] <not_gerd> bye, #perl6

[17:09] *** not_gerd left
[17:10] <Ulti> I'm writing a bot which tracks emotional content of what people are saying and keeps a score of how negative/positive they are and how negative and positive they are to other users

[17:11] *** thou left
[17:11] <moritz> sounds quite interesting

[17:14] <Ulti> there is a nice blob of open data where someone hand annotated the emotional impact of a couple of thousand words from Twitter posts

[17:15] <arnsholt> How are you resolving sentiment?

[17:15] <arnsholt> SVM classifier or something?

[17:15] <Ulti> just looking up the word content in a dictionary and summing the scores from the database

[17:15] <Ulti> heh no

[17:15] <Ulti> nothing complicated

[17:15] <arnsholt> Right. You'll probably want a negation resolver for that approach though

[17:15] <Ulti> so a word like "bastard" has a -5 score and something like "amazing" would be +5

[17:16] <arnsholt> Right, that one

[17:16] <arnsholt> A friend of mine used that to evaluate the negation resolution system he did for his master's thesis

[17:16] <moritz> and what would "not bad" give?

[17:16] <Ulti> at the moment the score of bad ;)

[17:16] <arnsholt> That's the tricky part =)

[17:17] <Ulti> but check for not prefixed isn't that hard

[17:17] <moritz> .oO( nothing wrong with that)

[17:17] <Ulti> just invert the sign on the score if not is prefixed

[17:17] <arnsholt> So what my friend did was this: sum scores of all words, negated words have changed sign

[17:17] <arnsholt> Ah, but negation usually has longer scope than a single token =)

[17:17] <Ulti> moritz this is just a fun bot ;P

[17:18] <moritz> Ulti: yes, I figured :-)

[17:18] <arnsholt> His results showed that for positive sentiment, negation resolution didn't help the system a lot, but for negative sentiment it helped quite a bit

[17:18] <masak> moritz: I read your "sounds quite interesting" above and immediately saw the autopun potential in that ;)

[17:18] <Ulti> I already have a markov parody generator that will swap out the next word generated from a thesaurus based on altering emotional content, it works quite well

[17:18] <Ulti> arnsholt interesting

[17:19] *** leprevost_ joined
[17:19] <Ulti> but yeah short of a perfect English grammar engine I'm not going to be able to do a great job

[17:19] <arnsholt> In his data set it looked like positive sentiment was almost always expressed with positive words, but for negative it was quite common to see things like "this isn't a very good movie"

[17:19] <Ulti> also noun use compared with adjective use makes a big difference

[17:19] *** leprevost left
[17:20] <arnsholt> Nah, don't need a perfect parser =)

[17:20] <arnsholt> He used a relatively straightforward approach

[17:20] <Ulti> using negative words to describe something is more negative than just a noun which could be negative

[17:21] <masak> so, "that amazing bastard" would have a score of exactly 0? :P

[17:21] <Ulti> http://neuro.imm.dtu.dk/wiki/AFINN  <-- the data if anyone wants some fun

[17:21] <Ulti> masak: yeah something like that

[17:22] <Ulti> clearly the scoring function is going to be key, might be better to average and just go with whatever has the majority

[17:22] <masak> Ulti: that reminds me of someone who tried to find the extremes of hapiness scoring in (I think) The Simms.

[17:22] <Ulti> so if amazing is only +1 or something but bastard is -5 its probably reasonably negative even if its said in a nice way

[17:23] <Ulti> masak: lol

[17:23] <masak> Ulti: they concluded that the highest happiness score was becoming a father, and that it was exactly canceled out by being on fire four times.

[17:23] <masak> I wish I remembered the URL for that.

[17:24] <Ulti> hahaha I bet a real world study would be similar

[17:24] <masak> :P

[17:24] <moritz> "highest happiness score was becoming a father" -- I can confirm that :-)

[17:24] <masak> but not the 4x-on-fire thing, I hope.

[17:25] <moritz> I've never tried that part, and don't intend to

[17:25] <Ulti> http://mattoates.co.uk/work/parody.php <-- the thing I already have using some stolen data I could get into trouble for having

[17:26] <Ulti> moritz: I bet being a father of a teen will adjust for the happiness without being on fire

[17:26] <Ulti> or worse your teenager sets you on fire

[17:29] <mst> I think I only set other teenagers on fire

[17:29] <Ulti> I mostly blew things up with the minimum of fire

[17:31] <tadzik> good evening

[17:37] <moritz> \o tadzik 

[17:37] <raiph> o/ tadzik

[17:38] <dalek> rakudo/nom: 59dd40f | moritz++ | / (2 files):

[17:38] <dalek> rakudo/nom: make Int.rand return a random Int if the invocant is too big to become a Num

[17:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/59dd40fa6b

[17:44] *** dalek joined
[17:44] *** ChanServ sets mode: +v dalek

[17:49] <colomon> moritz: how does nqp::rand_I work?

[17:49] <colomon> afk # 4yo chasing....

[17:53] <moritz> colomon: see https://github.com/perl6/nqp/commit/8ae6f20892

[17:55] <colomon> ?errr.... if you use mod like that, won't you get an uneven distribution?  Or am I missing something here

[17:55] <colomon> ?

[17:56] <moritz> colomon: it won't be perfectly uniform

[17:57] <colomon> probably better than returning Inf...

[17:57] <moritz> colomon: but note that the length of the random number is 1 digit longer than the modulus

[17:57] <moritz> colomon: and 1 digit is 48bit on 64bit systems

[17:57] <colomon> oh

[17:58] <colomon> that does seem relatively harmless

[17:58] <moritz> so the relative non-uniformity is limited to 2**-48

[17:58] <moritz> and maybe 2**-20 on 32bit platforms

[18:00] <moritz> I didn't bother coming up with a faster and/or more precise algorithm

[18:03] *** leprevost_ left
[18:06] <moritz> oh, it seems I've broken something with that patch

[18:07] *** leont left
[18:11] * colomon is trying to figure out how libtommath does it, with no luck so far.

[18:12] <moritz> how it does what?

[18:13] <dalek> rakudo/nom: 7d6aa02 | moritz++ | / (2 files):

[18:13] <dalek> rakudo/nom: Revert "make Int.rand return a random Int if the invocant is too big to become a Num"

[18:13] <dalek> rakudo/nom: 

[18:13] <dalek> rakudo/nom: This reverts commit 59dd40fa6b6eec1688e2b8a1f4a35cdad7d50e64.

[18:13] <dalek> rakudo/nom: It broke stuff, even though I thought I had tested it. Back to the debugging

[18:13] <dalek> rakudo/nom: board.

[18:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d6aa02cf8

[18:15] *** tgt joined
[18:20] <masak> the debugging board looks like a drawing-board, but it has more hexdigits on it :)

[18:20] <moritz> correct

[18:21] <colomon> moritz: how it does the random numbers for mp_prime_miller_rabin

[18:21] <moritz> no idea on that one

[18:25] <sorear> good * #perl6

[18:26] <colomon> o/

[18:26] *** whiteknight left
[18:31] <sorear> colomon: according to TimToady++, libtommath cheats and uses its internal list of the first 256 primes as "sufficiently random" numbers for miller-rabin

[18:31] <colomon> oh

[18:31] <sorear> moritz: are you still interested in cleverer approaches for uniform random bigints?

[18:31] <sorear> timotimo: Niecza uses universal hashing :D

[18:31] <colomon> sorear: I certainly am interested in cleverer approaches.

[18:32] <moritz> sorear: yesish :-)

[18:33] <timotimo> as it should, i'd say.

[18:34] * colomon likes the idea of slipshod probabilistic algorithms even less than he likes the idea of probabilistic algorithms

[18:39] *** fgomez joined
[18:41] <diakopter> don't you hate it when you've been debugging code for an hour, and then you finally realize you're the one who wrote it?

[18:41] <dalek> roast: b093af3 | (Solomon Foster)++ | S32-num/log.t:

[18:41] <dalek> roast: Add test for the log of a very large Int.

[18:41] <dalek> roast: review: https://github.com/perl6/roast/commit/b093af3ee1

[18:41] <colomon> diakopter: indeed, that's a terrible, terrible feeling.

[18:42] *** fgomez left
[18:42] <dalek> niecza: 6287229 | (Solomon Foster)++ | lib/Builtins.cs:

[18:42] <dalek> niecza: Add BigInteger handling in ln.

[18:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/628722912a

[18:42] * moritz doesn't really want to write a bigint log algorithm

[18:43] <colomon> it's good for the soul!

[18:43] * colomon actually just used BigInteger.Log

[18:43] <sorear> colomon: (Fat)Rat log ....

[18:44] <colomon> sorear: yeah, that's clearly needed too.

[18:44] <moritz> well, I guess I'll just implement log2

[18:44] <colomon> but one baby step at a time.

[18:44] * masak .oO( log2 is all you need )

[18:44] <sorear> depending on how many ulps you want bigint log is not so hard, just cut off all the low-order digits, turn the top 53 bits into a double, and pass it off to FLOG

[18:45] <moritz> masak: I know

[18:45] <masak> I suspected you knew ;)

[18:45] <moritz> my idea is simply shift off digits until the result can be packed into a double

[18:45] <sorear> FLOGP1 if you're feeling perverse

[18:45] * colomon has just been ordered to read Paddle-to-the-Sea

[18:46] * moritz just finished his reading duty and put the small one to bed

[18:46] *** leprevost_ joined
[18:48] <sorear> colomon: where did you get the magic numbers in https://github.com/sorear/niecza/commit/27543db1f12b43fd6581bd05af27678dbf69adce ?

[18:49] *** birdwindupbird joined
[18:49] <sorear> moritz: actually what I was going to propose diakopter++ beat me to.

[18:50] *** kaare_ left
[18:50] <sorear> moritz: round up to the nearest power of 2, pick random numbers that are less than that power of 2 (easy to do with a random bit source), redo; if > $limit

[18:50] <sorear> expected iteration count will clearly not exceed 2

[18:50] *** fgomez joined
[18:51] <sorear> expected iteration count can be made arbitrarily close to 1 by changing the round-up rule

[18:51] *** Su-Shee_ is now known as Su-Shee

[18:51] <moritz> sorear: sounds sensible

[18:52] *** felipe joined
[18:52] <moritz> (though strictly speaking it's not an algorithm, becaues it's not guarantueed to terminate :-)

[18:57] *** Chillance joined
[19:02] *** Circlepuller joined
[19:03] *** fgomez left
[19:03] *** fgomez joined
[19:04] *** benabik left
[19:04] *** benabik joined
[19:04] *** Circlepuller_ left
[19:05] <cognominal> hum, forgot how to test a missing optional argument versus undefined

[19:06] <cognominal> S06: You may check whether an optional parameter was bound to anything by calling C<VAR($param).defined>.

[19:06] <masak> I don't think that ever worked in any implementation.

[19:06] <masak> a perhaps more important question is: what makes you care? :)

[19:06] <MikeFair_> colomon: In what context? Sounds like it ought to get initialized by something if not provided

[19:07] <MikeFair_> s/colomon/cognominal

[19:07] <MikeFair_> :)

[19:07] <masak> cognominal: you could set the default to a unique object that can never be passed in from the outside.

[19:08] <MikeFair_> cognominal: or perhaps it's your function/equation that needs to actually initialize it to a default if it is undefined (in which case the success of undefined is a missing optional parameter)

[19:08] <masak> r: class A {}; constant DEFAULT = A.new; sub foo($param = DEFAULT) { say $param === DEFAULT ?? "wasn't passed" !! "was passed" }; foo(); foo(A.new)

[19:08] <p6eval> rakudo 59dd40: OUTPUT«wasn't passed␤was passed␤»

[19:08] <masak> cognominal: ^

[19:09] <cognominal> it came in the context of an article I write. To explain the setter/getter generated for a public attribute.

[19:10] <cognominal> missing optionnal argument means getter

[19:11] <cognominal> interesting that the terms getter and setter don't appear in S12

[19:11] <cognominal> but accessor is there

[19:15] <cognominal> r: sub a($v?) { say VAR($v).defined }  a 1

[19:15] <p6eval> rakudo 7d6aa0: OUTPUT«===SORRY!===␤Confused␤at /tmp/otD8lMBymY:1␤»

[19:15] <cognominal> r: sub a($v?) { say VAR($v).defined };  a 1

[19:15] <p6eval> rakudo 7d6aa0: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&VAR' called (line 1)␤»

[19:16] <cognominal> r: sub a($v?) { say $v.VAR.defined };  a 1

[19:16] <p6eval> rakudo 7d6aa0: OUTPUT«True␤»

[19:16] <colomon> sorear: https://en.wikipedia.org/wiki/Miller%E2%80%93Rabin_primality_test

[19:16] <cognominal> r: sub a($v?) { say $v.VAR.defined };  a 

[19:16] <p6eval> rakudo 7d6aa0: OUTPUT«False␤»

[19:17] <cognominal> so it is there alright but as method macro, not as a function macro.

[19:20] <masak> cognominal: the terms getter/setter aren't in S12, because that's not what they are, really.

[19:20] <masak> cognominal: notice that actual setting of the value is done with '='

[19:21] <cognominal> if I get things right, the setter/getter implicitely generated for a rw attribute C<$.attr> is  equivalent to :   method attr($v?) {  $v.VAR.defined ?? $.attr = $v !! $.attr  }

[19:21] <sorear> colomon: what about it

[19:21] <colomon> sorear: that's where the magic numbers came from.

[19:22] <sorear> oh!

[19:22] <sorear> thanks.

[19:22] * colomon hopes wikipedia knows what it is talking about.

[19:22] <cognominal> masak: the setting with = is another way or the only way?

[19:22] <diakopter> colomon: I got my prime program to test primality at roughly 30,000 very large bigints/second

[19:23] <colomon> diakopter: define very large?

[19:23] <diakopter> 50 decimal digits. I guess not enormous.

[19:23] <cognominal> S12:  Public attributes have a secondary sigil of "dot", indicating the automatic generation of an accessor method of the same name"

[19:23] <masak> cognominal: hm, you can always manually create setters that take an argument. but I haven't seen people do this, and I wouldn't consider it advisable or idiomatic.

[19:24] <diakopter> afk a while &

[19:24] <cognominal> I wonder where I have picked that...

[19:25] <masak> r: class A { has $!x; multi method x() { $!x }; multi method x($new_val) { $!x = $new_val } }; given A.new { .x(42); say .x() }

[19:25] <p6eval> rakudo 7d6aa0: OUTPUT«42␤»

[19:25] <masak> do not do this :)

[19:25] <jnthn> The accessor just returns the attribute. If you say "is rw", then it doesn't decontainerize it, which means that any scalar container remains and the assignment just works.

[19:25] <cognominal> I was talking about generated accessors

[19:25] <masak> cognominal: I know you were.

[19:25] <masak> cognominal: but you seemed to be under the impression that they worked as above.

[19:26] <jnthn> Right, the above is how geneated ones work :)

[19:26] <sorear> diakopter: post-TWIRL, I'd say we want 200 or 300 digit primes for RSA

[19:26] *** MikeFair_ left
[19:31] *** fgomez left
[19:32] *** leprevost_ left
[19:36] <diakopter> sorear: I was wrong about the 50 digits

[19:36] <diakopter> that's how long the winning prefix is

[19:37] <diakopter> I'm instrumenting now to find out an average size per base

[19:37] * masak learns about TWIRL

[19:37] <masak> I like hypothetical hardware devices :)

[19:38] <diakopter> sorear: also, the point of the program is not to generate primes. it's to run TimToady's test

[19:44] *** birdwindupbird left
[19:44] <diakopter> hm; maybe 50 was too high.

[19:44] <diakopter> well no

[19:44] *** fgomez joined
[19:46] *** birdwindupbird joined
[19:50] *** FROGGS joined
[19:51] *** flightrecorder joined
[20:02] *** GlitchMr left
[20:11] <diakopter> phenny: tell TimToady interestingly, stems of even and odd lengths alternate between 1x and 4x rate of primality testing

[20:11] <phenny> diakopter: I'll pass that on when TimToady is around.

[20:13] <TimToady> bases also tend to alternate, due to baked in primes

[20:13] <phenny> TimToady: 20:11Z <diakopter> tell TimToady interestingly, stems of even and odd lengths alternate between 1x and 4x rate of primality testing

[20:13] *** bruges_ left
[20:13] * TimToady figgered out how to tether to my phone...

[20:13] <TimToady> *his

[20:15] *** bruges joined
[20:18] <colomon> TimToady: is there a reason you didn't use 2 * n.ln ** 2 as the upper bound for a in your Miller-Rabin?

[20:19] <sorear> masak: yes, TWIRL is one of my all-time favorite papers :D

[20:19] <sorear> colomon: 2 * n.ln ** 2 is for the deterministic but GRH-conditional Miller test

[20:21] <colomon> sorear: ah

[20:38] *** MikeFair_ joined
[20:52] <masak> sorear: only read the Wikipedia article so far. but then I'll read the paper, too.

[21:05] *** zby_home_ left
[21:08] *** raiph left
[21:19] <diakopter> TimToady: my fast run is almost caught up to my less fast run at 1.5m on the base 18 downslope

[21:20] <diakopter> 4cores++

[21:20] <diakopter> my poor Thinkpad fan...

[21:22] *** cognominal left
[21:24] *** cognominal joined
[21:27] *** cognominal_ joined
[21:29] *** cognominal left
[21:37] *** cognominal_ left
[21:41] *** mtk joined
[21:46] *** cognominal_ joined
[21:52] *** birdwindupbird left
[22:18] *** cognominal_ left
[22:26] *** cognominal joined
[22:27] *** MayDaniel left
[22:33] *** tgt left
[22:38] <diakopter> TimToady: how far has any of your runs gotten? finished base 18?

[22:39] *** flightrecorder left
[22:39] *** cognominal_ joined
[22:39] *** flightrecorder joined
[22:41] *** cognominal left
[22:52] *** spider-mario left
[22:52] *** cognominal_ left
[22:57] *** leont joined
[23:02] *** Circlepuller_ joined
[23:04] *** Circlepuller left
[23:10] *** MikeFair_ left
[23:28] *** doy left
[23:28] *** revdiablo joined
[23:29] *** doy joined
[23:38] *** Guest29702 joined
[23:38] *** raiph joined
[23:38] <raiph> phenny, tell pmichaud fyi: https://gist.github.com/3768134

[23:38] <phenny> raiph: I'll pass that on when pmichaud is around.

[23:41] *** PacoAir left
[23:46] *** kid51 joined
[23:47] *** onski joined
[23:48] <onski> nr: 'a, b, c and d' ~~ /\w ** ', '/ and say ~$/

[23:48] <p6eval> niecza v21-21-g6287229: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** ', ' as separator; nowadays please use atom+ % ', ' at /tmp/qnvZImduaw line 1:␤------> 'a, b, c and d' ~~ /\w ** ', '⏏/ and say ~$/␤␤a, b, c␤»

[23:48] <p6eval> ..rakudo 7d6aa0: OUTPUT«===SORRY!===␤Quantifier quantifies nothing at line 2, near " ', '/ and"␤»

[23:49] <onski> nr: 'a, b, c and d' ~~ /\w % ', '/ and say ~$/

[23:49] <p6eval> niecza v21-21-g6287229: OUTPUT«===SORRY!===␤␤Unrecognized regex metacharacter % (must be quoted to match literally) at /tmp/lY2bedDSxL line 1:␤------> 'a, b, c and d' ~~ /\w %⏏ ', '/ and say ~$/␤␤Unable to parse regex; couldn't find final '/' at /tmp…

[23:49] <p6eval> ..rakudo 7d6aa0: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix / instead␤at /tmp/9AqigSvliB:1␤»

[23:50] <onski> nr: 'a, b, c and d' ~~ /\w +% ', '/ and say ~$/

[23:50] <p6eval> rakudo 7d6aa0, niecza v21-21-g6287229: OUTPUT«a, b, c␤»

[23:51] <onski> nr: 'a, b, c and d' ~~ /\w + % ', '/ and say ~$/

[23:51] <p6eval> rakudo 7d6aa0, niecza v21-21-g6287229: OUTPUT«a, b, c␤»

[23:51] *** wamba left
[23:52] *** flightrecorder left
[23:52] *** FROGGS left
[23:54] <onski> nr: 'a, b, c and d' ~~ /\w + % [,\s]/ and say ~$/

[23:54] <p6eval> rakudo 7d6aa0: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter , (must be quoted to match literally) at line 2, near "\\s]/ and s"␤»

[23:54] <p6eval> ..niecza v21-21-g6287229: OUTPUT«===SORRY!===␤␤Unrecognized regex metacharacter , (must be quoted to match literally) at /tmp/FucmZNVxD5 line 1:␤------> 'a, b, c and d' ~~ /\w + % [,⏏\s]/ and say ~$/␤␤Unhandled exception: Unable to resolve method ast i…

[23:55] <onski> nr: 'a, b, c and d' ~~ /\w +% [\,\s]/ and say ~$/

[23:55] <p6eval> rakudo 7d6aa0, niecza v21-21-g6287229: OUTPUT«a, b, c␤»

[23:56] <sorear> welcome, onski

[23:56] <onski> good morning! sorear.

[23:59] <onski> nr: say 'nr++ !'

[23:59] <p6eval> rakudo 7d6aa0, niecza v21-21-g6287229: OUTPUT«nr++ !␤»

[23:59] *** onski left
