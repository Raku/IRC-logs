[00:01] *** popl joined
[00:03] *** lawrmcfa left
[00:23] *** dayangkun joined
[00:30] *** fgomez joined
[00:38] *** thou left
[00:44] *** hash_table left
[00:53] *** hash_table joined
[01:06] *** hypolin joined
[01:11] *** anuby joined
[01:16] *** dayangkun left
[01:22] <[Coke]> lessee, no test.

[01:47] *** hash_table left
[01:50] *** raiph left
[01:50] *** hash_table joined
[01:58] *** MikeFair left
[02:01] <[Coke]> phenny: tell supernovus I tried to write a test that this passed and rakudo failed, and failed. Can you add a test to the ticket or to roast?

[02:01] <phenny> [Coke]: I'll pass that on when supernovus is around.

[02:04] *** MikeFair joined
[02:16] *** cognominal left
[02:19] *** tokuhiro_ left
[02:23] <dalek> roast: a7ab785 | coke++ | S02-types/nan.t:

[02:23] <dalek> roast: Add a test for rakudo RT #103500

[02:23] <dalek> roast: review: https://github.com/perl6/roast/commit/a7ab78548e

[02:27] <[Coke]> phenny: ask pmichaud if we can close https://rt.perl.org/rt3/Ticket/Display.html?id=68854

[02:27] <phenny> [Coke]: I'll pass that on when pmichaud is around.

[02:36] *** fgomez left
[02:37] *** leprevost joined
[02:38] *** orafu left
[02:39] *** orafu joined
[02:40] *** lawrmcfa joined
[02:51] <[Coke]> std: my @a = 1, 2, 3, given 42; say @a

[02:51] <p6eval> std 77327a4: OUTPUT«ok 00:00 44m␤»

[02:52] <masak> rn: say given 42

[02:52] <p6eval> niecza v22-7-g7df6137: OUTPUT«===SORRY!===␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/jSlezIXNSc line 1:␤------> say⏏ given 42␤␤Unhandled exception: Check failed␤␤  at /h…

[02:52] <p6eval> ..rakudo f0aced: OUTPUT«␤»

[02:52] <masak> rn: say 1, 2, 3, given 42

[02:52] <p6eval> niecza v22-7-g7df6137: OUTPUT«123␤»

[02:52] <p6eval> ..rakudo f0aced: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&given' called (line 1)␤»

[02:53] <masak> heh.

[02:53] <masak> diferent parsers indeed.

[02:55] <sorear> r: say

[02:55] <p6eval> rakudo f0aced: OUTPUT«␤»

[02:56] <sorear> r: print

[02:56] <p6eval> rakudo f0aced:  ( no output )

[02:56] <sorear> nr: my $niecza = !try eval 'print'; say $niecza

[02:56] <p6eval> rakudo f0aced: OUTPUT«False␤»

[02:56] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«True␤»

[02:57] <[Coke]> nqp: True.HOW.say

[02:57] <p6eval> nqp: OUTPUT«Method 'say' not found for invocant of class 'NQPClassHOW'␤current instr.: '' pc 92 ((file unknown):165529781) (/tmp/XyNZxhccTb:1)␤»

[02:57] <sorear> p: my $niecza = !try eval 'print'; say $niecza

[02:57] <p6eval> pugs: OUTPUT«*** Cannot cast from VBool True to VCode (VCode)␤    at /tmp/NH_AY3vMLR line 1, column 9-31␤»

[02:57] *** fgomez joined
[02:57] <TimToady> p: try 42

[02:57] <sorear> p: print

[02:57] <p6eval> pugs: OUTPUT«*** Cannot cast from VInt 42 to VCode (VCode)␤    at /tmp/EMn54408k8 line 1, column 1 - line 2, column 1␤»

[02:57] <p6eval> pugs:  ( no output )

[02:57] <TimToady> pugs doesn't have statement form of try

[02:58] *** skids left
[02:58] <[Coke]> r: True.HOW.say

[02:58] <p6eval> rakudo f0aced: OUTPUT«Null PMC access in get_bool()␤  in attributes at src/stage2/gen/nqp-mo.pm:1151␤  in method perl at src/gen/CORE.setting:791␤  in method gist at src/gen/CORE.setting:786␤  in sub say at src/gen/CORE.setting:7250␤  in method say at src/gen/CORE.setting:781␤  in block…

[02:58] <[Coke]> n: True.HOW.say

[02:58] <p6eval> niecza v22-7-g7df6137: OUTPUT«ClassHOW.new(...)␤»

[02:59] <[Coke]> RT--

[03:03] <[Coke]> RT: 640 open tickets, 80 blocking on tests.

[03:08] *** raiph joined
[03:08] <raiph> hi all

[03:11] <sorear> yo

[03:12] <TimToady> yo²

[03:13] <raiph> what about: parse the irclog. pull out lines beginning nr:, std: etc., plus maybe bits inside {} on a line, parse it using a Perl 6 syntax parser, and link bits to doc.perl6.org/whatever?

[03:14] <raiph> (or have the eval bots annotate the irc log file, but that seems wrongish to me)

[03:17] <diakopter> irc is logged in a database

[03:19] <raiph> diakopter: right. a Perl 5 script constructs a day's worth view, and search results, and annotates it a bit, linking things like S01. I see all these evals, and responses, and think

[03:20] <raiph> .oO( Wouldn't it be cool if I could click on that keyword? Wonder what more there is to say about this error? )

[03:21] <raiph> Invite beginners to learn on channel. The channel log becomes an anarchist tutorial farm. That might suck after a while, but would be a great problem to have.

[03:24] <raiph> Especially in combination with doing daily log summaries (as is now happening, with relative ease).

[03:25] *** lawrmcfa left
[03:33] *** fridim_ joined
[03:42] <raiph> Hmm. It could be you have to view the relatively lightweight (10% of full?) summary page to see those links.

[03:46] <raiph> (Lightweight also reflects my guess that few folk currently use the summary view, so server load is light.)  

[04:11] *** thou joined
[04:22] *** leprevost left
[04:23] *** fridim_ left
[04:26] *** telex left
[04:31] *** kaleem joined
[04:35] *** cognominal joined
[04:39] *** telex joined
[04:49] *** cognominal left
[05:04] *** kevouze joined
[05:07] *** lawrmcfa joined
[05:10] *** raiph left
[05:11] <kevouze> Hi. Anyone keen to help out for a survey about newcomer experience in the Perl community?

[05:11] <kevouze> http://blogs.perl.org/users/kevin_carillo/2012/10/newcomer-experience-and-contributor-behavior-in-perl-and-other-foss-communities---survey.html

[05:12] <kevouze> It would interesting be able compare Perl6 practices with other perl projects. You just need to have joined Perl within the last 2 years.

[05:20] *** birdwindupbird joined
[05:20] <moritz> I'm afraid I can't serve with that trait

[05:23] <kevouze> no problem, thanks.for considering to help out.

[05:24] *** GlitchMr joined
[05:25] <sorear> kevouze: I joined p6 in feb 10, not good enough?

[05:27] <kevouze> yes, all good!

[05:30] *** popl left
[05:37] *** SamuraiJack joined
[05:59] *** simcop2387 left
[06:01] *** simcop2387 joined
[06:10] *** wamba joined
[06:12] *** hash_table left
[06:15] *** wamba left
[06:35] <dalek> rakudo/nom: 584f19e | jnthn++ | src/Perl6/Actions.pm:

[06:35] <dalek> rakudo/nom: Optimize double-quoted string literals in regexes.

[06:35] <dalek> rakudo/nom: 

[06:35] <dalek> rakudo/nom: Those can just emit a literal node, not go through !LITERAL.

[06:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/584f19ef63

[06:36] *** wamba joined
[06:40] <jnthn> phenny: tell colomon 584f19e may help a little too; feel free to mail me an updated profile if you want me to dig some more

[06:40] <phenny> jnthn: I'll pass that on when colomon is around.

[06:40] * jnthn commutes

[06:43] *** kurahaupo left
[06:48] *** aharoni joined
[07:02] *** brrt joined
[07:07] *** mucker joined
[07:10] *** xinming joined
[07:10] *** GlitchMr left
[07:13] *** xinming_ left
[07:18] *** kevouze left
[07:18] *** flightrecorder joined
[07:23] *** FROGGS joined
[07:30] *** orafu left
[07:36] *** hoelzro|away is now known as hoelzro

[07:41] *** wamba left
[07:56] <Woodi> morning everyone :)

[07:57] <brrt> \o woodi

[07:57] *** mucker left
[07:57] *** mucker joined
[07:58] *** integral left
[07:58] <sorear> o/

[08:00] *** Su-Shee_ joined
[08:00] *** Su-Shee left
[08:01] *** Su-Shee_ is now known as Su-Shee

[08:01] *** integral joined
[08:01] *** integral left
[08:01] *** integral joined
[08:01] <Woodi> I got some futuristic probably idea :) : there is libpcre (in C) but maybe/probably one day someone will want libpgram[mar] in C... this cycle can be avoided - a) having faster grammar engine as lib in C can be performance improvement and b) it can bring World closer to Perl6 :)

[08:02] <brrt> in short, you want to port p6 grammar to c?

[08:02] <brrt> more power to you

[08:02] *** fhelmberger joined
[08:02] <brrt> its quite another thing to say rakudo will use it, rather than their current version

[08:02] <brrt> but sure

[08:02] <Woodi> brrt: I want have it :)

[08:03] <sorear> Woodi: I can't tell whether you're arguing for or against p6grammars in C

[08:03] <Woodi> sorear: of course I want p6 grammar engine in C in lib form usable in other projects...

[08:04] <brrt> i personally think it is not a /really/ bad idea

[08:04] <sorear> I agree

[08:04] <sorear> sleep&

[08:04] <brrt> well, you can also help fix parrot, then other languages can run on parrot and use the grammar engine too

[08:04] <brrt> bye soreer

[08:04] <brrt> sorear

[08:06] <Woodi> but someone can tell me how to call C macros from NativeCall ? and how "struct timeval *timeout" should be called on v6 side ?

[08:07] <brrt> c macros can't be 'called' as such

[08:07] <brrt> they are translated by the compiler into textual c source code

[08:07] <brrt> they do not exist at runtime

[08:08] <Woodi> brrt: ok for details :) but lots of libraries use macros, how to use it ?

[08:09] *** odoacre joined
[08:09] <brrt> Woodi: basically, I imagine you have some struct

[08:09] <brrt> and then your library has LIBFOO_QUIX(x) defined

[08:09] <brrt> which gets some values from the struct, right

[08:10] <brrt> ?

[08:10] <Woodi> do not know exactly :) 

[08:12] *** wamba joined
[08:13] *** mucker left
[08:14] *** mucker joined
[08:18] <Woodi> makro is simple: #define VERSION3   3  :)  but I must pack it into  const void *invalue....

[08:19] <brrt> if it is stored anywhere in an exported symbol, you should be able to access it, i do not know if NativeCall exposes that functionality however

[08:19] <brrt> otherwise, you might get away with reading the header files

[08:20] <brrt> i'd even say, if you could make a header-file-reader to work together with NativeCall, that would be usefull

[08:20] <Woodi> I read it myself and trying to complet single v6 view :)

[08:21] <Woodi> and how  char *attrs[] should be named in NativeCall language ? 

[08:22] <brrt> i do not know that :-) i'm sorry

[08:22] <brrt> i'm pretty sure its possible though

[08:25] <Woodi> no problem :) i hear there are still problems with some parts of "translation" :)

[08:26] * brrt has used parrot nci, rather than NativeCall

[08:26] <brrt> NativeCall is considerably more powerful, though

[08:28] <Woodi> I wonder how it works... if it do not tucg gcc or something then what to do with macros ? write some intermediate code maybe ?

[08:28] <Woodi> *touch...

[08:29] <FROGGS> Woodi: you could write C-functions that return a numeric #define

[08:30] <FROGGS> Woodi: you really just can "use" macros from within C

[08:31] <jnthn> Aye, macros have no corespondence in the compiled library

[08:31] <FROGGS> think of: #define MAX(a, b)    (a > b ? a : b)

[08:31] <jnthn> So they "don't exist" by the time NativeCall gets it, and there's no symbol to look up and so on.

[08:31] <FROGGS> if you use MAX() somewhere in your C code, it will be replaced by the (a > b ? ...)

[08:32] <jnthn> So, like enums, they need manual translation 

[08:32] <FROGGS> it is really just text replacement in C files, it vanishes when it becomes a lib

[08:32] *** mucker left
[08:32] <jnthn> aye

[08:32] <Woodi> FROGGS: I do not ask how C work :)

[08:32] <FROGGS> thats the point where Inline C might come handy ;o)

[08:33] <FROGGS> Woodi: but you need to know, obviously

[08:33] <Woodi> but is not enough...

[08:34] <Woodi> I need NativeCall *notation* for things...

[08:34] <jnthn> r: macro MAX($a, $b) { quasi { {{{$a}}} > {{{$b}}} ?? {{{$a}}} !! {{{$b}}} } }; say MAX(1, 2)

[08:34] <p6eval> rakudo 584f19: OUTPUT«2␤»

[08:36] <Woodi> I must add I am lazy (or not) here and trying to avoid rewriting all macros in I can found .h files...

[08:36] *** Su-Shee left
[08:37] <FROGGS> Woodi: thats the point where a C-wrapper might come handy, so you just can return the result from C-macro

[08:37] <jnthn> Woodi: Write something that translates header file macros etc into Perl 6 then :P

[08:37] <FROGGS> this wrapper function will then be a symbol you can call using NativeCall

[08:37] <FROGGS> jnthn++

[08:37] <FROGGS> Woodi: I give you 50$ for a working code ;o)

[08:38] <FROGGS> and another 20 bucks for parsing enums right

[08:38] <Woodi> I thinked about automatic and massive .h translation too :)

[08:39] <brrt> woodi: now you have a reason, get at it :-)

[08:39] <FROGGS> well, it might work for some piece of code, but dont expect to get it to work for every header file there is

[08:39] <jnthn> I believe the Parrot folks wrote a fairly advanced C grammar, fwiw.

[08:39] <jnthn> That could be quite stealable.

[08:39] <jnthn> So you don't have to grammar from scratch

[08:40] *** dakkar joined
[08:43] <Woodi> still there is problem how things should be named on NativeCall side. eg. how translation of "char *attrs[]" should look like ? OpaquePointer or OpaquePointer CArray ? and "struct somestruct **sctrls" ?

[08:43] <FROGGS> CArray[OpaquePointer] ?

[08:43] <jnthn> char *attrs[] could be guessed as CArray[Str]

[08:43] <FROGGS> ohh, you are right

[08:43] <Woodi> :)

[08:43] <FROGGS> had no coffee so far

[08:44] * jnthn is at the client with the awesome coffee machine today and is probably drinking enough of it for half the channel...

[08:45] <Woodi> jnthn: what is name of that machine ? :)

[08:45] <jnthn> Hm, not sure... :)

[08:45] <jnthn> I'll ask it when I go for the next cup

[08:49] <brrt> jnthn: isnt that CArray[CStr] or something

[08:49] <brrt> because you don't really have Str objects

[08:50] <jnthn> brrt: It knows what to do with Str

[08:50] <brrt> oh, thats nice

[08:56] <arnsholt> Woodi: Well, that's a problem with C in general, really

[08:57] <arnsholt> char * can be either a string (zero terminated), or a byte array (with arbitrary bytes)

[08:58] <arnsholt> You'll just have to make an arbitrary choice and let the end user figure it out

[09:02] *** wamba left
[09:02] *** wamba joined
[09:02] <jnthn> Yeah, any header to NativeCall code tool will have to be "best guess"

[09:02] <jnthn> Maybe it should have a mode where it adds comments saying "I guessed here, review" or something. :)

[09:03] <arnsholt> Yeah, was just thinking the same thing =)

[09:06] <Woodi> actually I want just a bindings to library to have db connectivity... but wonder how would look C done on top of Perl6 ? :) C grammar can be googled, was probably done by few projects...

[09:08] <Woodi> maybe pointless but maybe unknown unknown is hiding ? :)

[09:09] *** leont joined
[09:16] <brrt> having a c header reader is really useful

[09:21] <Woodi> ok, I have situation like this: function is "int cfunc(*val)" and I must send int so in C I use &intvalue. how '&' looks in NativeCall ? :)

[09:22] <Woodi> I try sending Int but it is too smart with checks :)

[09:23] *** daxim joined
[09:23] <jnthn> Woodi: Best way at the moment is to do CArray[int] and pass it a 1-elem array

[09:24] <Woodi> ook :)

[09:33] *** cognominal joined
[09:45] *** kaleem left
[09:48] <lumi__> r: macro MAX($a, $b) { quasi { my $a := {{{$a}}}; my $b := {{{$b}}}; $a > $b ?? $a !! $b } }; say MAX(1, 2);

[09:48] <p6eval> rakudo 584f19: OUTPUT«2␤»

[09:49] <lumi__> Is that right? The binding thing?

[09:50] <jnthn> yes

[09:50] <lumi__> (Also, yay, macros!)

[09:50] <jnthn> I was just translating teh C macro literally :)

[09:51] <jnthn> masak++ is to thank for those :)

[09:51] <lumi__> jnthn: Oh, OK, there's no way to do it right in C...

[09:51] <jnthn> Still some work to go on them yet

[09:51] <lumi__> masak++

[09:52] <lumi__> jnthn: What's missing? I messed with them a bit in ancient times

[09:52] <jnthn> Making declarations (e.g. subs) inside macros, the COMPILING:: pseudo-package support.

[09:54] *** kaleem joined
[09:54] <jnthn> lunch &

[09:54] *** Psyche^ joined
[09:57] *** kaleem left
[09:57] *** Patterner left
[09:57] *** Psyche^ is now known as Patterner

[10:01] *** brrt left
[10:02] *** kaleem joined
[10:05] *** hypolin left
[10:08] *** anuby left
[10:16] *** wamba left
[10:16] *** wamba joined
[10:24] *** wk left
[10:26] *** aharoni left
[10:37] *** mucker joined
[10:51] *** kaleem left
[10:54] *** kaleem joined
[11:09] *** leont left
[11:19] <grondilu> btw has anyone been writing a C grammar in Perl6?

[11:24] *** wamba left
[11:24] <moritz> there's an incomplete C grammar in NQP in the parrot repo

[11:24] <moritz> for parsing the .ops files

[11:25] *** wamba joined
[11:26] *** am0c joined
[11:31] <grondilu> ok I'll have a look.

[11:41] *** wamba left
[11:41] *** wamba joined
[11:42] *** shlomif joined
[11:42] *** shlomif is now known as rindolf

[11:53] <colomon> jnthn++: that shaved another 20s off the running time.

[11:53] <phenny> colomon: 06:40Z <jnthn> tell colomon 584f19e may help a little too; feel free to mail me an updated profile if you want me to dig some more

[11:53] <colomon> jnthn: I'll get you an updated profile ASAP

[12:00] <colomon> jnthn: e-mailed.

[12:05] <jnthn> colomon: I am tied up with $client for the next couple of hours anyway 

[12:05] <jnthn> colomon: How long is it taking now?

[12:08] <colomon> jnthn: on the linux box, 3m47s

[12:08] *** rhr left
[12:09] *** _jaldhar left
[12:09] <jnthn> colomon: What did all the .s you added win?

[12:09] <jnthn> Did that help with memory also?

[12:10] <colomon> The .s got me 45s or so.  I haven't checked memory usage.

[12:11] <jnthn> OK, so we need to win another 47s to have halved the runtime... :)

[12:11] *** am0c left
[12:12] <colomon> r: say (5*60+52)/2

[12:12] *** orafu joined
[12:12] <p6eval> rakudo 584f19: OUTPUT«176␤»

[12:13] <colomon> yes.  :)

[12:16] <jnthn> There may be a win from making the to/from in the match object native ints.

[12:16] <jnthn> That's how NQP has it.

[12:25] <flussence> ooh, regex speedups?

[12:25] <jnthn> flussence: combination of Rakudo improvements and colomon++ tweaking his grammar :)

[12:28] <colomon> sorear suggested adding :: to places where LTM might be causing issues.  dunno if that will help rakudo performance or only niecza performance....

[12:29] *** wamba left
[12:29] *** wamba joined
[12:31] <moritz> I don't think rakudo implements ::

[12:31] <moritz> r: /a :: b/

[12:31] <p6eval> rakudo 584f19: OUTPUT«===SORRY!===␤:: not yet implemented at line 2, near " b/"␤»

[12:33] <jnthn> Evaluating the NFA didn't seem to be unusually expensive in the profile, fwiw.

[12:34] <jnthn> Turning that bit alternation I mentioned into a char class may help but probably only a little.

[12:35] *** gootle left
[12:40] <colomon> jnthn: token special, you mean?  I was under the impression that '!' | '"' | '*' versus <[ ! " * ]> was just a notational convenience...

[12:41] <jnthn> colomon: They compile rather differently.

[12:42] <moritz> in the end they have the same semantics, but rakudo still does LTM for the | case

[12:42] <jnthn> Right

[12:42] <colomon> guess I can give that a try.  was mostly avoiding it because I thought it would make for too long a line.  :)

[12:42] <colomon> but probably have to do a preschool dropoff first.  

[12:42] <jnthn> Who said you have to put the char class all one one line? :)

[12:43] <colomon> ooooooo

[12:44] <moritz> old p5 think, I think

[12:45] *** tokuhiro_ joined
[12:45] <jnthn> r: say "ooh look spaces count" ~~ m:P5/ooh look/

[12:45] <p6eval> rakudo 584f19: OUTPUT«｢ooh look｣␤␤»

[12:45] <jnthn> :)

[12:48] *** killbot left
[12:51] *** rindolf left
[12:51] <jnthn> BTW, if some enterprising soul wants a relatively easy P5Regex task, implement \A and \Z and stuff :)

[12:51] *** wamba left
[12:52] <jnthn> (there's a load of tests for it)

[12:52] *** wamba joined
[12:54] <moritz> \A is just the same as ^ in Perl 6 regex

[12:54] * moritz takes a look

[12:55] *** zipf joined
[12:55] <arnsholt> \A and ^ are different under /m (or was it /s?) though

[12:56] <moritz> \A is always the same

[12:56] <moritz> ^ depends on /m

[12:56] *** zipf left
[12:56] <arnsholt> Right, that.

[12:57] <jnthn> Yeah, I already did the m-varying ^ semantics I think

[12:58] <moritz> \z is also easy

[12:58] <moritz> \Z is a bit more tricky

[12:58] <moritz> \Z is \n?\z

[12:58] <jnthn> Because \n semantics?

[12:58] <jnthn> Oh, but $ does that too and I did $ already

[12:58] <jnthn> so you can nab that :)

[12:59] <moritz> do I need to put that in p5backaslash:sym<A> etc?

[13:00] <jnthn> yes, you'll need something in the grammar and an action method

[13:01] *** flightrecorder left
[13:01] *** killbot joined
[13:01] *** hash_table joined
[13:01] *** FROGGS left
[13:02] * moritz tries

[13:07] *** rindolf joined
[13:13] *** PacoAir joined
[13:19] *** wamba left
[13:23] *** flightrecorder joined
[13:23] *** FROGGS joined
[13:23] *** GlitchMr joined
[13:24] <colomon> is <[ ! " * ]> the same as <[ !"* ]> ?

[13:29] <jnthn> Yes

[13:29] <jnthn> It matches \s* as meaningless between things in the char class

[13:30] <jnthn> Thus why multiple lines are also fine :)

[13:31] <colomon> "Unsupported use of - as character range"

[13:31] <colomon> how do I escape that?

[13:31] <colomon> (in <[  ]>

[13:32] <jnthn> \-

[13:32] <colomon> now I get "regex assertion not terminated by angle bracket"

[13:32] <colomon> that's with token special { <[ !"*$%&.#+,\-()?/:;<=>@[]{|}^`~ ]> }

[13:33] <jnthn> Need to escape the ] in there too

[13:33] <colomon> and now it works!  jnthn++

[13:33] <jnthn> .oO( but will it be faster... )

[13:34] <colomon> jnthn: running my tests first, to make sure it's still correct.  ;)

[13:35] *** bluescreen10 joined
[13:35] *** hash_table left
[13:39] <colomon> which it is!  \o/

[13:41] <colomon> timing...

[13:43] *** cognominal left
[13:44] *** Pleiades` left
[13:47] *** wamba joined
[13:51] *** Pleiades` joined
[13:59] <[Coke]> <spongebob>3 hours later</spongebob>

[14:00] <colomon> whoops!  got sidetracked.  (checks) no performance improvement at all with that change.  can't say I'm wildly surprised by that.

[14:01] <jnthn> Tells us that alternations are relatively cheap I guess :)

[14:01] <colomon> well, I don't know that they're called all that often on a regular file.

[14:02] <colomon> according to the last profile I did before this, the time taken in special is trivial

[14:03] <jnthn> ah, ok

[14:03] <colomon> 12% of the execution time is in <ws>? 

[14:03] <jnthn> Wow

[14:03] *** cognominal joined
[14:03] <jnthn> Sounds plausible though

[14:04] <jnthn> Do you have a custom ws?

[14:04] <jnthn> Or is this the default one?

[14:04] <jnthn> If the default one then there's certainly room for some improvement...

[14:05] <colomon> That's the default one, and I never even call it explicitly.

[14:05] <colomon> must be in the rules, I guess?

[14:06] <jnthn> Yes

[14:06] <jnthn> That's surprisingly pricey.

[14:06] *** stopbit joined
[14:11] *** dayangkun joined
[14:12] *** dayangkun left
[14:13] *** kaare__ joined
[14:14] *** birdwind1pbird joined
[14:16] *** aharoni joined
[14:17] *** Pleiades` left
[14:19] *** Pleiades` joined
[14:23] *** tokuhiro_ left
[14:26] <colomon> jnthn: I'm looking at token untyped_parameter { '$' | <real> | <integer> | <string> 

[14:26] <colomon>                             | <entity_instance_name> | <enumeration> | <binary> | <list_of_parameters> }

[14:26] <colomon> at the moment.

[14:27] <colomon> would there be value to using || instead of | here?

[14:27] <colomon> (would it even work in Rakudo?)

[14:28] <jnthn> That's likely to make it slower.

[14:29] <arnsholt> At a guess, || would make it slower than |

[14:29] <jnthn> || tries things one by one

[14:29] <arnsholt> Yeah, what jnthn said

[14:29] <arnsholt> With | you get LTM to find the right branch

[14:29] <jnthn> | tries them "in parallel" using an NFA

[14:29] <jnthn> And it can trim out impossible ones without having to call the subrules.

[14:30] <colomon> would reordering them make any difference, given that?

[14:30] *** lawrmcfa left
[14:30] <jnthn> No

[14:31] <jnthn> It's || where re-ordering would help

[14:31] <colomon> then the overall set of parameter tokens/rules may qualify as "surprisingly slow"

[14:31] <colomon> hard to say, because they are called a LOT

[14:32] *** cognominal left
[14:38] *** kaleem left
[14:38] *** Shozan joined
[14:40] *** rjbs- joined
[14:40] *** avarab joined
[14:40] *** avarab left
[14:40] *** avarab joined
[14:41] *** literal_ joined
[14:41] *** estrai_ joined
[14:41] *** ranguard_ joined
[14:44] *** Pleiades` left
[14:44] *** crazed- joined
[14:45] *** SHODAN left
[14:45] *** estrai left
[14:45] *** Khisanth left
[14:45] *** ranguard left
[14:45] *** rjbs left
[14:45] *** literal left
[14:45] *** avar left
[14:45] *** crazedpsyc left
[14:45] *** crazed- is now known as crazedpsyc

[14:46] *** hash_table joined
[14:51] <[Coke]> rjbs++

[14:51] *** zby_home_ joined
[14:52] * rjbs- is saving up his karma for IRC, The Home Game.

[14:53] *** Khisanth joined
[14:55] *** rhr joined
[14:57] *** Pleiades` joined
[15:02] <jnthn> decommute &

[15:02] *** skids joined
[15:04] <TimToady> the new sigspace policy minimizes the number of calls to <ws>; don't think rakudo implements that yet...

[15:04] <TimToady> (the new policy only calls <ws> if something else matched first, basically)

[15:06] <TimToady> oh, and you should be able to cut down LTM analysis with {}, which also stops the token like ::

[15:07] <TimToady> it just doesn't change the backtracking rule, if there happens to be degrees of freedom in the token's regex

[15:07] <TimToady> which there usually isn't, at least in parsing a language

[15:07] <TimToady> data files might be a different story

[15:12] <colomon> Is that just {} or do you mean wrapping things in {  } brackets?

[15:13] * colomon fears he is behind the curve in grammar comprehension.... 

[15:18] *** birdwind1pbird left
[15:18] *** MayDaniel joined
[15:19] <lumi__> colomon: I think he means that just having a block breaks LTM even if it's empty

[15:23] <colomon> lumi__: that's what I'm thinking too, but I'd like to make sure I'm not going astray.  

[15:39] <jnthn> An empty block would do it

[15:39] <jnthn> But as I said, Rakudo doesn't seem to be suffering much on the LTM front.

[15:41] <colomon> jnthn: sure, but if it provides drastic improvements for Niecza performance without hurting Rakudo performance, that would be worthwhile

[15:44] <jnthn> I'll probably slow Rakudo down a bit since it doesn't optimize away empty blocks.

[15:45] <perigrin> *It'll ... otherwise ... jnthn is a meenie ... punnishing poor rakudo for not optimizing away empty blocks.

[15:46] <jnthn> er, yes :D

[15:47] <jnthn> I should do that optimization at some point. I seem to recall that last time I tried it didn't work out for some reason.

[15:47] *** fgomez left
[15:48] <jnthn> colomon: Hm, in the latest profile you sent me it seems ws is only 6.5%, but you mentioned 12% earlier.

[15:50] <colomon> :(

[15:50] <colomon> will try to sort it out in a minute.

[15:51] <jnthn> Wow, that initial .subst got way cheaper

[15:52] *** rindolf left
[16:00] *** fgomez joined
[16:04] *** hoelzro is now known as hoelzro|away

[16:13] <dalek> rakudo/nom: fb0b115 | jnthn++ | src/core/ (2 files):

[16:13] <dalek> rakudo/nom: Use native ints for Match $!to/$!from.

[16:13] <dalek> rakudo/nom: 

[16:13] <dalek> rakudo/nom: This will certainly save a good amount of memory, but it also saves the

[16:13] <dalek> rakudo/nom: MATCH method from having to do two object boxings too. Of course, we do

[16:13] <dalek> rakudo/nom: them later in some cases, but I suspect this will be an overall win.

[16:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb0b115205

[16:14] <grondilu> Test Summary Report

[16:14] <grondilu> -------------------

[16:14] <grondilu> t/spec/S32-io/IO-Socket-INET.t                          (Wstat: 0 Tests: 16 Failed: 2) Failed tests:  6, 9

[16:14] <grondilu> Files=701, Tests=25653, 7101 wallclock secs (19.85 usr  2.67 sys + 6578.06 cusr 156.14 csys = 6756.72 CPU)

[16:14] <grondilu> Result: FAIL

[16:15] <jnthn> colomon: Maybe fb0b115 helps a bit.

[16:15] <colomon> jnthn: will check!

[16:18] *** cognominal joined
[16:19] * colomon will also get back to paying his taxes, as that is on a deadline of sorts.

[16:24] *** brrt joined
[16:27] *** fglock joined
[16:28] <colomon> jnthn: 11 seconds gone, not bad!

[16:28] <colomon> I've started a new profile run.

[16:32] *** SamuraiJack left
[16:36] *** Celelibi left
[16:39] *** Celelibi joined
[16:40] *** SamuraiJack joined
[16:48] *** mucker left
[16:52] *** cognominal left
[16:53] *** dakkar left
[16:54] *** fgomez left
[16:55] *** spider-mario joined
[16:57] *** cognominal joined
[16:59] *** bluescreen10 left
[17:03] *** fgomez joined
[17:04] *** brrt left
[17:07] *** leont joined
[17:10] *** birdwindupbird left
[17:34] *** brrt joined
[17:35] *** lawrmcfa joined
[17:38] <felher> r: my Int @array = 1,2,3; say @array eqv [1,2,3]

[17:38] <p6eval> rakudo fb0b11: OUTPUT«False␤»

[17:39] <felher> Is it expected behaviour that the Type-Information of that array makes eqv return false?

[17:40] <moritz> yes

[17:41] <moritz> nr: say 1.0 eqv 1

[17:41] <p6eval> rakudo fb0b11, niecza v22-7-g7df6137: OUTPUT«False␤»

[17:41] <moritz> same case

[17:42] *** integral left
[17:46] <felher> I see. Whats the nicest way to get what i wanted, then? [&&] @array Xeqv [1,2,3]? Or Array.new(@array) eqv [1,2,3]?

[17:46] <felher> (i know that for 1,2,3 i could use ==) :)

[17:47] <felher> (X== that is)

[17:48] <jnthn> Zeqv more likely

[17:48] <felher> jnthn: yeah, of course :)

[17:48] <jnthn> And all

[17:48] <felher> all @array Zeav [1,2,3]?

[17:49] <jnthn> r: my Int @a = 1,2,3; say all [1,2,3] eqv @a

[17:49] <p6eval> rakudo fb0b11: OUTPUT«all(False)␤»

[17:49] <jnthn> r: my Int @a = 1,2,3; say all([1,2,3] eqv @a)

[17:49] <p6eval> rakudo fb0b11: OUTPUT«all(False)␤»

[17:49] <jnthn> grr

[17:49] <jnthn> r: my Int @a = 1,2,3; say all([1,2,3] Zeqv @a)

[17:49] <p6eval> rakudo fb0b11: OUTPUT«all(True, True, True)␤»

[17:49] <jnthn> r: my Int @a = 1,2,3; say so all [1,2,3] Zeqv @a 

[17:49] <p6eval> rakudo fb0b11: OUTPUT«True␤»

[17:49] <jnthn> There we go :)

[17:49] <jnthn> r: my Int @a = 1,2,4; say so all [1,2,3] Zeqv @a 

[17:49] <p6eval> rakudo fb0b11: OUTPUT«False␤»

[17:50] <felher> jnthn: yeah, that looks kinda nice. Thanks :)

[17:51] *** leont left
[17:54] *** brrt left
[17:59] *** integral joined
[17:59] *** integral left
[17:59] *** integral joined
[18:01] *** brrt joined
[18:01] <moritz> (off topic) does anybody know of a generalization of the Nested Sets model to store arbitrary DAGs (and not just trees) in SQL?

[18:09] <PerlJam> .oO( How can that possibly be off topic *here*? )

[18:18] *** _edwin joined
[18:21] *** integral left
[18:21] *** japhb_ joined
[18:22] <japhb_> jnthn, can any of the optimizations you've been making to improve colomon++'s parsing use case be applied to NQP, so its parsing will be faster as well?

[18:23] <sorear> good * #perl6

[18:23] <moritz> I'm pretty sure that NQP already uses native ints for match attributes

[18:23] *** kaare__ is now known as kaare_

[18:23] * _edwin filed https://rt.perl.org/rt3/Ticket/Display.html?id=115212

[18:24] *** fhelmberger left
[18:24] <japhb_> moritz, he's done a couple more too ... double-quote literal handling, method cache authority ...

[18:25] <japhb_> But given what you said, I now wonder how many NQP optimizations can be moved over to Rakudo.  ;-)

[18:26] <brrt> moritz: I do not know, but i'm very interested

[18:28] * brrt is actually really close to giving up on the whole #perl6 thing

[18:30] <moritz> brrt: may I ask why?

[18:30] *** integral joined
[18:30] *** integral left
[18:30] *** integral joined
[18:31] <brrt> "Positional arguments implicitly come in via the @_ array, but unlike in Perl 5 they are readonly aliases to actual arguments:"

[18:31] <brrt> honestly, why?

[18:31] <sorear> THAT is why you're leaving?

[18:32] <sorear> also, I think that document is out of date, @_ isn't used at all unless you mention it now

[18:32] <moritz> brrt: because most modifications of arguments are unintended

[18:32] <doy> and all existing implementations do read-only copies, as nicholas clark pointed out

[18:32] <brrt> i'm not leaving, i'm nearly turning mad

[18:33] <brrt> well, why can't they just be copies then?

[18:34] <moritz> because copies of big stuff can be expensive

[18:34] <moritz> and there's the question of how deeply/shallow you copy

[18:34] <moritz> and so on

[18:35] <brrt> fine; i'm not suggesting php4 deep-copy-on-write (that was hilarious madness that hurt so bad)

[18:35] <brrt> but shallow pointer copy is pretty much what you'd 'want', isn't it?

[18:36] <PerlJam> brrt: not me.

[18:36] <brrt> why not, why isn't that enough

[18:36] <PerlJam> unintended second order effects

[18:37] *** daxim left
[18:38] <jnthn> japhb_: NQP already has the method cache authority thing for a long while, I'd just not gotten around to porting it over to Rakudo. 

[18:38] <japhb_> jnthn, ah so

[18:38] <brrt> PerlJam: please explain :-)

[18:39] <japhb_> jnthn, I was wondering a few weeks ago how often optimizations only make it into NQP or Rakudo but not both (when they make sense in both) ... and now I have my answer.  ;-)

[18:39] <jnthn> japhb_: And it's double-quoted strings in regexes don't actually allow interpolation or anything that would preclude literals.

[18:39] <dalek> roast: 920c5be | (Edwin Steiner)++ | S14-roles/stubs.t:

[18:39] <dalek> roast: Add test for RT #115212: [BUG] accessor method does not count as implementation of required method.

[18:39] <dalek> roast: review: https://github.com/perl6/roast/commit/920c5be01d

[18:39] <dalek> roast: 7673df5 | (Edwin Steiner)++ | S0 (10 files):

[18:39] <dalek> roast: Merge branch 'master' of github.com:perl6/roast

[18:39] <dalek> roast: review: https://github.com/perl6/roast/commit/7673df5901

[18:39] <PerlJam> brrt: I wouldn't want to accidentally affect a change in the caller's environment because I made a change to a parameter passed to my subroutine.

[18:40] <jnthn> japhb_: Well, NQP doesn't yet have an optimizer :)

[18:40] <japhb_> There's a biggie.  ;-)

[18:40] <jnthn> japhb_: So there's some fun to be had there too :)

[18:41] * japhb_ is looking forward to that improvement, as he is currently back to working on his benchmarking tool and thus seeing just how slow some things are.

[18:41] <brrt> PerlJam: which doesn't happen if you copy pointers to the subroutine enviroment

[18:42] *** integral left
[18:42] *** integral joined
[18:42] *** integral left
[18:42] *** integral joined
[18:42] <japhb_> .oO( awfy.perl6.org )

[18:44] <brrt> wait.

[18:44] <brrt> i'm fearing i'm misunderstanding the issue here

[18:44] *** rindolf joined
[18:45] <sorear> brrt: there are reasons why I often wonder if perl6 is a good idea, and that @_ thing is never one of them

[18:45] <japhb_> D'oh!  Ran the benchmark for several minutes only to discover I'd forgotten to send the timing data to a file.  BAH.

[18:45] <brrt> p6: sub foo(*@a is rw) { @a[0,1] = @a[1,0] }; my ($a, $b) = 0, 1; foo($a, $b); say $a;

[18:45] <p6eval> niecza v22-7-g7df6137: OUTPUT«1␤»

[18:45] <p6eval> ..rakudo fb0b11: OUTPUT«0␤»

[18:45] <brrt> ok, which one is right

[18:47] <sorear> brrt: in the real world, you'd never use @_, always rw parameters

[18:47] <sorear> p6: sub foo($x is rw, $y is rw) { ($x,$y) = ($y,$x) }; my ($a,$b) = 0,1; foo($a,$b); say $a

[18:47] <p6eval> rakudo fb0b11, niecza v22-7-g7df6137: OUTPUT«1␤»

[18:48] <brrt> so, niecza got it right

[18:48] <brrt> right

[18:49] <jnthn> Does the spec say one way or the other?

[18:49] <brrt> the spec suggests niecza's behavior

[18:49] <jnthn> Reference?

[18:49] <brrt> which i find maddening but is apparantly the correct behavior

[18:49] <jnthn> I think Rakudo pays no attention at all to "is rw" in a slurpy, fwiw...

[18:49] <jnthn> Unless Pm implemented it to do so and I didn't notice. :)

[18:50] <brrt> s06, Note: the rw container trait is automatically distributed  to the individual elements by the slurpy star even though there is no  actual array or hash passed in. More precisely, the slurpy star means  the declared formal parameter is not considered readonly; only its elements are. See "Parameters and arguments" below.

[18:50] <brrt> sorry for copying, btw

[18:52] *** spider-mario left
[18:52] <jnthn> ah, ok

[18:52] <jnthn> Yeah, Rakudo probably should pay attention to the "is rw" there then and do something different.

[18:53] <diakopter> p6: sub foo(*%a is rw) { say %a{'a'}; %a{'a'} = 2; say %a{'a'} }; my $a = 4; foo(|{'a' => $a}); say $a;

[18:53] <p6eval> rakudo fb0b11, niecza v22-7-g7df6137: OUTPUT«4␤2␤4␤»

[18:53] <brrt> and, that doesn't make you very nearly insane? this meant in a non-inflammatory matter, by the way

[18:54] <diakopter> brrt: one tends to get accustomeed to glaring inconsistence. also non-inflammatory.

[18:54] <diakopter> *around here

[18:54] <jnthn> brrt: huh, I've worked on Rakudo since about December 2007, I've been insane for ages. :)

[18:55] <brrt> :-) good, i'm not alone, then

[18:56] <jnthn> The glaring inconsistencies are at least better than the subtle, unnoticed ones...

[18:56] <jnthn> I've learend not to worry too much about such things though. They tend to get worked out, as the implementations push for them to be.

[18:58] <sorear> brrt: is rw is pretty much the sanest part of perl 6.  I am baffled by the fact that you seem to have a problem with it

[18:59] <brrt> sorear: my problem,if anything, is that it prohibits a clean separation between caller and callee

[18:59] <PerlJam> brrt: prohibits?!?

[19:00] <brrt> well, yeah, suppose i have a scope containing a, and b, i must effectively pass the location of a and b to a subroutine, not their values

[19:00] <brrt> $a, and $b

[19:00] <jnthn> brrt: I think you're missing a level

[19:00] <grondilu> rn:  constant foo = do given %*ENV<FOO> { when .defined { m:i/^ bar $/  }; default { False } }; say foo;

[19:00] <brrt> because - the way i'm reasoning - the caller cannot know if the callee things its arguments are read-writeable

[19:00] <p6eval> rakudo fb0b11, niecza v22-7-g7df6137: OUTPUT«False␤»

[19:00] <jnthn> my $a = 42;

[19:00] <brrt> yeah, probably

[19:00] <jnthn> Means that the lexpad contains a Scalar which contains 42.

[19:00] <brrt> s/things/thinks/

[19:00] <jnthn> You pass the Scalar.

[19:01] <brrt> .... 

[19:01] <brrt> yes, obviously

[19:02] <grondilu> rn:  constant foo = do given %*ENV<HOME> { when .defined { m:i/^ home $/  }; default { False } }; say foo;

[19:02] <p6eval> niecza v22-7-g7df6137: OUTPUT«False␤»

[19:02] <p6eval> ..rakudo fb0b11: OUTPUT«===SORRY!===␤Cannot assign to a non-container␤»

[19:03] <brrt> so in a weird way you're always pushing pointers, it isn't an exception

[19:04] <jnthn> er...what...

[19:04] <brrt> yeah that wasn't intelligeble

[19:04] <brrt> i mean

[19:04] <jnthn> brrt: That was at Rakudo's response to grondilu's program, not to you! :)

[19:04] <brrt> ok

[19:04] <brrt> (i didn't understand that program either, btw)

[19:05] <brrt> so, youre basically always dealing with a container, and a value

[19:05] *** fgomez left
[19:06] <jnthn> grondilu: I'm, er, confused now because I just ran what you pasted locally and it worked

[19:07] *** fgomez joined
[19:08] *** Playb3yond joined
[19:08] <grondilu> jnthn: is the ENV var defined ?

[19:08] <flussence> jnthn: fails here

[19:08] <diakopter> sorear: my last snippet above - should it behave the same as the *@a ?

[19:08] <grondilu> nr: constant home-is-in-home = %*ENV<HOME>.defined ?? (%*ENV<HOME> ~~ m:i/ home /) !! True;

[19:08] <p6eval> niecza v22-7-g7df6137:  ( no output )

[19:08] <p6eval> ..rakudo fb0b11: OUTPUT«===SORRY!===␤Cannot assign to a non-container␤»

[19:08] <jnthn> grondilu: No

[19:09] <jnthn> oh wait, surely home is...

[19:09] <jnthn> oh, no it's not

[19:09] <jnthn> If I change it to HOMEPATH I get the error

[19:10] <grondilu> it's  rakudo bug, right?

[19:10] <jnthn> Seems like

[19:11] *** nyuszika7h left
[19:12] <grondilu> nr: constant foo = %*ENV<HOME> ~~ /home/;

[19:12] <p6eval> rakudo fb0b11: OUTPUT«===SORRY!===␤Cannot assign to a non-container␤»

[19:12] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1289 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting…

[19:12] <jnthn> nr: constant foo = (%*ENV<HOME> ~~ /home/);

[19:12] <p6eval> rakudo fb0b11: OUTPUT«===SORRY!===␤Cannot assign to a non-container␤»

[19:12] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1289 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 266 (Mu.Str @ 15) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting…

[19:13] <jnthn> nr: constant foo = %*ENV<HOME>.match(/home/);

[19:13] <p6eval> rakudo fb0b11:  ( no output )

[19:13] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«Unhandled exception: Unable to resolve method match in type Any␤  at /tmp/UC83ubgjc2 line 1 (foo init @ 2) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 76 (downcall @ 4) ␤  at /home/p6eval/niecza/src/Ni…

[19:14] <diakopter> jnthn: my last snippet above - should it behave the same as the *@a ?

[19:15] <jnthn> diakopter: afaik 'is rw' does nothing on slurpy hashes either

[19:15] *** Playb3yond left
[19:16] *** SamuraiJack left
[19:16] <grondilu> r: constant foo = %*ENV<HOME>.match(m:i/ home /);

[19:16] <p6eval> rakudo fb0b11: OUTPUT«===SORRY!===␤Method 'match' not found for invocant of class 'Mu'␤»

[19:17] *** Playb3yond joined
[19:17] <jnthn> grondilu: m/.../ matches immediately on $_

[19:18] *** \n joined
[19:18] <grondilu> jnthn: oh, ok

[19:19] <dalek> rakudo/nom: dbf3478 | jnthn++ | src/core/Cursor.pm:

[19:19] <dalek> rakudo/nom: Small optimization to Match construction.

[19:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbf3478bf4

[19:19] <jnthn> So far as I can tell, the thing it fails to assign to is actually $/

[19:23] <Woodi> bbkr: given my understability of problem :) I think I yesterday hit something you can read with this context in mind:  http://en.wikipedia.org/wiki/Mutable_object  and CoW is involved too

[19:25] <jnthn> colomon: Not sure how much dbf3478 will help; it's hard to tell from the benchmark. It *should* make things a bit faster.

[19:25] <colomon>  jnthn++: will time...

[19:26] <jnthn> I'm seeing if I can improve CAPHASH a little also

[19:29] *** fibo joined
[19:35] *** wk joined
[19:38] <colomon> jnthn: looks like that is another 7secs off

[19:38] <jnthn> colomon: What're we at now? :)

[19:38] <colomon> 3.5 min

[19:39] <colomon> so 30 seconds to go for an overall halving of execution time.  :)

[19:40] * jnthn should probably be working on debugger improvements, but hey, optimizing is fun...

[19:40] <flussence> .oO( optimising for the "fail fast" pattern )

[19:46] *** am0c joined
[19:47] *** wk left
[19:50] *** Playb3yond left
[19:54] *** birdwindupbird joined
[20:00] *** brrt left
[20:01] *** fibo left
[20:02] *** fibo joined
[20:02] <moritz> r: sub f() { nqp::substr("foo", 0, 1) }; say f

[20:02] <p6eval> rakudo fb0b11: OUTPUT«f␤»

[20:03] *** GlitchMr left
[20:05] *** fglock left
[20:10] *** wk joined
[20:12] *** avarab is now known as avar

[20:12] *** kaare_ left
[20:12] *** kaare_ joined
[20:18] <_edwin> http://rosettacode.org/wiki/Permutations_by_swapping#Perl_6

[20:19] <cognominal> nqp: say(%*A)

[20:19] <p6eval> nqp: OUTPUT«Hash[0x9e9de88]␤»

[20:20] <cognominal> r: say(%*A)

[20:20] <p6eval> rakudo dbf347: OUTPUT«Dynamic variable name not found␤  in method gist at src/gen/CORE.setting:9934␤  in sub say at src/gen/CORE.setting:7250␤  in block  at /tmp/Tl17ixHqyY:1␤␤»

[20:20] <cognominal> What is the semantic for dynamic variable in NQP?

[20:20] *** birdwindupbird left
[20:21] <moritz> nqp: say($*A)

[20:21] *** literal_ is now known as literal

[20:21] <p6eval> nqp: OUTPUT«␤»

[20:21] <moritz> nqp: say($*A.WHAT)

[20:21] <p6eval> nqp: OUTPUT«␤»

[20:21] <moritz> nqp: say($*A.^name)

[20:21] <p6eval> nqp: OUTPUT«Confused at line 2, near "say($*A.^n"␤current instr.: 'panic' pc 20029 (src/stage2/gen/NQPHLL.pir:7321) (src/stage2/gen/NQPHLL.pm:324)␤»

[20:21] <cognominal> It seems it is autovivied. how to test it has been declared?

[20:21] <moritz> nqp: say($*A.HOW.name($*A))

[20:21] <p6eval> nqp: OUTPUT«NQPMu␤»

[20:23] *** kaare_ left
[20:24] *** arlinius joined
[20:24] <cognominal> nqp: my %*B; say(%*B.HOW.name(%*B))

[20:24] <p6eval> nqp: OUTPUT«Can only use get_how on a SixModelObject␤current instr.: '' pc 151 ((file unknown):79) (/tmp/tBHlIAD6nr:1)␤»

[20:25] <moritz> probably a Parrot Hash

[20:25] <jnthn> yeah, it will be

[20:25] <moritz> nqp: say(nqp::typeof__SP(%*B))

[20:25] <p6eval> nqp: OUTPUT«Error while compiling block : Error while compiling op call: Error while compiling op typeof__SP: No registered operation handler for 'typeof__SP'␤current instr.: '' pc 43434 (src/stage2/QAST.pir:15060) (src/stage2/QAST.nqp:2253)␤»

[20:25] <jnthn> I guess it is auto-viving in some way

[20:25] <jnthn> pir::

[20:26] <moritz> nqp: say(pir::typeof__SP(%*B))

[20:26] <p6eval> nqp: OUTPUT«Hash␤»

[20:26] <cognominal> nqp:  my %*B := Hash.new; say(%*B.HOW.name(%*B))

[20:26] <p6eval> nqp: OUTPUT«NQPMu␤»

[20:28] *** xinming left
[20:29] *** hash_table left
[20:30] *** aharoni left
[20:30] * grondilu made a interface to OpenSSL (so far, only a few digests):  [email@hidden.address]
[20:30] *** kurahaupo joined
[20:30] *** xinming joined
[20:31] <cognominal> jnthn, I am trying to get %!, %? and $_ to live from one shell evaluation to another in the Perl6 shell. In nqp/src/HLL/Compiler.pm, I replace %interacitve_pad with %*INTERACTIVE_PAD  and I want to test it in finishpad in src/Perl6/Action.pm to set $BLOCK. Is it cargo cult? if now how to do it?

[20:32] <cognominal> s/now/no/

[20:34] <jnthn> cognominal: That feels like an odd kinda way to do it.

[20:35] <cognominal> I thought you would find a better way!

[20:35] <jnthn> Well, it's an issue for the debugger also, it seems.

[20:35] <jnthn> I think it's getting $!, $_ etc wrong if you try to introspect them

[20:35] <cognominal> if the debugger includes a shell, I bet

[20:36] <jnthn> So I think it's perhaps more general that just interactive.

[20:36] *** fgomez left
[20:37] <TimToady> r: my Int @array = 1,2,3; say @array ~~ [1,2,3]

[20:37] <p6eval> rakudo dbf347: OUTPUT«True␤»

[20:38] <TimToady> felher: but note ^^

[20:38] <jnthn> oh!

[20:38] <jnthn> TimToady++

[20:39] <felher> TimToady: oha, nice. Thanks!

[20:39] * felher looks up the smart-match-table once again :)

[20:39] *** bruges_ left
[20:40] <_edwin> std: https://gist.github.com/3868275

[20:40] <p6eval> std 77327a4: OUTPUT«ok 00:01 53m␤»

[20:41] *** bruges joined
[20:47] <dalek> ecosystem: a594e55 | grondilu++ | META.list:

[20:47] <dalek> ecosystem: Update META.list

[20:47] <dalek> ecosystem: 

[20:47] <dalek> ecosystem: perl6 interface to openssl, so far only a few digests.  Needs small modification of code for big-endian hosts.

[20:47] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/a594e55c71

[20:47] <dalek> ecosystem: 3e78dba | (Ahmad M. Zawawi)++ | META.list:

[20:47] <dalek> ecosystem: Merge pull request #15 from grondilu/patch-1

[20:47] <dalek> ecosystem: 

[20:47] <dalek> ecosystem: Update META.list

[20:47] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/3e78dbae41

[20:51] <grondilu> cool

[20:53] <grondilu> karma grondilu

[20:53] <aloha> grondilu has karma of 6.

[20:53] <grondilu> :)

[20:56] <cognominal> grondilu++

[21:02] <cognominal> r: say UNIT.WHO.keys

[21:02] <p6eval> rakudo dbf347: OUTPUT«GLOBALish EXPORT $?PACKAGE ::?PACKAGE $_ $/ $! $=pod !UNIT_MARKER␤»

[21:02] <cognominal> ::?PACKAGE ?

[21:05] *** zby_home_ left
[21:06] <japhb_> cognominal, current package's stash?

[21:07] <ingy> jnthn: do you know of a good demo p6 webapp?

[21:08] *** _edwin left
[21:08] <jnthn> ingy: Not off hand

[21:08] <ingy> jand wants to add p6 support to ActiveState's Stackato

[21:08] <jnthn> cognominal: Like ::?CLASS - it can be used as a type name.

[21:09] <ingy> just needs something to show off

[21:09] <jnthn> ingy: tadzik has made Bailador, so may have some suggestions.

[21:09] <cognominal> I don't get the difference between $?PACKAGE and ::$?PACKAGE

[21:09] <jnthn> cognominal: They contain the same thing, but you can't write $?PACKAGE where a type name is expected

[21:09] <ingy> I think I asked about this before

[21:10] <dalek> perl6-bench: dc0fc43 | (Geoffrey Broadwell)++ | bench:

[21:10] <dalek> perl6-bench: WIP: Pass config and overall per-run info to summarizers; display benchmark rev and overall run start time in summary outputs; save all config and per-run info in JSON output

[21:10] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/dc0fc435c8

[21:10] <dalek> perl6-bench: 5ed43bd | (Geoffrey Broadwell)++ | bench:

[21:10] <dalek> perl6-bench: Fixes for previous WIP commit

[21:10] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/5ed43bd08b

[21:10] <dalek> perl6-bench: 872ccf1 | (Geoffrey Broadwell)++ | bench:

[21:10] <dalek> perl6-bench: Stop testing Perlito6/perl5 on rc-forest-fire

[21:10] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/872ccf10db

[21:10] <dalek> perl6-bench: 7c25a88 | (Geoffrey Broadwell)++ | bench:

[21:10] <dalek> perl6-bench: Fix braino in HTML style output

[21:10] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/7c25a885cc

[21:10] <dalek> perl6-bench: 6f48049 | (Geoffrey Broadwell)++ | bench:

[21:10] <dalek> perl6-bench: Improve default HTML styling

[21:10] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/6f480496d6

[21:11] *** skids left
[21:16] <cognominal> r: my $?PACKAGE $a

[21:16] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Redeclaration of symbol $?PACKAGE␤at /tmp/wgkzzFw3GJ:1␤»

[21:16] <cognominal> r: my ::$?PACKAGE $a

[21:16] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Cannot use :: as a type name at line 2, near "$?PACKAGE "␤»

[21:16] <japhb_>  r: my ::?PACKAGE $a

[21:16] <p6eval> rakudo dbf347:  ( no output )

[21:17] <cognominal> oops

[21:17] <cognominal> thx jnthn and japhb_

[21:18] *** wk left
[21:18] <cognominal> I should read closely before attempting any interpetation

[21:21] *** rindolf left
[21:29] <dalek> perl6-bench: 0d7bba5 | (Geoffrey Broadwell)++ | TODO:

[21:29] <dalek> perl6-bench: A few more thoughts added to TODO

[21:29] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/0d7bba570b

[21:30] *** telex left
[21:32] *** telex joined
[21:43] *** cognominal left
[21:44] <japhb_> nr: my ($s) = now.to-posix; 1 for 1..100_000; my ($e) = now.to-posix; ($e - $s).say;

[21:44] <p6eval> niecza v22-7-g7df6137: OUTPUT«6.40090799331665␤»

[21:44] <p6eval> ..rakudo dbf347: OUTPUT«0.8622609␤»

[21:45] <japhb_> sorear, Any idea why niecza is unusually comparatively slow for the above trivial loop?

[21:47] <sorear> japhb_: niecza's Range.iterator has seen much less love

[21:47] <japhb_> sorear, Also, it would be really nice if Instant would coerce to Num.  ;-)

[21:47] <japhb_> sorear, Ah, OK, got it.

[21:47] <sorear> r: say now.Num

[21:47] <p6eval> rakudo dbf347: OUTPUT«1349905682.03435␤»

[21:48] *** MayDaniel left
[21:51] *** wamba left
[21:54] *** cognominal joined
[21:59] *** PacoAir left
[22:02] *** PacoAir joined
[22:10] *** daniel-s left
[22:11] *** whiteknight joined
[22:11] *** daniel-s joined
[22:14] *** am0c left
[22:27] <dalek> nqp: 71afc92 | jnthn++ | src/QRegex/Cursor.nqp:

[22:27] <dalek> nqp: Optimize CAPHASH a bit.

[22:27] <dalek> nqp: 

[22:27] <dalek> nqp: Avoids some boxing/unboxing and also an iterator allocation.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/71afc92312

[22:27] <dalek> nqp: 885cc4c | jnthn++ | src/NQP/Actions.pm:

[22:27] <dalek> nqp: Nameds should not be involved in multi-dispatch.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/885cc4c303

[22:27] <dalek> nqp: 9ef6b1b | jnthn++ | src/stage0/ (9 files):

[22:27] <dalek> nqp: Update bootstrap.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9ef6b1b01e

[22:27] <dalek> nqp: 00bb439 | jnthn++ | src/QAST/Compiler.nqp:

[22:27] <dalek> nqp: Try to better convey void context.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/00bb439036

[22:27] <dalek> nqp: a2cbfa4 | jnthn++ | src/QAST/Compiler.nqp:

[22:27] <dalek> nqp: Some more void context cleanups.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a2cbfa429b

[22:27] <dalek> nqp: 6247a45 | jnthn++ | src/QAST/Operations.nqp:

[22:27] <dalek> nqp: Generate better code for void if/unless.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6247a4566a

[22:27] <dalek> nqp: 5a60f40 | jnthn++ | src/NQP/ (2 files):

[22:27] <dalek> nqp: Generate better code for NQP's prefix:<!>.

[22:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5a60f40679

[22:33] *** mtk left
[22:39] <jnthn> 'night o/

[22:42] *** mtk joined
[22:46] <dalek> perl6-bench: cae05bc | (Geoffrey Broadwell)++ | bench:

[22:46] <dalek> perl6-bench: Add Niecza as a (partial) NQP compiler

[22:46] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/cae05bc6ea

[22:46] <dalek> perl6-bench: 9983ad1 | (Geoffrey Broadwell)++ | / (2 files):

[22:46] <dalek> perl6-bench: Begin documenting expected results and analysis of the various tests

[22:46] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/9983ad1389

[22:46] <dalek> perl6-roast-data: e98769f | coke++ | p (2 files):

[22:46] <dalek> perl6-roast-data: today (automated commit)

[22:46] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/e98769ff01

[22:46] <dalek> perl6-roast-data: fc4e5fb | coke++ | / (3 files):

[22:46] <dalek> perl6-roast-data: today (automated commit)

[22:46] *** dalek left
[22:47] *** dalek joined
[22:47] *** ChanServ sets mode: +v dalek

[22:50] *** hash_table joined
[22:50] *** bbkr_ joined
[22:58] *** fgomez joined
[23:10] *** erkan left
[23:25] *** tokuhiro_ joined
[23:25] <[Coke]> I've gotten to the point in partcl-nqp where I now have a circular dependancy that won't work due to the compile to pir step.

[23:26] <[Coke]> time to start combining perl files.

[23:27] *** PacoAir left
[23:32] <TimToady> http://rosettacode.org/wiki/Zeckendorf_number_representation#Perl_6

[23:32] *** Pleiades` left
[23:37] *** MikeFair left
[23:39] *** Pleiades` joined
[23:39] <[Coke]> TimToady: why is the constant inside the multi?

[23:39] <[Coke]> (just for scoping?)

[23:42] *** popl joined
[23:42] *** MikeFair_ joined
[23:47] * japhb_ is intrigued by the idiom in TimToady++'s code of a finite sequence built by clipping an infinite sequence

[23:47] <japhb_> (As opposed to just generating a finite sequence immediately.)

[23:48] *** dalek left
[23:49] *** skids joined
[23:50] *** thou left
[23:51] *** hugme left
[23:51] *** PerlJam left
[23:51] *** topo_ joined
[23:51] *** tadzik left
[23:51] *** dalek joined
[23:51] *** ChanServ sets mode: +v dalek

[23:51] *** PerlJam joined
[23:51] *** sergot left
[23:52] *** Juerd left
[23:52] *** sergot joined
[23:52] *** Juerd joined
[23:52] *** hugme joined
[23:52] *** ChanServ sets mode: +v hugme

[23:52] *** [Coke] left
[23:52] *** [Coke] joined
[23:53] *** topo left
[23:54] *** topo_ is now known as topo

[23:58] *** dayangkun joined
[23:59] *** p6eval left
