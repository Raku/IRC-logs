[00:01] *** shinobicl left
[00:01] *** benabik joined
[00:08] <Juerd> moritz: At this moment, 1.5G is a bit too much. Note that feather3 is for the unsafe part; perhaps building parrot automatically could happen on feather1, after which the binaries are copied to feather3?

[00:10] <Juerd> moritz: I could extend feather1's memory to 2G

[00:13] *** icwiener left
[00:13] *** icwiener_ joined
[00:17] *** UrielRLeon joined
[00:18] *** UrielRLeon left
[00:21] *** ab5tract left
[00:35] *** localhost left
[00:36] *** localhost joined
[00:44] <sorear> good * #perl6

[00:44] <sorear> Juerd: Why is there more than one feather?

[00:45] *** shinobicl___ joined
[00:47] *** shinobicl___ left
[00:50] *** icwiener_ left
[01:07] *** Yappoko____ left
[01:10] <sjn> moritz++ # For blogging about the hackathon at http://perlgeek.de/blog-en/perl-6/2012-upcoming-p6-hackathon.html :)

[01:10] <sorear> o/ sjn

[01:13] *** FACEFOX left
[01:13] <japhb> sorear, how does niecza handle laziness?  And is the implementation of laziness unified into one section of the code, or distributed across lots of files?

[01:14] <sorear> see IterHasFlat in Kernel.cs

[01:14] <sorear> anything that iterates a list uses that

[01:21] <japhb> Ouch, github trying to display Kernel.cs causes browser script timeouts.

[01:27] <benabik> Javascript syntax highlight?

[01:27] *** skipper left
[01:42] *** leprevost joined
[01:44] *** TESTKEYz joined
[01:46] *** envi_ joined
[01:50] *** lestrrat left
[01:51] *** lestrrat joined
[01:57] <cbk1090> I need help/want to learn how to make modules for Perl 6.  I have some code(https://gist.github.com/2143601)  but I'm not sure if it will work or how to get it to work. I would like to have self contained classes or modules, any ideas/tips? 

[02:00] *** scott__ joined
[02:01] *** shinobicl___ joined
[02:02] *** FACEFOX joined
[02:04] *** TESTKEYz left
[02:04] *** TESTKEYz joined
[02:05] *** whiteknight left
[02:06] <shinobicl___> rakudo: sub f(Int :$x, Int :$y){ return $x + $y; }; sub f(Int $x, Int $y){ return $x * $y; }; say f(1,1); say f(x=>2,y=>2);

[02:06] <p6eval> rakudo 704a21: OUTPUT«===SORRY!===␤Redeclaration of routine f␤at /tmp/G7PDUGroVw:1␤»

[02:07] <shinobicl___> how could i declare both functions? One with positional and another with named parameters?

[02:07] <sorear> if you want multiple declarations, you need to say "multi sub"

[02:15] *** FACEFOX left
[02:15] *** libertyprime left
[02:16] <shinobicl___> rakudo: class C { multi method new(:$a!, :$b, :$c, :$x = 0) {say "named $x"; }; multi method new($a, $b, $c, $x = 0){ say "positional $x"; }; }; my $var = C.new(a=>1,b=>2,c=>3); my $var2 = C.new(1,2,3); my $var3 = C.new(a=>1,b=>2,c=>3,x=>88); my $var4 = C.new(1,2,3,99);

[02:16] <p6eval> rakudo 704a21: OUTPUT«named 0␤positional 0␤named 88␤positional 99␤»

[02:16] <shinobicl___> this works as expected.

[02:16] <shinobicl___> rakudo: class B { method new($Z){say "B - $Z";};  }; my $var0 = B.new(100);  class C is B { multi method new(:$a!, :$b, :$c, :$x = 0) {say "named $x"; callwith($x)}; multi method new($a, $b, $c, $x = 0){ say "positional $x"; }; }; my $var = C.new(a=>1,b=>2,c=>3); my $var2 = C.new(1,2,3); my $var3 = C.new(a=>1,b=>2,c=>3,x=>88); my $var4 = C.new(1,2,3,99);  

[02:16] <p6eval> rakudo 704a21: OUTPUT«B - 100␤named 0␤Too many positional parameters passed; got 2 but expected 1␤  in method new at src/gen/CORE.setting:552␤  in <anon> at src/gen/Metamodel.pm:2579␤  in any call_with_args at src/gen/Metamodel.pm:2576␤  in block <anon> at src/gen/CORE.setting:390␤  in …

[02:17] <shinobicl___> this... i don't know. I want to call the B.new with callwith, but it reports the "Too many positional parameters" error

[02:19] *** wolfman2000 joined
[02:21] *** libertyprime joined
[02:29] <shinobicl___> rakudo: class A { multi method new(Int $x){ say "A with Int $x";}; multi method new(Str $s){ say "A with Str $s"}; }; class B { method new(Int $y) { say "B with $y"; return callwith($y); }; }; my $var1 = A.new(1); my $var2 = A.new("str"); my $var3 = B.new("text");

[02:29] <p6eval> rakudo 704a21: OUTPUT«A with Int 1␤A with Str str␤Nominal type check failed for parameter '$y'; expected Int but got Str instead␤  in method new at /tmp/Bco7QQoMD4:1␤  in block <anon> at /tmp/Bco7QQoMD4:1␤␤»

[02:30] <shinobicl___> rakudo: class A { multi method new(Int $x){ say "A with Int $x";}; multi method new(Str $s){ say "A with Str $s"}; }; class B { method new(Int $y) { say "B with $y"; return callwith($y); }; }; my $var1 = A.new(1); my $var2 = A.new("str"); my $var3 = B.new(1);

[02:30] <p6eval> rakudo 704a21: OUTPUT«A with Int 1␤A with Str str␤B with 1␤Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:556␤  in <anon> at src/gen/Metamodel.pm:2579␤  in any call_with_args at src/gen/Metamodel.pm:2576␤  in block <anon> at src/gen/CORE.setting:3…

[02:38] *** havenn joined
[02:51] *** skids joined
[02:58] *** s1n joined
[03:12] *** shinobicl___ left
[03:23] *** Chillance left
[03:24] *** shinobicl___ joined
[03:25] *** havenn left
[03:32] *** alester joined
[03:37] *** envi_ left
[03:43] *** DarthGandalf left
[03:52] *** orafu left
[03:52] *** orafu joined
[03:53] *** DarthGandalf joined
[04:09] *** havenn joined
[04:11] *** leprevost left
[04:18] *** Yappo___ joined
[04:27] *** Su-Shee left
[04:29] *** Su-Shee joined
[04:36] *** alester left
[04:57] *** wolfman2000 left
[05:38] *** birdwindupbird joined
[05:40] *** kaleem joined
[05:40] *** havenn left
[05:51] *** fgomez left
[05:58] *** NamelessTee joined
[06:00] *** mucker joined
[06:04] *** mucker left
[06:05] *** mucker joined
[06:20] *** thou left
[06:21] *** TESTKEYz left
[06:22] *** TESTKEYz joined
[06:27] *** TESTKEYz left
[06:34] *** shinobicl___ left
[06:38] <dalek> nqp: ca74e29 | moritz++ | tools/build/PARROT_REVISION:

[06:38] <dalek> nqp: bump parrot revision to 4.2.0 release

[06:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ca74e29152

[06:38] <dalek> rakudo/nom: 1a468d8 | moritz++ | tools/build/NQP_REVISION:

[06:38] <dalek> rakudo/nom: bump NQP revision to get parrot 4.2.0

[06:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1a468d853c

[06:47] *** mucker left
[07:03] <tadzik> good morning #perl6

[07:03] <moritz> \o tadzik 

[07:04] <tadzik> cbk1090: what do you mean by self-contained classes/modules?

[07:05] <tadzik> cbk1090: you could look through the code of existing modules to see how they work: http://modules.perl6.org/

[07:09] *** daxim joined
[07:37] <sorear> o/ tadzik 

[07:40] *** odoacre left
[07:41] *** odoacre joined
[07:45] *** mucker joined
[08:05] *** bacek joined
[08:11] *** bacek left
[08:11] *** bacek joined
[08:15] *** bacek left
[08:15] *** bacek joined
[08:16] *** bacek left
[08:16] * felher really likes the '0 but True' that is returned by 'shell' or such :)

[08:17] *** bacek joined
[08:17] <moritz> felher: I really hope that shell() will return something nicer and easier to inspect

[08:17] *** bacek left
[08:18] *** bacek joined
[08:18] *** bacek left
[08:19] *** bacek joined
[08:19] <felher> moritz: What information should that nicer thing contain?

[08:19] *** bacek left
[08:19] <moritz> felher: well, I'm thinking of some more general object that qx// could also return

[08:20] <moritz> felher: which would then store the exit code, the STDOUT stream, the STDERR stream, possibly some timing information

[08:20] * sorear has an irrational dislike of 0 but True

[08:21] * moritz has a rational dislike of 0 but True

[08:21] <felher> moritz: and will still return 'True' if i put it in boolean context and will still return 0 if i put it in numeric context?

[08:21] <moritz> felher: yes

[08:21] <sjn> AND it's defined :)

[08:22] <moritz> though maybe an explicit .status would be clearer than just numeric context

[08:22] <tadzik> yeah, 0 but True seems unsane

[08:22] <tadzik> not insane, but unsane :)

[08:23] *** am0c joined
[08:23] <moritz> thing is, if you start passing around '0 but True' objects, people will come up with all sorts of crazy ways to guard against that

[08:23] <felher> moritz: obvisouly, since this is a superset of the current '0 but True', im fine with that.

[08:24] <moritz> p6: my $thing = 0 but True; if $thing ~~ Int && $thing ~~ Bool { say "I don't trust you" }

[08:24] <p6eval> pugs: OUTPUT«*** Cannot cast from VBool True to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[08:24] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89:  ( no output )

[08:24] <moritz> hm

[08:25] <sorear> note, moritz, Bool ~~ Int

[08:25] <moritz> felher: yes, I understand. Kinda like the context magic that Match possesses

[08:26] <moritz> p6: say Bool ~~ Int

[08:26] <p6eval> rakudo 1a468d: OUTPUT«False␤»

[08:26] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«True␤»

[08:26] <p6eval> ..pugs: OUTPUT«␤»

[08:26] <moritz> sorear: even if the spec says so, it feels wrong

[08:26] <moritz> because it doesn't respect Liskov in any way

[08:27] <felher> moritz: it doesn't? Can't you use Bool everywhere you use int? (Or do i mix up liskov with something else)

[08:27] <felher> nom: True.sin

[08:27] <p6eval> rakudo 1a468d:  ( no output )

[08:27] <felher> nom: True.sin.say

[08:27] <p6eval> rakudo 1a468d: OUTPUT«0.841470984807897␤»

[08:28] <sorear> the only thing Int does that Bool doesn't is smartmatch

[08:28] <moritz> felher: a Bool cannot hold all values that an Int can hold

[08:28] <sorear> that only matters if Int/Bool is mutable, no?

[08:28] *** NamelessTee left
[08:28] <moritz> r: say Int.new(5) == 5

[08:28] <p6eval> rakudo 1a468d: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:556␤  in block <anon> at /tmp/0VbTP_GsuS:1␤␤»

[08:29] <sorear> I don't think it's really correct to say an Int "holds" a value

[08:29] <moritz> my point is that Bool is more of a subset type of Int than an inherited type

[08:29] *** mj41_nb joined
[08:29] <moritz> well, it is a value

[08:29] <sorear> "my Int $x" can hold considerably fewer values than "my Any $x"

[08:30] <sorear> Int is a subtype of Any :D

[08:30] <moritz> I know, I know

[08:30] * sorear is half asleep, will leave when this is done

[08:32] * sorear times out, --> sleep

[08:32] <felher> o/ sorear :)

[08:33] *** fglock joined
[08:35] *** bacek joined
[08:36] <moritz> http://moritz.faui2k3.org/tmp/perl6-lines.txt statistics about how much we spoke in here

[08:36] *** bacek left
[08:36] * moritz currently too lazy to turn it into a chart

[08:36] *** bacek joined
[08:37] <tadzik> svg::plot ttr!

[08:38] *** bacek left
[08:38] *** bacek joined
[08:39] <felher> Hm, regarding liskov. Wikipedia says: "Let q(x) be a property provable about objects x of type T. Then q(y) should be provable for objects y of type S where S is a subtype of T.". That means that subtypes do have to beave exactly like 'T', doesn't it? Since 'does not have Method x' or 'does reject value of ...' are properties, every subtype that would have such a method violates the liskov-principle?

[08:39] *** bacek left
[08:39] <felher> *behave

[08:40] *** bacek joined
[08:40] <moritz> no, I think "property" is more narrowly defined here

[08:40] *** bacek left
[08:41] *** bacek joined
[08:43] <felher> Ah, so property is more like 'can do'-properties?

[08:43] *** bacek left
[08:43] <moritz> yes

[08:44] <moritz> or think of it as an assertion

[08:44] *** bacek joined
[08:44] <moritz> for example for role Real, we dearly hope that   is_approx $x.sqrt ** 2, $x;  holds

[08:45] *** bacek left
[08:46] *** bacek joined
[08:46] *** bacek left
[08:47] *** bacek joined
[08:47] *** bacek left
[08:48] <felher> Okay, i think i got it on a 'not-so-formal' level. I try to get the paper never the less, just to see how it's defined. Thanks :)

[08:49] <moritz> on a not-so-formal level it just says "substitution an object by the same object of a subclass shouldn't break stuff"

[08:50] <moritz> *substitutiting

[08:54] <moritz> it seems SVG::Plot is quite broken when using it with a single data set :(

[08:56] <moritz> and now I've tried to add some debugging output

[08:57] <moritz> and got a segfault :/

[08:57] <tadzik> moritz: do you use it precompiled?

[08:57] <moritz> r: note 'oh hai'

[08:57] <p6eval> rakudo 1a468d: OUTPUT«oh hai␤»

[08:57] <tadzik> it did segfault for me when precompiled

[08:57] <moritz> tadzik: I've precompiled SVG.pm and XML::Writer, but not SVG::Plot

[08:58] <tadzik> I see

[08:58] <tadzik> you could try removing those as well, maybe it'll help

[08:58] * moritz tries

[09:03] *** bacek joined
[09:05] <moritz> nom: my @a = eager gather for 1..10 { .say; take $_ }

[09:05] <p6eval> rakudo 1a468d: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[09:10] <felher> "Our paper is intentionally written in a descriptive and informal style" ... damn it ... :)

[09:10] <moritz> read it anyway, it might still contain some interesting formalism :-)

[09:14] <felher> moritz: yeah, quite possible :)

[09:15] <moritz> http://moritz.faui2k3.org/tmp/perl6-lines.svg

[09:15] <moritz> I finally found the bug

[09:16] <felher> nearly lookes like a sine ... :)

[09:16] <moritz> SVG::Plot was using [min] and [max] to find the upper and lower bounds

[09:16] <moritz> and I fed it strings, not numbers

[09:16] <moritz> so [min] and [max] worked lexicographically, having $min > $max

[09:17] <moritz> which moved nearly all of the plot points outside the viewport

[09:18] <felher> "11" < "2" .. :)

[09:18] *** lestrrat left
[09:19] <moritz> p6: say '11' lt '2'

[09:19] <p6eval> pugs: OUTPUT«1␤»

[09:19] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«True␤»

[09:19] *** lestrrat joined
[09:45] <masak> good morning, #perl6

[09:46] <tadzik> dzien dobry masak 

[09:46] <masak> dzien dobry, o tadziku!

[09:46] <tadzik> :P

[09:47] <tadzik> you usually omit the "o" here, unless you want it to sound ancient-ish :)

[09:47] <masak> I... I sorta had that feeling :)

[09:47] <tadzik> sounds a bit like "o królu"

[09:47] <masak> moritz: it hurts sometimes that infix:<min> and infix:<max> don't coerce, like all the arithmetic, stingithmetic, and comparison ops do.

[09:48] <moritz> masak: I really wonder if we want +min, ~min, +max, ~max operators

[09:48] <moritz> masak: or something along these lines

[09:48] <moritz> it feels we're missing a primitive

[09:49] <masak> aye.

[09:49] <masak> I think that would be good.

[09:50] * masak .oO( ?min, ?max -- exotic ways to spell && and || )

[09:51] *** dakkar joined
[09:53] <masak> nom: my $o = class {}; say $o

[09:53] <p6eval> rakudo 1a468d: OUTPUT«<anon>()␤»

[09:53] *** NamelessTee joined
[09:53] <masak> nom: my $o = class {}; say [max] $o, Inf

[09:53] <p6eval> rakudo 1a468d: OUTPUT«Inf␤»

[09:53] <masak> nom: my $o = class {}; say [min] $o, Inf

[09:53] <p6eval> rakudo 1a468d: OUTPUT«Inf␤»

[09:53] <masak> grrr :/

[09:54] <moritz> what would zou want that to do?

[09:54] <moritz> s/z/y/

[09:55] <masak> always treat Inf as bigger than anything else, including user-defined types.

[09:55] <moritz> hm

[09:55] <masak> the only thing that Inf isn't bigger than is Inf.

[09:56] <moritz> what about NaN?

[09:56] <masak> Inf is bigger than NaN.

[09:56] <moritz> how much bigger? ;-)

[09:56] <masak> or maybe I don't care about that one, I'll let the IEEE people fight that one out.

[09:56] <masak> Inf/NaN arithmetic isn't consistent, so its specifics don't interest me that much :)

[09:58] *** envi_ joined
[10:02] *** kaleem_ joined
[10:02] <colomon> r: my $o = class {}; say [min] $o, Inf

[10:02] <p6eval> rakudo 1a468d: OUTPUT«Inf␤»

[10:02] <colomon> n: my $o = class {}; say [min] $o, Inf

[10:02] <p6eval> niecza v15-4-g1f35f89: OUTPUT«ANON()␤»

[10:02] <colomon> \o/

[10:03] <colomon> n: my $o = class {}; say [max] $o, Inf

[10:03] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Inf␤»

[10:03] *** kaleem left
[10:06] <masak> niecza++

[10:07] <moritz> (mostly off-topic) I offer my IRC logging service to all open source communities; and my current attempt to gather some stats showed that one of them (#thegeekgroup) talks more than double as much as we do

[10:08] <moritz> but we are the second-most active channel that I log

[10:15] *** kaleem_ left
[10:15] *** scott__ left
[10:19] *** kaleem joined
[10:31] <masak> \o/

[10:39] <masak> <moritz> felher: a Bool cannot hold all values that an Int can hold

[10:40] <masak> this is the way derived types work.

[10:40] <masak> so I don't see how that's an argument at all.

[10:40] *** tarch joined
[10:40] <masak> oh, sorear++ also pointed that out, but with Any/Int :)

[10:42] <masak> by the way, http://moritz.faui2k3.org/tmp/perl6-lines.svg is fascinating.

[10:42] <moritz> was 2010-07 the month of the first Star release, by any chance?

[10:43] <masak> compare it to this graph: http://moritz.faui2k3.org/tmp/perl6-lines.svg

[10:44] <masak> er, this one: http://www.perlfoundation.org/perl6/index.cgi/Perl_6_timeline.png?action=attachments_download;page_name=when_will_perl_6_be_released;id=20071231104947-0-13730

[10:45] <masak> yes, the first rakudo star was 2010-07.

[10:45] *** araujo left
[10:45] *** pmurias joined
[10:45] <pmurias> fglock: hi

[10:45] <masak> we need a new ambitious goal. something to fire us up as much as Rakudo Star did. the next stage of the rocket.

[10:46] <masak> if it can include Niecza as well as Rakudo, even better.

[10:47] <pmurias> fglock: i'm reading through Perlito5::JavaScript::LexicalBlock, do we need something like the visitors from kp6?

[10:48] <masak> the most fascinating bit of the graph is this, I think: the Pugs/golden age has the shape of a falling line, from early 2005 to late 2007. the Rakudo project has the shape of a parabola, spanning from early 2008 to late 2012.

[10:48] <masak> of course, extrapolating after that is futile.

[10:49] * [Coke]_ is still waiting for masak to relaunch pugs!

[10:49] * [Coke]_ wonders why his nick is not right.

[10:49] *** [Coke]_ is now known as [Coke]

[10:49] <moritz> well, I kinda hope that much of the excitement will move from the compilers to the modules and docs we'll create

[10:49] <masak> whatever Pugs will be, it won't be that kind of DDoS attack of activity again. I'm sorry, I'm not au. :)

[10:50] <moritz> that would be a real sign of maturity

[10:50] * masak puts himself with the sun in his back, holding a banner, shouting "let's build a better tomorrow!"

[10:50] <[Coke]> moritz: "oh, real mature."

[10:51] <[Coke]> murhaba, #perl6

[10:51] <fglock> pmurias: I think that's overkill at this point; do you see a specific use?

[10:52] <pmurias> if (0) {@bar} creates a package variable bar under "no strict" in perl5

[10:53] <pmurias> i'm currently passing back info in a global $Perlito5::PKG_VARS

[10:54] <pmurias> but seeing we do a traversal already i thought it migh want to have a visitor

[10:54] <pmurias> s/traversal/partial traversal/

[10:58] *** araujo joined
[10:58] <pmurias> fglock: and we do 'use statement' expansion?

[11:03] <fglock> about {@bar} - I think we should collect the declarations (and missing declarations) and add them at the end of the lexical block processing (we now do this at the start, but that's more expensive)

[11:04] <fglock> 'use' is processed at the wrong place (in perlito5.pl) - this needs some refactoring

[11:04] <fglock> maybe add BEGIN{} first

[11:05] <fglock> we have 'do-file'; we can use that to implement 'require' and 'use'

[11:06] <fglock> lunch&

[11:08] *** pmurias left
[11:34] *** mucker left
[11:47] *** skids left
[12:00] *** lestrrat left
[12:01] *** lestrrat joined
[12:04] *** pernatiy left
[12:16] *** birdwind1pbird joined
[12:18] <fglock> pmurias: also related to LexicalBlock - figure out how to implement 'my $x if $z' and 'my $x = $x'

[12:18] <fglock> maybe make $x a stack

[12:19] <fglock> so it becomes roughly: push $x, undef if $z; push $x, undef if $x

[12:22] <fglock> same problem in p5-to-p6, I think

[12:24] *** jaldhar left
[12:29] <fglock> sorry, the 2nd one is: push @$x, $x[-1]

[12:32] *** libertyprime left
[12:38] <moritz> .u hbar

[12:38] <phenny> moritz: Sorry, no results for 'hbar'.

[12:40] *** birdwindupbird left
[12:40] <masak> .u dash

[12:40] <phenny> U+2013 EN DASH (–)

[12:40] <masak> .u em dash

[12:40] <phenny> U+2014 EM DASH (—)

[12:40] <moritz> .u h bar

[12:40] <phenny> U+2015 HORIZONTAL BAR (―)

[12:41] * moritz is looking for hbar really

[12:41] <masak> .u double vertical line

[12:41] <moritz> I want a LaTeX-to-Unicode lookup (and the other way round)

[12:41] <phenny> U+2016 DOUBLE VERTICAL LINE (‖)

[12:43] <masak> .u 210F

[12:43] <phenny> U+210F PLANCK CONSTANT OVER TWO PI (ℏ)

[12:43] <masak> that one?

[12:44] <moritz> yes

[12:44] <moritz> thanks

[12:44] * masak kowtows

[12:47] *** NamelessTee left
[12:52] *** benabik left
[13:05] <masak> .u benzene

[13:05] <phenny> U+232C BENZENE RING (⌬)

[13:05] <masak> .u benzene circle

[13:05] <phenny> U+23E3 BENZENE RING WITH CIRCLE (⏣)

[13:07] <LoRe> .u pile of poo

[13:07] <phenny> LoRe: Sorry, no results for 'pile of poo'.

[13:07] *** mucker joined
[13:08] <moritz> phenny doesn't do chars > 0xFFFF, iirc

[13:08] <moritz> .u 10001

[13:08] <phenny> moritz: Sorry, no results for '10001'.

[13:14] * masak just discovered http://en.wikipedia.org/wiki/Grimm's_law

[13:16] *** shinobicl joined
[13:25] *** pernatiy joined
[13:25] *** birdwindupbird joined
[13:26] *** icwiener joined
[13:32] *** pmurias joined
[13:32] *** skids joined
[13:32] <pmurias> fglock: re my $x = $x, maping them to different javascript variables could work

[13:34] <pmurias> fglock: why is my $x if $z special?

[13:35] <pmurias> fglock: in p6-to-p5 use $OUTER::x

[13:52] *** xinming_ joined
[13:54] *** xinming left
[13:56] <masak> oh look, this page is so old it uses the 'skip' no-longer-keyword. http://c2.com/cgi/wiki?GivenWhen

[13:56] * masak attempts to change it to 'succeed'

[13:58] <masak> wow, that was easy.

[13:58] <masak> c2++

[13:58] <timotimo> so is it the only awesome feature in perl6? :)

[13:59] <masak> yeah, we're all doing this twelve-year-and-counting project solely for the awesomeness of given/when :P

[13:59] <timotimo> well, i could see that ... :p

[14:01] <PerlJam> obviously Perl 5 has trouble getting given/when right.  That Perl 6 does is quite awesome  :)

[14:01] <masak> p6: sub fac($_) { when * < 2 { 1 }; $_ * fac $_ - 1 }; say fac 5

[14:01] *** Woodi left
[14:02] <p6eval> pugs: OUTPUT«(timeout)»

[14:02] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«120␤»

[14:02] <masak> \o/

[14:02] * masak wonders what Pugs thinks that means

[14:02] <moritz> it probably doesn't exit the outer block

[14:03] <colomon> could it be parsing it as (fac $_) - 1     ?

[14:03] <colomon> p6: sub fac($_) { when * < 2 { 1 }; $_ * fac($_ - 1) }; say fac 5

[14:03] *** Woodi joined
[14:03] <PerlJam> pugs didn't know about Whatevers did it?

[14:03] <p6eval> pugs: OUTPUT«(timeout)»

[14:03] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«120␤»

[14:04] <PerlJam> I think that first * is throwing purs for a loop  ;-)

[14:04] <PerlJam> s/pur/pugs/

[14:04] <masak> oh, yes.

[14:04] <moritz> p6: sub f($_) { say 'inside when' when 2; say 'outside when' }; f 2

[14:04] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "when"␤    expecting operator, ":", "," or "}"␤    at /tmp/eQASgFqNnm line 1, column 31␤»

[14:04] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«inside when␤outside when␤»

[14:04] <masak> pugs: sub fac($_) { when $_ < 2 { 1 }; $_ * fac $_ - 1 }; say fac 5

[14:04] <p6eval> pugs: OUTPUT«120␤»

[14:04] <masak> Pugs++

[14:05] <masak> huh, pugs never had statement_mod when? :)

[14:05] *** icwiener left
[14:05] *** icwiener joined
[14:05] <moritz> seems like

[14:05] <moritz> p6: sub f($_) { when 2 { say 'inside when' }; say 'outside when' }; f 2

[14:05] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«inside when␤»

[14:06] <geekosaur> pugs knows Whatever but it's a very early view thereof

[14:08] *** ChanServ sets mode: +o moritz

[14:08] <fglock> pmurias: my $x if $z will only create the new var if $z is true (at runtime)

[14:08] *** moritz sets mode: -b *!*@turkeyberry.sgn.cornell.edu

[14:08] *** moritz sets mode: -o moritz

[14:09] *** dukeleto joined
[14:09] * dukeleto waves

[14:09] <fglock> dukeleto: o/

[14:11] <pmurias>  fglock: are you sure about my $x if $z?

[14:11] <fglock> testing

[14:11] <moritz> eval: my $x = 5; my $x if 0; $x

[14:11] <buubot_backup> moritz: No output.

[14:11] <moritz> eval: my $x = 5; my $x if 0; [$x]

[14:11] <buubot_backup> moritz: [undef]

[14:11] <masak> dukeleto: you were banned last time because your auto-joiner is noisy when it gets in a loop with some other factor that times you out.

[14:12] <masak> eval: $_ = 5; say "OH HAI" when 5

[14:12] <buubot_backup> masak: ERROR: syntax error at (eval 20) line 1, near "say "OH HAI"" 

[14:12] <masak> eval: use 5.016; $_ = 5; say "OH HAI" when 5

[14:12] <buubot_backup> masak: ERROR: Perl v5.16.0 required--this is only v5.14.2, stopped at (eval 20) line 1. BEGIN failed--compilation aborted at (eval 20) line 1. 

[14:12] <masak> eval: use 5.014; $_ = 5; say "OH HAI" when 5

[14:12] <buubot_backup> masak: OH HAI ERROR: Can't use when() outside a topicalizer at (eval 20) line 1. 

[14:13] <masak> eval: use 5.014; given 5 { say "OH HAI" when 5; say "never reached" }

[14:13] <buubot_backup> masak: ERROR: syntax error at (eval 20) line 1, near "given 5" syntax error at (eval 20) line 1, near ""never reached" }" 

[14:13] <masak> eval: use 5.014; given (5) { say "OH HAI" when 5; say "never reached" }

[14:13] <buubot_backup> masak: OH HAI 1

[14:13] <pmurias> fglock: http://paste.scsys.co.uk/188107

[14:13] <dukeleto> masak: yes, dircproxy default settings are to autorejoin, so when I would forget to close an irc session on a different machine, they go into a never-ending war

[14:13] <masak> p6: given 5 { say "OH HAI" when 5; say "this *is* reached" }

[14:13] <p6eval> rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«OH HAI␤this *is* reached␤»

[14:13] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "when"␤    expecting operator, ":", "," or "}"␤    at /tmp/w3BcEb_tiH line 1, column 24␤»

[14:15] <masak> dukeleto: it won't be less distracting next time when I know the underlying cause. :) I'll likely ban you again. so if you find yourself banned again, that was likely why.

[14:15] <fglock> ok - so not a problem :)

[14:18] <shinobicl> hi

[14:18] <shinobicl> rakudo: class B { method new($Z){say "B - $Z";};  }; my $var0 = B.new(100);  class C is B { multi method new(:$a!, :$b, :$c, :$x = 0) {say "named. $x"; callwith($x)}; }; my $var2 = C.new(a=>1,b=>2,c=>3)

[14:18] <p6eval> rakudo 1a468d: OUTPUT«B - 100␤named. 0␤Too many positional parameters passed; got 2 but expected 1␤  in method new at src/gen/CORE.setting:552␤  in <anon> at src/gen/Metamodel.pm:2579␤  in any call_with_args at src/gen/Metamodel.pm:2576␤  in block <anon> at src/gen/CORE.setting:390␤  in…

[14:18] <masak> hi shinobicl 

[14:19] <shinobicl> i got this problem.. i want to invoke the parent's new function with callwith but i got this error

[14:19] <moritz> uhm

[14:20] * masak submits rakudobug

[14:20] <moritz> that looks like weird interaction of multis, non-multis and callwith

[14:20] <moritz> is callwith supposed to stay within the same dispatcher?

[14:20] <masak> it redispatches to the default .new, no?

[14:21] <shinobicl> i got a class that inherits from Date. So, i want to provide the same constructors as Date has. I'm trying to use something like the code i posted to achieve that

[14:21] <moritz> masak: and I think that's correct

[14:21] <masak> I'm not so sure.

[14:21] <masak> it doesn't vibe with my understanding of multi subs.

[14:21] <masak> unless multi methods are vastly different, which they might be, this is wrong too.

[14:21] <moritz> masak: because calling .new() without a positional argument narrows down the list of candidates that are available to nextsame

[14:22] <masak> hm.

[14:22] <masak> troo.

[14:22] <moritz> r: multi a() { }; multi a($) { callwith() }; a(1)

[14:22] <p6eval> rakudo 1a468d:  ( no output )

[14:22] <masak> yeah, this may be an anti-issue, then.

[14:22] <moritz> r: multi a() { say 'here' }; multi a($) { callwith() }; a(1)

[14:22] <p6eval> rakudo 1a468d:  ( no output )

[14:22] <masak> I mean, a non-issue.

[14:22] <moritz> shinobicl: any reason not to call self.Date::new(ARGS) directly?

[14:22] <masak> dangit, I *still* lack a robust mental model of what nextsame and friends do. :/

[14:23] <moritz> it's *not* 'call a routine of the same name as me, but exclude me from the call'

[14:24] <shinobicl> I haven't tried that syntax, but i want my derived class to be a date too. The thing is, my derived class has an additional attribute

[14:24] <shinobicl> so i'm doing this: 

[14:24] <moritz> shinobicl: of which you need to take care of anyway, indepently on how you call the parent constructor

[14:25] <shinobicl> multi method new(:$year!, :$month, :$day, :$calendar = WorkdayCalendar.new) { my $D = callwith(year=>$year, month=>$month, day=>$day); ^M  $D.calendar = $calendar; return $D;  }

[14:25] <masak> taking care of an additional attribute sounds more like a job for .BUILD, not .new

[14:26] <Woodi> hi

[14:26] <shinobicl> with that 'new', $calendar gets 'attached' to the object. Tyhe problem starts when i start adding more 'new's

[14:26] <masak> hi Woodi 

[14:26] <moritz> shinobicl: try  my $D = self.Date::new(...);

[14:26] <shinobicl> ok, i'll do, thanks moritz

[14:26] <masak> shinobicl: well, the reason for the problem was explained above by moritz++, if you're interested.

[14:26] <moritz> shinobicl: oh, and if you have any suggestions on how to make the constructors in Date more friendly to subclassing, I'd be glad to hear them too

[14:27] <Woodi> just read Star2012.02 release info and looks nice... especially future part :)

[14:27] <masak> yeah. this is going to crop up again and again until we understand it well :)

[14:27] <masak> Woodi: this month's star release is going to be awesome :)

[14:28] * moritz just hopes that jnthn++ can fix the MiniDBI segfault(s) before the release

[14:28] <Woodi> but just compiled it and got "libparrot.so: warning: strcpy() is almost always misused, please use ..."

[14:28] <shinobicl> I think the constructors in Date are well implemented. I just hit a wall with that "callwith" thing. 

[14:28] <Woodi> is it allow buffer overflow ?

[14:30] <moritz> Woodi: not more than before; just the warning is new

[14:32] <Woodi> warning is specific for OpenBSD gcc...

[14:32] *** leprevost joined
[14:32] *** cognominal left
[14:33] *** cognominal joined
[14:33] <shinobicl> thanks moritz++, with that change all of my constructors test passed :D

[14:33] <masak> moritz++

[14:34] *** kaleem left
[14:34] <masak> (though it feels like defeat (1) to have to spell out the class explicitly, creating a teeny-tiny amount of dis-DRY, (2) to misjudge how the multimethod dispatch will work in a given moderately complex case)

[14:34] *** Vespakoen joined
[14:37] <moritz> agreed

[14:38] <moritz> I can also never remember if the default Mu.new is specced to be a multi method or an only-method

[14:40] <masak> multi, I hope.

[14:41] <masak> (because I expect a user-defined class to be able to do 'multi method new' and not shadow Mu.new)

[14:42] <moritz> right; shadowing a multi is easier than adding candidates to an only

[14:44] <bbkr> speaking of candidates - I did training about signatures today in my company based on Perl6 and people were really impressed by where{} constraints and things you can do with them :)

[14:44] <moritz> :-)

[14:44] *** thou joined
[14:46] <PerlJam> bbkr: your company uses Perl 6?

[14:46] <PerlJam> :-)

[14:47] <bbkr> yes, for utilities mostly. and a lot of things from P6 ported back to P5 such as Regexp::Grammars.

[14:48] <moritz> bbkr: whoa. Where is that company? And are you hiring?

[14:48] <masak> indeed. whoa.

[14:49] <moritz> .oO( "Mr. Lenz, what do you say to those who accuse of blatant job whoring?" -- "hire me!" )

[14:49] <moritz> *accuse you

[14:49] <bbkr> Implix in Poland. main product is getresponse.com - email marketing tool with heavy duty Perl workers sending up to 20_000_000 mails per day.

[14:49] <masak> cool.

[14:50] <moritz> wow. I can't even imagine the length you need to go to haven them not all flagged as spam immediately

[14:50] <moritz> s/haven/have/ # can't type today

[14:51] * masak .oO( put "*NOT SPAM*" in the subject line :P )

[14:51] <pmurias> moritz: you mean tricking spam filters ;)

[14:51] <moritz> pmurias: I thought more of staying off of DNS blacklists and the likes

[14:51] *** PacoAir joined
[14:55] <bbkr> there are mechanisms for killing spammers who wants to use our system. still - maintaining high deliverability for legit users is very complicated :)

[14:55] <masak> I bet.

[14:55] *** Chillance joined
[14:58] *** fgomez joined
[14:59] *** alester joined
[15:02] *** havenn joined
[15:03] *** benabik joined
[15:04] *** geekosaur left
[15:05] <felher> In java, a method of a class can change private attributes of all objects of its class. Is this possible in Perl6? i.e. is the following possible in Perl6: class C { has $!priv; method x(C $other) { $other!priv = 3; } }; ?

[15:05] <bbkr> that reminds me we still don't have Email::MIME. I'll try to hack something basic soon.

[15:06] *** araujo left
[15:06] <masak> felher: it should be, methinks. I don't know how current implementations conform, though.

[15:07] <felher> masak: nom doesn't :) But i agree that it should be possible :)

[15:07] <masak> felher: private attributes are only visible within the current class block. but I think the visibility isn't limited to the invocant. I might be wrong, though.

[15:08] <masak> otherwise it's really difficult to write some things.

[15:08] <masak> for example to construct a new instance of an immutable type from some operation on two existing instances.

[15:08] <moritz> nom: class A { has $.priv; method a(A $x) { $x!A::priv = 5 ; say $x.priv} }; say A.new.a(A.new)

[15:08] <p6eval> rakudo 1a468d: OUTPUT«Private method 'priv' not found on type A␤  in method dispatch:<!> at src/gen/CORE.setting:778␤  in method a at /tmp/Tv1fGPxYEY:1␤  in block <anon> at /tmp/Tv1fGPxYEY:1␤␤»

[15:09] <moritz> nom: class A { has $.priv; method !priv() is rw { $!priv }; method a(A $x) { $x!A::priv = 5 ; say $x.priv} }; say A.new.a(A.new)

[15:09] <p6eval> rakudo 1a468d: OUTPUT«Cannot assign to a readonly variable or a value␤  in method a at /tmp/1P2Tpk_SeG:1␤  in block <anon> at /tmp/1P2Tpk_SeG:1␤␤»

[15:10] <felher> moritz: maybe i'm wrong but did you really want to try 'has $.priv' istead of 'has $!priv'?

[15:10] <moritz> felher: yes, because I wanted the accessor for reading the result :-)

[15:10] <felher> moritz: ah, i see :)

[15:10] <moritz> felher: but since the accessor is RO, it doesn't harm here

[15:12] <masak> niecza: class A { has $.priv; method a(A $x) { $x!A::priv = 5 ; say $x.priv} }; say A.new.a(A.new)

[15:12] <p6eval> niecza v15-4-g1f35f89: OUTPUT«5␤True␤»

[15:12] <masak> so, I guess what I'm saying is I'm with Niecza++ on this one.

[15:13] *** geekosaur joined
[15:14] *** tokuhiro_ joined
[15:14] <felher> niecza: class A { has $!priv; method test() { my A $a .= new(); $a!priv = 3; } }; A.test();

[15:14] <p6eval> niecza v15-4-g1f35f89:  ( no output )

[15:14] <felher> \o/ :)

[15:15] *** araujo joined
[15:15] *** araujo left
[15:15] *** araujo joined
[15:16] <moritz> nom: role A[::T $] { also is T }; class B { }; class C does A[B] { }; say C ~~ B

[15:16] <p6eval> rakudo 1a468d: OUTPUT«===SORRY!===␤Cannot type check against type variable T␤»

[15:16] *** araujo left
[15:16] <moritz> that's... somwhere between LTA and wrong, I'm not sure where exactly it is :-)

[15:18] *** birdwind1pbird left
[15:19] * masak submits rakudobug

[15:19] <moritz> n: role A[::T $] { also is T }; class B { }; class C does A[B] { }; say C ~~ B

[15:19] <p6eval> niecza v15-4-g1f35f89: OUTPUT«===SORRY!===␤␤GLOBAL::T does not name any package at /tmp/8ui7SHbKPA line 1:␤------> role A[::T⏏ $] { also is T }; class B { }; class C ␤␤A type must be provided at /tmp/8ui7SHbKPA line 1:␤------> role A[::T⏏[…

[15:20] <masak> n: class A { has $!priv }; sub test() { my A $a .= new(); $a!priv = 3 }; test(); say "alive"

[15:20] <moritz> why does it need to name a package for inheritance?

[15:20] <p6eval> niecza v15-4-g1f35f89: OUTPUT«===SORRY!===␤␤Cannot resolve class for private method at /tmp/AeYxRVjBCp line 1:␤------> ; sub test() { my A $a .= new(); $a!priv⏏ = 3 }; test(); say "alive"␤␤Unhandled exception: Unable to resolve method kind in class A…

[15:21] <moritz> note that the type constraint allows subclasses too

[15:22] <moritz> which is why it wouldn't be sufficient for resolving private attributes, even if the compiler was sufficiently smart

[15:24] *** araujo joined
[15:24] <moritz> on a completely different topic, S12 says that 'self' is always assumed to be in item context

[15:24] <moritz> why is that the case? that's the role of the $ sigil, which isn't there on 'self'

[15:26] <masak> the role of the $ sigil is forcing item context.

[15:26] <masak> 'self', by current spec, has that built-in.

[15:27] <moritz> yes, but why?

[15:27] <masak> I don't know. maybe because of some psychological expectation that 'self' is a single thing?

[15:28] <moritz> we've extra eliminiated the $ from (|$foo) variables, because it doesn't fit the "$ means item" philosphy

[15:28] <masak> do you have a use case where 'self' being in item context is cumbersome or unfortunate?

[15:28] <masak> can you *guarantee* that a lot of existing Perl 6 code (in CORE, for example) doesn't rely on the assumption that 'self' is in item context? :)

[15:29] <moritz> r: my @a = 1, 2; .say for @a.push: 3

[15:29] <p6eval> rakudo 1a468d: OUTPUT«1␤2␤3␤»

[15:30] <moritz> push simply returns self. Very convenient, and only possible because rakudo doesn't enforce the contnext

[15:30] <masak> by the way, I wrote a blog post last week that was published today. it has vibes of #perl6 in it. some of you might find it pleasant reading: http://blog.edument.se/2012/03/21/how-to-think-better-about-code-and-be-more-effective/

[15:30] <masak> moritz: so you're saying that Rakudo isn't to spec in that regard?

[15:31] <moritz> masak: correct

[15:31] * masak submits rakudobug

[15:31] * masak grins

[15:31] *** havenn left
[15:31] <moritz> nom: class A is Array { method identity { self } }; my @a := A.new; @a = 3, 4, 5; .say for @a.identity

[15:31] <p6eval> rakudo 1a468d: OUTPUT«3␤4␤5␤»

[15:31] <benabik> r: my @a = 1,2; .say for $(@a.push: 3)

[15:31] <p6eval> rakudo 1a468d: OUTPUT«1 2 3␤»

[15:31] <moritz> there you go, without reference to any core thing

[15:36] <masak> moritz: does Niecza mandate item context for 'self'? if it doesn't, I say excise the wording from the spec. if it does, what spectests does Niecza fail if the itemization logic is removed?

[15:37] <moritz> n: class A is Array { method identity { self } }; my @a := A.new; @a = 3, 4, 5; .say for @a.identity

[15:37] <p6eval> niecza v15-4-g1f35f89: OUTPUT«3 4 5␤»

[15:37] <moritz> it does itemize

[15:43] *** mj41_nb left
[15:46] *** tokuhiro_ left
[15:46] *** Psyche^ joined
[15:47] *** tokuhiro_ joined
[15:47] *** mj41 joined
[15:50] *** Patterner left
[15:50] *** Psyche^ is now known as Patterner

[15:50] *** birdwind1pbird joined
[15:51] *** tokuhiro_ left
[15:55] *** fgomez left
[15:57] *** birdwind1pbird left
[16:05] <sorear> good * #perl6

[16:06] <masak> sorear! \o/

[16:07] *** fgomez joined
[16:08] <sorear> niecza: class A is Array { method identity { self } }; my @a := A.new; @a = 3,4,5; .say for @a.identity; my $x = $a; .say for $x.identity

[16:08] <p6eval> niecza v15-4-g1f35f89: OUTPUT«===SORRY!===␤␤Variable $a is not predeclared (did you mean @a?) at /tmp/f6713e9Jxn line 1:␤------>  = 3,4,5; .say for @a.identity; my $x = ⏏$a; .say for $x.identity␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/n…

[16:09] <sorear> niecza: class A is Array { method identity(\:) { self } }; my @a := A.new; @a = 3,4,5; .say for @a.identity; my $x = @a; .say for $x.identity

[16:09] <p6eval> niecza v15-4-g1f35f89: OUTPUT«3␤4␤5␤3 4 5␤»

[16:09] <sorear> masak, is that what you really want?

[16:10] *** plobsing left
[16:11] <masak> I think so, yes. moritz++ managed to sway me.

[16:11] <masak> at least until I see a good use case for "self forces item context".

[16:15] *** rhr left
[16:18] <fglock> pmurias: t/base/lex.t parses now

[16:19] *** araujo left
[16:20] *** rhr joined
[16:29] *** pyrimidine1 is now known as pyrimidine

[16:33] *** fglock left
[16:33] *** pyrimidine left
[16:34] *** pyrimidine joined
[16:40] *** havenn joined
[16:42] *** araujo joined
[16:42] *** araujo left
[16:42] *** araujo joined
[16:48] *** colomon left
[16:51] *** ponbiki joined
[16:51] *** araujo left
[16:51] *** shinobicl_ joined
[16:52] *** araujo joined
[16:52] *** araujo left
[16:52] *** araujo joined
[16:53] *** daxim left
[16:53] *** shinobicl left
[16:54] *** envi_ left
[16:54] *** envi_ joined
[17:02] * masak decommutes

[17:03] *** fglock joined
[17:11] *** mj41 left
[17:12] *** birdwindupbird left
[17:13] *** havenn left
[17:14] <felher> Can i tell a hash to throw a exception if i try to read a element that he doesn't have? So that 'my %hash; say %hash<x>;' throws an exception?

[17:15] *** NamelessTee joined
[17:18] *** havenn joined
[17:19] *** ponbiki left
[17:20] <sorear> felher: no.

[17:20] <sorear> especially because reading and writing are the same.

[17:21] <benabik> I wonder if you could get it to return a Failure on FETCH.

[17:22] <moritz> that's probably doable

[17:22] <moritz> though of course it doesn't mix with autovivifcation

[17:22] <moritz> if you do something like %h<a>[1] = 0; , it will call method postcircumfix:<[ ]> on the return value from %h<a>

[17:22] <moritz> and if that's a Failure -> BOOM

[17:23] <benabik> Point.

[17:23] *** MayDaniel joined
[17:26] <felher> sorear: reading and writing is the same, because %hash<x> returns and value that i can assign something in every case. So 'say %hash<a>' is just a special case, where i don't use the value for assignment?

[17:26] <felher> Maybe 'returns a container' is better that 'returns a value'

[17:27] <moritz> well, the container contains the value

[17:27] <benabik> Isn't there a way to specify a default value for a hash?  You could default it to Failure.new(:message => 'Item not in hash'), no?

[17:27] <moritz> and say() is only interested in the value, not the container

[17:27] <benabik> (Yes this wouldn't work with auto-viv, but you're asking for it.)

[17:28] <sorear> returning a Failure is much less useful than throwing an exception

[17:29] <sorear> esp. since, by my reading of S04, most of the magic is in &fail

[17:29] <benabik> Seemed like the easiest way to get reads to throw and writes not to.

[17:29] <sorear> dumbly &return-ing a thing which happens to be a Failure will not do anything useful in most cases

[17:30] <moritz> well, &fail just constructs a Failure object and returns the current routine

[17:30] <sorear> reads won't throw at all

[17:30] <moritz> you could, in theory, return a proxy that dies on FETCH

[17:31] <benabik> It would throw when you attempt to use the value, no?  That's pretty close to 'throw on read', I think..

[17:38] *** havenn left
[17:38] *** kaare_ joined
[17:40] <felher> benabik: the problem is: the function that accesses the hash only assigns it to variables. I will then die later in another part of the code, which probably doesn't have the knowledge to give a good error message.

[17:41] <felher> I could write a ' || die ' at the end of every assignment, though... or derive from hash and let the new class throw the exception.

[17:41] <sorear> // die better

[17:42] <benabik> I've seen C++ comments like that.

[17:42] <moritz> if you do it inside the hash (or derived class), you can get nice X::Hash::NoSuchKey(key => $yourkey) errors out of it

[17:43] <felher> benabik: comments like what? And which part is it where you think i'm wrong?

[17:44] <benabik> felher: // die better

[17:44] *** havenn joined
[17:44] <felher> benabik: ah, okay :)

[17:45] <felher> sorear: yeah, right '//' is bettern than '||' :)

[17:47] <felher> moritz: tempting :)

[17:49] <sorear> commute&

[17:54] *** Ulti left
[17:58] <felher> I have a constructor in C++, e.g. "Class(int 3)", and function that needs an argument of type "Class", e.g. : "printClass(Class a) {...}". Then i can write "printClass(3)", because C++ knows that it can convert 3 to Class using the "Class(int e)"-Construcutor. Is that possible in Perl6, too?

[17:59] <felher> Because then i could write: "method doSomethingWithTheHash(AutodieHash %hash)" and put normal %hahes in it... :)

[18:00] *** pernatiy left
[18:00] <felher> Maybe that should be: "is something like that possible in Perl6", since the default constructor concept ist quite different from C++'s :)

[18:00] <moritz> felher: https://gist.github.com/2150358

[18:01] <felher> moritz: omg, that is so cute :)

[18:01] <felher> moritz++, thnx :)

[18:02] <moritz> well, there's the coercion syntax

[18:02] <felher> moritz: but regarding "%h does safety". I thoug "but" is for runtime-mixin of roles into objects?

[18:02] <benabik> IIRC, but returns a new object and does mixes into the existing one.

[18:02] <moritz> felher: 'does' is like 'but', but in-place

[18:02] <felher> moritz: oh, sweet :)

[18:02] <benabik> does is but=

[18:02] <moritz> benabik++ is right

[18:03] <felher> benabik: thanks :)

[18:03] <moritz> benabik: under the hood there are fine differences

[18:03] <moritz> like, 'does' doesn't do any assignment

[18:03] <benabik> moritz: True.  Does but= even work?

[18:04] <moritz> no idea

[18:04] <benabik> r: role Foo {}; my @a; @a but= Foo

[18:04] <p6eval> rakudo 1a468d:  ( no output )

[18:04] <benabik> r: role Foo { method a() { say 'yes' } }; my @a; @a but= Foo; @a.a

[18:04] <p6eval> rakudo 1a468d: OUTPUT«Method 'a' not found for invocant of class 'Array'␤  in block <anon> at /tmp/LTY5dZWRk5:1␤␤»

[18:04] <moritz> felher: you do so something like   class SafeHash is Hash does safety { method &.(*@a) { coercion here } } 

[18:04] <benabik> Oh.  It probably does @a = @a but Foo, which just re-stores the contents.

[18:05] *** dakkar left
[18:05] <moritz> felher: then you can write SafeHash(%other) and get a SafeHash back

[18:05] *** tyatpi joined
[18:05] <moritz> benabik: though in rakudo, 'does' is the more primitive operation, and 'but' is basically   $lhs.clone does $rhs

[18:06] *** am0c left
[18:06] <felher> moritz: nice, thanks. I guess S13 is the right address, if want to know more about that? :)

[18:06] <moritz> felher: and S02 maybe

[18:06] <moritz> anyway, I was quite surprised how that 'safety' role was

[18:06] <moritz> it worked on first try

[18:07] <moritz> though notice that it's expensive, it creates a new object for every access

[18:11] <felher> moritz: couldn't one write something like: "if !self.exists($key) { die "blubb" } else { return nextsame($key) }" or something like that? Like delegating to the original at_key-method?

[18:12] <Juerd> sorear: Anyone can get an account on feather1, and it's not very secured. As a result, it was not very practical to host production websites (and, back then, an svn server) on it. It's easy to over-load feather1, and that would also bring down sites like perl6.org

[18:12] *** mucker left
[18:12] <Juerd> sorear: The virtual machine feather3 is for evalbots, which are very insecure in nature as they allow arbitrary code execution to unauthenticated users by design.

[18:13] <moritz> Juerd: I guess I should try to set up the build environment on feather1, and run evalbot on feather3

[18:13] <moritz> Juerd: if I run into any limitations, I'll tell you

[18:13] <Juerd> moritz: That solution definitely has my preference and fits the separation's intent.

[18:14] <felher> moritz: ah, obvisly not... assignment would never work, then...

[18:14] <Juerd> I guess rsync over ssh will probably be an easy way to copy the binaries to feather3

[18:14] <Juerd> But use any solution you like

[18:16] <tadzik> good evening

[18:16] <felher> o/

[18:19] <moritz> Juerd: yes, it just requires me to put a passwordless ssh key on feather1. Not a great solution, but well, feather3 isn't secure anyway

[18:20] <Juerd> moritz: Feel free to create a separate user account for this, on feather1, 3, or both

[18:20] <moritz> both, for sure

[18:28] *** tarch left
[18:39] *** Vespakoen left
[18:39] *** shinobicl joined
[18:39] *** Vespakoen joined
[18:41] *** shinobicl_ left
[18:44] *** litejk joined
[18:44] *** litejk left
[18:46] <TimToady> felher: if a failure propagates to a different part of the code and dies, it's supposed to have enough internal info to tell you what went wrong originally

[18:47] *** wolfman2000 joined
[18:51] <felher> TimToady: I see, but ... i really have to catch the bus... :)

[18:51] * felher off 'til home

[18:52] *** mj41 joined
[18:54] <TimToady> sorear: exceptions are not better than failure under a dataflow paradigm

[18:55] *** MayDaniel left
[18:55] *** colomon joined
[18:56] <TimToady> exceptions are a good example of hanging semantics on the wrong peg at least some of the time

[18:58] <TimToady> I think overuse of exceptions is one of the traps of the imperative paradigm

[18:59] <TimToady> control flow tends to make dataflow unanalyzable

[19:00] *** birdwindupbird joined
[19:03] *** libertyprime joined
[19:06] *** tyatpi left
[19:17] *** GlitchMr joined
[19:17] *** envi_ left
[19:19] *** tyatpi joined
[19:20] <TimToady> I agree with the feeling that self should behave like a \self binding on the invocant and not itemize

[19:21] <moritz> \o/

[19:22] <moritz> TimToady: do you have any wisdom to share about what happens under the hood when 'use Module <argumentlist>;' is executed?

[19:22] <moritz> TimToady: ie, which part of the module gets the argumentlist?

[19:22] <moritz> sorry for fast context switching :-)

[19:25] <TimToady> well, 'use' breaks down into a 'need' and an 'import'

[19:28] <TimToady> STD currently treats those as primitives that look for a module's export declarations in an EXPORT package

[19:28] <TimToady> there's no call into the module, per se

[19:29] <TimToady> I think rakudo handles this with the metaobject somehow

[19:29] *** havenn left
[19:29] <moritz> if we want   use lib $path;  to work, we need some kind of call into the module

[19:30] <TimToady> if there's actually going to be code run at import time, I think we should treat use/import as a funny kind of macro call

[19:31] <TimToady> that can work either hygienically or not (or as a hybrid, partly text and partly AST)

[19:32] <TimToady> one could imagine doing import with a textual 'my $foo := Their::Export::<$foo>' of some sort, in the limiting case

[19:33] <TimToady> *EXPORT

[19:33] <moritz> that would also explain how to do export a CATCH or CONTROL block, for example

[19:33] <TimToady> (though I think EXPORT is lexically scoped, so you'd need a magical accessor)

[19:34] <TimToady> you can basically do anything with a macro-view of importation

[19:34] *** GlitchMr42 joined
[19:34] <TimToady> it seems like a good unification to not reinvent the macro wheel badly

[19:35] *** GlitchMr left
[19:35] <TimToady> of course, the defaults should still encourage people to be as hygienic as possible

[19:36] <moritz> that sounds surprisingly sane

[19:36] <moritz> I'd like to hear what masak++ has to say about it

[19:36] <TimToady> so from the viewpoint of the module-macro, it's more like COMPILING:<$foo> := $foo

[19:37] <TimToady> *::

[19:37] *** lichtkind joined
[19:38] <TimToady> I've been thinking of 'use Stuff <a b c>' as a funny-looking macro call for a year or two or three now

[19:38] *** GlitchMr42 is now known as GlitchMr

[19:40] <TimToady> nap &

[19:41] <lichtkind> good night :)

[19:41] <lichtkind> are the planned actors in perl 6?

[19:41] <lichtkind> shii found incredible stupid typos

[19:41] *** fgomez_ joined
[19:41] *** fgomez_ left
[19:41] *** fgomez left
[19:45] *** fgomez joined
[19:47] *** ksi joined
[19:49] *** wolfman2000 left
[19:53] <fglock> 149 tests pass # perlito5 running perl5 test suite; this is not much, but these tests are hard :P

[20:06] *** leprevost left
[20:06] *** bacek left
[20:07] *** Chillance left
[20:08] *** Chillance joined
[20:09] <ashleydev> fglock++

[20:12] <lichtkind> fglock++

[20:14] <fglock> pmurias++ # added node.js support

[20:17] *** birdwindupbird left
[20:22] *** bacek joined
[20:23] <masak> what do I think of it? I think it sounds sane, but that it's hard to tell with just the skeleton of an idea.

[20:23] <masak> most uses/examples of Perl 6 macros out there are a combination of fantasy and misunderstanding :)

[20:24] <masak> outline the mechanism in as much detail as you can, and then we can talk about it.

[20:25] <masak> I'm not sure 'use Foo;' could be an AST macro, because it contains an undeclared bareword Foo.

[20:26] * masak looks forward to the coming of the age when "it's a macro" stops meaning something abstract and starts meaning something concrete

[20:27] *** pernatiy joined
[20:28] <moritz> it might need to be "is parsed"

[20:28] <masak> yeah, I'm not going near that.

[20:29] <masak> maybe in another grant, but I suspect beer isn't gonna be convincing enough for that...

[20:30] <masak> the thing with "is parsed" macros is that *anything* is potentially an "is parsed" macro.

[20:30] <moritz> if!

[20:30] <moritz> for!

[20:31] <masak> those two are innocent enough to be AST macros, even.

[20:31] <moritz> uhm

[20:31] <masak> hm, almost :)

[20:31] <moritz> they have TTIAR

[20:31] <masak> yeah, just (re-)noticed :)

[20:31] <masak> apart from that :)

[20:33] <masak> there could even be an intermediate form, something like a "mostly AST"/"only slightly 'is parsed'" macros, that let you write stuff like TTIAR and the parser will turn a blind eye because it's already seen the macro name.

[20:33] *** pernatiy left
[20:33] <moritz> niecza: sub term:<--->() { say 'foo' }; ---

[20:33] <p6eval> niecza v15-4-g1f35f89: OUTPUT«foo␤»

[20:34] <moritz> niecza: sub term:<--->($x) { say 'foo' }; --- 3

[20:34] <p6eval> niecza v15-4-g1f35f89: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/OrpZNtH7Pb line 1:␤------> sub term:<--->($x) { say 'foo' }; --- ⏏3␤Other potential difficulties:␤  $x is declared but not used at /tmp/OrpZNtH7Pb line 1:␤------> sub term:<-…

[20:34] <moritz> ok, thought so

[20:35] *** ponbiki joined
[20:38] *** ponbiki left
[20:44] *** fsergot joined
[20:44] <fsergot> hi o/

[20:44] <phenny> fsergot: 19 Mar 16:56Z <sjn> tell fsergot https://gist.github.com/1711730 for your register-joyment :)

[20:45] <tadzik> hi fsergot 

[20:46] <masak> fsergot! \o/

[20:47] <masak> I mean, dobry wiecz?r, o fsergotu.

[20:48] <fsergot> nice masak. \o/

[20:48] <fsergot> :-)

[20:49] <masak> tadzik-san taught me ;)

[20:49] <tadzik> masak: I think it'd be like "o fsergocie" :)

[20:49] <masak> oh, ok :/

[20:50] <tadzik> but given the fact that "fsergot" is not a Polish word known to me, you can choose whatever you want :)

[20:50] * masak .oO( I must've fsergocie the rules... )

[20:50] <tadzik> -u works for Królu, but I don't think that's regular at all, actually

[20:51] <tadzik> O Tadeuszu, but O Filipie

[20:51] <tadzik> probably there's some rule for this, but I never had a head for grammar rules

[20:51] <masak> in other news, the strained multilingual puns will be delivered by me for the duration of jnthn's absence, to the best of my ability, which isn't much... :P

[20:51] <tadzik> I consider myself well entertained :)

[20:52] <masak> it's grammar-tainment hour!

[20:54] <masak> tadzik: I felt I "got" grammar when I realized that it's just a description framework for how language behaves, just as math is "just" a description framework for number-like things behave.

[20:54] *** y3llow_ joined
[20:54] *** bruges_ joined
[20:56] *** y3llow left
[20:57] *** bruges left
[20:57] *** y3llow_ is now known as y3llow

[20:58] <tadzik> I guess so. It's just that it was always easier for me to just use it long enough to grok it instinctiv...something

[20:59] *** skids left
[20:59] <masak> to me, that's like saying "I never bothered about the principles of addition and multiplication, I just looked at enough examples until it fell into place".

[20:59] <tadzik> heh

[21:00] <tadzik> well, I learned Polish the very same way :)

[21:00] <masak> but then, I'm fascinated by grammar as a phenomenon because I find it cool that such a thing even exists.

[21:01] <masak> in the worst case, we might've been stranded with having to haphazardly stringing words together, trying to convery some nebulous "meaning" through juxtaposition and sheer wearing down of the listener.

[21:01] <tadzik> yeah, it's interesting. Like, the languages probably evolve mostly on their own, and still you're able to write a strangely consistent spec for them

[21:02] *** ksi left
[21:02] <masak> instead, we have a framework with which to structure utterances according to fixed, explainable rules. and people who grok the rules are richer, more successful, and more beautiful than those who don't.

[21:02] <masak> or so I've heard.

[21:03] <masak> but srsly, language is one of the chief assets of a programmer. and there are probably few better forums to express that idea than #perl6 :)

[21:04] *** icwiener left
[21:04] <masak> sometimes I think that if it was Perl 5's mission to export effective "text munging" in its various forms to the world, it's Perl 6's mission to export effective "language munging" to the world.

[21:05] *** GlitchMr left
[21:07] <masak> ooh, nice p6l thread.

[21:07] <felher> nom: my @array; say @array[4];

[21:07] <masak> probably belonged to p6u, but who cares.

[21:07] <p6eval> rakudo 1a468d: OUTPUT«Any()␤»

[21:07] <felher> nom: my @array; say @array[*-1];

[21:07] <p6eval> rakudo 1a468d: OUTPUT«Failure.new(exception => X::AdHoc.new(payload => "Cannot use negative index -1 on Array"))␤»

[21:08] * felher hoped for 'Any', too

[21:10] <masak> probably it's * getting expanded as 0, and then the failure triggers (wrongly)

[21:10] <masak> it could be argued that it should never trigger for whatever-y expressions.

[21:11] * masak submits rakudobug

[21:13] <felher> \o/

[21:19] <colomon> perl6: say Inf.WHAT

[21:19] <jnthn> Hm, you indexed into it with -1...isn't that a reasonable error? :)

[21:19] <p6eval> rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«Num()␤»

[21:19] <p6eval> ..pugs: OUTPUT«Num␤»

[21:20] <masak> jnthn: no, the thing that is forbidden is writing .[-1] -- we want to catch people who *don't know that it's deprecated syntax*

[21:20] <masak> jnthn: people who write .[*-1] clearly got the memo.

[21:21] <jnthn> nom: my @array; say @array[*-2] 

[21:21] <p6eval> rakudo 1a468d: OUTPUT«Failure.new(exception => X::AdHoc.new(payload => "Cannot use negative index -2 on Array"))␤»

[21:22] <jnthn> I fear [*-x] may do the computation and delegate to .[result]

[21:22] *** fglock left
[21:23] <jnthn> And the latter throws the error

[21:23] <masak> that would explain Rakudo's less-than-correct behaviour, for sure. :)

[21:23] <jnthn> Anyway, it's all written in Perl 6 in the setting for anybody who wants to twiddle :)

[21:25] <jnthn> masak: I'm rather dubious about "less-than-correct" or about returning Any for something that is almost certainly an out of bounds bug, rather than a Failure that definedness tests in the right way but flags up the error if you expect it to be a value.

[21:25] <jnthn> I think Rakudo's behavior could be argued to be helpful.

[21:26] <masak> aye. I'm playing Debby's avocado here.

[21:27] <jnthn> I'm not going to argue strongly either way. I just don't find it obvious that Rakudo's behavior is less than correct. :)_

[21:27] <jnthn> Unless you have a handy spec reference. :)

[21:29] <masak> well, S09 already allows arrays with negative indices, so it's not forbidden per se.

[21:29] <jnthn> Right,  but in that case you'd have declared it

[21:30] <jnthn> Also, we won't be expecting arrays that are fixed length to just return Any when you index outside of that bound, surely.

[21:31] <masak> no, that probably throws.

[21:32] <masak> so you're basically arguing that ordinary arrays are "semi-fixed" in length, in that they implicitly declare themselves never to have negative indices?

[21:32] <masak> if so, fair enough. that's a consistent argument.

[21:33] <jnthn> masak: Yes, that's my argument

[21:36] *** pmurias left
[21:47] *** havenn joined
[21:53] *** xenu left
[22:02] *** cogno joined
[22:09] *** shinobicl left
[22:12] *** benabik left
[22:13] *** cogno left
[22:18] *** cogno joined
[22:20] *** plobsing joined
[22:21] *** NamelessTee left
[22:24] *** REPLeffect joined
[22:28] <sorear> good * #perl6

[22:29] <masak> sorear! \o/

[22:30] *** tyatpi left
[22:30] <masak> 'night, #perl6

[22:30] <sorear> I agree that exceptions aren't so hot for dataflow, but I'm still not convinced Failure can be made better :|

[22:31] <sorear> night masak.

[22:36] *** snearch joined
[22:37] *** M_o_C joined
[22:38] *** cogno left
[22:39] *** M_o_C left
[22:40] <colomon> \o

[22:40] <sorear> o/ colomon 

[22:41] *** sftp left
[22:42] *** skids joined
[22:48] *** sftp joined
[22:52] *** kaare_ left
[22:53] *** mj41 left
[23:03] *** xenu joined
[23:04] *** xenu is now known as Guest18260

[23:15] *** nebuchadnezzar left
[23:15] *** havenn left
[23:21] *** PacoAir left
[23:27] *** lichtkind left
[23:28] *** thou left
[23:29] *** mdupont left
[23:30] *** thou joined
[23:32] *** thou left
[23:42] *** snearch left
[23:44] *** whiteknight joined
[23:53] *** shinobicl___ joined
