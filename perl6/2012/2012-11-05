[00:00] <azawawi> consider running farabi6 inside a directory with fewer files/directories... i.e. not $HOME

[00:00] <azawawi> to test open file "autocomplete" feature

[00:02] <azawawi> sorear: Hi. How safe is {Niecza --safe}? 

[00:03] *** cognominal left
[00:04] *** sftp joined
[00:08] <azawawi> remind me again, where is the rakudo perl 6 safe mode code?

[00:09] <azawawi> nevermind, found it... https://github.com/moritz/try.rakudo.org/blob/master/backend/p6safe.pl

[00:10] <sorear> Niecza --safe is a quick hack and should never be used to protect a valuable system; it operates at far too high a level

[00:11] <sorear> properly sandboxing perl 6 should be done at the VM level or below (ideally seccomp)

[00:11] <tadzik> azawawi: I don't think that's the way to do it

[00:11] <tadzik> there is SAFE.setting for this these days

[00:11] <tadzik> https://github.com/rakudo/rakudo/blob/nom/src/SAFE.setting

[00:12] <tadzik> which apparently is deprecated in favor of https://github.com/rakudo/rakudo/blob/nom/src/RESTRICTED.setting

[00:12] <azawawi> :)

[00:12] <azawawi> i think the wording 'restricted' is better than 'safe'

[00:13] *** cognominal joined
[00:13] <azawawi> sorear: thx

[00:15] *** kshannon joined
[00:15] <azawawi> tadzik: any idea how to use it? :)

[00:15] *** benabik joined
[00:18] <azawawi> hmm i will add $FARABI6_INSECURE which is by default disabled...

[00:19] *** armitage81 joined
[00:20] *** armitage81 left
[00:20] *** armitage81 joined
[00:21] *** snearch left
[00:30] <azawawi> FARABI6_UNSAFE=1 farabi6  # enable unsafe mode... i.e. run local code  

[00:38] *** kda left
[00:53] *** rindolf left
[00:56] *** daniel-s_ is now known as daniel-s

[01:00] *** tokuhiro_ joined
[01:02] <azawawi> hmmm... http::server::simple and firefox = crash

[01:02] <azawawi> i was wondering why farabi6 kept crashing randomly

[01:04] *** bowtie left
[01:04] *** DarthGandalf left
[01:05] *** Chillance left
[01:07] *** kcwu left
[01:09] *** DarthGandalf joined
[01:30] <diakopter> I had a dream that the Rakudo team implored me to "please stop finding/submitting [WEIRD] rakudobugs"

[01:31] <diakopter> (it was an ego-boosting dream, I guess)

[01:40] <diakopter> r: my $a = .HOW.new(); say $a.^methods

[01:40] <p6eval> rakudo 64208d: OUTPUT«No such method 'gist' for invocant of type 'NQPRoutine'␤  in method gist at src/gen/CORE.setting:4875␤  in sub say at src/gen/CORE.setting:7304␤  in block  at /tmp/zGdVxRn9kr:1␤␤»

[01:41] <diakopter> boo. I wanna see ClassHOW methods

[01:41] <diakopter> r: my $a = .HOW.new(); print $a.^methods

[01:41] <p6eval> rakudo 64208d: OUTPUT«Nominal type check failed for parameter '$got'; expected Any but got NQPRoutine instead␤  in method REIFY at src/gen/CORE.setting:6091␤  in method reify at src/gen/CORE.setting:5247␤  in method gimme at src/gen/CORE.setting:5612␤  in method print at src/gen/CORE.se…

[01:42] *** fgomez left
[01:42] *** dayangkun joined
[01:43] <diakopter> r: my $a = .HOW.new(); .($a) for $a.^methods

[01:43] <p6eval> rakudo 64208d: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in any set_invoke_forwarder at src/gen/Metamodel.pm:2207␤  in block  at /tmp/WcpjEgyZDO:1␤␤»

[01:43] <diakopter> r: my $a = .HOW.new(); .($a, $a) for $a.^methods

[01:43] <p6eval> rakudo 64208d: OUTPUT«too many positional arguments: 2 passed, 1 expected␤  in any archetypes at src/gen/Metamodel.pm:2203␤  in block  at /tmp/id6bir1sfS:1␤␤»

[01:43] <diakopter> set_invoke_forwarder and archetypes seem pretty leaky to me.

[01:43] <diakopter> phenny: tell masak please see here VVDKVMLRSNCD in the logs

[01:43] <phenny> diakopter: I'll pass that on when masak is around.

[01:47] <azawawi> http://feather.perl6.nl:3030/  # Farabi6 with the new Run dialog and Open dialog... feedback appreciated... Firefox crashes HTTP::Server::Simple server... hence please use Chrome or something else... Have fun

[01:49] <azawawi> farabi6 server now restarts itself... just in case :)

[01:54] * azawawi sleep &

[01:54] *** azawawi left
[01:55] *** fgomez joined
[01:59] *** hypolin joined
[01:59] <skids> https://gist.github.com/4014812 # workaround for crony roles used more than once

[02:03] *** kcwu joined
[02:06] *** chee joined
[02:15] *** leont left
[02:22] *** whiteknight left
[02:28] *** sizz_ joined
[02:28] *** sizz left
[02:30] *** cognominal left
[02:32] *** armitage81 left
[02:37] *** tokuhiro_ left
[02:55] *** araujo left
[02:57] *** araujo joined
[03:26] *** fgomez left
[03:26] *** dayangkun left
[03:34] *** dayangkun joined
[03:35] *** dayangkun left
[03:36] *** dayangkun joined
[04:11] *** raiph joined
[04:33] <raiph> phenny, tell azawawi Syntax Check (F6) seems to do nothing; Rakudo and Niecza give "ENV{FARABI6_UNSAFE} is not enabled"; If I click in text area when a menu (File, Build...) is dropped, that menu disappears and will no longer drop. (Have to refresh page to clear.) (From Chrome's about: "10.0.648.82 (75062) Built on Joli OS 1.2, running on Joli OS 1.2")

[04:33] <phenny> raiph: I'll pass that on when azawawi is around.

[04:34] <raiph> exit

[04:35] <raiph> heh. goodnight #perl6...

[04:35] *** raiph left
[04:44] *** havenn joined
[05:10] *** plobsing left
[05:23] *** telex left
[05:25] *** telex joined
[05:30] *** telex left
[05:37] *** telex joined
[05:52] *** fgomez joined
[05:57] *** SamuraiJack joined
[06:24] *** araujo left
[06:24] *** kaleem joined
[06:30] *** skids left
[06:37] *** araujo joined
[06:38] *** havenn left
[06:50] *** azawawi joined
[07:09] *** havenn joined
[07:18] *** havenn left
[07:34] *** bonsaikitten left
[07:35] *** bonsaikitten joined
[07:38] *** domidumont joined
[07:43] <azawawi> hi

[07:43] <phenny> azawawi: 04:33Z <raiph> tell azawawi Syntax Check (F6) seems to do nothing; Rakudo and Niecza give "ENV{FARABI6_UNSAFE} is not enabled"; If I click in text area when a menu (File, Build...) is dropped, that menu disappears and will no longer drop. (Have to refresh page to clear.) (From Chrome's about: "10.0.648.82 (75062) Built on Joli OS 1.2, running on Joli OS 1.2")

[07:44] *** domidumont left
[07:45] <moritz> \o

[07:45] <phenny> moritz: 04 Nov 01:38Z <[Coke]> ask moritz you added S03-operators/andthen.t to rakudo's spectest - did you forget to push the test file?

[07:46] <moritz> seems like, yes

[07:46] <azawawi> phenny: tell raiph 1. very old chrome version, F6 at the moment does not do anything when there is no error. Try it with some errors in it. You can install Farabi6 to test it on your machine and set FARABI6_UNSAFE=1

[07:46] <phenny> azawawi: I'll pass that on when raiph is around.

[07:46] <azawawi> moritz: hi

[07:46] <moritz> unfortunately I just moved to a different flat, and won't have internet access until 2012-11-12 or so

[07:47] <moritz> hi azawawi 

[07:51] <azawawi> Niecza wins on ease of installation (provided you install mono first... a lot of time wasted there)

[07:52] <azawawi> Rakudo wins on completeness and modules support.. You lose a lot of time building a rakudo star though

[07:52] <azawawi> std on the near perfect error message support. make takes a bit of time though. TimToady++

[07:52] <bonsaikitten> azawawi: both are trivial to install

[07:53] <azawawi> im thinking from a user's point of view

[07:53] <azawawi> how much time is spent doing task X before using starting with real programming perl6 task

[07:54] <moritz> we really want to do be able to install it with 'apt-get install rakudo'

[07:54] <moritz> and on windows there's an .msi

[07:54] <bonsaikitten> "emerge niecza rakudo" <-- problem solved ;)

[07:55] <azawawi> installation time... apt-get solves it... emerge = build time

[07:55] *** hoelzro|away is now known as hoelzro

[07:55] <bonsaikitten> azawawi: only if you don't have binpkgs already (and apt-get is really bad with some common issues)

[07:56] <azawawi> bonsaikitten: true but a binary package is really handy...

[07:57] <bonsaikitten> azawawi: takes me 8 minutes to build *and* run tests

[07:57] <azawawi> moritz: how do i get the p6doc index? i need it for help index autocompletion and F1 context help

[07:57] <bonsaikitten> azawawi: that's a tolerable tradeoff if I get a recent version out of it

[07:58] <azawawi> programmers are lazy... :)

[07:59] * azawawi is building rakudo on feather3 for farabi6 auto deployment

[07:59] <moritz> azawawi: the best option is probably to hack htmlify to dump the index as .json or so

[07:59] <jnthn> morninä

[08:00] <jnthn> .oO( this is not the keyboard layout you are looking for )

[08:01] <moritz> \o

[08:01] <azawawi> moritz: https://github.com/perl6/doc/blob/master/htmlify.pl , right?

[08:01] <moritz> right

[08:01] <jnthn> moritz: oh noes no internets?!

[08:02] <jnthn> Hope you survive :)

[08:02] <azawawi> he did it before if i remember correctly :)

[08:04] *** fhelmberger joined
[08:07] <sorear> o/ jnthn

[08:07] <azawawi> is there a plan/grant to upgrade feather.perl6.nl?

[08:08] <jnthn> hi, sorear 

[08:08] <sorear> feather is a commons sort of thing

[08:08] <sorear> a large number of people are authorized to update it

[08:08] <sorear> so, nobody does

[08:10] *** havenn joined
[08:10] <azawawi> sorear: hardware that is...

[08:13] <azawawi> moritz: what happened to try.rakudo.org? maintenance problems?

[08:13] <moritz> jnthn: only internets at $work

[08:14] <moritz> azawawi: yes; somhow the server hangs up after a few days

[08:14] <moritz> azawawi: and too few people know how to restart it

[08:14] *** havenn left
[08:15] <sorear> is farabi a js app?

[08:16] <sorear> moritz: phew, good to know you won't be going completely dark :D

[08:16] <jnthn> Seems it's about time to start teaching here. bbl :)

[08:18] * azawawi takes a look at try.rakudo.org

[08:19] <azawawi> we have great perl6 evalbot here but nothing exposed to the outside world

[08:19] <azawawi> s/evalbot/eval bots/

[08:20] <sorear> azawawi: what is farabi implemented in?

[08:20] <azawawi> sorear: farabi6 => perl6 + js frontend

[08:20] <azawawi> sorear: farabi (perl 5): perl + mojo + js frontend

[08:21] <sorear> azawawi: I wonder how feasible it would be to run niecza on the client using Silverlight and broker communications through js

[08:21] <azawawi> sorear: interesting

[08:22] <azawawi> sorear: i have done a lot as3 flash programming but silverlight nothing atm

[08:22] <azawawi> sorear: s/a lot/a lot of/

[08:24] *** mhasch joined
[08:24] *** domidumont joined
[08:55] *** sorenso joined
[08:55] *** PZt left
[08:58] *** domidumont left
[08:59] *** domidumont joined
[09:05] *** sorenso left
[09:06] *** sorenso joined
[09:10] *** havenn joined
[09:11] *** Rix left
[09:12] *** Rix joined
[09:15] *** havenn left
[09:21] *** dayangkun left
[09:28] *** flightrecorder joined
[09:33] *** imarcusthis left
[09:36] *** imarcusthis joined
[09:48] *** kresike joined
[09:48] <kresike> hello all you happy perl6 people

[09:48] *** circlepuller left
[09:49] <tadzik> hey kresike 

[09:49] <kresike> tadzik, o/

[09:54] *** circlepuller joined
[09:56] *** azawawi left
[10:02] *** azawawi joined
[10:03] *** leont joined
[10:07] *** leont left
[10:08] *** hypolin left
[10:11] <masak> morning, #perl6

[10:11] <phenny> masak: 01:43Z <diakopter> tell masak please see here VVDKVMLRSNCD in the logs

[10:11] *** havenn joined
[10:11] <masak> (it's OK, I read all of the logs) :)

[10:11] *** fhelmberger left
[10:15] <azawawi> star: "Howdy".say;

[10:15] <p6eval> star 2012.10: OUTPUT«(timeout)»

[10:16] *** havenn left
[10:18] <azawawi> star: "Test".say;

[10:18] <p6eval> star 2012.10: OUTPUT«Test␤»

[10:22] *** sorenso left
[10:30] *** hoelzro left
[10:31] *** hoelzro joined
[10:31] * masak backlogs

[10:31] *** cognominal joined
[10:34] <moritz> star: "Howdy".say;

[10:34] <p6eval> star 2012.10: OUTPUT«Howdy␤»

[10:34] <masak> r: my $a = .HOW.new(); .($a) for $a.^methods

[10:34] <p6eval> rakudo 64208d: OUTPUT«PackFile_unpack: Buffer length 0 is shorter than PACKFILE_HEADER_BYTES 18.␤current instr.: '' pc 4075 (src/gen/perl6-moduleloader.pir:1632) (src/Perl6/ModuleLoader.pm:256)␤called from Sub '' pc 4235 (src/gen/perl6-moduleloader.pir:1692) (src/Perl6/ModuleLoader.pm:2…

[10:34] <masak> r: my $a = .HOW.new(); .($a, $a) for $a.^methods

[10:34] <p6eval> rakudo 64208d: OUTPUT«PackFile_unpack: Buffer length 0 is shorter than PACKFILE_HEADER_BYTES 18.␤current instr.: '' pc 4075 (src/gen/perl6-moduleloader.pir:1632) (src/Perl6/ModuleLoader.pm:256)␤called from Sub '' pc 4235 (src/gen/perl6-moduleloader.pir:1692) (src/Perl6/ModuleLoader.pm:2…

[10:34] <masak> <diakopter> set_invoke_forwarder and archetypes seem pretty leaky to me.

[10:35] <masak> no, I think that's what the methods you're calling might be called.

[10:35] <masak> oh, the above executions failed. wonder why.

[10:36] *** sorenso joined
[10:39] *** PZt joined
[10:39] *** azawawi left
[10:49] *** azawawi joined
[10:53] *** am0c joined
[10:55] <azawawi> http://feather.perl6.nl:8080  # F6 syntax check fixed, Run dialog is more cool :)

[11:01] * masak finds the page https://en.wikipedia.org/wiki/Egbert_B._Gebstadter hilarious

[11:01] *** gootle left
[11:11] *** havenn joined
[11:17] *** havenn left
[11:19] *** hoelzro is now known as hoelzro|away

[11:19] *** arlinius left
[11:36] *** SmokeMachine left
[11:36] *** fgomez left
[11:39] *** SmokeMachine joined
[11:48] *** xdbr joined
[11:50] *** fhelmberger joined
[11:52] *** chee left
[11:55] *** chee joined
[11:59] *** hoelzro|away is now known as hoelzro

[12:12] *** havenn joined
[12:17] *** havenn left
[12:22] *** tokuhiro_ joined
[12:34] *** azawawi left
[12:35] *** bluescreen10 joined
[12:35] *** Psyche^ joined
[12:38] *** Patterner left
[12:38] *** Psyche^ is now known as Patterner

[12:43] *** brrt joined
[12:52] *** cognominal left
[12:53] *** cognominal joined
[12:58] <felher> masak: thanks for the pointer to your discussion with TimToady. It answered exactly my question :)

[12:58] <masak> nice. glad to hear it.

[12:59] <masak> it's part of an intermittent discussion that stretches over several months.

[13:00] *** ponbiki left
[13:01] *** ponbiki joined
[13:01] *** ponbiki is now known as Guest20434

[13:07] <felher> masak: btw: I wasn't sure how to translate your 'I don't think it's at all unreasonable'. Does this mean "It's not completely unreasonable" (my first guess) or "It's totally reasonable" ? (not that it would make a difference. I'm just curious )

[13:07] *** grondilu joined
[13:08] <felher> this certainly has to do with my english rather than with your sentence :)

[13:12] * felher afk for a while

[13:12] <masak> felher: "I think the reasonableness is very far from the setting 'unreasonable' (i.e. quite reasonable)"

[13:12] <masak> r: macro capture-output($code) { my $result; my $out; quasi { $result = ""; $out = $*OUT; $*OUT = class { method print(*@args) { $result ~= @args.join } }; {{{$code}}}; $*OUT = $out; $result } }; my $s = capture-output say "OH HAI"; print $s

[13:12] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤»

[13:12] <masak> this is way cool.

[13:13] <moritz> masak++

[13:13] *** havenn joined
[13:13] <masak> I had written this example off as a case of "Better Written As Sub"... but now that I implement it, I see that it's not. just like with the logging example, the 'say "OH HAI"' is bare. it can't be bare with subs.

[13:13] <masak> now what I *didn't* show is how I had to try the above in 10 different ways and ran into three different macro-related bugs on the way. :P

[13:14] <arnsholt> =D

[13:14] <masak> the first one is related to using 'temp' inside of a macro.

[13:14] <moritz> it's like November 2009 again, but with macros this time :-)

[13:14] <arnsholt> And in theory this shold work as capture-output { ... } right?

[13:15] <masak> arnsholt: if you do it as a sub, you'd do it with the curlies, yes.

[13:15] <moritz> masak: it's basically a custom phaser

[13:15] <moritz> with macros

[13:15] <moritz> r: BEGIN say 42;

[13:15] <p6eval> rakudo 64208d: OUTPUT«42␤»

[13:16] <masak> r: macro foo { quasi { temp $*OUT } }; foo

[13:16] <p6eval> rakudo 64208d: OUTPUT«Null PMC access in elements()␤  in sub prefix:<temp> at src/gen/CORE.setting:11961␤  in  at /tmp/XCSZksD14I:1␤  in block  at /tmp/XCSZksD14I:1␤␤»

[13:16] * masak submits rakudobug

[13:17] <arnsholt> masak: How about macro with more than a single statement?

[13:17] *** havenn left
[13:17] <masak> arnsholt: we can only pass terms to macros at present.

[13:17] <arnsholt> Right =)

[13:17] <brrt> i have some Very Interesting Behavior, although it is correct afaik

[13:17] <masak> arnsholt: however, if you put parens or curlies around your statements...

[13:18] <brrt> nr: sub foo { return { say "OH HAI"; return 42; }; }; foo().();

[13:18] <p6eval> niecza v22-16-g4c016f5: OUTPUT«OH HAI␤Unhandled exception: Illegal control operator: return␤  at /tmp/hVv4WvilD8 line 1 (ANON @ 6) ␤  at /tmp/hVv4WvilD8 line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4215 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line …

[13:18] <p6eval> ..rakudo 64208d: OUTPUT«OH HAI␤Attempt to return outside of any Routine␤  in block  at src/gen/CORE.setting:466␤  in block  at /tmp/0esC6gtKK2:1␤␤»

[13:19] <masak> brrt: yes, it's correct.

[13:19] <masak> brrt: in short, bare blocks don't bind 'return'.

[13:20] <masak> so your inner return ends up binding to 'foo'.

[13:20] *** GlitchMr joined
[13:20] <masak> which has already returned by the time the inner block runs. so the error message is correct.

[13:20] <moritz> and by the time you run the inner block, &foo already has returned

[13:20] * moritz too slow

[13:20] <brrt> yes, now, what happens if i call it in another dynamic context?

[13:21] <moritz> r: sub foo { return { say "OH HAI"; return 42; }; }; try foo().(); say $/.WHAT

[13:21] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤Any()␤»

[13:21] <moritz> r: sub foo { return { say "OH HAI"; return 42; }; }; try foo().(); say $!.WHAT

[13:21] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤X::ControlFlow::Return()␤»

[13:21] *** bowtie joined
[13:21] <moritz> r: sub foo { return { say "OH HAI"; return 42; }; }; sub bar { try foo().(); say $!.WHAT }; bar()

[13:21] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤X::ControlFlow::Return()␤»

[13:21] <moritz> brrt: same thing

[13:21] <masak> r: sub foo { bar({ return 42 }); return 3 }; sub bar(&c) { c }; say foo

[13:21] <brrt> r: sub foo { return { say "OH HAI"; return 42; } }; sub bar { foo().(); }

[13:21] <p6eval> rakudo 64208d: OUTPUT«42␤»

[13:21] <p6eval> rakudo 64208d:  ( no output )

[13:21] <masak> I believe the first output is mine.

[13:22] <masak> and it prints what I expected.

[13:22] <brrt> it is expected, but madness

[13:22] <masak> that is, you can *return* from a subroutine that's above your currently executing subroutine in the call stack.

[13:22] <masak> it's not madness. it's just regular exceptions.

[13:22] <moritz> I think that's a bug.

[13:22] <masak> I don't.

[13:23] <moritz> return is supposed to be tied to the outer lexical routine

[13:23] <masak> it is.

[13:23] <masak> that's why you see this behavior.

[13:23] <masak> the 'return 42' in &foo binds to &foo.

[13:23] <flussence> oh, I did a hackish $*OUT capture thing a long time ago, if you see any useful ideas there feel free to steal 'em - https://gist.github.com/1606837

[13:23] <moritz> masak: oh, I was confused

[13:23] <flussence> (I was thinking, maybe Cat should have IO methods on it...)

[13:24] <masak> moritz: for a little while there I thought we were disagreeing on something. then normality returned. :P

[13:25] <brrt> masak: returns and exceptions, that weird

[13:25] <GlitchMr> This channel is always active ;-)

[13:25] <brrt> exceptions are weird in their own right, but return-as-an-exception

[13:25] <brrt> its easy in continuations, i guess

[13:25] <masak> brrt: how would you implement it? :)

[13:26] <brrt> well, i would create it by making the inner block a lambda with a fixed continuation - that of foo, determined at run time

[13:26] <brrt> so it would do the same thing

[13:26] <masak> brrt: or rather, if you accept that exceptions allow you to effectively return from several routines at once, why don't you like it when &return does?

[13:27] <brrt> masak, mostly because return means a simpler thing in the c world

[13:27] <masak> "Toto, I don't think we're in C-land anymore"

[13:27] <brrt> this being perl6 i should not at all be surprised by finding there is more than one way to do it

[13:36] <masak> r: macro foo { quasi { my &bar = { say "OH HAI" }; bar } }; foo

[13:36] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&bar' called (line 1)␤»

[13:36] <masak> r: macro foo { quasi { my &bar = { say "OH HAI" }; &bar() } }; foo

[13:36] <p6eval> rakudo 64208d: OUTPUT«Cannot assign into a PMCNULL container␤  in  at /tmp/GfBF7Zue77:1␤  in block  at /tmp/GfBF7Zue77:1␤␤»

[13:36] * masak submits rakudobug

[13:37] <masak> none of this is surprising, of course, since we already know variable declarations don't work properly in macros.

[13:37] <masak> er, in quasi blocks, I mean.

[13:38] <masak> r: macro foo { quasi { my $bar = "OH HAI"; say $bar } }; foo

[13:38] <p6eval> rakudo 64208d: OUTPUT«Cannot assign into a PMCNULL container␤  in  at /tmp/euDdsux_9o:1␤  in block  at /tmp/euDdsux_9o:1␤␤»

[13:38] <masak> r: macro foo { quasi { my $bar; say $bar } }; foo

[13:38] <p6eval> rakudo 64208d: OUTPUT«Mu()␤»

[13:38] <masak> sorry; declarations work. assignments somehow don't.

[13:38] <masak> assignments to locally declared variables, that is.

[13:39] <moritz> remember --ll-exception when debugging :-)

[13:40] <masak> thanks for le reminder :) I need it.

[13:40] <masak> r: macro foo { my $bar = "OH HAI"; quasi { say $bar } }; foo

[13:40] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤»

[13:40] <masak> r: macro foo { my &bar = { say "OH HAI" }; quasi { &bar() } }; foo

[13:40] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤»

[13:40] <masak> r: macro foo { my &bar = { say "OH HAI" }; quasi { bar } }; foo

[13:40] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&bar' called (line 1)␤»

[13:41] <masak> huh!

[13:41] <masak> I wonder if that's a different failure mode, or the same one.

[13:42] <moritz> r: macro foo { sub bar { say "OH HAI" }; quasi { &bar() } }; foo

[13:42] <p6eval> rakudo 64208d: OUTPUT«OH HAI␤»

[13:43] <masak> r: macro foo { sub bar { say "OH HAI" }; quasi { bar } }; foo

[13:43] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&bar' called (line 1)␤»

[13:43] <masak> well, it's consistent, at least.

[13:45] <[Coke]> I made very little (but some!) progress on muddle this weekend, taking the little bit of functionality that was there and putting a slightly nicer skin on it

[13:45] <[Coke]> http://feather.perl6.nl:2653/

[13:45] <masak> nice. [Coke]++

[13:46] <flussence> [Coke]++

[13:46] <[Coke]> Hopefully by the end of the week, it'll be functional enough that we can add a make target to rakudo or niecza to submit reports.

[13:46] <[Coke]> Thanks to me from a year ago, since dropping in twitter bootstrap is a pretty easy upgrade. :)

[13:47] <flussence> how fast is it? one of the big problems with smolder was that it collapses if you look at it funny...

[13:49] <brrt> basically, 'take' both yields its value and returns, right?

[13:50] <brrt> so my $x = take 3; sets $x to 3?

[13:50] <[Coke]> It's a mojolicious app - right now I'm running it under morbo, but we could shove it into a more robust container.

[13:50] <brrt> r: my $x = take 3; say $x;

[13:50] <p6eval> rakudo 64208d: OUTPUT«take without gather␤  in block  at src/gen/CORE.setting:429␤  in block  at src/gen/CORE.setting:478␤  in block  at /tmp/fBpNUYcX69:1␤␤»

[13:50] <flussence> [Coke]: should be pretty fast then :)

[13:50] <[Coke]> it's also using sqlite3, because that's zero install and I can run it anywhere. We can add another backend if there's a better choice on feather. (or wherever.)

[13:53] *** cognominal left
[13:54] <moritz> (starting simple)++

[13:55] *** bluescreen10 left
[13:57] <masak> r: my @a = gather { say take 3 };

[13:57] <p6eval> rakudo 64208d: OUTPUT«0␤»

[13:57] <masak> brrt: that's interesting.

[13:57] <flussence> mojolicious (and other stuff like it) seem perfect for this sort of thing - replacing a flaky old web service with one that actually works. I've done it a few times at $dayjob already.

[13:57] <masak> what does the 0 mean?

[13:57] <masak> r: my @a = gather { say take 3; say take 42 };

[13:57] <p6eval> rakudo 64208d: OUTPUT«0␤0␤»

[13:57] <masak> n: my @a = gather { say take 3; say take 42 };

[13:57] <p6eval> niecza v22-16-g4c016f5: OUTPUT«Potential difficulties:␤  @a is declared but not used at /tmp/YeVGB755T9 line 1:␤------> [32mmy [33m⏏[31m@a = gather { say take 3; say take 42 };[0m␤␤3␤42␤»

[13:58] * masak submits rakudobug

[13:58] <masak> n: my @a = gather { say take 3; say take 42 }; say @a.perl

[13:58] <p6eval> niecza v22-16-g4c016f5: OUTPUT«3␤42␤[3, 42].list␤»

[13:58] <flussence> take returns 0?

[13:58] <masak> n: my @ = gather { say take 3; say take 42 };

[13:58] <p6eval> niecza v22-16-g4c016f5: OUTPUT«3␤42␤»

[13:58] <flussence> (sometimes?)

[13:58] <masak> flussence: in Rakudo, yes. in Niecza it gives back the value.

[13:58] *** cognominal joined
[13:58] <masak> which seems much more useful.

[13:58] <flussence> agreed

[13:59] <tadzik> I wonder if we can marry that and emmentaler somehow

[13:59] <tadzik> (muddle)

[14:00] <brrt> masak: returning the value is basically what is spec'-ed

[14:00] <masak> brrt: any reference to that bit of spec?

[14:01] <masak> (so I can include it in the RT ticket)

[14:01] <brrt> s04-somewhere, will be a few minutes

[14:02] <masak> S04:735.

[14:03] <brrt> http://perlcabal.org/syn/S04.html#The_gather_statement_prefix

[14:03] <masak> The value returned by the C<take> to the C<take>'s own context is that same

[14:03] <masak> returned argument (which is ignored when the C<take> is in sink context).

[14:03] <brrt> say is maybe seen as sink context?

[14:05] <flussence> r: my @a = gather { say eager take 3 };

[14:05] <p6eval> rakudo 64208d: OUTPUT«0␤»

[14:05] *** marloshouse_ joined
[14:05] <masak> brrt: no. sink context is when you don't use the value from 'take' at all.

[14:05] <GlitchMr> What eager take is supposed to do?

[14:06] *** marloshouse left
[14:06] *** marloshouse_ is now known as marloshouse

[14:06] <flussence> not sink context

[14:06] *** SamuraiJack left
[14:06] *** PacoAir joined
[14:07] <brrt> r: say sink 3;

[14:07] <p6eval> rakudo 64208d: OUTPUT«Nil␤»

[14:09] <[Coke]> I wonder if that's actually a Kitchen sink. it would explain a lot.

[14:09] <moritz> maybe it's a kitten sink

[14:09] <brrt> that association also came to my mind

[14:10] <brrt> perl6, comes with (kitchen) sink

[14:11] *** bluescreen10 joined
[14:11] *** tokuhiro_ left
[14:13] *** havenn joined
[14:14] *** cognominal left
[14:16] <masak> std: KitchenSink

[14:16] <p6eval> std 04216b1: OUTPUT«ok 00:00 41m␤»

[14:16] <masak> STD comes with a kitchen sink.

[14:16] <masak> std: GardenHose

[14:16] <p6eval> std 04216b1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'GardenHose' used at line 1␤Check failed␤FAILED 00:00 41m␤»

[14:18] *** havenn left
[14:28] *** kaleem left
[14:32] *** plobsing joined
[14:39] *** atrodo_ joined
[14:40] *** kaare_ joined
[14:42] *** atrodo left
[14:42] *** atrodo_ is now known as atrodo

[14:42] *** atrodo left
[14:42] *** atrodo joined
[14:42] *** mtk joined
[14:43] *** sivoais left
[14:46] *** kaleem joined
[14:47] *** plobsing left
[14:50] *** marloshouse left
[14:54] *** arlinius joined
[14:55] *** marloshouse joined
[14:56] *** spider-mario joined
[14:57] *** benabik left
[14:58] <felher> masak: ah, okay, now i get it. Thanks :)

[14:58] <felher> (About the reasonable-thingy)

[15:01] <masak> also, your request for clarification was not at all unreasonable :P

[15:04] *** telex left
[15:04] <felher> masak: :D

[15:06] *** telex joined
[15:11] *** stopbit joined
[15:12] <felher> oha, the capture-output macro is nice :)

[15:14] *** havenn joined
[15:14] <masak> :)

[15:16] <felher> masak: do you have to save $*OUT explicitly? Couldn't one just write "my $*OUT = class { ... };" ?

[15:17] <flussence> $*OUT is an IO object, not a string

[15:17] <masak> felher: that might work too, yes.

[15:17] *** brrt left
[15:17] *** brrt joined
[15:18] <masak> r: say "before"; { my $*OUT = class { method print(*@) {} }; say "inside" }; say "after"

[15:18] <p6eval> rakudo 64208d: OUTPUT«before␤after␤»

[15:18] <masak> yes, that works. but probably not in quasis yet, because there seems to be something wrong with quasi { my ... }

[15:18] * [Coke] wonders why these gists are gists and not blog posts.

[15:18] <felher> masak: okay, nice :)

[15:18] <[Coke]> (pointing at masak's recent blog post mentioning some gists)

[15:18] *** skids joined
[15:19] *** havenn left
[15:19] <masak> [Coke]: because gists feel like they have a smaller "contract" to be kept up-to-date, or to explain everything to an uninitiated audience.

[15:19] <masak> it's as if gists are mostly for me, whereas blog posts are mostly for other people.

[15:21] <masak> n: my @sorted = 1, 2, 2, 2, 3, 4, 4, 5; my @uniq = gather for @sorted { state $previous = take $_; next if $_ === $previous; $previous = take $_ }; say @uniq

[15:21] <p6eval> niecza v22-16-g4c016f5: OUTPUT«1 2 3 4 5␤»

[15:21] <masak> \o/

[15:21] <[Coke]> I feel like you're hiding things you should be showing people.

[15:21] <masak> n: my @sorted = 1, 2, 2, 2, 3, 4, 4, 5; my @uniq = gather for @sorted { my $previous = START take $_; next if $_ === $previous; $previous = take $_ }; say @uniq

[15:21] <p6eval> niecza v22-16-g4c016f5: OUTPUT«1 2 2 2 3 4 4 5␤»

[15:22] <masak> [Coke]: well, I am taking pains to link to them from the blog posts.

[15:22] <brrt> masak: does that work with rakudo?

[15:22] <[Coke]> https://gist.github.com/abd360db840a0719da2f in particular.

[15:22] <masak> [Coke]: and the gists really are less authoritative.

[15:22] <masak> [Coke]: yes, that's perhaps the best of them. it's also quite recent.

[15:23] <masak> [Coke]: it was written for YAPC::EU, for the proceedings handed out to all participants.

[15:23] <masak> (which means that at the time, it did not make sense to blog it)

[15:26] *** adu joined
[15:27] <[Coke]> heh. I happened to read that gist first (the proceedings), and assumed the others were also in a similar vein.

[15:29] <masak> most of them are just random musings and ruminations.

[15:30] <masak> almost all are on the theme "wow, macros are like closures, except they're not closures OMG I'm so confused here's what's really going on..."

[15:34] <masak> I'm still a little nervous to make the edit to Wikipedia mentioned in that gist.

[15:34] <masak> maybe I should go talk to some Lisp people on IRC first.

[15:35] *** havenn joined
[15:37] *** sivoais joined
[15:39] <masak> heh, #lisp channel redirects me to #scheme, because those are the hygienic people :P

[15:40] <moritz> lol

[15:40] <TimToady> .oO(Uncommon Lisp)

[15:42] <arnsholt> masak: Heehee. That's Common Lispers for ya. "Who needs hygiene anyways?!" ^_^

[15:44] <masak> I haven't been put on fire yet. people are very friendly on both channels.

[15:48] <masak> hah, LeoNerd at #scheme makes a really good point about macro expansions and deparsing.

[15:48] <arnsholt> Not bad. #lisp can get real snarky real quick

[15:48] <arnsholt> Oh?

[15:49] <masak> if you ever try to deparse the expanded code, suddenly you have to handle variable collisions somehow.

[15:49] <masak> my factoring of macro expansions means I don't have to handle it with gensymming and such. but during deparse, the problem would resurface.

[15:49] <masak> essentially because some blocks have "impossible" OUTERs.

[15:49] <arnsholt> Huh

[15:50] <[Coke]> would we ever be able to deparse the fact that a macro was there? special flag on the AST?

[15:50] <[Coke]> or would it all just look like old school deparsed Java?

[15:51] *** brrt left
[15:51] <masak> no idea.

[15:52] * moritz doesn't understand "impossible" OUTERs

[15:52] <[Coke]> (that is, not much like the original code with artificial var names.... oh - "like minified javascript" is probably better. :)

[15:53] <TimToady> the main point of an AST is to be A...not necessarily to let you reconstruct the C

[15:53] <masak> moritz: first-class functions allow you to separate a block from its OUTER at *runtime*. macros allow you to do so at *compile time*. which is why "surgery"/recontexting by fiddling with Parrot internals is needed.

[15:54] <moritz> masak: erm, what?

[15:54] <moritz> a function never gets separated from its OUTER, afaict

[15:54] *** thou joined
[15:55] <moritz> sub a { sub b { } }; # &b's outer is always &a, no matter what, no?

[15:55] <masak> I'm being a bit sloppy and unclear here. sorry.

[15:55] <masak> I'm talking about moving the code itself. the OUTER link remains the same, yes. both with closures and macros.

[15:56] <masak> but the code gets pulled from the block denoted by this OUTER.

[15:56] <moritz> normal closures never move the code, right?

[15:56] <moritz> just macros

[15:56] <masak> the code "moves" in the sense that I can return it from its original context and pass it somewhere else.

[15:57] <masak> but you're right, in some sense it never leaves its original environment.

[15:57] <masak> only the references to the closure do.

[15:57] <moritz> you can move references to code+lexpad

[15:57] <masak> right.

[15:58] <masak> with macros, we *copy* the code itself, which is why it's harder to re-establish OUTERs. and it happens on two levers, once with the quasi and once for each unquote.

[15:58] <masak> levels*

[15:58] *** kaleem left
[15:58] <moritz> I'm with you so far

[15:58] <moritz> how does that lead to "impossible" OUTERs?

[15:59] <masak> well, suppose you deparse the code after the macro expansion happened.

[15:59] <masak> there's no explicit mechanism to denote what OUTER a block has. it's just indicated by nesting, right?

[15:59] <moritz> is that because you can copy two macros into the same block, with conflicting OUTERs?

[15:59] <moritz> ah

[15:59] <masak> and yet code expanded by a macro will have an OUTER that points back into the macro body.

[16:00] <masak> that's genuinely impossible.

[16:00] <masak> in the sense that you can't write code like that directly in Perl 6.

[16:00] <moritz> so, impossible in the sense that you can't reproduce the same thing with non-macro Perl 6 code

[16:00] <masak> right.

[16:00] <moritz> but, not impossible in the sense of "impossible to resolve deterministically" or so

[16:00] <moritz> (which I thought first you meant)

[16:00] <moritz> ok, got it

[16:01] <moritz> it's a bit like writing closure code without closures, where you have to do massive refactorings

[16:01] <flussence> macros are interdimensional wormholes

[16:01] <moritz> like carrying objects around that simulate the lexpads

[16:01] <masak> no, it's possible to resolve deterministically.

[16:01] <masak> the impossibility resurfaces when you try to deparse the code, though. I hadn't thought of that before.

[16:02] <skids> WOuld you be able to key off the fact that you've reached an impossibility to have your decompiler say: oh I guess I should be looking to generate a macro now?

[16:03] <moritz> it's probably not too hard to detect, but hard to turn into a macro (just my shallow guess)

[16:03] <masak> ooh, an interesting objection at #scheme.

[16:03] <masak> moritz: (re massive refactorings and carrying objects around) yes, exactly.

[16:04] <masak> skids: it's certainly possible to detect when a variable doesn't resolve properly. like referring to $var without $var being in scope.

[16:04] <masak> skids: but though this is a sure-fire way to detect macros *today*, it may not always be. also, it will not detect all macros.

[16:06] *** sivoais left
[16:06] <skids> But it will detect macros that are impossible top express in macro-free perl6, yes?  In which case a patch macro that just supplies the appropriate OUTER might be generated.

[16:08] <moritz> sounds possible

[16:08] <moritz> though not trivial

[16:08] <skids> Well, I wouldn't expect a decompiler to be a trivial endeavor :-)

[16:09] *** benabik joined
[16:09] <masak> skids: well, a naive deparser might easily miss the re-bound OUTER links and just generate illegal code.

[16:09] *** thou left
[16:12] *** domidumont left
[16:12] *** sivoais joined
[16:14] <kresike> bye folks

[16:14] *** kresike left
[16:14] *** sorenso left
[16:15] <jnthn> evening o/

[16:15] <moritz> \o jnthn, how was the teaching?

[16:15] *** hoelzro is now known as hoelzro|away

[16:15] <jnthn> Fine, but my throat hurts after talking lots.

[16:18] <masak> r: macro foo { quasi { return 42 } }; sub bar { foo }; say bar

[16:18] <p6eval> rakudo 64208d: OUTPUT«Attempt to return outside of any Routine␤  in block  at src/gen/CORE.setting:466␤  in  at /tmp/Pr3vSisyzw:1␤  in sub bar at /tmp/Pr3vSisyzw:1␤  in block  at /tmp/Pr3vSisyzw:1␤␤»

[16:18] <masak> aww

[16:18] <masak> that should work, methinks.

[16:18] <jnthn> I'm less than convinced.

[16:18] <jnthn> Well

[16:19] <jnthn> Hm

[16:19] <masak> :)

[16:19] <jnthn> I'm not sure of any way to do it that won't be an epic hack :/

[16:19] <masak> remember, a quasi is a *deferred* context.

[16:19] <jnthn> I remember. I also remember that return is lexical. Lexical things in quasis refer to...the scope the quasi is in.

[16:19] <jnthn> quasi { $a } # refers to the $a where the quasi is

[16:20] <masak> hm, troo.

[16:20] <masak> so the 'return' here gets bound to the macro?

[16:20] <jnthn> And the way we look up the return handler is just as an ordinary lexical.

[16:21] <jnthn> I think it uses find_lex even, just like normal variables.

[16:22] *** cognominal joined
[16:23] <moritz> what does it find_lex? &ROUTINE?

[16:25] <jnthn> RETURN

[16:25] <jnthn> .lex "RETURN", $P107 # from the generated code

[16:26] <masak> hygienic macros reading recommendations from #scheme: https://gist.github.com/4018113

[16:27] <masak> as predicted, I am being taught a bit of humility by listening to the peeps on that channel. they haven't crushed my macros factoring yet, but their skepticism is... refreshing.

[16:27] <moritz> I kinda hope your factoring survives

[16:28] <masak> me too!

[16:29] *** am0c left
[16:33] *** flightrecorder left
[16:35] <[Coke]> http://news.perlfoundation.org/2012/11/google-code-in.html - TPF post about this year's google code in.

[16:35] <[Coke]> go, add sixtasks.

[16:43] *** am0c joined
[16:45] *** benabik left
[16:45] *** [particle]1 is now known as [particle]

[16:50] *** benabik joined
[16:54] <masak> I hadn't seen this naggum post about hygiene in Lisps before: http://www.xach.com/naggum/articles/3236789642671151@naggum.net.html

[16:54] <masak> (got it from the #lisp people, not from the #scheme people) :P

[16:56] *** Chillance joined
[16:57] *** brrt joined
[17:05] *** MayDaniel joined
[17:06] *** adu left
[17:07] *** fgomez joined
[17:12] <arnsholt> masak: Ah yes, Naggum is always an entertaining read. I'm not surprised it was the CL camp that gave you the link though

[17:12] <arnsholt> Naggum is their prophet, after all =)

[17:16] <masak> indeed.

[17:16] <masak> hence the ':P'.

[17:16] <arnsholt> Heh. Indeed

[17:17] <cognominal> rn: class A {  sub hi { say 'hi' }; method hi { hi };  }; class B is A { method hi1 { hi } }; A.new.hi; B.new.hi; B.new.hi1

[17:17] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&hi' called (line 1)␤»

[17:17] <p6eval> ..niecza v22-16-g4c016f5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'hi' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/…

[17:18] <cognominal> I am not sure it make any sense to inherit subs. The idea just crosses my mind :)

[17:18] <cognominal> *crossed

[17:19] <masak> cognominal: subs are not inherited.

[17:19] <cognominal> I see

[17:19] <masak> only methods do lookup along the MRO axis.

[17:19] <masak> which is why in B &hi is not even visible.

[17:20] <cognominal> indeed

[17:20] <masak> well, that and the fact that subs are lexical by default. :)

[17:21] <masak> rn: class A { our sub hi { say 'hi' } }; class B { our &hi; method hi1 { hi } }; B.new.hi1

[17:21] <p6eval> niecza v22-16-g4c016f5: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Any␤  at /tmp/3v0tIoAW6g line 1 (B.hi1 @ 4) ␤  at /tmp/3v0tIoAW6g line 1 (mainline @ 8) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4215 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/…

[17:21] <p6eval> ..rakudo 64208d: OUTPUT«No such method 'Any' for invocant of type 'Parcel'␤  in  at src/gen/BOOTSTRAP.pm:845␤  in  at src/gen/BOOTSTRAP.pm:839␤  in any  at src/gen/BOOTSTRAP.pm:836␤  in method hi1 at /tmp/tFywyq7xl8:1␤  in block  at /tmp/tFywyq7xl8:1␤␤»

[17:21] <masak> inneresting.

[17:21] <masak> oh, different classes => different packages.

[17:21] <masak> so not too surprising.

[17:22] <cognominal> I like stupid questions, that always lead to interesting thoughts

[17:22] <masak> aye.

[17:22] <diakopter> r: our macro foo() { }; foo()

[17:22] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling op bind: First child of a 'bind' op must be a QAST::Var␤»

[17:22] <cognominal> so I am not ashamed to make a fool of myself if I can learn in the process

[17:23] <diakopter> masak: let me type that for you:  /me submits rakudobug

[17:23] <cognominal> one just need the right place to bounce them around.  :)

[17:24] <diakopter> r: temp macro foo() { }; foo()

[17:24] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Method 'returns' not found for invocant of class 'NQPMu'␤»

[17:24] <masak> diakopter: indeed.

[17:25] * masak submits rakudobug

[17:25] * masak submits rakudobug

[17:25] <masak> diakopter++ diakopter++

[17:25] <cognominal> also, with macros, masak has a keen eye for anything related to names in time and in space.

[17:26] <diakopter> r: module foo; macro foo() { }; foo; foo(); # foo works; foo() doesn't

[17:26] <p6eval> rakudo 64208d: OUTPUT«invoke() not implemented in class 'foo'␤  in block  at /tmp/JEyQXBbqaU:1␤␤»

[17:26] <masak> it does give a keener understanding of context and phases, yes.

[17:27] <[Coke]> r: my $a = macro foo() {}; say $a;

[17:27] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling op p6store: Unknown QAST node type NQPMu␤»

[17:27] <masak> diakopter: both should work.

[17:27] * masak submits [Coke]'s rakudobug

[17:27] <[Coke]> I have no idea what I expect $a to contain there, btw. :)

[17:28] <diakopter> masak: both should invoke macro foo? or one should invoke macro foo and the other invoke class foo (like it's doing)?

[17:28] <cognominal> :)

[17:28] <masak> diakopter: both should invoke macro foo, IMO.

[17:28] <masak> r: module foo; sub foo() { say "OH HAI" }; foo; foo()

[17:28] <p6eval> rakudo 64208d: OUTPUT«invoke() not implemented in class 'foo'␤  in block  at /tmp/n8jWXMP4lX:1␤␤»

[17:29] <masak> hm.

[17:29] <masak> same there; really unrelated to macros, I think.

[17:29] <diakopter> oh

[17:29] <masak> [Coke]: a Macro (which is a Routine)

[17:29] * masak submits diakopter's rakudobug

[17:29] <masak> good rakudobug weather tonight :)

[17:30] <masak> that's four in five minutes.

[17:31] <diakopter> r: my $*a = macro { }

[17:31] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling op p6store: Unknown QAST node type NQPMu␤»

[17:32] * [Coke] thinks that's the same as mine.

[17:32] <masak> yes; I'll report them together.

[17:32] <[Coke]> pugs: say 3;

[17:32] <p6eval> pugs: OUTPUT«3␤»

[17:32] <[Coke]> Any haskell folks, Pugs is no longer building for me in a fresh checkout on feather.

[17:33] <jnthn> module foo; sub foo() { say "OH HAI" }; foo; foo()

[17:33] <jnthn> In this one, foo() parses as a coercion.

[17:34] <[Coke]> rakudofolks: https://github.com/coke/perl6-roast-data/blob/master/perl6_pass_rates - line 5 vs. line 9 - pretty sure those are from "running via cron" and "running from my shell"; Any suggestions about what to add to my "run rakudo tests" scripts to avoid that are welcome.

[17:34] *** robinsmidsrod left
[17:34] *** robins joined
[17:34] <masak> jnthn: oh!

[17:34] * masak adds that to the appropriate rakudobug

[17:35] <jnthn> Anyway, it's right it doesn't call the sub. Just an LTA error I guess...though I ain't immediately sure what to do with it...

[17:41] *** sizz joined
[17:41] *** sizz_ left
[17:42] *** brrt left
[17:50] *** adu joined
[17:51] *** adu left
[17:56] <sorear> o/

[17:57] <diakopter> o

[17:58] *** SamuraiJack joined
[17:59] <jnthn> o/

[17:59] <masak> \o/

[18:01] *** domidumont joined
[18:06] <[Coke]> anyone use "Tapper" ?

[18:06] <[Coke]> it appears to be in vaguely the same market as smolder.

[18:07] *** arlinius left
[18:07] *** domidumont1 joined
[18:11] *** domidumont left
[18:13] *** fhelmberger left
[18:18] *** kaare_ left
[18:18] *** domidumont1 left
[18:19] *** domidumont joined
[18:19] *** snearch joined
[18:20] *** flightrecorder joined
[18:22] *** cognominal left
[18:23] *** Milbourne joined
[18:24] *** am0c left
[18:24] *** kaare_ joined
[18:34] *** robins is now known as robinsmidsrod

[18:43] *** grondilu left
[18:45] *** brrt joined
[18:47] *** colomon left
[18:48] *** xinming_ joined
[18:51] *** xinming left
[19:03] *** domidumont left
[19:05] *** mtk left
[19:05] *** mtk joined
[19:08] <masak> n: constant @c := 1, -> $n { 2 * (2 * $n - 1) / ($n + 1) * @c[$n - 1] } ... *; say @c[$_] for 0..5

[19:08] <p6eval> niecza v22-16-g4c016f5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot use bind operator with this LHS at /tmp/B5bAObkC37 line 1:␤------> [32m $n - 1) / ($n + 1) * @c[$n - 1] } ... *[33m⏏[31m; say @c[$_] for 0..5[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/li…

[19:09] <masak> n: constant @c = 1, -> $n { 2 * (2 * $n - 1) / ($n + 1) * @c[$n - 1] } ... *; say @c[$_] for 0..5

[19:09] <p6eval> niecza v22-16-g4c016f5: OUTPUT«1␤1␤1␤1␤1␤1␤»

[19:09] <masak> hm, but that block isn't getting an index, of course...

[19:10] <TimToady> which usually means you shouldn't be using ... for that

[19:10] <masak> n: constant @c = 1, { state $i = 0; $i++; 2 * (2 * $i - 1) / ($i + 1) * $_ } ... *; say @c[$_] for 0..5

[19:10] <p6eval> niecza v22-16-g4c016f5: OUTPUT«1␤1␤2␤5␤14␤42␤»

[19:10] <masak> there we go.

[19:10] <masak> r: constant @c = 1, { state $i = 0; $i++; 2 * (2 * $i - 1) / ($i + 1) * $_ } ... *; say @c[$_] for 0..5

[19:10] <p6eval> rakudo 64208d: OUTPUT«1␤1␤2␤5␤14␤42␤»

[19:11] <masak> woo

[19:12] <TimToady> nr: constant @c = 1, { (state $i)++; 2 * (2 * $i - 1) / ($i + 1) * $_ } ... *; say @c[$_] for 0..5

[19:12] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5: OUTPUT«1␤1␤2␤5␤14␤42␤»

[19:12] <TimToady> nr: constant @c = 1, { state $i++; 2 * (2 * $i - 1) / ($i + 1) * $_ } ... *; say @c[$_] for 0..5

[19:12] <p6eval> niecza v22-16-g4c016f5: OUTPUT«1␤1␤2␤5␤14␤42␤»

[19:12] <p6eval> ..rakudo 64208d: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix + instead␤at /tmp/T18sEnSDMe:1␤»

[19:12] <masak> rn: constant @c = 1, { (state $i)++; 2 * (2 * $i - 1) / ($i + 1) * $_ } ... *; sub b($l) { my $r = (^@c[$l]).roll; my $s; for reverse(^$l) Z ^$l -> $l1, $l2 { $s += @c[$l1] * @c[$l2]; return [~] "[", b($l1), "]", b($l2) if $r < $s }; return "" }; say b 5

[19:12] <p6eval> niecza v22-16-g4c016f5: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1295 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 294 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/mV4ZDw7cxC line 1 (b @ 15…

[19:12] <p6eval> ..rakudo 64208d: OUTPUT«[[][[]]][]␤»

[19:13] <masak> a little update to the "balanced brackets" solution, now with 'constant'.

[19:13] <masak> std: state $i++

[19:13] <p6eval> std 04216b1: OUTPUT«ok 00:00 42m␤»

[19:13] <masak> TimToady: nieczabug that 'state $i++' doesn't parse?

[19:13] <TimToady> rakudobug

[19:13] <masak> oh!

[19:13] <masak> yes.

[19:13] * masak submits rakudobug

[19:14] <masak> r: state $i++

[19:14] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Confused␤at /tmp/q3jGE_C9uJ:1␤»

[19:15] <jnthn> Already TD'd...

[19:15] <jnthn> *RT

[19:15] <masak> oh!

[19:15] <jnthn> And probably exact same issue as the sub foo { }() thing submitted the other day

[19:16] * masak looks for the previous ticket

[19:16] <jnthn> Now if only somebody could find out why...

[19:17] <masak> no, I can't find any previously submitted RT ticket for that.

[19:17] *** Milbourne left
[19:17] <masak> rn: my $a++

[19:17] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Confused␤at /tmp/txWl1n_0np:1␤»

[19:17] <p6eval> ..niecza v22-16-g4c016f5: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/K5JEon7nDZ line 1:␤------> [32mmy [33m⏏[31m$a++[0m␤␤»

[19:17] <masak> maybe it's submitted for something like that instead.

[19:17] * jnthn isn't particularly disappointed Rakudo doesn't parse it :P

[19:18] <jnthn> It visually chunks pretty awfully.

[19:18] *** grondilu joined
[19:18] <grondilu> in S29, S32/Scalars is mentionned but it doesn't exists, does it?

[19:21] <grondilu> (see 'defined' and 'undefine')

[19:21] *** SamuraiJack left
[19:22] <masak> jnthn: same awful visual chunking with sub {}()

[19:23] <jnthn> masak: Yeah

[19:23] <masak> grondilu: right. neither does 'undefine' anymore.

[19:24] <grondilu> rn: my %h; say "ok" unless %h<foo> :exists;

[19:24] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Confused␤at /tmp/L2WIT6sx75:1␤»

[19:24] <p6eval> ..niecza v22-16-g4c016f5: OUTPUT«ok␤»

[19:24] <grondilu> how do I test the existence of a hash entry?

[19:25] <grondilu> (I mean, until the :exists adverb is implemented on rakudo?)

[19:25] <jnthn> %foo.exists('bar')

[19:26] <grondilu> oh yeah.  ok

[19:26] <jnthn> My last efforts to look into operator adverbs led to headaches and a busted operator expression parser... :/

[19:26] <masak> rn: my %h; say "ok" unless %h.postcircumfix<( )>('foo', :exists)

[19:26] <p6eval> niecza v22-16-g4c016f5: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix in type Hash␤  at /tmp/NwdlGnPlct line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4215 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4216 (module-CORE @ 579) ␤  …

[19:26] <p6eval> ..rakudo 64208d: OUTPUT«No such method 'postcircumfix' for invocant of type 'Hash'␤  in block  at /tmp/L0vpRT6hMB:1␤␤»

[19:26] *** leont joined
[19:27] <masak> rn: my %h; say "ok" unless %h.postcircumfix<{ }>('foo', :exists)

[19:27] <p6eval> niecza v22-16-g4c016f5: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix in type Hash␤  at /tmp/arCFrHNqzI line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4215 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4216 (module-CORE @ 579) ␤  …

[19:27] <p6eval> ..rakudo 64208d: OUTPUT«No such method 'postcircumfix' for invocant of type 'Hash'␤  in block  at /tmp/hTdh3q9sf0:1␤␤»

[19:27] <jnthn> masak: You missed the :

[19:27] <masak> oh right.

[19:27] <masak> rn: my %h; say "ok" unless %h.postcircumfix:<{ }>('foo', :exists)

[19:27] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5: OUTPUT«ok␤»

[19:27] <masak> \o/

[19:27] *** cognominal joined
[19:27] *** Chillance left
[19:28] *** Chillance joined
[19:29] *** azawawi joined
[19:29] <jnthn> OK, I don't understand how STD's parsing of my $a++ works out.

[19:29] <azawawi> hi

[19:29] <jnthn> Unless there's a trait or post_constraint, the last thing that matches is a <.ws>

[19:29] <grondilu> rn: my %foo = 'bar' => 1; undefine %foo<bar>; say "ok" unless %foo.exists: 'bar';

[19:30] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5:  ( no output )

[19:30] <jnthn> Which will match between $a and ++

[19:30] <dalek> specs: 30974c6 | masak++ | S29-functions.pod:

[19:30] <dalek> specs: [S29] updated references to S32 synopsis

[19:30] <dalek> specs: review: https://github.com/perl6/specs/commit/30974c6e3c

[19:30] <grondilu> how do I delete a hash entry (not just set the entry to 'Any')?

[19:30] <jnthn> And then POST does:

[19:30] <jnthn> <!{ @*MEMOS[$¢.pos]<ws> }>

[19:30] <jnthn> grondilu: .delete('foo')

[19:30] <masak> grondilu++ # finding broken links

[19:31] <masak> rn: my %h = foo => 1; %h.postcircumfix<{ }>('foo', :delete); say %h.perl

[19:31] <jnthn> As in, we didn't just match ws.

[19:31] <p6eval> niecza v22-16-g4c016f5: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix in type Hash␤  at /tmp/qisI11z9zk line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4215 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4216 (module-CORE @ 579) ␤  …

[19:31] <p6eval> ..rakudo 64208d: OUTPUT«No such method 'postcircumfix' for invocant of type 'Hash'␤  in block  at /tmp/ZhniHBeFdc:1␤␤»

[19:31] <jnthn> So I'm kinda at a loss as to why it works in STD :)

[19:31] <masak> rn: my %h = foo => 1; %h.postcircumfix:<{ }>('foo', :delete); say %h.perl

[19:31] <p6eval> niecza v22-16-g4c016f5: OUTPUT«{}.hash␤»

[19:31] <p6eval> ..rakudo 64208d: OUTPUT«("foo" => 1).hash␤»

[19:31] * masak submits rakudobug

[19:31] <dalek> perl6-roast-data: 302162b | coke++ | / (3 files):

[19:31] <dalek> perl6-roast-data: today (automated commit)

[19:31] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/302162bd26

[19:31] <grondilu> rn: my %foo = 'bar' => 1; %foo.delete: 'bar'; say "ok" unless %foo.exists: 'bar';

[19:31] <jnthn> masak: todo, not bug...

[19:31] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5: OUTPUT«ok␤»

[19:32] <jnthn> masak: And I'd again be surprised if the adverb stuff ain't already TODO ticketed.

[19:32] <TimToady> 'my foo' is just a term, and POST will match after that without intervening ws

[19:32] <masak> jnthn: oh! :exist worked above for the wrong reasons...

[19:32] <masak> :exists

[19:32] <jnthn> TimToady: But variable_declarator calls <.ws> explicitly.

[19:33] *** hash_table joined
[19:33] <TimToady> well, if there's no actual whitespace there, it can still be a postfix

[19:34] <jnthn> TimToady: But ws matches in this case, no?

[19:34] <TimToady> doesn't matter

[19:34] <TimToady> POST checks for the absence of ws explicitly

[19:35] <TimToady> line 3302

[19:35] <grondilu> also, honnestly I kind of liked P5's syntax:  "... if exists $foo{bar}"

[19:35] <jnthn> Yes, that's what I'm looking at

[19:35] <brrt> is the CONTROL phaser implemented anywhere?

[19:35] *** chee left
[19:35] <brrt> and if so, hiow

[19:35] <jnthn> Rakudo does <!MARKED('ws')>

[19:36] <jnthn> In the same place

[19:36] <jnthn> Which should be equivalent.

[19:36] <jnthn> oh.

[19:36] <jnthn>         if ($¢.pos == $startpos) {

[19:36] <jnthn>             @*MEMOS[$¢.pos]<ws>:delete;

[19:36] <jnthn>         }

[19:36] <jnthn> Is in ws. Does that mean "don't mark it unless we actually had some characters?"

[19:37] *** snearch left
[19:37] <brrt> rn: sub foo { say "hi"; return 42; CONTROL { say "bye!"; } }

[19:37] <p6eval> rakudo 64208d:  ( no output )

[19:37] <p6eval> ..niecza v22-16-g4c016f5: OUTPUT«Potential difficulties:␤  &foo is declared but not used at /tmp/GMj3js4ZOx line 1:␤------> [32msub foo [33m⏏[31m{ say "hi"; return 42; CONTROL { say "by[0m␤␤»

[19:38] <brrt>  rn: sub foo { say "hi"; return 42; CONTROL { say "bye!"; } }; foo;

[19:38] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5: OUTPUT«hi␤»

[19:38] <brrt> is CONTROL not supposed to be called?

[19:38] *** Guest52580 joined
[19:39] <TimToady> jnthn: yes, we memoize the space at the end to point to the beginning, but only if it's different

[19:41] <masak> grondilu: to me that syntax looks odd. it looks like we're doing something with the value $foo{bar}. but we're not. we're asking the hash whether that entry is even in the hash.

[19:42] <grondilu> masak: but we do something similar with //

[19:42] <masak> we do?

[19:42] <grondilu> r: my %foo; say %foo<bar> // "there is no bar in foo"

[19:42] <p6eval> rakudo 64208d: OUTPUT«there is no bar in foo␤»

[19:43] <masak> sure, but that's a straight fetch from the hash.

[19:43] <masak> not an existence check.

[19:43] <masak> meaning that if someone stores an undefined value, you won't be able to tell that apart from no entry at all.

[19:43] * grondilu is skeptical

[19:44] <grondilu> r: my %foo = 'bar' => undef; say %foo<bar> // "there is no bar in foo"

[19:44] <p6eval> rakudo 64208d: OUTPUT«===SORRY!===␤Unsupported use of undef as a value;  in Perl 6 please use something more specific:␤ Mu (the "most undefined" type object),␤ an undefined type object such as Int,␤  Nil as an empty list,␤  !*.defined as a matcher or method,␤     Any:U as a type constraint␤     o…

[19:44] <grondilu> r: my %foo = 'bar' => Nil; say %foo<bar> // "there is no bar in foo"

[19:44] <p6eval> rakudo 64208d: OUTPUT«there is no bar in foo␤»

[19:44] *** leont left
[19:44] <grondilu> indeed

[19:45] <masak> I'm happy empirical evidence still cures misinformed skepticism :)

[19:45] <grondilu> so // has not the exact same semantic as in P5, has it?

[19:46] <doy> that's how // works in p5 too

[19:46] <grondilu> oh, I thought // tested existence.

[19:47] <masak> no, infix:<//> falls back to the rhs if the lhs is undefined. nothing more.

[19:47] <doy> eval: my %foo = (bar => undef); say $foo{bar} // "there is no bar in foo"

[19:47] <buubot_backup> doy: ERROR: syntax error at (eval 20) line 1, near "$foo{bar" 

[19:48] <doy> eval: use 5.010; my %foo = (bar => undef); say $foo{bar} // "there is no bar in foo"

[19:48] <buubot_backup> doy: there is no bar in foo 1

[19:48] * grondilu needs to read perlop again

[19:49] <doy> where is that trailing 1 coming from

[19:50] <huf> return value of say

[19:51] <huf> the perl5 evalbot evals your code in scalar context and also prints the return value

[19:51] <doy> ah, okay

[19:51] <huf> if it's a ref, it gets pretty printed, otherwise just shat out

[19:51] <huf> put a '' as the last expression if you want to suppress it ;)

[19:53] <masak> or just don't 'say' the final value ;)

[19:53] <masak> eval: use 5.010; my %foo = (bar => undef); $foo{bar} // "there is no bar in foo"

[19:53] <buubot_backup> masak: there is no bar in foo

[19:54] <huf> well yes, but maybe you have a valid reason for saying so much

[19:54] *** brrt left
[19:55] *** MikeyG joined
[20:03] *** grondilu left
[20:05] *** bruges left
[20:06] <jnthn> TimToady: What happens if you have a "my @foo[10];" and assign something like 1..* into it?

[20:07] *** bruges joined
[20:08] *** bluescreen10 left
[20:08] <geekosaur> I would expect the whatever to appropriately limit itself... isn't that the point?

[20:09] <jnthn> geekosaur: Note that 1..* isn't forming a closure; it's a distinct case from @foo[1..*].

[20:10] <jnthn> r: say (1..*).max

[20:10] <p6eval> rakudo 64208d: OUTPUT«Inf␤»

[20:10] <jnthn> 1..* is just sugar for 1..Inf

[20:12] *** gaussblurinc joined
[20:18] <TimToady> nr: my ($a,$b,$c) = 1..*; say "$a $b $c"

[20:18] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5: OUTPUT«1 2 3␤»

[20:18] <TimToady> jnthn: it's just like that

[20:19] <TimToady> nr: my @a; @a[0..9] = 1..*; say @a;

[20:19] <p6eval> rakudo 64208d, niecza v22-16-g4c016f5: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[20:19] <TimToady> or that

[20:20] <jnthn> my @a[10] = 1..*; # is this done eagerly?

[20:20] <jnthn> (the @a[0..9] = 1..* case would be...)

[20:20] <masak> I'm fine with it being done eagerly.

[20:20] <TimToady> I think it must be eager when there are known targets on the left

[20:20] <jnthn> OK, makes sense, thanks.

[20:21] <jnthn> What of push, shift, etc on a fixed size array?

[20:21] <TimToady> my ($a,$b,@c) = 1..* can treat only the final assignment as lazy

[20:21] <TimToady> error

[20:22] <jnthn> OK, presumably a splice that would result in a change is the same.

[20:22] * TimToady despises the use of pop on things that can't be popped :)

[20:29] <[Coke]> r: my $a = 1..*; say $a.pop;

[20:29] <p6eval> rakudo 64208d: OUTPUT«No such method 'pop' for invocant of type 'Range'␤  in block  at /tmp/8cOHCm35jB:1␤␤»

[20:29] <[Coke]> r: my $a = 1..*; say $a[*];

[20:29] <p6eval> rakudo 64208d: OUTPUT«(timeout)»

[20:51] *** kaare_ left
[21:05] *** kurahaupo joined
[21:05] *** GlitchMr left
[21:09] *** azawawi left
[21:13] *** colomon joined
[21:15] <dalek> ecosystem: 0b0c582 | (Timothy Totten)++ | META.list:

[21:15] <dalek> ecosystem: Added PSpec

[21:15] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/0b0c5828ff

[21:18] <sorear> is Timothy Totten a #perl6-er?

[21:19] *** leont joined
[21:19] <sorear> o/ colomon

[21:19] <colomon> \o

[21:23] *** leont left
[21:26] *** leont joined
[21:28] *** MayDaniel left
[21:29] <[Coke]> sorear: https://github.com/supernovus

[21:31] <sorear> I see

[21:31] <dalek> rakudo/nom: 0dd4514 | jnthn++ | src/Perl6/ (2 files):

[21:31] <dalek> rakudo/nom: Implement INIT as r-value.

[21:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0dd4514891

[21:33] *** MayDaniel joined
[21:33] <dalek> roast: 1d5f961 | jnthn++ | S04-phasers/rvalue.t:

[21:33] <dalek> roast: Fix and unfudge phaser r-value tests.

[21:33] <dalek> roast: 

[21:33] <dalek> roast: Correct a mis-paren'd eval call, and correct a test that had wrong

[21:33] <dalek> roast: expectations about containers.

[21:33] <dalek> roast: review: https://github.com/perl6/roast/commit/1d5f96177e

[21:45] *** havenn left
[21:46] *** gaussblurinc left
[21:46] *** havenn joined
[21:50] *** havenn left
[21:54] *** hash_table left
[21:54] <dalek> rakudo/nom: e472c9b | jnthn++ | src/Perl6/Actions.pm:

[21:54] <dalek> rakudo/nom: Fix our ($x, $y).

[21:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e472c9ba09

[21:54] <dalek> rakudo/nom: ef70aad | jnthn++ | src/core/control.pm:

[21:54] <dalek> rakudo/nom: Fix return value of take/take-rw.

[21:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef70aad810

[21:56] *** arlinius joined
[21:57] *** domidumont joined
[22:03] *** skids left
[22:07] <dalek> rakudo/nom: 0e41354 | jnthn++ | src/Perl6/World.pm:

[22:07] <dalek> rakudo/nom: Only SET_FILE_LINE on exceptions that can.

[22:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0e41354a5c

[22:07] *** benabik left
[22:07] *** cognominal left
[22:09] *** MayDaniel left
[22:14] *** domidumont left
[22:18] <masak> jnthn: I see you rejected https://rt.perl.org/rt3/Ticket/Display.html?id=115586 rather than merge it with its earlier duplicate.

[22:19] <masak> in the long run, merging tickets will simplify searching for old bugs.

[22:20] <jnthn> Not filing dupes within a couple of days of each other would save me time in the short term :P

[22:20] <jnthn> Feel free to twiddle it as you prefer.

[22:20] <sorear> masak \o/

[22:21] <masak> will do.

[22:22] <jnthn> r: say '' ~~ / $d /;

[22:22] <p6eval> rakudo 0e4135: OUTPUT«===SORRY!===␤Variable $d is not declared␤at /tmp/l4Zsow9e9k:1␤»

[22:22] <masak> and yes, sorry about filing the same thing twice within such a short time span. there's been a flurry of tickets, and I wanted to make sure I submitted all of them...

[22:23] <masak> merged.

[22:23] <diakopter> \o/

[22:26] <[Coke]> always ok to just note it here and some bugadmin will take care of it.

[22:26] <[Coke]> (mainly masak. :)

[22:27] <diakopter> jnthn: sorry masak and I have feeble memories about this :D

[22:28] <masak> generally I catch overlaps, but my overlap detector must have underlapped this time.

[22:29] <jnthn> r: my ${a} = 5;

[22:29] <p6eval> rakudo 0e4135: OUTPUT«===SORRY!===␤Unsupported use of ${a};  in Perl 6 please use $a␤at /tmp/9PM7O_R0P8:1␤»

[22:29] *** spider-mario left
[22:31] <diakopter> this cannot be.

[22:31] *** sizz left
[22:31] <diakopter> er, ww

[22:33] *** cognominal joined
[22:35] *** Guest52580 left
[22:35] *** flightrecorder left
[22:35] <jnthn> std: sub f { f(|$) }; say "alive"

[22:35] <p6eval> std 04216b1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of $) variable; in Perl 6 please use $*EGID at /tmp/kH8aP4cv2r line 1:␤------> [32msub f { f(|$)[33m⏏[31m }; say "alive"[0m␤Parse failed␤FAILED 00:00 43m␤»

[22:35] *** chee joined
[22:35] *** chee is now known as Guest64859

[22:36] *** Guest64859 left
[22:36] *** Guest64859 joined
[22:37] *** Guest64859 is now known as chee

[22:39] <jnthn> Is https://rt.perl.org/rt3/Ticket/Display.html?id=102276 rejectable?

[22:40] <sorear> yes and no

[22:40] <sorear> .duckmap still exists, I think

[22:40] <sorear> but hypers are specced to do something different now

[22:41] <jnthn> r: $_ = 'foo'; s:g/ /a/;

[22:41] <p6eval> rakudo 0e4135:  ( no output )

[22:41] <jnthn> r: $_ = 'foo'; s:g//a/;

[22:41] <p6eval> rakudo 0e4135: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter / (must be quoted to match literally) at line 2, near "a/;"␤»

[22:41] <jnthn> std: $_ = 'foo'; s:g/ /a/;

[22:41] <p6eval> std 04216b1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null pattern not allowed at /tmp/5RJPtyw4vg line 1:␤------> [32m$_ = 'foo'; s:g/ [33m⏏[31m/a/;[0m␤Parse failed␤FAILED 00:00 43m␤»

[22:41] <jnthn> std: $_ = 'foo'; s:g//a/;

[22:41] <p6eval> std 04216b1: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null pattern not allowed at /tmp/4_SLCIBEbD line 1:␤------> [32m$_ = 'foo'; s:g/[33m⏏[31m/a/;[0m␤    expecting colon pair (restricted)␤Parse failed␤FAILED 00:00 43m␤»

[22:41] *** flightrecorder joined
[22:49] <jnthn> Well, that's a bunch of tickets moved to testneeded status...

[22:50] <masak> jnthn++

[22:50] <jnthn> Various of them quoting related.

[22:52] *** leont left
[22:53] *** sftp left
[22:53] <jnthn> I wonder if we can use Google Code In to reduce the size of the testneeded list :P

[22:53] <jnthn> (If so, need to select ones that aren't really hard to test well...)

[22:56] <dalek> rakudo/nom: 0a320a4 | jnthn++ | docs/ChangeLog:

[22:56] <dalek> rakudo/nom: A few ChangeLog additions.

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0a320a4158

[23:00] *** Entonian joined
[23:01] *** Entonian left
[23:06] <jnthn> 'night, #perl6

[23:11] <masak> 'night, #perl6

[23:11] *** stopbit left
[23:11] <tadzik> good knight

[23:17] *** PacoAir left
[23:18] *** mtk left
[23:21] *** fgomez left
[23:22] *** benabik joined
[23:23] *** mtk joined
[23:36] *** skids joined
[23:39] *** Guest20434 is now known as ponbiki

[23:43] *** jeffreykegler joined
[23:45] *** jeffreykegler left
[23:47] *** sftp joined
[23:59] *** fgomez joined
