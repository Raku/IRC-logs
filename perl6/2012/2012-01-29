[00:04] *** shinobicl_ joined
[00:28] *** mj41 left
[00:29] <colomon> sorear: nextwith works again?

[00:34] <sorear> colomon: nextwith has always worked, but the semantics changed recently

[00:35] <colomon> I was under the impression you'd removed it recently because of the semantic change.

[00:35] <sorear> ah, no, sorry about that - I removed uses of it from the compiler

[00:35] *** nacho joined
[00:35] <colomon> I'd hesitated messing further with panda because I knew panda used it.  

[00:35] *** nacho is now known as Guest34864

[00:35] <sorear> in order for the compiler to work on both new-niecza and old-niecza, it can't use nextwith at all

[00:35] <colomon> so imagine my surprise again when I tried my version of panda and it Just Worked.

[00:36] <colomon> sorear: ah, gotcha.

[00:36] <colomon> I'm working on getting Math::Prime niecza friendly atm.

[00:36] <sorear> cool

[00:38] * sorear is currently trying to get $obj.::('Foo::Bar') to work

[00:39] <colomon> success!  just used my (installed) version of panda-niecza to install Math::Prime.

[00:40] <colomon> it's less than completely elegant, but it works

[00:40] <sorear> WOW

[00:40] <sorear> colomon++ # panda-niecza actually working?!

[00:40] <colomon> there are a couple of issues which still need to be resolvedd

[00:40] <colomon> right now it's hard-wired to use my personal install of niecza

[00:41] *** shinobicl_ left
[00:41] <colomon> I need to figure out a better approach than that.  (normal panda just calls a perl6 executable)

[00:41] <colomon> and there are some warnings that should be silenced (or possible represent bugs that need to be fixed)

[00:42] <colomon> but yeah, it works

[00:42] <colomon> (oh, and there are issues with a lock file not being cleaned up if an install aborts)

[00:42] <sorear> hmm, is END working for you?

[00:43] <colomon> I don't know.  (panda is definitely not trying to use it.)  

[00:43] <jnthn> sleep &

[00:43] <colomon> there's probably a spectest for it, no?

[00:43] <colomon> jnthn: 'night

[00:45] *** dorlamm left
[00:45] <sorear> colomon: yes, there are a few END spectests (which weren't working for [Coke] at one point)

[00:46] <colomon> .... looks like the END spectests are mostly marked todo.  :(

[00:46] <colomon> errr, they're all eval based.

[00:47] <sorear> ascending-order has nontodo END tests

[00:48] <colomon> looks like it does work for me.  (Just tried END { say "In end!" }; and it printed okay.)

[00:48] <colomon> so if I can figure out the lock thing, I maybe can fix it that way.

[00:51] *** Maddingue left
[00:51] <tadzik> colomon: wow, that's awesome!

[00:52] <colomon> tadzik: most of the changes have been basically cosmetic, it definitely ought to be possible to re-merge the versions in the long run

[00:52] <dalek> niecza: 59f5ccb | sorear++ | / (5 files):

[00:52] <dalek> niecza: Implement $foo.::($bar)() form

[00:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/59f5ccbaa6

[00:55] *** lestrrat left
[00:56] *** lestrrat joined
[00:57] *** Maddingue joined
[00:58] <dalek> niecza: 797fd44 | sorear++ | / (2 files):

[00:58] <dalek> niecza: Support <::($bar)>, <Foo::($bar)> regex syntax (possibly this should not capture?)

[00:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/797fd44853

[00:58] *** Guest34864 left
[01:13] <colomon> sorear: with 797fd44, spectest is clean except for the usual S02-magicals/env.t fail.

[01:23] <colomon> tadzik: hmmm, I've still got some sort of issue here

[01:26] <colomon> it's .panda/state

[01:27] <colomon> ~/.panda/state

[01:30] *** Yary joined
[01:32] * colomon just installed HTTP::Easy, though it doesn't seem to have much in the way of tests, so who knows if it works.

[01:43] <colomon> sorear: seems like $! is giving us problems in panda-niecza?

[01:43] *** whiteknight joined
[02:17] *** Gruber joined
[02:18] *** Grrrr left
[02:19] *** clkao left
[02:20] *** clkao joined
[02:34] *** wolfman2000 joined
[02:52] *** PacoAir left
[02:57] *** whiteknight left
[02:58] *** bbkr1 left
[02:58] *** bbkr1 joined
[03:01] *** Exodist left
[03:01] *** Exodist joined
[03:02] *** raiph left
[03:02] *** bloonix left
[03:03] *** bloonix joined
[03:03] *** buubot_backup left
[03:05] *** aloha left
[03:07] *** aloha joined
[03:10] *** ksi left
[03:10] <colomon> loliblogged: http://justrakudoit.wordpress.com/2012/01/29/modules-and-perl-6s/

[03:14] *** buubot_backup joined
[03:20] *** orafu left
[03:20] *** orafu joined
[03:24] <dalek> niecza: 7b72ce0 | sorear++ | lib/NieczaCLR.cs:

[03:24] <dalek> niecza: Make CLR-interop not make duplicate wrappers so often

[03:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7b72ce051a

[03:29] <dalek> niecza: f072aab | sorear++ | lib/NieczaCLR.cs:

[03:29] <dalek> niecza: Give CLR class wrappers non-null HOW pointers (oops!)

[03:29] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f072aabf71

[03:36] *** ponbiki joined
[03:41] *** Patterner left
[03:44] *** Psyche^ joined
[03:44] *** Psyche^ is now known as Patterner

[03:51] <colomon> sorear: spectest still the same.  :)

[03:51] <colomon> 'night

[03:52] <sorear> 'night

[03:53] <dalek> niecza: 92251b1 | sorear++ | lib/NieczaCLR.cs:

[03:53] <dalek> niecza: Treat interfaces roleishly, allowing $obj.CLR::System::IDisposable::Dispose to work (fixes #56)

[03:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/92251b189d

[04:05] *** alvis joined
[04:11] *** tokuhirom joined
[04:13] *** Chillance left
[04:15] <dalek> niecza: bc8344f | sorear++ | src/niecza:

[04:15] <dalek> niecza: Make it possible to pass arguments to ::(method)...

[04:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bc8344f251

[04:15] *** tokuhirom left
[04:16] *** tokuhirom joined
[04:19] *** ponbiki left
[04:20] *** tokuhirom left
[04:20] *** ponbiki joined
[04:25] *** offby1 joined
[04:25] <dalek> niecza: 20aa772 | sorear++ | lib/NieczaCLR.cs:

[04:25] <dalek> niecza: Actually, punning messes up calls, so do not treat interfaces as full roles ...

[04:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/20aa77253f

[04:25] <offby1> What's the file-test operator look like these days?  I thought it was :f, but -- if ($cache_file_name ~~ :f)  =>  Method 'f' not found for invocant of class 'Str'

[04:29] <sorear> if $cache_file_name.IO ~~ :f

[04:30] <offby1> oho, tx

[04:33] <sorear> niecza: class A { has $.x = 4; has $.y = $!y; } say A.new.y

[04:33] <p6eval> niecza v13-376-g92251b1: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/cVYNE9nlfG line 1:␤------> [32mclass A { has $.x = 4; has $.y = $!y; }[33m⏏[31m say A.new.y[0m␤␤Parse failed␤␤»

[04:33] <sorear> niecza: class A { has $.x = 4; has $.y = $!x; }; say A.new.y

[04:33] <p6eval> niecza v13-376-g92251b1: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical self in A init␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ␤  at Niecza.CLRBackend.Na…

[04:34] <sorear> niecza: class A { has $.x = 4; has $.y = $!x; };

[04:34] <p6eval> niecza v13-376-g92251b1: OUTPUT«Unhandled exception: System.Exception: Unable to find lexical self in A init␤  at Niecza.CLRBackend.NamProcessor.ResolveLex (System.String name, Boolean upf, System.Int32& uplevel, Boolean core) [0x00000] in <filename unknown>:0 ␤  at Niecza.CLRBackend.Na…

[04:34] <sorear> niecza: class A { has $.y = die "moo"; };

[04:34] <p6eval> niecza v13-376-g92251b1:  ( no output )

[04:34] <offby1> is there some equivalent to python's "dir" function?  That is, a uniform way that I can find out what methods are available on a given object?

[04:34] <sorear> nom: say $*OUT.^methods

[04:35] <p6eval> nom 9719f7: OUTPUT«open close eof get getc lines read seek tell write opened print slurp d e f l r s t w x z copy chmod say ins chomp path␤»

[04:35] <sorear> offby1: that

[04:35] <sorear> offby1: also, welcome to #perl6

[04:35] <offby1> tx :)

[04:35] <offby1> I dip in about twice a year

[04:37] *** benabik left
[04:47] *** wooden left
[04:58] *** benabik joined
[05:28] *** bkolera joined
[05:56] *** Trashlord joined
[06:26] *** wooden joined
[06:26] *** wooden left
[06:26] *** wooden joined
[06:33] *** kaare_ joined
[06:35] *** kaare__ joined
[06:37] *** kaare_ left
[06:38] <moritz> o/

[06:54] *** wolfman2000 left
[06:57] <sorear> o/ moritz

[07:07] *** kaare__ left
[07:16] <sorear> moritz: if you do perl6/specs@0de30c in the commit log, it'll show up as a link on github

[07:16] <sorear> e.g. see the last commit on https://github.com/perl6/roast

[07:19] <moritz> sorear: ok, I'll try to remember the syntax

[07:20] <sorear> I'm not by any means insisting you do it.  IMO github is secondary, I'm mainly writing for 'git log'

[07:21] <moritz> it is nice to have a standard syntax for that though

[07:39] *** xinming left
[07:52] <moritz> phenny: ask tadzik if there are any Pod related errors that the user can make that aren't syntax errors

[07:52] <phenny> moritz: I'll pass that on when tadzik is around.

[07:52] <moritz> std: loop(1; 1; 1) { }

[07:52] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Word 'loop' interpreted as 'loop()' function call; please use whitespace around the parens at /tmp/G2PrJXo3eB line 1:␤------> [32mloop[33m⏏[31m(1; 1; 1) { }[0m␤Unexpected block in infix position (two terms in a row) at /tmp/G2PrJXo3…

[07:53] <moritz> std: loop{ }

[07:53] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'loop' used at line 1␤Check failed␤FAILED 00:01 108m␤»

[07:53] <moritz> curious.

[07:55] <moritz> std: @

[07:55] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Non-declarative sigil is missing its name at /tmp/TTZQsbwYgY line 1:␤------> [32m<BOL>[33m⏏[31m@[0m␤Use of uninitialized value $first in string eq at STD.pm line 66226.␤Use of uninitialized value $sigil in string eq at STD.pm line 6…

[07:56] *** s1n left
[07:59] *** samlh left
[08:14] <moritz> nom: #`

[08:14] <p6eval> nom 9719f7:  ( no output )

[08:14] <moritz> huh.

[08:17] *** birdwindupbird joined
[08:18] <dalek> rakudo/typed-exceptions-smoke: d63e72d | moritz++ | src/ (2 files):

[08:18] <dalek> rakudo/typed-exceptions-smoke: more typed syntax errors

[08:18] <dalek> rakudo/typed-exceptions-smoke: review: https://github.com/rakudo/rakudo/commit/d63e72d744

[08:18] <dalek> rakudo/typed-exceptions-smoke: 5e82cc3 | moritz++ | src/ (2 files):

[08:18] <dalek> rakudo/typed-exceptions-smoke: more typed errors; fix error for #` without following block

[08:18] <dalek> rakudo/typed-exceptions-smoke: review: https://github.com/rakudo/rakudo/commit/5e82cc3d77

[08:19] <moritz> that branch is just so that I can spectest my changes on a faster computer before pushing them to nom

[08:21] *** ponbiki left
[08:25] <moritz> std: }

[08:25] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected closing bracket at /tmp/hOqa4Z0VzU line 1:␤------> [32m<BOL>[33m⏏[31m}[0m␤Parse failed␤FAILED 00:01 105m␤»

[08:25] <moritz> std: -

[08:25] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Prefix requires an argument at /tmp/dZ5Nv4ZsPf line 1 (EOF):␤------> [32m-[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 107m␤»

[08:25] <moritz> what's an easy way to trigger a "Confused" message from STD?

[08:26] <sorear> std: ∞

[08:26] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus statement at /tmp/OkQ2LjfjJL line 1:␤------> [32m<BOL>[33m⏏[31m∞[0m␤Parse failed␤FAILED 00:01 109m␤»

[08:26] *** bkolera left
[08:26] <sorear> std: 1∞

[08:27] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused at /tmp/_hw3054A2J line 1:␤------> [32m1[33m⏏[31m∞[0m␤    expecting any of:␤    POST␤   bracketed infix␤        infix or meta-infix␤    postfix␤        postfix_prefix_meta_operator␤   statement modifier loop␤Parse failed␤FAILED 00:01

[08:27] <p6eval> ..108m␤»…

[08:27] <sorear> looks like that did the trick

[08:28] *** bkolera joined
[08:29] <moritz> thanks

[08:36] <sorear> perl6: sub foo { say +(True ff False) }; for ^5 { foo }

[08:36] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&infix:ff"␤    at /tmp/T4AqNqN27e line 1, column 17-30␤»

[08:36] <p6eval> ..niecza v13-378-g20aa772: OUTPUT«1␤2␤3␤4␤5␤»

[08:36] <p6eval> ..rakudo 9719f7: OUTPUT«1␤1␤1␤1␤1␤»

[08:37] <sorear> perl6: sub foo { say +(True ff True) }; for ^5 { foo }

[08:37] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&infix:ff"␤    at /tmp/fAqIT7FcxQ line 1, column 17-29␤»

[08:37] <p6eval> ..rakudo 9719f7, niecza v13-378-g20aa772: OUTPUT«1␤1␤1␤1␤1␤»

[08:37] <sorear> perl6: sub foo { say +($_ ff False) }; for ^5 { foo 0; foo 1 }

[08:37] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'foo' will never work with argument types (int) (lines 1, 1)␤    Expected: :()␤»

[08:37] <p6eval> ..niecza v13-378-g20aa772: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[08:37] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&infix:ff"␤    at /tmp/9Dtgxu04hz line 1, column 17-28␤»

[08:38] <sorear> perl6: sub foo($_) { say +($_ ff False) }; for ^5 { foo 0; foo 1 }

[08:38] <p6eval> rakudo 9719f7: OUTPUT«0␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[08:38] <p6eval> ..niecza v13-378-g20aa772: OUTPUT«0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤»

[08:38] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&infix:ff"␤    at /tmp/0w_Zr_vo_4 line 1, column 21-32␤»

[08:38] <sorear> perl6: for ^5 { sub foo($_) { say +($_ ff False) }; foo 0; foo 1 }

[08:38] <p6eval> rakudo 9719f7: OUTPUT«0␤1␤1␤1␤1␤1␤1␤1␤1␤1␤»

[08:38] <p6eval> ..niecza v13-378-g20aa772: OUTPUT«0␤1␤0␤1␤0␤1␤0␤1␤0␤1␤»

[08:38] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&infix:ff"␤    at /tmp/MzfS9Cjo00 line 1, column 30-41␤»

[08:38] <sorear> nom: sub foo { $_ }; say foo 15

[08:38] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'foo' will never work with argument types (int) (line 1)␤    Expected: :()␤»

[08:39] <sorear> moritz: known bug?

[08:39] <moritz> bug?

[08:39] <moritz> you didn't put $_ in the signature

[08:39] <sorear> there is no signature, so it defaults to \$_ = $OUTER::_

[08:40] <moritz> for blocks, yes

[08:40] <moritz> for subs, the implicit signature is based on the presence of @_ and %_

[08:40] <sorear> STD has the same implicit signature rules for blocks and subs

[08:41] <moritz> that seems wrong

[08:41] <moritz> it means you can't do stuff like   sub f { for 1..2 { say @_[$_] } }

[08:41] <moritz> because then the @_ ends up being in the signature of the block, not the sub

[08:42] <moritz> , 

[08:42] <moritz> also when rakudo tried to implement those semantics back in the days, nobody knew how $_ and @_ interacted

[08:43] <sorear> so there's something in the prose spec that contradicts STD.getsig?  or is this an @Larry decision that somehow never got recorded?

[08:43] <moritz> I don't think the specs well enough to tell

[08:44] <moritz> but I do know that $_ and @_ don't interact well in any intuitive way

[08:44] <moritz> perl6: sub f { say $_ }; f 3

[08:44] <p6eval> niecza v13-378-g20aa772: OUTPUT«3␤»

[08:44] <p6eval> ..rakudo 9719f7: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'f' will never work with argument types (int) (line 1)␤    Expected: :()␤»

[08:44] <p6eval> ..pugs b927740: OUTPUT«␤»

[08:45] <moritz> if the spec says nothing about it, I'd assume p5 behavior in having $_ not interact with arguments passed to subs

[08:45] <moritz> niecza: sub f { say $_.perl; say @_.perl }; f 1, 2, 3

[08:45] <p6eval> niecza v13-378-g20aa772: OUTPUT«Any␤(1, 2, 3).list␤»

[08:46] <moritz> niecza: sub f { say $_.perl; say @_.perl }; $_ = 5; f

[08:46] <p6eval> niecza v13-378-g20aa772: OUTPUT«Any␤().list␤»

[08:46] <moritz> that doesn't make any sense, if $_ defaults to OUTER::$_

[08:48] <moritz> nom: =begin

[08:48] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead at line 1, near "begin"␤»

[08:48] <moritz> nom: =begin foo

[08:48] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead at line 1, near "begin foo"␤»

[08:49] <sorear> moritz: the presence of @_ suppresses the generation of a $_ par ameter, so you're seeing the mainline $_

[08:49] <sorear> niecza: say ({ 5 }).signature

[08:49] <p6eval> niecza v13-378-g20aa772: OUTPUT«:(Any \$_)␤»

[08:49] <sorear> niecza: say ({ $_ }).signature

[08:49] <p6eval> niecza v13-378-g20aa772: OUTPUT«:(Any \$_)␤»

[08:49] <sorear> niecza: say ({ $_, @_ }).signature

[08:49] <p6eval> niecza v13-378-g20aa772: OUTPUT«:(*@_)␤»

[08:50] <sorear> niecza: say ({ $^foo }).signature

[08:50] <p6eval> niecza v13-378-g20aa772: OUTPUT«:(Any $foo)␤»

[08:50] <sorear> hey, I just noticed I could probably port Math::Model now

[08:50] <moritz> but the mainline $_ is 5, no?

[08:50] <moritz> niecza: sub f { say $_.perl; say @_.perl }; $_ = 5; f

[08:51] <p6eval> niecza v13-378-g20aa772: OUTPUT«Any␤().list␤»

[08:51] <sorear> erm... I think niecza does a 'my $_' in routines by default

[08:51] <sorear> if $_ is not created by the signature

[08:52] <sorear> I'll wait for the ruling

[08:52] <moritz> my next suggestion would have been to wait for TimToady++, right :-)

[08:52] <sorear> I should start on announce.v14 RSN too

[09:03] <dalek> niecza: 6915253 | sorear++ | / (2 files):

[09:03] <dalek> niecza: Ignore arguments to rules for LTM purposes

[09:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6915253d90

[09:10] *** birdwindupbird left
[09:11] <masak> morning, #perl6! \o/

[09:11] <sorear> MASAK!

[09:11] <masak> jnthn++ # http://6guts.wordpress.com/2012/01/29/this-months-rakudo-star-release-and-whats-coming-next/

[09:11] <sorear> \o/

[09:12] <masak> sorear: re `-I=path` not working being intentional -- long-term, I hope there will be a convergence on command-line flags between Niecza and Rakudo.

[09:15] <sorear> yes

[09:15] <dalek> niecza: f341570 | sorear++ | / (2 files):

[09:15] <dalek> niecza: Implement protoregexes forwarding arguments to callees

[09:15] <dalek> niecza: 

[09:15] <dalek> niecza: The bit in spec where equal longest terms fall back to type-based MMD if

[09:15] <dalek> niecza: there are arguments is not yet implemented, and probably never will be.

[09:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f34157099c

[09:18] <masak> just a few hours remain of p6cc! hurry, hurry!

[09:20] <dalek> niecza: 4158fa9 | sorear++ | docs/TODO.S05:

[09:20] <dalek> niecza: Check off parameters/LTM on TODO.S05

[09:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4158fa911a

[09:23] <sorear> oops, I guess I'll have to work on announce.v14 tomorrow

[09:23] <fasad> hi !

[09:23] <sorear> hello fasad

[09:23] <sorear> anything I can do for you real quick before I run off to bed?

[09:24] <fasad> so i found out that declaring more than one array on the same my statement does not work. why ?

[09:24] <fasad> my @a, @b;

[09:24] <sorear> need parens

[09:24] <sorear> std: my @a, @b;

[09:24] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable @b is not predeclared (declarators are tighter than comma, so maybe your 'my' signature needs parens?) at /tmp/YcYIR98sOy line 1:␤------> [32mmy @a, [33m⏏[31m@b;[0m␤Check failed␤FAILED 00:01 111m␤»

[09:24] <fasad> oh

[09:25] <sorear> niecza: my @a, @b; # curious

[09:25] <p6eval> niecza v13-379-g6915253: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable @b is not predeclared (declarators are tighter than comma, so maybe your 'my' signature needs parens?) at /tmp/w0FeGzOazs line 1:␤------> [32mmy @a, [33m⏏[31m@b; # curious[0m␤␤Potential difficulties:␤  @a is de…

[09:25] <fasad> one last thing, how to assign same value to all the array elements?

[09:25] <masak> could have a better error message.

[09:25] <sorear> masak: what do you propose?

[09:25] <masak> fasad: my @a = $value xx $length;

[09:26] <sorear> fasad: arrays go up to infinity.  Assigning the same value to *all* of them could take a while

[09:26] <masak> sorear: "Variable @b not predeclared (did you forget parentheses?)"

[09:26] <fasad> sorear: couldn't it be lazy?

[09:26] <sorear> masak: you think that's better than what STD already does?

[09:26] <masak> fasad: lists are lazy, arrays are not.

[09:26] <masak> sorear: oh!

[09:27] <masak> sorear: didn't read properly. :/

[09:27] <fasad> btw, rakudo complains about @b being not predeclared. Its warning has room for improvement !

[09:28] <masak> though I do think that "parens", cute as it is, is a less well-known term than "parentheses".

[09:28] <masak> fasad: yes.

[09:28] * masak submits rakudobug

[09:28] <masak> rakudo: my @a, @b;

[09:28] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Variable @b is not predeclared at line 1, near ";"␤»

[09:29] <sorear> reminds me of bras and kets

[09:29] * sorear really -> sleep now

[09:29] <fasad> masak: +1 (on "parenthesea")

[09:29] <fasad> *parentheses

[09:30] <masak> 'night, sorear. dream of arrays going up to infinity.

[09:30] <fasad> good night sorear

[09:31] <eviltwin_b> niecza's ladder?

[09:31] <masak> :)

[09:38] <masak> there are 1243 #perl6 tickets with 'cmasak' as a requestor on RT. 816 resolved, 382 new/open, 44 rejected, 1 stalled.

[09:39] <masak> 664 new/open/stalled tickets overall. more'n half of the new/open bugs are from me :>

[09:42] <masak> 1985 resolved/rejected tickets overall. so, I only have 43% of those. the rest of you guys are still slightly ahead on that one.

[09:49] *** Patterner left
[09:55] <bacek> ~~

[09:56] <bacek> seen jnthn

[09:56] <aloha> jnthn was last seen in #perl6 9 hours 12 mins ago saying "sleep &".

[09:57] <masak> bacek: he'll be around shortly.

[09:57] <masak> (we didn't drink *that* much beer last night) :P

[09:57] <bacek> phenny, tell jnthn rakudo/src/binder/bind.c, line 755 will be broken soon :)

[09:57] <phenny> bacek: I'll pass that on when jnthn is around.

[09:58] <masak> ooh, advance notice! bacek++

[09:58] <bacek> masak, yeah. Beer is good :)

[09:58] <masak> especially good beer :)

[09:58] <bacek> masak, indeed!

[10:00] *** GlitchMr joined
[10:01] <moritz> nom: say 9 ** 4

[10:01] <p6eval> nom 9719f7: OUTPUT«6561␤»

[10:02] <masak> moritz: t1? :)

[10:03] <moritz> masak: t1.

[10:03] *** SHODAN joined
[10:17] *** Psyche^ joined
[10:17] *** Psyche^ is now known as Patterner

[10:20] *** espadrine joined
[10:33] *** espadrine left
[10:42] *** mj41 joined
[10:47] <bbkr1> moritz: I've reported #109306 about Socket:INET not handling line separator properly, but i'm not sure if it is rakudo bug or nqp problem with readline.

[10:49] *** whiteknight joined
[10:51] <moritz> bbkr1: migth be a problem in the chomping logic

[10:53] <moritz> which is done in IO::Socket somewhere

[10:55] <moritz> nom: say (9 + 9) * (9 + 9)

[10:55] <p6eval> nom 9719f7: OUTPUT«324␤»

[10:59] <moritz> nom: say 9 / ((9 + 9) / 9)

[10:59] <p6eval> nom 9719f7: OUTPUT«4.5␤»

[11:20] *** fsergot joined
[11:21] <fsergot> o/

[11:38] <masak> \o

[11:58] *** Moukeddar joined
[12:07] <masak> Moukeddar! \o/

[12:07] <Moukeddar> Hello Sir o/

[12:07] <masak> hello dear fellow.

[12:11] <masak> blog post! http://strangelyconsistent.org/blog/the-perl-6-coding-contest-2011-edition-is-now-closed

[12:14] <jnthn> afternoon o/

[12:14] <phenny> jnthn: 09:57Z <bacek> tell jnthn rakudo/src/binder/bind.c, line 755 will be broken soon :)

[12:15] <jnthn> bacek: That's fine; hints on what to change it to are very helpful too :)

[12:15] <jnthn> bacek: Or even *gasp* a proper API for me to actually implement the stuff I'm doing there. ;-)

[12:19] *** xinming joined
[12:21] <masak> +1

[12:22] <masak> this is how the Rakudo<->Parrot collaboration should work, all the time :)

[12:22] <masak> advance notices, friendly cross-channel banter, suggestions of APIs :)

[12:23] *** birdwindupbird joined
[12:32] <felher> masak++ # blog post about the p6cc :)

[12:47] *** Moukeddar left
[12:50] *** ksi joined
[12:54] <tadzik> moritz: yeah, I can think of some

[12:54] <phenny> tadzik: 07:52Z <moritz> ask tadzik if there are any Pod related errors that the user can make that aren't syntax errors

[12:54] <tadzik> good morning

[12:54] <tadzik> I think some of them are already reported by panic()

[12:54] <moritz> good "morning" tadzik :-)

[12:54] <tadzik> 13:54? Oh my

[12:55] <colomon> \o

[12:57] <jnthn> :)

[12:57] <tadzik> colomon: re ~/.perl6 and ~/.niecza, do we assume that Rakudo modules are different than Niecza modules?

[12:58] <colomon> tadzik: that's been my assumption, though in practice, a lot of modules can go both ways

[12:59] <tadzik> I'd assume they're the same .pm files

[12:59] <colomon> or perhaps the right way of saying it is modules should be installed separately for the two compilers even if they're the same .pm files.

[12:59] <tadzik> well, do they?

[13:00] <tadzik> I'm thinking about some sort of perl6-switcher tool (more)

[13:00] <masak> good post-noon, tadzik

[13:00] <tadzik> it'll keep modules for both, and when you do perl6-switcher rakudo, 'perl6' executable becomes /path/to/rakudo, and ~/.perl6 becomes ~/.perl6-switcher/rakudo/ or something

[13:01] <tadzik> sort of like perlbrew manages multiple Perl fives

[13:01] <tadzik> masak: good morn... good day masak 

[13:01] <colomon> yeah, that would be another interesting way of handling the situation.

[13:02] <tadzik> It feels wrong to me to have both ~/.perl6 and ~/.niecza. Because then, why not ~/.rakudo and ~/.niecza? And then, what is perl6 after all?

[13:02] <moritz> well, I'd say ~/.perl6/rakudo and ~/.perl6/niecza

[13:02] <colomon> tadzik: well, I was trying to present a solution that wouldn't require changing how rakudo works; but obviously switching to ~/.rakudo makes more sense.  ;)

[13:03] <tadzik> imho, it doesn't :P

[13:03] <tadzik> I think .niecza has a right to use ~/.perl6 as much as rakudo does, if you know what I mean

[13:04] <masak> +1

[13:04] <masak> here's my take on it: outsiders will always expect to run a 'perl6' executable.

[13:04] <masak> that's why Rakudo got on in the first place.

[13:05] <masak> there's a strain of thought saying Rakudo is encroaching on the 'perl6' name, but I don't think that's it.

[13:05] <masak> no more than any particular C compiler is squatting the 'cc' name.

[13:06] <colomon> right -- but when you install GCC (for instance), it installs "gcc" and /usr/lib/gcc...

[13:07] <masak> I didn't say all compilers install themselves on /usr/bin/cc

[13:07] <masak> I'm saying there is more than one that does.

[13:07] *** cognominal_ left
[13:08] *** cognominal_ joined
[13:08] <masak> and it's not considered a problem.

[13:08] <colomon> which cc

[13:09] <colomon> lrwxr-xr-x  1 root  wheel  32 Jun 13  2011 /usr/bin/cc -> ../llvm-gcc-4.2/bin/llvm-gcc-4.2

[13:13] <colomon> If Rakudo installs "rakudo" and Niecza installs "niecza" and they use ~/.rakudo and ~/.niecza, then the perl6 executable can be whatever the user wants.  That's a fine solution in my book.

[13:14] <colomon> (And yes, "perl6" can change just like perlbrew)

[13:15] <jnthn> Either ~/.[rakudo|niecza] or ~/.perl6/[rakudo|niecza]/ seem workable to me.

[13:16] <colomon> +1

[13:16] <moritz> in the long run, do we want a shared installation dir, with custom subdirs for implementation specific files?

[13:17] <moritz> if so, we might want ~/.perl6/lib for .pm6 files, and ~/.perl6/rakudo/blib/ for .pir files or so

[13:18] <colomon> moritz: I'm hesitant about shared installation dir, just because it seems like the cleanest way to avoid having modules which only work on one implementation muddle up the other implementation is to have separate include paths.

[13:20] <colomon> might be particularly important in the case where a module compiles but doesn't actually work (ie tests fail so it won't install in an implementation-specific /lib)

[13:21] <moritz> right

[13:26] *** icwiener joined
[13:40] *** xinming left
[13:40] *** PacoAir joined
[13:53] <colomon> phenny: tell sorear The last test of S05-grammar/protoregex.t has gone from needing a todo to needing a skip.    I know this is what you were working on last night, so I thought I'd bring it to your attention before refudging.

[13:53] <phenny> colomon: I'll pass that on when sorear is around.

[13:54] *** tokuhirom joined
[14:05] *** ksi left
[14:11] <dalek> nqp/bs: a32b456 | jnthn++ | t/serialization/01-basic.t:

[14:11] <dalek> nqp/bs: Tests for VM array serialization.

[14:11] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/a32b456e60

[14:11] <dalek> nqp/bs: a7d8e0f | jnthn++ | src/6model/serialization.c:

[14:11] <dalek> nqp/bs: Implement VM array serialization; tests pass.

[14:11] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/a7d8e0f697

[14:11] <dalek> nqp/bs: 1f52d8b | jnthn++ | t/serialization/01-basic.t:

[14:11] <dalek> nqp/bs: Tests for hash serialization.

[14:11] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/1f52d8bc51

[14:11] <dalek> nqp/bs: 7ca562f | jnthn++ | src/6model/serialization.c:

[14:11] <dalek> nqp/bs: Hash serialization. Tests pass.

[14:11] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7ca562f772

[14:11] *** mucker joined
[14:16] *** kmwallio joined
[14:18] <fasad> rakudo: say 3**5;

[14:18] <p6eval> rakudo 9719f7: OUTPUT«243␤»

[14:19] <fasad> rakudo: say "3**5";

[14:19] <p6eval> rakudo 9719f7: OUTPUT«3**5␤»

[14:19] <fasad> rakudo: say "{3**5}";

[14:19] <p6eval> rakudo 9719f7: OUTPUT«243␤»

[14:19] <moritz> rakudo: say ([+] (3**5).comb) %% 9

[14:19] <p6eval> rakudo 9719f7: OUTPUT«Bool::True␤»

[14:19] <fasad> sweet :)

[14:20] <tadzik> :)

[14:21] <fasad> what does this error mean: Null PMC access in find_method('postcircumfix:<[ ]>')

[14:21] <tadzik> that means "it shouldn't have happened, please report a bug"

[14:21] <tadzik> what's the code?

[14:22] <fasad> tadzik: let me paste it somewhere & come back

[14:22] <tadzik> sure thing

[14:24] <masak> short code trumps long code.

[14:24] <colomon> nom: sub d(*@pos, *%named) { }; my @l = &d.signature.params; say @l>>.named

[14:24] <p6eval> nom 9719f7: OUTPUT«Bool::False Bool::True␤»

[14:25] <colomon> niecza: sub d(*@pos, *%named) { }; my @l = &d.signature.params; say @l>>.named

[14:25] <p6eval> niecza v13-381-g4158fa9: OUTPUT«Potential difficulties:␤  @pos is declared but not used at /tmp/YSW4pSwbzD line 1:␤------> [32msub d(*[33m⏏[31m@pos, *%named) { }; my @l = &d.signature[0m␤  %named is declared but not used at /tmp/YSW4pSwbzD line 1:␤------> [32msub d(*@pos, *[33m⏏[…

[14:25] <colomon> niecza: sub d(*@pos, *%named) #ok { }; my @l = &d.signature.params; say @l>>.named

[14:25] <p6eval> niecza v13-381-g4158fa9: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed block at /tmp/vezcIOjQRS line 1 (EOF):␤------> [32m@l = &d.signature.params; say @l>>.named[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[14:26] <colomon> niecza: sub d(*@pos, *%named) { say @pos.perl ~ %named.perl }; my @l = &d.signature.params; say @l>>.named

[14:26] <p6eval> niecza v13-381-g4158fa9: OUTPUT«Bool::False Bool::False␤»

[14:27] <colomon> ah

[14:27] *** icwiener left
[14:27] *** icwiener joined
[14:29] <dalek> roast: 59e3518 | (Solomon Foster)++ | S06-signature/introspection.t:

[14:29] <dalek> roast: Heavy fudging for niecza.

[14:29] <dalek> roast: review: https://github.com/perl6/roast/commit/59e351885b

[14:29] *** xinming joined
[14:29] <dalek> niecza: e9bafb9 | (Solomon Foster)++ | t/spectest.data:

[14:29] <dalek> niecza: Turn on S06-signature/introspection.t.

[14:29] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e9bafb9a07

[14:30] *** LlamaRider joined
[14:32] <dalek> nqp/bs: 76e62d8 | jnthn++ | src/6model/serialization.c:

[14:32] <dalek> nqp/bs: Make some naming more consistent.

[14:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/76e62d83e4

[14:32] <dalek> nqp/bs: b3b2a5b | jnthn++ | t/serialization/01-basic.t:

[14:32] <dalek> nqp/bs: Tests for serializing integer and string arrays.

[14:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b3b2a5be69

[14:32] <dalek> nqp/bs: dc73db6 | jnthn++ | t/serialization/01-basic.t:

[14:32] <dalek> nqp/bs: Use explicit nqp::elems in element counting tests.

[14:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/dc73db6a5e

[14:32] <dalek> nqp/bs: d142652 | jnthn++ | src/6model/serialization.c:

[14:32] <dalek> nqp/bs: Serialization of integer and string arrays. That should be all the primitives in place.

[14:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/d1426528b2

[14:34] *** tokuhirom left
[14:34] *** tokuhirom joined
[14:36] <fasad> tadzik: i'm trying to draw a Chess Board; http://tinypaste.com/b1dea7fe ; warning: the code is not pretty !

[14:36] <jnthn> afk for a bit

[14:38] <fasad> jnthn: oh. have a look :)

[14:38] <tadzik> fasad: it's not bad. I'm looking into it

[14:39] *** tokuhirom left
[14:39] <masak> nom: my ((@a = 1, 2, 3), (@b = 4, 5, 6)); say @b.perl

[14:39] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Cannot put required parameter after optional parameters␤at /tmp/Zs99vI3Htt:1␤»

[14:39] *** Yary left
[14:39] <masak> fasad: that's not how you initialize multiple arrays.

[14:39] <masak> nom: my (@a, @b); @a = 1, 2, 3; @b = 4, 5, 6; say @b.perl

[14:39] <p6eval> nom 9719f7: OUTPUT«Array.new(4, 5, 6)␤»

[14:41] <tadzik> nom: my ((@a)); say @a.perl;

[14:41] <p6eval> nom 9719f7: OUTPUT«Null PMC access in find_method('perl')␤  in block <anon> at /tmp/_QVyc6Q8Fe:1␤  in <anon> at /tmp/_QVyc6Q8Fe:1␤»

[14:41] <tadzik> aside from how should that react, I call LTA

[14:41] <tadzik> niecza: my ((@a)); say @a.perl;

[14:41] <p6eval> niecza v13-381-g4158fa9: OUTPUT«[].list␤»

[14:41] <tadzik> or even a bug

[14:41] <tadzik> std: my ((@a)); say @a.perl;

[14:41] <p6eval> std 48335fc: OUTPUT«ok 00:01 112m␤»

[14:42] <fasad> masak: yeah removing the parentheses gets rid of the error

[14:42] <fasad> but the code still does not dwim

[14:42] *** whiteknight left
[14:44] <fasad> darn. in the last but fourth line, i meant to write {9-$_}, i forgot the braces in the paste. however it still does not work

[14:47] <tadzik> fasad: works for me

[14:47] <tadzik> well, sort of

[14:47] <fasad> ok, code with the parens removed & the including the braces: http://tinypaste.com/69154f0f

[14:48] <tadzik> yeah, it's fine

[14:48] <fasad> i get "use of uninitialized value of type Any in string context"

[14:48] <tadzik> fasad: https://gist.github.com/1699126

[14:48] <tadzik> note: say "{9-$_} |  ...

[14:50] <masak> my (@a = 1..3, @b = 4..6); say @b.perl

[14:50] <masak> nom: my (@a = 1..3, @b = 4..6); say @b.perl

[14:50] <p6eval> nom 9719f7: OUTPUT«Array.new()␤»

[14:50] <masak> fasad: don't initialize arrays like that. it doesn't work.

[14:50] <fasad> tadzik: ?

[14:50] <masak> fasad: see my evaluation above.

[14:50] <masak> nom: my (@a, @b); @a = 1, 2, 3; @b = 4, 5, 6; say @b.perl

[14:50] <p6eval> nom 9719f7: OUTPUT«Array.new(4, 5, 6)␤»

[14:50] *** kmwallio left
[14:50] <tadzik> fasad: what's the problem?

[14:50] <fasad> masak: but is it supposed to work?

[14:51] <fasad> tadzik; yeah i put the braces there but i still get "use of uninitialized value of type Any in string context" repeated eight times for each say "{9-$_ | ...

[14:52] <tadzik> weird. I don't :)

[14:52] <fasad> tadzik: rakudo, right?

[14:52] <tadzik> yes

[14:52] <masak> fasad: no, that's simply not how you do it.

[14:52] <tadzik> This is perl6 version 2012.01-36-g6eae67e

[14:53] <masak> fasad: at least I've never seen someone initialize a variable with a signature default, which is what you're trying to do.

[14:54] <fasad> forgive my ignorance, what's a signature ?

[14:54] <masak> fasad: though if it shouldn't work -- and I strongly suspect it shouldn't -- then there should be a compile-time warning, really.

[14:54] <masak> fasad: a signature is the ($x) part of 'sub foo($x) { ... }'

[14:55] <fasad> tadzik: how do i find my version? 'perl6 -v' does not work

[14:55] <tadzik> fasad: perl6 --version

[14:55] <fasad> tadzik: This is perl6 version 2012.01-39-g0bcf489

[14:56] <tadzik> that's even newer than mine then

[14:56] <tadzik> definitely not the case

[14:56] <tadzik> fasad: did you run the code I pasted on github?

[14:58] <fasad> tadzik: the github code works :|

[14:58] <tadzik> then diff -uN github.code your.code :)

[14:59] <tadzik> I changed only array declarations and added {} in say(), twice

[14:59] <fasad> tadzik: i did the same. now trying out diff ...

[15:00] *** Radvendii joined
[15:02] <Radvendii> nom: say 1 <= all(0,5) <= 3 # i think someone already saw this but... broken?

[15:02] <p6eval> nom 9719f7: OUTPUT«all(Bool::False, Bool::True)␤»

[15:02] <masak> fasad: when you do 'my ($a, $b, $c)', the '($a, $b, $c)' is a signature too.

[15:03] <fasad> masak: what is so signature-ly about it?

[15:04] <Radvendii> oh wait

[15:04] <Radvendii> that's not a bug

[15:04] <Radvendii> i didn't see that it was all()

[15:05] <masak> fasad: it's not signature-ly, it's an actual signature.

[15:06] <fasad> tadzik: nailed it. i had only removed the parens but forgotten to split each my onto a different line

[15:06] <masak> fasad: and the reason you could even use a '=' inside of it is that '=' means "default value" in signatures. however, default values only make sense for functions, not for variable initializations.

[15:06] * masak gets a vague sense he's been submitting an RT ticket about this once

[15:06] <fasad> masak: sorry, i meant why is it called a signature? #in 'my ($a, $b, $c)'

[15:07] <masak> fasad: hm, dunno exactly.

[15:07] <masak> fasad: probably because it's how the function identifies itself to the world.

[15:08] <fasad> the 'my' function ?!

[15:09] <masak> nono, in the case of 'sub foo($x)'.

[15:09] <masak> and then signatures are simply re-used for 'my' variable initialization.

[15:09] <masak> but it's not a perfect match, and some things will not make perfect sense outside of function declarations.

[15:09] <masak> 'my ($x is copy)' doesn't make much sense either.

[15:10] <fasad> masak: hmm.

[15:12] <jnthn> Note that when you do a list assignment based on a signature, it just does the variable decls and degenerates to a simple Parcel.

[15:12] <fasad> so to be clear, when declaring more-than-one array with 'my', i should not try to initialize them too. correct?

[15:12] <jnthn> I suspect it should whine about signatures that are too complex to do that to.

[15:13] <Radvendii> ummm... i have a ghost variable

[15:13] <Radvendii> i'm getting an error about variable $v

[15:13] <Radvendii> and i've checked every instance of the letter 'v' in my program

[15:13] <fasad> jnthn: i'm still trying to understand the word 'Parcel' !

[15:13] <Radvendii> $v doesn't exist in any form

[15:14] <Radvendii> # such as $^v $!v $.v $v, etc

[15:14] <masak> jnthn: I'm of two minds about actually allowing defaults in 'my' declarations.

[15:14] <masak> jnthn: I can even see real use cases for nested siggie declarations :)

[15:15] <jnthn> masak: So long as you don't expect it to have any influence whatsoever on the assignment that follows...

[15:15] <jnthn> masak: But that'd seem isleading

[15:15] <jnthn> *misleading

[15:15] <jnthn> masak: The defaults...yeah, that could be useful I guess.

[15:17] *** shinobicl_ joined
[15:19] <masak> jnthn: there isn't always an assignment after the declaration.

[15:19] <masak> and of course any such assignment will win over any default.

[15:20] <TimToady> one still might assign too few values

[15:21] <masak> that, too.

[15:21] <TimToady> @_ in a block is discussed at S06:1931

[15:21] <masak> my ($a, $b, $c = 5) = @values;

[15:22] <masak> ok, so I'm for allowing defaults to set variables.

[15:22] * fasad still thinks my ((@a = 1, 2, 3), (@b = 4, 5, 6)) should work :(

[15:23] <tadzik> perl6: my @a = 1, 2, 3; @a = []

[15:23] <p6eval> pugs b927740, rakudo 9719f7, niecza v13-381-g4158fa9:  ( no output )

[15:23] <tadzik> hmm

[15:23] <tadzik> perl6: my @a = 1, 2, 3; @a = []; say @a.perl

[15:23] <p6eval> rakudo 9719f7: OUTPUT«Array.new([])␤»

[15:23] <p6eval> ..niecza v13-381-g4158fa9: OUTPUT«[[]].list␤»

[15:23] <p6eval> ..pugs b927740: OUTPUT«[[],]␤»

[15:23] <masak> fasad: it will, but only with almost that syntax.

[15:23] <tadzik> oddness

[15:23] <masak> fasad: my (@a = (1, 2, 3), @b = (4, 5, 6));

[15:25] <fasad> masak: but any fancy assignment will/does not work?

[15:26] <TimToady> someone should write a Unicode input method that works like Anthy

[15:26] <TimToady> but searches the names

[15:26] <masak> fasad: question too vague :)

[15:27] <masak> fasad: note, though, that I changed my mind 5 minutes ago. :)

[15:29] * fasad has not had anything to eat for last 7 hours :(

[15:29] <fasad> no, i was not coding perl6 for those 7 hours !

[15:29] * fasad is off to dinner

[15:29] *** xinming left
[15:30] *** xinming joined
[15:36] <tadzik> declaring MAIN('ls', Bool :$all), '--all ls' works but 'ls --all' does not. Bug of feature?

[15:36] *** nebuchadnezzar left
[15:37] <Radvendii> is it *remotely* possible that given $i {} is changing the value of $i?

[15:41] <masak> nom: my $i = 5; given $i { $_ = 42 }; say $i

[15:41] <p6eval> nom 9719f7: OUTPUT«42␤»

[15:43] <Radvendii> that's not what i'm saying

[15:43] *** Trashlord left
[15:43] <Radvendii> nom: my $i=5; $i.say; given $i { $i.say};

[15:43] <p6eval> nom 9719f7: OUTPUT«5␤5␤»

[15:43] <Radvendii> and those two are different in my program

[15:44] <Radvendii> which is the same place, i should add, in which i'm getting the error use of uninitialized variable $v of type Any in numeric context

[15:44] <Radvendii> even though $v doesnt exist

[15:44] <Radvendii> in my program at least

[15:44] *** LlamaRider left
[15:44] *** Trashlord joined
[15:46] *** nebuchadnezzar joined
[15:46] *** leprevost joined
[15:48] <masak> Radvendii: I've seen variables being called '$v' in error messages without actually having that name. there's a bug in some error message somewhere.

[15:48] <masak> Radvendii: as to your strange given action-at-a-distance, feel free to golf a short example of it.

[15:48] <Radvendii> masak: oh. that would make more sense. now i know what variable they are talking about at some point

[15:48] <Radvendii> masak: i'll try...

[15:50] <tadzik> btw: USAGE printing .WHY for every MAIN candidate. Yay or nay?

[15:51] <masak> a hesitant yay :)

[15:52] <tadzik> why hesitant? :)

[15:52] <Radvendii> oh come ON!

[15:53] *** cognominal joined
[15:53] <Radvendii> nom: my %a; %a<a> = 5; %a<a> = Nil; say %a.keys

[15:53] <p6eval> nom 9719f7: OUTPUT«a␤»

[15:53] <masak> Radvendii: looks correct to me.

[15:53] <masak> Radvendii: if you want to delete the key, .delete it.

[15:54] <Radvendii> really?

[15:54] <masak> tadzik: because I haven't seen how it looks yet.

[15:54] <tadzik> :)

[15:54] <Radvendii> that's weird...

[15:54] *** am0c joined
[15:54] <masak> Radvendii: tell me why you are surprised at this.

[15:55] <Radvendii> masak: it just seems like if i assign something to Nil, i'm saying it doesn't exist. 'defined' turns up False, so why should it still be a key of the hash?

[15:56] <masak> Radvendii: because there's an undefined value at that location.

[15:56] <masak> Radvendii: defined !=== exists

[15:56] *** cognominal_ left
[15:57] <masak> Radvendii: now, KeyHash behaves the way you expect. but not a normal Hash.

[15:57] <masak> (KeyHash NYI)

[15:57] <Radvendii> ^^ that was coming

[16:01] <Radvendii> i feel like the syntax %a<b>.delete should work... i even know a way to impliment it.

[16:02] <Radvendii> am i wrong that it should work though?

[16:05] <masak> yes, what you want is spelled '%a<b> :delete'

[16:06] <Radvendii> woah. i've never seen *that* syntax

[16:10] *** GlitchMr42 joined
[16:11] *** GlitchMr left
[16:12] <masak> Radvendii: :delete is an adverb. it's something that modifies an operator, in this case the .<b> access

[16:13] <Radvendii> how does one impliment it?

[16:13] *** leprevost left
[16:13] <Radvendii> for ones own classes

[16:13] <masak> sub postfix:<[ ]>($arg, :$delete) { ... }

[16:14] <jnthn> postcircumfix, that is

[16:14] <jnthn> Note that Rakudo doesn't parse operator adverbs yet.

[16:15] <Radvendii> but then how do i do it if i want to overload the {} method? # i've been overloading it by implimenting at_pos

[16:15] <Radvendii> and by at_pos i mean at_key

[16:17] <masak> er, right. postcircumfix

[16:17] <Radvendii> what?

[16:19] *** snearch joined
[16:20] <masak> sub postcircumfix:<[ ]>($arg, :$delete) { ... }

[16:20] <masak> actually, method, not sub :/

[16:21] <Radvendii> oh, right, but isn't it better practice to overload at_pos than postcircumfix:<[ ]>?

[16:25] <masak> in general, yes.

[16:25] <masak> but you asked how to declare the :delete adverb.

[16:26] <masak> it's the same kind of distinction as with "BUILD" and "new". if you want to do ordinary things, you're fine with using build. if you want to do fancy things like change the method signature, you use new.

[16:28] <Radvendii> but how do i not touch anything else? let's say i want to have it accept :delete, but not do anything else differently from normal [] (not even do anythnig with :delete)

[16:29] <Radvendii> do i have to re-write the whole method?

[16:31] <masak> yes.

[16:31] <masak> as things are currently factored, yes.

[16:31] <masak> this is a general problem in design.

[16:32] <masak> you have to factor things in *some* way, and anticipate the ways people want to break things apart and put them together again.

[16:32] <masak> but factorings are always tradeoffs, and you can't please everybody.

[16:33] <Radvendii> masak: i don't mean to keep bringing this up over and over again, but isn't that what SUPER is for in other languages?

[16:33] <tadzik> masak: https://gist.github.com/1699545

[16:34] <tadzik> #12 is to be fixed, of course

[16:35] <jnthn> dupa.pl :D

[16:35] <masak> Radvendii: :D

[16:36] <masak> Radvendii: inheritance is a fine tool, but it doesn't help the fact that any factoring of a class will favor some and dis-favor some.

[16:37] <masak> Radvendii: also, while it's not called SUPER in Perl 6, we have the same capabilities, and more. see http://perl6advent.wordpress.com/2010/12/14/day-14-nextsame-and-its-cousins/

[16:39] <Radvendii> yeah, i know, that's a whole 'nother beast. a wild one at that. and would that work? could i say method postcircumfix:<[ ]>(@args, :$delete) { nextwith(@args) } ?

[16:41] <Radvendii> nom: class A { method postcircumfix:<[ ]>(@args, :$delete) {nextwith(@args) }; my A $a .= new; $a[0] = 5

[16:41] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[16:41] *** fasad left
[16:41] <Radvendii> nom: class A { method postcircumfix:<[ ]>(@args, :$delete) {nextwith(@args) } }; my A $a .= new; $a[0] = 5; say $a[0];

[16:41] <p6eval> nom 9719f7: OUTPUT«Nominal type check failed for parameter '@args'; expected Positional but got Int instead␤  in method postcircumfix:<[ ]> at /tmp/p3t8t7m8zu:1␤  in block <anon> at /tmp/p3t8t7m8zu:1␤  in <anon> at /tmp/p3t8t7m8zu:1␤»

[16:41] <masak> sure, if you inherit from something that already has a postcircumfix:<{ }> method.

[16:46] <masak> er, postcircumfix:<[ ]>

[16:47] <masak> Radvendii: I should add that I don't believe many have done what you are now doing, so don't be too surprised if you stumble on a Big Fat Bug.

[17:03] <Radvendii> masak: haha, i've been coming across them all over the place, i'm used to it by now

[17:03] <Radvendii> like, for example, this 'given' changing variables business

[17:04] <Radvendii> isn't it just supposed to be the equivalent of "{$_ = $x; ...}" for "given $x {...}"?

[17:04] <Radvendii> but i assume that's not exactly what it does...

[17:07] *** pomysl left
[17:12] <eviltwin_b> perl has a longstanding thing of *binding* variables in blocks, not copying.  that is, $_ is an alias to $x there, not a copy of it

[17:13] <eviltwin_b> and therefore if $x is an lvalue, you can mutate it by assigning to $_

[17:13] *** icwiener left
[17:13] *** icwiener joined
[17:15] <eviltwin_b> (this is not new to perl6; for example, for/foreach has had binding (instead of copying) semantics going back to perl 3, at least)

[17:17] <Radvendii> eviltwin_b: right, i know that. the problem is that simply the fact of calling given $x {} is changing $x. here's a good illustration. as soon as i enter the block, $x !~~ $_

[17:17] *** birdwindupbird left
[17:17] <Radvendii> (evaluates to true)

[17:18] *** pomysl joined
[17:18] *** pomysl left
[17:18] *** pomysl joined
[17:20] *** icwiener left
[17:20] *** icwiener joined
[17:23] <masak> Radvendii: you're meant to run your good examples on p6eval, so that we can all see what goes wrong :)

[17:23] <masak> Radvendii: in this case, I think you're misunderstanding how infix:<~~> works.

[17:23] *** mucker left
[17:24] <masak> Radvendii: in particular, don't use smartmatching when number equality or string equality will do.

[17:24] <masak> if you're smartmatching against $_, it means you're confused.

[17:26] <Radvendii> masak: nono, i did try ~~ (which does work for number comparison) but i also just printed out the values of the variables, and they were different.

[17:26] *** samlh joined
[17:27] *** pomysl left
[17:27] <Radvendii> masak: the reason i'm not running it on p6eval is because it's integrated into my program and i'm having a hard time isolating the problem

[17:28] <Radvendii> and what operator should i use for equality testing if i dont know whether it's a number or a string...

[17:29] <masak> probably smartmatch.

[17:29] <masak> but not against $_ :)

[17:32] <Radvendii> why not?

[17:36] *** kaare__ joined
[17:37] *** snearch left
[17:37] <masak> because smartmatch already topicalizes on $_

[17:38] <masak> or am I confused? is that just for things like m// ?

[17:38] <moritz> no, smartmatching always topicalizes

[17:38] <moritz> so if you use $_ on the RHS of the smart match operator, it refers to the LHS

[17:38] <moritz> nom: 42 ~~ say($_)

[17:38] <p6eval> nom 9719f7: OUTPUT«42␤»

[17:39] <jnthn> That's a neat idiom. It looks like the 42 is swimming towards the say

[17:39] <jnthn> nom: 42 ~~ .say

[17:39] <tadzik> :P

[17:39] <p6eval> nom 9719f7: OUTPUT«42␤»

[17:39] <jnthn> Even better!

[17:43] <tadzik> masak: okay, so how do you find the new Usage?

[17:44] *** pomysl joined
[17:44] *** pomysl left
[17:44] *** pomysl joined
[17:45] <Radvendii> oh right! i remember that. then i must have used $_ as the LHS (e.g. $_ !~~ $i) but regardless, my problem still holds (i'm working on narrowing down the problem)

[17:46] <dalek> rakudo/usage-prints-WHY: c6024fe | tadzik++ | src/core/Main.pm:

[17:46] <dalek> rakudo/usage-prints-WHY: Make default USAGE print .WHY for the documented candidates

[17:46] <dalek> rakudo/usage-prints-WHY: review: https://github.com/rakudo/rakudo/commit/c6024fe435

[17:46] *** mj41 left
[17:47] <jnthn> tadzik: Seems like a nice idea

[17:51] <masak> Radvendii: smartmatch is not symmetric.

[17:52] <Radvendii> masak: i know... that's why i said "i must have used $_ as the LHS" because it evaluated to !~~ evaluated to True, and as we said <anything> !~~ $_ is False

[17:54] *** kaare_ joined
[17:54] *** kaare__ left
[17:56] <masak> Radvendii: it's a pity you can't use p6eval to better show me what you mean.

[17:56] <Radvendii> yeah

[17:56] <Radvendii> i'm working on it

[17:56] <masak> oh, good.

[17:57] *** samlh left
[17:57] *** cooper left
[17:59] *** samlh joined
[18:00] *** cooper joined
[18:02] *** Chillance joined
[18:04] <moritz> you can always point p6eval to gist URLs

[18:08] * colomon is wondering when sorear++ is going to wake up...

[18:12] <Radvendii> moritz: oh really?

[18:12] <Radvendii> i feel like my whole program wouldn't help very much, it's not *that* much but still...

[18:21] <Radvendii> i feel like my whole program wouldn't help very much, it's not *that* much but still...

[18:21] <Radvendii> aaaagh

[18:21] <Radvendii> sorry 'bout htat

[18:22] <Radvendii> nom: say ("a" but 5).perl #not very good for debugging purposes...

[18:22] <p6eval> nom 9719f7: OUTPUT«"a"␤»

[18:22] <Radvendii> it's hard to tell if there's something sneaky going on

[18:28] <masak> then don't use .perl

[18:28] <masak> nom: say ("a" but 5).WHAT

[18:28] <p6eval> nom 9719f7: OUTPUT«Str+{<anon>}()␤»

[18:29] *** Trashlord left
[18:32] <Radvendii> o-o-oh

[18:33] <Radvendii> thanks :D

[18:34] <masak> Radvendii: it seems your data is very confused. you're actually getting things in some context, and you don't know whether they're strings or numbers, and you don't know (but need to know) whether they've been overloaded with 'but'?

[18:34] <masak> something tells me you're using power tools where precision tools would do you more good.

[18:35] <Radvendii> nono, they're strings. i just wanted to be *sure* because i'm still getting a feel for the language

[18:37] <masak> ah.

[18:40] <masak> blog post! \o/ http://strangelyconsistent.org/blog/macros-progress-report-interesting-things

[18:45] *** cognominal_ joined
[18:47] *** cognominal left
[18:51] *** Trashlord joined
[18:56] <bbkr1> Is it possible to provide decimal char range in regexp? for example I can write in hex <[\x20]>, but <[\d32]> is interpreted as digit,3,2.

[18:59] <Radvendii> are there any multi-line comments in p6?

[18:59] <masak> bbkr1: \c20

[19:00] <masak> Radvendii: #`[ ...] or Pod.

[19:00] <Radvendii> ooooooh

[19:00] <Radvendii> what's Pod?

[19:01] <bbkr1> masak++

[19:02] <Radvendii> what if i have a [] in the part that i am commenting?

[19:03] *** Trashlord left
[19:03] <moritz> nom: #`( foo ) say 42

[19:03] <p6eval> nom 9719f7: OUTPUT«42␤»

[19:04] <Radvendii> nom: #`( (foo) say "uh-oh"; ) say 42

[19:05] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Confused at line 1, near ") say 42"␤»

[19:05] <Radvendii> that's to be expected

[19:05] <Radvendii> but it's not a very effective multi-line comment if a very common programming symbol trips it up

[19:05] <Radvendii> unless...

[19:05] <jnthn> nom: #`[ (foo) say "uh-oh"; ] say 42

[19:05] <p6eval> nom 9719f7: OUTPUT«42␤»

[19:05] <Radvendii> ah

[19:05] <Radvendii> i was just about to test that

[19:05] <jnthn> std: #`( (foo) say "uh-oh"; ) say 42

[19:06] <p6eval> std 48335fc: OUTPUT«ok 00:01 108m␤»

[19:06] <Radvendii> nom: #`# (foo) say "uh-oh"; # say 42

[19:06] <p6eval> nom 9719f7: OUTPUT«42␤»

[19:06] *** rindolf joined
[19:06] <rindolf> Hi all.

[19:06] <jnthn> Radvendii: There's a known nom-issue in quoting where it doesn't count nested pairs in places it should.

[19:06] <Radvendii> rindolf: o/

[19:06] <jnthn> o/ rindolf 

[19:06] * jnthn goes to sort out some food

[19:06] <Radvendii> jnthn: ah...

[19:07] <offby1> blueberries in the left, bread in the middle, cream on the right.

[19:07] <offby1> sorted!

[19:07] <rindolf> Radvendii: what's up?

[19:10] <felher> masak++ # again, this time for macro-hacking and bloging :)

[19:13] *** Trashlord joined
[19:16] <masak> ;)

[19:16] <moritz> phenny: ask [Coke] which nom revisioin he for his t1 solution

[19:16] <phenny> moritz: I'll pass that on when [Coke] is around.

[19:17] <Radvendii> OH

[19:17] <Radvendii> phenny is a bot!

[19:18] <moritz> aye, she is

[19:18] <Radvendii> :P i'm the *sharpest* knife in the drawr

[19:18] <Radvendii> drawer*

[19:19] <Radvendii> rindolf: trying to figure out what is causing my bug

[19:19] <rindolf> Radvendii: OK, which bug?

[19:20] <Radvendii> rindolf: for some reason just declaring given $i {} is changing the *value* of $i...

[19:21] <rindolf> Radvendii: ah, I see.

[19:21] <Radvendii> rindolf: but what's really odd, is that $_ get's set to what $i _used_ to be

[19:21] <rindolf> Radvendii: OK.

[19:22] <rindolf> Radvendii: does a debugger for NQP code exist?

[19:22] <offby1> Radvendii: "drawr.com"!  My new domain name!  Thanks!

[19:23] <Radvendii> offby1: haha, no problem. i'm surprised it's not already taken...

[19:23] <masak> offby1: with a main menu item "not the sharpest knife"... :)

[19:23] <offby1> Radvendii: it is :-|

[19:24] <Radvendii> aww...

[19:24] <offby1> I suspect all of the following are already claimed: English words that are nouns, derived from a transitive verb, by adding "-er", but then eliding the hyphen and the "e"

[19:24] <moritz> perl6: say 'foo'.length

[19:24] <p6eval> pugs b927740: OUTPUT«*** No such method in class Str: "&length"␤    at /tmp/r6CedB25lf line 1, column 5 - line 2, column 1␤»

[19:24] <p6eval> ..niecza v13-381-g4158fa9: OUTPUT«Unhandled exception: Unable to resolve method length in class Str␤  at /tmp/egHSeK1pJE line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3609 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3610 (module-CORE @ 62) ␤  at /hom…

[19:24] <p6eval> ..rakudo 9719f7: OUTPUT«Method 'length' not found for invocant of class 'Str'␤  in block <anon> at /tmp/7gN3WsaSPE:1␤  in <anon> at /tmp/7gN3WsaSPE:1␤»

[19:25] <Radvendii> moritz: (.chars)

[19:25] <moritz> Radvendii: I know, I know

[19:25] <Radvendii> oh

[19:25] <Radvendii> okay

[19:25] <moritz> Radvendii: I was just checking a fact for a p6cc submission

[19:26] <Radvendii> offby1: yeah probably, everyone's grasping for domain names nowadays

[19:26] <Radvendii> moritz: Okay

[19:26] *** birdwindupbird joined
[19:27] *** bbkr1 left
[19:34] *** samlh left
[19:34] *** birdwindupbird left
[19:37] <sorear> good * #perl6

[19:37] <phenny> sorear: 13:53Z <colomon> tell sorear The last test of S05-grammar/protoregex.t has gone from needing a todo to needing a skip.    I know this is what you were working on last night, so I thought I'd bring it to your attention before refudging.

[19:38] *** jferrero left
[19:41] *** GlitchMr42 left
[19:44] <colomon> sorear: I discovered this morning that @*INC in niecza doesn't actually do anything

[19:45] <Radvendii> YAY

[19:45] <Radvendii> masak: i distilled the error down

[19:45] <Radvendii> nom: sub foo ($a, $f) { if $f { foo('z', 0) }; given $a {say $a; say $_} }; foo('x', 1)

[19:45] <p6eval> nom 9719f7: OUTPUT«z␤z␤z␤x␤»

[19:46] <masak> Radvendii++

[19:46] <masak> that is the real deal.

[19:46] * masak submits rakudobug

[19:47] *** birdwindupbird joined
[19:47] <Radvendii> masak: yay :D

[19:47] <moritz> perl6: sub foo ($a, $f) { if $f { foo('z', 0) }; given $a {say $a; say $_} }; foo('x', 1)

[19:47] <p6eval> rakudo 9719f7: OUTPUT«z␤z␤z␤x␤»

[19:47] <p6eval> ..pugs b927740, niecza v13-381-g4158fa9: OUTPUT«z␤z␤x␤x␤»

[19:49] * masak is surprised we still have this kind of lexpad bug

[19:49] * Radvendii assumes lexpad has to do with lexical scopes?

[19:50] <moritz> yes

[19:50] <Radvendii> cool

[19:50] *** jferrero joined
[19:52] <masak> Radvendii: if I had to guess, what you're seeing is the given block anchoring to the lexpad of the first invocation, and then when the lookup for $a is done in the second invocation, it finds the wrong -- the old -- OUTER for the given block.

[19:53] <masak> at least that's a hypothesis consistent with the data.

[20:00] <fsergot> good night! o/

[20:00] *** fsergot left
[20:01] <masak> Radvendii: https://rt.perl.org/rt3/Ticket/Display.html?id=109322

[20:10] <jnthn> Yes, it's another upshot of the FAIL of doing lexical capture at block entry.

[20:10] <jnthn> At first glance.

[20:11] <masak> but "doing lexical capture at block entry" sounds like it should work in this case. but it doesn't.

[20:11] <Radvendii> slightly unrelated but: why do we even use "given" wouldn't "for" do the same thing on a scalar?

[20:13] <masak> it would.

[20:13] <masak> but not on a list.

[20:14] <masak> also, 'for' has loop semantics; 'given' doesn't.

[20:16] <Radvendii> oh, that makes sense

[20:16] <[Coke]> phenny: tell moritz t1 should run on This is perl6 version 2012.01-2-g3ddd2fb built on parrot 3.11.0 revision RELEASE_3_11_0

[20:16] <phenny> [Coke]: I'll pass that on when moritz is around.

[20:16] <phenny> [Coke]: 19:16Z <moritz> ask [Coke] which nom revisioin he for his t1 solution

[20:16] <colomon> also sometimes it's important to say what you mean.  :)

[20:17] <moritz> [Coke]: thanks

[20:17] <phenny> moritz: 20:16Z <[Coke]> tell moritz t1 should run on This is perl6 version 2012.01-2-g3ddd2fb built on parrot 3.11.0 revision RELEASE_3_11_0

[20:18] <Radvendii> colomon: right...

[20:19] <[Coke]> moritz: hopefully it works. It's the only I'll get around to submitting ;)

[20:20] <[Coke]> for your sake I hope I'm disqualified from winning. ;)

[20:20] <[Coke]> also, it's kind of lame. I feel like I wrote you some Java. :(

[20:20] <moritz> [Coke]: my first run gave some errors, but I'm unable to reproduce it. Now it seems to work fine, albeit slow

[20:20] <Radvendii> nom: sub foo ($a, $f) { if $f { foo('z', 0) }; {$_:=$a; say $a; say $_} }; foo('x', 1) #does it work explicitly?

[20:20] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Cannot use bind operator with this left-hand side␤at /tmp/xS1arfAU_K:1␤»

[20:21] <Radvendii> aw, c'mon

[20:21] <[Coke]> moritz: well, on the plus side, it'll run that slow no matter what number you pass to it!

[20:21] <Radvendii> nom: sub foo ($a, $f) { if $f { foo('z', 0) }; {$_=$a; say $a; say $_} }; foo('x', 1) #does it work explicitly?

[20:22] <p6eval> nom 9719f7: OUTPUT«z␤z␤z␤z␤»

[20:22] <Radvendii> ooh. that's even worse...

[20:22] <moritz> [Coke]: all solution have that in common

[20:23] <masak> Radvendii: but it has exactly the same cause.

[20:23] <Radvendii> masak: yup... i just realized that

[20:24] <Radvendii> i thought it maybe had to do with the "given" statement itself

[20:24] <masak> me too.

[20:25] <masak> no, it's just blocks inside reentrant blocks.

[20:25] * masak updates ticket

[20:25] *** icwiener left
[20:25] *** icwiener joined
[20:33] *** shinobicl_ left
[20:45] *** shinobicl_ joined
[20:53] *** spine joined
[21:03] *** birdwindupbird left
[21:18] <spine> oh crap, I missed the p6cc deadline...

[21:19] <spine> well was fun anyways :)

[21:21] <moritz> spine: I kinda think it's still open until midnight UTC

[21:21] <moritz> masak: is that right?

[21:22] <shinobicl_> rakudo: class D2 is Date { }; my D2 $d2 = D2.new("2011-01-02"); say $d2.perl; say $d2.WHAT;

[21:22] <p6eval> rakudo 9719f7: OUTPUT«Date.new(2011, 1, 2)␤D2()␤»

[21:23] <shinobicl_> why the 1st say reports "Date"? shouldn't that be "D2.new"?

[21:23] <spine> moritz: well, strangelyconsistent.org made it seem like it's over :)

[21:23] *** rindolf left
[21:24] <Radvendii> shinobicl_: maybe p6 is smart enough to know that it can generalize to a Date object?

[21:24] <Radvendii> hmm... that shouldn't be it though

[21:26] <moritz> no, the .perl method simply doesn't take inheritance into account

[21:26] * moritz -> sleep

[21:26] *** y3llow_ joined
[21:26] *** pothos_ joined
[21:26] <moritz> one might argue that you have to write your own .perl if you subclass a value type

[21:26] <moritz> some for

[21:27] *** pothos left
[21:27] <moritz> nom: class A is Str { }; say A.new.perl

[21:27] <p6eval> nom 9719f7: OUTPUT«""␤»

[21:27] * moritz -> really sleep

[21:28] <Radvendii> nom: $_ = 5; say <w b>.grep: -> $x {$_})

[21:28] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Confused at line 1, near ")"␤»

[21:28] <Radvendii> nom: $_ = 5; say <w b>.grep: -> $x {$_}

[21:28] <p6eval> nom 9719f7: OUTPUT«w b␤»

[21:28] <Radvendii> hahaha

[21:28] <Radvendii> it puts it in $x and $_?

[21:28] *** y3llow left
[21:29] *** y3llow_ left
[21:29] <Radvendii> nom: $_ = 5; say <a b c d e f>.grep: -> $x, $y {$_}

[21:29] <p6eval> nom 9719f7: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in block <anon> at /tmp/wpi18hPfn3:1␤  in method ACCEPTS at src/gen/CORE.setting:1333␤  in method reify at src/gen/CORE.setting:4474␤  in method reify at src/gen/CORE.setting:4379␤  in method reify at src…

[21:29] *** y3llow joined
[21:29] *** pothos_ left
[21:30] *** pothos joined
[21:30] <Radvendii> nom: $_ = 5; say <a b c d e f>.map: -> $x, $y {$_}

[21:30] <p6eval> nom 9719f7: OUTPUT«5 5 5␤»

[21:30] <Radvendii> nom: $_ = 5; say <a b c d e f>.map: -> $x {$_}

[21:30] <p6eval> nom 9719f7: OUTPUT«5 5 5 5 5 5␤»

[21:30] *** kaare_ left
[21:31] <Radvendii> nom: $_ = 5; eager <a b>.grep: -> $x {.say}

[21:31] <p6eval> nom 9719f7: OUTPUT«5␤5␤»

[21:31] *** y3llow left
[21:31] <Radvendii> there we go

[21:31] <Radvendii> good

[21:31] <Radvendii> it doesn't overwrite $_

[21:32] *** y3llow joined
[21:33] *** pothos left
[21:33] *** pothos joined
[21:33] *** y3llow left
[21:34] *** y3llow joined
[21:36] *** y3llow left
[21:36] *** y3llow joined
[21:39] <masak> no, it's only for re-entrant scopes.

[21:39] <masak> like a sub calling itself.

[21:45] *** hundskatt joined
[21:48] <Radvendii> i know, i was just wondering if .map made $_ refer to the arguments it passes _even_ if i specify parameters

[21:48] <Radvendii> apparently not

[21:48] <Radvendii> which is good

[21:50] <Radvendii> nom: my $a = 5; $_=$a; when Int { say "this works" } #possible temprorary replacement for given?

[21:50] <p6eval> nom 9719f7: OUTPUT«this works␤»

[21:51] <Radvendii> nom: sub foo ($a, $f) { if $f { foo('z', 0) }; $_=$a; say $a; say $_ }; foo('x', 1) #does it work explicitly?

[21:51] <p6eval> nom 9719f7: OUTPUT«z␤z␤x␤x␤»

[21:51] <Radvendii> okay

[21:51] <Radvendii> that'll work for now

[21:51] <masak> Radvendii++ # workaround

[21:52] <masak> 'night, #perl6

[21:52] <Radvendii> o/ masak

[21:53] *** icwiener left
[22:17] <Radvendii> nom: say True || False && False

[22:17] <p6eval> nom 9719f7: OUTPUT«Bool::True␤»

[22:17] <Radvendii> ## && binds tighter than ||

[22:18] *** cooper left
[22:19] *** Tenzen joined
[22:19] <Radvendii> what is the conventional style/indentation format for writing complex logic...

[22:19] *** cooper joined
[22:19] <Radvendii> like <expression> || (<exp2> && (<exp3 || <exp4>))

[22:27] <sorear> typically, you avoid writing logic expressions more than a few lines

[22:32] <Radvendii> dang

[22:34] <sorear> phenny: tell colomon Do what you will with protoregex.t; it's not actually testing what it says it is, because of different anchoring rules

[22:34] <phenny> sorear: I'll pass that on when colomon is around.

[22:51] <Radvendii> nom: my $x=0; while($x<2) repeat { say $x++}

[22:51] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Confused at line 1, near "while($x<2"␤»

[22:51] <Radvendii> nom: my $x=0; while $x<2 repeat { say $x++}

[22:51] <p6eval> nom 9719f7: OUTPUT«===SORRY!===␤Missing block at line 1, near "repeat { s"␤»

[22:52] <Radvendii> nom: my $x=0; repeat { say $x++} while $x<2

[22:52] <p6eval> nom 9719f7: OUTPUT«0␤1␤»

[22:53] *** bkolera left
[22:55] * sorear starts trying to do setting summarization

[22:55] <sorear> s/setting/changelog/

[23:00] *** cognominal_ left
[23:01] *** cognominal joined
[23:03] <Radvendii> expected Array+{MyQs} but got Array+{MyQs} instead

[23:03] <Radvendii> :P

[23:03] <Radvendii> umm... say what?

[23:11] *** PacoAir left
[23:12] <sorear> sounds like you have two classes with the same name

[23:12] <sorear> a common danger of creating classes at runtime...

[23:15] <colomon> sorear: roger, roger

[23:15] <phenny> colomon: 22:34Z <sorear> tell colomon Do what you will with protoregex.t; it's not actually testing what it says it is, because of different anchoring rules

[23:18] <Radvendii> sorear: but i'm not... oh, are you refering to the "but MyQs" syntax?

[23:21] <dalek> roast: 8e86311 | (Solomon Foster)++ | S05-grammar/protoregex.t:

[23:21] <dalek> roast: Refudge for latest niecza.

[23:21] <dalek> roast: review: https://github.com/perl6/roast/commit/8e86311dce

[23:22] * jnthn -> sleep, long day coming up tomorrow...

[23:34] *** ggoebel left
[23:37] <sorear> Radvendii: ye

[23:38] <felher> masak: thnx for your https://gist.github.com/1548053 . Was nice to read :)

[23:38] * felher off

[23:39] *** ggoebel joined
[23:46] <dalek> niecza: 989c185 | sorear++ | docs/announce.v14:

[23:46] <dalek> niecza: First half of changelog summarization

[23:46] <dalek> niecza: review: https://github.com/sorear/niecza/commit/989c185cc2

[23:52] <dalek> roast: 9c25355 | (Solomon Foster)++ | S02-magicals/env.t:

[23:52] <dalek> roast: Refudge for latest niecza.

[23:52] <dalek> roast: review: https://github.com/perl6/roast/commit/9c25355891

[23:52] *** spine left
[23:58] *** Yary joined
