[00:01] *** lue joined
[00:01] <lue> hello world o/

[00:04] <sorear> lue!

[00:04] <lue> hi sorear o/

[00:15] *** fridim_ left
[00:25] *** adu joined
[00:31] *** benthumb joined
[00:32] *** thilp joined
[00:32] *** benthumb left
[00:33] *** fgomez left
[00:38] *** _jaldhar joined
[00:43] *** thilp left
[00:52] *** sjohnson joined
[00:52] *** sjohnson left
[00:52] *** sjohnson joined
[00:57] <dalek> nqp/toqast: 407a1cf | pmichaud++ | src/HLL/Compiler.pm:

[00:57] <dalek> nqp/toqast: Update stagestats to use a bitmask instead of levels.

[00:57] <dalek> nqp/toqast:    0x02 = display memory and pmc allocation

[00:57] <dalek> nqp/toqast:    0x04 = force gc sweep before displaying stats

[00:57] <dalek> nqp/toqast:    0x08 = pause between stages

[00:57] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/407a1cf7a9

[01:00] *** _jaldhar left
[01:01] *** Slacky left
[01:14] <pmichaud> arggh, pushed to the wrong branch.

[01:14] <pmichaud> I'll cherry-pick it into master.

[01:16] <dalek> nqp: a4165a9 | pmichaud++ | src/HLL/Compiler.pm:

[01:16] <dalek> nqp: Update stagestats to use a bitmask instead of levels.

[01:16] <dalek> nqp:    0x02 = display memory and pmc allocation

[01:16] <dalek> nqp:    0x04 = force gc sweep before displaying stats

[01:16] <dalek> nqp:    0x08 = pause between stages

[01:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a4165a9eb6

[01:31] *** thelazydeveloper left
[01:32] *** fgomez joined
[01:43] *** PacoAir left
[01:46] *** adu left
[02:04] *** Lard joined
[02:09] <Lard> Hi guys, Is there something similar to moose type coercions in perl6?

[02:10] <Lard> I can't find any docs on it...

[02:11] <Lard> "is also" is mentioned here https://gist.github.com/247656 but I can't see that documented anywhere

[02:16] *** _jaldhar joined
[02:17] <sorear> Lard: no.

[02:18] <sorear> the closest we have are coerced types, like has Int() $.foo

[02:18] <sorear> you can initialize $.foo with any value, and the .Int method will be called

[02:18] <sorear> but you can't do custom coercers like Moose :(

[02:18] <sorear> also I'm not sure that anyone implements coerced types yet.

[02:19] <sorear> what you can do *today* is write a custom BUILD method which initializes the attributes

[02:19] <Lard> sorear: ah ok thanks... I'll see if it that works now...

[02:19] <sorear> submethod BUILD(:$foo) { $!foo = $foo.Int }

[02:19] <Lard> really I couldn't get BUILD to work....

[02:20] <Lard> I do submethod BUILD ( :$foo ) {$!bar = $foo;}

[02:21] <Lard> having declared bar earlier and it wasn't working for me...

[02:22] <Lard> It's sad that something like type coercions isn't in perl6...I loved that part of moose

[02:24] <sorear> it's sad that perl 6 hasn't bothered to learn from the changes Moose made after being forked

[02:24] <sorear> perl 6 doesn't even have _required attributes_

[02:25] <Lard> yeah I saw the = die "blah" but I prefer the declarative moose style

[02:25] <sorear> eh.  I shouldn't dump all my complaints on the new person.

[02:26] <Lard> haha

[02:29] <sorear> weclome!

[02:29] <Lard> thanks :)

[02:30] *** tokuhiro_ joined
[02:33] <pmichaud> https://gist.github.com/3063969  # does this work as a Foo($value) coercer?  

[02:34] <pmichaud> then we could have   my Foo() $x;   such that any value assigned to $x passes through Foo(...)  first

[02:35] <pmichaud> although I guess the resulting value would need to be blessed into Foo to satisfy the type constraint.

[02:36] <sorear> let's add to Mu/Any multi postcircumfix:<( )>($x) { $x."{self.^name}"() }

[02:36] <sorear> now you can implement either Type() or .Type, with Type() multis taking precedence

[02:37] <sorear> although we don't currently have a good way to define a ."Foo::Bar" method in Perl 6

[02:37] <pmichaud> I'm guessing you really want  multi postcircumfix:<( )>(Mu:U: $x)  there, though.

[02:38] <pmichaud> otherwise we're defining postcircumfix on... well, everything :-)

[02:43] <sorear> hrm.

[02:43] <sorear> http://irclog.perlgeek.de/perl6/2010-07-16#i_2559776

[02:44] <sorear> I recollected this as being much more of unilateral shoot-down than it actually was

[02:46] *** xinming_ joined
[02:48] *** xinming left
[03:12] *** bruges joined
[03:13] *** Lard left
[03:15] *** Entonian joined
[03:15] *** Entonian left
[03:39] *** quietfanatic joined
[03:40] <quietfanatic> Hm, is there a way to do a (function-style) pattern match on an object with attributes?

[03:40] <quietfanatic> I know you can do it with an array.

[03:41] <quietfanatic> perl6: sub sayattrs ([*%attrs]) { say %attrs.perl }; class Vec { has $.x; has $.y; }; sayattrs(Vec.new(x => 1, y => 2))

[03:41] <p6eval> niecza v19-12-gf36d743: OUTPUT¬´Unhandled exception: Nominal type check failed in binding '' in 'sayattrs'; got Vec, needed Positional‚ê§  at /tmp/L__dOahayc line 0 (sayattrs @ 1) ‚ê§  at /tmp/L__dOahayc line 1 (mainline @ 7) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3918 (ANON @ 3) ‚ê§ ‚Ä¶

[03:41] <p6eval> ..rakudo 57eaaa: OUTPUT¬´Nominal type check failed for parameter ''; expected Positional but got Vec instead‚ê§  in sub sayattrs at /tmp/MZ8UbWdvP6:1‚ê§  in block <anon> at /tmp/MZ8UbWdvP6:1‚ê§‚ê§¬ª

[03:41] <quietfanatic> perl6: sub sayattrs ({*%attrs}) { say %attrs.perl }; class Vec { has $.x; has $.y; }; sayattrs(Vec.new(x => 1, y => 2))

[03:41] <p6eval> niecza v19-12-gf36d743: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse signature at /tmp/HiNGWvDQHD line 1:‚ê§------> [32msub sayattrs ([33m‚èè[31m{*%attrs}) { say %attrs.perl }; class Ve[0m‚ê§Couldn't find final ')'; gave up at /tmp/HiNGWvDQHD line 1:‚ê§------> [32msub sayattrs (‚Ä¶

[03:41] <p6eval> ..rakudo 57eaaa: OUTPUT¬´===SORRY!===‚ê§Missing block‚ê§at /tmp/i4BtaLswMt:1‚ê§¬ª

[03:43] *** Lard joined
[03:43] <sorear> r: sub sayattrs($ (*%attrs)) { say %attrs.perl }; class Vec { has $.x; has $.y; }; sayattrs(Vec.new(x => 1, y => 2))

[03:43] <p6eval> rakudo 57eaaa: OUTPUT¬´("x" => 1, "y" => 2).hash‚ê§¬ª

[03:43] <sorear> quietfanatic.

[03:44] <quietfanatic> oh

[03:44] <quietfanatic> sweet

[03:44] <quietfanatic> though the syntax is a little odd methinks

[03:50] <quietfanatic> Oh, but I can't use that to do coercions, because methods on SomeType:U appear to be impossible

[03:50] <quietfanatic> rats

[03:52] <quietfanatic> Oh never mind, I was spelling postcircumfix 'infix'.  Doh

[03:53] <quietfanatic> Except it still doesn't work.

[03:53] <quietfanatic> class A { method postcircumfix:<( )> (A:U:) { say 3 } }; A()

[03:53] <quietfanatic> rn: class A { method postcircumfix:<( )> (A:U:) { say 3 } }; A()

[03:53] <p6eval> rakudo 57eaaa: OUTPUT¬´Too many positional parameters passed; got 2 but expected 1‚ê§  in method postcircumfix:<( )> at /tmp/bxmz9cNgsh:1‚ê§  in <anon> at src/gen/BOOTSTRAP.pm:811‚ê§  in any <anon> at src/gen/BOOTSTRAP.pm:807‚ê§  in block <anon> at /tmp/bxmz9cNgsh:1‚ê§‚ê§¬ª

[03:53] <p6eval> ..niecza v19-12-gf36d743: OUTPUT¬´3‚ê§¬ª

[03:54] <quietfanatic> niecza++

[03:54] <pmichaud> r: class XYZ { method postcircumfix:<( )>(XYZ:U: $x) { say 3 } };  XYZ(0)   # checking

[03:54] <p6eval> rakudo 57eaaa: OUTPUT¬´3‚ê§¬ª

[03:54] <pmichaud> r: class XYZ { method postcircumfix:<( )>(XYZ:U: $x) { say 3 } };  XYZ()   # checking

[03:54] <p6eval> rakudo 57eaaa: OUTPUT¬´3‚ê§¬ª

[03:54] <pmichaud> hmmmm

[03:55] <pmichaud> r: class XYZ { method postcircumfix:<( )>(XYZ:U: $x) { say 3 } };  XYZ(3,4,5)   # checking

[03:55] <p6eval> rakudo 57eaaa: OUTPUT¬´3‚ê§¬ª

[03:55] <pmichaud> I bet Rakudo is always expecting a Capture of the arguments there.

[03:55] <quietfanatic> huh

[03:55] <pmichaud> r: class XYZ { method postcircumfix:<( )>(XYZ:U: $x) { say $x.WHAT } };  XYZ(3,4,5)   # checking

[03:55] <p6eval> rakudo 57eaaa: OUTPUT¬´Capture()‚ê§¬ª

[03:55] <pmichaud> *ding*

[03:56] <quietfanatic> Where does that capture come from?

[03:56] <pmichaud> it's the capture formed by the arglist to the .( ) call

[03:57] *** thou left
[03:57] <quietfanatic> oh, so

[03:57] <quietfanatic> r: class XYZ { method postcircumfix:<( )>(XYZ:U: $x) { say $x[1] } };  XYZ(3,4,5)   # checking

[03:57] <pmichaud> I'm not sure it's _correct_; that just appears to be what Rakudo is doing.

[03:57] <p6eval> rakudo 57eaaa: OUTPUT¬´4‚ê§¬ª

[03:57] <quietfanatic> er

[03:58] <quietfanatic> r: class XYZ { method postcircumfix:<( )>(XYZ:U: $x) { say $x } };  XYZ(3,4,5)

[03:58] <p6eval> rakudo 57eaaa: OUTPUT¬´3 4 5‚ê§¬ª

[03:58] <quietfanatic> yeah I'm pretty sure that's wrong.

[03:58] <quietfanatic> where's masakbot?

[03:59] <sorear> quietfanatic: 3,4,5 are being wrapped into a capture.

[03:59] <quietfanatic> Yes, but the signature should unwrap the capture.

[04:00] <pmichaud> there may be some circularity sawing taking place there... probably need to check with jnthn++, too.

[04:17] *** fgomez left
[04:18] *** fgomez joined
[04:20] <dalek> nqp: b9d44ce | pmichaud++ | src/QRegex/ (3 files):

[04:20] <dalek> nqp: [qregex]  Initial implementation of <( and )> tokens.

[04:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b9d44ce7b3

[04:20] <dalek> nqp: 66edbf6 | pmichaud++ | t/qregex/01-qregex.t:

[04:20] <dalek> nqp: Add some got/expected output to t/qregex/01-qregex.t .

[04:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/66edbf6a36

[04:20] <dalek> nqp: b07bc9e | pmichaud++ | t/qregex/rx_metachars:

[04:20] <dalek> nqp: [qregex]: Add some tests for <( and )> .

[04:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b07bc9e530

[04:26] *** tyatpi left
[04:31] <moritz> \o

[04:31] <pmichaud> o/

[04:31] <sorear> |o|

[04:31] <pmichaud> eek!  a TIE fighter!

[04:34] <dalek> rakudo/nom: a569e39 | pmichaud++ | / (4 files):

[04:34] <dalek> rakudo/nom: Update <( and )> in regexes to use code inherited from NQP.

[04:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a569e39fa9

[04:34] <dalek> roast: baf17a4 | pmichaud++ | S05-metasyntax/angle-brackets.t:

[04:34] <dalek> roast: Add some more <( and )> tests.

[04:34] <dalek> roast: review: https://github.com/perl6/roast/commit/baf17a461a

[05:00] *** bluescreen10 left
[05:01] *** thou joined
[05:04] *** tyatpi joined
[05:19] *** libertyprime joined
[05:23] *** tyatpi left
[05:44] *** kaare_ joined
[05:52] *** tyatpi joined
[06:04] *** tokuhiro_ left
[06:21] *** thou left
[06:32] *** mucker joined
[06:36] *** sisar left
[06:37] *** sisar joined
[06:37] *** nebuchadnezzar joined
[06:46] *** quietfanatic left
[06:48] <tadzik> hoelzro|away: yeah, please don't worry about licesing when it comes to my modules :)

[06:49] <tadzik> I missed some action due to being suddenly asleep

[06:53] <sorear> o/ tadzik

[06:56] <tadzik> sorear: o/

[07:02] <moritz> \o

[07:47] *** Lard left
[07:47] *** sergot joined
[07:47] <sergot> hello o/

[07:47] <sergot> !

[07:59] <sorear> helo sergot

[08:00] *** tokuhiro_ joined
[08:08] *** GlitchMr joined
[08:15] *** sorear joined
[08:27] *** szabgab joined
[08:28] <szabgab> r: say "hi"

[08:28] <p6eval> rakudo a569e3: OUTPUT¬´hi‚ê§¬ª

[08:28] <szabgab> r: for 1 .. 3 { say $_ }

[08:28] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[08:28] <szabgab> r: for 1 .. 3 { say  }

[08:28] <p6eval> rakudo a569e3: OUTPUT¬´‚ê§‚ê§‚ê§¬ª

[08:28] <szabgab> r: for 1 .. 3 { print }

[08:28] <p6eval> rakudo a569e3:  ( no output )

[08:29] <szabgab> the last one prints me 3 times True in the REPL while the say version just 3 empty rows

[08:30] <szabgab> If anyone could explain that to me  ...

[08:30] <pmichaud> the repl only does the 'p' if the executed code doesn't produce any output

[08:30] <pmichaud> so, since    for 1..3 { say }   generates output, the repl doesn't do any additional printing.

[08:31] <pmichaud> for 1..3 { print }  doesn't print anything (it prints 3 null strings), so the repl prints the result of the for loop

[08:31] <pmichaud> which is (True, True, True)

[08:31] <pmichaud> r:  say (for 1..3 { print }).perl

[08:31] <p6eval> rakudo a569e3: OUTPUT¬´(Bool::True, Bool::True, Bool::True).list‚ê§¬ª

[08:32] <pmichaud> you can also see the difference if you do     say ""    and    print ""   from the repl

[08:32] <pmichaud> the first will display a blank line; the second will display "True"  (which is the result of the print)

[08:32] <szabgab> ok for that, and why neiher of them print the content of $_ ?

[08:32] <pmichaud> there are no more default arguments in Perl 6.

[08:33] *** mucker left
[08:33] <pmichaud> if you want to print $_, you have to do    print $_    or $_.print   or .print

[08:33] <szabgab> but there is for the for loop

[08:33] <szabgab> default iterator

[08:33] <szabgab> or what is the name of the variable there?

[08:33] <pmichaud> yes, $_ is set in the block, but a bare "say" doesn't default to displaying $_

[08:34] <pmichaud> std:  for 1..3 { say }    # I think STD flags it as an error

[08:34] <p6eval> std fd2647b: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/BRcBVzOyPz line 1:‚ê§------> [32mfor 1..3 { say[33m‚èè[31m }    # I think STD flags it as an error[0m‚ê§Check failed‚Ä¶

[08:34] <pmichaud> we used to flag it as an error in Rakudo... apparently that got dropped somewhere.

[08:34] <szabgab> nice

[08:34] *** thelazydeveloper joined
[08:34] <szabgab> probably it would be better to flag that too

[08:34] <pmichaud> agreed; it's not always super-easy to do that :)

[08:34] <szabgab> and what is the name of the variables in the for loop ?

[08:35] <pmichaud> the for loop just passes the iterated values to the block -- the block gets to decide what to call the variable.

[08:35] <pmichaud> r:  for 1..3 { say $^x }

[08:35] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[08:35] <pmichaud> r:  for 1..3 -> $n { say $n }

[08:35] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[08:35] <szabgab> I mean I used to call them "iterator" 

[08:35] <szabgab> in perl 5 

[08:35] <szabgab> to describe them

[08:35] <szabgab> in general

[08:35] <pmichaud> I don't think that works in p6, though.

[08:36] <pmichaud> because they belong to the block, not the for loop.

[08:36] <pmichaud> r:  (1..3).map( -> $n { say $n }).eager

[08:36] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[08:36] <szabgab> so I was  looking for a generic term for the variable that is  on the right hand side of ->

[08:37] <pmichaud> it's a parameter

[08:37] <szabgab> ok,  that will do :)

[08:37] <pmichaud> just like if we do     sub anon ($x, $y) { ... }      

[08:37] <szabgab> then another question , there used to be an idea   to  write    for 1..10 by(2)  { }

[08:37] <pmichaud> we can also do    -> $x, $y { ... }

[08:37] *** brrt joined
[08:37] *** brrt left
[08:38] <szabgab> but I don't think it is there any more, not even in the spec

[08:38] *** brrt joined
[08:38] <pmichaud> correct, it's gone.  We now use the sequences operator.

[08:38] <szabgab> so can I loop every 2nd value?

[08:38] <pmichaud> say   1,3,5 ...^ *>= 10

[08:38] <szabgab> r: for 1,3...10 { say $_ }

[08:38] <pmichaud> r: say   1,3,5 ...^ *>= 10~

[08:38] <p6eval> rakudo a569e3: OUTPUT¬´(timeout)¬ª

[08:38] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/8DXq5AQqdk:1‚ê§¬ª

[08:38] <pmichaud> r: say   1,3,5 ...^ *>= 10

[08:38] <p6eval> rakudo a569e3: OUTPUT¬´1 3 5 7 9‚ê§¬ª

[08:38] <szabgab> r: for 1,3,5 ...10 { say $_ }

[08:39] <p6eval> rakudo a569e3: OUTPUT¬´(timeout)¬ª

[08:39] <pmichaud> the endpoint has to match exactly, or the sequence is infinite

[08:39] <szabgab> r: for 1,3,5 ...11 { say $_ }

[08:39] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§11‚ê§¬ª

[08:39] <szabgab> r: for 1,3 ...11 { say $_ }

[08:39] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§11‚ê§¬ª

[08:39] <szabgab> oh

[08:39] *** araujo left
[08:39] <pmichaud> it's a smart match at the end of the sequence, thus  * >= 10 works

[08:39] <szabgab> I think that used to work without exact match

[08:39] <pmichaud> it did; that got changed

[08:40] <pmichaud> because we have lots of sequences that can't be easily deduced as "up to" or "down to"

[08:40] <szabgab> r: for 1,3 ...^ *>10

[08:40] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Missing block‚ê§at /tmp/N0PJ14uCw4:1‚ê§¬ª

[08:40] <szabgab> r: for 1,3 ...^ *>10 { say $_ }

[08:40] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§¬ª

[08:42] <pmichaud> hmmm, I wonder

[08:42] <szabgab> r: for 1,2,0 ... 3 { say $_ }

[08:42] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§0‚ê§Unable to deduce sequence‚ê§  in method gist at src/gen/CORE.setting:9567‚ê§  in sub say at src/gen/CORE.setting:7011‚ê§  in block <anon> at /tmp/Dx2zwGalQA:1‚ê§‚ê§¬ª

[08:42] <pmichaud> r:  for 1,3 ...^ * !< 10 { .say }

[08:42] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§¬ª

[08:42] <pmichaud> heh, it works.

[08:43] <szabgab> could you give a sequence where you cannot deduct if it is upper or lower limit?

[08:44] <pmichaud> r: my @a = 1, -2, 4 ... *;  say @a[^15];

[08:44] <p6eval> rakudo a569e3: OUTPUT¬´1 -2 4 -8 16 -32 64 -128 256 -512 1024 -2048 4096 -8192 16384‚ê§¬ª

[08:44] <pmichaud> r: my @a = 1, -1, 1 ... *;  say @a[^10]

[08:44] <p6eval> rakudo a569e3: OUTPUT¬´1 -1 1 -1 1 -1 1 -1 1 -1‚ê§¬ª

[08:44] <szabgab> r: for 1,2,0 ... 3 { say $_ }

[08:44] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§0‚ê§Unable to deduce sequence‚ê§  in method gist at src/gen/CORE.setting:9567‚ê§  in sub say at src/gen/CORE.setting:7011‚ê§  in block <anon> at /tmp/1Mj25vrSPb:1‚ê§‚ê§¬ª

[08:45] <pmichaud> r: my @a = True, !* ... *;   say @a[^10]

[08:45] <p6eval> rakudo a569e3: OUTPUT¬´True False True False True False True False True False‚ê§¬ª

[08:45] <szabgab> it does not lie my sequence :(

[08:45] <szabgab> like

[08:45] <pmichaud> it can't figure out the relationship between 1, 2, and 0

[08:45] <szabgab> r: for 1,2,0,3 ... -1 { say $_ }

[08:45] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§2‚ê§0‚ê§3‚ê§Unable to deduce sequence‚ê§  in method gist at src/gen/CORE.setting:9567‚ê§  in sub say at src/gen/CORE.setting:7011‚ê§  in block <anon> at /tmp/8yQEiguzOR:1‚ê§‚ê§¬ª

[08:46] <pmichaud> what sequence are you wanting there?

[08:46] <szabgab> +1, -2, +3, -4 

[08:46] <pmichaud> yeah, that's neither arithmetic nor geometric

[08:46] <pmichaud> but you can do

[08:47] <pmichaud> (thinking)

[08:47] <diakopter> 1234 times -1,1,-1,1

[08:48] <diakopter> the nth at the first times the nth at the second

[08:48] <szabgab> I was thinking that if it is restricted to arithmetic and geometric then from 3 items you can see if it has a direction

[08:48] <pmichaud> r: my @a = 1, { $^x.abs * -$^x.sign } ... *;   say @a[^10]

[08:48] <p6eval> rakudo a569e3: OUTPUT¬´1 -1 1 -1 1 -1 1 -1 1 -1‚ê§¬ª

[08:48] <pmichaud> r: my @a = 1, { ($^x.abs+1) * -$^x.sign } ... *;   say @a[^10]

[08:48] <p6eval> rakudo a569e3: OUTPUT¬´1 -2 3 -4 5 -6 7 -8 9 -10‚ê§¬ª

[08:48] <szabgab> and from there you can no if it is upper bound, lower bound or no bound

[08:48] <pmichaud> szabgab: yeah, I think we decided that's too much special casing

[08:49] <pmichaud> it's much easier to just say it's always a smartmatch at the end

[08:50] <pmichaud> and geometric doesn't always have a direction

[08:50] <szabgab> r: for 1,3  ...^ *<10 { say $_ }

[08:50] <p6eval> rakudo a569e3:  ( no output )

[08:50] <szabgab> r: for 1,3  ...7 { say $_ }

[08:50] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§¬ª

[08:51] <szabgab> r: for 1,3  ...^ *>10 { say $_ }

[08:51] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§¬ª

[08:51] <szabgab> it feels the oposite way :)

[08:51] <pmichaud> yeah, that's why I did !< earlier :-)

[08:51] <szabgab> r: for 1,3  ...^ !<10 { say $_ }

[08:51] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Preceding context expects a term, but found infix !< instead‚ê§at /tmp/GihLfh61fo:1‚ê§¬ª

[08:51] <pmichaud> * !< 10

[08:52] <szabgab> r: for 1,3  ...^ * !<10 { say $_ }

[08:52] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§¬ª

[08:52] <szabgab> cryptic :(

[08:52] <pmichaud> not really.... !< is "not less than"

[08:52] <szabgab> r: for 1,3  ...  ^*!<  10 { say $_ }

[08:52] <p6eval> rakudo a569e3: OUTPUT¬´Cannot call 'Numeric'; none of these signatures match:‚ê§:(Mu:U \$v, Mu *%_)‚ê§‚ê§  in method Numeric at src/gen/CORE.setting:686‚ê§  in sub prefix:<^> at src/gen/CORE.setting:4948‚ê§  in block <anon> at /tmp/bagpRPf6fq:1‚ê§‚ê§¬ª

[08:52] <szabgab> r: for 1,3  ...^*!<  10 { say $_ }

[08:52] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§¬ª

[08:53] <szabgab> 4 non-alpha :)

[08:53] <szabgab> r: for 1,3  ...* <  10 { say $_ }

[08:53] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§¬ª

[08:53] <szabgab> r: for 1,3  ...* >  10 { say $_ }

[08:53] <p6eval> rakudo a569e3: OUTPUT¬´1‚ê§3‚ê§5‚ê§7‚ê§9‚ê§11‚ê§¬ª

[08:54] <szabgab> the first one would look good :)

[08:54] <szabgab> oh this will never end if every person comes with new ideas :)

[08:55] <szabgab> or "different from current" even if not "new"

[09:00] *** Woodi left
[09:07] *** sudokode left
[09:10] *** tyatpi left
[09:12] *** cognominal left
[09:14] *** cognominal joined
[09:16] *** sergot left
[09:26] *** PacoAir joined
[09:31] *** birdwindupbird joined
[09:36] *** sergot joined
[09:39] <pmichaud> r:  say 'abcd'.match(/a/, :x(1..4)).WHAT

[09:39] <p6eval> rakudo a569e3: OUTPUT¬´List()‚ê§¬ª

[09:39] <pmichaud> r:  say 'abcd'.match(/a/, :x(1..4))

[09:39] <p6eval> rakudo a569e3: OUTPUT¬´a‚ê§¬ª

[09:39] <pmichaud> r:  say 'abcd'.match(/a/, :n(1,3))

[09:39] <p6eval> rakudo a569e3: OUTPUT¬´q[a]‚ê§‚ê§¬ª

[09:39] <pmichaud> r:  say 'abcd'.match(/a/, :n(1,3)).WHAT

[09:39] <p6eval> rakudo a569e3: OUTPUT¬´Match()‚ê§¬ª

[09:40] <pmichaud> r:  say 'abcd'.match(/./, :n(1,3)).WHAT

[09:40] <p6eval> rakudo a569e3: OUTPUT¬´Match()‚ê§¬ª

[09:40] <pmichaud> r:  say 'abcd'.match(/./, :nth(1,3))

[09:40] <p6eval> rakudo a569e3: OUTPUT¬´a c‚ê§¬ª

[09:40] <pmichaud> r:  say 'abcd'.match(/./, :nth(1,3)).WHAT

[09:40] <p6eval> rakudo a569e3: OUTPUT¬´List()‚ê§¬ª

[09:40] <pmichaud> r:  say 'abcd'.match(/a/, :nth(1,3)).WHAT

[09:40] <p6eval> rakudo a569e3: OUTPUT¬´Match()‚ê§¬ª

[09:40] *** Guest34089 left
[09:40] <pmichaud> that seems wrongish.

[09:43] <pmichaud> time for sleep -- bbl

[09:51] *** Su-Shee joined
[09:51] <Su-Shee> hi all :)

[09:54] <sergot> Su-Shee: hi

[09:56] *** mucker joined
[10:03] *** whiteknight joined
[10:03] *** whiteknight is now known as Guest95989

[10:06] *** szabgab left
[10:23] *** Patterner left
[10:25] <masak> g'day, #perl6.

[10:25] *** Psyche^ joined
[10:25] *** Psyche^ is now known as Patterner

[10:25] <colomon> \o

[10:25] * colomon is not quite awake yet

[10:25] * masak is on a bus!

[10:25] <masak> and I've been awake since 04:30, which... mhh.

[10:27] * colomon work up at exactly 06:01

[10:29] <colomon> tried to go back to sleep, but my nose was too stuffy to handle the CPAP.

[10:29] <diakopter> hm. I spupose I should sleep tonight

[10:29] *** brrt left
[10:29] *** brrt joined
[10:30] *** brrt left
[10:36] *** zby_home_ joined
[10:42] <jnthn> Good Saturday, #perl6

[10:42] <masak> jnthn! \o/

[10:44] <moritz> \o

[10:44] <moritz> jnthn++ # hague grant completed

[10:46] <colomon> \o/

[10:46] <jnthn> \o/

[10:49] *** je joined
[10:56] <masak> jnthn++ \o/

[10:58] *** tyatpi joined
[11:00] *** birdwindupbird left
[11:01] *** je left
[11:06] <masak> re http://irclog.perlgeek.de/perl6/2012-07-07#i_5793473 -- I agree with quietfanatic++, and I think sorear++ changed the spec and fixed Niecza to be more consistent and simpler in this regard. I don't believe there are circularity issues.

[11:06] <masak> if jnthn concurs (or doesn't fly into a tantrum about having to change this bit), I'll submit a rakudobug.

[11:07] <jnthn> It used to be spec'd that way.

[11:07] <jnthn> I agreed it could change already.

[11:07] <jnthn> Rakudo didn't get updated yet.

[11:07] <jnthn> It was mostly SMOP that wanted it to be the other way, fwiw.

[11:08] * masak submits rakudobug

[11:08] <jnthn> That particular circularity saw doesn't apply to anything 6model-y. 6model doesn't care for captures in any sense, and the invocation protocol is specified as VM specific.

[11:08] <masak> yes, I remember that bit of input coming from pmurias++ and ruoso++

[11:08] <jnthn> Rakudo's postcircumfix:<( )> isn't the invocation protocol in general.

[11:08] <jnthn> SMOP tried to make it that way, which was why it wanted said circularity saw, iirc.

[11:09] <jnthn> .oO( Can I just fix this, or do I have to think about deprecation policy... :-) )

[11:10] *** araujo joined
[11:10] *** araujo left
[11:10] *** araujo joined
[11:14] <masak> the invocation protocol is VM specific, but I do hope the expected parameter list for postcircumfix:<( )> isn't.

[11:15] <jnthn> masak: That was kinda my point. What postcircumfix:<( )> does isn't anything to do with the VM's view.

[11:15] <masak> ok ok good.

[11:15] <masak> that's probably wise.

[11:29] *** Woodi joined
[11:39] <masak> Woodi! \o/

[11:44] *** c1sung left
[11:44] *** c1sung joined
[11:51] <pmichaud> jnthn: (postcircumfix:<( )>)   afaic, you can "just fix it".

[11:52] <Woodi> hi today everyone :)

[11:53] <jnthn> as far as i...?

[11:53] <pmichaud> as far as I'm concerned

[11:53] * jnthn is used to that ending "ct" = can tell :)

[11:53] <jnthn> oh!

[11:53] <jnthn> :)

[12:15] *** mucker left
[12:18] <dalek> doc: 2139f4f | pmichaud++ | lib/Positional.pod:

[12:18] <dalek> doc: [Positional]:  EnumMap isn't Positional; other minor tweaks and fixes.

[12:18] <dalek> doc: review: https://github.com/perl6/doc/commit/2139f4f040

[12:27] *** mucker joined
[12:29] *** GlitchMr left
[12:31] <dalek> doc: 7b0caa5 | pmichaud++ | lib/ (7 files):

[12:31] <dalek> doc: Various grammatical and minor fixes.

[12:31] <dalek> doc: review: https://github.com/perl6/doc/commit/7b0caa595f

[12:33] <dalek> rakudo/toqast: f96df3b | jnthn++ | src/QPerl6/Actions.pm:

[12:33] <dalek> rakudo/toqast: Translate the rest of the 'obvious' remaining PAST:: usages in the Actions. Thsoe that remain are interesting in some way. :-)

[12:33] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/f96df3b2ac

[12:33] <dalek> rakudo/toqast: 0c943c2 | jnthn++ | src/QPerl6/World.pm:

[12:33] <dalek> rakudo/toqast: Translate the easy remaining PAST usages in World.

[12:33] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/0c943c2536

[12:33] *** samlt joined
[12:41] *** birdwindupbird joined
[12:42] *** crab2313 joined
[12:48] *** am0c_ joined
[12:48] *** mucker left
[12:51] *** mucker joined
[13:04] *** GlitchMr joined
[13:05] <dalek> nqp/toqast: fd47dae | jnthn++ | src/QAST/Operations.nqp:

[13:05] <dalek> nqp/toqast: Add what/how/who ops.

[13:05] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/fd47dae8a6

[13:05] <dalek> nqp/toqast: 58acfd1 | jnthn++ | src/QAST/ (2 files):

[13:05] <dalek> nqp/toqast: Add a way to mark a block as having a custom arguments processor, and compile it to a :call_sig usage on Parrot.

[13:05] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/58acfd16bf

[13:07] <dalek> rakudo/toqast: 9b02aca | jnthn++ | src/QPerl6/ (3 files):

[13:07] <dalek> rakudo/toqast: Add a few ops to the abstraction layer.

[13:07] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/9b02aca31c

[13:07] <dalek> rakudo/toqast: c62d139 | jnthn++ | src/QPerl6/Actions.pm:

[13:07] <dalek> rakudo/toqast: Update arguments handling. Gets back one more sanity test, and changes the failure mode of many others.

[13:07] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/c62d139c7c

[13:07] <dalek> rakudo/toqast: bf653dd | jnthn++ | src/QPerl6/Actions.pm:

[13:07] <dalek> rakudo/toqast: Update compilation of .WHAT/.HOW/.WHO.

[13:07] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/bf653dd901

[13:07] *** Su-Shee left
[13:09] *** sergot left
[13:16] *** Guest95989 left
[13:22] <dalek> rakudo/toqast: 9114f92 | jnthn++ | src/QPerl6/ (2 files):

[13:22] <dalek> rakudo/toqast: Start to update return value handling.

[13:22] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/9114f9234c

[13:22] <dalek> rakudo/toqast: a543d24 | jnthn++ | src/QPerl6/ (2 files):

[13:22] <dalek> rakudo/toqast: Update Perl 6 capture_lex handling, which wins back one more sanity test.

[13:22] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/a543d246dd

[13:22] <dalek> rakudo/toqast: 3f5bb89 | jnthn++ | src/QPerl6/Actions.pm:

[13:22] <dalek> rakudo/toqast: Make returnless analysis not explode.

[13:22] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/3f5bb8971f

[13:25] *** sergot joined
[13:33] *** birdwindupbird left
[13:33] *** birdwindupbird joined
[13:34] *** pyrimidine left
[13:34] *** pyrimidine joined
[13:37] *** tyatpi left
[13:47] *** am0c_ left
[13:58] <timotimo> are there already specs or ideas how the automatic commandline argument parser created with MAIN can be enhanced? descriptions for flags and values etc.?

[14:02] *** flussence joined
[14:06] *** fgomez left
[14:12] *** birdwindupbird left
[14:12] *** brrt joined
[14:12] <moritz> not really

[14:12] <moritz> you can always write your own command line parser

[14:12] <timotimo> it would be nice to have a nice default one in place that does more than just the simples stuff

[14:13] <moritz> then write one

[14:13] <moritz> and we'll ship it with R*

[14:13] <moritz> and with a bit of luck and work, it'll become the default

[14:13] <colomon> timotimo: do you know what the current one can do?

[14:13] <timotimo> i don't know all of it i'm sure

[14:14] <moritz> it's nice, but it does have its limitations

[14:14] <dalek> nqp/toqast: 9c4dfa5 | jnthn++ | / (4 files):

[14:14] <dalek> nqp/toqast: Implement and test resultchild, which allows something other than the final statement of a QAST::Stmt or QAST::Stmts to be used as the result of the overall operation.

[14:14] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/9c4dfa54ef

[14:14] <moritz> it doesn't support subcommands with options separate from the main options, for example

[14:18] *** flussence left
[14:18] *** flussence joined
[14:21] *** PacoAir_ joined
[14:21] <colomon> What's qx// supposed to do if it can't execute?  (Say you've used the wrong command name.)

[14:21] <moritz> fail() I hope

[14:21] <colomon> that seems reasonable

[14:22] <flussence> that's what S29 says for shell() and run() anyway

[14:22] *** PacoAir left
[14:22] *** PacoAir_ is now known as PacoAir

[14:25] <moritz> the first two tests in  t/00-parrot/ now pass with qperl6

[14:25] <moritz> as does no. 4

[14:26] <jnthn> moritz: Currenlty there's 4 failures in t/00-parrot nad 5 in t/01-sanity

[14:26] <jnthn> (With latest toqast in nqp and rakudo repos)

[14:26] <jnthn> At least, that's how I have it :)

[14:33] *** nodmonkey joined
[14:33] <colomon> arg.  in niecza, sprintf works (on my current case) but printf doesn't.  :(

[14:35] <colomon> niecza: printf("%s, %d\n", "test", 1)

[14:35] <p6eval> niecza v19-12-gf36d743: OUTPUT¬´Unhandled exception: index out of range‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1277 (sprintf @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1278 (printf @ 4) ‚ê§  at /tmp/R2j1ncpN6z line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setti‚Ä¶

[14:35] * _sri wonders if there's a perl6brew yet

[14:41] <_sri> tadzik: i've been looking at MuEvent, is $socket.poll the only way to do non-blocking I/O?

[14:42] <_sri> that approach doesn't scale at all

[14:43] * colomon is not sure what it says about him that fixing bugs in Niecza is easier than just remembering the syntax to get his 16-line $work script working in p5

[14:46] * _sri wanted to build a little event loop with rakudo to see where it stands performance wise for I/O heavy servers

[14:49] *** whiteknight joined
[14:50] *** whiteknight is now known as Guest14009

[14:50] *** samlt left
[14:55] <dalek> nqp/toqast: 2cf193e | jnthn++ | src/QAST/Operations.nqp:

[14:55] <dalek> nqp/toqast: Port lexotic to QAST.

[14:55] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/2cf193eabd

[15:01] *** tyatpi joined
[15:12] <dalek> zavolaj: 8449183 | (Arne Skj√¶rholt)++ | TODO:

[15:12] <dalek> zavolaj: Update TODO list.

[15:12] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/844918322f

[15:14] *** cognominal_ joined
[15:15] *** harmil_home joined
[15:17] *** cognominal left
[15:20] <dalek> niecza: 442e075 | (Solomon Foster)++ | lib/CORE.setting:

[15:20] <dalek> niecza: Make printf work.  (How had we missed this one?!)

[15:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/442e075bb0

[15:24] *** tyatpi left
[15:44] *** brrt1 joined
[15:45] *** brrt1 left
[15:46] *** brrt left
[15:49] *** tokuhiro_ left
[15:53] *** PacoAir left
[15:54] *** PacoAir joined
[16:00] <dalek> nqp/toqast: f80052a | jnthn++ | src/QAST/Compiler.nqp:

[16:00] <dalek> nqp/toqast: s/newclosure/capture_lex/ for consistency with PAST.

[16:00] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/f80052aa6c

[16:00] <dalek> nqp/toqast: 7de611e | jnthn++ | src/QAST/ (2 files):

[16:00] <dalek> nqp/toqast: Fix register allocation so that lexicals don't get stomped on.

[16:00] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/7de611ec9b

[16:00] <dalek> rakudo/toqast: 05a1e61 | jnthn++ | src/QPerl6/Actions.pm:

[16:00] <dalek> rakudo/toqast: Update return handling for QAST.

[16:00] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/05a1e61938

[16:00] <dalek> rakudo/toqast: c6c6488 | jnthn++ | src/QPerl6/Actions.pm:

[16:00] <dalek> rakudo/toqast: Stop add_inlining_info blowing up, though really this whole thing goes away soon since we'll be able to serialize bits of QAST.

[16:00] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/c6c648801d

[16:16] <dalek> nqp/toqast: 2cb23aa | jnthn++ | src/QAST/Compiler.nqp:

[16:16] <dalek> nqp/toqast: Ensure blocks always end up with a lexinfo.

[16:16] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/2cb23aa30b

[16:18] *** crab2313 left
[16:19] <harmil_home> busy morning

[16:21] <harmil_home> ugh, I'm trying to refactor IO into a base IO::Parrot and the specced IO class, and I'm getting some very odd errros on compile that give me no leads on what to fix...

[16:22] <moritz> harmil_home: which specced IO class?

[16:22] <moritz> harmil_home: and what errors do you get?

[16:22] <harmil_home> moritz: I don't know. Whatever one was already in there. I'm basically trying to leave it alone, and just factor out $!PIO into a base class

[16:23] <harmil_home> Could not locate compile-time value for symbol Comp::AdHoc

[16:23] <harmil_home> current instr.: 'nqp;Perl6;World;_block2280' pc 32075 (src/gen/perl6-symboltable.pir:13915) (src/Perl6/World.pm:1709)

[16:23] <moritz> harmil_home: that IO class isn't specced :-)

[16:23] <harmil_home> moritz: fair enough, but it's loosely based on (and probably intended to migrate towards) the spec, right?

[16:24] <moritz> harmil_home: very loosely

[16:24] <harmil_home> My goal is to leave its interface as its interface, whatever that is and make Parrot::IO give us everything Parrot can do

[16:24] <harmil_home> er IO::Parrot

[16:25] <moritz> ah, I see how you might get that error

[16:25] <harmil_home> So, for example, my buffered IO stuff just moves down a level, as does anything that's basically just a wrapper around nqp::p6box_*($!PIO.somefunc())

[16:25] <harmil_home> oh?

[16:26] *** nodmonkey left
[16:26] <moritz> harmil_home: it will be much easier for you do the whole thing outside of the setting

[16:27] <moritz> in fact, there isn't a good reason to do it inside the setting

[16:27] <moritz> unless you are fond of very long compile times

[16:27] <harmil_home> I'm not entirely clear what that menas.

[16:27] <moritz> just write the new IO::Parrot and IO class in a normal script

[16:27] <moritz> not in src/core/IO.pm

[16:28] <harmil_home> Ah, and override the core ones and all of the static functions that map into them?

[16:28] <moritz> (the error you are getting is an error during error reporting; I'll try to make it more robust)

[16:28] <moritz> harmil_home: right

[16:28] <moritz> whever "override" just means "declare a new one"

[16:29] <moritz> (lexical lookup)++

[16:29] <harmil_home> I suppose I could do that, but it seems like a lot of duplication. Won't that lead to IO in the core slowly diverging from "the real IO"?

[16:29] <harmil_home> Do we care?

[16:29] <moritz> harmil_home: well, we can always copy it back into src/core/IO.pm if it proves to be superior

[16:30] <harmil_home> Fair enough, I see what you're saying.

[16:30] <moritz> harmil_home: in fact I prototyped most of "my" setting code outside the setting first

[16:32] <arnsholt> One of the benefits of having most of the compiler written in Perl 6: Prototyping new bits of the compiler can often be done outside of the compiler first =)

[16:33] <pmichaud> Yes, I almost always prototype new features outside of the core setting first.

[16:33] <pmichaud> question:   what should be the result of   

[16:33] <harmil_home> Should I do this as a stand-alone perl6-io module or in my fork of rakudo/rakudo under lib?

[16:34] <pmichaud>     "abcd".match( /./, :p(1), :global)

[16:34] <pmichaud> harmil_home: I suggest a standalone module.

[16:34] <harmil_home> pmichaud: thanks

[16:35] <pmichaud> I think (1) IO::Parrot is very useful, yet (2) it's unlikely to be part of the Rakudo core, unless we find it to be fundamental somehow.

[16:35] <pmichaud> (it is likely to be part of R*, however)

[16:36] <pmichaud> rn:  say "abcd".match( /./, :p(1), :global)

[16:36] <harmil_home> pmichaud: urm... well, I can't do IO::Parrot in a vacuum. IO::Parrot is mostly a re-factor and re-write of the internals of IO

[16:36] <p6eval> niecza v19-13-g442e075: OUTPUT¬´Unhandled exception: Excess arguments to Cool.match, unused named global‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (Cool.match @ 1) ‚ê§  at /tmp/AYDLrnj5tV line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3918 (ANON @ 3) ‚ê§  at /ho‚Ä¶

[16:36] <p6eval> ..rakudo a569e3: OUTPUT¬´b c d‚ê§¬ª

[16:36] <pmichaud> rn:  say "abcd".match( /./, :p(1), :g)

[16:36] <p6eval> niecza v19-13-g442e075: OUTPUT¬´Unhandled exception: Excess arguments to Cool.match, unused named g‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (Cool.match @ 1) ‚ê§  at /tmp/ePKgPPnjAJ line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3918 (ANON @ 3) ‚ê§  at /home/p6‚Ä¶

[16:36] <p6eval> ..rakudo a569e3: OUTPUT¬´b c d‚ê§¬ª

[16:36] *** nodmonkey joined
[16:36] <moritz> well, :p only makese sense on the first match

[16:37] <pmichaud> yes, so I'm wondering if we should only get one match back.

[16:37] *** phenny left
[16:37] <moritz> I can see three possible interpretations

[16:37] <moritz> (1) only ever return one match

[16:37] <moritz> (2) only anchor the first match

[16:37] *** phenny joined
[16:38] <moritz> (3) anchor the first match to 1, and each subsequent match to where the previous left off

[16:38] <pmichaud> yes, those are the three I was considering also.  I guess this will have to be a TimToady++ question.

[16:38] <arnsholt> My initial reaction is 1, I think

[16:39] <moritz> nqp: my $x := 1; $x++; say($x)

[16:39] <p6eval> nqp: OUTPUT¬´2‚ê§¬ª

[16:39] <moritz> nqp: my $x := 1; ++$x; say($x)

[16:39] <p6eval> nqp: OUTPUT¬´2‚ê§¬ª

[16:42] *** nodmonkey left
[16:57] <pmichaud> https://github.com/perl6/specs/issues/16

[16:58] <moritz> pmichaud++

[16:59] <moritz> sorear: can we get dalek to report spec issues?

[16:59] <pmichaud> I found that by just watching the perl6/specs repo, I get emails everytime a new issue or comment is posted.

[17:00] <pmichaud> email seems to be the only push notification for issues on github

[17:00] <moritz> well, dalek also supports pulling

[17:00] <colomon> ah, that's why I've been getting those emails...

[17:00] <moritz> having commit access should also be enough

[17:01] <pmichaud> I think one has to actually be watching the repo to get the emails.

[17:01] <pmichaud> but I could be wrong about that.

[17:01] <pmichaud> (You also get emails for any issues you create or comment upon, I think.)

[17:02] <moritz> maybe I'm watching it because I created it :-)

[17:02] <moritz> I don't remember ever pressing a "watch" button though

[17:08] <pmichaud> anyway, I looked into it a few days ago, and decided I wasn't up to tracking everything down to get issue updates into dalek

[17:08] *** pmurias joined
[17:11] *** kaare_ left
[17:11] *** kaare_ joined
[17:11] *** lep-delete joined
[17:12] <dalek> nqp/toqast: ad562d8 | jnthn++ | src/QAST/Operations.nqp:

[17:12] <dalek> nqp/toqast: Implement op xor (which has the semantics of xor_nqp).

[17:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/ad562d8a09

[17:12] <dalek> specs: aca4dff | pmichaud++ | questions.txt:

[17:12] <dalek> specs: Remove questions.txt in favor of Github's issue tracker.

[17:12] <dalek> specs: The one unanswered question from questions.txt is now at

[17:12] <dalek> specs: https://github.com/perl6/specs/issues/17 .

[17:12] <dalek> specs: review: https://github.com/perl6/specs/commit/aca4dff4da

[17:13] <dalek> rakudo/toqast: 2ce8e79 | jnthn++ | src/QPerl6/Grammar.pm:

[17:13] <dalek> rakudo/toqast: xor_nqp => xor; now down to 2 failing test files in 00-parrot and 3 in 01-sanity.

[17:13] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/2ce8e795b3

[17:17] *** szabgab joined
[17:17] <harmil_home> rn: class A {}; role B {}; class C is A does B {}

[17:17] <szabgab> r: say substr "abcd", 1, -1

[17:17] <p6eval> rakudo a569e3, niecza v19-13-g442e075:  ( no output )

[17:17] <p6eval> rakudo a569e3: OUTPUT¬´Negative length argument (-1) to .substr‚ê§  in method gist at src/gen/CORE.setting:9567‚ê§  in sub say at src/gen/CORE.setting:7011‚ê§  in block <anon> at /tmp/kvgD4R6vnP:1‚ê§‚ê§¬ª

[17:18] <harmil_home> I think the no output is mine ;)

[17:18] <szabgab> is the fact that substr does not take negative length the design or lack of implementation?

[17:18] <pmichaud> I think it's *-1

[17:18] <harmil_home> rn: class A {}; role B {}; class IO is A does B

[17:18] <p6eval> niecza v19-13-g442e075: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse class definition at /tmp/OcrdwU6Zc9 line 1 (EOF):‚ê§------> [32mss A {}; role B {}; class IO is A does B[33m‚èè[31m<EOL>[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[17:18] <p6eval> ..rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Unable to parse $*PKGDECL definition at line 2, near ""‚ê§¬ª

[17:18] <szabgab> harmil_home: yes

[17:18] <pmichaud> r: say substr "abcd", 1, *-1

[17:18] <p6eval> rakudo a569e3: OUTPUT¬´bc‚ê§¬ª

[17:19] <szabgab> pmichaud: aha

[17:19] <szabgab> thanks

[17:19] <pmichaud> the error message to .substr should perhaps indicate that.

[17:19] <harmil_home> anyone have a sense of why I'm getting errors parsing a class definition if I call it IO?

[17:19] <szabgab> r: my $x=-1; say substr "abcd", 1, $x

[17:19] <p6eval> rakudo a569e3: OUTPUT¬´Negative length argument (-1) to .substr‚ê§  in method gist at src/gen/CORE.setting:9567‚ê§  in sub say at src/gen/CORE.setting:7011‚ê§  in block <anon> at /tmp/DgW1qkrzzW:1‚ê§‚ê§¬ª

[17:19] <moritz> r: class IO { }

[17:19] <p6eval> rakudo a569e3:  ( no output )

[17:20] <szabgab> r: my $x=-1; say substr "abcd", 1, *$x

[17:20] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/oj8gSkFa0S:1‚ê§¬ª

[17:20] <moritz> harmil_home: no. works here

[17:20] <szabgab> r: my $x=-1; say substr "abcd", 1, * $x

[17:20] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/Y2_1LUWr3z:1‚ê§¬ª

[17:20] <szabgab> r: my $x=1; say substr "abcd", 1, * -$x

[17:20] <p6eval> rakudo a569e3: OUTPUT¬´bc‚ê§¬ª

[17:20] <harmil_home> moritiz, see my rn: above

[17:20] <harmil_home> moritz, even

[17:20] <szabgab> so both rakudo and I am confused :)

[17:23] <pmichaud> rn: class A {}; role B {};  my class IO is A does B { ... }

[17:23] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§The following packages were stubbed but not defined:‚ê§    IO‚ê§at /tmp/7bbkQWsjSF:1‚ê§¬ª

[17:23] <p6eval> ..niecza v19-13-g442e075: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Package was stubbed but not defined at /tmp/4sq6dqLtRv line 1:‚ê§------> [32mclass A {}; role B {};  my class[33m‚èè[31m IO is A does B { ... }[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.se‚Ä¶

[17:23] <pmichaud> rn: class A {}; role B {};  my class IO is A does B { }

[17:23] <p6eval> rakudo a569e3, niecza v19-13-g442e075:  ( no output )

[17:23] <pmichaud> rn: class A {}; role B {};  class IO is A does B { }

[17:23] <p6eval> rakudo a569e3, niecza v19-13-g442e075:  ( no output )

[17:23] <pmichaud> seems to work.

[17:24] <harmil_home> I'm trying to figure out what you did differently...

[17:25] <moritz> harmil_home: you were missing the { } of the class

[17:25] <harmil_home> ah... hmm...

[17:25] <harmil_home> so then it was a red herring. That's unpleasant

[17:26] <harmil_home> My real error is Unable to parse $*PKGDECL definition at line 226, near "does IO::F"

[17:26] <harmil_home> which I get on class IO is IO::Parrot does IO::FileTestable {

[17:26] <pmichaud> could be an error inside the braces (that isn't being reported well)

[17:27] <moritz> r: class IO::Parrot { }; class IO is IO::Parrot does IO::FileTestable { }

[17:27] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Unable to parse $*PKGDECL definition at line 2, near "does IO::F"‚ê§¬ª

[17:27] <harmil_home> OK, I'll start doing the binary search...

[17:27] <pmichaud> if you can nopaste it, we might be able to spot it quickly

[17:27] <harmil_home> interesting.

[17:27] <moritz> seems I've just reproduced it above

[17:27] <moritz> r: class IO::Parrot { }; class MyIO is IO::Parrot does IO::FileTestable { }

[17:27] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Unable to parse $*PKGDECL definition at line 2, near "does IO::F"‚ê§¬ª

[17:27] <moritz> so, not related to the IO name

[17:28] <harmil_home> related to undefined IO::FileTestable?

[17:28] <moritz> r: class IO::Parrot { }; class IO does IO::FileTestable { }

[17:28] <p6eval> rakudo a569e3: OUTPUT¬´===SORRY!===‚ê§Unable to parse $*PKGDECL definition at line 2, near "does IO::F"‚ê§¬ª

[17:28] <harmil_home> Oh heck

[17:28] <harmil_home> I didn't export IO::Parrot after I moved it out into a file

[17:28] <moritz> r: say IO::FileTestable

[17:28] <p6eval> rakudo a569e3: OUTPUT¬´Could not find symbol 'IO::&FileTestable'‚ê§  in block <anon> at /tmp/ojDGWQZdeJ:1‚ê§‚ê§¬ª

[17:28] <moritz> oh, that explains a lot

[17:29] <harmil_home> hmmm that didn't help any

[17:29] <pmichaud> might be worthy of a LTA rakudobug

[17:29] <moritz> r: say IO::FileTestable

[17:29] <p6eval> rakudo a569e3: OUTPUT¬´Could not find symbol 'IO::&FileTestable'‚ê§  in block <anon> at /tmp/k8rQXz5Tio:1‚ê§‚ê§¬ª

[17:29] <harmil_home> LTA?

[17:29] <moritz> less than awesome

[17:29] <harmil_home> ah

[17:29] <moritz> oh

[17:29] <moritz> that's becase p6eval hides IO

[17:29] <moritz> it works locally

[17:30] <moritz> but yes, a missing IO::Parrot would do the same

[17:30] <pmichaud> also, if you do    class IO does IO::FileTestable     you're hiding the old IO namespace

[17:30] <harmil_home> pmichaud, which I wish to do

[17:30] <harmil_home> I'm wholly replacing it

[17:31] <pmichaud> which means that IO::FileTestable isn't visible :)

[17:31] <pmichaud> unless you're replacing that too :)

[17:31] <harmil_home> yep

[17:31] <pmichaud> okay then.

[17:31] <moritz> though, consider not to inherit from IO::Parrot

[17:31] <harmil_home> my IO.pm is the core IO.pm with all parrot IO calls ripped out

[17:32] <moritz> it feels wrong to have VM-specific behavior as the superclass of the general IO class

[17:32] <harmil_home> how would you define IO.read if not in terms of a lower-level interface?

[17:33] <pmichaud> it can be a role

[17:33] <jnthn> It's fine to define it in terms of a lower level interface, but it should be done through delegation.

[17:33] <moritz> harmil_home: you can ouse a lower-level interface without inheritance

[17:34] <jnthn> Please think a bit about what this will look like off Parrot too. :)

[17:34] <moritz> harmil_home: it can be an attribute (has $.parrot-io), or simply function calls or something else

[17:34] <moritz> right, delegation, not inheritance

[17:34] <pmichaud> we definitely don't want to be interposing a vm-specific class between IO and Any

[17:34] <harmil_home> Ugh, I was trying to extract the parrot-speciifc attribute out, not change it's type ;)

[17:34] <harmil_home> pmichaud, why not?

[17:35] <pmichaud> it is likely to confuse the type system across implementations

[17:35] <moritz> because superclasses are part of the public API

[17:35] <pmichaud> moritz++ said it better :)

[17:35] <moritz> and our public API shouldn't expose VM-specific stuff

[17:35] <moritz> inheritance is just wrong Wrong WRONG here

[17:35] <harmil_home> pmichaud, how would it confuse the type systems across implementations? There won't be an IO::Parrot in a non-Parrot implementation will there?

[17:36] <pmichaud> harmil_home: correct.  Which means that IO on a different implementation would have a different superclass than Rakudo on Parrot

[17:36] <harmil_home> sigh, OK, I'm going to go get some lunch and try to pretend that getting buffered IO into the core isn't running into road-blocks at every step

[17:38] <moritz> be glad that we caught that mistake *before* you implemented it all

[17:40] <pmichaud> > say substr 'abcd', 1, -1

[17:40] <pmichaud> Negative length argument (-1) to .substr, use '*-1' if you want offset from the end

[17:40] <jnthn> pmichaud++

[17:40] <dalek> rakudo/toqast: 3dd5f6f | jnthn++ | src/QPerl6/Actions.pm:

[17:40] <dalek> rakudo/toqast: Eliminate a usage of viviself.

[17:40] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/3dd5f6f91c

[17:40] <dalek> rakudo/toqast: a466813 | jnthn++ | src/QPerl6/ (2 files):

[17:40] <dalek> rakudo/toqast: Start fixing package lookups a bit. Gets us one more test passing again.

[17:40] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/a4668139cd

[17:40] <jnthn> splice still needs this kinda update too

[17:42] *** harmil_home left
[17:46] <sorear> good * #perl6

[17:47] <sorear> moritz: dalek reports anything that you can append to the queue file.

[17:47] <sorear> moritz: it also has an rss puller

[17:47] <sorear> rss pull will be slower ofc

[17:48] <moritz> sorear: where is parrot's issue watching configured?

[17:49] <pmichaud> ...parrot has an issue watcher?

[17:49] <pmurias> sorear: hi

[17:50] <pmurias> sorear: is there anything with niecza that you need help with?

[17:53] <sorear> pmichaud: yes!  and it even used to work!

[17:53] <sorear> trac only

[17:53] *** vmspb joined
[17:54] *** PerlJam joined
[17:56] <sorear> colomon: why doesn't sprintf take a slurpy?

[18:00] *** tyatpi joined
[18:01] <dalek> rakudo/nom: c24da0b | pmichaud++ | src/core/Str.pm:

[18:01] <dalek> rakudo/nom: Improve the negative start/length failure messages for substr.

[18:01] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c24da0b30e

[18:05] <pmurias> sorear: my summer break has started so I should have lots of free time soon

[18:06] <pmurias> sorear: should I work on the stuff from the TODO or does the no-bootstrap branch need to be finished first?

[18:09] <sorear> I haven't gone over TODO recently, probably it has a lot of stale items

[18:09] <sorear> I personally am blocking everything else on no-bootstrap

[18:13] <pmurias> anything there I should work on

[18:14] <pmurias> ?

[18:14] <pmurias> preferably something isolated as lightning destroyed my dsl modem, so I have to walk to the uni to use the wifi :(

[18:21] *** fgomez joined
[18:21] * sorear shrugs

[18:30] *** am0c left
[18:53] *** trist4n left
[18:54] *** lep-delete left
[18:54] <pmurias> sorear: how should I build the non-bs branch?

[18:58] <sorear> pmurias: make, then mono obj/Run.Kernel.dll -test-nobs --help

[18:58] <sorear> hmmm

[18:59] <sorear> no, that was right

[18:59] <sorear> it wasn't working because I tried it in the wrong checkout

[19:00] <flussence> random question: is there a more idiomatic way to have a repeating list of items than @f[$_ % @f]?

[19:00] <sorear> @f xx *

[19:01] *** GlitchMr left
[19:01] <pmurias> sorear: thanks

[19:01] <pmurias> sorear: I mistook the lack of some debian package for typing the wrong invocation

[19:01] <flussence> oh, that looks nicer. thanks

[19:01] *** MayDaniel joined
[19:02] <sorear> pmurias: actually just make obj/Run.Kernel.dll

[19:02] <sorear> the branch is nowhere near usable

[19:04] *** vmspb left
[19:07] <pmurias> sorear: does the non-bs branch run anything right now?

[19:07] <pmurias> sorear: does the non-bs branch run anything right now?

[19:08] <pmurias> sorry for repetition

[19:08] <sorear> no

[19:10] <pmurias> so you are just translating code for now?

[19:11] <sorear> yes

[19:16] <masak> evening, #perl6

[19:16] <sorear> o/ masak

[19:20] *** birdwindupbird joined
[19:25] <moritz> \o *

[19:29] *** pmurias left
[19:30] *** preflex_ joined
[19:30] *** preflex_ is now known as preflex

[19:35] <masak> r: class A { method foo() {} }; say +grep { .positional && !.invocant }, A.^methods[0].signature.params; class B { has A $.a handles <foo> }; say +grep { .positional && !.invocant }, B.^methods[0].signature.params

[19:35] <p6eval> rakudo c24da0: OUTPUT¬´0‚ê§0‚ê§¬ª

[19:35] <masak> r: class A { method foo() {} }; say +grep { .positional && !.invocant }, A.^methods[0].signature.params; class B { has A $!a handles <foo> }; say +grep { .positional && !.invocant }, B.^methods[0].signature.params

[19:35] <p6eval> rakudo c24da0: OUTPUT¬´0‚ê§1‚ê§¬ª

[19:35] <masak> jnthn: why the 1?

[19:36] <masak> this surprised me greatly.

[19:36] <masak> r: class A { method foo() {} }; class B { has A $!a handles <foo> }; say (grep { .positional && !.invocant }, B.^methods[0].signature.params).name

[19:36] <p6eval> rakudo c24da0: OUTPUT¬´No such method 'name' for invocant of type 'List'‚ê§  in block <anon> at /tmp/fUdadEjW3e:1‚ê§‚ê§¬ª

[19:36] <jnthn> masak: Maybe handles installs a closure rather than an anonymous method or something.

[19:36] <masak> r: class A { method foo() {} }; class B { has A $!a handles <foo> }; say (grep { .positional && !.invocant }, B.^methods[0].signature.params)[0].name

[19:36] <p6eval> rakudo c24da0: OUTPUT¬´$c‚ê§¬ª

[19:36] <masak> what's $c?

[19:37] *** christian_ joined
[19:37] <masak> jnthn: yeah, but it only does this when the attribute is private.

[19:37] <masak> suddenly my nice introspection breaks :)

[19:37] <jnthn> ...what?

[19:37] <jnthn> It's about handles. It's nothing to do with privacy.

[19:38] <masak> well, it shouldn't have anything to do with privacy.

[19:38] *** christian_ left
[19:38] <masak> but note that the output is different if it's $.a or $!a above.

[19:38] <masak> that's what's surprising, more than anything else, really.

[19:39] * masak submits rakudobug

[19:39] <jnthn> ah, maybe it goes thorugh a differnet codepath or something becuase you want it to call the accessor in the first case

[19:39] <jnthn> I dunno

[19:40] <masak> the B.foo method comes back saying it has one positional non-invocant parameter.

[19:40] <jnthn> Well, did you check what kind of object it is?

[19:40] <jnthn> It's probably a Block rather than a Method.

[19:40] <masak> r: class A { method foo() { say "OH HAI" } }; class B { has A $!a handles <foo> }; B.new.foo

[19:40] <p6eval> rakudo c24da0: OUTPUT¬´OH HAI‚ê§¬ª

[19:41] <masak> r: class A { method foo() {} }; class B { has A $!a handles <foo> }; say (grep { .positional && !.invocant }, B.^methods[0].signature.params)[0].^name

[19:41] <p6eval> rakudo c24da0: OUTPUT¬´Parameter‚ê§¬ª

[19:41] <masak> er.

[19:41] <masak> r: class A { method foo() {} }; class B { has A $!a handles <foo> }; say B.^methods[0].^name

[19:42] <p6eval> rakudo c24da0: OUTPUT¬´Method‚ê§¬ª

[19:42] <masak> it's a Method.

[19:42] <masak> with a $c parameter.

[19:42] <jnthn> Oh.

[19:42] <jnthn> oh, of course.

[19:42] <jnthn> it's |$c

[19:42] <jnthn> As in, the capture

[19:43] <jnthn> I'm surprised that is counted as positional.

[19:43] <jnthn> I suspect that's the real bug.

[19:43] <jnthn> r: sub foo(|$c) { }; say &foo.params[0].positional

[19:43] <p6eval> rakudo c24da0: OUTPUT¬´No such method 'params' for invocant of type 'Sub'‚ê§  in block <anon> at /tmp/GsWgBwfdNM:1‚ê§‚ê§¬ª

[19:43] <jnthn> r: sub foo(|$c) { }; say &foo.signature.params[0].positional

[19:43] <p6eval> rakudo c24da0: OUTPUT¬´True‚ê§¬ª

[19:44] <pmichaud> r: sub foo(|$c) { };  say &foo.count;

[19:44] <jnthn> Yeah, that probably should not be True

[19:44] <p6eval> rakudo c24da0: OUTPUT¬´Inf‚ê§¬ª

[19:44] <pmichaud> r: sub foo(|$c) { };  say &foo.arity;

[19:44] <p6eval> rakudo c24da0: OUTPUT¬´0‚ê§¬ª

[19:44] <pmichaud> at least those are correct.  :-)

[19:44] <masak> I think the real bug is that the actual parameters in the handled method get hidden in a capture parameter -- and that this only happens for private attributes :/

[19:44] <jnthn> What "actual parameters"?

[19:44] <masak> jnthn: in this case, an empty list of them.

[19:45] <jnthn> masak: Your expectations are weird.

[19:45] <jnthn> masak: How is it meant to know that the object that you call .foo on will take no parameters?

[19:46] <pmichaud> in some sense, wrappers that pass-through their arguments to the thing they wrap perhaps ought to expose the underlying signature, too.

[19:46] <jnthn> IT'S A METHOD DISPATCH. WE DO NOT KNOW.

[19:46] <masak> jnthn: what pmichaud said.

[19:46] <masak> jnthn: why does it work for the public case but not for the private case?

[19:46] <pmichaud> although yes, I see what jnthn++ is saying also, here.

[19:47] <masak> well, me too.

[19:47] <jnthn> masak: Because you're looking at the wrong method, perhaps?

[19:47] <jnthn> .methods[0] 

[19:47] <jnthn> You're probably looking at the generated accessor method there.

[19:48] <pmichaud> there have been a few times I've wished for   .methods.<xyz>  :-)

[19:49] <jnthn> Sadly, it's a list, not a hash.

[19:49] <jnthn> Wait...what? :)

[19:49] *** szabgab left
[19:49] <jnthn> .find_method('xyz') # :)

[19:49] <pmichaud> ...where .postcircumfix:<{ }>  greps through that list for method names

[19:49] <pmichaud> I can live with find_method

[19:50] <pmichaud> r:  say 3.find_method('Str')

[19:50] <p6eval> rakudo c24da0: OUTPUT¬´No such method 'find_method' for invocant of type 'Int'‚ê§  in block <anon> at /tmp/kwRwcKAoyO:1‚ê§‚ê§¬ª

[19:50] <jnthn> .^

[19:50] <pmichaud> r:  say 3.^find_method('Str')

[19:50] <jnthn> It's a meta-method

[19:50] <p6eval> rakudo c24da0: OUTPUT¬´Str‚ê§¬ª

[19:50] <pmichaud> r:  say 3.^find_method('Str').signature

[19:50] <p6eval> rakudo c24da0: OUTPUT¬´:(Mu , , Mu *%_)‚ê§¬ª

[19:51] <jnthn> Um.

[19:51] <pmichaud> okay, that works well enough for me I guess.  :)

[19:51] <moritz> you can also do .can('Str')[0]

[19:51] <jnthn> Aside from Signature.perl needs some love.

[19:51] <pmichaud> r: class A { method foo() { say "OH HAI" } };  class B { has A $!a handles <foo>;  B.new.^find_method('foo').say

[19:51] <p6eval> rakudo c24da0: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 2, near ""‚ê§¬ª

[19:52] <pmichaud> r: class A { method foo() { say "OH HAI" } };  class B { has A $!a handles <foo>; };  B.new.^find_method('foo').say

[19:52] <p6eval> rakudo c24da0: OUTPUT¬´foo‚ê§¬ª

[19:52] <pmichaud> r: class A { method foo() { say "OH HAI" } };  class B { has A $!a handles <foo>; };  B.new.^find_method('foo').signature.say

[19:52] <p6eval> rakudo c24da0: OUTPUT¬´:(Mu , |$c, Mu *%_)‚ê§¬ª

[19:52] <pmichaud> there ya go.  :-)

[19:52] <jnthn> Yeah, it knows its a capture.

[19:52] <jnthn> I bet that way, changing it to $.a doesn't change things.

[19:53] <pmichaud> and we can't know anything about the underlying A.foo because it's a dispatcher, not a wrapper?

[19:53] <jnthn> What is I wrote a class C is A { method foo($x) { } } 

[19:53] <jnthn> *if

[19:53] <jnthn> It's a dynamic (at runtime) dispatch.

[19:54] <pmichaud> exactly.  the handles<foo>  doesn't wrap the A::foo method.

[19:54] <pmichaud> It simply takes anything coming in at B.foo and sends it to $!a

[19:54] <jnthn> Exactly. It installs a new method in B.

[19:54] <pmichaud> wfm

[19:55] <masak> ok, so "it's like this".

[19:55] <moritz> ... "and that's the way it is"

[19:55] <masak> r: class A { method foo() { say "OH HAI" } };  class B { has A $.a handles <foo>; }; say B.new.^find_method('foo').signature

[19:55] <p6eval> rakudo c24da0: OUTPUT¬´:(Mu , |$c, Mu *%_)‚ê§¬ª

[19:55] <jnthn> So, the only bug I see in all of this is that a |$c gives .positional as True under introspection.

[19:55] <pmichaud> to fix the .positional problem, I propose adding $SIG_ELEMENT_IS_CAPTURE to

[19:55] <pmichaud>             ($!flags +& ($SIG_ELEM_SLURPY_POS +| $SIG_ELEM_SLURPY_NAMED)) == 0 &&

[19:56] <jnthn> pmichaud: Yes, that should do it.

[19:56] <masak> jnthn: it also counts |$c differently for the public/private attr cases.

[19:56] <masak> even though it's there in both cases.

[19:56] <jnthn> masak: You haven't shown that.

[19:57] <jnthn> masak: [0] in the list of methods is probably not the generated 'foo', but instead the generated accessor method.

[19:57] *** Guest14009 left
[19:58] <masak> oh.

[19:58] *** whiteknight joined
[19:58] <jnthn> Relying on ordering of generated stuff in the method list is not wise.

[19:58] <pmichaud> ...which is why I'd like a .^methods{'foo'}  :-)

[19:58] *** whiteknight is now known as Guest30914

[19:58] <pmichaud> I agree that find_method works... but it has that "find_" part in it.

[19:59] <masak> r: class A { method foo() {} }; class B { has A $.a handles <foo> }; say (grep { .positional && !.invocant }, B.^methods[0].signature.params)[0].name

[19:59] <p6eval> rakudo c24da0: OUTPUT¬´No such method 'name' for invocant of type 'Nil'‚ê§  in block <anon> at /tmp/tqiggdrcJ4:1‚ê§‚ê§¬ª

[19:59] <masak> r: class A { method foo() {} }; class B { has A $.a handles <foo> }; say B.^methods[0].name

[19:59] <p6eval> rakudo c24da0: OUTPUT¬´a‚ê§¬ª

[19:59] <pmichaud> ding!

[19:59] <masak> jnthn++ masak--

[20:00] <masak> shoulda checked ;)

[20:01] <jnthn> pmichaud: .^method_table{'foo'} may well work.

[20:01] <jnthn> pmichaud: But it's...ugly again probably ;)

[20:01] <pmichaud> jnthn: no, I like that one.

[20:01] <jnthn> pmichaud: Be aware that method_table is only the methods *directly* in the class.

[20:01] <pmichaud> find_method is too.... active for me

[20:01] <pmichaud> oh, that's a very good point.

[20:01] <jnthn> pmichaud: Well, find_method can be very active :)

[20:01] <pmichaud> Okay, I accept find_method.

[20:02] <jnthn> pmichaud: If there's any fallback stuff or wildcard delegation going on, find_method is gonna also get you that too.

[20:02] <pmichaud> ...we have no tests for .positional ?

[20:02] <jnthn> .^methods is purely asking the class about what was added to it, and returns everything up to Cool or Any.

[20:02] <masak> pmichaud: find_method is definitely active in the case of, say, Grammar::Debugger ;)

[20:02] <jnthn> Right, that's an excellent example.

[20:04] <jnthn> pmichaud: S06-signature/introspection.t will contain them if they're anywhere

[20:04] <pmichaud> jnthn: it does not.  I'll add a couple :)

[20:04] <jnthn> :)

[20:05] <pmichaud> r: sub xyz(|$c) { };  say &xyz.signature.params[0].name

[20:05] <p6eval> rakudo c24da0: OUTPUT¬´$c‚ê§¬ª

[20:06] <pmichaud> r: sub xyz(|$c) { };  say &xyz.signature.params[0].positional

[20:06] <p6eval> rakudo c24da0: OUTPUT¬´True‚ê§¬ª

[20:06] <jnthn> That's the one that I think should be False.

[20:06] <jnthn> ooc

[20:06] <jnthn> r: sub xyz(*@a) { };  say &xyz.signature.params[0].positional

[20:06] <p6eval> rakudo c24da0: OUTPUT¬´False‚ê§¬ª

[20:06] <pmichaud> that's explicitly checked for by SIG_ELEM_SLURPY_POS

[20:07] <jnthn> ah, yes 

[20:07] <pmichaud> 19:55 <pmichaud>             ($!flags +& ($SIG_ELEM_SLURPY_POS +| $SIG_ELEM_SLURPY_NAMED)) == 0 &&

[20:08] <pmichaud> r: sub xyz(|$c) { };  say &xyz.signature.params[0].slurpy

[20:08] <p6eval> rakudo c24da0: OUTPUT¬´False‚ê§¬ª

[20:09] <pmichaud> ...wonder if that should be true :-)

[20:09] <jnthn> Arguably

[20:10] <pmichaud> > sub xyz(|$c) { };  say &xyz.signature.params[0].positional

[20:10] <pmichaud> False

[20:10] <jnthn> (The reason there's something to argue mostly being because of its snapshotting semantics.)

[20:11] <pmichaud> spectesting

[20:13] <moritz> pmichaud: is &xyz.count still Inf?

[20:17] <pmichaud> > say &xyz.count

[20:17] <pmichaud> Inf

[20:18] <dalek> rakudo/nom: 3e00089 | pmichaud++ | src/core/Parameter.pm:

[20:18] <dalek> rakudo/nom: Fix .positional for capture parameters in signatures.  masak++

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3e00089519

[20:18] <dalek> roast: 7a77ff8 | pmichaud++ | S06-signature/introspection.t:

[20:18] <dalek> roast: [S06]:  Add tests for capture parameter introspection of .positional, .named, etc.

[20:18] <dalek> roast: review: https://github.com/perl6/roast/commit/7a77ff860b

[20:20] *** bruges left
[20:26] *** kcwu left
[20:27] <masak> lol I bloggied! http://strangelyconsistent.org/blog/july-7-saving-and-restoring

[20:27] <masak> I again invite people to break the game in ways I didn't predict.

[20:37] *** seldon joined
[20:38] <tadzik> _sri: yeah, this sucks a bit but it's the only way I know of

[20:38] <tadzik> there's also Select PMC in Parrot, and IO::Select is a wrapper around that, but it behaved a bit weird to me last time I tried it

[20:38] <_sri> tadzik: *a bit* is quite an understatement ;p

[20:42] <tadzik> :)

[20:42] <tadzik> I was secretly hoping that it'd work fine for you

[20:42] <tadzik> I wrote tests for it, but it was a bit like "hmm, what makes sense _and_ works..."

[20:44] <tadzik> not sure if I ever succeeded on the first part

[20:44] <tadzik> I have some free time in the upcoming days, maybe I could write some poll/epoll on parrot/nqp level which isn't completely stupid

[20:51] <dalek> nqp: 8062b32 | pmichaud++ | src/QRegex/Cursor.nqp:

[20:51] <dalek> nqp: [qregex] Add !cursor_more, a preliminary method for handling :g, :ov, :ex.

[20:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8062b3239a

[20:51] <dalek> nqp: 052b7a1 | pmichaud++ | src/pmc/qrpa.pmc:

[20:51] <dalek> nqp: [qrpa]  Fix exception message for shift from empty array (jnthn++).

[20:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/052b7a17c9

[21:04] *** birdwindupbird left
[21:11] *** tyatpi left
[21:19] *** kaare_ left
[21:22] <masak> good night, #perl6

[21:23] *** ponbiki joined
[21:23] *** ponbiki is now known as Guest77817

[21:29] *** zby_home_ left
[21:37] *** mucker left
[21:39] *** MayDaniel left
[21:41] *** samlt joined
[22:03] <sorear> how much interest is there in getting github issues on dalek?

[22:04] <diakopter> the command to close an issue could be 'exterminate'

[22:11] <sergot>  good night o/ 

[22:11] *** sergot left
[22:13] <pmichaud> github issues on dalek  +1

[22:17] <jnthn> 'night, #perl6

[22:21] <seldon> Are the d, e, f, l, r, s, t, w, x, and z methods of class IO part of the public API?

[22:25] <sorear> Yes

[22:28] <seldon> What do they do?

[22:29] <pmichaud> they're filetest operators

[22:29] <pmichaud> .d == is this file a directory

[22:29] <pmichaud> .e == does this file exist

[22:29] <seldon> Oh, I see.

[22:30] <pmichaud> it's what enables things like    "foo.txt".io ~~ :f     # true if foo.txt exists and is readable

[22:30] <pmichaud> see "Other things" in http://perlcabal.org/syn/S32/IO.html

[22:31] <dalek> nqp: 7995664 | pmichaud++ | src/ops/nqp.ops:

[22:31] <dalek> nqp: Clean up some gcc compiler warnings.

[22:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7995664736

[22:31] <dalek> nqp: eb7f09e | pmichaud++ | src/6model/ (4 files):

[22:31] <dalek> nqp: More compiler warning cleanups.

[22:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/eb7f09e0fb

[22:31] <dalek> nqp: 28f89ef | pmichaud++ | src/6model/base64.c:

[22:31] <dalek> nqp: More casting and code cleanup.

[22:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/28f89ef3ff

[22:35] <seldon> There they are. I didn't make the connection to member functions :o

[22:37] <seldon> I'm shamelessly lifting method signatures from IO.pm, btw. I hope that's okay.

[22:46] *** PacoAir left
[22:50] *** tyatpi joined
[22:51] *** bruges joined
[23:07] *** sudokode joined
[23:24] <diakopter> pmichaud: does nqp's --target=past still work? It tells me Could not find sub _dumper

[23:27] *** tyatpi left
[23:34] *** seldon left
[23:35] *** seldon joined
