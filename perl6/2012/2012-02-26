[00:03] <dalek> nqp/bs: 947ad8b | jnthn++ | src/6model/serialization.c:

[00:03] <dalek> nqp/bs: Improve error on unimplemented serialization object type to be more informative.

[00:03] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/947ad8b925

[00:03] <dalek> nqp/bs: cca9005 | jnthn++ | src/6model/serialization.c:

[00:03] <dalek> nqp/bs: Handling of Pointer PMC in serializer.

[00:03] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/cca9005f51

[00:03] <dalek> nqp/bs: 590d356 | jnthn++ | src/6model/serialization.c:

[00:03] <dalek> nqp/bs: Block GC while we serialize, to be on the safe side. Sadly, doesn't eliminate the serializer segfault Rakudo's CORE.setting now triggers...

[00:03] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/590d356892

[00:03] <dalek> nqp/bs: 75d8264 | jnthn++ | src/6model/reprs/P6opaque.c:

[00:03] <dalek> nqp/bs: Add a sanity check for missing serialize function in P6opaque.serialize.

[00:03] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/75d8264bed

[00:03] <dalek> nqp/bs: bf9f634 | jnthn++ | src/6model/reprs/P6bigint.c:

[00:03] <dalek> nqp/bs: Implement serialize/deserialize for P6bigint REPR.

[00:03] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/bf9f634b43

[00:04] <dalek> rakudo/bs: 3878d27 | jnthn++ | src/Perl6/World.pm:

[00:04] <dalek> rakudo/bs: Add static code ref marking; gets us a bit further with the serialization.

[00:04] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/3878d273de

[00:10] <jnthn> Enough for today...that gets things a decent nudge further, though :)

[00:11] <colomon> jnthn++

[00:12] <cognominal> jnthn++

[00:19] <lue> jnthn++ # I'm very interested in your memory-saving serialization efforts, jnthn :)

[00:23] *** bkolera joined
[00:24] <jnthn> Hopefully will have some numbers on how much of an improvement it is in the coming days. :)

[00:26] * jnthn goes for sleep &

[00:28] *** lue left
[00:29] *** Trashlord joined
[00:30] *** PacoAir left
[00:32] *** PZt joined
[00:38] *** snearch joined
[00:56] *** snearch left
[01:01] *** lue joined
[01:04] <colomon> anyone out there know where the specs are for run and qx?

[01:05] <TimToady> run is in S29-functions

[01:05] <colomon> TimToady++

[01:06] <TimToady> qx is S02:Adverbs_on_quotes

[01:13] <colomon> TimToady: why is run  run ( *$cmd, *@args, ... ) 

[01:13] <colomon> *$cmd?

[01:14] <sorear> *$cmd (NYI in niecza) means that the slurpy list is initialized, and $cmd ::= @slurpy.shift

[01:15] <sorear> it means that you can do run(@argv) and not fuss with separating off the command first

[01:15] <sorear> it could also be written run(*@argv)

[01:15] <colomon> sorear++

[01:16] *** preflex_ joined
[01:17] <colomon> how do I pass null to a C# function (from niecza)?

[01:17] <colomon> Str ?

[01:17] <colomon> (for type string)

[01:17] *** preflex left
[01:17] *** preflex_ is now known as preflex

[01:18] <sorear> colomon: (null str)

[01:23] * colomon has forgotten the nuances of calling CLR libraries from p6-niecza.

[01:49] <colomon> sorear: do you recall how to create a string[]?

[01:50] <colomon> I had it in one of my scripts at one point, but can't find it now....

[02:00] <colomon> Array...

[02:03] *** havenn left
[02:09] *** Chillance left
[02:12] *** NamelessTee left
[02:19] *** sisar joined
[02:19] *** ribayr left
[02:19] *** tokuhirom joined
[02:20] <sorear> colomon: it's usually easier to do that sort of marshalling at the C# level; look at Builtins.UnboxLoS

[02:21] *** thou joined
[02:25] *** seanstickle joined
[02:26] *** wolfman2000 joined
[02:27] *** ribayr joined
[02:27] *** ribayr left
[02:27] *** ribayr joined
[02:32] *** thou left
[02:42] * sorear now appears to be writing a mono profiler (sort of)

[02:46] *** ksi left
[02:52] *** havenn joined
[03:05] <sorear> yay, I have mono running my profiler

[03:07] *** dbr left
[03:15] <dalek> niecza: ef5fdf8 | sorear++ | tools/extheapshot.c:

[03:15] <dalek> niecza: Add a skeleton of a heap profiler extracted from Mono

[03:15] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ef5fdf837c

[03:22] *** orafu left
[03:22] *** orafu joined
[03:33] *** preflex_ joined
[03:34] *** preflex left
[03:34] *** preflex_ is now known as preflex

[03:38] *** havenn left
[03:40] *** havenn joined
[03:49] *** tokuhirom left
[03:52] *** Patterner left
[03:54] *** aindilis joined
[04:08] <dalek> niecza: 06138f0 | sorear++ | tools/extheapshot.c:

[04:08] <dalek> niecza: Add a crude ability to count objects per high-level type

[04:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/06138f0546

[04:08] <sorear> it seems that the most numerous objects during -C CORE execution are Matches (25522)

[04:09] <sorear> followed by Hash, Int, CallFrame, Str, Array, Num, Parameter, Signature, Block, Cursor, Method

[04:10] * etneg checks for niecza's official site

[04:11] <sorear> https://github.com/sorear/niecza

[04:12] * etneg waits for it to be moved to a niecza.com

[04:13] *** plobsing left
[04:13] <sorear> out of 193098 objects total, Match, Hash, Int, CallFrame, and Str account for 107754

[04:14] <sorear> it would probably be better if I had byte counts, but that accounting would be very hard

[04:14] <sorear> etneg: I'm not a commercial entity

[04:15] <etneg> well then niecza.org

[04:20] *** birdwindupbird joined
[04:30] *** noam joined
[04:31] <sisar> um, what is HTAAF ? #Google does not help. Though i got someting like "think of Camel introduction".

[04:31] <sisar> *HTAAOF

[04:32] *** Psyche^ joined
[04:32] *** Psyche^ is now known as Patterner

[04:33] *** noam_ left
[04:36] *** MayDaniel left
[04:39] <jlaire> sisar: have the appropriate amount of fun

[04:39] *** havenn left
[04:39] <sisar> jlaire: ah. thanks

[05:14] *** marmalade left
[05:39] <moritz> \o

[05:42] <sorear> o/ moritz 

[05:45] <moritz> <sorear> It's a workaround for the fact that some compilers implement is using .Str

[05:46] <moritz> erm, is() is *specced* to do a string comparison

[05:46] <sorear> oh

[05:46] <moritz> if tehre are "some compilers" that use different semantics, they are buggy :-)

[05:46] <sorear> for some reason I thought is() was specced to do ===

[05:46] <moritz> no

[05:46] <sorear> well, I'm glad I haven't "fixed" niecza yet!

[05:47] <moritz> but one could use   is_deeply to compare type objects

[05:49] *** zhangkaizhao joined
[05:53] *** lestrrat left
[05:53] *** lestrrat joined
[05:56] <[Coke]> "total",      4410,     6,  1974,   302,  6692, 23430

[05:57] <[Coke]> (pugs)

[05:57] <dalek> roast: e4b089d | coke++ | S (16 files):

[05:57] <dalek> roast: pugs fudges

[05:57] <dalek> roast: review: https://github.com/perl6/roast/commit/e4b089d897

[05:58] <dalek> Pugs.hs: abaccdf | coke++ | t/spectest.data:

[05:58] <dalek> Pugs.hs: run fudged tests

[05:58] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/abaccdf898

[05:59] <[Coke]> b: say 4410 / 20298

[05:59] <p6eval> b 1b7dd1: OUTPUT«0.217262784510789␤»

[05:59] <[Coke]> pugs at 21.73% if the big 2 don't move before the run later.

[06:01] <dalek> Pugs.hs: 76de685 | moritz++ | Pugs/ext/Test/lib/Test.pm:

[06:01] <dalek> Pugs.hs: untested implemented of eval_lives_ok

[06:01] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/76de685870

[06:01] <moritz> eeks, that broke stuff

[06:02] <dalek> Pugs.hs: 628adae | moritz++ | Pugs/ext/Test/lib/Test.pm:

[06:02] <dalek> Pugs.hs: fix syntax error

[06:02] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/628adae6e3

[06:05] <[Coke]> where is gist specced?

[06:07] <moritz> S29, S02

[06:07] <[Coke]> ah, and S32.

[06:11] *** seanstickle left
[06:14] *** birdwindupbird left
[06:14] <[Coke]> b: say ( 4410 + 658 ) / 20298 # increasingly hard to reach fruit.

[06:14] <p6eval> b 1b7dd1: OUTPUT«0.24967977140605␤»

[06:17] * sorear wonders if we need a one-letter alias for at least one maintained impl

[06:18] * geekosaur wonders if it would be (a) useful (b) too evil, to have "*"

[06:19] <moritz> geekosaur++ # that's the right mind set

[06:19] <moritz> sorear: I wouldn't object

[06:19] <lue> Has anyone else tried compiling the most recent nqp/bs?

[06:19] <moritz> lue: I'm pretty sure jnthn++ has

[06:20] <lue> Of course :) . I seem to be getting an error with an undeclared NEED_CONTINUATION (in serialization.c).

[06:21] <moritz> lue: oh, that means your parrot is too old

[06:22] <moritz> lue: in the development branches, we're not very good at keeping track of the parrot and nqp revisions we need

[06:22] <lue> That's... interesting. I *just* recompiled a new parrot (pulled at around the same time as nqp/bs and rakudo/bs). Lemme check... yep, up-to-date

[06:25] <moritz> lue: which parrot revision have you compiled?

[06:25] <lue> Oh, maybe I have something too new (nqp's tools/build/PARROT_REVISION say 4.0.0, I have 4.1.0)

[06:26] <moritz> you need at least RELEASE_4_1_0-11-something

[06:26] <dalek> roast: 1e33805 | coke++ | S (7 files):

[06:26] <dalek> roast: pugs unfudge for eval_lives_ok

[06:26] <dalek> roast: moritz++

[06:26] <dalek> roast: review: https://github.com/perl6/roast/commit/1e338051d6

[06:26] <moritz> huh, but I get the same error

[06:27] * moritz checks

[06:27] *** zhangkaizhao left
[06:28] *** zhangkaizhao joined
[06:28] <moritz> oh, maybe then the parrot is too new :(

[06:29] <lue> I'll try bumping down to 4.0.0 then

[06:29] <moritz> 4.1.0

[06:30] *** preflex left
[06:30] *** preflex_ joined
[06:31] <lue> Do you mean I should bump down to 4.1.0? (Or are you just listing your parrot version?)

[06:31] *** preflex_ is now known as preflex

[06:31] *** noam left
[06:31] *** noam joined
[06:36] <moritz> I spend all my days making meaningless lists of parrot versions. It's such fun!

[06:37] *** Oofbitau1 joined
[06:38] *** Oofbitau1 left
[06:47] * lue switching to RELEASE_4_1_0 (this'll take a while...)

[07:12] *** birdwindupbird joined
[07:12] <moritz> std: my ($a, $b) .= new

[07:12] <p6eval> std a540d4e: OUTPUT«ok 00:01 112m␤»

[07:16] *** kaare_ joined
[07:19] <moritz> std: :($a, $b:)

[07:19] <p6eval> std a540d4e: OUTPUT«ok 00:01 110m␤»

[07:21] *** birdwindupbird left
[07:22] <moritz> std: :($.)

[07:22] <p6eval> std a540d4e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse signature at /tmp/AXtxXcEwZz line 1:␤------> [32m<BOL>[33m⏏[31m:($.)[0m␤Couldn't find final ')'; gave up at /tmp/AXtxXcEwZz line 1:␤------> [32m:($[33m⏏[31m.)[0m␤    expecting any of:␤     constraint␤     param_sep␤     

[07:22] <p6eval> ..para…

[07:22] <moritz> std: :(:$.)

[07:22] <p6eval> std a540d4e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse signature at /tmp/VRRNIys7KO line 1:␤------> [32m<BOL>[33m⏏[31m:(:$.)[0m␤Couldn't find final ')'; gave up at /tmp/VRRNIys7KO line 1:␤------> [32m:(:$[33m⏏[31m.)[0m␤    expecting any of:␤   constraint␤     param_sep␤      pa…

[07:22] <moritz> nom: :($.)

[07:22] <p6eval> nom 4f0ed5: OUTPUT«===SORRY!===␤Unable to parse colonpair, couldn't find final ')' at line 2␤»

[07:23] <moritz> nom: sub (:$.) { }

[07:23] <p6eval> nom 4f0ed5: OUTPUT«===SORRY!===␤Missing block␤at /tmp/Kx6USJBMuU:1␤»

[07:23] <moritz> nom: sub ($.) { }

[07:23] <p6eval> nom 4f0ed5: OUTPUT«===SORRY!===␤Missing block␤at /tmp/SMW7SFBkRd:1␤»

[07:24] <moritz> I'm trying to trigger an error "Cannot declare $. parameter in signature without an accessor name" which I found in rakudo's Actions.pm

[07:25] <moritz> nom: sub ($.foo) { }

[07:25] <p6eval> nom 4f0ed5:  ( no output )

[07:25] <moritz> nom: sub (:$.foo) { }

[07:25] <p6eval> nom 4f0ed5:  ( no output )

[07:25] <moritz> but it seems the parser doesn't ever allow that error to trigger

[07:25] <moritz> or I'm not creative enough :-)

[07:26] <dalek> rakudo/nom: 9d39e88 | moritz++ | src/ (2 files):

[07:26] <dalek> rakudo/nom: X::Syntax::Signature::InvocantMarker

[07:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9d39e880e0

[07:29] <moritz> perl6: my @fib := 1, 1, *+* ... *; say @fib[10]

[07:29] <p6eval> rakudo 4f0ed5, niecza v14-72-gf99bd59: OUTPUT«89␤»

[07:29] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected " say"␤    at /tmp/t1aCiylEwn line 1, column 28␤»

[07:32] <geekosaur> nom: class Foo { method foo ($.) { } }

[07:32] <p6eval> nom 4f0ed5: OUTPUT«===SORRY!===␤Missing block␤at /tmp/3RhEVvfNF2:1␤»

[07:32] * geekosaur didn't think so, but what the heck

[07:32] <lue> nom: sub ($., $a) { say $a;}

[07:33] <p6eval> nom 4f0ed5: OUTPUT«===SORRY!===␤Missing block␤at /tmp/zd7brrjgrD:1␤»

[07:38] <lue> my guess is that the dot in $. is being handled by something else first (sub (($.)) { } generates a different error about missing right paren)

[07:48] *** birdwindupbird joined
[07:59] *** sisar left
[08:11] *** birdwindupbird left
[08:20] <dalek> niecza: 3d88c41 | sorear++ | tools/extheapshot.c:

[08:20] <dalek> niecza: Start on full implementation of blaming heap profiler

[08:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3d88c41989

[08:27] <colomon> sorear: how do I pass an @variable to a sub in Q:CgOp?  the sub is expecting a Variable...

[08:28] <sorear> {@variable}

[08:28] <colomon> sorear++

[08:33] <colomon> sorear: I've got run all hooked up using GLib.Process.SpawnSync (no fallback yet).  But it's failing when I try to execute "ls" using it: GLib.GException: Failed to execute child process "ls" (No such file or directory)

[08:34] <sorear> try using an absolute path

[08:34] <colomon> ooo, that at least gets me a different error

[08:35] <colomon> System.InvalidCastException: Cannot cast from source type to destination type.

[08:35] <sorear> pass --debug=casts to mono to get a slightly better error

[08:35] <colomon> I guess this may have something to do with my second question: how do I handle "out" parameters using Invoke?

[08:36] *** bkolera left
[08:36] <sorear> see WritebackRefs in NieczaCLR.cs

[08:36] <colomon> Unable to cast object of type 'System.Boolean' to type 'System.Int32'.

[08:36] <colomon> that error I understand.  :)

[08:40] <Teratogen> bah, it should cast it to a 0 or 1.

[08:40] <Teratogen> I never heard of anything so silly!

[08:44] <colomon> sorear: fixing the return value cast and using the absolute location of ls seems to make it work.   still trying to figure out how WritebackRefs works to get results from the ls command...

[08:50] *** Tedd1 joined
[08:50] <colomon> ooo, I think I've got it

[08:53] <colomon> boo-ya!

[08:55] <colomon> it's definitely working

[09:02] <colomon> gonna try to get back to sleep now, and clean it up in the morning.

[09:02] <colomon> sorear++

[09:13] *** isBEKaml joined
[09:14] <isBEKaml> [Coke]++ # pugs!

[09:15] <isBEKaml> moritz++ and masak++ too 

[09:16] *** noam_ joined
[09:20] *** noam left
[09:22] <isBEKaml> hackage down? I'm trying to build latest pugs, but it's stuck on cabal update while retrieving package list from hackage. :(

[09:23] <dalek> niecza: aaedd91 | sorear++ | tools/extheapshot.c:

[09:23] <dalek> niecza: Finish the basic mechanism for the new profiler; needs more description functions

[09:23] <dalek> niecza: review: https://github.com/sorear/niecza/commit/aaedd915fe

[09:23] *** noam__ joined
[09:27] *** noam_ left
[09:30] *** noam_ joined
[09:33] *** kaare__ joined
[09:33] *** kaare_ left
[09:33] <dalek> niecza: 05fa915 | sorear++ | lib/Cursor.cs:

[09:33] <dalek> niecza: Fix retention of call frames by way of unneeded LTM construction lists

[09:33] <dalek> niecza: review: https://github.com/sorear/niecza/commit/05fa915fc6

[09:34] *** noam__ left
[09:38] <sorear> memory usage is down to 150m for the setting, from ~250m at the beginning of the week

[09:38] <moritz> \o/

[09:40] <sorear> I'll probably have to release mostly as is

[09:43] *** NamelessTee joined
[09:46] *** tokuhirom joined
[09:50] *** packetknife joined
[10:00] <sorear> STD.pm6 is *almost* back under a minute, and uses well under 200m

[10:00] * sorear -> sleep

[10:01] *** packetknife left
[10:10] *** xinming_ left
[10:16] *** sisar joined
[10:16] *** am0c joined
[10:17] <fsergot> o/

[10:18] <sisar> hi !

[10:18] <cognominal> nom:  sub t($/) { say $/.^name }; t(1)

[10:18] <p6eval> nom 9d39e8: OUTPUT«Int␤»

[10:19] *** birdwindupbird joined
[10:19] <cognominal> should not the parameter $/ be contrained to be a Match?

[10:19] <sisar> perl6: my $a = 'd'; say $a +4;

[10:19] <p6eval> pugs b927740, rakudo 9d39e8: OUTPUT«4␤»

[10:19] <p6eval> ..niecza v14-77-g05fa915: OUTPUT«Unhandled exception: Cannot parse number: d␤  at /home/p6eval/niecza/lib/CORE.setting line 1360 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3398 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3400 (NumSyntax.str2num @ 4) ␤  at /h…

[10:19] <cognominal> *constrained.

[10:20] <sisar> wth. can someone explain ? ^^

[10:21] <cognominal> 'd'  cannot be converted to a number

[10:22] <geekosaur> I think the real question is why did rakudo take it as 0 instead of complaining

[10:22] <sisar> cognomonal: what about rakudo & pugs ?

[10:22] <geekosaur> (seems to me niecza is right.  pugs is just old, per usual...)

[10:22] <sisar> geekosaur: yep !

[10:23] <geekosaur> sisar, pugs has not been updated beyond being able to build it, it still follows some rules that no longer apply

[10:25] <geekosaur> rakudo ought to know better but may be doing something strange in terms of numeric parsing.

[10:25] <isBEKaml> buubot_backup: eval print 'd' + 4;

[10:25] <buubot_backup> isBEKaml: 41

[10:25] <geekosaur> rakudo: my $a = 'g'; say $a + 4;

[10:25] <p6eval> rakudo 9d39e8: OUTPUT«4␤»

[10:25] <geekosaur> hm, ok, first idea out the window

[10:26] <geekosaur> rakudo: my $a = 'duh'; say $a + 4;

[10:26] <p6eval> rakudo 9d39e8: OUTPUT«4␤»

[10:26] <geekosaur> that be b0rked

[10:26] *** dukeleto left
[10:27] *** dukeleto joined
[10:27] <isBEKaml> b: my $foo='h'; say 4 + $foo;

[10:27] <p6eval> b 1b7dd1: OUTPUT«4␤»

[10:27] <isBEKaml> hmm, that was always like this? 

[10:28] <isBEKaml> b: my $foo = 'd'; +$foo.say;

[10:28] <p6eval> b 1b7dd1: OUTPUT«d␤»

[10:28] <isBEKaml> niecza: my $foo = 'd'; +$foo.say;

[10:28] <p6eval> niecza v14-77-g05fa915: OUTPUT«d␤»

[10:29] <isBEKaml> Am I misremembering something now or isn't +$x numifying anymore?

[10:29] <isBEKaml> perl6: my $foo='foobarbaz'; say +$foo;

[10:30] <p6eval> niecza v14-77-g05fa915: OUTPUT«Unhandled exception: Cannot parse number: foobarbaz␤  at /home/p6eval/niecza/lib/CORE.setting line 1360 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3398 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3400 (NumSyntax.str2num @ 4) …

[10:30] <p6eval> ..pugs b927740, rakudo 9d39e8: OUTPUT«0␤»

[10:30] <isBEKaml> perl6: my $foo='f'; say +$foo;

[10:30] <p6eval> niecza v14-77-g05fa915: OUTPUT«Unhandled exception: Cannot parse number: f␤  at /home/p6eval/niecza/lib/CORE.setting line 1360 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3398 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3400 (NumSyntax.str2num @ 4) ␤  at /h…

[10:30] <p6eval> ..pugs b927740, rakudo 9d39e8: OUTPUT«0␤»

[10:30] <isBEKaml> that's more like it. 

[10:33] <sisar> what is +$var supposed to do ?

[10:34] <fsergot> nom: say +'1';

[10:34] <p6eval> nom 9d39e8: OUTPUT«1␤»

[10:34] <fsergot> It changes to Int

[10:34] <fsergot> nom: say +'1'.WHAT;

[10:34] <p6eval> nom 9d39e8: OUTPUT«use of uninitialized value of type Str in numeric context␤0␤»

[10:35] <fsergot> nom: say (+'1').WHAT;

[10:35] <p6eval> nom 9d39e8: OUTPUT«Int()␤»

[10:35] <fsergot> sisar: :)

[10:36] <isBEKaml> sisar: it converts the var to numeric form. like a .Int 

[10:37] <isBEKaml> perl6: my $limit="4"; for 0..^ +$limit { say "a" }

[10:37] <p6eval> pugs b927740, rakudo 9d39e8, niecza v14-77-g05fa915: OUTPUT«a␤a␤a␤a␤»

[10:37] <sisar> ok, so +'f' should give zero (like rakudo) or error (like niecza) ? or maybe f's ASCII value or something?

[10:38] <fsergot> nom: say (+'1.1').WHAT;

[10:38] <p6eval> nom 9d39e8: OUTPUT«Rat()␤»

[10:38] <isBEKaml> sisar: I'm leaning towards niecza. If you're thinking like Java, that's a NumberFormatException. :)

[10:39] <sisar> isBEKaml: thats allright, but what do the specs have to say about it?

[10:40] <isBEKaml> sisar: can't say for sure. The best I could pick up is S03:618

[10:40] <isBEKaml> perl6: +Int.say; # undefined behaviour?

[10:40] <p6eval> pugs b927740: OUTPUT«Int␤»

[10:40] <p6eval> ..rakudo 9d39e8, niecza v14-77-g05fa915: OUTPUT«Int()␤»

[10:42] <isBEKaml> sisar: now that I read it again, it seems to be saying that the return value should be the least value of a number. In that case, rakudo and pugs would be right. 

[10:44] <sisar> isBEKaml: did you interpret "the narrowest appropriate type"(S03:618) to mean "should be the least value of a number" ?

[10:45] <isBEKaml> sisar: yes - in the scenario of a var not being a number. 

[10:45] <fsergot> perl6: say (+'f2').WHAT;

[10:45] <p6eval> niecza v14-77-g05fa915: OUTPUT«Unhandled exception: Cannot parse number: f2␤  at /home/p6eval/niecza/lib/CORE.setting line 1360 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3398 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3400 (NumSyntax.str2num @ 4) ␤  at /…

[10:45] <p6eval> ..pugs b927740: OUTPUT«Num␤»

[10:45] <p6eval> ..rakudo 9d39e8: OUTPUT«Int()␤»

[10:46] <isBEKaml> perl6: say (+'e42').WHAT

[10:46] <p6eval> niecza v14-77-g05fa915: OUTPUT«Unhandled exception: Cannot parse number: e42␤  at /home/p6eval/niecza/lib/CORE.setting line 1360 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3398 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3400 (NumSyntax.str2num @ 4) ␤  at …

[10:46] <p6eval> ..pugs b927740: OUTPUT«Num␤»

[10:46] <p6eval> ..rakudo 9d39e8: OUTPUT«Int()␤»

[10:47] <isBEKaml> perl6: say (+'1.5e42').WHAT

[10:47] <p6eval> rakudo 9d39e8, niecza v14-77-g05fa915: OUTPUT«Num()␤»

[10:47] <p6eval> ..pugs b927740: OUTPUT«Num␤»

[10:47] <sisar> isBEKaml: i think it is not clear at all what is meant by "narrowest .. ". Lets wait for TimToady, or someone who knows better to clear this up

[10:50] *** snearch joined
[10:51] <isBEKaml> sisar: I'm no expert, but I'm thinking of numeric types as containers for bounded numeric values. The narrowest appropriate scope would then be the least bound of the numeric scope applicable. 

[10:51] *** bacek left
[10:52] <isBEKaml> sisar: In the case above where '+e42' yielded an Int(), while '+1.5e42' yielded a Num, what I said above seems to hold. 

[10:52] <sisar> isBEKaml: maybe yes, maybe no. #reluctant to agree, yet :)

[10:53] <sisar> back to my original problem, if $x = <someAlphabet>, and i want to increase $x by 2, i.e. 'a' goes to 'c' , how would i do that ?

[10:53] <isBEKaml> just be aware that this would fail when you're talking about Complex, unordered. 

[10:55] <jnthn> mornin'

[10:55] <isBEKaml> jnthn! \o/ 

[10:55] <isBEKaml> nom: 'aa'.succ.say;

[10:55] <p6eval> nom 9d39e8: OUTPUT«ab␤»

[10:55] <isBEKaml> nom: 'a'.succ.say;

[10:55] <p6eval> nom 9d39e8: OUTPUT«b␤»

[10:55] <isBEKaml> sisar: ^^

[10:56] <sisar> isBekaml: thanks :)

[10:58] <isBEKaml> nom: my @foo=<a b c d>; @foo.map { .succ }.gist.say;

[10:59] <p6eval> nom 9d39e8: OUTPUT«===SORRY!===␤Confused␤at /tmp/LKZ1zHzOpF:1␤»

[10:59] <isBEKaml> nom: my @foo=<a b c d>; say @foo.map { .succ }

[10:59] <p6eval> nom 9d39e8: OUTPUT«===SORRY!===␤Confused␤at /tmp/38apvdD6dT:1␤»

[11:01] * isBEKaml grumbles about nommap...

[11:02] <jnthn> nom: my @foo=<a b c d>; say @foo.map: { .succ }

[11:02] <p6eval> nom 9d39e8: OUTPUT«b c d e␤»

[11:02] <isBEKaml> nom: my @foo=<a b c d>; say @foo>>.succ;

[11:02] <p6eval> nom 9d39e8: OUTPUT«b c d e␤»

[11:02] <jnthn> Nothing to do with map - you need a colon if you're using that syntax for a method call.

[11:02] <jnthn> (general syntax rules)

[11:03] <isBEKaml> jnthn: Ah, I see.. generally, can I say that ": { ... }" would need a callable block in its signature?

[11:03] <isBEKaml> jnthn: for future help, how do I ask the compiler to give me the method signature for any function/multi?

[11:03] <jnthn> isBEKaml: No, it's actually just another way to write the argument list

[11:04] <jnthn> $foo.meth(arg1, arg2) can also be $foo.meth: arg1, arg2

[11:05] <jnthn> nom: Array.^find_method('map').signature.perl.say

[11:05] <p6eval> nom 9d39e8: OUTPUT«:(Any , Any $block, Mu %_!)␤»

[11:05] <jnthn> nom: Array.^find_method('grep').signature.perl.say

[11:05] <p6eval> nom 9d39e8: OUTPUT«:(Any , Mu $test, Mu %_!)␤»

[11:06] <jnthn> etc.

[11:06] <isBEKaml> jnthn: Gee, thanks! Though it doesn't say which params are optional or implicit, I sure hope you'd be including that in the Metamodel as well!

[11:06] <jnthn> It's...getting that last one really wrong. :/

[11:06] <jnthn> Should be *%_

[11:07] *** bacek joined
[11:07] <jnthn> nom: class A { method foo($a, $b?) { } }; A.^find_method('foo').signature.perl.say

[11:07] <p6eval> nom 9d39e8: OUTPUT«:(A , Any $a, Any $b?, Mu %_!)␤»

[11:07] <isBEKaml> jnthn: just what I meant. I kind of figured that %_ are implicit.. 

[11:07] <jnthn> Yeah, it should be tagged slurpy, not required. :/

[11:08] <jnthn> I mean, I'm guessing it actually is set up that way.

[11:08] <jnthn> It's just Signature.perl doing something silly

[11:08] <isBEKaml> nom: class A { method foo($a, $b?) { } }; A.^find_method('foo').signature.say

[11:08] <p6eval> nom 9d39e8: OUTPUT«:(A , Any $a, Any $b?, Mu %_!)␤»

[11:08] <jnthn> It's correct until the final parameter.

[11:09] <isBEKaml> yes

[11:09] <isBEKaml> does .say .perl too?

[11:09] <isBEKaml> ^^ Signatures

[11:09] <jnthn> Looks like Signature.gist delegates to .perl or something.

[11:09] <jnthn> Which seems reasonable.

[11:11] *** Trashlord left
[11:12] <isBEKaml> jnthn: Where Mu comes in, is that something meant for discarding more params than defined signature? # I think not... 

[11:13] <isBEKaml> nom: class A { method foo($a, $b, $c?) { say $a, $b; }; }; my $ff = A.new; $ff.foo(23,42,45 89238);

[11:13] <p6eval> nom 9d39e8: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2␤»

[11:13] <jnthn> It's kinda meaningless on a slurpy.

[11:14] <jnthn> Missing...either a comma or a . there

[11:14] <tadzik> good morning

[11:14] <isBEKaml> nom: class A { method foo($a, $b, $c?) { say $a, $b; }; }; my $ff = A.new; $ff.foo(23,42,45,89238);

[11:14] <p6eval> nom 9d39e8: OUTPUT«Too many positional parameters passed; got 5 but expected between 3 and 4␤  in method foo at /tmp/1LsXPOzcaG:1␤  in block <anon> at /tmp/1LsXPOzcaG:1␤␤»

[11:15] <isBEKaml> nom++ #params no more than what's defined. 

[11:15] <jnthn> tadzik: Morning finished only 14 minutes ago! Good going!

[11:15] <isBEKaml> tadzik: o/

[11:15] <tadzik> jnthn: better than usual :)

[11:15] <jnthn> tadzik: Aye. :)

[11:25] *** Trashlord joined
[11:34] *** sisar left
[11:37] *** isBEKaml left
[11:43] *** ascent_ joined
[11:44] *** ascent_ left
[11:55] *** birdwind1pbird joined
[12:05] *** isBEKaml joined
[12:10] *** mj41 left
[12:11] *** isBEKaml left
[12:12] <dalek> nqp/bs: 600a772 | jnthn++ | src/pmc/nqplexinfo.pmc:

[12:12] <dalek> nqp/bs: Make sure we don't lose the static_code reference over the PBC boundary.

[12:12] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/600a7720d6

[12:12] <dalek> rakudo/bs: 5bc64cc | jnthn++ | src/pmc/perl6lexinfo.pmc:

[12:12] <dalek> rakudo/bs: Update Perl6LexInfo to save static_code ref over the PBC boundary also.

[12:12] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/5bc64ccdf4

[12:24] *** seanstickle joined
[12:26] *** jack123 joined
[12:26] *** lateau__ joined
[12:30] *** jack123 left
[12:31] *** Chillance joined
[12:42] *** noam_ left
[12:45] *** noam_ joined
[12:46] *** lateau__ left
[13:04] *** ggoebel joined
[13:19] *** birdwind1pbird left
[13:36] *** am0c left
[13:39] *** sisar joined
[13:40] *** whiteknight joined
[13:45] *** birdwindupbird left
[13:47] *** mj41 joined
[14:01] <masak> good postnoon, #perl6.

[14:03] <fsergot> masak \o/

[14:04] <masak> \o/

[14:05] <fsergot> perl6: sub infix:<I>(@a, @b){ my @r gather for @a { take $_ when any(@b) & !any(@r);}} say <a b c d> I <a h j>;

[14:05] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "gather"␤    expecting "?", "!", trait, "=", infix assignment, operator or "}"␤    at /tmp/M9nmWyZwb3 line 1, column 30␤»

[14:05] <p6eval> ..niecza v14-77-g05fa915: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row at /tmp/PQ_9bTe6EB line 1:␤------> [32msub infix:<I>(@a, @b){ my @r [33m⏏[31mgather for @a { take $_ when any(@b) & ![0m␤␤Parse failed␤␤»

[14:05] <p6eval> ..rakudo 9d39e8: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[14:06] <fsergot> eh

[14:06] *** mj41 left
[14:06] <fsergot> perl6: sub infix:<I>(@a, @b){ my @r = gather for @a { take $_ when any(@b) & !any(@r);}} say <a b c d> I <a h j>;

[14:06] <p6eval> niecza v14-77-g05fa915: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/ZLd9CWuUg2 line 1:␤------> [32m @a { take $_ when any(@b) & !any(@r);}}[33m⏏[31m say <a b c d> I <a h j>;[0m␤␤Parse failed␤␤»

[14:06] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "@r"␤    expecting "=", operator, ":", ",", "}", context or "("␤    at /tmp/xzqjrfJMUR line 1, column 27␤»

[14:06] <p6eval> ..rakudo 9d39e8: OUTPUT«===SORRY!===␤Confused␤at /tmp/IVtq4NVqPB:1␤»

[14:06] <fsergot> perl6: sub infix:<I>(@a, @b){ my @r = gather for @a { take $_ when any(@b) & !any(@r);}}; say <a b c d> I <a h j>;

[14:06] <fsergot> sorry

[14:06] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "@r"␤    expecting "=", operator, ":", ",", "}", context or "("␤    at /tmp/tmlCeOMFxh line 1, column 27␤»

[14:06] <p6eval> ..rakudo 9d39e8, niecza v14-77-g05fa915: OUTPUT«a␤»

[14:07] <fsergot> nom: sub infix:<I>(@a, @b){ my @r = gather for @a { take $_ when any(@b) & !any(@r);}}; say <a b c d> I <a h j c>;

[14:07] <p6eval> nom 9d39e8: OUTPUT«a c␤»

[14:07] <fsergot> Is there a built-in functions which returns intersection of 2 arrays?

[14:08] <fsergot> function*

[14:10] <masak> there's the set intersection function/method.

[14:12] <masak> https://github.com/sorear/niecza/blob/master/lib/CORE.setting#L2057

[14:14] <fsergot> \o/ :)

[14:16] <masak> I didn't find any word methods for those. maybe that's too much repetition to have all three of unicode ops, texas ops, and word methods?

[14:16] <masak> .intersection, .union, etc.

[14:24] <fsergot> How easily to convert char to hex representation? :)

[14:25] <fsergot> nom: 'A'.ord.base(16).say;

[14:25] <p6eval> nom 9d39e8: OUTPUT«41␤»

[14:25] <fsergot> ?

[14:25] <fsergot> :)

[14:26] <jnthn> Think that's probably the easiest way :)

[14:27] *** ascrazy joined
[14:27] *** xinming joined
[14:35] *** Chillance left
[14:35] *** xinming left
[14:35] *** Chillance joined
[14:42] *** seanstickle left
[14:43] <fsergot> Error which is showed when We start nom with file that doesn't exist as argument is quite strange, isn't it?

[14:44] <fsergot> Only the first line of whole error msg is needed.

[14:44] <fsergot> :)

[14:45] <fsergot> s/start/run/ :)

[14:46] <jnthn> Then patch it. :)

[14:46] <jnthn> The backtrace is indeed useless there.

[14:47] <jnthn> Or if you're not sure how to patch it, ticket it. :)

[14:47] <fsergot> jnthn, could You help me? :)

[14:47] <jnthn> It'll likely be somewhere in HLL::Compiler

[14:47] <jnthn> In the NQP repo

[14:47] <fsergot> jnthn++ thanks

[14:48] <jnthn> fsergot: Line 404, in evalfiles

[14:48] <jnthn> oh, that's in my branch, may be a tad off

[14:49] <jnthn> Anyway, the die there is what results in the backtrace

[14:49] <colomon> niecza: say Mu.WHAT === Mu.WHAT

[14:49] <p6eval> niecza v14-77-g05fa915: OUTPUT«Unhandled exception: Nominal type check failed in binding '$l' in 'infix:<===>'; got Mu, needed Any␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (infix:<===> @ 1) ␤  at /tmp/1saETMLb0u line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting li…

[14:49] <cognominal> nom: say Match ~~ Match:U

[14:49] <p6eval> nom 9d39e8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Match:U' called (line 1)␤»

[14:49] <colomon> niecza: say Any.WHAT === Any.WHAT

[14:49] <p6eval> niecza v14-77-g05fa915: OUTPUT«True␤»

[14:50] <cognominal> I suppoose :U and :D should work outside signature. Not sure if they are regular adverbs (which are not implemented)

[14:51] <jnthn> fsergot: If you can change it to print to stderr and then exit with code 1 or so I guess that works.

[14:51] *** noam__ joined
[14:51] <jnthn> cognominal: That would imply that they have a first-class representation.

[14:51] *** noam__ left
[14:51] <fsergot> jnthn: Ok, I'll. :) Now I'm looking for evalfiles :)

[14:51] <jnthn> cognominal: Which isn't the case just yet.

[14:51] *** noam__ joined
[14:52] <jnthn> fsergot: OK. Note, nqp repository :)

[14:52] *** noam__ left
[14:52] <cognominal> jnthn: what do you mean by "they"?

[14:52] <fsergot> jnthn: found in src/HLL/Compiler.pm \o/

[14:52] *** noam joined
[14:53] <jnthn> cognominal: Foo:D and Foo::U

[14:53] <jnthn> er

[14:53] <jnthn> Foo:U

[14:53] <cognominal> adverbs are pairs, aren't they

[14:53] <jnthn> cognominal: Yes but they have to be given semantics on order to mean anything.

[14:53] *** noam_ left
[14:54] <cognominal> yes

[14:54] <jnthn> cognominal: At the moment the only thing that does that is the signature handling.

[14:54] <cognominal> yes, that's my point :)

[14:54] <colomon> niecza: say Mu.WHAT.gist === My.WHAT.gist

[14:54] <p6eval> niecza v14-77-g05fa915: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'My' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /home/p6e…

[14:55] <colomon> niecza: say Mu.WHAT.gist === Mu.WHAT.gist

[14:55] <p6eval> niecza v14-77-g05fa915: OUTPUT«True␤»

[14:55] <jnthn> cognominal: I suspect they should work "first class".

[14:55] <jnthn> cognominal: Didn't work out exactly how to factor it yet.

[14:55] *** am0c joined
[14:55] <cognominal> that's what S12:1593 implies

[14:58] <fsergot> jnthn: If I change something in nqp on my machine, I'll have to recompile the whole rakudo?

[14:58] <jnthn> fsergot: yes

[14:58] <jnthn> fsergot: Though you can test your chagne in nqp repo first

[14:58] <jnthn> fsergot: Since if you do nqp something-that-does-not-exist 

[14:58] <jnthn> then it should not have the backtrce

[14:59] <fsergot> jnthn++: thank You. :)

[15:02] <jnthn> Thanks for working on the fix :)

[15:03] *** PacoAir joined
[15:08] <dalek> nqp/bs: 9acb660 | jnthn++ | src/6model/serialization.c:

[15:08] <dalek> nqp/bs: Improved diagnostics for Parrot Object types sneaking into places that need serialization.

[15:08] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/9acb660b0a

[15:08] <dalek> nqp/bs: 5fb6da3 | jnthn++ | src/6model/serialization.c:

[15:08] <dalek> nqp/bs: Look for COMPILER_STUB marker and, if seen, don't serialize outer.

[15:08] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5fb6da3527

[15:08] <dalek> rakudo/bs: 5fb6c0b | jnthn++ | src/Perl6/ (2 files):

[15:08] <dalek> rakudo/bs: Tag compile-time stubs so we don't try and serialize their outer (which is the create_code_object method in World).

[15:08] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/5fb6c0bfd3

[15:10] *** tokuhirom left
[15:10] *** noam_ joined
[15:13] *** noam left
[15:23] <dalek> nqp/bs: efcb770 | jnthn++ | src/6model/serialization.c:

[15:23] <dalek> nqp/bs: Skip over any CallContext we encounter - future Rakudo refactors will avoid the need for this hack in the long run. And...tada! We successfully serialize CORE.setting, producing 1393664 bytes of serialized data with 10578 strings in the string heap. Sadly, we then explode in the optimizer...

[15:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/efcb770d46

[15:23] <dalek> rakudo/bs: d3bd66a | jnthn++ | src/Perl6/Actions.pm:

[15:23] <dalek> rakudo/bs: Fix a pirop signature (nothing to do with this branch, just spotted it).

[15:23] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/d3bd66a40f

[15:23] <masak> jnthn++!

[15:24] <jnthn> No word on if it deserializes again yet, mind ;)

[15:24] <masak> psshf, details ;)

[15:24] <jnthn> Though those kinds of issues have been very rare.

[15:24] *** mj41 joined
[15:25] <jnthn> Well, more fun coming yet but...time for a walk. bbiab

[15:28] <masak> yay, more fun!

[15:30] *** am0c left
[15:31] *** sisar left
[15:32] <tadzik> woot

[15:32] *** lateau__ joined
[15:32] <tadzik> that is awesome :)

[15:35] *** sisar joined
[15:37] *** Jerkwad joined
[15:37] *** thou joined
[15:47] *** Patterner left
[15:49] *** Psyche^ joined
[15:49] *** Psyche^ is now known as Patterner

[16:06] <dalek> roast: 6728253 | (Solomon Foster)++ | S09-subscript/slice.t:

[16:06] <dalek> roast: Fix typo that slipped in somehow.

[16:06] <dalek> roast: review: https://github.com/perl6/roast/commit/6728253901

[16:08] <masak> perl6: my @a of Int; push @a, "OH HAI"; say @a.perl

[16:08] <p6eval> niecza v14-77-g05fa915: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Trait of not available on variables at /tmp/rT_DSgHQWQ line 1:␤------> [32mmy @a of Int[33m⏏[31m; push @a, "OH HAI"; say @a.perl[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line …

[16:08] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "of"␤    expecting "?", "!", trait, "=", infix assignment or operator␤    at /tmp/xQ0jWLEruO line 1, column 7␤»

[16:08] <p6eval> ..rakudo 9d39e8: OUTPUT«Array.new("OH HAI")␤»

[16:10] *** libreofficer joined
[16:14] <libreofficer> Hello! Can I get some info about gsoc? I use perl not so long time, but I want to join in and help perl6. Is there some simple tasks to try it?

[16:15] <masak> libreofficer: hi! welcome!

[16:16] <masak> we do have a list somewhere...

[16:16] <tadzik> hello libreofficer 

[16:17] <jnthn> http://wiki.enlightenedperl.org/gsoc2012/ideas

[16:18] <libreofficer> Thanks! I read http://wiki.enlightenedperl.org/gsoc2012/ideas and I think writing "custom sprintf" will be simple enough. But I want to write some simplest things for start

[16:18] <jnthn> Though I need to update that optimisation task...

[16:18] <libreofficer> jnthn, yes, I'd read it

[16:18] <jnthn> libreofficer: Yeah, much of that work got done. There's still LOADS of options in the area of optimization, however.

[16:20] * tadzik ponders a thought about a full-blown web framework as a gsoc task

[16:20] *** fsergot left
[16:20] <jnthn> tadzik: Could be fun.

[16:21] <jnthn> tadzik: An NFG strings implementation - if you feel like some guts-y stuff - could also be an interesting project.

[16:21] <tadzik> New Found Glory is an American rock band from Coral Springs, Florida.

[16:21] <jnthn> :

[16:21] <jnthn> :D

[16:21] <tadzik> NFG strings?

[16:22] <tadzik> :)

[16:22] * tadzik reads http://www.parrot.org/content/what-nfg-why-you-want-parrot-have-it

[16:23] <jnthn> tadzik: There's some bits in S02

[16:23] *** pmurias joined
[16:23] <libreofficer> so, could I find some TODOs anywere?

[16:23] <jnthn> libreofficer: I can think of a few ways in. (more)

[16:24] <jnthn> libreofficer: One easy way to get started is writing tests. We have a bunch of fixed bugs that are lacking tests in the spectest suite.

[16:25] <jnthn> libreofficer: Then there's attempting to fix stuff, but that can vary from not so had to "ouch, my brain"

[16:25] <dalek> niecza: 09d5111 | (Paweł Murias)++ | perl5/Niecza/.gitignore:

[16:25] <dalek> niecza: Add a .gitignore for all the Niecza.pm build process byproducts.

[16:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/09d511142e

[16:25] <dalek> niecza: a9d984a | (Paweł Murias)++ | / (8 files):

[16:25] <dalek> niecza: make perl5 now always rebuilds Niecza.pm.

[16:25] <dalek> niecza: Added Niecza::create_LoS which creates a Perl6 list of string from p5

[16:25] <dalek> niecza: land.

[16:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a9d984a684

[16:25] <jnthn> libreofficer: If you're interested in adding features to Rakudo then we have a ROADMAP in docs/ROADMAP

[16:26] <jnthn> libreofficer: Each item is marked with how much effort is involved.

[16:27] <jnthn> libreofficer: Though many will need a little asking around here for tips. :)

[16:27] <libreofficer> I see

[16:28] <jnthn> libreofficer: Some things just need writing Perl 6 code, others need compiler skills (this isn't always hard), occasionally you may need to write some C stuff, but that's not all that common.

[16:28] <masak> https://github.com/rakudo/rakudo/blob/nom/docs/ROADMAP

[16:28] <flussence> is Str.indent in nom yet? That should be a really easy one, I've got working code but I procrastinate too much to get it in :)

[16:29] <jnthn> flussence: Don't believe it is in yet. :)

[16:30] <masak> nom: my @foo of Int = "OH HAI"; say "alive"

[16:30] <p6eval> nom 9d39e8: OUTPUT«alive␤»

[16:30] <jnthn> masak: Known.

[16:30] <jnthn> masak: The usual "variable traits NYI" thingy.

[16:30] <jnthn> nom: my Int @foo; @foo[0] = "OH HAI"

[16:30] <p6eval> nom 9d39e8: OUTPUT«Type check failed in assignment to '$v'; expected 'Int' but got 'Str'␤  in block <anon> at /tmp/EXXAfym0UN:1␤␤»

[16:31] <flussence> hm, it's bitrotted quite a bit since it's still using as-coercion syntax... but it's a start: https://github.com/flussence/p6-misc/blob/master/lib/Indent.pm

[16:32] <jnthn> flussence: Rakudo still uses the "as" coercion syntax anyway :)

[16:32] <masak> nom: my Int @foo; push @foo, "OH HAI"; say "alive"

[16:32] <p6eval> nom 9d39e8: OUTPUT«alive␤»

[16:32] <libreofficer> C does not scared me, I'd wrote on it. But I don't know arch of Racudo yet

[16:32] <tadzik> so what's then new '$foo as Int'?

[16:33] * masak never used '$foo as Int'

[16:33] <masak> but 'my Int @foo' is really old.

[16:33] <jnthn> Int() $foo

[16:33] <tadzik> odd

[16:34] <jnthn> It's meant to remind you of the coercion syntax. :)

[16:34] <tadzik> :)

[16:34] <masak> I like 'my Int() $foo'.

[16:34] <masak> it's short, and easy to get used to.

[16:34] <jnthn> Note that sub foo(Int(Str) $foo) { } means "a Str must be passed, and will be coerced to an Int"

[16:35] <flussence> .oO( "coercion" looks like a word that should have an accented letter or two )

[16:35] <libreofficer> Operators

[16:35] <libreofficer> 2 *** missing native operators, including ++/-- (jnthn)

[16:35] <libreofficer>  Is it difficult?

[16:35] <jnthn> Yeah.

[16:35] <jnthn> Well.

[16:35] <jnthn> It's difficult because it depends on missing native type infrastructure.

[16:36] <libreofficer> oh

[16:36] <jnthn> The operators themselves are trivial to write.

[16:36] <jnthn> But the stuff needed to actually make that happen is trickier.

[16:36] <jnthn> (Mostly because it needs to be something that the optimizer can reduce to a really efficient operation)

[16:37] *** thou left
[16:38] <libreofficer> ok, and what about 3 **    Optimizing multis for `[+] 1..10` and `[<=] 1..10` etc. ?

[16:39] <jnthn> That should be somewhat easier.

[16:40] <masak> and fun to think about :)

[16:41] <gfldex> masak , moritz : re: Temporal-questions 2 days ago: https://gist.github.com/1917526

[16:42] <libreofficer> jnthn, so, I think I try it. Can you explain in details this task?

[16:42] *** sisar left
[16:42] <masak> my @post-to-display := @posts.grep: ($last-visit - .posted-at) < 24h;

[16:43] <masak> needs curlies or *

[16:43] <masak> hm, I would hesitate to accept postfix:<h> into core. it's a really nice syntax to load in using a module, though.

[16:44] <gfldex> i was thinking the same

[16:44] <gfldex> it's basicly the same syntax then most of us where teached in school

[16:44] <masak> then the Metric::Length module can peacefully co-exist with the Calendar module somehow over what postfix:<m> means :)

[16:46] <masak> gfldex: re example on lines 30..34: just use Date. problem solved.

[16:46] <masak> oh, you *are* using Date. just not enough. :)

[16:46] <gfldex> the problem is not so much having the same name but that you can't mix SI minutes with UTC minutes

[16:47] <jnthn> libreofficer: The idea is (for the [+] 1..10 case anyway) that instead of doing the normal reduction operator (which does 1 + 2 + ... + 10) there's a formula for this case.

[16:47] <masak> you can do things like $tom.birth + 365.

[16:47] <gfldex> for years that are not leap years

[16:47] <masak> but honestly I'd prefer to do $tom.birth + years(1) or something.

[16:47] <masak> right.

[16:47] <jnthn> libreofficer: At the moment we always auto-generate these reduction operators (it all boils down to higher order programming)

[16:48] <masak> all( January | Sunday ) # this has got to be confused -- you probably want a comma, not an infix:<|>

[16:48] <gfldex> it's brain compiled :)

[16:48] <libreofficer> jnthn, I see

[16:49] <masak> gfldex: most of what you're proposing seems to be neat little extensions to what we have already in core.

[16:49] <masak> neat little non-core extensions, I should say.

[16:49] <masak> what's there already is meant to provide neat little extensions like this.

[16:50] <masak> feel free to actually implement them -- preferably with tests -- and put them up on module.perl6.org

[16:50] *** wolfman2000 left
[16:51] <gfldex> i'm happy do to so

[16:51] <masak> pulling in Julian calendar or Chinese lunar calendar into core is not on the table unless you've convinced me of why it's important.

[16:51] <gfldex> there are a few things mission in Temporal tho

[16:51] <gfldex> like Date.new(now);

[16:51] <masak> how about Date.today?

[16:51] <masak> if it's missing, that's an omission :)

[16:51] <gfldex> you have to do Date.new(DateTime.now)

[16:51] <masak> yeah, I want Date.today. that makes perfect sense.

[16:52] <masak> nom: say Date.today

[16:52] <p6eval> nom 9d39e8: OUTPUT«2012-02-26␤»

[16:52] <masak> oh! there it is! :)

[16:52] <masak> we could add Date.now as a synonym, but that feels only half-important.

[16:52] <gfldex> nom: say Date.new(now);

[16:52] <p6eval> nom 9d39e8: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:569␤  in block <anon> at /tmp/xsFatLyXgg:1␤␤»

[16:52] <masak> nom: say Date(now)

[16:52] <p6eval> nom 9d39e8: OUTPUT«Method 'Date' not found for invocant of class 'Instant'␤  in <anon> at src/gen/Metamodel.pm:3425␤  in <anon> at src/gen/Metamodel.pm:3422␤  in block <anon> at /tmp/LK71VuS8X3:1␤␤»

[16:52] <masak> arguably that should work.

[16:53] * masak submits rakudobug

[16:54] <gfldex> nom: say Date.new('2010-02-30');

[16:54] <p6eval> nom 9d39e8: OUTPUT«day of 2010/2 out of range. Is: 30, should be in 1..28␤  in method check-value at src/gen/CORE.setting:8719␤  in method check-date at src/gen/CORE.setting:8729␤  in method new at src/gen/CORE.setting:9035␤  in method new at src/gen/CORE.setting:9041␤  in method new at…

[16:55] <masak> TimToady: in the case of Date(Instant), it really feels like the conversion method should sit on Date, not Instant. could that be made to work at all?

[16:55] <masak> nice error message, by the way.

[16:56] <jnthn> masak: You implement method postcircumfix:<( )> in Date.

[16:56] <masak> ooh

[16:56] <jnthn> I'm pretty sure I already wired up that case :)

[16:56] <masak> can't we have some nice sugar for such conversions, too?

[16:56] <jnthn> You likely want to constraint it to :U only

[16:57] <masak> like `method FROM(Instant:U $i) { ... }`

[16:57] <jnthn> Heh...never satisfied :P

[16:57] <masak> no :)

[16:57] <masak> so that I don't have to write up postcircumfix:<( )> myself with all the types I want to convert from.

[16:57] <masak> wire up*

[16:57] <jnthn> yeah, I can see the argument for something like that.

[16:58] <jnthn> Hm, isn't method &.() or so not already spec'd?

[16:59] <jnthn> yeah, see S13. Though NYI in Rakudo

[16:59] <moritz> \o

[16:59] <jnthn> hi, moritz o/

[16:59] <masak> jnthn: ooh! so doing multis on that already gives me what I want. :)

[17:00] <masak> moritz! \o/

[17:00] <jnthn> masak: Yeah, and (though S13 looks out of date there) I think the spec changed recently so you can do multis there

[17:00] <jnthn> I didn't get around to updating Rakudo for that yet.

[17:00] <jnthn> Though it's LHF if anybody wants to take it on.

[17:00] <tadzik> hello moritz 

[17:02] <masak> yeah, sorear++ updated it to be simpler, I think.

[17:06] <moritz> nom: try Date.new('2011-02-30'); say $!.WHAT

[17:06] <p6eval> nom 9d39e8: OUTPUT«X::OutOfRange()␤»

[17:06] <moritz> \o/

[17:06] <masak> \o/

[17:06] <masak> that's... beautiful.

[17:06] <moritz> nom: try Date.new('2011-02-30'); say $!.perl

[17:06] <p6eval> nom 9d39e8: OUTPUT«X::OutOfRange.new(what => "day of 2011/2", got => 30, range => "1..28")␤»

[17:07] <jnthn> moritz++

[17:08] <dalek> nqp/bs: 7c0ad48 | jnthn++ | src/6model/reprs/P6opaque.c:

[17:08] <dalek> nqp/bs: Add a better error rather than giving an unhelpful Null PMC Access for a possible failure mode in P6opaque.

[17:08] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7c0ad48767

[17:08] <dalek> rakudo/bs: 854d464 | jnthn++ | src/ (2 files):

[17:08] <dalek> rakudo/bs: A type declared in BOOTSTRAP should have its attributes set up there also; Capture broke this rule, which caused issues.

[17:08] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/854d4648cb

[17:08] <tadzik> moritz: purely awesome

[17:08] <moritz> in such cases I wonder if it the range should be an actual Range object instead of a string

[17:08] <libreofficer> jnthn, where to start? Where can I found current realization and how to write it clearly?

[17:08] <masak> nom: sub check-range($got, $range) { die X::OutOfRange.new(:$got, :$range) unless $got ~~ $range }; try check-range(10, 1..8); say $!.perl

[17:08] <p6eval> nom 9d39e8: OUTPUT«X::OutOfRange.new(what => "Argument", got => 10, range => 1..8)␤»

[17:09] <masak> moritz: "Argument"? :)

[17:09] <masak> oh, I think I see.

[17:09] <masak> moritz: actual Range, no question.

[17:09] <masak> otherwise you just invite useless parsing.

[17:10] <moritz> nom: say (1..18).gist

[17:10] <p6eval> nom 9d39e8: OUTPUT«1..18␤»

[17:10] <masak> yeah. there's no ungist :)

[17:10] <masak> well.

[17:10] <masak> there's &eval, and &val, I guess. :)

[17:10] <masak> but the less of them, the better.

[17:11] <moritz> well, it's pretty obvious in this case

[17:11] <moritz> but in others, I'm not so sure

[17:11] <moritz> for example when types are concerned

[17:11] <moritz> Method 'foo' not found for invocant of type Int

[17:12] <[Coke]> Cannot Be Ungist

[17:12] <moritz> Int could be stored as a type object, but it would require us to be much more careful about .gist vs .Str in the error message

[17:12] <jnthn> libreofficer: Take a look in src/core/metaops.pm for where reduction is implemented today

[17:12] <moritz> and then there are error messages where the type might not yet be composed etc.

[17:16] <pmurias> moritz: I need to put p5 module in roast (to test use ...:from<perl5>) properly, is the current working directory guaranteed when running the test suit?

[17:18] <pmurias> moritz: that is can I set the p5 inc relative to that?

[17:18] <moritz> pmurias: depends on what you mean by "guaranteed". The README in roast says that all tests should be executed as t/spec/*/*.t, and thus defines the current directory. Several other tests rely on it.

[17:18] <pmurias> moritz: that's what i meant thanks

[17:18] <moritz> pmurias: but of course we are never guarded against the insanity of future compiler writers :-)

[17:18] <moritz> we have t/spec/packages/, maybe add t/spec/p5-packages/ or packages/p5/ or so

[17:32] <dalek> rakudo/nom: c295b53 | moritz++ | src/core/ (2 files):

[17:32] <dalek> rakudo/nom: include actual Range object in X::OutOfRange error from Date.new

[17:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c295b5342a

[17:33] <dalek> roast: 26f6834 | moritz++ | S32-exceptions/misc.t:

[17:33] <dalek> roast: X::Syntax::Signature::InvocantMarker

[17:33] <dalek> roast: review: https://github.com/perl6/roast/commit/26f6834354

[17:33] <dalek> roast: 1bf4f1d | moritz++ | S32-exceptions/misc.t:

[17:33] <dalek> roast: X::OutOfRange

[17:33] <dalek> roast: review: https://github.com/perl6/roast/commit/1bf4f1dc02

[17:41] <masak> no-one expects the insanity of future compiler writers!

[17:42] *** mj41 left
[17:42] <masak> er, nobody*

[17:44] <[Coke]> pugs: say 3 eqv 3

[17:44] <p6eval> pugs b927740: OUTPUT«1␤»

[17:49] <dalek> nqp/bs: 7fd001a | jnthn++ | src/HLL/World.pm:

[17:49] <dalek> nqp/bs: Harden null string handling in string heap code-gen.

[17:49] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7fd001a3b7

[17:49] <dalek> nqp/bs: 833c719 | jnthn++ | src/PAST/NQP.pir:

[17:49] <dalek> nqp/bs: Oops, forgot to commit isnull_s addition.

[17:49] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/833c719deb

[17:49] <dalek> nqp/bs: 37cac25 | jnthn++ | src/6model/serialization.c:

[17:49] <dalek> nqp/bs: Don't duplicate the null string in the strings heap. Turns out it showed up a load when doing CORE.setting compilation. Reduces string heap size from 10578 to 2483.

[17:49] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/37cac25470

[17:51] *** zhangkaizhao left
[17:59] <masak> LINQ and macros came up yesterday. this seems apropos: http://scalamacros.org/usecases/language-integrated-queries.html

[17:59] <[Coke]>   Failed tests:  18-24

[17:59] <[Coke]>   TODO passed:   22-24

[18:00] <[Coke]> O_o

[18:00] <masak> that can't be right :)

[18:00] *** icwiener joined
[18:00] <masak> [Coke]: I say bug in the test harness.

[18:01] <[Coke]> plan was 17. that'll do it.

[18:02] <masak> yeah, prolly.

[18:03] <colomon> [Coke]: I've been seeing weird test harness results apparently from pugs fugding

[18:03] <dalek> roast: b6ba504 | coke++ | S (11 files):

[18:03] <dalek> roast: pugs fudges

[18:03] <dalek> roast: review: https://github.com/perl6/roast/commit/b6ba504573

[18:03] *** lateau__ left
[18:04] <dalek> niecza: e5096c2 | (Solomon Foster)++ | lib/ (2 files):

[18:04] <dalek> niecza: Start of implementation of run.  Still needs work, but can execute commands already.

[18:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e5096c2efe

[18:04] <dalek> niecza: a69231e | (Solomon Foster)++ | lib/CORE.setting:

[18:04] <dalek> niecza: Make infix:<eqv> and infix:<cmp> accept Mu arguments.  Relies on a slightly hacky change from $a.WHAT === $b.WHAT to $a.WHAT.gist eq $b.WHAT.gist; my memory suggests there are obscure edge cases there the new version fails, but I was unable to figure out how to modify the old version to get it to work.

[18:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a69231e534

[18:04] <dalek> niecza: 7ccd4bc | (Solomon Foster)++ | lib/Builtins.cs:

[18:04] <dalek> niecza: Comment out code that isn't doing anything yet, to avoid warnings.

[18:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7ccd4bce3d

[18:04] <dalek> Pugs.hs: 96b47de | coke++ | t/spectest.data:

[18:04] <dalek> Pugs.hs: run fudged tests

[18:04] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/96b47de1a4

[18:04] <[Coke]> colomon: apologies. I've only been checking in pugs because "what could possible go wrong"

[18:04] <[Coke]> *ly. ;)

[18:05] *** skids joined
[18:07] <[Coke]> properties-general, looks like.

[18:11] <[Coke]> colomon: weird - only thing I did to that file was add individual #?pugs todo markers.

[18:12] <moritz> niecza: role A { }; my $x = 3 but A; say $x.WHAT

[18:12] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«Int+A()␤»

[18:13] <moritz> niecza: my $x = do { my role A { }; 5 but A }; my $y = do { my role A { }; 5 but A }; say $x.WHAT; say $y.WHAT

[18:13] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«Int+A()␤Int+A()␤»

[18:13] *** havenn joined
[18:13] <moritz> niecza: my $x = do { my role A { }; 5 but A }; my $y = do { my role A { }; 5 but A }; say $x eqv $y

[18:13] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«True␤»

[18:13] <moritz> ... and that's the obscure edge case that colomon++ wasn't able to remember

[18:13] <moritz> rakudo: my $x = do { my role A { }; 5 but A }; my $y = do { my role A { }; 5 but A }; say $x eqv $y

[18:13] <p6eval> rakudo c295b5: OUTPUT«True␤»

[18:14] <moritz> hm, same problem

[18:14] <jnthn> Type equivalence should go on .WHAT being the same object, not on some name stringification.

[18:16] <moritz> correct

[18:18] <[Coke]> jnthn: there are lots of tests that are comparing .WHAT.gist instead of just .WHAT

[18:18] <jnthn> [Coke]: That's OK for the tests, imo.

[18:18] <[Coke]> (which I'm only finding because pugs has no .gist)

[18:19] <[Coke]> jnthn: ok then. ;)

[18:19] <jnthn> [Coke]: But Rakudo's eqv implementation shouldn't use it.

[18:21] *** mucker joined
[18:22] <dalek> nqp/bs: 4524488 | jnthn++ | src/HLL/World.pm:

[18:22] <dalek> nqp/bs: Toss legacy dependency handling code.

[18:22] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/4524488699

[18:23] <dalek> rakudo/bs: 8193d6b | jnthn++ | src/Perl6/World.pm:

[18:23] <dalek> rakudo/bs: Don't need to merge globals when loading the module loader. With this, the produced CORE.setting.pbc loads up until attempting to deserialize, which currently fails for some reason.

[18:23] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/8193d6b38d

[18:24] *** packetknife joined
[18:28] * jnthn away for a bit

[18:29] <dalek> roast: 18311a3 | (Solomon Foster)++ | S03-operators/eqv.t:

[18:29] <dalek> roast: Unfudge tests that now work.

[18:29] <dalek> roast: review: https://github.com/perl6/roast/commit/18311a38aa

[18:32] *** xinming joined
[18:32] *** havenn_ joined
[18:35] *** fsergot joined
[18:36] <pmurias> colomon: hi

[18:36] <colomon> o/

[18:36] <pmurias> colomon: why do we use Glib for &run?

[18:36] <pmurias> instead of System.Diagnostics.Process?

[18:36] <colomon> pmurias: it's the best.... 

[18:37] <colomon> err I don't know.

[18:37] <colomon> hold on

[18:38] <colomon> is that what you're using for p5 interop?

[18:38] *** havenn left
[18:38] * colomon is now browsing docs...

[18:39] <pmurias> colomon: for p5 interop i'm using p/invoke

[18:43] *** mucker left
[18:47] <pmurias> moritz: if the only test is in eval_lives_ok I can move it out from there?

[18:48] <moritz> pmurias: if it makes sense outside an eval_lives_ok, yes

[18:50] <dalek> niecza: 404996f | (Paweł Murias)++ | t/spectest_p5.data:

[18:50] <dalek> niecza: Add test to t/spectest_p5.data.

[18:50] <dalek> niecza: review: https://github.com/sorear/niecza/commit/404996f127

[18:51] <pmurias> moritz: should I just put anything that I'm adding to niecza (and isn't obviously niecza specific) to S01-perl5-integration?

[18:51] *** havenn joined
[18:52] <moritz> pmurias: if it's specific to niecza, it should go into niecza's repo

[18:53] <moritz> pmurias: if it's specced, but only niecza handles it right now, it should be treated like any other spectest

[18:53] <pmurias> the p5 integration isn't specced

[18:53] <pmurias> and currently the directory hold pugs fossils

[18:53] <pmurias> * holds

[18:54] <moritz> S01 does spec p5 integration

[18:54] <pmurias> in a "yes we have it manner"

[18:54] *** havenn left
[18:55] *** havenn_ left
[18:55] <moritz> it gives concrete examples

[18:55] *** havenn joined
[18:57] *** havenn left
[18:57] *** skipper joined
[18:57] <pmurias> moritz: it only specs that 'use v5' works

[18:58] *** birdwindupbird joined
[18:58] <moritz> yes. That's a quite concrete form of interop with v5, isn't it?

[19:03] <pmurias> it's still not specced only mentioned

[19:04] *** retupmoca joined
[19:05] *** skipper left
[19:14] <colomon> pmurias: oh, I think I see the issue that bugged sorear about System.Diagnostics.Process -- it takes all its arguments as one string, instead of passing them argument by argument.

[19:15] <colomon> on the other hand, if it actually is portable, it might be a great fall-back approach...

[19:22] <sorear> good * #perl6

[19:25] <sorear> colomon: S02:1283 is slightly relevant to what you've done today

[19:25] <colomon> o/

[19:28] <colomon> sorear: you mean the $a.WHAT.gist eq $b.WHAT.gist thing?

[19:28] <sorear> yes

[19:31] <colomon> I guess my question here is, what is the type returned by .WHAT?

[19:31] <fsergot> nqp: say 1;

[19:31] <p6eval> nqp: OUTPUT«Confused at line 1, near "say 1;"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[19:31] <colomon> niecza: say Mu.WHAT.perl

[19:31] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«Mu␤»

[19:31] <fsergot> nqp: say(1);

[19:31] <p6eval> nqp: OUTPUT«1␤»

[19:34] <fsergot> nqp: exit(1);

[19:34] <p6eval> nqp: OUTPUT«Could not find sub exit␤current instr.: '_block1000' pc 30 ((file unknown):36) (/tmp/56xUVG9Xw4:1)␤»

[19:36] <sorear> colomon: .WHAT always returns the same type as the argument

[19:36] <colomon> sorear: yeah, I was just starting to realize that

[19:36] <colomon> so it's an undefined object of the given object's type?

[19:37] <sorear> yes

[19:38] <fsergot> How to force NQP to exit? :)

[19:38] <sorear> nqp: say(1); pir::exit(3); say(2);

[19:38] <p6eval> nqp: OUTPUT«1␤»

[19:39] <sorear> that seems like it might have worked

[19:39] <fsergot> sorear++ thanks

[19:39] <sorear> note that pir::exit doesn't actually call exit(2)

[19:39] <sorear> it just throws an exception with the severity set to EXIT

[19:40] <sorear> fsergot: you said hi the other day and I tried to return it but I couldn't because your connection kept dropping out :(

[19:41] <sorear> pmurias: I'm serious about wanting something on the new p5 stuff for announce.v15

[19:41] *** noam_ left
[19:41] <fsergot> I had some troubles with connection recently. :(

[19:41] *** noam_ joined
[19:42] <fsergot> sorear: It's the only way to exit in nqp?

[19:47] <colomon> sorear: the problem with changing infix:<===> to take Mu arguments is that it no longer autothreads properly when you do that.

[19:49] <pmurias> sorear: when is the deadline for the annocement?

[19:49] <sorear> colomon: the other problem is that === is specifically specced to take (Any,Any)

[19:50] <sorear> pmurias: tomorrow

[19:50] <colomon> sorear: ah, those things probably go together, eh?

[19:51] <sorear> Now that you bring it up I don't think the signatures for eqv and cmp are explicitly given anywhere

[19:51] <sorear> pmurias: 36 hours before the end of the release window

[19:52] <colomon> there are spec tests which check things like Mu eqv Any, which is how I got into this mess in the first place.

[19:53] <colomon> and it makes much less sense to autothread them

[19:54] <pmurias> sorear: i'll start writing something down then

[19:54] *** havenn joined
[19:55] <colomon> sorear: is ^isa exact?  that is, if I say $a.^isa(Mu), then $a really is a Mu and not just something derived from Mu?

[19:55] <masak> perl6: say Cool.^isa(Any)

[19:55] <p6eval> rakudo c295b5: OUTPUT«1␤»

[19:55] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&Cool"␤    at /tmp/1PJ0ccoMgD line 1, column 5 - line 2, column 1␤»

[19:55] <p6eval> ..niecza v14-82-g7ccd4bc: OUTPUT«True␤»

[19:56] *** ribayr left
[19:57] <jnthn> No, it's not "exact"

[19:57] <jnthn> So Rakudo and Niecza are correct here

[19:57] <jnthn> fsergot: Using pir::exit is fine

[19:58] <jnthn> Or you may want to add an entry to the mapping table in src/PAST/NQP.pir, then you can write nqp::exit()

[19:58] <jnthn> er, nqp::exit($code)

[19:58] <colomon> jnthn: is there a better way determine type equivalenc than $a^.isa($b) and $b^.isa($a)?

[19:58] <colomon> s/and/&&/

[19:59] <moritz> $a.WHAT === $b.WHAT

[19:59] <colomon> moritz: doesn't work if $a or $b is Mu

[19:59] <jnthn> What moritz++ said shoudl do it, modulo the Mu case

[19:59] <colomon> which is exactly the case I'm worried about

[19:59] <moritz> eeks

[20:00] <masak> so the question boils down to: how do you determine whether an object is Mu but not derived from Mu?

[20:00] <masak> solve that, and you solve the whole problem.

[20:01] *** ribayr joined
[20:01] <colomon> masak: I've been trying to do exactly that for the last six minutes

[20:01] <moritz> $a !~~ Any

[20:01] <moritz> perl6: say Junction !~~  Any

[20:01] <p6eval> pugs b927740: OUTPUT«1␤»

[20:01] <p6eval> ..rakudo c295b5, niecza v14-82-g7ccd4bc: OUTPUT«True␤»

[20:01] <colomon> ooooo

[20:02] <moritz> nom: say Junction.^mro

[20:02] <p6eval> nom c295b5: OUTPUT«Junction() Mu()␤»

[20:02] <moritz> $a.^mro.elems == 1 # Mu or Mu.new

[20:02] <colomon> niecza: say Junction.^mro

[20:02] <moritz> and you can distinguish those two cases with $a.DEFINITE

[20:02] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«Unhandled exception: Unable to resolve method mro in class ClassHOW␤  at /tmp/mLVVTfYUtV line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3836 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3837 (module-CORE @ 65) ␤  at /ho…

[20:02] *** ribayr left
[20:03] <sorear> niecza: say Junction.WHICH

[20:03] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Frame.BindSignature (Niecza.Frame th, Niecza.Signature sig, Int32 mode, System.String signame, Niecza.Variable[] pos, Niecza.VarHash named,…

[20:03] <sorear> niecza: say Junction.WHICH === Junction.WHICH

[20:03] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«True␤»

[20:03] <sorear> niecza: say Junction.WHICH === Mu.WHICH

[20:03] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«False␤»

[20:04] * moritz hates the fact that === autothreads

[20:05] <sorear> masak, however, has used === autothreading in yapsi

[20:05] <sorear> that was one of the features whose lack in contemporary niecza I had to deal with in the yapsi/niecza branch

[20:06] <masak> I have? huh.

[20:07] <masak> ISTR TimToady has been going back and forth a bit on whether === really autothreads.

[20:14] <felher> jnthn: out of curiosity: Why would one create a mapping and than use nqp::exit instead of pir::exit? Is it because then one may later rewrite/change the implementation of it in NQP and have all the code automagically use it?

[20:17] <sorear> felher: nqp is not limited to Parrot anymore

[20:17] <sorear> nqp::exit has the potential of doing the right thing on nqp/jvm, nqp/lua, and nqp/dotnet

[20:18] <moritz> and even on pure parrot, we have some nqp:: opcodes that don't directly map to a single pir:: opcode

[20:20] <sorear> also pir is going to be killed with fire at the first opportunity, but all that means is that the "pir::" name will become a fossil

[20:20] <moritz> great point, which chromatic completely misses when bashing the nqp:: opcodes

[20:22] <felher> sorear++, moritz++. Thanks for the explanation :)

[20:22] <sorear> chromatic is still at it huh.

[20:22] <moritz> well, not right now, just last time I tried to discuss with him

[20:23] <TimToady> I have never gone back and forth on === autothreading

[20:24] <moritz> old S03 was just silent on whether it autothreads

[20:24] <TimToady> I'm the one who insists it must

[20:24] <colomon> sorear: okay if I refactor infix:<===> to use a Niecza:: sub which does take Mu?  Then use that version instead of === in infix:<cmp>.

[20:24] <TimToady> and that junctions must be written in terms of something lower level

[20:25] <sorear> colomon: ok

[20:25] <colomon> sorear: on it, then.

[20:27] <masak> TimToady: ah.

[20:28] <dalek> niecza: 0e1f874 | sorear++ | tools/extheapshot.c:

[20:28] <dalek> niecza: [extheapshot] Refactor and orthogonalize image handling

[20:28] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0e1f874717

[20:29] <TimToady> === is not there for the convenience of people writing CORE stuff, but for mere mortals who are dealing with various derived types that they'll expect to autothread

[20:29] *** plobsing joined
[20:30] *** birdwindupbird left
[20:33] <colomon> sorear: seems to work like a charm.  :)

[20:35] *** seanstickle joined
[20:42] *** plobsing left
[20:43] *** Chillance left
[20:43] *** Chillance joined
[20:47] *** razor42 joined
[20:47] *** benabik left
[20:48] *** plobsing joined
[20:49] <masak> TimToady: makes sense.

[20:49] <moritz> only half to me

[20:50] <moritz> IMHO it's a really good idea to provide low-level-ish primitives

[20:50] <moritz> which are consistent more than they DWIM

[20:50] *** benabik joined
[20:51] *** ribayr joined
[20:51] <dalek> niecza: f8c5ab8 | sorear++ | tools/extheapshot.c:

[20:51] <dalek> niecza: [extheapshot] Record and report root types

[20:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f8c5ab8a5c

[20:51] <moritz> so if === autothreads, we should really make a more primitive way available

[20:51] <masak> no argument there.

[20:52] <fsergot> nom: <1 2 3 1>.uniq.say;

[20:52] <p6eval> nom c295b5: OUTPUT«1 2 3␤»

[20:52] <dalek> niecza: 834f2d9 | (Solomon Foster)++ | lib/CORE.setting:

[20:52] <dalek> niecza: Refactor infix:<===> to be built using a new Niecza::ValueIdentity sub, which can take Mu arguments.  Then use Niecza::ValueIdentity where we were previously using infix:<===> in infix:<cmp>.

[20:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/834f2d94cb

[20:52] <fsergot> nom: <abc cba b abc>.uniq.say;

[20:52] <p6eval> nom c295b5: OUTPUT«abc cba b␤»

[20:53] <masak> does uniq in Niecza use Set? :)

[20:54] <fsergot> Why "slurp('file').Array.uniq.say" doesn't work?

[20:54] <colomon> masak: nope

[20:54] <masak> colomon: just noticed :)

[20:54] <colomon> fsergot: because slurp returns a single string

[20:54] <masak> niecza: class C { method Str { "OH HAI" } }; say ~C.new

[20:54] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«OH HAI␤»

[20:55] <masak> niecza: class C { method Str { "OH HAI" } }; say +uniq C.new, C.new

[20:55] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'uniq' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /hom…

[20:55] <fsergot> colomon: even in array context? Like: "my @lines = slurp 'file';"

[20:55] <colomon> fsergot: yes

[20:55] <masak> niecza: class C { method Str { "OH HAI" } }; say +(C.new, C.new).uniq

[20:55] <p6eval> niecza v14-82-g7ccd4bc: OUTPUT«1␤»

[20:55] <masak> should be 2, IMO.

[20:55] <masak> nom: class C { method Str { "OH HAI" } }; say +(C.new, C.new).uniq

[20:55] <moritz> fsergot: use  open('file').lines   instead

[20:55] <p6eval> nom c295b5: OUTPUT«1␤»

[20:55] <colomon> fsergot: if you want lines, you have to ask for them

[20:55] * masak submits rakudobug

[20:55] <colomon> or slurp('file').lines

[20:56] <colomon> open('file').lines should be preferable, but I don't think either implementation will close the file if you do it that way....

[20:56] *** MayDaniel joined
[20:57] <fsergot> Hmm, I was convinced that slupr in array context returns an array. :)

[20:57] <fsergot> I know other ways, but I was curious.

[20:58] <moritz> fsergot: that might be true in p5

[20:58] <moritz> fsergot: but in perl 6, a routine doesn't know which context it's called in

[20:58] <masak> in a sense, array context is gone.

[20:59] <jnthn> We got object hashes in Rakudo now, so should be able to get uniq righter :)

[20:59] <masak> that's my idea.

[20:59] <moritz> fsergot: so the only way to make that work would be by returning an object that can be used either as a Str or a List. Which is totally possible, but a waste of memory

[20:59] <moritz> jnthn: I'm already compiling a possible fix :-)

[20:59] <masak> might be this bug has been submat before, but this makes it stand out :)

[20:59] <jnthn> fsergot: Your patch is a tad off - it puts the error on STDOUT instead of STDERR

[20:59] <jnthn> pir::printerr will write to STDERR

[21:00] *** MayDaniel left
[21:00] <moritz> we should totally alias that as nqp::note

[21:00] <moritz> oh wait, &note appends a newline

[21:00] <jnthn> +1

[21:00] <jnthn> dang :)

[21:00] <fsergot> jnthn: Oh, right. I forget about it.

[21:01] <fsergot> this*

[21:03] <moritz> also I'm not sure that's the right approach

[21:04] <sorear> masak: uniq should use set, which should use object hashes

[21:04] <sorear> jnthn: What's the user interface for object hashes?

[21:04] <moritz> what if a a compiler wants to call evalfile without having it exit on failure?

[21:04] <moritz> sorear: my %hash{Type}

[21:04] <dalek> niecza: 15bcd26 | sorear++ | tools/extheapshot.c:

[21:04] <dalek> niecza: [extheapshot] Generate full class names

[21:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/15bcd269c7

[21:04] <colomon> sorear: doesn't uniq preserve order?

[21:05] <moritz> nom: my %h{Any}; 

[21:05] <p6eval> nom c295b5:  ( no output )

[21:05] <sorear> moritz: does that syntax actually work in nom?

[21:05] <moritz> sorear: yes

[21:06] <moritz> nom: class A { has $.x; method Str() { 'a' } }; my %h{Any}; %h{A.new(x => 3) } = 3; %h{A.new(x => 5)} = 2; say %h.keys.perl

[21:06] <p6eval> nom c295b5: OUTPUT«(A.new(x => 3), A.new(x => 5)).list␤»

[21:06] <moritz> it's a newish feature

[21:06] <masak> \o/

[21:07] * masak has been looking forward to it for years

[21:07] <jnthn> moritz: What would you suggest as a better approach?

[21:08] <jnthn> masak: Now write something awesome using it :)

[21:08] <moritz> jnthn: I don't know. I'd know how to solve this on the Perl 6 level

[21:08] <sorear> nom: my %h{Any}; say %h

[21:08] <p6eval> nom c295b5: OUTPUT«().hash␤»

[21:08] <sorear> nom: my %h{Any}; say %h.WHAT

[21:08] <p6eval> nom c295b5: OUTPUT«Hash+{TypedHash}()␤»

[21:08] <sorear> nom: my %h; say %h.WHAT

[21:08] <p6eval> nom c295b5: OUTPUT«Hash()␤»

[21:08] <masak> jnthn: :)

[21:08] <sorear> nom: my %h{Any}; say %h.^methods(:local)

[21:08] <masak> jnthn: I will.

[21:08] <p6eval> nom c295b5: OUTPUT«at_key STORE_AT_KEY bind_key pairs of␤»

[21:08] <sorear> nom: my %h{Any}; say %h.of

[21:09] <p6eval> nom c295b5: OUTPUT«Mu()␤»

[21:09] <masak> o.O

[21:09] <sorear> nom: my %h{Any}; say %h.^mro

[21:09] <p6eval> nom c295b5: OUTPUT«Hash+{TypedHash}() Hash() EnumMap() Iterable() Cool() Any() Mu()␤»

[21:09] <jnthn> What're you o.O-ing at?

[21:09] <moritz> .of returns the type constraint for the values

[21:09] <jnthn> Right, exactly.

[21:09] <masak> ah, 'course.

[21:09] <sorear> nom: say Hash.^methods(:local)

[21:09] <p6eval> nom c295b5: OUTPUT«new at_key bind_key STORE_AT_KEY STORE delete push PARAMETERIZE_TYPE perl␤»

[21:09] <masak> how to I get the type constraint for the keys?

[21:09] <sorear> nom: say EnumMap.^methods(:local)

[21:09] <p6eval> nom c295b5: OUTPUT«elems exists iterator list keys kv values pairs invert at_key STORE_AT_KEY Capture FLATTENABLE_LIST FLATTENABLE_HASH fmt of Bool ACCEPTS perl␤»

[21:10] <TimToady> there should be a shape property, methinks

[21:10] <moritz> masak: spec a way to introspect it, and we'll implement it

[21:10] <jnthn> masak: None yet implemented.

[21:10] <benabik> What's the +{TypedHash} bit?

[21:10] <jnthn> Well, that's not *strictly* true. There probably is a way to go looking at the meta-object

[21:10] <sorear> jnthn: is there *any* way to get at the key constraint, using pir:: etc?

[21:10] <havenn> Noob question here, but Ruby folks are telling me the reason 'puts' (print with a \n) can't be called like "hi".puts is because puts is a private method of every object, so that you can call "puts 'hi'" in any context in your code"

[21:11] <masak> +1 on TimToady'd .shape proposal.

[21:11] <jnthn> sorear: If there is a way, it's almost certainly not with that.

[21:11] <havenn> How does perl6 get around issue of context?

[21:11] <jnthn> sorear: It'd be by introspecting the type args on a role.

[21:11] <masak> it's just a matter of spec'ing what .shape returns briliiantly.

[21:11] <havenn> Or do I just need to read more and ask less? =P

[21:11] <sorear> jnthn: basically I want to know how nom reacts to my %h{$type}

[21:11] <sorear> nom: sub evil($x = my %h{$x}) { }

[21:11] <p6eval> nom c295b5: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[21:11] <masak> havenn: no, it's a fine question.

[21:11] <TimToady> havenn: in P6-ese we'd say that those are submethods, not methods

[21:11] <moritz> benabik: it works by mixing in a parameterized role into hash

[21:11] <sorear> nom: sub less_evil($x; $y = my %h{$x}) { }

[21:11] <p6eval> nom c295b5: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[21:12] <sorear> nom: sub still_a_bit_evil($x) { my %hash{$x} }

[21:12] <p6eval> nom c295b5: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[21:12] <masak> havenn: used to be 'say $x' and '$x.say' were "the same" in Perl 6. but now they're distinct, and one delegates to the other.

[21:12] <TimToady> havenn: and it is a good question, because we keep finding people writing methods that should be submethods, like .gist

[21:12] <moritz> sorear: it's syntactic, iirc

[21:12] <masak> havenn: turned out we weren't that much helped by methods exporting themselves as subs.

[21:13] <sorear> I am +1 to requiring the stuff in the shape brackets to be compile time constants

[21:13] <jnthn> sorear: It handles it by mixing in a role.

[21:13] <TimToady> if a method is accessing the private attributes of the current class, it should probably be a submethod

[21:13] <sorear> C99 has to be better at something

[21:13] <masak> heh, TimToady and I seem to be explaining different things :)

[21:13] <TimToady> unless you are very careful for your method to be usable by subclasses

[21:13] <jnthn> sorear: If you manage to get it a type known at compile time in there somehow it'll probably be happy.

[21:14] <TimToady> I am +1 to relying on constant folding for compile-time shapes, and allow run-time shapes like Algol :)

[21:14] <jnthn> nom: constant Foo = Int; my %hash{Foo} # think this may work out...

[21:14] <p6eval> nom c295b5:  ( no output )

[21:15] <fsergot> jnthn: I sended a new patch! :)

[21:15] <TimToady> I am +1 to that because I like to torment implementors :)

[21:15] * masak knew it!

[21:15] <sorear> TimToady: at issue is the behavior of declarations being lifted to the top of the scope

[21:15] *** kaare__ left
[21:15] <sorear> TimToady: say %*foo.shape; my $x = (Int, Str).pick; my %*foo{$x};

[21:16] <TimToady> that doesn't look like legal P6 to me...

[21:16] *** Trashlord left
[21:16] <jnthn> sorear: TimToady said constant folding and compile time...that seems decidedly runtime :)

[21:17] <TimToady> he's trying to show the problem with runtime

[21:17] <jnthn> Now, if that was constant $x... :)

[21:17] <sorear> TimToady: In what way is it not legal P6?

[21:17] <TimToady> std: say %*foo.shape; my $x = (Int, Str).pick; my %*foo{$x};

[21:17] <p6eval> std a540d4e: OUTPUT«ok 00:01 113m␤»

[21:17] <sorear> Other than the whole "requires closed timelike curves" thing

[21:17] <masak> :D

[21:18] <TimToady> ah, missed the *

[21:18] <masak> closed timelike curves are not a syntactic feature!

[21:18] <masak> thus, STD.pm6 doesn't check for them.

[21:18] <TimToady> but anything that relies on a run-time value obviously can't be elaborated till that value is available

[21:18] <TimToady> so the shape would be undefined

[21:18] <masak> wfm

[21:19] <dalek> nqp: aee97aa | (Filip Sergot)++ | src/HLL/Compiler.pm:

[21:19] <dalek> nqp: nicer error message of &evalfiles

[21:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/aee97aacc8

[21:19] <dalek> nqp: d85df9e | (Filip Sergot)++ | src/HLL/Compiler.pm:

[21:19] <dalek> nqp: nicer error message of &evalfiles

[21:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d85df9e27b

[21:19] <dalek> nqp: 5030ed5 | (Filip Sergot)++ | src/HLL/Compiler.pm:

[21:19] <dalek> nqp: &evalfiles will print error msg to the STDERR

[21:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5030ed5a5b

[21:19] <dalek> nqp: 3133d4a | (Filip Sergot)++ | src/HLL/Compiler.pm:

[21:19] <dalek> nqp: &evalfiles will print error msg to the STDERR

[21:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3133d4aad1

[21:19] <dalek> nqp: 9903471 | jonathan++ | src/HLL/Compiler.pm:

[21:19] <dalek> nqp: Merge pull request #30 from sergot/master

[21:19] <dalek> nqp: 

[21:19] <dalek> nqp: nicer error message when file specified at command line is not found; maybe not perfect, but surely an improvement from user's point of view

[21:19] <dalek> nqp: review: https://github.com/perl6/nqp/commit/990347106f

[21:20] <jnthn> TimToady: I assume in this case it's OK to whine about this as a problem at compile time, rather than being undefined at runtime? :)

[21:20] <TimToady> well, with contextuals it's difficult for the compiler to detect much

[21:21] <TimToady> but something coming in lexically would give the compiler more to work with, of course

[21:21] <jnthn> The declaration of the contextual is just a normal lexical declaration, though.

[21:22] <TimToady> yes, but we could conceivable call ourselves recursively, and pass things down that way

[21:22] <TimToady> mind, it's a smelly way to pass parameters

[21:23] <TimToady> contextuals are kind of an escape valve too

[21:23] <TimToady> they should be exceptional much as exceptions are exceptional

[21:23] <sorear> What I had been thinking is that my %foo{...} binds %foo to an unusable placeholder at block entry, and becomes (%foo := Hash.new(shape => ...)) at normal execution time

[21:23] <fsergot> Sorry for 4 commits, not only 1.

[21:24] <moritz> fsergot: no problem. If we really cared, we could have squashed them into one

[21:24] <TimToady> sorear: something like that

[21:25] <TimToady> it's a bit harder to implement than just putting arbitrary restrictions, but it fits in with the P6 notion of not doing things either too early or too late, but letting the data relationships drive the implicit control flow

[21:26] <jnthn> In Rakudo the type-y stuff is resolved at compile time, so the block entry action is cheap.

[21:27] <jnthn> Anything as the shape which is compile-time knowable should be fine.

[21:27] <fsergot> It was my second patch, so it's not advenced. :)

[21:27] <jnthn> (Almost certainly it's too restrictive in Rakudo today.)

[21:27] <TimToady> I view run-time shaped arrays as another way to write generic code

[21:27] <TimToady> P6 is fine with intentional generic code; it's the unintentional generic code that is forbidden

[21:28] <jnthn> Wait, so you want the compile time case to work too?

[21:28] <jnthn> gah

[21:28] <jnthn> You want the runtime case to work too?

[21:28] <TimToady> if the shape is a constant, sure

[21:29] <TimToady> yeah, like in Algol :)

[21:29] <jnthn> For...what definition of "constant"?

[21:29] <jnthn> I take "constant" to mean "we know it at compile time" :P

[21:29] <TimToady> yes

[21:29] <TimToady> otherwise you pessimize for run time correctness

[21:30] *** whiteknight left
[21:30] <TimToady> we have to do something similar already for dimensions that are *, and shrink and grow them depending on usage, not just the declaration

[21:31] <TimToady> but a run-time shape is at least constant over the particular elaboration of the declaration

[21:31] <TimToady> (elaboration being a run-time concept borrowed from Ada)

[21:32] <TimToady> note that in the typcical case of my @array[10,10] we very much know that 10 and 10 are both constants

[21:33] <sorear> sub foo { my $x; } # in p5, every SV that is bound to $x is an elaboration of the pad slot?  is that what elaboration means?

[21:33] <TimToady> [10;10] I mean

[21:33] <sorear> TimToady: the other question is what to do about @*foo[1] = 5; my @*foo[10];

[21:33] <TimToady> yes, more or less; Ada includes the notion of initializing in that

[21:34] <sorear> the obvious answer is to reject it, if we're delaying shape evaluation until execution time

[21:34] <sorear> but we could have a split approach that hoists constant shapes

[21:34] <sorear> (ow)

[21:34] <jnthn> perl6: my $*x = 42; sub foo() { say $*x; my $*x = 100; }; foo()

[21:34] <p6eval> rakudo c295b5, niecza v14-87-g15bcd26: OUTPUT«Any()␤»

[21:34] <p6eval> ..pugs b927740: OUTPUT«␤»

[21:34] <lue> hello world o/

[21:35] <jnthn> hellue!

[21:35] <TimToady> I really think it's pathological to refer to a contextual before it's defined

[21:35] <jnthn> Pathological enough to make it behave like...

[21:35] <jnthn> std: say $x; my $x;

[21:35] <p6eval> std a540d4e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $x is not predeclared at /tmp/O0bQKW97Ti line 1:␤------> [32msay [33m⏏[31m$x; my $x;[0m␤Check failed␤FAILED 00:01 110m␤»

[21:35] <jnthn> er

[21:35] <jnthn> std: my $x; { say $x; my $x; }

[21:36] <p6eval> std a540d4e: OUTPUT«[31m===[0mSORRY![31m===[0m␤Lexical symbol '$x' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::<$x>␤  before you can unambiguously declare a new '$x' in this scope at /tmp/WJkECNDRPj line 1:␤---…

[21:36] <TimToady> yes, or at least like a rebinding error

[21:36] <TimToady> yes, that one

[21:36] <jnthn> Yeah, that's the one I messed up tyring to trigger :)

[21:37] <sorear> jnthn: are you thinking of having the pad slot be initially NULL and throwing a runtime exception if accessed before declaration?

[21:38] <jnthn> sorear: No, I was thinking of catching the usage at compile time.

[21:38] <jnthn> sorear: See what contextuals we've seen being used

[21:38] <sorear> jnthn: could you elaborate on that?

[21:38] <jnthn> sorear: Then if a my $*ooh-i-saw-this-already is declared, whine like STD does above

[21:38] <sorear> jnthn: also, what about MY::{'@foo'}; my @foo[5] ?

[21:39] <jnthn> sorear: I guess if you're using that syntax you "escape" the predeclaration check.

[21:39] <TimToady> though in this case we don't know *where* the contextual is actually coming from, only that $*foo has been used ambiguously

[21:39] <sorear> (pretend '@foo' is an expression that the constant folder can't see through)

[21:41] <TimToady> well, or @::('foo') likewise

[21:41] <jnthn> nom: say pir::find_lex__Ps('%h').of; my Int %h{Str};

[21:41] <p6eval> nom c295b5: OUTPUT«Int()␤»

[21:41] <TimToady> we've already said that an eval may see only one lexical of a given name, and can't know whether the eval is before or after the declaration

[21:42] <TimToady> perl6: say eval '$foo'; my @foo = 42;

[21:42] <p6eval> rakudo c295b5: OUTPUT«===SORRY!===␤Variable $foo is not declared␤at eval_0:1␤»

[21:42] <p6eval> ..niecza v14-87-g15bcd26: OUTPUT«Potential difficulties:␤  @foo is declared but not used at /tmp/LQnUHl8eos line 1:␤------> [32msay eval '$foo'; my [33m⏏[31m@foo = 42;[0m␤␤Unhandled exception: Variable $foo is not predeclared (did you mean @foo?)␤  at /home/p6eval/niecza/boot/lib/CORE…

[21:42] <p6eval> ..pugs b927740: OUTPUT«␤»

[21:42] <TimToady> oops

[21:42] <TimToady> perl6: say eval '$foo'; my $foo = 42;

[21:42] <p6eval> niecza v14-87-g15bcd26: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/jzygnhRfhE line 1:␤------> [32msay eval '$foo'; my [33m⏏[31m$foo = 42;[0m␤␤Any()␤»

[21:42] <p6eval> ..rakudo c295b5: OUTPUT«Any()␤»

[21:42] <p6eval> ..pugs b927740: OUTPUT«␤»

[21:43] <jnthn> perl6: say eval '$foo'; my Int $foo = 42;

[21:43] <TimToady> perl6: say eval '$OUTER::foo'; my $foo = 42;

[21:43] <p6eval> niecza v14-87-g15bcd26: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/L1tkXHgEr9 line 1:␤------> [32msay eval '$foo'; my Int [33m⏏[31m$foo = 42;[0m␤␤Int()␤»

[21:43] <p6eval> ..pugs b927740: OUTPUT«Int␤»

[21:43] <p6eval> ..rakudo c295b5: OUTPUT«Int()␤»

[21:43] <p6eval> niecza v14-87-g15bcd26: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/RPzWmovT73 line 1:␤------> [32msay eval '$OUTER::foo'; my [33m⏏[31m$foo = 42;[0m␤␤Any()␤»

[21:43] <p6eval> ..rakudo c295b5: OUTPUT«Any()␤»

[21:43] <p6eval> ..pugs b927740: OUTPUT«␤»

[21:44] <TimToady> right, in this case elaboration is after the eval

[21:45] <TimToady> perl6: for 1..2 { say eval '$foo'; state $foo = 42; }

[21:45] <p6eval> rakudo c295b5: OUTPUT«Any()␤42␤»

[21:45] <p6eval> ..pugs b927740: OUTPUT«␤42␤»

[21:45] <p6eval> ..niecza v14-87-g15bcd26: OUTPUT«Potential difficulties:␤  $foo is declared but not used at /tmp/an83tM2Zz3 line 1:␤------> [32mfor 1..2 { say eval '$foo'; state [33m⏏[31m$foo = 42; }[0m␤␤Any()␤42␤»

[21:45] <TimToady> that's better

[21:47] <masak> and not a problem at all.

[21:48] <masak> that's a nice example -- I must remember to include that one in my macro talk in Erlangen.

[21:48] <masak> the whole trick to remaining sane when doing macros turns out to be to have a sharp eye for when different things in a program "activate".

[21:48] <jnthn> omg, I have to write a talk for Erlangen :)

[21:48] <masak> things may be right next to each other, but if one is run-mode and the other is compile-mode, they will not fire adjacent in time.

[21:48] <masak> great fun.

[21:49] <masak> mwhahaha

[21:50] *** SHODAN left
[21:50] *** seanstickle left
[21:52] *** SHODAN joined
[21:55] *** pmurias left
[22:14] *** havenn left
[22:15] *** fsergot left
[22:17] <cognominal> nom: grammar G { token TOP { [<a>|<b>]+ }; token a { a }; token b { b} }; say G.parse: 'ababb'

[22:17] <p6eval> nom c295b5: OUTPUT«=> <ababb>␤ b => <b>␤ b => <b>␤ b => <b>␤␤»

[22:18] <cognominal> something around the grammar engine seems seriously broken.

[22:19] *** icwiener left
[22:20] *** ribayr left
[22:23] <cognominal> good night

[22:24] *** Trashlord joined
[22:26] *** snearch left
[22:29] *** Tedd1 left
[22:45] *** ribayr joined
[22:49] *** plobsing left
[22:51] <masak> good night, #perl6

[23:15] *** PacoAir left
[23:19] <colomon> o/

[23:19] <sorear> o/ colomon

[23:21] *** Trashlord left
[23:21] <colomon> sorear: what do you think of system.diagnostics.process?

[23:22] <sorear> I think it's a pretty good wrapper for the Windows process-control functions

[23:22] <sorear> but it fails moderately hard for POSIX

[23:22] <colomon> I was wondering if it might make sense to use it as a backup for the run sub if GLib isn't available.

[23:22] <sorear> I don't think Microsoft can be faulted for designing APIs that work well on their own systems

[23:22] <sorear> yes, it would.

[23:23] <sorear> au was talking about some kind of shell quoting thing earlier

[23:23] <colomon> to the backlog!

[23:23] <sorear> I am not really an expert on shell diversity

[23:23] *** dorlamm joined
[23:23] * colomon is glad to have au around more regularly again

[23:23] <sorear> we need to find some autoconf geeks and some cmd.exe geeks

[23:23] <sorear> agreed

[23:23] *** Trashlord joined
[23:24] *** Trashlord is now known as Guest17202

[23:24] <jnthn> cmd.exe isn't cool enough to have geeks :)

[23:24] <jnthn> In short - don't even think about trying to quote stuff using single quotes. :) Only doubles work. :)

[23:28] *** franek joined
[23:29] *** dorlamm left
[23:30] <colomon> sorear: I've gone back in the logs to the 23rd, haven't seen au talking about shells yet...

[23:30] <colomon> err, shelling out, I mean.

[23:30] <sorear> ShellQuote

[23:30] <sorear> 2012.02.18.13.48.09 < au> yeah, one'd need a String::ShellQuote equivalent.

[23:30] <sorear> 23rd of which month?

[23:31] <colomon> this month

[23:31] <colomon> but going backwards

[23:31] *** plobsing joined
[23:32] *** Chillance left
[23:32] *** carlos joined
[23:32] *** franek left
[23:32] <colomon> "Only Bourne shell quoting is supported.  I'd like to add other shells

[23:32] <colomon> (particularly cmd.exe), but I'm not familiar with them.  It would be a

[23:32] <colomon> big help if somebody supplied the details."

[23:32] <colomon> groan

[23:32] *** carlos is now known as Guest67167

[23:34] <sorear> I did not mean to imply that it would be _useful_.

[23:34] <colomon> snort

[23:34] <[Coke]> (pugs fossils) which pugs is now running again!

[23:35] <colomon> actually, I'm not sure the other way around wouldn't be more useful -- properly breaking up a command line into command and arguments

[23:37] * jnthn wanders afk...'night 

[23:37] <colomon> 'night

[23:45] *** ribayr left
[23:51] *** Guest67167 left
[23:56] *** tokuhirom joined
[23:59] <[Coke]> # 02/26/2012 - niecza++ ; pugs (22.81%); rakudo (99.2%)

[23:59] <[Coke]> "niecza",     20298,     8,   751,  1548, 22601, 23646

[23:59] <[Coke]> "pugs"  ,      4632,     5,  1999,   332,  6968, 23437

[23:59] <[Coke]> "rakudo",     20136,    28,   604,  1864, 22632, 23656

