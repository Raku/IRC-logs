[00:16] *** thou left
[00:25] *** thou joined
[00:26] <sorear> good * #perl6

[00:29] *** aindilis joined
[00:37] *** icwiener left
[00:43] *** thou left
[00:48] *** whiteknight joined
[00:53] *** PacoAir joined
[00:57] *** PacoAir left
[01:11] <colomon> o/

[01:13] *** scott_ joined
[01:13] *** scott_ is now known as Guest93514

[01:14] <sorear> o/ colomon

[01:15] <colomon> how's school going?

[01:33] *** benabik joined
[01:35] <sorear> ok

[01:45] *** raoul left
[01:54] *** tokuhir__ joined
[01:57] *** tokuhir__ left
[02:17] *** pomysl left
[02:21] *** isBEKaml left
[02:23] *** raoul joined
[02:23] *** wolfman2000 joined
[02:35] *** pomysl joined
[02:35] *** pomysl left
[02:35] *** pomysl joined
[02:38] *** lestrrat left
[02:40] *** lestrrat joined
[02:47] *** raoul left
[03:02] *** whiteknight left
[03:04] *** pomysl left
[03:04] *** pomysl joined
[03:04] *** pomysl left
[03:04] *** pomysl joined
[03:09] *** replore joined
[03:33] *** orafu left
[03:33] *** orafu joined
[03:41] *** sftp_ left
[03:57] *** xinming joined
[04:04] *** awoodland left
[04:10] *** xinming left
[04:11] *** xinming joined
[04:18] *** jferrero left
[04:51] *** dj_goku joined
[04:54] <dj_goku> I ran make rakudo-spectest with 2012.1 rakudo-star on osx lion , and I have failures: http://paste.scsys.co.uk/182331 I googled, but didn't see anything.

[04:56] <Teratogen> nom: 1+1

[04:56] <p6eval> nom f9fcb2:  ( no output )

[04:57] <Teratogen> nom: say 1+1

[04:57] <p6eval> nom f9fcb2: OUTPUT«2␤»

[04:57] <Teratogen> good, that works

[05:00] <sorear> dj_goku: this isn't necessarily a problem

[05:03] <sorear> dj_goku: most of those test files use is_run, which is known to be fragile

[05:03] <Teratogen> nom: say e**(pi*i)

[05:04] <p6eval> nom f9fcb2: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&i' called (line 1)␤»

[05:04] <Teratogen> baw

[05:04] *** replore left
[05:04] *** replore__ joined
[05:04] <geekosaur> nom: say e**(pi*1i)

[05:04] <p6eval> nom f9fcb2: OUTPUT«-1+1.80886962109647e-09i␤»

[05:04] <geekosaur> ...

[05:05] <sorear> what, geekosaur?

[05:06] <sorear> nom: say sin pi

[05:06] <p6eval> nom f9fcb2: OUTPUT«3.58979347393082e-09␤»

[05:06] <geekosaur> mmm, point

[05:06] <geekosaur> rather, *floating* point.  feh

[05:06] <sorear> nom: say atan(1)*4

[05:06] <p6eval> nom f9fcb2: OUTPUT«3.14159265358979␤»

[05:06] <sorear> nom: say atan(1)*4 - pi

[05:06] <p6eval> nom f9fcb2: OUTPUT«3.58979335146614e-09␤»

[05:06] <sorear> nom: say pi

[05:06] <p6eval> nom f9fcb2: OUTPUT«3.14159265␤»

[05:07] <sorear> nom: say pi.WHAT

[05:07] <p6eval> nom f9fcb2: OUTPUT«Num()␤»

[05:07] <sorear> so... it looks like nom's pi doesn't even have double precision

[05:07] <sorear> niecza: say e**(pi*i)

[05:07] <p6eval> niecza v14-42-g1d02da9: OUTPUT«-1+1.2246063538223773E-16i␤»

[05:07] <geekosaur> closer at least

[05:07] <sorear> easy fix I'm sure to get the precision of pi closer to machine epsilon

[05:08] <dj_goku> sorear: alright, I'll take your word. :D Just thought I would ask anyways.

[05:10] <sorear> dj_goku: I'm not certain what all of those errors are, it might be worth putting a full log up someone for a rakudo person to look at

[05:12] <dj_goku> alright. by rakudo person, you mean someone in here?

[05:14] <sorear> yeah

[05:14] <sorear> like pretty much anyone who isn't me :p

[05:14] <dj_goku> haha

[05:18] <dj_goku> http://paste.scsys.co.uk/182332

[05:22] *** s1n left
[05:25] *** hypolin joined
[05:26] *** kaleem joined
[05:56] *** alvis left
[06:01] *** woosley joined
[06:11] *** replore__ left
[06:23] *** pat_js joined
[06:23] *** amirite joined
[06:24] <pat_js> hi

[06:26] <sorear> Hello, and welcome, pat_js.

[06:26] <pat_js> i had written a solution for the knapsack1-0 problem for rosettacode last October and now it doesn't work anymore.

[06:27] <pat_js> (with an more actual rakudo)

[06:27] <pat_js> can someone hint me what's wrong with it?

[06:27] <pat_js> http://rosettacode.org/wiki/Knapsack_problem/0-1#Perl_6

[06:28] <sorear> hrm, I remember TimToady was doing lots yesterday with knapsacks

[06:28] <moritz> o\

[06:28] <sorear> o/

[06:29] <pat_js> yeah i wrote a solution for the unbounded problem and he made it work with niecza and tweaked the style 

[06:31] <pat_js> rakudo says a type check failed

[06:33] <moritz> my @skip := func(...)

[06:33] <moritz> but one of the cases returns $v, which is an integer

[06:33] *** REPLeffect joined
[06:33] * araujo looks in

[06:34] <moritz> and it was a bug in older rakudos that you could bind an Int to an @-sigiled variabled

[06:35] <pat_js> yeah, func returns an Int and a @ary of strings

[06:36] <moritz> then you should just assign its return value to @skip, not binding to it

[06:36] <moritz> how long should a run of that script take?

[06:37] <pat_js> it took like forever 

[06:39] *** GlitchMr joined
[06:39] <pat_js> ah ok but it's really just that binding, if i replace it with an assingment it works

[06:39] <pat_js> with a smaller dataset.

[06:40] <pat_js> I just thought binding would be faster than assingning

[06:40] *** MayDaniel joined
[06:40] *** MayDaniel left
[06:44] <pat_js> is there a way to profile perl6 code? i really would like to know what exactly take so long

[06:48] <sorear> so would I

[06:49] <moritz> pat_js: use the --profile  option to rakudo

[06:49] <moritz> though maybe we should reduce the problem size a bit

[06:54] *** birdwindupbird joined
[06:56] *** pomysl left
[06:56] <pat_js> yeah i did that (smaller problem size and --profile) is there a formatter for the output?

[06:56] *** pomysl joined
[06:56] <moritz> pipe stderr into a file, and then run  kcachegrind $file

[06:57] <moritz> about 40% run time in the list iteration code

[06:57] <pat_js> first i'd need kcachegrind

[06:57] <moritz> correct

[06:58] *** wtw joined
[06:58] *** alvis joined
[06:58] <sorear> get kcachegrind

[06:59] <sorear> it's not as scary as you think

[07:00] <pat_js> funny thing is heared about it at the last perlmongers thing and thought about installing it some time, but forgot about it

[07:01] <sorear> for some reason a lot of people come here thinking that installing kcachegrind requires switching your system to use KDE

[07:02] <pat_js> it does not, but installing kcachegrind requires a lot of kde programms to be installed

[07:07] *** tarch joined
[07:14] <pat_js> what's <cycle 3> in there?

[07:14] <pat_js> in kcachegrind?

[07:19] <pat_js> could it be that the list dispatching is slow?

[07:27] <bonsaikitten> sorear: hrm. I'm trying to build niecza for fun, you apparently don't have any source archives on the github page

[07:34] <sorear> source archives?

[07:34] <bonsaikitten> sorear: yes, so that I can build a release and not have to abuse git

[07:34] *** Tyrskaegg joined
[07:35] <bonsaikitten> for head it's ok, but I don't want precompiled sauce but also don't like to use git for static checkouts

[07:35] <sorear> I think there is an option on the download page for getting any branch head or tag as .tar.gz

[07:35] *** snearch joined
[07:35] <sorear> and all the releases are tagged

[07:36] <bonsaikitten> hrmkay, let's see if I can motivate github without wanting to get drunk again

[07:36] <sorear> warning: when you type "make", the Makefile will automatically download and install the latest binary release, because niecza requires itself to build

[07:36] <sorear> s/latest/matching/

[07:37] <bonsaikitten> that I can patch (seen that in the build instructions)

[07:37] <sorear> patch?

[07:38] <bonsaikitten> <-- distro maintainer

[07:38] <bonsaikitten> I'm used to making bad makefiles play nice

[07:38] <bonsaikitten> no worries, I play a doctor on the internet

[07:39] <sorear> ahahaha.

[07:40] <sorear> If you're trying to make a source-only niecza ebuild, I look forward to seeing what you come up with.

[07:40] <sorear> I can't say I'm entirely a fan of this bootstrapping thing, but Perl 6 rules are the only sane way to parse Perl 6...

[07:41] <bonsaikitten> I guess the proper way is a niecza-bin ebuild and then depend on || ( niecza niecza-bin )

[07:41] <bonsaikitten> same way you used to bootstrap icedtea and ghc

[07:41] <sorear> you should...right

[07:42] <sorear> I'm a ghc user, I have some familiarity with how they do things

[07:42] <sorear> (I am *not* a gentoo user)

[07:42] <bonsaikitten> you should be

[07:42] <bonsaikitten> much less effort :)

[07:42] * bonsaikitten dislikes compiling

[07:43] <sorear> switching would be effort.  I've been using debian since 2003, and all the options I (knew I) had were slackware, debian, and red hat

[07:43] <bonsaikitten> mmh yes

[07:43] <bonsaikitten> I dislike having to recompile almost everything to get sane defaults on debian - like the bash that used to not have netdevices

[07:44] <bonsaikitten> apart from that it's an okish distro

[07:46] <sorear> I'm a weird special case anyway

[07:46] <sorear> (like, "I'm using a WM I co-wrote" levels of weird special)

[07:46] <bonsaikitten> ya, I'm more of a "released software is stale" person that hits every bug, and I'm lazy

[07:48] <sorear> for some irrational reason I'm disgusted with how much xmonad has been popularized

[07:49] <bonsaikitten> I'm a silly KDE user, I do not understand xmonad

[07:49] <bonsaikitten> same way I'm unable to play vi

[07:52] <pat_js> rakudo: multi foo(0){say "o!"}; multi foo(Int $x){say $x}; foo();

[07:52] <p6eval> rakudo f9fcb2: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'foo' will never work with no arguments (line 1)␤    Expected any of:␤    :(Int )␤    :(Int $x)␤»

[07:52] *** Trashlord left
[07:53] <pat_js> sorry

[07:53] <sorear> sorry?

[07:53] <pat_js>  rakudo: multi foo(-1){say "-1!"}; multi foo(Int $x){say $x}; foo(-1)

[07:53] <p6eval> rakudo f9fcb2: OUTPUT«===SORRY!===␤Malformed parameter at line 1, near "-1){say \"-"␤»

[07:53] <sorear> you did nothing to warrant an apology

[07:54] <pat_js> for abusing the public channel for chatting with the evalbot

[07:54] <pat_js> is it a bug or a feature that you cant have negative literals in parameter declarations

[07:55] <pat_js> i think it might be because - being an unary prefix op and not some magical maybe a constructor 

[07:56] <sorear> "Malformed parameter" means that the parser itself is confused

[07:56] <sorear> I think that it is a prefix thing

[07:56] <sorear> rakudo: :(-1)

[07:56] <p6eval> rakudo f9fcb2: OUTPUT«===SORRY!===␤Malformed parameter at line 1, near "-1)"␤»

[07:56] <sorear> rakudo: :(1)

[07:56] <p6eval> rakudo f9fcb2:  ( no output )

[07:56] <sorear> std: :(-1)

[07:56] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed parameter at /tmp/LITABtwBz9 line 1:␤------> [32m:([33m⏏[31m-1)[0m␤    expecting any of:␤      name␤   parameter␤      signature␤      statement end␤  statement list␤Parse failed␤FAILED 00:01 109m␤»

[07:56] <sorear> std rejects it, so it can't be a bug

[07:57] <sorear> anything std does it not a bug

[07:57] <sorear> unless Larry says it is a bug.  which happens sometimes...

[07:59] <pat_js> ah… 

[07:59] <pat_js> makes sense

[08:00] *** scott__ joined
[08:00] *** Guest93514 left
[08:01] <jnthn> Yeah. -1 is not a literal.

[08:01] <jnthn> morning btw :)

[08:02] <sorear> o/ jnthn 

[08:02] <sorear> jnthn: I need your help understanding OKness.

[08:04] <jnthn> sorear: Then you're going to have to wait until I understand it. :)

[08:05] * jnthn spent a good chunk of his train journey to Stockholm yesterday pondering it.

[08:05] <jnthn> At one point I was wondering whether scalar containers and OKness may be two versions of some underlying primitive, but that got uncomfy pretty fast.

[08:06] <jnthn> Now I'm on to wondering if it's after the same primitives one would want for making objects from one langauge behave like those of another...

[08:06] <jnthn> ...and whether TimToady is thinking of a flattening mechanism or something really delegational.

[08:07] * jnthn normally goes to the park to do design work, but it's -12C out. :)

[08:07] <jnthn> ...plus I have to teach a class for the next couple of days :)

[08:09] * sorear wonders whether to be happy or annoyed that here it's also a very cold day ~ +5C

[08:10] * sorear imagines jnthn setting sleep dep records while teaching said class

[08:10] <jnthn> meh, +5 isn't cold! :P

[08:10] <bonsaikitten> jnthn: all a matter of perspective

[08:10] <bonsaikitten> jnthn: if you have no heating it's frustratingly cold!

[08:10] <jnthn> bonsaikitten: Very true!

[08:11] * bonsaikitten doesn't appreciate the lack of central heating in Shanghai

[08:11] <sorear> also depends on latitude

[08:11] <sorear> and elevation

[08:12] <sorear> I live on the coast at 34N

[08:12] * jnthn remembers being in Shanghai, some years ago. :)

[08:13] <sorear> the widest span of temps I've seen is +2 to +40 or so

[08:13] <jnthn> +40 is...outside the range of temperatures I can cope with. :)

[08:13] <sorear> me too.

[08:13] <sorear> part of why I like the idea of moving to Sweden so much.

[08:13] <jnthn> +35 in Beijing last summer was more than enough. 

[08:14] <jnthn> sorear: We're hiring! ;)

[08:14] <sorear> although a couple years ago a Finnish friend of mine was complaining about +38 weather

[08:14] <sorear> which, I hear, is a little out of the ordinary for .fi

[08:15] <jnthn> Yes, sounds like.

[08:17] <bonsaikitten> I like ~30C, that's when life becomes happy

[08:17] <sorear> part of the problem is doubtless the fact that my house has no insulation to speak of

[08:19] <sorear> I guess the builders wanted people to fully experience the famous San Diego weather

[08:22] <bonsaikitten> sorear: most of the world isn't up to german standards ;)

[08:23] *** mj41 joined
[08:24] <jnthn> German Perl Workshop soon :)

[08:24] <bonsaikitten> bit far away for me ...

[08:26] <jnthn> Not so far from here :)

[08:26] <jnthn> Though enough to fly it rather than take the train.

[08:30] *** jferrero joined
[08:36] <jnthn> ah, folks are here. time to teach 'em stuffs :)

[08:41] <sorear> Bit far for mee too :'(

[08:42] *** mucker joined
[08:49] *** Trashlord joined
[09:08] *** woosley left
[09:09] *** ab5tract joined
[09:13] *** am0c joined
[09:18] *** lestrrat left
[09:19] *** lestrrat joined
[09:35] *** pat_js left
[09:50] <moritz> jnthn: what's the difference between PAST::Stmt and PAST::Stmts ?

[09:51] *** GlitchMr left
[09:51] <masak> morgningz.

[09:51] <masak> moritz: PAST::Stmts can contain several PAST::Stmt?

[09:52] <moritz> masak: it seems that both can contain multiple PAST nodes.

[09:53] <masak> yes. I didn't say they couldn't.

[09:53] *** dakkar joined
[09:54] <moritz> I've thought more about adding &sink calls

[09:54] <moritz> there are basically two approaches

[09:54] <moritz> whitelisting and blacklisting

[09:55] <moritz> thing is, we don't want &sink calls to the result of assignment, binding, and literals (for example)

[09:55] <moritz> currently I lean towards whitelisting, because the blacklist might get long

[09:55] <moritz> what do we call &sink on?

[09:56] <moritz> subroutine calls, method calls, variables

[09:56] <moritz> anything else?

[09:57] <masak> in the field of security, blacklisting is frowned upon, not just because the blacklist may get long, but because omissions in the blacklist translate to security holes.

[09:57] <masak> here I would guess it translates to wrong semantics, which isn't so good either.

[09:57] <moritz> well, both blacklisting and whitelisting lead to wrong semantics if done wrong

[09:57] <masak> ...but not worse than omitting something from the whitelist. :) hm.

[10:00] *** xinming left
[10:00] *** tarch left
[10:00] *** tarch_ joined
[10:01] *** xinming joined
[10:04] *** hypolin left
[10:08] <moritz> meh.

[10:08] <moritz> what happens when you add code to add &sink calls, and then compile the setting?

[10:08] <moritz> the quiz is open.

[10:13] <moritz> ok, I'll solve it for you. There's no &sink defined yet.

[10:15] <moritz> nom: &sink.()

[10:15] <p6eval> nom f9fcb2: OUTPUT«===SORRY!===␤Symbol '&sink' not predeclared in <anonymous> (/tmp/GO_fsyjBXL:1)␤»

[10:15] <masak> d'oh!

[10:15] <jnthn> moritz: Stmt is newer, and also a register allocation boundary

[10:16] <jnthn> So any temps are freely re-used afterwards

[10:16] <moritz> jnthn: ok, thanks

[10:19] <masak> oh!

[10:19] * masak guessed completely wrong, then :)

[10:19] <jnthn> ;)

[10:20] <moritz> ok, I'm now trying to emit &sink only if &sink is in lexical scope during comp_unit

[10:21] <jnthn> .oO( my $*SINKING_FEELING; )

[10:21] <moritz> the work is done in Perl6::Sinker :-)

[10:21] <jnthn> moritz: Thing is that by the end of compiling the setting...it will be :)

[10:22] <jnthn> But I guess you know that and are setting it in comp_unit in teh grammar, after setting loading is done.

[10:22] <moritz> I wasn't aware of it

[10:23] <jnthn> moritz: ah, ok

[10:23] <jnthn> then yeah, chekcing in comp_unit action would be too late :)

[10:23] <jnthn> I guess you'll use $*W.find_symbol, wrapped in a try block...

[10:23] <moritz> I'm trying $*W.is_lexical

[10:24] <jnthn> oh

[10:24] <jnthn> that'll work fine too

[10:24] <jnthn> better in fact :)_

[10:24] <moritz> and it does seem to work... except that I now get an infinite recursion

[10:24] <jnthn> not that it needs the &

[10:24] <jnthn> *note

[10:24] <moritz> I know

[10:24] <jnthn> ouch...where? :)

[10:25] <moritz> I've added a  sub sink($x) { $x.?sink; Nil }

[10:25] <moritz> https://gist.github.com/f2e6456a406fe0db0956 is what I get

[10:25] <moritz> maybe I'm adding sink calls to the insides of the sink?

[10:26] <moritz> so, the approach of checking in the actions really doesn't seem to work

[10:26] <moritz> hm

[10:27] <moritz> so I do need to make the check in grammar earlier

[10:28] <jnthn> yes, or you'll be sunk

[10:30] *** birdwind1pbird joined
[10:30] <moritz> I wonder if literals in sink context should warn

[10:31] <jnthn> probably yes :)

[10:31] <moritz> I also wonder if variables should be put in sink context

[10:31] <jnthn> Not sure on that one

[10:32] <moritz> it feels unnecessarily magic if    my @a = ...; @a;  does somethinge else than just  my @a = ...;

[10:32] <moritz> you *can* write  sink @a; if that's what you mean.

[10:34] *** JimmyZ joined
[10:37] <jnthn> lunch here

[10:43] <masak> interesting read about the scales of data access for a CPU: https://plus.google.com/112493031290529814667/posts/LvhVwngPqSC

[10:51] *** aindilis left
[10:54] *** birdwind1pbird left
[11:01] *** xinming left
[11:07] *** xinming joined
[11:07] *** mtths left
[11:08] *** tarch_ left
[11:15] *** am0c left
[11:15] <jnthn> masak: Thus why hitting on the cache is so important. :)

[11:16] *** scott__ left
[11:17] * masak .oO( "hey cache, you come here often?" )

[11:18] *** [particle] left
[11:20] *** [particle] joined
[11:20] <jnthn> er, s/on//

[11:20] <jnthn> what was I thinking... 

[11:25] *** Siddy joined
[11:26] *** Trashlord left
[11:28] *** pernatiy left
[11:29] <masak> nom: my @a = 1 xx 10; for ^10 { say @a; my @b = 1; for @a[2..*] { push @b, $_ + @b[*-1] }; @a = @b }

[11:29] <p6eval> nom f9fcb2: OUTPUT«1 1 1 1 1 1 1 1 1 1␤1 2 3 4 5 6 7 8 9␤1 4 8 13 19 26 34 43␤1 9 22 41 67 101 144␤1 23 64 131 232 376␤1 65 196 428 804␤1 197 625 1429␤1 626 2055␤1 2056␤1␤»

[11:29] <masak> (yup, still thinking about balanced strings) :)

[11:29] <moritz> are those the right numbers?

[11:30] <masak> yes.

[11:30] <masak> and that's the simplest way I know to construct them.

[11:30] <moritz> neat

[11:32] *** Siddy is now known as Trashlord

[11:34] *** PZt left
[11:35] *** daxim joined
[11:39] *** tarch_ joined
[11:42] *** PZt joined
[11:46] <flussence> whoa, rakudo has a --profile option? how long's that been there?

[11:56] *** am0c joined
[12:07] *** snearch left
[12:07] *** fsergot left
[12:08] *** Trashlord left
[12:14] *** pernatiy joined
[12:15] <jnthn> flussence: months :)

[12:29] *** ilogger2 joined
[12:29] *** ChanServ sets mode: +v ilogger2

[12:29] *** literal joined
[12:31] <dalek> rakudo/sink: 21e7425 | moritz++ | src/Perl6/Sinker.pm:

[12:31] <dalek> rakudo/sink: no need to visit children of PAST::Op

[12:31] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/21e74251b4

[12:31] <dalek> rakudo/sink: d17935e | moritz++ | src/ (4 files):

[12:31] <dalek> rakudo/sink: Only sink if we know about &sink

[12:31] <dalek> rakudo/sink: 

[12:31] <dalek> rakudo/sink: Doesn't quite work it seems.

[12:31] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/d17935ed6a

[12:32] <moritz> somhow in https://github.com/rakudo/rakudo/commit/d17935ed6a $*HAS_SINK is always false, even when not compiling the setting, and I can't understand why

[12:33] <moritz> it's declared outside of comp_unit (in TOP), and initialized inside the comp_unit grammar rule, so it should persist to the comp_unit action method, no?

[12:34] <jnthn> $*HAS_SINK := $*W.is_lexical('&sink');

[12:34] <jnthn> I think that line may come too early

[12:34] <jnthn>  $/.CURSOR.unitstart();

[12:34] <jnthn> Think it needs to come after unitstart.

[12:34] *** MayDaniel joined
[12:34] <moritz> what does unitstart do?

[12:34] <jnthn> iirc, call SET_OUTER_CTX

[12:35] <moritz> ah.

[12:35] <moritz> indeed

[12:35] *** fsergot joined
[12:45] *** raoul joined
[12:46] <moritz> $ ./perl6 -e 'sub sink($) { say "sunk!" }; 1; 1;'

[12:46] <moritz> sunk!

[12:46] <moritz> sunk!

[12:46] <flussence> \o/

[12:47] <moritz> it's... still mostly wrong

[12:47] <colomon> but not entirely!  ;)

[12:48] <dalek> rakudo/sink: 48005a5 | moritz++ | src/Perl6/Grammar.pm:

[12:48] <dalek> rakudo/sink: fix $*HAS_SINK. jnthn++

[12:48] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/48005a5686

[12:51] *** leprevost joined
[12:58] * jnthn ponders that QAST nodes should have a :dba so we can set the semantic role that the node is playing, independent of wrapping

[12:59] <jnthn> So we can :dba('literal') whether it's a QAST::Val or a lookup in the SC constants table...

[13:00] <moritz> that sounds sane

[13:01] * jnthn occasionally comes up with sane things :)

[13:21] *** danishman joined
[13:34] *** kaleem joined
[13:37] <masak> moritz++ # free-sinker

[13:39] <dalek> rakudo/sink: a07582b | moritz++ | src/Perl6/ (2 files):

[13:39] <dalek> rakudo/sink: add nosink annotation

[13:39] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/a07582b9e2

[13:45] <Teratogen> nom: say 1 + 1

[13:45] <p6eval> nom f9fcb2: OUTPUT«2␤»

[13:45] <Teratogen> yay, it works!

[13:45] *** kaleem left
[13:46] <Teratogen> But shouldn't it just say "2"?

[13:46] <masak> Teratogen: using 'say' means that you want a newline at the end.

[13:46] <masak> nom: print 1 + 1

[13:46] <p6eval> nom f9fcb2: OUTPUT«2»

[13:46] <Teratogen> oh!

[13:46] <Teratogen> my xchat client definitely doesn't have the right character set encoding to display that whatever it is

[13:47] *** snearch joined
[13:47] <masak> the difference between 'print' and 'say' is the newline (and some other distracting and useless distinction that TimToady and moritz seem to like but that I don't see the use for)

[13:48] *** PZt joined
[13:52] <moritz> Teratogen: use UTF-8

[13:52] <moritz> $ ./perl6 -e 'class A { method sink() { say "sunk!" } }; A.new; 1'

[13:53] <moritz> for now it generally excludes the last statement of a block

[13:53] <moritz> because that's the return value, and the caller needs to handle its context

[13:53] <moritz> of course that's not true for the mainline, but I didn't special-case that yet

[13:54] *** Trashlord joined
[13:55] <masak> it's somewhat of a transitive thing, isn't it?

[13:55] <dalek> rakudo/sink: 822bef8 | moritz++ | src/core/control.pm:

[13:55] <dalek> rakudo/sink: fix sinko

[13:55] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/822bef8298

[13:55] <masak> the last statement of a block can be in sink context, depending on whether the calling statement is.

[13:56] <moritz> masak: well, that's one way to look at it

[13:56] <masak> so code can behave quite differently depending on how it's called. it's basically caller context propagating into the callee, but at a smaller scale than with Perl 5.

[13:57] <moritz> masak: the other way to look at it that the last statement of a block isn't in sink context, but the caller can still call &sink on the return value of that statement

[13:57] <moritz> which fits the "context flows outwards" view of Perl 6 much better, IMHO

[13:58] *** xinming joined
[13:58] <masak> that mental model feels to me like the &sink call happens "too late", though.

[13:59] <masak> because (for example) a for loop can produce hefty amounts of garbage data if it finds itself in a non-sink context.

[13:59] <moritz> erm, no

[13:59] <flussence> I guess it depends on having sufficient laziness

[13:59] <masak> and just calling &sink after it's returned all the garbage helps no-one.

[13:59] <moritz> a for-loop in non-sink context is lazy

[13:59] <moritz> and doesen't produce anything, except a lazy thunks

[13:59] <moritz> *thunk

[13:59] <masak> oh, right.

[13:59] <masak> that's even *more* confusing! :)

[14:00] <masak> but it's consistent with the rest of Perl 6, I guess.

[14:00] <moritz> sink context is there to make for-loops less confusing :-)

[14:00] <flussence> it makes more sense if you start at the end of the program and work backwards :)

[14:00] *** raoul left
[14:01] <masak> nom: sub foo { for ^100 { say "OH NOES" when /99/; $_ } }; say foo[42]

[14:01] <p6eval> nom f9fcb2: OUTPUT«OH NOES␤42␤»

[14:01] <masak> /o\

[14:02] <moritz> well, that's the old behavior, which I want to change

[14:02] <masak> nodnod

[14:03] * moritz spectests first

[14:04] <masak> has anyone ever made the parallel between binding and quantum entanglement?

[14:04] <jnthn> Note that eager context and sink context are different. Sink context should make a for loop (or map) not build a result list

[14:04] <jnthn> Note that this can work becasue a for or map on its own does absolutely nothing until you ask it for results.

[14:05] <masak> still, it feels to me that both sinkness and eagerness propagate inwards into callees.

[14:07] <masak> the &map code called by the 'for' loop needs to be aware that it's in sink context, and not build the result list.

[14:08] <jnthn> no

[14:08] <jnthn> &map returns a MapIter *immediately*. It doesn't do any work itself.

[14:08] <jnthn> That iterator has .sink called on it.

[14:09] <masak> oh!

[14:09] <moritz> and the problem with the current factoring is that it has .eager and not .sink called on it

[14:09] <jnthn> right. which is why it keeps date for too long

[14:09] *** tokuhirom joined
[14:09] <masak> so... there's some kind of dependency injection going on here that puts the caller in control. nice.

[14:09] <moritz> which means we can never GC return values of the loop, even in sink context

[14:10] <masak> or would that be "reverse dependency injection"? hm.

[14:10] *** xinming left
[14:13] <masak> nom: MapIter; say "alive"

[14:13] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[14:13] <masak> nom: say MapIter.^methods

[14:13] <p6eval> nom f9fcb2: OUTPUT«new BUILD reify DUMP iterator list flat elems infinite item fmt Int Num chrs Numeric Str␤»

[14:14] <jnthn> masak: I lied a bit - the MapIter isn't returned itself, but rather a List with a MapIter in its unreified portion

[14:14] <masak> ah, so the MapIter is a sort of "promise" of a future calculation?

[14:15] <masak> like in HOP :)

[14:15] <masak> er, the MJD book, I mean.

[14:15] <lumi___> Wouldn't the masak-type sink be easier to optimize?

[14:16] *** xinming joined
[14:16] <jnthn> masak: kinda like that, yet

[14:17] <jnthn> If you mean what I think you mean, anyway :)

[14:17] <moritz> lumi___: the reason we abolished inward flowing context is that it doesn't mix with multi dispatch

[14:18] <moritz> multi a() { }; multi a(Str $x) { }; a(b()) # is &b in sink context or in Str context here?

[14:19] *** tokuhirom left
[14:19] *** tokuhir__ joined
[14:19] *** Trashlord left
[14:21] <lumi___> moritz: Oh, I see

[14:21] <lumi___> So sink context mustn't affect the return value, so the callee can't know it, right?

[14:22] <moritz> the caller imposes the sink context on the return value (or it doesn't)

[14:23] <masak> moritz: I don't get your example. clearly &b can't be in sink context there, since its return value is passed on to &a.

[14:24] *** tokuhir__ left
[14:24] <moritz> eval: use Data::Dumper; sub a { print Dumper wantarray }; sub b() { }; b a

[14:24] <buubot_backup> moritz: ERROR: syntax error at (eval 20) line 2, near "b a " 

[14:24] <moritz> eval: use Data::Dumper; sub a { print Dumper wantarray }; sub b() { }; b(a)

[14:24] <buubot_backup> moritz: ERROR: Too many arguments for main::b at (eval 20) line 2, near "a) " 

[14:24] <moritz> eval: use Data::Dumper; sub a { print Dumper wantarray; return }; sub b() { }; b(a)

[14:24] <buubot_backup> moritz: ERROR: Too many arguments for main::b at (eval 20) line 2, near "a) " 

[14:25] <moritz> why too many arguments, if a returns the empty list?

[14:25] <masak> doesn't compile, probably even syntactically incorrect.

[14:25] <masak> you're essentially saying that &b syntactically doesn't have any arguments.

[14:25] <moritz> right

[14:25] <masak> not a big problem in practice, I guess :)

[14:26] <moritz> aye

[14:26] <moritz> because p5 doesn't have multi dispatch

[14:27] <moritz> but if the caller is a multi with a nullary candidate, there is a case where it wants the callee to return 0 args. Which is the same as sink context, no?

[14:27] <masak> I don't know.

[14:27] *** leprevost left
[14:28] <masak> feels like there is a slight qualitative difference between returning Nil and returning ()

[14:28] <[Coke]> "./perl6 --profile foo.p6" - runs the program and THEN complains about the profile option.

[14:28] <masak> [Coke]: that's how fast it is! :P

[14:28] <moritz> complains?

[14:28] <moritz> it writes the profile to STDERR

[14:28] <[Coke]> masak++ #print vs. say

[14:29] *** sftp joined
[14:29] <[Coke]> (nd if you try to use the usage it suggests, you get an immediate usage error.)

[14:31] <dalek> rakudo/sink: 6ca381c | moritz++ | src/ (2 files):

[14:31] <dalek> rakudo/sink: make for-loops lazy, unless in sink context

[14:31] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/6ca381c623

[14:31] *** sftp left
[14:34] <moritz> oops. That commit breaks 'use Test;'

[14:34] <jnthn> Wow!

[14:35] *** PacoAir joined
[14:39] <moritz> oh, and the previous one broke dynamic vars

[14:39] <moritz> urks.

[14:40] <jnthn> moritz: if you're not applying sink context in the setting then it'll break for loops...

[14:41] <moritz> jnthn: oh right. Ouch.

[14:41] <lumi___> moritz: Actually I don't see how any signature can bind successfully and still give a sink context

[14:41] <jnthn> moritz: Why can we not apply it in the setting?

[14:41] <jnthn> I mean, if it's written early on...

[14:42] <jnthn> oh, other than the infinite recursion issue..

[14:42] <moritz> well, that one was the real reason

[14:42] <jnthn> But most things in the setting don't run until after the setting is compiled

[14:43] *** lateau_ joined
[14:43] <jnthn> moritz: Maybe just disable sink if we're inside a routien called sink ;)

[14:44] <moritz> jnthn: it would feel righter to declare &sink in BOOTSTRAP.pm

[14:44] <moritz> jnthn: is that feasible?

[14:45] <jnthn> moritz: Only if you construct the Routine object by hand and add it to the export list

[14:45] <jnthn> Well, Sub object

[14:45] <jnthn> But yeah, seems possible

[14:45] <kcw> is there any way to get an unbound class method? or does that even make sense the way p6 treats types?

[14:46] <moritz> kcw: what's an "unbound" class method?

[14:46] <kcw> a method from a class that isn't attached to any specific instance of the class

[14:47] <moritz> you can just write a method that doesn't access any attributes

[14:47] <moritz> then it works as such a method

[14:47] <moritz> nom: class A { method speak() { say '\\o kcw' } }; A.speak

[14:47] <p6eval> nom f9fcb2: OUTPUT«\o kcw␤»

[14:48] <kcw> I mean to do things like "my $func = Str.say; my Str $x = 'text'; $func($x)"

[14:48] <masak> kcw: doing it that way calls the method.

[14:49] <masak> but it can be done without much trouble with a different syntax.

[14:49] <kcw> ^ ok; that's what I was looking for

[14:49] <masak> nom: say Str.can("say")

[14:49] <p6eval> nom f9fcb2: OUTPUT«say␤»

[14:49] <moritz> nom: my ($func) = Str.can('say'); $func('foo')

[14:49] <p6eval> nom f9fcb2: OUTPUT«foo␤»

[14:49] <masak> nom: say Str.can("say").^name

[14:49] <p6eval> nom f9fcb2: OUTPUT«Parcel␤»

[14:49] <masak> nom: say Str.can("say")[0].^name

[14:49] <p6eval> nom f9fcb2: OUTPUT«Method␤»

[14:50] <masak> moritz++ # already knew what I was figgering out

[14:50] <moritz> note that it also works the other way round:

[14:50] <moritz> nom: 'foo'.&say

[14:50] <p6eval> nom f9fcb2: OUTPUT«foo␤»

[14:50] <masak> nom: my ($func) = Str.can('say'); $func(42)

[14:50] <p6eval> nom f9fcb2: OUTPUT«42␤»

[14:50] <masak> ooh!

[14:51] <masak> and that's *correct*, because the method .say is on Any :)

[14:51] <PerlJam> greetings

[14:51] <masak> PerlJam! \o/

[14:52] <moritz> masak: but you shouldn't rely on it, because the compiler might add an optimized 'say'-method to Str

[14:52] *** mikemol joined
[14:53] *** lateau_ left
[14:55] *** mikemol left
[14:55] *** mikemol joined
[14:56] *** thou joined
[14:58] * masak ponders this from a Liskov perspective

[14:58] *** sftp joined
[14:58] <masak> generalizing, that means that whenever I fetch out a method like that, there's really nothing I can say about how narrow or wide the invocant type can be, except that it must contain the type I got it from.

[14:59] *** tarch__ joined
[15:00] <moritz> which is a statement about its wideness (it's wide enough to accept the invocant type) :-)

[15:02] *** noam joined
[15:02] *** mikemol left
[15:03] <masak> in Java generics terminology, it's <? super Str> (for some value of Str).

[15:03] *** mikemol joined
[15:04] *** MayDaniel left
[15:06] *** tarch joined
[15:07] *** tarch__ left
[15:08] *** sftp left
[15:10] *** snearch left
[15:11] <[Coke]> moritz: profile doesn't play well with MAINs with signatures.

[15:11] <[Coke]> oh. yes it does.

[15:12] <[Coke]> (this random .p6 had a MAIN and invoked MAIN. something is confused, but it's probably not --profile)

[15:13] * flussence wants --profile[=<fileno>] instead of always going to stderr

[15:13] *** sftp joined
[15:13] * masak wants to watch http://vimeo.com/36579366 but has to wait until he gets home -- it looks promising!

[15:13] <moritz> flussence: then patch it. Shouldn't be too hard, I think

[15:14] <masak> it's by the http://worrydream.com/LadderOfAbstraction/ guy.

[15:14] <flussence> hm, maybe that should be file *name*, I'm not sure how well multiple fd's works outside linux...

[15:14] <moritz> file name would be more intuitive

[15:14] <flussence> and I might give it a go, after $dayjob :)

[15:17] <jnthn> Note that instead of .can you can also .^find_method :)

[15:18] <Teratogen> .tincan

[15:18] *** leprevost joined
[15:18] <jnthn> .beercan

[15:22] *** MayDaniel joined
[15:25] <masak> .can-can

[15:25] <flussence> .can't

[15:26] <[Coke]> # 02/16/2012 - niecza at 99.88%

[15:26] <[Coke]> "niecza",     20055,     8,   751,  1573, 22387, 23257

[15:26] <[Coke]> "rakudo",     20078,    28,   610,  1863, 22579, 23267

[15:28] <jnthn> nom: use MONKEY_TYPING; augment class Mu { method can't($name) { !self.can($name) } }; say FatRat.can't('fit-in-small-holes')

[15:28] <p6eval> nom f9fcb2: OUTPUT«True␤»

[15:28] <jnthn> \o/

[15:28] <masak> :P

[15:28] <masak> nom: use MONKEY_TYPING; augment class Mu { method can't($name) { !self.can($name) } }; say Num.can't('floor')

[15:28] <p6eval> nom f9fcb2: OUTPUT«False␤»

[15:28] <masak> \o/

[15:29] <jnthn> oh

[15:29] <jnthn> For my GPW meta-programming talk, I should make a custom meta-class that, for all Bool returning methods, adds an inverse. :)

[15:30] <[Coke]> shouldn't

[15:30] <jnthn> :P

[15:30] <jnthn> It's *really* easy to do :)

[15:31] <moritz> even I would manage that, I think

[15:31] <[Coke]> wouldn't

[15:32] <jnthn> method add_method($obj, $name, $code) { callsame; if $code.returns === Bool { self.add_method($obj, $name ~ "'t", method (|$c) { !$code(|$c) }) } }

[15:33] <masak> won't that recurse forever?

[15:34] <masak> hm, maybe not, since the call doesn't add a method which explicitly returns a Bool.

[15:34] <jnthn> No, because I didn't put "returns Bool" on the generated method :)

[15:34] <masak> right.

[15:35] <[Coke]> what if you have an analyzer smart enough to determine that it does return bool even if you don't declare it?

[15:35] <[Coke]> (would that get ignored?)

[15:35] <jnthn> [Coke]: I suspect that'd be optimizer space, and optimization happens after method addition I guess.

[15:36] <jnthn> Plus I'm not sure if we should go adding traits the user didn't declare.

[15:36] <masak> not by default, no.

[15:36] <jnthn> True. All's fair if... :)

[15:41] *** alester joined
[15:42] *** benabik joined
[15:43] *** MayDaniel left
[15:43] *** Psyche^ joined
[15:44] *** kaleem joined
[15:47] *** Psyche^ is now known as Patterner

[15:51] *** jferrero joined
[15:58] *** jaldhar joined
[16:06] <moritz> http://appft1.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&Sect2=HITOFF&d=PG01&p=1&u=%2Fnetahtml%2FPTO%2Fsrchnum.html&r=1&f=G&l=50&s1=%2220040230959%22.PGNR.&OS=DN/20040230959&RS=DN/20040230959 didn't we have === and !=== back in 2003? :-)

[16:06] * moritz too young, p6 wise

[16:08] <doy> is perl6 a BASIC-derived programming language compiler?

[16:09] <moritz> not really

[16:09] <PerlJam> There is some small distillation of BASIC within Perl 6 , but I'd hardly call that "derived" 

[16:10] * moritz decommutes

[16:10] * PerlJam jsut boggles that there are 3 co-inventors for the IsNot operator

[16:10] <PerlJam> s/jsut/just/

[16:11] <flussence> sounds like people weren't kidding when they say pointer math is hard :)

[16:11] <masak> I see nothing of merit in software patents. they just make it harder for everyone who wants to develop software.

[16:11] <Teratogen> software patents are stupid.

[16:12] <Teratogen> But, I think one of the first software patents was some access control mechanism for Unix.

[16:12] <jnthn> .oO( If u nix our ideas, we sue! )

[16:13] <flussence> .oO( so *that's* why nothing has a working file locking API! )

[16:13] <PerlJam> software patents are a legal tool for financial protection.  i.e. an anathema to those of us raised in a scientific tradition of sharing.

[16:14] <PerlJam> But I don't think patents would be so bad if the patent office were sane.

[16:14] <flussence> or competent

[16:15] <flussence> I've heard the vast majority of that stuff just gets rubber-stamped without even being read

[16:16] <Teratogen> I think there was a major kerfluffle when Microsoft tried to patent the symbolic link.

[16:16] <Teratogen> Uhm, wait a second you guys, Unix has had symbolic links for DECADES.

[16:16] * PerlJam pictures Einstein with a rubber stamp

[16:19] <masak> I just think software is different enough that patents on software don't make much sense. it's almost as if someone went and patented the use of past tenses of the verb "interject", and then protected his exclusive right to that use by suing other authors who used it.

[16:22] <PerlJam> masak: software patents make sense, it's their appliction to stupid things that doesn't make sense

[16:22] <masak> I think I've only seen it applied in ways that I consider stupid.

[16:23] <PerlJam> I remember long a ago there was a patent on the blinking cursor (held by the Lotus Corp. I think).   That's just stupid.

[16:24] <PerlJam> But patenting a complicated process that is non-obvious and does something useful seems perfectly valid to me.

[16:25] <masak> I'm not sure I agree right away.

[16:26] * jnthn decommutes

[16:26] <PerlJam> If the hardware for an MRI machine were available in any local hardware store, but you developed some software that made the MRI machine actually useful, wouldn't you want some protection so that you sell your invention (software) ?

[16:27] <PerlJam> (that's ultimately what happens for software ... the hardware is generally ubiquitous, but the arrangement of concepts via programming isn't)

[16:28] <colomon> PerlJam: sure, but that's what copyright is for

[16:28] <PerlJam> colomon: copyright protects the text, but not the process.

[16:30] <PerlJam> e.g., copyright will protect my C program, but if someone else wrote a Java program to do that same thing, then that's perfectly fine

[16:30] <colomon> PerlJam: so?  If the process is so obvious anyone can easily reconstruct it, then I don't deserve a patent.  If not, then copyright is fine protection.

[16:31] <colomon> the goal is to reward the programmer's effort, not to give them a monopoly on a certain kind of software

[16:32] *** kaleem_ joined
[16:32] <PerlJam> colomon: That's *exactly* what patent protection is for ... it's only "obvious" after someone else has taken the time to figure out which pieces to put together and in what order. 

[16:33] *** Trashlord joined
[16:34] *** kaleem left
[16:35] <colomon> PerlJam: that's a great assertion, but do you have a shred of proof?

[16:36] * masak decommutes

[16:37] <colomon> Or to put it another way: I've been successfully running a small software business for 13 years now.  I've never patented anything.  In my opinion, the threat that some arsehole out there has patented something that I came up with on my own is a bigger threat to my business than if all my source code somehow escaped into the wild...

[16:40] *** leprevost left
[16:41] *** jferrero left
[16:42] <PerlJam> colomon: I've got no axe to grind really.   But IMHO, the ideals of patents as applied to software have some merit though the execution of those ideals via patent offices and patent law are flawed.

[16:46] *** jferrero joined
[16:48] *** MayDaniel joined
[16:52] *** leprevost joined
[16:53] <TimToady> patents really only make sense for companies who can also afford lawyers, but there's no equal protection under the law for the little guy who can not afford to guess which bits of his intellectual property to waste time patenting at thousands of dollars a pop

[16:54] <TimToady> the guy with most of the sheep will eventually steal your one sheep anyway

[16:54] * TimToady is reminded of the episode with David and Nathan with respect to Bathsheba

[16:57] *** alester left
[16:57] <TimToady> not to mention Uriah the Hittite...

[16:58] <Teratogen> I unlicense all my code, even trivial code.  That way there is prior art.

[16:59] <TimToady> except the stupid patent office is going with the stupid first-to-file rule rather than first-to-invent

[17:01] <geekosaur> also note that prior art only helps if someone can afford to challenge in court

[17:02] <geekosaur> unfortunately, the PTO doesn't do any due diligence; there can be mountains of prior art and nobody will verify before granting the patent

[17:04] *** kaare_ joined
[17:04] <TimToady> so really our only viable strategy is to write successful open source software but fly under the radar long enough that most of the software economy ends up ignoring the patent office

[17:05] <TimToady> that is the only strategy that I can see working

[17:07] <benabik> Quick, patent it so nobody else can sue you for using it.  ;-)

[17:10] *** kaleem_ left
[17:17] *** pat_js joined
[17:17] <TimToady> moritz: I suspect sink should return () rather than Nil, since Nil is becoming an item; otherwise "sink sink" is an error, when it should just be a noop

[17:18] <TimToady> and you want to be able to put sink into the middle of an expression and interpolate nothing

[17:20] <TimToady> as to when you should put something in sink context, just ask yourself "Does this merit a 'Useless use of X' award?"

[17:21] <TimToady> sink context awards that error to anything without side effects

[17:21] <au> . o O { sink sink sink reboot(); } # ...merits a 'Useless use of "sink"' award

[17:21] <TimToady> the question, for example, is whether we view fetching a variable as a valid way to produce side effects

[17:22] <TimToady> I'm not sure it is

[17:22] <TimToady> :)

[17:22] <benabik> Proxy.new( FETCH => { $database.fetch('variable') } ); ?

[17:23] *** jaldhar left
[17:23] <TimToady> otoh, we know, or at least hope, that reboot() has side effects, so it's not a Useless use of reboot

[17:24] <au> exactly.

[17:24] <benabik> I could see fetching variables opening connections to databases, opening files, etc.

[17:24] <TimToady> so a sink on something with side effects is a side effect, but a sink of that sink isn't... :)

[17:24] <benabik> OTOH, if you're doing that lazily, it shouldn't matter if it doesn't happen.

[17:25] <TimToady> so with enough sinks you can issue the "Useless use of sink" award

[17:25] <au> so tat's two useless uses of "sink" awards

[17:25] <au> yeah.

[17:26] * TimToady awards a Most Useful award to Perl 5's Useless award :)

[17:26] <TimToady> that's where most precedence screwups manifest themselves

[17:27] *** zby_home joined
[17:27] <colomon> au!  \o/

[17:27] <au> /o

[17:27] * TimToady hopes that a salute and not an oncoming headache...

[17:28] <au> it's intended as a salutation

[17:31] <TimToady> benabik: even fetching a lazy array should probably be biased in favor of FP semantics, so maybe we should require an explicit eager to drain one of those

[17:34] <TimToady> well, not drain, but force to completion, and then the implicit sink throws away the whole list

[17:36] <moritz> so a bare mention of a variable would be a warning, not a sink

[17:36] *** packetknife joined
[17:36] <TimToady> a warning and a sink, I tihnk

[17:37] <TimToady> side-effect() + side-effect() gets a useless use of + award but also does the side effects

[17:37] *** packetknife left
[17:39] <TimToady> eval: use warnings; (print "A") + (print "B")

[17:39] <buubot_backup> TimToady: AB2

[17:39] <TimToady> hmm, buubot doesn't appear to relay STDERR

[17:40] <TimToady> but locally: Useless use of addition (+) in void context at -e line 1.

[17:40] <TimToady> but it still prints AB

[17:40] <moritz> TimToady: buubot_backup just doesn't evaluate in void context

[17:41] <moritz> TimToady: it even gives you the return value (2) at the end

[17:41] <TimToady> ah, you're right

[17:41] <TimToady> eval: use warnings; (print "A") + (print "B"); 42

[17:41] <buubot_backup> TimToady: Useless use of addition (+) in void context at (eval 20) line 1. AB42

[17:41] <TimToady> \o/

[17:41] <TimToady> moritz++

[17:41] * colomon 's current giant svn merge is making him long for git for $work

[17:42] <benabik> colomon: This is what git-svn is for.

[17:43] <colomon> benabik: I gave it a try a few years ago, but it doesn't seem a good solution for the case where you normally have a couple dozen copies of cloned at the same time.

[17:44] <benabik> colomon: Ah, yes.  Takes more finesse that way.  I know it's generally best to have a single point of svn->git, but not sure if dcommitting from multiple works well.

[17:44] *** xinming left
[17:45] *** xinming joined
[17:45] *** packetknife joined
[17:46] <TimToady> moritz: I would also guess that an implicit sink may have subtly different semantics than an explicit one

[17:46] <TimToady> so that a bare "@foo;" would not cause side effects in @foo, but and explicit "sink @foo" would behave like "eager @foo"

[17:47] <TimToady> I thought of another difference earlier but have since forgotten it :/

[17:48] <TimToady> well, there's the fact that an explicit sink needs to arrange to return () if there's any overhead to that, while an implicit sink need to arrange to return anything

[17:48] <TimToady> s/need/does not need/

[17:50] <TimToady> there's no difference on P5 since it's stack based, and sinking just pushes nothing (well, just does the stack reset between statements)

[17:50] <TimToady> but in P6 it might involve generating an empty Parcel

[17:50] *** xinming left
[17:51] *** xinming joined
[17:53] <benabik> Are Parcels mutable?

[17:53] <benabik> If they're not, you could just return a global empty Parcel.

[17:54] <TimToady> Parcels are not mutable, but they may contain mutables

[17:54] <TimToady> so () is immutable, yes

[17:55] <TimToady> ($foo) is immutable on the outside :)

[17:55] *** Chillance joined
[17:57] *** packetknife left
[17:59] *** thou left
[18:01] <moritz> well,   sink @foo  empties @foo

[18:02] <moritz> otherwise a for-loop in sink context must retain its elements

[18:02] <TimToady> well, here's another difference between explicit and implicit sink: the implicit sink is a circularity saw

[18:02] * moritz thought it was sinks all the way down

[18:02] <TimToady> but yeah, if you call a routine as a procedure, you expect it to do side effects

[18:03] <TimToady> so draining is probably correct even for implicit, though we can probably optimize things some

[18:03] <TimToady> the sink might delegate a sink-yourself to a list

[18:04] <TimToady> been thinking there is something similar for when you print an infinite list

[18:04] <TimToady> instead of just freezing, it should do something like .print for @list

[18:04] <TimToady> or .spray, or whatever we split the raw print into to make masak happy^Whappier

[18:05] <jnthn> evenin'

[18:06] <PerlJam> print, say, spray?

[18:06] *** thou joined
[18:06] <TimToady> well, a politer form of .spew :)

[18:06] <TimToady> opposite of slurp

[18:07] <TimToady> .spit

[18:07] <TimToady> it's hard to think of an opposite that doesn't have negative socal vibes

[18:07] <moritz> perl6: print 1..*

[18:08] <moritz> emit

[18:08] <moritz> but that's not very clear, I think

[18:08] <p6eval> pugs b927740: OUTPUT«Stack space overflow: current size 8388608 bytes.␤Use `+RTS -Ksize -RTS' to increase it.␤»

[18:08] <p6eval> ..niecza v14-42-g1d02da9: OUTPUT«(timeout)»

[18:08] <p6eval> ..rakudo f9fcb2: OUTPUT«(timeout)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211…

[18:08] <TimToady> trouble with emit is that it's usually reserved for things like code generators

[18:08] *** Tarmvred joined
[18:09] <TimToady> looks like rakudo++ already manages to do it somehow

[18:09] <TimToady> well...

[18:09] <TimToady> perl6: (1..*).print

[18:09] <TimToady> betcha that don't work

[18:10] <p6eval> rakudo f9fcb2: OUTPUT«(timeout)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211…

[18:10] <p6eval> ..pugs b927740: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[18:10] <p6eval> ..niecza v14-42-g1d02da9: OUTPUT«Unhandled exception: Unable to resolve method print in class Range␤  at /tmp/0b9nIt5SJj line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3773 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3774 (module-CORE @ 65) ␤  at /hom…

[18:10] <TimToady> well, well

[18:10] * moritz claims a forfeit

[18:10] <TimToady> paint me impressed

[18:10] <TimToady> okay, I owe you a something or other

[18:10] <jnthn> ...how does it do it? :)

[18:11] <TimToady> delegation to the object in question

[18:11] <TimToady> perl6: (1..*, 42).print

[18:12] <p6eval> niecza v14-42-g1d02da9: OUTPUT«Unhandled exception: Unable to resolve method print in class Parcel␤  at /tmp/t4MkSH_mZr line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3773 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3774 (module-CORE @ 65) ␤  at /ho…

[18:12] <p6eval> ..rakudo f9fcb2: OUTPUT«(timeout)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001011021031041051061071081091101111121131141151161171181191201211…

[18:12] <p6eval> ..pugs b927740: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[18:12] <TimToady> rakudo++

[18:14] <flussence> might be useful for p6eval to print both ends of the output in case of a timeout...

[18:15] <moritz> "both ends"?

[18:15] <TimToady> how far the output got

[18:15] *** kaleem joined
[18:16] <moritz> hm, yes

[18:16] <TimToady> presumably you can make a fairly large disk file in a few seconds :)

[18:16] <moritz> not hard to patch, if anybody wants to do it

[18:16] <TimToady> one could probably spaceout in addition to a timeout, with a proper ulimit

[18:17] <jnthn> moritz: How's the sink stuff going? Need me to throw in any tuits/look at anything?

[18:17] <moritz> the reason we don't do it is that STD.pm used to write files during compilation

[18:18] * jnthn should have some tuits after dinner :)

[18:18] <moritz> jnthn: I haven't done much, mainly because I don't knoww (yet) how to proceed

[18:18] <jnthn> moritz: OK.

[18:18] <moritz> jnthn: putting &sink in bootstrap, or some other hack. That's the question.

[18:18] <moritz> hey, I know

[18:19] <moritz> I put it into a setting, and hack it to be only a single statement

[18:19] <moritz> (with Q:PIR or so)

[18:19] <moritz> so it doesn't get any inner statements that are sink-annotated themselves

[18:19] *** MayDaniel left
[18:20] <jnthn> ouch!

[18:20] <jnthn> Though would work.

[18:20] <jnthn> Though at the cost of Q:PIR, which we're supposed to be eliminating...

[18:20] <moritz> we could also make it an opcode

[18:20] <TimToady> yes, the circularity saw aspect of the implicit sink

[18:21] <moritz> then the inliner can do its work on it

[18:21] * moritz feels really evil now

[18:21] <moritz> TimToady: should &sink return the empty list, or an empty parcel?

[18:21] *** thou left
[18:22] <TimToady> what's the effective difference?

[18:22] <TimToady> which is faster?  :)

[18:22] <moritz> parcel is faster in rakudo, iirc

[18:22] <TimToady> which will dwtm if they put it in the middle of an argument list?

[18:23] <TimToady> I think parcel is better, offhand

[18:23] <jnthn> Parcel is faster at the moment. But once I get the serialization work done both should be literals figured out at compile time.

[18:23] <TimToady> I think parcel is correcter

[18:23] <jnthn> Yeah, feels right to be.

[18:23] <jnthn> *me

[18:23] <TimToady> to be, too :)

[18:25] *** Tarmvred left
[18:25] <jnthn> moritz: Trouble with an opcode is that it'd probably end up doing the .?sink call in a nested runloop, which is very ungood.

[18:25] <moritz> jnthn: oh :(

[18:26] <dalek> specs: b3ccbd1 | larry++ | S02-bits.pod:

[18:26] <dalek> specs: sink returns (), not Nil

[18:26] <dalek> specs: review: https://github.com/perl6/specs/commit/b3ccbd1e76

[18:27] <jnthn> We certainly want something that'll get inlined though.

[18:27] <moritz> agreed

[18:27] <jnthn> Though, get the semantics right first and then we make the inliner diddle it.

[18:27] <moritz> couldn't we emit .?sink; ()  directly, instead of calls to &sink ?

[18:29] <jnthn> Yes.

[18:29] <jnthn> Well, you'd need to stick the thing being sunk into a temporary register.

[18:30] <jnthn> But that's easy too.

[18:30] <TimToady> maybe everything should have a .sink method that says, "Evaluate yourself for side effects, and carp if you don't have any"

[18:30] <moritz> we might even want to inline dispatch:<.?> in PAST

[18:30] <jnthn> In fact, you can do it better than the normal .? path too.

[18:31] <jnthn> moritz: Yes, that's what I was thinking.

[18:31] <TimToady> then constant folding would automatically produce the Useless warnings

[18:32] <moritz> jnthn: is there an example of such a temporary register usage at the PAST level somewhere?

[18:32] *** MayDaniel joined
[18:33] <jnthn> moritz: Grep Actions.pm for :scope('register')

[18:33] <jnthn> (Multiple examples)

[18:34] <jnthn> moritz: You'll maybe need a fresh name also; grep for .unique to see how to do that :)

[18:34] <moritz> so I just chose a uniq name, declare it as :scope('register'), bind to it, and then a PAST::Var with the same scope and name?

[18:35] <moritz> can't we use the same register name throughout the whole program?

[18:35] <jnthn> Correct

[18:35] <jnthn> moritz: er, you'd need to declare it once per PAST::Block

[18:36] *** snearch joined
[18:36] <jnthn> moritz: And the optimizer may make assumptions about non-dupe register names when it inlines blocks, but that latter issue is very fixable.

[18:37] <TimToady> commuting &

[18:37] *** kaleem left
[18:38] *** Tarmvred joined
[18:39] *** pyrimidine left
[18:46] <masak> phenny: "Tarmvred"?

[18:46] <phenny> masak: "ileus" (sv to en, translate.google.com)

[18:46] <masak> :)

[18:47] <masak> "Ileus is a disruption of the normal propulsive ability of the gastrointestinal tract." -- Wikipedia

[18:49] <daxim> soooo… propulsive? like in the first few seconds of "the pick of destiny"?

[18:49] *** pyrimidine joined
[18:49] <jnthn> dinner &

[18:52] <moritz> nom: say infix:<,>().WHAT

[18:52] <p6eval> nom f9fcb2: OUTPUT«Parcel()␤»

[18:52] *** MayDaniel left
[18:53] *** ab5tract joined
[19:05] *** MayDaniel joined
[19:05] *** birdwindupbird joined
[19:06] <Tarmvred> daxim: Symptoms is pretty much the same as when learning Perl6. ;)

[19:09] <moritz> jnthn: can I check if a PAST::Op returns a value?

[19:10] *** aindilis joined
[19:26] <masak> Tarmvred: you're learning Perl 6 the wrong way, then :)

[19:27] *** wolfman2000 joined
[19:29] <jnthn> moritz: There's...a lot of different things that a PAST::Op could represent.

[19:29] <moritz> jnthn: never mind, I've fixed it

[19:30] <moritz> well, enough to compile the setting

[19:30] <jnthn> :)

[19:30] <dalek> rakudo/sink: 89633a5 | moritz++ | src/ (4 files):

[19:30] <dalek> rakudo/sink: codegen .?sink; () directly instead of calling &sink

[19:30] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/89633a5c3a

[19:31] <moritz> aaand... only 3 files fail in 'make test'

[19:31] <jnthn> ooh :)

[19:32] <moritz> $ ./perl6 -e 'my $x = "foo"; $x++; say $x'

[19:32] <moritz> ===SORRY!===

[19:32] <moritz> Method 'postcircumfix:<( )>' not found for invocant of class 'Parcel'

[19:32] <moritz> a, Str.succ fails

[19:33] <jnthn> Well, that succs.

[19:33] <jnthn> Str.succ is pretty complex, iirc

[19:35] <moritz> the line that fails is   my Int ($Ir0, $Ir1) = RANGEPOS($str);

[19:35] <jnthn> Does list assignment generally work?

[19:36] <moritz> yes

[19:36] <moritz> (that's the first thing I've checked)

[19:36] <Tarmvred> masak: Hehe well, actually I find it extremely fun, and I figured out the answer to the question I came in here for (howto do my($multiple, $declaration). I'm quite new to programming in general but I haven't found anything as fun to learn as Perl, and directly to Perl 6

[19:36] <Tarmvred> It's quite addictive

[19:38] <moritz> jnthn: curiously the whole block compiled to PIR doesn't contain a single sink call

[19:38] <benabik> Learning new languages and new paradigms is additive.  Perl 6 just happens to be like three or four languages and tries to allow as many paradigms as possible.

[19:39] <jnthn> moritz: It's not failing somewhere within RANGEPOS?

[19:40] <moritz> current instr.: '_block4586' pc 76654 (src/gen/perl6-metamodel.pir:31072) (src/gen/Metamodel.pm:3425)

[19:40] <moritz> called from Sub 'succ' pc 924224 (src/gen/CORE.setting.pir:247047) (src/gen/CORE.setting:3347)

[19:40] <moritz> are the first two lines

[19:40] <masak> Tarmvred: I agree -- it's a nice language.

[19:41] <masak> Tarmvred: if you haven't already, check out http://strangelyconsistent.org/blog/list-of-posts, starting at 1 Jun, 2011. it's a 30-day course in programming and Perl 6.

[19:41] <moritz> and src/gen/CORE.setting.pir:247047 is $P695 = "&RANGEPOS"($P694)

[19:42] <moritz> but the first bt line doesn't come from RANGEPOS

[19:43] <jnthn> moritz: Can you gist me the PIR you're looking at?

[19:43] <jnthn> May be able to spot something...

[19:44] <Tarmvred> masak: Thats perfect, thanks.

[19:44] <moritz> jnthn: willdo

[19:47] <moritz> jnthn: https://gist.github.com/1847311

[19:49] <moritz> a Parcel is what a sink returns

[19:50] <jnthn> nom: class A { sub foo() { say 42 }; method bar() { foo() } }; A.bar

[19:50] <p6eval> nom f9fcb2: OUTPUT«42␤»

[19:50] <jnthn> moritz: Does ^^ work in your branch?

[19:50] <moritz> jnthn: nope

[19:51] <moritz> also

[19:51] <jnthn> moritz: Same kind of error?

[19:51] <moritz> $ ./perl6 -e 'my ($a, $b) = "abc".split("b"); say $a; say $b'

[19:51] <moritz> Nil

[19:51] <moritz> Nil

[19:52] <jnthn> nom: my $a; my $b; my $c := ($a, $b); $c.STORE((1, 2)); say $a, $b

[19:52] <p6eval> nom f9fcb2: OUTPUT«12␤»

[19:52] <jnthn> How about that one?

[19:52] <moritz> 12

[19:52] <jnthn> ok, so it's not busted Parcel.STORE then...

[19:53] <moritz> my guess is really that some declarative stuff is busted

[19:53] <jnthn> The above one with the sub in the class not working is a bit bothersome.

[19:54] <jnthn> And could easily be the cause of the RANGEPOS issue - which is a sub declared in a class.

[19:54] *** benabik left
[19:54] <moritz> jnthn: https://gist.github.com/1847382 is the generated PIR for that

[19:55] *** MayDaniel left
[19:55] <moritz> oh

[19:55] <jnthn> aha!

[19:55] <jnthn> It's sinking the closure clone...

[19:55] <moritz> aye

[19:55] * moritz just arrived at the same conclusion

[19:56] <jnthn> A nosink around line 346 in World.pm should help

[19:57] <jnthn> er

[19:57] <jnthn> 356

[19:57] <moritz> I also think we need one in Actions in block_closure

[19:57] *** benabik joined
[19:57] <jnthn> Prolly

[19:58] *** MayDaniel joined
[19:58] <moritz> erm, in World.pm line 356 the top-level PAST::Op is a bind_6model

[19:58] <moritz> so that one shouldn't be sunk, because I don't recurse into PAST::Ops at all

[19:58] <moritz> only ever consider the top-level one

[19:59] <jnthn> moritz: Yeah, that's why I'm confused how it's getting messed up...

[19:59] <moritz> and only sink if that's a call

[20:00] <jnthn> Also, we maybe don't want to even analyze the first PAST::Stmts within a PAST:Block

[20:00] <jnthn> As it's always the declarative bits, not the executional bits

[20:01] <jnthn> +                        :pirop('can IPS'),

[20:01] <jnthn> Should be IPs

[20:01] <moritz> but not every first statement in a PAST::Block is declarative, no?

[20:01] <jnthn> For better code gen

[20:01] <moritz> ok, will fix that

[20:01] <jnthn> moritz: A PAST::Block always contains two PAST::Stmts nodes that the top level

[20:01] <jnthn> The first one is only for lexiecal declarations, closure cloning, calling the binder, etc.

[20:02] <jnthn> The second one is what's produced by statementlist

[20:02] <jnthn> That is, it contains the list of statements that were actually written.

[20:02] <moritz> ok, so I can skip every first element of a PAST::Block

[20:02] <jnthn> Right

[20:02] <jnthn> That's why so much code does stuff with $block[0] :)

[20:04] *** ksi_ joined
[20:05] <moritz> then maybe it would be more efficient to make PAST::Block a class with two attributes (for declarative and procedural stuff) than an Array, no?

[20:05] <jnthn> Well, so far the "two children" has been a convention only.

[20:06] <jnthn> That is, Rakudo and NQP do it, but the compiler toolkit doesn't give any meaning to it beyond that.

[20:06] <moritz> so I shouldn't rely on it in Perl6::Sinker?

[20:06] <jnthn> You can rely on it in Perl6::Sinker 'cus its input is code that Perl6::Actions has produced :)

[20:10] * moritz waits for the setting to compile

[20:12] <moritz> meh, now dies during codegen

[20:12] <moritz> seems that $block[1] is Undef, occasionally

[20:14] * moritz refines the codegen

[20:14] <moritz> now the last lurker will have realized that codegen isn't my strong side

[20:23] *** ab5tract left
[20:26] <[Coke]> IWBNI strangelyconsistent.org had "next/prev" buttons on blog entries.

[20:28] *** Chillance left
[20:28] *** roadt joined
[20:28] *** roadt left
[20:29] <moritz> masak: feel hilighted, ^^

[20:31] *** mj41 joined
[20:31] <masak> [Coke]: I've had the same thought.

[20:31] <masak> it's not impossible.

[20:31] <flussence> .oO( isn't there a patent on double-linked lists?! :)

[20:32] <masak> not only "next/prev post", but "next/prev post on this topic", fsvo "topic".

[20:32] <masak> ...without cluttering up the interface :)

[20:33] <moritz> there's enough space under "no notes" and at the bottom of an article

[20:34] <masak> sure, there's enough space. I put lots of space in there. :)

[20:34] <masak> doesn't mean links won't clutter up that space.

[20:34] *** localhost joined
[20:35] <masak> [Coke]: I'll take it under consideration, not least because I was already thinking about something like that myself.

[20:36] <masak> the main challenge is that introduction of such links causes neighboring posts to require an update whenever a post is created or changes title.

[20:36] <masak> clearly I need to map out the data dependencies here, end then implement something clever that tracks them and updates the right stuff.

[20:36] <masak> s/, end/, and/

[20:37] <moritz> well, if it's just "next" and "previous", the deps don't need to be explicitly declared

[20:37] <moritz> clearly you need a Blog::World that tracks declarations and deps

[20:37] <moritz> :-)

[20:38] <moritz> meh. The nosink stuff doesn't work, it seems

[20:38] <masak> well, the addition of a new post at the end of the line still affects the previous one by adding a link where there was none before.

[20:39] <moritz> yes, but since that's a general rule, it doesn't need to be declared per post

[20:40] <masak> thank heavens, no. everything that can be implicit should be :)

[20:40] <masak> I wouldn't want to manage inter-post deps *anywhere*.

[20:40] <masak> even the "next in topic" would just work by adding topic tags to posts.

[20:40] *** wolfman2000 left
[20:40] <moritz> aye

[20:41] <dalek> rakudo/sink: 54d7ab7 | moritz++ | src/Perl6/ (2 files):

[20:41] <dalek> rakudo/sink: codegen improvements, jnthn++.

[20:41] <dalek> rakudo/sink: 

[20:41] <dalek> rakudo/sink: But it seems it is not enough :(

[20:41] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/54d7ab7e6d

[20:50] *** leprevost left
[20:51] <jnthn> moritz: What's the next failure?

[20:51] <dalek> nqp/bs: dff3130 | jonathan++ | src/NQP/ (2 files):

[20:51] <dalek> nqp/bs: Separate out creation of code objects from addition of methods; not all code objects are methods.

[20:51] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/dff3130f6b

[20:52] <moritz> jnthn: still the same failure

[20:52] <moritz> jnthn: ah, but I think I understand why

[20:53] <moritz> jnthn: let me try a possible fix here before I bother you again

[20:53] <jnthn> k

[20:53] * jnthn if bothering himself plenty with refactoring multi handling in NQP :)

[20:58] <moritz> hm, no, didn't fix it

[20:58] * moritz tries another thing

[20:59] *** kaare_ left
[21:01] *** birdwindupbird left
[21:05] *** alester joined
[21:13] <dalek> rakudo/sink: 0b8b2f1 | moritz++ | src/Perl6/ (3 files):

[21:13] <dalek> rakudo/sink: better nosink annotations

[21:13] <dalek> rakudo/sink: 

[21:13] <dalek> rakudo/sink: Though I do not understand why this is necessary.

[21:13] <dalek> rakudo/sink: The sinker code should never descend into PAST::Op

[21:13] <dalek> rakudo/sink: nodes, so it shouldn't be necessary in Perl6::World

[21:13] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/0b8b2f17b7

[21:19] *** y3llow joined
[21:19] *** pothos joined
[21:21] *** y3llow left
[21:22] *** y3llow joined
[21:22] *** az5112 joined
[21:22] *** pernatiy joined
[21:22] *** pothos left
[21:23] *** pothos joined
[21:24] *** y3llow left
[21:24] *** y3llow joined
[21:25] *** pothos left
[21:26] *** pothos joined
[21:28] *** pat_js left
[21:30] <dalek> rakudo/sink: 7ed62e8 | moritz++ | src/Perl6/Actions.pm:

[21:30] <dalek> rakudo/sink: list assignment needs a nosink annotation, otherwise all arrays are empty

[21:30] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/7ed62e840b

[21:31] <moritz> jnthn: now 'make test' passes, except for the file that tests 'use Test;'

[21:32] <moritz> which imports nothing (but lives)

[21:32] <moritz> and I don't understand that all, since Test.pir contains no .?sink calls at all

[21:32] <moritz> and the code for 'use Test;' doesn't either

[21:33] <moritz> is there any setting code involved in loading a module?

[21:35] <jnthn> moritz: Yes, traits.pm, the export trait.

[21:35] <jnthn> Which does a for loop.

[21:37] *** Khisanth joined
[21:40] * moritz -> sleep

[21:41] <jnthn> 'night, moritz 

[21:43] *** preflex joined
[21:46] *** danishman left
[21:53] <dalek> nqp/bs: 61ec7dc | jonathan++ | src/how/NQPClassHOW.pm:

[21:53] <dalek> nqp/bs: Prepare NQPClassHOW to handle the multi-method changes.

[21:53] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/61ec7dc87b

[21:53] <dalek> nqp/bs: e3b73bb | jonathan++ | src/core/NQPRoutine.pm:

[21:53] <dalek> nqp/bs: Sketch some dispatcher related methods into NQPRoutine.

[21:53] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/e3b73bbf3d

[21:53] <dalek> nqp/bs: b103371 | jonathan++ | src/NQP/Actions.pm:

[21:53] <dalek> nqp/bs: Generate simpler code for attribute lookups in the non-role case.

[21:53] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b103371f90

[21:53] <dalek> nqp/bs: 1c216a2 | jonathan++ | src/NQP/World.pm:

[21:53] <dalek> nqp/bs: Start to refactor the multi method handling in NQP::World to not rely on DispatcherSub. Not completely done yet; breaks multi-method tests. However, it's enough to get compilation further with the new serializer.

[21:53] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/1c216a225c

[21:57] <jnthn> Enough for today.

[21:57] <felher> jnthn: what does 'bs' stand for?

[21:58] *** az5112 left
[21:58] <jnthn> felher: Bounded Serialization

[21:58] <PerlJam> felher: use your imagination :)

[21:58] <jnthn> Coming up with bounded serialization takes quite a lot of imagination. :)

[21:59] <PerlJam> It's more fun that way though.

[21:59] <felher> :)

[21:59] <felher> thnx :)

[21:59] <jnthn> ;)

[21:59] * jnthn is hoping he can get the NQP side of this wrapped up at the weekend, then dig into getting Rakudo using it.

[22:01] <PerlJam> jnthn: This should make some things faster, yes?

[22:01] *** raoul_ joined
[22:01] *** packetknife joined
[22:01] * felher reads http://en.wikipedia.org/wiki/Serialization to at least understand a tiny bit of whats going on and then goes to bed :)

[22:02] *** ab5tract joined
[22:02] <jnthn> PerlJam: Depends what you mean by "things" :)

[22:02] <jnthn> PerlJam: It should make Rakudo compilation less memory hungry and faster.

[22:03] <jnthn> PerlJam: It should also improve Rakudo's startup time.

[22:03] <jnthn> It'll also unblock various other things.

[22:03] <jnthn> Some of which are optimizations.

[22:06] <PerlJam> jnthn: any guess how noticable the differences will be between before and after?

[22:07] <masak> why guess? just write it and find out! :)

[22:07] <[Coke]> jnthn will have more spare time!

[22:10] <jnthn> PerlJam: It's a bit hard to guess at. I know that just under 60% of the lines of PIR we generate today for CORE.setting are related to re-building the environment, which is what the serialization work is replacing.

[22:10] <PerlJam> wow.  

[22:10] <jnthn> Of course, it won't replace it with "nothing". :) But it will mean that a LOAD of PAST nodes we build today that generate that PIR will no longer be needed.

[22:11] <PerlJam> I knew we were regenerating stuff, but I would have guessed it was more on the order of 20% or so

[22:11] <jnthn> The thing it replaces it with is a (probably epic in this case) binary blob.

[22:11] *** noam left
[22:11] <jnthn> Plus building a big array of strings, and a big array of static code refs.

[22:11] *** noam joined
[22:12] <jnthn> Which in terms of PAST nodes should be a drop in the ocean compared to what we have today.

[22:12] *** ksi_ left
[22:12] <jnthn> How much faster startup will be is harder to put a figure on.

[22:21] <masak> still, cause for hope.

[22:25] <jnthn> aye

[22:26] *** tarch left
[22:26] <jnthn> Plus we'll be able to have nice things, like non-literal constants :)

[22:27] <jnthn> Talking of nice things...sleep &

[22:28] *** raoul_ left
[22:28] <masak> std: my int ($a, $b)

[22:28] <p6eval> std 52f3895: OUTPUT«ok 00:01 110m␤»

[22:29] <masak> nom: my int ($a, $b); say 'alive'

[22:29] <p6eval> nom f9fcb2: OUTPUT«Lexical '$a' is of wrong register type in lexical lookup␤  in block <anon> at /tmp/ZygsqoaYcw:1␤␤»

[22:29] * masak submits rakudobug

[22:30] <masak> nom: my (int $a, int $b); say 'alive'

[22:30] <p6eval> nom f9fcb2: OUTPUT«Lexical '$a' is of wrong register type in lexical lookup␤  in block <anon> at /tmp/oUNZad6Ay3:1␤␤»

[22:31] <masak> huh!

[22:31] <masak> nom: my (int $a); say 'alive'

[22:31] <p6eval> nom f9fcb2: OUTPUT«Lexical '$a' is of wrong register type in lexical lookup␤  in block <anon> at /tmp/FpPrEx1LXf:1␤␤»

[22:31] <masak> nom: my int $a; say 'alive'

[22:31] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[22:31] <masak> still a bug, but not what I thought it was :)

[22:31] *** freeu4 joined
[22:32] <PerlJam> star: my int $a; say 'alive';

[22:32] <p6eval> star 2012.01: OUTPUT«alive␤»

[22:32] <PerlJam> huh

[22:33] <masak> does that surprise you? star works the same as nom.

[22:33] <PerlJam> when I tried that locally, it died in the same manner as above

[22:34] <PerlJam> but I don't have a recently-build rakudo; it's a couple of days old

[22:34] <freeu4> i can't found any tutorial about compile perl6 code with parrot and rakudo !

[22:35] <masak> freeu4: compiling code with parrot and rakudo is easy. just do 'perl6 mycode.pl'

[22:35] <masak> rakudo compiles your code, and runs it.

[22:35] *** benabik left
[22:36] <freeu4> masak: no creat stand alone file ?!

[22:36] <masak> freeu4: no. neither Perl 5 nor Perl 6 creates a stand-alone compiled file before running it.

[22:36] <masak> freeu4: what is your use case?

[22:37] <masak> (i.e. why is not the script file sufficient for you?)

[22:37] <masak> nom: my Int $a; say 'alive'

[22:37] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[22:37] <masak> nom: my (Int $a); say 'alive'

[22:37] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[22:37] <masak> nom: my (Int $a); $a = "OH HAI"; say 'alive'

[22:37] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[22:38] <masak> nom: my (Int $a, Int $b); $b = "OH HAI"; say 'alive'

[22:38] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[22:38] <masak> nom: my Int $a; $a = "OH HAI"; say 'alive'

[22:38] <p6eval> nom f9fcb2: OUTPUT«Type check failed in assignment to '$a'; expected 'Int' but got 'Str'␤  in block <anon> at /tmp/FYE1VJwPBP:1␤␤»

[22:39] *** dju joined
[22:41] <freeu4> masak: i want create a stnd-alone from perl6 script ; like after compile c progrm (./gcc 1.c -o 1)

[22:41] <masak> yes, I understand.

[22:41] <masak> why do you want this?

[22:42] <freeu4> masak: after public my program , everyone can run it 

[22:44] <masak> I guess there could be a way to bundle the 'perl6' runtime and the script together into one big binary monstrosity.

[22:44] <masak> but you have to understand that you gain nothing from this -- you will always need a Perl 6 runtime to run your program.

[22:45] <masak> so all you're doing by bundling things into one single executable is move data around. you won't get a smaller file, or anything like that.

[22:46] <masak> my 'perl6' file from a recently compiled nom is 74KB. that's... small.

[22:46] <masak> my guess because most of the stuff is in library files elsewhere.

[22:46] <masak> you'd have to bundle those, too.

[22:46] <masak> in the end, you'd need to bundle all of Rakudo and all of Parrot.

[22:47] <masak> creating what's likely a HUGE file. that's one HUGE file per script you compile to a stand-alone executable.

[22:47] <masak> consider the alternative -- running the script immediately :)

[22:48] *** lutok joined
[22:48] <masak> lots of advantages: smaller files. it works today. when we fix bugs and you update Rakudo, your script will run better/faster.

[22:50] <masak> nom: constant FOO = 42; say 'alive'

[22:50] <p6eval> nom f9fcb2: OUTPUT«alive␤»

[22:50] <Tarmvred> masak: aren't there any perl 5 -> binary compiler/program?

[22:52] <Tarmvred> perl2exe ex? Haven't tried it myself though.

[22:52] <PerlJam> Tarmvred: there have been in the past, but most are now defunct.

[22:52] <PerlJam> though I hear that perlcc is being revived

[22:53] <slavik> perlcc?

[22:53] <slavik> perl to binary?

[22:53] <PerlJam> http://search.cpan.org/~nwclark/perl-5.8.9/utils/perlcc.PL

[22:54] <PerlJam> actually ... https://metacpan.org/module/perlcc  that's the latest

[22:59] <freeu4> masak: thank you

[23:00] *** freeu4 left
[23:01] <masak> dang, I was gonna give freeu4 http://perldoc.perl.org/perlfaq3.html#How-can-I-compile-my-Perl-program-into-byte-code-or-C%3f

[23:04] <masak> nom: my $n = 0; while $n < 10 { say "HAHA $n"; NEXT { $n++ } }; say "alive"

[23:04] <p6eval> nom f9fcb2: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&NEXT' called (line 1)␤»

[23:05] * araujo looks in

[23:05] <araujo> masak, o/

[23:05] <masak> araujo! \o/

[23:05] <masak> nom: for ^10 { foo($_); .say }; sub foo($x) { next if $x %% 2 }

[23:05] <p6eval> nom f9fcb2: OUTPUT«1␤3␤5␤7␤9␤»

[23:05] <araujo> heh :)

[23:05] <araujo> masak, heard around you were going to resume pugs dev? .... do you happen to have some TODO around? :)

[23:06] <masak> araujo: no, we haven't been able to consistently create a working dev environment yet.

[23:06] <masak> the TODO is basically "pick a lot of low-hanging fruit, learn how the Pugs architecture works, have lots of fun"

[23:06] <araujo> I see

[23:06] <araujo> masak, "working dev environment" ?

[23:07] <araujo> care to elaborate?

[23:09] <masak> a Pugs.hs repo on feather that can be compiled.

[23:10] <masak> moritz got it to work; [Coke] and I didn't. we couldn't find any diff between our ways of setting things up.

[23:10] <araujo> oh I see

[23:10] <araujo> I thought you were talking about some SDK or something :P

[23:11] *** fsergot left
[23:15] *** mj41 left
[23:21] <masak> no, just Unix :)

[23:22] <masak> but having the project compile feels like a necessary prerequisite to hacking.

[23:27] *** tarch joined
[23:39] *** pernatiy left
[23:41] *** Tarmvred left
[23:43] *** snearch left
[23:48] *** tarch left
[23:49] *** whiteknight joined
