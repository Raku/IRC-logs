[00:02] *** fgomez left
[00:04] *** benabik left
[00:11] *** thou left
[00:17] *** benabik joined
[00:17] *** fgomez joined
[00:23] <flussence> well, I've hit a stone wall. "psgi.input => Buf.new()" on a POST request - it's not getting set, which means POST doesn't work at all.

[00:25] *** japhb_ left
[00:26] *** whiteknight left
[00:40] <flussence> ...I think IO::Socket.get is broken.

[00:41] <flussence> HTTP::Easy::PSGI only does reads by calling .get for the headers and a .read($len) later on, but that .read always ends up with no data

[00:49] <flussence> actually... I might be horribly wrong

[00:50] <flussence> yeah, it's the other way around: http://irclog.perlgeek.de/perl6/2012-10-24#i_6095161

[00:51] <diakopter> I've had my head buried in a stone wall of a project for 2 weeks

[00:51] <diakopter> er, 3

[00:57] *** rindolf left
[01:02] *** benabik_ joined
[01:05] *** gdey left
[01:05] *** benabik left
[01:05] *** benabik_ is now known as benabik

[01:13] *** PacoAir left
[01:14] <flussence> oh.

[01:14] <flussence> figured out why it doesn't work.

[01:14] <flussence> in 837d0f8 moritz deleted the line in .read that... does the reading bit

[01:16] *** benabik left
[01:16] *** benabik joined
[01:18] <flussence> more specifically, this one: https://github.com/rakudo/rakudo/commit/837d0f8#L2L30

[01:20] *** Chillance left
[01:21] <flussence> and with that fixed I can get back to fighting bugs in modules instead of the language itself... *sigh*

[01:30] *** FROGGS_ joined
[01:33] *** flightrecorder left
[01:34] *** FROGGS left
[01:34] *** flightrecorder joined
[01:40] *** fgomez left
[01:40] *** fgomez joined
[01:44] *** MikeFair joined
[01:44] *** benabik left
[01:45] *** jerome left
[01:50] *** benabik joined
[01:56] *** DarthGandalf left
[01:59] *** jerome joined
[01:59] *** DarthGandalf joined
[02:21] *** orafu left
[02:21] *** orafu joined
[02:40] *** skids joined
[02:54] *** bapa left
[02:54] *** bapa joined
[03:10] *** jaldhar joined
[03:12] *** flightrecorder left
[03:12] *** FROGGS_ left
[03:14] *** gregp joined
[03:14] *** gregp is now known as Guest34516

[03:15] *** Guest34516 is now known as gregster

[03:17] *** gregster left
[03:19] *** orafu left
[03:19] *** OuLouFu joined
[03:19] *** OuLouFu is now known as orafu

[03:40] *** HarryS joined
[03:51] *** armitage81 left
[04:01] *** thou joined
[04:04] *** cognominal left
[04:22] *** Playb3yond joined
[04:24] *** telex left
[04:25] *** Playb3yond left
[04:28] *** jaldhar left
[04:34] *** telex joined
[04:34] *** azawawi joined
[04:40] <azawawi> hi #perl6

[04:40] <phenny> azawawi: 26 Oct 22:13Z <rindolf> tell azawawi OK, I understand now - regarding HTTP::Easy.

[04:43] <azawawi> rn: require File::Spec;

[04:43] <p6eval> niecza v22-14-g136ddcf: OUTPUT«Unhandled exception: System.NotImplementedException: The requested feature is not implemented.␤  at Anon.1.Run.MAIN.C0mainline (Niecza.Frame ) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.RunCore (Niecza.Frame& cur) [0x00000] in <filename unknown>…

[04:43] <p6eval> ..rakudo 3619d7: OUTPUT«Could not find File::Spec in any of: /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/site/lib, /home/p6eval/.perl…

[04:43] <azawawi> star: require File::Spec;

[04:43] <p6eval> star 2012.07: OUTPUT«Could not find File::Spec in any of: /home/p6eval/.perl6/lib, /home/p6eval/star/lib/parrot/4.6.0/languages/perl6/lib␤  in any load_module at src/Perl6/ModuleLoader.pm:108␤  in block <anon> at /tmp/jQF2rCmulp:1␤␤»

[04:43] *** jaldhar joined
[04:45] <azawawi> star: if (1) { require File::Spec; }

[04:45] <p6eval> star 2012.07: OUTPUT«Could not find File::Spec in any of: /home/p6eval/.perl6/lib, /home/p6eval/star/lib/parrot/4.6.0/languages/perl6/lib␤  in any load_module at src/Perl6/ModuleLoader.pm:108␤  in block <anon> at /tmp/yhJNoydXNT:1␤␤»

[04:46] <azawawi> r: if (1) { require File::Spec; }

[04:46] <p6eval> rakudo 3619d7: OUTPUT«Could not find File::Spec in any of: /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/site/lib, /home/p6eval/.perl…

[04:48] *** telex left
[04:52] <azawawi> moritz: ping

[04:53] *** telex joined
[04:55] *** jaldhar left
[04:56] <azawawi> phenny: tell moritz Any chance star: is upgraded to 2012.09 or the upcoming 2012.10? Thanks.

[04:56] <phenny> azawawi: I'll pass that on when moritz is around.

[04:58] <azawawi> star: /clear

[04:58] <p6eval> star 2012.07: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix / instead␤at /tmp/58T7rkhTy9:1␤»

[04:59] *** jaldhar joined
[05:01] <azawawi> do 'require' in Perl 6 work in the same way that it works in Perl 5 or not?

[05:01] <azawawi> s/do/does/

[05:02] * azawawi walk &

[05:02] *** azawawi left
[05:04] *** tokuhir__ left
[05:08] *** Entonian joined
[05:09] *** Entonian left
[05:09] *** Entonian joined
[05:11] *** Entonian left
[05:11] *** Entonian joined
[05:16] *** Entonian left
[05:43] *** sisar joined
[05:48] *** bro_grammer left
[05:52] *** Pleiades` left
[05:58] *** Pleiades` joined
[06:23] *** skids left
[06:32] *** s1n left
[06:37] *** sivoais left
[06:42] *** sivoais joined
[06:44] *** thou left
[06:44] *** flightrecorder joined
[07:02] *** GlitchMr joined
[07:06] *** mucker joined
[07:10] *** Rix joined
[07:38] *** mucker left
[07:40] *** SamuraiJack joined
[07:46] *** gootle joined
[08:22] <moritz> phenny: tell azawawi I'll upgrade p6eval once 2012.10 is released

[08:22] <phenny> moritz: I'll pass that on when azawawi is around.

[08:22] <phenny> moritz: 04:56Z <azawawi> tell moritz Any chance star: is upgraded to 2012.09 or the upcoming 2012.10? Thanks.

[08:28] *** havenn_ joined
[08:29] *** sisar left
[08:30] *** havenn left
[08:44] *** havenn_ left
[08:56] *** MayDaniel joined
[08:58] *** SamuraiJack left
[08:58] *** jaffa4 joined
[08:59] <jaffa4> hi ALL

[08:59] <jaffa4> how would you convert c flag in a regular expression to Perl 6 regular expression?

[09:00] *** colomon left
[09:12] <sorear> I need to look up what c does

[09:15] *** cognominal joined
[09:15] <sorear> jaffa4: /c is inapplicable in perl 6 because it modifies the behavior of pos(), which has been removed due to bad interaction with threads

[09:16] <jaffa4> well, I am not sure I understand you I mean the whys... but it does not work.. right...

[09:16] <sorear> What are you trying to accomplish?

[09:17] <jaffa4> to continue matching if a previous match fails

[09:17] <sorear> please elaborate

[09:17] <sorear> what is "continue"

[09:17] <jaffa4> continue from the same position which was before the last match failed.

[09:18] <sorear> /c is meaningless in perl 5 except when it modifies scalar context /g

[09:18] <sorear> scalar context /g is gone

[09:19] <sorear> there is no 'same position'.  perl 6 doesn't remember that, unless our communication is very confused

[09:19] <jaffa4> $/.pos

[09:20] <sorear> hmm... probably you should save $/.pos in a variable if you want to still have it after the next match

[09:20] <jaffa4> yes, I can do that

[09:20] <sorear> or write the code to not use $/ directly

[09:21] <sorear> e.g. $match //= m/foo/

[09:21] <jaffa4> Not sure what I see

[09:25] <jaffa4> r:$match //= m/foo/

[09:26] <jaffa4> std: match //= m/foo/

[09:26] <p6eval> std 64edd1c: OUTPUT«===SORRY!===␤Null regex not allowed at /tmp/9uSPFYSjs0 line 1:␤------> match //⏏= m/foo/␤Undeclared routine:␤  'match' used at line 1␤Check failed␤FAILED 00:00 43m␤»

[09:26] <jaffa4> r: match //= m/foo/

[09:27] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤Null regex not allowed at line 2, near "= m/foo/"␤»

[09:27] <jaffa4> r: $match //= m/foo/

[09:27] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤Variable $match is not declared␤at /tmp/vap8A8vqAi:1␤»

[09:27] <jaffa4> r: my $match='m'; $match //= m/foo/

[09:27] <p6eval> rakudo 3619d7:  ( no output )

[09:27] <jaffa4> r: my $match='m'; $match //= m/fm/

[09:27] <p6eval> rakudo 3619d7:  ( no output )

[09:28] <jaffa4> r: my $match='m'; print $match //= m/fm/

[09:28] <p6eval> rakudo 3619d7: OUTPUT«m»

[09:28] <jaffa4> r: my $match='m'; print $match //= m/fm/ ; print $match.pos

[09:28] <p6eval> rakudo 3619d7: OUTPUT«No such method 'pos' for invocant of type 'Str'␤  in block  at /tmp/7KbbptzgN2:1␤␤m»

[09:33] *** Su-Shee left
[09:42] <jaffa4> r: my $match='m'; print ($match //= m/fm/ ).pos; 

[09:42] <p6eval> rakudo 3619d7: OUTPUT«No such method 'pos' for invocant of type 'Str'␤  in block  at /tmp/UhI6HfbiLN:1␤␤»

[09:42] *** cognominal left
[09:45] *** havenn joined
[09:50] *** havenn left
[09:53] <masak> good antenoon, #perl6

[09:53] <eiro> hello guys 

[09:55] *** cognominal joined
[09:56] <eiro> yeah cognominal :)

[09:57] <cognominal> hi, eiro and the nice #perl6 crowd

[09:58] * masak .oO( are you saying eiro is not nice? ) :P

[09:59] <moritz> jaffa4: simply store the $/.to from the previous successful match, and anchor to that with :c($pos) or :p($pos)

[09:59] <moritz> though for lexing (for which you use /c in Perl 5) you can just use a grammar instead

[10:01] <cognominal> * and the rest of the nice ...

[10:02] <cognominal> now, masak will say I downplay #perl6 compared to eiro

[10:07] <eiro> haha. i'm confused, have poor skills in both perl6 and english6 but i'm trying. i want bailador to listen to other than localhost:3000 

[10:07] <masak> I ain't said nothin' :)

[10:08] *** cognominal_ joined
[10:08] <eiro> (btw the bailador message is a lie: it doesn't listen to 0.0.0.0 :)

[10:08] *** cognominal left
[10:08] <eiro> wow! another improved cognominal_ 

[10:08] <eiro> imppressive update

[10:10] *** spider-mario joined
[10:13] *** cognominal__ joined
[10:14] *** cognominal_ left
[10:15] *** kurahaupo joined
[10:16] *** not_gerd_ joined
[10:16] <not_gerd_> hello, #perl6

[10:16] *** havenn joined
[10:16] <not_gerd_> r: sub foo(--> Str) { fail }; foo

[10:16] <p6eval> rakudo 3619d7: OUTPUT«Type check failed for return value; expected 'Str' but got 'Failure'␤  in sub foo at /tmp/0ZrVGVmt0m:1␤  in block  at /tmp/0ZrVGVmt0m:1␤␤»

[10:17] <not_gerd_> ^ bug?

[10:17] *** whiteknight joined
[10:19] <jnthn> morning o/

[10:20] <not_gerd_> jnthn: good morning

[10:20] <jnthn> er, afternoon :)

[10:20] <not_gerd_> ;)

[10:20] <not_gerd_> jnthn: http://irclog.perlgeek.de/perl6/2012-10-27#i_6104324

[10:21] *** kurahaupo left
[10:22] *** havenn left
[10:23] <not_gerd_> using typed containers appears to be fraught with gotchas

[10:23] <not_gerd_> Nominal type check failed for parameter '@triggers'; expected Positional but got Array instead

[10:23] <Ulti> win 2

[10:23] <not_gerd_> lose 1

[10:24] <Ulti> :(

[10:24] <Ulti> not that this window isn't my fav ;)

[10:24] <jnthn> not_gerd_: While the error isn't great, note that you can only pass a typed array to something expecting to be passed a typed array

[10:25] <jnthn> r: sub foo(Int @a) { }; my @b = 1,2,3; foo(@b);

[10:25] <p6eval> rakudo 3619d7: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Array instead␤  in sub foo at /tmp/FudroQh7lM:1␤  in block  at /tmp/FudroQh7lM:1␤␤»

[10:25] <jnthn> r: sub foo(Int @a) { }; my Int @b = 1,2,3; foo(@b);

[10:25] <p6eval> rakudo 3619d7:  ( no output )

[10:25] <jnthn> It's on my todo list to make the error include the parametric bit. I'm really not sure why it doesn't already...

[10:25] *** cognominal__ left
[10:26] <not_gerd_> jnthn: any comments on returning Failure from subs with typed return values?

[10:27] *** MayDaniel left
[10:28] <jnthn> not_gerd_: In theory it should work. In practice, making it work may interact interestingly with the optimizer, which believes that if you say you're going to return a Str, you really are, and thus it can analyze/inline any call it's nested in based on that.

[10:29] <not_gerd_> r: (-> Str *@ {})()

[10:29] <p6eval> rakudo 3619d7: OUTPUT«Nominal type check failed for parameter ''; expected Positional but got Array instead␤  in block  at /tmp/8AuoXqKwID:1␤␤»

[10:30] <not_gerd_> r: (-> Str :@dummy {})()

[10:30] <p6eval> rakudo 3619d7: OUTPUT«Nominal type check failed for parameter '@dummy'; expected Positional but got Array instead␤  in block  at /tmp/nj6qHNDKgS:1␤␤»

[10:30] *** pmurias joined
[10:30] <not_gerd_> these were my specific problems

[10:31] *** not_gerd_ is now known as not_gerd

[10:31] *** cognominal joined
[10:31] <jnthn> I think typed slurpies ain't gonna work, but the second one is certainly an issue. I suspect it's creating an untyped default container.

[10:34] <jnthn> moritz: flussence noticed that https://github.com/rakudo/rakudo/commit/837d0f8#L2L30 seems to have accidentally the line that does a read from a socket

[10:36] <jnthn> moritz: I'm spectesting a patch that adds it back, but otoh the spectests didn't miss it in the first place...

[10:37] <jnthn> I'm also thinking I'll include this patch in R* so we don't have a month of "R* won't .read from sockets", but I ain't gonna cut a separate Rakudo release in order to do that.

[10:37] <not_gerd> r: (-> Str @ {})(Nil)

[10:37] <p6eval> rakudo 3619d7: OUTPUT«Nominal type check failed for parameter ''; expected Positional but got Nil instead␤  in block  at /tmp/gLih4ud_F7:1␤␤»

[10:38] <not_gerd> another one I expected to work

[10:38] <jnthn> Hm, not sure about that one. I can see why it perhaps should.

[10:38] <jnthn> r: (-> @a { say @a.WHAT })(Nil)

[10:38] <p6eval> rakudo 3619d7: OUTPUT«Nominal type check failed for parameter '@a'; expected Positional but got Nil instead␤  in block  at /tmp/F4A9bzL7rE:1␤␤»

[10:38] <jnthn> You don't even need to type it for that one though :)

[10:43] *** cognominal left
[10:43] <dalek> rakudo/nom: 72ec639 | jnthn++ | src/core/IO/Socket.pm:

[10:43] <dalek> rakudo/nom: Restore accidentally removed read in IO::Socket.

[10:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/72ec639814

[10:43] <jnthn> phenny: tell flussence I restored the missing read in 72ec639

[10:43] <phenny> jnthn: I'll pass that on when flussence is around.

[10:44] <jnthn> flussence++ # bug report that specified why the code was wrong

[10:48] *** havenn joined
[10:50] <not_gerd> r: (-> Str() $ {})(42)

[10:50] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤Missing block␤at /tmp/Kn4UVMdMLZ:1␤»

[10:50] <not_gerd> not implemented or am I misremembering the syntax?

[10:50] *** tokuhiro_ joined
[10:50] *** cognominal joined
[10:50] <not_gerd> std: (-> Str() $ {})(42)

[10:50] <p6eval> std 64edd1c: OUTPUT«ok 00:00 46m␤»

[10:52] <cognominal> jnthn++  # nice QAST doc

[10:54] <jnthn> not_gerd: The new coercion syntax isn't implemented; Rakudo does support the old "as Str" way.

[10:55] *** havenn left
[11:01] *** rindolf joined
[11:02] <eiro> pull request on vim-perl: gf navigation now works for perl6 

[11:03] <moritz> \o/

[11:16] *** cognominal left
[11:19] *** cognominal_ joined
[11:20] *** cognominal_ left
[11:21] *** havenn_ joined
[11:24] <dalek> star: 742f9db | jnthn++ | docs/announce/2012.10:

[11:24] <dalek> star: Draft release announcement for 2012.10 release.

[11:24] <dalek> star: review: https://github.com/rakudo/star/commit/742f9db78a

[11:24] <dalek> star: 2651682 | jnthn++ | tools/star/Makefile:

[11:24] <dalek> star: Bump versions.

[11:24] <dalek> star: review: https://github.com/rakudo/star/commit/26516829f7

[11:24] <jnthn> moritz: Any chance you could contribute something to the R* release announcement on the $*CUSTOM-LIB and related changes?

[11:25] * jnthn isn't sure exactly what it is about and would rather somebody who groks it well write that section of the announce ;)

[11:27] <jnthn> Additionally, if anybody has suggestions of modules we really should include in R*, let me know. :)

[11:27] <jnthn> (as in, ones we currently don't :))

[11:27] *** havenn_ left
[11:27] <masak> oh, we're in a-star-is-born mode?

[11:27] *** Chillance joined
[11:28] <jnthn> masak: I'll cut the star release during the weekend.

[11:28] <masak> yay

[11:31] *** cognominal joined
[11:43] * not_gerd lunch

[11:43] *** not_gerd left
[11:54] *** havenn joined
[11:56] *** cognominal left
[11:59] *** sisar joined
[12:00] *** havenn left
[12:02] *** colomon joined
[12:03] *** cognominal joined
[12:04] *** domidumont joined
[12:04] *** domidumont left
[12:06] *** domidumont joined
[12:07] *** domidumont left
[12:07] *** domidumont joined
[12:07] *** domidumont left
[12:08] *** domidumont joined
[12:08] *** domidumont left
[12:10] <pmurias> jnthn: when compiling 'module Foo {...}' GLOBALish should contain Foo?

[12:11] *** domidumont joined
[12:12] *** domidumont left
[12:17] <jnthn> pmurias: Yes; done at src/NQP/Grammar.pm:392

[12:18] <jnthn> pmurias: Presuming the module isn't nested in some other package, that is.

[12:18] <jnthn> See 121 for the "default package is GLOBALish"

[12:22] <pmurias> $block.symtable<$?PACKAGE> seems a correct way of extracting GLOBALish? (with $block being the topmost block)

[12:23] <pmurias> I get the right things from $?PACKAGE at runtime, and NQP*HOW,etc. at compile time

[12:24] <jnthn> It'd have to be $block.symtable<$?PACKAGE><value> to get the actual object.

[12:24] <jnthn> But I'd usually write it as $block.symbol('$?PACKAGE')<value>

[12:25] <pmurias> yes, I was adding <value>

[12:25] <pmurias> I'll switch to .symbol

[12:25] <jnthn> It's doing the same thing under the hood, it's just a little shorter 

[12:27] *** havenn joined
[12:29] *** birdwindupbird joined
[12:30] <pmurias> jnthn: for $node.symbol('$?PACKAGE')<value>.WHO -> $pkg_var {...}

[12:30] *** tokuhiro_ left
[12:31] <pmurias> jnthn: should that iterate all the pkg vars?

[12:31] <jnthn> pmurias: Looks right.

[12:31] <jnthn> Well

[12:31] <jnthn> $pkg_var will be soemthing with .key and .value

[12:34] <pmurias> it seems to work for packages other then GLOBALish

[12:34] *** havenn left
[12:36] * pmurias moves to a room with internet good enough for pastebins ;)

[12:38] <dalek> perl6-examples: 00f5048 | (Gerhard R)++ | euler/prob009-gerdr.pl:

[12:38] <dalek> perl6-examples: [euler/prob009] use naive expression for upper bound

[12:38] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/00f50488a6

[12:38] <dalek> perl6-examples: ca200a0 | (Gerhard R)++ | euler/prob009-gerdr-feeds.pl:

[12:38] <dalek> perl6-examples: [euler/prob009] add version using feed operators

[12:38] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/ca200a008a

[12:41] <moritz> jnthn: re %*CUSTOM_LIB, there's a blurb already in docs/depreactions in the rakudo repo

[12:43] <moritz> jnthn: IMHO it would be fine just to copy it over; if you don't think that's good enough, I can write something else too

[12:43] <jnthn> moritz: If you're happy with it, I'm sure it's fine :)

[12:43] *** pmurias left
[12:44] <moritz> well, it's hard for me to judge if it's informative/understandable, because I already know the stuff :-)

[12:45] <jnthn> moritz: It looks OK to me :)

[12:45] *** whiteknight left
[12:45] *** pmurias joined
[12:45] <jnthn> I understand it now anyways :)

[12:46] <moritz> phenny: ask tadzik what he thinks of the panda/custom-lib branch, and if it's mergable before the star release

[12:46] <phenny> moritz: I'll pass that on when tadzik is around.

[12:47] <moritz> maybe not before the star release, but I hope before the the 2011.11 star release :-)

[12:48] <jnthn> Perhaps best to wait for the 2011.11.

[12:48] <pmurias> jnthn: that's what I find at compile time: http://pastie.org/5123213

[12:48] <jnthn> er, 2012.11 :)

[12:48] <moritz> erm yes ._)

[12:49] <jnthn> pmurias: Are you looking at $*UNIT or $*UNIT_OUTER?

[12:49] <jnthn> pmurias: I suspect you're looking at the setting's GLOBALish

[12:49] <jnthn> As in, one frame too far out.

[12:50] <jnthn> (We cheat a little here in so far as the setting's idea of global actually becomes invisible; dates back to before NQP had any export mechanism I guess...)

[12:51] *** cognominal left
[12:51] <pmurias> I'm looking at the $?PACKAGE of all the block in .load, but I guess I should look how the GLOBALish merging work

[12:51] <pmurias> * works

[12:51] <moritz> r: proto sub a($, $?) { }

[12:52] <p6eval> rakudo 72ec63:  ( no output )

[12:53] <pmurias> jnthn: the way nqp-js works is I grab the QAST from the compreg'ed nqp and compile it, so I don't have access to any of the contextuals from the compiler

[12:55] <jnthn> pmurias: OK, to put it another way: what you get as the "top block" isn't UNIT, it's something that wraps it.

[12:55] <jnthn> pmurias: So you need to look one block down for the one whose symbols table contains GLOBALish for the current unit.

[12:59] *** cognominal joined
[13:01] *** havenn joined
[13:04] *** Psyche^ joined
[13:07] *** havenn left
[13:07] *** Patterner left
[13:07] *** Psyche^ is now known as Patterner

[13:12] <flussence> g'mornin, GMT-5

[13:12] <phenny> flussence: 10:43Z <jnthn> tell flussence I restored the missing read in 72ec639

[13:12] <flussence> yay

[13:16] <moritz> flussence++, jnthn++ # noticing and cleaning up my mess

[13:32] *** hash_table joined
[13:34] *** havenn joined
[13:41] *** havenn left
[13:54] <dalek> rakudo/Q: 5157d7f | jnthn++ | src/Perl6/ (2 files):

[13:54] <dalek> rakudo/Q: Stub in quoting grammar/actions.

[13:54] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/5157d7f7d6

[13:54] <dalek> rakudo/Q: 5c6fc96 | jnthn++ | src/Perl6/Grammar.pm:

[13:54] <dalek> rakudo/Q: Start porting Q language from STD.

[13:54] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/5c6fc9620d

[14:01] <dalek> rakudo/proto-arity: ce3b28d | moritz++ | src/core/ (2 files):

[14:01] <dalek> rakudo/proto-arity: start to switch some protos to a more constraint signature

[14:01] <dalek> rakudo/proto-arity: 

[14:01] <dalek> rakudo/proto-arity: we want things like  @list.map: &sin; to work, and that can only work

[14:01] <dalek> rakudo/proto-arity: if &sin is arity 1, so it cannot have a proto sig of (|)

[14:01] <dalek> rakudo/proto-arity: review: https://github.com/rakudo/rakudo/commit/ce3b28dec5

[14:01] <dalek> rakudo/proto-arity: 0315558 | moritz++ | src/core/ (7 files):

[14:01] <dalek> rakudo/proto-arity: narrow down more protos

[14:01] <dalek> rakudo/proto-arity: review: https://github.com/rakudo/rakudo/commit/0315558a15

[14:02] *** PacoAir joined
[14:03] *** mucker joined
[14:05] *** Pleiades` left
[14:06] *** birdwind1pbird joined
[14:07] *** havenn joined
[14:11] *** Pleiades` joined
[14:15] *** havenn left
[14:19] *** cognominal left
[14:22] *** ivan`` left
[14:23] *** ivan`` joined
[14:25] *** arlinius left
[14:29] *** mikemol left
[14:30] *** am0c joined
[14:32] <moritz> if somebody could spectest the proto-arity branch against nom, that would be most welcome

[14:33] <jnthn> moritz: "against nom"? Is the branch not directly from HEAD?

[14:33] <moritz> s/spectest/benchmark/

[14:33] * moritz a bit distracted

[14:33] <moritz> it spectests fine

[14:33] <jnthn> I can run the spectests and see if they're any slower than a normal run. Is there some other benchmark you have in mind?

[14:34] <moritz> nothing in particular, no

[14:34] <jnthn> OK

[14:34] <dalek> rakudo/Q: 6f1695e | jnthn++ | src/Perl6/Grammar.pm:

[14:34] <dalek> rakudo/Q: Add an STD role.

[14:34] <dalek> rakudo/Q: 

[14:34] <dalek> rakudo/Q: While we inherit a bunch of stuff from HLL::Grammar, STD has a few

[14:34] <dalek> rakudo/Q: things factored out that we'd also like to share between languages.

[14:34] <dalek> rakudo/Q: They shall go into this role.

[14:34] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/6f1695ee4a

[14:35] <masak> "Q"? the guy from James Bond movies?

[14:35] <masak> :P

[14:35] <jnthn> No, Q the grammar :P

[14:35] <masak> oh!

[14:35] <jnthn> I'm working on aligning STDs and Rakudo's quote parsing.

[14:35] <jnthn> So we can haz things like quote adverbs.

[14:35] <jnthn> And then, like, heredocs.

[14:37] <masak> cool.

[14:38] * moritz looks forward to it

[14:38] * jnthn too :P

[14:38] <dalek> nqp: 686d9ed | jnthn++ | src/NQP/World.pm:

[14:38] <dalek> nqp: Fix composing roles with regexes in.

[14:38] <dalek> nqp: 

[14:38] <dalek> nqp: The runtime mixin case worked, but curiously not the compile time one.

[14:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/686d9ed5ab

[14:39] <jnthn> moritz: building and spectesting your branch, so can compare times

[14:41] *** havenn joined
[14:41] <dalek> rakudo/nom: e5b94e3 | masak++ | src/Perl6/World.pm:

[14:41] <dalek> rakudo/nom: [src/Perl6/World.pm] make comment more precise

[14:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5b94e343b

[14:45] *** am0c left
[14:46] *** xinming left
[14:46] *** xinming joined
[14:46] <jnthn> moritz: No measurable difference.

[14:46] <moritz> \o/

[14:46] <moritz> then I'll merge

[14:47] <jnthn> moritz: It was a little faster than my last run in nom, but by second a couple of seconds, which is noise.

[14:47] <jnthn> moritz++

[14:48] <jnthn> Gee, it's still October and the November relesae is already starting to smell good :)

[14:48] *** havenn left
[14:49] <moritz> :-)

[14:49] * masak silently works on macros in the background

[14:49] <masak> this roles fixup code doesn't look so bad. should be able to lift it over and declare D2 complete.

[14:50] <colomon> \o/

[14:51] *** sisar left
[14:52] <dalek> rakudo/nom: ce3b28d | moritz++ | src/core/ (2 files):

[14:52] <dalek> rakudo/nom: start to switch some protos to a more constraint signature

[14:52] <dalek> rakudo/nom: 

[14:52] <dalek> rakudo/nom: we want things like  @list.map: &sin; to work, and that can only work

[14:52] <dalek> rakudo/nom: if &sin is arity 1, so it cannot have a proto sig of (|)

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce3b28dec5

[14:52] <dalek> rakudo/nom: 0315558 | moritz++ | src/core/ (7 files):

[14:52] <dalek> rakudo/nom: narrow down more protos

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0315558a15

[14:52] <dalek> rakudo/nom: 6cefb40 | moritz++ | src/core/ (9 files):

[14:52] <dalek> rakudo/nom: Merge branch 'proto-arity' into nom

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6cefb40243

[14:52] <dalek> rakudo/nom: 6859fb6 | moritz++ | docs/ChangeLog:

[14:52] <dalek> rakudo/nom: update ChangeLog with proto arity changes

[14:52] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6859fb69ff

[14:53] *** JJ6 joined
[14:54] *** JJ6 left
[14:59] *** mr007x joined
[15:05] *** cognominal joined
[15:13] <dalek> roast: 8ce7a4e | moritz++ | S (2 files):

[15:13] <dalek> roast: rakudo unfudges

[15:13] <dalek> roast: review: https://github.com/perl6/roast/commit/8ce7a4e211

[15:15] *** havenn joined
[15:16] *** colomon left
[15:21] <masak> r: macro einstein() { my $q = quasi { 2 }; $q = quasi { 1 + {{{$q}}} }; $q = quasi { 1 + {{{$q}}} }; $q }; say einstein()

[15:21] <p6eval> rakudo 6859fb: OUTPUT«4␤»

[15:21] *** MayDaniel joined
[15:21] <masak> \o/

[15:22] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:22] <p6eval> rakudo 6859fb: OUTPUT«Cannot call 'infix:<+>'; none of these signatures match:␤:($x = { ... })␤:(int $a, int $b)␤:(num $a, num $b)␤:(Int:D \a, Int:D \b)␤:(Num:D \a, Num:D \b)␤:(Rational \a, Rational \b)␤:(Rational \a, Int \b)␤:(Int \a, Rational \b)␤:(Complex:D \a, Complex:D \b)␤:(Instan…

[15:22] *** colomon joined
[15:23] <masak> :/

[15:23] <cognominal> what is the meaning of {*} in qnp/src/QAST/Compiler.nqp?

[15:23] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { 66 + {{{$q3}}} } }; say bohr()

[15:23] <p6eval> rakudo 6859fb: OUTPUT«666␤»

[15:23] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { 6 + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:24] <p6eval> rakudo 6859fb: OUTPUT«666␤»

[15:24] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} } }; say bohr()

[15:24] <p6eval> rakudo 6859fb: OUTPUT«6␤»

[15:24] <masak> vewwy weiwd...

[15:24] <jnthn> cognominal: In a proto method? It's "call the appropriate multi here"

[15:24] <masak> so it's only adding *three* things that fails? o.O

[15:24] <masak> s/things/unquotes/

[15:25] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q1}}} + {{{$q1}}} } }; say bohr()

[15:25] <p6eval> rakudo 6859fb: OUTPUT«18␤»

[15:25] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q2}}} + {{{$q2}}} + {{{$q2}}} } }; say bohr()

[15:25] <p6eval> rakudo 6859fb: OUTPUT«180␤»

[15:25] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q3}}} + {{{$q3}}} + {{{$q3}}} } }; say bohr()

[15:25] <p6eval> rakudo 6859fb: OUTPUT«1800␤»

[15:25] <cognominal> jnthn, thx

[15:25] <masak> what in the world...

[15:26] <jnthn> masak: Did you meant to do $q3 in all the quasis?

[15:26] <pmurias> jnthn: I put $*UNIT in every put and it still lacks the package

[15:26] <jnthn> 'cus 600 + 600 + 600 is 1800 in my book :)

[15:26] <pmurias> s/put/pad/

[15:27] <masak> jnthn: only {{{$q1}}} + {{{$q2}}} + {{{$q3}}} fails. all other combos succeed. that's the weird thing.

[15:27] <masak> my best guess is that it's something that trips on the exact shape of the AST created by combining those arithmetical expressions.

[15:27] <jnthn> masak: It's nothing to do with the first quasi just having a literal in?

[15:27] <masak> why would that make a difference?

[15:28] <jnthn> I've no idea :)

[15:28] <masak> {{{$q1}}} + {{{$q1}}} + {{{$q1}}} succeeds.

[15:28] <jnthn> ah, true

[15:29] *** domidumont joined
[15:29] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { say "are we failing in here?"; 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:29] <p6eval> rakudo 6859fb: OUTPUT«Cannot call 'infix:<+>'; none of these signatures match:␤:($x = { ... })␤:(int $a, int $b)␤:(num $a, num $b)␤:(Int:D \a, Int:D \b)␤:(Num:D \a, Num:D \b)␤:(Rational \a, Rational \b)␤:(Rational \a, Int \b)␤:(Int \a, Rational \b)␤:(Complex:D \a, Complex:D \b)␤:(Instan…

[15:29] <pmurias> jnthn: how does WHO work?

[15:30] <masak> huh. which infix:<+> *is* failing?

[15:30] <masak> jnthn: or, hm, is that a compile-time error?

[15:31] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; BEGIN { say "A" }; say bohr(); BEGIN { say "B" }

[15:31] <p6eval> rakudo 6859fb: OUTPUT«A␤B␤Cannot call 'infix:<+>'; none of these signatures match:␤:($x = { ... })␤:(int $a, int $b)␤:(num $a, num $b)␤:(Int:D \a, Int:D \b)␤:(Num:D \a, Num:D \b)␤:(Rational \a, Rational \b)␤:(Rational \a, Int \b)␤:(Int \a, Rational \b)␤:(Complex:D \a, Complex:D \b)␤:(In…

[15:31] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say "alive"; say bohr()

[15:31] <p6eval> rakudo 6859fb: OUTPUT«alive␤Cannot call 'infix:<+>'; none of these signatures match:␤:($x = { ... })␤:(int $a, int $b)␤:(num $a, num $b)␤:(Int:D \a, Int:D \b)␤:(Num:D \a, Num:D \b)␤:(Rational \a, Rational \b)␤:(Rational \a, Int \b)␤:(Int \a, Rational \b)␤:(Complex:D \a, Complex:D \b)␤:(…

[15:31] <jnthn> pmurias: It just grabs the stash associated with the type

[15:31] <jnthn> pmurias: Under the hood it's no more than STABLE(obj)->WHO

[15:32] <masak> r: macro bohr() { say "A"; my $q1 = quasi { 6 }; say "B"; my $q2 = quasi { 6 * 10 }; say "C"; my $q3 = quasi { 100 + 200 + 300 }; say "D"; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:32] <p6eval> rakudo 6859fb: OUTPUT«A␤B␤C␤D␤Cannot call 'infix:<+>'; none of these signatures match:␤:($x = { ... })␤:(int $a, int $b)␤:(num $a, num $b)␤:(Int:D \a, Int:D \b)␤:(Num:D \a, Num:D \b)␤:(Rational \a, Rational \b)␤:(Rational \a, Int \b)␤:(Int \a, Rational \b)␤:(Complex:D \a, Complex:D \b)␤…

[15:32] <jnthn> pmurias: In NQP it's just set to a hash. In Rakudo we set it to a Perl 6 Stash object.

[15:32] <masak> r: macro bohr() { my $q1 = quasi { 1 + 5 }; my $q2 = quasi { 6 * 10 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:32] <p6eval> rakudo 6859fb: OUTPUT«720␤»

[15:32] <masak> jnthn: you're right.

[15:33] <jnthn> o.O

[15:33] <jnthn> wtf, it was a complete guess

[15:33] <masak> jnthn: it *does* have to do with $q1 containing just a literal.

[15:33] <masak> note also that the above answer is wrong.

[15:33] <masak> it should be 666, not 720.

[15:33] <masak> something weird is going on here with precedence.

[15:33] <colomon> hmmm... $q2 + $q2 + $q3 is 720

[15:34] <masak> r: macro bohr() { my $q1 = quasi { 1 + 5 }; my $q2 = quasi { 10 + 50 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:34] <p6eval> rakudo 6859fb: OUTPUT«720␤»

[15:34] <jnthn> I'm doubtful it's a precedence bug. I do have to wonder if it's not something busted in the code that walks through the AST to find quasis and splicing things in.

[15:34] <masak> ok, not a precedence bug.

[15:34] <masak> I like colomon's theory better.

[15:34] <masak> maybe $q1 gets lost somewhere and $q2 gets used instead.

[15:35] <masak> r: macro bohr() { my $q1 = quasi { 6 * 10 }; my $q2 = quasi { 1 + 5 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:35] <p6eval> rakudo 6859fb: OUTPUT«612␤»

[15:35] <masak> yeah, colomon++ is right.

[15:35] <jnthn> masak: Yes, my guess was that the "getting lost" is happening in the spliciing.

[15:35] <masak> quite possibly.

[15:37] * masak submits rakudobug

[15:38] <colomon> thought: maybe the reason it wouldn't work when it was quasi { 6 } is there wasn't enough room to splice in 6 * 10.

[15:38] <colomon> r: macro bohr() { my $q1 = quasi { 6 * 10  }; my $q2 = quasi { 1 + 5 * 2 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:38] <p6eval> rakudo 6859fb: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤␤  in method Numeric at src/gen/CORE.setting:795␤  in sub infix:<+> at src/gen/CORE.setting:2602␤  in  at /tmp/dU2oFIuXp5:1␤  in block  at /tmp/dU2oFIuXp5:1␤␤»

[15:39] <colomon> r: macro bohr() { my $q1 = quasi { 6  }; my $q2 = quasi { 1 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:39] <p6eval> rakudo 6859fb: OUTPUT«602␤»

[15:39] <colomon> r: macro bohr() { my $q1 = quasi { 6 + 1 }; my $q2 = quasi { 1 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:39] <p6eval> rakudo 6859fb: OUTPUT«608␤»

[15:40] <colomon> didn't expect that.

[15:40] <masak> it gets the sum right.

[15:40] <masak> that last one, I mean.

[15:40] <masak> what the heck is going on here...?

[15:41] <diakopter> r: macro bohr() { my $q2 = quasi { 1 + 5 }; my $q1 = quasi { 10 + 50 }; quasi { {{{$q1}}} + {{{$q2}}} + 600 } }; say bohr()

[15:41] <p6eval> rakudo 6859fb: OUTPUT«612␤»

[15:41] <diakopter> the second splats the first

[15:42] <masak> not in the "608" case above.

[15:42] <colomon> hold on, better test

[15:42] <masak> so, yes, but only sometimes.

[15:42] <diakopter> when both are additions

[15:42] <colomon> r: macro bohr() { my $q1 = quasi { 6 + 1 }; my $q2 = quasi { 9 }; my $q3 = quasi { 100 + 200 + 300 }; quasi { {{{$q1}}} + {{{$q2}}} + {{{$q3}}} } }; say bohr()

[15:42] <p6eval> rakudo 6859fb: OUTPUT«616␤»

[15:43] <diakopter> oH!

[15:43] <diakopter> when both have 2 terms

[15:43] <diakopter> multiplication works too

[15:44] <diakopter> first splats the second when theyy're the same shape?

[15:44] *** rindolf left
[15:44] <colomon> but if the second is bigger, it super splats it, making something outright illegal.

[15:44] <masak> doesn't cover it. the first case had $q1 = quasi { 6 } and $q2 = quasi { 6 * 10 }

[15:44] *** rindolf joined
[15:45] <masak> oh!

[15:45] <masak> yes, diakopter + colomon might cover it.

[15:45] * masak re-reads backlog to make sure

[15:45] <diakopter> sorry; I meant second splats the first

[15:45] *** mucker left
[15:45] <diakopter> typosed

[15:46] <masak> r: macro bohr() { my $q1 = quasi { 6 }; my $q2 = quasi { 6 * 10 }; quasi { {{{$q1}}} + {{{$q2}}} } }; say bohr()

[15:46] <p6eval> rakudo 6859fb: OUTPUT«Cannot call 'infix:<+>'; none of these signatures match:␤:($x = { ... })␤:(int $a, int $b)␤:(num $a, num $b)␤:(Int:D \a, Int:D \b)␤:(Num:D \a, Num:D \b)␤:(Rational \a, Rational \b)␤:(Rational \a, Int \b)␤:(Int \a, Rational \b)␤:(Complex:D \a, Complex:D \b)␤:(Instan…

[15:46] <masak> diakopter: oh; that's how I read you anyway :)

[15:46] <masak> r: macro bohr() { my $q1 = quasi { 5 + 1 }; my $q2 = quasi { 6 * 10 }; quasi { {{{$q1}}} + {{{$q2}}} } }; say bohr()

[15:46] <p6eval> rakudo 6859fb: OUTPUT«120␤»

[15:46] <diakopter> I mean, it'd be cuter if the first got the second

[15:47] <masak> yes, diakopter + colomon seem to have it.

[15:47] <diakopter> maybe

[15:47] <colomon> I don't understand it, I'm just trying to pin down the behavior.  :)

[15:47] <jnthn> phenny: ask TimToady what stops the sequential alternation in nibbler from being a normal alternation?

[15:47] <phenny> jnthn: I'll pass that on when TimToady is around.

[15:48] <diakopter> jnthn: what does it become if not a normal alternation?

[15:48] <masak> colomon: same here.

[15:48] <diakopter> a method?

[15:48] <jnthn> diakopter: It means that the NFA can't be used to pick the branch to take.

[15:50] <diakopter> r: macro bohr() { my $q2 = quasi { 1 + 5 }; my $q1 = quasi { 10 - 50 }; quasi { {{{$q1}}} + {{{$q2}}} } }; say bohr()

[15:50] <p6eval> rakudo 6859fb: OUTPUT«12␤»

[15:51] <colomon> diakopter++

[15:51] <diakopter> wait, it's the second *in the addition*, not the second to be declared

[15:51] *** birdwind1pbird left
[15:51] <jnthn> phenny: ask TimToady Why "push @nibbles, $<starter>;" but $<escape>[*-1], $<nibbler>[*-1], etc? Bug?

[15:51] <phenny> jnthn: I'll pass that on when TimToady is around.

[15:56] <diakopter> r: macro bohr { my $q2 = quasi { 1 + 5 }; my $q1 = quasi { 10 - 50 }; quasi { try eval('DROOL') + {{{$q2}}} } }; say bohr

[15:56] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling block bohr: Error while compiling block : Error while compiling block : Error while compiling op call: Unknown QAST node type QAST::Unquote␤at /tmp/MXwoFA4Rny:1␤»

[15:56] <diakopter> masak: that's something ^^

[15:57] <diakopter> what's a QAST::Unquote

[15:57] <diakopter> that's what she said

[15:59] <masak> diakopter: nice.

[15:59] <masak> yes, the fact that QAST::Unquote shows up so late in compilation is always a bug.

[15:59] <masak> something is afoot here.

[15:59] <masak> jnthn: I'm starting to think that the problem is in the find-unquotes recursion.

[15:59] <diakopter> ahand too

[16:04] <jnthn> masak: Sounds feasible given what we're observing.

[16:04] <masak> that code is in nqp. it's very approachable.

[16:04] <masak> maybe it does something wrong with operators?

[16:04] <diakopter> r: macro bohr { quasi { try eval('DROOL') } }; bohr

[16:04] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Method 'evaluate_unquotes' not found for invocant of class 'String'␤at /tmp/kD5frDqxtm:1␤»

[16:04] <diakopter> o+O

[16:04] <jnthn> masak: Didn't you write that code? :)

[16:05] <masak> jnthn: yes, of course I did. :)

[16:05] <diakopter> what's evaluate_unqoutes

[16:05] <jnthn> masak: I'm glad you find it approachable :P

[16:05] <masak> should be this one: https://github.com/perl6/nqp/blob/master/src/QAST/Op.nqp#L21

[16:05] <jnthn> masak: QAST::Op should be quite simple..

[16:06] <masak> looks right to me.

[16:06] <diakopter> masak: another weird bug ^^

[16:06] <jnthn> masak: boom, headshot

[16:06] <jnthn> masak: my $result := pir::repr_clone__PP(self);

[16:06] <masak> diakopter: yes. further confirmation that we've identified the area where things are going wrong.

[16:06] <jnthn> masak: That clones the *node*

[16:06] <jnthn> masak: But not the children array within it

[16:06] <jnthn> There's a method in QAST::Node called shallow_clone, iirc

[16:06] <masak> jnthn: oh!

[16:06] <jnthn> That clones the object *and* the child array.

[16:06] <diakopter> r: macro marco { quasi { quasi { 5 } } }; say marco

[16:07] <p6eval> rakudo 6859fb: OUTPUT«AST.new()␤»

[16:07] <jnthn> diakopter: That one actually looks right :P

[16:07] <masak> jnthn: would this explain the RT ticket I just filed, about $q1 and $q2 ?

[16:07] <jnthn> masak: possibly

[16:07] <masak> diakopter: that one is right.

[16:07] <diakopter> cool

[16:07] <jnthn> masak: It'd certainly cause...issues.

[16:07] <masak> diakopter: quasi blocks produce AST objects.

[16:07] <masak> jnthn: I'll see about pushing a fix.

[16:08] *** cognominal left
[16:09] <dalek> rakudo/Q: 50c8923 | jnthn++ | src/Perl6/Grammar.pm:

[16:09] <dalek> rakudo/Q: First crack at babble.

[16:09] <dalek> rakudo/Q: 

[16:09] <dalek> rakudo/Q: Fairly alike the STD version, except we cache the derived languages.

[16:09] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/50c89237e6

[16:09] <dalek> rakudo/Q: 5050218 | jnthn++ | src/Perl6/Grammar.pm:

[16:09] <dalek> rakudo/Q: Initial port of nibbler, nibble and quibble.

[16:09] <dalek> rakudo/Q: 

[16:09] <dalek> rakudo/Q: Fairly close to STD, but nibbler should be faster this way. Skipped

[16:09] <dalek> rakudo/Q: the runaway multi-line string detection for now; can add it later.

[16:09] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/505021806a

[16:12] *** colomon_ joined
[16:12] <jnthn> break; afk for a bit

[16:12] *** colomon left
[16:12] *** colomon_ is now known as colomon

[16:13] <moritz> jnthn: please also document those rules, I find the names confusing :-)

[16:14] *** cognominal joined
[16:15] <diakopter> r: macro marco { try 0 }; marco

[16:15] <p6eval> rakudo 6859fb: OUTPUT«(timeout)»

[16:15] <diakopter> masak: ^^

[16:16] * masak submits rakudobug

[16:17] <masak> r: BEGIN { try 0 }; say "alive"

[16:17] <p6eval> rakudo 6859fb: OUTPUT«(timeout)»

[16:17] <masak> seems it has nothing to do with macros, just 'try' at BEGIN time.

[16:17] <diakopter> oh

[16:18] <masak> r: BEGIN { try { say 0 } }; say "alive"

[16:18] <p6eval> rakudo 6859fb: OUTPUT«(timeout)0␤»

[16:18] <diakopter> r: macro marco { die 1 }; say marco

[16:18] <moritz> r: BEGIN try 0;

[16:19] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Method 'SET_FILE_LINE' not found for invocant of class 'X::AdHoc'␤»

[16:19] <p6eval> rakudo 6859fb: OUTPUT«(timeout)»

[16:19] <diakopter> masak: SET_FILE_LINE error

[16:19] <moritz> I can try to investigate that

[16:19] <masak> at a guess, the bug in podolsky() is also related to the RT ticket found today.

[16:20] <masak> diakopter: that looks genuine.

[16:20] * masak submits rakudobug

[16:20] <masak> diakopter: do you have like a big table of features to try and combine?

[16:21] <masak> because sometimes I've toyed with the idea of making such a table.

[16:21] <diakopter> no just a brain full of jumbled mess

[16:21] <masak> :P

[16:22] *** kaare_ joined
[16:25] <diakopter> masak: what do parameters to macros do

[16:28] <diakopter> r: macro marco { polo }; macro polo { marco }; say marco

[16:28] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Could not find sub &polo␤at /tmp/jEHRf9GTEQ:1␤»

[16:28] <diakopter> r: macro marco { polo }; macro polo { marco }; say polo

[16:28] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Could not find sub &polo␤at /tmp/M02sEn7GNH:1␤»

[16:28] <diakopter> funny they both can't find polo

[16:29] <diakopter> r: macro marco { polo }; macro polo { quasi { 55 } }; say marco

[16:29] <p6eval> rakudo 6859fb: OUTPUT«55␤»

[16:29] *** jaldhar left
[16:29] <masak> diakopter: arguably the should find polo, since it's been defined before marco is called.

[16:30] <masak> they*

[16:30] *** rindolf left
[16:30] <diakopter> but the 3rd marco finds polo before it's defined

[16:30] <masak> diakopter: but recursion inside macros needs to bottom out, just like all other recursion :)

[16:30] <masak> oh, so it does. weird.

[16:31] <masak> I can't really explain that.

[16:31] <masak> diakopter: parameters on macros are AST-ifications of the arguments you pass to macros. you can unquote them in quasi blocks.

[16:31] <masak> r: macro twice($stuff) { quasi { {{{$stuff}}

[16:31] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Unable to parse expression in block; couldn't find final '}' at line 2, near ""␤»

[16:31] <masak> ugh.

[16:32] <masak> r: macro twice($stuff) { quasi { {{{$stuff}}}; {{{$stuff}}} } }; twice say "OH HAI"

[16:32] <p6eval> rakudo 6859fb: OUTPUT«OH HAI␤OH HAI␤»

[16:32] * masak submits the marco-polo thing

[16:33] <masak> r: macro marco { say "m"; polo }; macro polo { say "p"; marco }; marco

[16:33] <p6eval> rakudo 6859fb: OUTPUT«m␤===SORRY!===␤Could not find sub &polo␤at /tmp/zXOBjjGx1r:1␤»

[16:33] <masak> r: macro marco { say "m"; polo }; macro polo { say "p"; marco }; polo

[16:33] <p6eval> rakudo 6859fb: OUTPUT«m␤===SORRY!===␤Could not find sub &polo␤at /tmp/hQL1B2hOCX:1␤»

[16:33] <masak> that last one does not make sense.

[16:34] <masak> it should not say "m"

[16:34] <masak> oh!

[16:34] <masak> no, I'm wrong.

[16:35] <masak> "marco" inside "polo" is a macro invocation and gets run at parse time, when parsing "polo".

[16:35] <masak> so what you should be getting, diakopter, is an infinite loop at parse time.

[16:35] <moritz> why?

[16:36] <moritz> at parse time, polo is not known

[16:36] <masak> right.

[16:36] <moritz> so it can't be called

[16:36] <masak> right.

[16:36] <masak> it might be that forward-calls to macros just don't make sense.

[16:37] <masak> because "polo" in "marco" should've been a macro invocation, too, had the parser known that it'd be declared as a macro.

[16:37] <moritz> well, it would compile it to a run-time call, because it's not yet known as a macro

[16:37] <masak> right.

[16:37] <moritz> and then when the parser finds that's a macro, not an ordinary routine, it has to shake its head in confusion

[16:38] <masak> right now, it just moves on with life.

[16:38] <masak> r: foo; sub foo { say "OH HAI" }

[16:38] <p6eval> rakudo 6859fb: OUTPUT«OH HAI␤»

[16:38] <masak> r: foo; macro foo { say "OH HAI" }

[16:38] <p6eval> rakudo 6859fb: OUTPUT«OH HAI␤»

[16:38] <masak> o.O

[16:38] *** benabik left
[16:38] <masak> I wonder why that one works.

[16:39] <masak> r: BEGIN { say "A" }; foo; BEGIN { say "B" }; macro foo { say "OH HAI" }

[16:39] <p6eval> rakudo 6859fb: OUTPUT«A␤B␤OH HAI␤»

[16:39] *** benabik joined
[16:39] <masak> ahahah.

[16:39] <masak> it gets called as a sub.

[16:39] <jnthn> BEGIN time dynamic compilation has snapshot semantics on the outer lexpad.

[16:39] <masak> yeah.

[16:39] <jnthn> Because lexpads are immutable, it just constructs an outer view based on what is decalred so far.

[16:39] <jnthn> And that view is a snapshot, and not updated.

[16:40] <masak> jnthn: well, foo is called as a sub above.

[16:40] <masak> hence the ordering between "B" and "OH HAI".

[16:40] <jnthn> Yes, that's unsurprising.

[16:40] <jnthn> I'm just pointing out why you might be seeing other interesting things, generally.

[16:40] <masak> so, the rule is, Rakudo tries to call all forward-declared macros as subs. sometimes, it succeeds.

[16:40] <jnthn> Well, if we take the one that failed:

[16:41] <masak> oh, and it doesn't succeed in the "polo" case, because &polo simply isn't visible from within &marco.

[16:41] <jnthn> macro marco { say "m"; polo }; macro polo { say "p"; marco }; marco

[16:42] <jnthn> Disecting this, we se marco, it calls it at compile time, says "m", but there was no polo in the lexpad at the time marco got its snapshot (which happend while parsing polo but before polo was installed).

[16:42] <masak> ah.

[16:42] <masak> so routines get installed at the '}'?

[16:42] <jnthn> Yeah

[16:43] <masak> that makes sense, because lexpads, I guess.

[16:43] <jnthn> We could potentially change that.

[16:43] <jnthn> But I'm not keen at all.

[16:43] <masak> well, it's only an issue with macros.

[16:43] <jnthn> Because it's...dangerous...without other changes.

[16:43] <masak> *nod*

[16:43] <masak> no urgent need.

[16:44] <jnthn> btw, I realized that at the least the non-cloning bug could be why you had that bug when you tried to matryosha quasis in a loop.

[16:44] <jnthn> *matryoshka

[16:44] <masak> <masak> at a guess, the bug in podolsky() is also related to the RT ticket found today.

[16:45] <masak> jnthn: yeah, I realized that in the above line, too :)

[16:45] <jnthn> oh, I didn't fully backlog the bit when I was away :)

[16:45] <masak> it's nice when bugs unify ;)

[16:45] <jnthn> Talking of away, I guess I should go buy something to cook/eat for dinner...

[16:46] <masak> I'll try to fix the cloning bug le meantime.

[16:46] <masak> s/le/in le/

[16:48] * moritz should do his bugfix in nom, not in a non-working, experimental branch :-)

[16:49] <masak> git stash FTW.

[16:52] *** colomon left
[16:57] *** colomon joined
[16:57] *** MikeFair left
[16:57] *** MikeFair joined
[17:07] *** benabik left
[17:09] *** benabik joined
[17:22] *** fgomez left
[17:22] *** fgomez joined
[17:25] <masak> jnthn: I'm going to commit anyway, because I'm reasonably convinced this is fine. but I found the same need for self.shallow_clone(), not just in 'Op.pm', also in <Block Stmt Stmts Want> >>~>> '.pm'.

[17:25] * masak builds and tests

[17:29] <jnthn> yes, anything with kids will need it

[17:30] * masak .oO( these nodes shouldn't be getting on a plane at all... )

[17:31] <flussence> Public Service Announcement: hacking on a crashy web app is much nicer with daemontools instead of doing ^C/↑/␤ in a terminal window after every change.

[17:32] *** GlitchMr left
[17:32] <TimToady> .u ↑

[17:32] <phenny> U+2191 UPWARDS ARROW (↑)

[17:32] <phenny> TimToady: 15:47Z <jnthn> ask TimToady what stops the sequential alternation in nibbler from being a normal alternation?

[17:32] <phenny> TimToady: 15:51Z <jnthn> ask TimToady Why "push @nibbles, $<starter>;" but $<escape>[*-1], $<nibbler>[*-1], etc? Bug?

[17:32] *** GlitchMr joined
[17:32] <moritz> p6eval runs inside a  while true; do perl evalbot.pl $configfile; sleep 20; done;   loop

[17:33] <moritz> :-)

[17:33] <dalek> nqp: bc73493 | masak++ | src/QAST/ (5 files):

[17:33] <dalek> nqp: [src/QAST/*.nqp] shallow-clone nodes with kids

[17:33] <dalek> nqp: 

[17:33] <dalek> nqp: A node without children can make do with the

[17:33] <dalek> nqp: pir::repr_clone__PP call that was already there.

[17:33] <dalek> nqp: But those that use the array of children need that

[17:33] <dalek> nqp: cloned too, so we do self.shallow_clone();

[17:33] <dalek> nqp: 

[17:33] <dalek> nqp: This ought to fix a number of weird quasi-related

[17:33] <dalek> nqp: behaviors we've seen in Rakudo.

[17:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bc734932e9

[17:33] <masak> jnthn: is it kosher to bump NQP_REVISION? defaulting to "yes".

[17:34] <flussence> masak: I've done that before, but I felt like being fancy for a change :)

[17:34] <flussence> whoops

[17:34] <flussence> s/m.*/$the-other-m/

[17:35] <dalek> rakudo/nom: 9d50d6b | masak++ | tools/build/NQP_REVISION:

[17:35] <dalek> rakudo/nom: [NQP_REVISION] bump for better unquotes handling

[17:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9d50d6bce4

[17:35] <jnthn> masak: yes, that's pretty much always safe

[17:36] *** birdwindupbird left
[17:36] <masak> the only thing I could think of that would make it less than desirable was the upcoming star release.

[17:36] <TimToady> re starter/stopper not using [*-1], yes, that's probably a buglet, but masked by the downstream ignoring them, since the internal starter/stoppers just end up part of the string

[17:38] <TimToady> jnthn: and re || vs |, I just wanted to make sure the quote nester overrode any random escapes you happen to have included by accident, since the quote chars are probably in the user's head, and the escapes probably aren't

[17:39] <TimToady> qq{ { } } chooses to treat the internals as starter/stopper rather than closure interpolation, for instance

[17:41] <TimToady> though that may be a retro-rationale; doing LTM between starters and escapes was not working out for some reason that I don't recollect

[17:41] *** telex left
[17:42] <TimToady> it might be that it blew up my lexer-writer at the time somehow

[17:42] *** telex joined
[17:42] <masak> podolsky() passes locally \o/

[17:43] <diakopter> r: macro marco { AST.new }; marco

[17:43] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block : Unknown QAST node type Any␤»

[17:43] <diakopter> :>

[17:43] <masak> bohr() still fails :/

[17:43] <TimToady> otoh I think privileging the starter/stopper is consistent with checking for the stopper as the loop condition

[17:44] <masak> diakopter: fair point.

[17:44] * masak submits rakudobug

[17:45] *** benabik left
[17:46] <diakopter> r: macro polo { quasi { 5 } }; &polo = macro { quasi { 3 } }; say polo

[17:46] <TimToady> so, for instance, qq$ $foo $ is going to take the variable's $ as the quote terminator despite $foo being (potentially) a longer token

[17:46] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling op p6store: Unknown QAST node type NQPMu␤»

[17:46] <TimToady> so it's kinda consistent to treat internal {} as starter/stopper even if it could be an escape too

[17:46] <diakopter> masak: I dunno. trying to clobber polo.

[17:47] *** fgomez left
[17:47] <jnthn> TimToady: OK, makes sense.

[17:47] <TimToady> kinda :)

[17:48] <jnthn> One option if we want it to be LTMable is to whack a <!starter> before the <escape>

[17:48] <TimToady> I know when I first started out I had grand schemes of including terminators in with other categories, but it tended not to work out well

[17:48] <diakopter> r: macro polo { quasi { 5 } }; class polo { quasi { 3 } }; say polo

[17:48] <p6eval> rakudo 6859fb: OUTPUT«polo()␤»

[17:48] <jnthn> dinner, bbiab

[17:49] <diakopter> masak: I can't redeclare &polo, but I can make a class of that name

[17:49] *** hash_table left
[17:49] <jnthn> diakopter: Your class is called polo, not &polo :)

[17:49] <TimToady> well, if we can make | work faster than ||, it's worth looking at

[17:49] <diakopter> I know

[17:49] <diakopter> I was referring to an unseen p6eval query

[17:50] <diakopter> r: macro polo { quasi { 5 } }; my &polo = { quasi { 3 } }; say polo

[17:50] <p6eval> rakudo 6859fb: OUTPUT«===SORRY!===␤Redeclaration of symbol &polo␤at /tmp/Oul3A0pquq:1␤»

[17:50] <diakopter> jnthn: (that)

[17:51] <diakopter> jnthn: (but I can make a class with name polo)

[17:52] <TimToady> but my guess is that | vs || will be in the noise, unless can find a fast way to maybe scan .*? in front of it, but then you probably need both <!starter> and <!stopper> in front of <escape>

[17:53] <TimToady> furthermore, and difference between | and || code might disappear as we optimized Perl 6 further, since the | form would just be moving the .*? loop to lower-level code which, while faster now, might not be faster later

[17:54] *** fgomez joined
[17:54] <GlitchMr> I've Perl 6 changes... now only if my Internet would be quicker... I've typed git push and nothing.

[17:55] * TimToady struggles feebly to get out of the conjectural-analytical weeds

[17:55] * diakopter hands TimToady a presupposition

[17:56] * TimToady looks at it, and wishes it were a postsupposition instead...

[17:56] <TimToady> or perhaps a midsupposition...

[17:56] <moritz> you suppostitions lot!

[17:57] <GlitchMr> | is so natural. It allows some abuse of it like http://codegolf.stackexchange.com/a/8776/3103, but it also could make really nice code.

[17:57] <moritz> *suppostitious # way to kill a pun with a typo

[17:57] <GlitchMr> I mean, x is 0 or 2, not x is 0 or x is 2.

[17:58] <GlitchMr> I still have to find use for ^, but whatever.

[17:59] <dalek> perl6-examples: 1f2506c | (Gerhard R)++ | euler/prob053-gerdr.pl:

[17:59] <dalek> perl6-examples: [euler/prob053] add version using feed operators

[17:59] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/1f2506c7ef

[17:59] <TimToady> moritz: you could blame it on pyslexia instead

[18:01] <TimToady> or would that be qyslexia in this case...

[18:01] <diakopter> r: sub foo { my $x = 5; macro bar { quasi { macro bar { quasi { $x } } } } }; say foo

[18:01] <p6eval> rakudo 6859fb: OUTPUT«5␤»

[18:01] <diakopter> oh.

[18:01] <diakopter> r: sub foo { my $x = 5; 7; macro bar { quasi { macro bar { quasi { $x } } } } }; say foo

[18:01] <p6eval> rakudo 6859fb: OUTPUT«7␤»

[18:03] <masak> diakopter: as jnthn points out, with the macro-and-sub there is an actual name clash, since both are named &polo. with macro-and-class, there isn't.

[18:03] *** rindolf joined
[18:04] <diakopter> ok

[18:06] <diakopter> r: sub foo { my $x = 5; 7; regex foo { quasi { $x } }; say 'alive'; foo }; say foo

[18:06] <p6eval> rakudo 6859fb: OUTPUT«(timeout)Useless declaration of a has-scoped method in mainline␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤alive␤ali…

[18:06] <diakopter> oh hm

[18:06] <diakopter> nm

[18:07] <TimToady> std: sub foo { my $x = 5; 7; regex foo { quasi { $x } }; say 'alive'; foo }; say foo

[18:07] <GlitchMr> Finite recursion depth would be weird for interpreted language.

[18:07] <p6eval> std 64edd1c: OUTPUT«Potential difficulties:␤  'regex' declaration outside of grammar at /tmp/mEEtd2ssnm line 1:␤------> sub foo { my $x = 5; 7; regex foo ⏏{ quasi { $x } }; say 'alive'; foo }; sa␤ok 00:00 45m␤»

[18:08] <GlitchMr> Especially one that encourages functional programming.

[18:08] <diakopter> r: sub foo { my $x = 5; 7; &foo() }; say foo

[18:08] <p6eval> rakudo 6859fb: OUTPUT«maximum recursion depth exceeded␤current instr.: 'print_exception' pc 89091 (src/gen/CORE.setting.pir:42742) (src/gen/CORE.setting:9094)␤called from Sub 'foo' pc 111 ((file unknown):80) (/tmp/Mh3jcAAI_K:1)␤called from Sub 'foo' pc 155 ((file unknown):103) (/tmp/Mh3…

[18:08] <diakopter> r: sub foo { my $x = 5; 7; class foo { }; &foo() }; say foo

[18:08] <p6eval> rakudo 6859fb: OUTPUT«foo()␤»

[18:09] <diakopter> somehow the addition of class foo makes &foo() not recurse

[18:09] <GlitchMr> Uhm, how did previous example and that didn't?

[18:09] <GlitchMr> worked*

[18:09] <diakopter> GlitchMr: I dunno; I'm curious too

[18:09] <masak> GlitchMr: no, finite recursion depth is very common, and pretty much a necessity if you have stackframes.

[18:10] <masak> (and no guarantees of tail-call optimization)

[18:10] <GlitchMr> Perl 5 haves infinite recursion depth (except for operator overloading which doesn't for some reason)

[18:10] <diakopter> interpreted can still have the exact same call stack structure as compiled

[18:10] <GlitchMr> has*

[18:12] <diakopter> eval: sub foo{foo};foo

[18:12] <buubot_backup> diakopter: foo

[18:12] <TimToady> Perl 5 is (largely) stackless

[18:12] <GlitchMr> Also, ZX Spectrum BASIC only has memory as recursion limit

[18:12] <GlitchMr> Why Perl 6 would have it?

[18:12] <TimToady> so the call stack is really in the heap

[18:13] <TimToady> but Perl 5 doesn't to tail-recursion optimization, last I knew

[18:13] <TimToady> *do

[18:13] <GlitchMr> Well, technically there is goto &sub, but it

[18:13] <GlitchMr> 's manual optimization

[18:13] <diakopter> eval: sub foo {foo};foo

[18:13] <buubot_backup> diakopter: foo

[18:13] <diakopter> eval: sub foo {foo};foo()

[18:13] <buubot_backup> diakopter: foo

[18:14] <diakopter> eval: sub foo {foo};&foo->()

[18:14] <buubot_backup> diakopter: foo

[18:14] <GlitchMr> diakopter: foo sub it unknown until Perl sees ending brace of sub

[18:14] <GlitchMr> eval: sub foo; sub foo { foo }; foo

[18:14] <buubot_backup> GlitchMr: Out of memory! 

[18:14] <GlitchMr> eval: sub foo { foo() }; foo

[18:14] <diakopter> oh yeah.

[18:14] <buubot_backup> GlitchMr: Out of memory! 

[18:14] *** cognominal left
[18:14] <GlitchMr> is unknown*

[18:15] <masak> GlitchMr: so. Perl 5 doesn't have infinite recursion depth.

[18:15] <diakopter> TimToady: does p5 malloc frames one by one? or by large blocks?

[18:16] <GlitchMr> masak: obviously no language has infinite recursion depth

[18:16] <jnthn> r: sub foo { my $x = 5; 7; &foo() }; say foo

[18:16] <p6eval> rakudo 9d50d6: OUTPUT«maximum recursion depth exceeded␤current instr.: 'print_exception' pc 89091 (src/gen/CORE.setting.pir:42742) (src/gen/CORE.setting:9094)␤called from Sub 'foo' pc 111 ((file unknown):80) (/tmp/BRQJDGPtcr:1)␤called from Sub 'foo' pc 155 ((file unknown):103) (/tmp/BRQ…

[18:16] <jnthn> r: sub foo { my $x = 5; 7; class foo { }; &foo() }; say foo

[18:16] <p6eval> rakudo 9d50d6: OUTPUT«foo()␤»

[18:16] <masak> GlitchMr: you said above that Perl 5 does.

[18:16] <GlitchMr> And no machine is Turing-complete

[18:16] <jnthn> Here', the foo you're talking about is the class foo :)

[18:16] <mst> my perl5 code has intentionally restricted recurion depth

[18:16] <jnthn> Thus the foo() :)

[18:16] <masak> <GlitchMr> Perl 5 haves infinite recursion depth (except for operator overloading which doesn't for some reason)

[18:17] <mst> since I have fatal warnins on, so the 'deep recursion' warning goes off and kills it

[18:17] <diakopter> jnthn: right, but how could &foo refer to the class

[18:17] <mst> I consider this to be a feature

[18:17] <jnthn> diakopter: You never fallced the sub

[18:17] <jnthn> *called

[18:17] <diakopter> ohh

[18:17] <masak> mst: I think I would, too.

[18:18] <GlitchMr> Also, &foo->() looks like %a->{b} for me.

[18:18] <GlitchMr> Not sure... really

[18:18] <GlitchMr> deparse: &foo->()

[18:18] <buubot_backup> GlitchMr:  &foo->();

[18:19] <GlitchMr> eval: use warnings; &foo->()

[18:19] <buubot_backup> GlitchMr: ERROR: Undefined subroutine &main::foo called at (eval 20) line 1. 

[18:19] <GlitchMr> How does that work?

[18:19] <mst> how does what work?

[18:19] <GlitchMr> &foo->()

[18:20] <GlitchMr> Let me guess, it's actually

[18:20] <GlitchMr> &foo(@_)->()

[18:20] <mst> eval: sub foo { return sub { 42 } }; &foo->();

[18:20] <buubot_backup> mst: 42

[18:20] <TimToady> diakopter: p5 uses a (reallocatable) compact array of PERL_CONTEXT structs for a call stack

[18:20] <mst> GlitchMr: ^^ same way as everything else

[18:20] <diakopter> TimToady: ah

[18:20] <GlitchMr> It looked for me like deprecated %a->{b} for some reason

[18:22] <flussence> I'm not sure /\%a->(.*)/ would make sense at all

[18:25] <diakopter> r: my $a; class foo { my class foo { }; $a = foo }; say foo eqv $a

[18:25] <p6eval> rakudo 9d50d6: OUTPUT«True␤»

[18:25] <diakopter> r: my $a; class foo { my class foo { }; $a = foo }; say foo === $a

[18:25] <p6eval> rakudo 9d50d6: OUTPUT«True␤»

[18:25] <diakopter> :S

[18:25] <diakopter> r: my $a; class foo { my class foo { }; $a = foo }; say foo ~~ $a

[18:25] <p6eval> rakudo 9d50d6: OUTPUT«False␤»

[18:26] <dalek> std: edd7715 | larry++ | STD.pm6:

[18:26] <dalek> std: $<starter> and $<stopper> under * are arrays

[18:26] <dalek> std: review: https://github.com/perl6/std/commit/edd7715275

[18:26] <masak> r: class foo {}; say foo.WHICH

[18:26] <p6eval> rakudo 9d50d6: OUTPUT«foo␤»

[18:26] <masak> r: class foo {}; say foo.WHERE

[18:26] <p6eval> rakudo 9d50d6: OUTPUT«-1124002555␤»

[18:26] <mst> GlitchMr: the other funny one is when people write $obj->method_name->();

[18:26] <mst> GlitchMr: and then get exceedingly confused

[18:26] <mst> 76

[18:27] <masak> r: class foo { my class foo {}; say foo.WHERE }; say foo.WHERE

[18:27] <p6eval> rakudo 9d50d6: OUTPUT«-1892705808␤1340315348␤»

[18:27] <jnthn> Uh. Returning the class name for .WHICH is a rather bad idea :)

[18:27] <jnthn> I think that's already RT'd though.

[18:27] <masak> jnthn: that surprised me a bit, yes.

[18:27] <jnthn> masak: me too

[18:27] <masak> jnthn: which is why === gives True above, I guess.

[18:28] <masak> and diakopter is right to ':S' about it.

[18:28] <TimToady> yes, classes are not a value type, so should return object identity

[18:28] <diakopter> r: my $a; class foo { my class foo { }; $a = foo }; say foo.WHERE, $a.WHERE

[18:28] <p6eval> rakudo 9d50d6: OUTPUT«-356640531-363419417␤»

[18:29] <jnthn> masak: Yes, it's clearly wrong.

[18:29] <jnthn> A patch would be better than a :S :)

[18:29] <diakopter> jnthn: well, I thought it was wrong for the wrong reason

[18:29] <TimToady> jnthn thinks 2 wrongs make a write :)

[18:30] <jnthn> :P

[18:31] <jnthn> TimToady: We have in STD quote_mod:sym<a>, but it doesn't parse array, the long form, which tweak also accepts. Deliberate?

[18:32] <rindolf> How do I run the specttest in parallel?

[18:32] <flussence> rindolf: "make TEST_JOBS=<n> spectest"

[18:33] <rindolf> flussence: thanks.

[18:37] *** benabik joined
[18:37] <moritz> ... as documented in rakudo's README

[18:37] <moritz> erm should be at least :/

[18:38] <moritz> hm, it's in INSTALL.txt

[18:40] *** cognominal joined
[18:42] <pmurias> jnthn: how can I determine in nqp if something is a type object?

[18:42] <TimToady> jnthn: there are two ways for quote_mods to get parsed. we only allow the short form for :qa and such, but both the short and long forms can be parsed as quotepairs in babble

[18:42] <TimToady> but the latter require the colon

[18:43] <TimToady> at that point, it's the fact that there are two different names in the tweak that allow both :a and :array

[18:43] <jnthn> pmurias: !nqp::concrete($thing)

[18:44] <jnthn> pmurias: sorry, nqp::isconcrete

[18:44] <jnthn> TimToady: I figured the quotepair form would allow both, just wanted to check about the quote_mods.

[18:47] <TimToady> yes, the long forms aren't actually parsed with <quote_mod>

[18:47] <jnthn> OK

[18:49] <pmurias> jnthn: and check for something being a SixModelObject?

[18:50] <TimToady> eventually we probably oughta unify the processing of all identifiers so that a user's 'sub qa' isn't overridden by the language's qa accidentally

[18:50] <TimToady> the quote operators are a bit too keywordy for my tastes right now

[18:50] <TimToady> that would get them out of the LTM table too

[18:51] <jnthn> arrgh...I start copying a bit of STD and you ponder changing it :P

[18:52] <TimToady> well, just the parsing of the symbol.  everything else would work the same

[18:52] <jnthn> :)

[18:52] <moritz> that's the eternal Perl 6 curse -- you implement something, and thus trigger its change

[18:52] <TimToady> the problem is that whenever you draw my attention to something, I look at it :D

[18:53] *** benabik left
[18:55] <TimToady> but I'm still in pondering mode on that; qa and friends probably need to be treated as a lexical macro provided by the setting, and then the identifier participates in normal identifier lookup, rather than being a special rule

[18:55] <TimToady> thankfully I don't know how to do that yet :)

[18:55] <jnthn> pmurias: I guess pir::typeof__SP($obj) gives back SixModelObject. There's not a convenient way 'cus generally it's a smell.

[18:56] <jnthn> TimToady: Sounds like a cure worse than the disease 

[18:56] <moritz> nqp: say(pir::typeof__SP(class A { }));

[18:56] <p6eval> nqp: OUTPUT«NQPMu␤»

[18:56] <moritz> jnthn: nope

[18:57] <jnthn> Oh. Because...we made that cheat. :/

[18:57] <jnthn> Grr.

[18:57] <jnthn> I dunno how you do it then.

[18:57] <moritz> note to self: when implement a feature, either prepare a shiny distraction for TimToady, or switch off dalek :-)

[18:57] <pmurias> using it as one and CATCH is one way

[18:58] <jnthn> pmurias: Yes, I meant a better way than that. ;)

[18:58] <TimToady> macro qa { 'q:a' } might be perfectly adequate in this case, actually

[18:59] * jnthn hopes masak++ looks forward to figuring out the circularity sawing needed to make macros work in the setting...

[18:59] <masak> :)

[19:00] <rindolf> OK, running make TEST_JOBS=4 took real 7m12.423s ; user 23m0.866s ; sys 1m39.183s - does not seem too good.

[19:00] <rindolf> What is the wallclock time?

[19:00] <masak> oh, so all of a sudden I'm the macros guy, huh? :P

[19:00] <TimToady> not so sudden as all that :P

[19:00] <jnthn> rindolf: What doesn't seem too good?

[19:00] <rindolf> jnthn: the time it takes it to run.

[19:01] <rindolf> jnthn: it's a fast machine.

[19:01] <masak> no, seriously. circularity sawing is fine. macros already straddle the compiler and the core.

[19:01] <rindolf> A Core i3 one.

[19:01] <TimToady> even our galaxy has a core...

[19:01] <jnthn> rindolf: Then help make things faster.

[19:01] <jnthn> rindolf: That's the only way things get better.

[19:02] * TimToady has memories of core memories...

[19:02] <rindolf> jnthn: OK.

[19:02] <rindolf> jnthn: didn't you say that spectest ran at 2 minutes for you?

[19:02] <jnthn> rindolf: I run it with --jobs=6 here and get through it in < 4 mins, fwiw.

[19:02] <rindolf> Or was it three minutes?

[19:02] <rindolf> jnthn: what are you machine's specs?

[19:02] <rindolf> s/you/your/

[19:02] <jnthn> It was three. Then we started passing more tests ;)

[19:03] <jnthn> rindolf: It's an i7, quad core

[19:03] <rindolf> jnthn: ah, hah.

[19:03] <rindolf> BTW, how can I get an account on feather?

[19:04] <jnthn> I think moritz++ can give those these days...

[19:04] <dalek> perl6-examples: 294bc61 | (Gerhard R)++ | euler/prob003-gerdr (2 files):

[19:04] <dalek> perl6-examples: [euler/prob003] simplify algorithm

[19:04] <dalek> perl6-examples: 

[19:04] <dalek> perl6-examples: composite numbers won't divide the reduced $n as their factors

[19:04] <dalek> perl6-examples: have already been seen and divided out

[19:04] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/294bc616f2

[19:05] <moritz> http://feather.perl6.nl/ should have a link to instructions

[19:06] <rindolf> moritz: it does not.

[19:06] <moritz> rindolf: try the "original announcement" link

[19:08] <rindolf> moritz: http://www.mail-archive.com/perl6-language@perl.org/msg20060.html - should I contact Juerd?

[19:08] <rindolf> moritz: that announcement is very old.

[19:09] <rindolf> moritz: anyway, you can send me a temp password to [email@hidden.address]
[19:09] *** SamuraiJack joined
[19:09] <moritz> rindolf: yes, email Juerd and put me CC

[19:09] <moritz> (include all the required information, as stated in the announcement)

[19:11] <rindolf> moritz: should I email #####@juerd.nl ?

[19:11] <rindolf> moritz: with the pound signs?

[19:19] <dalek> rakudo/Q: 606a81a | jnthn++ | src/Perl6/Grammar.pm:

[19:19] <dalek> rakudo/Q: Assorted fixes to babble.

[19:19] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/606a81aecc

[19:19] <dalek> rakudo/Q: fecccba | jnthn++ | src/Perl6/Grammar.pm:

[19:19] <dalek> rakudo/Q: Add quote_mod proto and candidates.

[19:19] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/fecccbad29

[19:19] <dalek> rakudo/Q: f3651e8 | jnthn++ | src/Perl6/Actions.pm:

[19:19] <dalek> rakudo/Q: Action method for quibble.

[19:19] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/f3651e8f07

[19:19] <dalek> rakudo/Q: 069784b | jnthn++ | src/Perl6/Grammar.pm:

[19:19] <dalek> rakudo/Q: Add some missing protos.

[19:19] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/069784be79

[19:20] *** SamuraiJack_ joined
[19:21] *** havenn left
[19:24] *** SamuraiJack left
[19:25] *** fgomez left
[19:25] *** domidumont left
[19:25] <rindolf> moritz: ping.

[19:27] *** fgomez joined
[19:29] *** Pleiades` left
[19:35] *** cognominal left
[19:35] *** Pleiades` joined
[19:39] <tadzik> phenny: pass me a cookie

[19:39] <phenny> tadzik: 12:46Z <moritz> ask tadzik what he thinks of the panda/custom-lib branch, and if it's mergable before the star release

[19:39] <tadzik> ohyes

[19:39] <tadzik> I'll look at it tomorrow, promise

[19:39] <tadzik> ETOOTIRED today

[19:41] <tadzik> so, what's cooking today, #perl6? :)

[19:43] *** cognominal joined
[19:44] *** SamuraiJack_ left
[19:44] *** SamuraiJack_ joined
[19:44] <dalek> rakudo/Q: 1c4a880 | jnthn++ | src/Perl6/Actions.pm:

[19:44] <dalek> rakudo/Q: Action method for new quote nibbler.

[19:44] <dalek> rakudo/Q: 

[19:44] <dalek> rakudo/Q: Seems to essentially work.

[19:44] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/1c4a8809ab

[19:44] <dalek> rakudo/Q: 768a57b | jnthn++ | src/Perl6/Grammar.pm:

[19:44] <dalek> rakudo/Q: Corrections to nibbler grammar rule.

[19:44] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/768a57b8e5

[19:44] <jnthn> tadzik: moritz++ has been cooking the setting. I'm cooking quotes. masak++ is cooking macros :)

[19:45] <jnthn> TimToady++ is cooking my brain :P

[19:45] <tadzik> so, nibbler. Can has fancy Formatting Codes quoting now, I guess

[19:45] <jnthn> tadzik: That, and heredocs, are the goal.

[19:46] <tadzik> ossum

[19:46] <mst> heredocs ftw

[19:46] <mst> I especially like <<''; for confusing people

[19:47] <gfldex> that's what perl is for after all

[19:48] <gfldex> like god placed bones in the ground to confuse the paleontologists so we place perl scripts on our harddisk to confuse generations to come

[19:49] <masak> std: my $a = q:to'';␤oh hai␤␤␤

[19:49] <p6eval> std edd7715: OUTPUT«ok 00:00 42m␤»

[19:50] <masak> mst: possibility of confusion retained in Perl 6 ;)

[19:50] <masak> std: my $a = q:to'EOT';␤oh hai␤␤

[19:50] <p6eval> std edd7715: OUTPUT«===SORRY!===␤Unrecognized quote modifier: to'EOT at /tmp/j8tcr5qqJZ line 1:␤------> my $a = q⏏:to'EOT';␤(Possible runaway string from line 1)␤Couldn't find terminator ' at /tmp/j8tcr5qqJZ line 3 (EOF):␤------> <BOL>⏏[31…

[19:51] <masak> std: my $a = q:to<EOT>;␤oh hai␤␤

[19:51] <p6eval> std edd7715: OUTPUT«===SORRY!===␤(Possible runaway string from line 2)␤Couldn't find delimiter for heredoc␤ at /tmp/Ux0ppiTNga line 3 (EOF):␤------> <BOL>⏏<EOL>␤Parse failed␤FAILED 00:00 42m␤»

[19:52] <jnthn> r: say '\a'

[19:53] <p6eval> rakudo 9d50d6: OUTPUT«\a␤»

[19:53] <masak> std: say "\a"

[19:53] <p6eval> std edd7715: OUTPUT«ok 00:00 42m␤»

[19:53] <masak> r: say "\a"

[19:53] <p6eval> rakudo 9d50d6: OUTPUT«===SORRY!===␤Unrecognized backslash sequence: '\a' at line 2, near "\""␤»

[19:54] <masak> what does STD think \a is in qq strings?

[19:55] <TimToady> n: say ord "\a"

[19:55] <p6eval> niecza v22-14-g136ddcf: OUTPUT«7␤»

[19:56] * masak submits rakudobug

[19:56] *** cognominal left
[19:56] *** colomon left
[19:56] <TimToady> p: say ord "\a"

[19:56] <p6eval> pugs: OUTPUT«7␤»

[19:57] <masak> eval: ord "\a"

[19:57] <buubot_backup> masak: 7

[19:57] <masak> :)

[19:58] *** cognominal joined
[19:59] <tadzik> flussence! flussence!

[20:00] <flussence> hai

[20:00] <tadzik> flussence, flussence 

[20:00] <tadzik> your tests not worky

[20:00] <flussence> :(

[20:00] <flussence> they did last time I tried...

[20:00] <tadzik> t/05-post-content.t ...... ===SORRY!===

[20:00] <tadzik> Variable $postdata is not declared

[20:00] *** GlitchMr left
[20:01] <flussence> oh, I'm dumb :)

[20:02] *** nlpplz left
[20:03] <flussence> ok, try now. I actually did things in the right order this time :)

[20:04] <tadzik> No such method 'decode' for invocant of type 'Any'

[20:04] <tadzik> I may have to update my rakudo

[20:05] <tadzik> that'll take a minute :)

[20:05] *** jaffa4 left
[20:06] <flussence> hm, that *should* be a Buf...

[20:09] <dalek> roast: faee08f | masak++ | S06-macros/unquoting.t:

[20:09] <dalek> roast: [S06-macros/unquoting.t] unfudged a TODO test

[20:09] <dalek> roast: 

[20:09] <dalek> roast: Now passes in Rakudo.

[20:09] <dalek> roast: review: https://github.com/perl6/roast/commit/faee08ff36

[20:09] *** MikeFair left
[20:09] *** jaldhar joined
[20:11] <rindolf> phenny: tell moritz that's OK - I found juerd's E-mail address in a an old E-mail.

[20:11] <phenny> rindolf: I'll pass that on when moritz is around.

[20:14] *** colomon joined
[20:16] *** benabik joined
[20:20] *** birdwindupbird joined
[20:30] <dalek> rakudo/Q: ddbb67f | jnthn++ | src/Perl6/ (2 files):

[20:30] <dalek> rakudo/Q: Switch basic Q quotes over to new quote handling.

[20:30] <dalek> rakudo/Q: 

[20:30] <dalek> rakudo/Q: No spectest regressions, so either things basically work or it's just

[20:30] <dalek> rakudo/Q: undertested. :)

[20:30] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/ddbb67f69a

[20:30] <dalek> rakudo/Q: 048c742 | jnthn++ | src/Perl6/Grammar.pm:

[20:30] <dalek> rakudo/Q: Factor quote language derivation out of babble.

[20:30] <dalek> rakudo/Q: 

[20:30] <dalek> rakudo/Q: Some things want to just get the language and nibble.

[20:30] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/048c742024

[20:30] <dalek> rakudo/Q: 972112f | jnthn++ | src/Perl6/Grammar.pm:

[20:30] <dalek> rakudo/Q: Remove accidentally copied multi.

[20:30] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/972112fbd6

[20:33] <masak> r: multi d() { [] }; multi d($d) { [$d] }; multi d($d1, $d2, *@a) { ([10*$d1 + $d2, .list] for d(|@a)), ([$d1, .list] for d($d2, |@a)) }; say .map((* + 96).chr).join if all(@$_) <= 26 for d(1, 2, 3, 4)

[20:33] <p6eval> rakudo 9d50d6: OUTPUT«lcd␤awd␤abcd␤»

[20:33] <masak> nicer solution to yesterday's little puzzle.

[21:00] <masak> r: multi d() { [] }; multi d($d) { [$d] }; multi d($d1, $d2, *@a) { (["$d1$d2", .list] for d(|@a)), ([$d1, .list] for d($d2, |@a)) }; say .map((* + 96).chr).join if all(@$_) <= 26 for d(1, 2, 3, 4)

[21:01] <p6eval> rakudo 9d50d6: OUTPUT«lcd␤awd␤abcd␤»

[21:01] <dalek> rakudo/Q: 93abcf3 | jnthn++ | src/Perl6/Actions.pm:

[21:01] <dalek> rakudo/Q: Actions for some of the escapes.

[21:01] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/93abcf3e07

[21:01] <dalek> rakudo/Q: bf526c2 | jnthn++ | src/Perl6/Grammar.pm:

[21:01] <dalek> rakudo/Q: Pass on orig, not target, in nibbler.

[21:01] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/bf526c2bc3

[21:01] <dalek> rakudo/Q: 467a479 | jnthn++ | src/Perl6/ (2 files):

[21:01] <dalek> rakudo/Q: Switch single quoted strings to new quote parser.

[21:01] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/467a479850

[21:02] *** SamuraiJack_ left
[21:11] *** bapa left
[21:11] *** bapa joined
[21:16] *** bapa left
[21:16] *** havenn joined
[21:19] *** bapa joined
[21:19] *** bapa left
[21:20] *** bapa joined
[21:22] *** bapa left
[21:24] *** bapa joined
[21:36] *** benabik left
[21:37] *** kaare_ left
[21:38] <masak> 'night, #perl6

[21:41] <dalek> nqp: 81cdc24 | jnthn++ | src/QRegex/Cursor.nqp:

[21:41] <dalek> nqp: Add orig method to Cursor.

[21:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/81cdc24831

[21:41] <dalek> nqp: 84a13cb | jnthn++ | src/how/NQPParametricRoleHOW.pm:

[21:41] <dalek> nqp: Fix thinko when roles did roles.

[21:41] <dalek> nqp: 

[21:41] <dalek> nqp: Seems this path never got exercised in NQP before.

[21:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/84a13cbf1c

[21:41] <dalek> nqp: c077b22 | jnthn++ | src/HLL/Grammar.pm:

[21:41] <dalek> nqp: Make LANG pass on orig, not target, plus args.

[21:41] <dalek> nqp: 

[21:41] <dalek> nqp: This may get rid of some of the oddness we've seen with strings with

[21:41] <dalek> nqp: null bytes showing up. Also means we can pass arguments on to a rule

[21:41] <dalek> nqp: in another language.

[21:41] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c077b22a24

[21:42] *** fgomez left
[21:42] *** fgomez joined
[21:49] <dalek> rakudo/Q: 75d531b | jnthn++ | src/Perl6/ (2 files):

[21:49] <dalek> rakudo/Q: Fill out action methods for remaining escapes.

[21:49] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/75d531b3c0

[21:49] <dalek> rakudo/Q: b276a81 | jnthn++ | src/Perl6/ (2 files):

[21:49] <dalek> rakudo/Q: Switch double-quoted strings to new quote parser.

[21:49] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/b276a81543

[21:59] *** birdwindupbird left
[22:01] *** MayDaniel left
[22:02] *** PacoAir left
[22:14] *** imarcusthis- left
[22:16] *** imarcusthis joined
[22:16] *** benabik joined
[22:19] *** tokuhiro_ joined
[22:36] *** rindolf left
[22:38] *** spider-mario left
[22:41] *** rindolf joined
[22:41] *** rindolf left
[22:41] <dalek> rakudo/Q: 289f960 | jnthn++ | src/Perl6/Grammar.pm:

[22:41] <dalek> rakudo/Q: Apply balanced/unbalanced after base tweak.

[22:41] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/289f960990

[22:41] <dalek> rakudo/Q: f86d5a6 | jnthn++ | src/Perl6/Grammar.pm:

[22:41] <dalek> rakudo/Q: Fix error reporting.

[22:41] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/f86d5a6602

[22:41] <dalek> rakudo/Q: 99f6013 | jnthn++ | src/Perl6/ (2 files):

[22:41] <dalek> rakudo/Q: Switch q, qq and Q:PIR to new quote parser.

[22:41] <dalek> rakudo/Q: review: https://github.com/rakudo/rakudo/commit/99f601380d

[22:43] <jnthn> Got many of the quoting constructs switched over to STD style approach now. No slowdown (thanks to caching the derived languages), and only one new test fail. And it looks like it's 'cus the test is wrong...

[22:44] <tadzik> not bad

[22:44] <tadzik> flussence: I think the test is still rong :(

[22:45] *** tokuhiro_ left
[22:46] *** havenn left
[22:48] *** havenn joined
[22:50] <jnthn> 'night, #perl6

[22:50] <diakopter> o/

[22:50] <tadzik> good knight jnthn 

[23:06] *** hash_table joined
[23:07] <sorear> o/

[23:09] *** benabik left
[23:09] <diakopter> sorear: how goes

[23:09] *** benabik joined
[23:16] <sorear> diakopter: ok

[23:20] <flussence> tadzik: I dunno, it looks right to me... am I missing something obvious?

[23:21] <flussence> or, *which* test's wrong for you?

[23:33] *** stocks joined
[23:34] * [Coke] tries to bisect his nqp build segfault

[23:35] *** pmurias left
[23:38] *** stocks left
[23:43] *** pmurias joined
[23:52] *** skids joined
[23:55] *** stocks joined
