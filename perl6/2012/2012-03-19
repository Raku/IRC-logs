[00:20] *** alester joined
[00:28] *** havenn left
[00:32] *** Vespakoen_ joined
[00:34] *** Vespakoen left
[00:35] *** localhost left
[00:35] <shinobicl___> should i redefine .WHAT for user defined classes?

[00:36] <shinobicl___> i got this message when invoking what in a class i created. : use of uninitialized variable $message of type Workdate in string context

[00:36] *** localhost joined
[00:39] <sorear> You can't redefine WHAT.

[00:42] <shinobicl___> that's what i imagined... Maybe i broke something when making the derived class.

[00:43] *** Chillance left
[00:43] <cognominal> r: so.WHAT?

[00:43] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Confused␤at /tmp/hmfk5tfs6a:1␤»

[00:44] <cognominal> :)

[00:47] *** shinobicl___ left
[00:48] *** notevent` left
[00:58] *** shinobicl___ joined
[00:58] *** Vespakoen_ left
[01:02] *** kshannon left
[01:10] *** scott_ joined
[01:10] *** alester left
[01:11] *** scott_ is now known as Guest2852

[01:18] *** s1n joined
[01:37] *** jferrero joined
[02:00] *** shinobicl___ left
[02:00] *** shinobicl___ joined
[02:03] *** flussence left
[02:03] *** whiteknight left
[02:04] <shinobicl___> i have a problem with one overloaded operator. i think that the fact that calling WHAT on my custom class reports an error, is the symptom of a deeper problem

[02:08] *** swarley joined
[02:17] *** flussence joined
[02:27] *** flussence left
[02:42] *** benabik joined
[02:46] *** libertyprime left
[02:49] *** libertyprime joined
[02:52] *** swarley left
[02:54] *** envi_ joined
[02:54] *** wolfman2000 joined
[02:56] *** flussence joined
[02:58] *** libertyprime left
[03:11] *** cbk1090 left
[03:13] *** awwaiid left
[03:33] *** abercrombie joined
[03:34] *** odoacre joined
[03:58] *** orafu left
[04:00] *** orafu joined
[04:24] *** FACEFOX left
[04:34] *** am0c joined
[04:38] *** pernatiy left
[04:44] *** dwierenga joined
[05:02] <dalek> specs: 7812d5d | larry++ | S04-control.pod:

[05:02] <dalek> specs: small typo

[05:02] <dalek> specs: review: https://github.com/perl6/specs/commit/7812d5d32d

[05:06] *** cj left
[05:13] *** cj joined
[05:18] *** kaleem joined
[05:22] *** maxiozzi left
[05:27] *** flussence left
[05:28] *** birdwindupbird joined
[06:14] *** NamelessTee joined
[06:32] <moritz> shinobicl___: what you described earlier is a warning, not an error

[06:32] <moritz> shinobicl___: and it's expected that you get a warning when you use .WHAT inside a string. If you want to print the type object, do something like $obj.WHAT.gist or $obj.^name

[07:01] *** wtw joined
[07:04] <masak> morning, #perl6.

[07:06] <masak> http://lists.parrot.org/pipermail/parrot-dev/2012-March/006713.html looks like a "traditional p6l email" that somehow ended up on parrot-dev.

[07:06] <tadzik> good morning #perl6

[07:07] <moritz> good am, *

[07:07] <masak> poranek, tadzik.

[07:07] <moritz> masak: I jsut read it, and thought the same

[07:07] <masak> moritz: never mind that the poster forgot the actual name of junctions, or doesn't actually know what constructs we have in place for immutability.

[07:08] <masak> or thinks that &map will hyper when given the chance.

[07:08] <sorear> o/ masak, tadzik 

[07:09] <masak> moritz: do you want to craft a reply, or should I?

[07:10] <sorear> 1. yay, another persion who doesn't understand the difference between P and R

[07:10] *** mdupont left
[07:10] <sorear> 2. I unsubscribed to parrot-dev after travis-ci caused a 100x increase in traffic.  has that been fixed yet?

[07:11] <masak> think so.

[07:11] <sorear> #parrot has told me I'm a jerk for being bothered by this

[07:11] <masak> I still see travis emails sometimes, but they're much less obnoxious.

[07:11] <masak> sorear: they ended up complaining themselves on the list.

[07:15] *** tarch joined
[07:18] <masak> sorear: fwiw, they told you that unsubscribing was "pretty curmudgeonly". that's two steps away from telling you you're a jerk...

[07:27] <sorear> Only two.

[07:27] <sorear> I really don't like being told that travis spamming the list is my problem.

[07:28] <moritz> masak: I don't really think it deserves a reply

[07:30] <sorear> I'll stop this, I don't think I'm being productive

[08:04] <masak> sorry if I made it worse. I agree that the travis emails didn't fill any useful purpose at all.

[08:09] <masak> by the way, I've stopped thinking of junctions as a threading primitive. most of the situations I use them in are for making code look simpler, nothing more.

[08:29] *** mj41_nb joined
[08:29] <masak> that doesn't mean that they'll never *be* a threading primitive, of course. but I don't think they will be, or if they are, that it won't do much difference.

[08:32] <moritz> agreed

[08:32] <moritz> it's not a basic building block for building concurrent applications

[08:32] <moritz> just some parallel sugar

[08:33] <moritz> perl6: 'ab' ~~ /a/|/b/; say ~$/

[08:33] <p6eval> pugs b927740: OUTPUT«sh: /home/p6eval/Pugs.hs/Pugs: Permission denied␤»

[08:33] <p6eval> ..rakudo 1968b8: OUTPUT«use of uninitialized value of type Any in string context␤␤»

[08:33] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/nFMb98uKiQ line 1 (mainline @ 3…

[08:34] *** kmp left
[08:39] *** slavik1 left
[08:41] <masak> and the "parallel" part of "parallel sugar" is really the smallest part of it.

[08:42] <masak> it's the Huffman effect that I'm after most of the time. part "forget about sequencing, I'm not using it", part "make the same comparison (against the same variable or whatever) for all these values".

[08:43] <masak> it's *completely* right that this variant be spelled '|' rather than '||'.

[08:44] <dalek> evalbot: 22a3f60 | moritz++ | evalbot.pl:

[08:44] <dalek> evalbot: fix pugs path, hopefull

[08:44] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/22a3f60f9a

[08:44] <dalek> evalbot: dff5c8f | moritz++ | evalbot.pl:

[08:44] <dalek> evalbot: install p6 alias for perl6

[08:44] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/dff5c8f589

[08:44] *** shinobicl___ left
[08:45] <moritz> evalbot control restart

[08:45] *** p6eval left
[08:46] *** p6eval joined
[08:46] *** ChanServ sets mode: +v p6eval

[08:46] <moritz> r: say 'this is going to take a while'

[08:46] <moritz> I have no idea why, but the first execution after a restart always takes ages

[08:47] <p6eval> rakudo 1968b8: OUTPUT«this is going to take a while␤»

[08:47] <moritz> p6: say 'new alias'

[08:47] <p6eval> pugs, rakudo 1968b8, niecza v15-4-g1f35f89: OUTPUT«new alias␤»

[08:47] <masak> woot.

[08:52] <moritz> Juerd: ping

[08:52] <moritz> Juerd: the machine on which p6eval runs now is going to be discontinued, so I'd like to move p6eval to feather3, but currently it doesn't have enough memory to handle that load

[08:53] <moritz> Juerd: is there some memory available than can be redistributed?

[08:53] *** y3llow left
[08:56] *** y3llow joined
[08:58] *** y3llow left
[08:59] *** y3llow joined
[09:01] *** y3llow left
[09:01] *** y3llow joined
[09:07] *** perlish joined
[09:10] *** Chillance joined
[09:12] *** Bzek joined
[09:26] *** rsimoes left
[09:26] *** Bzek left
[09:27] *** rsimoes joined
[09:34] *** dakkar joined
[09:40] *** ab5tract joined
[09:55] *** fglock joined
[10:01] *** perlish left
[10:02] *** Guest2852 left
[10:10] <masak> p6: say 10 ** 10

[10:10] <p6eval> pugs, rakudo 1968b8, niecza v15-4-g1f35f89: OUTPUT«10000000000␤»

[10:11] <masak> p6: say (10 ** 10).flip.comb(/..?.?/).join('_').flip

[10:11] <p6eval> rakudo 1968b8, niecza v15-4-g1f35f89: OUTPUT«10_000_000_000␤»

[10:11] <p6eval> ..pugs: OUTPUT«*** No such method in class Rat: "&flip"␤    at /tmp/nDY3goR_Tg line 1, column 5 - line 2, column 1␤»

[10:13] *** kaleem left
[10:13] *** kaleem joined
[10:14] <masak> r: use MONKEY_TYPING; augment class Cool { multi method comb(Int $n) { my $regex = '.' ~ '.?' xx ($n - 1); nextwith(eval "/$regex/") } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:14] <p6eval> rakudo 1968b8: OUTPUT«Cannot call 'comb'; none of these signatures match:␤:(Str:D , Mu %_!)␤:(Str:D , Regex $pat, Any $limit = { ... }, Any :match(:$match), Mu %_!)␤:(Cool , Mu %_!)␤:(Cool , Regex $matcher, Any $limit = { ... }, Mu %_!)␤␤  in method comb at src/gen/CORE.setting:1878␤  i…

[10:15] <masak> r: use MONKEY_TYPING; augment class Cool { multi method comb(Int $n) { my $regex = '.' ~ '.?' xx ($n - 1); nextwith(self, eval "/$regex/") } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:15] <p6eval> rakudo 1968b8: OUTPUT«Cannot call 'comb'; none of these signatures match:␤:(Str:D , Mu %_!)␤:(Str:D , Regex $pat, Any $limit = { ... }, Any :match(:$match), Mu %_!)␤:(Cool , Mu %_!)␤:(Cool , Regex $matcher, Any $limit = { ... }, Mu %_!)␤␤  in method comb at src/gen/CORE.setting:1878␤  i…

[10:15] <masak> hm. :/

[10:16] <masak> r: use MONKEY_TYPING; augment class Cool { multi method comb(Int $n) { my $regex = '.' ~ '.?' xx ($n - 1); die (eval "/$regex/").WHAT } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:16] <p6eval> rakudo 1968b8: OUTPUT«Cannot call 'comb'; none of these signatures match:␤:(Str:D , Mu %_!)␤:(Str:D , Regex $pat, Any $limit = { ... }, Any :match(:$match), Mu %_!)␤:(Cool , Mu %_!)␤:(Cool , Regex $matcher, Any $limit = { ... }, Mu %_!)␤␤  in method comb at src/gen/CORE.setting:1878␤  i…

[10:16] <masak> oh, it's the .comb(3) that doesn't dispatch.

[10:18] <masak> why not?

[10:21] <colomon> Str, Mu versus Cool, Int?

[10:21] <masak> r: use MONKEY_TYPING; augment class Str { multi method comb(Int $n) { my $regex = '.' ~ '.?' xx ($n - 1); die (eval "/$regex/").WHAT } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:21] <p6eval> rakudo 1968b8: OUTPUT«use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Regex in string context␤use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Regex in string context␤␤  in method comb at /tmp…

[10:21] <masak> that seemed to be it. colomon++

[10:22] <colomon> 'morning.  :)

[10:22] * masak tips hat

[10:23] <masak> r: use MONKEY_TYPING; augment class Str { multi method comb(Int $n) { die $n } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:23] <p6eval> rakudo 1968b8: OUTPUT«3␤  in method comb at /tmp/gvNGpCXsG_:1␤  in block <anon> at /tmp/gvNGpCXsG_:1␤␤»

[10:24] <masak> r: use MONKEY_TYPING; augment class Str { multi method comb(Int $n) { nextsame(eval "/{'.' ~ '.?' xx ($n - 1)}/") } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:24] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Can not get non-existent attribute '$!dispatchees' on class 'Routine'␤»

[10:24] <masak> um.

[10:24] *** grondilu joined
[10:25] <masak> r: use MONKEY_TYPING; augment class Str { multi method comb(Int $n) { nextwith(eval "/{'.' ~ '.?' xx ($n - 1)}/") } }; say (10 ** 10).flip.comb(3).join('_').flip

[10:25] <p6eval> rakudo 1968b8: OUTPUT«␤»

[10:25] <grondilu> perl6: say join ':', $_ for [\,] 1, 2, 3

[10:25] <p6eval> rakudo 1968b8, niecza v15-4-g1f35f89: OUTPUT«1␤1␤2␤1␤2␤3␤»

[10:25] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&prefix:[\\,]"␤    at /tmp/YvJAmDYwgn line 1, column 22 - line 2, column 1␤»

[10:26] * grondilu was expecting 1n1:2n1:2:3n

[10:26] <masak> why?

[10:27] *** flussence joined
[10:27] <grondilu> I guess I don't understand the triangular operator well.

[10:27] <masak> Perl has a long tradition of flattening. that's what you're seeing here too.

[10:28] <masak> r: .say for [\R,] "and a partridge in a pear tree", "two turtle doves"

[10:28] <p6eval> rakudo 1968b8: OUTPUT«and a partridge in a pear tree␤two turtle doves␤and a partridge in a pear tree␤»

[10:28] <masak> \o/

[10:28] <grondilu> Ok but what if I really want a list of lists?  I tried "LoL" with no success.

[10:29] <masak> LoL is only partially implemented, if that.

[10:30] <masak> you're experiencing the effects of living in an imperfect reflection of the perfect future.

[10:30] <grondilu> ok.  I'll wait then.

[10:36] <masak> r: my $s = ''; for 1, 2, 3 { if $s { $s ~= ':' }; $s ~= $_ }; say $s

[10:36] <p6eval> rakudo 1968b8: OUTPUT«1:2:3␤»

[10:38] <masak> r: my @a; for 1, 2, 3 { push @a, $_; say @a.join(':') }

[10:38] <p6eval> rakudo 1968b8: OUTPUT«1␤1:2␤1:2:3␤»

[10:38] <masak> grondilu: workaround ;)

[10:39] <moritz> r: say join ":", @$_ for [\,] 1, 2, 3

[10:39] <p6eval> rakudo 1968b8: OUTPUT«1␤1␤2␤1␤2␤3␤»

[10:39] <masak> moritz: it's deeper than that.

[10:39] <moritz> r: say join ":", @$_ for ([\,] 1, 2, 3).tree

[10:39] <p6eval> rakudo 1968b8: OUTPUT«1␤1:2␤1:2:3␤»

[10:39] <masak> woo

[10:39] <masak> moritz++

[10:39] <moritz> problem was that 'for' flattens

[10:41] <masak> right.

[10:42] *** fsergot left
[10:46] <grondilu> well done, moritz++

[10:51] *** kaleem left
[10:52] *** kaleem joined
[10:59] *** grondilu left
[11:07] *** daxim joined
[11:24] * moritz has a new hobby: answering homework questions on perlmonks with Perl 6 :-)

[11:24] *** xinming left
[11:24] *** att joined
[11:24] <arnsholt_> Teehee

[11:24] <arnsholt_> Educated trolling ;)

[11:25] <moritz> for example http://www.perlmonks.org/?node_id=959903

[11:25] <moritz> and hey, it prompted somebody to actually run my example code!

[11:29] <masak> moritz: why have you pondered that SVG.pm should handle the 'style' attribute specially?

[11:30] <moritz> masak: because its insides have quite a specific structure

[11:30] <moritz> masak: which could well be expressed as an array of pairs, just like the SVG stuff

[11:30] <moritz> masak: and because it's quite common

[11:30] <masak> I... I think I agree.

[11:31] <masak> but I'd rather see a whole different approach to it all than my poor ol' XML::Writer :)

[11:31] <masak> I will ponder this over lunch.

[11:40] *** sftp left
[11:41] *** xinming joined
[11:45] *** snearch joined
[11:49] <gfldex> svg is using CSS (of sort) and the latter is moving slowly into the direction of a script language proper

[11:50] <gfldex> in the long run a list of pairs wont cut it

[11:50] *** sftp joined
[11:51] *** mucker joined
[12:04] *** skids left
[12:17] *** tarch left
[12:25] *** am0c left
[12:27] *** att is now known as att_

[12:37] *** alvis left
[12:39] *** mtk joined
[12:43] *** sporous left
[12:43] *** sporous joined
[12:50] *** alvis joined
[12:57] *** alvis left
[12:58] <masak> having thought about it some, I realize I would probably want to template my XML.

[12:58] <masak> expressing all the XML throught arrays and hashes just isn't worth it.

[12:59] <masak> however, the two killer features that would make me use this system and nothing else would be:

[13:00] <bonsaikitten> sorear: so, niecza-bin packaged easily, is there a nice tarball for niecza source?

[13:00] <moritz> bonsaikitten: it's on github in the download section, iirc

[13:00] <bonsaikitten> moritz: only the precompiled

[13:00] <masak> (1) compile-time correctness checking of the XML template, ranging from just XML correctness to schema compatibility. sufficiently sensible behavior around XML template placeholders.

[13:01] <moritz> bonsaikitten: oh, right. But you can get tarballs from github too

[13:01] *** jerome_ left
[13:02] <moritz> there's a "ZIP" button left of the field with the git URLs

[13:02] <masak> (2) the ability to fill placeholders with arbitrary objects, as long as they do some role, say, XML::Str-able

[13:02] *** sisar joined
[13:02] <bonsaikitten> right, let's see if I can figure that one out

[13:05] <masak> interestingly, this pie-in-the-sky dream looks very much like the pie-in-the-sky dream for embedding SQL queries in code.

[13:18] *** jerome_ joined
[13:19] *** awwaiid joined
[13:19] <masak> essentially, a macro could be made to handle the compile-time aspect of (1).

[13:20] <masak> this again gives an indication of the desirability to be able to introspect literal arguments at compile-time, by the way.

[13:27] <bonsaikitten> guh, .net wasn't meant to be run in a managed environment :)

[13:31] <sisar> try.rakudo.org is down ?

[13:31] <moritz> it usually is :(

[13:33] <masak> where is it hosted?

[13:33] <moritz> feather2

[13:33] <flussence> 3

[13:33] <moritz> erm, right

[13:34] <flussence> and yeah, "down" seems to be its normal state :(

[13:34] <moritz> feather2 only has perl6.org and hugme 

[13:34] <flussence> (and I think it's still running pre-nom...)

[13:34] * flussence does some percussive maintenance

[13:35] <flussence> oh, the dns isn't there :/

[13:35] <moritz> 193.200.132.142

[13:36] <bonsaikitten> cp boot/obj/Kernel.dll run/

[13:36] <bonsaikitten> cp: cannot stat `boot/obj/Kernel.dll': No such file or directory

[13:36] <bonsaikitten> heh, nice makefile confusion :)

[13:37] <moritz> are you trying parallel make?

[13:37] <flussence> (ok, not pre-nom so it's not *terrible*...)

[13:37] <bonsaikitten> moritz: augh.

[13:37] <moritz> but pre-bs I think

[13:37] <moritz> bonsaikitten: that doesn't work on the first build

[13:37] <bonsaikitten> moritz: yes, trying ;) let's see if tuning that down helps

[13:38] <moritz> bonsaikitten: once it got the bootstrap thingy downloaded and unpacked, paralell make works again

[13:38] *** skids joined
[13:38] <bonsaikitten> moritz: there will always be only one build in this case (distro packaging)

[13:38] <moritz> so, don't go parallel for now :/

[13:38] <flussence> moritz: I'm wondering whether it'd be worth ripping out the POE persistent TTY thing now that rakudo doesn't take forever and a half to start up. If there's no processes running in the background, they can't get stuck all the time :)

[13:38] <moritz> bonsaikitten: what distro are you packaging for?

[13:38] <bonsaikitten> gentoo

[13:39] <masak> r: my $t = now; my @a; @a[ $_ ] = $_ for 1 .. 1e4; print now - $t

[13:39] <p6eval> rakudo 1968b8: OUTPUT«2.55866416794898»

[13:39] <bonsaikitten> rakudo is getting boring ;) so I'm playing around with niecza

[13:39] <masak> r: my $t = now; my %h; %h{ $_ } = $_ for 1 .. 1e4; print now - $t

[13:39] <p6eval> rakudo 1968b8: OUTPUT«1.51738952909994»

[13:39] <flussence> bonsaikitten: I've had problems with niecza and -j too, it used to work a few months ago IIRC

[13:39] <masak> in Rakudo, hashes are faster than arrays :)

[13:39] <bonsaikitten> flussence: oh well, three extra characters

[13:39] <masak> in re http://perlmonks.org/?node_id=960334

[13:39] <moritz> flussence: well, you still have to persist the REPL session between several requestis

[13:39] <moritz> *requests

[13:40] <moritz> bonsaikitten: too boring because it's so little trouble? :-)

[13:40] <moritz> masak: yes, it pays the price of lazyness

[13:40] <moritz> (it = Arrays)

[13:40] <bonsaikitten> moritz: well, apart from pcre being a bit silly ... and tests in 2012.02 have a few issues I need to track down and file bugs for

[13:42] <masak> moritz: even when, as here, I'm not using that laziness at all.

[13:42] <moritz> masak: correct

[13:42] <masak> what is the additional cost here, more exactly?

[13:43] <moritz> well, for each array access we need to check if the number of reified elements is big enough

[13:43] <moritz> though that should be rather cheap-ish

[13:43] <moritz> I kind think we're doing something very wrong when it comes to arrays and lists

[13:44] <moritz> nom: my @a = 1, 2, 3; say @a.DUMP

[13:44] <p6eval> rakudo 1968b8: OUTPUT«Array<-4100004978996074906>(:items(Mu), :nextiter(ListIter<-4100004978996073111>(:reified(▶Mu), :rest(RPA<-4100004978996040334>(Array<-4100004978996076959>(:items(RPA<-4100004978996035975>(▶1, ▶2, ▶3)), :nextiter(▶Mu)))), :list(Array<-4100004978996074906>))))␤»…

[13:44] <moritz> there you see what's wrong

[13:44] <moritz> it's not the outer-most array that holds all the reified elements

[13:44] <masak> right.

[13:45] <moritz> they are stored in two layers of nextiter

[13:45] <masak> I almost feel tempted to submit a rakudobug about that.

[13:45] <moritz> please do

[13:45] * masak submits rakudobug

[13:45] <bonsaikitten> ok, bad idea: cp /opt/niecza/run/Kernel.dll boot/obj/ <-- this doesn't fix things *g*

[13:46] <moritz> bonsaikitten: does a simple 'make -j1' not succeed?

[13:48] *** [particle] joined
[13:56] *** [particle] left
[13:58] *** [particle] joined
[14:01] *** leprevost joined
[14:02] <bonsaikitten> moritz: nyet

[14:02] <moritz> bonsaikitten: then open an issue in the github issue tracker

[14:02] <bonsaikitten> moritz: it's not finding the Kernel.dll ... I'll see if I can narrow it down to a proper bugreport

[14:03] <bonsaikitten> at the moment it might just be User Error :)

[14:03] <moritz> did you do anything more fancy than unpacking the archive, cd'ing into it and typing 'make'?

[14:04] <moritz> ah, I too get an error if I remove the boot/ dir

[14:04] <moritz> make: *** No rule to make target `boot/obj/Run.CORE.ser', needed by `boot/obj/Run.CClass.ser'.  Stop.

[14:05] <bonsaikitten> yeah, so I cp the precompiled bits in

[14:05] <mucker> Hi guys ... just a doubt. Is something like Devel::Declare(dispatch on a keyword) possible now in rakduo ?

[14:06] <bonsaikitten> then it fails to find the Kernel.dll even with a simple make

[14:06] *** shinobicl__ joined
[14:06] <moritz> mucker: we now have basic support for macros

[14:06] <moritz> though not with 'is parsed'

[14:06] <moritz> and I think you can declare custom terms and operators

[14:07] <moritz> r: sub term:sym<foo>() { 'really foo' }; say foo

[14:07] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Cannot add tokens of category 'term' with a sub␤»

[14:07] <moritz> why ever not? :/

[14:07] <mucker> ok ... i know about the macros. masak++ for that :)

[14:08] <mucker> what is a term ?

[14:08] <moritz> things that aren't operators or delimiters

[14:08] <moritz> like, numbers or strings, function calls, variables, ...

[14:09] <mucker> you can overload that ? neat !

[14:09] * mucker digs up the perl6 cabal

[14:10] <moritz> well, I dearly hope so

[14:10] <moritz> a simple (yet limited) form to do that is to declare a constant

[14:10] <moritz> r: constant foo = 'my string'; say foo

[14:10] <p6eval> rakudo 1968b8: OUTPUT«my string␤»

[14:10] <moritz> that adds foo to the term category

[14:12] <moritz> rakudo: my @a = 1, 2; @a[3] = 4; say @a.DUMP

[14:12] <p6eval> rakudo 1968b8: OUTPUT«Array<-8937442109488417235>(:items(RPA<-8937442109493102304>(▶1, ▶2, (null), ▶4)), :nextiter(▶Mu))␤»

[14:13] *** sdo joined
[14:14] <pmichaud> good morning, #perl6

[14:14] <masak> pmichaud! \o/

[14:14] <pmichaud> bug #111848 is interesting.  :-)

[14:14] <moritz> good am, pm

[14:14] <sdo> hello

[14:14] <shinobicl__> nom: use Test; my Int $i = 1; say $i.WHAT; diag $i.WHAT;

[14:14] <p6eval> rakudo 1968b8: OUTPUT«Int()␤use of uninitialized variable $message of type Int in string context␤# ␤»

[14:15] <PerlJam> pmichaud: greetings!  Good to see you on IRC :)

[14:15] <fglock> pmichaud: o/

[14:15] <shinobicl__> now i see what you meant, masak.... about using WHAT in a string

[14:15] *** sftp_ joined
[14:15] <moritz> shinobicl__: you need .gist or .^name for that

[14:16] <masak> pmichaud: I submitted it, but I'm not at all sure the criticism is relevant, because I don't know enough about the list model.

[14:16] *** sftp left
[14:16] <masak> pmichaud: though I do think it's rather insane that arrays are slower than hashes in that benchmark.

[14:16] <moritz> well, I see no pragmatic reason to nest it all that deep, and performance is a good reason against it

[14:16] <pmichaud> I'm curious if there's a similar discrepancy in p5, though :)

[14:16] <moritz> in p5, arrays are faster than hashes

[14:16] <masak> I can guarantee you that arrays are faster in p5.

[14:16] <pmichaud> the "nesting" is an artifact of laziness.  I haven't found a way around it.

[14:17] <moritz> but why two levels deep?

[14:17] <masak> the data indicates that in the short term, we'd be better off using hashes as underlying storage for arrays.

[14:17] <masak> which is just... wrong.

[14:17] <pmichaud> masak: well, yes, if everything is eager then it can be faster.

[14:18] <pmichaud> (much faster)

[14:18] <moritz> but list assignment *is* eager (unless the RHS is potentially infinite), no?

[14:18] <masak> I was doing item assignment.

[14:18] <pmichaud> yes, the benchmark is on item assignment.

[14:18] <masak> where the term *eager* doesn't really apply.

[14:19] <moritz> though the example where I .DUMP'ed it was list assignment

[14:19] <moritz> r: my @a = 1, 2, 3; say @a.DUMP

[14:19] <p6eval> rakudo 1968b8: OUTPUT«Array<-8535248794724126791>(:items(Mu), :nextiter(ListIter<-8535248794732518218>(:reified(▶Mu), :rest(RPA<-8535248794732485459>(Array<-8535248794724132930>(:items(RPA<-8535248794724091994>(▶1, ▶2, ▶3)), :nextiter(▶Mu)))), :list(Array<-8535248794724126791>))))␤»…

[14:19] <moritz> even if it is lazy, I see reason for only one level of nesting

[14:20] <pmichaud> moritz: I agree with you that something looks wrongish there.

[14:20] * moritz must leave now

[14:20] <pmichaud> like, wrongish enough that I'm motivated to open up the code again and see what's going on :)

[14:20] <masak> yay

[14:21] <pmichaud> I'm curious if it's always been this way though (in nom)

[14:21] <pmichaud> the above doesn't jibe well with what I remember of the code, so I'm wondering if a change somewhere else has introduced this behavior

[14:22] <pmichaud> r: my @a;  @a[0] = 1;  @a[1] = 2;  @a[2] = 3;  say @a.DUMP;   # just curious

[14:22] <p6eval> rakudo 1968b8: OUTPUT«Array<5730301629138936667>(:items(RPA<5730301629130058586>(▶1, ▶2, ▶3)), :nextiter(▶Mu))␤»

[14:22] <pmichaud> yes, that's more like what I would expect.

[14:22] * colomon just glanced at his IRC client to discover pmichaud++ is here!

[14:22] <pmichaud> I'm thinking something has going wonky with list assignment.

[14:23] <pmichaud> s/going/gone/

[14:23] <pmichaud> anyway, I don't think the double-nesting is the source of the speed delay noted by masak++, since that's an item assignment issue.

[14:24] <pmichaud> r: my $t = now;  my @a = 0 .. 1e4; print now - $t;

[14:24] <p6eval> rakudo 1968b8: OUTPUT«0.966963239242268»

[14:25] <pmichaud> r: my $t = now;  my %h; %h{ $_ } = $_ for 1 .. 1e4;  print now - $t;

[14:25] <p6eval> rakudo 1968b8: OUTPUT«1.42148155308195»

[14:25] <pmichaud> it's also not true that "hashes are faster than arrays"  :-)

[14:25] <pmichaud> at least, not as written there.  :-)

[14:26] *** mucker left
[14:26] <masak> the above comparse one list assignment to an array against 1e4 item assignments to a hash.

[14:26] <masak> compares*

[14:27] *** shinobicl joined
[14:27] <pmichaud> well, for item assignment hashes currently have a few advantages.

[14:28] <pmichaud> e.g., we don't have to do checks for "infinite hashes"

[14:28] <pmichaud> there also aren't exceptions tested for or generated for "invalid keys"

[14:29] <pmichaud> r:  my %h;  %h{-1} = -1;   say %h.perl; 

[14:29] <p6eval> rakudo 1968b8: OUTPUT«("-1" => -1).hash␤»

[14:29] <pmichaud> r:  my @a;  @a[-1] = -1;  say @a.perl;

[14:29] <p6eval> rakudo 1968b8: OUTPUT«Cannot use negative index -1 on Array␤  in method <anon> at src/gen/CORE.setting:8083␤  in <anon> at src/gen/Metamodel.pm:2250␤  in any find_method_fallback at src/gen/Metamodel.pm:2248␤  in any find_method at src/gen/Metamodel.pm:822␤  in block <anon> at /tmp/tRrA…

[14:30] *** shinobicl__ left
[14:30] <masak> nod.

[14:30] <pmichaud> r:  my @a; @a[$_] = $_ for 1 .. 10;  print @a.DUMP;

[14:30] <p6eval> rakudo 1968b8: OUTPUT«Array<7462650248283522845>(:items(RPA<7462650248282058266>((null), ▶1, ▶2, ▶3, ▶4, ▶5, ▶6, ▶7, ▶8, ▶9, ▶10)), :nextiter(▶Mu))»

[14:31] <pmichaud> hmmm.  clearly the code has changed a fair bit since I wrote it, since we now have :$BIND!  arguments.

[14:33] <ggoebel> masak: regarding embedding SQL in code... I assume you are familiar with LINQ? That is microsoft's answer to that question http://en.wikipedia.org/wiki/Language_Integrated_Query

[14:34] <pmichaud> I suspect the main difference in the code has to be the use of    self.exists($pos)  in Array.at_pos  versus   nqp::existskey(...)  in Hash.at_key

[14:34] <pmichaud> self.exists($pos)  is likely to be far more expensive.

[14:34] <flussence> ggoebel: we were talking about this a few days/weeks ago... someone suggested we can do most of the fancy DBIx-style stuff with the syntax we already have :)

[14:35] <pmichaud> it might be worth rewriting Array.at_pos to avoid the self.exists()

[14:35] <pmichaud> (i.e., to use an nqp::builtin directly somehow)

[14:36] <pmichaud> colomon: o/

[14:36] <colomon> \o

[14:37] <sjn> pmichaud: hotel arrangements for your trip to the hackathon in Oslo have now been done. :)

[14:37] <pmichaud> anyway, I have to head off to run some errands; I'll take a look at the Array issue a bit more later.  Also I'll look into moritz's double-level array bit; I agree that looks really wonky.

[14:37] <pmichaud> sjn:  \o/

[14:37] <tadzik> pmichaud: hello!

[14:37] <pmichaud> I'm very much looking forward to being there

[14:37] <sjn> pmichaud: hope you're fine with the same hotel as last time (they've refurbished since then, so it's a bit nicer now)

[14:37] <tadzik> double-level arrays, almost like the double bacon bug

[14:37] *** PacoAir joined
[14:38] <pmichaud> sjn: it was fine the last time (quite nice, actually)

[14:38] <bonsaikitten> https://github.com/sorear/niecza/issues/110 let's see how many people yell at me for doing it wrong ;)

[14:38] <pmichaud> sjn:  so yes, same hotel is very acceptable :)

[14:38] <sjn> awesome \o/

[14:39] <pmichaud> okay, I must go or I shall be late for my appointments.  bbl

[14:39] <pmichaud> (tadzik:  hello :-)

[14:39] <masak> ggoebel: I am (somewhat) familiar with LINQ, and I did think about LINQ when I wrote the comment about SQL.

[14:43] *** slavik1 joined
[14:43] <colomon> Ack.  Just wrote a very simple p6 script for $work.  It goes completely wrong instantly in niecza, and blows up with a random error after 4 minutes in rakudo.  :(

[14:44] <masak> :(

[14:44] * masak hopes both those behaviors can be turned into nicely golf'd bug reports

[14:46] <colomon> https://gist.github.com/2114864

[14:46] <colomon> On the principle of "Ask other people if you are doing something stupid you don't see".

[14:47] <tadzik> colomon: .= I guess

[14:47] <tadzik> that looks like a Perl5ism

[14:47] <colomon> Script is supposed to go through a text file, which contains multiple large sections each labelled "Brep Start", and finally just print out the last one.

[14:47] <colomon> tadzik: ooo, good call!

[14:47] <masak> colomon: $brep .= $_;

[14:48] <masak> colomon: method call?

[14:48] *** ApHeX3211 left
[14:48] <masak> I'm surprised that compiles.

[14:48] <colomon> nope, p5ism

[14:48] <colomon> it compiles on both compilers!!!

[14:48] <geekosaur> oosp

[14:48] <masak> std: my $brep; $brep .= $_;

[14:48] <geekosaur> "oops" even.

[14:48] <p6eval> std 1ad3292: OUTPUT«Potential difficulties:␤  Unsupported use of .= as append operator; in Perl 6 please use ~= at /tmp/XDvFIK591_ line 1:␤------> [32mmy $brep; $brep .=[33m⏏[31m $_;[0m␤ok 00:01 110m␤»

[14:49] <colomon> and (as I said) it ran for 4 minutes on rakudo, going through a text file which looks nothing at all like a series of p6 methods.

[14:49] * masak ponders whether "oosp" can be considered a very short autopun

[14:49] <masak> colomon: what a wonderful way to crash Rakudo, though.

[14:49] <colomon> niecza: my $brep; $brep .= $_;

[14:49] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at /home/p6eval/niecza/src/STD.pm6 line 3853 (ANON @ 1) ␤  at /home/p6…

[14:49] <masak> colomon++

[14:50] <colomon> yup, that's the error I was getting locally on niecza.  LTA and then some.

[14:50] <colomon> niecza: my $brep = ""; $brep .= "1 Regions In Brep"

[14:50] <p6eval> niecza v15-4-g1f35f89: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of . to concatenate strings or to call a quoted method; in Perl 6 please use ~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses at /tmp/SYkG47nkbO line 1 (EOF):␤-…

[14:51] <colomon> well, that's a fine error

[14:51] <colomon> r: my $brep = ""; $brep .= "1 Regions In Brep"

[14:51] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Quoted method name requires parenthesized arguments at line 1, near ""␤»

[14:51] <colomon> as is that.

[14:53] <gfldex> does $_ got a type?

[14:53] <colomon> n: my $brep = ""; $brep .= "1.0000000000000000 0.0000000000000000 0.0000000000000000 - Color"

[14:53] <p6eval> niecza v15-4-g1f35f89: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of . to concatenate strings or to call a quoted method; in Perl 6 please use ~ to concatenate, or if you meant to call a quoted method, please supply the required parentheses at /tmp/t58juqOhgY line 1 (EOF):␤-…

[14:54] <colomon> n: my $brep = ""; for "1.0000000000000000 0.0000000000000000 0.0000000000000000 - Color\n".lines { $brep .= $_ }

[14:54] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at /home/p6eval/niecza/src/STD.pm6 line 3853 (ANON @ 1) ␤  at /home/p6…

[14:54] <colomon> there we are

[14:54] <colomon> r: my $brep = ""; for "1.0000000000000000 0.0000000000000000 0.0000000000000000 - Color\n".lines { $brep .= $_ }

[14:54] <p6eval> rakudo 1968b8: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Str'␤  in <anon> at src/gen/BOOTSTRAP.pm:812␤  in any <anon> at src/gen/BOOTSTRAP.pm:808␤  in method dispatch:<var> at src/gen/CORE.setting:762␤  in method dispatch:<.=> at src/gen/CORE.setting:787␤  in …

[14:54] <colomon> and there we are!

[14:54] <colomon> r: my $brep = ""; for "1.0\n".lines { $brep .= $_ }

[14:54] <p6eval> rakudo 1968b8: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Str'␤  in <anon> at src/gen/BOOTSTRAP.pm:812␤  in any <anon> at src/gen/BOOTSTRAP.pm:808␤  in method dispatch:<var> at src/gen/CORE.setting:762␤  in method dispatch:<.=> at src/gen/CORE.setting:787␤  in …

[14:54] <masak> o.O

[14:54] <pmichaud> back again for a moment

[14:55] <colomon> n: my $brep = ""; for "1.0\n".lines { $brep .= $_ }

[14:55] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at /home/p6eval/niecza/src/STD.pm6 line 3853 (ANON @ 1) ␤  at /home/p6…

[14:55] <masak> r: $_ = "say"; 42 .= $_

[14:55] <p6eval> rakudo 1968b8: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Str'␤  in <anon> at src/gen/BOOTSTRAP.pm:812␤  in any <anon> at src/gen/BOOTSTRAP.pm:808␤  in method dispatch:<var> at src/gen/CORE.setting:762␤  in method dispatch:<.=> at src/gen/CORE.setting:787␤  in …

[14:55] <colomon> masak: ideas for better golfing?

[14:55] <moritz> r: $_ .= $_

[14:55] <p6eval> rakudo 1968b8: OUTPUT«Method 'Any' not found for invocant of class 'Any'␤  in <anon> at src/gen/BOOTSTRAP.pm:800␤  in any <anon> at src/gen/BOOTSTRAP.pm:797␤  in method dispatch:<var> at src/gen/CORE.setting:762␤  in method dispatch:<.=> at src/gen/CORE.setting:787␤  in block <anon> at …

[14:55] <colomon> oh, you're already on it.

[14:55] <masak> n: my $brep = ""; $_ = "1.0"; $brep .= $_

[14:55] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at /home/p6eval/niecza/src/STD.pm6 line 3853 (ANON @ 1) ␤  at /home/p6…

[14:55] <pmichaud> as far as the "nesting" within moritz++'s list assignment example -- I suspect that may actually be rakudo being smart enough to not collapse the nesting until it's convenient (or necessary) to do so

[14:55] <masak> r: my $brep = ""; $_ = "1.0"; $brep .= $_

[14:55] <p6eval> rakudo 1968b8: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'Str'␤  in <anon> at src/gen/BOOTSTRAP.pm:812␤  in any <anon> at src/gen/BOOTSTRAP.pm:808␤  in method dispatch:<var> at src/gen/CORE.setting:762␤  in method dispatch:<.=> at src/gen/CORE.setting:787␤  in …

[14:56] <pmichaud> r:  my @a = 1,2,3;  say @a.DUMP;  # nesting still exists

[14:56] <p6eval> rakudo 1968b8: OUTPUT«Array<9117123632094916941>(:items(Mu), :nextiter(ListIter<9117123632103330891>(:reified(▶Mu), :rest(RPA<9117123632103330897>(Array<9117123632094966091>(:items(RPA<9117123632094921045>(▶1, ▶2, ▶3)), :nextiter(▶Mu)))), :list(Array<9117123632094916941>))))␤»…

[14:56] <moritz> r: my @a = 1, 2, 3; @a[0] = 5; say @a.DUMP

[14:56] <p6eval> rakudo 1968b8: OUTPUT«Array<210349531758767697>(:items(RPA<210349531759943517>(▶5)), :nextiter(ListIter<210349531772507474>(:reified(▶Mu), :rest(RPA<210349531771335763>(▶2, ▶3)), :list(Array<210349531758767697>))))␤»

[14:56] <pmichaud> r:  my @a = 1,2,3;  say @a[0];  say @a.DUMP;

[14:56] *** abercrombie left
[14:56] <p6eval> rakudo 1968b8: OUTPUT«1␤Array<-4576368191250143623>(:items(RPA<-4576368191239098016>(▶1)), :nextiter(ListIter<-4576368190703353748>(:reified(▶Mu), :rest(RPA<-4576368191250124939>(▶2, ▶3)), :list(Array<-4576368191250143623>))))␤»

[14:56] <moritz> we'll still pay the double-nesting penalty for every item that is accessed

[14:57] <pmichaud> no, not really.

[14:57] <pmichaud> how so?

[14:57] <colomon> masak: the reason the rakudo failure was so slow was that for wasn't using lines() lazily, I'll bet.

[14:57] <masak> moritz: you're still confusing the item assignment example with your list assignment example.

[14:57] <masak> moritz: I did too, for a while, I think.

[14:57] <moritz> to get at @a[1], the list still has to descend into two ListIters

[14:57] <masak> colomon: sounds reasonable.

[14:58] <pmichaud> only the first time it's accessed.

[14:58] <moritz> yes, but still for every item once

[14:58] <moritz> masak: no, I'm mixing on purpose

[14:58] *** birdwindupbird left
[14:58] <pmichaud> that's true whether you do it as part of the list assignment or postpone it until later.

[14:58] *** abercrombie joined
[14:58] <pmichaud> rakudo is simply saying "don't bother reifying all of the elements until they're really needed"

[14:59] <pmichaud> where "reify" in this case means "move from the nextIter list into the items list"

[15:00] <pmichaud> back to masak++'s case, what needs to happen is that we need to hotpath  Array.at_pos for the case where the Array doesn't have any lazy (nextiter) part.

[15:00] <pmichaud> instead of relying on self.exists() to do it, which gets expensive.

[15:00] <pmichaud> (because of the method call overhead)

[15:00] <masak> that sounds nice.

[15:01] <pmichaud> I suspect that's the primary speed difference between the hash and array example.  if so, that would get them closer in line, although Array still has a bit more work to do because it has the overhead of checking for a lazy part.

[15:01] <pmichaud> (which is just a definedness check)

[15:02] <pmichaud> Hash has the advantage of being able to do all of its element existence checking in a single Parrot op.  Array has to do several other boundary and laziness checks in addition to the exists Parrot op

[15:02] *** fgomez joined
[15:03] *** fgomez left
[15:03] *** fgomez joined
[15:03] <pmichaud> anyway, I still agree that the double-nesting looks a bit suspicious, but I suspect it's simply Rakudo being (possibly wisely) lazier than we would expect at first glance.

[15:03] *** tokuhiro_ joined
[15:04] <pmichaud> i.e., it's postponing some of the work of moving things into the items attribute, instead of incurring the cost at the point of the assignment

[15:05] <pmichaud> okay, I have to head off to next appointments now -- bbl.

[15:07] <colomon> masak: you want to submit bug reports for your golfs, or shall I?

[15:08] <shinobicl> In this line of code... multi infix:<->(Date:D $a, Date:D $b) {  $a.daycount - $b.daycount; } What does the ':' after 'Date' means?

[15:08] <masak> colomon: please go ahead.

[15:08] *** att_ left
[15:08] <tadzik> shinobicl: Date:D means "a Date object, defined" I think

[15:08] <masak> shinobicl: the ':D' means "must be an instance, can't be a type object"

[15:09] <tadzik> as in "instantiated, not a type object"

[15:10] *** leprevost left
[15:20] *** wolfman2000 left
[15:22] *** att_ joined
[15:22] <fgomez> hey guys, newbie doubt here

[15:22] <fgomez> if i define a sub as sub mysub (*%params) {...}

[15:23] <fgomez> what is the reason a call like this works 'mysub(a=>1, b=>2, c=>3)' but a call like this doesn't 'my %h = a=>1, b=>2, c=>3; mysub(%h);'

[15:24] <tadzik> in the second one you're passing a single hash object rather than a list of pairs

[15:24] <fgomez> I have to flatten the %h with '|' for it to work

[15:24] <tadzik> yes

[15:24] <fgomez> ah ok

[15:24] <fgomez> but why wouldn't it work regardless then?

[15:25] <fgomez> if it's being passed as an object, why wouldn't params assume key=Object, value=undef

[15:25] <TimToady> named args share syntax with pairs, but they're only named args as a special syntax when used at the top level of a call

[15:26] <TimToady> the call object itself is called a Capture, and that contains the positional and named parameters

[15:27] <fgomez> I was trying to verify what was going on in the generated capture

[15:27] <TimToady> the | is what moves something over from the positionals to the nameds

[15:28] <fgomez> but turns out I can't do 'my $capture = \(|%hash)

[15:28] <fgomez> so when I use a slurpy hash in my signature, it's expecting named lists of pairs specifically?

[15:28] <fgomez> list*

[15:28] <masak> fgomez: key=Object, value=undef is p5-think. positional arguments and named arguments mostly move in different spaces.

[15:29] <masak> %h is a positional argument, and as such won't map to a slurpy hash parameter.

[15:30] <geekosaur> maybe the p5think here is that %h is passed as a list in p5, but an object in p6, and the latter cannot be matched against a list of pairs

[15:31] <fgomez> mmm I see

[15:31] <fgomez> that's what I understood wrong I think, that *%params implies a a bunch of pairs

[15:32] <fgomez> oh very nice, so if I do mysub(%h=>'something') it works

[15:34] <masak> I think so.

[15:34] <masak> though %h is likely to be Str-mangled on the receiving end.

[15:34] <fgomez> wait actually no it doesnt

[15:34] <fgomez> hmm

[15:35] <masak> r: my %h; my $pair = %h => 'something'; say $pair.perl

[15:35] <p6eval> rakudo 1968b8: OUTPUT«{} => "something"␤»

[15:36] <fgomez> even if I do mysub(%h.Str=>1) it'll complain

[15:37] <fgomez> r: my %h = a=>1; my %g = b=>2; sub mysub(*%params) { for %params.kv -> $k, $v { say "$k:$v"; } }  mysub(%h.Str=>%b=>Str);

[15:37] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Confused␤at /tmp/yUy0p5YHFe:1␤»

[15:37] <fgomez> oops

[15:38] <fgomez> r: my %h = a=>1; my %g = b=>2; sub mysub(*%params) { for %params.kv -> $k, $v { say "$k:$v"; } }  mysub(%h.Str=>%b.Str);

[15:38] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Confused␤at /tmp/Zyso6Y1G99:1␤»

[15:47] <masak> fgomez: missing ';' after '}'

[15:48] <masak> well, after the '} }', let's say.

[15:49] *** Patterner left
[15:49] *** kaare_ joined
[15:50] <fgomez> r: my %h = a=>1; my %g = b=>2; sub mysub(*%params) { for %params.kv -> $k, $v { say "$k:$v"; } };  mysub(%h.Str=>%b.Str);

[15:50] <p6eval> rakudo 1968b8: OUTPUT«===SORRY!===␤Variable %b is not declared␤at /tmp/2iV53fodDK:1␤»

[15:50] <fgomez> hmm, but that's a subroutine definition. does there need to be a ';' there?

[15:51] <masak> Perl 6 syntax mandates that you either have a \n after a closing curly brace, or a ';'.

[15:51] <fgomez> I'm still playing around with this in the interactive interpreter, but i still don't understand it exactly

[15:51] *** Psyche^ joined
[15:51] *** Psyche^ is now known as Patterner

[15:51] <fgomez> oh I see

[15:51] <awwaiid> masak, I wonder if at some point the principle of least surprise will win that one

[15:52] <masak> awwaiid: how do you mean?

[15:52] <colomon> masak: bug not filed because I cannot convince myself it actually is a bug... I vacillate back and forth.

[15:52] <awwaiid> like if for the next 10 years if I have to tell each person who learns how to do oneliners about that rule, it might get old

[15:52] <masak> awwaiid: nowadays, I'm a bit suprised that one-liners in Perl 5 work without the ';' after the '}' :)

[15:53] <masak> awwaiid: seriously. it's highly illogical.

[15:53] <awwaiid> the rule, or anyone who expects it to work? :)

[15:53] <masak> the rule.

[15:54] <masak> I admit that it makes one-liners look prettier, but at the expense of consistency and sanity.

[15:54] <awwaiid> yeah. There is a difference between \s+ sensitivity and /\n|;/ sensitivity

[15:55] <masak> Perl 6 clearly takes the clean, high road here.

[15:55] <awwaiid> oh I thought you were agreeing with me :)

[15:55] <masak> so no, I don't feel tired explaining it to people, even after 5 years :)

[15:55] <awwaiid> ok

[15:56] <awwaiid> clearly I've been poking at perl6 for a long time and only noticed it recently, so it isn't a big deal

[15:56] <doy> well, it's only illogical if you've already gotten comfortable with whitespace-sensitivity in general

[15:57] *** alester joined
[15:57] <masak> I recently realized that I can't break long expressions of after a closing (usually hash) curly. that bothered me, but not enough to complain about it. I still think it's a net win to have a simple, consistent rule.

[15:57] <awwaiid> doy: I only _barely_ tollerate the idea of \s+ having meaning. Giving /\n|;/ meaning feels icky.

[15:57] <masak> off*

[15:57] <doy> awwaiid: agreed

[15:57] <doy> (:

[15:58] <masak> you're both arguing from a p5 viewpoint, where there simply is no consistency.

[15:59] <awwaiid> well why not take it the other way and allow \n to replace ; in other cases?

[15:59] <awwaiid> I'll tell you why - because it's sick and wrong :)

[15:59] <fgomez> lol

[15:59] <masak> in the same vein, I haven't heard any arguments in defense of sigil variance better than "it makes sense for sigils to vary, and I'm used to it".

[15:59] <awwaiid> irrelevant

[16:00] <doy> masak: i don't understand the consistency argument?

[16:00] <doy> about whitespace specifically

[16:01] <masak> doy: Perl 5's rule seems to be "you can leave off semicolons after block-ending closing curlies, because these sort of terminate a statement anyway. the parser will figure it out for you"

[16:02] <masak> doy: Perl 6's rule is 'every statement, including sub declarations, needs a semicolon. however, "};\n" is so common that we will infer it from "}\n" for you'

[16:02] *** MayDaniel joined
[16:02] <awwaiid> oh, I thought the rule was "you can leave off semicolons before or after blocks because there is no ambiguity on what you mean"

[16:03] <masak> in Perl 5? yeah, maybe.

[16:03] <fgomez> r: sub mysub(*%params) { say "$_:{%params{$_}}" for %params.keys; }; mysub(a=>1,b=>2);

[16:03] <p6eval> rakudo 1968b8: OUTPUT«a:1␤b:2␤»

[16:03] <fgomez> r: sub mysub(*%params) { say "$_:{%params{$_}}" for %params.keys; }; mysub(3=>1,4=>2);

[16:03] <p6eval> rakudo 1968b8: OUTPUT«Too many positional parameters passed; got 2 but expected 0␤  in sub mysub at /tmp/E6ZMFo7FW6:1␤  in block <anon> at /tmp/E6ZMFo7FW6:1␤␤»

[16:03] <fgomez> what is the reason that wouldn't work?

[16:03] <fgomez> the second call that is

[16:03] <masak> awwaiid: the point is, in Perl 6, there *is* ambiguity as to what you mean, because you can use blocks and closures more freely.

[16:03] <awwaiid> so the consistency is that sub declarations are statements, just like other statements. makes sense.

[16:04] <awwaiid> ah. because it looks like a block to me, but it could actually be a param?

[16:04] *** sdo left
[16:05] <masak> fgomez: I don't know, actually. 3 and 4 makes the pairs be interpreted as pairs, not as named arguments.

[16:05] <masak> fgomez: maybe because those are not valid parameter variable names.

[16:05] <masak> awwaiid: yes, or anything really.

[16:06] <awwaiid> and why is \s+ not good enough? We should at least write this down to point stupid pedantics like me at

[16:06] <masak> awwaiid: From S04: "Because subroutine declarations are expressions, not statements, this is now invalid: sub f { 3 } sub g { 3 }"

[16:07] <masak> it's two terms in a row, basically.

[16:07] <masak> std: sub f { 3 } sub g { 3 }

[16:07] <p6eval> std 1ad3292: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/SXasBnbCoX line 1:␤------> [32msub f { 3 }[33m⏏[31m sub g { 3 }[0m␤    expecting any of:␤   infix or meta-infix␤    infixed function␤       statement modifier loop␤Pa…

[16:07] <awwaiid> I find it disturbing that I almost prefer a forced ';' instead of /;|\n/

[16:07] <fgomez> masak: I see, yeah that makes an awful lot of sense actually hehe

[16:08] <masak> awwaiid: then I have an easy solution for you.

[16:08] <awwaiid> hehe

[16:08] <masak> always use '};'

[16:08] <awwaiid> yeah yeah

[16:09] <masak> if it helps, *I* can force you.

[16:09] <awwaiid> that's awefully kind of you to offer :)

[16:09] <masak> anytime :)

[16:10] *** plobsing left
[16:10] <awwaiid> so what can we legitamately put in the blank: sub f { 3 } ________

[16:10] <cognominal> on the shell, how can I ask if something (say Hash) is a class, and somehting (say Associative) is a role?

[16:10] <awwaiid> I guess an operator

[16:12] *** plobsing joined
[16:13] <cognominal> r:  Associative.^roles

[16:13] <p6eval> rakudo 1968b8:  ( no output )

[16:13] <cognominal> r:  say Associative.^roles

[16:13] <p6eval> rakudo 1968b8: OUTPUT«Associative()␤»

[16:13] <cognominal> I guess this a good enough answer

[16:13] <masak> r: say sub f { 3 } + 42

[16:13] <p6eval> rakudo 1968b8: OUTPUT«Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \$v, Mu %_!)␤␤  in method Numeric at src/gen/CORE.setting:644␤  in sub infix:<+> at src/gen/CORE.setting:2284␤  in block <anon> at /tmp/pJnI10rBAj:1␤␤»

[16:14] <masak> r: say sub f { 3 } // 42

[16:14] <p6eval> rakudo 1968b8: OUTPUT«sub f() { ... }␤»

[16:14] <awwaiid> yeah

[16:15] <dalek> rakudo/nom: 69791b0 | masak++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[16:15] <dalek> rakudo/nom: [BOOTSTRAP.pm] fixed copy-paste-o

[16:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69791b0262

[16:15] *** wtw left
[16:16] *** snearch left
[16:16] <cognominal> r:  say Associative.^methods

[16:16] <p6eval> rakudo 1968b8: OUTPUT«of␤»

[16:16] <cognominal> strange that I can call .^roles that does not appear on .^methods

[16:17] <cognominal> is .^roles some other kind of entity?

[16:18] <masak> you're confusing levels, I think.

[16:19] <awwaiid> masak, yeah. pretty significant cost and scary road to go down to start making exceptions to treating the blocks I care about different. that don't make it feel less wrong, but shuts me up for now :)

[16:19] <fgomez> sub mysub($a, $b) { say "$a,$b"; }; mysub(a=>'a', b=>'b');

[16:19] <masak> .^methods lists the methods on the class. .^roles is a method on the metaclass object.

[16:19] <fgomez> r: sub mysub($a, $b) { say "$a,$b"; }; mysub(a=>'a', b=>'b');

[16:19] <p6eval> rakudo 1968b8: OUTPUT«Not enough positional parameters passed; got 0 but expected 2␤  in sub mysub at /tmp/PCW0oR55xf:1␤  in block <anon> at /tmp/PCW0oR55xf:1␤␤»

[16:19] <masak> awwaiid: happy to have had this discussion.

[16:19] <fgomez> is this an outdated construct? I grabbed it from the using Perl6 book

[16:19] <masak> awwaiid: it was eye-opening for me as well.

[16:20] <masak> fgomez: yes.

[16:20] <fgomez> but (clearly) it doesn't work right now, but hte book is from july last year

[16:20] <fgomez> ah ok

[16:20] <fgomez> so in order to pass an argument by name, the parameter has to be named as well?

[16:23] <masak> fgomez: according to the spec, proto subs may declare positional paramteres which can then be bound to named arguments.

[16:24] <masak> fgomez: but it's definitely not implemented in Rakudo, and I doubt it's implemented in Niecza.

[16:24] *** tokuhiro_ left
[16:24] * sjn has updated the Perl 6 Hackathon info page: https://gist.github.com/1711730

[16:24] <sjn> there's a registration link there now \o/

[16:25] <sjn> GO FORTH AND REGISTER! \o/

[16:27] <masak> \o/

[16:28] <cognominal> r: Associative.HOW.^methods

[16:28] <p6eval> rakudo 1968b8: OUTPUT«Method 'dispatch:<.^>' not found for invocant of class 'Perl6::Metamodel::ParametricRoleGroupHOW'␤  in block <anon> at /tmp/P8KkIYum1t:1␤␤»

[16:29] *** pmurias joined
[16:29] <pmurias> fglock: hi

[16:30] <masak> cognominal: the metaclass object has a metaclass object; it just doesn't have the sugar to invoke methods on it that way. :)

[16:31] <cognominal> r: Associative.HOW.HOW.methods

[16:31] <pmurias> fglock: we now pass 3 perl5 tests ;)

[16:31] <p6eval> rakudo 1968b8: OUTPUT«too few positional arguments: 1 passed, 2 (or more) expected␤  in methods at src/stage2/gen/nqp-mo.pm:984␤  in block <anon> at /tmp/wHyuJkRYWg:1␤␤»

[16:32] <masak> cognominal: and now you see what the sugar does for you (it supplies the object you're interested in)

[16:32] <masak> r: Associative.HOW.HOW.methods(Associative.HOW)

[16:32] <p6eval> rakudo 69791b: OUTPUT«too few named arguments: no argument for required parameter 'local'␤  in methods at src/stage2/gen/nqp-mo.pm:984␤  in block <anon> at /tmp/wsn1zMf7Sr:1␤␤»

[16:32] *** kaleem_ joined
[16:32] <masak> r: Associative.HOW.HOW.methods(Associative.HOW, :local(1))

[16:32] <p6eval> rakudo 69791b:  ( no output )

[16:32] <masak> r: say Associative.HOW.HOW.methods(Associative.HOW, :local(1))

[16:32] <p6eval> rakudo 69791b: OUTPUT«Method 'gist' not found for invocant of class 'NQPRoutine'␤  in method gist at src/gen/CORE.setting:4189␤  in sub say at src/gen/CORE.setting:6216␤  in block <anon> at /tmp/AZqTSPqVNo:1␤␤»

[16:32] <masak> anyway, that works :)

[16:32] *** fglock left
[16:33] <masak> r: say Associative.HOW.HOW.methods(Associative.HOW, :local(1)).elems

[16:33] <p6eval> rakudo 69791b: OUTPUT«22␤»

[16:34] *** kaleem left
[16:40] *** nwc10 joined
[16:42] *** pmurias left
[16:49] *** havenn joined
[16:50] *** M_o_C joined
[16:50] *** fgomez left
[16:50] <PerlJam> .oO( How now brown cow? )

[16:51] <pmichaud> PerlJam: good to see you again also :)

[16:51] * nwc10 is impressed with how masak stumbled across an incantation that summons pmichaud 

[16:52] <pmichaud> yes, masak++.  It's also a matter of having really good timing on that one.  Other tickets have gotten my attention but I've been too busy with other stuff to "respond"  :)

[16:52] <masak> nwc10: I was thinking the same.

[16:53] <masak> nwc10: "I should submit more List-internals tickets!" :)

[16:53] <pmichaud> long ago in the early days of my contributions, it was thought that simply mentioning any form of PGE bug was sufficient to summon me to #parrot :)

[16:53] <sjn> pmichaud: https://gist.github.com/1711730 :)

[16:53] <sjn> jnthn: same to you

[16:54] <sjn> moritz: and you :)

[16:54] <sjn> tadzik: and you :D

[16:54] <pmichaud> sjn: excellent!

[16:54] <sjn> fsergot isn't there though

[16:54] <sjn> here*

[16:55] <sjn> how does one leave messages to people?

[16:55] <tadzik> sjn: I did it already :)

[16:55] <tadzik> phenny: tell sjn this way

[16:55] <phenny> tadzik: I'll pass that on when sjn is around.

[16:55] <sjn> yay!

[16:55] <phenny> sjn: 16:55Z <tadzik> tell sjn this way

[16:56] <sjn> phenny: tell fsergot https://gist.github.com/1711730 for your register-joyment :)

[16:56] <phenny> sjn: I'll pass that on when fsergot is around.

[16:57] <sjn> tadzik: have you recieved a host from us yet? :)

[16:57] * masak decommutes

[16:57] <sjn> tadzik: or have you organized something else

[16:58] <tadzik> sjn: oh, huh, weren't you to be my host?

[17:00] <sjn> I'm going the find you one :)

[17:00] <tadzik> okay :)

[17:00] <sjn> although if you prefer, you can stay at my place 

[17:00] <sjn> no problems with that

[17:00] <tadzik> what suits you best, although I seem to recall you offering me a place :)

[17:00] *** fgomez joined
[17:00] <sjn> well, I almost did :)

[17:01] <sjn> we have commitments for 6 beds from 4 hosts

[17:01] <fgomez> lol, vim-perl perl6 syntax plugin for vim brings it down to its knees

[17:01] <sjn> but we haven't really matched people with hosts yet :)

[17:02] <tadzik> okay :)

[17:02] *** wolfman2000 joined
[17:04] <sjn> masak: so you're planning on staying at a hotel?

[17:04] <sjn> masak: we can probably find you a sofa if you're interested saving money

[17:05] <PerlJam> Is someone going to blog on what happened with GSoC + TPF ?

[17:05] <arnsholt_> fgomez: Yeah, it's a known issue, unfortunately

[17:05] <sjn> masak: buf if you want to stay at a hotel anyway, pmichaud will be staying at http://anker-hotel.no/ :)

[17:13] <cognominal> thx, masak. was way from keyboard and will be.

[17:19] *** fglock joined
[17:19] <pmichaud> http://gist.github.com/2119935  # before and after timings of patch to hotpath Array.at_pos

[17:20] <pmichaud> spectesting now.

[17:26] <pmichaud> all tests pass

[17:27] <shinobicl> some time ago, i used to have some overloaded operators with "our multi...." in a .pm file. Now, i understand that this is not possible. Well, i declared those operators in a .pm file as "multi infix..." , and i have a .t that uses that .pm file. Now I can't invoke those overloaded operators. 

[17:28] <tadzik> pmichaud: cool!

[17:28] *** colomon left
[17:28] <moritz> shinobicl: you need to 'is export' them

[17:28] <shinobicl> oh, i see. thanks moritz!

[17:29] <pmichaud> updating the patch to handle the  at_pos(int) case

[17:29] <PerlJam> moritz: it's enough to "is export" the proto isn't it?

[17:30] *** nwc10 left
[17:30] <shinobicl> i was using Temporal.pm as an example... i can't find the 'export' word in that file.

[17:30] <moritz> PerlJam: yes, but if you want to add multis to an existing operator, a proto is the wrong thing to export

[17:31] <moritz> shinobicl: Temporal.pm isn't "use"ed in the normal way; it's part of the setting

[17:31] <moritz> shinobicl: so things are different

[17:31] *** colomon joined
[17:34] <pmichaud> r:  say (1.1902-0.8430)/1.1902

[17:34] <p6eval> rakudo 69791b: OUTPUT«0.291715678037305␤»

[17:35] <pmichaud> 30% speedup isn't bad :)

[17:35] <pmichaud> oops

[17:35] <pmichaud> r:  say (1.1902-0.8929)/1.1902

[17:35] <p6eval> rakudo 69791b: OUTPUT«0.249789951268694␤»

[17:35] <pmichaud> 25% speedup isn't bad :)

[17:35] <PerlJam> http://www.slate.com/articles/technology/technology/2012/03/ruby_ruby_on_rails_and__why_the_disappearance_of_one_of_the_world_s_most_beloved_computer_programmers_.single.html

[17:36] <PerlJam> Scroll down to where she asks "But what language to learn?" and look at the 3 reasons cited for choosing ruby

[17:36] <PerlJam> particularly that third one.

[17:37] <moritz> pmichaud: I also suspect that iteration could be optimized for reified lists somehow (unless it already is)

[17:38] <moritz> as well as iteration over integer ranges

[17:38] *** tyatpi joined
[17:38] <pmichaud> moritz: it has some optimizations already but there are more to be explored

[17:38] <moritz> though the real beef is in sink context, where we don't have to keep the return values around

[17:38] <pmichaud> it's important to note that reified/not reified isn't the only dimension, there's also flattened/unflattened

[17:39] <daxim> PerlJam, conclusion?

[17:39] <moritz> right, that's one that I don't really appreciate yet

[17:39] <pmichaud> something can be reified but unflattened, which means that in e.g., list assignment you still have to walk through the list to do flattening.

[17:39] <fgomez> Oh gee, just downloaded the updated draft for Using Perl 6, and the wording on the Signatures part is much clearer than the old version I was reading

[17:39] <pmichaud> List.reify uses some opcode optimization in place to avoid walking through elements when it can detect (how much of) a simple splice is sufficient

[17:41] <pmichaud> what lists really want is some sort of flag that says "I'm fully reified and all of my elements are flattened."  The Seq type held that honor at one point, but its place in the type parentage was always off.

[17:44] *** mj41_nb left
[17:49] *** kaleem_ left
[17:50] *** havenn left
[17:52] <fgomez> are the synopses the best reference to learn perl6 right now?

[17:54] *** colomon left
[17:55] *** colomon joined
[17:56] <PerlJam> fgomez: there's also "Using Perl 6"

[17:56] *** havenn joined
[17:56] <moritz> which fgomez already mentioned :-)

[17:56] <moritz> there are also various blogs about perl 6, for example the Perl 6 advent calendar

[17:56] <PerlJam> ah, so he did.

[17:57] <PerlJam> fgomez: I'd say there is currently no "best reference" for learning Perl 6.  :)

[17:57] <PerlJam> or, the best reference is to use everything you can find.

[17:57] <fgomez> hmm

[17:57] <moritz> the best is to read all the stuff out there, and hang around here and ask questions whenever there's something unclear

[17:57] <PerlJam> (but treat the synopses as definitive)

[17:57] <moritz> and play with the compilers

[18:01] <fgomez> ..

[18:01] <fgomez> ops

[18:01] <moritz> rakudo: say 'play with me!'

[18:01] <p6eval> rakudo 69791b: OUTPUT«play with me!␤»

[18:02] *** NamelessTee left
[18:06] <dalek> rakudo/nom: c10792f | pmichaud++ | src/core/Array.pm:

[18:06] <dalek> rakudo/nom: Hotpath the check for existing elements in Array.at_pos(), addressing (partially) the Array-versus-Hash initialization speed anomaly described in RT #111848.

[18:06] <dalek> rakudo/nom: 

[18:06] <dalek> rakudo/nom: Each Array element access via .at_pos($pos) resulted in an expensive

[18:06] <dalek> rakudo/nom: call to self.exists($pos) for each access, whereas Hash element accesses

[18:06] <dalek> rakudo/nom: via .at_key($key) were able to use nqp::existskey() directly.  This patch

[18:06] <dalek> rakudo/nom: uses nqp::existspos() to hotpath the detection of existing elements and

[18:06] <dalek> rakudo/nom: avoids calls to self.exists($pos) when the Array is already fully

[18:06] <dalek> rakudo/nom: reified.  For the benchmark given in RT #111848, this results in a ~25%

[18:06] <dalek> rakudo/nom: speedup for array element accesses, and brings it to within 5% of Hash

[18:06] <dalek> rakudo/nom: element access times.  (At present Array element accesses still have

[18:06] <dalek> rakudo/nom: more overhead at the PIR level than Hash element accesses due to laziness

[18:06] <dalek> rakudo/nom: considerations and boundary checks.)

[18:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c10792f88a

[18:07] *** dakkar left
[18:11] *** plobsing left
[18:18] *** havenn left
[18:26] *** tyatpi left
[18:34] *** sisar left
[18:37] <fgomez> Oh I didn't know you could specify a return type in sub definitions..

[18:38] <TimToady> yup

[18:39] <TimToady> in any of three different places, in fact

[18:40] *** havenn joined
[18:40] <fgomez> r: sub bar ($x, $y --> Int()) { return 3.5 }; bar();

[18:40] <p6eval> rakudo c10792: OUTPUT«===SORRY!===␤Missing block␤at /tmp/92lqv2sp41:1␤»

[18:40] *** jaldhar left
[18:41] <fgomez> :<

[18:41] *** NamelessTee joined
[18:41] <pmichaud> r: sub bar ($x, $y --> Int) { return 3.5 }; bar()

[18:41] <p6eval> rakudo c10792: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'bar' will never work with no arguments (line 1)␤    Expected: :(Any $x, Any $y)␤»

[18:42] <pmichaud> r: sub bar ($x, $y --> Int) { return 3.5 }; bar(3,4)

[18:42] <p6eval> rakudo c10792:  ( no output )

[18:42] <pmichaud> r: sub bar ($x, $y --> Int) { return 3.5 }; say bar(3,4)

[18:42] <p6eval> rakudo c10792: OUTPUT«3.5␤»

[18:42] <pmichaud> nyi, I guess.

[18:44] <pmichaud> afk

[18:48] <jnthn> afternoon, #perl6

[18:48] <jnthn> ooh, pmichaud! \o/

[18:49] <jnthn> Pro tip: in Argentina, the price for wine in the menu that would seem to get you a glass of it in Sweden does actually get you a whole bottle here in Argentina. Lunch was very liquid. :)

[18:49] <colomon> o/

[18:51] <jnthn> Given arrays are lazy in Perl 6 and hashes need not do that, somehow I don't actually feel that surprised that arrays aren't crazy faster than hashes.

[18:51] *** ksi joined
[18:52] <jnthn> Natively typed arrays, otoh, apparently won't have to do any laziness.

[18:52] <jnthn> So should be decidedly faster.

[18:53] <pmichaud> do natively typed arrays have to deal with undefined elements?

[18:53] <pmichaud> or non-existent elements?

[18:53] <jnthn> pmichaud: There's no "undefined" as far as natives go since everything is unboxed

[18:53] <pmichaud> (jnthn: o/ !)

[18:54] <jnthn> Non-existent - yeah, if you index past the end. And then it depends if it's an explicitly sized array or not. :)

[18:54] <pmichaud> jnthn: right.  Much of the overhead for Array is dealing with vivification and laziness issues

[18:55] <jnthn> *nod*

[18:55] <jnthn> There's still a few oddnesses with arrays/lists, fwiw.

[18:55] <jnthn> I put in a patch that helped with list assignment at some point a while back.

[18:55] <pmichaud> anyway, my patch got Array to within 5% of Hash, so I suspect that's about as good as to be expected until we stop optimizing for constant lists or lists that we know certain characteristics of (e.g., constant lists)

[18:55] <jnthn> "until we stop" - start? :)

[18:56] <pmichaud> *start, yes.

[18:56] <jnthn> :)

[18:56] <TimToady> well, you can't stop until you've started either...

[18:56] <jnthn> Anyway, the patch I did was likely imperfect.

[18:56] <pmichaud> I'm likely to look a little more at List issues as I start finding tuits :)

[18:56] <pmichaud> especially since there are some good list-y tickets :)

[18:56] <jnthn> Nice. They're still the bit of Rakudo that I find hardest to hack on.

[18:57] <pmichaud> I still want to try to refactor List.munch to improve iteration speed, too.

[18:57] <jnthn> I'm relatively comfortable on the regex engine by now, but the lists are still a place I don't feel I've wrapped my head around the model.

[18:57] <TimToady> perl6: constant @foo = 1, @foo; say @foo[5]

[18:58] <jnthn> Well, parts of it I have...but when I go to hack on it I always feel I'm missing something.

[18:58] <p6eval> rakudo c10792: OUTPUT«===SORRY!===␤Variable @foo is not declared␤at /tmp/5ZXhMWKSIe:1␤»

[18:58] <p6eval> ..pugs: OUTPUT«pugs: *** Undeclared variable: ("@foo",MkPad (padToList []),[PCompiling {pc_pad = MkMPad {mp_id = 140653128351729, mp_pad = <ref:0x7fec5b5ccb21>}}])␤    at /tmp/BhLhXlKgdw line 1, column 20-24␤»

[18:58] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Any()␤»

[18:58] <TimToady> be nice when that works too

[18:58] <jnthn> TimToady: In Rakudo, that *may* just be an error in symbol handling.

[18:59] <TimToady> is probably missing some "I'm not defined yet" backpressure somewhere or other

[18:59] <jnthn> TimToady: Oh, I think it's deeper than that.

[19:00] <jnthn> TimToady: How is it meant to work?

[19:00] <jnthn> TimToady: Constant delcarations are kind binding as far as I understand them. And there's nothing to say that @foo should be lazily read.

[19:00] <jnthn> s/ind//

[19:00] <jnthn> s/ind/kind/ # clearly, the wine worked...

[19:01] * pmichaud is not crying for jnthn++ in Argentina.

[19:01] <jnthn> :)

[19:01] <TimToady> if .ar wines are like .uy wines, then only about 10%, but that just makes it easier to have too much :)

[19:01] <jnthn> pmichaud: Happy you're going to make it over to Oslo :)

[19:01] <pmichaud> jnthn: me too!

[19:02] <jnthn> TimToady: I think I'm still suffering from expecting Swedish prices to apply to alcohol here. :)

[19:02] <pmichaud> afk

[19:02] <TimToady> @foo is in a list, and lists are supposed to be lazy unless forced not to be

[19:02] <TimToady> and the = is not really an assignment, which would be eager

[19:02] <jnthn> TimToady: OK, so...what is it? :)

[19:02] <TimToady> it's an initializer

[19:02] <jnthn> To elaborate, my problem with the construct is this (more)

[19:03] <jnthn> "1, @foo" to me is making a Parcel from 1 and a lookup up @foo

[19:03] *** havenn left
[19:03] <jnthn> In that constant declaration, @foo is not yet bound to anything.

[19:03] <jnthn> s/up/of/

[19:03] <TimToady> which is why it's an initializer, not just a binding

[19:03] *** fgomez left
[19:04] <jnthn> TimToady: I'm happy enough that they're different, I just don't grok what the "it's an initializer" bit actually boils down to here.

[19:04] *** sporous left
[19:04] *** fgomez joined
[19:04] *** sporous joined
[19:05] *** cogno joined
[19:06] <jnthn> TimToady: If the answer is "@foo has an Array installed in the symbol, *then* we evaluate the RHS and assign it" then I can go with that.

[19:06] <jnthn> (In that case, it's just like a "my" declaration)

[19:06] <TimToady> no

[19:07] <TimToady> that's not what is wanted here, since my's initializer is like assignment in being eager

[19:07] <TimToady> this needs to be a recursive definition that returns 1,1,1,1,1...*

[19:08] <TimToady> useless in this case, but there are more useful recursive definitions

[19:08] <jnthn> I understand the desired result. I'm missing how we get to it.

[19:08] <TimToady> reify can never reify more than one value at each level with that definition, and has to recurse through the laziness to get another 1

[19:09] *** tyatpi joined
[19:09] <TimToady> well, maybe it can reify twice as many each time

[19:10] <TimToady> so each recursion level is like 1,@foo  1,1,@foo  1,1,1,1,@foo 1,1,1,1,1,1,1,1,@foo

[19:11] <TimToady> but a more interesting example (required to work by the Python test suite!) is hamming numbers

[19:11] <TimToady> constant @hamming = 1, dedup (@hamming X* 2) M (@hamming X* 3) M (@hamming X* 5);

[19:12] <TimToady> where M is a merge infix

[19:12] <TimToady> well, different syntax in Python, of course

[19:12] <jnthn> If we have "1, @foo" then we don't want to change the semantics of parcels, which means @foo has to be *something* at the time we evaluate the RHS of the constant declaration. I'm just missing 1) what @foo is at that point, and 2) what we do with @foo once we've BEGIN-time evaluation of the RHS.

[19:13] <TimToady> it's the promise to return whatever is in @foo

[19:13] <TimToady> interpolating @foo into a list should be lazy

[19:13] <TimToady> so it represents an iterator of some sort

[19:13] <jnthn> I guess what I'm really asking is, does what you want desugar to something we already have, or is it something different?

[19:13] *** libertyprime joined
[19:14] <jnthn> Because I'm looking at this expecting it to desugar into something we already have. Which may be wrong...

[19:14] * TimToady is not sure if it desugars, having failed so far to get any hamming implementation to work

[19:15] *** cogno_ joined
[19:16] <TimToady> but that may be the lack of ability to merge lists lazily, which is why I simplified to 1,@foo

[19:17] <TimToady> something in there seems to be snapshotting the current reification of @foo, not the abstraction of a lazy array

[19:19] <TimToady> or maybe it's copying over the current plan and not allowing that to be extended somehow with lazy plans that we don't know yet

[19:20] *** M_o_C left
[19:26] * masak home

[19:26] *** cogno left
[19:27] <TimToady> here's some discussion of hamming in Python: http://paddy3118.blogspot.com/2009/11/hamming-numbers-and-perl-why-i-just.html

[19:28] <TimToady> defer_output is their way of talking about lazy iterators, I think

[19:28] *** wolfman2000 left
[19:28] *** cogno_ left
[19:29] <TimToady> another: http://mail.python.org/pipermail/python-list/2005-January/916102.html

[19:31] <pmichaud> (just here for a second) ... also, are we clearly making the distinction that   constant @foo = 1, @foo;  is lazy while  my @foo = 1, @foo;  is eager?

[19:31] <TimToady> yes

[19:31] <pmichaud> okay

[19:31] <TimToady> each declarator can treat = however it likes

[19:31] <TimToady> that's one of the reasons we changed the parser to slurp the = with the declarator

[19:32] <pmichaud> wfm

[19:32] <pmichaud> afk again, kid school pickup

[19:32] <TimToady> it can also decide what :=, ::=, or .= mean

[19:32] <masak> sjn: ah. I didn't want to impose unnecessarily. but if you have spare sofas in circulation, I'd be happy to fill one. :)

[19:32] *** aindilis left
[19:33] <masak> sjn: 'd probably be more of an adventure than hotel anyway.

[19:33] *** aindilis joined
[19:33] <masak> fwiw, jnthn and I are les slow, and haven't made definite trav plans yet.

[19:34] <TimToady> lunch &

[19:34] <jnthn> True :)

[19:34] <masak> pmichaud++ # 30% speedup

[19:35] * jnthn was guessing hotel, or short-term appartment, or something :)

[19:37] *** cogno joined
[19:38] *** birdwindupbird joined
[19:40] <masak> PerlJam: (re Ruby and hugging) I knew it! Perl 6 is the new Ruby! :P

[19:41] <PerlJam> masak: yep :-)

[19:41] *** cogno left
[19:55] *** cogno joined
[19:57] *** daxim left
[20:03] *** cogno left
[20:03] *** havenn joined
[20:12] <shinobicl> nom: class A { has Int @.val is rw = <100>; method perl{ return "A.new($.val)"; }; method cloneadd3(){ my $aclone = self.clone; $aclone.val.push(3); return $aclone; }  }; my A $a = A.new(); say $a.perl; my $b = $a.cloneadd3; say $a.perl; say $b.perl;

[20:12] <p6eval> rakudo c10792: OUTPUT«A.new(100)␤A.new(100 3)␤A.new(100 3)␤»

[20:12] <shinobicl> i think the second "say" is wrong.... why $a has another element added being that i add the element to the clone?

[20:13] <tadzik> possibly it doesn't deepcopy

[20:13] <moritz> there's no possible one-size-fits-them-all solution for clone

[20:14] <shinobicl> nom: class A { has Int $.val is rw = 100; method perl{ return "A.new($.val)"; }; method cloneplus3(){ my $aclone = self.clone; $aclone.val += 3; return $aclone; }  }; my A $a = A.new(); say $a.perl; my $b = $a.cloneplus3; say $a.perl; $a.cloneplus3(); say $a.perl; say $b.perl;

[20:14] <p6eval> rakudo c10792: OUTPUT«A.new(100)␤A.new(100)␤A.new(100)␤A.new(103)␤»

[20:14] <shinobicl> for scalars it seems to work

[20:15] <moritz> well, only for value types

[20:17] <masak> more specifically, no language provides a general deepcopy method, and no language ever will.

[20:18] <masak> the world is too gnarly for that. it contains spoilsport types like database handles and other perishable-resource things.

[20:19] <shinobicl> but even then, isn't much safer to make clone send a warning when trying to clone complex structures? or maybe i'm just using the wrong function (clone)

[20:22] <moritz> you should make your own method for deep cloning

[20:22] <shinobicl> i will... thanks again :)

[20:22] *** fglock left
[20:24] <masak> making your own method for deep cloning is the only solution I know of, from a language design perspective.

[20:25] <masak> well, the far extreme of that is a serialization framework :)

[20:26] <shinobicl> my own clone method sounds much saner

[20:31] *** birdwindupbird left
[20:35] *** snearch joined
[20:37] *** MayDaniel left
[20:44] *** pernatiy joined
[20:49] *** fgomez left
[20:59] *** perimosocordiae left
[21:00] *** fgomez joined
[21:07] *** libertyprime left
[21:09] *** libertyprime joined
[21:11] <shinobicl> nom: use Test; ok(1==2, "fails"); dies_ok( { my $x = (1/0); }, 'division by zero'); dies_ok( { my $x = (1/1); }, 'division');

[21:11] <p6eval> rakudo c10792: OUTPUT«not ok 1 - fails␤not ok 2 - division by zero␤not ok 3 - division␤»

[21:12] *** kaare_ left
[21:12] <benabik> r: try { my $x = (1/0); }; say $!

[21:12] <p6eval> rakudo c10792: OUTPUT«Mu()␤»

[21:12] <benabik> r: my $x = (1/0)

[21:12] <p6eval> rakudo c10792:  ( no output )

[21:13] <shinobicl> i think that the 2nd test should report success

[21:13] <benabik> r: say (1/0)

[21:13] <p6eval> rakudo c10792: OUTPUT«Inf␤»

[21:13] *** havenn left
[21:13] <benabik> shinobicl: 1/0 doesn't die, it returns Inf.

[21:13] <shinobicl> ok.. i see , 1/0 is not an exception:S

[21:13] <benabik> I'm not sure why it does.  That's not the right answer.

[21:15] *** skids left
[21:15] *** mj41_nb joined
[21:29] *** tokuhiro_ joined
[21:30] *** snearch left
[21:33] <flussence> shouldn't that only happen for Num, not Int?

[21:33] <flussence> perl6: say 1e0 / 0e0; say 1/0;

[21:33] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Inf␤Inf␤»

[21:33] <p6eval> ..rakudo c10792: OUTPUT«Divide by zero␤  in block <anon> at /tmp/hNLuyrwdB7:1␤␤»

[21:33] <p6eval> ..pugs: OUTPUT«*** Illegal division by zero␤    at /tmp/4UUG04Skbi line 1, column 5-14␤»

[21:34] <flussence> perl6: say 1/0; say 1e0/0e0;

[21:34] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Inf␤Inf␤»

[21:34] <p6eval> ..rakudo c10792: OUTPUT«Inf␤Divide by zero␤  in block <anon> at /tmp/cVnBBXkWEU:1␤␤»

[21:34] <p6eval> ..pugs: OUTPUT«*** Illegal division by zero␤    at /tmp/qi8QECl0_M line 1, column 5-8␤»

[21:35] <dalek> roast: eb002d6 | jonathan++ | S04-phasers/pre-post.t:

[21:35] <dalek> roast: Correct and unfudge a test; POST runs LIFO.

[21:35] <dalek> roast: review: https://github.com/perl6/roast/commit/eb002d65e1

[21:37] *** shinobicl left
[21:47] *** NamelessTee left
[21:47] *** NamelessTee joined
[21:57] *** havenn joined
[21:58] <Juerd> moritz: Possibly. Can you be more specific about the requirements?

[22:01] *** pernatiy left
[22:02] *** havenn left
[22:03] *** havenn joined
[22:05] <dalek> rakudo/nom: eff8364 | jonathan++ | src/ (3 files):

[22:05] <dalek> rakudo/nom: Aborted PRE does not run POST or LEAVE phasers of the block.

[22:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eff83643f5

[22:06] <dalek> roast: 70ba2f8 | jonathan++ | S04-phasers/pre-post.t:

[22:06] <dalek> roast: Untodo another PRE/POST test.

[22:06] <dalek> roast: review: https://github.com/perl6/roast/commit/70ba2f8c5a

[22:07] <dalek> features: 96c433a | jonathan++ | features.json:

[22:07] <dalek> features: Update for PRE/POST phasers; Rakudo gets +, and since the submethod form is gone from spec then Niecza no longer needs +- on this.

[22:07] <dalek> features: review: https://github.com/perl6/features/commit/96c433a232

[22:07] <flussence> the alt+f4 ending

[22:07] <flussence> whoops, ww

[22:12] <masak> sounds like an abrupt endind.

[22:12] <masak> ending*

[22:12] <masak> I'm in xmonad, and I still haven't really gotten used to alt+f4 not being bound to anything.

[22:13] *** ksi left
[22:14] <flussence> I've used e17 a few times, its default shortcuts really threw me off. I think "close window" is alt+X

[22:15] <tadzik> I'm in KDE and I can't imagine it any other way than shift-windows-c ;)

[22:15] <huf> i've been using win-e for ages 

[22:17] <masak> you're all freaks, the lot of you :P

[22:18] <flussence> .oO( close windows manually? just let the OOM-killer clean them up for you! :)

[22:19] <masak> clearly Ctrl+Alt+Bksp is the only way to end applications.

[22:19] <tadzik> window garbage collector

[22:19] <masak> flussence: actually, that's the way it seems to work on my phone.

[22:19] <masak> I never close stuff, I just shift over to some other app.

[22:19] <tadzik> you never close tabs, too ;)

[22:20] <tadzik> well, g'night #perl6

[22:20] <sjn> nn o/

[22:20] <jnthn> 'night, tadzik 

[22:20] <flussence> I remember (a long time ago now) reading about "crash-safe app design" where things should be built around the expectation that the process can be killed at any time. Sounds like that idea got put to use :)

[22:21] <masak> dobranoc, drodzy tadzik.

[22:22] <masak> flussence: fwiw, in Android there are hooks for various levels of inactivity.

[22:22] <masak> flussence: apps are expected to preemptively save away everything already at the first level, which is just "unfocus" or something like that.

[22:23] <dalek> rakudo/nom: 169bc80 | jonathan++ | docs/ChangeLog:

[22:23] <dalek> rakudo/nom: Couple more ChangeLog notes.

[22:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/169bc8051e

[22:26] <jnthn> Hmm. Rakudo has a release manager for the April release, but not one for the March release on this Thursday. If you fancy releasing the release with a bunch of phasers implemented and a nice startup time reduction, do sign up in docs/release_guide.pod. :)

[22:27] <jnthn> masak: If you get a moment, something in the ChangeLog about macros landing would be le nice. :)

[22:34] <[Coke]> pugs: say 3.Rat

[22:34] <p6eval> pugs: OUTPUT«*** No such method in class Int: "&Rat"␤    at /tmp/KL6AvTuNvr line 1, column 5 - line 2, column 1␤»

[22:34] *** plobsing joined
[22:35] <masak> jnthn: gotcha.

[22:35] * masak looks into it

[22:36] <masak> I can do this months release, but I would *prefer* to see some enthusiastic semi-newcomer sign up. I did last month.

[22:38] *** skids joined
[22:38] <dalek> rakudo/nom: b2505be | masak++ | docs/ChangeLog:

[22:38] <dalek> rakudo/nom: [docs/ChangeLog] added macros and quasis

[22:38] <dalek> rakudo/nom: 

[22:38] <dalek> rakudo/nom: Oh right! Almost forgot. :-)

[22:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b2505be2e1

[22:39] <masak> 'night, #perl6

[22:39] <felher> o/ masak

[22:41] <colomon> \o

[22:46] *** cognominal left
[22:53] <[Coke]> when is the release this month?

[22:53] *** NamelessTee left
[22:56] *** whiteknight joined
[22:57] <[Coke]> ah, nevermind. I'm not going to move up my volunteer month. ;)

[22:57] <[Coke]> pmichaud: o/

[23:05] *** tyatpi left
[23:07] *** tokuhiro_ left
[23:07] <jnthn> [Coke]: Yes, I noticed you were up for next month. Thanks. :)

[23:08] * jnthn => finding dinner in a thunderstorm :)

[23:12] *** mj41_nb left
[23:23] *** havenn left
[23:27] <[Coke]> I figured this month was too close to the week of meetings in the UK for me to pay attentions.

[23:28] * [Coke] has now had some great Thai and Indian, and wonders if they will hit an ``English'' place some night this week.

[23:29] *** cognominal joined
[23:29] <[Coke]> gah. again I've been charging my laptop for hours except I didn't flip the little switch next to the power outlet.

[23:31] *** BooK left
[23:31] *** BooK joined
[23:32] *** doy left
[23:33] *** att_ left
[23:36] *** att_ joined
[23:40] *** y3llow left
[23:40] *** y3llow joined
[23:40] *** doy joined
[23:45] *** PacoAir left
[23:59] <sorear> good * #perl6

