[00:05] *** wolfman2000 joined
[00:06] *** lichtkind_ joined
[00:07] *** lichtkind left
[00:07] *** lichtkind_ is now known as lichtkind

[00:09] *** lichtkind left
[00:17] *** xinming left
[00:18] *** xinming joined
[00:24] <sorear> good * #perl6

[00:24] <sorear> moritz: What is the rationale for splitting out substr-rw?

[00:31] <araujo> hello sorear o/

[00:36] <sorear> o/ araujo

[00:39] <geekosaur> sorear, as I understand it, making substr work for both lvalue and rvalue means even the rvalue uses take a significant performance hit

[00:47] *** tokuhirom joined
[00:47] *** s1n left
[00:54] <colomon> \o

[00:59] * colomon meant to port moritz++'s code to niecza, but is somewhat obsessed with his ABC bug at the moment.

[01:01] *** scott_ joined
[01:02] *** scott_ is now known as Guest90895

[01:03] <colomon> "port" may mean cut-n-paste this time...

[01:04] *** s1n joined
[01:06] *** ispeak_ left
[01:19] *** shinobicl left
[01:22] *** replore joined
[01:23] <[Coke]> # 05/15/2012 - rakudo++ (22162); niecza (91.96%); pugs (35.01%)

[01:25] <dalek> tablets: 977e2a1 | (Herbert Breunung)++ | docs/appendix-g-glossary.txt:

[01:25] <dalek> tablets: polish glosary

[01:25] <dalek> tablets: review: https://github.com/perl6/tablets/commit/977e2a194e

[01:25] *** s1n left
[01:29] *** adu joined
[01:30] <dalek> tablets: 28ddcbc | (Herbert Breunung)++ | docs/appendix-g-glossary.txt:

[01:30] <dalek> tablets: linking term operand

[01:30] <dalek> tablets: review: https://github.com/perl6/tablets/commit/28ddcbc3f2

[01:30] *** wolf2k_away joined
[01:30] *** Tedd1 joined
[01:30] *** wolfman2000 left
[01:30] *** Tedd1^ left
[01:32] *** benabik joined
[01:35] <adu> ok I think I get it now

[01:35] <adu> I need backtracking so I can't use tokens

[01:37] <adu> r: my token char { <[\ ..~]> }; my token cd_start { '<![CDATA[' }; my token cd_data { <.char>* <?before ']]>'> }; my token cd_end { ']]>' }; my token cd_sect { <.cd_start> <cd_data> <.cd_end> }; say "<![CDATA[ hello ]]>" ~~ /^ <cd_sect> $/

[01:37] <p6eval> rakudo 22c12b: OUTPUT«#<failed match>␤»

[01:37] <adu> my token char { <[\ ..~]> }; my token cd_start { '<![CDATA[' }; my regex cd_data { <.char>* <?before ']]>'> }; my token cd_end { ']]>' }; my token cd_sect { <.cd_start> <cd_data> <.cd_end> }; say "<![CDATA[ hello ]]>" ~~ /^ <cd_sect> $/

[01:38] <adu> r: my token char { <[\ ..~]> }; my token cd_start { '<![CDATA[' }; my regex cd_data { <.char>* <?before ']]>'> }; my token cd_end { ']]>' }; my token cd_sect { <.cd_start> <cd_data> <.cd_end> }; say "<![CDATA[ hello ]]>" ~~ /^ <cd_sect> $/

[01:38] <p6eval> rakudo 22c12b: OUTPUT«=> <<![CDATA[ hello ]]>>␤ cd_sect => <<![CDATA[ hello ]]>>␤  cd_data => < hello >␤␤»

[01:39] <adu> :)

[01:39] <colomon> sorear: do you have any clue how I could be getting an action called over and over (infinite loop, it appears) on the same stretch of the matched grammar?

[01:40] *** s1n joined
[01:41] <sorear> colomon: outer rule is looping with <before> maybe?

[01:42] <sorear> NIECZA_TRACE=all might shed some light

[01:42] <colomon> oooo

[01:42] <colomon> does that require a different build or anything?

[01:44] <colomon> I am seeing something weird in the backtrace when I insert a die.

[01:46] <colomon> "Unknown trace option on"

[01:58] *** Guest50006 left
[02:04] *** leprevost joined
[02:05] *** leprevost left
[02:07] *** leprevost joined
[02:12] <colomon> sorear: also, one of these days we've got to run the niecza profiler on ABC -- it's taking a stupid long time running a part of the code I thought should be relatively straightforward.

[02:16] <sorear> colomon: all, not on

[02:16] <colomon> ooo, cool!

[02:17] <sorear> niecza doesn't have anything I can fairly call a profiler

[02:18] <colomon> trace is a LOT of information, yow

[02:19] <colomon> re profiling: I'd always assuming the grammar portion of things was slow, and converting the element array to lilypond was quick.  But I added say statements, and it appears the second portion is the slow bit.

[02:21] <adu> hmm

[02:21] <adu> http://pastebin.com/raw.php?i=sHDAe3wP

[02:21] <adu> how do I make it so that value => <z>?

[02:22] <adu> or should that be in the Actions, not the Grammar?

[02:26] <colomon> probably an action, I think?

[02:27] *** orafu left
[02:28] *** orafu joined
[02:31] *** zhutingting joined
[02:34] <colomon> sorear: is it possible that whatever endline my Mac is using is translating to two \v ?

[02:34] *** tokuhirom left
[02:35] <sorear> colomon: not impossible

[02:35] <sorear> Idon't think it's likely, but hey, if it's the last possibility left...

[02:35] *** avar left
[02:35] *** avar joined
[02:35] *** avar left
[02:35] *** avar joined
[02:36] <colomon> If I use \v, it goes into an apparently endless loop

[02:36] <colomon> If I use \v+, it works fine

[02:36] *** adu left
[02:48] *** estrai left
[02:48] *** araujo left
[02:49] *** estrai joined
[02:51] <colomon> may have a suitable workaround.  :)

[02:53] *** araujo joined
[02:53] *** araujo left
[02:53] *** araujo joined
[02:56] *** shinobicl joined
[03:01] *** zhutingting_ joined
[03:04] *** zhutingting left
[03:04] *** zhutingting_ is now known as zhutingting

[03:05] *** ponbiki joined
[03:07] *** adu joined
[03:12] *** aloha left
[03:18] *** shinobicl left
[03:24] *** aloha joined
[03:26] <colomon> maybe not.  :(

[03:43] <colomon> aha!  think I've finally got it worked out.

[03:56] *** benabik left
[03:56] *** ponbiki left
[04:05] *** thou joined
[04:10] <moritz> \o

[04:11] <moritz> sorear: re splitting substr and substr-rw, it's a way to make you pay only for what you use

[04:12] *** [particle] left
[04:20] <adu> what does this mean:

[04:20] <adu> Method 'nqpattr' not found for invocant of class 'NQPRoutine'

[04:24] *** derrazo_ joined
[04:28] <sorear> are you using nqp?

[04:34] <adu> no I'm using perl6

[04:34] <adu> rakudo

[04:34] <adu> anyways, I fixed the problem

[04:34] <adu> I don't remember how

[04:43] *** JCHEN joined
[04:49] <dalek> nqp: b6d1a40 | moritz++ | tools/build/PARROT_REVISION:

[04:49] <dalek> nqp: bump parrot version to 4.4.0

[04:49] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b6d1a40dc4

[04:50] <adu> oOo

[04:52] <adu> sorear: are you interested in how I got that error?

[04:55] *** derrazo_ left
[04:55] * moritz is

[04:57] *** cognominal joined
[04:58] <sorear> adu: No, I don't do rakudoguts

[04:58] <sorear> o/ cognominal

[05:00] *** cognominal___ left
[05:03] *** birdwindupbird joined
[05:07] <adu> moritz: I'm pretty sure it's <element> and <contents> in this grammar: http://pastebin.com/raw.php?i=mHh03tLF

[05:25] *** wolf2k_away left
[05:30] *** cognominal left
[05:30] *** cognominal joined
[05:41] *** adu left
[05:43] *** alim joined
[05:47] *** wtw joined
[05:49] *** [particle] joined
[05:50] *** kaleem joined
[05:54] *** adu joined
[06:15] *** NamelessTee joined
[06:21] *** quicoju left
[06:23] *** quicoju joined
[06:30] *** replore left
[06:34] *** adu left
[06:36] *** tyatpi left
[06:37] *** tyatpi joined
[06:52] *** lestrrat left
[06:54] *** lestrrat joined
[06:55] *** birdwindupbird left
[06:57] *** mucker joined
[07:01] *** birdwindupbird joined
[07:03] *** brrt joined
[07:09] *** NamelessTee left
[07:12] *** fhelmberger joined
[07:20] *** cognominal left
[07:21] *** cognominal joined
[07:23] *** alim left
[07:27] *** havenn joined
[07:46] <mikec_> morning

[07:47] <sorear> o/

[07:58] *** integral_ joined
[07:58] *** integral_ left
[07:58] *** integral_ joined
[08:03] *** integral left
[08:03] *** HarryS left
[08:03] *** HarryS joined
[08:04] *** goraki joined
[08:17] *** mucker left
[08:19] *** mucker joined
[08:21] <jnthn> mornin'

[08:21] <moritz> \o

[08:23] *** sh0ne joined
[08:24] *** sh0ne left
[08:28] <jnthn> moritz: I recall you did some work on restricting how far the Rat denominator could grow? 

[08:29] <moritz> jnthn: yes

[08:29] <moritz> r: say (1/2**63).WHAT

[08:29] <p6eval> rakudo 22c12b: OUTPUT«Rat()␤»

[08:29] <moritz> r: say ((1/2**63) * (1/2**63)).WHAT

[08:29] <p6eval> rakudo 22c12b: OUTPUT«Num()␤»

[08:30] <jnthn> moritz: OK, thought so...

[08:30] <moritz> but iirc it's not the constructor that checks it, but the DIVIDE_NUMBER routine in Rat.pm

[08:30] <lumi_> r: say("aaaa" ~~ /a ** {3}/)

[08:30] <p6eval> rakudo 22c12b: OUTPUT«=> <aaaa>␤␤»

[08:30] <moritz> the { } separator form is NYI

[08:30] <moritz> and it parses at as separated by a null string

[08:30] <moritz> known bug

[08:31] <lumi_> moritz: It's a separator?

[08:32] <moritz> r: say 'a,b,c' ~~ / a ** ','/

[08:32] <p6eval> rakudo 22c12b: OUTPUT«=> <a>␤␤»

[08:32] <moritz> hm

[08:32] <lumi_> moritz: I'm trying to do something like: / $<length>=[\d+] \s . ** $<length>/

[08:32] <moritz> lumi_: that doesn't work

[08:33] <lumi_> moritz: I noticed :) Is there some other way to do it?

[08:33] <moritz> (.+) <?{ +$<length> == $0.chars }>

[08:37] *** sergot joined
[08:37] <sergot> hi o/ !

[08:38] <tadzik> \o/

[08:44] *** dakkar joined
[08:51] <masak> good prenoon.

[08:53] *** thou left
[08:55] <sergot> \o/

[08:57] <tadzik> shark

[09:02] *** kresike joined
[09:03] *** havenn left
[09:15] *** jferrero joined
[09:19] <bbkr> good morning p6

[09:19] <tadzik> hey bbkr 

[09:19] <moritz> \o bbkr, tadzik, masak, sergot 

[09:20] *** aloha left
[09:20] *** aloha joined
[09:25] <goraki> bbkr: morning.

[09:25] <goraki> bbkr: remember that compile problem I had with nqp?

[09:25] *** daxim joined
[09:25] <bbkr> goraki: yes, what was the solution?

[09:25] <bbkr> (if you found one)

[09:26] <goraki> bbkr: It was a compile flag (which gets imported from parrot) causing an error in a 3rd party library (dyncall) that caused it.

[09:26] <goraki> -Werror=strict-prototypes

[09:27] <goraki> bbkr: you can avoid said problem if you just take the flag out of the Makefile in 3rdparty/dyncall

[09:28] *** pmurias joined
[09:29] <masak> <moritz> IMHO the only sane way is to make lvalue substr syntactic

[09:29] <masak> +1

[09:29] <bbkr> goraki: thanks for the info, i'll check if I can reproduce this error

[09:30] <moritz> masak: I have since then changed my opinion

[09:30] <moritz> masak: because it would require to special-case all known lvalue operations

[09:30] <moritz> masak: now I think that the only sane way is to split normal and lvalue substr into different routines

[09:30] <moritz> masak: which I've done

[09:30] <goraki> bbkr: if it's easier, you could just check with the dyncall library, I can reproduce with that if I manually add the flag after configure.

[09:31] <goraki> more details: https://github.com/perl6/nqp/issues/38

[09:31] <masak> moritz: yeah, I'm quickly reading up here in the backlog. :)

[09:31] <masak> not sure what I think right now.

[09:31] <masak> I'm glad we have substr-rw functionality, but "substr-rw" is not a pretty name. :)

[09:32] <moritz> but consistent with return-rw

[09:33] *** lestrrat left
[09:34] *** lestrrat joined
[09:34] <pmurias> moritz: how does spliting substr into to routines help?

[09:35] *** [particle]1 joined
[09:35] <moritz> pmurias: we can return a Proxy object from return-rw

[09:35] <moritz> pmurias: we could just always do that, but it would be very costly for such a common (and rather low-level) operation

[09:38] *** [particle] left
[09:38] <masak> moritz: indeed. and take-rw. I don't like the look of either of them. OTOH, I don't have any better suggestion. :/

[09:39] <tadzik> couldn't optimizer resolve FETCH/STORE in compile time?

[09:39] <jnthn> Not easily.

[09:40] <jnthn> I mean, you're moving the problem, not solving it.

[09:40] <tadzik> how so?

[09:40] *** JCHEN left
[09:40] <jnthn> In that you'd still need to do the l-value analysis you'd do if you were going to make substr(...) = ... syntactic.

[09:41] <jnthn> Also, Proxy is a bit weird

[09:41] <jnthn> It's a type that we don't really see

[09:41] <jnthn> nom: my $x = 'hello'; say substr-rw($x, 2, 2).WHAT

[09:41] <p6eval> rakudo 22c12b: OUTPUT«Str()␤»

[09:41] <moritz> r: say substr-rw("foo", 1, 1).WHAT

[09:41] <p6eval> rakudo 22c12b: OUTPUT«Str()␤»

[09:41] <jnthn> It's in the same niche as Scalar.

[09:42] <tadzik> ah

[09:42] <jnthn> So the declared return type of substr-rw is...Str :)

[09:42] <masak> it'd be totally fine with substr returning a Proxy only in the cases of '=' and '~~ s[] ='. that is, you can't store the thing in intermediate variables or anything.

[09:43] <masak> and I'd like for the mechanism behind that to be generalized to spec, so that users can define routines that do this.

[09:43] <jnthn> masak: And...a pony too?

[09:43] <masak> pony-rw

[09:43] * jnthn doesn't have a problem with the -rw suffix

[09:44] <jnthn> One immediate way to optimize if we *did* decide we can't live with it, though...

[09:44] <masak> I think I simply dislike dashes in CORE names.

[09:44] <jnthn> multi foo(Str $x is rw, ...) { ... } vs multi foo(Str $x, ...) { ... }

[09:45] <jnthn> The latter never returns a Proxy

[09:45] <jnthn> BUT it doesn't optimize most of the cases

[09:47] <masak> why not?

[09:48] <masak> and would my "immediate assignment" restriction above help?

[09:49] <masak> I think passing around Proxies will be very rare. the thing you want rw substr for is doing an immediate action on a substring.

[09:49] <jnthn> masak: Because often the thing you're substr-ing will come directly from a variable.

[09:51] <jnthn> The immediate assignment restriction is kinda violating the way we view context in Perl 6.

[09:51] <masak> agreed.

[09:51] <masak> it feels like it reintroduces the context thing a bit again.

[09:51] <jnthn> We don't pass context information down, we let things return objects that will do the right thing in the appropriate context.

[09:51] *** tyatpi left
[09:52] <masak> ok, so what I want seems self-contradictory. :/

[09:52] * masak wisely avoids throwing a tantrum and saying "fine, I'll do my own language where I don't have to abide by the Law of the Excluded Middle!"

[09:57] <bbkr> goraki: I cannot reproduce this error with strict-prototypes flag. HEAD rakudo builds just fine on 10.7.3 + Xcode 4.3.2

[09:57] <goraki> well, that's really weird.

[09:58] <goraki> bbkr: can you do me a favour and check nqp/3rdparty/dyncall/Makefile for that flag (-Werror=strict-prototypes)?

[09:59] <goraki> Just in case it's not there (which would seem weird, but anyway)

[09:59] *** kboga left
[10:00] <bbkr> goraki: which one? I have Makefile.M         Makefile.embedded  Makefile.generic   Makefile.psp

[10:01] <goraki> bbkr: You don't just have a Makefile in there (no extension) after the configuration?

[10:02] <bbkr> goraki: no

[10:03] <bbkr> I have Nmakefile

[10:04] <Timbus> doesnt xcode use clang instead of gcc?

[10:04] <bbkr> and grep on strict-prototypes in all files returns nothing

[10:05] <goraki> bbr: doh.

[10:05] <Timbus> o. mystery solved

[10:05] <goraki> it's the nqp/Makefile

[10:06] <goraki> Timbus: it uses llvm.

[10:06] <Timbus> yeah

[10:06] <bbkr> goraki: I have -Werror=strict-prototypes assigned to CFLAGS there

[10:06] <Timbus> but llvm uses clang or gcc frontends

[10:06] <Timbus> both of which have behaviour different to gcc! ;/

[10:06] <goraki> Timbus: but I think (this may be made up) it's their own version, and using the gcc frontend.

[10:07] <goraki> in fact I think they both there.

[10:07] <Timbus> it depends which option is selected i think

[10:07] <Timbus> yea

[10:07] <bbkr> I'll try another mac machine

[10:08] <goraki> bbkr: and from the rakudo dir, does this work?

[10:08] <goraki> gcc -o atest.tmp -Werror=strict-prototypes nqp/3rdparty/dyncall/dyncallback/dyncall_thunk.c

[10:09] <goraki> (because if it does then you don't seem to have my problem (-: )

[10:09] <bbkr> it does not, returns nqp/3rdparty/dyncall/dyncallback/dyncall_thunk_x64.c:28: error: function declaration isn't a prototype

[10:10] <bbkr> conclusion is that this file was not compiled during build process

[10:11] <goraki> that's odd, it always compiles for me. what arch are you running?

[10:12] *** alim joined
[10:13] <bbkr> Darwin bbkr.org 11.3.0 Darwin Kernel Version 11.3.0: Thu Jan 12 18:47:41 PST 2012; root:xnu-1699.24.23~1/RELEASE_X86_64 x86_64

[10:14] <bbkr> hackintosh with 64b extensions loaded, trying now on genuine mac...

[10:14] <goraki> right, okay.

[10:14] <goraki> cheers. (-:

[10:15] *** Guest90895 left
[10:16] <bbkr> argh, this is sooo slow. /me dreams about Ivy Bridge macs

[10:17] <goraki> bbkr: don't worry about it too much, I'm going to try and find another machine in my office that's got 10.7 + Xcode installed.

[10:18] *** zhutingting left
[10:24] <bbkr> another build successful. Darwin Pawels-iMac.local 11.4.0 Darwin Kernel Version 11.4.0: Mon Apr  9 19:32:15 PDT 2012; root:xnu-1699.26.8~1/RELEASE_X86_64 x86_64 i386

[10:26] <goraki> and the compiler is i686-apple-darwin11-llvm-gcc-4.2?

[10:40] <bbkr> gcc version 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.9.00)

[10:46] *** jaldhar joined
[10:51] <goraki> yep, same as me.

[10:51] <goraki> well, that's just weird.

[10:51] <goraki> bbkr++: Thanks for testing all this, no idea what's going on with my machine.

[11:05] *** bacek joined
[11:07] *** JimmyZ_ joined
[11:16] *** pmurias left
[11:18] *** pmurias joined
[11:22] *** JimmyZ__ joined
[11:24] *** JimmyZ_ left
[11:28] *** JimmyZ_ joined
[11:28] <moritz> r: class A { method foo() { }; method foo() { } }

[11:28] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Package 'A' already has a method 'foo' (did you mean to declare a multi-method?)␤»

[11:30] <dalek> rakudo/world-rethrow: c663f0f | moritz++ | src/ (2 files):

[11:30] <dalek> rakudo/world-rethrow: provide file and line number for method redeclaration errors

[11:30] <dalek> rakudo/world-rethrow: review: https://github.com/rakudo/rakudo/commit/c663f0fa34

[11:30] <moritz> this commit works, but feels borderline to the very hacky side

[11:31] <moritz> reviews and suggestions for improvements are very welcome

[11:31] *** JimmyZ__ left
[11:34] <dalek> tablets: 02cf1e9 | (Herbert Breunung)++ | docs/index.txt:

[11:34] <dalek> tablets: polish comments in index

[11:34] <dalek> tablets: review: https://github.com/perl6/tablets/commit/02cf1e9398

[11:34] <dalek> tablets: 2fea6e8 | (Herbert Breunung)++ | docs/index.txt:

[11:34] <dalek> tablets: update status

[11:34] <dalek> tablets: review: https://github.com/perl6/tablets/commit/2fea6e848c

[11:36] <jnthn> moritz: Use HOP

[11:37] <moritz> jnthn: a world method that takes a callable, and tries to execute it?

[11:37] <jnthn> do_errorable(-> { $obj.HOW."$meta_method_name"($obj, $name, $code_object) });

[11:37] <JimmyZ_> r: rethrow

[11:37] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&rethrow' called (line 1)␤»

[11:37] <jnthn> And do_errorable (er, name it better :)) is used to wrap up all the things like this.

[11:38] <jnthn> moritz: Basically, yeah.

[11:38] <jnthn> moritz: Well, it can even be a sub.

[11:38] <moritz> well, if we use it both from actions and the grammar, a method in World seems like the right thing to do

[11:39] <jnthn> moritz: I know we're sometimes calling straight into code from the actions at compile time, but I see that as a bit on an anit-pattern.

[11:39] <jnthn> *anti

[11:39] <jnthn> *of

[11:39] <moritz> :(

[11:39] <JimmyZ_> perl6 can't rethrow exception in CATCH block?

[11:39] <jnthn> I'd rather all the boundary-crossing places happen in World.

[11:40] <moritz> jnthn: Perl 6 can. NQP can not

[11:40] <moritz> erm, meant JimmyZ_ 

[11:40] <moritz> sorry

[11:40] <jnthn> If that means a $*W.run_code($code_object), that's preferable to me.

[11:40] <jnthn> Er, I guess it'd pass in $/ too :)

[11:41] <jnthn> And the do_errorable probably needs $/ also.

[11:41] <JimmyZ_> hmm. I always think NQP code is Perl 6 code

[11:41] <moritz> yes, the line number is the entire point :-)

[11:41] <jnthn> Right :)

[11:42] *** jaldhar left
[11:44] *** JimmyZ__ joined
[11:45] *** mucker left
[11:47] *** JimmyZ_ left
[11:48] *** JimmyZ__ left
[11:49] <moritz> jnthn: how does Proxy gets its magic?

[11:49] <moritz> jnthn: I mean, what marks it as a container type?

[11:50] *** JimmyZ_ joined
[11:50] <jnthn> moritz: See its setup code in BOOTSTRAP

[11:50] <jnthn> moritz: But basically, it gets a container spec.

[11:51] <moritz> ah, the pir::set_container_spec__vPPsP

[11:52] *** JimmyZ_ left
[11:53] *** JimmyZ_ joined
[11:54] <jnthn> moritz: Yes.

[11:57] *** JimmyZ__ joined
[12:01] *** JimmyZ_ left
[12:01] *** fgomez left
[12:01] *** fgomez joined
[12:03] *** JimmyZ_ joined
[12:05] *** JimmyZ__ left
[12:06] *** JimmyZ_ left
[12:07] *** JimmyZ_ joined
[12:07] <masak> jnthn++ # knows many things about Rakudo internals

[12:09] *** JimmyZ_ left
[12:11] *** skids left
[12:25] *** JimmyZ_ joined
[12:33] <flussence> p6: class A { has %.b }; my $a = A.new(b => {foo => 1, bar => 2, baz => 3}); $a.b<foo baz>

[12:33] *** plobsing left
[12:33] <p6eval> pugs, rakudo 22c12b, niecza v17-4-ge5b869e:  ( no output )

[12:33] <flussence> p6: class A { has %.b }; my $a = A.new(b => {foo => 1, bar => 2, baz => 3}); $a.b<foo baz>.perl.say

[12:33] <p6eval> rakudo 22c12b, niecza v17-4-ge5b869e: OUTPUT«(1, 3)␤»

[12:33] <p6eval> ..pugs: OUTPUT«\(1, 3)␤»

[12:34] <flussence> I just had to do that (obj-hashref-arrayslice) in $dayjob perl 5 code, and it never gets any easier to remember :)

[12:35] *** crab2313 joined
[12:37] *** crab2313 left
[12:39] * masak .oO( what's difficult about it, it's just $a->b()->{qw<foo baz>} )

[12:39] <moritz> don't you need an @ somewhere when you return a list?

[12:40] <moritz> eval: sub a() { {a => 1, b => 2 } }; my $obj = bless {}; [ $obj->a()->{qw/a b/} ]

[12:40] <buubot_backup> moritz: [undef]

[12:40] <mikec_> hmm

[12:40] <moritz> eval: sub a() { {a => 1, b => 2 } }; my $obj = bless {}; [ @{$obj->a()}{qw/a b/} ]

[12:40] <buubot_backup> moritz: [1,2]

[12:41] *** stepnem left
[12:43] *** stepnem joined
[12:45] *** pernatiy joined
[12:48] *** ponbiki joined
[12:48] <lumi_> moritz: I still can't get .**$length (conceptually, actually using your suggecstion) to work

[12:49] *** pmurias_ joined
[12:49] *** pmurias_ left
[12:50] <moritz> r: say '2 abcde' ~~ / (\d+) \s (.+) <?{ $1.chars == $0 }> /

[12:50] <p6eval> rakudo 22c12b: OUTPUT«#<failed match>␤»

[12:50] <moritz> r: say '2 abcde' ~~ / (\d+) \s (.+) <?{ say $/; $1.chars == $0 }> /

[12:50] <p6eval> rakudo 22c12b: OUTPUT«=> <2 abcde>␤ 0 => <2>␤ 1 => <abcde>␤␤=> <2 abcde>␤ 0 => <2>␤ 1 => <abcde>␤␤=> <2 abcde>␤ 0 => <2>␤ 1 => <abcde>␤␤=> <2 abcde>␤ 0 => <2>␤ 1 => <abcde>␤␤=> <2 abcde>␤ 0 => <2>␤ 1 => <abcde>␤␤#<failed match>␤»

[12:50] <moritz> r: say '2 abcde' ~~ / (\d+) \s (.+) <?{ say ~$/; $1.chars == $0 }> /

[12:50] <p6eval> rakudo 22c12b: OUTPUT«2 abcde␤2 abcde␤2 abcde␤2 abcde␤2 abcde␤#<failed match>␤»

[12:51] <moritz> oh, it seems that $/ isn't updated often enough

[12:51] <moritz> r: say '2 abcde' ~~ / (\d+) \s (.+) {} <?{ say ~$/; $1.chars == $0 }> /

[12:51] <p6eval> rakudo 22c12b: OUTPUT«2 abcde␤2 abcde␤2 abcde␤2 abcde␤2 abcde␤#<failed match>␤»

[12:52] <moritz> r: say '2 abcde' ~~ / (\d+) \s (.+) {} <?{ say ~$1; $1.chars == $0 }> /

[12:52] <p6eval> rakudo 22c12b: OUTPUT«abcde␤abcde␤abcde␤abcde␤abcde␤#<failed match>␤»

[12:52] *** pmurias left
[12:53] *** PacoAir joined
[12:58] <lumi_> moritz: So it's not possible now?

[12:59] <moritz> lumi_: I wouldn't know how

[12:59] *** JimmyZ__ joined
[13:00] <lumi_> moritz: I'll give it up for now then

[13:00] <moritz> lumi_: one more idea...

[13:01] <moritz> r: say '2 abcde' ~~ / (\d+) \s (.+) <at($0.to + 1 + $0)> /

[13:01] <p6eval> rakudo 22c12b: OUTPUT«Method 'to' not found for invocant of class 'Any'␤  in regex <anon> at /tmp/Bn2Lao7Sxq:1␤  in method ACCEPTS at src/gen/CORE.setting:9245␤  in block <anon> at /tmp/Bn2Lao7Sxq:1␤␤»

[13:01] <moritz> ok, not working either

[13:02] *** JimmyZ_ left
[13:03] *** [particle]1 is now known as [particle]

[13:06] *** snearch joined
[13:06] *** Psyche^ joined
[13:06] *** crab2313 joined
[13:09] *** Patterner left
[13:09] *** Psyche^ is now known as Patterner

[13:09] <[Coke]> ZOMG it's [particle]!

[13:10] <[particle]> howdy, [Coke]!

[13:10] <colomon> o/

[13:10] <moritz> \o [particle] 

[13:12] <PerlJam> [particle]: greetings!  how's life?

[13:13] <[particle]> life is great, thanks for asking.

[13:13] <[particle]> how's everyone here? it's been a long item.

[13:13] *** crab2313 left
[13:13] <[particle]> er... time.

[13:13] *** JimmyZ_ joined
[13:14] <moritz> same of faces, many new faces :-)

[13:14] <moritz> s/of/old/

[13:14] <moritz> and I still can't type properly :-)

[13:14] <[particle]> i wouldn't know anything about that, myself :)

[13:14] *** JimmyZ__ left
[13:15] <moritz> and I have a local patch for the 'lazy' statement prefix here, but it seems to trigger evaluation in basically every possible situation :/

[13:16] <[particle]> so, not very lazy.

[13:16] <moritz> what works is

[13:16] <moritz> my $x := lazy say 'foo';

[13:16] <moritz> # doesn't say foo

[13:17] <moritz> but if you use assignment, it does

[13:17] <moritz> and if you pass it to a routine, it does too, because the type check needs the actual value

[13:19] *** JimmyZ_ left
[13:20] *** grondilu joined
[13:21] <grondilu> p6: say "ok" if (class Foo {}).bless([]) ~~ Foo; 

[13:21] <p6eval> niecza v17-4-ge5b869e: OUTPUT«ok␤»

[13:21] <p6eval> ..rakudo 22c12b:  ( no output )

[13:21] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&class"␤    at /tmp/Hp0Kv1WWhR line 1, column 14-26␤»

[13:22] <moritz> n: say "ok" if (class Foo {}).bless(1) ~~ Foo

[13:22] <p6eval> niecza v17-4-ge5b869e: OUTPUT«ok␤»

[13:22] <moritz> grondilu: I'd guess that niecza simply ignores the first argument to bless

[13:22] <grondilu> Why?  In Perl6 you can bless pretty much anything, can't you?

[13:23] <grondilu> p6: say "ok" if (class Foo {}).bless(Mu) ~~ Foo; 

[13:23] <p6eval> niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Nominal type check failed in binding '' in 'Mu.bless'; got Mu, needed Any␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Mu.bless @ 1) ␤  at /tmp/eZXvQysiNg line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (…

[13:23] <p6eval> ..rakudo 22c12b:  ( no output )

[13:23] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&class"␤    at /tmp/jaPb2M5iJz line 1, column 14-26␤»

[13:23] <grondilu> n: say "ok" if (class Foo {}).bless(Mu.new) ~~ Foo; 

[13:23] <p6eval> niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Nominal type check failed in binding '' in 'Mu.bless'; got Mu, needed Any␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Mu.bless @ 1) ␤  at /tmp/gh0RkMQUTW line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (…

[13:25] *** tokuhirom joined
[13:25] *** snearch left
[13:25] <grondilu> Not related to above:  why can't packages do inheritance?  I thought classes were for instanciation, but that I could use packages (or modules) for inheritance, just as in Perl 5.

[13:26] <masak> grondilu: the first argument to bless is the "underlying storage" for the object. usually that's an opaque object, but I guess one could use hashes and arrays too, like in Perl 5.

[13:26] <masak> grondilu: packages and subs don't have the mechanism for method resolution order that inheritance would require.

[13:27] <masak> grondilu: you can always simulate inheritance in a package by wiring it up manually.

[13:28] <moritz> what would inheritance in a package mean?

[13:29] <PerlJam> kinda sounds like role composition without the conflict resolution

[13:29] <jnthn> Maybe part of the confusion here is that in Perl 5 package really means "a thingy that holds symbols", whereas in Perl 6, the name of the package actually refers to a type object, and .WHO is more like the traditional Perl 5 meaning of package. 

[13:29] *** tokuhirom left
[13:31] <masak> moritz: I guess it would mean that dispatch to any ('our') subs you didn't define in the package falls back to the package inherited from.

[13:31] <dalek> rakudo/lazy: 18f9e41 | moritz++ | / (5 files):

[13:31] <dalek> rakudo/lazy: first shot at "lazy" statement prefix

[13:31] <dalek> rakudo/lazy: review: https://github.com/rakudo/rakudo/commit/18f9e41073

[13:31] *** tokuhirom joined
[13:32] <moritz> importing and reexporting would do that

[13:33] <moritz> jnthn: I first experimented with making LazyScalar not inherit from Proxy, and instead install static FETCH/STORE methods and store the payload and the code object as attributs... looped infinitely, and I didn't manage to debug it

[13:36] <jnthn> r: package Foo { our sub x() { say 1 } }; package Bar { our sub y() { say 2 } }; Bar.WHO does role { has $.prototype is rw; method at_key($key) { self.exists($key) ?? nextsame() !! $.prototype.WHO.at_key($key) } }; Bar.WHO.prototype = Foo; &Bar::x(); &Bar::y();

[13:36] <p6eval> rakudo 22c12b: OUTPUT«1␤2␤»

[13:38] <jnthn> moritz: Will peek at the patch.

[13:38] <jnthn> moritz: Though, probably I should glance the spec for lazy too...

[13:39] <grondilu> come on guys, give inheritance to packages in the language instead of these obscure code tricks.

[13:39] <jnthn> grondilu: You've totally missed the point.

[13:39] <grondilu> ahh

[13:39] <grondilu> sorry

[13:39] <jnthn> Inheritance is not a property of "packages" in the sense that I think you're thinking about them :)

[13:39] <grondilu> I meant: "like in Perl 5"

[13:40] <jnthn> Inheritance is something classes do, and it's the meta-object that does it. 

[13:40] <jnthn> Yes, that's what I was trying to explain. Things in Perl 6 ain't like in Perl 5 in this area.

[13:40] <moritz> S04-statements/lazy.t expects that passing around the result of a 'lazy' keeps it lazy. I don't see how that can work together with type checks

[13:40] <jnthn> moritz: Me either. :)

[13:40] <moritz> grondilu: if you want to inheritance like in perl 5, use classes.

[13:40] <grondilu> well I thought instanciation was something classes do, not inheritance.  Inheritance is not the main point.

[13:41] <moritz> well, you can still use classes if you want inheritance, even if you don't want instantiation

[13:41] <grondilu> but I'll have to use methods, and their syntax is a bit heavier.

[13:41] <grondilu> :(

[13:42] <moritz> then maybe what you want is importing with re-exporting

[13:42] <moritz> which is NYI, but probably not too hard to do

[13:43] <grondilu> indeed this is missing too.

[13:43] <jnthn> moritz: Passing a lazy somewhere that wants to type check is a fairly deep problem.

[13:44] *** skids joined
[13:44] *** tyatpi joined
[13:45] <grondilu> r: package Foo { our sub talk { say "hi" } }; use Foo q(talk);  

[13:45] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Could not find sub &talk␤»

[13:45] <grondilu> r: package Foo { our sub talk { say "hi" } }; use Foo <talk>;  

[13:45] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Could not find Foo in any of: /home/p6eval/.perl6/lib, /home/p6eval/nom-inst1/lib/parrot/4.3.0-devel/languages/perl6/lib␤»

[13:45] <grondilu> r: module Foo { our sub talk { say "hi" } }; use Foo <talk>;  

[13:45] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Could not find Foo in any of: /home/p6eval/.perl6/lib, /home/p6eval/nom-inst1/lib/parrot/4.3.0-devel/languages/perl6/lib␤»

[13:45] <grondilu> ahh nevermind

[13:46] <moritz> r: module Foo { sub talk is export { say 'hi' } }; import Foo; talk()

[13:46] <p6eval> rakudo 22c12b: OUTPUT«hi␤»

[13:48] <grondilu> I don't understand.  So it is implemented, isnt'it?

[13:48] <moritz> importing is implemented, yes

[13:48] <moritz> I did that two weeks ago, iirc

[13:48] <moritz> but what's not implemented is re-exporting

[13:49] <moritz> r: module A { sub talk is export { say 'hi' } }; module B { import A }; import B; talk

[13:49] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Method 'ast' not found for invocant of class 'Undef'␤»

[13:49] <moritz> ooh, "fun"

[13:50] <grondilu>  r: module A { sub talk is export { say 'hi' } }; module B { import A }; import B; B::talk

[13:50] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Method 'ast' not found for invocant of class 'Undef'␤»

[13:50] <grondilu>  n: module A { sub talk is export { say 'hi' } }; module B { import A }; B::talk

[13:50] <p6eval> niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤Action method statement_control:import not yet implemented at /tmp/qoG5fFEkHa line 1:␤------> ort { say 'hi' } }; module B { import A ⏏}; B::talk␤␤Unhandled exception: Unable to resolve method statement_lev…

[13:52] <moritz> r: module A { sub talk is export { say 'hi' } }; module B { import A };

[13:52] <p6eval> rakudo 22c12b: OUTPUT«===SORRY!===␤Method 'ast' not found for invocant of class 'Undef'␤»

[13:53] <dalek> roast: a2275c3 | moritz++ | S04-statements/lazy.t:

[13:53] <dalek> roast: [lazy.t] make much more realisitic

[13:53] <dalek> roast: 

[13:53] <dalek> roast: * if you want to carry stuff around without evaluating, you need binding

[13:53] <dalek> roast: * passing stuff to routines type-checks, thus cannot be lazy

[13:53] <dalek> roast: review: https://github.com/perl6/roast/commit/a2275c3d4c

[13:54] <lumi_> r:  say("2 abcde" ~~ regex  { (\d+)\s* :my $p; { $p = $/.CURSOR.pos} (\w *)  <?at: $p+$0>})

[13:54] <p6eval> rakudo 22c12b: OUTPUT«=> <2 ab>␤ 0 => <2>␤ 1 => <ab>␤␤»

[13:55] <moritz> lumi_++

[13:56] <dalek> rakudo/lazy: e1b8b12 | moritz++ | / (3 files):

[13:56] <dalek> rakudo/lazy: smally cleanups for "lazy"

[13:56] <dalek> rakudo/lazy: 

[13:56] <dalek> rakudo/lazy: * do not evaluate the thunk when LazyScalar is being assigned to

[13:56] <dalek> rakudo/lazy: * update ChangeLog

[13:56] <dalek> rakudo/lazy: * run tests

[13:56] <dalek> rakudo/lazy: review: https://github.com/rakudo/rakudo/commit/e1b8b1292e

[13:56] <lumi_> moritz: Thanks for the pointers :)

[13:56] <moritz> lumi_: you're welcome. I really hope we'll support ** {} soon.

[13:57] <jnthn> moritz++ # taking on lazy

[13:57] <lumi_> moritz: btw, ':my $p = $.pos' and basically every other variation I tried blows up weirdly

[13:58] <lumi_> r:  say("2 abcde" ~~ regex  { (\d+)\s* :my $p = $.pos; (\w *)  <?at: $p+$0>})

[13:58] <p6eval> rakudo 22c12b: OUTPUT«Method 'item' not found for invocant of class 'Integer'␤  in regex <anon> at /tmp/qo9_SvnVl0:1␤  in method ACCEPTS at src/gen/CORE.setting:9245␤  in block <anon> at /tmp/qo9_SvnVl0:1␤␤»

[13:58] <moritz> lumi_: that doesn't quite surprise me

[13:59] <lumi_> I don't even understand what was trying to happen there

[13:59] <moritz> $.pos is short for self.pos.item

[13:59] <moritz> but $.pos seems to return a parrot integer

[13:59] <moritz> so it blows up, because parrot's int doesn't know how to itemize itself in a Perl 6 way :-)

[14:00] <jnthn> Missing perl6ize_type I guess

[14:01] <PerlJam> why is  ** {} not supported exactly?

[14:02] <moritz> because nobody implemented it

[14:02] <moritz> I don't think there's a big blocker

[14:02] <PerlJam> ok

[14:03] <PerlJam> as long as there are not archetectural changes that are required, I might see about implementing it later today.

[14:03] <PerlJam> s/not/no/

[14:03] <jnthn> Step 1 is to rip out ** still supporting seperators :)

[14:04] <jnthn> We've warned about that in multiple Star releases by now, so it's fine to remove.

[14:05] <moritz> jnthn: fwiw I'm now confident that the 'lazy' implementation can't be made much more robust without huge changes; so if you're happy with the implementation, we can merge (but don't hurry)

[14:05] *** benabik joined
[14:06] <tadzik> release is tomorrow:)

[14:06] <jnthn> moritz: I don't see the way you've done it disrupting anything else, it's sufficiently contained to merge.

[14:06] <jnthn> moritz: I suspect we'll probably end up with some spec tweaks from TimToady++ on this at some point.

[14:07] <jnthn> moritz: In the meantime, having at least a first guess at how it'll work is useful.

[14:07] <moritz> which reminded me that I wanted to tweak substr/substr-rw in the specs

[14:08] *** JimmyZ joined
[14:12] *** grondilu left
[14:13] *** b1rkh0ff joined
[14:14] *** b1rkh0ff left
[14:15] *** b1rkh0ff joined
[14:15] *** b1rkh0ff left
[14:15] *** b1rkh0ff joined
[14:15] <PerlJam> Does nqp know about % in regex yet?

[14:16] *** tokuhirom left
[14:16] <dalek> rakudo/nom: 18f9e41 | moritz++ | / (5 files):

[14:16] <dalek> rakudo/nom: first shot at "lazy" statement prefix

[14:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/18f9e41073

[14:16] <dalek> rakudo/nom: e1b8b12 | moritz++ | / (3 files):

[14:16] <dalek> rakudo/nom: smally cleanups for "lazy"

[14:16] <dalek> rakudo/nom: 

[14:16] <dalek> rakudo/nom: * do not evaluate the thunk when LazyScalar is being assigned to

[14:16] <dalek> rakudo/nom: * update ChangeLog

[14:16] <dalek> rakudo/nom: * run tests

[14:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e1b8b1292e

[14:16] <dalek> rakudo/nom: a6515f0 | moritz++ | / (7 files):

[14:16] <dalek> rakudo/nom: Merge branch 'lazy' into nom

[14:16] <moritz> PerlJam: I think qregex knowss about it

[14:16] <jnthn> PerlJam: yes

[14:16] <jnthn> Well, what moritz said

[14:16] <jnthn> NQP itself doesn't

[14:16] <jnthn> QRegex implements it

[14:16] <PerlJam> gotcha

[14:16] <jnthn> NQP will know it after qbootstrap is done.

[14:17] *** REPLeffect left
[14:17] *** tokuhirom joined
[14:20] <PerlJam> looks to me like ** grokking separators is because it inherits that behavior from qregex.  If I remove that from qregex is there anything special I need to do for rakudo to use it other than just recompiling nqp/rakudo?

[14:21] <PerlJam> ("it" == "the modified qregex")

[14:21] <moritz> well, if you want to support  ** { 2..3 }  and the block is parsed as a Perl 6 block, you'll get a Perl 6 range back

[14:21] <moritz> you won't teach nqp how to handle Perl 6 ranges

[14:21] <moritz> so you'll need some work on the rakudo end too

[14:22] <jnthn> Aye

[14:22] <PerlJam> aye.

[14:22] <jnthn> Just the removal should not need any Rakudo work though, afaik.

[14:23] <PerlJam> removing **<sep> looks simple enough that I may just do that now  :)

[14:29] *** PacoAir left
[14:31] <PerlJam> Just to make sure I'm not crazy:   https://gist.github.com/2710781   

[14:31] <PerlJam> Looks good?

[14:31] <PerlJam> tests all seem to pass (aside from the bigint tests that always seem to fail)

[14:32] *** kaleem left
[14:32] <moritz> looks reasonable

[14:33] <dalek> nqp: 7df35de | duff++ | src/QRegex/P6Regex/ (2 files):

[14:33] <dalek> nqp: Remove **<sep>

[14:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7df35de3e6

[14:35] *** plutoid joined
[14:38] <moritz> t/qregex/01-qregex.t (Wstat: 0 Tests: 707 Failed: 6) Failed tests:  212-214, 216-218

[14:40] <moritz> not ok 212 - ** with a term

[14:40] <moritz> # ERROR: Quantifier quantifies nothing at line 1, near " \\,$"

[14:40] <PerlJam> huh ..  how did you run that test?  Does not "make test" run them all?

[14:41] <moritz> PerlJam: I think it only runs them all if the previous tests succeeded :/

[14:41] <moritz> PerlJam: but 'make qregex-test' should get you there

[14:41] <PerlJam> yeah, already figured that out :)

[14:42] <moritz> but it's a simple enough patch, one can simply remove the lines from t/qregex/rx_quantifiers

[14:42] <PerlJam> yep

[14:43] <Ulti> neat rakudo 2011.07 is on Ubuntu 12.04 

[14:43] <moritz> that's the last release before nom

[14:43] <Ulti> yeah :/

[14:46] <moritz> PerlJam: wanna do it, or should I?

[14:46] <dalek> nqp: ee757db | duff++ | t/qregex/rx_quantifiers:

[14:46] <dalek> nqp: Remove regex tests for **<sep>

[14:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ee757db8a9

[14:46] <PerlJam> :-)

[14:47] <PerlJam> (I was busy making sure I ran *all* of the tests this time)

[14:47] <moritz> :-)

[14:48] <dalek> nqp: 3196005 | moritz++ | t/qregex/rx_modifiers:

[14:48] <dalek> nqp: untodo passing qregex tests

[14:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3196005b69

[14:48] <lumi_> https://github.com/lumimies/git-fe-parser -- That's what I was making

[14:51] <masak> lumi_: nice! lumi_++

[14:53] *** xinming left
[14:56] <PerlJam> What does "perl6_type_check_return_value" do exactly?  Or how does it work?

[14:56] <PerlJam> (I'm trying to figure out how to guarantee the return value of the block is either an Int or a Range)

[14:57] *** alim left
[14:57] <jnthn> PerlJam: It's the thing we call at the end of a block to chekc the thing it's about to return is of teh right type.

[14:58] <jnthn> PerlJam: It's not what you're looking for.

[14:58] <jnthn> PerlJam: You want to just do a normal type check for that.

[14:59] <PerlJam> What does a "normal type check" look like in Actions.pm ?

[14:59] <PerlJam> call isa?

[15:00] <PerlJam> I mean, would I insert PAST::Ops to call isa to check either Int or Range?

[15:01] <jnthn> :pirop('type_check__IPP')

[15:01] <jnthn> First child is the thing you have, second is the type

[15:01] <jnthn> Get the type with $*W.get_ref($*W.find_symbol(['Int']))

[15:01] <PerlJam> nqp::istype  :-)

[15:01] *** benabik left
[15:01] <jnthn> Yes, it's what nqp::istype compiles down to.

[15:02] * PerlJam is slowly getting it.

[15:02] <jnthn> But...is the block not evaluated at runtime?

[15:02] <jnthn> x ** { Bool.pick ?? 10 !! 5..42 } /

[15:02] <PerlJam> right, which is why I was thinking I'd need to insert PAST ops to do the type check

[15:03] <jnthn> Yes :)

[15:05] *** NamelessTee joined
[15:05] *** plutoid left
[15:06] <sergot> nom: say [x] 1, 2, 2;

[15:06] <p6eval> rakudo 22c12b: OUTPUT«1111␤»

[15:07] *** wtw left
[15:08] <masak> nom: sub multiply(Int $a, Int $b) { (1 x $a x $b).chars }; say multiply 4, 5

[15:08] <p6eval> rakudo 22c12b: OUTPUT«20␤»

[15:08] <masak> :P

[15:08] <tadzik> aah :)

[15:08] <sergot> :)

[15:08] <tadzik> it's like finding prime numbers with regexes

[15:10] <PerlJam> you could really confuse people by making that first number 0 instead of 1  ;)

[15:10] *** s1n left
[15:10] <masak> I thought of making it "X" or the Unicode character for a chicken or something.

[15:11] <PerlJam> .u chicken

[15:11] <phenny> PerlJam: Sorry, no results for 'chicken'.

[15:11] <PerlJam> My incredulty was justified

[15:12] <sergot> brb

[15:12] *** sergot left
[15:12] <tadzik> phenny: en pl "incredulty"?

[15:12] <phenny> tadzik: "incredulty" (en to pl, translate.google.com)

[15:14] <masak> PerlJam: phenny doesn't do recent Unicode versions.

[15:14] <tadzik> FRONT FACING BABY CHICK

[15:14] *** sergot joined
[15:14] <masak> tadzik: "incredulity" jest wtedy, gdy coś nie wierzę

[15:15] <tadzik> ha, that makes sense :)

[15:15] <tadzik> phenny: "niewiarygodne"?

[15:15] <phenny> tadzik: "incredible" (pl to en, translate.google.com)

[15:15] <masak> "credo" is Latin for "I believe"

[15:15] <tadzik> phenny: "nie do wiary"?

[15:15] <phenny> tadzik: "unbelievable" (pl to en, translate.google.com)

[15:15] <tadzik> somewhat

[15:17] *** skids left
[15:18] *** skids joined
[15:23] <daxim> https://plus.google.com/108373812962355405651/posts/Et5tdx8iTh4

[15:23] *** benabik joined
[15:25] *** birdwindupbird left
[15:26] *** s1n joined
[15:31] *** JimmyZ left
[15:31] *** thou joined
[15:36] *** REPLeffect joined
[15:39] *** KyleHa joined
[15:40] <KyleHa> Hello #perl6.

[15:41] <masak> KyleHa! \o/

[15:41] <KyleHa> Hiya Masak!

[15:42] <KyleHa> I'm looking at S04 and wondering what a "control exception" is that the the CONTROL block catches. Is it just whatever "warn" spits out, or is there more to it than that?

[15:42] *** s1n left
[15:45] <moritz> return, next, redo, last all work through control exceptions

[15:46] <KyleHa> So if I'm using a CONTROL block to catch warnings, I could catch more than that? How can I tell what I'm intercepting?

[15:47] <moritz> I haven't done any work on control exceptions, so there's no nice interface for it

[15:47] <moritz> though src/core/Exceptions.pm does some catching and inspecting of them at a low level

[15:50] *** spider-mario joined
[15:57] *** s1n joined
[15:58] *** REPLeffect left
[15:58] *** mikemol joined
[15:59] *** REPLeffect joined
[16:00] *** alim joined
[16:02] *** s1n left
[16:05] *** alim left
[16:08] *** brrt left
[16:11] <masak> blog post! \o/ http://strangelyconsistent.org/blog/t4-hex-puzzle

[16:17] *** s1n joined
[16:18] *** pernatiy left
[16:19] *** leprevost left
[16:19] *** derrazo joined
[16:20] *** derrazo left
[16:21] <jnthn> masak: Looks like a little mojibake in http://strangelyconsistent.org/p6cc2011/t4/edgar/

[16:21] *** icwiener joined
[16:26] <masak> indeed. must be the encoding of the HTML that's wrong. checking.

[16:28] *** s1n left
[16:28] <geekosaur> interestingly, the second file is correct, it's only the first that has the iso8859 vs. utf8 weirdie in the name

[16:30] *** birdwindupbird joined
[16:30] <masak> yeah. that's probably a clue to what's going on. I remember utf-8-converting both, though.

[16:38] <TimToady> "Here's an example:" used to show unbalanced html with a .png, now I just get a blank space without a pic

[16:39] *** tokuhirom left
[16:40] <TimToady> nevermind, ^R fixed it

[16:41] *** kresike left
[16:43] *** daxim left
[16:43] *** flussence left
[16:44] *** s1n joined
[16:45] <masak> yeah, I did some klutz updates before doing the correct one.

[16:46] *** PacoAir joined
[16:48] <masak> moritz++ for prodding me along on this one. it's taken some time due to $work and a wish for complete cover of all the things.

[16:52] *** ponbiki left
[16:53] <masak> encoding bug fixed in http://strangelyconsistent.org/p6cc2011/t4/edgar/ -- jnthn++ for reporting.

[16:53] <masak> that file had simply been converted from latin-1 to utf8 twice by some overzealous p6cc organizer.

[16:55] *** s1n left
[16:55] <moritz> "doppelt hält besser"

[16:57] *** derrazo joined
[16:58] <masak> :P

[17:02] *** birdwindupbird left
[17:02] *** goraki left
[17:03] *** birdwindupbird joined
[17:05] *** dakkar left
[17:05] *** crab2313 joined
[17:05] *** kboga joined
[17:09] *** s1n joined
[17:14] <sorear> good * #perl6

[17:15] *** birdwindupbird left
[17:17] *** birdwindupbird joined
[17:17] *** thelazydeveloper joined
[17:17] *** s1n left
[17:18] <colomon> \o

[17:20] *** fgomez left
[17:31] *** s1n joined
[17:34] <pmichaud> good afternoon, #perl6

[17:35] *** Chillance joined
[17:35] <pmichaud> what in the world is a "lazy scalar"?

[17:35] <PerlJam> one that lays around all day doing nothing

[17:36] <[Coke]> ho, pmichaud.

[17:37] <moritz> pmichaud: it's what the 'lazy' statement prefix returns

[17:37] <pmichaud> why doesn't the 'lazy' prefix simply return a list?

[17:38] <moritz> because it doesn't preserve the return type

[17:38] <pmichaud> I don't understand.

[17:38] <PerlJam> sounds like a thunk

[17:39] <moritz> r: my $x := lazy 'foo'; say $x.WHAT

[17:39] <p6eval> rakudo a6515f: OUTPUT«Str()␤»

[17:39] <moritz> if it returned a List, that wouldn't say Str()

[17:39] <pmichaud> when would a Str() be lazy?

[17:40] <moritz> it's not the Str that is lazy

[17:40] <moritz> it's the container

[17:40] <pmichaud> why are containers lazy?  is there some discussion on this I should read in backscroll?

[17:40] <moritz> r: my $x := lazy { say 'not yet executed'; "foo" }; say 1; say $x

[17:40] <p6eval> rakudo a6515f: OUTPUT«1␤not yet executed␤foo␤»

[17:40] <pmichaud> oh, that's .... wrong.

[17:41] <pmichaud> at least that looks really wrong to me.

[17:41] <masak> r: my $lazy-scalar = gather take foo; sub foo { say "OH HAI"; take 42 }; say "look, it's lazy!"; say $lazy-scalar

[17:41] <p6eval> rakudo a6515f: OUTPUT«look, it's lazy!␤OH HAI␤42 0␤»

[17:41] <masak> oops

[17:41] <masak> r: my $lazy-scalar = gather take foo; sub foo { say "OH HAI"; 42 }; say "look, it's lazy!"; say $lazy-scalar

[17:41] <p6eval> rakudo a6515f: OUTPUT«look, it's lazy!␤OH HAI␤42␤»

[17:41] <pmichaud> that looks like a "thunk" to me, not laziness.

[17:41] <moritz> what's the difference?

[17:42] <pmichaud> laziness has always been (to my mind) something associated with list evaluation

[17:42] <moritz> but it doesn't need to

[17:42] <moritz> in haskell, laziness isn't limited to lists

[17:42] <geekosaur> ...laziness *is* a thunk, last I checked

[17:42] <pmichaud> I think what has been defined here is a conflation of two separate concepts.

[17:43] <geekosaur> sounds to me like the mis-conflation is lists = laziness

[17:43] <pmichaud> what really annoys me about the above is that it looks like I'm binding to a closure, and the closure is being automatically evaluated even though I haven't used .()

[17:43] <TimToady> that is precisely the point

[17:43] <moritz> pmichaud: it's not any different than other phaser

[17:43] <moritz> compare BEGIN foo() and BEGIN { foo() }

[17:44] <moritz> do you expect tha latter to return a closure?

[17:44] <jnthn> o/ pmichaud 

[17:44] <moritz> ok, s/phaser/statement prefix/

[17:44] <pmichaud> that's because BEGIN automatically turns its argument into a closure.... and it's CAPS to indicate that this is what should happen.

[17:44] <pmichaud> fsvo of "argument"

[17:45] <moritz> pmichaud: would it please you if we did s/lazy/LAZY/?

[17:45] <PerlJam> heh, I was just about to ask that

[17:45] <jnthn> Another real problem with lazy trying to be a scalar container is that as soon as you need to type check, it has to evaluate the thing. So you can't pass it around.

[17:45] <pmichaud> since we already have a 'lazy' defined (and I've thought of it as being something somewhat different), LAZY would definitely make me feel better.  But "thunk" might be more descriptive.

[17:46] <TimToady> that end is just syntax

[17:46] <moritz> but "thunk" is something that compiler writers use, not users (usually)

[17:46] <TimToady> the point is that FETCH calls it, not .()

[17:46] <jnthn> TimToady: Had you envisioned it as being container-y?

[17:47] <TimToady> I just envision it as being more haskelly, where P6 doesn't default scalars to lazy

[17:47] <TimToady> but it seems to be working out containerly

[17:47] <moritz> well, it seems to work out only partially

[17:48] <pmichaud> I don't mind if there's a statement prefix that creates a LazyScalar thingy that does something like this;  but if the statement prefix is 'lazy' I don't understand how that relates to lazy context and lists.

[17:48] <moritz> (fwiw I won't be mad at anyone if we reject it in the end; I'm not attached to the concept)

[17:48] <moritz> pmichaud: I must admit that I didn't think about that at all, just implemented what the tests wanted

[17:49] <dalek> roast: 644e553 | moritz++ | S05- (2 files):

[17:49] <dalek> roast: rakudo refudging

[17:49] <dalek> roast: review: https://github.com/perl6/roast/commit/644e553a20

[17:49] <pmichaud> yes, I'm only concerned about the collision with the synopses already-defined 'lazy' operator

[17:49] <moritz> speaking of which, how does that work?

[17:49] <TimToady> doing it the haskell way probably implies static type checking, so maybe it's kind of a "native container" notion

[17:50] <pmichaud> moritz: to me, 'lazy' just creates a list that refuses to do any advanced reification -- it reifies things only when it's forced to do so

[17:50] <TimToady> any kind of pointer indirection ends up hoisting type info up the pointer sequence

[17:51] *** derrazo left
[17:51] <TimToady> pmichaud: other FP languages do not make this distinction

[17:51] <pmichaud> moritz: that might end up being a little naive interpretation of 'lazy', but it's been my mental working model for now

[17:52] <pmichaud> TimToady: when it comes to lists and containers, Perl 6 is definitely not (to my mind) FP though :)

[17:52] <TimToady> but it might be that we require stronger typing for use of scalar laziness

[17:52] <TimToady> or stronger non-typing :)

[17:52] <pmichaud> indeed, much of what we've had to do with containers and lists and evaluation and the like has been because of P6's non-FP-ness, I think.

[17:53] <PerlJam> TimToady: seems like type-inference would help if P6 could do it  (like Haskell)

[17:53] <TimToady> I think this is an inaccurate view of FP, insofar as all FP implementations have to do things like this underneath

[17:53] *** fhelmberger left
[17:53] <pmichaud> TimToady: that's a good point.

[17:53] *** spider-mario left
[17:53] <moritz> so, short term ruling, s/lazy/LAZY/ ?

[17:54] *** mucker joined
[17:54] <moritz> before people get used to the current usage

[17:54] <pmichaud> anyway, my objection is only to the fact that 'lazy' as defined in the recent commit doesn't seem to have anything to do with the _many_ mentions of the word 'lazy' in the synopses.  Either a unification needs to take place (perhaps only in my understanding of the term), or we need a different term.

[17:55] <TimToady> maybe we should rename it to "promise" or some such

[17:55] <TimToady> and allow a return type

[17:56] <pmichaud> I'd also prefer something other than "LazyScalar", for the same reason.  :-)

[17:57] *** sftp left
[17:58] *** sftp joined
[17:58] *** NamelessTee left
[17:59] <pmichaud> afk for a bit, errands

[18:00] <PerlJam> The synopses do seem to almost always talk about laziness with respect to listy things (at least in my quick ack)

[18:00] <PerlJam> I guess I never noticed that before.

[18:01] <PerlJam> Until now I'd been thinking of laziness in perl more as "generic laziness"  kind of like haskell does it.

[18:01] <moritz> PerlJam: fwiw your NQP patch does have a bit of fallout in rakudo land

[18:01] <PerlJam> moritz: more broken test?

[18:02] <PerlJam> er tests

[18:02] <moritz> PerlJam: because the unsupported <term> ** {closure}  form had previously been (falsly) recognized as  <term> ** <sep>

[18:02] <moritz> PerlJam: yes, 4 test files. I'm working on fudging them

[18:02] <PerlJam> moritz++

[18:03] <PerlJam> afk, meeting.  I should have time later tonight (maybe sooner if I'm lucky) to hack on **{}

[18:04] *** cognominal_ joined
[18:05] *** birdwindupbird left
[18:05] <moritz> man, S05-mass/rx.t is a huge PITA to fudge

[18:06] <moritz> first, it's big and slow. Second, the line numbers between the fudged file and the .t file differ quite a bit

[18:07] *** cognominal left
[18:08] <dalek> roast: 1e5917a | moritz++ | S05-metasyntax/single-quotes.t:

[18:08] <dalek> roast: simplify a regex test

[18:08] <dalek> roast: review: https://github.com/perl6/roast/commit/1e5917acb3

[18:09] *** fgomez joined
[18:12] <KyleHa> How hard would it be to make "fudge" retain line numbering?

[18:12] <moritz> dunno; usually it does

[18:15] *** s1n left
[18:15] *** NamelessTee joined
[18:18] *** icwiener left
[18:22] <moritz> fwiw I sometimes get some weird race conditions

[18:22] <moritz> when I save a .t file and immediately after that I run fudge, the test file is gone from the disc

[18:23] <moritz> dunno if vim screws up somehow, but it has only ever happened in connection with fudge/fudgeall to me

[18:24] <pmichaud> phenny: tell tadzik if possible, check with me before doing the May release; I'm expecting to land some regex engine patches later today.  kthx

[18:24] <phenny> pmichaud: I'll pass that on when tadzik is around.

[18:24] <dalek> roast: 149135c | moritz++ | S05-mass/rx.t:

[18:24] <dalek> roast: refudge rx.t for rakudo

[18:24] <dalek> roast: review: https://github.com/perl6/roast/commit/149135c8e0

[18:24] <moritz> oooh, ++pmichaud

[18:25] <diakopter> heh

[18:27] <pmichaud> afk, lunch

[18:28] <dalek> rakudo/nom: 2b96819 | moritz++ | / (2 files):

[18:28] <dalek> rakudo/nom: rename "lazy" to "LAZY" to avoid confusion with lazy lists

[18:28] <dalek> rakudo/nom: 

[18:28] <dalek> rakudo/nom: this might not be the final name either

[18:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b96819319

[18:28] *** fgomez left
[18:28] *** fgomez joined
[18:28] <KyleHa> Lay Zae

[18:30] *** icwiener joined
[18:30] *** s1n joined
[18:32] *** bluescreen10 joined
[18:39] *** s1n left
[18:45] <dalek> rakudo/nom: b390e8b | moritz++ | src/Perl6/Actions.pm:

[18:45] <dalek> rakudo/nom: [LAZY] fix the name in the actions too

[18:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b390e8b9f6

[18:51] * colomon likes this line: $title .=subst('"', "'", :g);

[18:54] *** flussence joined
[18:54] *** alester joined
[18:54] <masak> heh :)

[18:54] <masak> I might've used q[] for both strings in such a case.

[18:54] <masak> because it makes the insides of the strings a bit clearer.

[18:54] *** s1n joined
[18:54] <masak> .=subst(q["], q['], :g)

[18:54] *** goraki joined
[18:55] <colomon> masak++

[18:55] <colomon> though it's pretty easy to read with a sufficiently big fixed-width font.  

[18:55] *** cognominal_ left
[18:55] * moritz would have suggested .=subst(:g, q["], q['])

[18:56] <moritz> I like regex adverbs on the front

[18:57] *** leprevost joined
[18:57] * colomon wasn't even aware that was an option.  are there tests for it?

[18:58] *** cognominal joined
[18:58] *** thelazydeveloper left
[18:59] <moritz> for mixing positionals and named? I'm quite sure yes

[19:01] <colomon> mind you, I'm not sure why I didn't think that was an option.  But I've always putted named arguments last.

[19:01] <moritz> well, in signatures that's mandatory

[19:01] *** colomon left
[19:01] <moritz> but on the caller side, the whole point of using names is that the position doesn't matter :-)

[19:02] *** fibo joined
[19:02] <dalek> roast: 8fb35f5 | moritz++ | S0 (2 files):

[19:02] <dalek> roast: simplify subrule.t a bit

[19:02] <dalek> roast: review: https://github.com/perl6/roast/commit/8fb35f59c8

[19:06] *** snearch joined
[19:11] *** mdupont joined
[19:23] *** leprevost left
[19:26] *** fgomez left
[19:28] *** fgomez joined
[19:31] <masak> r: class A { has @.channels = [] }; say A.new.channels.elems

[19:31] <p6eval> rakudo b390e8: OUTPUT«1␤»

[19:32] <masak> Timbus: this bug remains in your Net::IRC::Bot code. I can send you a pull request to fix it if you want.

[19:33] *** KyleHa left
[19:35] *** leprevost joined
[19:38] <masak> ok, let's sort this out once and for all.

[19:38] <masak> .* only does the MRO thing, right?

[19:39] <masak> meaning, it traverses up the class hierarchy, calling all applicable candidates.

[19:39] <masak> if a class has candidates, but none are applicable, the dispatch fails. correct?

[19:40] <jnthn> Yes, that's how it's implemented, and what makes sense to me.

[19:40] <masak> r: class A { multi method foo($x where 42) { say "OH HAI" } }; A.new.*foo(5)

[19:40] <p6eval> rakudo b390e8: OUTPUT«Cannot call 'foo'; none of these signatures match:␤:(A , $x, Mu *%_)␤␤  in method foo at src/gen/CORE.setting:310␤  in method dispatch:<.*> at src/gen/CORE.setting:839␤  in block <anon> at /tmp/x4Bypvlxy7:1␤␤»

[19:40] <jnthn> It used to be different because we used to flatten the two types of dispatch.

[19:40] <masak> right.

[19:40] <masak> now.

[19:41] <jnthn> Now we have protos. We method dispatch to the proto. That in turn invokes the multiple dispatch.

[19:41] <jnthn> Do the method dispatcher, the proto is opaque.

[19:41] <masak> what's the syntax for saying, "for all these objects some of which may have foo methods with signatures matching my arguments, call those and don't worry so much if things fail"?

[19:41] <moritz> s/Do/To/

[19:42] <masak> there's no MRO or inheritance involved here.

[19:42] <masak> just a bunch of objects. how do I do that?

[19:42] <moritz> $obj.map: { $_.?foo(yourparcel) } ?

[19:42] <masak> s/things fail/binding on particular candidates fails/

[19:42] <jnthn> er, .? is about MRO too

[19:43] <masak> so, `$_.?foo(parcel) for @objs` should work?

[19:43] <jnthn> .? is about MRO too

[19:43] <jnthn> Not about multi-dispatchers.

[19:43] <masak> yeah, but here there's no inheritance.

[19:43] <jnthn> There's till an MRO!

[19:44] <masak> but .? is silent if it fails, right?

[19:44] <masak> oh well. that's why I'm asking. how *do* I do the above?

[19:44] <jnthn> If it fails on the *method* dispatch.

[19:44] <jnthn> Failure to bind the signature isn't a failed method dispatch.

[19:44] <moritz> r: class A { method foo(Int) { } }; A.?foo(Str)

[19:44] <p6eval> rakudo b390e8: OUTPUT«Nominal type check failed for parameter ''; expected Int but got Str instead␤  in method foo at /tmp/nKREDdimd5:1␤  in block <anon> at /tmp/nKREDdimd5:1␤␤»

[19:44] <jnthn> Right.

[19:44] *** goraki left
[19:45] <jnthn> So... :)

[19:45] <masak> I know I have all the pieces of the puzzle, MROs, multis, signatures, blablabla.

[19:45] <masak> but I don't grok. :/

[19:45] <jnthn> To solve masak's problem...

[19:45] <masak> how *do* I... oh good, here it comes.

[19:45] * diakopter tries to even understand the problem

[19:46] <masak> diakopter: it's Net::IRC::Bot. it's built on the user hooking up the bot with a bunch of modules, each one containing multi methods doing pattern matching in their signatures.

[19:46] <masak> diakopter: if a multi doesn't bind, it's meant to skip that call and just move on.

[19:47] <masak> diakopter: now, .* used to do that when Timbus++ wrote it, but the semantics changed.

[19:47] <jnthn> r: class A { multi method foo(Int) { }; multi method foo(Str) { } }; my @args = 42; A.^find_method('foo').candidates_matching(|@args)>>.(|@args)

[19:47] <p6eval> rakudo b390e8:  ( no output )

[19:47] <jnthn> r: class A { multi method foo(Int) { say 1 }; multi method foo(Str) { say 2 } }; my @args = 42; A.^find_method('foo').candidates_matching(|@args)>>.(|@args)

[19:47] <p6eval> rakudo b390e8:  ( no output )

[19:47] <jnthn> hm :/

[19:48] <jnthn> r: class A { multi method foo(Int) { say 1 }; multi method foo(Str) { say 2 } }; my @args = 42; A.^find_method('foo').candidates_matching(|@args).perl.say

[19:48] <p6eval> rakudo b390e8: OUTPUT«()␤»

[19:48] <jnthn> r: class A { multi method foo(Int) { say 1 }; multi method foo(Str) { say 2 } }; my @args = 42; A.^find_method('foo').candidates_matching(Int).perl.say

[19:48] <p6eval> rakudo b390e8: OUTPUT«()␤»

[19:48] <jnthn> r: class A { multi method foo(Int) { say 1 }; multi method foo(Str) { say 2 } }; my @args = 42; A.^find_method('foo').candidates_matching(A, Int).perl.say

[19:48] <p6eval> rakudo b390e8: OUTPUT«(method foo(A , Int , Mu *%_) { ... },)␤»

[19:48] <jnthn> aha!

[19:48] <masak> :)

[19:48] <jnthn> r: class A { multi method foo(Int) { say 1 }; multi method foo(Str) { say 2 } }; my @args = 42; A.^find_method('foo').candidates_matching(A, |@args).perl.say

[19:48] <p6eval> rakudo b390e8: OUTPUT«(method foo(A , Int , Mu *%_) { ... },)␤»

[19:48] <jnthn> r: class A { multi method foo(Int) { say 1 }; multi method foo(Str) { say 2 } }; my @args = 42; A.^find_method('foo').candidates_matching(A, |@args)>>.(|@args)

[19:48] <p6eval> rakudo b390e8: OUTPUT«Nominal type check failed for parameter ''; expected A but got Int instead␤  in method foo at /tmp/4jIrDluqmJ:1␤  in sub METAOP_HYPER_CALL at src/gen/CORE.setting:11142␤  in block <anon> at /tmp/4jIrDluqmJ:1␤␤»

[19:48] <jnthn> oh heh

[19:48] <jnthn> Anyway, I think you can see how to build something on this :)

[19:49] <masak> yes.

[19:49] <masak> thank you.

[19:49] <jnthn> Though for the IRC bot, you may want to try { ... } the whole thing anyway.

[19:49] * diakopter wonders how much more/less efficient being explicit about the candidate searching is

[19:51] <masak> jnthn: under http://perlcabal.org/syn/S12.html#Calling_sets_of_methods , the first sentence is "For any method name, there may be some number of candidate methods that could handle the request: typically, inherited methods or multi variants."

[19:52] <masak> jnthn: problem with doing `try` on the call is that it masks other errors. so I'd have to do a CATCH and let non-binding errors through.

[19:52] <masak> but that should work, OTOH.

[19:52] <masak> r: class A { multi foo(Int) {} }; try A.new.foo("OH HAI"); say $!

[19:52] <p6eval> rakudo b390e8: OUTPUT«Method 'foo' not found for invocant of class 'A'␤  in block <anon> at /tmp/shUxIafdC7:1␤␤»

[19:52] <masak> r: class A { multi foo(Int) {} }; try A.new.foo("OH HAI"); say $!.^name

[19:52] <p6eval> rakudo b390e8: OUTPUT«X::AdHoc␤»

[19:52] <masak> AdHoc? :)

[19:52] <diakopter> hm, what's an easy way to time things in rakudo

[19:53] <moritz> r: say now - now

[19:53] <p6eval> rakudo b390e8: OUTPUT«-0.04258100␤»

[19:53] <masak> r: say time

[19:53] <p6eval> rakudo b390e8: OUTPUT«1337198003␤»

[19:53] <diakopter> now and time are seconds?

[19:53] <masak> r: say now R- now

[19:53] <p6eval> rakudo b390e8: OUTPUT«0.02353280␤»

[19:54] <moritz> masak: any exception that isn't explicitly typed is X::AdHoc

[19:54] <moritz> diakopter: now has sub-second resolution

[19:54] <moritz> r: say time - time

[19:54] <p6eval> rakudo b390e8: OUTPUT«0␤»

[19:54] <diakopter> ok

[19:54] <diakopter> thx

[19:54] <masak> moritz: so if I want to match on it, I match on the text?

[19:55] <jnthn> masak: Yeah. That bit of the spec has been there before any of the proto stuff.

[19:55] <jnthn> masak: Well, current proto stuff.

[19:55] <moritz> masak: or you patch rakudo to throw a typed exception :-)

[19:55] <masak> r: class A { multi foo(Int) {} }; try A.new.foo("OH HAI"); say $! ~~ /'Method ' \'\w+\' ' not found'/

[19:55] <p6eval> rakudo b390e8: OUTPUT«Method 'substr' not found for invocant of class 'X::AdHoc'␤  in method Str at src/gen/CORE.setting:9032␤  in method Stringy at src/gen/CORE.setting:695␤  in method gist at src/gen/CORE.setting:9088␤  in sub say at src/gen/CORE.setting:6765␤  in block <anon> at /tmp…

[19:55] <masak> ehm.

[19:56] <moritz> $!.payload or $!.message

[19:56] <masak> yeahbut

[19:56] <moritz> do you think X::AdHoc is Cool?

[19:56] <moritz> I thought about it

[19:56] <masak> I guess I assument the moral equivalent of that, yeah.

[19:57] <masak> at least that it pretends to be stringish if you try to match a regex against it.

[19:57] <moritz> but I don't want exceptions to be accidentally used as strings

[19:57] <masak> yeah, I guess I see the risk.

[19:57] <jnthn> .oO( does anybody ever assume the immoral equivalent? )

[19:57] <moritz> and in the long run we want to discourage string matching

[19:57] <masak> r: class A { multi foo(Int) {} }; try A.new.foo("OH HAI"); say $!.message ~~ /'Method ' \'\w+\' ' not found'/

[19:57] <p6eval> rakudo b390e8: OUTPUT«=> <Method 'foo' not found>␤␤»

[19:57] <masak> r: class A { multi foo(Int) {} }; try A.new.foo("OH HAI"); say ?$!.message ~~ /'Method ' \'\w+\' ' not found'/

[19:57] <p6eval> rakudo b390e8: OUTPUT«#<failed match>␤»

[19:58] <masak> r: class A { multi foo(Int) {} }; try A.new.foo("OH HAI"); say so $!.message ~~ /'Method ' \'\w+\' ' not found'/

[19:58] <p6eval> rakudo b390e8: OUTPUT«True␤»

[19:58] <masak> "in the long run we want to discourage string matching" is a bad argument for not making it convenient to do so when you need it.

[19:58] <moritz> aye

[19:59] <masak> though I agree with your other points.

[20:05] <masak> r: class A { multi method foo(Int) {} }; try A.new.foo("OH HAI"); say so $!.message ~~ /'none of these signatures match'/

[20:05] <p6eval> rakudo b390e8: OUTPUT«True␤»

[20:05] <masak> I keep forgetting to put 'method' on multi methods... :/

[20:15] <masak> TimToady: S12 is out-of-date with how Rakudo handles .*

[20:16] <masak> TimToady: also, since .* does much less than it used to, there's now no easy way to call a set of same-named multi methods in a class, some of which may bind.

[20:24] <dalek> perl6.org: 1d5f762 | (Filip Sergot)++ | source/fun/index.html:

[20:24] <dalek> perl6.org: [source/fun/index.html] fixed broken link.

[20:24] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/1d5f762efe

[20:25] <moritz> masak: I'm curious, what's your use case for matching "method 'foo' not found" errors?

[20:25] <masak> moritz: Net::IRC::Bot

[20:25] <masak> moritz: trying to fix it up.

[20:25] <masak> it builds on the old .* semantics.

[20:26] <moritz> I'm pretty sure that such a fix is wrong, in the sense of also catching such errors from inside such a call

[20:26] <masak> today's autopun: http://twitter.com/sixthformpoet/status/202728418356379648

[20:27] <moritz> ie the call that you want to catch actually succeeds, but the method then tries to call another method, which fails

[20:27] *** cognominal left
[20:28] *** cognominal joined
[20:31] *** mucker left
[20:32] <masak> moritz: yes.

[20:32] <masak> moritz: so maybe jnthn's proposed introspection way is cleaner.

[20:34] <jnthn> Well, it's not really introspection so much as just a longer syntax for dispatch :)

[20:35] <diakopter> that's what makes me curious about the efficiency

[20:36] <jnthn> I was gonna say you miss the multi-dispatch cache, but then if you're asking it for all candidates, you're gonna anyway.

[20:36] <jnthn> As the cache only covers "give me THE best one"

[20:37] <masak> hm.

[20:38] *** flussence left
[20:39] <moritz> ok, stupid question. Why must it be multi methods?

[20:40] <masak> in case you want to match several different things for a given method name in the same class, I guess.

[20:40] <masak> I haven't seen a case where that's actually done, but I imagine it happens.

[20:40] *** snearch left
[20:40] <masak> like, several .said methods matching different expressions.

[20:41] <moritz> but those have pretty much the same signature each, just different where-blocks, right?

[20:42] <masak> yes...

[20:42] <moritz> in that case I'd add a   proto method said($str) {*}

[20:42] <moritz> hm

[20:42] *** birdwindupbird joined
[20:42] <moritz> or an only-method, that uses some other dispatch mechanism

[20:43] <moritz> or pharsed ifferently, I think you're spending much energy on a mechanism that could much simpler if you remove some not-quite-needed generality

[20:43] <moritz> *phrased

[20:44] <masak> I can see an argument being made for the having to write a proto creating extra work (and extra clutter) for the IRC bot module writer.

[20:44] *** crab2313 left
[20:44] <masak> ("I just wanted to get it to do these things, why do I have to worry about protos?")

[20:44] <masak> currently, the nice thing about those module classes is that they basically contain just the methods for the Net::IRC::Bot framework to hook into.

[20:45] *** cognominal left
[20:45] *** goraki joined
[20:45] <moritz> yes, I can see the point for preserving that

[20:45] *** cognominal joined
[20:46] <masak> if you read S12 it feels pretty great. you just use .* for this.

[20:46] <masak> but we've lost that, and jnthn thinks that's right. and I won't argue with that.

[20:46] <masak> but we don't have that feature anymore.

[20:47] <dalek> rakudo/method-not-found: 65f9d95 | moritz++ | src/core/Exception.pm:

[20:47] <dalek> rakudo/method-not-found: avoid some boxing in print_control

[20:47] <dalek> rakudo/method-not-found: review: https://github.com/rakudo/rakudo/commit/65f9d95d53

[20:47] <dalek> rakudo/method-not-found: 8254a60 | moritz++ | src/core/Exception.pm:

[20:47] <dalek> rakudo/method-not-found: typed exception for "method not found" error

[20:47] <dalek> rakudo/method-not-found: review: https://github.com/rakudo/rakudo/commit/8254a6008e

[20:48] <moritz> CATCH {  given X::Method::NotFound { handle method-not-found case } }

[20:49] <masak> moritz++

[20:50] <masak> moritz: but that turned out to be not the exception I got. I only got that when I forgot to put 'method' after 'multi' :/

[20:50] <masak> moritz: the real exception was 'none of these signatures match:'

[20:52] <moritz> masak: that one is a bit tricker to "type", though we do support some typed exception from C land now

[20:53] * moritz -> sleep

[20:54] <masak> 'night, moritz. dream of beautifully typeable excpetions.

[20:54] <goraki> guten nacht

[21:05] *** mikemol left
[21:05] *** skids left
[21:10] *** ispeak joined
[21:22] *** s1n left
[21:26] *** jferrero left
[21:27] *** b1rkh0ff left
[21:30] *** b1rkh0ff joined
[21:34] *** birdwindupbird left
[21:35] *** wolfman2000 joined
[21:37] *** s1n joined
[21:38] *** thou left
[21:39] *** benabik left
[21:42] <masak> 'night, #perl6

[21:45] *** s1n left
[21:45] <jnthn> 'night, masak

[21:47] *** derrazo joined
[21:47] *** derrazo left
[21:51] <dalek> nqp: 45ed99f | (Gerhard R)++ | 3rdparty/dyncall/GNUmakefile:

[21:51] <dalek> nqp: fixes #38

[21:51] <dalek> nqp: 

[21:51] <dalek> nqp: use explicit -Wno-strict-prototypes instead of -w, which is ignored by gcc 4.2

[21:51] <dalek> nqp: only necessary on OS X, which comes with a broken version of GNU make

[21:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/45ed99fd0e

[21:51] *** leprevost left
[21:52] *** sisar joined
[21:54] <sergot> good night o/

[21:54] *** sergot left
[21:54] <sisar> 'night

[21:55] *** mdupont left
[21:55] *** goraki left
[21:56] *** lestrrat left
[21:57] *** lestrrat joined
[22:00] *** s1n joined
[22:00] *** Araq joined
[22:02] *** not_gerd joined
[22:03] <not_gerd> phenny: tell flussence could you please verify that NQP still builds on the machine that got you https://gist.github.com/2050618

[22:03] <phenny> not_gerd: I'll pass that on when flussence is around.

[22:04] <Woodi> there is at least one protocol (LDAP) where rfc says that errors should be differentiated by numbers and error "textual form" is implementation dependent. maybe same is for HTTP...

[22:06] *** alester left
[22:06] <geekosaur> I think most of them do that now.  SMTP is an exception but sprouted a modified text form with standardized errors to compensate in a backward compatible way

[22:08] *** mdupont joined
[22:10] *** bluescreen10 left
[22:12] <Woodi> HTTP have "classes" of errors (3xx or 4xx), and probably only few numbers are in common use

[22:12] <tadzik> good evening

[22:12] <phenny> tadzik: 18:24Z <pmichaud> tell tadzik if possible, check with me before doing the May release; I'm expecting to land some regex engine patches later today.  kthx

[22:12] <Woodi> hallo tadzik today :)

[22:12] <geekosaur> the classes of errors thing is a very longstanding thing

[22:12] <tadzik> oh, so it's "good morning" already? :)

[22:16] <Woodi> tadzik: is there a NEWS or Changelog file for new Star to look at maybe ?

[22:17] <tadzik> Woodi: well, it's not Star coming out tomo...today

[22:17] <tadzik> it's an ordinary compiler release, and yes, there's a Changelog in the repo

[22:18] <tadzik> see https://github.com/rakudo/rakudo/blob/nom/docs/ChangeLog

[22:18] <Woodi> I hoped for star :) ok, looking.

[22:21] *** not_gerd left
[22:21] <Woodi> and I was thinked do we can call Star a 'stable' distro but probably it will mess with Perl6 state to much in users eyes...

[22:21] *** PacoAir left
[22:22] <Woodi> and what is short-circuit ? :)

[22:22] <tadzik> haha, I passed the SE exam \o/

[22:22] <Woodi> gratz :) early session ?

[22:22] <geekosaur> users mostly think perl6 is dead in the water :/ so messing with that is a good thing

[22:22] <tadzik> Woodi: nah, just a Kolokwium

[22:23] <tadzik> but one of those "pass or die" ones

[22:23] <Woodi> it's required to pass :)

[22:23] <tadzik> aye

[22:25] <tadzik> gosh, I won't have an easy job writing a gist of this month's changelog...

[22:26] <tadzik> "Teh cool stuff. You can has it"

[22:26] *** bluescreen10 joined
[22:28] <Woodi> you sure all entries from changelog belongs to Perl6 compiler ? :) roundrobin, chmod... :)

[22:29] <tadzik> yes

[22:30] <tadzik> I remember moritz++'s patches for those two recently :)

[22:31] *** fgomez left
[22:31] <tadzik> btw, Woodi, did you look at your Redis driver recently?

[22:32] <Woodi> not in last 8 months... becouse I had problems with compiling Star on my small server. but it changed yesterday :)

[22:33] *** fgomez joined
[22:33] <tadzik> ha, great :)

[22:33] <tadzik> I was looking forward to building some useful webapp using this Redis and Bailador

[22:33] <Woodi> and I was trying to do more on Redis topic

[22:34] <tadzik> there is now a working DBI too, but I wanted to look at this Redis thing anyway

[22:35] <Woodi> I will try do things tom^Hday :)

[22:36] <tadzik> :)

[22:37] <sisar> are you guys talking about this Redis http://redis.io/ ?

[22:37] <Woodi> yes

[22:37] *** NamelessTee left
[22:37] <Woodi> it is simple protocol so pure perl implementations can be done

[22:39] <Woodi> but using C bindings always will be better. maybe later someone do this

[22:39] <sisar> i don't get it... what is Rdeis? The Introduction to Redis page does not help much.

[22:39] <tadzik> should be possible as long as we don't go asynchronous

[22:39] <sisar> *Redis

[22:39] <Woodi> sisar: it is memcache with disk persistence

[22:40] *** cognominal left
[22:40] *** cognominal joined
[22:40] * sisar looks up memcache and disk persistence

[22:40] <sisar> :)

[22:40] <Woodi> and many data types :) and methods on them

[22:41] <Woodi> sisar: it is next NoSQL database :)

[22:41] <sisar> oh, so its a database? or it will replace databases ?

[22:41] <Woodi> no

[22:42] <tadzik> yes; no

[22:42] <tadzik> I think :)

[22:42] <sisar> ah

[22:42] <Woodi> it is like cache with safety on disk. not quite intented as full db

[22:43] <sisar> .oO ( there is so much to learn ! )

[22:43] <sisar> .oO ( which is a good thing :) )

[22:43] <sisar> .oO ( i guess ? )

[22:43] <Woodi> but it can be used as full db :) 

[22:44] <sisar> Woodi++ thanks for explaining. I do have a faint idea now :)

[22:44] <Woodi> sisar: yes, learning is good thing :)

[22:45] <Woodi> but working must follow it in some point :)

[22:45] <sisar> not the learning, the 'amount' of learning blows my mind sometimes

[22:45] <Woodi> heh :)

[22:45] <Woodi> there will be more in the future :)

[22:46] *** REPLeffect left
[22:46] <sisar> and right now i'm just a sophomore teenager !

[22:46] <Woodi> choose subset you like :)

[22:47] <sisar> you mean *subject ?

[22:47] <Woodi> learn until your mind is like sponge :)

[22:47] <sisar> aye

[22:48] <tadzik> time for me, *yawn*. Goodnight #perl6

[22:48] <sisar> 'night

[22:48] <Woodi> gn tadzik

[22:50] *** REPLeffect joined
[22:50] <Woodi> sisar: I once hear that numbers things are easier before 30 year of life, so if you consider some philospohy it can wait till 40 year :)

[22:50] <sisar> hehe 

[22:51] *** b1rkh0ff left
[22:51] <Woodi> ok, I will go now too

[22:51] <sisar> bye

[22:51] <Woodi> g * everyone :)

[22:51] *** whiteknight joined
[22:52] *** whiteknight is now known as Guest1540

[22:54] *** icwiener left
[22:58] *** flussence joined
[23:09] *** estrai left
[23:10] *** estrai joined
[23:10] <jnthn> 'night, #perl6

[23:11] *** Araq left
[23:11] *** cognominal left
[23:11] *** cognominal joined
[23:16] *** cognominal left
[23:16] *** cognominal joined
[23:16] *** thou joined
[23:18] *** bluescreen10 left
[23:21] *** fgomez left
[23:21] *** fgomez joined
[23:25] *** cognominal left
[23:25] *** cognominal joined
[23:25] *** thou left
[23:30] *** cognominal_ joined
[23:30] *** cognominal left
[23:30] <[Coke]> (redis) oooh. we're using redis/jedis for a work project. having a p6 port would be a nice alternative.

[23:31] <[Coke]> guten abend, perl 6.

[23:37] *** cognominal_ left
[23:38] *** cognominal joined
[23:41] *** aloha left
[23:52] *** aloha joined
