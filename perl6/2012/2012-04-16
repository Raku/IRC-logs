[00:53] *** tokuhirom joined
[00:59] *** wolfman2000 left
[01:00] *** Trashlord left
[01:01] *** Trashlord joined
[01:02] <moritz> felher: pong

[01:03] *** scott___ joined
[01:06] *** havenn joined
[01:16] *** nif left
[01:19] *** lichtkind left
[01:27] *** nif joined
[01:30] *** havenn left
[01:30] *** mucker joined
[01:34] <[Coke]> colomon: ping.

[01:34] <colomon> pong

[01:35] <[Coke]> can you please update S32-trig/cos.t to emit a specific plan?

[01:35] <[Coke]> (and whatever others there are.)

[01:35] <[Coke]> pugs doesn't like the implicit plan of 'done'.

[01:36] <colomon> hmmmm.... let me ponder

[01:37] <colomon> fudging those files is going to be pretty extreme, no?

[01:38] <[Coke]> let me ask you a different question: how many tests ARE there in that file?

[01:38] *** tokuhirom left
[01:39] <[Coke]> (right now I'm passing 67/67)

[01:39] <colomon> let you know in a moment

[01:39] <colomon> 154

[01:40] <[Coke]> p: (-5.49778714383314).Rat(1e-9).cos

[01:40] <p6eval> pugs: OUTPUT«*** No compatible multi variant found: "&Rat"␤    at /tmp/nf_SEA_tyd line 1, column 1 - line 2, column 1␤»

[01:40] <[Coke]> p: -5.49778714383314.Rat(1e-9).cos

[01:40] <p6eval> pugs: OUTPUT«*** No compatible multi variant found: "&Rat"␤    at /tmp/n1jmey2khg line 1, column 1 - line 2, column 1␤»

[01:40] <[Coke]> p: -5.49778714383314.Ra.cos

[01:40] <p6eval> pugs: OUTPUT«*** No such method in class Rat: "&Ra"␤    at /tmp/MOoszFcb1i line 1, column 1 - line 2, column 1␤»

[01:40] <[Coke]> p: -5.49778714383314.Rat.cos

[01:40] <p6eval> pugs:  ( no output )

[01:41] <[Coke]> first approximation of Rat($epsilon) is to just ignore epsilon, meh?

[01:42] * colomon ponders a script which runs a test file and then add a proper plan statement to the top.

[01:42] <colomon> [Coke]: yes

[01:42] <[Coke]> hurm. nevermind, I'll not be able to easily add that yet.

[01:42] <[Coke]> ah well, skipping this file.

[01:47] <[Coke]> colomon: nevermind. I'm not passing all the tests anyway.

[01:52] *** godfrey999 joined
[01:53] *** thelazydeveloper left
[01:53] <dalek> roast: fa12fff | coke++ | S (4 files):

[01:53] <dalek> roast: pugs fudge

[01:53] <dalek> roast: review: https://github.com/perl6/roast/commit/fa12fffe6e

[01:57] <dalek> Pugs.hs: 9e709ce | coke++ | t/spectest.data:

[01:57] <dalek> Pugs.hs: run fudged tests

[01:57] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/9e709cecb5

[01:59] <mucker> hi guys ... correct me if I am wrong, but is NQP a full implementation of perl6 regex ?

[01:59] <moritz> it's not

[02:00] <mucker> does rakudo or n have full implementation of regex ?

[02:00] <moritz> no, there are still a few features missing

[02:00] <moritz> though niecza's implementation is quite impressive

[02:00] <mucker> ok :)

[02:01] <[Coke]> p: say "34" ~~ /\d/

[02:01] <p6eval> pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20120203/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** Can't locate P…

[02:01] <[Coke]> Urk.

[02:04] *** plobsing joined
[02:10] *** orafu left
[02:11] *** orafu joined
[02:20] *** mucker left
[02:24] *** cognominal_ left
[02:25] *** cognominal joined
[02:47] *** wolfman2000 joined
[02:49] *** nif left
[02:51] *** lestrrat left
[02:52] *** cognominal left
[02:53] *** lestrrat joined
[02:53] *** cognominal joined
[03:02] *** envi_ joined
[03:25] *** clkao left
[03:25] *** clkao joined
[03:41] *** envi_ left
[03:46] *** cognominal left
[03:46] *** cognominal joined
[03:48] *** IKARi_ left
[03:59] *** fgomez left
[04:02] *** alvis left
[04:58] *** y3llow left
[04:59] *** birdwindupbird joined
[05:02] *** araujo left
[05:06] *** alester joined
[05:21] *** alester left
[05:23] *** Trashlord left
[05:24] *** spaceships left
[05:28] *** Trashlord joined
[05:33] *** mos_ joined
[05:33] *** mos_ left
[05:34] *** bonsaikitten left
[06:01] *** kaleem joined
[06:03] *** xinming left
[06:06] *** NamelessTee joined
[06:13] *** bonsaikitten joined
[06:14] *** wtw joined
[06:15] *** xinming joined
[06:26] *** cognominal left
[06:28] *** cognominal joined
[06:50] *** sftp left
[06:51] *** sftp joined
[06:51] *** fglock left
[06:51] *** Tedd1 joined
[06:56] *** kaleem left
[06:57] *** araujo joined
[06:57] *** araujo left
[06:57] *** araujo joined
[06:58] *** sftp left
[06:59] *** brrt joined
[07:02] *** sftp joined
[07:06] *** fhelmberger joined
[07:16] *** darkx joined
[07:18] *** sftp left
[07:18] *** sftp_ joined
[07:20] *** PZt left
[07:20] *** kaleem joined
[07:26] *** kaleem left
[07:26] *** kaleem joined
[07:29] *** ZapZ left
[07:33] *** kaleem left
[07:45] *** kaleem joined
[07:59] <masak> go' mo', #perl6

[08:00] <jnthn> hi masak

[08:01] <moritz> \o jnthn, masak, *

[08:11] <tadzik> \o/

[08:24] <moritz> r: say 'tadzik' ~~ *

[08:24] <p6eval> rakudo 442db9: OUTPUT«True␤»

[08:24] <moritz> good, I greeted him too :-)

[08:26] <masak> r: say * ~~ 'tadzik'

[08:26] <p6eval> rakudo 442db9: OUTPUT«False␤»

[08:27] <masak> r: say * ~~ *

[08:27] <p6eval> rakudo 442db9: OUTPUT«True␤»

[08:27] <masak> (* ~~ *)

[08:27] <masak> almost looks like one of sjohnson++'s fat faces ;)

[08:29] <moritz> that'st he True fat face :-)

[08:30] <moritz> r: say (* ~~ *)

[08:30] <p6eval> rakudo 442db9: OUTPUT«True␤»

[08:32] *** dakkar joined
[08:33] *** fglock joined
[08:34] <sorear> o/ masak

[08:35] <masak> \o sorear

[08:36] <fglock> o/ #perl6

[08:37] <__sri> \o peer pressure

[08:37] <masak> :P

[08:37] <moritz> :-)

[08:37] <masak> I find http://www.modernperlbooks.com/mt/2012/04/mock-objects-despoil-your-tests.html quite interesting, not least because it manages very well to highlight a classicist's view of tests. I've seen enough of the mockist side of the story to know that there's more to it, but I haven't come down on either side of the fence yet.

[08:38] <masak> and maybe I never will. different projects have different requirements.

[08:39] <moritz> they probably have

[08:39] <moritz> some months back I've written WebService::Libris

[08:40] <moritz> and I was happy that I found a way to avoid doing either live calls over the internet while testing, or mocking

[08:40] <moritz> the solution was to enable a caching mechanism, and distribute the cache files

[08:41] <moritz> of course that didn't test the actual fetching code, but the fetching code was just one call to Mojo::UserAgent

[08:42] <arnsholt> I have to admit I'm easily amused by chromatic's writings

[08:54] *** cognominal left
[08:55] *** cognominal joined
[08:59] *** lestrrat left
[09:00] *** lestrrat joined
[09:05] <masak> arnsholt: if you mean he writes in a captivating manner, I agree. he's often humorously hyperbolic.

[09:05] <masak> the only drawback of excessive sarcasm is that it doesn't always end up holding a position -- just stating a lot of negatives.

[09:06] <masak> s/only/big/

[09:06] <arnsholt> Yeah, there is that

[09:07] <arnsholt> I think the best part of his writing is that he pulls of the whole "cranky, opinionated hacker" thing without swearing every other sentence

[09:08] <masak> aye.

[09:09] <masak> it's always refreshing to read the writings of someone with obvious experience.

[09:09] <sorear> the best part of chromatic

[09:10] <sorear> the best part of chromatic's writing is that most of it manages to come across as a direct response to something I said in #perl6 in the last week

[09:10] <moritz> totally different topic, and off-topic here, but I found http://johncarlosbaez.wordpress.com/2012/04/15/ice/ quite interesting

[09:10] <moritz> sorear: he surely reads #perl6 logs, at least occasionally

[09:12] *** alvis joined
[09:12] <cognominal> \o

[09:14] <cognominal> moriz, in physic terms, perl 6 implementations are slowing changing from vapour to sludge? :)

[09:15] <moritz> cognominal: some parts are already moving from sludge to solid :-)

[09:15] <cognominal> I guess we shoot to organic.

[09:15] <cognominal> *slowly

[09:17] <sorear> moritz: yeah, and it makes me feel special :p

[09:19] <masak> you are :)

[09:19] * moritz was about to say the same thing, but didn't

[09:24] <masak> moritz: mini-challenge: write succinct p6 program that generates such sequences, ababcacba, of length N from the alphabet <a b c>, but where no two adjacent positions have the same letter.

[09:25] <sorear> mind if I try?

[09:25] <masak> go ahead.

[09:25] <moritz> go right ahead

[09:25] <masak> I'm writing up one too right now.

[09:25] * moritz too

[09:26] <bbkr> is ababababab valid sequence?

[09:26] <sorear> n: say join '', <a b c>.pick, { <a b c>.grep(* != $_).pick } ...^ { @_ == 10 }

[09:26] <masak> yes.

[09:26] <p6eval> niecza v16-21-g1b64073: OUTPUT«␤»

[09:26] <sorear> n: say join '', (<a b c>.pick, { <a b c>.grep(* != $_).pick } ...^ { @_ == 10 })

[09:26] <p6eval> niecza v16-21-g1b64073: OUTPUT«Unhandled exception: Cannot parse number: a␤  at /home/p6eval/niecza/lib/CORE.setting line 1363 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3402 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3404 (NumSyntax.str2num @ 4) ␤  at /h…

[09:27] <sorear> n: say join '', (<a b c>.pick, { <a b c>.grep(* ne $_).pick } ...^ { @_ == 10 })

[09:27] <p6eval> niecza v16-21-g1b64073: OUTPUT«bcabacbab␤»

[09:27] <shachaf> masak: I always heard of a similar thing wher eyou generate a position of length N such you never have two consecutive identical substrings.

[09:27] <shachaf> I.e., no aa, no abab, no acbcacbc, etc.

[09:27] <shachaf> By "always" I mean once.

[09:27] <sorear> this reminds me of the word problem for computably presented groups

[09:28] <sorear> Thue grammars and such

[09:28] <moritz> p6: my %complement = a => <b c>, b => <a c>, c => <a b>; say (%complement.keys.pick, { %complement{$_}.pick } ... *)[^10].join;

[09:28] <p6eval> pugs: OUTPUT«*** unknown parse error␤    at /tmp/rtrKdOplec line 1, column 113␤»

[09:28] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«cbacabacac␤»

[09:28] <p6eval> ..rakudo 442db9: OUTPUT«ababcbcabc␤»

[09:28] <shachaf> What is that problem?

[09:29] <moritz> shachaf: random positioning of ice layers as described in http://johncarlosbaez.wordpress.com/2012/04/15/ice/

[09:29] <masak> <masak> moritz: mini-challenge: write succinct p6 program that generates such sequences, ababcacba, of length N from the alphabet <a b c>, but where no two adjacent positions have the same letter.

[09:29] *** darkx left
[09:29] <masak> ok, here's my take:

[09:29] <shachaf> I meant the thing sorear mentioned.

[09:29] <masak> r: my $N = 20; say (((([\+] (1, 2).pick xx $N) X+ (^3).pick) X% 3) X+ ord("a"))>>.&chr

[09:29] <p6eval> rakudo 442db9: OUTPUT«c a c a c a b c b c a b c a b a b a b a␤»

[09:29] * shachaf looks at ice article.

[09:29] <moritz> I like my solution, even if the initialization is a bit wordy

[09:30] <masak> moritz: ours are both O(N), I think.

[09:30] <sorear> n: say {<a b c>[$_]}>>([\+] (1,2).pick(10))

[09:30] <p6eval> niecza v16-21-g1b64073: OUTPUT«c Any()␤»

[09:31] <sorear> n: say {(<a b c> xx Inf)[$_]}>>([\+] (1,2).pick(10))

[09:31] <p6eval> niecza v16-21-g1b64073: OUTPUT«a b c a b c␤»

[09:31] <shachaf> (There exists an infinite sequence of the form I described which can be generated very simply, but it's pretty tricky to find. An easier way of generating it is just backtracking.)

[09:31] <sorear> n: say {(<a b c> xx Inf)[$_]}>>([\+] (1,2).roll(10))

[09:31] <p6eval> niecza v16-21-g1b64073: OUTPUT«a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c␤»

[09:31] <sorear> n: say {(<a b c> xx Inf)[$_]}>>([\+] (1..2).roll(10))

[09:31] <p6eval> niecza v16-21-g1b64073: OUTPUT«a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c␤»

[09:31] <sorear> n: say (1..2).roll(10)

[09:31] <p6eval> niecza v16-21-g1b64073: OUTPUT«2 2 1 1 2 2 1 1 1 2␤»

[09:32] <masak> oh, indeed.

[09:32] <sorear> n: say ([\+] (1..2).roll(10))

[09:32] <p6eval> niecza v16-21-g1b64073: OUTPUT«1 3 5 6 8 10 12 14 15 16␤»

[09:32] <masak> r: my $N = 20; say (((([\+] (1, 2).roll($N)) X+ (^3).pick) X% 3) X+ ord("a"))>>.&chr

[09:32] <p6eval> rakudo 442db9: OUTPUT«b c b a b a b c a c b a b c b a b a c b␤»

[09:32] <moritz> p6: my @a = <a b c>; my %c = @a.map: -> $l { $l => @a.grep({$_ ne $l}) }; say (%c.keys.pick, { %c{$_}.pick } ... *)[^10].join;

[09:32] <sorear> n: say map (<a b c> xx Inf)[$_]}, ([\+] (1..2).roll(10))

[09:32] <p6eval> rakudo 442db9: OUTPUT«cababacbab␤»

[09:32] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«abcacbcbcb␤»

[09:32] <p6eval> ..pugs: OUTPUT«*** unknown parse error␤    at /tmp/qCmAwhBfhf line 1, column 112␤»

[09:32] <p6eval> niecza v16-21-g1b64073: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unexpected closing bracket at /tmp/sxSXqG9PoI line 1:␤------> [32msay map (<a b c> xx Inf)[$_][33m⏏[31m}, ([\+] (1..2).roll(10))[0m␤␤Parse failed␤␤»

[09:32] <sorear> n: say map {(<a b c> xx Inf)[$_]}, ([\+] (1..2).roll(10))

[09:32] <p6eval> niecza v16-21-g1b64073: OUTPUT«a b c a b c a b c a b c a b c a b c a b c a b c a b c a b c␤»

[09:33] <sorear> n: say map {(<a b c> xx Inf).flat[$_]}, ([\+] (1..2).roll(10))

[09:33] <moritz> still wordy, but less repetitive (my solution

[09:33] <p6eval> niecza v16-21-g1b64073: OUTPUT«c a b a b c a b c b␤»

[09:33] <sorear> n: say join map {(<a b c> xx Inf).flat[$_]}, ([\+] (1..2).roll(30))

[09:33] <p6eval> niecza v16-21-g1b64073: OUTPUT«␤»

[09:33] <moritz> n: say map {<a b c>[$_ % *]}, ([\+] (1..2).roll(10))

[09:33] <p6eval> niecza v16-21-g1b64073: OUTPUT«c b a b c a b a b a␤»

[09:34] <sorear> n: say join '', map {(<a b c> xx Inf).flat[$_]}, ([\+] (1..2).roll(30))

[09:34] <p6eval> niecza v16-21-g1b64073: OUTPUT«bacbababacabcbacbabcbabacabcbc␤»

[09:34] <moritz> I like .[$_ % *] :-)

[09:36] <sorear> Writing Markov chains shouldn't be this hard.

[09:37] <moritz> p6: my @a = <a b c>; say (@a.pick, -> $l { @a.grep($l ne *).pick } ... *)[^10].join;

[09:37] <p6eval> rakudo 442db9: OUTPUT«acacacabca␤»

[09:37] <p6eval> ..pugs: OUTPUT«*** unknown parse error␤    at /tmp/griclbNPGT line 1, column 70␤»

[09:37] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«bacacacacb␤»

[09:37] *** _jaldhar is now known as jaldhar

[09:37] <moritz> not too hard IMHO :-)

[09:37] *** jferrero joined
[09:37] <moritz> p6: my @a = <a b c>; say (@a.pick, { @a.grep($_ ne *).pick } ... *)[^10].join;

[09:37] <p6eval> rakudo 442db9: OUTPUT«cabcabacab␤»

[09:37] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«ababcbcacb␤»

[09:37] <p6eval> ..pugs: OUTPUT«*** unknown parse error␤    at /tmp/dWJDs31tgE line 1, column 64␤»

[09:38] <sorear> "Why can't r and n agree on any of this?"

[09:38] *** envi_ joined
[09:38] <moritz> they are just non-conformists

[09:38] * sorear sleep

[09:38] <moritz> r: say 3 * 2**9

[09:38] <p6eval> rakudo 442db9: OUTPUT«1536␤»

[09:38] <moritz> good night sorear, dream of easy markov chains

[09:38] <masak> r: my $m = 3; say (((^$m).roll, { ($_ + 1 + (^($m-1)).roll) % $m } ... *) Z+ ord('a'))[^10]>>.&chr.join

[09:38] <p6eval> rakudo 442db9: OUTPUT«c␤»

[09:38] <masak> hrm.

[09:39] <moritz> masak: X+, not Z+

[09:39] <masak> r: my $m = 3; say (((^$m).roll, { ($_ + 1 + (^($m-1)).roll) % $m } ... *) X+ ord('a'))[^10]>>.&chr.join

[09:39] <p6eval> rakudo 442db9: OUTPUT«bcbcacabab␤»

[09:39] <masak> \o/

[09:39] <masak> moritz++

[09:40] <moritz> now somebody please make a blog post, tracing each different approach through the stages shown here :-)

[09:40] <masak> r: my $m = 3; say ^$m

[09:40] <p6eval> rakudo 442db9: OUTPUT«0..^3␤»

[09:40] <masak> r: my $m = 3; say ^^$m

[09:40] <p6eval> rakudo 442db9: OUTPUT«0..^3␤»

[09:42] *** kresike joined
[09:45] <masak> r: my %comp; my @v = <a b c>; for map { [@v.rotate($_)] }, ^@v { .say }

[09:45] <p6eval> rakudo 442db9: OUTPUT«a b c␤b c a␤c a b␤»

[09:46] <masak> r: my %comp; my @v = <a b c>; for map { [@v.rotate($_)] }, ^@v { my ($k, @vs) = @v; %comp{$k} = @vs }; say %comp.perl

[09:46] <p6eval> rakudo 442db9: OUTPUT«("a" => ["b", "c"]).hash␤»

[09:46] <masak> huh.

[09:47] <masak> r: my %comp; my @v = <a b c>; for map { [@v.rotate($_)] }, ^@v { .say; my ($k, @vs) = @v; %comp{$k} = @vs }; say %comp.perl

[09:47] <p6eval> rakudo 442db9: OUTPUT«a b c␤b c a␤c a b␤("a" => ["b", "c"]).hash␤»

[09:47] <masak> where did the other two entries go?

[09:47] <moritz> erm

[09:48] <moritz> @v is always the same

[09:48] <moritz> $_ is what's changing in the loop

[09:48] *** birdwindupbird left
[09:48] <moritz> and you print $_ with .say

[09:48] <masak> er... oops.

[09:48] <masak> r: my %comp; my @v = <a b c>; for map { [@v.rotate($_)] }, ^@v { .say; my ($k, @vs) = @$_; %comp{$k} = @vs }; say %comp.perl

[09:48] <p6eval> rakudo 442db9: OUTPUT«a b c␤b c a␤c a b␤("a" => ["b", "c"], "b" => ["c", "a"], "c" => ["a", "b"]).hash␤»

[09:48] <masak> r: my %comp; my @v = <a b c>; for map { [@v.rotate($_)] }, ^@v { my ($k, @vs) = @$_; %comp{$k} = @vs }; say %comp.perl

[09:48] <p6eval> rakudo 442db9: OUTPUT«("a" => ["b", "c"], "b" => ["c", "a"], "c" => ["a", "b"]).hash␤»

[09:48] <masak> \o/

[09:49] <moritz> r: my %comp; my @v = <a b c>; for @v.keys { my ($k, @vs) = @v.rotate($_); %comp{$k} = @vs }; say %comp.perl

[09:49] <p6eval> rakudo 442db9: OUTPUT«("a" => ["b", "c"], "b" => ["c", "a"], "c" => ["a", "b"]).hash␤»

[09:49] <moritz> feels a bit more straight-forward IMHO

[09:50] <masak> r: my @v = <a b c>; my %comp = map { my ($k, @vs) = @v.rotate($_); $k => @vs }, @v.keys; say %comp.perl

[09:50] <p6eval> rakudo 442db9: OUTPUT«("a" => ["b", "c"], "b" => ["c", "a"], "c" => ["a", "b"]).hash␤»

[09:51] <moritz> I wonder...

[09:51] <moritz> r: my @v = <a b c>; my %comp = map { [=>] @v.rotate($_)[0, 1..*-1] }, ^@v; say %comp.perl

[09:51] <p6eval> rakudo 442db9: OUTPUT«("a" => "b" => "c", "b" => "c" => "a", "c" => "a" => "b").hash␤»

[09:52] <moritz> r: my @v = <a b c>; my %comp = map { [=>] @v.rotate($_)[0, 1..*-1].tree }, ^@v; say %comp.perl

[09:52] <p6eval> rakudo 442db9: OUTPUT«("a" => ["b", "c"], "b" => ["c", "a"], "c" => ["a", "b"]).hash␤»

[09:52] <arnsholt> I get a Rakudo spectest failure in S11-modules/require.t on Linux. Is that a known one?

[09:52] <moritz> \o/

[09:52] <masak> moritz: woot

[09:52] <moritz> arnsholt: I get that too. I kinda suspect jnthn++ is to blame

[09:53] <moritz> it's harder to read, but sometime I like the challenge of getting rid of variables

[09:53] *** birdwindupbird joined
[09:53] <moritz> I wonder if .rotate(*) should return a LoL of all rotations

[09:53] <moritz> (and I'm only half-kidding right now)

[09:53] <masak> r: my @v = <a b c>; my %comp = map -> @ ($k, @vs) { $k => @vs }, map { @v.rotate($_) }, ^@v; say %comp.perl

[09:53] <p6eval> rakudo 442db9: OUTPUT«Nominal type check failed for parameter ''; expected Positional but got Str instead␤  in block <anon> at /tmp/WltNubu86u:1␤␤»

[09:54] <masak> r: my @v = <a b c>; my %comp = map -> @ ($k, @vs) { $k => @vs }, map { [@v.rotate($_)] }, ^@v; say %comp.perl

[09:54] <p6eval> rakudo 442db9: OUTPUT«Nominal type check failed for parameter '@vs'; expected Positional but got Str instead in sub-signature␤  in block <anon> at /tmp/AjXTqd6X9r:1␤␤»

[09:54] <moritz> masak: you need to feed in a list of lists or list of arrays or so

[09:54] <moritz> otherwise @ is never happy

[09:54] <masak> I thought that's what I did.

[09:54] <masak> putting [] in the second map

[09:54] <moritz> oh, right

[09:54] <moritz> hm

[09:55] <moritz> r: my @v = <a b c>; say (map { [@v.rotate($_)] }, ^@v).perl

[09:55] <p6eval> rakudo 442db9: OUTPUT«(["a", "b", "c"], ["b", "c", "a"], ["c", "a", "b"]).list␤»

[09:55] <moritz> masak: oh

[09:55] <moritz> masak: it fails in the subsiganture

[09:55] <moritz> masak: because it needs to be *@vs, not @v

[09:55] <masak> ah, yes.

[09:55] <moritz> *not @vs

[09:56] <masak> r: my @v = <a b c>; my %comp = map -> @ ($k, *@vs) { $k => @vs }, map { @v.rotate($_) }, ^@v; say %comp.perl

[09:56] <p6eval> rakudo 442db9: OUTPUT«Nominal type check failed for parameter ''; expected Positional but got Str instead␤  in block <anon> at /tmp/pNyMOiUV1n:1␤␤»

[09:56] <moritz> it even says "in sub-signature" :-)

[09:56] <cognominal> do you know?  http://mathworld.wolfram.com/deBruijnSequence.html

[09:56] <masak> r: my @v = <a b c>; my %comp = map -> @ ($k, *@vs) { $k => @vs }, map { [@v.rotate($_)] }, ^@v; say %comp.perl

[09:56] <p6eval> rakudo 442db9: OUTPUT«("a" => ["b", "c"], "b" => ["c", "a"], "c" => ["a", "b"]).hash␤»

[09:56] <masak> cognominal: yes, I've come across that concept. :)

[09:57] <cognominal> I have bought "algorithm on strings". Not read yet

[09:58] <cognominal> this one :  http://www.amazon.fr/Algorithms-Strings-Maxime-Crochemore/dp/0521848997

[09:59] *** kaleem left
[09:59] <masak> "Cliquez pour Feuilleter!" :D

[09:59] <cognominal> oops, I paste the amazom.fr page.

[10:00] <masak> cognominal: for a mo I thought you meant http://www.amazon.com/Algorithms-Strings-Trees-Sequences-Computational/dp/0521585198

[10:01] <masak> which was a textbook in one of my favorite courses.

[10:01] <cognominal> I don't know why but it is trendy to have mederval covers for books on lisp or algorithms.

[10:02] * moritz thinks of The Art of the Meta Object Protocol :-)

[10:02] *** kaleem joined
[10:04] <cognominal> I suppose that, somehow, doing algorithms or lisp is specially crafty

[10:05] <cognominal> well not in the deceiful meaning of the word.

[10:05] <masak> as in craftmanship, yes.

[10:08] *** daxim joined
[10:10] <masak> or is it "craftSmanship"? probably.

[10:11] <moritz> phenny: "handwerk"?

[10:11] <phenny> moritz: "craft" (de to en, translate.google.com)

[10:11] <moritz> meh :-)

[10:11] *** scott___ left
[10:12] <moritz> phenny: "handwerkskunst"?

[10:12] <phenny> moritz: "craftsmanship" (de to en, translate.google.com)

[10:13] <masak> phenny: "slöjd"?

[10:13] <phenny> masak: "crafts" (sv to en, translate.google.com)

[10:14] <tadzik> phenny: "rzemiosło"?

[10:14] <phenny> tadzik: "craft" (pl to en, translate.google.com)

[10:14] <tadzik> phenny: "rzemieślnictwo"?

[10:14] <phenny> tadzik: "crafts" (pl to en, translate.google.com)

[10:14] <masak> phenny: "hantverk"?

[10:14] <phenny> masak: "crafts" (sv to en, translate.google.com)

[10:14] <tadzik> . o O ( is there even a word like this one? )

[10:22] *** lestrrat left
[10:23] *** lestrrat joined
[10:28] <daxim> "All craftsdwarfship is of finest quality."

[10:30] <masak> sounds like Pratchett.

[10:33] <moritz> your pratchettship is excellent :-)

[10:33] *** wolfman2000 left
[10:34] <daxim> lolwhat

[11:21] *** buubot_backup left
[11:21] *** buubot_backup joined
[11:24] *** Timbus left
[11:25] <masak> daxim: 你在哪里学了汉语?

[11:37] *** JimmyZ joined
[11:41] *** PZt joined
[11:55] *** godfrey999 left
[11:57] *** lloydf joined
[11:59] *** jaffa4 joined
[11:59] <moritz> masak: after skimming http://stackoverflow.com/questions/1990464/efficiency-of-purely-functional-programming I'm sure there must be a purely functional data structure that works way better than the "obvious" approach for calculating the frequency of characters in a string

[11:59] *** snearch joined
[12:01] <masak> ooh

[12:01] *** skids left
[12:02] <masak> clearly there are things to learn here.

[12:02] *** mucker joined
[12:03] *** brrt left
[12:04] <moritz> indeed

[12:05] *** plobsing left
[12:12] *** plobsing joined
[12:12] <jaffa4> hi

[12:12] <jaffa4> Where is an example how to call functions in external libraries?

[12:16] <jnthn> jaffa4: https://github.com/jnthn/zavolaj has a README with examples of what it is capable of, plus the test suite is full of examples in a sense too.

[12:17] <jnthn> star: use NativeCall; sub fork() is native returns Int { * }; say fork();

[12:17] <p6eval> star 2012.02: OUTPUT«26904␤»

[12:17] <jnthn> Hm :)

[12:17] <moritz> star: use NativeCall; sub fork() is native returns Int { * }; say fork(); say 'oh hai'

[12:17] <p6eval> star 2012.02: OUTPUT«26908␤oh hai␤»

[12:17] <jaffa4> What is  { * }?

[12:18] <moritz> jnthn: might be a limitation of p6eval, not capturing subprocesses' output or so

[12:18] <jnthn> moritz: That's my guess

[12:18] <masak> jaffa4: it's a special form.

[12:18] <jnthn> jaffa4: You don't have to write the *

[12:18] <jnthn> jaffa4: The actually body of the sub is totally unimportant.

[12:18] <jnthn> It just means "whatever" in Perl 6

[12:18] <jnthn> So it felt apt

[12:19] <jnthn> sub fork() is native returns Int { "OMG A DRUNK POLAR BEAR" } is fine too :)

[12:19] <masak> o.O

[12:19] <jaffa4> It does not seem to work in Niecza

[12:19] <masak> jnthn: what kind of fork() are you using? :P

[12:20] <jnthn> jaffa4: No, it won't.

[12:20] <moritz> niecza can't call C code (afaict), only other CLR code

[12:20] <moritz> and there are examples of this both in the niecza repo and on the p6 advent calendar 2011

[12:22] <jaffa4> other CLR code may be enough.

[12:22] <jnthn> masak: My head is a messy place today :P

[12:22] <arnsholt> IIRC C# (or maybe it's just .Net) has some pretty spiffy FFI facilities

[12:23] <arnsholt> So it might be possible to create a Niecza NativeCall with those

[12:23] * masak .oO( TODO: get brain out of messy place where instead of "OH HAI", brain emits "OMG A DRUNK POLAR BEAR"... )

[12:23] <moritz> wow, it's the 16th day of the month, and tomorrow is a parrot release already

[12:23] <jnthn> huh...wow

[12:23] <frettled> masak: OMG A DRUNK SWEDE

[12:23] * masak acts redlös

[12:26] <bbkr> std: my ${a} = 5;

[12:26] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unsupported use of ${a}; in Perl 6 please use $a at /tmp/WsfqeL0gUw line 1:␤------> [32mmy ${a}[33m⏏[31m = 5;[0m␤Parse failed␤FAILED 00:00 40m␤»

[12:26] <bbkr> rakudo: my ${a} = 5;

[12:26] <p6eval> rakudo 442db9:  ( no output )

[12:26] <bbkr> hm, it did _something_ :)

[12:27] * bbkr reports

[12:28] <jnthn> nom: my $a{a} = 5

[12:28] <p6eval> rakudo 442db9:  ( no output )

[12:28] <jnthn> Hm

[12:28] <masak> right.

[12:28] <jnthn> I mean, I know we support

[12:29] <masak> it probably does '(my $){a} = 5'

[12:29] <jnthn> nom: my %h{Int}

[12:29] <p6eval> rakudo 442db9:  ( no output )

[12:29] <jnthn> nom: my %h{a}

[12:29] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤Invalid hash shape; type expected␤»

[12:29] <masak> hm, but why isn't that a CHECK-time error?

[12:29] <jnthn> nom: my @h{a}

[12:29] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤Shaped arrays not yet implemented. Sorry. ␤at /tmp/n80mZdR4Yp:1␤»

[12:29] <jnthn> nom: my $h{a}

[12:29] <p6eval> rakudo 442db9:  ( no output )

[12:29] <moritz> nom: my $h{a}; $h = 5; say $h

[12:29] <p6eval> rakudo 442db9: OUTPUT«5␤»

[12:29] <jnthn> It's parsing a shape. I wonder if it then just drops it for scalars somehow.

[12:30] <masak> sure seems that way.

[12:30] <bbkr> so is that a bug?

[12:30] *** tokuhirom joined
[12:31] <moritz> yes

[12:31] <moritz> parsing things but then ignoring them (except comments :-) is so mysql

[12:31] <masak> mysql doesn't ignore comments!? :P

[12:32] <bbkr> https://rt.perl.org/rt3/Ticket/Display.html?id=112470

[12:32] <moritz> masak: no, but lots of other stuff :-)

[12:32] <moritz> depending on the engine foreign key contraints, CHECK, UNIQUE and all the other fun stuff

[12:33] <masak> wow.

[12:36] <arnsholt> masak: http://sql-info.de/mysql/gotchas.html =)

[12:36] <arnsholt> Apparently it's not updated for 5.0 though, so some of it might actually be history by now

[12:36] *** brrt joined
[12:38] <masak> yeah. mysql is no longer in the set of bits of technology I automatically reach for when I need to solve a problem.

[12:38] *** brrt1 joined
[12:39] <masak> postgres and sqlite are.

[12:41] *** brrt left
[12:42] *** brrt1 is now known as brrt

[12:43] <jaffa4> maybe you are forgetting firebird.

[12:43] * JimmyZ usually uses postgreSQL

[12:44] <moritz> jnthn: firebird is robust and has many features, but often a bit awkward to use

[12:44] <moritz> erm, meant jaffa4 

[12:44] *** bluescreen10 joined
[12:44] <moritz> in particular I see no reason to use it over postgres

[12:44] <moritz> which also has much better perl bindings

[12:44] <jaffa4> It seems to be smaller in size

[12:44] <jaffa4> It has got embedded version

[12:49] *** bluescreen10 left
[12:50] *** bluescreen10 joined
[12:50] *** bluescreen10 left
[12:50] *** bluescreen10 joined
[12:54] <jaffa4> moritz: clear

[12:56] <jaffa4> r: eval(:lang<perl5>,'1');

[12:56] <p6eval> rakudo 442db9: OUTPUT«Null PMC access in find_method('compile')␤  in sub eval at src/gen/CORE.setting:450␤  in block <anon> at /tmp/DsscnwJUe9:1␤␤»

[12:56] <jaffa4> s: eval(:lang<perl5>,'1');

[12:56] * masak submits rakudobug

[12:56] <jaffa4> n: eval(:lang<perl5>,'1');

[12:56] <p6eval> niecza v16-21-g1b64073: OUTPUT«Unhandled exception: System.IO.FileNotFoundException: Could not load file or assembly 'Perl5Interpreter' or one of its dependencies. The system cannot find the file specified.␤File name: 'Perl5Interpreter'␤  at System.AppDomain.Load (System.String assembly…

[12:57] <jnthn> Wow. First NPMCA in a while. :)

[12:57] <masak> we're pretty good at shielding ourselves from them nowadays.

[12:57] *** _ilbot left
[12:57] <masak> much thanks to 6model, I guess.

[12:57] <masak> 6model++

[12:57] *** _ilbot joined
[12:58] <jaffa4> What is NPMCA?

[12:58] <masak> Null PMC Access.

[12:59] <jaffa4> internal jargon

[13:00] <masak> yeah, there was a time when we had so many of them that we got tired of saying the full name.

[13:00] <moritz> r: say pir::null()

[13:00] <masak> I've heard Java peeps say NPE, too.

[13:00] <p6eval> rakudo 442db9: OUTPUT«use of uninitialized value of type Mu in string context  in method Str at src/gen/CORE.setting:667␤␤use of uninitialized value of type Mu in string context  in method Str at src/gen/CORE.setting:667␤␤===SORRY!===␤error:imcc:syntax error, unexpected '\n'␤    in file '(…

[13:01] <moritz> r: say pir::null__P()

[13:01] <p6eval> rakudo 442db9: OUTPUT«Null PMC access in find_method('gist')␤  in sub say at src/gen/CORE.setting:6482␤  in block <anon> at /tmp/x5o7v_yi5z:1␤␤»

[13:01] * masak packs moritz up and sends him into RT :)

[13:01] *** benabik left
[13:02] * moritz waves to everybody on the way

[13:04] *** Timbus joined
[13:06] <masak> I put moritz in RT #112474

[13:07] * moritz kannot be loaded. OH NOEZ! What have you done to me?

[13:07] <masak> I fibbed. I didn't actually.

[13:08] <masak> you were too big to fit in an email attachment ;)

[13:09] <moritz> r: 3e9 / 8 / 1024 # size of human genome in kb

[13:09] <p6eval> rakudo 442db9:  ( no output )

[13:09] <moritz> r: say 3e9 / 8 / 1024 # size of human genome in kb

[13:09] <p6eval> rakudo 442db9: OUTPUT«366210.9375␤»

[13:09] <masak> that's for *one* cell.

[13:09] <moritz> erm, modulo some constant factors :-)

[13:13] *** mtk left
[13:15] *** spider-mario joined
[13:21] *** mucker left
[13:24] *** plobsing left
[13:32] <masak> r: say [/] 3e9, 8, 1024

[13:32] <p6eval> rakudo 442db9: OUTPUT«366210.9375␤»

[13:32] *** kaleem left
[13:34] *** bacek left
[13:35] *** PacoAir joined
[13:38] <jaffa4> Is it possible to enumarate enums?

[13:39] <[Coke]> r: say Bool.pick(*)

[13:39] <p6eval> rakudo 442db9: OUTPUT«True False␤»

[13:39] <[Coke]> r: say Bool.enum.perl

[13:39] <p6eval> rakudo 442db9: OUTPUT«Method 'enum' not found for invocant of class 'Bool'␤  in block <anon> at /tmp/PYD1khAgt0:1␤␤»

[13:39] *** JimmyZ left
[13:40] *** dakkar left
[13:40] <[Coke]> well, there's one way, anyway. ;)

[13:41] <masak> r: enum A <a b c d>; say A.enums.perl

[13:41] <p6eval> rakudo 442db9: OUTPUT«("a" => 0, "b" => 1, "c" => 2, "d" => 3).hash␤»

[13:41] <colomon> r: say Bool.list.Num

[13:41] <p6eval> rakudo 442db9: OUTPUT«1␤»

[13:41] *** kaleem joined
[13:41] <colomon> r: say +(Bool.list)

[13:41] <p6eval> rakudo 442db9: OUTPUT«1␤»

[13:41] <colomon> :\

[13:42] <[Coke]> r: say Bool.list

[13:42] <p6eval> rakudo 442db9: OUTPUT«use of uninitialized value of type Bool in string context  in method Str at src/gen/CORE.setting:667␤␤␤»

[13:42] <jaffa4> That is printing, how to enumate?

[13:43] <jaffa4> r: enum A <a b c d>; pritn A.hash;

[13:43] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&pritn' called (line 1)␤»

[13:43] <jnthn> r: say Bool.enums.perl

[13:43] <p6eval> rakudo 442db9: OUTPUT«("False" => 0, "True" => 1).hash␤»

[13:43] <jaffa4> r: enum A <a b c d>; print A.hash;

[13:43] <p6eval> rakudo 442db9: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:5781␤  in method hash at src/gen/CORE.setting:1033␤  in block <anon> at /tmp/pnmfY_FeY3:1␤␤»

[13:44] <jnthn> [Coke]: You got "enum", not "enums"

[13:44] <jnthn> enum A <a b c>; for A.enums -> $val { say $val }

[13:44] <jnthn> r: enum A <a b c>; for A.enums -> $val { say $val }

[13:44] <p6eval> rakudo 442db9: OUTPUT«"a" => 0␤"b" => 1␤"c" => 2␤»

[13:44] <colomon> r: say Bool.enums.Num

[13:44] <p6eval> rakudo 442db9: OUTPUT«2␤»

[13:45] <colomon> r: say Bool.enums.Int

[13:45] <p6eval> rakudo 442db9: OUTPUT«2␤»

[13:45] <colomon> r: enum A <a b c>;  say A.enums.Int

[13:45] <p6eval> rakudo 442db9: OUTPUT«3␤»

[13:45] <masak> colomon: I think +Bool.list *should* be 1.

[13:45] <masak> colomon: it's mixing up levels a bit to assume an enum type object should listify to its enums.

[13:46] <masak> the type object has more "integrity" than that, if you will.

[13:46] <colomon> r: say Bool.list.perl

[13:46] <p6eval> rakudo 442db9: OUTPUT«(Bool,).list␤»

[13:46] <colomon> makes sense, I gues

[13:46] <colomon> s

[13:46] *** kaleem left
[13:46] * jnthn agrees with masak

[13:47] <masak> there's a general principle here that I can't quite put into words.

[13:47] <masak> but I find APIs where objects are polymorphic and "collapse" into arrays and hashes that are completely different from the original object... slightly tiring.

[13:48] <masak> better to have explicit methods and a container/containee relation.

[13:48] <jaffa4> r: enum A <a b c d>; print Ac;

[13:48] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Ac' called (line 1)␤»

[13:48] <jaffa4> r: enum A <a b c d>; print c;

[13:48] <p6eval> rakudo 442db9: OUTPUT«c»

[13:48] <masak> r: enum A <a b c d>; print A::c

[13:48] <p6eval> rakudo 442db9: OUTPUT«c»

[13:49] <jaffa4> SHould not it print 2?

[13:49] *** skids joined
[13:50] <jaffa4> r: enum A <a b c d>; print $A::c;

[13:50] <p6eval> rakudo 442db9: OUTPUT«use of uninitialized variable $v of type Any in string context  in method Str at src/gen/CORE.setting:667␤␤»

[13:50] <jaffa4> r: enum A <a b c d>; print A.c;

[13:50] <p6eval> rakudo 442db9: OUTPUT«Method 'c' not found for invocant of class 'A'␤  in block <anon> at /tmp/gwDKzZjXzw:1␤␤»

[13:50] <masak> it's not a class or an object.

[13:50] <masak> it's a package.

[13:51] <masak> as to whether it should print 2, "no".

[13:51] <masak> not by spec.

[13:51] <jnthn> r: enum A <a b c d>; print +c;

[13:51] <p6eval> rakudo 442db9: OUTPUT«2»

[13:51] <masak> previous versions said it should. but it changed on that point.

[13:51] <jnthn> Just numify it if you want the numeric value.

[13:51] <masak> which I really like, because it means Bool::True stringifies to "True" :)

[13:52] <jaffa4> r: enum A <a b c d>; print +A.c;

[13:52] <p6eval> rakudo 442db9: OUTPUT«Method 'c' not found for invocant of class 'A'␤  in block <anon> at /tmp/JrcjSzxQef:1␤␤»

[13:52] <jaffa4> r: enum A <a b c d>; print +A::c;

[13:52] <p6eval> rakudo 442db9: OUTPUT«2»

[13:52] *** dakkar joined
[13:53] <jaffa4> n: enum A <a b c d>; print +A::c;

[13:53] <p6eval> niecza v16-21-g1b64073: OUTPUT«2»

[13:53] <jaffa4> n: enum A <a b c d>; print +c;

[13:53] <p6eval> niecza v16-21-g1b64073: OUTPUT«2»

[13:57] <jaffa4> n: enum A <a b c d>; print ~c;

[13:57] <p6eval> niecza v16-21-g1b64073: OUTPUT«c»

[13:59] *** dakkar left
[13:59] <masak> n: enum A <a b c d>; say ?c; say ?a

[13:59] <p6eval> niecza v16-21-g1b64073: OUTPUT«True␤False␤»

[14:01] *** NamelessTee left
[14:01] *** lloydf left
[14:07] <jaffa4> r: "a"~~ rx:P5/a/;

[14:07] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤Adverb P5 not allowed on rx␤at /tmp/hV040YCgV9:1␤»

[14:08] <jaffa4> std: "a"~~ rx:P5/a/;

[14:08] <p6eval> std 3d13d53: OUTPUT«ok 00:00 49m␤»

[14:08] <jaffa4> n: "a"~~ rx:P5/a/;

[14:08] <p6eval> niecza v16-21-g1b64073: OUTPUT«Unhandled exception: Autoloading NYI␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1366 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 4667 (Regex.tweak @ 6) ␤  at /home/p6eval/niecza/src/STD.pm6 line 500 (ANON @ 3) ␤  at /home/p6eval/niecza/sr…

[14:08] <masak> "Autoloading"?

[14:09] *** fsergot joined
[14:10] <fsergot> hi o/

[14:12] *** wtw left
[14:12] *** dakkar joined
[14:13] *** kaleem joined
[14:13] <masak> halo, fsergocie.

[14:14] <masak> jak się masz?

[14:15] <fsergot> masak: Dobrze. A Ty? :)

[14:16] *** snearch left
[14:17] <masak> też dobrze :)

[14:19] <masak> zajęty. ale dobrze. :)

[14:20] <jaffa4> everybody is alright.

[14:20] <jnthn> .oO( if you squint hard enough, it almost looks like Slovak )

[14:21] * masak .oO( if you squint hard enough, you can't see stuff )

[14:22] <jnthn> ETOOHARD :P

[14:23] * masak .oO( Perl makes easy squints easy, and hard squints possible )

[14:23] <fsergot> masak: Great! :)

[14:24] * masak grabs his Polish matura diploma and runs before the Google Translate scandal unravels

[14:24] *** plobsing joined
[14:25] *** PacoAir left
[14:32] *** mucker joined
[14:32] <tadzik> did I hear Polish?

[14:33] <tadzik> ...where did you get your Polish matura diploma?

[14:33] * tadzik looks for his

[14:39] *** NamelessTee joined
[14:46] *** tokuhirom left
[14:49] <masak> tadzik: I don't really have one. but it's fun to pretend that I know even the basics of Polish.

[14:49] <tadzik> :)

[14:49] <tadzik> I had fun pretending to know German on the Datev event on GPW

[14:49] <tadzik> "Bier, ja ja, naturlich"

[14:50] <tadzik> naturlich, I didn't understand a single word this lady was saying :)

[14:50] <moritz> it worked pretty well :-)

[14:50] <tadzik> I keep telling myself she didn't notice for some time :)

[14:50] <tadzik> until I was like "uhh, do you speak English?"

[14:51] <masak> did she? :)

[14:51] *** mucker left
[14:52] <tadzik> I'll probably never know :)

[14:53] *** simcop2387 left
[14:53] *** fsergot left
[14:55] *** simcop2387 joined
[14:55] <moritz> I think she thought you were drunk :-)

[14:57] <masak> *lol*

[15:04] *** birdwindupbird left
[15:04] *** kresike left
[15:08] *** fsergot joined
[15:14] *** mucker joined
[15:17] <tadzik> :P

[15:21] *** att joined
[15:26] *** kaleem left
[15:26] *** vlixes joined
[15:30] *** spaceships joined
[15:30] *** bluescreen10 left
[15:31] *** spaceships left
[15:34] *** zpmorgan joined
[15:37] *** benabik joined
[15:38] * cognominal is looking at deserialization code and find suspicious doubletons like two    push string_heap, "perl6"    that appear in sequence. Apparently this is not harmful, but is it useful?   jnthn?

[15:41] <PerlJam> Have you guys seen this?  http://www.chris-granger.com/2012/04/12/light-table---a-new-ide-concept/

[15:43] <jnthn> cognominal: No, but the code that eliminates dupes was causing some people segfaults.

[15:44] <jnthn> So that optimization was backed out for the time being.

[15:47] *** fglock left
[15:47] <cognominal> ok

[15:49] <cognominal> p6:   my int @a;  @a = (3,2);  say @a[0].perl

[15:49] <p6eval> niecza v16-21-g1b64073: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed my at /tmp/huPPHMGrl6 line 1:␤------> [32mmy[33m⏏[31m int @a;  @a = (3,2);  say @a[0].perl[0m␤␤Parse failed␤␤»

[15:49] <p6eval> ..rakudo 442db9: OUTPUT«Method 'STORE' not found for invocant of class 'Integer'␤  in block <anon> at /tmp/hIXsvlnc9U:1␤␤»

[15:49] <p6eval> ..pugs: OUTPUT«\3␤»

[15:50] <cognominal> this is not new but not sure it has ever been filed as a bug.

[15:50] *** bluescreen10 joined
[15:51] *** Patterner left
[15:51] <masak> r: my int @a = (3, 2)

[15:51] <p6eval> rakudo 442db9: OUTPUT«Method 'STORE' not found for invocant of class 'Integer'␤  in block <anon> at /tmp/tJ3mC1rBJN:1␤␤»

[15:51] <masak> r: my int @a = (3)

[15:51] <p6eval> rakudo 442db9: OUTPUT«Method 'STORE' not found for invocant of class 'Integer'␤  in block <anon> at /tmp/x13H9zDQer:1␤␤»

[15:51] <masak> r: my int @a = 3

[15:51] <p6eval> rakudo 442db9: OUTPUT«Method 'STORE' not found for invocant of class 'Integer'␤  in block <anon> at /tmp/pvcw3mffBF:1␤␤»

[15:51] <cognominal> p6: my Int @a; my $a= 1 but False; @a = ( $a,2);  say ?@a[0]

[15:51] <p6eval> rakudo 442db9, niecza v16-21-g1b64073: OUTPUT«False␤»

[15:51] <p6eval> ..pugs: OUTPUT«*** Cannot cast from VBool False to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[15:51] <masak> r: my int @a; say "alive"

[15:51] <p6eval> rakudo 442db9: OUTPUT«alive␤»

[15:52] <cognominal> it works great for non native types.

[15:53] *** Psyche^ joined
[15:53] *** Psyche^ is now known as Patterner

[15:54] *** kaleem joined
[15:56] <jnthn> There's already an RT for compact arrays being NYI

[15:56] <cognominal> ok

[16:05] *** brrt left
[16:07] *** thelazydeveloper joined
[16:08] *** spaceships joined
[16:11] <arnsholt> jnthn: In bind_boxed, any good reason accessor_call(value, "type") should return NULL?

[16:13] <[Coke]> rakudodevs: any comments on nine's threading branch?

[16:13] <jnthn> arnsholt: Is that not missing an interp argument?

[16:13] <jnthn> arnsholt: What what type is value?

[16:14] <jnthn> arnsholt: It will return NULL if there's no type method, iirc.

[16:14] *** fhelmberger left
[16:17] <jnthn> [Coke]: I'm curious if it's able to create a thread from within a running Rakudo program and run some code on it.

[16:17] <jnthn> [Coke]: Looks like no Windows support yet though.

[16:19] <arnsholt> jnthn: The interp is there in my code (omitted due to laziness)

[16:20] <arnsholt> The value should be a CArray (I think), or at least that's the RHS of the bind operator in my code

[16:20] *** att left
[16:22] <jnthn> arnsholt: huh, you'd only call .type on an attribute meta-object

[16:23] <arnsholt> Oh, right. That would explain a lot =)

[16:23] <jnthn> arnsholt: If you need the type object of the value, just STABLE(value)->WHAT

[16:23] *** alester joined
[16:23] *** plobsing left
[16:24] <arnsholt> Oooh. A lot easier, that

[16:24] <jnthn> ;)

[16:24] <jnthn> Yes, I did try to make 6model relatively nice to interact with in C-land too :)

[16:25] <[Coke]> jnthn: yah, I was hoping maybe you could point nine at the right API for windows. ;)

[16:26] <[Coke]> bother. I can add a Rat that takes an epsilon that is ignored (pugs), but I cannot seem to invoke it. At least it's compiling now.

[16:32] <[Coke]> pugs> 3.Rat(234)

[16:32] <[Coke]> 3/1

[16:34] *** kaleem left
[16:42] *** estrabd joined
[16:48] *** mucker left
[16:49] *** att joined
[16:49] <dalek> Pugs.hs: adac868 | coke++ | Pugs/src/Pugs/Prim.hs:

[16:49] <dalek> Pugs.hs: Add .Rat($epsilon)

[16:49] <dalek> Pugs.hs: 

[16:49] <dalek> Pugs.hs: just ignore $epsilon for now.

[16:49] <dalek> Pugs.hs: 

[16:49] <dalek> Pugs.hs: Closes #16

[16:49] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/adac868f51

[16:51] *** kaleem joined
[16:51] *** kaleem left
[16:52] *** kaleem joined
[16:53] *** estrabd left
[16:55] *** PacoAir joined
[16:56] *** estrabd joined
[16:57] <[Coke]> \o/

[16:59] <[Coke]> p6: say (0+2i).WHAT

[16:59] <p6eval> rakudo 442db9, niecza v16-21-g1b64073: OUTPUT«Complex()␤»

[16:59] <p6eval> ..pugs: OUTPUT«Complex␤»

[17:00] <[Coke]> colomon: why are there tests that have (0+2i).Complex in S32-trig ?

[17:01] <[Coke]> what is the coercion there buying us?

[17:01] <geekosaur> was there a Gaussian integer type at one point?

[17:01] <colomon> simplicity for the test code generator

[17:01] <[Coke]> colomon: arglebargle. Ok.

[17:02] <colomon> It probably can be improved.  But then, Complex.Complex should be pretty darned easy to implement.  ;)

[17:07] <[Coke]> done. now I need Rat.Str 

[17:10] <[Coke]> p: say 3.Rat.Str

[17:10] <p6eval> pugs: OUTPUT«*** No such method in class Rat: "&Str"␤    at /tmp/ZEe1p2xBAe line 1, column 5 - line 2, column 1␤»

[17:10] <[Coke]> p: say 3.Str

[17:10] <p6eval> pugs: OUTPUT«*** No such method in class Int: "&Str"␤    at /tmp/8YD_p3IRaS line 1, column 5 - line 2, column 1␤»

[17:12] *** dakkar left
[17:13] <[Coke]> (and then bless, and FatRat, and asin).

[17:14] <colomon> [Coke]++

[17:18] *** flussence_ joined
[17:18] <[Coke]> I didn't say I was DOING it. :P

[17:19] *** flussence left
[17:21] *** thou joined
[17:23] *** flussence_ left
[17:24] *** flussence joined
[17:24] *** plobsing joined
[17:25] <[Coke]> I think we're going to end up with some failing tests here just to get all the simple math ones passing, but I think that's ok.

[17:25] <[Coke]> (ok, I am doing it. ;)

[17:34] *** tokuhirom joined
[17:35] *** noam left
[17:37] *** noam joined
[17:37] <spider-mario> what would be an idiomatic way of getting the effect of “xx” in Perl 5?

[17:38] <PerlJam> spider-mario: ("foo") x 5

[17:38] <spider-mario> oh, that works on lists?

[17:38] <spider-mario> thanks a lot :D

[17:41] <dalek> Pugs.hs: 1f8d97f | coke++ | Pugs/src/Pugs/Prim.hs:

[17:41] <dalek> Pugs.hs: add Complex.Complex

[17:41] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/1f8d97f1bb

[17:41] <dalek> Pugs.hs: f7180f8 | coke++ | Pugs/src/Pugs/Prim.hs:

[17:41] <dalek> Pugs.hs: add acos, asin

[17:41] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/f7180f88f4

[17:41] <dalek> Pugs.hs: 740cde8 | coke++ | Pugs/src/Pugs/Prim.hs:

[17:41] <dalek> Pugs.hs: add basic .Str

[17:41] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/740cde8081

[17:41] <dalek> Pugs.hs: 17e95c9 | coke++ | t/update_passing_test_data.pl:

[17:41] <dalek> Pugs.hs: (temporary?) update to show planned # of tests.

[17:41] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/17e95c9606

[17:42] <[Coke]> still need a (noop is fine) bless, and a FatRat (which I'm probably just going to make an alias for Rat for now.)

[17:50] *** thou left
[17:50] *** kaleem left
[17:50] *** daxim left
[17:58] *** leprevost joined
[18:02] <masak> geekosaur: I don't think the spec ever had gaussian ints.

[18:03] <masak> geekosaur: but it's very easy to make such a type in userland.

[18:03] <[Coke]> masak: I assumed his question was an answer to my question.

[18:03] <masak> or you could just restrict Complex to having integral re and im parts. :)

[18:04] * geekosaur vaguely recalled *something* having a distinct gaussian int type, which would explain a coercion of what looked like a gaussian int to a full complex

[18:04] <jaffa4> I made an on-line test for Perl 6 for people. You can test yourself if you know Perl 6 well enough or not. link: tests.equinoxbase.com/test.pl

[18:05] * TimToady doesn't think anyone here knows Perl 6 well enough...  :)

[18:05] <jaffa4> You excepted I guess

[18:06] *** benabik left
[18:06] *** benabik_ joined
[18:06] *** benabik_ is now known as benabik

[18:09] *** benabik_ joined
[18:09] *** benabik left
[18:09] *** benabik_ is now known as benabik

[18:09] <masak> jaffa4: there seems to be checkbox interference between questions 5 and 6. I checked a box in question 5, and it was still checked in question 6.

[18:09] *** |newbie| joined
[18:10] <moritz> r: print [+] 1,3,4,9;

[18:10] <p6eval> rakudo 442db9: OUTPUT«17»

[18:10] <|newbie|> on cheating

[18:11] <moritz> CHEATING IS TECHNIQUE

[18:11] *** jaffa4 left
[18:11] <jnthn> wtf, I only got 53.85%!

[18:11] <spider-mario> the program didn’t accept “add multi in front of both” + “add multi in front of the second one”

[18:12] <spider-mario> technically, if you need to append it before both, you need to append it before the second one

[18:12] <spider-mario> ;)

[18:12] <|newbie|> I am not getting you

[18:13] <moritz> erm, wtf

[18:13] <moritz> it would be nice to see a summary of what one is supposed to have done wrong

[18:14] <masak> japhb: I got 50.64%: https://gist.github.com/2400447

[18:14] <masak> er, jaffa4.

[18:14] <masak> oh, he left.

[18:14] <moritz> I hope @a= <1 5 7 9 10>; isn't supposed to be a valid answer

[18:14] <masak> that question was vague.

[18:14] *** |newbie| is now known as jaffa5

[18:14] <jaffa5> it is

[18:14] <moritz> because it's not the same as 1, 5, 7, 9, 10

[18:14] <jaffa5> I thought it is

[18:14] <moritz> p6: say <1 5 7 9 10>.perl

[18:14] <p6eval> pugs, rakudo 442db9: OUTPUT«("1", "5", "7", "9", "10")␤»

[18:14] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«(val("1"), val("5"), val("7"), val("9"), val("10"))␤»

[18:14] <jnthn> I got 0% for classes. I should learn about them. :)

[18:15] <spider-mario> jaffa5 : I’m talking about http://i.imgur.com/2Y1Oe.png

[18:15] <moritz> jaffa5: well, you're wrong

[18:15] <masak> jnthn: *lol*

[18:15] <masak> jaffa5: you should check the validity of the questions I got wrong.

[18:15] <masak> jaffa5: I don't know what numbers they correspond to, but you probably do.

[18:15] <jaffa5> It does so

[18:15] <moritz> it's no fun to take wrong/imprecise tests

[18:16] <jaffa5> I tried to make it precise

[18:16] <masak> you're getting feedback now.

[18:16] <masak> it needs more precision.

[18:18] <masak> jaffa5: here's what's funny about jnthn getting 0% on classes: he is the guy who took S12 (about OO) and implemented it more or less single-handedly in Rakudo. what's your estimation that your quiz is right and he's wrong? :)

[18:18] <jaffa5> no, the program says that

[18:18] <jaffa5> kill the program

[18:19] <moritz> r: say 1.WHAT.^name

[18:19] <p6eval> rakudo 442db9: OUTPUT«Int␤»

[18:19] <jnthn> Yeah, I ticked that as avlid

[18:20] <masak> jaffa5: could you publish the "correct" answers somewhere? that's easier than a bunch of us reverse-engineering them.

[18:20] <jnthn> and the 1.^name

[18:20] <masak> jnthn: me too.

[18:20] <moritz> jnthn: I know

[18:20] * jnthn goes to eat stuff, back in a bit. Probably with a tuit or two :)

[18:20] *** jaldhar left
[18:20] *** jaldhar joined
[18:21] <jaffa5> jif you publish the correct answer, it is not going to be a test anymore

[18:21] * masak takes some deep breaths

[18:21] <moritz> well, if you miscredit answers it's not a test either

[18:21] <masak> jaffa5: but we have strong reason to believe that some of the answers you put in there are wrong.

[18:22] <cognominal> jnthn, I have refreshed blizkost. It passes tests.    The diff :  https://gist.github.com/2400493

[18:22] <masak> jaffa5: for all the reasons stated above.

[18:22] <jaffa5> I will extend it , so that it will explain the right answers and  the bad ones

[18:22] <masak> jaffa5: sounds good. but that's just a complicated version of showing us the answers directly.

[18:22] <moritz> r: constant %h = (a => 1, b => ").hash

[18:22] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix => instead at line 1, near " \").hash"␤»

[18:22] <moritz> r: constant %h = (a => 1, b => 2).hash

[18:22] <p6eval> rakudo 442db9:  ( no output )

[18:22] <masak> still, better than nothing.

[18:22] <moritz> r: constant %h = (a => 1, b => 2).hash; say %h.perl

[18:22] <p6eval> rakudo 442db9: OUTPUT«("a" => 1, "b" => 2).hash␤»

[18:23] <moritz> r: constant %h = (a => 1, b => 2).hash; INIT { say %h.perl }

[18:23] <p6eval> rakudo 442db9: OUTPUT«("a" => 1, "b" => 2).hash␤»

[18:23] <moritz> wow, when has that been fixed?

[18:23] <masak> was it once broken?

[18:23] <moritz> yes

[18:23] <masak> r: constant %h = (a => 1, b => 2).hash; CHECK { say %h.perl }

[18:23] <p6eval> rakudo 442db9: OUTPUT«("a" => 1, "b" => 2).hash␤»

[18:23] <moritz> there used to be no way to create a hash at compile time

[18:23] <masak> r: constant %h = (a => 1, b => 2).hash; BEGIN { say %h.perl }

[18:23] <p6eval> rakudo 442db9: OUTPUT«("a" => 1, "b" => 2).hash␤»

[18:23] <masak> wow!

[18:23] <masak> that's really early!

[18:23] <moritz> r: constant %h = (a => 1, b => 2); CHECK { say %h.perl }

[18:23] <p6eval> rakudo 442db9: OUTPUT«("a" => 1, "b" => 2)␤»

[18:24] <moritz> that's still wrong though

[18:24] <masak> aye.

[18:24] <moritz> (RT #111944)

[18:24] <masak> r: constant Int $x = 42; CHECK { say $x }

[18:24] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤Missing initializer on constant declaration␤at /tmp/kECJtXbY5E:1␤»

[18:24] <masak> heh?

[18:24] <masak> std: constant Int $x = 42; CHECK { say $x }

[18:24] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing initializer on constant declaration at /tmp/QJRFBJ3vw_ line 1:␤------> [32mconstant Int [33m⏏[31m$x = 42; CHECK { say $x }[0m␤Two terms in a row at /tmp/QJRFBJ3vw_ line 1:␤------> [32mconstant Int [33m⏏[31m$x = 42; CHECK …

[18:24] <moritz> it parses it as  (constant Int) # missing initiliazer

[18:24] <masak> oh!

[18:25] <masak> r: constant $x = 42; CHECK { say $x }

[18:25] <p6eval> rakudo 442db9: OUTPUT«42␤»

[18:25] *** leprevost left
[18:25] <masak> r: my constant Int $x = 42; CHECK { say $x }

[18:25] <p6eval> rakudo 442db9: OUTPUT«===SORRY!===␤Missing initializer on constant declaration␤at /tmp/s023c8tcIq:1␤»

[18:25] <masak> there's no way to type constants?

[18:25] <moritz> nope

[18:26] *** jaldhar left
[18:26] <jaffa5> masak: not sure about what you wrote earlier... it is just a compilcated way of showing answers directly?

[18:26] <jaffa5> all tests are like that

[18:26] <[Coke]> jaffa5: he's trying to help you improve the quality of your test. You're making it difficult.

[18:27] <masak> jaffa5: I/we believe you got some of the answers wrong when you created the test.

[18:27] <[Coke]> If you don't want the core team to help you fix your test so that it's correct, that's fine, but I'm not sure what your expectation here is.

[18:27] <jaffa5> masak: ok

[18:27] <masak> jaffa5: I've already taken the test. you're not spoiling it for me. take any measures you feel are necessary to hide the answers from others but show them to me.

[18:28] <masak> if not, you are indeed making it difficult for me to help you.

[18:28] <jaffa5> ok, wait a sec

[18:28] <masak> [Coke]++ # diplomacy

[18:29] *** uvtc joined
[18:32] *** thou joined
[18:34] <uvtc> Hi #perl6. Can anyone tell me how to fix this: http://paste.pocoo.org/show/582533/ ?

[18:35] <jnthn> cognominal: You already have a commit bit there :)

[18:36] <cognominal> ok

[18:36] *** lichtkind joined
[18:37] *** leprevost joined
[18:40] <moritz> uvtc: you probably want curly braces after the =>, not [

[18:40] <spider-mario> (the outer =>)

[18:41] <uvtc> Ah, that got me further. Thanks, moritz.

[18:42] <uvtc> In all the examples of hashes I've seen so far, they always look like this: `my %h = 'a' => 1, 'b' => 2;`. That is, no commas, and no curlies required. What do the curlies do (in the context here)?

[18:43] <moritz> uvtc: in 'my %h = ...', it's the assignment to a hash variable that creates the hash. If you don't do that, you need { ... } to create a hash

[18:43] <moritz> a => 1, b => 2 per se is just a list of Pair objects

[18:43] <uvtc> (Oh, nice. Also, just had to change the "append" to "push", and everything works. :) )

[18:44] <uvtc> moritz, Oh, of course. Thanks!

[18:44] <lichtkind> uvtc: hai , yes i was not that responsive but i hope it gets better soon

[18:46] <uvtc> lichtkind, hi.

[18:46] <uvtc> lichtkind, Did you have a look at the generated html?

[18:47] <uvtc> lichtkind, Oops. Sorry, should take this offline.

[18:47] <jaffa5> spider-mario: I added the word "only" to the cases you found unclear.

[18:48] <uvtc> lichtkind, re responsiveness, n/p

[18:50] <cognominal> now, I will try to see why panda does not install zavolaj

[18:51] <cognominal> "not in the ecosystem"

[18:53] <cognominal> blatant lie

[18:55] <[Coke]> seen au?

[18:55] <aloha> au was last seen in #perl6 1 days 9 hours ago saying ". o O ( whetstones )".

[18:56] <[Coke]> p6: say sin(3).Rat

[18:56] <p6eval> pugs: OUTPUT«0.141120008059867213523475015790609177202␤»

[18:56] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«0.14111922141119221␤»

[18:56] <p6eval> ..rakudo 442db9: OUTPUT«0.141119221411192␤»

[18:57] <[Coke]> p6: say sin(3).Rat.perl

[18:57] <p6eval> rakudo 442db9: OUTPUT«58/411␤»

[18:57] <p6eval> ..pugs: OUTPUT«5084384125703515/36028797018963968␤»

[18:57] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«<58/411>␤»

[18:57] <[Coke]> I'd say that's pretty Fat(Rat).

[18:58] <au> [Coke]: I'm fading fast, after staying up a night translating http://allisonrandal.com/2012/04/15/open-source-enlightenment/ into https://gist.github.com/2400315

[18:58] <au> but please feel free to typeahead anything you'd like me to help with :)

[18:59] *** GlitchMr joined
[18:59] *** sporous left
[18:59] *** sporous joined
[19:02] <masak> ooh, 繁體字！

[19:02] <spider-mario> ~glitchmr@….adsl.inetia.pl

[19:03] <spider-mario> .pl? :D

[19:03] <cognominal> how can I get the whole stack trace when I get :  use of uninitialized value of type Command in string context  in method Str at src/gen/CORE.setting:667

[19:03] <GlitchMr> spider-mario, yes

[19:03] <spider-mario> that sounds appropriate

[19:03] <moritz> cognominal: CONTROL { say $!.backtrace.nice }

[19:03] <masak> cognominal: --ll-exception ?

[19:03] <moritz> or .full if you're a bit more paranoid

[19:04] <cognominal> masak++ moritz++

[19:04] <moritz> r: CONTROL { say $!.backtrace.nice }; ~Any

[19:04] <p6eval> rakudo 442db9: OUTPUT«Method 'backtrace' not found for invocant of class 'Any'␤  in block <anon> at /tmp/3Z_eGnRUwI:1␤␤»

[19:04] <moritz> r: CONTROL { say .backtrace.nice }; ~Any

[19:04] <p6eval> rakudo 442db9: OUTPUT«  in method Str at src/gen/CORE.setting:667␤  in method Stringy at src/gen/CORE.setting:674␤  in sub prefix:<~> at src/gen/CORE.setting:957␤  in block <anon> at /tmp/9cpXsFcUB0:1␤␤use of uninitialized value of type Any in string context  in method Str at src/gen/CO…

[19:04] <moritz> cognominal: sorry, $_ not $!

[19:05] <moritz> I *always* do that wrong

[19:06] *** birdwindupbird joined
[19:07] *** tokuhirom left
[19:10] <uvtc> At some point did Perl 6 support calling fn's with a colon, as in `my-func: 3`?

[19:10] <moritz> that's the so-called "indirect method syntax"

[19:10] <tadzik> doesn't it now?

[19:11] <moritz> it's specced, but rakudo doesn't implement it

[19:11] <masak> std: use MONKEY_TYPING; augment class Int { method my-func {} }; my-func: 5

[19:11] <p6eval> std 3d13d53: OUTPUT«Compiled lib/MONKEY_TYPING.pm6␤ok 00:00 41m␤»

[19:11] <TimToady> p6 has never specced *functions* with colons that I can recall

[19:12] <tadzik> ha! The use of uninitialized value of type Command in string context in panda comes from gen-usage()

[19:13] * tadzik tries a fix

[19:13] <uvtc> Well, that's what's strange. In this script http://paste.pocoo.org/show/582562/ , it works. But in this one http://paste.pocoo.org/show/582565/ it gives me an error.

[19:13] <uvtc> That little script gives me:

[19:14] <uvtc> ===SORRY!===

[19:14] <uvtc> Confused

[19:14] <uvtc> at ./bar.pl6:1

[19:14] <TimToady> after all, a function with a colon is indistinguishable from a label

[19:14] <moritz> uvtc: yes, as I said, rakudo doesn't implement it

[19:14] <moritz> and, as also said, it would call a method, not a subroutine

[19:14] <cognominal> I have an account on feather but lost the password. how can I reset it?

[19:14] <moritz> cognominal: I can do that for yuo

[19:14] *** Chillance joined
[19:15] <cognominal> thx

[19:15] <uvtc> moritz, Oh, I didn't catch the difference there between method & function. Thanks.

[19:15] <moritz> cognominal: erm, what's your username on feather?

[19:15] <TimToady> masak: note that my-func: 5 is a label followed by a Useless use of constant 5

[19:15] <cognominal> moritz:  "cognominal" if the account still exists.

[19:15] <[Coke]> au: it would be awesome if you could setup a bless() function that would either 1) do what t/spec/S32-trig/sin.t needed it to do, or, barring that, 2) complete without throwing an exception.

[19:16] <moritz> cognominal: no such account or home directory. So I guess the account doesn't exist

[19:16] <[Coke]> I may try to hack at it again (for #2) later tonight.

[19:17] <uvtc> TimToady, If the function calling syntax doesn't allow the colon, why bother having method calling honor it?

[19:17] <masak> TimToady: is it always a label if it's \w ':' first in a statement?

[19:17] <cognominal> moritz, I have not used in years so I am not surprised it has been removed.

[19:17] <TimToady> because a function can be a listop without it, but a  method can't

[19:17] <moritz> cognominal: then contact Juerd to get a fresh account

[19:17] <moritz> I think instructions are on http://feather.perl6.nl/

[19:18] * moritz still remains highly suspicious of the indirect method syntax

[19:18] <cognominal> moritz, thx

[19:18] <TimToady> masak: yes, provided the ':' isn't part of some longer token

[19:18] <moritz> though that was  methodname $invocant: rest, of, args,  right?

[19:19] <masak> oh, right.

[19:19] <TimToady> yes, it's quite unambiguous, at least compared to P5

[19:19] <masak> std: use MONKEY_TYPING; augment class Int { method my-func {} }; my-func 5:

[19:19] <p6eval> std 3d13d53: OUTPUT«ok 00:00 42m␤»

[19:19] * jnthn wonders what it'd take to parse it.

[19:19] <masak> \o/

[19:19] <masak> std: my-func 5:

[19:19] <p6eval> std 3d13d53: OUTPUT«ok 00:00 42m␤»

[19:19] <jnthn> (In Rakudo)

[19:19] <masak> heh, it's a method call. don't need to declare the method :P

[19:19] <TimToady> here's all it does: look to see if the first comma is really a colon, and if so, it's an invocant

[19:20] <TimToady> easy peasy

[19:20] <jnthn> Hm.

[19:20] <jnthn> You almost make it sound like LHF... :P

[19:20] * jnthn will take a peek once he's done with the last pseudo-packages

[19:20] <moritz> std: m 5: 7: 1

[19:20] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Alphanumeric character is not allowed as delimiter at /tmp/lWdqcAvrWD line 1:␤------> [32mm [33m⏏[31m5: 7: 1[0m␤Parse failed␤FAILED 00:00 40m␤»

[19:20] <moritz> std: mymethod 5: 7: 1

[19:20] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal use of colon as invocant marker at /tmp/hAwYe8LmLX line 1:␤------> [32mmymethod 5: 7:[33m⏏[31m 1[0m␤Check failed␤FAILED 00:00 42m␤»

[19:21] <masak> std: a b 2: 5:

[19:21] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal use of colon as invocant marker at /tmp/Sl2YzfHtac line 1:␤------> [32ma b 2: 5:[33m⏏[31m<EOL>[0m␤Undeclared routine:␤   'a' used at line 1␤Check failed␤FAILED 00:00 42m␤»

[19:21] <masak> std: a b 2: :

[19:21] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Preceding context expects a term, but found infix : instead at /tmp/3PSfVdZGm8 line 1:␤------> [32ma b 2: [33m⏏[31m:[0m␤Parse failed␤FAILED 00:00 42m␤»

[19:21] <masak> std: a (b 2:):

[19:21] <p6eval> std 3d13d53: OUTPUT«ok 00:00 42m␤»

[19:21] <jnthn> std: 1 : 2

[19:21] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal use of colon as invocant marker at /tmp/AFKPy5e3ZO line 1:␤------> [32m1 :[33m⏏[31m 2[0m␤Check failed␤FAILED 00:00 41m␤»

[19:22] <jnthn> ...infix : ?

[19:22] <TimToady> yes, parsed as a fancy comma

[19:22] <TimToady> that easily-peasily turns into an invocant marker

[19:22] <uvtc> syntactic cologne

[19:22] <skids> groan

[19:23] *** samlt joined
[19:23] *** plobsing left
[19:24] <jnthn> :P

[19:24] <TimToady> it's also one of the many motivations for turning ?: into ??!!, or that : would be ambiguous

[19:24] <jnthn> aye

[19:25] <uvtc> skids, it's my understanding that #perl6 participants are allowed one awful joke and/or pun per diem. So, there, I've used mine up.

[19:25] <moritz> right, more puns are forbidden, by punishment of Nil

[19:25] <moritz> :-)

[19:27] <skids> uvtc: that one was bad enough to get expropriated, congrats.

[19:28] <TimToady> .oO(syntactic Köln)

[19:28] <uvtc> If you're going out on the town with a fancy comma, you need the cologne. [ducks]

[19:28] * masak .oO( syntactic line of pillars )

[19:29] <TimToady> though, since it's really rewriting the AST, it's more like semantic cologne...

[19:30] <masak> arborial cologne.

[19:30] <moritz> macrologogne

[19:30] <uvtc> Not sure if it was noticed before, but the error I get for trying to use the colon with a function call always tells me the problem is at line 1, regardless of where the offending cologne is.

[19:31] <masak> Perl 6 parsers are so slow, they just assume they're still on line 1 :P

[19:33] <TimToady> perl6: my Int constant $x = 42;

[19:33] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "constant"␤    expecting ":" or "("␤    at /tmp/2AF2hBpHgo line 1, column 8␤»

[19:33] <p6eval> ..rakudo 442db9:  ( no output )

[19:33] <p6eval> ..niecza v16-21-g1b64073: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/2yqY46vNUS line 1:␤------> [32mmy Int constant $x [33m⏏[31m= 42;[0m␤␤»

[19:33] <TimToady> perl6: my Int constant $x = 42; say $x

[19:33] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "constant"␤    expecting ":" or "("␤    at /tmp/_1VGr1BLr3 line 1, column 8␤»

[19:33] <p6eval> ..rakudo 442db9, niecza v16-21-g1b64073: OUTPUT«42␤»

[19:33] <TimToady> perl6: constant $x of Int = 42; say $x

[19:33] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "of"␤    expecting "?", "!", trait, "=", infix assignment or operator␤    at /tmp/jjSGyp06Vb line 1, column 13␤»

[19:33] <p6eval> ..rakudo 442db9, niecza v16-21-g1b64073: OUTPUT«42␤»

[19:33] <TimToady> sure you can type constants

[19:33] <jnthn> constants

[19:34] <jnthn> .oO( gee, I can! )

[19:34] <TimToady> see!

[19:34] <jnthn> fwiw, I'm not entirely sure Rakudo pays any attention to the "of" form 

[19:34] <jnthn> Actually...

[19:34] *** FACEFOX left
[19:34] <jnthn> How does the "of" form work? :)

[19:35] <jnthn> There's no container to apply the trait to...

[19:35] <TimToady> and yet there is a declarand

[19:35] <jnthn> hehe

[19:36] <jnthn> multi trait_mod:<of>(Mu $value, Mu:U $type) { $value ~~ $type or die "Type check failed ..." }

[19:36] <jnthn> ...no. :)

[19:37] <jnthn> Maybe there needs to be a ConstantDeclarand meta-object or something.

[19:37] <jnthn> Otherwise implementing export will be a problem too as we need to convey the name.

[19:37] <TimToady> the "constant" keyword lives in the 'sub' slot, so maybe that's a hint

[19:38] <jnthn> Well, for a sub we pass a Sub object.

[19:38] <jnthn> But constants aren't invokable in any sense, so I'd not expect it to be anything that's ~~ Code

[19:38] <moritz> std: constant a = 3; &a

[19:38] <p6eval> std 3d13d53: OUTPUT«ok 00:00 43m␤»

[19:38] <TimToady> though STD distinguishes type_declarator from routine_declarator, but they both are parsed at the same point

[19:39] <moritz> std: &a

[19:39] <p6eval> std 3d13d53: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'a' used at line 1␤Check failed␤FAILED 00:00 42m␤»

[19:39] * jnthn finds that std result bothersome

[19:40] <jnthn> nom: constant a = 3; say a; say &a

[19:40] <p6eval> rakudo 442db9: OUTPUT«3␤Nil␤»

[19:41] <TimToady> remember STD installs & variants for types so that you can talk about coercions as nouns

[19:41] <jnthn> Ah, for Int('eresting') ?

[19:41] <jnthn> OK

[19:41] <TimToady> std: &Int

[19:41] <p6eval> std 3d13d53: OUTPUT«ok 00:00 42m␤»

[19:42] <masak> I believe this to be an autopun: http://twitter.com/dwineman/status/191950031409000448

[19:42] * moritz calls the autopunpolice

[19:44] <felher> moritz: I implemented a few typed exceptions similar to those that are already in IO.pm. The problem is they return Nil and die if something went wrong. Seems quite a few spectest require the funcitons i wanted to implement to return Failure or True. Whats the way to go? Implement the new with True/Failure and keep those that alreay have typed exceptions as they are? Rewrite the old to not die with a typed

[19:44] <felher>  exception but return True/Failure instead?

[19:44] *** wooden_ left
[19:44] <uvtc> I think I recall heredocs being discussed here recently. That they're specced (<http://perlcabal.org/syn/S02.html#Heredocs>) but not yet implemented. Why does Perl 6 spec heredocs instead of using a multi-line quoting syntax (for example, Python's triple quotes)?

[19:45] <TimToady> because Python's triple quotes suck

[19:45] *** fgomez joined
[19:45] *** fgomez left
[19:45] *** fgomez joined
[19:45] <TimToady> and they are implemented in niecza

[19:45] <sjohnson> *gasp*

[19:45] <uvtc> What about them sucks?

[19:45] <masak> I thought triple quotes were for documentation.

[19:45] *** sivoais left
[19:46] <geekosaur> no, they actually poduce strings; just happens a string in void context works as documentation (compare Lisp)

[19:46] <TimToady> the point of heredocs is to use the line sequence out-of-band to the character sequence

[19:47] <TimToady> triple quotes, besides being ugly and inflexible, don't do that

[19:47] *** sivoais joined
[19:48] <uvtc> TimToady, I agree that using 3 quote marks together to mean a "quote" is ... not pretty.

[19:48] <TimToady> so you end up having to violate end-weight considerations to put any extra little arguments way down at the end

[19:48] <TimToady> pragmatically, heredocs are about end-weight

[19:49] *** benabik left
[19:50] <TimToady> process( q:to/END/, 2, 3 );  # let's you finish the thought with a promise of the first argument

[19:50] <TimToady> *lets

[19:50] <uvtc> TimToady, Oh. Right. That explanation sticks nicely. Thanks.

[19:51] <TimToady> and the fact that it's difficult to implement just reinforces the fact that Perl is designed to torment the implementors rather than the users

[19:53] <TimToady> n: say q:to/END/, 'done';␤  Indented stuff.␤  END␤

[19:53] <p6eval> niecza v16-21-g1b64073: OUTPUT«Indented stuff.␤done␤»

[19:53] <TimToady> niecza++ # implements trimming

[19:54] <masak> n: say q:to/END/, 'done';␤Oops, forgot to indent! Silly me.␤  END␤

[19:54] <p6eval> niecza v16-21-g1b64073: OUTPUT«Oops, forgot to indent! Silly me.␤done␤»

[19:54] <masak> that's wrong, I think.

[19:54] <TimToady> only if you think like a masak

[19:55] * masak .oO( bug! bug! bug! )

[19:55] * masak .oO( say it's a bug! come on! )

[19:55] <geekosaur> *files a masakbug*

[19:55] <TimToady> It might warrant a warning, but chopping non-whitespace off the front could be construed as needlessly unforgiving

[19:57] <masak> I meant more like, shouldn't the text itself be at least as indented as the end marker?

[19:57] <masak> I always thought so.

[19:57] <TimToady> in fact, this is discussed at S02:4321

[20:00] <colomon> spec++

[20:02] <masak> oh. only a warning.

[20:02] <masak> I think a warning might be too mild there.

[20:03] <TimToady> I'll let you off this time.

[20:04] *** leprevost left
[20:04] *** GlitchMr left
[20:04] <masak> but I don't hold that opinion strongly enough to get on the barricades, or blitz-patch the spec. :)

[20:05] <TimToady> well, you may s/may/must/, if you must

[20:08] <TimToady> nap &

[20:10] <masak> can I do s/warning/fatal warning/, too? :P

[20:11] *** benabik joined
[20:12] *** spider-mario left
[20:12] <masak> putting the end marker at a deeper indentation level than some of the text signifies a deep confusion which should probably be addressed before the program is run anyway.

[20:13] *** spider-mario joined
[20:13] <masak> it's close to choosing the wrong string delimiter at the end of a string.

[20:16] *** sivoais left
[20:18] *** plobsing joined
[20:20] *** sivoais joined
[20:23] *** sivoais left
[20:23] *** sivoais joined
[20:24] *** att left
[20:37] <dalek> rakudo/nom: f05a64d | moritz++ | src/core/Exception.pm:

[20:37] <dalek> rakudo/nom: class X::TypeCheck (not yet used)

[20:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f05a64db8e

[20:38] <moritz> felher: sorry, missed your question earlier. Return True or die seems like a reasonable approach

[20:39] <moritz> harmonizing the tests also seems reasonable

[20:39] *** att joined
[20:40] *** samlt left
[20:40] <felher> moritz: shall i rewrite the Copy and Rename to do True/die instead of Nil/die too? 

[20:40] <moritz> felher: yes, please

[20:40] <felher> moritz: kk, will do :)

[20:40] * moritz is excited that he isn't the only one anymore who takes care of such stuff

[20:41] *** jferrero left
[20:42] <jnthn> felher++

[20:43] <lichtkind> moritz: i know that feeling :)

[20:44] *** lichtkind left
[20:45] *** bacek joined
[20:45] *** lichtkind joined
[20:45] *** benabik left
[20:45] *** raiph joined
[20:45] <moritz> jnthn: fwiw it seems to be impossible to create a constant hash inside the setting, or to create a non-constant hash and then use it inside an INIT block 

[20:46] <felher> \o/ :)

[20:47] <felher> moritz: i will still ask you if something goes wrong and you probably still have to review my patches :)

[20:47] <felher> +though

[20:47] <moritz> felher: that's the way it always starts

[20:48] <felher> moritz: okay then :)

[20:48] <moritz> jnthn: https://gist.github.com/2401418 that's what happens if I try

[20:49] <moritz> code like   constant $x = ( 'X::TypeCheck' => sub ($operation, $got, $expected) { X::TypeCheck.new(:$operation, :$got, :$expected).throw },).hash;

[20:49] <jnthn> Hmm

[20:49] <jnthn> .oO( circularity sore )

[20:50] <moritz> is it normal for all those setting routines to show up as nqp;Perl6;World;prefix:<!> in the backtrace?

[20:50] <moritz> not all, only some of them, it seems

[20:51] <jnthn> That seems decidedly odd.

[20:51] <jnthn> oh, no

[20:51] <jnthn> It's not.

[20:51] <moritz> or even more precisely, most seem to come up twice, once with and once without that prefix

[20:51] <jnthn> It's jsut a side-effect of the dynamic compilation

[20:51] <jnthn> Yeah

[20:51] <jnthn> There's various bits of thunkery going on as it discovers stuff it's gotta run off and compile.

[20:52] <jnthn> Are you doing this after Hash is fully defined?

[20:52] <moritz> yes

[20:52] <moritz> this is in Exception.pm

[20:52] <moritz> which comes after Hash.pm

[20:52] <raiph> took jaffa's test; got 46%; was disappointed; then saw scores of jnthn and masak... ;)

[20:52] <phenny> raiph: 15 Apr 20:08Z <lichtkind> tell raiph thanks a lot uvtc is also currently helping me to decide but nothing final yet

[20:53] <moritz> raiph: I was somewhere around 50% too

[20:53] <lichtkind> raiph: hai

[20:54] <moritz> anyway, sleep time for me

[20:55] <moritz> zZzZz

[20:55] <raiph> gnight moritz

[20:56] *** birdwindupbird left
[20:56] <lichtkind> gut nacht

[20:58] *** benabik joined
[20:58] <jnthn> 'night, moritz 

[21:00] *** uvtc left
[21:02] *** orafu left
[21:02] *** orafu joined
[21:03] <masak> sweet sleeply, moritz.

[21:03] *** skids left
[21:06] <masak> p6: say "salmon live in trees and eat pencils".Bool

[21:06] <p6eval> pugs: OUTPUT«1␤»

[21:06] <p6eval> ..rakudo 442db9, niecza v16-21-g1b64073: OUTPUT«True␤»

[21:06] *** envi_ left
[21:09] <dalek> rakudo/nom: ef6fe01 | jnthn++ | src/ (2 files):

[21:09] <dalek> rakudo/nom: CORE, SETTING and UNIT.

[21:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef6fe01990

[21:09] <dalek> roast: fa50707 | jnthn++ | S02-names/pseudo.t:

[21:09] <dalek> roast: Unfudge.

[21:09] <dalek> roast: review: https://github.com/perl6/roast/commit/fa50707da1

[21:10] <benabik> masak: Maybe we should hook up Str.Bool to a natural language processor so it can evaluate the truth of the statement.

[21:10] <masak> I see absolutely no philosophical hurdles with that.

[21:10] <masak> or even technical ones.

[21:16] <dalek> rakudo/nom: 1501f51 | jnthn++ | docs/ChangeLog:

[21:16] <dalek> rakudo/nom: Update ChangeLog a little.

[21:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1501f51a06

[21:23] <lichtkind> raiph allright just tell me when you have time

[21:24] *** plobsing left
[21:24] *** bluescreen10 left
[21:24] <dalek> rakudo/nom: c4f9b1b | jnthn++ | docs/ROADMAP:

[21:24] <dalek> rakudo/nom: Remove various completed ROADMAP items.

[21:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c4f9b1b87a

[21:26] *** spider-mario left
[21:28] *** huf_ is now known as huf

[21:31] *** mdupont left
[21:33] *** fsergot left
[21:37] <tadzik> there is something abnormally satisfying in writing tests for Test:: modules

[21:37] <masak> yo dawg.

[21:38] <masak> I expect it's the same thrill as writing a bootstrapping compiler.

[21:38] <tadzik> I herd you like tests? ok()? ok()? ok()?

[21:38] <masak> :P

[21:39] <masak> so I put some tests in your tests: ok(ok(ok()))

[21:39] * tadzik giggles

[21:40] * tadzik wonders if https://github.com/tadzik/IO-Capture-Simple/blob/master/t/test-io-capture/01-basic.t#L10 is even correct

[21:40] *** bluescreen10 joined
[21:42] <masak> can you formulate a falsifiable hypothesis such that if it's not correct, you'd find out?

[21:42] *** benabik left
[21:43] *** brrt joined
[21:43] <tadzik> possibly

[21:44] <tadzik> I can break this tests, yes

[21:47] <masak> sounds like a good idea.

[21:48] *** att left
[21:48] *** ggoebel left
[21:49] *** snearch joined
[21:51] *** jaffa5 left
[21:51] *** PacoAir left
[21:52] *** ggoebel joined
[21:56] <felher> masak: was your question about a falsifiable hypothesis about something special or just a question to the world/channel/tadzik? :)

[21:57] <Tene> felher: responding to tadzik

[21:57] <felher> Tene: thanks :)

[22:01] <tadzik> good knight #perl6

[22:01] *** fgomez left
[22:01] *** fgomez joined
[22:01] *** NamelessTee left
[22:05] <felher> o/

[22:06] *** mdupont joined
[22:18] *** Araq joined
[22:23] *** plobsing joined
[22:23] *** localhost left
[22:25] *** localhost joined
[22:26] <jnthn> 'night o/

[22:37] *** Chillance left
[22:49] <lichtkind> good night

[22:58] <sorear> good * #perl6

[22:58] <sjohnson> hi

[23:00] <sjohnson> :)

[23:01] <sjohnson> everyday i learn multiple things about perl5, it almost makes me wonder if i'll be able to to undertake learning perl 6

[23:20] *** ilogger2 joined
[23:20] *** ChanServ sets mode: +v ilogger2

[23:24] *** Moukeddar joined
[23:35] *** Moukeddar left
[23:42] <lichtkind> vlixes: indeed :)

[23:42] <lichtkind> mayne said that :)

[23:42] <lichtkind> many

[23:42] <lichtkind> the perl 6 teblets are aimed to be an easy learnign

[23:42] <lichtkind> learning

[23:57] *** tokuhirom joined
[23:58] *** whiteknight joined
