[00:08] *** noam_ joined
[00:12] *** noam left
[00:14] *** whiteknight left
[00:18] *** whiteknight joined
[00:22] *** packetknife left
[00:24] *** awoodland left
[00:36] *** benabik joined
[00:54] *** havenn joined
[01:05] *** scott__ joined
[01:15] *** havenn left
[01:15] *** felipe joined
[01:18] *** PacoAir left
[01:22] *** bbkr left
[01:23] *** bbkr joined
[01:37] <sorear> good * #perl6

[01:37] <araujo> sorear, o/

[01:38] *** sivoais joined
[01:40] *** autarch joined
[01:41] <autarch> hi all ... I'm working on an article for LWN on the state of Perl 5, and I want to talk a bit about the relationship between 5 and 6

[01:41] <autarch> is there an official statement on this anywhere I can quote?

[01:41] <sorear> hello autarch

[01:41] <autarch> hi

[01:41] <sorear> TimToady: ping

[01:41] <autarch> yeah, a quote from Larry would be ideal

[01:41] *** gv left
[01:44] *** isBEKaml left
[01:51] *** odoacre left
[01:52] *** odoacre joined
[01:56] *** whiteknight left
[02:04] <autarch> http://paste.scsys.co.uk/184822

[02:04] <autarch> how does that seem?

[02:04] <autarch> http://paste.scsys.co.uk/184822?tx=on&wr=on&submit=Format+it%21 - more readable

[02:08] <sorear> I approve

[02:08] <autarch> I wouldn't mind getting TimToady's blessing too

[02:09] <sorear> I want to get more than just a blessing from him...

[02:10] * sorear waits.

[02:13] *** scott__ left
[02:16] *** scott__ joined
[02:22] *** wolfman2000 joined
[02:24] *** ribayr joined
[02:27] <sjn> autarch: nice start on a text

[02:27] <autarch> thanks

[02:27] <sjn> not sure if "

[02:28] <sjn> not sure if "The Perl 5 of today is largely similar to the Perl 5 of ten years ago" is the best way to put it

[02:29] <sjn> some of the most active people in the perl community have started saying that "This is not your father's Perl" (albeit cheekily :)

[02:29] <autarch> I'm more talking about the language itself

[02:29] <autarch> maybe I should just say "The Perl 5 language of today ..."

[02:30] <sjn> Perl 5 has some really major differences today as compared to 5 years ago

[02:30] <sjn> and much comes from the "Modern Perl" "movement"

[02:31] <sjn> (maybe it's too much to call it a "movement" but there are some iteresting diversions from the good-old ways of thinking Perl there)

[02:32] <autarch> But the Perl 5 language as interpreted by perl is not all that different

[02:33] <sjn> there are some new additions that have made Perl 5 a more expressive and easier to use language

[02:33] <sjn> if you compare with Perl 10 years ago, there's a LOT

[02:33] <autarch> I still maintain that they are "largely" similar

[02:33] <sjn> much comes from the experimentation that has been done on CPAN, but some are core changes

[02:33] <autarch> as in, it's been an evolution, whereas Perl 6 is a revolution

[02:34] <sjn> yeah

[02:34] <sjn> that's true

[02:34] <autarch> I'm just trying to contrast the two languages

[02:34] <sjn> but do keep in mind that you can get significant changes with evolution too :)

[02:34] <autarch> sure

[02:34] <sjn> it would be wrong to give an impression that Perl 5 hasn't changed much in 10 years

[02:34] <sjn> that's patently untrue

[02:35] <autarch> I'll try to think of a better way to phrase it

[02:35] <sjn> (and directly misleading, imo)

[02:35] <sjn> there's been a very useful co-existence between P5 and P6 for several years

[02:36] <autarch> I do say that

[02:36] <sjn> and several of the cooler P6 features have been attempted to "backport" to P5 in the form of new CPAN modules

[02:36] <sjn> of which the biggest and best know example is the Moose OO system

[02:37] <sjn> known*

[02:37] <autarch> I'm going to cover some of that later in the article

[02:37] <sjn> talking about Perl 5 today without mentioning the newer modules and frameworks would be rather sad :)

[02:38] <autarch> yeah, like I said, later

[02:38] <autarch> that's a small excerpt of a larger article

[02:38] <autarch> (which is mostly unwritten)

[02:39] <sjn> but yes, Perl 6 is a project where the goal is to make a wonderful Perl-like language with all kinds of awesome features, but without the straightjackets that come from having to care about backward compatibility

[02:40] <sjn> and frankly, some of the stuff that's ready today can easily be called "mind-blowing" :)

[02:40] <sjn> </biased_opinion> :)

[02:42] <sjn> autarch: re: language, you might want to find more ways of saying "Perl 5" and "Perl 6" though :)

[02:42] <sjn> there's quite a lot of repetition

[02:43] <autarch> I think Perl 6 has lots of cool ideas and features myself

[02:43] <autarch> well, I could write P5 and P6, but that seems to piss some people off

[02:46] <sjn> "the language", "version 4", "the #perl6 community's product", "the different P6 implentations"

[02:47] <sjn> plenty of ways to vary the language ;)

[02:48] <sjn> (I'll leave it to you to do the rest ;)

[02:52] *** noam_ left
[03:02] *** NamelessTee left
[03:11] *** alester joined
[03:15] *** orafu left
[03:16] *** orafu joined
[03:46] <sorear> sjn: I think it's safe to say autarch is familiar with modern perl; ey's one of the Moose bigshots ;)

[03:47] *** marmalade left
[03:51] <sjn> he is? :)

[03:51] * sjn had no idea

[03:51] <sjn> autarch++ for keep it cool among n00bs :)

[03:52] <sjn> ooh

[03:52] <sjn> Dave Rolsky :)

[03:53] <autarch> yeah, that's me

[03:53] <sjn> autarch: sorry about my sillyness then :)

[03:53] <autarch> no, no problem

[03:53] * sjn had no idea <_<

[03:55] * sjn should really learn to stop being "helpful" at 3am :-P

[03:59] <Tene> https://gist.github.com/1955491 -- bug I found with current rakudo HEAD in grammars

[03:59] <Tene> That's as small as I was able to golf it.

[04:00] *** am0c joined
[04:04] *** NamelessTee joined
[04:14] *** packetknife joined
[04:20] <alester> FYI to everyone: I just transferred rakudo.org off of GoDaddy. 

[04:20] <alester> If there are any problems at all, please let me know.

[04:22] <Tene> My company has some pretty bad history with godaddy. :(

[04:23] <alester> http://petdance.com/2012/02/why-im-finally-leaving-godaddy/

[04:49] <geekosaur> godaddy needs to be gone,daddy,gone...

[04:49] <geekosaur> :p

[05:05] *** machine2 joined
[05:06] *** skids left
[05:06] *** autarch left
[05:25] *** woosley joined
[05:29] *** xinming left
[05:29] *** xinming joined
[05:30] *** xinming left
[05:30] *** xinming joined
[05:30] *** birdwindupbird joined
[05:33] *** machine2 left
[05:38] *** machine2 joined
[05:40] *** machine2 left
[05:41] *** machine2 joined
[06:19] *** lestrrat left
[06:20] *** lestrrat joined
[06:27] *** alester left
[06:34] *** noam joined
[06:37] *** woosley left
[06:37] *** sivoais left
[06:38] *** sivoais joined
[06:38] <moritz> good morning

[06:38] *** sivoais left
[06:39] *** sivoais joined
[06:39] <TimToady> howdy doo

[06:41] *** packetknife left
[06:43] <sorear> good mornign moritz.

[06:43] <sorear> hello TimToady, you are needed

[06:49] *** alvis left
[06:52] <TimToady> a lot of people seem to have that impression

[06:54] *** wtw joined
[06:54] <sorear> TimToady: http://irclog.perlgeek.de/perl6/2012-03-02#i_5232938

[06:55] *** alvis joined
[06:59] <TimToady> well, right now I have to go pick up future daughter-in-law from the airport

[06:59] <TimToady> I saw that earlier, but didn't think of anything particularly clever to say that hasn't already been said too many times

[07:00] *** NamelessTee left
[07:00] <TimToady> the only thing that will prove Perl 6 to the world is doing it

[07:00] <TimToady> afk &

[07:08] *** machine2 left
[07:09] *** alvis left
[07:09] *** machine2 joined
[07:15] *** noam left
[07:15] *** noam_ joined
[07:22] *** machine2 left
[07:36] *** mj41 joined
[07:43] <moritz> nom: class A { method &[]($x) { say 'there' } }; A.new.[5]

[07:43] <p6eval> nom d0a245: OUTPUT«===SORRY!===␤Missing block␤at /tmp/EgK4pqqBRv:1␤»

[07:44] <moritz> nom: class A { method @[]($x) { say 'there' } }; A.new.[5]

[07:44] <p6eval> nom d0a245: OUTPUT«===SORRY!===␤Missing block␤at /tmp/EtiYZS9e9k:1␤»

[07:44] <moritz> nom: class A { method @.[]($x) { say 'there' } }; A.new.[5]

[07:44] <p6eval> nom d0a245: OUTPUT«===SORRY!===␤Missing block␤at /tmp/3UtIBcOaf6:1␤»

[07:44] <moritz> nom: class A { method @.[$x] { say 'there' } }; A.new.[5]

[07:44] <p6eval> nom d0a245: OUTPUT«there␤»

[07:44] *** noam_ left
[07:47] <geekosaur> *blink* not postcircumfix:< [ ] > ?

[07:47] <geekosaur> (argh notwork, 5 minutes to type that...)

[07:48] <geekosaur> which means I won't see the answer...

[07:48] <moritz> geekosaur: it's a shortcut for postcircumfix:<[ ]>

[07:49] *** alvis joined
[08:06] *** packetknife joined
[08:06] *** PacoAir joined
[08:09] *** PacoAir left
[08:12] *** alvis left
[08:13] *** bbkr_ joined
[08:14] *** bbkr left
[08:14] *** bbkr_ is now known as bbkr

[08:18] *** pat_js joined
[08:19] *** fhelmberger_ joined
[08:21] *** noam joined
[08:32] <jnthn> morning, #perl6

[08:32] <sorear> hello, jnthn

[08:34] *** aindilis left
[08:34] *** aindilis joined
[08:37] <moritz> woah, lots of rakudo progress

[08:37] *** pat_js left
[08:37] <jnthn> Wow, time between entering $dayjob building and having a sticky note in my hand about a bug was literally 15 seconds today

[08:39] <moritz> phenny: "tack så mycket"?

[08:39] <phenny> moritz: "thanks so much" (sv to en, translate.google.com)

[08:39] <moritz> phenny: en no "much"?

[08:39] <phenny> moritz: "mye" (en to no, translate.google.com)

[08:40] <moritz> no wonder I didn't reckonize "mycket" :-)

[08:41] <sorear> is sv easy to transcribe?

[08:44] <jnthn> sorear: Not so bad

[08:45] <jnthn> sorear: Especially if you're lucky enough to live in a bit of Sweden without odd, Danish-influenced pronunciation.

[08:45] * jnthn lives in such an area, and finds his Swedish comprehension generally goes up noticably when he travels to other regions

[08:46] <sorear> I think you mean does *not* live in such an area...

[08:47] <sorear> TODO: learn Swedish

[08:47] <moritz> sorear: knowing German and English, I found learning Norwegian rather easy

[08:48] <sorear> jnthn: do you beleive in role Hash[::T = Any] { ... } ?

[08:48] <moritz> sorear: though my aim was mostly understanding people, not speaking it myself (so that I can understand my wife's family :-)

[08:49] <moritz> and I haven't quite succeded yet, but the half year where I put effort into it was rewarded with astonishingly successful

[08:49] <sorear> TODO: learn German :)

[08:50] * sorear is starting to think about S09 in earnest now

[08:50] <jnthn> sorear: I tried doing things that way before and it got icky.

[08:51] <sorear> I'm also wondering if there should be a type distinction between shapeful and shapeless aggregates, or if it should be hidden like Int/Bigint

[08:51] <sorear> niecza: say (10**12).REPR # can't remember if I finished this

[08:51] <jnthn> I was wondeirng if it's possible to do it was a set of composable mixins

[08:51] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unhandled exception: Unable to resolve method REPR in class Int␤  at /tmp/fEK3vlKrat line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3839 (module-CORE @ 65) ␤  at /home/p6…

[08:52] <sorear> jnthn: could you elaborate on that?

[08:53] <sorear> shape handling seems pretty monolithic to me

[08:55] *** alvis joined
[09:03] * sorear -> sleep, will quiz jnthn more tomorrow

[09:04] <jnthn> Yeah, $dayjob is being quite busy here at the moment...

[09:15] *** fglock joined
[09:15] *** thou left
[09:17] *** gv joined
[09:39] *** dakkar joined
[09:46] <fglock> I think I'm getting closer to a usable data model for perl5-in-js; next step would be to port it to perl6-in-js

[09:48] *** tarch joined
[09:56] <moritz> fglock++

[10:08] *** scott__ left
[10:11] *** gv left
[10:19] <fglock> moritz: I've found your post http://www.perlmonks.org/?parent=689702;node_id=3333

[10:19] <fglock> local and typeglob kinda work

[10:20] <fglock> what happenned with sprixel?

[10:22] <moritz> fglock: it died.

[10:23] <au> it begat niecza though

[10:23] <moritz> https://github.com/diakopter/sprixel

[10:23] <fglock> ah, cool (niecza, not died)

[10:23] <moritz> well, it got rewritten for several different backends

[10:24] <moritz> the current one seems to be C/6model

[10:29] <fglock> re data model - perlito5 now recompiles itself faster under v8 than under perl5; this gives some performance margin to add missing features and still have a usable impl

[10:32] <au> oooh

[10:32] <fglock> perl5-in-perl6 still needs a lot of work on the data model side

[10:33] <fglock> au: 10s in v8, 15s in perl5

[10:33] <moritz> perl6: say $_.*WHAT

[10:33] <p6eval> pugs b927740: OUTPUT«Scalar␤»

[10:33] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤NYI dottyop form .* at /tmp/krt8ABVT0w line 1 (EOF):␤------> [32msay $_.*WHAT[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niec…

[10:33] <p6eval> ..rakudo d0a245: OUTPUT«===SORRY!===␤Cannot use .* on a non-identifier method call at line 1, near ""␤»

[10:33] * au praises inline caching vms in general and v8 in particular

[10:33] <fglock> (10s bootstrap time is really nice to have)

[10:35] <au> fglock: btw, can perlito.js run in node as well as d8?

[10:36] <au> s/can/is there some settings that makes/

[10:36] <au> I ask because it might be very useful to have the bootstraped compiler as a npm module.

[10:36] <fglock> yes - it needs a different implementation of CORE.print and IO.slurp; everything else is the same

[10:36] <au> "npm install perlito ; perlito hello.pl"

[10:37] <fglock> au: can you make a patch? :)

[10:37] <au> what, no commit bits for me? :)

[10:37] <au> ok, I'll try making a pull request.

[10:37] <fglock> btw, I'm trying to make a cpan package

[10:37] <fglock> ah, sure - let me find out how it works

[10:38] <fglock> I'm not familiar with github

[10:38] <au> Admin -> Collaborators -> Add

[10:38] <au> (afaicr)

[10:39] <fglock> au: looking - do you have some time for me to explain the bootstrap & test process? (maybe in a priv channel)

[10:39] <moritz> if it's nothing secret, feel free to do it in here

[10:39] * moritz would be curious

[10:39] <au> yeah

[10:39] <au> and/or capture it into a document in the repo

[10:40] *** hugme joined
[10:40] <au> or open a pad in http://beta.etherpad.org/

[10:40] *** ChanServ sets mode: +v hugme

[10:40] <au> (I have ~20mins before lunch)

[10:40] <au> timtowtdi, though typing it here may be easiest :)

[10:41] <fglock> README-perlito5 has most of it

[10:42] <fglock> perl -Ilib5 perlito5.pl -Cjs src5/util/perlito5.pl > perlito5.js   # builds for perlito5 for v8

[10:42] <fglock> ~/bin/d8 perlito5.js -- -Cjs src5/util/perlito5.pl > perlito5-new.js   # bootstraps

[10:42] <fglock> running the bootstrap 3 times ensure it works

[10:43] <fglock> nice time util-perl5/bootstrap-perlito5-perl5.sh  # recompiles the whole lib5

[10:43] * au takes notes (and would probably add them as makefile targets)

[10:44] <fglock> time nice util-js/make-perlito5-js.sh   # recompiles the web gadget (html/perlito5.js)

[10:46] <fglock> (perlito6 is about the same, but it also needs to bootstrap in python)

[10:47] <fglock> recovering from a broken bootstrap is basically: git checkout lib5 perlito5.pl

[10:48] <au> got it.

[10:49] <fglock> you can't write to lib5 while using the perl5 backend, so you need a temp file:

[10:49] <fglock> perl -Ilib5 perlito5.pl -Cperl5 src5/lib/Perlito5/Javascript/Emitter.pm > x && cp x lib5/Perlito5/Javascript/Emitter.pm

[10:49] <fglock> or just use the js compiler:

[10:49] <fglock> ~/bin/d8 perlito5.js -- -Cperl5 src5/lib/Perlito5/Expression.pm > lib5/Perlito5/Expression.pm  

[10:50] <fglock> (which is kinda cool - using v8 to compile back to perl5)

[10:51] <au> yup

[10:51] *** daxim joined
[10:52] *** bbkr left
[10:52] * au idly wonders if theres a bin/into utility somewhere so "cat foo |into foo" can work

[10:52] <au> i.e. consume all of stdin, wait for it to close, then write it to arg1 

[10:53] <moritz> and doesn't write at all if SIGPIPE occurs?

[10:53] <au> yeah

[10:53] <au> I guess "tail -n 9999" is something like that

[10:54] <au> (if tail supports an -o option, that is)

[10:54] <fglock> testing in the command line with v8 also requires a temp file:

[10:54] <fglock> ~/bin/d8 perlito5.js -- -Cjs -e ' $main::a = 10; sub x { local $main::a; $main::a = 3; say $main::a; return 123 }; x(); say $main::a; ' > x && ~/bin/d8 x

[10:55] <fglock> though it could just run eval-string, thinking about it

[10:55] <au> ("|tail -n 999 |tee 1 >/dev/null" is close)

[10:55] * au punts that particular train of though

[10:55] <au> *t

[10:56] <au> fglock: you mean " | xargs d8 -e " ?

[10:57] <fglock> au: I don't understand what you mean

[10:58] <au> d8 perlito5.js -- -Cjs -e ... | xargs d8 -e

[10:59] <fglock> this gives me: Error reading 'Do' 

[11:00] <au> probably not then

[11:04] <fglock> au: adding -Cjs-node param to util/perlito5.pl might be better than tweaking a generic runtime

[11:05] <au> why? probing at startup is ~zero cost

[11:05] <fglock> because node has a lot more features, and then you keep the browser runtime smaller

[11:05] <fglock> maybe

[11:06] *** kst left
[11:06] <fglock> you may want "use" in the browser do an ajax call

[11:06] *** kst joined
[11:07] <au> yeah. we can test for the free variable require

[11:07] <au> and use it in both node and AMD/CommonJS/curlJS/requireJS/whatever context

[11:11] *** havenn joined
[11:11] <fglock> au: you should have a commit bit now

[11:11] <au> <- been hacking in coffeescript/node for almost a year now and would love to bring p5/p6 modules into the ecosystem

[11:11] <au> fglock++ thx!

[11:13] <fglock> you will probably find the calling conventions a bit odd, but that's needed to support some perl5 features efficiently

[11:13] <fglock> older versions had a simpler, more js-ish look

[11:13] <au> *nod*

[11:14] <masak> morning, #perl6

[11:15] <au> /o masak

[11:16] <fglock> o/

[11:16] <fglock> au: README-perlito5-js

[11:18] <au> got the callconv

[11:18] <fglock> if you have problems with the parser... I can *try* to explain

[11:19] <fglock> it's certainly not perfect

[11:20] <fglock> the plan for @ISA is to merge the methods in the class magically - this is not implemented

[11:20] * fglock waves hands

[11:20] <au> ah, so not using the .prototype.lookup chains?

[11:21] <fglock> probably not, because then you can have multiple inheritance

[11:21] <masak> I think the truce between the Perl 5 and Perl 6 communities can be achieved over the wording "Perl 6 won't replace Perl 5 any time soon". Eternal fivers can read it as an understatement and think "...or never", and be happy. Poeple in the sixers militia can read it as a long-term revolutionary plan and think "...but just you wait", and be happy.

[11:22] <daxim> you don't fool me!!

[11:22] * au still thinks Perl 5+6i is a nice version number

[11:22] <masak> s/never/ever/

[11:23] <au> or 5.14+6.28i, for that matter

[11:23] <au> perl6: (5.14 + 6.28i).WHAT

[11:23] <p6eval> pugs b927740, rakudo d0a245, niecza v15-2-gd19c478:  ( no output )

[11:23] <au> perl6: (5.14 + 6.28i).WHAT.say

[11:23] <p6eval> rakudo d0a245, niecza v15-2-gd19c478: OUTPUT«Complex()␤»

[11:23] <p6eval> ..pugs b927740: OUTPUT«Complex␤»

[11:24] <fglock> au: but .prototype.lookup chains is much better than no inheritance at all, of course

[11:24] <fglock> yes, it's complex :P

[11:24] <au> fglock: dunno, I kinda think we can serialize over C3 and arrange a linear .prototype .prototype.prototype chains.

[11:24] <masak> au: so you're saying the situation is complex? ;)

[11:25] <au> masak: yeah, it's easier to accept it as complex than discarding either part :)

[11:26] <masak> aye.

[11:26] <masak> despite what I wrote above, I'm not a militant sixer, nor do I plan to become one.

[11:27] * moritz too still uses large amounts of p5

[11:27] <masak> I'm eager to create a future where there's room for both languages.

[11:27] <moritz> and will, for the foreseeable future

[11:27] <au> PHP used to have militant sixers... they are sadly in short supply these days

[11:27] <masak> I probably write more Perl 5 than Perl 6 nowadays.

[11:27] <au> Perl community is comparably fortunate in that regard :)

[11:28] <masak> <TimToady> the only thing that will prove Perl 6 to the world is doing it

[11:29] <masak> this seems to be the predominant slogan the past few years.

[11:29] <masak> a Candide-like "let's tend our garden" attitude. :)

[11:29] <au> that's very candid for sure :)

[11:29] *** havenn left
[11:29] <masak> and p6l is full of Panglosses...

[11:30] <au> -> lunch, bbiab

[11:32] <masak> in fact, now that I think about it, the recent criticism heard on Twitter and elsewhere -- "the traffic on p6l/spec commits have decreased, therefore Perl 6 is in decline" -- is *pathetic*.

[11:33] <masak> the people who say it probably are simply misinformed and would benefit from being corrected, but... wow, if that's the best outsiders can come up with these days, I'd say we're doing pretty well!

[11:33] <au> “First, you win. Then they may ignore you, laugh at you, fight you… But none of that matters — You've won already!”

[11:34] <moritz> well, the traffic on the mailing lists has declined. And that's usually not a good sign.

[11:34] <moritz> though it really just has gone elsewhere, which is not apparent for the outsider

[11:34] <masak> moritz: it has. I haven't seen that as a worrying sign.

[11:34] <masak> elsewhere = IRC?

[11:35] <masak> blog posts?

[11:35] <moritz> IRC, gists, blog posts, conferences

[11:36] <moritz> remeber the "calling positional parameters by name must by" gist? that would have gone to p6l 3 years ago

[11:36] <masak> aye.

[11:37] <moritz> and spawned a discussion with 200+ messages, arguing over the virtues of empowering the user vs. avoiding accidents vs. transcental tibetian philosphy, or so

[11:37] <masak> when I want bikeshedding and out-of-the-box thinking with lots of noise and missed targets in it, I go to p6l.

[11:37] <masak> when I want bikeshedding and constructive discussion, I post a gist URL here :)

[11:39] <masak> I have a feeling that if one were to plot daily #perl6 activity over the past six-or-so years, one would see a definite increase.

[11:39] * moritz looks forward to high-bandwith communication with jnthn++ about the sink business

[11:39] * masak looks forward to going to Erlangen, and meeting moritz and the others

[11:40] <fglock> I'd rather discuss alternative perl5 implementations here than in other lists - unless it bothers you as off-topic

[11:40] <moritz> because I have the feeling that my first assumptions of how PAST nodes reflect program structure were childishly naíve

[11:40] <au> fglock: considering the said implementation is written in perl6, I doubt it'd be off-topic here :)

[11:41] <fglock> it is no longer written in perl6, I've translated to perl5 after bootstrapping 

[11:41] <fglock> but conceptually yes :P

[11:41] <au> that makes it doubly on topic, as the same process would apply to 5->6 and 6->js :)

[11:42] <masak> mmm, 6->js

[11:44] *** M_o_C joined
[11:44] *** kst left
[11:44] *** kst joined
[11:50] <masak> so, I have a Perl 6 day today.

[11:50] <masak> I'd like to spend parts of it on working on macros.

[11:50] <masak> it's probably high time for another branch rebase. :)

[11:51] <masak> I need to think more about the "two OUTERs" problem.

[11:51] <masak> maybe blog about it and about the recent progress.

[11:51] <masak> then I need to spend some time working on my GPW talk.

[11:56] <masak> moritz: [backlog] "mycket" and "mye" are practically the same spelling! :)

[11:57] <masak> at least by the loose, blurry vision etymologists (or enthusiasts) need to apply.

[11:57] <moritz> masak: right, the edit distance is just 3 :-)

[11:57] *** M_o_C left
[11:58] <masak> there you go.

[11:59] <masak> 1, if you consider that the 't' is silent, and the 'ck' is just one phoneme.

[12:00] <masak> sorear: I would learn German before learning Swedish... and after learning German, I wouldn't learn Swedish :)

[12:00] <masak> that's even if you plan to live here at some point.

[12:00] <masak> it's not worth it from a ROI point-of-view.

[12:01] * moritz kinda thinks it's *always* worth trying to learn the language of the country you live in

[12:01] <moritz> though that's more of a cultural choice than ROI

[12:03] <masak> I've met dozens of people at this point who learned Swedish, even though they spoke English well. out of all those, I consider *one* of them to have learned Swedish to a level where speaking it made more sense than speaking English.

[12:03] <masak> she had some sort of immersive learning process which apparently turned out quite well.

[12:03] *** mj41 left
[12:04] <masak> I know it's such a cliché, but "my native language is actually quite difficult to master".

[12:04] <masak> it's not so much the grammar and the words, which are close enough to English and German and French.

[12:05] <masak> it's the pronunciation. the exact sounds, the stressing of words, and the sentence melody.

[12:05] <moritz> "made more sense than speaking English" is exactly the ROI-type thinking that I don't mean

[12:05] <masak> nod.

[12:05] <moritz> how can you ever understand a culture on the gut level if you don't get their puns? :-)

[12:06] <masak> oh, I agree with that.

[12:06] <masak> that's why I'm always interested in the structure of languages, even though I don't speak them well.

[12:09] *** bluescreen10 joined
[12:14] *** bluescreen10 left
[12:18] <masak> here's the current "issue" with macros:

[12:19] <masak> macro foo($x) { $x }; foo my $a = 42; say $a

[12:19] *** mj41 joined
[12:19] <masak> we'd like this program to output '42', rather than, say, not even compile because $a isn't visible.

[12:20] <masak> for that to work, the AST corresponding to the 'my $a = 42' bit has to be more of a thunk than a block.

[12:25] <moritz> correct, it shouldn't be a call frame or outer frame on its own

[12:25] <masak> nom: my $x = 0; sub foo { True && my $a = $x++; say $a }; foo; foo; foo

[12:25] <p6eval> nom d0a245: OUTPUT«0␤1␤2␤»

[12:25] <masak> as TimToady points out in http://irclog.perlgeek.de/perl6/2012-02-24#i_5204285 , this case is analogous.

[12:25] *** bluescreen10 joined
[12:25] <moritz> isn't there a PAST::Block type that corresponds to that?

[12:26] <masak> how would I find out?

[12:26] <masak> investigate how infix:<&&> is wired up?

[12:26] <moritz> it's in Actions.pm

[12:26] <masak> ok.

[12:26] * masak looks

[12:26] <moritz> but I think it'll disappoint you

[12:26] <masak> me too :)

[12:26] <moritz> because iirc it's just :pasttype<if>

[12:27] <masak> right.

[12:27] *** hugme left
[12:27] *** hugme joined
[12:27] <masak> also, I have more immediate problems.

[12:27] *** ChanServ sets mode: +v hugme

[12:27] <masak> macro foo($x) { $x }; foo say "OH HAI" # still doesn't work

[12:27] <masak> for known reasons.

[12:29] <masak> there are only three occurrences of :pasttype<if> in Actions.pm -- neither of them relating to infix:<&&>.

[12:30] <masak> they relate, respectively, to 'if', 'when', and quotepairs.

[12:31] <moritz> sorry, it's Grammar.pm

[12:31] <masak> ok.

[12:31] <masak> token infix:sym<&&>   { <sym>  <O('%tight_and, :pasttype<if>')> }

[12:31] <masak> right.

[12:32] <masak> well, if :pasttype<if> has thunking behavior, then maybe it means that I can use that.

[12:33] <moritz> well, thinking is easy on the PAST level

[12:33] <moritz> *thunking

[12:33] <moritz> nice typo :-)

[12:33] <moritz> because it just means passing a PAST::something around

[12:33] <masak> right.

[12:34] <masak> the burning question, however, is till this: can I give a *thunk* a different OUTER?

[12:34] * fglock wonder how to parse here-docs (easily)

[12:34] <moritz> .*?$delimiter  maybe?

[12:35] <moritz> masak: doesn't it automatically get a different outer when you put it into a PAST tree somewhere?

[12:36] <masak> moritz: hold on, I'll give you an example.

[12:36] <moritz> ah, the code in Perl6::World seems to fiddle with $pad<outer>

[12:37] <masak> macro foo($x) { quasi { say {{{$x}}} } }; foo (my $x = 42); say $x # expected '42\n42\n'

[12:38] <masak> the quasi has an OUTER being the macro &foo, even after being implanted in the mainline in lieu of the macro call.

[12:38] <masak> therefore, the thunk representing '(my $x = 42)' needs to re-OUTER itself back to the mainline somehow.

[12:38] <masak> that is the core of my current challenge.

[12:39] <moritz> macro foo($x) { quasi { say {{{$x}}} } }; foo (my $y = 42); say $y

[12:39] <moritz> also expects 42\n\42, right?

[12:39] <masak> ah, thanks. better.

[12:39] <masak> yes.

[12:39] <masak> they are two distinct variables.

[12:39] <masak> and it may not really be an OUTER I need to change. as TimToady said, a thunk is something that parasites on an existing lexical scope.

[12:39] <moritz> right, so a simple re-outering isn'T enough

[12:40] <moritz> right, you need to merge it into some pad

[12:40] <masak> aye.

[12:40] <moritz> think of it as a role you mix into it

[12:40] * masak tries to think of it like that, and falls off the deep end

[12:40] <masak> yes... I think I get it. a role has its own lexical environment too.

[12:40] <moritz> never mind then :-)

[12:40] <masak> but this is somewhat inside-out from that.

[12:41] <masak> we want to mix the mainline into the quasi block.

[12:41] <masak> and implant the quasi block into the mainline.

[12:41] <masak> it's like a "quilting" operation. :)

[12:41] <moritz> well, if we mix the quasi into the mainline, the other direction happens automatically, no?

[12:42] <masak> sounds like you're thinking of closures, not ASTs.

[12:42] <masak> though I dearly hope you're right, and that I've misunderstood something :)

[12:43] <moritz> I'm currently trying to figure out how the generated code for the already-applied macro would look like

[12:44] <masak> from my perspective, it looks like a block (coming from the quasi block), proudly declaring that it has the macro as an OUTER.

[12:44] <masak> containing thunks that somehow assert that they are part of the mainline's lexpad.

[12:44] <tadzik> good afternoon, #perl6

[12:44] <masak> tadzik! \o/

[12:45] <tadzik> \o/

[12:45] <moritz> masak: I think that OUTERs aren't the solution

[12:46] <moritz> masak: because it's really about hygiene

[12:46] <masak> no, probably not.

[12:46] <moritz> masak: and you can't find a general solution that fddles with OUTERS and comes up with the right answer

[12:46] <masak> moritz: a secondary cause of concern is setting those thunks up so that they get "rebound", just like each 'my $a = $x++' gets rebound to each invocation of 'sub foo'.

[12:47] <masak> http://en.wikipedia.org/wiki/Hygienic_macro#Strategies is informative in the various ways we can solve this, I guess.

[12:47] <moritz> masak: hold on, let me think through tthe current issue before coming up with new ones

[12:47] <masak> gladly.

[12:47] <masak> but they're all really related.

[12:49] <moritz> sub mysay($x) { say $x; return $x };  macro foo($x) { quasi { mysay {{{ $x }}} } }; foo(mysay '42')

[12:49] *** colomon joined
[12:49] <moritz> this executes the 'mysay 42' first, right?

[12:50] <masak> "first"?

[12:50] <moritz> well, the output is 42\n42\n

[12:50] <moritz> let me make this a bit clearer

[12:50] <masak> yes. as far as I can see, it is.

[12:50] <moritz> sub mysay($x) { say $x; return 2 * $x };  macro foo($x) { quasi { mysay {{{ $x }}} } }; foo(mysay 42)

[12:50] <moritz> the output is 42\n48\n, correct?

[12:50] <masak> yes.

[12:51] <masak> well, "42\n84\n"

[12:51] <masak> but you meant that.

[12:51] <moritz> right

[12:51] <moritz> ENOMATH :-)

[12:51] <masak> the 'mysay' in the quasi gets called first.

[12:52] <masak> or, hm.

[12:52] <masak> no, it doesn't.

[12:52] <masak> the code that gets spliced in is 'mysay mysay 42', but as ASTs.

[12:53] <masak> from then on, there's nothing more funny going on that sub calls.

[12:53] <masak> I don't really see what you're trying to show here.

[12:53] *** fhelmberger_ left
[12:54] <moritz> well, the act of showing answered my initial question already :-)

[12:54] <masak> oh, good.

[12:54] <moritz> ok, here are my thoughts

[12:54] <moritz> it should compile to something like

[12:54] <moritz> $MACRO::x = (my $y = 42);

[12:55] <moritz> say $MACRO::x

[12:55] <moritz> say $y

[12:55] <moritz> where 1) $MACRO::x is a uniq name per macro instantiation

[12:56] <masak> achieve hygiene by shoving things from inside the quasi into a gensym'd namespace?

[12:56] <moritz> and 2) the first say() in there is looked up from the perspective of the macro's scope

[12:56] <moritz> masak: yes, or an equivalent mechanism

[12:56] <masak> right.

[12:56] <moritz> the question is if there's a sane way to unify the lookup of the &say and the $x inside the macro

[12:56] *** JimmyZ joined
[12:57] <masak> corresponding to the "Packages" solution on Wikipedia.

[12:57] <moritz> and that's the point you've been trying to make all along, isn't it?

[12:57] <masak> sometime like that.

[12:57] <masak> a macro always has to deal with two lookup chains.

[12:57] <masak> and the user very much expects the macro not to mess them up.

[12:58] <masak> so much that it's almost a bit hard to make precise :)

[12:59] <masak> a closure always deals with only one lookup chain. what's magical about closures is that it's the "original" lookup chain, not the "spliced-in" lookup chain.

[12:59] <masak> but the code that results from a macro application needs to relate to both "original" (quasi) and "spliced-in" (mainline) lookup chains.

[13:03] <moritz> https://gist.github.com/1958280

[13:04] * masak looks

[13:04] <moritz> nothing really new

[13:05] <masak> it tells me you're really getting it.

[13:05] <masak> I've only showed the problem with scalar variables so far. you're showing it with sub lookup.

[13:05] <moritz> well, they really obey the same lookup semantics

[13:06] <moritz> I could have done that by sheer pattern matching, without understanding (wait, where's the difference? :-)

[13:08] <masak> ;)

[13:08] * masak .oO( http://en.wikipedia.org/wiki/Chinese_room )

[13:15] <moritz> I'm now trying to visualize how the generated AST for https://gist.github.com/1958280 might look like

[13:15] <moritz> the first possiblity being

[13:16] <moritz> $MACRO::x := (say "hello $a");

[13:16] <moritz> sub MACRO::greet($a) { say "LOL IT'S $a.uc()" };

[13:17] <moritz> MACRO::greet MACRO::$x

[13:17] <moritz> sub greet($a) { say "hello $a" }

[13:17] <moritz> greet $y

[13:18] <moritz> the second involving some weirdly connected blocks that twist my head in ways that I fear might be unrecoverable

[13:21] *** tokuhirom joined
[13:26] *** am0c left
[13:26] *** mtk joined
[13:29] *** simcop2387 left
[13:31] *** simcop2387 joined
[13:31] <moritz> hugme: hug masak because he has to implement macros

[13:31] * hugme hugs masak

[13:31] <phenny> hugme: 03 Feb 15:08Z <[Coke]> tell hugme to hug p5p.

[13:31] <moritz> hugme: hug p5p

[13:31] * hugme hugs p5p

[13:31] <masak> wow, they had to wait for that hug almost a month.

[13:32] <moritz> yes, hugmes auto-rejoin didn't work

[13:32] <moritz> I hope I've fixed it now, mit literal++'s help

[13:33] <masak> moritz: I think I've been heading towards your second possibility involving weirdly connected blocks that twist your head in ways that may or may not be unrecoverable...

[13:33] <masak> I will now seriously consider your namespacing solution.

[13:35] <masak> for quite a while, I've had the feeling that *something* will have to be rewritten at insertion-time; either the quasi lookups or the mainline lookups.

[13:35] <masak> I've been going back and forth on which ones to rewrite.

[13:37] <moritz> note that you can also gensym names, or rewrite when you detect conflicts (though that's harder, I think), it really doesn't matter which way you fudge the names

[13:37] <moritz> you can safely gensym names that aren't valid Perl 6 identifiers

[13:37] <moritz> like with a double sigil or so

[13:40] <masak> the thing about gensymming is that you know it's gonna come back and bite you.

[13:40] <masak> it's basically incompatible with predictable lexpad introspection, for example.

[13:41] <masak> and I don't know if I believe in "when you detect conflicts" -- that presupposes that all lookups are statically known, which isn't so. Perl 6 has lots of runtime-only lookup mechanisms.

[13:42] <moritz> right

[13:42] <moritz> which is why you need namespaces

[13:42] <moritz> thought it *can* be gensym'med micro-namespaces

[13:42] <masak> I need something, for sure.

[13:42] <masak> maybe namespaces.

[13:43] <masak> in a way, tying up OUTERs in exactly the right way can be seen as a form of clever anonymous namespacing.

[13:43] <moritz> at some point you have to fool the dynamic lookup not to take those symbols into account that are implementation details

[13:44] <moritz> yes, it sounds more elegant

[13:45] * JimmyZ can't build rakudo :(

[13:45] <JimmyZ> Serialization Error: could not locate static code ref for closure 'c3_merge'

[13:48] *** overrosy left
[13:49] <masak> JimmyZ: did you do a realclean or a 'git clean -dfx'?

[13:53] <moritz> and is that newest rakudo and nqp?

[13:54] <JimmyZ> moritz: 

[13:54] <JimmyZ> moritz: yes

[13:55] <JimmyZ> moritz: everything is the newest, and did 'git clean -xdf'

[13:55] <masak> did you try building everything from a freshly cloned rakudo repo?

[13:55] <moritz> that... shouldn't be necessary

[13:55] <masak> no, it shouldn't.

[13:55] <masak> but you never know.

[13:56] <JimmyZ> I'm everything is  fresh

[13:56] <JimmyZ> I'm sure *

[13:58] <JimmyZ> nom: constant @primes = 2, 3, -> $p { ($p+2, $p+4 ... -> $n { $n %% none @primes ... * >= sqrt $n })[*-1] } ... *; 

[13:58] <p6eval> nom d0a245: OUTPUT«===SORRY!===␤Variable @primes is not declared␤at /tmp/RPLkFWmwOe:1␤»

[13:58] <JimmyZ> I thought it was fixed.

[13:59] <masak> what made you think that?

[13:59] <masak> as far as I know, it wasn't even RT'd.

[13:59] *** pernatiy left
[13:59] <moritz> the commit message was    Fix 'constant fib := 0, 1, *+* ... *; say fib[100]'.

[13:59] <JimmyZ> https://github.com/rakudo/rakudo/commit/d4e8e416522a3e7b0817a883abb35ed6d8d18ef7

[14:00] <masak> that looks like a fix for something slightly different.

[14:00] <moritz> aye

[14:00] <jnthn> Yes, there were two issues, I fixed one out of two.

[14:00] <masak> jnthn+

[14:00] <jnthn> *sigh* four hours to find/fix a one-char bug...

[14:00] * JimmyZ still can't build rakudo

[14:00] <jnthn> ...over 2 to reproduce the environment the bug was found in, mind :/

[14:01] <jnthn> JimmyZ: Are you really sure you have latest Rakudo?

[14:01] *** colomon left
[14:01] <jnthn> I recognize that error. It was the first one I got when I built old Rakudo on nqp/bs before I started the Rakudo updates. :)

[14:02] <JimmyZ> $ git pullAlready up-to-date.

[14:02] <JimmyZ> both nqp and rakudo is Already up-to-date

[14:02] *** jaldhar left
[14:03] *** jaldhar joined
[14:03] <moritz> JimmyZ: what's the output of  git ref-parse HEAD  ?

[14:03] <masak> maybe something else in the system is old.

[14:03] <JimmyZ> a one-char bug are always hard

[14:04] <JimmyZ> $ git rev-parse head

[14:04] <JimmyZ> c314198aeb77953bb15ad8d053381242828a3f52

[14:05] <moritz> that's nqp, right?

[14:05] <moritz> looks correct

[14:05] <masak> walk /

[14:05] <masak> &

[14:06] <JimmyZ> oh no, .. I 'm in (cont_reuse) branch ...

[14:07] <moritz> JimmyZ: you should be in rakudo/nom and nqp/master

[14:07] <jnthn> ah, that explains it.. :)

[14:08] *** jaldhar left
[14:08] *** NamelessTee joined
[14:16] <JimmyZ> works for me now 

[14:16] <jnthn> \o/

[14:22] <JimmyZ> compile CORE.Setting takes 980Mb memory here

[14:22] <moritz> time to add more stuff to src/core/ :-)

[14:23] <jnthn> :P :P

[14:23] <jnthn> tadzik++ already did yesterday :)

[14:23] <felher> perl6: sub cc($a, $b) { $a ~ $b }; <a b c> X&cc <1 2 3>;

[14:23] <p6eval> rakudo d0a245: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in sub cc at /tmp/p32LlRTSf2:1␤  in block <anon> at /tmp/p32LlRTSf2:1␤␤»

[14:23] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "2"␤    expecting operator␤    at /tmp/xndbFkYbNN line 1, column 45␤»

[14:23] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«Unhandled exception: No value for parameter '$b' in 'cc'␤  at /tmp/j1MrY3SgKd line 0 (cc @ 1) ␤  at /tmp/j1MrY3SgKd line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3839 (m…

[14:24] <moritz> nom: class A { ... }; class B is A { }; class A { }; say B.new ~~ A

[14:24] <p6eval> nom d0a245: OUTPUT«Method 'new' not found for invocant of class 'B'␤  in block <anon> at /tmp/xvg9wpPrT7:1␤␤»

[14:24] <jnthn> felher: Declare a sub infix:<cc>($a, $b) { ... 

[14:24] <jnthn> and use Xcc

[14:24] <jnthn> moritz: I know about that one.

[14:25] <moritz> jnthn: is that supposed to work?

[14:25] <jnthn> Not sure. I know that it doesn't though :)

[14:25] <moritz> I mean, I could totally understand if not

[14:25] <jnthn> I think I can make it fall out naturally from other things.

[14:26] <moritz> so we don't need to know about the parent classes parents and methods at compose time?

[14:27] <felher> jnthn: i though, since one could write infix:<foo>('a', 'b') (using operator foo as a binary function), maybe X works on binary functions (using binary-function as operator), too :)

[14:28] <felher> *thought

[14:28] <jnthn> moritz: Well, it's more that parents re-composing should announce the change to the hierarchy.

[14:28] <jnthn> felher: No :)

[14:28] <felher> jnthn: k, thnx :)

[14:29] *** havenn joined
[14:33] *** grondilu joined
[14:34] <fsergot> o/

[14:36] *** grondilu_ joined
[14:37] <grondilu_> perl6: say constant X = 10**5

[14:37] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/BdHKeJXtdZ line 1, column 16␤»

[14:37] <p6eval> ..rakudo d0a245, niecza v15-2-gd19c478: OUTPUT«100000␤»

[14:37] <grondilu_> perl6: say constant X = 10**50

[14:37] <p6eval> rakudo d0a245, niecza v15-2-gd19c478: OUTPUT«100000000000000000000000000000000000000000000000000␤»

[14:37] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/8_G_jHFBcx line 1, column 16␤»

[14:37] <grondilu_> perl6: say constant X = 0x10000000000000000000000000000000000000000000000000000000;

[14:37] <p6eval> rakudo d0a245: OUTPUT«===SORRY!===␤Object of type 'Int' cannot be referenced without having been assigned a serialization context␤»

[14:37] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/7CxndOyIpq line 1, column 16␤»

[14:37] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«1684996666696914987166688442938726917102321526408785780068975640576␤»

[14:37] <grondilu_> rakudo--

[14:38] *** grondilu left
[14:38] <moritz> grondilu_: don't -- it, write a bug report and a test :-)

[14:39] <grondilu_> is there an Howto somewhere?

[14:39] <moritz> I guess some of the number parsing code needs updates after the bs merge

[14:39] <moritz> grondilu_: bug reports are simply emails to [email@hidden.address]
[14:40] <moritz> with an expressive subject and a small bit of code and example output that demonstrates the problem

[14:40] <grondilu_> ok

[14:40] <grondilu_> do I have to make sure it hasn't been reported yet?

[14:40] <moritz> and tests... I think I've written about that too, but I think it's quite obvious from looking at the existing tests

[14:40] *** skids joined
[14:40] <moritz> grondilu_: I don't think that one has been reported yet

[14:41] <grondilu_> Oh I see instructions in rakudo's README.  Sorry.

[14:42] <felher> so, if one has a binary function and want to use X on it, he make a new block and declares the function as an binary operator? like http://paste.pocoo.org/show/559762/?

[14:46] <moritz> I guess we should really provide a crosswith() function or so

[14:47] <grondilu_> felher: I think if you define cc as an operator you'll be able to right directly $a X[cc] $b

[14:47] <moritz> maybe zip() should   sub zip(*@@lol, :with=&infix:<,>)

[14:47] <moritz> and then we should have a cross(*@@lol, :with=&infix:<,>)

[14:48] <moritz> then you could write that    cross &cc, @list1, @list2

[14:48] <moritz> perl6: role A { method x() { } }; role B { method x() { } }; class C does A does B { }

[14:48] <p6eval> niecza v15-2-gd19c478: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Method 'x' must be resolved by class 'C' because it exists in roles 'A[curried][...]' and 'B[curried][...]' at /tmp/FYgypaJUFw line 1 (EOF):␤------> [32mhod x() { } }; class C does A does B { }[33m⏏[31m<EOL>[0m␤␤Unhandled…

[14:48] <p6eval> ..pugs b927740:  ( no output )

[14:48] <p6eval> ..rakudo d0a245: OUTPUT«===SORRY!===␤Method 'x' must be resolved by class C because it exists in multiple roles (B, A)␤»

[14:51] <felher> grondilu_: in my paste i did define it as an operator and then used it like '<a b c> Xcc <1 2 3>'. Or did i mistunderstand you?

[14:53] <moritz> perl6: role A { method x() { ... } }; class B does A { }

[14:53] <felher> Whats the reason for meta-operators to not be able to use functions as in X&foo?

[14:53] <p6eval> niecza v15-2-gd19c478: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Method 'x' must be implemented by 'B' because it is required by role 'A[curried][...]' at /tmp/AJnwecnwCT line 1 (EOF):␤------> [32mmethod x() { ... } }; class B does A { }[33m⏏[31m<EOL>[0m␤␤Unhandled exception: Check fai…

[14:53] <p6eval> ..rakudo d0a245: OUTPUT«===SORRY!===␤Method 'x' must be implemented by B because it is required by a role␤»

[14:53] <p6eval> ..pugs b927740:  ( no output )

[14:53] <moritz> felher: they are called meta *operators* because they act on *operators*

[14:54] <moritz> felher: I can understand that you want something that acts on non-operators. I want it too

[14:54] <moritz> felher: but then it should simply be a higher-order function, much like map or grep

[14:55] <moritz> though X&cc might work out. Maybe. Need to ask our parsing gurus (TimToady, sorear, jnthn)

[14:55] <felher> moritz: I thought there is no difference between operators and subs save their names. So its primarily a naming-thing?

[14:55] <jnthn> Well, the names imply a parser augmentation.

[14:55] <moritz> felher: well, names and the syntax they imply

[14:56] <moritz> you can do  say(1, 2, 3), you can't do   1 &say 2 &say 3

[14:56] <moritz> operators also have "fun" like precedence and associativity

[14:57] <felher> Ah, i see. Thanks :)

[14:57] <moritz> for example for [op], the associativity tells the meta-reduce thingy whether to reduce left-to-right or right-toleft

[14:57] <jnthn> in some sense, operators are verbs whereass &foo is a noun.

[14:57] <moritz> nom: say ([**] 2, 3, 4) == 2 ** 3 ** 4

[14:57] <p6eval> nom d0a245: OUTPUT«True␤»

[14:57] <jnthn> And maybe it's nice to keep things straight in that sense.

[14:57] <moritz> note that ** is right-assoc

[14:58] <felher> yeah, i understand the problem with the associativity. ty :)

[14:58] <moritz> jnthn: but it might not hurt to be able to verb a noun :-)

[14:58] <jnthn> True

[14:59] *** kst left
[15:00] *** kst joined
[15:02] <grondilu_> felher: (about earlier)  Indeed.  My bad.

[15:03] <felher> hm, over all that meta-operator stuff i forgot on what i was working on in the first place...

[15:03] <felher> grondilu_: kk :)

[15:06] <felher> Oh, great, bs is merged to nom \o/

[15:08] <jnthn> aye :)

[15:09] *** tokuhirom left
[15:11] *** Trashlord left
[15:12] *** GlitchMr joined
[15:15] <felher> Great! (make clean && perl Configure.pl --gen-nqp --gen-parrot && gmake -j10 && gmake install) is no one minute faster :)

[15:16] <felher> *now

[15:16] *** marmalade joined
[15:25] *** sisar joined
[15:27] <fglock> moritz++ the ".*?$delimiter" suggestion was obvious, but actually helped - now I have something I can refine later

[15:29] <moritz> felher: you could save much time by building parrot in parallel too

[15:29] *** Trashlord joined
[15:29] <moritz> felher: though it either needs a custom build script, or fiddling with the configure system

[15:29] <moritz> or maybe there's an env options

[15:31] <felher> moritz: thanks for the hint. I'll look into that :)

[15:38] *** noam left
[15:39] *** MayDaniel joined
[15:40] *** noam joined
[15:41] *** kst left
[15:41] <moritz> I wouldn't object to a patch that adds a --parrot-make-option option to rakudo's Configure.pl

[15:42] *** kst joined
[15:44] *** Psyche^ joined
[15:48] <jnthn> decommute &

[15:48] *** Patterner left
[15:48] *** Psyche^ is now known as Patterner

[15:53] *** mj41 left
[15:54] *** havenn left
[15:56] *** pernatiy joined
[16:02] *** wtw left
[16:04] *** havenn joined
[16:06] *** thou joined
[16:07] *** thou left
[16:10] *** grondilu_ left
[16:14] *** kaare_ joined
[16:19] *** JimmyZ left
[16:20] *** colomon joined
[16:25] * jnthn home o/

[16:27] *** havenn left
[16:27] *** am0c joined
[16:30] *** alester joined
[16:31] * [Coke] wonders what's on jnthn's rakudo-genda now that bs has landed.

[16:34] *** fglock left
[16:40] *** packetknife left
[16:41] <[Coke]> pugs: say 1...2

[16:41] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "2"␤    expecting operator, ":", "," or term postfix␤    at /tmp/YxTfhvRjaB line 1, column 9␤»

[16:42] <[Coke]> pugs: say 1..2

[16:42] <p6eval> pugs b927740: OUTPUT«12␤»

[16:46] <TimToady> pugs: say 1 ... 2

[16:46] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "2"␤    expecting operator, ":" or ","␤    at /tmp/YJ_Ray8xlA line 1, column 11␤»

[16:47] <TimToady> I wonder how that's pars(ec)ing...

[16:50] <au> pugs: my @x := (1...); say @x[1000]

[16:50] <p6eval> pugs b927740: OUTPUT«1001␤»

[16:50] <au> (postfix:<...>)

[16:50] <TimToady> that's why I tried a space

[16:50] <au> pugs: my @x := (1   ...); say @x[1000]

[16:50] <p6eval> pugs b927740: OUTPUT«1001␤»

[16:51] <jnthn> [Coke]: Try and unblock at least of the moritz++ branches, some feature hacking, and work on qregex bootstrap.

[16:51] <au> (it pre-dates the "Postfix found where infix expected is an error" rule)

[16:51] <TimToady> overagressive parsec space rule maybe

[16:51] <jnthn> *at lesat one

[16:52] <au> pugs: &infix:<...>(1,2)

[16:52] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&infix:..."␤    at /tmp/MowGquYYrD line 1, column 1 - line 2, column 1␤»

[16:53] *** att left
[16:58] <moritz> jnthn: sorting out the operator multi stuff in match-refactor branch might be an overall win too

[16:58] <moritz> jnthn: the sink branch needs some discussion

[16:58] <jnthn> moritz: Is it best left until GPW when we'll have more bandwidth?

[16:59] <moritz> yes (for sink)

[16:59] <jnthn> Yes, the sink one was what I was meaning.

[16:59] <moritz> considering that GPW is only 3 days away...

[16:59] <jnthn> Right :)

[16:59] <moritz> and pre-GPW lasagna only 2 days away... :-)

[16:59] * tadzik wonders if we have more lags now due to cables, or we will have on GPW due to sound barriesr

[16:59] <jnthn> \o/

[17:00] <jnthn> moritz: Is there some summary of what "the operator multi stuff" is?

[17:01] * jnthn thinks it was discussed a bit more here once...

[17:01] <jnthn> moritz: Anyway, updating match-refactor with latest changes...

[17:02] *** havenn joined
[17:02] *** kst left
[17:03] *** kst joined
[17:03] *** NamelessTee left
[17:05] <dalek> Heuristic branch merge: pushed 98 commits to rakudo/match-refactor by jnthn

[17:05] <moritz> jnthn: in essence  multi infix:<foo>(SomeType, SomeType) { } in a lexical scope is called for some values of 'foo', but for others it falls back to (Any, Any) case

[17:06] <moritz> class A { }; { multi infix:<+>(A, A) { 'OH HAI' }; say A + A }

[17:06] <moritz> nom: class A { }; { multi infix:<+>(A, A) { 'OH HAI' }; say A + A }

[17:06] <p6eval> nom d0a245: OUTPUT«OH HAI␤»

[17:06] <moritz> nom: class A { }; { multi infix:<==>(A, A) { 'OH HAI' }; say A == A }

[17:06] <p6eval> nom d0a245: OUTPUT«OH HAI␤»

[17:06] <moritz> nom: class A { }; { multi infix:<eq>(A, A) { 'OH HAI' }; say A eq A }

[17:06] <p6eval> nom d0a245: OUTPUT«use of uninitialized value of type A in string context␤use of uninitialized value of type A in string context␤True␤»

[17:07] <moritz> see, works for + but not for eq

[17:07] <moritz> and the match-refactor branch shifts infix:<==> from working to not-working

[17:07] *** Chillance joined
[17:09] <jnthn> nom: class A { }; { multi infix:<->(A, A) { 'OH HAI' }; say A - A }

[17:09] <p6eval> nom d0a245: OUTPUT«use of uninitialized value of type A in numeric context␤use of uninitialized value of type A in numeric context␤0␤»

[17:09] *** icwiener joined
[17:09] <jnthn> Heh. So + works, - does not.

[17:09] <moritz> and git bisect shows it's a commit that only touches the setting in rather harmless ways

[17:09] <jnthn> wtf. :)

[17:09] <moritz> I forgot which on it was, but I can find it in the logs

[17:09] <jnthn> which one, ooc?

[17:09] <jnthn> yeah, may help

[17:09] <jnthn> I'm gonna switch back to nom branch and debug it there.

[17:09] <moritz> either 560633d964a78848f6a78e2366189803ce54cacd or 5b4468309e03b0d6ff3f01070997b6ebb9687103 I think

[17:10] <moritz> yeah, match-refactor can be cleanly merged into pre-bs nom

[17:11] <jnthn> I just merged latest nom branch into match-refactor and it built fine.

[17:11] <moritz> 5b4468309e03b0d6ff3f01070997b6ebb9687103 is the evil one

[17:11] <moritz> make spectest should show two failing test files

[17:12] <moritz> and several passing TODOs, which are the main aspect of that whole branch :-)

[17:12] <jnthn> k

[17:12] *** sisar left
[17:13] <jnthn> OK, I got the +/- diff reproduced locally.

[17:13] <moritz> it's also something that's reflected in the way the spectests are fudged

[17:14] <moritz> so seems quite determinstic, even if in weird ways

[17:14] *** fglock joined
[17:14] *** birdwindupbird left
[17:14] *** wolfman2000 left
[17:14] <jnthn> moritz: Well, this is telling.

[17:15] <jnthn> $ perl6 z.p6

[17:15] <jnthn> OH HAI

[17:15] <jnthn> use of uninitialized value of type A in numeric context

[17:15] <jnthn> 0

[17:15] *** NamelessTee joined
[17:15] <jnthn> $ perl6 --optimize=off z.p6

[17:15] <jnthn> OH HAI

[17:15] <moritz> oh.

[17:16] <moritz> and now you try the different optimization levels

[17:16] <jnthn> --optimize=0 (analysis only) and --optimize=1 are fine

[17:16] <jnthn> Starts at --optimize=2 (the default)

[17:16] <moritz> oh, and we only got back operator overloading after the optimizer was implemented

[17:17] <jnthn> OK, that gives me a relatively small amount of code to consider as to blame. :)

[17:17] <moritz> so that why we didn't notice any regressions -- I attributed all the changes in non-passing tests to the nom-vs.-b difference

[17:17] <jnthn> I blame the guy who wrote the optimizer.

[17:18] * TimToady thinks that something that does required transformations shouldn't be called an optimizer...

[17:18] <jnthn> TimToady: ?

[17:18] <moritz> well, it's more optimal than an incomplete implementation :-)

[17:18] *** gv joined
[17:18] <jnthn> TimToady: It works fine with the optimizer off.

[17:18] <TimToady> okay

[17:18] <jnthn> TimToady: It's when it's on that it's doing the transformation wrong.

[17:18] <moritz> jnthn: well, without the optimizer we don't get CHECK-time routine checking, which is specced

[17:19] <moritz> (iirc)

[17:19] <jnthn> True.

[17:19] <TimToady> that's probably what I was thinking of...

[17:19] <jnthn> --optimize=0 actually doesn't optimize, mind.

[17:19] * TimToady is still in 6 impossible things mode

[17:19] <jnthn> It only does the analysis part.

[17:19] <jnthn> --optimize=off turns off that analysis too.

[17:20] <jnthn> I'm happy to name them in better ways. :)

[17:21] <moritz> --static-frob=0..3

[17:21] <moritz> :-)

[17:23] *** sisar joined
[17:26] <jnthn> Hmmm.

[17:26] <jnthn> Think I see it.

[17:26] *** isBEKaml joined
[17:28] * jnthn also wonders why he ended up with the multi-dispatch related bits on Code rather than Routine

[17:28] <TimToady> the problem with allowing &foo as an operator is it prevents the terse foo&bar style of & junction; while we recommend whitespace around infixes, I'm not much into requiring it

[17:28] <moritz> because you wanted to multi-dispatch anon blocks? :-)

[17:28] <TimToady> we might possibly allow &foo inside of [&foo] though

[17:29] <sisar> o.O (description of 'length' => "This word is banned in Perl 6. You must specify units." !)

[17:29] <sisar> 'banned' ?

[17:30] <masak> 'severely discouraged'? :)

[17:30] <moritz> banned. We do not use it, except to rant about it

[17:30] *** Vlavv` joined
[17:30] <TimToady> it is generally considered a sign of Everything Is A List mentality, which is not P6-Think

[17:30] <moritz> well, I can talk about the length of my car, but then the answer isn't a number, but a number + unit :-)

[17:30] <masak> +1 on X[&foo], or at least I don't feel opposition to it. I don't like X&foo at all, for reasons stated above.

[17:31] <TimToady> though a list could have cars in it...

[17:31] * masak cddrs

[17:31] <sisar> on first reading i though that i can't even define a sub called length in P6

[17:33] *** Vlavv_ left
[17:33] <TimToady> P6 sometimes tries to discourage you from thinking too generically where precision is required; length is one of those place

[17:33] <TimToady> *places

[17:33] <TimToady> s/places/times/  :)

[17:35] *** sisar left
[17:39] *** slavik1 left
[17:39] *** kst left
[17:39] *** slavik1 joined
[17:39] *** kst joined
[17:40] *** pernatiy left
[17:40] *** pernatiy joined
[17:43] *** pernatiy_ joined
[17:45] *** pernatiy_ left
[17:45] *** mucker joined
[17:45] *** pernatiy left
[17:49] *** pernatiy joined
[17:51] * TimToady wonders what precedence [&foo] should default to

[17:53] <TimToady> arguably should depend on foo's signature

[17:55] * skids awestruck by all the fixes/new stuff in just last week.  jnthn++ , moritz++ , tadzik++ !

[17:56] <skids> Definitely looking forward to testing out PROXY/postcircumfix:<( )> fixes.

[17:57] <jnthn> moritz: Fixed.

[17:57] *** tarch left
[17:57] <dalek> rakudo/nom: 93104f1 | jnthn++ | src/ (5 files):

[17:57] <dalek> rakudo/nom: Only need multi handling stuff in Routine; don't make every other block pay the price of the few extra attributes.

[17:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/93104f1c96

[17:57] <dalek> rakudo/nom: 99bc8b3 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[17:57] <dalek> rakudo/nom: Fix over-sharing of proto thunks, which caused mis-dispatches in some cases.

[17:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99bc8b320c

[17:58] *** MayDaniel left
[17:58] <moritz> \o/

[17:59] <jnthn> Wasn't actually the optimizer's fault in the end...was a bug in dispatcher derevation.

[18:04] *** havenn left
[18:07] <jnthn> moritz: There were two tickets related to this issue; tagged one testneeded, closed the other.

[18:08] *** havenn joined
[18:10] *** skipper joined
[18:12] *** kst left
[18:12] *** kst joined
[18:12] <moritz> jnthn: ok, I'll see what we can unfudge

[18:12] <moritz> ... and merge match-refactor :-)

[18:13] *** havenn left
[18:13] <jnthn> \o/

[18:13] <dalek> rakudo/nom: e46bfea | moritz++ | src/ (4 files):

[18:13] <dalek> rakudo/nom: Merge remote branch 'origin/match-refactor' into nom

[18:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e46bfea35d

[18:13] <jnthn> .oO( that branch needed exhaustive testing )

[18:14] <dalek> Heuristic branch merge: pushed 150 commits to nqp/qbootstrap by jnthn

[18:15] *** dakkar left
[18:15] <jnthn> ah, it didn't dispaly the commit message for the merge commit. Summary: qbootstrap doesn't build at the moment (expected that, though)

[18:17] <dalek> std: bd9fad8 | larry++ | STD.pm6:

[18:17] <dalek> std: add conjectural infix [&foo] parsing

[18:17] <dalek> std: 

[18:17] <dalek> std: Variants such as [&.foo], [&(...)] also allowed.

[18:17] <dalek> std: Variants with $ sigil also admitted (but not @ or %;

[18:17] <dalek> std: I suppose those could be allowed if keyed 2-dimensionally).

[18:17] <dalek> std: review: https://github.com/perl6/std/commit/bd9fad832c

[18:17] <moritz> jnthn++ # the bs merge made the whole dev cycle (recompile, test) much snappier

[18:19] <jnthn> moritz: Yes, it's more -Ofun to hack now :)

[18:23] * felher likes X[&foo]

[18:25] * [Coke] tries to fudge S03-junctions/misc.t for pugs and goes blind.

[18:26] * [Coke] adds a pugs todo to test 6. it turns into test 5, which then passes.

[18:28] <dalek> std: 8fb2ea6 | larry++ | STD.pm6:

[18:28] <dalek> std: set $<O> correctlier

[18:28] <dalek> std: review: https://github.com/perl6/std/commit/8fb2ea6716

[18:28] *** noam left
[18:28] *** wolfman2000 joined
[18:28] <TimToady> evalbot rebuild std

[18:28] <p6eval> OK (started asynchronously)

[18:28] *** noam joined
[18:31] <dalek> Rebuild of std complete.

[18:32] <moritz> std: 1

[18:32] <p6eval> std 8fb2ea6: OUTPUT«ok 00:01 107m␤»

[18:32] <moritz> ok, right revision

[18:36] <dalek> roast: ea3031a | moritz++ | S02-names-vars/ (2 files):

[18:36] <dalek> roast: rakudo unfudge

[18:36] <dalek> roast: review: https://github.com/perl6/roast/commit/ea3031a2c1

[18:36] <dalek> roast: d178924 | moritz++ | S06-operator-overloading/workout.t:

[18:36] <dalek> roast: fix S06-operator-overloading/workout.t

[18:36] <dalek> roast: 

[18:36] <dalek> roast: the previous version assumed that &is_approx from Test.pm lifts infix:<->,

[18:36] <dalek> roast: which it does not (and the spec does not say so either)

[18:36] <dalek> roast: Also contains rakudo unfudges

[18:36] <dalek> roast: review: https://github.com/perl6/roast/commit/d1789249ad

[18:36] <dalek> roast: a66ef9c | moritz++ | S0 (5 files):

[18:36] <dalek> roast: rakudo unfudges

[18:36] <dalek> roast: review: https://github.com/perl6/roast/commit/a66ef9c092

[18:37] <TimToady> moritz: well, it could be lying

[18:38] <dalek> rakudo/nom: c3b4d54 | moritz++ | t/spectest.data:

[18:38] <dalek> rakudo/nom: run operator overloading workout.t

[18:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c3b4d54e6c

[18:39] <sorear> good * #perl6

[18:39] <moritz> are classes exported by default?

[18:39] <dalek> std: 9c3ef6d | larry++ | STD.pm6:

[18:39] <dalek> std: don't forget to check the variable if [$foo]

[18:39] <dalek> std: review: https://github.com/perl6/std/commit/9c3ef6d736

[18:40] <jnthn> moritz: No

[18:40] <jnthn> moritz: But they're our-scoped by default

[18:40] <jnthn> moritz: And then GLOBAL-merging.

[18:40] <TimToady> evalbot rebuild std

[18:40] <p6eval> OK (started asynchronously)

[18:41] <jnthn> dinner time &

[18:41] <moritz> oh, I see what's wrong

[18:41] <TimToady> std: 42 [&atan2] 43

[18:41] <p6eval> std 8fb2ea6: OUTPUT«ok 00:01 113m␤»

[18:41] <moritz> t/spec/S06-operator-overloading/imported-subs.t starts as

[18:41] <moritz> use Exportops;

[18:42] <moritz> and t/spec/packages/Exportops goes like

[18:42] <moritz> module Exportops;

[18:42] *** MayDaniel joined
[18:42] <moritz> class NotANumber { stuff here }

[18:42] <dalek> Rebuild of std complete.

[18:42] *** MayDaniel left
[18:42] *** MayDaniel joined
[18:42] <jnthn> Right, that'll be available as Exportops::NotANumber

[18:42] <moritz> and then imported-subs.t tries to uses that NotANumber (unqualified)

[18:43] <moritz> can I make NotANumber also 'is export' and have the short name available?

[18:43] <jnthn> Yes

[18:43] <jnthn> ooh, I should clean up the is export trait now we have bs too :)

[18:45] *** kst left
[18:45] <jnthn> First though, really dinner.

[18:45] *** kst joined
[18:45] <dalek> roast: 6551484 | moritz++ | / (2 files):

[18:45] <dalek> roast: fix Exportops.pm, and unfudge S06-operator-overloading/imported-subs.t

[18:45] <dalek> roast: review: https://github.com/perl6/roast/commit/65514849a9

[18:45] *** thou joined
[18:46] <TimToady> std: 42 [$foo] 43

[18:46] <p6eval> std 9c3ef6d: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $foo is not predeclared at /tmp/r49AhTSI7A line 1:␤------> [32m42 [[33m⏏[31m$foo] 43[0m␤Check failed␤FAILED 00:01 110m␤»

[18:46] <moritz> \o/

[18:46] <TimToady> std: 42 [&foo] 43;  # assumes post-declared

[18:46] <p6eval> std 9c3ef6d: OUTPUT«ok 00:01 114m␤»

[18:46] <TimToady> std: &foo

[18:46] <p6eval> std 9c3ef6d: OUTPUT«ok 00:01 111m␤»

[18:47] <TimToady> that too

[18:47] <TimToady> niecza: &foo

[18:47] <p6eval> niecza v15-2-gd19c478: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'foo' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /home/…

[18:47] <TimToady> arguably should work like that though

[18:47] <dalek> rakudo/nom: b6c09b4 | moritz++ | t/spectest.data:

[18:47] <dalek> rakudo/nom: run S06-operator-overloading/imported-subs.t

[18:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b6c09b4310

[18:49] <TimToady> sorear: where does niecza add_mystery for a bare &foo ?

[18:49] *** daxim left
[18:52] *** localhost left
[18:54] *** localhost joined
[19:00] <moritz> std: sub foo; foo()

[19:00] <p6eval> std 9c3ef6d: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed block at /tmp/tJ4MC1rBfe line 1:␤------> [32msub foo[33m⏏[31m; foo()[0m␤    expecting any of:␤ new name to be defined␤ routine_def␤    trait␤Parse failed␤FAILED 00:01 107m␤»

[19:01] <moritz> rakudo: try eval 'sub foo; foo()'; say $!.perl

[19:01] <p6eval> rakudo b6c09b: OUTPUT«X::AdHoc.new(payload => "Method 'ast' not found for invocant of class 'Undef'")␤»

[19:01] <moritz> nom: sub foo; foo()

[19:01] <p6eval> nom b6c09b: OUTPUT«===SORRY!===␤Method 'ast' not found for invocant of class 'Undef'␤»

[19:03] <moritz> nom: sub foo //;

[19:03] <p6eval> nom b6c09b: OUTPUT«===SORRY!===␤Missing block␤at /tmp/stu6NjbORV:1␤»

[19:06] <masak> moritz: can I submit a rakudobug for the LTA error message on 'sub foo;'?

[19:07] <moritz> masak: sure

[19:07] * masak submits rakudobug

[19:07] <moritz> and when we fix it, I'll test it properly (ie by type of exception)

[19:09] <moritz> oh, it might even be my fault :/

[19:10] *** mj41 joined
[19:11] <felher> moritz: would be so kind to take a look at https://github.com/felher/rakudo/commit/f9c5694e1b718981d83e913ad4fd502128ab5676 -- Maybe thats a patch that you wouldn't object to :)

[19:11] <felher> +you

[19:11] *** tokuhirom joined
[19:11] <moritz> felher: I'll take a look, but it might take after lunch

[19:11] *** sisar joined
[19:11] <felher> moritz: thanks, thats fine with me :)

[19:12] *** PacoAir joined
[19:13] *** Teratogen left
[19:13] <Tene> masak: can you also make a rakudobug out of this? https://gist.github.com/1955491

[19:15] *** cbk1090 joined
[19:16] <sorear> TimToady: (niecza's) STD.pm6 line 5465

[19:17] <masak> Tene: I will if you golf it a bit further :)

[19:17] <Tene> bah; that's already golfed down from my original by more than half.

[19:17] <masak> (I already saw it in the backlog and decided not to submit it until it's shorter)

[19:20] <[Coke]> phenny: "Wat is en Dampfmaschin? Da stelle mer uns janz dumm."

[19:20] <masak> [Coke]: question mark

[19:20] <[Coke]> phenny: "Wat is en Dampfmaschin? Da stelle mer uns janz dumm."?

[19:20] <phenny> [Coke]: "Wat is a steam engine ? Then ask us janz stupid number ." (de to en, translate.google.com)

[19:21] <[Coke]> That's not helpful. (subject of a message to p5p)

[19:21] <masak> has the structure of a pun, but ich don't get it.

[19:22] <moritz> it's a famous line from a German movie

[19:23] <moritz> and it's dialect, which is why Google Translate doesn't like it

[19:23] <moritz> "WHat is a steam engine? Let's act very stupid... " (ie, start at the basics)

[19:23] <Tene> masak: what about https://gist.github.com/1955491 ?

[19:23] *** birdwindupbird joined
[19:24] *** kst left
[19:24] <flussence> .oO( we should use test suite progress to determine when Perl 6 Is Ready - all we need to do is fail less tests than PHP :)

[19:24] *** icwiener left
[19:24] *** icwiener joined
[19:24] <cbk1090> I'm having problems with user input, is there a way to change a Str and make it an Int?

[19:24] <dalek> specs: f538b17 | larry++ | S01-overview.pod:

[19:24] <dalek> specs: default to P5 only when invoked as 'perl'

[19:24] <dalek> specs: review: https://github.com/perl6/specs/commit/f538b17f47

[19:24] <moritz> cbk1090: sure, call .Int on it

[19:25] <moritz> nom: say '42'.Int

[19:25] <p6eval> nom b6c09b: OUTPUT«42␤»

[19:25] <moritz> nom: say '42'.Int.WHAT

[19:25] <p6eval> nom b6c09b: OUTPUT«Int()␤»

[19:25] <cbk1090> ok

[19:26] *** pernatiy left
[19:26] *** PacoAir left
[19:26] <cbk1090> It's not working...

[19:26] <cbk1090> if $data ~~ m/ (\d+ ) \s (\d+)  / { $num1.Int = $0; $num2.Int = $1;  say "Data: " ~ $num1 ~ ", " ~ $num2; return(1); }

[19:27] <moritz> you probably want

[19:27] <moritz> $num1 = $0.Int

[19:27] <cbk1090> ok

[19:28] *** kst joined
[19:31] <cbk1090> moritz, Thank you so much!

[19:35] <sisar> why does comb have a default while split does not ?

[19:35] <moritz> sisar: what would you default it to?

[19:36] *** att joined
[19:37] * sisar is not falling for that ;-)

[19:37] <moritz> sisar: but it's the heart of the answer

[19:37] <moritz> sisar: in p5, split() is rather magical

[19:37] <dalek> std: 137d5f5 | larry++ | STD.pm6:

[19:37] <dalek> std: backport niecza's undefined &foo detector

[19:37] <dalek> std: review: https://github.com/perl6/std/commit/137d5f5c71

[19:37] <moritz> sisar: like, removing leading and trailing empty items

[19:37] *** bluescreen10 left
[19:38] <moritz> sisar: in p6, we don't do that, and instead have .comb and .words

[19:38] *** kst left
[19:38] <moritz> sisar: so if you want a split that defaults to /\s+/ or so, you should really be using .words instead

[19:39] *** kst joined
[19:39] <sisar> so when the spec says "The default is no longer ' ' since that would be interpreted as a constant. ", it is saying "no longer" to contrast with P5?

[19:39] <moritz> right

[19:39] <Tene> rakudo: grammar Foo { token element { | 'a' <element> { make 'a' ~ $<element>.ast } | ';' { make ';' } } }; say Foo.parse("aaaa;", :rule<element>).ast;

[19:40] <p6eval> rakudo b6c09b: OUTPUT«Method 'match' not found for invocant of class 'Any'␤»

[19:43] <TimToady> evalbot rebuild std

[19:43] <p6eval> OK (started asynchronously)

[19:43] <Tene> That parses fine if you remove the actions.

[19:43] *** Tedd1 joined
[19:44] <dalek> Rebuild of std complete.

[19:45] <masak> sisar: even if Perl 6 is not the successor or "next version of" Perl 5, it still has its roots in it.

[19:45] <TimToady> std: 1 [&atan2] 3; 1 [&btan2] 3

[19:45] <p6eval> std 137d5f5: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'btan2' used at line 1␤Check failed␤FAILED 00:01 114m␤»

[19:45] <fglock> yay - heredocs work: http://perlcabal.org/~fglock/perlito5.html

[19:45] <masak> fglock++

[19:46] <TimToady> I hope you parsed them the right way and not the Perl 5 way :)

[19:46] <sisar> moritz: "String delimiters must not be treated as rules but as constants. " Can you explain?

[19:47] *** wolfman2000 left
[19:47] *** kst left
[19:47] <moritz> sisar: $str.split('.+') doesn't interpret the '.+' as a regex

[19:47] <moritz> sisar: but it actually searches for the substring '.+'

[19:47] *** kst joined
[19:48] <sisar> so it simply forbids regexes ?

[19:49] <sorear> hi fglock!

[19:49] <moritz> sisar: no, you *can* pass a regex

[19:49] <moritz> $str.split(rx/.+/)

[19:49] <moritz> sisar: the spec simply says that a string shouldn't be compiled automagically to a regex, like p5 does it

[19:49] <fglock> base/lex.t is *very* hard

[19:49] <fglock> sorear: o/

[19:50] <dalek> rakudo/nom: ced04f7 | (Felix Herrmann)++ | / (2 files):

[19:50] <dalek> rakudo/nom: enable Configure.pl to pass options to Parrot's make

[19:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ced04f710a

[19:50] <dalek> rakudo/nom: d4dc7d7 | moritz++ | src/Perl6/Grammar.pm:

[19:50] <dalek> rakudo/nom: fix regression introduced in 6588dd39, fixes bug #111492

[19:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d4dc7d7d95

[19:50] <sisar> moritz: hmm. I'll have a look at P5 split, hopefully it won't confuse me :

[19:51] <moritz> sisar: it simply means "don't do magic" :-)

[19:52] * sisar thinks magic is an overused word in perl lingo

[19:52] * [Coke] would update "no longer foo" to something like "contrasted with perl5's default, foo"

[19:52] <dalek> roast: fcd1668 | moritz++ | S32-exceptions/misc.t:

[19:52] <dalek> roast: Test for proper error of "sub foo;", RT #68710 and RT #111492

[19:52] <dalek> roast: review: https://github.com/perl6/roast/commit/fcd1668173

[19:52] <moritz> [Coke]: feel free :-)

[19:53] <[Coke]> (because I get the feeling some of those are referring to old p6 behavior)

[19:53] <[Coke]> moritz: I will eventually give the spec a front to back readthrough.

[19:53] <sisar> [Coke]: i got the same exact feeling

[19:53] <moritz> evalbot rebuild nom

[19:53] <p6eval> NOT OK (maybe a rebuild is already in progress?)

[19:54] <[Coke]> perhaps during the enormous layovers on the next business trip

[19:54] <[Coke]> evalbot rebuild THE UNIVERSE

[19:54] <p6eval> OK (started asynchronously)

[19:54] <dalek> Rebuild of THE complete.

[19:54] <masak> haha

[19:54] <tadzik> :)

[19:54] <[Coke]> ... that was astonishingly fast.

[19:54] <sisar> ;)

[19:54] <sisar> hehe

[19:54] <tadzik> evalbot rebuild my house

[19:54] <p6eval> OK (started asynchronously)

[19:54] <dalek> Rebuild of my complete.

[19:54] <masak> evalbot rebuild me into a cyborg

[19:54] <p6eval> OK (started asynchronously)

[19:54] <dalek> Rebuild of me complete.

[19:54] <tadzik> :)

[19:54] <TimToady> evalbot rebuild THE COMPLETE MULTIVERSE

[19:54] <p6eval> OK (started asynchronously)

[19:54] <dalek> Rebuild of THE complete.

[19:55] <masak> it only gets to THE

[19:55] <masak> that's not impressive.

[19:55] <masak> I could do that.

[19:55] <TimToady> ooh, white did it split on unbreakable space?

[19:55] <TimToady> *why

[19:55] <moritz> it might just search for \w+

[19:55] <moritz> luke the source

[19:56] <sisar> evalbot rebuild evalbot

[19:56] <p6eval> OK (started asynchronously)

[19:56] <dalek> Rebuild of evalbot complete.

[19:57] <sisar> does it actually rebuild evalbot?

[19:57] <moritz> no

[19:57] <sisar> ( it should)

[19:57] <moritz> no

[19:58] <sisar> so who builds evalbot ?

[19:58] <moritz> nobody; it doesn't need a build step

[19:59] <masak> evalbot rebuild masak

[19:59] <p6eval> OK (started asynchronously)

[19:59] <masak> ahh.

[19:59] <dalek> Rebuild of masak complete.

[19:59] <moritz> do we have a masak clone now?

[20:00] <tadzik> that could be useful

[20:00] <masak> no, just a fresher build.

[20:00] <tadzik> I could use a clone of myself too

[20:00] <moritz> :-)

[20:00] <masak> one day I'll write that blog post about having seven clones.

[20:00] <TimToady> it has to dismantle the previous one for parts to build the new one

[20:00] <masak> I have it mostly mapped out in my head.

[20:00] <moritz> yeah, that's the big problem with hardware

[20:01] <masak> it's not completely problem-free to have clones, I'll tell you that much.

[20:01] <moritz> yes, all the hassle with the authorities

[20:01] <sisar> what language would a TimToady's clone invent ? might be interesting ;-)

[20:01] <moritz> who pays the tax?

[20:01] <moritz> sisar: Perl. Of course :-)

[20:02] <moritz> felher++ # configure patch

[20:02] <masak> moritz: we're under the radar. all the clones except one always stay in the apartment.

[20:02] <masak> moritz: no, it's more a psychological thing. I never realized how obnoxious I can be!

[20:03] <masak> hard to reason with sometimes. especially since I know just about all my own buttons to push.

[20:03] <moritz> masak: ah, that explains the supposedly good wifi connection in Swedish busses

[20:03] <moritz> it's the clones from the apartment that do the IRCing

[20:04] <masak> dang, I should have been more careful!

[20:04] <moritz> it all makes sense now :-)

[20:04] <masak> I mean... hehe, yes. it's them.

[20:05] *** masak2 joined
[20:05] <masak2> masak: get off, it's my turn

[20:05] <masak> :P

[20:05] <masak> wow, that's unexpectedly provocative.

[20:06] <masak2> masak: seriously, you've been here all day

[20:06] <masak> rule 1 when actually getting clones: agree to never be several online on IRC at the same time.

[20:06] *** wolfman2000 joined
[20:06] <masak> masak2: you're a phony, and I'll tell you why.

[20:06] <masak> I'd never name a clone "masak2".

[20:06] <masak2> dang

[20:06] <masak> that's classical rookie mistake in clone naming.

[20:06] <masak2> it's that "masak" is taken on freenode!

[20:06] <masak> every clone will consider itself "the original masak", and will have to have a name that reflects that.

[20:07] *** masak2 is now known as kasam

[20:07] <masak> including, to the extent the distinction can be made, the original.

[20:07] <masak> you see, I've been giving this quite a bit of thought.

[20:07] <sorear> why is masak2 connecting from Poland with tadzik's hostmask?

[20:07] <masak> for, um, research into my story.

[20:07] <tadzik> sorear: no idea :)

[20:07] <masak> sorear: yeah, it's all very confusing.

[20:07] <sorear> did you accidentally leave a clone behind during one of your tadzik hackathons?

[20:07] <flussence> sorear: they get around a lot

[20:08] <tadzik> masak: I thought that was real you!

[20:08] <moritz> tadzik: they are *all* real

[20:08] <tadzik> /o\

[20:08] <skids> .oO(tadzik pirated a copy?)

[20:08] <kasam> cover blown!

[20:08] *** kasam left
[20:09] <masak> yes. we have slightly different memories after the point of cloning, but we're still mostly the same.

[20:09] <flussence> .oO( compared to most other places, hostmasks are completely useless as unique identifiers in here... )

[20:12] <moritz> masak: have you heard of the "paranoia" pen&paper RPG?

[20:12] <masak> moritz: yes, only recently. I can see why you're thinking of it.

[20:13] <moritz> if you die, you're replaced almost immediately by a clone with full knowledge of your previous self

[20:13] <moritz> (which is a bug in the system, you shouldn't have those memories :-)

[20:13] <masak> :P

[20:13] <moritz> oh, and it's lots of fun to play

[20:14] <masak> I'd love to try it sometime.

[20:16] <tadzik> never played it

[20:16] *** kst left
[20:17] *** kst joined
[20:18] <moritz> it's kind of a meta-RPG; it makes you do all the stuff that you usually don't do in a "real" RPG

[20:19] <moritz> like, distrust and repeatedly kill your fellow players

[20:19] <tadzik> heh

[20:19] *** pjcj left
[20:19] <tadzik> on a last D&D session there appeared a gang of whale hunters, whose goal in life was powerleveling (whales give quite a plenty of XP)

[20:19] <tadzik> talk about broken 4th wall

[20:20] <moritz> well, there's an easy solution for that: whales dying out :-)

[20:20] <tadzik> they were just NPCs, no need to try to stop them :)

[20:21] <diakopter> I'll dye your whale

[20:21] <masak> diakopter! \o/

[20:21] <masak> diakopter: you're supposed to shave the whales, not dye them!

[20:22] * diakopter writes JIRA plugins this week

[20:22] * diakopter wrote an html5 app optimized for iPad last week

[20:22] <diakopter> too much variety

[20:22] <masak> moritz: my new favorite game could be called a micro connection game: http://www.cameronius.com/games/span/

[20:23] <masak> diakopter: is this $dayjob, or something else?

[20:25] <tadzik> woot, rakudo passes 23k tests

[20:26] <sorear> diakopter! o/

[20:26] <jnthn> tadzik: :D

[20:27] *** skipper left
[20:31] *** birdwindupbird left
[20:32] *** noteventime joined
[20:35] <masak> tadzik: didn't we pass 20k tests only weeks ago?

[20:35] <tadzik> something along this, yes

[20:35] *** Trashlord left
[20:36] <masak> crazy.

[20:37] <masak> so not only have Niecza and Rakudo been locked in an even race, they've been running full speed at the same time?

[20:37] <masak> we shoulda done this competition thing ages ago :P

[20:38] <sisar> masak: http://strangelyconsistent.org/blog/june-20-2011-hangman doen't work for me

[20:38] <fglock> we need a 3rd team, just writing more tests

[20:38] *** Trashlord joined
[20:39] <sisar> i'm getting 'words' as the word to be guessed, everytime

[20:39] * jnthn bets a missing .IO

[20:40] <sisar> but line 1 for "states" works

[20:41] <masak> sisar: huh. I'll look into it. sounds odd.

[20:41] <sisar> ok

[20:42] *** parcs` joined
[20:47] <moritz> my $WORD = lines("words").roll;

[20:47] <moritz> yep, that's outdated

[20:48] <moritz> lines() now just breaks a string into lines

[20:48] <masak> aha, that simple.

[20:48] <masak> sisar: fix: lines("words".IO).roll;

[20:48] <masak> I'll update the post.

[20:48] <moritz> can be fixed with an .IO, just as jnthn++ predicted

[20:48] <moritz> or open('words').lines

[20:48] <masak> sisar++, jnthn++, moritz++

[20:48] <moritz> which I personally prefer

[20:48] <sisar> masak++

[20:49] <masak> I never liked open.lines -- the point of .lines is to abstract away the open

[20:50] <sisar> .IO treats "words" as a Input/Output object rather than a string?

[20:51] <sisar> slurp does not need .IO ?

[20:52] *** pernatiy joined
[20:52] <moritz> well, .IO treats "words" as path

[20:53] <moritz> and lines(IO) reads from the IO object passed to it

[20:53] *** kst left
[20:54] <sisar> slurp defaults to slurp(IO) ?

[20:56] <moritz> slurp opens the file for you if you pass a string (and not an IO object) to it

[20:58] *** kst joined
[21:00] * sisar zzz...

[21:01] <masak> moritz: you should learn to explain that in a way that doesn't make your audience fall asleep :P

[21:12] *** snearch joined
[21:15] *** Khisanth left
[21:16] <moritz> masak: maybe it was something you didn't say :-)

[21:16] *** snearch left
[21:19] <masak> I'm glad sisar is perusing my Perl 6 intro blog posts from this summer. I'll try to live up to the honor.

[21:21] <dalek> roast: 1af5f7a | moritz++ | S32-exceptions/misc.t:

[21:21] <dalek> roast: RT #71814, =begin without identifier

[21:21] <dalek> roast: review: https://github.com/perl6/roast/commit/1af5f7a99e

[21:22] <moritz> I *love* it when I can use typed exceptions to close tickets that complain about bad errors

[21:22] <moritz> there are many tickets in the 'testneeded' queue where the error is already a typed exception

[21:23] <gfldex> it all falls into place

[21:23] <gfldex> there must be some sort of master plan

[21:23] <moritz> well, it was one of my major reasons for applying for that exception grant :-)

[21:24] <moritz> so it's not really unexpected

[21:24] <moritz> but stilly very gratifying

[21:26] <masak> moritz++

[21:26] *** gv left
[21:26] *** GlitchMr left
[21:27] *** kst left
[21:28] *** kst joined
[21:29] *** Khisanth joined
[21:32] *** MayDaniel left
[21:33] <sorear> jnthn: how is your time now?

[21:39] <jnthn> sorear: I'm aboutish.

[21:39] <jnthn> As in, physically here. Mentally, questionable. :)

[21:39] <jnthn> (Insufficient sleep...)

[21:41] <moritz> sorear: it seems that niecza's "make" isn't safe for parallel make when obtaining a new bootstrap compiler

[21:42] <moritz> and, completely unrelated

[21:42] <moritz> in https://rt.perl.org/rt3/Ticket/Display.html?id=76486 it's always the first multi that's called. Is that right?

[21:42] <jnthn> moritz: looking

[21:43] <moritz> and if yes, why doesn't the case with [] give ambiguous dispatch?

[21:43] <jnthn> argh, that ticket has a bunch of examples. Which are we looking at?

[21:43] <moritz> the very last one

[21:43] <moritz> in the last reply

[21:44] <moritz> perl6: multi sub a(@a) { say 1 ~ @a.perl }; multi sub a([]) { say 2 ~ [].perl }; a []

[21:44] <p6eval> rakudo d4dc7d: OUTPUT«1Array.new()␤»

[21:44] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "[])"␤    expecting formal parameter or ")"␤    at /tmp/UwCYKvZkPH line 1, column 50␤»

[21:44] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«2[]␤»

[21:44] *** y3llow_ joined
[21:44] <moritz> I kinda agree with niecza here

[21:44] *** pothos_ joined
[21:45] <jnthn> Same...I'm thought we had a passing test for that case too

[21:45] <moritz> I was about to write on... and it didn't pass :/

[21:45] *** havenn joined
[21:46] <jnthn> ah

[21:46] <jnthn> Something is off here.

[21:46] *** pothos left
[21:46] *** y3llow left
[21:47] *** y3llow_ left
[21:47] *** y3llow joined
[21:48] <dalek> roast: a288e1f | moritz++ | S06-multi/unpackability.t:

[21:48] <dalek> roast: RT #76486

[21:48] <dalek> roast: review: https://github.com/perl6/roast/commit/a288e1fc8d

[21:48] <moritz> I'll just roast it, and reply to the ticket

[21:48] <jnthn> oh, I think I see...

[21:48] *** pothos_ left
[21:48] *** parcs` left
[21:48] *** pothos joined
[21:49] <noteventime> I just started learning a little Perl 6 (having basically no prior experience with any Perl), and I'm a little confused by named parameters. How can one tell the difference between passing a named parameter and passing a non-named pair? If it does it by inspecting the type of the left hand side of the pair, what is that type and where/how is it bound?

[21:49] *** y3llow left
[21:50] <masak> noteventime: it's a syntactical distinction.

[21:50] <jnthn> moritz: Looks like it may have been a bug in building the signature object. Compiling an attempted fix at the moment.

[21:50] <moritz> noteventime: it's syntactic

[21:50] *** y3llow joined
[21:50] * masak is faster :)

[21:50] <noteventime> Ok

[21:50] <moritz> noteventime: the a => $value and :a($value) forms are named

[21:50] <moritz> whereas 'a' => $value (note the quotes) and $pair forms are positionals that happen to be pairs

[21:50] <noteventime> So I can't do anything magical like passing named variables by a hash table?

[21:51] <moritz> noteventime: you can, be you have to declare your magic

[21:51] <moritz> mysub(|%h) uses all the pairs from %h as named arguments

[21:51] <noteventime> And what types do the keys have to be?

[21:51] *** pothos left
[21:52] *** wolfman2000 left
[21:52] <noteventime> (Or I guess, how does it map the keys of the hash table to the named parameters?)

[21:52] <moritz> nom: sub greet(:$whom) { say "welcome $whom" }; my %h = whom => 'noteventime'; greet |%h

[21:52] <masak> whatever type you declare your parameter to be.

[21:52] <p6eval> nom d4dc7d: OUTPUT«welcome noteventime␤»

[21:52] *** y3llow left
[21:52] *** pothos joined
[21:52] <moritz> by name :-)

[21:52] *** y3llow joined
[21:52] <moritz> the keys of a standard hash are always of type Str

[21:52] <noteventime> Interesting

[21:52] <masak> noteventime: it maps the hash key to the name of the named param.

[21:52] *** kst left
[21:53] *** fglock left
[21:53] <moritz> and the value can be of type Mu, that is to say any possible value

[21:53] <sorear> noteventime: you can also say fun((a => 2)) to pass a Pair value

[21:53] *** kst joined
[21:53] <moritz> ah right, that trick also exists. I usually forget about it.

[21:53] <sorear> noteventime: there seems to be a semi-general rule in Perl 6 that parens disable syntactic magic

[21:53] <noteventime> Ok, I didn't realise that hash table keys were strings by default :)

[21:53] <moritz> sorear: except when they don't :-)

[21:54] <noteventime> Nice, thanks for the explanation

[21:54] *** y3llow left
[21:54] <moritz> nom: my %h{Any}; class A { method Str() { 'foo' } }; %h{A.new} = 1; sub f(*%h) { say %h.perl }; f |%h

[21:54] <p6eval> nom d4dc7d: OUTPUT«("A|7279588910590874249" => 1).hash␤»

[21:54] <moritz> heh

[21:54] <moritz> it uses .WHICH

[21:54] *** y3llow joined
[21:54] *** pothos left
[21:55] <moritz> which is... dubious, but somehow not surprising

[21:55] <sorear> Hash table keys in Perl have historically[1] always been Str.  It was only a week or two ago that Rakudo added support for non-Str hash keys, and Niecza still doesn't have them

[21:55] <sorear> [1] it's possible to plug in modules that override this

[21:55] *** pothos joined
[21:57] <sorear> rakudo: my $r1 = role { method foo() { 5 } }; my $r2 = role { method foo() { 7 } }; my %hash{Any}; %hash{"quux" but $r1} = 9; %hash{"quux" but $r2} = 11; say %hash.keys>>.foo

[21:57] <p6eval> rakudo d4dc7d: OUTPUT«5␤»

[21:57] <moritz> ouch

[21:58] *** pothos left
[21:58] <masak> huh.

[21:58] *** pothos joined
[21:58] <moritz> rakudo: my $r1 = role { method foo() { 5 } }; my $r2 = role { method foo() { 7 } }; say ("quux" but $r1).WHICH; say ("quux" but $r2).WHICH

[21:58] <p6eval> rakudo d4dc7d: OUTPUT«Str+{<anon>}|quux␤Str+{<anon>}|quux␤»

[21:59] <moritz> seems we are insufficiently paranoid in ClassHOW.gist, or we should be using something else in .WHICH

[21:59] <masak> those look more like .WHAT than .WHICH to me.

[21:59] <moritz> masak: feel free to rakudobug

[21:59] <jnthn> Er, we shoudln't be using the typename. :)

[21:59] *** kst left
[21:59] <jnthn> Just use nqp::where($the_type.HOW) to get a unique identifier for the type.

[21:59] <moritz> ok

[22:00] *** kst joined
[22:00] * araujo wonders if someone is already using perl6 in production environments out there

[22:00] <jnthn> I guess it doesn't matter what we use so long as it's type-unique.

[22:00] <sorear> araujo: yes, it's done

[22:00] <araujo> sorear, though it is still under development, I guess ... small scripts 100~200 LOC would be ok to go right?...

[22:00] <araujo> I mean for such a tasks

[22:01] *** pothos left
[22:01] <moritz> yes

[22:01] <sorear> araujo: even large scripts are ok!  it's more a question of performance and longevity

[22:01] *** pothos joined
[22:01] <araujo> sorear, I care about the latter mainly, yes

[22:01] <moritz> people use such scripts to generate test data for "production" tasks, for example

[22:01] *** havenn left
[22:01] <sorear> you *will* have to make small changes to your scripts every few months to keep them running.

[22:02] <araujo> sorear, right, that is why I guess small scripts shouldn't be a big deal to maintain

[22:02] <araujo> moritz, interesting

[22:02] <araujo> good to know

[22:02] <sorear> araujo: use common sense and try not to write excessively fancy code

[22:03] * araujo nods

[22:03] <sorear> if you write a torture test for the junction engine, it's much more likely to need tweaks

[22:04] *** pothos left
[22:04] <araujo> I guess using .. basic constructs and such... not getting too fancy as you say ... would keep the code easy to maintain

[22:04] *** pothos joined
[22:05] <[Coke]> moritz: I have fond memories of paranoia.

[22:05] * moritz too

[22:05] <moritz> time for sleep here

[22:05] *** rodolo joined
[22:05] <[Coke]> tadzik: I think you might be counting skips in your 23k.

[22:05] * moritz waves to the cheering crowd :-)

[22:05] *** tokuhirom left
[22:06] <masak> good night, moritz.

[22:06] <sorear> jnthn: I'm wondering if now would be a good time to ask about your "shapes as mixins" comment

[22:06] <jnthn> 'night moritz 

[22:06] <masak> dream of cheering crowds and butterflies.

[22:07] *** pothos left
[22:07] * masak submits rakudobug of the 'but $r1' case above.

[22:07] *** rodolo left
[22:07] *** pothos joined
[22:07] <jnthn> sorear: Today I implement typed hashes as Hash + a mixin.

[22:08] <jnthn> sorear: Mostly, I was wondering if other such bits of S09 can be handled in that way.

[22:08] <jnthn> sorear: I haven't thought it all the way through yet.

[22:09] <jnthn> sorear: Seems a natural way of only making types with extra constraints pay for them, or on the flip side getting the information into the type system for optimizers to care about.

[22:09] *** skids left
[22:09] <tadzik> [Coke]: I probably am

[22:12] <jnthn> sorear: There may well be drawbacks to that approahc.

[22:12] <jnthn> *approach

[22:13] <masak> araujo: my blog engine is written in Perl 6. it has been building HTML to be served to the world since September 2010.

[22:15] <araujo> masak, hehehe nice :D

[22:16] <araujo> masak, how easy has been to maintain during this time?

[22:16] <araujo> many changes along the way?

[22:17] <masak> practically none.

[22:18] <masak> I don't remember anything that made me tear out my hair.

[22:18] <masak> compared to maintaining, say, November back in 2008/2009, this has been a breeze.

[22:19] <flussence> I have to say, I was really impressed after the announcement of forum.dlang.org's existence a few days ago

[22:19] <flussence> their site loads as fast as your blog does!

[22:20] <sorear> meh

[22:20] <araujo> masak, good to know :)

[22:20] <sorear> anyone who's really serious about running a web site should use a PHP wiki engine

[22:20] <sorear> that's what mikemol does

[22:20] <dalek> rakudo/macros3: fca3907 | masak++ | / (7 files):

[22:20] <dalek> rakudo/macros3: implemented quasi quotes and macros

[22:20] <dalek> rakudo/macros3: 

[22:20] <dalek> rakudo/macros3: This works:

[22:20] <dalek> rakudo/macros3: 

[22:20] <dalek> rakudo/macros3: - Macro declarations

[22:20] <dalek> rakudo/macros3: - Calling a macro (using `macro()` and `macro` and operators)

[22:20] <dalek> rakudo/macros3: - Quasi quotes

[22:20] <dalek> rakudo/macros3: - Variable lookup from within the quasi quote

[22:20] <dalek> rakudo/macros3: 

[22:20] <dalek> rakudo/macros3: This doesn't, yet:

[22:20] <dalek> rakudo/macros3: 

[22:20] <dalek> rakudo/macros3: - Returning a macro parameter instead of a quasi

[22:20] <dalek> rakudo/macros3: - Variable lookup from within a macro parameter

[22:20] <dalek> rakudo/macros3: review: https://github.com/rakudo/rakudo/commit/fca39072d2

[22:21] <masak> macros2 is dead -- long live macros3.

[22:21] <flussence> third time lucky? :)

[22:21] * jnthn wonders how high we'll get :)

[22:21] <jnthn> .oO( We probably need to get pretty high to work out macros :P )

[22:22] <mikemol> sorear: >.>

[22:22] * masak hugs sorear 

[22:23] * [Coke] writes a very very very small amount of haskell.

[22:24] <tadzik> masak: you didn't name your clone masak2, but your branches are named macros, macros2, macros3... ;)

[22:24] <sorear> If I have a clone I'll name em `uuidgen`

[22:25] <masak> tadzik: the branches don't risk having their sense of primacy hurt.

[22:25] <tadzik> :)

[22:25] <tadzik> that's what _you_ think!

[22:25] <masak> yes, it is.

[22:25] <flussence> sorear: I think that's how a few sci-fi stories of clones going insane start...

[22:27] <dalek> rakudo/nom: dc6b0ef | jnthn++ | src/Perl6/Actions.pm:

[22:27] <dalek> rakudo/nom: For sub-signatures using [...] we should constrain to Positional.

[22:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dc6b0efb91

[22:27] <dalek> rakudo/nom: 79c8e19 | jnthn++ | src/Perl6/Actions.pm:

[22:27] <dalek> rakudo/nom: Fix the do-we-have-a-subsig test so it doesn't drop 0-arity subsignatures.

[22:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/79c8e19b4b

[22:27] <dalek> roast: 2228433 | jnthn++ | S06-multi/unpackability.t:

[22:27] <dalek> roast: Untodo a couple of multi tests.

[22:27] <dalek> roast: review: https://github.com/perl6/roast/commit/2228433661

[22:30] *** kst left
[22:30] *** kst joined
[22:40] <masak> earlier this evening, I realized that I would probably have lots of long, silent psychological struggles with my clones. like, moving back and forth between a cupboard and a cup hanging from the wall.

[22:40] <masak> no-one would say anything, but it would be like a tense situation. it would go on form months, or years.

[22:40] <masak> for*

[22:40] <dalek> rakudo/nom: 4f62718 | jnthn++ | src/core/traits.pm:

[22:40] <dalek> rakudo/nom: Eliminate old hack from the bad old days when we ran traits again at startup.

[22:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4f62718a0f

[22:41] *** kst left
[22:41] *** kst joined
[22:41] <tadzik> jnthn: how far is require from working?

[22:42] <masak> s/moving back and forth/moving a toothbrush back and forth/

[22:44] <tadzik> or maybe import, not require

[22:44] *** mucker left
[22:44] <jnthn> tadzik: import as in...?

[22:45] <tadzik> as in require 'Foo::Bar'; import 'Foo::Bar'

[22:45] <tadzik> or such

[22:45] <jnthn> That can't work as import operates at compile time

[22:46] <jnthn> But require can probably be made to work pretty soon

[22:46] <jnthn> I plan to look over the whole import/export thing a bit more soon. It gets a bit easier now.

[22:46] <jnthn> Do you have a use case in mind? :)

[22:46] <tadzik> hmm, require seems to Just WOrk

[22:46] <jnthn> Oh. :)

[22:47] * tadzik looks for a use case he had in mind

[22:47] <jnthn> Oh, it's marked as working but no import lists in features.

[22:47] <jnthn> Which is the state I thought it was in.

[22:48] <tadzik> what was the syntax for getting a class by name?

[22:48] <tadzik> like ::("Foo") or something

[22:49] <jnthn> nom: class A { }; say ::("A")

[22:49] <p6eval> nom d4dc7d: OUTPUT«A()␤»

[22:49] <tadzik> huh

[22:49] <jnthn> Apparently, that :)

[22:50] <tadzik> https://gist.github.com/1962048 this doesn't work for some reason

[22:51] *** kst left
[22:52] <jnthn> Try

[22:52] <jnthn> ::('MyModule')::('&foo')();

[22:52] <tadzik> no change

[22:55] *** kst joined
[22:56] <tadzik> but then: my $a = &MyModule::foo; $a.() works

[22:56] <tadzik> ::('&MyModule')::('foo')(); does not

[22:56] <[Coke]> seen au?

[22:56] <aloha> au was last seen in #perl6 6 hours 4 mins ago saying "pugs: &infix:<...>(1,2)".

[22:58] <jnthn> tadzik: INDIRECT_NAME_LOOKUP doesn't fall back to looking in GLOBAL, it seems

[22:58] <[Coke]> phenny, ask au: given http://feather.perl6.nl/~coke/pugs.diff, all the method seem to work: I can do "3.Int.Num.Rat" -> 3/1 - however, when I say "Int" with this patch, I get an error about multis. pre-patch it returns "::Int"; any pointers?

[22:58] <phenny> [Coke]: I'll pass that on when au is around.

[22:59] *** att left
[22:59] <[Coke]> (rough guess, this is worth at least 1000 tests. ;)

[23:00] *** kaare_ left
[23:02] *** glass left
[23:03] *** havenn joined
[23:04] <jnthn> tadzik: Got a patch locally

[23:04] <tadzik> yay!

[23:04] <jnthn> tadzik: 'twas a one-liner

[23:05] <jnthn> Running spectest justin case

[23:05] <jnthn> (only takes 3 mins or so here...)

[23:05] <tadzik> :)

[23:05] <jnthn> It *was* 3 mins before tadzik++ went and got us passing more tests :)

[23:05] <tadzik> if a minute was 300 seconds it'd also take about 3 minutes in here :)

[23:05] <tadzik> :P

[23:07] *** mj41 left
[23:07] *** kst left
[23:08] <jnthn> tadzik: If you have a moment to add a test, that'd be awesome ;)

[23:08] <dalek> rakudo/nom: 715aed6 | jnthn++ | src/core/operators.pm:

[23:08] <dalek> rakudo/nom: Fix ::('blah') lookups to also fall back to GLOBAL (tadzik++ for noting the bug).

[23:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/715aed6db3

[23:09] <jnthn> Note it needs to be ::('MyModule')::('&foo')();

[23:09] <tadzik> jnthn: I'll find one, sure :)

[23:09] <tadzik> jnthn++

[23:09] *** mj41 joined
[23:10] *** kst joined
[23:15] *** mucker joined
[23:19] <dalek> roast: dfd1074 | tadzik++ | S11-modules/require.t:

[23:19] <dalek> roast: Add a test for calling subroutines by name in a module that was require()d

[23:19] <dalek> roast: review: https://github.com/perl6/roast/commit/dfd1074105

[23:19] <jnthn> \o/

[23:20] <tadzik> let's see if that works for classes...

[23:21] <tadzik> \o/

[23:21] <tadzik> now zby should be able to port WebNano to Perl 6 :)

[23:22] <jnthn> woo

[23:22] <masak> \o/

[23:23] <tadzik> at least until I get to know about another blocker :)

[23:24] *** aindilis left
[23:26] *** icwiener left
[23:34] *** whiteknight joined
[23:36] <masak> 'night, #perl6

[23:36] <jnthn> 'najt, masak

[23:38] *** skids joined
[23:38] <mathw> lo

[23:39] <jnthn> hi, mathw 

[23:40] <mathw> I seem to have broken my sleep schedule

[23:40] <mathw> it's 23:40 and I just woke up feeling like it's time to start the day

[23:42] <jnthn> Oops.

[23:42] <jnthn> :)

[23:42] <jnthn> 'tis done far too easily.

[23:43] <jnthn> Though normally I do it in the summer, when there's not much darkness to remind me that night exists :)

[23:43] <mathw> ah we don't really have that problem so much

[23:44] <mathw> my problem was that this morning (which I'm now thinking of as 'yesterday') I woke up at about 3am thanks to the pain in my stupid leg, went for a walk to loosen it out, and kind of never went back to sleep...

[23:44] <mathw> so it seems I went to sleep again at about 6pm

[23:44] <mathw> maybe

[23:45] <jnthn> Sorry to hear about the leg :(

[23:45] <jnthn> Hope it improves.

[23:45] <mathw> I have my second visit to the physiotherapist in 10 hours

[23:46] <mathw> so far he's got it to loosen up in exchange for near-constant pain. I'm assured this is normal.

[23:53] *** colomon left
[23:55] *** mj41 left
