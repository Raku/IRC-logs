[00:01] *** att joined
[00:12] *** att left
[00:23] *** colomon joined
[00:23] * jnthn disappears for the night

[00:34] *** havenn left
[00:37] *** havenn joined
[00:37] *** colomon left
[00:40] *** havenn left
[00:43] <noteventime> Are there any reasons (apart from performance?) for using methods over multis?

[00:55] *** Trashlord left
[01:00] *** Chillance left
[01:05] *** att joined
[01:09] *** Trashlord joined
[01:11] *** whiteknight left
[01:22] <TimToady> noteventime: well, in theory the multis can be faster than the methods, since the candidate list can be statically determined, and possibly trimmed down to one if the types are knowable

[01:23] <TimToady> really, you should just ask yourself, "Is this something the object should be in charge of, or is it something in the semantic space between objects?"

[01:25] <TimToady> if you find yourself contorting symmetric semtantics into asymmetric calls for the sake of OO, it's a code smell

[01:25] <TimToady> 1.add(2) is not very perly

[01:31] <noteventime> Timbus: I'm generally not very fond of object oriented programming, preferring algebraic data types and closures. Multis seem like a reasonable compromise kind of thing. Also I never understood the point with single dispatch OO in a language which doesn't do static type checking (as far as I can see you might just as well store closures in a record type).

[01:32] <noteventime> TimToady: sorry, I misstabed

[01:32] <noteventime> (I thought erc didn't do that :/)

[01:35] <noteventime> I really quite like what Perl 6 is doing in the whole OO department though, reminds me of CLOS (though I don't know enough about any of them to know if that's just a superficial similarity due to both supporting multiple dispatch).

[01:42] <sorear> in practice method calls will probably be faster than multis

[01:43] *** noam_ joined
[01:46] *** noam left
[01:52] <TimToady> noteventime: it's not just a superficial resemblance; both languages are fundamentally FP underneath, and methods are just closures that some dispatcher has found; multis are just closures that a different dispatcher has found

[01:53] *** whiteknight joined
[01:56] <noteventime> Timbus: Interesting, are there some kind of formal semantics for reasoning about the object system?

[02:00] <noteventime> TimToady* (I'm really sorry, I don't know what's up with ERC, it has never behaved like this before)

[02:10] *** isBEKaml left
[02:10] * [Coke] is sad that the haskell daemon hasn't appeared to answer my question!

[02:10] *** mucker left
[02:14] <noteventime> Haskell daemon?

[02:14] <TimToady> not really, but there is sufficient introspection of the metaobjects that such could probably be defined as a sublanguage

[02:14] <[Coke]> noteventime: our resident Haskell expert who might be able to help me patch Pugs.

[02:15] <TimToady> decommuting &

[02:15] *** wolfman2000 joined
[02:18] *** wolfman2000 left
[02:18] <noteventime> [Coke]: Unless it's Pugs specific you could always try the excellent #haskell :)

[02:19] *** wolfman2000 joined
[02:23] <sorear> oh, is #haskell excellent again?

[02:24] <sorear> I was the most active human in 2007 but it started sucking and I left

[02:25] <noteventime> sorear: Well, I haven't been very active lately, but I remember it as being really great

[02:25] <noteventime> sorear: In what way did it start sucking? I'm pretty sure I haven't been seeing a lot of trolling/flaming or anything like that

[02:27] <[Coke]> oh, maybe sorear can answer my question. ;

[02:27] <[Coke]> ;)

[02:29] *** noam_ left
[02:34] *** tokuhirom joined
[02:35] *** jaldhar joined
[02:36] <sorear> noteventime: a culture appeared where it was unacceptable to ever talk negatively about Haskell

[02:36] <sorear> it used to be I could talk honestly about Haskell's strengths and weaknesses

[02:38] <noteventime> sorear: You might have a point there actually

[02:38] <[Coke]> good thing that happened, or you'd be working on pugs instead of niecza. ;)

[02:39] <noteventime> Not that I'm trying to defend it or anything, but doesn't that tend to happen to almost all larger tech communities 

[02:39] <sorear> noteventime: the motto of Haskell used to be "Avoid success at all costs"

[02:39] <noteventime> Some kind of over defensiveness against trolls

[02:43] <noteventime> Hopefully this doens't come out as offensive, but why would one want target CLR any longer? Migrating/interoperating with legacy code?

[02:43] <geekosaur> noteventime, library availability

[02:43] <noteventime> Wouldn't the JVM be a better target for that?

[02:44] <noteventime> I guess it might just be a matter of taste, but I can't remember seeing a lot of CLR things

[02:44] <noteventime> It might just be that I don't mingle in the areas that do though 

[02:44] <geekosaur> there's enough stuff on CLR, easily

[02:45] <geekosaur> I'm not real familiar with the CLR bytecode but I would not be surprised if it were easier to design for; JVM bytecode is very Java-centric and often painful for languages tht don't work like Java does

[02:45] *** thou left
[02:45] <geekosaur> CLR has had *some* thought put into not being really tightly bound to C#

[02:46] <noteventime> That might be true too

[02:46] <noteventime> Though hasn't that changed with things like Clojure?

[02:46] * geekosaur has worked a little with jvm bytecode.  it really does have a tight relationship with javathink

[02:46] <geekosaur> clojure does a lot of working around it

[02:46] <geekosaur> scala chose to work with it instead by staying fairly close to java

[02:46] <noteventime> I remember issues with it lacking tail recursion optimisation

[02:47] <sorear> noteventime: CLR startup is a lot faster/uses way less memory than JVM (comparing mono to HotSpot)

[02:47] <noteventime> Though I never quite figured out why tail recursion couldn't be optimised in the frontend

[02:47] *** NamelessTee left
[02:47] <geekosaur> sometimes it can

[02:47] <sorear> noteventime: no-one has ever been sued for using the CLR; people have been sued for picking Java

[02:47] <sorear> noteventime: Indirect tail calls

[02:47] <sorear> return $foo();

[02:48] <sorear> the #1 reason I don't use Java is that HotSpot is unusably slow on my machine

[02:50] <noteventime> Haha, like my mother once told me "Ahh Java, it's that thing where you get a cup of coffee down by the clock and then everything locks up" :)

[02:52] <sorear> I've looked into the possibility of porting niecza to the JVM; the biggest yucky spot seems to be that the JVM is hostile to functional programming

[02:52] <sorear> if you want to be able to refer to 10,000 first class functions in the JVM, you need 10,000 classes, 10,000 .class files on disk...

[02:53] <[Coke]> pugs: say Int

[02:53] <p6eval> pugs b927740: OUTPUT«Int␤»

[02:53] <noteventime> At the risk of sounding really stupid, how much of an issue is that for perl? It is "just" the closures, or are there deeper reasons?

[02:53] <[Coke]> anyone know where that's defined?

[02:53] <sorear> noteventime: every function in a perl program can potentially be the target of &foo

[02:54] <noteventime> sorear: Sure, but you already treat functions as objects, don't you?

[02:54] <noteventime> Or is that just syntactic sugar?

[02:54] <sorear> noteventime: treating functions as objects

[02:55] <sorear> noteventime: treating functions as P6-objects requires compiling each one to a JVM-class

[02:55] <sorear> any function object can be called!

[02:56] <sorear> noteventime: iow, I don't understand your question.

[02:56] <geekosaur> ^^ that is what I meant by javathink embedded in the bytecode

[02:56] <noteventime> sorear: I mean, on the perl side, doesn't Perl 6 do something like Ruby's everything-is-an-object?

[02:56] <geekosaur> it's also why functional languages for the jvm tend to come with hugeous runtime jars

[02:56] <sorear> noteventime: that's not relevant at all

[02:56] <noteventime> Sorry if I'm being thick, 4 in the morning and I just started reading a little about perl 6 today

[02:57] <sorear> noteventime: think about it

[02:57] <sorear> noteventime: if I have an object that wraps a function, how is the object supposed to hold a reference to the function?

[02:57] <sorear> and please don't say "java.lang.reflect.Method"

[02:57] *** sisar left
[02:58] <noteventime> I don't know, I'm not familiar with Java runtime or idioms, it just seemed that the JVM should be able to optimise it. Doens't it do something like anonymous classes to get something similar to closures?

[02:59] <geekosaur> last I checked all anonymous classes were ugly hacks underneath

[02:59] <sorear> noteventime: sort of, but they're not really anonymous

[02:59] <noteventime> Only time I had to do in Java was in a really horrible intro to programming course at university

[02:59] <sorear> noteventime: they get names like Foo$30, and are saved in Foo$30.class

[02:59] <noteventime> Ok, that explains it

[02:59] <sorear> noteventime: s/closures/all first-clas functions/

[03:00] <noteventime> Right

[03:00] <noteventime> I remember, gave me lots of headache 

[03:00] <sorear> on the internet people misuse the word "closure" far more often than they use it correctly

[03:00] <sorear> people just shouldn't use it at all :|

[03:00] <noteventime> I thought you could do something like a function pointer at least

[03:00] <sorear> nope!

[03:01] <sorear> on the CLR you can.

[03:01] <noteventime> You can't do anything like a function pointer even in java bytecode?

[03:01] <sorear> No.

[03:01] <noteventime> I see, that makes things a lot more clear :)

[03:02] <noteventime> I thought the issue was just related to closures

[03:03] <noteventime> Each time I hear something new about java it surprises me with how horrible it is

[03:05] <noteventime> I kinda dislike beating on the language like that, but I can't say anything positive about it

[03:05] <sorear> java is a definite improvement on the things that came before it, for the purposes for which it was developed

[03:06] <noteventime> sorear: Before it? As in C++ or do you mean COBOL?

[03:06] <noteventime> Because I'd probably rather use C++ than Java to be honest

[03:06] <sorear> I do mostly mean C++

[03:06] <sorear> that's what the second part of my sentence was for

[03:07] <sorear> C++ is not very useful for a locked-down browser or smartphone runtime

[03:07] <noteventime> Right, that's true

[03:07] <noteventime> Sounds like you'd like better operating system security though

[03:08] <sorear> Defense in depth

[03:08] <sorear> OS-level security is not a panacea

[03:08] <noteventime> Neither is Java though ;)

[03:08] <sorear> it's slow, unportable, and often doesn't work at all

[03:09] <sorear> you combine it with runtime security to achieve somehting even better

[03:10] <noteventime> Possibly, I guess I couln't really say, I have absolutely no experience with such environments

[03:11] <noteventime> sorear: Wouldn't something like FreeBSDs jails work though?

[03:11] <noteventime> Or would that be too slow?

[03:11] <sorear> noteventime: nothing that allows user code to run on the bare CPU is ever going to be trustworthy

[03:12] <noteventime> (I have no idea about its details, just that it's something like a chroot which includes file handles, processes e.t.c.)

[03:12] <sorear> every few years some CPU bug is discovered that allows unprivileged code to break the sandbox

[03:12] <sorear> or at least crash the processor

[03:13] <noteventime> So the reasoning is that a CPU isn't patchable?

[03:14] *** orafu left
[03:14] <noteventime> Otherwise I don't see why a VM should be less prone to such issues 

[03:14] *** orafu joined
[03:15] <sorear> noteventime: the adversary will act before you have a chance to patch your system.

[03:16] <noteventime> sorear: Why couldn't that be true for a virtual machine too though?

[03:16] *** colomon joined
[03:16] <noteventime> It still has to issue syscalls of some kind somewhere

[03:17] <sorear> Non sequitur

[03:18] <sorear> o/ colomon

[03:18] <noteventime> sorear: What I mean is, there could just as well be a bug in the virtual machine that allowed some kind of arbitrary code execution 

[03:18] <colomon> o/ ... but he's off at a concert and his wife stole his computer! :)

[03:19] <sorear> noteventime: https://en.wikipedia.org/wiki/Defense_in_depth

[03:21] <noteventime> Maybe I'm just missing the particular kind of issues you could run into. If everything runs in a VM it seems to me an issue in the VM would be as critical as an issue on the CPU would be when everything ran on bare CPU. Unless you use multiple VMs to separate the processes, in which case it seems to be the same thing as having something like jails.

[03:21] <noteventime> sorear: I'll think about it in the morning, perhaps I'm just too tired :) thanks for the info

[03:23] *** Guest54925 joined
[03:23] <Guest54925> Hello

[03:23] <sorear> you use a secured VM in a separate processor inside a chroot on a decent OS with a good processor

[03:23] <Guest54925> Can someone assist me with a PERL loop?

[03:23] <sorear> five dubious fences add up to a decent barrier

[03:24] <sorear> Guest54925: it's not PERL, it's Perl

[03:24] <sorear> and you want #perl-help

[03:24] <Guest54925> Thanks

[03:24] <sorear> this is the channel for the Perl 6 redesign

[03:25] <Guest54925> How can I find #perl-help?

[03:25] <timotimo> why not? doesn't Perl have a Print Eval Read Loop?

[03:25] <sorear> Guest54925: google it.  when you find the right server, read the documentation for your IRC client to find out how to join.

[03:26] <noteventime> timotimo: Not REPL loop :) (I read REPL at first too)

[03:26] <sorear> it's probably either on MAGnet or Freenode

[03:26] <noteventime> opps

[03:26] <noteventime> Sorry, I missed the joke, I must real be too tired

[03:26] <sorear> I don't know which, and I have a knee-jerk reaction to minimally help anyone who says PERL

[03:27] <sorear> it's like a reverse code word

[03:27] <noteventime> sorear: Like lisp people dislike people who say LISP :)

[03:27] <sorear> LISP actually means something

[03:27] <noteventime> or at least meant something

[03:27] *** Guest54925 left
[03:27] <sorear> if you say LISP, it means you're using one of the broken dialects from the 50s that don't handle funargs correctly, like MACLISP or elisp

[03:29] <noteventime> Though I doubt that's (with the possible exception of elisp) what the people saying LISP intend

[03:29] <noteventime> sorear: Maybe saying PERL means you really want PEARL?

[03:30] <shachaf> sorear: I've generally understood that "LISP" referred to any dialect, and "Lisp" refers to Common Lisp.

[03:32] <timotimo> i thought lisp was "list processor", so shouldn't it be LisP?

[03:32] <noteventime> I wonder if there ever was a word processor called WORP

[03:33] <timotimo> hah, that gives way to lots of star trek references and puns

[03:33] <timotimo> "warp 6!" - "whoa, microsoft hasn't even released worp 4 yet!"

[03:37] *** aindilis joined
[03:38] *** whiteknight left
[03:39] *** NamelessTee joined
[03:45] *** Tedd1^ joined
[03:47] *** Tedd1 left
[03:48] *** aindilis left
[03:48] *** aindilis joined
[04:11] *** marmalade left
[04:18] *** BinGOs joined
[04:27] *** tokuhirom left
[04:34] *** fsergot left
[04:47] *** araujo left
[04:49] *** autark left
[05:07] *** noteventime left
[05:32] <japhb> When fixing things in the spec, is the date/version stamp in the header supposed to be updated on all changes, or just the non-typo ones?

[05:32] *** NamelessTee left
[05:34] <dalek> specs: 186ae88 | (Geoffrey Broadwell)++ | S32-setting-library/Exception.pod:

[05:34] <dalek> specs: Fix typo

[05:34] <dalek> specs: review: https://github.com/perl6/specs/commit/186ae88c94

[05:34] <dalek> specs: bb4c5e5 | (Geoffrey Broadwell)++ | S02-bits.pod:

[05:34] <dalek> specs: Fix double thinko; remove trailing whitespace in same lines

[05:34] <dalek> specs: review: https://github.com/perl6/specs/commit/bb4c5e5638

[05:34] <dalek> specs: f8d2de3 | (Geoffrey Broadwell)++ | S32-setting-library/Basics.pod:

[05:34] <dalek> specs: Remove extra whitespace introduced by automated change

[05:34] <dalek> specs: review: https://github.com/perl6/specs/commit/f8d2de39f0

[05:36] *** birdwindupbird joined
[05:37] <dalek> specs: 86b688a | (Geoffrey Broadwell)++ | S32-setting-library/Containers.pod:

[05:37] <dalek> specs: Clarify wording in splice() description

[05:37] <dalek> specs: review: https://github.com/perl6/specs/commit/86b688a296

[05:47] *** kaare_ joined
[05:48] <TimToady> new entry: http://rosettacode.org/wiki/Factors_of_a_Mersenne_number#Perl_6

[05:49] <TimToady> japhb: there's no fixed boundary, whatever you think is substantial

[05:53] *** packetknife joined
[05:53] <TimToady> incidentally, that RC entry breaks rakudo with: splice() not implemented in class 'Mu'

[05:58] <sorear> afk power outage, be back tomorrow...

[06:05] *** packetknife left
[06:07] <Timbus> rakudo: my @a := 1,2, * + @a[0] ... *; say @a[4];

[06:07] <p6eval> rakudo 715aed: OUTPUT«use of uninitialized value of type Nil in numeric context␤use of uninitialized value of type Nil in numeric context␤use of uninitialized value of type Nil in numeric context␤splice() not implemented in class 'Mu'␤  in method reify at src/gen/CORE.setting:4515␤  in …

[06:10] <Timbus> niecza: my @a := 1,2, * + @a[0] ... *; say @a[4];

[06:10] <p6eval> niecza v15-2-gd19c478: OUTPUT«5␤»

[06:10] <Timbus> well then. take that, haskell.

[06:20] *** kaare_ left
[06:32] <moritz> \o

[06:34] *** kaare_ joined
[06:35] *** kaare_ left
[07:07] *** packetknife joined
[07:07] *** thou joined
[07:16] *** havenn joined
[07:18] *** packetknife left
[07:19] *** colomon left
[07:21] *** noam joined
[07:22] *** GlitchMr joined
[07:36] *** colomon joined
[07:38] <geekosaur> hmf.  mono from macports still can't use mono-sgen with niecza

[07:42] *** colomon left
[07:55] <japhb> TimToady, Roger that, thanks.

[08:02] *** araujo joined
[08:02] *** araujo left
[08:02] *** araujo joined
[08:16] *** colomon joined
[08:18] *** am0c left
[08:24] *** am0c joined
[08:36] *** sisar joined
[08:43] *** Patterner left
[08:48] *** Psyche^ joined
[08:48] *** Psyche^ is now known as Patterner

[08:48] *** snearch joined
[08:51] *** zipf joined
[08:53] *** zipf left
[08:53] *** zipf joined
[08:53] *** zipf left
[08:53] *** havenn left
[09:10] *** birdwindupbird left
[09:14] *** Patterner left
[09:17] *** birdwindupbird joined
[09:27] *** Psyche^ joined
[09:27] *** Psyche^ is now known as Patterner

[09:49] *** MayDaniel joined
[09:59] *** tarch_ joined
[10:14] *** snearch left
[10:18] *** tarch_ left
[10:30] *** sisar left
[10:34] <dalek> rakudo/nom: 06cf161 | moritz++ | src/core/Complex.pm:

[10:34] <dalek> rakudo/nom: Implement constant i for complex numbers

[10:34] <dalek> rakudo/nom: 

[10:34] <dalek> rakudo/nom: constant i = 1i; had bootstrappy problems last I tried, but now

[10:34] <dalek> rakudo/nom: we can simply write Complex.new(0, 1) on the RHS. jnthn++

[10:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/06cf16181b

[10:40] *** am0c left
[10:44] <tadzik> https://gist.github.com/1965528 enum exportation bug

[10:47] *** JimmyZ_ joined
[10:47] <JimmyZ_> nom: say pi; pi.WHAT

[10:47] <p6eval> nom 715aed: OUTPUT«3.14159265␤»

[10:48] <JimmyZ_> nom: say pi; say pi.WHAT

[10:48] <p6eval> nom 715aed: OUTPUT«3.14159265␤Num()␤»

[10:48] <JimmyZ_> nom: constant pi = 3.1415926535897832; say pi; say pi.WHAT;

[10:48] <p6eval> nom 715aed: OUTPUT«3.14159265358978␤Rat()␤»

[10:48] <JimmyZ_> nom: constant pi = 3.14159265; say pi; say pi.WHAT;

[10:48] <p6eval> nom 715aed: OUTPUT«3.14159265␤Rat()␤»

[10:52] <JimmyZ_> niecza: say pi; say pi.WHAT

[10:52] <p6eval> niecza v15-2-gd19c478: OUTPUT«3.1415926535897931␤Num()␤»

[10:52] <JimmyZ_> niecza: constant pi = 3.1415926535897831; say pi; say pi.WHAT;

[10:52] <p6eval> niecza v15-2-gd19c478: OUTPUT«3.1415926535897833␤Rat()␤»

[10:59] <jnthn> afty o/

[10:59] <jnthn> tadzik: Looks like it's export the enum itself, but not the individual symbols.

[11:00] <jnthn> tadzik: RT it (got a few things to do before I get Perl 6 tuits today), but I should be able to fix it fairly easily.

[11:01] <JimmyZ_> afternoon 

[11:02] <tadzik> cool

[11:05] <tadzik> now that I think about Perl 6 module infrastructure compared to CPAN, it's a bit like The Pirate Bay with magnet links compared to TPB serving .torrent files

[11:06] <tadzik> CPAN has lots of .tar.* archives, we have lots of URLs to META.info files, which contain everything you need to know to obtain and install a module

[11:06] <tadzik> I like how accidental evolution leads to such things

[11:08] <jnthn> :)

[11:09] * jnthn has to write his talk today also :)

[11:09] <jnthn> Or at least start on it.

[11:09] <tadzik> yeah

[11:09] <tadzik> I just started thinking "what the hell am I going to talk about for 20 minutes" ;)

[11:10] <jnthn> Just take like 20 rage faces and talk about an aspect of the module ecosystem that reflects each one. :)

[11:10] * jnthn sketched his out last night and thinks he'll fill his 40 minutes quite easily

[11:18] <arnsholt> I have a trollface on slide two of my lecture for monday =)

[11:19] *** noam left
[11:20] *** noam joined
[11:21] <tadzik> :)

[11:46] *** am0c joined
[11:51] *** NamelessTee joined
[11:52] *** noteventime joined
[12:02] *** aindilis left
[12:03] *** aindilis joined
[12:06] *** wayland76 joined
[12:07] *** whiteknight joined
[12:21] *** mj41 joined
[12:29] *** robins is now known as robinsmidsrod

[12:52] *** zipf joined
[12:53] *** colomon left
[13:04] *** zipf left
[13:23] *** vlkv joined
[13:24] *** vlkv is now known as gv

[13:28] *** leprevost joined
[13:31] <moritz> perl6: constant x = 4; say x x x

[13:31] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/MaoEZDJM7g line 1, column 12␤»

[13:31] <p6eval> ..rakudo 06cf16, niecza v15-2-gd19c478: OUTPUT«4444␤»

[13:31] *** fglock joined
[13:32] <JimmyZ_> perl6: constant x = 4; say x*x

[13:32] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/hxFj01BllG line 1, column 12␤»

[13:32] <p6eval> ..rakudo 06cf16, niecza v15-2-gd19c478: OUTPUT«16␤»

[13:32] <JimmyZ_> perl6: constant x = 4; say xxx

[13:32] <p6eval> rakudo 06cf16: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&xxx' called (line 1)␤»

[13:32] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'xxx' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /home/…

[13:32] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/lSV50o2OA5 line 1, column 12␤»

[13:33] <dalek> roast: 9f76350 | moritz++ | S16-io/say-and-ref.t:

[13:33] <dalek> roast: RT #80186, IO.say

[13:33] <dalek> roast: review: https://github.com/perl6/roast/commit/9f763506c3

[13:34] <JimmyZ_> nom: constant * = 4; say*x*

[13:34] <p6eval> nom 06cf16: OUTPUT«===SORRY!===␤Method 'sorry' not found for invocant of class 'Perl6::Grammar'␤»

[13:35] <JimmyZ_> new bug!

[13:35] *** snearch joined
[13:35] <jnthn> That looks...familiar.

[13:36] <jnthn> moritz: ^^

[13:36] <jnthn> moritz: Is this an error reporting bug like the one fixed recently?

[13:36] *** wayland76 left
[13:37] <moritz> jnthn: might be. I'll investigate

[13:38] <moritz> though I really think it's just a mistyped s/panic/soory/

[13:40] <moritz> jnthn: yep. And you did it :-)

[13:40] <moritz> -        || <.panic: "Missing initializer on constant declaration">

[13:40] <moritz> +        || <.sorry: "Missing initializer on constant declaration">

[13:40] <moritz> you probably took that from STD or so

[13:40] <moritz> anyway, I'll fix

[13:42] <masak> good afternoon, #perl6

[13:43] <jnthn> moritz: d'oh

[13:43] <jnthn> sorry!

[13:43] <jnthn> o/ masak

[13:43] <moritz> :-)

[13:43] <moritz> std: constant * = 3

[13:43] <p6eval> std 137d5f5: OUTPUT«===SORRY!===␤Missing initializer on constant declaration at /tmp/TrCHxNq6Ic line 1:␤------> constant ⏏* = 3␤Preceding context expects a term, but found infix = instead at /tmp/TrCHxNq6Ic line 1:␤------> constant * ⏏…

[13:44] <moritz> it seems to parse it as   constant () * = 3

[13:44] *** sisar joined
[13:44] <moritz> why the heck to we parse anonymous constant declarations? What's the point?

[13:45] <moritz> after the constant, rakudo expects [ <identifier> | <variable> | <?> ]

[13:45] <jnthn> std: my $x = constant = 42

[13:45] <p6eval> std 137d5f5: OUTPUT«ok 00:01 110m␤»

[13:45] *** donri_ joined
[13:45] <jnthn> nom: my $x = constant = 42; say $x

[13:45] <p6eval> nom 06cf16: OUTPUT«42␤»

[13:45] <jnthn> I guess it's a way to force pre-computation of some value

[13:45] <moritz> but that doesn't make $x a constant, right?

[13:45] <jnthn> No but if it was an expression on the RHS of the = it'd force its evaluation at BEGIN time

[13:45] <moritz> wouldn't BEGIN do the same?

[13:46] <jnthn> But my $x = BEGIN 1 + 2; is perhaps clearer

[13:46] <jnthn> Yeah

[13:46] *** donri_ left
[13:46] <moritz> I'd rather have 'constant' without a variable or identifier give a better error message

[13:46] <moritz> but I guess it's TimToady++'s call here

[13:48] <jnthn> *nod*

[13:50] <moritz> I have to admit it's cute, but it's also obscure

[13:50] *** havenn joined
[13:51] <dalek> rakudo/nom: 4bacfdc | moritz++ | src/Perl6/Grammar.pm:

[13:51] <dalek> rakudo/nom: throw more X::Syntax::Missing errors.

[13:51] <dalek> rakudo/nom: 

[13:51] <dalek> rakudo/nom: Also fixes error reporting from constant declarators

[13:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4bacfdcfc6

[13:51] <jnthn> \o/

[13:51] *** buubot_backup left
[13:52] <sisar> those who are gonna give a talk on Monday, will it be recorded and put up online ?

[13:53] <moritz> if you mean at GPW, I don't think so

[13:53] <jnthn> Mine is on Tue :)

[13:53] <jnthn> I'll upload the slides

[13:53] <moritz> same for those :-)

[13:53] <sisar> i can live with slides...

[13:54] * moritz is working on his slides right now

[13:54] <moritz> but they are in German, mostly

[13:54] <sisar> jnthn: what's your talk about ?

[13:54] <sisar> moritz: dang 

[13:54] <dalek> roast: 157d7b7 | moritz++ | S32-exceptions/misc.t:

[13:54] <dalek> roast: more tests for "constant" parse errors

[13:54] <dalek> roast: review: https://github.com/perl6/roast/commit/157d7b7c6b

[13:56] <moritz> sisar: but you can read the example code anyway, the identifers are all English :-)

[13:56] <jnthn> sisar: Meta-programming

[13:56] <jnthn> Introspection, runtime type creation, custom meta-classes, etc.

[13:57] * moritz has about 25 slides, and a writer's block. Need 40. 

[13:57] <sisar> moritz: what are you talking about ?

[13:59] <moritz> sisar: Perl 6 features and which compilers implements them today

[14:00] <moritz> so the least advanced of all these talks

[14:00] *** noteventime left
[14:00] <moritz> nom: constant x = 'foo'; sub f(Int) { }; f x

[14:00] <p6eval> nom 06cf16: OUTPUT«Nominal type check failed for parameter ''; expected Int but got Str instead␤  in sub f at /tmp/PvjNAmMsAK:1␤  in block <anon> at /tmp/PvjNAmMsAK:1␤␤»

[14:01] <moritz> jnthn: it's a bit sad that this isn't caught at CHECK time

[14:01] <jnthn> Hm

[14:01] <jnthn> Wonder why it ain't...

[14:05] <moritz> sisar: fwiw http://conferences.yapceurope.org/gpw2012/schedule?day=2012-03-06 has the list of Perl 6 talks

[14:07] <jnthn> Wow, one room on Tuesday is pretty much Perl 6 room :d

[14:07] <sisar> moritz: now i can stop bothering you. thanks.

[14:07] <moritz> jnthn: yes :-)

[14:08] <moritz> jnthn: I would have prefered to do the talks before the hackathon, but that wasn't quite possible

[14:08] <moritz> (for two reasons: 1) so that people can first learn what it's all about, then join us hacking and 2) that masak++ doesn't waste the high-bandwith time with making slides :-)

[14:09] <moritz> ... or other people besides masak. Did I mention that I'm not done either? :-)

[14:09] <jnthn> Me either but I have at least started :)

[14:10] <jnthn> Got sketched out all the stuff I want to do, so now it's just writing slides and code.

[14:11] *** buubot_backup joined
[14:14] <masak> moritz: you know me too well.

[14:14] <masak> fwiw, I'm preparing the talk now.

[14:15] <moritz> well, don't we all pattern-match?

[14:15] <moritz> :-)

[14:16] *** buubot_backup left
[14:19] <dalek> rakudo/nom: 8b5ee17 | jnthn++ | src/Perl6/Actions.pm:

[14:19] <dalek> rakudo/nom: Annotate lookups of stuff with term:name that are known at compile time with the statically known type. Gets us some better static analysis, including with constants, as pointed out by moritz++.

[14:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b5ee17ce9

[14:20] <moritz> niecza: say pi.WHAT

[14:20] <jnthn> > constant x = 'foo'; sub f(Int) { }; f x

[14:20] <jnthn> CHECK FAILED:

[14:20] <p6eval> niecza v15-2-gd19c478: OUTPUT«Num()␤»

[14:20] <jnthn> Calling 'f' will never work with argument types (Str) (line 1) Expected: :(Int )

[14:21] <moritz> \o/

[14:23] *** icwiener joined
[14:27] * jnthn wonders if moritz is adding a slide on compile time analysis :)

[14:27] <moritz> jnthn: I have one that shows a dispatch failure detected at CHECK time

[14:28] <moritz> and also a bit role composition stuff shown at compile time

[14:29] <jnthn> Nice

[14:29] <moritz> https://github.com/moritz/perltalk/blob/master/p6-features-status.talk#L134

[14:31] <jnthn> Entwickler: for Rakudo - probably tadzik++ should be on it too :)

[14:32] <moritz> oh right :-)

[14:33] *** att left
[14:38] *** buubot_backup joined
[14:38] *** sisar left
[14:38] *** Chillance joined
[14:45] *** buubot_backup left
[14:49] <tadzik> hm?

[14:50] *** att joined
[14:50] <moritz> tadzik: jnthn++ just said I should mention you as a rakudo dev. He's right, of course :-)

[14:50] <tadzik> oh :)

[14:51] <masak> tadzik++

[14:53] <tadzik> oh, while we're at it, yes, I'm preparing my talk too ;)

[14:54] * moritz didn't want to start a witch hunt with his comment :-)

[14:55] <moritz> anybody got a cute example of list comprehension?

[14:56] <masak> ooh, Form.pm could be a nice GSoC project.

[14:56] *** noam_ joined
[14:57] * jnthn woulda expected one on Rosettacode, but the features page doesn't link to such an example

[14:58] <jnthn> And the spec example is boring and better done with sequences.

[14:58] *** noam left
[14:59] <masak> moritz: my @perfect_squares = ($_ if $_ == [+] divisors $_ for 1 .. 100);

[15:02] <masak> er, @perfect_numbers, sorry.

[15:03] <masak> @primes is perhaps a more well-known example. my @primes = ($_ if 1 == divisors $_ for 1 .. 100);

[15:05] <masak> basically, the use cases that make sense for list comprehensions rather than pure sequences are the ones where a predicate is involved.

[15:14] *** havenn left
[15:28] *** havenn joined
[15:32] *** DarthGandalf left
[15:35] *** DarthGandalf joined
[15:46] <mikemol> jnthn: Believe me, I wish there were a good task on RC for list comprehensions; it's embarassing to admit I don't know what people are talking about there; I never touched Lisp.

[15:48] *** Patterner left
[15:49] *** Psyche^ joined
[15:49] *** Psyche^ is now known as Patterner

[15:54] *** PacoAir joined
[15:58] <moritz> mikemol: "list comprehension" just means that a loop returns a list, and you use that return value

[16:01] *** MayDaniel left
[16:04] *** PacoAir left
[16:05] <masak> Wikipedia has some good examples and explanations: http://en.wikipedia.org/wiki/List_comprehension

[16:05] *** icwiener left
[16:05] <masak> list comprehensions have their roots in set builder notation.

[16:05] *** icwiener joined
[16:05] <TimToady> the usual syntax has a couple of problems from a p6 perspective

[16:05] <TimToady> it uses symbols before their declaration

[16:06] <TimToady> and it puts the conditional on the wrong side of the loop from a nesting perspective

[16:07] <TimToady> though one could fake that with a proper list infix that did a grep

[16:07] <TimToady> but the big one is declaring loop vars after use

[16:14] *** buubot_backup joined
[16:16] <dalek> nqp: 764faf9 | jnthn++ | src/HLL/World.pm:

[16:16] <dalek> nqp: Now, if we ask for a reference to an object in SC, we can just add it, since we can serialize whatever.

[16:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/764faf9a8d

[16:16] <dalek> rakudo/nom: efad32e | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[16:16] <dalek> rakudo/nom: Make it a bit easier to create Attribute meta-object instances.

[16:16] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/efad32ee43

[16:23] * TimToady never considered that constant could be anonymous; probably a copy-pasto from enum rule

[16:24] <masak> +1 on disallowing anon constant

[16:25] <TimToady> already working on it

[16:25] <masak> the idiom looks too much like = () = to me

[16:25] <masak> TimToady++

[16:26] <jnthn> Heh, I just assumed it was for consistency and implemented it :)

[16:26] <masak> jnthn++

[16:27] <masak> it would be very consistent, of course.

[16:27] <masak> but probably the kind that is a hobgoblin.

[16:28] <jnthn> Mmmmm....Hobgoblin! :D

[16:29] <masak> "The beer of the little mind" :P

[16:30] <dalek> std: 292f669 | larry++ | STD.pm6:

[16:30] <dalek> std: disallow anonymous constant declarations

[16:30] <dalek> std: review: https://github.com/perl6/std/commit/292f669905

[16:34] <masak> nom: $*IN; say "alive"

[16:34] <p6eval> nom efad32: OUTPUT«alive␤»

[16:35] <masak> nom: $*ARGS; say "alive"

[16:35] <p6eval> nom efad32: OUTPUT«alive␤»

[16:36] <TimToady> std: $*MASAK; say "ok 00:01 110m"

[16:36] <masak> is there a &slurp that should default to reading from the Perl 6 equivalent of <ARGV> ?

[16:36] <p6eval> std 137d5f5: OUTPUT«ok 00:01 109m␤»

[16:37] <flussence> are $?constants still a thing?

[16:37] <masak> I want it to read from $*IN, or from a file if one was provided.

[16:37] <masak> flussence: sure.

[16:38] * flussence was getting slightly confused by all this new sigil-less stuff

[16:38] <TimToady> perl6: say $*ARGFILES.slurp

[16:38] <p6eval> pugs b927740: OUTPUT«*** Unsafe function 'slurp' called under safe mode␤    at /tmp/3DgYqFqstR line 1, column 5 - line 2, column 1␤»

[16:38] <p6eval> ..rakudo efad32: OUTPUT«Method 'slurp' not found for invocant of class 'ArgFiles'␤  in block <anon> at /tmp/wmiNFxrY0O:1␤␤»

[16:38] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«Unhandled exception: Unable to resolve method slurp in class ArgFiles␤  at /tmp/9D_a0CwwSj line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3839 (module-CORE @ 65) ␤  at /h…

[16:39] <TimToady> perl6: say $*ARGFILES.lines

[16:39] <p6eval> rakudo efad32: OUTPUT«Land der Berge, Land am Strome, Land der Äcker, Land der Dome, Land der Hämmer, zukunftsreich! Heimat bist du großer Söhne, Volk, begnadet für das Schöne, vielgerühmtes Österreich, vielgerühmtes Österreich!  Heiß umfehdet, wild umstritten liegst dem Erdteil du inmi…

[16:39] <p6eval> ..niecza v15-2-gd19c478: OUTPUT«Land der Berge, Land am Strome, Land der Äcker, Land der Dome, Land der Hämmer, zukunftsreich! Heimat bist du großer Söhne, Volk, begnadet für das Schöne, vielgerühmtes Österreich, vielgerühmtes Österreich!  Heiß umfehdet, wild umstritten liegst dem Erdteil…

[16:39] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Scalar: "&lines"␤    at /tmp/fOvP8tG7S4 line 1, column 5 - line 2, column 1␤»

[16:39] <TimToady> looks like ArgFiles needs to be taugh about delegating to IO or some such

[16:39] <TimToady> *taught

[16:40] <TimToady> btw, the equivalent in P5 only slurps one file at a time, iirc

[16:40] <masak> moritz: new backtraces are excellent.

[16:40] <masak> moritz++

[16:40] *** jferrero left
[16:40] <masak> moritz: do you think we should also hide MAIN_HELPER? I do.

[16:41] <jnthn> Sounds reasonable

[16:42] <jnthn> masak: Should just be annotating it with "is hidden-from-backtrace" or some such

[16:43] *** tokuhirom joined
[16:45] *** aindilis left
[16:45] *** aindilis joined
[16:46] *** sisar joined
[16:50] *** am0c left
[16:50] *** xenu joined
[16:51] *** marmalade joined
[16:54] *** kaare_ joined
[16:54] <tadzik> masak: do you recall if anyone ever tried to implement what's in S22?

[16:55] *** tokuhirom left
[16:55] <masak> tadzik: I think not.

[16:55] <masak> I remember when that one was written, but it probably remained a gleam in the authors' eyes.

[16:55] *** jferrero joined
[16:55] <masak> I'd say it has "borrow what could work, ignore the rest" status.

[16:56] <tadzik> I have a feeling that no one ever paid attention to it when implementing ecosystem as we have now

[16:56] <tadzik> as in: evolution, not intelligent design

[17:00] <masak> nothing wrong with design of the kind you refer to.

[17:00] <tadzik> of course

[17:00] <masak> but it has to have its roots in need, not want.

[17:00] <masak> if the distinction makes sense :)

[17:01] <masak> there's something of a scratch-your-own-itch and eat-your-own-dogfood there that can't be ignored.

[17:02] <cognominal> reading the commit log,  /me sees "attribute meta object instance". /me is not sure to understand what it is

[17:03] <cognominal> I suppose that attributes are seen as object and they have their palace in the metaoo system

[17:04] <cognominal> indeed I see an Attribute.HOW

[17:04] <masak> cognominal: attributes have properties that you might want to modify in your OO system. therefore, they have their own HOW.

[17:04] <masak> cognominal: in Moose, they're even more important since Moose rests so heavily on attributes and so lightly on methods.

[17:06] <jnthn> cognominal: It's just an attribute that represents at attribute

[17:06] <cognominal> I can guess that is stuff like ownProperty in js, which defines if an attribute belongs to the current object or is inherited.

[17:06] <jnthn> cognominal: Most declarative things in Perl 6 lead to compile-time creation of some kind of object that describes what it is and how it works.

[17:07] <masak> TimToady: what's your take on the capture-inside-of-regex-interpolation thing I found the other day? <{ '(.) $0' }>

[17:07] <cognominal> I got the general idea, I don't have grasped all the details.

[17:07] *** aindilis left
[17:07] <TimToady> masak: that runs as a subrule, so $0 is local to the <{ }>

[17:07] <jnthn> cognominal: Well, maybe I should give my meta-programming talk I'm working on at the moment in France some time this year then :)

[17:07] *** aindilis joined
[17:07] *** icwiener left
[17:08] <cognominal> you bet.

[17:09] <cognominal> Anyway if you don't come. I will study it thoroughly to present it but that would be so much better if you do that in person.

[17:09] <TimToady> perl6: say 'fooo' ~~ /<{ '(.) $0' }> $0/

[17:09] <p6eval> niecza v15-2-gd19c478: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/DYY8o1sGD9 line 1 (ANON @ 9) ␤ …

[17:09] <p6eval> ..rakudo efad32: OUTPUT«#<failed match>␤»

[17:09] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[17:10] <jnthn> cognominal: Are the dates announced yet?

[17:10] <masak> TimToady: oh, ok.

[17:10] <masak> nom: grammar G { regex TOP { <.panic "OH NOES"> }; method panic($m) {} }; G.parse("")

[17:10] <p6eval> nom efad32: OUTPUT«Unmarshallable foreign language value passed for parameter '$m'␤  in method panic at /tmp/aiw2289Jtt:1␤  in regex TOP at /tmp/aiw2289Jtt:1␤  in method parse at src/gen/CORE.setting:8175␤  in block <anon> at /tmp/aiw2289Jtt:1␤␤»

[17:10] <masak> jnthn: ^^^

[17:10] <TimToady> perl6: say 'fooo' ~~ /$<x> = <{ '(.) $0' }> $<x>[0]/; # maybe this works

[17:10] <p6eval> niecza v15-2-gd19c478: OUTPUT«Potential difficulties:␤  Apparent subscript will be treated as regex at /tmp/avehYCl3bE line 1:␤------> ay 'fooo' ~~ /$<x> = <{ '(.) $0' }> $<x>⏏[0]/; # maybe this works␤␤Match()␤»

[17:10] <p6eval> ..rakudo efad32: OUTPUT«#<failed match>␤»

[17:10] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[17:11] <cognominal> http://journeesperl.fr/fpw2012/

[17:11] <cognominal> jnthn:   http://journeesperl.fr/fpw2012/newtalk

[17:11] <cognominal> :)

[17:11] <TimToady> perl6: say 'fooo' ~~ /$<x> = <{ '(.) $0' }> $(<x>[0])/; # maybe this works

[17:11] <p6eval> niecza v15-2-gd19c478: OUTPUT«Match()␤»

[17:11] <p6eval> ..rakudo efad32: OUTPUT«Method 'x' not found for invocant of class 'Cursor'␤  in <anon> at /tmp/RLSn5XbrOk:1␤  in regex <anon> at /tmp/RLSn5XbrOk:1␤  in method ACCEPTS at src/gen/CORE.setting:8188␤  in block <anon> at /tmp/RLSn5XbrOk:1␤␤»

[17:11] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[17:12] *** jferrero left
[17:12] <masak> jnthn: yes, please do. I haven't even seen your talk, and I'm already looking forward to seeing it a second time :P

[17:12] <jnthn> I love how cognominal links me to the submit talk page rather than the homepage of the FPW site :P

[17:12] <tadzik> :)

[17:12] <TimToady> perl6: say 'foooo' ~~ /$<x> = <{ '(.) $0' }> $<x>/;

[17:13] <p6eval> niecza v15-2-gd19c478: OUTPUT«#<match from(1) to(5) text(oooo) pos([].list) named({"x" => #<match from(1) to(3) text(oo) pos([#<match from(1) to(2) text(o) pos([].list) named({}.hash)>].list) named({}.hash)>}.hash)>␤»

[17:13] <p6eval> ..rakudo efad32: OUTPUT«=> <oooo>␤ x => <oo>␤  0 => <o>␤␤»

[17:13] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[17:13] <masak> jnthn: why is the thing Unmarshallable above?

[17:13] <masak> jnthn: (it's some ways up, between TimToady's p6eval spammings) :)

[17:14] *** jferrero joined
[17:14] <jnthn> masak: yeah, I missed it :P

[17:14] *** birdwindupbird left
[17:14] <jnthn> masak: I'm...not sure. Is that not missing a colon?

[17:14] * moritz missed it too

[17:15] <jnthn> nom: grammar G { regex TOP { <.panic: "OH NOES"> }; method panic($m) {} }; G.parse("")

[17:15] <p6eval> nom efad32: OUTPUT«Cannot look up attributes in a type object␤  in regex TOP at /tmp/y3W_qodcCF:1␤  in method parse at src/gen/CORE.setting:8175␤  in block <anon> at /tmp/y3W_qodcCF:1␤␤»

[17:15] <jnthn> nom: grammar G { regex TOP { <.panic: "OH NOES"> }; method panic($m) { die "painfully" } }; G.parse("")

[17:15] <p6eval> nom efad32: OUTPUT«painfully␤  in method panic at /tmp/WB4nBiLzf1:1␤  in regex TOP at /tmp/WB4nBiLzf1:1␤  in method parse at src/gen/CORE.setting:8175␤  in block <anon> at /tmp/WB4nBiLzf1:1␤␤»

[17:16] <masak> jnthn++

[17:16] <jnthn> masak: It's because you used the syntax that makes <begin blah blah> work

[17:16] <masak> oh.

[17:16] <jnthn> masak: That compiles blah blah as a regex

[17:16] <jnthn> masak: And then you were passing a Parrot Sub off to panic.

[17:16] <masak> oops.

[17:17] <masak> Unmarshellable.

[17:17] <jnthn> :P

[17:17] <moritz> Un-marshmellow-ish

[17:17] <jnthn> Derivational morphology. I uses it.

[17:18] <cognominal> jnthn, When I talk to people, I have a lot of trouble to explain the ultimated goal of the rakudo project which is to eventually compile any dynamic languages and make them interact. People have no idea of what is involved. They are already unaware of the system  that makes possible to (dynamically) link .o files. They don't realize that the same thing for dynamic languages are more complicated by two orders of magnitude or so

[17:18] <cognominal> . And when they suddenly realize the scope, they think that we (well I certainly mean the non lurker unlike me) will not be able to pull it. 

[17:18] <moritz> huh

[17:18] <cognominal> *ultimate

[17:18] <jnthn> Huh.

[17:18] <moritz> rakudo's goal is to compiler Perl 6

[17:18] <jnthn> The goal of Rakudo is to be an awesome Perl 6 compiler.

[17:18] <jnthn> You're thinking of Parrot.

[17:18] <moritz> and maybe some parts of p5, to the way that the specs require it

[17:18] <TimToady> jnthn: You just need more hemidemisemiaffixishnesslessnessless.

[17:19] <TimToady> er, *ness

[17:19] <cognominal> if it was only so you would not bother with all this meta stuff.

[17:19] <masak> not so.

[17:19] <masak> all this meta stuff is cool even without the language interop.

[17:19] <moritz> and not only cool, but necessary

[17:19] <jnthn> Right.

[17:19] <cognominal> and once this stuff is done, the goal, assumed or not, will eventually follow thru.

[17:20] <jnthn> It's the way we implement large chunks of Perl 6 in a decent way, a way to make the language extensible, etc.

[17:20] <jnthn> Yes, it's true, representation poly and so forth make interop easier to implement.

[17:20] <TimToady> but putting that goal first leads to...parroty things...

[17:20] <jnthn> But it's not the only goal.

[17:21] <jnthn> And was far from the primary one.

[17:21] <jnthn> For 6model at least.

[17:21] <dalek> rakudo/nom: b8a20ce | moritz++ | src/core/Main.pm:

[17:21] <dalek> rakudo/nom: hide MAIN_HELPER from bactraces. masak++

[17:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b8a20cedd9

[17:21] <dalek> rakudo/nom: 141cd63 | moritz++ | src/core/Num.pm:

[17:21] <dalek> rakudo/nom: steal more precises definitions of pi and e from niecza++

[17:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/141cd63d8f

[17:22] <moritz> efad32ee431c12145ba2aa99c4de2a4673135a73 looks like talk-driven design. jnthn++ :-)

[17:22] <jnthn> ooh, strasbourg. I've never been there :)

[17:22] <TimToady> parrot's model of interop development was a bit on the order of Ready! Fire! Aim!

[17:23] <TimToady> you can't really do interop without a good metamodel

[17:23] <masak> nom: grammar G { regex TOP { (foo) <.panic: "!$0!"> }; method panic($m) { die $m } }; G.parse("foo")

[17:23] <p6eval> nom efad32: OUTPUT«!!␤  in method panic at /tmp/SAKd6FG6zc:1␤  in regex TOP at /tmp/SAKd6FG6zc:1␤  in method parse at src/gen/CORE.setting:8175␤  in block <anon> at /tmp/SAKd6FG6zc:1␤␤»

[17:24] <masak> why doesn't this output '!foo!'?

[17:24] <jnthn> hm

[17:24] <moritz> because of impedance mismatch

[17:24] <jnthn> .oO( mis-Match )

[17:24] <masak> moritz: those are words. what do you mean by them?

[17:25] <masak> also, is there a workaround? :)

[17:25] <moritz> yes, a block

[17:25] <jnthn> nom: grammar G { regex TOP { (foo) { $/.CURSOR.panic: "!$0!" } }; method panic($m) { die $m } }; G.parse("foo")

[17:25] <p6eval> nom efad32: OUTPUT«Method 'match' not found for invocant of class 'Any'␤»

[17:25] <cognominal> to paraphrase a known ahphorism,  I see the future this way "Every compiling system attempts to expand until it support genericity, hygienic macros and a metaobject system. Those which cannot so expand are replaced by ones which can."

[17:25] <masak> oh, so it's kinda similar to the problem in .subst ?

[17:25] <moritz> the problem is basically that the regex engine doesn't publish match variables unless it is deemed necessary

[17:26] <moritz> and when parsing argument strings, that doesn't happen (but it should)

[17:26] <jnthn> moritz: Yeah, it's that.

[17:26] <jnthn> moritz: Just hit on the same conclusion.

[17:26] <masak> sounds RT-able to me.

[17:26] <cognominal> I forget to mention a type inferencing system, but perl 6 and rakudo are not there yet.

[17:27] * masak submits rakudobug

[17:27] <jnthn> cognominal: Rakudo does various bits of type-driven analysis and (very) limited inference.

[17:27] <jnthn> nom: constant x = 'lol'; multi foo(Int) { }; foo(x)

[17:27] <p6eval> nom efad32: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'foo' will never work with argument types (Str) (line 1)␤    Expected any of:␤    :(Int )␤»

[17:27] *** isBEKaml joined
[17:27] <cognominal> I agree but I am talking of a more systematic stuff like does haskell.

[17:27] <moritz> that's just propagation, not really inference, is it?

[17:28] <jnthn> moritz: Well, we didn't decalre that x was of type Str anywhere

[17:28] <jnthn> moritz: So in a sense it "figured it out"

[17:28] <moritz> point taken

[17:28] <jnthn> moritz: Though in this case the figuring was very easy (just do .WHAT)

[17:28] <moritz> WAT?

[17:28] <jnthn> :P

[17:29] <TimToady> nom: constant x = 101; multi foo(Int) { }; foo(~x)

[17:29] <p6eval> nom efad32: OUTPUT«No applicable candidates found to dispatch to for 'foo'. Available candidates are:␤:(Int )␤␤  in block <anon> at /tmp/pY4ppADszW:1␤␤»

[17:29] <TimToady> dint figger that one out

[17:29] <moritz> right, because it didn't constant-fold prefix:<~>

[17:29] <jnthn> Well, it may have been able to figger it without constant folding too

[17:30] <TimToady> it shouldn't have to constant fold to know that ~ is returning a string

[17:30] <cognominal> anyway, my point is that it would be good the share the feeling of necessity of stuff is done in rakudo. People who wrongly see perl6 as perl5 improved clearly don't get it.

[17:30] <jnthn> TimToady: Yeah, if we declare it on the proto it can do that.

[17:30] <cognominal> s :1st /the/to/

[17:30] <moritz> TimToady: well, that'd need a return type annotation on the proto or so

[17:30] <moritz> which we don't have yet, I guess

[17:31] <jnthn> Yeah, at the moment that won't be considered or enforced.

[17:31] <jnthn> All doable. :)

[17:31] <moritz> just needs sufficiently advanced tuits :-)

[17:32] <TimToady> cognominal: however, there's a tendency in type-inferencey languages to assume the user is as smart as the inferencer, which can lead to vast confusion among mere mortals

[17:32] <TimToady> so we need to tread carefully there

[17:32] <jnthn> The hard part isn't always figuring out that a piece of code could never work, but explaining why.

[17:32] *** buubot_backup left
[17:32] <TimToady> you need to be able to present the chain of reasoning in a clear fashion

[17:33] <cognominal> yes indeed, the way these systems "think" is so different we do.

[17:33] <jnthn> moritz: Well, Germany has lots of beer ;)

[17:33] <TimToady> just saying "That won't work for some reason" is about like saying "Syntax error" without a line number

[17:33] <cognominal> :)

[17:34] <cognominal> so true.

[17:34] <cognominal> well, they give a reason but it is not human readable.

[17:35] <TimToady> "No applicable candidates found" is already a bit gobbledygooky in my opinion

[17:36] <cognominal> We tend to work with context, and inferecing types tends to use too much context for us to process.

[17:36] *** isBEKaml left
[17:38] *** isBEKaml joined
[17:39] <TimToady> Cannot figure out which foo to call; available signatures are:

[17:39] <TimToady> something more like that

[17:40] *** Trashlord left
[17:41] *** Trashlord joined
[17:41] *** havenn left
[17:41] <TimToady> and it should say the type signature of what you did pass, and maybe the values if there are constraints

[17:41] *** jferrero left
[17:41] *** isBEKaml left
[17:42] *** buubot_backup joined
[17:45] *** jferrero joined
[17:46] *** buubot_backup left
[17:46] <TimToady> niecza: constant x = 101; multi foo(Int) { }; foo(~x)

[17:46] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unhandled exception: No candidates for dispatch to &foo; candidates are:␤    Int␤  at /tmp/qxnuzgp8NE line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3839 (module-CORE @ 6…

[17:47] <TimToady> niecza's message is even less sensical; there are no candidates, and here they are

[17:48] <TimToady> Error messages should avoid overly precise words like "dispatch", "candidates", "applicable"

[17:48] <TimToady> the user is just trying to call foo

[17:50] <TimToady> Cannot call foo; none of these signatures match:

[17:50] <jnthn> TimToady: The message you suggested would seem to cover ambiguous or no possible candidates.

[17:50] <jnthn> OK, that's better

[17:50] <jnthn> What about the ambiguous case?

[17:50] <TimToady> then it should say ambiguous

[17:51] <TimToady> Cannot call foo; too many signatures match:

[17:51] <TimToady> :)

[17:52] <jnthn> "Ambiguous call to '%Ss'; these signatures all matched:\n%Ss" ?

[17:52] *** jferrero left
[17:52] <TimToady> that's not half bad

[17:54] <TimToady> would still like to see the actual arg types(+gisted values?) at some point

[17:55] <jnthn> Yeah, I already got them into the compile-time errors. Will try and get 'em into the runtime ones soon also.

[17:55] *** jferrero joined
[17:55] * TimToady is hard to please, except when he's not...

[17:56] <dalek> rakudo/nom: a89da25 | jnthn++ | src/binder/multidispatch.c:

[17:56] <dalek> rakudo/nom: Improve multi-dispatch error text; TimToady++.

[17:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a89da25b73

[17:58] <jnthn> It needs to become a typed exception anyways at some point soon.

[17:58] <TimToady> also, from a writerly perspective, the original message had a passive verb; those can usually be strengthened into some active verb

[17:59] <jnthn> Happily, the message improved.

[17:59] <TimToady> \o/

[17:59] <TimToady> thanks

[18:00] <jnthn> When we do the typed exception, I can just pass the capture of args that failed and the signatures available/ambiguous in the object

[18:01] <cognominal> jnthn++ #  integrating bs makes nom so much faster.

[18:01] <jnthn> Then it'll be dead easy to render the error however we want it.

[18:01] <moritz> and let me figure out the hard stuff :-)

[18:01] <jnthn> \o/

[18:01] <jnthn> moritz: I think joining strings together and calling .gist on stuff is easier in Perl 6 than it is in C ;)

[18:02] <jnthn> moritz: We'll be sure to figure out how to do typed exceptions from C land while at GPW.

[18:03] *** jferrero left
[18:06] <moritz> and from meta model land

[18:07] <moritz> I have some vague, sketchy ideas that might work out

[18:08] <moritz> but jnthn++ as probably much less vague and more realistic ideas :-)

[18:08] *** buubot_backup joined
[18:10] *** noam_ left
[18:11] *** noam_ joined
[18:12] <cognominal> I agree that what piss me the most currently is C error messages that don't give the parrot/perl 6 line that triggered them.

[18:14] *** noam_ left
[18:14] *** noam_ joined
[18:14] <jnthn> moritz: Do you mention grammars at all in your talk?

[18:15] *** Trashlord left
[18:16] <cognominal> I wish you fun at gpw.

[18:19] *** lutok joined
[18:25] *** noam joined
[18:27] *** noam_ left
[18:28] *** jferrero joined
[18:29] *** noam left
[18:31] <TimToady> jnthn: a nit, but I'd s/matched/match/ in your ambiguous message; introducing unnecessary temporal information tends to cloud abstract statements

[18:31] <TimToady> this is why literary critics always write about authors in the present tense

[18:32] <TimToady> "In this passage Morris artfully weaves archaicisms with more modern notions"

[18:33] *** JimmyZ_ left
[18:35] <dalek> rakudo/nom: 4bdb94a | jnthn++ | src/binder/multidispatch.c:

[18:35] <dalek> rakudo/nom: Present for TimToady++.

[18:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4bdb94a5b6

[18:36] *** jferrero left
[18:40] <masak> jnthn++ # commit message

[18:41] <TimToady> nit one, perl two...

[18:44] <moritz> jnthn: I plan to

[18:45] *** ascrazy joined
[18:46] *** shinobicl_ joined
[18:47] *** MayDaniel joined
[18:47] *** MayDaniel left
[18:47] *** MayDaniel joined
[18:51] *** jferrero joined
[18:51] *** noteventime joined
[18:52] *** localhost left
[18:54] *** localhost joined
[18:57] <jnthn> dinner &

[18:57] *** shinobicl_ left
[18:59] <TimToady> I also think we should simplify these: s/Nominal type check/Type check/ and s/Constraint type check/Constraint/

[18:59] <TimToady> so it's just:

[18:59] <TimToady> Constraint failed...

[18:59] <TimToady> Type check failed...

[18:59] <moritz> -1

[19:00] <moritz> "Constraint failed" could be a PRE too

[19:00] <moritz> or some other invariant

[19:00] <TimToady> then it should say PRE

[19:00] <TimToady> the rest of the message indicates it's in a parameter binding

[19:00] <cognominal> jnthn, if you go back to Paris, you come to get to use the word used by Jean Dujardin at the academy award : putain!  Explained here: http://www.youtube.com/watch?v=GSeaDQ6sPs0

[19:01] <TimToady> we talk about nominal type checks, but I think the word does not carry sufficient weight to inflict it on the user

[19:02] <TimToady> and PRE should probably be talking about invariants, not constraints, as you yourself just pointed out

[19:03] <TimToady> constraints in Perl 6 are pretty consistently subset types (either named or anonymous), so "type" is redundant

[19:03] <TimToady> so I stand by my proposal

[19:04] *** icwiener joined
[19:04] *** kmwallio joined
[19:10] *** jferrero left
[19:11] *** birdwindupbird joined
[19:12] *** att left
[19:13] *** ascrazy left
[19:15] *** jferrero joined
[19:18] *** ascrazy joined
[19:18] *** havenn joined
[19:19] *** noam joined
[19:22] *** havenn left
[19:24] *** att joined
[19:25] <noteventime> I'm slightly confused, does Parrot use LLVM nowadays?

[19:25] <moritz> no

[19:25] <moritz> there are plans to use LLVM for the parrot's JIT compiler that is in planning

[19:25] <noteventime> Ok, it's just some experimental extra you can enable

[19:25] <moritz> but you can compile parrot with LLVM-GCC and with clan

[19:26] <moritz> *clang

[19:26] <noteventime> Or did I misread something as a release log, that wasn't?

[19:26] <moritz> maybe

[19:27] <noteventime> "New --with-llvm option to Configure.pl, which will link to LLVM if it is available" <- Maybe that just means I can compile it with clang? 

[19:28] <noteventime> Or wait, does it mean it uses the LLVM linker?

[19:28] <moritz> I'm reading http://parrot.org/news/2012/Parrot-4.1.0 and see no mention of LLVM at all

[19:28] <noteventime> http://www.parrot.org/news/2011/Parrot-3.3.0 <- Thats the one I saw

[19:28] <moritz> oh. That's a bit older :-)

[19:28] <noteventime> It wasn't really imporant though, I was just curious 

[19:30] <noteventime> moritz: I read something about Parrot and LLVM and that's the release blurb I got when I googled it

[19:30] * moritz reads config/auto/llvm.pm and can't make much sense of it either

[19:39] <moritz> jnthn: ok, I now have some few slides on grammars

[19:40] *** pjcj joined
[19:40] *** havenn joined
[19:40] *** syslq__ joined
[19:40] *** syslq__ left
[19:44] <noteventime> Why use grammars rather than some kind of parser combinator library? Is it "just" a matter of performance or is there something deeper?

[19:45] <moritz> why use some kind of parser combinator library instead of grammars?

[19:45] <moritz> the advantage of grammars is that they harmonize quite well with the OO system

[19:45] <moritz> they just use it

[19:45] <moritz> so you can take advantage of all the neat stuff (role composition for example)

[19:46] <moritz> in grammars too

[19:47] <noteventime> Couldn't that be achieved by having classes containing parser combinators though? I'm not saying it'd a better approach, coming from Haskell I was just curious if there are any strong reasons against doing parser combinators.

[19:48] <noteventime> (I mean, having methods returning parser generators, making it possible for roles to fill them in)

[19:48] <moritz> could probably be

[19:48] <moritz> but currently it sounds more complicated, without any obvious benefits

[19:51] *** leprevost left
[19:51] <noteventime> Well, you wouldn't have to have them be a language feature, which might be considered a benefit.

[19:52] <TimToady> as soon as you use the word "combinator" you've scared away 2/3 of your potential users  :)

[19:52] <mathw> I'm not sure you could get the syntax as good if they were combinators

[19:52] <noteventime> That's a good point

[19:52] <mathw> Parsec's good, but it's still not as elegant as Perl 6 grammars IMO

[19:52] <moritz> well, Perl 6 is malleable enough that you can surely implement that as a library

[19:52] <noteventime> TimToady: The people using "combinator" might consider that an additional benefit ;)

[19:53] <mathw> moritz: yes but the grammars being built into the language is one of the ways in which that mallability is accomplished

[19:53] <TimToady> Perl 6 is not aiming primarily to please the intelligensia

[19:53] <noteventime> I'm not saying grammars aren't a nice idea, I like them, especially in this age of DSLs :)

[19:54] <geekosaur> noteventime, you'r actually missing a point.  it's not about "build parser into the language", it's about "make regular expressions composable"

[19:54] <moritz> and reusable

[19:54] <geekosaur> think of it as part of regex syntax, intended to make them easier to think about and reuse

[19:54] <moritz> but we don want a parser built into the language, and we have that :-)

[19:55] *** mj41 left
[19:55] <moritz> s/don/do/

[19:55] *** skipper joined
[19:55] *** kmwallio left
[19:55] <noteventime> geekosaur: And having composable regular expressions seems to do largely the same thing as having a parser combinator library

[19:55] <mathw> it helps that it's the same parser that's used by the compiler

[19:55] <TimToady> noteventime: yes, that "benefit" of the typical FP language is something we're trying very hard to avoid

[19:56] <noteventime> TimToady: Typical FP language meaning Haskell and OCaml?

[19:56] <geekosaur> noteventime, but regexes are perl.  so we should prefer something that isn't?

[19:56] <TimToady> it's the job of Perl to educate people wherever they are, not to chase them away if they don't meet some high standard

[19:57] <noteventime> geekosaur: As I said, I'm not saying it would have been a better choice, I just wondered if there were any obvious reasons for using it that I had missed

[19:57] <noteventime> TimToady: I wasn't being very serious :)

[19:57] <geekosaur> (so why continue once that was answered?)

[19:57] <masak> how can I fail a rule in present-day Rakudo?

[19:57] *** havenn left
[19:57] <TimToady> <!>

[19:58] <TimToady> well, that's supposed to work

[19:58] <masak> TimToady: doesn't that just fail the current alternation?

[19:58] <masak> I want to fail the rule.

[19:58] <TimToady> uh, ::: <!> then

[19:58] <jnthn> Another one is that we parse Perl 6 with Perl 6 grammars, so your language tweaks can be meta-circular.

[19:58] <noteventime> geekosaur: Because I didn't quite understand the reasons that were given

[19:58] <masak> TimToady: ::: not yet implemented

[19:58] <masak> TimToady: "...in present-day Rakudo"

[19:58] <TimToady> noteventime: well, we're not trying to chase you away either :)

[20:00] *** mj41 joined
[20:00] <moritz> masak: there's probably some nasty hack with  { return self.'!cursor_fail'() } or something

[20:00] <masak> yeech.

[20:00] <moritz> step back. What are you trying to do?

[20:00] <TimToady> put a ||<!> on the outer construct, maybe

[20:00] <jnthn> Wait, ::: doesn't immediately failing the rule though, iirc?

[20:00] <noteventime> geekosaur: Sorry if I sounded negative, I really do like the language

[20:00] <jnthn> ::: fails it if it gets backtracked over

[20:01] <TimToady> that's why I put a <!> after it

[20:01] <jnthn> TimToady: oh!

[20:01] <jnthn> I misread.

[20:01] <masak> TimToady: that might work, thanks.

[20:01] <jnthn> Sorry.

[20:01] <jnthn> masak: Did b do :::?

[20:01] <moritz> alpha: /a ::: a/

[20:01] <p6eval> alpha :  ( no output )

[20:01] <masak> jnthn: alpha definitely did.

[20:02] <moritz> b: /a ::: a/

[20:02] <p6eval> b 1b7dd1: OUTPUT«===SORRY!===␤::: not yet implemented at line 22, near " a/"␤»

[20:02] <masak> because PGE did.

[20:02] <jnthn> No, then.

[20:02] *** ruoso left
[20:02] <moritz> but notice that the semantics have changed since the alpha days

[20:02] <jnthn> Yeah...PGE ain't easy to look at for inspiration though. Whereas nqp-rx is.

[20:02] <TimToady> niecza: 'ab' ~~ /a ::: b/

[20:02] <jnthn> But I can probably figure out how to do ::: without too much trouble anyway.

[20:02] <p6eval> niecza v15-2-gd19c478:  ( no output )

[20:02] <TimToady> niecza: say 'ab' ~~ /a ::: b/

[20:02] <p6eval> niecza v15-2-gd19c478: OUTPUT«#<match from(0) to(2) text(ab) pos([].list) named({}.hash)>␤»

[20:03] <masak> moritz: I'm parsing things with the structure ABBBBBABBBB, and I started to emit error messages when I come upon an unknown kind of B. but I don't want it to flag up an A.

[20:03] <TimToady> niecza: say 'acb' ~~ /a [ c ::: <!> ] b/

[20:03] <p6eval> niecza v15-2-gd19c478: OUTPUT«Match()␤»

[20:03] <masak> moritz: so in a sense, I'm stuck in an inner loop, wrongly flagging up things that are OK in the outer loop.

[20:03] <TimToady> niecza: say 'ab' ~~ /a [ c ::: <!> ] b/

[20:03] <p6eval> niecza v15-2-gd19c478: OUTPUT«Match()␤»

[20:03] <TimToady> niecza: say 'ab' ~~ /a [ c ::: <!> ]? b/

[20:03] <p6eval> niecza v15-2-gd19c478: OUTPUT«#<match from(0) to(2) text(ab) pos([].list) named({}.hash)>␤»

[20:04] <TimToady> niecza: say 'acb' ~~ /a [ c ::: <!> ]? b/

[20:04] <p6eval> niecza v15-2-gd19c478: OUTPUT«Match()␤»

[20:04] <TimToady> looks like niecza does it right

[20:04] *** ruoso joined
[20:04] <masak> niecza++

[20:04] <jnthn> masak: Can probably implement it for you later today.

[20:04] <jnthn> :: is the harder one.

[20:05] <TimToady> yes, well, that's an instruction to the LTMer

[20:05] *** ribayr left
[20:05] <masak> jnthn: \o/

[20:05] *** PacoAir joined
[20:05] <TimToady> so backtrack over :: can actually go out many levels, unlike ::

[20:05] <TimToady> er, :::

[20:06] <TimToady> :: goes out to whatever level the LTM is alternating at

[20:06] <TimToady> we could do all of this with arguments to <commit>

[20:07] <TimToady> <commit 'LTM'>, <commit &ROUTINE>, etc

[20:08] <masak> heh. moritz++' suggestion { return self.'!cursor_fail'() } seems to abort the whole *program*, not just the grammar parse.

[20:08] <TimToady> then you could commit to any rule in your outer dynamic scope

[20:08] *** skipper left
[20:09] <TimToady> and <commit> as currently defined defaults to <commit 'TOP'> or some such, more or less, give or take a few aspirin

[20:10] <masak> g'ah, this is really frustrating! everytime I think I've worked around the thing, it turns out I've only aborted the current... group or alternation, not the whole rule.

[20:11] <masak> maybe I'm really wanting something like ~

[20:12] <masak> nope, that didn't work either.

[20:13] * TimToady wonders if there's a way to install a CATCH block in a rule

[20:13] <moritz> TimToady: recently I was wondering how one would export a CATCH block

[20:13] <moritz> TimToady: for a custom exception / backtrace printer

[20:13] <masak> nom: grammar G { regex TOP { <outer>* }; regex outer { A <inner>* }; regex inner { B | (.) { say "Unknown B: $0" } } }; say G.parse("ABBBBABBB")

[20:14] <p6eval> nom 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBBABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <A>␤   0 => <A>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[20:14] <TimToady> we might have to relax the highlander rule for that

[20:14] <TimToady> or wrap CATCHes somehow

[20:14] <masak> how do I get Rakudo to stop considering "A" an unknown "B" above?

[20:14] <masak> TimToady: what's the highlander rule?

[20:15] <TimToady> There kin only be one!

[20:15] *** havenn joined
[20:15] <masak> ah, 'course.

[20:15] * masak clarly has watched too little of that genre

[20:15] *** PacoAir left
[20:16] *** wolfman2000 left
[20:16] * TimToady only knows about it from RFC 9

[20:17] <TimToady> "Highlander Variable Types"

[20:17] <moritz> fwiw the feature matrix still says - for run, qx in niecza

[20:18] <masak> TimToady: that's what I was thinking of too.

[20:18] <masak> ah well, I turned off my nice "Unknown B" warnings. seems I can't have them just now.

[20:21] <TimToady> I really don't understand how you think a cut could help that

[20:22] * TimToady should eat breakfast now that it's after noon, maybe

[20:23] <masak> a cut? I wanted to abort the rule at that point. if <inner> reports failure, the * quantifier is satisfied and <outer> succeeds.

[20:23] <masak> the equivalent of the rule saying "this is not for me to handle".

[20:25] *** icwiener left
[20:26] *** havenn left
[20:27] * tadzik leaves for GPW

[20:29] *** ascrazy left
[20:29] <masak> tadzik: see you on the other side!

[20:30] *** havenn joined
[20:35] * moritz wishes tadzik a good travel

[20:36] <jnthn> tadzik: Safe travels :)

[20:45] <TimToady> nom: grammar G { regex TOP { <outer>* }; regex outer { A <inner>* }; regex inner { B | (.) { say "Unknown B: $0" <!> } } }; say G.parse("ABBBBABBB")

[20:46] <p6eval> nom 4bdb94: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix !> instead at line 1, near " } } }; sa"␤»

[20:46] <TimToady> nom: grammar G { regex TOP { <outer>* }; regex outer { A <inner>* }; regex inner { B | (.) { say "Unknown B: $0" } <!> } }; say G.parse("ABBBBABBB")

[20:46] <p6eval> nom 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[20:46] <TimToady> why not just that?

[20:47] *** ascrazy joined
[20:51] <masak> TimToady: because it still prints "Unknown B: A"

[20:51] *** birdwindupbird left
[20:51] <masak> TimToady: the trick wasn't about aborting the rule after printing that, the trick was about aborting the rule before that.

[20:52] <masak> if it encounters a C, it's fine for it to squawk. but not if it encounters an A.

[20:53] <moritz> then just write   B | <!before A> (.) { ... } <!>

[20:53] <moritz> or quantify <inner> with *? maybe?

[20:55] *** Trashlord joined
[20:56] *** isBEKaml joined
[20:57] <masak> hm. :)

[20:58] *** snearch left
[20:59] <moritz> masak: searching for an advanced, NYI language feature instead of using existing ones is a disease that the early adaptors should be immune against *SCNR*

[21:01] <masak> moritz: oh, come *on*. :P

[21:01] <masak> that is so not fair -- I didn't pout once, and was honestly looking for a workaround.

[21:02] <moritz> ok, you are right

[21:02] <moritz> sorry

[21:02] <masak> I believe moritz++ was referring to http://strangelyconsistent.org/blog/attitude

[21:02] <masak> which is still relevant and something I try to keep in mind.

[21:04] <masak> fwf, I'm having fun building Yet Another Presentation Framework this evening.

[21:04] <masak> this is it, folks. the Ultimate Framework.

[21:05] <moritz> does it mean it's a superset of my own framework? :-)

[21:05] *** GlitchMr left
[21:07] <masak> maybe in some very loose sense.

[21:15] *** kmwallio joined
[21:17] *** isBEKaml left
[21:19] * moritz will have to do some JS hacking tomorrow, and doesn't look forward to it :/

[21:32] <TimToady> I still fail to see how you expect a cut-like operation to read your mind about whether there's an A there or not if you never test for A

[21:34] <masak> IWBNI heredocs were listed at http://perl6.org/compilers/features

[21:34] <masak> TimToady: I'm willing to test for A. but I can't seem to do it outside of an alternation or a non-capturing group, and <!> will only abort that alternation or non-capturing group.

[21:36] *** noam left
[21:36] *** fglock left
[21:38] <TimToady> niecza: grammar G { regex TOP { <outer>* }; regex outer { A <inner>* }; regex inner { B | <?before A > ::: <!> | (.) { say "Unknown B: $0" } <!> } }; say G.parse("ABBBBABBB")

[21:38] <p6eval> niecza v15-2-gd19c478: OUTPUT«#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named({}.hash)>, #…

[21:38] *** QnD joined
[21:39] <TimToady> well, that's the way I said first thing, it's just rakudo don't do it yet

[21:39] <QnD> anyone in here know anything about active perl dev

[21:39] <TimToady> as in from ActiveState?

[21:39] <QnD> yeh

[21:39] <TimToady> as far as I know there's no ActiveState development of Perl 6...</rimshot>

[21:40] <TimToady> a #perl-help or #perl channel might be more useful there

[21:40] <QnD> i need to know how to load activeperl for other OS's so i can crosscompile

[21:40] *** noam joined
[21:40] <QnD> k

[21:40] <TimToady> there have historically been activestate mailing lists, maybe you can hunt those up

[21:41] <masak> TimToady: yes, that was the first thing I said, but my question was about how to do it in present-day Rakudo... :)

[21:41] <TimToady> here, have a lollipop

[21:41] <QnD> activestate used to be cool with giving out info.... now they are too big for their boots

[21:42] <TimToady> so the way to do it in present-day Rakudo is to patch it :P

[21:43] <QnD> thx... cheers

[21:43] <masak> apparently. :)

[21:43] *** QnD left
[21:45] <TimToady> hmm, I have an idea

[21:45] *** noam_ joined
[21:46] *** plobsing joined
[21:47] <TimToady> perl6: grammar G { regex TOP { <outer>* }; regex outer { A <inner>* }; regex inner { B | [(.) { say "Unknown B: $0" }]?? } }; say G.parse("ABBBBABBB")

[21:47] <p6eval> rakudo 4bdb94, niecza v15-2-gd19c478: OUTPUT«(timeout)»

[21:47] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/VlYubNqekx line 1, column 124 - line 2, column 1␤»

[21:48] <TimToady> perl6: grammar G { regex TOP { <outer>* }; regex outer { A <inner>* }; regex inner { B | [(.) { say "Unknown B: $0" }]?? <!> } }; say G.parse("ABBBBABBB")

[21:48] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unknown B: A␤#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named…

[21:48] <p6eval> ..rakudo 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[21:48] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/5eLZZnvd6g line 1, column 128 - line 2, column 1␤»

[21:48] *** havenn left
[21:48] *** noam left
[21:49] *** kaare_ left
[21:50] <TimToady> perl6: grammar G { token TOP { <outer>* }; token outer { A <inner>* }; regex inner { B | [(.) { say "Unknown B: $0" }]?? <!> } }; say G.parse("ABBBBABBB")

[21:50] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unknown B: A␤#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named…

[21:50] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/Gdl79TKEwQ line 1, column 128 - line 2, column 1␤»

[21:50] <p6eval> ..rakudo 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[21:50] *** noam_ left
[21:51] <TimToady> that ought to fail with 0 reps the first time, and backtrack to 1 rep (and a warning) only if the whole pattern fails, I'd think

[21:52] <TimToady> perl6: grammar G { token TOP { <outer>* }; token outer { A <inner>* }; regex inner { B || [(.) { say "Unknown B: $0" }]?? <!> } }; say G.parse("ABBBBABBB")

[21:52] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unknown B: A␤#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named…

[21:52] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/xmzeg5iDxt line 1, column 129 - line 2, column 1␤»

[21:52] <p6eval> ..rakudo 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[21:53] <TimToady> perl6: grammar G { token TOP { <outer>* $ }; token outer { A <inner>* }; regex inner { B || [(.) { say "Unknown B: $0" }]?? <!> } }; say G.parse("ABBBBABBB")

[21:54] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unknown B: A␤#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named…

[21:54] <p6eval> ..rakudo 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[21:54] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/9gw6cevc66 line 1, column 131 - line 2, column 1␤»

[21:54] <TimToady> not clear why the ?? isn't working

[21:56] <TimToady> perl6: grammar G { token TOP { <outer>* $ }; token outer { A <inner>* }; regex inner { B || <!> || (.) { say "Unknown B: $0" } <!> } }; say G.parse("ABBBBABBB")

[21:56] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unknown B: A␤#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named…

[21:56] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/IiWG4hQHx0 line 1, column 134 - line 2, column 1␤»

[21:56] <p6eval> ..rakudo 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[21:58] <TimToady> perl6: grammar G { token TOP { <outer>* $ }; regex outer { A <inner>* }; regex inner { B || <!> || (.) { say "Unknown B: $0" } <!> } }; say G.parse("ABBBBABBB")

[21:58] <p6eval> niecza v15-2-gd19c478: OUTPUT«Unknown B: A␤#<match from(0) to(9) text(ABBBBABBB) pos([].list) named({"outer" => (#<match from(0) to(5) text(ABBBB) pos([].list) named({"inner" => (#<match from(1) to(2) text(B) pos([].list) named({}.hash)>, #<match from(2) to(3) text(B) pos([].list) named…

[21:58] <p6eval> ..rakudo 4bdb94: OUTPUT«Unknown B: A␤=> <ABBBBABBB>␤ outer => <ABBBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤ outer => <ABBB>␤  inner => <B>␤  inner => <B>␤  inner => <B>␤␤»

[21:58] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class G: "&parse"␤    at /tmp/bxRvS7HBpj line 1, column 134 - line 2, column 1␤»

[21:59] * TimToady gives up spamming for now

[22:01] <masak> it's a tricky one to workaround, fershure.

[22:03] *** fglock joined
[22:06] <dalek> nqp/kill_props_vtables: 572970e | bacek++ | src/ (2 files):

[22:06] <dalek> nqp/kill_props_vtables: Update to latest parrot with replaceing prop VTABLEs with standalone functions

[22:06] <dalek> nqp/kill_props_vtables: review: https://github.com/perl6/nqp/commit/572970edfa

[22:07] <jnthn> Well, that'll save some pointless virtualism. bacek++

[22:21] *** PacoAir joined
[22:25] *** mj41 left
[22:35] <masak> nom: my $foo = "OH HAI"; say "<b>$foo</b>"

[22:35] <p6eval> nom 4bdb94: OUTPUT«Method 'at_key' not found for invocant of class 'Str'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1196␤  in block <anon> at /tmp/oxbLthoO2u:1␤␤»

[22:35] <masak> nom: my $foo = "OH HAI"; say "<b>$foo\</b>"

[22:35] <p6eval> nom 4bdb94: OUTPUT«<b>OH HAI</b>␤»

[22:35] <masak> oh, that works now. someone++

[22:42] *** havenn joined
[22:43] *** skipper joined
[22:45] <cognominal> I have the feeling that my macbook ventilator is more sollicitated but for a shorter time with compiling nom with bs

[22:46] <cognominal> *solicited?

[22:46] <masak> phenny: "ventilateur"?

[22:46] <phenny> masak: "fan" (fr to en, translate.google.com)

[22:47] <cognominal> oops

[22:47] <masak> from Latin "vannus" -- "winnowing basket".

[22:47] <cognominal> when my French hit the fan...

[22:47] <masak> :)

[22:47] <cognominal> *hits

[22:47] <masak> "pardon my French..."

[22:47] *** havenn left
[22:48] *** skipper left
[22:51] *** PacoAir left
[22:51] <cognominal> :)

[22:51] *** PacoAir joined
[22:52] *** fglock left
[22:52] *** PacoAir_ joined
[22:57] *** PacoAir__ joined
[22:57] *** PacoAir left
[22:57] *** PacoAir__ is now known as PacoAir

[22:59] *** PacoAir_ left
[23:04] <cognominal> "Le président de la chaîne Starbucks, Howard Schultz, pose devant le premier-café boutique de Paris, avenue de l'Opéra"  Avec un mug. On voit le fin connaisseur de la culteur française. Je doit être comme ma mère qui me fait une scène quand je bois dans une canette, mais je ne  peux pas boire du chocolat ou du café dans un gobelet en carton.

[23:04] <masak> guten nacht, #perl6

[23:04] <cognominal> oops

[23:04] <cognominal> wrong channel again :(

[23:04] <jnthn> C'est affreux!

[23:04] <masak> "Avec un mug." :)

[23:04] <masak> knowing this channel, he's gonna throw it at a wall.

[23:05] <jnthn> .oO( at a Wall )

[23:06] <masak> "I've decided never to develop Perl 6, and to put Jon Orwant in anger management therapy."

[23:07] <cognominal> :)

[23:07] *** snearch joined
[23:08] <cognominal> well in French Perl conferences we do serve coffee in a platic cup because we are cheap.

[23:08] <cognominal> but people don't have to pay for it so we have a excuse.

[23:10] <masak> Jon Orwant incident, plastic cup version: "I've decided to release Perl 5.8"

[23:10] <masak> heh, fan fiction. it's fun.

[23:11] <masak> Jon Orwant incident, cup doesn't break: "We need to harden Perl 5 and make it more secure."

[23:11] <jnthn> .oO( Nej, d e fan! )

[23:12] <masak> phenny: "Nej, det är fan!"

[23:12] <masak> phenny: "Nej, det är fan!"?

[23:12] <phenny> masak: "No, it's hell!" (sv to en, translate.google.com)

[23:13] * jnthn is still working out the exact usage of that word

[23:13] <jnthn> I hear it daily, however :)

[23:13] <masak> Jon Orwant incident, cup goes through a window: "We need a dedicated Windows port of Perl."

[23:14] <cognominal> :the mug transmogrified to a strawberry?

[23:14] <masak> only in a universe where the cup hits the wall and breaks, does Mr Wall get to break backwards compat. :)

[23:14] *** ascrazy left
[23:15] <jnthn> And the result was smashing. :)

[23:15] <masak> jnthn: it's a complex word, to be sure. I count uses as a noun, adverb, and interjection.

[23:16] <cognominal> is that wat to fuck or shit is to english?

[23:16] <cognominal> *what

[23:16] <jnthn> My impression is it's not that strong.

[23:16] <masak> only because secularism is on the rise.

[23:17] <masak> religious swears simply don't have that strong a feel anymore.

[23:17] <jnthn> English swears seem pretty fashionable here.

[23:18] <masak> everything from the Anglophone culture is immediately cool here.

[23:18] <jnthn> Even I'm cool in Sweden.

[23:19] <jnthn> Though that's mostly due to the weather. :P

[23:19] *** PacoAir left
[23:19] * [Coke] stares at his haskell problem.

[23:20] <cognominal> I am reading Miles Davis autobriography,  there is many "shit" and/or "motherfucker" per page.  And in one of my favorite movie "The big Lebowsky" uses "fucking" every other sentences.

[23:20] <masak> [Coke]: what *is* your Haskell problem?

[23:20] <cognominal> s/uses/The dude uses/

[23:22] *** PacoAir joined
[23:22] * masak tries again to leave

[23:22] <masak> 'night, #perl6

[23:23] <jnthn> see you dans l'aeroport, masak :)

[23:30] <[Coke]> masak: gah, I was going to tell you my problem. ;)

[23:30] <[Coke]> masak: o/

[23:36] <[Coke]> In case he lied, see http://feather.perl6.nl/~coke/pugs.patch; with it, "Int" throws a multi error, before it says ::Int.

[23:40] <geekosaur> 404...

[23:41] *** havenn joined
[23:43] <[Coke]> s/patch/diff/

[23:52] <jnthn> Time for sleep...'night

[23:53] *** gv left
[23:53] <[Coke]> jnthn: ~~

[23:55] <geekosaur> mmmmmmrgh was hoping it was a haskell type error, I have a little clue about those, pugs multis are a bit beyond me (I should probably try to wrap my head around that again)

