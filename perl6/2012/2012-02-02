[00:01] *** stepnem joined
[00:23] * sorear wonders if ey can make it

[00:24] *** lestrrat left
[00:25] *** lestrrat joined
[00:26] *** whiteknight joined
[00:46] <colomon> +1 to sorear and [Coke] making it to YAPC::NA.  niecza hackathon!

[00:50] <sorear> heh.  I haven't even looked at "where" and "when" yet

[00:51] <colomon> Madison Wisconsin

[00:55] <colomon> June 13-15

[00:59] <sorear> Wisconsin, the one province of the US that I actually have to look up where it is

[00:59] <sorear> (thanks)

[01:07] <colomon> we call them "states".  ;)

[01:07] <colomon> It's right around the lake from Michigan.

[01:13] *** skids joined
[01:18] <TimToady> wait, I'm confused, Michigan is a lake, right?  ;)

[01:18] * sorear thinks "states" is a horrible name, especially when speaking to an int'l audience

[01:18] <TimToady> and is Madison named after James or Dolley?

[01:19] <TimToady> there's the united states, and the untied states...

[01:19] * TimToady continues to be in the state of confusion

[01:23] <sorear> also, why do Americans talk about counties when they've NEVER had counts?

[01:23] <sorear> at least there are priests in Louisiana

[01:27] <skids> More importantly, why do some Americans rant about "czars" when they've never had one?

[01:43] <offby1> do we really rant about czars?

[01:43] * offby1 mostly rants about bad UI

[01:51] <TimToady> czars are 1 off from bad UI :P

[01:56] * offby1 is enlightened

[02:08] *** Chillance left
[02:10] <skids> How does one fail a regexp from inside a closure without failing the interpreter?

[02:19] *** Util left
[02:20] *** Util joined
[02:21] *** whiteknight left
[02:35] <TimToady> use a <?{ ... }> closure and return false

[02:41] *** benabik joined
[02:43] *** leprevost left
[02:44] *** bkolera left
[03:02] *** jaldhar joined
[03:03] *** jerome_ left
[03:05] *** jferrero left
[03:17] *** jerome_ joined
[03:19] <colomon> niecza: say $*EXECUTABLE_NAME

[03:19] <p6eval> niecza v13-389-g852f0ff: OUTPUT«/home/p6eval/niecza/run/Niecza.exe␤»

[03:22] *** orafu left
[03:22] *** orafu joined
[03:24] <colomon> niecza: say %*ENV<PERL6LIB>

[03:24] <p6eval> niecza v13-389-g852f0ff: OUTPUT«Any()␤»

[03:27] <colomon> tadzik: ping?

[03:46] <colomon> tadzik: unping.  Finally figured out where ~/.perl6 is set as the destination for libraries

[03:54] *** wolfman2000 joined
[04:01] *** kmwallio joined
[04:04] <colomon> saddest thing: running a program you think is going to work, and having it simply stop and print "Any()"

[04:10] <offby1> I can think of sadder

[04:10] <colomon> yeah, probably

[04:11] <colomon> still, it's quite annoying

[04:12] <colomon> niecza: die

[04:12] <p6eval> niecza v13-389-g852f0ff: OUTPUT«Unhandled exception: Died␤  at /home/p6eval/niecza/lib/CORE.setting line 1344 (die @ 3) ␤  at /tmp/wS7piXWxcT line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3606 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3607 (modul…

[04:14] *** jaldhar left
[04:16] <diakopter> niecza: coredump

[04:16] <p6eval> niecza v13-389-g852f0ff: OUTPUT«===SORRY!===␤␤Undeclared routine:␤    'coredump' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1347 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at…

[04:18] * diakopter ponders "czars are 1 off..."

[04:21] * diakopter gives up

[04:22] *** jaldhar joined
[04:39] *** kmwallio left
[04:52] *** birdwindupbird joined
[05:13] *** jaldhar left
[05:53] <moritz> niecza: class A { has $.x; submethod BUILD($a) { $!x = $a } }; A.new('foo')

[05:53] <p6eval> niecza v13-389-g852f0ff: OUTPUT«Unhandled exception: Excess arguments to Mu.new, used 1 of 2 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Mu.new @ 1) ␤  at /tmp/5RPbkW5vm_ line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3606 (ANON @ 3) ␤  at /home/…

[05:54] <moritz> pugs: class A { has $.x; submethod BUILD($a) { $!x = $a } }; A.new('foo')

[05:54] <p6eval> pugs b927740: OUTPUT«*** Must only use named arguments to new() constructor␤    Be sure to use bareword keys.␤    at /tmp/gCepPVcyYH line 1, column 56 - line 2, column 1␤»

[06:13] *** kaleem joined
[07:06] *** ponbiki joined
[07:15] *** birdwind1pbird joined
[08:04] *** birdwind1pbird left
[08:11] *** am0c^ joined
[08:12] <am0c^> is there no such a thing like PERL6_LIB env variable in spec?

[08:13] <Tene> Dunno about spec, but rakudo uses PERL6LIB

[08:15] *** tarch joined
[08:15] *** dbr joined
[08:18] *** wolfman2000 left
[08:28] *** snearch joined
[08:39] *** daxim joined
[08:45] <am0c^> Thanks Tene

[08:50] *** mj41 joined
[09:01] *** snearch left
[09:19] *** ponbiki left
[09:21] *** kshannon left
[09:22] *** kshannon joined
[09:23] *** fasad joined
[09:25] *** tarch left
[09:31] <moritz> and niecza implements the -I command line option

[09:42] *** am0c^ left
[09:47] *** BooK joined
[09:48] *** Psyche^ joined
[09:48] *** BooK_ joined
[09:49] *** Patterner left
[09:49] *** Psyche^ is now known as Patterner

[09:50] *** am0c joined
[09:56] <masak> good antenoon, #perl6

[10:05] <masak> interesting discussion over at p6l.

[10:06] <masak> TheDamian's "Constructor args certainly shouldn't be restricted to just the names

[10:06] <masak> of public attributes." is especially interesting.

[10:06] <masak> does he mean "private attributes are OK too"? or "other stuff is OK too"?

[10:07] <moritz> the latter, judging from his example with dates

[10:07] *** eiro joined
[10:12] <masak> alright, OK.

[10:13] <masak> then there isn't any discord with his prior statements about encapsulation. goodie.

[10:13] <moritz> at least that's how I read it :-)

[10:15] <masak> thing is as far as I know, no-one ever claimed that constructor args would be restricted to the names of public attrs... :)

[10:15] <masak> maybe if you squint that's the default if you don't override anything.

[10:15] <masak> ah well. I don't yet quite understand what problem is being addressed with the proposed changes, so...

[10:16] <masak> I see the DRY violation that moritz points out, but... that's never been a problem for me in practice, for some reason.

[10:16] <masak> I usually end up defining my own .BUILD or my own .new -- not so often both of them.

[10:17] <moritz> masak: it seems to be unexpected and hard to explain to newcomers, which should be a red flag

[10:17] <moritz> well, the point is, if you use private attributes and a custom .new, you *have* to write a custom BUILD too

[10:18] <moritz> and I can't any imagine any reaction to that other than "why the f<explitive deleted> should I have to do that?"

[10:18] <jnthn> morning, #perl6

[10:18] <moritz> mrnng, jnthn

[10:19] <jnthn> I hope everyone fiddling with object construction is thinking about how to make whatever we settle on possible to do fast as well. :)

[10:19] <moritz> jnthn: I can't speak for everybody, but I do

[10:20] <jnthn> :)

[10:21] <moritz> which is another reason I reject pmichaud++'s proposal (from yesterday in the IRC logs) to call another method on the constructed object

[10:21] *** am0c left
[10:21] <moritz> self.bless(*, |%public).PRIVATE(|%private)

[10:22] <jnthn> huh, how'd that work...

[10:22] <masak> o.O

[10:22] <masak> we're meant to make things *easier*.

[10:22] <moritz> aye :-)

[10:23] <masak> having .new and .BUILD separated is already a head trip for people, who are used to one constructor.

[10:24] <masak> how about we just re-allow private attrs to be initialized? it's an "I can argue it both ways" issue anyways.

[10:24] <masak> (in the sense that the act of instantiation in itself is a kind of encapsulation breakage)

[10:24] <moritz> dunno if that's possible to do efficiently, but can't we do the private vs. public attributes check is done in .new instead of bless/BUILDALL/BUILD?

[10:25] <moritz> then somebody who writes his own .new doesn't have to bother with it anymore

[10:25] <jnthn> moritz: I saw that suggestion and am still wondering how to do it efficiently (more

[10:25] <masak> oh! maybe here's an insight. whatever solution we come up with must allow the *class* block to set private attrs at construction (even readonly ones), but nothing outside of it.

[10:26] <jnthn> To do it would really mean changing the interface to bless so we can differentiate public vs private there

[10:26] <jnthn> Which in turns would mean BUILDALL can

[10:27] <moritz> where exactly does the differntiation happen now?

[10:27] <jnthn> moritz: BUILDALL

[10:28] <moritz> hm, I do forsee one problem

[10:28] <moritz> class A { has $!x }; class B is A { has $.x }

[10:28] <moritz> we need to be careful not to bust that case

[10:29] <jnthn> Yeah, that one currently isn't a problem.

[10:29] <jnthn> I worry that there's simply too many choices here to make one true sane default

[10:30] <jnthn> And I'd rather the default be fairly un-magical.

[10:30] * masak head spin

[10:30] <jnthn> We also need to worry about what happens as people refactor (public to private, private to public, etc)

[10:35] *** dbr left
[10:35] * jnthn read through the thread

[10:36] *** dbr joined
[10:37] <masak> jnthn: yes. private to public is the more important one -- I don't mind if making something public private is a bit more work.

[10:39] * jnthn wonders how much the issue is that we scope attributes lexically to a class, but scope construction to all attributes over the inheritance chain.

[10:39] <jnthn> Maybe

[10:39] *** abercrombie left
[10:39] <jnthn> self.bless(*, |%named) # will only touch publics

[10:40] <jnthn> self.bless(*, A{ x => 42 }) # in this case, a class name was mentioned, and x may initialize A's $!x 

[10:40] *** dbr left
[10:40] <Timbus> you touched A's privates :o

[10:40] <jnthn> Timbus: Relax, A seemed to enjoy it :P

[10:41] <jnthn> So if you're initializing the non-virtual, you're qualifying it.

[10:41] *** abercrombie joined
[10:41] <jnthn> That was, the default .new only initializes publics

[10:41] <Timbus> yes i learned that when my irc bot stopped working :v

[10:42] <jnthn> BUT you can write a .new that initializes privates.

[10:42] <Timbus> -ng let me set privates in new and personally i thought that was good?

[10:42] <jnthn> And you're made to do it in a way that will still work if the class is subclassed.

[10:42] <moritz> Timbus: well, the spec changed

[10:43] <jnthn> Timbus: A bunch of people thought it wasn't so good and...what moritz said. So Rakudo just followed that change. :)

[10:43] <moritz> jnthn: I need to think about that, but it does sound interesting

[10:43] <jnthn> We do try to implement the spec now and then. :)

[10:43] <jnthn> moritz: Yes, I need more coffee to ponder that one too. 

[10:43] <Timbus> i guess readonly public attrs is fine, too

[10:43] <jnthn> Timbus: Yes

[10:44] *** dbr joined
[10:44] <moritz> Timbus: it made me think about why i wanted to keep some attributes private, and decided there wasn't a good reason to share them with the world

[10:44] *** dbr left
[10:45] *** dbr joined
[10:45] <fasad> hello #perl6

[10:45] <Timbus> lol moritz 

[10:50] *** dbr left
[10:52] <masak> fasad: greetings, perl6onaut!

[10:53] <fasad> :) so what's a 'package' basically ?

[10:53] <moritz> fasad: it's a relict, mostly

[10:54] <masak> it's like a module, but without many of the conveniences of modules.

[10:54] <moritz> so, basically no reason to use one

[10:54] <moritz> right?

[10:54] <jnthn> It's mostly a "placeholder"

[10:54] <jnthn> That's its most important role.

[10:54] <moritz> ah right

[10:54] <moritz> you can stub something as a package

[10:54] <jnthn> class A::B { } # A is a Package

[10:54] <jnthn> note that

[10:54] <moritz> and later declare it as a role, class, grammar, ...

[10:54] <jnthn> nom: module A { }; module A { }

[10:54] <p6eval> nom ce5cca: OUTPUT«===SORRY!===␤Redeclaration of symbol A␤at /tmp/r4U8T98AAu:1␤»

[10:55] <jnthn> nom: package A { }; module A { }

[10:55] <p6eval> nom ce5cca:  ( no output )

[10:55] <jnthn> A package can always have its identity stolen by a module/class/role/grammar etc

[10:55] <jnthn> Why is why you can do

[10:55] <jnthn> *Which is...

[10:55] <jnthn> nom: class A::B { }; class A { }

[10:55] <p6eval> nom ce5cca:  ( no output )

[10:55] <jnthn> And it works.

[10:56] <masak> inneresting.

[10:56] <masak> I did not know this.

[10:56] <fasad> jnthn++

[10:56] <jnthn> Well, more revealing is

[10:56] <jnthn> nom: class A::B { }; $A::x = 42; class A { }; say $A::x

[10:56] <p6eval> nom ce5cca: OUTPUT«42␤»

[10:57] <jnthn> Well, that's sill though 'cus the assignment runs at runtime :)

[10:57] <moritz> I think it took quite some pain until we've figured out all that package stuff

[10:57] <jnthn> nom: class A::B { }; BEGIN { $A::x = 42; }; class A { }; say $A::x

[10:57] <p6eval> nom ce5cca: OUTPUT«42␤»

[10:57] <jnthn> There, that's what I was trying to show. :)

[10:58] <jnthn> moritz: Yeah...well, we put it off for a while in Rakudo by using Parrot namespaces. :)

[11:00] <fasad> we really need some documentation. looking up the synopses everytime is... ugh :(

[11:01] <moritz> fasad: do you want to become our documentation champion?

[11:02] <fasad> moritz: well i think i could, but then all of you here would be bombarded with questions, mostly trivial ones :p

[11:03] <moritz> fasad: that's OK

[11:03] <fasad> there is a wiki for perl 6: http://www.perlfoundation.org/perl6/index.cgi?perl_6 . Looks dead !

[11:04] <moritz> I think it was locked down due to spam

[11:05] <moritz> or was that reversed?

[11:05] <masak> doesn't really matter -- it's not the final answer anyway.

[11:05] <masak> we need something authoritative, that people treat as authoritative. not Yet Another Wiki.

[11:06] <moritz> and that one was really ugly to use

[11:06] <moritz> no, the one authorotative thing should be in a git repo somewhere

[11:06] <fasad> moritz: +1 #ugly

[11:06] <masak> problem is, the spec will always be authoritative in exactly the way we want, and it will always "win" per default when the docs start to slip and bitrot.

[11:07] <masak> so it's a bit of an uphill battle.

[11:07] <moritz> masak: it simply means we need more people who take care of user docs than who update the specs

[11:07] <fasad> so will i have to learn POD then?

[11:08] * fasad wonders why is html bad as a markup language for perl

[11:09] <moritz> fasad: well, first of all it offers no easy option for verbatim code inclusion

[11:09] <moritz> it sucks to have to write  <code>if $x &lt; $y {</code>

[11:11] <fasad> ok. masak: though the specs will always be authorative, u agree we need something like the perl5 documentation?

[11:12] * fasad is astonished at his use of 'we' !

[11:12] <moritz> maybe we can even move stuff out of specs into user docs

[11:13] <moritz> for example some of the S32 stuff could well be changed into more user-oriented docs, and then there's no reason for duplicating it

[11:14] <fasad> also, will rakudo, niecza or some new compiler(!) share the documentation?

[11:15] <moritz> well

[11:15] <moritz> I'm sure that rakudo star will ship the docs

[11:15] <moritz> but in the form of bundling it, not copying and editing on its own

[11:15] <moritz> or maybe importing it for .WHY stuff

[11:16] <fasad> moritz: ^^ ?

[11:17] <moritz> fasad: sorry, which part is unclear?

[11:17] <fasad> what is .WHY? #if we had documentaion, i wouldn't be asking :)

[11:17] <moritz> there's a way to attach documentation to objects

[11:18] <moritz> and ask an object about the docummentation attached to it by calling $stuff.WHY

[11:24] <fasad> masak: i started watching Perl 6 Appetizers (http://www.youtube.com/watch?v=kOiGF9eRUWY). The first six minutes have no audio :(

[11:29] <fasad> can i rename thw wikipedia page "Rakudo Perl" to "Rakudo Perl 6" ? #need an official name

[11:30] <moritz> sure (but leave a redirect in place)

[11:30] *** birdwindupbird left
[11:31] <fasad> moritz: whenever you renmae a page (called 'moving') on Wikipedia, it automatically creates a redirect

[11:31] <moritz> ah, nice

[11:31] *** snearch joined
[11:33] *** mtk left
[11:37] *** birdwindupbird joined
[11:45] <fasad> done

[12:00] *** Chillance joined
[12:09] *** wolf_ joined
[12:19] <dalek> nqp/bs: 5deb755 | jnthn++ | src/6model/serialization. (2 files):

[12:19] <dalek> nqp/bs: Refactor serialization code to eliminate a bunch of code duplication and make it more extensible.

[12:19] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5deb7557d0

[12:19] <dalek> nqp/bs: 0deef9b | jnthn++ | src/6model/serialization. (2 files):

[12:19] <dalek> nqp/bs: Similar refactor for deserialization.

[12:19] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/0deef9b7cc

[12:19] <jnthn> .oO( To get the day off to a good start, delete 100 lines of code... )

[12:20] *** jferrero joined
[12:21] *** am0c^ joined
[12:34] <masak> fasad: oh! it is news to me that the remaining parts of the video *has* audio!

[12:39] <moritz> nom: say 'a' after 'b'

[12:39] <p6eval> nom ce5cca: OUTPUT«False␤»

[12:39] <moritz> nom: say 'b' after 'a'

[12:39] <p6eval> nom ce5cca: OUTPUT«True␤»

[12:40] <moritz> nom: say 10 after 2

[12:40] <p6eval> nom ce5cca: OUTPUT«True␤»

[12:41] <masak> fasad: I find that video is pretty useless without the slides. unfortunately, I was never able to put those slides online, because the PDF became too big :(

[12:41] <masak> fasad: the slides source is online, though: https://github.com/masak/talks/blob/master/yapc-eu-2010-appetizers/slides

[12:52] *** kaleem left
[12:52] <masak> diakopter: fwiw, I didn't get the "czars are 1 off..." thing either.

[12:54] <fasad> masak: i didn't get it either !

[12:54] *** skids left
[12:55] *** Chillance left
[12:55] *** tokuhirom joined
[12:56] <fasad> masak: thanx for the slide source, but it defeats the very purpose of watching a video #fasad is one lazy guy

[12:56] <masak> hehe

[12:57] <masak> in that case, I think that's the wrong video for you. had they filmed the slides, maybe you could've done without the slides source. as it is now, I don't think you'll get much out of it without the source.

[13:00] <fasad> masak: it's all right. who needs the video when you are right here  to be pestered to no end... :p

[13:00] <masak> pester away -- I love talking about Perl 6 :)

[13:02] <moritz> nom: say 1 cmp 2

[13:02] <p6eval> nom ce5cca: OUTPUT«Increase␤»

[13:03] <masak> nom: say 1 cmp 2 cmp 3

[13:03] <p6eval> nom ce5cca: OUTPUT«Increase␤»

[13:03] *** snearch left
[13:03] <masak> nom: say 1 cmp 3 cmp 2

[13:03] <p6eval> nom ce5cca: OUTPUT«Increase␤»

[13:03] <moritz> std: 1 cmp 3 cmp 2

[13:03] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤"cmp" and "cmp" are non-associative and require parens at /tmp/41Bxhgypvu line 1:␤------> 1 cmp 3 cmp ⏏2␤Check failed␤FAILED 00:01 109m␤»

[13:03] <fasad> masak: are the slide written in POD ? how do u make slides out of them? maybe i can make them on my own, without the images obviously...

[13:04] <masak> fasad: yes, they're written in a subset of Pod6.

[13:04] <masak> fasad: see https://github.com/masak/talks/blob/master/yapc-eu-2010-appetizers/make-presentation

[13:04] <masak> if you whack at that script enough, and have Inkscape installed, eventually slides will fall out.

[13:04] <masak> fasad: are you on Mac OS X?

[13:05] <fasad> masak: no. Ubuntu.

[13:05] *** grondilu joined
[13:05] <masak> then you might want to find a way to merge the individual slide PDFs in the end.

[13:06] <masak> I was on Mac OS X at the time, and it turned out it was easier to just load all individual slide PDFs into Preview, and PgDn from one to the next.

[13:06] <grondilu> perl6: my @a[4]; # of int;

[13:06] <p6eval> rakudo ce5cca: OUTPUT«===SORRY!===␤Shaped variable declarations are not yet implemented at line 1, near "; # of int"␤»

[13:06] <p6eval> ..pugs b927740:  ( no output )

[13:06] <p6eval> ..niecza v13-389-g852f0ff: OUTPUT«===SORRY!===␤␤Postconstraints, and shapes on variable declarators NYI at /tmp/BreesqZ0Wx line 1:␤------> my @a[4]⏏; # of int;␤␤Potential difficulties:␤  @a is declared but not used at /tmp/BreesqZ0Wx line 1:␤------> […

[13:06] <masak> grondilu: I want S09 too :/

[13:06] <grondilu> ?

[13:06] <masak> grondilu: that's part of the NYI parts of S09.

[13:07] <fasad> masak: btw, i think's that's a really geeky way to make slides #from text

[13:07] <fasad> but i like it

[13:07] <fasad> i also want S09 :/

[13:07] <grondilu> well, right now I just noticed that rakudo (and apparently niecza too)  don't take the # into account.  This is silly.

[13:07] *** Chillance joined
[13:08] <moritz> nom: my Int @a; @a[0] = 'Not a Number';

[13:08] <p6eval> nom ce5cca: OUTPUT«Type check failed in assignment to '$v'; expected 'Int' but got 'Str'␤  in block <anon> at /tmp/CwKAEV6YCI:1␤  in <anon> at /tmp/CwKAEV6YCI:1␤»

[13:08] <grondilu> Ahhh sorry.  My bad.

[13:08] <fasad> perl6: my @a[*];

[13:08] <p6eval> rakudo ce5cca: OUTPUT«===SORRY!===␤Shaped variable declarations are not yet implemented at line 1, near ";"␤»

[13:08] <p6eval> ..pugs b927740:  ( no output )

[13:08] <p6eval> ..niecza v13-389-g852f0ff: OUTPUT«===SORRY!===␤␤Postconstraints, and shapes on variable declarators NYI at /tmp/fbo3iWE4JY line 1:␤------> my @a[*]⏏;␤␤Potential difficulties:␤  @a is declared but not used at /tmp/fbo3iWE4JY line 1:␤------> my [33…

[13:09] <grondilu> I thought it was the '# of int' that was the problem.  Silly of me.

[13:09] *** bluescreen10 joined
[13:09] <fasad> huh. @a[*] is just the same as @a

[13:09] <jnthn> Rakudo doesn't do trait application on variables just yet.

[13:10] * jnthn wonders what the semantics of my @a[4] = ...some potentially infinite thing that maybe produces 5 elements... :)

[13:10] *** sbp left
[13:10] <grondilu> perl6:  class A { method new($x) { self.WHAT.CREATE } };  my A $a .= new "foo";

[13:10] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "\""␤    expecting operator␤    at /tmp/wWCcEHEleC line 1, column 66␤»

[13:10] <p6eval> ..rakudo ce5cca: OUTPUT«===SORRY!===␤Confused␤at /tmp/FFGQ4yP1IV:1␤»

[13:10] <p6eval> ..niecza v13-389-g852f0ff: OUTPUT«===SORRY!===␤␤Two terms in a row (method call requires colon or parens to take arguments) at /tmp/_DWNXHLBOG line 1:␤------> { self.WHAT.CREATE } };  my A $a .= new ⏏"foo";␤Other potential difficulties:␤  $x is declare…

[13:10] <grondilu> perl6:  class A { method new($x) { self.WHAT.CREATE } };  my A $a .= new("foo");

[13:10] <p6eval> rakudo ce5cca:  ( no output )

[13:10] <p6eval> ..niecza v13-389-g852f0ff: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/CBF74Hr3s4 line 1:␤------> class A { method new(⏏$x) { self.WHAT.CREATE } };  my A $a .= ␤  $a is declared but not used at /tmp/CBF74Hr3s4 line 1:␤------> d new($x) { se…

[13:10] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class A: "&CREATE"␤    at /tmp/piTd63UCKz line 1, column 28-45␤»

[13:11] <grondilu> Am I supposed to need parenthesis when calling a constructor with arguments?

[13:12] <jnthn> yes, or a colon

[13:13] <grondilu> a colon?

[13:14] <grondilu> rakudo:  class A { method new($x) { self.WHAT.CREATE } };  my A $a .= new :"foo"; # you mean this?

[13:14] <p6eval> rakudo ce5cca: OUTPUT«===SORRY!===␤Confused␤at /tmp/CCuyRg53l7:1␤»

[13:14] <jnthn>  rakudo:  class A { method new($x) { self.WHAT.CREATE } };  my  A $a .= new: "foo"

[13:14] <p6eval> rakudo ce5cca:  ( no output )

[13:14] <jnthn> Like that :)

[13:14] <jnthn> er

[13:15] <jnthn> self.WHAT.CREATE - the .WHAT is redundant there

[13:15] <jnthn> Also you skip any attribute initialization

[13:15] <grondilu> never seen this colon notation before.  It's in S06?

[13:15] <jnthn> Yes

[13:15] <jnthn> Or S12

[13:16] <grondilu> I need to check this out

[13:16] <grondilu> the less I use parenthesis, the happier I am :)

[13:16] *** xinming left
[13:19] *** xinming joined
[13:23] *** Chillance left
[13:24] *** Chillance joined
[13:25] *** dudulz joined
[13:28] *** snearch joined
[13:35] *** snearch left
[13:41] *** snearch joined
[13:44] <masak> just so long as you know what the colon does to your expression :)

[13:44] <moritz> may I colon-ize you? :-)

[13:45] * masak .oO( "Everyone wants to colon-ize." )

[13:45] <masak> sorear: is 'handles' on the roadmap? would it be a difficult addition?

[13:47] <grondilu> By the way I don't understand the motto "everyone wants the colon".

[13:48] <moritz> well, it's more of an observation than a motto

[13:48] <grondilu> but what does it mean?

[13:48] <moritz> people when asked to come up with a new syntax for a nice feature just often tend to reach for the colon

[13:48] <masak> grondilu: it's from the time of the RFCs, when a lot of syntactic proposals contained the colon in various ways.

[13:48] <masak> grondilu: note that it almost requires that ?: go away.

[13:50] <moritz> niecza: say 1 cmp 2

[13:50] <p6eval> niecza v13-389-g852f0ff: OUTPUT«Increase␤»

[13:50] <moritz> niecza: say 10 before 2

[13:50] <p6eval> niecza v13-389-g852f0ff: OUTPUT«False␤»

[13:51] <[Coke]> niecza: say ~10 before 2

[13:51] <p6eval> niecza v13-389-g852f0ff: OUTPUT«False␤»

[13:51] <[Coke]> niecza: say ~10 before ~2

[13:51] <p6eval> niecza v13-389-g852f0ff: OUTPUT«True␤»

[13:52] <moritz> perl6: class A { has @.a = 1, 2, 3, 4; method swap { @!a[0, 3] = @!a[3, 0]; self } }; say A.new.swap.a

[13:52] <p6eval> rakudo ce5cca, niecza v13-389-g852f0ff: OUTPUT«4 2 3 1␤»

[13:52] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected ","␤    expecting "_", fraction, exponent, term postfix, operator or "}"␤    at /tmp/zXwag20ZBB line 1, column 22␤»

[14:00] *** birdwind1pbird joined
[14:00] <masak> nom: my int $i = 10_000; $i++

[14:00] <p6eval> nom ce5cca: OUTPUT«Cannot assign to a non-container␤  in sub postfix:<++> at src/gen/CORE.setting:2537␤  in block <anon> at /tmp/9bXkGSxlTa:1␤  in <anon> at /tmp/9bXkGSxlTa:1␤»

[14:00] <masak> bah.

[14:00] <masak> niecza: my int $i = 10_000; $i++; say $i

[14:00] <p6eval> niecza v13-389-g852f0ff: OUTPUT«===SORRY!===␤␤Malformed my at /tmp/H7QLx7dT2m line 1:␤------> my⏏ int $i = 10_000; $i++; say $i␤␤Parse failed␤␤»

[14:01] <masak> I reject the assumption that just because it's a native, you can't ++ it

[14:02] <masak> if it's just sugar for '$i = $i + 1', then what's the big problem?

[14:02] <jnthn> That it isn't just sugar for that. :)

[14:03] <masak> I know, and I'm not saying it should be.

[14:03] <jnthn> masak: If you want to do the design work for rw on native types and tell me how it works, feel free. Otherwise, you'll just have to wait a bit until I get around to that. :)

[14:03] <masak> I'm saying I expect it to be, even though I know better.

[14:03] *** benabik left
[14:03] <jnthn> "is rw"

[14:03] <jnthn> I agree it should work - it just needs me to solve a general problem.

[14:03] <masak> oh good. :)

[14:03] *** Chillance left
[14:03] * masak stands down red alert

[14:04] <jnthn> That's why we still have yellow for native operators in features. :)

[14:04] <moritz> oh, that's not the only reason

[14:04] <moritz> for examply the bust the REPL

[14:04] *** Chillance joined
[14:04] <jnthn> Well, yeah. And PAST. :)

[14:04] <masak> nom: my $t = now; for ^10_000 {}; say now - $t

[14:05] <p6eval> nom ce5cca: OUTPUT«0.21766632631398␤»

[14:05] <moritz> you mean the lots of boxes and unboxe?

[14:05] <jnthn> moritz: Right.

[14:05] <masak> nom: my $t = now; loop (my int $i = 0; $i < 10_000; $i = $i + 1) {}; say now - $t

[14:05] <p6eval> nom ce5cca: OUTPUT«0.0619243610018518␤»

[14:05] <masak> nom: say 0.21766632631398 / 0.0619243610018518

[14:05] <p6eval> nom ce5cca: OUTPUT«3.5150354851053␤»

[14:05] <masak> this factor is the most embarassing part of Rakudo right now.

[14:05] <masak> it should be ~1.

[14:05] <jnthn> I'm not sure why you find that surprising.

[14:06] <jnthn> Unless you mean "Rakudo's optimizer shoudl re-write the first to the second" :)

[14:06] <masak> I mean that.

[14:06] *** spine joined
[14:06] <masak> of course it's not surprising that the unoptimized version performs worse :)

[14:06] <masak> involving, as it does, lists and stuff.

[14:06] <moritz> actually I expected the factor to be even worse

[14:07] <masak> it probably is, for longer lists.

[14:07] <jnthn> OK, so long as you aren't expecting a C-style for loop with native integers to match lazy list iteration in the general case. :)

[14:07] <masak> nom: my $t = now; for ^100_000 {}; say now - $t

[14:07] <masak> nom: my $t = now; loop (my int $i = 0; $i < 100_000; $i = $i + 1) {}; say now - $t

[14:07] <p6eval> nom ce5cca: OUTPUT«7.04157658210751␤»

[14:07] <p6eval> nom ce5cca: OUTPUT«0.535169021351181␤»

[14:07] <moritz> aye, worse

[14:07] <masak> yes, it is.

[14:07] <jnthn> pmichaud: ^^ :)

[14:07] <masak> jnthn: my expectations are high... but not quite that high :)

[14:07] *** am0c^ left
[14:08] <jnthn> masak: Note that the re-write isn't entirely trivial (more)

[14:08] <masak> I know.

[14:08] <jnthn> masak: In the useful case of this you'd actually expect to do something in the loop.

[14:08] <jnthn> And the for one means $_ needs the iteration variable.

[14:08] <masak> as long as you start using the fact that it's a list, you can't optimize the list away.

[14:08] <jnthn> Right. It's statically spotting it's a range.

[14:08] <masak> I'm just saying we can do more.

[14:08] <jnthn> Which means we need to construct the range literal at the compile time.

[14:09] <masak> aye,

[14:09] <masak> s/,/./

[14:09] <jnthn> Which is easier when I've done serialization. :)

[14:09] <jnthn> Good job I'm working on that. ;)

[14:09] <masak> ++jnthn

[14:09] <masak> jnthn: consider me your expectant end user, if the mental image helps you work faster :P

[14:10] * masak avoids disclosing whether that's meant as a carrot, or a stick :)

[14:10] <jnthn> .oO( carrot dangling from a stick )

[14:10] <jnthn> .oO( stick made of carrots )

[14:11] <moritz> phenny: "zuckerbrot und peitsche"?

[14:11] <phenny> moritz: "Carrots and sticks" (de to en, translate.google.com)

[14:11] <moritz> phenny: "zuckerbrot"?

[14:11] <phenny> moritz: "sugar- bread" (de to en, translate.google.com)

[14:11] <moritz> phenny: "peitsche"?

[14:11] <phenny> moritz: "whip" (de to en, translate.google.com)

[14:12] *** skids joined
[14:12] <masak> phenny: "morot och piska"?

[14:12] <phenny> masak: "carrot and stick" (sv to en, translate.google.com)

[14:13] <masak> phenny: "piska"?

[14:13] <phenny> masak: "whip" (sv to en, translate.google.com)

[14:13] <masak> phenny: "ris och ros"?

[14:13] <phenny> masak: "and fame" (sv to en, translate.google.com)

[14:14] <masak> phenny: "ros och ris"?

[14:14] <phenny> masak: "blow hot and cold" (sv to en, translate.google.com)

[14:14] <masak> what?

[14:14] <Woodi> phenny: "zamienil stryjek siekierke na kijek"

[14:14] <masak> Woodi: question mark

[14:14] <Woodi> phenny: "zamienil stryjek siekierke na kijek"?

[14:14] <phenny> Woodi: "uncle turned into an ax on a stick" (pl to en, translate.google.com)

[14:15] <daxim> lolwhat

[14:17] <masak> "stryjek" is "uncle"? is it a diminutive?

[14:17] <masak> phenny: en pl "uncle"?

[14:17] <phenny> masak: "wujek" (en to pl, translate.google.com)

[14:17] <masak> phenny: "stryjek"?

[14:17] <phenny> masak: "uncle" (pl to en, translate.google.com)

[14:18] * skids mulls various ways to fail a rexexp in an API-visible grammar.

[14:18] <moritz> <!>

[14:18] <skids> I wonder if FAILGOAL was really intended to be specced, or just an off the cuff thing.

[14:19] <skids> Yes, <!> fails, but what if I want to attach a message to that failure.

[14:19] *** mtk joined
[14:20] <skids> Certainly I don't want to generate a failure that needs to be caught to keep the program running, since regexps are pften used when you know they will sometimes fail.

[14:21] <skids> Littering warnings to ERR probably also not so friendly.

[14:21] <moritz> fwiw FAILGOAL is what the ~ combinator calls if it can't find the terminator

[14:22] <moritz> and yes, I agree we should have a mechanism for that

[14:22] <skids> So that leaves somehow figuring a way to get an unthrown Failure into the failed Match object.

[14:22] <moritz> the obvious answer would be to fail()

[14:22] <moritz> (though that's not specced to work that way with regexes)

[14:24] <skids> And then, what if you really do want fatality (unless the user explicity catches around the match statement.)

[14:24] <moritz> then you die

[14:24] <skids> Ah, of course.

[14:26] <skids> WRT FAILGOAL seems like :dba is only used in that one corner case as well?

[14:27] <moritz> yes

[14:27] <moritz> (though maybe Gramar::Debugger could also use it)

[14:27] *** birdwind1pbird left
[14:33] <Woodi> masak: "stryjek" is traditional name for fathers brother.

[14:37] *** tarch joined
[14:37] <masak> ah, so paternal uncle.

[14:40] <PerlJam> That thread about new/BUILD on p6l may mean that we need some better docs on the subject.

[14:41] <moritz> PerlJam: I don't think that's the only answer

[14:41] *** PacoAir joined
[14:41] <PerlJam> of course not.  tmtowtdi after all :)

[14:42] * masak .oO( "...to document it" )

[14:49] *** grondilu left
[14:51] *** dbr joined
[14:53] *** wolf_ left
[14:58] <flussence> that new/BUILD thing definitely needs some good code examples. I take far too long to figure it out whenever I try to do anything non-default with it.

[15:00] <moritz> everybody here is welcome to take my "let's build an object" blog post as a starting point, and explain it better / more verbose etc.

[15:00] <moritz> and I'll update the blog post to link to the better version :-)

[15:01] *** GlitchMr joined
[15:01] *** benabik joined
[15:03] *** snearch left
[15:04] *** dbr left
[15:04] *** dbr joined
[15:08] *** dbr left
[15:10] *** lestrrat left
[15:10] *** tokuhirom left
[15:11] *** lestrrat joined
[15:11] *** dbr joined
[15:14] <skids> Somehow I've managed to get myself thinking "I wish there was a ternary op inside regexps"

[15:15] * skids washes hands frantically.  Out damn spot.

[15:15] <moritz> p5 has one

[15:15] <moritz> but of course you can emulate one with <?{ ... }>

[15:16] <skids> I find myself writing stuff like: [ <? before \s> { warn foo } <!> ] || <!before \s>

[15:17] <moritz> there's no reason for the <!before \s>

[15:17] <moritz> if the next thing is a \s, then <!before \s> can't match

[15:18] <skids> It's supposed to match, to make the subrule return true, if there is no \s.

[15:18] *** nemesit joined
[15:19] <skids> e.g. false+warn if there is \s, true if there isn't.

[15:19] <moritz> then you can just add an ? at the end

[15:19] <moritz> [ <?before \s> { warn 'foo' } <!> ]?

[15:20] *** dbr left
[15:20] <skids> \o/ somehow I just wasn't seeing that. moritz++

[15:20] *** dbr joined
[15:22] <moritz> skids: if you haven't done it, I'd recommend to read STD.pm6

[15:22] <moritz> skids: it's full of useful idioms

[15:23] *** xinming left
[15:25] *** xinming joined
[15:25] *** dbr left
[15:28] <[Coke]> aloha, STD.pm6?

[15:30] <skids> Oh no the ? quantifier doesn't do it quite.  Need the truth value, and it's always true.

[15:31] <moritz> uhm, why not?

[15:31] <moritz> niecza: https://github.com/perl6/std/raw/master/STD.pm6

[15:31] <p6eval> niecza v13-389-g852f0ff: OUTPUT«===SORRY!===␤␤Confused at /tmp/H9CAD87ZTe line 1:␤------> https⏏://github.com/perl6/std/raw/master/STD.p␤␤Undeclared routine:␤     'https' used at line 1␤␤Parse failed␤␤»

[15:31] <moritz> niecza: https://github.com/perl6/std/blob/master/STD.pm6

[15:31] <p6eval> niecza v13-389-g852f0ff: OUTPUT«Unhandled exception: Unable to locate module DEBUG in @path␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1347 (die @ 3) ␤  at /home/p6eval/niecza/src/NieczaPathSearch.pm6 line 23 (NieczaPathSearch.load_module @ 12) ␤  at /home/p6eval/niecza/src/Nie…

[15:32] <skids> rakudo: say "aaa" ~~ m/ a [ a <!> ]? a /;

[15:32] <p6eval> rakudo ce5cca: OUTPUT«=> <aaa>␤␤»

[15:32] *** PacoAir left
[15:32] <skids> Which is correct, of course.

[15:32] <skids> (I think?)

[15:33] <moritz> ah, you don't want the rule to always succeed

[15:33] <skids> exactly.

[15:33] <moritz> then I misundertood your intetions earlier on

[15:34] *** PacoAir joined
[15:36] <skids> wait, shouldn't that above response be "aa" not "aaa"?

[15:36] <moritz> you're right

[15:37] <moritz> nom: say so 'a' ~~ /<!>/

[15:37] <p6eval> nom ce5cca: OUTPUT«True␤»

[15:37] <moritz> oh

[15:37] <moritz> it seems that <!> doesn't work :/

[15:38] <skids> Well, it has to work in some sense, because I'm using it effectively elsewhere I think.

[15:38] <moritz> if it worked, the above would have said 'False' and not 'True'

[15:39] <skids> I guess I just haven't tested that corner of code and just think it is working.

[15:41] <skids> might explain a few things :-)

[15:46] *** kaleem joined
[15:49] <skids> <!before <?> > seems a good enough work-alike for now.

[15:53] <TimToady> nom: say so 'a' ~~ /<?{False}>/

[15:53] <p6eval> nom ce5cca: OUTPUT«False␤»

[15:53] <TimToady> nom: say so 'a' ~~ /<?{}>/

[15:53] <p6eval> nom ce5cca: OUTPUT«False␤»

[15:53] <TimToady> that works too

[15:54] <TimToady> nom: say so 'a' ~~ /<!{1}>/

[15:54] <p6eval> nom ce5cca: OUTPUT«False␤»

[15:54] <TimToady> nom: say so 'a' ~~ /<!{0}>/

[15:54] <p6eval> nom ce5cca: OUTPUT«True␤»

[15:54] * masak submits rakudobug

[15:55] *** Trashlord joined
[15:56] <TimToady> nom: say so 'a' ~~ /<[]>/

[15:56] <p6eval> nom ce5cca: OUTPUT«===SORRY!===␤StopIteration␤»

[15:57] <TimToady> std: say so 'a' ~~ /<[]>/

[15:57] <p6eval> std 48335fc: OUTPUT«ok 00:01 112m␤»

[15:57] <TimToady> niecza: say so 'a' ~~ /<[]>/

[15:57] <p6eval> niecza v13-389-g852f0ff: OUTPUT«Unhandled exception: Unable to resolve method oplift in class Any␤  at /home/p6eval/niecza/src/RxOp.pm6 line 19 (ANON @ 2) ␤  at <unknown> line 0 (KERNEL map @ 2) ␤  at /home/p6eval/niecza/src/RxOp.pm6 line 19 (RxOp.oplift @ 3) ␤  at /home/p6eval/niecza/s…

[15:58] * masak submits rakudobug

[15:58] <masak> oh wait. Niecza :P

[15:58] <TimToady> that too

[15:58] <masak> yeah, the Rakudo one is not good either.

[16:01] <masak> it should simply allow /<[]>/ as meaning, hm, I guess /<!>/ :)

[16:01] <masak> ...which is why you thought to try it :)

[16:02] * masak submits Nieczabug

[16:02] <TimToady> ooh, a mind reader

[16:02] <TimToady> now if you can just figure out what I *will* think next week...

[16:02] <masak> more like a retrograde analyst :P

[16:03] *** jferrero left
[16:03] <moritz> QRegex/Actions.pm even has a branch in an action method that deals with <!>

[16:04] <TimToady> nom: say so 'a' ~~ /<!before ''>/

[16:04] <p6eval> nom ce5cca: OUTPUT«False␤»

[16:06] * jnthn back

[16:11] <jnthn> moritz: Ah, think I see what's up with <!>

[16:13] *** dbr joined
[16:17] *** benabik left
[16:17] *** nemesit left
[16:18] *** nemesit joined
[16:19] <jnthn> nqp: say("a" ~~ /a <!>/)

[16:19] <p6eval> nqp: OUTPUT«␤»

[16:19] <[Coke]> did the qregex branch land before *?

[16:19] <jnthn> [Coke]: Which qregex branch?

[16:19] <jnthn> nqp: say("a" ~~ /a/)

[16:19] <p6eval> nqp: OUTPUT«a␤»

[16:19] <jnthn> hm

[16:21] <jnthn> nqp: say("aa" ~~ /[a <!>]? a/)

[16:21] <p6eval> nqp: OUTPUT«a␤»

[16:21] <jnthn> nom: say("aa" ~~ /[a <!>]? a/)

[16:21] <p6eval> nom ce5cca: OUTPUT«=> <aa>␤␤»

[16:21] <jnthn> oh!

[16:21] <jnthn> nom: say("a" ~~ /a/)

[16:21] <p6eval> nom ce5cca: OUTPUT«=> <a>␤␤»

[16:21] <jnthn> Right.

[16:22] <jnthn> [Coke]: The branch that makes NQP parse using QRegex (qbootstrap) ain't done yet.

[16:23] *** offby1 left
[16:23] <pmichaud> good morning, #perl6

[16:23] <jnthn> pmichaud! \o/

[16:24] *** kaare_ joined
[16:25] <masak> pmichaud! \o/

[16:25] <[Coke]> jnthn: i'm pretty sure that's the one I meant. Thanks.

[16:25] *** kmwallio joined
[16:25] <pmichaud> rakudo:  say 'aaa' ~~ / a [ a <!> ]? a /;

[16:25] <p6eval> rakudo ce5cca: OUTPUT«=> <aaa>␤␤»

[16:25] <pmichaud> huh.

[16:25] <jnthn> pmichaud: I've got a local patch.

[16:25] <jnthn> pmichaud: <!> generates anchor with subtype 'fail'

[16:25] <jnthn> pmichaud: QAST::Compiler didn't implement that ;)

[16:25] <pmichaud> that would be the issue then :)

[16:26] <pmichaud> needs test

[16:26] <[Coke]>          \o/

[16:26] <[Coke]> pmichaud: |

[16:26] <[Coke]>          / \

[16:26] <masak> :D

[16:26] <jnthn> pmichaud: If you have a tuit for something regexy though, I'd *really* appreciate it if you could look at RT# 107746

[16:27] <skids> jnthn++ pmichaud++

[16:27] *** stepnem left
[16:27] <jnthn> Did that <!> get an RT ticket?

[16:27] <masak> yes.

[16:28] <masak> https://rt.perl.org/rt3/Ticket/Display.html?id=109672

[16:28] <jnthn> tack

[16:28] <dalek> nqp: 2208373 | jnthn++ | src/QAST/Compiler.nqp:

[16:28] <dalek> nqp: Implement subtype 'fail' of anchors in QAST::Compiler.

[16:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/220837314e

[16:29] <masak> jnthn: пожалуйста :)

[16:29] <pmichaud> jnthn++ # patch

[16:29] <pmichaud> jnthn: yes, I can look at #107746.  probably won't get to it until tomorrow

[16:29] * pmichaud looks at his ticket queue

[16:29] <jnthn> pmichaud: OK. There's a general issue with the cut handling.

[16:29] <jnthn> pmichaud: I suspect looking at this will lead you to it.

[16:30] <pmichaud> yes, cut is a bit tricky to handle overall.

[16:30] <jnthn> Basically, there are points when matching that the bstack ends up empty.

[16:30] <jnthn> In :r mode, usually.

[16:30] <jnthn> And it then goes and throws away all the captures on the cstack.

[16:30] <jnthn> (Which are still needed.)

[16:30] <pmichaud> ah, looks like it needs some mark_commit love

[16:30] <pmichaud> (if that's the case)

[16:31] <jnthn> I'm not sure I've seen a notion of mark_commit :)

[16:31] <jnthn> So yes, sounds like :)

[16:31] <pmichaud> mark commit exists in nqp-rx; I'm not sure where it ended up in the qast stuff.

[16:31] <pmichaud> essentially it's a way of shrinking the bstack (cut) while preserving the cstack

[16:32] <jnthn> I think it must be missing.

[16:32] *** drake01 joined
[16:33] *** awoodland joined
[16:33] <jnthn> If that one is fixed, and protoregexes can incorporate their NFA into their caller's NFA, then I suspect we will be very close to doing the bootstrap on qregex.

[16:34] *** kaleem left
[16:35] <dalek> rakudo/nom: 6b62395 | jnthn++ | tools/build/NQP_REVISION:

[16:35] <dalek> rakudo/nom: Bump to latest NQP to get <!> fix.

[16:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6b6239564f

[16:36] <skids> .oO(wonders if that was what was behind http://irclog.perlgeek.de/perl6/2012-01-31#i_5083420)

[16:36] <drake01> Hi guys, I m a python programmer.. Wish to learn perl too. I hear that perl6 is completely different language compared to currently used, perl5.. So for a programmar like me, what is the way to go about perl. Should I start with perl6 or perl5? Suggestions??

[16:36] <huf> both?

[16:38] <fasad> anyone care to comment on my rather naive variable use -> http://paste.ubuntu.com/826578/

[16:38] <TimToady> you can't really get a job programming Perl 6 quite yet, but you'll feel cleaner programming in it :)

[16:38] *** stepnem joined
[16:38] <masak> drake01: learn Perl 5 for the practical day-to-day. learn Perl 6 for the super awesome.

[16:39] <masak> (that said, Perl 5 is pretty awesome in many ways too. and Perl 6 is increasingly practical with each monthly release.)

[16:39] <TimToady> coming from Python, I'd suggest comparing examples on rosettacode.org to see the differences

[16:40] <PerlJam> drake01: btw, what's a "programmer like you"?  All I know is that you (probably) know python.

[16:41] <PerlJam> drake01: do you do web apps?  Sysadmin stuff?  bio-related programming? etc

[16:41] <TimToady> fasad: all symbolic references now use the ::() syntax, so you want @::($name)

[16:42] <fasad> masak: i was able to make your slides for Appetizer. yumm :)

[16:42] <fasad> TimToday: duh. thanx

[16:42] <TimToady> the obvious @$name is reserved for hard refs only

[16:43] *** kaleem joined
[16:43] <fasad> TimToday: so we were discussing (the non-existing) perl 6 documentation earlier. Any thoughts ?

[16:43] <TimToady> only just started backlogging

[16:44] <masak> fasad: I'm surprised and delighted :)

[16:45] <skids> fasad: http://perlcabal.org/syn/S02.html#Interpolating_into_names

[16:45] *** jferrero joined
[16:45] *** benabik joined
[16:45] <fasad> masak: had to hack your script just so that it works on linux... though the files generated are huge in size !

[16:46] <fasad> skids: thanks

[16:47] *** birdwindupbird left
[16:47] <masak> fasad: yeah. :/ the images are pretty high-resolution (for extra yumminess) and an image is repeated on each slide.

[16:47] <masak> that was my big mistake.

[16:50] <jnthn> You also made the whole audience hungry :P

[16:51] <pmichaud> jnthn: I don't think that qregex bootstrap is all that far away, if only I can find some dedicated tuits.  most of the pieces are in place.

[16:51] <jnthn> pmichaud: Have you seen the qbootstrap branch? :)

[16:51] <pmichaud> I only saw that there is one :)

[16:51] <masak> jnthn: hey, I asked them to put it before lunch! :)

[16:51] <jnthn> pmichaud: I did a bunch of stuff in there. :)

[16:52] *** dbr left
[16:52] <jnthn> pmichaud: Including re-working various of the HLL::Grammar methods as needed for QRegex.

[16:52] <jnthn> pmichaud: It has a stage 1 built like NQPQ is in master, and thus stage2 is NQP parsed using QRegex. It fails some tests still, but once we get that dealt with, yeah, it should bootstrap. :)

[16:53] <fasad> TimToday: i meant, what documentation would be like. Will compilers share it, or are they supposed to write their own?

[16:53] <jnthn> Agree it should be close.

[16:53] <jnthn> fasad: imo, sounds like something that should be shared.

[16:53] <fasad> jnthn++

[16:53] <jnthn> It's hard enough to get people to write *one* set of docs, let alone one per compiler! :)

[16:53] <drake01> Oops, started browsing rosettacode.org. PerlJam, I wish to learn perl to add another sorta' general purpose language in the list of languages I know. Though, I'd be using it for sysadmin and for creating webapps stuff.. 

[16:54] <fasad> surely there is more than one way to document it ? :p

[16:54] <jnthn> ;-)

[16:55] <pmichaud> fasad: of course, but in p6 we also try to make sure there's one really good way :)

[16:55] <PerlJam> drake01: then definitely learn Perl 5.  And maybe learn Perl 6 for fun.

[16:56] <TimToady> drake01: and if, while learning Perl 5, you think "this bit is really screwy", you're probably right, and it's probably fixed in Perl 6 :)

[16:56] <masak> drake01: what PerlJam said. Perl 6 may or may not take over the world one day. Perl 5 already has.

[16:56] <fasad> TimToday++ #that's what makes going back to Perl 5 hard

[16:57] <pmichaud> afk, lunch

[16:57] <masak> Perl 5 is an OK language. we can't judge past mistakes solely by today's standards.

[16:57] <pmichaud> well, we *can* ... :)

[16:58] <pmichaud> afk, lunch for real this time

[16:58] <TimToady> I know, let's do *both*!  :)

[16:58] <PerlJam> Perl 6 really needs a CPAN

[16:58] <benabik> panda?

[16:58] <masak> panda is great. it is not CPAN.

[16:58] <PerlJam> best would be a reliable way to access Perl 5 code so that we could kill 2 birds with one stone

[16:58] <flussence> cpanda?

[16:58] <masak> flussence++

[16:58] <jnthn> ;)

[16:58] *** awoodland left
[16:59] <TimToady> 'course, the best parts of CPAN are just builtins to Perl 6...

[16:59] <PerlJam> without that, the current Perl 6 compilers aren't "useful enough" to  most people I think

[16:59] <drake01> I m unable to see the differences perl6 is/'llbe having compared to perl5.. I mean python3 too was incompatabile in a few ways compared to 2.x series. But migration was not tough.. How exactly perl6 differ from perl5? 

[16:59] <masak> TimToady: DBIx, Devel::NYTProf, Carp, B::Deparse...

[16:59] <masak> er, DBIx::Class.

[17:00] <PerlJam> drake01: Perl 6 fixes all of the things that can't be fixed in Perl 5 because of backward compatibility.  :)

[17:00] <TimToady> obviously, those are just the second-best parts :)

[17:00] <masak> TimToady: PPI, Perl::Critic, Catalyst, Dancer...

[17:01] * masak decommutes

[17:01] <fasad> darke01: think about C and C++ #a fairly good analogy

[17:01] <TimToady> ouch

[17:01] <fasad> *drake: ... ^^

[17:01] <drake01> So migration from perl5 to 6 should not be a painful experience, right?

[17:01] <masak> it's migration the other way that's painful :)

[17:01] <fasad> "ouch" ?

[17:02] <TimToady> comparing Perl 6 to C++

[17:02] <masak> drake01: there's no automatic way to translate p5->p6. you basically have to learn new syntax and semantics.

[17:02] * fasad should take back his analogy?

[17:02] <jnthn> fasad: Well, we like to think that we made things cleaner and saner in Perl 6. ;)

[17:03] <TimToady> drake01: python3 was very timid in breaking backward compat.  Perl 6 thinks if you're gonna break it, break it Real Good.

[17:03] <TimToady> C++ would have been much better off not trying to hang on to the C subset

[17:03] <fasad> i meant the relationship between C and C++ . I remember something like "just like C++ is not killing C... perl 6 doesn't kill perl 5"

[17:04] * flussence much prefers web analogies. p5 -> p6 is more like going Firefox 1.0 -> Chromium 1.0; they're both pretty decent, but the newer one is much nicer, if a bit stiff at times

[17:05] <fasad> it was Damian Conway's analogy btw :)

[17:06] <PerlJam> TimToady: I think that was a smart move to get relative speedy adoption  "It's just like C, but with some added syntax"

[17:06] * fasad is looking for the video

[17:06] <mikemol> TimToady: Hey, I don't think comparing Perl 6 to C++ ought to carry a negative connotatoin either way. ^^

[17:07] <PerlJam> mikemol: you must not have used C++ very much  ;)

[17:07] <mikemol> PerlJam: Day job for the past five years. ;)

[17:07] <mikemol> PerlJam: C++/MFC/Win32. I have a very, very high pain tolerance, it seems.

[17:07] <PerlJam> indeed

[17:08] <mikemol> But for me, C++ is a very comfortable language. :)

[17:08] <PerlJam> mikemol: do you make heavy use of the STL?

[17:08] <PerlJam> mikemol: do you use templates much?

[17:09] <mikemol> PerlJam: Heck yeah.

[17:09] <drake01> 'Break it Real Good' That is scary.. What's the meaning of learning one language twice. Does the new *things* perl6 bring (when compared to perl5) are good enough to spend time learning it?

[17:09] <PerlJam> mikemol: Did you use C++ before the STL existed?

[17:09] <mikemol> Well, far more with custom templates than with the STL. And I've pushed template classes enough to expose bugs in MSVC10's compilers.

[17:10] <mikemol> PerlJam: I've had to port forward code from that era, but that's about it.

[17:10] <PerlJam> mikemol: then I think I can begin to understand your perspective.

[17:11] <mikemol> Worst I've had to do is work with VC6 on a really, really old app. Gave up and ported it to VC8. That code depended on some jawdropping compiler bugs.

[17:12] <doy> vc6 certainly had some jawdropping compiler bugs

[17:12] <PerlJam> drake01: don't think of it as learning "one language twice" because it's not.

[17:12] <mikemol> for(int foo; foo < n; ++foo) { /* some code */ } ; /* use foo for something else; declaration from inside for() was still active... */

[17:13] <PerlJam> drake01: Think of it more like ... learning "British English" after learning "American English"    though the contrast there isn't great enough

[17:13] <fasad> see the first 5 mins of http://blip.tv/open-source-developers-conference/perl-6-update-4461138 for the C++ analogy...

[17:15] *** awoodland joined
[17:15] <drake01> PerlJam: Let me put my question in this way: Why should one learn perl6 if there is perl5 with almost same capabilities (I hope) as perl6?

[17:15] <fasad> drake01: don't think much about all the analogies, 'cause there is none which descibres it perfectly... just jump right into perl6 :)

[17:18] <PerlJam> drake01: "same capabilities" reads like "Turing equivalent" to me.

[17:19] <sorear> good * #perl6

[17:19] <PerlJam> Why learn <insert any programming language> if there is <insert any other programming language> with almost the same capabilities?

[17:19] <TimToady> sorear: o/

[17:20] <PerlJam> drake01: Perl 6 is more expressive and not only makes hard things possible, but some hard things become easy.

[17:20] <TimToady> drake01: to get the same capabilities (almost) in Perl 5, you have to import a whole pile of modules

[17:20] <PerlJam> drake01: Perl 6 also makes some seemingly impossible things, possible :)

[17:21] <drake01> PerlJam: not Turing equivalent.. :) I mean, I m not expecting perl6 to offer great improvements in doing things as compared to perl5.. Almost same effort should go in both versions for solving problems from areas perl is good at.

[17:21] <drake01> Or does it?

[17:21] <moritz> there are areas where Perl 6 is much stronger than Perl 5

[17:22] <TimToady> mikemol: are you suggesting that's a bug?  Perl 6 defines loop that way to get consistent semantics; we only use -> $foo to move external declarations into a blcok

[17:22] <PerlJam> drake01: PHP, Python, Ruby, and Perl 5 are all roughly equivalent.  They all occupy the same niches these days (though PHP probably lags in sysadmin programming)  Why pick one over another?

[17:22] <moritz> for example separating binary and text data properly

[17:22] <moritz> grammars are a killer feature

[17:22] <moritz> proper, built-in classes and roles

[17:22] <moritz> and so on

[17:23] <moritz> see http://faq.perl6.org/ for a bigger list

[17:23] <TimToady> real OO, real FP

[17:23] <TimToady> real signatures

[17:23] <huf> macros!

[17:24] <TimToady> more to the point, hygienic macros

[17:25] <drake01> PerlJam: Python asks you to stick to the indentation n what not? Perl doesn't.. the grace python offers in solving problems, php doesn't.. Perl's regexes are stronger n straightforward, I hear, compared to others.. 

[17:26] <PerlJam> drake01: See moritz and TimToady for what Perl 6 offers that Perl 5 makes you work a little harder for.

[17:26] <drake01> PerlJam: * s/grace/elegance

[17:27] <huf> grace and elegance are rather subjective i feel

[17:27] <PerlJam> huf: sure, but they're important  :)

[17:27] <huf> but yes, php doesnt offer it, whatever it is.

[17:27] <huf> PerlJam: oh yes.

[17:27] * TimToady thinks that Perl 6 leapfrogs Python in elegance

[17:27] <huf> perl * leapfrogs python imho, but that's just me

[17:28] <PerlJam> TimToady: just like some perl people have myopia about the forced indentation of python, some python people have myopia about the sigils and such.

[17:29] <huf> oh yes, it's always the unfamiliar thing that you'll feel as too much

[17:30] <dalek> faq: ae47fda | moritz++ | answers.md:

[17:30] <dalek> faq: add an anchor for the feature list, and repeat the link to the feature matrix

[17:30] <dalek> faq: review: https://github.com/perl6/faq/commit/ae47fdabd0

[17:31] <mikemol> TimToady: Yeah. Having declarations in the first part of a for(;;) group imply that those declarations are tied to that for(;;) statement. If a var needs to be survive the for(;;) statement, it ought to declared prior to the for(;;) statement. At least in languages which have strong relationships with C and C++ syntax. And, at least, IMO.

[17:31] <mikemol> It comes from seing things next to each other and expecting them to be closely related. It makes inductive leaps about behavior shorter.

[17:32] *** nemesit left
[17:32] <TimToady> well, Perl 5 went that route, and it turns into a complete mess of built-ins doing one thing (sometimes) and non-builtins doing something else

[17:33] <TimToady> can't have that in an extensible language where built-ins and non-built-ins are supposed to work the same

[17:33] <mikemol> Sure.

[17:33] <mikemol> Perhaps the for(;;) construct is simply misnamed in Perl 6.

[17:33] <TimToady> it's called loop (;;)

[17:34] <mikemol> or perhaps there's an extra parameter. Why not loop (;)?

[17:34] <TimToady> and we very rarely use it

[17:34] <TimToady> and when we do use it, it's often because we *want* the loop variable to survive

[17:34] <drake01> TimToady: How does perl6 deal with the complete mess you say? 

[17:35] <TimToady> my only ever declare a variable in the surrounding block

[17:35] <mikemol> drake01: builtins are supposed to be indistinguishable, semantically, from functions and user-defined code.

[17:35] <sorear> mikemol: I'm fairly sure that C89 didn't limit for(;;) variables to the loop body

[17:35] <TimToady> loop parameters are really formal parameters to the following lambda

[17:35] <sorear> mikemol: I have for-variable scoping failed under "C89 and C++ incompatibilities"

[17:36] *** daxim left
[17:36] <TimToady> for @list -> $x {...}    # we use this to declare $x as a lexical inside the block as a formal parameter

[17:36] <PerlJam> C89 didn't let you declare vars inside the (;;) part IIRC

[17:36] *** awoodland left
[17:36] <moritz> C89 only lets you declare variables at the start of the function

[17:37] <PerlJam> start of any block

[17:37] <mikemol> sorear: C89 evolved from K&R, so I'm not really suprised, I suppose. I don't really see the point of the first parameter to for(;;), though.

[17:37] <huf> TimToady: is this similarly true for other constructs like if? if my $x = .... { # $x would be visible in the block surrounding the if?

[17:37] <TimToady> anyway, there are no special cases that way in Perl 6; with 'my' you know it's outside; with '->' you know it's inside

[17:37] <TimToady> huf: yes, it's consistent

[17:37] <mikemol> Ah, it's an initializer. That makes sense, then.

[17:38] <TimToady> but you can also write if ... -> $x {...} and then it's inside

[17:38] <huf> TimToady: ah. i thought there was some tricky sugar on top to keep this consistent AND compatible with perl5 expectations

[17:38] <huf> TimToady: the value of the condition is passed as the first param to the block?

[17:38] <TimToady> it's not compatible

[17:38] * mikemol imagines the argument then goes between making the initialization of the var the responsibility of the preceeding code, vs providing a construct-provided reminder.

[17:38] <TimToady> huf: if you want it to

[17:39] <huf> TimToady: you mean if i declare the block as taking one argument?

[17:39] <TimToady> if only passes a parameter if you explicitly declare one

[17:39] <mikemol> So I could see where that comes from. Seems an odd syntax glitch, though.

[17:39] <huf> sweet

[17:39] <TimToady> mikemol: we haven't found that people actually run into that problem much

[17:40] <TimToady> most Perl 5 code uses foreach-style loops, and people naturally translate to -> $x form, and it does what they want

[17:40] <mikemol> TimToady: They probably won't for simple cases. I can think of a few where things could get hairy, but they're derived from my understanding of C++ var cleanup, and getting confused about when destructors would get called.

[17:41] <TimToady> we don't use RAII in Perl 6

[17:41] <TimToady> we have other ways to do things at scope exit

[17:41] <mikemol> Then all my cases evaporate. :)

[17:41] <ashleydev> RAII?

[17:42] <PerlJam> ashleydev: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization

[17:42] <ashleydev> thx

[17:42] <mikemol> ashleydev: Resource Acquisition Is Initialization. Which is a really obtuse way of saying that you have object constructors and destructors do interesting things when a var is created on the stack, and when scoping rules say it should pop.

[17:43] <sorear> { open my $fh, ">foo"; print $f, "bar"; } # in Perl 5 this doesn't leak filehandles

[17:43] <mikemol> Absolute most common use case I see it in where it's used to hold mutexes.

[17:43] <TimToady> otoh, it pretty much requires a reference-counting implementation, which prevents you from running efficiently on most VMs these days

[17:45] <drake01> Ok.. So What I could decide for now is to start with perl5 (as it has good enough documentation n other sources which perl6 doesn't). and after getting familiar with it and using it for sometime, start with perl6 too.. There seems no better approach to learnin Perl.. 

[17:45] <TimToady> you'll find a lot of stuff does carry over from Perl 5 to Perl 6 too

[17:46] <TimToady> it's neither completely different nor completely the same

[17:46] <PerlJam> as long as you don't get hung up on particulars of syntax

[17:46] * PerlJam still boggles at the resistence of moving from -> to . for method invocation

[17:47] * ashleydev hates -> as a method invocer

[17:47] <TimToady> it's much prettier as a kind of sideways lambda :)

[17:48] <huf> yeah.

[17:49] <ashleydev> if perl5 moved to . instead of -> it would mean less people will eventually move to perl6

[17:49] <PerlJam> ashleydev: I don't think so

[17:49] <PerlJam> perl 5 would also have to adopt a host of other perl 6 features

[17:49] <ashleydev> it is

[17:49] <PerlJam> laziness is one of the hard ones

[17:50] <moritz> ashleydev: if per5 moved to . instead of -> it would break backwards compatibilty on such a massive scale that it wouldn't be much use anymore

[17:50] <TimToady> yes, the more that Perl 5 tries to adopt Perl 6 features, the more it becomes obvious that you need the whole package

[17:50] <[Coke]> I suspect we'll change our tune a bit when we have a 6.0 (1.0? Rakudo Perl 6.0.3 1.2.4)

[17:50] <drake01> TimToady: What should be the good way to start learning perl. Should I start with programming perl or some other book. or Jump into documentation directly..  How to start exploring documentation. any starting points??

[17:50] *** PacoAir left
[17:50] <ashleydev> moritz: na, you could use it as a feature with the new versioning scheme that perl5 is doing

[17:50] <TimToady> you can't have smartmatching without the type system, they already discovered :/

[17:50] <[Coke]> In terms of backward compat, that is.

[17:51] <PerlJam> hey, has the new camel book shipped yet?

[17:51] <TimToady> it's in QC2

[17:51] <[Coke]> drake01: I hear Programming Perl (latest) edition is due shortly.

[17:51] * [Coke] is TOO SLOW

[17:51] <moritz> ashleydev: I'll believe it when I see it

[17:51] <PerlJam> drake01: get the latest Programming Perl edition as soon as it's ready.  You can probably pre-order or O'Reilly's web site

[17:52] <PerlJam> drake01: in the mean time, look through learn.perl.org

[17:54] <PerlJam> moritz: someone posted a patch to p5p to add the dotty syntax as a feature.  It wasn't met warmly, but it didn't get a frigid stare either.

[17:54] <moritz> PerlJam: I know about the patch

[17:54] <moritz> PerlJam: my doubts are rather on a larger scale

[17:55] <moritz> PerlJam: iirc obra's vision was to support not only the syntax but also the semantics of various perl versions

[17:55] <drake01> PerlJam: Got the offline copy of documentation.. Its like 20 MBs of pdfs.  How to go through it if one wishes to.. Some startin points?

[17:55] <PerlJam> moritz: aye. that's my understanding as well

[17:55] <moritz> ie if you write 'use 5.16.2' in perl 5.20, then you'll get version 5.16.2

[17:56] <moritz> it's long shot from a -> to . patch to that versioning framework

[17:56] <moritz> drake01: perlintro

[17:57] <drake01> moritz: Thanks.. :)

[17:57] <PerlJam> moritz: it's closer now tha the patch exists though.  

[17:57] <PerlJam> moritz: maybe only marginally closer, but still  :)

[17:59] *** PacoAir joined
[18:00] <drake01> Leaving now.. It's great being here.. See Ya' people.. :) Bye!  

[18:00] *** drake01 left
[18:01] *** bacek left
[18:01] <TimToady> hmm, if BUILD set its capture into $_, then "has $!mine = .<mine>;" could pull from the named arguments maybe

[18:02] *** kaleem left
[18:04] <TimToady> hmm, except it would probably look in the wrong place for $_ if one wasn't passed

[18:05] <jnthn> We already gave $_ a meaning now.

[18:05] <jnthn> iirc

[18:05] <TimToady> in BUILD?

[18:05] <TimToady> or in initializers?

[18:05] <jnthn> TimToady: No, in the closure on the RHS or a has decl.

[18:05] <TimToady> alias for self?

[18:06] <jnthn> nom: class A { method m() { say 42; A.new } }; class B { has A $.x = .m }; B.new # I think...

[18:06] <p6eval> nom 6b6239: OUTPUT«42␤»

[18:06] <jnthn> That.

[18:06] <TimToady> nom: class A { method m() { say 42; A.new } }; class B { has A $.x = self.m }; B.new

[18:06] <p6eval> nom 6b6239: OUTPUT«Method 'm' not found for invocant of class 'B'␤  in method <anon> at /tmp/2r7mX4G_G5:1␤  in method BUILDALL at src/gen/CORE.setting:583␤  in method bless at src/gen/CORE.setting:573␤  in method new at src/gen/CORE.setting:558␤  in block <anon> at /tmp/2r7mX4G_G5:1␤  i…

[18:07] <jnthn> TimToady: It's set to the attribute's current value

[18:07] <jnthn> TimToady: Which'll be a type object.

[18:07] <jnthn> Believe S12 specs it that way. Not sure how useful it is. :)

[18:07] <TimToady> nom: class A { method m() { say 42; A.new } }; class B { has A $.x .= m }; B.new

[18:07] <p6eval> nom 6b6239: OUTPUT«use of uninitialized value of type Mu in string context␤use of uninitialized value of type Mu in string context␤===SORRY!===␤error:imcc:syntax error, unexpected DOT ('.')␤  in file '(file unknown)' line 22100176␤␤»

[18:07] <jnthn> Heh. :)

[18:07] <jnthn> Don't do that. ;)

[18:08] <jnthn> ooc

[18:08] <jnthn> std: class C { has $.x .= new }

[18:08] <p6eval> std 48335fc: OUTPUT«ok 00:01 109m␤»

[18:08] <jnthn> Is that parsed as an initializer?

[18:08] <TimToady> yes

[18:08] <jnthn> ah, good

[18:08] <TimToady> = .= := and ::=

[18:08] <jnthn> Then that'll be another bug down when I get to the initializer changes. \o/

[18:09] *** stepnem left
[18:10] * TimToady now contemplates whether special casing 'has $!mine = *;' to set from the capture would be cool

[18:11] <jnthn> TimToady: What did you make of my suggestion that named arguments to bless can only initilize things with accessors (as today), matching their virtualness, but autovivifying thingies can initialize privates (since they identify the non-virtual target)?

[18:12] <jnthn> Thus giving a way to write a .new that will initialize privates, and be Liskov-safe...

[18:13] <jnthn> (And trivially making the default not to touch privates...)

[18:13] <TimToady> I'd need to see an example

[18:14] <jnthn> TimToady: As in, a real world one, or just the syntax I'm refering to?

[18:14] <TimToady> syntax

[18:14] <jnthn> oh :)

[18:14] <jnthn> class A { has $!a; method new($a) { self.bless(*, A{ a => $a }) } }

[18:15] <jnthn> We already have the syntax.

[18:15] *** stepnem joined
[18:16] <TimToady> it bothers me to overload WHENCE for that, when its primary purpose is to direct traffic to the proper BUILD

[18:17] <jnthn> TimToady: We'd still do that (more)

[18:17] <TimToady> and it gives the control to the caller rather the class, which I don't like

[18:17] *** mj41 left
[18:18] <TimToady> I'd rather have an easy way of marking which private attributes provide a 'one-time' initialization interface

[18:18] <jnthn> TimToady: It's just that when finding values for uninitialized private attributes after running any BUILD methods, we'd let them come from the WHENCE thingy.

[18:18] <jnthn> TimToady: That is a good argument against this.

[18:19] <TimToady> and the initializer seems like a good place to specify it

[18:19] <TimToady> since it's about initialization, after all

[18:19] <jnthn> *nod*

[18:20] <TimToady> giving access to the capture would also allow the private name to change and alias a different name from the capture

[18:20] <TimToady> has $!mine = $*CAPTURE<theirs>;

[18:20] <TimToady> but shorter :)

[18:21] <jnthn> Yeah, that's a bit awkward. Right idea though.

[18:21] <jnthn> We *could* put it in $_. I'm curious how much code out there uses the existing semantics.

[18:21] *** bacek joined
[18:21] <moritz> erm

[18:21] <TimToady> esp if .= is available for teh current usage

[18:22] <moritz> somehow I feel we're discussing it backwards right now

[18:22] <TimToady> my basic assumption is that private means private

[18:22] <TimToady> by default

[18:22] <moritz> we want to give .new a way to initialize private attributes

[18:22] <moritz> not something that requires an extra mapping on the end of the attributes

[18:23] <TimToady> $s!mine = 42;  already works in niecza

[18:23] <TimToady> a class trusts itself, so you can set private attributes in new

[18:23] <TimToady> I was discussing this earlier, but everyone ignored me :)

[18:24] <moritz> well, it's not something that seems to scale nicely to initializing many attributes

[18:24] <TimToady> but I think putting it in new is wrongish, if it's an attribute of the, er, attribugte

[18:24] <moritz> nto as nicely as self.bless(*, :$foo, :$bar)

[18:25] <TimToady> it's still the wrong place if you have multiple constructors

[18:25] <TimToady> it's whether the attribute allows public initialization under that name

[18:25] <moritz> why "public"?

[18:25] <moritz> new is a method in the same class as the attribute

[18:26] <moritz> so it can do private stuff too, as you just said

[18:26] <TimToady> *only* if it's a submethod, or written as generally as the default new!!!

[18:27] <TimToady> new is the wrong place to do anything infrastructural if it can be inherited!!!

[18:27] <TimToady> (unless you're very, very careful)

[18:27] <moritz> the point of writing a custom .new *is* that you want somthing more specific than Mu.new

[18:28] <TimToady> remapping args is not infrastructural, and is fine for inheritance

[18:28] <TimToady> setting private attributs is *not* fine

[18:28] <TimToady> infrastructure belongs in BUILD or in has

[18:28] *** kaleem joined
[18:29] <dalek> nqp/bs: 3e5b40c | jnthn++ | t/serialization/02-types.t:

[18:29] <dalek> nqp/bs: First few basic tests for type serialization, just knowhow for now.

[18:29] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/3e5b40c5ed

[18:29] <dalek> nqp/bs: fdf9376 | jnthn++ | src/6model/serialization.c:

[18:29] <dalek> nqp/bs: Start stubbing in STable serialization/deserialization.

[18:29] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/fdf9376181

[18:29] <dalek> nqp/bs: d82072a | jnthn++ | t/serialization/02-types.t:

[18:30] <dalek> nqp/bs: Simplify initial type serialization test - use the P6int REPR (P6opaque is needier).

[18:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/d82072a943

[18:30] <dalek> nqp/bs: 23841b2 | jnthn++ | src/6model/reprs/KnowHOWREPR.c:

[18:30] <dalek> nqp/bs: Implement serialize/deserialize REPR functions for KnowHOWREPR.

[18:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/23841b26cd

[18:30] <dalek> nqp/bs: ad6c86b | jnthn++ | src/6model/serialization.c:

[18:30] <dalek> nqp/bs: Make sure we create STables that are properly initialized when deserializing.

[18:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/ad6c86b14d

[18:30] <dalek> nqp/bs: f3156d5 | jnthn++ | t/serialization/02-types.t:

[18:30] <dalek> nqp/bs: Oops, correct test count.

[18:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/f3156d50ad

[18:30] <dalek> nqp/bs: 3e8a06a | jnthn++ | src/6model/knowhow_bootstrapper.c:

[18:30] <dalek> nqp/bs: A KnowHOW really should publish a type check cache, so it at least matches itself.

[18:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/3e8a06a5a8

[18:30] <dalek> nqp/bs: 54ce490 | jnthn++ | src/6model/serialization.c:

[18:30] <dalek> nqp/bs: Serialization/deserialization of type check caches.

[18:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/54ce49048b

[18:31] *** mj41 joined
[18:31] <pmichaud> back from lunch

[18:31] <moritz> TimToady: I thikn we'll have a hard time educating the user about what belongs into .new and what doesn't

[18:33] <tadzik> good evening

[18:33] <TimToady> it's really pretty simple: one constructor gets called, and many initializers, so the one constructor can't do anything that needs to know *which* initializer is running

[18:33] <jnthn> o/ tadzik 

[18:34] *** fasad left
[18:35] <TimToady> we're running into a similar problem with various string conversions like .gist, where people write methods that inadvertently speak for descendants and do the wrong thing

[18:36] <TimToady> or worse, .perl

[18:36] *** kaleem left
[18:36] <TimToady> .gist is at least allowed to drop information, and it might be okay to drop a descendants info, or it might not

[18:36] <TimToady> the descendant should pick that though, not the parent class

[18:40] <TimToady> so we probably need PERL and GIST submethods that get called as appropriate by a generic .perl or .gist method

[18:43] <TimToady> then we can have sane defaults, with overrides, rather than requiring every class to always define them

[18:52] <TimToady> perl6: class A { has $.a = 1; }; class B is A { has $.b = 2 }; B.new.gist.say

[18:52] <p6eval> pugs b927740: OUTPUT«*** No such method in class B: "&gist"␤    at /tmp/9bz5bkcq41 line 1, column 57 - line 2, column 1␤»

[18:52] <p6eval> ..niecza v13-389-g852f0ff: OUTPUT«B.new(...)␤»

[18:52] <p6eval> ..rakudo 6b6239: OUTPUT«B.new(b => 2, a => 1)␤»

[18:52] <TimToady> I think .gist should probably be B{ b => 2, A{ a => 1 }}

[18:53] <masak> +1

[18:53] <TimToady> and maybe even .perl, with a .new on the end, if we can .new a WHENCE

[18:54] <TimToady> B{ b => 2, A{ a => 1 }}.new

[18:54] <TimToady> rather than cluttering it up with .new all over the place

[18:55] <TimToady> it's also more obvious here that A{} has its own control of .gist/.perl, and that gets embedded into the external structure by the default gister

[18:57] <TimToady> niecza: say set <a b c>

[18:57] <p6eval> niecza v13-389-g852f0ff: OUTPUT«set(a, b, c)␤»

[18:59] <TimToady> bbl &

[19:02] <benabik> WHENCE?

[19:03] <moritz> jnthn: something's wrong with the NQP revision in rakudo

[19:03] <jnthn> moritz: Hm :S

[19:03] <moritz> jnthn: rakudo wants 

[19:03] <moritz> 2012.01-8-g2208373

[19:03] <moritz> moritz@jacq:~/p6/rakudo/nqp>git describe origin/master 

[19:03] <moritz> 2012.01-6-g2208373

[19:04] *** nebuchadnezzar left
[19:04] <moritz> jnthn: did you forget to push some commits? or is that from another branch?

[19:04] *** nebuchadnezzar joined
[19:04] <jnthn> huh, I did git describe to get that!

[19:04] <jnthn> moritz: No, I only did it to get the <!> fixing patch

[19:05] <jnthn> I'm terribly confused about how I managed to screw this up...

[19:05] <moritz> hm

[19:05] <moritz> 2208373 is the start of the patch that fixes <!>

[19:05] <jnthn> yeah

[19:05] <moritz> but git describe gives me a 6, not an 8

[19:05] <moritz> ah well

[19:05] <jnthn> Looking on github I only see 6 commits to...

[19:06] <jnthn> OK, well, s/8/6 then

[19:06] <moritz> ok

[19:06] <jnthn> <- confused

[19:06] <masak> nom: say join 'ne', '', 'buchad', 'zzar'

[19:06] <p6eval> nom 6b6239: OUTPUT«nebuchadnezzar␤»

[19:07] <dalek> rakudo/nom: acbec86 | moritz++ | tools/build/NQP_REVISION:

[19:07] <dalek> rakudo/nom: fix NQP_REVISION

[19:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/acbec86cab

[19:07] <jnthn> moritz++

[19:11] *** [particle] left
[19:12] *** [particle] joined
[19:15] *** nemesit joined
[19:22] <moritz> jnthn: btw, I've started the 'has-self' branch, and it mostly works...

[19:22] <moritz> except that when we parse 'has $.x = ...', the RHS has $*HAS_SELF eq ''

[19:23] <moritz> even though I wrote

[19:23] <moritz> +    token scope_declarator:sym<has>       {

[19:23] <moritz> +        <sym>

[19:23] <moritz> +        :my $*HAS_SELF := 'partial';

[19:23] <moritz> +        <scoped('has')>

[19:24] <moritz> but the action method 'variable' called by <scoped('has'>) has $*HAS_SELF eq ''

[19:26] <moritz> I have no idea what's wrong; there shouldn't be any grammar rules between 'scoped' and 'variable' which reset $*HAS_SELF

[19:27] <jnthn> moritz: This is why we need the initializer fixes :)

[19:28] <jnthn> moritz: <scoped('has')> does not parse the = and what follows it in Rakudo's grammar

[19:28] <jnthn> (Changed in STD recently)

[19:28] <moritz> oh.

[19:28] <jnthn> Thus $*HAS_SELF is no longer set when we parse the RHS of the =.

[19:28] <moritz> same for 'constant', I assume?

[19:28] <jnthn> moritz: Yes.

[19:29] <jnthn> A bunch of stuff will get cleaner we switch to the new STD way of parsing initializers. :)

[19:30] <moritz> yes, I can believe that :-)

[19:31] *** birdwindupbird joined
[19:34] <jnthn> Time for something to eat here. :)

[19:34] <jnthn> And will have a couple more hours for Perl 6 related bits afterwards :)

[19:39] *** nemesit left
[19:41] *** awoodland joined
[19:43] *** awoodland left
[19:43] <moritz> nom: say (1, 2).fmt('%04d', '|')

[19:43] <p6eval> nom acbec8: OUTPUT«0001|0002␤»

[19:46] *** awoodland joined
[19:47] *** awoodland left
[19:51] *** jferrero left
[19:55] *** jferrero joined
[19:56] *** dudulz left
[19:58] *** kmwallio left
[20:03] *** Trashlord left
[20:09] <moritz> masak: some people, when faced with a problem, think "Oh I know, I'll use Java". Now they have ProblemFactory.

[20:12] <colomon> +1

[20:15] *** bluescreen10 left
[20:15] *** Trashlord joined
[20:25] <masak> moritz: Ö=

[20:25] <masak> moritz: :)

[20:27] *** bluescreen10 joined
[20:31] *** Chillance left
[20:34] <tadzik> :P

[20:36] <masak> probably they have an IProblem and an AbstractProblem as well.

[20:36] <masak> you know, because it's nice to separate a problem into an interface and an abstract implementation.

[20:38] *** birdwindupbird left
[20:38] * jnthn tries to remember the last time he actually wrote an abstract class

[20:41] <[Coke]> moritz++ #PF

[20:42] <moritz> nom: multi trait_mod:<is>(Mu $, :$abstract!) { }; class Concrete is abstract { }; say Concrete.new

[20:42] <p6eval> nom acbec8: OUTPUT«Concrete.new()␤»

[20:42] * moritz now remembers the last time he actually wrote an abstract class :-)

[20:43] <jnthn> nom: class Abstract is repr('Uninstantiable') { }; Abstract.new()

[20:43] <p6eval> nom acbec8: OUTPUT«You cannot create an instance of this type␤  in method bless at src/gen/CORE.setting:571␤  in method new at src/gen/CORE.setting:558␤  in block <anon> at /tmp/HAp2cKM6sF:1␤  in <anon> at /tmp/HAp2cKM6sF:1␤»

[20:43] <jnthn> :)

[20:55] *** tarch left
[21:05] *** GlitchMr left
[21:29] *** simcop2387 left
[21:31] *** simcop2387 joined
[21:38] *** bluescreen10 left
[21:55] *** bluescreen10 joined
[21:56] *** skids left
[22:00] *** kaare_ left
[22:00] *** SHODAN left
[22:02] *** SHODAN joined
[22:03] *** am0c joined
[22:06] <dalek> nqp/bs: d638979 | jnthn++ | t/serialization/02-types.t:

[22:06] <dalek> nqp/bs: Add a test case for serializing a P6opaque based type with knowhow meta-object; it has a single attribute.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/d638979c1b

[22:06] <dalek> nqp/bs: 5d153d9 | jnthn++ | src/6model/serialization.c:

[22:06] <dalek> nqp/bs: Should not try to serialize body of type objects, as they don't have one.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5d153d991a

[22:06] <dalek> nqp/bs: 8b5594d | jnthn++ | src/6model/s (2 files):

[22:06] <dalek> nqp/bs: Add hook for REPR data serialization/deserialization.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/8b5594db44

[22:06] <dalek> nqp/bs: ea75288 | jnthn++ | src/6model/serialization.c:

[22:06] <dalek> nqp/bs: Remove unused variable to get rid of a warning.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/ea752883b8

[22:06] <dalek> nqp/bs: 4df246b | jnthn++ | src/6model/s (3 files):

[22:06] <dalek> nqp/bs: Add write/read functions for serializing references to STables.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/4df246bc7d

[22:06] <dalek> nqp/bs: 2b2818f | jnthn++ | src/6model/reprs/P6opaque.c:

[22:06] <dalek> nqp/bs: Get serialization and much of the deserialization (minus the derived info we'll re-calculate) in place for the P6opaque REPR data. Gets the P6opaque-based type with attribute tests passing.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2b2818fa80

[22:11] <masak> reify, reify, reify, reify, gimme, eager. Rakudo stack traces read a bit like spam :/

[22:14] <tadzik> Imagine. A module, which puts ads in stacktraces

[22:14] <jnthn> Then figure out how you want them to look and make it happen. :)

[22:14] <tadzik> reify, gimme, CHEAP MEDICINE, reify

[22:14] <jnthn> reify, gimme, DRUGS TO MAKE ME, eager

[22:14] * masak shudders

[22:15] <masak> I guess my point is that I'd welcome a less cluttered and more meaningful stacktrace.

[22:15] <masak> or, here's an idea, none at all.

[22:15] <masak> because what I really want is the error message, and I have to scroll back for it across a lot of meaningless lines.

[22:16] <jnthn> Well, that's an easy patch :)

[22:16] <jnthn> Maybe a --backtrace option to enable them

[22:16] <jnthn> If you really wanted it, just run again.

[22:16] <jnthn> :)

[22:16] <am0c> hello, I think PERL6LIB environment variable should be in Perl6 spec

[22:16] <tadzik> gimme, reify, TIRED OF BUGS? TRY TARDIS!, reify, reify, reify...

[22:17] *** Moukeddar joined
[22:17] *** erana_ joined
[22:17] <jnthn> am0c: Sounds somewhat sane.

[22:19] <slavik> am0c: I would argue that it is implementation dependent

[22:19] <slavik> jnthn: PERL6LIB does not really makes sense as a language spec ... unless there is a section on implementations honoring specific things

[22:20] <masak> am0c: TimToady has said that PERL6LIB is a stop-gap solution.

[22:21] <am0c> I see.

[22:22] <masak> S11 proposes that modules end up in a database somewhere, that is, entirely divorced from a directory structures. frankly, I wouldn't mind if that never happened.

[22:22] <jnthn> Yes, clearly we should make the way modules are located very different over the various implementations, so you never know what to expect. :P

[22:23] <jnthn> PERL6LIB may not be a stopgap, but I suspect we want some kind of standardization in this area.

[22:23] <jnthn> Probably a bit early yet though.

[22:23] <jnthn> er, s/may not/may/

[22:24] *** colomon left
[22:24] <am0c> if there will not be somewhat standard thing, it could be harder to manage them.

[22:25] <masak> indubitably.

[22:28] *** benabik left
[22:29] *** colomon joined
[22:39] *** spine left
[22:48] *** packetknife joined
[23:00] *** PacoAir left
[23:01] *** PacoAir joined
[23:02] *** PacoAir left
[23:08] <jnthn> night, #perl6

[23:08] <masak> 'night, jnthn

[23:15] *** mj41 left
[23:16] <masak> 'night, #perl6

[23:17] <am0c> good night

[23:25] *** Radvendii joined
[23:25] <Radvendii> o/ perl6

[23:26] <Radvendii> i know you guys explained it to me before, but remind me why FETCH is getting called twice, when i only access the variable once?

[23:32] <[Coke]> there are irc logs, btw.

[23:32] <[Coke]> https://www.google.com/search?q=site%3Airclog.perlgeek.de+inurl%3Aperl6

[23:34] <[Coke]> (I don't remember the answer.)

[23:36] <slavik> (05:49:31 PM) jnthn: Radvendii: Proxy is a scalar container. Various bits of the runtime - as you pass the container around - will want to decontainerize it.

[23:36] <slavik> you're welcome :)

[23:36] <slavik> friday on the 20th

[23:42] *** skids joined
