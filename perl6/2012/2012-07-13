[00:02] *** stephenlb left
[00:03] *** atrodo left
[00:03] *** skids joined
[00:03] *** stephenlb joined
[00:04] *** HarryS left
[00:04] *** HarryS joined
[00:09] *** whiteknight joined
[00:10] *** whiteknight is now known as Guest51241

[00:16] *** jaldhar_ joined
[00:16] *** _jaldhar left
[00:31] *** leprevost left
[00:37] *** tokuhiro_ left
[00:48] *** spaceships joined
[00:54] *** jaldhar_ left
[00:54] *** jaldhar_ joined
[01:00] *** spaceships left
[01:05] *** benabik_ joined
[01:05] *** benabik_ left
[01:05] *** benabik_ joined
[01:05] *** thou joined
[01:05] *** benabik left
[01:05] *** benabik_ is now known as benabik

[01:16] *** scott__ joined
[01:25] *** dukeleto joined
[01:28] *** spaceships joined
[01:30] *** Guest51241 left
[01:43] <pmichaud> TimToady (and others who want to contribute):  https://github.com/perl6/specs/issues/18

[01:44] <pmichaud> (just made a minor edit; reload)

[01:45] <colomon> plan?

[01:45] <pmichaud> .plan is the lazy form of .push

[01:46] <pmichaud> http://perlcabal.org/syn/S32/Containers.html#plan

[01:46] <colomon> bless you.

[01:46] <colomon> errr, rather, pmichaud++

[01:46] <pmichaud> afaik it's nyi in rakudo, but can be easily made into yi

[01:46] <colomon> so plan will definitely do the job, right?

[01:47] <pmichaud> yes, but I'm not sure that's really intended to be the canonical way of combining the elements of two lists

[01:47] <pmichaud> (or more)

[01:48] <colomon> I don't know about that (don't know enough about .plan to judge yet) but it does kind of feel like there ought to be a graceful operator to do this.

[01:49] <pmichaud> oh, and actually plan (as defined in S32)   *won't* do it, because it flattens.

[01:49] <pmichaud> I'll update the ticket.

[01:50] <pmichaud> updated.

[01:51] <pmichaud> colomon++

[01:52] <colomon> so, graceful operator?

[01:52] <pmichaud> I don't know yet.  :-)

[01:53] <colomon> almost seems like the pipe operator should do this?

[01:53] <pmichaud> I'm hoping that's not the case.  It may be the case.

[01:53] <colomon> (I mean, not that it's implemented that away now, but could be.)

[01:54] <pmichaud> (|@x, |@y)  concerns me a little bit because it'll mean we need "lazy Parcels".  We might need them anyway, but that will mean I get to start bugging jnthn++ about it :)

[01:55] <pmichaud> i.e., the binder would have to know how to deal with Parcels that have "bare" active iterators in them.

[01:56] *** dukeleto left
[01:56] *** Exodist left
[01:56] *** plobsing left
[01:56] *** aloha left
[01:56] *** rsimoes left
[01:56] *** c1sung left
[01:56] *** baest left
[01:56] *** domidumont left
[02:03] <pmichaud> ...although I guess it would really end up being  (|@x, |@y).list ... which doesn't frighten me _quite_ as much.

[02:03] <pmichaud> but our mechanism for piping things is currently eager-ish.

[02:04] <colomon> pmichaud: just so it's clear, I'm proposing we spec an operator to do this.  I don't know what we've got now that can implement it, other than brutally using gather / take.

[02:05] <pmichaud> colomon: okay, good clarification.  I suspect "spec a new operator" falls into TimToady++ realm.

[02:05] <colomon> and it seems like a low-level approach is likely to be best, anyway.

[02:05] <pmichaud> yes

[02:05] <colomon> (implementing it, I mean)

[02:06] * colomon suspects infix:<followed-by> is a bit long

[02:07] <pmichaud> in some way it feels similar to the metaops, like  reduction or zip or something, since we're doing something to multiple lists

[02:07] <colomon> agreed

[02:07] <colomon> infix:<ZZ>?

[02:08] * colomon is sure TimToady will swoop in and fix an inelegant solution sooner or later.

[02:08] <pmichaud> well, it's more like a reduction

[02:08] <pmichaud> [followed-by]   @a, @b

[02:08] <pmichaud> but without the flattening that reduction implies :-)

[02:09] <pmichaud> anyway, yes, I'll await the swoop.

[02:09] <colomon> [,] @a, @b

[02:09] <colomon> ?

[02:09] <pmichaud> Knowing the answer to this question may speed me a fair bit along on fixing some of the other List issues

[02:09] <pmichaud> (...and it may not :-)

[02:10] <colomon> ah, I was proposing we just come up with something in the full knowledge we'll probably have to do a search and replace when TimToady++ gets involved.

[02:10] <pmichaud> [,] is already specced to mean "make a new Array"

[02:11] <pmichaud> well, I don't need the answer so much for an immediate code problem as I do for the overall question of improving the List implementation

[02:13] <pmichaud> I mean, I could just define a @x.CONCAT(@y) and patch it all up internally and it wouldn't really answer my overall understanding of flattening behavior

[02:13] <pmichaud> that's why the question is more about the canonical answer than "let's just make something that works"

[02:14] *** mucker left
[02:14] <colomon> It's just I get the urge to implement something when I realize there's a hole, you know?  :)

[02:14] *** dukeleto joined
[02:14] *** Exodist joined
[02:14] *** plobsing joined
[02:14] *** aloha joined
[02:14] *** rsimoes joined
[02:14] *** c1sung joined
[02:14] *** baest joined
[02:14] *** domidumont joined
[02:14] *** wolong joined
[02:14] *** apejens_ joined
[02:14] *** Tene joined
[02:14] *** pnu joined
[02:16] <pmichaud> I've updated the original issue to clarify that I'm looking for the canonical answer and the underlying reason for the question.  colomon++ again.

[02:18] <colomon> btw, this conversation is memorialized anyway, no?  ;)

[02:18] <pmichaud> yes, but it's less formal than a conversation in an issue thread, I think.

[02:18] <pmichaud> it's more conducive to back-and-forth discussion, as we've been having here.

[02:19] <pmichaud> a reply in an issue thread might be taken as "here's the answer" even when it's meant to be more speculative :)

[02:20] <pmichaud> my main intent for putting things into specs/issues is to keep a list of the outstanding questions, so they aren't forgotten

[02:20] <pmichaud> secondarily, they can record the major points of decision and discussion

[02:20] <pmichaud> for back-and-forth discussion and brainstorming/exploration, I feel like IRC is better suited for that

[02:21] <pmichaud> afk, time to walk the dog

[02:31] *** odoacre joined
[02:40] *** orafu left
[02:43] *** orafu joined
[03:14] *** spaceships left
[03:23] *** Su-Shee_ joined
[03:27] *** Su-Shee left
[03:32] *** TomDLux joined
[03:34] *** TomDLux left
[03:35] *** snearch joined
[03:40] *** snearch left
[03:48] *** am0c_ joined
[04:15] *** simcop2387 left
[04:17] *** simcop2387 joined
[04:23] *** snearch joined
[04:24] *** snearch left
[04:25] *** snearch joined
[04:25] <thou> tadzik: is this known panda build failure: http://paste.lisp.org/display/130520

[04:25] *** thelazydeveloper left
[04:34] <thou> This is perl6 version 2012.06-87-g499cc68 built on parrot 4.5.0 revision RELEASE_4_5_0

[04:35] *** pupoque joined
[04:40] <thou> (and panda github master)

[05:00] *** scott__ left
[05:01] *** birdwindupbird joined
[05:02] *** kaare_ joined
[05:03] *** scott__ joined
[05:25] *** snearch left
[05:29] <thou> i've found that the problem file will compile OK if I remove one directory from PERL6LIB: http://paste.lisp.org/display/130520#1

[05:30] <thou> maybe an issue with my using recent git version of nom

[05:31] *** pupoque left
[05:33] *** [particle]1 joined
[05:34] *** [particle] left
[05:38] *** stepnem left
[05:50] <thou> anyways, in case someone else runs into it, a workaround is to install the dependencies (File::Tools, JSON::Tiny, Test::Mock) with $SRC/ext in PERL6LIB, and then install panda itself (.) without it in PERL6LIB

[05:54] *** samlt joined
[05:57] *** sisar joined
[05:58] *** am0c_ left
[05:59] *** kaleem joined
[06:06] <dalek> panda: a5814af | moritz++ | bootstrap.pl:

[06:06] <dalek> panda: [bootstrap.pl] avoid a warning if $PERL6LIB is not set

[06:06] <dalek> panda: review: https://github.com/tadzik/panda/commit/a5814af563

[06:11] *** wtw joined
[06:12] *** nodmonkey joined
[06:14] *** Su-Shee_ is now known as Su-Shee

[06:20] <tadzik> thou: oh, that rings a bell

[06:21] <thou> morning, tadzik!

[06:21] <tadzik> thou: can you try boostraping on offline-bootstrap branch?

[06:21] *** GlitchMr joined
[06:21] <tadzik> good morning thou :)

[06:26] *** stephenlb left
[06:27] <moritz> \o

[06:28] <moritz> tadzik: I have a patch that fixes bootstrapping in the master branch for me

[06:28] <moritz> based on thou++'s observations

[06:28] <tadzik> great

[06:28] <thou> ==> Succesfully installed panda                                                                      

[06:28] <tadzik> did you try offline-bootstrap yet?

[06:28] <thou> (with offline-bootstrap)

[06:28] <moritz> no

[06:28] <tadzik> \o/

[06:29] <tadzik> okay, I need to go to work now :)

[06:29] <tadzik> Will catch up with you later

[06:29] <thou> ok!

[06:29] <dalek> panda: 04b6755 | moritz++ | bootstrap.pl:

[06:29] <dalek> panda: make bootstrap.pl more robust

[06:29] <dalek> panda: 

[06:29] <dalek> panda: do not add ext/ to lib once ext/ is installed

[06:29] <dalek> panda: review: https://github.com/tadzik/panda/commit/04b67556b5

[06:29] <moritz> thou++

[06:39] *** stepnem joined
[06:47] <thou> hmmm, seems that offline-bootstrap didn't install anything in ~/.perl6, so i'd have to point PERL6LIB at ~/.panda/src/* or some such to get at my modules. FYI, test is simply: rm -rf ~/.perl6 ~/.panda; perl6 bootstrap.pl; perl6 $HOME/.perl6/bin/panda

[06:48] <moritz> thou: does panda's master branch work for you after my latest patch?

[06:48] *** adu joined
[06:48] *** nodmonkey left
[06:51] <thou> i expect it will, i'll verify

[06:53] <thou> moritz: yes, works well

[06:53] <moritz> \o/

[06:53] * moritz -> commute

[06:55] *** thou left
[07:03] *** thou joined
[07:04] *** brrt joined
[07:04] *** birdwindupbird left
[07:23] *** fhelmberger joined
[07:38] *** sisar left
[07:46] *** cosimo joined
[08:03] <moritz> do we have a good name for non-native types?

[08:03] <brrt> objects?

[08:05] <sorear> boxed types?

[08:05] <sorear> refernece types?

[08:05] <sorear> [1] officially, there is no "str" type, even if rakudo supports it and niecza plans to

[08:13] <hoelzro> are there any known bugs in the regex engine? maybe some that have been fixed since Rakudo * 2012.06?

[08:13] <hoelzro> I'm making use of a fairly trivial one, but the program locks up when matching

[08:13] <hoelzro> and the problem is *really* hard to duplicate outside of my program

[08:15] <moritz> hoelzro: the common cause for infinite loops in the regex engine is quantification of zero-width matches

[08:15] <moritz> hoelzro: if you do <.foo>+ and foo can match zero characters, it loops

[08:25] *** kresike joined
[08:25] <kresike> hello all you happy perl6 people

[08:31] <hoelzro> =(

[08:31] <hoelzro> moritz: the regex is just /^ bot <[:,]>/

[08:32] <hoelzro> and it only triggers when invoked at a certain point in the call stack

[08:32] <moritz> hoelzro: that's very odd

[08:33] <hoelzro> moritz: you're telling me =)

[08:34] <moritz> hoelzro: what string or object are you matching on?

[08:34] <hoelzro> moritz: just a string

[08:34] <hoelzro> "yo"

[08:35] <moritz> yo, that's weird

[08:36] <hoelzro> indeed

[08:37] <hoelzro> any recommendations on how to debug this?

[08:37] <hoelzro> I might try running it with rakudo HEAD when I get home

[08:37] <moritz> try to make it reproducable

[08:37] <moritz> and give masak++ or me a tarball

[08:38] <moritz> and then one of us will try to golf it down

[08:38] <hoelzro> yeah, I'm trying

[08:38] <hoelzro> the problem is it's an XMPP bot

[08:38] <hoelzro> and  when I give the bot a "fake" connection that creates the same messages, the regex magically works

[08:39] <moritz> oh

[08:39] <moritz> hoelzro: try  $str = $str.encode.decode;  before matching against $str

[08:40] <moritz> hoelzro: it could be some oddity related to internal representation of the string

[08:40] <hoelzro> moritz: thanks, will do

[08:40] <hoelzro> hang on

[08:40] <moritz> r: say nqp::box_s(nqp::unbox_s("foo").encoding)

[08:40] <p6eval> rakudo 74e183: OUTPUT«use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤===SORRY!===␤error:imcc:The opcode 'repr_box_str_p_s' (repr_box_s…

[08:40] <moritz> r: say nqp::p6box_s(nqp::unbox_s("foo").encoding)

[08:40] <p6eval> rakudo 74e183: OUTPUT«No such method 'encoding' for invocant of type 'String'␤  in block <anon> at /tmp/rByhyF7rpN:1␤␤»

[08:41] <hoelzro> moritz: no dice

[08:41] *** thou left
[08:41] <hoelzro> wait, nvm!

[08:41] <hoelzro> that worked!

[08:41] <moritz> \o\ /o/

[08:42] <moritz> hoelzro: do you get that string from $socket.recv?

[08:42] <hoelzro> moritz: sort of; it was created from JSON parsed from a string from a socket

[08:43] <moritz> hoelzro: then it's kinda surprising that the JSON parsing worked, but the regex match didn't :-)

[08:43] <hoelzro> it's really odd

[08:43] <hoelzro> I think I was testing for the lock up wrong on this machine

[08:43] <hoelzro> so now I have to go back and check =/

[08:43] <moritz> anyway, the good news is that there's a parrot branch that makes IO a bit more sane

[08:44] <hoelzro> I was doing say 'before'; return unless $msg.body =~ /$re/; say 'after'

[08:44] <hoelzro> ok, cool

[08:44] <moritz> the bad news is that it will be merged after this month's parrot release

[08:44] <hoelzro> meh, I can wait

[08:44] <moritz> so it'll be in rakudo 2012.09

[08:44] <moritz> erm, 08

[08:44] <hoelzro> I should try to get my getsockname stuff into Parrot while I can

[08:55] *** adu left
[08:59] *** daxim joined
[08:59] *** am0c_ joined
[09:02] <cognominal__> r: say ?!a

[09:02] <p6eval> rakudo 74e183: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a' called (line 1)␤»

[09:02] <moritz> hoelzro: with the offensive string, please try  nqp::p6box_s(pir::encodingname__SI(pir::encoding__Is(nqp::unbox_s($YOURSTRING)));

[09:02] <cognominal__> r: say ?:!a

[09:02] <p6eval> rakudo 74e183: OUTPUT«True␤»

[09:02] <moritz> hoelzro: and tell me the result

[09:02] <cognominal__> did not read the doc, but I would have expected this one to be false.

[09:02] <moritz> (ie, say the result of that expression)

[09:02] <moritz> cognominal__: its value is false

[09:02] <moritz> cognominal__: not the pair itself

[09:03] *** samlt left
[09:04] <cognominal__> yes, I rephrase: I expected the pair to be false too.

[09:05] *** samlt joined
[09:05] <moritz> hm

[09:05] <moritz> cognominal__: do you have a use case where it's useful to be false?

[09:05] <moritz> it might be useful behavior. I don't know :-)

[09:05] <cognominal__> I was asking myself the same question :)

[09:07] <cognominal__> I suppose I  could translate my gut feeling by the expectation  ?:!a would be a huffmanization of  ?:!a.value

[09:07] <cognominal__> or more vaguely that it dwims :)

[09:08] *** bbkr joined
[09:08] <moritz> otoh with the current factoring, you can write   while my $pair = @queue.shift { ... }

[09:08] <moritz> and have it DWYM even for false Pair values

[09:08] <cognominal__> but, it may break important things

[09:09] <cognominal__> meaning?

[09:09] <hoelzro> moritz: for some reason, it's working on this machine =/

[09:09] <hoelzro> I'll try your solution when I get back home

[09:17] *** samlt left
[09:17] *** samlt joined
[09:22] *** sisar joined
[09:24] *** snearch joined
[09:40] <Coleoid> I'm looking at roast/TODO and seeing numbers a la r28344, which I cannot find in rt.perl.org...

[09:40] <Coleoid> Have I gone astray in some part of this, or should this work?

[09:41] <sorear> things that match r\d+ are SVN revisions

[09:41] <Coleoid> Ahh...

[09:42] <moritz> Coleoid: those notes are probably out of date :(

[09:42] <moritz> they were commits to the synopsis, at the time when the synopsis were still in svn

[09:42] <sorear> historically #perl6 has used the Parrot SVN repo, which contained Parrot and Rakudo, and the Pugs repo, which contained *everything else*

[09:43] <moritz> (and even before that, the synospis were in their own svn repo somewhere on svn.perl.org)

[09:43] <Coleoid> I recall, wayback, the specs being in pugs, and rakudo being in parrot...

[09:43] <sorear> but in the last few years we've 1. split the repos into more managable pieces 2. moved everying onto github

[09:44] <Coleoid> So is there a process to resolve these links,

[09:45] <Coleoid> ...to current git change IDs, or are many of these likely to be done already?

[09:46] <moritz> you can do a 'git log' in the specs repo, and search for the SVN revision number (without the leading 'r')

[09:46] <sorear> https://github.com/perl6/specs/commit/566592f6e0d46309190a7c0ae91ec51378e33874

[09:47] <sorear> on a lark I checked 'specs' first

[09:47] <sorear> it's there.

[09:47] <moritz> but it is unlikely to give you good ideas what to work on

[09:47] <Coleoid> Is there a more up-to-date source of test/spec TODOs?

[09:48] <moritz> Coleoid: I think currently the best idea is to look at the last few months of spec commits, and check the tests if they have been updated

[09:51] <Coleoid> (Checking...)

[09:52] <moritz> usually I have a huge load of roast tasks in the back of mind

[09:52] <moritz> I'm surprised to find that I can't seem to remember any

[09:52] <Coleoid> Please let me know if some return to roost.

[09:54] <jnthn> good day o/

[09:55] <moritz> \o jnthn 

[10:03] *** scott__ left
[10:05] <jnthn> (roast tasks) there's also the testneeded queue.

[10:07] <moritz> aye

[10:07] <moritz> but many of those are non-trivial

[10:07] <moritz> because the tickets only mention what the stuff should *not* do

[10:08] <moritz> or much is about how errors are reported, for which you need typed exceptions to do the testing right

[10:08] *** brrt1 joined
[10:09] *** brrt left
[10:11] <jnthn> Ah, true.

[10:11] *** brrt1 is now known as brrt

[10:16] <cognominal__> putain, je voudrais faire des courses pour bouffer

[10:16] <cognominal__> c'est quoi ce temps à la con? c'est la faute au nouveau gouvernement ou c'est l'héritage sarkozien?

[10:17] <moritz> cognominal__: wrong channel?

[10:17] <cognominal__> oops

[10:17] <jnthn> phenny: "putain"?

[10:17] <phenny> jnthn: "whore" (fr to en, translate.google.com)

[10:17] <jnthn> whoa!

[10:18] <jnthn> I thought it was just "Darn" 

[10:18] <tadzik> :)

[10:18] <cognominal__> that's a standard expletive

[10:18] <jnthn> Political rants...they get ugly :P

[10:19] <jnthn> cognominal__: At school the worst they taught us was, "zut alors"

[10:19] <cognominal__> I wonder who I need to blame for the bad weather

[10:20] <cognominal__> jnthn, I hear "zut" twice a year, at most

[10:20] <jnthn> hah!

[10:20] <jnthn> Typical high school French. Teaching you the untrendy curses.

[10:21] <cognominal__> but, that's was intended for #perlfr where we curse a lot.

[10:21] *** Psyche^ joined
[10:22] <cognominal__> I suppose, if I had a child, I would ask him to say "zut"  when talking at the familial table with no illusion about what he would say elsewhere

[10:23] * moritz just learned "merde"

[10:23] <cognominal__> with putain and merde, you can go a long way.

[10:24] *** Patterner left
[10:24] *** Psyche^ is now known as Patterner

[10:25] <cognominal__> I wonder what the french translation of the "Big Lebowsky" use for "fucking"

[10:25] <cognominal__> *uses

[10:27] <brrt> ...

[10:28] <brrt> that is possible to find out

[10:29] *** GlitchMr42 joined
[10:29] <arnsholt> cognominal__: I lolled at "c'est la faute au nouveau gouvernement ou c'est l'héritage sarkozien?"

[10:29] <arnsholt> =)

[10:29] <arnsholt> As did one of my colleagues, when he came over to see what I was laughing at ^_^

[10:29] <jnthn> .oO( The new government have already achieved growth...in the number of clouds above France )

[10:30] *** GlitchMr left
[10:30] *** GlitchMr42 is now known as GlitchMr

[10:30] *** am0c_ left
[10:35] <arnsholt> I really need to clean up some warnings in nqp_dyncall.ops just too hard to find the errors among all the warnings

[10:43] <arnsholt> jnthn: Is there an easy way we can stash the stuff created for a callback after it's been created?

[10:43] <arnsholt> If there isn't, I think we'd be forced to leak some memory for callbacks

[10:45] <arnsholt> Speaking of memory leaks and such, is there a chance that anonymous subs can get GCed?

[10:46] <jnthn> Anonymous subs certainly can get GC'd, yes.

[10:47] <sorear> it depends on how they are created

[10:47] <jnthn> And closures taken of them very certainly can.

[10:47] <sorear> anonymous subs created by closure cloning can be GCed

[10:47] <sorear> anonymous subs created by the compiler for 'eval' cannot

[10:47] <sorear> (don't use eval.)

[10:48] <arnsholt> I was thinking of something like this: native-func(sub(int $ival) { say $ival })

[10:48] <jnthn> Yes, that's at risk.

[10:49] <arnsholt> 'k. Hopefully not a big deal, at least initially

[10:49] <jnthn> I mean, if it's called back during the call to native-func it's OK

[10:49] <jnthn> If the callback is stashed somewhere and invoked by a later native call, that could be more problematic.

[10:50] <arnsholt> Indeed. File under "manually managing memory" I suppose

[10:51] <arnsholt> But the other thing: Is there some place we can easily stash a few pointers of data about a sub?

[10:52] <jnthn> Does dyncallback not give you a way to keep some data around and have it passed back to you when the callback is invoked?

[10:52] <arnsholt> Sure, that's not the problem

[10:53] <jnthn> Yeah, userdata

[10:53] <arnsholt> The problem is that we don't know whether a callback will be invoked several times or only once, so it's not safe to free the data in the callback handler

[10:53] <jnthn> Ah, I see.

[10:53] <jnthn> So we'd end up leaking that.

[10:53] <arnsholt> Currently we'll allocate a string, a struct and the callback function itself every time a sub is passed as a callback arg

[10:54] <arnsholt> So, depending on the size of the callback function, a few hundred bytes a pop, I guess

[10:54] <jnthn> Well, you can keep an array of pointers to that userdata

[10:55] <jnthn> Just in a static or something like that.

[10:55] <jnthn> And maybe some op to free things up afterwards.

[10:56] <jnthn> In general, we can't know when it's OK to free it. We'll probably have to provide a way in Zavolaj for the user to give hints.

[10:58] <arnsholt> Yeah, we'll probably want a few toggles to mark the C data in structs and arrays as freeable as well I think

[11:05] *** brrt left
[11:12] *** thelazydeveloper joined
[11:25] <cognominal__> nqp:  say( <e a b g d >.sort)

[11:25] <p6eval> nqp: OUTPUT«5␤»

[11:25] <cognominal__> hum

[11:26] <cognominal__> I have trouble with nqp. how to get the sorted array instead of the length

[11:26] <tadzik> it probably stringifies it that way

[11:26] <tadzik> use join

[11:26] <tadzik> nqp: say( <e a b g d >.sort.join(", "))

[11:26] <p6eval> nqp: OUTPUT«Method 'join' not found for invocant of class 'ResizablePMCArray'␤current instr.: '_block1000' pc 58 ((file unknown):171419499) (/tmp/9a4LGju2KR:1)␤»

[11:26] <tadzik> nqp: say( pir::join(<e a b g d >.sort, ","))

[11:26] <p6eval> nqp: OUTPUT«,␤»

[11:26] <tadzik> grr

[11:27] <tadzik> nqp: say( pir::join(", ", <e a b g d >.sort))

[11:27] <p6eval> nqp: OUTPUT«a, b, d, e, g␤»

[11:27] <tadzik> aye

[11:27] <cognominal__> and that the beginning of it cuz I will need to pass the function that does the sort.

[11:28] <cognominal__> tadzik: where is the "nqp" sort routine defined?

[11:28] <cognominal__> is that pmc stuff?

[11:28] *** xinming left
[11:29] <tadzik> I think so

[11:29] <moritz> in ResizablePMCArray

[11:29] <tadzik> it may be a Parrot VTABLE, but I'm not sure

[11:30] <moritz> not a vtable, just a method

[11:30] <cognominal__> so when it does not find a regular method it defaults to a parrot vtable method?

[11:30] <moritz> no

[11:31] <moritz> vtables and methods are called differently

[11:31] *** fridim_ joined
[11:31] <cognominal__> so concretely where is defined the sort method in my case?

[11:32] <moritz> parrot/src/pmc/fixedpmcarray.pmc

[11:33] <bbkr> How can I slurp png image into variable? I added :bin flag to open but slurp tells me "This type cannot unbox to a native string"

[11:34] <moritz> I don't think we do binary slurp yet

[11:35] <moritz> you probably need  my $f = open :bin, $filename; my $buf = $f.read(1e32); $f.close  or so

[11:35] <cognominal__> apparently I can pass a compare func :)

[11:37] <bbkr> moritz: I need to endode it for transport using Base64, which accepts only string. And binary buf will not decode to Str for the same reason that slurp failed :(

[11:37] <moritz> bbkr: erm, what?

[11:38] <moritz> bbkr: how are you calling decode?

[11:38] <moritz> (the obvious fix is to implement base64 encoding on buffers)

[11:40] <bbkr> I've tried your solution and it also fails on read

[11:40] <bbkr> my $f = open ("/Users/bbkr/Developer/Perl6/MongoDB/logotype/logo_32x32.png", :bin); my $b = $f.read(1e32); $f.close; # trying sample image

[11:40] <bbkr> This type cannot unbox to a native string

[11:41] *** fridim_ left
[11:41] <moritz> huh

[11:42] <tadzik> huh, which type

[11:42] <moritz> hm, 1e32 might be a bit big

[11:42] <tadzik> r: my $a = 1e32

[11:42] <p6eval> rakudo 74e183:  ( no output )

[11:42] <tadzik> r: my $a = 1e32; say $a

[11:42] <p6eval> rakudo 74e183: OUTPUT«1e+32␤»

[11:43] <moritz> bbkr: I can read 1e5 bytes from my 'perl6' binary

[11:43] <moritz> and it only returns 68435 bytes

[11:43] <bbkr> same issue

[11:44] <moritz> then your rakudo build is broken

[11:44] <moritz> star: my $f = open('bin/perl6', :bin); say $f.read(1e5).bytes; $f.close

[11:44] <p6eval> star 2012.06: OUTPUT«open is disallowed in safe mode␤  in sub restricted at src/SAFE.setting:2␤  in sub open at src/SAFE.setting:5␤  in block <anon> at /tmp/DRhkJxnGlV:1␤␤»

[11:44] <moritz> meh

[11:48] <bbkr> opening perl6 binary works fine, opening png fails

[11:49] <moritz> works fine here with a 24571 byte PNG image

[11:49] <bbkr> can you try to download https://github.com/bbkr/mongo-perl6-driver/raw/master/logotype/logo_32x32.png and try?

[11:49] <bbkr> maybe some byte sequence insice causes this issue

[11:50] <moritz> just a sec

[11:50] <bbkr> inside*

[11:50] <moritz> works fine here

[11:50] *** skids left
[11:50] <moritz> reads 4837 bytes, same as 'wc -c'

[11:52] <kresike> bye all

[11:52] *** kresike left
[11:53] <bbkr> moritz: I found my mistake - had space after open and bracket :)

[11:53] <tadzik> aaaargh

[11:53] <moritz> oh

[11:54] <tadzik> that sounds infuriating

[11:54] <moritz> still the error is LTA

[11:54] <tadzik> however you write that

[11:54] <tadzik> yep

[11:54] * bbkr reports

[11:54] <bbkr> thanks :)

[11:54] <moritz> it should eithe constrain the type to Str, or should coerce to it

[11:55] <tadzik> the first thing we ever put into Perl::Critic is checking for things like this

[11:55] <tadzik> subcall (foo); "please write me as subcall((foo)) to not confuse everybody"

[12:04] <bbkr> everything works now, including slurp and base64 on binary data

[12:05] <felher> I just read that a Hash is a EnumMap. But a EnumMap is supposed to be immutable according to specs, while a Hash isn't. If i create a sub like 'sub some-sub(EnumMap $em) ', i'd expect $em to be immutable. Which it doesn't have to be, because i can put a Hash in it. Is it supposed to be that way?

[12:05] <felher> Or maybe i got something wrong?

[12:05] <moritz> felher: well, the expection that $em will be immutable is simply wrong

[12:05] <moritz> *expectation

[12:06] <moritz> that's not how Liskov works

[12:07] <moritz> it only gives weaker assertions of the type "if I can call method m on EnumMap, then I can call it on any subclass of EnumMap too"

[12:09] *** Coleoid left
[12:10] *** Su-Shee left
[12:14] <felher> moritz: you're right. That isn't how Liskov works. But i find it to be odd nevertheless. Like if there were a subclass of String in the standard Java library, that is mutable. Well, not that bad, but it may be the same direction.

[12:16] <moritz> felher: as long as it's only odd (and not bad) that's OK :-)

[12:16] *** JimmyZ joined
[12:25] *** [particle] joined
[12:28] *** [particle]1 left
[12:28] *** plobsing left
[12:30] <felher> moritz: okay. What do you think about mentioning it in the EnumMap spec, that Hash is a EnumMap, but not immutable. So that noone comes across EnumMap and thinks it's a good idea to have a class that gets EnumMaps and uses them while relying on them being immutable?

[12:31] <moritz> felher: that's something that belongs in user docs, not in the specs

[12:31] *** plobsing joined
[12:31] <felher> moritz: okay :)

[12:31] <moritz> felher: and yes, EnumMap and Hash are still TODO. You can add them if you want :-)

[12:33] <felher> moritz: k. If i have some spare time this weekend. But probably not until next tuesday is over. :)

[12:33] <felher> After tuesday, chances are i have some time to spare :)

[12:42] <dalek> doc: 9231982 | moritz++ | lib/objects.pod:

[12:42] <dalek> doc: start "objects" language documentation

[12:42] <dalek> doc: review: https://github.com/perl6/doc/commit/92319824c4

[12:42] <dalek> doc: 9439739 | moritz++ | TODO:

[12:42] <dalek> doc: note that Hash and EnumMap are TODO

[12:42] <dalek> doc: review: https://github.com/perl6/doc/commit/94397394e2

[12:44] <colomon> http://www-fp.cs.st-andrews.ac.uk/~icfppc/task.pdf

[12:47] <moritz> nice :-)

[12:51] <moritz> now we just have to allow multiple robots at once per level, and have them leave land mines at certain spots...

[12:53] *** samlt left
[12:53] *** samlt joined
[12:54] *** spider-mario joined
[12:59] *** bluescreen10 joined
[13:12] *** bluescreen10 left
[13:14] *** xinming joined
[13:17] *** localhost left
[13:18] *** jaldhar_ left
[13:18] *** localhost joined
[13:26] *** bluescreen10 joined
[13:28] *** wtw left
[13:46] *** atrodo joined
[13:59] *** kaleem left
[14:07] *** fgomez left
[14:08] *** samlt left
[14:08] *** samlt joined
[14:09] *** GlitchMr left
[14:13] *** dukeleto left
[14:13] *** skids joined
[14:27] *** dukeleto joined
[14:29] *** hoelzro joined
[14:29] <PerlJam> Some of you probably saw it on #parrot, but I thought I'd mention it here anyway: http://blogs.perl.org/users/rurban/2012/07/architecture-testing.html

[14:29] <PerlJam> Seems like a good resource for someone to setup test environments for Rakudo

[14:33] *** hoelzro left
[14:34] *** birdwindupbird joined
[14:39] *** hoelzro joined
[14:41] *** jtpalmer joined
[14:45] *** sirrobert joined
[14:50] *** birdwindupbird left
[14:53] *** cognominal__ left
[14:54] *** fhelmberger left
[14:58] *** MayDaniel joined
[15:02] *** cognominal joined
[15:04] *** mucker joined
[15:05] *** mucker left
[15:05] *** cognominal left
[15:05] *** mucker joined
[15:06] *** cognominal joined
[15:13] *** thou joined
[15:15] *** cognominal left
[15:16] *** cognominal joined
[15:20] *** vmspb joined
[15:20] *** cognominal left
[15:21] *** cognominal joined
[15:21] *** thou left
[15:22] *** thou joined
[15:23] <sirrobert> Apparently .can does not recognize fallback methods set up with .^add_fallback (https://gist.github.com/3105446).  Is that intended?

[15:25] <jnthn> Hmmm

[15:25] <jnthn> Lemme see what S12 says on .can

[15:26] <jnthn> Yeah, it probably should. Looks like NYI.

[15:26] <jnthn> .oO( Not that .^add_fallback is in any way spec'd... )

[15:27] <TimToady> does that add a method, or a place to look for methods that can be modified after the fact, as CANDO specs

[15:27] <jnthn> TimToady: It's more in CANDO space.

[15:27] <jnthn> TimToady: It's the guts behind "has $!a handles *;" style wildcarding constructs.

[15:28] <jnthn> TimToady: Which now seems to have scaped into people's code. :/

[15:28] <TimToady> ah, good

[15:28] <jnthn> Despite me insistently saying "please, do it with handles if you can" :)

[15:28] <jnthn> *escaped

[15:28] <TimToady> I mean, the semantics, not the escape :)

[15:28] <jnthn> I'm a bit hazy on CANDO.

[15:28] <TimToady> well, maybe it's an eval-class escape valve

[15:29] <jnthn> Yeah, I guess.

[15:29] <jnthn> Well, I'm a bit hazy on .^can too.

[15:29] <TimToady> we should probably look at where it escaped, and why

[15:29] <diakopter> scaped indeed

[15:29] <jnthn> Well, in at least one case when I enquired the answer was, "oh, I didn't know about handles *"

[15:30] <TimToady> the intent of can is to be lazy with respect to fallbacks

[15:30] <jnthn> Do we expect .can to return something you can invoke?

[15:30] <jnthn> Or something you can iterate that produces things to invoke?

[15:30] <jnthn> Or both?

[15:30] *** cognominal_ joined
[15:31] <TimToady> both is usually nice, except when it isn't...

[15:31] <jnthn> In b we tried to make it both and it got horrible.

[15:31] <jnthn> In nom I stripped it back to "an iterable thingy"

[15:31] <jnthn> And haven't heard yelps of surprise

[15:31] <jnthn> Mostly because it gets used in boolean context.

[15:31] <TimToady> iterable is more important than invokable, I suspect

[15:32] <jnthn> And "has no elements" is false, as desired.

[15:32] <TimToady> and there's always [0]()

[15:32] <jnthn> Well, you can .^find_method if you just want to get something invokable too :)

[15:33] <jnthn> I guess a related question is, should .+ and .* operate in terms of .^can?

[15:33] *** cognominal left
[15:33] <jnthn> Which'd mean they will consider fallbacks too...

[15:33] <TimToady> why not?

[15:33] <jnthn> I don't particularly have reasons for them not to :)

[15:34] <masak> greetings, #perl6

[15:34] <jnthn> In fact, I'd more argue for them doing so :)

[15:34] *** MayDaniel left
[15:34] <jnthn> Just wanted to get a feeling of what's expected so I can implemented a righter thing.

[15:34] <jnthn> o/ masak

[15:36] *** [particle] left
[15:38] * masak back-clogs

[15:39] *** spaceships joined
[15:41] *** spider-mario_ joined
[15:41] *** spider-mario left
[15:41] *** spider-mario_ is now known as spider-mario

[15:42] <colomon> ooo, back clogging is much harder than forward clogging.  you have to be careful not to dance into something you don't see...

[15:42] <colomon> TimToady!  \o/

[15:42] <masak> also, the clogs are really hot.

[15:42] <TimToady> that's from the IR

[15:43] <masak> <Coleoid> I recall, wayback, the specs being in pugs, and rakudo being in parrot...

[15:43] <masak> this comment gave me the mental image of Perl 6 unfolding over the years like an intricate flower...

[15:44] * TimToady is only briefly on before commuting to Seattle to see Cid Taliessin Hudspeth.

[15:44] <colomon> Cid++

[15:45] <colomon> one of our local "cloggers": http://www.nicgareiss.com/Premise.html

[15:46] *** godfrey999 joined
[15:47] * masak .oO( because the world needs more Walls ) :P

[15:47] <masak> anyway, Cid++

[15:51] *** crab2313 joined
[15:52] *** vmspb left
[15:53] *** [particle] joined
[15:55] <TimToady> colomon: I admired your malaprop at http://irclog.perlgeek.de/perl6/2012-07-04#i_5784968

[16:06] *** hoelzro is now known as hoelzro|away

[16:13] *** birdwindupbird joined
[16:15] *** birdwindupbird left
[16:15] *** fridim_ joined
[16:21] *** cognominal_ left
[16:21] *** cognominal_ joined
[16:26] <[Coke]> Tear down this Wall?

[16:30] *** aindilis left
[16:34] *** sirrobert left
[16:34] *** sirrobert joined
[16:35] *** nodmonkey joined
[16:35] <bbkr> Which group has the right to take tickets in RT? I'm currently in Everyone and Unprivileged and I cannot take ticket or assign tags.

[16:36] * sirrobert was afk a bit

[16:37] <sirrobert> I don't think I can use 'handles' for what I'm trying to do =)  that's why I was using .^add_fallback

[16:37] <sirrobert> I tried... really =)

[16:38] *** cognominal_ left
[16:38] *** cognominal_ joined
[16:41] *** je joined
[16:43] <sirrobert> how can I check if a given class/role/package has been defined?

[16:45] <sirrobert> ooh... maybe I *can* use handles...

[16:45] * sirrobert is afk.

[16:46] <bbkr> star: class A{}; Any.HOW(A).WHAT.say

[16:46] <p6eval> star 2012.06: OUTPUT«use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤===SORRY!===␤error:imcc:The opcode 'get_how_p_p_p' (get_how<3>) wa…

[16:46] <bbkr> it says for me error is in line 158519259 :)

[16:46] <jnthn> wow :)

[16:46] <sirrobert> heh

[16:46] <jnthn> Yeah, we should catch that bogus syntax rather earlier :)

[16:47] *** JimmyZ left
[16:47] <bbkr> I'm not sure how to report it, I mean - what is expected

[16:49] <bbkr> I'll report that get_how_p_p_p method name is leaking to user-level error

[16:52] <bbkr> reported

[16:52] <flussence> rn: my $x = 'abcde'; my $e = :e<e>; say $x.match(/ $e.value /).perl;

[16:52] <p6eval> niecza v19-13-g442e075: OUTPUT«Match␤»

[16:52] <p6eval> ..rakudo 74e183: OUTPUT«Match.new(orig => "abcde", from => 5, to => -3, ast => Any, list => ().list, hash => EnumMap.new())␤»

[16:53] <flussence> rn: my $x = 'abcde'; my $e = :e<e>; say $x.match(/ {$e.value} /).perl;

[16:53] <p6eval> rakudo 74e183: OUTPUT«Match.new(orig => "abcde", from => 0, to => 0, ast => Any, list => ().list, hash => EnumMap.new())␤»

[16:53] <p6eval> ..niecza v19-13-g442e075: OUTPUT«#<match from(0) to(0) text() pos([].list) named({}.hash)>␤»

[16:53] <flussence> I don't get what I'm doing wrong there.

[16:55] <[Coke]> who wants RT perl6 ticket access?

[16:55] <bbkr> me please

[16:56] <bbkr> I had access before but for some reason i cannot take or assign tag to ticket now

[16:56] <bbkr> login "bbkr"

[16:56] <[Coke]> ok. just need 30 minutes to find hte damn link. ;)

[16:58] <bbkr> thanks

[16:59] <bbkr> how should "\ " (escaped space) behave in regexp? match literally?

[16:59] <bbkr> r: say " " ~~ /\ /;

[16:59] <p6eval> rakudo 74e183: OUTPUT«q[ ]␤␤»

[16:59] <benabik> r: say " " ~~ / ' ' /;

[16:59] <p6eval> rakudo 74e183: OUTPUT«q[ ]␤␤»

[17:00] *** sftp left
[17:00] *** sftp joined
[17:03] *** cognominal_ left
[17:03] *** cognominal_ joined
[17:07] <bbkr> std: q\ \ # this should be quoting or routine call?

[17:07] <p6eval> std 3b49ac8: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'q' used at line 1␤Check failed␤FAILED 00:00 40m␤»

[17:07] <[Coke]> bbkr: we removed the implicit old link between parrot commiters and perl6 bugadmins. that might have dropped you if you weren't n channel at the time to speak up.

[17:07] * [Coke] bookmarks this link so he can stop digging through parrot to find it.

[17:08] <[Coke]> bbkr: done.

[17:08] <bbkr> [Coke]: I was not on channel during that

[17:08] <bbkr> thanks

[17:09] *** thou left
[17:10] *** thou joined
[17:10] <bbkr> both taking and tag assigning works ;)

[17:11] *** fridim_ left
[17:13] *** daxim left
[17:15] *** patspam joined
[17:15] *** seldon joined
[17:18] *** dukeleto left
[17:19] *** bbkr left
[17:21] <moritz> jnthn: the problem with 'handles *' is that it needs something which can make receive arbitrary methods

[17:21] <moritz> jnthn: so that in turn needs a fallback somehow

[17:21] <jnthn> moritz: Ah...so it's being used as an escape hatch for doing your own dispatch, as such?

[17:25] <moritz> jnthn: yes

[17:31] *** dukeleto joined
[17:32] *** GlitchMr joined
[17:35] <GlitchMr> Hello

[17:36] *** je left
[17:36] *** cognominal_ left
[17:37] *** dukeleto left
[17:37] <masak> GlitchMr! \o/

[17:38] *** cognominal_ joined
[17:43] *** fhelmberger joined
[17:43] <diakopter> can NQP read environment variables?

[17:48] *** icwiener joined
[17:49] *** hoelzro|away is now known as hoelzro

[17:50] <hoelzro> moritz: btw, I "fixed" my regex lock up issue

[17:54] <moritz> diakopter: yes, via pir::new__Ps('Env')

[17:55] *** crab2313 left
[17:56] <diakopter> moritz: is that a hash of some sort?

[17:56] <PerlJam> It's a PMC

[17:56] <diakopter> that much I knew :)

[17:56] <PerlJam> :)

[17:56] <moritz> diakopter: it has a similar API, yes

[17:56] <PerlJam> yes, it's a very hashy PMC

[17:57] <moritz> ie you can $env<key>

[17:57] <moritz> *can use

[17:57] *** MayDaniel joined
[17:57] <diakopter> kthx

[17:57] <moritz> yw

[17:59] *** fhelmberger left
[18:01] <diakopter> in NQP how would I get a string that has only the alphanumeric chars from another string?

[18:03] *** cognominal_ left
[18:03] *** cognominal_ joined
[18:04] <moritz> diakopter: there's a match(string, regex, :global) method

[18:04] <moritz> so something like nqp::join('', match($string, /\w+/, :global))

[18:07] <diakopter> how about alphanumerics or spaces?

[18:07] <diakopter>  /<[\w' ']>+/ ?

[18:07] <PerlJam> Isn't there also subst?  my $foo := subst($string, $regex, '', :global);  # ?

[18:11] <moritz> yes

[18:11] <moritz> diakopter: <[\w\ ]> I think

[18:19] *** patspam_ joined
[18:21] *** patspam left
[18:22] *** patspam joined
[18:22] *** patspam_ left
[18:27] *** nodmonkey left
[18:27] *** nodmonkey joined
[18:37] * masak reads http://homepages.cwi.nl/~ralf/OOHaskell/paper.pdf with interest

[18:40] <benabik> masak++

[18:41] <moritz> r: class A { }; class B is A { has $.x; method new(*%a) { bless(A.new, |%a) } }; say B.new(x => 5).x

[18:41] <p6eval> rakudo 74e183: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&bless' called (line 1)␤»

[18:41] <moritz> r: class A { }; class B is A { has $.x; method new(*%a) { self.bless(A.new, |%a) } }; say B.new(x => 5).x

[18:41] <p6eval> rakudo 74e183: OUTPUT«No such method 'x' for invocant of type 'A'␤  in block <anon> at /tmp/aVF27bmDW7:1␤␤»

[18:44] <moritz> is that suppost to work?

[18:46] <masak> not sure.

[18:47] <masak> I thought the first arg to .bless wasn't an object so much as an underlying representation.

[18:47] <jnthn> It's a candidate.

[18:47] <masak> whether "underlying representation" is what jnthn calls "repr", I don't know.

[18:47] <moritz> so, what exactly is a candidate?

[18:47] <jnthn> Soemthing that CREATE gave you back

[18:47] <moritz> is it an object?

[18:47] <jnthn> Normally you pass * there and it calls CREATE for you.

[18:47] <jnthn> Yes.

[18:48] <moritz> so, what kind of object?

[18:48] <jnthn> It just hasn't had any initialization work done yet.

[18:48] <jnthn> Whatever type you called CREATE on.

[18:48] <moritz> so, CREATE is the closer equivalent to p5's bless

[18:48] <jnthn> r: class A { has $.x = 42; }; say A.CREATE.x; say A.new.x;

[18:49] <p6eval> rakudo 74e183: OUTPUT«Any()␤42␤»

[18:49] <moritz> and bless doesn't do any blessing, just initialization?

[18:49] <jnthn> Right, it already knows its type.

[18:49] <moritz> then it's misnamed, IMHO

[18:49] <jnthn> r: class A { has $.x = 42; }; say A.CREATE.WHAT; say A.new.WHAT;

[18:49] <p6eval> rakudo 74e183: OUTPUT«A()␤A()␤»

[18:49] <jnthn> What do you want to call it? :)

[18:50] <jnthn> I agree it's different to what Perl 5 does.

[18:50] <GlitchMr> bless is confusing with Perl 5

[18:50] <moritz> jnthn: INIT_ATTRIBUTES or so

[18:50] <jnthn> moritz: eww, no

[18:50] <moritz> also

[18:50] <jnthn> moritz: It's what you call in a custom .new

[18:50] <jnthn> It's quite user facing.

[18:51] <moritz> if the candidate is already a proper object, we could just make .bless a method on that object

[18:51] <jnthn> True

[18:51] <moritz> then you could write  self.CREATE.init(|%attrs) or so

[18:51] <moritz> or maybe s/init/INIT/

[18:51] <jnthn> It shouldn't be uppercsae since you call it yourself and it isn't magical :)

[18:52] <jnthn> BUILDALL and BUILD are uppercase 'cus they get called for you and are magical in that sense.

[18:53] <moritz> well, 'bless' is good in the sense that it's unlikely to collide with user-supplied methods

[18:53] <jnthn> Today you can write self.bless(*, |%attrs), which means you don't have to chain methods.

[18:53] <jnthn> Yes, that too :)

[18:53] <moritz> OTOH it's a constant FAQ what that * means, and what you could pass to it instead

[18:54] <jnthn> True. You normally don't care to do anything other than the default

[19:01] *** GlitchMr left
[19:02] <dalek> doc: 9c4688c | moritz++ | lib/Mu.pod:

[19:02] <dalek> doc: [Mu] document bless and CREATE

[19:02] <dalek> doc: review: https://github.com/perl6/doc/commit/9c4688c770

[19:03] <moritz> so, there's no API for reblessing an object into a subclass, right?

[19:06] *** crab2313 joined
[19:08] <jnthn> moritz: Right.

[19:08] <jnthn> moritz: .^mixin is currenlty implemented in terms of a 6model primitive for doing so.

[19:09] *** hoelzro is now known as hoelzro|away

[19:09] <masak> p6l email about .trans sent.

[19:12] * moritz sheds the bike

[19:14] <moritz> masak++

[19:14] <moritz> on the surface, the arguments for splitting the methods are convincing

[19:14] <masak> yay

[19:15] <moritz> can't tell you anything about under-the-surface yet

[19:15] <masak> understood. knowing that would be highly interesting, of course.

[19:15] <masak> in a way, I'm also only on the surface level of the whole discussion so far. but I thought throwing it out there might help make a dive.

[19:16] <colomon> masak++

[19:18] <moritz> I just thought it would be nice to be able to switch off range-DWIM in .trans

[19:19] <masak> I don't immediately see the use case for that.

[19:19] <moritz> following the thoughts of design astronautism, one could switch on features with named args

[19:20] <moritz> masak: the use case is mostly if the substitutions lists are generated

[19:21] *** patspam left
[19:21] <moritz> otoh then one can generate them as lists, not strings

[19:21] <moritz> so, never mind

[19:23] <masak> right.

[19:23] <masak> I'm not proposing scrapping things like "a..z" in .trans, by the way. I rather like that feature. and it's like tr///

[19:23] <moritz> yes, I understood that

[19:24] <flussence> r: say ([..] <a z>).perl

[19:24] <p6eval> rakudo 74e183: OUTPUT«"a".."z"␤»

[19:24] <flussence> I didn't expect that one to work... :)

[19:25] <jnthn> r: say ([..] <a z>).list.perl

[19:25] <p6eval> rakudo 74e183: OUTPUT«("a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z").list␤»

[19:25] <colomon> r: say ([..] <a g z>).perl

[19:25] <p6eval> rakudo 74e183: OUTPUT«"a".."g".."z"␤»

[19:25] <colomon> errr.... that's wrong, isn't it?

[19:25] <colomon> r: say ([..] <a g z>).list

[19:25] <flussence> r: say +([..] <a g z>).list

[19:25] <jnthn> I suspect that it will complain if you try and listify it.

[19:25] <p6eval> rakudo 74e183: OUTPUT«No such method 'succ' for invocant of type 'Range'␤  in sub postfix:<++> at src/gen/CORE.setting:1347␤  in method reify at src/gen/CORE.setting:4829␤  in method reify at src/gen/CORE.setting:4950␤  in method reify at src/gen/CORE.setting:4950␤  in method gimme at s…

[19:25] <p6eval> rakudo 74e183: OUTPUT«No such method 'succ' for invocant of type 'Range'␤  in sub postfix:<++> at src/gen/CORE.setting:1347␤  in method reify at src/gen/CORE.setting:4829␤  in method reify at src/gen/CORE.setting:4950␤  in method gimme at src/gen/CORE.setting:5328␤  in method elems at s…

[19:25] <jnthn> Right.

[19:26] <masak> r: say ("a".."g".."z").min.^name

[19:26] <p6eval> rakudo 74e183: OUTPUT«Range␤»

[19:27] <masak> so it associates to the... left.

[19:27] <moritz> std: 1..2..3

[19:27] <p6eval> std 3b49ac8: OUTPUT«[31m===[0mSORRY![31m===[0m␤".." and ".." are non-associative and require parens at /tmp/7khn6N9xv0 line 1:␤------> [32m1..2..[33m⏏[31m3[0m␤Check failed␤FAILED 00:00 41m␤»

[19:27] <moritz> r: 1..2..3

[19:27] <p6eval> rakudo 74e183:  ( no output )

[19:28] <colomon> bug indeed.  ;)

[19:28] <colomon> nr: 1..2..3

[19:28] <p6eval> niecza v19-13-g442e075: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤".." and ".." are non-associative and require parens at /tmp/8EmLGgsfcy line 1:␤------> [32m1..2..[33m⏏[31m3[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1402 (die @ 5) ␤  at…

[19:28] <p6eval> ..rakudo 74e183:  ( no output )

[19:29] <colomon> n: say ([..] <a g z>).perl

[19:29] <p6eval> niecza v19-13-g442e075: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot reduce with .. because structural infix operators are diffy and not chaining at /tmp/Moczmc98Wi line 1:␤------> [32msay ([..][33m⏏[31m <a g z>).perl[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/…

[19:29] <colomon> niecza++

[19:32] * masak submits rakudobug

[19:33] <colomon> masak: not sure what to think about the .trans thing, but I'm still pleased you raised the question

[19:34] <masak> like me, then :)

[19:34] *** patspam joined
[19:35] *** birdwindupbird joined
[19:35] * moritz likes masak

[19:35] * masak flies like an arrow

[19:35] <colomon> I find the spec kind of confusing, and the code implementing it in niecza makes it one of the more complex core functions.

[19:35] <colomon> if not *the* most complex.

[19:36] <moritz> 118 lines in rakudo

[19:37] <colomon> n: say 2678 - 2561 ~ " in niecza"

[19:37] <p6eval> niecza v19-13-g442e075: OUTPUT«117 in niecza␤»

[19:38] <colomon> wouldn't be surprised if it's more or less the same code...

[19:38] <colomon> LSM class involved?

[19:38] <moritz> yes

[19:38] <colomon> yeah, probably the same code, then.  :)

[19:38] <moritz> written by masak++, iirc

[19:39] <sorear> one of these days I'm going to rip out niecza's .trans and replace it with something that uses the _real_ LTM engine

[19:39] <masak> ISTR so too.

[19:39] <sorear> alas niecza-shaped tuits are in short supply these days.

[19:39] <masak> sorear: the Rakudo team has plans for that too.

[19:40] <jnthn> We actually have a real LTM engine now :)

[19:40] <moritz> yes, but it's not easy to interface to it

[19:41] <jnthn> It was hard to write, it should be hard to interface to :P

[19:41] <jnthn> I don't know that it's all that bad actually.

[19:41] <moritz> :-)

[19:42] <moritz> well, it would be *much* easier if array-variable interpolation was supported

[19:42] <jnthn> Yeah. That's tricky to get right.

[19:42] <jnthn> due to 

[19:42] <jnthn> a | @a | bc

[19:42] <jnthn> Style things

[19:42] <moritz> and especially if we had some API that also gives us the index of the matching array element

[19:43] <moritz> jnthn: you know that @a doesn't participate in the LTM unless it's a compile-time constant?

[19:43] <jnthn> moritz: Is that in S05?

[19:44] *** kaare_ left
[19:45] <moritz> "An interpolated array using junctive semantics is declarative

[19:45] <moritz> (participates in external longest token matching) only if it's 

[19:45] <moritz> known to be constant at the time the regex is compiled.  

[19:45] <moritz> "

[19:45] <moritz> S05:1252

[19:46] <jnthn> Oh.

[19:46] <moritz> but TimToady++ said that in general there's still LTM between the array elements

[19:46] <jnthn> Oh, wait

[19:47] <jnthn> iiuc

[19:47] <moritz> so a | @b | bc   is more like   [a | b] || [|@b]

[19:47] <jnthn> a | @a | bc /

[19:47] <jnthn> er

[19:47] <jnthn>  / a | @a | bc /

[19:47] <jnthn> I don't think it's saying you don't get LTM semantics even if @a isn't known until runtime

[19:47] <jnthn> Notice the "external" bit

[19:48] <jnthn> token x { <y> }; token y { a | @a | bc }

[19:48] <moritz> external = external to the array, in my reading

[19:48] <jnthn> Here, it's not be incorporated into x's LTM

[19:48] <jnthn> Oh, I read it as "external to this rule"

[19:49] <moritz> we've had that discussion recently

[19:49] <jnthn> Hm, it could be either. :)

[19:49] <jnthn> OK

[19:49] <moritz> with pmichaud++ and TimToady++

[19:49] <jnthn> I'm happy for it to be the easier one ;)

[19:49] <moritz> let me try to find it in the logs

[19:49] <jnthn> I musta missed it.

[19:49] <dalek> nqp/toqast: 5c66ca4 | jnthn++ | src/QAST/Operations.nqp:

[19:49] <dalek> nqp/toqast: vivify => ifnull; pmichaud++.

[19:49] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/5c66ca47be

[19:50] *** patspam left
[19:50] <dalek> rakudo/toqast: ecd9c1b | jnthn++ | src/QPerl6/Actions.pm:

[19:50] <dalek> rakudo/toqast: Chase op name change.

[19:50] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/ecd9c1b519

[19:50] <moritz> jnthn: discussion starts at http://irclog.perlgeek.de/perl6/2012-06-28#i_5766030

[19:51] *** patspam joined
[19:51] <jnthn> nmake

[19:51] <jnthn> oops

[19:51] *** patspam left
[19:53] <jnthn> moritz: aha

[19:53] *** patspam joined
[19:53] <jnthn> moritz: Then yes, your interpretation is correct.

[19:54] *** patspam left
[19:55] *** sisar left
[20:04] <masak> I've golfed the segfault from a few days ago.

[20:04] <masak> it might be the strangest I've ever seen. but it's very consistent. lots of components, though.

[20:04] <masak> r: use Test; class A {}; (-> &c, $m { A.new()(); CATCH { default { ok 1, $m } } })(A, "")

[20:05] <p6eval> rakudo 74e183: OUTPUT«(signal SEGV)»

[20:05] * masak submits rakudobug

[20:05] <[Coke]> masak++

[20:05] <masak> feel free to submit shorter versions to the channel if you find any. I will add them to the RT ticket.

[20:06] <gfldex> Segmentation fault (core dumped) # under cygwin

[20:06] <masak> note that A is sent in as &c, and that was the original issue: a non-Callable was invoked.

[20:06] <moritz> r: class A {}; (-> &c, $m { A.new()(); CATCH { default { say $m } } } )(Mu.new, '')

[20:06] <p6eval> rakudo 74e183: OUTPUT«Null PMC access in find_method('gist')␤  in block <anon> at /tmp/aD6vfCqowe:1␤  in block <anon> at /tmp/aD6vfCqowe:1␤␤»

[20:07] <masak> that looks like a clue of some sort.

[20:07] <moritz> masak: but shouldn't it fail to bind in the first place?

[20:07] <moritz> I mean, A to &c

[20:07] <masak> yes.

[20:07] <masak> and maybe it does, I dunno.

[20:07] <moritz> r: sub f(&c) { }; f(class { })

[20:07] <p6eval> rakudo 74e183: OUTPUT«Nominal type check failed for parameter '&c'; expected Callable but got <anon> instead␤  in sub f at /tmp/a0Rp2HjxT2:1␤  in block <anon> at /tmp/a0Rp2HjxT2:1␤␤»

[20:07] <masak> but the A.new()(); these is necessary.

[20:08] <masak> which indicates the first line gets run.

[20:08] <masak> r: use Test; class A {}; (-> &c, $m { CATCH { default { ok 1, $m } } })(A, "")

[20:08] <p6eval> rakudo 74e183: OUTPUT«(signal SEGV)»

[20:08] <masak> I stand corrected. :)

[20:08] <masak> that explains a lot. the CATCH catches binding errors.

[20:08] <masak> and then the $m never gets bound, because the binder wasn't done!

[20:08] <moritz> erm, what?

[20:09] <masak> I couldn't have trolled Rakudo better if I had wanted to! :D

[20:09] <moritz> a CATCH block catches... no way

[20:09] <masak> yes way.

[20:09] <masak> that's what happens.

[20:09] <moritz> I... hope that it's not supposed to catch those.

[20:09] <masak> it's so obvious now.

[20:09] <masak> no, I don't think it is.

[20:09] <moritz> ah, and that's why I got the null PMC access

[20:10] <masak> but I can see why that falls out. I think binding is lexically done inside of the callee.

[20:10] <moritz> r: sub f(&x) { CATCH { default { say "OH NOES" } } }; f 3

[20:10] <p6eval> rakudo 74e183: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'f' will never work with argument types (int) (line 1)␤    Expected: :(&x)␤»

[20:10] <jnthn> Huh, I thought exception handlers weren't set up until after the binding...

[20:10] <moritz> r: sub f(&x) { CATCH { default { say "OH NOES" } } }; f Mu.new

[20:10] <p6eval> rakudo 74e183: OUTPUT«OH NOES␤»

[20:10] <moritz> that's a short version :-)

[20:11] <moritz> masak++

[20:11] <masak> now without the segv :)

[20:11] <moritz> aye

[20:11] <masak> crypt++ # found it while hacking around with real code

[20:11] <moritz> the rest was probably just necessary to turn a Null PMC Access into a segfault, or so

[20:12] <sorear> masak: man 3 crypt?

[20:12] <moritz> sorear: nope, his adventure game

[20:13] <masak> I don't know what I was thinking when naming it...

[20:14] <masak> apparently I wasn't thinking of man 3 crypt. :)

[20:14] <moritz> its setting is a crypt?

[20:14] <masak> the innermost room is a crypt, yes.

[20:14] <masak> you haven't played it yet, moritz? :)

[20:14] *** lichtkind joined
[20:14] <moritz> masak: no

[20:15] <moritz> jnthn: looking at the generate code, it seems it 1) does a capture_lex 2) sets up the exception handler 3) calls perl6_take_dipatcher 4) declares $_, $/, $! and call_sig and 5) calls bind_signature

[20:16] <jnthn> hah

[20:16] <jnthn> Good news: block and exception handlers got a divorce in QAST :)

[20:16] <jnthn> *blocks

[20:17] <moritz>     new $P1043, 'ExceptionHandler'

[20:17] <moritz>     set_label $P1043, control_1042

[20:17] <moritz>     $P1043."handle_types_except"(.CONTROL_ALL)

[20:17] <moritz> I guess the binder does not generate a CONTROL exception

[20:17] <jnthn> Yeah, ain't it f**king wonderful that we have to make a PCC method call to set up an exception handler :/

[20:18] <jnthn> I...don't think they should be control exceptions.

[20:18] <jnthn> Failing to bind is a real exception.

[20:18] <masak> don't swear in an RT ticket! :P

[20:18] * moritz thinks so too

[20:18] <jnthn> It's that the handler shouldn't be set up at that point.

[20:18] <moritz> jnthn: so, that's another GCable just for the call that sets up the exception handler?

[20:18] <jnthn> Yeah

[20:19] <moritz> would it help if i convinced the parrot folks to provide an op that does it instead?

[20:21] <jnthn> It'd probably be more efficient that way but...dunno how interested I am in opening the exceptions in Parrot can of worms.

[20:22] <lichtkind> jnthn: great grant report

[20:22] <lichtkind> does it mean we can have widgets soon?

[20:22] <jnthn> lichtkind: widgets?

[20:23] <jnthn> moritz: Provided there was such an op I guess it'd be easy to update the code gen to use it.

[20:24] <dalek> nqp/toqast: 20331f5 | jnthn++ | src/QRegex/ (2 files):

[20:24] <dalek> nqp/toqast: Add a way to turn an NFA into QAST rather than PAST.

[20:24] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/20331f5451

[20:24] <dalek> nqp/toqast: 0eb3cc4 | jnthn++ | / (3 files):

[20:24] <dalek> nqp/toqast: Add BlockMemo, a way to segregate the hack we use for caps and nfa storage.

[20:24] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/0eb3cc4ed4

[20:24] <dalek> nqp/toqast: ecf6316 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[20:24] <dalek> nqp/toqast: Use QAST::BlockMemo, to hopefully get QRegex::P6Regex::Actions::qbuildsub to be generating valid QAST (though probably still not quite gonna work yet).

[20:24] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/ecf6316051

[20:25] *** bruges_ joined
[20:27] *** bruges left
[20:27] <lichtkind> jnthn: binding to gui tk with callbacks

[20:28] <jnthn> lichtkind: Oh!

[20:28] <jnthn> lichtkind: arnsholt++ is hacking on callbacks at the moment :)

[20:28] <arnsholt> Yeah, I'm kind of hoping to make a GTK demo as a proof of concept/demo

[20:30] <masak> \o/ ++arnsholt

[20:30] <tadzik> \o/

[20:30] <jnthn> That'll be very cool

[20:30] <jnthn> arnsholt: Are you gonna be at YAPC::EU, btw?

[20:31] <arnsholt> Don't think so unfortunately

[20:31] <arnsholt> Fits kind of weirdly with holidays and stuff this year

[20:31] <jnthn> Aww. Was gonna say, if so, maybe submit a Zavolaj talk :)

[20:31] <arnsholt> I've been considering it actually =)

[20:32] <arnsholt> But I've started to look for likely workshops and such this fall, and then I can do one for YAPC::EU next year perhaps

[20:32] <[Coke]> jnthn: parrot seems genuinely interested in doing the right thing by rakudo (re exception can of worms)

[20:33] <masak> it's still a can of worms ;)

[20:33] *** godfrey999 left
[20:34] <lichtkind> maybe you want come to bologna

[20:34] <lichtkind> ipw was fun

[20:36] *** cognominal_ left
[20:36] *** cognominal joined
[20:37] <arnsholt> Hmm. That might work

[20:38] <jnthn> [Coke]: Figuring out the "right thing" is probably not so easy. I'm not even sure how various bits manage to work at the moment. :)

[20:39] <masak> meanwhile, on #postgresql: https://gist.github.com/3107323 ;)

[20:41] *** godfrey999 joined
[20:42] <arnsholt> Oooh, sounds like a good 'un

[20:43] *** plobsing left
[20:43] *** bluescreen10 left
[20:44] <flussence> do they have ir clogs?

[20:45] *** plobsing joined
[20:49] *** bluescreen10 joined
[20:51] *** plobsing left
[20:52] <[Coke]> jnthn: fair enough. as long as you're avoiding it for a *good* reason. ;)

[20:53] *** plobsing joined
[21:04] *** skids left
[21:05] *** atrodo left
[21:11] *** birdwindupbird left
[21:17] <pmichaud> good afternoon, #perl6

[21:18] <jnthn> evenin, Pm o/

[21:18] <[Coke]> phenny: help?

[21:18] <phenny> [Coke]: Hi, I'm a bot. Say ".commands" to me in private for a list of my commands, or see http://inamidst.com/phenny/ for more general details. My owner is sbp.

[21:18] <pmichaud> jnthn: regex { a | @b | @c };    @b and @c participate in ltm only if they're constant at the time the regex is compiled

[21:19] <pmichaud> TimToady++ pointed that out a couple of weeks ago :)

[21:19] <jnthn> pmichaud: Yes, moritz++ pointed me at the conversation :)

[21:19] <pmichaud> good deal.  Yes, that makes arrays a lot easier, although we'll need some dynvars to let us know if a given array is in | or || context

[21:19] <pmichaud> (when the regex is being compiled)

[21:20] <dalek> nqp/toqast: 804bcfa | jnthn++ | src/QAST/ (2 files):

[21:20] <dalek> nqp/toqast: Get some box/unbox infrastructure in place.

[21:20] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/804bcfaca6

[21:20] <dalek> nqp/toqast: bed7038 | jnthn++ | src/HLL/Compiler.pm:

[21:20] <dalek> nqp/toqast: Make sure $*PASTCOMPILER is available (still some regex engine leftovers there...will clear up later.

[21:20] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/bed70380f2

[21:20] <sorear> How can you tell if they are constant?

[21:20] <pmichaud> they have to have been declared constant at compile-time

[21:20] <jnthn> To a first approximation, "do we have a compile time value for it"

[21:21] * [Coke] cannot figure out how to get phenny to respond to help queries.

[21:22] <benabik> phenny: help

[21:22] <phenny> benabik: Hi, I'm a bot. Say ".commands" to me in private for a list of my commands, or see http://inamidst.com/phenny/ for more general details. My owner is sbp.

[21:22] <[Coke]> benabik: and the followup from that results in a suggestion to use help which doesn't work.

[21:23] *** [particle] left
[21:23] <benabik> [Coke]: Oh.  Well, details.

[21:23] *** [particle] joined
[21:24] <masak> lol I again blog here! http://strangelyconsistent.org/blog/july-13-2012-things-which-you-can-read

[21:25] <jnthn> lawl

[21:25] *** bluescreen10 left
[21:25] <flussence> I wonder

[21:25] <flussence> .help

[21:26] *** spider-mario left
[21:26] <flussence> hm, maybe it's disabled to avoid spamming the channel.

[21:26] *** spider-mario joined
[21:27] <benabik> Also don't work in PM

[21:31] <lichtkind> ahhh due my intense weeks of writing tablets my fingers learned to write gi instead of hg

[21:31] *** nodmonkey left
[21:33] <dalek> nqp/toqast: dd04942 | jnthn++ | src/QAST/ (2 files):

[21:33] <dalek> nqp/toqast: Fix some bugs in BlockMemo handling.

[21:33] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/dd04942b3f

[21:33] <dalek> rakudo/toqast: 4498bea | jnthn++ | src/QPerl6/Actions.pm:

[21:33] <dalek> rakudo/toqast: Start using qbuildsub for regex building.

[21:33] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/4498bea438

[21:36] *** godfrey999 left
[21:36] <jnthn> rakudo/toqast now has some regex support back in place. Up to 12804 passing spectests.

[21:36] <jnthn> And all sanity tests pass.

[21:37] <masak> whoa.

[21:37] <masak> jnthn++

[21:38] *** thou left
[21:39] *** bluescreen10 joined
[21:40] *** plobsing left
[21:42] *** plobsing joined
[21:56] <lichtkind> jnthn++

[21:58] *** samlt left
[21:58] *** samlt joined
[22:02] *** spider-mario left
[22:04] *** samlt left
[22:04] *** samlt joined
[22:05] *** MayDaniel left
[22:12] *** [particle] left
[22:15] <dalek> nqp/toqast: 014837a | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[22:15] <dalek> nqp/toqast: Fix qalt_nfas to recurse to itself.

[22:15] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/014837a4a8

[22:15] <dalek> nqp/toqast: cd6dfc3 | jnthn++ | src/QAST/Block.nqp:

[22:15] <dalek> nqp/toqast: Implement QAST::Block.symtable.

[22:15] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/cd6dfc3072

[22:18] *** snearch left
[22:19] <dalek> rakudo/toqast: 266d7b6 | jnthn++ | src/QPerl6/Ops.pm:

[22:19] <dalek> rakudo/toqast: First crack at box/unbox wiring. Wins some more tests at least.

[22:19] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/266d7b66b5

[22:19] <dalek> rakudo/toqast: 101c115 | jnthn++ | src/QPerl6/Actions.pm:

[22:19] <dalek> rakudo/toqast: Fix subset compilation.

[22:19] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/101c1156fd

[22:19] <dalek> rakudo/toqast: 9edea62 | jnthn++ | src/QPerl6/World.pm:

[22:19] <dalek> rakudo/toqast: Fix BEGIN time and thus roles.

[22:19] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/9edea62622

[22:22] *** cognominal_ joined
[22:24] *** cognominal left
[22:32] *** Coleoid joined
[22:32] *** seldon left
[22:37] *** skids joined
[22:41] <masak> good night, #perl6

[22:55] *** PacoAir joined
[22:56] *** cognominal__ joined
[22:57] *** cognominal_ left
[23:04] *** cognominal_ joined
[23:07] *** cognominal__ left
[23:08] *** benabik left
[23:12] *** benabik joined
[23:20] *** icwiener_ joined
[23:20] <dalek> nqp/toqast: 03261ac | jnthn++ | src/QAST/Compiler.nqp:

[23:20] <dalek> nqp/toqast: Add qastnode, for an abitrary QAST tree inside a QAST::Regex.

[23:20] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/03261ac258

[23:20] <dalek> nqp/toqast: f574160 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[23:20] <dalek> nqp/toqast: Various regex related tweaks to help QAST'd Rakudo work.

[23:20] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/f57416063b

[23:21] <dalek> rakudo/toqast: 94bb03f | jnthn++ | src/QPerl6/Actions.pm:

[23:21] <dalek> rakudo/toqast: Fix quotepair.

[23:21] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/94bb03f33c

[23:21] <dalek> rakudo/toqast: 08c051a | jnthn++ | src/QPerl6/Actions.pm:

[23:21] <dalek> rakudo/toqast: s/pastnode/qastnode/ in regex handling.

[23:21] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/08c051ab73

[23:21] <dalek> rakudo/toqast: 613d647 | jnthn++ | src/QPerl6/Actions.pm:

[23:21] <dalek> rakudo/toqast: Various regex fixes; gets a bunch of S05 tests passing again.

[23:21] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/613d6474c3

[23:23] * geekosaur 's brain keeps edit correcting that to "toast"

[23:24] *** icwiener left
[23:25] *** lichtkind left
[23:35] <dalek> rakudo/toqast: f97e527 | jnthn++ | src/QPerl6/Actions.pm:

[23:35] <dalek> rakudo/toqast: Fix @bar>>.foo compilation.

[23:35] <dalek> rakudo/toqast: review: https://github.com/rakudo/rakudo/commit/f97e527f44

[23:35] *** PacoAir left
[23:35] <jnthn> Enough for today. Now up to 14997. :)

[23:36] <cognominal_> nqp: my $a := :a<b>; say ($a)

[23:36] <p6eval> nqp: OUTPUT«Confused at line 2, near "say ($a)"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22385 (src/stage2/gen/NQPHLL.pir:8546) (src/stage2/gen/NQPHLL.pm:326)␤»

[23:36] <cognominal_> nqp: my $a := :a<b>; say($a)

[23:36] <p6eval> nqp: OUTPUT«b␤»

[23:36] *** fgomez joined
[23:36] <cognominal_> nqp: my $a := a => 'b' ; say($a)

[23:36] <p6eval> nqp: OUTPUT«b␤»

[23:37] <cognominal_> nqp: my $a := :a('b') ; say($a)

[23:37] <p6eval> nqp: OUTPUT«b␤»

[23:37] <cognominal_> hum.

[23:41] *** vlixes joined
[23:43] <flussence> I wish I knew enough to figure out that build error :(

[23:54] *** crab2313 left
[23:55] <flussence> uh oh

[23:55] <flussence> I checked out nqp/toqast and reverted 80306ff, and it still failed with the same error

[23:57] <flussence> maybe it was some internal resource limit, and that was what initially pushed it over the edge...

