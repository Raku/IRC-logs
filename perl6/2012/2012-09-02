[00:00] *** replore joined
[00:18] *** fgomez joined
[00:20] *** replore left
[00:28] *** silug left
[00:29] *** spider-mario left
[00:47] *** replore joined
[00:47] *** replore left
[00:57] *** mucker left
[01:04] *** cognominal left
[01:04] *** cognominal joined
[01:06] <MikeFair> I have a rule stat_or_block { <block> | <statement> }  -- I've been using say messages to watch as it's being parsed. What I've noticed is the <statement> part of the rule never seems to get tested

[01:06] <MikeFair> any ideas?

[01:08] <TimToady> whitespace messing up LTM maybe

[01:08] <MikeFair> LTM?

[01:08] <TimToady> longest token matching

[01:08] <MikeFair> Well I'm getting a "can't parse" failure

[01:08] *** replore_ joined
[01:08] *** replore_ left
[01:08] <MikeFair> so clearly the <block> is failing

[01:09] <MikeFair> Would whitespace cause the <statement> not to be evaluated?

[01:09] <TimToady> I can't vouch for rakudo's parser in that regard

[01:10] <TimToady> but | should be a parallel LTM-ish match, not sequential like ||

[01:10] <MikeFair> I've seen references to a Grammar Tracer thing of some kind, is there something like that I can use in Parrot's Compiler Toolkit

[01:10] <TimToady> oh, what are you using to parse?

[01:10] <MikeFair> TimToady: oh sorry about that, I'm using parrot

[01:10] <TimToady> I have even less to say about parrot

[01:10] <TimToady> that almost certainly does not do LTM correctly

[01:11] *** benabik left
[01:11] <MikeFair> if 1 then say 1

[01:12] <MikeFair> So where can I read up on how the LTM is getting created?

[01:13] <MikeFair> It's going through all the various <block> matches, then just giving up

[01:13] <TimToady> parrot doesn't do LTM

[01:14] <TimToady> I only know how Perl 6 works (or is supposed to (or I'm supposed to))

[01:14] * MikeFair nods.

[01:14] <MikeFair> Well Parrot is using NQP 

[01:15] <MikeFair> Grammar rules

[01:15] <MikeFair> At least that's the part I'm using

[01:15] <MikeFair> atm

[01:16] <MikeFair> if I reserve the order of them and do <statement> | <block> I get a different error :)

[01:16] <MikeFair> (the one I'm expecting)

[01:18] *** benabik joined
[01:18] <MikeFair> I'm off for a bit!

[01:18] <MikeFair> bbl

[01:18] <MikeFair> TimToady: thx!

[01:20] * TimToady was in a funny jetlag state earlier today--could program, but couldn't backlog...

[01:20] * TimToady tries again to backlog

[01:26] *** _jaldhar left
[01:29] *** replore joined
[01:30] *** replore left
[01:35] *** _jaldhar joined
[01:41] *** benabik left
[01:42] *** benabik joined
[01:53] *** FROGGS_ left
[01:55] *** dju left
[02:00] *** jeffreykegler joined
[02:00] *** dju joined
[02:01] <jeffreykegler> I have a question about semantics in grammar rules

[02:02] <jeffreykegler> S05 says you set the AST element via make

[02:02] <jeffreykegler> But looking at STD.pm, it seems to be almost never used

[02:03] <jeffreykegler> I'm thinking in terms fo the traditional parse tree semantics -- you know, parent takes child as arguments ....

[02:03] <jeffreykegler> and passes result up to its own parent ...

[02:03] <benabik> STD.pm doesn't really generate an AST, just a parse tree.

[02:04] <benabik> (IIRC)

[02:04] <jeffreykegler> In other words, I'm looking for the semantics in the wrong place?  It's not in STD.pm

[02:05] <TimToady> it does generate an ast, but its action routines are written in Perl 5 (in viv), so it just emulates make, without using that feature of Perl 6 directly

[02:05] <jeffreykegler> OK

[02:05] <TimToady> and I believe that niecza just uses the match tree directly

[02:05] <TimToady> despite being STD-based

[02:05] <jeffreykegler> I'm trying to imitate Perl 6 for the semantics of "Sixish", a Perl 6-like Marpa interface

[02:06] <jeffreykegler> How might I say that the semantics are in routine &do_x()?

[02:06] <TimToady> STD is in kind of a funny place, because it's trying not to commit to any particlar AST representation

[02:06] <jeffreykegler> <&do_x()>   ?

[02:07] *** FROGGS_ joined
[02:07] *** xdbr left
[02:07] <TimToady> STD uses an Action package that dispatches to the same name as the rule that is being reduced

[02:07] <jeffreykegler> Which explains why my study of STD.pm from the semantics point of view was so frustrating

[02:07] <jeffreykegler> TimToady: Aha!

[02:08] <TimToady> which actually doesn't scale terribly well to derived grammars...

[02:08] <jeffreykegler> So the semantics is by rule name, and is elsewhere

[02:08] <TimToady> we'd need to derive Action modules in parallel with the languages, but we don't try to

[02:09] <TimToady> or somehow derived grammars need to give their rules a derived identity

[02:09] <jeffreykegler> So right now, semantics is separate from grammar and the connection is made by rule name

[02:09] <TimToady> yes

[02:10] <TimToady> though, in fact, derived grammars are represented in P5-land with nested packages, so the info is kinda there

[02:11] <jeffreykegler> I'm kind of torn -- semantics often looks cool right next to the rule, but ...

[02:11] <jeffreykegler> it does clutter, and it's not clear which is nicest

[02:11] <TimToady> it tends to prevent the grammar from being re-used for other purposes though

[02:11] <ingy> seen mberends

[02:11] <aloha> mberends was last seen in #perl6 18 days 1 hours ago joining the channel.

[02:12] <jeffreykegler> I take it's your opinion that as a general matter, it is best to separate the two

[02:12] *** replore_ joined
[02:12] <TimToady> for the STD5 grammar (a Perl 5 grammar I've been working on), it's partially derived from STD, and it seems to have worked out okayish

[02:13] <TimToady> albeit with a bit of copy/paste for some rules

[02:13] <TimToady> the spec intends 'make' to be useful from within the rules, though rakudo at one point interpreted it as only in action rules; dunno if that's still the case

[02:14] <TimToady> so as usual we try to have it both ways

[02:14] <TimToady> at the expense of not having AST building be the default in the main grammar

[02:14] <TimToady> since we want to degrade gracefully to simple match trees

[02:15] <TimToady> if you have any ideas for how to make that transition more gracefully, I'm all ears

[02:15] <jeffreykegler> So I could just express the semantics via rule name and :dba

[02:16] <TimToady> well, :dba is primarily for error messages

[02:16] <TimToady> I seem to recall some other use once, but it has slipped my mind what the details were

[02:16] <jeffreykegler> Is there a more appropriate way of aliasing for semantic purposes than :dba ?

[02:16] <TimToady> or whether we still use :dba for something else

[02:17] *** replore_ left
[02:18] <jeffreykegler> TimToady: Re the transition, I don't think I'd have any useful ideas

[02:19] <jeffreykegler> As my questions indicate, I'm trying to learn to feel my way through this area

[02:19] <TimToady> :dba is primarily intended to be enlightening to the recipient of the error message; dunno whether that's compatible with semantic markup that is interesting to the writer

[02:19] <TimToady> well, all of us are still trying to learn our way through this :)

[02:20] <diakopter> (some several times over)

[02:20] <MikeFair> TimToady: What's the transition you're thinking of?

[02:20] <TimToady> erasing the boundary between regex and grammar

[02:21] <TimToady> we've made that fairly seemless on the parsing end of things, but it's a bit clunky to add in an AST still

[02:21] <jeffreykegler> OK.  I won't use :dba, because I don't want to have the Sixish syntax have jarring differences with that of Perl 6

[02:21] <jeffreykegler> Perhaps I might as well make up my own adverb, such as :action("action

[02:21] <TimToady> the colonpair notation is meant to be an extension mechanism in any case, so you can make up your own

[02:22] <MikeFair> TimToady: I'm working on building up to establishing the AST as a service and using zmq's zero-copy mechanisms as a sort of in process SOA 

[02:23] *** orafu left
[02:23] *** orafu joined
[02:23] <MikeFair> TimToady: I don't know if it will work, but mentally it makes me completely abstract the the concepts of Grammar and semantics

[02:24] <TimToady> well, certainly there are aspects of it that may be amenable to inversion of control

[02:24] <MikeFair> TimToady: Eventually it will give me an execution pipeline 'Grammar parser thread' <-> 'AST'/language binging <-> Execution module

[02:24] <sorear> TimToady: niecza uses "make" heavily in the action package

[02:24] <TimToady> but as usual it comes down to a question of identity

[02:25] <MikeFair> TimToady: SQL in postgres has the same sort of idea, the postgres engine specifically executes a query plan, which is the same thing as AST like thing

[02:25] <MikeFair> So there's clearly a pattern

[02:26] <TimToady> mostly I just try to get this stuff close enough that smarter people can take it in various directions :)

[02:27] <MikeFair> TimToady: identity how? I think of it like a web session, where the AST side of things will track a cookie for each "Grammar" socket/client

[02:28] <MikeFair> TimToady: Every time a particular client (a Grammar parser) makes an API call, the "current context" of that call will be known

[02:29] <MikeFair> At least I've failed in every attempt to explain to myself why it's not a good idea, and ZMQ will make the network part pretty simple

[02:30] <TimToady> there are usually several kinds of context floating around, and it's not always trivial to know which parts contribute to a given entity's uniqueness

[02:31] <TimToady> (that's Tagmemics 101, basically)

[02:32] <MikeFair> TimToady: Another approach I was considering was registering named sockets, which we can also do.  

[02:32] *** Circlepuller_ joined
[02:32] <MikeFair> ack -- interuptted

[02:32] <MikeFair> bl

[02:32] <MikeFair> bbl

[02:33] <TimToady> linguistically speaking, that's the whole etic vs emic distinction; which features contribute to identity, and which are merely epiphenominal in this current language

[02:34] *** replore_ joined
[02:34] *** Circlepuller left
[02:34] <jeffreykegler> TimToady: I went off & tried to look up "colonpair" notation

[02:35] <jeffreykegler> I'm not really sure what you meant

[02:35] <diakopter> the replacement for the fat arrow pair

[02:35] <diakopter> :key(value)

[02:36] <jeffreykegler> diakopter: why "colonpair"?  there's just one colon :-)

[02:36] <TimToady> see S02:Adverbial_Pair_forms

[02:36] <jeffreykegler> TimToady: Thanks, will do

[02:36] <diakopter> the colon introduces the pair

[02:37] <TimToady> and a colon is a pair of dots :)

[02:37] <jeffreykegler> TimToady, diakopter: OK, sure :-)

[02:38] *** replore_ left
[02:45] *** tokuhiro_ left
[02:50] *** replore joined
[02:53] * diakopter watched the first episode of the new documentary on the life of the conjoined twins who share a whole body. they had a documentary when they were 16; now they are 22

[02:54] <diakopter> it ... boggles the mind, continously.

[02:56] <diakopter> somehow they both control most of the body; the head on the right controls the arm on the right and the head on the left controls the arm on the left. it showed them dribbling a basketball back and forth between hands, *without*looking*

[02:59] <diakopter> sorry for the OT. http://tlc.howstuffworks.com/tv/abby-and-brittany/videos

[03:05] *** erkan left
[03:06] *** popl left
[03:09] *** jeffreykegler left
[03:12] *** erkan joined
[03:12] *** erkan left
[03:12] *** erkan joined
[03:15] *** immortal joined
[03:15] *** immortal left
[03:15] *** immortal joined
[03:15] *** erkan left
[03:19] *** replore left
[03:23] *** replore joined
[03:47] *** replore left
[04:38] <MikeFair> TimToady: Still about?

[04:42] <MikeFair> If I'm understanding the emic and etic descriptions right then emic => class and etic=> interface that class implements

[04:42] <MikeFair> It's also really well described by the Entity Framework pattern that real time video games have come up with

[04:43] *** kaare_ joined
[04:44] <MikeFair> They break their framework into multiple "Systems" (which I think of as the verticals dimension), and orthoganal to the "Systems" are "Entities" (which I consider the horizontal dimension)

[04:45] *** telex left
[04:46] <MikeFair> There's on other piece I can't recall the name of which is basically the equivalent to an "Interfaces"/"Types"/"Class" like thing

[04:46] <MikeFair> An entity is a specific instance of an object that binds together a specific set of Interfaces which the "Systems" require from the Entity in order to perform their work

[04:48] <MikeFair> An "Entity" instance might actually have bits and pieces of itself stored all over the place in each of the various "Systems"  because it's the Systems that know how to keep track and operate on the Entities values

[04:49] <MikeFair> If two "Systems" are operating on the same value they can synchronize information via the instances given Entity ID

[04:50] <MikeFair> It's really easy to see how this works in a complex 3D game like system because each "Entity" really has many domains of data, for instance, the sound track / sounds the object makes have almost nothing to do with the visuals

[04:51] <MikeFair> Just like the visuals have almost nothing to with say the entities AI algorithm

[04:52] <MikeFair> But all three of those systems have to share the "Point in 3D space" information about the same object

[04:56] *** telex joined
[04:58] <MikeFair> So the theory I have for the programming I want to put into the langauge I'm working on fits really nicely with all these ideas because I'm working on treating the "threads" of a program as part of a distributed system

[05:00] <MikeFair> So that gives my execution model.  Each class is a separate thread that keeps track of the properties for instances of its objects

[05:00] <MikeFair> (a factory)

[05:00] <MikeFair> but also a worker

[05:02] <MikeFair> Now these of these "vertical" threads can be chained together "horizontally" via message queues (using libzmq)

[05:03] <MikeFair> Now when I say "thread" I say it because it creates the right image for separation, but likely it won't be implemented that way (at least not until I move it onto the GPU :) )

[05:05] <MikeFair> Now since I want to allow anyone to be able to program for this system, rather than making them learn a new language for this system, I'm planning on using native language-like syntax

[05:07] *** telex left
[05:08] <MikeFair> The first language is English, implementing/copying the constructs from the xTalk family of languages (like hyperCard/SuperCard and others)

[05:09] <MikeFair> because they've been at this for so long, they've got some really good ideas/cheats/experience in what it's like to use the english language to  do this

[05:09] <MikeFair> They don't try and be extensible with the language though and that's where Perl6 can make all the difference

[05:09] <MikeFair> Perl6 is basically all the semantics of xTalk, with none of the syntax

[05:10] <MikeFair> (Well Perl6 is missing a couple, like messagePath for instance, but that can be added)

[05:10] *** telex joined
[05:11] <MikeFair> TimToady: So that's it - that's why I'm here, and why I'm really keen on making sure the Grammar/Actions present a really clean abstraction layer, so that other native languages can be ported

[05:13] <MikeFair> TimToady: So summing all that up into a simple recommendation of how to go about simplifying/cleaning up the separation, imagine there's a programming language that has a structured, well defined, english-like almost natural syntax

[05:13] <MikeFair> What can be described in English, can also be described in other native languages, at least for the purposes of programming

[05:14] <MikeFair> So the framework/API needs to be such that a small set of contirbutors can "localize" the syntax of the language into their native tongue

[05:15] <MikeFair> Wash/Rinse/Repeat for other DSLs (like SQL)

[05:18] <moritz> good morning *

[05:19] <MikeFair> TimToady: I didn't recognize that this was really that import and core design goal for Perl6 so I'm glad you said something about it, otherwise i'd just have kept quite. Thanks

[05:19] <MikeFair> moritz: Hey there!  Good morning

[05:21] <MikeFair> like my little tirade?

[05:23] <moritz> I haven#t backlogged yet

[05:24] <MikeFair> ahh :)

[05:33] *** isBEKaml joined
[05:34] <isBEKaml> OHHAI, pugs-compat cabal build with GHC 7.4.1 shows failure. Seems to depend on haskell98 but is unable to locate it. https://gist.github.com/3595096

[05:45] *** drbean joined
[06:04] <isBEKaml> slow day today. =)

[06:05] <sorear> huh.  I *just* received the 2012.08 p6l announce

[06:05] <isBEKaml> For anyone that's interested in my Pugs issue, it was due to incompatibilities between base and haskell98 packages. I think the way to fix this would be to migrate code using IO module to using System.IO module. 

[06:05] <sorear> I got two copies of it on the day of

[06:05] <isBEKaml> (that's in pugs-compat)

[06:05] <isBEKaml> hello, sorear

[06:06] <sorear> hello, isBEKaml.

[06:07] <isBEKaml> how's things with niecza?

[06:14] <sorear> (were you at yapc::eu?)

[06:15] <isBEKaml> No, I have never been outside country. :)

[06:15] <sorear> niecza is losing -Ofun for me, so I'm probably not going to be doing too much with it; my Perl 6 involvement in the future is likely to be with the Rakudo/NQP porting efforts

[06:15] <sorear> I have this idea that you're German

[06:15] <sorear> oh, mumbai

[06:15] *** fgomez left
[06:15] *** fgomez joined
[06:16] <isBEKaml> Oh, I'm sad to see that - I have been trying to follow niecza with some interest (time permitting)

[06:16] <isBEKaml> Yes, I'm from India

[06:16] *** PZt left
[06:17] <isBEKaml> I think changing direction towards Rakudo/NQP to CLR environment won't hurt anything. 

[06:17] <isBEKaml> That's an equally worthy goal

[06:17] <sorear> niecza is really feeling the pain of some design decisions I made in early 2011

[06:18] <moritz> fwiw rakudo has had several such pain points too

[06:18] <moritz> which lead to some of the famous rewrites

[06:18] <isBEKaml> Like ? From what I have seen, no project every goes smoothly without any rewrites.

[06:19] <isBEKaml> s/every/every/

[06:19] <isBEKaml> gah, ever! (muscle memory, sorry)

[06:20] <sorear> i've been on IRC for 7 years, I'm pretty good at reading mangled text

[06:20] <isBEKaml> hello, moritz

[06:20] <FROGGS_> morning

[06:20] <sorear> hello FROGGS_.  also, moritz

[06:20] <isBEKaml> o/ FROGGS_ 

[06:20] <moritz> \o

[06:21] <moritz> n: constant name = 'a'; sub ::(name) { 42 }; say a()

[06:21] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«42␤»

[06:21] <sorear> n: BEGIN my $name = 'a'; sub ::($name) { 42 }; say a()

[06:21] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«42␤»

[06:25] <FROGGS_> do I have to wrap them with a sub? can't I import a constant directly from a module?

[06:26] <sorear> importing constants from modules is allowed by spec

[06:26] <sorear> you may be hitting a bug

[06:29] <moritz> the two are mostly unrelated

[06:32] <dalek> roast: eb6e664 | moritz++ | S02-names/indirect.t:

[06:32] <dalek> roast: basic test for declarations with indirect names

[06:32] <dalek> roast: review: https://github.com/perl6/roast/commit/eb6e664976

[06:33] *** PZt joined
[06:37] <dalek> rakudo/nom: 1f86d22 | moritz++ | t/spectest.data:

[06:37] <dalek> rakudo/nom: run indirect name declaration tests

[06:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f86d2279d

[06:39] <dalek> std: 36c6322 | larry++ | / (2 files):

[06:39] <dalek> std: parse <<END with correct quote language

[06:39] <dalek> std: review: https://github.com/perl6/std/commit/36c6322ed5

[06:44] *** marmay joined
[06:46] *** krunen left
[06:50] *** krunen joined
[06:51] *** PZt left
[06:52] *** PZt joined
[07:01] <dalek> std: 2f65afc | larry++ | STD_P5.pm6:

[07:01] <dalek> std: allow p5 code to switch back to p6

[07:01] <dalek> std: review: https://github.com/perl6/std/commit/2f65afc62d

[07:08] *** thou left
[07:08] *** immortal left
[07:10] *** thou joined
[07:10] *** erkan joined
[07:10] *** erkan left
[07:10] *** erkan joined
[07:12] *** isBEKaml left
[07:15] <ingy> what's the p6rules syntax for committing to a rule?

[07:15] *** isBEKaml joined
[07:22] *** replore_ joined
[07:22] <ingy> :: looks promising

[07:23] <sorear> :::

[07:24] <sorear> wait, what exactly do you want?

[07:24] <sorear> ::: commits all choice points in the current rule

[07:24] <sorear> :: commits all choice points up to and including the last |

[07:25] *** mucker joined
[07:27] <ingy> sorear: I'm really just looking for a syntax token for Pegex to say, don't back up

[07:27] <ingy> it's nice when it roughly follows p6

[07:28] *** isBEKaml left
[07:29] <sorear> ingy: if the stuff after the token fails to match, how far back should pegex skip?

[07:31] <ingy> sorear: I'm thinking it should fail at that point

[07:32] *** replore_ left
[07:33] <sorear> ingy: fail the rule? (:::) fail the entire matching process? (<commit>)

[07:33] *** SamuraiJack joined
[07:33] <sorear> we don't like <commit> very much here because you can't recover from it

[07:35] *** GlitchMr joined
[07:36] <ingy> sorear: I'm trying to get the error handling more elegant. I don't really have enough test cases yet, though.

[07:38] <ingy> a: b | c | `error msg for rule a`

[07:38] <ingy> same as

[07:38] <ingy> a: b | c | ERR_a; ERR_A: `error msg for rule a`

[07:39] <ingy> it might be nice to have implicit calls to ERR_a

[07:40] <ingy> anyway just ruminating and wondering what p6 did...

[07:42] <sorear> so, you haven't clarified how far you want the commit to fail to

[07:42] <sorear> there's also <commit('RULE_NAME')> in p6, which does what it sounds like

[07:43] <ingy> I guess I don't grok why I wouldn't want to fail completley

[07:48] <ingy> reading through the relevant s05

[07:51] <sorear> ingy: If you fail completely there is no chance for error recovery.

[07:53] <ingy> understood

[08:02] <masak> morning, #perl6

[08:05] <ingy> sorear: I'm leaning towards:

[08:05] <ingy> a: b :: c

[08:05] <ingy> means 

[08:06] <ingy> a: b ( c | ERROR_a )

[08:06] <ingy> so :: is a nice syntax that effectively means <commit>

[08:07] <masak> GlitchMr: for looping backwards along a range, I'd really recommend doing `for reverse ^.chars` or equivalent.

[08:07] <ingy> but I don't really need anything except to make grammars more succinct, afaik

[08:07] <masak> GlitchMr: it's very readable. and it circumvents the "limitation" that ranges have of not going backwards. maybe in the future it'll be a very optimized case too, who knows?

[08:07] <ingy> hi masak 

[08:08] <GlitchMr> The problem is that 0 shouldn't be in range

[08:08] <GlitchMr> So, I'm using .chars ... 1

[08:09] *** thou left
[08:10] *** birdwindupbird joined
[08:12] <masak> GlitchMr: then, `reverse 1 .. .chars`

[08:12] <GlitchMr> But what's wrong with ...

[08:12] <GlitchMr> (aside of that it's sequence operator?)

[08:12] <masak> nothing wrong with it. it just doesn't follow the Principle of Least Power in this case.

[08:13] <masak> nothing wrong with it being the sequence operator either. that's what it is.

[08:13] <GlitchMr> With two arguments, it's a range

[08:14] <masak> no, it's still a sequence of items.

[08:14] <masak> a Range is a type in the type system.

[08:14] <masak> r: say (1..5).^name; say (1 ... 5).^name

[08:14] <p6eval> rakudo 1f86d2: OUTPUT«Range␤List␤»

[08:14] <masak> a Range is *one* item. the List consists of five items.

[08:15] <GlitchMr> Hmmm, yeah

[08:16] <masak> as long as you have a Range, it's in an unexpanded state, and only contains information about its endpoints.

[08:16] <masak> which is why this is a very cheap operation:

[08:16] <masak> r: say (0 .. 1_000_000_000).perl

[08:16] <p6eval> rakudo 1f86d2: OUTPUT«0..1000000000␤»

[08:17] <GlitchMr> reverse doesn't really seem clear... but range(1, 11, -1) in Python doesn't either

[08:17] <masak> and that's why I said 'reverse $min..$max' may some day be optimized. because the elements still haven't expanded.

[08:17] <masak> what's not clear about 'reverse 1..5'?

[08:17] <masak> I think it reads extremely well.

[08:17] <GlitchMr> That end point is star point?

[08:18] <masak> right. because it was reversed.

[08:18] <GlitchMr> start*

[08:19] *** birdwindupbird left
[08:20] <masak> it doesn't seem that unclear to me. at least, no more unclear than `abs -5`, which removes the minus sign and produces +5.

[08:20] <GlitchMr> But why somebody would use abs with constant value?

[08:23] *** Patterner left
[08:23] <masak> this one was just an example. the example still holds if you put a variable there: `abs $v`.

[08:23] <masak> if you know the semantics of &abs, you know that the result will be a positive value.

[08:24] <masak> if you know the semantics of &reverse, you know that the result will be a reversed list of values.

[08:24] *** Psyche^ joined
[08:25] *** Psyche^ is now known as Patterner

[08:25] <GlitchMr> Well, at least it's more explicit than similar operator in CoffeeScript which makes unoptimized code...

[08:26] <GlitchMr> 'for i in [$_.length .. 1]' generates 'for (i = _i = _ref = $_.length; _ref <= 1 ? _i <= 1 : _i >= 1; i = _ref <= 1 ? ++_i : --_i) {}'

[08:26] <huf> their range operator goes both up and down? /o\

[08:27] <masak> I'm glad I'm not using a language where the range operator can go downwards... :/

[08:28] <GlitchMr> The problem being that you don't know when it will go down

[08:28] <huf> for it to be useful, the range operator must be able to return empty lists

[08:28] <huf> or empty ranges

[08:28] <huf> or empty somethings

[08:28] <GlitchMr> If $_.length is smaller than 1 (let's say that string is empty), it iterates for 0 and 1

[08:28] <GlitchMr> Not really useful

[08:29] <GlitchMr> And probably good reason why I should use reverse instead

[08:29] <masak> yes.

[08:30] <masak> GlitchMr: because of -- exactly -- what huf just said.

[08:31] <GlitchMr> I just have noticed this after I've ran similar code in CoffeeScript

[08:32] <huf> php's range() function is broken like that too... webby languages :)

[08:33] <GlitchMr> Not only that, range() in PHP isn't iterator ;)

[08:33] <GlitchMr> But...

[08:33] <huf> there's that too, but that's an optimization in a sense

[08:34] <GlitchMr> And being explicit with $step doesn't help. $step always uses abs() on itself

[08:34] <GlitchMr> That could be fun

[08:35] <GlitchMr> In Python, if you want to have reverse range, you have to specify $step of -1

[08:35] <GlitchMr> step*

[08:36] <GlitchMr> https://gist.github.com/3595918

[08:36] <GlitchMr> panda not found

[08:36] <GlitchMr> That could be fun

[08:40] *** replore joined
[08:44] <GlitchMr> Also, I think I forgot about this, but in CoffeeScript you CAN be explicit.

[08:44] <MikeFair> Is "the name of my function" available as a perl6 variable somehow?

[08:44] <GlitchMr> 'for i in [$_.length .. 1] by -1' generates 'for (i = _i = _ref = $_.length; _i >= 1; i = _i += -1) {}'

[08:44] <masak> we used to have the :by adverb for ranges (in the spec). it got tossed by the wayside for philosophical reasons.

[08:45] <masak> basically, where we had :by previously, we now have infix:<...>

[08:45] <masak> (though I still prefer to reverse ranges in the :by(-1) case)

[08:46] <GlitchMr> MikeFair: I guess no (but I'm not sure) - function could have multiple names or it could be nameless

[08:47] <GlitchMr> But you can reference to current subroutine using &?ROUTINE

[08:47] *** replore left
[08:47] <MikeFair> Hmm, that's a start

[08:48] <sorear> sleep&

[08:48] <GlitchMr> oh, wait, you can

[08:48] <GlitchMr> perl6: sub abc { &?ROUTINE.name }; print "<{abc}>"

[08:48] <p6eval> rakudo 1f86d2, niecza v21-1-ga8aa70b: OUTPUT«<abc>»

[08:48] <GlitchMr> But I wouldn't depend on this

[08:50] *** replore joined
[08:50] <masak> why not?

[08:51] <GlitchMr> What is .name for anyways?

[08:52] <GlitchMr> perl6: my &subroutine = do { my sub this-is-not-a-subroutine { } }; say &subroutine.name;

[08:52] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«Potential difficulties:␤  &this-is-not-a-subroutine is declared but not used at /tmp/STSNbvHIN_ line 1:␤------>  = do { my sub this-is-not-a-subroutine ⏏{ } }; say &subroutine.name;␤␤this-is-not-a-subroutine␤»

[08:52] <p6eval> ..rakudo 1f86d2: OUTPUT«this-is-not-a-subroutine␤»

[08:53] <GlitchMr> It returns 'this-is-not-a-subroutine' even if you cannot call sub {} with this name

[08:54] <GlitchMr> When you have first-class functions, even if you can get name, it won't help you much

[08:56] <GlitchMr> Is there any good reason to have .name aside of "other languages have it?"

[09:00] <arnsholt> Because sometimes, you do need it

[09:02] *** birdwindupbird joined
[09:03] *** MayDaniel joined
[09:04] <GlitchMr> It simply doesn't work in anything more complex than PHP.

[09:04] <GlitchMr> (in PHP, function references are function names)

[09:06] <huf> doesnt work for what?

[09:06] <huf> (also, not entirely true for php)

[09:06] <GlitchMr> I know, PHP has closures since PHP 5.3

[09:08] *** replore left
[09:09] <GlitchMr> perl6: (1 .. 5).map(&sin).perl.say

[09:09] <p6eval> rakudo 1f86d2: OUTPUT«This type cannot unbox to a native integer␤  in method reify at src/gen/CORE.setting:5187␤  in method reify at src/gen/CORE.setting:5089␤  in method gimme at src/gen/CORE.setting:5467␤  in method perl at src/gen/CORE.setting:5687␤  in block  at /tmp/XC4UqGsuB7:1␤␤»…

[09:09] <p6eval> ..niecza v21-1-ga8aa70b: OUTPUT«(0.8414709848078965e0, 0.90929742682568171e0, 0.14112000805986721e0, -0.7568024953079282e0, -0.95892427466313845e0).list␤»

[09:09] <GlitchMr> Another Rakudo bug?

[09:10] *** birdwindupbird left
[09:15] <moritz> looks like it, yes

[09:16] <moritz> nr: say &sin.arity

[09:16] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«1␤»

[09:16] <p6eval> ..rakudo 1f86d2: OUTPUT«0␤»

[09:16] <moritz> nr: say &sin.count

[09:16] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«1␤»

[09:16] <p6eval> ..rakudo 1f86d2: OUTPUT«Inf␤»

[09:16] <moritz> oh.

[09:17] <GlitchMr> Why &sin doesn't have arity?

[09:17] <moritz> cause it's declared as   proto sub sin(|) {*}  in rakudo

[09:18] <moritz> which is the most extensible thing to do

[09:18] <GlitchMr> Numeric multi method sin ( Numeric  $x ) is export

[09:18] <GlitchMr> This is in synopsis

[09:19] <moritz> and wrong

[09:19] <GlitchMr> It should be Cool, isn't it?

[09:19] <GlitchMr> This is so confusing

[09:21] *** kaare_ left
[09:26] *** marmay left
[09:27] <moritz> that would declare a method with the invocant plus another argument

[09:27] <moritz> and yes, there should be a Cool variant too

[09:32] *** tokuhiro_ joined
[09:33] <moritz> nqp: say(nqp::index('a', 'b'))

[09:33] <p6eval> nqp: OUTPUT«-1␤»

[09:33] <moritz> nqp: say(nqp::index('abc', 'b'))

[09:33] <p6eval> nqp: OUTPUT«1␤»

[09:35] <GlitchMr> > so index 'a', 'a'

[09:35] <GlitchMr> False

[09:35] <GlitchMr> Why?

[09:36] <GlitchMr> Couldn't index have something like "but True"?

[09:37] <moritz> rakudo doesn't implement StrPos yet, which should do that part

[09:37] <moritz> just use s/so/defined/

[09:37] <moritz> r: class DYNAMIC { }; say DYNAMIC

[09:37] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Cannot use pseudo-package DYNAMIC in a package name␤»

[09:39] <tadzik> good morning #perl6

[09:41] <GlitchMr> * MATCH ":moorcock.freenode.net 004 SixtySixBot moorcock.freenode.net"

[09:41] <GlitchMr> But... it matches

[09:41] <GlitchMr> Now I'm really confused

[09:41] <GlitchMr> If it matches, why it doesn't

[09:41] <GlitchMr> or

[09:41] <moritz> GlitchMr: your question doesn't make any sense to somebody who doesn't see exactly what you do

[09:42] <GlitchMr> print so RawEvent.parse(':moorcock.freenode.net 004 SixtySixBot moorcock.freenode.net ircd-seven-1.1.3 DOQRSZaghilopswz CFILMPQbcefgijklmnopqrstvz bkloveqjfI')

[09:42] <GlitchMr> I see...

[09:42] <moritz> n: sub DYNAMIC() { }; DYNAMIC()

[09:42] <p6eval> niecza v21-1-ga8aa70b:  ( no output )

[09:42] <GlitchMr> https://gist.github.com/3596274

[09:42] <GlitchMr> How it could match if TOP rule has ^ and $

[09:43] <moritz> r: https://gist.github.com/3596274

[09:43] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Confused␤at /tmp/5XRFKGwNbd:1␤»

[09:43] <GlitchMr> It's probably glitchmr@strawberry ~> cat debug.p6

[09:43] <moritz> right

[09:44] <GlitchMr> r: https://gist.github.com/3596277

[09:44] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Could not find Grammar::Tracer in any of: /home/p6eval/.perl6/lib, /home/p6eval/nom-inst/lib/parrot/4.7.0-devel/languages/perl6/lib␤»

[09:44] <moritz> star: https://gist.github.com/3596277

[09:44] <GlitchMr> r: https://gist.github.com/3596279

[09:44] <p6eval> star 2012.07: OUTPUT«TOP␤|  user␤|  * [37;41mFAIL␤|  host␤|  |  space␤|  |  * [37;41mFAIL␤|  |  space␤|  |  * [37;41mFAIL␤|  |  space␤|  |  * [37;41mFAIL␤|  |  space␤|  |  * [37;41mFAIL␤|  |  space␤…

[09:44] <p6eval> rakudo 1f86d2: OUTPUT«True»

[09:45] <GlitchMr> * MATCH ":moorcock.freenode.net 004 SixtySixBot moorcock.freenode.net"

[09:45] <GlitchMr> I still wonder how it matched when it shouldn't

[09:45] <moritz> remove the 'so'

[09:46] <moritz> and s/print/say/

[09:46] <GlitchMr> r: https://gist.github.com/3596279

[09:46] <p6eval> rakudo 1f86d2: OUTPUT«:moorcock.freenode.net 004 SixtySixBot moorcock.freenode.net ircd-seven-1.1.3 DOQRSZaghilopswz CFILMPQbcefgijklmnopqrstvz bkloveqjfI»

[09:46] <GlitchMr> what?

[09:46] <moritz> it parses all the trailing garbage as params

[09:46] <moritz> params => ｢bkloveqjfI｣

[09:47] <moritz> $<params>=<-space>+

[09:47] <GlitchMr> https://gist.github.com/3596287

[09:47] <GlitchMr> What?

[09:48] <GlitchMr> As for bot itself, it looks like https://gist.github.com/3596290

[09:49] <moritz> looks like a bug in the bot module

[09:51] <GlitchMr> my $event = Net::IRC::Parser::RawEvent.parse($line)

[09:51] <GlitchMr> or $*ERR.say("Could not parse the following IRC event: $line") and next;

[09:51] <GlitchMr> huh?

[09:52] <GlitchMr> It parsed except it didn't?

[09:52] <moritz> GlitchMr: I can't make any sense of what you say

[09:52] <moritz> what do you mean by "It parsed except it didn't?"?

[09:53] <GlitchMr> ok, I've enabled debug mode

[09:53] <GlitchMr> https://gist.github.com/3596312

[09:53] <GlitchMr> It crashed just after MOTD

[09:54] <GlitchMr> https://github.com/TiMBuS/Net--IRC/blob/master/lib/Net/IRC/Bot.pm#L55

[09:54] <GlitchMr> hmm...

[09:55] <GlitchMr> \c is decimal escape?

[09:55] <GlitchMr> That looks like \xD\xA for me

[09:57] <GlitchMr> In method .sendln...

[09:57] <GlitchMr> .send in CORE.setting attempted to call .seek

[09:57] <GlitchMr> Except .seek is... not implemented?

[09:57] <arnsholt> moritz: Could you take a look at the libnames branch in Zavolaj?

[09:58] <arnsholt> The new test works on OS X, but because Linux does weird stuff with library names it doesn't work there. If you have any good ideas that'd be awesome

[09:58] <moritz> arnsholt: yes. What exactly should I look at?

[09:59] * moritz git fetches

[10:01] <moritz> my $realname =  !$libname.DEFINITE   ?? "" !! $libname;

[10:01] <moritz> why not write that as   my $realname = $libname // "";   ?

[10:01] <arnsholt> Because it's been reduced from code that actually needed the ternary, and I just mechanically reduced it =)

[10:02] <moritz> arnsholt: does this require any extra rakudo or nqp branches/commits?

[10:03] <arnsholt> Yeah

[10:03] <arnsholt> nqp/dyncall-libnames

[10:04] <moritz> arnsholt: is that branch just one patch?

[10:06] <arnsholt> So far, yeah

[10:07] <arnsholt> But since it breaks old versions of Zavolaj and is kinda experimental in general I kept it in a branch

[10:07] <moritz> well

[10:07] <moritz> I have only glanced at the C code

[10:08] <moritz> does PARROT_LOAD_EXT and PARROT_SHARE_EXT contain the dot?

[10:08] <arnsholt> Yup

[10:08] * moritz hopes so

[10:09] <arnsholt> They do =)

[10:09] <moritz> aye

[10:09] <arnsholt> But the real problem is the new test in Zavolaj. On my Linux machine, it fails because the C library is libc.so.6 and not libc.so >.<

[10:09] <GlitchMr> Perhaps https://github.com/TiMBuS/Net--IRC/tree/use-muevent will work

[10:09] <arnsholt> On OS X it's just libc.dylib

[10:09] <GlitchMr> But can panda install from alternate git branch?

[10:09] <Timbus> hi

[10:10] <Timbus> no it wont

[10:10] <tadzik> I never taught it to :)

[10:10] <tadzik> oh, use-muevent

[10:10] <tadzik> and I ended up with my own fork :)

[10:10] <Timbus> muevent chokes after a few dozen lines

[10:10] <tadzik> yeah, then unchokes

[10:10] <Timbus> oh?

[10:11] <GlitchMr> Timbus: I cannot get your Net::IRC::Bot module to work

[10:11] <GlitchMr> This is code: https://gist.github.com/3596290

[10:11] <tadzik> Timbus: yeah, it's sort of funny

[10:11] <GlitchMr> And this is result: https://gist.github.com/3596312

[10:11] <tadzik> it either unchokes after ~30 seconds, or...

[10:11] <tadzik> or you can set up another socket (listener, via MuEvent), and then when you send anything to it, the IRC socket "unchokes"

[10:11] <tadzik> I have no idea how this works

[10:11] <Timbus> :I

[10:12] <GlitchMr> I've tried using Freenodebot.pl, but it also doesn't work

[10:12] <GlitchMr> In similar way

[10:12] <Timbus> might be worth looking at wrapping libev in zavolaj

[10:12] <moritz> arnsholt: isn't that why, by convention, the empty string as a library name looks into libc?

[10:13] <tadzik> my wild guess was that we're too slow at receiving packets, and freenode stops sending them after a while

[10:13] <Timbus> GlitchMr, dunno, 'seek' doesnt exist?

[10:13] <Timbus> strange

[10:13] <GlitchMr> This is newest Rakudo by the way

[10:13] <GlitchMr> glitchmr@strawberry ~/g/SixtySixBot> perl6 -v

[10:13] <GlitchMr> This is perl6 version 2012.08-63-g1f86d22 built on parrot 4.7.0 revision RELEASE_4_7_0-165-g29796c6

[10:14] <GlitchMr> Or perhaps...

[10:14] <moritz> arnsholt: at least I dimly recall reading that, and I'm afraid that's my only contribution to that topic :(

[10:15] <Timbus> GlitchMr, cant seem to reproduce this on a slightly older rakudo.

[10:16] <moritz> recently a branch was merged in parrot that re-did much of the IO subsystem

[10:16] <Timbus> o

[10:16] <moritz> after the 2012.08 release

[10:17] <Timbus> i.. couuuld look into that

[10:18] <tadzik> hm

[10:20] *** Moukeddar joined
[10:22] <tadzik> hm, this now fails on new rakudo: https://gist.github.com/3596516

[10:23] <tadzik> (foo is the input)

[10:23] <GlitchMr> I wonder why people use complicated prompts ;)

[10:23] <tadzik> just for the sake of having a two-line prompt

[10:24] <arnsholt> moritz: No, dlopen(NULL) lets you dig into the libraries already loaded by the executable

[10:24] <arnsholt> Not quite the same, but since pretty much any program will link against libc it works for getting at that stuff

[10:25] <arnsholt> But since I want to make sure both dylibs and bundles work on OS X, I have to load a library I can be reasonably sure exists everywhere

[10:25] <arnsholt> Maybe I'll just make it a test run only on OS X

[10:29] <GlitchMr> This prompt actually reminds me my very old prompt

[10:29] <GlitchMr> http://dl.dropbox.com/u/63913412/dos.png

[10:31] <lizmat> jnthn: ping

[10:31] <phenny> lizmat: 01 Sep 18:11Z <jnthn> tell lizmat le NQP branch merge is done, which unblocks your ops work :)

[10:35] <lizmat> getting on that now

[10:38] <jnthn> lizmat: pong

[10:39] <lizmat> you left the answer I wanted to ask

[10:39] <lizmat> :-)

[10:40] *** spider-mario joined
[10:40] <jnthn> aha :)

[10:42] <GlitchMr> If I want stability, I should use stable release

[10:43] <GlitchMr> Except some modules aren't so stable

[10:43] <Moukeddar> guys, sorry to bother you, but how do you plan your project , we're talking here about a single developer project ? any suggestions ?

[10:43] <GlitchMr> Moukeddar: uhmmm... what project?

[10:44] <Moukeddar> it's a pet project, a mix of web and desktop stuff 

[10:46] *** MayDaniel left
[10:47] *** DarthGandalf left
[10:48] <Moukeddar> so ?

[10:49] <lizmat> hhmmm… make test generates errors *after* it seems done?

[10:50] <jnthn> lizmat: ?

[10:50] <jnthn> lizmat: nopaste?

[10:50] <lizmat> https://gist.github.com/3596762

[10:51] <moritz> Moukeddar: 1) be clear on what you want to do 2) identify a minimally useful subset of functionality 3) implement that 4) grow from there

[10:52] <Moukeddar> moritz, i can do that using a spreadsheet :) , thanks :)

[10:52] <lizmat> jnthn: there is more if you want

[10:52] * lizmat pasted the whole thing now

[10:52] <jnthn> lizmat: I'm guessing it invokes prove mutliple times

[10:53] <jnthn> huh, t/setting...

[10:53] *** DarthGandalf joined
[10:53] <jnthn> hm, that lot looks bitrotten.

[10:54] <lizmat> jnthn: after git pull this morning, make test did:

[10:54] <lizmat> $ make test

[10:54] <lizmat> make: *** No rule to make target `src/pmc/dispatchersub.pmc', needed by `src/pmc/nqp_group.bundle'.  Stop.

[10:55] <jnthn> lizmat: Did you just make? 

[10:55] <lizmat> I figured I needed to run Configure.pl again

[10:55] <jnthn> lizmat: Right.

[10:55] <lizmat> make came up with the same error

[10:55] <jnthn> lizmat: That's expected. Configure.pl generates the Makefile

[10:55] <lizmat> then ran make again, then make test gave these errors

[10:55] <jnthn> If something gets removed, the makefile has to be re-generated

[10:55] <lizmat> that's what I figured  :-)

[10:55] <jnthn> I can't see how these tests could ever have worked for...a while

[10:55] *** Moukeddar left
[10:55] <jnthn> (the t/setting ones)

[10:56] <lizmat> so I guess the reason is: why are they being tested now?

[10:56] <lizmat> I don't think they were before

[10:56] <jnthn> That's weird

[10:56] <jnthn> They don't run for me when I "nmake test"

[10:56] * jnthn checks again

[10:57] * lizmat will start with a fresh repo and see what it gives

[10:58] <moritz> jnthn: http://moritz.faui2k3.org/tmp/0001-fix-declaration-of-subs-with-indirect-name.patch seems to work, but it's somewhat ugly

[10:58] <moritz> and probably not correct in corner cases

[10:58] <moritz> n: sub CALLER::foo() { }

[10:58] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«===SORRY!===␤␤Pseudo package CALLER may not be used in compile time reference at /tmp/ZtyDslPwV7 line 1:␤------> sub CALLER::foo⏏() { }␤␤Potential difficulties:␤  &foo is declared but not used at /tmp/ZtyDslPwV7 line 1:␤…

[10:59] <moritz> nr: sub CALLER() { say 42 }; CALLER()

[10:59] <p6eval> niecza v21-1-ga8aa70b:  ( no output )

[10:59] <p6eval> ..rakudo 1f86d2: OUTPUT«42␤»

[11:00] <moritz> nr: sub a::b() { }

[11:00] <p6eval> rakudo 1f86d2, niecza v21-1-ga8aa70b:  ( no output )

[11:00] <moritz> nr: sub a::b() { }; a::b()

[11:00] <p6eval> rakudo 1f86d2: OUTPUT«Could not find symbol '&b'␤  in method <anon> at src/gen/CORE.setting:9796␤  in  at src/gen/Metamodel.pm:2317␤  in any find_method_fallback at src/gen/Metamodel.pm:2305␤  in any find_method at src/gen/Metamodel.pm:859␤  in  at src/gen/BOOTSTRAP.pm:826␤  in any  at …

[11:00] <p6eval> ..niecza v21-1-ga8aa70b:  ( no output )

[11:03] <jnthn> lizmat: Here, nmake test only runs t/nqp, t/qast and t/hll

[11:03] <moritz> no regex tests?

[11:03] <jnthn> No

[11:03] <jnthn> It...does for you?

[11:03] <jnthn> well, wtf

[11:03] <moritz> it did last I tried

[11:03] <jnthn> test: all core-test setting-test qregex-test

[11:04] <moritz> does one of them fail for you?

[11:04] <jnthn> I get the usual 46 fail due to no ICU

[11:04] <moritz> well

[11:05] <moritz> that will lead to the rest of the tests not being run

[11:05] <jnthn> oh.

[11:05] <jnthn> why the heck is it set up to do all these different invocations of prove?

[11:05] <jnthn> proposal: make test just calls prove with all the things?

[11:05] <jnthn> Apart from t/setting, which I'm somewhat inclined to nuke.

[11:06] *** JimmyZ joined
[11:07] <moritz> iirc the background is that if you simply invoke the harness, a failure on the top can scroll by, and at the end you don't see that anything failed

[11:07] <moritz> well, if you do it in one line, it would work

[11:07] <jnthn> Right, that's my idea

[11:07] <moritz> +1 then

[11:08] <jnthn> Yeah, that way gets you one summary at the end

[11:08] *** lizmat left
[11:09] *** lizmat joined
[11:13] *** kaare_ joined
[11:19] <lizmat> jnthn: a fresh clone gives the same errors

[11:19] <lizmat> should I look at fixing the tests?

[11:21] <dalek> nqp: 1801844 | jnthn++ | tools/build/Makefile.in:

[11:21] <dalek> nqp: Clean up test targets so they actually run all of the tests they're expected to and give a single summary at the end of doing so.

[11:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/18018440ba

[11:21] <dalek> nqp: e4db73c | jnthn++ | t/ (7 files):

[11:21] <dalek> nqp: Steal a couple of the tests that still makes sense from t/setting into t/nqp, then toss t/setting, which was largely bit-rotten.

[11:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e4db73c3bb

[11:22] <jnthn> lizmat: Those commits should clean things up

[11:22] <lizmat> ack

[11:23] <lizmat> many errors less, but a new one appeared

[11:24] <lizmat> https://gist.github.com/3597242

[11:24] <jnthn> Did you re-Configure?

[11:25] <jnthn> (I updated the Makefile.in)...

[11:26] <lizmat> no, will do now  :-)

[11:31] <lizmat> All tests successful  :-)

[11:31] <jnthn> \o/

[11:32] <jnthn> Time to break stuff! 

[11:32] <jnthn> ;)

[11:32] <lizmat> working on it  :-)

[11:35] *** birdwindupbird joined
[11:35] <lizmat> r: .say for 1 .. 5

[11:35] <p6eval> rakudo 1f86d2: OUTPUT«1␤2␤3␤4␤5␤»

[11:35] <lizmat> rn: .say for 1 .. 5

[11:35] <p6eval> rakudo 1f86d2, niecza v21-1-ga8aa70b: OUTPUT«1␤2␤3␤4␤5␤»

[11:37] <dalek> nqp: 9dc2b8d | (Elizabeth Mattijsen)++ | / (2 files):

[11:37] <dalek> nqp: Eradicated pir::does(...,'hash') for nqp::ishash

[11:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9dc2b8d5a2

[11:40] *** birdwindupbird left
[11:43] <dalek> nqp: 237fae7 | (Elizabeth Mattijsen)++ | / (2 files):

[11:43] <dalek> nqp: Eradicated pir::get_who__PP for nqp::who

[11:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/237fae7709

[11:49] <GlitchMr> https://gist.github.com/3597564

[11:49] <GlitchMr> Am I doing something incorrectly?

[11:51] <GlitchMr> And why %*ENV is readonly?

[11:59] <lizmat> jnthn: Can only use repr_defined on a SixModelObject

[11:59] <lizmat> ring a bell?

[12:00] <lizmat> this is about s/nqp::defined/nqp::isconcrete/

[12:06] <jnthn> lizmat: Yeh

[12:06] <jnthn> *Yeah

[12:06] <jnthn> That's why we need nqp::defined I guess

[12:06] <lizmat> so pir::defined -> nqp::defined?

[12:07] <lizmat> for now, then?

[12:07] <lizmat> or are there some nqp::defined's that should become nqp::isconcrete?

[12:08] <GlitchMr> glitchmr@feather ~> perl6 -v

[12:08] <GlitchMr> This is Rakudo Perl 6, version 2010.08 built on parrot 2.7.0

[12:08] <GlitchMr> oh

[12:08] <GlitchMr> I read it as 2012.08

[12:09] *** Timbus|Away joined
[12:10] <GlitchMr> But... why Perl 6 development server would have two years old version of Rakudo

[12:11] * lizmat is pinging juerd

[12:11] <bonsaikitten> because no one upgraded? :)

[12:14] <lizmat> it appears that the one responsible for upgrading did not upgrade

[12:14] <lizmat> trying to find out who that was

[12:14] <GlitchMr> But at least they haven't lied with "A recent version of pugs to work with". pugs is recent enough.

[12:15] <GlitchMr> It says "Copyright 2005-2012"

[12:15] *** Timbus left
[12:15] *** Timbus|Away is now known as Timbus

[12:15] <lizmat> GlitchMr: could it be that your perl6 is a symlink to someone's home dir

[12:16] <GlitchMr> glitchmr@feather ~> which perl6

[12:16] <GlitchMr> /usr/local/bin/perl6

[12:16] <GlitchMr> Not really

[12:16] <lizmat> after checking with Juerd, he says that it was basically the idea that everybody would compile their own

[12:17] <GlitchMr> I see...

[12:17] <lizmat> and that the system one was just something that you could use as a very basic bootstrap

[12:17] *** erkan left
[12:17] *** immortal joined
[12:17] *** immortal left
[12:17] *** immortal joined
[12:17] <lizmat> I'll be seeing juerd IRL next Tuesday at the Amsterdam PM meeting, and discuss how to take feather onwards

[12:21] <GlitchMr> I hope that compiling Perl 6 myself won't be too problematic for server ;)

[12:22] <lizmat> only one way to find out, I guess

[12:23] <jnthn> lizmat: nqp::isconcrete is safe only when you know you always have some kind of 6model object to hand. In NQP, arrays, hashes etc are still not that.

[12:25] <dalek> nqp: 2019842 | (Elizabeth Mattijsen)++ | / (2 files):

[12:25] <dalek> nqp: Eradicated pir::defined__IP for nqp::defined

[12:25] <dalek> nqp: 

[12:25] <dalek> nqp: The original plan was to s/nqp::defined/nqp::isconcrete/ but this gave errors

[12:25] <dalek> nqp: on 6model objects:

[12:25] <dalek> nqp: 

[12:25] <dalek> nqp:   Can only use repr_defined on a SixModelObject

[12:25] <dalek> nqp: 

[12:25] <dalek> nqp: So only did pir::defined__IP -> nqp::defined migration.  And moved the

[12:25] <dalek> nqp: possible nqp::defined -> nqp::isconcrete migration to jnthn's list

[12:25] <dalek> nqp: review: https://github.com/perl6/nqp/commit/20198427a8

[12:26] <lizmat> but they will be?  so this is just a matter of delay?

[12:28] <GlitchMr> 26502 glitchmr  20   0 34536  22m 6372 R  28,2  1,9   0:00.85 cc1

[12:28] <GlitchMr> 28,2% of CPU usage

[12:28] <GlitchMr> ok

[12:28] <jnthn> lizmat: On @next-vm almost certainly.

[12:29] * lizmat will try to recognize 6model objects from bare arrays/hashes and see what will work

[12:29] <lizmat> btw: NQP/Actions.pm:993:                        || pir::isa__IPs($_.returns, 'Undef') # XXX hack, goes away after QAST migration

[12:29] <jnthn> ooh

[12:29] <jnthn> Try deleting it. :)

[12:30] <jnthn> iirc, the other half of the || does what's really needed now

[12:31] <lizmat> testing

[12:32] <lizmat> for pir::isa__IPs I see <Namespace Sub String> as 2nd parameter

[12:32] *** breakEM left
[12:33] <lizmat> I assume Namespace/Sub are hashes, and String is list ?

[12:35] <lizmat> test ok

[12:35] <jnthn> er

[12:36] <jnthn> where is that code? :)

[12:36] <jnthn> Namespace doesn't even make sense any more in NQP

[12:36] <dalek> nqp: dae38f0 | (Elizabeth Mattijsen)++ | / (2 files):

[12:36] <dalek> nqp: Removed now superfluous call to pir::isa__IPS(..,'Undef'), per jnhtn's instructions

[12:36] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dae38f0367

[12:36] <lizmat> HLL/Compiler.pm:46:        pir::isa__IPs($value, 'NameSpace')

[12:37] <jnthn> oh my

[12:37] <moritz> oh my indeed

[12:37] <jnthn> I wonder if we even encounter that code path any more.

[12:38] <jnthn> EXPORT doesn't work that way any more for example

[12:38] <moritz> r: sub GLOBAL() { }; say GLOBAL()

[12:38] <p6eval> rakudo 1f86d2: OUTPUT«invoke() not implemented in class 'GLOBAL'␤  in block  at /tmp/wx1VGIt9hJ:1␤␤»

[12:39] <jnthn> moritz: By the Type(...) rule I guess it's attempting to turn that into a coercion...

[12:39] <jnthn> get_module in HLL::Compiler also looks very suspect

[12:40] <lizmat> shall I drop get_exports / value_type and get_module and see what happens?

[12:40] <jnthn> lizmat: Yeah.

[12:40] <jnthn> I can't imagine them doing anything useful any more.

[12:41] <lizmat> testing

[12:41] <jnthn> I think they may have been part of a previous HLL interop thing.

[12:41] <jnthn> But are bitrotten to the extent that they're not worth keeping.

[12:42] *** immortal left
[12:42] *** erkan joined
[12:42] *** erkan left
[12:42] *** erkan joined
[12:42] <moritz> jnthn: any feedback on http://moritz.faui2k3.org/tmp/0001-fix-declaration-of-subs-with-indirect-name.patch ?

[12:42] <moritz> jnthn: I realize it's incredibly hacking, but I don't quite know what do about it

[12:44] <moritz> *hacky

[12:44] <lizmat> jnthn: tests ok

[12:45] <jnthn> moritz: Is there no way we can communicate the DYNAMIC thing into disect_longname (pass it a named arg or something)?

[12:45] <jnthn> So that it leaves the DYNAMIC alone?

[12:46] <moritz> jnthn: well, I experimented with passing :decl<routine> to it

[12:46] <moritz> and be more permissive in that case

[12:46] <moritz> but all I got was a NPMCA

[12:47] <dalek> nqp: 25fcb3f | (Elizabeth Mattijsen)++ | src/HLL/Compiler.pm:

[12:47] <dalek> nqp: Dropped some bitrotten code from previous HLL interop thing

[12:47] <dalek> nqp: 

[12:47] <dalek> nqp: It was referencing pir::isa__IP(..,'Namespace') which was obsolete

[12:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/25fcb3f3d5

[12:47] <moritz> jnthn: I'll nopaste a patch, wait a second..

[12:48] <jnthn> moritz: OK. I'm mostly tied up with sorting out some $dayjob stuff I've been putting off at the moment, though.

[12:49] * lizmat will stop bothering jnthn and enjoy the nice weather with bike ride

[12:50] <moritz> jnthn: http://moritz.faui2k3.org/tmp/0001-clean-up-deflongname-handling.patch (and don't hurry :-)

[12:51] <jnthn> OK, will look in a bit... :)

[12:56] *** hoelzro|away is now known as hoelzro

[12:57] *** JimmyZ left
[13:10] *** JimmyZ joined
[13:18] <moritz> taking a second look, one bug is obvious

[13:20] <moritz> a return after a die is almost certainly wrong :-)

[13:22] *** benabik left
[13:23] *** benabik joined
[13:23] <moritz> patch updated

[13:23] <moritz> (under the same URL)

[13:23] <moritz> now it dies with Method 'orig' not found for invocant of class 'NQPMu'

[13:23] <moritz> current instr.: 'add_deadly' pc 9181 (src/gen/perl6-optimizer.pir:3416) (src/Perl6/Optimizer.pm:536)

[13:24] <moritz> which probably means it installed something as the wrong name, and then the optimizer died while adding the memo about the missing subroutine

[13:24] <sergot> Who is responsible for planetsix.perl.org? :)

[13:25] <moritz> sergot: the perl.org admins, but for example [Coke] has enough privs to add feeds

[13:25] <moritz> (and remove them)

[13:25] <sergot> moritz++ thanks. :)

[13:29] * moritz adds some debug statements

[13:34] <GlitchMr> export PATH="`perl -l72e'print for reverse sort </home/glitchmr/rakudo-star/*.*/bin>'`$PATH"

[13:34] <GlitchMr> Because I'm bored...

[13:35] <moritz> dammit, it's DYNAMIC again

[13:39] *** benabik left
[13:41] <pmichaud> good morning, #perl6

[13:41] <colomon> \o, pm

[13:42] <moritz> good am, pm and colomon

[13:42] <jnthn> good afty, pmichaud 

[13:42] <colomon> o/

[13:49] *** benabik joined
[14:00] * moritz discovers another bug

[14:07] <moritz> \o/ it build the setting again

[14:09] *** fgomez left
[14:10] *** skids joined
[14:11] <moritz> the code is now a bit longer and more robust

[14:11] <moritz> and as a plus:

[14:11] <moritz> ./perl6 -e 'sub CALLER::foo() { }'

[14:11] <moritz> ===SORRY!===

[14:11] <moritz> Cannot use pseudo-package CALLER in a sub declaration

[14:12] <moritz> r: sub CALLER::foo() ·{ }; say MY::.keys

[14:12] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Missing block␤at /tmp/KgnK3jrUq1:1␤»

[14:12] <moritz> r: sub CALLER::foo() { }; say MY::.keys

[14:12] <p6eval> rakudo 1f86d2: OUTPUT«!UNIT_MARKER GLOBALish EXPORT $?PACKAGE ::?PACKAGE $_ $/ $! &CALLER::foo $=pod␤»

[14:13] <jnthn> Oops ;)

[14:13] <jnthn> moritz++

[14:15] *** araujo left
[14:24] <moritz> jnthn: do you have a feeling how many LongName objects we carry around?

[14:24] <moritz> thing is, for better error messages I'd like to store a Match object per LongName. Is that OK? or too expensive?

[14:25] *** moises joined
[14:28] <jnthn> moritz: I think LongName objects are fairly short lived.

[14:28] <moritz> ok, great

[14:28] <jnthn> They shouldn't make it into the AST ever, for example.

[14:35] <moritz> nqp: say(1) if !NQPMu

[14:35] <p6eval> nqp: OUTPUT«1␤»

[14:35] <moritz> nqp: say(1) if NQPMu

[14:35] <p6eval> nqp:  ( no output )

[14:36] <moritz> nqp: nqp::die(42)

[14:36] <p6eval> nqp: OUTPUT«42␤current instr.: '' pc 52 ((file unknown):40) (/tmp/xC3hcm2Abd:1)␤»

[14:36] *** MayDaniel joined
[14:36] <moritz> hm, that line number is correct

[14:37] <moritz> nqp: 1 || say(42)

[14:37] <p6eval> nqp:  ( no output )

[14:38] *** marmay joined
[14:38] <spider-mario> aw, why does Rakudo repeat itself in some error messages?

[14:38] <lumi_> Would it be possible to run a grammar, and emit HTML with the original text surrounded by a tag with the matching rulename as a class?

[14:38] <spider-mario> ===SORRY!===

[14:38] <spider-mario> Error while compiling block : Error while compiling block hello: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote

[14:39] <lumi_> For cheap and fun syntax highlighting, I was thinking

[14:39] <spider-mario> r: macro hello($name) {quasi { say "Hello { {{{$name}}} } !"; };} hello("Rakudo");

[14:39] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Confused␤at /tmp/e_VUo1yinr:1␤»

[14:39] <spider-mario> r: macro hello($name) {quasi { say "Hello { {{{$name}}} } !"; };}; hello("Rakudo");

[14:39] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling block hello: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote␤»

[14:39] <spider-mario> here, reproduced

[14:41] <jnthn> spider-mario: That's an internal error from the compiler toolchain.

[14:41] <spider-mario> ok.

[14:41] <jnthn> spider-mario: The macros implementing is really rather new.

[14:41] <jnthn> spider-mario: So it'll be a bug in that.

[14:42] <moritz> spider-mario: please submit

[14:42] <jnthn> The messages are often pretty handy for tracking down the issue. :)

[14:43] <jnthn> r: macro hello($name) {quasi { say "Hello { {{{$name}}} } !"; };};

[14:43] <p6eval> rakudo 1f86d2: OUTPUT«===SORRY!===␤Error while compiling block : Error while compiling op call: Error while compiling block : Error while compiling block hello: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote␤»

[14:43] <jnthn> Golfed.

[14:44] <spider-mario> sorry, I have forgotten the procedure to submit a rakudo bug?

[14:45] *** benabik left
[14:46] <jnthn> [email@hidden.address]
[14:46] <jnthn> (some other hints in README)

[14:47] <spider-mario> thanks

[14:47] <GlitchMr> Error while compiling block : Error while compiling block : Error while compiling block load_module: Error while compiling op lexotic: Error while compiling op if: Error while compiling block : Error while compiling op handle: Error while compiling op if: Error while compiling block : Error while compiling op bind: Error while compiling op associative_bind: Cannot infer type from ''

[14:47] <GlitchMr> that could be fun

[14:49] <lumi_> Maybe I'll try doing it, but I only have tuits in 2 weeks

[14:50] *** nebuchadnezzar left
[14:52] <jnthn> o.O

[14:52] <jnthn> GlitchMr: How'd you get that one?

[14:53] *** benabik joined
[14:53] <GlitchMr> I've tried to compile perl6

[14:53] <GlitchMr> But I probably do it incorreclt

[14:53] <GlitchMr> incorrectly*

[14:53] <GlitchMr> t/nqp/60-bigint.t ............... Failed 3/34 subtests

[14:53] <GlitchMr> wait...

[14:54] *** birdwindupbird joined
[14:54] *** hoelzro is now known as hoelzro|away

[15:00] *** nebuchadnezzar joined
[15:03] *** HotJessicaBOOBS joined
[15:04] *** HotJessicaBOOBS left
[15:12] *** yarp left
[15:14] <dalek> nqp: 6b8b4a6 | jnthn++ | src/ (2 files):

[15:14] <dalek> nqp: Move CTXSAVE and EXPR that were temporarily subclassed in NQP::Actions back up into HLL::Actions (taking the QAST-using versions).

[15:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6b8b4a6641

[15:14] <dalek> nqp: 899659e | jnthn++ | src/ (2 files):

[15:14] <dalek> nqp: Move QAST versions of quote_EXPR and quote_delimited up into HLL::Actions, eliminating them from NQP::Actions.

[15:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/899659e42e

[15:14] <dalek> nqp: ed02bcc | jnthn++ | src/HLL/World.pm:

[15:14] <dalek> nqp: Toss a bunch of now-dead code (replaced by a combination of QAST::WVal, bs and some of the logic moving into QAST::Compiler itself).

[15:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ed02bcc357

[15:23] <spider-mario> bug reported, it’s #114708

[15:24] <spider-mario> https://rt.perl.org:443/rt3/Public/Bug/Display.html?id=114708

[15:26] *** benabik left
[15:27] *** birdwindupbird left
[15:30] *** skids left
[15:33] *** Moukeddar joined
[15:33] *** benabik joined
[15:35] *** Moukeddar left
[15:36] *** thou joined
[15:42] *** benabik left
[15:44] *** JimmyZ left
[15:49] *** JimmyZ joined
[15:55] *** JimmyZ left
[15:59] *** tokuhiro_ left
[15:59] <dalek> nqp: 694af0d | jnthn++ | src/QRegex/P5Regex/Actions.nqp:

[15:59] <dalek> nqp: Various P5Regex de-PASTifications.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/694af0d938

[15:59] <dalek> nqp: fb79576 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[15:59] <dalek> nqp: Start updating P6Regex to eliminate use of buildsub (now always uses qbuildsub) and turn some other PAST usages into QAST.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fb79576da0

[15:59] <dalek> nqp: d7054fa | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[15:59] <dalek> nqp: Toss some now-dead code in P6Regex.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d7054fa119

[15:59] <dalek> nqp: dd2cd29 | jnthn++ | src/QRegex/NFA.nqp:

[15:59] <dalek> nqp: Toss NFA.past.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dd2cd2960d

[15:59] <dalek> nqp: 211d5b3 | jnthn++ | src/HLL/Compiler.pm:

[15:59] <dalek> nqp: Eliminate a couple of mentions of PAST from HLL::Compiler.

[15:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/211d5b3f8a

[15:59] <GlitchMr> That's lots of commits

[16:00] <jnthn> Lot of deleted code too :)

[16:07] <dalek> rakudo/indirect-subs: a59d2f3 | moritz++ | src/Perl6/ (3 files):

[16:07] <dalek> rakudo/indirect-subs: fix declaration of subs with indirect name

[16:07] <dalek> rakudo/indirect-subs: review: https://github.com/rakudo/rakudo/commit/a59d2f3fae

[16:07] <dalek> rakudo/indirect-subs: 989d8b2 | moritz++ | src/ (2 files):

[16:07] <dalek> rakudo/indirect-subs: typed exception for illegal use of pseudo packages in other names

[16:07] <dalek> rakudo/indirect-subs: review: https://github.com/rakudo/rakudo/commit/989d8b2292

[16:08] <moritz> that branch now mostly works

[16:09] <moritz> but  module MY { }

[16:09] <moritz> now dies with Null PMC access in get_string()

[16:09] <moritz> the offending line is   if !$decl || ($decl eq 'routine') {  if the backtrace can be trusted

[16:10] <moritz> which is kinda weird, because if $decl is Null, I'd expect the ($decl eq 'routine') to never run

[16:11] <jnthn> Well, I'd expect the NPMCA to be in the if $decl and it to complain about get_bool too...

[16:11] <moritz> oh, the line annotations are off

[16:11] <moritz> looking at the PIR, it actually comes from                   if $_ eq 'GLOBAL' {

[16:11] <moritz> a few lines below

[16:11] <GlitchMr> I've Perl6 in ~/rakudo-star/ in case somebody would want to use it

[16:12] <moritz> which makes much more sense, since $_ is never assigned

[16:12] <moritz> stupid copy-pasto

[16:12] <moritz> jnthn: so, line numbers in NQP are off :(

[16:13] <jnthn> moritz: Wonder if it's just insufficient :node($/)-ing...

[16:15] <moritz>                 $ast := QAST::Stmts.new($ast) if nqp::istype($ast, QAST::Node);

[16:15] <moritz> from method statementlist

[16:15] <jnthn> hm

[16:15] <moritz> does that propagate the .node properly?

[16:15] <jnthn> Well, if the thing below got one, yes

[16:15] <jnthn> But for safety we could attach it again there.

[16:18] <dalek> nqp: 061f7f7 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[16:18] <dalek> nqp: Clear up most remaining PAST usages in P6Regex.

[16:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/061f7f79b7

[16:18] <dalek> nqp: f17f978 | jnthn++ | src/QRegex/P6Regex/Actions.nqp:

[16:18] <dalek> nqp: Final PAST eliminations in P6Regex.

[16:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f17f97850e

[16:18] <dalek> nqp: 2158891 | jnthn++ | src/QRegex/P5Regex/Actions.nqp:

[16:18] <dalek> nqp: Final PAST eliminations in P5Regex.

[16:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2158891b32

[16:18] <dalek> nqp: 5ba6925 | jnthn++ | src/ (2 files):

[16:18] <dalek> nqp: Various cleanups and simplifications to QAST::Compiler and HLL::Compiler now that it no longer has to cope with PAST and POST.

[16:18] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5ba6925bdf

[16:19] <dalek> rakudo/indirect-subs: c1aac0d | moritz++ | src/Perl6/World.pm:

[16:19] <dalek> rakudo/indirect-subs: avoid a Null PMC Access

[16:19] <dalek> rakudo/indirect-subs: review: https://github.com/rakudo/rakudo/commit/c1aac0d2ba

[16:21] <GlitchMr> glitchmr@feather ~> perl6

[16:21] <GlitchMr> perl6                perl6-2012.07        perl6-2012.08        perl6-debug          perl6-debug-2012.08

[16:21] <GlitchMr> good

[16:23] *** fibo joined
[16:35] *** SamuraiJack_ joined
[16:36] *** SamuraiJack left
[16:37] <thou> tadzik: hi, is $=data implemented in rakudo?

[16:38] *** nodmonkey joined
[16:46] *** nodmonkey left
[16:46] *** crab2313 joined
[16:47] <dalek> rakudo/nom: 821d6a0 | jnthn++ | src/Perl6/Grammar.pm:

[16:47] <dalek> rakudo/nom: Eliminate final PAST::Node usages in Perl6::Grammar's op generation, and update it to tall the QAST compiler rather than PAST::Compiler, use qbuildsub instead of buildsub, etc.

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/821d6a0f93

[16:47] <dalek> rakudo/nom: a55950d | jnthn++ | tools/build/NQP_REVISION:

[16:47] <dalek> rakudo/nom: Bump to latest NQP, with muchly reduced PAST usage.

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a55950d765

[16:47] <dalek> rakudo/nom: 1f1378e | jnthn++ | src/Perl6/Actions.pm:

[16:47] <dalek> rakudo/nom: Unbust /< a aa >/.

[16:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f1378ead4

[16:47] <GlitchMr> Timbus: would you consider this to be abuse of your module: https://gist.github.com/3601377

[16:48] <GlitchMr> oops, it should be negative check

[16:48] <GlitchMr> s/if/unless/

[16:49] <GlitchMr> oh, wait... I forgot that .subst returns its value

[16:51] <GlitchMr> perl6: lass blah { has $.regex = /a/; method replace($a is copy) { $a ~~ s/$.regex/b/; $a } }; blah.new.replace('cake').perl.say

[16:51] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«===SORRY!===␤␤Attribute $!regex declared outside of any class at /tmp/YaA_jWp3wj line 1:␤------> lass blah { has $.regex ⏏= /a/; method replace($a is copy) { $a ~␤␤Methods must be used in some kind of package at /tmp/YaA…

[16:51] <p6eval> ..rakudo 1f86d2: OUTPUT«===SORRY!===␤You cannot declare attribute '$.regex' here; maybe you'd like a class or a role?␤at /tmp/qjWdTTg28s:1␤»

[16:51] <GlitchMr> perl6: class blah { has $.regex = /a/; method replace($a is copy) { $a ~~ s/$.regex/b/; $a } }; blah.new.replace('cake').perl.say

[16:51] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«Unhandled exception: Unable to resolve method regex in type Cursor␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 566 (Cool.subst @ 37) ␤  at /tmp/UW7pC_Zppv line 1 (blah.replace @ 4) ␤  at /tmp/UW7pC_Zppv line 1 (ma…

[16:51] <p6eval> ..rakudo 1f86d2: OUTPUT«No such method 'regex' for invocant of type 'Cursor'␤  in regex  at /tmp/JCt62h5bHR:1␤  in method match at src/gen/CORE.setting:4021␤  in method subst at src/gen/CORE.setting:4083␤  in method replace at /tmp/JCt62h5bHR:1␤  in block  at /tmp/JCt62h5bHR:1␤␤»…

[16:51] <GlitchMr> Cursor?

[16:52] <jnthn> GlitchMr: A regex is a kind of method.

[16:52] <jnthn> GlitchMr: Thus any time you're in a regex, self is the cursor.

[16:52] <GlitchMr> So, I have to make copy of $.regex if I want to use it?

[16:52] <jnthn> Yes

[16:53] <GlitchMr> or use .subst()?

[16:53] <jnthn> I don't see how that'd help here. You'd still be passing a regex to subst I guess?

[16:53] <GlitchMr> Well, yes

[16:53] <GlitchMr> That regex would be

[16:53] <GlitchMr> /$.regex/

[16:54] <GlitchMr> So I can simply type $.regex

[16:54] <jnthn> ah

[16:54] <jnthn> yes, you can do that. :)

[16:58] <dalek> rakudo/nom: a59d2f3 | moritz++ | src/Perl6/ (3 files):

[16:58] <dalek> rakudo/nom: fix declaration of subs with indirect name

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a59d2f3fae

[16:58] <dalek> rakudo/nom: 989d8b2 | moritz++ | src/ (2 files):

[16:58] <dalek> rakudo/nom: typed exception for illegal use of pseudo packages in other names

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/989d8b2292

[16:58] <dalek> rakudo/nom: c1aac0d | moritz++ | src/Perl6/World.pm:

[16:58] <dalek> rakudo/nom: avoid a Null PMC Access

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c1aac0d2ba

[16:58] <dalek> rakudo/nom: 9cdf452 | moritz++ | src/ (4 files):

[16:58] <dalek> rakudo/nom: Merge remote branch 'origin/indirect-subs' into nom

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9cdf4527f6

[16:58] <dalek> rakudo/nom: 91e9725 | moritz++ | docs/ChangeLog:

[16:58] <dalek> rakudo/nom: update ChangeLog

[16:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/91e9725ed0

[17:08] <dalek> roast: c32c4d0 | moritz++ | S02-names/indirect.t:

[17:08] <dalek> roast: unfudge tests for indirect sub name declarations

[17:08] <dalek> roast: review: https://github.com/perl6/roast/commit/c32c4d09a0

[17:09] *** sftp left
[17:10] *** sftp joined
[17:11] <GlitchMr> Just wondering, is there opposite of slurp which would save content to file?

[17:11] <jnthn> spurt

[17:13] <jnthn> afk for a bit

[17:13] <dalek> rakudo/nom: 54030c3 | jnthn++ | docs/ChangeLog:

[17:13] <dalek> rakudo/nom: Add a note about having QAST-based NQP to the ChangeLog.

[17:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/54030c31c7

[17:20] *** benabik joined
[17:21] <GlitchMr> 19:20:54   @GlitchMr | 66: add future The future is already here — it's just not very evenly distributed.

[17:21] <GlitchMr> 19:20:57   @GlitchMr | 66: future                                                                        

[17:21] <GlitchMr> 19:20:57 SixtySixBot | GlitchMr: The future is already here — it's just not very evenly distributed.     

[17:21] <GlitchMr> ok, it seems to work :)

[17:22] *** varnie joined
[17:28] *** daniel-s_ joined
[17:31] *** daniel-s left
[17:33] <tadzik> thou: no, I don't think so

[17:33] <tadzik> I can give a try tomorrows

[17:35] *** moises left
[17:36] <GlitchMr> Just wondering, is 'Z,' operator identical to 'Z' operator?

[17:36] <GlitchMr> And identical to 'ZZZ' operator

[17:40] *** birdwindupbird joined
[17:41] *** thou left
[17:42] *** thou joined
[17:44] *** thou left
[17:46] <moritz> std: class Foo:: { }

[17:46] <p6eval> std 2f65afc: OUTPUT«ok 00:00 40m␤»

[17:46] <moritz> nr: class Foo:: { }

[17:46] <p6eval> niecza v21-1-ga8aa70b: OUTPUT«===SORRY!===␤␤Illegal explicit declaration of a symbol table at /tmp/K1aZm9UNYd line 1:␤------> class Foo::⏏ { }␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1435 (die @ 5) ␤  a…

[17:46] <p6eval> ..rakudo 91e972: OUTPUT«===SORRY!===␤Name Foo:: ends with '::' and cannot be used as a package name␤»

[17:47] *** thou joined
[17:48] <moritz> which error message do you like better?

[17:51] *** thou_ joined
[17:51] <jnthn> Rakudo's gives you a better idea of what to do about the problem, Niecza's is more technically detailed.

[17:52] * jnthn tries to think of a good union of the two

[17:53] <moritz> "Illegal use of trailing :: in name 'Foo::', which denotes a symbol table rather than a type'

[17:53] *** xinming left
[17:53] <jnthn> Something like that, yes.

[17:53] *** thou left
[17:54] *** xinming joined
[18:01] *** hoelzro|away is now known as hoelzro

[18:04] <sorear> good * #perl6

[18:04] <diakopter> o/

[18:05] *** thou_ left
[18:06] *** fibo left
[18:09] *** birdwindupbird left
[18:12] <pmichaud> jnthn: ping

[18:12] <jnthn> pmichaud: pong

[18:13] <pmichaud> jnthn: I'm working on reducing the number of return values from !cursor_start;  I can do all of them easily except I'm not sure how to efficiently get $?CLASS back

[18:14] <jnthn> pmichaud: If you were doing this after the $!orig/$!target refactor I'd have an answer... :)

[18:14] <pmichaud> what would your answer be then?

[18:14] <Circlepuller_> i like those ansi colors :3

[18:15] <jnthn> Put it in the thing you move $!orig/$!target into

[18:15] <pmichaud> store it there?  I'm not sure that works if we re-use the $!orig/$!target thing across multiple cursor types.

[18:15] <jnthn> Hm

[18:15] <pmichaud> I suppose we could say "don't reuse it"... but that's not really what happens now.

[18:15] <jnthn> Do we know the boundary?

[18:15] <pmichaud> I suspect perhaps not always.

[18:15] <jnthn> er, that was badly phrased

[18:15] <jnthn> ah, you understood it anyway :)

[18:16] <jnthn> Yeah, at first I thought it may be easily knowable but I can see it being more subtle...

[18:16] <pmichaud> anyway, putting it in $!orig/$!target feels like the wrong place.

[18:16] <jnthn> $!cstack is always free at !cursor_start time ;-)

[18:16] <pmichaud> because $!orig/$!target are about the thing being parsed, not the cursors doing the parcing

[18:16] <pmichaud> *parsing

[18:16] <pmichaud> $!cstack isn't free on a restart.

[18:16] <jnthn> ah, dang.

[18:16] <jnthn> yes.

[18:17] <GlitchMr> I should make Acme::ChuckNorris module. It will remove every bug in program.

[18:17] <GlitchMr> Code: exit

[18:18] <pmichaud> I can of course do it with a method call to the newly returned Cursor... but... dang.

[18:18] <jnthn> Yes, that would suck.

[18:20] <pmichaud> I can return a low-level list and grab things out of that.  Still icky because of the PMC allocation, though.

[18:20] <jnthn> A hack is to have a !CUR_CLASS lexical that !cursor_start binds.

[18:20] <pmichaud> ...via outer?

[18:20] <jnthn> Caller.

[18:20] <pmichaud> er, yes, caller

[18:20] <jnthn> Of course, all uses of it are done on the register.

[18:21] <pmichaud> lexical wouldn't be bad

[18:21] <jnthn> it's the least bad option so far.

[18:21] <pmichaud> could do some of that for the other registers too

[18:21] <pmichaud> it increases the size of the lexpad, though

[18:22] <jnthn> Yeah

[18:22] <MikeFair> Anyone know how I can express if <EXPR> then <EXPR> [else <EXPR>]  as "'if' is the prefix to a 'then' ternary operator?"

[18:23] <MikeFair> It's the equivalent to the ternary operator (test) ? true : false  , but will only work if prefixed by 'if'

[18:23] <jnthn> And you really want to parse the 'if' as a prefix?

[18:23] <jnthn> Maybe nextterm helps

[18:23] <moritz> MikeFair: express on what level?

[18:23] <moritz> grammar? AST? bytecode?

[18:24] <MikeFair> jnthn: Well I don't really care the if is prefix

[18:24] <GlitchMr> But Perl 6 already has fine ternary operator

[18:24] <GlitchMr> test ?? true !! false

[18:24] <MikeFair> jnthn: I think it was more the case that 'operator' was the hammer tool atm

[18:24] <jnthn> pmichaud: In the long run, I expect the attribute lookups could be faster, mind.

[18:24] <MikeFair> GlitchMr: Sorry, i'm writing some Grammar rules for parrot

[18:25] <GlitchMr> oh, ok

[18:25] <jnthn> MikeFair: You could always look at how we parse our if/else construct in NQP

[18:25] <pmichaud> well, I suppose I could pass it through the $!orig/$!target object... it just seems weird to do that

[18:26] <GlitchMr> I find it interesting that CoffeeScript has if something then true else false construct

[18:26] <pmichaud> even there, though, I have to do a couple of extra lookups  (namely get the .WHAT of the $!orig/$!target object so that I can do the lexical lookups)

[18:26] <jnthn> pmichaud: Yeah, to me too. I prefer the lexical

[18:26] <pmichaud> s/lexical/attribute/

[18:26] <jnthn> (for the cur_class case)

[18:26] <pmichaud> well, setting the lexical would likely be via store_dynamic_lex

[18:27] <pmichaud> and should I just do the one lexical, or should I do all of the registers that way?

[18:27] <pmichaud> probably just the one, to keep the size down

[18:27] <pmichaud> the downside of setting the lexical is that it really tightly couples !cursor_start to regexes even more than they currently are

[18:29] <jnthn> Just the one, in my view

[18:29] <jnthn> Yes, true. OTOH, the current factoring couples the code tightly to Parrot...

[18:30] *** erkan left
[18:30] *** erkan joined
[18:30] *** erkan left
[18:30] *** erkan joined
[18:30] <pmichaud> at the moment I think I'm more comfortable passing it through the extra structure

[18:30] <pmichaud> I think it'll be faster that way and use a lot less memory

[18:31] <pmichaud> one other possibility would be to use a "static" nqp::list to pass the values

[18:32] <pmichaud> so, just return the list object, and then grab the individual things out via ::atpos.  That's similar to returning a Parcel, at any rate.

[18:32] <jnthn> So long as that's only done for objects, so we don't go boxing the other bits

[18:32] <pmichaud> yes, of course

[18:33] * jnthn mumbles something about the static list and thread safety :)

[18:33] <pmichaud> yeah, that too.  It might not be too bad to create a list on each invocation; that's pretty much what happens now, iiuc

[18:33] <pmichaud> i.e., the return values go into a pmc of some sort

[18:34] *** thou joined
[18:34] <pmichaud> does    .return (foo, bar, baz)   in PIR result in a PMC allocation?

[18:34] <jnthn> No, it populates the existing CallContext. May well be some lower level allocation(s) though.

[18:35] *** varnie left
[18:35] <pmichaud> ...populates the existing CallContext?   that sounds... odd.

[18:35] <jnthn> Hm, I thought it was used for args one way and returns the other

[18:36] <jnthn> oh, maybe not...

[18:37] <pmichaud> well, I think that doing it via a separate QRPA (Parcel) sounds sanest at the moment; can try that and see if it has an impact on performance.

[18:37] <pmichaud> it's closest to what Perl 6 would expect anyway.

[18:38] <pmichaud> and yes, for the objects only; the natives will be fetched from the appropriate objects

[18:38] *** araujo joined
[18:38] *** araujo left
[18:38] *** araujo joined
[18:39] <pmichaud> I suspect going via QRPA is also more portable to other machines when we get there.

[18:39] <pmichaud> or at least simpler to follow.

[18:39] <pmichaud> passing via $!orig/$!target might have the same sort of thread-safety issues as using a shared QRPA

[18:40] <jnthn> true

[18:40] <pmichaud> okay, that gives me a good place to start.

[18:41] *** thou left
[18:47] <GlitchMr> https://gist.github.com/3602814

[18:47] <GlitchMr> I'm thinking too recursively

[18:57] *** _jaldhar left
[19:03] *** GlitchMr left
[19:09] <pmichaud> jnthn: did you already put in the nohandler optimization for while/until/for/etc loops?

[19:10] <pmichaud> looks like "yes"

[19:18] <pmichaud> jnthn++

[19:19] <cognominal> what is the meaning of the box_target trait?

[19:21] *** _jaldhar joined
[19:21] *** stepnem left
[19:21] <jnthn> pmichaud: yes

[19:22] <jnthn> pmichaud: CORE.setting parse time and spectest times are currently at their lowest for quite a while :)

[19:22] <jnthn> cognominal: If you're declaring a type that boxes a native type, it indicates the attribute that holds the boxed value.

[19:23] <pmichaud> jnthn: I'm thinking of changing  :nohandler to be  :loopcontrol(0|1)

[19:23] <moritz> r: class A { has str $a; has str $b is box_target; method Str { "$a|$b" } }; say nqp::box_s(A, 'foo').Str

[19:23] <p6eval> rakudo 54030c: OUTPUT«Cannot look up attributes in a type object␤  in method Str at /tmp/5pcFkmopzV:1␤  in any  at src/gen/BOOTSTRAP.pm:105␤  in block  at /tmp/5pcFkmopzV:1␤␤»

[19:23] <pmichaud> then the dynvar can be $*LOOPCONTROL or something like that

[19:23] *** _jaldhar is now known as jaldhar

[19:23] <moritz> r: class A { has str $a; has str $b is box_target; method Str { "$a|$b" } }; say nqp::box_s('foo', A).Str

[19:23] <p6eval> rakudo 54030c: OUTPUT«|foo␤»

[19:23] <moritz> cognominal: see above

[19:23] *** cognominal left
[19:24] *** nwc10 joined
[19:24] <nwc10> jnthn++

[19:24] *** cognominal joined
[19:24] <pmichaud> anyway, I'm afk to pickup lunch

[19:24] *** cognominal left
[19:24] <jnthn> pmichaud: handlecontrol or so is maybe expliciter.

[19:24] <pmichaud> loophandler, maybe?

[19:24] <moritz> nwc10: I was confused by your latest p6c email, it looked like parsing took much longer (?) than before?

[19:25] <nwc10> yes, it did seem to

[19:25] <nwc10> no, I don't know why

[19:25] <pmichaud> we're using more memory, yes?  that could be why.

[19:25] *** cognominal joined
[19:25] <nwc10> it's reliable. Well, two runs both had similar numbers

[19:25] <cognominal> thx jnthn

[19:25] <moritz> nwc10: but still the overall build was faster?

[19:25] <jnthn> That's odd; here parsing is somewhat faster.

[19:25] *** Moukeddar joined
[19:26] <moritz> that is... surprising

[19:26] <nwc10> we're using a bit more memory than when just Rakudo was on QAST

[19:26] <pmichaud> the raspberry pi is extremely memory/swap bound

[19:26] <nwc10> but yes, the overal build is faster

[19:26] <pmichaud> so anytime we use a bit more memory, things slow down a lot

[19:26] <nwc10> jnthn: you're not swapping like a crazy swappy thing

[19:26] <jnthn> nwc10: True.

[19:26] <nwc10> apparently there's a "network block device" in Linux, but I've not found it yet

[19:27] <nwc10> which would permit sane(r) network swap

[19:27] <nwc10> I couldn't reliably get swapping over NFS to work

[19:27] <nwc10> well, to keep working

[19:27] <nwc10> I have this suspicion that the kernel needed to swap something out in order to be able to free a bit more memory up in order to talk to the swap device.

[19:27] <nwc10> "Oh, bother."

[19:28] <moritz> nwc10: I know I've exported an encrypted disc via the network block device

[19:29] *** Moukeddar_ joined
[19:29] <sorear> nwc10: linux doesn't swap to filesystems, it swaps directly to block devices

[19:29] *** Moukeddar_ left
[19:29] <nwc10> sorear: yes, so I had to make a swap file on the NFS mounted file system, then make a loopback something, and then swapon that

[19:29] <sorear> when you set up a swap file, the VM subsystem asks the file system to allocate blocks for the file and then don't reallocate them for a while

[19:30] <nwc10> which seemed to "work"

[19:30] <nwc10> but actually didn't, when it mattered, after I'd gone to bed

[19:30] <sorear> loopback swap is a Bad Idea for the reason you just mentioned, deadlocks

[19:30] <nwc10> ah OK. :-)

[19:30] *** sirrobert joined
[19:30] <sorear> it _is_ safe to swap to the network block device

[19:31] <nwc10> ah OK

[19:31] <sorear> you're looking for https://www.kernel.org/doc/Documentation/blockdev/nbd.txt

[19:31] <nwc10> thanks

[19:31] <sirrobert> how can I load a module at runtime (with, say, $module = "Foo::Bar") and check if anything gets loaded into the Foo::Bar space?

[19:31] <pmichaud> okay, I'm really afk this time.  @child[1] needs lunch.

[19:31] <pmichaud> bbl

[19:31] <jnthn> sirrobert: require

[19:32] <jnthn> sirrobert: Then a late-bound lookup (maybe the ::('Foo::Bar') way)

[19:32] <sirrobert> hm thanks.  (weird... I had trouble with require a long time ago

[19:32] *** Moukeddar left
[19:32] <jnthn> Occasionally stuff gets fixed ;)

[19:32] <sirrobert> yeah, the ::($module) was working, but I had to do an explicit use

[19:32] <sirrobert> jnthn: heh nod =)

[19:32] <sirrobert> I should have just checked again =)

[19:32] <sorear> Current state: It currently works. Network block device seems to be pretty stable. It was originaly thought that it is impossible to swap over TCP. This turned out not to be true, though the patch required to make it safe has not been forward-ported to any reasonably recent kernel.

[19:32] <sirrobert> require works for me now

[19:33] <jnthn> I think moritz++ did a bunch of require improvements not terribly long ago.

[19:33] <sirrobert> ok, nice

[19:33] <sirrobert> saves me some headache, for sure

[19:33] <jnthn> :)

[19:34] * jnthn digs back into the $dayjob task he procrastinated

[19:37] <sorear> looks like it actually is somewhat used, http://sourceforge.net/mailarchive/forum.php?forum_name=nbd-general&max_rows=25&style=ultimate&viewmonth=201208

[19:37] <dalek> rakudo/nom: 962b9b1 | moritz++ | src/ (3 files):

[19:37] <dalek> rakudo/nom: typed exception for import name clashes

[19:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/962b9b1e4d

[19:38] *** stepnem joined
[19:38] <sorear> chrome sees the large volume of Russian spam and offered to translate the list menu page for me :D

[19:40] <jnthn> Russian spam is handy for maintaining one's ability to parse cyrillic... :)

[19:40] <sirrobert> heh

[19:40] <jnthn> Most of the Russian spam I get is spam about services for sending spam...

[19:44] <moritz> how recursive

[19:45] <moritz> if you have an email address linked to a scientific research institute, you'll soon get spam for silicon wafers

[19:45] *** stepnem left
[19:46] *** szabgab joined
[19:46] <szabgab> hi

[19:46] <moritz> \o szabgab 

[19:47] <moritz> what brings you to IRC?

[19:47] <sorear> o/ szabgab 

[19:47] *** stepnem joined
[19:47] <szabgab> I am so lonely :)

[19:47] <sorear> I got your email but I haven't figure out what to do with it yet

[19:48] <szabgab> also I am trying to figure out when is http://blogs.perl.org/users/perl_6_reports/ going to be published?

[19:48] <szabgab> sorear: say OK and I go ahead with it

[19:48] <sorear> published?

[19:48] <szabgab> sorear: I mean updated

[19:48] <szabgab> the next one

[19:48] <moritz> szabgab: raiph has been doing that in the past

[19:48] *** immortal joined
[19:48] *** immortal left
[19:48] *** immortal joined
[19:48] <szabgab> but taiph is not here now, right?

[19:49] <sorear> raiph?

[19:49] <szabgab> and I'd like to include it in the Perl Weekly that goes out in about 12 hours from now

[19:49] *** erkan left
[19:49] <szabgab> and the p5p weekly is also missing

[19:49] <szabgab> what is this? summer holiday?

[19:49] <moritz> seems like :-)

[19:50] <szabgab> I was wondering if I should keep this tab open :)

[19:50] <szabgab> on the channel, just in case, but I have not done any Perl 6 in a week now

[19:51] <benabik> In the US, Monday is Labor Day.  Many people head out on vacation for the long weekend.

[19:51] <szabgab> this monday?

[19:51] <szabgab> so no one will read the news :|

[19:51] <jnthn> There are people outside of the US :P

[19:52] *** wk_ left
[19:52] <nwc10> jnthn: I'm sure that's a myth created to scare small children

[19:52] <nwc10> (just a myth)

[19:53] <szabgab> according to my stats, that's just a myth :)

[19:58] *** wk joined
[20:01] *** Pleiades` left
[20:01] *** Pleiades` joined
[20:11] *** crab2313 left
[20:13] *** crab2313 joined
[20:15] *** marmay left
[20:24] <sirrobert> any docs on try/catch?  didn't see any on doc.perl6.or

[20:24] <sirrobert> g

[20:25] *** Pleiades` left
[20:25] <jnthn> sirrobert: I gave a talk on it recently: http://jnthn.net/papers/2012-yapceu-exceptions.pdf

[20:25] <moritz> S04 probably

[20:26] <sirrobert> thanks

[20:26] <MikeFair> given grammar G { proto rule stuff { <*> }; rule stuff:sym<version1> { }; rule stuff:sym<version2> }

[20:27] <MikeFair> is there some way I can specifically request a match on stuff:sym<version2> or can I only match <stuff>

[20:27] <moritz> you can only match <stuff>

[20:27] <moritz> another layer of indirection solves the problem

[20:28] *** Pleiades` joined
[20:28] <MikeFair> ok, what was the "match but do not consume" operator on <> again

[20:28] <MikeFair> moritz: hehe ;)  

[20:28] <moritz> <?foo> is look-ahead (match but do not consume)

[20:28] <moritz> <.foo> is match-but-do-not-record-in$/

[20:29] <MikeFair> Right!!

[20:29] <MikeFair> there's a distinction there!!

[20:30] * MikeFair is learning!

[20:31] *** popl joined
[20:31] <sirrobert> why is CATCH in all caps? (ooc)

[20:31] <moritz> because that makes it stand out

[20:31] <moritz> all of our phasers are all-caps

[20:32] <sirrobert> hmm... phasers?

[20:32] <moritz> also it's kind of a mini-namespace

[20:32] <moritz> sirrobert: blocks or statements that are run at special times during the execution

[20:32] <sirrobert> ahh

[20:32] <sirrobert> phase-based blocks

[20:32] <sirrobert> ok, cool

[20:32] <sirrobert> thanks

[20:32] <moritz> BEGIN, INIT, START, FIRST, NEXT, END, ENTER, LEAVE, PRE, POST

[20:32] <moritz> etc.

[20:33] <sirrobert> makes good sense =)  I'm glad to be able to put it into a semantically meaningful bucket

[20:36] *** kaare_ left
[20:38] *** nwc10 left
[20:40] *** crab2313 left
[20:44] <sirrobert> how would I add new tokens to a grammar dynamically? (runtime)

[20:44] <sirrobert> and corresponding actions to the grammar's action class, I guess

[20:44] <jnthn> Whoa. :)

[20:44] <sirrobert> heh

[20:44] <jnthn> Well, they're just classes

[20:44] <jnthn> So, same way you normally add methods to things

[20:44] <jnthn> .^add_method and then remember to .^compose

[20:45] <sirrobert> ok

[20:45] <jnthn> (and tokens are just methods really)

[20:45] <sirrobert> if I .^add_method and .^compose, do existing instances get affected?

[20:45] <jnthn> Yes

[20:45] <sirrobert> so there's no .^add_token?

[20:45] <jnthn> If you want to do stuff per instance, use mixins

[20:45] <jnthn> No, because a token is just a method.

[20:45] <sirrobert> (might be a good addition, just for parallelism)

[20:45] <jnthn> Just one written in regex language.

[20:45] <sirrobert> ok cool... trying it

[20:48] <pmichaud> yay, my lightning talk is (finally) online!

[20:48] <sirrobert> I guess I have to re-write TOP to be able to handle the new token ...

[20:48] <sirrobert> pmichaud: nice =)

[20:48] <sirrobert> where?

[20:48] *** PacoAir left
[20:48] <pmichaud> http://www.youtube.com/watch?v=ILWrbvI8Qfg&feature=plcp   starting at 27:30

[20:51] *** tokuhiro_ joined
[20:55] <sirrobert> pmichaud++: good talk =)  nice work

[20:56] * jnthn wonders if they video'd the lightning talks at YAPC::EU :)

[20:56] <sirrobert> is there any sandboxing work being done in p6?

[20:56] <sirrobert> or I guess you could replace the main grammar with a crippled version?

[20:56] <jnthn> A crippled setting is more likely to be useful

[20:57] <sirrobert> woops, gotta go... later, p6 =)

[20:58] <sorear> rakudo and niecza both have sandboxes

[20:58] <sorear> and both sandboxes have holes big enough to drive trucks through

[21:05] <FROGGS_> pmichaud++ #awesome talk

[21:06] <pmichaud> gabor also gives a really good talk at 45:15

[21:06] <pmichaud> er, szabgab++  :)

[21:07] <pmichaud> make that 45:50

[21:13] *** thou joined
[21:13] <sorear> pmichaud++ great

[21:14] *** SamuraiJack_ left
[21:34] <szabgab> pmichaud: either way thanks :)

[21:36] *** MayDaniel left
[21:49] *** hoelzro is now known as hoelzro|away

[21:49] <pmichaud> szabgab: you're welcome... I really enjoyed that talk :)

[21:50] *** szabgab left
[21:51] <masak> o/

[21:52] <pmichaud> masak: o/

[21:52] * masak has been busy with @friends in the weekend

[21:52] <masak> I'm actually eager to dive back into macros, but sometimes being social takes precedence :)

[21:52] <pmichaud> masak++ # enjoying the big blue room a bit

[21:55] *** average_drifter joined
[21:55] <tadzik> masak! \o/

[21:55] <average_drifter> hello 

[21:55] <average_drifter> I came here today to ask you guys some questions

[21:55] <tadzik> welcome

[21:55] <average_drifter> as you may know, I'm a known and big troll. but today I am going to pose some serious questions

[21:56] <average_drifter> recently I've read on perlmonks a thread

[21:56] <masak> sorry, we didn't know you were a troll.

[21:56] <masak> at least I didn't.

[21:56] <average_drifter> well only sometimes

[21:56] <average_drifter> masak: I am sometimes. but I have not been on #perl6 

[21:56] <masak> anyway, welcome.

[21:56] <average_drifter> masak: on #perl however, I go there and bash them sometimes

[21:56] <masak> we hug trolls here.

[21:56] <average_drifter> anyway

[21:56] <average_drifter> back to my question

[21:56] <masak> :)

[21:57] <average_drifter> masak: yes, but I take my troll shoes off today

[21:57] <average_drifter> because I want to ask some serious question

[21:57] <average_drifter> so as I was saying I read a thread on perlmonks about a possible implementation of Perl5 using LLVM and Clang

[21:57] <average_drifter> and that was considered a very interesting idea because both LLVM and Clang are abundantly funded by Intel

[21:57] <average_drifter> and many other companies

[21:58] <average_drifter> so my question is: What do you guys think the lifetime and possibilities of development of Parrot are

[21:58] <masak> that is a good question.

[21:58] <average_drifter> and why you did not choose LLVM and Clang as the primary tools to build Rakudo

[21:59] <pmichaud> several years ago, a number of people looked at LLVM as a possibility for a backend for Perl 6 in general and the consensus was that it wasn't yet sophisticated enough to be able to handle it.

[21:59] <diakopter> because building rakudo grew out of a desire to implement Perl 6 on parrot.

[21:59] <pmichaud> that may no longer be the case, but certainly it was the case in 2007/2008 when we were working on Rakudo.

[22:00] <pmichaud> today we're looking at making Rakudo work on multiple backends, and a few people have expressed an interest in LLVM as one of the backends.

[22:00] <average_drifter> pmichaud: I understand. and now, looking on LLVM, how do you feel about the decision to use Parrot ? and may that change in the future ?

[22:01] <pmichaud> I don't have any comment about our decision to use parrot then; there really wasn't a "decision" to make.

[22:01] <diakopter> see the "Lessons about LLVM" section of http://qinsb.blogspot.com/2011/03/unladen-swallow-retrospective.html

[22:02] <diakopter> "Unfortunately, LLVM in its current state is really designed as a static compiler optimizer and back end. LLVM code generation and optimization is good but expensive. The optimizations are all designed to work on IR generated by static C-like languages."

[22:03] <average_drifter> ok, so I take it that LLVM isn't really geared towards dyanmic languages

[22:03] <pmichaud> I don't have any plans to abandon Parrot in the future; we'll simply be supporting multiple backends.  It's entirely possible that people will tend to prefer the backends other than Parrot, but we're waiting to see what actually happens rather than speculating at this point.

[22:05] <pmichaud> from discussions at yapc::eu a couple of weeks ago I'm led to believe that llvm may have better support for dynamic languages than it did previously, but I haven't had a chance to investigate that myself.

[22:05] <pmichaud> also, I'll be watching keenly to see what happens with the p5 on llvm effort (if one happens :)

[22:06] *** xinming left
[22:06] <average_drifter> pmichaud: from the discussion on perlmonks it seems that there was a person who attempted this

[22:06] *** bruges left
[22:06] <average_drifter> pmichaud: and the people on perlmonks were taking guesses as to why that person's code has disappeared

[22:06] <average_drifter> pmichaud: or what difficulties he/she encountered

[22:06] *** bruges joined
[22:07] *** dju left
[22:07] <average_drifter> it's somewhat of a mistery to me at this point what exactly happened

[22:07] <average_drifter> pmichaud: have a look http://www.perlmonks.org/?node_id=989940

[22:08] <pmichaud> as a general rule, all of the people I know who work with the p5 codebase in any detail talk about how incredibly difficult it is likely to be to port perl 5 to another runtime platform.  This isn't to say it can't be done, just that it will require a lot of work.

[22:08] *** xinming joined
[22:08] <average_drifter> pmichaud: I know what you mean. I've dived in p5 guts a bit and feel like it's a huuuge "thing".. I can't find a different word to describe it

[22:09] <average_drifter> I'm actually afraid that at some point it will become so *complex* that people will be so scared of it and run away

[22:09] <average_drifter> including myself

[22:09] <average_drifter> but at the moment it's still documented, it's still manageable..

[22:09] <average_drifter> in some ways..

[22:09] *** dju joined
[22:12] <pmichaud> oh, I'm certain things will happen (more)

[22:12] <average_drifter> let me give a small example of what I mean

[22:13] <pmichaud> one of the things that happened at the perl reunification summit two weeks ago was to find ways that we can get perl 5 and perl 6 talking together; and one (of several) approaches will be to write a perl 5 system using perl 6 tools

[22:13] <pmichaud> TimToady++ already has a pretty good start on a perl 5 grammar

[22:13] <diakopter> from the author: "Despite its name, LLVM has little to do with traditional virtual machines, though it does provide helpful libraries that can be used to build them." just JIT. no GC; no object system; no interpreter.

[22:13] <average_drifter> let's suppose someone wanted to make an asynchronous callback mechanism in p5. That stuff is highly non-trivial, you get to deal with multiple Perl interpreters running in different threads, a lot of Internal Perl API, a lot of macros, a lot of debugging, gdb gdb gdb..

[22:14] *** ast joined
[22:15] <diakopter> the title of the commit message where he added that text? "llvm is not a vm"

[22:15] <pmichaud> average_drifter: right.  I'm expecting that there will be a number of efforts to improve asynchronous event handling in p5.

[22:16] <pmichaud> with the eventual goal of having something saner that can be emulated/ported to other environments (and something that p6 can start to build to as well)

[22:17] <sorear> diakopter: at yapc someone tried to tell me that LLVM, in terms of features, was a drop-in replacement for the CLR

[22:17] <diakopter> omg.

[22:17] <sorear> I thanked him while privately thinking "you have no idea what you are talking about, do you"

[22:17] <pmichaud> sorear: heh, I had the same thought.  Of course, I'd heard similar things from this person before so I already discounted it.  :)

[22:23] <geekosaur> ...wat

[22:24] *** stepnem left
[22:48] *** yarp joined
[22:59] *** am0c joined
[22:59] <jnthn> 'night, #perl6

[23:00] <masak> 'night, #perl6

[23:01] *** tokuhiro_ left
[23:02] *** tokuhiro_ joined
[23:05] *** shachaf is now known as SHACHAF

[23:06] *** tokuhiro_ left
[23:18] *** jeffreykegler joined
[23:19] *** c1sung left
[23:21] *** benabik left
[23:22] *** benabik joined
[23:23] *** tokuhiro_ joined
[23:27] *** c1sung joined
[23:28] *** tokuhiro_ left
[23:37] *** yarp left
[23:41] <sjn> 's funny and sad, named parameters have been mentioned as a todo

[23:41] <sjn>              in perlsub.pod since the 90s

[23:45] *** Circlepuller joined
[23:46] *** Circlepuller_ left
