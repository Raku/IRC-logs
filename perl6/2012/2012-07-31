[00:11] *** benabik left
[00:22] *** benabik joined
[00:23] <colomon> sorear: I mean lc, uc, tc, foldcase, etc.

[00:25] <sorear> oh!

[00:27] <TimToady> colomon: http://irclog.perlgeek.de/perl6/2012-07-30#i_5861524 seems like a bug; shouldn't the a's total to 5?

[00:29] <TimToady> oh, no, it

[00:30] <colomon> n: my $x = KeyBag.new({a => 3}); my $y = KeyBag.new({a => 2}); my $z = ($x ⊎ $y);  say "z = ", $z;

[00:30] <p6eval> niecza v19-15-g051783d: OUTPUT«z = bag("a" => 5)␤»

[00:30] <TimToady> it's the absence of ⨄ that is maybe the bug

[00:30] <TimToady> wait, where did you find that

[00:30] <colomon> TimToady: which?

[00:31] <TimToady> nevermind, got the wrong op

[00:31] <TimToady> got the "uppercase" on 

[00:31] <TimToady> *one

[00:31] <TimToady> which presumably means the same as [⊎]  :)

[00:32] <sorear> colomon: wondering if you might be interested in this month's release

[00:32] * colomon has to admit that the various bag union operators are virtually indistinguishable in the IRC font he uses

[00:32] <colomon> sorear: when should it be?

[00:32] *** skids joined
[00:32] <TimToady> much like Σ is just [+]

[00:33] <colomon> TimToady: wait, what?  (I mean, I understand the sum, but not the set/bag operator equivalent.)

[00:34] <TimToady> .u ⨄

[00:34] <phenny> U+2A04 N-ARY UNION OPERATOR WITH PLUS (⨄)

[00:34] <TimToady> I take the N-ARY to mean "reduction"

[00:34] <colomon> huh

[00:35] <TimToady> as opposed to the lowercase one, which is binary

[00:35] <TimToady> .u ⊎

[00:35] <phenny> U+228E MULTISET UNION (⊎)

[00:35] <colomon> agh, what?!?

[00:35] <TimToady> I'm not suggesting anything is wrong

[00:36] <TimToady> I just forgot ordinary union with bags was "max"

[00:36] * colomon wildly increases the size of his font, trying to tell the difference between the two.

[00:37] <colomon> I've gone as big as I can, and I still can't tell the visual difference between those two symbols.

[00:37] <TimToady> maybe your font just uses the same glyph

[00:38] <TimToady> the N-ARY one is just uppercase sized here instead of lowercase sized

[00:38] <colomon> which one does niecza implement? (he asked, dreading the answer)

[00:38] <colomon> .u ⊎

[00:38] <phenny> U+228E MULTISET UNION (⊎)

[00:38] <colomon> \o

[00:38] <colomon> \o/

[00:38] <TimToady> "I'm not suggesting anything is wrong"

[00:39] * colomon stops panicking

[00:39] <colomon> .u ⊍

[00:39] <phenny> U+228D MULTISET MULTIPLICATION (⊍)

[00:39] <colomon> I seem to recall mjd thought multiset multiplication was completely useless.

[00:40] <TimToady> I seem to recall thinking the same thing :)

[00:40] <colomon> in the discussion we had back when I added ≼ and ≽

[00:41] <colomon> I just assumed that if someone bothered to assign a unicode codepoint to it, it must be used somewhere.  :)

[00:41] <TimToady> all I can figure is that, if you're doing multiset multiplication, the numbers you have are the viewpoint from a different dimension

[00:41] <TimToady> so looking from the x direction I see 2 a's, and looking from the y direction I see 3

[00:41] <TimToady> so it's only good for when counting projection images

[00:42] <moritz> japhb_: I didn't notice we had non-generated files in html/

[00:42] <moritz> japhb_: I'll probably undo the commits and simply place favicon.ico into html/ directly

[00:42] <TimToady> btw, I don't want people to have to say "use Set", on the "math just comes" principle

[00:42] <japhb_> moritz, yeah, the bits needed to support the autocomplete searching

[00:43] <colomon> sorear: about the case routines, the C# ones appear to just be wrong.  I've implemented more correct versions the same way I did tc, but that approach (looking up the table for each character) is wildly inefficient.

[00:43] <TimToady> if unicode slows down our compilers drastically, we need to fix our compilers

[00:43] <japhb_> Fair enough.  I'm happy either reverting, or moving forward to having all static files in html-files, and html/ being always completely generated, depending on whether you want it to act like a blib/ or not.

[00:44] <colomon> TimToady: It's just my implementations which suck.

[00:44] <colomon> There are very obvious ways to improve the code, they just make it a bit trickier to implement.

[00:44] <moritz> japhb_: mostly I want an easy way to clean out html/ when some pod files or routines are deleted or renamed

[00:45] <japhb_> Time for a Makefile with 'html' and 'clean' targets?

[00:45] <japhb_> Maybe 'sync' and 'missing' too

[00:52] *** am0c joined
[00:56] <dalek> doc: a792008 | moritz++ | html (2 files):

[00:56] <dalek> doc: Revert "[htmlify] add copying of static files; add favicon"

[00:56] <dalek> doc: 

[00:56] <dalek> doc: This reverts commit d5477a86d741516eac6225eb4e75e7d1be49f3e9.

[00:56] <dalek> doc: 

[00:56] <dalek> doc: There are still lots of static files in html/, so toss this

[00:56] <dalek> doc: attempt which just makes things more complicated

[00:56] <dalek> doc: review: https://github.com/perl6/doc/commit/a792008672

[00:56] <dalek> doc: d0f8a02 | moritz++ | html/favicon.ico:

[00:56] <dalek> doc: add favicon

[00:56] <dalek> doc: review: https://github.com/perl6/doc/commit/d0f8a02489

[00:56] <dalek> doc: ee7934d | moritz++ | .gitignore:

[00:56] <dalek> doc: make .gitignore more specific

[00:56] <dalek> doc: review: https://github.com/perl6/doc/commit/ee7934d716

[00:58] <moritz> r: say Grammar.^mro

[00:58] <p6eval> rakudo c1bfbb: OUTPUT«Grammar() Cursor() Any() Mu()␤»

[01:02] *** benabik left
[01:05] <dalek> doc: 8a04f29 | moritz++ | lib/Grammar.pod:

[01:05] <dalek> doc: document Grammar

[01:05] <dalek> doc: review: https://github.com/perl6/doc/commit/8a04f291f3

[01:06] *** scott___ joined
[01:06] *** japhb_ left
[01:06] <moritz> n: say Grammar ~~ Cursor

[01:06] <p6eval> niecza v19-15-g051783d: OUTPUT«True␤»

[01:08] *** Guest47300 left
[01:11] <dalek> doc: c03644e | moritz++ | lib/Cursor.pod:

[01:11] <dalek> doc: document Cursor

[01:11] <dalek> doc: review: https://github.com/perl6/doc/commit/c03644ea76

[01:12] <moritz> if Cursors have a public API, and anybody knows it, please add it :-)

[01:12] *** Khisanth joined
[01:13] <ruoso> great news on the switch to QAST... I imagine the ammount of PIR in rakudo is now much smaller

[01:13] <moritz> ruoso: not in rakudo directly, but in its toolchain

[01:13] *** vinian joined
[01:14] <moritz> the PAST -> QAST and POST -> PIRT switches got rid of the last big remaining chunks of PIR code

[01:14] <ruoso> that's nice...

[01:14] <ruoso> so porting rakudo to different runtimes is now a real possibility

[01:17] <moritz> aye

[01:17] <moritz> QAST also has less parrotisms than PAST

[01:21] <ruoso> so I guess the first step in such adventure would be to port nqp itself

[01:22] <moritz> well, one possible first step

[01:22] <moritz> you can also run the nqp-on-parrot to generate whatever code you want to generate

[01:23] <ruoso> I guess that would be an intermediate step anyway

[01:23] <ruoso> since nqp would need to emit code for other vm prior to running in other vm

[01:23] <ruoso> (i mean, for the port to be useful)

[01:24] <moritz> right

[01:24] <ruoso> is there much pir emitting in rakudo? or is that all hidden behind QAST?

[01:25] <pmichaud> there's very little pir in rakudo itself.

[01:25] <ruoso> includding in rakudo's output?

[01:26] <pmichaud> there are a few places that hide it behind "pir::".  There are one or two Q:PIR's left.

[01:26] <pmichaud> I don't quite understand "in rakudo's output".  We still compile to PIR, yes.

[01:26] <moritz> and most references to PIR in Perl6::Actions are wrapped in QAST::VM.new(pirop => $whatever)

[01:26] <pmichaud> but compiling to PIR is a function of the backend, not of anything specific to rakudo.

[01:27] <moritz> pmichaud: I guess the motivation behind the question was, how much would you need to modify Actions.pm to generate something else than PIR

[01:27] <ruoso> yes...

[01:27] <moritz> a quick glance tells me that most direct PIR stuff is related to exceptions

[01:27] <moritz> which is pretty VM specific

[01:27] <pmichaud> not too much, although you still have to replace the custom C-ops, too.

[01:28] * moritz tries to sleep again, now that $daughter has finally done the same

[01:33] <pmichaud> TimToady: STD.pm6 has a few instances of things like        token trait_mod:handles { <sym>:s <term> }

[01:34] <pmichaud> am I understand correctly that :s there doesn't have any effect other than to add a <.ws> after <term>; i.e., the above is equivalent to

[01:34] <pmichaud> token trait_mod:handles { <sym> <term> <.ws> }

[01:34] <pmichaud> ?

[01:35] <pmichaud> (I realize that particular instance can now be better written as   rule trait_mod:handles { <sym> <term> } ... I just want to confirm that the whitespace after :s isn't treated as sigspace, per S05)

[01:36] <pmichaud> afk, walk, bbiaw

[01:37] *** plobsing joined
[01:44] *** vinian left
[01:50] <TimToady> I think when that was written :s did introduce <.ws> directly after

[01:50] <TimToady> in any case, that seems to be the intent there

[01:54] <TimToady> and, in fact, the 'endsym' for handles requires whitespace there

[01:54] <TimToady> since term doesn't traverse whitespace, I'd say STD is still turning on :s directly after

[01:55] <TimToady> iirc, the :s not turning off whitespace right after was a brief transitional form to the current formulation of not doing <.ws> unless something real was matched

[01:56] <diakopter> is #perl6 in a punctuation or equilibrium

[01:57] <TimToady> Gould only knows

[01:59] *** plobsing left
[02:00] *** vinian joined
[02:02] * TimToady should switch STD to the new sigspace policy..

[02:06] *** benabik joined
[02:07] *** gongyiliao left
[02:07] *** gongyiliao joined
[02:36] *** Psyche^ joined
[02:38] *** Patterner left
[02:38] *** Psyche^ is now known as Patterner

[02:40] <sorear> colomon: release today-ish.

[02:42] <colomon> sorear: oh.  I've got to get to bed in the next couple of minutes, I didn't get enough sleep last night and had a long day of three-year-old wrangling today.  And if I actually had any brainpower at the moment, I'd really need to be $working anyway...

[02:44] <sorear> colomon: fair

[02:58] *** orafu joined
[03:02] *** gongyiliao left
[03:14] *** scott___ left
[03:14] *** scott___ joined
[03:20] *** adu joined
[03:25] <pmichaud> TimToady: so, STD.pm6 is transitional and S05 is correct (whitespace after :s and other modifiers isn't sigspace)?  That would definitely be my preference.

[03:41] *** vinian left
[04:01] *** gongyiliao joined
[04:05] *** vinian joined
[04:06] *** larks joined
[04:08] *** larks left
[04:08] *** larks joined
[04:17] *** telex joined
[04:24] <TimToady> spec is correct, sigspace is sigspace only after a "real" match of some kind

[04:24] <TimToady> working on a STD patch currently

[04:28] <TimToady> heh, now it won't parse /:i foo/  :)

[04:28] *** telex left
[04:29] <TimToady> hmm, roast has a lot of this error:

[04:29] <TimToady> Placeholder variable $^k may not be used here because the surrounding block takes no signature at /home/larry/perl6/roast/S03-operators/bag.t line 7:

[04:29] <TimToady> ------>     $x.keys.sort.map({ $^k ~ ':' ~ $x{⏏$^k} }).join(' ')

[04:30] <TimToady> maybe my t/spec is out of date though...

[04:30] *** cognominal__ joined
[04:31] <TimToady> actually, there are still 5 instances of that

[04:33] *** cognominal_ left
[04:37] *** telex joined
[04:40] *** cognominal_ joined
[04:43] *** cognominal__ left
[04:44] *** adu left
[04:55] *** jaldhar joined
[04:57] <dalek> roast: 4d00912 | larry++ | S0 (4 files):

[04:57] <dalek> roast: $^k not legal inside hash subscript

[04:57] <dalek> roast: review: https://github.com/perl6/roast/commit/4d0091229f

[05:05] <dalek> std: f43a358 | larry++ | STD.pm6:

[05:05] <dalek> std: 1st whack at new sigspace semantics

[05:05] <dalek> std: 

[05:05] <dalek> std: Only regex tokens that set $*SIGOK will enable following sigspace.

[05:05] <dalek> std: review: https://github.com/perl6/std/commit/f43a358f16

[05:21] *** birdwindupbird joined
[05:33] *** aloha joined
[05:44] *** kaleem joined
[06:04] *** xinming joined
[06:24] *** SamuraiJack joined
[06:27] <arnsholt> r: my Int foo { ... }; say 'alive'

[06:27] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Malformed my␤at /tmp/bB4PKvFJYa:1␤»

[06:28] <arnsholt> r: Int sub foo { ... }; say 'alive'

[06:28] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/DHNdeoiJOX:1␤»

[06:44] *** xinming left
[06:50] *** wtw joined
[06:51] *** kaare_ joined
[07:09] *** brrt joined
[07:12] *** cognominal_ left
[07:12] *** cognominal joined
[07:47] *** brrt left
[07:47] *** bbkr joined
[07:47] *** bbkr left
[07:48] *** xinming joined
[07:56] *** crab2313 joined
[07:57] *** fhelmberger joined
[08:01] <moritz> r: my Int sub foo() { }; say &foo.returns

[08:01] <p6eval> rakudo c1bfbb: OUTPUT«Mu()␤»

[08:05] <jnthn> morning o/

[08:05] <moritz> \o

[08:05] <japhb> o/

[08:09] *** GlitchMr joined
[08:14] <dalek> rakudo/io-pipe: 271741a | (Geoffrey Broadwell)++ | src/core/IO.pm:

[08:14] <dalek> rakudo/io-pipe: Absolute minimum changes needed to support opening pipes for reading and writing

[08:14] <dalek> rakudo/io-pipe: review: https://github.com/rakudo/rakudo/commit/271741a999

[08:15] <japhb> I need to head to bed, and have only a very slow computer here ... can someone please spectest the above commit?

[08:15] <moritz> japhb: will do

[08:15] <japhb> ++moritz  # Many thanks

[08:16] <japhb> good night &

[08:16] <moritz> sleep weel japhb++

[08:16] <moritz> *well

[08:18] <dalek> doc: 4d92362 | (Geoffrey Broadwell)++ | type-graph.txt:

[08:18] <dalek> doc: Fill in role lists for Perl6::Metamodel::*HOW

[08:18] <dalek> doc: review: https://github.com/perl6/doc/commit/4d92362c2b

[08:19] *** daxim joined
[08:25] <masak> good antenoon, #perl6

[08:28] <tadzik> good noonteraf, masak 

[08:29] <crab2313> masak: \o

[08:30] <dalek> perl6.org: fce57f6 | (Gabor Szabo)++ | source/documentation/index.html:

[08:30] <dalek> perl6.org: link to the perl6maven site instead of the old pages on szabgab.com

[08:30] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/fce57f6942

[08:32] <masak> tadzik: I see what you did there

[08:33] <moritz> \o masak, tadzik, crab2313 

[08:33] <moritz> szabgab++ # blogging, p6maven

[08:33] <moritz> and just yesterday I wrote docs for Junction :-)

[08:33] *** birdwindupbird left
[08:35] *** birdwindupbird joined
[08:36] <dalek> doc: 792ea01 | moritz++ | lib/Junction.pod:

[08:36] <dalek> doc: [Junction] add See Also section with links

[08:36] <dalek> doc: review: https://github.com/perl6/doc/commit/792ea015a7

[08:39] *** dakkar joined
[08:51] *** dayangkun joined
[09:03] *** kaare_ left
[09:11] *** bbkr joined
[09:14] *** Coleoid joined
[09:19] *** fgomez left
[09:20] *** dayangkun left
[09:29] <arnsholt> moritz++ # trait-exceptions

[09:42] *** bbkr left
[09:51] *** Vakaris joined
[09:51] <moritz> arnsholt: does it work now for you?

[09:54] <arnsholt> The of case looks like it works as expected

[09:54] <arnsholt> Same segfault issue in the returns handler though

[09:59] *** sergot joined
[10:00] <sergot> hi o/

[10:00] <tadzik> \o

[10:00] <moritz> arnsholt: returns is a trait_mod on Routine, right?

[10:06] <masak> sergocie! \o/

[10:10] <sergot> \o/

[10:11] *** vinian left
[10:12] <arnsholt> moritz: Yeah

[10:12] <arnsholt> The problem seems to be triggered by the exception throwing, somewhere above the trait_mod stuff

[10:13] <arnsholt> I'm digging around in gdb, but I don't have a good idea what's going on yet

[10:13] <moritz> arnsholt: want to push the whole thing to a branch, so that I can play with it?

[10:13] <moritz> not that I have a track record in fixing segfaults or anything, but I did work with exceptions before :-)

[10:16] <arnsholt> I think the patch in https://gist.github.com/3206774 is all there is to it

[10:16] <arnsholt> My findings so far are:

[10:17] <arnsholt> 1) The segfault happens because something that's not a sixmodelobject gets passed to Rakudo_cont_decontainerize

[10:17] <arnsholt> 2) The decontainerization is part of inspecting the arguments for multidispatch

[10:18] <arnsholt> 3) There's a single argument, and a single md candidate which can only take exactly one argument

[10:18] <moritz> could it be that nqp::isnull($returns); returns a parrot integer, and prefix:<not> dispatching dies?

[10:19] <arnsholt> Oooh. That may very well be it!

[10:19] * moritz tries a fix

[10:19] <moritz> ... unless nqp::p6bool(nqp::isnull(...))

[10:21] <arnsholt> Oooh, looks like it

[10:21] <moritz> it gets through the parse stage that way

[10:22] <moritz> (it could even be that 'unless' doesn't need the nqp::p6bool thingy, being provided by the compiler. But prefix:<not> is a normal multi)

[10:23] <moritz> phenny: tell japhb spectest on the io-pipe branch is clean here. Feel free to merge!

[10:23] <phenny> moritz: I'll pass that on when japhb is around.

[10:24] <arnsholt> Yep. Looks like it's working

[10:24] <moritz> $ ./perl6 -e 'sub f(--> Str) returns Int { }'

[10:24] <moritz> ===SORRY!===

[10:24] <moritz> Redeclaration of return type for f (previous return type was Str)

[10:24] <moritz> at -e:1

[10:25] <arnsholt> Awesome!

[10:25] *** scott___ left
[10:25] <moritz> spectesting now

[10:25] <jnthn> arnsholt++, moritz++

[10:27] <arnsholt> Looks like the problem is that nqp::isnull became turned into a Parrot PMC

[10:27] <arnsholt> I'm guessing assignment to an intermediate P register turned it into an int PMC

[10:27] <moritz> in Integer probably

[10:28] <moritz> s/in/an/

[10:28] <arnsholt> Yeah

[10:32] *** crab2313 left
[10:32] *** araujo joined
[10:35] <moritz> spectest passes

[10:38] *** mucker joined
[10:39] *** JimmyZ joined
[10:49] <JimmyZ> hello,  anchor with space doesn't suppot firefox, ie: http://doc.perl6.org/type/Array#Methods%20supplied%20by%20role%20Positional

[10:50] <jnthn> I'm pretty sure it's firefox that's doing the non-supporting :P

[10:51] <masak> it's also not supported by HTML 4.01.

[10:51] <mhasch> no, I mentioned it a few days ago.  The anchor would have to have spaces where the URL has %20 for the link to work.

[10:51] <mhasch> better no spaces at all

[10:52] <JimmyZ> well, they should be replaced by '-' or something

[10:53] <mhasch> precisely. moritz might accept a patch :-)

[10:54] <masak> I'm absolutely sure he will.

[10:55] <masak> actually, either of us will. :)

[10:55] <mhasch> preferring - over _ would be the perl6ish thing to do, too ...

[10:55] <arnsholt> jnthn: One thing that mystifies me, now that I've thought about it: Why does the code explode in trait_mod:<returns> but not trait_mod:<of>? They had identical bodies and signatures...

[11:07] <jnthn> arnsholt: That is mysterious...maybe just that one gets triggered in the setting compilation but not the other?

[11:07] *** MayDaniel joined
[11:09] *** sftp joined
[11:09] *** Vakaris left
[11:14] *** Vakaris joined
[11:21] <arnsholt> Right. The world behaves a bit differently when you're compiling the setting, I suppose

[11:22] *** dbr joined
[11:24] * arnsholt tries something

[11:26] <masak> Fortress project wrapping up: https://blogs.oracle.com/projectfortress/entry/fortress_wrapping_up -- http://lambda-the-ultimate.org/node/4570

[11:26] <masak> I've always liked Fortress for what it tries to do.

[11:28] <masak> "There is much work yet to be done in designing and implementing programming languages, and we believe that many of the ideas mentioned above will be important, in some form, in future language designs." +1

[11:29] <arnsholt> jnthn: Yeah, that's it. Changing a returns to of in setting code triggers the segfault again

[11:29] *** kaare_ joined
[11:31] *** Vakaris left
[11:32] <masak> from the lambda-the-ultimate thread: "Productizing languages is difficult".

[11:38] <moritz> arnsholt: do you want to commit the patch, or should I?

[11:38] <arnsholt> I can commit it

[11:39] <dalek> rakudo/nom: 1b2db80 | (Arne Skjærholt)++ | src/core/traits.pm:

[11:39] <dalek> rakudo/nom: Throw an exception when a sub gets assigned several return types.

[11:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1b2db80e26

[11:40] *** Vakaris joined
[11:40] <arnsholt> I tried to implement the "Int sub foo()" case as well, but it required more grammar tuits than I had right then

[11:41] <moritz> arnsholt: usually the typ constraint is in $*OFTYPE somehow

[11:42] * moritz tries a patch

[11:42] <arnsholt> std: Int sub foo { ... }

[11:42] <p6eval> std f43a358: OUTPUT«[31m===[0mSORRY![31m===[0m␤Two terms in a row (listop with args requires whitespace or parens) at /tmp/id5I2dGN4D line 1:␤------> [32mInt [33m⏏[31msub foo { ... }[0m␤    expecting any of:␤        infix or meta-infix␤    infixed function␤       statement modifier

[11:42] <p6eval> ..loop␤Parse f…

[11:42] <moritz> r: my Int sub foo() { }

[11:42] <p6eval> rakudo c1bfbb:  ( no output )

[11:43] <moritz> r: my Int sub foo() { }; say &foo.returns

[11:43] <p6eval> rakudo c1bfbb: OUTPUT«Mu()␤»

[11:43] <arnsholt> Ah, right

[11:43] <jnthn> It always has to has a scope declarator first

[11:44] <arnsholt> Quite

[11:44] <jnthn> .oO( my oh my, the state of my English... )

[11:44] <moritz> it might be as simple as $code.signature.set_returns($*OFTYPE.ast) if $*OFTYPE;

[11:44] * moritz tries that patch

[11:44] *** JimmyZ left
[11:44] <arnsholt> Yeah, that should do it, and an exception if the signature already has a value

[11:45] <moritz> right

[11:46] <moritz> interesting that the Fortress folks found STM to be a good choice

[11:46] <moritz> because the last things I've heard about STM was that it was overhyped and doesn't work too well in practise

[11:47] <moritz> maybe they "just" did it right :-)

[11:47] <moritz> the "Symmetric multimethod dispatch" is probably close to what p6 has

[11:49] <moritz> $ ./perl6 -e 'my Int sub f() { }; say &f.returns'

[11:49] <moritz> Int()

[11:49] <moritz> now for exceptions...

[11:49] *** JimmyZ joined
[11:52] *** skids left
[11:58] *** Vakaris left
[12:03] *** gongyiliao left
[12:08] *** Chillance joined
[12:09] *** Coleoid left
[12:13] *** Vakaris joined
[12:15] *** sftp left
[12:24] *** spider-mario joined
[12:24] <pmichaud> good morning, #perl6

[12:25] <Pleiades`> morning!

[12:25] <JimmyZ> morning, pm

[12:25] <moritz> good am, pm

[12:26] <jnthn> o/ Pm

[12:29] *** GlitchMr left
[12:29] *** Vakaris left
[12:31] <moritz> my currently-in-the-works patch already found a roast bug

[12:31] <arnsholt> Nifty!

[12:31] *** GlitchMr joined
[12:31] <moritz> my List sub f { return () } # and it expected a call to that to live

[12:32] *** JimmyZ left
[12:33] *** JimmyZ joined
[12:41] *** JimmyZ_ joined
[12:44] *** JimmyZ left
[12:44] *** JimmyZ_ is now known as JimmyZ

[12:48] <dalek> rakudo/trait-exceptions: 3a20b76 | moritz++ | / (2 files):

[12:48] <dalek> rakudo/trait-exceptions: remove some deprecated subs and methods

[12:48] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/3a20b76b46

[12:48] <dalek> rakudo/trait-exceptions: f4b83df | moritz++ | tools/build/NQP_REVISION:

[12:48] <dalek> rakudo/trait-exceptions: bump NQP revision to get dyncall callbacks, arnsholt++

[12:48] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/f4b83df6d7

[12:48] <dalek> rakudo/trait-exceptions: 705fabb | (Felix Herrmann)++ | src/core/Main.pm:

[12:48] <dalek> rakudo/trait-exceptions: make Main.pm output a usage message on an unexpected named argument instead of bind failing

[12:48] <dalek> rakudo/trait-exceptions: 

[12:48] <dalek> rakudo/trait-exceptions: Signed-off-by: Moritz Lenz [email@hidden.address]
[12:48] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/705fabb531

[12:48] <dalek> rakudo/trait-exceptions: 07faa45 | moritz++ | / (4 files):

[12:48] <dalek> rakudo/trait-exceptions: Merge branch 'nom' into trait-exceptions

[12:48] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/07faa456cd

[12:48] <dalek> rakudo/nom: 6441778 | moritz++ | src/ (3 files):

[12:48] <dalek> rakudo/nom: refactor redeclaration of return type exceptions, enable "my Type sub f" return types

[12:48] <dalek> rakudo/nom: 

[12:48] <dalek> rakudo/nom: this refactors the check if a signature has a return type into

[12:48] <dalek> rakudo/nom: a has_returns method in Signature, which reduces the monkey-getattr accesses

[12:48] <dalek> rakudo/nom: into Signature

[12:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6441778f61

[12:48] <dalek> roast: 9db8364 | moritz++ | S06-routine-modifiers/scoped-named-subs.t:

[12:48] <dalek> roast: fix a return type bug

[12:48] <dalek> roast: review: https://github.com/perl6/roast/commit/9db836433b

[12:48] <dalek> roast: 864c54b | moritz++ | S04-exceptions/fail.t:

[12:48] <dalek> roast: fudge a test for rakudo which we passed for the wrong reasons before

[12:48] <dalek> roast: review: https://github.com/perl6/roast/commit/864c54b6ed

[12:48] <dalek> roast: 75c081f | moritz++ | S32-exceptions/misc.t:

[12:48] <dalek> roast: tests for multiple return type exceptions

[12:48] <dalek> roast: review: https://github.com/perl6/roast/commit/75c081fd69

[12:49] <moritz> oops, I didn't mean to push to trait-exceptions, sorry

[12:50] *** atrodo joined
[12:50] <arnsholt> Ah, good refactor. moritz++

[12:51] <arnsholt> moritz: I recently set git config --global push.default current to avoid that =)

[12:51] <moritz> arnsholt++ # thanks

[12:58] <dalek> rakudo/nom: 85541f0 | moritz++ | docs/ChangeLog:

[12:58] <dalek> rakudo/nom: update ChangeLog

[12:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85541f0b68

[12:59] *** PacoAir joined
[13:01] *** mscha joined
[13:01] <mscha> perl6: my $a == 2|3; say $a==2; say $a!=2;

[13:01] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Preceding context expects a term, but found infix = instead at /tmp/IeJyCpetGD line 1:␤------> [32mmy $a =[33m⏏[31m= 2|3; say $a==2; say $a!=2;[0m␤␤Parse failed␤␤»

[13:01] <p6eval> ..rakudo c1bfbb: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead␤at /tmp/uwbWTlW7pm:1␤»

[13:02] <mscha> perl6: my $a = 2|3; say $a==2; say $a!=2;

[13:02] <p6eval> niecza v19-15-g051783d: OUTPUT«any(Bool::True, Bool::False)␤False␤»

[13:02] <p6eval> ..rakudo c1bfbb: OUTPUT«any(True, False)␤False␤»

[13:03] <mscha> perl6: say ((2|3) != 2);

[13:03] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«False␤»

[13:03] <moritz> mscha: negated operators are special-cased for autothreading

[13:03] <moritz> eg  $a != $b  behaves as   !($a == $b)

[13:03] <mscha> But is this correct?  Any of 2 or 3 IS unequal to 2, no?

[13:03] <moritz> otherwise it would be very confusing

[13:04] *** PacoAir left
[13:04] <moritz> people have written things like  if $a != any(1, 2, 3, 4) { }

[13:04] <moritz> and wondered why it was always True

[13:04] <mscha> Ah, that's a good point.  Very confusing if !(a == b) != (a != b)

[13:06] <moritz> I must admit that in the beginning I was opposed to the change, but I now see the wisdom of it. TimToady++

[13:06] *** JimmyZ_ joined
[13:06] *** PacoAir joined
[13:08] *** JimmyZ left
[13:08] *** JimmyZ_ is now known as JimmyZ

[13:19] <moritz> p6rd: upcoming

[13:19] <p6rd> niecza 2012-07-30, parrot 2012-08-21, rakudo 2012-08-23

[13:19] <mscha> perl6: my @grades = <A B A A F C C>; say any(@grades) ne "A"; # I'm a straight A student!

[13:19] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«False␤»

[13:19] <moritz> eeks, reports a date from the past :(

[13:20] <moritz> perl6: my @grades = <A B A A F C C>; say all(#grades) eq 'A'; # not so :-)

[13:20] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2, near ""␤»

[13:20] <p6eval> ..niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unable to parse argument list at /tmp/2kDjVuHHpX line 1:␤------> [32mmy @grades = <A B A A F C C>; say all([33m⏏[31m#grades) eq 'A'; # not so :-)[0m␤Couldn't find final ')'; gave up at /tmp/2kDjVuHHpX line 1 (EOF):␤-----…

[13:20] <moritz> perl6: my @grades = <A B A A F C C>; say all(@grades) eq 'A'; # not so :-)

[13:20] <p6eval> rakudo c1bfbb: OUTPUT«all(True, False, True, True, False, False, False)␤»

[13:20] <p6eval> ..niecza v19-15-g051783d: OUTPUT«all(Bool::True, Bool::False, Bool::True, Bool::True, Bool::False, Bool::False, Bool::False)␤»

[13:20] <moritz> perl6: my @grades = <A B A A F C C>; say so all(@grades) eq 'A'; # not so :-)

[13:20] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«False␤»

[13:22] <mscha> I guess it's impossible to make everything DWIM with junctions.

[13:22] *** bluescreen10 joined
[13:23] <moritz> it's impossible to make everything DWIM, period :-)

[13:24] <moritz> which hilights the need for good docs

[13:25] *** skids joined
[13:28] *** JimmyZ_ joined
[13:30] *** JimmyZ left
[13:30] *** JimmyZ_ is now known as JimmyZ

[13:33] <dalek> doc: de7f6db | moritz++ | lib/Junction.pod:

[13:33] <dalek> doc: explain autothreading and negated operators

[13:33] <dalek> doc: review: https://github.com/perl6/doc/commit/de7f6db001

[13:34] <[Coke]> me;

[13:35] <masak> mscha: any(...) ne is to be read as "not any equal" (which was false in your case), not as "any not equal" (which was true).

[13:35] <[Coke]> ww

[13:36] <moritz> masak: we've discussed that before mscha++'s example

[13:36] * [Coke] reads gabor's maven artile about junctions and is left wondering "if they're like sets, why do we have sets and junctions".

[13:36] <[Coke]> *article

[13:36] <moritz> they aren't like sets :/

[13:37] <pmichaud> yeah, we've been through that a few times before.

[13:37] <pmichaud> I wonder if it makes more sense to think of them as predicates.

[13:37] *** benabik left
[13:37] <pmichaud> or existential quantifiers

[13:39] *** benabik joined
[13:40] *** tokuhiro_ joined
[13:43] *** tokuhiro_ left
[13:43] *** tokuhiro_ joined
[13:45] <dalek> nqp/sigsp: ba8d67c | pmichaud++ | src/QRegex/P6Regex/Grammar.nqp:

[13:45] <dalek> nqp/sigsp: Update to handle leading spaces in p6regex arglist.

[13:45] <dalek> nqp/sigsp: review: https://github.com/perl6/nqp/commit/ba8d67cb75

[13:52] *** JimmyZ left
[13:53] * pmichaud adds a comment re junctions/sets to the p6maven article

[13:59] <moritz> http://doc.perl6.org/type/Junction now explains negated ops + autothreading

[14:00] <masak> what's the url to szabgab's article?

[14:00] <pmichaud> http://perl6maven.com/perl6-is-a-value-in-a-given-list-of-values

[14:00] <masak> thank you.

[14:01] * pmichaud reads the doc

[14:02] *** fhelmberger left
[14:03] <masak> in szabgab's defense, he just says "Similar to a set." -- and only when talking about the un-orderedness of junctions.

[14:03] <moritz> is there a way to specify fallbacks for lexical lookups in Perl 6? like AUTOLOAD/CANDO for methods

[14:03] <moritz> (not that I particularly want one, just curious)

[14:03] <masak> r: my $weekdays; say $weekdays.^name

[14:03] <p6eval> rakudo c1bfbb: OUTPUT«Any␤»

[14:04] <masak> r: my $weekdays = any <Monday Tuesday Wednesday Thursday Friday Saturday Sunday>; say $weekdays.^name

[14:04] <p6eval> rakudo c1bfbb: OUTPUT«Junction␤»

[14:04] <jnthn> moritz: Don't believe so. A lot hangs off the lexpad being immutable from CHECK time on.

[14:05] <jnthn> Like

[14:05] <jnthn> r: foo()

[14:05] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&foo' called (line 1)␤»

[14:05] <masak> moritz: if you specified such a fallback for lexical lookups, would it then be impossible to get an error when typo'ing a variable?

[14:05] <moritz> masak: only if the fallback creates the error

[14:05] <pmichaud> masak: I agree that "similar to a set" is appropriate.  However, my experience has been that without the added caution against thinking about junctions as sets, a lot of newbies make the association "junction" == "set" and things get complicated from there.

[14:05] <masak> pmichaud: I agree about that, too.

[14:06] <moritz> masak: just like you only get errors for failed method dispatches in the presence of AUTOLOAD if the fallback creates the error

[14:06] <masak> I agree that 'junctions == sets' doesn't capture what junctions are, and will create misunderstandings.

[14:06] <masak> moritz: sounds reasonable. but for methods it happens at invoke time. for lexical lookup, at parse time.

[14:07] <masak> moritz: (that is, I understand if the more static lexical lookups don't support this)

[14:07] <moritz> well, such a fallback could be present at compile time

[14:08] <PerlJam> moritz: what would you do with a lexical lookup fallback?

[14:08] <moritz> ie at lookup time, just the same as with method fallback

[14:08] <moritz> PerlJam: not sure. Maybe evil DSL hackery :-)

[14:08] <pmichaud> moritz: what's an example of looking up a lexical that cannot be resolved at compile-time, ooc?

[14:08] <moritz> 16:03 < moritz> (not that I particularly want one, just curious)

[14:08] *** GlitchMr left
[14:09] <moritz> pmichaud: my $name = prompt; say ::($name);

[14:09] <pmichaud> we do have things like OUTER:: and stuff.

[14:09] <moritz> but that's kinda beside my point. If there'd be a fallback, it would operate at compile time too

[14:09] <PerlJam> moritz: so ... give no use-case, it probably shouldn't exist  :)

[14:09] <pmichaud> OUTER::{$name}  might work.

[14:10] <moritz> you need it parse time to determine if it's followed by a term or operator

[14:10] <masak> er, what?

[14:10] <pmichaud> r:  my $a = 'alpha';  my $name = '$a';   { say OUTER::{$name}; };   # just curious

[14:10] <p6eval> rakudo c1bfbb: OUTPUT«alpha␤»

[14:11] <masak> \o/

[14:11] <pmichaud> so, you want a fallback for

[14:11] <pmichaud> r:  my $a = 'alpha';  my $name = '$b';   { say OUTER::{$name}; };   # just curious

[14:11] <p6eval> rakudo c1bfbb: OUTPUT«Any()␤»

[14:11] <pmichaud> looks like //

[14:11] <pmichaud> r:  my $a = 'alpha';  my $name = '$b';   { say OUTER::{$name} // 'beta'; };   # just curious

[14:11] <p6eval> rakudo c1bfbb: OUTPUT«beta␤»

[14:12] <pmichaud> r:  my $a = 'alpha';  my $name = '$b';   { say OUTER::.exists{$name}; };   # just curious

[14:12] <p6eval> rakudo c1bfbb: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method exists at src/gen/CORE.setting:6465␤  in block  at /tmp/8Lf9ULYrLk:1␤␤»

[14:12] <pmichaud> hmmmm.

[14:12] <pmichaud> might want to add .exists to Stash

[14:12] <pmichaud> or... something.

[14:12] *** cognominal left
[14:13] <pmichaud> oh, wait.

[14:13] <pmichaud> r:  my $a = 'alpha';  my $name = '$b';   { say OUTER::.exists($name); };   # just curious

[14:13] <p6eval> rakudo c1bfbb: OUTPUT«0␤»

[14:13] <jnthn> Stash inherits from Hash. :)

[14:14] <pmichaud> from Parrot Hash?

[14:14] <jnthn> Huh?

[14:14] * geekosaur has been sitting there wondering if those braces were supposed to be parens...

[14:14] <jnthn> No, from Hash :)

[14:14] <pmichaud> .exists returned zero there

[14:14] <jnthn> Perl 6 Hash :)

[14:14] *** cognominal joined
[14:14] * pmichaud looks.

[14:14] <moritz> maybe a hash bug

[14:14] *** tokuhiro_ left
[14:14] <jnthn> Oh, though

[14:14] <jnthn> That's not a Stash

[14:14] <pmichaud> I would've expected False.

[14:14] <jnthn> It's a PsudoStash I guess

[14:14] <moritz> r: say Hash.new.exists('foo')

[14:14] <p6eval> rakudo c1bfbb: OUTPUT«False␤»

[14:14] *** wtw left
[14:14] <jnthn> r: say OUTER::.WHAT

[14:14] <p6eval> rakudo c1bfbb: OUTPUT«PseudoStash()␤»

[14:15] <moritz> r: say PseudoStash.^mro

[14:15] <p6eval> rakudo c1bfbb: OUTPUT«PseudoStash() EnumMap() Iterable() Cool() Any() Mu()␤»

[14:15] <jnthn> r: say OUTER::.^methods(:local)

[14:15] <p6eval> rakudo c1bfbb: OUTPUT«new at_key bind_key exists␤»

[14:15] <jnthn> And it overrides exists, and that's probably where le bug is.

[14:15] <jnthn> I blame the guy who wrote PseudoStash :P

[14:15] *** sergot left
[14:16] <jnthn> ah, I see it

[14:16] <pmichaud> okay, I just patched up Rakudo's grammar for the new leading space issues, and it compiled on the second try.  Now I guess I have to go ahead and kill my laptop battery with a full spectest run.

[14:16] <pmichaud> wasn't expecting that to happen this morning :-)

[14:16] <moritz> the first branch just goes to nqp::existskey

[14:16] <jnthn> yeah

[14:17] <jnthn> compiling a fix

[14:17] <pmichaud> nqp::p6bool that.

[14:17] <jnthn> right

[14:17] <moritz> pmichaud: you can push to a branch and let me do the spectest, if you want to save battery live :-)

[14:18] <pmichaud> will do that... but I also think I'll have enough battery to last the rest of my son's soccer practice :)

[14:18] * pmichaud is currently working from the middle of a park.

[14:19] <dalek> rakudo/sigsp: 7300248 | pmichaud++ | src/Perl6/Grammar.pm:

[14:19] <dalek> rakudo/sigsp: First pass at sigspace fixes (for others to test).

[14:19] <dalek> rakudo/sigsp: review: https://github.com/rakudo/rakudo/commit/73002487d1

[14:19] <pmichaud> there, pushed as rakudo/sigsp.  note that you have to build that branch with the sigsp branch of nqp.

[14:20] <tadzik> heh, that reminds me of http://i.imgur.com/nD0Hn.jpg :)

[14:20] <moritz> pmichaud: willdo

[14:20] <tadzik> (that's me working on last year's gsoc :P)

[14:20] <tadzik> was a lot better than sitting in the office

[14:21] <moritz> building nqp now

[14:21] *** mscha left
[14:24] <jnthn> Patch seems to work.

[14:24] <jnthn> Will spectest.

[14:24] <jnthn> (the PseudoStash one)

[14:25] <pmichaud> I get a couple of spectest fails in s05; I'm guessing the tests may need updating also.

[14:25] <moritz> might very well be the case

[14:26] <moritz> and you'll probably find that the now failing tests are TODOed for niecza :-)

[14:26] <moritz> speaking of which

[14:26] <moritz> sorear: CAN HAZ RELEASE PULESE?

[14:26] <pmichaud> p6rd: next

[14:26] <p6rd> niecza 2012-07-30, parrot 2012-08-21, rakudo 2012-08-23

[14:27] <moritz> it's a bug in p6rd that it reports niecza's release date from the past

[14:27] *** mucker left
[14:30] *** sergot joined
[14:31] <moritz> $ ./perl6 -Ilib t/spec/S05-grammar/protos.t

[14:31] <moritz> ===SORRY!===

[14:31] <moritz> Unrecognized regex metacharacter < (must be quoted to match literally) at line 15, near "...> }\n\n  "

[14:31] <moritz> that's  proto token fred { <...> }

[14:32] <moritz> I guess that's deprecated proto syntax, but it wasn't intential that it's not parsed anymore

[14:32] <pmichaud> correct.

[14:32] <moritz> though Perl6::Grammar itself uses <...> quite a bit

[14:33] *** GlitchMr joined
[14:33] <pmichaud> looking.

[14:33] <moritz> probably role regex_dev in Grammar.pm

[14:34] <moritz> s/role/rule/

[14:34] <moritz>           '{'[

[14:34] <moritz>             | ['*'|'<...>'|'<*>'] <?{ $*MULTINESS eq 'proto' }> $<onlystar>={1}

[14:34] <pmichaud> yes, that's likely it.

[14:34] <moritz> yes, looks like that could be affected by the change

[14:34] <pmichaud> need a space after the '{'

[14:34] *** benabik left
[14:35] *** kaare_ left
[14:35] <pmichaud> oh, wait, no.

[14:35] <pmichaud> hrm.

[14:36] *** kaare_ joined
[14:36] <pmichaud> fixing.

[14:36] <dalek> rakudo/nom: ce9ae4e | jnthn++ | src/core/PseudoStash.pm:

[14:36] <dalek> rakudo/nom: Fix PseudoStash.exists to always return a Bool.

[14:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce9ae4e785

[14:37] <pmichaud> compiling, testing.

[14:38] <moritz> https://gist.github.com/3217474

[14:38] *** JimmyZ joined
[14:38] <moritz> the failures fro type.t and S32-exceptions/misc are likely due to sigsp being behind nom

[14:39] <pmichaud> yes.

[14:39] <moritz> ss/likeley //

[14:39] <dalek> rakudo/sigsp: 9c63f57 | pmichaud++ | src/Perl6/Grammar.pm:

[14:39] <dalek> rakudo/sigsp: Better handle <...> and other special forms in regex_def.  moritz++

[14:39] <dalek> rakudo/sigsp: review: https://github.com/rakudo/rakudo/commit/9c63f57cec

[14:40] <pmichaud> see if that patch resolves the S05 stuff.

[14:40] * moritz recompiles

[14:40] *** thou joined
[14:43] <pmichaud> \o/   fixed it for me

[14:45] <moritz> here too. t/spec/S05-metasyntax/angle-brackets.rakudo still aborts after test 35

[14:45] <pmichaud> that's ... weird

[14:46] <moritz> $ ./perl6 -e 'my @second = rx/\.**2/, rx/'.**2'/; "a" ~~ /<@second>/'

[14:46] <moritz> ===SORRY!===

[14:46] <moritz> Unrecognized regex metacharacter } (must be quoted to match literally) at line 2, near ""

[14:47] <pmichaud> probably another <?> after square bracket or | issue

[14:47] <pmichaud> in regex_var

[14:47] <pmichaud> looking

[14:47] <GlitchMr> perl6: print srand

[14:47] <p6eval> niecza v19-15-g051783d:  ( no output )

[14:47] <p6eval> ..rakudo c1bfbb: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'srand' will never work with no arguments (line 1)␤    Expected: :(Int $seed)␤»

[14:49] <GlitchMr> I guess it's impossible to receive current seed?

[14:49] <pmichaud> I'm not even sure what test 36 is meant to test.

[14:50] <pmichaud> oh, I see.

[14:50] <pmichaud> kinda.

[14:51] <PerlJam> GlitchMr: if you need a specific seed (for reproducability presumably), then you just set it to some known value.

[14:52] <moritz> pmichaud: I guess it's really a NYI thing that we've been passing or failing for entirely the wrong reasons

[14:52] <pmichaud> --ll-exception says it's in MAKE_REGEX

[14:53] <moritz> still it might point to something that change in regex parsing which might or might not be what we want

[14:53] <pmichaud> that's gotta be where the '}'

[14:53] <pmichaud>  is

[14:53] * pmichaud installs 'ack' on his notebook, which for some reason hadn't been done yet.

[14:54] <hoelzro> woo

[14:54] <hoelzro> ack++

[14:54] <GlitchMr> ack?

[14:54] <hoelzro> http://betterthangrep.com/

[14:54] <GlitchMr> I've tried it, but I don't like how it works on regexpes

[14:54] *** nightlord joined
[14:54] <hoelzro> GlitchMr: what don't you like about it?

[14:54] <moritz> I like very much that I can use it with p5 regexes, which I happen to know very well

[14:54] <hoelzro> I happen to have an in with the developers ;)

[14:54] <GlitchMr> ack '\*\+\?'

[14:55] <GlitchMr> But, I guess I can use \Q, so whatever

[14:55] <moritz> ack -Q '*+?'

[14:55] <GlitchMr> Unrecognized escape \Q passed through in regex

[14:55] <GlitchMr> or not

[14:55] <moritz> ack -Q '*+?'

[14:55] <pmichaud> I'm guessing we must've been not-really-passing that test.

[14:55] * pmichaud looks.

[14:56] <GlitchMr> Interesting how "ack -Q '+'" doesn't work... probably I should return this bug

[14:56] <GlitchMr> report*

[14:56] <moritz> r: my @a = rx/.+/, rx/'.+'/; say ~@a

[14:56] <hoelzro> GlitchMr: which version of ack are you on?

[14:56] <p6eval> rakudo c1bfbb: OUTPUT« ␤»

[14:57] <pmichaud> hahahahah

[14:57] <moritz> pmichaud: probably related to those regexes stringifying empty

[14:57] <hoelzro> GlitchMr: good catch; please do report it =)

[14:57] <pmichaud> indeed, that's undoubtedly it.

[14:57] <moritz> pmichaud: and then our failure to detect null patterns

[14:57] <GlitchMr> ack-grep 1.92

[14:57] <GlitchMr> ...

[14:57] <GlitchMr> hmmm... yeah... odl

[14:57] <GlitchMr> old

[14:57] <hoelzro> GlitchMr: btw, you should be able to do ack -Q -- '+'

[14:57] <pmichaud> okay, so not really a sigsp regression.

[14:58] <hoelzro> that works with my ack (2.00a01)

[14:58] <pmichaud> cool, so the sigsp branch appears to pass all of the relevant spectests

[14:59] <GlitchMr> ok... I'm now installing ack 2.00a01

[14:59] *** birdwindupbird left
[14:59] <pmichaud> okay, when I get back home I'll run a few more tests and then merge sigsp back into the master branches

[15:00] <pmichaud> (<30 mins left here in the park)

[15:00] <dalek> roast: 7c36bd0 | moritz++ | S0 (2 files):

[15:00] <dalek> roast: rakudo refudges

[15:00] <dalek> roast: 

[15:00] <dalek> roast: * unfudge return type tests that now pass

[15:00] <dalek> roast: * skip regex tests that have been passing/running for the wrong reasons

[15:00] <dalek> roast: review: https://github.com/perl6/roast/commit/7c36bd0e2b

[15:01] <GlitchMr> Actually, I think I was using recursive awk instead of ack before

[15:02] <hoelzro> all the more reason to try ack again =)

[15:03] <moritz> urks, JSON::Tiny relies on the old regex behavior

[15:03] <GlitchMr> I would like ack more if it would use finite automata (for example re::engine::RE2, but whatever)

[15:04] *** cognominal_ joined
[15:04] * pmichaud looks

[15:05] <GlitchMr> I guess I could modify ack to use re::engine::RE2 instead

[15:05] <hoelzro> GlitchMr: well, throw it in the issue tracker for ack 2 =)

[15:06] <pmichaud> rule TOP wants a space between the ^ and the [

[15:06] *** cognominal left
[15:07] <GlitchMr> Because you know, grep uses finite automata

[15:07] <timotimo> ack2 will be a perl6 program?

[15:07] <spider-mario> more like ack6

[15:08] <timotimo> yeah, because that's how long it'll take, right? ;)

[15:08] <GlitchMr> Actually, I should make ack version for yourself

[15:08] <hoelzro> timotimo: ack2 is already written =)

[15:09] <GlitchMr> Which for example replaces space with regular expression working similarly to Perl 6 rules

[15:09] <moritz> pmichaud: that alone isn't enough

[15:10] <pmichaud> moritz: hmmm

[15:10] <pmichaud> I probably need to look at the code gen for the % and ~ items, then.

[15:10] <timotimo> oh, didn't realize. my local ack is apparently outdated

[15:11] <pmichaud> it can be of course "fixed" with the leading <?> trick, but we probaby want to make sure there's not a regex engine bug lurking there

[15:11] <moritz> pmichaud: https://github.com/moritz/json/commit/1f01acdca19af68fb9808f3a308f85b3c7af7766 fixes all but two errors

[15:12] <moritz> not ok 43 - JSON string «{ " s p a c e d " :[1,2 , 3\n...[42]» parsed

[15:12] <moritz> not ok 47 - JSON string «[    0.5 ,98.6\n...[46]» parsed

[15:12] <moritz> are the remaining failures

[15:12] <pmichaud> I'll have to look at it when I get back home

[15:12] <hoelzro> timotimo: it's still in alpha, though

[15:12] <hoelzro> so distros haven't likely packaged it up

[15:13] <pmichaud> I really would prefer to not have the <?>'s there.

[15:13] *** kaleem left
[15:13] * moritz too

[15:13] <pmichaud> at the moment I'm suspicious of the <.ws> handling around the ~'s

[15:13] <pmichaud> or maybe the %'s

[15:13] <moritz> in the long run I'd even prefer <.ws> over <?>

[15:14] <moritz> more explicit in intent

[15:14] <pmichaud> yeah, but it ends up calling <.ws> twice.

[15:14] <pmichaud> unless you do   <.ws>token instead of <.ws> token

[15:15] <moritz> -rule pairlist   { <?> <pair>* % \,             }

[15:15] <moritz> +rule pairlist   { <?> <pair> * % \,             }

[15:15] <moritz> should that make a difference?

[15:16] <pmichaud> it might, depending on how the <.ws>'s are distributed inside of the quantification

[15:16] *** spider-mario left
[15:16] <pmichaud> that's the part I think I need to review.

[15:16] <moritz> in general I want to allow <.ws> everywhere here (ie between <pair> and \, and \, and <pair>)

[15:17] *** cognominal joined
[15:19] <pmichaud> in the case of   <foo>**3   and <foo> **3   the second includes <.ws> between repetitions

[15:20] <pmichaud> and yes, S05 says there's a difference between   <pair>* % \, and   <pair> * % \,

[15:20] *** cognominal_ left
[15:22] <geekosaur> (that is just a bit ugly)

[15:22] * moritz decommutes

[15:25] <pmichaud> time fo rme to leave also

[15:25] <pmichaud> bbl

[15:27] *** JimmyZ left
[15:29] <pmichaud> TimToady: https://github.com/perl6/specs/issues/22   when you get a chance

[15:29] <pmichaud> bbl

[15:37] *** nightlord left
[15:59] *** Coleoid joined
[15:59] *** sergot left
[16:09] <dalek> rakudo/nom: 271741a | (Geoffrey Broadwell)++ | src/core/IO.pm:

[16:09] <dalek> rakudo/nom: Absolute minimum changes needed to support opening pipes for reading and writing

[16:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/271741a999

[16:09] <dalek> rakudo/nom: 37f890a | (Geoffrey Broadwell)++ | src/core/IO.pm:

[16:09] <dalek> rakudo/nom: Merge branch 'io-pipe' into nom

[16:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/37f890a4ca

[16:11] *** SamuraiJack_ joined
[16:12] <pmichaud> ....is :p the spec'd method for opening a pipe, ooc?

[16:14] <moritz> no

[16:14] *** SamuraiJack left
[16:14] *** sudokode joined
[16:14] <moritz> the part of S32::IO that talks about pipes is in the design insanity part

[16:15] <pmichaud> I'm a little concerned about adding :p if it doesn't turn out to be spec.

[16:15] <pmichaud> it just feels wrongish.

[16:15] <TimToady> we don't have to call all our IO constructors 'open'

[16:16] <moritz> so, name it &pipe?

[16:16] *** thelazydeveloper joined
[16:16] <TimToady> can't think of a better name with only half a cup o' coffee in me

[16:19] *** sergot joined
[16:19] <masak> seems a good name to me. +1

[16:19] <pmichaud> my only (very minor) concern with &pipe is confusion with the unix syscall of the same name.

[16:20] <pmichaud> at some point it's just   IO::Pipe.new(...)

[16:20] <pmichaud> or even IO::Pipe(...)

[16:20] <moritz> I don't know if we even need a separate IO::Pipe

[16:21] <pmichaud> we don't have to give all of our IO constructors specialized function-call forms :-)

[16:22] <moritz> actually IO::Path.pipe might be good fit

[16:22] <masak> aye.

[16:22] <pmichaud> I'd definitely like that better.

[16:23] * moritz senses another IO spec refactoring, though a much smaller this one

[16:24] <moritz> in fact I'd like  Str.io to return an IO::Path

[16:24] *** sammii joined
[16:24] *** sammii left
[16:24] <moritz> then IO::Path can support .open, .slurp, .spurt, .pipe

[16:25] <moritz> and since IO as a class is going away (to be replaced by IO::Handle), we teach people to say $str.io instead of $str.IO

[16:25] <moritz> or maybe $str.path

[16:25] <moritz> there's just a wee problem with that

[16:26] <moritz> IO::Path is currently Cool, and I'd like it to stay that way

[16:26] <moritz> so IO::Path.lines currently does what Str.lines does (break a string up into lines)

[16:26] <moritz> so, either we leave it at that, then we have to force people to write $str.path.open.lines

[16:26] <moritz> instead of $str.path.lines

[16:27] <moritz> or we make IO::Path.lines like IO::Handle.lines

[16:27] <moritz> but then not all "things that look like Str" (ie Cool) do the same when you call .lines on them

[16:27] *** orafu left
[16:30] <moritz> any opinions which way is less bad?

[16:39] * japhb just got here, so reading back

[16:39] <phenny> japhb: 10:23Z <moritz> tell japhb spectest on the io-pipe branch is clean here. Feel free to merge!

[16:39] *** am0c left
[16:42] <TimToady> why should IO::Path be Cool?

[16:43] <japhb> moritz, If IO::Path supports .slurp and .spurt, it feels like .lines makes some sense from the perspective of "methods that operate on the entire contents of the file"

[16:45] <japhb> And FWIW, I just did :p for pipe open because A) it's actually what's happening at lower layers, B) it made sense as a parallel to the other flags, and C) because I'd been told at one point a few weeks ago to assume that the syn wording for pipes was essentially ignorable

[16:45] <japhb> My apologies if I misinterpreted C), of course.

[16:48] *** Coleoid left
[16:49] <moritz> TimToady: because &dir returns IO::Path objects, and people expect to use them like strings

[16:49] <moritz> japhb: I still agree with C) :-)

[16:50] <moritz> japhb: and you see, even if we decide the patch was "wrong", it has still spawned an interesting discussion

[16:50] <japhb> True enough.  :-)

[16:50] *** kaleem joined
[16:51] <TimToady> can't we make them stringify without making them Cool?

[16:52] <moritz> TimToady: stringify yes, but not otherwise behave like a string

[16:52] <moritz> like, regex-match, for example

[16:53] <moritz> well, we could, but we already have a mechanism for that, and that is Cool

[16:53] *** dakkar left
[16:54] <moritz> we *can* break the assumption that the return values from &dir behave string-like, but it'd make much file name handling code more verbose

[16:55] <TimToady> well, maybe we can intercept lines instead

[16:55] <TimToady> the primary purpose of IO::Path is to represent the identity of a file

[16:55] <TimToady> strings are secondary

[16:56] <TimToady> losing sight of that is a good way to get race conditions that lead to security holes

[16:57] <japhb> TimToady, how do we make an IO::Path object that A) does not open or stat the file when it is created and B) does not fall prey to race conditions?

[16:59] <pmichaud> japhb: C) is definitely a truth -- the existing IO spec is very loose at the moment.  My question was more along the lines of "is a :p flag really what we want here?"

[16:59] *** daxim left
[17:00] <TimToady> readdir does not just return strings; it also returns inodes, and IO::Path should track that

[17:00] <TimToady> it can at least check that the inode stays the same

[17:01] <japhb> pmichaud, I'm torn between the part of me that dislikes having to say ':r, :p' or ':w, :p' and the part of me the dislikes lying to upper-layer programmers about what the underlying API actually is.  I suppose I could assuage both parts with explicit ':rp' and ':wp' flags, but then that feels a little ugly from the orthoganality angle.

[17:02] <pmichaud> japhb: by "underlying API" do you mean "Parrot", ooc?

[17:04] <TimToady> I think if you open a path, and the inode changes, it should fail by default

[17:04] <TimToady> one can defeat this by opening the string name, of course

[17:04] <japhb> pmichaud, at least several layers down through parrot, yes.  Though it does eventually have to split execution path to do popen(), I suppose.  And of course, Parrot's design decision shouldn't matter for Perl 6's design.

[17:05] <pmichaud> japhb: I'm sure this will come across totally wrongly to people that read it, but in some areas Parrot's design choices were deliberately anti-patterns from Perl 6.

[17:06] *** kaleem left
[17:06] <japhb> pmichaud, what are you thinking of when you say that?

[17:07] <pmichaud> exceptions, IO, basic data types.... a variety of things

[17:07] <pmichaud> calling conventions

[17:07] * japhb thinks on that a moment

[17:08] <pmichaud> there were many times when the responses I got were along the lines of "Parrot shouldn't follow the Perl [6] model in this case..."

[17:08] <japhb> Well, intentionally different (I assume because of a desire to be more language-agnostic), or just baked in before anyone really understood Perl 6's designs?

[17:08] <pmichaud> I'm not saying those choices were wrong for Parrot, just that Parrot's goals for a long time were very different from Rakudo/Perl 6 ones.

[17:09] <pmichaud> desire to be language-agnostic, yes.

[17:09] <TimToady> desire not to be seen as favoring Perl

[17:10] <pmichaud> anyway, these days I'm especially cautious about choosing an API because "that's what Parrot does in this case".  The track record there isn't that good.

[17:10] * japhb shrugs

[17:10] <japhb> I can buy that.

[17:10] <pmichaud> I should probably stop there.  :)

[17:11] *** Sorensen_ joined
[17:11] * TimToady respects it greatly when people stop there.  :)

[17:11] <japhb> In any case, I'm certainly open to better ideas, and happy to hack something in.  I actually need working pipes, but I don't strongly care what they look like, TBH.

[17:13] <pmichaud> japhb: (need working pipes)  -- yeah, I agree we need something for now, so I'm not calling for immediate change or reversion of the patch :)

[17:13] <pmichaud> IO is one of those areas where we actually do need some exploration; it's just that :p doesn't feel quite right to me.  It's good enough for interim, though.

[17:14] <Sorensen_> Hello, all.  I think I may have a bug to report for Rakudo.  But it may already be in the bug list, I don't know...  It's a bit tricky to search with small keywords

[17:14] <moritz> Sorensen_: what's the bug?

[17:14] <Sorensen_> ...How do you make the IRC bot guy do the perl codes?

[17:14] <moritz> (yes, RT isn't easy to search for)

[17:15] <Sorensen_> like, "Hey Rakudo, eval me this"

[17:15] <moritz> r: say 'OH HAI, Sorensen_'

[17:15] <p6eval> rakudo c1bfbb: OUTPUT«OH HAI, Sorensen_␤»

[17:15] <moritz> like this

[17:15] <Sorensen_> cool, okay, let me try this out...

[17:15] *** vmspb joined
[17:15] <Sorensen_> r: my $any = any <a b c>; say $any; $any++; say $any; $any++; say $any;

[17:15] <p6eval> rakudo c1bfbb: OUTPUT«any(a, b, c)␤any(b, c, d)␤any(c, d, e)␤»

[17:16] <Sorensen_> Okay, never mind.  I guess the bug has been fixed!

[17:16] <Sorensen_> I was using Rakudo 2012.04.1, I guess that is out of date now?

[17:16] <flussence> very

[17:16] <moritz> Sorensen_: there's a reason we do monthly releases :-)

[17:16] <Sorensen_> On my machine, I get (a b c), (a b c), (b c d).  The first increment doesn't do anything.

[17:17] <moritz> that's weird

[17:17] <flussence> b: my $any = any <a b c>; say $any; $any++; say $any; $any++; say $any;

[17:17] <p6eval> b 922500: OUTPUT«any("a", "b", "c")␤any("b", "c", "d")␤any("c", "d", "e")␤»

[17:17] <Sorensen_> Well, cool to see that four months makes such a difference. 

[17:17] <flussence> b: say $*PERL

[17:17] <p6eval> b 922500: OUTPUT«name   rakudo␤version  2011.07␤␤»

[17:17] <flussence> interesting

[17:17] <Sorensen_> hmm

[17:17] <moritz> well, b was an entirely different beast anyway :-)

[17:19] <Sorensen_> wait wait... maybe it's an issue with the REPL.  Ha, I should have tried it all on one line like I did in here.  It works when it's on one line; but the first time I write "$any++" and hit enter, the REPL gives me the old version

[17:19] <Sorensen_> Like this... 

[17:19] <Sorensen_> >  my $any = any <a b c>; any(a, b, c) > $any++ any(a, b, c) > say $any any(b, c, d) 

[17:19] <Sorensen_> eh, that didn't paste nicely...

[17:20] <moritz> Sorensen_: note that $any++ returns $any, not the incremented any

[17:20] <Sorensen_> OH DUH

[17:20] <Sorensen_> the smacking sound you hear the in background is my hand against my forehead

[17:20] <moritz> and I thought for a moment an airplane had crashed :-)

[17:20] <Sorensen_> ++$any works as expected

[17:21] <Sorensen_> (I was playing around with stuff from this post:  http://perl6maven.com/perl6-is-a-value-in-a-given-list-of-values  ...  Yeah, I wasn't thinking there.  The way the REPL works makes sense, it just wasn't how I was thinking about it.)

[17:22] * moritz is glad that szabgab brings people to play with p6

[17:22] <japhb> pmichaud, perhaps methods/subs 'pipe-to' (the common write-to-process pipe), 'pipe-from' (the common read-from-process pipe), and 'pipe' (make a raw pipe)

[17:22] <moritz> what does the raw pipe do?

[17:22] * japhb goes to check if that's already what the syn said

[17:22] * moritz likes pipe-to and pipe-from

[17:23] <japhb> moritz, you get both ends.  Do with them what you will

[17:23] <japhb> Essentially pipe(2) in *nix

[17:23] <masak> Sorensen_: welcome. glad to see that your bug from four months ago was (1) fixed, and (2) not even a bug ;)

[17:23] <masak> so, really not (1), I guess... :P

[17:24] <Sorensen_> Ha, I like that. Ciao all, thanks for the quick feedback.  Best of luck with your programming.

[17:24] *** Sorensen_ left
[17:27] <japhb> Interesting, another item for :p as a flag on pipe -- .p is the test for 'is a pipe'.  Perhaps pipe-to and pipe-from implemented in terms of open :p, which is considered the "low-level" way to do it.  ;-)

[17:27] <japhb> s/flag on pipe/flag on open meaning pipe/

[17:28] <TimToady> it bothers me slightly to have a flag that changes the meaning of a string in hindsight

[17:29] <TimToady> also, we have to worry a bit about combinatorics if we get too many interacting options

[17:29] <japhb> Ah, S32 has 'IO::Pipe.to', 'IO::Pipe.from', and 'IO::Pipe.pair'.  I suppose I could do pipe-to, pipe-from, and pipe-pair ....

[17:30] <japhb> TimToady, yeah, we already have some silliness of which of :r :w :a is used with something that is or is not '-'

[17:30] <TimToady> .oO(open-to, open-from, open-pair...)

[17:31] <japhb> TimToady, I think that is too general a set.  Meaning, it sounds like it wants really magical open, of the "opens sockets if you ask it to" variety

[17:32] <TimToady> I'm just point out the inconsistency

[17:32] <TimToady> *ing

[17:32] <japhb> Which inconsistency?  I can see several angles of strange there, but I'm not sure what you're actually referring to.

[17:33] <TimToady> why pipe-to, but open :w ?

[17:34] <japhb> Hmmm, well, pipe's don't have the append/overwrite dichotomy.  And you can have a R/W pipe, but it's a hectare of brambles.

[17:34] *** orafu joined
[17:35] <japhb> Yeah, I dunno.  What is your preference, or do you have one yet?

[17:35] <TimToady> no, I just enjoy complaining :)

[17:35] * moritz would like either IO::Path.pipe() with :r/:w or IO:Path.pipe-{to,from,pair}

[17:37] <japhb> I will say that I find the way Perl 5 and bash both go, with all sorts of special combinations of <>+&| and so forth all meaning various things, gets confusing enough that for the rarer stuff I always have to check perlfunc to be sure.

[17:39] <japhb> IO::Path.pipe() doesn't make sense to me for two reasons: 1) You don't have a path involved in a pipe pair, and 2) the command you pipe to may be much more than just a path (e.g. having options/arguments)

[17:39] <flussence> maybe IO::Path.pipe should call mkfifo()

[17:40] <TimToady> it's more like IO::Identity in my mind, which why it was just IO before

[17:40] <TimToady> so IO::Handle is closer to the truth than IO::Path

[17:41] <TimToady> unless, of course, we redefine 'path'

[17:42] <TimToady> but it represents "I already said how to get to this thing, and I don't want to say it again"

[17:44] <moritz> well, IO::Handle is a handle, IO::Path is a path

[17:44] <moritz> and in my world, reading a directory returns paths, not handles

[17:44] <moritz> maybe your world is different :-)

[17:45] <moritz> and I don't see how inodes are any less prone to race conditions than paths, for that matter

[17:45] <japhb> moritz, in my world, a directory returns "things I can open and query for name, path, and stat info".

[17:47] <japhb> It happens that Perl 5 gave me string representations of name, and expected me to get the others through contortions on that.  But that always felt like an extra step.

[17:47] <japhb> Mind you, it was an extra step that in some sense reflected the underlying API.

[17:48] *** fgomez joined
[17:49] <japhb> Humm, I guess returning path info from a directory-contained object depends recursively on the path of the directory.  Makes me wonder about symlinks, mounts, canonical names, and so forth.

[17:50] <moritz> currently I see my approach (something simple, implementable very soon, easy to use) at odds with TimToady++'s musings (which seems to target for perfect and easy to use)

[17:52] *** sftp joined
[17:53] *** simcop2387_ joined
[17:54] *** simcop2387_ is now known as simcop2387

[17:55] <masak> I don't believe in aiming for perfect. I believe much more in mimicking things out there that already work well.

[17:55] <masak> surely we're not the first ones to implement this functionality in a language library.

[17:56] <diakopter> but "aiming for perfect" is just an expression of trying to define "well" in your statement about "work well"

[17:56] <masak> if that's true, then how do moritz' and TimToady's approaches differ?

[17:57] <diakopter> just amount of time willing to devote to the definition, I guess

[17:57] <japhb> Because IIUC TimToady thinks paths-as-strings does not qualify as "working well"

[17:57] *** SHODAN joined
[17:58] <masak> I interpreted moritz as "get it working now", and (his description of TimToady, I haven't been following along too closely) as "get it right first".

[17:58] <mhasch> fwiw I think the notion of an "atomic" open (taking a path, returning a handle) should at some point be exposed to the program; things like string munching for paths need abstraction but not "implicit-ness".

[17:59] <masak> that was the worst use of parentheses, ever. sorry. :/

[17:59] <mhasch> :P

[17:59] <japhb> masak: so ... many ... LISP ... jokes

[18:00] <masak> :P

[18:01] <moritz> well, the problem with "aiming for perfect" is that the IO specs have been trying that for years, and see what it brought us

[18:02] <moritz> just read the whole thing, and try not to cringe

[18:02] <moritz> (and remember that I've thrown out the worst 30% already)

[18:03] <masak> I'm not sure the IO spec has been aiming anywhere in particular for years.

[18:03] <masak> mostly it's been the victim of many chefs, and no clear vision.

[18:04] <moritz> IMHO it's the victim of no implementation, many chefs, and no clear vision

[18:04] <japhb> moritz, I'm essentially saying this as a man on the outside, but I'm not sure the problem was "aiming for perfect", but rather "design up front in an implementation vacuum"

[18:04] <moritz> japhb: right, that was a big part of the problem

[18:05] <sorear> good * #perl6

[18:05] <moritz> \o sorear 

[18:05] <japhb> o/

[18:05] <masak> sorear! \o/

[18:08] <flussence> I can't help but wonder if all this would be easier after a big s/IO:://g

[18:09] <flussence> (i.e. stop trying to get all the subclasses playing nice and just have them work well on their own)

[18:09] <moritz> flussence: try it and see :-)

[18:10] * flussence goes off to re-read that bit of S32...

[18:16] *** crab2313 joined
[18:18] *** crab2313 left
[18:22] <tadzik> o/

[18:25] <japhb> o/

[18:25] <masak> o/

[18:31] <colomon> o/

[18:31] *** fhelmberger joined
[18:31] <sorear> o/

[18:32] <jnthn> \o

[18:32] * masak .oO( a non-conformist! )

[18:34] <jnthn> :D

[18:34] *** fridim_ joined
[18:35] * masak .oO( you are unique, just like everyone else )

[18:37] <colomon> .oO( not me! )

[18:37] <masak> :P

[18:37] <sorear> 'but some are more unique than others'

[18:38] <japhb> I am utterly the same, unlike everyone else.

[18:38] <masak> 'individual uniqueness is already here, it's just not evenly distributed'

[18:38] <sorear> colomon: since you seem to be the only person who contributed to niecza (git log v19..HEAD) this month, would you mind summarizing what you've done for the announcement?

[18:38] *** cognominal_ joined
[18:39] <TimToady> well, if anything ever needed duck typing, it's I/O

[18:40] <TimToady> my main concern is that we don't make the lazy way something we have to recant later in the interests of security (see 2-arg open)

[18:42] *** cognominal left
[18:42] <TimToady> and it's just really easy in the original Unix model of I/O for race conditions to sneak in between the name and the fd you think came from a particular name but didn't

[18:43] <colomon> sorear: Added floating point support for printf/sprintf. Added simple versions of tc, tclc, and tcuc.

[18:43] <TimToady> that's why the newer APIs are full of fdthis and fdthat

[18:44] *** fhelmberger left
[18:44] <TimToady> no true identity is in filenames (or commands) until they are opened

[18:44] <japhb> Too bad open can be rather expensive.  :-(

[18:45] <TimToady> the race condition mostly shows up in doing stat when you should fdstat

[18:46] <TimToady> hence my desire that $filename.IO ~~ :w work against an fd by default, not against a filename

[18:46] <TimToady> or .io, or whatever it ends up

[18:46] <japhb> Too bad inode ids aren't globally unique.

[18:47] <TimToady> yes, well, you need at least dev as well, but a directory should only be in a single dev

[18:47] <TimToady> I also recognize that this becomes more of a problem in the context of universal naming schemes

[18:48] *** sivoais joined
[18:48] <TimToady> to the extent that the only safe-ish ID that you can have in the long run is a cryptochecksum like git does

[18:48] <japhb> Well, I was thinking about inode reuse, actually.  Even on a single device ... the inode number space isn't large enough not to reuse them.  Especially on filesystems that treat them as indices in some pre-allocated array.

[18:48] <TimToady> there's really no guarantee that two probes of a URI will produce the same thing

[18:48] <japhb> True.

[18:49] <TimToady> japhb: but at least if the inode changes you have some clue that something happened

[18:49] <moritz> TimToady: $filename.IO ~~ :anything  working through a fd doesn't buy us anything at all

[18:49] <moritz> TimToady: because that file handle is GC'ed immediately

[18:49] <moritz> and what remains is the file name again

[18:49] <TimToady> right, unless there's caching of some sort

[18:50] <sorear> TimToady: except git uses SHA-1, which is widely regarded as almost broken *ducks*

[18:50] <TimToady> *ducks* typing...

[18:50] <TimToady> admittedly caching is not the solution either to security

[18:50] <japhb> TimToady, there are some filesystems (I gather ext2 is one of these) that like to immediately reuse the inode of a just-deleted file.

[18:52] <TimToady> makes you want one-use filename, so if you say $filename.IO ~~ :w and $filename.open it says "You can't open that now"

[18:52] <japhb> sorear, IIRC Linus said back when SHA-1 was first seriously attacked that since he was using it for uniqueness amongst cooperative people, not for security against an attacker, that wasn't an issue for Git.  Has this been revised?

[18:53] *** cognominal joined
[18:53] *** cognominal_ left
[18:53] <TimToady> it's a bit more important for the Perl 6 Official Library to have something that can't be spoofed

[18:53] <TimToady> (maybe)

[18:53] <masak> ooh, HPMoR tommorrow? :)

[18:53] <sorear> japhb: I think gitland has gotten a bit wider since then

[18:54] <japhb> Of course.  I just figured "sorear is usually more up to date on this sort of thing", so I thought I'd ask.  :-)

[18:54] <TimToady> it's just that, having been burned multiple times in the past, I know in my guts that file security cannot be a retrofit

[18:54] <japhb> masak, hopefully not another delay like July 1.  :-/

[18:54] <sorear> there's also the question of 'how far will SHA-1 cryptanalysis get'?

[18:54] <masak> japhb: one can hope.

[18:54] <sorear> MD4 is so badly cracked that you can find collisions with pen & paper

[18:54] <Tene> masak: hpmor progress update tomorrow

[18:55] <masak> right.

[18:58] <japhb> TimToady, in any case, I'm curious if there is prior art to putting a safe-but-still-fast-and-powerful interface on top of the painfully finicky unix IO API.  I'd hate to lose all the power or performance in trying to gain the ability to save the programmer from themselves.

[18:59] <TimToady> .oO(use UNSAFE_STAT)

[18:59] <moritz> also, going through FDs is only possible if you have permissions to open the stuff you're talking about

[19:00] <TimToady> yeah, I'm just grouchy today

[19:00] <masak> TimToady: I'd hate to see us crawling up out of the ditch of perfection (if that's what happened to S16), only to fall back down again.

[19:00] * TimToady can usually figure out a way to have it both ways, and it doesn't seem possible here

[19:01] <japhb> moritz, sadly, that's a clear fail of the Unix API right there (the lack of separation between "get a unique handle to" and "open for read or write")

[19:02] <moritz> also let's not forget that there are non-UNIX systems out there

[19:03] <japhb> moritz, I'm not.  But unless this changed, the old Perl philosophy was "the world's APIs -- seen from the Unix API point of view"

[19:03] <japhb> At least, that's how I always saw it.

[19:05] <TimToady> well, an fd is the only guarantee of identity in Unix, so I guess we have to live with that one way or another

[19:06] <TimToady> also, it's object identity, not value identity, since files are mutable

[19:11] *** cognominal left
[19:11] <TimToady> I guess it bothers me that someone might do: $handle = $filename.IO; and think $handle ~~ :x is working on the fd when it's not

[19:14] <TimToady> that situation doesn't arise in P5 because stat works directly on filename strings

[19:16] <TimToady> IO in that case really has very little to do with I/O

[19:17] <TimToady> almost want $filename.stat ~~ :x instead

[19:18] <TimToady> I think that would reflect what's happening much better

[19:18] <japhb> Well, the objection about $handle = $filename.IO is part of the reason for having $path = $filename.path instead.  Handle is a crazy name for something that isn't actually a handle.

[19:19] <moritz> TimToady: then let's go for $filename.path ~~ :x

[19:19] <TimToady> part of the reason for the original formulation was to cache the statbuffer for the filename

[19:19] <moritz> that fits very well with my plans so far

[19:19] <japhb> Do you object to $filename.path ~~ :x and $filename.open ~~ :x doing the string and fd tasks?

[19:19] <TimToady> I think that's clearer than what we have

[19:21] *** SamuraiJack_ left
[19:24] *** GlitchMr left
[19:27] <TimToady> in retrospect .io is too confusing to be the default way to do things

[19:27] <japhb> I agree.

[19:27] *** vmspb left
[19:29] <TimToady> though we want to scrap .open we could have .io, .input, and .output to go with pipe-io, pipe-input, and pipe-output  :)

[19:30] <TimToady> or .io, .in, .out to go with pipe-io, pipe-in, pipe-out

[19:30] <TimToady> gets rid of all the :r, :w, and :rw flags at least

[19:31] <TimToady> would still need :a and such though

[19:31] <japhb> But I guess we still need to keep :a, :bin, :chomp, :enc

[19:31] <japhb> ... right

[19:31] <moritz> also for UNIX systems we might want to have .open on Buf too

[19:31] * PerlJam stubbornly clings to :r :w and friends.

[19:32] <TimToady> .sysopen  :P

[19:32] <moritz> because file names are really binary on linux

[19:32] <TimToady> $filename.in.lines ain't so bad

[19:33] <japhb> TimToady, we need an escape hatch for magical '-' (both wanting the magic and wanting to explicitly not use the magic) -- how did you want to factor that in this line of thinking?

[19:33] <TimToady> well, '-'.in is obviously the opposite of '-'.out

[19:34] <TimToady> moritz: yes, encodings of filenames is a complete disaster across OSes

[19:34] <japhb> Sure, but does it open the standard handles, or a path named '-'?

[19:35] <TimToady> I'd think '-'.in would just return $*IN and '-'.out would just return $*OUT

[19:36] <japhb> So is this where we then need '-'.sysopen(:r) and '-'.sysopen(:w)?

[19:36] <japhb> oh, and: ew.

[19:37] <japhb> .oO( .sys-in, .sys-out, .sys-io )

[19:37] <japhb> (That 'ew' was to my own suggestion)

[19:37] <TimToady> I do like that the -io variants don't commit to whether they return a pair or just something two-ended like a socket

[19:37] <geekosaur> $go.sysin DD ...

[19:38] <TimToady> isn't there supposed to be some slashes in there somewhere

[19:38] <TimToady> well, I never learned JCL

[19:39] <geekosaur> s/.../*/ and all you need is an appropriate DD operator.  and maybe syntax fudging to get the slashes in there ;}

[19:40] <dalek> nqp: 0fdbf28 | jnthn++ | src/QAST/ (5 files):

[19:40] <dalek> nqp: Fix over-sharing of children.

[19:40] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0fdbf2858f

[19:42] * geekosaur just used the $ in place of //.  just define the twigil!

[19:43] *** cognominal joined
[19:44] *** birdwindupbird joined
[19:44] * TimToady wonders if people could get used to: my $handle = in $filename;

[19:44] *** colomon joined
[19:45] * moritz thinks "in" is a bit too generic for that purpose

[19:45] <japhb> Yes, feels like an over-huffmanization

[19:46] <TimToady> but open-in is a bit too long for what is the default

[19:46] * moritz is fine with open

[19:46] <TimToady> considered open, open-out, and open-io

[19:46] <dalek> doc: 995c843 | moritz++ | type-graph.txt:

[19:46] <dalek> doc: [type-graph.txt] remove IO::Dir and IO::File

[19:46] <dalek> doc: review: https://github.com/perl6/doc/commit/995c84302b

[19:47] <TimToady> then wondered if pipe, pipe-out, pipe-io could be forced to wrk

[19:47] <TimToady> or maybe open is just a synonym for open-in

[19:47] <sorear> mmm JCL

[19:47] <japhb> Well, you can make open still be the truly generic thing (pile of options to do all sorts of stuff), and at the same time be the "open for reading" sub/method -- that overloading at least works with my brain just fine.

[19:48] <TimToady> so open still defaults to input, but open-in is also there

[19:48] <japhb> Yeah, I can dig that.

[19:48] <sorear> "well, O_RDONLY is 0, so it all just works"

[19:52] <TimToady> so we can agree on that huffman coding for the listop form, but what about the methods?  .in vs .open-in vs .open; .out vs .open-out

[19:53] <TimToady> can argue that both ways

[19:53] <moritz> I'm firmly against .in and .out

[19:53] <moritz> because there IO isn't the only boundary where somethiing goes in and out

[19:53] <skids> .oO(isn't this what adverbs are for?)

[19:53] <PerlJam> skids: I was thinking the same thing.

[19:54] <moritz> we also have scopes, modules, containers etc. where something could go in or out

[19:54] *** sftp left
[19:54] <PerlJam> and in could nicely be a predicate too  :)

[19:54] <japhb> .oO( feeds )

[19:55] <TimToady> then the same methods as listops

[19:55] <moritz> aye

[19:55] <TimToady> .open, .open-in, open-out, .open-io

[19:55] <masak> rn: module A { class B {}; our $c = B.new }; say $A::c.^name

[19:55] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«B␤»

[19:56] <masak> rn: module A { class B {}; our $c = B.new }; say A::B

[19:56] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«B()␤»

[19:56] <TimToady> I do think that it's a good thing to put the direction into the name, because that's a user-centric viewpoint, not an implementor-centric viewpoint

[19:56] <TimToady> "I am creating this file", not "I am opening a handle"

[19:57] *** sftp joined
[19:57] *** benabik joined
[19:59] <masak> rn: module A { class B {} }; class A::C {}; say "alive"

[19:59] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«alive␤»

[19:59] <masak> \o/

[20:00] <moritz> erm, why doesn#t that give a redeclaration error?

[20:00] <moritz> s/#/'/

[20:01] <jnthn> Which symbol is being redeclared?

[20:01] <skids> moritz: B vs C... but shouldn't it need an augment, or "is also" or whatever it is these days?

[20:02] <skids> oh wait, module, not class...

[20:02] <sorear> moritz: 'A::C' generates a very "soft" declaration of A, which can merge with anything else

[20:03] <PerlJam> masak: Do you have a state-of-the-art guide to macros somewhere?

[20:04] <moritz> oh, I thought it was A::B

[20:04] <dalek> nqp: 14a8815 | jnthn++ | src/QAST/InlinePlaceholder.nqp:

[20:04] <dalek> nqp: Don't lose namedness of arguments when inlining.

[20:04] <dalek> nqp: review: https://github.com/perl6/nqp/commit/14a88157da

[20:04] <moritz> never mind then

[20:06] <dalek> rakudo/inliner: 5cd3686 | jnthn++ | src/Perl6/Ops.pm:

[20:06] <dalek> rakudo/inliner: Mark some Perl 6 ops as inlinable.

[20:06] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/5cd36869f8

[20:06] <dalek> rakudo/inliner: 958a3ea | jnthn++ | src/ (2 files):

[20:06] <dalek> rakudo/inliner: We will keep around the QAST tree of inlinable things now, not some string thingy.

[20:06] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/958a3eadf9

[20:06] <dalek> rakudo/inliner: fdcee65 | jnthn++ | src/Perl6/Optimizer.pm:

[20:06] <dalek> rakudo/inliner: Tweak optimizer to look for inlining information properly (though not actually using it yet).

[20:06] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/fdcee65641

[20:06] <dalek> rakudo/inliner: 44fef37 | jnthn++ | src/Perl6/Actions.pm:

[20:06] <dalek> rakudo/inliner: Update the inlinability analysis and start attaching inlining information to routines again.

[20:06] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/44fef37c38

[20:13] <masak> PerlJam: what, more exactly, are you looking for?

[20:14] <PerlJam> masak: Just to know what's implemented and works today.

[20:15] <masak> PerlJam: oh! hold on, then.

[20:15] *** bruges joined
[20:15] <masak> PerlJam: http://strangelyconsistent.org/blog/macros-progress-report-d1-merged

[20:15] <masak> PerlJam: http://strangelyconsistent.org/blog/macros-progress-report-quantum-yak-shaving

[20:16] <PerlJam> ah, danke

[20:17] <dalek> doc: d510e13 | moritz++ | lib/Whatever.pod:

[20:17] <dalek> doc: document Whatever

[20:17] <dalek> doc: review: https://github.com/perl6/doc/commit/d510e13d1f

[20:19] <moritz> nqp: sub f(:$i) { say($i) }; f(:i)

[20:19] <p6eval> nqp: OUTPUT«1␤»

[20:19] <moritz> jnthn: you can write :inlineable(1) as :inlinable in nqp :-)

[20:22] <jnthn> moritz: Oh :)

[20:23] * masak .oO( it's less inhospitable than you think! )

[20:23] <jnthn> .oO( it's never hospitalized me )

[20:29] *** cognominal left
[20:29] <dalek> rakudo/inliner: 60117ea | jnthn++ | src/Perl6/Optimizer.pm:

[20:29] <dalek> rakudo/inliner: Implement inlining, now using nice AST splicing. Seems to basically work; handful of test failures that will need investigation. Also generated code not yet awesome.

[20:29] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/60117ea3f0

[20:31] *** cognominal joined
[20:38] <dalek> ecosystem: aceab63 | (Carl Mäsak)++ | META.list:

[20:38] <dalek> ecosystem: [META.list] added Adventure::Engine

[20:38] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/aceab63a79

[20:39] <masak> \o/

[20:39] <masak> this should make lue++ happy, too.

[20:41] <jnthn> nqp: my $a; foo(:$a)

[20:41] <p6eval> nqp: OUTPUT«Could not find sub foo␤current instr.: '_block1000' pc 55 ((file unknown):137888379) (/tmp/vpXdprrJ7x:1)␤»

[20:42] <moritz> jnthn: the syntax is supported, yes

[20:42] <moritz> nqp: sub f(:$x) { say($x) }; my $x = 5; f(:$x)

[20:42] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " 5; f(:$x)"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8523) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:42] <moritz> nqp: sub f(:$x) { say($x) }; my $x := 5; f(:$x)

[20:42] <p6eval> nqp: OUTPUT«5␤»

[20:43] *** spider-mario joined
[20:44] <TimToady> ooc, how does nqp store in natives without "="?

[20:45] <jnthn> TimToady: It doesn't have a container model, so everything is really "shove X in memory location Y"

[20:46] <jnthn> TimToady: Rakudo actually goes to some effort to hide the fact that = assigning to a native means there isn't a scalar container.

[20:46] <jnthn> Under the hood, my int $x = 5; is compiled down to something more like my $x := 5; is.

[20:47] *** cognominal left
[20:47] <jnthn> The use of "=" is to keep the user comfy, not the compiler :)

[20:47] *** cognominal joined
[20:48] <TimToady> I guess that's an area where nqp isn't really a subset of p6

[20:48] <jnthn> Yeah, that had bothered me a bit

[20:48] <TimToady> since := in p6 is always indirect

[20:48] <jnthn> otoh, the analysis to make = work for natives and only natives wouldn't be terribly hard.

[20:50] <TimToady> I think of := as a = to a (native) pointer locati

[20:50] <TimToady> *tion

[20:50] <jnthn> Right

[20:50] <jnthn> Which it basically is

[20:51] <dalek> ecosystem: 93d6026 | (Carl Mäsak)++ | META.list:

[20:51] <dalek> ecosystem: [META.list] added Crypt::Game

[20:51] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/93d6026c70

[20:51] <jnthn> But that really means "to the body of the object itself", which is what you're doing with native types too 

[20:52] <TimToady> my hope is, of course, that we can keep the p6 semantics clean enough in that regard to make it a drop-in replacement for nqp someday :)

[20:52] <TimToady> of course, I want everything else too :)

[20:52] * masak .oO( we're so fond of Perl 6 that we want even Not Quite Perl 6 to be Perl 6! )

[20:54] <jnthn> Well, a worthy initial goal is that NQP code compiles with the Perl 6 compiler.

[20:54] <TimToady> and I'm quite willing to throw a few pragmas at it when I want the Very Fast subset :)

[20:54] <jnthn> Yeah, that'll be interesting when I get the NQP optimizer in place.

[20:54] <jnthn> Oh argh. The Rakudo optimizer has just, er, thrown up some fun too...

[20:54] <jnthn> It inlined a routine in wrap.t.

[20:54] <sorear> jnthn: you're making me want to get a Rakudo CLA filed and abandon Niecza

[20:55] <jnthn> And...yeah, you can guess... :)

[20:55] <TimToady> sorear: otoh, rakudo could use a better parser :)

[20:56] <jnthn> sorear: Which bit of what I said, ooc? :)

[20:57] <jnthn> TimToady: What is it that you really want to see Rakudo do here?

[20:57] *** sergot left
[20:57] <jnthn> TimToady: Is it Rakudo not having STD's error model that's the main pain point?

[20:57] <TimToady> not say "Confused" when niecza doesn't

[20:58] * sjn just read gabor's post

[20:58] <TimToady> but also do a bit more in terms of grammar derivation, like support quote languages better

[20:58] <jnthn> *nod*

[20:58] <jnthn> Well, I did implement mixins in NQP like a week ago :)

[20:59] <sjn> <- thinking about "what's a good idomatic way to name junction variables?"

[21:01] <lue> hello world o/

[21:02] <sjn> first thought: my $some_weekday = any <Mon Tue Wed Thu Fri Sat Sun>;

[21:02] * lue goes to get Adventure::Engine

[21:02] <sjn> or perhaps $a_weekday

[21:02] <masak> lue! \o/

[21:03] *** skids left
[21:03] <japhb> masak, why Crypt::Game instead of Game::Crypt?  The former seems namespace-reversed

[21:03] <TimToady> n: my \any_weekday = any <Mon Tue Wed Thu Fri Sat Sun>; say 'Fri' ~~ any_weekday;

[21:03] <p6eval> niecza v19-15-g051783d: OUTPUT«True␤»

[21:03] <lue> (installing it with panda seems like a good idea...)

[21:04] <pmichaud> yes, I wonder when/if nqp and Perl 6 / rakudo will converge someday.  But at the moment having the extra layer of abstraction still seems very useful.

[21:04] <masak> japhb: I kinda thought of Crypt as a top-level namespace for events, exceptions, and the game.

[21:04] <masak> japhb: did the same with Hanoi.

[21:04] <japhb> Ah

[21:04] <pmichaud> I totally understand about Rakudo's grammar not being as sophisticated at error handling as it ought to be; patches welcome there.

[21:04] <pmichaud> we just have to be careful to not make the parser too slow in the process.

[21:04] <japhb> masak, but when put into the ecosystem, it feels odd

[21:05] <pmichaud> also, some things are now more possible with ltm that we couldn't really handle well before.

[21:05] <sorear> jnthn: you've got a working fully integrated parser.  I don't, and I'm losing hope that I ever will

[21:05] *** kaare_ left
[21:05] <japhb> pmichaud, I'd settle for just having Rakudo able to parse any NQP correctly.  It bothers me when I can't make the same code work under both.

[21:06] <sjn> TimToady: what did you just do there?

[21:06] <pmichaud> japhb: what parts aren't parsing, ooc?

[21:06] <jnthn> sorear: In the nobootstrap?

[21:06] <sorear> jnthn: correct

[21:06] <masak> japhb: because of "namespace squatting" issues?

[21:06] <japhb> Actually, come to think of it, the last time I ran over it may not have been a parse error, but rather argument semantics for a builtin, lemme check ...

[21:07] <masak> japhb: I don't think Perl 6 is mature enough for us to have to worry about that. I could rename it to Game::Crypt, but I'd rather do it for a deeper reason than "it feels odd".

[21:07] * sjn doesn't know the   my bareword = any <foo bar>;  syntax

[21:07] <sorear> jnthn: rakudo is rapidly catching up in the places where I once had niecza working better (inlining!) and has always been ahead in other places

[21:07] <japhb> masak: yes, because Crypt:: makes me think Cryptography

[21:07] <masak> sjn: it's fairly new.

[21:08] <pmichaud> ...and nyi in rakudo, iiuc

[21:08] <sjn> what is it?

[21:08] <masak> japhb: that's been the trouble with that name since it got it. :)

[21:08] <japhb> Heh

[21:08] <masak> sjn: assign-once variables.

[21:08] <japhb> masak, but Game::Crypt gives it enough context to be clear.  ;-)

[21:08] <sorear> jnthn: it might just be the failed branch malaise, but I'm kinda feeling now like niecza has no future.

[21:09] <sjn> masak: so... it's a kind of.. function?

[21:09] <japhb> pmichaud, ah yes, it was bless.

[21:09] <sjn> because "assign-once variable" really makes no sense

[21:09] <masak> sjn: more like a kind of constant.

[21:09] <pmichaud> I think of   my \bareword =    as being more of a way to have a sigiless noun.

[21:10] <pmichaud> *sigil-less noun

[21:10] <jnthn> sorear: There's things Niecza has managed much better at than Rakudo too, as TimToady++ pointed out. If you'd find working on Rakudo more -Ofun, though, I'm all for that. :)

[21:10] <masak> japhb: you're right.

[21:10] *** birdwindupbird left
[21:10] <masak> japhb: I'll see about renaming it. tomorrow.

[21:10] <sjn> ok, so it's a sigil-less constant

[21:10] <masak> rn: constant foo = 42; say foo

[21:10] <japhb> masak, cool beans, thanks.

[21:10] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«42␤»

[21:10] <pmichaud> japhb: yeah, nqp doesn't necessarily implement the full Perl 6 runtime.

[21:10] <pmichaud> and .bless is part of that runtime.

[21:10] <masak> constants can be sigil-less, too :)

[21:10] <sorear> japhb: generic crypto, ore 

[21:10] <sjn> so, what's the difference?

[21:10] <sorear> japhb: generic crypto, or things that resemble crypt(3)?

[21:11] <japhb> pmichaud, right, but that one felt like an arbitrary difference.

[21:11] <masak> sjn: the difference between \foo and constant foo is that the former is assigned at runtime.

[21:11] <sjn> ok

[21:12] <japhb> Does NQP even recognize * at all?  Meaning, can it be made to recognize bless(*,...) and just ignore that leading * silently?

[21:13] <japhb> Oh, another strange incompatibility: whether MAIN's args include the program name

[21:13] <pmichaud> that's probably not an intentional incompatibility.  I didn't even remember that NQP has a MAIN

[21:15] <jnthn> It's decidedly not intentional.

[21:16] <japhb> sorear, Generic crypto, for me.  I don't even think about the 'o' because Perl 5 history has led me to think Crypto:: is stranger than Crypt::

[21:16] <pmichaud> ...but getting NQP's MAIN to work like Perl 6's MAIN is also likely to be... problemeatic.

[21:16] <japhb> But I know that's just habit.

[21:16] <pmichaud> I'm even wondering if NQP should have a MAIN (or needs one)

[21:16] <jnthn> NQP's MAIN just really gets @*ARG passed, or thereabouts.

[21:16] <jnthn> pmichaud: I found it helpful to have it when porting NQP to NQP.

[21:16] <japhb> pmichaud, it doesn't have to work the same, just not be different in a way that I can't correct for easily.

[21:17] <pmichaud> japhb: sure, but that starts to sound very much like a slippery-slope sort of thing

[21:17] <japhb> When dealing with the MAIN args incompatibility, must first thought was "Is there any way to know that I'm in NQP or Rakudo without making the other one die?"

[21:18] <pmichaud> seems like we could get $*VM to provide that.

[21:18] <japhb> When all you want is just positional args, they are effectively the same.

[21:18] <pmichaud> and I suspect we could get NQP's MAIN to work like Rakudo's MAIN.  But more to the point, if you want something to work the same in NQP and Rakudo in that case, just don't use MAIN at all :-)

[21:19] <pmichaud> i.e., the question becomes  "why use MAIN there?"

[21:19] *** cognominal left
[21:19] <japhb> So ... what would be the common way to get identical CLI args in both?

[21:20] <pmichaud> I would think looking at @*ARGS ought to work in both.

[21:20] <pmichaud> (perhaps it doesn't, but it ought.)

[21:20] <japhb> nqp: say @*ARGS;

[21:20] <p6eval> nqp: OUTPUT«Confused at line 2, near "say @*ARGS"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8523) (src/stage2/gen/NQPHLL.pm:326)␤»

[21:20] <japhb> nqp: say(@*ARGS);

[21:20] <p6eval> nqp: OUTPUT«Contextual @*ARGS not found␤current instr.: '_block1000' pc 43 ((file unknown):42) (/tmp/psRw6cmqQM:1)␤»

[21:21] <pmichaud> *that's* what nqp should likely be providing instead of MAIN.

[21:21] <japhb> Fine by me.  I just wanted *some* common way to get args in a way that didn't get off-by-one with one of them

[21:21] *** moukeddar joined
[21:22] <pmichaud> nqp likely needs to catch up with recent changes to rakudo / perl 6 there.

[21:22] *** moukeddar left
[21:22] <pmichaud> there have been some changes made to HLL::Compiler for Rakudo's benefit; I'm not sure that nQP was equally updated.

[21:23] <pmichaud> anyway, I have to run some errands :-/   bbiaw

[21:26] *** atrodo left
[21:26] <dalek> nqp: d8f20ed | jnthn++ | src/QAST/Compiler.nqp:

[21:26] <dalek> nqp: Provide a better, more uniform way to handle Want and coercion (nothing is switched to using it yet, though).

[21:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d8f20ed4fb

[21:26] <dalek> nqp: 6485fa4 | jnthn++ | src/QAST/Compiler.nqp:

[21:26] <dalek> nqp: Switch handling of attribute bind values to the new Want-aware coercion scheme.

[21:26] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6485fa4f7a

[21:26] <jnthn> Hmm...seems none of my YAPC::EU talks got accepted this year :(

[21:27] <japhb> That seems very odd.

[21:27] <jnthn> Guess I may as well still go.

[21:28] *** cognominal joined
[21:28] <jnthn> Though not being a speaker makes it decidedly less attractive. It's not like crouched over a laptop is a comfortable way to hack.

[21:28] <jnthn> *being

[21:28] <jnthn> (For me, that is...)

[21:29] <masak> jnthn: :(

[21:30] <dalek> rakudo/inliner: 0c46ef0 | jnthn++ | src/Perl6/Optimizer.pm:

[21:30] <dalek> rakudo/inliner: D'oh, left behind debugging code.

[21:30] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/0c46ef01f5

[21:31] *** bbkr joined
[21:32] <masak> I had completely forgotten this, but my blogging site just went down during the night.

[21:32] *** cognominal_ joined
[21:32] <masak> I guess I'll publish the blog post in a gist for the time being, and then actually publish it tomorrow morning.

[21:33] <bbkr> hmm, crypt installed by panda says "Missing block at /Users/bbkr/.perl6/bin/crypt:326"

[21:33] *** cognominal left
[21:34] <masak> bbkr: what version of Rakudo is that?

[21:34] <bbkr> Star 2012.07

[21:34] <masak> huh.

[21:34] <masak> This is perl6 version 2012.07-208-gb87659a built on parrot 4.5.0 revision RELEASE_4_5_0

[21:35] <masak> and it runs fine here.

[21:35] <masak> and I don't see anything odd on line 325.

[21:35] <masak> er, 326.

[21:35] <masak> anyway, here we go: "lol", I "blogged"! "\o/" https://gist.github.com/3220769

[21:35] <bbkr> i just cloned repo and got the same result when trying to validate with -c flag.

[21:36] <masak> bbkr: game starts normally here. no parse error.

[21:36] <bbkr> have you tried on star release?

[21:36] <lue> how do I get rakudo to install into ~/.perl6 so I can make panda work?

[21:36] <masak> bbkr: nope.

[21:36] <tadzik> lue: how are those two related?

[21:37] <bbkr> lue: you don't have to. do you use Star or only compiler?

[21:37] <lue> tadzik: because make install (no sudo) just installs stuff in ~/rakudo/install, which I don't like (in fact, I have no ~/.perl6 right now)

[21:37] <tadzik> lue: why would you need rakudo in ~/.perl6?

[21:37] <tadzik> panda installs stuff to ~/.perl6

[21:38] <tadzik> ~/.perl6 is automatically in @*INC, so you don't need to care about it

[21:38] <lue> Hm, I appear not to be thinking correctly. If only I could sudo make install on feather...

[21:39] <tadzik> lue: 1) install rakudo 2) bootstrap panda 3) everything works

[21:39] <tadzik> you don't need to care about where stuff gets installed

[21:40] *** cognominal__ joined
[21:40] <lue> number 3 doesn't wfm. Hang on, lemme finish compiling rakudo and then I'll try panda again.

[21:41] *** cognominal_ left
[21:43] <lue> But just running "perl6 bootstrap.pl" throws an error, likely because feather's rakudo is very old. So I'd have to do some magic with $PATH to get it to work.

[21:44] *** cognominal__ left
[21:45] *** cognominal joined
[21:45] <lue> masak++

[21:45] <masak> yes, feather's rakudo is very old.

[21:45] <masak> you could install a newer one in your homedir, perhaps?

[21:46] <lue> that's what I wanted to do :) right now it just goes in ~/rakudo/install, and I thought (for whatever reason) it was supposed to be in ~/.perl6 for a homedir install

[21:47] <tadzik> ~/rakudo/install is fine

[21:47] <tadzik> panda doesn't care where your rakudo is, as long as 'perl6' is in $PATH

[21:47] * tadzik sleeps &

[21:48] <lue> I should probably put ~/rakudo/install/bin first in $PATH's list, right?

[21:48] <tadzik> I think so

[21:48] <masak> sounds about right.

[21:49] <lue> .oO(Is it bad that I'm so used to being able to install stuff in /usr/local that when I'm on feather and can't I've lost the ability to do things correctly? :) )

[21:52] <masak> consider it an opportunity to learn how to do without sudo ;)

[21:54] <bbkr> masak: this is weird, syntax error about missing block disappeared when i commented line "when X::Adventure …" in CATCH, but at the same time Adventure::Engine syntax that provides this class is OK

[21:55] <masak> bbkr: that does sound weird.

[22:04] *** PacoAir left
[22:09] *** spider-mario left
[22:10] <bbkr> star: CATCH { when X::Y {} }

[22:10] <p6eval> star 2012.07: OUTPUT«===SORRY!===␤Missing block␤at /tmp/4LoyksdaLg:1␤»

[22:11] <bbkr> hm, does not make any sense

[22:11] <bbkr> r: CATCH { when X::Y {} }

[22:11] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Missing block␤at /tmp/NTZDH8L6yj:1␤»

[22:12] <lue> r: class X::Y{ }; CATCH when X::Y { } }

[22:12] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Missing block␤at /tmp/AG1zwwTQ08:1␤»

[22:12] <lue> r: class X::Y{ }; CATCH { when X::Y { } }

[22:12] <p6eval> rakudo c1bfbb:  ( no output )

[22:12] <bbkr> i know X::Y is not defined, but in this case error message is way LTA

[22:13] <lue> agreed

[22:13] <lue> star: class X::Y{ }; CATCH { when X::Y { } }

[22:13] <p6eval> star 2012.07:  ( no output )

[22:14] * bbkr reports

[22:19] *** fridim_ left
[22:19] <bbkr> that partially explains masak's crypt game issue - somehow it cannot see X::Adventure type in CATCH scope

[22:20] *** benabik left
[22:21] *** benabik joined
[22:23] <masak> bbkr++

[22:24] * lue can't believe he didn't set up panda sooner!

[22:25] <masak> :)

[22:28] <lue> Now I'm off to try using Adventure::Engine!

[22:30] <masak> \o/

[22:31] <bbkr> digging further problem with missing block message disappeared (X::Adventure became visible inside CATCH scope) after I removed Hanoi/Game.pir.

[22:32] <bbkr> can you compile this file to pir and check if crypt works?

[22:33] <bbkr> maybe we have similiar issue that was once spotten on non-deterministic URI compilation

[22:33] <masak> ugh. tomorrow. :/

[22:33] <bbkr> spotted*

[22:33] <bbkr> masak: no rush

[22:33] <masak> I've shut down my brain for today, sorry.

[22:34] *** skids joined
[22:35] <lue> (ooh, I was about to ask about putting a subroutine on an exit, but then I spot on_try_exit in Crypt's BUILD!)

[22:35] *** bluescreen10 left
[22:39] <masak> lue: yes! that's why reading BUILD is instructive ;)

[22:41] <lue> Since I've suddenly decided my real game (just writing a small demo to get used to A::E) takes place in the sky, there are a lot of directions where ***You have died***.

[22:41] <lue> And in those directions, I'd like to ask "Are you sure?" first, so a sub is necessary.

[22:43] <masak> well, hooks allow further events to be emitted, but not user interaction.

[22:44] <masak> the .on_try_exit hook is the only one that conditionally cancels its parent action as well (with a Bool).

[22:44] <pmichaud> jnthn: my talk wasn't accepted either, it would seem.

[22:44] <masak> :(

[22:44] <masak> that sucks.

[22:45] <pmichaud> looks like two of Carl's talks were accepted... and that's it.

[22:45] <pmichaud> http://act.yapc.eu/ye2012/talks/tag/perl6

[22:45] *** Coleoid joined
[22:45] *** Chillance left
[22:46] *** Chillance joined
[22:46] <pmichaud> masak: I guess you're the voice of Perl 6 for YAPC::EU :-) :-)

[22:46] <masak> oh crap :P

[22:47] <benabik> Apparently the voice of Perl 6 is a potty mouth.  ;-)

[22:48] <jnthn> pmichaud: Aww. :(

[22:49] * jnthn always enjoys the Pm talks :)

[22:49] * masak too

[22:49] <masak> and the jnthn talks as well.

[22:49] <jnthn> masak: huh, you get to see jnthn talks more than most :P

[22:49] <Tene> masak: I guess you'll just have to impersonate both jnthn and pmichaud during your talk

[22:49] <masak> the results don't feel commensurate with the awesomenesses of the speakers, is all I'm saying.

[22:50] *** lucas_ joined
[22:50] <masak> Tene: somehow I'm not sure that would help anything, really...

[22:51] <Tene> I think i've seen recorded jnthn and pm talks, but I don't think I've ever seen a masak talk.

[22:51] <masak> there's a few of them out there. none of them are very notable.

[22:52] <jnthn> Oh come on. The module cheese one... :P

[22:52] <jnthn> Though dunno if that was videod. :)

[22:53] <masak> don't think so.

[22:53] <masak> well, I remember a camera from that one.

[22:53] <masak> but I've never seen any video come out of it.

[22:53] <masak> jnthn: it was actually still a Rakudo cheese at that point. the module cheese evolved out from that.

[22:54] <masak> but yeah, that was a terribly successful talk. I have bugger all idea why, because it wasn't very good :P

[22:54] <masak> http://www.perlworkshop.no/npw2009/talk/1734

[22:55] <pmichaud> masak: you're way in the minority opinion there

[22:55] <pmichaud> I thought that talk was the best I saw at the workshop.

[22:55] <masak> o.O

[22:55] <masak> wow. thanks.

[22:55] <pmichaud> (of course, I didn't see my talk, so I can't compare.  I still thought yours was better than mine, but I'm a biased observer :)

[22:56] <masak> anyway, tadzik++ has realized most of the ecosystem dreams of that talk.

[22:56] <masak> plus Emmentaler, which I never put in a talk.

[22:57] * masak yawns

[22:57] <masak> good night, #perl6. it was nice talking to you. you're awesome.

[23:00] <sorear> goodbye masak *cries*

[23:00] <pmichaud> oh, wait, looks like Moritz' talk was accepted also.

[23:00] <pmichaud> both of his talks!  So that makes four.

[23:01] <pmichaud> http://act.yapc.eu/ye2012/talk/4055

[23:01] <pmichaud> http://act.yapc.eu/ye2012/talk/4202

[23:01] <sorear> agh, I really need to get travel plans sorted ASAP

[23:01] * sorear makes panicky gestures

[23:01] <pmichaud> okay, I feel better now, although I was really looking forward to jnthn++'s talk on roles.

[23:02] <pmichaud> that just seems sooooooo timely and useful for this conference

[23:03] <jnthn> pmichaud: There is a roles talk though: http://act.yapc.eu/ye2012/talk/4150

[23:03] <pmichaud> yeah, true.

[23:03] <jnthn> pmichaud: I guess maybe my one may have clashed a bit wiht that. But I did submit another one too... :)

[23:06] <pmichaud> so, it looks like they've accepted around 20 new talks since the "no perl 6 talks at yapc::eu" posting, and 4 of those are Perl 6 related.  That's not too bad, considering where things started.

[23:06] <jnthn> aye

[23:06] <pmichaud> anyway, I guess I'll have to come up with a good lightning talk, although those slots are filling up also.

[23:07] <pmichaud> and I'm still fairly disappointed that none of my yapc::na talks have made it to youtube yet :-|

[23:07] <pmichaud> (at least, not officially)

[23:07] <pmichaud> looks like they got up to "M" (Mark Straman) and stopped.

[23:08] <pmichaud> (http://youtube.com/yapcna)

[23:10] <sorear> what's the official explanation?

[23:10] <sorear> were they unable to get music distribution licenses for the other talks?

[23:10] *** erkan joined
[23:10] *** erkan left
[23:10] *** erkan joined
[23:15] *** plobsing joined
[23:18] <pmichaud> there has been no explanation yet.

[23:18] <pmichaud> I'm certain they had license for distributing the other talks; reportedly it was one of the criteria for acceptance

[23:18] <pmichaud> but just looking through the talk page, it looks as though they've been posting talks in alphabetical order by first name.

[23:19] <pmichaud> thus they've only gotten as far as "Mark", and "Patrick" collates after that.

[23:20] <pmichaud> afk, dinner

[23:21] <sorear> and they just stopped?  how long has it been since they last posted a new talk?

[23:22] <pmichaud> ten days.  last post was July 21.

[23:27] * sorear wonders if they will ever get to pm

[23:27] <sorear> did they ever finish uploading ::NA 2011?

[23:31] *** benabik left
[23:37] *** benabik joined
[23:40] *** thelazydeveloper left
[23:43] <skids> r: sub a () returns Int { fail("foo") }; a().WHAT.say; # http://perlcabal.org/syn/S02.html#Undefined_types would suggest a Failure here, though not necessarily the "foo" Failure itself.

[23:43] <p6eval> rakudo c1bfbb: OUTPUT«Type check failed for return value; expected 'Int' but got 'Failure'␤  in sub a at /tmp/eSqEPViPUG:1␤  in block  at /tmp/eSqEPViPUG:1␤␤»

[23:45] <[Coke]> does panda's bootstrap care which perl6 is in your path, or does it use the perl6 it was invoked with?

[23:48] <[Coke]> skids: huh. I wonder how you're you're supposed to fail out of a typed sub, ten.

[23:48] <[Coke]> *then.

[23:49] *** plobsing left
[23:53] <benabik> Either Failure should be ignored by the type checker, or the act of checking its type should cause it to throw.

[23:58] *** cognominal_ joined
