[00:13] *** havenn joined
[00:17] *** sftp left
[00:19] *** spider-mario left
[00:31] *** adu left
[00:41] *** tokuhiro_ joined
[00:43] *** adu joined
[00:47] *** xinming left
[00:52] *** jj123 joined
[00:53] *** xinming joined
[00:53] *** jj123 left
[01:06] *** friendofthefanat joined
[01:06] <friendofthefanat> hello

[01:07] *** havenn left
[01:07] *** topo`_ is now known as topo`

[01:08] <TimToady> most of the interesting people have gone to sleep

[01:10] *** sftp joined
[01:10] *** friendofthefanat left
[01:11] *** johnny4shure joined
[01:11] <johnny4shure> is that you lewis?

[01:12] <johnny4shure> #quietfanatic

[01:12] <johnny4shure> nvm no its not

[01:12] <TimToady> quietfanatic is his nick

[01:13] <johnny4shure> I know, I checked his IP and its not where it would be if he was who is claims to be

[01:13] <TimToady> many of us run screen sessions on long-running servers

[01:14] <johnny4shure> ah

[01:14] <TimToady> and the irc "server" is kinda arbitrary anyway

[01:15] <TimToady> quietfanatic is on appflux, the same server I use, which is, I believe, in Virginia

[01:16] <johnny4shure> ah I see

[01:16] <johnny4shure> any good perl 5 tutorials? / books?

[01:17] <TimToady> well, I hear the Camel book is pretty good... :-)

[01:17] <TimToady> but it really depends on your learning style

[01:19] <geekosaur> p5 is probably best not discussed here, though

[01:19] <johnny4shure> oops sorry guys my bad

[01:20] <TimToady> yah, the folks hang out here are mostly interested in p6, but it's okay

[01:20] <TimToady> we talk about p5 sometimes too :)

[01:20] <geekosaur> (some people here do know p5 fairly well, but not all)

[01:21] <johnny4shure> perl 6 isnt released is it?

[01:21] <TimToady> "It's released every month."

[01:21] <johnny4shure> lol

[01:21] <johnny4shure> from the man himself

[01:21] <TimToady> no implementation implements the entire spec yet, fershure

[01:22] <johnny4shure> ah

[01:22] <TimToady> and none of the implementations quite measure up to p5 in terms of speed

[01:22] <TimToady> (yet)

[01:23] <TimToady> but http://rosettacode.org/wiki/Category:Perl_6 has 481 examples of (mostly) running Perl 6 code

[01:24] <TimToady> otoh there's no Camel book for it yet

[01:27] * sorear waves to johnny4shure

[01:28] <johnny4shure> Im not sure how to wave back :)

[01:29] <sorear> I did /me waves to ...

[01:29] <sorear> in theory /commands depend on your choice of client, but /me is pretty standard

[01:29] *** cognominal joined
[01:31] <sorear> I'm still up, unsure if I count as an interesting person...

[01:31] <TimToady> well, I hedged it in any case, like a good engineer

[01:37] <johnny4shure> haha

[01:37] *** cognominal left
[01:37] *** cognominal_ joined
[01:38] <johnny4shure> is it a mystery when the camel book for perl 6 will grace us with its presence?

[01:38] <[Coke]> moritz: you added S03-operators/andthen.t to rakudo's spectest - did you forget to push the test file?

[01:38] <[Coke]> phenny: ask moritz you added S03-operators/andthen.t to rakudo's spectest - did you forget to push the test file?

[01:38] <phenny> [Coke]: I'll pass that on when moritz is around.

[01:40] <TimToady> johnny4shure: well, we just have to write it first

[01:40] <johnny4shure> I guess thats true isn't it.

[01:41] * diakopter becomes more interesting

[01:42] <TimToady> diakopter: did the lights go out on all your whales?

[01:42] <diakopter> that's tomorrow

[01:42] <TimToady> ah, yes

[01:42] <diakopter> today was Monterey

[01:42] <TimToady> which is pretty much everything except whales

[01:43] <diakopter> it's a nice aquarism

[01:43] <diakopter> aquarium

[01:43] <diakopter> couldn't find much else to do

[01:43] <johnny4shure> should I start by learning perl 5 or perl 6

[01:44] <diakopter> johnny4shure: depends what you want to use it for, I guess

[01:44] <TimToady> there'r some nice restaurants, and shop that sells all kinds of hot sauce

[01:44] <johnny4shure> web development

[01:44] <TimToady> does it also have to run on your teacher's computer?

[01:45] <johnny4shure> nah

[01:45] <johnny4shure> just mine :)

[01:46] <johnny4shure> Im trying to abandon rails

[01:46] *** cognominal_ left
[01:46] <johnny4shure> just cause I've realized it's not the proper tool for any job imho

[01:46] <TimToady> there's a web framework for p6 called Bailador, but I don't know what it's state is, and the people who do know are mostly asleep

[01:47] <TimToady> 'course you can always roll your own with Perl

[01:47] * johnny4shure 

[01:48] <TimToady> p5 will have many more existing tools on various levels currently, since p6 is still being explored

[01:48] <TimToady> otoh p6 is a nicer language to work with

[01:48] <johnny4shure> I was looking at catalyst

[01:49] <TimToady> that's a common choice, and good for many uses

[01:49] <TimToady> a bit harder to get going in, but probably more flexible than rails

[01:50] <johnny4shure> ive just hit a lot of operating boundaries of rails way too fast

[01:50] <TimToady> web frameworkds in p5 do tend to bring out strong opinions in people though, so don't expect everyone to agree with your choice :)

[01:52] <TimToady> it's not like in ruby where rails is almost completely dominant

[01:53] *** bowtie left
[01:53] <johnny4shure> I hate uniformity so I can deal

[01:54] <diakopter> I'm confused. how is my single-threaded Java program maxing all four cores

[01:54] <johnny4shure> infinite loop?

[01:55] <johnny4shure> but that would only max one

[01:55] <johnny4shure> so nvm

[01:55] <cotto> very infinite loop

[01:55] *** johnny4shure left
[01:55] <TimToady> maybe the optimizer is attempting some autothreading

[01:55] *** cognominal_ joined
[01:55] <diakopter> that would be seriously *impressive*

[01:56] <diakopter> though how it derived that this algorithm is wait-free and trivially parallelizable, I don't know

[01:56] <TimToady> well, one thread can easily be the GC

[01:57] <TimToady> and maybe the GC can multithread if if gets tired

[01:57] <diakopter> nm, I found it. I was actually launching 128 threads that were all spinning

[01:57] <TimToady> *ifit

[01:57] <diakopter> forgot to disable this other thing

[01:58] <cotto> I like all of the less likely explanations.

[01:58] <TimToady> 1. Write an autothreader for Perl 6.

[01:59] <TimToady> 2. Write a Java-to-Perl 6 translator

[01:59] <TimToady> 3. ???

[01:59] <TimToady> 4. Profit

[02:01] *** cognominal_ left
[02:11] <Timbus> <diakopter> I'm confused. how is my single-threaded Java program maxing all four cores -> <diakopter> nm, I found it. I was actually launching 128 threads

[02:11] <Timbus> my sides

[02:11] <diakopter> :)

[02:11] *** adu left
[02:11] <diakopter> well, I thought I had commented out all the threadpool thing

[02:12] <diakopter> but missed some

[02:12] <diakopter> (I hadn't seen it use all the cores yet)

[02:17] <diakopter> my statements. the jvm or cpu, it's reordering them.

[02:17] <diakopter> or both.

[02:25] <sorear> cpus reorder statements all the time

[02:25] <sorear> and even when they don't, memory models often make it look like they do

[02:25] <sorear> cache coherency protocols are seriously funky

[02:38] *** jlaire left
[02:38] *** sizz_ left
[02:39] *** sizz joined
[02:43] *** jlaire joined
[02:47] *** xinming left
[02:48] *** xinming joined
[02:52] *** tokuhiro_ left
[02:53] <japhb> I'm reminded of "Variables won't; constants aren't."

[02:55] *** tokuhiro_ joined
[02:59] *** tokuhiro_ left
[03:07] *** xdbr_ left
[03:09] *** orafu left
[03:10] *** orafu joined
[03:20] *** REPLeffect joined
[03:44] *** daniel-s_ is now known as daniel-s

[03:47] *** xinming_ joined
[03:50] *** xinming left
[03:54] *** plobsing left
[04:02] *** [particle]1 joined
[04:04] *** [particle] left
[04:08] <dalek> perl6-roast-data: d80f178 | coke++ | / (9 files):

[04:08] <dalek> perl6-roast-data: * rebuild from scratch each time.

[04:08] <dalek> perl6-roast-data: * Rename file tests.

[04:08] <dalek> perl6-roast-data: * use one version of roast

[04:08] <dalek> perl6-roast-data: * record roast sha1

[04:08] <dalek> perl6-roast-data: * avoid div-by-zero error.

[04:08] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d80f178404

[04:08] <dalek> perl6-roast-data: dd6ac96 | coke++ | bin/niecza.sh:

[04:08] <dalek> perl6-roast-data: Need a ./perl6 for test_summary.

[04:08] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/dd6ac96f00

[04:08] <dalek> perl6-roast-data: 405f649 | coke++ | / (4 files):

[04:08] <dalek> perl6-roast-data: today (automated commit)

[04:08] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/405f6493bd

[04:08] <[Coke]> there. rakudo is up about 1K tests from a month ago.

[04:14] <[Coke]> I've reinstalled the cron job, hopefully we'll get daily runs again.

[04:28] *** jlaire left
[04:32] <dalek> roast: a2adec0 | coke++ | integration/weird-errors.t:

[04:32] <dalek> roast: refudge for niecza

[04:32] <dalek> roast: review: https://github.com/perl6/roast/commit/a2adec0081

[04:35] *** jlaire joined
[04:40] <grondilu_> r: macro f($x) { "{{{$x}}} (just testing macros)" };  say f "ok"

[04:41] <p6eval> rakudo 68460c: OUTPUT¬´f‚ê§===SORRY!===‚ê§too few positional arguments: 2 passed, 3 (or more) expected‚ê§¬ª

[04:41] <grondilu_> *

[04:41] *** grondilu_ left
[04:43] *** grondilu joined
[04:47] *** xinming joined
[04:50] *** xinming_ left
[04:57] *** Chillance left
[05:01] *** topo` left
[05:48] *** xinming_ joined
[05:50] *** xinming left
[05:53] <[Coke]> r: macro f($x) { quasi "{{{$x}}} (just testing macros)" } } ; say f "ok"

[05:53] <p6eval> rakudo 68460c: OUTPUT¬´===SORRY!===‚ê§Missing block‚ê§at /tmp/QaW2tPJF8Y:1‚ê§¬ª

[05:54] *** xinming_ left
[05:54] *** xinming joined
[05:55] *** gootle joined
[05:57] <diakopter> r: macro f($x) { quasi { "{{{$x}}} (just testing macros)" } } ; say f "ok"

[05:57] <p6eval> rakudo 68460c: OUTPUT¬´AST<-1403658370> (just testing macros)‚ê§¬ª

[06:21] <grondilu> shouldn't it output "ok (just testing macros)"?

[06:24] <sorear> no

[06:24] <sorear> the outermost layer of {} delimits code from text

[06:24] <sorear> the code which is interpolated is just {{$x}} which is equivalent to $x

[06:24] <sorear> r: macro f($x) { quasi { "{{{{$x}}}} (just testing macros)" } } ; say f "ok"

[06:24] <p6eval> rakudo 68460c: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling block f: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote‚ê§at /tmp/cM33Hcj2KD:1‚ê§¬ª

[06:25] <sorear> r: macro f($x) { quasi { {{{$z}}} ~ " (just testing macros)" } } ; say f "ok"

[06:25] <p6eval> rakudo 68460c: OUTPUT¬´===SORRY!===‚ê§Variable $z is not declared‚ê§at /tmp/ZqjmVP9ZWV:1‚ê§¬ª

[06:25] <sorear> r: macro f($x) { quasi { {{{$x}}} ~ " (just testing macros)" } } ; say f "ok"

[06:25] <p6eval> rakudo 68460c: OUTPUT¬´ok (just testing macros)‚ê§¬ª

[06:26] <sorear> phenny: tell masak interpolating unquotes into strings like "foo {{{{$x}}}} bar" breaks messily. diakopter++

[06:26] <phenny> sorear: I'll pass that on when masak is around.

[06:26] <sorear> r: macro f($x) { quasi { for 1..5 { {{{$x}}} } } } ; say f "ok"

[06:26] <p6eval> rakudo 68460c: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling block f: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote‚ê§at /tmp/hTSrBKOAU4:1‚ê§¬ª

[06:26] <sorear> phenny: tell masak update/retraction: it's actually a generic issue with block-wrapping syntaxes and probably something you know about

[06:26] <phenny> sorear: I'll pass that on when masak is around.

[06:29] <grondilu> r: macro infix:<m+>($a, $b) { quasi { ({{{$a}}} + {{{$b}}}) % 13 } }; say [m+] ^10;

[06:29] <p6eval> rakudo 68460c: OUTPUT¬´Type check failed in unquote evaluation; expected AST but got Int‚ê§  in method evaluate_unquotes at src/gen/CORE.setting:10274‚ê§  in method incarnate at src/gen/CORE.setting:10264‚ê§  in macro infix:<m+> at /tmp/Px9WO9UEdl:1‚ê§  in sub  at src/gen/CORE.setting:12223‚ê§  in‚Ä¶

[06:30] <grondilu> can't I use a macro operator with a meta-operator?

[06:31] *** tokuhiro_ joined
[06:31] <grondilu> (if that makes any sense, which I'm not sure)

[06:33] <diakopter> [Coke]++ for that one, actually

[06:33] <sorear> grondilu: I don't think so.

[06:34] <sorear> macros, because of their ability to look into expressions, subvert the higher-order function system

[06:34] <grondilu> yeah that's what I thought.

[06:35] <sorear> masak et al been talking about allowing macros in HOFs, but silently converting them to subs, along the lines of sub ($x,$y) { $x m+ $y }

[06:35] <grondilu> that would be nice

[06:35] <sorear> I'm a little dubious of this, it seems to me that if a macro _can_ usefully be turned into a sub, it _should_ have been a sub to begin with

[06:35] *** tokuhiro_ left
[06:36] <sorear> I can't think of a case where it'd be a win to use a macro where a sub would do

[06:36] <sorear> other than working around stupid optimizers

[06:36] <grondilu> wouldn't a macro be faster?

[06:36] <diakopter> r: print &fff

[06:37] <p6eval> rakudo 68460c:  ( no output )

[06:37] <diakopter> O_O

[06:37] <diakopter> r: print &fff; say 'alive'

[06:37] <p6eval> rakudo 68460c: OUTPUT¬´alive‚ê§¬ª

[06:38] <diakopter> r: say (&fff).WHAT; say 'alive'

[06:38] <p6eval> rakudo 68460c: OUTPUT¬´Nil‚ê§alive‚ê§¬ª

[06:38] <diakopter> std: say (&fff).WHAT; say 'alive'

[06:38] <p6eval> std 04216b1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§ 'fff' used at line 1‚ê§Check failed‚ê§FAILED 00:00 45m‚ê§¬ª

[06:38] <diakopter> that seems new

[06:39] <diakopter> phenny: tell masak r: print &fff; say 'alive' # no error like std? # also r: say (&fff).WHAT; say 'alive'

[06:39] <phenny> diakopter: I'll pass that on when masak is around.

[06:43] *** adu joined
[06:46] <diakopter> r: macro foo { quasi { say macro bar { 55 } } }; say foo

[06:46] <p6eval> rakudo 68460c: OUTPUT¬´===SORRY!===‚ê§Method 'evaluate_unquotes' not found for invocant of class 'NQPMu'‚ê§at /tmp/oVJS9KJsJs:1‚ê§¬ª

[06:46] <diakopter> phenny: tell masak r: macro foo { quasi { say macro bar { 55 } } }; say foo # boom

[06:46] <phenny> diakopter: I'll pass that on when masak is around.

[06:51] *** xinming left
[06:52] <sorear> grondilu: if macros are faster than small subs, it means your inliner is broken

[06:53] *** xinming joined
[06:53] <grondilu> sorear: ok

[06:55] <diakopter> phenny: tell masak r: macro foo { die macro bar { 55 } } # different kind of boom

[06:55] <phenny> diakopter: I'll pass that on when masak is around.

[06:55] <diakopter> phenny: tell masak r: macro foo { die macro bar { 55 } }; foo # another different kind of boom

[06:55] <phenny> diakopter: I'll pass that on when masak is around.

[06:55] <diakopter> r: macro foo { die macro bar { 55 } }; foo

[06:55] <p6eval> rakudo 68460c: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling block foo: Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Error while compiling op call: Unknown QAST node type NQPMu‚ê§at /tmp/uKpHj4LjXH‚Ä¶

[06:58] <diakopter> star: macro foo { package bar { } }; foo

[06:58] <p6eval> star 2012.10: OUTPUT¬´===SORRY!===‚ê§too few positional arguments: 2 passed, 3 (or more) expected‚ê§¬ª

[06:59] <diakopter> r: macro foo { package bar { } }; foo

[06:59] <p6eval> rakudo 68460c: OUTPUT¬´foo‚ê§===SORRY!===‚ê§too few positional arguments: 2 passed, 3 (or more) expected‚ê§¬ª

[06:59] <diakopter> phenny: tell masak r: macro foo { package bar { } }; foo # weird boom

[06:59] <phenny> diakopter: I'll pass that on when masak is around.

[07:03] *** ingy left
[07:03] *** ingy joined
[07:06] <diakopter> r: require lion

[07:06] <p6eval> rakudo 68460c: OUTPUT¬´Could not find lion in any of: /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/vendor/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/site/lib, /home/p6eval/.perl6/2012‚Ä¶

[07:17] <diakopter> r: say (macro a { }).DUMP

[07:17] <p6eval> rakudo 68460c: OUTPUT¬´(timeout)¬ª

[07:17] <diakopter> I'll time you out

[07:43] * grondilu created http://rosettacode.org/wiki/Talk:Permutations_by_swapping#Alternative_Perl6_version

[07:47] *** xinming_ joined
[07:48] <grondilu> ahh it does not work

[07:49] * grondilu removed it

[07:50] *** xinming left
[07:53] *** jaldhar left
[07:57] *** tokuhiro_ joined
[08:06] *** l3x joined
[08:07] *** GlitchMr joined
[08:11] *** l3x is now known as l3xer

[08:17] *** SamuraiJack joined
[08:21] *** adu left
[08:24] *** zby_home joined
[08:27] *** domidumont joined
[08:48] *** xinming joined
[08:51] *** xinming_ left
[08:51] *** domidumont left
[08:52] *** domidumont joined
[08:59] *** tokuhiro_ left
[09:00] *** tokuhiro_ joined
[09:04] *** tokuhiro_ left
[09:16] *** kaare_ joined
[09:20] *** l3xer left
[09:21] *** l3xer joined
[09:32] *** orafu left
[09:42] *** kaare_ left
[09:44] *** Patterner left
[09:44] *** Psyche^ joined
[09:46] *** kaare_ joined
[09:48] *** xinming_ joined
[09:49] *** Psyche^ left
[09:50] *** Psyche^ joined
[09:50] *** Psyche^ is now known as Patterner

[09:51] *** xinming left
[10:04] <GlitchMr> eval: print "\x{FF5F}\x{FF60}"

[10:04] <buubot_backup> GlitchMr: ÔΩüÔΩ†1

[10:05] <GlitchMr> eval: print "\x{201c}\x{201d}"

[10:05] <buubot_backup> GlitchMr: ‚Äú‚Äù1

[10:16] *** spider-mario joined
[10:22] <GlitchMr> Also: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/Actions.pm#L3469

[10:22] <GlitchMr> Somehow I doubt this line is intentional

[10:22] <GlitchMr> Could it be removed?

[10:29] *** Patterner left
[10:29] *** l3xer left
[10:29] *** Psyche^ joined
[10:29] *** Psyche^ is now known as Patterner

[10:44] <jnthn> ohhai o/

[10:45] <tadzik> oh hai

[10:45] <jnthn> [Coke]++ # fixing the roast data

[10:46] <jnthn> Rakudo has quietly sneaked past the 24,000 passing tests marker, it seems :)

[10:47] *** xinming_ left
[10:48] *** xinming joined
[10:49] <dalek> rakudo/nom: 64208d7 | jnthn++ | src/Perl6/Actions.pm:

[10:49] <dalek> rakudo/nom: Remove leftover debugging code; GlitchMr++.

[10:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/64208d73c6

[11:00] *** sisar joined
[11:01] *** kaare_ left
[11:01] *** leont joined
[11:03] <lumi__> Is there some way to evaluate macro arguments?

[11:09] <jnthn> Haven't seen one, though may just be NYI

[11:09] *** kaare_ joined
[11:10] <jnthn> Well, I mean, there's no "official" way. Of course, there's *a way*. :)

[11:10] <jnthn> r: sub eval_ast($ast) { eval 'macro m() { quasi { {{{$ast}}} } }; m' }; macro foo($a) { say eval_ast($a); $a }; foo 42

[11:10] <p6eval> rakudo 68460c: OUTPUT¬´42‚ê§¬ª

[11:29] *** PacoAir joined
[11:36] *** kaare_ left
[11:37] *** kaare_ joined
[11:48] *** xinming_ joined
[11:51] *** xinming left
[11:52] *** jaffa4 joined
[11:52] <jaffa4> hi

[11:53] <jaffa4> What does :? do in regular expression?

[11:55] <jnthn> jaffa4: After a quantifier? It's a backtracking modifier, iirc. 

[11:55] <jnthn> Gives you frugal matching

[11:55] <jaffa4> What is frugal matching?

[11:55] *** MayDaniel joined
[11:55] <jnthn> r: say 'aaa' ~~ /\w+/

[11:55] <p6eval> rakudo 64208d: OUTPUT¬´ÔΩ¢aaaÔΩ£‚ê§‚ê§¬ª

[11:55] <jnthn> r: say 'aaa' ~~ /\w+:?/

[11:55] <p6eval> rakudo 64208d: OUTPUT¬´ÔΩ¢aÔΩ£‚ê§‚ê§¬ª

[11:56] <jnthn> It does the quantifier, but does as few characters as it can, rather than swallowing as many as it can.

[11:56] *** chee joined
[11:56] <jaffa4> This is what ? did in Perl 5

[11:56] <jnthn> r: say 'aaa' ~~ /\w+?/

[11:56] <p6eval> rakudo 64208d: OUTPUT¬´ÔΩ¢aÔΩ£‚ê§‚ê§¬ª

[11:56] <jnthn> And still does in Perl 6 :)

[11:56] <jaffa4> What difference does : make?

[11:59] <jnthn> Looking at the implementation...none...

[11:59] <jnthn> However, note that : on its own means no backtracking

[12:00] <jnthn> : is don't backtrack, :? is frugal backtracking, :! is greedy backtracking

[12:01] <jaffa4> backtracking I understand but what is the difference between greedy backtracking and frugal?

[12:02] <jnthn> Greedy = match as much as you can, and if you have to backtrack then try matching less

[12:02] <jnthn> Frugal = match as little as you can, and if you have to backtrack then try matching more

[12:02] <jnthn> r: say 'abab' ~~ /\w+b/

[12:03] <p6eval> rakudo 64208d: OUTPUT¬´ÔΩ¢ababÔΩ£‚ê§‚ê§¬ª

[12:03] <jnthn> r: say 'abab' ~~ /\w+?b/

[12:03] <p6eval> rakudo 64208d: OUTPUT¬´ÔΩ¢abÔΩ£‚ê§‚ê§¬ª

[12:04] <jaffa4> r: say 'abab' ~~ /\w+!b/

[12:04] <p6eval> rakudo 64208d: OUTPUT¬´ÔΩ¢ababÔΩ£‚ê§‚ê§¬ª

[12:04] <jaffa4> I guess with ! is the same as without !

[12:05] <jnthn> In a regex, yes.

[12:05] <jnthn> In a rule or token declaration, the default is ratchet (no backtracking)

[12:05] <jaffa4> ok, thanks

[12:16] *** bowtie joined
[12:21] *** jerome left
[12:34] *** jerome joined
[12:35] *** Psyche^ joined
[12:35] *** Patterner left
[12:35] *** Psyche^ is now known as Patterner

[12:40] *** mcero joined
[12:47] *** jaldhar joined
[12:48] *** xinming joined
[12:51] *** xinming_ left
[12:58] *** zby_home left
[13:00] *** sisar left
[13:09] *** cognominal joined
[13:14] *** benabik left
[13:24] *** cognominal left
[13:28] *** tokuhiro_ joined
[13:31] *** cognominal joined
[13:31] *** leont left
[13:32] *** tokuhiro_ left
[13:33] *** jaldhar left
[13:44] *** jaldhar joined
[13:45] <masak> g'day, #perl6

[13:45] <phenny> masak: 06:26Z <sorear> tell masak interpolating unquotes into strings like "foo {{{{$x}}}} bar" breaks messily. diakopter++

[13:45] <phenny> masak: 06:26Z <sorear> tell masak update/retraction: it's actually a generic issue with block-wrapping syntaxes and probably something you know about

[13:45] <phenny> masak: 06:39Z <diakopter> tell masak r: print &fff; say 'alive' # no error like std? # also r: say (&fff).WHAT; say 'alive'

[13:45] <phenny> masak: 06:46Z <diakopter> tell masak r: macro foo { quasi { say macro bar { 55 } } }; say foo # boom

[13:45] <phenny> Further messages sent privately

[13:45] <masak> as indeed they were.

[13:45] <masak> diakopter++ # stresstesting macros

[13:46] <masak> I will get back to all of these reports after lunch.

[13:46] <masak> diakopter: re defining anything declarational inside a quasi, that's for D4, so that's not expected to work yet.

[13:47] <jnthn> o/ masak

[13:48] *** xinming_ joined
[13:51] *** xinming left
[13:55] *** cognominal left
[13:57] *** brrt joined
[14:05] *** cognominal joined
[14:17] *** brrt left
[14:18] <cognominal> hi, how to test the type of an object that is not 6model in nqp?

[14:23] <jnthn> Don't.

[14:23] <jnthn> Find another way to do what you want that means you don't have to.

[14:23] *** mhasch left
[14:23] <jnthn> The rest of Rakudo and NQP have been done without needing to do this...

[14:24] <cognominal> hum

[14:24] <jnthn> If you must, pir::isa__IPs($foo, 'SixModelObject'). But don't expect your code to be portable.

[14:26] <jnthn> Note that nqp::istype does not explode if given non-6model objects.

[14:29] <cognominal> ok, so if I want to check if the value is a string, I do a string operation in a C<try>? If it passes, it is a string?

[14:30] <jnthn> Er, most things can work as strings.

[14:30] <jnthn> nqp: say(1 ~ 2)

[14:30] <p6eval> nqp: OUTPUT¬´12‚ê§¬ª

[14:30] <jnthn> What are you actually trying to do?

[14:31] <cognominal> I am rewriting the code you gave me this summer to generated json from a match

[14:32] <cognominal> it worked only for a few cases

[14:32] <cognominal> but was a good start :)

[14:33] <jnthn> OK, and where do you hit problems?

[14:34] <cognominal> ok, I protect my  .isa(Match) and the rest can be treated as a string because I have already treated the list/hash cased.

[14:34] <cognominal> thx

[14:35] <jnthn> Note that nqp::istype($foo, NQPMatch) or so will not need protecting

[14:36] <cognominal> nice

[14:40] <jnthn> And it'll keep working :)

[14:41] *** cognominal left
[14:48] *** xinming joined
[14:49] *** cognominal joined
[14:49] *** cognominal left
[14:49] *** cognominal joined
[14:51] *** xinming_ left
[15:06] *** jaldhar left
[15:09] *** am0c joined
[15:11] <masak> cognominal: whatever it is you're doing exactly, you don't seem to be working "with the grain" of Perl 6.

[15:12] <masak> r: "foobarbaz" ~~ /foobar/; say $/.substr(3)

[15:12] <p6eval> rakudo 64208d: OUTPUT¬´bar‚ê§¬ª

[15:12] <masak> most common objects are Cool, i.e. they will act as Str if you need them to.

[15:14] *** Pleiades` left
[15:14] <grondilu> guys, what would you think of this:  http://paste.siduction.org/20121104151335 for http://rosettacode.org/wiki/Write_language_name_in_3D_ASCII  ?

[15:15] * masak looks

[15:15] <masak> aww, I expected source code.

[15:15] <grondilu> oops, I forgot to expand

[15:16] <grondilu> http://paste.siduction.org/20121104151608 

[15:16] *** Pleiades` joined
[15:16] <masak> most of these language exmples are cool. python's isn't, though. :/

[15:16] <masak> examples*

[15:17] <masak> grondilu: the output looks wrongly formed here.

[15:17] <grondilu> indeed

[15:18] <masak> and I'm still more interested in the source than the output.

[15:18] <masak> if the source is just "print this multi-line string literal", I don't think it's a nice solution.

[15:18] <masak> (IMHO)

[15:19] <jaffa4> r:/(.*?(';'\s*||()<before \x27>||()<before \x22>||<before \/\*>||<before $>||()<before \n>)) /

[15:19] <jaffa4> r: /(.*?(';'\s*||()<before \x27>||()<before \x22>||<before \/\*>||<before $>||()<before \n>)) /

[15:19] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Unrecognized regex metacharacter ) (must be quoted to match literally) at line 2, near "<before \\x"‚ê§¬ª

[15:20] <jaffa4> std: /(.*?(';'\s*||()<before \x27>||()<before \x22>||<before \/\*>||<before $>||()<before \n>)) /

[15:20] <p6eval> std 04216b1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null pattern not allowed at /tmp/fvdKiUZgEw line 1:‚ê§------> [32m/(.*?(';'\s*||([33m‚èè[31m)<before \x27>||()<before \x22>||<before[0m‚ê§    expecting any of:‚ê§       quantmod‚ê§       regex atom‚ê§     regex_infix‚ê§    sigmaybe‚ê§Parse failed‚ê§FAILED 00:00

[15:20] <p6eval> ..42m‚ê§¬ª‚Ä¶

[15:20] *** Chillance joined
[15:21] <grondilu> masak: I was planning on making a home-made compression of the string literal

[15:22] <cognominal> masak: that's nqp, not Perl 6  :)

[15:23] <masak> cognominal: I see. yes, nqp does more of explicit coercion, that's true.

[15:26] <masak> TimToady: oops! I meant to do 'does'...

[15:27] <masak> I updated https://gist.github.com/c97c37efa09d0d72ad9e to reflect this fact.

[15:28] <jaffa4> : "b\x27"~~ /<before \x27>/;

[15:29] <jaffa4> How to match \x27 without advancing .pos?

[15:30] <jnthn> Matching it will advance the position, but you can probably capture it.

[15:30] *** cognominal left
[15:31] <masak> diakopter: the accidental neologism "aquarism" sounds like a bias one might accrue if one works too much with water-dwelling creatures.

[15:34] <masak> r: macro f($x) { quasi { "{{{{$x}}}} (just testing macros)" } } ; say f "ok"

[15:34] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling block f: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote‚ê§at /tmp/ThGOl8kMre:1‚ê§¬ª

[15:34] <masak> this one is indeed interesting.

[15:34] <timotimo> masak, be wary of the aquatic supremacist types. they want to subvert (actually submerge) most of humanity

[15:34] <masak> TimToady: would you expect {{{}}} or { {{{}}} } inside a qq string in a quasi?

[15:34] * masak submits rakudobug

[15:34] <masak> timotimo: :P

[15:35] <jnthn> .oO( if you could use different stoppers for the quasis, we can avoid this crazy... :P )

[15:36] <jnthn> masak: I think the answer is that quasis only have meaning in the MAIN language, so you need to be inside the closure.

[15:36] <masak> I think that's sane, yes.

[15:36] <jnthn> er, please confirm STD actually belives what I just told you :P

[15:37] <masak> because we're essentially doing a post-lexicalizing unquote substitution here, and qq strings are tokens.

[15:37] <jnthn> They're not tokens, but the inside of them is a different language.

[15:37] <masak> right.

[15:38] <masak> they're tokens in the sense that they're one "thing" to the optable parser.

[15:38] <masak> but so are parenthetical expressions, so I guess that definition of "token" is not very standard :)

[15:38] *** cognominal joined
[15:39] <masak> r: macro f($x) { quasi { for 1..5 { {{{$x}}} } } } ; say f "ok"

[15:39] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling block f: Error while compiling block : Error while compiling block : Unknown QAST node type QAST::Unquote‚ê§at /tmp/xqmqR5HheK:1‚ê§¬ª

[15:39] <masak> huh? why the heck does that break? it looks perfectly OK to me...

[15:40] * masak submits rakuodbug

[15:40] <jnthn> Lack of delayed declarations?

[15:41] <jnthn> (a block is a declaration, really)

[15:42] <masak> no, it's failing to find and substitute the unquote.

[15:43] <masak> note to everyone about to stumble over early macro bugs: whenever you get the above "Unknown QAST node type QAST::Unquote", it means that you managed to place a {{{}}} in a place where it was not found and substituted. congratulations. it's always a bug, so make sure to report new cases.

[15:45] <jnthn> masak: Ok, well, it's both :)

[15:45] <masak> r: print &fff; say (&fff).WHAT; say 'alive'

[15:45] <p6eval> rakudo 64208d: OUTPUT¬´Nil‚ê§alive‚ê§¬ª

[15:45] <masak> I don't know what to think about this one.

[15:45] <jnthn> Unsurprising, I think.

[15:45] <jnthn> r: print Nil

[15:45] <p6eval> rakudo 64208d:  ( no output )

[15:45] <jnthn> Unless you want the &fff to whine at compile time, which arguably it should.

[15:46] <masak> r: print &foweubtweyrghasrasrt; say (&foweubtweyrghasrasrt).WHAT

[15:46] <p6eval> rakudo 64208d: OUTPUT¬´Nil‚ê§¬ª

[15:46] <masak> ah.

[15:46] <masak> n: print &foweubtweyrghasrasrt; say (&foweubtweyrghasrasrt).WHAT

[15:46] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'foweubtweyrghasrasrt' used at line 1,1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_uni‚Ä¶

[15:46] <masak> yes, it should whine, I think.

[15:46] * masak submits rakudobug

[15:46] <masak> diakopter++

[15:46] <jnthn> Make sure it's not already filed.

[15:46] <masak> ok.

[15:46] <jnthn> I'm sure we've had this discussion before...

[15:47] <jnthn> It'll need the optimizer to catch it I expect.

[15:47] <dalek> perl6-roast-data: 3276340 | coke++ | .gitignore:

[15:47] <dalek> perl6-roast-data: Ignore new roast/ dir

[15:47] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/3276340be8

[15:47] <jnthn> Can't do the variable path as postdecls are OK

[15:47] <masak> we have https://rt.perl.org/rt3/Ticket/Display.html?id=107960 which is arguably the same issue.

[15:48] *** xinming_ joined
[15:48] <masak> r: macro foo { die macro bar { 55 } }; foo

[15:48] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Error while compiling block : Error while compiling block foo: Error while compiling op p6typecheckrv: Error while compiling op lexotic: Error while compiling op p6decontrv: Error while compiling op call: Unknown QAST node type NQPMu‚ê§at /tmp/MqNFBXtLcV‚Ä¶

[15:48] * masak submits rakudobug

[15:49] <masak> r: macro foo { die "OH NOES" }; foo

[15:49] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Method 'SET_FILE_LINE' not found for invocant of class 'X::AdHoc'‚ê§¬ª

[15:49] <masak> r: macro foo { die }; foo

[15:49] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Method 'SET_FILE_LINE' not found for invocant of class 'X::AdHoc'‚ê§¬ª

[15:49] <masak> yeah, that should work.

[15:49] <jnthn> I think that's a general problem, fwiw

[15:49] <jnthn> (any non-X::Comp exception thrown at compile time, in certain cases)

[15:50] *** whiteknight joined
[15:50] <masak> r: macro foo { quasi { die "this works, though!" } }; foo; say "alive"

[15:50] <p6eval> rakudo 64208d: OUTPUT¬´this works, though!‚ê§  in  at /tmp/vMPQqM2Njn:1‚ê§  in block  at /tmp/vMPQqM2Njn:1‚ê§‚ê§¬ª

[15:50] <masak> \o/

[15:52] *** xinming left
[15:52] <jnthn> yeahbut that's thrown at runtime :)

[15:53] <masak> GlitchMr: re http://irclog.perlgeek.de/perl6/2012-11-04#i_6124794 -- please tell me more about your doubts that that line is "intentional".

[15:53] <GlitchMr> It was already fixed

[15:53] <GlitchMr> jnthn already removed that line

[15:53] <GlitchMr> It was this line: https://github.com/rakudo/rakudo/commit/64208d73c65ba32998dda503ffa0962b6efcc40b

[15:54] <masak> oh!

[15:54] <masak> yes.

[15:54] <masak> GlitchMr++

[15:54] * masak feels bad for letting that line slip through :)

[15:54] <jnthn> Don't worry, happens to all of us :)

[15:54] <GlitchMr> I've found this line while making Perl 6 changes article

[15:55] <jnthn> Also, I'm always impressed how many times people who aren't Rakudo core devs catch stuff like this. It's really nice having such code review.

[15:56] *** grondilu left
[15:56] <TimToady> masak: when we switch to ¬§ we won't have that problem

[15:57] <TimToady> ({{{}}} vs {{{{}}}})

[15:58] <jnthn> .oO( then our problem will be how the f**k to type ...that thing )

[15:58] <TimToady> it's supposed to be hard :)

[15:58] <TimToady> but witha compose key it's probably just COMPOSE ox

[15:58] <jnthn> I guess it's not replacing {{{ }}}

[15:58] <TimToady> (is how I typed it)

[15:58] <jnthn> Just additional?

[15:59] <TimToady> well ¬§() or some such

[15:59] <TimToady> ¬§foo for a direct one

[15:59] <TimToady> ¬§escape() for something that might be recognized in a string, maybe

[16:00] <TimToady> some kind of syntax to name the syntactic category that it participates in the alternation of

[16:00] <TimToady> so the parser knows what to treat it as, and what to expect after it

[16:01] <TimToady> but I'm not in a hurry to spec that since it gives masak++ a cold grue

[16:01] <TimToady> (and is not part of his grant)

[16:01] * jnthn would be curious to see it prototyped in STD

[16:02] * TimToady 2

[16:02] <jnthn> I'd perhaps be less wary of it if I knew how it worked... :)

[16:02] <masak> I would be curious to see it prototyped in spec, too.

[16:03] <TimToady> maybe I can figure it out while we're taking Julian to Disneyland this week

[16:03] <masak> it's not that I'm so against it anymore. I just know that there are conceptual problems with things I've seen proposed so far, making them unsuitable as replacements for {{{}}}

[16:04] <TimToady> can you remind me of those when they occur to you?

[16:05] <masak> it's in the logs. just search for ¬§ :P

[16:06] *** plobsing joined
[16:06] <TimToady> it's possible, I suppose, that (like your AST types determined by the lexical context), we should be determining the targetted alternation by marking the quasi, not the unquasi

[16:07] <masak> but if I recall correctly, something like parsing an operator is problematic because the information about precedence and associativity sits on the operator, which if it's parametric isn't available at parse time.

[16:07] <masak> things like that.

[16:08] <TimToady> I suspect that a restriction on parametricity is probably in order there, or you can't parse the role

[16:08] <TimToady> (correctly)

[16:08] <masak> note that I'm not distinguishing between "AST types" in any strict sense. it's more of a difference on the domain level. i.e. macro ASTs can turn out to have originated from quasis or from macro arguments.

[16:09] <TimToady> my bias these days is to try to think of such things as "types" by default, in a loose sense, since it tends to drive the design into a saner direction, even if they don't officially become types

[16:09] <masak> it's noticeable in the source code, where things were previously named $quasi_ast, and can now be named $macro_ast, etc.

[16:09] <TimToady> since many of the RFCs can be analyzed as "type failures"

[16:09] <masak> TimToady: nod.

[16:11] <TimToady> here's a funny way to do parametric operator precedence: require the operator to be defined in its own file, and stop the parse as soon as you see the operator, and then complete the parse each time it's instantiated :)

[16:11] <TimToady> but probably we should just make a way to eval something at instantiation time

[16:13] <TimToady> (and let the result of the eval poke things in where the compiler would have at compile time)

[16:13] <masak> I don't think {{{}}} is powerful enough to do things like 'class {{{$name}}} { ... }' -- which people seem to expect.

[16:13] <masak> same with subs, methods, etc.

[16:13] <masak> there seems to be an expectation that macros do this. I don't think it's at all unreasonable.

[16:14] <TimToady> hence the ¬§ proposal, as an escape that is highly unlikely to occur in normal code

[16:14] <masak> aye.

[16:14] <TimToady> so it can be special-cased in every lexer

[16:14] <jnthn> walk &

[16:15] <masak> 'class {{{$name}}} { ... }' is interesting, because what is $name? most likely, it'll be a Str. so in a way, it's a text-based macro substitution.

[16:15] <masak> (well, an AST containing a Str, I guess)

[16:16] <masak> because 'create-class MyClass;' with MyClass being a bareword won't work.

[16:16] <masak> so it'd have to be 'create-class "MyClass";'

[16:16] <TimToady> you'd really like to have something like a quasi :category<longname> { stuff } to poke in there

[16:17] <[Coke]> alright, got muddle working locally agian...

[16:17] <masak> std: Unknown::Longname

[16:17] <p6eval> std 04216b1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared name:‚ê§    'Unknown::Longname' used at line 1‚ê§Check failed‚ê§FAILED 00:00 41m‚ê§¬ª

[16:17] <masak> TimToady: my point is that if it's not declared at macro invocation time, it won't work.

[16:17] <masak> TimToady: and since the purpose of the macro is to declare it...

[16:18] *** spider-mario left
[16:18] <TimToady> that's why macros need to be able to also say "this argument is parsed as :category<longname>"

[16:19] <masak> oh, non-textual macros having a hand in how their arguments are parsed? interesting.

[16:19] <masak> yes, that would solve a lot of current issues I see.

[16:19] <TimToady> the only alternative is the one-size-fits-all aproach of Lisp

[16:19] <masak> for example how you'd even pass an operator.

[16:20] <TimToady> "the one true syntax" crops up in lots of languages for that reason

[16:20] * masak is excited by this last suggestion

[16:20] <TimToady> which last suggestion, forcing everyone to use Lisp?  :)

[16:21] <masak> no, being able to specify what category the macro arguments belong to. :)

[16:22] <TimToady> well, the parser has to know when to stop parsing any given category, but for an operator this is usually self-limiting by LTM and whatever the longest token implies

[16:22] <GlitchMr> Why Lisp? Why not Logo programming language?

[16:22] <TimToady> why not Tcl, which also has the "one true syntax"

[16:23] <masak> as does TECO.

[16:23] <masak> oh, was thinking of Trac.

[16:23] <GlitchMr> In Logo, strings, numbers, arrays and code blocks are this same type - strings

[16:23] <TimToady> I remember Tom Christiansen congratulating John Osterhaut for finding a way to force people to put the opening curly on the same line as the condition "as God and Dennis Ritchie intended it"

[16:24] <GlitchMr> (or perhaps they are arrays... not sure, really)

[16:24] <masak> in JavaScript, everything is either a double-precision float, a string, or a hash. :)

[16:24] *** leont joined
[16:25] <TimToady> but Lisp is the granddaddy of all languages that force you to use a single syntax for every possible AST

[16:25] <TimToady> they perceive this to be a feature

[16:25] <GlitchMr> masak: or undefined or null

[16:25] <GlitchMr> or NaN

[16:25] <masak> yes, it's interesting that both Arc and Clojure deviate from this trend.

[16:25] <GlitchMr> (but NaN is float...)

[16:25] <masak> GlitchMr: NaN is a double-precision float.

[16:25] <TimToady> in a sense, Perl 6 is finally inventing M-EXPRs

[16:26] <masak> TimToady: I heard the same meme from jnthn the other day.

[16:26] <masak> curious.

[16:26] <GlitchMr> I've once done a language that looks like this - https://gist.github.com/4012490

[16:26] <GlitchMr> That "almost" looks like Lisp

[16:29] <GlitchMr> (that wasn't intended to be used like normal language... it's REALLY slow)

[16:32] <jaffa4> How to make a reverse for  loop?

[16:32] <masak> r: for reverse 1, 2, 3 { .say }

[16:32] <p6eval> rakudo 64208d: OUTPUT¬´3‚ê§2‚ê§1‚ê§¬ª

[16:32] <jaffa4> ok

[16:35] *** cognominal left
[16:36] *** cognominal joined
[16:37] <GlitchMr> jaffa4: reverse makes iterator so it should be as fast as normal for loop

[16:37] *** arkydo joined
[16:37] <jaffa4> good to know

[16:39] <masak> most list functions make iterators.

[16:39] <GlitchMr> Isn't the general rule - everything makes iterator unless it's sort?

[16:40] <masak> er.

[16:41] <masak> I think we need to define terms here if the discussion is to have any meaning.

[16:41] <masak> by "iterator", I assume you mean something gather-like.

[16:42] <masak> many list function have a gather somewhere in them, either directly or indirectly.

[16:42] <masak> map and grep do, but I think Rakudo has some optimization there so it's not really gather. don't remember the details.

[16:42] *** cognominal left
[16:43] <masak> r: my @a = map { last when * %% 7; $_ }, 1..10; say @a

[16:43] <p6eval> rakudo 64208d: OUTPUT¬´1 2 3 4 5 6‚ê§¬ª

[16:44] <masak> sort isn't unique in not returning its results using gather. not even among the list functions.

[16:45] <masak> basically anything which needs the whole input before being able to emit its first piece of output will have this property.

[16:45] <masak> and note that sort still *could* return results using an iterator. I just don't think it does.

[16:48] *** xinming joined
[16:52] *** xinming_ left
[16:52] *** cognominal joined
[16:54] *** raiph joined
[16:58] <raiph> [Coke]'s spectest passing data mentions numbers for "spec" and "plan". for rakudo, for the last few months, "plan" has been higher than "spec". what's that about?

[16:58] <TimToady> yes, sort could be lazy on the last merge

[16:58] <jnthn> What types of iterators things use under the hood is probably best left as an implementation detail :)

[16:58] <jnthn> raiph: It's about people thinking explicit test plans are too much like hard work. ;)

[16:59] <jnthn> raiph: Some tests do there stuff and then have "done" at the end. Many have an explicit "plan 42;"

[17:00] <jnthn> raiph: Those with an explicit plan can be counted into spec as they can be analyzed statically without having to actually run the tests.

[17:01] <masak> it's an interesting data point in a big discussion about being explicit/redundant vs statically analyzing code for its properties.

[17:03] *** tokuhiro_ joined
[17:03] <jnthn> Personally, I'd find it more intersting to know how many spectests we actually have :P

[17:06] <masak> I don't think anyone would contest that.

[17:06] <masak> the question is more, how.

[17:07] <jnthn> What if we put the number of tests somewhere in the file, in a way that could be easily regex'd out? :D

[17:08] <masak> then we might as well plan it.

[17:08] <masak> otherwise the risk is too big that it gets out of sync.

[17:08] <jnthn> masak: You missed the sarcasm :)

[17:08] <masak> yes, I did.

[17:09] <jnthn> (My point being, that's what plan actually gives us, where it's used)

[17:09] <masak> probably because I don't fully agree with its premise.

[17:09] <masak> I think it'd be nice to have enough tooling to be able to get by with 'plan *'/'done'. I know we don't have such tooling.

[17:10] <jnthn> I'm not sure we can.

[17:10] <jnthn> What if the is/ok etc are in a loop?

[17:11] <jnthn> I guess I just don't find twiddling a number at the top of a test file painful, so fail to see the motivation for plan */done.

[17:13] <doy> why is running the test suite a problem?

[17:13] <jaffa4> How would you count number of matches in a string of regular expression?

[17:13] <jnthn> doy: Because some test files don't actually run yet.

[17:14] <raiph> is the "spec" number the total of explicit "plan"s and the "plan" number (closer to) the actual number of spec tests?

[17:14] <raiph> (ie I'm confused. :)

[17:14] <jnthn> raiph: The plan number is the number of planned tests from files that ran.

[17:14] <jnthn> The spec number is adding up the explicit plans for all files.

[17:15] <doy> jnthn: that could be fixed by explicit skip counts, couldn't it?

[17:15] <raiph> jnthn: thanks. that makes sense. any idea what the "spec" number is? :)

[17:15] <raiph> oops. thanks

[17:15] <masak> r: "aaaaaaaa" ~~ /(a)+/; say $0.elems

[17:15] <p6eval> rakudo 64208d: OUTPUT¬´8‚ê§¬ª

[17:15] <masak> jaffa4: like that?

[17:16] <masak> r: "aaaaaaaa" ~~ /(a)+/; say +$0

[17:16] <p6eval> rakudo 64208d: OUTPUT¬´8‚ê§¬ª

[17:16] <jnthn> doy: When it's the whole test file that won't parse or isn't meaningful to run, that really boils down to the number of tests in the file.

[17:16] <jnthn> Yes, we could get a better estimate by running the test that will run, adding up all that they plan, then just looking for explicit plans in the remaining test files.

[17:16] <jnthn> *tests

[17:16] <jaffa4> r: "\nererer\n" ~~ / \n /;

[17:16] <p6eval> rakudo 64208d:  ( no output )

[17:17] <jaffa4> NUmber of \n s in the text?

[17:18] <jnthn> r: say "\nererer\n".match(/\n/, :g).elems

[17:18] <p6eval> rakudo 64208d: OUTPUT¬´2‚ê§¬ª

[17:18] <jaffa4> n: say "\nererer\n".match(/\n/, :g).elems

[17:18] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´Unhandled exception: Excess arguments to Cool.match, unused named g‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (Cool.match @ 1) ‚ê§  at /tmp/dfzWZwWqb6 line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4215 (ANON @ 3) ‚ê§  at /home/p6‚Ä¶

[17:19] <jnthn> Guess it's nyi in n

[17:20] <jaffa4> n: "aaaaaaaa" ~~ /(a)+/; say $0.elems

[17:20] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´8‚ê§¬ª

[17:21] <GlitchMr> grep > +grep * eq "\n", "\nabc\n".comb

[17:21] <GlitchMr> 2

[17:21] <GlitchMr> This is probably bad hack

[17:21] <GlitchMr> I meant

[17:22] <GlitchMr> +grep * eq "\n", "\nabc\n".comb

[17:22] <jnthn> Well, if it's just \n you are about then in this specific case

[17:22] <jnthn> r: say "\nererer\n".lines.elems

[17:22] <p6eval> rakudo 64208d: OUTPUT¬´2‚ê§¬ª

[17:22] <jnthn> :)

[17:23] *** circlepuller left
[17:23] <jaffa4> yes , or "\n\n" ~~ /(.*?\n)+/;

[17:24] *** circlepuller joined
[17:24] *** arkydo left
[17:26] <masak> r: say "".lines.elems

[17:26] <p6eval> rakudo 64208d: OUTPUT¬´0‚ê§¬ª

[17:26] <masak> r: say "a".lines.elems

[17:26] <p6eval> rakudo 64208d: OUTPUT¬´1‚ê§¬ª

[17:26] <masak> r: say "\n".lines.elems

[17:26] <p6eval> rakudo 64208d: OUTPUT¬´1‚ê§¬ª

[17:26] <masak> r: say "a\n".lines.elems

[17:26] <p6eval> rakudo 64208d: OUTPUT¬´1‚ê§¬ª

[17:26] <jnthn> Yeah, it aint' really the same as looking for \n. But may be righter anyway, dependong on the use case :)

[17:37] *** Vlavv_ joined
[17:38] <masak> r: macro foo { package bar { } }

[17:38] <p6eval> rakudo 64208d:  ( no output )

[17:40] <GlitchMr> r: say +"a\nb".lines

[17:40] <p6eval> rakudo 64208d: OUTPUT¬´2‚ê§¬ª

[17:41] <GlitchMr> Yeah... I guess if you would insert \n at end of string and remove 1, it would work

[17:43] *** cognominal left
[17:48] *** xinming_ joined
[17:50] *** cognominal joined
[17:51] *** xinming left
[18:16] <masak> clearly the best answer is "\nabc\n".comb.Bag{"\n"} ;)

[18:16] <masak> (but I don't think that works yet)

[18:21] <jaffa4> r: print $*ERR: "error";

[18:21] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/M7UiEc7ZOH:1‚ê§¬ª

[18:22] <jaffa4> s: print $*ERR: "error";

[18:22] <jaffa4> std: print $*ERR: "error";

[18:22] <p6eval> std 04216b1: OUTPUT¬´ok 00:00 43m‚ê§¬ª

[18:22] <jaffa4> n: print $*ERR: "error";

[18:22] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Invocant handling is NYI at /tmp/XGRxk_C9kr line 1:‚ê§------> [32mprint $*ERR: "error"[33m‚èè[31m;[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ‚ê§  at /home/p6eval/‚Ä¶

[18:23] *** bruges left
[18:23] *** jaldhar joined
[18:23] *** bruges joined
[18:23] <masak> it's NYI in Rakudo, too. but Rakudo's just acting confused about it.

[18:24] <jaffa4> r: $*ERR.print ("error");

[18:24] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/tTFAiPaMWM:1‚ê§¬ª

[18:24] <jaffa4> n: $*ERR.print ("error");

[18:24] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Two terms in a row (method call requires colon or parens to take arguments) at /tmp/cn45IiCvgK line 1:‚ê§------> [32m$*ERR.print [33m‚èè[31m("error");[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[18:24] <jaffa4> IS there a way to print to the STDERR?

[18:28] <masak> r: $*ERR.print ("error")

[18:28] <p6eval> rakudo 64208d: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/pnQtFYiCxz:1‚ê§¬ª

[18:28] <masak> r: $*ERR.print("error")

[18:28] <p6eval> rakudo 64208d: OUTPUT¬´error¬ª

[18:28] <masak> r: $*ERR.print: "error"

[18:28] <p6eval> rakudo 64208d: OUTPUT¬´error¬ª

[18:28] <masak> you almost had it.

[18:33] *** tokuhiro_ left
[18:37] <jaffa4> n: $*ERR.print("error");

[18:37] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´error¬ª

[18:37] <jaffa4> ok";

[18:39] <jaffa4> IS it possible to redirect stderr and stdout?

[18:42] <flussence> r: https://gist.github.com/1606837

[18:42] <p6eval> rakudo 64208d: OUTPUT¬´def‚ê§abc‚ê§‚ê§¬ª

[18:45] <colomon> In theory, I think $*ERR = IO object should work.  dunno if it works in practice yet.

[18:45] <masak> I've successfully temporized $*OUT, I'm pretty sure.

[18:45] <jnthn> yeah, shoudl work. Tehre's even an IO::Capture module

[18:48] *** xinming joined
[18:51] *** xinming_ left
[18:52] <masak> right, exactly.

[18:54] <sorear> o/

[18:58] <jaffa4> What chmod? Is there such a function somewhere?

[18:59] <jnthn> o/ sorear 

[19:02] <jaffa4> r:   chmod( 700, "basename.plx" );

[19:02] <p6eval> rakudo 64208d: OUTPUT¬´Failed to set the mode of 'basename.plx' to '0o1274': chmod failed: No such file or directory‚ê§  in block  at src/gen/CORE.setting:7521‚ê§  in method chmod at src/gen/CORE.setting:7516‚ê§  in sub chmod at src/gen/CORE.setting:7803‚ê§  in block  at /tmp/W6kF9MHJRP:1‚ê§‚ê§¬ª‚Ä¶

[19:03] <jaffa4> n:   chmod( 700, "basename.plx" );

[19:03] <p6eval> niecza v22-16-g4c016f5: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'chmod' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ‚ê§  at /ho‚Ä¶

[19:03] <masak> sorear! \o/

[19:06] <jaffa4> the speed of Niecza seems to be less than 120 lines/s

[19:08] <sorear> masak: best discovery of today: http://www.jmilne.org/math/

[19:08] *** snearch joined
[19:09] * masak looks

[19:11] *** havenn joined
[19:13] <masak> sorear: nice! thanks.

[19:16] <jaffa4> rakudo does not like tis... quotestart:  if ( $quote == 0 ) {

[19:17] <masak> jaffa4: the label? no, Rakudo doesn't do labels yet. Niecza does.

[19:17] <masak> wow, the thought of someone writing 112 pages about complex multiplication...

[19:18] <jaffa4> ok

[19:19] <colomon> masak: context?

[19:20] *** havenn left
[19:21] * colomon thought he had it for a moment, but the article he was looking at is 154 pages on complex multiplication....

[19:21] <masak> colomon: <sorear> masak: best discovery of today: http://www.jmilne.org/math/

[19:22] <masak> the article I found was at http://www.jmilne.org/math/CourseNotes/cm.html

[19:22] <masak> it is beyond me; I don't know that much group theory.

[19:22] <colomon> gotcha

[19:23] <sorear> seems to be something much broader than just multiplication over C

[19:23] <sorear> skimming this it makes a lot of references to semisimple K-algebras

[19:24] <colomon> over my head as well.

[19:26] *** MayDaniel left
[19:26] * masak .oO( "semisimple"... unfortunately it's the wrong half of it that's simple ) :P

[19:27] <sorear> it's like a small planet...

[19:28] *** PacoAir left
[19:28] <sorear> I came looking for information on elliptic curves

[19:28] <sorear> I will be here a while

[19:28] <masak> ;)

[19:28] *** PacoAir joined
[19:29] *** PacoAir left
[19:29] *** PacoAir joined
[19:30] <masak> I feel like an amateur chess player in terms of category theory. I still have to remind myself that monomorphisms correspond to injective functions, and epimorphisms to surjective functions.

[19:30] <masak> it's like having to remind oneself that the horsie moves two steps in one direction, then turns 90 degrees and moves one more step.

[19:32] <colomon> masak++

[19:41] <cognominal> masak: my math teacher (who was a moron) would chastize you for wrongly assimilating the general case to one particular example.  But he was a Bourbakian bureaucrat who has no clue about the learning process.

[19:43] <masak> the epithet "Bourbakian bureaucrat" has a nice ring to it, even if it's not that flattering ;)

[19:43] <cognominal> for him, apparently,  everything was said in the formal language of math and it was a crime to try to interpret it or to reformulate in more common languag.

[19:43] <sorear> mm, Bourbaki

[19:44] <masak> cognominal: to me mathematics is awesome precisely because I can context-switch between (sometimes necessary) formalism and (sometimes very useful) informality.

[19:44] <cognominal> right

[19:44] <masak> I think many people consider math lethally boring because they are only taught the former.

[19:45] <masak> to me it has always been a very alive topic.

[19:47] <cognominal> we are not straying far away from Perl. It is about languages. Should they be a straight jacket or a way to think?

[19:48] <masak> right.

[19:51] <cognominal> btw, I should go someday back to read  http://www.di.ens.fr/users/longo/files/CategTypesStructures/book.pdf

[19:54] <sorear> cognominal: would you blame any major part of that on the Bourbakis themselves?

[19:54] <cognominal> sorear: nope

[19:54] *** domidumont left
[19:58] <cognominal> but its caricature fits very well in the educational system. They make it a mechanical way to teach, and to rate students. Somehow formalism is the new numerology of so callled educated people, meaning if you frame anything with enough formalism, it has to be true.

[19:59] <cognominal> ‚Ä¶ or meaningful in some vague platonist way.

[19:59] <cognominal> *platonic?

[20:06] <masak> no, I think it has always been that way. probably even before we had empirical science in a big way.

[20:06] <cognominal> sorear: I think the first Bourbakists would be horrified to see how their stuff has been transmogrified into a arbitrary selection process. Most of the formalism has been invented to deal with various form of infinities which are hardly touched in school (except for the convergence of series). 

[20:06] <masak> people who don't know how to clearly convey their message resort to hiding behind majestic formalisms.

[20:07] <sorear> what level of schooling are we talking about here?

[20:09] <cognominal> I forget the equivalency with the american system. I meant before what we call the bacallaur√©at you get around 17-18 years of age.

[20:10] <masak> sounds like 10th to 12th grade here.

[20:14] *** kurahaupo joined
[20:17] <cognominal> Right now, I am reading Bernard Stiegler and his messsage is buried in Derridian crap wordplay. He has an excuse, he was his student but I don't know why so many authors need to wrap their message in pretentious forms that alienates them from their pontential readership.

[20:20] *** mcero left
[20:22] <masak> cognominal: have you seen http://masi.cscs.lsa.umich.edu/~crshalizi/chomsky-on-postmodernism.html ?

[20:23] *** raiph left
[20:25] <sorear> Derrida :|

[20:27] <masak> I think Eliezer Yudkowsky woke me up from some of the excessive respect for high-falutin' language which doesn't make a difference in the observable universe. does the falling tree in the forest make a sound if no-one's there to hear it? well, if I answered "yes" or "no" to that question, is there any way to tell the difference in the physical universe?

[20:28] <masak> that is, models better describe something that matters, or they won't matter either.

[20:29] <cognominal> masak: Chomsky is very much hated by the french intelligentsia because he denounces their lack of integrety : pompous language and playing fast with facts or downright ignoring them. They were very vicious when he got framed by a revisionist. The case was closed : Chomsky himself is a revisionist.  http://en.wikipedia.org/wiki/Faurisson_affair

[20:30] <masak> Chomsky v. the French. I don't know anything about that, but I can imagine. :)

[20:34] *** kurahaupo left
[20:35] <GlitchMr> perl6: print +'–ó'

[20:35] <p6eval> rakudo 64208d: OUTPUT¬´Cannot convert string to number: base-10 number must begin with valid digits or '.' in '‚èè–ó' (indicated by ‚èè)‚ê§  in method Str at src/gen/CORE.setting:9992‚ê§  in method print at src/gen/CORE.setting:7488‚ê§  in sub print at src/gen/CORE.setting:7298‚ê§  in block  at /tmp/‚Ä¶

[20:35] <p6eval> ..niecza v22-16-g4c016f5: OUTPUT¬´Unhandled exception: Cannot parse number: –ó‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1443 (die @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3546 (ANON @ 11) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3548 (NumSyntax.str2num @ 5) ‚ê§  at /h‚Ä¶

[20:36] <GlitchMr> ok, I guess that putting Russian letters instead of digits won't work ;-)

[20:36] <GlitchMr> (ok, that wasn't even an attempt... it's a programming language, not human)

[20:36] <jnthn> .u –ó

[20:36] <phenny> U+0417 CYRILLIC CAPITAL LETTER ZE (–ó)

[20:36] <sorear> I kind of feel like a bad person for stereotyping French philospohers as unintelligible

[20:37] <sorear> ===SORRY!=== Cross-script phishing attack detected

[20:37] <jnthn> :D

[20:37] <GlitchMr> But well, phishing using Russian is actually possible

[20:37] <GlitchMr> Many letters are... similar

[20:38] <jnthn> Yeah, pe–æple w–æn't n–ætice a thing...

[20:38] <GlitchMr> But today, considering that browsers display punycode if website address contains letters from different scripts...

[20:38] <GlitchMr> Probably all you can do is paypaI.com

[20:38] <GlitchMr> or...

[20:39] <sorear> 2012.10.24.13.32.13 < kurahaupo> Œ∫ŒªŒµœÄœÑœà?

[20:39] <sorear> 2012.10.24.13.32.39 < jnthn> .oO( gee, that's some really messed up cyrill...oh, wait... )

[20:40] <GlitchMr> —Ä–∞—É—Ä–∞–Ü.com

[20:40] <GlitchMr> ^ this is actually cyrillic...

[20:41] <GlitchMr> Actually, –Ü is not Russian, but still

[20:41] <GlitchMr> .u –Ü

[20:41] <phenny> U+0406 CYRILLIC CAPITAL LETTER BYELORUSSIAN-UKRAINIAN I (–Ü)

[20:43] *** jaffa4 left
[20:44] <sorear> did not realize Belarus had its own letters

[20:44] <GlitchMr> Not really. Those letters just have disappeared from Russian.

[20:45] <jnthn> iirc, Belarusian can best represent my surname compared to other Cyrillic alphabets.

[20:45] <GlitchMr> I was in Russian before 1918

[20:45] * jnthn read that as "I was in Russia before 1918" :D

[20:45] * sorear mis-parsed that as "I was in Russi...

[20:46] <GlitchMr> I is 9th letter of alphabet.

[20:46] <GlitchMr> (no... it's I am... wait)

[20:47] <sorear> GlitchMr, Russian revolution refugee

[20:47] <GlitchMr> I was referring to letter, not me.

[20:47] <GlitchMr> sorear: https://en.wikipedia.org/wiki/Reforms_of_Russian_orthography

[20:47] <felher> masak++ # macro work and newest blogpost. Very nice :)

[20:48] * sorear kind of doubts that GlitchMr was alive in 1918

[20:48] <masak> felher: thanks! I'm pretty happy about the recent progress.

[20:48] <GlitchMr> lol, I wasn't

[20:49] <GlitchMr> I should put it in quotes or something

[20:49] <GlitchMr> Or perhaps as U+0406

[20:49] <GlitchMr> U+0406 was in Russian before 1918

[20:49] <GlitchMr> (but they didn't have Unicode...)

[20:49] * masak .oO( Belarussian, the beautiful version of Russian... )

[20:50] <masak> Belarusian*

[20:58] *** GlitchMr left
[20:58] <felher> masak: glad to hear that. While i'm quite impressed to see how far the macro-work has come I am also quite eagerly waiting to see COMPILING:: work. Not that I have a particular use case at hand, but it strikes me as one of those things people will do great stuff with :)

[20:59] <felher> But maybe thats just me. I can't help it and I can't explain it -- but I just like macros. :)

[20:59] <masak> me too :)

[21:00] <masak> COMPILING:: will likely have several parts.

[21:00] <masak> you're supposed to be able to both define new things in the mainline scope, and refer to existing things there, for example.

[21:00] <jnthn> .oO( In the first part, we collect together the long list of things the spec and spectests think COMPILING means... )

[21:01] * masak .oO( it means the programmers are fighting with swords from their office chairs )

[21:07] *** kaare_ left
[21:07] <felher> masak: oh, does this mean that one can write a macro that defines a sub in the mainline code? And this sub may be used by the normal code following it? Something like ' macro make-stubs(...) {...} ; make-stubs(<sub1 sub2 sub3 sub4>); ' which will then make sub1, sub2, sub3 and sub4 in the mainline code, with some stub code in them?

[21:08] <felher> Someting like : https://gist.github.com/7064d9fc21e5b1df6a1a

[21:11] <masak> felher: yes, but the macros as currently spec'd are not powerful enough to vary over sub names. see discussion earlier today with TimToady.

[21:13] <felher> masak: okay, great, thanks! :)

[21:22] *** theOnliest joined
[21:24] *** SamuraiJack left
[21:30] *** theOnliest left
[21:32] <felher> 'night, #perl6

[21:37] <[Coke]> raiph: pretty sure that's from tests with "plan *"

[21:38] <[Coke]> ... sees jnthn already addressed it.

[21:38] *** plobsing left
[21:39] *** avar left
[21:40] *** avar joined
[21:41] *** plobsing joined
[21:48] <dalek> perl6-roast-data: b5f5c0d | coke++ | / (3 files):

[21:48] <dalek> perl6-roast-data: today (automated commit)

[21:48] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/b5f5c0d4ca

[21:49] *** plobsing left
[21:50] <masak> 'night, #perl6

[21:51] <sorear> night masak

[21:51] * [Coke] is glad to see his family's home country discussed in backscroll.

[21:52] <[Coke]> sorear: 8 failures in my niecza run today. (down from 11)

[21:56] <sorear> Which one?  Belarus?

[22:03] *** nyuszika7h left
[22:03] *** sftp left
[22:05] *** nyuszika7h joined
[22:11] *** am0c left
[22:18] *** rindolf joined
[22:22] *** kda joined
[22:27] *** fgomez left
[22:28] *** fgomez joined
[22:29] <[Coke]> yes. though "home country is extremely generous, since I only found out it was Belarus and not Russia about 5 years ago.

[22:30] *** shoeswat joined
[22:30] *** shoeswat left
[22:31] *** Rix left
[22:33] <sorear> [Coke]: did you ever live there yourself?

[22:34] <[Coke]> no. pretty sure you have to go back 3 more generations for that.

[22:34] <[Coke]> records are sketchy.

[22:34] *** fgomez left
[22:37] *** Rix joined
[22:38] *** chee left
[22:42] *** PacoAir left
[22:50] *** daniel-s_ joined
[22:51] *** fgomez joined
[22:52] *** leont left
[22:54] *** daniel-s left
[22:55] *** leont joined
[23:07] *** benabik joined
[23:08] *** azawawi joined
[23:09] <azawawi> hi

[23:26] *** benabik_ joined
[23:26] *** benabik left
[23:26] *** benabik_ is now known as benabik

[23:28] *** benabik_ joined
[23:28] *** benabik left
[23:28] *** benabik_ is now known as benabik

[23:28] *** benabik left
[23:30] *** plobsing joined
[23:46] *** sjohnson left
[23:47] *** sjohnson joined
[23:48] *** sjohnson left
[23:48] *** sjohnson joined
[23:55] *** thou left
[23:57] * azawawi starts dancing... Farabi6 run dialog with various Perl 6/5 runtimes implemented... :)

[23:57] <sorear> \o/

[23:59] <azawawi> panda install Farabi6  # to test it... since right now Safe is not enabled

