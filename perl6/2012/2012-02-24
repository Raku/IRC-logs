[00:10] <TimToady> just finished http://herbsutter.com/welcome-to-the-jungle/ which is a good exposition of why many of the less obvious design decisions of Perl 6 matter, and why we still need to keep designing with clean specification of data relationships while not making assumptions about how those relationships must be processed

[00:12] *** fridim_ left
[00:12] <TimToady> I think overall we've done pretty well in future-proofing Perl 6, but we'd like to do better than just survive the future; we'd like to prosper in it

[00:18] <TimToady> case in point: we'd like a recursive definition of @hamming to be able to figure out it is tightly coupled to itself that it needs strict laziness, while other sequence generators with looser dependencies may be worked ahead in batches; this will in the future directly influence the mapping of subtasks to processing units and pipelines

[00:19] <TimToady> one thing glossed over in the article is latency; we may need to work out ways of specifying maximum desired latency so that the compiler maps a particular computation to the GPU rather than the cloud

[00:21] * TimToady waves hands, but doubtless there are PhDs in the details of how that works

[00:22] <TimToady> but there's something in there about knowing when someone downstream is waiting impatiently for your results, and when it's just "whenever convenient"

[00:23] <TimToady> sort of inside-out throttling

[00:23] <TimToady> but in the sense of stepping on the gas pedal, not the brakes

[00:24] * TimToady thinks of the growing plant in Colossal Cave bellowing "WATER!"

[00:36] *** tokuhirom joined
[00:38] *** Chillance left
[00:42] <houghton> could someone help me get an example program running?

[00:43] <houghton> here's the code: https://github.com/dfhoughton/PerlSampler/blob/master/roles.p6

[00:43] <houghton> here's the error: Constraint type check failed for parameter '$amt'

[00:43] <houghton> basically, I say a parameter should be Numeric

[00:43] <houghton> I give it an integer

[00:43] <houghton> the type constraint fails

[00:44] <houghton> this same example ran when I first wrote it

[00:45] <houghton> so I'm thinking there's something I could swap in there for "Numeric" to make this work

[00:45] <houghton> I can do without the constraint altogether, but I wrote it to show some Java programmers that type constraint were possible in Perl 6, among other things

[00:45] <katernya> I'm a homocore

[00:46] <katernya> lol @ juvenile jokes

[00:47] <katernya> houghton is there a line numer?

[00:47] <houghton> eh, I just pulled Numeric out everywhere and I'm still getting a type constraint failure

[00:48] <houghton> in block <anon> at whatsnew/roles.p6:66

[00:48] <benabik> houghton: The `where {$amt <= $!account }` is considered a type constraint, I think.

[00:48] <houghton> also :1

[00:48] <houghton> ah

[00:48] <houghton> so that's it

[00:48] <benabik> It's a subtype.

[00:49] <houghton> so that was an expected failure, but I thought the CATCH block would silence it

[00:49] <benabik> It might be a CONTROL exception instead...  Not sure.

[00:49] <houghton> going to try taking out the where bit to see what happens

[00:50] <houghton> sure enough, that was it

[00:50] <houghton> so shouldn't I be able to catch the exception and handle it without it's giving me line numbers and such?

[00:52] <benabik> nom: sub foo( $x where { $_ > 0 } ) { say $x }; foo(1);

[00:52] <p6eval> nom 580848: OUTPUT«1␤»

[00:52] <benabik> nom: sub foo( $x where { $_ > 0 } ) { say $x }; foo(1); CONTROL { say 'hi' }

[00:52] <TimToady> you have put a default {} around your say, or it doens't know it's caught it

[00:52] <p6eval> nom 580848: OUTPUT«1␤»

[00:52] <benabik> nom: sub foo( $x where { $_ > 0 } ) { say $x }; foo(0); CONTROL { say 'hi' }

[00:52] <p6eval> nom 580848: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub foo at /tmp/3zzB4g7I9w:1␤  in block <anon> at /tmp/3zzB4g7I9w:1␤␤»

[00:53] <TimToady> houghton: it's the implicit succeed of a when/default that bypasses the rethrow logic

[00:54] <TimToady> a CATCH catches it, but doesn't "handle" it without a case statement

[00:54] <houghton> alright

[00:54] <houghton> thanks a lot

[00:54] <TimToady> note that the default CATCH for a try includes a default {}

[00:55] <houghton> where should I look for examples?

[00:55] <houghton> I can just grep for CATCH

[00:56] *** samlh joined
[00:57] *** thou left
[01:00] <houghton> well, there isn't a lot of CATCHing going on in there

[01:01] <TimToady> there's only one CATCH in your program, and that's the one that needs "default { say...}"

[01:02] <houghton> well, CATCH { default { say 'oops! ...' } } did the trick

[01:02] <houghton> oh, I was grepping the perl 6 source

[01:02] <houghton> src/ and t/

[01:03] <TimToady> in general we try to avoid throwing exceptions for normal processing, since they should be for, er, exceptions

[01:03] <houghton> right

[01:04] <houghton> but Java programmers are used to a lot more exception handling; that was the intended audience for this snippet

[01:04] <TimToady> for example, generally we'd put a multi to handle the unmatched constraint case

[01:04] <TimToady> and we never use exceptions to terminate a loop; it just runs out of lazy list

[01:05] <houghton> will have to learn some new tricks

[01:06] <TimToady> basically, as I was saying above, there are various subtle design issues having to do with parallel processing, and exceptions tend to be de-emphasized for just that reason

[01:06] <TimToady> the article I referenced indicates that some GPU architectures can't even do exceptions

[01:08] <houghton> I started to read it but didn't get that far

[01:08] <houghton> that is interesting

[01:08] <TimToady> yes, it is rather tl;dry-ish

[01:08] <TimToady> well, gotta run

[01:08] <TimToady> later &

[01:09] <houghton> thanks for the help

[01:11] *** scott__ joined
[01:11] *** houghton left
[01:13] * [Coke] wonders what he contributed to this release other than "I'll do a release" ;)

[01:20] <sorear> good * #perl6

[01:26] <katernya> ruby gem hehe

[01:28] *** ribayr left
[01:30] <colomon> \o

[01:32] *** ribayr joined
[01:32] *** leprevost left
[01:38] *** am0c joined
[01:38] *** sisar joined
[01:40] <sorear> sisar: hi!

[01:40] <sisar> o/

[01:43] <sorear> that name reminds me of http://en.wikipedia.org/wiki/SISAL

[01:43] <sisar> hehe

[01:45] <sisar> print and say, how do they differ? #well apart from the obvious \n

[01:47] <sorear> niecza: say 1..10

[01:47] <p6eval> niecza v14-64-g8248afc: OUTPUT«1..10␤»

[01:47] <sorear> niecza: print 1..10

[01:47] <p6eval> niecza v14-64-g8248afc: OUTPUT«12345678910»

[01:47] *** tokuhirom left
[01:48] <sorear> "print" is designed to work with few suprises; it just puts its arguments in list context and prints all the values as strings

[01:48] <sorear> "say" is designed with much more DWIM, and objects can override say by defining a ".gist" method

[01:48] <sorear> niecza: print (1..10).gist

[01:49] <p6eval> niecza v14-64-g8248afc: OUTPUT«1..10»

[01:53] <sisar> trying out yesterday's quirk...

[01:54] <sisar> niecza: my %h; %h<wow>.print;

[01:54] <p6eval> niecza v14-64-g8248afc: OUTPUT«Unhandled exception: Unable to resolve method print in class Any␤  at /tmp/wKSF3BqxbN line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3826 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3827 (module-CORE @ 65) ␤  at /home/…

[01:54] <sisar> niecza: my %h; print %h<wow>;

[01:54] <p6eval> niecza v14-64-g8248afc: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1222 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 230 (Mu.Str @ 10) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[01:55] <sorear> look up Cool is S02

[01:55] <sorear> this behavior is by design

[01:55] * sisar looks

[02:07] *** am0c left
[02:22] <sisar> sorear: i was hoping my name would remind you of Ceasar ;-)

[02:23] <sisar> *Caesar

[02:26] *** thou joined
[02:33] *** wolfman2000 joined
[02:34] *** sisar left
[02:38] *** whiteknight left
[02:44] <dalek> roast: 221ae65 | coke++ | S (5 files):

[02:44] <dalek> roast: pugs autounfudge

[02:44] <dalek> roast: review: https://github.com/perl6/roast/commit/221ae65b94

[02:49] <katernya> i dont know if my feeble mind can handle perl6

[03:00] * sorear hugs katernya

[03:14] *** am0c joined
[03:17] *** Alias joined
[03:21] *** aindilis joined
[03:24] *** orafu left
[03:24] *** orafu joined
[03:27] *** ribayr left
[03:31] *** ribayr joined
[03:32] *** lestrrat left
[03:33] *** lestrrat joined
[03:35] *** ribayr left
[03:57] <lichtkind> katernya: perl 6 is beginner and expert friendly

[03:57] <lichtkind> you can do a lot with little syntax rules

[03:57] <lichtkind> but have long journey to full mastership

[03:57] <lichtkind> like in all good martial arts

[03:57] <lichtkind> :)

[03:58] *** lichtkind left
[04:14] <katernya> that was .. helpful

[04:26] <katernya> can I write my perl 5 app to be compatible with perl6?

[04:27] <geekosaur> perl 6 is syntactically ... distinct from perl 5

[04:27] <katernya> in other words, no

[04:27] <katernya> and why would you want to

[04:28] <katernya> amirite

[04:28] <geekosaur> embedding per 5 in perl 6 is supposed to be possible, and is in various states of functioning in rakudo and niecza

[04:29] <katernya> that sounds less than desirable

[04:29] <katernya> i mean, a nice feature, but this is new code

[04:29] <geekosaur> it's just that perl 6 is a continuation of perl ideas, less than of perl syntax, mainly because perl 5's syntax has some significant warts

[04:31] <katernya> nod

[04:32] <katernya> I am just wondering if i can interface to postgresql

[04:32] <geekosaur> hrm

[04:33] * geekosaur wonders if any rakudo experts are around...

[04:34] <katernya> so far all i've found is a reference to a "parrot interface to libpq"

[04:34] <katernya> http://trac.parrot.org/parrot/browser/trunk/runtime/parrot/library/Pg.pir

[04:34] <benabik> The best best for Rakudo at the moment is probably NativeCall to the original pg library.

[04:35] <benabik> Interacting with raw Parrot objects is... tricky at the moment.

[04:36] <katernya> i don't fully understand how it all fits together, or why there would be a parrot interface to libpq

[04:36] <katernya> how is XS done in perl 6?

[04:38] <geekosaur> there is no single standard; perl 6 allows, and has, multiple implementations

[04:38] <sorear> The big problem with XS is that it exposes a lot of Perl 5's implementation technology

[04:38] <katernya> yeah, it had problems, sure

[04:38] <sorear> Perl 6 is following a path of implementation diversity, which contraindicates that approach

[04:38] <geekosaur> rakudo uses parrot's native-call interfaces.  niecza can use anything the CLR can use, I believe, which should mean "anything" but may require some extra setup

[04:39] <sorear> For binding to C libraries, we're generally going for more of a FFI-like approach

[04:39] <katernya> so now there are even more ways to do it?

[04:39] <katernya> what is FFI?

[04:40] *** benabik left
[04:40] <geekosaur> "foreign function interface", specifically the standard LibFFI

[04:40] <geekosaur> http://sourceware.org/libffi/

[04:41] <katernya> I suppose I don't need to use postgresql at all

[04:41] <geekosaur> more and more stuff is going that way, which means more and more stuff is becoming "plug and play"

[04:43] <katernya> i might choose the path of least resistance

[04:44] <sorear> geekosaur: I don't think "FFI" means "LibFFI clone"

[04:44] <sorear> geekosaur: I'm thinking especially of the Haskell FFI.  Doesn't that predate LibFFI?

[04:45] <geekosaur> GHC uses libffi

[04:46] <geekosaur> the FFI *spec* predates libffi, but isn't a binary level specification, just a language-level extension

[04:50] <geekosaur> and one that kinda goes out of its way not to say anything useful about how you actually use any of the information, which has led to much annoyance as ghc has altered its implementation :)

[04:50] <geekosaur> (multiple times)

[04:52] <sorear> geekosaur: I'm not talking about a specification

[04:52] <sorear> geekosaur: I'm talking about a general Way of Doing Things

[04:53] <sorear> Visual Basic has had a "FFI" by another name for ages, and I can't imagine it was the first

[04:53] <geekosaur> haskell's ffi is too simple to qualify even as that, though

[04:53] <geekosaur> as specified, at least

[04:53] <sorear> you write a declaration that gives a function name, a dll name, and argument and return types

[04:54] <sorear> with all the needed ByRef annotations

[05:05] <katernya> do i have to build my own perl

[05:05] <katernya> sorry, ignore me

[05:10] *** Jerkwad left
[05:11] *** birdwindupbird joined
[05:22] *** benabik joined
[05:24] *** kaleem joined
[05:33] *** preflex left
[05:35] *** preflex joined
[05:54] *** NamelessTee joined
[05:55] *** skids left
[06:05] *** thou left
[06:21] <moritz> masak++ # rakudo release

[06:23] <dalek> nqp: 9843c1d | moritz++ | tools/build/PARROT_REVISION:

[06:23] <dalek> nqp: bump parrot revision to something after the cont_reuse merge

[06:23] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9843c1da1f

[06:24] <dalek> rakudo/nom: 546343d | moritz++ | src/binder/multidispatch.c:

[06:24] <dalek> rakudo/nom: Merge remote branch 'origin/cont_reuse' into nom

[06:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/546343d9cc

[06:24] <dalek> rakudo/nom: ad349d5 | moritz++ | tools/build/NQP_REVISION:

[06:24] <dalek> rakudo/nom: bump NQP revision

[06:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ad349d5859

[06:53] *** birdwind1pbird joined
[06:54] *** NamelessTee left
[07:05] *** wtw joined
[07:16] *** plobsing joined
[07:21] <moritz> std: sub f($1) { }

[07:21] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot declare a numeric parameter at /tmp/2CF2N0hXjC line 1:␤------> [32msub f($1[33m⏏[31m) { }[0m␤Parse failed␤FAILED 00:01 109m␤»

[07:24] *** birdwind1pbird left
[07:24] *** Vlavv` left
[07:27] *** noam left
[07:27] *** noam joined
[07:33] <moritz> std: sub f($<x>) { }

[07:33] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse signature at /tmp/S8m9WdGAwn line 1:␤------> [32msub f[33m⏏[31m($<x>) { }[0m␤Couldn't find final ')'; gave up at /tmp/S8m9WdGAwn line 1:␤------> [32msub f($[33m⏏[31m<x>) { }[0m␤    expecting any of:␤      constraint␤     …

[07:33] <moritz> std: my $<x>

[07:33] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot declare a match variable at /tmp/Zd0u1NLxCr line 1:␤------> [32mmy $<x>[33m⏏[31m<EOL>[0m␤Parse failed␤FAILED 00:01 108m␤»

[07:33] <moritz> perl6: sub f($<x>) { }

[07:33] <p6eval> niecza v14-64-g8248afc: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unable to parse signature at /tmp/7O7Ac64kCM line 1:␤------> [32msub f([33m⏏[31m$<x>) { }[0m␤Couldn't find final ')'; gave up at /tmp/7O7Ac64kCM line 1:␤------> [32msub f($[33m⏏[31m<x>) { }[0m␤␤Parse failed␤␤»…

[07:33] <p6eval> ..rakudo ad349d: OUTPUT«===SORRY!===␤Missing block␤at /tmp/E2QW2Vrr4o:1␤»

[07:33] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "$<x"␤    expecting formal parameter or ")"␤    at /tmp/MHVy4Z4Au6 line 1, column 7␤»

[07:48] *** mj41 joined
[08:00] *** proller left
[08:05] *** araujo left
[08:06] <dalek> rakudo/nom: 1ccc79f | moritz++ | src/ (2 files):

[08:06] <dalek> rakudo/nom: typed exception for numeric parameter

[08:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1ccc79fa27

[08:09] *** araujo joined
[08:10] *** tarch joined
[08:11] *** Vlavv_ joined
[08:11] <dalek> roast: b291479 | moritz++ | S32-exceptions/misc.t:

[08:11] <dalek> roast: test parameter variant of X::Syntax::Variable::Numeric

[08:11] <dalek> roast: review: https://github.com/perl6/roast/commit/b291479208

[08:15] *** aindilis` joined
[08:15] *** aindilis left
[08:23] <moritz> std: my @a()

[08:23] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤The () shape syntax in array declarations is reserved at /tmp/n7NTUFJ3zn line 1:␤------> [32mmy @a()[33m⏏[31m<EOL>[0m␤Check failed␤FAILED 00:01 110m␤»

[08:24] *** Vlavv_ left
[08:31] *** tarch_ joined
[08:31] *** tarch left
[08:33] <dalek> rakudo/nom: 8a29c50 | moritz++ | src/ (2 files):

[08:33] <dalek> rakudo/nom: X::Syntax::Reserved

[08:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8a29c50061

[08:35] <dalek> roast: a78af8c | moritz++ | S32-exceptions/misc.t:

[08:35] <dalek> roast: X::Syntax::Reserved

[08:35] <dalek> roast: review: https://github.com/perl6/roast/commit/a78af8cec1

[08:39] *** wolfman2000 left
[08:50] <sorear> o/ moritz

[08:51] <moritz> \o sorear 

[08:54] *** alim_ left
[09:10] *** daxim joined
[09:22] *** silug_ left
[09:40] <fsergot> hi #perl6 \o

[09:40] *** Trashlord left
[09:41] <moritz> o/ fsergot 

[09:56] <dalek> rakudo/nom: f9c788d | moritz++ | src/ (2 files):

[09:56] <dalek> rakudo/nom: typed NYI exceptions from Grammar.pm

[09:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9c788d898

[09:56] <dalek> rakudo/nom: 8ee2aa3 | moritz++ | src/Perl6/Actions.pm:

[09:56] <dalek> rakudo/nom: more consequent NYI errors from Actions.pm

[09:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8ee2aa3a68

[09:58] <moritz> fwiw we now have more typed exceptions in Actions.pm and Grammars.pm than untyped exceptions

[09:59] *** MayDaniel joined
[09:59] <colomon> \o/

[09:59] <moritz> many (but not all) of the remaining untyped exceptions are for rakudo limitations, or errors that I'm not sure about if they are legit, or how to trigger

[10:02] *** alim joined
[10:07] *** _jfried joined
[10:07] *** Tedd1 left
[10:08] *** slavik2 joined
[10:08] *** jfried left
[10:08] *** slavik1 left
[10:17] *** Steven__ joined
[10:18] *** Steven__ left
[10:18] *** Tedd1 joined
[10:20] *** scott__ left
[10:24] <tadzik> o/

[10:24] *** _jfried is now known as jfried

[10:36] <fsergot> tadzik: o/

[10:52] <moritz> nom: rx:g/a/

[10:52] <p6eval> nom 8ee2aa: OUTPUT«===SORRY!===␤Adverb 'g' not allowed on m at line 1, near ""␤»

[11:06] *** JimmyZ joined
[11:08] <dalek> rakudo/nom: 867f9d5 | moritz++ | src/ (2 files):

[11:08] <dalek> rakudo/nom: X::Syntax::Regex::Adverb

[11:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/867f9d5cb9

[11:08] * JimmyZ wonders when https://github.com/perl6/nqp/pull/29 will be merged

[11:08] <moritz> JimmyZ: I can do it after lunch. I just didn't want to do it right before the rakudo release, because I don't know how risky it is

[11:09] <JimmyZ> moritz: ok, thanks.

[11:09] <dalek> roast: dc3de2d | moritz++ | S32-exceptions/misc.t:

[11:09] <dalek> roast: X::Syntax::Regex::Adverb

[11:09] <dalek> roast: review: https://github.com/perl6/roast/commit/dc3de2d65a

[11:18] <masak> g'day, #perl6

[11:18] <fsergot> o/ masak

[11:19] <flussence> nom: say -t $*IN

[11:19] <p6eval> nom 8ee2aa: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&t' called (line 1)␤»

[11:19] <fsergot> moritz: Could You check this? : https://gist.github.com/1900171

[11:19] <flussence> is that NYI or changed from p5?

[11:20] <moritz> flussence: both :-)

[11:20] <flussence> (please ignore the fact that it's *wrong* and I should've used $*OUT instead :)

[11:20] <fsergot> moritz: it makes unlink removes only files, as You probably see.

[11:20] *** pernatiy left
[11:20] <fsergot> moritz: Is it correct?

[11:20] <moritz> fsergot: looks much better than before

[11:20] <JimmyZ> good *, masak!

[11:21] <moritz> fsergot: though I think :d & :e is redundant -- :d implies :e

[11:21] <moritz> fsergot: and you can make it a bit more efficient by writing it as  $path.IO.d

[11:23] <masak> it's funny how once we were supposed to be able to write `if -f -s $filename` in Perl 6, or something like that -- stacking filetests on top of each other.

[11:23] <masak> to make things shorter and more convenient.

[11:23] <moritz> (in the setting we generally care more about speed than about idiomatic Perl 6 code)

[11:23] <masak> and how since then we've migrated to longer and longer forms of the file tests for, essentially, language purity reasons.

[11:24] <masak> so that now it's `if $filename.IO ~~ :f & :s`

[11:24] <moritz> except that it doesn't make any sense for :s, because size isn't a boolean return value

[11:24] <masak> ah, true.

[11:25] <masak> bad example.

[11:25] <masak> I was trying to think of two filetests that made sense together.

[11:25] <fsergot> moritz: but I want to check if $path exists as a file and it's not a dir.

[11:25] <masak> I'm still eagerly waiting for someone to (ab)use the above syntax for something *other* that IO objects, by the way. it's perfectly extensible, which I guess is one of the nice things about it.

[11:26] <moritz> fsergot: currently the check if "if it is a directory and exists"

[11:26] <fsergot> moritz: Oh, You are right.

[11:26] <moritz> masak: well, it's only extensible for methods without arguments that return Bool

[11:27] <masak> sure.

[11:27] <moritz> masak: I have abused that syntax once, but I don't remember for which purpose :/

[11:27] <masak> is there a way to provide all enums of an enumeration with a method?

[11:27] <masak> by mixing in a role at the right level, say.

[11:28] <moritz> nom: enum A <b c>; say b.WHAT

[11:28] <p6eval> nom 8ee2aa: OUTPUT«A()␤»

[11:28] <moritz> nom: enum A < b c >; A does role { method x() { say "OH HAI" } }; b.x

[11:28] <p6eval> nom 8ee2aa: OUTPUT«Cannot use 'does' operator with a type object␤  in sub infix:<does> at src/gen/CORE.setting:9266␤  in block <anon> at /tmp/IBftWxVDlU:1␤␤»

[11:28] <moritz> no.

[11:30] <fsergot> moritz: Just like that? F5 :)

[11:31] <moritz> fsergot: yes

[11:31] <fsergot> moritz: so, it's fine now?

[11:32] <masak> std: role R {}; enum A does R <a b c>

[11:32] <p6eval> std 52f3895: OUTPUT«ok 00:01 108m␤»

[11:32] <masak> \o/

[11:32] <masak> nom: role R { method foo { say "OH HAI" } }; enum A does R <a b c>

[11:32] <p6eval> nom 867f9d:  ( no output )

[11:32] <masak> nom: role R { method foo { say "OH HAI" } }; enum A does R <a b c>; A.foo

[11:32] <p6eval> nom 867f9d: OUTPUT«OH HAI␤»

[11:32] <masak> \o/

[11:32] <fsergot> How to gove it to change in IO.pm? 

[11:32] <fsergot> give*

[11:32] <masak> nom: role R { method foo { say "OH HAI" } }; enum A does R <a b c>; b.foo

[11:32] <p6eval> nom 867f9d: OUTPUT«OH HAI␤»

[11:33] * masak hugs rakudo

[11:33] <moritz> masak: ok, I was wrong :-)

[11:33] <moritz> fsergot: now you create a pull request. See http://help.github.com/send-pull-requests/

[11:33] <masak> that's OK -- it worked. which is, like, really cool.

[11:33] <masak> it makes enums *much* more useful.

[11:34] <moritz> std: enum A does role { } <a b c>

[11:34] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'A' (see line 1) at /tmp/m2K7zlukAm line 1:␤------> [32menum A[33m⏏[31m does role { } <a b c>[0m␤Bogus term at /tmp/m2K7zlukAm line 1 (EOF):␤------> [32menum A does role { } <a b c>[33m⏏[31m<EOL>[…

[11:34] <fsergot> moritz++ thanks

[11:34] <masak> moritz: try parens.

[11:35] <moritz> std: enum A does (role { }) <a b c>

[11:35] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegal redeclaration of symbol 'A' (see line 1) at /tmp/ZegCN3xwnM line 1:␤------> [32menum A[33m⏏[31m does (role { }) <a b c>[0m␤Bogus term at /tmp/ZegCN3xwnM line 1 (EOF):␤------> [32menum A does (role { }) <a b c>[33m⏏[31m<EO…

[11:35] <moritz> it probably backtracks, and stumbles over A a second time

[11:35] <moritz> LTA

[11:40] <fsergot> moritz, masak: Could You check this? : https://gist.github.com/1892277

[11:41] * masak submits LTA rakudobug

[11:41] <masak> oh wait, that was STD... well, then.

[11:42] *** sisar joined
[11:44] <sisar> rakudo's 'Confused' error is really unhelpful :(

[11:44] *** grondilu joined
[11:44] <sisar> rakudo: 3x3;

[11:44] <p6eval> rakudo 867f9d: OUTPUT«===SORRY!===␤Confused␤at /tmp/xonKltsQ7e:1␤»

[11:44] <sisar> niecza: 3x3;

[11:44] <p6eval> niecza v14-64-g8248afc: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Whitespace is required between alphanumeric tokens at /tmp/wU7n_0S60L line 1:␤------> [32m3[33m⏏[31mx3;[0m␤␤Whitespace is required between alphanumeric tokens at /tmp/wU7n_0S60L line 1:␤------> [32m3x[33m⏏[31m3;[0m␤␤…

[11:45] <sisar> niecza++

[11:45] <masak> sisar: Niecza's parser started out being STD from the start. Rakudo's parser has had to converge towards STD as it grows in power.

[11:46] <sisar> rakudo: [**] 2,3,4,5

[11:46] <p6eval> rakudo 867f9d:  ( no output )

[11:47] <sisar> rakudo: say [**] 2,3,4,5;

[11:47] <p6eval> rakudo 867f9d: OUTPUT«Inf␤»

[11:47] <sisar> niecza: say [**] 2,3,4,5;

[11:47] <p6eval> niecza v14-64-g8248afc: OUTPUT«(timeout)»

[11:47] <sisar> hehe ;)

[11:48] <sisar> what is rakudo's limit for declaring Inf ?

[11:49] <grondilu> nom: say 10**100

[11:49] <p6eval> nom 867f9d: OUTPUT«10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000␤»

[11:49] *** NamelessTee joined
[11:49] <grondilu> nom: say (10**100)**100

[11:49] <p6eval> nom 867f9d: OUTPUT«1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000…

[11:49] <sisar> wow !

[11:50] <grondilu> gotta be quite high :)

[11:50] <masak> 10_000 zeros.

[11:50] <grondilu> probably when physical memory is too low

[11:50] <masak> (b ** x) ** y == b ** (x * y)

[11:51] <grondilu> indeed

[11:51] <masak> nom: say ((10 ** 100) ** 100).chars - 1

[11:51] <p6eval> nom 867f9d: OUTPUT«10000␤»

[11:51] <grondilu> nom: say 10**10_000

[11:51] <p6eval> nom 867f9d: OUTPUT«1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000…

[11:51] <grondilu> nom: say 10**10_001

[11:51] <p6eval> nom 867f9d: OUTPUT«1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000…

[11:52] <grondilu> nom: say 10**10_000_000

[11:52] <grondilu> :)

[11:52] <masak> grondilu: you can also privmsg with p6eval, conducting experiments outside of the limelight of the channel.

[11:52] <p6eval> nom 867f9d: OUTPUT«(timeout)»

[11:53] <grondilu> p6eval: say 10**100_000

[11:53] <flussence> nom: say (10**1_000_000).chars # probably more sensible

[11:53] <p6eval> nom 867f9d: OUTPUT«(timeout)»

[11:53] <sisar> ^it did not say Inf there (?)

[11:53] <grondilu> lol I totally forgot how to privmsg on IRC :)

[11:53] <flussence> guess not

[11:54] <masak> grondilu: /msg p6eval nom: say "OH HAI"

[11:54] <grondilu> masak: works.  Thks

[11:54] *** am0c left
[11:55] <masak> &

[12:06] *** mj41 left
[12:17] *** bluescreen10 joined
[12:17] *** pernatiy joined
[12:20] *** mj41 joined
[12:21] * flussence wonders how hard it'd be to write macros that translate entire chunks of perl6 code into equivalent SQL statements...

[12:24] <grondilu> flussence: what kind of application would that be for?

[12:25] *** ab5tract joined
[12:25] *** odoacre left
[12:26] <flussence> I dunno, but accessing a DB the same way you'd access any other data structure sounds cool :)

[12:28] <colomon> flussence: isn't that possible already using Proxy?

[12:28] <colomon> and / or appropriate class design?

[12:28] <flussence> it's possible somehow, I just don't know how yet

[12:29] <au> https://en.wikipedia.org/wiki/Language_Integrated_Query has some starting points :)

[12:30] <au> (iirc, mst was planning to port it to Perl5 under the Data::Query / Data::CapabilityBased namespace.)

[12:31] <colomon> LINQ!

[12:33] <colomon> I didn't realize it had been generalized into other languages.

[12:33] <grondilu> SQL sucks anyway.  I very much like NoSQL (MongoDB and stuff like that)

[12:34] <flussence> SQL's a great tool, just a terrible method of expression.

[12:34] <colomon> var results =  from c in SomeCollection

[12:34] <colomon>                where c.SomeProperty < 10

[12:34] <colomon>                select new {c.SomeProperty, c.OtherProperty};

[12:35] <arnsholt> I'm with flussence. Relational algebra is an extremely powerful tool; it's just a shame the syntax built over it is so bad

[12:35] <colomon> seems like my @results := SomeCollection.grep({ .SomeProperty < 10 }).map( ... ) is nicer...

[12:36] <grondilu> yes, using grep, map and stuff like that should be way enough.  No SQL needed 

[12:36] <flussence> sql { source('SomeCollection').grep(*.SomeProperty < 10).<SomeProperty OtherProperty> }; # :)

[12:37] <flussence> (I think X/Z/hypers would fit in nicely too...)

[12:37] *** shinobicl_ joined
[12:38] *** szbalint_ is now known as szbalint

[12:39] <au> flussence: yeah. one possible variant is that sql{} may not be neccessary if table('SomeCollection') provides its own grep/map/sort/groupBy methods that's compatible with Positional API and just generates/calls SQL underneath.

[12:41] <flussence> good points, I think what I'm looking for is a DBIx::Class-alike but with all of perl6 at its disposal :)

[12:41] <flussence> (we don't need macros for that)

[12:41] <au> *nod*

[12:44] <grondilu> Well, maybe someone could write a Perl6 SQL Grammar, for a start :)

[12:44] <moritz> fsergot: re https://gist.github.com/1892277 it's wrong to *first* check stuff

[12:45] <moritz> fsergot: simply try to do the operation, and then fail if it failed

[12:45] *** jferrero left
[12:45] <moritz> fsergot: otherwise you run into race conditions easily

[12:46] <moritz> (only exception: it's OK to check if it's  directory, because of parrot's unusual API)

[12:48] <fsergot>  moritz: and there is a problem with this. If it checks whether $path is a directory it fails when $path does not exist as well.

[12:48] *** ab5tract left
[12:49] <fsergot> moritz: it's because why I added there '.e' condition before.

[12:49] <moritz> fsergot: that's a problem with .d then, and needs to be fixed on that level

[12:49] <moritz> $ /perl6 -e 'say "NOTTHERE".IO.d'

[12:49] <moritz> False

[12:49] <moritz> doesn't fail here

[12:50] <fsergot> moritz, You are right, could I try to repair this?

[12:50] <moritz> ah wait, I see what you mean

[12:50] <masak> arnsholt: I think SQL is in some kind of syntactic sweet spot, even if it isn't a global optimum.

[12:50] <moritz> but the check for  dir $path  is certainly wrong

[12:50] <moritz> just don't do it. The error from the parrot operation will tell the same thing

[12:51] <fsergot> moritz: Ok. :)

[12:52] *** MayDaniel left
[12:53] <masak> also, don't think "macros" when you think "cool sublanguages". think grammars braided into the current slang.

[12:53] <moritz> but that's all just stupid workarounds. I've had enough of this

[12:54] <arnsholt> masak: Yeah, it's true that it's not completely hopeless

[12:54] <arnsholt> When writing queries, I still can't stop writing the FROM clause first though (and quite often the WHERE second)

[12:56] <fsergot> moritz: "aDir".IO.d returns False when "aDir" isn't a directory and when "aDir" doesn't exists.

[12:57] <moritz> fsergot: right; my mistake

[12:58] <fsergot> moritz: so, should I "repair" .d? 

[12:58] <moritz> fsergot: no, .d is correct. I was wrong.

[12:59] <sisar> moritz: what is rakudo's limit before it declares Inf ?

[12:59] <moritz> sisar: in which context?

[13:00] <sisar> nom: say [**] 2,3,4,5; #moritz

[13:00] <p6eval> nom 867f9d: OUTPUT«Inf␤»

[13:01] <moritz> perl6: say [**] 2,3,4,5;

[13:02] <p6eval> pugs b927740, niecza v14-64-g8248afc: OUTPUT«(timeout)»

[13:02] <p6eval> ..rakudo 867f9d: OUTPUT«Inf␤»

[13:02] <moritz> sisar: I think when the exponent of a ** operation doesn't fit into a 32bit integer anymore

[13:04] <moritz> fsergot: this is all just crap workarounds for parrot not exposing unlink and rmdir separately. I'm going to change so, so then you'll be able to use pir::new__PS('OS').unlink and .rmdir

[13:04] <moritz> fsergot: and then no more fiddling with .d will be necessary

[13:04] <sisar> moritz: hmm, makes sense. niecza hangs on this expr for me. I gave niecza 15mins, thinking it would give me an accurate answe, but alas, no. I had to kill it. rakudo++

[13:05] <moritz> sisar: I guess that for such calculations it makes more sense to use something like floats, which store both a mantissa and an exponent

[13:06] <moritz> perl6: say [**] <2 3 4 5>>>.Num

[13:06] <fsergot> moritz: Great. :)

[13:06] <p6eval> pugs b927740: OUTPUT«*** No such method in class Array: "&>>Num"␤    at /tmp/x1TxK7zeay line 1, column 10 - line 2, column 1␤»

[13:06] <p6eval> ..rakudo 867f9d, niecza v14-64-g8248afc: OUTPUT«Inf␤»

[13:06] <moritz> you'd just need a separate data type with a bigger exponent :-)

[13:06] <sisar> moritz: '>>.Num" ?

[13:07] <moritz> sisar: .Num converts one thing into a Num (aka floating point number)

[13:07] <moritz> sisar: and >>.method calls .method for each item of an array (or hash)

[13:07] <dalek> nqp: 6d1c5ff | moritz++ | / (30 files):

[13:07] <dalek> nqp: Merge remote branch 'jimmyz/master'

[13:07] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6d1c5ff486

[13:07] <moritz> JimmyZ++

[13:08] <fsergot> moritz: where and how will You change what You said? :)

[13:09] *** am0c joined
[13:09] <moritz> fsergot: in parrot's src/dynpmc/os.pmc, and Very Soon

[13:09] <sisar> moritz: in contrast, perl5 uses float by default, right?

[13:09] <fsergot> moritz: asking just for pure curiosity. :)

[13:09] <fsergot> moritz++

[13:10] <moritz> sisar: well, perl 5 uses a polymorphic 'scalar' data type that can either be integer, float, string, reference or undef

[13:10] <sisar> oh !

[13:10] <moritz> sisar: and it does int arithmethics with int, and all fractional arithmethics with float

[13:11] <moritz> sisar: and on 32bit systems it auto-upgrades integers to floats, because 'double' has a longer mantissa than 32bit

[13:11] *** grondilu left
[13:12] <cognominal> nom:  say (('a' ~~ /a/).WHAT)

[13:12] <p6eval> nom 867f9d: OUTPUT«Match()␤»

[13:12] * sisar starts reading up on IEEE 754-2008

[13:12] <cognominal> nom:  die  (('a' ~~ /a/).WHAT)

[13:12] <p6eval> nom 867f9d: OUTPUT«use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Match in string context␤use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Match in string context␤␤  in block <anon> at /tmp/e…

[13:13] <colomon> nom: say (2 ** 3).WHAT

[13:13] <p6eval> nom 867f9d: OUTPUT«Int()␤»

[13:13] <colomon> nom: say (2 ** 3 ** 4).WHAT

[13:13] <p6eval> nom 867f9d: OUTPUT«Int()␤»

[13:13] <colomon> nom: say (2 ** 3 ** 4 ** 5).WHAT

[13:13] <p6eval> nom 867f9d: OUTPUT«Num()␤»

[13:13] <cognominal> nom: die 1.WHAT

[13:13] <p6eval> nom 867f9d: OUTPUT«use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Int in string context␤use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Int in string context␤␤  in block <anon> at /tmp/GeEsZ…

[13:13] <cognominal> WHAT the f...?

[13:14] <colomon> nom: say 3 ** 4 ** 5

[13:14] <p6eval> nom 867f9d: OUTPUT«3733918487410200435329597541848665882254097767837340077506369317220790406172652512299936889388039772204687650654314751581087270545921608585813513369828091873141917485942625809388070199519564042855718180410466812887974029255176680123406172983965747316191523867230462351…

[13:14] <moritz> cognominal: 1.WHAT is a type object (Int)

[13:14] <colomon> nom: say (3 ** 4 ** 5) / 8

[13:14] <p6eval> nom 867f9d: OUTPUT«Inf␤»

[13:14] *** kaleem left
[13:14] <moritz> cognominal: it stringifies to '' + warning, but say() uses .gist

[13:14] <colomon> nom: say (3 ** 4 ** 5) div 8

[13:14] <p6eval> nom 867f9d: OUTPUT«4667398109262750544161996927310832352817622209796675096882961646525988007715815640374921111735049715255859563317893439476359088182402010732266891712285114841427396857428282261735087749399455053569647725513083516109967536568970850154257716229957184145239404834038077939…

[13:14] <cognominal> moritz++

[13:15] <moritz> cognominal: errors are meant for stuff that can be displayed nicely, so what you pass to &die should *really* stringify niecely

[13:16] <moritz> but you can do

[13:16] <moritz> nom: try { die Int }; say $!.payload

[13:16] <p6eval> nom 867f9d: OUTPUT«use of uninitialized value of type Str in string context␤use of uninitialized variable  of type Int in string context␤Int()␤»

[13:17] <moritz> you see, you get the Int() back in the end

[13:17] <moritz> the stringification in between is needed for HLL interop, and not something I want to get rid of

[13:17] <moritz> fsergot: https://github.com/perl6/nqp/commit/6d1c5ff486

[13:18] <sisar> wow, floating point arithmetic and large number representation on computers is *complicated* !

[13:18] <moritz> sisar: now you see what the poor compiler writers have  to deal with :-)

[13:19] <sisar> moritz: lol. accept my sympathies ;-)

[13:20] <dalek> nqp: d44ab2e | moritz++ | tools/build/PARROT_REVISION:

[13:20] <dalek> nqp: bump PARROT_REVISION to get separate unlink and rmdir primtives

[13:20] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d44ab2eba1

[13:21] <dalek> rakudo/nom: 1c93f3c | moritz++ | / (2 files):

[13:21] <dalek> rakudo/nom: bump NQP revision

[13:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1c93f3c501

[13:22] <moritz> fsergot: there you go. Once you 'git pull' and re-gen your parrot and nqp, you can use .unlink and .rmdir

[13:25] <fsergot> moritz++ thanks

[13:25] <sisar> both niecza & rakudo take considerable time before declaring true for '[<=] 1..10**10' . There is scope for optimization, but heck, who is ever gonna be as dumb as me ask a computer to check *that* for him :-)

[13:25] *** jaldhar left
[13:26] <moritz> sisar: there are other things we want to optimize too

[13:26] <moritz> sisar: like [+] 1..$n can be turned into $n * ($n+1) / 2

[13:26] <sisar> i thought jnthn optimized that

[13:27] <moritz> not that specific case

[13:28] <sisar> what did he do then ?

[13:28] <moritz> optimize reduction ops on long lists of values

[13:30] *** ponbiki joined
[13:35] <sisar> hm. to be clear, rakudo will optimize [<=] 1..LargeNumber (in future)? or will assume that no one is gonna try that ?

[13:35] <moritz> we'll optimize it.

[13:35] <sisar> why should we?

[13:36] <moritz> because it's our job to be smart even if the user isn't

[13:36] <moritz> no really, it might not be that obvious

[13:36] <masak> it's out job to make code that looks good/clear run optimally.

[13:36] <masak> our*

[13:36] <moritz> somebody might write   sub is_ordered(*@vals) { [<=] @vals) }

[13:36] <flussence> or to use a technical term, de-duplication of programmer effort :)

[13:36] *** snearch joined
[13:37] <moritz> and somebody else might call   is_ordered @something, and doesn't care where @something comes from

[13:37] <moritz> and that happens to be a Range

[13:38] <masak> if we know it's a Range at compile time, we can optimize the sub call to True :)

[13:39] <moritz> if it's a *numeric* range

[13:39] <masak> ah, yes.

[13:39] <moritz> note that  [<] 'a'..'b' # false

[13:39] <masak> have to be careful there.

[13:39] <masak> nod

[13:39] <moritz> and that (the need to be careful) is one of the reasons it's not yet optimized

[13:40] <sisar> nice points, moritz

[13:40] <moritz> it's hard to catch all corner cases, and while our test coverage isn't bad, it's not optimal either

[13:40] *** xinming left
[13:41] <sisar>  so do we document missing optimization needs, or its like "everybody knows it" or "too many to document" ?

[13:41] <moritz> sisar: we should add them to ROADMAP

[13:42] * sisar is a sucker for documenting everything :-)

[13:44] <dalek> rakudo/nom: e45989e | moritz++ | docs/ROADMAP:

[13:44] <dalek> rakudo/nom: document optimization ideas, sisar++ for proposing it

[13:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e45989e663

[13:44] *** tokuhirom joined
[13:45] *** pmurias joined
[13:47] *** ponbiki left
[13:48] <pmurias> sorear: is it ok if put niecza-p5 interoperability stuff into the p5 Niecza.pm module?

[13:49] *** xinming joined
[13:54] *** xinming left
[13:57] *** xinming joined
[13:59] *** ab5tract joined
[13:59] <sisar> moritz++

[14:00] *** ponbiki joined
[14:02] *** wolfman2000 joined
[14:05] *** bulll joined
[14:08] *** ponbiki left
[14:09] *** xinming left
[14:10] <bulll> FF ?DCC SEND “ff???f??????????????” 0 0 0 

[14:13] <fsergot> Where &fail is defined?

[14:13] *** xinming joined
[14:14] <masak> bulll: that's not a syntax I recognize -- what is that?

[14:14] <[Coke]> masak: it predates you, young one.

[14:14] * masak bows to the elders

[14:14] <masak> there's a ^A in there, I see.

[14:15] <bulll> ??�DCC SEND &quot;ff???f?ð‘¹ð‘°ð‘·ð‘³ð‘¶ð‘³ð‘ºð‘¼ð‘·ð‘®ð‘¼ð’€ð‘º&quot; 0 0 0

[14:15] <masak> bulll: please. don't.

[14:15] <[Coke]> If he's doing it accidentally, it's really quite impressive.

[14:15] <masak> [Coke]: is it malicious?

[14:16] <masak> I'm not averse to kicking someone who is making an ass of himself.

[14:16] <[Coke]> eh. it's spammy, anyway. if it barfs again, bump him for a bit.

[14:16] <masak> nod.

[14:17] <masak> [Coke]: you still didn't tell me what protocol that is.

[14:18] <flussence> I've never seen a protocol that uses “”-quotes before.

[14:18] *** bulll left
[14:18] <flussence> oh well, that answers that.

[14:18] <cognominal> nom:  (grammar { token TOP { <a>? $<b>='b' }; token a { a } }).parse: 'ab'; say $/<b>.keys;

[14:18] <p6eval> nom e45989: OUTPUT«a␤»

[14:20] <[Coke]> masak: ah. it actually read like modem crap, but looks he's trying to do a direct client send with IRC and failing.

[14:20] <[Coke]> http://en.wikipedia.org/wiki/Direct_Client-to-Client

[14:20] <[Coke]> my apologies. it's not as dirt old as I thought. ;)

[14:21] <huf> it's quite a horrible protocol tho :_)

[14:21] <[Coke]> IRC does suck, yes.

[14:22] <huf> IRC doesnt suck, it just has flaws

[14:22] <huf> DCC on the other hand ;)

[14:22] <etneg> that is likely some mirc crap

[14:22] <etneg> lol

[14:23] *** PZt left
[14:24] *** thou joined
[14:24] <huf> looks like ircII had it, so unlikely to be "some mirc crap"

[14:34] *** birdwindupbird left
[14:34] *** samlh left
[14:35] <moritz> fsergot: &fail is defined in src/core/Failure.pm

[14:38] <fsergot> moritz++

[14:41] *** PacoAir joined
[14:41] *** jferrero joined
[14:45] <dalek> niecza: 4927ce0 | (Paweł Murias)++ | perl5/Niecza/ (17 files):

[14:45] <dalek> niecza: create a stub Niecza p5 module with Module::Starter

[14:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4927ce0c44

[14:45] <dalek> niecza: 02fe910 | (Paweł Murias)++ | / (11 files):

[14:45] <dalek> niecza: Rename Niecza::Interoperability to Niecza.

[14:45] <dalek> niecza: Make Niecza a full Module::Build using module with an XS part.

[14:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/02fe910c95

[14:45] <colomon> pmurias++

[14:47] *** samlh joined
[14:47] <pmurias> colomon: the commits don't actually make the full niecza use Module::Build just the perl5 side interop support

[14:47] <colomon> pmurias: yes, I understood that.

[14:48] *** skids joined
[15:07] *** tokuhir__ joined
[15:08] <dalek> rakudo/nom: bd9cb3a | (Filip Sergot)++ | src/core/IO.pm:

[15:08] <dalek> rakudo/nom: changed &unlink and new &rmdir

[15:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd9cb3a6ac

[15:08] <dalek> rakudo/nom: 0f96959 | moritz++ | src/core/IO.pm:

[15:08] <dalek> rakudo/nom: Merge pull request #58 from sergot/nom

[15:08] <dalek> rakudo/nom: 

[15:08] <dalek> rakudo/nom: changed &unlink and new &rmdir

[15:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0f969596b5

[15:10] <moritz> fsergot++

[15:11] *** tokuhirom left
[15:16] <[Coke]> . ö O ( nom )

[15:17] <fsergot> karma fsergot

[15:17] <aloha> fsergot has karma of 4.

[15:17] <fsergot> \o/

[15:17] <fsergot> :)

[15:17] <tadzik> fsergot++

[15:18] <gfldex> <wikipedia>NTP uses an epoch of January 1, 1900. The first rollover will occur in 2036, prior to the UNIX year 2038 problem.</wikipedia>

[15:18] <gfldex> as more i read about clocks as less i like them

[15:19] <fsergot> tadzik: Could Shell::Command use File::Find?

[15:20] *** wtw left
[15:22] <tadzik> fsergot: sure

[15:22] <tadzik> it's the same package

[15:27] <colomon> tadzik: do you remember if panda uses unlink to remove directories?

[15:27] *** tokuhir__ left
[15:28] * colomon is trying to remember why he had to implement the ability to do rmdir using unlink in niecza...

[15:30] *** felher left
[15:32] *** felher joined
[15:32] <tadzik> colomon: I think it does, yes

[15:33] <colomon> I think the latest rakudo patches may break panda, then.

[15:33] <fsergot> So,  it's a problem now?

[15:33] <fsergot> :(

[15:34] <colomon> probably just requires some simple fixes

[15:35] <tadzik> colomon: it seems to use this just to remove files

[15:35] <fsergot> We can add &rm that will remove files and directories, but does that make sense?

[15:36] * tadzik shrugs

[15:36] <tadzik> I don't see why unlink shouldn't remove directories

[15:36] <tadzik> oh, in Perl 5 it does not

[15:37] <fsergot> Right.

[15:37] <tadzik> okay then

[15:40] <colomon> I definitely added rmdir support to unlink (in niecza) well after writing the rest of the unlink function.  I wouldn't have done it without running into something out there that wanted it to work that way...

[15:44] *** Psyche^ joined
[15:46] *** kaleem joined
[15:47] *** Patterner left
[15:47] *** Psyche^ is now known as Patterner

[15:53] <moritz> the reasoning is that unlink and rmdir are primitives that are supported by most operating systems as atomic operations

[15:53] <moritz> whereas everything magical that we might build ourselves will not be atomic

[15:53] <moritz> so it makes sense to make the primitives available

[15:53] <colomon> moritz: I'm not against unlink only handling files.  I'm just trying to figure out what piece of the perl 6 ecosystem is out there using it to delete directories

[15:58] <masak> moritz: +1

[15:59] <masak> I think file systems definitely isn't a place where we should try and reinvent a rounder, more beautiful wheel.

[15:59] <moritz> well, maybe we should, but it shouldn't be the only wheel available :-)

[15:59] <masak> there's a lot of thought gone into the current status quo :)

[16:00] <masak> right, we shouldn't try and abstract away the actual primitives.

[16:00] <pmurias> man 3 unlink mentions that it is possible to unlink directories on some system if you are root

[16:00] *** wolfman2000 left
[16:01] <pmurias> if i remember correctly thus making some bad stuff happen ;)

[16:01] <pmurias> perldoc -f unlink mentions that too

[16:02] <moritz> it's also possible to create hard links to directories on some systems. I wouldn't do it either :-)

[16:03] <flussence> .oO( those wheels could use some suspension springs... )

[16:04] *** PZt joined
[16:08] *** kaare_ joined
[16:09] *** MayDaniel joined
[16:12] *** mj41 left
[16:15] *** alim left
[16:17] <colomon> aha!

[16:19] <colomon> File::Tools's t/02-shell-command.t fails if unlink doesn't handle directories

[16:20] <tadzik> oh noes

[16:20] <tadzik> wanna commit bit?

[16:20] <tadzik> :)

[16:20] <colomon> sure

[16:20] <masak> \o/

[16:20] <moritz> please wait until after the star release (if we do one) with fixing

[16:20] <moritz> or do it in a branch

[16:20] <masak> colomon++

[16:20] <colomon> unlink 't/dupa/foo/bar';

[16:20] <colomon> unlink 't/dupa/foo';

[16:20] <colomon> unlink 't/dupa/';

[16:20] <colomon> moritz: why?  it's broken now.

[16:20] <masak> well, fix the tests.

[16:20] <cognominal> I don't understand the purpose of the .gethash method in the double quote interpolation   S02:3998

[16:21] *** ascent__ left
[16:21] <moritz> colomon: define "now"

[16:21] <colomon> if you grab the latest rakudo, File::Tools tests (and therefore panda's bootstrap) will fail

[16:21] <cognominal> what removing it would change?

[16:22] <moritz> colomon: yes, but "the latest rakudo" is later than "the last released compiler"

[16:22] <masak> cognominal: it's just an example.

[16:22] <moritz> colomon: and if we fix it for the development version, we might break it for the release

[16:22] <moritz> colomon: and since rakudo star bundles File::Tools, that would be unfortunate

[16:23] <moritz> colomon: unless you fix it in a way that doesn't break on the latest released version

[16:23] <cognominal> masak: albeit a misleading one

[16:23] <moritz> cognominal: you don't know what @baz[3](1, 2, 3) returns

[16:24] *** kaleem left
[16:24] <cognominal> moritz: indeed. forget what I said.

[16:28] <moritz> cognominal: but if you have a better example that uses just built-in types, I'd be happy to see that used instead

[16:29] *** MayDaniel left
[16:29] <fsergot> moritz: I said ealrier that we can write &rm subroutine which would work as the 'old' &unlink. Is it bad solution? :)

[16:29] <colomon> yes, that doesn't help at all

[16:30] <colomon> the problem is that we have to support the latest released Rakudo, which doesn't have rmdir, and ideally the latest github rakudo, which doesn't allow you to unlink a directory.

[16:31] <fsergot> Oh, right. Sorry :)

[16:31] <colomon> probably the easiest way to handle this is just to comment out the unlink "directory" calls for now

[16:31] <pmurias> colomon: use "rakudo detect"? ;)

[16:31] <moritz> eeks

[16:31] <moritz> I'd rather just shove the fix into a branch until after the star release

[16:32] <moritz> and live with the inconvenience of a test failure for a week or so

[16:32] <colomon> the inconvenience is that panda will not install

[16:32] <colomon> (unless I've somehow made panda-niecza stricter than panda)

[16:33] <tadzik> It feels wrong to me having a separate panda-niecza

[16:33] <tadzik> maybe it could have some Configure-alike mechanism to adjust stuff

[16:33] <cognominal> moritz: nope, I missed the point of the documentation which is the support of a parenthesis-less call in a double quote, not the purpose of the call.

[16:35] *** MayDaniel joined
[16:35] *** dukeleto left
[16:36] *** dukeleto joined
[16:36] *** dukeleto left
[16:36] *** dukeleto joined
[16:36] *** dukeleto left
[16:37] *** dukeleto joined
[16:37] *** dukeleto left
[16:37] *** dukeleto joined
[16:37] *** dukeleto left
[16:38] *** dukeleto joined
[16:38] *** dukeleto left
[16:38] *** dukeleto joined
[16:38] *** dukeleto left
[16:39] *** dukeleto joined
[16:39] *** dukeleto left
[16:39] *** dukeleto joined
[16:39] *** dukeleto left
[16:40] *** dukeleto joined
[16:40] *** fsergot left
[16:41] *** fsergot joined
[16:41] <etneg> groovy

[16:42] *** plobsing left
[16:42] *** REPLeffect left
[16:46] <[Coke]> colomon: people USE panda? from rakudo-nom-latest?

[16:46] <[Coke]> you can tag a release of the lib that is known to work with the last release, and then make master work on master.

[16:46] *** samlh left
[16:46] <[Coke]> you don't need a single commit that does both.

[16:48] *** REPLeffect joined
[16:52] *** jaldhar joined
[17:03] *** MayDaniel left
[17:04] *** birdwindupbird joined
[17:05] *** felher left
[17:06] *** felher joined
[17:11] *** daxim left
[17:14] *** MayDaniel joined
[17:15] <masak> TDD makes code come out different.

[17:16] <masak> it's sort of a minimalism thing.

[17:16] *** JimmyZ left
[17:22] *** am0c left
[17:26] *** dukeleto left
[17:26] *** dukeleto joined
[17:26] *** dukeleto left
[17:27] *** dukeleto joined
[17:27] *** dukeleto left
[17:27] *** dukeleto joined
[17:27] *** pmurias left
[17:31] *** am0c joined
[17:33] *** Vlavv_ joined
[17:35] *** pernatiy left
[17:36] <[Coke]> # 02/24/2012 - niecza++ ; pugs (15.56%); rakudo (99.26%)

[17:36] <[Coke]> "niecza",     20283,     8,   751,  1549, 22591, 23597

[17:36] <[Coke]> "pugs"  ,      3158,     6,  1744,    47,  4955, 23388

[17:36] <[Coke]> "rakudo",     20134,    28,   604,  1869, 22635, 23607

[17:37] <[Coke]> niecza is resting on its laurels.

[17:37] <TimToady> sorear++ is attending to his schoolwork

[17:37] <TimToady> *eir schoolwork :)

[17:37] <colomon> pronoun trouble

[17:38] <colomon> ;)

[17:38] <huf> use *

[17:38] <colomon> so where should I put tests for mkdir and rmdir?

[17:38] <huf> i hear it does the right thing

[17:38] *** jaldhar left
[17:38] *** benabik left
[17:38] *** mikemol left
[17:39] *** mikemol joined
[17:39] <moritz> colomon: S16-io/*

[17:40] <colomon> any sane reason I shouldn't just make the testfile mkdir_rmdir.t?  It's hard to test one without the other...

[17:42] *** plobsing joined
[17:42] *** birdwindupbird left
[17:43] <masak> colomon: go for it.

[18:02] <TimToady> "now you see what the poor compiler writers have to deal with"

[18:03] <colomon> errr.... hmmm, unlink.t seems to be in S16-filehandles

[18:03] <TimToady> now you see what the poor compiler writers refuse to deal with, and blame the programmer for any mistakes

[18:15] *** jfried left
[18:15] *** wolverian left
[18:15] *** jfried joined
[18:21] *** mathw left
[18:24] *** MayDaniel left
[18:28] *** dorlamm joined
[18:29] *** mathw joined
[18:30] <dalek> roast: 54bd8ba | (Solomon Foster)++ | S16-filehandles/mkdir_rmdir.t:

[18:30] <dalek> roast: Simple test file for mkdir and rmdir.

[18:30] <dalek> roast: review: https://github.com/perl6/roast/commit/54bd8ba9ea

[18:35] *** Chillance joined
[18:36] <[Coke]> colomon: your use of ".Int" there blocks pugs.

[18:36] <[Coke]> (not that it could probably dothe rest of it)

[18:37] <colomon> pugs: mkdir "lets-see"

[18:37] <p6eval> pugs b927740: OUTPUT«*** Unsafe function 'mkdir' called under safe mode␤    at /tmp/ssY050ft92 line 1, column 1 - line 2, column 1␤»

[18:37] <colomon> pugs: rmdir "lets-see"

[18:37] <p6eval> pugs b927740: OUTPUT«*** Unsafe function 'rmdir' called under safe mode␤    at /tmp/fpAxU7ETfj line 1, column 1 - line 2, column 1␤»

[18:37] <colomon> looks like it might well be able to handle the core functions, anyway

[18:37] <colomon> pugs: 10.1.floor

[18:37] <p6eval> pugs b927740:  ( no output )

[18:37] <colomon> pugs: say 10.1.floor

[18:37] <p6eval> pugs b927740: OUTPUT«10␤»

[18:38] <[Coke]> pugs: say rand.Int

[18:38] <p6eval> pugs b927740: OUTPUT«*** No such method in class Scalar: "&Int"␤    at /tmp/yQTC7FRgW7 line 1, column 5 - line 2, column 1␤»

[18:38] *** mathw left
[18:38] <dalek> roast: 17034f7 | (Solomon Foster)++ | S16-filehandles/mkdir_rmdir.t:

[18:38] <dalek> roast: Switch .Int to .floor for pugs.

[18:38] <dalek> roast: review: https://github.com/perl6/roast/commit/17034f771f

[18:41] *** preflex_ joined
[18:42] *** preflex left
[18:42] *** preflex_ is now known as preflex

[18:44] *** pernatiy joined
[18:46] <dalek> niecza: 0874dc3 | (Solomon Foster)++ | lib/CORE.setting:

[18:46] <dalek> niecza: Add rmdir.  Using unlink to remove a directory is now deprecated, but we'll leave the functionality in there until Rakudo sorts out its issues.

[18:46] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0874dc3fdd

[18:46] <dalek> niecza: b5e1ab1 | (Solomon Foster)++ | t/spectest.data:

[18:46] <dalek> niecza: Turn on S16-filehandles/mkdir_rmdir.t.

[18:46] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b5e1ab1928

[18:46] <colomon> [Coke]: there's 14 more working tests for you.  ;)

[18:46] *** dorlamm left
[18:47] *** dorlamm joined
[18:47] *** mathw joined
[18:49] *** snearch left
[18:56] *** fridim_ joined
[18:57] <colomon> [Coke]: I meant in niecza, of course... not sure if they will run in pugs or not.

[18:58] <TimToady> std: 1 == 2

[18:58] <p6eval> std 52f3895: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/oDkTuxE3nL line 1:␤------> [32m1 ==[33m⏏[31m 2[0m␤Parse failed␤FAILED 00:01 109m␤»

[18:59] <moritz> what's bogus about that?

[19:01] <colomon> niecza: 1 == 2

[19:01] <p6eval> niecza v14-66-g02fe910:  ( no output )

[19:02] *** ab5tract left
[19:03] <TimToady> what's bogus is that Perl isn't treating nonbreaking space as whitespace

[19:03] <TimToady> Pelr 5

[19:03] <TimToady> *rl

[19:04] <arnsholt> Pretty far off-topic (sorry), but the kind of thing someone in here might know: Do any of you know off hand if a portion of text in square brackets in a classical (Latin) text is added text, or to be considered as not there (even though present in most manuscripts)?

[19:04] <arnsholt> I can never remember >.<

[19:05] <TimToady> in Greek there are usually footnotes that say :)

[19:06] <TimToady> failing that, the front matter usually says how to interpret them

[19:07] <TimToady> in the absence of such guidance, I'd read them as "not 100% of the manuscripts have this" without commitment to whether it was an addition or deletion

[19:07] <arnsholt> Yeah, that might be it

[19:07] <arnsholt> Now to decide which reading to choose when I'm fixing stuff in a corpus I'd like to parse =)

[19:07] *** mikemol left
[19:08] <TimToady> they are usually used for additions in Greek texts

[19:09] <arnsholt> The disadvantage of this electronic library of texts is that the critical apparatus doesn't seem to be there

[19:09] <TimToady> right, that's so very...useful...

[19:10] <arnsholt> Heh. Most of the time it's not much of an issue, but in this case it's pretty annoying

[19:10] <arnsholt> But thanks for the input! I'm closer to enlightenment at least, so that's progress

[19:10] <TimToady> in Nestle's Greek NT you get ABCD ratings of the likelihood it was in the original manuscript

[19:11] <TimToady> along with various alternate readings

[19:11] <arnsholt> That's pretty cool

[19:11] <TimToady> so there brackets are almost always an addition

[19:12] <arnsholt> Yeah, looking closer at the text and thinking a bit more, I think it has to be an addition

[19:13] <arnsholt> (Incidentally, Sallust's history of the Catiline conspiracy is pretty cool)

[19:17] <cognominal> so they invented a very crude form of version control.

[19:20] <[Coke]> colomon: *** No such subroutine: "&nok"

[19:20] *** am0c left
[19:21] <[Coke]> pugs: sin(3).Int.say

[19:21] <p6eval> pugs b927740: OUTPUT«*** No such method in class Num: "&Int"␤    at /tmp/jAliqZwCcU line 1, column 1 - line 2, column 1␤»

[19:21] <[Coke]> nom: sin(3).Int.say

[19:21] <p6eval> nom 0f9695: OUTPUT«0␤»

[19:25] *** dukeleto left
[19:26] *** dukeleto joined
[19:26] *** dukeleto left
[19:26] *** dukeleto joined
[19:26] *** dukeleto left
[19:27] *** dukeleto joined
[19:27] *** dukeleto left
[19:27] *** dukeleto joined
[19:28] *** dukeleto left
[19:28] *** dukeleto joined
[19:28] *** dukeleto left
[19:28] *** sisar left
[19:28] *** dukeleto joined
[19:29] *** dukeleto left
[19:29] *** dukeleto joined
[19:29] *** dukeleto left
[19:29] *** dukeleto joined
[19:30] *** dukeleto left
[19:30] *** dukeleto joined
[19:30] *** dukeleto left
[19:31] *** dukeleto joined
[19:31] *** dukeleto left
[19:31] *** dukeleto joined
[19:31] *** dukeleto left
[19:32] *** dukeleto joined
[19:32] <arnsholt> cognominal: This isn't the Romans' notation though, it's editors of the texts in recent(ish) times. But yeah, sort of =)

[19:35] *** noam left
[19:35] *** noam joined
[19:37] *** benabik joined
[19:39] <colomon> [Coke]: it's a standard Test.pm method...

[19:40] <moritz> just not yet in pugs Test.pm, I think

[19:42] <flussence> argh! now my netbook doesn't have enough RAM to build firefox *or* chromium! At least nom still works...

[19:42] *** plobsing left
[19:43] <flussence> (and it's because of a gigantic linker command each time...)

[19:47] <masak> TimToady: mecro foo($x) { $x }; my $a = 42; say foo my $a # does this output 42?

[19:47] <masak> er, macro*

[19:48] *** MayDaniel joined
[19:49] <TimToady> std: macro foo($x) { $x }; my $a = 42; say foo my $a

[19:49] <p6eval> std 52f3895: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $a (see line 1) at /tmp/ZG5pdBWYmQ line 1:␤------> [32moo($x) { $x }; my $a = 42; say foo my $a[33m⏏[31m<EOL>[0m␤ok 00:01 113m␤»

[19:49] <TimToady> can you deduce it from that?  :)

[19:49] <masak> I know redeclaration produces a warning. it'd still run, I guess.

[19:50] <masak> I'm probing for how much of a closure/thunk each macro parameter is.

[19:50] *** havenn joined
[19:50] *** bluescreen10 left
[19:50] <TimToady> I'd think so; your macro is pretty much a no-op

[19:50] <TimToady> more thunk than closure; there's no new scope

[19:51] <masak> right.

[19:51] <masak> but a thunk still carries its context with it somehow.

[19:51] <TimToady> thunks are parasites on some other lexical scope

[19:52] <masak> it's a bit problematic because at the point the macro is called, we're still in compile mode and things are very much not built up yet.

[19:52] <masak> so the best we can do is to parasite the thunk on the static lexpad.

[19:52] <TimToady> perl6: True && my $a = 42; say $a

[19:52] <p6eval> pugs b927740, rakudo 0f9695, niecza v14-68-gb5e1ab1: OUTPUT«42␤»

[19:52] <masak> but then when we run we'll want the "same" thunk to have been fixup'd to parasite on the appropriate runtime lexpad.

[19:53] <masak> TimToady: in a sense, it's a thunk in that it doesn't have a block boundary, but it's a closure in that it has to be portable enough to be carried into the macro routine.

[19:54] <masak> I don't think I've ever seen a portable thunk.

[19:55] *** bluescreen10 joined
[19:56] <jnthn> evenin', #perl6

[19:56] <moritz> \o jnthn 

[19:56] <masak> jnthn! \o/

[19:58] * jnthn is done with teaching for a bit :)

[19:58] <colomon> o/

[19:59] *** birdwindupbird joined
[20:01] *** mj41 joined
[20:02] *** wooden left
[20:07] *** Trashlord joined
[20:08] <dalek> std: f87df17 | larry++ | STD.pm6:

[20:08] <dalek> std: Update definition of Nil in undef remapping

[20:08] <dalek> std: review: https://github.com/perl6/std/commit/f87df17854

[20:08] <dalek> std: a540d4e | larry++ | STD.pm6:

[20:08] <dalek> std: Be panicky about malformed traits

[20:08] <dalek> std: review: https://github.com/perl6/std/commit/a540d4e994

[20:10] <masak> macro foo($x) { my $a = 1; quasi { say $a; say {{{$x}}} } }; my $a = 2; foo $a # perhaps this is a better starting point

[20:11] <masak> there's two lookups here of a variable `$a`, starting from the same lexical scope, that should find two different variables.

[20:11] *** tarch_ left
[20:12] <masak> h...how does that happen, in practice? what makes one go one way and the other go another way?

[20:14] <masak> note that the `$a` that becomes a macro arg AST needs to be "live", and we can't substitute 2 or something simple like that... the assignment hasn't even happened yet!

[20:14] <masak> (and in the general case we might need the lvalue, not just a snapshot)

[20:14] <moritz> that's the question of how to achieve hygiene, right?

[20:15] <masak> yes, it ends up being about hygiene here. but my actual question is more general.

[20:15] <TimToady> $x has to know its pad, and the outer $a is already bound to it by the time the $x is passed

[20:15] <masak> namely, how to wire up so that macro-arg ASTs remember their provenance.

[20:15] <masak> TimToady: right, that's what I've concluded as well.

[20:16] <masak> but the pad at the point of the macro call is the static pad, and later when we run it needs to be fixup'd to be the runtime pad containing the 2.

[20:19] <masak> problem is, at the point we're running the stuff, there's nothing left to do fixups *on*. :/

[20:20] <masak> maybe it'd be possible to hook the fragments of macro-arg ASTs that end up in the program AST into the normal closure fixup somehow... but that's a really vague notion right now.

[20:20] <masak> anyway, it's problematic.

[20:26] *** wolverian joined
[20:27] *** mathw left
[20:27] *** mathw joined
[20:31] <TimToady> I suspect there's some analog tree-walk that corresponds to the reparse that unhygienic macros do

[20:32] <jnthn> .oO( as opposed to a digial tree-walk? )

[20:33] * colomon is trying to figure out how to get one of his very first p6 scripts to run again

[20:34] <colomon> \o/

[20:34] <colomon> odd that    -> $text is rw     was the hang-up

[20:34] <TimToady> lemme guess, $.x vs $!x  :)

[20:34] <TimToady> ah

[20:35] <colomon> dunno why I stopped using this script, it's great for copying and pasting C++ code.  ;)

[20:35] <TimToady> what the 'is rw' what you had or what you needed?

[20:35] <TimToady> *was

[20:35] <colomon> what I had

[20:36] <TimToady> and using it on immutables?

[20:36] *** att joined
[20:36] <colomon> nom: for $*IN.lines() -> $text is rw { $text = "boo" }

[20:36] <p6eval> nom 0f9695: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <anon> at /tmp/aHym_wCOkT:1␤␤»

[20:36] <colomon> yeah

[20:36] <colomon> ooo, should have been is copy, eh

[20:36] <colomon> ?

[20:37] <jnthn> Looks like it

[20:37] <colomon> yup, is copy works beautifully

[20:38] <colomon> the style of the code is horrible, IMO

[20:38] <colomon> I clearly hadn't learned what I was doing yet.

[20:38] <TimToady> perl6: for $*IN.lines { $_ = 42 };  # will probably bite lots of P5 folx

[20:38] <p6eval> rakudo 0f9695: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <anon> at /tmp/B_PhqEYdEz:1␤␤»

[20:38] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Scalar: "&lines"␤    at /tmp/3P1zHsD4OI line 1, column 5-16␤»

[20:38] <p6eval> ..niecza v14-68-gb5e1ab1:  ( no output )

[20:39] <masak> sub custom-ast { my $a = 1; my $ast = #`[hypothetical way to build an AST object, manually. let's say it codes for `say $a;`]; }; my $a = 2; eval custom-ast # does this output 1, or 2?

[20:41] <TimToady> depends on how your AST builder marks the $a

[20:41] * jnthn woulda thunk 1, and you'd need COMPILING::<$a> to mean the other thing

[20:41] <jnthn> Mebbe :)

[20:42] *** plobsing joined
[20:42] <TimToady> many ASTs can know in advance which pad they're binding to, but that case requires a default to caller's $a, I suspect

[20:43] <TimToady> either the AST knows, or it doesn't, and if it doesn't, the first place that does fixup treewalk probably claims it

[20:44] <TimToady> quasi itself is already defined to default to macro's $a, but I'm assuming your #`[] maybe has a different policy

[20:44] <TimToady> and the only way it can emulate COMPILING::<$a> is to leave it unbound for now, I think

[20:45] <masak> I'm mostly just throwing use cases around right now -- I have no particular agenta.

[20:45] <TimToady> quasi just won't do that without explicit COMPILING declaration

[20:45] *** Jerkwad joined
[20:45] <masak> right.

[20:45] <TimToady> but the effect might be to leave $a unbound in the returned AST, and let the fixup catch it

[20:46] <masak> unbound ASTs sound like a kind of unhygiene to me.

[20:46] <TimToady> unbound variable only

[20:46] <masak> since they'll bind quite late, and lookups will find whatever's close by.

[20:46] <masak> yeahbut.

[20:46] *** pmurias joined
[20:46] <masak> nothing's a "variable" in the AST. it's all just nodes.

[20:47] <masak> some nodes represent variable lookups.

[20:47] <masak> lookups for bound variables and unbound variables are indistinguishable.

[20:47] <PerlJam> So ... is "unquasi" still underspecced as eval?

[20:47] <masak> PerlJam: I'm using eval for now, because it makes sense to me.

[20:47] <[Coke]> colomon: I'm not complaining.

[20:48] <masak> PerlJam: it's not really an "unquasi", since a quasi turns program code (text) into an AST, but the eval turns the AST onwards into executable code.

[20:48] <PerlJam> true

[20:48] <masak> (and runs that code)

[20:49] <PerlJam> (I don't have a good name for it though)

[20:49] <TimToady> .oO(Entish, the Language of Trees)

[20:50] <masak> :)

[20:50] <PerlJam> as far as variable lookups are concerned, we can use "eval" to control when variables get bound, right?

[20:50] <TimToady> and the Entwives are obviously the free variables

[20:50] <masak> PerlJam: for a while I was considering &val, since it turns a tree fragment into a value, but &val is taken too nowadays.

[20:51] * PerlJam has the beginnings of an idea, but not enough brain power right now to walk it through to completion

[20:53] <TimToady> we're making something too hard here...

[20:53] <TimToady> in: my $a; $a

[20:53] <TimToady> the $a doesn't really care which lexpad it's in, it just knows it a particlar location in the current lexpad

[20:54] <masak> are you talking about lookups to variables in the current lexpad being special-cased?

[20:55] <TimToady> I'm sayin', by the time you stitch the AST back in, any free $a should behave the same as if it were already there in the first place

[20:57] <TimToady> (I'm ignoring the parrot findlex fiasco for the moment; talking about ideal lexpad where a variable just compiled to an offset from some base address)

[20:57] <TimToady> all a recursive call does is supply a different base address

[20:58] <TimToady> likewise a clone

[20:58] <masak> I'm not even sure I believe in the use case of a free $a yet. it only occurs when an AST is created programatically; in all other cases, the AST already has a context to look up $a in.

[20:58] <masak> but I might be misunderstanding something.

[20:59] <masak> we're at the limit of my comprehension of these issues.

[20:59] <TimToady> I do think there is a use case for mixed hygienic ASTs with unhygienic bits that need to be "linked"

[20:59] <masak> feel free to provide one :)

[20:59] <masak> afk &

[20:59] <TimToady> well, anything that wants to declare a variable in the caller's scope, for one

[21:00] <TimToady> but then use it hygienically in the rest of the macro

[21:00] <TimToady> much better to switch to hygiene in the middle than to do the whole thing textually

[21:01] *** birdwindupbird left
[21:03] <TimToady> allowing bits of reparse-style unquoting limits damage to the smallest scope, leaving the hygienic macro to brainwash the parser only with respect to those parts of the parse it wants to brainwash the parser about

[21:04] <TimToady> otherwise we force people to write text macros that are just source filters writ slightly smaller

[21:04] <geekosaur> mmm, lisp macros

[21:05] <TimToady> hygienic macros are a lot like the fates that the lexer supplies to the parser in STD; "Look into my eyes; you're getting sleepy...sleeply...you've already parsed this, so wake up and look at the AST you just made. <snap>"

[21:06] <TimToady> only in the case of fates, it's only the initial entry that is faked, not the production of the AST

[21:07] <TimToady> well, the entry isn't faked, but the pattern matching is bypassed, since the LTM already figured that part out

[21:08] <TimToady> anyway, I think hygienic really means telling the whitest lies you can get away with...so if we can limit the reparsing to merely relinking variables, the lies are almost very white

[21:09] <TimToady> but sometimes you want to lie a little more than that

[21:09] *** HarryS left
[21:10] *** mj41 left
[21:11] <mathw> I love this conversation :)

[21:13] * TimToady ponders a degenerate case of parsing $x entirely lazily, as controlled by demand from the macro and it's "parse now" bits, but hesitates to mention it lest it drive masak insane(r)

[21:13] <TimToady> *its

[21:15] * pyrimidine readies the tin foil hat for masak

[21:17] <TimToady> hygienic macros are all about fooling the lie detector

[21:17] <mathw> what is a hygienic macro?

[21:18] <pyrimidine> one that uses lots of soap?

[21:18] * TimToady would be very surprised if there were not a wikipedia entry for that

[21:18] <TimToady> top google hit, in fact

[21:18] *** fsergot left
[21:19] <cognominal> if it were not in wikipedia, it would not exist.

[21:19] * mathw goes to read it

[21:19] <pyrimidine> makes sense why they're called hygienic now

[21:20] <cognominal> I am not sure which  came first, the world or the wikipedia.

[21:21] <benabik> cognominal: Check the Wikipedia articles for "The World" and "Wikipedia".  Compare dates.  :-D

[21:22] <mathw> I remember when there wasn't a wikipedia, and the world was around then

[21:22] <mathw> so I think the world came first, unless somebody's been injecting false memories

[21:23] <TimToady> and we know Wikipedia *never* injects false memories...

[21:25] <mathw> So basically a hygienic macro is one which can't accidentally clash its internal definitions with ones in its surrounding scope

[21:26] <mathw> and thus rather useful

[21:27] <TimToady> Conjecture: we could scrap "is parsed" entirely, and just pass a Cursor in when requested, and make the macro do the parsing of arguments by calling grammar rules directly on the Cursor--but presumably only if the signature asks for the Cursor

[21:29] <TimToady> in fact, a macro could secretly be a method on the current parse, so self is already that Cursor, and no need to request it if you need it, though we'd have to worry about returning a new Cursor in that case

[21:30] <TimToady> so the new AST would presumably be returned as part of the new cursor, like any ordinary parser rule does

[21:30] <cognominal> cursory conjecture?

[21:32] <TimToady> a macro is, after all, really just a sort of sugar for a grammar rule

[21:32] <cognominal> “The question is,” said Alice, “whether you can make identifiers bind to so many different things.”

[21:33] <TimToady> The question is who's to be outer, that's all.

[21:40] *** Trashlord left
[21:41] *** MayDaniel left
[21:42] <masak> ok, I like the macro-as-method-on-Cursor idea a lot.

[21:42] <masak> I'm not so sure about the whole "white lies" musing, mainly because I still haven't seen a concrete use case.

[21:42] *** fsergot joined
[21:42] <masak> until further notice, I will implement the spec as it stands. :)

[21:43] *** bluescreen10 left
[21:46] *** havenn left
[21:47] <masak> yes, the question is who's to be OUTER. the tricky thing about hygienic macros is that it essentially has two legitimate OUTERs: the "normal" one, in the code where it is located, and the "macro" one, which is the normal OUTER of the quasi the code was generated from.

[21:48] <colomon> who controls the horizontal?  who controls the vertical?

[21:48] <PerlJam> I guess that second one is the place where the macro is used?

[21:48] *** pmurias left
[21:49] <PerlJam> (You may have said that, but the words didn't quite register that way for me)

[21:49] *** zipf joined
[21:49] <masak> no, the first one is the place where the macro is used. if by "used" you mean "called".

[21:49] <masak> the second one is where the macro is defined.

[21:49] <PerlJam> oh, then "where the code is located" was completely confusing to me :)

[21:49] <masak> yes, that was ambiguous.

[21:50] <masak> I meant something like, "where the code is located *now*, after it has been stitched into the mainline"

[21:51] *** Trashlord joined
[21:51] <masak> the difference between closures and macro-generated code is in where in the production chain "cloning" is done.

[21:51] *** zipf left
[21:52] <masak> closures can clone themselves so as to generate more fresh pads. macro quasis clone themselves and generate fresh new program code.

[21:54] *** proller_ joined
[21:59] *** bluescreen10 joined
[22:00] <PerlJam> and they (macros) use the pad of whatever code they've been injected into.

[22:01] <PerlJam> so ... what's a use-case for using the OUTER available at macro definition time?

[22:02] <PerlJam> (my mind is still slowly wrapping itself around these ideas)

[22:04] <PerlJam> (and, assuming there is a nice use case that means we'd need to distinguish definitional-OUTER from macro-call-OUTER, could we have OUTER always be the latter, and use MACRO::OUTER (or something) for the former ?)

[22:04] *** skids left
[22:04] *** shinobicl_ left
[22:06] *** bkolera joined
[22:16] <masak> PerlJam: actually, the code inside a quasi *primarily* uses the OUTER of the quasi. this is the basis of hygiene.

[22:17] <masak> PerlJam: things like COMPILING may offset that and make the code inside the quasi choose the mainline as its OUTER.

[22:17] <masak> I guess that's your MACRO::OUTER.

[22:17] <masak> see S06, the last few parts, for details.

[22:18] *** preflex_ joined
[22:19] <PerlJam> but code inside the macro def (but outside the quasi) use which OUTER?

[22:19] *** preflex left
[22:20] *** preflex_ is now known as preflex

[22:22] <PerlJam> never mind, that's a foolish question

[22:22] * PerlJam just isn't thinking clearly right now

[22:25] <masak> don't worry, I've tread this path for the past few months, I know what it's like :)

[22:25] <masak> the code inside the macro def has completely normal lookup rule. a macro is just a routine, which happens to be called at BEGIN time.

[22:25] <masak> rules*

[22:27] <PerlJam> aye, it's only the quasi that's weird.

[22:27] <PerlJam> :-)

[22:27] <masak> and the quasi is only weird in that it's transplanted someplace else and still expected to "remember" its provenance like a closure... but *also* sometimes use its new adopted OUTER, if asked to.

[22:32] <sorear> good * #perl6

[22:34] <masak> sorear! \o/

[22:34] *** manhunter joined
[22:34] <manhunter> anyone there?

[22:34] <PerlJam> manhunter: yep

[22:35] <PerlJam> (At least for the next few minutes)

[22:35] <manhunter> what's difference between perl and perl6?

[22:36] <PerlJam> manhunter: could you give me some more context?  Because I can think of probably a hundred ways to answer that  :)

[22:37] <sorear> perl is a program which executes the Perl 5 language.  perl6 is the name of several programs that execute Perl 6.

[22:37] <PerlJam> manhunter: sorear chose to answer in the same way as what came to my mind first :)

[22:37] <sorear> Perl 6 is an (as yet incomplete, incompatible) successor to Perl 5.  It is *not* simply an upgrade.

[22:38] <manhunter> Ok, what's the difference between perl5 an perl6?

[22:39] <PerlJam> manhunter: they are different languages that share a common ancestry

[22:39] <PerlJam> manhunter: there are lots of differences.

[22:39] <masak> manhunter: back in 2000, some people wanted to make a new Perl, called Perl 6.

[22:39] <manhunter> why?

[22:39] <masak> we're the intellectual descendants of those people.

[22:39] <manhunter> what's the problem with perl5?

[22:39] <masak> why? because it was felt there was a need for it.

[22:40] <masak> Perl 5 is a fine language.

[22:40] <PerlJam> manhunter: perl 5 had some deficiences at the time that weren't amenable to gradual change.

[22:40] <masak> there's no "the problem" with Perl 5.

[22:40] <masak> there are a number of problems with Perl 5, which may or may not ever get fixed.

[22:40] <manhunter> what's the benifit/advantage did you give in perl6?

[22:41] <PerlJam> manhunter: laziness, a real object system, grammars, etc.

[22:41] <masak> Perl 6 is designed, where in many places Perl 5 grew forth.

[22:41] <masak> some things have been re-thought and redesigned so they make more sense.

[22:41] <manhunter> any syntax difference?

[22:41] <PerlJam> manhunter: yes

[22:41] <masak> yes.

[22:41] <masak> there weren't many to start with, but the two languages have diverged.

[22:42] <masak> well, Perl 6 has diverged. :)

[22:42] <manhunter> what is the basic difference? give some example

[22:42] <masak> ok.

[22:42] *** plobsing left
[22:42] <PerlJam> manhunter: sigil invariance is a simple syntactic difference.

[22:42] <[Coke]> Perl 6 has become more like Perl 6. Perl 5 has also become more like Perl 6.

[22:42] <masak> Perl 5: `if $var == 3 || $var == 4 || $var == 8 { ... }`

[22:42] <masak> Perl 6: `if $var == 3 | 4 | 8 { ... }`

[22:43] <sorear> Another thing is that Perl 5 is very tied to a single C implementation, and will only run in eenvironments where C works

[22:43] <[Coke]> masak: that's not valid 5.

[22:43] <doy> that would be "if ($var == 3 ...)"

[22:43] <masak> oh!

[22:43] <manhunter> if $var == 3 || $var == 4 || $var == 8 { ... } looks good though

[22:43] <masak> yeah, but you need parens in Perl 5.

[22:43] <masak> I keep forgetting that.

[22:43] <PerlJam> masak: the lack of parens spoils you a little.

[22:43] <PerlJam> :)

[22:43] <arnsholt> I've started forgetting it as well. A tad annoying at times ^_^

[22:43] <sorear> Perl 6 currently has (among major implementations only) a C-based implementation, a C#-based implementation, and a Haskell-based implementation

[22:43] <manhunter> if ($var == 3 || $var == 4 || $var == 8) looks good though , it is the C syntax 

[22:43] <masak> Perl 5: `my $sum = 0; for (@values) { $sum += $_ }; say $sum`. Perl 6: `my $sum = [+] @values; say $sum`

[22:44] <doy> manhunter: what's wrong with making a language not based on c?

[22:44] <sorear> Larry: We're serious about reinventing all the wheels that need s to be reinvented

[22:44] <PerlJam> manhunter: right ... that's Perl 5.  Perl 6 makes the same expression more concise.

[22:44] <masak> manhunter: yes. Perl 6 doesn't always keep to the C syntax.

[22:45] <PerlJam> Perl 6 has better abstractions  :)

[22:45] <masak> Perl 5: `package MyClass; sub new { bless {}, shift }`. Perl 6: `class MyClass {}`

[22:46] <masak> Perl 5: `if ($a < $b && $b < $c) { ... }`. Perl 6: `if $a < $b < $c { ... }`

[22:47] *** manhunter left
[22:47] <masak> Perl 5: `package Tones; our $DO = 0; our $RE = 1; our $MI = 3;`. Perl 6: `enum Tones <DO RE MI>;`

[22:48] <sorear> enum Tones <DO RE :MI(3)>; you mean :p

[22:48] <sorear> might need double angles

[22:50] <masak> oops. I meant `our $MI = 2` :)

[22:51] *** NamelessTee left
[22:54] *** fridim_ left
[22:58] <Teratogen> o/~ do a deer a female deer, re, a drop of golden sun o/~

[22:58] *** kaare_ left
[23:04] *** plobsing joined
[23:07] *** thou left
[23:07] <fsergot> good night #perl6 o/

[23:08] *** manhunter joined
[23:08] *** dankodin joined
[23:08] <manhunter> hi

[23:09] *** fridim_ joined
[23:09] *** thou joined
[23:15] *** dorlamm left
[23:19] *** NamelessTee joined
[23:20] *** Chillance left
[23:23] <sorear> manhunter: hi

[23:31] *** Trashlord left
[23:39] *** manhunter left
[23:42] *** Tedd1 left
[23:42] *** Tedd1 joined
[23:45] *** skids joined
[23:50] *** att left
[23:57] *** seanstickle joined
