[00:01] <TimToady> sorear: here's a Set.pm that works (mostly) under niecza: https://gist.github.com/1654636

[00:02] * TimToady is not sure about precedence levels yet...

[00:06] <[Coke]> ooh, TimToady++

[00:06] <TimToady> something to be said for making them list infixes

[00:07] <TimToady> so that they can coerce lists to sets automatically

[00:08] <TimToady> oops, forgot the Bool returns too

[00:10] <dalek> (sorear) cool, TimToady.

[00:11] <dalek> (sorear) I guess object-keyed hashes would make a nice addition...

[00:12] <dalek> (sorear) also, to keep masak++ happy, needs ASCII aliases.  Preferably infix:<\in>, infix:<\subseteq>, etc :D

[00:13] *** cooper joined
[00:13] <sorear> for some reason my connection to host02 just dropped out for about five minutes

[00:13] <sorear> it's been laggy all day

[00:13] <sorear> how's host02 been treating you, TimToady?

[00:14] <TimToady> dropping lots of packets

[00:16] *** LlamaRider joined
[00:16] <sorear> o/ LlamaRider 

[00:16] <LlamaRider> o/

[00:17] <LlamaRider> hi there

[00:17] *** donri left
[00:17] *** thou left
[00:19] *** benabik_ joined
[00:19] *** benabik left
[00:19] *** benabik_ is now known as benabik

[00:20] <jnthn> arrrghhh, finally I think I see $nasty-bug

[00:20] * jnthn feels stupid for not spotting it earlier

[00:21] <LlamaRider> oh noes, I just started rebuilding rakudo :D I guess there will be need to do that again

[00:23] <jnthn> LlamaRider: Well, my patch didn't work yet, but also it's not something that impacts current Rakudo master built against the suggested NQP.

[00:23] <LlamaRider> *whew*

[00:24] <LlamaRider> good luck with it then :)

[00:24] <jnthn> Thanks.

[00:24] <jnthn> If it is what I think it is, then it's one of those annoying situations where you spend an hour spotting the issue and then the patch is 1 line long.

[00:30] <TimToady> revised to have return types, and set ops can now coerce to sets

[00:30] <TimToady> (typing blind, so please forgive typos)

[00:31] <TimToady> and there are already Texas versions

[00:31] <TimToady> currently the list infixes all have the same precedence

[00:32] <TimToady> arguably (&) should be tighter than (|) for consistency...

[00:33] <TimToady> but I don't know what set theoreticians think about the precedence of ∪ vs ∩

[00:33] <jnthn> uuurah, patch is success \o/

[00:33] <dalek> nqp: bbd5639 | jnthn++ | src/QAST/Compiler.nqp:

[00:33] <dalek> nqp: Helps to actually have the cstack pulled out of the cursor before we go trying to look at stuff in it.

[00:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bbd5639307

[00:36] <jnthn> phenny: tell moritz latest nqp master fixes pretty much all the failures. rx.t and comb.t I didn't verify as they need ICU; since it's just 3 tests I'm happy to todo those and win the many, many more we get - plus the important backtracking functionality.

[00:36] <phenny> jnthn: I'll pass that on when moritz is around.

[00:39] *** cognominal_ joined
[00:43] *** cognominal left
[00:43] *** nwc10 joined
[00:44] <nwc10> To check, Rakudo isn't considered "production ready" yet, is it?

[00:46] <jnthn> nwc10: I don't think of it as such yet. You can do useful stuff with it, for sure, but I don't think any commonly used definition of "production ready" should be applied to it yet.

[00:47] <nwc10> Good stuff. Otherwise I'd be asking for the non-public security bug reporting address :-)

[00:47] <nwc10> Because I assume that all the fun with hash collisions applies to Rakudo too. http://www.ocert.org/advisories/ocert-2011-003.html

[00:47] <nwc10> (no-one has mentioned it in this context yet, to my knowledge, so I'm assuming that it will be, as one has to take action to avoid it)

[00:50] <jnthn> nwc10: Think https://github.com/parrot/parrot/commit/ccf2d6a3805ebebebf5267d108dce98f7d9a6d9a may be related

[00:51] <jnthn> No idea *if* Parrot_platform_get_entropy() is sufficiently random

[00:51] <nwc10> yes, that looks plausible. If it's "working", then hashes should come back in a different order for each run

[00:51] <jnthn> nwc10: Plausible, yeah. I ain't tried it.

[00:51] <doy> i'd honestly be a bit surprised if it was an issue, considering perl 5 fixed it back in 2003

[00:51] <nwc10> I'm pretty sure I don't have a build of Rakudo anywhere

[00:52] <nwc10> indeed. It was so strange watching the rest of the world blow up.

[00:52] <nwc10> The perl 5 games are here: http://perl5.git.perl.org/perl.git/blob/HEAD:/util.c#l5802

[00:53] <nwc10> it doesn't need much to be safe

[00:53] <doy> also, it doesn't require hashes to come back in a different order for each run, necessarily - perl 5 only starts randomizing things if it detects degenerate behavior (unless you set a compile flag)

[00:53] <nwc10> yes, but that was sort of a fudge to get back to binary compatibility with modules which had pre-compiled hash values in them

[00:53] <jnthn> Perl_croak(aTHX_ "Your random numbers are not that random");

[00:53] <jnthn> :D

[00:53] <nwc10> it's sort of useful to always come back with different orders, to set programmer expectations

[00:54] <doy> sure, just saying it's not required

[00:54] <doy> (:

[00:54] <nwc10> but it was a bit too, um, politically awkward to retrofit that

[00:54] <nwc10> IIRC one of Dan's original stated policies for Parrot was that if something didn't need to be ordered, then that thing should be made to be returned in a non-predictable order

[00:55] <nwc10> to force people to code defensively, rather than having assumtions that then break

[00:55] <nwc10> no idea how well that stuck.

[00:55] *** LlamaRider left
[00:55] *** donri joined
[00:57] <TimToady> I guess I don't have Texas versions of ∈ or ∋ yet... okay, new gist with (elem) and (cont) too

[00:58] *** kboga joined
[00:59] <kboga> nom: say 0x1000000000000000 <+ 1

[00:59] <p6eval> nom fa821c: OUTPUT«Bool::False␤»

[01:00] <kboga> nom: say 0x1000000000000000 +< 1 #oops

[01:00] <p6eval> nom fa821c: OUTPUT«2305843009213693952␤»

[01:06] <japhb> *rez*

[01:06] <phenny> japhb: 21 Jan 23:53Z <sorear> tell japhb I have my doubts about $?USAGE as a true compile-time constant.  say $?USAGE; multi MAIN ...; say $?USAGE # should the two says differ?

[01:07] <TimToady> perl6: my %hash = 'a' .. 'z' X=> 1; say %hash.keys

[01:07] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«z y x w v u t s r a b c d e f g h i j k l m n o p q␤»

[01:07] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "%hash"␤    expecting "=", context, ":" or "("␤    at /tmp/KAT84gW118 line 1, column 4␤»

[01:07] <p6eval> ..rakudo fa821c: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[01:09] <japhb> sorear, Did you mean to have a BEGIN before the first 'say $?USAGE'?  Because otherwise I don't think they would be different.  Perhaps I am in violent agreement ... $?USAGE to me can only be set once the unit has been completely compiled, so no, it is not in that sense the same as other compile-time constants.

[01:09] <jnthn> o/ japhb 

[01:09] <japhb> Note that I am VERY backlogged because of $day-job craziness, so if there has been discussion of this in the last week, I don't know about it.

[01:10] *** nwc10 left
[01:10] <japhb> o/ jnthn, long time since we've been on at the same time.  :-)

[01:10] <jnthn> japhb: Yeah, I was pretty exhausted by Christmas and took some mostly-offline rest.

[01:11] <japhb> Good for you!

[01:11] <japhb> Still feeling charged up, even after 3 weeks of January?

[01:12] <jnthn> japhb: Reasonably. Was a bit tired from teaching last week - I had the misfortune of sleeping awfully the night before the course. But rested well today and feeling reasonably good again. :)

[01:12] <japhb> Oh yeah, I hate it when I get bad sleep right before something important.  At least you're better now!

[01:13] <japhb> I actually got massively bad sleep the night before my job interview for my current job.  I babbled.  A lot.  :-)

[01:13] <jnthn> Yeah. The course went fine, but I was done for after each day.

[01:14] *** nornagest left
[01:15] <japhb> What was the subject last week?  C# again?

[01:17] *** LlamaRider joined
[01:17] <jnthn> japhb: Yeah. I made this advanced C# course at $dayjob, which for some reason is selling *really* well. I've got bookings for giving it every month through to May or something crazy. 

[01:17] <japhb> There are many worse problems to have.  ;-)

[01:17] <jnthn> Yes, I'm happy with this particular problem. :)

[01:18] <kboga> nom: say nqp::p6box_i(pir::shl__III(2**64, 1)); say 2**64 +< 1; say nqp::bitshiftl_I(nqp::p6decont(2**64), nqp::unbox_i(1), Int)

[01:18] <jnthn> (As are my $dayjob :-))

[01:18] <p6eval> nom fa821c: OUTPUT«0␤0␤36893488147419103232␤»

[01:19] <japhb> I bet!

[01:20] <kboga> looks like nom still uses the pir::shl op for bigints? 

[01:20] <jnthn> kboga: If so, that would be decidedly ungood.

[01:21] <jnthn> kboga: Looks like you're correct :(

[01:21] <japhb> *sigh* From the sounds of the kids, I think I need to disappear again ...

[01:21] <japhb> *derez*

[01:21] <kboga> ehm, that last p6decont and unbox_i shouldn't be there...

[01:22] <jnthn> kboga: Oddness. moritz++ even wrote ops for doing the bigint shl/shr by the looks of it.

[01:22] <kboga> oh, shr too

[01:23] *** shinobicl_ joined
[01:23] <jnthn> Yeah

[01:24] <jnthn> kboga: It looks like a really easy fix - just change the Int candidates for the ops in Int.pm from nqp::bitshiftl_i to nqp::bitshiftl_I

[01:24] <jnthn> kboga: Feel free to try it if you wish...it's 2:30AM here and I want to sleep. :)

[01:24] <jnthn> kboga: Or if not then please just file a ticket, and somebody will get to it soon no doubt :)

[01:26] <kboga> this should fix that: http://pastebin.com/2KqtY64w

[01:26] <jnthn> kboga: Looks plausible. 

[01:27] <jnthn> kboga: If it works, feel free to send pull request or lemme know and I can apply it tomorrow. Or maybe moritz++ beats me to it.

[01:27] * jnthn -> sleep; 'night all

[01:28] <LlamaRider> good night

[01:30] *** kboga left
[01:39] *** thou joined
[01:40] *** shinobicl_ left
[01:57] *** kboga joined
[01:57] <kboga> pull request filed, good night jnthn & p6

[01:58] *** kboga left
[02:01] *** Tenzen joined
[02:05] *** icwiener left
[02:05] *** icwiener joined
[02:20] <colomon> OMG!

[02:20] <colomon> ==> Succesfully installed panda-niecza

[02:21] *** jferrero left
[02:22] <colomon> sorear: ping?

[02:26] *** jferrero joined
[02:27] *** s1n left
[02:30] *** kboga joined
[02:32] *** thou left
[02:34] *** donri left
[02:35] <kboga> phenny: tell jnthn test summary report of latest nqp (including your patch) & rakudo (with icu) and the shl/shr patch applied: http://pastebin.com/VLV2Pezx . The only failing test looks a lot like the one that nqp accidently passed for the wrong reasons https://github.com/perl6/nqp/commit/078ea5d911d52879150b0ae08fb2b502eed982d2

[02:35] <phenny> kboga: I'll pass that on when jnthn is around.

[02:38] *** LlamaRider left
[02:39] *** kboga left
[02:55] *** _twitch joined
[02:58] <ggoebel> colomon++

[03:01] <sorear> colomon: pong

[03:01] <colomon> sorear: o/

[03:02] <sorear> japhb: I was under the impression that $?FOO was reserved for constants, which can only be set at the moment they are defined

[03:02] *** _twitch left
[03:02] *** _twitch joined
[03:04] <colomon> at some point, we need to think about making ~/.perl6/lib part of the default path

[03:04] <colomon> though I'm still kind of thinking there should be separate .perl6s for rakudo and niecza.

[03:05] *** Chillance left
[03:19] *** _twitch left
[03:20] *** whiteknight left
[03:26] *** _twitch joined
[03:28] *** orafu left
[03:28] *** orafu joined
[03:38] *** Psyche^ joined
[03:42] *** Patterner left
[03:42] *** Psyche^ is now known as Patterner

[03:50] *** leprevost left
[04:14] <araujo> anybody knows if there exist some 'partial' bindings or initial effort for some Gui toolkit bindings already?

[04:22] *** PacoAir left
[04:25] *** icwiener left
[04:25] *** icwiener joined
[04:26] <dalek> Heuristic branch merge: pushed 137 commits to rakudo/str-numeric by japhb

[04:44] *** icwiener left
[04:44] *** icwiener joined
[05:06] *** benabik_ joined
[05:06] *** benabik left
[05:06] *** benabik_ is now known as benabik

[05:14] *** molaf joined
[05:17] *** icwiener left
[05:17] *** icwiener joined
[05:20] *** molaf left
[05:22] *** molaf joined
[05:23] <TimToady> araujo: colomon++ was playing with Gtk in December, but for some reason search on the ir clock doesn't find it

[05:23] <TimToady> I found a ref by searching for "button" instead

[05:25] <moritz> in the niecza repo there are some gtk examples

[05:25] <phenny> moritz: 21 Jan 23:37Z <jnthn> tell moritz thanks for doing the test run, that looks promising; I know a bunch of those that now explode are all doing so due to one underlying cause.

[05:25] <phenny> moritz: 00:36Z <jnthn> tell moritz latest nqp master fixes pretty much all the failures. rx.t and comb.t I didn't verify as they need ICU; since it's just 3 tests I'm happy to todo those and win the many, many more we get - plus the important backtracking functionality.

[05:26] <araujo> TimToady, ooh, I see, thanks, I might ask him later

[05:27] <araujo> moritz, they work?

[05:27] * araujo will check

[05:27] <moritz> araujo: I haven't tried them, but I have seen screenshots and blogposts about them

[05:29] <moritz> perl6: say (-4) 

[05:29] <p6eval> pugs b927740, rakudo fa821c, niecza v13-327-g5a9c36f: OUTPUT«-4␤»

[05:29] <moritz> perl6: say (-4) +< 2

[05:29] <p6eval> pugs b927740, rakudo fa821c, niecza v13-327-g5a9c36f: OUTPUT«-16␤»

[05:29] <moritz> perl6: say 4 +< 2

[05:29] <p6eval> pugs b927740, rakudo fa821c, niecza v13-327-g5a9c36f: OUTPUT«16␤»

[05:30] <TimToady> perl6: say -4 +< 2

[05:30] <p6eval> pugs b927740, rakudo fa821c, niecza v13-327-g5a9c36f: OUTPUT«-16␤»

[05:30] <dalek> rakudo/nom: 2e84915 | kboga++ | src/core/Int.pm:

[05:30] <dalek> rakudo/nom: Make the bitwise shift subs on Int:D's actually use the bigint arithmetic nqp ops that Moritz++ coded.

[05:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e84915ba0

[05:30] <dalek> rakudo/nom: ba6e783 | moritz++ | src/core/Int.pm:

[05:30] <dalek> rakudo/nom: Merge pull request #56 from kboga/fix_bigint_shl/shr

[05:30] <dalek> rakudo/nom: 

[05:30] <dalek> rakudo/nom: Make the bitwise shift subs on Int:D's actually use the bigint arithmetic nqp ops that Moritz++ coded.

[05:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ba6e783942

[05:35] <japhb> sorear, Looking at S28, I don't think $*USAGE would be appropriate twigil use; the USAGE does not change from run to run (or during a run, if MOP actions that would alter USAGE are disallowed), and is indeed fixed after compile is complete.  However, unlike some of the other $? variables, its value is not fully determined at the instant of a reference to it in single-pass compilation.  Thus if you want to constant-fold it, you cannot do so

[05:35] <japhb>  on the fly -- you must constant-fold it after the unit has been compiled.  Which sounds to me like it needs some special casing, somewhere from very low to medium on the hackishness scale, depending on how the rest of the compiler is architected.

[05:36] <sorear> japhb: The most expedient approach would be to make $?USAGE an ordinary (LISimple) lexical

[05:36] <sorear> although this would mean that the user could do $?USAGE := ... and it wouldn't be rejected

[05:37] <TimToady> &MAIN.usage is another possibility

[05:39] <japhb> TimToady, in fact, jnthn has suggested that $?USAGE be set at the right time by doing exactly &MAIN.usage .  :-)

[05:39] <TimToady> if .usage can be calculated, why bother precalculating it?

[05:39] <TimToady> it's not like it needs heavy optimization...

[05:39] <japhb> Taking the alternate branch in my comment above about having to disallow MOP actions that would change USAGE at runtime, we are then left with a variable that must be handled like a $*, but is more logically named $?

[05:40] <TimToady> I'd be perfectly happy blowing $?USAGE away if &MAIN.usage works

[05:41] <japhb> TimToady, I think we may have a winner, then.

[05:41] <japhb> Because that's sure as heck the easiest implementation.

[05:42] <japhb> (Though it does leave the tiny bleck that if &MAIN gets .usage() from Routine, then Routine will have a .usage() that only makes sense for one specific use case.)

[05:43] <TimToady> or people should learn to read a more general description of what the routine wants that works either way

[05:43] <TimToady> assuming one could finesse that...

[05:44] <sorear> huh?

[05:44] <japhb> TimToady, we could make it output a couple of different syntaxen depending on an adverb.

[05:45] <TimToady> that's also an option

[05:45] <japhb> --foo=bar v. :foo('bar')

[05:45] <TimToady> or .usage vs .USAGE :)

[05:45] <japhb> ooh

[05:46] <japhb> .oO( If you're going to shout about the Routine's name, perhaps you want to shout about its usage as well? )

[05:46] <TimToady> it's an idea, anyway

[05:46] <sorear> TimToady: Does the return value from the mainline code of a file mean anything in Perl 6 under any circumstance?

[05:47] <TimToady> I think it'd be less POLA if it's in sink context

[05:47] <TimToady> (the last statement)

[05:47] <TimToady> but allowing explicit return would allow explicit fail too

[05:48] <japhb> TimToady, what if the last line of the file happens to be an assignment?

[05:48] <sorear> I don't understand what you're trying to say.

[05:48] <sorear> What I'm asking - is there any difference whatsoever between -e 0 and -e 1 ?

[05:48] *** JimmyHoff left
[05:48] <TimToady> japhb: assignments don't care if they're in sink context

[05:48] <TimToady> I don't think so

[05:48] <japhb> Which is to say, were you suggesting forcing sink context on the last line, or just changing from the Perl 5 default?

[05:49] <TimToady> how is that different?

[05:49] <TimToady> well, Perl 5 has the last line in sink context I believe

[05:50] <japhb> Really?  Never tried that.

[05:50] * sorear is still a sink contect unbeleiver, fwiw

[05:51] <TimToady> buubot_backup: eval use warnings; 1 + 1

[05:51] <buubot_backup> TimToady: 2

[05:51] *** _twitch left
[05:51] <TimToady> well, warns with -2

[05:51] <TimToady> -w

[05:51] <TimToady> Useless use of a constant (2) in void context at - line 1.

[05:52] <TimToady> buubot is obviously screwing around with the context

[05:53] <japhb> eval use 5.10; sub context { my $c = wantarray; say $c ? "list" : defined $c ? "scalar" : "void"; } context;

[05:53] <buubot_backup> japhb: ERROR: Perl v5.100.0 required (did you mean v5.10.0?)--this is only v5.14.2, stopped at (eval 20) line 1. BEGIN failed--compilation aborted at (eval 20) line 1. 

[05:53] <TimToady> "useless use of" are some of the most useful warning that Perl 5 gives

[05:53] <japhb> eval use 5.10.0; sub context { my $c = wantarray; say $c ? "list" : defined $c ? "scalar" : "void"; } context;

[05:53] <buubot_backup> japhb: scalar 1

[05:54] <japhb> Interesting!  Using -E locally, that's void.

[05:54] <TimToady> it's obvsiously in scalar context if it reports the result

[05:54] <japhb> Oh, duh.

[05:54] <japhb> *sigh*

[05:54] * japhb is clearly not thinking with all oars in water tonight

[05:55] <dalek> nqp: 0b6d2f1 | moritz++ | VERSION:

[05:55] <dalek> nqp: bump VERSION to 2012.01

[05:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0b6d2f1296

[05:55] <japhb> Sadly, I think that means I should not code.

[05:58] <TimToady> sorear: sink context has *only* the use of triggering side effects; if the last operation has no side effects, it makes no sense in a sink context

[05:59] <TimToady> and very nearly always indicates a misunderstanding of something like precedence

[05:59] <TimToady> so sink context is very important for figuring out awesome error messages

[06:01] <TimToady> buubot_backup: eval use warnings; 2 + rand; 3

[06:01] <buubot_backup> TimToady: Useless use of addition (+) in void context at (eval 20) line 1. 3

[06:02] <TimToady> perl6: 2; 3;

[06:02] <p6eval> pugs b927740, rakudo ba6e78, niecza v13-327-g5a9c36f:  ( no output )

[06:02] <TimToady> we have a ways to go there

[06:03] <dalek> rakudo/nom: 66c4b84 | moritz++ | tools/build/NQP_REVISION:

[06:03] <dalek> rakudo/nom: bump NQP revision

[06:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/66c4b8420d

[06:03] <dalek> rakudo/nom: 17ae87e | moritz++ | docs/ChangeLog:

[06:03] <dalek> rakudo/nom: update ChangeLog

[06:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/17ae87e2cd

[06:04] <japhb> TimToady, is that Perl 5 warning altered by an overload of '+'?

[06:04] <TimToady> I doubt it; and if you overload '+' with something with side effects, you deserve whatever you get

[06:04] <japhb> Heh.

[06:09] <TimToady> knowing which functions are really functions might be important enough to distinguish a 'fun' keyword from the 'sub' keyword

[06:09] <TimToady> I don't want to see 90% of the functions marked 'is pure'

[06:10] <TimToady> alternately, we say that any subs that default to returning something are by default functions unless declared otherwise

[06:10] <japhb> Hmmm.  And the consequences of lying about purity?

[06:11] <TimToady> sometimes you get caught sooner, sometimes later

[06:11] <TimToady> it's pretty easy to spot whether you're changing something outside the function most of the time

[06:12] <TimToady> at least in the immediately available code

[06:13] <dalek> rakudo/nom: 70b2ce7 | moritz++ | docs/ (3 files):

[06:13] <dalek> rakudo/nom: 2012.01 release announcement

[06:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/70b2ce79be

[06:13] <TimToady> it would be interesting to go through our current settings and see how much is pure already

[06:13] <japhb> .oO( "Cannot call impure routine from code declared to be a pure function." )

[06:14] <moritz> phenny: tell jnthn I mostly prepared the January release; is there anything in your TODO worth waiting for?

[06:14] <phenny> moritz: I'll pass that on when jnthn is around.

[06:14] <TimToady> for an immutable type like Set, every method is pure

[06:16] <dalek> roast: 6556f08 | moritz++ | / (4 files):

[06:16] <dalek> roast: fudge a rakudo regression (which we bogusly passed before), and several unfudges

[06:16] <dalek> roast: review: https://github.com/perl6/roast/commit/6556f08678

[06:16] <TimToady> otoh, something like ff is pure only if both sides of it are pure

[06:16] <moritz> we really need a better immutability marker than WHICH

[06:16] <moritz> infix:<does> also need to check if an object is immutable

[06:17] * TimToady thinks that immutable is really the default, and mutators should check if an object is mutable

[06:18] <TimToady> more capabilities based than prohibition based

[06:18] <moritz> any objects wihch have no rw accessors and simply don't assign to attributes are immutable

[06:19] <TimToady> effectively immutable, but maybe hard to determine

[06:20] <moritz> right

[06:20] <moritz> which is why I'd like some kind of declaration

[06:21] <TimToady> let's not call it 'data' like Haskell calls things that aren't data

[06:23] <sorear> I also need an immutability check for constant folding

[06:24] <TimToady> sure; note how Perl 5 complains about 1+1 as constant 2 rather than infix '+' :)

[06:25] <TimToady> buubot_backup: eval 2+2; 3

[06:25] <buubot_backup> TimToady: 3

[06:25] <TimToady> buubot_backup: eval use warnings; 2+2; 3

[06:25] <buubot_backup> TimToady: Useless use of a constant (4) in void context at (eval 20) line 1. 3

[06:25] <TimToady> like that

[06:25] <sorear> eval use warnings; 2+2; 3

[06:25] <buubot_backup> sorear: Useless use of a constant (4) in void context at (eval 20) line 1. 3

[06:25] <sorear> you don't even need the nick

[06:25] <TimToady> ah

[06:25] <TimToady> eval is one of my favorite functions :P

[06:25] <buubot_backup> TimToady: ERROR: No such class favorite at (eval 20) line 1, near "of my favorite" syntax error at (eval 20) line 1, near "of my favorite" 

[06:26] <sorear> blech, p5 indirect object syntax

[06:26] <TimToady> I don't suppose we can make it recognize p5eval instead...

[06:28] <sorear> japhb: now starting to try to port your MAIN_HELPER

[06:32] <japhb> sorear, sorry to hear it.  ;-)

[06:37] <sorear> wait, seriously, Perl 6 MAIN doesn't suppport permutation?

[06:38] <japhb> ?

[06:38] <sorear> ls /var -l

[06:38] <japhb> Right, that is not supported.

[06:39] <japhb> Thus, you can't do an interface like ImageMagick.

[06:39] <japhb> But nothing stops you from parsing @*ARGS yourself ...

[06:39] <TimToady> for offbeat argument processors, one can either preprocess @*ARGS or avoid MAIN entirely

[06:40] <sorear> meh, I'm just spoiled by GNU getopt

[06:40] <TimToady> it's not an important enough feature to make it do everything

[06:41] <TimToady> though if we required use of MAIN, there'd be more pressure in that direction

[06:41] <japhb> Why would we require that?

[06:41] <TimToady> to be prescriptionist like other language designers :)

[06:41] <japhb> Heh.

[06:42] <TimToady> Sorry, "Heh." does not contain a verb.

[06:42] <japhb> It contains a weakened interjection.

[06:43] <TimToady> .oO(a weekend interjection)

[06:43] <japhb> .oO( Interjections!  Show excitement, or emotion! They're set apart from a sentence by an exclamation point, or by a comma when the feeling's not as strong. )

[06:44] <TimToady> Oh--are those the only two ways?

[06:44] <japhb> School House Rock had entirely too much influence on my English lessons as a child.

[06:44] <TimToady> conjunction junction...

[06:45] <japhb> Exactly.  I loved that one.  Heck, I loved almost all of the grammar and science ones.

[06:45] <japhb> I didn't find out until I had children of my own that I'd missed the entire season of multiplication ones.

[06:45] *** benabik left
[06:46] <japhb> My favorite of all of them though is still The Tale of Mr. Morton, I think.

[06:46] <TimToady> sorear: you have to realize I'm a bit irrational when it comes to getopt routines; I've never ever used one in C.

[06:48] <TimToady> I've also never used lex/flex, probably for similar reasons

[06:48] *** icwiener left
[06:48] <TimToady> (not necessarily good reasons...)

[06:49] <TimToady> I guess it's not surprising that Perl 6 tries to make all those at least somewhat obsolete

[06:56] <sorear> perl6: my $?FOO

[06:56] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«===SORRY!===␤␤Variables with the ? twigil cannot be declared using my; they are created using 'constant'. at /tmp/W8ChKzy5Qg line 1 (EOF):␤------> my $?FOO⏏<EOL>␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/ni…

[06:56] <p6eval> ..pugs b927740, rakudo 70b2ce:  ( no output )

[06:58] <TimToady> speaking of obsolete, I'd better go to bed...

[06:58] <TimToady> zzz &

[06:58] <sorear> good night

[06:58] <japhb> o/

[07:03] <sorear> japhb's MAIN_HELPER does some funny things with constraint_list ...

[07:04] <japhb> lemme go pull up my ancient code

[07:04] *** icwiener joined
[07:06] <japhb> sorear, yeah, some of that is Rakudo-isms.  It tries to DWIM when the original constraint was a constant, for instance.

[07:06] <japhb> IIRC, that is.

[07:06] <sorear> japhb: 'ancient' code?

[07:06] <japhb> In nom years.

[07:06] <japhb> ;-)

[07:07] <sorear> I see

[07:07] <japhb> It's been too long since I've done anything but bug fix in here, because my supply of readily available tuits dried up before Failure and val() were ironed out.

[07:08] <japhb> Which is why my comment about being sorry you had to port the current version was only half joking.

[07:11] *** icwiener left
[07:35] <sorear> nom: sub MAIN() { }; @*ARGS = '--help'

[07:35] <p6eval> nom 70b2ce: OUTPUT«Unexpected named parameter 'help' passed␤  in sub MAIN at /tmp/VtShIBsnEA:1␤  in sub MAIN_HELPER at src/gen/CORE.setting:7709␤  in block <anon> at /tmp/VtShIBsnEA:1␤  in <anon> at /tmp/VtShIBsnEA:1␤»

[07:35] <sorear> nom: say Code.^methods(:local);

[07:35] <p6eval> nom 70b2ce: OUTPUT«Method 'gist' not found for invocant of class 'Sub'␤  in method gist at src/gen/CORE.setting:4056␤  in sub say at src/gen/CORE.setting:5931␤  in block <anon> at /tmp/Yv4v3fXyXP:1␤  in <anon> at /tmp/Yv4v3fXyXP:1␤»

[08:06] *** drbean joined
[08:19] *** Patterner left
[08:21] *** Psyche^ joined
[08:21] *** Psyche^ is now known as Patterner

[08:21] *** Trashlord left
[08:33] *** Patterner left
[08:36] *** kaare_ joined
[08:38] *** Psyche^ joined
[08:38] *** Psyche^ is now known as Patterner

[08:50] *** Trashlord joined
[08:51] *** GlitchMr joined
[08:52] <tadzik> good morning

[08:53] <sorear> o/ tadzik

[08:53] <GlitchMr> hi

[08:53] <sorear> o/ GlitchMr

[08:54] *** kaare__ joined
[08:54] *** kaare_ left
[08:57] <sorear> Why isn't Signature.perl just a call to map and join?

[09:06] <sorear> ...And why does this code read so much like NQP?

[09:10] <dalek> niecza: 41df027 | sorear++ | main.pl:

[09:10] <dalek> niecza: Start drafting port of Sub introspection, MAIN_HELPER

[09:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/41df027922

[09:10] * sorear -> sleep

[09:15] <tadzik> g'night

[09:24] *** kaare_ joined
[09:24] *** kaare__ left
[09:49] *** kaare_ left
[09:53] *** dbr joined
[10:06] <fsergot> good morning :)

[10:10] *** mj41 joined
[10:18] *** birdwindupbird joined
[10:26] *** kaare_ joined
[10:49] *** donri joined
[11:02] *** cognominal_ left
[11:03] *** cognominal joined
[11:12] *** bbkr1 joined
[11:13] *** fsergot left
[11:13] *** sftp_ joined
[11:14] *** sftp left
[11:20] *** bbkr1 left
[11:35] *** fsergot joined
[11:39] *** fsergot left
[11:45] *** mauror joined
[11:48] *** MayDaniel joined
[11:54] *** mauror left
[11:57] *** fsergot joined
[11:57] *** fsergot left
[11:58] *** fsergot joined
[11:58] *** am0c joined
[11:59] *** mauror joined
[12:01] *** birdwindupbird left
[12:01] *** birdwindupbird joined
[12:05] *** MayDaniel left
[12:09] <moritz>  hmmmmmmmmmmr cf7…....... 

[12:10] *** whiteknight joined
[12:10] *** fsergot left
[12:14] *** mauror left
[12:15] <jnthn> afternoon

[12:15] <phenny> jnthn: 02:35Z <kboga> tell jnthn test summary report of latest nqp (including your patch) & rakudo (with icu) and the shl/shr patch applied: http://pastebin.com/VLV2Pezx . The only failing test looks a lot like the one that nqp accidently passed for the wrong reasons https://github.com/perl6/nqp/commit/078ea5d911d52879150b0ae08fb2b502eed982d2

[12:15] <phenny> jnthn: 06:14Z <moritz> tell jnthn I mostly prepared the January release; is there anything in your TODO worth waiting for?

[12:16] <tadzik> moritz: oh, hello Ronja :)

[12:16] *** mauror joined
[12:18] <moritz> wow, she even managed to produce a character I don't know how to write on that keyboard

[12:18] <jnthn> moritz: Thanks for that! The only thing I wanted to do was make sure MiniDBI can work under nom. In the worst (though hopefully unlikely) case it'd need fixes in the dyncall handling code. I will check that out within the next few hours. So, we can put out that release today :)

[12:19] <tadzik> moritz: try alt+comma, or alt+dot

[12:19] <moritz> tadzik: neither does it

[12:19] <moritz> and I haven't even configured a compose key :-)

[12:20] <masak> g'day, #perl6.

[12:21] <jnthn> o/ masak 

[12:21] <tadzik> :)

[12:21] <tadzik> hey masak 

[12:21] <masak> hey hey hey -- from a train!

[12:21] <masak> :D

[12:22] <masak> I don't know why I find that so fascinating every time.

[12:22] <tadzik> :P

[12:22] <jnthn> masak: I did it on a plane in December!

[12:22] <masak> whoa.

[12:22] <jnthn> masak: How fascinating would that be? :)

[12:22] *** bbkr1 joined
[12:22] <masak> that's Internet without even touching the ground!

[12:23] <masak> I bet that requires some sort of wire-less technology.

[12:23] <tadzik> as if the internet was in the air!

[12:23] <tadzik> nah, I doubt it. I think the plane has this roll of cable, and it's plugged in somewhere on the airport

[12:24] <tadzik> that'd be SO MUCH FASTER

[12:24] <jnthn> Oh...and that's why they only do this on shorthaul flights? The cable isn't long enough to do longhaul flights yet? Now I see it...

[12:24] <moritz> it's very thin glas fiber, that's why you normally don't see it

[12:24] <tadzik> or maybe it's using a wireless fiberoptics

[12:24] <tadzik> like, you know, a flashlight and a receiver

[12:24] <jnthn> OK so...MiniDBI is so old it mentions proto.

[12:24] <jnthn> Also

[12:24] <jnthn> I don't have a commit bit on it :(

[12:25] <masak> in fact, contrails are just glass fiber glittering in the air.

[12:25] <jnthn> Ah, but moritz++ does :)

[12:25] <tadzik> hah, git-proxy :P

[12:26] <moritz> jnthn: and I think I can even give you a commit bit

[12:26] <jnthn> moritz: ah, ok

[12:26] *** hugme joined
[12:26] <moritz> provided I get that stupid bot running :-)

[12:26] *** ChanServ sets mode: +v hugme

[12:26] <moritz> hugme: add jnthn to MiniDBI

[12:26] <jnthn> I just did a fork but if you can give me a bit on the real thing... :)

[12:26] <hugme> moritz: You need to register with freenode first

[12:27] <moritz> uhm, can somebody else please try that?

[12:27] <tadzik> hugme: add jnthn to MiniDBI

[12:27] <hugme> tadzik: You need to register with freenode first

[12:27] <tadzik> I _am_ registered!

[12:27] <moritz> seems the bot is b0rked

[12:27] <moritz> I'll work around it

[12:27] *** hugme left
[12:27] <jnthn> hugme: add jnthn to MiniDBI

[12:27] <tadzik> :)

[12:31] <moritz> jnthn: please re-check if you now have access

[12:31] <jnthn> Seems so! :)

[12:31] <jnthn> moritz++

[12:40] <moritz> jnthn, masak: do you already have travel plans for DPW2012 (like, which flights you take)?

[12:40] *** fsergot joined
[12:41] *** PacoAir joined
[12:45] <masak> moritz: no, not yet.

[12:51] <jnthn> masak: I looked up the train, fwiw. 10 hours!

[12:52] <masak> about what I'd expect.

[12:52] <tadzik> heh, my bus ride will take about 14 :P

[12:52] <jnthn> yeah

[12:53] *** hugme joined
[12:53] *** ChanServ sets mode: +v hugme

[12:54] <moritz> hugme: add jnthn to MiniDBI

[12:54] * hugme hugs jnthn. Welcome to MiniDBI!

[12:54] <moritz> \o/

[12:55] <masak> \o/

[12:56] <jnthn> Just successfully pushed there too :)

[12:56] <moritz> long story short, the freenode responses had changed

[13:00] <moritz> has anybody seen or heard from mberends lately?

[13:01] <jnthn> No :(

[13:01] *** am0c left
[13:01] * masak misses mberends

[13:01] * moritz too

[13:02] <masak> he's probably very busy, as he was in the latter half of 2011.

[13:02] <jnthn> Last I saw him was the Perl 6 workshop.

[13:02] <jnthn> er

[13:02] <jnthn> London Perl Workshop

[13:02] <jnthn> :)

[13:02] <tadzik> (:

[13:03] * masak .oO( Freudian Slip Perl Workshop )

[13:04] <jnthn> :P

[13:04] <jnthn> Hm. Well, now MiniDBI loads the mysql driver and gets to the point of trying to connect. :)

[13:05] <colomon> araujo: see https://github.com/colomon/mandelbrot/blob/master/bin/gtk-mandelbrot.pl for example

[13:12] * moritz now sent an email to mberends++

[13:17] * moritz adds a META.info to MiniDBI

[13:30] <dalek> nqp: 9c20151 | jnthn++ | src/pmc/sixmodelobject.pmc:

[13:30] <dalek> nqp: Revert a commit I thought I'd already reverted, but musta only done in a branch.

[13:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/9c20151436

[13:32] *** tokuhirom joined
[13:33] *** Alias left
[13:35] *** tokuhir__ joined
[13:38] *** bbkr1 left
[13:39] *** tokuhirom left
[13:40] <moritz> nom: role A { has $!foo }; class B does A { method x() { $!foo = 'bar' } }; B.new.x

[13:40] <p6eval> nom 70b2ce: OUTPUT«===SORRY!===␤Attribute $!foo not declared in class B␤at /tmp/lPtQ_Qrpe8:1␤»

[13:40] <moritz> that one is stopping MiniDBD::Pg

[13:41] <jnthn> moritz: I just updated MiniDBD::mysql for the nom semantics in that regard.

[13:41] <masak> yeah; nom is right there.

[13:41] <jnthn> I get it to connect to mysql and prepare a statement, but it's blowing up on executing it.

[13:44] <masak> moritz++ jnthn++ # working on MiniDBD

[13:45] <moritz> jnthn: I've copied your fix over to MiniDBD::Pg

[13:48] <moritz> Ronja is having fun with the water she was supposed to drink, sucking it out of the bottle and spreading it all over the table

[13:48] <jnthn> :)

[13:48] <jnthn> moritz: OK. Just pushed another few fixes (mostly for .new semantics having changed)

[13:49] <jnthn> just visiting the shop, bbi10 

[13:57] *** fsergot left
[14:02] <jnthn> back

[14:05] *** am0c joined
[14:07] <dalek> rakudo/nom: 2e26f35 | moritz++ | tools/build/NQP_REVISION:

[14:07] <dalek> rakudo/nom: undo bump to nqp 2012.01 until we decide to actually cut the release

[14:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e26f3588c

[14:25] *** MayDaniel joined
[14:29] *** hundskatt left
[14:33] *** MayDaniel left
[14:34] *** fsergot joined
[14:34] <fsergot> nom: %hash<ABC> = 1,2,3;

[14:34] <p6eval> nom 2e26f3: OUTPUT«===SORRY!===␤Variable %hash is not predeclared at line 1, near "<ABC> = 1,"␤»

[14:34] <fsergot> nom: my%hash; %hash<ABC> = 1,2,3;

[14:35] <p6eval> nom 2e26f3:  ( no output )

[14:35] <fsergot> nom: my %hash; %hash<ABC> = 1,2,3;

[14:35] <p6eval> nom 2e26f3:  ( no output )

[14:35] *** Jay_S joined
[14:38] *** shinobicl___ joined
[14:40] *** Jay_S left
[14:42] <fsergot> nom: if 1 ~~ any( 1,2,3 ){ say 1; }

[14:42] <p6eval> nom 2e26f3: OUTPUT«===SORRY!===␤Missing block at line 1, near ""␤»

[14:42] <fsergot> nom: if 1 ~~ any( 1,2,3 ) { say 1; }

[14:42] <p6eval> nom 2e26f3: OUTPUT«1␤»

[14:42] <fsergot> rakudobug?

[14:43] <fsergot> Why there have to be a space between ) and { ? :)

[14:44] <moritz> because otherwise it is parsed as a postcircumfix

[14:44] <moritz> just like the {'foo'} in %hash{'foo'}

[14:44] <moritz> not a bug

[14:44] <moritz> std: if 1 ~~ any( 1,2,3 ){ say 1; }

[14:44] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Missing block at /tmp/zge26wo5ai line 1 (EOF):␤------> if 1 ~~ any( 1,2,3 ){ say 1; }⏏<EOL>␤Parse failed␤FAILED 00:01 111m␤»

[14:49] *** tokuhir__ left
[14:51] <shinobicl___> perl6: role myrole {}; my sub infix:<¬>(myrole $s1, myrole $s2) { say "$s1 ¬ $s2" }; my Str $s1 = "s1" does myrole; my Str $s2 = "s2" does myrole; say $s1 ¬ $s2;

[14:51] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«s1 ¬ s2␤Bool::True␤»

[14:51] <p6eval> ..rakudo 2e26f3: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'infix:<\xAC>' will never work with argument types (Str, Str) (line 1)␤    Expected: :(myrole $s1, myrole $s2)␤»

[14:51] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\172'␤decodeUTF8': bad data: '\172'␤decodeUTF8': bad data: '\172'␤*** Unknown syntactic construct: Syn "does" [Ann (Cxt (CxtItem (mkType "Str"))) (Val (VStr "s1")),Val (VType (mkType "myrole"))]␤    at /tmp/9MRTn_zVWM line 1, column 87-108␤»…

[14:54] <shinobicl___> std: role myrole {}; my sub infix:<¬>(myrole $s1, myrole $s2) { say "$s1 ¬ $s2" }; my Str $s1 = "s1" does myrole; my Str $s2 = "s2" does myrole; say $s1 ¬ $s2;

[14:54] <p6eval> std 40d10f7: OUTPUT«ok 00:01 115m␤»

[14:56] *** donri left
[14:57] <moritz> std doesn't do type checks

[14:57] <moritz> maybe it helps if you don't type-constrain your variables to Str

[14:58] <moritz> does that mean we can't statically analyse role type checks?

[14:58] <shinobicl___> rakudo: role myrole {}; my sub infix:<¬>(myrole $s1, myrole $s2) { say "$s1 ¬ $s2" }; my $s1 = "s1" does myrole; my $s2 = "s2" does myrole; say $s1 ¬ $s2;

[14:59] <p6eval> rakudo 2e26f3: OUTPUT«s1 ¬ s2␤Bool::True␤»

[14:59] <shinobicl___> :D

[15:07] <moritz> our type system isn't really designed for union types, but they sneak in through the backdoor through mixins

[15:12] <TimToady> we tend to use types as our discriminants, and polymorphic containers that allow the types in question

[15:12] <TimToady> what we don't have is polymorphic containers that allow a list of types

[15:13] <TimToady> the old 'my Cat|Dog $catdog'

[15:14] <TimToady> can define a 'subset CatDog of Any where Cat | Dog'

[15:14] <TimToady> that's as close as we get right now

[15:15] <TimToady> subset Tree where Node | Leaf

[15:15] <fsergot> moritz: it is burdensome, isn't it? :)

[15:17] *** dbr left
[15:18] *** dbr joined
[15:18] *** birdwindupbird left
[15:19] <TimToady> subset Union of Subset where *.constraint ~~ Any[Type];  # :)

[15:28] *** bbkr1 joined
[15:41] *** am0c left
[15:44] *** LlamaRider joined
[15:44] *** LlamaRider left
[15:45] *** LlamaRider joined
[15:45] <LlamaRider> \o #perl6

[15:48] <tadzik> hey LlamaRider 

[15:50] <colomon> \o

[15:50] * jnthn back...long skype call :)

[15:50] *** cognominal left
[15:50] <colomon> what's the difference between calling nextwith(blah) and self.my-method-name(blah)?

[15:51] <jnthn> shinobicl___: Think you've spotted a case where the compile time type analysis doesn't know what it doesn't know. Please do ticket it.

[15:51] <colomon> or is it self.Parent::my-method-name(blah)?

[15:52] *** cognominal joined
[15:52] <jnthn> colomon: nextwith goes to the next candidate the current dispatcher knows about

[15:52] <jnthn> colomon: What it means is context sensitive - it depends on what dispatcher you're in (wrap, multi-dispatch, method dispatch)

[15:54] *** dbr left
[15:54] *** dbr joined
[15:56] <LlamaRider> ok, i have safely concluded that the most confusing feature of Perl6 are arrays :) I think 50% of my questions here were about arrays.

[15:56] <LlamaRider> And as you can guess I have a new one "why doesn't this work" :

[15:56] <LlamaRider> rakudo: my @a = [0 xx 3] xx 4; say @a.perl; @a[1][2] = 5; say @a.perl;

[15:56] <p6eval> rakudo 2e26f3: OUTPUT«Array.new([0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0])␤Array.new([0, 0, 5], [0, 0, 5], [0, 0, 5], [0, 0, 5])␤»

[15:57] <LlamaRider> i'm trying to set the second row, third column element of a 2D array

[15:57] <LlamaRider> not sure exactly what is wrong with the approach

[15:58] <LlamaRider> i guess i'm indexing it wrong

[15:59] <colomon> that's a nom bug, isn't it?

[15:59] <colomon> niecza: my @a = [0 xx 3] xx 4; say @a.perl; @a[1][2] = 5; say @a.perl;

[15:59] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«[[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]].list␤[[0, 0, 0], [0, 0, 5], [0, 0, 0], [0, 0, 0]].list␤»

[16:00] <LlamaRider> oO... rakudo , you fail me again :(

[16:01] <LlamaRider> ideas for workarounds are most welcome

[16:02] <jnthn> colomon: It looks like Rakudo just implements the spec as it used to be, before the change to say that xx should thunk its left hand side.

[16:02] *** am0c joined
[16:03] <LlamaRider> accessing works as expected, but setting is somehow off

[16:03] <jnthn> LlamaRider: Well, all that's happening is that it's creating an array [0,0,0] and then repeating the same one 4 times

[16:04] <LlamaRider> oh my

[16:04] <jnthn> LlamaRider: That used to be the way it was spec'd to work, until cases like your one showed it was a bad idea. Then the spec changed, somebody patched Niecza, and nobody patched Rakudo yet.

[16:04] <geekosaur> congratulations, you can emulate python :)

[16:04] <LlamaRider> no references in Perl6 huh? the advent calendar sure was hiding things from me :D

[16:05] <jnthn> Ah, we have an RT ticket about it.

[16:05] <jnthn> So it won't be forgotten.

[16:06] <jnthn> nom: my @a = ([0 xx 3] for ^4); say @a.perl; @a[1][2] = 5; say @a.perl;

[16:06] <p6eval> nom 2e26f3: OUTPUT«Array.new([0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0])␤Array.new([0, 0, 0], [0, 0, 5], [0, 0, 0], [0, 0, 0])␤»

[16:06] *** mj41 left
[16:06] <jnthn> Taht's the easy workaround.

[16:06] <jnthn> *That

[16:08] <LlamaRider> \o/ thanks

[16:09] *** pomysl left
[16:11] <LlamaRider> but this is interesting to dig into

[16:11] *** pomysl joined
[16:11] <LlamaRider> rakudo: my $a = [1,2]; my @b = $a xx 3; my @c = $a.clone xx 3; say @b.perl; say @c.perl;

[16:11] <p6eval> rakudo 2e26f3: OUTPUT«Array.new([1, 2], [1, 2], [1, 2])␤Array.new(1, 2, 1, 2, 1, 2)␤»

[16:11] <LlamaRider> why is clone dereferencing?

[16:14] *** colomon left
[16:29] <moritz> bug

[16:32] <LlamaRider> I need to stay away from arrays, they're dangerous

[16:34] <moritz> that's a bit like saying "I need to stay away from human language; it's ambiguous"

[16:35] <moritz> maybe you should rather stay away from .clone. There's no universal way to clone an arbitrary object

[16:36] * jnthn wonders what clone on an array means with regard to the unevaluated parts

[16:36] <moritz> jnthn: fwiw the mysql tests segfault after test 2

[16:36] *** xinming left
[16:36] <moritz> (MiniDBI, that is)

[16:37] <moritz> that's with your latest nqp patch

[16:38] <LlamaRider> moritz: it's not my fault the arrays are buggy :) 

[16:38] <LlamaRider> or clone for that matter

[16:38] <moritz> LlamaRider: neither is it your fault that human language is buggy :-)

[16:39] <LlamaRider> well, I try to avoid using "this sentence is false" in casual discussions ;D

[16:39] <jnthn> moritz: Yeah, I've found running mysql_connect in a loop

[16:39] <jnthn> segfaults also

[16:39] <jnthn> Running with debug memory allocation libraries complains very quickly about heap corruption.

[16:40] *** xinming joined
[16:45] *** benabik joined
[16:47] *** am0c left
[16:50] *** LlamaRider left
[16:56] *** az5112 joined
[16:59] <az5112> Hello p6 -- how do I reverse a hash in p6 (i.e. exchange keys and values)? I tried %h.reverse but it does sth different.

[16:59] *** MayDaniel joined
[16:59] <flussence> nom: {a=>1, b=>2}.invert.perl.say

[16:59] <p6eval> nom 2e26f3: OUTPUT«(1 => "a", 2 => "b").list␤»

[17:05] <az5112> Thanks,that's better than reverse :)

[17:07] <jnthn> moritz: fwiw, I did manage to get MiniDBI to successfully do an insert into a table. So the issues mostly seem to revolve around tracking down the memory management issues.

[17:07] <az5112> And how do I prevent flattening of a hash when pushing to an array? (i.e. I'd like to get an array of hashes, not a flat list)

[17:08] <jnthn> az5112: Could try .item on the thing you're pushing.

[17:08] <az5112> thanks

[17:19] <moritz> or @array.push: [things here]

[17:34] <cognominal> jnthn, I have a fix for the problem with --target=parse :  https://gist.github.com/1657774

[17:43] <TimToady> or @array.push: $%hash where implemented

[17:46] <TimToady> sorear: I suspect our connection problems are actually related to the solar storm that blew through last night

[17:47] <TimToady> probably some microwave link somewhere...

[17:47] *** bbkr1 left
[17:48] <dalek> nqp: 20df103 | jnthn++ | src/ops/nqp_dyncall.ops:

[17:48] <dalek> nqp: Don't try and calculate needed stack space - it ain't quite that simple. Just do what all the docs do and allow a decent amount.

[17:48] <dalek> nqp: review: https://github.com/perl6/nqp/commit/20df103f80

[17:50] *** MayDaniel left
[18:02] *** Chillance joined
[18:19] *** _dbr joined
[18:21] *** dbr left
[18:27] *** birdwindupbird joined
[18:34] *** GlitchMr42 joined
[18:35] *** icwiener joined
[18:37] *** GlitchMr left
[18:39] *** nebuchadnezzar left
[18:44] <jnthn> moritz: I have latest DBD::mysql doing inserts, selects etc. It runs, but there's some instability.

[18:44] <jnthn> moritz: Annoyingly, the cause of that is proving hard to track down.

[18:48] *** nebuchadnezzar joined
[18:50] *** Tenzen left
[18:51] *** icwiener left
[18:51] *** icwiener joined
[18:58] *** should joined
[18:58] <should> nom: my $str = "abcabcabc";my @x = $str ~~ m:g/abc/;say ~@x

[18:58] <p6eval> nom 2e26f3: OUTPUT«False␤»

[18:59] <benabik> nom: my $str = 'abcabcabc'; my $x = $str ~~ m/abc/; say $x.perl

[18:59] <p6eval> nom 2e26f3: OUTPUT«Match.new(orig => "abcabcabc", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new())␤»

[19:00] <should> hi perl6,why it false

[19:00] <moritz> looks wrong to me

[19:00] <moritz> but I don't know what m:g is supposed to return

[19:00] <moritz> niecza: say ('abcabcabc' ~~ m:g/abc/).perl

[19:01] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«===SORRY!===␤␤Regex modifier g not yet implemented at /tmp/ytVUdzhvN4 line 1:␤------> say ('abcabcabc' ~~ m:g⏏/abc/).perl␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die…

[19:01] <jnthn> nom: my $str = "abcabcabc";my @x = $str.match(/abc/, :g); say ~@x

[19:01] <p6eval> nom 2e26f3: OUTPUT«abc abc abc␤»

[19:01] <should> oh!yhanks moritz

[19:01] <jnthn> should: Using the .match method with :g would seem to work out rather better.

[19:01] <should> thanks jnthn

[19:05] *** Trashlord left
[19:06] <moritz> nom: my $str = "abcabcabc";my @x = $str ~~ m:g/abc/; say @x.perl

[19:06] <p6eval> nom 2e26f3: OUTPUT«Array.new(Bool::False)␤»

[19:06] <moritz> wtbh

[19:08] <should> hi moritz !how to translate the perl code to perl6

[19:08] <should> my $s = "aaaa";my $i;while ($s =~/../g){pos($s) -=1;$i++};say $i

[19:10] <moritz> nom: my $s = 'aaaa'; my $i = $s.chars - 1; say $i

[19:10] <p6eval> nom 2e26f3: OUTPUT«3␤»

[19:10] <moritz> should: no need to do all that stuff just to count how many two-character matches fit into a string :-)

[19:10] <should> i see ! thanks 

[19:14] <should> if I want count 'aaa' repeate how many times?

[19:15] <should> my $s = "aaaacbaaaab";my $i;while ($s =~/aaa/g){pos($s) -=2;$i++};say $i

[19:16] <moritz> nom: my $s = 'aaaacbaaaab'; say $s.match(:overlap, :g, /aaa/).elems

[19:16] <p6eval> nom 2e26f3: OUTPUT«4␤»

[19:16] <should> oh ! thank you !moritz

[19:17] <moritz> nom: my $s = 'aaaacbaaaab'; say $s.match(:overlap, /aaa/).elems

[19:17] <p6eval> nom 2e26f3: OUTPUT«4␤»

[19:17] <sorear> good * #perl6

[19:19] <moritz> \o sorear 

[19:21] *** Trashlord joined
[19:24] *** bkolera left
[19:25] <mikemol> Interesting: http://enki2.tumblr.com/post/16299354659

[19:27] <moritz> jnthn: t/10-mysql.t ......... 1/86 Method 'disconnect' not found for invocant of class 'Any'

[19:27] <mikemol> I'm still chewing, though. Trying to figure out how much if it is trading CPU for memory, and pondering parallelization as a way of handling the NFA. But neither regex nor hard CS are my areas of expertise...

[19:30] <tadzik> more readable version: http://swtch.com/~rsc/regexp/regexp1.html

[19:32] <moritz> mikemol: one thing is that grep only needs to determine whether and where a match occurs, but there is no need to construct match variables like $0, $1

[19:32] <moritz> which means that it's much easier for grep to transfrom the NFA to a DFA

[19:35] <should> nom: my $s = "abcde"; say $0 if $s ~~ /(abc)/

[19:35] <p6eval> nom 2e26f3: OUTPUT«=> <abc>␤␤»

[19:37] <jnthn> moritz: Ah, looks like the test file needs a bunch of database setup to take place first :S

[19:38] <should> Hi moritz~ it's weird why not just output 'abc' ? is it a bug?

[19:39] <moritz> should: no. Use   say ~$0   or say $0.Str  if you want that

[19:39] <benabik> nom: my $s = 'abode'; say ~$0 if $s ~~ /(abc)/

[19:39] <p6eval> nom 2e26f3:  ( no output )

[19:39] <benabik> nom: my $s = 'abcde'; say ~$0 if $s ~~ /(abc)/

[19:39] <p6eval> nom 2e26f3: OUTPUT«abc␤»

[19:40] <should> yes !! thanks moritz.

[19:41] <benabik> By default $0 has more information...

[19:41] <benabik> nom: my $s = 'abcde'; say $0.perl if $s ~~ /(abc)/

[19:41] <p6eval> nom 2e26f3: OUTPUT«Match.new(orig => "abcde", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new())␤»

[19:42] <should> thanks benabik !

[19:46] <az5112> Given the following:    my @arr = [ 1, 2 ], [ 2, 3];       can I flatten the array using map?   my @brr = @arr.map( { ........... } );

[19:47] <moritz> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @>>.flat.perl

[19:47] <p6eval> nom 2e26f3: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name at line 1, near "@>>.flat.p"␤»

[19:47] <moritz> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @arr>>.flat.perl

[19:47] <p6eval> nom 2e26f3: OUTPUT«([1, 2], [2, 3])␤»

[19:47] <moritz> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @arr>>.list.perl

[19:47] <az5112> I tried |@_ but I guess the vertical bar is only for sub arguments.

[19:47] <benabik> I don't think you need the » in there...

[19:47] <p6eval> nom 2e26f3: OUTPUT«([1, 2], [2, 3])␤»

[19:47] <moritz> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @arr.flat.perl

[19:47] <benabik> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @arr.flat.perl

[19:47] <p6eval> nom 2e26f3: OUTPUT«Array.new([1, 2], [2, 3])␤»

[19:47] <moritz> ok, let's try it with map :-)

[19:48] <benabik> Hm.

[19:48] <moritz> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @arr.map( { @($_) 0} ).perl

[19:48] <p6eval> nom 2e26f3: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[19:48] <moritz> nom: my @arr = [ 1, 2 ], [ 2, 3]; say @arr.map( { @($_) } ).perl

[19:48] <p6eval> nom 2e26f3: OUTPUT«(1, 2, 2, 3).list␤»

[19:48] <moritz> better.

[19:52] <az5112> Thanks, @($_) does the trick.

[19:52] <moritz> >> doesn't work because hypers now hyper all the way down

[19:53] * moritz hates that

[19:58] *** birdwindupbird left
[19:59] <benabik> Maybe we need >> and >>>> ?

[20:04] <moritz> +1

[20:05] <moritz> then we can have >> descend just one level, and >>> recursively

[20:05] <mikemol> Would it be plausible to have something act as a breaker, a "don't recurse beyond this point" marker?

[20:10] <moritz> you mean that you pass such a marker to the iterator?

[20:10] <moritz> if yes, that's more the task for a method, not an op

[20:11] *** mj41 joined
[20:16] <should> moritz ~ my @a = [1,2],[3,4];what's diffrence between my @z = @a.map: *.list and my @z = @a>>.list

[20:17] <moritz> should: the difference is that 1) map is lazy, >> is eager 2) >> recurses into arrays, .map does not and 3) >> does not execute in order, map does

[20:19] <should> why diffrent result

[20:19] <moritz> because of 2)

[20:20] *** nebuchadnezzar left
[20:20] <should> thanks moritz

[20:21] <moritz> the >>.list version calls 1.list, 2.list, 3.list, 4.list, not never [1,2].list

[20:22] <should> I see ,thanks!

[20:23] *** nebuchadnezzar joined
[20:24] <moritz> should: in English it is usual to placed the space after a punctuation, not before it. So 'I see, thanks' would be much more readable

[20:25] <should> yes ! moritz! thank you.

[20:27] <moritz> ! is also a punctuation character.

[20:28] <should> moritz! you are a good teacher.

[20:35] * sorear joins the welcoming party

[20:39] <az5112> Is there an array replication operator in perl6?

[20:40] <moritz> yes, xx

[20:40] <moritz> nom: say ('a', 'b') xx 5

[20:40] <p6eval> nom 2e26f3: OUTPUT«a b a b a b a b a b␤»

[20:41] <az5112> Thanks -- I think the book fails to mention that. 

[20:43] <moritz> az5112: care to open a TODO ticket at https://github.com/perl6/book/issues ?

[20:43] <az5112> sure

[20:44] <moritz> release preview at http://moritz.faui2k3.org/tmp/rakudo-2012.01.tar.gz -- please test

[20:46] *** should left
[20:47] <moritz> that tarball doesn't have VERSION bumped :/

[20:47] <moritz> but it won't make any difference for the spectest run

[20:47] <dalek> rakudo/nom: b23e8f0 | moritz++ | tools/build/NQP_REVISION:

[20:47] <dalek> rakudo/nom: bump to NQP 2012.01

[20:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b23e8f0efd

[20:47] <dalek> rakudo/nom: 2b53639 | moritz++ | VERSION:

[20:47] <dalek> rakudo/nom: bump VERSION to 2012.01

[20:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b53639c41

[20:49] <sorear> moritz: what's the state of star these days?

[20:50] <moritz> sorear: it's waiting for the January compiler release, which I'm doing right now

[20:50] <moritz> sorear: ie we plan to do a star release this month

[20:50] <sorear> cool.

[20:52] *** Radvendii joined
[20:52] <sorear> o/ Radvendii

[20:52] <Radvendii> o/

[20:53] <Radvendii> is perl6 compiled into C code like perl5?

[20:53] <cognominal> moritz, can you pull this patch in rakudo?  https://gist.github.com/1657774

[20:53] <sorear> Radvendii: mu

[20:54] <sorear> 1. Perl 6 is purely a language name and doesn't mean a specific iplementation

[20:54] <moritz> 2. there's no Perl 5 compiler that translates into C code

[20:54] <sorear> 2. perl5 (the compiler currently maintained by rjbs) doesn't generate C, although it is written in C

[20:54] <moritz> cognominal: should that go into the release?

[20:54] <jnthn> cognominal: I'm dubious about that patch.

[20:54] <moritz> then "no" :-)

[20:55] <sorear> moritz: there's B::C, although it's unmaintained, hasn't worked at all since 5.8 or so, and never worked particularly *well* to begin with

[20:55] <Radvendii> what about pp or whatever it is... i found some CPAN module that would give you C code out of the perl5 code (at least i thought so...)

[20:55] <cognominal> jnthn, its fixes the problem with --target=parse

[20:55] <jnthn> cognominal: I don't really understand why it would do what it claims to do.

[20:56] <moritz> Radvendii: pp barely embeds the perl5 compiler and the source program and the modules into a single file

[20:56] <jnthn> cognominal: Yes, what's the reason it does this? :)

[20:56] <moritz> Radvendii: similarly rakudo's perl6.exe is also just rakudo's PBC (bytecode) plus an embedded parrot

[20:56] <jnthn> cognominal: Because: token unitstart { <?> }

[20:57] <jnthn> cognominal: Oh...is it because we always have to call that in order to validly parse?

[20:57] <cognominal> with the --target=parse is set the action for unitstart is not called

[20:57] <dalek> star: 68c7b81 | jnthn++ | skel/docs/announce/2012.01:

[20:57] <dalek> star: First draft of the 2012.01 release announcement for Star.

[20:57] <dalek> star: review: https://github.com/rakudo/star/commit/68c7b810aa

[20:57] <Radvendii> moritz: okay... then i guess iw as mistaken

[20:58] <cognominal> and it is necessary to set the context necessary for the dump

[20:58] <jnthn> cognominal: Yeah, I see it now.

[20:58] <tadzik> Star!

[20:58] <Radvendii> Also, how do i define postcircumfix operators for a class. should i declare it as a subroutine that takes the class as the first variable? or is there some way to do it as a method...

[20:58] <cognominal> I don't claim to understand everything it does but it works for me.

[20:58] <jnthn> cognominal: Yeah, I was bothered because I didn't see why it worked. But now I do.

[20:59] <Radvendii> and by subroutine that takes the class as the first variable i mean a standard postcircumfix sub that takes the object as the thing before the postcircumfix

[21:00] <jnthn> Radvendii: method postcircumfix:<[ ]>($index) { }

[21:01] <jnthn> moritz, tadzik: That announcement is very draft. Feel free to twiddle/hack on it.

[21:01] *** _dbr left
[21:01] <Radvendii> and that's called with $obj[$index] or $obj.[$index]?

[21:01] <tadzik> as soon as I finish my filesystem :P

[21:01] <jnthn> Radvendii: Either.

[21:01] <jnthn> Radvendii: Those two are the same really.

[21:02] <Radvendii> jnthn: oh. weird. okay. and what about multi-dimensional arrays? how does $obj[$i][$j] work?

[21:02] *** GlitchMr42 left
[21:03] <benabik> If $obj[$i] returns something you can index, I think.

[21:03] <cognominal> jnthn, indeed the unitstart rule is not called anymore,  so it could be dropped.

[21:03] <jnthn> Radvendii: It does $obj[$i], and then takes the result and does [$j] on it

[21:03] <Radvendii> benabik: oh... that makes sense. sorry.

[21:04] <moritz> jnthn: oops, I wrote an announcement too. Did I forget to push it?

[21:05] <moritz> oh, that's star. Never mind.

[21:05] <jnthn> moritz: Right :)

[21:05] <Radvendii> I've never seen this in the articles I've looked through, but i assume one can do "has @.arr" (ive only seen it with scalars)

[21:06] <benabik> nom: class A { has @.a }; say A.a.perl

[21:06] <p6eval> nom 2b5363: OUTPUT«Cannot look up attributes in a type object␤  in method a at src/gen/CORE.setting:1384␤  in block <anon> at /tmp/W1E7eNpfcy:1␤  in <anon> at /tmp/W1E7eNpfcy:1␤»

[21:06] <jnthn> Yes, you can

[21:06] <benabik> nom: class A { has @.a }; say A.new.a.perl

[21:06] <jnthn> benabik: .new :)

[21:06] <p6eval> nom 2b5363: OUTPUT«Array.new()␤»

[21:06] <benabik> jnthn: Realized I had forgotten it just as I hit enter.

[21:06] <moritz> nom: class A { has @.a handles <at_pos> }; my $a = A.new; $a[0] = 3; say $a[0];

[21:06] <p6eval> nom 2b5363: OUTPUT«3␤»

[21:07] <Radvendii> oh! handles <at_pos> makes the []s fall through to that variable?

[21:08] <moritz> Radvendii: basically [] handles things like slices and Whatever objects, and then calls at_pos

[21:08] <Radvendii> o-oh. i understand.

[21:08] <jnthn> Yes, implemetning at_pos is often far easier :)

[21:08] <moritz> Radvendii: and since postcircumfix:<[ ]> is defined in Any, you can get Array-ish behavior simply by implementing at_pos

[21:09] <moritz> though you should define .elems and .list too

[21:09] <Radvendii> and what does postcircumfix:<{}> call?

[21:09] <jnthn> at_key

[21:10] <Radvendii> is there a way to make all array-like functions fall through to an array variable?

[21:10] <moritz> inherit from Array

[21:11] <moritz> or maybe you can do   has @.a handles Array;

[21:11] <Radvendii> nom: class A { has @.a handles Array }; my $a = A.new; $a[0] = 3; say $a[0];

[21:11] <moritz> nom: class A { has @.x handles Array; }; say A.new.push: <foo bar>;

[21:11] <p6eval> nom 2b5363: OUTPUT«foo bar␤»

[21:11] <p6eval> nom 2b5363: OUTPUT«A.new(a => Array.new(3))␤»

[21:11] *** mj41 left
[21:11] <Radvendii> hahaha

[21:11] <Radvendii> i guess it works...

[21:11] <Radvendii> sweet

[21:11] <moritz> but I don't think that's any better than inheritance

[21:12] <moritz> it just flattens the MRO

[21:12] <Radvendii> MRO?

[21:12] <moritz> method resolution order

[21:13] <Radvendii> if i had the class inherit from Array, how would i tell it which instance variable to use as the array?

[21:15] <Radvendii> nom: class A is Array { }; my $a = A.new; $a[0] = 3; say $a[0];

[21:15] <p6eval> nom 2b5363: OUTPUT«3␤»

[21:15] <Radvendii> ah

[21:15] <Radvendii> i see

[21:16] <benabik> nom: class A is Array { method a() { say self[0] }; my $a = A.new; $a[0] = 1; $a.a

[21:16] <p6eval> nom 2b5363: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[21:16] <benabik> nom: class A is Array { method a() { say self[0] } }; my $a = A.new; $a[0] = 1; $a.a

[21:16] <p6eval> nom 2b5363: OUTPUT«1␤»

[21:17] <Radvendii> i was just about to test that. :P

[21:17] <Radvendii> sweet. i've got my answer

[21:18] <moritz> or you could even write

[21:18] <moritz> class A is Array { }; my @a := A.new;

[21:18] <jnthn> nom: class Harray is Array is Hash { }; my $x = Harray.new; $x<a> = 'hi'; $x[0] = 42; say $x<a>; say $x[0]; # curious if it works...

[21:18] <p6eval> nom 2b5363: OUTPUT«hi␤42␤»

[21:19] <jnthn> Though I guess that's really an Arrash :)

[21:19] <Radvendii> hahaha. i was just about to test hash-arrays

[21:19] <Radvendii> so it stores them separately?

[21:19] <jnthn> You'll need to do a bit more to have that work out well with things like .perl, .list, etc.

[21:20] <moritz> I've updated the tarball at http://moritz.faui2k3.org/tmp/rakudo-2012.01.tar.gz

[21:20] <moritz> now it contains the latest roast commit and correct VERSION

[21:20] <moritz> Radvendii: yes, separately

[21:20] <moritz> spectesting the new tarball, and if everything is fine, I'll tag the release tomorrow

[21:21] <moritz> but now i need to go to bed

[21:21] <moritz> have fun!

[21:21] <jnthn> 'night, moritz 

[21:21] <Radvendii> jnthn: oh... because it wouldnt know whether to use the array or hash for .perl?

[21:21] <jnthn> Radvendii: It'll just follow the MRO and call whichever shows up first in that. So, depends if you wrote "is Hash is Array" or "is Array is Hash"

[21:21] <Radvendii> nom: class Harray is Array is Hash { }; my $x = Harray.new; $x<a> = 'hi'; $x[0] = 42; say $x<a>; say $x.perl;

[21:22] <p6eval> nom 2b5363: OUTPUT«hi␤[42]␤»

[21:22] <Radvendii> or... both?

[21:22] <jnthn> nom: class Harray is Array is Hash { }; say Harray.^mro

[21:22] <p6eval> nom 2b5363: OUTPUT«Harray() Array() List() Hash() EnumMap() Iterable() Cool() Any() Mu()␤»

[21:22] <Radvendii> it prints both...

[21:22] <jnthn> Radvendii: Yes, but with method dispatch the first one wins.

[21:22] <Radvendii> method dispatch?

[21:23] <jnthn> nom: class A { method m() { say 1 } }; class B is A { method m() { say 2 } }; B.m # says 2

[21:23] <p6eval> nom 2b5363: OUTPUT«2␤»

[21:23] <Radvendii> right, but what methods are implimented by both Hash and Array?

[21:24] <jnthn> Radvendii: .perl, .elems, .keys, ... :)

[21:24] <Radvendii> Array has .keys?

[21:24] <jnthn> Sure

[21:24] <Radvendii> nom: my @a = 1,2,3,4; say @a.keys

[21:25] <p6eval> nom 2b5363: OUTPUT«0 1 2 3␤»

[21:25] <Radvendii> everything except the last..?

[21:25] <Radvendii> oh

[21:25] <Radvendii> no

[21:25] <Radvendii> the indicies

[21:25] <jnthn> nom: my @a = <foo bar baz>; for @a.kv -> $idx, $val { say "Index $idx has value $val" }

[21:25] <p6eval> nom 2b5363: OUTPUT«Index 0 has value foo␤Index 1 has value bar␤Index 2 has value baz␤»

[21:25] <jnthn> Yeah. Can be useful.

[21:25] <Radvendii> right

[21:26] <Radvendii> nom: class Harray is Array is Hash { }; my $x = Harray.new; $x<a> = 'hi'; $x[0] = 42; say $x<a>; say $x.keys;

[21:26] <p6eval> nom 2b5363: OUTPUT«hi␤0␤»

[21:26] <Radvendii> so it does both, for all of those...

[21:26] <jnthn> ..does both?

[21:26] <Radvendii> it does the Hash .keys and the Array .keys

[21:26] <jnthn> No

[21:26] <jnthn> It only outputs the 0

[21:27] <jnthn> Not a

[21:27] <jnthn> Swap around Array and Hash in the class decl and see the difference.

[21:27] <Radvendii> oh

[21:27] <Radvendii> i was getting confused because of the say $x<a> statement...

[21:27] <Radvendii> nom: class Harray is Array is Hash { }; my $x = Harray.new; $x<a> = 'hi'; $x[0] = 42;say $x.keys;

[21:27] <p6eval> nom 2b5363: OUTPUT«0␤»

[21:27] <Radvendii> nom: class Harray is Hash is Array { }; my $x = Harray.new; $x<a> = 'hi'; $x[0] = 42;say $x.keys;

[21:27] <p6eval> nom 2b5363: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:5460␤  in block <anon> at /tmp/zMGJ6WT1y3:1␤  in <anon> at /tmp/zMGJ6WT1y3:1␤»

[21:29] <Radvendii> ..?

[21:29] <jnthn> oh, curious. :)

[21:29] <jnthn> I'm...not quite sure. :)

[21:29] <Radvendii> nom: class Harray is Hash is Array { }; my $x = Harray.new; $x<a> = 'hi'; $x[0] = 42;

[21:29] <p6eval> nom 2b5363: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:5460␤  in block <anon> at /tmp/aOX0MJnyKi:1␤  in <anon> at /tmp/aOX0MJnyKi:1␤»

[21:29] <jnthn> nom: class Harray is Hash is Array { }; my $x = Harray.new;

[21:29] <Radvendii> it has to do with the storing, not the printing...

[21:29] <p6eval> nom 2b5363:  ( no output )

[21:30] <jnthn> Yeah. Still odd.

[21:30] <jnthn> Guessing there's some unfortunate conflict somewhere.

[21:30] <Radvendii> nom: class Harray is Hash is Array { }; my $x = Harray.new; $x[0,1] = <hi 12>; say $x<hi>;

[21:30] <p6eval> nom 2b5363: OUTPUT«Cannot assign to a non-container␤  in method STORE at src/gen/CORE.setting:4110␤  in block <anon> at /tmp/908VnZBsOq:1␤  in <anon> at /tmp/908VnZBsOq:1␤»

[21:31] <jnthn> If you actually wanted to do something like this, you'd be better off doing delegation anyway, fwiw. 

[21:31] <Radvendii> delegation?

[21:31] <jnthn> Radvendii: has @.array handles 'at_pos'; has %.hash handles 'at_key';

[21:31] <jnthn> Radvendii: And then decide what .perl and .elems and so on should do :)

[21:31] <Radvendii> someone was saying that that wasn't a good idea...

[21:32] <Radvendii> they said something about flattening the MDO

[21:32] <Radvendii> or something...

[21:32] <Radvendii> MRO

[21:33] <jnthn> Radvendii: If you want to create something with *both* hash and array semantics, it's a better way to go. If you just want to inherit from and tweak one of them, then yeah, inheritnace probably is neater.

[21:33] <jnthn> Radvendii: They're different mechanisms with different use cases.

[21:33] <Radvendii> okay... but what does it mean to flatten the MRO?

[21:35] <jnthn> Radvendii: It means that you aren't inheriting from as many things. Many people dislike deep inheritance hierarchies, though inheriting from Array probably isn't a problematic case.

[21:36] <Radvendii> okay.

[21:36] <Radvendii> well, i am implementing a Harray (harrash?) so i guess i'll do the handles method

[21:36] <jnthn> Radvendii: If you're doing both then yeah, that's the way I'd go.

[21:38] <Radvendii> also, if i want it to do mostly the same thing as at_pos on an instance array, except also do something else, i should impliment the at_pos method and call @.arr.at_pos() and then do whatever else, right?

[21:40] <jnthn> Radvendii: Yeah. Be aware that at_pos returns a container, so if you want to allow modification of the underlying array then you'll need to be a little careful.

[21:40] <jnthn> (Like, label your at_pos method with "is rw"

[21:40] <jnthn> )

[21:41] *** mauror left
[21:41] * jnthn away for a bit

[21:48] <cxreg> not to nag, but it has been over 100 days since the last rakudo.org post, an update would be cool

[21:50] <jnthn> cxreg: Next Rakudo Star release is iminent (within next couple of days), we'll certainly post about that there.

[21:51] <sorear> o/ jnthn

[21:52] <jnthn> o/-ish, sorear 

[21:52] * jnthn only now and then wondering past the keyboard :)

[21:54] *** cooper left
[21:55] *** icwiener left
[21:55] *** icwiener joined
[22:03] <cxreg> jnthn: right, cool

[22:09] <sorear> hmm...

[22:09] <sorear> I am now thinking of having a Mu.immutable() method

[22:10] <sorear> because Pair, Parcel, etc are immutable iff their children are

[22:13] *** cooper joined
[22:22] *** kaare_ left
[22:23] *** Radvendii left
[22:25] <sorear> niecza: say $?CORE::ORIG

[22:25] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«Potential difficulties:␤  Unrecognized variable: $?CORE::ORIG at /tmp/wy7DsPotwk line 1:␤------> say ⏏$?CORE::ORIG␤␤Any()␤»

[22:25] <sorear> niecza: say CORE::<$?ORIG>

[22:25] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«Any()␤»

[22:25] <sorear> niecza: say $?ORIG

[22:25] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«say $?ORIG␤»

[22:26] <sorear> niecza: say MY::<$?ORIG>

[22:26] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«Any()␤»

[22:33] <sorear> perl6: say { :a, :b }.values.WHAT

[22:33] <p6eval> pugs b927740: OUTPUT«a  1␤b     1␤␤*** Not a keyed value: VBool True␤    at /tmp/HwsRVb_5Hd line 1, column 1 - line 2, column 1␤»

[22:33] <p6eval> ..rakudo 2b5363, niecza v13-327-g5a9c36f: OUTPUT«List()␤»

[22:34] *** az5112 left
[22:39] *** LlamaRider joined
[22:40] * jnthn -> rest

[22:41] *** ksi joined
[22:46] *** techskilled joined
[22:50] <shinobicl___> jnthn: ticket sent

[22:56] *** Radvendii joined
[22:57] <Radvendii> o/

[22:58] <Radvendii> what is the "super" entity in classes?

[23:00] <shinobicl___> perl6: role MyRole is Date {}; my $var1 does MyRole; $var1 = "2011-12-12"; my Str $var2 = $var1.succ; say $var1.perl; say $var2.perl;

[23:00] <p6eval> niecza v13-327-g5a9c36f: OUTPUT«===SORRY!===␤␤Unhandled trait Date for this context at /tmp/EBDz6QeDsb line 1:␤------> role MyRole is Date ⏏{}; my $var1 does MyRole; $var1 = "2011-␤␤Trait does not available on variables at /tmp/EBDz6QeDsb line 1:␤---…

[23:00] <p6eval> ..rakudo 2b5363: OUTPUT«"2011-12-12"␤"2011-12-13"␤»

[23:00] <p6eval> ..pugs b927740: OUTPUT«*** Unknown syntactic construct: Syn "does" [Ann (Decl SMy) (Var "$var1"),Val (VType (mkType "MyRole"))]␤    at /tmp/HrYrPRUv9z line 1, column 25-45␤»

[23:04] *** icwiener left
[23:11] *** techskilled left
[23:11] <sorear> Radvendii: 'super' is not, and afaik never has in Perl, meaningful in any context

[23:12] *** LlamaRider left
[23:12] <sorear> Radvendii: 'SUPER' was used to call overriden methods in 5 and old 6, but that functionality is part of nextsame() now

[23:13] <Radvendii> okay. i didn't end up needing it in any case. what i do need is a way to do something like "has @.a handles <at_pos>" and then also do something else when at_pos() get's called.

[23:13] <Radvendii> i tried overwriting at_pos and calling @.a.at_pos($i) from within it, but that doesn't seem to work...

[23:17] <shinobicl___> nom: role MyRole is Date {}; my Str $s1 does MyRole; say $s1.WHAT; my Date $s2  = $s1; say $s2.WHAT;

[23:17] <p6eval> nom 2b5363: OUTPUT«Str()␤Type check failed in assignment to '$s2'; expected 'Date' but got 'Str'␤  in block <anon> at /tmp/p_P1ZVXc_8:1␤  in <anon> at /tmp/p_P1ZVXc_8:1␤»

[23:18] <sorear> Radvendii: you might need to remove handles, if you're going to write your own at_pos

[23:18] <shinobicl___> maybe i'm going to far asking that to the type system, but in another case, $s1 seems to get the 'Date' behavoir when i apply the role to it

[23:18] <Radvendii> the issue is that when i do "return @.a.at_pos($i)" it returns the number, which is a readonly value

[23:19] <sorear> Radvendii: then you should make your definiton of at_pos 'is rw'

[23:19] <Radvendii> so i say method at_pos($i) is rw?

[23:20] <sorear> yes

[23:20] <Radvendii> that doesn't seem to help...

[23:20] *** LlamaRider joined
[23:22] <Radvendii> nom: class A {has @.b; method at_pos($i) is rw { return @.b.at_pos($i) } }; my A $a .= new; $a[0]=1; say $a[0];

[23:22] <p6eval> nom 2b5363: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <anon> at /tmp/AN0norus94:1␤  in <anon> at /tmp/AN0norus94:1␤»

[23:26] *** LlamaRider left
[23:26] <Radvendii> any ideas?

[23:26] <benabik> nom: my @a = 1; @a.at_pos(0) = 2; say @a[0]

[23:26] <p6eval> nom 2b5363: OUTPUT«2␤»

[23:26] <sorear> Radvendii: try not using return?

[23:28] <sorear> shinobicl___: don't use "s1" does role

[23:28] <sorear> shinobicl___: you wanted 'but'

[23:30] <Radvendii> and... that does the trick

[23:30] <Radvendii> thanks sorear 

[23:30] <sorear> nom: foo

[23:30] <p6eval> nom 2b5363: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&foo' called (line 1)␤»

[23:30] <sorear> nom: return-rw

[23:30] <p6eval> nom 2b5363: OUTPUT«Attempt to return outside of any Routine␤  in block <anon> at /tmp/8S1Xu2Z4i8:1␤  in <anon> at /tmp/8S1Xu2Z4i8:1␤»

[23:30] <sorear> you might be able to use that instead, if you have to bail in the middle

[23:31] <Radvendii> okay. sweet.

[23:32] <shinobicl___> rakudo: role MyRole is Date {}; my Str $s1 but MyRole; say $s1.WHAT; my Date $s2 = $s1; say $s2.WHAT;

[23:33] <p6eval> rakudo 2b5363: OUTPUT«Str()␤Type check failed in assignment to '$s2'; expected 'Date' but got 'Str'␤  in block <anon> at /tmp/1OH3wxBec8:1␤  in <anon> at /tmp/1OH3wxBec8:1␤»

[23:34] <benabik> nom: my @a = 1; sub f { return-rw @a.at_pos(0) }; f() = 2; say @a[0]

[23:34] <p6eval> nom 2b5363: OUTPUT«2␤»

[23:35] <Radvendii> i didnt know dashes were legal characters in subroutines... hm.

[23:35] <benabik> nom: sub they_are() {...}

[23:35] <p6eval> nom 2b5363:  ( no output )

[23:36] <sorear> nom: sub this'is'legal'too() { ... }

[23:36] <p6eval> nom 2b5363:  ( no output )

[23:36] <sorear> - and ' are interpreted as identifiers only if they are flanked by alnums without spaces

[23:37] <benabik> std: sub foo'() { ... }

[23:37] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Malformed block at /tmp/gWTx0cgg72 line 1:␤------> sub foo⏏'() { ... }␤    expecting any of:␤     new name to be defined␤ routine_def␤    trait␤Parse failed␤FAILED 00:01 107m␤»

[23:37] <awwaiid> sorear, flankes you say? so I can't do....

[23:37] <awwaiid> what benabik just did

[23:37] <benabik> nom: sub foo'() { ... }

[23:37] <p6eval> nom 2b5363: OUTPUT«===SORRY!===␤Malformed block at line 1, near "'() { ... "␤»

[23:38] <benabik> Pity.  My haskell-self is sad

[23:38] <awwaiid> my ocaml-self feels the same

[23:38] <sorear> right, if you want U+02B9 MODIFIER LETTER PRIME you have to explicitly write that

[23:38] <awwaiid> tend to use f' to wrap f where f' is the recursive version that needs an iterator

[23:38] <Radvendii> alright, i know this is kind of silly, since i was just trying to avoid this, but when i say "has @.b handles <at_pos>" it makes it read-write. even if i say "has @!b handles <at_pos>". how do i make it only let you access the elements, not write to them (without declaring a separate method at_pos?

[23:38] <sorear> ASCII ' won't DWIM here :|

[23:39] <sorear> nom: sub fooʹ() { ... }

[23:39] <p6eval> nom 2b5363:  ( no output )

[23:39] <awwaiid> looks awefully similar :)

[23:39] <awwaiid> and by awefully... I mean awefully

[23:39] <Radvendii> sub foo`() { ... }

[23:39] <Radvendii> nom: sub foo`() { ... }

[23:39] <p6eval> nom 2b5363: OUTPUT«===SORRY!===␤Malformed block at line 1, near "`() { ... "␤»

[23:39] <Radvendii> oh, so apostrophe and prime doesnt work

[23:40] <awwaiid> you gotta use that unicode prime that sorear used, not backtick

[23:40] <Radvendii> what's the character you used?

[23:40] <geekosaur> backtick won't work, no

[23:40] <benabik> .u ʹ

[23:40] <phenny> U+02B9 MODIFIER LETTER PRIME (ʹ)

[23:40] <awwaiid> sorear used U+02B9

[23:40] <Radvendii> ah

[23:41] *** PacoAir left
[23:41] <awwaiid> two characters that render the same and act differently are a recipe for pain. But that's where we're all heading I suppose.

[23:42] <geekosaur> see also punycode

[23:42] <awwaiid> I guess their not quite the same... 'ʹ'ʹ'ʹ'ʹ'ʹ

[23:42] <Radvendii> and when splat (*) does like 4 different things you're in big trouble... :P

[23:42] <awwaiid> well as long as the splat consistently does those things then I'll be ok

[23:43] <awwaiid> like () doing grouping vs parameters

[23:43] <benabik> nom: (* * *)(*)

[23:43] <p6eval> nom 2b5363: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in whatevercode <anon> at /tmp/C9lcpmJYzo:1␤  in block <anon> at /tmp/C9lcpmJYzo:1␤  in <anon> at /tmp/C9lcpmJYzo:1␤»

[23:43] <benabik> Awh

[23:43] <benabik> nom: (* * *)(*, *)

[23:43] <p6eval> nom 2b5363: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu:U \$v, Mu %_!)␤␤  in method Numeric at src/gen/CORE.setting:649␤  in sub infix:<*> at src/gen/CORE.setting:2236␤  in whatevercode <anon> at /tmp/laWwCXY9uW:1␤  in block <anon> …

[23:54] <Radvendii> (* ** *).WHAT

[23:54] <benabik> WhateverCode()

[23:54] <Radvendii> nom: (* ** *).WHAT

[23:54] <p6eval> nom 2b5363:  ( no output )

[23:54] <Radvendii> lol

[23:54] <Radvendii> nom: say (* ** *).WHAT

[23:54] <p6eval> nom 2b5363: OUTPUT«WhateverCode()␤»

[23:54] <Radvendii> nice

[23:55] <benabik> Radvendii: told ya.  ;-)

[23:55] *** ksi left
[23:55] <Radvendii> nom: (* ** * * *)(1,2,3)

[23:55] <p6eval> nom 2b5363:  ( no output )

[23:55] <Radvendii> nom: say (* ** * * *)(1,2,3)

[23:55] <p6eval> nom 2b5363: OUTPUT«3␤»

[23:55] <Radvendii> WIN

[23:55] <Radvendii> :

[23:55] <Radvendii> :P

[23:56] <Radvendii> nom: say (* ** * * * ** * * *)(0,0,0,0,0)

[23:56] <p6eval> nom 2b5363: OUTPUT«0␤»

[23:59] <sorear> have you seen the 'starry obfu'?

