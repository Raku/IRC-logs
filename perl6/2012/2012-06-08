[00:20] *** Guest34330 left
[00:20] *** fgomez left
[00:20] <diakopter> r: .Str.say for ('abcdefg' ~~ /(a) [ (bc) (d) | .* (ef) ] .* (g)/).list

[00:20] <p6eval> rakudo 81402b: OUTPUT«a␤ef␤use of uninitialized value of type Any in string context  in block <anon> at /tmp/Nlit50o0Kp:1␤␤␤g␤»

[00:21] <diakopter> well, that's different from before at least

[00:27] *** fgomez joined
[00:33] *** xinming joined
[00:36] *** xinming_ left
[00:44] *** lichtkind left
[00:50] *** stephenlb joined
[00:55] <[Coke]> if gen-parrot checks out a fresh copy, there's no need to realclean. minor time sink.

[01:03] *** spaceships left
[01:09] *** drbean left
[01:11] *** drbean joined
[01:12] *** [particle] joined
[01:15] *** [particle]1 left
[01:15] *** tokuhiro_ joined
[01:18] *** libertyprime left
[01:19] *** libertyprime joined
[01:39] *** drbean left
[01:39] *** drbean joined
[01:54] <dalek> rakudo/nom: 6ab416b | pmichaud++ | src/ (4 files):

[01:54] <dalek> rakudo/nom: Get binder to recognize QRPAs; let nqp::istype and nqp::islsit inherit from nqp.

[01:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6ab416bb56

[02:09] *** drbean left
[02:10] *** scott_ joined
[02:10] *** scott_ is now known as Guest24159

[02:11] *** drbean joined
[02:22] *** fgomez left
[02:30] *** am0c joined
[02:31] *** fgomez joined
[02:39] *** drbean left
[02:41] *** drbean joined
[02:43] *** tyatpi left
[03:03] *** tokuhiro_ left
[03:17] *** xinming left
[03:21] *** xinming joined
[03:25] *** qelseio joined
[03:26] <qelseio> hello

[03:31] <sorear> Hello.

[03:39] *** drbean left
[03:40] *** drbean joined
[03:42] *** libertyprime left
[03:42] *** libertyprime joined
[03:56] *** libertyprime left
[03:57] *** libertyprime joined
[04:01] *** libertyprime left
[04:01] *** libertyprime joined
[04:08] <sjohnson> hi

[04:09] *** drbean left
[04:10] *** drbean joined
[04:14] *** adu joined
[04:16] <adu> what does "Method 'match' not found for invocant of class 'String'" mean?

[04:16] *** qelseio left
[04:16] <diakopter> context?

[04:17] <adu> I'm calling parse() on a grammar

[04:17] <diakopter> do you have any inline code in the rules?

[04:17] <diakopter> (I don't remember from when I read through your xml grammar)

[04:18] <adu> this is a new grammar :)

[04:18] <sorear> adu: It means you, or something you called, tried to invoke .match() on a raw Parrot String object

[04:18] <sorear> raw Parrot Strings don't have a .match method.  hence, it failed.

[04:18] <adu> i suppose I should paste

[04:19] <adu> http://pastebin.com/xSpeq9r7

[04:20] <sorear> Why is that error message confusing?  How can it be improved?

[04:20] <adu> first of all, I can't find any inline code

[04:20] <adu> secondly, I never call a .match method explicitly, so I don't know what else to look for

[04:20] <sorear> Did you see that it has a backtrace?

[04:21] <sorear> hmm.  I am getting confrontational.  I should drop this.

[04:21] <adu> there is no backtrace

[04:21] <diakopter> hugme: hug all

[04:21] * hugme hugs all

[04:21] <adu> :)

[04:21] <sorear> what, no backtrace? :|

[04:21] <adu> indeed

[04:22] * diakopter decides to run it

[04:22] <adu> I have a file with "say Go::Grammar.parse(@*ARGS[0]);" in it

[04:22] <adu> and "use Go::Grammar;"

[04:22] <adu> that's how I'm running it

[04:23] <diakopter> what are you supplying to args

[04:23] <diakopter> go go gadget grammar

[04:23] *** am0c left
[04:23] <adu> diakopter: '1'

[04:24] <adu> since I'm using TOP { <literal> } it should match <int_lit>

[04:24] <diakopter> haha

[04:24] <diakopter> I get Error while reading from file: Malformed UTF-8 string

[04:24] <adu> hmm

[04:24] <diakopter> my text editor must have failed

[04:24] <diakopter> when pasting

[04:24] <adu> I have some funky sym<<bla>>

[04:24] *** cognominal_ left
[04:25] <sorear> adu: try "" ~ @*ARGS[0]

[04:25] <adu> hmm nope

[04:26] *** cognominal joined
[04:27] <diakopter> sigh. the utf8 encoding thing is better, but now rakudo is failing to parse the file at line l.  itz Cornfuzzled

[04:28] <sorear> .u l

[04:28] <phenny> U+006C LATIN SMALL LETTER L (l)

[04:28] <diakopter> ok. I give up. switching to linux rakudo

[04:29] <diakopter> sorear: oops :)

[04:31] <diakopter> sigh. even more fail.

[04:31] <diakopter> I blame pastebin.

[04:34] <diakopter> adu: well, your use of ** is incorrect

[04:34] <diakopter> at statement_list

[04:35] <diakopter> ** is for (un)bounded repetition with a range

[04:35] <adu> that might be it

[04:35] <diakopter> use ]* % ';'

[04:35] <adu> I commented out everything until it gave a different error

[04:35] <diakopter> except I tried it, and even more fail

[04:35] <adu> ws should be \s*

[04:35] <adu> not \s

[04:35] <adu> hehe :)

[04:36] <sorear> diakopter: what adu has is the old syntax, rakudo ought to still support it

[04:36] <sorear> diakopter: also, x**y is x+ % y, not x* % y

[04:37] <adu> thanks for helping :)

[04:37] <adu> it works now

[04:38] <adu> this will be my third Go parser

[04:38] <diakopter> sorear: did you test that or are you just saying "rakudo ought to still support it" because... why?

[04:39] <adu> evolving languages should freeze a feature set at some point, what features get frozen are a matter of debate

[04:39] <diakopter> r: say "5,3" ~~ /\d ** ","/

[04:39] <p6eval> rakudo 6ab416: OUTPUT«===SORRY!===␤Quantifier quantifies nothing at line 2, near " \",\"/"␤»

[04:39] *** drbean left
[04:39] <adu> I'm quite happy with %

[04:39] <diakopter> n: say "5,3" ~~ /\d ** ","/

[04:39] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** "," as separator; nowadays please use atom+ % "," at /tmp/47fC34_vex line 1:␤------> say "5,3" ~~ /\d ** ","⏏/␤␤#<match from(0) to(3) text(5,3) pos([].list) named({}.hash)>␤»

[04:40] <diakopter> sorear: see rakudo's error above

[04:40] <diakopter> mr confrontational; lulz :P

[04:40] <adu> lol

[04:41] *** drbean joined
[04:43] <dalek> nqp: 6be8ad9 | pmichaud++ | / (2 files):

[04:43] <dalek> nqp: Fix count overrun bug in QRPA.splice.

[04:43] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6be8ad9fd5

[04:47] <diakopter> adu: I reproduced your Method 'match' not found for invocant of class 'String' error

[04:47] <diakopter> pmichaud: parrot leakage here I think

[04:50] <adu> diakopter: i see

[04:51] <diakopter> adu: for amusement I'll try to golf the error

[04:51] <sorear> 'String' is a PMC type, not a Perl 6 type

[04:51] <sorear> it *has* to be Parrot leakage.

[04:51] <diakopter> oh! it's failing while parsing the input file

[04:52] <diakopter> the grammar file

[04:52] <diakopter> bug

[04:52] <sorear> oh?

[04:53] <diakopter> r: https://gist.github.com/2893670

[04:53] <p6eval> rakudo 6ab416: OUTPUT«===SORRY!===␤Method 'match' not found for invocant of class 'String'␤at /tmp/e_WwfLP01C:162␤»

[04:54] <diakopter> now to golf it

[04:58] <diakopter> rule expression_list { [ <statement> | <?> ]+ % ';' }

[04:58] <diakopter> is killing it

[04:58] <diakopter> how, I have no diea

[04:58] <diakopter> idea

[04:58] <diakopter> rule statement_list { [ <statement> | <?> ]+ % ';' }

[04:58] <diakopter> is just fine

[04:58] *** thou joined
[04:59] <diakopter> wth

[05:00] <diakopter> oh.

[05:00] <diakopter> expression_list is in there twice

[05:00] <diakopter> r: grammar G { rule a { }; rule a { } }

[05:00] <p6eval> rakudo 6ab416: OUTPUT«===SORRY!===␤Method 'match' not found for invocant of class 'String'␤at /tmp/1gme0LaT2i:1␤»

[05:01] <diakopter> there you go, golfed

[05:01] <diakopter> where's masakbot when you need him

[05:02] <adu> hmm

[05:02] <adu> that is strange

[05:02] <diakopter> adu: you have too many expression_list

[05:03] <adu> so i doo

[05:03] <adu> oops

[05:04] *** birdwindupbird joined
[05:13] <moritz> \o

[05:13] <diakopter> moritz: bug above

[05:13] <diakopter> howdy

[05:13] <moritz> jnthn++ # blog

[05:13] <moritz> bugs before waking up :/

[05:16] <diakopter> it's minor

[05:16] <diakopter> quiet easy fix I'm sure

[05:23] <pmichaud> dalek flood coming up

[05:24] <diakopter> pmichaud: watch this

[05:24] <diakopter> r: grammar G { rule a { }; rule a { } }

[05:24] <p6eval> rakudo 6ab416: OUTPUT«===SORRY!===␤Method 'match' not found for invocant of class 'String'␤at /tmp/edQM_CEFt3:1␤»

[05:24] <diakopter> little fun one adu just found

[05:24] <pmichaud> diakopter: sure, looks like issue with rule method definitions

[05:25] * diakopter wants to see dalek flood

[05:25] <pmichaud> here it comes....

[05:25] *** dalek left
[05:25] <diakopter> hee

[05:25] <pmichaud> bye dalek :-)

[05:25] * moritz waves

[05:25] <sorear> that was me deactivating it for safety :p

[05:26] *** dalek joined
[05:26] *** ChanServ sets mode: +v dalek

[05:26] <pmichaud> anyway, that merges in the new MapIter code.  I still have some improvements to make, but I can do it in the nom branch instead of subbranches

[05:27] <moritz> pmichaud++

[05:27] <pmichaud> there are also still a couple of pieces that are too eager, but I can track them down and clean them up also

[05:28] <diakopter> r: grammar A { token a { }; token a { } }

[05:28] <p6eval> rakudo 6ab416: OUTPUT«===SORRY!===␤Method 'match' not found for invocant of class 'String'␤at /tmp/TaBvwFfZ6b:1␤»

[05:28] * diakopter looks at https://github.com/rakudo/rakudo/commit/204acefc5f29f4e9e64972d997fbe7e70fead616

[05:34] <pmichaud> anyway, time for sleep here... will hack more tomorrow

[05:42] <adu> sweet!

[05:42] <adu> http://pastebin.com/hJWLrmsV

[05:45] <adu> diakopter: oh, so ** had nothing to do with it, it was only the repeated definition?

[05:45] <diakopter> yeah, but ** doens't work either

[05:45] <diakopter> for me

[05:45] <adu> so both

[05:46] <adu> right that was an error in my code as well

[05:46] <adu> anyways, the grammar is working quite well now

[05:46] <diakopter> why can I not find a link to create a rakudobug

[05:46] <sorear> because you can't create rakudobugs using the Web

[05:47] <sorear> send mail to [email@hidden.address]
[05:47] <sorear> any content will be automatically (subject to greylisting) be filed as a bug against rakudo

[05:49] *** xinming left
[05:49] *** xinming joined
[05:50] *** cognominal_ joined
[05:51] *** xinming left
[05:53] *** cognominal left
[05:55] *** xinming joined
[05:55] *** pupoque left
[06:00] *** kaleem joined
[06:09] *** drbean left
[06:11] *** drbean joined
[06:28] <adu> hmm

[06:28] <adu> how do I code these rules? http://golang.org/ref/spec#Semicolons

[06:30] <diakopter> study how STD.pm6 does it with terminator

[06:30] <diakopter> there is a special case for following }

[06:31] <adu> hmm

[06:39] <adu> diakopter: on line 4907?

[06:39] *** drbean left
[06:39] *** drbean joined
[06:40] <jnthn> morning o/

[06:41] <jnthn> pmichaud++ # MapIter merge

[06:42] <adu> morning :)

[06:57] *** fridim_ joined
[06:57] *** kresike joined
[06:57] <kresike> good morning all you happy perl6 people

[06:59] *** stephenlb left
[07:00] <sorear> heya, kresike 

[07:00] <kresike> sorear, o/

[07:09] *** drbean left
[07:09] *** drbean joined
[07:12] *** cognominal___ joined
[07:12] *** adu left
[07:14] *** cognominal_ left
[07:23] *** adu joined
[07:27] *** GlitchMr joined
[07:31] *** brrt joined
[07:40] *** thou left
[07:42] *** NamelessTee joined
[07:47] *** fgomez left
[07:52] <diakopter> lol. on github just now: Great repository names are short and memorable. Need inspiration? How about finna-be-octo-dangerzone.

[07:57] *** cognominal___ left
[07:58] *** cognominal joined
[08:03] <GlitchMr> I actually wonder how many people followed GitHub suggestions :P

[08:03] <GlitchMr> It's obvious joke, but still

[08:03] <GlitchMr> freezing-ninja

[08:03] <GlitchMr> ok...

[08:04] *** fridim__ joined
[08:04] <GlitchMr> ... actually... I think I will name my Clippy for PHP "fuzzy-ninja"

[08:06] <diakopter> the joke wasn't obvious to me; I thought it was algorithm fail

[08:07] <GlitchMr> None of those names is serious

[08:07] <GlitchMr> are*

[08:07] <diakopter> is

[08:07] <diakopter> None is singular :)

[08:07] <GlitchMr> ... well... whatever

[08:07] *** adu left
[08:08] <diakopter> because none is short for not one

[08:09] *** drbean left
[08:11] *** drbean joined
[08:13] <GlitchMr> Repositories names aren't that important (aside of username.github.com one), but it's easier to say "check repository hello-world" than "check repository jgdsigjeiowf-vrejhjg-erhjjdewr"

[08:15] <cosimo> GlitchMr: thanks for your pull requests

[08:15] <GlitchMr> I'm going to send pull requests like that to every repository :P

[08:15] <cosimo> I see automation possibilities :)

[08:16] *** cognominal_ joined
[08:18] <tadzik> GlitchMr: glad you're doing that :)

[08:18] <GlitchMr> I'm currently at "gge"

[08:18] <tadzik> it would make sense to drop panda support for the repo-url thing once all the important stuff is updated

[08:19] <GlitchMr> https://github.com/masak/gge/pull/1

[08:19] <GlitchMr> :)

[08:19] *** cognominal left
[08:20] <tadzik> GlitchMr++

[08:20] <GlitchMr> lol... GitHub for Windows stopped working

[08:22] <GlitchMr> It works like this: "fork", "clone in Windows", create branch "panda-badge", fix "META.info", make commit, send pull request

[08:25] <GlitchMr> Oh, and publish

[08:25] <GlitchMr> I forgot to mention that

[08:26] *** cognominal_ left
[08:27] *** cognominal joined
[08:27] <GlitchMr> https://github.com/perl6/Pod-To-HTML/

[08:28] <GlitchMr> I guess that I can skip pull request on that :P

[08:30] *** not_gerd joined
[08:30] <not_gerd> hello, #perl6

[08:31] <not_gerd> is it possible to compile .pm -> .pir from within a script (ie without spawning a new Rakudo process)?

[08:34] <brrt> euh...

[08:34] <brrt> this is a moritz question

[08:35] <not_gerd> ;)

[08:35] <brrt> but, yeah, probably, if you can get access to the rakudo compiler object

[08:36] <brrt> which is what the compreg() opcode does for parrot

[08:36] <brrt> but, i'm not sure rakudo gives you access

[08:36] <not_gerd> well, there's always pir::

[08:37] * not_gerd needs to figure out how  pir::compreg__Ps('perl6') works

[08:37] <not_gerd> or rather, if it does what I want

[08:37] <brrt> probably, yes

[08:37] <brrt> but i'm not sure if the registered compiler is rakudo or perl6

[08:38] <brrt> compreg returns either NULL or a HLLCompiler

[08:38] <not_gerd> pir::compreg__Ps('perl6') return a Perl6::Compiler

[08:39] <not_gerd> ^returns

[08:39] *** drbean left
[08:40] <brrt> oh, that will work

[08:40] <brrt> can you find the relevant documentation?

[08:40] <not_gerd> brrt: probably

[08:40] *** drbean joined
[08:41] <brrt> great :-)

[08:43] <not_gerd> just hope that they are up to date ;)

[08:55] <moritz> you'll probably need to read the sources

[08:56] <not_gerd> Type check failed in assignment to '$comp'; expected 'Mu' but got 'Perl6::Compiler'

[08:57] <moritz> try binding

[08:57] <moritz> r: my $comp := pir::compregs__Ps('perl6')

[08:57] <p6eval> rakudo 809b8f: OUTPUT«use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤===SORRY!===␤error:imcc:syntax error, unexpected PREG, expecting …

[08:57] <moritz> r: my $comp := pir::compreg__Ps('perl6')

[08:57] <p6eval> rakudo 809b8f:  ( no output )

[08:57] <moritz> you must emulate the stuff that's in src/main.nqp

[08:58] <brrt> no synopsis for getting the compiler yet? 

[08:58] <moritz> ie create an @*END_PHASERS dynamic var, then invoke $comp.command_line

[08:59] <not_gerd> my current problem is that I can't use Perl6::Grammar (which I assume is NQP) from Perl6

[09:01] <not_gerd> I don't know how to get at hll-config as well, as it seems to be lexical

[09:05] <moritz> r: my $comp := pir::compreg__Ps('perl6'); my $args := nqp::list; nqp::push($args, 'lib/Test.pm'); $comp.command_line($args, :encoding<utf8>);

[09:05] <p6eval> rakudo 809b8f: OUTPUT«> Land der Berge, Land am Strome,␤CHECK FAILED:␤Undefined routine '&Berge' called (line 1)␤Undefined routine '&Strome' called (line 1)␤Undefined routine '&am' called (line 1)␤Undefined routine '&Land' called (lines 1, 1)␤Undefined routine '&der' called (line 1)␤> L…

[09:06] <moritz> wow, that seems to have invoked the REPL or something

[09:06] <moritz> strike

[09:07] <moritz> the first element in the array to command_line is supposed to be the executable name

[09:08] <brrt> thats dangerous stuff, really

[09:08] <moritz> not_gerd: https://gist.github.com/2894632

[09:08] <moritz> not_gerd: that's only a first shot, you still need to separate the lists for the END phasers and so on

[09:09] <moritz> not_gerd: but you don't need to 'use' Perl6::Grammar etc. separately, because main.nqp already does that

[09:09] <tadzik> moritz: why's there both filename.pl and A.pm?

[09:09] *** drbean left
[09:09] <moritz> tadzik: because HLL::Compiler expects the executable name at index 0

[09:10] <not_gerd> moritz: figured that out as well - it seems the compiler object that compreg returns is already set up

[09:10] *** drbean joined
[09:10] <tadzik> okay

[09:11] <moritz> and with   RAKUDO_MODULE_DEBUG=1 ./perl6 -I. -e 'use A;' I could verify that it actually loads A.pir

[09:12] <tadzik> it that much faster compared to run("perl6 bla bla")?

[09:12] <tadzik> I guess startup time isn't that painful nowadays

[09:14] <not_gerd> tadzik: I'm still working on a dwimmy ufo version

[09:15] <not_gerd> I'm making it portable by not using shell built-ins but perl6 code

[09:15] <tadzik> I see

[09:15] <not_gerd> so compiling to pir means starting a perl6 process which immediately shells out to perl6

[09:15] <not_gerd> and that's... not that fast ;)

[09:15] <tadzik> yeah. I guess Panda could use that too

[09:16] <tadzik> and if it did, we could quickly test if it doesn't break anything

[09:16] <not_gerd> now, I need a replacement for rm -rf

[09:16] <tadzik> and if that is possible, then we could be pretty close to Pod module

[09:16] <not_gerd> how do I get a list of files in a directory?

[09:16] <tadzik> not_gerd: doesn't Shell::Command have it?

[09:17] <tadzik> https://github.com/tadzik/perl6-File-Tools/blob/master/lib/Shell/Command.pm it's close to having it :)

[09:17] <moritz> not_gerd: dir()

[09:17] <moritz> r: say dir()

[09:17] <p6eval> rakudo 809b8f: OUTPUT«star src .bashrc nom-inst1 test3.pl .profile t nom-inst2 nom-inst examples Makefile .gitignore lib test2.pl rakudo p1 VERSION simple-tests .perlbrew std obj main.pl .lesshst nom niecza test.pl .cpanm .bash_logout run TODO Pugs.hs dalek LICENSE .ssh License-MS-PL.tx…

[09:17] *** aindilis` joined
[09:18] <jnthn> Mmmm... .ssh

[09:18] <jnthn> ;)

[09:19] <tadzik> ew, evalbot allows dir()? :)

[09:19] <moritz> it does. And the ssh keys are public anyway :-)

[09:19] <moritz> r: say dir('.ssh/')

[09:19] <p6eval> rakudo 809b8f: OUTPUT«authorized_keys␤»

[09:19] *** stepnem_ joined
[09:20] <jnthn> ah, no private key in there. Phew :)

[09:20] *** not_gerd left
[09:20] *** sunnavy_ joined
[09:21] *** jtpalmer_ joined
[09:21] *** pnu joined
[09:21] *** clkao_ joined
[09:21] *** stepnem left
[09:21] *** aindilis left
[09:21] *** sunnavy left
[09:21] *** jtpalmer left
[09:21] *** pnu_ left
[09:21] *** stepnem_ is now known as stepnem

[09:22] *** not_gerd joined
[09:22] *** sunnavy_ is now known as sunnavy

[09:23] <brrt> say cat('.ssh/authorized_keys')

[09:23] *** not_gerd_ joined
[09:24] *** not_gerd_ left
[09:25] <moritz> r: say slurp(.ssh/authorized_keys')

[09:25] <p6eval> rakudo 809b8f: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')'␤»

[09:25] <moritz> r: say slurp('.ssh/authorized_keys')

[09:25] <p6eval> rakudo 809b8f: OUTPUT«ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDPEkT8qXSWd/OFKrJAM8pEW0gmpvDkvcY0vdOdez+EKXGdsbhz/NnmVcjOfJo11VbZAn3ADlj4W+O3z1ocduCAPiUNAF9o4x9d0tUaSHtqZQZf5ltP60Zvc+Q7liMwmfnBhRSvErJghj/ZTsJdk55cONLkkp0mxkTXjm9bEWjCzn1JAzNcOcv0qnkvaBu/42+SQy652Q5E4AE6HHwKkPIQATUVArlb4DqKF…

[09:25] *** cognominal_ joined
[09:26] <brrt> ah, i didn't dare to do that

[09:26] <moritz> it's not a secrect

[09:27] <moritz> if you can deduce private SSH keys from public keys you'll have a lot more interesting targets than feather3 :-)

[09:28] *** cognominal left
[09:28] <brrt> fair enough

[09:29] <brrt> if i could do that, i'd be in jail or have millions, whichever comes first

[09:29] <tadzik> why not both? :)

[09:32] <jnthn> Because spending your millions in jail is hard work? :)

[09:33] <tadzik> ;)

[09:33] <kresike> well he didn't say anything about spending the money :) 

[09:33] <brrt> getting in jail while you have millions is hard wor, too

[09:33] <brrt> s/wor/work/

[09:33] <brrt> but thats another discussion entirely

[09:36] <jnthn> lunch &

[09:39] *** drbean left
[09:40] *** drbean joined
[09:59] *** daxim joined
[10:00] <dalek> ecosystem: 71caa9d | GlitchMr++ | SHELTER/ (6 files):

[10:00] <dalek> ecosystem: Update old modules to fit current module specifications.

[10:00] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/71caa9db23

[10:04] <tadzik> I think most of those old modules should be removed from the ecosystem

[10:04] <tadzik> (some already are)

[10:08] <GlitchMr> lol... GitHub for Windows randomly crashes

[10:08] <GlitchMr> That newest update was buggy

[10:09] *** brrt1 joined
[10:10] *** brrt left
[10:11] *** am0c joined
[10:12] <GlitchMr> ok

[10:12] <GlitchMr> Unless I have missed some module, after everybody will accept Pull Request, every module should have panda badge

[10:13] <tadzik> great

[10:13] <tadzik> GlitchMr++

[10:14] <not_gerd> portable version of my dwimmy ufo reimplmentation: https://gist.github.com/2891292

[10:15] <GlitchMr> https://github.com/GlitchMr

[10:15] <GlitchMr> also my repository list is full of forked Perl 6 modules

[10:15] <GlitchMr> :P

[10:15] <not_gerd> for some reason, it has extremely slow startup

[10:16] <not_gerd> might be the multi MAIN dispatch...

[10:16] <not_gerd>  time ./ufo --foo

[10:16] <not_gerd> ^that's a failed dispatch, and it takes nearly 2 seconds

[10:16] <GlitchMr> And after that, we could remove those panda badges... until something will change again :P

[10:17] <tadzik> not_gerd: may it be that you're doing many things in mainline, before MAIN appears

[10:19] <not_gerd> Stage parse: 1.317

[10:19] <moritz> not_gerd: multi dispatch generally isn't slow

[10:20] <moritz> (compared to many other operations in rakudo, that is)

[10:20] <not_gerd> t's the parsing of the script...

[10:21] <not_gerd> time to rebuild the toolchain and see if it helps...

[10:22] <wolverian>  

[10:22] <moritz> I think we should throw out proto

[10:22] <moritz> it has bitrotted, and panda works and is maintained

[10:22] *** JimmyZ joined
[10:24] <tadzik> +1

[10:24] *** Guest24159 left
[10:25] <moritz> (and it was a prototype anyway :-)

[10:25] <dalek> ecosystem: 941013f | moritz++ | META.list:

[10:25] <dalek> ecosystem: remove proto

[10:25] <dalek> ecosystem: 

[10:25] <dalek> ecosystem: it has bitrotted, and thorougly replaced by panda

[10:25] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/941013fd3b

[10:25] <moritz> so

[10:25] <moritz> my exception grant is finished

[10:26] <moritz> my ufo rewrite is finished and waits for review

[10:26] <tadzik> congratulations!

[10:26] <moritz> the question is: what to hack on next?

[10:26] <moritz> I'll throw around some ideas

[10:26] <tadzik> if I were you I'd take a look at P5 interop

[10:26] <moritz> 1) focus on the book and other documentaiton effort (not too much fun)

[10:27] <moritz> 2) more DBIish work (maybe add niecza compatible backends?)

[10:27] <JimmyZ> thread!

[10:27] <phenny> JimmyZ: 04 Jun 16:38Z <TimToady> tell JimmyZ http://irclog.perlgeek.de/perl6/2012-06-04#i_5680738 is right behavior, except that the compiler should really warn about "Useless use of 3 in a sink context"

[10:28] <moritz> 3) precompilation stuff (though jnthn kinda seems a better fit for that; OTOH he seems a better fit for nearly all topics... :-)

[10:28] <moritz> 4) start to partially port Mojo to p6

[10:29] <JimmyZ> or Dancer?

[10:29] <moritz> 5) trace module loading, so that compile time excpetions can show the module loading backtrace

[10:30] <moritz> p5 interop and threads aren't topics for me

[10:30] <moritz> mojo vs dancer: I happen to have used Mojolicious

[10:31] * JimmyZ doesn't know what's the difference between Mojo and Dancer

[10:31] *** stepnem left
[10:31] <moritz> and it has zero dependencies, so it's a much better target for porting

[10:31] <tadzik> Dancer limits itself to what Mojolicious::Lite provides

[10:31] <JimmyZ> Dancer has some dependencies?

[10:31] <tadzik> yes

[10:32] <moritz> JimmyZ: http://deps.cpantesters.org/?module=Dancer&perl=5.16.0&os=any+OS

[10:32] <tadzik> small ones, I happen to live without them when working on Bailador (so far)

[10:33] *** stepnem joined
[10:33] <moritz> the other reason is that Mojo provides lots of basic web stuff that we need anyway at some point (cookies, HTTP classes, DOM tree handling etc.)

[10:34] <moritz> anyway, those were just some ideas

[10:34] <moritz> and I feel torn

[10:35] <not_gerd> Stage parse: 1.610

[10:35] <moritz> documentation would probably the most beneficial, but least fun, and rather frustrating

[10:35] <JimmyZ> I'm +1 to 4 _ and 5 )

[10:35] <not_gerd> another regression in parsing speed :(

[10:35] <JimmyZ> 4 ) and 5 )

[10:37] <moritz> not_gerd: is that after updating to newest rakudo?

[10:37] <not_gerd> moritz: yes

[10:38] <moritz> not_gerd: iirc jnthn said he had some ideas for optimizations

[10:39] <tadzik> moritz: Mojo seems a worthwhile goal. I keep finding myself reimplementing lots of HTTP stuff for various projects, so having them collected, well-written and maintained will be awesome

[10:39] <moritz> "Web depends on HTTP::Daemon, which was not found in the ecosystem"

[10:39] <moritz> eeks

[10:39] <tadzik> it's been like this for ages :)

[10:39] <not_gerd> is it possible to precompile scripts?

[10:40] <not_gerd> naive approach fails with Missing or wrong version of dependency 'src/Perl6/World.pm'

[10:40] * brrt1 thinks it is, perl6 --target=pir or something?

[10:40] <moritz> not_gerd: no

[10:41] <GlitchMr> nr: m:g/42/

[10:41] <p6eval> rakudo 809b8f: OUTPUT«No such method 'match' for invocant of type 'Any'␤  in block <anon> at /tmp/T6999f0ZHt:1␤␤»

[10:41] <p6eval> ..niecza v18-6-ge52d6c3: OUTPUT«===SORRY!===␤␤Regex modifier g not yet implemented at /tmp/F2IOGCToyB line 1:␤------> m:g⏏/42/␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/nie…

[10:42] <GlitchMr> Should I use .subst() hack for niecza?

[10:42] <GlitchMr> 'string'.subst(/(42)/, { @arr.push(0) }, :g)

[10:43] <GlitchMr> ... or perhaps I should use grammars... yeah... that's the solution

[10:51] <colomon> GlitchMr: if you just want to find all the examples of a regex in a string, use .comb

[10:51] <colomon> ie 'string'.comb(/42/)

[10:52] <GlitchMr> Works :)

[10:53] *** stepnem left
[10:54] <GlitchMr> Also, does Perl 6 contain something like .charAt() in JavaScript?

[10:54] <GlitchMr> 'abc'.charAt(0) // returns 'a' in JavaScript

[10:54] <colomon> rn: say "This is a test of comb".comb(/<[aeiou]>./).perl

[10:54] <p6eval> rakudo 809b8f: OUTPUT«("is", "is", "a ", "es", "of", "om").list␤»

[10:54] <p6eval> ..niecza v18-6-ge52d6c3: OUTPUT«["is", "is", "a ", "es", "of", "om"].list␤»

[10:55] <not_gerd> GlitchMr: you mean a borken implementation of Unicode?

[10:55] <not_gerd> hopefully, not

[10:55] <GlitchMr> No

[10:55] <GlitchMr> I just mean character at position

[10:55] <GlitchMr> But not using UTF-16 :P. I want full Unicode support for that.

[10:56] <colomon> GlitchMr: note that comb by default returns strings, if you want Match objects from it you need to use the :match argument

[10:56] <GlitchMr> I could use .substr(), but I don't know fast it would be. And it probably wouldn't be idiomatic.

[10:56] *** crab2313 joined
[10:56] <colomon> GlitchMr: for charAt, use substr

[10:59] *** stepnem joined
[11:02] <GlitchMr> nr: my @a = 1, 2; my @b = 3, 4; @b ,= @a; print @a

[11:02] <p6eval> rakudo 809b8f, niecza v18-6-ge52d6c3: OUTPUT«12»

[11:03] <GlitchMr> nr: my @a = 1, 2; my @b = 3, 4; @b ,= @a; print @b

[11:03] <p6eval> rakudo 809b8f, niecza v18-6-ge52d6c3: OUTPUT«3412»

[11:03] <GlitchMr> :)

[11:03] <GlitchMr> ...

[11:03] <GlitchMr> But actually... I think I should use .push() instead of ,= operator

[11:04] <tadzik> it's probably more idiomatic, yes

[11:09] *** fridim__ left
[11:09] *** drbean left
[11:11] *** drbean joined
[11:18] *** brrt1 left
[11:30] *** kaleem left
[11:30] *** JimmyZ left
[11:30] *** JimmyZ joined
[11:32] *** crab2313 left
[11:36] <colomon> nr: my @a = 1, 2; my @b = 3, 4; @b ,= @a; print @b.perl

[11:36] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«[3, 4, 1, 2].list»

[11:36] <p6eval> ..rakudo 809b8f: OUTPUT«Array.new(3, 4, 1, 2)»

[11:36] *** cosimo left
[11:36] * colomon is kind of charmed by ,=

[11:39] *** am0c left
[11:39] *** drbean left
[11:40] *** drbean joined
[11:42] *** am0c joined
[11:42] *** plobsing left
[11:43] *** plobsing joined
[11:44] *** fridim_ left
[11:45] <jnthn> Yes, altnfa merge slowed parsing down a bit

[11:45] <jnthn> Correctness first, then speed. I improved correctness. Now I can focus on speed. :)

[11:45] *** skids left
[11:46] <jnthn> moritz: 5 would be cool; 4 also. 3 - feel free to golf any pre-comp issues but beyond that point I can probably deal with them faster.

[11:46] <jnthn> moritz: Another possible task is versioned modules

[11:47] <jnthn> moritz: Also, trying to work out the import lists for require

[11:47] <jnthn> But there's spec issues there...

[11:50] <jnthn> I will also try to wire up some stuff for a :Perl5 attribute on regexes in the next few days, for anybody who wants to hack in this area.

[12:00] *** tyatpi joined
[12:06] *** att joined
[12:09] *** drbean left
[12:11] *** drbean joined
[12:16] *** cognominal_ left
[12:21] *** crab2313 joined
[12:22] *** cognominal joined
[12:23] *** _jaldhar left
[12:23] *** am0c left
[12:36] *** sergot joined
[12:37] <sergot> hi o/ ! :)

[12:37] <kresike> hi sergot o/

[12:39] *** drbean left
[12:40] *** xinming left
[12:40] *** grondilu joined
[12:41] *** drbean joined
[12:41] <grondilu> p6: module life { constant meaning is export = 42 }; import life; say meaning;

[12:41] <p6eval> rakudo 809b8f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&meaning' called (line 1)␤»

[12:41] <p6eval> ..niecza v18-6-ge52d6c3: OUTPUT«===SORRY!===␤␤Action method statement_control:import not yet implemented at /tmp/6njLz1Q4jO line 1:␤------> nt meaning is export = 42 }; import life⏏; say meaning;␤␤Unhandled exception: Unable to resolve method statement…

[12:41] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "is"␤    expecting ":" or "("␤    at /tmp/f7WBHMHEDW line 1, column 32␤»

[12:41] <grondilu> can't I export constants?

[12:41] <moritz> grondilu: not yet

[12:42] <moritz> jnthn: import lists for require also sounds itneresting

[12:43] <grondilu> also, I finally managed to overwrite &infix:<+> but it's kind of weird.  I must export one of the multi, but if I write a proto then I can not add normal integers anymore.

[12:44] <grondilu> r: module A { class Foo {}; multi infix:<+>(Foo, Foo) { Foo } }; say Foo + Foo; say 1 + 1;

[12:44] <p6eval> rakudo 809b8f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Foo' called (lines 1, 1)␤»

[12:44] <moritz> right; if you write a proto, it replaces the existing infix:<+>

[12:45] <grondilu> but the weird thing is that all the multi get exported, even if I wrote 'is export' on only one. 

[12:45] <grondilu> r: module A { class Foo {}; multi infix:<+>(Foo, Foo) is export { Foo }; multi infix:<*>(Foo, Foo) { Foo } }; import A; say A::Foo + A::Foo; say 1 + 1;

[12:45] <p6eval> rakudo 809b8f: OUTPUT«Foo()␤2␤»

[12:46] <grondilu> r: module A { class Foo {}; multi infix:<+>(Foo, Foo) is export { Foo }; multi infix:<*>(Foo, Foo) { Foo } }; import A; say A::Foo + A::Foo; say A::Foo * A::Foo; say 1 + 1;

[12:46] <p6eval> rakudo 809b8f: OUTPUT«Foo()␤use of uninitialized value of type Foo in numeric context  in block <anon> at /tmp/q61YjDR6NH:1␤␤use of uninitialized value of type Foo in numeric context  in block <anon> at /tmp/q61YjDR6NH:1␤␤0␤2␤»

[12:46] <grondilu> ahh

[12:46] <grondilu> I don't get it.  I had a different result yesterday.

[12:48] <grondilu> r: module A { class Foo {}; multi infix:<+>(Foo, Foo) is export { Foo }; multi infix:<*>(Foo, Foo) is export { Foo } }; import A; say A::Foo + A::Foo; say 1 + 1;

[12:48] <p6eval> rakudo 809b8f: OUTPUT«Foo()␤2␤»

[12:48] <moritz> erm, what? it picked up the correct candidate for + but the wrong one for * ?

[12:48] <grondilu> seems so.  Weird, huh?

[12:49] <grondilu> hang on.  I forgot the '*'

[12:49] <moritz> r: module A { class Foo { }; multi infix:<*>(Foo, Foo) is export { Foo }; import A; say A::Foo * A::Foo

[12:49] <grondilu> r: module A { class Foo {}; multi infix:<+>(Foo, Foo) is export { Foo }; multi infix:<*>(Foo, Foo) is export { Foo } }; import A; say A::Foo + A::Foo, A::Foo  1 + 1;

[12:49] <p6eval> rakudo 809b8f: OUTPUT«===SORRY!===␤Cannot import symbol '&infix:<*>' from package 'A', since it already exists in the lexpad␤»

[12:49] <p6eval> rakudo 809b8f: OUTPUT«===SORRY!===␤Confused␤at /tmp/_QYXCv7P0Z:1␤»

[12:49] <grondilu> r: module A { class Foo {}; multi infix:<+>(Foo, Foo) is export { Foo }; multi infix:<*>(Foo, Foo) is export { Foo } }; import A; .say for A::Foo + A::Foo, A::Foo * A::Foo, 1 + 1;

[12:49] <p6eval> rakudo 809b8f: OUTPUT«use of uninitialized value of type Foo in numeric context  in block <anon> at /tmp/y6GIC55bsN:1␤␤use of uninitialized value of type Foo in numeric context  in block <anon> at /tmp/y6GIC55bsN:1␤␤Foo()␤0␤2␤»

[12:49] <moritz> r: module A { class Foo { }; multi infix:<*>(Foo, Foo) is export { Foo } }; import A; say A::Foo * A::Foo

[12:49] <p6eval> rakudo 809b8f: OUTPUT«Foo()␤»

[12:50] <moritz> r: module A { class Foo { }; multi infix:<+>(Foo, Foo) { Foo }; multi infix:<*>(Foo, Foo) is export { Foo } }; import A; say A::Foo * A::Foo

[12:50] <p6eval> rakudo 809b8f: OUTPUT«Foo()␤»

[12:53] <PerlJam> good * #perl6

[12:55] <sergot> o/ :)

[12:55] <moritz> r: require Test <&ok &done>;

[12:55] <p6eval> rakudo 809b8f: OUTPUT«===SORRY!===␤require with argument list not yet implemented. Sorry. ␤at /tmp/3OrIxqx4HG:1␤»

[12:56] <pmichaud> good morning, #perl6

[12:56] <jnthn> pmichaud! \o/

[12:57] *** cognominal left
[12:57] *** cognominal_ joined
[12:59] <grondilu> my Digest module (git@github.com:grondilu/libdigest-perl6.git) has two sub modules:  Digest::sha256 and Digest::rmd160.  How should I name the repo to conform to the ecosystem.  Would digest-sha256-rmd160 be fine?

[12:59] <GlitchMr> nr: print (@("\x00" .. "\x1F")).perl

[12:59] <p6eval> rakudo 809b8f: OUTPUT«(timeout)»

[12:59] <p6eval> ..niecza v18-6-ge52d6c3: OUTPUT«("\x[0]", ).list»

[13:00] <moritz> grondilu: there's no mandatory naming scheme

[13:01] <GlitchMr> How can I make byte ranges?

[13:01] <moritz> 'modulename' or 'perl6-modulename' seems rather common

[13:01] <moritz> r: say (0..0x1F)>>.chr.perl

[13:01] <p6eval> rakudo 809b8f: OUTPUT«("\x[0]", "\x[1]", "\x[2]", "\x[3]", "\x[4]", "\x[5]", "\x[6]", "\x[7]", "\b", "\t", "\n", "\x[b]", "\x[c]", "\r", "\x[e]", "\x[f]", "\x[10]", "\x[11]", "\x[12]", "\x[13]", "\x[14]", "\x[15]", "\x[16]", "\x[17]", "\x[18]", "\x[19]", "\x[1a]", "\x[1b]", "\x[1c]", "\…

[13:01] <GlitchMr> :)

[13:01] <GlitchMr> I like this solution

[13:03] <GlitchMr> @characters.push((.substr(0, 1).ord .. .substr(3, 4).ord)».chr);

[13:03] <GlitchMr> Seems to work...

[13:03] <pmichaud> moritz: (what to work on)   I've been wondering what it would take to start a 'perldoc -f' equivalent.

[13:04] <grondilu> r: say chrs ^0x20

[13:04] <p6eval> rakudo 809b8f: OUTPUT«␀ ␤

[13:04] <tadzik> grondilu: how about Digest?

[13:04] <GlitchMr> Wait...

[13:04] <GlitchMr> there is chrs function?

[13:04] <GlitchMr> Nice :)

[13:05] <moritz> pmichaud: it's probably not too hard to get a basic version started

[13:05] <moritz> pmichaud: but it needs to be extended to methods too

[13:05] <grondilu> tadzik: there is no 'perl6' reference in 'Digest', but I guess I could just name it p6-digest.

[13:05] <pmichaud> moritz: aye, methods too

[13:05] <grondilu> GlitchMr: yes, there is.  And there is also ords.

[13:05] <tadzik> grondilu: please don't put references to Perl 6 in module names

[13:06] <tadzik> there's no point in naming everything Perl6-Something in Perl 6 module directory

[13:06] <grondilu> tadzik: but it could mess up with my other repos on Github :(

[13:06] <moritz> tadzik: but it might make sense for a repo name if you want a 'Digest' module in another programming language

[13:06] <PerlJam> pmichaud, moritz: a smarter-than-perldoc that doesn't need -f to find functions/methods would be nice.

[13:06] <tadzik> oh, repo name

[13:07] <Woodi> afternoon ppls

[13:07] <tadzik> I though we're talking about the module name

[13:07] <tadzik> in META.info and so

[13:07] <moritz> PerlJam: the problem with smart things is that they tend to go wrong when there are multiple things with the same name

[13:07] <tadzik> grondilu: I used to name my module repos perl6-Something on github

[13:07] <Woodi> is maybe Storable or something with freeze to disk/load later builtinto p6 ?

[13:08] <grondilu> Woodi that would be great.  And also File::Map.

[13:08] * Woodi cpanning

[13:08] <tadzik> grondilu: so regarding your question: there's no policy regarding repo names and the ecosystem. Ecosystem does not really care about repo names, only module names, as I noted

[13:08] *** Psyche^ joined
[13:09] <PerlJam> moritz: so it needs to be even smarter!  :)

[13:09] <grondilu> tadzik: ok so I'll keep 'libdigest-perl6' since I don't know how to rename a repo :)

[13:09] <tadzik> grondilu: looks debianish :)

[13:10] <tadzik> grondilu: there's some option in the repo admin tools for renaming a repo, iirc

[13:10] <tadzik> I know I renamed Pies to panda at some point in time

[13:10] <Woodi> OpenBSD use p5-Curses-UI :)

[13:11] <[Coke]> moritz++ # mojo

[13:11] <pmichaud> anyway, some sort of 'perldoc -f' tool would be hugely useful for people

[13:11] <grondilu> 'perldoc -f' would be awesome.

[13:12] <Woodi> and I thinked that simple modules/dirty/fast hacks or pp versions could be Simple::... 

[13:12] <estrai> 'perldoc -f'++

[13:12] <grondilu> s/perldoc/perl6doc/

[13:12] *** Patterner left
[13:12] *** Psyche^ is now known as Patterner

[13:12] <tadzik> perldoc -f would be relly easy once we can get Pod into the settign

[13:13] <tadzik> and I think it belongs aside perl6 --doc, not as a separate tool

[13:14] <pmichaud> I'm wondering if we really want Pod in the setting, though.

[13:14] <Woodi> can .perl for use in storable is good idea ? (or one possible maybe ?)

[13:14] *** xinming joined
[13:14] <grondilu> Woodi: it's better than nothing.

[13:14] <[Coke]> jnthn: what diagnostic tools do you use to make rakudo faster?

[13:14] <Woodi> k, thanx

[13:14] <pmichaud> (pod in setting)  seems like we'd want documentation improvements to happen more rapidly, at least initially.

[13:15] *** thou joined
[13:15] <tadzik> more rapidly than what?

[13:15] <[Coke]> (smarter than perldoc -f: grok)

[13:15] <pmichaud> than someone needing to edit the source code files to update the docs.

[13:15] <tadzik> true

[13:16] <pmichaud> as far as compile speed goes, we could certainly fix tools/build/gen-cat.pl to strip pod from the src/core/ files as it's building CORE.setting

[13:17] <tadzik> why would we have it there then?

[13:17] <pmichaud> well, there is something to be said for having the documentation near the thing being documented

[13:18] <pmichaud> and when pod-in-setting works, then we'd have .WHY working on the builtins

[13:18] <tadzik> not if we strip it for compile speed, as you said

[13:18] <pmichaud> I meant as a temporary step until pod-in-setting is plausible

[13:18] <tadzik> okay

[13:19] <pmichaud> afk in 10, in case anyone has questions/comments for me :)

[13:28] <pmichaud> afk

[13:39] *** drbean left
[13:40] *** spider-mario joined
[13:42] *** drbean joined
[13:45] <TimToady> nr: "[" ~~ /(\[)/; say $0

[13:45] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«#<match from(0) to(1) text([) pos([].list) named({}.hash)>␤»

[13:45] <p6eval> ..rakudo 809b8f: OUTPUT«q[[]␤␤»

[13:48] *** colomon left
[13:50] *** alvis`` joined
[13:52] *** p6eval left
[13:52] *** not_gerd left
[13:52] *** zb left
[13:53] *** Util left
[13:53] *** cognominal_ left
[13:53] *** gfldex left
[13:53] *** zb joined
[13:53] *** mathw joined
[13:53] *** Util joined
[13:54] *** odoacre left
[13:54] *** gfldex joined
[13:54] *** sorear joined
[13:54] *** aindilis` left
[13:54] *** alvis` left
[13:55] *** cognominal joined
[13:55] *** charsbar____ joined
[13:58] *** cognominal left
[13:58] *** p6eval joined
[13:58] *** ChanServ sets mode: +v p6eval

[13:59] *** awwaiid joined
[14:00] *** cognominal joined
[14:01] *** att left
[14:01] *** odoacre joined
[14:01] *** colomon joined
[14:02] <moritz> r: say $*PROGRAM_NAME

[14:02] <p6eval> rakudo 809b8f: OUTPUT«/tmp/57BaluvP_n␤»

[14:09] *** snearch joined
[14:09] *** drbean left
[14:10] *** drbean joined
[14:11] *** fridim_ joined
[14:16] *** fridim_ left
[14:17] *** PacoAir joined
[14:27] <grondilu> Check out my perl6 #bitcoin library: [email@hidden.address]   Most of elliptic curve and addresses dealing is done.  I'll soon work on database and network.

[14:28] <tadzik> wow

[14:29] <tadzik> grondilu: you probably want to add dependencies to META.info

[14:32] * grondilu doesn't know much about META.info

[14:32] <grondilu> I'll fix that.

[14:32] <tadzik> grondilu: you may want to read http://wiki.perl6.org/Create%20and%20Distribute%20Modules

[14:33] <pmichaud> oh cool, the new MapIter code is 20% faster than 2012.05   (for 1..500000 { ... })

[14:33] <tadzik> cool

[14:33] <pmichaud> 5.37 sec vs 6.14 sec

[14:33] <tadzik> pmichaud++

[14:33] <pmichaud> oh, maybe that's only 15%

[14:33] <pmichaud> r:  say (6.14-5.37)/6.14

[14:33] <p6eval> rakudo 809b8f: OUTPUT«0.125407␤»

[14:33] <pmichaud> 12.5%

[14:33] <moritz> still an improvement

[14:34] *** skids joined
[14:34] <pmichaud> plus less greedy

[14:34] *** colomon left
[14:34] <pmichaud> okay, I can live with that.  now for more improvements :)

[14:34] <tadzik> what is the most costly thing about it, lack of sink context?

[14:34] <felher> pmichaud++

[14:35] <pmichaud> I'm not sure what the greatest cost is atm.  lack of sink context probably increases memory usage but I doubt it's affecting the speed much

[14:35] <pmichaud> (modulo gc issues)

[14:36] <moritz> have you tried --profile?

[14:36] <pmichaud> not yet

[14:36] <pmichaud> I have another minor optimization spectesting now

[14:37] *** ggoebel left
[14:39] <kresike> bye all

[14:39] <tadzik> bye kresike 

[14:39] *** kresike left
[14:41] <moritz> r: say join ', ', reverse <a b c> X~ 1..3

[14:41] <p6eval> rakudo 809b8f: OUTPUT«c3, c2, c1, b3, b2, b1, a3, a2, a1␤»

[14:42] *** ggoebel joined
[14:42] <moritz> r: say join ', ', <a b c> XR~ 1..3

[14:42] <p6eval> rakudo 809b8f: OUTPUT«␤»

[14:42] <moritz> r: say join ', ', <a b c> X~ 1..3

[14:42] <p6eval> rakudo 809b8f: OUTPUT«␤»

[14:43] <moritz> r: say join ', ', (<a b c> X~ 1..3)

[14:43] <p6eval> rakudo 809b8f: OUTPUT«a1, a2, a3, b1, b2, b3, c1, c2, c3␤»

[14:43] <moritz> r: say join ', ', (<a b c> XR~ 1..3)

[14:43] <p6eval> rakudo 809b8f: OUTPUT«1a, 2a, 3a, 1b, 2b, 3b, 1c, 2c, 3c␤»

[14:44] <grondilu> I'm surprised you needed parens.

[14:45] *** JimmyZ left
[14:45] <moritz> list ops like X have loser precedence than ,

[14:45] <grondilu> I thought X~ would have the same precedence as ~

[14:45] *** snearch left
[14:46] *** snearch joined
[14:47] <pmichaud> how does the output of --profile work?  do I feed that to kcachegrind or something?

[14:47] <moritz> pmichaud: like that, yes

[14:47] <tadzik> I think so

[14:47] <jnthn> Open it in kcachegrind

[14:47] <moritz> perl6 --profile yourprog.pl 2>profile.log

[14:48] <moritz> kcachegrind profile.log

[14:48] * pmichaud installs kcachegrind again

[14:48] *** colomon joined
[14:50] *** mikemol joined
[14:51] <moritz> the unless nqp::isconcrete($!reified) { ... } block in ListIter.reify seems to use up most of the CPU time

[14:51] <jnthn> What? :)

[14:51] <pmichaud> well, that's the list handler, so it makes sense

[14:51] <jnthn> isconcrete is a flag check...

[14:51] <pmichaud> not the flag check, the block

[14:51] *** JimmyZ joined
[14:51] <jnthn> oh!

[14:52] <pmichaud> okay, I have some optimizations for that block

[14:52] *** thelazydeveloper joined
[14:52] <pmichaud> however, it's interesting that the cost of that block is not coming from any of the various methods it calls

[14:53] <pmichaud> so there's likely something pathological there

[14:53] <moritz> it makes 90% in my profile

[14:53] <pmichaud> ....90%?

[14:53] <pmichaud> in mine it's 17%

[14:53] <jnthn> Are you lookign at inclusive or exclusive? :)

[14:54] <moritz> pmichaud: are you looking at "ticks" or "ops"?

[14:54] <pmichaud> ops

[14:54] <pmichaud> I can look at ticks

[14:54] <moritz> I looked at ticks

[14:54] <moritz> it's much lower in ops

[14:55] <moritz> (ticks are time, ops just counts the number of invoked parrot opcodes; much less useful IMHO)

[14:55] <jnthn> The ratio can be sometimes interesting though

[14:55] <jnthn> Few ops to ticks suggests some op is very expensive

[14:55] <jnthn> If it's that costly, a C level profile may also show it up

[14:56] *** grondilu left
[14:56] <pmichaud> just a sec, let me screen dump my profile and you all can walk me through it

[14:57] <jnthn> OK, but gotta go in 5 or so...

[14:57] <jnthn> (train)

[14:58] <pmichaud> http://pmichaud.com/work/kc-1.png

[14:58] <moritz> pmichaud: first click on the column header 'self'

[14:58] <pmichaud> okay, done

[14:59] <GlitchMr> nr: print &pack

[14:59] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'pack' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home…

[14:59] <p6eval> ..rakudo 809b8f: OUTPUT«pack»

[14:59] <moritz> that way it's sorted by exclusive time

[14:59] <jnthn> Yeah, the exclusive time bet is interesting.

[14:59] <jnthn> High exclusive time in CORE.setting especially so

[14:59] <moritz> now some _block(\d+) should show up on top

[15:00] <pmichaud> so, on mine the bulk of the time is in block 1013 (33.66%) and postfix:<++>  (29.90%)

[15:00] <moritz> you just grep for that name in src/gen/CORE.setting.pir

[15:00] * [Coke] is happy that this level of profiling is available.

[15:00] <moritz> and there you can see in the annotations which line in src/gen/CORE.setting it corresponds to

[15:00] <moritz> and that way you can find out the enclosing routine

[15:01] <pmichaud> http://pmichaud.com/work/kc-2.png   (sorted by 'self')

[15:01] <pmichaud> so, on mine it looks like the bulk of the time is spent calling the { $i++ } block (500K times)

[15:01] <jnthn> The most expensive block is the one in the program, not the actual list guts.

[15:01] <pmichaud> that indicates to me that the cost of the map itself is less than 37%

[15:02] *** adu joined
[15:02] <moritz> ah, I had an empty block in my for loop

[15:02] <pmichaud> oh, well, yes -- if your for loop has an empty block, then the loop takes up 90% of the execution time :)

[15:03] *** spider-mario left
[15:03] <moritz> well, not the loop, just one block in the loop

[15:05] <pmichaud> anyway, yes, this works for me.  I'm not seeing anything too unexpected here at the moment

[15:05] <pmichaud> [Coke]: (profiling available)  I'm very happy to see it also.  It's a huge help that we went without for too long.

[15:06] <dalek> rakudo/nom: 8bb2fad | pmichaud++ | src/core/MapIter.pm:

[15:06] <dalek> rakudo/nom: Use QRPA for ListIter's $!rest in MapIter.

[15:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8bb2fadddd

[15:06] <[Coke]> I hope to find time to play with it soon and find expensive things to clean up. ;)

[15:06] *** spider-mario joined
[15:08] <jnthn> decommute &

[15:08] *** _jaldhar joined
[15:09] *** drbean left
[15:10] *** drbean joined
[15:15] <adu> good morning

[15:16] *** _jaldhar left
[15:17] <TimToady> likewise

[15:19] *** _jaldhar joined
[15:20] <[Coke]> # 06/07/2012 - rakudo++ (22423); niecza (91.29%); pugs (34.56%)

[15:20] <[Coke]> minor gains by rakudo

[15:20] *** fridim_ joined
[15:21] <adu> rakudo++

[15:25] <xinming> If I remember right, In our roadmaps, That we targeting compiling of perl 6 into plain C source files, and ship the source files to another machines and build via a C Compiler, Am I right?

[15:26] <moritz> xinming: who is the "we"/"our" you're speaking of?

[15:26] <pmichaud> xinming: that's not been the plan for rakudo, no.

[15:26] <moritz> I'm pretty sure it was never on a roadmap of mine

[15:26] <pmichaud> at least, not in any sort of short-term or medium-term roadmap.

[15:26] <xinming> I don't mean roadmap

[15:27] <xinming> I remember that when we are at pugs age, And people compiling perl 6 into javascript

[15:27] <xinming> and someone "said"(maybe I'm wrong), That we can write a C emmit kind of thing to generate C code directly.

[15:28] <pmichaud> I think I remember hearing that, yes.  I don't know how feasible that's ever been.

[15:29] <[Coke]> the problem with that is eval.

[15:29] <[Coke]> s/the/a/

[15:29] <TimToady> well, all you have to do is emit a parrot too, which is in C  :)

[15:29] <pmichaud> well, I suppose someone could write Perl 6 code that implements a Perl 6 VM (including dynamic stuff) and is translatable to C.

[15:30] <arnsholt> I'm not sure I see (much) of a use-case for emitting to C

[15:30] <adu> "all you have to do"

[15:30] <arnsholt> But I do think in the really long term someone'll probably get around to writing a compiler that compiles to native code

[15:30] <PerlJam> arnsholt: the usual reason is "speed"  (but we know how that turns out)

[15:30] <pmichaud> adu: TimToady often says "all you have to do"  :-)

[15:31] <pmichaud> adu:  "All you have to do is implement protoregexes and longest token matching via DFAs and ... "  :-P

[15:31] <arnsholt> PerlJam: There is that, but I think a compiler to machine code is more viable. Not unlike the state of Common Lisp compilers

[15:32] <arnsholt> Most of the CL compilers are written in CL and emit machine code (just like C compilers tend to be written in C)

[15:33] <xinming> arnsholt: If I remember right, sbcl can compile lisp code to C

[15:33] <adu> clj emits jvm

[15:34] <[Coke]> I'm more sanguine about parrot getting a JIT in the next year than I am about rakudo or niecza emitting C.

[15:34] <adu> I was interested in doing that

[15:35] <arnsholt> Definitely. Native-code compiler is very-much a long term possibility, I think. Not just something that can be magically conjured into existence

[15:35] <moritz> fwiw the codegen part (when compiling to C) will be much less work than providing all the runtime support

[15:39] <arnsholt> Well, true. But it's not very useful without the runtime support =

[15:39] <arnsholt> s/=/=)

[15:39] *** drbean left
[15:40] *** drbean joined
[15:41] *** spaceships joined
[15:45] *** daxim left
[15:46] *** spaceships left
[15:47] <moritz> https://github.com/perl6/doc

[15:48] <felher> moritz++ :)

[15:50] <pmichaud> maybe "p6doc" is a better repo name, to match the name of the tool.

[15:51] <pmichaud> other than that, moritz++

[15:51] <moritz> pmichaud: well, I also want to gather the docs, not just the tool

[15:52] <pmichaud> fair enough.

[15:52] <pmichaud> where "docs" != "specs", of course :)

[15:56] <moritz> of 

[15:56] <moritz> course

[15:57] <[Coke]> are the docs going to be tied to an implementation?

[15:57] <[Coke]> or annotated for same?

[15:58] <[Coke]> or pretend to be universal for a spec revision?

[15:58] <moritz> universal

[16:01] <pmichaud> r: say 20/540

[16:01] <p6eval> rakudo 8bb2fa: OUTPUT«0.037037␤»

[16:05] <moritz> nr: say fc 'foo'

[16:05] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'fc' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/p…

[16:05] <p6eval> ..rakudo 8bb2fa: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&fc' called (line 1)␤»

[16:06] <moritz> nr: say titlecase 'foo'

[16:06] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«===SORRY!===␤␤Undeclared routine:␤      'titlecase' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at …

[16:06] <p6eval> ..rakudo 8bb2fa: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&titlecase' called (line 1)␤»

[16:06] <felher> moritz: what exactly do mean by 'gather documentation'? Go through the specs, write documentation for builtin functions and such and let them be viewable using p6doc? :)

[16:06] <moritz> felher: exactly

[16:06] <felher> \o/ :)

[16:07] <moritz> nr: say 'abc'.index('b').WHAT

[16:07] <p6eval> rakudo 8bb2fa, niecza v18-6-ge52d6c3: OUTPUT«Int()␤»

[16:08] *** birdwindupbird left
[16:08] <moritz> in cases where both rakudo and niecza deviate from the spec in the same way, I'm going to describe what is, not what should be

[16:09] *** drbean left
[16:10] <moritz> nr: say 'abc'.index('d').WHAT

[16:10] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«Num()␤»

[16:10] <p6eval> ..rakudo 8bb2fa: OUTPUT«Str()␤»

[16:10] *** drbean joined
[16:10] <felher> moritz++ :)

[16:10] <moritz> Num? why Num?

[16:10] <moritz> nr: say 'abc'.index('d')

[16:10] <p6eval> niecza v18-6-ge52d6c3: OUTPUT«Num()␤»

[16:10] <p6eval> ..rakudo 8bb2fa: OUTPUT«Str()␤»

[16:10] <moritz> eeks

[16:10] <moritz> I'd expect either a Failure or the Int type object

[16:12] <pmichaud> (deviate)  also note that it's a deviation somehow :)

[16:13] *** _jaldhar left
[16:13] *** am0c joined
[16:16] *** Chillance joined
[16:17] <moritz> the dalek hook from perl6/doc doesn't seem to work :/

[16:19] *** mikemol_ joined
[16:20] *** mikemol left
[16:21] <sorear> good * #perl6

[16:21] <moritz> \o sorear 

[16:24] *** vlixes joined
[16:25] *** bluescreen10 joined
[16:26] <moritz> sorear: any idea why commits to perl6/doc don't show up here?

[16:27] <moritz> I've added http://feather3.perl6.nl:5000/dalek?t=freenode,perl6 as a post-commit URL

[16:27] *** adu left
[16:27] *** adu joined
[16:28] <moritz> nr: say Parcel ~~ Positional

[16:28] <p6eval> rakudo 8bb2fa, niecza v18-6-ge52d6c3: OUTPUT«True␤»

[16:30] <moritz> nr: say split('a', 'bac', :all).perl

[16:30] *** Vlavv_ left
[16:30] <p6eval> rakudo 8bb2fa: OUTPUT«("b", "a", "c").list␤»

[16:30] <p6eval> ..niecza v18-6-ge52d6c3: OUTPUT«["b", #<match from(1) to(2) text(a) pos([].list) named({}.hash)>, "c"].list␤»

[16:30] *** JimmyZ left
[16:33] <sorear> moritz: 

[16:33] <sorear> moritz: I think it needs to be #perl6

[16:33] <moritz> sorear: ok

[16:34] <moritz> sorear: mu/misc/dalek-push.txt doesn't include the #

[16:35] <moritz> sorear: and with the # it also doesn't work :/

[16:35] <sorear> actually, it doesn't work because I think the parrot folks might have done something

[16:36] <sorear> dalek crashed spewing errors from the CREDITS parser

[16:39] *** drbean left
[16:40] *** drbean joined
[16:42] *** Vlavv_ joined
[16:47] <moritz> sorear: so, what's the problem with the CREDITS file?

[16:48] <sorear> starting that investigation now

[16:49] <GlitchMr> back (for a while :P)

[16:49] <moritz> the last commit that touched CREDITS removed the pod markers

[16:55] <sorear> yeah, dalek depends on searching the file for =cut

[16:55] <sorear> bad #parrot

[16:55] <[Coke]> bad dalek, that's not a pod file. ;)

[16:57] <[Coke]> seems like reading to the end is safe.

[16:58] <sorear> ok, dalek is patched and restarted, moritz you can try again

[17:01] <[Coke]> sorear++

[17:06] <GlitchMr> nr: say "c"~ <\ | / ->[$_%4]for^Inf

[17:06] <GlitchMr> nr: say "c"~ <\ | / ->[$_%4]for 1..10

[17:06] <p6eval> rakudo 8bb2fa: OUTPUT«(timeout)c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤…

[17:06] <p6eval> ..niecza v18-6-ge52d6c3: OUTPUT«(timeout)c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤…

[17:06] <p6eval> rakudo 8bb2fa, niecza v18-6-ge52d6c3: OUTPUT«c|␤c/␤c-␤c\␤c|␤c/␤c-␤c\␤c|␤c/␤»

[17:07] <GlitchMr> Makes sense...

[17:09] <[Coke]> dalek just posted in #parrot; sorear++

[17:09] *** drbean left
[17:10] *** drbean joined
[17:16] <pmichaud> in perl6/doc, is it worth it to come up with a shorthand notation that indicates implementation status?   E.g.,   "r+ n+"?

[17:17] <pmichaud> (borrowing from the 'features' repo for the moment.)

[17:19] <pmichaud> I'm also reminded of the IndexDotHTML support key system:  http://www.blooberry.com/indexdot/misc/suppkey.htm  where they indicated support for HTML features by browser type

[17:19] <pmichaud> (yes, it's very outdated; the idea is the thing)

[17:21] <moritz> pmichaud: don't think it's worth the shortcut

[17:21] <moritz> pmichaud: there's enough implemented stuff we can document first :-)

[17:22] <pmichaud> okay.  I'm just wondering about "not implemented in XXX" becoming stale

[17:22] <pmichaud> having a shortcut means we might be able to use this to have a "detailed features" online matrix

[17:22] <pmichaud> but since I'm not doing the work (yet), it's just an idea and not really a "iwbni" :-)

[17:25] <dalek> doc: 137e690 | moritz++ | CREDITS:

[17:25] <dalek> doc: update my CREDITS entry to match the repository

[17:25] <dalek> doc: review: https://github.com/perl6/doc/commit/137e69067f

[17:26] *** icwiener joined
[17:29] *** mikemol joined
[17:31] *** zby_home joined
[17:32] <moritz> tadzik: ping

[17:32] *** alvis``` joined
[17:32] *** mikemol_ left
[17:33] <moritz> tadzik: I want to extract only a section of Pod of which I know the name of the heading in advance

[17:33] <moritz> tadzik: any good ideas how I could do that?

[17:34] *** alvis`` left
[17:34] <moritz> so far I've come up with some ideas: 1) preprocess with regexes, write only the interesting part to a temp file, run rakudo on that

[17:34] <moritz> 2) patch rakudo somehow to magically do it for me (but how?)

[17:34] <moritz> 3) subclass Pod::To::Text (but then I'm screwed when I want a different backend)

[17:35] <moritz> 4) inject a filter stage between parsing and emission backend (is that overkill)?

[17:35] <eiro> hello guys 

[17:35] <moritz> tadzik: any thoughts?

[17:35] <moritz> \o eiro 

[17:35] <moritz> erm, eiro/

[17:36] <moritz> :-)

[17:36] <eiro> trying to write a script to install a rakudo/fpw 

[17:36] <eiro> is there a chance to have a tag for fpw12 ? 

[17:37] <moritz> yes

[17:38] <eiro> cool :) 

[17:38] <moritz> eiro: I just need to check if/how it interacts with rakudo's own version reporting

[17:38] <eiro> the goal of  the script: bailador + tags + dbi 

[17:38] <eiro> ok

[17:39] <moritz> eiro: any particular revision you want to tag?

[17:39] *** drbean left
[17:40] <eiro> moritz, you tell me :) i really don't know what commit is the best to use

[17:40] <eiro> perhaps tadzik could tell ? 

[17:41] <eiro> i'm trying the very last tag for now 

[17:42] *** drbean joined
[17:42] <eiro> 8bb2fadddd5f4779d3d33f09880cd2fb3d415be8

[17:42] <GlitchMr> How can I make Perl 5 style sub. That means I can use it either as method of class or by specifying it as first argument?

[17:42] <GlitchMr> So I could do both of those:

[17:42] <GlitchMr> $something->do_that('a')

[17:42] <GlitchMr> And

[17:43] <GlitchMr> $something.do_that('a')

[17:43] <GlitchMr> *

[17:43] <GlitchMr> and

[17:43] <GlitchMr> Something.do_that($something, 'a')

[17:43] <moritz> you can't do that in p5 either

[17:43] <eiro> yes you can in perl5 

[17:43] <moritz> you can do Someting::do_that($something, 'a') in p5

[17:44] <eiro> ohh .. :: instead . , right 

[17:44] <moritz> eiro: yes, but only if special-case the subroutine to ignore the first argument if it's a string

[17:44] <GlitchMr> Well, whatever. So I can use method directly or on instance

[17:44] *** fgomez joined
[17:44] <moritz> r: class A { our method x is export { 'A::x' } }; say A.x; say A::x(A)

[17:44] <p6eval> rakudo 8bb2fa: OUTPUT«A::x␤A::x␤»

[17:44] <moritz> GlitchMr: like this

[17:44] <GlitchMr> Interesting :)

[17:44] <eiro> moritz, anyway: you can Something->do_that( $something, 'a'), you have 3 parameters then

[17:45] *** fgomez left
[17:45] *** fgomez joined
[17:45] <eiro> 'Something', $something, 'a' 

[17:45] <moritz> eiro: yes, I know

[17:47] <moritz> eiro: but since it's not normal calling convention, the routine must be written to explicitly take that case into account

[17:48] *** simcop2387 left
[17:49] *** mtk left
[17:49] *** simcop2387 joined
[17:50] <zby_home> is there something like local::lib for perl6 http://nopaste.snit.ch/143553 ?

[17:51] <moritz> phenny: "Nie ma takiego pliku ani katalogu"?

[17:51] <phenny> moritz: "No such file or directory" (pl to en, translate.google.com)

[17:51] <moritz> zby_home: you need perl6 in $PATH for now

[17:52] <zby_home> OK

[17:52] <zby_home> interesting - I did not even noticed that that error message was in Polish

[17:53] <GlitchMr> lol

[17:53] <moritz> I did :-)

[17:53] <GlitchMr> I did too :P

[17:53] <GlitchMr> But too late

[17:53] <GlitchMr> Well... 1:1... whatever that means

[17:53] *** simcop2387 left
[17:54] <GlitchMr> Isn't need for perl6 in $PATH a bug?

[17:55] <geekosaur> "for now" implies it's something expected to change in the future

[17:55] <geekosaur> which suggests if not a bug then a known infelicity

[17:55] *** simcop2387 joined
[17:55] <GlitchMr> oh, ok

[17:56] <eiro> masak, remember where Tags.pm is ? 

[18:04] <moritz> eiro: if neither jnthn nor pmichaud object, i'll push the fpw12 tag tomorrow

[18:07] <dalek> rakudo/nom: 5a415c9 | moritz++ | src/core/Cool.pm:

[18:07] <dalek> rakudo/nom: return Int type object from failed Str.index

[18:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a415c9933

[18:08] *** mtk joined
[18:09] <eiro> moritz, ok: i'll test from it 

[18:09] *** drbean left
[18:10] *** drbean joined
[18:12] <pmichaud> ...fpw12 tag?

[18:12] * pmichaud reads backscroll

[18:13] *** mtk left
[18:13] <pmichaud> I see no issue with a fpw12 tag.  Most of the release details look specifically for tags that begin with "2012..." or the like.

[18:13] *** am0c left
[18:14] <pmichaud> looks like it looks for tags beginning with "2"

[18:14] <pmichaud> anyway, fpw12 tag +1 from me if you want

[18:14] <moritz> good

[18:15] <pmichaud> (foldcase)  I wasn't sure if ICU's foldcase semantics matched the ones we want for p6

[18:16] <pmichaud> also, we can always write our own opcode to access ICU's foldcase rather than wait/ask parrot to do it

[18:17] <pmichaud> see, for example, the is_uprop opcode in src/ops/nqp.ops

[18:17] <pmichaud> (which gives us access to ICU's property databse, which Parrot also doesn't expose)

[18:18] * pmichaud adds note to issue ticket

[18:22] *** mtk joined
[18:24] <adu> how do I match \n when it's already matched by <ws>?

[18:25] <moritz> you can match ^^ which is begin-of-line

[18:25] <adu> oh

[18:25] <adu> thanks

[18:25] <moritz> r: say "a\nb" ~~ /<alpha> <.ws> ^^ b/

[18:26] <p6eval> rakudo 5a415c: OUTPUT«q[a␤b]␤ alpha => q[a]␤␤»

[18:26] <moritz> r: say "a\n b" ~~ /<alpha> <.ws> ^^ b/

[18:26] <p6eval> rakudo 5a415c: OUTPUT«#<failed match>␤»

[18:26] <moritz> so be careful that you don't use <.ws> if it could slurp up a space after the newline

[18:27] <pmichaud> also note that \h* can be used for whitespace that isn't newline

[18:27] <pmichaud> (horizontal whitespace)

[18:27] <adu> and \v

[18:27] <adu> anyways, I'll give it a think

[18:28] <moritz> and in grammars you can write your own token ws that fits your needs

[18:29] <adu> I'm aware of that

[18:30] <adu> I suppose I could write a special newline token that fails when it could be an automatic semicolon...

[18:31] <adu> [\n <!semi>]

[18:32] <adu> where <semi> matches newlines under certain conditions?

[18:32] <moritz> well

[18:32] <moritz> that would be an \n not followed by a semi

[18:32] <moritz> maybe you rather want <!semi> \n ?

[18:32] <adu> [\n & <!semi>]

[18:32] <moritz> no

[18:33] <adu> <!before semi> \n

[18:33] <moritz> & is for matches of the same length left and right

[18:33] <adu> <semi> either matches ';' or \n

[18:33] <moritz> <!before <semi>> and <!semi> do the same thing

[18:33] <adu> those are both the same length

[18:33] <moritz> but <!semi> matches 0 chars

[18:33] <adu> oh

[18:34] <adu> so yes, I want <!semi> \n :)

[18:34] <adu> moritz++

[18:39] *** drbean left
[18:40] *** drbean joined
[18:46] *** _jaldhar joined
[18:49] *** _jaldhar left
[18:51] *** skids left
[18:52] *** _jaldhar joined
[19:00] *** kaleem joined
[19:07] *** mikemol left
[19:07] *** topologist joined
[19:17] *** birdwindupbird joined
[19:28] <dalek> doc: 03bfa61 | moritz++ | lib/Str.pod:

[19:28] <dalek> doc: Str.comb

[19:28] <dalek> doc: review: https://github.com/perl6/doc/commit/03bfa61dbe

[19:28] <dalek> doc: 67120d9 | moritz++ | bin/p6doc:

[19:28] <dalek> doc: basic implementation of -f

[19:28] <dalek> doc: review: https://github.com/perl6/doc/commit/67120d982c

[19:28] <dalek> doc: 24ae160 | moritz++ | README:

[19:28] <dalek> doc: more examples for README

[19:28] <dalek> doc: review: https://github.com/perl6/doc/commit/24ae160cd4

[19:38] *** kaleem left
[19:39] *** drbean left
[19:40] *** drbean joined
[19:46] *** fgomez left
[19:46] *** fgomez joined
[19:53] *** brrt joined
[19:57] *** snearch left
[20:03] *** zby_home left
[20:06] *** preflex left
[20:07] *** sporous left
[20:09] *** sporous joined
[20:09] *** preflex joined
[20:10] *** Telgalizer left
[20:13] *** sporous left
[20:13] *** sporous_ joined
[20:14] *** GlitchMr left
[20:14] *** Telgalizer joined
[20:14] *** preflex left
[20:15] *** preflex_ joined
[20:16] *** preflex_ is now known as preflex

[20:19] *** sporous_ is now known as sporous

[20:22] <brrt> r: pir::compreg_Ps('nqp');

[20:22] <p6eval> rakudo 5a415c: OUTPUT«use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤use of uninitialized value of type Mu in string context  in any <anon> at src/gen/BOOTSTRAP.pm:104␤␤===SORRY!===␤error:imcc:syntax error, unexpected PREG, expecting …

[20:23] <moritz> r: my $n := pir::compreg__Ps('nqp')

[20:23] <p6eval> rakudo 5a415c:  ( no output )

[20:24] <moritz> brrt: need two __ between pirop and signature

[20:25] <brrt> a, i see

[20:25] <brrt> moritz: would you know why load_language('nqp') in winxed causes a segfault? is that normal?

[20:25] <moritz> brrt: I hope it's not normal :-)

[20:26] <brrt> hmm, i can't seem to start gdb with the correct arguments

[20:26] <moritz> gdb --args your command line

[20:26] <moritz> run

[20:26] <brrt> oh, i see

[20:26] <moritz> and no, I don't know why that happens

[20:26] <moritz> otherwise only the first argument is treated as executable

[20:27] <moritz> and you have to supply the rest of the args to the 'run' command in gdb

[20:27] <brrt> its in Parrot_oo_find_vtable_override

[20:28] <brrt> none of its arguments seem to be zero

[20:30] <brrt> is this an nqp bug or a parrot bug?

[20:30] *** birdwindupbird left
[20:30] <moritz> hard to know

[20:31] *** skids joined
[20:34] <moritz> nqp: my $r := pir::compreg__Ps('nqp')

[20:34] <p6eval> nqp:  ( no output )

[20:35] * tadzik is back

[20:35] <moritz> \o tadzik 

[20:35] *** brrt left
[20:36] <tadzik> moritz: okay, Pod extraction. You mean to extract Pod from a separate file somehow?

[20:37] <tadzik> if you want it from the file you're in that should be quite easy

[20:37] <moritz> from a different file

[20:37] <tadzik> even easier if we implemented all the spec :)

[20:37] <tadzik> now that's a hard part

[20:37] <moritz> p6doc Str.split # searches for Str.pod  =head3 split  # or so

[20:37] <tadzik> as we don't really have a Pod Parser which we can tell "parse this file"

[20:37] <moritz> we do

[20:38] <moritz> it's called perl6 :-)

[20:38] <tadzik> well, yeah :)

[20:38] <tadzik> but you'll have to execute something from another file's UNIT scope, or so

[20:38] <moritz> I've now done a regex job and extracted the pod section into a temp file

[20:38] <moritz> p6doc Str.split # works

[20:38] <moritz> it's not a nice solution, but better than nothing

[20:38] <tadzik> true

[20:39] <moritz> now we just need docs :-9

[20:39] <tadzik> okay, you have all the pods in $=pod, which is an array of Pod::Blocks

[20:39] *** drbean left
[20:39] <tadzik> so you could do .first on it, looking for Pod::Block::Heading (I think) where .name eq something

[20:39] *** brrt joined
[20:40] <moritz> but how do I get another files' $=pod var?

[20:40] <tadzik> oh, it's just .content, not .name

[20:40] <tadzik> yeah, that's the hard part

[20:40] *** drbean joined
[20:40] <tadzik> I wonder if we could eval { $file ~ '; $=pod' } ;)

[20:41] *** wooden joined
[20:41] *** wooden left
[20:41] *** wooden joined
[20:41] <tadzik> string eval, I mean

[20:41] <moritz> and have all our variables leak into the inner scope

[20:42] <tadzik> yeah, seems to work

[20:42] <tadzik> oh, will they :F

[20:43] <tadzik> yeah, they will

[20:43] * tadzik considers extracting Pod grammar into a module

[20:45] * jnthn home 

[20:45] *** thou left
[20:46] <tadzik> hello jnthn 

[20:47] <tadzik> jnthn: any ideas about stealing some file's unit-scoped $=pod?

[20:47] <jnthn> hi, tadzik 

[20:47] <jnthn> "stealing"?

[20:49] <tadzik> accessing, from a perl 6 code

[20:49] <tadzik> so far the best idea is "my $somepod = eval(slurp('foo.pl') ~ ';$=pod');", which is hardly awesome

[20:52] <moritz> tadzik: I think the best approach is to install a hook between the pod parser and the emitter

[20:53] <moritz> and which can transform the pod tree

[20:53] <tadzik> an emmiter is called from within the file with $=pod

[20:53] <moritz> yes

[20:53] <moritz> but we already have hooks to use a different emitter

[20:54] <tadzik> yes

[20:54] <moritz> --doc=html # irrc

[20:54] <tadzik> oh

[20:54] <moritz> erm, iirc

[20:54] <moritz> so

[20:54] *** thou joined
[20:54] <tadzik> so you can write anything you want, yes

[20:54] <moritz> --doc=myfilter

[20:54] <tadzik> and you'll get your $=pod

[20:54] <moritz> and Pod::To::Myfilter can then pass on stuff to Pod::To::Whatever

[20:54] <tadzik> you need any class with a render() method

[20:55] *** lichtkind joined
[20:55] <tadzik> which takes $=pod as an argument

[20:55] <tadzik> so class Myfilter { method render($pod) { ... } } and you're done

[20:55] <tadzik> then --doc=Myfilter will work

[20:56] <lichtkind> o/

[20:56] <tadzik> \o

[20:57] <jnthn> +1 to doing it through existing API :)

[20:58] <lichtkind> tadzik: I will have tuits in 2 weeks again when next issue of foo is out

[20:58] *** thou left
[20:58] <tadzik> lichtkind: any particular ideas for spending tuits?

[21:00] <lichtkind> tadzik: sure my grant is still open -  i want complete the glossary tablet

[21:00] <lichtkind> and sync it a bit with the glossary in ther perldoc and camel

[21:09] *** drbean left
[21:11] *** drbean joined
[21:22] *** brrt left
[21:26] <jnthn> pmichaud: ping

[21:27] *** pupoque_gnexus joined
[21:30] *** pupoque_gnexus is now known as pupoque

[21:31] <moritz> r: say Pod::Heading

[21:31] <p6eval> rakudo 5a415c: OUTPUT«Heading()␤»

[21:32] *** pupoque left
[21:32] *** pupoque_gnexus joined
[21:32] *** pupoque_gnexus left
[21:34] <sergot> good night! o/

[21:34] <pmichaud> jnthn: pong

[21:35] *** sergot left
[21:36] <jnthn> pmichaud: One slowdown: while loops always generate exception handling stuff

[21:36] <pmichaud> jnthn: yes, but ?

[21:36] <jnthn> pmichaud: Even if redo/next/last are not used.

[21:36] <pmichaud> I'm not sure what this is in reference to.

[21:36] <jnthn> pmichaud: but it's expensive when you have while loops in your LTM code.

[21:36] <pmichaud> oh!

[21:37] <jnthn> pmichaud: I don't have a way to write a loop in NQP, so far as I can tell, that doesn't result in creating a Parrot ExceptionHandler

[21:37] <jnthn> pmichaud: I don't think that's very cheap :)

[21:38] <pmichaud> we could make one.

[21:39] <pmichaud> nqp::while(...)   with some option that says "don't generate exception handlers"

[21:39] <jnthn> pmichaud: Yeah, something like that.

[21:39] <dalek> nqp: dceb34b | jnthn++ | src/QRegex/Cursor.nqp:

[21:39] <dalek> nqp: Simplify and improve performance of !alt a bit; creates less junk. ~4% improvement on CORE.setting parse time.

[21:39] <dalek> nqp: review: https://github.com/perl6/nqp/commit/dceb34b88b

[21:40] <pmichaud> in our other Actions.pm stuff, do we make much use of 'next' or 'last', ooc?

[21:40] <jnthn> Not much.

[21:40] <dalek> doc: beac27d | moritz++ | lib/Pod/To/SectionFilter.pm:

[21:40] <dalek> doc: add a Pod::To:: module that searches for a given section

[21:40] <dalek> doc: review: https://github.com/perl6/doc/commit/beac27d966

[21:40] <jnthn> Or at least, I don't remember off hand anywhere that we do.

[21:40] <pmichaud> I count seven instances in src/Perl6

[21:40] <moritz> 3 x last, 1x next

[21:41] <moritz> in Actions.pm

[21:41] <pmichaud> er, 6 instances

[21:41] <pmichaud> 3 in Pod.pm, one in ClassHOW, 2 in Actions.pm

[21:41] <pmichaud> ('next')

[21:41] <pmichaud> so, it does get used some.

[21:41] <pmichaud> Hrm.

[21:41] <jnthn> Seems a shame to penalize every while loop though.

[21:41] <jnthn> Especially when we can probably statically detect it.

[21:42] <jnthn> It's lexical, innit?

[21:42] <pmichaud> according to p6 it's lexotic

[21:42] <jnthn> Or at least, we can constrain NQP that way.

[21:42] <pmichaud> which means dynamic

[21:42] <jnthn> Ah.

[21:42] <pmichaud> I wouldn't be opposed to making it lexical-only in nqp

[21:42] <pmichaud> dynamic instances of next/last aren't really all that common

[21:43] <pmichaud> or, more to the point, I wouldn't mind that someone would have to code a loop such that it can detect the need for the handler lexically

[21:43] <jnthn> *nod*

[21:43] <pmichaud> i.e., you only get the handler if there's a lexical next/last/redo.  The handler is still dynamic; but you have to explicitly add a next to get it.

[21:44] <pmichaud> thus    if 0 { next; }    would be good enough to generate the handler but not cause much of a runtime cost

[21:45] <pmichaud> so, we'd need to extend the ast while node to have an option that says "don't install a handler", and then have the lexical detection of next/redo/last

[21:46] <jnthn> Yeah

[21:47] <pmichaud> I wonder if it makes sense to do the same for 'for' loops. :-)

[21:47] <pmichaud> (I believe they share some of the underlying code gen anyway.)

[21:47] <pmichaud> for that matter, I wonder how many of our occurrences of next/last actually occur in while loops :)

[21:48] <jnthn> Oh, I thought aht's what you'd searched for

[21:48] <jnthn> I didn't realize you were looking at for loops too :)

[21:48] <pmichaud> no, I just searched for instances of next/last

[21:48] <lichtkind> jnthn: model6 landed fully?

[21:48] <jnthn> lichtkind: Huh? :)

[21:48] *** spider-mario left
[21:48] <lichtkind> hai

[21:49] <lichtkind> i mean that this work on wrenching model6 into rakudo is now completed?

[21:49] <pmichaud> jnthn: ooc, which ltm code are you looking at wrt while loops?

[21:49] <jnthn> !alt

[21:49] <jnthn> And !protoregex

[21:50] <pmichaud> is the cost of the handler showing up in a profile, ooc?

[21:51] <pmichaud> I mean, it's one handler per while loop, not one per while loop iteration

[21:52] <jnthn> I'd need to do a C level profile...generally I just know that reducing the amount of junk each !alt call generated just made a fairly sizable difference.

[21:53] <jnthn> And that ExceptionHandler creation there is probably multiple PMCs.

[21:53] <jnthn> iirc, there's an RPA of the handler IDs created also

[21:53] <jnthn> Or maybe it's just the one...

[21:53] <jnthn> Plus the ops to set it up

[21:53] <jnthn> Just looking for ways to streamline !alt and !protoregex, really.

[21:53] <pmichaud> they're showing up in the profile?

[21:54] <pmichaud> (just checking for confirmation, not doubting that they could be)

[21:54] <jnthn> I remember it showing up in the last C level profile I did...lemme generate a new one.

[21:54] <jnthn> Problem is...the answer is fuzzy (more)

[21:54] <pmichaud> I agree the exception handlers can be expensive -- we've seen that when we did rakudo-level subs

[21:55] <jnthn> I don't have a way to correlate the "we spend time creating them" in the C level profile with the HLL level profile. 

[21:55] <pmichaud> does every method/sub/etc still get an exception handler to catch returns?  I think you detect those lexically also, iirc

[21:55] <jnthn> So in a sense even though I recall there being some cost there, it's ahrd to actually conclusively say "it's the while loops here"

[21:56] <jnthn> In NQP?

[21:56] <pmichaud> yeah, in nqp

[21:56] <jnthn> It only gets a return handler if there's an explicit return.

[21:56] <pmichaud> so yes, having while and for loops only get iteration handlers on explicit next/last/redo seems very doable.

[21:56] <jnthn> It detects it's there, then adds it only if needed.

[21:56] <pmichaud> at least seems like it could follow a similar pattern.

[21:56] <jnthn> *nod*

[21:57] <lichtkind> jnthn: i just wanted ask beause i read in your blog nowadays only about QAST and such and was wandering if 6model is an topic anymore

[21:57] <pmichaud> and I suspect also that it means that many (most?) exception handler creations you're seeing are coming from loops, not methods or subs

[21:57] <jnthn> pmichaud: Yes, that's my guess. I wish I had better data.

[21:57] <jnthn> Not sure how to get it.

[21:57] <jnthn> lichtkind: The core of 6model is largely stable enough these days that it doesn't see much development.

[21:58] <pmichaud> I can certainly do a few tests to see how much the exception handler creation might be costing us.

[21:58] <jnthn> lichtkind: The point of 6model was that we'd do development of meta-objects in a HLL (like NQP) though.

[21:58] <jnthn> pmichaud: Could be good to get an idea of what it might save us.

[21:58] <lichtkind> jnthn: thanks i slowly preparing for the next update article :)

[21:59] <pmichaud> jnthn: actually, come to think of it, I already have a perfect test case.  the MapIter code has to install an exception handler -- I can compare it to with/without pretty easily

[21:59] <pmichaud> just a sec

[21:59] <dalek> nqp: d738608 | jnthn++ | src/QRegex/Cursor.nqp:

[21:59] <dalek> nqp: Similar simplification to !protoregex as just done to !alt; much less noticable difference, probably because we just pick the first answer much of the time and it works out.

[21:59] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d7386080b3

[22:00] <pmichaud> jnthn: have you tried replacing   new "ResizableIntegerArray"  with a clone yet?

[22:00] <pmichaud> istr you said that showed up on the profile some.

[22:01] <pmichaud> I also wonder if RIA is at all suboptimal.  Doesn't seem likely, since we only really do push + pop on it.

[22:01] <jnthn> pmichaud: Not tried that yet.

[22:01] *** pupoque joined
[22:02] <jnthn> pmichaud: fyi, !alt is called 323,000 times in CORE.setting parse.

[22:03] <pmichaud> oh!

[22:04] <pmichaud> the other thing you could do is to replace the while loop with Q:PIR { ... } -- like MapIter does

[22:04] <jnthn> Yeah, I was hoping not to do Q:PIR blocks :(

[22:04] <pmichaud> I agree that's not a general solution to the problem, but for hotspots it's plausible

[22:04] <pmichaud> and when we get fast loops again we can always go back :)

[22:05] <pmichaud> okay, trying mapiter w and w/o handler

[22:05] <pmichaud> just a sec

[22:09] *** drbean left
[22:10] <sjohnson> @karma

[22:11] <tadzik> karma sjohnson 

[22:11] <aloha> sjohnson has karma of 5.

[22:11] <tadzik> sjohnson++ # ¯\_(ツ)_/¯

[22:11] <sjohnson> heheh

[22:11] <pmichaud> 50K while loops with handler installed:  17.048 sec

[22:11] *** Telgsta joined
[22:11] <pmichaud> 50K while loops w/o  handler installed:  16.263 sec

[22:11] <jnthn> Oh?

[22:11] <jnthn> That's...much smaller than I'd have imagined. Hm.

[22:11] *** Telgalizer left
[22:12] <pmichaud> r: say (17.048-16.263)/17.048

[22:12] <p6eval> rakudo 5a415c: OUTPUT«0.046046␤»

[22:12] *** drbean joined
[22:12] <pmichaud> 4%

[22:12] *** bluescreen10 left
[22:12] <jnthn> Pretty small difference.

[22:13] <pmichaud> that particular test might be swamped by other execution time stuff; but it's clear that the time involved is on the order of 0.8 / 50000 sec

[22:13] <pmichaud> r: say 0.8 / 50000

[22:13] <p6eval> rakudo 5a415c: OUTPUT«0.000016␤»

[22:13] *** vlixes left
[22:13] <sjohnson> tadzik++

[22:14] <jnthn> r: say 0.000016 * 300000

[22:14] <p6eval> rakudo 5a415c: OUTPUT«4.8␤»

[22:14] <jnthn> Adds up when you do it 300,000 times...

[22:14] <pmichaud> yeah, 300K loops would add 5 seconds

[22:15] <jnthn> And the profile says we're doing that many.

[22:15] <pmichaud> out of 100 seconds (on my box) needed to parse CORE.settings, that means it's costing 5%

[22:15] <pmichaud> seems worth fixing at some level then

[22:15] <pmichaud> plus, that's just the cost of the while loops for the alt handler

[22:15] <pmichaud> we have lots of other loops in the compilation :)

[22:15] <jnthn> Yeah.

[22:16] <jnthn> Well, we have one in !protoregex, but that one actually *uses* last. :)

[22:16] <pmichaud> so, +1 to fixing it.  Need me to adjust the PAST nodes, or ... ?

[22:16] <jnthn> Depends how soon we want the fix.

[22:16] <pmichaud> I'm thinking of all of the while and for loops in Actions.pm, though.

[22:16] <jnthn> I mean, maybe we just do it right in QAST? :)

[22:16] <pmichaud> well, doing it right in QAST goes without saying :)

[22:17] <pmichaud> I can certainly add a replacement 'while' node type to PAST that provides the new capability

[22:17] <pmichaud> or, since this is optional, I can even add it to Parrot's PAST nodes directly

[22:18] <jnthn> If it won't take much time, it'd mean we can improve the parse performance in time for the next release.

[22:18] <jnthn> er

[22:18] <jnthn> It'd help us to improve the...

[22:18] <jnthn> :)

[22:18] <pmichaud> oh, the PAST part is pretty straightforward.  I can do that, like, tonight.

[22:19] <pmichaud> the detection of lexical last/next is the trickier part, at least for me.  But since you've already done it, I suspect you could do that quickly also :)

[22:19] <jnthn> Hah, I just ahve a $*USES_RETURN or something in routine_def :)

[22:20] <pmichaud> right, we just need a $*USES_NEXT or something

[22:20] <pmichaud> in statement:<while> and friends

[22:20] <jnthn> Right.

[22:20] <pmichaud> okay -- let's do this.  if I get time tonight (likely), I'll work on the whole thing some.

[22:20] <pmichaud> I'll leave word via phenny about how far I get.

[22:20] <pmichaud> getting the PAST node updated should be no problem.

[22:20] *** ponbiki joined
[22:21] <pmichaud> I should have some time tomorrow, also, but my schedule has other events on it to deal with :-/

[22:21] <pmichaud> plus I should probably make sure my stuff is ready for yapc :-)

[22:21] <jnthn> Ah, yeah, YAPC is soon, right?

[22:21] <pmichaud> I leave tuesday, it starts wed

[22:21] <jnthn> k

[22:22] <pmichaud> and a good bit of sunday is unavailable for me

[22:22] <jnthn> OK.

[22:22] <jnthn> I'm around quite a bit this weekend and early on next week

[22:22] <jnthn> Towards next weekend I'll be largely afk

[22:23] <pmichaud> anyway, I agree based on the above that avoiding the exception handlers is probably worth(pardon the pun)while

[22:24] <jnthn> :P

[22:27] <pmichaud> afk for a bit

[22:31] *** ranguard_ joined
[22:31] *** daemon_ joined
[22:31] *** betterwo1ld joined
[22:31] <dalek> nqp: ac5f5fc | jnthn++ | src/ops/nqp.ops:

[22:31] <dalek> nqp: Re-use state arrays in NFA runner, saving roughly a million PMC allocations during CORE.setting parse. Another couple of percent off.

[22:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ac5f5fc4a5

[22:31] *** Juerd_ joined
[22:35] *** ivan``_ joined
[22:36] *** pupoque left
[22:36] *** ivan`` left
[22:36] *** betterworld left
[22:36] *** wolverian left
[22:36] *** daemon left
[22:36] *** hugme left
[22:36] *** tadzik left
[22:36] *** Juerd left
[22:36] *** ranguard left
[22:36] *** Juerd_ is now known as Juerd

[22:37] *** ivan``_ is now known as ivan``

[22:38] *** NamelessTee left
[22:39] *** cognominal_ joined
[22:39] *** mattp_ joined
[22:39] *** Facefox left
[22:39] *** drbean left
[22:42] *** cognominal left
[22:42] *** drbean joined
[22:42] *** wolverian joined
[22:42] *** sjohnson joined
[22:42] <lichtkind> good night

[22:43] *** tadzik joined
[22:44] *** alester joined
[22:45] *** adu left
[22:45] *** Facefox joined
[22:45] *** icwiener left
[22:47] *** hugme joined
[22:47] *** ChanServ sets mode: +v hugme

[23:26] *** alester left
[23:37] <spacebat_> trying to build rakudo on the nom branch, from a clean checkout, running Configure.pl has nqp complain it can't find libgmp.so.3, parrot complains it can't find libicuuc.so.42, then make-realclean fails with /usr/local/perl5/perlbrew/perls/perl-5.14.1/bin/perl5.14.1: not found

[23:37] <spacebat_> but nothing in my environment mentions perlbrew being under /usr/local, and nothing mentions 5.14.1, I use 5.14.2

[23:38] <spacebat_> I've build rakudo on this machine before alright, so I have libgmp and libicu installed

[23:39] <spacebat_> am I building a broken old branch?

[23:39] *** drbean left
[23:40] <jnthn> No, "nom" branch is the right one.

[23:41] <jnthn> Latest commits were earlier today...I built latest recently also and it worked out. Seems it's something ICU related, though the perlbrew error is really odd too.

[23:41] <spacebat_> I'll try a fresh clone

[23:41] *** drbean joined
[23:45] *** whiteknight joined
[23:45] <spacebat_> I think my nqp and parrot submodules must have been out of date or something

[23:45] *** whiteknight is now known as Guest38800

[23:46] <dalek> nqp: f60f402 | jnthn++ | src/ops/nqp.ops:

[23:46] <dalek> nqp: Refactor to pull much of the NFA runner out of the op body.

[23:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/f60f4024e9

[23:46] <dalek> nqp: ba8bf93 | jnthn++ | src/ (3 files):

[23:46] <dalek> nqp: Refactor the NFA ops; we needn't get the ordering back and then push it onto the bstack in a loop, we can just do it right in an op; we've a few other ops that manipulate the bstack after all. Another little win.

[23:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ba8bf9311b

[23:46] <dalek> nqp: 35db044 | jnthn++ | src/stage0/ (8 files):

[23:46] <dalek> nqp: Update bootstrap.

[23:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/35db04446b

[23:46] <dalek> nqp: 7176d14 | jnthn++ | src/ops/nqp.ops:

[23:46] <dalek> nqp: Toss now-unused op.

[23:46] <dalek> nqp: review: https://github.com/perl6/nqp/commit/7176d14a2c

[23:47] *** _jaldhar left
[23:53] <dalek> rakudo/nom: 0fde4a1 | jnthn++ | tools/build/NQP_REVISION:

[23:53] <dalek> rakudo/nom: Use latest NQP for some parsing performance improvements (roughly 8% improvement for CORE.setting).

[23:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0fde4a1e37

[23:53] <diakopter> jnthn++

[23:55] <jnthn> Sometime over the weekend I'll try to recover our spectest time too.

[23:55] <jnthn> (We spent a load of time early in the parse building NFAs that we could build at compile time and serialize.)

[23:55] <jnthn> s/spent/spend/

[23:57] <jnthn> The LTM transitivity is to blame.

