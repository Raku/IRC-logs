[00:06] <diakopter> 14 minutes

[00:13] <dalek> roast: 099ceda | diakopter++ | S06-currying/mixed.t:

[00:13] <dalek> roast: add test for RT #70890. resolves ticket.

[00:13] <dalek> roast: review: https://github.com/perl6/roast/commit/099cedad93

[00:18] *** wamba joined
[00:21] <dalek> roast: ed30b2e | diakopter++ | S12-enums/thorough.t:

[00:21] <dalek> roast: test for RT #71196. resolves ticket.

[00:21] <dalek> roast: review: https://github.com/perl6/roast/commit/ed30b2efbf

[00:22] <dalek> roast: a3f5481 | diakopter++ | S12-enums/thorough.t:

[00:22] <dalek> roast: fudge niecza

[00:22] <dalek> roast: review: https://github.com/perl6/roast/commit/a3f5481314

[00:27] <TimToady> http://rosettacode.org/wiki/Set_consolidation#Perl_6

[00:27] <TimToady> doesn't work in rakudo for some reason though

[00:27] <dalek> roast: 6a03ec5 | diakopter++ | S05-mass/rx.t:

[00:27] <dalek> roast: test RT #71702. resolves ticket

[00:27] <dalek> roast: review: https://github.com/perl6/roast/commit/6a03ec52c3

[00:28] <diakopter> TimToady: \o/ a golfing challenge

[00:29] *** b1rkh0ff left
[00:29] <TimToady> well, I was aiming more for clarity...

[00:30] <TimToady> and FP, but it still has a mutable variable

[00:31] <diakopter> does rakudo not have those set operators?

[00:32] <TimToady> it supposedly does

[00:32] <TimToady> nr: say set('a','b') ∪ set('b','c')

[00:32] <p6eval> niecza v18-2-gea3d97a: OUTPUT«set(a, b, c)␤»

[00:32] <p6eval> ..rakudo 636527: OUTPUT«===SORRY!===␤Confused␤at /tmp/7lZrRxbqcp:1␤»

[00:33] <TimToady> maybe not

[00:37] <diakopter> I don't even see union or intersection methods in rakudo's Set.pm

[00:46] <dalek> roast: 6a6a83f | diakopter++ | S04-statements/redo.t:

[00:46] <dalek> roast: test RT #72442. resolves ticket.

[00:46] <dalek> roast: review: https://github.com/perl6/roast/commit/6a6a83f0a6

[00:47] <TimToady> that's very odd; I wonder if they got lost in a branch merge somewhere along the way

[00:54] <mdmkolbe> Does the argument list interpolation operator (prefix "|"), mean anything on other contexts or is it just for argument list interpolation?

[00:54] <TimToady> if it's in another context, it wouldn't be a prefix operator...

[00:55] <mdmkolbe> ?

[00:57] <mdmkolbe> I mean is it's use as an argument list interpolation operator a special case of a more general operation or is it just for that one use case?

[00:57] *** adu joined
[00:58] <dalek> roast: 369d517 | diakopter++ | S12-class/basic.t:

[00:58] <dalek> roast: test RT #72916

[00:58] <dalek> roast: review: https://github.com/perl6/roast/commit/369d517e7a

[00:58] <diakopter> resolves ticket.

[00:59] *** wamba left
[00:59] <adu> hi diakopter 

[00:59] <diakopter> mdmkolbe: no, when used as a prefix, that's the only meaning | has. 

[00:59] <TimToady> I don't see any more general case for it, but argument list interpolation already seems pretty general to me

[01:00] <diakopter> adu: howdy

[01:00] <adu> oh, you're talking about passing a list as arguments?

[01:01] <mdmkolbe> adu: yes

[01:02] <adu> well

[01:03] <adu> I suppose that's different from currying

[01:04] *** diakopter joined
[01:05] <TimToady> well...p6 doesn't really do currying, it just does partial function application

[01:05] <TimToady> and this ain't it

[01:06] <mdmkolbe> perl6: say 1, (2, 3), 4

[01:06] <p6eval> rakudo 636527, niecza v18-2-gea3d97a: OUTPUT«12 34␤»

[01:06] <p6eval> ..pugs: OUTPUT«1234␤»

[01:06] <TimToady> though I supposed &func.assuming(|@args) could be viewed as a form of currying

[01:08] <TimToady> but technically currying has to do with a series of functions of 1 argument

[01:08] <TimToady> Haskell does that, but Perl 6 doesn't

[01:10] <adu> I remember reading about .assuming

[01:10] <mdmkolbe> IIUC, p6 has subtyping over parametric types.  How does it resolve the resulting inconsistencies?  I.e., from a type theory perspective, Bowl[Apple] shouldn't be a subtype of Bowl[Fruit] because you can't put an Orange in a Bowl[Apple].

[01:10] <adu> I've read a few of the synopses many times

[01:10] <mdmkolbe> (Sorry for so many questions, I'm learning Perl 6 and am currios about some of the design decisions as my day job is in programming language research.) 

[01:11] <adu> mdmkolbe: we should be friends

[01:12] <diakopter> there, I added eval_dies_with_error to rakudo. now to see about niecza

[01:14] <TimToady> mdmkolbe: you should ask jnthn++ that when he's on; he's been thinking about these things, and I believe has some ideas on where Perl 6 should head in that regard

[01:15] <TimToady> me, I go all handwavey at that point

[01:15] <TimToady> type theory is not my speciality

[01:16] <mdmkolbe> (re: argument lists) I guess I would have expected something like func(*@args) since that parallels the slurpy syntax (Maybe there a problems with that)

[01:16] <TimToady> we decided to steal * for something else

[01:17] <TimToady> its use to mean "whatever" cannot be combined with use as a prefix operator

[01:17] <mdmkolbe> TimToady: that makes sense

[01:17] <TimToady> nr: constant \fib = 0,1,*+* ... *; say fib[^20]

[01:18] <p6eval> rakudo 636527: OUTPUT«===SORRY!===␤Missing initializer on constant declaration␤at /tmp/9UrGjMbi_d:1␤»

[01:18] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Kernel.ToComposable (Niecza.STable arg, Niecza.STable cls) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.ApplyRoleToClass (Niecza.ST…

[01:18] <TimToady> hmm

[01:18] <TimToady> nr: constant @fib = 0,1,*+* ... *; say @fib[^20]

[01:18] <p6eval> rakudo 636527, niecza v18-2-gea3d97a: OUTPUT«0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181␤»

[01:19] <TimToady> and | looks like a slit that you cut, into which you insert the argments :)

[01:19] <sorear> niecza apparently thinks fib is a role

[01:20] <TimToady> nr: my \fib = 0,1,*+* ... *; say fib[^20]

[01:20] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Kernel.ToComposable (Niecza.STable arg, Niecza.STable cls) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.ApplyRoleToClass (Niecza.ST…

[01:20] <p6eval> ..rakudo 636527: OUTPUT«===SORRY!===␤Malformed my␤at /tmp/Z2NJ0yyW7n:1␤»

[01:20] <TimToady> nr: constant fib = 0,1,*+* ... *; say fib[^20]

[01:20] <p6eval> rakudo 636527: OUTPUT«0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181␤»

[01:20] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Kernel.ToComposable (Niecza.STable arg, Niecza.STable cls) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.ApplyRoleToClass (Niecza.ST…

[01:21] <mdmkolbe> TimToady: I'm not sure whether to laugh or groan at that visual pun

[01:21] <TimToady> if you're going to hang around here, you'll get used to thinking that things aren't actually mutually exclusive most of the time

[01:22] <diakopter> please share; I don't see a pun :)

[01:22] <mdmkolbe> What does "::" signify in a type parameter?  (e.g. role [::T] { ... })

[01:22] <TimToady> capture a type 'en passant' from the argument

[01:23] <TimToady> nr: sub sametype (::T $, T $) { say "Same type" }; sametype 42,43

[01:23] <p6eval> niecza v18-2-gea3d97a: OUTPUT«===SORRY!===␤␤GLOBAL::T does not name any package at /tmp/cmv_acYXqG line 1:␤------> sub sametype (::T⏏ $, T $) { say "Same type" }; sametype 4␤␤A type must be provided at /tmp/cmv_acYXqG line 1:␤------> sub sametyp…

[01:23] <p6eval> ..rakudo 636527: OUTPUT«Same type␤»

[01:23] <TimToady> NYI in niecza, apparently

[01:24] <TimToady> r: sub sametype (::T $, T $) { say "Same type" }; sametype 42,"foo"

[01:24] <p6eval> rakudo 636527: OUTPUT«Nominal type check failed for parameter ''; expected Int but got Str instead␤  in sub sametype at /tmp/tlkkCFc6DE:1␤  in block <anon> at /tmp/tlkkCFc6DE:1␤␤»

[01:24] <TimToady> hmm, that error message is LTA, should probably say 'parameter 2"

[01:25] <mdmkolbe> ok, that also makes sense.  Is there another visual pun about why the choice of "::" for that?

[01:26] <TimToady> that's more a historical accident, since :: is the nested package delimiter in Perl 5

[01:27] <TimToady> but we do at least trying to keep things looking different, even when there isn't an explicit visual metaphor

[01:28] <TimToady> all the metaoperators look very different from each other, and from normal operators

[01:28] <diakopter> sorear: is ~~ available in niecza's Test.pm?

[01:29] <TimToady> list infixes tend to be either tall or wide so they can be seen in the middle of two lists

[01:29] <sorear> diakopter: yes

[01:29] <diakopter> ah, there I see it

[01:29] <mdmkolbe> Ok, now my biggest question: roles vs classes.  Other than not being able to be instanciated, it looks like roles are a strict superset of the features of classes (maybe I missed something).  Why would I write with a class instead of always writing roles and then (so I can instanciate it) writting a dummy class that inherits from the role?

[01:30] <TimToady> roles are immutable; classes are mutable

[01:30] <TimToady> but if you use a role as if it were a class, it will "pun" an anonymous class for you

[01:31] <mdmkolbe> TimToady: the contents are immutable or the definition is immutable?

[01:31] <diakopter> sorear: I'd like to add this to rakudo https://gist.github.com/2856077  I was wondering what you thought about adding something like that to niecza.  for checking error messages.

[01:31] <TimToady> a role has no contents in the sense that a class does

[01:32] <TimToady> if a role has attributes, it really means that it *will* have attributes when instantiated

[01:33] <TimToady> but again, jnthn is the go-to-guy for all the nitty-gritty details

[01:33] <TimToady> but he's asleep right now

[01:33] <TimToady> something to do with living in Sweden...

[01:34] <mdmkolbe> TimToady: I'm still not understanding what part of a class can mutate that can't in a role.  We have rw attributes in a role right?

[01:34] <TimToady> you can add methods on the fly to a class, for instance, via monkey typing

[01:35] <TimToady> nr: use MONKEY_TYPING; augment class Int { method wave () { say "{self} waves" } }; 42.wave

[01:35] <p6eval> rakudo 636527, niecza v18-2-gea3d97a: OUTPUT«42 waves␤»

[01:36] <mdmkolbe> TimToady: ok, that clarifies the mutability.  Is there any reason to write classes (instead of roles) for something other than monkey typing?

[01:36] <TimToady> unlike in Ruby, this is discouraged, hence the need for "use MONKEY_TYPING"

[01:37] <TimToady> well, there's the whole inheritance tree thing, which is occasionally useful

[01:37] <TimToady> there's mixins...

[01:37] *** tokuhiro_ joined
[01:37] <mdmkolbe> Roles don't get those?

[01:37] <TimToady> nr: say so (0 but True)

[01:37] <p6eval> rakudo 636527, niecza v18-2-gea3d97a: OUTPUT«True␤»

[01:38] <TimToady> you can mixin in roles, but mixins use inheritance to derive an anonymous new class

[01:38] * colomon was just pondering a role as a completely abstract interface -- one method which is defined as { ... }

[01:38] <TimToady> s/ in /

[01:38] <TimToady> so mixins are always a relationship between two classes

[01:40] <sorear> mdmkolbe: Role/class punning makes me uneasy.  I think it's a huge hack conflating separate semantic domains, and I don't use it in any of my code

[01:40] *** tokuhiro_ left
[01:40] <sorear> mdmkolbe: one feature you lose if you go roles-only is the ability to override methods

[01:41] <sorear> diakopter: um.

[01:42] <sorear> diakopter: nom has regexes.

[01:42] <diakopter> I didn't type that

[01:42] <mdmkolbe> I'm willing to take it on authority that the two concepts can't be unified, but as a language designer/compiler writer I'm having difficulty seeing the benefit to separating the ideas.

[01:42] <diakopter> sorear: that's copied from eval_dies_ok

[01:42] <TimToady> roles are compile-time types, while classes are run-time types

[01:42] *** tokuhiro_ joined
[01:42] <TimToady> a class is more like a container of roles

[01:43] <sorear> diakopter: ah well

[01:43] <sorear> diakopter: go ahead, I don't mind that in nieczxa

[01:43] <mdmkolbe> sorear: I thought I saw an example of one role overriding a method it inherits from another role

[01:43] <diakopter> yay, glad to know you typo it too

[01:44] <TimToady> we don't say that roles inherit; they "compose"

[01:44] <diakopter> colomon: do you have commit access to rakudo?

[01:44] <TimToady> on one level roles are straight out of Smalltalk Traits

[01:45] <colomon> diakopter: should have it still, yes

[01:45] <sorear> I'm not saying that the concepts *can't* be unified

[01:45] <sorear> but I don't know of anyone who has read _Composable Units of Behavior_ and is comfortable with the idea

[01:45] <TimToady> confusing mutable containers with immutable contents tends to give optimizers hissyfits

[01:46] <diakopter> colomon: would you like to add my last gist to rakudo's Test.pm?  It would help me close a bunch of RT tickets to actually test for errors.  Where rakudo and niecza differ on the (both correct) error, the pattern can contain both.

[01:46] <TimToady> Perl 5 did that all over; in Perl 6 we're trying not to do it so often

[01:46] <diakopter> a bunch of the testneeded tickets on RT are for LTA errors

[01:47] <sorear> diakopter: I think that, nine times out of ten, it makes sense to standardize error messages

[01:47] <TimToady> when you try to combine the concepts of role and class you end up with monstrosities like "final classes"

[01:48] <mdmkolbe> TimToady: the compile-time/runtime distinction is semi-persuasive.  To explore your "container" explanation, would you say a class is similar to the v-table in C++ (i.e., it is the dynamic "thing" shared by multiple objects describing their behaviors)?

[01:49] <TimToady> well, v-tables are a mechanism to preserve some performance when you have to do late binding because you don't know what you're dealing with typewise (polymorphism)

[01:49] <mdmkolbe> (A role would then be the static "things" that can describe one part of that behavior.  A differene from C++ is that in C++ you only get one static "behavior thing" per dynamic "behavior thing")

[01:50] <sorear> although, as an optimizer writer, I want final in perl6 pretty badly

[01:50] <TimToady> roles are kind of a way to present more information to the compiler without (much) impacting the flexibility of the runtime

[01:50] <sorear> it would be *awesome* to know that within the scope of my Str $x; $x.chars can be turned into an offset pointer fetch

[01:50] <sorear> etc

[01:51] <sorear> you get some of that with multis, but not quite all

[01:51] <TimToady> sorear: final is available at CHECK time if a class has not been requested to stay open/non-final

[01:51] <colomon> diakopter: I don't mind making the change, but I would kind of like to wait long enough to make sure there's sone consensus on it...

[01:52] <colomon> *some

[01:53] <TimToady> S12:2132 for finalization rules

[01:56] <mdmkolbe> well I have to get back to writing for a conference deadline, thanks for answering my questions

[01:57] <diakopter> colomon: I figured sorear's assent to add the analogous method in niecza was enough consensus

[01:57] *** Guest67605 left
[01:58] <colomon> diakopter: and no one seems to be saying "No, no!"...

[01:58] <colomon> will be a few, I've not updated Rakudo in a couple of weeks.

[01:58] <colomon> *few minutes

[01:58] *** adu left
[02:00] <sorear> TimToady: the main problem with deferring stuff to CHECK time is that it reduces the benefit of precompiling the setting

[02:01] <sorear> I'll see what things are like after non-bootstrap gets a bit further

[02:05] *** Telgalizer left
[02:09] <diakopter> sorear: I'm definitely going to need help writing that for niecza's Test.pm6

[02:09] *** isBEKaml left
[02:11] <dalek> rakudo/nom: eff089b | (Solomon Foster)++ | lib/Test.pm:

[02:11] <dalek> rakudo/nom: Add diakopter++'s eval_dies_with_error.

[02:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eff089bffb

[02:11] <colomon> There you are.

[02:12] <diakopter> whee!

[02:15] <diakopter> colomon: thanks

[02:16] <colomon> no problem, hope it works okay!  ;)

[02:16] *** jaldhar joined
[02:23] *** jaldhar left
[02:25] *** jaldhar joined
[02:32] *** aesundstrom_ joined
[02:33] *** aesundstrom_ left
[02:35] *** kurahaupo joined
[02:41] *** kurahaupo left
[02:42] *** Chillance left
[02:55] *** tokuhiro_ left
[03:00] *** tokuhiro_ joined
[03:06] <TimToady> colomon: I thought you ported sets from niecza to rakudo at one point, or am I confabulating?

[03:07] *** tokuhiro_ left
[03:13] <sorear> niecza definitely has working sets

[03:13] <sorear> I remember the pain of getting all those extra operators to work in the setting

[03:13] <TimToady> indeed, using them in http://rosettacode.org/wiki/Set_consolidation#Perl_6

[03:14] <TimToady> but I was pretty sure rakudo had 'em too, and they seem to have evaporated

[03:14] <pmichaud> maybe try b: ?

[03:14] <pmichaud> b: say Set

[03:14] <p6eval> b 922500: OUTPUT«Set()␤»

[03:14] <pmichaud> looks like they existed in Beijing

[03:15] <pmichaud> I have to run some errands at the moment, but I'll be happy to port them

[03:15] <diakopter> Set is there, but I couldn't find the intersection or union operators

[03:15] <pmichaud> if nobody else beats me to it :)

[03:15] <pmichaud> I suggest stealing from niecza if possible :)

[03:15] <pmichaud> afk for a bit

[03:36] *** Telgalizer joined
[03:39] *** Telgalizer left
[03:53] *** b1rkh0ff joined
[04:17] *** cognominal_ joined
[04:19] *** Khisanth left
[04:20] *** cognominal left
[04:32] *** Khisanth joined
[05:01] *** thou left
[05:35] *** spaceships left
[05:36] *** jaldhar left
[05:41] *** jaldhar joined
[05:48] *** fgomez left
[06:05] *** stephenlb left
[06:25] <moritz> \o

[06:28] *** kaare_ joined
[06:39] <sorear> o/

[06:41] *** wamba joined
[06:49] *** cognominal_ left
[06:49] *** terrence joined
[06:51] *** cognominal joined
[06:57] *** cognominal left
[06:57] *** cognominal joined
[07:02] *** cognominal left
[07:02] *** wamba left
[07:04] *** cognominal joined
[07:07] *** terrence_ joined
[07:16] *** wamba joined
[07:25] *** cognominal_ joined
[07:26] <tadzik> o/

[07:27] <sorear> o/

[07:28] *** cognominal left
[07:36] *** wamba left
[07:37] *** birdwindupbird joined
[07:43] *** terrence_ left
[07:44] *** terrence left
[07:57] *** terrence joined
[07:57] *** terrence_ joined
[08:08] *** wamba joined
[08:09] *** mdmkolbe left
[08:15] <dalek> niecza/non-bootstrap: ba74410 | sorear++ | lib/ (2 files):

[08:15] <dalek> niecza/non-bootstrap: Op.pm6 translation, part 2

[08:15] <dalek> niecza/non-bootstrap: review: https://github.com/sorear/niecza/commit/ba74410265

[08:15] <dalek> niecza/non-bootstrap: 7aa4b5e | sorear++ | lib/ (6 files):

[08:15] <dalek> niecza/non-bootstrap: Use new array munging helpers whereever possible in the kernel

[08:15] <dalek> niecza/non-bootstrap: review: https://github.com/sorear/niecza/commit/7aa4b5e9a3

[08:40] *** sergot joined
[08:40] <sergot> hi o/

[08:40] <sorear> o/

[08:41] *** odoacre left
[08:41] *** odoacre joined
[08:46] <sorear> what's really remarkable here is that in the code I've converted so far, the blowup factor has only been on the order of 50%

[08:46] <sorear> I was expecting it to more like triple the size

[08:48] *** GlitchMr joined
[09:01] *** araujo joined
[09:01] *** araujo left
[09:01] *** araujo joined
[09:09] *** imarcusthis joined
[09:11] *** brrt joined
[09:12] <dalek> niecza/non-bootstrap: a315a5c | sorear++ | lib/Op.cs:

[09:12] <dalek> niecza/non-bootstrap: Op, part 3

[09:12] <dalek> niecza/non-bootstrap: review: https://github.com/sorear/niecza/commit/a315a5cdf1

[09:12] <sorear> sleep&

[09:16] <GlitchMr> Just wondering, is hash key order preserved in Perl 6?

[09:17] <GlitchMr> ok, it doesn't look like it preserves

[09:20] *** birdwindupbird left
[09:24] *** lazyking joined
[09:25] <GlitchMr> perl6: 1, 2 XXX 3, 4

[09:25] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "XX"␤    expecting operator␤    at /tmp/Up9OlShodJ line 1, column 7␤»

[09:25] <p6eval> ..rakudo eff089, niecza v18-2-gea3d97a:  ( no output )

[09:25] <GlitchMr> nr: print (1, 2 XXX 3, 4).perl

[09:25] <p6eval> niecza v18-2-gea3d97a: OUTPUT«(1, 3, 1, 4, 2, 3, 2, 4).list»

[09:25] <p6eval> ..rakudo eff089: OUTPUT«((ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),)).list»

[09:27] <GlitchMr> perl6: @a = 1, 2, 3; @a»++; print (@a).perl

[09:27] <p6eval> pugs: OUTPUT«*** ␤    Unexpected " ="␤    expecting "::"␤    Variable "@a" requires predeclaration or explicit package name␤    at /tmp/26P58UzCrd line 1, column 3␤»

[09:27] <p6eval> ..rakudo eff089: OUTPUT«===SORRY!===␤Variable @a is not declared␤at /tmp/T0SLkdESvg:1␤»

[09:27] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«===SORRY!===␤␤Variable @a is not predeclared at /tmp/MIukkvMkOx line 1:␤------> <BOL>⏏@a = 1, 2, 3; @a»++; print (@a).perl␤␤Variable @a is not predeclared at /tmp/MIukkvMkOx line 1:␤------> @a = 1, 2, 3; ⏏…

[09:27] <GlitchMr> perl6: my @a = 1, 2, 3; @a»++; print (@a).perl

[09:27] <p6eval> niecza v18-2-gea3d97a: OUTPUT«[2, 3, 4].list»

[09:27] <p6eval> ..pugs: OUTPUT«\(1, 2, 3)»

[09:27] <p6eval> ..rakudo eff089: OUTPUT«Array.new(2, 3, 4)»

[09:28] *** birdwindupbird joined
[09:29] *** wamba left
[09:30] <GlitchMr> As for mutable grammars: http://paste.uk.to/ad5489c4

[09:31] <GlitchMr> They are very flexible :).

[09:31] <GlitchMr> ... except I've noticed problem with my function

[09:31] <GlitchMr> For 0! it returns 0 :(

[09:33] <GlitchMr> sub postfix:<!> { [*] 1 .. $^a or 1 }

[09:34] <GlitchMr> This should fix it.

[09:35] *** birdwindupbird left
[09:35] *** birdwindupbird joined
[09:43] *** birdwindupbird left
[09:47] *** wamba joined
[09:47] *** cognominal joined
[09:50] *** cognominal_ left
[09:58] *** sporous joined
[09:59] <jnthn> ohhai o/

[10:02] <jnthn> r: say Set

[10:02] <p6eval> rakudo eff089: OUTPUT«Set()␤»

[10:02] <jnthn> I think we have the set type, but not the unicode-y operators

[10:06] *** birdwindupbird joined
[10:14] *** birdwindupbird left
[10:21] *** spider-mario joined
[10:31] *** whiteknight joined
[10:32] *** whiteknight is now known as Guest1193

[10:36] *** birdwindupbird joined
[10:47] <Woodi> hallo

[10:48] <jnthn> o/ Woodi 

[10:49] *** odoacre left
[10:49] *** odoacre joined
[10:52] <Woodi> mdmkolbe: classes and roles are near the same, roles are kind of primitive classes. difference is that roles are addition to inheritance hierarchy. if you have Figure -> Square | Circle hierarchy and want to add Logging functionality in pure OO you should add it to superclass and pollute all hierarchy. with roles/interfaces you just plug-in when it is needed. so for me it is mainly for keeping classes small, clean, reusable, etc, etc...

[10:52] *** lazyking left
[10:53] *** lazyking joined
[10:53] <jnthn> Well, I tend to see roles as more the unit of resuse

[10:53] <jnthn> Classes are probably still the unit of responsibility.

[10:53] <jnthn> (As in, SRP.)

[10:54] <Woodi> reuse of roles or classes ?

[10:56] <jnthn> Woodi: I tend to think of roles as the way to factor re-usable concepts, and classes gather them together into an object that covers a responsibility.

[10:57] <jnthn> Consider how the Perl 6 metamodel is factored.

[10:57] <jnthn> We have roles like Naming, MROBasedMethodDispatch, C3MRO, AttributeContainer

[10:57] <jnthn> All of these cover concepts, but aren't any use in and of themselves.

[10:58] <jnthn> By contrast, the classes - like ClassHOW - compose various roles and add the extra bits needed in order to satisfy the responsibility (in this case, ClassHOW is responsible for implementing the semantics of Perl 6 classes).

[11:00] *** JimmyZ_ joined
[11:00] <jnthn> Now, you *can* re-use ClassHOW. That's what GrammarHOW does, by inheriting from it. But inheritance is only a tool for behavior specialization, so it's only applicable to a fairly restricted range of re-use possibilities.

[11:01] <jnthn> For more re-use, we then turn to composition...so it's not really so surprising to find that roles, our tool for re-use, are compositional in nature.

[11:05] *** mucker joined
[11:07] *** Chillance joined
[11:16] * moritz back

[11:18] *** fridim_ joined
[11:19] <jnthn> good afty, moritz o/

[11:21] *** tokuhiro_ joined
[11:22] *** lazyking left
[11:25] *** lazyking joined
[11:25] <Woodi> jnthn: I mean roles and classes are the same on syntactic lvl so it realy seems you can not have roles. and it is small twist becouse interfaces in Java comes first and they come near without implementation so "code re-use" seems strange on first look :) anyway I need to learn better responsibility vs behaviour... 

[11:29] <colomon> TimToady: I didn't port sets to rakudo, someone else (maybe moritz++?) did.

[11:29] <tadzik> I did, I think

[11:29] * jnthn thinks it was tadzik++

[11:30] <tadzik> git blames me

[11:30] <moritz> and I think the reason for not having the set operators was that having non-Latin-1 characters inside the setting slowed things down considerably

[11:30] <jnthn> Suddenly QRegex!

[11:30] <moritz> but I think that now, after qbootstrap, that's not a problem anymore

[11:30] <jnthn> Right, it really shouldn't be now.

[11:31] <tadzik> fwiw, I didn't port them for no reason. Just didn't :)

[11:31] <tadzik> or I can't recall any blockers

[11:32] *** mucker left
[11:33] *** mucker joined
[11:37] *** araujo left
[11:38] *** araujo joined
[11:52] *** terrence_ left
[11:52] *** terrence left
[11:53] *** mucker left
[11:53] *** brrt left
[12:03] *** wamba left
[12:07] <moritz> r: role A [$] { }; class B { }; class C is B { }; say A[C] ~~ A[B]

[12:07] <p6eval> rakudo eff089: OUTPUT«True␤»

[12:07] <moritz> r: role A [$] { }; class B { }; class C is B { }; say A[B] ~~ A[C]

[12:07] <p6eval> rakudo eff089: OUTPUT«False␤»

[12:07] *** xinming_ joined
[12:10] *** xinming left
[12:10] *** wamba joined
[12:14] *** mucker joined
[12:33] <GlitchMr> I have proposal which shouldn't be ever implemented.

[12:34] <tadzik> then for whom is that proposal?

[12:34] *** mucker left
[12:34] <GlitchMr> sub query $query {} # if doesn't require parenthesis, so why sub would need...

[12:35] <GlitchMr> (but seriously, I think that parenthesis are good)

[12:35] <moritz> r: sub query { }; say query # look, no parens :-)

[12:35] <p6eval> rakudo eff089: OUTPUT«Nil␤»

[12:37] <arnsholt> moritz: Oooh, does that mean the role parameter bug is fixed?

[12:42] *** thou joined
[12:49] <moritz> arnsholt: no, that's a different one

[12:50] <moritz> r: class A { }; role R { }; say (A.new but R) ~~ (A.new but R)

[12:50] <p6eval> rakudo eff089: OUTPUT«False␤»

[12:50] <moritz> r: class A { }; role R { }; say (A.new but R) ~~ (A but R)

[12:50] <p6eval> rakudo eff089: OUTPUT«False␤»

[12:50] <moritz> that's the one

[12:57] *** ponbiki joined
[13:07] *** slavik1 joined
[13:08] *** Psyche^ joined
[13:10] <arnsholt> Oh well =)

[13:11] *** Patterner left
[13:11] *** Psyche^ is now known as Patterner

[13:15] *** thou left
[13:17] <arnsholt> jnthn: OOC, how hard d'you think it'd be to fix the (A.new but R) !~ (A.new but R) bug?

[13:19] <jnthn> arnsholt: We don't cache the mixins we produce at all at the moment.

[13:19] <jnthn> arnsholt: It's probably not too hard.

[13:20] <jnthn> Shouldn't need any C work, just NQP stuff

[13:23] <arnsholt> Cool. I might try to look into it when I get some tuits

[13:24] *** crab2313 joined
[13:25] <jnthn> Go for it. I'm gonna be on alternation LTM and pre-comp fixes for the a bit.

[13:30] <arnsholt> Spiffy. LTM are pre-compilation are definitely cooler than mixin bugs =)

[13:33] *** cognominal_ joined
[13:34] *** wamba left
[13:36] *** cognominal left
[13:52] *** mucker joined
[14:20] *** terrence joined
[14:34] *** plobsing left
[14:36] *** terrence left
[14:36] <TimToady> nr: sub postfix:<!> { [*] 1 .. $^a }; say 0!

[14:36] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«1␤»

[14:36] *** plobsing joined
[14:36] <TimToady> GlitchMr: where do you get the idea that it returns 0?

[14:37] <GlitchMr> Weird...,

[14:37] <GlitchMr> Possibly because I had old version of Niecza

[14:38] *** sudokode left
[14:38] <TimToady> could be

[14:38] <GlitchMr> I've updated it and it works correctly

[14:38] <GlitchMr> I had two months old version of Niecza

[14:39] <TimToady> I don't remember when niecza implemented nullary defaults

[14:39] <TimToady> nr: my $a; $a *= 42; say $a

[14:39] <p6eval> rakudo eff089: OUTPUT«42␤»

[14:39] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1262 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 296 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/i3lpZCWKpW line 1 (mainlin…

[14:40] <TimToady> there's another spot that could use some work

[14:40] <TimToady> same notion though

[14:41] <moritz> two months can be a lot of time in p6 land :-)

[14:41] <TimToady> I think that's about the half life of my brain cells nowadays...

[14:42] <TimToady> nr: my $a; $a min= 42; say $a

[14:42] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Any()␤»

[14:42] <p6eval> ..rakudo eff089: OUTPUT«42␤»

[14:43] <TimToady> nr: my $a; $a max= 42; say $a

[14:43] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«42␤»

[14:44] <TimToady> nr: my $a; $a &&= 42; say $a

[14:44] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«Any()␤»

[14:44] <moritz> hey, people actually use 'nr' and 'rn' :-)

[14:44] <moritz> 

[14:44] <tadzik> it would seem so :)

[14:45] <TimToady> nr: say [&&]()

[14:45] <p6eval> niecza v18-2-gea3d97a: OUTPUT«===SORRY!===␤␤This macro cannot be used as a function at /tmp/0cuR56ROwa line 1 (EOF):␤------> say [&&]()⏏<EOL>␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1401 (die @ 5) ␤  at…

[14:45] <p6eval> ..rakudo eff089: OUTPUT«True␤»

[14:45] <TimToady> arguably, if [&&] returns true, so should &&= 42

[14:45] *** zby_home joined
[14:46] <TimToady> nr: my $a; $a &= 42; say $a

[14:46] <moritz> nr: say True && 42

[14:46] <p6eval> rakudo eff089: OUTPUT«all(all(), 42)␤»

[14:46] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«(timeout)»

[14:46] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«42␤»

[14:47] <TimToady> nr: say so all()

[14:47] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«True␤»

[14:47] <TimToady> &= 42 can just return all(42) there, I'd think

[14:49] *** terrence joined
[14:49] <moritz> r: say all(all(), 42) ~~ 42

[14:49] <p6eval> rakudo eff089: OUTPUT«all(all(), True)␤»

[14:49] <moritz> r: say so all(all(), 42) ~~ 42

[14:49] <p6eval> rakudo eff089: OUTPUT«True␤»

[14:49] <moritz> though it seems they are equivalent

[14:50] <TimToady> nr: my $a; $a ^= 42; say $a

[14:50] <p6eval> niecza v18-2-gea3d97a: OUTPUT«(timeout)»

[14:50] <p6eval> ..rakudo eff089: OUTPUT«one(one(), 42)␤»

[14:51] <TimToady> probably repeated ^= cannot be the same as [^]

[14:52] <TimToady> nr: my $a; $a ^= 42; $a ^= "oops"; say $a

[14:52] <p6eval> niecza v18-2-gea3d97a: OUTPUT«(timeout)»

[14:52] <p6eval> ..rakudo eff089: OUTPUT«one(one(one(), 42), oops)␤»

[14:52] <TimToady> nr: my $a; $a ^= 42; $a ^= "oops"; $a ^= "true again?"; say $a

[14:52] <p6eval> niecza v18-2-gea3d97a: OUTPUT«(timeout)»

[14:52] <p6eval> ..rakudo eff089: OUTPUT«one(one(one(one(), 42), oops), true again?)␤»

[14:53] <TimToady> nr: my $a; $a ^= 42; $a ^= "oops"; $a ^= "true again?"; say so $a

[14:53] <p6eval> niecza v18-2-gea3d97a: OUTPUT«(timeout)Stacktrace:␤␤  at (wrapper managed-to-native) object.__icall_wrapper_mono_object_isinst (object,intptr) <0xffffffff>␤  at Niecza.Kernel.UnboxAny<T> (Niecza.P6any) <0x0002b>␤  at Niecza.CtxJunctionBool.Get (Niecza.Variable) <0x000f7>␤  at Niecza.Ctx…

[14:53] <p6eval> ..rakudo eff089: OUTPUT«True␤»

[14:53] <TimToady> ooh, kaboomy!

[14:54] *** crab2313 left
[14:54] *** xinming_ left
[14:55] <zby_home> hi there - is this a help channel?

[14:55] <TimToady> only for Perl 6, not for Perl 5

[14:55] <tadzik> hello zby_home 

[14:55] <TimToady> unless you're thinking about jumping off a bridge, in which case, yes, it is :)

[14:56] *** crab2313 joined
[14:56] <zby_home> http://nopaste.snit.ch/143026

[14:57] <tadzik> r: class A { }; say A.new.^name.perl

[14:57] <zby_home> I can call WHAT from outside but not from inside?

[14:57] <p6eval> rakudo eff089: OUTPUT«"A"␤»

[14:57] <TimToady> WHAT is not a real method, it's just a macro

[14:57] <tadzik> zby_home: consider using that ^

[14:57] <zby_home> aha

[14:57] <zby_home> thanks

[14:57] <tadzik> although someone will probably smack me for suggesting an evil thing :)

[14:58] <TimToady> self.WHAT oughta work there

[14:59] <TimToady> I don't see why you need an extra .new

[14:59] <zby_home> "Non-declarative sigil is missing its name" this was for replacing it with "method ref { $.^name.perl }"

[15:00] <TimToady> use self.^name

[15:00] <zby_home> "method ref { self.WHAT.perl }" worked!

[15:00] <moritz> hm, interesting

[15:00] <TimToady> nobody's bothered to define the $.WHAT form of the macro

[15:01] <moritz> currently $thing.name does all the 'is "name" the name of a macro-ish method?' checking

[15:01] <moritz> but $.name does not

[15:01] <moritz> I guess it should. Should it?

[15:02] * TimToady waffles

[15:02] * moritz pancakes

[15:02] *** spaceships joined
[15:02] * TimToady wonders how "waffles" came to mean that

[15:03] <moritz> maybe there was a culture where people exchanged meaningless gossip while eating waffles?

[15:03] <moritz> sounds certainly like a nice culture. I love waffles :-)

[15:05] <TimToady> not apparently related to waffle the flat edible, probably from obsolete 'waff', to yelp

[15:05] <TimToady> unless people used to yelp when they saw a waffle...

[15:05] <TimToady> according to the AmHer

[15:06] <TimToady> .[*-1,*-2] = .[*-2,*-1]

[15:09] <TimToady> nr: my $_ = [<w a f f l e>]; .[*-1,*-2].=reverse; .say

[15:09] <p6eval> rakudo eff089: OUTPUT«===SORRY!===␤Redeclaration of symbol $_␤at /tmp/pr8gGwj_X7:1␤»

[15:09] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $_ (see  line 0) at /tmp/xyLWlzD_2Y line 1:␤------> my $_ ⏏= [<w a f f l e>]; .[*-1,*-2].=reverse; ␤␤Unhandled exception: Unable to resolve method reverse in type Parcel␤  at /tm…

[15:09] <TimToady> r: $_ = [<w a f f l e>]; .[*-1,*-2].=reverse; .say

[15:09] <p6eval> rakudo eff089: OUTPUT«w a f f e l␤»

[15:10] *** cognominal_ left
[15:11] <TimToady> a nieczabug, perhaps, unless someone can argue that rakudo is wrong to make it work :)

[15:11] *** cognominal_ joined
[15:11] *** terrence left
[15:12] <TimToady> n: $_ = [<w a f f l e>]; .[*-1,*-2].=reverse; .say

[15:12] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: Unable to resolve method reverse in type Parcel␤  at /tmp/usOFskbmTX line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3912 (module-CORE @ 558) ␤  at /h…

[15:12] <TimToady> n: $_ = [<w a f f l e>]; .[*-1,*-2] = .[*-1,*-2].reverse; .say

[15:12] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: Unable to resolve method reverse in type Parcel␤  at /tmp/7XVWKtBmVS line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3912 (module-CORE @ 558) ␤  at /h…

[15:12] <tadzik> can anyone peek at https://gist.github.com/2858778 ?

[15:12] <tadzik> for some reason an exception is rethrown there

[15:13] *** brrt joined
[15:13] <TimToady> nice prompt :)

[15:13] <tadzik> why, thank you :)

[15:14] <tadzik> moritz: have a second?

[15:15] <diakopter> TimToady: there were wafflemakers at Texas A&M's cafeteria that you flipped back and forth, rotating them 180 and back.

[15:15] <tadzik> it's the existence of CATCH block that rethrows it

[15:15] <tadzik> even if it's empty

[15:16] <TimToady> an empty catch block needs a default to catch everything

[15:17] <TimToady> it's the action of succeeding a case that marks the exception as caught

[15:18] <TimToady> dropping out the bottom will always rethrow

[15:19] <tadzik> hmm

[15:19] <jnthn> Yes, wrap it in a default { ... }

[15:20] <jnthn> $.WHAT - the things people thing of... :)

[15:20] <jnthn> *think

[15:20] <tadzik> yeah, default fixes that

[15:20] <tadzik> was it always this way in Rakudo?

[15:20] <TimToady> if it wasn't, it was a bug

[15:20] <jnthn> tadzik: Not always, but it's been for quite a while now.

[15:20] <tadzik> understood

[15:20] <tadzik> I don't CATCH enough exception I guess :)

[15:20] <TimToady> it's always been specced this way

[15:21] <TimToady> well, except before it was specced at all...

[15:21] <jnthn> Yeah, Rakudo had a rather handwavey implementation of exceptions a while back :)

[15:22] <diakopter> TimToady: in a WhateverCode of a sequence generator, is the current list index available as a variable?

[15:22] <TimToady> no

[15:22] <jnthn> You could potentially use a state var to track it

[15:22] <TimToady> this usually means you shouldn't be using ...

[15:22] * diakopter wonders how to make an efficient lazy list of the factorials

[15:23] <flussence> r: say |.push: .pop, .pop given 'waffle'.comb # handy thing, that pipe.

[15:23] <p6eval> rakudo eff089: OUTPUT«waffel␤»

[15:23] <TimToady> factorial doesn't need absolute index

[15:23] <TimToady> only relative, which ... already provides

[15:25] <diakopter> how might factorials look

[15:26] *** brrt1 joined
[15:26] <jnthn> 1, 1, *+* ... *

[15:26] <jnthn> oh wait

[15:26] <jnthn> that's...grr

[15:26] <jnthn> :)

[15:26] <TimToady> yeah, me too

[15:26] <TimToady> at least I have the excuse that it's morning

[15:26] *** cognominal___ joined
[15:27] <jnthn> Morning is a relative concept :)

[15:27] * diakopter decides to get waffles from the local greasy spoon

[15:27] *** brrt left
[15:27] <TimToady> nr: my @fact = [\*] 1..*; say @fact[10]

[15:27] <p6eval> niecza v18-2-gea3d97a: OUTPUT«(timeout)»

[15:28] <p6eval> ..rakudo eff089: OUTPUT«39916800␤»

[15:28] <TimToady> diakopter: that's what you're loking for

[15:28] <jnthn> r: say (1, { $_ * ($_ + 1) }, ... *)[^10]

[15:28] <p6eval> rakudo eff089: OUTPUT«===SORRY!===␤Comma found before apparent series operator; please remove comma (or put parens␤    around the ... listop, or use 'fail' instead of ...) at line 2, near " ... *)[^1"␤»

[15:28] *** cognominal_ left
[15:28] <jnthn> r: say (1, { $_ * ($_ + 1) } ... *)[^10]

[15:28] <p6eval> rakudo eff089: OUTPUT«1 2 6 42 1806 3263442 10650056950806 113423713055421844361000442 12864938683278671740537145998360961546653259485195806 165506647324519964198468195444439180017513152706377497841851388766535868639572406808911988131737645185442␤»

[15:28] <jnthn> oh, dang

[15:28] *** spaceships left
[15:28] * jnthn shouldn't do anything hard on a weekend :)

[15:29] * TimToady wonders what the verb "loke" would mean...

[15:30] <TimToady> anyhoo, ... is one of those attractive hammers that makes things look like a nail

[15:30] <TimToady> in this case a triangle reduction works much better

[15:30] <jnthn> Aye, it's very nice.

[15:31] <zby_home> http://nopaste.snit.ch/143032

[15:31] <jnthn> r: my @fact = [\*] 1..*; say @fact[100]

[15:31] <p6eval> rakudo eff089: OUTPUT«9425947759838359420851623124482936749562312794702543768327889353416977599316221476503087861591808346911623490003549599583369706302603264000000000000000000000000␤»

[15:31] <zby_home> I need to dynamically load a class and then check if it isa another class

[15:31] *** fgomez joined
[15:32] <TimToady> zby_home: could be an XY problem

[15:33] <zby_home> it is for a Catalyst like dispatcher

[15:33] <zby_home> it loads classes under MyApp/Controller

[15:33] <zby_home> and checks if they are subclasses of something - just to be sure that I can dispatch there

[15:33] <jnthn> ::($c) is what you need for an indirect lookup. And don't do string .isa

[15:34] <jnthn> .isa(A) is fine, or just smartmatch against the superclass.

[15:34] <jnthn> r: my $c = 'Test'; require $c; say 'alive'

[15:34] <p6eval> rakudo eff089: OUTPUT«alive␤»

[15:34] <jnthn> Yeah, that bit works.

[15:35] <zby_home> hmm ::($c).isa( 'A' ); worked for me

[15:36] <zby_home> but not with isa ( A )

[15:37] <jnthn> Well, is A in scope?

[15:37] <zby_home> P is A

[15:38] <zby_home> I require P so it should load A

[15:38] <zby_home> I don't know if that means A is in scope

[15:38] <zby_home> but it fails as if it was not

[15:38] <jnthn> It isn't; you should explicitly use the thing that contains A.

[15:38] <zby_home> but with that string isa it worked

[15:38] <jnthn> As type names need to exist at compile time.

[15:38] <jnthn> Otherwise, they'll be considered list ops.

[15:38] <zby_home> aha

[15:38] <zby_home> OK

[15:39] *** sudokode joined
[15:39] *** birdwindupbird left
[15:40] <TimToady> nr: https://gist.github.com/2847343

[15:40] <p6eval> rakudo eff089: OUTPUT«Cannot call 'push'; none of these signatures match:␤:(Any:U \$self, *@values, Mu *%_)␤␤  in method push at src/gen/CORE.setting:1169␤  in block <anon> at /tmp/GPAAh6hTnH:6␤  in method reify at src/gen/CORE.setting:5045␤  in method reify at src/gen/CORE.setting:4940…

[15:40] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«[[1, 2], [], [3, 4]]␤[[1, 3], [], [2, 4]]␤[[1, 4], [], [2, 3]]␤[[2, 3], [], [1, 4]]␤[[2, 4], [], [1, 3]]␤[[3, 4], [], [1, 2]]␤»

[15:41] *** ponbiki left
[15:41] <TimToady> afk &

[15:41] <jnthn> Yes, that one probably needs me to fix the phasers/recursion issue.

[15:55] *** tokuhiro_ left
[15:59] <cognominal___> hi, what is the rational of outlawed nqp:: opcode?

[16:00] <tadzik> they're too Parrot-specific

[16:00] <jnthn> cognominal___: See discussion here for details but - the ones we outlawed are too close to how Parrot works.

[16:01] <cognominal___> I don't understand, that means rakudo will be always parrot specific?

[16:02] <moritz> no

[16:02] <moritz> it means we'll have to have backend-specific code

[16:02] <moritz> or find better abstractions

[16:04] <jnthn> Many of the cases we have at the moment mean "we didn't 6model-ize something yet"

[16:04] <jnthn> PAST => QAST will remove a bunch of 'em, for example.

[16:04] <cognominal___> ok, thx for the explanation

[16:04] * diakopter likes how my ubuntu vm restarts in like 5 seconds

[16:05] <cognominal___> diakopter, just installed it in a virtualbox and I was amazed

[16:06] <tadzik> huh, what

[16:06] <diakopter> vmware player on windows and vmware fusion on mac are my fav

[16:06] <cognominal___> tried to install smartos but did not figure out to see a virtual nic.

[16:06] * diakopter goes to figure out eval_dies_with_error for niecza

[16:15] <GlitchMr> How can I specify any numeric type in static typing

[16:16] <GlitchMr> By that I mean, Int, Rat, Num and Complex

[16:16] <GlitchMr> (and probably other numeric types)

[16:17] *** mucker left
[16:18] <GlitchMr> ok, found it

[16:18] <GlitchMr> I've to use "Real" type

[16:21] <jnthn> Note that Complex is not in Real. If you want to accept that too, use Numeric

[16:22] *** lazyking left
[16:24] <GlitchMr> nr: print (-> (Numeric $x) { $x })(5)

[16:24] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: Unable to resolve method Capture in type Int␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/dG7JICrkpW line 0 (ANON @ 1) ␤  at /tmp/dG7JICrkpW line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3911 (ANON @ 3) ␤  …

[16:24] <p6eval> ..rakudo eff089: OUTPUT«Not enough positional parameters passed; got 0 but expected 1 in sub-signature␤  in block <anon> at /tmp/vd5Gwsvus3:1␤␤»

[16:24] <GlitchMr> What am I doing wrong?

[16:25] <jnthn> Parents

[16:25] <jnthn> er

[16:25] <jnthn> parens

[16:25] <GlitchMr> Oh wait, -> is not for functions

[16:25] <jnthn> It is

[16:25] <jnthn> But you do not put the signature in parens

[16:25] <jnthn> r: print (-> Numeric $x { $x })(5)

[16:25] <p6eval> rakudo eff089: OUTPUT«5»

[16:25] <moritz> if you do, it is parsed as a subsignature

[16:25] <jnthn> Right.

[16:26] <moritz> that's why rakudo's error message says "in sub-signature"

[16:27] <[Coke]> ZOMGWTFBBQ.

[16:28] <jnthn> [Coke]: Hope the weather is better where you are for a BBQ than it is here :P

[16:29] <dalek> niecza: 2a30970 | diakopter++ | lib/Test.pm6:

[16:29] <dalek> niecza: analogous eval_dies_with_error for niecza

[16:29] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2a309708f6

[16:30] <moritz> diakopter: I hope you're not putting stuff in roast that uses eval_dies_with_error

[16:31] <GlitchMr> Why not?

[16:32] <moritz> because there's a  much more general throws_like being developed in S32-exceptions/misc.t that can also handle typed exceptions properly

[16:32] <GlitchMr> Also, does anybody ever uses those "review" links?

[16:32] <moritz> yes

[16:33] <GlitchMr> (oh wait)

[16:33] <GlitchMr> Whatever

[16:33] <diakopter> moritz: this works in niecza too?

[16:33] *** JimmyZ_ left
[16:33] <moritz> diakopter: probably not

[16:34] <diakopter> I needed something that works in niecza too

[16:34] <GlitchMr> nr: print 5 + now

[16:34] <p6eval> rakudo eff089: OUTPUT«Instant:1338654905.306785»

[16:34] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«Unhandled exception: Cannot use value like Instant as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 295 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/KgbNVolrrJ line 1 (mainline @ 3)…

[16:34] <moritz> then match againt "$!" in the tests for now

[16:34] <moritz> introducing an inferior standard when a better one is emerging is harmful

[16:34] <GlitchMr> Why I cannot do this in Niecza? Not implemented?

[16:35] <dalek> roast: 30363b2 | moritz++ | S05-mass/rx.t:

[16:35] <dalek> roast: avoid &say in case of a test failre (to not confuse test harness)

[16:35] <dalek> roast: review: https://github.com/perl6/roast/commit/30363b26e6

[16:35] *** xinming joined
[16:35] <diakopter> moritz: ok, feel free to remove the eval_dies_with_error in Test.pm

[16:36] <diakopter> this just slows me down considerably for closing tickets

[16:36] <diakopter> and means tons of duplicated code

[16:36] <diakopter> in roast

[16:36] <moritz> diakopter: the proper way is not to check exception messages, but to throw typed exceptions, and check the type

[16:36] <GlitchMr> niecza: use Threads; Thread.new(42); # Shouldn't crash whole interpreter

[16:37] <p6eval> niecza v18-2-gea3d97a: OUTPUT«␤Unhandled Exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.Frame.MakeChild (Niecza.Frame outer, Niecza.SubInfo info, Niecza.P6any sub) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.GetInferi…

[16:37] <moritz> everything else is technical debt

[16:37] <diakopter> moritz: that's a very narrow view

[16:37] <moritz> (and yes, that's much slower to implement, I know)

[16:37] <moritz> diakopter: but from long experience with roast and several implementations

[16:37] <dalek> niecza: 014fec3 | diakopter++ | lib/Test.pm6:

[16:37] <dalek> niecza: remove eval_dies_with_error

[16:37] <dalek> niecza: review: https://github.com/sorear/niecza/commit/014fec34be

[16:38] <GlitchMr> Weird, it caused "Program stopping working" in Windows

[16:38] <diakopter> moritz: ok, feel free to remove the eval_dies_with_error in rakudo's Test.pm (that colomon added for me)

[16:38] <diakopter> moritz: I guess I'll give up on closing these RT tickets then, becaues it's too hard

[16:39] <diakopter> because someone will have to make all these exceptions for niecza and rakudo before these tickets can be closed

[16:40] *** wamba joined
[16:40] *** wamba left
[16:41] *** wamba joined
[16:41] <diakopter> I am complaining about this; adding tests to compare against $! is just as much technical debt as using a new (could be TEMPORARY) function in Test.pm

[16:42] <diakopter> and even more technical debt, I'm arguing, because they're even harder to find in the test suite to replace once the new standard is used, if ever

[16:42] <diakopter> using a function in Test.pm makes them all easy to find at once

[16:43] <jnthn> diakopter: But some folks (especially moritz++) *has* been adding a load of these typed exceptions in Rakudo and taking care of designing them into a nice structure.

[16:44] <jnthn> diakopter: I think it's even documented somewhere how to do it.

[16:44] <jnthn> There's probably into the 100s of 'em by now.

[16:45] <diakopter> I knew about this. that doesn't factor into what I'm saying. once they're implemented in niecza too, I think they can be used in roast

[16:45] <jnthn> That makes no sense. If we worked like that, roast would only be allowed to contain tests that Rakudo and Niecza could both pass :)

[16:45] <diakopter> that's not what I was saying.

[16:46] <jnthn> Shouldn't leave Pugs out either ;)

[16:46] <diakopter> the RT tickets address LTA error messages, not exceptions.

[16:46] <diakopter> so the corresponding tests should be about the error messages, not exceptions.

[16:47] <diakopter> so I'm arguing that I should be able to compare against the text of an error message in roast, that's all, and I wanted a function in Test to do that.

[16:47] <diakopter> I wanted to be able to test them in niecza too.

[16:47] <GlitchMr> http://perlcabal.org/syn/S29.html#Obsolete_Functions

[16:47] <GlitchMr> %() function?

[16:49] <moritz> diakopter: my point is that even smart-matching against "$!" is technical debt, and making it easier to write technical debt isn't progress

[16:49] <diakopter> jnthn: I can't test against the exceptions in niecza, so I need to compare against error message text.  I don't want to write two tests, one for rakudo and one for niecza, one testing the exception and one checking error message text.

[16:49] *** snearch joined
[16:50] <diakopter> moritz: I fully disagree.  if the technical debt needs to be written, making it easier to write is TOTALLY better.

[16:50] <jnthn> diakopter: Then write it in the way that is the emerging standard for doing these things (the typed exceptions) and Niecza will come to pass it once it implements the typed exceptions.

[16:50] <moritz> diakopter: but it doesn't need to be written

[16:50] <GlitchMr> Isn't that function called infix:<%> now?

[16:50] <diakopter> moritz: why not?  these tickets don't need closed?  We don't need to compare against the text of error messages?

[16:50] <moritz> diakopter: the tests can be written to use typed exceptions, and then niecza doesn't pass them.

[16:51] <GlitchMr> And I don't think that Perl 5 had %() function

[16:51] <jnthn> diakopter: The LTA tickets aren't usually so much about the wording as the failure mode.

[16:51] <jnthn> diakopter: Most of them really are that stuff fails in the wrong way/for the wrong reason

[16:52] <jnthn> A typed exception is a much better way to assess whether the failure mode was correct.

[16:52] <jnthn> Imagine one day we localize things so the errors are in $other-language. Tests looking at the typed exceptions will be fine. Ones that looked at exact wording, less so.

[16:55] <diakopter> as I said twice already, feel free to revert colomon's commit from last night

[16:55] <diakopter> I already reverted it in niecza

[16:59] <diakopter> jnthn: I wasn't arguing that it wasn't technical debt (which it seems you are trying to convince me of).

[17:00] <diakopter> jnthn: I am reacting confusedly to moritz's conflicting suggestions to compare against $! in roast, and catch typed exceptions in roast.

[17:00] <diakopter> first comparing against $! is okay, and then it's not.

[17:01] <moritz> diakopter: ok, my first reaction was wrong. Comparing against $! isn't good.

[17:01] <moritz> diakopter: sorry for the confusion

[17:01] <diakopter> the entire rest of my argument was based on that

[17:01] <diakopter> obviously.

[17:02] <moritz> yes, sorry about that

[17:02] <dalek> rakudo/nom: 5d36100 | moritz++ | lib/Test.pm:

[17:02] <dalek> rakudo/nom: remove eval_dies_with_error

[17:02] <dalek> rakudo/nom: 

[17:02] <dalek> rakudo/nom: the proper way are typed exceptions; a helper function for those

[17:02] <dalek> rakudo/nom: is currently being developed in t/spec/S32-exceptions/misc.t

[17:02] <dalek> rakudo/nom: (and will later be moved to Test.pm or Test::Util

[17:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5d3610057a

[17:02] <GlitchMr> nr: print (1, 2, 3).bytes

[17:02] <p6eval> niecza v18-2-gea3d97a: OUTPUT«10»

[17:02] <p6eval> ..rakudo eff089: OUTPUT«5»

[17:02] <GlitchMr> ... what?

[17:03] <moritz> nr: say (1, 2, 3).Str

[17:03] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«1 2 3␤»

[17:03] <moritz> nr: say (1, 2, 3).Str.bytes

[17:03] <p6eval> rakudo eff089: OUTPUT«5␤»

[17:03] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«10␤»

[17:04] <moritz> nr: say (1, 2, 3).Str.chars

[17:04] <p6eval> rakudo eff089, niecza v18-2-gea3d97a: OUTPUT«5␤»

[17:04] <GlitchMr> UTF-16?

[17:04] <moritz> seems like

[17:04] <GlitchMr> Why we have bytes anyways?

[17:05] <GlitchMr> It doesn't make sense with normal strings.

[17:05] * jnthn wonders if .bytes even makes sense without an argument to specify the encoding.

[17:05] <GlitchMr> It could be UTF-8, UTF-16, UTF-32, ISO-8859-1, anything

[17:05] <jnthn> Otherwise the result is meaningless

[17:05] <moritz> well, there's some spec on that

[17:05] <GlitchMr> It has to we converted into some encoding first

[17:05] <flussence> "assume utf8" seems like a sane default to me

[17:05] *** fgomez left
[17:05] <moritz> the default is $?ENCODING or so, and efault to UTF-8

[17:06] <jnthn> ah, ok

[17:06] <GlitchMr> nr: print $?ENCODING

[17:06] <p6eval> niecza v18-2-gea3d97a: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 1262 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 268 (Mu.Str @ 15) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting…

[17:06] <p6eval> ..rakudo eff089: OUTPUT«===SORRY!===␤Variable $?ENCODING is not declared␤at /tmp/gTqd6l4hUQ:1␤»

[17:06] <GlitchMr> $?ENCODING what?

[17:06] <moritz> GlitchMr: didn't say it was implemented :-)

[17:09] <GlitchMr> http://irclog.perlgeek.de/perl6/2011-12-23#i_4870398

[17:09] <GlitchMr> Also, what is that ++ thing?

[17:10] <GlitchMr> Which appears when new commit is made

[17:10] <diakopter> it is karma

[17:10] *** sivoais joined
[17:11] <diakopter> it is a joke about some people's beliefs that there is a global measurement of goodwill for each person

[17:11] <GlitchMr> I wonder how karma for Notepad increased just because of Notepad++ text editor :P?

[17:11] <jnthn> You should see how much karma C gets thanks to C++ ;)

[17:11] <GlitchMr> And how karma for C increased because of C++?

[17:12] <jnthn> Well, after C++ arrived we all realized, "gee, comparatively, C wasn't bad!"

[17:12] <GlitchMr> Read: C++ was worse?

[17:12] <jnthn> imho :)

[17:12] *** GlitchMr left
[17:12] *** GlitchMr joined
[17:12] <GlitchMr> ...

[17:12] <GlitchMr> stupid keyboard shortcuts to part channel

[17:13] *** brrt1 left
[17:13] <jnthn> heh, I thought you'd got offended because I prefer C to C++ :P

[17:13] <GlitchMr> Well, in C you can know what is:

[17:13] <GlitchMr> a = b + c * d

[17:13] <GlitchMr> But in C++, you know nothing.

[17:13] *** brrt joined
[17:14] <GlitchMr> Well, you know nothing too if this would be written in Python or Perl.

[17:14] <GlitchMr> (except that Perl 5 wouldn't accept bareword before = sign)

[17:15] *** lichtkind joined
[17:15] <moritz> re .bytes

[17:15] <lichtkind> im currently reading the new camel

[17:15] <moritz> I also think it's bad

[17:15] <moritz> because it belongs to Buf, not Str

[17:15] <moritz> or phrased differently

[17:15] <lichtkind> it hink some bits from the glossary there might me "inspire" to some glossary phrases here

[17:16] <GlitchMr> Converting to Buf is too magical

[17:16] <GlitchMr> (but that could be fine for Perl)

[17:16] <moritz> I don't believe in strings that coexists in different Unicode layers

[17:16] <GlitchMr> In Node.js for example, you have to convert string into any encoding to get its length in bytes.

[17:16] <sergot> karma C

[17:16] <aloha> C has karma of 713.

[17:16] <GlitchMr> It makes sense.

[17:16] <moritz> IMHO it makes much more sense to have separate types for Buf, Codepoints and Graphs

[17:16] <GlitchMr> karma Notepad

[17:16] <aloha> Notepad has karma of 18.

[17:16] <tadzik> ;)

[17:17] <GlitchMr> But what about C-- language?

[17:17] <tadzik> tricky bastards. Naming things just for karma!

[17:17] <GlitchMr> karma C

[17:17] <aloha> C has karma of 713.

[17:17] <GlitchMr> ok...

[17:17] <moritz> C--

[17:17] <moritz> karma C

[17:17] <aloha> C has karma of 712.

[17:17] <tadzik> maybe C-- is invented by night's watch just to balance C++ karma level

[17:17] <GlitchMr> Except C-- is very lowlevel

[17:17] <sergot> it seems that we often talk about C++ :)

[17:17] <moritz> tadzik: tricky bastards, naming things just for karma of *another* language :-)

[17:17] <GlitchMr> It's higher level than assembler, but lower than C

[17:18] <GlitchMr> http://www.cminusminus.org/

[17:19] <tadzik> ;)

[17:19] <diakopter> jnthn: maybe you saw in the backlog; compiling CORE was looping for me using the altnfa branch

[17:20] <jnthn> diakopter: Oh...that's weird

[17:21] <jnthn> I wonder if I pushed stuff wrong somehow...it looped for me in nom, but the couple of patches in altnfa got it a bit further.

[17:21] *** spaceships joined
[17:21] <jnthn> hmmm...it was second patch done in https://github.com/rakudo/rakudo/commits/altnfa that fixed the looping

[17:22] * diakopter wonders what other custom PMCs will be sped up a lot once pmichaud figures out how to get qrpa as fast as it was built-in to parrot

[17:23] *** fgomez joined
[17:25] * jnthn away for a bit

[17:31] <diakopter> oh. I didn't switch branches for rakudo

[17:34] <diakopter> well, I'm not going to be very helpful with that, since I can't push to rakudo

[17:35] *** Chillance left
[17:36] <sorear> TimToady: GlitchMr: niecza added nullary defaults last week. ;)

[17:36] <sorear> good * #perl6

[17:37] <GlitchMr> Makes sense

[17:37] <sergot> sorear: o/

[17:38] *** Chillance joined
[17:38] <sorear> TimToady: strange, I'm pretty sure ($x,$y).=reverse USED to work in niecza

[17:40] <sorear> GlitchMr: yes, + handling time values is NYI in Niecza

[17:41] <sorear> GlitchMr: iirc colomon has claimed that

[17:41] <GlitchMr> Operator overloading?

[17:43] <sorear> moritz: Why can't throws_like be used on an implementation without typed exceptions?

[17:45] <moritz> sorear: because its main point is checking stuff that only typed exceptions have (type of the exception, return value from methods on the exception)

[17:45] <moritz> sorear: you can use it of course, but it doesn't make much sense

[17:46] <sorear> moritz: ignore previous message, I have now seen the debate resolution

[17:46] <moritz> sorear: if I identify the stable parts of the exceptions stuff, how willing are you to implement it in niecza?

[17:47] <sorear> moritz: is the Rakudo core of typed exception support mature enough to steal en masse when I have tuits?

[17:47] <sorear> yes

[17:47] <sorear> afk

[17:48] <GlitchMr> perl: print [\[+]] 2, 3, 4, 5

[17:48] <GlitchMr> perl6: print [\[+]] 2, 3, 4, 5

[17:49] <p6eval> rakudo 5d3610, niecza v18-2-gea3d97a: OUTPUT«25914»

[17:49] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "2"␤    expecting operator, ":" or ","␤    at /tmp/aL0IymMBaM line 1, column 14␤»

[17:49] *** spaceships left
[17:49] <GlitchMr> niecza> [\[*]] 1 .. 10

[17:49] <GlitchMr> 1 2 6 24 120 720 5040 40320 362880 3628800

[17:49] <GlitchMr> That looks awesome!

[17:49] <GlitchMr> Except... I don't need second pair of []

[17:52] <dalek> tablets: 2da7d78 | GlitchMr++ | docs/tablet-4-operators.txt:

[17:52] <dalek> tablets: Fix metaprogramming link in chapter 4

[17:52] <dalek> tablets: review: https://github.com/perl6/tablets/commit/2da7d78bbf

[17:52] <GlitchMr> karma GlitchMr

[17:52] <aloha> GlitchMr has karma of 2.

[17:53] <moritz> sorear: you'll be able to steal the classes roles verbatim, but the throwing locations are scattered throughout the code base in rakudo

[17:55] <GlitchMr> perl6: note "HUGE SUCCESS"

[17:55] <p6eval> pugs: OUTPUT«*** No such subroutine: "&note"␤    at /tmp/vJVY9LUQvh line 1, column 1 - line 2, column 1␤»

[17:55] <p6eval> ..rakudo 5d3610, niecza v18-2-gea3d97a: OUTPUT«HUGE SUCCESS␤»

[17:55] <GlitchMr> :)

[17:55] *** Guest1193 left
[18:04] *** crab2313 left
[18:05] *** brrt left
[18:05] *** crab2313 joined
[18:21] <diakopter> moritz: do you expect to convert all the eval_dies_ok to throws_like?

[18:21] <diakopter> (eventually)

[18:22] *** brrt joined
[18:22] <diakopter> and dies_ok

[18:27] <colomon> sorear: I didn't so much "claim" it as say "Why didn't I do that months ago!"  But I'm game to do it when I get the chance, if no one else does it first.

[18:29] *** mdmkolbe joined
[18:32] <mdmkolbe> Historical/design question: Does p6 have a "_" operator?  Was "_" ever considered for the "whatever operator" (parallels Haskell and Prologs "_" (except dual), also has "fill in the blank" mnemonic)?  Is there a reason "*" was chosen instead?

[18:33] <jnthn> I think long, long ago it was to be the string concatenation operator.

[18:33] *** timotimo joined
[18:34] <jnthn> But it was probably rather too ugly... :)

[18:34] *** brrt left
[18:37] <mdmkolbe> was the "whatever" operator conceived of before or after moving away from "_" as string concat?

[18:39] <jnthn> After, I think.

[18:39] <jnthn> I think it's * in the sense that * is often used as a wildcard.

[18:43] <geekosaur> * is certainly a more Perlish wildcard

[18:45] <jnthn> Yes, more people come to Perl having seen shells and SQL than come to Perl having seen Haskell and Prolog, I suspect. :)

[18:45] <geekosaur> (I have a vague recollection that _ *was* briefly considered, but * has the Perlish connotation already from regexes)

[18:46] *** whiteknight joined
[18:47] *** whiteknight is now known as Guest63694

[18:50] *** snearch left
[18:53] *** brrt joined
[18:55] *** cognominal___ left
[18:56] *** cognominal joined
[19:10] *** icwiener joined
[19:19] *** amoe joined
[19:19] *** amoe left
[19:31] *** brrt left
[19:38] *** birdwindupbird joined
[19:43] <dalek> nqp/altnfa: 1764d47 | jnthn++ | src/QRegex/NFA.nqp:

[19:43] <dalek> nqp/altnfa: Ensure <.alpha> contributes to longest prefix.

[19:43] <dalek> nqp/altnfa: review: https://github.com/perl6/nqp/commit/1764d475d7

[19:49] <moritz> .oO( it would be mildly interesting to come up with a list of Unicode characters that were never considered for special meaning in Perl 6 in any way )

[19:50] <diakopter> moritz: I had a question above

[19:50] <pmichaud> jnthn: ping

[19:50] <moritz> diakopter: no

[19:51] <pmichaud> jnthn:  using the word "alpha" to key the nfa builder is almost certainly wrong.  It needs to be tied to the alpha() method itself.

[19:52] <pmichaud> <alpha>, <alnum>, etc. are built-in methods, not reserved words.

[19:52] <pmichaud> s/built-in/default/

[19:53] <jnthn> pmichaud: Yeah, I don't see a good way to do that right off though.

[19:53] <jnthn> pmichaud: I agree it should end up that way.

[19:54] <pmichaud> I'm guessing some sort of init method that attaches an NFA to NQPCursorRole.alpha -- same as we do for the other compiled regexes

[19:54] <jnthn> pmichaud: I'm struggling a bit with a few things here...

[19:54] <jnthn> pmichaud: Having made <.alpha> be declarative, suddenly we're in big trouble with everything.

[19:54] <jnthn> pmichaud: Because we don't implement longest literal prefix.

[19:55] <pmichaud> jnthn: right

[19:55] <jnthn> pmichaud: So it seems it's managing to see "proto " and then say "oh, term:sym<name> will do!"

[19:56] <pmichaud> the nfa runner needs a way to keep track of longest literal prefix to break ties

[19:56] <pmichaud> where longest literal prefix is measured by exact character matches

[19:56] <pmichaud> as opposed to the charclass matches

[19:56] <pmichaud> at least, that was my guess at the approach to take at the time

[19:57] <jnthn> pmichaud: Any suggestions exaclty how to carry that information?

[19:57] <pmichaud> well, it has to be carried in the list of active states, I think

[19:57] <pmichaud> i.e., each state indicates how many literal characters it's seen 

[19:57] <jnthn> Yeah...so it'd need to be a foursome rather than a threesome.

[19:57] <pmichaud> ummmmm, hmmm

[19:57] <pmichaud> (thinking)

[19:58] <pmichaud> states, not edges

[19:58] <pmichaud> I haven't thought it through yet

[19:58] <jnthn> oh..

[20:00] <dalek> tablets: 7ba8dab | GlitchMr++ | docs/appendix-f-faq.txt:

[20:00] <dalek> tablets: Perl 6 is usable right now.

[20:00] <dalek> tablets: review: https://github.com/perl6/tablets/commit/7ba8dab512

[20:00] <pmichaud> when traversing an edge representing a literal char, we increase the literal prefix count.  if we traverse an edge that isn't a literal char, we either zero the count or leave it alone from then on

[20:00] <pmichaud> (not sure which)

[20:00] <pmichaud> anyway, something like that

[20:00] <jnthn> We'd need to poision the count at at some point

[20:00] <jnthn> \w* 'foo' 

[20:01] <jnthn> or

[20:01] <jnthn> 'a' \w* 'foo'

[20:01] <jnthn> The 'foo' should never contribute.

[20:01] <pmichaud> well, what about

[20:01] <pmichaud> 'a' \w* [ 'foo' | 'food' ]

[20:02] <pmichaud> does it still not contribute?

[20:02] <GlitchMr> It works like /a\w*(?:food|foo)/ in Perl 5 :).

[20:02] <jnthn> It contributes to the declarative prefix.

[20:02] <jnthn> (the 'foo' that is)

[20:03] <jnthn> Just not to the longest literal prefix

[20:03] <GlitchMr> Or food?

[20:03] <pmichaud> okay

[20:03] <jnthn> Well, that's my understanding...

[20:03] <jnthn> :)

[20:03] <pmichaud> so, when traversing a non-literal match, there's a flag or something that indicates "don't increase the literal length" after this point

[20:03] <jnthn> We could use a signed.

[20:03] <jnthn> And you negative it

[20:03] <pmichaud> yes, a signed would do just fine

[20:03] <jnthn> oh dang...no minus zero

[20:04] <pmichaud> or, start negative and then make it positive when reaching the end

[20:04] <pmichaud> (easier to sort)

[20:04] <jnthn> *nod*

[20:04] <pmichaud> can also offset by one

[20:04] <jnthn> OK. I probably won't try this tonight, but will give it a go tomorrow.

[20:04] <pmichaud> to avoid the "no minus zero" effect

[20:04] <pmichaud> the count doesn't have to be exactly right -- it just has to compare correctly to counts made for the other paths

[20:04] <jnthn> In the event you have time, feel free to task steal if you now exactly how you want it to look :)

[20:05] <jnthn> Hmm, good point.

[20:05] <jnthn> s/now/know

[20:05] * jnthn will ponder it some more too

[20:05] <pmichaud> i.e.,  'aa'  has to sort before 'a', so counts of 3 and 2 work just as well as 2 and 1

[20:05] <jnthn> Yes

[20:05] <jnthn> Seems implementing this can't be avoided any longer.

[20:06] <pmichaud> I'm still chasing down the dynpmc thingy.

[20:06] <jnthn> OK. :)

[20:06] <jnthn> I can prolly figure this out.

[20:06] <pmichaud> when I build qrpa as a dynpmc in parrot, I get something as fast as rpa

[20:06] <jnthn> Oh.

[20:06] <jnthn> Wait, as a dynpmc *in Parrot*?

[20:07] *** kaare_ left
[20:07] <jnthn> Or as a built-in PMC in Parrot?

[20:07] <GlitchMr> http://tablets.perl6.org/appendix-e-exciting.html

[20:07] <pmichaud> in the parrot repo, a standalone dynpmc with no other p6 stuff attached

[20:07] * jnthn thought dynpmcs were dynpmcs...

[20:07] <GlitchMr> I'm not sure, is lack of code after chomp($result = <>); intentional?

[20:07] <pmichaud> as opposed to what I have in the qrpa branch, where the dynamic qrpa is part of the perl6_group

[20:07] <jnthn> pmichaud: Bizzare.

[20:07] <pmichaud> right

[20:07] <araujo> hello 

[20:07] <pmichaud> here's the full story

[20:07] <jnthn> Have you compared the compile/link flags?

[20:07] <pmichaud> I'm comparing them now.

[20:07] <GlitchMr> (oh wait, it's part of prompt())

[20:07] <GlitchMr> I haven't noticed

[20:07] <GlitchMr> lol

[20:08] <pmichaud> my first version of qrpa was built as part of the perl6_group -- it's slower than rpa

[20:08] <pmichaud> I then added a qrpa class directly to parrot, it's same speed or faster than rpa

[20:09] *** nwc10 joined
[20:09] <araujo> anybody knows a web page with the explanation of available modules/methods?

[20:09] <pmichaud> I then made a qrpa class in parrot's src/dynpmc class and that lives in its own group.  It's same speed or faster than rpa

[20:09] <nwc10> oh, jnthn just said what I was going to say - compile and link flags

[20:09] <diakopter> pmichaud: I wonder how many other custom pmcs you can speed up once you figure this out

[20:09] <jnthn> o/ nwc10 

[20:09] <dalek> tablets: 63eee41 | GlitchMr++ | docs/appendix-e-exciting.txt:

[20:09] <dalek> tablets: <> doesn't always mean read from STDIN in Perl 5, so you cannot use it for prompts

[20:09] <dalek> tablets: review: https://github.com/perl6/tablets/commit/63eee41cce

[20:10] <pmichaud> I then made a qrpa_group in the rakudo repo (containing just the qrpa class), it's slower than rpa

[20:10] <jnthn> araujo: Built-in ones, or just modules generally? If the latter see http://modules.perl6.org/

[20:10] <pmichaud> which means that something about building qrpa_group using rakudo's makefile or environment is causing it to be slower than when it's built from the src/dynpmc directory and parrot's makefile or environment

[20:10] <nwc10> have you tried copying the Parrot rpa code and renaming it as something, firstly in the parrot repository, and then in rakudo's? To see if the copy is slower in Rakudo's?

[20:10] <nwc10> (will this tell you anything you don't already know?)

[20:10] <araujo> jnthn, mm.. well, both .. thanks, I check that out

[20:11] <pmichaud> nwc10: copying Parrot's rpa code is.... painful.

[20:11] <nwc10> OK. :-(

[20:11] <nwc10> don't do that then :-)

[20:11] <pmichaud> it could be done, but I'm fairly sure it must have something to do with compile or link options that rakudo is using

[20:11] <araujo> jnthn, I was searching for built-in ones ... 

[20:11] <pmichaud> diakopter: yeah, I'm wondering if finding this fix will improve all of our dynpmcs and dynops

[20:11] <pmichaud> diakopter: I'm at least hoping that might be the case.  :-)

[20:12] <moritz> fwiw if parrot split some of its option variables for the makefiles, it's likely that we've missed it

[20:13] <pmichaud> afk a moment

[20:14] <dalek> tablets: 6ce7dc6 | GlitchMr++ | docs/appendix-d-delta.txt:

[20:14] <dalek> tablets: `=` for checking equation is mistake, `==` should be used.

[20:14] <dalek> tablets: review: https://github.com/perl6/tablets/commit/6ce7dc6c0c

[20:15] <sorear> jnthn: fwiw, niecza does literal length sorting statically

[20:15] <jnthn> sorear: Statically?

[20:15] <jnthn> sorear: I think I need more precision...when exactly does it do it?

[20:16] *** alvis left
[20:16] <jnthn> At the point the DFA is constructed?

[20:16] <sorear> Yes

[20:16] <jnthn> OK

[20:16] <sorear> Given (<a> | <b> | <c>)

[20:16] <sorear> a, b, and c's NFA's are asked for their literal length, and things are permuted accordingly

[20:17] <sorear> At NFA execution time, the all tiebreakers have been folded into "the first equally long alternative wins"

[20:17] <GlitchMr> perl: print '1' cmp 2

[20:17] <GlitchMr> perl6: print '1' cmp 2

[20:17] <GlitchMr> lol

[20:17] <p6eval> rakudo 5d3610: OUTPUT«Increase»

[20:17] <p6eval> ..pugs: OUTPUT«-1»

[20:17] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«Decrease»

[20:17] <GlitchMr> I still do it

[20:19] *** alvis joined
[20:20] <jnthn> sorear: Interesting. I'm a little worried that the current NFA executer may accidentally disorder things due to the way it handles epsilon edges.

[20:20] <jnthn> oh, but that...shouldn't be an issue.

[20:21] <jnthn> Wait, can't this be done by associating these tie-breaks with the fate?

[20:22] * jnthn kinda suspects so

[20:22] <jnthn> sorear++

[20:22] <jnthn> Thanks for help.

[20:22] <jnthn> I think I see a way to do this now.

[20:23] <pmichaud> 20:16 <sorear> a, b, and c's NFA's are asked for their literal length, and things are permuted accordingly

[20:23] <pmichaud> I'm a little confused by this statement.  What if one of them has multiple literal lengths?

[20:23] <jnthn> Oh.

[20:24] <jnthn> pmichaud: You thinking "longest applicable literal length"?

[20:24] <jnthn> Like, it's just just about having the longest literal prefix, it has to have been on the match path?

[20:25] <jnthn> s/just just/not just/

[20:25] <jnthn> Hm. That shoots down what I was pondering... :)

[20:25] <pmichaud> it has to be the longest literal prefix on the match path chosen

[20:25] <jnthn> Right.

[20:25] <pmichaud> (there can be more than one match path)

[20:25] <jnthn> *nod*

[20:26] <jnthn> Suddenly it seems less static...

[20:26] <sorear> The understanding that I had was that if it could depend on match paths, it wasn't a literal prefix.

[20:26] <sorear> token foo { abc | def } # foo has a literal length of 0 any way it matches

[20:26] <moritz> s/0/3/ ?

[20:26] <sorear> no, 0

[20:27] <moritz> uhm, why?

[20:27] <moritz> abc and def both look pretty literally to me

[20:27] <sorear> but the alternation destroys the literalism

[20:27] <diakopter> token bar { ab | abc } # has a literal prefix length of 2

[20:28] <jnthn> diakopter: I don't think any of us are arguing quite for that...

[20:28] <sorear> diakopter: not in niecza or std, but if you left-factor it to token bar { ab c? } then yes

[20:28] <diakopter> ah, sorry; /me is quiet again :)

[20:28] <jnthn> iiuc, sorear is saying "the token has to start with a literal string, nothing fancier"

[20:29] *** mtk left
[20:29] * nwc10 assumes it's things like the perl6 equivalent of /(a|w+)ab/

[20:29] <nwc10> or maybe /a(aa|\w+)ab/

[20:29] <jnthn> And Pm and I understood it more as "you run the NFA and see what point the match path does something non-literal"

[20:29] <pmichaud> token a { abc | def }

[20:30] <pmichaud> token b { ghi }

[20:30] <pmichaud> <a> <b> { say 'one' } | ab \w+ { say 'two'}  /

[20:30] <nwc10> where you might initially be able to take both sides of the alternation, but a later match failure ends up with ony one side being valid

[20:30] <pmichaud> I would think that 'abcghi' would result in 'one' and not 'two'

[20:30] *** GlitchMr left
[20:30] <pmichaud>  / <a> <b> { say 'one' } | ab \w+ { say 'two'}  /

[20:30] <sorear> jnthn: attaching any kind of data to NFA match paths is a good way to turn a constant time algorithm into an exponential time algorithm.

[20:31] <sorear> jnthn: I am very very reluctant to do anything of the sort.

[20:31] <pmichaud> i.e., the literal match of <a> against 'abc' means it's longer than the 'ab' match of the second half

[20:31] <jnthn> sorear: I can't see how adding what Pm and I discussed to QRegex's NFA runner would do anything of the sort.

[20:32] <pmichaud> which would mean that the literal match length of <a> isn't zero.

[20:32] <sorear> jnthn: How do you decide whether a literal edge is on the "eventual match path"?

[20:32] <jnthn> pmichaud: Well, the whole <a> <b> would both count iiuc

[20:32] <moritz> pmichaud: when I compile dynpmcs with parrot's and rakudo's Makefile, sort the options and throw away all of the include paths and make a diff, there are only three differing lines (more)

[20:32] <pmichaud> jnthn: right, I agree.  My point is that   'abc' | 'def'   can't have a literal length of zero

[20:32] <moritz> pmichaud: rakudo has -DDISABLE_GC_DEBUG=1 and -DNDEBUG

[20:33] <moritz> pmichaud: parrot has -g

[20:33] <pmichaud> moritz: noted

[20:33] <moritz> oh, but I forgot to pass --optimize to parrot's configure.pl

[20:33] <moritz> so maybe the interesting part got omitted

[20:33] <moritz> pmichaud: I'll try again :-)

[20:33] <pmichaud> yes, you have to have --optimize for the Parrot Configure.pl.  Otherwise everything is slow slow slow

[20:34] <nwc10> pmichaud is probably in the easiest position to go for the real brute force - eyeball compare the generated assembly for the PMC code in Parrot, vs in Rakudo

[20:35] <sorear> pmichaud: (abcghi) I agree this behavior is less than ideal, but it is a cost I am willing to bear to avoid an exponential blowup in the state space.

[20:35] <pmichaud> nwc10: I hadn't gotten to that stage yet.  I'm going to look at compile options first.  If I can't get that to illustrate the difference, I'm going to set up easy-to-build branches of both parrot and rakudo with the pieces I've done and let people hack on it (eyeballs)

[20:35] <jnthn> sorear: With a parallel NFA, all of the paths are being explored in parallel; if you're propagating the information as you follow the states then it that is tracing the match path.

[20:36] <jnthn> s/it that/that/

[20:36] <sorear> jnthn: parallel NFAs are only efficient because identical states can be coalesced

[20:36] <pmichaud> sorear: I'm more concerned with what the specification requires than what's "ideal"  :-)

[20:36] <pmichaud> if the specification says that   'abc' | 'def'  doesn't contribute to longest literal match, that's fine with me.  :)

[20:37] <jnthn> Right, but the spec doesn't, so far as I can see.

[20:37] <pmichaud> but that's not the way I've understood it to date.

[20:37] <pmichaud> besides, a protoregex is really just a form of alternation, and clearly *it* ought to have some contribution to longest literal match, iiuc

[20:37] <sorear> pmichaud: I would rather change the specification than force users to deal with slow compilers forever.

[20:38] <sorear> pmichaud: I am looking forward to seeing the sub-exponential literal algorithm that jnthn++ claims to have.

[20:38] <diakopter> Longest literal prefix: food\w* beats foo\w* by 1 position

[20:38] <jnthn> sorear: I only claimed that the addition would not change the order of the algorithm that is presently being used.

[20:39] <sorear> in niecza, protoegexes do not contribute to literal prefixes.

[20:40] <pmichaud> sorear: whatever TimToady++ declares to be the correct answer, I'm going to go with that.  

[20:40] *** pupoque joined
[20:40] <sorear> Yes.

[20:40] <diakopter> http://irclog.perlgeek.de/perl6/2010-06-16#i_2442589

[20:41] <pmichaud> if we declare that      'abc' [ 'def' | 'de' ]       always has a longest literal prefix of 3 and not (5|6), then let's spec it and go that way.

[20:41] <diakopter> sorear	what about ab[d|e] ?

[20:41] <diakopter> 04:18	TimToady	that's 2

[20:41] <jnthn> How does <term> know to pick the multi-declarator parse path for 'proto' rather than term:sym<name>? 

[20:41] <jnthn> sorear: ^

[20:41] <moritz> pmichaud: erm yes, the -O2 doesn't get propagated to rakudo's Makefile

[20:41] <jnthn> sorear: Is it just the "last declaration" rule?

[20:42] <pmichaud> moritz: okay, that's likely it.  moritz++

[20:42] <moritz> and the reason is pretty simple

[20:42] <jnthn> er, I mean, earliest declaration wins...

[20:42] <pmichaud> based on the log that diakopter++ posts,    abc | def  is indeed prefix zero

[20:42] <sorear>  token term:multi_declarator   { <?before 'multi'|'proto'|'only'> <multi_declarator> }

[20:42] <pmichaud> i.e., doesn't contribute to longest literal match.  That might make things simpler

[20:42] <sorear> oh,hmm

[20:42] <moritz> it doesn't appear in any variable in the Makefile

[20:43] <pmichaud> where does it appear in Parrot's makefile, ooc?

[20:43] <moritz> parrot's makefile simply adds an -O2 to everything

[20:43] <moritz> pmichaud: in all rules separately

[20:43] <pmichaud> ...Configure.pl adds it directly?  ugh

[20:43] <pmichaud> it must be in the template somewhere

[20:43] <sorear> jnthn: as far as I can tell it IS just the last-declaration rule o.O will have to ask TimToadty

[20:43] *** s1n joined
[20:44] *** s1n left
[20:44] <jnthn> sorear: Well, my whole understanding of "longest literal prefix" came from "this must be why we get it wrong in Rakudo"... :)

[20:44] <jnthn> I...really do not want to believe that one is declaration order.

[20:44] <pmichaud> moritz: aha, here it is!

[20:44] <pmichaud> .c$(O) : # suffix rule (limited support) $(CC) $(CFLAGS) @optimize@ $(CC_WARN) -I$(@D) -Isrc/ @cc_o_out@$@ -c $<

[20:45] <moritz> oh, @optimize@

[20:45] <pmichaud> I just need to add @optimize@ to Rakudo's Makefile.in, I bet.

[20:45] <moritz> silly me, I was looking in the generated Makefile, not in Makefile.in

[20:45] <moritz> and *there* it's expanded already

[20:45] <pmichaud> I'm surprised they didn't put it into $(CFLAGS)

[20:45] <pmichaud> anyway

[20:45] <moritz> though $(CFLAGS) isn't expanded in there

[20:46] <pmichaud> trying that now

[20:48] <pmichaud> that also explains why I wasn't getting -g on the dynpmcs either

[20:48] <pmichaud> pmichaud@kiwi:~/p6/rakudo-qrpa$ install/bin/parrot_config optimize

[20:48] <pmichaud> -O2 -g

[20:48] <pmichaud> seems weird to have "-g" in the "optimize" flag, though.  :-P

[20:48] <jnthn> What's -g? :)

[20:48] <pmichaud> include debugging symbols for gdb

[20:48] <jnthn> hah :)

[20:49] <pmichaud>        -g  Produce debugging information in the operating system's native

[20:49] <pmichaud>            format (stabs, COFF, XCOFF, or DWARF 2).  GDB can work with this

[20:49] <pmichaud>            debugging information.

[20:49] <jnthn> In MSVC there's a funny situation where you can't have a debugging symbols AND optimize the build in certain ways.

[20:49] <jnthn> Maybe that's why they are grouped together.

[20:49] <nwc10> HP-UX on PA RISC turns out to be even *more* fun

[20:49] <pmichaud>            GCC allows you to use -g with -O.  

[20:49] <nwc10> 64 bit is fine

[20:49] <pmichaud>            Nevertheless it proves possible to debug optimized output.  This

[20:49] <pmichaud>            makes it reasonable to use the optimizer for programs that might

[20:49] <pmichaud>            have bugs.

[20:50] <nwc10> 32 bit, you can use -O and -g with C code

[20:50] <nwc10> but *not* with pre-processed C code

[20:50] <crab2313> should all tests in parrot get passed? except the skipped.

[20:51] <benabik> crab2313: Yes, a test in parrot should pass or be TODOed

[20:51] *** slavik1 left
[20:52] <crab2313> benabik: but there are two tests on my machine didn't pass.

[20:52] <pmichaud> pmichaud@kiwi:~/p6/rakudo-qrpa$ install/bin/parrot z2.pir rpa[$I0] = 0.656108856201172

[20:52] <pmichaud> qrpa[$I0] = 0.585737943649292

[20:53] <pmichaud> \o/

[20:53] <pmichaud> moritz++

[20:53] <moritz> \o/

[20:53] <pmichaud> moritz++

[20:53] <nwc10> win!

[20:53] <jnthn> Whoa!

[20:53] <jnthn> We even *beat* Parrot's rpa

[20:53] <jnthn> pmichaud++

[20:53] <pmichaud> could be a big win, since all of the nqp+rakudo C code has apparently been compiled unoptimized

[20:53] <pmichaud> that includes 6model

[20:53] <diakopter> maybe that 1 less pos comparison makes a difference

[20:53] <jnthn> pmichaud: Wait...the NQP code too?!

[20:54] <benabik> crab2313: Then there may be a bug.  Can you nopaste your platform and the failures?

[20:54] <pmichaud> unless we included the @optimize@ flag into the Makefile

[20:54] *** birdwindupbird left
[20:54] <pmichaud> which I doubt, since I stole the Makefile from Rakudo

[20:54] <dalek> nqp: 23b8c3e | moritz++ | tools/build/Makefile.in:

[20:54] <dalek> nqp: [build] include @optimize@ in CCFLAGS

[20:54] <dalek> nqp: review: https://github.com/perl6/nqp/commit/23b8c3efc7

[20:54] <pmichaud> patches coming up

[20:54] <jnthn> pmichaud: Wow :)

[20:54] <jnthn> Er, patch come up ;)

[20:54] <pmichaud> oh, looks like moritz++ is beating me to it

[20:56] <moritz> I can patch rakudo too, just want to wait for the build to finish to be sure

[20:57] <pmichaud> moritz: I'll let you make the patches, yes.

[20:57] <nwc10> and then there will be comparison benchmarks?

[20:58] <pmichaud> sure, we can compare against 2012.05

[20:58] <pmichaud> or against whatever was in place this morning

[20:58] <nwc10> either is interesting. actually, both. :-)

[20:58] <nwc10> and a pony.

[20:59] <crab2313> benabik: https://gist.github.com/2859940

[20:59] <sorear> colomon: I want a second opinion before closing #129 NOTABUG

[21:00] <dalek> rakudo/nom: 8b4208b | moritz++ | tools/build/Makefile.in:

[21:00] <dalek> rakudo/nom: [build] reuse @optimize@ flags from parrot

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b4208b996

[21:00] <dalek> rakudo/nom: acf9038 | moritz++ | tools/build/NQP_REVISION:

[21:00] <dalek> rakudo/nom: bump to an optimize NQP revision

[21:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/acf90382e8

[21:01] <benabik> crab2313: Those are both IPv6 tests.  Perhaps that is not enabled in your kernel?

[21:01] <moritz> note that parrot also uses @optimize@ in the linker flags

[21:02] <pmichaud> I didn't find that

[21:02] <moritz> LD_SHARE_FLAGS   = -shared -O2 -L/usr/local/lib -fstack-protector -fPIC

[21:02] <pmichaud> ah, that's already in @ld_share_flags@ then

[21:03] <moritz> ok

[21:03] <crab2313> benabik: Yes, IPv6 is disabled in my kernel.

[21:03] <pmichaud> config/gen/makefiles/root.in:129:LD_SHARE_FLAGS   = @ld_share_flags@

[21:03] <benabik> crab2313: Then those are expected failures, and parrot should run just fine modulo any attempts to use IPv6

[21:04] <pmichaud> ack -a '@optimize@' only reports the config/gen/makefiles/root.in line

[21:04] <pmichaud> afk for a bit

[21:04] <crab2313> benabik: Thanks.

[21:04] * moritz wonders why config/gen/ contains non-generated files

[21:04] <benabik> crab2313: No problem.  :-)  If you need any further help, I tend to be here and there's #parrot on irc.perl.org

[21:06] * diakopter sees how long it takes rakudo's setting to compile with the new optimize

[21:07] <pmichaud> parrot's config/gen/ contains the sources for generating things, not the things generated

[21:07] <pmichaud> afk for a bit for real this time

[21:09] <colomon> sorear: NOTABUG was my first response.  But I haven't sat down and thought on it again, I'm just going on vague memories from implementing it.

[21:10] *** gesh joined
[21:14] *** gesh left
[21:14] <diakopter> yeah, that speeds up the CORE compilation 6%

[21:15] <jnthn> Not Bad.

[21:15] *** pupoque_gnexus joined
[21:16] <diakopter> ymmv

[21:17] *** Fodilhaozinho joined
[21:19] *** Fodilhaozinho left
[21:25] <crab2313> oh, I think it is 75%

[21:26] *** nwc10 left
[21:32] <araujo> what is the '&code' parameter type?? isn't that something like: { $_+ $_} ?

[21:32] *** crab2313 left
[21:33] <jnthn> & just means "Callable"

[21:33] <jnthn> &code is equivalent to Callable $code in terms of what it accepts

[21:33] <jnthn> However, there's another benefit to writing &code

[21:33] <jnthn> You can call the thing with code(...) syntax

[21:35] <araujo> mm I see

[21:47] *** b1rkh0ff left
[22:00] *** b1rkh0ff joined
[22:02] <lichtkind> good night

[22:02] *** lichtkind left
[22:15] <pmichaud> looks like I saved 13 seconds  (304 - 291)   in the spectest after @optimize@

[22:16] <jnthn> \o/

[22:17] <pmichaud> CORE.setting goes from 146.4 sec to 137.5  (6.1%)

[22:17] <pmichaud> so, nothing hugely spectacular but still a nice win

[22:17] <pmichaud> we should get more win for list-related things after the other changes I have planned :)

[22:18] <jnthn> \o/

[22:18] * jnthn hopes we can get more parsing win soon too

[22:19] <pmichaud> I'll also look at the $!target stuff soon

[22:19] <jnthn> yay

[22:19] <jnthn> I'll continue my alternation/LTM efforts tomorrow :)

[22:19] <jnthn> My brane can only take so long at that stuff in one sitting :)

[22:20] <diakopter> jnthn, the mental nfa runner

[22:20] <pmichaud> did you catch the log that diakopter pointed out earlier?  Based on that, I read that each regex has exactly one longest literal match

[22:20] <jnthn> Yeah, it still bothers me I started to be able to run NFAs in my head by reading the sequences of digits. :P

[22:20] <pmichaud> as sorear++ described

[22:20] <jnthn> pmichaud: Yes, the key line in it was when TimToady++ very clearly indicated he did not want it to be data driven.

[22:20] <pmichaud> okay, good.  

[22:20] <pmichaud> as long as we're all in agreement :)

[22:21] <pmichaud> afk, car repair

[22:21] * TimToady is not sure he agrees with himself...

[22:21] <jnthn> uh-oh :P

[22:21] <TimToady> but will think about it s'more

[22:21] <zby_home> http://nopaste.snit.ch/143054 - I am trying to have a class method here

[22:21] <zby_home> the one without parameters seems to work

[22:21] <zby_home> but the other one taking a hash does not

[22:22] *** icwiener left
[22:22] <tadzik> zby_home: well, you're not passing it a hash

[22:22] <tadzik> Not enough positional parameters passed; got 1 but expected 2

[22:23] <zby_home> true - in my code I was actually calling it in this way: ::P.a( a => 'a' );

[22:23] <zby_home> but this results in the same error

[22:24] <tadzik> I guess a => 'a' results in a named parameter

[22:24] <zby_home> ach

[22:24] <zby_home> sorry

[22:24] <tadzik> you either need to pass a hash explicitely { a => 'a' }, or declare a slurpy hash in the param list

[22:24] <tadzik> sub foo (*%slurpy) { say %slurpy.perl }; foo(bar => 'baz')

[22:24] <tadzik> rn: sub foo (*%slurpy) { say %slurpy.perl }; foo(bar => 'baz')

[22:24] <p6eval> rakudo acf903: OUTPUT«("bar" => "baz").hash␤»

[22:24] <p6eval> ..niecza v18-2-gea3d97a: OUTPUT«{"bar" => "baz"}.hash␤»

[22:25] <tadzik> r: sub foo (%hash) { say %hash.perl }; foo({bar => 'baz'})

[22:25] <p6eval> rakudo acf903: OUTPUT«("bar" => "baz").hash␤»

[22:25] <tadzik> that should do it

[22:28] <TimToady> I think I'm okay with ignoring [a|b] for longest literal, since you could write it as separate rules if you want the other thing, and the idea is to recognize specific literal tokens, not tricksy patterns that try to do too much

[22:29] *** wamba left
[22:29] <sorear> TimToady: in STD, how does the term know to parse 'proto ...' using term:declarator?

[22:29] <jnthn> TimToady: proto token foo { * }; token foo:sym<bar> { <sym> } # does <sym> count as longest literal when dispatching to <foo>?

[22:30] <sorear> TimToady: jnthn and I are worried that it might only be declaration order

[22:30] <jnthn> I don't mean when calculating a longest literal for another thing that calls <foo>. I mean the actual <foo> dispatch itself.

[22:30] <jnthn> Yes, also what sorear++ asked :)

[22:30] <TimToady> <sym> should be considered literal, methinks

[22:31] <jnthn> That's what got me thinking longest literal was transitive.

[22:31] <sorear> jnthn: I have been operating under the assumption that the answer to that is yes

[22:31] <jnthn> Or...something.

[22:31] <TimToady> it's usually the literal token, so yes

[22:32] <jnthn> Well, it desugars to a literal; once anything that cares gets its hands on it the desugaring from <sym> to a literal woulda happened. In Rakudo at least.

[22:32] <jnthn> sorear: "yes" is the answering I'm hoping for too

[22:32] <sorear> the STD-relevant case is token term:id { \w+ }; token term:declarator { <declarator> }; token declarator { ['only'|'multi'|'proto'] }

[22:33] <sorear> declarator, in the niecza/new-STD model, has a prefix length of 0

[22:33] <sorear> so there's no prefix reason to prefer term:id over term:declarator of vice versa

[22:33] <sorear> *or vice

[22:33] <jnthn> *literal* prefix, yes?

[22:33] <sorear> yes, literal prefix

[22:33] <TimToady> that might have been written when STD was doing it the other way

[22:33] <jnthn> Well, declarator is only one such example 

[22:34] <TimToady> *all* of STD was written when it was the other way :)

[22:35] <jnthn> We don't tie-break very accurately on declaration order at the moment. And so as soon as I fixed <ident> to do declarative prefix properly...boom, loads of stuff ended up in term:sym<name>.

[22:35] <jnthn> (In Rakudo, that is.)

[22:35] <TimToady> or maybe there's some distinction between an alternation that occurs first vs one that occurs after other literal charas

[22:36] <TimToady> but STD would certainly have treated those as three separate fates with literal lengtsh of 4 or 5

[22:38] <TimToady> the situation of trying to parse several keywords with the same code is a little different than a keywords that goes all dendritic halfway through

[22:41] <TimToady> or to put it a different way, an alternation that starts a token rule could be hoisted up into the outer alternation for purposes of LTM, but not alternations that occur further on in the match

[22:42] <sergot> good night ! o/

[22:42] *** sergot left
[22:42] <tadzik> good knight sergot

[22:43] <TimToady> otherwise we're in the situation that literal longest tokens must *always* be alternated under a proto, which seems a bit non-Perly

[22:45] <TimToady> I think this approach is still subject to static analysis, while preserving a bit more Least Astonishment for things like ['only'|'multi'|'proto']

[22:46] <TimToady> so I guess I don't entirely agree with myself after all

[22:47] <jnthn> Well, the other thing is

[22:47] <jnthn> token term:package_declarator { <package_declarator> }

[22:47] <jnthn> That probably also wants us to hoist literal prefixes.

[22:48] <TimToady> I kinda think it's what people will expect when the alternation is the first thing

[22:49] <jnthn> Yeah but...then don't you lose the staticness of it?

[22:49] <TimToady> and I also have the suspicion that if we have to rely on declaration order, the terrorists will have won

[22:49] <jnthn> Because which longest literal prefix matches is data-dependant...

[22:50] <jnthn> I think that's the underlying tension here.

[22:50] <TimToady> not really, you just have n literals that happen to map to the same rule

[22:51] <jnthn> So...that rules' longest literal prefix is just the @all_possible_literal_prefixes.max(*.char) ?

[22:51] <TimToady> as long as we stay away from quantifiers and downstream alternations, there's no exponential blowup

[22:51] <jnthn> Ah...so...limitedly data dependent somehow?

[22:52] <TimToady> only, multi, and proto participate as three separate LTMs, with 4, 5, and 5 length

[22:52] <TimToady> at the point a new language is derived and the new lexer is generated, those are effectively static

[22:53] <TimToady> should probably allow an initial <?before 'only'|'multi'|'proto'> as a form of initial [] too

[22:55] <TimToady> I think we can have our cake and eat it too, mostly, without too much pain, as long as we limit it to initial alternations

[22:56] <TimToady> either that or we need some kind syntactic relief via <sym> for matching multiple keywords

[22:56] <TimToady> but the initial alternation seems amenable to analysis, and we already have that syntax

[22:58] <TimToady> it's really no different from transitive alternation if the keywords is matched by a sub-proto

[22:58] <jnthn> *nod*

[22:58] <TimToady> *are

[22:58] <TimToady> this feels rightest to me at the moment

[22:59] <TimToady> so now I've probably made everyone unhappy :)

[23:00] <pmichaud> I'm not unhappy, but perhaps that's because I haven't read the backscroll yet :-)

[23:01] *** zby_home left
[23:02] <pmichaud> (I'm actually certain that reading bs won't change my level of happiness.)

[23:03] * TimToady pictures pmichaud++ reading bounded serialization :)

[23:03] * diakopter pictured something else

[23:03] <pmichaud> lately I think there's just too much bs on #perl6  :)

[23:03] <TimToady> a college degree?

[23:03] <jnthn> .oO( reading src/6model/serialization.c could be described that way... )

[23:04] <sorear> TimToady: I think that idea can be made to work

[23:05] <TimToady> I agree that calulating the cross-product of downstream branches is potentially explosive, which I actually ran into several times in early STD development...

[23:05] <TimToady> *calc

[23:06] <TimToady> this seems like about the right balance of torment for the implementors vs the users

[23:06] <pmichaud> .oO( ... there's been a balance? )

[23:06] <jnthn> .oO( what be this new policy? )

[23:07] <TimToady> that I'll actually tell you the places where we choose to also torment the users, instead of just Not Mentioning It?

[23:07] <jnthn> :)

[23:08] <TimToady> usually we call that DIHWIDT

[23:09] <tadzik> huh

[23:10] <TimToady> which means "We can't be bothered to tell you how stupid you, the user, are."

[23:10] <tadzik> I get ===SORRY!=== No object at index 66 when running make test on precompiled WebNano6

[23:10] *** pupoque_gnexus left
[23:10] <jnthn> :/

[23:10] <tadzik> but when I added a few BEGIN say "foo"; around, it started working

[23:10] <jnthn> tadzik: Around...what?

[23:10] <tadzik> seems that non-deterministic compilation strikes again in this particular case

[23:10] <jnthn> In the thing doing the sue statement?

[23:10] <jnthn> *use

[23:11] <jnthn> Or in the module being pre-compiled?

[23:11] <tadzik> oh, it was just a coincidence

[23:11] <tadzik> jnthn: I've been adding those around use statements

[23:11] <tadzik> but there's no correlation, not much

[23:11] <tadzik> it's mostly random-ish

[23:11] <jnthn> Bother.

[23:13] *** cognominal_ joined
[23:15] *** icwiener joined
[23:16] *** cognominal left
[23:21] <jnthn> oh, dang

[23:21] <jnthn> er, ww

[23:24] *** mtk joined
[23:25] *** cognominal___ joined
[23:29] *** cognominal_ left
[23:43] *** aindilis joined
[23:45] <itz> #perl6++ # 10 years late ok but it will kick ruby and java's arses

[23:46] <timotimo> ruby and java will not be around any more

[23:49] <gfldex> i'm quite sure oracle will be able to sue you over copyrighted java patents

[23:49] <pmichaud> I'm sure they'll be able to lose, also.  :-)

[23:50] * jnthn was most happy with the copyright judgement

[23:50] <pmichaud> same here

[23:51] <jnthn> I wish it had been a slightly broader opinion, but still...it was very well written.

[23:51] <itz> the coder judge seemed to help!

[23:51] <jnthn> Yeah!

[23:52] <pmichaud> the judge was smart to keep the opinion narrow

[23:52] <jnthn> pmichaud: More likely to stand on appeal?

[23:52] <pmichaud> less invitation to appeal

[23:52] * jnthn suspects Oracle will appeal anyway

[23:52] <pmichaud> oh yes, oracle says they're going to appeal

[23:53] <pmichaud> jnthn: obtw, I'm going ahead and putting qrpa in to nqp now

[23:53] <pmichaud> *into

[23:53] <jnthn> Do the appeals court get to say whether they even care to hear an appeal? Or are they obligated to hear it?

[23:54] <pmichaud> appeals court can deny appeal, yes.

[23:54] <jnthn> I know the supreme can just say "no" and let it stand.

[23:54] <jnthn> Ah. So it may be that it's stopped right there.

[23:54] <jnthn> Unless Oracle really want to go all the way to the supreme court...

[23:54] <pmichaud> I'm expecting they'll hear an appeal, but that oracle will lose on appeal also.

[23:54] <diakopter> was it a federal or state case?

[23:54] <pmichaud> I think the supreme court will be unlikely to hear any appeal on this one.

[23:55] *** cognominal joined
[23:55] <itz> sun++ # letting the GPL genii out of the bottle

[23:55] <pmichaud> diakopter: federal court

[23:55] <pmichaud> copyright is always in federal court

[23:56] <itz> oracle-- # bad larry

[23:56] <jnthn> Are patents always federal also?

[23:56] <itz> perl++ # good larry

[23:56] <pmichaud> jnthn: I don't know about patents.... it would make sense, though.

[23:56] <jnthn> +1 on QRPA in nqp

[23:57] <diakopter> um. 

[23:58] *** cognominal___ left
[23:58] <diakopter> CORE parse in 78 seconds on windows; almost twice as fast as in the linux vm on the same machine.  very unexpected.

[23:58] <jnthn> huh...

[23:58] <jnthn> That's odd.

[23:59] <diakopter> jnthn: how long does the first stage of CORE take on yours

[23:59] <jnthn> 60 seconds

[23:59] <diakopter> nice

[23:59] <jnthn> Probably a bit less now

[23:59] <jnthn> I didn't time it since the optimize stuff

