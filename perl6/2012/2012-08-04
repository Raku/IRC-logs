[00:00] *** cognominal_ left
[00:00] *** cognominal_ joined
[00:03] *** Tedd1 joined
[00:07] *** tokuhiro_ joined
[00:22] *** seldon left
[00:24] *** cognominal__ joined
[00:25] *** cognominal_ left
[00:27] *** whiteknight joined
[00:28] *** cognominal__ left
[00:28] *** whiteknight is now known as Guest47936

[00:40] *** cognominal joined
[00:40] *** tokuhiro_ left
[00:42] *** cognominal left
[00:58] *** Guest47936 left
[01:00] *** cognominal joined
[01:01] *** cognominal left
[01:06] *** UncleFester6 joined
[01:26] *** ponbiki left
[01:33] *** ponbiki joined
[01:33] *** ponbiki is now known as Guest90488

[01:39] *** PacoAir left
[01:41] *** Guest90488 left
[01:49] *** UncleFester6 left
[02:00] *** bluescreen10 left
[02:09] *** Chillance left
[02:37] *** Psyche^ joined
[02:39] *** leprevost joined
[02:40] *** Patterner left
[02:40] *** Psyche^ is now known as Patterner

[02:43] *** b1rkh0ff left
[02:55] *** orafu left
[02:55] *** orafu joined
[03:20] *** bluescreen10 joined
[03:28] <dalek> roast: d0cf38e | coke++ | S05-interpolation/regex-in-variable.t:

[03:28] <dalek> roast: pugs fudge

[03:28] <dalek> roast: review: https://github.com/perl6/roast/commit/d0cf38e5a9

[03:29] *** thelazydeveloper left
[03:30] *** gongyiliao joined
[03:31] <Timbus> r: sub ♞ {"knight"}

[03:31] <p6eval> rakudo 1f662c: OUTPUT«===SORRY!===␤Missing block␤at /tmp/QYTg3e9hBc:1␤»

[03:31] <Timbus> not allowed?

[03:32] <Timbus> n: sub ♞ {"knight"}; say ♞;

[03:32] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed block at /tmp/3WDDbuhVVO line 1:␤------> [32msub [33m⏏[31m♞ {"knight"}; say ♞;[0m␤␤Parse failed␤␤»

[03:32] <Timbus> guess so

[03:32] <dalek> roast: 1b99898 | coke++ | S06-other/main.t:

[03:32] <dalek> roast: niecza fudge

[03:32] <dalek> roast: review: https://github.com/perl6/roast/commit/1b998989bb

[03:37] <[Coke]> r: sub postfix<♞> { "knight" }; 

[03:37] <p6eval> rakudo 1f662c: OUTPUT«===SORRY!===␤Missing block␤at /tmp/fdJ_TSY3Zl:1␤»

[03:38] <benabik> r: sub postfix:<♞>($x) { $x ~ "knight" }; say "white "♞

[03:38] <p6eval> rakudo 1f662c: OUTPUT«white knight␤»

[03:38] *** gongyiliao left
[03:39] <timotimo> what exactly does fudge mean? is it different from "skip" or "xfail"?

[03:39] <benabik> r: sub term:<♞>() { "knight" }; say ♞

[03:39] <p6eval> rakudo 1f662c: OUTPUT«===SORRY!===␤Cannot add tokens of category 'term'␤at /tmp/ELsIQfALdE:1␤»

[03:39] <benabik> I think "fudge" is for things that fail only in some implementations.

[03:40] <timotimo> OK

[03:40] <timotimo> oh my, it's already light out. time to go to bed >_>

[03:40] <timotimo> good * #perl6

[03:41] <Timbus> r: macro circumfix:«♞ ♞»($text) { return "kn" ~ "i" x $text.chars ~ "ghts" }; macro circumfix:«☀ ☀»($text) { return "d" ~ "a" x $text.chars ~ "ze" }; say "arabian " ~ ♞'♞♞♞♞'♞; say "like arabian " ~ say "Like arabian " ~ ☀'☀☀☀☀☀'☀; say "more often than not, are hotter than hot"

[03:41] <p6eval> rakudo 1f662c: OUTPUT«arabian kniiiights␤Like arabian daaaaaze␤like arabian True␤more often than not, are hotter than hot␤»

[03:41] <Timbus> aw

[03:43] <Timbus> is it possible to get macros to take non-strings

[03:47] *** birdwindupbird joined
[03:47] <Timbus> r: macro circumfix:«♞ ♞»($text) is parsed / <-[♞]>+ / { return "kn" ~ "i" x $text.chars ~ "ghts" }; say ♞♘♘♘♞

[03:47] <p6eval> rakudo 1f662c: OUTPUT«===SORRY!===␤Missing block␤at /tmp/IvVjMgDvki:1␤»

[03:48] <Timbus> d'oh

[03:51] *** ingy joined
[04:05] *** jaldhar joined
[04:07] *** Stocks29 joined
[04:08] *** Stocks29 left
[04:31] *** kaare_ joined
[04:32] *** telex left
[04:33] *** telex joined
[04:48] *** thou joined
[05:11] *** JimmyZ_ joined
[05:15] <moritz> jnthn: (re documenting metamodel in perl6/doc) yes, reasonable. Go ahead :-)

[05:17] <moritz> good morning everybdoy

[05:18] *** gongyiliao joined
[05:19] <JimmyZ_> moritz: good morning

[05:22] <sorear> good morning moritz.

[05:45] *** gongyiliao left
[05:54] *** leprevost left
[06:13] <dalek> doc: 45054e8 | moritz++ | lib/objects.pod:

[06:13] <dalek> doc: [object] self, private methods, submethods

[06:13] <dalek> doc: review: https://github.com/perl6/doc/commit/45054e89f4

[06:14] <moritz> r: class A { has $.x; submethod BUILD() { } }; A.new(:x<3>).x.say

[06:14] <p6eval> rakudo 1f662c: OUTPUT«Any()␤»

[06:39] *** SamuraiJack joined
[07:01] *** thou left
[07:06] *** cognominal joined
[07:16] *** eternaleye_ is now known as eternaleye

[07:30] *** GlitchMr joined
[07:59] *** tokuhiro_ joined
[08:02] *** nodmonkey joined
[08:19] <masak> good antenoon, #perl6

[08:20] <moritz> \o masak

[08:20] *** brrt joined
[08:21] *** birdwindupbird left
[08:22] * masak back-clogs

[08:23] <moritz> r 

[08:24] <Timbus> arr!

[08:24] <moritz> array!

[08:24] <moritz> r: say Array.^mro

[08:24] <p6eval> rakudo 1f662c: OUTPUT«Array() List() Iterable() Cool() Any() Mu()␤»

[08:25] <moritz> r: say Parcel.^mro

[08:25] <p6eval> rakudo 1f662c: OUTPUT«Parcel() Cool() Any() Mu()␤»

[08:25] * moritz thought Parcel was Iterable

[08:26] <Timbus> i oh thought you were txting in pirate. "r me hrties. wnt 2 plndr l8r?"

[08:27] <moritz> akshually it was just a mostly dead ssh connection where I didn't see what I typed

[08:28] <masak> r: $_ = "mostly dead ssh connection"; s[ea] = "rea"; .say

[08:28] <p6eval> rakudo 1f662c: OUTPUT«mostly dread ssh connection␤»

[08:28] *** tokuhiro_ left
[08:30] <sorear> o/ masak

[08:30] <JimmyZ_> r: s[ea] = "rea"; .say

[08:30] <p6eval> rakudo 1f662c: OUTPUT«No such method 'subst' for invocant of type 'Any'␤  in block  at /tmp/htGuR5us8T:1␤␤»

[08:30] <masak> sorear: \o

[08:31] <JimmyZ_> r: $_ = ""; s[ ] = "rea"; .say

[08:31] <p6eval> rakudo 1f662c: OUTPUT«rea␤»

[08:32] <JimmyZ_> r: $_ = ""; s[] = "rea"; .say

[08:32] <p6eval> rakudo 1f662c: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter ] (must be quoted to match literally) at line 2, near " = \"rea\"; "␤»

[08:33] <JimmyZ_> std: $_ = ""; s[ ] = "rea"; .say

[08:33] <p6eval> std f43a358: OUTPUT«[31m===[0mSORRY![31m===[0m␤Null pattern not allowed at /tmp/VK1jegzuR7 line 1:␤------> [32m$_ = ""; s[ [33m⏏[31m] = "rea"; .say[0m␤    expecting quantifier␤Parse failed␤FAILED 00:00 43m␤»

[08:34] <tadzik> good morning

[08:35] <moritz> \o tadzik 

[08:36] *** thelazydeveloper joined
[08:38] <sorear> .oO( there's only one? also, that's quite some Hubris you have there )

[08:38] *** brrt left
[08:39] <moritz> sorear: only one what? /me misses some context

[08:40] <sorear> 01:36 -!- thelazydeveloper [~lazydevel@unaffiliated/thelazydeveloper] has joined #perl6

[08:41] * masak comes crashing in through the window

[08:41] <masak> moritz: grammar!

[08:41] * masak runs off

[08:41] <moritz> now we can just hope for impatience

[08:41] <sorear> I'm missing the context

[08:44] * moritz too

[08:44] * masak .oO( Perl 6 Coding Context )

[08:45] <masak> by the way, first and second prize winners have gotten their prizes now, if not all their book deliveries yet.

[08:45] <moritz> \o/

[08:46] <masak> the p6cc2011 was awesome. the judging was a bit slow, but that's my fault.

[08:46] <masak> moritz++ helped with a second set of eyeballs, moral support, and occasional necessary reminders.

[08:47] <moritz> and much of the review for t1 and t2 :-)

[08:47] <masak> oh, yes. moritz++

[08:47] <masak> also, p6cc2012 will be *awesome*.

[08:49] <moritz> r: class A { has $.x = 5; submethod BUILD() { } }; A.new(:x<3>).x.say

[08:49] <p6eval> rakudo 1f662c: OUTPUT«5␤»

[08:52] * masak finds he used "awesome" about both p6cc2011 and p6cc2012, but felt he meant different things...

[08:52] <moritz> MTA: More Than Awesome

[08:53] <masak> :P

[08:54] *** bbkr left
[08:55] *** mucker joined
[09:01] <masak> I'm implementing Lambda Calculus. planning to do a small writeup about it. http://github.com/masak/lambda-calculus/commits/master

[09:01] <masak> but now I have a case of a left-recursive rule, and I'm thinking about how best to handle it.

[09:02] <masak> here's what the Wikipedia page has to say about it: "Applications are assumed to be left associative: M N P may be written instead of ((M N) P)"

[09:03] <masak> so both of these create the AST `app[ app[M, N], P ]`.

[09:03] <moritz> with a quantifier :-)

[09:03] <masak> heh :)

[09:03] <masak> yes, the thought crossed my mind.

[09:03] <masak> and then just have the action method create the right AST.

[09:03] <moritz> right

[09:03] <masak> moritz++

[09:04] <moritz> or

[09:04] <moritz> build a parser generator that correctly handles left recursion :-)

[09:04] <masak> yeah.

[09:04] <moritz> or take an existing one :-)

[09:04] <masak> I was wondering if maybe the new LTM-y bits would correctly handle left recursion.

[09:04] <moritz> you can make bison emit its jump table

[09:04] <moritz> recursion terminates longest prefixes

[09:04] <masak> but there's a potential infinity in there which I guess is a bit too much even for our LTM.

[09:04] <moritz> so, no

[09:04] <masak> ah, yes.

[09:05] <masak> does that go for mutual recursion as well? that must be a hoot to compute.

[09:05] <moritz> mutual recursion also terminates longest prefixes

[09:05] * masak head spins

[09:06] <moritz> well, it would be much harder to have it not terminate LTM :-)

[09:06] <moritz> because it would mean the NFA/DFA builder would need to know how to turn recursion into quantifiers

[09:06] <masak> ah well. it's declarative, and everyone knows declarations don't require any computation :P

[09:06] <moritz> now you can just have a hash with all method names that have already been visited (when doing the declarative prefix calculations)

[09:07] <masak> ah; yes.

[09:07] <masak> hm.

[09:07] <moritz> I'd say that's one of the simpler parts of LTM implementation :-)

[09:07] <masak> I can't quite get that to fit, though.

[09:07] <masak> you have to remove stuff from that hash as you go up the call tree.

[09:08] <masak> oh, I guess it works out.

[09:08] <arnsholt> I think the "standard" way to avoid left-recursion in CFGs is to refactor the grammar

[09:08] <moritz> masak: you just have to copy the hash for each new branch

[09:09] <arnsholt> There's a weakly equivalent (same language, but different parse tree) Greibach normal form for all CFGs

[09:09] <dalek> doc: c6ac771 | moritz++ | lib/objects.pod:

[09:09] <dalek> doc: [objects] inheritance, object construction

[09:09] <dalek> doc: review: https://github.com/perl6/doc/commit/c6ac77175f

[09:09] <moritz> ah yes, I remember that fun in the formal languages class :-)

[09:09] <masak> oh, so much to learn... :)

[09:10] <moritz> reviews of the commit above would be very welcome

[09:10] <moritz> is it understandable, is it correct?

[09:11] * masak reviews

[09:12] <masak> s/the parents' method/the parents classes' method/, perhaps?

[09:13] <masak> s/of the name/of that name/ -- and this doesn't address "longnames".

[09:13] <masak> s/The order by which/The order in which/

[09:13] <masak> s/\(mro\)/(MRO)/

[09:14] <sorear> sleep&

[09:14] <masak> 'night, sorear.

[09:15] <masak> "All calls to public method are "virtual" in the C++ sense" -- nitpick: is it the call that is virtual? or the public method?

[09:15] <masak> "Point.new( x => 1, y  => 2);" -- unbalanced whitespace inside parens.

[09:16] *** mberends joined
[09:16] <mberends> o/

[09:16] <masak> mberends! \o/

[09:16] <masak> s/\(ie/(i.e./

[09:17] * mberends had time to read irclogs for a change :-)

[09:18] <moritz> \o mberends 

[09:18] <dalek> doc: 2c69e87 | moritz++ | lib/objects.pod:

[09:18] <dalek> doc: fixes by masak++

[09:18] <dalek> doc: review: https://github.com/perl6/doc/commit/2c69e87601

[09:19] *** Khisanth left
[09:19] <masak> ss/However this is considered poor practi<(s)>e/c/

[09:19] * masak loves <( )>

[09:20] <masak> moritz: maybe worth pointing out that the $!attr binding in BUILD isn't particular to BUILD, or even submethods

[09:20] <masak> anyway, moritz++. nice, clear explanation.

[09:20] *** Khisanth joined
[09:21] <masak> oh, and I'd perhaps go with s/much harder/harder/ in the end. :)

[09:26] *** brrt joined
[09:27] <arnsholt> Oooh. <( )> is pretty spiffy

[09:29] <masak> moritz, arnsholt: ended up refactoring my l-recursion into a quantifier :) thanks.

[09:32] * JimmyZ_ likes <( )> too.

[09:41] *** brrt left
[09:41] *** brrt joined
[09:44] <masak> rn: grammar G { regex TOP { ^ $ { make "OH HAI" } } }; say G.parse('').ast

[09:44] <p6eval> rakudo 1f662c, niecza v19-15-g051783d: OUTPUT«OH HAI␤»

[09:45] <masak> hm.

[09:45] *** PacoAir joined
[09:46] <jnthn> moritz++ # taking my scribblings in objects.pod and adding loads more to them :)

[09:47] <jnthn> good morningish 

[09:47] <masak> good mornington, jnthn.

[09:47] <masak> rn: grammar G { regex TOP { ^ <foo> $ { make $<foo>.ast } }; regex foo { foo { make "OH HAI" } } }; say G.parse('foo').ast

[09:47] <p6eval> rakudo 1f662c, niecza v19-15-g051783d: OUTPUT«OH HAI␤»

[09:48] <JimmyZ_> good morning jnthn 

[09:50] <masak> rn: grammar G { regex TOP { ^ <foo> $ { make $<foo>.ast } }; regex foo { [foo|bar] { make "OH HAI" } } }; say G.parse('foo').ast

[09:50] <p6eval> rakudo 1f662c, niecza v19-15-g051783d: OUTPUT«OH HAI␤»

[09:54] <dalek> doc: 12121ef | jimmy++ | lib/objects.pod:

[09:54] <dalek> doc: fixed typo.

[09:54] <dalek> doc: review: https://github.com/perl6/doc/commit/12121ef7e0

[10:02] * arnsholt starts reading up on S26

[10:09] *** sftp left
[10:13] *** u_u joined
[10:16] *** GlitchMr left
[10:20] *** xinming left
[10:20] *** xinming joined
[10:29] *** brrt left
[10:31] *** brrt joined
[10:31] *** spider-mario joined
[10:33] *** brrt left
[10:36] *** M_o_C joined
[10:43] *** SamuraiJack left
[10:43] <masak> hehe. the 'λx.M N' abbreviation associates to the left ('(λx.M) N'), but the 'λxyz.N' abbreviation associates to the right ('λx(λy(λz.N))').

[10:44] <masak> er, sorry. 'λx.(λy.(λz.N))'

[10:45] <shachaf> λxyz.N isn't really "associating"

[10:46] <masak> but left-associations translate into for loops, and right-associations translate into reverse for loops. the body of the for loop does a new 'make' with $/.ast somewhere inside its new argument.

[10:46] <masak> shachaf: oh?

[10:46] <shachaf> Oh, you weren't done.

[10:46] <masak> shachaf: there's a variable and an expression. two things. it associates.

[10:46] <shachaf> What would it mean for it to associate to the left?

[10:47] <masak> ...heh.

[10:48] <arnsholt> shachaf: For some operators, whether you go from right to left or left to right matters

[10:48] <masak> yeah, I guess there's something else going on here than associativity.

[10:48] <masak> but it felt just like associativity. strange.

[10:49] <moritz> it's a bit like with multiple prefix operators

[10:49] <shachaf> arnsholt: Sure. But there's no operator here, really.

[10:49] <moritz> !+$foo can *only* mean !(+$foo)

[10:49] <moritz> because (!+)($foo) doesn't make sense

[10:49] <masak> right.

[10:49] <masak> so it's just a kind of nesting.

[10:49] <moritz> right

[10:49] <moritz> shachaf++

[10:50] *** crab2313 joined
[10:51] <masak> this is very clean and makes me happy: https://github.com/masak/lambda-calculus/commit/aae9c586973222ee4b0980c9f1c15b23ce805cfe

[10:51] <moritz> ooh, nice use of make and $/.ast to avoid a variable to hold the intermediate AST

[10:51] <masak> hm, which is nicer, 'reverse $<variable>[0..*-2]', or '$<variable>[reverse 0..*-2]'?

[10:52] <masak> moritz: yeah, that's what I meant above.

[10:52] *** spider-mario left
[10:52] <moritz> the first

[10:52] <dalek> rakudo/inliner: 25d7c81 | jnthn++ | src/Perl6/Optimizer.pm:

[10:52] <masak> why?

[10:52] <dalek> rakudo/inliner: A further allomorphy tweak, fixing one more test that the inliner regressed.

[10:52] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/25d7c818a7

[10:52] <dalek> rakudo/inliner: 72075f2 | jnthn++ | src/Perl6/Actions.pm:

[10:52] <dalek> rakudo/inliner: Don't consider things that use pseudo-packages to be inlinable.

[10:52] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/72075f2eca

[10:52] <moritz> it has the advantage of working

[10:52] <masak> huh?

[10:52] <masak> oh!

[10:52] <moritz> 0..*-2 is a WhateverCode

[10:52] <masak> right.

[10:52] <masak> sometimes I have too high expectations on *

[10:53] <shachaf> Hah, "Lambda/Calculus.pm"

[10:53] <jnthn> .oO( When you wish up on a *... )

[10:53] <moritz> well, it does do many things right intuitively

[10:53] <moritz> masak: in fact, (0..^*-2).reverse works

[10:53] <masak> 'course, I could go '$<variable>[*-2 ... 0]' ;)

[10:54] <masak> or, hm.

[10:54] <moritz> I don't think you can

[10:54] <masak> no.

[10:54] <moritz> because the series is evaluated first

[10:54] <masak> rn: my @a = <a b c d e f g>; .say for @a[*-2 ... 0]

[10:54] <p6eval> rakudo 1f662c: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in block  at /tmp/M0eDqs6Y7Y:1␤␤»

[10:54] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Need more items on the LHS␤  at /home/p6eval/niecza/lib/CORE.setting line 1414 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3147 (get-next-closure @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3191 (ANON @ 17) ␤  a…

[10:54] <masak> right.

[10:54] <masak> the series grabs the whatevs.

[10:55] *** bluescreen10 left
[10:55] *** whiteknight joined
[10:56] *** whiteknight is now known as Guest54824

[10:57] <dalek> doc: 4d4236e | moritz++ | lib/objects.pod:

[10:57] <dalek> doc: [objects] roles, role application

[10:57] <dalek> doc: review: https://github.com/perl6/doc/commit/4d4236ec43

[10:58] <moritz> jnthn: in your talks on roles, do you have a better example than DrunkenGymnast for role conflicts?

[10:58] * moritz would like to steal one :-)

[10:59] <masak> what? clearly, that's the best example possible! :P

[11:01] <masak> here's one: role VScrollable { method scroll($dy) { ... } }; role HScrollable { method scroll($dx) { ... } }; class MyWindow does VScrollable does HScrollable {}

[11:02] <jnthn> moritz: I recall doing one where it was about booking a train ticket, and there was a $.line (as in, which railway line) but it conflicting with a $.line related to "line on the invoice"

[11:02] *** JimmyZ_ left
[11:06] <moritz> masak: hm, nice

[11:06] *** GlitchMr joined
[11:07] *** bluescreen10 joined
[11:11] *** JimmyZ joined
[11:30] *** crab2313 left
[11:34] <GlitchMr> perl6: printf '% %'

[11:34] <p6eval> rakudo 1f662c: OUTPUT«'%' is not a valid sprintf format␤  in sub sprintf at src/gen/CORE.setting:2079␤  in sub printf at src/gen/CORE.setting:2084␤  in block  at /tmp/jZhTBBbewa:1␤␤»

[11:34] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: invalid format specifier␤  at /home/p6eval/niecza/lib/CORE.setting line 1286 (sprintf @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1287 (printf @ 5) ␤  at /tmp/RNA187pMhC line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE…

[11:35] *** gongyiliao joined
[11:35] <GlitchMr> But... Perl 6 Synopsis allows things like '% %'

[11:35] <GlitchMr> I guess it's bug in synopsis

[11:37] *** fgomez left
[11:38] *** birdwindupbird joined
[11:41] <dalek> doc: 3a0a898 | moritz++ | lib/objects.pod:

[11:41] <dalek> doc: roles and stubs

[11:41] <dalek> doc: review: https://github.com/perl6/doc/commit/3a0a8986bd

[11:43] <masak> GlitchMr: yes, I would say so.

[11:45] <masak> GlitchMr: though C prints '%' on printf("% %");

[11:45] <masak> so maybe we should allow it after all.

[11:46] <moritz> perl 5 also prints %

[11:56] *** crab2313 joined
[12:07] *** crab2313 left
[12:08] <dalek> nqp: 6589656 | jnthn++ | src/QAST/Operations.nqp:

[12:08] <dalek> nqp: Add a way for ops evaluating to native types to attach that information to nodes.

[12:08] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6589656170

[12:08] *** brrt joined
[12:09] <dalek> rakudo/inliner: 4a658ee | jnthn++ | src/ (4 files):

[12:09] <dalek> rakudo/inliner: Fix return type check handling when inlining.

[12:09] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/4a658ee913

[12:09] <dalek> rakudo/inliner: 57697e2 | jnthn++ | src/Perl6/Actions.pm:

[12:09] <dalek> rakudo/inliner: Attach return types to nqp::op nodes.

[12:09] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/57697e2798

[12:15] *** MayDaniel joined
[12:17] *** brrt left
[12:19] *** _fall0ut_ joined
[12:21] *** driador left
[12:43] <masak> nr: class A { class B {}; method foo { say B.new } }; A.new.foo

[12:43] <p6eval> niecza v19-15-g051783d: OUTPUT«B.new(...)␤»

[12:43] <p6eval> ..rakudo 1f662c: OUTPUT«B.new()␤»

[12:43] <masak> nr: class A::B { class C {}; method foo { say C.new } }; A::B.new.foo

[12:43] <p6eval> niecza v19-15-g051783d: OUTPUT«C.new(...)␤»

[12:43] <p6eval> ..rakudo 1f662c: OUTPUT«C.new()␤»

[12:47] *** M_o_C left
[12:48] <masak> folks, Crypt::Game is now called Game::Crypt. and Hanoi::Game is called Game::Hanoi. all tests still pass and all CLIs still run.

[12:48] <masak> I believe the code got a little better for it, too. japhb++

[12:49] *** user joined
[12:49] <JimmyZ> masak++

[12:50] *** brrt joined
[12:52] <masak> I've received *lots* of good crypt feedback from Keving Coyler, the winner of July's open challenge.

[12:53] <masak> I will trawl through it during the weekend, as I find slots of time.

[12:58] *** tokuhiro_ joined
[12:58] <dalek> rakudo/inliner: 3bfb7a6 | jnthn++ | src/ (4 files):

[12:58] <dalek> rakudo/inliner: Very minimal implementation of the 'soft' pragma, but enough that we'll be able to use it to make wrap.t happy.

[12:58] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/3bfb7a68d6

[13:04] * masak hugs vim digraphs

[13:09] <dalek> rakudo/nom: 5cd3686 | jnthn++ | src/Perl6/Ops.pm:

[13:09] <dalek> rakudo/nom: Mark some Perl 6 ops as inlinable.

[13:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5cd36869f8

[13:09] <dalek> rakudo/nom: 958a3ea | jnthn++ | src/ (2 files):

[13:09] <dalek> rakudo/nom: We will keep around the QAST tree of inlinable things now, not some string thingy.

[13:09] *** dalek left
[13:09] *** nodmonkey left
[13:10] *** dalek joined
[13:10] *** ChanServ sets mode: +v dalek

[13:10] *** mberends left
[13:10] <moritz> ooh, inliner merged?

[13:11] <jnthn> Yeah

[13:11] <masak> yay.

[13:11] <masak> jnthn++

[13:11] <moritz> \o/

[13:11] <jnthn> It's able to inline more stuff

[13:11] <jnthn> Also

[13:11] <jnthn> r: say 2 +< 63

[13:11] <p6eval> rakudo 1f662c: OUTPUT«0␤»

[13:11] <jnthn> > say 2 +< 63

[13:11] <jnthn> 18446744073709551616

[13:12] <jnthn> Those kinds of things are mixed.

[13:12] <moritz> \o/

[13:12] <jnthn> It's less stupid about literal allomorphy, or whatever it's called. :)

[13:12] <jnthn> s/mixed/fixed/

[13:13] <jnthn> oh, dang, I needed to bump NQP_REVISION

[13:14] <moritz> I like to call it stupomorphy :-)

[13:14] <dalek> rakudo/nom: 5f2af91 | jnthn++ | tools/build/NQP_REVISION:

[13:14] <dalek> rakudo/nom: Bump NQP_REVISION to get improvements needed by the inliner.

[13:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5f2af91226

[13:16] *** brrt left
[13:19] *** user left
[13:22] *** boni joined
[13:24] *** mberends joined
[13:27] <dalek> nqp: e401db5 | jnthn++ | src/6model/serialization.c:

[13:27] <dalek> nqp: Re-enable re-use of strings on the string heap; it makes a fairly notable difference to the output size of CORE.setting compilation, and a small but certainly worthwhile difference to CORE.setting compilation time. Causes no issues here; hopefully not for anyone else now either.

[13:27] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e401db56c3

[13:29] *** boni left
[13:31] <dalek> rakudo/nom: 44cb610 | jnthn++ | tools/build/NQP_REVISION:

[13:31] <dalek> rakudo/nom: Get string sharing optimization for faster builds.

[13:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/44cb6102f7

[13:31] <dalek> rakudo/nom: 5e1b9a8 | jnthn++ | docs/ChangeLog:

[13:31] <dalek> rakudo/nom: ChangeLog updates.

[13:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5e1b9a8d61

[13:31] <jnthn> away for a bit

[13:34] *** cognominal_ joined
[13:35] *** leprevost joined
[13:37] *** cognominal left
[13:44] *** cognominal_ left
[13:48] *** awwaiid left
[13:49] <JimmyZ> hmm, I didn't get a difference to the output size of CORE.setting compilation

[13:51] <JimmyZ> sorry, wrong nqp branch

[13:53] *** awwaiid joined
[13:53] <GlitchMr> [\+] ^Inf

[13:54] <GlitchMr> I like Perl 6 :)

[13:54] <masak> :)

[13:54] <GlitchMr> I like how this list is lazy

[13:55] <masak> well, it turns out it's much easier to have infinite lists if they're lazy... :)

[13:55] <GlitchMr> > ([\+] ^Inf)[^20]

[13:55] <GlitchMr> 0 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120 136 153 171 190

[13:55] <GlitchMr> :)

[13:55] <GlitchMr> (well, ok, I could just type [\+] ^20, but whatever

[13:55] <masak> the \ was chosen because it makes like a little triangle with the [

[13:59] <GlitchMr> > 'ł' gt 'z'

[13:59] <GlitchMr> True

[13:59] <GlitchMr> Well, I guess that 'ł' is indeed bigger basing on codepoint

[13:59] <masak> yes.

[13:59] <masak> if you want locale-specific sorting, you have to specify that.

[13:59] <GlitchMr> How?

[13:59] <masak> through some means not specified by the Perl 6 spec.

[14:00] <masak> that sounds like a CPAN module to me.

[14:01] <GlitchMr> > sort 'a' .. 'z', <ą ć ę ł ń ó ś ź ż>

[14:01] <GlitchMr> a b c d e f g h i j k l m n o p q r s t u v w x y z ó ą ć ę ł ń ś ź ż

[14:01] <GlitchMr> This isn't really useful

[14:01] <masak> depends on your use case.

[14:02] <GlitchMr> I was doing it wrong all along

[14:02] <GlitchMr> I shouldn't use sort with names

[14:02] <masak> well, you should.

[14:03] <masak> just not the default string sort.

[14:04] <GlitchMr> But whatever, it's hard to determine what should be first: > sort 'a' .. 'z', <ą ć ę ł ń ó ś ź ż>

[14:04] <GlitchMr> oops

[14:04] <GlitchMr> sorry for paste

[14:04] <GlitchMr> ß or ś for example

[14:05] <GlitchMr> What should be first? I've no idea

[14:05] <masak> that's why you need a locale.

[14:05] <mucker> hi ... what does <!before ...> mean ?

[14:06] <GlitchMr> Well, in case of ß or ś those characters belong to different languages

[14:06] <masak> r: my $polish-alphabet = 'aąbcćdeęfghijklłmnńoópqrsśtuvwxyzźż'; sub polishly($c) { $polish-alphabet.index($c) }; say ('a' .. 'z', <ą ć ę ł ń ó ś ź ż>).sort(&polishly)

[14:06] <p6eval> rakudo 1f662c: OUTPUT«a ą ć ę ł ń ó ś ź ż b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[14:06] <masak> \o/

[14:06] <masak> GlitchMr: yes. they belong to different languages.

[14:06] <JimmyZ> r: say 6.9 / 7.7

[14:06] <p6eval> rakudo 1f662c: OUTPUT«0.896104␤»

[14:06] <masak> mucker: it's a zero-width look-ahead.

[14:08] <Timbus> did uh

[14:08] <Timbus> did that actually sort

[14:08] <mucker> i basically want to match any characters before END .. so i'm thinking the regex should look like <!before END <.+>>

[14:08] <masak> oh ye of little faith :)

[14:08] <GlitchMr> <!before > is (?! ) in Perl 5 (if I think correctly)

[14:08] <masak> r: my $polish-alphabet = 'aąbcćdeęfghijklłmnńoópqrsśtuvwxyzźż'; sub polishly($c) { $polish-alphabet.index($c) }; say ('b', 'c', 'a', 'd' .. 'z', <ą ć ę ł ń ó ś ź ż>).sort(&polishly)

[14:08] <p6eval> rakudo 1f662c: OUTPUT«a ą ć ę ł ń ó ś ź ż b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[14:08] <masak> \o/

[14:09] <masak> oh, but it still puts the weird chars wrong :/

[14:09] <Timbus> so they all just come before 'b'

[14:09] <GlitchMr> That sort is weird

[14:09] <masak> no :(

[14:09] * masak can't see immediately what's wrong

[14:10] <masak> r: my $polish-alphabet = 'aąbcćdeęfghijklłmnńoópqrsśtuvwxyzźż'; sub polishly($c) { $polish-alphabet.index($c) }; say ('a' .. 'z', <ą ć ę ł ń ó ś ź ż>)>>.&polishly

[14:10] <p6eval> rakudo 1f662c: OUTPUT«0 2 3 5 6 8 9 10 11 12 13 14 16 17 19 21 22 23 24 26 27 28 29 30 31 32 1 4 7 15 18 20 25 33 34␤»

[14:11] <masak> that looks... right.

[14:12] <GlitchMr> n: my $polish-alphabet = 'aąbcćdeęfghijklłmnńoópqrsśtuvwxyzźż'; sub polishly($c) { $polish-alphabet.index($c) }; say ('b', 'c', 'a', 'd' .. 'z', <ą ć ę ł ń ó ś ź ż>).sort(&polishly)

[14:12] <p6eval> niecza v19-15-g051783d: OUTPUT«d e f g h i j k l m n o p q r s t u v w x y z ą ć ę ł ń ó ś ź ż a b c␤»

[14:12] <GlitchMr> huh?

[14:12] <masak> there's something I'm missing here.

[14:12] <GlitchMr> r: ('b', 'c', 'a', 'd' .. 'z', <ą ć ę ł ń ó ś ź ż>).flat.sort: {'aąbcćdeęfghijklłmnńoópqrsśtuvwxyzźż'.index($_)}

[14:12] <p6eval> rakudo 1f662c:  ( no output )

[14:13] <GlitchMr> r: my $polish-alphabet = 'aąbcćdeęfghijklłmnńoópqrsśtuvwxyzźż'; sub polishly($c) { $polish-alphabet.index($c) }; say ('b', 'c', 'a', 'd' .. 'z', <ą ć ę ł ń ó ś ź ż>).flat.sort(&polishly)

[14:13] <p6eval> rakudo 1f662c: OUTPUT«a ą b c ć d e ę f g h i j k l ł m n ń o ó p q r s ś t u v w x y z ź ż␤»

[14:13] <masak> GlitchMr++

[14:13] <masak> yeah. there was a .flat missing.

[14:13] <masak> I'm surprised it's needed.

[14:14] <GlitchMr> I guess that Rakudo sorted by first character in list for some reason

[14:14] *** sneex joined
[14:14] <GlitchMr> karma GlitchMr

[14:14] <aloha> GlitchMr has karma of 12.

[14:15] <GlitchMr> Good enough I guess :)

[14:15] <Timbus> r: say ('b', 'c', 'a', 'd' .. 'z', <ą ć ę ł ń ó ś ź ż>).perl

[14:15] <p6eval> rakudo 1f662c: OUTPUT«("b", "c", "a", "d".."z", ("ą", "ć", "ę", "ł", "ń", "ó", "ś", "ź", "ż"))␤»

[14:15] <masak> that looks right.

[14:15] <Timbus> just m,aking sure

[14:16] <GlitchMr> It's not Perl 5 where lists are automatically flattened when possible

[14:17] <GlitchMr> In Perl 5, my %hash = (key => do_something()) always calls do_something in list context

[14:18] <GlitchMr> Potentially causing warnings about missing value for key

[14:19] <GlitchMr> Usually scalar do_something() or [do_something()] or {do_something()} is what you want

[14:23] *** cognominal joined
[14:23] *** cognominal left
[14:23] *** cognominal joined
[14:30] *** Chillance joined
[14:30] *** tokuhiro_ left
[14:31] *** tokuhiro_ joined
[14:31] <GlitchMr> perl6: my hash = <a b c d>; print "%a{}{}[]{}";

[14:31] <p6eval> rakudo 5e1b9a: OUTPUT«===SORRY!===␤Malformed my␤at /tmp/gHUsgsPaoi:1␤»

[14:31] <p6eval> ..niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed my at /tmp/3SQaGq_ZML line 1:␤------> [32mmy[33m⏏[31m hash = <a b c d>; print "%a{}{}[]{}";[0m␤␤Parse failed␤␤»

[14:31] <GlitchMr> perl6: my %hash = <a b c d>; print "%hash{}{}[]{}";

[14:31] <p6eval> rakudo 5e1b9a: OUTPUT«a b c     d»

[14:31] <p6eval> ..niecza v19-15-g051783d: OUTPUT«a        b␤c     d␤»

[14:32] <GlitchMr> std: my %hash = <a b c d>; print "%hash{}{}[]{}";

[14:32] <p6eval> std f43a358: OUTPUT«ok 00:00 42m␤»

[14:32] *** Chat3354 joined
[14:34] *** Chat3354 left
[14:35] *** tokuhiro_ left
[14:39] *** nwc10 joined
[14:39] <nwc10> what is the 'soft' pragma?

[14:41] <jnthn> nwc10: See 2889 on in S06

[14:42] *** sneex left
[14:42] <masak> S06:2889 # creates a link in the irclogs

[14:42] <nwc10> thanks

[14:42] *** brrt joined
[14:43] <nwc10> gosh, I think I must have read that at some time, maybe years ago

[14:43] <nwc10> as I remember this phrase: Be aware that this may turn your optimizer into more of a "pessimizer". 

[14:44] <nwc10> is it Christmas yet? :-/

[14:45] <jnthn> It's *August* :P

[14:49] <mucker> is this a right regex  <!before END <.+>> ?? 

[14:49] <mucker> before END match anychars

[14:49] <jnthn> That doesn't look like it's doing what you wish.

[14:50] <mucker> :(

[14:50] <jnthn> In fact, it really ain't

[14:50] <jnthn> What's an example of the string you're trying to match?

[14:51] <mucker> "foo bar baz END" ... I want to match "foo bar baz "

[14:51] <masak> sounds more like you want to set up a goal.

[14:52] <jnthn> Dunno goal matching is gonna work out too well for this.

[14:52] <jnthn> Maybe...

[14:52] <masak> r: say "foo bar baz END" ~~ / '' ~ 'END' [\w+ % [\s+]] /

[14:52] <p6eval> rakudo 5e1b9a: OUTPUT«Unable to parse , couldn't find final 'END'␤  in any FAILGOAL at src/stage2/QRegex.nqp:862␤  in regex  at /tmp/a1AOYX8xFc:1␤  in method ACCEPTS at src/gen/CORE.setting:9884␤  in block  at /tmp/a1AOYX8xFc:1␤␤»

[14:52] <jnthn> r: say "foo bar baz END" ~

[14:52] <p6eval> rakudo 5e1b9a: OUTPUT«===SORRY!===␤Confused␤at /tmp/hakFlunXjw:1␤»

[14:52] <jnthn> argh

[14:52] <masak> r: say "foo bar baz END" ~~ / '' ~ 'END' [<!before END> \w+ % [\s+]] /

[14:52] <p6eval> rakudo 5e1b9a: OUTPUT«Unable to parse , couldn't find final 'END'␤  in any FAILGOAL at src/stage2/QRegex.nqp:862␤  in regex  at /tmp/xQxbJyjH5m:1␤  in method ACCEPTS at src/gen/CORE.setting:9884␤  in block  at /tmp/xQxbJyjH5m:1␤␤»

[14:52] <jnthn> r: say "foo bar baz END" ~~ /.+? <before END>/

[14:52] <p6eval> rakudo 5e1b9a: OUTPUT«q[foo bar baz ]␤ before => q[]␤␤»

[14:53] <jnthn> r: say "foo bar baz END" ~~ /.+? <?before END>/

[14:53] <p6eval> rakudo 5e1b9a: OUTPUT«q[foo bar baz ]␤␤»

[14:53] <jnthn> That may be one way

[14:53] <masak> yeah, but it backtracks a lot. :/

[14:53] <jnthn> Relies on backtracking though.

[14:53] <masak> (forwards)

[14:53] <mucker> Ah ! thnkx was confused about the before's syntax

[14:53] *** nwc10 left
[14:54] <jnthn> Curiously, it is declarative.

[14:54] <masak> not so curious, I think.

[14:54] *** u_u left
[14:54] <jnthn> oh, hmm, maybe anyway

[14:54] <jnthn> But yeah, it ain't so efficient.

[14:54] <masak> in the best case, its contents is just more DFA :)

[14:55] <mucker> also whats the p6 equivalent of [^\d]

[14:56] <masak> <-[\d]>

[14:57] <jnthn> \D 

[14:57] <masak> heh.

[14:58] <masak> suggestion for a bot: p5re-to-p6re-bot.

[14:58] <masak> (maybe with a better name) :)

[14:58] <GlitchMr> Hmmm... that sounds interesting

[14:58] <GlitchMr> Perhaps I should implement this as part of my IRC bot

[14:59] <masak> good luck :)

[14:59] <GlitchMr> Well, if I would parse Perl 5 regexpes first :P.

[14:59] <GlitchMr> Regexpes like: /$a)/ could mean anything

[15:00] <masak> I could imagine implementing something like that with someone as a weekend hackathon thing.

[15:03] <GlitchMr> I mean, Perl is already too clever for its good when it sees any variables in RegExp

[15:03] <GlitchMr> /$length[2345]/

[15:03] <GlitchMr> ^ what this does?

[15:04] <GlitchMr> And what this does?

[15:04] <GlitchMr> /$length[23]/

[15:06] <masak> the main task of such a bot would not be to get it right each time, but to be informative.

[15:06] <GlitchMr> I mean, $length[2345] is variable $length followed by character class [2345]

[15:06] <GlitchMr> $length[23] is variable $length[23]

[15:06] <masak> for example, both of the parentheses-to-indices systems in p5 and p6 are statically knowable, but in different ways.

[15:07] <masak> GlitchMr: oh? what's the difference? just the size of the number?

[15:07] <GlitchMr> Yes

[15:07] <masak> what's the rule?

[15:07] <GlitchMr> I've no idea

[15:09] <GlitchMr> I read about this in... perldiag

[15:09] <GlitchMr> Ambiguous use of %c{%s[...]} resolved to %c%s[...]

[15:12] *** u_u joined
[15:12] <GlitchMr> "Interpolation in patterns has several quirks: $| , $( , $) , @+ and @- are not interpolated, and constructs $var[SOMETHING] are voted (by several different estimators) to be either an array element or $var followed by an RE alternative."

[15:13] <GlitchMr> Voted?

[15:13] <GlitchMr> VOTED?

[15:13] <GlitchMr> I know about DWIM, but isn't this going too far?

[15:14] *** brrt1 joined
[15:14] <masak> wrong channel to be upset about this :)

[15:15] *** brrt left
[15:16] <GlitchMr> I wonder how it is possible that Perl 5 uses like everything EXCEPT for spaces for DWIM.

[15:17] <masak> "Perl 5 users" isn't one coherent group with just one opinion.

[15:18] <huf> the solution is simple! let's give : and {/} yet another meaning!

[15:18] <GlitchMr> Now I wonder how it is voted :P.

[15:18] *** brrt1 left
[15:19] *** nodmonkey joined
[15:23] *** brrt joined
[15:26] <GlitchMr> http://paste.uk.to/c6569207

[15:26] <GlitchMr> Why I have so pointless utilities on my PC...

[15:27] *** MayDaniel left
[15:28] *** cognominal_ joined
[15:31] *** cognominal left
[15:31] *** brrt left
[15:34] *** brrt joined
[15:45] *** brrt left
[15:46] *** SamuraiJack joined
[15:50] <birdwindupbird> How can one get AST for some statements?

[15:50] <masak> could you provide more of the context in which you're asking this question?

[15:54] <birdwindupbird> Sorry. I am trying to golf why LEAVE phaser do not fire in multi sub. I want to see AST of such sub. I am trying 'perl6 --target=past -e "my $k = 1; $k++". But get 'Method '__dump' not found for invocant of class 'Any'. May be i am doing it wrong way?

[15:57] <masak> last I heard, --target=past was never really updated for the nom/6model branches.

[15:57] <masak> so it's inaccessible except for perhaps really simple stuff, if that.

[15:59] <birdwindupbird> Ok. May be there are other means to look into AST?

[16:00] *** snearch joined
[16:00] <masak> no. the feature doesn't seem to be a priority among those who can implement it (jnthn++ and pmichaud++, basically).

[16:01] <jnthn> Well, thing is that phasers are (a) declarative and (b) fired by something in perl6.ops.

[16:01] <masak> which I somewhat understand. it's not on a critical path.

[16:01] <jnthn> I'm doubtful that even if --target=past worked it would yield too many clues.

[16:02] <jnthn> r: multi foo() { 1; LEAVE { say 'bai' } }; foo();

[16:02] <p6eval> rakudo 5e1b9a:  ( no output )

[16:02] <jnthn> r: multi foo(:$x) { 1; LEAVE { say 'bai' } }; foo();

[16:02] <p6eval> rakudo 5e1b9a:  ( no output )

[16:02] *** MayDaniel joined
[16:02] <jnthn> r: multi foo(:$x) { 1; ENTER { say 'hi' } }; foo();

[16:02] <p6eval> rakudo 5e1b9a: OUTPUT«hi␤»

[16:03] <masak> submitted on 2012-06-07 by moritz++: https://rt.perl.org/rt3/Ticket/Display.html?id=113548

[16:05] <birdwindupbird> jnthn: Thanks. I am just trying to find my way into improvement of perl6. My steps seem incompetent and naive, i know. :)

[16:06] <masak> birdwindupbird++

[16:07] <birdwindupbird> First "plus-plus". It's so inspiring...

[16:08] <GlitchMr> karma birdwindupbird 

[16:08] <aloha> birdwindupbird has karma of 1.

[16:08] <jnthn> Yeah, I've little idea why we've problems with LEAVE phasers (I guess UNDO and KEEP also) in multis...it's a curious bug.

[16:09] <jnthn> I wonder if it's anything to do with the callframe re-use that happens in enter_multi_dispatch op.

[16:09] *** gongyiliao left
[16:10] *** MayDaniel left
[16:22] <dalek> nqp/toqast: 2637cf1 | jnthn++ | src/NQPQ/World.pm:

[16:22] <dalek> nqp/toqast: Create scopes as QAST::Block.

[16:22] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/2637cf1e3d

[16:22] <dalek> nqp/toqast: 8ef56a3 | jnthn++ | src/NQPQ/Actions.pm:

[16:22] <dalek> nqp/toqast: Update a couple other block creations to use QAST.

[16:22] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/8ef56a31d3

[16:22] <dalek> nqp/toqast: 18cec82 | jnthn++ | src/NQPQ/ (2 files):

[16:22] <dalek> nqp/toqast: Update comp_unit to start using QAST::CompUnit, and tackle some of the other bits of comp_unit updating.

[16:22] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/18cec8216a

[16:23] <dalek> nqp/toqast: d579e84 | jnthn++ | src/NQPQ/World.pm:

[16:23] <dalek> nqp/toqast: Update compile-time binding of lexicals.

[16:23] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/d579e8410e

[16:23] <dalek> nqp/toqast: a05823a | jnthn++ | src/NQPQ/Actions.pm:

[16:23] *** bluescreen10 left
[16:23] <dalek> nqp/toqast: Pull in CTXSAVE override (will update the default one in HLL::Actions after QAST migration).

[16:23] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/a05823abf7

[16:23] *** birdwindupbird left
[16:25] *** xinming left
[16:27] *** xinming joined
[16:27] *** mucker left
[16:28] <dalek> nqp/toqast: 476dd8e | jnthn++ | src/NQPQ/Actions.pm:

[16:28] <dalek> nqp/toqast: Correct :hll copy-pasto.

[16:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/476dd8e222

[16:28] <dalek> nqp/toqast: 8440713 | jnthn++ | src/NQPQ/Actions.pm:

[16:28] <dalek> nqp/toqast: Update argument list processing for QAST.

[16:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/8440713c28

[16:28] <dalek> nqp/toqast: 10f4753 | jnthn++ | src/NQPQ/Actions.pm:

[16:28] <dalek> nqp/toqast: Update numeric literal handling. Now with no setting/regex lib loading, nqp::say(42) works.

[16:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/10f4753f6e

[16:39] *** SamuraiJack left
[16:46] *** benabik left
[16:57] *** phenny left
[16:57] *** phenny joined
[16:57] *** cognominal_ left
[17:07] *** cognominal joined
[17:11] *** JimmyZ left
[17:11] <dalek> nqp/toqast: b9f1e11 | jnthn++ | src/NQPQ/Actions.pm:

[17:11] <dalek> nqp/toqast: Add an EXPR that produces QAST.

[17:11] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/b9f1e11787

[17:11] <dalek> nqp/toqast: a5e4e27 | jnthn++ | src/NQPQ/Grammar.pm:

[17:11] <dalek> nqp/toqast: Update most of the operators to use :op instead of :pirop/:pasttype.

[17:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/a5e4e27baa

[17:12] <dalek> nqp/toqast: c945388 | jnthn++ | src/NQPQ/Actions.pm:

[17:12] <dalek> nqp/toqast: Couple of fixes so if/unless now work again.

[17:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/c945388cb0

[17:12] <dalek> nqp/toqast: cd9fe1d | jnthn++ | src/QAST/Operations.nqp:

[17:12] <dalek> nqp/toqast: Add an nqp::isfalse to go with nqp::istrue; NQP wants it.

[17:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/cd9fe1dd46

[17:12] <dalek> nqp/toqast: 375dfd0 | jnthn++ | src/NQPQ/ (2 files):

[17:12] <dalek> nqp/toqast: Get setting/module loading to work again.

[17:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/375dfd0b60

[17:12] <dalek> nqp/toqast: 753dc29 | jnthn++ | src/NQPQ/Actions.pm:

[17:12] <dalek> nqp/toqast: Get strings working. With this, we pass a few of the simple tests in t/nqp again.

[17:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/753dc29e0e

[17:27] *** u_u left
[17:41] *** cognominal_ joined
[17:43] *** cognominal left
[17:59] *** jaldhar left
[17:59] *** jaldhar joined
[18:13] *** leprevost left
[18:13] *** jaldhar left
[18:15] *** thou joined
[18:15] *** jaldhar joined
[18:15] <moritz> nr: say (\1).WHAT

[18:15] <p6eval> rakudo 5e1b9a, niecza v19-15-g051783d: OUTPUT«Capture()␤»

[18:15] <moritz> nr: say (\"foo").uc

[18:15] <p6eval> rakudo 5e1b9a: OUTPUT«No such method 'uc' for invocant of type 'Capture'␤  in block  at /tmp/rZ0YnP39Td:1␤␤»

[18:15] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method uc in type Capture␤  at /tmp/zGzqinNY8A line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /home…

[18:17] <moritz> nr: say Capture ~~ Positional

[18:17] <p6eval> rakudo 5e1b9a: OUTPUT«False␤»

[18:17] <p6eval> ..niecza v19-15-g051783d: OUTPUT«True␤»

[18:17] <moritz> nr: say Capture ~~ Associative

[18:17] <p6eval> rakudo 5e1b9a: OUTPUT«False␤»

[18:17] <p6eval> ..niecza v19-15-g051783d: OUTPUT«True␤»

[18:17] * moritz agrees with niecza here

[18:17] <moritz> pmichaud, jnthn: is there a good reason that Capture is neither Positional nor Associative in Rakudo?

[18:18] <moritz> it implements at_pos and at_key

[18:19] <moritz> nr: say (\(1, a => 2)).list.perl

[18:19] <p6eval> rakudo 5e1b9a: OUTPUT«(1,).list␤»

[18:19] <p6eval> ..niecza v19-15-g051783d: OUTPUT«(1, ).list␤»

[18:19] <moritz> nr: say (\(1, a => 2)).hash.perl

[18:19] <p6eval> rakudo 5e1b9a: OUTPUT«EnumMap.new("a", 2, )␤»

[18:19] <p6eval> ..niecza v19-15-g051783d: OUTPUT«{"a" => 2}.hash␤»

[18:19] <masak> yeah, I agree with Niecza too.

[18:20] <masak> just as Match is Positional & Associative

[18:20] <moritz> nr: say Match ~~ Associative

[18:20] <p6eval> rakudo 5e1b9a: OUTPUT«False␤»

[18:20] <p6eval> ..niecza v19-15-g051783d: OUTPUT«True␤»

[18:20] <moritz> :-)

[18:22] *** cj left
[18:23] *** cj joined
[18:23] <moritz> nr: say (\ a => 1).perl

[18:23] <p6eval> niecza v19-15-g051783d: OUTPUT«"a" => 1␤»

[18:23] <p6eval> ..rakudo 5e1b9a: OUTPUT«===SORRY!===␤You can't backslash that at line 2, near " a => 1).p"␤»

[18:24] *** cognominal_ left
[18:25] <masak> r: my $q = quasi { {{{$a}}} }

[18:25] <p6eval> rakudo 5e1b9a: OUTPUT«===SORRY!===␤Variable $a is not declared␤at /tmp/ly_Tyc8lal:1␤»

[18:26] <masak> r: my $a; my $q = quasi { {{{$a}}} }

[18:26] <p6eval> rakudo 5e1b9a:  ( no output )

[18:26] <masak> hm. that probably should compile but not run.

[18:26] <masak> r: my $a; my $q = quasi { {{{$a}}} }; say $q.^name

[18:26] *** u_u joined
[18:26] <p6eval> rakudo 5e1b9a: OUTPUT«AST␤»

[18:26] *** mikemol left
[18:27] <moritz> r: my $a; my $q = quasi { {{{$a}}} }; say $q.perl

[18:27] <p6eval> rakudo 5e1b9a: OUTPUT«AST.new()␤»

[18:28] *** mikemol joined
[18:28] <moritz> ok, here's a weirdness

[18:28] <moritz> capture literals are made with \

[18:28] <moritz> s/capture/Capture/

[18:29] <moritz> and then there are Parcel and Capture parameters

[18:29] <moritz> and they use | and \

[18:29] <moritz> but it's the | that makes the Capture

[18:29] <moritz> isn't that... totally confusing?

[18:31] <masak> yes.

[18:31] <masak> I've never thought about that before.

[18:32] <moritz> I realize that there's an analogy to | on the caller side

[18:32] <moritz> f(|$c) interpolates whatever is in |$c in the argument list

[18:32] <moritz> and   sub f(|$c) { } puts whatever comes in into $c

[18:38] <moritz> nr: say (\(1, a => 2)).elems

[18:38] <p6eval> rakudo 5e1b9a, niecza v19-15-g051783d: OUTPUT«1␤»

[18:38] <moritz> erm, what?

[18:38] <moritz> why does it count only positional elems?

[18:39] <dalek> doc: 447afc8 | moritz++ | lib/Capture.pod:

[18:39] <dalek> doc: document Capture

[18:39] <dalek> doc: review: https://github.com/perl6/doc/commit/447afc88e5

[18:40] <masak> moritz: because that's what the list nature does?

[18:40] *** Guest54824 left
[18:40] <TimToady> because it's a Capture, not a Parcel

[18:41] <TimToady> Capture is after named args have been pulled out separately

[18:42] <jnthn> I suspect Capture not doing Positional and Associative is an accident.

[18:42] <masak> I have a question about unquotes. do they run ASAP on surrounding block entry, or ALAP when evaluating the quasiquote?

[18:42] * masak guesses ALAP

[18:42] <masak> ...in resonance with how qq strings work.

[18:43] <TimToady> I'd think ALAP would be more useful

[18:43] <masak> yeah.

[18:43] <masak> that's probably what people expect.

[18:43] <masak> I mean, you might want to synthetically create more ASTs in the macro body.

[18:43] <masak> and then unquote them.

[18:44] * jnthn expects ALAP too

[18:44] <moritz> nr: say (\(1, 2, b => 3)).hash

[18:44] <p6eval> niecza v19-15-g051783d: OUTPUT«{"b" => 3}␤»

[18:44] <p6eval> ..rakudo 5e1b9a: OUTPUT«EnumMap.new("b", 3, )␤»

[18:44] * moritz doesn't understand "Capture is after named args have been pulled out separately"

[18:44] <moritz> the named args are still in the Capture, no?

[18:45] <TimToady> but they are no longer part of masak's "list nature"

[18:47] <moritz> so far I've thought of Hash.elems and List.elems in equal terms

[18:47] *** cognominal joined
[18:48] <moritz> but I guess one could say that Hash.elems coerces the hash to list and then obtains the number of elements, at least notionally

[18:48] <tadzik> \o/

[18:48] <TimToady> nr: 'foobar' ~~ /(...) $<bar>=[...]/; say $/.elems

[18:48] <p6eval> rakudo 5e1b9a, niecza v19-15-g051783d: OUTPUT«1␤»

[18:48] <TimToady> same deal

[18:49] * moritz nods

[18:49] <masak> tadzik: \o/

[18:49] <moritz> \o tadzik

[18:50] <masak> so. ALAP.

[18:50] *** GlitchMr left
[18:50] <masak> next question: on which hook, conceptually, is the code that does the unquote AST stiching-in hung?

[18:51] <masak> at parse time there's static quasis. but the thing that gets returned from a macro or assigned to a variable is an incarnated quasi.

[18:52] <masak> on which hook does the code hang that incarnates a static quasi?

[18:53] <masak> hm. I guess it's just a question of code generation, actually.

[18:53] <jnthn> Isn't it just when we hit the place wher the quasi is in the code?

[18:53] *** p6rd left
[18:53] <masak> indeed.

[18:54] <moritz> just like with strings with interpolation, no?

[18:54] <masak> yes, just so.

[18:54] * masak goes to find the piece of code that generates quasis today

[18:54] <moritz> ok, making Capture does Positional does Associative causes some spectest fallout

[18:55] <moritz> http://perlpunks.de/paste/show/501d701b.584.228

[18:55] <moritz> t/spec/integration/error-reporting.rakudo seems to be caused by the inliner, not by that patch

[18:56] <moritz> hash.t and splicte.rakudo hung

[19:02] <moritz> huh

[19:03] <moritz> make t/spec/S32-array/splice.t   say "Non-zero wait status: 11"

[19:03] <moritz> ./perl6 -Ilib t/spec/S32-array/splice.rakudo; echo $?

[19:03] <moritz> 0

[19:04] <masak> r: macro foo { my $a = {}; quasi { say $a.WHICH } }; foo; foo

[19:04] <p6eval> rakudo 5e1b9a: OUTPUT«Hash|-1115445535␤Hash|-1108920089␤»

[19:04] <moritz> r: say Match.^mro

[19:04] <p6eval> rakudo 5e1b9a: OUTPUT«Match() Capture() Cool() Any() Mu()␤»

[19:04] <moritz> ah, and the hang in t/spec/S02-types/hash.t is for using a Match object as a hash index

[19:05] <moritz> which tries to slice because it's a Positional

[19:05] <moritz> and then loops, because the iteration still returns Match

[19:05] *** fgomez joined
[19:06] <moritz> might be solved with special-casing

[19:07] <moritz> r: say 1; ␤␤␤ +Any

[19:07] <p6eval> rakudo 5e1b9a: OUTPUT«1␤use of uninitialized value of type Any in numeric context  in block  at /tmp/epqfuAfH1b:1␤␤»

[19:07] <masak> yeah. the unquote stitching code should go here: https://github.com/rakudo/rakudo/blob/nom/src/core/AST.pm#L11

[19:08] <moritz> jnthn: the line number for the warning is wrong; that's rather new, and causes a test failure in error-reporting.t

[19:08] <masak> right now all that happens there is that the appropriate context gets set.

[19:09] <moritz> probably needs to generate code that does the unquoting

[19:09] <moritz> or splicing

[19:09] <moritz> or... /me confuses all the terms right now

[19:09] <jnthn> moritz: Hmm...curious.

[19:10] <moritz> jnthn: does the default optimization level inline stuff?

[19:11] <jnthn> Yeah

[19:11] <jnthn> But I'm not sure what it'd inline there

[19:11] <masak> moritz: well, there is already code generated to call that method. I think that's all that's needed.

[19:11] <jnthn> Oh...

[19:11] <moritz> jnthn: the prefix:<+>?

[19:11] <jnthn> The + I guess

[19:11] <moritz> jnthn: --optimize=0 fixes the line number

[19:11] *** cognominal left
[19:11] <jnthn> --optimize=1 too?

[19:11] <moritz> with =1 it's also correct

[19:11] *** cognominal joined
[19:13] <jnthn> moritz: Does https://gist.github.com/3259432 help?

[19:13] *** p6rd joined
[19:13] <moritz> p6rd exited after 3548m26.170s with "Terminated."

[19:14] <masak> amy idea why?

[19:14] <moritz> jnthn: will test

[19:14] <masak> any*

[19:15] <jnthn> Given that it was terminated, I blame Arnold Schwarzenegger

[19:15] <moritz> masak: it might have leaked memory and exceeded the ulimit

[19:15] <moritz> masak: or could be some memory corruption

[19:15] <moritz> p6rd: next

[19:15] <p6rd> parrot 2012-08-21, rakudo 2012-08-23, niecza 2012-08-27

[19:16] <tadzik> oh, I get to release Rakudo during the YAPC

[19:17] <jnthn> ooh :)

[19:17] <jnthn> Do it in a lightning talk ;-)

[19:17] <tadzik> tee-hee

[19:17] <tadzik> well, if you bring your PC...

[19:17] <moritz> jnthn: huh, your patch applied with offset -50 lines, and then it complained "Symbol '$inlined' not predeclared in inline_immediate_block"

[19:17] *** mberends left
[19:17] <jnthn> wtf!

[19:17] <jnthn> It was meant to go in inline_call

[19:18] <masak> git... making a mistake? surely not!

[19:18] *** mberends joined
[19:18] <jnthn> I know...it normally gits everything right.

[19:19] <moritz> i applied with patch(1), not git apply

[19:19] <moritz> but I think I see where it should go

[19:19] <masak> nice to see some other implementation of *anything* saying "It's mainly an architectural change with little visible benefit, but it will be a big improvement in terms of flexibility and modularity inside the compiler.": http://hackage.haskell.org/trac/ghc/blog/newcg-update

[19:19] <arnsholt> jnthn: Are you sure there's enough time to do spectests and everything during a lightning talk? =)

[19:19] <jnthn> arnsholt: Probably not even on my main dev machine, actually...

[19:20] <arnsholt> Yeah. I might be able to get it done if I do TEST_JOBS=8 on my work machine

[19:21] <moritz> I could let you remote into my 24core $work machine :-)

[19:21] <moritz> but it's windows, and doesn't have a working C compiler :(

[19:22] <jnthn> moritz: "Great, another re-write!"

[19:22] <jnthn> s/moritz/masak/

[19:25] <arnsholt> Oooooh, I could do it on our work big machine

[19:25] <arnsholt> TEST_JOBS=32  >:D

[19:26] <jnthn> o.O

[19:26] <arnsholt> What can I say, we do comp.ling. Lots of data is our business =)

[19:27] <masak> jnthn: yeah, can't those Haskell guys just finish one compiler according to spec and *release* the damn thing!? :P

[19:27] <moritz> jnthn: your patch fixes the warning line number

[19:27] <arnsholt> jnthn: Don't ask how much memory there is ;)

[19:27] <jnthn> moritz: asbra! I can commit it, unless you already did.

[19:27] <moritz> jnthn: go ahead

[19:28] <masak> arnsholt: TEST_JOBS=32, sure, but t/spec/S32-io/IO-Socket-INET.t will still be the bottleneck :)

[19:28] <moritz> arnsholt: 8GB... per core?

[19:28] <arnsholt> moritz: Yeah =)

[19:28] <dalek> rakudo/nom: 7e1b380 | jnthn++ | src/Perl6/Optimizer.pm:

[19:28] <dalek> rakudo/nom: Don't lose line numbers when inlining; moritz++ for reporting.

[19:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7e1b380a25

[19:29] <jnthn> Hm, this means we inline calls to + :D

[19:29] <arnsholt> Oh, and maybe we could just put the bottleneck test first in spectest.data, masak =)

[19:29] <jnthn> r: say 32 * 8

[19:29] <p6eval> rakudo 5e1b9a: OUTPUT«256␤»

[19:29] <masak> arnsholt: that might be a good idea anyway...

[19:29] <jnthn> That's bigger than my darn SSD on thi smachine!

[19:30] <tadzik> hehe, same here

[19:30] <arnsholt> Well, it's a shared machine. I don't have it all to myself, really =)

[19:30] * moritz can just offer 92GB for 24 cores. Should still be enough for ~30 parallel jobs

[19:30] <moritz> easily

[19:36] *** cj left
[19:37] <tadzik> masak: Game::Crypt doesn't seem to pass its tests

[19:38] <tadzik> 59 modules ok, 49 not ok (108 total) on new rakudo

[19:40] <masak> tadzik: huh. I ran them locally, and they passed...

[19:40] * masak runs them again

[19:40] *** benabik joined
[19:41] <masak> tadzik: all tests pass here. do I need to update my nom?

[19:42] * masak does so

[19:45] *** kaare_ left
[19:45] *** flussence joined
[19:48] *** fgomez left
[19:48] *** fgomez joined
[19:48] <masak> tadzik: I now have an up-to-date installed nom. tests still pass.

[19:48] <moritz> ==> Testing Game::Crypt

[19:48] <moritz> t/crypt.t .. 1/? Could not find symbol '&NoExitThere'

[19:48] <masak> :/

[19:49] <moritz> masak:  do you have local modifications? or local modifications in Adventure::Engine?

[19:49] <moritz> or unpushed commits?

[19:50] <japhb> Or a pony?

[19:50] <masak> no, there's still just the one commit there.

[19:50] <masak> (in the Adventure::Engine repository)

[19:51] <masak> I have X::Adventure::NoExitThere defined at line 143 of Adventure/Engine.pm

[19:51] <masak> I have no idea what would be wrong on your setups. tadzik, moritz, suggestions welcome.

[19:52] <moritz> masak: did you precompile Adventure::Engine?

[19:52] <masak> no.

[19:52] * moritz did

[19:53] <masak> if precompilation breaks Adventure::Engine, then that's very bad.

[19:54] <moritz> that seems to be exactly what happens

[19:54] <moritz> removing the .pir files, t/crypt.t runs fine

[19:55] * masak submits rakudobug

[19:55] <moritz> might be an instance of https://rt.perl.org/rt3/Ticket/Display.html?id=112626

[19:56] * masak looks

[19:58] <masak> yes, that looks very similar.

[20:04] *** benabik left
[20:06] <masak> well, maybe not.

[20:06] <masak> that one is about declarations colliding which shouldn't be.

[20:06] <masak> mine is about declarations missing.

[20:06] <masak> of course, the underlying cause could still be the same.

[20:07] <masak> I could golf and submit a separate rakudobug if that's deemed worthwhile.

[20:07] <masak> or golf and add to #112626

[20:10] <masak> g'ah! it's 2012, and precompilation breaks my modules in Rakudo. :(

[20:11] *** MayDaniel joined
[20:12] *** birdwindupbird joined
[20:13] <jnthn> masak: We didn't *have* the serialization bit of precompilation until 2012.

[20:14] <jnthn> And we all know how many people clamber to fix the issues in that area.

[20:16] <masak> ...not many? just a guess.

[20:17] * jnthn suspects the number of people who comitted to serialization.c is somewhere around 1. :)

[20:17] <masak> jnthn: sorry about the overt frustration. I just want Perl 6 to be a reliable platform to build software on.

[20:18] <masak> if these breakages happened in 2008, I wouldn't bat an eyelash.

[20:19] <jnthn> Then try to find ways to increase the bus number in areas where it's too low to have enough people to get to "reliable" as quickly as you'd like.

[20:20] *** awwaiid left
[20:20] <masak> yeah.

[20:20] *** awwaiid joined
[20:20] *** benabik joined
[20:23] *** nwc10 joined
[20:23] <nwc10> jnthn++ # nom now uses only 56% of the RAM that the last release needed to compile the setting (on "my" machine)

[20:24] <nwc10> at this rate it will be using negative RAM by about October

[20:25] <jnthn> Uh...I'm not sure extrapolation works like that, but awesome :)

[20:26] * awwaiid uses the negative-ram to open up some faster-than-light time travel and goes back in time to now to by himself another coffee

[20:27] <awwaiid> jnthn++ # thanks for the coffee

[20:27] <jnthn> \o/

[20:27] <jnthn> nwc10: That's...quite a big drop.

[20:27] <nwc10> yes. I wonder if my measurement is duff for some reason.

[20:27] <jnthn> The ChangeLog quotes a value around 35%

[20:28] <flussence> I came to ask a stupid question, but I ended up fixing it by making my code nicer...

[20:28] <nwc10> oh, that was a drop from the last release all the way to HEAD

[20:28] <dalek> nqp/toqast: 729ce4d | jnthn++ | src/NQPQ/Actions.pm:

[20:28] <dalek> nqp/toqast: Fix lexical variables.

[20:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/729ce4d6d5

[20:28] <dalek> nqp/toqast: c115641 | jnthn++ | src/NQPQ/Actions.pm:

[20:28] <dalek> nqp/toqast: Fix empty blocks.

[20:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/c115641f6b

[20:28] <dalek> nqp/toqast: 0758db1 | jnthn++ | src/NQPQ/Grammar.pm:

[20:28] <dalek> nqp/toqast: Spell defor correctly.

[20:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/0758db1db4

[20:28] <dalek> nqp/toqast: 50bd8cc | jnthn++ | src/NQPQ/Actions.pm:

[20:28] <dalek> nqp/toqast: Eliminate many uses of viviself.

[20:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/50bd8ccb2d

[20:28] <dalek> nqp/toqast: bfd58e5 | jnthn++ | src/NQPQ/ (2 files):

[20:28] <dalek> nqp/toqast: A bunch more PAST::Var => QAST::Var, fixing simple sub declarations along the way.

[20:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/bfd58e5cb8

[20:29] <nwc10> but top says

[20:29] <nwc10> Mem: 2881M Active, 2534M Inact, 586M Wired, 100M Cache, 399M Buf, 1814M Free

[20:29] <nwc10> so it's not swapping

[20:29] <jnthn> Nice

[20:29] <jnthn> Well, the string de-dupe thing I did today could easily have helped.

[20:29] <nwc10> OK, to be fair that's top when I'm not running it - let me log in twice

[20:30] *** xinming left
[20:33] *** snearch left
[20:34] <nwc10> This is while running:

[20:34] <nwc10> 96290 nicholas       1 118    0   905M   835M CPU0   0   5:18 100.00% perl6

[20:35] <nwc10> size just peaked at 10055M before it exited

[20:35] <nwc10> er, 1005M

[20:35] <TimToady> whew

[20:35] <jnthn> !

[20:35] <nwc10> so it's under a Gb now on (at least one) x86_64 FreeBSD machine

[20:35] <jnthn> I don't think we've ever needed 10055M :)

[20:36] <nwc10> maybe on a system with 512 bit pointers

[20:36] <nwc10> actually, only 256 bit pointers for the most recent release

[20:38] <sorear> good * #perl6

[20:38] <nwc10> it seems to be a very good * today

[20:38] <tadzik> good star sorear 

[20:39] * jnthn hopes we can shave some more off yet :)

[20:39] <jnthn> o/ sorear 

[20:39] <nwc10> me too. but you have to hit diminishing returns at some point, don't you? :-(

[20:41] <jnthn> Yeah

[20:41] <masak> sorear! \o/

[20:42] * nwc10 hopes someone else can check his figures aren't insanely wrong

[20:45] <dalek> nqp/toqast: b1a033c | jnthn++ | src/NQPQ/Actions.pm:

[20:45] <dalek> nqp/toqast: Eliminate multitype usage.

[20:45] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/b1a033c63e

[20:45] <dalek> nqp/toqast: 8f9d295 | jnthn++ | src/NQPQ/Actions.pm:

[20:45] <dalek> nqp/toqast: Toss hopefully unrequired namespace call.

[20:45] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/8f9d295a98

[20:45] <dalek> nqp/toqast: 263e374 | jnthn++ | src/NQPQ/World.pm:

[20:45] <dalek> nqp/toqast: s/subid/cuid/

[20:45] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/263e374152

[20:45] <dalek> nqp/toqast: e8e11ea | jnthn++ | src/NQPQ/World.pm:

[20:45] <dalek> nqp/toqast: Fix method setup, which gets basic classes working again.

[20:45] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/e8e11eae24

[20:47] <flussence> I did stuff: https://github.com/flussence/perl6-Test-Corpus

[20:48] <flussence> (so that I could be increasingly lazy writing tests)

[20:50] <masak> flussence: nice!

[20:50] <masak> flussence++

[20:51] <flussence> .oO( now I just need to test it... )

[20:52] *** nwc10 left
[20:52] <masak> flussence: IO::Path has a .basename public attribute.

[20:54] <masak> flussence: also, I'd write `Callable $test-block` as `&test` if I were you.

[20:55] <tadzik> errr

[20:55] <flussence> I'll make the Callable change, but I'm trying to make this work in rakudo+niecza simultaneously and niecza hasn't caught up on IO yet.

[20:55] <tadzik> star: use JSON::Tiny; my $json = "\n [1, 2, 3"; say (from-json $json).perl

[20:55] <p6eval> star 2012.07: OUTPUT«Any␤»

[20:56] <tadzik> star: use JSON::Tiny; my $json = "[1, 2, 3"; say (from-json $json).perl

[20:56] <p6eval> star 2012.07: OUTPUT«Unable to parse array, couldn't find final ']'␤  in any FAILGOAL at src/stage2/QRegex.nqp:831␤  in regex array at /home/p6eval/star/lib/parrot/4.6.0/languages/perl6/lib/JSON/Tiny/Grammar.pm:8␤  in regex TOP at /home/p6eval/star/lib/parrot/4.6.0/languages/perl6/lib/J…

[20:56] <tadzik> star: use JSON::Tiny; my $json = "[1, 2, 3]"; say (from-json $json).perl

[20:56] <p6eval> star 2012.07: OUTPUT«[1, 2, 3]␤»

[20:56] <tadzik> moritz: is that intentional?

[20:56] <tadzik> as in: leading \n breaks stuffs

[20:56] <dalek> nqp/toqast: 24fb046 | jnthn++ | src/NQPQ/Actions.pm:

[20:56] <dalek> nqp/toqast: Somewhat fix self, attribute access.

[20:56] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/24fb0469ac

[20:57] <flussence> ...and s/&/$/ breaks rakudo too, wtf

[20:58] <flussence> t/expand.t .. Nominal type check failed for parameter '&func'; expected Callable but got Sub instead # https://github.com/flussence/Text-Tabs-Wrap/blob/spec-rewrite/t/expand.t

[20:59] <cognominal> jnthn, what is a WVal in QAST?

[20:59] *** Chillance left
[20:59] <jnthn> World Value

[20:59] <jnthn> As in, something we know at compile time.

[20:59] *** benabik left
[21:00] <jnthn> flussence: Did you write something like Sub &foo?

[21:01] <flussence> I'm trying to think why I wrote Callable there in the first place...

[21:02] <jnthn> Note that Callable &foo is like Callable[Callable] $foo

[21:02] <flussence> I guess I could just get rid of the type entirely, the & should be enough

[21:02] <jnthn> Rigth

[21:02] <jnthn> Having the type *and* & is probably messing it up for you

[21:02] <tadzik>     my %old = from-json slurp $old-results;

[21:02] <tadzik>     my %new = from-json slurp $old-results;

[21:02] <tadzik> it looked so sensemaking...

[21:02] <cognominal> thx jnthn++

[21:03] <masak> r: say Sub ~~ Callable

[21:03] <p6eval> rakudo 7e1b38: OUTPUT«True␤»

[21:05] <tadzik> http://i.imgur.com/2lskK.png \o/

[21:05] <tadzik> that may come in handy

[21:06] <jnthn> tadzik: ooh!

[21:06] <jnthn> tadzik++

[21:07] <tadzik> it'll be more awesome. Stay tuned :)

[21:07] <tadzik> speaking of which, which feather is a good place to put some resource-heavy operations to be running once in a while?

[21:09] *** birdwindupbird left
[21:09] <cognominal> What is the 'soft' pragma?

[21:10] <jnthn> cognominal: S06 explains it in some detail

[21:10] <cognominal> ha, thx

[21:10] <jnthn> It's about managing the interaction of wrap and inlining.

[21:11] <cognominal> yup, I see that

[21:12] <dalek> emmentaler: 34e1831 | tadzik++ | difftool:

[21:12] <dalek> emmentaler: Add difftool for nice results comparing

[21:12] <dalek> emmentaler: review: https://github.com/tadzik/emmentaler/commit/34e18311a1

[21:14] *** RobiX joined
[21:15] *** benabik joined
[21:26] *** benabik left
[21:32] *** benabik joined
[21:34] *** cognominal left
[21:35] *** MayDaniel left
[21:36] *** MayDaniel joined
[21:53] *** cognominal joined
[21:53] *** benabik left
[21:57] <tadzik> I like how it takes ~5 seconds to install some stuff with panda :)

[21:59] * masak beats the big drum faster to hasten the Singularity

[21:59] *** buubot_backup left
[22:03] <sorear> o/ masak

[22:04] <masak> \o

[22:08] <tadzik> masak: I fixed Yapsi build and compiler.t, but there are things beyond my understanding there and in runtime.t

[22:09] <tadzik> (https://github.com/tadzik/yapsi)

[22:10] <masak> tadzik: oh, ok. thanks for the heads-up.

[22:10] <masak> I might have a look tomorrow.

[22:10] <tadzik> okay

[22:11] * jnthn hasn't written a module for quite a while

[22:11] <jnthn> Maybe I should try my hand at it sometime :)

[22:11] <tadzik> random idea from today: Text::Colors

[22:11] <tadzik> or ::Colours

[22:11] <tadzik> something along Term::ANSIColor, but able to produce terminal stuff, maybe also HTML text and so

[22:11] <tadzik> like a common interface for colo(u)ring text

[22:12] <jnthn> tadzik++ # awareness of correct spelling as well as American spelling of words

[22:12] <jnthn> ;-)

[22:12] <tadzik> :)

[22:12] *** MayDaniel left
[22:13] <tadzik> that reminds me of one of Tim Minchin's pieces

[22:14] <masak> reminds me of guerilla editing of Wikipedia.

[22:14] <jnthn> .oO( gorilla editing of Wikipedia )

[22:14] <masak> https://secure.wikimedia.org/wikipedia/meta/wiki/Guerilla_spelling_campaigns

[22:14] <jnthn> oO( use GORILLA_EDITING; )

[22:16] <masak> the best part of that page? it is categorized both as "Humour" and "Humor" :P

[22:16] <tadzik> :D

[22:22] <tadzik> No such method 'MATCH' for invocant of type 'Integer'

[22:22] <tadzik> that sounds awful

[22:25] <jnthn> Indeed. :/

[22:25] <jnthn> How'd you get it?

[22:26] <tadzik> use Grammar::Tracer on Yapsi.pm

[22:26] <tadzik> gone away when I used <?after> instead of a hack that was there

[22:27] <tadzik> https://github.com/tadzik/yapsi/blob/bf9cf97406df530/lib/Yapsi.pm#L31 here

[22:28] <jnthn> r: say "ab" ~~ /<?{ $/.CURSOR.pos > 0 }> ./

[22:28] <p6eval> rakudo 7e1b38: OUTPUT«q[b]␤␤»

[22:29] *** thou left
[22:29] <jnthn> oh, but using Grammar::Tracer

[22:30] <tadzik> aye

[22:35] *** benabik joined
[22:37] <masak> tadzik++ # de-hacking Yapsi

[22:38] <tadzik> masak: I made it pass all tests and things :)

[22:39] <tadzik> well, almost

[22:39] <masak> tadzik: you rock

[22:39] <tadzik> well, almost

[22:40] <tadzik> I finally stumbled upon something that looks like being not a change in Perl 6 itself and not a rakudo de-regression :)

[22:45] <tadzik> yep, all tests pass now

[22:45] <jnthn> Pass all the tests! \o/

[22:46] <tadzik> REmove all the warnings!

[22:46] <tadzik> (but one)

[22:47] <tadzik> masak: pull request sent

[22:52] <tadzik> now I feel like sleeping. Good knight #perl6!

[22:53] <jnthn> 'night, tadzik 

[22:54] *** LadySainthilaire joined
[22:55] <LadySainthilaire> hi

[22:56] *** LadySainthilaire left
[22:56] <masak> hilairious.

[23:02] *** RobiX left
[23:02] *** sftp joined
[23:09] <masak> good knight, #perl6.

[23:09] *** cognominal left
[23:11] * jnthn gets some rest also

[23:22] *** PacoAir left
[23:24] *** cognominal joined
[23:35] *** sivoais joined
[23:52] *** rvchangue joined
