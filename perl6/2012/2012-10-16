[00:00] *** tokuhiro_ joined
[00:00] <japhb_> more web benchmarks, or more benchmarks in general?

[00:00] *** cognominal left
[00:00] <japhb_> Yeah, more work per test is definitely important.

[00:02] <supernovus> japhb: web benchmarks. I want to test the adapter-based services (SCGI and FastCGI) with at least two HTTP servers, and compare all three of the Perl 6 libraries against their Perl 5 counterparts.

[00:02] <japhb_> nodnod

[00:03] <japhb_> Perl 5's Benchmark.pm had a useful feature that (in addition to specifying a fixed number of iterations per test), you could specify a minimum run time per test, and it would iterate a couple times to determine an iteration count that would meet that minimum run time.

[00:06] <supernovus> japhb_: That's pretty cool! I just recently re-discovered the 'ab' tool (thanks to bbkr++ for that) and figured it would be a neat idea to see how my web app libraries compare to one another :-) I'll add in more Perl 6 libraries that I didn't write as I built up the benchmarks, the first iteration is limited to the three libraries I have the most experience with (being the author helps...)

[00:07] <japhb_> heh

[00:08] <supernovus> Anyway, time to go for this evening, have a good one! :-)

[00:08] *** supernovus left
[00:10] *** cognominal joined
[00:14] <dalek> perl6-bench: f264e1b | (Geoffrey Broadwell)++ | TODO:

[00:14] <dalek> perl6-bench: More feature TODOs

[00:14] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/f264e1bc20

[00:19] *** cognominal left
[00:27] *** cognominal joined
[00:28] <cognominal> r:  my &ords = -> $_ { .split('')>>.ord }; my ($a,$b) = "ABCDE\nABDCE".split: "\n";  say +((ords($a) >>+^<< ords($b)).grep: * != 0)

[00:28] <p6eval> rakudo 7ddece: OUTPUT«2␤»

[00:29] <cognominal> this is a top ugly way to calculate a hamming distance (for that problem : http://rosalind.info/problems/hamm/) is there anything cleaner?

[00:34] *** cognominal left
[00:39] *** fridim_ left
[00:39] <TimToady> my ($a,$b) = "ABCDE\nABDCE".split: "\n"; say [+] $a.comb Zne $b.comb;

[00:39] <phenny> TimToady: 15 Oct 22:25Z <pmichaud> tell TimToady   BTW, one of the girls on our LEGO robotics team really likes Camelia as the mascot.  :-)

[00:40] <TimToady> nr: my ($a,$b) = "ABCDE\nABDCE".split: "\n"; say [+] $a.comb Zne $b.comb;

[00:40] <p6eval> rakudo 7ddece, niecza v22-13-g0d2a99e: OUTPUT«2␤»

[00:40] <japhb_> phenny, tell cognominal Str.ords already exists in Rakudo

[00:40] <phenny> japhb_: I'll pass that on when cognominal is around.

[00:41] *** cognominal joined
[00:41] <TimToady> cognominal: see backlog

[00:41] <cognominal> thx

[00:41] <phenny> cognominal: 00:40Z <japhb_> tell cognominal Str.ords already exists in Rakudo

[00:42] <TimToady> well, that's assuming they're the same length, of course

[00:42] <japhb_> TimToady, that's specified in the problem cognominal++ referenced

[00:42] <TimToady> there was some sentiment to remove .ords

[00:43] <japhb_> I really like .ords, myself.

[00:43] <japhb_> (conceptually, I mean -- I haven't looked at Rakudo's implementation thereof)

[00:43] <TimToady> it may have been chrs that people were upset with, but they go together

[00:44] *** cognominal left
[00:47] <TimToady> ords might be faster than comb

[00:48] <TimToady> and ords could conceivably be lazy enough not to create an array of the whole string

[00:48] <TimToady> well, so could comb

[00:49] <TimToady> in either case should just be a lightweight iterator pointing into the (presumably immutable) string

[00:52] *** mjreed joined
[00:54] *** cognominal joined
[00:54] *** MikeFair left
[00:56] *** anuby joined
[00:56] *** cognominal left
[01:01] *** MikeFair joined
[01:06] *** cognominal joined
[01:09] *** MikeFair left
[01:09] *** cognominal left
[01:13] *** fgomez left
[01:14] *** hypolin joined
[01:16] *** MikeFair joined
[01:20] *** cognominal joined
[01:22] *** cognominal left
[01:22] <skids> For NCI with APIs that allow you to provide an allocator hook, is there a parrot/nqp function that is worth handing off, e.g. one that will free/GC the given allocation?

[01:23] <skids> ( I assume there is, but which one is preferred?)

[01:26] *** fgomez joined
[01:32] *** cognominal joined
[01:41] <colomon> rn: my %a = b => c; say %a<b>:defined

[01:41] <p6eval> rakudo 7ddece: OUTPUT«===SORRY!===␤Confused␤at /tmp/fc9Qc2Hr4w:1␤»

[01:41] <p6eval> ..niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Undeclared routine:␤     'c' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/p…

[01:42] <colomon> rn: my %a = "b" => "c"; say %a<b>:defined

[01:42] <p6eval> rakudo 7ddece: OUTPUT«===SORRY!===␤Confused␤at /tmp/vUl_IsB5d3:1␤»

[01:42] <p6eval> ..niecza v22-13-g0d2a99e: OUTPUT«Unhandled exception: Excess arguments to KERNEL Hash.postcircumfix:<{ }>, unused named defined␤  at <unknown> line 0 (KERNEL Hash.postcircumfix:<{ }> @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 183 (postcircumfix:<{ }> @ 5) ␤  at /tmp/TbPHRX3VDP l…

[01:42] <colomon> rn: my %a = "b" => "c"; say %a<b>:exists

[01:42] <p6eval> rakudo 7ddece: OUTPUT«===SORRY!===␤Confused␤at /tmp/TOSQgJz7NG:1␤»

[01:42] <p6eval> ..niecza v22-13-g0d2a99e: OUTPUT«True␤»

[01:42] <colomon> rn: my %a = "b" => "c"; say %a<b> ~~ defined

[01:42] <p6eval> rakudo 7ddece: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'defined' will never work with no arguments (line 1)␤    Expected any of:␤    :(Mu \x)␤»

[01:42] <p6eval> ..niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Unsupported use of bare 'defined'; in Perl 6 please use .defined if you meant $_, or use an explicit invocant or argument at /tmp/Ac1SODgJma line 1 (EOF):␤------> my %a = "b" => "c"; say %a<b> ~~ defined⏏<EOL>…

[01:43] <colomon> rn: my %a = "b" => "c"; say %a<b>.defined

[01:43] <p6eval> rakudo 7ddece, niecza v22-13-g0d2a99e: OUTPUT«True␤»

[01:43] *** popl left
[01:50] *** tokuhiro_ left
[01:50] <skids> rn: my %a = "b" => "c"; say %a.exists("b") # knew I had seen at least one form of "exists" working

[01:50] <p6eval> rakudo 7ddece, niecza v22-13-g0d2a99e: OUTPUT«True␤»

[01:50] *** tokuhiro_ joined
[01:52] *** FROGGS_ joined
[01:54] *** tokuhiro_ left
[01:55] <colomon> the sad thing is, I probably implemented the niecza version of that.  stupid memory.

[01:55] *** flightrecorder left
[01:56] *** FROGGS left
[01:56] *** flightrecorder joined
[02:01] *** cognominal left
[02:13] <sorear> colomon: actually I added .exists(), and btw it's not spec

[02:14] <sorear> the spec form is :exists

[02:14] <colomon> sorear: I knew that it wasn't spec.

[02:14] *** daniel-s left
[02:14] <colomon> sorear++ # adding it for rakudo-compatibility 

[02:22] *** japhb_ left
[02:22] <skids> Interestingly, the method form IS specced for Array

[02:22] *** daniel-s joined
[02:26] <kurahaupo> ii,

[02:27] <sorear> o/ kurahaupo 

[02:28] <kurahaupo> sorry, random window refocus

[02:30] *** daniel-s left
[02:35] *** mjreed_ joined
[02:36] *** mjreed_ left
[02:38] *** mjreed left
[02:56] <colomon> Ooo, just published my 99th post on justrakudoit.

[03:03] *** gootle joined
[03:03] *** cibs left
[03:03] *** leprevost joined
[03:13] *** xinming_ joined
[03:14] *** am0c joined
[03:16] *** xinming left
[03:31] <TimToady> whois Xmental

[03:31] <TimToady> just checking to see if a known userid here...

[03:35] <sorear> I think you wanted /whois

[03:42] <TimToady> yes, that's what I did next, but you can't see that bit...

[03:42] <TimToady> nothing, btw

[03:42] <TimToady> it's after that that I googled for it

[03:42] <TimToady> (we're discussing an RC vandal)

[03:50] <am0c> hello #perl6, there is no "NativeCall" thingy in http://perlcabal.org/syn/ although there is an article about it ( http://perl6advent.wordpress.com/2010/12/15/day-15-calling-native-libraries-from-perl-6/ )

[03:51] <am0c> is implementation or spec about it removed temporarily?

[03:52] <TimToady> implementations are free to prototype things like this; they may be specced when they prove to be universal across implementions

[03:52] <sorear> am0c: NativeCall has never been part of the generla spec

[03:52] <am0c> oh, I see.

[03:55] <am0c> so, it means that more implementations make us happy yey!

[03:56] *** benabik left
[03:56] *** benabik joined
[03:59] *** thou joined
[04:01] *** kurahaupo left
[04:07] *** leprevost left
[04:11] *** telex left
[04:17] *** kurahaupo joined
[04:19] *** telex joined
[04:28] *** telex left
[04:32] *** hash_table left
[04:35] *** telex joined
[05:00] *** aharoni joined
[05:03] *** kaleem joined
[05:06] *** thou left
[05:09] *** kevouze joined
[05:22] *** sftp left
[05:22] *** sftp joined
[05:32] *** birdwindupbird joined
[05:39] <moritz> colomon: re http://justrakudoit.wordpress.com/2012/10/16/step-actions/, what about  make $/.hash.values[0].ast ?

[05:41] <pmichaud> yay, I've finally found a program to reproduce the parrot readline bug in pure parrot

[05:42] *** bryntum_support joined
[05:42] <moritz> \o/ pmichaud++

[05:43] <pmichaud> https://gist.github.com/3897389

[05:43] <pmichaud> I'll create a ticket for it

[05:44] *** bryntum_support left
[05:44] <dalek> rakudo/nom: 637aad0 | moritz++ | docs/ChangeLog:

[05:44] <dalek> rakudo/nom: update ChangeLog

[05:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/637aad07d0

[05:44] *** SamuraiJack joined
[05:45] <sorear> pmichaud: o.O

[05:45] <masak> pmichaud++

[05:48] <masak> pmichaud: on my setup, it doesn't even show the prompt until I hit ^D (and then it runs the whole program without waiting for input)

[05:48] <pmichaud> ick, does that mean the flush issue is still present?

[05:48] <masak> I... probably have a very old Parrot. :/

[05:48] <masak> updating.

[05:50] <pmichaud> https://github.com/parrot/parrot/issues/861

[05:55] <masak> I'm now on bleeding Rakudo, which uses Parrot RELEASE_4_8_0. still no prompt until ^D.

[05:56] <pmichaud> wtf?  why is bleeding rakudo using RELEASE_4_8_0?

[05:56] <sorear> no, the causality is backward.

[05:57] <sorear> Rakudo is bleeding because masak stabbed it with RELEASE_4_8_0

[05:57] <pmichaud> rakudo nom HEAD should be on RELEASE_4_4_0

[05:57] <pmichaud> nqp has RELEASE_4_4_0 in tools/build/PARROT_RELEASE, unless my git repos are way out of sync

[05:58] <moritz> well, 4.8.0 > 4.4.0

[05:58] <masak> my Rakudo just built on 2012.09.1-39-g637aad0.

[05:58] <moritz> and we have no mechanism in the build system to enforce the downward bump

[05:58] <sorear> is the nqp build system smart enough to auto-downgrade?

[05:58] <moritz> no

[05:58] <sorear> oh

[05:58] <pmichaud> we don't do maximum version numbers, no.

[05:58] <masak> should I bump my Parrot down to 4.4.0?

[05:59] <masak> maybe just nuke the parrot/ subdir?

[05:59] <pmichaud> masak: you definitely don't want to be on 4.8.0, no matter what :-)

[05:59] <masak> heh :)

[05:59] * masak nukes

[05:59] <sorear> pmichaud: just bc of io-rewrite?

[06:00] <pmichaud> sorear: I'm pretty sure io-rewrite is the culprit, yes.

[06:00] <pmichaud> I know I ended up spending several days on the 2012.09 star release because of the bugs in the 4.8.0 release :-/

[06:01] <sorear> pmichaud: I mean, are there other showstopper bugs besides readline?

[06:01] <pmichaud> sorear: I don't know... I don't think many people have been using 4.8.0 with later rakudoes

[06:01] <pmichaud> i.e., it's a largely untested configuration.

[06:01] *** ServerSage left
[06:02] <sorear> does it pass spectest at least?

[06:02] <pmichaud> yes, it passes spectest

[06:02] <pmichaud> but neither spectest nor parrot tests were able to catch the autoflush or readline bugs

[06:03] <masak> I/O is always going to be undertested. it's a square peg to unit testing's round hole.

[06:04] <pmichaud> I'm thinking the 2012.10 release needs to remain on 4.4.0-4.7.0

[06:04] <sorear> I am tempted to do the following experiment:

[06:04] <sorear> remove autoflush support from Perl 5.  run "make test".  see what kinds of tests catch it, if any

[06:05] <pmichaud> immediately after the release (and assuming parrot gets the readline bug fixed), we can try bumping PARROT_REVISION for a month to see if any other I/O bugs pop up

[06:05] *** ServerSage joined
[06:08] <pmichaud> anyway, bedtime here...bbl

[06:08] <sorear> gnight

[06:09] <masak> 'night, pm

[06:10] <masak> PerlJam++ is releasing 2012.10. any volunteers for 2012.11?

[06:12] <FROGGS_> masak: any special knowledge required, other than just to be able to run the test suite?

[06:14] <masak> that's about it.

[06:14] *** flightrecorder left
[06:14] <masak> see docs/release_guide.pod for the process in detail.

[06:14] <masak> it's actually very straightforward.

[06:15] <FROGGS_> I know that document, since I needed it to recompile for testing

[06:15] <FROGGS_> what blog-accounts would I need?

[06:15] <masak> I'm back on Parrot 4.4.0. z.pir now prompts directly.

[06:16] <masak> FROGGS_: no blog accounts needed.

[06:16] <masak> one just emails p6c.

[06:16] <masak> on 4.4.0, the readline bug doesn't manifest. I guess because it's pre-io-rewrite?

[06:17] <FROGGS_> masak: thanks

[06:18] <FROGGS_> so I might volunteer, if no other wants to do it

[06:20] <masak> FROGGS_: please add yourself to https://github.com/rakudo/rakudo/blob/nom/docs/release_guide.pod under "Planned 2012 releases"

[06:20] <FROGGS_> k, I will in a few minutes

[06:20] <FROGGS_> brb

[06:20] *** FROGGS_ left
[06:28] <sorear> CIA postmortem, have not finished reading: http://esr.ibiblio.org/?p=4540

[06:30] <bonsaikitten> I've put an irker instance online to cover for cia's disappearance

[06:30] <bonsaikitten> it's an interesting fail because there were no backups and the hoster did wipe that VM after getting an explicit NAK from the customer

[06:39] <doy> i can't be the only one around here who gets twitchy just by instinct when people write a blog post talking about overengineering and "what happened to simplicity" and whatnot

[06:40] <doy> esr: still pretty irritating

[06:40] <sorear> the current version of dalek is a tail -f bot

[06:41] <sorear> there is a file on feather3, anything you cat >> it will show up here

[06:41] <bonsaikitten> doy: amusing: esr used xml for writing the manpages

[06:41] <bonsaikitten> doy: ... if that's not overengineering ...

[06:42] *** zk_ joined
[06:42] <bonsaikitten> apart from that irker is pretty much the minimum needed for structured notifications

[06:42] <doy> well, that's the thing

[06:42] *** kaleem left
[06:42] *** zk_ left
[06:42] <doy> "overengineering" in about 90% of the cases just means "i don't understand all of your use cases"

[06:43] *** birdwind1pbird joined
[06:43] <bonsaikitten> hmm, yes and no

[06:43] <bonsaikitten> if you look at the cia codebase it's multiple different languages for no reason

[06:44] <bonsaikitten> there's strange use of XML (and it smells even like pseudo-XML) that feels a bit unneeded

[06:44] <bonsaikitten> it does cover a lot more ground than irker (webUI, statistics etc)

[06:45] <bonsaikitten> still ... why write one part in python, then one part in erlang and nail it together with something else as translation layer?

[06:46] <doy> "that feels a bit unneeded" is my point

[06:46] <doy> "feelings" are generally not very productive in this sense

[06:47] <doy> granted, this is more relevant on projects that haven't failed

[06:47] <doy> but still

[06:47] <bonsaikitten> usually that "code smell" feeling has a base, but it takes lots of time to formalize it

[06:48] <bonsaikitten> intuition is not precise, but has a good enough hit rate to be used as a starting point for investigations

[06:48] <doy> sure

[06:49] <doy> but there's this tendency to use that intuition as a reason to just be dismissive and feel superior about your design skills

[06:49] <doy> again, in this particular case it may be justified (i don't know, i haven't seen the actual code), but that kind of language just tends to set off other kinds of alarm bells in my head

[06:50] *** cibs joined
[06:51] *** sizz left
[06:51] <bonsaikitten> I'm not a good designer, just better than average ;)

[06:52] *** flightrecorder joined
[06:52] *** sizz joined
[06:58] *** birdwind1pbird left
[06:59] *** birdwind1pbird joined
[06:59] *** mucker joined
[07:00] *** sizz_ joined
[07:00] *** sizz left
[07:01] <masak> the topic of software design interests me.

[07:01] <masak> though the words "architecture" and "architect" are even less strictly defined than the term "object orientation" :)

[07:02] <sorear> overengineering is what happens when you change your requirements 10 times and wind up with software that does 80% things you don't need because inadvertant cross-dependencies prevented you from fully adapting the software to the removal of requirements

[07:03] <bonsaikitten> there are funny patterns like "second system effect"

[07:03] <bonsaikitten> basically "let's rewrite it to fix $issues - oh, why not add $features - oh, let's add EVERYTHING"

[07:04] <masak> *cough*

[07:04] <sorear> bonsaikitten: have you heard the perl 6 motto?

[07:05] <bonsaikitten> sorear: ... yes?

[07:06] *** brrt joined
[07:08] <masak> skimming the post, it seems to me that esr does have a point about the complexity and overengineering.

[07:09] <masak> ooh, and "I'd take that patch" (from the comments). nice, haven't seen that meme before.

[07:11] <masak> "To paint this purely as a case of some idiot developing a recklessly complex architecture would be misleading, and I think much less interesting than the truth: This is a great case study of what happens when a service is well-liked but nobody steps up to maintain it. It grows organically to the extent that it can, then collapses."

[07:11] <masak> nice summary.

[07:12] <masak> and that's where a deliberate architecture, and an architect, would have been helpful.

[07:14] *** mucker left
[07:17] *** hoelzro|away is now known as hoelzro

[07:21] <bonsaikitten> basically someone driving the project forward

[07:23] *** FROGGS joined
[07:23] <brrt> hmm, reading it i can't get the feeling but 'this shouldn't have been hard'

[07:24] <masak> brrt: which can be said about a lot of software, I guess.

[07:27] <bonsaikitten> usually it is not hard

[07:27] <bonsaikitten> just takes time, and motivation

[07:29] <masak> some people would classify things that take time and motivation as "hard".

[07:32] <brrt> setting up an architecture like that would always have taken time

[07:32] <brrt> and anything that takes time pretty much takes motivation, too

[07:35] *** flightrecorder left
[07:35] *** FROGGS left
[07:35] *** flightre1 joined
[07:35] *** FROGGS joined
[07:38] *** kevouze left
[07:40] *** awwaiid left
[07:41] *** bbkr left
[07:42] *** awwaiid joined
[07:43] <brrt> btw, testing the string representation of an object for some value

[07:43] <brrt> thats not always a good idea, right

[07:46] *** birdwind1pbird left
[07:46] <masak> no, but it gets you a long way.

[07:46] <masak> I have a question about the separation of lexing and parsing.

[07:47] <brrt> ask :-) 

[07:47] <brrt> as if there is a better channel

[07:47] <masak> is it the case that such a separation grows less realistic/desirable with the amount of slangs/language switching going on?

[07:48] <masak> is that why neither Perl 5 nor Perl 6 makes an effort to separate lexing and parsing?

[07:48] <moritz> yes

[07:48] <masak> can some sort of maxim be formed here, such as "if you think you're going to do lots of DSLs, don't bother with the separation of the lexing and parsing steps"?

[07:48] <moritz> fwiw Perl 5 does try to separate lexing and parsing

[07:48] <moritz> and the result is madness :-)

[07:49] <masak> 'cus it seems to me that such a separation is a good idea, when possible. but it also seems to me that language switching makes it cumbersome or impossible.

[07:50] <moritz> unless the different slangs can be lexed by the same rules

[07:50] *** sirrobert left
[07:50] <moritz> (which is usually not the case)

[07:50] <masak> well, if you try to do the separation when there is lots of language switching going on, what you end up with is probably madness. or half-hearted compromises, like "scan ahead for (what looks like) the closing delimiter of this regex".

[07:51] <masak> right.

[07:51] *** erkan left
[07:51] <moritz> which kinda kills you if you want to allow regex modifiers to go at the end of the regex :-)

[07:52] *** erkan joined
[07:52] *** erkan left
[07:52] *** erkan joined
[07:52] <sorear> masak: separation works best in a language like C where the lexer and parser can work asynchronously, with (ideally) zero feedback from the parser to the lexer

[07:52] <masak> ooh, feedback.

[07:52] *** kurahaupo left
[07:52] <masak> hadn't thought of it in terms of feedback, but yeah, that's what's going on.

[07:52] <sorear> (in practice most C parsers use feedback, but that's more a matter of working around yacc limitations than something fundamental to C)

[07:52] <masak> right.

[07:53] <masak> even a C parser has to build symbol tables and stuff.

[07:53] <sorear> (specifically, C compilers like the lexer to spit out different tokens for things like TYPEDEF so that int32_t foo, bar can parse sanely)

[07:54] *** sirrobert joined
[07:54] <arnsholt> Requiring symbols to be declared makes your grammar context sensitive, so hacking around it is easier =)

[07:55] <sorear> in modern C there's also a preprocessor wedged between the parser and the lexer

[07:55] <sorear> pre-standard C ran the preprocessor before the lexer, wth hilarious consequences

[07:56] <masak> I suppose there's a connection between "context sensitive" and "slangs", too.

[07:56] <sorear> #define assert(x) if (!x) carp("x");

[07:57] <bonsaikitten> ah, stories from the dark ages

[07:57] * sorear watches masak slowly turn green

[07:57] <masak> sorear: oh wow.

[07:58] <masak> that is... so wrong.

[07:58] <tadzik> :)

[07:58] <sorear> morn tadzik

[07:59] <arnsholt> masak: I think it was you who introduced me to the presentation style where you have a few big words on each slide, but I can't remember what it was called. Help? =)

[07:59] <brrt> sorear: can't really see whats wrong

[07:59] <arnsholt> brrt: It'll probably expand the x in the string, which I don't think happens in modern C

[08:00] <sorear> brrt: just pointing out that in pre-standard C the preprocessor worked at the character level, so the occurence of x in the string is expanded

[08:00] <brrt> ah, i see

[08:00] <brrt> modern c has an option for that iirc

[08:00] <brrt> ##x or so

[08:00] <sorear> in modern C the preprocessor runs after the lexer and mostly only touches identifier tokens

[08:01] <sorear> it never modifies strings except through the #x formation

[08:01] <masak> arnsholt: Takahashi?

[08:01] <arnsholt> Takahashi, yeah. Think that's it

[08:01] <masak> https://en.wikipedia.org/wiki/Takahashi_method

[08:01] <masak> I think I was directly inspired by au++.

[08:02] <arnsholt> I'm attempting to use it for the presentation I'll give in Copenhagen of my research

[08:02] <sorear> there's also #define FOO(x) __foo__/**/x

[08:02] <arnsholt> It's a bit scary to not be able to rely on lots and lots of bullet points though

[08:02] <sorear> never used this, the incantation may be a bit more involved than I remember

[08:04] *** Caldrin left
[08:05] <jnthn> mornin' 

[08:05] <arnsholt> o/

[08:05] <sorear> o/

[08:05] <brrt> \o

[08:06] <tadzik> sorear: g'morning

[08:07] <jnthn> Perl 6 *does* separate lexing and parsing, in my view. It's just that it doesn't make the grammar writer do it. It figures it out by looking at declarative prefixes and constructing NFAs where it can.

[08:09] *** fhelmberger joined
[08:11] * sorear does not think that longest declarative prefix semantics and lexers are at all the same thing 

[08:11] <jnthn> sorear: Squint harder.

[08:11] <jnthn> ;-)

[08:12] <jnthn> I'd say that if you hit something that is entirely declarative, though, it counts as a token.

[08:12] <jnthn> (In the lexing sense)

[08:16] <masak> jnthn: I disagree, for (I believe) the same reasons as sorear.

[08:16] <masak> interleaved "lexing" through LTM and declarative prefixes does not count as "separate lexing" in my book.

[08:18] <sorear> I look at it in more of an LL(\infty) way - the parser is allowed lookahead when deciding what option to take

[08:19] <sorear> an interesting failure mode that I've seen once or twice in niecza is that if you have too long of declarative prefixes, the \infty can be realised and now your parse is quadratic because each "rule" looks-ahead all the way to the end of the file

[08:20] <masak> hm, never had that.

[08:22] <sorear> maybe my p6 demotivation of late is a laws and sausages thing

[08:23] <masak> if so, just remember that some things are inherent to the Perl 6 design, and others to a particular implementation.

[08:24] <masak> seems to me the branch you went down that didn't lead anywhere in particular was instrumental in sucking some motivation out of you.

[08:35] <masak> as for me, it reminds me of the phenomenal velocity with which Niecza has grown.

[08:35] <masak> imagine if we'd had Niecza in 2002 :)

[08:36] <masak> (and yes, I know it has a lot of dependencies we didn't have back then, such as STD.pm6)

[08:36] <bonsaikitten> hehe

[08:37] <bonsaikitten> masak: that's a rather funny thought experiment

[08:38] <sorear> masak: OTOH, then we'd be stuck with prefix:<=> and &want

[08:40] <masak> ugh

[08:40] *** sjohnson left
[08:41] <jnthn> .oO( module IdeasWeRejected; sub prefix:<=>($a) is export { $a.get } )

[08:41] <sorear> to be fair a lot of my gripes with perl6 boil down to "it's not designed to support niecza" :D

[08:42] <sorear> (a unit-at-a-time weakly optimizing compiler for a target with unusable coroutines)

[08:42] <brrt> what about a better target

[08:55] *** am0c left
[09:00] *** dakkar joined
[09:01] *** flightre1 left
[09:02] *** FROGGS left
[09:23] *** kresike joined
[09:23] <kresike> hello all you happy perl6 people

[09:23] *** hoelzro is now known as hoelzro|away

[09:25] <jnthn> o/ kresike 

[09:25] <moritz> \o *

[09:25] <brrt> hi kresike

[09:26] <kresike> jnthn, moritz, brrt o/

[09:29] <masak> kresike! \o/

[09:30] <kresike> masak, o/

[09:33] <sorear> what about less than happy perl6 people?

[09:34] <brrt> they can explain their cause of unhappiness

[09:34] <brrt> and we might all learn a bit

[09:39] <masak> we encourage open and healthy debate, as long as people's opinions are similar enough to what we believe we believe :P

[09:51] *** hoelzro|away is now known as hoelzro

[09:51] *** SamuraiJack_ joined
[09:54] *** SamuraiJack left
[10:00] *** hypolin left
[10:02] *** daxim joined
[10:02] *** brrt left
[10:05] *** anuby left
[10:12] *** domidumont left
[10:23] <lumi__> r: https://gist.github.com/3898515

[10:23] <p6eval> rakudo 637aad: OUTPUT«(signal SEGV)»

[10:23] <lumi__> That's my attempt at an overload trait, and it segfaults

[10:25] <jnthn> ==

[10:25] <jnthn> ?

[10:25] <jnthn> You wanted eq?

[10:25] <jnthn> It shoudln't segfault

[10:25] <jnthn> But still, == ain't gonna work

[10:25] <lumi__> I probably wanted eq, yup :P

[10:25] <lumi__> But I brought it up because it segfaults

[10:27] <jnthn> Yeah

[10:27] <jnthn> file it in RT, I'll see if I can reproduce

[10:27] <jnthn> It otherwise looks like fine code

[10:53] *** erkan left
[10:58] *** pmurias joined
[11:02] *** replore joined
[11:03] *** kaleem joined
[11:05] *** Su-Shee_ joined
[11:07] *** Su-Shee left
[11:07] *** Su-Shee_ is now known as Su-Shee

[11:09] *** kaleem left
[11:09] *** flightrecorder joined
[11:10] *** kaleem joined
[11:12] *** brrt joined
[11:17] *** replore left
[11:17] <brrt> \o #perl6

[11:18] *** replore_ joined
[11:19] <pmurias> hi

[11:20] <pmurias> jnthn: ping

[11:20] <pmurias> nqp: my $a; my $b; $a := 1; $b := 1; say($a =:= $b);

[11:20] <p6eval> nqp: OUTPUT«0␤»

[11:20] <pmurias> rakudo: my $a; my $b; $a := 1; $b := 1; say($a =:= $b);

[11:20] <p6eval> rakudo 637aad: OUTPUT«True␤»

[11:21] <pmurias> jnthn: I have resumed porting nqp to js, and I found the following difference between rakudo and nqp in the test suit

[11:21] <jnthn> Doing =:= in NQP with something that's value-type-ish is likely a bad idea.

[11:22] <jnthn> In fact, the thing we use =:= for in NQP is not really what Perl 6 wants it to mean...

[11:23] <pmurias> what do you use =:= in NQP for?

[11:23] <jnthn> "are the objects on each side the same object"

[11:23] <jnthn> As in, same memory address.

[11:24] <pmurias> so two different identical literals in =:= are different objects

[11:24] <pmurias> ?

[11:24] <jnthn> Yes because NQP doesn't have a constants table for such things

[11:24] <jnthn> It does however have native types these days

[11:25] <pmurias> should I duplicate that in nqp-js?

[11:25] <jnthn> The native types, or lack of constant table? :)

[11:25] <jnthn> Looking at S03 though, NQP using =:= for the meaning it currently has is never gonna be consistent with Perl 6 semantics.

[11:25] <jnthn> And what Rakudo did above is rather suspect also.

[11:26] <jnthn> git st

[11:26] <jnthn> oops

[11:26] <pmurias> jnthn: should I implement the lack of constant table?

[11:27] <pmurias> which is different from not implementing a constant table as js already has one ;)

[11:27] <jnthn> pmurias: No

[11:27] <jnthn> pmurias: Let's for now say that 1 =:= 1 in NQP is undefined behavior

[11:27] <jnthn> I should hope we don't rely on it anywhere...

[11:28] <jnthn> I think all the =:=s really mean "same object" when it's a reference type.

[11:28] <jnthn> Maybe we should change to === but then people will also expect 1 === 1 to be true.

[11:28] <pmurias> it's named eqaddr

[11:28] <jnthn> Yeah

[11:29] <jnthn> I don't think Perl 6 has an operator that means what NQP is doing with =:= at the moment.

[11:29] <jnthn> Probably because defining operators with undefined semantics in many cases is a bad idea ;-)

[11:29] <pmurias> the test suit needs to be changed

[11:29] <jnthn> Yeah, but need to decide what to change it to first :)

[11:37] <pmurias> looking at ack output, rakudo doesn't seem to use =:= for comparing values

[11:37] <pmurias> === seems more suitable

[11:38] <pmurias> but having it undefined on values seems confusing

[11:38] <jnthn> I'm not implementing === in real NQP

[11:39] <jnthn> er, real === in NQP

[11:40] <pmurias> change it to something we don't have in perl6?

[11:40] <jnthn> Maybe we should just make them all nqp::eqaddr($a, $b) :-)

[11:40] <jnthn> And if you do it on something that it's not sensible to do it on, you get a non-sensible answer :)

[11:41] <pmurias> nqp::eqaddr seems much better

[11:42] <colomon> o/

[11:43] <pmurias> \o

[11:47] <moritz> "As we say in French, when life gives you stateful functions, make le monade." -- rgs

[11:47] <masak> :) saw that one earlier today.

[11:47] <masak> one of the finest puns in quite a while.

[11:47] <masak> it has a certain... je ne sais quoi. acidity? :)

[11:48] <Su-Shee> moritz: I laughed at that this morning too.. :)

[11:49] <moritz> https://labs.ripe.net/Members/john_bond/wifi-issues-during-ripe-65 # if you hold a RIPE conference, you'll surely have enough competent people to debug the wifi :-)

[11:50] <Su-Shee> different level of "network" :)

[11:50] <Su-Shee> layer :)

[11:51] *** timbunce joined
[11:52] <timbunce> My "Perl at SkyCon'12" slides got featured on the slideshare homepage http://www.slideshare.net/Tim.Bunce/perl-at-skycon12 - it includes an overview of the state of perl5 and perl6.

[11:52] *** tokuhiro_ joined
[11:52] <timbunce> There's also a screencast at http://blip.tv/timbunce/perl-at-skycon-12-6391951

[11:53] <moritz> timbunce++

[11:53] <timbunce> moritz++ for the clean JSON::Tiny module code I featured.

[11:54] <timbunce> Makes a lovely 3 slide set.

[11:54] <Su-Shee> *hihi* and of course it starts with xkcd.. :)

[11:54] <timbunce> The lack of procedural code is particularly impressive.

[11:55] <pmurias> jnthn: should I change nqp?

[11:55] <timbunce> Su-Shee: Randall Munroe was the closing keynote speaker at the conference :)

[11:55] <Su-Shee> timbunce: haha. so everyone added an xkcd, because there is of course an xkcd for every subject and purpose by now.. ;)

[11:55] <masak> timbunce++

[11:56] <jnthn> pmurias: Feel free to change the =:= usages to nqp::eqaddr

[11:56] <masak> Su-Shee: Mr Munroe should make an xkcd for the state of there being an xkcd for every subject and purpose... ;)

[11:57] *** flightrecorder left
[11:58] <jnthn> lumi__: https://gist.github.com/3898844 plus a local fix I'm spectesting works now

[11:58] <Su-Shee> masak: I see a department of redundancy department tasting xkcd coming up. :)

[11:59] <Su-Shee> monty xkcd!

[11:59] <masak> timbunce: those Perl Data Anatomy diagrams are gorgeous.

[12:00] <dalek> rakudo/nom: 9c15141 | jnthn++ | src/binder/multidispatch.c:

[12:00] <dalek> rakudo/nom: Various bits of SEGV-protection in multi-dispatch.

[12:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9c15141ee5

[12:01] <timbunce> masak: Agreed. I'm not sure what tool was used for those (or if the current ill guts maintainer knows how to update them)

[12:03] <masak> timbunce: very, very nice slides. thanks for sharing those.

[12:03] <jnthn> timbunce++ # nice

[12:03] <masak> they're nice to the point of me wondering whether, were I ever in the position of presenting Perl 5 and 6 in that way, I might not simply ask for permission to use those slides straight off.

[12:03] <pmichaud> good morning, #perl6

[12:03] <masak> pmichaud! \o/

[12:04] <timbunce> I'm happy for anyone to use any of my slides. That deck was partly distilled from my earlier perl myths talks.

[12:04] <masak> I recognize some of those slides, yes.

[12:05] <jnthn> hi, pmichaud 

[12:05] <timbunce> The most fun in the talk was during the Q&A when I was demonstrating the scope of CPAN by asking the (mostly non perl) audience for "any topic" and typing it into the metacpan.org search box to see the matching suggestions. Proved to be impressive.

[12:06] <masak> I can imagine :)

[12:06] <masak> that's a neat way to convey the impressiveness of CPAN.

[12:06] <timbunce> Someone asked for "world peace" - I suggested they work on that one themselves.

[12:06] <Su-Shee> that's just one half of the impressiveness.. 

[12:07] <Su-Shee> I have xx years old platforms where I only do cpan Foo::Bar for whatever I need and _nothing_ else and it all works and all installs and all runs.. 

[12:08] <timbunce> I liked the tag line "Get ahead of the revolution: http://perl6.org"

[12:08] <pmichaud> excellent slides    timbunce++

[12:08] <masak> r: say "I have $x$x years old platforms..." for 1..5

[12:08] <p6eval> rakudo 637aad: OUTPUT«===SORRY!===␤Variable $x is not declared␤at /tmp/uIdII7N0ff:1␤»

[12:08] <timbunce> pmichaud: thanks

[12:08] <masak> r: say "I have $_$_ years old platforms..." for 1..5

[12:08] <p6eval> rakudo 637aad: OUTPUT«I have 11 years old platforms...␤I have 22 years old platforms...␤I have 33 years old platforms...␤I have 44 years old platforms...␤I have 55 years old platforms...␤»

[12:09] <pmichaud> I recognize some code examples in those slides   :)

[12:10] <timbunce> :)

[12:10] *** pmurias left
[12:10] <masak> cards++

[12:10] *** ggoebel left
[12:10] <colomon> moritz++ # omg, make $/.hash.values[0].ast // []; works in both rakudo and niecza.  big win!

[12:11] <moritz> colomon: even $/.values[0].ast might work

[12:13] *** domidumont joined
[12:17] *** bbkr joined
[12:17] <bbkr> rakudo: printf "%d"; # known bug?

[12:17] <p6eval> rakudo 9c1514: OUTPUT«Null PMC access in get_integer()␤  in sub sprintf at src/gen/CORE.setting:2166␤  in sub printf at src/gen/CORE.setting:2171␤  in block  at /tmp/lpFWKhquug:1␤␤»

[12:21] <tadzik> not surprising bug, at least

[12:21] <pmichaud> bbkr:  rt #106594

[12:21] <pmichaud> https://rt.perl.org/rt3/Ticket/Display.html?id=106594

[12:21] * tadzik considers toying around with our own printf()

[12:22] <bbkr> pmichaud: thanks

[12:22] *** birdwindupbird left
[12:24] *** birdwindupbird joined
[12:28] <brrt> popquiz, why are 6 bit operations stupid?

[12:29] <brrt> (context, a virtual machine)

[12:29] <brrt> 32-bit instruction word, 6 bytes for the operation

[12:30] <brrt> 6 bits

[12:31] <masak> brrt: insufficient context. 6 bits seems plenty given that brainfuck only has 8 operations in total. only 3 bits required to encode those.

[12:31] <brrt> 6 bits are plenty

[12:32] <brrt> the point is efficiency

[12:32] <brrt> getting the first 6 bits takes at least an AND operation

[12:32] <brrt> as in, instruction & 0b111111

[12:33] <brrt> making it 8 bits, its a full byte

[12:33] <colomon> moritz++: you are quite right.

[12:33] <jnthn> tadzik: Please do :)

[12:33] <jnthn> tadzik: One that can handle bigint too :)

[12:33] <tadzik> aye

[12:34] <tadzik> jnthn: do you think a grammar is a proper way to tackle this?

[12:34] <brrt> context is this nice link: http://rsms.me/2012/10/14/sol-a-sunny-little-virtual-machine.html

[12:34] <tadzik> it feels Perlsixy

[12:34] <tadzik> brrt: yeah, 6 bits seems a bit underthought

[12:35] <pmichaud> tadzik: I wouldn't use a grammar, no.

[12:35] <tadzik> for efficiency reasons?

[12:36] <jnthn> Is it actually that complex?

[12:36] <tadzik> not really

[12:36] <pmichaud> that, and it just strikes me as being easier to scan for %'s

[12:36] <tadzik> well, if it were mere %'s

[12:36] <tadzik> but then you have %5d's

[12:36] <tadzik> and %-5d's, stuff

[12:36] <pmichaud> you still scan for the %'s

[12:37] <tadzik> sure

[12:37] <pmichaud> then you look at what comes next to figure out what to do

[12:37] <arnsholt> You could comb $format-regex I guess?

[12:37] <arnsholt> Although that might count as grammars

[12:37] <tadzik> arnsholt: but then you get only %'s, not the rest

[12:37] <tadzik> well, I'll experiment and see for myself

[12:37] <pmichaud> tadzik: oh, you could comb for   /%[dxo]/  patterns

[12:37] <pmichaud> (I still don't recommend it, but it would work)

[12:37] <tadzik> I could, yes

[12:38] <tadzik> but then it's a matter of substituting them with new stuff

[12:38] <tadzik> so at least 2 passes, no?

[12:38] <arnsholt> Feels like it should be doable in a single pass

[12:38] <tadzik> yeah, I just don't see how I'd do that with .comb

[12:39] <arnsholt> True

[12:39] <jnthn> At present, regex is probably the fastest way to scan through a string

[12:39] <tadzik> without making it unneceserilly complex

[12:39] <tadzik> right

[12:40] <tadzik> yay, fun project on the horizon :)

[12:40] <jnthn> yay

[12:40] <pmichaud> you could do  .split( /pat/, :all)

[12:40] <pmichaud> that would still be one pass

[12:40] *** benabik left
[12:40] <tadzik> hm, I never knew about :all

[12:40] *** benabik joined
[12:40] <tadzik> indeed, split, map, join then

[12:41] *** leont joined
[12:41] <tadzik> will try different approaches and see how they work out

[12:43] *** jaldhar_ is now known as jaldhar

[12:48] *** mucker joined
[13:00] *** hash_table joined
[13:04] *** Psyche^ joined
[13:06] *** telex left
[13:07] *** Patterner left
[13:07] *** Psyche^ is now known as Patterner

[13:08] *** telex joined
[13:09] *** rindolf joined
[13:09] *** hoelzro left
[13:10] *** rob___ joined
[13:10] *** rob___ is now known as hoelzro

[13:13] *** skids left
[13:14] *** flightrecorder joined
[13:14] *** FROGGS joined
[13:15] *** sirrobert left
[13:22] *** GlitchMr joined
[13:25] *** PacoAir joined
[13:26] *** grondilu joined
[13:26] <grondilu> rn:  my @words = <foo bar>; say "foo" ~~ / ^ < @words > $ /;

[13:26] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Potential difficulties:␤  @words is declared but not used at /tmp/AFcbwDjjUz line 1:␤------> my ⏏@words = <foo bar>; say "foo" ~~ / ^ < @␤␤Match()␤»

[13:26] <p6eval> ..rakudo 9c1514: OUTPUT«#<failed match>␤»

[13:27] <grondilu> r:  my @words = <foo bar>; say "foo" ~~ / ^ < {@words} > $ /;

[13:27] <p6eval> rakudo 9c1514: OUTPUT«#<failed match>␤»

[13:27] <grondilu> n:  my @words = <foo bar>; say "foo" ~~ / ^ < {@words} > $ /;

[13:27] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Potential difficulties:␤  @words is declared but not used at /tmp/W40e7m7NU1 line 1:␤------> my ⏏@words = <foo bar>; say "foo" ~~ / ^ < {␤␤Match()␤»

[13:27] <grondilu> Can't I interpolate inside a < > in regex?

[13:29] <moritz> D/w 20

[13:29] *** leont left
[13:29] <masak> grondilu: see S05.

[13:29] <masak> (not an "RTFM" so much as "I don't know/don't remember offhand")

[13:30] <jnthn> No, just as you can't in normal Perl 6.

[13:30] <masak> oh, it's [|@words] or something, isn't it?

[13:30] <jnthn> Something like that, yeah

[13:31] <grondilu> masak: ok, sorry

[13:32] *** benabik left
[13:33] <grondilu> rn:  my @words = <foo bar>; say "foo" ~~ / @words /;

[13:33] <masak> no apology needed.

[13:33] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«#<match from(0) to(3) text(foo) pos([].list) named({}.hash)>␤»

[13:33] <p6eval> ..rakudo 9c1514: OUTPUT«#<failed match>␤»

[13:34] <grondilu> according to line 1014 of S05 the above should match, shouldn'it?

[13:34] <lumi__> Is there some trick to exporting trait_mod:<is> ?

[13:35] <grondilu> oh ok I've just realized that niecza found a match.

[13:35] <masak> lumi__: don't think so.

[13:35] <masak> grondilu: yeah. probably just unimplemented in Rakudo.

[13:35] <masak> or implemented but not to spec.

[13:37] <moritz> lumi__: it might need a new rakudo

[13:37] *** pmurias joined
[13:37] <moritz> r: module A { multi trait_mod:<is>() is export { } }; import A;

[13:37] <p6eval> rakudo 9c1514:  ( no output )

[13:38] <moritz> seems to work

[13:39] <moritz> star: module A { multi trait_mod:<is>() is export { } }; import A;

[13:39] <p6eval> star 2012.07:  ( no output )

[13:40] <moritz> star: module A { multi trait_mod:<is>(say 42 ) is export { } }; import A; trait_mod:<is>()

[13:40] <p6eval> star 2012.07: OUTPUT«===SORRY!===␤Invalid typename in parameter declaration at line 2, near " 42 ) is e"␤»

[13:40] <moritz> star: module A { multi trait_mod:<is>() is export { say 42 } }; import A; trait_mod:<is>()

[13:40] <p6eval> star 2012.07: OUTPUT«42␤»

[13:40] <moritz> r: module A { multi trait_mod:<is>() is export { say 42 } }; import A; trait_mod:<is>()

[13:40] <p6eval> rakudo 9c1514: OUTPUT«42␤»

[13:40] <moritz> seems no trick is necessary

[13:41] *** simo_ joined
[13:42] <lumi__> moritz: I'm having trouble with importing it from another file, not sure what exactly is going on, but my multi doesn't appear on the candidate list

[13:42] *** simo_ left
[13:44] <moritz> lumi__: how young/old is your rakudo?

[13:44] *** tokuhiro_ left
[13:44] *** hash_table left
[13:44] <moritz> lumi__: I suspect it might need patch Perl-22-g031a497

[13:44] *** tokuhiro_ joined
[13:45] *** grondilu left
[13:47] <lumi__> Head from after jnthn++'s recent fix to my segfault

[13:49] *** tokuhiro_ left
[13:53] <felher> Hm, i know i can interpolate a variable into a regex with / $variable /. Is there also an easy way to interpolate an attribute of an object into the regex? / $object.strAttribute / doesn't work, because it interpolates $object.Str, and takes '.strAttribute' as part of the normal regex.

[13:55] <FROGGS> so you are searching for Perl 5's \Q\E?

[13:55] <moritz> FROGGS: try $obj.strAttribute()

[13:55] <moritz> lumi__: I've just put a simple trait_mod:<is> into a file, exported it and used it just fine

[13:55] <moritz> (also on HEAD)

[13:56] <GlitchMr> {$object.strAttribute} or $object.strAttribute()

[13:56] <GlitchMr> It should work

[13:56] <GlitchMr> Oh, wait, {} is assertion

[13:57] <moritz> {} in a regex is just action

[13:57] <moritz> <{ }> might do it, not sure

[13:58] <felher> GlitchMr, moritz: yep. {} is an action and () in a regex is treated das a (disallowed) null-pattern

[13:58] <felher> even after $object.strAttribute

[13:58] <lumi__> I'm getting this weirdness: Method 'SET_FILE_LINE' not found for invocant of class 'X::AdHoc'

[13:58] <lumi__> I guess maybe my rakudo is sick

[13:58] <FROGGS> moritz: can you try to add "use NativeCall" after you import the trat_mod:<is> from that file and see if it still sowkrs?

[13:58] *** replore_ left
[13:58] <FROGGS> s/sowrks/works/

[13:59] * felher tries <{ }>

[13:59] <FROGGS> didnt update my rakudo for a while now, so I'm not sure that the import-bug is still there

[13:59] <GlitchMr> This is confusing. If {} interpolates in strings, why it shouldn't it regexpes?

[13:59] <felher> moritz++ # awesome, thnx :)

[13:59] <hoelzro> GlitchMr: that may be a bug

[13:59] *** stopbit joined
[14:00] <moritz> lumi__: that indicates you might throw an exception inside the trait

[14:00] <moritz> lumi__: try calling it at run time, and see if you get a better error message

[14:00] <GlitchMr> It's a feature as far I know, but confusing

[14:00] <GlitchMr> How often you use (?{}) in Perl 5 regexpes anyways?

[14:01] * moritz doesn't need interpolation into regexes very often

[14:02] <FROGGS> r: use NativeCall

[14:02] <p6eval> rakudo 9c1514: OUTPUT«===SORRY!===␤Could not find NativeCall in any of: /home/p6eval/.perl6/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/lib, /home/p6eval/nom-inst/lib/parrot/4.8.0-devel/languages/perl6/custom/lib␤»

[14:02] <FROGGS> sad

[14:03] <jnthn> FROGGS: r is just the compiler

[14:03] <jnthn> star: use NativeCall;

[14:03] <p6eval> star 2012.07:  ( no output )

[14:03] <FROGGS> ohh

[14:03] <jnthn> That's how you get at the distro

[14:03] <FROGGS> but 2012.07 is way to old for that...

[14:03] <jnthn> oh, hm 

[14:04] <FROGGS> jnthn: did you fix that trait_mod import problem?

[14:05] <pmurias> GlitchMr: putting in prints for debugging purposes is one use of (?{ })

[14:06] <jnthn> FROGGS: Hmm...I fixed something about trait mod in 031a49747 but I think you mean something else.

[14:06] *** kaare_ joined
[14:10] <FROGGS> hmmm, k, I'll recompile and check

[14:16] <moritz> FROGGS: I still can't import trait_mod:<is> from two different modules, no

[14:16] <FROGGS> moritz: k, thanks

[14:16] <jnthn> Is that a general multi issue?

[14:17] <GlitchMr> pmurias: isn't debugger for that?

[14:17] <FROGGS> jnthn: I think so

[14:19] <FROGGS> jnthn: the problem is here: https://github.com/rakudo/rakudo/blob/nom/src/Perl6/World.pm#L268

[14:20] <FROGGS> it should throw an X::Import::Redeclaration, but instead should merge the symbols and add dispatchees

[14:20] <FROGGS> s/should/shouldn't)

[14:20] <FROGGS> meh

[14:20] <jnthn> Yeah

[14:20] <jnthn> Only if things are all onlystars I guess though

[14:20] <pmurias> GlitchMr: I haven't tried Regexp::Debugger

[14:20] <FROGGS> I tried to hunt that down, but after  a week and a half I gave up

[14:20] <jnthn> Otherwise I guess the different protos could conflict.

[14:21] <pmurias> GlitchMr: and I prefer prints to the perl5 code debuggers

[14:21] <jnthn> FROGGS: I think it's just an NYI

[14:21] <FROGGS> right, thats why there is a # TODO ;o)

[14:22] <FROGGS> I tried to find the point where I would be able to handle the dispatchees, but had no luck

[14:23] <FROGGS> all I can say is if you uncomment that exception, you will get the symbols/dispatchees of the module you import at last

[14:23] <jnthn> Right

[14:24] *** rindolf left
[14:25] *** bbkr__ joined
[14:27] *** bbkr left
[14:29] <moritz> what I currently wonder is

[14:29] <moritz> star: use NativeCall; class A is export { }

[14:29] <p6eval> star 2012.07:  ( no output )

[14:29] <moritz> how does that work?

[14:30] <moritz> I'd thought that NativeCall exports a trait_mod:<is>

[14:30] <moritz> how does it work that the 'is export' from the setting is still visible?

[14:31] <colomon> moritz: it's a multi of trait_mod:<is>, isn't it?

[14:31] <moritz> colomon: yes, that much is clear

[14:31] *** sirrobert joined
[14:32] <FROGGS> moritz: you can have the trait_mod:<is> from core and another module

[14:32] <moritz> does it mean that importing multis merges the multis into the existing multis?

[14:32] <FROGGS> but not core + module + module

[14:32] <moritz> FROGGS: correct, and I don't understand why

[14:32] <FROGGS> me neither

[14:33] <colomon> seems like it should always work no matter how many modules are involved?  (are we talking rakudo or spec here?)

[14:33] <moritz> colomon: that much is also clear

[14:33] <moritz> the question is why core + module + module doesn't work in rakudo, even though core + moduel works

[14:33] <moritz> since core + module works, there must be a merging operation somewhere (though maybe implicit through scoping or so)

[14:34] <FROGGS> maybe there is a separate dispatcher list for core and modules?

[14:34] <jnthn> moritz: I think the answer is horrible.

[14:34] <jnthn> moritz: It's because the CORE multi candidates are included in the dispatcher that is exported.

[14:34] <moritz> eeks

[14:35] <jnthn> moritz: Because that's how lexical multis work.

[14:35] <jnthn> (they incorporate outer candidates into their candidate list)

[14:35] <moritz> so on merging, we have to take care not to create dispatch conflicts between the same candidate exported through two different routes

[14:35] <FROGGS> btw, I made debugging output so I could see what functiona are called when loading and importing modules, its just crazy (for me), every core module is calling stuff from modules that calls stuff from the calling modules and so on

[14:35] <FROGGS> just like crazy

[14:37] <jnthn> What? :)

[14:37] <jnthn> moritz: Something like that.

[14:37] <jnthn> moritz: Or we make sure that exports don't end up including things that they "inherited"

[14:38] <sirrobert> If there's a file I eval a fair bit (for my test suite), is there a way to compile it and read the compiled version in?

[14:38] <sirrobert> (eval seems slower than I'd expected)

[14:38] <moritz> sirrobert: make it a module, precompile it

[14:39] <sirrobert> moritz: ok.  precompiling modules is currently broken for me.

[14:39] <moritz> :(

[14:40] <sirrobert> well, actually, I haven't checked in like a month... maybe it's working =)

[14:40] <sirrobert> (checking)

[14:41] <jnthn> You have to be doing some fairly specific things to hit pre-comp bugs.

[14:41] *** skids joined
[14:41] <sirrobert> it's a natural skill =)

[14:41] *** ggoebel joined
[14:41] * colomon seems to recall that he has hit pre-comp bugs as well...

[14:42] <sirrobert> running my test suite on the precompiled bit now.

[14:42] <moritz> colomon: ABC did, last I looked

[14:42] <colomon> moritz: right

[14:42] <jnthn> User-defined operators are the "easy way" to hit the issue

[14:42] <colomon> moritz: I don't even try to pre-comp any of my modules these days... I always do something like prove -e "perl6 -Ilib" t/ 

[14:43] *** grondilu joined
[14:43] <sirrobert> !! perfect tests on Rakudo 2012-09 =)  I turned off precomp in the 2012-07 when I was hitting the issues.

[14:44] <sirrobert> everyone++

[14:44] <sirrobert> and the tests ran in 1/98457639875349739 the time =)

[14:44] *** hash_table joined
[14:44] <jnthn> precomp ain't perfect yet for sure, but the cases where it works are much more common than the cases where it doesn't

[14:45] <sirrobert> jnthn: I had hit something that broke all of my tests

[14:45] <sirrobert> (I wrote a testing framework to do spec-testing for a REST API)

[14:45] <jnthn> ooh, nice

[14:45] <sirrobert> probably something in there went weird

[14:45] <jnthn> (the framework, not the bug)

[14:45] <sirrobert> heh nod

[14:45] <sirrobert> it's super slick

[14:45] <sirrobert> it allows introspection to produce api spec docs out of the test suite =)

[14:46] <sirrobert> (*I* like it, anyway ;)

[14:46] <moritz> sounds nice :-)

[14:47] <moritz> the precomp bugs are usually all-or-nothing

[14:47] <sirrobert> when we get some solid footing (business-wise) I'll see about releasing it and some other stuff we built

[14:47] <moritz> either everything works perfectly, or you get a compile-time error

[14:47] <sirrobert> heh nod

[14:47] <sirrobert> that was my experience

[14:47] <moritz> (at least that's my experience so far)

[14:48] <jnthn> Yes, and I'd rather have it all-or-nothing that really weird behavior.

[14:49] *** benabik joined
[14:52] *** kresike left
[15:01] *** bbkr_ left
[15:02] *** bbkr_ joined
[15:04] <rjbs-> 2/lm

[15:05] *** lorn left
[15:06] *** lorn joined
[15:08] *** replore joined
[15:09] *** colomon_ joined
[15:09] * skids reposes http://irclog.perlgeek.de/perl6/2012-10-16#i_6065721 question now that folks are awake

[15:10] *** colomon left
[15:10] *** colomon_ is now known as colomon

[15:10] <jnthn> skids: Can I have a concrete example of such an API?

[15:11] <skids> jnthn: things like: void    *mhash_end_m(MHASH thread, void* (*hash_malloc)(size_t));

[15:12] <skids> The malloc is used to create the memory for the digest, which is pointed to by the return value.

[15:12] *** mtk left
[15:13] *** att joined
[15:14] <jnthn> skids: Maybe arnsholt++ has some idea but I'm not aware of any such function we have that'd do anything useful there.

[15:17] <moritz> what is the problem, the callback or the malloc?

[15:17] <skids> No problem, most APIs that offer these forms also offer forms that just internally call malloc.

[15:18] <skids> The question is whether there's a benefit from using the other form, for example, getting a malloc that can DESTROY itself (eventually, even if NYI).

[15:18] *** mtk joined
[15:19] <jnthn> moritz: Did you mean to add changelog entries under New in 2012.09.1?

[15:19] <jnthn> moritz: Or did you want a 2012.10 heading? :)

[15:19] <jnthn> (I mean for latest 3 entries)

[15:19] *** fgomez left
[15:22] *** benabik_ joined
[15:23] <dalek> rakudo/nom: 7372a10 | jnthn++ | src/core/ (8 files):

[15:23] <dalek> rakudo/nom: Eliminate various pir:: usages.

[15:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7372a10b19

[15:23] <dalek> rakudo/nom: c2005e6 | jnthn++ | src/Perl6/Grammar.pm:

[15:23] <dalek> rakudo/nom: Fix most of the Pod tests on Win32.

[15:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2005e6b8c

[15:24] *** grondilu left
[15:25] *** benabik left
[15:25] *** benabik_ is now known as benabik

[15:27] *** hoelzro is now known as hoelzro|away

[15:28] *** benabik_ joined
[15:30] *** sjohnson joined
[15:30] *** sjohnson left
[15:30] *** sjohnson joined
[15:30] *** benabik left
[15:30] *** benabik_ is now known as benabik

[15:32] *** rindolf joined
[15:32] *** fgomez joined
[15:32] *** brrt left
[15:33] *** MayDaniel joined
[15:34] <jnthn> r: $*ARGFILES.lines()

[15:34] <p6eval> rakudo 9c1514:  ( no output )

[15:34] <jnthn> r: say $*ARGFILES.lines()[0]

[15:34] <p6eval> rakudo 9c1514: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmi…

[15:34] <jnthn> r: say $*IN.lines()[0]

[15:34] <p6eval> rakudo 9c1514: OUTPUT«Land der Berge, Land am Strome,␤Land der Äcker, Land der Dome,␤Land der Hämmer, zukunftsreich!␤Heimat bist du großer Söhne,␤Volk, begnadet für das Schöne,␤vielgerühmtes Österreich,␤vielgerühmtes Österreich!␤␤Heiß umfehdet, wild umstritten␤liegst dem Erdteil du inmi…

[15:34] <jnthn> r: say $*IN.lines().perl

[15:34] <p6eval> rakudo 9c1514: OUTPUT«("Land der Berge, Land am Strome,\nLand der Äcker, Land der Dome,\nLand der Hämmer, zukunftsreich!\nHeimat bist du großer Söhne,\nVolk, begnadet für das Schöne,\nvielgerühmtes Österreich,\nvielgerühmtes Österreich!\n\nHeiß umfehdet, wild umstritten\nliegst dem Erdt…

[15:35] <jnthn> r: say open('README', :r).lines[0]

[15:35] <p6eval> rakudo 9c1514: OUTPUT«open is disallowed in restricted setting␤  in sub restricted at src/RESTRICTED.setting:2␤  in sub open at src/RESTRICTED.setting:5␤  in block  at /tmp/HbelFTiQq_:1␤␤»

[15:35] <jnthn> r: say CORE::open('README', :r).lines[0]

[15:35] <p6eval> rakudo 9c1514: OUTPUT«No such method 'Any' for invocant of type 'Str'␤  in  at src/gen/BOOTSTRAP.pm:814␤  in any  at src/gen/BOOTSTRAP.pm:811␤  in block  at /tmp/OUvIHGkHN2:1␤␤»

[15:36] <jnthn> Hm, oddness. lines works for me... :S

[15:44] <moritz> jnthn: I wanted 2012.10

[15:44] <moritz> jnthn: but it seems I've messed it up

[15:44] <jnthn> moritz: ok :)

[15:46] <jnthn> std: 'abc' ~~ /:iabc/

[15:46] <p6eval> std 77327a4: OUTPUT«===SORRY!===␤Unrecognized regex modifier :iabc at /tmp/bZn_zdAHo2 line 1:␤------> 'abc' ~~ /:iabc⏏/␤Check failed␤FAILED 00:00 44m␤»

[15:56] *** thou joined
[15:57] *** alester joined
[15:58] *** ComWT left
[15:58] <sirrobert> is there a way from "prove" to run just a specific test?

[15:59] <moritz> prove -e perl6 t/yourtest.t

[15:59] <sirrobert> like, 32 tests planned, skip until you get to test 14 and run that one.

[15:59] <sirrobert> err assertions, I mean

[15:59] <moritz> erm, no

[15:59] <sirrobert> ok =)

[15:59] <moritz> often individual tests depend on previous tests

[16:00] <moritz> and prove just executes some binaries; doesn't need to be perl

[16:00] <moritz> anything that prints  plan 1;\nok 1 - your dad\n  is fine

[16:04] <sirrobert> nod

[16:04] <sirrobert> just wondering if it was possible for those times that don't =)

[16:05] <sirrobert> easy enough to comment out the ones I want to skip

[16:05] <sirrobert> mistype

[16:06] <moritz> easy enough to mistype :-)

[16:06] *** silug left
[16:06] *** silug joined
[16:06] <sirrobert> heh

[16:07] <masak> sirrobert: if your tests are parseable enough, you could autogenerate test files containing subsets of your tests, and run those.

[16:07] <sirrobert> ahh, good idea.  Yeah, I tend to put sets of subtests in anonymous blocks

[16:07] <sirrobert> thanks

[16:08] * moritz has an evil idea

[16:09] <sirrobert> ....?  

[16:09] <sirrobert> do tell =)

[16:09] <moritz> sub test($name, &block) { block() }

[16:09] <moritz> so you write

[16:09] <moritz> test 'first label', { # first block of tests here }

[16:09] <moritz> test 'second label', { # second block of tests here }

[16:10] <sirrobert> hmmmm good =)

[16:10] <moritz> and then you can make sub test() more sophisticated, to only call tests whose blocks are in @*ARGS

[16:10] <moritz> and call them all if @*ARGS is empty

[16:10] <sirrobert> nice

[16:10] <sirrobert> I'll slip that into my to-do =)

[16:11] <sirrobert> my current test framework lets me do API tests this way:

[16:11] <moritz> sub test($name, &block) { block() if !@*ARGS || $name eq any @*ARGS }

[16:11] <[Coke]> you could just steal "fudge".

[16:11] <sirrobert> $suite.test: 'description', GET, $url, %query-params, %body-params;

[16:11] <lumi__> You also need a count for skipping, I think

[16:11] *** sjohnson left
[16:11] <sirrobert> and a separate file handles the expected results so my test file is clean

[16:11] <moritz> lumi__: unless you use planless testing

[16:12] <jnthn> r: :(::T $x)

[16:12] *** sjohnson joined
[16:12] <p6eval> rakudo c2005e:  ( no output )

[16:12] <moritz> r: :(::T $x); say $x.WHAT

[16:12] <p6eval> rakudo c2005e: OUTPUT«===SORRY!===␤Variable $x is not declared␤at /tmp/1oIy7PsXFp:1␤»

[16:12] <moritz> r: my :(::T $x); say $x.WHAT

[16:12] <p6eval> rakudo c2005e: OUTPUT«===SORRY!===␤Malformed my␤at /tmp/IsFMGbqDMR:1␤»

[16:13] <sirrobert> What is ::T?

[16:13] *** leont joined
[16:13] <skids> Type capture en passant.

[16:13] <lumi__> r: my ::T $x;

[16:13] <p6eval> rakudo c2005e:  ( no output )

[16:13] <jnthn> Type capture

[16:13] <jnthn> It used to explode when you wrote the above. Now it doesn't.

[16:13] * jnthn is doing some RTs :)

[16:13] <sirrobert> I don't understand the response =)

[16:13] <moritz> r: my ::T $x = 24; say $x

[16:13] <p6eval> rakudo c2005e: OUTPUT«Cannot assign to a readonly variable or a value␤  in block  at /tmp/h4FK6PMgL1:1␤␤»

[16:13] <sirrobert> ohhh

[16:13] <lumi__> r: my ::T $x; say $x.WHAT

[16:13] <p6eval> rakudo c2005e: OUTPUT«Cannot call a method on type variable T␤  in any find_method at src/gen/Metamodel.pm:295␤  in sub say at src/gen/CORE.setting:7268␤  in block  at /tmp/NoSNyivfRM:1␤␤»

[16:13] <jnthn> I don't think it's very useful in a my :)

[16:14] <jnthn> r: say \(1, 1) ~~ :(::T, T)

[16:14] <p6eval> rakudo c2005e: OUTPUT«True␤»

[16:14] <jnthn> r: say \(1, 'lol') ~~ :(::T, T)

[16:14] <p6eval> rakudo c2005e: OUTPUT«False␤»

[16:14] <jnthn> Even works :)

[16:14] *** leont left
[16:16] <dalek> nqp: 3cfcb96 | jnthn++ | src/QRegex/P6Regex/Grammar.nqp:

[16:16] <dalek> nqp: Detect invalid internal regex mods.

[16:16] <dalek> nqp: 

[16:16] <dalek> nqp: Includes the case where the invalid mod starts with the name of a

[16:16] <dalek> nqp: recognized one.

[16:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3cfcb96c4b

[16:18] <dalek> rakudo/nom: aeb4515 | jnthn++ | tools/build/NQP_REVISION:

[16:18] <dalek> rakudo/nom: Bump NQP_REVISION to get regex modifier fix.

[16:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aeb45158fc

[16:18] <dalek> rakudo/nom: 7731d28 | jnthn++ | src/core/MapIter.pm:

[16:18] <dalek> rakudo/nom: Avoid an unbox-as-Int failure in MapIter.

[16:18] <dalek> rakudo/nom: 

[16:18] <dalek> rakudo/nom: Note that this may not be quite the right semantics, but it's better

[16:18] <dalek> rakudo/nom: than exploding over the eventual unbox_i of Inf we can otherwise get.

[16:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7731d28166

[16:18] *** pmurias left
[16:19] *** pochi left
[16:19] <lumi__> I've uploaded https://github.com/lumimies/override-perl6 - it does that whole "No such method 'SET_FILE_LINE'" when the exception is thrown

[16:19] <lumi__> Oh, which is a bad thing

[16:21] *** Hor|zon joined
[16:22] <jnthn> moritz: ^^ may be one you've an answer for :)

[16:25] <sjn> \o

[16:25] * sjn is at Hackeriet (the Oslo hackerspace) talking about Perl6 o/

[16:26] <sjn> got a question here... what kind of parsing style does rakudo use? (recursive decent?)

[16:26] <sirrobert> =)

[16:26] <jnthn> recursive indecent

[16:26] <sjn> :)

[16:27] <jnthn> It's a kind of PEG

[16:27] *** rogerrogerstein joined
[16:27] <TimToady> nr: sub foo { [+] gather '' ~~ / ^ { take 1..4; return 0 } / }; say foo

[16:27] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«10␤»

[16:27] <p6eval> ..rakudo c2005e: OUTPUT«0␤»

[16:27] <TimToady> I think this is a nieczabug

[16:28] <sjn> jnthn: kind of?

[16:28] <jnthn> It's recursive descent but alternations are decided by transitive LTM, meaning that unlike typical recdescent it won't have to try anything like as many branches.

[16:28] <jnthn> And it also has a bottom-up expression parser too

[16:33] *** spider-mario joined
[16:33] *** kaleem left
[16:35] <Hor|zon> Question: am I the only one having really confusing conversations about perl6 roles because of conflation of interface and mixin?

[16:36] <Hor|zon> it seems to me that you need some experience of both concepts separately to make _sensible_ use of roles

[16:37] <sirrobert> Hor|zon:  my conversations about roles have worked well when I say: "composable class elements"

[16:37] <sirrobert> then just emphasize "composable" for a while.

[16:37] <TimToady> added a validating version to http://rosettacode.org/wiki/Roman_numerals/Decode#Perl_6, but it runs into the nieczabug above

[16:38] *** dakkar left
[16:40] <Hor|zon> sirrobert: lol, I was trying to explain things to a new developer, and I realised that there was no way he wouldn't create a mess, because roles themselves come without handle bars

[16:40] <TimToady> Hor|zon: that's why we picked the word "role", because it's a concept that doesn't commit to one or the other.  If you use a role from a class, it's interface; if you use it to wrap an object in a new type, it's a mixin.

[16:40] <Hor|zon> you usually want interface type roles, or mixin type roles, and then sometimes  a *Tiny* bit of the other, but the grey area is huge

[16:41] <jnthn> Most of my roles aren't interface-type or mixin-type these days.

[16:41] <doy> mine either

[16:42] <Hor|zon> jonathan-type roles?

[16:42] <TimToady> well, they're also generics, generally speaking

[16:42] <TimToady> as such they can suggest implementation, which interfaces don't

[16:43] <TimToady> you can also think of them as closed classes :)

[16:43] <TimToady> It would seem that roles have many roles. :D

[16:44] <jnthn> Hor|zon: To me, roles are primarily about factoring out common concerns that can be composed into many classes. A class should have a responsibility and completely fulfil it. A role is free of the need to have a responsibility, and can focus on being a reusable thingy.

[16:45] <TimToady> Hamlet is a role, but it has to be instantiated by an actor, the class.

[16:45] <jnthn> Example from Rakudo implementation: grammars, roles and classes can all have methods, so the functionality related to having methods is factored out into a role.

[16:45] <TimToady> We all know that Hamlet is irresponsible. :)

[16:45] *** Pleiades` left
[16:45] <jnthn> A "method haver" is useless on its own, but the concept and its implementation is reusable.

[16:45] <sirrobert> jnthn:  Whereas a superclass is a hierarchical extraction of duplicated functionality, a role is a non-hierarchical extraction.

[16:46] <masak> TimToady: agree on the Nieczabug. I'll submit it.

[16:46] <sirrobert> jnthn:  (in support of what you were saying =)

[16:46] <Hor|zon> yeah, it's definitely a better concept, but I'm starting to think having some type of mixin and interface syntax/module (implemented on top of roles), which makes it obvious would be nice to have, it could just be another module

[16:47] <Hor|zon> that way when you see a role explicitly, you know it's grey area code, but when it's only a mixin or only an interface it's also obvious

[16:48] <masak> TimToady: https://github.com/sorear/niecza/issues/153

[16:48] <TimToady> masak++

[16:49] <doy> that just always feels like an artificial limitation to me - what if you have an interface, and then decide it would be useful to provide a default implmentation of one of the methods (because it ends up almost always doing the same thing)?

[16:49] <Hor|zon> I'm just finding that I end up writing in comments "this is meant as an interface" with my roles

[16:49] <Hor|zon> if I could just alias "role" to "interface", I could get rid of the stupid comment

[16:49] <TimToady> well, if all your methods are stubs, it's an interface

[16:51] *** sjohnson left
[16:51] <Hor|zon> it all depends on your intentions, present and future, I'm just saying I could make it very clear from the outset using a different keyword

[16:51] *** sjohnson joined
[16:51] *** sjohnson left
[16:51] <TimToady> compared to p5, we do give more names to things in p6, but naming a degenerate case seems to me to not all that terribly useful

[16:51] <TimToady> *not be

[16:52] *** Pleiades` joined
[16:52] <TimToady> if it's useful in your situation, we'll probably have macros to give aliases to things like that

[16:52] <Hor|zon> I agree, not terribly useful, so maybe not core, but as an optional extra

[16:52] <Hor|zon> ah yes, macros

[16:52] <Hor|zon> cool

[16:53] <TimToady> aliases are a good (or at least un-bad) spot to use single-word textual macros, I suspect

[16:54] * jnthn had pondered making installing any name in EXPORTHOW lead to the creation of a package_declarator that parses that name and uses the appropraite meta-object.

[16:54] *** sjohnson joined
[16:54] *** sjohnson left
[16:54] *** sjohnson joined
[16:54] <jnthn> Then you could also do the meta-programming to make sure that there was no way to supply anything in an interface besides a stub.

[16:54] <jnthn> well, you can do that bit today

[16:54] <jnthn> but the extra names bit you can't

[16:55] <jnthn> it may be too magical though ;)

[16:55] <TimToady> and may fall out of exportable macros anyway

[16:55] <Hor|zon> too magical? ;)

[16:55] <TimToady> or more generally, exportable grammar

[16:56] <jnthn> TimToady: You still need to get the right entires in %*HOW

[16:56] <jnthn> (that is, we could make you need to explicitly do the syntax tweak but it'd be additional)

[16:56] <TimToady> sure, that's more than an alias will do, but grammars are a bit more powerful than that

[16:57] <jnthn> TimToady: I guess in this I'm assuming that the EXPORTHOW package will stay around as the way to do these things... :)

[16:57] *** replore left
[16:57] <TimToady> "use Python;" will have to do even more work than that :)

[16:57] <jnthn> Oh, I had a question about STD...

[16:57] <jnthn> std: { sub infix:<lolz>($, $) { }; a lolz b; }; a lolz b

[16:57] <p6eval> std 77327a4: OUTPUT«===SORRY!===␤Undeclared routines:␤        'a' used at line 1,1␤   'b' used at line 1,1␤   'lolz' used at line 1,1␤Check failed␤FAILED 00:00 44m␤»

[16:58] <jnthn> er

[16:58] <jnthn> std: { sub infix:<lolz>($, $) { }; 1 lolz 2; }; 1 lolz 2

[16:58] <p6eval> std 77327a4: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/1LajtzUe_o line 1:␤------>  infix:<lolz>($, $) { }; 1 lolz 2; }; 1 ⏏lolz 2␤    expecting any of:␤      infix or meta-infix␤    infixed function␤       statement modifier loop␤Parse failed␤FAILED 00:00

[16:58] <p6eval> ..46m…

[16:58] <jnthn> That's what I wanted

[16:58] <jnthn> So, the grammar tweaks are lexically scoped. In Rakudo that currently isn't true

[16:58] <jnthn> r: { sub infix:<lolz>($, $) { }; 1 lolz 2; }; 1 lolz 2

[16:58] <p6eval> rakudo c2005e: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&infix:<lolz>' called (line 1)␤»

[16:58] *** birdwindupbird left
[16:58] <jnthn> I mean, it gets it but not as a syntax problem like it should.

[16:58] <TimToady> so what's the question?

[16:58] <jnthn> I was looking at how STD makes this work and got...confused.

[16:59] <jnthn> I saw that it twiddles what's in %*LANG<MAIN>

[16:59] <jnthn> Also that we immediately mix into the current cursor

[16:59] <jnthn> But how does that lead to the cursor we're parsing the statements with in the outer scope work?

[17:00] <TimToady> we throw away that cursor at the end of the current lexical scope

[17:00] *** erkan joined
[17:00] *** erkan left
[17:00] *** erkan joined
[17:00] *** vlixes joined
[17:00] <jnthn> But there's more than one cursor object created at this point, at least in the way QRegex has it.

[17:00] <TimToady> that's how STD does all of its scoping and backtracking; the cursor carries everything, so you merely throw away cursors

[17:01] <jnthn> OK, but when you hit statementlist, that makes a cursor

[17:01] <jnthn> Calling statement creates another one, etc.

[17:01] <jnthn> When one statement is a declaration that installs a categorical, it can mix into the current cursor, but that's the cursor for, say, routine_def

[17:02] <jnthn> Now, I can see how everything we parse inside of the routine sees the derived grammar

[17:02] <TimToady> see line 1325

[17:02] <jnthn> looking

[17:02] <TimToady> each statement starts in the current language in MAIN

[17:02] <TimToady> so it comes down to dynamic scoping at that point

[17:02] <jnthn> Oooooh!

[17:03] <jnthn> hm, and I can't find where $*LASTSTATE is declared?

[17:04] <jnthn> Or what it's about

[17:04] <jnthn> The bless makes sense to me and answers my question, though.

[17:04] * jnthn guesses it's the bless that really matters here

[17:05] <TimToady> there's a 'local $::LASTSTATE;' in CursorBase

[17:05] <jnthn> Is there a reason it's <!!{ $*LASTSTATE = $¢.pos; $¢ = %*LANG<MAIN>.bless($¢); }> rather than just { $*LASTSTATE = $¢.pos; $¢ = %*LANG<MAIN>.bless($¢); }

[17:05] <jnthn> LTM related?

[17:05] <TimToady> yes

[17:05] <TimToady> <!...> is transparent to LTM

[17:05] <TimToady> <?...> isn't

[17:06] <jnthn> *nod*

[17:06] <TimToady> nor is {}

[17:06] <jnthn> I'm pretty sure we have it that way already

[17:06] * jnthn tries to work out what $*LASTSTATE is actually for

[17:06] <TimToady> so I guess it's an oversimplification to say that STD does all its scoping by throwing away cursors, though that's essentially what the dynamic scoping is managing

[17:07] <jnthn> yeah, I'd been looking in cursor_fresh and all that lot for some odd magic :)

[17:07] <jnthn> well, and mixin

[17:07] <jnthn> I'm relieved that what's going on is basically sane :)

[17:07] <jnthn> LASTSTATE looks suspiciously fossily to me

[17:08] <TimToady> ./STD.pm5:	$SIG{__WARN__} = sub { die @_,"   statement started at line ", 'Cursor'->lineof($::LASTSTATE), "

[17:08] <jnthn> Oh

[17:08] <jnthn> OK, I guess it's not important for what I'm doing here

[17:09] <jnthn> OK, thanks, that clears things up nicely for me :)

[17:09] <TimToady> it's an old debugging aid

[17:09] <TimToady> though not necessarily obsolete, if I stick a "warn" in somewhere

[17:09] <TimToady> I should probably take it out of STD

[17:10] <TimToady> haven't used it in years

[17:11] <[Coke]> jnthn: any ideas on https://github.com/perl6/nqp/issues/59 ?

[17:13] <TimToady> jnthn: the 'bless' is part of the magic; the important thing to remember is that we never actually return a cursor up the tree (except to cheat); all info that travels up the syntax tree is (at least notionally) copied out of a dying cursor into (a clone of) the outer cursor that initiated the subparse.

[17:13] * jnthn takes it as license to ignore it for now

[17:13] <jnthn> [Coke]: looking

[17:14] <jnthn> TimToady: Yes, the "never return a cursor up the tree" thing was what was bothering me about how on earth STD was doing it :)

[17:15] <jnthn> n: class EEK {method Numeric() {return 3}}; my $a:= EEK.new(); say(+$a);

[17:15] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«3␤»

[17:15] <jnthn> grr

[17:15] <jnthn> nqp: class EEK {method Numeric() {return 3}}; my $a:= EEK.new(); say(+$a);

[17:15] <p6eval> nqp: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤␤current instr.: 'Numeric' pc 3370 (src/stage2/gen/NQPCORE.setting.pir:1584) (src/stage2/NQPCORE.setting:171)␤»

[17:15] <jnthn> nqp: class EEK {multi method Numeric() {return 3}}; my $a:= EEK.new(); say(+$a);

[17:15] <p6eval> nqp: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤␤current instr.: 'Numeric' pc 3370 (src/stage2/gen/NQPCORE.setting.pir:1584) (src/stage2/NQPCORE.setting:171)␤»

[17:16] <jnthn> [Coke]: I have to wonder if it's not something to do with Parrot vtable oddness

[17:16] <TimToady> yes, it's the fact that ; can behave as a language change, such that everything following the ; is logically a subparse of what came before

[17:16] <TimToady> semicolons are sort of a legal fiction of "all statements are created equal"

[17:16] <jnthn> nqp: class EEK {method Numeric() is parrot_vtable('get_integer') {return 3}}; my $a:= EEK.new(); say(+$a);

[17:16] <p6eval> nqp: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤␤current instr.: 'Numeric' pc 3370 (src/stage2/gen/NQPCORE.setting.pir:1584) (src/stage2/NQPCORE.setting:171)␤»

[17:16] <TimToady> but declarations are more equal than others

[17:16] <jnthn> nqp: class EEK {method Numeric() is parrot_vtable('get_number') {return 3}}; my $a:= EEK.new(); say(+$a);

[17:16] <p6eval> nqp: OUTPUT«3␤»

[17:17] <jnthn> [Coke]: Workaround is ^^

[17:18] * jnthn gets a fix for ignorecase literals in the LTMer

[17:20] <tadzik> .u ｣

[17:20] <phenny> U+FF63 HALFWIDTH RIGHT CORNER BRACKET (｣)

[17:20] <tadzik> Perl 6, exercising your fonts since 2001, or something

[17:20] <jnthn> tadzik: I did a Pod arsing patch earlier that fixed most of the test fails of Pod parsing on Windows.

[17:21] <jnthn> tadzik: Not everything passes yet but it's closer at least.

[17:21] *** kurahaupo joined
[17:21] <jnthn> Feel free to review it to make sure it's not insane.

[17:21] <jnthn> oh, *parsing. :)

[17:21] <Hor|zon> lol, the jury is still out on which is truer

[17:21] <Hor|zon> :P

[17:22] <jnthn> :D

[17:22] <dalek> nqp: 3629cd6 | jnthn++ | src/ (2 files):

[17:22] <dalek> nqp: Handle case-insensitive literals in LTM.

[17:22] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3629cd605c

[17:23] <tadzik> :)

[17:23] <tadzik> jnthn: I suppose it's alright :)

[17:24] <dalek> rakudo/nom: 90fad9b | jnthn++ | tools/build/NQP_REVISION:

[17:24] <dalek> rakudo/nom: NQP_REVISION bump for :i/LTM fix.

[17:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/90fad9bf9a

[17:25] <masak> jnthn: it totally should have been called "lexing and arsing". :P

[17:27] <jnthn> .oO( Butt all I did was a typo... )

[17:27] <Hor|zon> github needs perl6 highlighting

[17:27] *** mucker left
[17:27] <Hor|zon> wonder how to go about it...

[17:27] <masak> Perl 6 highlighting is Perl 6-complete.

[17:28] *** sudokode left
[17:28] <skids> .oO(but then instead of "bison" we'd have "arsen")

[17:28] <jnthn> If it manages a better approximation than a Perl 5 syntax highlighter it's a step forward :)

[17:30] <Hor|zon> so, this would be the project to patch https://github.com/github/linguist

[17:30] <Hor|zon> ugh ruby...

[17:31] <TimToady> just write a ruby backend for p6 :)

[17:33] <masak> How Difficult Can It Be?(TM)

[17:33] <TimToady> I see you stuck to ASCII there...

[17:33] *** sudokode joined
[17:34] <skids> I wonder whether a completely heuristic-based generic syntax highlighting algo could yield "good enough" results across a wide variety of languages.

[17:34] <masak> TimToady: ™

[17:35] <TimToady> skids: not without some kind of "am I getting warmer?" oracle

[17:35] <masak> au++ # App::Uni

[17:35] <Hor|zon> on files of a certain length I'm sure it's good enough

[17:35] * masak would like a generic "am I getting warmer?" oracle

[17:36] <skids> Well, using existing highlighters and codebases, one could train it to get close to those results.

[17:36] <TimToady> a heuristic highlighter will likely have a terrible time with Perl's term vs operator distinction

[17:37] <skids> How critical is getting that particular bit of highlighting correct?

[17:37] <TimToady> it's one thing to hide a namespace behind a sigil, it's another to hide a namespace behind a syntax node

[17:38] <TimToady> do you want to use a variable named 'x'?

[17:38] <TimToady> or 'gt', or 'cmp'?

[17:38] <skids> Well, the question is would I be thrown off horribly if x wasn't blue.

[17:39] <TimToady> and is / a division or the start of a regex?

[17:39] <jnthn> well, it's promotion too

[17:39] <jnthn> er, ww

[17:39] <TimToady> do you want a regex like / x y z / to highlight the x as if it were an infix?

[17:41] <Hor|zon> I don't think there's enough Perl 6 code in existence to train anything well enough either way

[17:41] <TimToady> just saying a purely heuristic algo is unlikly to figure this out; it's okay if a highlighter makes a few mistakes, but I doubt we can have one of those currently without giving it some strong hints about "warmer"

[17:43] <sirrobert> ooc: highlighter for what context?

[17:43] * TimToady imagines someone patient enough to learn Perl 6 merely by being rapped on the knuckles every time there's a syntax error (without seeing the message)

[17:43] <TimToady> sirrobert: github, I believe

[17:43] <sirrobert> TimToady: ah

[17:44] *** erkan left
[17:45] *** qazplm joined
[17:45] <skids> In an editor context, "warmer" feedback would be easier to implement.

[17:46] <TimToady> well, more likely you'd get "cooler" feedback, like a "Guess Again" button the user can hit

[17:47] *** fglock joined
[17:47] <TimToady> or a right-click menu item you can put on the offending passage

[17:48] <skids> Of course, introducing the human means the feedback could quite often be entirely wrong.

[17:48] <TimToady> otoh, you might end up with users trying to teach the parser how to parse syntactically incorrect code, which would also be madness

[17:48] <TimToady> I think we're in agreement there... :)

[17:48] <arnsholt> skids: Sounds like you want some kind of Markov model highlighterh (re: heuristic highlighter) =)

[17:48] <sirrobert> "Then I applied myself to the understanding of wisdom, and also of madness and folly, but I learned that this, too, is a chasing after the wind."

[17:49] *** kurahaupo left
[17:49] <TimToady> but a cord of three strands is not easily broken

[17:50] <sirrobert> huh, segfault.  I don't get those often

[17:50] <Hor|zon> seems linguist actually uses pygments for highlighting, which is python, and allows custom lexers, hoorah

[17:50] *** Chillance joined
[17:50] <TimToady> "a time to search, and a time to give up for lost"  There's parsing in a nutshell...

[17:52] <Hor|zon> ( noruby moresanity )++

[17:52] *** hoelzro|away is now known as hoelzro

[17:59] *** mucker joined
[18:02] *** fhelmberger left
[18:04] *** GlitchMr left
[18:12] <TimToady> felher: note that <{ EXPR }> will assume that you're trying to compiles a regex, so it won't work with a literal string that has metachars, if you just want string matching

[18:12] <TimToady> use $(EXPR) or "{EXPR}" to get string matching, depending on what rakudo implements

[18:12] <TimToady> at worst, you'll have to use a temp var

[18:14] <TimToady> nr: my $_ = "foo bar"; say m/ <{ $_ }> /

[18:14] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Potential difficulties:␤  Useless redeclaration of variable $_ (see  line 0) at /tmp/5L1LqSVnZV line 1:␤------> my $_ ⏏= "foo bar"; say m/ <{ $_ }> /␤␤Match()␤»

[18:14] <p6eval> ..rakudo 7731d2: OUTPUT«===SORRY!===␤Redeclaration of symbol $_␤at /tmp/p8_BfrCztk:1␤»

[18:14] <TimToady> nr: $_ = "foo bar"; say m/ <{ $_ }> /

[18:14] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Match()␤»

[18:14] <p6eval> ..rakudo 7731d2: OUTPUT«#<failed match>␤»

[18:14] <TimToady> nr: $_ = "foo bar"; say m/ "{ $_ }" /

[18:15] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«#<match from(0) to(7) text(foo bar) pos([].list) named({}.hash)>␤»

[18:15] <p6eval> ..rakudo 7731d2: OUTPUT«Null PMC access in find_method('Stringy')␤  in regex  at /tmp/8YLkZPevlM:1␤  in method match at src/gen/CORE.setting:4105␤  in block  at /tmp/8YLkZPevlM:1␤␤»

[18:15] <TimToady> ooh, rakudobug

[18:15] <TimToady> nr: $_ = "foo bar"; say m/ $( $_ ) /

[18:15] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«#<match from(0) to(7) text(foo bar) pos([].list) named({}.hash)>␤»

[18:15] <p6eval> ..rakudo 7731d2: OUTPUT«#<failed match>␤»

[18:15] <TimToady> and another :)

[18:16] <TimToady> felher: looks like your best bet is a temp scalar for now

[18:17] <TimToady> nr: my $x = "foo bar"; say m/ "{ $x }" /

[18:17] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Unhandled exception: Unable to resolve method match in type Any␤  at /tmp/MNJtdv2eHy line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4212 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4213 (module-CORE @ 579) ␤  at /home/…

[18:17] <p6eval> ..rakudo 90fad9: OUTPUT«No such method 'match' for invocant of type 'Any'␤  in block  at /tmp/JqBUydpkuI:1␤␤»

[18:18] * masak submits rakudobug

[18:18] <TimToady> nr: my $x = "foo bar"; $_ = $x; say m/ "{ $x }" /

[18:18] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«#<match from(0) to(7) text(foo bar) pos([].list) named({}.hash)>␤»

[18:18] <p6eval> ..rakudo 90fad9: OUTPUT«｢foo bar｣␤␤»

[18:18] <TimToady> looks like m is clobbering $_

[18:18] <felher> TimToady: well, "{ $x.y }" seems to work for my purposes here.

[18:18] <felher> TimToady: thanks! I can't believe i didn't try  "{ }" :)

[18:18] <felher> TimToady++

[18:18] <TimToady> yes, the problem seems to be losing $_

[18:19] <TimToady> is probably desugaring m// to $_ ~~ // or some such

[18:19] <TimToady> except you'd think that'd still work

[18:19] <TimToady> nr: my $x = "foo bar"; $_ = $x; say m/ $( $x ) /

[18:20] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«#<match from(0) to(7) text(foo bar) pos([].list) named({}.hash)>␤»

[18:20] <p6eval> ..rakudo 90fad9: OUTPUT«#<failed match>␤»

[18:20] <TimToady> that one seems like an unrelated bug

[18:20] <TimToady> probably not parsing $() as a variable there

[18:21] <masak> nod

[18:21] <TimToady> nr: my $x = "foo bar"; $_ = $x; say m/ $( 1 2 ) /

[18:21] * masak submits rakudobug

[18:21] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Unable to parse argument list at /tmp/3VwM6MRlmY line 1:␤------> my $x = "foo bar"; $_ = $x; say m/ $(⏏ 1 2 ) /␤Couldn't find final ')'; gave up at /tmp/3VwM6MRlmY line 1:␤------> my $x = "foo bar"; $…

[18:21] <p6eval> ..rakudo 90fad9: OUTPUT«#<failed match>␤»

[18:21] <TimToady> yes, it thinks it's just $ and () separatelhy

[18:21] <sirrobert> All tests successful.

[18:21] <sirrobert> =)

[18:22] <TimToady> no more challenges in life, eh?

[18:22] <sirrobert> Challenge Accepted.  ;)

[18:25] *** mucker left
[18:25] *** mucker joined
[18:27] *** erkan joined
[18:27] *** erkan left
[18:27] *** erkan joined
[18:31] <sergot> hi o/

[18:31] <masak> sergocie! \o/

[18:32] <tadzik> hello :)

[18:32] <sergot> \o/ I'm back. :)

[18:32] <masak> welcome back \o/

[18:32] * masak .oO( I again come to here )

[18:33] <TimToady> \.\o\O(evolution)

[18:35] <TimToady> \.\o\O\.(revolution)

[18:38] *** vlixes left
[18:47] *** daxim left
[18:51] *** PacoAir left
[18:52] *** PacoAir joined
[18:53] <dalek> std: 8a3fdfd | larry++ | / (3 files):

[18:53] <dalek> std: remove LASTSTATE hack

[18:53] <dalek> std: review: https://github.com/perl6/std/commit/8a3fdfda43

[18:56] <dalek> std: a426055 | larry++ | boot/ (2 files):

[18:56] <dalek> std: rebootstrap

[18:56] <dalek> std: review: https://github.com/perl6/std/commit/a426055052

[19:16] *** fuleo2 left
[19:24] *** benabik left
[19:25] *** benabik joined
[19:26] *** PacoAir left
[19:26] *** PacoAir joined
[19:32] *** birdwindupbird joined
[19:34] <dalek> nqp: a98083d | jnthn++ | src/QAST/Operations.nqp:

[19:34] <dalek> nqp: Map nqp::rebless => pir::change_type.

[19:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a98083dd09

[19:34] <dalek> nqp: 5fab963 | jnthn++ | src/ops/nqp.ops:

[19:34] <dalek> nqp: Ensure reblessing to the same type is cheap.

[19:34] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5fab9631f6

[19:38] <jnthn> star: { use Grammar::Tracer; grammar Foo { token TOP { ^ abc $ } } }; grammar Bar { token TOP { ^ abc $ } }; Foo.parse('abc'); Bar.parse('abc');

[19:38] <p6eval> star 2012.07: OUTPUT«TOP␤* [37;42mMATCH "abc"␤TOP␤* [37;42mMATCH "abc"␤»

[19:38] *** daxim joined
[19:42] *** SamuraiJack_ left
[19:43] <dalek> rakudo/nom: 670363b | jnthn++ | tools/build/NQP_REVISION:

[19:43] <dalek> rakudo/nom: Bump NQP_REVISION to get nqp::rebless.

[19:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/670363b4b5

[19:43] <dalek> rakudo/nom: 0d7f83c | jnthn++ | src/Perl6/ (2 files):

[19:43] <dalek> rakudo/nom: Use nqp::rebless in a couple of places.

[19:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0d7f83ccf9

[19:43] <dalek> rakudo/nom: dbd8130 | jnthn++ | src/Perl6/Grammar.pm:

[19:43] <dalek> rakudo/nom: Localize %*LANG and %*HOW in statementlist.

[19:43] <dalek> rakudo/nom: 

[19:43] <dalek> rakudo/nom: This means that custom meta-objects really do only apply in the lexical

[19:43] <dalek> rakudo/nom: scope that they are imported into.

[19:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dbd8130e83

[19:43] <dalek> rakudo/nom: 919d967 | jnthn++ | src/Perl6/Grammar.pm:

[19:43] <dalek> rakudo/nom: Apply any %*LANG<MAIN> tweaks to statements.

[19:48] *** orafu joined
[19:49] *** supernovus joined
[19:51] <supernovus> Is there any interest in an indexOf type method being added to Array ?  Concept @c.index-of($a); # if $a is found in @c, its index position is returned. Otherwise False is returned.

[19:51] <tadzik> we have is-prime, I don't see why we wouldn't want index-of :>

[19:52] <FROGGS> ya, I use that often in PHP and always missed it in Perl

[19:52] <sirrobert> supernovus:  I'd use it.

[19:52] *** fglock left
[19:53] <daxim> its doc should come with an admonishment to use a hash instead

[19:53] *** mucker left
[19:54] <sirrobert> hashes are interesting because they're less flexible than arrays of pairs

[19:54] *** fgomez left
[19:55] <sirrobert> I recently had a good use case for an array of pairs, but a hash wouldn't work. 

[19:55] <sirrobert> (though I would have liked to use a hash =)

[19:55] <flussence> well there's .first, maybe .index-of should be called .first-index

[19:56] <supernovus> daxim: there are times when it is very useful to be looking through an Array for a certain object. In the current case I have come across this, the nodes of an XML element are stored in @.nodes. I want to be able to do a $xml.insert-before($existing-node, $new-node); without having to know the position of $existing-node before hand. For this case I've written my own lookup function, but this is a common enough feature, it's in Jav

[19:56] <supernovus> ascript 1.5, PHP, etc.

[19:56] <sirrobert> flussence: makes sense to me

[19:56] *** fgomez joined
[19:57] <diakopter> which type of equals would index-of use?

[19:57] <sirrobert> eqv

[19:57] <sirrobert> ?

[19:58] <supernovus> What is the difference between eqv and === ? My current code is using === but the basic idea is to find the same object.

[19:59] <sirrobert> r: {a => 1, b=>{c=>2}} ===  {a => 1, b=>{c=>2}}

[19:59] <p6eval> rakudo 90fad9:  ( no output )

[19:59] <sirrobert> r:  {a => 1, b=>{c=>2}} eqv  {a => 1, b=>{c=>2}}

[19:59] <p6eval> rakudo 90fad9:  ( no output )

[19:59] <sirrobert> r: say {a => 1, b=>{c=>2}} ===  {a => 1, b=>{c=>2}}

[19:59] <p6eval> rakudo 90fad9: OUTPUT«False␤»

[19:59] <sirrobert> r:  say {a => 1, b=>{c=>2}} eqv  {a => 1, b=>{c=>2}}

[19:59] <p6eval> rakudo 90fad9: OUTPUT«True␤»

[20:00] <diakopter> may e index-of could optionally take a comparator WhateverCode

[20:00] <TimToady> maybe it could just take a smartmatch like it oughta

[20:00] <TimToady> then you can say * === or * eqv if you wanna

[20:01] <sirrobert> TimToady:  how would that work for this...

[20:01] <sirrobert> r: say {a => 1, b=>{c=>2}} ~~ {a => 1, b=>{c=>2}}

[20:01] <p6eval> rakudo 90fad9: OUTPUT«False␤»

[20:01] <sirrobert> syntactically, I mean

[20:01] <dalek> std: cda80a9 | jnthn++ | CursorBase.pmc:

[20:01] <dalek> std: Couple of tabs => spaces, to deconfuse the reader.

[20:01] <dalek> std: review: https://github.com/perl6/std/commit/cda80a951e

[20:02] <TimToady> r: say {a => 1, b=>{c=>2}} ~~ (* eqv {a => 1, b=>{c=>2}})

[20:02] <p6eval> rakudo 90fad9: OUTPUT«True␤»

[20:02] <sirrobert> I didn't know you could do that

[20:02] <sirrobert> cool

[20:02] <TimToady> r: say {a => 1, b=>{c=>2}} ~~ (* === {a => 1, b=>{c=>2}})

[20:02] <p6eval> rakudo 90fad9: OUTPUT«False␤»

[20:03] <sirrobert> so it's comparing the first hash to an expression of equivalence?

[20:03] <sirrobert> rather, applying it to

[20:04] <TimToady> it's right there at S03:3593

[20:05] <sirrobert> thanks (I consume the specs in pieces sorted by relevance and filtered by awareness =)

[20:07] <diakopter> i eat the S like a cow

[20:08] <supernovus> Okay, that's pretty cool. Using first-index($a); will use default smart matcher semantics, and first-index((* === $a)); will use === semantics (via the smart matcher operator inside first-index())

[20:08] * skids wonders what's so horrible about @a.pairs.grep({ $_.value op $thingy })>>.key[0];

[20:09] <TimToady> why do all that extra work when .first().key will work

[20:09] <sirrobert> skids: http://xkcd.com/378/

[20:10] <supernovus> skids: well for one, compared to @a.first-index($a); that's damn ugly and more boiler plate than should be needed for a simple operation.

[20:10] <TimToady> @a.pairs.first($a).key is not much longer

[20:11] <skids> Well, how ugly is this going to be after allowing someone to express which op to use?

[20:11] <sirrobert> the cognitive load is a fair bit higher =)

[20:11] *** fgomez left
[20:12] <TimToady> in fact, the .pairs.first is exactly same length as .first-index, so the only difference is the .key

[20:12] <supernovus> skids: @a.first-index((* === $a));

[20:12] <sirrobert> supernovus:  are the inside () needed? =)

[20:12] <sirrobert> would @a.first-index(*===$a) work?

[20:12] <TimToady> well, and the need to do *.value in there instead of *

[20:12] <supernovus> sirrobert: nope, I just tried it without them and it works fine

[20:13] <TimToady> might be worth it to save both a .key and a .value

[20:13] <sirrobert> supernovus: nice

[20:13] <diakopter> which equals does .first use

[20:13] <supernovus> @a.first-index(* === $a) will work fine

[20:13] <TimToady> diakopter: if it doesn't use smartmatch, it's a bug

[20:13] <sirrobert> TimToady:  why use a *.value?

[20:14] <sirrobert> TimToady: what does that mean in array context?

[20:14] <TimToady> because a .pair won't === its value

[20:14] <[Coke]> jnthn++ #workarounds

[20:14] <supernovus> sirrobert: for the .pair usage you need *.value because * is referring to the Pair object itself.

[20:15] <sirrobert> ah, got it... in the case of an array of pairs

[20:15] <TimToady> list of pairs, but yeah

[20:15] <supernovus> I'd like to implement first-index() using a plain old loop() and see if there is any speed difference between that technique and the .pairs.first technique.

[20:15] <skids> .oO(we should decide now how to punish the first person to ask for ".second")

[20:16] <TimToady> right now loop will tend to beat anything else in speed, because our (non-)loop optimizations suck

[20:17] <TimToady> no, no, we punish the second person to ask for .second

[20:18] <diakopter> heh

[20:18] <supernovus> TimToady: Ah, as my library-specific version is using a loop() and just returning on the first successful match, which should be fairly fast.

[20:18] <jnthn> How does it know what to loop up to?

[20:18] <sirrobert> @a.nth(3, $a);    ;)

[20:18] <dalek> rakudo/nom: 14e575b | jnthn++ | docs/ChangeLog:

[20:18] <dalek> rakudo/nom: Update ChangeLog.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/14e575b607

[20:19] <jnthn> (If the answer is ".elems" or something, then it won't work out well with laziness)

[20:19] <TimToady> .[0] // last works pretty well, last I checked

[20:20] <supernovus> jnthn: on my library specific implementation it looks like: loop (my $i=0; $i < @.nodes.elems; $i++)

[20:20] <TimToady> 'course, if the list contains undefs, that wouldn't be exactly right...

[20:20] <jnthn> supernovus: Yeah, we shouldn't put something like that into CORE

[20:20] *** PacoAir left
[20:20] <jnthn> supernovus: 'cus the moment it hits a lazy list it explodes

[20:20] <jnthn> Also because we can use a native int 

[20:20] <TimToady> you'd want something more like .gimme(1)

[20:21] <supernovus> jnthn: good point. I hadn't thought of lazy lists in this use case. My current implementation is better left to the library specific use.

[20:21] *** grondilu joined
[20:22] <jnthn> supernovus: Well, if your use case won't have infinite lists you're probably just fine :)

[20:22] <TimToady> of course, if you know the list is already reified, that's the fastest way to get through it

[20:23] <TimToady> or the fastest way through the reified bits, if partially reified

[20:23] <TimToady> so maybe we want something like .elems that tells us how much is reified, so we can just batch that much o fit

[20:24] <TimToady> of it, even

[20:24] <supernovus> Well, I guess @c.pairs.first(*.value === $b).key;  is the best way to do it currently as a generic feature. For my library, I'll stick with the specialized version, as the number of elements in @.nodes is known up front (and if an XML document has an infinite number of nodes in it, there's a bigger problem than my library...)

[20:24] *** grondilu left
[20:24] <TimToady> you'd like the generic form to optimize itself into the fast form whenever possible

[20:25] <jnthn> TimToady: I think Rakudo's list impl may well be doing something like that already. It certainly has a reifified part and gimme will return right away when it can.

[20:27] *** birdwindupbird left
[20:29] *** birdwindupbird joined
[20:32] <diakopter> r: say $_!X::a

[20:32] <p6eval> rakudo 919d96: OUTPUT«===SORRY!===␤Method 'is_trusted' not found for invocant of class 'Perl6::Metamodel::PackageHOW'␤»

[20:33] <jnthn> hm, a bit lta.

[20:34] <jnthn> A package can't have methods, so it can't trust, so a private method call on one makes no sense.

[20:37] *** FROGGS left
[20:38] *** flightrecorder left
[20:38] *** kurahaupo joined
[20:43] * masak submits rakudobug

[20:45] <masak> good night, #perl6

[20:45] <TimToady> o/

[20:45] <sirrobert> wave

[20:45] <supernovus> good night masak!

[20:46] <jnthn> 'night, masak

[20:46] <[Coke]> can someone comment on whether https://rt.perl.org/rt3/Ticket/Display.html?id=74946 is an actual bug or a misunderstanding?

[20:46] <dalek> rakudo/nom: 2fca74a | jnthn++ | src/Perl6/Actions.pm:

[20:46] <dalek> rakudo/nom: Don't explode over missing is_trusted; diakopter++.

[20:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2fca74a1aa

[20:47] *** _edwin joined
[20:47] <sirrobert> what is this doing:

[20:47] <sirrobert> r: "foo" ~~~~~~~~ /f/

[20:47] <p6eval> rakudo 919d96:  ( no output )

[20:47] <sirrobert> r: say "foo" ~~~~~~~~ /f/

[20:47] <jnthn> Waving.

[20:47] <p6eval> rakudo 919d96: OUTPUT«False␤»

[20:47] <sirrobert> heh

[20:47] <jnthn> std: "foo" ~~~~~~~~ /f/

[20:47] <p6eval> std cda80a9: OUTPUT«===SORRY!===␤Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/Q3s3c_LNQe line 1:␤------> "foo" ~~~~⏏~~~~ /f/␤Parse failed␤FAILED 00:00 42m␤»…

[20:47] <sirrobert> r: say "foo" ~~~~~ /f/

[20:47] <p6eval> rakudo 919d96: OUTPUT«False␤»

[20:47] <sirrobert> r: say "foo" ~~~~~~~~~~~~~~~~~~~~~~~~~~ /f/

[20:48] <p6eval> rakudo 919d96: OUTPUT«False␤»

[20:48] <jnthn> It's parsed as

[20:48] <_edwin> hi perl6ers!

[20:48] <jnthn> "foo" ~~ (~ ~ ~ ~ ~ ~ /f/)

[20:48] <jnthn> I suspect

[20:48] <jnthn> hi _edwin 

[20:48] <sirrobert> what is a single tilde?

[20:48] <_edwin> rn: class Foo { has @.bytes of int8; }

[20:48] <sirrobert> hi _edwin

[20:48] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/oh8SjnnfK2 line 1:␤------> class Foo { has @.bytes ⏏of int8; }␤␤Parse failed␤␤»

[20:48] <p6eval> ..rakudo 919d96: OUTPUT«===SORRY!===␤Cannot call 'trait_mod:<of>'; none of these signatures match:␤:(Routine:D $target, Mu:U $type)␤:(Mu:U $target, Mu:U $type)␤␤at /tmp/FGp09pW0sv:1␤»

[20:48] <jnthn> sirrobert: stringify

[20:48] <sirrobert> jnthn: heh oh yeah

[20:48] <_edwin> hm, locally I get Null PMC access from rakudo

[20:48] <jnthn> _edwin: We don't provide int8 yet

[20:49] <_edwin> rn: my @bytes of int8;

[20:49] <p6eval> rakudo 919d96:  ( no output )

[20:49] <p6eval> ..niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/LnHED8x7E_ line 1:␤------> my @bytes ⏏of int8;␤␤Parse failed␤␤»

[20:49] <TimToady> rn: my @bytes is Array of int8;

[20:49] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Trait name not available on variables at /tmp/qvPQvxuVOK line 1:␤------> my @bytes is Array ⏏of int8;␤␤Two terms in a row at /tmp/qvPQvxuVOK line 1:␤------> my @bytes is Array ⏏of int8;␤…

[20:49] <p6eval> ..rakudo 919d96:  ( no output )

[20:50] <_edwin> jnthn, in attributes, or generally?

[20:50] <moritz> generally

[20:50] <TimToady> 'of' only modifies a type on the left

[20:50] <TimToady> iirc

[20:50] <jnthn> [Coke]: I think the ticket is right, off hand.

[20:51] <TimToady> std: my $foo of int8;

[20:51] <p6eval> std cda80a9: OUTPUT«ok 00:00 42m␤»

[20:51] <TimToady> I guess STD doesn't mind it

[20:51] <_edwin> I thought in case of @ the default type is Array and that would be modified by the "of"

[20:51] <jnthn> I think Rakudo doesn't mind it syntactically, it just hasn't much idea about variable traits.

[20:52] <jnthn> _edwin: No, the "of" would be modifying what the array contains.

[20:52] <TimToady> nr: my @array of Int;

[20:52] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Trait of not available on variables at /tmp/ryaFM7fZxy line 1:␤------> my @array of Int⏏;␤␤Potential difficulties:␤  @array is declared but not used at /tmp/ryaFM7fZxy line 1:␤------> my ⏏@a…

[20:52] <p6eval> ..rakudo 919d96:  ( no output )

[20:53] <TimToady> should mean the same as my Int @array, or my @array returns Int

[20:53] <_edwin> rn: my Int @array;

[20:53] <p6eval> rakudo 919d96:  ( no output )

[20:53] <p6eval> ..niecza v22-13-g0d2a99e: OUTPUT«Potential difficulties:␤  @array is declared but not used at /tmp/BeRH8BSe4e line 1:␤------> my Int ⏏@array;␤␤»

[20:53] <TimToady> or my @array[* --> Int]

[20:53] <TimToady> (maybe)

[20:53] <jnthn> (maybe) ;)

[20:53] <jnthn> Agree with the others though :)

[20:54] <_edwin> ok, I can live with my Int @array for the time being, thanks

[20:55] <_edwin> but I'd like to reproduce that Null PMC access...

[20:55] <TimToady> eval my %a = ('a',1,'b',2); $a{a} = delete $a{a}; print join ' ', %a

[20:55] <buubot_backup> TimToady: a 1 b 21

[20:56] <TimToady> [Coke]: perl 5 agrees

[20:56] <_edwin> seems to happen only in the REPL

[20:56] <jnthn> _edwin: If you can make it consistently explode in the repl, please file it in RT.

[20:57] *** hash_table left
[20:57] <[Coke]> TimToady: why is it "b 21" ? 

[20:57] <TimToady> it's b 2

[20:57] <TimToady> 1 is the final return value

[20:57] <TimToady> eval 42

[20:57] <buubot_backup> TimToady: 42

[20:58] <TimToady> eval print "42"

[20:58] <buubot_backup> TimToady: 421

[20:58] <[Coke]> danke.

[20:58] <TimToady> not terribly well distinguished, admittedly

[20:58] *** aindilis left
[20:59] <TimToady> eval say 42

[20:59] <buubot_backup> TimToady: ERROR: syntax error at (eval 20) line 1, near "say 42" 

[20:59] <TimToady> buu, hiss!

[20:59] <sorear> eval $[

[20:59] <buubot_backup> sorear: ERROR: Can't locate arybase.pm in @INC (@INC contains:) at (eval 20) line 2. BEGIN failed--compilation aborted at (eval 20) line 2. 

[20:59] <sorear> eval $]

[20:59] <buubot_backup> sorear: 5.016000

[20:59] <sorear> eval use 5.016; say 42

[20:59] <buubot_backup> sorear: 42 1

[21:00] *** benabik left
[21:05] * _edwin reported https://rt.perl.org/rt3/Public/Bug/Display.html?id=115310

[21:07] *** skids left
[21:11] *** birdwindupbird left
[21:11] <_edwin> std: s[0]*]

[21:11] <p6eval> std cda80a9: OUTPUT«ok 00:00 43m␤»

[21:12] <_edwin> does this really mean something, or is it a stdbug (as diakopter suggested iirc)

[21:12] <jnthn> It's a cute form of s/0/*/ :)

[21:13] <_edwin> I don't see how

[21:13] <jnthn> std: s[0][*]

[21:13] <p6eval> std cda80a9: OUTPUT«===SORRY!===␤Unsupported use of brackets around replacement; in Perl 6 please use assignment syntax at /tmp/kvXsCWRdcH line 1:␤------> s[0]⏏[*]␤Parse failed␤FAILED 00:00 42m␤»

[21:13] <jnthn> I suspect it should produce that. :)

[21:14] *** bruges left
[21:15] *** alester left
[21:15] *** bruges joined
[21:15] <_edwin> std: sub s { ... }; s[0]

[21:15] <p6eval> std cda80a9: OUTPUT«===SORRY!===␤Missing assignment operator at /tmp/veNSKfjzmx line 1 (EOF):␤------> sub s { ... }; s[0]⏏<EOL>␤Parse failed␤FAILED 00:00 43m␤»

[21:15] <sorear> n: s[0]*]

[21:15] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Malformed assignment operator at /tmp/yi7TeX3YbQ line 1:␤------> s[0]*⏏]␤␤Parse failed␤␤»

[21:18] *** kaare_ left
[21:18] <_edwin> std: sub s { ... }; s()

[21:18] <p6eval> std cda80a9: OUTPUT«ok 00:00 42m␤»

[21:18] <_edwin> std: sub s { ... }; s();

[21:19] <p6eval> std cda80a9: OUTPUT«ok 00:00 42m␤»

[21:19] <diakopter> r: say $_."{ return 55 }"()

[21:19] <p6eval> rakudo 2fca74:  ( no output )

[21:19] <_edwin> huh? I get different behavior using private messages

[21:20] <diakopter> n: say $_."{ return 55 }"()

[21:20] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Unhandled exception: Illegal control operator: return␤  at /tmp/UiO_klH9Lq line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4212 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4213 (module-CORE @ 579) ␤  at /home/p6eval/nie…

[21:21] <_edwin> std: sub s { ... }; s();

[21:21] <p6eval> std cda80a9: OUTPUT«===SORRY!===␤Confused at /tmp/ajeD8vghxk line 1:␤------> sub s { ...⏏ }; s();␤    expecting any of:␤   POST␤   infix or meta-infix␤    infixed function␤       postcircumfix␤  postfix␤        postfix_prefix_meta_operator␤   postop␤ statement

[21:21] <p6eval> ..modifier loo…

[21:22] *** aharoni left
[21:22] * _edwin no see no difference

[21:22] *** rindolf left
[21:25] *** rindolf joined
[21:25] <diakopter> n: s[a]*=]

[21:25] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Unhandled exception: Unable to resolve method subst in type Any␤  at /tmp/ADMJ6D7ql6 line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4212 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4213 (module-CORE @ 579) ␤  at /home/…

[21:25] <diakopter> sorear: ^^

[21:25] <supernovus> As fun as the name Exemel is for my library, would its purpose be more easily obvious if I renamed it XML?

[21:26] <sorear> yes, a bit

[21:26] <diakopter> it requires the equals sign

[21:26] <sorear> n: ]

[21:26] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«===SORRY!===␤␤Unexpected closing bracket at /tmp/CaZtbHQlIh line 1:␤------> <BOL>⏏]␤␤Parse failed␤␤»

[21:28] *** benabik joined
[21:29] *** benabik left
[21:29] <_edwin> oh, I somehow got a no-break space in there. that makes the difference

[21:29] <_edwin> evil character

[21:39] <supernovus> Okay, as of now, Exemel is reborn as XML (although the github project will forever be 'exemel').  No more word-plays for my project names, I promise ;-)

[21:40] *** mtk left
[21:41] <sorear> supernovus: I do not get the word play there

[21:41] <_edwin> what is the difference between (*%s) and (**%s)? did not find it in the spec

[21:42] <supernovus> sorear: the original name was pronounced the same as saying the letters X M L.

[21:42] <diakopter> sorear: any idea why it parses with the equals sign but not without?

[21:44] <sorear> diakopter: no

[21:44] *** spider-mario left
[21:45] <jnthn> sleep &

[21:45] <sorear> night

[21:49] *** supernovus left
[21:49] <_edwin> nr: sub foo(Pair *@pairs) {}; foo(1 => 2);

[21:49] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«Potential difficulties:␤  @pairs is declared but not used at /tmp/027ac7pp2t line 1:␤------> sub foo(Pair *⏏@pairs) {}; foo(1 => 2);␤␤»

[21:49] <p6eval> ..rakudo 2fca74: OUTPUT«Nominal type check failed for parameter '@pairs'; expected Positional but got Array instead␤  in sub foo at /tmp/ip2Sl_zZ_k:1␤  in block  at /tmp/ip2Sl_zZ_k:1␤␤»

[21:49] <_edwin> nr: sub foo(Pair *@pairs) { say @pairs }; foo(1 => 2);

[21:49] <p6eval> niecza v22-13-g0d2a99e: OUTPUT«1 => 2␤»

[21:49] <p6eval> ..rakudo 2fca74: OUTPUT«Nominal type check failed for parameter '@pairs'; expected Positional but got Array instead␤  in sub foo at /tmp/YTpkftNtWo:1␤  in block  at /tmp/YTpkftNtWo:1␤␤»

[21:49] <_edwin> rakudobug?

[21:50] <sorear> _edwin: yes

[21:50] <sorear> I have no idea what's going on but that error message is ridiculous

[21:51] *** att left
[21:51] <_edwin> as Array does Positional, right?

[21:52] *** kst left
[21:52] <sorear> exactly

[21:53] *** kst joined
[21:54] <_edwin> seems to be a general problem with typed slurpies

[21:55] <_edwin> not only slurpy @, just typed @ seems enough

[21:58] *** fgomez joined
[22:03] *** Chillance left
[22:04] <_edwin> oh, i duplicated a masaked bug

[22:09] *** hoelzro is now known as hoelzro|away

[22:11] *** sjohnson left
[22:15] *** fgomez left
[22:15] *** hash_table joined
[22:16] * _edwin updated https://rt.perl.org/rt3/Ticket/Display.html?id=113964

[22:18] *** _edwin left
[22:19] *** rindolf left
[22:24] *** whiteknight joined
[22:33] *** stopbit left
[22:33] *** benabik joined
[22:35] *** MayDaniel left
[22:35] *** fgomez joined
[22:40] *** skids joined
[22:46] *** steampunkey joined
[22:46] *** steampunkey left
[22:47] *** paxcoder joined
[22:47] <rjbs-> How's Perl 6 going? :)

[22:48] <rjbs-> What's awesome lately?

[22:48] <paxcoder> rjbs-, i reckon better than python 3 ;-P

[22:48] *** rjbs- is now known as rjbs

[22:48] <paxcoder> rjbs-, rules, check em out

[22:48] *** rjbs left
[22:48] *** rjbs joined
[22:48] <rjbs> Have they gotten much cooler lately?

[22:48] <paxcoder> rjbs, i know regexes did

[22:48] <rjbs> I should update my local rakudo build.  I'm sure it's ages out of date.

[22:49] <rjbs> Orrr.... maybe it doesn't even exist anymore.

[22:49] <diakopter> <blink>

[22:50] <sjn> rjbs: $ cpanm Rakudo::Star

[22:50] <sjn> works fine. :)

[22:50] <paxcoder> shun the rakudo non-haver shuuuuun.

[22:50] <rjbs> sjn: nice.

[22:50] * sjn blames mst

[22:50] <rjbs> Yeah, I remember seeing that, now that you mention it.

[22:51] <paxcoder> jk, i don't have it. heck, i don't know perl. any perl. i just reinvented the whole rules thing (not implemented) so i thought i'd see how you did them.

[22:52] <paxcoder> rjbs, when you exec some code in ?{} in a regex, can it access the FSM somehow?

[22:53] <paxcoder> umm, anyone, not just rjbs

[22:53] <diakopter> what FSM

[22:53] <rjbs> In p5?  What specifically are you trying to do?

[22:53] <paxcoder> diakopter, the one that matches the input against the regex

[22:54] <paxcoder> rjbs, p6 (any, really)

[22:54] <diakopter> <facedesk>

[22:54] <paxcoder> rjbs, informative. as i said, i don't code perl.

[22:54] * rjbs can't help in p6.

[22:54] <paxcoder> diakopter, problem?

[22:54] <diakopter> not anymore :P

[22:54] <paxcoder> diakopter, you just looked up FSM, didn't you?

[22:55] <diakopter> please don't pick a fight.. I was merely pointing out that there might not be a FSM

[22:55] *** japhb_ joined
[22:56] <paxcoder> diakopter, well, can it access state of whatever it is that does and does the matching?

[22:56] <sorear> .oO( well, how else do you explain the trend in heights?) 

[22:57] <paxcoder> is this lang for registered users only?

[22:57] <paxcoder> *channel

[22:57] <diakopter> I hope not

[22:57] *** paxcoder is now known as perlOblivious

[22:57] <sorear> paxcoder: are you new here?

[22:57] <perlOblivious> that should help.

[22:58] <perlOblivious> sorear, as i've said before, i know no perl. so, very much so.

[22:58] <diakopter> the Perl 6 grammar implementations generally are recursive descent, with some NFA for optimization of patterns that are declarative

[22:59] <diakopter> user code makes it non-declarative, so code can't be run during the NFA

[23:00] <diakopter> Perl 5, I have no idea

[23:00] <diakopter> lol at "lang for registered users only"; that's cute :D

[23:00] <diakopter> (but no, the channel isn't either; it doesn't have the +i by its name here)

[23:00] <rjbs> Plenty such languages have existed! :)

[23:01] <perlOblivious> diakopter, what are "declarative patterns"?

[23:03] <diakopter> patterns that can be reduced to an automata. see the last occurence of 'declarative' in http://perlcabal.org/syn/S05.html

[23:03] <perlOblivious> i guess rules (which I reckon are like BNF) could be called declarative, using the definition which makes Prolog declarative programming (eg. pattern matching instead of controlling flow ith ifs and cases)

[23:03] <diakopter> *automaton

[23:04] <diakopter> *occurrence

[23:05] <diakopter> declarative portions don't cause side effects

[23:05] <diakopter> procedural ones do

[23:06] <perlOblivious> diakopter, right, but are you really saying rules cannot execute code? cannot a rule contain a regex which executes something in ?{} ?

[23:07] <diakopter> sure; it just can't be optimized to an NFA or participate in longest-token-matching

[23:08] <diakopter> (ltm, which you can read much about in that url above)

[23:11] <perlOblivious> let me make a paste to see what my question is.

[23:12] <sorear> perlOblivious: a rule which executes code does not produce a NFA.

[23:13] <perlOblivious> sorear, that's alright. but something has to process it.

[23:14] <sorear> perlOblivious: the rule is compiled directly into code to do the processing.  there is no runtime representation of the rule, it is simply bytecode or machine code

[23:14] <perlOblivious> sorear, hmm. i guess that would mean "no"

[23:15] <perlOblivious> the code executed cannot influence the matcher

[23:16] <diakopter> well, it can if the matcher changes its behavior based on external state modified by the code it runs

[23:17] <TimToady> this is starting to sound like a conversation where people are using different definitions for words

[23:17] <perlOblivious> diakopter, but how would it? it's predefined.

[23:18] <perlOblivious> let me finish writing that code snippet

[23:19] <diakopter> TimToady: words definitions conversation are using people sound different

[23:20] <diakopter> TimToady: also, it cannot be determined whether I know what I'm saying, nor whether I am accurate

[23:21] * TimToady puts diakopter into a Skinner box to see how he behaves.

[23:22] * TimToady hopes diakopter doesn't notice that it's really a Schrödinger box...

[23:28] <japhb_> That's one hell of a randomized negative stimulus

[23:33] <TimToady> well, it's a double-blind study, so if I tell diakopter he's in the control group, there's a 3/4 chance he'll believe me.  :)

[23:33] <perlOblivious> actually code is better :-/

[23:33] <perlOblivious> back to code

[23:36] *** tokuhiro_ joined
[23:37] *** thou left
[23:47] <perlOblivious> diakopter, here: http://paste.debian.net/plainh/9078fce9

[23:48] <perlOblivious> literate programming ;-)

[23:48] <perlOblivious> crap i forgot to decrement count

[23:49] <TimToady> perlOblivious: oh, we do that sort of thing by choosing which cursor to return

[23:49] <perlOblivious> http://paste.debian.net/plainh/fe39ddb7

[23:49] <perlOblivious> (just replaced n with count where it decrements)

[23:50] <perlOblivious> Timbus, you manipulate the matcher's cursor?

[23:50] <TimToady> or returning no cursors for failure

[23:50] <TimToady> no, cursors are immutable

[23:50] <perlOblivious> is cursor a pointer to the current char/group/etc?

[23:51] <TimToady> a cursor holds the current match state; if you advance the position, you just return a different cursor with the new position

[23:51] <TimToady> to fail, return ()

[23:51] <TimToady> in STD at least, you can return a lazy list of cursors to control future backtracking points

[23:52] <perlOblivious> Timbus, () is like nil or smth?

[23:52] <perlOblivious> how is the cursor passed into the function? how do you return cursor-1?

[23:52] <TimToady> yes, just an empty list

[23:52] *** armitage81 joined
[23:53] <diakopter> perlOblivious: TimToady, not Timbus :P

[23:53] <TimToady> same way, in fact the <after FOO> assertion matches backward in just that way

[23:53] <perlOblivious> Timbus, sry, i have a crappy complete, and am used to 3 chars + <tab>

[23:53] <Timbus> asdfasd

[23:53] <diakopter> :)

[23:54] <TimToady> there are many people on this channel (hi lurkers!)

[23:54] <TimToady> not that Timbus++ is a lurker

[23:54] <Timbus> :o

[23:54] <Timbus> well i mostly am

[23:55] <perlOblivious> Timbus, i'm sorry, i'm trying to get it...

[23:55] <perlOblivious> grr. TimToady *

[23:56] <perlOblivious> Timbus, do you just return -1 to go one position back? If not, where is the cursor stored? Is it implicitly passed, what's its name?

[23:56] * perlOblivious facepalms

[23:56] <perlOblivious> TimToady, ^

[23:57] *** sjohnson joined
[23:57] *** sjohnson left
[23:57] *** sjohnson joined
[23:58] <perlOblivious> TimToady, can you write me a function that will just advance the cursor to skip the next char (effectively making it a '.') ?

[23:58] <TimToady> if $¢ points to the current cursor, then movement backwards is $¢ = $¢.cursor_fresh($¢.pos - 1)

[23:58] <TimToady> same thing, only with a +

[23:59] <perlOblivious> you must know that i don't know perl. so $􏿽xA2 is the matcher object or smth?

[23:59] <TimToady> there is no *the* matcher object; there are many

[23:59] <perlOblivious> or is there some special cursor entity in perl that i'm not aware of?

[23:59] <TimToady> we're talking perl 6 here; perl 5 is completely different

