[00:00] *** Chillance left
[00:02] <jlaire> p6: class C { method m() { <a b> } }; my @cs = C.new xx 3; say @cs.map({.m.list}).elems

[00:02] <p6eval> pugs, rakudo d9fd17: OUTPUT«6␤»

[00:02] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«3␤»

[00:02] <jlaire> :/

[00:03] *** eviltwin_b joined
[00:03] <jlaire> how to flatten a list of lists like that in niecza?

[00:03] *** geekosaur left
[00:03] *** eviltwin_b is now known as geekosaur

[00:06] *** dorlamm left
[00:06] <jlaire> found a workaround

[00:17] *** eviltwin_b joined
[00:17] *** geekosaur left
[00:17] *** eviltwin_b is now known as geekosaur

[00:17] *** sisar joined
[00:19] *** eviltwin_b joined
[00:19] *** geekosaur left
[00:19] *** eviltwin_b is now known as geekosaur

[00:22] *** fgomez left
[00:31] <Radvendii> what's the proper way to undefine something?

[00:31] *** fgomez joined
[00:32] <Radvendii> nom: my $a = null;

[00:32] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&null' called (line 1)␤»

[00:32] <Radvendii> nom: my $a = nil;

[00:32] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&nil' called (line 1)␤»

[00:32] <Radvendii> nom: my $a.undef

[00:32] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Confused␤at /tmp/8SZTzdweWd:1␤»

[00:33] <idlecuriosity> nom: my $a = Nil;

[00:33] <p6eval> rakudo d9fd17:  ( no output )

[00:33] <Radvendii> ah

[00:33] <Radvendii> thanks

[00:33] <idlecuriosity> np, I learnt it just now :)

[00:38] <Radvendii> hmm... that doesn't work for removing indicies of an array

[00:38] <Radvendii> nom: my @a = 1,2,3; @a[1]=Nil; @a;

[00:38] <p6eval> rakudo d9fd17:  ( no output )

[00:38] <Radvendii> nom: my @a = 1,2,3; @a[1]=Nil; say @a;

[00:38] <p6eval> rakudo d9fd17: OUTPUT«1  3␤»

[00:38] <Radvendii> nom: my @a = 1,2,3; @a[1]=Nil; say @a.perl;

[00:38] <p6eval> rakudo d9fd17: OUTPUT«Array.new(1, Nil, 3)␤»

[00:39] <Radvendii> nom: my @a = 1,2,3; @a.delete(1); say @a.perl;

[00:39] <p6eval> rakudo d9fd17: OUTPUT«Array.new(1, Any, 3)␤»

[00:39] <Radvendii> awww... really?

[00:39] <TimToady> are you trying to find splice()?

[00:40] <Radvendii> nom: my @a = 1,2,3; @a.splice(1); say @a.perl;

[00:40] <p6eval> rakudo d9fd17: OUTPUT«Array.new(1)␤»

[00:40] <Radvendii> huh?

[00:40] <Radvendii> I don't know, what's it do?

[00:41] <jlaire> nom: my @a = <a b c d e f>; @a.splice(3); say @a.perl

[00:41] <p6eval> rakudo d9fd17: OUTPUT«Array.new("a", "b", "c")␤»

[00:41] <Radvendii> I guess what i'm doing is simpler than i thought

[00:42] <sisar> Radvendii: here is splice in perl5 explained: http://szabgab.com/splice-to-slice-and-dice-arrays-in-perl.html You can easily figure it out in perl6 :)

[00:42] <Radvendii> i just want to clip off the last element of a list if it's Nil

[00:42] <Radvendii> that's easy enough

[00:43] <sorear> Radvendii: go read console_codes(4) or one of the 1e4 equivalent documents on the Web

[00:44] <Radvendii> oh, is that for the clear screen thing?

[00:44] <sorear> n: say <a b> xx 3

[00:44] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«a b a b a b␤»

[00:44] <sorear> Radvendii: clear screen, cursor positioning, colors, the workd

[00:45] <Radvendii> sweet!

[00:45] <Radvendii> thanks

[00:57] *** icwiener left
[00:57] *** scott__ joined
[01:01] *** replore_ joined
[01:04] *** geekosaur left
[01:05] *** geekosaur joined
[01:05] *** lestrrat left
[01:06] *** lestrrat joined
[01:10] *** tokuhirom left
[01:11] *** eviltwin_b joined
[01:11] *** geekosaur left
[01:11] *** eviltwin_b is now known as geekosaur

[01:16] *** sporous left
[01:16] *** replore_ left
[01:17] *** eviltwin_b joined
[01:17] *** geekosaur left
[01:17] *** eviltwin_b is now known as geekosaur

[01:21] *** sporous joined
[01:34] *** raiph joined
[01:34] *** eviltwin_b joined
[01:34] *** geekosaur left
[01:35] *** eviltwin_b is now known as geekosaur

[01:38] *** scott___ joined
[01:41] *** scott__ left
[01:43] *** scott___ left
[01:45] *** scott__ joined
[01:48] *** geekosaur left
[01:48] *** eviltwin_b joined
[01:49] *** eviltwin_b is now known as geekosaur

[01:56] *** whiteknight left
[01:59] *** geekosaur left
[01:59] *** eviltwin_b joined
[02:00] *** eviltwin_b is now known as geekosaur

[02:01] *** thou left
[02:09] *** Radvendii left
[02:10] *** eviltwin_b joined
[02:10] *** geekosaur left
[02:10] *** eviltwin_b is now known as geekosaur

[02:21] *** geekosaur left
[02:21] *** eviltwin_b joined
[02:22] *** eviltwin_b is now known as geekosaur

[02:23] *** geekosaur left
[02:23] *** eviltwin_b joined
[02:24] *** eviltwin_b is now known as geekosaur

[02:32] *** geekosaur left
[02:33] *** geekosaur joined
[02:37] *** eviltwin_b joined
[02:37] *** geekosaur left
[02:37] *** eviltwin_b is now known as geekosaur

[02:38] *** orafu left
[02:38] *** orafu joined
[02:39] *** eviltwin_b joined
[02:39] *** geekosaur left
[02:39] *** sftp_ left
[02:39] *** eviltwin_b is now known as geekosaur

[02:42] *** eviltwin_b joined
[02:42] *** geekosaur left
[02:42] *** eviltwin_b is now known as geekosaur

[02:44] *** sftp joined
[02:53] *** eviltwin_b joined
[02:53] *** geekosaur left
[02:53] *** eviltwin_b is now known as geekosaur

[03:04] *** envi_ joined
[03:04] *** crab2313 joined
[03:07] *** wolfman2000 joined
[03:11] *** alvis` joined
[03:11] *** eviltwin_b joined
[03:11] *** geekosaur left
[03:11] *** eviltwin_b is now known as geekosaur

[03:12] *** alvis left
[03:15] *** alc joined
[03:37] *** mikemol left
[03:38] *** mmol_saffron joined
[03:41] *** kaleem joined
[03:41] *** geekosaur left
[03:41] *** eviltwin_b joined
[03:41] *** eviltwin_b is now known as geekosaur

[03:45] *** ponbiki joined
[03:48] *** samurai2 joined
[03:49] *** samurai2 left
[03:52] *** alc left
[03:56] *** geekosaur left
[03:57] *** geekosaur joined
[04:07] *** mmol_saffron left
[04:26] *** crab2313 left
[04:38] *** MContagious joined
[04:48] *** alc joined
[04:50] *** sisar left
[04:56] *** alc left
[05:03] *** thou joined
[05:04] *** eviltwin_b joined
[05:04] *** geekosaur left
[05:04] *** eviltwin_b is now known as geekosaur

[05:08] *** ponbiki left
[05:10] *** alc joined
[05:12] *** alc left
[05:18] *** eviltwin_b joined
[05:18] *** geekosaur left
[05:19] *** geekosaur joined
[05:20] *** eviltwin_b left
[05:21] *** eviltwin_b joined
[05:21] *** geekosaur left
[05:21] *** eviltwin_b is now known as geekosaur

[05:23] *** fgomez left
[05:30] *** eviltwin_b joined
[05:30] *** geekosaur left
[05:31] *** eviltwin_b is now known as geekosaur

[05:35] *** geekosaur left
[05:35] *** NamelessTee joined
[05:37] *** geekosaur joined
[05:48] *** eviltwin_b joined
[05:48] *** geekosaur left
[05:48] *** eviltwin_b is now known as geekosaur

[06:06] *** eviltwin_b joined
[06:06] *** geekosaur left
[06:06] *** eviltwin_b is now known as geekosaur

[06:07] *** NamelessTee left
[06:15] *** wtw joined
[06:17] *** sisar joined
[06:18] *** sisar left
[06:18] *** sisar joined
[06:19] *** eviltwin_b joined
[06:19] *** geekosaur left
[06:19] *** eviltwin_b is now known as geekosaur

[06:21] *** eviltwin_b joined
[06:21] *** geekosaur left
[06:21] *** eviltwin_b is now known as geekosaur

[06:31] *** geekosaur left
[06:31] *** eviltwin_b joined
[06:32] *** geekosaur joined
[06:32] *** fhelmberger joined
[06:35] *** eviltwin_b left
[06:35] *** snearch joined
[06:38] *** geekosaur left
[06:42] *** geekosaur joined
[07:03] *** idlecuriosity left
[07:04] *** snearch left
[07:07] *** lestrrat left
[07:09] *** lestrrat joined
[07:16] *** xinming_ joined
[07:19] *** xinming left
[07:21] *** eviltwin_b joined
[07:21] *** geekosaur left
[07:22] *** eviltwin_b is now known as geekosaur

[07:39] <moritz> \o

[07:40] <moritz> jnthn: new problem: Pair isn't in BOOTSTRAP.pm, so I can't use Pair in Grammar.pm while compiling the setting :/

[07:41] <moritz> jnthn: and traits.pm does 'use Perl6::BOOTSTRAP'

[07:41] <moritz> hm, I might special-case empty import lists

[07:50] *** thelazydeveloper joined
[07:50] <moritz> that way seems simpler anyway

[08:14] *** fglock joined
[08:24] <jnthn> mornin'

[08:25] <tadzik> hello

[08:25] <jnthn> moritz: I don't think you should need import lists while compiling the setting.

[08:25] <jnthn> It only does whatever the default thing is.

[08:26] <moritz> right

[08:30] <moritz> jnthn: oh, and  'use Test :DEFAULT' produces DEFAULT => Mu

[08:30] <moritz> I guess it's the same bug as

[08:31] <moritz> r: sub f { return a => 5 }; say f.perl

[08:31] <p6eval> rakudo d9fd17: OUTPUT«"a" => Mu␤»

[08:31] *** fgomez joined
[08:32] *** fgomez left
[08:32] *** fgomez joined
[08:33] <jnthn> Huh, it shouldn't be producing a named parameter at all...

[08:33] <jnthn> That's the point of looking at EXPR...

[08:34] <moritz> well, I think it creates a proper Pair

[08:35] *** LylePerl left
[08:43] <moritz> nqp: sub f($x?) { say(nqp::defined($x)) }; f()

[08:43] <p6eval> nqp: OUTPUT«Unrecognized nqp:: opcode 'nqp::defined' at line 1, near ") }; f()"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22008 (src/stage2/gen/NQPHLL.pir:7047) (src/stage2/gen/NQPHLL.pm:329)␤»

[08:43] <moritz> nqp: sub f($x?) { say(pir::defined($x)) }; f()

[08:43] <p6eval> nqp: OUTPUT«0␤»

[08:43] <moritz> nqp: sub f($x?) { say(pir::defined($x)) }; f([])

[08:43] <p6eval> nqp: OUTPUT«1␤»

[08:48] *** daxim joined
[08:55] <dalek> rakudo/use-arglist: 6145974 | moritz++ | src/ (2 files):

[08:55] <dalek> rakudo/use-arglist: allow importing of tags

[08:55] <dalek> rakudo/use-arglist: 

[08:55] <dalek> rakudo/use-arglist: the default is not imported when an explicit tag is provided

[08:55] <dalek> rakudo/use-arglist: review: https://github.com/rakudo/rakudo/commit/6145974238

[08:57] *** birdwindupbird joined
[09:01] <jnthn> yay :)

[09:01] <tadzik> ooo

[09:02] <moritz> note that it currently does not complain about nonexisting tags

[09:02] <moritz> so you can write

[09:02] <moritz> use Test :NONE;

[09:02] <moritz> though I think you can achieve the same with    need Test;  anyway

[09:03] <tadzik> and it won't import anything, right?

[09:03] <jnthn> I'm not sure the spec says whether it should complain or not.

[09:03] <moritz> right

[09:03] <jnthn> At least, I don't recall S11 indicating as such.

[09:03] <moritz> jnthn: to me, importing looks more like a sub call than a method call, so by extension I think it should complain

[09:04] <jnthn> Hmm, I'd not thunk of it that way :)

[09:08] <tadzik> ha, clever

[09:09] *** geekosaur left
[09:09] <tadzik> although I see it more like obj.do_something_for_me than obj.?do_something_for_me

[09:09] <tadzik> so the conclusion is the same

[09:09] <jnthn> Note that there's various other bits of magic in arglist stuff.

[09:10] <moritz> well, TimToady++'s ruling was that importing calls a macro in the loaded module

[09:10] <moritz> so until our macros are a bit more capable, we'll just do an approximation anyway

[09:11] <jnthn> Of note, :MANDATORY

[09:11] *** geekosaur joined
[09:11] <jnthn> a...macro?

[09:12] <moritz> yes

[09:12] <moritz> because it has the option to do all the intersting stuff that aliasing routines can't do

[09:12] <moritz> like, adding a CATCH block

[09:12] <moritz> or tweaking slangs

[09:12] <moritz> and stuff like that

[09:13] <jnthn> ah

[09:13] <jnthn> Through COMPILING mostly, I guess.

[09:13] <moritz> yes

[09:13] <moritz> so no point in doing it now, since we don't hav e COMPILING

[09:13] <jnthn> Right

[09:14] <moritz> r: class A { sub f() is export { say 'oh shark' } }; import A; f

[09:14] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&f' called (line 1)␤»

[09:16] <jnthn> That doesn't work because we only install in UNIT::EXPORT so far, rather than through all the packages we're nested in.

[09:17] <moritz> so export lists are per package right now?

[09:17] <moritz> erm, sorry, per file?

[09:17] <jnthn> Yes, per compilation unit.

[09:17] <jnthn> S11 says that in

[09:18] <jnthn> class A { class B { sub foo() is export { } } }

[09:18] <jnthn> It'd be installed in B::EXPORT::DEFAULT::<&foo>, A::EXPORT::DEFAULT::<&foo> and the UNIT one.

[09:18] <jnthn> Today it only goes in UNIT

[09:19] <dalek> rakudo/use-arglist: 3c393c6 | moritz++ | src/Perl6/ (2 files):

[09:19] <dalek> rakudo/use-arglist: refactor compile time evaluation into a World method

[09:19] <dalek> rakudo/use-arglist: review: https://github.com/rakudo/rakudo/commit/3c393c6aa7

[09:19] <dalek> rakudo/use-arglist: 5b60299 | moritz++ | src/Perl6/Grammar.pm:

[09:19] <dalek> rakudo/use-arglist: fix import + arglist

[09:19] <dalek> rakudo/use-arglist: review: https://github.com/rakudo/rakudo/commit/5b60299c37

[09:20] *** eviltwin_b joined
[09:20] *** geekosaur left
[09:20] *** kresike joined
[09:21] *** eviltwin_b is now known as geekosaur

[09:24] <moritz> meh, it seems that while not importing stuff works, importing custom tags still doesn't install the routines :/

[09:25] <moritz> but explicitly importing :DEFAULT or :ALL works

[09:25] <jnthn> Does exporting with tags other than the defautl one actually to the right instatllation?

[09:25] <moritz> I guess not

[09:25] <jnthn> r: sub foo() is export(:BLAH) { }

[09:25] <p6eval> rakudo d9fd17:  ( no output )

[09:25] <jnthn> I don't recall implementing that bit.

[09:26] <moritz> I wonder how it dispatches at all

[09:27] <moritz> there's a   multi trait_mod:<is>)(Routine:D \$r, :$export!) 

[09:27] *** not_gerd joined
[09:27] <not_gerd> hello, #perl6

[09:27] <not_gerd> some benchmarking fun: https://gist.github.com/2626839

[09:27] <moritz> \o not_gerd 

[09:28] <not_gerd> the high-level code outperforms the low-level version ;)

[09:28] <moritz> not_gerd: I think if you do subroutines with low-level types, you might be faster

[09:28] <moritz> not_gerd: because then rakudo can infer at compile time that there's a native num to pass

[09:28] <moritz> and no boxing will happen

[09:29] <jnthn> If you use native types in the wrong way, it will cost more due to loads of boxing/unboxing.

[09:30] <moritz> r: multi trait_mod:<is>(Routine:D \$r, :$ext!, $args) { say $args.perl }; sub f is ex(:blah) { }

[09:30] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Cannot put required parameter after variadic parameters␤at /tmp/lI9rjYYKWy:1␤»

[09:30] <moritz> r: multi trait_mod:<is>(Routine:D \$r, $args, :$ext!) { say $args.perl }; sub f is ex(:blah) { }

[09:30] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Cannot call 'trait_mod:<is>'; none of these signatures match:␤:(Attribute:D $attr, :rw(:$rw)!)␤:(Attribute:D $attr, :readonly(:$readonly)!)␤:(Attribute:D $attr, :box_target(:$box_target)!)␤:(Routine:D $r, :rw(:$rw)!)␤:(Routine:D $r, :default(:$default)…

[09:31] <moritz> r: multi trait_mod:<is>(Routine:D \$r, $args, :$ext!) { say $args.perl }; sub f is ex('blah') { }

[09:31] <jnthn> moritz: ex vs ext

[09:31] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Cannot call 'trait_mod:<is>'; none of these signatures match:␤:(Attribute:D $attr, :rw(:$rw)!)␤:(Attribute:D $attr, :readonly(:$readonly)!)␤:(Attribute:D $attr, :box_target(:$box_target)!)␤:(Routine:D $r, :rw(:$rw)!)␤:(Routine:D $r, :default(:$default)…

[09:31] <moritz> r: multi trait_mod:<is>(Routine:D \$r, $args, :$ex!) { say $args.perl }; sub f is ex('blah') { }

[09:31] <p6eval> rakudo d9fd17: OUTPUT«"blah"␤»

[09:31] <moritz> r: multi trait_mod:<is>(Routine:D \$r, $args, :$ex!) { say $args.perl }; sub f is ex(:blah) { }

[09:31] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Cannot call 'trait_mod:<is>'; none of these signatures match:␤:(Attribute:D $attr, :rw(:$rw)!)␤:(Attribute:D $attr, :readonly(:$readonly)!)␤:(Attribute:D $attr, :box_target(:$box_target)!)␤:(Routine:D $r, :rw(:$rw)!)␤:(Routine:D $r, :default(:$default)…

[09:31] <moritz> jnthn: thanks

[09:31] <moritz> r: multi trait_mod:<is>(Routine:D \$r, |$args, :$ex!) { say $args.perl }; sub f is ex(:blah) { }

[09:31] <p6eval> rakudo d9fd17: OUTPUT«Capture.new( list => ().list, hash => EnumMap.new("ex", 1, ))␤»

[09:32] <moritz> r: multi trait_mod:<is>(Routine:D \$r, *%args, :$ex!) { say %args.perl }; sub f is ex(:blah) { }

[09:32] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Required named parameter 'ex' not passed␤»

[09:32] <moritz> r: multi trait_mod:<is>(Routine:D \$r, :$ex!, *%args) { say %args.perl }; sub f is ex(:blah) { }

[09:32] <p6eval> rakudo d9fd17: OUTPUT«().hash␤»

[09:36] *** thou left
[09:36] *** eviltwin_b joined
[09:36] *** geekosaur left
[09:36] *** eviltwin_b is now known as geekosaur

[09:40] <moritz> r: class A { sub f is export(:YARR) { } }; say UNIT::EXPORT::.keys

[09:40] <p6eval> rakudo d9fd17: OUTPUT«ALL DEFAULT␤»

[09:44] *** geekosaur left
[09:45] *** geekosaur joined
[09:46] <arnsholt> .u ṛ

[09:46] <phenny> U+1E5B LATIN SMALL LETTER R WITH DOT BELOW (ṛ)

[09:47] <arnsholt> .u ṝ

[09:47] <phenny> U+1E5D LATIN SMALL LETTER R WITH DOT BELOW AND MACRON (ṝ)

[09:47] <arnsholt> .u ḷ

[09:47] <phenny> U+1E37 LATIN SMALL LETTER L WITH DOT BELOW (ḷ)

[09:47] <arnsholt> .u ḥ

[09:47] <phenny> U+1E25 LATIN SMALL LETTER H WITH DOT BELOW (ḥ)

[09:55] *** geekosaur left
[09:56] *** geekosaur joined
[09:58] <moritz> jnthn: how do I access named arguments to a trait?

[10:04] *** brrt joined
[10:04] *** eviltwin_b joined
[10:04] *** geekosaur left
[10:05] *** eviltwin_b is now known as geekosaur

[10:05] <moritz> r: multi trait_mod:<is>(|$a) { say $a.perl }; sub f is foo(:bar) { }

[10:05] <p6eval> rakudo d9fd17: OUTPUT«Capture.new( list => (sub f() { ... },).list, hash => EnumMap.new("foo", 1, ))␤»

[10:05] <moritz> no bar in sight :(

[10:05] <moritz> (pun intended)

[10:13] <tadzik>     pun indented

[10:15] <moritz> I guess the reason is that the argument list to the 'is' trait is parsed as a circumfix, which contains a semilist, not an arglist

[10:15] <moritz> so there's no logic to handle named arguments

[10:15] <moritz> but, otoh, shouldn't named arguments then become simple pairs?

[10:15] <moritz> r: my $x = do { :foo }; say $x

[10:15] <p6eval> rakudo d9fd17: OUTPUT«"foo" => Bool::True␤»

[10:16] <moritz> r: my $x = (:foo) ; say $x

[10:16] <p6eval> rakudo d9fd17: OUTPUT«"foo" => Bool::True␤»

[10:20] *** crab2313 joined
[10:20] *** crab2313 left
[10:21] <moritz> ok, importing by tag name works, though you have to set up the export package yourself :-)

[10:22] <moritz> module A { our sub f is export(:YARR) { say 'oh shark' } }

[10:22] <moritz> UNIT::EXPORT::<YARR> := package YARR { our &f = &A::f; }

[10:22] <moritz> and then

[10:22] <moritz> use A :YARR; f;  says 'oh shark'

[10:24] *** not_gerd left
[10:28] *** cogno joined
[10:35] *** cogno left
[10:38] *** brrt left
[10:44] *** JimmyZ joined
[10:51] *** cogno joined
[10:58] <cogno> When one watches a commit page on github, how does he know what branch the commit belongs to?

[10:59] <tadzik> I'm not sure if one does

[11:00] <cogno> Too bad.

[11:03] <tadzik> any particular commit you have in mind?

[11:06] *** brrt joined
[11:10] *** snearch joined
[11:10] *** moritz joined
[11:11] *** cogno left
[11:15] <jnthn> moritz: I suspect you've found a bug in the handling or args to the trait mod.

[11:17] *** _Vi joined
[11:19] <_Vi> Is Perl6 ready for use cases like "perl -pe 's/something/anything/' -i *.c", but with per6'th numerous regex enhancements?

[11:19] *** tyatpi joined
[11:21] *** cogno joined
[11:26] *** cogno left
[11:27] <tadzik> I don't think we have -i implemented

[11:28] <brrt> would it be possible - and if so, useful - to create a subset Filename of String where the file exists?

[11:28] *** lestrrat left
[11:29] <tadzik> possible? I think so

[11:29] *** lestrrat joined
[11:30] <tadzik> r: subset Filename of Str where { .IO ~~ :e }

[11:30] <p6eval> rakudo d9fd17:  ( no output )

[11:30] <jnthn> r: subset Filename of Str where { .IO ~~ :e }; say 'README' ~~ Filename; say 'lolno' ~~ Filename

[11:30] <p6eval> rakudo d9fd17: OUTPUT«False␤False␤»

[11:30] <tadzik> r: subset Filename of Str where { .IO ~~ :e }; Filename $a = "README"

[11:30] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Confused␤at /tmp/s24cf4g888:1␤»

[11:30] <jnthn> r: subset Filename of Str where { .IO ~~ :e }; say 'perl6' ~~ Filename; say 'lolno' ~~ Filename

[11:30] <p6eval> rakudo d9fd17: OUTPUT«False␤False␤»

[11:30] <tadzik> r: subset Filename of Str where { .IO ~~ :e }; my Filename $a = "README"

[11:30] <p6eval> rakudo d9fd17: OUTPUT«Type check failed in assignment to '$a'; expected 'Filename' but got 'Str'␤  in block <anon> at /tmp/i_JnSSyRX1:1␤␤»

[11:31] <jnthn> r: say "README".IO ~~ :e

[11:31] <p6eval> rakudo d9fd17: OUTPUT«False␤»

[11:31] <jnthn> r: say "README" ~~ :e

[11:31] <p6eval> rakudo d9fd17: OUTPUT«Method 'e' not found for invocant of class 'Str'␤  in method ACCEPTS at src/gen/CORE.setting:5639␤  in block <anon> at /tmp/Q58SGxK3SP:1␤␤»

[11:31] <moritz> brrt: note that type checks are supposed to pure functions

[11:32] <moritz> brrt: so if somebody adds or deletes a file while your program is running, that might cause some havoc

[11:33] <brrt> dangerous method

[11:33] <brrt> but still

[11:34] *** geekosaur left
[11:36] *** geekosaur joined
[11:45] *** noam left
[11:46] *** noam joined
[11:46] <_Vi> Is (will be) Perl6 in general as good tool for ad-hoc oneliners as Perl5 is? It would be good to be able to use it as "enhanced sed" with advanced Unicode capabilities.

[11:46] *** noam left
[11:46] *** noam joined
[11:47] <moritz> _Vi: we haven't reached that level yet, but we certainly intend to do it

[11:48] <moritz> I've been implementing a few command line options these past weeks, maybe I should consider doing some more in the -F or -i direction

[11:48] <moritz> afk&

[11:48] <_Vi> (In my head the "soul and spirit of Perl" lies in oneliners and short non-modular text-processing scripts. Perl6 does not have this spirit yet.)

[11:53] <dalek> Perlito: 6244c95 | (Flavio S. Glock)++ | t5/op/exp.t:

[11:53] <dalek> Perlito: Perlito5 - add t/op/exp.t

[11:53] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/6244c9526f

[11:57] *** brrt left
[11:58] *** _sri joined
[11:58] *** skids left
[11:58] *** moritz left
[11:59] *** moritz joined
[12:05] *** _Vi left
[12:06] *** mtk joined
[12:31] *** MContagious left
[12:34] *** geekosaur left
[12:34] *** eviltwin_b joined
[12:34] *** eviltwin_b is now known as geekosaur

[12:48] *** eviltwin_b joined
[12:48] *** geekosaur left
[12:48] *** eviltwin_b is now known as geekosaur

[12:50] *** PacoAir joined
[12:50] *** eviltwin_b joined
[12:50] *** geekosaur left
[12:51] *** eviltwin_b is now known as geekosaur

[12:52] *** geekosaur left
[12:52] *** geekosaur joined
[12:53] *** snearch left
[12:55] *** PacoAir left
[13:04] *** bluescreen10 joined
[13:04] *** PacoAir_ joined
[13:06] *** eviltwin_b joined
[13:06] *** geekosaur left
[13:06] *** eviltwin_b is now known as geekosaur

[13:07] *** _Vi joined
[13:08] *** bluescreen10 left
[13:10] *** Guest51792 left
[13:10] *** eviltwin_b joined
[13:10] *** geekosaur left
[13:11] *** eviltwin_b is now known as geekosaur

[13:13] *** eviltwin_b joined
[13:13] *** geekosaur left
[13:14] *** bluescreen10 joined
[13:14] *** geekosaur joined
[13:15] *** xenu joined
[13:15] *** xenu is now known as Guest71264

[13:17] *** eviltwin_b left
[13:24] *** bluescreen10 left
[13:25] *** skids joined
[13:25] *** bluescreen10 joined
[13:31] *** eviltwin_b joined
[13:31] *** geekosaur left
[13:32] *** eviltwin_b is now known as geekosaur

[13:36] *** tyatpi left
[13:40] *** mynameisbrian joined
[13:43] *** pernatiy left
[13:45] *** araujo left
[13:46] *** araujo joined
[13:46] *** pernatiy joined
[13:46] *** pernatiy left
[13:48] *** pernatiy joined
[13:49] *** tyatpi joined
[13:51] <colomon> n: say '\S\'

[13:51] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/BSnyHC3wCm line 1:␤------> [32msay[33m⏏[31m '\S\'[0m␤␤Confused at /tmp/BSnyHC3wCm line 1:␤------> …

[13:52] <colomon> n: say 'A'.ord

[13:52] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«65␤»

[13:54] *** pernatiy_ joined
[13:54] *** pernatiy left
[13:54] <colomon> what's the p6 equivalent of $'     ?

[13:55] *** kaleem left
[13:57] <colomon> ah, $/.postmatch

[13:59] *** DarthGandalf joined
[13:59] *** eviltwin_b joined
[13:59] *** geekosaur left
[14:00] *** eviltwin_b is now known as geekosaur

[14:00] <colomon> n: say "face".hex

[14:00] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Unable to resolve method hex in class Str␤  at /tmp/r3CZD0vf4z line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3840 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3841 (module-CORE @ 65) ␤  at /home/p6e…

[14:00] *** mynameisbrian left
[14:00] <colomon> r: say "face".hex

[14:00] <p6eval> rakudo d9fd17: OUTPUT«Method 'hex' not found for invocant of class 'Str'␤  in block <anon> at /tmp/tC9Oi3Rs_h:1␤␤»

[14:01] * colomon 's brain is starting to hurt from switching back and forth with p5

[14:01] <jnthn> r: say :16('face')

[14:01] <p6eval> rakudo d9fd17: OUTPUT«64206␤»

[14:01] <colomon> r: my $a = 'face'; say :16($a)

[14:01] <p6eval> rakudo d9fd17: OUTPUT«64206␤»

[14:01] <colomon> n: my $a = 'face'; say :16($a)

[14:01] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«64206␤»

[14:02] <colomon> jnthn++

[14:03] *** eviltwin_b joined
[14:03] *** geekosaur left
[14:03] *** eviltwin_b is now known as geekosaur

[14:04] *** kaare_ joined
[14:09] *** Guest71264 left
[14:14] *** xenu joined
[14:15] *** xenu is now known as Guest66045

[14:23] *** eviltwin_b joined
[14:23] *** geekosaur left
[14:23] *** eviltwin_b is now known as geekosaur

[14:23] *** tyatpi left
[14:28] *** kresike left
[14:31] *** PacoAir_ left
[14:33] *** cognominal joined
[14:34] *** cognominal___ left
[14:37] *** tyatpi joined
[14:37] *** sporous left
[14:37] *** sporous joined
[14:39] *** araujo left
[14:39] *** eviltwin_b joined
[14:39] *** geekosaur left
[14:40] *** eviltwin_b is now known as geekosaur

[14:40] *** araujo joined
[14:41] *** eviltwin_b joined
[14:41] *** geekosaur left
[14:42] *** eviltwin_b is now known as geekosaur

[14:47] *** eviltwin_b joined
[14:47] *** geekosaur left
[14:47] *** eviltwin_b is now known as geekosaur

[14:51] *** Kresike joined
[14:53] *** eviltwin_b joined
[14:53] *** geekosaur left
[14:54] *** eviltwin_b is now known as geekosaur

[14:55] *** zby_home_ joined
[14:57] *** fgomez left
[14:59] *** birdwindupbird left
[15:01] *** erkan left
[15:05] *** geekosaur left
[15:05] *** eviltwin_b joined
[15:05] *** eviltwin_b is now known as geekosaur

[15:12] *** tyatpi left
[15:12] *** eviltwin_b joined
[15:12] *** geekosaur left
[15:13] *** eviltwin_b is now known as geekosaur

[15:23] *** glass left
[15:24] *** envi_ left
[15:25] *** envi_ joined
[15:26] *** sftp left
[15:27] *** sftp joined
[15:28] *** tyatpi joined
[15:28] *** Guest66045 left
[15:28] *** tokuhirom joined
[15:29] *** carlin joined
[15:30] *** envi_ left
[15:30] <masak> lol shark hai, #perl6

[15:32] <jnthn> fin evening, masak

[15:32] *** envi_ joined
[15:33] <moritz> \o

[15:35] *** fglock left
[15:35] * masak .oO( have the appropriate amount of fin )

[15:35] *** fgomez joined
[15:36] *** MContagious joined
[15:38] *** xenu joined
[15:38] *** xenu is now known as Guest74228

[15:40] *** fgomez left
[15:49] *** JimmyZ left
[15:49] *** Psyche^ joined
[15:49] <moritz> fin ack

[15:50] * masak .oO( NAK on wood )

[15:51] * geekosaur too NAKered

[15:52] <moritz> no details please

[15:53] *** Patterner left
[15:53] *** Psyche^ is now known as Patterner

[15:56] *** geekosaur left
[15:56] *** eviltwin_b joined
[15:56] *** eviltwin_b is now known as geekosaur

[16:09] *** geekosaur left
[16:13] <raiph> p6: say lines("asdf")[0] # expected this to look for a file "asdf" and say its first line

[16:13] <p6eval> pugs: OUTPUT«*** No such subroutine: "&lines"␤    at /tmp/iNzpLXdSwX line 1, column 5 - line 2, column 1␤»

[16:13] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«asdf␤»

[16:13] <jnthn> raiph: That's slept lines("asdf".IO)[0]

[16:14] <raiph> thx jnthn

[16:14] <moritz> r: say lines("asdf".IO)[0]

[16:14] <p6eval> rakudo d9fd17: OUTPUT«Unable to open filehandle from path 'asdf'␤  in method open at src/gen/CORE.setting:6588␤  in method get at src/gen/CORE.setting:6608␤  in code <anon> at src/gen/CORE.setting:6632␤  in sub coro at src/gen/CORE.setting:4926␤  in method reify at src/gen/CORE.setting:…

[16:14] <TimToady> p6: say words('the quick brown fox jumped')[3]

[16:14] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&words' called (line 1)␤»

[16:14] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&words"␤    at /tmp/gtj1gJE0m_ line 1, column 5 - line 2, column 1␤»

[16:14] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'words' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1364 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /hom…

[16:15] <jnthn> .oO( I'm not sure if that typo was ironic or Freudian... )

[16:15] <bbkr> wow, awesome trick with "file".IO

[16:15] <raiph> right. (btw i like your spelling of spelled)

[16:15] *** geekosaur joined
[16:17] <TimToady> p6: say 'the quick brown fox jumped'.words[3]

[16:17] <p6eval> rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«fox␤»

[16:17] <p6eval> ..pugs: OUTPUT«*** No such method in class Str: "&words"␤    at /tmp/7Jvqdl04jT line 1, column 5 - line 2, column 1␤»

[16:17] <TimToady>  multi method words ( Str $input: Int $limit = Inf --> List ) is export

[16:17] <TimToady> supposed to be exported as as a function

[16:18] *** fglock joined
[16:18] *** fgomez joined
[16:18] <masak> TimToady: could we get 'invert' as a function, too? I'd find that useful.

[16:19] *** geekosaur left
[16:19] *** geekosaur joined
[16:20] <TimToady> sure, anything that makes sense both ways and is common enough for it to matter should be considered for export at least

[16:20] <masak> \o/

[16:20] <masak> oh oh

[16:21] <TimToady> but I'm sure there are methods that are going to be rare enough that they don't merit such treatement

[16:21] <masak> and List.invert (as being the same as List.kv.hash.invert) -- I'd like that too

[16:21] <TimToady> um

[16:21] <TimToady> why not List.pairs.invert?

[16:21] <TimToady> .kv is a micro-smell

[16:22] <masak> ah.

[16:22] *** MContagious left
[16:22] <masak> yeah. maybe that's enough, then.

[16:22] <masak> p6: say <a b c>.pairs.invert

[16:22] <p6eval> pugs: OUTPUT«*** Not a keyed value: VList [VStr "a",VStr "b",VStr "c"]␤    at /tmp/IrcXokCCwJ line 1, column 5 - line 2, column 1␤»

[16:22] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Unable to resolve method invert in class List␤  at /tmp/hLf2h_qa2Z line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3840 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3841 (module-CORE @ 65) ␤  at /home…

[16:22] <p6eval> ..rakudo d9fd17: OUTPUT«Method 'invert' not found for invocant of class 'List'␤  in block <anon> at /tmp/9lmAS5IB4E:1␤␤»

[16:22] <TimToady> mind, I dunno if that even works

[16:22] <masak> seems not :)

[16:23] <TimToady> but we ought to be able to write one that doesn't need an intermediate hash, meseemeth

[16:25] <TimToady> that is, a List.invert that assumes pairs the same way a hash initializer does

[16:25] <masak> right.

[16:25] <masak> I keep finding myself in situations when I want that.

[16:25] <TimToady> then it doesn't matter whether whether you .kv or .pairs

[16:25] <masak> :)

[16:26] <TimToady> but it would require one or the other to introduce the .keys

[16:26] *** fglock left
[16:28] <TimToady> it might be a little surprising to someone who expects @array.invert to behave exactly like @hash.invert though

[16:29] <sorear> good * #perl6

[16:29] <TimToady> \o

[16:29] *** thou joined
[16:29] <jnthn> masak: Curious - what kind of situation?

[16:31] *** ponbiki joined
[16:31] <TimToady> emulating content-addressable memory

[16:31] *** eviltwin_b joined
[16:31] *** geekosaur left
[16:31] <masak> jnthn: hex puzzle. mapping forwards from j2-like coords to 1-d board indices, and then backwards to 2-d coordinate pairs.

[16:31] *** eviltwin_b is now known as geekosaur

[16:32] *** wtw left
[16:32] <jnthn> ah, ok

[16:32] <masak> jnthn: the forwards mapping is done most easily as 'my %horizontals = <i1 i2 ...>.kv.hash.invert'

[16:34] <TimToady> basically, any 2-way mapping where one of them is naturally positional

[16:34] *** mspaulding joined
[16:34] <masak> right.

[16:34] *** mspaulding left
[16:35] *** wolfman2000 left
[16:36] <sisar> um, installing LWP::Simple fails for me with failure in dependence resolution: https://gist.github.com/2628829.

[16:36] <TimToady> I could probably be argued into List.invert assuming it should invert on the indexes, and leave out the hashlist stuff

[16:36] *** NamelessTee joined
[16:37] <TimToady> while less powerful, it's probably more POLS

[16:37] <TimToady> the other way is to distinguish Array.invert from List.invert, but that bothers me

[16:38] <masak> oh, I meant inverting on the indices.

[16:39] <masak> sisar: panda seems to complain because the URI tests don't pass -- so it doesn't go on and install LWP::Simple.

[16:39] <TimToady> perl6: say (a => 42).invert.perl

[16:39] <p6eval> rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«42 => "a"␤»

[16:39] <p6eval> ..pugs: OUTPUT«*** No such method in class Pair: "&invert"␤    at /tmp/ifgTGz1xwR line 1, column 5 - line 2, column 1␤»

[16:39] <TimToady> we can always hyperinvert a pairlist

[16:40] <masak> that still doesn't feel Huffmanized enough to me.

[16:40] <TimToady> I mean that in addition to List.invert

[16:41] <masak> ah.

[16:41] <TimToady> because that would do the wrong thing with a list of pairs

[16:41] <sisar> masak: ok. So I need to wait till URI is fixed ? (i know, i should fix it myself)

[16:42] <sisar> :)

[16:42] <TimToady> you'd end up with 0 => (a => 42)

[16:43] <TimToady> perl6: my %hash = (:a(1), :b(2), :c(3)).pairs».invert; say %hash<c>

[16:43] <p6eval> pugs: OUTPUT«*** Not a keyed value: VList [VRef <Pair:0xf6d85bb9>,VRef <Pair:0xf6d85c31>,VRef <Pair:0xf6d85c8d>]␤    at /tmp/bzrU0kk1FC line 1, column 12-47␤»

[16:43] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«Any()␤»

[16:43] <TimToady> oops

[16:44] <TimToady> perl6: my %hash = (:a(1), :b(2), :c(3))».invert; say %hash<c>

[16:44] <p6eval> pugs: OUTPUT«*** No such method in class Array: "&>>invert"␤    at /tmp/eZZ5NPmqIS line 1, column 12-41␤»

[16:44] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«Any()␤»

[16:44] *** libertyprime left
[16:44] <masak> sisar: yes, please do. or at least figure out more about the test failures.

[16:44] <sisar> ok

[16:44] <TimToady> perl6: my %hash = <a b c d e>.pairs».invert; say %hash<c>

[16:44] <p6eval> rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«2␤»

[16:44] <p6eval> ..pugs: OUTPUT«*** Not a keyed value: VList [VStr "a",VStr "b",VStr "c",VStr "d",VStr "e"]␤    at /tmp/2FMJ66De4g line 1, column 12-37␤»

[16:45] <TimToady> that at least avoids creating a temp hash

[16:45] *** libertyprime joined
[16:48] *** eviltwin_b joined
[16:48] *** geekosaur left
[16:49] *** eviltwin_b is now known as geekosaur

[16:55] *** erkan joined
[16:55] *** erkan left
[16:55] *** erkan joined
[16:55] <masak> perl6: my %hash = <a b c d e> Z=> 0..*; say %hash<c>

[16:55] <p6eval> rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«2␤»

[16:55] <p6eval> ..pugs: OUTPUT«*** unknown parse error␤    at /tmp/sxmYSABSen line 1, column 27␤»

[16:55] <masak> so does this. but I don't much like the end weight of it.

[16:55] *** eviltwin_b joined
[16:55] *** geekosaur left
[16:56] *** eviltwin_b is now known as geekosaur

[16:57] <masak> that's why I'd like a sub form of 'invert', too. because it places the transformation up front.

[16:58] *** geekosaur left
[16:58] *** geekosaur joined
[16:59] <sorear> p6: &invert

[16:59] <p6eval> pugs: OUTPUT«*** ␤    Unexpected end of input␤    expecting "::" or signature value␤    Variable "&invert" requires predeclaration or explicit package name␤    at /tmp/3ubh2sCbl8 line 1, column 8␤»

[16:59] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85:  ( no output )

[17:00] <sorear> n: say invert [<a i u e o>]

[17:00] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Nominal type check failed in binding '%h' in 'invert'; got Array, needed Associative␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (invert @ 1) ␤  at /tmp/OFg3FW4C_I line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting li…

[17:00] <sorear> n: say invert {<a i u e o> Z=> 0..*}

[17:00] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Nominal type check failed in binding '%h' in 'invert'; got Block, needed Associative␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (invert @ 1) ␤  at /tmp/rU3cw1ymAB line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting li…

[17:00] <sorear> n: say invert {%(), <a i u e o> Z=> 0..*}

[17:00] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Nominal type check failed in binding '%h' in 'invert'; got Block, needed Associative␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (invert @ 1) ␤  at /tmp/FvJjCHG074 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting li…

[17:00] <sorear> n: say invert %(<a i u e o> Z=> 0..*)

[17:01] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«0 => "a" 1 => "i" 2 => "u" 3 => "e" 4 => "o"␤»

[17:02] <masak> \o/

[17:02] *** vlixes joined
[17:02] <masak> any good reason *not* to make 'invert <a i u e o>' work, too?

[17:04] *** PacoAir joined
[17:04] <TimToady> I already said I was fine with that part, I think...my wonderings were more about the types involved

[17:06] *** carlin left
[17:06] *** eviltwin_b joined
[17:06] *** geekosaur left
[17:07] *** carlin joined
[17:07] *** eviltwin_b is now known as geekosaur

[17:07] <tadzik> 'afternoon, #eplr6

[17:07] <tadzik> or whatever channel I'm on

[17:10] *** simcop2387 joined
[17:11] *** Chillance joined
[17:12] <Woodi> hallo

[17:12] <Woodi> perl6: my %hash = (:a(1), :b(2), :c(3)); say %hash

[17:12] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«{"a" => 1, "b" => 2, "c" => 3}␤»

[17:12] <p6eval> ..rakudo d9fd17: OUTPUT«("a" => 1, "b" => 2, "c" => 3).hash␤»

[17:12] <p6eval> ..pugs: OUTPUT«a  1b      2c      3␤»

[17:13] * masak .oO( Perl 6 was delayed many years, because the community members kept logging into anagrams of the channel name )

[17:13] <Woodi> it's strange that compilers have different output...

[17:13] <masak> Woodi: no, it's not.

[17:13] <masak> Woodi: .gist defaults to .perl, which is compiler-dependent.

[17:14] <Woodi> ah, right. so "internal dumper" is standarized ?

[17:15] <Woodi> I think about it as kind of code serialization... for RPC or something...

[17:19] *** Guest74228 left
[17:26] *** geekosaur left
[17:26] *** eviltwin_b joined
[17:26] *** eviltwin_b is now known as geekosaur

[17:34] *** geekosaur left
[17:34] *** eviltwin_b joined
[17:34] *** eviltwin_b is now known as geekosaur

[17:35] *** ocharles joined
[17:40] *** xenu joined
[17:40] *** eviltwin_b joined
[17:40] *** geekosaur left
[17:41] *** xenu is now known as Guest40378

[17:41] *** eviltwin_b is now known as geekosaur

[17:42] *** not_gerd joined
[17:42] <not_gerd> hello, #perl6

[17:42] <not_gerd> google fail - is it possible to define your own ternary operators?

[17:42] *** geekosaur is now known as allbery_b

[17:45] *** geekosaur joined
[17:45] <moritz> not yet, i fear

[17:46] *** eviltwin_b joined
[17:46] *** geekosaur left
[17:47] *** geekosaur joined
[17:48] <masak> what's missing?

[17:48] <jnthn> Something that does the right thing with the definition, I suspect.

[17:48] <masak> r: sub infix:<!? !?>($a, $b, $c) { "$a, $b and $c went into a bar..." }; say 1 !? 2 !? 3

[17:48] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Confused␤at /tmp/rLuIegwVIH:1␤»

[17:48] <masak> aww

[17:49] <moritz> ttiar

[17:49] <moritz> hm, no

[17:49] * moritz can't parse

[17:49] <masak> ;)

[17:49] <moritz> r: sub infix:<FOO BAR>(*@a) { say @a.perl }; 1 FOO 2 BAR 3

[17:49] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Confused␤at /tmp/UU5finyUCs:1␤»

[17:49] *** allbery_b left
[17:49] <moritz> r: sub infix:<FOO BAR>(*@a) { say @a.perl }; 1 FOO BAR 3

[17:49] <p6eval> rakudo d9fd17: OUTPUT«Array.new(1, 3)␤»

[17:50] <moritz> r: sub infix:<FOO BAR>(*@a) { say @a.perl }; 1 FOO  BAR 3

[17:50] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Confused␤at /tmp/qHyav8EPpc:1␤»

[17:50] <not_gerd> anyway, I had some more fun with the n-body benchmark

[17:50] <not_gerd> if anyone wants to take a look: https://gist.github.com/2626839

[17:51] <jnthn> moritz: Heh. Was just glancing the code and realized...it just...installs the token, including the space. :)

[17:52] <moritz> jnthn: I figured :-)

[17:53] <jnthn> I'm gonna redo that whole load of stuff soonish anyways.

[17:53] *** geekosaur left
[17:53] <jnthn> To fix the serialization issues, and also to enable the precedence traits.

[17:54] <tadzik> jnthn: did you have any chance to look at that non-deterministic precompilation fun?

[17:55] <[Coke]> jnthn: are you using win xp or win 7?

[17:55] <jnthn> tadzik: There was a non-deterministic one?

[17:55] <jnthn> [Coke]: Win 7.

[17:55] <tadzik> jnthn: yeah, URI and panda suffer from it. Basically, loading sometimes fails with "No object at STable <n>", and sometimes not

[17:55] <jlaire> .u ’

[17:55] <phenny> U+2019 RIGHT SINGLE QUOTATION MARK (’)

[17:56] <jnthn> tadzik: "sometimes"? :/

[17:56] <tadzik> jnthn: yeah, that's the point :/

[17:56] <tadzik> jnthn: I can provide a shell if you can't reproduce

[17:57] <jnthn> What do you have to do to make it suceed? Just run it again? Or re-compile?

[17:57] *** eviltwin_b is now known as geekosaur

[17:57] <tadzik> jnthn: you have a 50% chance. Recompilation triggers it

[17:57] <tadzik> if it's compiled with luck, then it always works

[17:57] <tadzik> if without luck, then it never does

[17:57] <tadzik> afair, will recheck

[18:00] <tadzik> jnthn: yes, it's a matter of recompiling it

[18:03] *** tokuhirom left
[18:03] *** tokuhirom joined
[18:07] *** pernatiy_ left
[18:08] *** pernatiy joined
[18:08] *** tokuhirom left
[18:10] *** alester joined
[18:23] <masak> tadzik: so that makes it deterministic, then?

[18:28] *** wolfman2000 joined
[18:28] <tadzik> no

[18:29] <tadzik> you have approx. 50% chance it'd work

[18:29] <masak> :/

[18:30] <masak> grep the code for any 1d2 die rolls...

[18:30] *** eviltwin_b joined
[18:30] *** geekosaur left
[18:31] *** eviltwin_b is now known as geekosaur

[18:33] *** zby_home_ left
[18:37] <tadzik> my only guess is the Parrot's hash randomization

[18:37] <tadzik> I know of no other things that are random

[18:37] *** fhelmberger left
[18:47] <TimToady> parallel make could be random

[18:48] <jnthn> Ah

[18:48] <jnthn> And parallel make would potentially cause issues like this...

[18:52] *** wolf2k_away joined
[18:55] *** wolfman2000 left
[18:57] <sisar> tadzik: now i remember, i got the exact same error "No STable at index 8" when compiling panda today. Any info I can provide? I still have the terminal output of that try.

[18:57] *** _Vi left
[18:59] <Celelibi> About the >> and << metaoperators: what is an operator?

[18:59] <masak> Celelibi: how do you mean?

[18:59] <masak> an operator is anything that S03 talks about. to a first approximation :P

[18:59] <Celelibi> How can I make my own operator to put between >> and << ?

[19:00] <masak> Celelibi: just define it, as a sub.

[19:00] <colomon> Celelibi: sub infix:<whatever>($a, $b) { ... }

[19:00] <masak> r: sub infix:<!!!>($a, $b) { "A $a and a $b walk into a bar..." }; say "platypus" !!! "philosopher"

[19:00] <p6eval> rakudo d9fd17: OUTPUT«A platypus and a philosopher walk into a bar...␤»

[19:01] <Celelibi> What are they talking about ?

[19:01] <Celelibi> :)

[19:01] <masak> Plato :)

[19:01] <colomon> n: sub infix:<whatever>($a, $b) { $a ~ " blue" x $b }; say <go blue> >>whatever<< [2, 3, 4]

[19:01] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Ran off end of non-dwimmy left␤  at /home/p6eval/niecza/lib/CORE.setting line 1364 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3019 (ANON @ 18) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3026 (_hyper_posi @ 6) ␤  at /…

[19:02] *** GlitchMr joined
[19:02] <Celelibi> what is <go blue> ?

[19:02] <masak> Celelibi: ('go', 'blue')

[19:02] *** wolf2k_bahhumbug joined
[19:02] <GlitchMr> perl6: print sqrt -1

[19:02] <Celelibi> like qw ?

[19:02] <p6eval> pugs, rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«NaN»

[19:02] <colomon> yes

[19:02] <masak> Celelibi: to a first approximation, yes.

[19:02] <GlitchMr> perl6: print sqrt(-1 + 0i)

[19:02] <Celelibi> ok

[19:02] <p6eval> rakudo d9fd17: OUTPUT«6.12303176911189e-17+1i»

[19:02] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«6.1230317691118863E-17+1i»

[19:02] <p6eval> ..pugs: OUTPUT«0 + 1i»

[19:02] <masak> Pugs++

[19:03] *** eviltwin_b joined
[19:03] *** geekosaur left
[19:03] *** eviltwin_b is now known as geekosaur

[19:04] *** wolf2k_bahhumbug left
[19:05] *** wolf2k_away left
[19:06] <sisar> aye, Pugs++

[19:09] *** eviltwin_b joined
[19:09] *** geekosaur left
[19:09] *** eviltwin_b is now known as geekosaur

[19:09] <Celelibi> masak: and what's the difference between <> and qw ?

[19:10] <cognominal> none, I think

[19:12] <Celelibi> And can I, in some way use the meta operators >> and/or << on more that two arguments?

[19:13] <cognominal> r:  say << a b > < c >>  # except that you can do it multilevel

[19:13] <p6eval> rakudo d9fd17: OUTPUT«a b > < c␤»

[19:13] *** geekosaur left
[19:14] <Celelibi> I don't understand that line.

[19:14] <cognominal> r:  say << a b > < c >>.perl  # except that you can do it multilevel

[19:14] <p6eval> rakudo d9fd17: OUTPUT«("a", "b", ">", "<", "c")␤»

[19:15] *** geekosaur joined
[19:15] <masak> Celelibi: <> has val() semantics. (see S02). qw doesn't.

[19:16] *** birdwindupbird joined
[19:16] <Celelibi> cognominal: this is just a list...

[19:16] <Celelibi> I don't get it.

[19:16] <masak> Celelibi: cognominal wants to show off that if you have a '<' inside the <> list, you can just delimit with <<>> instead.

[19:17] <Celelibi> ok

[19:17] <masak> and so on.

[19:17] <cognominal> you can't do that with qw

[19:17] <masak> cognominal: in Perl 5, you can't.

[19:17] <masak> cognominal: this is #perl6 :P

[19:17] *** _dolmen_ joined
[19:17] <cognominal> I am watching the Almadovar, so I am not very attentive

[19:18] <masak> n: .say for qw<<< > >> >>>

[19:18] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«>␤>>␤»

[19:18] <Celelibi> ok ok

[19:18] * masak .oO( I thought he was called the Hollande... )

[19:18] <cognominal> …in spanish to make it more challenging

[19:19] <masak> n: .say for qw<[< a b c >]>

[19:19] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«[<␤a␤b␤c␤>]␤»

[19:20] *** Mescale joined
[19:22] <Celelibi> oh oh, was the ">>." in "Str.methods(:all)>>.name" the metaoperator >> applied on "."?

[19:22] <masak> conceptually, yes.

[19:22] <Celelibi> which means "actually no"? :)

[19:22] <masak> "." isn't really an operator.

[19:23] <masak> or rather, if it's an oprator, it's a rather strange one.

[19:23] <Celelibi> hum... Is >>. the operator as whole?

[19:23] <masak> in the sense that >>+<< is the operator as a whole, yes.

[19:24] <Celelibi> ok so this >>. is actually part of the language while >>+<< is not. right?

[19:24] <tadzik> no, it's just a combo

[19:25] <gfldex> r: my @a = 1,2,3; say @a>>.?foo;

[19:25] <p6eval> rakudo d9fd17: OUTPUT«Nil Nil Nil␤»

[19:25] <masak> Celelibi: it's all just parsing. there's no real "actually part of the language" distinction.

[19:25] <Celelibi> what is .?

[19:25] <masak> Celelibi: it's a dottyop

[19:25] <masak> Celelibi: see STD.pm6 :)

[19:26] <masak> Celelibi: or did you ask 'what is C<.?>?' :)

[19:26] <masak> Celelibi: it's "call method, but don't mind if dispatch fails".

[19:26] <cognominal> everything is more or less dotty in Perl 6    :)

[19:26] <Celelibi> I mean fucking connect my brain to that computer so that I know everything!

[19:26] <Celelibi> :p

[19:26] <gfldex> Celelibi: http://perlcabal.org/syn/S12.html#Calling_sets_of_methods

[19:27] *** geekosaur left
[19:28] <gfldex> it's like a twigil but not :->

[19:29] <Celelibi> what means "call all the methods"?

[19:29] <masak> Celelibi: it means call all the methods.

[19:29] <Celelibi> How can there be several appliable methods?

[19:29] *** geekosaur joined
[19:29] <masak> Celelibi: inheritance.

[19:29] <Celelibi> ok

[19:30] <gfldex> how does that play with MMD?

[19:30] <masak> r: class A { method foo { say "A" } }; class B is A { method foo { say "B" } }; B.new.*foo

[19:30] <p6eval> rakudo d9fd17: OUTPUT«B␤A␤»

[19:30] <Celelibi> So $obj.*methods will call the methods of $obj and its parents.

[19:30] <masak> gfldex: very well.

[19:30] <masak> Celelibi: $obj doesn't have parents. its class does. and it's not just the parents, it's all applicable methods, any level up.

[19:31] <Celelibi> parents

[19:31] <Celelibi> ok

[19:31] <masak> that's not the point :)

[19:31] <Celelibi> I fogot about the multiple inheritance.

[19:31] <masak> "parents" only indicates the case of MI.

[19:31] <masak> you meant "ancestors" or something.

[19:31] <Celelibi> yes.

[19:31] <masak> don't blame me for your being inexact :P

[19:31] <TimToady> parent's parents are parents too :P

[19:31] <Celelibi> English is not my native language. :)

[19:32] <masak> TimToady: yes, but not $obj's.

[19:32] <masak> Celelibi: neither is it mine.

[19:32] <masak> I suspect that there's more non-native English speakers here than native ones.

[19:32] *** geekosaur is now known as allbery_b

[19:32] <Celelibi> possibly. :)

[19:33] <TimToady> regarding whether . is an operator, not by itself; rather it's considered to introduce a postfix, so the whole method call is the postfix operator

[19:33] *** eviltwin_b joined
[19:33] <masak> ah.

[19:33] <masak> learn something every day ;)

[19:33] <Celelibi> And can I declare several methods that could match the same arguments?

[19:34] <TimToady> and some of our native English speakers have studied linguistics, which means they don't know how the language works anymore either

[19:34] <cognominal> a spread postfix then.

[19:34] <masak> Celelibi: yes, if you declare them 'multi'.

[19:34] *** allbery_b left
[19:34] <Celelibi> ok

[19:34] <Celelibi> and I guess .* will call them all.

[19:34] *** Mescale left
[19:34] <masak> hm, with .* you don't need the 'multi'.

[19:34] <masak> as I showed above.

[19:35] <Celelibi> r: class A { method foo { say "A" } }; class B is A { method foo { say "B" } method foo {say "C"} }; B.new.*foo

[19:35] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[19:35] <Celelibi> r: class A { method foo { say "A" } }; class B is A { method foo { say "B" }; method foo {say "C"} }; B.new.*foo

[19:35] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Package 'B' already has a method 'foo' (did you mean to declare a multi-method?)␤»

[19:35] <moritz> note that classes usually have to be explicitly designed for .* use, otherwise .* won't work as expected

[19:35] <Celelibi> r: class A { method foo { say "A" } }; class B is A { multi method foo { say "B" }; multi method foo {say "C"} }; B.new.*foo

[19:35] <p6eval> rakudo d9fd17: OUTPUT«Ambiguous call to 'foo'; these signatures all match:␤:(B , Mu *%_)␤:(B , Mu *%_)␤␤  in method foo at src/gen/CORE.setting:293␤  in method dispatch:<.*> at src/gen/CORE.setting:821␤  in block <anon> at /tmp/Ebas_rsdm9:1␤␤»

[19:36] <TimToady> .* is kind of a power tool; it can cut your arm off really quick

[19:37] <TimToady> add in >> and it'll gladly cut off all your limbs

[19:37] *** Mescale joined
[19:37] <Celelibi> I guess from the last error that .* cannot call several methods in the same class.

[19:37] <TimToady> nope

[19:38] <TimToady> you can only do that if you add 'multi'

[19:38] <TimToady> and then distinguish the type sigs enough so that's not ambiguous

[19:38] <Celelibi> didn't I put multi in the right place?

[19:38] <masak> Celelibi: your problem wasn't .* at all

[19:38] <TimToady> you didn't distinguish the signatures

[19:39] <masak> Celelibi: your problem was an ambiguous dispatch.

[19:39] <Celelibi> r: class A { method foo { say "A" } }; class B is A { multi method foo { say "B" }; multi method foo (int $a = 0) {say "C"} }; B.new.*foo

[19:39] <p6eval> rakudo d9fd17: OUTPUT«Ambiguous call to 'foo'; these signatures all match:␤:(B , Mu *%_)␤:(B , int $a = { ... }, Mu *%_)␤␤  in method foo at src/gen/CORE.setting:293␤  in method dispatch:<.*> at src/gen/CORE.setting:821␤  in block <anon> at /tmp/u2sOxmc5rI:1␤␤»

[19:39] <masak> Celelibi: generally, if you make your method signatures exactly the same, you'll get one.

[19:39] <TimToady> .* isn't meant to help with that

[19:39] <jnthn> Remember that .* is *only* about the MRO

[19:39] <masak> Celelibi: 'multi' really only makes sense if you also make sure to make your signatures different enough.

[19:40] <jnthn> The multi-dispatch is then a secondary dispatch *after* normal method dispatch.

[19:40] <Celelibi> ok

[19:40] <jnthn> And the "call all the things" semantics is not applied recursviely into the proto's dispatch.

[19:40] <Celelibi> MRO ?

[19:40] <jnthn> Method Resolution Order. Basically, "what order do we visit classes in to find the method"?

[19:40] <TimToady> if you really need to call a set of indentical signatures, just shove 'em in a data structure and call 'em with >>.

[19:40] <jnthn> When you have multiple inheritance, there's more than one way you could walk the tree.

[19:41] <Celelibi> ok

[19:41] <TimToady> s/indent/ident/

[19:41] <Celelibi> I think I get it.

[19:41] <TimToady> good questions though

[19:42] <TimToady> it's not something we've always "got" ourselves

[19:43] * moritz regularly confuses how inheritance and multi methods interact

[19:43] <moritz> and I think we've been back and forth a few times about how it should be

[19:43] <masak> I also think I get it now.

[19:44] <masak> well, nowadays, I should say. since about mid-2011.

[19:44] <masak> it's really quite pretty.

[19:44] *** not_gerd left
[19:44] <masak> and yeah, keeping the MRO and the proto/multi bits apart is kinda important ;)

[19:45] * jnthn wishes it had been so obvious from the start, so he didn't have to re-implement all the things...

[19:46] <TimToady> we'll all be smart by the time this is done :)

[19:46] <jnthn> ;)

[19:47] <TimToady> otoh, I hope we're all dead before this is done too, in the 100-year-language sense :)

[19:48] <masak> I hope we're all alive by the time this is done, in the 100-year language sense... :)

[19:48] <TimToady> the Plurality is Near!

[19:49] <TimToady> I suppose it doesn't have to be me, as long as it's somebody who thinks he's me...

[19:51] <TimToady> The Strong Turing Test: emulating you so well that you don't know whether you're the real you or not...

[19:52] <masak> TimToady: you reminded me of http://blog.plover.com//brain/immortality.html

[19:52] *** jaldhar left
[19:53] <TimToady> yes, I've always liked that one.

[19:54] <masak> something about all that bothers me; can't quite say what.

[19:54] <TimToady> s/you don't know/neither of you knows/

[19:55] <TimToady> well, the whole issue rests on the extent to which your identity includes the reality in which you're embedded

[19:55] <Celelibi> <TimToady> The Strong Turing Test: emulating you so well that you don't know whether you're the real you or not... <-- please stop messing with my mind! :p

[19:56] <moritz> Celelibi: you'll have to get used to that if you hang around here for longer :-)

[19:56] <TimToady> um...no?  :P

[19:56] <eviltwin_b> shatterday?

[19:57] <TimToady> sorry, I mess regularly with my own mind, and some of it naturally wanders out into the reality in which I am embedded

[19:57] <masak> *lol*

[19:58] <jnthn> moritz: Latest on use-malice is...import works and I need to look at export?

[19:58] * masak .oO( we have a level-3 TimToady containment breach... all personel to section 4A of the reality in which TimToady is embedded... )

[19:58] *** eviltwin_b is now known as geekosaur

[19:59] <moritz> jnthn: correct

[19:59] <Celelibi> TimToady: I already do this myself. I don't really need more. :)

[19:59] <jnthn> Pulled...building. :)

[19:59] <masak> personnel*

[19:59] <TimToady> .oO(the Gray Geek Catastrophe)

[19:59] <masak> TimToady: :D

[19:59] <moritz> jnthn: it works when I build the export tag myself :-)

[20:00] <jnthn> moritz: OK :)

[20:00] <masak> TimToady: weirdest mental image today: Guido van Rossum, riding the Googleplex, trying to fend of an ocean of your brain with a pitchfork.

[20:00] <jnthn> So, design question

[20:01] <masak> off*

[20:01] <jnthn> sub foo is export(:lol, :wut) { }

[20:01] <jnthn> What gets passed to the trait_mod there?

[20:01] <jnthn> Clearly :export is passed.

[20:01] <jnthn> Then do we get: a) two named args, :lol and :wut, or b) one positional arg, which is a Parcel containing two Pairs?

[20:01] <jnthn> TimToady: ^^ :)

[20:01] <cognominal> sometimes, #perl6 sounds like inception, the movie.

[20:02] *** GlitchMr left
[20:02] <TimToady> 'is export' is 'long shorthand' for :export so the rules of :export(:lol, :wut) apply, which is to say it's the same as export => (:lol, :wut)

[20:02] <Celelibi> inception is a fary tale. :)

[20:02] <moritz> jnthn: how about a a Capture containing two pairs?

[20:02] <Celelibi> (Well, I don't thing about Alice in wonderland)

[20:02] <moritz> carlin: as is #perl6. Oh, wait...

[20:03] <moritz> erm, meant Celelibi 

[20:03] <moritz> Celelibi: intellectual milk and honey flow in generally friendly atmosphere

[20:03] <jnthn> TimToady: Oh. :)

[20:03] <jnthn> TimToady: Not the answer I expected, but I can implement that one :)

[20:04] <masak> moritz: though milk flows better than honey.

[20:04] <moritz> masak: yes, but having two different viscosities makes for much more interesting flow patterns

[20:05] <masak> ooh, yes.

[20:05] <masak> (different viscosities)++

[20:05] * TimToady suspects that honey stays liquid-ish at a temperature where milk freezes...

[20:05] * [Coke] , in backscroll, wonders if we can have a Modula-3 TimToady containment breach instead.

[20:06] <TimToady> [Coke]: the breach is Oberon the other side from where you're looking...

[20:06] <masak> if I ever form a post-anarchist unplugged punk duo with someone, I'm gonna name it "Two Different Viscosities".

[20:06] *** fhelmberger joined
[20:08] <masak> TimToady: When you look into an ABSYS, the ABSYS also looks into you.

[20:09] <masak> ooh, ABSYS was a Prolog precursor...

[20:09] <TimToady> well, so?  Neutrinos are into physicists...

[20:09] <geekosaur> and everyone else

[20:10] <Celelibi> masak: this may sound quite sexual in some ways. :)

[20:10] <TimToady> and everything else

[20:12] <masak> Celelibi: I have such an innocent mind that the thought didn't even occur to me.

[20:13] *** Kresike left
[20:13] <Celelibi> I wish I would think a bit less sometime.

[20:14] <masak> that's an unusual wish.

[20:14] <[Coke]> TimToady: *groan*

[20:14] <masak> though not entirely unreasonable.

[20:14] <masak> Celelibi: tried meditation?

[20:14] <tadzik> that's one of the reasons for drinking alcohol, I guess

[20:15] <tadzik> one once said "I drink so I tolerate people I spend my time with"

[20:15] <[Coke]> masak: I often complain that my brain is full. That's almost the same complaint.

[20:15] <Celelibi> masak: actually it's not the "quantity" it's what I think to.

[20:16] <masak> Celelibi: nevertheless.

[20:17] <Celelibi> tadzik: that's right, I'm a bit more open minded when I'm drunk. :)

[20:17] * masak notes for the first time that Celelibi's nick could be seen as a portmanteau of "celibate" and "libido"

[20:17] <tadzik> :>

[20:17] <masak> tadzik: I try to seek out friends that I'm able to stand when sober.

[20:18] <Celelibi> Tell me more about your innocence masak. :)

[20:18] <tadzik> masak: same :)

[20:18] <masak> Celelibi: I was totally not serious. my father is the King of innuendo, srsly.

[20:18] <TimToady> as opposed to friends who will help you stand when you're not sober?

[20:18] <tadzik> :)

[20:19] <masak> TimToady: incidentally, those overlap quite well :)

[20:19] <TimToady> overlap!?!?

[20:19] <masak> *lol*

[20:19] <Celelibi> I learned a new word today: "innuendo".

[20:20] * masak .oO( must be something they put in the #perl6 welcome punch tonight... )

[20:20] <sisar> tadzik: read my earlier comment? re panda build fails

[20:21] <tadzik> sisar: yeah, seen that, but that's the same thing here

[20:21] *** Mescale left
[20:21] *** tyatpi left
[20:22] <sisar> does make parallize on its own or do i need to tell it to ?

[20:22] <Celelibi> is "hyperoperator" synonymous for "meta operator" ?

[20:22] <Celelibi> make -j 8

[20:23] <tadzik> sisar: that's not the thing, sadly :/

[20:23] <sisar> oh, ok, fine :)

[20:23] *** ponbiki left
[20:23] <cognominal> <tadzik> one once said "I drink so I tolerate people I spend my time with".     Paul Valéry said "un homme seul est toujours en mauvaise companie" : a man alone is aways in bad company, but I suppose you did not mean it that way  :)

[20:24] <Celelibi> If I understand correctly in perl6 there are less {} and more <>. :)

[20:24] <tadzik> cognominal: nope :)

[20:24] <masak> Celelibi: no, the hyperops are just a type of metaop.

[20:24] <masak> Celelibi: reduction ops are another type.

[20:25] <Celelibi> hyperoperators are only >> and << ?

[20:25] <masak> aye.

[20:25] <Celelibi> ok

[20:25] <masak> and the things that go between them :)

[20:25] <Celelibi> ok

[20:25] <Celelibi> so >>+<< as a whole is an hyperoperator.

[20:26] <TimToady> yes, we use the term both ways

[20:26] <Celelibi> is >>+>> also one?

[20:26] <TimToady> yes, but that one's dwimmy on the right

[20:27] <Celelibi> dwimmy?

[20:27] <cognominal> I said that Perl 6 is dotty, I forgot to said it was loopy too

[20:27] <TimToady> perl6: say (1,2,3) »+« (1,2)

[20:27] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Ran off end of non-dwimmy right␤  at /home/p6eval/niecza/lib/CORE.setting line 1364 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3020 (ANON @ 19) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3026 (_hyper_posi @ 6) ␤  at …

[20:27] <p6eval> ..pugs: OUTPUT«243␤»

[20:27] <p6eval> ..rakudo d9fd17: OUTPUT«Sorry, lists on both sides of non-dwimmy hyperop are not of same length:␤    left: 3 elements, right: 2 elements␤␤  in sub hyper at src/gen/CORE.setting:10792␤  in block <anon> at src/gen/CORE.setting:10773␤  in block <anon> at /tmp/BygWuXgsSN:1␤␤»

[20:27] <TimToady> perl6: say (1,2,3) »+« (1,2,3)

[20:27] <p6eval> pugs: OUTPUT«246␤»

[20:27] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«2 4 6␤»

[20:27] <TimToady> perl6: say (1,2,3) »+» (1,2)

[20:27] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "\187+\187"␤    expecting operator, ":" or ","␤    at /tmp/3kODkyzBcV line 1, column 13␤»

[20:27] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«2 4 4␤»

[20:28] <TimToady> perl6: say (1..10) »+» (1,2)

[20:28] <p6eval> rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«2 4 4 6 6 8 8 10 10 12␤»

[20:28] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "\187+\187"␤    expecting operator, ":" or ","␤    at /tmp/S1kzO_7N9V line 1, column 13␤»

[20:28] <TimToady> other metaops have different policies, for instance

[20:28] <masak> Celelibi: DWIM means "Do What I Mean", i.e. employ some context-sensitive logic to figure out some thing that is not explicitly stated. in the case of >>+>>, make the right-hand list as long or short as makes sense.

[20:29] <TimToady> perl6: say 1..10 Z+ 1..3

[20:29] <p6eval> pugs: OUTPUT«12345678910␤»

[20:29] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«2 4 6␤»

[20:29] <masak> Celelibi: Perl 5 uses a lot of DWIM that (from the perspective of Perl 6) is considered deprecated.

[20:29] <TimToady> a 'zip' metaop just trims to the shorter of the two lists

[20:29] <Celelibi> ok

[20:29] <TimToady> since you can't have a zipper with only one side

[20:29] * masak was gonna say

[20:30] <Celelibi> And yes, that was a question I had last time. What does mean "make the list as long as needed"?

[20:30] <Celelibi> By repeating its elements?

[20:30] <TimToady> depends on what is making the list as long as needed

[20:30] * masak .oO( innuendo )

[20:30] <TimToady> with hypers, it repeats the short side

[20:31] *** phenny left
[20:31] *** phenny joined
[20:31] <TimToady> with a degenerate (!?!) case that a single element just repeats

[20:33] <Celelibi> ok, and the list extended/shortened is the one on the "small side" of the >>

[20:33] <TimToady> if it's the xx operator, it just repeats the list on the left

[20:34] <Celelibi> what's the equivalent of x operator in perl5?

[20:34] <masak> x

[20:34] <masak> unless you want the list-context variant, then it's xx

[20:34] <TimToady> r: say (1..10) »+» (1..20)

[20:34] <p6eval> rakudo d9fd17: OUTPUT«2 4 6 8 10 12 14 16 18 20␤»

[20:34] <TimToady> yes, the dwimmy side can shorten as well as repeat

[20:34] <Celelibi> r: say (1 .. 10)x2

[20:34] <p6eval> rakudo d9fd17: OUTPUT«===SORRY!===␤Confused␤at /tmp/ToHwjimFfT:1␤»

[20:35] <Celelibi> what's wrong?

[20:35] <TimToady> std: say (1 .. 10)x2

[20:35] <p6eval> std fab64fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Whitespace is required between alphanumeric tokens at /tmp/biESrIXzTw line 1:␤------> [32msay (1 .. 10)x[33m⏏[31m2[0m␤Check failed␤FAILED 00:00 42m␤»

[20:35] <TimToady> n: say (1 .. 10)x2

[20:35] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Whitespace is required between alphanumeric tokens at /tmp/5UXVcpE1LS line 1:␤------> [32msay (1 .. 10)x[33m⏏[31m2[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1364 (die @ 3) …

[20:35] <tadzik> masak: autopun? "Hypochondria is the only illnes I don't have"

[20:35] <TimToady> what's wrong is that rakudo isn't quite using the standard parser yet

[20:37] <jnthn> moritz: Think I've got it workin' :)

[20:38] <Celelibi> but it don't seem to work either with niecza

[20:38] <jnthn> moritz: But it turned out a bunch of other traits were relying on the arg being passed int he wrong way, so been clearing up that.

[20:38] <masak> tadzik: yeah :P

[20:38] <TimToady> n: say (1..10) x 2

[20:38] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«1 2 3 4 5 6 7 8 9 101 2 3 4 5 6 7 8 9 10␤»

[20:38] <masak> tadzik: though I would turn it around for maximum punch.

[20:38] <TimToady> n: say (1..10) xx 2

[20:38] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«1 2 3 4 5 6 7 8 9 10 1 2 3 4 5 6 7 8 9 10␤»

[20:39] <tadzik> masak: I saw it turned around in one film I think

[20:39] <TimToady> Celelibi: it works if you read the error message :P

[20:39] <tadzik> masak: "Hypochondria?" "Yeah, it's the illnes that (...describes...)" "Oh my god. I have that too!"

[20:39] <masak> tadzik: :P

[20:40] *** sivoais left
[20:40] <Celelibi> TimToady: they are hard to read with these escape codes.

[20:40] <masak> tadzik: yeah, I'm probably silly to want to turn it around. the usual way with autopuns is mention + use, in that order.

[20:40] <masak> Celelibi: check the IRC logs.

[20:40] *** fhelmberger left
[20:41] <TimToady> Celelibi: which IRC client are you using?  irssi just shows things in colors, since those are terminal color codes

[20:41] <Celelibi> masak: they're stored in the logs. :)

[20:41] <Celelibi> TimToady: xchat.

[20:41] *** sivoais joined
[20:41] <Celelibi> these are color codes for a terminal, not for irc. :)

[20:41] <TimToady> I'm on a terminal

[20:41] <tadzik> weechat doesn't show them

[20:41] *** birdwindupbird left
[20:42] <geekosaur> mmm, yes, I need a script to do something about the broken ansi x3.64 codes in those

[20:42] <geekosaur> (also xchat)

[20:42] <Celelibi> the best fix would be that p6eval translate them to irc color codes. :)

[20:45] <geekosaur> indeed

[20:45] *** fhelmberger joined
[20:45] <sisar> is http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#Perl_6 using a feature which is NYI in rakudo? coz it hangs Rakudo, but works fine in Niecza.

[20:46] <Celelibi> and so... <<+>> is just like a regular + ?

[20:46] <diakopter> sisar: how long did you wait while it was hanging?

[20:46] <sisar> 2-3 mins...

[20:47] <sisar> should i wait moar ?

[20:47] <diakopter> how long did niecza take

[20:47] <sisar> diakopter: 3 seconds.

[20:47] <diakopter> oh; hm

[20:48] <diakopter> hard to tell (to me)

[20:48] <diakopter> I guess it's worth trying again and waiting longer until someone replies with more knowledge

[20:49] <sisar> diakopter: when people ask the time, should i report the real, user, or sys time ?

[20:49] <diakopter> wall clock, I guess

[20:50] <diakopter> eh

[20:50] <TimToady> Celelibi: it's only like regular + if you feed it two numbers.  Otherwise + will try to coerce to numbers, so lists return the number of elements with bare +, whereas <<+>> will try to apply across lists

[20:50] <sisar> i mean "time perl6 <script-nae>" reports three times, right?

[20:50] <dalek> rakudo/use-arglist: 6fa9034 | jnthn++ | src/ (3 files):

[20:50] <dalek> rakudo/use-arglist: Refactor handling of traits taking named arguments. The argument is now passed along with the name. Updated various of the built-in traits along with this.

[20:50] <dalek> rakudo/use-arglist: review: https://github.com/rakudo/rakudo/commit/6fa90347db

[20:50] <dalek> rakudo/use-arglist: f9a94d8 | jnthn++ | src/core/traits.pm:

[20:50] <dalek> rakudo/use-arglist: Handle export tags.

[20:50] <dalek> rakudo/use-arglist: review: https://github.com/rakudo/rakudo/commit/f9a94d8d09

[20:51] <jnthn> moritz: There you go. :) A test in advent2009-day12.t fails, but looking at it, I think it's wrong.

[20:51] <Celelibi> TimToady: yep I saw. It expand the shortest list.

[20:51] <Celelibi> r: say ((1, 2, 3) X (4, 5, 6)).perl

[20:51] <p6eval> rakudo d9fd17: OUTPUT«((ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),)).list␤»

[20:52] <jnthn> moritz: Also a trait one, but should be an easy fix when merging.

[20:52] <Celelibi> what does that mean? :)

[20:52] <jnthn> r: say ((1, 2, 3) X (4, 5, 6))

[20:52] <masak> Celelibi: means you're in over your head :P

[20:52] <p6eval> rakudo d9fd17: OUTPUT«1 4 1 5 1 6 2 4 2 5 2 6 3 4 3 5 3 6␤»

[20:52] <jnthn> Celelibi: Just Rakudo being lazy :)

[20:52] <jnthn> (That is, not evaluating stuff until it has to.)

[20:52] <Celelibi> ok, these are lazy lists.

[20:53] <jnthn> Looks like...

[20:53] <Celelibi> How do I force the evaluation of an expression?

[20:53] <jnthn> .eager should do it.

[20:53] <jnthn> r: say ((1, 2, 3) X (4, 5, 6)).eager.perl

[20:53] <p6eval> rakudo d9fd17: OUTPUT«((ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),)).list␤»

[20:53] <jnthn> Hm...

[20:53] <[Coke]> jnthn: at this rate, all the advent tests will eventually break. 

[20:53] <jnthn> r: say ((1, 2, 3) X (4, 5, 6)).flat.perl

[20:53] <p6eval> rakudo d9fd17: OUTPUT«(1, 4, 1, 5, 1, 6, 2, 4, 2, 5, 2, 6, 3, 4, 3, 5, 3, 6).list␤»

[20:53] <diakopter> sisar: 60x slower for some operations wouldn't be surprising a while ago; I don't know about recently

[20:53] <[Coke]> as long as we do so intentionally and not accidentally, that's the best I can hopef or.

[20:53] <jnthn> That flattens it out at least.

[20:54] <Celelibi> why flat?

[20:54] <Celelibi> I do not want it flat. :)

[20:54] <jnthn> Celelibi: Well, .tree it or something then :)

[20:54] <TimToady> r: say ((1, 2, 3) X (4, 5, 6)).tree.perl

[20:54] <p6eval> rakudo d9fd17: OUTPUT«([1, 4], [1, 5], [1, 6], [2, 4], [2, 5], [2, 6], [3, 4], [3, 5], [3, 6]).list␤»

[20:54] <jnthn> Celelibi: Things don't commit to flat or structured until you put them in a context that makes them do so.

[20:55] <jnthn> [Coke]: I don't see how this one could ever have worked on an implementation that does import tags correctly.

[20:55] <Celelibi> ok

[20:55] <jnthn> [Coke]: It relies on something being in :DEFAULT, when the exporting module is putting it elsewhere.

[20:55] <Celelibi> then flat method appies a list context in the data.

[20:56] <Celelibi> and tree?

[20:56] *** envi_ left
[20:56] <TimToady> doesn't :)

[20:56] <jnthn> LoL context, or whatever we call it... :)

[20:56] <[Coke]> jnthn: it was 2009. We didn't know any better!

[20:56] <TimToady> lol only goes one level down

[20:56] <jnthn> Troo.

[20:57] <[Coke]> no, *tree*

[20:57] *** _Vi joined
[20:57] <TimToady> and X should be returning Parcels

[20:57] <TimToady> so it can come out (1,4),(1,5),(1,6) etc...

[20:57] <jnthn> [Coke]: :P

[20:57] <jnthn> TimToady: Well, that's just how it comes out once everything gets reified...

[20:58] <jnthn> TimToady: I guess you're saying it's being a bit too lazy?

[20:58] <TimToady> seems so

[20:58] <Celelibi> Hum... My version of rakudo do not evaluate the lazy lists with .tree

[20:58] <TimToady> x knows perfectly well how many elements it's returning each time, and that they're scalars

[20:58] <TimToady> X*

[20:59] <TimToady> it's only the outer list of parcels needs to be lazy

[20:59] <jnthn> TimToady: OK. Maybe masak++ would be so good as to rakudobug this; pmichaud++ may be trolled into fixing it or commenting "yes, just needs X" :)

[20:59] <masak> r: say 1, 2, 3 X* 4, 5, 6

[20:59] <p6eval> rakudo d9fd17: OUTPUT«4 5 6 8 10 12 12 15 18␤»

[21:00] <masak> jnthn: can I do it tomorrow. my mana is too low right now... :)

[21:00] <masak> or someone else could, too...

[21:00] <sisar> "mana" ?

[21:00] <jnthn> masak: Sure :)

[21:00] <TimToady> polynesian god power

[21:00] <jnthn> sisar: masak is fed by food falling from the sky, but not much fell today, depleting his energy...

[21:01] <[Coke]> r: (1..6 X* 1..6).uniq.sort.say

[21:01] <p6eval> rakudo d9fd17: OUTPUT«1 2 3 4 5 6 8 9 10 12 15 16 18 20 24 25 30 36␤»

[21:01] * TimToady wonders if masak has played Populace...

[21:01] *** kaare_ left
[21:02] <[Coke]> masak: coding taks mana and not health? hurm.

[21:02] <TimToady> er, Populous...

[21:02] <[Coke]> *takes

[21:03] <Celelibi> How could I create a lazy list myself?

[21:03] <tadzik> using gather take

[21:03] <Celelibi> To create an infinite list for instance.

[21:04] <tadzik> r: my @a = gather for 1..* { take $_ * 2 }; say @a[^30]

[21:05] <tadzik> eek, eager assignment :/

[21:05] <p6eval> rakudo d9fd17: OUTPUT«(timeout)»

[21:05] <masak> [Coke]: compiler hacking takes mana: http://strangelyconsistent.org/blog/perl-6-is-my-mmorpg

[21:05] <tadzik> r: my @a := gather for 1..* { take $_ * 2 }; say @a[^30]

[21:05] <p6eval> rakudo d9fd17: OUTPUT«2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40 42 44 46 48 50 52 54 56 58 60␤»

[21:05] <Celelibi> := ?

[21:06] <TimToady> there are a number of easier ways to make infinite lists

[21:07] * sisar zz..

[21:07] <masak> Celelibi: binding, as opposed to assignment.

[21:07] <TimToady> it depends on how fancy you need the list to be

[21:07] <TimToady> note that tadzik's example starts with the infinite list 1..*

[21:07] * Celelibi .oO(Y U SO SLOW TO LEARN BRAIN?!)

[21:08] *** skids left
[21:08] <TimToady> (well, techinically, it's an infinite range that gets turning into an infinite list...)

[21:08] <TimToady> and the even numbers are more easily written just as 2,4,6...*

[21:09] <Celelibi> How heavy is the CPU-cost of making a lazy list?

[21:09] <TimToady> so generally you don't need to write your own gather most of the time

[21:09] <TimToady> Celelibi: a lot lighter than generating the whole list

[21:09] <TimToady> </rimshot>

[21:09] <masak> unless the whole list is empty...

[21:09] <TimToady> serious answer: heavier currently than we hope it will be in the future

[21:10] <Celelibi> I hope so, indeed. :)

[21:10] * masak .oO( native lazy lists o.O )

[21:10] <Celelibi> But does it make sens to make every list lazy?

[21:10] <Celelibi> I think not.

[21:11] <TimToady> the compiler is free to optimize when it can determine there's an eager context

[21:11] <Celelibi> I think lists of tenth of elements are not worth lazying.

[21:12] <TimToady> and the lazy implementation is allowed to batch things up for efficiency

[21:12] <Celelibi> what does mean eager actually?

[21:12] <Celelibi> and the gather keyword? And take?

[21:13] <Celelibi> I think "take" means "stop execution here, take this value"

[21:13] <TimToady> gather/take is essentially our coroutine interface, but it's orthogonal to function calls

[21:13] <Celelibi> (and we'll continue execution for the next value)

[21:13] <TimToady> yes, take, is a 'yield'

[21:13] <Celelibi> ok.

[21:13] <TimToady> but easier to spell

[21:14] <Celelibi> indeed.

[21:14] <diakopter> beavers can be eager. gather is a gospel singer/songwriter.

[21:14] <Celelibi> and gather means "lazy expression follow here"?

[21:14] <Celelibi> or lazy list only?

[21:15] <TimToady> it means to set up a coroutine and/or thread

[21:15] <TimToady> with a thread, the insides could work ahead until the pipeline stalls

[21:15] <Celelibi> ok.

[21:15] <TimToady> again, up to the compiler

[21:16] <Celelibi> but the programmer then have to handle the synchronization on its own (if any).

[21:16] <Celelibi> I mean, mutex and stuff.

[21:16] <TimToady> no, the compiler would have to handle the handshaking if it implements it that way

[21:17] <Celelibi> can it?

[21:17] <TimToady> if a gather's code depends on side-effects from outside, then it's likely erroneous

[21:18] <TimToady> but if it depends on other lazy lists, that's okay, since those can block automatically till there are values available

[21:18] <Celelibi> I thought about that, and cannot figure out a use case where this would make sens. But that does not mean it doesn't make sens at all.

[21:18] <TimToady> we're trying to make Perl 6 very multicore/manycore friendly

[21:19] <TimToady> so a lot of the constructs are promising what you don't care about, to give room for the compiler to do whatever is best

[21:19] <TimToady> whether that's mapping to manycores, or pipeline processors, or GPUs...

[21:21] <TimToady> our current compilers don't try to do any of that, so they're necessarily a little slow to emulate parallelism

[21:22] <Celelibi> I think these places where parallelism can occur will have to be well documented since it will be the source of numerous insidious bugs.

[21:23] <Celelibi> If you did some parallel coding you should know how there bugs are hard to track. :)

[21:24] <Celelibi> and randomly appears.

[21:24] <Celelibi> and disappear...

[21:25] <TimToady> certainly, but generally the more you stick to the FP way of doing things, the safer you'll be, since it's usually side effects that get you into trouble

[21:26] <Celelibi> FP? Functionnal programming?

[21:26] <TimToady> OO also helps, insofar as side-effects are encapsulated into objects

[21:26] <TimToady> yes

[21:26] <Celelibi> k

[21:26] <Celelibi> ow ow ow. Does "gather" create a closure?

[21:27] <TimToady> we recognize that we are multiplying the possibilities for people to write erroneous code, but so far we haven't run into many problems

[21:27] <TimToady> the block form does

[21:27] <Celelibi> nice.

[21:27] <TimToady> but usually we just use 'gather' as a prefix for a loop that has its own closure

[21:29] <Celelibi> ok, then this lower the risk of unpredictable behavior.

[21:31] <TimToady> unpredictable behavior is not always completely evil, either, as long as the rocketship stays on course

[21:31] <Celelibi> indeed.

[21:31] <TimToady> the trick is to know when you care, and when you don't

[21:32] <TimToady> so all of the parallel constructs in Perl 6 tend to make you swear that you don't care :)

[21:32] <TimToady> apart from the guarantess of the particular constructs

[21:33] <TimToady> hypers still preserve order, even though they don't care what order the computation proceeds

[21:33] <TimToady> likewise gather will return elements in the order that take sends them

[21:33] <Celelibi> One thing I was thinking about was a lazy/infinite list that rely upon I/O to construct continuous flow of elements. And when the input change, the list elements will eventyally change. You don't know when, you only know this will happen.

[21:33] <Celelibi> -y+u

[21:35] <Celelibi> But well, the lists may not be well suitied for a flow.

[21:35] <Celelibi> (suited?)

[21:36] <TimToady> r: for '/dev/random'.IO.comb -> { say .ord }

[21:36] <p6eval> rakudo d9fd17: OUTPUT«Method 'comb' not found for invocant of class 'IO'␤  in block <anon> at /tmp/rzUIx934xc:1␤␤»

[21:36] <Celelibi> I'm sure there are use case for things like this.

[21:37] *** jferrero joined
[21:37] <TimToady> r: for '/dev/random'.IO.lines».comb -> { say .ord }

[21:37] <p6eval> rakudo d9fd17: OUTPUT«Malformed UTF-8 string␤␤  in method get at src/gen/CORE.setting:6611␤  in code <anon> at src/gen/CORE.setting:6632␤  in sub coro at src/gen/CORE.setting:4926␤  in method reify at src/gen/CORE.setting:4907␤  in method reify at src/gen/CORE.setting:4678␤  in method r…

[21:37] <TimToady> r: for open('/dev/random', :raw).lines».comb -> { say .ord }

[21:37] <p6eval> rakudo d9fd17: OUTPUT«open is disallowed in safe mode␤  in sub restricted at src/SAFE.setting:2␤  in sub open at src/SAFE.setting:5␤  in block <anon> at /tmp/QEoAmVvyp6:1␤␤»

[21:37] <TimToady> aww

[21:40] <TimToady> we don't seem to have any iterating method defined on binary files yet; read just reads a single buf, not a sequence of them

[21:41] <TimToady> and you can't use slurp on an infinite file

[21:41] <Celelibi> thought /dev/random is not infinite /dev/urandom is;

[21:42] <TimToady> anyway, that should certainly be possible, mapping a binary file to a lazy list

[21:42] <TimToady> currently we can do it with .lines on a text file

[21:43] <Celelibi> I think "take" forces the evaluation of its expression.

[21:44] <TimToady> well, on some level that does not include eager-izing the list

[21:45] <TimToady> n: my @a := gather loop { take 2,4,6...* }; say @a[^10]

[21:45] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«(timeout)»

[21:45] <TimToady> innersting

[21:45] <TimToady> r: my @a := gather loop { take 2,4,6...* }; say @a[^10]

[21:45] <p6eval> rakudo d9fd17: OUTPUT«2 4 6 8 10 12 14 16 18 20␤»

[21:45] <TimToady> looks like a nieczabug

[21:45] <Celelibi> how does perl infer the list I want?

[21:46] <Celelibi> r: say 1, 2, 3 ... 10

[21:46] <p6eval> rakudo d9fd17: OUTPUT«1 2 3 4 5 6 7 8 9 10␤»

[21:46] <Celelibi> r: say 1, 3, 5 ... 10

[21:46] <Celelibi> r: say 1, 3, 5 ... 11

[21:46] <p6eval> rakudo d9fd17: OUTPUT«(timeout)»

[21:46] <p6eval> rakudo d9fd17: OUTPUT«1 3 5 7 9 11␤»

[21:46] <TimToady> see S03:1806

[21:46] <Celelibi> r: say 1, 3, 5 ... 10

[21:46] *** Guest40378 left
[21:47] <Celelibi> interesting.

[21:47] <p6eval> rakudo d9fd17: OUTPUT«(timeout)»

[21:47] <TimToady> that's an infinite loop

[21:48] *** _dolmen_ left
[21:51] <TimToady> bbl &

[21:52] *** tyatpi joined
[21:53] *** xenu joined
[21:53] <Celelibi> oh, are closures and thread nice to combine in perl6?

[21:53] *** xenu is now known as Guest21759

[21:54] <Celelibi> I think I made perl5 crash with things like returning a function (with a closure from inside a map coderef or something like that) as a result of a thread.

[22:06] *** jferrero left
[22:12] *** jferrero joined
[22:26] *** whiteknight joined
[22:33] *** James joined
[22:34] *** James is now known as Guest69870

[22:36] *** fhelmberger left
[22:39] <jnthn> 'night, #perl6

[22:41] *** tokuhirom joined
[22:41] *** fgomez left
[22:42] *** PacoAir left
[22:49] *** bluescreen10 left
[22:51] *** fgomez joined
[22:54] *** Guest69870 left
[23:04] *** Timbus left
[23:06] <gfldex> p6: class A { class Str {}; method new() { return Str.new }; }; say A.new.WHAT;

[23:06] <p6eval> pugs: OUTPUT«Str␤»

[23:06] <p6eval> ..rakudo d9fd17, niecza v17-2-gb8fcf85: OUTPUT«Str()␤»

[23:06] *** Timbus joined
[23:06] <gfldex> is there any way to get hold of the outer class name?

[23:07] *** skids joined
[23:08] <gfldex> p6: package A { class Str {}; method foo() { return Str.new }; }; say foo.WHAT;

[23:08] <p6eval> pugs: OUTPUT«*** No such subroutine: "&foo"␤    at /tmp/IziyrsP17y line 1, column 67-75␤»

[23:08] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤A package cannot have methods added at /tmp/3bLD3APrKG line 1:␤------> [32mpackage A { class Str {}; method foo[33m⏏[31m() { return Str.new }; }; say foo.WHAT;[0m␤␤Undeclared routine:␤      'foo' used at line 1␤␤Potential diff…

[23:08] <p6eval> ..rakudo d9fd17: OUTPUT«Useless declaration of a has-scoped method in package␤===SORRY!===␤CHECK FAILED:␤Undefined routine '&foo' called (line 1)␤»

[23:08] <gfldex> p6: package A { class Str {}; method foo() { return Str.new }; }; say (A::foo).WHAT;

[23:08] <p6eval> pugs: OUTPUT«*** No compatible multi variant found: "&A::foo"␤    at /tmp/g4zjF335HE line 1, column 68-74␤»

[23:08] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤A package cannot have methods added at /tmp/eQ4ydRPDaL line 1:␤------> [32mpackage A { class Str {}; method foo[33m⏏[31m() { return Str.new }; }; say (A::foo).W[0m␤␤Potential difficulties:␤  'method' declaration outside o…

[23:08] <p6eval> ..rakudo d9fd17: OUTPUT«Useless declaration of a has-scoped method in package␤Could not find symbol 'A::&foo'␤  in block <anon> at /tmp/x_cIUUBbOz:1␤␤»

[23:08] <gfldex> p6: package A { class Str {}; sub foo() { return Str.new }; }; say (A::foo).WHAT;

[23:08] <p6eval> rakudo d9fd17: OUTPUT«Could not find symbol 'A::&foo'␤  in block <anon> at /tmp/P_yi5zLoUR:1␤␤»

[23:08] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«Potential difficulties:␤  &foo is declared but not used at /tmp/iQmOxjP6q0 line 1:␤------> [32mpackage A { class Str {}; sub foo[33m⏏[31m() { return Str.new }; }; say (A::foo).W[0m␤␤Unhandled exception: Unable to resolve method postcircumfix:<( )> in cl…

[23:08] <p6eval> ..pugs: OUTPUT«Str␤»

[23:09] <gfldex> p6: package A { class Str {}; our sub foo() { return Str.new }; }; say (A::foo).WHAT;

[23:09] <p6eval> pugs: OUTPUT«Str␤»

[23:09] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«Str()␤»

[23:09] <p6eval> ..rakudo d9fd17: OUTPUT«===SORRY!===␤This type cannot box a native string␤»

[23:09] <gfldex> :)

[23:10] <gfldex> n: say Str.^methods;

[23:10] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Unable to resolve method methods in class ClassHOW␤  at /tmp/pHIchPEjyY line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3840 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3841 (module-CORE @ 65) ␤  at …

[23:10] <gfldex> n: say Str.new.^methods;

[23:10] <p6eval> niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Unable to resolve method methods in class ClassHOW␤  at /tmp/jlOmCxTZcI line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3840 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3841 (module-CORE @ 65) ␤  at …

[23:10] <sorear> don't bother

[23:11] <gfldex> p6: package A { class Str {}; our sub foo() { return Str.new }; }; say (A::foo).chomp;

[23:11] <p6eval> pugs: OUTPUT«<obj:Str>␤»

[23:11] <p6eval> ..niecza v17-2-gb8fcf85: OUTPUT«Unhandled exception: Unable to resolve method chomp in class Str␤  at /tmp/BusWEUMYFX line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3840 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3841 (module-CORE @ 65) ␤  at /home/p…

[23:11] <p6eval> ..rakudo d9fd17: OUTPUT«===SORRY!===␤This type cannot box a native string␤»

[23:11] <gfldex> niecza is doing the right thing as it seams

[23:12] * gfldex finds his rakudobug pencil

[23:13] *** REPLeffect left
[23:13] *** REPLeffect joined
[23:14] <moritz> r: my $f = open(:bin, '/dev/urandom'); say $f.read(20)

[23:14] <p6eval> rakudo d9fd17: OUTPUT«open is disallowed in safe mode␤  in sub restricted at src/SAFE.setting:2␤  in sub open at src/SAFE.setting:5␤  in block <anon> at /tmp/CslPnRpCyt:1␤␤»

[23:14] <moritz> r: my $f = '/dev/urandom'.IO; say $f.read(20)

[23:14] <p6eval> rakudo d9fd17: OUTPUT«Method 'read_bytes' not found for invocant of class 'Any'␤  in method read at src/gen/CORE.setting:6638␤  in block <anon> at /tmp/KwbBSL_MsL:1␤␤»

[23:15] *** _ilbot left
[23:15] *** _ilbot joined
[23:16] <gfldex> std: package A { class Str {} our sub foo() }

[23:16] <p6eval> std fab64fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/oUZxkkwmjC line 1:␤------> [32mpackage A { class Str {}[33m⏏[31m our sub foo() }[0m␤    expecting any of:␤  infix or meta-infix␤    infixed function␤       statement…

[23:16] <gfldex> std: package A { class Str {} sub foo() }

[23:16] <p6eval> std fab64fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/QgsC1Eytse line 1:␤------> [32mpackage A { class Str {}[33m⏏[31m sub foo() }[0m␤    expecting any of:␤      infix or meta-infix␤    infixed function␤       statement

[23:16] <p6eval> ..mod…

[23:16] <gfldex> std: package A { class Str {} sub foo(){} }

[23:16] <p6eval> std fab64fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/QFqrtjHfGG line 1:␤------> [32mpackage A { class Str {}[33m⏏[31m sub foo(){} }[0m␤    expecting any of:␤    infix or meta-infix␤    infixed function␤       statement

[23:16] <p6eval> ..m…

[23:16] <gfldex> std: package A { class Str {}; sub foo(){} }

[23:16] <p6eval> std fab64fc: OUTPUT«ok 00:00 41m␤»

[23:17] <dalek> tablets: 62f4516 | (Herbert Breunung)++ | docs/tablet-2-basic-syntax.txt:

[23:17] <dalek> tablets: start working on tablet 2

[23:17] <dalek> tablets: review: https://github.com/perl6/tablets/commit/62f4516c60

[23:18] *** fgomez left
[23:20] *** fgomez joined
[23:25] *** Timbus left
[23:25] *** Timbus joined
[23:33] <raiph> re: "The Strong Turing Test: emulating you so well that you don't know whether you're the real you or not..."; http://www.newbanner.com/SecHumSCM/WhereAmI.html

[23:45] *** jferrero left
[23:49] *** Chillance left
[23:53] *** NamelessTee left
