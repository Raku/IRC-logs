[00:01] <jnthn> er, if you leave that in QAST::Node you don't save any memory.

[00:01] <jnthn> hm...that error is legit and not so easy to fix...

[00:05] *** fgomez joined
[00:09] *** att__ is now known as att_

[00:09] <jnthn> sleep &

[00:10] *** att_ is now known as att__

[00:12] <lue> good knight jnthn o/

[00:16] <dalek> rakudo/stdier: c5e946f | jnthn++ | src/Perl6/Grammar.pm:

[00:16] <dalek> rakudo/stdier: A little STD alignment.

[00:16] <dalek> rakudo/stdier: 

[00:16] <dalek> rakudo/stdier: Gets us a panic where STD has one and we lacked it, plus a bogus

[00:16] <dalek> rakudo/stdier: statement error that was also missing.

[00:16] <dalek> rakudo/stdier: review: https://github.com/rakudo/rakudo/commit/c5e946f855

[00:18] *** quester joined
[00:27] *** pmurias left
[00:28] *** rindolf left
[00:44] *** MayDaniel left
[00:46] *** cognominal left
[01:04] *** pecastro joined
[01:14] *** pecastro left
[01:14] *** fgomez left
[01:14] *** erkan left
[01:14] *** xinming_ left
[01:14] *** PacoAir left
[01:14] *** sizz left
[01:14] *** mj41 left
[01:14] *** fgomez joined
[01:15] *** xinming joined
[01:15] *** sizz joined
[01:15] *** erkan joined
[01:15] *** erkan left
[01:15] *** erkan joined
[01:15] *** PacoAir joined
[01:15] *** odoacre joined
[01:15] *** pecastro joined
[01:15] *** mj41 joined
[01:19] *** phenny joined
[01:27] *** pecastro left
[01:28] *** mikemol joined
[01:31] *** pecastro joined
[01:36] *** bowtie left
[01:43] *** pecastro left
[01:43] *** pecastro joined
[01:46] *** xinming left
[01:47] *** xinming joined
[01:49] *** hash_table joined
[01:56] *** pecastro left
[02:05] *** lichtkind left
[02:12] <dalek> tablets: 696f770 | (Herbert Breunung)++ | docs/appendix-a-index.txt:

[02:12] <dalek> tablets: explain indent in A

[02:12] <dalek> tablets: review: https://github.com/perl6/tablets/commit/696f770d96

[02:21] *** hash_table left
[02:21] *** FROGGS_ joined
[02:24] *** FROGGS left
[02:32] *** PacoAir left
[02:35] <dalek> tablets: f5b74af | (Herbert Breunung)++ | docs/appendix- (2 files):

[02:35] <dalek> tablets: adding TABSTOP-compiler-var

[02:35] <dalek> tablets: review: https://github.com/perl6/tablets/commit/f5b74af39e

[02:35] <dalek> tablets: 5c87432 | (Herbert Breunung)++ | docs/appendix-a-index.txt:

[02:35] <dalek> tablets: adding tim variants

[02:35] <dalek> tablets: review: https://github.com/perl6/tablets/commit/5c874320f8

[02:57] *** fgomez left
[03:01] <lue> Can knowhows (in nqp) inherit anything?

[03:01] *** wamba left
[03:03] *** benabik joined
[03:18] <PerlJam> GlitchMr++  Thanks. Yesterday and today did *not* go as planned for me.

[03:19] <PerlJam> (I was without internet until just a little while ago)

[03:23] <flussence> rpn: say $*EXECUTABLE_NAME

[03:23] <p6eval> niecza v24-5-g599cbcb: OUTPUT«/home/p6eval/niecza/run/Niecza.exe␤»

[03:23] <p6eval> ..rakudo 53daef: OUTPUT«./nom-inst/bin/perl6␤»

[03:23] <p6eval> ..pugs: OUTPUT«␤»

[03:24] <flussence> is there any easy way to do "shell($self ...)" type things?

[03:25] <flussence> (right now I've got it hardcoded to 'perl6 ...', which isn't very niecza-friendly...)

[03:28] *** fgomez joined
[03:29] *** whiteknight left
[03:30] *** noggle joined
[03:34] *** noggle_ left
[03:40] <lue> shell($*EXECUTABLE_NAME ~ "rest of the command"), I would think (or "$*EXECUTABLE_NAME rest of it", if you prefer)

[03:41] <flussence> yeah, but that won't work with niecza because it needs "mono" prepending to it if you don't have binfmt_misc stuff set up...

[03:42] <flussence> (I wonder if prepending xdg-open to it would make things better or worse...)

[03:43] *** xinming left
[03:43] <lue> my $prefix = $*EXECUTABLE_NAME ~~ /Niecza/ ?? "mono " !! ""; shell($prefix ~ $*EXECUTABLE_NAME ~ "args");

[03:44] *** xinming joined
[04:12] *** erkan left
[04:37] *** Psyche^ joined
[04:38] *** cooper_ joined
[04:40] *** Patterner left
[04:40] *** Psyche^ is now known as Patterner

[04:44] *** xinming_ joined
[04:47] *** xinming left
[04:58] *** daniel-s__ joined
[04:59] *** tokuhiro_ joined
[05:01] *** daniel-s_ left
[05:02] *** wooden left
[05:05] *** hash_table joined
[05:13] *** wooden joined
[05:13] *** wooden left
[05:13] *** wooden joined
[05:22] *** cooper_ left
[05:22] *** brahmam joined
[05:23] <brahmam> is perl6 interpreted or compiled

[05:24] <shachaf> Languages aren't interpreted or compiled.

[05:26] <brahmam> what is the end output.. i mean executable code...

[05:26] <brahmam> i am very very new to perl

[05:26] <shachaf> The end output of what?

[05:26] <brahmam> like.. in java... the class file

[05:27] <shachaf> Languages can be either interpreted or compiled, depending on whether you use an interpreter or a compiler. Perl 6 has both, as far as I know.

[05:27] <sorear> All known implementations of Perl 6 have both an interpreter and a compiler.

[05:27] <brahmam> do perl5 has compiler too..

[05:27] <sorear> Yes.

[05:28] <brahmam> so what is the executable file of perl script file..

[05:28] <doy> basically all non-toy languages have a compiler of some sort

[05:29] <brahmam> sorry... doy.. i didn't get you... what do you mean by non-toy languages... you mean which are not something fo experts..

[05:30] <brahmam> for*

[05:32] <doy> brahmam: what are you actually asking here?

[05:32] *** daniel-s__ left
[05:33] <brahmam> one of my collegue said compiler based langs perform better than interpreter based..

[05:33] <doy> that depends entirely on the compiler and interpreter involved

[05:34] <brahmam> i am basically a oracle DBA, i want to design a tool, something like sql*plus, which can connect to any db ie. oracle,mysql, db2 or SQL Server with same syntax you are comfortable with..

[05:34] *** telex left
[05:34] <doy> i suggest trying out the languages you're interested in and seeing if they are fast enough

[05:35] <brahmam> its basically converting the string entered by the user... to the equivalent of the target database, something lik ORM tools do..

[05:35] <doy> perl 5 can do something like that via SQL::Abstract

[05:36] <doy> i'm not sure if perl 6 has something similar

[05:37] <brahmam> as i am new to perl.... is it worth giving a shot at ...i want to take expert's advise..

[05:37] *** telex joined
[05:37] <brahmam> i am good at sql, plsql and a little bit with java

[05:44] *** xinming joined
[05:44] *** hash_table left
[05:47] *** xinming_ left
[05:59] *** daniel-s joined
[06:00] *** brahmam left
[06:09] *** daniel-s left
[06:17] *** daniel-s joined
[06:20] *** angelolicastro joined
[06:28] *** angelolicastro left
[06:30] *** daniel-s left
[06:34] *** SamuraiJack joined
[06:37] *** daniel-s joined
[06:41] *** angelolicastro joined
[06:44] *** angelolicastro left
[07:07] *** fgomez left
[07:17] *** fgomez joined
[07:34] <moritz> good morning

[07:34] <moritz> jnthn: yes, qast-sink-1 still segfaults

[07:41] *** wamba joined
[07:42] *** quester left
[08:01] <grondilu>  do you guys know the equivalent of  <pattern>* % ':' in perl5 ?

[08:03] <grondilu> maybe I have to repeat the pattern for the end:  (?:<pattern>:)* <pattern>

[08:08] <moritz> yes, that's it

[08:19] *** tokuhir__ joined
[08:19] *** tokuhiro_ left
[08:22] <FROGGS_> morning

[08:24] *** kaare_ joined
[08:35] <moritz> \o FROGGS_ 

[08:35] *** Liz joined
[08:35] *** Liz is now known as lizmat

[08:36] *** Chillance left
[08:36] <FROGGS_> masak: if I read you advent post right, rakudo will gain speed when doing all alternations of the LTM in different threads?

[08:39] <FROGGS_> masak++ # btw, good post

[08:39] <FROGGS_> morning moritz 

[08:50] <FROGGS_> moritz: what do you think about throwing typed warning/exceptions from modules?

[08:51] <FROGGS_> should be use a namespace pattern? X::Module::<Modulename> ? or X::<Modulename> or ... ?

[08:52] <moritz> FROGGS_: X::<Modulename>::YourError

[08:52] <moritz> though usually grouped not by module, but by distribution

[08:58] <dalek> perl6.org: d0a4b8e | (Juan Francisco Cantero Hurtado)++ | source/documentation/index.html:

[08:58] <dalek> perl6.org: Update link to the last "Using Perl 6" snapshot

[08:58] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/d0a4b8ea2f

[09:20] <masak> mornin', #perl6

[09:21] <masak> FROGGS_: theoretically, alternations of the LTM could be done in different threads. but something tells me there's not such a big speed gain to be had in that.

[09:21] <masak> because each alternation is fairly short, and would probably be dwarfed by threading overhead.

[09:23] <masak> FROGGS_: no, the real benefit is that conceptually, a DFA doesn't "go back" and try the next alternation from the last branch point. instead, the DFA tries all alternations conceptually "at once". by the end, all the non-matching alternations have been eliminated.

[09:23] <lizmat> morning masak

[09:23] <moritz> morning masak and lizmat 

[09:26] <masak> morning lizmat and moritz 

[09:26] <masak> wow, reading brahmam's question in the backlog is interesting.

[09:27] <masak> I could easily see myself asking such a question a couple of years back.

[09:27] <masak> especially the "a colleague said a compiler is faster than an interpreter, is it true?" question.

[09:28] <masak> but from my current vantage point, it just feels like brahmam is asking from within a great fog, and the answers barely reach back in to him.

[09:31] <masak> lichtkind: in https://github.com/perl6/tablets/commit/696f770d96 , why do you call it a "string object" when "string" is adequate? we don't talk of "integer objects" or "boolean objects" either.

[09:36] *** GlitchMr joined
[09:40] *** ifim left
[09:41] *** wamba left
[09:43] *** Pleiades` left
[09:48] *** Pleiades` joined
[09:49] *** wamba joined
[09:56] <GlitchMr> https://gist.github.com/4244090

[09:56] <GlitchMr> Example of something that is easy in AWK and Perl 6, but hard in Perl 5.

[09:57] <masak> oh, it's awk.

[09:57] <masak> I was wondering what weird dialect of Perl that was :)

[09:57] <GlitchMr> I've choosed Perl just for syntax highlighting.

[09:59] <GlitchMr> In Perl 5 it looks simple: join ',', map quotemeta, @words... except that actually doesn't work

[09:59] <GlitchMr> oops

[09:59] <GlitchMr> join '|', map quotemeta, @words

[10:00] <masak> nowadays I'm always suspicious of the practice of building sublanguages using strings.

[10:00] <masak> not only because of the general risk of injection attacks, but because of the crudeness of the approach.

[10:01] <GlitchMr> This is what PHP people do, I know. Oh, and Perl 5 with its regexpes.

[10:01] <GlitchMr> Also, oops, my approach is simply wrong. It assumes array isn't empty.

[10:04] <GlitchMr> It should be fixed now

[10:05] <tadzik> ah, the ol' "interpreted vs compiled" debate...

[10:06] <tadzik> doog morning #perl6

[10:06] <GlitchMr> But... only UNIX shell language is popular interpreted language.

[10:06] <GlitchMr> Other languages are compiled.

[10:07] <GlitchMr> Perhaps they aren't compiling programs to files, but they still compile programs.

[10:07] <sorear> GlitchMr: unix shell is actually pretty compiled

[10:08] <GlitchMr> Why program like this is valid then:

[10:08] <GlitchMr> exit

[10:08] <GlitchMr> ds'gew;tewv tv'ewrr.c24'r32$C"#@R?X"#@>""~``"3c;xe@"#:ex'@

[10:08] <sorear> because compilation occurs one line at a time

[10:08] <sorear> s/line/top-level statement/

[10:08] <sorear> wrap that program in an if true; then ... fi and it won't compile.

[10:09] <GlitchMr> Well, ok, that program had valid syntax

[10:10] <GlitchMr> But perhaps something involving $) or something.

[10:10] <GlitchMr> exit

[10:10] <GlitchMr> $)

[10:11] <GlitchMr> In if true; then ... fi it isn't valid anymore

[10:17] <masak> tadzik: it's silly. "compilation" is just a kind of translation. computers do it all the time. "interpretation" is just a switch statement in a loop. computers do that all the time too.

[10:17] <masak> which one is faster? the question almost isn't well-posed.

[10:18] <GlitchMr> Is Brainfuck interpreted or not (answer: depends on implementation)?

[10:20] <masak> yes, and that's what people answered brahmam in the backlog.

[10:22] <sorear> as someone who has spent a non-neglible amount of time studying CPU design, let me say that *everything* is interpreted...

[10:23] <masak> aye.

[10:23] <sorear> besides, transistors are a physics-based system for interpreting Boolean algebra.  and some people say even physics is an interpreter...

[10:25] * masak is struck by how the Church booleans look a bit like abstract transistors

[10:25] *** xinming left
[10:28] *** PacoAir joined
[10:31] *** kivutar joined
[10:33] <jnthn> morning o/

[10:34] <sorear> o/ jnthn

[10:34] <jnthn> An interpreter is just something that processes instructions and takes actions based on them. If the input to the process is different from the thing that gets interpreted, then there's a compiler inbetween the two performing that translation.

[10:34] <masak> jnthn! \o/

[10:34] <tadzik> there's no one to convince anymore :)

[10:34] <jnthn> Aye, just thought that was a nice way of putting it :)

[10:35] <masak> aye.

[10:38] <lizmat> which would make perl* a compiler?

[10:40] <jnthn> lizmat: Sure, it doesn't work directly off the source code, but instead interprets a tree structure.

[10:40] <moritz> well, perl 5 contains both a compiler and an interpreter

[10:40] <jnthn> Right.

[10:40] <moritz> as does Rakudo

[10:40] <lizmat> indeed…  so it's getting foggier and foggier, no?

[10:40] <lizmat> who cares anyway…  :-)

[10:41] <lizmat> as sorear pointed out, it's all interpreted by the CPU anyway   :-)

[10:41] <moritz> right, it's all a continuum these days

[10:41] <jnthn> I suspect people are more inclined to believe things are compilers when they feed source code in and get some other file containing some other form of the program out.

[10:45] *** cognominal joined
[10:59] * lizmat welcomes cognominal

[11:05] *** rindolf joined
[11:05] *** MayDaniel joined
[11:05] *** Su-Shee_ joined
[11:08] <jnthn> moritz: hm, qast-sink-1 doesn't actually build now. 

[11:08] * jnthn merges from nom

[11:09] *** Su-Shee left
[11:09] <sorear> sleep&

[11:09] <shachaf> jnthn: Well, that *is* what a compiler is.

[11:09] <shachaf> For a sufficiently broad meaning of "file", anyway.

[11:09] *** birdwindupbird joined
[11:11] <dalek> rakudo/qast-sink-1: e2f2dc4 | moritz++ | src/Perl6/Metamodel/RolePunning.pm:

[11:11] <dalek> rakudo/qast-sink-1: fix nqp::can(role { }, "anything"). jnthn++

[11:11] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/e2f2dc436d

[11:11] <dalek> rakudo/qast-sink-1: 6b01881 | jnthn++ | src/ (2 files):

[11:11] <dalek> rakudo/qast-sink-1: Start showing context, with eject marker.

[11:11] *** dalek joined
[11:11] *** ChanServ sets mode: +v dalek

[11:12] <moritz> jnthn: ah, it probably didn't like the new NQP cursor factoring

[11:13] <jnthn> yeah

[11:13] <jnthn> now I get the segfaul

[11:13] <jnthn> *segfault

[11:13] <jnthn> and...urgh

[11:14] <lizmat> glad you can reproduce now,…  I thought I was going crazy yesterday

[11:14] <moritz> lizmat: but it's a different branch

[11:14] <cognominal> \o everyone. lizmat sitting by me

[11:15] <lizmat> well, the revert jnthn suggested, fixed the pb for me

[11:15] <jnthn> lizmat: No no, different segfaults...

[11:15] <lizmat> :-(

[11:15] <jnthn> lizmat: Yours is worrying 

[11:16] <jnthn> moritz: Oh.

[11:16] <jnthn> It's nothing to do with sink.

[11:17] <jnthn> moritz: If I git revert 17bcd9649 it fixes it

[11:19] *** spider-mario joined
[11:27] <moritz> erm, WTF.

[11:28] <moritz> I introduced that commit to avoid a different bug with sinking, which I hadn't triaged yet

[11:30] <dalek> rakudo/qast-sink-1: c6b1d85 | jnthn++ | src/core/Parameter.pm:

[11:30] <dalek> rakudo/qast-sink-1: my-scope the Parameter constants.

[11:30] <dalek> rakudo/qast-sink-1: 

[11:30] <dalek> rakudo/qast-sink-1: For one because they should be, for two because it avoids a bug (that

[11:30] <dalek> rakudo/qast-sink-1: will need some separate tracking down).

[11:30] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/c6b1d85ae0

[11:30] <jnthn> moritz: ^ gets you constant and no segfaults :)

[11:32] <jnthn> moritz: Somehow we're losing lvalue nature of things somewhere...

[11:35] <jnthn> r: my %h = a => 42; for %h.pairs { .value += 100 }; say %h<a>

[11:35] <p6eval> rakudo 53daef: OUTPUT«42␤»

[11:35] <jnthn> r: my %h = a => 42; for %h.kv { .value += 100 }; say %h<a>

[11:35] <p6eval> rakudo 53daef: OUTPUT«No such method 'value' for invocant of type 'Str'␤  in block  at /tmp/d2wS_JebRZ:1␤␤»

[11:35] <jnthn> r: my %h = a => 42; for %h.kv -> $k, $v is rw { $v += 100 }; say %h<a>

[11:35] <p6eval> rakudo 53daef: OUTPUT«42␤»

[11:36] <jnthn> oh, that's not what the test is doing at all

[11:37] <jnthn> oh...it's something with try.

[11:38] <jnthn> r: try for 1..10 { .say }; say 'ok'

[11:38] <p6eval> rakudo 53daef: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤ok␤»

[11:38] <jnthn> moritz: ^ in qast-sink-1 only says the 'ok'

[11:39] *** MayDaniel left
[11:40] <moritz> so, try isn't sunk yet

[11:40] <jnthn> yeah

[11:40] <jnthn> try-ing a patch for that ;)

[11:41] <moritz> I guess we will uncover several missing pieces

[11:41] <moritz> one I know about is

[11:41] <moritz> r: my $x = 0; while $x++ < 5 {  for 1 { say } }; say 'ok'

[11:41] <p6eval> rakudo 53daef: OUTPUT«␤␤␤␤␤ok␤»

[11:41] <moritz> r: my $x = 0; while $x++ < 5 {  for 1 { .say } }; say 'ok'

[11:41] <p6eval> rakudo 53daef: OUTPUT«1␤1␤1␤1␤1␤ok␤»

[11:42] <moritz> that one only prints the last 1\n currently

[11:42] <moritz> I guess that needs modification to the codegen of loops

[11:43] <moritz> r: my $x = 0; while True { last if $x++ > 2; $x }

[11:43] <p6eval> rakudo 53daef:  ( no output )

[11:43] <moritz> r: my $x = 0; say do while True { last if $x++ > 2; $x }

[11:43] <p6eval> rakudo 53daef: OUTPUT«True␤»

[11:43] <moritz> oh, the return value is the condition?

[11:43] <moritz> then I guess the block just needs to be sunk always

[11:45] <moritz> r: my $x = 0; say do while $x++ < 5 { 1 }

[11:45] <p6eval> rakudo 53daef: OUTPUT«False␤»

[11:45] <dalek> rakudo/qast-sink-1: f122e60 | jnthn++ | src/Perl6/Actions.pm:

[11:45] <dalek> rakudo/qast-sink-1: Sink 'handle'.

[11:45] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/f122e60281

[11:45] <moritz> 'handle' handles exceptions?

[11:47] <jnthn> Yeah

[11:47] <jnthn> That got us back a couple of tests

[11:47] <jnthn> ah

[11:47] <jnthn> I see why the keybag ones explode.

[11:48] <jnthn> It does something like sub choose { ... for @blah -> $m { if ... { return $m } else { ... } } }

[11:48] <jnthn> And now that for is not eagerly evaluated, the return can happen too late

[11:50] <moritz> r: eager for ^5 { .say }

[11:50] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/aa2PkFW03V:1␤------> [32meager for ^5 [33m⏏[31m{ .say }[0m␤»

[11:50] <moritz> r: eager do for ^5 { .say }

[11:50] <p6eval> rakudo 53daef: OUTPUT«0␤1␤2␤3␤4␤»

[11:50] <moritz> std: eager for ^5 { .say }

[11:50] <p6eval> std a8bc48f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unexpected block in infix position (two terms in a row, or previous statement missing semicolon?) at /tmp/3WEPxvIVaP line 1:␤------> [32meager for ^5 [33m⏏[31m{ .say }[0m␤    expecting infix or meta-infix␤Parse failed␤FAILED 00:00 4…

[11:50] <moritz> might be neat to have that one work (ie eager as a statement prefix)

[11:51] <jnthn> yeah

[11:51] <jnthn> std: eager do for ^5 { .say }

[11:51] <p6eval> std a8bc48f: OUTPUT«ok 00:00 43m␤»

[11:51] <jnthn> Trying that for now

[11:53] *** MayDaniel joined
[11:58] *** xinming joined
[11:58] *** whiteknight joined
[12:00] <FROGGS_> masak: what is a DFA?

[12:00] *** erkan joined
[12:00] *** erkan left
[12:00] *** erkan joined
[12:00] <GlitchMr> FROGGS_: https://en.wikipedia.org/wiki/Deterministic_finite_automaton

[12:01] <dalek> rakudo/qast-sink-1: c481a55 | jnthn++ | src/core/Bag.pm:

[12:01] <dalek> rakudo/qast-sink-1: Fix bag and keybag failures.

[12:01] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/c481a559da

[12:01] <GlitchMr> Regexes can be converted to DFA.

[12:02] <GlitchMr> s/Regexes/Regular expressions/

[12:02] <GlitchMr> https://en.wikipedia.org/wiki/Regular_language

[12:06] *** Su-Shee_ is now known as Su-Shee

[12:10] *** tokuhir__ left
[12:11] *** tokuhiro_ joined
[12:12] *** PZt left
[12:13] <moritz> sets are unordered, right?

[12:14] <moritz> there are some tests that assume otherwise

[12:14] <jnthn> Yes, unordered.

[12:15] <dalek> roast: ad3da93 | moritz++ | S02-types/set.t:

[12:15] <dalek> roast: sets are unordered, so do not assume that .list preserves order

[12:15] <dalek> roast: review: https://github.com/perl6/roast/commit/ad3da93df5

[12:15] *** PZt joined
[12:15] *** tokuhiro_ left
[12:16] <jnthn> moritz: Any idea what the hash-interpolation.t one is about?

[12:16] * jnthn is working on some of the type-var related ones

[12:18] <moritz> jnthn: hash assignment is half broken

[12:18] <moritz> jnthn: it's the while-not-sinking-its-last-statement bug

[12:21] <moritz> jnthn: do you want to fix that, or should I try (with aid from you, I hope :-) ?

[12:24] *** kivutar left
[12:26] <jnthn> moritz: I'm just trying to find where the exact semantics of this are spec'd/tested

[12:26] <moritz> n: my $x = 3; say do while $x-- > 0 { 42 }

[12:26] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Nil␤»

[12:26] <moritz> n: my $x = 3; say do for ^3 { 42 }

[12:26] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/gdKt1Y6Lnu line 1:␤------> [32mmy [33m⏏[31m$x = 3; say do for ^3 { 42 }[0m␤␤Nil␤»

[12:28] <jnthn> n: my $x = 0; say do while $x { 1 }

[12:28] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Nil␤»

[12:28] *** MayDaniel left
[12:29] <jnthn> n: my $x = 0; say do until $x { ++$x }

[12:29] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Nil␤»

[12:29] <jnthn> r: my $x = 0; say do until $x { ++$x }

[12:29] <p6eval> rakudo 53daef: OUTPUT«1␤»

[12:29] <jnthn> r: my $x = 0; say do until $x { ++$x; 2 }

[12:29] <p6eval> rakudo 53daef: OUTPUT«1␤»

[12:29] <jnthn> Here's the thing: S04 says:

[12:29] <jnthn> The value of a loop statement is the list of values from each

[12:30] <jnthn> iteration.  Each iteration's value is returned as a single "argument"

[12:30] <jnthn> object.  See L<S02> for a long definition of argument, but in short,

[12:30] <jnthn> it's either an ordinary object or a parcel containing multiple values.

[12:32] <jnthn> There's not a single spectest match for do while/do repeat/do until/do loop.

[12:33] <moritz> hrmpf

[12:34] <moritz> I can see how that is consistent with for loops, but I don't know how useful it is

[12:34] <jnthn> Either way, it doesn't change that the loop body should be in sink context.

[12:35] <moritz> erm

[12:35] <jnthn> er, wait

[12:35] <moritz> if the values are collected, they aren't in sink context

[12:35] <jnthn> Right

[12:35] <moritz> unless the loop itself is in sink context

[12:35] <jnthn> *nod*

[12:35] <jnthn> argh

[12:36] <jnthn> Every time I fix something in this branch, it breaks more things.

[12:36] <moritz> I know that feeling :(

[12:36] <lizmat> just for my sanity: what is the difference between sink and void context?

[12:37] <moritz> lizmat: the name

[12:37] <lizmat> aha, ok

[12:37] <lizmat> I guess sink is easier to type than void  :-)

[12:40] *** bowtie joined
[12:42] <dalek> perl6-examples: 562f7bd | (L. Grondin)++ | rosalind/nwck-grondilu.pl:

[12:42] <dalek> perl6-examples: [rosalind] NWCK

[12:42] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/562f7bdad4

[12:42] <felher> masak++ #nice post about longest token matcing :)

[12:45] <dalek> nqp: 03aa465 | jnthn++ | src/ops/nqp.ops:

[12:45] <dalek> nqp: Make nqp::isconcrete safe on PMCs.

[12:45] <dalek> nqp: review: https://github.com/perl6/nqp/commit/03aa46598a

[12:46] <dalek> rakudo/qast-sink-1: 63659db | jnthn++ | src/Perl6/ (2 files):

[12:46] <dalek> rakudo/qast-sink-1: Fix explosions when trying to sink typevars.

[12:46] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/63659dbbd1

[13:03] <dalek> rakudo/qast-sink-1: 469768f | jnthn++ | src/Perl6/Actions.pm:

[13:03] <dalek> rakudo/qast-sink-1: Ensure loop bodies are sunk.

[13:03] <dalek> rakudo/qast-sink-1: 

[13:03] <dalek> rakudo/qast-sink-1: In the future we need to implement the non-sink-context loop stuff,

[13:03] <dalek> rakudo/qast-sink-1: but since it's never worked before (except for 'for' of course) and

[13:03] <dalek> rakudo/qast-sink-1: is untested, it's fine to put that aside for now.

[13:03] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/469768f06b

[13:03] <jnthn> moritz: OK, things look a bit better now.

[13:03] <jnthn> moritz: At lesat S02 and S03 tests seem clean.

[13:03] <jnthn> moritz: And all the failing date/calendar related ones no longer fail.

[13:05] <lizmat> r: my $a= sub { say "foo" }; $a.perl

[13:05] <p6eval> rakudo 53daef:  ( no output )

[13:05] <lizmat> r: my $a= sub { say "foo" }; say $a.perl

[13:05] <p6eval> rakudo 53daef: OUTPUT«sub() { ... }␤»

[13:06] <lizmat> is that correct that the output just has a … in there?

[13:06] <jnthn> To do otherwise would mean that we have to carry around the entire source code in the compiled output.

[13:07] <jnthn> So yes, it's working as intended.

[13:07] <jnthn> Or at least, as *I* intended. :)

[13:08] <lizmat> fair enough...

[13:08] <lizmat> just discussing ovid's use of B::Deparse for his Perl 5 code deduplication module that he's working on

[13:08] <lizmat> and I was wondering how that would work in Perl 6

[13:09] <jnthn> In Perl 6 we should probably be building such things at the AST level.

[13:10] <jnthn> moritz: ooh, eek

[13:10] <jnthn> moritz: When we sink "try", we sink the exception that gets caught in the catchless case, it seems

[13:10] <jnthn> moritz: And that then gets thrown, iiuc.

[13:12] <jnthn> moritz: That seems to be the issue in the S04-phasers/next.t anyways...

[13:17] <lizmat> jnthn: doesn't the debugger do something like that?

[13:18] <jnthn> moritz: Yes, the debugger works off the AST

[13:18] <jnthn> er

[13:18] <jnthn> lizmat: ^^

[13:19] * lizmat makes mental note to look at the debugger guts some more

[13:20] <jnthn> moritz: Need to go do other stuff for a bit now, but hope those commits help get sink further along :)

[13:21] <jnthn> lizmat: The debugger isn't terribly much code. 

[13:22] <lizmat> jnthn: indeed…. and probably the basis for a lot of other nice things...

[13:41] <moritz> jnthn: ok, thanks for the sinking so far :-)

[13:41] <moritz> will look a bit more at it soonish, though I don't know yet when

[13:41] *** MayDaniel joined
[13:44] *** sizz left
[13:44] *** lizmat left
[13:44] *** Liz joined
[13:44] *** Pleiades` left
[13:45] *** Liz is now known as Guest13393

[13:48] *** sizz joined
[13:50] *** Pleiades` joined
[14:59] *** Guest13393 is now known as lizmat

[15:09] <lizmat> r: macro marco { die 1 }; say marco

[15:09] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤1␤at /tmp/Bu8sEMKkwA:1␤------> ␤»

[15:09] <lizmat> r: macro marco { die 1 }

[15:09] <p6eval> rakudo 53daef:  ( no output )

[15:10] <lizmat> r: macro marco { die 1 }; marco

[15:10] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤1␤at /tmp/d8ep3hPwwl:1␤------> ␤»

[15:12] <jnthn> hmm, that location marker is LTA

[15:15] * lizmat was just going through some old perl6-compiler mails

[15:25] <Woodi> hallo :)

[15:26] <Woodi> just found new version of blue screen :)  http://en.wikipedia.org/wiki/File:BSoD_in_Windows_8.png

[15:29] <lizmat> fwiw, I've just downloaded a fresh copy of rakudo from github and it compiles and installs ok on Mac OSX

[15:30] <lizmat> I assume there was some fix done (the git revert was not necessary)

[15:34] *** spider-mario left
[16:02] <moritz> only 14 test files failing in qast-sink-1, jnthn++

[16:13] <Woodi> is something like "partial evaluation"  http://en.wikipedia.org/wiki/Partial_evaluation  considered in Perl6 ?

[16:18] <moritz> I guess I know the reason for most of the failures in the sink branch

[16:18] <moritz> nested loops aren't executed the way you'd expect them to

[16:18] <moritz> ./perl6 -e 'for ^2 { .say; for <a b> { .say } }

[16:18] <moritz> 0 1 a b a b

[16:19] *** MayDaniel_ joined
[16:21] <skids> Woodi: I would suspect it is on many levels.  It's a rather broad concept.

[16:22] <jnthn> moritz: oooh. Hm.

[16:22] *** MayDaniel left
[16:22] <jnthn> That is a bit of an issue if you're evaluating the things for their side-effects...

[16:23] <Woodi> I just wonder if binary for four operation calculator with console IO still contains hashes, evals, methods...

[16:24] <lizmat> nr: sub foo { our $bar = 3 }; foo; say our $bar

[16:24] <p6eval> niecza v24-5-g599cbcb: OUTPUT«3␤»

[16:24] <p6eval> ..rakudo 53daef: OUTPUT«Any()␤»

[16:25] * lizmat thinks rakudo is right

[16:25] <Woodi> rn: say our $bar

[16:25] <p6eval> rakudo 53daef, niecza v24-5-g599cbcb: OUTPUT«Any()␤»

[16:25] <Woodi> rn: say my $bar

[16:25] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Potential difficulties:␤  $bar is declared but not used at /tmp/bMWyVtb4jD line 1:␤------> [32msay my [33m⏏[31m$bar[0m␤␤Any()␤»

[16:25] <p6eval> ..rakudo 53daef: OUTPUT«Any()␤»

[16:26] <Woodi> n: my $bar; say $bar

[16:26] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Any()␤»

[16:26] <Woodi> shouldn't it say empty string ?

[16:27] <jnthn> No

[16:27] <lizmat> my understanding is that "our" is lexically scoped, even though it is referring to a package variable

[16:27] <lizmat> our is that too perl5ish?

[16:28] <lizmat> s/our/or/

[16:28] <jnthn> lizmat: our gives you a lexically scoped alias to a package-scoped variable.

[16:29] <jnthn> our $bar # like my $bar := OUR::<$bar>

[16:29] <lizmat> ah, so you're saying the our inside the sub is an alias to the same package var outside

[16:30] <lizmat> and so that rakudo *is* wrong in this example...

[16:32] <lizmat> ok, gotcha

[16:33] <jnthn> lizmat: Um, I didn't say Rakudo was wrong.

[16:33] <jnthn> They're both aliases to the same thing in the package.

[16:33] <jnthn> Thus "alias" :)

[16:34] <jnthn> Really it's just binding.

[16:34] <lizmat> but the assignment in foo() should be visible outside, no?

[16:34] <jnthn> Oh...I misread the output

[16:34] <jnthn> Then I guess Rakudo gets it wrong

[16:35] <jnthn> Which isn't so surprising since it doesn't even try to make our @foo and our %bar work...

[16:35] <lizmat> ah, ok

[16:35] <jnthn> One of those "nobody really seems to care about it so much as they care about other things so it never makes the top of the todo list" things :)

[16:35] <lizmat> nr: sub foo { our $bar = 3; return $bar }; say foo

[16:35] <p6eval> rakudo 53daef, niecza v24-5-g599cbcb: OUTPUT«3␤»

[16:36] <lizmat> nr: sub foo { our $bar = 3; return $bar }; say foo; say $bar

[16:36] <p6eval> niecza v24-5-g599cbcb: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $bar is not predeclared at /tmp/qaO7IGQasE line 1:␤------> [32mr $bar = 3; return $bar }; say foo; say [33m⏏[31m$bar[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443…

[16:36] <p6eval> ..rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $bar is not declared␤at /tmp/u4ayQ3eRkA:1␤------> [32mar = 3; return $bar }; say foo; say $bar[33m⏏[31m<EOL>[0m␤»

[16:37] <lizmat> nr: sub foo { our $bar = 3; return $bar }; say foo; say $<bar>

[16:37] <p6eval> rakudo 53daef, niecza v24-5-g599cbcb: OUTPUT«3␤Any()␤»

[16:39] <jnthn> $<bar> means $/<bar>

[16:39] <lizmat> ack

[16:39] <lizmat> nr: sub foo { our $bar = 3; return $bar }; say foo; say OUR::<$bar>

[16:39] <p6eval> rakudo 53daef, niecza v24-5-g599cbcb: OUTPUT«3␤3␤»

[16:39] *** zby_home joined
[16:58] *** birdwindupbird left
[17:12] *** fgomez left
[17:13] <skids> r: my $f = 0x9876543210; int($f).say; # will native types eventually coerce, or not, or spec TBD?

[17:13] <p6eval> rakudo 53daef: OUTPUT«invoke() not implemented in class 'int'␤  in block  at /tmp/_Nz5A6oCW5:1␤␤»

[17:14] <jnthn> I suspect it'll be too surprising for them not to.

[17:14] <jnthn> Need to nail down the exact semantics, however.

[17:14] <skids> good.  but given they are weird I thought "better ask about that"

[17:17] *** lizmat left
[17:19] <skids> .oO(maybe the natives should actually have some extra asm-like methods specced, e.g. rol, ror, clz)

[17:20] *** cognominal left
[17:25] *** fgomez joined
[17:26] <GlitchMr> Is viv acronym for viv is viv?

[17:27] <skids> roman numerals

[17:33] *** PacoAir left
[17:34] *** PacoAir joined
[18:13] <flussence> masak++ # LTM post

[18:13] *** MayDaniel_ left
[18:13] <dalek> ecosystem: 8f2f019 | flussence++ | META.list:

[18:13] <dalek> ecosystem: Add a few testing modules

[18:13] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/8f2f019a59

[18:13] <flussence> there, have an early christmas present :)

[18:16] *** [particle]1 joined
[18:16] *** am0c joined
[18:18] <skids> flussence++

[18:19] *** am0c left
[18:19] *** am0c joined
[18:21] <skids> flussence: In Sum I have some (currently Panda-breaking) test code that checks that code in the manpage actually works.  As part of that, I had to hack together an IO redirect that compares what a code chuck sends to stdio to expected output.  Might be worth having.

[18:22] <flussence> thanks, I'll take a look

[18:23] <skids> t/siphash.t will have it

[18:38] *** hash_table joined
[18:54] *** bbkr_ joined
[18:57] *** spider-mario joined
[19:03] *** pecastro joined
[19:16] <sorear> good * #perl6

[19:18] *** cognominal joined
[19:22] <cognominal> \o drinking beer and chartreuse :)  txh to duckduckgo

[19:23] <jnthn> o/ sorear, cognominal 

[19:36] *** SamuraiJack left
[19:45] *** grondilu left
[19:46] <sorear> o/ jnthn 

[19:54] <masak> good evening, #perl6

[19:58] <sorear> o/ masak

[20:00] * jnthn works on l'advent post

[20:00] <cognominal> Hqllo from Wendy

[20:01] <jnthn> .oO( If she pronounces it hqllo, the chartreuse must be going well :P )

[20:03] <cognominal> Getting ouy of the pub . See u later.

[20:03] *** cognominal left
[20:33] <bbkr_> as of today JSON::RPC in Perl6 implements whole specification (including Batches and Notifications) :)

[20:35] <moritz> \o/

[20:36] <moritz> bbkr_: please blog about it!

[20:37] *** noggle left
[20:39] <bbkr_> moritz: good idea, there are few cool Perl6 features used to achieve that. for example meta fallback, finding method and validating params on metaobject level (find_method, cando), gather-taking, etc. I'll try to write blog post this week.

[20:43] *** cognominal joined
[20:44] <bbkr_> can someone bump jsonrpc module version in Star repo?

[20:44] *** noggle joined
[20:46] <moritz> bbkr_: that's usually done before a release anyway

[20:48] <bbkr_> moritz: ok, I was not sure about it - for example 2012.10 had no updates.

[20:53] *** GlitchMr left
[20:53] *** cognominal left
[20:56] <jnthn> Tomorrow's advent post written and scheduled.

[20:56] <FROGGS_> jnthn:++

[20:56] <moritz> jnthn++

[20:56] * FROGGS_ is looking forward to it

[20:57] <FROGGS_> what's the topic?

[20:57] <jnthn> Oh, a boring topic

[20:57] <jnthn> quotes :)

[20:57] <am0c> jnthn++

[20:57] <jnthn> r: say 'omg single quotes'

[20:57] <jnthn> :)

[20:57] <p6eval> rakudo 53daef: OUTPUT«omg single quotes␤»

[20:58] <masak> at some point I'd like us to have a deep discussion about heredocs, indentation, and interpolation.

[20:58] <FROGGS_> wow, a few lines about quotes, nice ;o)

[20:58] <masak> but I'd like TimToday to be in it.

[20:58] <masak> anyway, jnthn++ for writing advent post.

[20:59] *** kurahaupo joined
[21:04] *** yakshavr joined
[21:07] *** ggoebel_ joined
[21:14] *** am0c left
[21:14] <bbkr_> where does panda keep module list now? ~/.panda is not present anymore

[21:18] <FROGGS_> maybe in the rakudo/install/... ?

[21:19] <FROGGS_> r: my $s = '{ .substr(0,5) eq "cpan:"}'; $_ = 'cpan:abc'; say eval $s

[21:19] <p6eval> rakudo 53daef: OUTPUT«No such method 'substr' for invocant of type 'Any'␤  in block  at eval_0:1␤  in  at eval_0:1␤  in sub eval at src/gen/CORE.setting:579␤  in block  at /tmp/iYohYq6tiM:1␤␤»

[21:19] <FROGGS_> how do I set the $_ for that block?

[21:21] <flussence> r: my $s = '-> $_ { .substr(0,5) eq "cpan:"}'; (eval $s)('cpan:abc')

[21:21] <p6eval> rakudo 53daef:  ( no output )

[21:21] <flussence> r: my $s = '-> $_ { .substr(0,5) eq "cpan:"}'; say (eval $s)('cpan:abc')

[21:21] <p6eval> rakudo 53daef: OUTPUT«True␤»

[21:22] <FROGGS_> flussence: thanks!

[21:22] <jnthn> moritz: Hm, it's not immediately obvious how to fix the nested loops issue...

[21:23] <tadzik> bbkr_: the CUSTOM_LIB thing

[21:24] <tadzik> parrot/languages/perl6/site/panda or something like this

[21:25] <jnthn> moritz: oh, mebbe I know...

[21:26] <bbkr_> tadzik: thanks. panda was not updating my GH changes, then after reading source code i fount that it fetches from http://feather.perl6.nl:3000/projects.json ad not in realtime from GitHub

[21:26] <bbkr_> found*

[21:27] <tadzik> bbkr_: yes, it gets the modules list from there

[21:28] <tadzik> but if you 'panda install' a module, it gets it straight from GH

[21:28] <tadzik> if it knows it

[21:35] *** zby_home left
[21:37] *** cognominal joined
[21:38] <bbkr_> tadzik: I've entered incorrect module name in "depends" so it breaks at dependencies resolving before fetching module from GH. no big deal, i'll just wait for rebuild :)

[21:45] <masak> rakudo could use some coloring-up of its error messages in the IRC logs. just like STD and niecza.

[21:47] <jnthn> moritz: I'm pretty sure Rakudo emits the same set of escape codes...

[21:47] <jnthn> er

[21:47] <jnthn> ^masak

[21:47] <masak> yes.

[21:47] <masak> me too.

[21:47] <masak> so it's something in the backlog generator needs to change.

[21:47] <masak> 'night, #perl6

[21:49] <dalek> rakudo/qast-sink-1: d4bf9e4 | jnthn++ | src/core/ (3 files):

[21:49] <dalek> rakudo/qast-sink-1: Fix nested for-loop side-effects in sink context.

[21:49] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/d4bf9e43a2

[21:49] <jnthn> moritz: Well, just pushed something that fixes your example and at least one of the failing tests.

[21:54] *** cognominal left
[21:55] *** cognominal joined
[21:58] *** lichtkind joined
[21:58] *** PacoAir left
[22:07] <lue> hello world o/

[22:07] <lichtkind> hai lue

[22:08] *** cooper left
[22:08] *** cooper_ joined
[22:08] <rindolf> lue: hello.

[22:09] <rindolf> OK, I think I'll read some Advent Calendar entries and listen to a song and then go to sleep.

[22:09] <lue> jnthn: thinking about the NQPParametricRoleHOW bug I discovered, can knowhows inherit anything?

[22:09] <jnthn> lue: No.

[22:09] <jnthn> That's the point of them.

[22:10] <jnthn> We use them to implement stuff like inheritance.

[22:10] <lue> Didn't seem like it from my glance at them yesterday.

[22:10] <lue> (your answer to my question, that is)

[22:10] <jnthn> I'm a bit surprised that the attributes they have aren't just conveyed to the target class and the fixing up happens there

[22:11] <jnthn> Oh, but maybe it's not set up that way...

[22:11] <lue> (fwiw I had yet to apply the Children role to any classes. I wanted to see if what I did so far would compile.)

[22:13] <jnthn> If you add something to the role implementation then really it just needs to play pass the parcel.

[22:13] <jnthn> That is, it doesn't actually set any mappings up

[22:13] <jnthn> It just passing them along to the class

[22:13] <jnthn> That's done by the applier

[22:14] <jnthn> It may not be too hard to figure out how to do that.

[22:14] <lichtkind> hej jnthn 

[22:15] <jnthn> ahoj, lichtkind 

[22:15] *** cooper_ is now known as cooper

[22:15] *** cooper left
[22:15] *** cooper joined
[22:16] *** spider-mario left
[22:16] *** countley joined
[22:18] <rindolf> jnthn: http://perl6advent.wordpress.com/2012/12/05/a-perl-6-debugger/ - nice post - the perl 6 debugger seems cool.

[22:18] <rindolf> Good night, everybody.

[22:18] <rindolf> Sleep well.

[22:18] <rindolf> Happy Hanukkah.

[22:19] <FROGGS_> gnight rindolf 

[22:20] <jnthn> rindolf: Yes, it's been fun to make and see people use :)

[22:21] <jnthn> rindolf: 'night

[22:22] <rindolf> OK, bye.

[22:22] *** rindolf left
[22:24] *** grondilu joined
[22:25] <grondilu> rn: say exp(pi) - pi  # xkcd.com/217

[22:25] <p6eval> niecza v24-5-g599cbcb: OUTPUT«19.999099979189467␤»

[22:25] <p6eval> ..rakudo 53daef: OUTPUT«19.9990999869983␤»

[22:25] <lue> am I seeing that right on NQPClassHOW.pm:449? publish_parrot_vtablee_handler_mapping (that extra e in vtable)

[22:26] <jnthn> lue: yes, typo (and the op itself is typo'd...)

[22:27] <jnthn> Time for some rest here &

[22:27] <lue> I could swear the error I got contained a non-typo'd version of that name, but I could be wrong.

[22:27] <lue> goodrest jnthn o/

[22:28] <lichtkind> jnthn lot has changed

[22:29] <lue> (nvm, the error was for a similarly named method)

[22:30] <dalek> tablets: 6a19a29 | (Herbert Breunung)++ | docs/appendix-b-grouped.txt:

[22:30] <dalek> tablets: fixing utf in B

[22:30] <dalek> tablets: review: https://github.com/perl6/tablets/commit/6a19a296c3

[22:31] <lichtkind> jnthn: is there any major internal change in rakudo in last 1,5y that i dont find in your blog?

[22:31] *** att__ left
[22:32] <tadzik> bbkr_: ah, gotcha

[22:35] <lue> .oO(Since when did nqp generate windows-style filepaths in its errors‽)

[22:36] <lichtkind> hej tadzik 

[22:36] <tadzik> hej

[22:36] <lichtkind> i back a bit

[22:40] <sorear> hai lichtkind 

[22:41] <lichtkind> :)

[22:43] *** kaare_ left
[22:51] <lichtkind> sorear: same to you any major niecza dev in last 1,5y i cant read somewhere?

[22:56] <sorear> niecza has only existed for 2,0y

[22:56] <sorear> so you're basically asking for the entire history of the project

[22:56] <sorear> probably reading the docs/announce.* files is your best bet

[23:09] <lichtkind> sorear: you mean all relevant is there?

[23:10] <sorear> maybe

[23:11] *** hash_table left
[23:11] <lichtkind> you should know :)

[23:25] *** tokuhiro_ joined
[23:54] *** cognominal left
