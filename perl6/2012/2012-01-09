[00:00] *** tokuhirom left
[00:00] *** pmichaud joined
[00:00] *** [Coke] joined
[00:00] *** PerlJam joined
[00:04] *** Juerd joined
[00:06] *** tadzik joined
[00:09] *** tokuhirom joined
[00:12] <ingy> tadzik: is HTTP::Easy psgi?

[00:13] <ingy> full disclosure... I'm working on ActiveState on Stackato which is a downloadable PaaS

[00:14] <ingy> you can run your own polyglot app hosting env and push apps to it etc

[00:15] <ingy> like dotcloud but you host it (or pick any place to host it)

[00:15] <ingy> I'd like to think about adding p6 to our 8 or so languages

[00:18] <ingy> I think having this work for Perl 6 would be a huge shot in the arm for Perl 6 evangelism.

[00:18] *** qu1j0t3 joined
[00:18] <qu1j0t3> hello chan. somebody might want to add a Perl 6 status update to this Quora topic. http://www.quora.com/What-is-the-future-of-Perl-programming

[00:25] <skids> perl6: class A { has $.a = 2; }; class B { has A $.aa handles A = A.new; has $.b; }; my B $f .= new(); $f.a.say;

[00:25] <p6eval> rakudo 4e5d8a: OUTPUT¬´2‚ê§¬ª

[00:25] <p6eval> ..niecza v13-166-gcdf48b2: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method trait_mod:handles not yet implemented at /tmp/ICrrfTgnIV line 1:‚ê§------> [32m = 2; }; class B { has A $.aa handles A [33m‚èè[31m= A.new; has $.b; }; my B $f .= new(); $[0m‚ê§‚ê§Trait 0 not available on variables‚Ä¶

[00:25] <p6eval> ..pugs b927740: OUTPUT¬´*** No such method in class B: "&a"‚ê§    at /tmp/QWKGE4oCrW line 1, column 97-105‚ê§¬ª

[00:26] <skids> rakudo: class A { has $.a = 2; }; class B { has A $.aa handles A; has $.b; }; my B $f .= new(); $f.aa .= new(); $f.a.say;

[00:26] <p6eval> rakudo 4e5d8a: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in method dispatch:<.=> at src/gen/CORE.setting:788‚ê§  in block <anon> at /tmp/XsMB2hHmP5:1‚ê§  in <anon> at /tmp/XsMB2hHmP5:1‚ê§¬ª

[00:28] *** molaf joined
[00:30] <raiph> ingy: nice!

[00:32] <colomon> ingy: please keep bringing this up.  If needed we can write something to get the job done.

[00:32] * colomon is ignorant of the current state of p6 web stuff, but is very willing to learn and code.

[00:33] <sorear> sounds like getting bailador to run on niecza should be a high priority of mie

[00:33] *** qu1j0t3 left
[00:34] <ingy> stackato is built over CloudFoundry. dukeleto is the "ingy" of that project.

[00:35] <ingy> so this would be good for parrot as well.

[00:35] <ingy> dukeleto: make sense?

[00:35] <ingy> CF is on github. 

[00:36] <ingy> also someone recently added mono support iirc

[00:36] <ingy> so it could support niecza

[00:37] <colomon> woot!

[00:37] *** tokuhirom left
[00:42] <ingy> Stackato is an "enterprise ready" paas built over VMWare's open source CloudFoundry paas. If we targeted p6 as a runtime for CF, it would also just work on Stackato, and thus be available to ActiveState's corporate customers.

[00:43] <sorear> can you explain paas?

[00:43] <ingy> I personally convinced ActiveState to make Stackato have a free license for single node non-commercial use. So people can download and use it free forever...

[00:43] <ingy> sorear: sure

[00:43] <ingy> EC2 and Linode etc are IaaS

[00:44] <ingy> DotCloud and Heroku (and CF and Stackato) are PaaS

[00:44] <ingy> PaaS is essentially a VM that is ready to run applications

[00:44] <sorear> I have not personally used *any* of those examples.

[00:45] <ingy> it has all the components preconfigured

[00:45] <ingy> OS, language runtime, database, services, etc

[00:46] <ingy> so you just 'push' an app and it's running

[00:46] <ingy> you control every aspect of the VM from a console...

[00:46] <ingy> although we provide ssh access too

[00:47] <ingy> most PaaS providers provision a VM for you on their own IaaS configuration

[00:47] <sorear> what's IaaS?

[00:47] <ingy> Infrastructure as a Service

[00:48] <ingy> virtual hardware

[00:48] <ingy> rackspace, linode, amazon ec2

[00:48] <ingy> etc

[00:48] <ingy> paas is Platform aaS

[00:49] <kshannon> sorear: http://irclog.perlgeek.de/perl6/2012-01-08#i_4952481 "this has been... rectified"

[00:49] <kshannon> Does this mean p6eval should have my change?

[00:49] <sorear> kshannon: yes

[00:49] <ingy> this is the future of running web apps...

[00:49] <kshannon> Hmm.... It doesn't seem to work :(

[00:49] <kshannon> nom: https://github.com/perl6/roast/blob/master/S02-magicals/args.t

[00:49] <p6eval> nom 4e5d8a: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "https://gi"‚ê§¬ª

[00:50] <ingy> Stackato and CF are called "Private PaaS"

[00:50] <sorear> evalbot control restart

[00:50] *** p6eval joined
[00:50] *** ChanServ sets mode: +v p6eval

[00:50] <ingy> meaning we don't care where you run it

[00:50] <ingy> which is why I joined AS

[00:51] <ingy> because cloud computing is a big push towards centralization of power

[00:51] <ingy> which is the end of a free internet as we know it

[00:51] <ingy> imho...

[00:52] *** kmwallio joined
[00:52] <ingy> offering cloud ease of use without giving away all your power is a win/win

[00:53] <ingy> having perl6 apps that deploy in 5 seconds is just the icing on the cake ;)

[00:55] *** Juerd_ joined
[00:55] *** Juerd_ left
[00:56] <sorear> o/ Juerd

[00:56] <Juerd> Hi

[00:56] <Juerd> (Confused yet? I am...)

[00:58] <ingy> Juerd: re?

[01:00] <Juerd> mi fa so la ti do!

[01:00] <ingy> :)

[01:00] <cognominal> s/ti/si/

[01:00] <Juerd> tomato, tomato.

[01:01] <Juerd> IPA would have worked better but I don't know IPA. Or SAMPA.

[01:01] <cognominal> you say tomato i say tomato  :)

[01:02] <Juerd> I tend to say tomaat.

[01:02] <Juerd> That's kind of the norm, here in .nl

[01:02] <benabik> I prefer Stouts to IPAs.

[01:12] *** twirp joined
[01:12] *** twirp left
[01:13] *** twirp joined
[01:15] *** kmwallio left
[01:20] *** ksi left
[01:31] * flussence just read the CORE2 stuff in backlog... looks promising

[01:32] *** wolfman2000 joined
[01:33] <sorear> o/ flussence

[01:34] <flussence> I'm more of the opinion that there should be a good autoloader system for heavy classes, but I'll take an improvement that doesn't kill my netbook. also hi :)

[01:34] *** twirp left
[01:36] *** kmwallio joined
[01:37] *** ggoebel joined
[01:41] *** ggoebel left
[01:47] *** ggoebel joined
[02:30] <dalek> roast: f951a3e | coke++ | integration/advent2009-day09.t:

[02:30] <dalek> roast: niecza fudge

[02:30] <dalek> roast: review: https://github.com/perl6/roast/commit/f951a3e6ba

[02:30] <dalek> niecza: e960439 | coke++ | t/spectest.data:

[02:30] <dalek> niecza: run more tests

[02:30] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e9604398be

[02:31] *** tokuhirom joined
[02:34] *** am0c joined
[02:36] *** tokuhirom left
[02:38] <dalek> niecza: 25c122b | sorear++ | / (2 files):

[02:38] <dalek> niecza: Add a 'pure' trait, mark a bunch of setting functions

[02:38] <dalek> niecza: review: https://github.com/sorear/niecza/commit/25c122be38

[02:38] <dalek> niecza: eba5eb3 | sorear++ | / (9 files):

[02:38] <dalek> niecza: Take a first crack at implementing constant folding

[02:38] <dalek> niecza: 

[02:38] <dalek> niecza: Using the 'pure' trait on functions, a function call with only immutable

[02:38] <dalek> niecza: constant arguments can be replaced with its result value.  For now only

[02:38] <dalek> niecza: works on true functions; some pieces of function-like syntax that are

[02:38] <dalek> niecza: implemented differently don't fold.

[02:38] <dalek> niecza: review: https://github.com/sorear/niecza/commit/eba5eb328c

[02:38] <sorear> I spent most of today debugging eba5eb3 ... that fought me a lot more than roles have :|

[02:39] <skids> What are the semantics of "class A is rw {...}"?

[02:43] <sorear> marks all attributes rw

[02:43] <sorear> niecza: 5**5**5

[02:43] <p6eval> niecza v13-166-gcdf48b2:  ( no output )

[02:43] <sorear> niecza: for ^1000 { 5**5**5 }

[02:43] <p6eval> niecza v13-166-gcdf48b2:  ( no output )

[02:43] <sorear> niecza: 5**5**6

[02:43] <p6eval> niecza v13-166-gcdf48b2:  ( no output )

[02:43] <sorear> niecza: for ^1000 { 5**5**6 }

[02:43] <p6eval> niecza v13-166-gcdf48b2:  ( no output )

[02:43] <sorear> niecza: 5**5**7

[02:43] <p6eval> niecza v13-166-gcdf48b2:  ( no output )

[02:43] <sorear> niecza: 5**5**8

[02:43] <p6eval> niecza v13-166-gcdf48b2:  ( no output )

[02:44] <sorear> niecza: for ^1000 { 5**5**8 }

[02:45] <p6eval> niecza v13-166-gcdf48b2: OUTPUT¬´(timeout)¬ª

[02:45] <sorear> evalbot rebuild niecza

[02:45] <p6eval> OK (started asynchronously)

[02:46] <dalek> Rebuild of niecza complete.

[02:46] <sorear> niecza: for ^1000 { 5**5**8 }

[02:46] <p6eval> niecza v13-169-geba5eb3:  ( no output )

[02:46] <sorear> look how much faster it is!!!

[02:47] <benabik> Fix for exponentiation?

[02:47] <[Coke]> sorear: in backscroll I cannot tell the difference. ;)

[02:48] <colomon> sorear++

[02:48] *** HarryS joined
[02:48] <[Coke]> ah. I lie, I can, if I read the last 2. nifty.

[02:50] <[Coke]> perl6: List.new(4,5,6).say

[02:50] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´Unhandled exception: Excess arguments to List.new, used 1 of 4 positionals‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (List.new @ 1) ‚ê§  at /tmp/jy0xOJzb6k line 1 (mainline @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2842 (ANON @ 3) ‚ê§  at /h‚Ä¶

[02:50] <p6eval> ..rakudo 4e5d8a: OUTPUT¬´4 5 6‚ê§¬ª

[02:50] <p6eval> ..pugs b927740: OUTPUT¬´*** Must only use named arguments to new() constructor‚ê§    Be sure to use bareword keys.‚ê§    at /tmp/I2bec2OfGY line 1, column 1 - line 2, column 1‚ê§¬ª

[02:50] <[Coke]> is rakudo wrong here?

[02:52] <colomon> it's probably not spec'd

[02:52] <colomon> perl6: list(4, 5, 6).say

[02:52] <p6eval> rakudo 4e5d8a, niecza v13-169-geba5eb3: OUTPUT¬´4 5 6‚ê§¬ª

[02:52] <p6eval> ..pugs b927740: OUTPUT¬´456‚ê§¬ª

[02:55] <felher> will rakudo/nom compile with 400MB free RAM?

[02:56] <sorear> Maybe, if you have 2 gigs of fast swap and a lot of patience.

[02:56] *** jeffreykegler joined
[02:56] <felher> sorear: :D. k, thnx :)

[03:00] *** lutok joined
[03:03] *** jeffreykegler left
[03:04] *** am0c_ joined
[03:06] *** am0c left
[03:06] *** am0c_ is now known as am0c

[03:06] *** am0c is now known as Guest71677

[03:07] *** Guest71677 is now known as am0c^

[03:08] *** lutok left
[03:28] *** kmwallio left
[03:33] *** thou_ joined
[03:36] <[Coke]> i wonder if we should just always re-fudge when running t/spec/fudge

[03:36] <[Coke]> (rather than relying at all on timestamps.)

[03:38] *** Psyche^ joined
[03:39] *** Psyche^ is now known as Patterner

[03:43] <sorear> [Coke]: +1... the fudger is very fast compared to all current implementations

[03:50] *** orafu joined
[03:57] <dalek> roast: 2372496 | coke++ | fudge:

[03:57] <dalek> roast: Always attempt to refudge.

[03:57] <dalek> roast: 

[03:57] <dalek> roast: Handles cases when arguments change or version control mucks with timestamps.

[03:57] <dalek> roast: review: https://github.com/perl6/roast/commit/237249666f

[03:59] <[Coke]> ah. it was also impacting autounfudge. whee.

[04:02] <kshannon> coke++

[04:12] *** raiph left
[04:19] *** dku joined
[04:37] *** odoacre joined
[05:04] *** satyavvd joined
[05:08] *** cognominal joined
[05:13] *** kaleem joined
[05:15] *** mkramer joined
[05:20] *** am0c^ left
[05:40] <moritz> phenny: tell jnthn about https://gist.github.com/1581336 (nqp qbootstrap test output with ICU)

[05:40] <phenny> moritz: I'll pass that on when jnthn is around.

[05:44] <kshannon> I've got a NQP 'int' from nqp::getattr_i($c, NQPCursorRole, '$!pos') and I want to put it in a string for tracing but everything I'm trying is giving: get_string() not implemented in class 'int'

[05:45] <dalek> roast: 42626ba | coke++ | S (14 files):

[05:45] <dalek> roast: niecza (auto)unfudge

[05:45] <dalek> roast: review: https://github.com/perl6/roast/commit/42626ba4f9

[05:46] <moritz> kshannon: is that in NQP or in Rakudo?

[05:47] <moritz> in rakudo, I'd nqp::p6box_s() the thing

[05:47] <moritz> in NQP; I'd try pir::set__SI() around it

[05:47] *** kaleem left
[05:48] <kshannon> NQP qbootstrap debugging

[05:50] *** benabik joined
[06:05] *** tokuhirom joined
[06:09] *** kaleem joined
[06:09] *** tokuhirom left
[06:11] <[Coke]> std: regex b {};

[06:11] <p6eval> std dc62e1d: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Null pattern not allowed at /tmp/M47szwRhuk line 1:‚ê§------> [32mregex b {[33m‚èè[31m};[0m‚ê§Other potential difficulties:‚ê§  'regex' declaration outside of grammar at /tmp/M47szwRhuk line 1:‚ê§------> [32mregex b [33m‚èè[31m{};[0m‚ê§Parse ‚Ä¶

[06:11] <[Coke]> std: regex b {'a'};

[06:11] <p6eval> std dc62e1d: OUTPUT¬´Potential difficulties:‚ê§  'regex' declaration outside of grammar at /tmp/LIFCIeDulm line 1:‚ê§------> [32mregex b [33m‚èè[31m{'a'};[0m‚ê§ok 00:01 120m‚ê§¬ª

[06:12] <[Coke]> sorear: there are a few tests we can't run they have a regex/token outside of a grammar.

[06:14] <[Coke]> ah, misread the error, looks like it's the same as std.

[06:14] <[Coke]> (so it's not an error and there's something else going on.)

[06:15] *** baest_ joined
[06:18] <sorear> niecza: regex b {'a'}

[06:18] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Methods must be used in some kind of package at /tmp/cT1obwdQ0z line 1:‚ê§------> [32mregex b [33m‚èè[31m{'a'}[0m‚ê§‚ê§Potential difficulties:‚ê§  'regex' declaration outside of grammar at /tmp/cT1obwdQ0z line 1:‚ê§------> [32mreg‚Ä¶

[06:18] <sorear> [Coke]: My understanding of the current spec is that a regex outside of a grammar must be marked "my"

[06:18] <sorear> it's possible we'll rule this is automatic

[06:19] *** dukeleto joined
[06:25] <[Coke]> ah.

[06:26] *** thou_ left
[06:26] *** zby_home_ joined
[06:27] *** nornagest joined
[06:31] *** Woodi joined
[06:31] *** koban joined
[06:32] *** koban left
[06:36] *** DrEeevil joined
[06:38] *** y3llow_ joined
[06:38] <moritz> I thought the idea was to invent some magic handwaving that mixes regexes into the current slang (?), and thus makes    regex a { foo }; 'a' ~~ /<a>/  work

[06:41] <sorear> moritz: that can be accomplished just by having regex a default to my

[06:42] <moritz> sorear: but /<a>/ doesn't look for a lexical &a, does it?

[06:42] <sorear> moritz: it does

[06:43] *** wtw joined
[06:43] <sorear> S05:1422

[06:43] <sorear> I interpreted this to mean *only* Regex-classed objects

[06:44] <sorear> so / <sin> / is still a call to a method

[06:44] <sorear> if you have a burning desire to use a trig function as a parsing method, you'll need to use <sin=&sin> like in Rakudo b

[06:45] *** REPLeffect joined
[06:46] *** dukeleto left
[06:46] *** odoacre left
[06:46] *** orafu left
[06:46] *** p6eval left
[06:46] *** tadzik left
[06:46] *** Util left
[06:46] *** Lorn left
[06:46] *** `patch` left
[06:46] *** y3llow_ is now known as y3llow

[06:47] *** orafu joined
[06:48] <moritz> nom: my regex a { }; say

[06:48] <moritz> nom: my regex a { 'a' }; say 'a' 9~

[06:48] <moritz> nom: my regex a { 'a' }; say 'a' ~~ /<a>/

[06:48] <moritz> what's up with p6eval?

[06:48] <kshannon> Netsplit

[06:49] <moritz> worse

[06:49] <moritz> it doesn't react to ctrl+c from the command line

[06:50] *** bbkr joined
[06:50] *** MC91 joined
[06:50] *** tadzik joined
[06:50] *** dukeleto joined
[06:50] *** odoacre joined
[06:50] *** p6eval joined
[06:50] *** Util joined
[06:50] *** spetrea joined
[06:50] *** fsergot joined
[06:50] *** ashleydev joined
[06:50] *** lestrrat joined
[06:50] *** daxim joined
[06:50] *** fhelmberger joined
[06:50] *** mattp_ joined
[06:50] *** daemon joined
[06:50] *** dalek joined
[06:50] *** Tene joined
[06:50] *** kfo joined
[06:50] *** Lorn joined
[06:50] *** `patch` joined
[06:50] *** wolfe.freenode.net sets mode: +vv p6eval dalek

[06:50] <kshannon> nom: my regex a { 'a' }; say 'a' ~~ /<a>/

[06:50] *** p6eval left
[06:50] *** p6eval joined
[06:50] *** ChanServ sets mode: +v p6eval

[06:50] <kshannon> nom: my regex a { 'a' }; say 'a' ~~ /<a>/

[06:51] <moritz> it received that input at least

[06:51] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'a' not found for invocant of class 'Cursor'‚ê§  in regex <anon> at /tmp/06o0zaeUGJ:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:7228‚ê§  in block <anon> at /tmp/06o0zaeUGJ:1‚ê§  in <anon> at /tmp/06o0zaeUGJ:1‚ê§¬ª

[06:51] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'a' not found for invocant of class 'Cursor'‚ê§  in regex <anon> at /tmp/CBvV5AexSy:1‚ê§  in method ACCEPTS at src/gen/CORE.setting:7228‚ê§  in block <anon> at /tmp/CBvV5AexSy:1‚ê§  in <anon> at /tmp/CBvV5AexSy:1‚ê§¬ª

[06:51] <moritz> niecza: my regex a { 'a' }; say 'a' ~~ /<a>/

[06:51] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´#<match from(0) to(1) text(a) pos([].list) named({"a" => #<match from(0) to(1) text(a) pos([].list) named({}.hash)>}.hash)>‚ê§¬ª

[06:51] <moritz> niecza: my regex a { 'a' }; { my sub a() { }; say so 'a' ~~ /<a>/ }

[06:51] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´Potential difficulties:‚ê§  &a is declared but not used at /tmp/_jIipyvpZ4 line 1:‚ê§------> [32mmy regex a { 'a' }; { my sub a[33m‚èè[31m() { }; say so 'a' ~~ /<a>/ }[0m‚ê§‚ê§Unhandled exception: Unable to resolve method a in class Cursor‚ê§  at /tmp/_jIipyvpZ4 ‚Ä¶

[06:52] <sorear> moritz: transatlantic routing glitch causes netsplit and disrupts your ssh connection?

[06:52] <moritz> sorear: no, the ssh connection was fine; I could change windows inside the screen

[06:54] *** DrEeevil is now known as bonsaikitten

[07:04] *** jaldhar joined
[07:07] <sorear> rakudo: sub foo(::Int $x) { say 15 ~~ Int }; foo("xyz")

[07:07] <p6eval> rakudo 4e5d8a: OUTPUT¬´===SORRY!===‚ê§You cannot create an instance of this type‚ê§¬ª

[07:09] *** sayu joined
[07:09] <sorear> Does initial in parameters :: always mean "en passant type capture"?

[07:10] <japhb> nom: my $class := Any.HOW.HOW; my @m := $class.HOW.methods($class, :local).list; say @m.WHAT;

[07:10] <p6eval> nom 4e5d8a: OUTPUT¬´List()‚ê§¬ª

[07:11] <japhb> nom: my $class := Any.HOW.HOW; my @m := $class.HOW.methods($class, :local).list; say @m.WHAT; for @m { say "alive" }

[07:11] <p6eval> nom 4e5d8a: OUTPUT¬´List()‚ê§Unmarshallable foreign language value passed for parameter '$value'‚ê§  in method new at src/gen/CORE.setting:5111‚ê§  in sub coro at src/gen/CORE.setting:4522‚ê§  in method reify at src/gen/CORE.setting:4497‚ê§  in method reify at src/gen/CORE.setting:4280‚ê§  in method‚Ä¶

[07:11] <japhb> OK, how do I iterate @m in the above?  I've clearly got Tired Brane

[07:12] <sorear> Why are you using .list there at all?

[07:12] <japhb> nom: my $class := Any.HOW.HOW; my @m := $class.HOW.methods($class, :local); say @m.WHAT;

[07:12] <p6eval> nom 4e5d8a: OUTPUT¬´Type check failed in binding‚ê§  in block <anon> at /tmp/P4dKWJPLj6:1‚ê§  in <anon> at /tmp/P4dKWJPLj6:1‚ê§¬ª

[07:12] <japhb> That's why.

[07:12] <sorear> You're saying @m

[07:12] <sorear> Don't do that

[07:13] <japhb> nom: my $class := Any.HOW.HOW; my $m := $class.HOW.methods($class, :local); say $m.WHAT;

[07:13] <p6eval> nom 4e5d8a: OUTPUT¬´Hash()‚ê§¬ª

[07:13] <sorear> @m requires Positional, which is a Perl 6 type, excluding NQP result values

[07:13] <sorear> ...or those

[07:13] <japhb> WTF?

[07:13] <sorear> nom: my $class := Any.HOW.HOW; my $m := $class.HOW.methods($class, :local); say $m

[07:13] <p6eval> nom 4e5d8a: OUTPUT¬´Unmarshallable foreign language value passed for parameter '$value'‚ê§  in method new at src/gen/CORE.setting:5111‚ê§  in sub coro at src/gen/CORE.setting:4522‚ê§  in method reify at src/gen/CORE.setting:4497‚ê§  in method reify at src/gen/CORE.setting:4280‚ê§  in method reify ‚Ä¶

[07:13] <sorear> nom: my $class := Any.HOW.HOW; my $m := $class.HOW.methods($class, :local); say $m.Str

[07:13] <p6eval> nom 4e5d8a: OUTPUT¬´Unmarshallable foreign language value passed for parameter '$value'‚ê§  in method new at src/gen/CORE.setting:5111‚ê§  in sub coro at src/gen/CORE.setting:4522‚ê§  in method reify at src/gen/CORE.setting:4497‚ê§  in method reify at src/gen/CORE.setting:4280‚ê§  in method reify ‚Ä¶

[07:14] <sorear> nom: my $class := Any.HOW.HOW; my $m := $class.HOW.methods($class, :local); say $m.keys

[07:14] <p6eval> nom 4e5d8a: OUTPUT¬´Unmarshallable foreign language value passed for parameter '$value'‚ê§  in method new at src/gen/CORE.setting:5111‚ê§  in sub coro at src/gen/CORE.setting:4522‚ê§  in method reify at src/gen/CORE.setting:4497‚ê§  in method reify at src/gen/CORE.setting:4280‚ê§  in method reify ‚Ä¶

[07:14] <sorear> nom: my $class := Any.HOW.HOW; say $class

[07:14] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'gist' not found for invocant of class 'NQPClassHOW'‚ê§  in sub say at src/gen/CORE.setting:5702‚ê§  in block <anon> at /tmp/UIgLocYCpJ:1‚ê§  in <anon> at /tmp/UIgLocYCpJ:1‚ê§¬ª

[07:15] <sorear> nom: my $class := Any.HOW.HOW.HOW; say $class

[07:15] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'gist' not found for invocant of class 'KnowHOW'‚ê§  in sub say at src/gen/CORE.setting:5702‚ê§  in block <anon> at /tmp/EOnuiUqMkG:1‚ê§  in <anon> at /tmp/EOnuiUqMkG:1‚ê§¬ª

[07:15] <sorear> nom: my $class := Any.HOW.HOW.HOW.HOW; say $class

[07:15] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'gist' not found for invocant of class 'KnowHOW'‚ê§  in sub say at src/gen/CORE.setting:5702‚ê§  in block <anon> at /tmp/561r3cJriK:1‚ê§  in <anon> at /tmp/561r3cJriK:1‚ê§¬ª

[07:15] * japhb chuckles: Find the class by looking at the error message telling you it can't show you the name for the class.

[07:16] <sorear> japhb, I'm ready to try to add &val to niecza

[07:16] <sorear> I'm wondering what the parse rules should be, esp. for Pairs

[07:16] <kshannon> \o/

[07:17] <japhb> The annoying thing is that on a conceptual level, it looks like there's a decent-ish set of metamethods all the way down, but unfortunately beyond a certain point, I can't actually seem to introspect any further from Perl6-land. 

[07:18] <sorear> japhb: You need to use NQP to use the lower metamethods

[07:18] <sorear> Perl6 can only really use its own objects

[07:18] <sorear> I think that... thing... was a parrot;Hash

[07:18] <sorear> nom: my $class := Any.HOW.HOW; my $m := $class.HOW.methods($class, :local); say $m.REPR

[07:18] <p6eval> nom 4e5d8a: OUTPUT¬´P6opaque‚ê§¬ª

[07:18] <japhb> Yeah, that's my guess as well.

[07:19] <sorear> hmm, maybe not

[07:19] <sorear> jnthn has been pretty clear in the past that Any.HOW.HOW is meant to be an NQP-world object in Rakudo

[07:19] <japhb>  nom: my $class := Any.HOW.HOW.HOW; my $m := $class.HOW.methods($class, :local); say $m.REPR

[07:19] <p6eval> nom 4e5d8a: OUTPUT¬´P6opaque‚ê§¬ª

[07:19] <japhb> Yeah, it's lying.

[07:20] <sorear> I don't know if he intends to make gisting a P6hash work, though

[07:20] <japhb>  nom: my $class := Any.HOW; my $m := $class.HOW.methods($class, :local); say $m.REPR

[07:20] <p6eval> nom 4e5d8a: OUTPUT¬´P6opaque‚ê§¬ª

[07:20] <benabik> nom: my $class := Any.HOW; say $class

[07:20] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'gist' not found for invocant of class 'Perl6::Metamodel::ClassHOW'‚ê§  in sub say at src/gen/CORE.setting:5702‚ê§  in block <anon> at /tmp/OKHMwo9wxz:1‚ê§  in <anon> at /tmp/OKHMwo9wxz:1‚ê§¬ª

[07:20] <benabik> nom: my $class := Any.HOW; say $class.name

[07:20] <p6eval> nom 4e5d8a: OUTPUT¬´too few positional arguments: 1 passed, 2 (or more) expected‚ê§  in name at src/gen/Metamodel.pm:58‚ê§  in block <anon> at /tmp/vXY_xGljPo:1‚ê§  in <anon> at /tmp/vXY_xGljPo:1‚ê§¬ª

[07:21] <moritz> nom: my $class := Any.HOW; say $class.name($class)

[07:21] <p6eval> nom 4e5d8a: OUTPUT¬´Any‚ê§¬ª

[07:21] <sorear> nom: my $class := Any; say $class.HOW.name($class)

[07:21] <p6eval> nom 4e5d8a: OUTPUT¬´Any‚ê§¬ª

[07:21] * japhb doesn't actually care about .gist for this stuff per se; I was really just trying to figure out how to write a tool that introspected the entire class space and drew a massive diagram of the whole reality all the way down to the bottom turtle.

[07:21] <sorear> nom: my $class := Any; say $class.^name # how it's meant to be used

[07:21] <p6eval> nom 4e5d8a: OUTPUT¬´Any‚ê§¬ª

[07:21] <benabik> sorear++

[07:21] *** zby_home_ left
[07:22] <benabik> nom: my $class := Any.HOW; say $class.^name

[07:22] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'dispatch:<.^>' not found for invocant of class 'Perl6::Metamodel::ClassHOW'‚ê§  in block <anon> at /tmp/Z9iHNNf7zb:1‚ê§  in <anon> at /tmp/Z9iHNNf7zb:1‚ê§¬ª

[07:22] <benabik> nom: my $class := Any.HOW; say $class.name($class)

[07:22] <p6eval> nom 4e5d8a: OUTPUT¬´Any‚ê§¬ª

[07:22] <benabik> nom: my $class := Any.HOW.HOW; say $class.name($class)

[07:22] <p6eval> nom 4e5d8a: OUTPUT¬´Perl6::Metamodel::ClassHOW‚ê§¬ª

[07:23] <benabik> nom: my $class := Any.HOW.HOW.HOW; say $class.name($class)

[07:23] <p6eval> nom 4e5d8a: OUTPUT¬´NQPClassHOW‚ê§¬ª

[07:23] <sorear> don't get into the habit of writing $class.name($class)

[07:23] <japhb> benabik discovered why I was compulsively writing the longhand.  :-)

[07:23] <sorear> it's wrong

[07:23] *** jaldhar left
[07:23] <japhb> Once you cross into the metamodel, .^ doesn't work.

[07:23] <japhb> ... at least, not in nom

[07:23] <sorear> it happens to work because all of jnthn's metaclasses (except KnowHOW) ignore their argument

[07:24] <sorear> the correct way to write the longhand is $class.HOW.name($class)

[07:24] <sorear> the invocant and the first argument should not be the same

[07:24] <japhb> Yes, and you'll note I was using the correct longhand.  ;-)

[07:24] <sorear> But benabik was not.

[07:24] <benabik> nom: my $class := Any.HOW.HOW; say $class.HOW.name($class)

[07:24] <p6eval> nom 4e5d8a: OUTPUT¬´NQPClassHOW‚ê§¬ª

[07:25] * japhb nods in acknowledgement

[07:25] <benabik> sorear: Ah, I see the difference.  Hard for me to remember this late at night.

[07:26] <sorear> your IRC client thinks you're in London.  How late is the night?

[07:26] <benabik> London?

[07:26] <sorear> 0730

[07:26] * japhb tables this line of thought until jnthn++ is back to explain how it can magically Just Work.  :-)

[07:26] <sorear> UTC+0000

[07:27] <benabik> Oh.  It's returning UTC.  I have no idea why.  I'm EST.  -5

[07:27] <sorear> now it's my turn to be all tired braney, I was thinking "EEST?  That's not night at all!"

[07:28] <benabik> Heh.  There's a reason I added the -5

[07:28] * benabik doesn't see an option for fixing local time.  Pity.

[07:29] <japhb> sorear, What exactly did you want to talk about re: Pair syntax?  Obviously I think it should try to interpret a string that looks like a colon pair as a numeric form first, since we can assume that colon syntax with a decimal integer key is not meant as a Pair but rather as a Numeric.

[07:29] <sorear> benabik: irssi?

[07:29] <japhb> But I'm not sure what you are thinking beyond that?

[07:29] <benabik> sorear: Colloquy

[07:29] <sorear> benabik: oh, you're not using a colo server?

[07:30] * sorear had to manually set the timezone in .bashrc on this VM

[07:30] <benabik> It's always displayed the timestamps in UTC, but I figured that was server time.  :-/

[07:30] <benabik> No, this is running on my laptop.

[07:30] <benabik> I intend to set up a bouncer on my server when I rebuild it.

[07:31] <sorear> (seriously, who thinks 'America/Los_Angeles' is a sane way to set a timezone?  I'm 200 miles south of LA, but I can't seem to set an actual offset.)

[07:33] <benabik> America/New_York makes sense for me, but I bet it was named after the city, not the state.

[07:33] <sorear> japhb: Mostly I just want to co-ordinate.

[07:37] <benabik> sorear: I think you can use US/Pacific instead of America/Los_Angeles.  The reason why you can't just use an offset is that it also has to find leap seconds, DST, etc etc

[07:39] <japhb> sorear, so that our algorithm is (functionally) the same, I assume?  Which is to say, both Niecza and Rakudo will make the same sort of thing out of identical strings?

[07:40] <sorear> japhb: yes

[07:40] <japhb> Ah, excellent.

[07:41] <sorear> japhb: also I don't want to duplicate work on the grammars & stuff

[07:41] <japhb> Fair enough.

[07:41] <sorear> Do leap seconds actually vary by locale?  I thought IERS set them for everyone.

[07:42] <benabik> Not everyone listens?

[07:42] <japhb> Well, the thing that started me down the mental path that eventually led to trying to introspect all the turtles was just making sure I had a good mental model of all the types and how I wanted to approach (or ignore) them for val().

[07:43] <benabik> Huh.  file reports different numbers of "transition times" for US/Eastern and US/Pacific.

[07:43] <japhb> As benabik++ said, I suspect not every timezone respects leap seconds.

[07:43] <tadzik> ingy: yes, HTTP::Easy supports PSGI

[07:43] <japhb> tadzik, What is the intended difference between HTTP::Server::Simple and HTTP::Easy?

[07:44] <japhb> Or do they in fact inhabit the same niche?

[07:44] <sorear> (IERS has to be one of the coolest NGO names anywhere)

[07:45] <tadzik> japhb: HTTP::Easy is generally HTTP::Server::SImple rewritten with some new features, I observed

[07:45] <japhb> Ah, OK.

[07:47] <japhb> sorear, one thing that occurs to me with val() is that we might want some way to remove some of the default-secure at programmer request.  Specifically, I've already wanted to be able to say "Expose this Enum to val()", even though I think the default should be that no Enum not provided by the setting should be visible.

[07:48] <sorear> I don't like this proliferation of random names.  It should just be called HTTP:auth<cpan:TADZIKES>

[07:50] <sorear> japhb: to me, that's not a security issue but rather a single-valuedness issue

[07:51] <sorear> japhb: I don't really care if user input can get enum values, but I do think that if val uses CALLER, we'll have a lot more problems

[07:51] <sorear> (for a start, CALLER absolutely will not work with the constant folding I implemented earlier today)

[07:53] <japhb> Hence my thought that if one wanted to expose additional types to val(), they'd have to expose that desire at the call site.  An adverb on val(), perhaps, or even another sub entirely.

[07:54] <bacek> jnthn, ping

[07:54] <japhb> bacek, chances are he's still asleep

[07:55] <bacek> japhb, ah, thanks. In which timezone he is now?

[07:55] <japhb> Sweden, I believe

[07:55] <bacek> ok

[07:55] <japhb> (But he likes to go to sleep around 2 AM local time IIRC.)

[07:56] <bacek> aloha, clock?

[07:56] <bacek> ok, about 9PM. Waaaaay too early :)

[07:57] <sorear> japhb: ...no wonder we get along so well! :D

[07:58] <japhb> *chuckle*

[07:58] <sorear> o/ bacek

[07:59] *** lutok joined
[08:00] *** stepnem joined
[08:06] <japhb> Are there (Perl 6) types that (should) exist by the end of the setting that are not represented in the list at the end of nom's src/Perl6/Metamodel/BOOTSTRAP.pm ?

[08:06] <japhb> Duh, yes.

[08:06] <japhb> Sigh.

[08:07] <japhb> All I want for winter holiday is NomIllGuts.

[08:11] <sorear> S02's list of types not good enough for you?

[08:11] *** baest_ is now known as baest

[08:12] <masak> morning, #perl6

[08:12] <sorear> masak!

[08:12] <masak> sorear! \o/

[08:12] <tadzik> hello masak!

[08:13] <masak> oh hai tadzik 

[08:13] <masak> I think you can expect jnthn soonish -- or at least not too late.

[08:15] * sorear is studying the uses of <typename> and <type_constraint> in STD

[08:16] <sorear> trying to figure out how best to handle the entire gamut

[08:16] <japhb> sorear, I can pull most of what I want from different places in S02, yes.

[08:17] <sorear> japhb: what kind of charts do you want?

[08:17] <japhb> But I was hoping to not have to do the gathering by hand.  :-)

[08:17] <japhb> sorear, Have you seen IllGuts for Perl 5?

[08:18] <sorear> not recently

[08:18] <japhb> or rather, perl5, I suppose.

[08:19] <japhb> The doc's been kept up to date.  Someone's got a rev for every perl5 release with a guts change.

[08:19] <japhb> Anyway, I want to have such a thing for Rakudo.  If I have to create it myself, I will.  :-)

[08:20] <sorear> japhb: I am going to guess now that pm is an early riser.

[08:21] <japhb> pmichaud?  Why do you say that?

[08:21] <sorear> I wonder what should be allowed inside the () in my Str(...) $x;

[08:21] <sorear> japhb: because jnthn sleeps at 2am, and I don't get along nearly as well with pm

[08:22] <japhb> *snrk*

[08:23] <sorear> STD parses the ... as a postcircumfix

[08:23] <sorear> so you could have my Str(:bar) $x ... which is just wrong

[08:23] <sorear> it should probably be limited to smartmatchers or type objects

[08:24] <sorear> seems to me it might be better to parse it as '(' <typename>? ')'

[08:26] *** orafu left
[08:26] *** orafu joined
[08:26] <masak> sorear: yes, pmichaud is an early to very early riser.

[08:28] *** mj41 joined
[08:30] *** cognominal_ joined
[08:30] <sorear> masak: constant folding!

[08:30] <sorear> masak: also, isBEKaml expressed interest in Yapsi.

[08:31] <japhb> All this talk of sleep and waking is reminding me that kid's vacation is over, and thus I'd better get to bed, or regret it when the alarm goes off.  ;-)

[08:31] <sorear> :)

[08:31] <masak> sorear: oh, so that's how you got the exponentiation to be faster. kudos!

[08:31] <sorear> good night

[08:32] <japhb> good night all &

[08:32] <masak> o/

[08:32] *** cognominal left
[08:32] <moritz> \o

[08:33] <sorear> I see how this works ... type_constraint is only used in signatures, easy enough

[08:34] <sorear> still a bit of a tangle with leading :: support; not sure if I should try to restrict the grammar or the actions

[08:35] <sorear> (NONE of the places where typename is used, have a use for a WHENCE block, but typename still looks for one.  Etc.)

[08:36] <sorear> nom: sub foo(Int(Cool) $x) { }

[08:36] <p6eval> nom 4e5d8a: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "(Int(Cool)"‚ê§¬ª

[08:37] <sorear> nom: sub foo(Cool $x as Int) { say $x }; foo 1.5

[08:37] <p6eval> nom 4e5d8a: OUTPUT¬´1‚ê§¬ª

[08:37] <sorear> ah, not quite on the latest spec?

[08:38] * sorear -> sleep

[08:47] <jnthn> morning

[08:47] <phenny> jnthn: 05:40Z <moritz> tell jnthn about https://gist.github.com/1581336 (nqp qbootstrap test output with ICU)

[08:48] <jnthn> moritz: Thanks :)

[08:48] <masak> sorear: no, not quite on the latest spec with that one.

[08:48] <jnthn> The latest spec on that one is deeper than being a purely syntactic matter

[08:49] <jnthn> I think coercion types are meant to be first class or some such...

[08:52] *** snearch joined
[08:52] *** daxim left
[08:53] <masak> not sure I see what that means.

[08:54] <jnthn> Not sure I fully do yet either :P

[08:54] <moritz> I thought it just meant that you store two types per container

[08:55] <moritz> the type to coerce to, and the type that is checked before coercion

[08:56] *** wolverian joined
[08:56] *** daxim joined
[08:57] <jnthn> role R[::T] { method m(T $x) { } }; R[Int(Str)].m('42') # should this be possible?

[08:57] <jnthn> afk for a moment

[08:58] <masak> I don't immediately see any problems with that.

[08:58] <masak> and yes, that explains what "first class" means for coercion types.

[08:58] <moritz> I too see the point now, and I don't know if that's meant to work

[08:59] *** cognominal_ left
[08:59] *** cognominal joined
[09:00] *** icwiener joined
[09:09] <kshannon> moritz++ # Awesomness of acronyms on irc.perlgeek.de

[09:09] <masak> the thing inside the R[] is a signature, and we know that signatures can contain Int(Str) -- hence the above is correct. :)

[09:11] <moritz> masak: no, it's not a signatue

[09:11] <moritz> *signature

[09:11] <moritz> masak: it's a signature in the declaration (R[::T]), but not in the application. There it's an argument list or Capture

[09:12] <jnthn> What moritz said

[09:12] <jnthn> It's showing up as a term in my example

[09:12] <jnthn> Probably parsed by typename

[09:12] <jnthn> er

[09:12] <jnthn> by term:name

[09:13] <moritz> masak: yesterday I closed a bug where you tried to use ::T inside the role concretization, and got a NPMCA; now you just get a different error :-)

[09:13] <moritz> b: role A[$x] { }; class B does A[::T] { }

[09:13] <p6eval> b 1b7dd1:  ( no output )

[09:13] <moritz> b: role A[$x] { }; class B does A[::T] { }; say B.new

[09:13] <p6eval> b 1b7dd1: OUTPUT¬´B()<0x4b76490>‚ê§¬ª

[09:13] <moritz> huh, then that ticket was really old

[09:13] <jnthn> ...what does that mean? :)

[09:14] <moritz> nom: role A[$x] { }; class B does A[::T] { }; say B.new

[09:14] <p6eval> nom 4e5d8a: OUTPUT¬´===SORRY!===‚ê§Could not locate compile-time value for symbol T‚ê§¬ª

[09:14] <jnthn> nor could I, nom :)

[09:14] <moritz> b: role A[$x] { method x() { $x } }; class B does A[::T] { }; say B.new.x

[09:14] <p6eval> b 1b7dd1:  ( no output )

[09:14] *** mkramer left
[09:14] <moritz> b: role A[$x] { method x() { $x } }; class B does A[::T] { }; say B.new.x.WHAT

[09:14] <p6eval> b 1b7dd1: OUTPUT¬´Failure()‚ê§¬ª

[09:14] <moritz> b: role A[$x] { method x() { $x } }; class B does A[::T] { }; say B.new.x.perl

[09:14] <p6eval> b 1b7dd1: OUTPUT¬´undef‚ê§¬ª

[09:14] <jnthn> o.O

[09:15] <jnthn> Glad nom didn't do that, or masak'd be submitting already :P

[09:16] <moritz> I don't think nom mentions undef, except for generating an error message about misuse of undef

[09:17] <jnthn> Good. :)

[09:18] * jnthn figures he should do some $dayjob

[09:21] *** dakkar joined
[09:23] <masak> point taken about the signature/capture distinction in parametric roles. it mirrors the declare/use of routines, I guess.

[09:23] <jnthn> Rajt.

[09:24] <masak> Grejt.

[09:30] *** mikemol joined
[09:33] <dalek> nqp: bb332d9 | bacek++ | src/pmc/ (3 files):

[09:33] <dalek> nqp: Don't use pmc-specific accessors when not necessary

[09:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/bb332d93b6

[09:39] *** orafu left
[09:39] *** orafu joined
[09:59] <cognominal> S04-control.pod:1668:    macro statement_control:<if> ($expr, &ifblock) {...}

[09:59] <cognominal>  does that mean that macro call arguments are not space separated?

[10:00] <jnthn> ...what's a macro doing taking something with an & sigil?

[10:00] <jnthn> It only gets ASTs in, no?

[10:00] <cognominal> that also...

[10:01] <masak> jnthn: ooh, I had not seen that one before.

[10:02] <cognominal> but that may be a macro for the implementation of an interpreter

[10:02] <masak> but yeah, the specification is full of those half-working macro examples.

[10:02] <masak> to be fair, E06 is worse ;)

[10:02] * jnthn just asks masak when he wants to know how macros will work :)

[10:03] <masak> I don't think they'll ever work like S04:1668 :)

[10:03] <cognominal> meaning a function is returned not an ASTm to be bound to &ifblock

[10:05] <masak> keep in mind though that these bits of the spec are known to be slushy. TimToady proposed a whole 'nuther *syntax* for quasi-interpolation a few months back, which never went into the spec because it was vastly problematic.

[10:05] <masak> (the syntax proposed to annotate each unit of interpolation with a syntactic class.)

[10:05] <kshannon> jnthn:  you're rxtrace in qbootstrap has some issues...

[10:06] <kshannon> ./nqp t/nqp/01-literals.t  dies with: Confused at line 18, near "say(q  <ok"

[10:06] <kshannon> ./nqp --rxtrace t/nqp/01-literals.t  instead: Confused at line 5, near "say('1..9'"

[10:06] <kshannon> find_dynamic_lex of "$*QUOTE_STOP" stops working...

[10:06] <tadzik> did you mean: your?

[10:06] <kshannon> s/you're/your/

[10:08] <jnthn> kshannon: That's...odd. 

[10:08] <kshannon> very.

[10:10] <kshannon> I patched QHLL/Grammar.pm stopper to die if it can't find $*QUOTE_STOP and it does just after the ' on line 5,  but only when --rxtrace is on.

[10:13] <jnthn> wtf

[10:14] <kshannon> I really wish the parrot debugger was in a workable state.  GDB just isn't at the right level :(

[10:18] <bacek> jnthn, \o

[10:18] <jnthn> o/ bacek 

[10:18] <bacek> jnthn, have a few minutes? I've got few questions about 6model

[10:19] <jnthn> bacek: I'm $dayjobbing, but can probably answer a few :)

[10:20] <bacek> jnthn, I'll try to be short :) Why in SixObjectCommonalities "stable" and "sc" are PMCs? Just for GC?

[10:21] <bacek> jnthn, (next one) what do you think is bare minimum of VTABLEs required to support 6model natively in Parrot? My current list is "init", "mark", "destroy", "store", "freeze" and "invoke". Did I miss something obvious?

[10:23] <jnthn> bacek: An SC probably wants to be GC-able

[10:23] <jnthn> STable need not be

[10:23] <jnthn> I've more than once pondered switching to ref-counting them.

[10:23] <jnthn> Because not doing so runs into finalisation order issues

[10:24] <bacek> jnthn, I'm thinking about something like STableRegistery for memory management.

[10:24] <bacek> .. of STables

[10:24] <jnthn> So long as they can be collected

[10:24] *** donri joined
[10:25] <jnthn> Well

[10:25] <jnthn> freed

[10:25] <jnthn> When no longer needed

[10:25] <bacek> jnthn, erm. Who cares? They are freed only at program exit afaik.

[10:25] <jnthn> No

[10:25] <bacek> ah. My bad.

[10:26] <jnthn> Types can come into existence during execution

[10:26] <jnthn> And then go out of scope and need freeing

[10:27] <bacek> otoh, how many different types we can have? 1k? 10k? 100k? 

[10:27] <jnthn> 100k would be very unusual, I suspect. 

[10:27] <jnthn> Well

[10:27] <jnthn> Existing at once

[10:28] <bacek> Indeed.

[10:28] <jnthn> There's no hard limit of course, but generally you have many instnaces of a much smaller number of types

[10:28] <bacek> 10k stables. With 100 bytes per stable it's only 1M of memory

[10:29] <jnthn> Yeah, and 10k sounds excessive.

[10:29] <jnthn> Well, for a large application maybe not

[10:29] <bacek> Not a big deal if we will keep them till end.

[10:29] <jnthn> Oh, I said "existing at once"

[10:30] <jnthn> Example: Test::Mock creates anonymous subclasses for mock objects. They need collecting, otherwise each test csae leaks memory

[10:30] *** tokuhirom joined
[10:30] <jnthn> Or even internally, I think role composition's temporary summation role that it creates may be collectable.

[10:31] <bacek> Ok. Agreed. To summarise: STable should be "GCable" but not necessary PMC.

[10:31] <jnthn> Well

[10:31] <jnthn> PMCs really want to be 6model objects I guess.

[10:31] <bacek> jnthn, yes. 

[10:33] <bacek> jnthn, this lead us to next question: "minimal set of VTABLEs" :)

[10:33] <bacek> afk # bb in 5

[10:35] <jnthn> Mark and destroy are representation operations.

[10:36] <jnthn> init - really needs splitting in two. What are the required initialization actions at a representation level, no matter what type we have (which is what initialize in the REPR API is for), plus some type-space mechanism that's like Perl 6's BUILD.

[10:37] <jnthn> The initialization level ones are non-optional and just part of object creation.

[10:41] <kshannon> Ah!  find_dynamic_lex is working,  it's the return from peek_delimiters...

[10:41] <kshannon> (start, stop) = self.'peek_delimiters'(target, pos)

[10:41] <moritz> that only works in PIR I suppose

[10:41] <kshannon> TWO return arguments...  the trace wrapper only passes ONE back...

[10:41] <moritz> not on the NQP level

[10:41] <moritz> oh, that's it

[10:42] <bacek> jnthn, we have 2 stage registration of PMC in Parrot right now. First stage can be used for init REPRs.

[10:42] <jnthn> Oh.

[10:43] <jnthn> bacek: Something in there sounds like a mis-understanding...

[10:43] <bacek> jnthn, second stage can be used as .compose for PMCs. Or we can even simplify it a bit.

[10:43] <kshannon> I'm starting to get pretty good at twisting GDB to do what I need for breakpoints in parrot.

[10:43] <bacek> jnthn, erm... Explain?

[10:43] <jnthn> OK, now I'm really confused

[10:45] <jnthn> bacek: Every object has an STable pointer. An STable points in turn to a meta-object and a REPR function table. That function table is a "singleton" per REPR. If it wants per-type data, it hangs it off the STable.

[10:45] <jnthn> bacek: The meta-object is just a completely normal object.

[10:46] <jnthn> bacek: It's meta-objects that generally have compose methods. But generally it's just a convention, not something that'd be baked in too deeply

[10:47] <jnthn> bacek: The point is that representation operations are not vtable-like things on an object itself. In fact, if you statically know the representation then it needn't be an indirect call at all.

[10:47] <bacek> jnthn, oookey. 

[10:48] <moritz> nom: enum A <b c>; say A.HOW

[10:48] <p6eval> nom 4e5d8a: OUTPUT¬´Method 'gist' not found for invocant of class 'Perl6::Metamodel::EnumHOW'‚ê§  in sub say at src/gen/CORE.setting:5702‚ê§  in block <anon> at /tmp/az7G1FQd1v:1‚ê§  in <anon> at /tmp/az7G1FQd1v:1‚ê§¬ª

[10:50] <moritz> jnthn: if I want to add a method that all enums need to have, do I put it into EnumHOW?

[10:51] <jnthn> moritz: ?

[10:51] <moritz> erm, no, that's the wrong meta level

[10:51] <jnthn> Right :)

[10:51] <moritz> where does it go?

[10:51] <jnthn> moritz: See src/core/Enumeration.pm

[10:51] <moritz> ah, wonderful

[10:51] <moritz> nom: say Bool.pick

[10:52] <p6eval> nom 4e5d8a: OUTPUT¬´Bool::True‚ê§¬ª

[10:52] <moritz> that one is fixed already, great

[10:53] *** explorer__ joined
[10:54] <kshannon> nom: say Bool.pick

[10:54] <p6eval> nom 4e5d8a: OUTPUT¬´Bool::False‚ê§¬ª

[10:54] <kshannon> just checking...

[10:54] * moritz adds Bool.roll too

[10:54] <moritz> nom: say Bool.roll(8)

[10:54] <p6eval> nom 4e5d8a: OUTPUT¬´True True True True False True True True‚ê§¬ª

[10:55] *** DarthGandalf joined
[10:55] <moritz> why does that work, even though there's no method roll in src/core/Enumeration.pm?

[10:55] <moritz> nom: say Bool.roll

[10:55] <p6eval> nom 4e5d8a: OUTPUT¬´Bool::True‚ê§¬ª

[10:56] <moritz> oh, I guess Any.roll re-dispatches to self.pick or so

[10:56] <moritz> nom: say Bool.list

[10:56] <p6eval> nom 4e5d8a: OUTPUT¬´use of uninitialized value of type Bool in string context‚ê§‚ê§¬ª

[10:57] <moritz> no, it doesn't. Any.roll redispatches to self.list.roll, and List.roll does all the work itself

[11:00] <bacek> jnthn, why SixModel_REPROps_Indexing supports only integer indexes? And how hashes are implemented in terms of REPR?

[11:00] <jnthn> moritz: Because Bool isn't an enum, iirc

[11:00] <jnthn> bacek: Oh, the index REPR ops part is *very* new.

[11:01] <jnthn> *indexed

[11:01] *** explorer__ left
[11:01] <bacek> jnthn, hmm... Looks like you'll have full set of current parrot's VTABLEs in REPRs... 

[11:02] <jnthn> bacek: Only those that explicitly relate to allocation and storage of stuff. For example, there'd never be a find_method, does, etc. 

[11:05] <moritz> nom: enum A <b c>; say A.pick(*); say A.roll(8)

[11:05] <p6eval> nom 4e5d8a: OUTPUT¬´b c‚ê§use of uninitialized value of type A in string context‚ê§use of uninitialized value of type A in string context‚ê§use of uninitialized value of type A in string context‚ê§use of uninitialized value of type A in string context‚ê§use of uninitialized value of type A in stri‚Ä¶

[11:05] <bacek> jnthn, ook. So, get_{foo}_keyed_{bar} is in. 

[11:05] <bacek> jnthn, get/setattr is in (Modulo my confusion about what the heck is difference between attr and prop in parrot)

[11:06] <bacek> jnthn, boxing is in

[11:06] <bacek> jnthn, all math ops are out (?)

[11:06] <moritz> bacek: what are you trying to do? migrate 6model to parrot?

[11:07] <bacek> moritz, other way round. Migrate parrot to 6model

[11:07] <masak> \o/

[11:07] <bacek> moritz, to make parrot small, simple, fast and comprehensible.

[11:08] <masak> bacek++

[11:08] <moritz> bacek: awesome!

[11:08] <jnthn> bacek: Yeah. Either REPR-specific ops (see nqp_bigint.ops) or we always unbox things to native types and do the computation natively

[11:08] <jnthn> bacek: To clarify, I don't think Parrot should be doing MMD in PMCs at all.

[11:08] <jnthn> If languages want to do their ops that way, they probably have their own idea of multiple dispatch.

[11:08] <bacek> jnthn, it was 3rd question about MultiSub vs DispatcherSub :)

[11:09] <jnthn> bacek: DispatcherSub implements NQP multi-dispatch semantics.

[11:10] <jnthn> bacek: But really, IMHO Parrot should be dis-entangling itself from multi-dispatch, not entangling itself in another language's view of it. 

[11:10] <bacek> jnthn, if "NewMultiSub" will provide only storage for Subs with empty .invoke, than we can have "DispatcherSub" and "P6MultiSub" inherited from it and provide different semantics for MMD

[11:11] <jnthn> Argh no, not inheritance!!!

[11:11] <moritz> simply store a function pointer to the multi dispather

[11:11] <masak> jnthn: it takes some time for people to get used to a core world without inheritance :)

[11:12] <jnthn> bacek: We really need a "protocol" of some kind for invocation

[11:12] <jnthn> Where a type can say "this is what invocation means to me"

[11:12] <jnthn> bacek: I don't think we should make languages commit to one way of storing their candidate lists.

[11:12] <jnthn> bacek: Already NQP and Perl 6 look differently there

[11:13] <jnthn> bacek: When I prototyped 6model on the CLR, I did just have a delegate (basically, function pointer) hanging off the STable.

[11:14] *** LlamaRider joined
[11:15] * jnthn has to leave for $meeting soon

[11:18] <jnthn> bacek: I sense that if the notion of vtable as Parrot has it today survives a 6model transition, it's function will be mostly reduced to HLL interop.

[11:18] <jnthn> *its

[11:21] *** cognominal left
[11:23] *** cognominal joined
[11:25] *** cognominal_ joined
[11:27] <jnthn> meeting &

[11:29] *** cognominal left
[11:35] *** jaldhar joined
[11:39] *** Juerd left
[11:39] *** Juerd joined
[11:41] <bacek> jnthn, ok. 1) If MMD is basically doesn't exists from VM point of view; 2) and call is just "VTABLE_invoke" on Object; than we can hand it over to HLL.

[11:41] <bacek> jnthn, one problem - MMD over free functions. Should we have some kind of "Namespace.invoke"?

[11:49] *** tokuhirom left
[11:49] *** tokuhirom joined
[11:53] *** tokuhirom left
[11:55] *** cognominal_ left
[11:56] *** birdwindupbird joined
[11:57] *** cognominal joined
[11:58] *** satyavvd left
[12:11] *** LlamaRider left
[12:15] <masak> bacek: what's a "free function"?

[12:15] *** sayu left
[12:15] <masak> I know what a free variable is; never heard of a free function.

[12:16] <masak> nom: class C { our method foo { say "OH HAI" } }; my &f = &C::foo; f(C.new)

[12:16] <p6eval> nom 4e5d8a: OUTPUT¬´OH HAI‚ê§¬ª

[12:16] <masak> is &f a free function?

[12:20] <masak> nom: class C { our method foo { say "OH HAI" } }; my &f = &C::foo; class D is C {}; f(D.new)

[12:20] <p6eval> nom 4e5d8a: OUTPUT¬´OH HAI‚ê§¬ª

[12:21] *** araujo joined
[12:21] *** araujo left
[12:21] *** araujo joined
[12:22] <masak> nom: class C { }; class D is C { our method foo { say "OH HAI" } }; my &f = &D::foo; f(D.new)

[12:22] <p6eval> nom 4e5d8a: OUTPUT¬´OH HAI‚ê§¬ª

[12:23] <masak> nom: class C { }; class D is C { our method foo { say "OH HAI" } }; my &f = &D::foo; f(C.new)

[12:23] <p6eval> nom 4e5d8a: OUTPUT¬´Nominal type check failed for parameter ''; expected D but got C instead‚ê§  in method foo at /tmp/3Uls2VsWfb:1‚ê§  in block <anon> at /tmp/3Uls2VsWfb:1‚ê§  in <anon> at /tmp/3Uls2VsWfb:1‚ê§¬ª

[12:23] <masak> \o/

[12:23] *** pnu joined
[12:26] *** arlinius joined
[12:30] <colomon> masak: mind if I borrow your trans (from ng) for niecza?

[12:30] <kshannon> Well,  That's a lot of PIR to get a working sub wrapper...

[12:31] <kshannon> 18 lines:  4 prologue,  10 wrapped call,  4 epilogue

[12:31] <masak> colomon: go right ahead.

[12:32] <masak> colomon: fwiw, pmichaud reported some problems with that code. I never did, but it uses some slightly advanced features like lexical classes.

[12:32] <masak> s/never did/never noticed anything/

[12:33] <colomon> checking now to see if it compiles.  :)

[12:34] <masak> I remember developing that bit of code. what's in ng is a second approach, after my first one turned out not to be radical enough. :)

[12:34] <masak> the main point is to encapsulate the difference between replacement substrings and replacement regexes.

[12:41] *** cognominal left
[12:42] *** cognominal joined
[12:43] <kshannon> If anyone else (e.g. jnthn) wants my hack for tracing in qbootstrap it's at https://github.com/KrisShannon/nqp/tree/qbootstrap-trace-HACK ( git pull git://github.com/KrisShannon/nqp.git qbootstrap-trace-HACK )

[12:44] <masak> kshannon++

[12:44] <kshannon> I'm too ashamed of it to put it into the official repo...

[12:44] <masak> ;)

[12:44] <colomon> niecza: class B { has $!a; methdo foo { say $!a; };  }; my $b = B.new(a => "hello"); $b.foo

[12:44] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Variable $!a used where no 'self' is available at /tmp/b59_zkKXmv line 1:‚ê§------> [32mclass B { has $!a; methdo foo { say [33m‚èè[31m$!a; };  }; my $b = B.new(a => "hello");[0m‚ê§‚ê§Undeclared routines:‚ê§       'foo' used at line 1‚ê§‚Ä¶

[12:44] <colomon> niecza: class B { has $!a; method foo { say $!a; };  }; my $b = B.new(a => "hello"); $b.foo

[12:45] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´Any()‚ê§¬ª

[12:45] <moritz> that's correct

[12:45] <colomon> niecza: class B { has $.a; method foo { say $.a; };  }; my $b = B.new(a => "hello"); $b.foo

[12:45] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Confused at /tmp/tPJwjlfAyh line 1:‚ê§------> [32mclass B { has $.a; metho[33m‚èè[31md foo { say $.a; };  }; my $b = B.new(a[0m‚ê§‚ê§Undeclared routine:‚ê§  'metho' used at line 1‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[12:45] <moritz> niecza: class B { has $.a; method foo { say $.a; };  }; my $b = B.new(a => "hello"); $b.foo

[12:45] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´hello‚ê§¬ª

[12:45] <moritz> colomon: you had a non-printable character inside the 'method'

[12:46] <colomon> so that doesn't work to initialize $! attributes?

[12:46] <moritz> correct

[12:46] <masak> colomon: you can't see private attributes from the outside, so you can't initialize them.

[12:46] <colomon> did it used to work in rakudo?  I keep on seeing examples that try to do that...

[12:46] <masak> yes.

[12:46] <moritz> it used to be specced to work

[12:46] <moritz> until masak++ raged against it, iirc

[12:47] <moritz> helped by TheDamian

[12:47] <masak> "raged"? :)

[12:47] <masak> I'm the height of composure...

[12:47] <moritz> raged in a civilized way :-)

[12:47] <masak> it *is* a lost battle, because there has to be a mechanism or two to actually get at private attributes.

[12:48] <masak> but there are good reasons for not making it easy.

[12:49] <colomon> anyway, masak++'s old trans code relied on it.  ;)

[12:49] <colomon> and now it works!

[12:50] <moritz> colomon: you could have looked at nom, there it has   submethod BUILD(:$!source) { }  to allow that

[12:51] *** tokuhirom joined
[12:58] <masak> oh! didn't know my .trans had been ported to nom.

[12:59] <moritz> masak: it has, but it has some regression

[12:59] <moritz> s

[13:00] <masak> not surprised.

[13:00] <moritz> masak: which I haven't investigated, because I don't know the code at all

[13:00] <moritz> it was basically a "blind" port

[13:00] <moritz> nom: say 'abc'.trans('b' => 'X')

[13:00] <p6eval> nom 4e5d8a: OUTPUT¬´aXc‚ê§¬ª

[13:00] <moritz> nom: say 'abc'.trans('b' => '')

[13:00] <p6eval> nom 4e5d8a: OUTPUT¬´ac‚ê§¬ª

[13:00] <moritz> oh, I thought that one failed

[13:02] *** Trashlord joined
[13:03] <masak> nom: say 'abbbbbc'.trans('bb' => 'b')

[13:03] <p6eval> nom 4e5d8a: OUTPUT¬´abbbbbc‚ê§¬ª

[13:03] <masak> nom: say 'abbbbbc'.trans(['bb'] => ['b'])

[13:03] <p6eval> nom 4e5d8a: OUTPUT¬´abbbc‚ê§¬ª

[13:04] <masak> ooh; that's correct!

[13:06] <dalek> roast: f0e1cc8 | moritz++ | S (3 files):

[13:06] <dalek> roast: rakudo unfudges

[13:06] <dalek> roast: review: https://github.com/perl6/roast/commit/f0e1cc8cc2

[13:08] <masak> huh -- what kind of path is 'S'?

[13:08] <moritz> masak: it's the common prefix of S32 and S02 or so

[13:08] <masak> I see :P

[13:08] <masak> no further questions. :)

[13:09] <moritz> no further answers :-)

[13:20] *** tokuhirom left
[13:21] *** tokuhirom joined
[13:25] *** tokuhirom left
[13:32] *** kaleem left
[13:34] <moritz> nom: say 'a'.trans(rx/a/ => sub ($x) { $x.WHAT.gist })

[13:34] <p6eval> nom 4e5d8a: OUTPUT¬´Not enough positional parameters passed; got 0 but expected 1‚ê§  in sub <anon> at /tmp/whRiVANMpS:1‚ê§  in method next_substitution at src/gen/CORE.setting:3720‚ê§  in method trans at src/gen/CORE.setting:3765‚ê§  in block <anon> at /tmp/whRiVANMpS:1‚ê§  in <anon> at /tmp/whRi‚Ä¶

[13:34] <moritz> ah, that's the problem in current num

[13:34] <moritz> s/num/nom+trans/

[13:37] *** cognominal left
[13:38] *** cognominal joined
[13:39] <masak> hm -- did that ever work?

[13:39] <moritz> nope

[13:39] <moritz> seems not

[13:39] <moritz> b: say 'a'.trans(rx/a/ => sub ($x) { $x.WHAT })

[13:39] <p6eval> b 1b7dd1: OUTPUT¬´Not enough positional parameters passed; got 0 but expected 1‚ê§  in <anon> at line 22:/tmp/htRsXK_5tq‚ê§  in 'Cool::next_substitution' at line 2512:src/gen/core.pm‚ê§  in 'Cool::trans' at line 2559:src/gen/core.pm‚ê§  in main program body at line 22:/tmp/htRsXK_5tq‚ê§¬ª

[13:40] *** simcop2387 joined
[13:41] *** simcop2387 left
[13:41] *** simcop2387 joined
[13:41] *** alim_ joined
[13:42] <moritz> masak: the problem with your .trans code, beautiful as it may be, is that it separates the matching and the substitution far enough that we don't have the Match object around anymore when the substitution closure is called

[13:42] *** Trashlord left
[13:43] <masak> nod.

[13:43] <masak> I'm aware that it's not the final iteration.

[13:44] <masak> the big win with that code, recall, was that it took the time complexity from O(.chars) to O(<substitutions made>)

[13:44] *** xinming joined
[13:45] <masak> which was a big deal with the November wiki at some point: http://strangelyconsistent.org/blog/november-6-2010-ideals-separation-and-pragmatism

[13:45] <moritz> I'm not sure that calculation is correct though

[13:46] <moritz> it looks more like O(<subsitutions considered>)

[13:46] <moritz> nom: say 'aaa'.trans(['aa', 'a'] => ['X', 'Y'])

[13:47] <p6eval> nom 4e5d8a: OUTPUT¬´XY‚ê§¬ª

[13:47] <masak> aye, you're right about that.

[13:48] <moritz> also it uses index() and regex matches, which are still O(.chars)

[13:49] *** xinming left
[13:51] *** xinming joined
[13:51] <masak> I'll retreat my arguments from exact O() notations to "it's a lot faster".

[13:51] *** cognominal_ joined
[13:53] <moritz> O( :/ ) to O( acceptable) :-)

[13:54] *** cognominal left
[13:55] <[Coke]> .u hap

[13:55] <phenny> U+A274 YI SYLLABLE HAP (Íâ¥)

[13:55] *** xinming left
[13:58] *** daxim left
[14:02] <[Coke]> who was recently trying to split the setting?

[14:02] <[Coke]> (for rakudo)

[14:02] * moritz 

[14:02] *** daxim joined
[14:04] <[Coke]> any luck? and do you think breaking up the setting will speed up the build?

[14:04] <[Coke]> (or at least reduce memory pressure?)

[14:04] <moritz> reducing memory pressure is my main goal

[14:04] <moritz> I've succeeded in moving some very few, isolated files out of the main setting

[14:04] <moritz> for example the MAIN_HELPER

[14:05] <moritz> but it seems I can't easily add multi candidates in the second setting to a proto defined in the first setting

[14:05] <moritz> jnthn++ promised to look into it

[14:06] <moritz> if that's fixed, it might be possible to move all the Temporal stuff to the second setting

[14:06] <moritz> maybe IO::Socket too

[14:06] <moritz> hm, that one might work today already

[14:06] <jnthn> jnthn is always saying he'll do stuff 

[14:06] <jnthn> :)

[14:06] * jnthn will try and get to it today...qbootstrap hacking sucked up yesterday's tuit supply

[14:09] <moritz> [Coke]: anyway, I already reduced virtual memory usage from 1.7G to 1.6G. Success!!!

[14:10] <[Coke]> \o/

[14:11] <dalek> rakudo/nom: 8b620e7 | moritz++ | src/core/Enumeration.pm:

[14:11] <dalek> rakudo/nom: Enumeration.roll

[14:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8b620e7896

[14:12] *** spine_ joined
[14:13] *** mkramer joined
[14:16] <dalek> roast: 8f11d73 | (Solomon Foster)++ | S05-transliteration/trans.t:

[14:16] <dalek> roast: Fudge for niecza.

[14:16] <dalek> roast: review: https://github.com/perl6/roast/commit/8f11d73386

[14:17] <moritz> meh, moving IO::Socket +INET to core2 gives the same 'rtype not set' error :/

[14:19] *** fsergot left
[14:22] *** mkramer left
[14:22] *** skids joined
[14:24] *** mkramer joined
[14:26] *** mkramer left
[14:26] *** simcop2387 left
[14:27] *** mkramer joined
[14:28] *** fsergot joined
[14:28] <fsergot> o/ :)

[14:29] <moritz> \o

[14:31] *** birdwindupbird left
[14:33] * [Coke] thinks we might hit 97% today, if colomon can find a few more of those. ;)

[14:34] *** PacoAir joined
[14:35] *** simcop2387 joined
[14:35] *** simcop2387 left
[14:35] *** simcop2387 joined
[14:36] *** kaleem joined
[14:37] <colomon> [Coke]: don't count on it, I need to $work

[14:38] <[Coke]> aw. *pout* (me too. ;)

[14:39] *** simcop2387 left
[14:39] <[Coke]> colomon: are you missing a push to niecza, or is that for later?

[14:39] <colomon> [Coke]: well, it's like this.

[14:40] <colomon> I ported masak++'s trans code to niecza.

[14:40] <colomon> and then I spectested

[14:40] <colomon> and then I got a bunch of failures.

[14:40] <[Coke]> (we are at just over 96% as of about 20m ago.)

[14:40] <colomon> right now I'm trying to verify the failures have nothing to do with my patch

[14:40] <[Coke]> roger.

[14:40] *** simcop2387 joined
[14:43] *** nebuchadnezzar joined
[14:50] <colomon> niecza: say 13e21 %  4e21 -  1e21

[14:50] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´NaN‚ê§¬ª

[14:50] *** kaleem left
[14:50] <colomon> niecza: say 13e21 %  4e21

[14:51] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´NaN‚ê§¬ª

[14:51] <colomon> well now, that's revolting

[14:51] <moritz> perl6: say 13e21 %  4e21

[14:51] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´NaN‚ê§¬ª

[14:51] <p6eval> ..rakudo 8b620e: OUTPUT¬´1e+21‚ê§¬ª

[14:51] <p6eval> ..pugs b927740: OUTPUT¬´1000000000000000000000‚ê§¬ª

[14:51] <colomon> niecza: say (13e21 %  4e21)

[14:51] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´NaN‚ê§¬ª

[14:51] <colomon> niecza: say (13e21) %  (4e21)

[14:51] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´NaN‚ê§¬ª

[14:51] <colomon> I think it must be from the constant folding patch

[14:51] <colomon> because this worked yesterday in niecza.

[14:53] *** kaleem joined
[14:54] <colomon> dunno if it's worth trying to hunt it down, or if sorear++ will just look at it and realize what is wrong

[14:54] <moritz> niecza: my ($a, $b) = (13e21, 4e21); say $a % $b

[14:54] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´1E+21‚ê§¬ª

[14:54] <moritz> constant folding indeed

[14:55] <colomon> moritz++ # smartness

[14:55] *** mkramer left
[14:55] *** kmwallio joined
[14:56] <[Coke]> I see 8 new failures since yesterday, but haven't tracked it down.

[14:56] <dalek> niecza: 27b68eb | (Solomon Foster)++ | lib/CORE.setting:

[14:56] <dalek> niecza: Straightforward port of masak++'s .trans method from Rakudo ng.

[14:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/27b68eb8d5

[14:56] <dalek> niecza: a43ea40 | (Solomon Foster)++ | t/spectest.data:

[14:56] <dalek> niecza: Turn on S05-transliteration/trans.t.

[14:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a43ea40805

[14:56] <colomon> niecza: say 'bit' ~& 'wise'

[14:56] <p6eval> niecza v13-169-geba5eb3: OUTPUT¬´Unhandled exception: Buffer bitops NYI‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1075 (die @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2396 (infix:<~&> @ 3) ‚ê§  at /tmp/hPe44s2pLW line 1 (mainline @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setti‚Ä¶

[14:56] <dalek> roast: dcb1827 | (Solomon Foster)++ | integration/real-strings.t:

[14:56] <dalek> roast: Fudge for niecza.

[14:56] <dalek> roast: review: https://github.com/perl6/roast/commit/dcb182716e

[14:57] <dalek> niecza: 452c98b | (Solomon Foster)++ | t/spectest.data:

[14:57] <dalek> niecza: Turn on integration/real-strings.t.

[14:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/452c98b674

[15:00] <masak> in Niecza, unimplemented features are exceptions.

[15:00] <masak> :)

[15:00] *** wolfman2000 left
[15:01] *** carlin joined
[15:01] <moritz> nom: try calframe.callframe; say $!.WHAT

[15:01] <p6eval> nom 8b620e: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&calframe' called (line 1)‚ê§¬ª

[15:02] <moritz> nom: try callframe.callframe; say $!.WHAT

[15:02] <p6eval> nom 8b620e: OUTPUT¬´X::NYI()‚ê§¬ª

[15:02] <moritz> :-)

[15:02] <jnthn> Typed exceptions :)

[15:02] <jnthn> moritz++

[15:03] <colomon> hmmm... does it even make sense to call a buffer bitop on two strings?

[15:03] <colomon> perl6: say 'bit' ~& 'wise'

[15:03] <p6eval> pugs b927740, rakudo 8b620e: OUTPUT¬´bip‚ê§¬ª

[15:03] <p6eval> ..niecza v13-169-geba5eb3: OUTPUT¬´Unhandled exception: Buffer bitops NYI‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1075 (die @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2396 (infix:<~&> @ 3) ‚ê§  at /tmp/I2Loy_et2Q line 1 (mainline @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setti‚Ä¶

[15:04] <moritz> colomon: ~& is meant to be a string bitwise op, not necessarily a buffer bitwise op

[15:04] <moritz> but what they mean is another questions, since bitops usually have to assume a fixed bit width

[15:04] <colomon> but... doesn't it depend on the string encoding?

[15:04] <moritz> which strings don't have

[15:05] <moritz> colomon: iirc the ops boil down to bit operations on the codepoint numbers

[15:05] <colomon> ugh

[15:06] <masak> TimToady usually says that string literals are allomorphic wrt Str/Buf.

[15:06] <moritz> which you can do just fine for & and |, but starts to get hairy for ^

[15:06] <masak> implementation is left as an exercise to the reader ;)

[15:07] * colomon turns on his SEP field...

[15:07] <moritz> colomon: it's turned off by default?

[15:07] <moritz> how can you possibly survive?

[15:08] <colomon> ;)

[15:08] <[Coke]> moritz: ... why do YOU care? ;)

[15:08] <masak> [Coke]: because his field is off, duh!

[15:09] * skids spitballs on compact structs/regex/pack/unpack

[15:09] <skids> What if	<:: > metasyntax, if invoked as <::Class> treated a Class as a rule

[15:09] <skids> (and sucked in the number of bytes in the compact struct, assuming 8-bit)

[15:09] <moritz> [Coke]: because I wonder how low I can tune my field, and remain as (in)sane as I am today

[15:09] <masak> skids: why do you need to treat Class as a role for that?

[15:10] <skids> rule, not role

[15:10] <skids> The normal assignment mechanisms being used to say where to stuff it

[15:10] <skids> And a lookahead	before that could serve	to validate fields if needed

[15:10] * masak can't read :)

[15:11] * [Coke] finds the embedded tabs not readable.

[15:11] <masak> skids: there are inexplicable Tab characters (^I) in your communication.

[15:11] <skids> Oh crap.  Was pretyping and pasting.

[15:11] <skids> Funny they don't show up on my client.

[15:11] <masak> phenny: sv en "tabbe"?

[15:11] <phenny> masak: "gaffe" (sv to en, translate.google.com)

[15:11] <masak> :P

[15:12] <moritz> phenny: de en "plenken"?

[15:12] <phenny> moritz: "Plenk" (de to en, translate.google.com)

[15:14] <LoRe> phenny: de en "kohlmeisen"

[15:14] <moritz> phenny: de en "kohlmeisen"?

[15:14] <phenny> moritz: "Great Tits" (de to en, translate.google.com)

[15:14] <[Coke]> O_o

[15:15] <moritz> it should append (bio.) or so :-)

[15:15] <moritz> http://en.wikipedia.org/wiki/Great_Tit

[15:15] <colomon> as opposed to silicone, moritz?

[15:16] <moritz> colomon: as opposed to the vulgar interpretation you are thinking of :-)

[15:16] <skids> I was going to say what could be more "bio" than great tits, but then colomon brought up silicone.

[15:18] *** araujo left
[15:20] *** sivoais joined
[15:21] * [Coke] wonders if niecza/perl6 has a "nocritic" option to allow intentionall defined but unused constructs for, say, tests that are try to excercize a side effect.

[15:21] <masak> "'Plenken' is derived as a borrowed word from the English 'blank'." -- http://en.wikipedia.org/wiki/Plenken

[15:21] <masak> [Coke]: there's #OK

[15:22] <masak> might work.

[15:22] <masak> niecza: my $a

[15:22] <p6eval> niecza v13-172-g452c98b: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/8eEryAM0NI line 1:‚ê§------> [32mmy [33m‚èè[31m$a[0m‚ê§‚ê§¬ª

[15:22] <masak> niecza: my $a #OK

[15:22] <p6eval> niecza v13-172-g452c98b:  ( no output )

[15:22] <masak> yup.

[15:22] * [Coke] ponders applying that liberally to the spec tests.

[15:23] * [Coke] guesses it's not worth it for right now.

[15:23] <colomon> we really should have a roast hackathon someday and try to clean the test files up

[15:31] * [Coke] reruns after colomon's commits:

[15:31] <[Coke]> niecza at 96.39%

[15:31] *** rjbs joined
[15:31] <rjbs> Good morning, butterfly people.

[15:31] *** araujo joined
[15:31] <rjbs> I have a question for you about rt.perl.org's perl6 queue.

[15:31] <masak> shoot.

[15:31] <[Coke]> niecza: say 18513*.97-17845

[15:31] <p6eval> niecza v13-172-g452c98b: OUTPUT¬´112.61‚ê§¬ª

[15:31] <rjbs> I am now a moderator for mail that gets reported to rt.perl.org's perl6 queue by email.

[15:32] <masak> rjbs: you mean all bug reports, for example?

[15:32] <rjbs> Yes, or followups.

[15:32] <rjbs> Example email in the queue:

[15:32] <rjbs> [001] MODERATE for [email@hidden.address]
[15:32] <rjbs> From:     [email@hidden.address] (via RT) [email@hidden.address]
[15:32] <rjbs> Subject:  [perl #107780] Compliments of the Season. 

[15:32] <rjbs> Obviously, this is spam.

[15:32] <masak> aye.

[15:32] <moritz> agreed.

[15:32] <rjbs> If I delete the message, the ticket *is still there*

[15:32] <masak> aye.

[15:32] <rjbs> So it might just sit there, looking like ignored spam in your queues.

[15:33] <rjbs> If I approve the message, you will get the spam mail, which will alert you to go delete/reject the ticket.

[15:33] <rjbs> Which would you folks prefer?

[15:33] <[Coke]> delete the mail.

[15:33] <masak> just sit there, I think.

[15:33] <moritz> rjbs: I'd prefer to never see that ticket

[15:33] <[Coke]> we go through often enough that we'll see the spam sitting in the rt queue.

[15:33] <masak> right.

[15:33] <masak> we don't want to inconvenience p6c with spam.

[15:34] <rjbs> Okay, thanks.

[15:34] <[Coke]> I delete a few of those every week. (for p6 & tpfgrants)

[15:34] <rjbs> I asked because in p5, we do not reliably go through new tickets yet. :-/

[15:34] <masak> [Coke]++

[15:34] <[Coke]> rjbs++ # I hate moderating. ;)

[15:34] <rjbs> I will relate your preference to the other moderators.  I wasn't 100% sure.

[15:34] <masak> rjbs: thanks for checking.

[15:34] <[Coke]> rjbs: we're... getting there for rakudo, but it's still not right.

[15:39] *** nornagest_ joined
[15:42] *** nornagest left
[15:51] <[Coke]> niecza: say 18513*.97-17788

[15:51] <p6eval> niecza v13-172-g452c98b: OUTPUT¬´169.61‚ê§¬ª

[16:00] *** packetknife left
[16:07] <dalek> roast: 45736a6 | coke++ | S05-transliteration/with-closure.t:

[16:07] <dalek> roast: niecza fudge

[16:07] <dalek> roast: review: https://github.com/perl6/roast/commit/45736a6899

[16:07] <dalek> niecza: 82f499a | coke++ | t/spectest.data:

[16:07] <dalek> niecza: run S05-transliteration/with-closure.t

[16:07] <dalek> niecza: review: https://github.com/sorear/niecza/commit/82f499a388

[16:08] <[Coke]> (10 more)

[16:09] *** cognominal_ left
[16:10] *** cognominal joined
[16:13] <[Coke]> sorear: S32-num/bridge.t has another 200 tests; is this something you can get running? (looks like I'd have to fudge it down to almost nothing at the moment.)

[16:14] <[Coke]> er, ../real-bridge.t

[16:16] <colomon> [Coke]: that's my baby, and it's going to be tricky for nieza

[16:17] <colomon> niecza

[16:25] <colomon> well, it might not be too awful to get the methods going.  it's the operators that are thorny at the moment.

[16:25] *** Trashlord joined
[16:27] * colomon is having one of those mystifying moments of stuff which shouldn't work working for $work

[16:28] *** kaare_ joined
[16:33] <colomon> and when I say "moment", I mean, "morning"

[16:33] *** kaleem left
[16:38] *** alester joined
[16:42] *** cognominal left
[16:43] *** cognominal joined
[16:44] *** LlamaRider joined
[16:51] *** kaleem joined
[16:51] *** x3nU joined
[16:52] *** spine_ left
[16:52] *** kaleem left
[16:54] *** kaleem joined
[16:56] *** zipf joined
[17:00] *** mj41 left
[17:02] <LlamaRider> rakudo: my @a=[100]; say @a[0]/2;

[17:02] <p6eval> rakudo 8b620e: OUTPUT¬´0.5‚ê§¬ª

[17:02] <LlamaRider> help with array contexts?

[17:03] <LlamaRider> I want to get 50 out ;)

[17:04] <tadzik> huh

[17:04] <colomon> rakudo: my @a=100; say @a[0]/2;

[17:04] <p6eval> rakudo 8b620e: OUTPUT¬´50‚ê§¬ª

[17:04] <tadzik> rakudo: my @a=[100]; say @a.perl

[17:04] <p6eval> rakudo 8b620e: OUTPUT¬´Array.new([100])‚ê§¬ª

[17:04] <tadzik> hehe

[17:04] <tadzik> that's right

[17:04] <tadzik> @a[0] is an array

[17:04] <tadzik> numifies to its size, which is 1

[17:04] <colomon> LlamaRider: the way you did it, the first element of @a was [100]

[17:05] <LlamaRider> O_O

[17:05] <colomon> rakudo: my @a=[100]; say @a.perl

[17:05] <LlamaRider> this [] notations comes back to bite me quite often

[17:06] <p6eval> rakudo 8b620e: OUTPUT¬´Array.new([100])‚ê§¬ª

[17:06] <[Coke]> rakudo: my @a=(100); say @a.perl

[17:06] <p6eval> rakudo 8b620e: OUTPUT¬´Array.new(100)‚ê§¬ª

[17:06] <colomon> rakudo: my $a=[100]; say $a[0]/2;

[17:06] <p6eval> rakudo 8b620e: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "say $a\x{1c}[0\x{1c}"‚ê§¬ª

[17:06] <[Coke]> if you really miss something to contain the elements.

[17:06] <colomon> stupid IRC client

[17:07] <LlamaRider> thanks to all

[17:07] <LlamaRider> I switched to () which works as in Perl 5 (in this case)

[17:08] <jnthn> Note that you don't actually need it at all in Perl 6

[17:08] <jnthn> nom: my @a = 1,2,3; say @a.elems

[17:08] <p6eval> nom 8b620e: OUTPUT¬´3‚ê§¬ª

[17:09] <jnthn> [...] is the way you write an array literal, which can be useful for nested arrays too

[17:09] <LlamaRider> I'm just worried not to end up with a Parcel (since I never understood those fully)

[17:09] <jnthn> LlamaRider: Parcels mostly disappear

[17:10] <jnthn> A parcel is just the thing you get when you separate a bunch of things with commas

[17:10] <jnthn> nom: say (1,2,3).WHAT

[17:10] <p6eval> nom 8b620e: OUTPUT¬´Parcel()‚ê§¬ª

[17:10] <LlamaRider> yeah, I was trying not to get that :) Arrays sound safer ( = i understand them)

[17:11] <jnthn> :)

[17:11] <jnthn> Time for some dinner, and then I should have some Perl 6 tuits :)

[17:11] <jnthn> bbiab

[17:12] *** alim_ left
[17:13] *** alim joined
[17:15] *** mj41 joined
[17:17] *** alim left
[17:23] *** mj41 left
[17:24] *** zipf left
[17:24] *** zipf joined
[17:25] <LlamaRider> I'm surprised one has to say log($n,2) and can't use log(:base(2),$n). Would be nice to have both (no idea if that's relevant feedback for anyone here)

[17:26] <tadzik> hehe, didn't we de-spec that not so long ago? :P

[17:26] *** kaare_ left
[17:26] *** kaare_ joined
[17:27] * colomon finally is getting the failure in his $work code he's been looking for all morning!  o/

[17:27] <moritz> LlamaRider: that used to work via the general mechanism of filling positional parameters by name; we've abolished that, so now we should think about specific cases like the one you mentioned

[17:27] *** mj41 joined
[17:29] *** simcop2387 left
[17:29] <[Coke]> moritz: by having one multi with named and one with positional?

[17:29] <LlamaRider> thanks for the background

[17:30] *** ksi joined
[17:30] *** simcop2387 joined
[17:31] <moritz> [Coke]: maybe that's a desired solution, or maybe we want to make the base always named. No idea.

[17:31] *** simcop2387 left
[17:33] *** simcop2387 joined
[17:33] *** cognominal left
[17:34] *** cognominal joined
[17:34] *** shinobicl___ joined
[17:34] *** mj41 left
[17:35] *** wtw left
[17:36] *** zipf left
[17:40] <LlamaRider> rakudo: my $a = [100]; say $a[0]/2;

[17:40] <p6eval> rakudo 8b620e: OUTPUT¬´50‚ê§¬ª

[17:40] <LlamaRider> shortest solution to my previous issue ;)

[17:41] <colomon> LlamaRider: I posted that one at 12:06.  Not sure I'd advise it, though.  :)

[17:42] <LlamaRider> ah, the one with the encoding problems. Btw :06 is more helpful to avoid timezone issues :)

[17:42] <LlamaRider> why not advise it? It will be safer to pass $a around than @a I guess (copying a reference is light)

[17:43] <LlamaRider> not sure it is a reference of course... used to be in P5

[17:44] <tadzik> LlamaRider: moritz wrote a post on this year's advent calendar about references, I think

[17:45] <tadzik> (I think it was moritz)

[17:45] *** zby_home joined
[17:45] <colomon> http://perl6advent.wordpress.com/2011/12/16/where-have-all-the-references-gone/

[17:45] *** zipf joined
[17:45] *** daxim left
[17:46] <LlamaRider> on it.

[17:46] *** Chillance joined
[17:47] <PerlJam> LlamaRider: maybe you wanted binding originally?  

[17:47] <PerlJam> nom: my @a := [100]; say @a[0]/2;

[17:47] <p6eval> nom 8b620e: OUTPUT¬´50‚ê§¬ª

[17:47] <LlamaRider> and again O_O

[17:49] <PerlJam> did someone already mention that?  My quick eye-ball scan didn't see it.

[17:49] <LlamaRider> I am sure I didn't *want* that, since I never thought about it from this angle. I wonder if this has some unexpected differences from the other ways.

[17:49] <LlamaRider> wasn't mentioned before, no

[17:51] <PerlJam> LlamaRider: It occurs to me that, if you learn something here, it would make a nice blog post from the non-perl6-person-doing-perl6 point of view.

[17:54] <LlamaRider> Can't promise I will have the time, but I might sum up what I've been through after the p6cc is over.

[17:55] <LlamaRider> you're definitely right that it is the least I can do to repay the generous tutoring I am offered here :)

[17:56] *** dakkar left
[18:02] *** thou joined
[18:03] *** alim joined
[18:03] *** cognominal left
[18:03] <sorear> good * #perl6

[18:04] <sorear> jnthn: I'm wondering if role T { }; class Foo does ::T { }  should be allowed.

[18:04] *** cognominal joined
[18:05] <moritz> nom: role T { }; class Foo does ::T { }; say 'alive'

[18:05] <p6eval> nom 8b620e: OUTPUT¬´===SORRY!===‚ê§Foo cannot compose T because it is not composable‚ê§¬ª

[18:05] <moritz> nom: role T { }; class Foo does T { }; say 'alive'

[18:05] <p6eval> nom 8b620e: OUTPUT¬´alive‚ê§¬ª

[18:07] <[Coke]> sorear: hio.

[18:08] *** nornagest_ is now known as nornagest

[18:08] <sorear> colomon: fwiw, I'm planning to write a completely original trans for Niecza (because LTM mostly)

[18:10] *** snearch left
[18:15] <colomon> sorear: cool.

[18:15] <masak> sorear: \o

[18:15] <colomon> I won't put in any effort trying to make the current version handle flags, then.  :)

[18:18] <sorear> huh

[18:18] <sorear> oh!

[18:20] <jnthn> sorear: Will you write it in Perl 6? :)

[18:20] * jnthn would be happy to have a better trans for Rakudo ;)

[18:21] <jnthn> ::T - I'm dubious about what that means anywhere other than in a signature.

[18:22] *** zipf left
[18:26] <dalek> niecza: c2021a0 | sorear++ | src/CompilerBlob.cs:

[18:26] <dalek> niecza: Fix constant folding with large integral Nums

[18:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c2021a0927

[18:27] <sorear> jnthn: well, notice that there is a T in the lexical scope

[18:27] <sorear> leading :: in expression context can be used to reference a type without regard to whether it has been declared yet

[18:28] <jnthn> Ah, that

[18:28] <jnthn> Yeah, that's sane enough too

[18:28] <jnthn> It's the uses like

[18:28] <jnthn> my ::T $x = ...

[18:28] <jnthn> That bother me a bit more

[18:28] <jnthn> Agree the thingy above shoulda probably worked.

[18:28] <sorear> this gets used a lot in niecza to make references from modules to classes in other modules that aren't directly used

[18:30] <dalek> specs: d9a16d0 | coke++ | S (2 files):

[18:30] <dalek> specs: remove duplicated words.

[18:30] <dalek> specs: review: https://github.com/perl6/specs/commit/d9a16d0fc4

[18:30] *** pyrimidine joined
[18:32] <LlamaRider> hm, i figured the [] arrays mostly, but need help with figuring out if they're actually references. Seems that they are:

[18:32] <LlamaRider> rakudo: sub change ($a is copy) { push $a, 1; }; my $a = [2]; say $a; say change $a; say $a;

[18:32] <p6eval> rakudo 8b620e: OUTPUT¬´2‚ê§2 1‚ê§2 1‚ê§¬ª

[18:33] <LlamaRider> this doesn't clone the Array object, but copies over a reference, right?

[18:33] <moritz> right

[18:33] <moritz> perl6: sub change ($a is copy) { push $a, 1; }; my $a = [2]; change $a; say $a

[18:33] <p6eval> pugs b927740, rakudo 8b620e, niecza v13-172-g452c98b: OUTPUT¬´2 1‚ê§¬ª

[18:33] <[Coke]> rakudo: sub change (@a is copy) { push @a, 1; }; my @a = [2]; say @a; say change @a; say @a;

[18:33] <p6eval> rakudo 8b620e: OUTPUT¬´2‚ê§2 1‚ê§2‚ê§¬ª

[18:33] <moritz> [Coke]: that's what I would have expected

[18:34] <LlamaRider> so, those are completely real references. Now, is this something special with refs to Array objects, or are all OO objects similar?

[18:36] <TimToady> special to containers, more like

[18:36] <TimToady> Hashes work the same

[18:36] <masak> but "container" isn't a closed set of types.

[18:37] <LlamaRider> why not make "is copy" to a $scalar throw an error? Seems awfully confusing to me.

[18:37] <TimToady> that's how we get a read/write copy of values

[18:37] <TimToady> otherwise it's readonly

[18:37] <moritz> nom: sub f($x) { $x = 3 }; f(6)

[18:37] <p6eval> nom 8b620e: OUTPUT¬´Cannot assign to a readonly variable or a value‚ê§  in sub f at /tmp/uqMZ97Sw1S:1‚ê§  in block <anon> at /tmp/uqMZ97Sw1S:1‚ê§  in <anon> at /tmp/uqMZ97Sw1S:1‚ê§¬ª

[18:38] <moritz> nom: sub f($x is copy) { $x = 3 }; f(6)

[18:38] <p6eval> nom 8b620e:  ( no output )

[18:38] <moritz> LlamaRider: that's the common use case

[18:38] <LlamaRider> this use case shocks me :) you just assigned something to a (passed) constant

[18:38] *** tokuhirom joined
[18:39] <LlamaRider> ah wait. got it. and then there are references, which are trickier.

[18:40] *** rjbs left
[18:40] *** Moukeddar joined
[18:40] <TimToady> we're trying to give implementations freedom on that level to use either pass-by-value or pass-by-reference, as long as it looks readonly

[18:41] <TimToady> and it biases solutions toward FP style to have readonly params

[18:43] <cognominal> TimToady, what do you think of  http://irclog.perlgeek.de/perl6/2012-01-09#i_4956213 ?

[18:44] *** tokuhirom left
[18:44] <cognominal> about FP, is there a way to declare a function/method as having no side effects?

[18:44] <LlamaRider> "is rw" has to copy by reference. "is copy" has to copy by value (but not deeply clone). and the default is a read-only pass by reference. is that right?

[18:46] *** wolfman2000 joined
[18:48] <sorear> jnthn: I was actually hoping you'd say it shouldn't be allowed. :|

[18:49] <sorear> note:

[18:49] <sorear> std: class X does ::T { say T }

[18:50] <p6eval> std dc62e1d: OUTPUT¬´ok 00:01 108m‚ê§¬ª

[18:50] <sorear> in STD, ::T when parsed as <typename> is always declarative, never referential

[18:56] * jnthn wonders if there's any value in splitting the declarative and referential cases of type parsing in some way.

[19:05] <TimToady> cognominal: that piece of spec is pretty ancient, and likely to need revision as we explore how syntactic defaults work for various categories

[19:05] <TimToady> it's more there to illustrate that different categories may have different defualts

[19:05] <TimToady> *au

[19:11] *** mj41 joined
[19:13] <jnthn> TimToady: After taking a look over the metamodel stuff...don't think an allmethods will be needed. Turns out that things actually get neater in some cases when I use method_table rather than methods inside the meta-model, and that it'll probably be marginally faster to boot.

[19:13] <jnthn> TimToady: So methods can be the user-facing thing and .^mro and .^method_table can be the more "primitive" things.

[19:14] <TimToady> \o/

[19:15] <TimToady> cognominal: regarding marking things as pure, I think it's the wrong default

[19:15] * jnthn trundles off to S12 to see what exactly .methods is meant to do

[19:15] <TimToady> most things should be pure, the closer you get to the FP ideal

[19:16] <TimToady> that's the C++ const failure mode, marking almost everything

[19:17] * TimToady is also not sure that methods can rise to the same level of purity as mathematical functions, unless the object as a whole is immutable

[19:17] <[Coke]> about 670 tests less until niecza passes rakudo.

[19:17] <[Coke]> *left

[19:18] <cognominal> C++ is a curse. I thought cursing was inappropriate in this channel. :)

[19:18] <TimToady> we can discuss curses though, which is fortunate for you

[19:18] <kshannon> jnthn: on of the parsing problems with the qbootstrap comes from the NFA mergesubrule of a protoregex not being recursive, e.g. the term NFA merges term:sym<value> which merges quote which is empty...

[19:19] <TimToady> but also, linguists don't believe words are magical that way

[19:20] <colomon> eh?  I thought most linguists believed words *were* magical...

[19:20] <TimToady> we feel perfectly free to talk about words like "fuck", "shit", and "cunt" without thinking we're cursing.  :)

[19:20] <colomon> ;)

[19:20] <jnthn> o.O

[19:20] <jnthn> :)

[19:21] <jnthn> kshannon: Oh...

[19:21] <jnthn> kshannon: Yes, that will be a problem. 

[19:21] <jnthn> And needs fixing :)

[19:21] <jnthn> Fixing that'll fix a couple of busted things

[19:21] <jnthn> Not to mention trim more branches earlier.

[19:23] *** birdwindupbird joined
[19:23] *** alim left
[19:23] <[Coke]> perl6: say DateTime.new();

[19:23] <p6eval> niecza v13-174-gc2021a0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared name:‚ê§       'DateTime' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1143 (P6.comp_unit @ 32) ‚ê§  at /ho‚Ä¶

[19:23] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&DateTime"‚ê§    at /tmp/gKJc73E369 line 1, column 5-19‚ê§¬ª

[19:23] <p6eval> ..rakudo 8b620e: OUTPUT¬´use of uninitialized value of type Int in string context‚ê§DateTime.new(year => , month => 1, day => 1, hour => 0, minute => 0, second => 0/1)‚ê§¬ª

[19:23] <TimToady> I remember with amusement once when someone I know told his son that he should not use the word "frickin'", but could not bring himself to say why :)

[19:24] *** hundskatt joined
[19:24] *** alim joined
[19:24] <masak> yeah, those euphemisms are so nasty.

[19:24] <TimToady> so I explained plainly that it was commonly thought to be small swearing for "fucking".

[19:24] <TimToady> they both looked at me, shocked :)

[19:25] <masak> :P

[19:25] <TimToady> linguists have to get their pleasure somewhere

[19:26] <TimToady> the languages themselves are mostly a form of torment :)

[19:26] <masak> I know the feeling :)

[19:28] <jnthn> :excl               exclude Cool and Any (the default)

[19:28] <jnthn> ...and presumably Mu too?

[19:28] <TimToady> colomon: but you're also right in that linguists do believe in "magic", on one level, which they call "pragmatics"

[19:28] <TimToady> there's a famous paper called "How to Do Things With Words"

[19:29] <TimToady> it's all about phrases that actually do things, such as "I now pronounce you husband and wife."

[19:29] <TimToady> and "I promise"

[19:30] <TimToady> and insofar as all language is intended to have some effect on the listener, yes, it's all magical :)

[19:31] <TimToady> but it's also just called "effective communication"

[19:31] <TimToady> or in some cases "effective propaganda" :)

[19:31] <slavik1> TimToady: taking a dig at USSR? :P

[19:32] <TimToady> actually, I was just talking ad hitlerium

[19:32] <slavik1> lol

[19:32] <slavik1> fair enough

[19:33] <TimToady> but we all propagandize to a lesser or greater extent

[19:33] <slavik1> true

[19:33] <TimToady> pretty much all of us want people to think better of us than we think of ourselves

[19:34] <slavik1> TimToady: I disagree, everyone thinking better of me adds to my list of things I have to work on. :(

[19:34] <slavik1> which I am not supposed to be responsible for.

[19:34] <TimToady> heh

[19:34] <TimToady> well, I did hedge it with "pretty much", so maybe you're the only exception :)

[19:35] <slavik1> I am sure I am not the only one, but point taken. :)

[19:36] <TimToady> well, I did hedge it with "maybe", so it's possible you're not the only one :)

[19:37] *** Moukeddar left
[19:37] <masak> I see what you're doing there.

[19:38] * TimToady bows on some semantic level or other

[19:40] <[Coke]> perl6: KeyHash.new();

[19:40] <p6eval> niecza v13-174-gc2021a0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared name:‚ê§       'KeyHash' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1143 (P6.comp_unit @ 32) ‚ê§  at /hom‚Ä¶

[19:40] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&KeyHash"‚ê§    at /tmp/7RPef_2m5l line 1, column 1-14‚ê§¬ª

[19:40] <p6eval> ..rakudo 8b620e:  ( no output )

[19:41] <moritz> nom: saz KeyHash.^parents

[19:41] <p6eval> nom 8b620e: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&saz' called (line 1)‚ê§¬ª

[19:41] <moritz> nom: say KeyHash.^parents

[19:41] <p6eval> nom 8b620e: OUTPUT¬´Iterable() Cool() Any() Mu()‚ê§¬ª

[19:41] <[Coke]> rakudo: my %a = KeyHash.new(); %a{1} = True; say %a.keys; %a{1} = False; say %a.keys;

[19:41] <p6eval> rakudo 8b620e: OUTPUT¬´Method 'iterator' not found for invocant of class 'KeyHash'‚ê§  in method reify at src/gen/CORE.setting:4283‚ê§  in method gimme at src/gen/CORE.setting:4647‚ê§  in method eager at src/gen/CORE.setting:4622‚ê§  in method STORE at src/gen/CORE.setting:5313‚ê§  in block <anon>‚Ä¶

[19:42] <jnthn> It's NYRI, I think

[19:42] <moritz> nom: say KeyHash.^methods(:local)

[19:42] <p6eval> nom 8b620e: OUTPUT¬´of‚ê§¬ª

[19:43] <moritz> yes, looks like a stub to me

[19:43] * [Coke] wonders what the point of the KeyHash is.

[19:44] <TimToady> sorear: re http://irclog.perlgeek.de/perl6/2012-01-09#i_4954903, another possibility is to automatically derive a new Regex slang for the current lexical scope that derives from the outer Regex slang

[19:45] <TimToady> then we could dispense with the &foo requirement

[19:45] *** Vlavv_ joined
[19:47] <moritz> and use that only for regex literals outside of grammars?

[19:48] <TimToady> [Coke]: "A C<KeyHash> automatically deletes any key whose value goes false."

[19:48] <TimToady> moritz: yes, a declared grammar doesn't need to make an anonymous derivation

[19:49] <TimToady> I suppose this would only apply to named regexes, since anon regexes could be mixed in to other things

[19:50] <moritz> TimToady: something in me says "that's wrong", but that might be because my mental model of slangs are wrong

[19:50] <moritz> somehow I thought a slang consists of rules for parsing the current language

[19:50] * jnthn too

[19:50] <jnthn> Well

[19:50] <TimToady> well, there's a 

[19:50] <jnthn> Something in the current language braid

[19:50] <moritz> not something that a user-space regex is supposed to call back to (unless it wants to parse Perl 6)

[19:51] <TimToady> Regex slang embedded in the MAIN slang

[19:51] <TimToady> a regex with a name can be considered declarative, and mixed in at compile time

[19:52] <TimToady> there could be compile-time mixins for other slangs in the current braid as well, I suppose

[19:53] <TimToady> that's essentially what things like Q:c are already doing

[19:53] <TimToady> but those scope to the current quote, not the rest of the lexical scope

[19:53] <[Coke]> TimToady: it also says that .elems is the sum of all the values, neither of which seems awesome enough to be a core data type.

[19:54] <[Coke]> so I am wondering what problem they were trying to solve.

[19:54] <TimToady> the postulated 'quote' keyword could be considered a to-end-of-scope mixin of a new quote construct

[19:55] <moritz> hey, if somebody wants a bit of fun, implement the last algorithm from http://www.keithschwarz.com/darts-dice-coins/ for Hash.roll (or better EnumMap.roll)

[19:55] <moritz> and add that to the settings of both rakudo and niecza

[19:56] <TimToady> [Coke]: it's just a generalization of mutable sets, bags, and similar values that may include fractional amounts, such as how much oil do you have in a set of oil tanks?

[19:57] <TimToady> always assuming the oil tanks blow up when they get empty :)

[19:58] <TimToady> it's also possible that KeyHash is slightly mis-specced, confusing false with default

[19:58] <[Coke]> niecza: my $a is Numeric;

[19:58] <p6eval> niecza v13-174-gc2021a0: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Trait name not available on variables at /tmp/Lwg2MmPHaD line 1:‚ê§------> [32mmy $a is Numeric[33m‚èè[31m;[0m‚ê§‚ê§Potential difficulties:‚ê§  $a is declared but not used at /tmp/Lwg2MmPHaD line 1:‚ê§------> [32mmy [33m‚èè[31m$a ‚Ä¶

[19:59] <[Coke]> sorear: that will probably block some of the type roles tests.

[19:59] <moritz> fwiw I'll spend most of tomorrow traveling, and AFK

[19:59] <TimToady> we probably want KeyHashes that can contain false values, so it should really be formulated in terms of the default value, which might be undefined

[20:00] <TimToady> it's just that a Set has a default value of False, and a Bag has a default value of 0

[20:00] <TimToady> but we don't have hash/array defaults totally thrashed out just yet

[20:01] <TimToady> and it may be that the generalization is not KeyHash, but my %stuff is default(42) is autopruned; or some such

[20:02] *** bluescreen10 joined
[20:02] <TimToady> or...  is default(42, :auto)

[20:03] *** birdwindupbird left
[20:03] *** jakky joined
[20:03] <skids> Wouldn't a hash/array logically default to the default of its value type, rather than having its own default?

[20:04] <TimToady> that's the default default, yes

[20:04] *** LlamaRider_ joined
[20:04] <skids> :-)

[20:04] <masak> I for one would like to experiment not only with autopruning, but with many useful data structures (stacks, queues, heaps, trees) as backend implementations to '@' and '%' variables.

[20:05] <TimToady> the autoprune generalization probably wants a smartmatch, not just a single value

[20:05] <TimToady> so fractional bags delete when * <= 0, maybe

[20:06] <TimToady> maybe that's the wrong approach though

[20:06] <jnthn> .oO( I for one welcome our data structure overlords )

[20:07] *** LlamaRider left
[20:07] <skids> masak: Think "backend implementation of several @'s or %'s at the same time in one data structure."

[20:07] *** cognominal left
[20:07] *** cognominal joined
[20:07] <TimToady> if we have a value type that's a subset type, then if the value is outside the subset, we choose either error or deletion, depening on whether it matches the default

[20:08] <TimToady> my Positive %fracbag is default(0) # delete if 0, complain if <0

[20:09] <TimToady> that seems cleaner to my clouded brane

[20:10] <masak> 'fracbag' sounds like it would be a severe insult in Battlestar Galactica.

[20:11] <TimToady> how 'bout %auxtank that you discard when empty

[20:11] <TimToady> assuming airplane semantics :)

[20:11] <TimToady> jettison, I should say

[20:11] <skids> Last time I tried taking a hash of all hash keys during hash accesses in parrot (running rakudo) something like 90% of hash accesses were for hashes from a family with about 10 or 20 distinct key states.  So essentially there were tens of thousands of copies of the same hash keys with different values. (Though jnthn++'s REPR stuff will also be attacking that problem.)

[20:12] <masak> doy: hey! I just noticed you're making Moose releases, too! doy++

[20:12] <TimToady> you mean you were using a %hash[Str] (the default) rather than %hash[Enum] (or some such

[20:13] <TimToady> we're also sorely lacking non-string hash keys

[20:13] *** Chillance left
[20:13] <TimToady> I have most of translation of Set.pm assuming that we can have hash keys based on WHICH

[20:13] *** Chillance joined
[20:14] <skids> Just saying an implementation of "lots of little hashes with same keys" on the back end might speed up naive programs.

[20:14] <TimToady> that's turning common strings into symbols, or some such, internally

[20:14] <TimToady> p5 actually does some optimization on that wise

[20:15] <TimToady> the trick to moving beyond string hashes is that you really only need a hash of the *identity*

[20:16] <TimToady> when you understand the identity, you can have a hash of it

[20:17] <TimToady> I suspect .WHICH is usually the right default for most entities, assuming we can get a hash of it

[20:17] <dalek> roast: a40c3de | jnthn++ | S12-introspection/definite.t:

[20:17] <dalek> roast: Tests for .DEFINITE.

[20:17] <dalek> roast: review: https://github.com/perl6/roast/commit/a40c3de647

[20:17] <dalek> roast: 72d6c38 | jnthn++ | S12-introspection/methods.t:

[20:17] <dalek> roast: Update methods.t for :excl semantics, new proto semantics and scatter .gist to avoid some warnings.

[20:17] <dalek> roast: review: https://github.com/perl6/roast/commit/72d6c38ed7

[20:17] <dalek> roast: 6529af0 | jnthn++ | S12-introspection/parents.t:

[20:17] <dalek> roast: Scatter some :all in parents.t to get it to pass again.

[20:17] <dalek> roast: review: https://github.com/perl6/roast/commit/6529af0c7f

[20:18] <dalek> rakudo/nom: 0838f41 | jnthn++ | src/ (2 files):

[20:18] <dalek> rakudo/nom: Implement .DEFINITE.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0838f41b8d

[20:18] <dalek> rakudo/nom: b1d3c7c | jnthn++ | src/Perl6/Metamodel/ (4 files):

[20:18] <dalek> rakudo/nom: Refactor to use method_table in place of methods inside of MOP.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b1d3c7cd50

[20:18] <dalek> rakudo/nom: 1f302f8 | jnthn++ | src/ (6 files):

[20:18] <dalek> rakudo/nom: Implement :excl and :all for methods, attributes and parents. Make :excl the default.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1f302f8c5e

[20:18] <dalek> rakudo/nom: b21d28b | jnthn++ | src/ops/perl6.ops:

[20:18] <dalek> rakudo/nom: Fix .DEFINITE for container case.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b21d28b540

[20:18] <dalek> rakudo/nom: e65b6b1 | jnthn++ | src/Perl6/Metamodel/BOOTSTRAP.pm:

[20:18] <dalek> rakudo/nom: Fixes to .is_dispatcher and .is_generic.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e65b6b1825

[20:18] <dalek> rakudo/nom: 783b468 | jnthn++ | t/spectest.data:

[20:18] <dalek> rakudo/nom: Run S12-introspection/definite.t.

[20:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/783b4680d3

[20:19] <masak> what's this .DEFINITE of which you speak?

[20:19] <jnthn> See S12

[20:19] <TimToady> what :D actually checks

[20:19] <masak> ah.

[20:20] * sorear wanders back

[20:23] <TimToady> oh, hey, moritz++ already talked about slang mixins; I should finish backlogging before commenting in my current delirous blathery state

[20:25] <TimToady> delirious, even

[20:26] <dalek> roast: fc605cb | jnthn++ | S12-introspection/definite.t:

[20:26] <dalek> roast: Test that DEFINITE really is a macro.

[20:26] <dalek> roast: review: https://github.com/perl6/roast/commit/fc605cbf27

[20:26] <dalek> roast: 7c55366 | jnthn++ | S12-introspection/parents.t:

[20:26] <dalek> roast: Some tests for :excl, both explicit and as the default.

[20:26] <dalek> roast: review: https://github.com/perl6/roast/commit/7c5536672f

[20:27] <jnthn> That's one less thing for TimToady++ to complain about. :)

[20:27] * TimToady can find something else now...

[20:27] <masak> jnthn++

[20:27] <jnthn> TimToady: I expected nothing less :P

[20:27] <tadzik> jnthn: do we pass that macro one?

[20:28] <jnthn> tadzik: ?

[20:28] <jnthn> Yes

[20:28] <tadzik> huh

[20:28] <jnthn> tadzik: You meant the test I just added

[20:28] <jnthn> ?

[20:29] <tadzik> yeah. For a moment I thought "we pass that, so we must have macros"

[20:29] <jnthn> no, no. It's wired in Actions.pm.

[20:29] <tadzik> I see

[20:29] <masak> I'm not sure how one'd *define* such a macro, but... :)

[20:29] <sorear> We do have macros.  Just not user-defined macros.

[20:29] <masak> that's the same problem as with .WHAT and the others.

[20:29] <[Coke]> 01/09/2012 - niecza at 96.46% (sorear++'s fix earlier today)

[20:30] <sorear> [Coke]: any remaining failures?

[20:30] <TimToady> any sufficiently advance macro is indistinguishable from a primitive...

[20:30] <masak> ;)

[20:30] <[Coke]> 5 more: https://gist.github.com/1584782

[20:30] <masak> maybe they're just 'macro postfix:<.WHAT>' -- but ISTR there was some problem with that notion...

[20:31] <masak> I think when Niecza reaches Rakudo's number of spectests, the Mayan calendar will just go "oh, frig it" and end early. :P

[20:32] <skids> What's a "mutator" for the purposes of http://perlcabal.org/syn/S09.html#Compact_structs 3rd paragraph?

[20:32] <dalek> rakudo/nom: de59b4b | jnthn++ | docs/ChangeLog:

[20:32] <dalek> rakudo/nom: Start a ChangeLog for the month, so we don't have it all to do right before the next release.

[20:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/de59b4b0c6

[20:33] <masak> colomon++ [Coke]++ tadzik++ PerlJam++ # tutoring LlamaRider_ earlier

[20:34] <LlamaRider_> do you have some sort of karma system in the channel? (trying to figure out the ++ mnemonics)

[20:34] <tadzik> karma LlamaRider_ 

[20:34] <aloha> LlamaRider_ has karma of 0.

[20:34] <tadzik> karma LlamaRider

[20:34] <aloha> LlamaRider has karma of 0.

[20:34] <tadzik> LlamaRider++ # for the new road of life

[20:35] <LlamaRider_> lol

[20:35] <TimToady> skids: any method that modifies any of the attributes

[20:35] <[Coke]> masak: ? I did no such thing, I was just double checking stuff. ;)

[20:35] *** LlamaRider_ left
[20:35] <masak> oh, ok.

[20:35] <masak> [Coke]--

[20:35] <masak> ;P

[20:35] <TimToady> it might be better to declare that it's a value type, and then try to catch mutators and complain

[20:36] *** LlamaRider joined
[20:36] <dalek> roast: 3fc0720 | jnthn++ | S14-roles/anonymous.t:

[20:36] <dalek> roast: Fudge for Rakudo (curiously, Niecza and Rakudo are consistent here - maybe the test is dubious.

[20:36] <dalek> roast: review: https://github.com/perl6/roast/commit/3fc0720b33

[20:37] <skids> Hrm.  Less flexible than I thought it would be... the reasons are probably over my head.

[20:37] <TimToady> esp since whether it's a value type changes how its identity is calculated

[20:37] <dalek> nqp/qbootstrap: f500829 | kshannon++ | .gitignore:

[20:37] <dalek> nqp/qbootstrap: Make git ignore all *.pbc

[20:37] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/f500829b49

[20:37] <dalek> nqp/qbootstrap: e4fe3ad | kshannon++ | src/QRegex/NFA.nqp:

[20:37] <dalek> nqp/qbootstrap: The enumcharlist can be negated.

[20:37] <dalek> nqp/qbootstrap: 

[20:37] <dalek> nqp/qbootstrap: Fix the NFA building to pay attention to that.

[20:37] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/e4fe3add50

[20:37] <TimToady> trying to deduce value-ness from the absense of mutators now seems like a mistake

[20:39] <dalek> rakudo/nom: 6bf68d0 | jnthn++ | t/spectest.data:

[20:39] <dalek> rakudo/nom: Run S14-roles/anonymous.t.

[20:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6bf68d0e47

[20:40] <masak> TimToady: +1

[20:41] <skids> I dunno it just strikes me that changing an attribute should just be treated like writing a new value to the entire set of attributes.

[20:42] <[Coke]> jnthn: there are a lot of places where I see "nom regression" and "niecza todo" on the exact same tests in the spec.

[20:42] <jnthn> Curious :)

[20:43] <TimToady> skids: at which point you either have a mutable type container, or you've violated the identity of the value type

[20:46] <skids> I'm not immersed enough in the vocabulary to converse intelligently I guess.

[20:53] <TimToady> well, there's far too much vocabulary swirling around this subject, but to the first approximation, if something is mutable, it means it takes its identity from its containerness, which can be thought of as a location somewhere

[20:54] <TimToady> if something is immutable, it takes its identity from its own value, and has the same identity wherever it finds itself

[20:54] <TimToady> copying a value doesn't make two different values

[20:55] <TimToady> 5 is the same everywhere, if you ignore representations

[20:55] <awwaiid> wherever you go, there you are?

[20:55] <TimToady> well, buckaroo banzai is kind of a constant in that sense, yes

[20:56] *** kaleem left
[20:56] <TimToady> but that's really more the mystery of a container acting as a value, whose identity is "buckaroo banzai" wherever he goes

[20:57] <TimToady> two object hashes keyed on buckaroo banzai are keyed on the same person, not on two different representations of the same person

[20:58] <TimToady> buckaroo banzai has only one .WHICH

[20:58] <masak> good night, #perl6.

[20:58] <TimToady> o/

[20:59] <kshannon> Well with a NFA recursive proto hack we now pass a lot more of the test suite: https://gist.github.com/1584871

[20:59] <jnthn> kshannon++ !!

[20:59] <TimToady> yay

[20:59] <jnthn> kshannon: How...hacky? ;)

[20:59] <skids> That much I get, it's the "value type" --> immutable (?) I was missing.

[20:59] <sorear> [Coke]: the first three were missed earlier

[21:00] <kshannon> Needs to be redone with a proper api.  I'm just not sure what that api should be.

[21:01] <kshannon> But as a proof that the missing recursiveness was most of the parsing errrors it performs brilliantly.

[21:02] <dalek> roast: 503fe00 | jnthn++ | S32-array/delete.t:

[21:02] <dalek> roast: Fudge S32-array/delete.t for Rakudo (same tests Niecza has fudged).

[21:02] <dalek> roast: review: https://github.com/perl6/roast/commit/503fe00af8

[21:03] <dalek> niecza: 7bc2d96 | sorear++ | lib/CORE.setting:

[21:03] <dalek> niecza: infix:<ne> also needs to handle junctions internally, gets three tests back

[21:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7bc2d964f0

[21:03] <dalek> rakudo/nom: b281b21 | jnthn++ | src/core/Hash.pm:

[21:03] <dalek> rakudo/nom: Handle various other cases of Hash.delete.

[21:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b281b21425

[21:03] <dalek> rakudo/nom: f4b327b | jnthn++ | t/spectest.data:

[21:03] <dalek> rakudo/nom: Run S32-hash/delete.t.

[21:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4b327bf97

[21:03] <dalek> rakudo/nom: c827edc | jnthn++ | src/core/Array.pm:

[21:03] <dalek> rakudo/nom: Implement Array.delete (based on ng code, but with various tweaks and updatings).

[21:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c827edcc3f

[21:03] <dalek> rakudo/nom: 38165a5 | jnthn++ | t/spectest.data:

[21:03] <dalek> rakudo/nom: Run S32-array/delete.t.

[21:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38165a575e

[21:04] <kshannon> If we can work out why the subclassing isn't working I think we'll be very close to a working QRegex NQP

[21:04] <sorear> jnthn: what do you think of S14-roles/anonymous.t:39?

[21:04] <sorear> jnthn: it's getting confused by niecza's "3 but Str("xyz")" implementation

[21:06] <jnthn> sorear: Should be workable

[21:06] <jnthn> sorear: We can tell the difference between a sub and a type

[21:06] <TimToady> kshannon: perhaps you need a way to examine the new computed lexer to see if it reflects the changes correctly

[21:07] <jnthn> sorear: I'm not sure how it's conflicting because role_generator lives in the lexpad as &role_generator, no?

[21:07] <sorear> jnthn: but what if the sub returns a type when called without arguments?

[21:07] <jnthn> oh, wait

[21:07] <jnthn> :)

[21:07] <sorear> jnthn: niecza is compiling it as &infix:<does>($a, &role_generator(), :value("hi"))

[21:08] <jnthn> sorear: Right.

[21:08] <jnthn> sorear: But role_generator isn't a known type

[21:08] <jnthn> sorear: So it's possible to disambiguate that quite easily, I'd imagine.

[21:09] <jnthn> kshannon: Oh, I know why that isn't working

[21:09] <jnthn> kshannon: https://rt.perl.org/rt3/Ticket/Display.html?id=107746

[21:09] <jnthn> kshannon: It's that - there's a case just like it package_def

[21:10] <colomon> sorear: when you get a chance, you should probably look at the failures in t/spec/S03-junctions/autothreading.t -- I based on when it stopped working, I'm guessing constant folding related.

[21:11] <sorear> colomon: I just fixed them

[21:11] <colomon> sorear++

[21:11] * colomon has been cleaning the nasty crevices of the kitchen.  :(

[21:13] <dalek> roast: 04cea6b | sorear++ | S (2 files):

[21:13] <dalek> roast: Fudge an accidental pass and a regression-with-cause for niecza

[21:13] <dalek> roast: review: https://github.com/perl6/roast/commit/04cea6bf65

[21:13] <[Coke]> colomon: we have some of those. you should come over, I'll bier you. ;)

[21:14] <colomon> [Coke]: no thanks, once a decade is about enough for my taste.

[21:14] <[Coke]> sorear: "accidental pass" - does that make a passing TODO?

[21:14] <sorear> [Coke]: no, it switched back to a fail with the constant folding changes

[21:15] <jnthn> afk for a bit

[21:15] <jnthn> kshannon: BTW, if you want to pass over your protoregex/NFA patch, I'd be happy to look at the API side of it. Or feel free to hack on it yourself if you're having fun with it :)

[21:15] * jnthn really gone for a while

[21:17] *** Exodist joined
[21:17] *** spine joined
[21:17] *** spine left
[21:18] *** spine joined
[21:22] <[Coke]> sorear: ah. thanks.

[21:24] *** fsergot left
[21:26] *** alim left
[21:29] *** PacoAir left
[21:32] *** zjmarlow joined
[21:33] *** xinming joined
[21:34] *** MC91 left
[21:34] *** MC91 joined
[21:38] *** Trashlord left
[21:39] *** xinming left
[21:41] <LlamaRider> jnthn: I mentioned I was scared of not understanding Parcels before. I got a Parcel by accident in one of my subs and tried to do a Zen slice on it. Took me a while to figure out I can't do that, since I had no clue I was working with a Parcel there :)

[21:41] <LlamaRider> rakudo: my Parcel $a = (1,2); say $a[];

[21:41] <p6eval> rakudo 38165a: OUTPUT¬´1 2‚ê§¬ª

[21:41] <LlamaRider> ... or I need to update?

[21:42] <LlamaRider> I am getting "Not enough positional parameters passed; got 1 but expected 2"

[21:42] <LlamaRider> yep. seems I need to update.

[21:43] *** PacoAir joined
[21:47] *** kaare_ left
[21:53] *** bluescreen100 joined
[21:58] *** alester left
[21:59] *** arlinius left
[21:59] *** arlinius joined
[22:00] <jnthn> LlamaRider: That bug was fixed recently :)

[22:01] <LlamaRider> is it currently easy to update rakudo?

[22:01] *** skids left
[22:01] <jnthn> LlamaRider: How did you get your Rakudo build? 

[22:02] <jnthn> If you're just building from git, then just "git pull", then re-do the build steps

[22:02] <LlamaRider> exactly how i did it. let me try

[22:09] <LlamaRider> boy that build takes a while :)

[22:09] *** wolfman2000 left
[22:11] <jnthn> yeah...working on improving that. :)

[22:12] <LlamaRider> works! :)

[22:13] <jnthn> yay! :)

[22:14] <LlamaRider> shame that I had to run into the bug though... took a while to find :D

[22:14] <LlamaRider> good job on fixing it :)

[22:15] *** tokuhirom joined
[22:19] *** tokuhirom left
[22:25] <[Coke]> # 01/09/2012 - niecza at 96.13% (after jnthn's commit fest)

[22:27] <sorear> jnthn: Do you think it's reasonble in the short term to make class Foo does ::My::Role carp?

[22:27] <jnthn> sorear: That's all Rakudo does at the moment :)

[22:28] *** saberman_3 joined
[22:28] *** saberman_3 left
[22:30] <jnthn> phenny: tell moritz oops, the setting compilation bustage was not anything to do with moving the temporal ops. It was to do with the sleep change that came in the previous commit.

[22:30] <phenny> jnthn: I'll pass that on when moritz is around.

[22:30] <jnthn> phenny: tell moritz well, the rtype bit anyway

[22:30] <phenny> jnthn: I'll pass that on when moritz is around.

[22:30] <dalek> rakudo/staged-setting-fail: 664f46b | jnthn++ | src/core/control.pm:

[22:30] <dalek> rakudo/staged-setting-fail: Work around pir::... limitation.

[22:30] <dalek> rakudo/staged-setting-fail: review: https://github.com/rakudo/rakudo/commit/664f46b9b2

[22:35] *** mj41 left
[22:38] *** Chillance left
[22:40] *** pyrimidine left
[22:43] *** nornagest left
[22:44] *** icwiener left
[22:52] *** donri left
[22:54] <tadzik> is there a clean way to do &some_sub.=wrap()?

[22:54] <tadzik> I get Cannot assign to a non-container. A bug maybe?

[22:54] <jnthn> tadzik: .wrap already is in place.

[22:55] <tadzik> oh, ok

[22:55] <tadzik> that was my first thought too, maybe I'm doing something wrong

[22:56] <dalek> rakudo/staged-setting-fail: ab92aff | jnthn++ | src/Perl6/ (2 files):

[22:56] <dalek> rakudo/staged-setting-fail: Fix for the 'Sub doesn't have an SC' issue - CORE and CORE2 both compile now.

[22:56] <dalek> rakudo/staged-setting-fail: review: https://github.com/rakudo/rakudo/commit/ab92aff520

[22:56] <jnthn> nom: sub foo() { say 2 }; &foo.wrap({ print 4; callsame; }); foo()

[22:56] <p6eval> nom 38165a: OUTPUT¬´42‚ê§¬ª

[22:57] <tadzik> nom: &foo.wrap({ print 4; callsame; }); sub foo() { say 2 }; foo()

[22:57] <p6eval> nom 38165a: OUTPUT¬´42‚ê§¬ª

[22:57] <tadzik> mkay

[22:57] <jnthn> phenny: tell moritz fixed the other bug you ran into too. Note - please can we call what you're called CORE2 as CORE, and then call the more primitive one something like PRIMITIVES? :)

[22:57] <phenny> jnthn: I'll pass that on when moritz is around.

[22:57] <jnthn> (Otherwise implementing CORE:: will be hell :))

[22:59] <tadzik> nom: &foo.wrap({ callsame + 1 }); sub foo() { 2 }; say foo()

[22:59] <p6eval> nom 38165a: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Calling '_block18889' will never work with argument types (Mu) (line 1)‚ê§    Expected: :()‚ê§¬ª

[22:59] <tadzik> nom: &foo.wrap({ callsame() + 1 }); sub foo() { 2 }; say foo()

[22:59] <p6eval> nom 38165a: OUTPUT¬´3‚ê§¬ª

[23:05] *** ksi left
[23:05] <jnthn> sleep &

[23:06] *** snearch joined
[23:07] *** MC91 left
[23:13] *** zjmarlow left
[23:15] *** Trashlord joined
[23:15] *** skids joined
[23:16] *** PacoAir left
[23:18] *** cooper joined
[23:26] *** Trashlord left
[23:28] <tadzik> nom: &foo.wrap({ callsame() + 1 }); sub foo() { return 2 }; say foo()

[23:28] <p6eval> nom 38165a: OUTPUT¬´3‚ê§¬ª

[23:28] <sorear> I wonder if Str:D(Cool:D)should be allowed

[23:29] <LlamaRider> good night ^^

[23:29] *** LlamaRider left
[23:44] *** zjmarlow joined
[23:44] <tadzik> ohh

[23:44] <tadzik> exported subs don't get wrapped from inside the module

[23:46] <tadzik> https://gist.github.com/1585730 bug or feature?

[23:47] *** snearch left
[23:51] <tadzik> S11 uses the word "binding" when it comes to exportation, this looks more like copying

