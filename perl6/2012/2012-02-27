[00:00] * [Coke] found a few files with a 100+ tests where pugs errored out after the first 5, so that was a win. ;)

[00:02] *** ascrazy left
[00:03] *** Guest67167 joined
[00:05] *** fsergot joined
[00:10] *** Guest67167 left
[00:18] <[Coke]> b: (20298*.25)-4632

[00:18] <p6eval> b 1b7dd1:  ( no output )

[00:18] <[Coke]> b: say (20298*.25)-4632

[00:18] <p6eval> b 1b7dd1: OUTPUT«442.5␤»

[00:30] <colomon> [Coke]++

[00:34] *** ribayr joined
[00:37] <colomon> So, we have (basically) three ways of shelling out?

[00:37] <colomon> "qx"  -- takes a command line, returns stdout.  (maybe stderr too?)

[00:38] *** packetknife left
[00:38] <colomon> shell: takes a command line, returns Proc::Status

[00:38] <colomon> run: takes command and list of arguments, returns Proc::Status

[00:41] <sorear> colomon: stdout only

[00:41] <sorear> there is shell and p5 precedent for sending stderr directly to the terminal

[00:42] <colomon> works for me...

[00:42] <sorear> but yes, I agree with your assessment of the ways

[00:42] *** plobsing left
[00:42] *** geekosaur left
[00:43] <colomon> what's frustrating is it seems like this is a total mismatch with the available C# library methods.  or maybe I'm missing all the good ones

[00:43] <sorear> are you still looking at SDP?

[00:44] <colomon> yes

[00:44] <sorear> it's a total mismatch with the winapi too

[00:44] <sorear> fits pretty well with posix though - execl, system, popen

[00:45] *** ribayr left
[00:46] *** ribayr joined
[00:46] *** packetknife joined
[00:47] *** geekosaur joined
[00:47] <colomon> does Mono.Posix have execl?

[00:47] <sorear> yes, but not fork, which makes it a lot less useful

[00:48] <sorear> ah, you're speechless too.

[00:48] <colomon> actually, just trying to find documention

[00:49] <colomon> you mean you have to end your current process to use it?

[00:49] <sorear> yes

[00:49] <sorear> well, re-use, not end so much

[00:49] <colomon> okay, so that's not helpful

[00:54] *** am0c joined
[00:54] <colomon> does mono have popen?  I'm not seeing it in google searches....

[00:54] <sorear> I didn't find it.

[00:57] <colomon> so it does seem like some unholy combination of GLib.Process.SpawnSync and SDP?

[00:57] <colomon> oooo, wait, SpawnCommandLineSync

[00:57] <colomon> !

[00:57] <colomon> that sounds promising for "qx"

[01:00] *** tokuhirom left
[01:07] *** bitpart joined
[01:08] *** bitpart left
[01:13] *** scott_ joined
[01:13] *** scott_ is now known as Guest25148

[01:17] <colomon> niecza> qx/ls/

[01:17] <colomon> Bag.pl

[01:18] <colomon> FETCH_URL

[01:18] <colomon> Fathers_Jig.mp3

[01:18] <colomon> (etc)

[01:21] *** plobsing joined
[01:52] *** sisar joined
[02:05] <dalek> niecza: 50e27f4 | (Solomon Foster)++ | lib/ (2 files):

[02:05] <dalek> niecza: Rough implementation of rungather (ie qx and qqx).

[02:05] <dalek> niecza: review: https://github.com/sorear/niecza/commit/50e27f480f

[02:10] *** am0c left
[02:15] <sorear> colomon!!

[02:15] <sorear> I mean colomon++

[02:15] <sorear> o/ sisar

[02:15] *** sisar left
[02:18] <colomon> sorear: still need to get the SDP versions written and working

[02:19] <sorear> colomon: is this even possible with SDP?

[02:20] <colomon> System.Diagnostics.Process.StandardOutput ... so I think so

[02:23] <dalek> roast: 6cdc350 | coke++ | / (16 files):

[02:23] <dalek> roast: pugs fudges

[02:23] <dalek> roast: review: https://github.com/perl6/roast/commit/6cdc3507d9

[02:23] <dalek> Pugs.hs: b88c3a7 | coke++ | t/spectest.data:

[02:23] <dalek> Pugs.hs: run fudged tests

[02:23] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/b88c3a7936

[02:26] <dalek> niecza: ac5e469 | sorear++ | tools/extheapshot.c:

[02:26] <dalek> niecza: [extheapshot] Start adding new-style printers

[02:26] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ac5e4696e7

[02:26] *** bonsaikitten left
[02:26] *** bonsaikitten joined
[02:39] *** birdwindupbird joined
[02:43] *** woosley joined
[02:45] *** thou joined
[02:56] *** NamelessTee left
[03:03] <dalek> niecza: a93b4b8 | sorear++ | lib/Cursor.cs:

[03:03] <dalek> niecza: Lexer need not retain the LAD trees

[03:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/a93b4b83b6

[03:13] <colomon> oooo, just got a basic SDP version of qx/ / working

[03:21] *** orafu left
[03:25] *** orafu joined
[03:33] *** odoacre joined
[03:33] *** birdwindupbird left
[03:35] *** birdwindupbird joined
[03:37] <colomon> sorear: how do you find the length of a string in C#?

[03:37] <sorear> .Length

[03:38] <colomon> sorear++

[03:39] <colomon> ah, it's a property, not a method

[03:41] <sorear> niecza: printf "%5d%5d", 2,3

[03:41] <p6eval> niecza v14-90-ga93b4b8: OUTPUT«Unhandled exception: index out of range␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (sprintf @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1237 (printf @ 3) ␤  at /tmp/hBFSke07v7 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting …

[03:42] <sorear> niecza: printf '%5d%5d', 2,3

[03:42] <p6eval> niecza v14-90-ga93b4b8: OUTPUT«Unhandled exception: index out of range␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (sprintf @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1237 (printf @ 3) ␤  at /tmp/ipqHxmh1qf line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting …

[03:42] <sorear> niecza: say 25.fmt('%5d')

[03:42] <p6eval> niecza v14-90-ga93b4b8: OUTPUT«   25␤»

[03:48] *** am0c joined
[03:53] *** birdwindupbird left
[03:56] <dalek> niecza: de628e4 | sorear++ | tools/extheapshot.c:

[03:56] <dalek> niecza: [extheapshot] Improve time handling for higher frequencies

[03:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/de628e47fc

[03:56] <dalek> niecza: 7376b10 | sorear++ | src/NieczaFrontendSTD.pm6:

[03:56] <dalek> niecza: Add an option to display stats on @*MEMOS usage

[03:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7376b1078d

[03:58] <sorear> niecza: say Any.keys

[03:58] <p6eval> niecza v14-90-ga93b4b8: OUTPUT«0␤»

[04:00] *** wolfman2000 joined
[04:01] *** lestrrat left
[04:02] *** lestrrat joined
[04:06] <dalek> niecza: e8df2d9 | (Solomon Foster)++ | lib/Builtins.cs:

[04:06] <dalek> niecza: Add System.Diagnostics.Process-based implementation of command_qx as a backup in case the GLib.Process.SpawnCommandLineSync cannot be found.

[04:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e8df2d9d8b

[04:07] <colomon> sorear: If you get chance to look that one over, please do.  Once we've had time to pound on that a bit, I'll clone it for run and shell, too.

[04:08] <dalek> roast: c158aed | (Solomon Foster)++ | S02-literals/quoting.t:

[04:08] <dalek> roast: Unfudge qx tests.

[04:08] <dalek> roast: review: https://github.com/perl6/roast/commit/c158aeddb2

[04:18] <sorear> observation: niecza's parser will benefit a lot from improved collection types

[04:37] *** sftp left
[04:38] *** sftp joined
[04:38] *** packetknife left
[04:51] *** mucker joined
[05:05] *** unobe left
[05:25] *** birdwindupbird joined
[05:29] *** kaleem joined
[05:34] *** worr joined
[05:45] *** razor42 left
[05:55] *** birdwind1pbird joined
[06:01] *** lestrrat left
[06:02] *** skids left
[06:02] *** lestrrat joined
[06:11] *** s1n joined
[06:20] *** mishin joined
[06:28] *** bbkr left
[06:37] *** birdwind1pbird left
[06:43] *** wtw joined
[06:45] *** takesako left
[06:45] *** fsergot left
[06:46] *** takesako joined
[07:22] *** mj41 joined
[07:24] *** agentzh joined
[07:44] <TimToady> Here's a funny new RC entry: http://rosettacode.org/wiki/Amb#Perl_6

[07:44] <TimToady> it only works in niecza because I've used 'next' in a custom operator to skip X cross entries, and niecza obviously uses a loop that responds to 'next'

[07:46] <sorear> I think it's a bug also

[07:46] <sorear> @a Xlf @b Xlf @c should call lf on 3 args at a time

[07:46] <sorear> because Xlf should have list assoc

[07:47] <sorear> (that could be worked around with a sprinkling of dos, of corse)

[07:47] <TimToady> well, X with a binary op should still work

[07:48] <sorear> worse, I think that might only be working because of mostly-eager-ness

[07:49] *** proller_ joined
[07:50] *** proller_ left
[07:50] <doy> wow, the perl5 one there is kind of hilarious

[07:52] *** proller_ joined
[07:53] <TimToady> if we force it to consider 4 args at a time, then we lose the benefit of nexting out of an earlier loop and not even constructing much of the search tree

[07:53] <TimToady> so nexting out of binary ops seems like a feature to me

[07:56] <sorear> I think this may be the first I've seen anyone use perl5's glob builtin.

[08:01] *** proller_ left
[08:04] <Tene> sorear: I used it yesterday.

[08:04] *** proller joined
[08:05] <sorear> ...

[08:06] <sorear> I just realized niecza is sending undef warnings to STDOUT.

[08:06] <sorear> s/realized/noticed/

[08:07] *** Tedd1 joined
[08:11] *** proller left
[08:13] *** proller joined
[08:16] *** havenn joined
[08:18] *** Jerkwad left
[08:19] <dalek> niecza: ed8f7dc | sorear++ | src/ (2 files):

[08:19] <dalek> niecza: Try to remove a retention path via OUTER::CALLER pointers of parametric role methods

[08:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ed8f7dc99c

[08:19] <dalek> niecza: e9fbe21 | sorear++ | src/NieczaFrontendSTD.pm6:

[08:19] <dalek> niecza: Fix spurious reporting of "0" for character positions with no memos at all

[08:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e9fbe21634

[08:19] <dalek> niecza: 4c7a3f0 | sorear++ | lib/Cursor.cs:

[08:19] <dalek> niecza: Remove more unneeded words from NFA.Node and NFA.Edge

[08:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4c7a3f05bd

[08:23] *** proller left
[08:27] <masak> morning, #perl6

[08:31] <sorear> o/ masak

[08:32] <sorear> false alarm on the warnings thing.

[08:33] <sorear> masak: release tocalandarday!

[08:36] <masak> release today? yay!

[08:39] *** slavik2 left
[08:40] <jnthn> morning'

[08:40] <jnthn> oops, useless use of abbreviation marker

[08:42] *** grondilu joined
[08:44] <masak> morning', jnthn'

[08:45] <grondilu> I wrote sha256 in perl6:  http://s0.barwen.ch/~grondilu/Crypto.pm6  I works, but it's terribly slow:  more than 5 minutes to compute a single hash!  I think it might be a nice benchmark to test code optimisation and so on.

[08:52] <jnthn> Indeed, thanks. Will give it a run through the profiler.

[08:52] <jnthn> (though not during the day...at $dayjob)

[08:53] <grondilu> glad you like it.

[08:54] <sorear> I think I'm going to call a break to the niecza memory optimizations now

[08:54] <sorear> The biggest immediate win looks like it will come from storing the line number and whitespace info in compact arrays

[08:55] <sorear> which means it looks like S09 is a highish priority for me now

[08:55] * sorear -> sleep

[08:55] *** grondilu left
[08:58] <masak> S09! \o/

[08:59] <masak> though S09 is so much more than compact arrays... :)

[08:59] <masak> it's shaped arrays and hashes, for example.

[09:00] <masak> or arrays with hash indexing.

[09:02] <masak> nom: say (2**32).^name

[09:02] <p6eval> nom c295b5: OUTPUT«Int␤»

[09:02] <sorear> masak: I can do compact arrays and tell everyone "I did as much on S09 as I had time for"

[09:02] <masak> :)

[09:02] <masak> 'night, sorear. dream of doing the -Ofun parts of S09.

[09:06] <masak> enlightening discussion about time-based releases: http://blogs.perl.org/users/educated_foo/2012/02/the-date-matches-mm01yyyy----its-a-release.html

[09:08] <doy> "enlightening"

[09:09] <masak> well, what was enlightening to me was the p5p mail and the blog comments.

[09:09] <doy> well, sure

[09:09] <masak> not so much the post itself, which is just critique without arguments.

[09:11] <masak> it reminds me of the fact that Perl 5 now has well-established time-based releases, and it seems to be working very well for them.

[09:11] <bonsaikitten> so does KDE

[09:11] <masak> there are critics, but it's all a bit of a "past the hump" thing at this point.

[09:11] <bonsaikitten> I don't see how one date is more special than the other, and there's too many x.1 releases happening either way

[09:11] <bonsaikitten> silly users do things you never expect and find new errors

[09:12] <doy> well, at this point, it's still pretty easy to say "seriously, just *look* at 5.10"

[09:12] <doy> (:

[09:12] <doy> (i do think it's a good thing though)

[09:15] <masak> it's not about one date being more special than the other.

[09:15] <masak> it's about getting fixes and improvements into the hands of users in a timely manner.

[09:15] *** havenn left
[09:16] <masak> time-based releases are an *insane* idea -- until you understand the basics of CI.

[09:18] <doy> yeah, it's always pretty amazing to me when i see what the perl 5 core's massive testing infrastructure is capable of

[09:18] *** worr left
[09:21] *** fsergot joined
[09:22] <fsergot> Hi #perl6 o/

[09:29] *** fsergot left
[09:29] *** fsergot joined
[09:31] <masak> fsergot! \o/

[09:32] <fsergot> masak: how are You?

[09:33] <jnthn> o/ fsergot 

[09:35] *** explorer__ joined
[09:35] <masak> fsergot: I'm in a good mood. how about You?

[09:37] <fsergot> jnthn: how are You? :-)

[09:37] *** jferrero left
[09:38] *** woosley left
[09:39] <fsergot> I'n at the school. :-(

[09:39] <masak> glad to hear that.

[09:41] <fsergot> Why glad? :-)

[09:42] <masak> it's hard to explain. you may not appreciate school right now, but I'm happy that's where you are.

[09:43] <masak> rather than, say, unemployed or in a motorcycle gang.

[09:43] <masak> school is a relatively good place to be.

[09:45] *** Guest17202 is now known as Trashlord

[09:45] *** Trashlord left
[09:45] *** Trashlord joined
[09:46] <jnthn> fsergot: I'm fine...doing on-site $dayjob today

[09:46] <jnthn> Only two and a half weeks until vacation \o/

[09:46] <moritz> ... and only one week until GPW!

[09:47] <masak> \o/

[09:47] <moritz> which reminds me, I have a talk to prepare

[09:47] <jnthn> Yay, German beer! \o/

[09:47] <masak> yay

[09:47] <moritz> and the greeting talk and the goodbye talk and so on

[09:48] <moritz> it seems I didn't say "no" fast enough when the organizers were looking for a fool to do it

[09:48] <jnthn> "Ein sehr gut Bierplatz ist hier!"

[09:48] *** kaleem left
[09:49] *** kaleem joined
[09:49] <jnthn> Critical opening talk info ;)

[09:49] <moritz> well, it's really more like "on Monday night, we're going out together. Tuesday night is social event (free food)"

[09:50] <jnthn> oooh! :D

[09:53] *** daxim joined
[09:54] <masak> say that, and you'll get applause and cheers.

[09:55] <masak> in fact, go for minimal things like that. you'll be remembered forever.

[09:55] <masak> "he turned up, said exactly what was needed, and then he faded back into the masses."

[09:56] <moritz> I do plan to be brief. People don't attend the workshop to hear me greeting them in length.

[09:56] <masak> the people are geeks. they can find out more details online if they need to :P

[09:59] <jnthn> ...provided the workshop has wifi. :)

[10:00] <moritz> it has. In standard crap quality, I fear :/

[10:01] <cognominal> jnthn, what's the diff between nqp et nqpq? why rakudo is using nqp?

[10:01] <jnthn> nqpq is the work to bootstrap NQP using QRegex

[10:02] <moritz> and iirc the nqpq executable uses QRegex for regexes by default

[10:02] <jnthn> yes

[10:02] <jnthn> well, really nqpq does just that in master

[10:02] * masak .oO( it has a Q in it, so it must be the future )

[10:02] <jnthn> It's only in qbootstrap where the real work to bootstrap on it is going on.

[10:03] <jnthn> But, bs has higher priority at the moment

[10:04] <cognominal> jnthhn: I have a lot of problems with regexen recently. I gather you will go back to them after bs.

[10:04] <jnthn> Well, many of them likely stem from missing mark_commit stuff.

[10:05] <cognominal> I will C<gather> after you had a C<take> at it  :)

[10:09] <fsergot> masak: You are probably right. :-)

[10:09] <fsergot> About school. :-)

[10:15] *** xinming left
[10:15] <masak> fsergot: well, to a first approximation, at least. of course, if it sucks, be aware that there are ways of making it a better experience.

[10:16] <moritz> and you can IRC at school. I never could do that :-)

[10:16] *** bbkr joined
[10:16] <tadzik> hello #perl6

[10:18] *** xinming joined
[10:18] *** Guest25148 left
[10:19] <fsergot> This is the first time I IRC at school. :-)

[10:19] <tadzik> :) Phones these days :P

[10:20] <masak> they're not really phones any more. they're handheld computers with a built-in cell-network radio.

[10:20] <tadzik> true

[10:20] <masak> that's what made me start to like them :)

[10:21] <masak> they're an "everything device". phone being one function which is subsumed into the rest.

[10:21] <masak> they're like Emacs.

[10:21] <tadzik> maybe I should buy this handheld computer for meself. People hate my phone these days, for they hear they own voice when talking to me

[10:21] <tadzik> I thought it's all handled in the baseband, which means there's something seriously wrong with my phone

[10:23] <masak> from things I've been told about phone tech, there's some amazing engineering going on there. turns out voice compression needs to allocate most of its space to handle sibilants.

[10:24] <arnsholt> I usually refer to my phone as a supercomputer that fits in my pocket

[10:24] <masak> it's certainly a viewport to a supercomputer cluster.

[10:25] <arnsholt> There's that as well. But for me it's mostly the fact that there's a ridiculous amount of processing power in a modern clever phone

[10:25] <arnsholt> From time to time, I try to remind myself that I'm actually living in the future =D

[10:26] * jnthn didn't think he'd be that bothered about having a smartphone until he actually got one

[10:27] <arnsholt> Yeah, it's pretty nice

[10:27] <jnthn> Though actually phoning people is pretty far down the list of things I use it for :)

[10:27] <arnsholt> Indeed =D

[10:28] <jnthn> Finding out how late the train is, reading email and doing video skype probably top my usage list. :)

[10:29] * jnthn expected video skype to make his data transfer hit the sky, but the compression actually seems pretty impressive...it's not made so much of a dent

[10:31] <masak> I'm still disappointed at the selection of programming IDEs *on* the Android.

[10:33] <tadzik> I'm wondering whether there's a vi variant, but for fingers, not for keyboards, if you know what I mean

[10:33] <moritz> model editing with fingers?

[10:33] *** NamelessTee joined
[10:34] *** lestrrat left
[10:34] <tadzik> aye

[10:34] <masak> sounds a bit like chording to me.

[10:34] <masak> http://en.wikipedia.org/wiki/Chording_keyboard

[10:35] <arnsholt> tadzik: I've done some minor editing with an ssh client and vim via my phone =)

[10:35] *** lestrrat joined
[10:35] <masak> me too.

[10:35] <tadzik> masak: like an accordion!

[10:36] <masak> oh wow, an accordion smartphone.

[10:36] <masak> "Hold on, I'll just call Greg." -- *expands bellows with a majestic sound*

[10:37] *** thou left
[10:37] <tadzik> heh, funny. When I saw you saying "chording", I thought of guitar chords. On the computer keyboard I'm probably mostly using piano chords, and phone seems more appropriate for guitar chords

[10:42] <szabgab> hi

[10:42] *** xinming left
[10:42] <szabgab> who is running rdstar ?

[10:42] <szabgab> I'd like to put a name to it but I only see Rakudo Death Star  on http://rdstar.wordpress.com/

[10:43] <moritz> that's lue

[10:44] <szabgab> thanks, is there a longer name I could add to the Perl Weekly ?

[10:44] <masak> Life, The Universe, and Everything? :)

[10:44] <szabgab> oh that   lue :)

[10:44] <masak> he seems to be one of our pseudonym peeps.

[10:45] <masak> I know his real name, but he seems to want to go by "lue" or "rnddim".

[10:45] <szabgab> ok, so I stick to the title RDS

[11:00] <masak> http://www.cs.washington.edu/education/courses/csep501/08wi/lectures/index.html # looks interesting.

[11:00] <masak> too bad that in the first PDF, they put Perl squarely in the "interpreters" slot, and spell it "PERL" at that. :/

[11:00] <masak> could still be a good course, though.

[11:05] <tadzik> looks interesting, indeed

[11:05] <tadzik> the Compilation Techniques on my Uni I'll start in October

[11:07] <moritz> a few random observations:

[11:08] <moritz> * printers suck

[11:08] <moritz> * all this talking about theory makes me think that maybe I should learn a bit theory on compilers too

[11:08] <moritz> * printers still suck.

[11:09] <tadzik> random thought: lazy evaluation is a way to trick a mind reader illusionist. He says "pick a number between 1 and 10", and you don't. You wait with picking it until he wants to do something with it

[11:10] <tadzik> it should do the trick

[11:10] <tadzik> (the trick, you see? Ha ha!)

[11:13] <moritz> lazy is, in some sense, like hubris

[11:13] <moritz> it's like saying "I *know* how I could generate these value. Why bother?"

[11:14] *** mishin left
[11:16] <masak> moritz: printing things is so twentieth century anyway.

[11:16] <masak> get the PDFs as an audiobook! :)

[11:17] <masak> tadzik: lazy evaluation is just corecursion. in ordinary recursion, you have routines calling routines to generate more data. in corecursion, you have data calling data to generate more routines. ;)

[11:17] <moritz> oh, the post men will love me for sending the recipient address as an audiobook :-)

[11:24] <dalek> rakudo/nom: 409db17 | moritz++ | t/spectest.data:

[11:24] <dalek> rakudo/nom: run mkdir_rmdir.t

[11:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/409db1720e

[11:27] <tadzik> moritz: oh, it's always like this with learning :)

[11:29] <dalek> roast: 75f1166 | moritz++ | S16-filehandles/mkdir_rmdir.t:

[11:29] <dalek> roast: fudge S16-filehandles/mkdir_rmdir.t for rakudo

[11:29] <dalek> roast: review: https://github.com/perl6/roast/commit/75f1166279

[11:30] *** pernatiy left
[11:30] *** xinming joined
[11:36] *** sisar joined
[11:55] *** birdwind1pbird joined
[12:02] <sisar> hi !

[12:03] *** mucker left
[12:06] <masak> sisar! \o/

[12:07] <sisar> masak : did you get a chance to look at http://irclog.perlgeek.de/perl6/2012-02-26#i_5209998 and the following conversation ?

[12:07] <sisar> s/following/subsequent

[12:07] <masak> yes, I saw it.

[12:08] <masak> Perl 6 historically was forgiving with numification of not-number-strings.

[12:08] <masak> but it has become stricter in the past few years.

[12:08] <masak> perl6: say +'foo'

[12:08] <p6eval> niecza v14-96-g4c7a3f0: OUTPUT«Unhandled exception: Cannot parse number: foo␤  at /home/p6eval/niecza/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3401 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3403 (NumSyntax.str2num @ 4) ␤  at …

[12:08] <p6eval> ..pugs b927740, rakudo 409db1: OUTPUT«0␤»

[12:08] <masak> I believe Niecza is more correct than Rakudo/Pugs here.

[12:09] <sisar> (as i mentioned there) the specs are not clear on this

[12:09] <tadzik> +1

[12:12] <sisar> revisiting my problem, "if $x = <someAlphabet>, and i want to increase $x by 2, i.e. 'a' goes to 'c' , how would i do that ?"

[12:12] <sisar> .succ is not good enough

[12:12] <masak> .succ.succ

[12:12] <masak> (duh) :)

[12:12] <sisar> masak: how about from 'a' to 's'

[12:13] <masak> sub increase-by-n($orig, $n) { my $result = $orig; $result .= succ for ^$n; $result }

[12:14] <sisar> (suppose i want to go from 'a' to 'e') how about 'a'.succ(4)

[12:15] <masak> arrgh, no.

[12:15] <masak> don't laden the .succ interface with complexity for everyone just to satisfy a use case you like.

[12:15] <fsergot> nim: say 1.succ.

[12:15] <masak> fsergot: it's "nom" and no period at the end

[12:16] <fsergot> nom: say 1.succ

[12:16] <p6eval> nom 409db1: OUTPUT«2␤»

[12:18] <sisar> masak: submitting a rakudobug?

[12:18] <fsergot> masak: because of small touch keyboard :-)

[12:19] <masak> sisar: sorry, for what?

[12:19] *** birdwind1pbird left
[12:20] <sisar> masak: +'foo' gives 0

[12:20] <sisar> or maybe you meant Niecza is more correct but rakudo is still correct (?)

[12:21] <masak> ah.

[12:21] <masak> I think there's already a rakudobug in there for that.

[12:22] <sisar> niecza: say +'two'; #just for fun  ;-)

[12:22] <p6eval> niecza v14-96-g4c7a3f0: OUTPUT«Unhandled exception: Cannot parse number: two␤  at /home/p6eval/niecza/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3401 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3403 (NumSyntax.str2num @ 4) ␤  at …

[12:22] <sisar> hehe

[12:24] <masak> niecza: say +'rebmun esrap tonnaC'

[12:24] <p6eval> niecza v14-96-g4c7a3f0: OUTPUT«Unhandled exception: Cannot parse number: rebmun esrap tonnaC␤  at /home/p6eval/niecza/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3401 (ANON @ 10) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3403 (NumSyntax.str…

[12:24] <masak> guess I should've had a colon at the start, too.

[12:25] <sisar> :)

[12:27] * sisar think if +'two' -> 2 is actually implemented in perl6, that would be a helluva dwim

[12:27] <lumi___> +'the number I'm thinking of' -> 7

[12:27] <sisar> of course i can make a module for tha()

[12:27] <sisar> *that

[12:27] <moritz> well, if we did, then people would want other languages to DWIM too

[12:28] <moritz> and a generic mechanism for plugging in other numification schemes

[12:28] <sisar> yeah, but that would be awesome !

[12:28] <sisar> not to mention a pain for compiler writers

[12:28] <moritz> and a mechanism for context-dependent numifications

[12:29] <sisar> but who cares about compiler writers these days ;-)

[12:29] * moritz 

[12:29] <sisar> moritz: +1 #context...

[12:30] * sisar too

[12:30] <moritz> use numification :base<day> :offset<yesterday>; say +'tomorrow' # 2

[12:31] <moritz> dammit, I should have saved that for Date.new('2012-03-31').succ

[12:32] <masak> nom: sub increase-by-n($orig, $n) { my $result = $orig; $result .= succ for ^$n; $result }; say increase-by-n("a", 18)

[12:32] <p6eval> nom 409db1: OUTPUT«s␤»

[12:33] <masak> nom: sub increase-by-n($orig, $n) { my $result = $orig; $result .= succ for ^$n; $result }; say "a".&increase-by-n(18)

[12:33] <p6eval> nom 409db1: OUTPUT«s␤»

[12:34] <sisar> masak: i'll modify that sub to accept 's' rather than 18

[12:34] <masak> moritz: every sufficiently advanced April 1st joke is indistinguishable from a real Perl 6 feature.

[12:34] <sisar> mosak: because, i know what letter i want finally, rather than how much increment i want

[12:34] <moritz> nom: sub increase-by-n($orig, $n) { ($orig, *.succ ... *)[$n] }; say increase-by-n('a', 18)

[12:34] <p6eval> nom 409db1: OUTPUT«s␤»

[12:35] <masak> nice.

[12:35] <masak> nom: sub increase-by-n($orig, $n) { ($orig ... *)[$n] }; say increase-by-n('a', 18)

[12:35] <p6eval> nom 409db1: OUTPUT«Decrement out of range␤  in method <anon> at src/gen/CORE.setting:7569␤  in <anon> at src/gen/Metamodel.pm:2213␤  in find_method_fallback at src/gen/Metamodel.pm:2211␤  in find_method at src/gen/Metamodel.pm:819␤  in block <anon> at src/gen/CORE.setting:9385␤  in bloc…

[12:35] <sisar> tmtowtdi++

[12:35] <masak> decrement!?

[12:36] *** jaldhar left
[12:36] <masak> nom: .say for (1 ... 100)[^10]

[12:36] <p6eval> nom 409db1: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[12:36] <masak> nom: .say for (1 ... *)[^10]

[12:36] <p6eval> nom 409db1: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤»

[12:36] <masak> nom: .say for ("a" ... *)[^10]

[12:36] <p6eval> nom 409db1: OUTPUT«Decrement out of range␤  in method <anon> at src/gen/CORE.setting:7569␤  in <anon> at src/gen/Metamodel.pm:2213␤  in find_method_fallback at src/gen/Metamodel.pm:2211␤  in find_method at src/gen/Metamodel.pm:819␤  in block <anon> at src/gen/CORE.setting:9385␤  in bloc…

[12:36] <masak> I call bug.

[12:36] * moritz calls masak

[12:37] *** pernatiy joined
[12:37] * masak submits rakudobug

[12:37] <colomon> who you gonna call?  masakbot!

[12:38] *** mcartmell left
[12:39] <masak> :P

[12:39] *** mikec joined
[12:39] <masak> scansion doesn't really work, but still.

[12:41] *** snearch joined
[12:44] <jnthn> +'foo' giving 0 in Rakudo doesn't deserve a bug report because the spec doesn't say it's wrong, afaik.

[12:44] <jnthn> Let's get the spec clarified before claiming Rakudo is wrong. :)

[12:45] <masak> agreed.

[12:46] <jnthn> There's plenty of (Perl 5) precedent for it being 0.

[12:46] <jnthn> Exception feels a bit wrong...it maybe is a fail()

[12:46] <jnthn> s/wro/stro/

[12:46] <moritz> jnthn: it's the "Decrement out of range" that's a bug

[12:46] <jnthn> moritz: I agree that's a bug.

[12:47] <jnthn> moritz: I was looking back at the +'foo' discussion.

[12:48] <masak> I checked, and didn't find an existing RT ticket for +'foo' being 0 rather than error. I won't submit one either.

[12:53] <moritz> it only makes sense to fail() in that case once our Failure handling has become much better

[12:54] <jnthn> Yeah.

[12:54] <jnthn> Once I'm done with bs stuff I need to go back and look at the TimToady++ failure changes proposal again

[12:54] <moritz> well, proper failure handling also needs sink

[12:58] *** havenn joined
[13:00] * masak decommutes

[13:01] *** tokuhirom joined
[13:01] <jnthn> Decommuting? at 2pm?!

[13:01] <sjn> jnthn: welcome to scandinavia :)

[13:15] <daxim> is that an euphemism now for getting out of bed?

[13:16] <moritz> no.

[13:20] <sisar> where are modules installed by panda installed ?

[13:21] <moritz> ~/.perl6/lib/

[13:21] <sisar> thanks :)

[13:24] *** havenn left
[13:29] *** kaleem_ joined
[13:32] *** mtk joined
[13:32] *** kaleem left
[13:44] *** retupmoca left
[13:44] *** am0c left
[13:56] *** sergot joined
[13:58] *** retupmoca joined
[14:00] *** fsergot left
[14:01] *** slavik1 joined
[14:04] *** snearch left
[14:05] *** am0c joined
[14:15] *** am0c left
[14:17] *** sergot left
[14:18] *** fsergot joined
[14:19] *** noam_ left
[14:19] *** noam_ joined
[14:25] *** kaleem_ left
[14:30] *** skids joined
[14:31] *** xinming left
[14:32] *** xinming joined
[14:38] <jnthn> Productive day. So far I've deleted 400,000 lines of code.

[14:39] <moritz> wow

[14:39] <jnthn> I don't think my "lines committed" count at this place will ever be positive again. :)

[14:39] <moritz> did the source tree contain several hundred slightly different versions of the same tree?

[14:39] <jnthn> No

[14:40] <jnthn> Just a huge amount of code generated by an ORM.

[14:40] *** PacoAir joined
[14:40] <colomon> \o/

[14:41] <colomon> my wife says you should get a double positive count for deleting lines, as long as the code still works.  ;)

[14:42] <jnthn> :)

[14:42] * colomon is trying to figure out if he is looking at dead code which can be deleted for his $work, too

[14:47] * jnthn also discovered git show --stat today also :)

[14:47] <jnthn> s:1st/also//

[14:49] <colomon> what's that do?

[14:49] <moritz> and that's non-trival to discover, because it's not explicitly in the man page

[14:49] <moritz> colomon: gives a summary of added/deleted lines

[14:49] <jnthn> colomon: Shows a diffstat for the commit

[14:50] <colomon> ah

[14:50] <colomon> interesting

[14:51] <moritz> ah, 'man git-show' says "This manual page describes only the most frequently used options."

[14:52] <moritz> and... what about the others? Should I read the source code?

[14:55] *** agentzh left
[15:01] <[Coke]> perhaps info?

[15:01] <daxim> ahahahaha

[15:03] <moritz> all the manpages say that one should use 'info' for more documentationi, and then the info page is exactly the same as the man page, but shown in a weirder pager

[15:04] *** eiro joined
[15:04] <eiro> hello all

[15:04] <moritz> eiro/

[15:04] <eiro> someone can tell me how to write "it's unreadable!" in swedish ? 

[15:05] <eiro> (also the spelling can be fun)

[15:05] <moritz> phenny: en se "it's unreadable"?

[15:05] <phenny> moritz: "it's unreadable" (en to se, translate.google.com)

[15:05] <moritz> erm

[15:06] <moritz> Det är oläslig # says the web interface

[15:06] <jnthn> looks feasible.

[15:06] <moritz> and that sounds reasonable to me

[15:06] <jnthn> läs is certainly "to read"

[15:07] <moritz> (in German "unleserlich" is "unreadable", and it seems to follow the same pattern as "oläslig")

[15:08] <eiro> i don't trust translate.google.com when i don't know the langage at all 

[15:08] <eiro> ok then: i have the first slide of my perl introduction

[15:08] <moritz> aye; helps to know 2.5 other germanic languages :-)

[15:09] <moritz> ok, really more like 2.1 :-)

[15:09] *** kmwallio joined
[15:09] <eiro> :) which are ?

[15:10] <moritz> German, English, Norwegian (Bokmal)

[15:10] <moritz> in descending order of fluency

[15:10] * jnthn does English and a little Swedish :)

[15:11] <eiro> jnthn, also czec for ya ?

[15:11] <arnsholt> eiro/moritz: From a Norwegian perspective, the Swedish looks good as well

[15:12] <fsergot> nom: .say for 1, 5 ... 100;

[15:12] <p6eval> nom 409db1: OUTPUT«(timeout)»

[15:12] <arnsholt> It's the same in Norwegian , modulo spelling

[15:12] <fsergot> nom: .say for 0, 5 ... 100;

[15:12] <p6eval> nom 409db1: OUTPUT«0␤5␤10␤15␤20␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤100␤»

[15:12] <jnthn> eiro: I speak some Slovak, which is close to Czech.

[15:12] <fsergot> How to do the same loop but with 99 as the upper limit?

[15:13] *** havenn joined
[15:13] <cognominal> eiro: \o/

[15:13] <eiro> cognominal, \o/

[15:13] <fsergot> nom: .say for 0, 5 ... 99; # doesn't work

[15:13] <eiro> oh ... so what about the perl6 classroom at jp12 ? 

[15:13] <p6eval> nom 409db1: OUTPUT«(timeout)»

[15:13] <jnthn> fsergot: It won't work because you never hit 99

[15:13] <eiro> masak, any news ? 

[15:13] <cognominal> très Gaullien comme salut :)

[15:13] <jnthn> fsergot: It has to match exactly.

[15:14] <moritz> jnthn: but it's a bug that 'for' is eager-ish if it can't detect the infinity of the list

[15:14] <jnthn> True.

[15:14] <jnthn> Dunno who is to blame for that one.

[15:14] <arnsholt> cognominal: ECHANNEL? =)

[15:14] <jnthn> MapIter or GatherIter or something in series...

[15:14] <jnthn> *sequences

[15:14] <moritz> not sequences

[15:14] <fsergot> jnthn: is there any way to do what I want (short :P )

[15:14] <fsergot> ? :)

[15:15] <moritz> iirc it's not limited to them

[15:15] <moritz> fsergot: what is that you want to do?

[15:15] <jnthn> nom: .say for 0, 5 ... * < 99 # maybe

[15:15] <p6eval> nom 409db1: OUTPUT«0␤»

[15:15] <moritz> nom: .say for 0, 5 ... * >= 99

[15:15] <p6eval> nom 409db1: OUTPUT«0␤5␤10␤15␤20␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤100␤»

[15:15] <jnthn> er, yes, that way :)

[15:16] <jnthn> nom: .say for 0, 5 ...^ * >= 99

[15:16] <moritz> a successfull smartmatch terminates the sequence

[15:16] <p6eval> nom 409db1: OUTPUT«0␤5␤10␤15␤20␤25␤30␤35␤40␤45␤50␤55␤60␤65␤70␤75␤80␤85␤90␤95␤»

[15:16] <fsergot> I want to read every fifth element of a 100 element array.

[15:16] *** noam_ left
[15:16] <fsergot> Great! thanks moritz++

[15:16] <fsergot> jnthn++

[15:17] <moritz> nom: say ('a' .. 'z')[0, 5 ... *]

[15:17] <p6eval> nom 409db1: OUTPUT«Method 'gimme' not found for invocant of class 'Range'␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1159␤  in block <anon> at /tmp/1vA_PP1V8t:1␤␤»

[15:17] <colomon> nom: my @array = 'a'..'z' xx 5; say @array[0, 5 ... * >= 99]

[15:17] <moritz> nom: say ('a' .. 'z').list[0, 5 ... *]

[15:17] <p6eval> nom 409db1: OUTPUT«a f k p u z Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any()␤»

[15:17] <p6eval> nom 409db1: OUTPUT«a f k p u z␤»

[15:18] <moritz> nom: say ('a' .. 'z').list[0, 5 ... *]

[15:18] *** havenn left
[15:18] <p6eval> nom 409db1: OUTPUT«a f k p u z␤»

[15:18] <colomon> nom: my @array = 'a'..'z' xx 5; say @array.list[0, 5 ... * >= 99]

[15:18] <p6eval> nom 409db1: OUTPUT«a f k p u z Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any()␤»

[15:18] <jnthn> colomon: That may be precedence

[15:18] <moritz> it seems it doesn't flatten?

[15:18] <moritz> ah

[15:18] <colomon> nom: my @array = ('a'..'z' xx 5).list; say @array[0, 5 ... * >= 99]

[15:19] <p6eval> nom 409db1: OUTPUT«===SORRY!===␤Confused␤at /tmp/kVl0GpNtqW:1␤»

[15:19] <jnthn> nom: my @array = ('a'..'z') xx 5; say @array.list[0, 5 ... * >= 99]

[15:19] <p6eval> nom 409db1: OUTPUT«a f k p u z e j o t y d i n s x c h m r w␤»

[15:19] <colomon> jnthn++

[15:19] * moritz agrees completely with afkpuzejotydinsxchmrw :-)

[15:21] * sisar badly wants multi-dimensional arrays to be implemented

[15:21] <colomon> really could use one more vowel, I reckon

[15:21] *** jferrero joined
[15:22] <moritz> sisar: you're not the only one :-)

[15:22] <sisar> moritz: sigh !

[15:22] * jnthn wonders if his next grant should be "do S09 stuff" :)

[15:22] <colomon> sisar: you can always start implementing.... ;)

[15:22] <sisar> jnthn++ #just for wondering !

[15:22] *** noam joined
[15:23] *** explorer__ left
[15:24] * colomon only wanted to write libraries in Perl 6, but somehow got dragged by #perl6 into implementing the compilers....

[15:24] *** noam left
[15:24] <sisar> colomon: yeah, but i'm sure you guys would have finished implementing it twice before i complete implementing it :p

[15:24] <colomon> *helping implementing

[15:24] *** noam joined
[15:24] <moritz> sisar: the point is not to complete it yourself, but help us doing it :-)

[15:24] <moritz> and even small bits help

[15:25] <moritz> colomon: well, part of the compiler (the setting) does feel like writing libraries

[15:25] <moritz> and it is, in fact

[15:25] <moritz> that's how I got lured too

[15:25] *** havenn joined
[15:25] <colomon> sisar: I'm pretty sure every single thing I've done on niecza, sorear++ could have done just as well, probably better.  But that doesn't mean I'm not usefully helping him out by doing what I can do and freeing him up to work on the trickier stuff.

[15:26] <colomon> moritz: true enough, most of what I've done probably qualifies as writing core libraries.  :)

[15:26] <sisar> moritz: what are you working on currently & how can i help? #give my 2 cents 

[15:27] <moritz> sisar: one thing I'm working on in Rakudo is to convert error messages from pure strings to objects that contain more information

[15:27] <moritz> nom: Date.new('2012-02-31')

[15:27] <p6eval> nom 409db1: OUTPUT«day of 2012/2 out of range. Is: 31, should be in 1..29␤  in method check-value at src/gen/CORE.setting:8719␤  in method check-date at src/gen/CORE.setting:8729␤  in method new at src/gen/CORE.setting:9035␤  in method new at src/gen/CORE.setting:9041␤  in method new at…

[15:27] *** tokuhirom left
[15:27] *** preflex_ joined
[15:27] <moritz> that's just the string, but under the hood...

[15:27] <sisar> oh!  that is 'typed exceptions' (?)

[15:27] <moritz> nom: try Date.new('2012-02-31'); say $!.perl

[15:27] <p6eval> nom 409db1: OUTPUT«X::OutOfRange.new(what => "day of 2012/2", got => 31, range => 1..29)␤»

[15:27] <moritz> sisar: correct

[15:28] <moritz> sisar: and it's not too hard to do. You just search for places where the compiler or the setting throws an error (search for 'die' or 'panic')

[15:28] <moritz> and then come up with a name for that error

[15:28] <moritz> and write a class for it in src/core/Exceptions.pm

[15:29] *** preflex left
[15:29] <moritz> and change the throwing location to use the class

[15:29] <moritz> write a test in t/spec/S32-exceptions/misc.t

[15:29] *** preflex_ is now known as preflex

[15:29] * sisar .oO( i said 2 cents, not 2 dollars !! )

[15:29] <moritz> that's more like 0.5 dollars :-)

[15:30] <moritz> sisar: that's how a typical patch looks like: https://github.com/rakudo/rakudo/commit/9d39e880e0ebf8c157b2e44f33fda58481ce8cd6

[15:30] <[Coke]> 4 bits.

[15:30] <moritz> sisar: not too complicated, is it?

[15:31] <sisar> okay, really basic question, are exceptions just errors with more info?

[15:31] <moritz> https://github.com/rakudo/rakudo/commit/867f9d5cb98ebfd36a7bd7c93202f7f8623377ac that one is a bit more complex (it passes additional information to the error object), but still manageable

[15:32] <moritz> in this case yes

[15:32] *** kaare__ joined
[15:32] <moritz> well, not even much more information than before, but easier to access

[15:32] <moritz> nom: try Date.new('2012-02-31'); say $!.range

[15:32] <p6eval> nom 409db1: OUTPUT«1..29␤»

[15:32] <moritz> I didn't need to parse the error message

[15:33] <moritz> and I can catch just this kind of exception if I want, because it's identified by a type

[15:33] <moritz> these two pieces are the whole point, really

[15:33] *** xinming left
[15:34] <sisar> hmm, looks interesting

[15:35] <moritz> sisar: want to walk through such a change?

[15:35] *** xinming joined
[15:36] <sisar> yes-ish :p

[15:36] <moritz> ok

[15:36] <moritz> let's start by finding a place to change

[15:36] <moritz> on my shell, I type

[15:37] <moritz> $ ack -w die src/core/

[15:37] <moritz> lots of hits

[15:37] <moritz> one for example is

[15:37] <moritz> src/core/Routine.pm

[15:37] <moritz> 89:            die("Invalid wrap handle passed to routine")

[15:37] <moritz> so, let's open src/core/Routine.pm

[15:38] <moritz> the code that throws the error is:

[15:38] <moritz>     method unwrap($handle) {

[15:38] <moritz>         $handle.can('restore') && $handle.restore() ||

[15:38] <moritz>             die("Invalid wrap handle passed to routine")

[15:38] <moritz>     }

[15:38] <moritz> so, routines can be wrapped and then unwrapped. The error is thrown if you try to unwrap something that wasn't wrapped, or is totally unrelated

[15:38] <sisar> wait, let me open it too

[15:38] * moritz waits

[15:39] <sisar> ok, loacated the code 

[15:40] <sisar> continue

[15:40] <moritz> alright

[15:40] <moritz> so, we need a name for that error

[15:40] <moritz> by convention, all error type names start with X::

[15:41] <moritz> then the error is related to routines, and occurs during unwrapping. So let's call it X::Routine::Unwrap

[15:42] <moritz> so, in another terminal, we open src/core/Exceptions.pm, and create that class

[15:42] <moritz> the general structure is

[15:43] <moritz> my class X::Routine::Unwrap is Exception { method message() { "error message here" } }

[15:44] <moritz> sisar: with me so far?

[15:44] <sisar> yes

[15:44] *** Psyche^ joined
[15:44] <moritz> ok, so we save Exceptions.pm

[15:44] <sisar> what does 'is Exception' do ?

[15:44] <moritz> it makes the new class inherit from the class Exception

[15:44] <moritz> which gives it facilities such as a .backtrace method

[15:45] <moritz> so, back to Routine.pm

[15:45] <moritz> we just replace   die("some message here")  by  die(X::Routine::Unwrap.new())

[15:46] <moritz> we're nearly done now

[15:46] <sisar> what is the .new() for ?

[15:47] <moritz> well, we want to throw an object of class X::Routine::Unwrap and not just the type object

[15:47] <moritz> because our object carries state, like the backtrace

[15:47] <moritz> so we need to create a new object, and throw that

[15:47] <moritz> ("throw that" means "pass it to die()")

[15:47] <sisar> ok

[15:48] <moritz> so, there's a tiny problem left

[15:48] <moritz> Routine.pm is compiled before Exceptions.pm

[15:48] *** Patterner left
[15:48] *** Psyche^ is now known as Patterner

[15:48] <moritz> so if tried to compile rakudo now, it'd compain that it doesn't know about X::Routine::Unwrap

[15:48] <moritz> to fix that, we put a so-called "stub" at the very start of Routine.pm

[15:48] <moritz> it's a promise that we'll declare that class later

[15:49] <moritz> it goes like this:

[15:49] <moritz> my class X::Routine::Unwrap { ... } # literal ... here

[15:49] <sisar> oh the yada-yada-yada operator !

[15:49] <[Coke]> (all error type names start with X) - I'm used to X not being a core thing, but a user-extension. (http, smtp)

[15:49] *** skipper joined
[15:50] <moritz> sisar: right

[15:50] <moritz> so, let's safe Routine.pm

[15:50] *** havenn left
[15:50] <moritz> and type 'make'

[15:50] <moritz> and wait for a while

[15:50] <moritz> in the mean time, we can think about writing a test

[15:50] <moritz> first let's try to trigger the error here

[15:50] <moritz> nom: sub f() { }; f.unwrap

[15:50] <p6eval> nom 409db1: OUTPUT«Method 'unwrap' not found for invocant of class 'Nil'␤  in block <anon> at /tmp/BXxkCpbZSS:1␤␤»

[15:50] <moritz> wow, that was wrong

[15:51] <moritz> I tried to call .unwrap on the return value of sub f

[15:51] <moritz> nom: sub f() { }; &f.unwrap

[15:51] <p6eval> nom 409db1: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method unwrap at src/gen/CORE.setting:1567␤  in block <anon> at /tmp/PzK37ydhe4:1␤␤»

[15:51] <moritz> right, method unwrap wants a wrap handler

[15:51] <moritz> so, let's give it something that's not a wrap handler

[15:51] <moritz> nom: sub f() { }; &f.unwra("foo")

[15:51] <p6eval> nom 409db1: OUTPUT«Method 'unwra' not found for invocant of class 'Sub'␤  in block <anon> at /tmp/QHWFU0z1OA:1␤␤»

[15:51] <moritz> nom: sub f() { }; &f.unwrap("foo")

[15:51] <p6eval> nom 409db1: OUTPUT«Invalid wrap handle passed to routine␤  in method unwrap at src/gen/CORE.setting:1569␤  in block <anon> at /tmp/5RNnAQBlty:1␤␤»

[15:52] <sisar> bingo !

[15:52] <moritz> aye

[15:53] <moritz> so, we know how to trigger the error

[15:53] <moritz> let's go to t/spec/S32-exceptions/misc.t

[15:53] <moritz> to the very end of the file

[15:53] <moritz> and the test goes like this:

[15:53] <colomon> moritz++  # very cool to watch this in the background as I hack up my $work source

[15:53] <moritz> throws_like 'string that causes the error', X::Error::Type;

[15:53] <moritz> so

[15:54] <moritz> throws_like 'sub f() { }; &f.unwrap("foo")', X::Routine::Unwrap

[15:54] *** thou joined
[15:54] <moritz> add semicolon at the end of the line

[15:54] <sisar> wait, i dont' have a spec library in my 't' directory

[15:55] <sisar> (i have rakudo cloned)

[15:55] <moritz> sisar: type   make spectest_checkout    in a shell in your rakudo dir

[15:55] <moritz> sisar: that gets the t/spec/ dir from github

[15:56] <moritz> sisar: you have to do that only the first time

[15:56] <sisar> it is clonig as we speak :)

[15:56] <sisar> continue...

[15:57] <moritz> well, we're mostly done

[15:57] <moritz> add the test I typed above

[15:57] <moritz> safe the file

[15:57] <moritz> wait for rakudo to compile

[15:57] <moritz> and then when rakudo has compiled, type    make t/spec/S32-exceptions/misc.t

[15:58] <moritz> and if the test passes, you know it worked

[15:58] <moritz> (I had to restart my rakudo compilation because of a stupid typo, so it might take a bit longer here)

[15:59] <sisar> will take still longer for me, i'm on a very slow machine

[16:01] <moritz> finished compiling here \o/

[16:01] <moritz> and... test passes

[16:01] <sisar> what does the test mean: just check if the exception was thrown or not?

[16:02] <moritz> it does two thinks

[16:02] <moritz> first it checks that the code actually died

[16:02] <moritz> and then it checks the type of that exception

[16:02] <moritz> the test output here is

[16:02] <moritz> ok 194 - 'sub f() { }; &f.unwrap("foo")' died

[16:02] <moritz> ok 195 - right exception type (X::Routine::Unwrap)

[16:03] <sisar> moritz: sorry !!

[16:03] <sisar> damn! i got to go :(( will be back as soon as possible

[16:03] <moritz> sisar: I'll also decommute

[16:03] <moritz> sisar: don't hurry, let it compile in the background :-)

[16:03] * sisar afk

[16:04] *** thou left
[16:04] *** bacek left
[16:05] * moritz also afk

[16:20] * jnthn decommutes

[16:22] *** att joined
[16:24] *** bothra joined
[16:24] *** bothra left
[16:27] *** lue left
[16:31] * colomon is getting that warm fuzzy feeling you get when your rewrite is shorter...

[16:31] *** blynch joined
[16:34] *** daxim left
[16:34] *** Jerkwad joined
[16:38] *** mucker joined
[16:40] *** lue joined
[16:44] *** pernatiy_ joined
[16:45] <TimToady> masak: that's an interesting solution to quasi lifting; treat all functions as potential macros

[16:45] *** blynch left
[16:45] *** pernatiy left
[16:46] <TimToady> I'm not sure it helps much with lifting our multi-ops though

[16:47] *** Trashlord left
[16:48] * TimToady is referring to http://irclog.perlgeek.de/perl6/2012-02-26#i_5211665

[16:48] *** blynch joined
[16:51] <TimToady> in general, multi-macros don't seem like they'd work too well if they have to reify a switch statement at every call point

[16:51] *** skipper left
[16:51] <TimToady> lifts in multis seem more like they just need to delay lookup of the lifted names till when the caller is known

[16:52] *** Trashlord joined
[16:54] *** wtw left
[16:54] *** kaare__ is now known as kaare_

[16:56] *** havenn joined
[16:57] *** thou joined
[16:57] * jnthn home

[16:58] *** wolfman2000 left
[17:01] *** am0c joined
[17:01] <TimToady> perl6: say "True" if 'a' === any <a b c>

[17:01] <p6eval> pugs b927740, rakudo 409db1, niecza v14-96-g4c7a3f0: OUTPUT«True␤»

[17:01] <TimToady> perl6: say "True" if 'a' eqv any <a b c>

[17:01] <p6eval> rakudo 409db1, niecza v14-96-g4c7a3f0:  ( no output )

[17:01] <p6eval> ..pugs b927740: OUTPUT«True␤»

[17:02] <TimToady> pugs++

[17:02] <TimToady> rakudobug, nieczabug

[17:03] <colomon> TimToady: this is what I was messing around with the other day.  Are you saying eqv should take Any arguments?

[17:03] <TimToady> that is exactly what I'm saying

[17:03] <TimToady> as with ===, there needs to be a more primitive eqv underneath that doesn't autothread

[17:04] <TimToady> but users will expect eqv to autothread

[17:04] <colomon> then we've got incorrect spectests....

[17:04] <colomon> in eqv.t

[17:04] * TimToady is not surprised; I keep having to argue this point :)

[17:05] <TimToady> either way we work it is a FAQ, but I think way will be less F than the other

[17:05] <TimToady> *this way

[17:05] <colomon> reckon I can fix the spectests and niecza.  :)

[17:06] *** lateau__ joined
[17:07] <lateau__> can I ask somthing about nqp here?

[17:08] <jnthn> Sure

[17:08] <TimToady> certainly, though I'm not the expert on that

[17:08] <lateau__> thank you

[17:09] <lateau__> is this allowed in nqp? %hash = ( 'k' => 'v'); on perl6

[17:09] *** kaare_ left
[17:09] *** kaare_ joined
[17:09] <jnthn> No

[17:09] <lateau__> oops

[17:09] <jnthn> For one, no assignment.

[17:10] <jnthn> Only binding

[17:10] *** birdwindupbird left
[17:10] *** pernatiy_ left
[17:10] <lateau__> so, I should do it like :      my %hash; %hash<key> := 'value'; 

[17:11] <[Coke]> nqp: my %hash; %hash<key> := 'value';

[17:11] <p6eval> nqp:  ( no output )

[17:11] <[Coke]> nqp: my %hash; %hash<key> := 'value'; say %hash<key>

[17:11] <p6eval> nqp: OUTPUT«get_pmc_keyed() not implemented in class 'Sub'␤current instr.: '_block1000' pc 73 ((file unknown):56) (/tmp/nzzHmIeG4A:1)␤»

[17:11] <jnthn> nqp: my %h := hash(a => 1, b => 2); say(%h<a>)

[17:11] <p6eval> nqp: OUTPUT«1␤»

[17:11] <jnthn> nqp: my %h := hash(a => 1, b => 2); say(%h<b>)

[17:11] <p6eval> nqp: OUTPUT«2␤»

[17:12] <jnthn> Like that.

[17:12] *** NamelessTee left
[17:13] <lateau__> jnthn: I got "Could not find sub hash"

[17:13] *** pyrimidine left
[17:14] <lateau__> jnthn: hmm... I'm using parrot-nqp. is this different from nqp?

[17:14] <jnthn> lateau__: Yes.

[17:14] <lateau__> jnthn: oops.

[17:15] <jnthn> The one in the nqp repo https://github.com/perl6/nqp is latest

[17:15] <jnthn> And is the one we're using with Rakudo.

[17:16] *** plobsing left
[17:17] *** havenn left
[17:17] *** ggoebel left
[17:18] *** plobsing joined
[17:18] <lateau__> jnthn: I'm actually working with parrot-nqp and referencing that repo(around HLL). I was confusing why parrot-nqp did not works like nqp sometimes. parrot-nqp != nqp... thank you ;)

[17:20] <TimToady> colomon: btw, eqv autothreading is specced at S03:1303, if you want an argument from the scriptures :)

[17:21] <colomon> TimToady: I'm okay with getting the answer from on high.  ;)

[17:22] * TimToady won't make you take off your shoes :)

[17:23] <TimToady> and I'd better not pursue that metaphor much further lest I be eaten of worms :)

[17:23] * colomon is already shoeless

[17:24] <colomon> well, barefoot, anyway

[17:27] *** ggoebel joined
[17:28] *** noam left
[17:29] <TimToady> oh, got to the backlog where sorear++ already point out eqv(Any,Any)

[17:29] <TimToady> well, I call Volleyball Principle

[17:29] <TimToady> (better too many going for the ball than too few)

[17:29] <sorear> good * #perl6

[17:30] <TimToady> good morning

[17:31] <jnthn> o/ sorear 

[17:33] <fsergot> \o

[17:33] <colomon> \o

[17:36] *** kaare__ joined
[17:36] <fsergot> open 'file', :w allows us to write to file, right?

[17:36] *** kaare_ left
[17:36] <colomon> yes

[17:37] *** aindilis left
[17:37] <fsergot> But is this file "saved" only when we close a filehandle?

[17:37] * moritz back

[17:38] <moritz> yes, that's a limitation in current rakudo

[17:38] <moritz> and parrot, for that matter

[17:38] <colomon> and niecza, too

[17:38] <fsergot> :(

[17:38] <fsergot> Is it hard to change?

[17:40] <colomon> would have done it years ago if it was easy

[17:40] <sorear> is it bad of me to be thinking "if you don't close filehandles, you deserve whatever you get"?

[17:40] <fsergot> colomon: right, sorry for stupid question. :)

[17:41] <colomon> fsergot: it drives me crazy too.  I'm too use to C++'s RAII taking care of that sort of thing.  

[17:41] <TimToady> well, p5 will close them for you if you don't get around tuit

[17:43] *** NamelessTee joined
[17:43] *** noam joined
[17:43] <sorear> do we want to guarantee that p6 calls all DESTROY submethods on clean exit?

[17:43] <TimToady> btw (still backlogging) I think IO.lines should close the file

[17:44] <TimToady> sorear: I would like that very much

[17:44] <TimToady> it is especially necessary for embedded stuff

[17:45] <TimToady> you don't want apache leaking filehandles, for instance

[17:46] <TimToady> or memory, for that matter

[17:46] <colomon> or water

[17:47] <TimToady> well, depends on what kind of apache

[17:47] <sorear> fuel?

[17:49] <dalek> rakudo/nom: d696855 | moritz++ | src/core/ (2 files):

[17:49] <dalek> rakudo/nom: Routine.unwrap now throws a typed exception

[17:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d696855f41

[17:50] <dalek> roast: 52f6db6 | moritz++ | S32-exceptions/misc.t:

[17:50] <dalek> roast: test for X::Routine::Unwrap

[17:50] <dalek> roast: review: https://github.com/perl6/roast/commit/52f6db64fc

[17:50] <moritz> phenny: tell sisar I've turned our session into two commits, https://github.com/rakudo/rakudo/commit/d696855f41 and https://github.com/perl6/roast/commit/52f6db64fc

[17:50] <phenny> moritz: I'll pass that on when sisar is around.

[17:53] <dalek> rakudo/nom: 38fc6fc | moritz++ | src/core/Exceptions.pm:

[17:53] <dalek> rakudo/nom: awesomize error message a bit

[17:53] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/38fc6fcc72

[17:56] <dalek> niecza: acd7da0 | (Solomon Foster)++ | lib/CORE.setting:

[17:56] <dalek> niecza: infix:<eqv> is supposed to take Any, Any.

[17:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/acd7da077e

[17:57] *** havenn joined
[17:58] <dalek> roast: ca66c90 | (Solomon Foster)++ | S03-operators/eqv.t:

[17:58] <dalek> roast: Instead of testing Mu eqv Mu and Mu !eqv Any, test that infix:<eqv> autothreads.  (New test fudged for Rakudo.)

[17:58] <dalek> roast: review: https://github.com/perl6/roast/commit/ca66c9071d

[17:59] <TimToady> maybe primitive === and eqv should be called \=== and \eqv or some such

[18:00] <colomon> new test shamelessly stolen from TimToady++, btw.   ;)

[18:02] <TimToady> unless someone can think of better names

[18:02] <sorear> how about cmp?

[18:03] <slavik1> and <=> ?

[18:03] <TimToady> what is the numeric value of a junction?

[18:04] <TimToady> but certainly a prefix of '\' for "primitive" could be somewhat productive, if we want it

[18:05] <TimToady> but like + and ~, not like metaoperators

[18:07] <TimToady> unless \ is some kind of higher-order funciton that lies to Any,Any candidates about their arguments' types

[18:09] <sorear> TimToady: [\===]

[18:09] <TimToady> there is that

[18:11] <TimToady> could be spelled [[\===]] at need

[18:12] <TimToady> I doubt people are going to be reducing on the primitive ops all that often, and if they're good enough to know there are primitive ops, they'll know how to wrap ops in extra []

[18:12] *** sisar left
[18:12] <TimToady> perl6: say [[+]] 1,2,3

[18:13] <p6eval> rakudo 38fc6f, niecza v14-97-gacd7da0: OUTPUT«6␤»

[18:13] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "1"␤    expecting operator, ":" or ","␤    at /tmp/sHsTNFScxd line 1, column 11␤»

[18:16] <TimToady> perl6: sub infix:<\\===> ($a, $b) { $a === $b }; say [[\===]] 42, 42

[18:16] <p6eval> rakudo 38fc6f: OUTPUT«===SORRY!===␤Confused␤at /tmp/s0Yegi4aZ8:1␤»

[18:16] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "42"␤    expecting operator, ":" or ","␤    at /tmp/nXmCpfD3kr line 1, column 56␤»

[18:16] <p6eval> ..niecza v14-97-gacd7da0: OUTPUT«True␤»

[18:16] <TimToady> niecza++

[18:16] *** mj41 left
[18:18] <TimToady> perl6: sub infix:<\\+> ($a, $b) { $a + $b }; say [[\+]] 1,2,3

[18:18] <p6eval> niecza v14-97-gacd7da0: OUTPUT«6␤»

[18:18] <p6eval> ..rakudo 38fc6f: OUTPUT«===SORRY!===␤Confused␤at /tmp/fwDDTiteXp:1␤»

[18:18] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "1"␤    expecting operator, ":" or ","␤    at /tmp/NdCa5Kxci6 line 1, column 50␤»

[18:18] <TimToady> so that can work as an escape hatch

[18:19] * TimToady loves the 'op eq [op]' rule

[18:20] *** Trashlord left
[18:22] <dalek> specs: 46e7100 | larry++ | S03-operators.pod:

[18:22] <dalek> specs: conject \=== and \eqv

[18:22] <dalek> specs: review: https://github.com/perl6/specs/commit/46e7100639

[18:36] *** MayDaniel joined
[18:41] *** am0c left
[18:45] *** Chillance joined
[18:48] *** Trashlord joined
[18:49] <TimToady> phenny: tell grondilu if you remove the unnecessary 'where' constraints, your sha256 runs 20 times faster

[18:49] <phenny> TimToady: I'll pass that on when grondilu is around.

[18:51] <TimToady> phenny: tell grondilu if you really want them, change them to 'where ^33' and it still runs 15 times faster

[18:51] <phenny> TimToady: I'll pass that on when grondilu is around.

[18:51] <jnthn> How were they written originally?

[18:51] * jnthn tries to find the link in the backlog...

[18:51] <TimToady> where { $b == any(^33) }

[18:51] *** birdwindupbird joined
[18:52] <masak> hello-from-a-train, #perl6.

[18:52] <colomon> \o

[18:52] *** lateau__ left
[18:52] <TimToady> hello-to-a-train

[18:53] *** Trashlord left
[18:53] * [Coke] ponders again a perl6 intro talk for yapc::na.

[18:53] <jnthn> o/ masak 

[18:53] <jnthn> Which tells me junctions are a pig...

[18:54] <TimToady> especially in hot code :)

[18:54] <masak> followup to awesome Bret Victor video: http://www.chris-granger.com/2012/02/26/connecting-to-your-creation/

[18:54] <jnthn> Tssk. Looks like somehow the marshalling of the binary blob of serialization data is getting screwed up in some cases :(

[18:54] <colomon> TimToady, jnthn: surely it's not a surprise that 0 <= $b < 33 is faster than any($b == 0, $b == 1, $b == 2, ...)? 

[18:55] <TimToady> well, it's not a surprise to me, which is why I glared at the code the moment I saw it

[18:56] <[Coke]> masak: agh! I haven't even watched the victor video yet!

[18:56] * TimToady is too connected to his creation to watch random videos...

[18:57] <masak> [Coke]: suit yourself ;)

[18:57] <jnthn> Blech, and IMCC parses strings with escape codes REALLY slowly...

[18:57] <masak> jnthn: I read that as "marshmallowing the binary blob" :P

[18:58] <jnthn> masak: :P

[18:58] <TimToady> I read it as: Serializer! Serialize thyself!

[18:58] <jnthn> Screw it. Let's base-64 encode...

[18:58] <jnthn> Actually, I think I'll eat first. :)

[19:00] *** MayDaniel left
[19:00] <moritz> jnthn: can't you use freeze and thaw on strings?

[19:01] <masak> jnthn: you didn't catch the pronoun mis-agreement in "Det är oläslig"...

[19:02] <masak> moritz: the reson you couldn't translate to "se" is that the two-letter language code is "sv". you were thinking of the country code.

[19:02] <moritz> masak: oh right

[19:02] <jnthn> moritz: The serializer produces a binary blob. We emit a .pir file which *then* becomes a .pbc. It's the step through .pir that is currently seeming problematic :/

[19:03] <moritz> jnthn: complain in #parrot :-)

[19:03] <TimToady> interestingly, niecza without the junctional constraints only runs the code a couple percent faster

[19:04] <jnthn> TimToady: Rakudo's auto-threader is *slow*. Mostly because it's a "make stuff work" implementation rather than a "make stuff fast" one.

[19:04] <TimToady> so yes, something is pigging out on those where constraints in rakudo

[19:05] <TimToady> it's also possible something in mono is inlining all those shifts and rotoates

[19:05] <TimToady> *tates even

[19:05] *** proller_ joined
[19:08] *** pyrimidine joined
[19:10] *** twirp joined
[19:14] <masak> reading things like http://scalamacros.org/usecases/advanced-domain-specific-languages.html, I get the feeling Perl 6 macros will be digging into the guts of AST hierarchies, transforming them wildly, possibly using dedicated libraries.

[19:15] <masak> TimToady: re your suggestion to make all subs potential macros -- that reminds me of the recent-ish discussion to simply make macros subs with AST parameters.

[19:15] *** noam_ joined
[19:15] *** cogno joined
[19:16] <TimToady> .oO(Any sufficiently advanced macro is indistinguishable from a compiler.)

[19:18] <tadzik> 'evening

[19:18] *** noam left
[19:20] <masak> well, yes. subroutines give you new ways to produce values at runtime. macros give you new ways to produce compiled code at compile time.

[19:21] <masak> grr. train fast, connection slouuuugh.

[19:21] * colomon is making one of those "tiny" changes for $work which blossoms out into dozens of tricky decisions....

[19:21] <masak> tadzik! \o/

[19:22] <masak> tadzik: sometimes I get the urge to turn your nick into a diminutive when greeting you... but it already is a diminutive! :)

[19:23] <masak> tadzik: is there a word for that feeling in Polish "the wish to diminutize a name beyond the possible range"? :)

[19:25] <tadzik> diminutize?

[19:25] <tadzik> hmm, yes, it's diminutived already

[19:26] <tadzik> oh, there are techniques to diminutize a word beyond sanity

[19:26] <masak> how are we going to express affection towards you when it's the default? :)

[19:26] <colomon> t.z.!

[19:26] <tadzik> :) See, it's a hack

[19:27] <masak> "oh, tadeczik!" :D

[19:27] <tadzik> well, there are some names which my parents use against me which used to make me roar...

[19:27] <masak> with laughter? or with rage? :)

[19:28] <tadzik> my age decided :P

[19:29] <masak> heh.

[19:29] <tadzik> I used to go bananas upon hearing "tadzinek"

[19:29] <masak> aww

[19:29] <tadzik> SAY CUTE! SAY CUTE AND I'LL CUTE YOURSELF!

[19:29] <tadzik> :P

[19:30] *** mj41 joined
[19:30] * masak shields himself with a teddy bear

[19:30] *** MayDaniel joined
[19:31] *** cogno left
[19:31] <TimToady> you can always go multilingual: tadziklet, tadzikito, tadzikchan

[19:32] <masak> neat.

[19:33] <tadzik> teddy bear, very funny

[19:33] <masak> thought you might catch that one :)

[19:33] <tadzik> ;)

[19:36] * [Coke] always reads tadzik as tzatziki 

[19:37] <tadzik> heh, it made me wonder how would people say to me on NLPW, my first Perl event. To my suprise, they kept on twisting their tongues on "tadzik", and it sounded quite correct :)

[19:38] <[Coke]> # 02/27/2012 - niecza++ ; pugs (23.8%); rakudo (99.03%)

[19:38] <[Coke]> "niecza",     20302,     8,   751,  1539, 22600, 23752

[19:38] <[Coke]> "pugs"  ,      4832,     6,  2024,   404,  7265, 23561

[19:38] <[Coke]> "rakudo",     20106,    80,   605,  1856, 22647, 23762

[19:41] *** noam_ left
[19:42] *** noam_ joined
[19:42] <[Coke]> b: say 20302*.25-4832

[19:42] <p6eval> b 1b7dd1: OUTPUT«243.5␤»

[19:44] *** NamelessTee left
[19:44] <masak> [Coke]: it's a joy to see the Pugs percentage creep upwards. I hope to have some time slot to look at hacking Haskell later in the week.

[19:44] <dalek> rakudo/nom: 3ca6e5f | moritz++ | src/core/ (2 files):

[19:44] <dalek> rakudo/nom: typed exception from default constructor when called with positional arguments

[19:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ca6e5f574

[19:45] <[Coke]> masak: slow but steady. having someone hacking on actual haskell will help immensely, I wager.

[19:45] <dalek> roast: 44d0aa3 | moritz++ | S32-exceptions/misc.t:

[19:45] <dalek> roast: test X::Constructor::Positional

[19:45] <dalek> roast: review: https://github.com/perl6/roast/commit/44d0aa378e

[19:46] *** noam__ joined
[19:46] <[Coke]> (and having a runnable test suite will help them/you, is my hope)

[19:47] *** cogno joined
[19:47] <masak> indeed.

[19:47] <[Coke]> pugs: Date.new("something").say

[19:47] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&Date"␤    at /tmp/dpEw4uR5ts line 1, column 1 - line 2, column 1␤»

[19:49] *** noam_ left
[19:55] *** cogno left
[20:00] <TimToady> niecza: Date.new("something").say

[20:00] <p6eval> niecza v14-97-gacd7da0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'Date' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /home/p…

[20:01] <moritz> nobody has stolen Temporal.pm yet?

[20:01] <colomon> nope

[20:01] <TimToady> I could actually use the Date module right now in niecza for $job, but it depends heavily on overloading builtin multis

[20:01] <TimToady> which niecza doesn't support yet

[20:02] <colomon> :(

[20:03] *** lichtkind joined
[20:04] *** noam_ joined
[20:04] <lichtkind> is <prior> also a predefiend subrule?

[20:06] *** bacek joined
[20:06] <TimToady> grep is your friend here

[20:07] *** noam__ left
[20:15] <masak> two hits in S05.

[20:16] <TimToady> only one if you put the angles

[20:16] <masak> nod.

[20:16] *** alester joined
[20:17] *** icwiener joined
[20:19] *** birdwindupbird left
[20:21] *** birdwindupbird joined
[20:21] <lichtkind> i get just one hit and it was not in the list but looks like one

[20:22] <lichtkind> thatswhy i asking because i cant get definite info from s05

[20:23] *** havenn left
[20:24] *** havenn joined
[20:24] *** mucker left
[20:26] *** havenn left
[20:26] *** NamelessTee joined
[20:26] *** havenn joined
[20:27] <TimToady> what is this "the list" of which you speak?

[20:29] <lichtkind> http://feather.perl6.nl/syn/S05.html#Predefined_Subrules

[20:30] *** blynch left
[20:32] <moritz> nom: say 'abc' ~~ /../; say 'foobarabracadabra' ~~ /<prior> \w ** 5/

[20:32] <p6eval> nom 3ca6e5: OUTPUT«=> <ab>␤␤=> <abracad>␤ prior => <ab>␤␤»

[20:36] <jnthn> nom: say 'part' ~~ /a../; say 'quart' ~~ /<prior>/

[20:36] <p6eval> nom 3ca6e5: OUTPUT«=> <art>␤␤=> <art>␤ prior => <art>␤␤»

[20:37] *** mucker joined
[20:37] *** mucker left
[20:38] <moritz> jnthn++ # prior => <art>

[20:39] * [Coke] wonders why pugs passes six tests about wrap when it doesn't implement Sub's .wrap

[20:42] *** Chillance left
[20:42] *** Chillance joined
[20:43] *** mucker joined
[20:47] <masak> [Coke]: that's how awesome Pugs is.

[20:47] *** mucker left
[20:48] *** birdwindupbird left
[20:48] *** mucker joined
[20:51] <dalek> specs: 12a2ea6 | larry++ | S05-regex.pod:

[20:51] <dalek> specs: make clear that "the list" is not exhaustive

[20:51] <dalek> specs: 

[20:51] <dalek> specs: lichtkind++

[20:51] <dalek> specs: review: https://github.com/perl6/specs/commit/12a2ea6193

[20:51] <moritz> oh right, it doesn't come with :exhaustive :-)

[20:59] *** twirp left
[20:59] *** snearch joined
[21:03] *** Trashlord joined
[21:04] *** hundskatt joined
[21:07] *** kaare__ left
[21:07] *** kaare_ joined
[21:14] *** proller_ left
[21:22] <dalek> nqp/bs: b5e5fd1 | jnthn++ | / (3 files):

[21:22] <dalek> nqp/bs: Add a public domain base64 encode/decode implementation.

[21:22] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b5e5fd14d3

[21:22] <dalek> nqp/bs: 5025478 | jnthn++ | src/ (2 files):

[21:22] <dalek> nqp/bs: Base64 encode the serialized data; for one, we avoid a weird corruption issue with binary:'...' strings (so CORE.setting deserialization now completes), but also it's parsed by IMCC much faster than the binary string with a load of escapes.

[21:22] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5025478e58

[21:23] <jnthn> So...with that mess fixed, I've got the problem I expected to have at this point :)

[21:26] <masak> jnthn++

[21:28] <[Coke]> jnthn: what's that?

[21:30] <jnthn> The augment + bs fun. :)

[21:30] <jnthn> Basically, the setting augments the types in BOOTSTRAP, but the changes get lost.

[21:35] <dalek> nqp/bs: f626c29 | jnthn++ | src/6model/serialization. (2 files):

[21:35] <dalek> nqp/bs: Don't leak.

[21:35] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/f626c297bb

[21:35] <dalek> rakudo/bs: 50cfbcf | jnthn++ | src/binder/s (2 files):

[21:35] <dalek> rakudo/bs: Bump to latest 6model headers.

[21:35] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/50cfbcf49a

[21:35] <masak> "Don't leak", the latest romantic pop hit by robots, for robots.

[21:35] *** havenn left
[21:39] *** icwiener left
[21:40] <jnthn> :P

[21:41] *** dukeleto left
[21:41] *** dukeleto joined
[21:41] *** dukeleto left
[21:42] *** dukeleto joined
[21:42] *** dukeleto left
[21:42] *** dukeleto joined
[21:42] *** dukeleto left
[21:43] *** dukeleto joined
[21:43] *** dukeleto left
[21:43] *** dukeleto joined
[21:43] *** dukeleto left
[21:43] <masak> nom: augment class Str { method postcircumfix:<[ ]>($i) { self.substr($i, 1) } }; say "OH HAI"[4]

[21:44] <p6eval> nom 3ca6e5: OUTPUT«===SORRY!===␤augment not allowed without 'use MONKEY_TYPING'␤at /tmp/vzQXStVHBn:1␤»

[21:44] <masak> nom: use MONKEY_TYPING; augment class Str { method postcircumfix:<[ ]>($i) { self.substr($i, 1) } }; say "OH HAI"[4]

[21:44] <p6eval> nom 3ca6e5: OUTPUT«A␤»

[21:44] <masak> \o/

[21:44] <jnthn> ew :P

[21:44] *** dukeleto joined
[21:44] *** dukeleto left
[21:44] <masak> that's the cultural stigma talking :)

[21:44] <masak> it may be frowned upon, but it's possible...

[21:44] <masak> and easy.

[21:44] *** dukeleto joined
[21:44] *** dukeleto left
[21:45] <masak> granted, the .[] should be a bit smarter, and accept lists.

[21:45] <jnthn> If you implement at_pos instead, it will :P

[21:45] *** dukeleto joined
[21:45] *** dukeleto left
[21:45] <masak> nom: use MONKEY_TYPING; augment class Str { method at_pos($i) { self.substr($i, 1) } }; say "OH HAI"[4]

[21:45] <p6eval> nom 3ca6e5: OUTPUT«A␤»

[21:45] *** dukeleto joined
[21:45] <masak> nom: use MONKEY_TYPING; augment class Str { method at_pos($i) { self.substr($i, 1) } }; say "OH HAI"[1..4]

[21:46] <p6eval> nom 3ca6e5: OUTPUT«H   H A␤»

[21:46] *** dukeleto left
[21:46] <masak> niiice.

[21:46] <masak> nom: use MONKEY_TYPING; augment class Str { method at_pos($i) { self.substr($i, 1) } }; say "OH HAI"[1..4].perl

[21:46] <p6eval> nom 3ca6e5: OUTPUT«("H", " ", "H", "A")␤»

[21:46] *** dukeleto joined
[21:46] *** dukeleto left
[21:46] <masak> ...but that's maybe a case where lvalue substr being syntactical-only would feel inadequate.

[21:47] *** dukeleto joined
[21:47] *** dukeleto left
[21:47] *** dukeleto joined
[21:47] <dalek> rakudo/bs: 82818b3 | jnthn++ | src/Perl6/World.pm:

[21:47] <dalek> rakudo/bs: Toss dead line of code.

[21:47] <dalek> rakudo/bs: review: https://github.com/rakudo/rakudo/commit/82818b3344

[21:47] *** dukeleto left
[21:48] *** dukeleto joined
[21:48] *** dukeleto left
[21:48] *** dukeleto joined
[21:48] *** dukeleto left
[21:49] *** dukeleto joined
[21:49] *** dukeleto left
[21:49] *** dukeleto joined
[21:49] *** dukeleto left
[21:50] *** dukeleto joined
[21:50] *** dukeleto left
[21:50] <masak> dukeleto is the noisiest bot on the channel right now.

[21:50] *** dukeleto joined
[21:50] *** dukeleto left
[21:51] *** dukeleto joined
[21:51] *** dukeleto left
[21:51] *** dukeleto joined
[21:51] *** dukeleto left
[21:52] *** dukeleto joined
[21:52] *** dukeleto left
[21:52] <jnthn> Aye

[21:52] <jnthn> Guess one of us could find our op bit and quieten it :)

[21:52] *** dukeleto joined
[21:53] *** dukeleto left
[21:53] *** dukeleto joined
[21:53] *** dukeleto left
[21:53] *** ChanServ sets mode: +o masak

[21:54] *** dukeleto joined
[21:54] *** dukeleto left
[21:54] *** kmwallio left
[21:54] *** dukeleto joined
[21:54] *** dukeleto left
[21:55] *** dukeleto joined
[21:55] *** masak sets mode: +b dukeleto!leto@turkeyberry.sgn.cornell.edu

[21:55] *** dukeleto left
[21:55] <jnthn> masak++

[21:55] *** dukeleto joined
[21:55] *** dukeleto left
[21:55] <jnthn> oh, dang. :)

[21:55] *** ChanServ sets mode: -o masak

[21:55] <masak> oh noes :/

[21:56] *** ChanServ sets mode: +o masak

[21:56] *** dukeleto joined
[21:56] <masak> clearly I need to work on this.

[21:56] *** dukeleto left
[21:56] *** dukeleto joined
[21:56] *** dukeleto left
[21:57] *** dukeleto joined
[21:57] *** dukeleto left
[21:57] *** dukeleto joined
[21:57] *** dukeleto left
[21:58] *** dukeleto joined
[21:58] *** dukeleto was kicked by masak (dukeleto))
[21:58] *** dukeleto joined
[21:58] *** dukeleto left
[22:00] *** MayDaniel left
[22:00] <Trashlord> obviously

[22:00] <Trashlord> and we're all sure you'll do a great job

[22:00] *** masak sets mode: +b *!leto@turkeyberry.sgn.cornell.edu

[22:00] *** ChanServ sets mode: +o jnthn

[22:00] *** dukelet0 joined
[22:00] *** ChanServ sets mode: -o masak

[22:01] <masak> oh wtf

[22:01] *** dukelet0 is now known as dukeleto

[22:01] *** jnthn sets mode: +b *!*@turkeyberry.sgn.cornell.edu

[22:01] <masak> op #perl6 masak

[22:01] *** jnthn sets mode: -o jnthn

[22:01] <masak> er

[22:02] <masak> jnthn: now there are three bans registered for dukeleto.

[22:03] *** ChanServ sets mode: +o jnthn

[22:03] <Trashlord> heh

[22:03] <masak> if they're a scarce resource, probably the first two should be clean'd up.

[22:03] *** jnthn sets mode: -b dukeleto!leto@turkeyberry.sgn.cornell.edu

[22:03] <masak> honestly, I thought the second one would keep things like dukelet0 away.

[22:03] <Trashlord> I think the first ban didn't work because it's *!leto, not *!~leto

[22:03] <masak> oh!

[22:03] *** jnthn sets mode: -b *!leto@turkeyberry.sgn.cornell.edu

[22:03] <masak> Trashlord++

[22:03] *** jnthn sets mode: -o jnthn

[22:03] <Trashlord> er, the second one I mean, yes

[22:04] <masak> anyway, the leto bot is gone for now.

[22:04] <masak> it can re-apply for membership in an orderly fashion, if it wants :)

[22:05] * jnthn has all tomorrow for Perl 6 o/

[22:05] <jnthn> Wonder if I can get Rakudo passing most of them spectests again with the bs. :)

[22:06] <masak> sounds like a challenge :)

[22:06] <[Coke]> jnthn++

[22:06] <jnthn> Muchly depends how well the design I sketched out for handling the augment stuff falls into place.

[22:07] <jnthn> oh, guess I should do the * release tomorrow also

[22:10] *** skids left
[22:10] *** dukeleto left
[22:11] <masak> \o/

[22:13] * [Coke] wonders if he should mention anything about the new perl6 say spec on the conversation about the p5p say thread.

[22:13] <[Coke]> s/he/we/

[22:15] <masak> how does it apply to p5?

[22:15] <masak> perl6: print <a b c d>

[22:15] <p6eval> pugs b927740, rakudo 3ca6e5, niecza v14-97-gacd7da0: OUTPUT«abcd»

[22:15] <masak> perl6: say <a b c d>

[22:15] <p6eval> rakudo 3ca6e5, niecza v14-97-gacd7da0: OUTPUT«a b c d␤»

[22:15] <p6eval> ..pugs b927740: OUTPUT«abcd␤»

[22:16] <masak> I mean, Perl 5 doesn't even have a &gist routine, nor any plans to get one.

[22:16] *** att left
[22:19] <[Coke]> So won't they be surprised.

[22:19] <masak> good point.

[22:19] <masak> go for it.

[22:20] <masak> worst case, it's of no import to them.

[22:20] <masak> best case, they can use that knowledge for something.

[22:33] *** Araq joined
[22:34] <masak> Araq: greetings.

[22:34] <Araq> hi masak 

[22:35] <masak> welcome to our humble adobe :)

[22:35] <Araq> there's 194 people in here and yet I'm greeted. nice :-)

[22:35] *** kaare_ left
[22:36] <masak> Araq: we're mostly on a first-name basis here... :)

[22:36] <masak> big village.

[22:37] <Araq> so what's the status of perl6?

[22:38] <masak> alive and kicking, and stronger than ever! :)

[22:38] <masak> nom: say "Perl 6 greets you too, Araq :)"

[22:38] <p6eval> nom 3ca6e5: OUTPUT«Perl 6 greets you too, Araq :)␤»

[22:39] <Araq> spec and implementation finished?

[22:39] <masak> nom: .say for 1, 2, 4 ... 256

[22:39] <p6eval> nom 3ca6e5: OUTPUT«1␤2␤4␤8␤16␤32␤64␤128␤256␤»

[22:39] <masak> Araq: spec still being twiddled, but large parts of it are very stable.

[22:39] <Araq> nom: .say 2, 4 ...

[22:39] <p6eval> nom 3ca6e5: OUTPUT«===SORRY!===␤Confused␤at /tmp/Bzepz_HdM_:1␤»

[22:40] <masak> no need for the dot in '.say' there.

[22:40] <masak> or do '.say for'

[22:40] <jnthn> nom: .say 2, 4 ... *

[22:40] <p6eval> nom 3ca6e5: OUTPUT«===SORRY!===␤Confused␤at /tmp/lBuIkboitj:1␤»

[22:40] <jnthn> gah

[22:40] <masak> also, you need a '*' at the end if you want to go forever.

[22:40] <jnthn> nom: .say for 2, 4 ... *

[22:40] <masak> or an 'Inf'

[22:40] <jnthn> though that's kinda infinite... :)

[22:40] <p6eval> nom 3ca6e5: OUTPUT«(timeout)2␤4␤6␤8␤10␤12␤14␤16␤18␤20␤22␤24␤26␤28␤30␤32␤34␤36␤38␤40␤42␤44␤46␤48␤50␤52␤54␤56␤58␤60␤62␤64␤66␤68␤70␤72␤74␤76␤78␤80␤82␤84␤86␤88␤90␤92␤94␤96␤98␤100␤102␤104␤106␤108␤110␤112␤114␤116␤118␤120␤122␤124␤126␤128␤130␤132␤134␤136␤138␤140␤142␤144␤146␤148␤150␤15

[22:40] <masak> hah, you got the arithmetic sequence :)

[22:40] <masak> that will never get all the way to infinity :P

[22:41] <Araq> how does that work? it's ambigous

[22:41] <benabik> Two numbers are assumed to be an arithmetic sequence, I think

[22:41] <colomon> benabik has right

[22:41] <benabik> Three get examined for arithmetic or geometric.

[22:41] <masak> Araq: it tries to fit things into an arithmetic sequence, otherwise a geometric one.

[22:41] <masak> if both of those fail, it fails.

[22:42] <benabik> nom: .say for 2, -3, 55 ... *

[22:42] <p6eval> nom 3ca6e5: OUTPUT«2␤-3␤55␤Failure.new(exception => X::AdHoc.new(payload => "unable to deduce sequence"))␤»

[22:42] <colomon> nom: .say for 1, 2, 5 ... * > 100

[22:42] <p6eval> nom 3ca6e5: OUTPUT«1␤2␤5␤Failure.new(exception => X::AdHoc.new(payload => "unable to deduce sequence"))␤»

[22:42] <masak> nom: .say for (2, -4, 8 ... *)[^20]

[22:42] <p6eval> nom 3ca6e5: OUTPUT«2␤-4␤8␤-16␤32␤-64␤128␤-256␤512␤-1024␤2048␤-4096␤8192␤-16384␤32768␤-65536␤131072␤-262144␤524288␤-1048576␤»

[22:42] <masak> \o/

[22:42] <Araq> it could pretend there's underlying polynomial and extrapolate it

[22:42] <masak> haha

[22:43] <masak> Araq: you're not the first one to suggest it :)

[22:43] <masak> we're crazy, but not that crazy.

[22:43] <Araq> how does multiple dispatch work in perl6?

[22:43] <Araq> is it type or value based?

[22:44] <benabik> yes

[22:44] <jnthn> Type based first, then value-based for tie-breaking.

[22:44] <Araq> are there disambiguation rules? or do trigger ambiguities an exception= 

[22:44] <Araq> ?

[22:45] <jnthn> If it's ambiguous you'll get an exception.

[22:45] <jnthn> I mean, there are rules.

[22:45] <benabik> nom: multi f(int $) { say "int" }; multi f(0) { say 0 }; multi f($) { say "anything"}; f("foo"); f(0); f(1); f(0.5)

[22:45] <p6eval> nom 3ca6e5: OUTPUT«anything␤int␤int␤anything␤»

[22:45] <masak> nom: multi foo($x) { say "amb" }; multi foo($x) { say "iguous" }; foo(42)

[22:45] <p6eval> nom 3ca6e5: OUTPUT«Ambiguous dispatch to multi 'foo'. Ambiguous candidates had signatures:␤:(Any $x)␤:(Any $x)␤␤  in block <anon> at /tmp/bKE2are5WV:1␤␤»

[22:46] <jnthn> But we don't try and disambiguate everything.

[22:46] <benabik> jnthn: Why didn't I get the 0 case?  ^^  Int v int?

[22:46] <jnthn> benabik: Correct.

[22:46] <TimToady> constraints are evaluated in order

[22:46] <jnthn> benabik: Native types always match narrower.

[22:46] <jnthn> At the type level, not at the constraint level.

[22:46] <benabik> nom: multi f(Int $) { say "Int" }; multi f(0) { say 0 }; f(0); f(1)

[22:46] <p6eval> nom 3ca6e5: OUTPUT«0␤Int␤»

[22:46] <jnthn> It may well have even resolved that one at compile time.

[22:46] <masak> Araq: it tries to figure out which candidates are more specific than others. if it tried everything and there are still > 1 candidate left, that's ambiguous.

[22:47] <benabik> Odd that int is "narrower" than 0.  *shrug*

[22:47] <TimToady> or if theres a circularity or contradiction in the types

[22:47] <jnthn> benabik: Yeah, maybe we should inference it as int instead of Int.

[22:47] <jnthn> Or...hmm, that has issues too :)

[22:47] <masak> TimToady: yes, but that's covered by the "> 1 candidate left" case.

[22:48] <Araq> what's perl 6's take on concurrency?

[22:48] <jnthn> There are ways to get circularities without constraints.

[22:48] <jnthn> But probably not with the default type system.

[22:48] <masak> Araq: Perl 6 is all for it.

[22:49] <masak> Araq: details pending, because no-one has picked up the torch for that one yet, really.

[22:49] <TimToady> mostly we try to express any inherent parallelism syntactically, and then let the computer figure out how

[22:49] <masak> not since the Pugs days, anyway.

[22:49] <TimToady> but various forms of concurrency are expressed naturally: hyperoperators, ffeeds

[22:49] <masak> form feeds are concurrent? :P

[22:50] <masak> this explains a lot of my printer trouble lately.

[22:50] <TimToady> even lazy lists can be done concurrently

[22:50] <benabik> jnthn: Is there a way to differentiate between Int and int literals?

[22:51] <masak> 'night, #perl6

[22:51] <TimToady> we try to keep our literals as allomorphic as possible

[22:51] <jnthn> benabik: No, they...what TimToady said

[22:51] <jnthn> I suspect we have some details on that allomorphy to work out yet, though.

[22:51] <jnthn> Well, I have, even if TimToady++ has it all worked out. :)

[22:52] <TimToady> er...maybe subconsciously... :)

[22:54] <fsergot> good night #perl6 o/

[22:55] <jnthn> 'night, fsergot 

[22:55] <colomon> \o

[22:57] <Araq> which implementation is the most advanced? rakudo?

[22:58] <TimToady> they all have their strong points and weak points

[22:59] <Araq> like?

[22:59] <TimToady> see http://perl6.org/compilers/features

[22:59] <TimToady> and niecza is on average considerably faster than rakudo at this point

[23:00] <TimToady> rakudo is stronger on its MOP, niecza is stronger in its parser (in the feature sense)

[23:01] <TimToady> they both pass about the same number of spec tests at this point

[23:01] <Araq> rakudo is based on parrot, right?

[23:02] <TimToady> yes

[23:02] <TimToady> at the moment

[23:02] <TimToady> but is designed to be retargetable someday

[23:02] <TimToady> niecza is on mono/.NET

[23:03] <Araq> are there any language features that are *not* in perl6? :-)

[23:03] <TimToady> sure

[23:03] <TimToady> indentation for syntax; optional semicolons :)

[23:04] <TimToady> we don't do currying in the strict sense, though partial application is fine

[23:04] <TimToady> where currying strictly means all functions are really of one argument as they are in Haskell

[23:05] <TimToady> (many people misuse "currying" to mean partial application)

[23:05] <TimToady> there are many, many stupid features that we haven't borrowed from other languages too

[23:06] <TimToady> like multi-pass parsing

[23:06] <Araq> really?

[23:06] <Araq> how should syntax macros work otherwise?

[23:06] <TimToady> hygienically

[23:07] <TimToady> you can do multi-pass parsing if you force it, there's always text macros and eval and such

[23:07] *** mj41 left
[23:08] <TimToady> but that falls under the category of knowing you're programming in two different languages at the same time

[23:08] <TimToady> intentional generic code is okay, but generally we want to know exactly which language the parser is in at any moment

[23:09] <TimToady> so we don't borrow two-pass solutions like P5's source filters

[23:09] <TimToady> which are not very composable

[23:11] <TimToady> a good site for comparing programming langauges is rosettacode.org; Perl 6 usually comes off looking pretty good there

[23:12] <TimToady> Araq: what languages are you familiar with already?

[23:12] <Araq> I hope pretty much all of them :-)

[23:13] <TimToady> ooh, a dilettante/1

[23:13] <TimToady> *!

[23:14] <TimToady> in that case, you should definitely see rosettacode.org

[23:14] <Araq> thanks you made my day :D

[23:14] <TimToady> unless, of course, that's what brought you here in the first place...

[23:16] <Araq> strictly speaking if you allow for user defined operator precedence, you have to do multi pass parsing already

[23:17] <Araq> ok, not if you keep a symbol table for parsing

[23:18] <TimToady> well, basically, that's why we enforce one-pass parsing, so that you can know whether you're in the language with the new operator or not

[23:19] <TimToady> in the extreme view, every declaration of a new name changes the language a bit

[23:19] <jnthn> Time for some sleep &

[23:19] <TimToady> o/

[23:21] <Araq> so if I introduce a new operator like ??! and give it precedence

[23:21] <Araq> and then use it after definition

[23:21] <TimToady> it will automatically be parsed correctly by the operator precedence parser

[23:22] <TimToady> the P6 parser is a layer cake of top-down and bottom-up

[23:22] <Araq> so you keep a symbol table for parsing?

[23:22] <Araq> so that you can look up ??!'s definition?

[23:22] <Araq> and precedence

[23:22] <TimToady> we keep an entire new grammar and lexer if you do something like a new operator

[23:22] <TimToady> derived from the old one

[23:23] <TimToady> grammars are just classes with funny methods that look like regexes

[23:23] <Araq> alright, how does the parser know when to invoke which grammar?

[23:23] *** kmwallio joined
[23:23] <Araq> oh I see. There is a notion of a "current" grammar I suppose

[23:23] <TimToady> the parser passes aroudn Cursor objects that reflect the current grammar and state of the parse

[23:24] <TimToady> and with lazy lists of cursors, you get backtracking for free

[23:24] <TimToady> well, for "free" :)

[23:24] <Araq> hm

[23:25] <TimToady> backtracking is merely throwing away this cursor and continuing with the next one on the lazy list

[23:25] <colomon> niecza: sub infix:<??!>($a, $b) is equiv<*> { $a * $b * 2 }; say 1 + 3 ??! 5

[23:25] <p6eval> niecza v14-97-gacd7da0: OUTPUT«31␤»

[23:25] <colomon> niecza: sub infix:<??!>($a, $b) is equiv<+> { $a * $b * 2 }; say 1 + 3 ??! 5

[23:25] <p6eval> niecza v14-97-gacd7da0: OUTPUT«40␤»

[23:25] <Araq> I don't get it. Why a lazy list and no stack?

[23:26] <TimToady> you can't unpop a stack without continuations

[23:26] <TimToady> if you want to backtrack into a subrule, you need a way to do that

[23:26] <TimToady> colomon: that equiv<> syntax looks weird to me

[23:27] <TimToady> oh, I guess it's still just a pair in disguise

[23:27] <Araq> what's an 'unpop' operation? a 'push'?

[23:28] <TimToady> only if you can manage to push back whatever was popped off and thrown away!

[23:28] <colomon> TimToady: just copying the syntax I found in a quick grep of the niecza source.  :)

[23:28] <TimToady> colomon: sorry, just woke from nap and am still groggy

[23:28] <colomon> niecza: sub infix:<??!>($a, $b) is equiv(&infix:<+>) { $a * $b * 2 }; say 1 + 3 ??! 5

[23:28] <p6eval> niecza v14-97-gacd7da0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Bogus term at /tmp/9RAbq7nbU6 line 1:␤------> [32miv(&infix:<+>) { $a * $b * 2 }; say 1 + [33m⏏[31m3 ??! 5[0m␤␤Parse failed␤␤»

[23:28] <TimToady> Araq: note that the precedence levels are all relative, and you can insert an infinite number of new precedence levels

[23:29] <colomon> TimToady: no worries

[23:30] <Araq> so you don't pop a grammar at the end of the module that introduced it

[23:30] <TimToady> well, the top-level precedence levels are absolute, but the user never worries about those

[23:30] <Araq> so because you never pop, it's a list and no stack

[23:31] <TimToady> if you throw away the last lazy element that references the grammar, sure

[23:31] <TimToady> and leaving a block does that sort of thing

[23:31] <Araq> I still don't get the 'lazy' part so I'm ignoring that for now

[23:32] <Araq> so ... hm

[23:32] <TimToady> low level, it means you can match / x*? y / as few times as possible without actually finding all the x's first

[23:33] <TimToady> high-level, it means you can deal with infinite lists

[23:33] <Araq> any pseudo-code for how the parser works?

[23:33] <TimToady> perl6: say (0, 1, *+* ... *)[100]

[23:33] <p6eval> rakudo 3ca6e5, niecza v14-97-gacd7da0: OUTPUT«354224848179261915075␤»

[23:33] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "["␤    at /tmp/Er2wHKHDes line 1, column 22␤»

[23:33] <TimToady> 100th fibonacci

[23:34] <TimToady> why pseudocode? the real code is in Perl 6...

[23:35] <TimToady> or do you mean the cursor stuff?

[23:35] <Araq> link?

[23:35] <Araq> and well I mean the cursor stuff and the parser

[23:36] <Araq> I guess; not sure since I don't understand yet how it works

[23:36] <TimToady> do you have any of these installed yet?

[23:36] <Araq> is there any classical lexer/parser distinction at all?

[23:36] <TimToady> yes and now

[23:36] <TimToady> *no

[23:36] <TimToady> you write the parser, and the lexer is automatically derived from it for you

[23:37] <TimToady> you have some control over that in how you write the parser

[23:37] <TimToady> you can tell it where to stop attempting longest token matching, for instance

[23:38] <Araq> I suppose the grammars are neither LL(k) nor LR(k) nor LAIR or whatever

[23:38] <Araq> is it based on PEGs?

[23:39] <TimToady> yes, PEGs is probably the closest concept

[23:39] <Araq> do you allow for left recursion?

[23:40] <TimToady> outside of that, LL is pretty close, but we don't generally have to worry about left recursion because the bottom up EXPR rule tends to get invoked somewhere in the middle layer

[23:40] *** whiteknight joined
[23:40] <Araq> how can the EXPR rule be bottom up?

[23:40] <TimToady> you can write a left recursion, and it won't blow up the LTM (longest token matcher), but you better have something in place to decide how to get out of the recursion

[23:41] <TimToady> it's an operator precedence parser

[23:41] <Araq> so EXPR does not use the same matching algorithms?

[23:41] <TimToady> at least in the standard language it is; one could substitute something stronger, but generally only at the risk of befuddling the users

[23:42] <Araq> is EXPR hardcoded then?

[23:42] <TimToady> EXPR calls back down into the top-down rules to find terms and infixes

[23:42] <TimToady> it's just a method, as are all the rules in the grammar

[23:42] *** snearch left
[23:43] <Araq> I see

[23:43] <TimToady> https://github.com/perl6/std/blob/master/STD.pm6 is the standard parser that everyone is aiming towards

[23:43] <TimToady> niecza follows it more closely than rakudo at this point

[23:44] <TimToady> just search down for 'method EXPR' if you want to see the opp

[23:45] <Araq> thanks, found it

[23:45] <TimToady> it's not a trivial parser, insofar as it handles strange forms of associativity

[23:46] <Araq> how is parsing speed with this approach?

[23:46] <TimToady> you'll want to consult the precedence table in S03

[23:46] <TimToady> not blazing fast yet, but gives much better error messages than your typical LALR

[23:47] <TimToady> there's still plenty of room for optimization, I think

[23:47] <TimToady> but we're concentrating on correctness first

[23:48] *** skids joined
[23:51] *** kmwallio left
[23:51] <Araq> what's the obsession with <> styled brackets? :-)

[23:51] <Araq> <.sorry: "..." >

[23:51] <TimToady> well, that's the extension syntax for assertions in P6 regexes

[23:52] <TimToady> that particular syntax is just a method call

[23:52] <TimToady> if you're familiar with Perl 5 regexes; Perl 6 regexes are a radical rethink

[23:52] <TimToady> S05 describes the differences

[23:53] <TimToady> you'll also see <foo> used a lot as literal hash subscripts because the standard parser is written on top of a Perl 5 engine, so objects tend to be hashes

[23:54] <TimToady> those will change to .foo accessors as we move more to an opaque object model

[23:55] <TimToady> (and is one of those optimizations I mentioned)

[23:56] *** am0c joined
[23:58] <sorear> good * #perl6

[23:58] <TimToady> sorear: Araq++ here seems to be a kindred spirit; he's asking all sorts of interesting questions :)

[23:59] <TimToady> er, ey is :)

