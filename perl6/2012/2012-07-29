[00:04] *** takadonet joined
[00:15] *** tokuhiro_ joined
[00:19] *** thelazydeveloper left
[00:30] *** benabik left
[00:30] *** benabik joined
[00:32] *** adu joined
[00:33] *** adu left
[00:42] *** gongyiliao joined
[01:02] *** Chillance left
[01:23] *** Coleoid joined
[01:49] *** drbean left
[01:50] *** drbean joined
[01:51] *** Transformer joined
[01:51] *** Transformer left
[02:05] *** orafu left
[02:06] *** echo__ joined
[02:07] *** dbr left
[02:07] *** orafu joined
[02:08] *** echo__ left
[02:26] *** cognominal left
[02:28] *** benabik left
[02:39] *** Patterner left
[02:40] *** benabik joined
[02:40] <skids> r: role E [ $g = "foo" ] { method h ($g = $OUTER::g) { $g.say } }; class D does E { }; my D $d .= new(); $d.h; # how to do this without renaming one of the $g's ?

[02:40] <p6eval> rakudo 843534: OUTPUT«Nominal type check failed for parameter '$g'; expected Any but got Mu instead␤  in method h at /tmp/u2Pvb_didm:1␤  in block  at /tmp/u2Pvb_didm:1␤␤»

[02:41] *** Psyche^ joined
[02:41] *** Psyche^ is now known as Patterner

[02:42] <skids> ...and what is the lexical "scope" of runtime parameter binding considered to be, that of inside the Callable?

[02:44] <moritz> yes

[02:44] <moritz> well, starting from its declaration to the end of the block

[02:44] <moritz> you can say   sub f($x, $y = $x * 2 ) {  ... }

[02:44] <moritz> so $x is actually visible in the rest of the parameter list too

[02:46] <moritz> but you can't assign to $g in your example above

[02:46] <moritz> oh wait, I'm not fully awake

[02:46] <moritz> I think $OUTER::g should work

[02:46] <diakopter> moritz: ur up very late or very early

[02:47] <moritz> diakopter: yes. I'll try to sleep again :-)

[02:57] *** xinming_ joined
[03:00] *** xinming left
[03:03] *** soooga joined
[03:04] *** soooga left
[03:06] *** soooga joined
[03:34] <skids> moritz++ thanks.  It would suck for cascading default values to need different names.

[03:51] <TimToady> http://rosettacode.org/wiki/Sorting_algorithms/Radix_sort#Perl_6

[03:54] *** kaare_ joined
[04:01] *** birdwindupbird joined
[04:06] *** birdwind1pbird joined
[04:08] *** birdwindupbird left
[04:10] *** kaxing left
[04:10] <quietfanatic> Instead of: my @buckets = @list.classify( *.substr($r,1) ).sort: *.key;

[04:11] <quietfanatic> why don't you say: my @buckets; @list.classify( *.substr($r,1) ).map: {@buckets[.key] = $_ }

[04:11] *** kaxing joined
[04:12] <quietfanatic> oh wait, you can't map a hash, can you

[04:12] <quietfanatic> .pairs.map then.

[04:12] <quietfanatic> but whatever

[04:13] <quietfanatic> or just @list.map: { @buckets[.substr($r, 1)] = $_ }

[04:13] <quietfanatic> or thereabouts

[04:14] <TimToady> doesn't work for the '-' bucket

[04:15] <quietfanatic> @list.map: { my $i = .substr($r, 1); @buckets[$i] = $i => $_ }

[04:22] *** telex left
[04:29] *** dalek left
[04:30] *** telex joined
[04:30] *** dalek joined
[04:30] *** ChanServ sets mode: +v dalek

[04:30] *** p6eval left
[04:30] *** Util_ left
[04:31] *** Util joined
[04:31] *** masak left
[04:31] *** dalek left
[04:32] *** Juerd left
[04:32] *** tadzik left
[04:33] *** dalek joined
[04:33] *** ChanServ sets mode: +v dalek

[04:33] *** Juerd joined
[04:34] *** p6eval joined
[04:34] *** ChanServ sets mode: +v p6eval

[04:35] *** Util left
[04:36] *** Util joined
[04:37] *** masak joined
[04:46] *** crab2313 joined
[04:49] *** UncleFester6 left
[04:59] *** crab2313 left
[05:26] <TimToady> rpn: sub foo (&infix:<op>, $a, $b) { say $a op $b }; foo &[*], 42, 7;

[05:26] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "op"␤    expecting operator, ":", "," or "}"␤    at /tmp/sfoybqgtL9 line 1, column 40␤»

[05:26] <p6eval> ..rakudo 843534: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2, near "say $a op "␤»

[05:26] <p6eval> ..niecza v19-15-g051783d: OUTPUT«294␤»

[05:26] <TimToady> rpn: sub foo (&infix:<op>, $a, $b) { say $a op $b }; foo &[/], 42, 7;

[05:26] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "op"␤    expecting operator, ":", "," or "}"␤    at /tmp/k4bR28KwsJ line 1, column 40␤»

[05:26] <p6eval> ..niecza v19-15-g051783d: OUTPUT«6␤»

[05:26] <p6eval> ..rakudo 843534: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2, near "say $a op "␤»

[05:26] <TimToady> coulda sworn binding to &infix:<op> worked already in rakudo

[05:27] *** betterworld left
[05:27] *** araujo left
[05:35] *** kaxing left
[05:36] <TimToady> anyway, http://rosettacode.org/wiki/Parsing/RPN_calculator_algorithm#Perl_6 only works with niecza

[05:37] *** raiph joined
[05:43] <raiph> is Boyer-Moore relevant to a regex implementation?

[05:43] <raiph> http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm

[05:43] <raiph> relevant to P6's regex engine?

[05:44] <raiph> s/P6's/a P6/

[05:45] <Timbus> well, yeah. im pretty sure perl 5 uses that

[05:46] <Timbus> you can use it to find initial matches and stuff

[05:49] * geekosaur remebers when ilyaz hooked BM into the perl5 regex engine

[05:50] *** betterworld joined
[05:50] <raiph> Timbus, geekosaur: thx

[05:51] <raiph> (now looking at ilyaz + bm + perl google)

[05:52] <geekosaur> hm now I wonder if that predated perl5 even.  been a long time ;}

[05:53] *** risou_ left
[05:54] <raiph> i recall reading about bm in the 80s. i think it was in an issue of scientific american.

[05:54] *** jimmy1980 joined
[05:55] <geekosaur> also "ilyaz" may not be appropriate for a google search because that was his cpan id but not necessarily mentioned in his email.  full name:  Ilya Zakharevich

[05:55] <geekosaur> (hah, remembered it correctly without needing to google...)

[05:57] <raiph> geekosaur: memory's interesting. i haven't had reason to recall bm in over a decade, but thought to myself "boyer", i recall "boyer"...

[05:58] <geekosaur> boyer-moore I remember, don't have to think about it much but it still comes up occasionally

[05:59] <raiph> "string matching algorithms that are more efficient than DFA's (like Fast Boyer Moore) can be utilized [and then] the real engine used to verify that the match is valid. In many cases this can result in much faster match times than a DFA can provide, even when the verifier is an NFA with backtracking. "

[06:00] <raiph> (from http://www.perlmonks.org/?node_id=597262)

[06:07] <geekosaur> interesting thing is, that's how BM was being used originally... although later developments probably complicated that a bit

[06:10] <geekosaur> and as pointed out later in that thread, in fact still does ;}

[06:11] <TimToady> um, I put BM into the regex engine

[06:12] <TimToady> Ilya may have improved it, of course

[06:30] <TimToady> look for fbminstr in 4.036, for instance

[06:44] *** tadzik joined
[06:49] <TimToady> http://rosettacode.org/wiki/Remove_lines_from_a_file#Perl_6

[06:49] *** JimmyZ joined
[06:54] <JimmyZ> r: say ( 600 - 490 ) / 600 * 100 , '%'

[06:54] <p6eval> rakudo 843534: OUTPUT«18.333333%␤»

[06:56] <JimmyZ> memory down to 490M in pirt branch

[06:58] *** GlitchMr joined
[07:02] *** ranguard_ left
[07:02] *** ranguard joined
[07:09] <TimToady> geekosaur: actually, now that I check, I had already added fbminstr in Perl 2.0

[07:18] <raiph> TimToady++ # rosettacode

[07:19] <geekosaur> TimToady, I know some form of it was there early, but Ilya did some work to integrate it better into regexen at one point.  on the warpath over people using index() instead of regex matching because it was faster...

[07:20] <TimToady> I put it in to find the initial match positions; iirc Ilya extended it to be able to look for the first thing after a .*?

[07:22] <TimToady> since .*? is a lot like the initial scan that a regex does

[07:23] <TimToady> don't want to take away from all the tweaking that Ilya did do, of course

[07:24] <geekosaur> yeh, but that tweaking is the main thing I remember boyer-moore for with respect to perl

[07:24] <geekosaur> think there was a big bikeshed over it too for some silly reason

[07:24] <raiph> TimToady: does a similar approach apply to P6 regex declarative prefixes or whatever you call the fixed bits?

[07:26] <TimToady> geekosaur: the bikeshed was, I think, because it was a lot of work for diminishing returns, and it was data-dependent

[07:27] <TimToady> filtering the initial match positions through fbm was already getting most of the benefit for most regexes

[07:28] <TimToady> raiph: well, it could, for matches that scan, but grammars generally don't scan, but match right were the previous thing left off

[07:29] <TimToady> certainly the engine tracks literal prefixes, so such an optimization be beneficial in some cases

[07:30] <TimToady> though the optimization tends to work well only for longer constant strings

[07:30] <TimToady> especially with the cache characteristics of modern CPUs, which will tend to have the next few characters handy

[07:32] <TimToady> of course, some of the bikeshedding back then on p5p was just personality conflicts too...

[07:36] <TimToady> raiph: but to answer your question, bm only applies to fixed strings, which is going to be a subset of declarative prefixes, which include anything you can write a DFA for

[07:37] <geekosaur> yes, yes it was.  I think that incident was a large part of why I bailed from p5p

[07:39] <TimToady> ooh, when did it suddenly become tomorrow?

[07:39] * TimToady starts to wander off toward bed

[07:40] <geekosaur> been tomorrow here for a while, my body is just being annoying

[07:40] <geekosaur> (so still up as 0400 approaches)

[07:43] *** crab2313 joined
[07:54] *** adu joined
[07:55] *** fgomez left
[08:03] *** SamuraiJack joined
[08:34] *** sergot joined
[08:34] <sergot> hi o/

[08:34] *** huf left
[08:42] *** crab2313 left
[08:42] *** NABUCFR joined
[08:58] *** sftp left
[09:00] *** sftp joined
[09:02] *** MayDaniel joined
[09:05] *** UncleFester6 joined
[09:10] *** raiph left
[09:13] *** pmurias joined
[09:13] <pmurias> what does QAST::Want do?

[09:24] <masak> pmurias: it handles coercion. see the three usages in src/QAST/Compiler.nqp

[09:24] <masak> (morning, #perl6)

[09:30] <pmurias> masak: hi

[09:31] <pmurias> masak: QAST::WVal contains a perl6 land value?

[09:31] <pmurias> can I extract the Int from a QAST::WVal in nqp land?

[09:33] <jnthn> .value gets the object itself

[09:33] <jnthn> It's a bit more sutble than "a perl6 land value" - QAST::WVal is for objects that are in the serialization context for the compilation unit.

[09:34] <jnthn> The right way in QAST to ask about stuff with known compile time values is that you can call .has_compile_time_value on any node, and the if that gives you back something true, you may call .compile_time_value to get hold of it.

[09:34] <JimmyZ> jnthn: memory use from 600M down to 490M in pirt branch, fyi

[09:34] <jnthn> Nice!

[09:34] <JimmyZ> jnthn++ 

[09:35] <JimmyZ> r: say ( 600 - 490 ) / 600 * 100 , '%' # 

[09:35] <p6eval> rakudo 843534: OUTPUT«18.333333%␤»

[09:37] <masak> brilliant! we should have thought of eliminating PCT compilation phases much earlier. :P

[09:41] <jnthn> masak: Sure, but which things would you have done later? :P

[09:44] <JimmyZ> so, pct will be give up eventually?

[09:44] <masak> PCT is alive and kicking, as far as I know.

[09:50] <dalek> perl6.org: a165385 | GlitchMr++ | source/archive/rfc/230.html:

[09:50] <dalek> perl6.org: Readd HTML version of RFC 230

[09:50] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/a1653850bf

[09:51] *** huf joined
[09:51] <GlitchMr> Somehow I wonder why it didn't existed before

[09:52] *** daniel-s left
[09:52] *** araujo joined
[09:52] *** araujo left
[09:52] *** araujo joined
[10:06] *** birdwind1pbird left
[10:13] <GlitchMr> perl6: 'abc'.chop.print

[10:13] <p6eval> rakudo 843534, niecza v19-15-g051783d: OUTPUT«ab»

[10:14] *** rcmalleb joined
[10:14] <arnsholt> I get a failure in t/spec/S16-filehandles/filestat.t with a pretty recent rakudo. Is that expected?

[10:14] <arnsholt> not ok 8 - IO.accessed should be updated when contents of file is read

[10:15] <GlitchMr> ok 8 - IO.accessed should be updated when contents of file is read

[10:16] <GlitchMr> Probably not

[10:17] <jnthn> arnsholt: I've heard @other report issues in that file. It seems platform specific.

[10:17] <arnsholt> Right. I'm on RedHat Linux

[10:17] *** JimmyZ left
[10:17] <GlitchMr> I'm at a4b8ad8cf33e3954b22f5221685e8423de77e303... but I don't think that revision exists (it's Rakudo + working run() function)

[10:18] <arnsholt> I also have two passing TODOs in S02-types/type.rakudo but that's because of my patch =D

[10:18] <GlitchMr> I'll download newest version to check, ok?

[10:18] <dalek> rakudo/nom: 2652a19 | (Arne Skjærholt)++ | src/Perl6/Actions.pm:

[10:18] <dalek> rakudo/nom: Keep track of return type info in --> signature syntax.

[10:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2652a19f1a

[10:18] <dalek> rakudo/nom: 3ec91e5 | (Arne Skjærholt)++ | src/Perl6/Actions.pm:

[10:18] <dalek> rakudo/nom: Make create_signature_object take a signature info hash instead of param list.

[10:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3ec91e54f4

[10:18] <dalek> rakudo/nom: 82c4cb1 | (Arne Skjærholt)++ | src/Perl6/ (2 files):

[10:18] <dalek> rakudo/nom: Pass signature info hashes to World.create_signature.

[10:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/82c4cb141e

[10:18] <dalek> rakudo/nom: 161ab28 | (Arne Skjærholt)++ | src/Perl6/World.pm:

[10:18] <dalek> rakudo/nom: Actually use signature info in World.create_signature.

[10:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/161ab288f2

[10:18] <dalek> rakudo/nom: 8cce367 | (Arne Skjærholt)++ | / (33 files):

[10:18] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[10:18] <dalek> rakudo/nom: 

[10:18] <dalek> rakudo/nom: Conflicts:

[10:18] <dalek> rakudo/nom: 	src/Perl6/Actions.pm

[10:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8cce367021

[10:19] <dalek> rakudo/nom: a251275 | (Arne Skjærholt)++ | / (3 files):

[10:19] <dalek> rakudo/nom: Merge branch 'nom' of github.com:rakudo/rakudo into nom

[10:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a2512754cc

[10:19] <GlitchMr> what?

[10:19] *** daniel-s joined
[10:19] <arnsholt> Oh, I pushed anyways =)

[10:19] <jnthn> arnsholt++

[10:19] <arnsholt> Didn't see your question 'till after

[10:21] <GlitchMr> That is long log...

[10:21] *** adu left
[10:26] <frettled> 5

[10:28] *** spider-mario joined
[10:28] <jnthn> r: say chr(120)

[10:28] <p6eval> rakudo 843534: OUTPUT«x␤»

[10:29] <jnthn> r: say chr(95)

[10:29] <p6eval> rakudo 843534: OUTPUT«_␤»

[10:30] <dalek> roast: ac096e5 | (Arne Skjærholt)++ | S02-types/type.t:

[10:30] <dalek> roast: Rakudo unfudge.

[10:30] <dalek> roast: review: https://github.com/perl6/roast/commit/ac096e50aa

[10:36] <arnsholt> jnthn: The Zavolaj test suite errors out with "elements() not implemented in class 'Parcel'" all of a sudden. Sound familiar?

[10:37] <jnthn> arnsholt: Not particularly.

[10:37] <jnthn> Sounds like something that wants to be an RPA is getting turned into a Perl 6 type at some point...but I couldn't guess where.

[10:38] <arnsholt> Oh, hang on. I might have the wrong NQP for my branch

[10:39] <arnsholt> Yeah, I think that might be it

[10:40] <arnsholt> Incidentally, I think this is my longest yak shave so far

[10:40] <arnsholt> As well as my first proper dig into Rakudo's internals

[10:41] <jnthn> And you survived the experience! \o/

[10:41] <arnsholt> Indeed ^_^

[10:42] <arnsholt> I have to admit after I was done with the Rakudo hack I did have to stop for a second to execute the context switch back to what I was actually doing =D

[10:43] *** birdwindupbird joined
[10:45] *** jlaire left
[10:45] <dalek> nqp/pirt: 302b444 | jnthn++ | src/QAST/PIRT.nqp:

[10:45] <dalek> nqp/pirt: Save some work (and potentially memory) during the final string concatenation.

[10:45] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/302b444fa3

[10:45] <dalek> nqp/pirt: 570712c | jnthn++ | src/QRegex/NFA.nqp:

[10:45] <dalek> nqp/pirt: Fix thinko in NFA building, which unbusts 2 out of the 3 failing S05 tests with PIRT.

[10:45] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/570712c71b

[10:46] <dalek> rakudo/pirt: eea3e60 | jnthn++ | src/Perl6/Actions.pm:

[10:46] <dalek> rakudo/pirt: Remove a hack we no longer need, fixing one of the other regressions.

[10:46] <dalek> rakudo/pirt: review: https://github.com/rakudo/rakudo/commit/eea3e60c9a

[10:47] *** jlaire joined
[10:47] *** thelazydeveloper joined
[10:54] *** birdwindupbird left
[10:55] <moritz> r: sub f(&x:(--> Int)) { }; f -> --> Int { }

[10:55] <p6eval> rakudo 843534: OUTPUT«===SORRY!===␤invoke() not implemented in class 'QAST::WVal'␤»

[10:56] <moritz> r: sub f(&x:(--> Int)) { }; 

[10:56] <p6eval> rakudo 843534: OUTPUT«===SORRY!===␤invoke() not implemented in class 'QAST::WVal'␤»

[10:56] <moritz> r: sub f(&x:(Str --> Int)) { }; 

[10:56] <p6eval> rakudo 843534: OUTPUT«===SORRY!===␤invoke() not implemented in class 'QAST::WVal'␤»

[10:57] <moritz> r: sub f(--> Int) { 'str' }; f

[10:57] <p6eval> rakudo 843534:  ( no output )

[10:57] <moritz> oh, rakudo is still too old

[10:58] <jnthn> .oO( Ракудо стар )

[11:01] <masak> :P

[11:02] <moritz> --> Int works here locally, but the &x:(...) still gives "invoke() not implemented in class 'QAST::WVal"

[11:02] <masak> phenny: "Ракудо стар"?

[11:02] <phenny> masak: "Rakudo star" (sr to en, translate.google.com)

[11:02] <masak> phenny: ru en "Ракудо стар"?

[11:02] <phenny> masak: "Rakudo old" (ru to en, translate.google.com)

[11:02] <masak> :P

[11:03] <tadzik> oh, the cross-language puns

[11:04] <moritz> jnthn: i guess error-reporting and callframe.t depend on annotations?

[11:06] <jnthn> moritz: Yeah, afaik that's all that's left.

[11:07] <jnthn> moritz: Am trying to untangle how POST did it at the moment... :)

[11:07] *** lue left
[11:07] *** rcmalleb left
[11:07] <arnsholt> moritz: I think it has to be &cb(...) (no colon)

[11:09] <jnthn> I think really the colon syntax should also work, but arnsholt++ has probably saved enough yaks for the moment ;-)

[11:09] <moritz> arnsholt: ah, with subsignatures

[11:09] <masak> phenny: en pl "old"?

[11:09] <moritz> arnsholt: the &cb:(...) should also work, as part of the longname

[11:09] <phenny> masak: "stary" (en to pl, translate.google.com)

[11:09] <masak> tadzik: seems to work in Polish as well...

[11:09] <moritz> arnsholt: but that's fine

[11:10] <tadzik> :)

[11:11] <tadzik> r: say 0.272 * 3934, " MB"

[11:11] <p6eval> rakudo a25127: OUTPUT«1070.048 MB␤»

[11:11] <tadzik> rakudo/pirt build on 64-bit

[11:12] <jnthn> tadzik: Can you remember what it was for you before any of the QAST stuff?

[11:12] *** GlitchMr left
[11:13] <tadzik> jnthn: I remember the reason why I bought another 2 GBs of ram :P

[11:13] <tadzik> but that was long ago

[11:13] <tadzik> ISTR it being about 1.5 GBs

[11:15] *** lue joined
[11:20] <moritz> yes, 1.5GB it was on my machine too

[11:20] <moritz> 1.7G before the bs merge

[11:21] <moritz> then dropped to 1.3 or so

[11:21] <moritz> and then slowly increased again to 1.5

[11:22] *** SamuraiJack left
[11:22] *** cognominal joined
[11:24] *** jimmy1980 left
[11:26] <dalek> nqp/pirt: 614dc7a | jnthn++ | src/QAST/PIRT.nqp:

[11:26] <dalek> nqp/pirt: Add back annotations.

[11:26] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/614dc7a481

[11:26] <jnthn> OK, spectesting and chesetesting of pirt now welcomed. :)

[11:26] <jnthn> And memory improvement reports :)

[11:28] <moritz> r: sub f(--> Int) { Str }; f

[11:28] <p6eval> rakudo a25127: OUTPUT«Type check failed for return value; expected 'Int' but got 'Str'␤  in sub f at /tmp/zZZuIVUc21:1␤  in block  at /tmp/zZZuIVUc21:1␤␤»

[11:29] <moritz> \o/

[11:29] <moritz> arnsholt++

[11:31] * jnthn merges latest nom stuff into pirt also, to ease testing

[11:32] *** jimmy1980 joined
[11:33] *** GlitchMr joined
[11:34] <dalek> roast: 25cc0f0 | moritz++ | S32-str/substr.t:

[11:34] <dalek> roast: remove .chrs usaeg from substr.t

[11:34] <dalek> roast: 

[11:34] <dalek> roast: After yesterday's discussion I think it will go away, and it's not what we're

[11:34] <dalek> roast: actually testing here anyway.

[11:34] <dalek> roast: review: https://github.com/perl6/roast/commit/25cc0f0402

[11:37] <moritz> jnthn: spectesting

[11:37] <jnthn> moritz: ok

[11:39] <jnthn> Looks fine after the merge.

[11:39] <dalek> rakudo/pirt: 2652a19 | (Arne Skjærholt)++ | src/Perl6/Actions.pm:

[11:39] <dalek> rakudo/pirt: Keep track of return type info in --> signature syntax.

[11:39] <dalek> rakudo/pirt: review: https://github.com/rakudo/rakudo/commit/2652a19f1a

[11:39] <dalek> rakudo/pirt: 3ec91e5 | (Arne Skjærholt)++ | src/Perl6/Actions.pm:

[11:39] <dalek> rakudo/pirt: Make create_signature_object take a signature info hash instead of param list.

[11:39] *** dalek left
[11:39] <jnthn> BOOM!

[11:39] *** dalek joined
[11:39] *** ChanServ sets mode: +v dalek

[11:42] *** phenny left
[11:43] *** phenny joined
[11:45] <jnthn> away for a bit

[11:50] *** takadonet left
[11:52] <moritz> jnthn: seems that line numbers aren't correct

[11:53] <moritz> jnthn: they are all 1 higher than they should be, at first glance

[12:00] *** drbean left
[12:00] <jnthn> my $line := HLL::Compiler.lineof($!node.orig(), $!node.from(), :cache(1)) + 1;

[12:01] <jnthn> hmm

[12:01] * jnthn removes the + 1

[12:01] <dalek> nqp/pirt: eb0c0a3 | jnthn++ | src/QAST/PIRT.nqp:

[12:01] <dalek> nqp/pirt: Try to make line numbers more correct.

[12:01] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/eb0c0a398a

[12:02] * masak accidentally puts a division slash in the right-hand part of a s///e and watches hilarity ensue

[12:02] <masak> ...in p5, where this is an issue, that is.

[12:03] *** drbean joined
[12:10] *** SamuraiJack joined
[12:10] <moritz> jnthn: yes, the + 1 ins't necessary anymore. I've fixed line_of some months ago :-)

[12:11] *** sivoais left
[12:12] <moritz> respectesting

[12:13] * masak .oO( I will respectest you in the morning )

[12:17] <moritz> 1066MB virtual memory used while building rakudo/pirt

[12:17] *** Chillance joined
[12:26] <moritz> jnthn: seems some of the line number stuff is still a bit off

[12:26] <moritz> jnthn: one of the line number tests in error-reporting.t now fails (the other pass), and the line number from callframe.t is one off

[12:27] <moritz> the one that fails in error-reporting.t is   sub mysub { \n +Any \n }; \n mysub()

[12:27] <moritz> it reports a warning from line 1, not line 2

[12:30] <moritz> weird, it says   .annotate 'line', 2    right before the call to &prefix:<+>

[12:33] <moritz> spectest summary: t/spec/S06-advanced/callframe.rakudo Failed test:  2, t/spec/integration/error-reporting.rakudo integration/error-reporting.rakudo               (Wstat: 0 Tests: 13 Failed: 1) Failed

[12:33] <moritz> test: 11

[12:34] <moritz> if I replace the warning with a die(), it still gets the wrong line number

[12:36] <moritz> the difference in the generated PIR between nom and pirt is that pirt emits two annotations in a row

[12:36] <moritz> .annotate 'line', 1

[12:36] <moritz> .annotate 'line', 2

[12:36] <moritz> then the call

[12:36] <moritz> nom just emits the second (correct) annotation line

[12:36] <moritz> I would have expected the second to take precedence

[12:38] *** lue left
[12:39] *** Chillance left
[12:40] *** Chillance joined
[12:40] <felher> little question: do methods handle named parameters differently from sub? Because this doesn't die:

[12:40] <felher> r: class A { method a() { }; }; A.new.a(:unexpected);

[12:40] <p6eval> rakudo a25127:  ( no output )

[12:40] <felher> while this does:

[12:40] <felher> r: sub a() { }; a(:unexpected);

[12:40] <p6eval> rakudo a25127: OUTPUT«Unexpected named parameter 'unexpected' passed␤  in sub a at /tmp/Bv6HvYbNt7:1␤  in block  at /tmp/Bv6HvYbNt7:1␤␤»

[12:41] <moritz> felher: yes, that's by design

[12:43] <felher> moritz: oh, okay. Thanks :)

[12:45] <felher> moritz: but sub a() is still a matching candidate as far as the dispatcher is concerned, but then fails on binding?

[12:46] <felher> (if that makes any sense, at all... :) )

[12:48] <moritz> felher: yes

[12:48] <moritz> felher: multi dispatch is done primarily based on the nominal type of positional parameters

[12:49] <moritz> felher: and then where-clauses and named params are "epsilons" tighter than just the matching positional arguments

[12:50] <jnthn> moritz: Investigating.

[12:52] <felher> moritz: is the dispatcher supposed to handle named parameters and such someday in the future?

[12:53] <jnthn> What's really going on is that methods get a *%_ added implicitly.

[12:53] <jnthn> While subs don't.

[12:53] <moritz> felher: the spec doesn't mandate it; dunno if it's feasible at some point in the future

[12:54] <moritz> jnthn: is it?

[12:54] <jnthn> moritz: In the original example. :)

[12:54] * jnthn was responding kinda late :)

[12:55] <jnthn> Trying a patch for the annotations.

[12:56] <moritz> jnthn: do we expect the dispatcher to treat named args/params the same way as positional ones? (like, in perl 6.2 or so)

[12:56] <jnthn> moritz: I think there's something in the spec that conjectures that a Perl 6 version beyond 6.0 may take named parameters into account during narrowness analysis.

[12:57] <jnthn> moritz: Working out the details of that may well be extremely hairy, though.

[12:57] *** lue joined
[12:58] <moritz> jnthn: is that because the narrowness analysis doesn't interact well with an unknown number of params that need to be analyzed?

[13:00] <jnthn> moritz: More that you can have lots of partially overlapping sets of named parameters between candidates.

[13:01] <felher> moritz, jnthn: thanks, folks :)

[13:03] <masak> felher: what's *really* going on is the interaction of named parameters being optional, and Perl 6 OO wanting to preserve some kind of Liskov substitutability for deriving types.

[13:03] * masak grins

[13:06] *** SamuraiJack_ joined
[13:07] *** SamuraiJack left
[13:08] <felher> masak: oh, makes sense. Otherwise methods in derived types will thrown an exception if given the old named arguments, right?

[13:09] <moritz> right

[13:09] <felher> \o/ :)

[13:09] <moritz> masak++ # nice explanation

[13:13] *** GlitchMr left
[13:15] <jnthn> Grr...first fix failed. :/

[13:15] * jnthn tries again

[13:23] <dalek> nqp/pirt: 5202f7d | jnthn++ | src/QAST/PIRT.nqp:

[13:23] <dalek> nqp/pirt: Fix dupe annotation emission.

[13:23] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/5202f7dad5

[13:24] *** spider-mario left
[13:24] <jnthn> moritz: That seems to nail it.

[13:37] <masak> moritz: oh, it actually made sense? huh. though to be fair, that's just echoing what A12 and S12 already say on the subject.

[13:38] *** tokuhiro_ left
[13:39] *** tokuhiro_ joined
[13:41] *** mtk left
[13:47] *** lue left
[13:50] *** mucker joined
[13:52] *** GlitchMr joined
[13:56] <dalek> nqp/pirt: dc13ec1 | jnthn++ | src/ops/nqp.ops:

[13:56] <dalek> nqp/pirt: Make type checking op quietly say no, so it can be safely used in a wider context.

[13:56] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/dc13ec1a46

[13:56] <dalek> nqp/pirt: 388a271 | jnthn++ | src/QAST/ (2 files):

[13:56] <dalek> nqp/pirt: A little optimization. Shaves some more seconds of CORE.setting compile time here, and off the spectest also.

[13:56] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/388a271e26

[13:58] *** benabik left
[13:58] *** Coleoid left
[13:58] *** benabik joined
[13:59] *** Coleoid joined
[14:00] *** jimmy1980 left
[14:01] *** jimmy1980 joined
[14:26] <moritz> jnthn: spectests on newest nqp/pirt are fine now

[14:27] <jnthn> moritz: OK. Think it should have an ecosystem test before merging?

[14:28] <moritz> jnthn: will try to do one

[14:28] <jnthn> moritz: OK, thanks :)

[14:29] *** tokuhiro_ left
[14:36] *** brrt joined
[14:37] * jnthn submits a YAPC::Asia talk

[14:38] *** Bucciarati left
[14:38] *** Bucciarati joined
[14:40] <GlitchMr> Just wondering, is there method like .first, except returning index?

[14:43] <brrt> nqp: pir::compreg("nqp");

[14:43] <p6eval> nqp: OUTPUT«error:imcc:The opcode 'compreg_p' (compreg<1>) was not found. Check the type and number of the arguments␤   in file '(file unknown)' line 169411186␤»

[14:43] *** sivoais joined
[14:43] <brrt> nqp: pir::compreg__Ps("nqp")

[14:43] <p6eval> nqp:  ( no output )

[14:44] <[Coke]> https://gist.github.com/3199314 - just built and installed rakudo (recent vintage) in ./rakudo; checkout panda in ./panda, and try to run the bootstrap, it explodes

[14:45] <masak> GlitchMr: no, but you can do .pairs.first({...}).key

[14:45] <moritz> [Coke]: does panda's offline-bootstrap branch work for you?

[14:49] <[Coke]> moritz: same error

[14:49] <[Coke]> This is perl6 version 2012.07-210-g8435346 built on parrot 4.4.0 revision RELEASE_4_4_0

[14:50] *** SamuraiJack_ left
[14:51] <moritz> that's pretty recent

[14:51] *** SamuraiJack joined
[14:55] <dalek> rakudo/nom: 8c740aa | moritz++ | docs/ChangeLog:

[14:55] <dalek> rakudo/nom: update ChangeLog

[14:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c740aad71

[14:58] *** JimmyZ joined
[15:00] *** MayDaniel left
[15:00] <felher> Hm, since candidates_matching of Routine only asks the dispatcher, is there a way to check if a bind will also work?

[15:13] *** brrt left
[15:14] <moritz> tadzik: it seems that newest Mojolicious comes without render_file_to_file, which broke the emmentaler renderer

[15:20] <pmichaud> good morning, #perl6

[15:20] <JimmyZ>  good am, pm

[15:21] <felher> o/ pm

[15:22] <jnthn> hi, pmichaud 

[15:24] <dalek> emmentaler: 75131c9 | moritz++ | formatter:

[15:24] <dalek> emmentaler: [formatter] avoid usage of render_file_to_file, which is gone from new versions of Mojo

[15:24] <dalek> emmentaler: review: https://github.com/tadzik/emmentaler/commit/75131c9c52

[15:25] <moritz> http://moritz.faui2k3.org/tmp/pirt-smoke.html is the result of the ecosystem test run on top of rakudo/pirt

[15:27] <moritz> 59 modules ok, 47 not ok

[15:28] <GlitchMr> Just wondering, is there any policy about modules which use nqp or parrot (read: not Perl 6, but works on Rakudo Perl 6)?

[15:28] <jnthn> moritz: Matches the last run, it seems: http://tjs.azalayah.net/index.html

[15:30] *** MayDaniel joined
[15:30] *** JimmyZ left
[15:32] <GlitchMr> https://github.com/colomon/Math-ContinuedFractions/

[15:32] <GlitchMr> Also, Perl 6 module without module files... what?

[15:33] <GlitchMr> I mean, tests work, but...

[15:33] <GlitchMr> This module cannot be used in real code because of it

[15:34] <jnthn> moritz: So, I think merge time :)

[15:35] <pmurias> what creates blib subdirectories during the rakudo build?

[15:38] <pmurias> https://github.com/pmurias/rakudo supports ./perl6 -Cjs -e 'say "Hello World"' | node ;)

[15:40] *** hoelzro|away is now known as hoelzro

[15:40] <hoelzro> if I define my own BUILD submethod, the default BUILD submethod Mu provides should still be called, right?

[15:40] <jnthn> pmurias: !! :D

[15:40] <GlitchMr> At least it's not always output "Hello World", but it's still hacky :P

[15:41] <jnthn> Everything starts out hacky. :)

[15:41] <GlitchMr> Well, viv is hack too

[15:42] <GlitchMr> I'm too lazy to actually compile this modified rakudo, but would it support escapes?

[15:42] <GlitchMr> Such as "\n"

[15:42] <moritz> jnthn: +1

[15:43] <moritz> pmurias: I don't think create subdirectories during the build

[15:43] <jnthn> Ah

[15:43] <jnthn> There's a .gitignore in blib/Perl6

[15:43] <moritz> pmurias: we put .gitignore files in dirs we put files into

[15:44] <pmurias> moritz: thanks

[15:44] *** uniejo joined
[15:46] *** spider-mario joined
[15:47] <dalek> Heuristic branch merge: pushed 27 commits to nqp by jnthn

[15:48] <GlitchMr> 27 commits?

[15:48] <GlitchMr> Oh, I see, branch merge

[15:48] <jnthn> yes, pirt

[15:50] *** uniejo left
[15:50] *** uniejo joined
[15:50] <dalek> rakudo/nom: 99d850b | jnthn++ | src/Perl6/Actions.pm:

[15:50] <dalek> rakudo/nom: Initial update to get Rakudo to build with nqp/pirt. Eliminates the final PAST::Node usages also. Some test failures; seems CORE.setting memory is a bit lower with this, which was the aim.

[15:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/99d850bc11

[15:50] <dalek> rakudo/nom: 2b57323 | jnthn++ | src/Perl6/Grammar.pm:

[15:50] <dalek> rakudo/nom: Fix user defined ops, which probably deals with many of the test regressions.

[15:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b57323921

[15:50] <dalek> rakudo/nom: eea3e60 | jnthn++ | src/Perl6/Actions.pm:

[15:50] <dalek> rakudo/nom: Remove a hack we no longer need, fixing one of the other regressions.

[15:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eea3e60c9a

[15:50] <dalek> rakudo/nom: e5fe863 | jnthn++ | / (5 files):

[15:50] <dalek> rakudo/nom: Merge branch 'nom' into pirt

[15:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e5fe863f29

[15:50] <dalek> rakudo/nom: 4e3d0ff | jnthn++ | src/Perl6/ (2 files):

[15:50] <dalek> rakudo/nom: Merge branch 'pirt' into nom

[15:50] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4e3d0ff0a5

[15:50] <dalek> rakudo/nom: c1bfbbb | jnthn++ | tools/build/NQP_REVISION:

[15:51] <dalek> rakudo/nom: Bump to an NQP revision with PIRT.

[15:51] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c1bfbbb233

[15:51] <cognominal> pirt?

[15:51] <jnthn> cognominal: More memory-efficient replacement for POST.

[15:53] <cognominal> nice

[15:53] <jnthn> Seems that the next Rakudo release ships with a ~ 35% memory saving during CORE.setting compilation over the previous one. :)

[15:55] * moritz guesses he can now leave firefox open while compiling rakudo :-)

[15:57] <pmichaud> rakudo no longer does inlining of native stuff?

[15:57] <pmichaud> e.g.,    my int $i = 5000;   $i = $i - 1;    isn't inlining the subtract  :-/

[15:58] <jnthn> pmichaud: No, I didn't re-do the inliner yet

[15:58] <jnthn> pmichaud: It's pretty much next on my todo list.

[15:59] <jnthn> (That is, we'll have it again well before the next release.)

[15:59] <pmichaud> okay.  we're probably paying a penalty for that with list stuff, then, as I switched much of the native nqp:: stuff to rely on the inliner.

[15:59] <pmichaud> (I can switch back to avoid that reliance if we wish.)

[16:00] <mhasch> when will the next release be due?

[16:00] <moritz> pmichaud: since jnthn will re-do the inliner soon anyway, I don't think it's worth switching back

[16:00] *** am0c joined
[16:00] <jnthn> pmichaud: I'd leave it; I suspect the inliner is back within days.

[16:00] <pmichaud> mhasch: next release is scheduled for 08/23

[16:02] <jnthn> So, well over 3 weeks away :)

[16:02] <mhasch> very fine, thanks pmichaud.

[16:02] *** soooga left
[16:02] <pmichaud> 3 weeks away, yes, but we lose _some_ time due to yapc::eu :)

[16:03] <pmichaud> anyway, if you say the inliner will be back within days, I'm fine with that :)

[16:03] * moritz ponders writing a bot which reports release dates

[16:03] <mhasch> the time on yapc::eu will be well spent, I am sure :-)

[16:03] <pmichaud> I'll just have to keep it in mind when doing timings and tests on list code until then :)

[16:04] <jnthn> pmichaud: Yeah, it didn't feel worth holding back getting more testing/feedback on all the rest of QAST for that.

[16:04] <pmichaud> jnthn: sure, no problem.  I just wasn't quite expecting loops to slow down like they did.  :)

[16:04] <pmichaud> ooc, did we agree that the 2012.08 release would be "Frankfurt"?

[16:05] <jnthn> pmichaud: At least we know the optimizer actually does something worthwhile now :P

[16:05] *** xinming_ left
[16:05] <moritz> I don't know if we agreed on that, but that was my plan when I snatched away "Frankfurt" as a release name two months ago :-)

[16:05] <pmichaud> ...or do we want to wait and see if there are actually any Perl 6 talks at YAPC::EU?  ;-)

[16:06] <jnthn> .oO( only if there are...dang, Pm beat me :P )

[16:06] <japhb> Anyone here have any skills hinting GraphViz layouts?  My type graph visualization iteration is hitting a wall.  :-/

[16:06] *** xinming joined
[16:07] <pmichaud> oh, I see masak++ got a email reply 

[16:07] <jnthn> pmichaud: When you do the <ws> tweaks, may be worth seeing if it can be sped up any along the way.

[16:08] *** uniejo left
[16:08] <cognominal> jnthn, switch to QAST is still on the ROADMAP. I thought that was completed even stuff like optimizations is not back

[16:08] <au> japhb: there's a really good, although proprietary, GraphViz .dot hinter application called OmniGraffle.app

[16:08] <moritz> cognominal: nqp hasn't switched to QAST yet

[16:09] <jnthn> pmichaud: Looking at CORE.setting profile output, over 5% of time (inclusive) is spent in ws. Compared to 2.4% or so for the entire optimizer phase. :)

[16:09] <cognominal> thx, moritz

[16:09] <pmichaud> jnthn: sure... but much of that is just because .ws is called sooooooo often

[16:09] *** GlitchMr left
[16:09] <jnthn> pmichaud: Aye, the call counts say as much.

[16:10] <jnthn> 225,000 calls while parsing CORE.setting.

[16:10] <moritz> might be a worthy target for the inliner :-)

[16:10] <pmichaud> <.ws> doesn't inline easily.

[16:10] <jnthn> Aye.

[16:10] * moritz cheers on jnthn to get to the method inliner :-)

[16:10] <japhb> au, Thank you.  Unfortunately, I'm actually looking for hints I can generate through relatively simple algorithmic means, starting from e.g. a human-friendly text file

[16:11] <japhb> Along the lines of "I want Pod::Config near to Pod::Block, but otherwise run normal layout"

[16:12] <pmichaud> jnthn: are there any subrules of <.ws> that show up high on the list?

[16:12] <jnthn> pmichaud: MARKED

[16:12] <pmichaud> number of calls, time spent, or both?

[16:13] <jnthn> pmichaud: 262k calls, 2.45%

[16:13] <pmichaud> 2.45% of the CORE.setting time?

[16:13] <jnthn> Yes.

[16:13] <pmichaud> okay, that might be where we can get some speedup.

[16:13] * mhasch just realized there is a significant lack of perl6 talks on the Franfurt talk list. What happened?

[16:14] <pmichaud> http://blogs.perl.org/users/moritz/2012/07/no-accepted-perl-6-talks-at-yapceu-2012.html

[16:14] <jnthn> pmichaud: To put it in context, !cursor_pass gets 757128 calls.

[16:14] <jnthn> pmichaud: And it is at 2.41%

[16:14] <pmichaud> well, every call to <.ws> also generates a call to MARKED

[16:14] <pmichaud> but yes, MARKED is obviously on the high side.

[16:15] <moritz> mhasch: ine ssence, the organizers did a majority vote to accept talks, and nobody had any overview of talks per topic or so

[16:15] <pmichaud> I'll definitely look at it.

[16:17] <jnthn> OK. I'm optimistic that once we get NQP on QAST, and I write an NQP::Optimizer, we can get some more wins.

[16:17] <jnthn> (In general.)

[16:19] <jnthn> back later &

[16:21] <hoelzro> did anyone see my question about custom BUILDs?

[16:27] <moritz> where?

[16:28] * moritz did not

[16:28] <moritz> are niecza releases on the last Monday of the month?

[16:29] <pmichaud> moritz: yes, that's the pattern I remember.

[16:34] <moritz> say Date.today.truncated-to(:week).day-of-week

[16:34] <moritz> r: say Date.today.truncated-to(:week).day-of-week

[16:35] <p6eval> rakudo c1bfbb: OUTPUT«1␤»

[16:35] <moritz> r: say Date.today.truncated-to(:week)

[16:35] <p6eval> rakudo c1bfbb: OUTPUT«2012-07-23␤»

[16:36] <hoelzro> if I define my own BUILD submethod, the default BUILD submethod Mu provides should still be called, right?

[16:36] <hoelzro> it was a good hour ago or so.

[16:36] <moritz> Mu doesn't provide a BUILD submethod for you

[16:36] <moritz> submethods are *not* inherited

[16:36] <hoelzro> right

[16:36] <moritz> so, Mu # aka, the question doesn't make sense

[16:37] <hoelzro> but if I don't provide my own BUILD submethod, the 'default' fills in my public attributes from the arguments to bless, doesn't it?

[16:37] <moritz> that's correct

[16:37] <hoelzro> ok

[16:37] <hoelzro> so, what I should be asking is this:

[16:38] <moritz> r: class A { has $.x; submethod BUILD() {} }; say A.new(x => 3).x

[16:38] <p6eval> rakudo c1bfbb: OUTPUT«Any()␤»

[16:38] <moritz> r: class A { has $.x; submethod BUILD(:$!x) {} }; say A.new(x => 3).x

[16:38] <p6eval> rakudo c1bfbb: OUTPUT«3␤»

[16:38] <hoelzro> how do I provide my own custom BUILD submethod, but still populate the attributes I didn't initialize in my own BUILD?

[16:38] <hoelzro> ex: https://gist.github.com/3199546

[16:38] *** uniejo joined
[16:39] <moritz> hoelzro: add :$!foo  to the signature of your BUILD

[16:39] *** uniejo left
[16:40] <hoelzro> moritz: so if I have a good deal of attributes in my class, and I want to have a custom BUILD, I need to do that by hand?

[16:40] <moritz> hoelzro: yes

[16:40] <hoelzro> =(

[16:41] <moritz> I know, it kinda sucks

[16:41] <moritz> though in your case, a default value works

[16:41] <moritz> has $.bar = YourClass.new

[16:41] <hoelzro> I was thinking nextsame; would do it, but it's not valid because it's a submethod, right?

[16:41] <moritz> right

[16:41] <hoelzro> moritz: default values are evaluated per instance, right?

[16:41] <moritz> r: https://gist.github.com/3200120

[16:41] <moritz> hoelzro: right

[16:41] <p6eval> rakudo c1bfbb: OUTPUT«parrot: 2012-08-21␤rakudo: 2012-08-23␤niecza: 2012-07-30␤»

[16:42] <hoelzro> moritz: ok, thanks!

[16:43] <au> japhb: PodConfig -> PodBlock [weight=999];

[16:44] <hoelzro> moritz: also, we were talking about interpolating strings into regexes last night; where is that defined in the spec?

[16:44] <hoelzro> I'd like to add a test to roast for it

[16:44] <au> or, programatically (P5), $graphviz->add_edge($node_a, $node_b, weight => 999);

[16:44] <moritz> S05

[16:45] <hoelzro> seciton?

[16:45] <hoelzro> *section

[16:45] <moritz> I don't know that by heart :-

[16:45] <moritz> )

[16:45] <hoelzro> heh

[16:46] <TimToady> S05:1165 for one

[16:46] <hoelzro> I looked in S05 a bit earlier, but I couldn't find anything definitive

[16:46] <moritz> there are some tests in S05-interpolation/ already, more welcome

[16:46] *** benabik left
[16:46] <TimToady> well, S05:1148

[16:46] <hoelzro> oh, ok

[16:46] <hoelzro> TimToady: thanks

[16:46] <moritz> hoelzro: there's a whole section, http://perlcabal.org/syn/S05.html#Variable_%28non-%29interpolation

[16:46] *** benabik joined
[16:47] <TimToady> and S05:1535

[16:47] <TimToady> "leading character" there means first char inside <...>

[16:48] <TimToady> nr: my $x = '.'; say 'foo.bar' ~~ / $($x) /

[16:48] <p6eval> niecza v19-15-g051783d: OUTPUT«#<match from(3) to(4) text(.) pos([].list) named({}.hash)>␤»

[16:48] <p6eval> ..rakudo c1bfbb: OUTPUT«#<failed match>␤»

[16:48] <TimToady> rakudobug

[16:48] <TimToady> nr: my $x = '.'; say 'foo.bar' ~~ / $x /

[16:48] <p6eval> niecza v19-15-g051783d: OUTPUT«#<match from(3) to(4) text(.) pos([].list) named({}.hash)>␤»

[16:48] <p6eval> ..rakudo c1bfbb: OUTPUT«q[.]␤␤»

[16:49] <moritz> I think $(...) in regex is simply NYI

[16:49] <hoelzro> "$x" is as well, iirc

[16:49] <TimToady> nr: my $x = '.'; say 'foo.bar' ~~ / "$x" /

[16:49] <moritz> correct

[16:49] <p6eval> niecza v19-15-g051783d: OUTPUT«#<match from(3) to(4) text(.) pos([].list) named({}.hash)>␤»

[16:49] <p6eval> ..rakudo c1bfbb: OUTPUT«#<failed match>␤»

[16:49] <hoelzro> I'm just being a good reporter and making sure there's a test in roast for it =)

[16:49] <moritz> hoelzro++

[16:50] <TimToady> nr: my $x = '.'; say 'foo.bar' ~~ / <$x> /

[16:50] <p6eval> niecza v19-15-g051783d: OUTPUT«#<match from(0) to(1) text(f) pos([].list) named({}.hash)>␤»

[16:50] <p6eval> ..rakudo c1bfbb: OUTPUT«q[f]␤␤»

[16:54] <pmichaud> getting "$x" to work shouldn't be too difficult.

[16:59] <japhb> au, Hmmm.  That sortof worked, once I made it style=invis, but it still thinks Pod::Config should be at a rank below Pod::Block.  And if I set constraint=false, it doesn't just turn off the rank constraint, it turns off the nearness constraint as well.

[16:59] * japhb tries adding rank=same to the link

[16:59] <japhb> Harumph, didn't work.

[17:00] <japhb> Ah, that only works for a subgraph

[17:00] <TimToady> r: sub foo (&infix:<op>, $a, $b) { say $a op $b }; foo &[/], 42, 7;

[17:00] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2, near "say $a op "␤»

[17:00] <TimToady> doesn't seem as though user-defined ops are quite fixed yet

[17:01] <pmichaud> I suspect rakudo doesn't recognize &infix:<op> in a signature as needing to modify the parser.

[17:03] <pmichaud> beyond that, what is the precedence of <op> in that case?  same as &infix:<+> ?

[17:03] <TimToady> that would be the default

[17:03] <pmichaud> okay.

[17:04] <moritz> Timbus: ping

[17:04] <TimToady> .oO(also &infix:<op> is equiv(&[X]))

[17:04] <moritz> Timbus: I'm trying your Net::IRC. The README says the way to reply to an event is $e.reply($msg), but I get " such method 'reply' for invocant of type 'Net::IRC::Event'"

[17:04] <pmichaud> but that example likely implies a re-think/refactor of how Rakudo handles user-defined operators.

[17:04] <pmichaud> I think Rakudo might currently do it in the sub declaration.

[17:04] <moritz> does  my &infix:<op>   also modify the grammar?

[17:05] <TimToady> well, it probably means there are two codepaths where there could be one

[17:05] <japhb> moritz, the docs for Net::IRC lie.  I played with that a bit, so lemme check my notes ...

[17:05] <moritz> n: my &infix:<op> = -> $a, $b { $a + $b }; say 1 op 3

[17:05] <p6eval> niecza v19-15-g051783d: OUTPUT«4␤»

[17:06] <moritz> japhb: seems I need to use $e.msg

[17:06] <TimToady> n: sub foo (&infix:<op>, $a, $b) { say $a op $b }; foo &[/], 42, 7;

[17:06] <p6eval> niecza v19-15-g051783d: OUTPUT«6␤»

[17:06] <TimToady> that one works in niecza too

[17:06] <japhb> moritz, correct, yes

[17:06] <japhb> but there was something else I wanted to pass on as well.

[17:06] <pmichaud> yeah, the grammar needs to be modified whenever &infix:<op>  is encountered in a declarational context.

[17:06] * japhb looking for that

[17:06] <pmichaud> and not just when the name of a routine happens to be &infix:...

[17:07] *** mikemol left
[17:09] <pmichaud> it probably also implies something about how 'is equiv' and 'is tighter' are handled.

[17:10] <pmichaud> since they attach to the declared name and not to the routine being declared.

[17:10] <moritz> which brings us to the topic of trait handling

[17:11] <moritz> IMHO we should pass the name of the traitee to the trait

[17:11] <moritz> that way constant + is export can work together more easily

[17:13] <japhb> moritz, https://gist.github.com/0e3dd578cdad1d93c4b6

[17:14] <moritz> japhb: thanks

[17:14] <japhb> np

[17:20] <diakopter> TimToady: what is .classify in radix_sort

[17:21] * TimToady is still wondering if 'has $.foo = stuff;' can attach stuff lazily to FETCH such that in BUILD a FETCH before a STORE gets the default, but a STORE before a FETCH clobbers it

[17:21] * japhb chuckles ... in attempting to clean all the gunk out of that gist, I accidentally left out a semicolon on line 5.

[17:21] *** lue joined
[17:22] <TimToady> diakopter: it, er, classifies things

[17:23] <TimToady> it's defined in S32/Containers:158 or so

[17:23] *** spider-mario left
[17:23] <TimToady> note that neither implementation actually implements it correctly

[17:23] <TimToady> it's supposed to return a Hash, not a list of Pairs

[17:24] <pmichaud> didn't moritz++ make a fix for this recently?

[17:24] <TimToady> nr: say (1,2,3,4,5).classify(* % 3).WHAT

[17:24] <p6eval> rakudo c1bfbb: OUTPUT«Hash()␤»

[17:24] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method classify in type Parcel␤  at /tmp/nc7IxXi1hN line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at …

[17:24] <TimToady> ohh, a Hash

[17:25] <TimToady> nr: say (\classify(* % 3, 1..10).WHAT

[17:25] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2, near ""␤»

[17:25] <p6eval> ..niecza v19-15-g051783d: OUTPUT«===SORRY!===␤␤Unable to parse parenthesized expression at /tmp/w3RrJAFK6X line 1:␤------> say (⏏\classify(* % 3, 1..10).WHAT␤Couldn't find final ')'; gave up at /tmp/w3RrJAFK6X line 1 (EOF):␤------> say (\classify(…

[17:25] <TimToady> nr: say classify(* % 3, 1..10).WHAT

[17:25] <p6eval> rakudo c1bfbb: OUTPUT«Hash()␤»

[17:25] <p6eval> ..niecza v19-15-g051783d: OUTPUT«List()␤»

[17:25] <TimToady> yeah, looks fixed in rakudo now

[17:26] <pmichaud> moritz++

[17:26] <TimToady> nr: say classify(* % 3, 1..10).{0,1,2}

[17:26] <p6eval> rakudo c1bfbb: OUTPUT«3 6 9 1 4 7 10 2 5 8␤»

[17:26] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Cannot use hash access on an object of type List␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 354 (Any.at_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/vyCvcC6jHl line 1 (mainli…

[17:26] *** lue left
[17:27] <TimToady> it only makes sense, since it has already constructed a Hash, to just return it, rather than forcing the caller to rebuild the Hash if they want one

[17:29] <TimToady> nr: say classify(*.substr(*-1,1), (-100..100).roll(20))< - 0 1 2 3 4 5 6 7 8 9 >

[17:29] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Cannot use hash access on an object of type List␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 354 (Any.at_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/bXHQM1nqM8 line 1 (mainli…

[17:29] <p6eval> ..rakudo c1bfbb: OUTPUT«Unable to coerce value for '$start' from WhateverCode to Int; no coercion method defined␤  in method substr at src/gen/CORE.setting:1919␤  in block  at /tmp/M9btQUCyZW:1␤␤»

[17:31] *** kaare_ left
[17:31] *** adu joined
[17:31] <skids> r: (-1 +> 16).say; (-1 +> 8).say; (-1 «+>« (16,8))».say

[17:31] <p6eval> rakudo c1bfbb: OUTPUT«-1␤-1␤0␤0␤»

[17:32] <TimToady> r: say classify(*.substr(0,1), (-100..100).roll(20)).WHAT

[17:32] <p6eval> rakudo c1bfbb: OUTPUT«Hash()␤»

[17:32] <TimToady> r: say classify(*.substr(0,1), (-100..100).roll(20)).{'-',0..9}

[17:33] <p6eval> rakudo c1bfbb: OUTPUT«-97 -89 -100 -22 -96 -12 -100 -33 -14 -7 -64 -25 -36 Any() 13 17 22 25 Any() Any() 57 Any() Any() 82 95␤»

[17:33] <TimToady> hmm, missing entries should return (), not Any

[17:33] <pmichaud> it's a Hash.

[17:34] <pmichaud> missing entries of Hash are Any.

[17:34] *** am0c left
[17:36] <TimToady> r: say classify(*.substr(0,1), (-100..100).roll(20)).{'-',0..9}:p

[17:36] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/kTOLPaqIh0:1␤»

[17:37] <TimToady> we had something in there about skipping missing entries when slicing somewhere

[17:37] <TimToady> don't remember if it was with or without the :p

[17:37] <pmichaud> probably needs to be with, otherwise      %h<a b c> = ....   doesn't dwim

[17:38] *** brrt joined
[17:38] *** GlitchMr joined
[17:39] <hoelzro> should rx { "$!instance-var" } function the same as my $var = $!instance-var; rx { "$var" }; ?

[17:42] <moritz> yes

[17:42] <hoelzro> ok, so that needs to go into the test as well, then

[17:46] *** lucas_ joined
[17:47] <tadzik> moritz++ # fixing smoked cheese

[17:49] <jnthn> Being able to smoke the cheese is terribly useful.

[17:50] <pmichaud> jnthn: should I open github issues in perl6/nqp for qast-related things?

[17:51] <dalek> roast: 7ad5915 | (Rob Hoelz)++ | S05-interpolation/regex-in-variable.t:

[17:51] <dalek> roast: Add test for double quote regex interpolation

[17:51] <dalek> roast: review: https://github.com/perl6/roast/commit/7ad591525d

[17:51] <dalek> roast: f0f43c4 | (Rob Hoelz)++ | S05-interpolation/regex-in-variable.t:

[17:51] <dalek> roast: Add test for interpolating instance members

[17:51] <dalek> roast: review: https://github.com/perl6/roast/commit/f0f43c4bac

[17:52] <pmichaud> hoelzro: is there a ticket for "$x"  in RT somewhere?

[17:52] <hoelzro> pmichaud: yes (https://rt.perl.org/rt3/Public/Bug/Display.html?id=113958)

[17:53] <pmichaud> thanks

[17:53] * pmichaud takes the ticket, will likely work on it tonight.

[17:54] <hoelzro> I think I found a bug in the Rakudo REPL; where should I put the test for that?

[17:54] <moritz> hoelzro: we don't have a good way to test the REPL yet :(

[17:55] <hoelzro> ah

[17:55] <moritz> and since the REPL isn't specced, they can't go into roast

[17:55] <pmichaud> ...what's the bug?

[17:55] <hoelzro> well, let's say I stick a role named Animal into Animal.pm6

[17:56] *** p6rd joined
[17:56] <hoelzro> if I do "use Animal;\nmy $dog = Any.new;\n$dog does Animal", the REPL complains that it doesn't know about Animal

[17:56] <hoelzro> although this could be my limited experience with Perl6 talking here.

[17:56] <moritz> p6rd: help

[17:56] <p6rd> Perl 6 release dates. Usage: p6rd: [ 'next' | 'next month' | YYYY-MM | YYYY-MM-DD ]

[17:56] <moritz> p6rd: next month

[17:56] <p6rd> rakudo: 2012-08-23, parrot: 2012-08-21, niecza: 2012-08-27

[17:57] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/B5eA4REbJr:1␤»

[17:57] <moritz> oh, it shouldn't talk to p6eval :-)

[17:57] *** p6rd left
[17:57] *** p6rd joined
[17:58] <moritz> p6rd: next

[17:58] <p6rd> rakudo 2012-08-23, parrot 2012-08-21, niecza 2012-07-30

[17:59] <pmichaud> ...should it sort by date there?  ;-)

[17:59] <pmichaud> i.e.,   niecza 2012-07-30, parrot 2012-08-21, rakudo 2012-08-23

[18:00] *** MayDaniel left
[18:00] <moritz> pmichaud: good idea

[18:00] <hoelzro> so is that behavior I saw in the REPL a bug?

[18:00] <hoelzro> or a defiency in my understanding?

[18:01] <pmichaud> hoelzro: my initial guess is that it's a bug.  It probably has to do with the fact that each line of input to the REPL is a separate compilation unit.

[18:01] *** whiteknight joined
[18:02] <hoelzro> ok

[18:02] *** p6rd left
[18:02] <pmichaud> and so when it gets down to  $dog does Animal   the compiler doesn't have "Animal" in a symbol table somewhere that it needs.

[18:02] *** whiteknight is now known as Guest60380

[18:02] <pmichaud> jnthn: nqp::while(cond, body)   is now always casting cond to a PMC... any way to avoid that?

[18:03] <pmichaud> or perhaps it's that   nqp::isge_i($i, 0)   is always casting to a PMC, although that seems less likely.

[18:03] <jnthn> pmichaud: Hmm...I suspect it's the "while".

[18:03] <jnthn> pmichaud: I need to review a few of those once I get the inliner in place.

[18:04] <jnthn> pmichaud: Does "if" do the same, ooc?

[18:04] <pmichaud> checking.

[18:04] *** p6rd joined
[18:05] <moritz> p6rd: next

[18:05] *** p6rd left
[18:05] <pmichaud> jnthn: doesn't look as though "if" is doing the same.

[18:05] <pmichaud> let me re-check 'while'

[18:06] *** p6rd joined
[18:06] <pmichaud> well... hrm.

[18:06] *** spider-mario joined
[18:06] <pmichaud> nqp::while boxes the result of the isge, but never actually uses the boxed result.

[18:06] <jnthn> pmichaud: oh...

[18:07] <jnthn> r: say do while False { }

[18:07] <p6eval> rakudo c1bfbb: OUTPUT«False␤»

[18:07] <jnthn> r: say do while 0 { }

[18:07] <p6eval> rakudo c1bfbb: OUTPUT«0␤»

[18:07] <jnthn> pmichaud: I suspect it's the "'cus we want it for the return value" thing...

[18:07] <jnthn> Fixable of course.

[18:07] <pmichaud> ...except I'm not sure that's the p6 semantic anymore :)

[18:08] <moritz> p6rd: next

[18:08] <p6rd> niecza 2012-07-30, parrot 2012-08-21, rakudo 2012-08-23

[18:08] <moritz> now sorted by date, pmichaud++

[18:09] <skids> But did he use a radix sort? :-)

[18:10] <pmichaud> jnthn: the while loop isn't context aware -- it always generates the PMC even if the caller is requesting something else?

[18:10] *** MayDaniel joined
[18:13] <felher> moritz++ #p6rd

[18:13] <moritz> https://github.com/moritz/p6-release-dates # source code

[18:13] <jnthn> pmichaud: I think it should be; I can believe there's something up with that.

[18:13] *** sergot left
[18:14] <jnthn> pmichaud: Will investigate in a bit.

[18:14] <jnthn> dinner, bbs

[18:14] <pmichaud> okay.  I need lunch myself... and perhaps I'll go work on something else for a while.

[18:15] <japhb> Whee, finally starting to figure out dot hinting for type graph visualization!

[18:16] <japhb> au, the trick was to do:  subgraph "cluster: foo" { rank=same; style=invis; "node1"; "node2"; }

[18:17] <japhb> That pulls the two (or more) nodes together into a same-rank packed area of the output

[18:18] <skids> Hrm.  RE: http://irclog.perlgeek.de/perl6/2012-07-27#i_5850800  -- Now that I have July Star locally, still I get a "value is not known at compile time" running that line locally without the BEGIN -- but evalbot is happy with it... weird.

[18:19] *** hoelzro is now known as hoelzro|away

[18:20] <moritz> skids: the fix came in after the release

[18:20] <skids> Ah.

[18:20] <moritz> skids: well, after the compiler release, and star uses the compiler releas

[18:20] <skids> OK, then not some difference in the way evalbot is built or run.  Good.

[18:21] <skids> moritz++

[18:22] <moritz> speaking of which, I should simplify the rakudo build

[18:22] <moritz> on p6eval

[18:23] <skids> BTW, what is the current story with the --parrot-option Configure, and should that go into the README?

[18:24] <moritz> it should go into INSTALL

[18:24] <moritz> README is too long already

[18:27] <skids> Ah... didn't notice INSTALL.txt as it's tucked in a subdir in the star distro tree.

[18:29] *** sergot joined
[18:31] *** adu left
[18:34] <jnthn> pmichaud: Yeah, I'm gonna need to spend a bit more time on this area. Will take care of if when working on inlining. It is trying to take care of type stuff, but apparently not getting things quite right there.

[18:39] *** brrt left
[18:40] <moritz> Timbus: and it seems that the IRC bot only joins the first channel that I pass to :channels

[18:41] *** brrt joined
[18:44] *** nebuchadnezzar left
[18:48] <felher> moritz: Why "$date  - $date.truncated-to(:month)" instead of "$date.day-of-month - 1"? Matter of taste or something i missed? Since i'm a big fan of types i would have used "Event $e" in "said" instead of "$e" - but this certainly is a matter of taste. Apart from that i find it to be quite cute :)

[18:51] <masak> r: sub foo(&x) { my $value = "inside foo"; return { say $value; say "[&x()]" } }; my $value = "outside foo"; foo { $value }; # moritz: actually, this is not altogether different from how macros work

[18:51] <p6eval> rakudo c1bfbb:  ( no output )

[18:51] <moritz> felher: I didn't think of day-of-month, it's certainly easier with it

[18:51] <masak> hm.

[18:51] <masak> r: sub foo(&x) { my $value = "inside foo"; return { say $value; say "[&x()]" } }; my $value = "outside foo"; (foo { $value })();

[18:51] <p6eval> rakudo c1bfbb: OUTPUT«inside foo␤[outside foo]␤»

[18:51] <masak> there we go.

[18:56] *** birdwindupbird joined
[19:01] *** p6rd left
[19:01] *** p6rd joined
[19:01] *** Coleoid left
[19:02] *** adu joined
[19:02] <moritz> p6rd: upcoming

[19:02] <p6rd> niecza 2012-07-30, parrot 2012-08-21, rakudo 2012-08-23

[19:03] <jnthn> p6rd: 6.0.0

[19:03] <jnthn> .oO( dang, it didn't say christmas )

[19:03] <moritz> it now runs on a 24/7 server, so we'll see how stable it runs

[19:05] <moritz> and with a ulimit, just to be sure

[19:13] <GlitchMr> perl6: my $var = 42; print "${var}";

[19:13] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Non-variable $ must be backslashed at line 2, near "${var}\";"␤»

[19:13] <p6eval> ..niecza v19-15-g051783d: OUTPUT«===SORRY!===␤␤Unsupported use of ${var}; in Perl 6 please use {$var} at /tmp/dWC3YtJE68 line 1:␤------> my $var = 42; print "${var}⏏";␤␤Parse failed␤␤»

[19:13] <GlitchMr> :)

[19:13] <GlitchMr> I prefer Niecza error message

[19:17] *** brrt left
[19:20] *** brrt joined
[19:21] *** crab2313 joined
[19:21] *** brrt left
[19:23] *** nebuchadnezzar joined
[19:23] *** mikemol joined
[19:24] *** GlitchMr left
[19:25] *** SamuraiJack left
[19:25] *** SamuraiJack joined
[19:26] *** nwc10 joined
[19:34] <pmurias> jnthn: how does QAST::Var.decl work?

[19:34] <pmurias> what does it mean?

[19:34] <jnthn> pmurias: Contains 'var' or 'param'

[19:35] <jnthn> pmurias: Or it's empty to mean "this is just a normal variable access"

[19:35] <jnthn> pmurias: Note that Rakudo uses its own signature binding stuff, so you'll only have to contend with decl.

[19:35] <jnthn> (For Rakudo.)

[19:37] <masak> https://github.com/moritz/p6-release-dates/blob/master/release-dates.pl # niiiiice

[19:37] <masak> moritz++

[19:39] *** lucas_ left
[19:40] *** birdwindupbird left
[19:40] *** birdwindupbird joined
[19:41] *** lue joined
[19:41] <arnsholt> Is there a difference in the kind of thing returned from return $thing rather than falling off the end of a block ending with $thing?

[19:41] <lue> hello world o/

[19:41] <masak> lue! \o/

[19:42] <masak> r: sub foo { my $thing = 42; return $thing }; sub bar { my $thing = 42; $thing }; say foo.^name; say bar.^name

[19:42] <p6eval> rakudo c1bfbb: OUTPUT«Int␤Int␤»

[19:42] <masak> arnsholt: doesn't look it.

[19:42] <masak> r: sub foo { my $thing = 42; return $thing, $thing }; sub bar { my $thing = 42; $thing, $thing }; say foo.^name; say bar.^name

[19:42] <p6eval> rakudo c1bfbb: OUTPUT«Parcel␤Parcel␤»

[19:43] <jnthn> I'd not expect one.

[19:43] <arnsholt> Cause that's how I fixed my problem in Zavolaj earlier today

[19:43] <pmurias> jnthn: for every my variable the is a QAST::Var with a decl equal to 'var'?

[19:43] <arnsholt> With return, breakage. No return works fine

[19:43] <jnthn> pmurias: Correct.

[19:43] <arnsholt> Mind, the value returned form the sub is bound with := not assigned

[19:44] <jnthn> arnsholt: What sort of value is it?

[19:44] <arnsholt> nqp::list

[19:44] <pmurias> jnthn: and what does the WVal with an Array contain?

[19:45] *** bbkr joined
[19:46] <jnthn> arnsholt: That explains it somewhat.

[19:46] <pmichaud> once you start working with nqp::list, then Rakudo's perl6izer often comes into play.

[19:46] <jnthn> arnsholt: Those are not proper Perl 6 types so you can get into some fun with them.

[19:46] <arnsholt> Right, right. That's probably it then

[19:46] <jnthn> pmurias: I don't get the "with an Array" part

[19:47] <jnthn> pmurias: WVal = World Value = a reference to an object created at compile time.

[19:47] <skids> IIRC the returned form is specced to be an "abnormal control" exception... but implementation status of that... ??

[19:47] <pmurias> a mysterious WVal containing an array appears in the past for -e '1'

[19:48] <jnthn> Hm

[19:48] * jnthn looks

[19:48] <jnthn> oh, I wonder if it's Pod related...

[19:49] <jnthn> pmurias: Yeah. Grammar.pm:514

[19:50] <pmurias> jnthn: and I get a segfault when calling pir::typeof__SP on it's first element

[19:50] <pmurias> jnthn: thanks

[19:51] <jnthn> typeof is a Parrot-y thing rather than a 6model-y thing. You might want to do $obj.HOW.name($obj) or so

[19:51] <jnthn> If you're after the name.

[19:51] <pmichaud> jnthn: I think I'm wanting a nqp::stmt  or nqp::stmts   opcode.

[19:52] <pmurias> jnthn: how do you display the past for a code snippet?

[19:52] <pmichaud> jnthn: any suggestions about how to add one?

[19:52] <jnthn> $ops.add_hll_op('perl6', 'stmts', -> $qastcomp, $op { $qastcomp.as_post(QAST::Stmts.new( |@($op) ))

[19:52] <jnthn> });

[19:52] <pmurias> s/past/qast/

[19:53] <jnthn> Add something like that in src/Perl6/Ops.pm

[19:53] <jnthn> You can promote it to NQP later if you like

[19:53] <pmichaud> I think I'll want to add it to nqp, but I .... right.

[19:53] <jnthn> It's easy, just s/hll/core/ and toss the 'perl6' arg

[19:53] <pmichaud> I'm looking at nqp::list, and it appears to create a PIRT::Ops node, though.

[19:53] <pmichaud> some of the nqp ops can create PIRT directly?

[19:54] <jnthn> No, only QAST::Compiler/QAST::Operations generates PIRT

[19:54] <jnthn> If you do nqp::list in Perl 6 source, it makes a QAST::Op.new( :op('list'), ... )

[19:55] <jnthn> That is, nqp::foo is just a way to make QAST::Op nodes

[19:55] <jnthn> The translation happens later

[19:55] <jnthn> Not like with nqp:: before with PAST, which could translate directly to a PAST node with the pirop in.

[19:56] <pmichaud> okay, just a sec.

[19:56] <pmichaud> (this makes sense at a high level; I'm wanting to understand a lower level)

[19:56] <jnthn> pmurias: In theory, --target=past. In practice, it explodes...

[19:57] <pmichaud> ...because --target=past still uses Parrot's Data::Dumper, and not everything (especially meta/knowhow stuff) knows how to dump itself.

[19:57] <jnthn> oh, ouch!

[19:57] <jnthn> I thought it'd been updated. D'oh.

[19:58] <pmichaud> it was updated for one type, but I think there are still some missing.

[19:58] <pmichaud> https://github.com/perl6/nqp/blob/master/src/QAST/Operations.nqp#L174  <-- can you describe what this is doing?

[19:58] <jnthn> OK. It's on my todo list, after the inliner.

[19:58] <jnthn> Looking

[19:59] <jnthn> pmichaud: QAST::Operations contains a registry.

[19:59] <pmichaud> yes, I know that part.

[19:59] <jnthn> OK, to clarify - what bit do you want to know about?

[19:59] <pmichaud> specifically, unlike  add_hll_op above, it appears to have a closure that returns a PIRT instead of a QAST

[19:59] <pmichaud> oh oh oh

[19:59] <jnthn> No

[19:59] <jnthn> Both return PIRT

[19:59] <pmichaud> right

[19:59] <pmichaud> I see the .as_post now

[20:00] <jnthn> Yeah

[20:00] <pmichaud> so, when you define a new "op", you pass it a closure that knows how to construct the PIRT

[20:00] <jnthn> Correct.

[20:00] <pmichaud> I think I like that, but I'm not sure yet.  :-)

[20:00] <jnthn> And then there's an auto-mapper for ops that go directly to PIR.

[20:01] <jnthn> Note that I don't encourage *widespread* use of the trick I showed (that is, making QAST to immediately de-sugar).

[20:01] <jnthn> However, it is very convenient in situations like the one you just asked for :)

[20:01] <pmichaud> so, in the stmts example above, I could just as easily have created something like 'list' does instead of going through QAST::Stmts

[20:02] <jnthn> pmichaud: Well, actually if you just have a list of statements to compile, you could do exactly what QAST::Stmts does.

[20:02] <jnthn>     multi method as_post(QAST::Stmts $node) {

[20:02] <jnthn>         self.compile_all_the_stmts($node.list, $node.resultchild, :node($node.node))

[20:02] <jnthn>     }

[20:02] <jnthn> Stmt does similar but with an extra bit of diddling to handle register allocation stuff.

[20:03] <pmichaud> right, Stmt imposes a temporary register sequence point.

[20:03] <jnthn> So you could write it as $qastcomp.compile_all_the_stmts($op.list)

[20:03] <jnthn> And avoid the temporary QAST::Stmts node.

[20:03] <pmichaud> okay, that tells me what I need to know for now.

[20:04] <pmichaud> The advantage of going through the QAST node of course is that you gain any future modifications (i.e., DRY)

[20:04] <jnthn> Yeah

[20:04] <jnthn> The disadvantage is making throwaway objects, but I doubt this is a hot path.

[20:04] <pmichaud> correct, it's likely not a hot path.  and I think that DRY trumps throwaway concerns until demonstrated otherwise.

[20:06] <pmichaud> the more I look at QAST, the more I like it.  I'm really glad you did the work and not me, I think we end up with a much better product (my views would've likely been too colored by the PAST implementations)

[20:07] <masak> jnthn++

[20:07] <moritz> jnthn++ indeed

[20:07] <moritz> I haven't looked much at the design, but I like the results :-)

[20:07] <pmichaud> I'll probably be doing some refactors and shifting a few things around over time... but it looks really solid.

[20:08] <masak> if you read anything, let it be https://github.com/perl6/nqp/blob/master/t/qast/qast.t

[20:08] <masak> it's a wonderful test file.

[20:08] <pmichaud> I'll look at it also :)

[20:09] * pmichaud looks now.

[20:09] <masak> oh, actually https://github.com/perl6/nqp/blob/master/src/QAST/Compiler.nqp is a good read too. it made me realize a few things about compilers.

[20:09] <masak> (primarily that OO can be applied to them in nice ways)

[20:10] <pmichaud> wow, Compiler.nqp is only 1463 loc

[20:10] <pmichaud> and that's including the regex stuff

[20:11] *** tokuhiro_ joined
[20:11] <pmichaud> so, waitaminnit.  rakudo is using PIRT now, yes?

[20:11] <moritz> yes

[20:12] <pmichaud> so are we using _any_ of PCT anymore?

[20:12] <pmichaud> (for Rakudo, I know NQP has yet to be converted.)

[20:12] <jnthn> pmichaud: No

[20:12] <pmichaud> whoa.

[20:12] <masak> \o/

[20:12] <masak> jnthn++

[20:12] <pmichaud> that's....   so incredibly cool.

[20:12] <jnthn> pmichaud: Unless today's HLL::Compiler still inherits from PCT::Compiler

[20:12] <moritz> my $compiled := PAST::Compiler.compile($parse);

[20:13] <moritz> from Perl6::Grammar

[20:13] <pmichaud> jnthn: it does not.

[20:13] <moritz> isn't that a PCT thingy?

[20:13] <jnthn> Yeah.

[20:13] <moritz> (something regey, iirc)

[20:13] <jnthn> Because of NQP :)

[20:13] <jnthn> moritz: Yeah, it's dynamically generating an action method.

[20:14] <jnthn> To go into Perl6::Actions

[20:15] <jnthn> (Which is written in NQP.)

[20:15] <jnthn> I think that gen_op may be the only mention of PAST.

[20:15] <jnthn> It also must be re-done.

[20:16] <jnthn> (In a bigger sense that "re-write it to use QAST"

[20:16] <jnthn> I think that code is the great survivor from the ng days or soemthing.

[20:16] <masak> rn: my @a = <a b c d e>; say $_ ~~ /^ f @a oo $/ for "faoo", "fcoo", "fzoo"

[20:16] <p6eval> rakudo c1bfbb: OUTPUT«#<failed match>␤#<failed match>␤#<failed match>␤»

[20:16] <pmichaud> if you're just installing an action method, NQP doesn't care if it was generated using PAST or QAST, though.

[20:16] <p6eval> ..niecza v19-15-g051783d: OUTPUT«#<match from(0) to(4) text(faoo) pos([].list) named({}.hash)>␤#<match from(0) to(4) text(fcoo) pos([].list) named({}.hash)>␤Match()␤»

[20:16] <jnthn> pmichaud: Yeah, it probably could be updated.

[20:16] <masak> rn: my @a = <a b c d e>; say so $_ ~~ /^ f @a oo $/ for "faoo", "fcoo", "fzoo"

[20:16] <p6eval> niecza v19-15-g051783d: OUTPUT«True␤True␤False␤»

[20:16] <p6eval> ..rakudo c1bfbb: OUTPUT«False␤False␤False␤»

[20:16] <pmichaud> at least, it shouldn't care :-)

[20:17] <jnthn> pmichaud: As I said though, gen_op is horribly broken in other ways.

[20:17] <pmichaud> jnthn: correct, it is.

[20:17] <pmichaud> and there was another example of that a few hours ago; it needs to be called on the declaration of the name

[20:17] <pmichaud> not from routine_def

[20:17] <jnthn> Yeah.

[20:17] <jnthn> That ain't so bad to fix.

[20:17] <jnthn> But it's what it does that needs a good going over.

[20:18] <pmichaud> sure, I agree.

[20:18] <jnthn> We really need to do the is assoc/is loser etc traits too.

[20:18] <jnthn> *losser

[20:18] <jnthn> argh..

[20:18] <jnthn> looser

[20:18] <pmichaud> fwiw, those apply to the name declaration and not the routine also

[20:19] <jnthn> pmichaud: Probably need to be carried on both.

[20:19] <pmichaud> could be that, too.

[20:19] <jnthn> I'm thinking exporting them.

[20:19] <jnthn> We need to associate the traits with the name on import.

[20:19] <pmichaud> the easiest way to start is to have a    is PREC('c=')  trait which forces a given precedence.

[20:20] <pmichaud> once that works, getting looser/tighter/equiv to work is a smop

[20:20] <pmichaud> (where 's' really is 'simple')

[20:20] <jnthn> Good point.

[20:20] <masak> heh -- I found https://rt.perl.org/rt3/Ticket/Display.html?id=95504 last summer when I implemented crypt the first time. now I hit upon it again. :)

[20:21] <moritz> yep, NYI

[20:21] <pmichaud> but shouldn't be too hard to YI

[20:22] <moritz> btw, is the interpolation syntactic?

[20:22] <moritz> I mean, if I do  my $s = [1, 2, 3];  /$s/

[20:22] <moritz> is that same as if I did it with a @ sigil?

[20:22] <pmichaud> my current guess is that   $s   is treated as a string there.

[20:23] <pmichaud> but I could be wrong about that, since  if $s is a Regex it is treated as a regex.

[20:23] <moritz> TimToady: ^^ any comment?

[20:24] <moritz> I guess @($s) is still available to do @ interpolation semantics

[20:24] <pmichaud> see also  https://github.com/perl6/mu/blob/master/misc/pm.txt#L7   :-)

[20:24] <TimToady> I'd guess it should be string

[20:24] *** SamuraiJack left
[20:24] <pmichaud> well,  "$s"  is also available to force string semantics :-)

[20:24] <TimToady> std: / @$_ /

[20:24] <p6eval> std e52e3ca: OUTPUT«ok 00:00 41m␤»

[20:25] <TimToady> I think people will expect string coercion there

[20:25] <TimToady> (without @)

[20:25] <moritz> since Array is Cool, we should use syntax to determine the operation, not type

[20:25] <moritz> so, +1 to $ forcing Str (unless it's a Regex)

[20:25] <masak> pmichaud: well the odd thing is, as the RT ticket explains, that there appears to be support for array interpolation.

[20:26] <masak> and ISTR someone actually implementing it.

[20:26] <pmichaud> masak: there was support in alpha and/or beijing, iirc

[20:26] <masak> ah.

[20:26] <moritz> by the way, can we have Parcel to be Cool too, pleaes?

[20:26] <moritz> nr: say Parcel ~~ Cool

[20:26] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[20:26] <pmichaud> it's Cool already, afaik

[20:26] <moritz> oh, it already is

[20:26] <moritz> never mind then

[20:26] <moritz> nr: say Parcel.^mro

[20:27] <p6eval> rakudo c1bfbb: OUTPUT«Parcel() Cool() Any() Mu()␤»

[20:27] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method mro in type ClassHOW␤  at /tmp/vx4q5_ZycW line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /ho…

[20:27] <pmichaud> I'm likely to have Parcel be Iterable, too.

[20:27] <[Coke]> blah. getting more pugs failures in daily spec run via cron that don't show up in a standard run.

[20:28] <moritz> is Iterable a role or a class?

[20:28] <pmichaud> it's currently a class.

[20:28] <moritz> the name just sounds role-y, IMHO

[20:28] <pmichaud> agreed

[20:28] <pmichaud> the name may also want a change, too.

[20:29] <moritz> though looking at Iterator and Iterable in Rakudo right now, they look as if they could very well be roles

[20:29] <pmichaud> it wouldn't be too difficult (now) to make it into a role if we decide we need to do that.  At the time I was implementing Iterable, role support in nom was still not completely there.

[20:30] <bbkr> example from spec does not work anymore: https://github.com/perl6/specs/issues/20

[20:31] <pmichaud> bbkr++ # good catch

[20:31] * pmichaud can update pm.txt :-)

[20:34] <masak> what determines if something should be Cool? why should Parcel be Cool?

[20:34] <masak> (not questioning the decision, just curious)

[20:34] <pmichaud> for many of the same reasons that Array and List are Cool (more)

[20:34] <pmichaud> if I have     sub foo(Cool $x) { say +$x );   

[20:35] <pmichaud> then I'm basically saying that I expect most of the standard types to be passed in as $x and that they'll coerce between num/str/list as appropriate.  Parcel does that.

[20:37] <pmichaud> (did that answer the question satisfactorily?)

[20:37] <masak> how do I say "what's been matched by the current rule" inside a <?{ ... }> block?

[20:37] <pmichaud> masak:    $/ ought to work

[20:38] <masak> oh, good.

[20:38] <pmichaud> r:  say  'abc' ~~ / .* <?{  $/.say }> /;   # checking

[20:38] <p6eval> rakudo c1bfbb: OUTPUT«q[abc]␤␤q[abc]␤␤»

[20:38] <pmichaud> r: 'abc' ~~ / . <?{  $/.say }> /;   # checking

[20:38] <p6eval> rakudo c1bfbb: OUTPUT«q[a]␤␤»

[20:40] <masak> \o/

[20:42] <moritz> masak: in general, stuff is Cool if it's a type that occurs often (and not just in very specific situations), and that has a sensible string and number interpretation

[20:43] <pmichaud> r: say 'abc' ~~ / . <?{  $/.say }> .. /;   # checking

[20:43] <p6eval> rakudo c1bfbb: OUTPUT«q[a]␤␤q[abc]␤␤»

[20:44] <moritz> for example Parameter is not cool, because it doesn't have a sensible numeric interretation, and you don't just run accross Paramter objects in normal p6 code

[20:44] <moritz> s/cool/Cool/

[20:45] <masak> lue: you'll be pleased; I'm writing a small grammar for command parsing :)

[20:45] <masak> moritz: ok, fair enough.

[20:45] <lue> I figured, judging by your recent questions :)

[20:46] <masak> heh :)

[20:46] <masak> lue++

[20:46] <tadzik> masak: as in: "make me spaghetti?"

[20:47] * moritz wants "sudo extinguish fire" as a command in crypt

[20:47] <moritz> :-)

[20:49] <masak> :P

[20:49] * jnthn has blaught: http://6guts.wordpress.com/2012/07/29/rakudo-qast-switch-brings-memory-reductions/

[20:52] <moritz> jnthn++

[20:53] <moritz> am I right in assuming that the QAST tree isn't GC'ed  after the PAST -> POST stage?

[20:53] <lue> jnthn++

[20:53] <tadzik> jnthn++ indeed

[20:54] <jnthn> moritz: s/POST/PIRT/ :)

[20:54] <bbkr> Is is possible to get class method using "&" operator? For example I can do "&substr" to get Callable object instead of executing it. But if I have class A {method a {}} neither &A.a or &A::a works.

[20:54] <tadzik> Parrot IR tree?

[20:54] <masak> "Happily, though, we’ve actually got a little bit faster at compilation." -- wow!

[20:54] <jnthn> tadzik: PIR Tree

[20:55] <masak> tadzik: the tree is infrared, so it glows a dull red.

[20:55] <tadzik> kewl

[20:55] <jnthn> bbkr: No, you canny do that

[20:55] <masak> tadzik: and there are clogs hanging in it.

[20:55] <moritz> bbkr: $obj.can('methodname')[0]

[20:55] <jnthn> bbkr: Easiest way are is $obj.^find_method('methodname')

[20:55] *** pjcj left
[20:56] <masak> bbkr: the methods are in a namespace not accessible through the & sigil. we discovered this as we hammered out 'our' and 'has' scopes around 2009.

[20:56] <jnthn> moritz: I think it should be collectable beyond the PIRT stage

[20:56] <jnthn> moritz: Oh, wait...

[20:56] <jnthn> moritz: That contains a link to $/ 

[20:56] <bbkr> thanks for explanation

[20:56] <jnthn> moritz: Which in turn references the QAST tree through .ast

[20:56] <jnthn> So basically, the whole lot goes away togehter.

[20:56] <jnthn> *together

[20:57] <moritz> jnthn: watching the memory growing during setting compilation, it seems it's not collected

[20:57] *** sergot left
[20:57] <moritz> jnthn: huh, I thought we didn't reference $/, just extract its .orig and .from?

[20:57] <moritz> at least that's what PAST did

[20:57] *** sergot joined
[20:57] <masak> "In other exciting news, the arrival on QAST means masak++ is digging into taking macros some steps further. Maybe there’ll be something nice there for the next release too. :-)" -- yes, I hope so too. and it doesn't feel that far-fetched.

[20:57] <jnthn> That...wasn't my understanding of what PAST did

[20:58] <masak> though $family is going to require my attention in the next few days.

[20:58] <jnthn> I thought it was at the POST stage that we pulled out the orig/from

[20:58] <masak> (nothing serious, just spending time)

[21:02] *** birdwindupbird left
[21:02] <jnthn> pmichaud: For inlining, I'm going to tag with of the ops (as in QAST::Op) are free of side-effects that'd mean you can't inline them. I'm pondering :pure(1) being specified at the point you add them. Sound reasonable?

[21:03] <jnthn> er, I messed upt he sentence :)

[21:03] <jnthn> ...autopun :/

[21:03] <jnthn> I meant free of side-effects meaning you *can* safely inline them...

[21:04] <jnthn> .oO( Clearly it's time for a beer... )

[21:04] <nwc10> *a* beer?

[21:05] <nwc10> I think you've earned more than one

[21:05] <nwc10> although, yes, one at a time :-)

[21:05] <jnthn> I'm not sure beer drinking parallelizes well on a single node. :)

[21:05] <masak> beer serialization context.

[21:06] <nwc10> gets even worse if you try to paralellise drinking (say) beer and cider

[21:06] <tadzik> slurp()

[21:06] *** Guest60380 left
[21:07] *** whiteknight joined
[21:07] <jnthn> I'd never seen snakebite as an example of parallelism...

[21:07] *** whiteknight is now known as Guest55706

[21:10] * masak learns about "shandy" -- eeew

[21:10] *** bbkr left
[21:11] <pmichaud> jnthn: (:pure)   thinking

[21:14] <geekosaur> try not to turn into a monad.  or a comonad, for that matter

[21:16] <pmichaud> jnthn: the approach sounds fine;  I don't remember if "inlinable" is exactly what :pure was meant to indicate.

[21:17] <jnthn> pmichaud: Well I could make the name inlinable

[21:17] <jnthn> It felt a bit...unweidly :)

[21:17] <pmichaud> :inline(1)  would be fine :-)

[21:17] <jnthn> *unwieldy

[21:17] <pmichaud> except that .inline means something else in P6 (on callframes)

[21:17] <jnthn> Hmm, that...right.

[21:17] <jnthn> Well, and it feels instructive rather than stative.

[21:18] <jnthn> It means "something can feel free to inline code containing this op elsewhere, 'cus this op runs on risk of screwing it up"

[21:18] <jnthn> *no

[21:18] <pmichaud> anyway, +1 from me.

[21:18] <pmichaud> we can change the names easily enough later if needed.

[21:18] <jnthn> True.

[21:18] * pmichaud reads blog post.

[21:19] <jnthn> Was mostly fishing for a better name.

[21:19] *** pmurias left
[21:20] <pmichaud> :pure works for now; I don't have a better name at the moment.  I'm hoping it's not a conflict with :pure in STD.pm6

[21:20] <pmichaud> blog post (and the work it describes) is excellent.  jnthn++

[21:22] <jnthn> pmichaud: It's in the same semantic niche at least.

[21:22] <pmichaud> jnthn: should I update docs/nqp-opcode.txt to reflect the QAST opcodes?

[21:22] *** spider-mario_ joined
[21:22] <jnthn> pmichaud: Yes, feel free.

[21:22] <pmichaud> that would give me a good opportunity to review them, too :)

[21:24] <pmichaud> ooc, is there still a flag equivalent to :flat on nodes?

[21:25] *** spider-mario left
[21:26] <jnthn> You can :flat(1) on any of the nodes.

[21:26] *** spider-mario_ is now known as spider-mario

[21:26] <pmichaud> excellent.

[21:26] <pmichaud> I may use that sometime in nqp::list and nqp::hash

[21:26] <pmichaud> i.e.,    nqp::list(1, 2, |@a, 3)   should inline the elements of @a

[21:26] <jnthn> oh...

[21:26] <jnthn> I didn't mean it quite like that.

[21:27] <pmichaud> (I know that doesn't currently work; just wanted to know that we had the flag.)

[21:27] <jnthn> I meant "call and callmethod pay attention to it, and it can go on any node"

[21:27] <jnthn> Oh, in that case, fine :)

[21:27] <pmichaud> nqp::list(1, 2, @a, 3)  should end up with a list of four elements,  nqp::list(1, 2, @a, 3)  will generate code that at runtime will splice the contents of @a into the list that is being built.

[21:28] <pmichaud> oops, |@a on the second nqp::list

[21:28] <pmichaud> and it can do that by looking at the :flat attribute of the child node containing @a

[21:28] *** nwc10 left
[21:28] <pmichaud> but that's a future improvement.  :-)

[21:29] <pmichaud> I had been planning to do something similar in PAST but never got around to it.  :)

[21:29] *** tokuhiro_ left
[21:33] *** nwc10 joined
[21:33] <nwc10> OK, on the Raspberry Pi with pirt

[21:33] <nwc10> Stage parse      : 5220.855

[21:33] <nwc10> QAST was

[21:33] <nwc10> Stage parse      : 23840.491

[21:33] <nwc10> before all of this was something like 52535.669

[21:33] <pmichaud> nwc10: those are seconds?

[21:33] <nwc10> jnthn++ # use less 'swap' :-)

[21:33] <nwc10> yes

[21:34] <nwc10> note, it hasn't yet managed to build without crashing

[21:34] <nwc10> either SEGV

[21:34] <pmichaud> so, we're now down to 1.5 hrs instead of 15 hrs?  ;-)

[21:34] <nwc10> or the whole thing locks up

[21:34] <nwc10> yes. 1.5 hours for the parse stage

[21:34] <masak> wow.

[21:34] <pmichaud> well, we're getting closer then :)

[21:34] <masak> Perl 6 on Raspberry Pi! \o/

[21:34] <nwc10> it is rather wow compared to the previous

[21:34] <nwc10> masak: I can install Rakudo with apt-get

[21:34] <nwc10> (just not a current one)

[21:35] <nwc10> but I suspect that debian's buildbots are beefier machines

[21:35] <nwc10> so far:

[21:35] <nwc10> Stage start      :   0.000

[21:35] <nwc10> Stage parse      : 5220.855

[21:35] <nwc10> Stage syntaxcheck:   0.048

[21:35] <nwc10> Stage past       :   0.015

[21:35] <nwc10> so I note that the formatting is a tad optimistic - assumng that nothing takes longer than 999 seconds :-)

[21:36] *** crab2313 left
[21:36] * jnthn chuckles

[21:36] <pmichaud> hey, we have to be optimistic *somewhere*!  :)

[21:36] <nwc10> note, `vmstat 5` now looks typically like this:

[21:36] <nwc10> procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu---- r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa 1  1 149464   8748     44   2020 1050  356  1050   356 8823 1607  0 22  0 78 0  2 149980   8328     44   2020 1195  473  1195   473 8836 1733  1 23  0 77

[21:36] <nwc10> ug

[21:37] *** Guest55706 left
[21:37] <nwc10> oh, actually, it's not that pretty any more

[21:37] <nwc10> it's now in 99% swap hell

[21:37] <nwc10> but for the parse stage it seems to be only about 80% swap hell

[21:38] <dalek> nqp: 06b7631 | jnthn++ | src/QAST/Operations.nqp:

[21:38] <dalek> nqp: Mark up the ops that we should be able to inline. (Not using the data for anything yet.)

[21:38] <dalek> nqp: review: https://github.com/perl6/nqp/commit/06b7631a86

[21:38] <pmichaud> I think that must be optimizer swap hell, then.

[21:38] <nwc10> I'm going to go to bed. And see what the morning brings.

[21:38] <jnthn> The optimizer walks the whole tree.

[21:38] <jnthn> I can see how that could be swap-ouchy.

[21:38] <nwc10> poor little USB disk.

[21:39] <skids> r: class A { multi method Int () { 3 } }; class B is A { multi method Int() { 2 } }; my B $b .= new(); $b.Int.say;

[21:39] <p6eval> rakudo c1bfbb: OUTPUT«2␤»

[21:39] <pmichaud> jnthn: what's the idea of putting the 'defor' definition immediately after the 'for' definition?  It took me a few minutes to figure out that it's "def-or" and not "de-for"  :-P

[21:39] <skids> r: role A { multi method Int () { 3 } }; class B does A { multi method Int() { 2 } }; my B $b .= new(); $b.Int.say;

[21:39] <p6eval> rakudo c1bfbb: OUTPUT«Ambiguous call to 'Int'; these signatures all match:␤:(B , Mu *%_)␤:(B , Mu *%_)␤␤  in method Int at src/gen/CORE.setting:325␤  in block  at /tmp/UTU5w7zrEB:1␤␤»

[21:40] <jnthn> pmichaud: To make people really read the code to see it's not actually a for loop in reverse. :P

[21:41] <nwc10> oh well, the build on the 32 bit FreeBSD system has failed thanks to (I think) -Werror=strict-prototypes tripping up over a header in /usr/local/include which isn't perfectly strict

[21:42] <nwc10> really not convinced that parrot setting all those -Werror options is the smartest thing to be doing.

[21:42] <pmichaud> jnthn: (06b7631 commit).... ummm... what does :pure really indicate, ooc?

[21:43] <jnthn> pmichaud: Routines are assessed for whether they could possibly be inlined.

[21:44] *** adu left
[21:44] <jnthn> pmichaud: If they can be, inlining info is stashed in the Routine object.

[21:44] <pmichaud> so,  :pure(1)  on a 'list' node means that the list node itself is inlinable, but doesn't say anything about the pureness of its children?

[21:44] <jnthn> pmichaud: Correct

[21:45] <pmichaud> and the inliner would have to check that?

[21:45] <jnthn> pmichaud: The algorithm is basically, walk the AST of the routine until we find something that says "NO!"

[21:45] <pmichaud> okay.

[21:45] <pmichaud> wfm.

[21:45] <jnthn> That tends to happen pretty quickly

[21:45] <jnthn> For non-simple routines.

[21:45] <jnthn> Which are the ones we want to inline.

[21:46] <jnthn> Goes without saying you can spend weeks tweaking such things...

[21:46] *** UncleFester6 left
[21:46] *** UncleFester6 joined
[21:50] *** nwc10 left
[21:55] <dalek> nqp: 3f4d70f | pmichaud++ | docs/nqp-opcode.txt:

[21:55] <dalek> nqp: Update nqp-opcode.txt for QAST a bit.

[21:55] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3f4d70f11e

[21:57] *** adu joined
[21:58] <jnthn> Time for some rest

[21:58] <jnthn> 'night

[22:04] *** thelazydeveloper left
[22:05] <pmichaud> how does one run the tests in t/qast ?

[22:05] <pmichaud> ...and I'm getting some fails.

[22:05] <masak> just ./nqp it?

[22:06] <pmichaud> rebuilding nqp w/o my patch to get a baseline

[22:06] <pmichaud> I'm guessing qast should be part of the standard 'make test' for nqp now.

[22:07] <masak> I would've guessed so too.

[22:07] <masak> but it isn't.

[22:07] <pmichaud> fixing.

[22:07] <masak> pmichaud++

[22:07] <pmichaud> the fails are all

[22:07] <pmichaud> not ok 30 - Compilation failure in test_qast_result: Contextual $*QAST_BLOCK_NO_CLOSE not found

[22:12] <pmichaud> okay, got it fixed.

[22:13] <dalek> nqp: 93d6777 | pmichaud++ | t/qast/qast.t:

[22:13] <dalek> nqp: Force QAST_BLOCK_NO_CLOSE in compile_qast() in qast tests.

[22:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/93d6777d20

[22:13] *** pjcj joined
[22:17] <dalek> nqp: 87b5356 | pmichaud++ | tools/build/Makefile.in:

[22:17] <dalek> nqp: Add qast and pirt tests to standard 'make test' target.

[22:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/87b5356682

[22:21] *** spider-mario left
[22:25] <masak> lol, I blog! \o/ http://strangelyconsistent.org/blog/july-29-2012-verb-synonyms

[22:29] <lue> masak++

[22:30] *** jimmy1980 left
[22:31] *** MayDaniel left
[22:31] <masak> lue: the game should be much more playable now, with both abbreviated directions and verbs.

[22:32] <masak> lue: do let me know if you find something unexpected.

[22:32] * lue goes to break^W play crypt again.

[22:32] * masak is sorely tempted to add 'extinguish fire' and 'sudo extinguish fire' (with appropriately acerbic responses) for moritz

[22:34] <lue> my pull of crypt (just now) still says "There is a car here.", by the way.

[22:39] <masak> fixed.

[22:39] <masak> it was because of a hard-coded description at the start of the game.

[22:40] <masak> a bit of a wart that that's needed, but I haven't devised a fix yet.

[22:40] *** adu left
[22:42] <dalek> nqp: 2a467a6 | pmichaud++ | / (3 files):

[22:42] <dalek> nqp: add nqp::stmts() op.

[22:42] <dalek> nqp: review: https://github.com/perl6/nqp/commit/2a467a63cf

[22:43] <lue> er, how do I put the tiny disk back on hanoi? I'm sure I'm just not using the right sentence.

[22:44] *** Chillance left
[22:44] <masak> that's currently not possible.

[22:44] <masak> a wrapping fix similar to the 'take' one is needed there.

[22:45] <masak> actually, the whole disks handling needs to be re-done a bit.

[22:45] <lue> well, then, uh-oh :) [I thought I'd make the hanoi game a bit easier by taking the tiny disk out of play]

[22:45] <masak> :P

[22:45] <lue> s/play/the hanoi game/

[22:45] <masak> yes, that is a cute shortcut.

[22:45] <masak> [Coke]++ discovered it too.

[22:45] <masak> feel free to patch the game.

[22:45] <masak> you currently can't examine any of the disks either. I have a better way to factor that, but I forgot to do it today.

[22:46] *** MayDaniel joined
[23:00] *** Chillance joined
[23:01] *** Chillance left
[23:02] <dalek> nqp: 71ffe4f | pmichaud++ | src/QAST/Operations.nqp:

[23:02] <dalek> nqp: Fix typo in pure-ification of nqp::isgt_n .

[23:02] <dalek> nqp: review: https://github.com/perl6/nqp/commit/71ffe4fbdf

[23:02] <lue> (found bug in crypt, putting on gist...)

[23:04] <lue> masak: https://gist.github.com/3179112 (the 29 July entry)

[23:04] *** whiteknight joined
[23:04] *** whiteknight is now known as Guest13642

[23:08] <masak> hm.

[23:08] <masak> that should trigger failing tests, too.

[23:08] <masak> testing.

[23:08] <masak> indeed.

[23:09] <masak> lue++

[23:09] <masak> tests++

[23:11] <masak> lue: fixed. pushed.

[23:12] <lue> karma C

[23:12] <lue> just a thought :) . Anyway, I have to go, bye for now! o/

[23:12] <masak> \o

[23:12] <masak> 'night, #perl6

[23:16] *** MayDaniel left
[23:18] *** Guest13642 left
[23:20] *** spider-mario joined
[23:21] *** adu joined
[23:29] *** spider-mario left
[23:42] *** Moukeddar joined
[23:42] *** Moukeddar left
