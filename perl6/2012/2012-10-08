[00:03] *** Chillance joined
[00:08] <grondilu> do you think one day a private rocket will use Perl6 code on board?  ;)

[00:10] *** fgomez left
[00:16] *** Patterner left
[00:18] <sorear> depends on how you define "use"

[00:19] <sorear> for hard-real-time high-assurance avionics, there will likely always be better choices

[00:21] <grondilu> at least for simulation, it will be cool to use a high level language such as Perl6.

[00:28] <grondilu> use Rocket; my Rocket $falcon .= new; wait 9* 1min and $falcon.take-off;  #  :)

[00:28] *** whiteknight left
[00:29] *** cognominal joined
[00:30] *** fgomez joined
[00:48] <colomon> grondilu: shoot, forgot about the launch and washed the dishes instead of watching!

[00:51] *** tadzik left
[00:52] *** tadzik joined
[00:55] *** fgomez left
[01:01] *** anuby joined
[01:14] *** hypolin joined
[01:29] *** fgomez joined
[02:03] *** am0c joined
[02:07] *** m0ss joined
[02:21] *** m0ss left
[02:25] *** erkan left
[02:41] *** orafu left
[02:42] *** orafu joined
[02:44] <cognominal> r: say CORE.WHO.keys

[02:44] <p6eval> rakudo 870d18: OUTPUT¬´&undefine &prefix:<temp> &prefix:<let> &INDIRECT_NAME_LOOKUP &REQUIRE_IMPORT &METAOP_ASSIGN &METAOP_TEST_ASSIGN:<//> &METAOP_TEST_ASSIGN:<||> &METAOP_TEST_ASSIGN:<&&> &METAOP_NEGATE &METAOP_REVERSE &METAOP_CROSS &METAOP_ZIP &METAOP_REDUCE_LEFT &METAOP_REDUCE_RIGHT ‚Ä¶

[02:47] <cognominal> typing it twice at the prompt on two different lines gives : Nominal type check failed for parameter '$got'; expected Any but got Perl6::Metamodel::ContainerDescriptor instead

[03:02] *** Celelibi left
[03:07] *** wamba joined
[03:07] *** hypolin left
[03:09] *** hypolin joined
[03:13] *** cognominal left
[03:39] *** Celelibi joined
[03:46] *** Celelibi left
[03:50] *** Celelibi joined
[04:07] *** wamba left
[04:10] *** sftp left
[04:13] *** s1n left
[04:25] *** telex left
[04:25] *** fgomez left
[04:27] *** fgomez joined
[04:29] *** s1n joined
[04:33] *** telex joined
[04:34] *** fgomez left
[04:51] *** s1n left
[04:57] *** fridim_ left
[05:01] *** erkan joined
[05:03] *** will1309 left
[05:11] *** SamuraiJack joined
[05:15] *** hash_table left
[05:18] *** s1n joined
[05:21] *** Playb3yond joined
[05:22] *** kaleem joined
[05:27] *** fgomez joined
[05:32] *** Playb3yond left
[05:33] *** birdwindupbird joined
[05:41] *** Psyche^ joined
[05:41] *** Psyche^ is now known as Patterner

[05:47] <moritz> good morning

[05:53] *** cognominal joined
[05:54] <sorear> o/

[05:59] <moritz> \o

[06:00] *** Chillance left
[06:04] <jnthn> morning o/

[06:11] *** cognominal left
[06:13] <sorear> jnthn!

[06:13] <sorear> \o/

[06:19] *** cognominal joined
[06:24] <jnthn> hi sorear  :)

[06:27] *** mst left
[06:27] *** mst joined
[06:40] *** flightrecorder joined
[06:53] *** FROGGS joined
[06:55] *** mikemol left
[06:57] *** mikemol joined
[07:08] *** brrt joined
[07:09] *** xinming_ left
[07:15] *** xinming joined
[07:15] <mathw> good morning!

[07:16] <brrt> morning

[07:36] *** fhelmberger joined
[07:44] *** cibs left
[07:47] *** irssi394 joined
[07:51] *** mishin joined
[07:52] *** irssi394 left
[07:52] *** alcapowned joined
[08:08] *** kresike joined
[08:09] <kresike> good morning all you happy perl6 people

[08:10] <tadzik> mornings

[08:13] *** thou left
[08:13] <sorear> o/

[08:14] <brrt> \o sorear

[08:14] *** cibs joined
[08:27] *** replore joined
[08:30] *** wamba joined
[08:34] *** brrt left
[08:36] *** mishin left
[08:36] <mathw> o/

[08:37] *** xiaoyafeng joined
[08:42] *** xiaoyafeng left
[08:44] *** mishin joined
[08:47] *** mishin left
[08:50] *** mishin joined
[09:05] *** kaleem left
[09:19] *** am0c left
[09:22] *** replore left
[09:22] *** SamuraiJack_ joined
[09:23] *** SamuraiJack left
[09:23] *** telex left
[09:24] *** telex joined
[09:26] *** wamba left
[09:26] *** wamba joined
[09:32] *** replore joined
[09:36] *** leont joined
[09:37] *** replore left
[09:48] *** rindolf joined
[09:49] *** Patterner left
[09:50] *** Psyche^ joined
[09:50] *** Psyche^ is now known as Patterner

[10:03] *** hypolin left
[10:04] *** daxim joined
[10:09] *** anuby left
[10:17] *** wamba left
[10:30] *** wamba joined
[10:32] *** wk_ left
[10:33] *** wamba left
[10:38] *** Sense_ joined
[10:43] *** mucker joined
[10:46] *** rindolf left
[10:48] *** rindolf joined
[10:53] *** cognominal left
[10:57] *** Sense_ left
[10:59] *** cognominal joined
[11:01] *** leont left
[11:01] *** tokuhiro_ joined
[11:03] *** wk joined
[11:05] *** Su-Shee_ joined
[11:09] *** Su-Shee left
[11:11] *** Su-Shee_ is now known as Su-Shee

[11:29] *** replore joined
[11:33] *** adu joined
[11:34] *** grondilu left
[11:37] *** kaleem joined
[11:40] *** rindolf left
[11:49] *** gootle left
[11:53] *** rindolf joined
[12:06] *** tokuhiro_ left
[12:07] *** tokuhiro_ joined
[12:12] *** tokuhiro_ left
[12:15] *** rindolf left
[12:16] *** rindolf joined
[12:19] *** GlitchMr joined
[12:24] *** sftp joined
[12:25] *** rindolf left
[12:26] *** rindolf joined
[12:34] *** adu left
[12:39] *** snearch joined
[12:42] *** cognominal left
[12:47] *** killbot left
[12:48] *** aharoni joined
[12:49] *** benabik left
[12:49] *** benabik joined
[12:50] *** cognominal joined
[12:52] *** rindolf left
[12:52] *** rindolf joined
[12:54] *** adu joined
[12:57] *** mucker left
[12:58] *** mucker joined
[12:59] *** PacoAir joined
[13:00] *** hash_table joined
[13:00] *** killbot joined
[13:04] *** atrodo joined
[13:07] *** benabik left
[13:12] *** cognominal_ joined
[13:13] *** cognominal left
[13:17] *** replore left
[13:22] *** replore_ joined
[13:23] *** zb left
[13:28] *** rindolf left
[13:28] *** rindolf joined
[13:29] *** zb joined
[13:32] <cognominal_> r:  my ($a, $b) = <1..3>; say $b

[13:32] <p6eval> rakudo 870d18: OUTPUT¬´Nil‚ê§¬ª

[13:33] <cognominal_> r:  my ($a, *, $b) = <1..3>; say $b

[13:33] <p6eval> rakudo 870d18: OUTPUT¬´===SORRY!===‚ê§Malformed parameter‚ê§at /tmp/36wzfNvY3y:1‚ê§¬ª

[13:33] <cognominal_> r:  my ($a, $, $b) = <1..3>; say $b

[13:33] <p6eval> rakudo 870d18: OUTPUT¬´Nil‚ê§¬ª

[13:33] *** hash_table left
[13:33] <[Coke]> r: my ($a, *, $b) = 1, 2, 3; say $b

[13:33] <p6eval> rakudo 870d18: OUTPUT¬´===SORRY!===‚ê§Malformed parameter‚ê§at /tmp/fbNSL0dXdM:1‚ê§¬ª

[13:34] <[Coke]> r: my ($a, $b) = 1, 2, 3; say $b

[13:34] <p6eval> rakudo 870d18: OUTPUT¬´2‚ê§¬ª

[13:34] <cognominal_> I expected a list context.  For the $ versus *, I am not too sure if the doc is a fossil or if the implementation is wrong

[13:36] <masak> the former, methinks.

[13:36] <phenny> masak: 04 Oct 20:54Z <sorear> tell masak possible rakudobugs, "r: .++" and "r: $_.++"; STD is fine with both; are they known?

[13:36] <phenny> masak: 04 Oct 20:55Z <sorear> tell masak well, rakudobugs for sure, possibly *new*

[13:36] <moritz> huh, it is a list context

[13:37] <moritz> erm wait, I might be looking at the wrong line of output right now

[13:37] <cognominal_> oops, I should have chosen betwen <1 2 3> and 1..3  # silly me

[13:37] <cognominal_> brainfart

[13:38] <[Coke]> my ($a, $, $b) = (<1..3>); say $b;

[13:38] <[Coke]> r: my ($a, $, $b) = (<1..3>); say $b;

[13:38] <p6eval> rakudo 870d18: OUTPUT¬´Nil‚ê§¬ª

[13:38] <[Coke]> r: my ($a, $, $b) = <1..3>.list; say $b;

[13:38] <p6eval> rakudo 870d18: OUTPUT¬´Nil‚ê§¬ª

[13:39] <masak> sorear: I'm on vacation and not likely to submit rakudobugs this week ;)

[13:39] <cognominal_> funny how mind automatisms work, apparently I could not choose between the two, so I choosed both, which wrong :)

[13:39] <masak> or even swap in my extensive knowledge about what's submitted and what isn't... :P

[13:39] *** replore_ left
[13:41] <cognominal_> I should compile my errors, I will probably learn a lot about my thought processes when going wrong

[13:41] <cognominal_> S)2:  Outside of declarative constructs you may use C<*> for a placeholder:

[13:42] <cognominal_> I don't see the benefit

[13:49] *** rindolf left
[14:09] *** stopbit joined
[14:13] <diakopter> hm, I wonder whether I have $work today

[14:15] *** benabik joined
[14:20] *** cognominal_ left
[14:21] *** cognominal_ joined
[14:26] *** buubot_backup joined
[14:30] *** benabik_ joined
[14:33] *** benabik left
[14:33] *** benabik_ is now known as benabik

[14:34] *** wk left
[14:35] *** integral left
[14:35] *** crab2313 joined
[14:35] *** cognominal_ left
[14:37] *** kaare__ joined
[14:39] *** spider-mario joined
[14:39] *** crab2313 left
[14:43] *** cognominal_ joined
[14:44] *** fridim_ joined
[14:49] *** hash_table joined
[14:50] *** thou joined
[14:50] *** replore joined
[14:51] *** integral joined
[14:51] *** integral left
[14:51] *** integral joined
[14:54] *** replore left
[14:57] *** telex left
[14:59] *** telex joined
[15:05] *** kaleem left
[15:07] *** birdwindupbird left
[15:07] *** snearch left
[15:12] <kresike> bye folks

[15:12] *** kresike left
[15:12] *** replore_ joined
[15:17] *** rindolf joined
[15:21] *** adu left
[15:23] *** rindolf left
[15:23] *** sirrobert joined
[15:25] *** integral left
[15:25] *** sirrobert left
[15:26] *** integral joined
[15:26] *** integral left
[15:26] *** integral joined
[15:26] *** sirrobert joined
[15:27] <sirrobert>  hi p6

[15:27] <phenny> sirrobert: 05 Oct 21:27Z <raiph> tell sirrobert expected Blah but got Blah: http://irclog.perlgeek.de/perl6/2012-03-01 discussion starts at 15:30

[15:28] *** wamba joined
[15:36] *** wamba left
[15:55] <masak> what does 5) mean under S05/Overview? could someone give an example?

[16:10] *** MayDaniel joined
[16:21] *** wamba joined
[16:21] *** Timbus left
[16:21] *** Timbus joined
[16:23] *** mikemol left
[16:24] *** mikemol joined
[16:26] *** Chillance joined
[16:32] *** snearch joined
[16:35] *** snearch left
[16:36] <PerlPilot> masak: http://irclog.perlgeek.de/perl6/2010-05-05#i_2296683 might help  :)

[16:36] <phenny> PerlPilot: 28 Apr 13:49Z <tadzik> tell PerlPilot I've sent you a pull request for Benchmark.pm

[16:36] *** PerlPilot is now known as PerlJam

[16:37] <PerlJam> phenny: you have a long memory :)

[16:44] *** zby_home_ joined
[16:50] *** raiph joined
[17:03] *** wk joined
[17:06] *** replore_ left
[17:12] *** benabik_ joined
[17:14] *** benabik left
[17:14] *** benabik_ is now known as benabik

[17:16] *** leont joined
[17:17] *** mucker left
[17:20] *** replore_ joined
[17:24] *** mucker joined
[17:25] *** replore_ left
[17:25] *** Pleiades` left
[17:27] *** wamba left
[17:29] *** Circlepuller joined
[17:29] *** Circlepuller left
[17:33] *** Pleiades` joined
[17:34] *** fhelmberger left
[17:37] <tadzik> wow :D

[17:38] <tadzik> that was before I knew PerlJam is PerlPilot :)

[17:42] *** wamba joined
[17:50] *** fridim_ left
[17:51] *** fglock joined
[17:57] *** cognominal_ left
[17:57] *** am0c joined
[18:03] <[Coke]> I am bemused that we are all hacking on #perl6, but still use IRC.

[18:04] *** killbot left
[18:04] <tadzik> why is that surprising?

[18:04] <sorear> masak: Nobody knows.

[18:04] *** cognominal joined
[18:05] <[Coke]> irc is like the perl3 of chat.

[18:06] <doy> what would you suggest as a replacement?

[18:06] <jnthn> MSN Messenger!

[18:06] <PerlJam> [Coke]: as soon as we get that telepathic link up and running, we can all join TIC (telepathic internet chat)

[18:06] <jnthn> .oO( The PHP of chat... )

[18:07] *** killbot joined
[18:08] <[Coke]> doy: my preference would be xmpp.

[18:09] * rjbs doesn't know of any xmpp clients half as useful as irssi.

[18:09] <rjbs> (Not that I need a vote in this, since I only show up to tell Coke to play D&D or to ask very basic questions.)

[18:10] <[Coke]> rjbs: dammit! I do want to play, really!

[18:10] <[Coke]> (that dammit was to me, not you!)

[18:10] <rjbs> [Coke]: :-)  Saturday!

[18:10] <[Coke]> rjbs: ironically? I've been playing a lot of skyrim lately.

[18:10] <tadzik> [Coke]: I guess the irc is just good enough, and xmpp doesn't really have any real advantage

[18:10] <[Coke]> actually, I do play skyrim ironically. Just to be hip.

[18:11] <sirrobert> does xmpp allow persistent channels?  that can be joined without invite?

[18:11] <tadzik> yes

[18:11] <sirrobert> I didn't know that

[18:11] <tadzik> one big cons: you need an xmpp account to join xmpp chat

[18:11] <sirrobert> what's it called?

[18:11] <sirrobert> tadzik: ahh

[18:11] <tadzik> I don't know if it's called anything

[18:11] <tadzik> I guess it's just MUC

[18:11] <sirrobert> just did a search for it but didn't know how to search for it =)

[18:11] <[Coke]> tadzik: yah, that's not a con.

[18:11] <sirrobert> xmpp channel

[18:11] <tadzik> oh yes it is

[18:12] <tadzik> "hey guys, move to this service. It serves the same purpose, but you need an account"

[18:12] <[Coke]> for guests? sure. For you and I? no it isn't. But you can allow guests.

[18:12] <[Coke]> tadzik: I /already/ need an account to use freenode.

[18:12] <tadzik> well, you get persistent identities on xmpp

[18:12] <doy> rjbs: "bitlbee"

[18:12] <tadzik> on irc we work around that, which is imperfect

[18:13] <[Coke]> tadzik: which, IMO, is a big enough reason to switch. But I am clearly outvoted, so the discussion is moot.

[18:13] <doy> [Coke]: you don't, really... it just whines at you a lot if you don't have one

[18:13] <doy> (:

[18:13] <tadzik> [Coke]: well, I'm quite a fan of xmpp myself

[18:13] <rjbs> doy: Hm.  I 've used that, but never for chat rooms on xmpp.  Hm.

[18:13] <doy> rjbs: i've never tried it with xmpp chat rooms, actually

[18:13] <doy> but it works fine for normal xmpp messages

[18:14] <tadzik> [Coke]: I guess the big win is that it's easier to bring people in to irc

[18:14] <tadzik> just "hey, click here and you're online"

[18:15] <[Coke]> tadzik: you can do the same with xmpp web chat, IIRC.

[18:15] <tadzik> [Coke]: is it possible to communicate on xmpp without an account?

[18:15] <[Coke]> tadzik: I believe so, yes.

[18:15] <tadzik> curious :)

[18:16] <[Coke]> let's assume it is: no one is switching, it's moot. :)

[18:16] <tadzik> is that specified in some XEP?

[18:16] * [Coke] stops talking about it because it's just depressing.

[18:16] <tadzik> now that you got me interested? You cruel person :)

[18:17] * tadzik goes to look at xmpp specs

[18:17] *** am0c left
[18:22] * [Coke] chuckles.

[18:23] <moritz> somebody[tm] could write a Perl 6 wrapper around libpurple (the IM lib that pidgin and some other clients ues)

[18:23] <moritz> *use

[18:24] <tadzik> hm

[18:24] <tadzik> I used loudmouth for clients I wrote, but it is absolutely horrible :)

[18:25] <tadzik> or maybe just horribly undermaintained

[18:25] <moritz> I've used none of those directly myself, from the usage patterns I just assumed that libpurple was a quasi-standard

[18:26] <tadzik> I think telepathy is now a go-to thing

[18:26] <tadzik> but maybe not :)

[18:27] *** mishin left
[18:28] <timotimo_> you can communicate on xmpp without accounts. it's how zeroconf chatting works

[18:28] <tadzik> cool

[18:28] <tadzik> do you have any technical links I could read?

[18:28] <timotimo_> but i don't think you can get onto the federated network like that

[18:29] <timotimo_> http://xmpp.org/extensions/xep-0174.html

[18:29] <tadzik> oh, nice

[18:40] <[Coke]> timotimo++

[18:40] <[Coke]> it has been a LONG time since I've read any xeps.

[18:43] * flussence found this sub-thread interesting, wondering how it'd go in p6; http://www.reddit.com/r/programming/comments/114x61/what_did_the_really_successful_programmers_do/c6jfkds?context=2

[18:43] <flussence> (and then I invariably ended up wondering what the heck andthen/orelse are used for...)

[18:43] <arnsholt> How attached can I expect people to be to S21 (Calling foreign code)?

[18:44] <flussence> arnsholt: meh, I've rewritten my code entirely once already, don't care :)

[18:44] <PerlJam> arnsholt: Why do you ask?

[18:45] <sirrobert> fluessence: a tabular return is appropriate there.  P6 may have some more terse syntax, though

[18:45] <arnsholt> I was going to spec the interface provided by NativeCall

[18:45] <jnthn> arnsholt: Go for it, imho

[18:46] <flussence> after actually looking at S21, +1

[18:46] <arnsholt> Cool

[18:46] <PerlJam> arnsholt: what they said :)

[18:46] <jnthn> S21 is...basically empty

[18:46] <arnsholt> I think I'll kill most of the stuff that's there, and relegate Perl 5 interop to a "how do we want this to work?" section

[18:47] *** bluescreen10 joined
[18:52] *** tadzik is now known as tadzikarp

[18:55] <[Coke]> jnthn: minor ping on nqp#59

[19:01] *** cognominal left
[19:02] *** cognominal joined
[19:03] *** brrt joined
[19:05] <brrt> p6: sub foo(|@args) {  say @args.elems }; foo(1,2,3)

[19:05] <p6eval> rakudo 870d18: OUTPUT¬´Obsolete use of | or \ with sigil on param @args‚ê§Nominal type check failed for parameter '@args'; expected Positional but got Capture instead‚ê§  in sub foo at /tmp/O9vIfrbjoT:1‚ê§  in block  at /tmp/O9vIfrbjoT:1‚ê§‚ê§¬ª

[19:05] <p6eval> ..niecza v22-7-g7df6137: OUTPUT¬´Potential difficulties:‚ê§  Unsupported use of | with sigil; nowadays please use | without sigil at /tmp/siNhJ8TWqb line 1:‚ê§------> [32msub foo(|@args[33m‚èè[31m) {  say @args.elems }; foo(1,2,3)[0m‚ê§‚ê§3‚ê§¬ª

[19:05] <brrt> p6: sub foo(|args) {  say |args.elems }; foo(1,2,3)

[19:06] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´Unhandled exception: Unable to resolve method Capture in type Int‚ê§  at /tmp/QyvKey6_jK line 1 (foo @ 5) ‚ê§  at /tmp/QyvKey6_jK line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4198 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting li‚Ä¶

[19:06] <p6eval> ..rakudo 870d18: OUTPUT¬´3‚ê§¬ª

[19:06] <brrt> how does this work?

[19:06] <brrt> also

[19:07] <brrt> p6: sub foo(|args) { say |args.elems }; foo(1, (2, 3), 4)

[19:07] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´Unhandled exception: Unable to resolve method Capture in type Int‚ê§  at /tmp/W4WMGkEMDr line 1 (foo @ 5) ‚ê§  at /tmp/W4WMGkEMDr line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4198 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting li‚Ä¶

[19:07] <p6eval> ..rakudo 870d18: OUTPUT¬´3‚ê§¬ª

[19:07] <sirrobert> sub foo (@args) { say @args }; foo(|@args);

[19:07] <sirrobert> r: sub foo (@args) { say @args }; foo(|@args);

[19:07] <p6eval> rakudo 870d18: OUTPUT¬´===SORRY!===‚ê§Variable @args is not declared‚ê§at /tmp/gTChAFUuwY:1‚ê§¬ª

[19:07] <brrt> in short

[19:07] <sirrobert> r: sub foo (@args) { say @args }; my @args = 1,2,3; foo(|@args);

[19:07] <p6eval> rakudo 870d18: OUTPUT¬´Nominal type check failed for parameter '@args'; expected Positional but got Int instead‚ê§  in sub foo at /tmp/JQFsT8Ry9n:1‚ê§  in block  at /tmp/JQFsT8Ry9n:1‚ê§‚ê§¬ª

[19:07] <brrt> does perl 6 do callee side argument flattening

[19:07] <sirrobert> yeah, you flatten when you call

[19:07] <sirrobert> not in the method sig (I'm pretty sure)

[19:07] <brrt> yeah, thats caller side

[19:08] <brrt> usually

[19:08] <brrt> i'm wondering about callee-side

[19:08] <sirrobert> ohh

[19:08] <sirrobert> sorry, dunno

[19:09] * brrt believes it is possible, and it has quite large implications

[19:10] <sirrobert> r: sub test ($foo, |@bar) { say $foo; say @bar.perl }; test(1,2,3,4);

[19:10] <p6eval> rakudo 870d18: OUTPUT¬´Obsolete use of | or \ with sigil on param @bar‚ê§Nominal type check failed for parameter '@bar'; expected Positional but got Capture instead‚ê§  in sub test at /tmp/y0Vhb0RrTd:1‚ê§  in block  at /tmp/y0Vhb0RrTd:1‚ê§‚ê§¬ª

[19:11] <sirrobert> r: sub test ($foo, *@bar) { say $foo; say @bar.perl }; test(1,2,3,4);

[19:11] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§Array.new(2, 3, 4)‚ê§¬ª

[19:11] <sirrobert> Is that what you wanted?

[19:11] <brrt> i knew that was possible :-) i'm wondering about the following case

[19:11] <brrt> r: sub text

[19:11] <p6eval> rakudo 870d18: OUTPUT¬´===SORRY!===‚ê§Missing block‚ê§at /tmp/CF3GOj6Zvl:1‚ê§¬ª

[19:12] <brrt> r: sub test($foo, *@bar) { say $foo; say @bar.perl }; test(1, 2, (3, 4))

[19:12] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§Array.new(2, 3, 4)‚ê§¬ª

[19:12] <brrt> damn you, perl6

[19:12] <sirrobert> I know what you mean:

[19:12] <brrt> back to the drawing board, it is

[19:12] <sirrobert> r: sub test($foo, *@bar) { say $foo; say @bar.perl }; test(1, 2, [3, 4])

[19:12] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§Array.new(2, [3, 4])‚ê§¬ª

[19:13] <sirrobert> right?

[19:13] <sirrobert> you want to flatten that?

[19:13] <brrt> yes

[19:13] <brrt> or, more properly

[19:13] <brrt> i want to know if perl6 will /allow/ flattening it

[19:13] <brrt> and, considering the 2, (3, 4) example, i'm guessing that it is

[19:14] <jnthn> r: sub test($foo, *@bar) { say $foo; say @bar.perl }; test(1, 2, (3, 4))

[19:14] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§Array.new(2, 3, 4)‚ê§¬ª

[19:14] <jnthn> r: sub test($foo, **@bar) { say $foo; say @bar.perl }; test(1, 2, (3, 4))

[19:14] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§LoL.new(2, $(3, 4))‚ê§¬ª

[19:14] *** tadzikarp is now known as tadzik

[19:14] <sirrobert> brrt, I think you have to flatten on the caller side for that.

[19:14] <jnthn> Dunno if that's what you're looking for

[19:14] <brrt> yeah, pretty much

[19:15] <brrt> jnthn: this means that a callee must be able to flatten the LoL of the caller

[19:16] <brrt> which is a Problem if you wish to implement it

[19:16] * jnthn doesn't quite see the problem.

[19:17] <brrt> great, then you might enlighten me :-)

[19:17] <jnthn> Or vice versa ;)

[19:17] <sirrobert> heh

[19:17] <brrt> ok, my problem, or challenge, is this

[19:17] <jnthn> A LoL preserves parcel structure.

[19:18] <jnthn> A normal *@foo flattens any flattening things that are passed.

[19:18] <brrt> (keep going please :-))

[19:18] <brrt> i wish to design and implement a bytecode that is high-level enough to implement many languages simultaneously and interoperably

[19:18] <brrt> i.e., i want to replace parrot

[19:19] <jnthn> Note that there's a difference between

[19:19] <jnthn> r: sub foo(*@a) { say @a.elems }; my @bar = 1,2,3; foo(@bar)

[19:19] <p6eval> rakudo 870d18: OUTPUT¬´3‚ê§¬ª

[19:19] *** daxim left
[19:19] <jnthn> r: sub foo(*@a) { say @a.elems }; foo([1,2,3])

[19:20] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§¬ª

[19:20] <jnthn> The [...] array constructor gives an item

[19:20] <jnthn> r: sub foo(*@a) { say @a.elems }; my @bar = 1,2,3; foo($@bar) # also

[19:20] <p6eval> rakudo 870d18: OUTPUT¬´===SORRY!===‚ê§Invalid hard reference syntax at line 2, near "@bar) # al"‚ê§¬ª

[19:20] <jnthn> er

[19:20] <jnthn> r: sub foo(*@a) { say @a.elems }; my @bar = 1,2,3; foo($(@bar)) # also

[19:20] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§¬ª

[19:21] <jnthn> More generally, things know if they will flatten or they are meant to be single items and that lives on with them when they are passed.

[19:22] <jnthn> (finished now, ask questions if you have 'em :))

[19:22] <brrt> yes, thanks :-)

[19:22] <brrt> ehm, my point was, in general

[19:23] <brrt> i had imagined a scheme where things that you want to flatten would provide an iterator

[19:23] *** Su-Shee left
[19:23] <brrt> i.e., a flattened hash would give an iterator for pairs

[19:24] <brrt> a flattened array would give an iterator for its items

[19:24] <brrt> however

[19:24] <brrt> if you can have callee-side flattening, this scheme fails

[19:25] <brrt> because my intention was to have the interpreter /not/ know which items can flatten

[19:25] <jnthn> If I was building Parrot's calling conventions again, I'd have the flatten thing just set a bit somewhere and leave the callee to figure out what to do

[19:26] <brrt> yeah, thats my back-to-the-drawing board plan

[19:26] <jnthn> Rakudo has a custom signature binder, fwiw.

[19:26] <jnthn> It kinda needs it.

[19:27] <jnthn> Binding Perl 6 signatures can lead to recursive calls into the binder, for example.

[19:27] <arnsholt> Regarding specs: are there any conventions for including speculations/marginalia into the text?

[19:27] <jnthn> arnsholt: I've seen things like (Conjectural: blah blah)

[19:28] <arnsholt> I'll go with that for the moment then. Some more experienced spec wrangler can fix it if it's too bad =)

[19:29] <sirrobert> what's the best way to do a method factory?  e.g.   class A { for <a b c> -> $name { method $name () {...} } };

[19:30] *** Su-Shee joined
[19:30] *** mucker left
[19:30] <brrt> jnthn: if you could read this: https://github.com/bdw/parakeet/blob/master/calling_conventions.md

[19:30] <brrt> and then tell me where i'm wrong

[19:30] <brrt> i'd be delighted

[19:30] <brrt> (although you have given me a pretty good idea)

[19:31] <jnthn> sirrobert: You should probably do that at BEGIN time

[19:31] <sirrobert> jnthn: hmm... ok

[19:31] <jnthn> And use the MOP I guess

[19:32] <jnthn> r: class A { BEGIN { for <a b c> -> $m { A.HOW.add_method(A, $m, method () { "method $m" }) } } }; say A.a; say A.c;

[19:32] <p6eval> rakudo 870d18: OUTPUT¬´method a‚ê§method c‚ê§¬ª

[19:33] <jnthn> hah, nailed it first time :)

[19:33] <sirrobert> heh nice

[19:33] <sirrobert> thanks

[19:33] <sirrobert> What does BEGIN { ... }mean inside a class declaration?

[19:33] *** zby_home_ left
[19:35] <jnthn> Same as it means anywhere else

[19:35] <jnthn> "Run this right now"

[19:35] * colomon has a grammar trace which has been running for three hours now...

[19:36] <jnthn> o.O

[19:36] <sirrobert> jnthn: ah.. I interpreted it as a different meaning in p5

[19:36] <jnthn> cognominal: Is it actually tracing?

[19:36] <colomon> jnthn: yes, and my names not cognominal.  ;)

[19:36] <jnthn> sirrobert: The thing to understand about classes is that as the parser runs over them, it makes a bunch of method calls.

[19:36] <jnthn> colomon: oops :)

[19:37] <jnthn> colomon: OK. This is Grammar::Tracer? :)

[19:37] <colomon> jnthn: yes

[19:37] <jnthn> It's not hung or messed up?

[19:37] <sirrobert> jnthn: ok, will think about that.

[19:37] <jnthn> 3 hours is...crazy long.

[19:37] <colomon> it's never stopped printing things out.  I think it might be in an endless loop of some sort

[19:37] <jnthn> Yeah

[19:37] <jnthn> I mean, it carries overhead compared to the normal un-traced parse but...

[19:38] <jnthn> ...that sounds excessive.

[19:38] <sirrobert> This also works.  Why would it be undesirable?

[19:38] <colomon> it never came back with a result in a non-traced run, which is why I switched over to traced.

[19:38] <sirrobert> r: class A { }; for <a b c> -> $m { A.HOW.add_method(A, $m, method () { "method $m" }) };     say A.a; say A.c;

[19:38] <p6eval> rakudo 870d18: OUTPUT¬´method a‚ê§method c‚ê§¬ª

[19:39] <colomon> jnthn: I kind of had a (late) birthday party after I started it, so I haven't been watching it very carefully.  It hasn't repeated itself in the last four minutes....

[19:41] <jnthn> colomon: OK. Maybe tracing really *is* that slow.

[19:43] <colomon> jnthn: it is parsing a 1.3 meg STEP file, so it is doing quite a lot of work.  (Just thought to look, and it is 4x longer than the next longest STEP file I've tried to parse, so maybe it's not too surprising it's slow.)

[19:44] *** birdwindupbird joined
[19:46] <brrt> also, isn't a Pair surprisingly like a cons?

[19:48] *** fgomez left
[19:49] <colomon> brrt: ;)

[19:50] <brrt> by the way... is it ever the intention we can 'flatten' an infinite list?

[19:51] <brrt> i.e., what happens now

[19:52] <brrt> r: sub foo(*@args) { say @args[0]; }; my @a = 1..Inf; foo(@a);

[19:52] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§¬ª

[19:52] <brrt> ... what happens to me now

[19:53] *** kaare__ left
[19:53] <jnthn> But we don't flatten there really 

[19:54] <jnthn> @args is an Array that contains @a and @a contains the Range and is flattening, so when you ask for @args[0] it asks for @a[0] which produces the first value from the range

[19:54] <jnthn> But that's nothing to do with calling conventions.

[19:54] <jnthn> Well, the creation of the outer Array for @args is I guess

[19:55] <brrt> basically

[19:55] <brrt> you're saying the callee makes a flattening array and therefore has to figure it out

[19:56] *** fgomez joined
[19:56] <jnthn> Well, the important flattening thing here is the @a

[19:59] <brrt> i guess that makes sense

[19:59] <brrt> se

[19:59] <sirrobert> how can I tell if two data structures match deeply?

[20:00] <jnthn> sirrobert: Did you try eqv?

[20:00] <sirrobert> no ... I've never used eqv yet =)

[20:00] <sirrobert> trying now

[20:00] <jnthn> OK, it may be what you want :)

[20:00] *** wamba left
[20:00] <sirrobert> jnthn:  yep, apparently it is =)

[20:01] <jnthn> \o/

[20:01] <brrt> the funny thing is

[20:01] <jnthn> colomon: It occurs to me I can probably make Grammar::Tracer perform a little better.

[20:01] <brrt> p6 binding is not even that hard

[20:01] <brrt> its just hard if you make cheap assumptions about it

[20:02] <brrt> r: sub foo($x, $y, $z) { say $x.perl; say $y.perl; say $z;perl }; foo(1,(2,3),4)

[20:02] <p6eval> rakudo 870d18: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&perl' called (line 1)‚ê§¬ª

[20:02] <brrt>  r: sub foo($x, $y, $z) { say $x.perl; say $y.perl; say $z.perl }; foo(1,(2,3),4)

[20:02] <p6eval> rakudo 870d18: OUTPUT¬´1‚ê§$(2, 3)‚ê§4‚ê§¬ª

[20:03] <brrt> $(2, 3) is a literal parcel?

[20:03] *** cognominal left
[20:03] <jnthn> It's a parcel in item context.

[20:03] <jnthn> (2, 3) # would flatten

[20:03] <jnthn> $(2, 3) # like (2, 3).item

[20:04] <colomon> jnthn: ooooo

[20:04] <jnthn> Actually $(2, 3) compiles to (2, 3).item

[20:04] <colomon> jnthn: still not repeating itself, BTW.

[20:04] <jnthn> I'm getting kinda tired for today, but I'll see if I can look at it tomorrow or so

[20:05] <colomon> jnthn: but the bad news is the file I really want to process is 12 megs, so if things are really this slow on a 1.3 meg file, I may be in trouble here.

[20:05] <jnthn> colomon: You need to process it with tracing?

[20:06] <jnthn> colomon: Grammar::Tracer slows down grammar execution quite significantly.

[20:07] <brrt> jnthn: thanks a lot

[20:07] <jnthn> I wrote it with "OK, I'm building a grammar and it doesn't work, let me work out where" in mind.

[20:07] <colomon> jnthn: no, I just need to process it.  But I'm doing the trace because the 1.3 meg file was so slow I thought it was in an infinite loop the tracer would help me find.  If instead it's really just that slow, then I've got big issues with running a 12 meg file.

[20:08] *** SamuraiJack_ left
[20:09] <jnthn> colomon: 3 hours sounds quite crazy. I mean, we chew through all 400 KB of CORE.setting - including building the AST - in not incredibly long.

[20:09] *** GlitchMr left
[20:09] <jnthn> Not with tracing, but still...

[20:10] *** cognominal joined
[20:11] <brrt> there is a factor of 30 difference only or so

[20:12] <jnthn> colomon: It's not backtracking in some place, is it?

[20:12] <jnthn> colomon: As in, it's all rule/token and not regex?

[20:15] <colomon> jnthn: all rule/token

[20:16] *** hash_table left
[20:20] <colomon> jnthn: I may just not have been showing enough patience, I just tried again (no trace, that's still running on a different machine) and it parsed the file in question in 3 minutes 47 seconds.  :)

[20:21] *** fglock left
[20:23] <arnsholt> perl6-language is the list for all things spec, right?

[20:23] *** birdwind1pbird joined
[20:24] *** wamba joined
[20:24] <sorear> ya

[20:25] * arnsholt signs up

[20:25] *** birdwindupbird left
[20:25] *** kurahaupo joined
[20:26] *** bbkr_ joined
[20:33] <bbkr_> star: use JSON::Tiny; use JSON::RPC::Client; try { CATCH { JSON::RPC::ParseError.new( data => ~$! ).throw };from-json( q|{"jsonrpc": "2.0", "method": "foobar, "params": "bar", "baz]| ) }

[20:33] <p6eval> star 2012.07: OUTPUT¬´use of uninitialized value of type Any in string context  in block <anon> at /tmp/r2pmhDBl2E:1‚ê§‚ê§Parse error (-32700): ""‚ê§¬ª

[20:33] *** Chillance left
[20:34] <jnthn> bbkr_: Inside CATCH, the current exception is in $_

[20:34] <bbkr_> do we have newest star available? code above SegFaults on 2012.09 on my machine

[20:34] <jnthn> (thus why it can be smart-matched on

[20:35] * jnthn wonders whihc star is running there

[20:35] <jnthn> star: say %*PERL<version>

[20:35] <p6eval> star 2012.07: OUTPUT¬´postcircumfix:<{ }> not defined for type Failure‚ê§  in method gist at src/gen/CORE.setting:9574‚ê§  in sub say at src/gen/CORE.setting:6980‚ê§  in block <anon> at /tmp/zgCUo4q9jU:1‚ê§‚ê§¬ª

[20:35] *** M_o_C joined
[20:35] <jnthn> star: say $*PERL

[20:35] <p6eval> star 2012.07: OUTPUT¬´("name" => "rakudo", "compiler" => {"name" => "rakudo", "ver" => "2012.07", "release-number" => "", "build-date" => "2012-07-28T09:39:00Z", "codename" => ""}).hash‚ê§¬ª

[20:35] <jnthn> ah

[20:35] <bbkr_> jnthn: I know, this is done on purpose (SegFault should not happen no matter how badly logic is broken)

[20:36] <jnthn> bbkr_: Indeed.

[20:36] <jnthn> bbkr_: Please file a ticket; golfing welcome if possible.

[20:37] <bbkr_> jnthn: I will after I isolate the root of the problem as much as possible.

[20:37] <jnthn> bbkr_: Thanks.

[20:37] <jnthn> When I get chance, I'll try and get it reproduced here under the debugger.

[20:38] <bbkr_> confirmation from someone running 2012.09 is still welcome, I'm not sure if it's Rakudo or OS fault

[20:38] <brrt> bbkr_: can you run it in gdb?

[20:40] <bbkr_> brrt, I'll try after I isolate the case a bit more

[20:41] <bbkr_> rakudo: try { CATCH { ~$! }; die } # shortest form that segfaults on my machine

[20:41] <p6eval> rakudo 870d18: OUTPUT¬´(signal SEGV)¬ª

[20:41] <bbkr_> rakudo: say $*PERL

[20:41] <p6eval> rakudo 870d18: OUTPUT¬´("name" => "rakudo", "compiler" => {"name" => "rakudo", "ver" => "2012.09.1-19-g870d189", "release-number" => "", "build-date" => "2012-10-07T20:14:14Z", "codename" => ""}).hash‚ê§¬ª

[20:42] <jnthn> eek

[20:42] <jnthn> rakudo: try { CATCH { say $! }; die }

[20:42] <p6eval> rakudo 870d18: OUTPUT¬´Mu()‚ê§‚ê§  in block  at /tmp/PvCL0g0K2j:1‚ê§‚ê§¬ª

[20:42] <jnthn> rakudo: try { CATCH { say pir::typeof__SP($!) }; die }

[20:42] <p6eval> rakudo 870d18: OUTPUT¬´Null PMC access in name()‚ê§  in block  at /tmp/z1hRUMISze:1‚ê§  in block  at /tmp/z1hRUMISze:1‚ê§‚ê§¬ª

[20:42] <jnthn> yowser

[20:43] <bbkr_> ?

[20:43] <jnthn> Yeah, that's bad.

[20:43] <colomon> jnthn: I just gave up on the long trace when I realized it was still only a third of the way through the file. 

[20:43] <jnthn> colomon: OK, so the tracer really is slow indeed. :)

[20:43] <jnthn> colomon: I'll see if I can't speed it up a bit :)

[20:44] <colomon> jnthn++

[20:45] <brrt> jnthn, bbkr_: works for me in gdb, although i have an oldish version

[20:45] <jnthn> Yeah, I'm thinking it's a regression that's snuck in and didn't get caught by spectest.

[20:45] <brrt> oh, wait, stringifying gives a segfault

[20:46] <bbkr_> RT #115184

[20:46] <jnthn> How old is your oldish?

[20:46] <brrt> in Rakudo_cont_decontainerize

[20:46] <jnthn> bbkr_: Thanks

[20:46] <brrt> 2012-07-359

[20:46] <brrt> old

[20:47] <brrt> cointainer.c, line 20

[20:47] <brrt> gdb is awesome

[20:47] <colomon> jnthn: yow, top says the 12 meg file has used up 4.5 gigs of memory so far in parsing.

[20:49] <brrt> anywhere i can post a backtrace?

[20:49] <jnthn> gist?

[20:49] <brrt> ok, data and _metadata of our pmc are null

[20:50] *** flightrecorder left
[20:50] *** flightrecorder joined
[20:50] <jnthn> I'm guessing it's a PMCNULL

[20:51] <brrt> probably

[20:51] <sorear> colomon: p6 parsers are slowww

[20:51] <brrt> basically, it derefs the data

[20:52] <colomon> sorear: it seems like it's the memory usage rather than the raw speed which is getting me...

[20:53] <brrt> i can't really figure out what opcodes cause it

[20:54] *** birdwind1pbird left
[20:56] <bbkr_> rakudo: say try { 666; CATCH { }; } # does this follow a spec? IMO place of phaser definition should be irrelevant to block return value.

[20:56] <p6eval> rakudo 870d18: OUTPUT¬´Nil‚ê§¬ª

[20:56] *** benabik left
[20:59] *** MayDaniel left
[21:01] <brrt> gist of backstrace

[21:01] <brrt> also

[21:01] <brrt> https://gist.github.com/3854954

[21:01] <brrt> Mu() is PMCNULL?

[21:01] <jnthn> No

[21:02] <brrt> it /appears/ to be so

[21:02] <jnthn> I think something somewhere is transforming it

[21:03] *** MayDaniel joined
[21:03] <brrt> added the pmc dump

[21:03] <brrt> to the gist

[21:03] <jnthn> oh, it blows up trying to do a multi-dispatch 

[21:03] <jnthn> Probably to prefix:<~>

[21:09] *** hash_table joined
[21:13] *** cognominal left
[21:13] *** fridim_ joined
[21:13] * brrt off

[21:15] * jnthn sleeps &

[21:17] *** brrt left
[21:19] *** cognominal joined
[21:21] <colomon> oh, the good news here is I successfully read a 4 meg file in 18.5 minutes

[21:22] * colomon wonders how long Niecza will take...

[21:23] *** cognominal left
[21:24] *** cognominal joined
[21:25] *** mtk left
[21:26] <sorear> slurp() should be decently fast since it's not looping at the p6 level :D

[21:26] *** mikemol left
[21:27] *** mikemol joined
[21:30] <diakopter> :D

[21:30] * diakopter wonders if there's a smiley for tongue-in-cheek

[21:31] <bbkr_> :ﬂ

[21:31] <diakopter> not in my font

[21:32] <bbkr_> (german double s)

[21:34] *** cognominal left
[21:34] <bbkr_> is phaser definition considered "a statement" considering a fact that it's tied to execution phase of a block rather than to position in this block?

[21:35] *** colomon left
[21:41] *** cognominal joined
[21:43] <bbkr_> rakudo: try { CATCH { }; die; }; say "alive"

[21:43] <p6eval> rakudo 870d18: OUTPUT¬´‚ê§  in block  at /tmp/SogYHm1UM4:1‚ê§‚ê§¬ª

[21:44] <bbkr_> hm, why is catched exception still causing code to die?

[21:48] <sorear> because you didn't catch the exception.

[21:48] <sorear> inside of a CATCH behaves as a given-block

[21:49] <sorear> if the exception is not matched by any when, it is not caughrt

[21:49] <sorear> r: try { CATCH { default { say $_ } }; die; }; say "alive"

[21:49] <p6eval> rakudo 870d18: OUTPUT¬´‚ê§  in block  at /tmp/NN9cdx7k3H:1‚ê§‚ê§alive‚ê§¬ª

[21:54] *** benabik joined
[21:57] <bbkr_> r: try {CATCH { return 1;}; die; }; say "alive"; # then why this example works?

[21:57] <p6eval> rakudo 870d18: OUTPUT¬´alive‚ê§¬ª

[21:58] <bbkr_> r: try {CATCH { 1;}; die; }; say "alive"; # and this does not, despite the fact that implicit block return value should behave in the same way in both cases?

[21:58] <p6eval> rakudo 870d18: OUTPUT¬´‚ê§  in block  at /tmp/_lAUdcPMDl:1‚ê§‚ê§¬ª

[21:59] <sorear> bbkr_: because "return" isn't the same as implicit block return.

[21:59] *** M_o_C left
[22:00] <TimToady> but there's no 'sub' there in either case

[22:00] *** fgomez left
[22:01] <TimToady> np: try {CATCH { return 1;}; die; }; say "alive";

[22:01] *** fgomez joined
[22:01] <TimToady> n: try {CATCH { return 1;}; die; }; say "alive";

[22:01] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´alive‚ê§¬ª

[22:01] <TimToady> n: try {CATCH { 1;}; die; }; say "alive";

[22:01] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´alive‚ê§¬ª

[22:01] <sorear> n still does not do lexical returns

[22:01] <bbkr_> niecza bug?

[22:02] <TimToady> there's nothing to return to, if CATCH is parsing as a block rather than a sub

[22:03] <TimToady> and I'd tend to argue that phasers should be considered blocks rather than subs

[22:04] *** MayDaniel left
[22:04] <bbkr_> so we have discrepancies between R and N here on "CATCH {1;}" case, which one behaves correctly?

[22:05] <sorear> no, bbkr, the discrepancy is with "try"

[22:05] <diakopter> rn: try {CATCH { 1; CATCH { say 55 }; die 4; }; die; }; say "alive";

[22:05] <sorear> in niecza, "try" eats uncaught exceptions

[22:05] <sorear> always

[22:05] <p6eval> rakudo 870d18: OUTPUT¬´(timeout)55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§55‚ê§5

[22:05] <p6eval> ..niecza v22-7-g7df6137: OUTPUT¬´55‚ê§alive‚ê§¬ª

[22:05] *** cognominal left
[22:05] <diakopter> 0_0

[22:06] <sorear> diakopter: dying in a catch block is a bad idea

[22:06] <diakopter> :)

[22:07] *** wtw left
[22:07] *** gugod left
[22:07] <diakopter> still. why does it recurse

[22:07] <bbkr_> rephrasing the question: should try{} consume uncaught exception or not?

[22:07] <doy> why is dying in a catch block a bad idea?

[22:07] <TimToady> well, more like CATCH in a CATCH is a bad idea; the spec handles dying in a CATCH block

[22:08] <diakopter> also, how can the inner CATCH go with the outer try, when there's no inner try

[22:08] *** aharoni left
[22:09] <diakopter> rn: try { try { try { die 66 } } }; say $!

[22:09] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´66‚ê§¬ª

[22:09] <p6eval> ..rakudo 870d18: OUTPUT¬´Any()‚ê§¬ª

[22:09] <sorear> doy: because the exception hasn't really been handled at that point, CATCH blocks are closer to filters than real exception handlers

[22:10] <sorear> doy: the stack isn't unwound until the catch block returns

[22:10] <spider-mario> I just discovered that perl5 actually supports string interpolation of arbitrary expressions

[22:10] <diakopter> so, $! isn't lexical to the inner try in niecza, but it is in rakudo; which is right

[22:10] <spider-mario> except for nested double quotes appearently

[22:10] <spider-mario> $ "${\('a' . 'b')}"

[22:10] <spider-mario> ab

[22:11] <spider-mario> a little more verbose than perl6‚Äôs {}, but still

[22:11] <TimToady> @{['a' . 'b']} is usual formulation, if list context doesn't get in your way

[22:12] <spider-mario> oh, I see

[22:12] <spider-mario> thanks

[22:12] *** PacoAir left
[22:12] *** cognominal joined
[22:13] <diakopter> rn: CATCH { BEGIN { say $! } }; 

[22:13] <p6eval> rakudo 870d18: OUTPUT¬´Mu()‚ê§¬ª

[22:13] <p6eval> ..niecza v22-7-g7df6137: OUTPUT¬´Any()‚ê§¬ª

[22:13] <diakopter> rn: say $!

[22:13] <p6eval> rakudo 870d18, niecza v22-7-g7df6137: OUTPUT¬´Any()‚ê§¬ª

[22:14] <spider-mario> it certainly doesn‚Äôt matter but ${} seems faster

[22:14] <spider-mario>        Rate    @    $

[22:14] <spider-mario> @ 1096074/s   -- -81%

[22:14] <spider-mario> $ 5892226/s 438%   --

[22:15] <spider-mario> but, hey, it‚Äôs string formatting after all. :p

[22:15] <spider-mario> it‚Äôs not like the user will notice, and it‚Äôs the expression inside that matter most anyway, I guess

[22:16] <spider-mario> matters*

[22:16] <diakopter> wth:

[22:16] <diakopter> rn: CATCH { say 66 }; die 4

[22:16] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´66‚ê§Unhandled exception: 4‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1437 (die @ 5) ‚ê§  at /tmp/3QHNBoQizv line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4198 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4199 (module-‚Ä¶

[22:16] <p6eval> ..rakudo 870d18: OUTPUT¬´4‚ê§  in block  at /tmp/JRnkKpmCzM:1‚ê§‚ê§¬ª

[22:16] <diakopter> rn: sub a() { CATCH { say 66 }; die 4 }; try { a }

[22:16] <p6eval> rakudo 870d18, niecza v22-7-g7df6137: OUTPUT¬´66‚ê§¬ª

[22:16] <cognominal> r:    for CORE.WHO.keys.sort { try { $_=eval $_; say $_.perl if $_ ~~ Code }}

[22:17] <p6eval> rakudo 870d18: OUTPUT¬´(timeout)sub ANON_ENUM(*@args) { ... }‚ê§sub AUTOTHREAD(&call, *@pos, *%named) { ... }‚ê§sub AUTOTHREAD_METHOD($name, *@pos, *%named) { ... }‚ê§sub COMP_EXCEPTION() { ... }‚ê§sub DIVIDE_NUMBERS(Int:D \nu, Int:D \de, $t1, $t2) { ... }‚ê§sub DUMP() { ... }‚ê§sub DYNAMIC(\name) {‚Ä¶

[22:17] <cognominal> a nice way to list subs in the CORE

[22:18] *** wamba left
[22:18] <diakopter> aha! :

[22:18] <diakopter> rn: my $a; try { $a = sub { CATCH { say 66 }; die 4 } }; $a()

[22:19] <p6eval> rakudo 870d18: OUTPUT¬´66‚ê§4‚ê§  in sub  at /tmp/k15G15jPxa:1‚ê§  in block  at /tmp/k15G15jPxa:1‚ê§‚ê§¬ª

[22:19] <p6eval> ..niecza v22-7-g7df6137: OUTPUT¬´66‚ê§Unhandled exception: 4‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1437 (die @ 5) ‚ê§  at /tmp/l91QU6Y8l_ line 1 (ANON @ 5) ‚ê§  at /tmp/l91QU6Y8l_ line 1 (mainline @ 10) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4198 (ANON @ 3) ‚ê§  at /home/p6eval/n‚Ä¶

[22:19] <cognominal> the try is necessary because of some stubbing

[22:19] *** wtw joined
[22:19] <diakopter> niecza dies 4; rakudo says 66

[22:19] <diakopter> sorear: I have no clue which is right

[22:19] <diakopter> oh wait.

[22:19] <diakopter> they both do both.

[22:19] <diakopter> <-- needs more coffee

[22:20] <cognominal> sub incore($type) {  for CORE.WHO.keys { try { $_=eval $_; say $_.perl if $_ ~~ Code and $_.signature.params>>.type >>~~>> $type;  } } } ; incore(Version)

[22:20] <diakopter> wait.

[22:21] *** gugod joined
[22:21] *** whiteknight joined
[22:21] <diakopter> why do they both do both? does it catch it or not?

[22:21] <cognominal> it should print core subs with an argument which match a $type, here Version,  but somehow its list everything :(

[22:21] <diakopter> why does it die 4 if it says 66

[22:21] <sorear> diakopter: it doesn't catch.

[22:21] *** bluescreen10 left
[22:21] <diakopter> how does it print 66

[22:22] <sorear> it enters the CATCH block, but you don't have anything in there to actually catch the exception.

[22:22] *** flightrecorder left
[22:22] *** FROGGS left
[22:22] <sorear> exceptions are caught by when statements inside CATCH blocks

[22:22] <diakopter> oh ...

[22:24] <cognominal> ho, an array of boolean is not a boolean!

[22:25] <bbkr_> TimToady: speaking of phasers - should phaser definition affect return value of a block like in "say try { 123; CATCH{} }" example? Spec says that in this case "the return value of a block is the value of its final statement" while phaser position cannot be described as "final" because it is executed in certain phase, not at the end of the block (in this case).

[22:25] <spider-mario> what d‚Äôyou think it is? fortran? J? :)

[22:27] *** _jaldhar joined
[22:27] <cognominal> r:  sub incore($type) {  for CORE.WHO.keys { try { $_=eval $_; say $_.perl if $_ ~~ Code and [&] $_.signature.params>>.type >>~~>> $type;  } } } ; incore(Version)

[22:27] <p6eval> rakudo 870d18: OUTPUT¬´(timeout)sub term:<time>() { ... }‚ê§sub term:<now>() { ... }‚ê§¬ª

[22:28] *** jaldhar left
[22:28] <cognominal> weird

[22:29] <sorear> bbkr_: the phaser is syntactically a statement and is treated as 'Nil;' for most purposes

[22:30] *** stopbit left
[22:32] <bbkr_> sorear: thanks, I was not sure if "statement" in this part of spec refers to syntax or something being executed

[22:33] <diakopter> rn: CATCH { 4 } while 0 { say 5 }; say "alive"

[22:34] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Strange text after block (missing comma, semicolon, comment marker?) at /tmp/15hPT7beWC line 1:‚ê§------> [32mCATCH { 4 }[33m‚èè[31m while 0 { say 5 }; say "alive"[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[22:34] <p6eval> ..rakudo 870d18: OUTPUT¬´alive‚ê§¬ª

[22:34] <diakopter> how could it parse that

[22:35] *** cognominal left
[22:36] * bbkr_ will try { "some sleep".get() } # good night

[22:36] *** spider-mario left
[22:36] *** bbkr_ left
[22:41] *** MikeFair_ left
[22:44] *** cognominal joined
[22:44] *** _jaldhar left
[22:46] *** MikeFair_ joined
[22:54] *** nebuchadnezzar left
[22:57] *** replore_ joined
[22:57] <diakopter> rn: say try { say 5; return try { 4 } }; say "alive"

[22:57] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´5‚ê§Unhandled exception: Illegal control operator: return‚ê§  at /tmp/VknWX79dZh line 1 (ANON @ 9) ‚ê§  at /tmp/VknWX79dZh line 1 (mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4198 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4199 (‚Ä¶

[22:57] <p6eval> ..rakudo 870d18: OUTPUT¬´5‚ê§¬ª

[23:00] <diakopter> rn: say try { die try { 4 } }; say "alive"

[23:00] <p6eval> rakudo 870d18: OUTPUT¬´4‚ê§  in block  at /tmp/9TsxcR3LUH:1‚ê§‚ê§alive‚ê§¬ª

[23:00] <p6eval> ..niecza v22-7-g7df6137: OUTPUT¬´Any()‚ê§alive‚ê§¬ª

[23:01] <diakopter> why doesn't rakudo catch it

[23:01] <diakopter> I mean.

[23:01] <diakopter> why does niecza catch it

[23:02] <diakopter> I mean. one of those.

[23:03] <sorear> diakopter: "try" in niecza always catches, whether or not the CATCH does anything

[23:03] <diakopter> oh. does rakudo do the wrong thing?

[23:04] <sorear> *shrug*

[23:10] *** drbean left
[23:11] <diakopter> r: eval 'say ' ~ 'try ' x 900 ~ '66'

[23:12] <p6eval> rakudo 870d18: OUTPUT¬´(timeout)¬ª

[23:12] <diakopter> n: eval 'say ' ~ 'try ' x 900 ~ '66'

[23:12] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´66‚ê§¬ª

[23:13] <diakopter> n: eval 'say ' ~ 'try ' x 3000 ~ '66'

[23:13] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´(timeout)¬ª

[23:13] *** _jaldhar joined
[23:14] <diakopter> so rakudo takes more than 10 ms per try

[23:14] *** drbean joined
[23:14] *** gfldex left
[23:14] <sorear> diakopter: I think that you're seeing quadratic behavior

[23:15] <sorear> r: eval 'try 66; ' x 900

[23:15] <p6eval> rakudo 870d18: OUTPUT¬´(timeout)¬ª

[23:15] <sorear> r: eval 'try { 66 }; ' x 900

[23:15] <p6eval> rakudo 870d18: OUTPUT¬´(timeout)¬ª

[23:15] <sorear> huh

[23:15] *** gfldex joined
[23:15] <sorear> n: eval 'try { 66 }; ' x 3000

[23:16] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´(timeout)¬ª

[23:16] <sorear> maybe not.

[23:16] <diakopter> niecza times out at at least 1750

[23:16] <diakopter> n: eval 'say ' ~ 'try ' x 1750 ~ '66'

[23:16] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´(timeout)¬ª

[23:16] <diakopter> trying to bisect

[23:17] <diakopter> like I did with rakudo

[23:17] <sorear> n: eval 'say ' ~ 'try ' x 50 ~ '66'; say times[0]

[23:17] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´66‚ê§1.180073‚ê§¬ª

[23:17] <sorear> n: eval 'say ' ~ 'try ' x 500 ~ '66'; say times[0]

[23:17] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´66‚ê§2.316144‚ê§¬ª

[23:18] <sorear> n: eval 'say ' ~ 'try ' x 1500 ~ '66'; say times[0]

[23:18] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´66‚ê§8.848553‚ê§¬ª

[23:18] <diakopter> hard to say due to startup time

[23:18] <diakopter> oh wait, what's times

[23:18] <sorear> n: say (2.316 - 1.180) / 450; say (8.848 - 1.180) / 1450

[23:18] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´0.0025244444444444446‚ê§0.0052882758620689651‚ê§¬ª

[23:19] <sorear> perldoc -f times

[23:19] <sorear> times[0] is noncumulative user time

[23:24] *** replore_ left
[23:25] *** benabik left
[23:26] <diakopter> rn: sub a() { eval 'return ' x 2000 ~ '5' }; say a

[23:27] <p6eval> rakudo 870d18, niecza v22-7-g7df6137: OUTPUT¬´(timeout)¬ª

[23:27] *** replore joined
[23:29] *** drbean left
[23:29] <diakopter> sorear: is there a way to measure niecza's time to lookup a unicode property like alpha

[23:30] *** replore left
[23:31] <diakopter> or rakudo's for that matter

[23:32] *** benabik joined
[23:33] <sorear> diakopter: depends a bit on what you mean I guess

[23:33] <diakopter> how long would it take to do a million

[23:33] <sorear> when you do <:alpha> in niecza it embeds an inversion list into the regex

[23:34] <diakopter> what's an inversion list

[23:34] *** drbean joined
[23:34] <sorear> actually it's a sorted list of intervals

[23:34] <sorear> does binary search to find the nearest interval, then checks membership

[23:35] *** carillke joined
[23:36] *** whiteknight left
[23:37] <diakopter> what's the golfedest way to check alpha on an alpha char

[23:37] <diakopter> in a regex let's say

[23:39] *** drbean left
[23:39] <diakopter> n: my $a = 'a'x 50000; say times[0]; $a ~~ /<alpha>*/; say times[0]

[23:39] *** leont left
[23:39] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´10.148634‚ê§10.24064‚ê§¬ª

[23:39] <diakopter> hm, is <alpha> the right thing

[23:40] <diakopter> I always forget the syntax

[23:41] <sorear> <alpha> works but <:alpha> will be faster

[23:42] *** MikeFair_ left
[23:45] <diakopter> n: my $a = 'a'x 50000; say times[0]; $a ~~ /<:Letter>*/; say times[0]

[23:45] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´10.196637‚ê§10.212638‚ê§¬ª

[23:47] <diakopter> I can't construct large strings fast enough to fit within p6eval's timeout

[23:48] <sorear> n: 'a' x 50000

[23:48] <p6eval> niecza v22-7-g7df6137:  ( no output )

[23:48] <sorear> n: say ('a' xx 50000).join

[23:48] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´(timeout)¬ª

[23:48] <sorear> n: say [~] 'a' xx 50000

[23:48] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa‚Ä¶

[23:49] <diakopter> ahhhh neat

[23:49] <sorear> [~] is using an internal StringBuilder

[23:49] <sorear> I think x is using the stupid quadratic algo

[23:50] *** MikeFair joined
[23:50] <diakopter> n: my $a = [~] 'a' xx 100000; say times[0]; $a ~~ /<:Letter>*/; say times[0]

[23:50] <p6eval> niecza v22-7-g7df6137: OUTPUT¬´7.860491‚ê§7.952497‚ê§¬ª

[23:58] *** cognominal left
