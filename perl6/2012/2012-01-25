[00:08] *** ggoebel left
[00:13] *** ggoebel joined
[00:22] *** thou left
[00:28] <[Coke]> phenny: tell ravendii about https://github.com/petdance/vim-perl

[00:28] <phenny> [Coke]: I'll pass that on when ravendii is around.

[00:28] *** thou joined
[00:29] <benabik> [Coke]: I'm pretty sure that's what I'm using, and I see the oddities with $s as well.

[00:30] *** lestrrat left
[00:32] *** lestrrat joined
[00:38] *** benabik left
[00:40] *** PacoAir left
[00:52] *** Chillance left
[00:58] *** molaf left
[00:58] *** thou left
[00:59] *** xeneg joined
[01:01] *** xeneg left
[01:01] <[Coke]> b: say 19373 - 19349 # 01/24/2012 - niecza at 99.87%

[01:01] <p6eval> b 1b7dd1: OUTPUT¬´24‚ê§¬ª

[01:01] <[Coke]> ARGH.

[01:04] *** tokuhirom left
[01:05] *** tokuhirom joined
[01:09] *** tokuhirom left
[01:11] *** replore_ joined
[01:13] *** molaf joined
[01:23] <colomon> I'm semi-on-the-job tonight, [Coke] 

[01:26] <rjbs-> TimToady: /me just sent you an email!

[01:26] *** rjbs- is now known as rjbs

[01:26] *** rjbs left
[01:26] *** rjbs joined
[01:32] <colomon> rakudo: say "a" ![!eq] "a"

[01:32] <p6eval> rakudo b7cce8: OUTPUT¬´Bool::True‚ê§¬ª

[01:36] <dalek> roast: 9fb6dac | (Solomon Foster)++ | S03-metaops/not.t:

[01:36] <dalek> roast: Three tests based on http://irclog.perlgeek.de/perl6/2012-01-24#i_5045770.

[01:36] <dalek> roast: review: https://github.com/perl6/roast/commit/9fb6dac04e

[01:39] <[Coke]> colomon: sweet.

[01:40] <sorear> good * #perl6

[01:41] <colomon> o/

[01:42] <colomon> niecza: multi sub infix:<[**]>() { 1; }; say [**] (); say [**] 1, 2, 3; 

[01:42] <p6eval> niecza v13-344-gf9b5518: OUTPUT¬´Potential difficulties:‚ê§  &infix:<[**]> is declared but not used at /tmp/xFO76LU__r line 1:‚ê§------> [32mmulti sub infix:<[**]>[33m‚èè[31m() { 1; }; say [**] (); say [**] 1, 2, 3[0m‚ê§‚ê§0‚ê§1‚ê§¬ª

[01:42] <colomon> niecza: multi sub infix:<[*]>() { 1; }; say [*] (); say [*] 1, 2, 3; 

[01:42] <p6eval> niecza v13-344-gf9b5518: OUTPUT¬´Potential difficulties:‚ê§  &infix:<[*]> is declared but not used at /tmp/0GYtNKI_1K line 1:‚ê§------> [32mmulti sub infix:<[*]>[33m‚èè[31m() { 1; }; say [*] (); say [*] 1, 2, 3;[0m‚ê§‚ê§0‚ê§6‚ê§¬ª

[01:43] <colomon> niecza: say [*] 1, 2, 3; multi sub infix:<[*]>() { 1; }; say [*] (); say [*] 1, 2, 3; 

[01:43] <p6eval> niecza v13-344-gf9b5518: OUTPUT¬´Potential difficulties:‚ê§  &infix:<[*]> is declared but not used at /tmp/8DwdhJ2P4O line 1:‚ê§------> [32msay [*] 1, 2, 3; multi sub infix:<[*]>[33m‚èè[31m() { 1; }; say [*] (); say [*] 1, 2, 3;[0m‚ê§‚ê§6‚ê§0‚ê§6‚ê§¬ª

[01:43] <colomon> niecza: say [*] 1, 2, 3; multi sub prefix:<[*]>() { 1; }; say [*] (); say [*] 1, 2, 3; 

[01:43] <p6eval> niecza v13-344-gf9b5518: OUTPUT¬´6‚ê§Unhandled exception: No candidates for dispatch to &prefix:<[*]>; candidates are:‚ê§    ‚ê§  at /tmp/C4IspXeXvK line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3424 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3425 (modul‚Ä¶

[01:44] <colomon> niecza: say [*] 1, 2, 3; multi sub prefix:<[*]>() { 1; }; my @a; say [*] @a; say [*] 1, 2, 3; 

[01:44] <p6eval> niecza v13-344-gf9b5518: OUTPUT¬´6‚ê§Unhandled exception: No candidates for dispatch to &prefix:<[*]>; candidates are:‚ê§    ‚ê§  at /tmp/BvsWKc585C line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3424 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3425 (modul‚Ä¶

[01:44] <sorear> it's not going to work

[01:46] <sorear> [Coke]: Whyfore ARGH?

[01:52] <rjbs> shift @ARGH

[01:59] *** REPLeffect left
[02:04] <colomon> I'm looking at S16-filehandles/chmod.t

[02:07] <colomon> It creates a temp file, then uses chmod to change permissions to 0o000, skips most of the tests because $*EUID is not defined / not true, and then tries to delete the temp file

[02:07] <colomon> but if the file permission was correctly set to 0o000, you can't delete it!

[02:08] <sorear> Why not?

[02:09] <sorear> / What do you mean?

[02:09] <colomon> no write permission on the file

[02:09] <colomon> that's what 0o000 means

[02:09] <sorear> you don't need write permission on a file to delete it

[02:09] <colomon> are you sure?

[02:09] <sorear> on UNIX anyway

[02:09] <colomon> you do on OS X

[02:09] <sorear> you need write permission on the *enclosing directory*

[02:10] <colomon> rm frip

[02:10] <colomon> rm: remove write-protected regular empty file `frip'?

[02:10] <sorear> rm -f frip

[02:11] <sorear> rm stats the file first and prompts you if it's write-protected, unless -f is given

[02:14] <colomon> I'm not saying the file is forever unremovable -- but I can promise you that niecza dies with System.UnauthorizedAccessException: Access to the path "temp_1327456824.112535" is denied.

[02:14] <colomon> on OS X at least, when you try to remove it.

[02:14] * colomon realizes he hasn't tried niecza on Linux in months...

[02:15] <sorear> I bet Mono is trying to emulate the Windows semantics here

[02:16] <colomon> seems quite possible

[02:16] *** Yary joined
[02:17] <Yary> Hi all, think I have a small Rakudo issue that's not in RT

[02:17] <Yary> From S06, using "sub MAIN ($directory);" with the semicolon at the end

[02:18] <sorear> nobody implements that form yet

[02:18] *** whiteknight joined
[02:18] <colomon> sorear: oh, right, the reason I haven't messed around with niecza on linux is that I had issues getting a decent mono up and running on it.

[02:18] <abercrombie> Hi perl6, a quick question: how do I apply ? to 'something' * 2..** to force minimum match?

[02:18] <Yary> OK

[02:19] <sorear> You have your stars backward

[02:19] <sorear> 'something ** 2..*

[02:19] <sorear> 'something' ** 2..*

[02:19] <abercrombie> yes, my typo, sorry.

[02:19] <sorear> I think it's: 'something' **? 2..*

[02:19] <abercrombie> ok, I will try it

[02:19] <sorear> although this is the reason ** is deprecated

[02:20] <sorear> wait, nvm

[02:21] <abercrombie> that's right, thanks.

[02:22] *** wolfman2000 joined
[02:35] *** thou joined
[03:03] *** whiteknight left
[03:24] *** orafu left
[03:24] *** orafu joined
[03:25] *** lutok left
[03:36] *** wolfman2000 left
[03:41] *** Patterner left
[03:43] *** Psyche^ joined
[03:43] *** Psyche^ is now known as Patterner

[03:45] <colomon> TimToady: ping?

[03:48] <TimToady> yes?

[03:48] <dalek> niecza: 93f71df | sorear++ | src/ (2 files):

[03:48] <dalek> niecza: Initial pass at importing STD changes

[03:48] <dalek> niecza: 

[03:48] <dalek> niecza: Sigilless \ and | things aren't actually supported yet, and there are

[03:48] <dalek> niecza: still ripple effects of the <initializer> change that need to occur.

[03:48] <dalek> niecza: review: https://github.com/sorear/niecza/commit/93f71df7fc

[03:49] <colomon> TimToady: I'm looking at getting your Set.pm working in niecza, and running it through the existing tests in set.t. 

[03:49] <colomon> TimToady: and I'm getting zillions of failures, and I need to work out whether they are code failures, niecza failures, or bad tests.

[03:50] <colomon> so I could use a consult.

[03:50] <sorear> TimToady: How bad is it if $a.WHICH eq $b.WHICH occasionally gives false positives?

[03:50] <sorear> TimToady: I can make $a.WHICH === $b.WHICH work reliably, but stringification creates problems

[03:51] <sorear> by "occasionally" I mean "about 2**-29 chance"

[03:51] <TimToady> well, hopefully we'll have real object keys someday, so it's probably not too bad for a temporary solution till then

[03:53] <TimToady> the main concern of using the stringification is security; if too many different keys can be forced to hash to the same bucket, you can get a DoS attack

[03:54] *** kcwu left
[03:55] <TimToady> to start with, I'm happy if only the sets of strings work reliably

[03:55] <colomon> TimToady: for instance, given my $s = set <a b foo>; does "is $s<santa>, False" make sense?

[03:55] <TimToady> I'm mostly interested in getting the API baked in soonish

[03:56] <TimToady> yes, it does

[03:56] <TimToady> to the extent that a set is treated as a hash, it behaves as a hash returning boolean

[03:56] <colomon> the spec says "Hash of True"

[03:56] <TimToady> of course a set can only return True

[03:57] <TimToady> so, I guess it doesn't necessarily make sense

[03:57] <TimToady> well, it'll make sense someday when we have defaults

[03:57] <colomon> why?

[03:57] <colomon> (defaults why?)

[03:57] <TimToady> because Sets will default to False

[03:57] <TimToady> and Bags will default to 0

[03:58] <TimToady> currently we can only get a default of Any, because it's hardwired

[03:58] <colomon> but you can't add to a Set anyway, so what difference does it make what the default is?

[03:58] <TimToady> API

[03:59] <TimToady> and the guarantee of returning a defined value

[03:59] <colomon> So, should I change postcircumfix:<{ }> with an // False, or should I remove the test?

[03:59] <TimToady> we can do // False for now

[04:00] <colomon> k

[04:00] <TimToady> it's not like a real Set type isn't going to hardwire that one way or another

[04:00] <TimToady> there's not even any guarantee that it must be implemented with a hash

[04:01] <colomon> Next failure is dies_ok { $s<a> = True }

[04:01] <TimToady> it merely fits into the API of Associative with a defined default value

[04:02] <colomon> apparently     method postcircumfix:<{ }> ($k) { %!elems{$k} // False }   is all you need to modify values in %!elems.

[04:03] <TimToady> and y'know, I don't think we even really need to define a default for every hash or array; it might be sufficient for the default value to be attached to the type

[04:03] <colomon> In this case I'm sure the code is wrong, but don't know whether it's a Set.pm issue or a niecza issue.

[04:03] <TimToady> at worst, if you really want different hashes with different values, you have to do a mixin for each

[04:04] <TimToady> is the proto defined "is rw"?

[04:05] <colomon> no

[04:05] <TimToady> normally %!elems{$k} should decontainerize when it returns so you can't assign to it

[04:06] <colomon> oh, that's interesting

[04:06] <TimToady> in the original nom code I stole from masak++, there's a method !STORE that dies

[04:06] <TimToady> but I think that's only for the set as a shole

[04:07] <colomon> I changed it to     method postcircumfix:<{ }> (*@k) { %!elems{|@k} // False }

[04:07] <TimToady> *whole

[04:07] <colomon> in an effort to handle $set<a b> as a test, and now assignment does fail

[04:07] <colomon> but multiple-element access still fails.

[04:08] <TimToady> well, it's probably supposed to be a \keys really anyway

[04:08] <TimToady> try \@k there maybe

[04:08] <colomon> that doesn't work in my copy of niecza (though I haven't upgraded to sorear++'s latest yet)

[04:08] <TimToady> \k parses but isn't implemented yet

[04:09] <colomon> nope, I get a Unable to resolve method Capture in class Str when I try to use it

[04:09] <colomon> I guess I should be brave and upgrade, I'm not going to manage to finish this before bed anyway.  :)

[04:10] *** raiph left
[04:10] <TimToady> probably wants something more like map -> $k { %!elems{$k} // False }, @k

[04:12] <TimToady>  or maybe just map -> $k { so %!elems{$k} }, @k

[04:13] <TimToady> ultimately, subscripts want to have something more like ** semantics, but we don't lol much yet

[04:14] <colomon> TimToady++ # map was a noticeable improvement

[04:15] <TimToady> I think just putting each lookup in boolean context should work

[04:15] <colomon> now the only remaining failures I get are the ones that assume type is preserved in the set

[04:16] <colomon> which is expected as long as hash keys are always strings, right?

[04:16] <TimToady> which we might possibly work around by storing the real value as part of the value, as long as we can guarantee it always returns true

[04:17] <TimToady> (in boolen context)

[04:17] *** DarthGandalf left
[04:17] <TimToady> but I'd rather have real === hashes

[04:18] <TimToady> hmm

[04:18] <TimToady> perl6: say so True => False

[04:18] <p6eval> rakudo b7cce8, niecza v13-345-g93f71df: OUTPUT¬´Bool::True‚ê§¬ª

[04:18] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&so"‚ê§    at /tmp/bOd4oC7lPZ line 1, column 5 - line 2, column 1‚ê§¬ª

[04:19] <TimToady> so if instead of storing True in the value we store True => $object, we could get $object back at need

[04:19] <TimToady> it's a hack, of course

[04:21] <sorear> TimToady: What I'm trying to ask is, "is WHICH stringification required to be reliable"?

[04:21] <sorear> TimToady: of course === shouldn't use Str

[04:23] *** replore_ left
[04:24] <TimToady> is your question really whether WHICH should form the basis of a reliable hash function?

[04:24] <dalek> roast: a2e9f04 | (Solomon Foster)++ | S02-types/set.t:

[04:24] <dalek> roast: Fudge for niecza.

[04:24] <dalek> roast: review: https://github.com/perl6/roast/commit/a2e9f04b77

[04:24] <TimToady> it can be argued that turning an object's WHICH into a string merely to hash it is wasted energy

[04:25] <TimToady> so maybe we need a HASH that can override the default that hashes WHICH.Str

[04:25] <TimToady> so a compound object could merely, say hash together the hashes returned by each of its compotnents

[04:26] <TimToady> *pone

[04:27] <TimToady> I think that WHICH itself must be unique when compared with === or eqv, but the stringification could be (a little) lossy

[04:29] <TimToady> a few bits leakage here or there is not a problem for DoS attacks, but if there are a large set of values that can map to the same hash function, you can be attacked

[04:30] <sorear> TimToady: I repeat, I am not planning to hash the stringificaiton in any official code

[04:30] <TimToady> for example, if the WHICH of a 64-bit floater only represented 32-bits worth, you can load 4 billion entries or so into the same hash slot

[04:30] <sorear> this is only for the sake of users silly enough to write $a.WHICH eq $b.WHICH

[04:30] <TimToady> I'm fine with probabalistic for that

[04:30] <sorear> ok

[04:32] <TimToady> after all, the whole of git runs on assuming no collisions in the hash space, though it's a pretty big hash space, as these things go...

[04:33] *** xinming left
[04:39] *** birdwindupbird joined
[04:42] <dalek> niecza: 314664d | (Solomon Foster)++ | lib/CORE.setting:

[04:42] <dalek> niecza: Import version of TimToady++'s Set class.  Alas, the operators are all commented out for the moment.

[04:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/314664db84

[04:42] <dalek> niecza: c347cd0 | (Solomon Foster)++ | t/spectest.data:

[04:42] <dalek> niecza: Turn on S02-types/set.t.

[04:42] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c347cd07c4

[04:46] <colomon> TimToady: thanks for your help

[04:47] <colomon> sorear: you might want to take a look at t/spec/S03-metaops/hyper.t, it's failing after your last patch.  (Or maybe because of set, but I cannot imagine how.)

[04:47] <colomon> 'night, all.

[04:48] <TimToady> o/

[04:59] *** thou left
[05:01] *** DarthGandalf joined
[05:10] *** thou joined
[05:21] *** Radvendii joined
[05:22] <Radvendii> nom: say <a b>.grep('a' !~~ /$_/)

[05:22] <p6eval> nom b7cce8: OUTPUT¬´‚ê§¬ª

[05:22] <Radvendii> ??

[05:23] <Radvendii> nom: <a b>.grep(say $_)

[05:23] <p6eval> nom b7cce8: OUTPUT¬´Any()‚ê§¬ª

[05:23] <Radvendii> nom: <a b>.grep(say *)

[05:23] <p6eval> nom b7cce8: OUTPUT¬´*‚ê§¬ª

[05:24] <Radvendii> nom: <a b>.grep(7say)

[05:24] <p6eval> nom b7cce8: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "<a b>.grep"‚ê§¬ª

[05:24] <Radvendii> nom: <a b>.grep(&say)

[05:24] <p6eval> nom b7cce8:  ( no output )

[05:24] <Radvendii> nom: <a b>.grep: {say $_}

[05:24] <p6eval> nom b7cce8:  ( no output )

[05:24] <sorear> Radvendii: you need to delay the evaluation somehow

[05:24] <sorear> .grep('a' !~~ /$_/) evaluates the expression before calling grep

[05:24] <Radvendii> which evaluation?

[05:25] <Radvendii> why would it do that?

[05:25] <Radvendii> doesn't it need to know what $_ is?

[05:25] <TimToady> it needs to know *when* $_ is

[05:25] <sorear> because Perl 6 uses something called "applicative order evaluation", whereby the arguments to functions are evalled before the function is called

[05:26] <sorear> as opposed to Haskell, which is pretty much the only "mainstream" language that uses the alternative, "normal order evaluation"

[05:26] <TimToady> I'm a bit surprised that your {say $_} didn't work

[05:26] <Radvendii> then how does .map: {} work?

[05:26] <sorear> {anything} evaluates to itself

[05:26] <Radvendii> ah

[05:27] <TimToady> nom: eager <a b>.grep: {say $_}

[05:27] <p6eval> nom b7cce8: OUTPUT¬´a‚ê§b‚ê§¬ª

[05:27] <TimToady> that's your problem

[05:27] <Radvendii> it's lazy evaluating?

[05:27] <Radvendii> hwo does that even make sense?

[05:27] <TimToady> it's not doing eager evalation by default

[05:27] <TimToady> nom: eager <a b>.grep: *.say

[05:27] <p6eval> nom b7cce8: OUTPUT¬´a‚ê§b‚ê§¬ª

[05:28] <TimToady> nom: sink <a b>.grep: *.say

[05:28] <cxreg> SPUG says hi

[05:28] <p6eval> nom b7cce8: OUTPUT¬´a‚ê§b‚ê§¬ª

[05:28] <Radvendii> sink?

[05:28] <sorear> hello, SPUG

[05:28] <sorear> Who is SPUG?

[05:28] * TimToady waves at SPUG

[05:28] <Radvendii> and why would it make a difference if it is lazy evaluating

[05:28] <cxreg> seattle.pm, particle is here

[05:28] <TimToady> if it never has any demand for the list of values, it never calls say

[05:29] *** xinming joined
[05:29] <sorear> particle's cool

[05:29] <TimToady> you guys still on Mercer Island?

[05:29] <Radvendii> nom: say <a b>.grep: *.say

[05:29] <p6eval> nom b7cce8: OUTPUT¬´a‚ê§b‚ê§a b‚ê§¬ª

[05:29] <Radvendii> ah

[05:29] <cxreg> TimToady: no, downtown

[05:30] <TimToady> lemme guess, Amazon...

[05:30] <cxreg> nope, marchex

[05:30] <cxreg> but today we're at a bar

[05:30] <TimToady> well that's...traditional... :)

[05:30] <cxreg> :-)

[05:31] * sorear wonders if there's any chance cxreg knows the Perl programmer friend of eirs who moved to Seattle years ago

[05:31] <cxreg> good chance of it, who?

[05:32] * TimToady has a number of ancient acquaintances in seattle...

[05:32] <Radvendii> nom: say <a b>.grep: {'a' ~~ *}

[05:32] <TimToady> plus 2 daughters and a grandson :)

[05:32] <p6eval> nom b7cce8: OUTPUT¬´a b‚ê§¬ª

[05:33] <Radvendii> as far as i know, 'a' ~~ 'b' evaluates to False

[05:33] <Radvendii> nom: say ?('a' ~~ 'b')

[05:33] <p6eval> nom b7cce8: OUTPUT¬´Bool::False‚ê§¬ª

[05:33] <Radvendii> yup

[05:33] <Radvendii> so why is it evaluating to true in the grep?

[05:33] <TimToady> because * is special to ~~

[05:33] <TimToady> it means match anything

[05:33] <cxreg> TimToady: well, you can be our next speaker then :D

[05:33] *** koban joined
[05:33] <Radvendii> oh. GAH. Splat means too much!!

[05:33] <TimToady> I've sworn off travel for this past while

[05:34] <Radvendii> nom: say <a b>.grep: {'a' ~~ $_}

[05:34] <p6eval> nom b7cce8: OUTPUT¬´a b‚ê§¬ª

[05:34] <sorear> cxreg: TimToady does not presently live in Seattle

[05:34] <cxreg> TimToady: well, come up soon :)

[05:34] <Radvendii> ha. why that?

[05:34] *** koban left
[05:34] <cxreg> yeah i know

[05:34] <TimToady> did too much last year, and crashed physically, so I'm taking it easy this year

[05:34] <cxreg> cool, good plan

[05:35] <TimToady> Radvendii: because the left side of ~~ *sets* $_ as a topicalizer

[05:35] <TimToady> nom: say <a b>.grep: -> $x { 'a' ~~ $x }

[05:35] <p6eval> nom b7cce8: OUTPUT¬´a‚ê§¬ª

[05:35] <TimToady> that's what you're looking for

[05:35] *** thou left
[05:35] <Radvendii> grumble grumble grumble

[05:35] <Radvendii> :P

[05:35] <Radvendii> thanks

[06:09] *** kaleem joined
[06:30] *** odoacre joined
[06:31] *** fsergot2 left
[06:35] <sorear> niecza: <a b> <<~>> <c d>

[06:36] <p6eval> niecza v13-347-gc347cd0: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 806 (warn @ 2) ‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 170 (Mu.Str @ 9) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/src/ST‚Ä¶

[06:36] <sorear> std: <a b> <<~>> <c d>

[06:36] <p6eval> std b808250: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[06:51] *** wtw joined
[06:53] <dalek> niecza: 6b3961c | sorear++ | src/STD.pm6:

[06:53] <dalek> niecza: Fix Texas hypers with list-assoc operators (how does this fix work?  why did it not fail before?)

[06:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6b3961c569

[06:54] *** kcwu joined
[07:10] *** Khisanth left
[07:11] <sorear> niecza: constant @foo = gather { take 1; take $_+1 for @foo }; say @foo[^12]

[07:11] <p6eval> niecza v13-348-g6b3961c: OUTPUT¬´Rebuild in progress‚ê§¬ª

[07:14] <sorear> niecza: constant @foo = gather { take 1; take $_+1 for @foo }; say @foo[^12]

[07:14] <p6eval> niecza v13-348-g6b3961c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Variable @foo is not predeclared at /tmp/d8gOyTNv4P line 1:‚ê§------> [32mt @foo = gather { take 1; take $_+1 for [33m‚èè[31m@foo }; say @foo[^12][0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/COR‚Ä¶

[07:15] <sorear> niecza: my ($x) = $x;

[07:15] <p6eval> niecza v13-348-g6b3961c:  ( no output )

[07:24] *** Khisanth joined
[07:28] <sorear> std: my \term:<‚àû> = Inf; say ‚àû

[07:28] <p6eval> std b808250: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Term definition requires an initializer at /tmp/psLRf4C6xT line 1:‚ê§------> [32mmy \term[33m‚èè[31m:<‚àû> = Inf; say ‚àû[0m‚ê§Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument a‚Ä¶

[07:29] <sorear> phenny: tell TimToady my \term:<‚àû> = Inf; still doesn't work because <identifier> won't parse past the colon.  What's the best fix here?

[07:29] <phenny> sorear: I'll pass that on when TimToady is around.

[07:30] <dalek> niecza: 552a38b | sorear++ | src/ (2 files):

[07:30] <dalek> niecza: Fix self-referential constants; add my \foo = ... syntax

[07:30] <dalek> niecza: review: https://github.com/sorear/niecza/commit/552a38bcf2

[07:32] *** Radvendii left
[07:38] *** lutok joined
[07:44] <sorear> nom: say ((5 but True) === (5 but False))

[07:44] <p6eval> nom b7cce8: OUTPUT¬´Bool::True‚ê§¬ª

[07:44] <sorear> ^^^ interesting infelecity

[07:45] <sorear> nom: my $a = do { role Moo { method x() { True } }; 5 but Moo }; my $b = do { role Moo { method x() { False } }; 5 but Moo }; say $a.x; say $b.x; say $a.WHICH; say $b.WHICH; say $a === $b

[07:45] <p6eval> nom b7cce8: OUTPUT¬´None of the parametric role variants for 'Moo' matched the arguments supplied.‚ê§Ambiguous dispatch to multi '_block1400'. Ambiguous candidates had signatures:‚ê§:(Mu )‚ê§:(Mu )‚ê§‚ê§  in specialize at src/gen/Metamodel.pm:1818‚ê§  in <anon> at src/gen/Metamodel.pm:2075‚ê§  in <ano‚Ä¶

[07:45] <sorear> nom: my $a = do { my role Moo { method x() { True } }; 5 but Moo }; my $b = do { my role Moo { method x() { False } }; 5 but Moo }; say $a.x; say $b.x; say $a.WHICH; say $b.WHICH; say $a === $b

[07:45] <p6eval> nom b7cce8: OUTPUT¬´Bool::True‚ê§Bool::False‚ê§Int+{Moo}|5‚ê§Int+{Moo}|5‚ê§Bool::True‚ê§¬ª

[07:46] <sorear> ^^^ longer version which will thwart jnthn's attempt at an easy fix for the short version

[07:47] <sorear> I think what's really up here is that the WHICH return needs to include .HOW.WHICH, and that needs to incude a WHERE descriminant

[07:50] <sorear> std: :(\foo)

[07:50] <p6eval> std b808250: OUTPUT¬´Can't call method "Str" on unblessed reference at STD.pm line 40751.‚ê§FAILED 00:01 109m‚ê§¬ª

[07:50] <sorear> std: sub (\foo) {}

[07:50] <p6eval> std b808250: OUTPUT¬´Can't call method "Str" on unblessed reference at STD.pm line 40751.‚ê§FAILED 00:01 109m‚ê§¬ª

[07:51] <sorear> std: sub (:\foo) {}

[07:51] <p6eval> std b808250: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[07:51] <sorear> std: sub (:cow(\foo)) {}

[07:51] <p6eval> std b808250: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed parameter at /tmp/0VT0S9Egof line 1:‚ê§------> [32msub (:cow([33m‚èè[31m\foo)) {}[0m‚ê§    expecting any of:‚ê§        name‚ê§   named_param‚ê§    parameter‚ê§      routine_def‚ê§    signature‚ê§Parse failed‚ê§FAILED 00:01 109m‚ê§¬ª

[07:52] <sorear> phenny: tell TimToady sub (:\foo) is accepted but sub (:foo(\bar)) is rejected.  Shouldn't param_var accept \bar ?

[07:52] <phenny> sorear: I'll pass that on when TimToady is around.

[07:52] <sorear> phenny: tell TimToady STD croaks on sub (\foo) {} with an unblessed reference error

[07:52] <phenny> sorear: I'll pass that on when TimToady is around.

[08:10] *** sudokode left
[08:11] *** sudokode joined
[08:15] <moritz> nom: push @*INC, $@*INC

[08:15] <p6eval> nom b7cce8: OUTPUT¬´===SORRY!===‚ê§Unsupported use of $@ variable as eval error; in Perl 6 please use $! at line 1, near "*INC"‚ê§¬ª

[08:16] <sorear> phenny: tell TimToady There are a few places in Niecza that use method foo(\$: ...) { } to force 'self' to be bound as a parcel.  What should be written now?

[08:16] <phenny> sorear: I'll pass that on when TimToady is around.

[08:17] <dalek> niecza: 69a1984 | sorear++ | / (2 files):

[08:17] <dalek> niecza: Implement \foo and |foo parameter forms, use them in setting where possible

[08:17] <dalek> niecza: review: https://github.com/sorear/niecza/commit/69a198459d

[08:18] <moritz> o/

[08:18] <sorear> /o

[08:23] *** mikemol left
[08:24] <sorear> hmm, perhaps WHICH should only include class info for immutable types

[08:24] *** mikemol joined
[08:25] <sorear> with a mutable type, you can use 'does' on it

[08:25] <moritz> sorear: fwiw I don't believe that WHICH can or should be a macro

[08:25] <sorear> and my thought is that WHICH for an object should never change )except in the case where you mix in a role that overrides WHICH)

[08:26] <moritz> so you think that   (3 but SomeRole) === 3  should be true?

[08:26] <sorear> no

[08:27] <moritz> so all roles override WHICH?

[08:27] <sorear> but isn't a mutator

[08:28] <sorear> what I'm saying is that my $a = MyClass.new; say $a.WHICH; $a does MyRole; say $a.WHICH; # shouldn't change

[08:28] <sorear> Int.WHICH can get away with including the type because Int subclasses can't change type

[08:28] <sorear> 3 does MyRole # forbidden!

[08:29] <moritz> "subclasses can't change type"?

[08:29] <sorear> on the other hand, Int.WHICH *has* to include the type, because of the example you just gave

[08:29] <moritz> subclassing is a type change, no?

[08:29] <sorear> no

[08:29] <sorear> subclassing creates a new type

[08:29] <sorear> subclassing does not magically cause existing objects to change type

[08:30] <moritz> right

[08:30] <sorear> [instances of (subclasses of Int)] cannot (change type)

[08:30] <moritz> nom: class A { }; role B { }; my $x = A.new; say $x.WHICH; $x does B; say $x.WHICH

[08:30] <p6eval> nom b7cce8: OUTPUT¬´A|-8491906571934514453‚ê§A+{B}|-8491906571934514453‚ê§¬ª

[08:31] <sorear> niecza: my $obj = 5; $obj does role { }

[08:31] <p6eval> niecza v13-349-g552a38b: OUTPUT¬´Unhandled exception: Cannot use 'does' operator with an immutable object‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1303 (die @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1242 (infix:<does> @ 6) ‚ê§  at /tmp/xE_E2vA9xi line 1 (mainline @ 2) ‚ê§  a‚Ä¶

[08:43] *** _twitch joined
[08:45] *** robinsmidsrod left
[08:45] * sorear -> sleep

[08:48] *** rsimoes1 left
[08:49] *** rsimoes1 joined
[08:51] *** robinsmidsrod joined
[09:12] *** grondilu joined
[09:12] <masak> morning, #perl6

[09:12] <moritz> \o masak 

[09:13] <masak> 6-peeps, only four days remain until the final p6cc deadline!

[09:21] *** grondilu left
[09:32] <dalek> rakudo/nom: 1cce955 | moritz++ | src/ (2 files):

[09:32] <dalek> rakudo/nom: typed exception for "Cannot use bind operator with this LHS"

[09:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1cce955e52

[09:32] <dalek> rakudo/nom: 5cf8452 | moritz++ | src/ (2 files):

[09:32] <dalek> rakudo/nom: typed error for binding to native types

[09:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5cf8452fda

[09:32] <dalek> rakudo/nom: 27a5dd3 | moritz++ | src/Perl6/Actions.pm:

[09:32] <dalek> rakudo/nom: more binding exception fixes

[09:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/27a5dd3bbd

[09:32] *** daxim joined
[09:33] *** Alias left
[09:33] <dalek> roast: a824698 | moritz++ | S32-exceptions/misc.t:

[09:33] <dalek> roast: typed binding excpetions

[09:33] <dalek> roast: review: https://github.com/perl6/roast/commit/a8246984e0

[09:33] *** Alias joined
[09:35] *** preflex left
[09:37] *** preflex joined
[09:37] *** Bucciarati left
[09:37] *** pomysl left
[09:38] *** pomysl joined
[09:39] <jnthn> mornin'

[09:40] <moritz> \o

[09:41] <masak> jnthn! \o/

[09:41] <moritz> in arguments to rules, what slang is used?

[09:41] <moritz> ie / <.panic: HERE> /

[09:42] *** Bucciarati joined
[09:43] <moritz> that's nqp regexes, fwiw

[09:45] <masak> well, S05 has an example <.gather { take foo($¬¢,1,2,3) }>

[09:45] <masak> which leads me to think that it's mainline p6 slang.

[09:45] <masak> if that makes any sense.

[09:46] <jnthn> moritz: Re-enters <LANG('MAIN', ...> or so iirc

[09:46] <moritz> ok

[09:46] <masak> right.

[09:46] <moritz> I was thinking about the best way to throw typed exceptions from the grammar

[09:46] <jnthn>     token arglist {

[09:46] <jnthn>         <arglist=.LANG('MAIN','arglist')>

[09:46] <jnthn>     }

[09:47] <masak> though S05 doesn't even mention the <.foo: |@arglist> syntax; only the <.foo(|@arglist)> syntax.

[09:47] <jnthn> masak: Sure I saw that syntax on a recent pass through S05...

[09:47] <masak> then I missed it.

[09:47] <jnthn> moritz: $*W is available in the grammar.

[09:48] <moritz> replacing <.panic: 'Malformed Regex'> with { $*W.throw($/, ['X', 'Syntax', 'Regex']) } is possible

[09:48] <moritz> but a bit ugly

[09:48] <moritz> I could make another panicy wrapper that looks like

[09:48] <moritz> <.typed_panic: 'X::Syntax::Regex'>

[09:48] <jnthn> moritz: That's be preferable

[09:48] <moritz> when then simply redispatches the latter

[09:49] <moritz> s/when/which/

[09:50] <moritz> would that simply be a method in Perl6::Grammar?

[09:50] <moritz> nom: /=/

[09:50] <p6eval> nom b7cce8: OUTPUT¬´===SORRY!===‚ê§Unrecognized regex metacharacter (must be quoted to match literally) at line 1, near "/"‚ê§¬ª

[09:50] <jnthn> moritz: Writing a method for it would work, yes

[09:51] <moritz> jnthn: and in that method, how do I get a $/ ?

[09:51] <jnthn> moritz: Why do you need $/?

[09:51] <jnthn> moritz: Or better asked: what info do you really need?

[09:52] <jnthn> moritz: If you do $/.CURSOR.pos() or so, then you can just do self.pos() in your method

[09:52] <tadzik> 'morning

[09:52] <moritz> jnthn: well, I want to pass it to Perl6::World.throw, which calls $/.from, $/.orig and $/.CUROSR.panic

[09:53] <moritz> (the latter as a fallback while compiling the setting)

[09:54] <jnthn> moritz: Ah. If you were passing the cursor rather than the match object to Perl6::World.throw it woulda been easier here :)

[09:54] <jnthn> moritz: Well, you can always get a $/ by writing it as a token instead of a method, then putting a codeblock inside.

[09:54] <jnthn> moritz: oh

[09:54] <moritz> jnthn: well, then I have to write $/.CURSOR in Actions.pm everywhere

[09:55] <moritz> how does the token get the match object?

[09:55] <moritz> something as simple as self.MATCH?

[09:55] <jnthn> oh, yeah

[09:55] <jnthn> You can do that :)

[09:55] <moritz> or self.CURSOR.MATCH?

[09:55] <jnthn> If you write a method foo() { } in a grammar, self is a Cursor

[09:56] <moritz> ok

[09:56] <jnthn> So just self.MATCH()

[09:57] *** dakkar joined
[10:18] *** _twitch left
[10:29] *** Yary left
[10:36] *** _twitch joined
[10:37] *** xinming left
[10:41] *** GlitchMr joined
[10:45] *** _twitch left
[10:51] *** xinming joined
[11:07] <bbkr> rakudo: say so \() ~~ :(); # bug or NYI? IMO it should return true

[11:07] <p6eval> rakudo 27a5dd: OUTPUT¬´Bool::False‚ê§¬ª

[11:07] *** Chillance joined
[11:10] <jnthn> NYI

[11:17] <moritz> nom: for (1; 1; 1) { }

[11:17] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§Unsupported use of C-style "for (;;)" loop; in Perl 6 please use "loop (;;)" at line 1, near "(1; 1; 1) "‚ê§¬ª

[11:45] *** Alias_ joined
[11:46] *** Alias left
[11:49] *** bbkr2 left
[11:55] *** xinming left
[12:06] *** Grrrr joined
[12:13] *** bkolera joined
[12:22] *** mtk joined
[12:22] *** mtk left
[12:22] *** mtk joined
[12:31] *** MayDaniel joined
[12:31] <daxim> http://perlmonks.org/index.pl?node_id=949890

[12:32] *** MayDaniel left
[12:35] *** mj41 left
[12:37] *** bluescreen10 joined
[12:40] *** kaleem left
[12:44] *** benabik joined
[12:49] <masak> on the Perl course I gave these last two days, I finished off with a Perl 6 section.

[12:49] *** skids joined
[12:49] <masak> reaction seems to have been a mix of "ok, so I'm definitely gonna learn Perl 6 now" and "hm, this is nothing that I think I need for what I do"

[12:49] <masak> which is fine.

[12:50] *** mj41 joined
[12:50] <masak> got the question "so when will it be, you know, here?" to which I answered "both major compilers make releases each month. each one more stable and featureful than the last."

[12:50] <masak> to which the reaction was something like "oh!"

[12:51] <masak> then I added "the the speed, memory leanness, and stability we deliver may not be within your required range yet. there's no conduit to CPAN beyond Blizkost."

[12:51] <masak> to which the reaction was something like "oh :/"

[12:54] *** am0c joined
[12:56] * skids looking forward to trying out Zavolaj when he gets the time, psyched to see work in this area.  jnthn++

[12:58] <skids> Was wondering if endian-reversed representations were on the TODO list.

[12:59] <moritz> why would you want such a thing?

[13:00] <moritz> for NCI?

[13:02] <skids> moritz: network packet buffer processing

[13:02] <moritz> skids: sounds more like a job for pack/unpack than for reprs

[13:03] <skids> I beg to differ.

[13:03] <moritz> how so?

[13:03] <skids> No reason an IP header should not be a viable object.

[13:04] <moritz> well, for IP headers you'd need a custom, bit-packed repr anyway, no?

[13:05] <masak> right. let's keep separate "values of the attributes" of an IP header object, and "serialization format" of same.

[13:05] <masak> that's what reprs are for :)

[13:05] <moritz> well, not exactly

[13:06] <moritz> that's what serialization formats are for

[13:06] <masak> hm, yes.

[13:06] <masak> it's three different things.

[13:06] <moritz> of course you *can* create a custom REPR that happens to have the same storage format as the serialization

[13:06] <masak> nod

[13:07] *** _twitch joined
[13:07] <skids> I kinda cringe when I hear "serialization format" because it sort of implies bounce-buffer semantics, when I could very well want to work on a live register set mmio region.

[13:07] * flussence wants a struct() or something, that takes a single pack() format and returns an object with .pack(*@values) and .unpack(Buf) methods

[13:08] * skids wants same, but regex-based :-)

[13:10] <skids> Anyway I'm sure it's all doable, just need to find the tiime to learn enough guts to do it.

[13:10] <benabik> Is it possible to send information from the class definition to the REPR?  I.E.  class IPPacket is REPR(EndianREPR) { ...; has int16 $.length is endianness(NetworkByteOrder); ... }

[13:10] <jnthn> Well, the point of doing NCI with REPR stuff is that it stores the data as it needs to be in native land.

[13:10] <masak> a repr would be perfect for something like libxml, where the objects coming in from C already have a given format. so we want to pass those objects around in Perl 6 without converting them, but they should behave like real Perl 6 obejcts.

[13:11] <masak> ...jnthn said it much shorter than I did :)

[13:11] <jnthn> masak: No, you don't need a custom REPR for that. You just declare a class XmlThingy is repr('Struct') { }

[13:11] <jnthn> And then in that class declare the attributes as the elements of the structure

[13:12] <jnthn> A REPR tends to correspond to a world view on arranging stuff in memory. C structures *in general* therefore are a candidate for being a representation.

[13:16] <masak> jnthn: oh!

[13:16] <masak> even better.

[13:16] <benabik> jnthn: Do REPRs receive any information on the annotations attached to attributes?  Could you say `has int32 $!val is NetworkByteOrder` and get it to DTRT?

[13:16] <masak> still, reprs are involved somehow... :)

[13:16] *** GlitchMr left
[13:16] <[Coke]> sorear: argh because only down by 25 tests yesterday. so close.

[13:16] <masak> benabik: an excellent question.

[13:17] <jnthn> masak: Yeah, people just have a tendancy to think "oh, I need a custom REPR for X" way too often :)

[13:17] <skids> benabik: more or less precisely what I was wondering.

[13:18] <jnthn> benabik, skids: When you declare a new type, the REPR's type_object_for is called. It receives the meta-object for the type in question.

[13:18] <jnthn> That can (though you'd best wait until declaration is done with) be used to get at the meta-attributes, which in turn mean you can get at the attribute type, plus if any traits were mixed in you can get at the values from those too.

[13:19] <jnthn> So basically, yes, though there's no explicit passing mechanism, it's just that all such information about a type is reachable through its meta-object somehow. :)

[13:19] <jnthn> That's how CStruct and P6opaque compute memory layouts.

[13:20] *** _twitch left
[13:22] <[Coke]> (4 days left until p6cc deadline). Guess I'm losing! ;)

[13:24] <masak> depends how you spend those 4 days... :)

[13:24] <benabik> jnthn: (poking through src/6model)  It looks like P6opaque is lazy about calculating its size, and only does so when it really needs it (via compute_allocation_strategy), right?

[13:24] <jnthn> benabik: Correct, though there is a little more to it than that (more)

[13:25] <jnthn> type_object_for is called too early for you to do the compuation.

[13:25] <colomon> perl6: my $a := 1, 2; say $a

[13:25] <p6eval> pugs b927740, niecza v13-350-g69a1984: OUTPUT¬´1‚ê§¬ª

[13:25] <p6eval> ..rakudo 27a5dd: OUTPUT¬´1 2‚ê§¬ª

[13:26] *** fdgbch456 joined
[13:27] <masak> colomon: "The binding operator parses as a list assignment, so it is reasonable to

[13:27] <masak> generate a list on the right without parens"

[13:27] <moritz> rakudo++

[13:27] <masak> S03:2299

[13:27] <fdgbch456> hi

[13:27] <masak> fdgbch456: hello!

[13:28] <colomon> masak: niecza's handling of that changed sometime in the last two days.

[13:28] <benabik> jnthn: The REPR is initialized (more or less) at the beginning of the class, right?  (NQPClassHOW.new_type).  Is there a reason it couldn't be delayed until compose()?  It seems like it would be very difficult to determine how much memory you need before then.

[13:29] <fdgbch456> i'm following the instructions on http://rakudo.org/how-to-get-rakudo/ and it says i need to install "the ICU library." So i'm downloading "icu4c-4_8_1_1-src.tgz", is it correct ?

[13:29] <moritz> fdgbch456: what operating system are you using?

[13:30] <moritz> fdgbch456: and how do your pronounce your nick name?

[13:30] <jnthn> benabik: We need the type object right away

[13:30] <fdgbch456> i figured i don't need icu4J (?)

[13:30] <fdgbch456> i'm using Ubuntu 11.10

[13:30] <moritz> fdgbch456: there should be a libicu-dev package that you can install with your package manager

[13:30] <jnthn> nom: class A { method m() { say 'oh lol' }; BEGIN { A.m } }

[13:30] <p6eval> nom 27a5dd: OUTPUT¬´oh lol‚ê§¬ª

[13:30] <moritz> fdgbch456: which is much easier for you

[13:30] <fdgbch456> lol...oh, its just a random ncik

[13:31] <fdgbch456> ok, will try ap-get then...

[13:31] <jnthn> benabik: See ^

[13:31] <moritz> fdgbch456: at leat it's called libicu-dev on debian, and usually the package names are the same

[13:32] <benabik> jnthn: I don't (immediately) see how that works.  Is it composing it mid-class?

[13:33] *** xinming joined
[13:34] <jnthn> benabik: It's not composed yet

[13:34] <jnthn> (at the time the method is called)

[13:36] *** timotimo joined
[13:37] <timotimo> hello, i'm trying to build rakudo-nom, but at the Configure.pl --gen-parrot step i get a failure with no obvious error message

[13:38] <masak> timotimo: could you nopaste it to gist.github.com?

[13:38] <benabik> jnthn: Oh.  An NQPClassHOW class couldn't do that because it uses @!mro which is calculated at compose time...  But Perl6::ClassHOW is smarter.

[13:38] <timotimo> yes, i will

[13:39] <benabik> jnthn: Sorry if I'm bothering you, I just find this stuff fascinating.

[13:39] <jnthn> benabik: Yeah, NQPClassHOW is decidedly simpler. That's deliberate. I wanted classes for implementing Perl 6's classes, but they didn't need to do everything Perl 6 classes do :)

[13:41] <timotimo> http://sprunge.us/VBJH <- there you go

[13:41] <benabik> jnthn: It seems like if you try to create an object before declaring all of it's attributes the REPR would get confused. Also, many (most?) REPRs will need to be lazy about allocation information because they'll want the attribute information.  Shouldn't they be notified on compose so they have a chance to do it without all the `if(!alloc) calc_alloc()` ?

[13:42] <moritz> timotimo: that's weird

[13:42] <moritz> timotimo: what platform is this?

[13:42] <timotimo> i agree :)

[13:42] <timotimo> debian sid on a 64 bit intel

[13:43] <jnthn> benabik: I have considered giving the REPR API a compose hook.

[13:44] <jnthn> benabik: Just means every meta-object needs to remember to call it, but maybe that's not such a burden.

[13:44] <moritz> timotimo: do you have any env variables set that could affect the compilation?

[13:44] <moritz> (something like concurrency options or so)

[13:44] <jnthn> moritz: Do you even see the actual error in that output? I'm missing it if it's there...

[13:44] <benabik> jnthn: Depends on if you want every meta-object to remember to call repr_compose or every repr to remember to calculate the allocation any place they may need it.  :-D

[13:44] <timotimo> apparently i have MAKEFLAGS= j2 j2 j2 j2, interesting

[13:45] <moritz> timotimo: please try clearing it

[13:45] <moritz> jnthn: make[1]: *** read jobs pipe: Is a directory.  Stop.

[13:45] <moritz> jnthn: a quick google tells me that that happens when one launches a sub-make in a parallalized build with 'make' instead of $(MAKE)

[13:45] <jnthn> moritz: hm. Note:

[13:45] <jnthn> cd 3rdparty/dyncall && BUILD_DIR=. make

[13:45] <moritz> jnthn: it seems that GNU make wants some kind of control over its child processes

[13:45] <jnthn> cd 3rdparty/dyncall && BUILD_DIR=. make

[13:46] <jnthn> moritz: It does it twice or some such...

[13:46] <moritz> weird

[13:46] <moritz> that's why I asked about concurrency options

[13:46] <timotimo> the environment was at fault, indeed

[13:46] <timotimo> thank you. i hopefully also identified and removed the culprit

[13:47] <moritz> timotimo: curiously, a simple 'make -j3' works for me in nqp

[13:48] <timotimo> another question: i have never written any perl5 and am new to perl6. is there a tutorial written for people like me?

[13:49] <moritz> timotimo: the "Using Perl 6" book is meant for people who know other programming languages, but not necessarily perl 5

[13:49] <timotimo> i've drooled over a couple of examples from perl6advent, but i'd like a more thorough approach

[13:50] <moritz> https://github.com/perl6/book/downloads

[13:50] <timotimo> sounds good. my prior experience consists mostly of c++ and python

[13:51] <moritz> if you find anything unclear in the book (it's under development), feel free to ask

[13:51] <moritz> most of the authors hang out here

[13:51] <timotimo> sure, thanks!

[13:51] <benabik> jnthn: Oh.  A.new doesn't work in BEGIN inside a class (method 'new' not found), so the allocation strategy can't get goofed.  Is that deliberate?

[13:52] <moritz> well, the .new comes in through inheritance, which is resolved at compose time, iirc

[13:52] <moritz> and compose time is when the class' final } is parsed

[13:53] <benabik> moritz: Makes sense.

[13:53] <jnthn> moritz: Yeah, that does offer some protection here. :)

[13:53] <moritz> one can still nqp::create :-)

[13:54] <jnthn> I'm tempted to do the compose hook anyway at some point

[13:55] <jnthn> Well, time to dig back into $dayjob stuffs...

[13:55] <benabik> I'm still somewhat worried about more general usage of 6model...  Having a repr compose would let it at least know if what's going on is a bad idea...

[13:55] <benabik> Although I guess the HOW should yell about creating an uncomposed class.

[13:57] <jnthn> benabik: Yeah, the more I ponder it, the more I think it's worth adding.

[13:57] * benabik digs into how objects are created.

[14:02] <benabik> Yeah, looks like creation bypasses the HOW.  So the REPR really has no way to check if the class is composed or not.

[14:02] <benabik> ANYway...

[14:02] <moritz> on what level? :-)

[14:03] <jnthn> nqp::create is a REPR op, not a HOW-related one, yes.

[14:03] * benabik should probably spend this time on $work or $thesis, not random 6model digging.

[14:06] <benabik> jnthn: BTW, 6model is an excellent piece of work.  And thanks for helping me understand it.

[14:06] <benabik> jnthn++

[14:09] <masak> timotimo: if you go to http://strangelyconsistent.org/blog/list-of-posts and search on that page for "June 1 2011", you'll get to the start of a 30-day intro course to Perl 6. that might be something for you.

[14:12] <benabik> It seems like we have more and more people showing up going "how do I get this working" and "how do I use this".  I like this trend.

[14:13] *** dhs227 joined
[14:13] *** dhs227 left
[14:14] <PerlJam> guten Morgen meine Freunde

[14:15] <moritz> \o PerlJam 

[14:27] <fdgbch456> so i have reached the step "To run a Perl 6 program with Rakudo, include the install directory in your system PATH variable", but there are two "perl6" executables, one in ~/rakudo/ and one in ~/rakudo/install/bin/

[14:27] <fdgbch456> which one do i include?

[14:27] <flussence> the install/ one

[14:28] <moritz> it even says "include the *install* directory" :-)

[14:28] <fdgbch456> the page http://rakudo.org/how-to-get-rakudo/ says, "This will build and install a ‚Äúperl6‚Ä≥ or ‚Äúperl6.exe‚Äù executable, by default in the parrot_install/bin/ subdirectory of the rakudo build directory."

[14:28] <moritz> oh, that's outdated

[14:28] <fdgbch456> & there is no "parrot_install" directory

[14:28] <PerlJam> fdgbch456: you could nuke everything else, as long as you keep that install directory around, you can run rakudo

[14:29] <fdgbch456> moritz: oh

[14:29] <moritz> it's now just named 'install/', not 'parrot_install/'

[14:29] <moritz> fdgbch456: http://rakudo.org/how-to-get-rakudo-nom/ is probably more interesting for you

[14:30] <moritz> once we have release a nom-based star, which should remove the old instruction page

[14:41] * PerlJam watches some really dark clouds move in and hopes that "tornado watch" doesn't turn into a "tornado warning"

[14:42] <jnthn> That'd suck.

[14:43] * TimToady wonders if OZ has any internetses...

[14:43] <phenny> TimToady: 07:29Z <sorear> tell TimToady my \term:<‚àû> = Inf; still doesn't work because <identifier> won't parse past the colon.  What's the best fix here?

[14:43] <phenny> TimToady: 07:52Z <sorear> tell TimToady sub (:\foo) is accepted but sub (:foo(\bar)) is rejected.  Shouldn't param_var accept \bar ?

[14:43] <phenny> TimToady: 07:52Z <sorear> tell TimToady STD croaks on sub (\foo) {} with an unblessed reference error

[14:43] <phenny> TimToady: 08:16Z <sorear> tell TimToady There are a few places in Niecza that use method foo(\$: ...) { } to force 'self' to be bound as a parcel.  What should be written now?

[14:44] <TimToady> oh, and jnthn++ for the terrible pun

[14:46] <masak> we let jnthn work on Rakudo just so he can provide us with bad puns all the time. ;)

[14:47] <TimToady> gah, I really hate it when ^O takes me to a different file in vim.  Is there a way to reverse and/or block that?

[14:49] <masak> sounds like Unity's new behavior of Alt-Tabbing to a different workspace :(

[14:49] <jasonmay> ^I is the reverse

[14:49] <benabik> TimToady: Jumplists are per window, so I think you'd have to open a new window for each file.  <Tab> should also bring you forward again quickly.

[14:50] *** PacoAir joined
[14:52] *** fdgbch456 left
[14:53] <TimToady> thanks

[14:55] *** birdwindupbird left
[15:00] <dalek> std: 655cc68 | larry++ | STD.pm6:

[15:00] <dalek> std: := and ::= must parse RHS as list assignment prec

[15:00] <dalek> std: 

[15:00] <dalek> std: The operator forms do that, but the initializer forms falsely

[15:00] <dalek> std: generalized from = parsing.

[15:00] <dalek> std: review: https://github.com/perl6/std/commit/655cc68965

[15:04] <TimToady> phenny: ask sorear Would (\self:) work?

[15:04] <phenny> TimToady: I'll pass that on when sorear is around.

[15:06] <moritz> eeks.

[15:07] <jnthn> hmm...in Rakudo I'd have to take care to suppress auto-generation/binding of self.

[15:07] <jnthn> Oh

[15:07] <jnthn> It'd cause a further problem.

[15:07] <jnthn> I rely on self being decontainerized.

[15:07] <jnthn> For attribute lookup

[15:08] <jnthn> So a naive patch to make the above work would break attribute lookups in any method that did that.

[15:08] <jnthn> Which I guess I could work around but ew.

[15:08] <moritz> also wouldn't that bind self to a parcel rather than to an object of the method you're currently in?

[15:08] <jnthn> moritz: "is parcel" doesn't mean that.

[15:09] <jnthn> moritz: It means "leave the thing exactly at is without re-containerization"

[15:09] <jnthn> *as

[15:09] <jnthn> Or context.

[15:09] <jnthn> (The context-ignoring part being why we don't want the sigils on there.)

[15:13] <jnthn> Hmm, what if you do method foo(\self) { ... } also. Then you get a self which is the wrong thing.

[15:13] <moritz> then you get a redeclaration error?

[15:14] <moritz> because there's one declaration for the implicit self, and another for one you just declared

[15:14] <moritz> and if you do method foo($other_self: \self), well, then screw you.

[15:15] <jnthn> moritz: Yes, but iiuc TimToady was suggesting we might end up suppressing declaration for implicit self

[15:15] <jnthn> moritz: Writing method foo($other_self:) { } does not mean you don't get self too

[15:16] <moritz> ah right

[15:19] *** kcwu left
[15:24] *** xinming left
[15:24] *** cognominal_ left
[15:25] *** xinming joined
[15:25] *** cognominal joined
[15:32] *** wtw left
[15:34] *** mj41 left
[15:34] *** phenny left
[15:34] *** krunen_ left
[15:34] *** arnsholt left
[15:34] *** timotimo left
[15:34] *** bkolera left
[15:34] *** Alias_ left
[15:34] *** lestrrat left
[15:34] *** charsbar___ left
[15:34] *** felher left
[15:34] *** huf left
[15:34] *** Yappoko___ left
[15:34] *** drbean left
[15:34] *** dukeleto left
[15:34] *** sirhc left
[15:34] *** tokuhirom3 left
[15:34] *** Khisanth left
[15:34] *** kshannon left
[15:34] *** aloha left
[15:34] *** rsimoes left
[15:34] *** Maddingue left
[15:34] *** groky left
[15:34] *** [Coke] left
[15:34] *** jnthn left
[15:34] *** bacek_at_work left
[15:34] *** pomysl left
[15:34] *** ruoso left
[15:34] *** Trashlord left
[15:34] *** yeltzooo left
[15:34] *** araujo left
[15:34] *** Vlavv` left
[15:34] *** mls left
[15:34] *** c1sung left
[15:34] *** LoRe left
[15:34] *** silug left
[15:34] *** Lorn left
[15:37] *** drbean joined
[15:38] *** kaare_ joined
[15:38] *** xinming left
[15:39] *** ranguard joined
[15:39] *** krunen joined
[15:39] *** timotimo joined
[15:39] *** arnsholt joined
[15:39] *** kshannon joined
[15:40] *** [Coke] joined
[15:42] *** xinming joined
[15:42] *** aloha joined
[15:42] *** bacek_at_work joined
[15:44] *** doy joined
[15:44] *** Maddingue joined
[15:47] <masak> <Radvendii> «ßis al ƒçiuj!

[15:48] <masak> Radvendii: your funny hats are upside down.

[15:48] *** TimToady joined
[15:49] <TimToady> whew, just discovered how to recover from a bad netsplit with /reconnect

[15:50] *** phenny joined
[15:50] *** jnthn joined
[15:50] <TimToady> a /reconnect is a lot easier than restarting irssi...

[15:50] <rjbs> restarting irssi always feels like an admission of failure to me

[15:50] <rjbs> and I always forget to rejoin at least 1d6 channels

[15:51] <moritz> doesn't irssi reconnect automatically?

[15:51] <rjbs> It tries to, but it's imperfect.

[15:51] <jnthn> It did for me, but I ended up on a server with, er, 6 of the channel's inhabitants.

[15:51] <jnthn> A /reconnect got me back to a better connected one :)

[15:52] <TimToady> hah, my orphan server had 7 inhabitants, nyaa nyaa nyaa

[15:52] *** am0c left
[15:52] * TimToady blames solar storms

[15:53] *** mj41 joined
[15:53] *** kcwu joined
[15:53] *** bkolera joined
[15:53] *** Alias_ joined
[15:53] *** lestrrat joined
[15:53] *** charsbar___ joined
[15:53] *** felher joined
[15:53] *** huf joined
[15:53] *** Timbus joined
[15:54] *** rsimoes joined
[15:54] *** cxreg joined
[15:54] *** pmurias joined
[15:54] *** Yappoko___ joined
[15:54] *** dukeleto joined
[15:54] *** sirhc joined
[15:54] *** tokuhirom3 joined
[15:55] *** kaleem joined
[15:55] *** amkrankruleuen joined
[15:55] *** pomysl joined
[15:55] *** ruoso joined
[15:55] *** Trashlord joined
[15:55] *** yeltzooo joined
[15:55] *** araujo joined
[15:55] *** Vlavv` joined
[15:55] *** mls joined
[15:55] *** c1sung joined
[15:55] *** LoRe joined
[15:55] *** silug joined
[15:55] *** Lorn joined
[15:55] *** hillu joined
[15:55] *** awwaiid joined
[15:55] *** mathw joined
[15:55] <moritz> TimToady: that does sound a bit like an BOfH excuse :-)

[15:56] <timotimo> when i find spelling mistakes etc in the perl6 book, is it ok to fork+edit+pullrequest them?

[15:56] <moritz> timotimo: or just commit them directly; what's your gitub ID?

[15:57] <timotimo> of course i could do that, too :p  -  it's "timo"

[15:57] <moritz> timotimo: you have commit access now. Have fun!

[15:57] <moritz> timotimo: note that the PDF might be slightly out of sync with the sources, so some typos might already be corrected

[15:57] <timotimo> wow, i hope i won't disappoint you by not working hard enough ;)

[15:58] <timotimo> yes, i've made sure to look into the code first

[15:58] <pmichaud> good morning, #perl6

[15:58] <phenny> pmichaud: 24 Jan 19:32Z <sorear> tell pmichaud At some point I'd like an overview of how LoL, $obj.lol, **@foo, etc work and fit together in Rakudo

[15:58] <moritz> good am, pm

[15:58] <colomon> pmichaud: good morning!

[15:58] <moritz> (I've missed that bad joke)

[15:59] <dalek> std: afb775b | larry++ | STD.pm6:

[15:59] <dalek> std: allow bare \ and \term:<your-ad-here> forms

[15:59] <dalek> std: review: https://github.com/perl6/std/commit/afb775b302

[15:59] *** groky joined
[16:00] *** Khisanth joined
[16:00] <masak> pmichaud! \o/

[16:00] <jnthn> o/ pmichaud 

[16:01] <TimToady> you just missed the great netsplits this morning

[16:01] <masak> \term:<your-ad-here> -- oh man.

[16:01] * masak imagines term:<this spec commit was brought to you by Pepsi>

[16:03] * jnthn hoped that the solar storm might mean he saw the aurora this far south, but I didn't see much...

[16:03] <TimToady> evalbot rebuild std

[16:03] <p6eval> OK (started asynchronously)

[16:03] * [Coke] glares at masak.

[16:04] *** groky left
[16:05] <dalek> Rebuild of std complete.

[16:05] <TimToady> std: my \term:<‚àû> = 42; say ‚àû;

[16:05] <p6eval> std afb775b: OUTPUT¬´ok 00:01 113m‚ê§¬ª

[16:05] <[Coke]> why is dalek announcing the rebuild is complete?

[16:06] <TimToady> so we can know when to torment it again?

[16:06] <[Coke]> (as opposed to p6eval)

[16:06] <TimToady> less noise the failed tries

[16:06] <TimToady> *than

[16:06] <TimToady> oh

[16:06] <dalek> book: eb5b12d | timo++ | src/basics.pod:

[16:06] <dalek> book: Removed stale references to " vs " in table tennis data

[16:06] <dalek> book: review: https://github.com/perl6/book/commit/eb5b12d22c

[16:07] <TimToady> std: constant term:<‚àÖ> = set();

[16:07] <p6eval> std afb775b: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[16:07] <TimToady> \o/

[16:07] <TimToady> std: constant \term:<‚àÖ> = set();

[16:07] <p6eval> std afb775b: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[16:07] *** Khisanth is now known as Guest20598

[16:07] <TimToady> (the \ is optional in constants)

[16:08] <masak> timotimo++

[16:11] <TimToady> std: sub (\foo) {}

[16:11] <p6eval> std afb775b: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[16:14] <skids> jnthn: WRT https://github.com/perl6/specs/pull/10 now that I read S02:1776 and S02:1917 it appears :: is both en-passant type capture and class predeclarator simultaneously.  So I should undo that pull request, or have there been decisions in this area not reflected in S02?  Or am I totally misunderstanding something?

[16:14] <dalek> niecza: 7bfcbe7 | (Solomon Foster)++ | lib/CORE.setting:

[16:14] <dalek> niecza: Add Bag modeled after Set.

[16:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7bfcbe7917

[16:14] <dalek> niecza: 6694950 | (Solomon Foster)++ | t/spectest.data:

[16:14] <dalek> niecza: Turn on S02-types/bag.t.

[16:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6694950a2e

[16:15] <timotimo> masak: :)

[16:15] * colomon notes that both set.t and bag.t could use quite a few more tests....

[16:15] <masak> skids: no, you're correct.

[16:16] <masak> skids: it's a way to refer to undeclared classes outside of signatures, and en-passant capture inside of them.

[16:16] <jnthn> Yup. Looks like a good clarification.

[16:17] <skids> But the S02 fragments say it predeclares the class as well inside a signature... ?

[16:18] <jnthn> :S

[16:18] <jnthn> It never pre-declares anything. It just defers lookup until runtime.

[16:18] <jnthn> Thus why it can't be used in declarative contexts, which need to know stuff at compile time.

[16:19] *** am0c joined
[16:20] <skids> Well, OK, my vocabulary is off... S02 says: "Within a signature or other declaration, the :: pseudo-sigil followed by an identifier marks a type variable that also declares the visibility of a package/type name without the sigil within the scope of the declaration"

[16:20] <skids> So that's what's re-confusing me.

[16:21] *** rsimoes left
[16:22] <masak> means you do ::Foo in a signature, and then you can talk about Foo in that scope.

[16:23] <jnthn> It just means...what masak said. Could be clearer though

[16:25] *** rsimoes joined
[16:25] <pmichaud> Rakudo 2012.01 is using Parrot 3.11.0 ?  (just checking)

[16:26] <masak> skids: however, Foo is not a class, or even really a type. it's just a type variable.

[16:28] *** colomon left
[16:28] <lumi___> Does that mean that "my (::T $x) = 5" (or so) means that T is Int for the containing scope?

[16:28] <jnthn> pmichaud: Yeah. The Rakudo compiler release went out with that, more by accident than anything. But next to nothing happened between 3.11.0 and 4.0.0 so it didn't seem worth doing a point release to correct.

[16:28] <PerlJam> nom: my (::T $x, T $y) = (1,"foo");  # and should this fail?

[16:28] <p6eval> nom 27a5dd:  ( no output )

[16:28] <pmichaud> okay.  One minor difference may be that packagers won't package a 3.11 Parrot release

[16:28] <PerlJam> std: my (::T $x, T $y) = (1,"foo");

[16:28] <p6eval> std afb775b: OUTPUT¬´ok 00:01 115m‚ê§¬ª

[16:29] <skids> Ah, comprehension dawns.  Maybe I'll try to work on that S02 verbiage as well.

[16:29] <jnthn> I suspect it should moan about the signature being too complex to turn that into a parcel of ($x, $y) and do list assignment in that case.

[16:29] * benabik hopes packagers would build rakudo with their packaged parrot, rather than --gen-parrot

[16:30] <pmichaud> benabik: oh, that's a good point.

[16:30] <jnthn> pmichaud: Hm, and a release that requires a 3.11 won't build against and installed 4.0?

[16:30] <pmichaud> it should work against a 4.0, yes.

[16:30] * jnthn forgets the exact rules...I know a later commit is OK.

[16:30] <jnthn> OK.

[16:30] * benabik has had no problem with NQP/Rakudo on 4.0.0-devel

[16:30] <pmichaud> it just seemed odd to me

[16:31] <masak> PerlJam: of course, STD allows that because STD doesn't typecheck.

[16:31] <jnthn> pmichaud: We could fix it, it just means issuing point compiler releases of NQP and Rakudo.

[16:31] <PerlJam> yeah, I just wanted to see if there was something std noticed that I didn't

[16:31] *** kaleem_ joined
[16:31] <masak> nom: sub foo(::T $a, T $b) { say "OH HAI" }; foo 5, 42

[16:31] <p6eval> nom 27a5dd: OUTPUT¬´OH HAI‚ê§¬ª

[16:31] <pmichaud> jnthn: I'm fine with leaving it as-is for this release, if you are.

[16:31] <masak> nom: sub foo(::T $a, T $b) { say "OH HAI" }; foo 5, "wrong"

[16:31] <p6eval> nom 27a5dd: OUTPUT¬´Nominal type check failed for parameter '$b'; expected Int but got Str instead‚ê§  in sub foo at /tmp/4fWEnqFA3Y:1‚ê§  in block <anon> at /tmp/4fWEnqFA3Y:1‚ê§  in <anon> at /tmp/4fWEnqFA3Y:1‚ê§¬ª

[16:31] <jnthn> pmichaud: Yeah, I'm fine with it.

[16:32] *** am0c left
[16:32] <masak> jnthn: will we ever be able to catch the above at compile-time? :)

[16:32] *** colomon joined
[16:32] <dalek> std: b5dc271 | larry++ | STD.pm6:

[16:32] <dalek> std: new rule to handle what can go inside param :x()

[16:32] <dalek> std: review: https://github.com/perl6/std/commit/b5dc271d83

[16:32] * [Coke] tries to find more Set & Bag tests to unfudge for colomon.

[16:32] <masak> jnthn: with one of those "will never work" errors...

[16:33] <jnthn> masak: Yeah, it'd need patches to compile time bind analysis in bind.c.

[16:33] <TimToady> evalbot rebuild std

[16:33] <p6eval> OK (started asynchronously)

[16:33] <jnthn> masak: It's not particularly tricky to catch the above case.

[16:34] <jnthn> masak: Oh, wait...it does get a bit tricky as compile time binding analysis doesn't currently have something to hand to serve as the type environment.

[16:34] <jnthn> masak: But even that's not hard to solve.

[16:34] *** kaleem left
[16:34] <dalek> Rebuild of std complete.

[16:35] <masak> jnthn: cool.

[16:35] <masak> I think it's kinda cute that p6eval says "OK" and dalek comes back and says "complete".

[16:35] <dalek> roast: a45df5f | coke++ | S0 (3 files):

[16:35] <dalek> roast: niecza autounfudge

[16:35] <dalek> roast: review: https://github.com/perl6/roast/commit/a45df5f96c

[16:36] <masak> makes it look like the bots are one big family :)

[16:36] <[Coke]> colomon: there's 5 more on top. ;)

[16:36] <tadzik> it could say LOL DONE

[16:37] <[Coke]> er, 8!

[16:37] <TimToady> std: sub foo (:x(:y(\z))) { ... }

[16:38] <p6eval> std b5dc271: OUTPUT¬´ok 00:01 110m‚ê§¬ª

[16:38] <benabik> std: sub foo (:\z) { ... }

[16:38] <p6eval> std b5dc271: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[16:38] <TimToady> phenny: tell sorear I think all your concerns are addressed now; bare \ is now allowed for the invocant

[16:38] <phenny> TimToady: I'll pass that on when sorear is around.

[16:39] <TimToady> std: method (\:) {}

[16:39] <p6eval> std b5dc271: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[16:40] <TimToady> std: sub foo (:x(:y(\term:<‚Äª>))) { say ‚Äª }

[16:40] <p6eval> std b5dc271: OUTPUT¬´ok 00:01 114m‚ê§¬ª

[16:43] *** kaleem_ left
[16:48] *** wamba joined
[16:49] *** wamba left
[17:00] * masak decommutes

[17:08] *** MayDaniel joined
[17:11] <pmichaud> time for lunch here, and I need to think a bit more about star configure/build

[17:12] *** MayDaniel left
[17:12] <pmichaud> bbiaw

[17:16] <flussence> yay! https://github.com/flussence/specgraphs/blob/master/impls.png

[17:16] * flussence &

[17:20] *** mj41 left
[17:30] <timotimo> in the perl6 book, I'm about to change "say @a === @a;    # 1" to "say @a === @a;    # Bool:True", is that OK?

[17:30] <timotimo> uh, Bool::True, of course

[17:31] <moritz> timotimo: yes

[17:31] <dalek> book: 850c094 | timo++ | src/operators.pod:

[17:31] <dalek> book: say @a === @a outputs Bool::True rather than 1.

[17:31] <dalek> book: review: https://github.com/perl6/book/commit/850c0944fd

[17:31] <timotimo> oh, there's more

[17:32] <moritz> timotimo++

[17:33] <timotimo> for the example say 3 == '3b'; i get "No applicable candidates found to dispatch to for 'Numeric'." rather than a 1. what to do with that?

[17:34] <moritz> hm, that's a failure by new numifying spec

[17:34] <moritz> (and rakudo doesn't do well in propagating the failure through ==)

[17:35] <moritz> timotimo: either add '# fails' or leave a TODO comment

[17:36] <dalek> book: e8cc91e | timo++ | src/operators.pod:

[17:36] <dalek> book: changed more 0 and 1 into True/False. Note, that 3 == '3b' fails.

[17:36] <dalek> book: review: https://github.com/perl6/book/commit/e8cc91e72f

[17:37] <timotimo> why does it say "timo++" in there?

[17:39] *** jaldhar left
[17:40] <timotimo> oh, also in the text it claims, that perl will use 0 if there's no way to turn the string into a numeric value. is that also false as of the new numifying spec?

[17:41] <Util> #ps time, 10m ago

[17:42] <Util> timotimo: It is using your GitHub ID.

[17:42] <timotimo> but my github id is timo, not timo++

[17:43] <Util> The ++ is kept track of by a "karma" bot on this channel. You get a ++ when you do something good.

[17:43] <timotimo> ah, all right

[17:43] <Util> Like a few mintes ago, when moritz did it to you.

[17:43] <Util> karma timo

[17:43] <aloha> timo has karma of 0.

[17:43] <Util> karma timotimo

[17:43] <aloha> timotimo has karma of 2.

[17:44] <timotimo> yup, i was aware of the karma thing, it just confused me to see it in the bots output

[17:44] <timotimo> where would i put feedback like "in chapter 3, the sort example drops new syntax onto the reader out of nowhere without a deeper explanation"?

[17:44] <Util> Commits are "something good" :)

[17:44] <timotimo> would an issue in the tracker be the right thing?

[17:44] <Util> Yes.

[17:45] <Util> and that is an excellent issue to raise

[17:46] <sorear> good * #perl6

[17:46] <phenny> sorear: 15:04Z <TimToady> ask sorear Would (\self:) work?

[17:46] <phenny> sorear: 16:38Z <TimToady> tell sorear I think all your concerns are addressed now; bare \ is now allowed for the invocant

[17:49] <moritz> it's #phasers time

[17:49] <sorear> [Coke]: (dalek reporting end) Convenience, mostly

[17:56] *** dakkar left
[18:04] *** tarski joined
[18:06] *** Radvendii joined
[18:07] <Radvendii> hey, guys? Y'know how the zip operator truncates the smaller list? is there a way to make it instead repeat the smaller list?

[18:08] <TimToady> (list) xx *

[18:09] <TimToady> or use the dwimmy hyper

[18:09] <TimToady> @a ¬ªop¬ª @b   # repeats @b

[18:10] *** daxim left
[18:10] <TimToady> perl6: say ('a'..'z') ¬ª~¬ª (1,2,3)

[18:10] <p6eval> rakudo 27a5dd, niecza v13-352-g6694950: OUTPUT¬´a1 b2 c3 d1 e2 f3 g1 h2 i3 j1 k2 l3 m1 n2 o3 p1 q2 r3 s1 t2 u3 v1 w2 x3 y1 z2‚ê§¬ª

[18:10] <p6eval> ..pugs b927740: OUTPUT¬´decodeUTF8': bad data: '\187'‚ê§decodeUTF8': bad data: '\187'‚ê§*** ‚ê§    Unexpected "\187~\187"‚ê§    expecting operator, ":" or ","‚ê§    at /tmp/_Cx0CnH2Ml line 1, column 16‚ê§¬ª

[18:11] <TimToady> perl6: say 'a'..'z' X~ (1,2,3) xx *

[18:11] <p6eval> rakudo 27a5dd, niecza v13-352-g6694950: OUTPUT¬´(timeout)¬ª

[18:11] <p6eval> ..pugs b927740: OUTPUT¬´abcdefghijklmnopqrstuvwxyz‚ê§¬ª

[18:11] <TimToady> perl6: say 'a'..'z' Z~ (1,2,3) xx *

[18:11] <p6eval> rakudo 27a5dd, niecza v13-352-g6694950: OUTPUT¬´a1 b2 c3 d1 e2 f3 g1 h2 i3 j1 k2 l3 m1 n2 o3 p1 q2 r3 s1 t2 u3 v1 w2 x3 y1 z2‚ê§¬ª

[18:11] <p6eval> ..pugs b927740: OUTPUT¬´abcdefghijklmnopqrstuvwxyz‚ê§¬ª

[18:12] <TimToady> perl6: say 'a'...* Z~ (1,2,3) xx *

[18:13] <p6eval> rakudo 27a5dd: OUTPUT¬´Decrement out of range‚ê§  in method Str at src/gen/CORE.setting:7212‚ê§  in method Stringy at src/gen/CORE.setting:678‚ê§  in sub infix:<eq> at src/gen/CORE.setting:977‚ê§  in method ACCEPTS at src/gen/CORE.setting:3230‚ê§  in sub coro at src/gen/CORE.setting:4618‚ê§  in meth‚Ä¶

[18:13] <p6eval> ..niecza v13-352-g6694950: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§"..." and "Z~" are non-associative and require parens at /tmp/3lZ7_j1rh_ line 1:‚ê§------> [32msay 'a'...* Z~ [33m‚èè[31m(1,2,3) xx *[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting lin‚Ä¶

[18:13] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&Z"‚ê§    at /tmp/HbJ57Pupn4 line 1, column 5 - line 2, column 1‚ê§¬ª

[18:13] <TimToady> perl6: say ('a'...*) Z~ (1,2,3) xx *

[18:13] <p6eval> niecza v13-352-g6694950: OUTPUT¬´(timeout)¬ª

[18:13] <p6eval> ..rakudo 27a5dd: OUTPUT¬´Decrement out of range‚ê§  in method Str at src/gen/CORE.setting:7212‚ê§  in method Stringy at src/gen/CORE.setting:678‚ê§  in sub infix:<~> at src/gen/CORE.setting:965‚ê§  in sub <anon> at src/gen/CORE.setting:9024‚ê§  in sub coro at src/gen/CORE.setting:4618‚ê§  in method re‚Ä¶

[18:13] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected " Z"‚ê§    at /tmp/BsbWzeI54C line 1, column 14‚ê§¬ª

[18:13] <TimToady> perl6: .say for ('a'...*) Z~ (1,2,3) xx *

[18:13] <jnthn> ...decrement? :)

[18:14] <p6eval> rakudo 27a5dd: OUTPUT¬´Decrement out of range‚ê§  in method Str at src/gen/CORE.setting:7212‚ê§  in method Stringy at src/gen/CORE.setting:678‚ê§  in sub infix:<~> at src/gen/CORE.setting:965‚ê§  in sub <anon> at src/gen/CORE.setting:9024‚ê§  in sub coro at src/gen/CORE.setting:4618‚ê§  in method re‚Ä¶

[18:14] <p6eval> ..niecza v13-352-g6694950: OUTPUT¬´(timeout)a1‚ê§b2‚ê§c3‚ê§d1‚ê§e2‚ê§f3‚ê§g1‚ê§h2‚ê§i3‚ê§j1‚ê§k2‚ê§l3‚ê§m1‚ê§n2‚ê§o3‚ê§p1‚ê§q2‚ê§r3‚ê§s1‚ê§t2‚ê§u3‚ê§v1‚ê§w2‚ê§x3‚ê§y1‚ê§z2‚ê§aa3‚ê§ab1‚ê§ac2‚ê§ad3‚ê§ae1‚ê§af2‚ê§ag3‚ê§ah1‚ê§ai2‚ê§aj3‚ê§ak1‚ê§al2‚ê§am3‚ê§an1‚ê§ao2‚ê§ap3‚ê§aq1‚ê§ar2‚ê§as3‚ê§at1‚ê§au2‚ê§av3‚ê§aw1‚ê§ax2‚ê§ay3‚ê§az1‚ê§ba2‚ê§bb3‚ê§bc1‚ê§bd2‚ê§be3‚ê§bf1‚ê§bg2‚ê§bh3‚ê§bi1‚ê§bj2‚ê§bk3‚ê§bl1‚ê§bm2‚ê§bn3‚ê§bo1‚ê§bp2‚ê§‚Ä

[18:14] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected " Z"‚ê§    at /tmp/9eNfrh7inL line 1, column 19‚ê§¬ª

[18:14] <TimToady> rakudo is suffering from increment whether

[18:15] <jnthn> *groan*

[18:15] *** fsergot joined
[18:15] <Radvendii> isn't ¬ªop¬ª act like X?

[18:16] <dalek> std: 47c76b3 | larry++ | STD.pm6:

[18:16] <dalek> std: change <initializer> to category for extensibility

[18:16] <dalek> std: review: https://github.com/perl6/std/commit/47c76b3460

[18:16] <TimToady> no, only if there's exactly one thing on the right

[18:16] <TimToady> in which case, either construct repeats it

[18:17] <TimToady> well, multiple things can repeat too, I guess

[18:17] <TimToady> perl6: say 'a'..'z' X~ 1,2,3

[18:17] <p6eval> rakudo 27a5dd, niecza v13-352-g6694950: OUTPUT¬´a1 a2 a3 b1 b2 b3 c1 c2 c3 d1 d2 d3 e1 e2 e3 f1 f2 f3 g1 g2 g3 h1 h2 h3 i1 i2 i3 j1 j2 j3 k1 k2 k3 l1 l2 l3 m1 m2 m3 n1 n2 n3 o1 o2 o3 p1 p2 p3 q1 q2 q3 r1 r2 r3 s1 s2 s3 t1 t2 t3 u1 u2 u3 v1 v2 v3 w1 w2 w3 x1 x2 x3 y1 y2 y3 z1 z2 z3‚ê§¬ª

[18:17] <p6eval> ..pugs b927740: OUTPUT¬´abcdefghijklmnopqrstuvwxyz‚ê§¬ª

[18:17] <TimToady> so yes, you are correct about that

[18:18] <[Coke]> flussence++

[18:18] <TimToady> note, however, that X is lazy, while hyper is eager, so only X or Z can deal with infinite lists

[18:18] <Radvendii> right...

[18:18] <Radvendii> nom: say <a b> Z 1,2,3

[18:18] <p6eval> nom 27a5dd: OUTPUT¬´a 1 b 2‚ê§¬ª

[18:19] <TimToady> and X can only deal with an infinite list on its left

[18:19] <Radvendii> nom: say <a b> ¬ª~¬ª 1,2,3

[18:19] <p6eval> nom 27a5dd: OUTPUT¬´a1 b123‚ê§¬ª

[18:19] <TimToady> precedence

[18:19] <TimToady> hypers are also scalar ops, not list ops

[18:19] <TimToady> hypers expect to run on an object, not a list

[18:20] <Radvendii> nom: say <a b> ¬ª~¬ª (1,2,3)

[18:20] <p6eval> nom 27a5dd: OUTPUT¬´a1 b2‚ê§¬ª

[18:20] * sorear reads the last few STD commits

[18:20] <Radvendii> ah. the issue is i have a list on either side and i dont know which one is going to be infinite.

[18:20] <Radvendii> sorry

[18:20] <Radvendii> which one is going to be bigger

[18:21] <TimToady> if you want the shorter to repeat in any case, use ¬´op¬ª

[18:21] <Radvendii> nom: say <a b> ¬´~¬ª (1,2,3)

[18:21] <p6eval> nom 27a5dd: OUTPUT¬´a1 b2 a3‚ê§¬ª

[18:21] <Radvendii> i see

[18:21] * benabik ponders what infix:<op> should do...

[18:21] <sorear> I was wondering earlier if anyone had any use whatsoever for the "repeat either" semantics of ¬´op¬ª

[18:22] <Radvendii> haha. i do!

[18:22] <Radvendii> oh wait. i dont want them concatenated though

[18:22] * [Coke] wonders if we think perl6 will suffer from the same issues being discussed on p5p today in regards to distributions and "what is perl". /me suspects he will just use perlbrew if it comes to that. (esp. nice to have a perl6brew given we have different perls to start with.)

[18:22] <TimToady> then use a different op

[18:22] <Radvendii> nom: say <a b> ¬´,¬ª (1,2,3)

[18:22] <p6eval> nom 27a5dd: OUTPUT¬´a 1 b 2 a 3‚ê§¬ª

[18:22] <Radvendii> there we go

[18:24] <sorear> minor problem being that niecza doesn't use 'add_name' and patch isn't thrilled by the fact that niecza's context lines are lacking { $ƒã.add_name...

[18:25] <Radvendii> [Coke]: here's my question: why are we splitting our efforts between different (compilers?) of perl (e.g. niecza, rakudo)

[18:26] <sorear> because I'm a pathetic wretch who doesn't work well with others

[18:26] <TimToady> because efforts are not a zero-sum game

[18:26] <Radvendii> sorear: :P

[18:27] <TimToady> because when two different implementations agree on how something should work, it's a pretty good indication that it's probably how it should be in the spec

[18:28] <Radvendii> that seems like a pretty secondary goal but that's just IMO, and i'm pretty new to this.

[18:28] <TimToady> the primary goal is to produce a better language, however long it takes

[18:28] <TimToady> the secondary goal is that we want it now :)

[18:28] <Radvendii> i suppose...

[18:29] <sorear> There isn't actually a *splitting* of effort involved.

[18:29] <Radvendii> sorear: no?

[18:29] <sorear> After I determined that I was mental-health-ily incapable of contributing to Rakudo, my choices were starting Niecza or not contributing at all

[18:30] <sorear> std: sub (\foo) { }

[18:30] <p6eval> std b5dc271: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[18:30] <Radvendii> Okay...

[18:30] <TimToady> Radvendii: I strongly suggest reading S01 for all about this meta-project-stuff

[18:30] <Radvendii> TimToady: okay

[18:31] *** bluescreen10 left
[18:33] <Radvendii> nom: sub a {say "in"; return True}; say [||] (a xx 3)

[18:33] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&xx' called (line 1)‚ê§¬ª

[18:34] <Radvendii> nom: say 1 xx 3

[18:34] <p6eval> nom 27a5dd: OUTPUT¬´1 1 1‚ê§¬ª

[18:34] * sorear decides to try editing the patch before applying it

[18:34] <jnthn> std:  sub a {say "in"; return True}; say [||] (a xx 3)

[18:34] <p6eval> std b5dc271: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§ 'xx' used at line 1‚ê§Check failed‚ê§FAILED 00:01 111m‚ê§¬ª

[18:34] <sorear> perl6: say rand xx 3

[18:34] <jnthn> Radvendii: I think you need a() there

[18:34] <p6eval> pugs b927740: OUTPUT¬´*** No such subroutine: "&xx"‚ê§    at /tmp/QT0oWEDtGH line 1, column 5 - line 2, column 1‚ê§¬ª

[18:34] <p6eval> ..niecza v13-352-g6694950: OUTPUT¬´0.11041774186790816 0.80917691244239776 0.39022010303578342‚ê§¬ª

[18:34] <p6eval> ..rakudo 27a5dd: OUTPUT¬´0.36751254841602 0.36751254841602 0.36751254841602‚ê§¬ª

[18:34] <Radvendii> nom: sub a {say "in"; return True}; say [||] (a() xx 3)

[18:34] <p6eval> nom 27a5dd: OUTPUT¬´in‚ê§Bool::True‚ê§¬ª

[18:34] * jnthn goes to find something to eat

[18:34] *** bluescreen10 joined
[18:35] <Radvendii> nom: sub a {say "in"; return True}; say [||] <a b c>.map: {a()}

[18:35] <p6eval> nom 27a5dd: OUTPUT¬´in‚ê§in‚ê§in‚ê§Bool::True‚ê§¬ª

[18:35] <Radvendii> so .map isn't lazy

[18:35] <[Coke]> Radvendii: same question for "why perl6? why not just work on perl5!"

[18:35] <[Coke]> volunteer time isn't completely fungible.

[18:35] <moritz> Radvendii: wrong conclusion

[18:35] <Radvendii> [Coke]: good question. well, actually my question would be why perl5?

[18:36] <Radvendii> moritz: how so?

[18:36] <moritz> nom: sub a {say "in"; return True}; say <a b c>.map(&in).[0]

[18:36] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§Symbol '&in' not predeclared in <anonymous> (/tmp/XG9pl3TIhD:1)‚ê§¬ª

[18:36] <sorear> patch: **** malformed patch at line 36

[18:36] <TimToady> Radvendii: that's a polite way of saying you're wrong

[18:36] <moritz> nom: sub a {say "in"; return True}; say <a b c>.map(&a).[0]

[18:36] <p6eval> nom 27a5dd: OUTPUT¬´Too many positional parameters passed; got 1 but expected 0‚ê§  in sub a at /tmp/5a_WhVnDb5:1‚ê§  in method reify at src/gen/CORE.setting:4471‚ê§  in method reify at src/gen/CORE.setting:4376‚ê§  in method gimme at src/gen/CORE.setting:4740‚ê§  in method exists at src/gen/CORE.‚Ä¶

[18:36] <moritz> nom: sub a($) {say "in"; return True}; say <a b c>.map(&a).[0]

[18:36] <p6eval> nom 27a5dd: OUTPUT¬´in‚ê§Bool::True‚ê§¬ª

[18:36] <moritz> Radvendii: see? if map were eager, you'd see three 'in'

[18:37] <Radvendii> but when i try to [||] it...

[18:37] <Radvendii> nom: sub a {say "in"; return True}; say any( <a b c>.map: {a()} )

[18:37] <p6eval> nom 27a5dd: OUTPUT¬´in‚ê§in‚ê§in‚ê§any(Bool::True, Bool::True, Bool::True)‚ê§¬ª

[18:37] *** bluescreen10 left
[18:37] <Radvendii> oh right, any does something else

[18:37] <Radvendii> nom: sub a {say "in"; return True}; say ?any( <a b c>.map: {a()} )

[18:37] <p6eval> nom 27a5dd: OUTPUT¬´in‚ê§in‚ê§in‚ê§Bool::True‚ê§¬ª

[18:39] <timotimo> huh, in the perl6 book, out of nowhere it says :type<<double-beef>>. my rakudo-nom shows no difference between :type<double-beef> and the one with <</>>

[18:41] <sorear> hmm

[18:41] <Radvendii> nom: say <a b c>.map: {$_}.map: {$_}

[18:41] <p6eval> nom 27a5dd: OUTPUT¬´Method 'count' not found for invocant of class 'List'‚ê§  in method reify at src/gen/CORE.setting:4471‚ê§  in method reify at src/gen/CORE.setting:4376‚ê§  in method reify at src/gen/CORE.setting:4376‚ê§  in method gimme at src/gen/CORE.setting:4740‚ê§  in method eager at src/g‚Ä¶

[18:41] <sorear> timotimo: Double angles interpolate like double quotes

[18:41] <Radvendii> nom: say (<a b c>.map: {$_}).map: {$_}

[18:41] <p6eval> nom 27a5dd: OUTPUT¬´a b c‚ê§¬ª

[18:42] <sorear> patch doesn't seem to like it when I delete individual lines from a unidiff

[18:42] *** GlitchMr joined
[18:43] <timotimo> sorear: so i could do things like :types<<rakudo-$currentbranch niecza>> and it would, for instance, give me "rakudo-nom", "niecza"?

[18:43] <sorear> yes

[18:43] <timotimo> well, "types" => (rak...)

[18:43] <timotimo> neat

[18:43] <doy> sorear: you also need to update the line counts in the hunk header

[18:44] * sorear wonders how the line counts are defined

[18:45] <doy> it's a pain, and usually less effort to just regenerate the patch after fixing it in the actual source

[18:45] <timotimo> another thing that confused me (maybe i should write a ticket for that as well?) is that in the dance moves example, the subs in the moves hash are called like this: %moves{$move}.();  - why is the . needed there?

[18:45] <moritz> timotimo: feel free to ticket it

[18:45] <moritz> (it's not needed, just a matter of style preference)

[18:47] <timotimo> well, the example has a "todo: find a different example", so maybe it's not needed after all

[18:47] <Radvendii> nom: say ?('wK' !~~ 'b')

[18:47] <p6eval> nom 27a5dd: OUTPUT¬´Bool::True‚ê§¬ª

[18:48] <Radvendii> nom: say ?('wK' !~~ 'w')

[18:48] <p6eval> nom 27a5dd: OUTPUT¬´Bool::True‚ê§¬ª

[18:48] <Radvendii> nom: say ?('wK' !~~ /w/)

[18:48] <p6eval> nom 27a5dd: OUTPUT¬´Bool::False‚ê§¬ª

[18:49] *** lichtkind joined
[18:51] <lichtkind> cheers o/

[18:51] <moritz> nom: say pir::perl6ize_type(1).WHAT

[18:51] <p6eval> nom 27a5dd: OUTPUT¬´use of uninitialized value of type Mu in string context‚ê§use of uninitialized value of type Mu in string context‚ê§===SORRY!===‚ê§error:imcc:The opcode 'perl6ize_type_p' (perl6ize_type<1>) was not found. Check the type and number of the arguments‚ê§   in file '(file unknown)' ‚Ä¶

[18:51] <sorear> o/ lichtkind 

[18:52] <moritz> nom: say pir::perl6ize_type__(1).WHAT

[18:52] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§rtype not set‚ê§¬ª

[18:52] <moritz> nom: say pir::perl6ize_type__PP(1).WHAT

[18:52] <p6eval> nom 27a5dd: OUTPUT¬´Int()‚ê§¬ª

[18:52] <moritz> nom: say pir::perl6ize_type__PP('1').WHAT

[18:52] <p6eval> nom 27a5dd: OUTPUT¬´Str()‚ê§¬ª

[18:52] <dalek> niecza: 32dcbb0 | coke++ | t/spectest.data:

[18:52] <dalek> niecza: run S03-smartmatch/any-type.t

[18:52] <dalek> niecza: review: https://github.com/sorear/niecza/commit/32dcbb078d

[18:53] <jnthn> moritz: Not convinced that's testing what you want it to :)

[18:53] <moritz> nom: say pir::perl6ize_type__PP(nqp::unbox_s '1').WHAT

[18:53] <p6eval> nom 27a5dd: OUTPUT¬´Str()‚ê§¬ª

[18:54] <jnthn> That's more like it :)

[18:54] * jnthn goes to cook stuff

[18:55] <dalek> book: 40b1d5d | timo++ | src/subs-n-sigs.pod:

[18:55] <dalek> book: in MAIN, limit sides to Numeric, update the usage output to also include --sum

[18:55] <dalek> book: review: https://github.com/perl6/book/commit/40b1d5d665

[18:55] <lichtkind> jnthn: goof om

[18:55] <lichtkind> i just come from it

[18:55] <lichtkind> i mean nom

[19:00] <Radvendii> nom: $_ = 'wK'; say "yay" if 1== /w/ ?? 1 !! 2

[19:00] <p6eval> nom 27a5dd: OUTPUT¬´No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:‚ê§:(Mu:U \$v, Mu %_!)‚ê§‚ê§  in method Numeric at src/gen/CORE.setting:649‚ê§  in sub infix:<==> at src/gen/CORE.setting:2276‚ê§  in block <anon> at /tmp/3qPRgCHe_G:1‚ê§  in <anon> at /tmp/3qPR‚Ä¶

[19:00] <Radvendii> nom: $_ = 'wK'; say "yay" if 1== (/w/ ?? 1 !! 2)

[19:00] <p6eval> nom 27a5dd: OUTPUT¬´yay‚ê§¬ª

[19:01] <Radvendii> nom: say "yup" if 1==2|1

[19:01] <p6eval> nom 27a5dd: OUTPUT¬´yup‚ê§¬ª

[19:02] <Radvendii> is there a Bool !! else ?? if syntax?

[19:03] <Radvendii> reversing the if and the else, kind of like an "unless"

[19:03] <moritz> no

[19:03] <Radvendii> okay

[19:08] <moritz> jnthn: https://gist.github.com/1677947 that's where I'm currently stuck (includes patch and backtrace)

[19:08] <moritz> OOOH, I know what's wrong

[19:08] <moritz> unstuck

[19:08] <moritz> don't call an attribute $.new

[19:08] <Radvendii> haha

[19:08] <moritz> it generates an accessor which overrwrites the constructor

[19:08] <Radvendii> good idea

[19:09] <[Coke]> moritz, masak: can you tell me how many people have submitted anything? (I know i haven't submitted anything yet.)

[19:10] <Radvendii> is there a way to overwrite variables as they are being passed into a subroutine?

[19:11] <Radvendii> like a default value, except that it is applied to the value they pass in

[19:11] <[Coke]> ... you mean, can you ignore the value they pass in?

[19:11] <[Coke]> that seems dubious.

[19:12] <Radvendii> nom: sub a($a=$a+1){say $a}; a(3)

[19:12] <p6eval> nom 27a5dd: OUTPUT¬´3‚ê§¬ª

[19:12] <Radvendii> except in what i am talking about that would be 4...

[19:12] <Radvendii> nom: sub a($a+1){say $a}; a(3)

[19:12] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "($a+1){say"‚ê§¬ª

[19:13] <Radvendii> nom: sub a($a+=1){say $a}; a(3)

[19:13] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "($a+=1){sa"‚ê§¬ª

[19:13] <moritz> nom: sub a($a is copy) { $a++; say $a }

[19:13] <p6eval> nom 27a5dd:  ( no output )

[19:13] <moritz> nom: sub a($a is copy) { $a++; say $a }; a(3)

[19:13] <p6eval> nom 27a5dd: OUTPUT¬´4‚ê§¬ª

[19:13] *** alester joined
[19:13] <moritz> signatures are for matching and binding, not for computations

[19:13] <Radvendii> i guess...

[19:14] <[Coke]> there's already a perfectly good place to write code, in the body. ;)

[19:14] <Radvendii> haha. i know. it just seems more clear to have all of the variable processing in the signature

[19:14] <moritz> no.

[19:14] <moritz> the signature is part of the public API

[19:15] <Radvendii> nom: sub a($tmp, :$a=$tmp+1){say $a}; a(3)

[19:15] <moritz> how you treat it internally isn't part of the API

[19:15] <p6eval> nom 27a5dd: OUTPUT¬´4‚ê§¬ª

[19:15] <TimToady> sorear: often a context diff will do better than a unidiff, if there is mismatched context in the middle of a unidiff

[19:15] <Radvendii> moritz: understood.

[19:15] <skids> nom: sub a($a, :$b? = $a + 1) { say $b; }; a(3); # but then you have the :b named parameter publicly available even if you do not want it.

[19:15] <p6eval> nom 27a5dd: OUTPUT¬´4‚ê§¬ª

[19:15] <benabik> Radvendii: Would you want to write `my $a + 1 = 3` and have $a = 4?

[19:16] <moritz> .oO( let's integrate an algebraic equation solver in p6... )

[19:16] <Radvendii> no...

[19:16] <Radvendii> moritz: agreed

[19:16] <moritz> in the multi dispatcher! jnthn, we look at you! (jk)

[19:21] <Radvendii> what's the perl6 equivalent to Javas toString() method?

[19:21] <benabik> .Str

[19:21] <Radvendii> and that's what say will call?

[19:21] <moritz> .gist

[19:22] <benabik> IIUC, "$a" and print $a will call $a.Str.  say $a will call $a.gist

[19:22] <[Coke]> (that is going to cause so much trouble. :P

[19:22] <Radvendii> why are they different?

[19:23] <Radvendii> shouldn't they do exactly the same thing?

[19:23] <moritz> then we wouldn't need different methods :-)

[19:23] <skids> say is for programmers.  Print is for users. 

[19:23] <moritz> aye

[19:23] <Radvendii> oh.

[19:24] <Radvendii> but for thingsl like ints, it's going to do the same

[19:24] <moritz> aye

[19:25] <Radvendii> haha. i've been pronouncing gist in my head with a hard g, so i was confused as to it's meaning. now i'm confused as to how it relates to string conversions...

[19:27] <TimToady> and I used to pronounce zavolaj with an affricate on the end until I thought about it...

[19:29] <Radvendii> . . .

[19:29] <pmichaud> back from lunch

[19:29] <huf> what's an affricate?

[19:29] <huf> i mean in this context

[19:29] <TimToady> a stop plus its associated fricative, in this case j as in judge

[19:30] <huf> oh, so zavoladj when it should be zavolay?

[19:31] *** birdwindupbird joined
[19:31] <timotimo> is foo() and foo always equivalent?

[19:31] <TimToady> well, zah voe lie in English

[19:31] <pmichaud> timotimo: no

[19:31] <TimToady> (I suspect)

[19:31] <moritz> nom: sub f(*@a) { say @a.join }; f() + 1; f + 1

[19:31] <p6eval> nom 27a5dd: OUTPUT¬´‚ê§1‚ê§¬ª

[19:32] <moritz> a case where it's not equivalent

[19:32] <huf> TimToady: got it.

[19:33] <moritz> gah, tim<tab> can now result in 3 different nicks :/

[19:33] <huf> TimToady: btw, what was the mnemonic (or the idea behind) calling bless bless in p5?

[19:33] <benabik> moritz: It's parsing that as f ( +1 ) ?

[19:33] <TimToady> it's asking your boss to bless your proposed project

[19:33] <skids> .oO("fricative" sounds like it should mean "an almost dirty word")

[19:34] <huf> well _now_ i'm confused.

[19:34] <Radvendii> moritz: why did your gah, ... comment make the bloop sound that usually asociates someone "Radvendii:"ing me

[19:35] <TimToady> huf: it's extending Official Recognition to the fact that a particular thing is in a particular category

[19:35] <Radvendii> nom: $a = "hi"; say $a.length;

[19:35] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§Variable $a is not predeclared at line 1, near " = \"hi\"; s"‚ê§¬ª

[19:35] <Radvendii> nom: my $a = "hi"; say $a.length;

[19:35] <p6eval> nom 27a5dd: OUTPUT¬´Method 'length' not found for invocant of class 'Str'‚ê§  in block <anon> at /tmp/lBerofVIYp:1‚ê§  in <anon> at /tmp/lBerofVIYp:1‚ê§¬ª

[19:36] <skids> nom: my $a = "hi"; say $a.chars;

[19:36] <p6eval> nom 27a5dd: OUTPUT¬´2‚ê§¬ª

[19:36] <Radvendii> ah

[19:37] <Radvendii> nom: my $a = "hi"; say $a.bytes;

[19:37] <skids> length is now ambiguous what with unicode/charset support.

[19:37] <p6eval> nom 27a5dd: OUTPUT¬´2‚ê§¬ª

[19:37] <huf> TimToady: so bless as in sanctify? (as in "admit to the list of saints")

[19:37] <Radvendii> so what's the difference betwixt .chars and .bytes?

[19:37] <skids> if your charset is 8-bit, nothing.

[19:37] <benabik> Radvendii: One returns the number of characters, the other the number of bytes.  ;-P

[19:37] <TimToady> huf: yes, there's some of that meaning too

[19:38] <Radvendii> nom: my $a = "ƒÅ≈Ç"; say $a.bytes;

[19:38] <p6eval> nom 27a5dd: OUTPUT¬´4‚ê§¬ª

[19:38] <TimToady> a constructor looks at the arguments and decides whether they make a sheep or a goat

[19:38] <Radvendii> i see

[19:38] <huf> TimToady: i am not familiar with this meaning of bless

[19:38] <huf> should've spent more time in church, i guess

[19:38] <huf> or reading bookses or somethjing

[19:39] <skids> Actually it's a secret conspiracy to rhyme with "dress", which will be revealed in an exceptionally bad limerick in 2015.

[19:39] <huf> that'd be really really great

[19:39] <pmichaud> skids: does that make it a revealing dress?  ;-)

[19:40] <Radvendii> groan...

[19:40] <TimToady> I doubt we can make skids fess

[19:40] * Radvendii meant that in the way-you're-supposed-to-react-to-puns way

[19:40] <dalek> rakudo/nom: 3670b71 | moritz++ | src/ (2 files):

[19:40] <dalek> rakudo/nom: <.obs> in the grammar now throws X::Obsolete objects

[19:40] <dalek> rakudo/nom: 

[19:40] <dalek> rakudo/nom: also provides a small piece of infrastructure for easily throwing typed exceptions from the grammar

[19:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3670b71121

[19:41] <pmichaud> TimToady: You're probably right, I guess.

[19:41] <TimToady> no less!  :)

[19:41] <dalek> roast: dc765eb | moritz++ | S32-exceptions/misc.t:

[19:41] <dalek> roast: tests for typed exceptions

[19:41] <dalek> roast: review: https://github.com/perl6/roast/commit/dc765ebbf6

[19:41] <huf> Radvendii: this channel would sound like the zombie apocalypse if everyone groaned everytime someone made a pun :D

[19:41] <Radvendii> huf: haha

[19:42] <pmichaud> phenny: tell jnthn I'm working on the star configure, but will likely need at least one more day to finish it.

[19:42] <phenny> pmichaud: I'll pass that on when jnthn is around.

[19:43] <Radvendii> nom: $a = 1,2,3; .say for $a

[19:43] <p6eval> nom 27a5dd: OUTPUT¬´===SORRY!===‚ê§Variable $a is not predeclared at line 1, near " = 1,2,3; "‚ê§¬ª

[19:43] <Radvendii> nom: my $a = 1,2,3; .say for $a

[19:43] <p6eval> nom 27a5dd: OUTPUT¬´1‚ê§¬ª

[19:43] <Radvendii> nom: my $a = (1,2,3); .say for $a

[19:43] <p6eval> nom 27a5dd: OUTPUT¬´1 2 3‚ê§¬ª

[19:43] <Radvendii> nom: my $a = (1,2,3); .say for @$a

[19:43] <p6eval> nom 27a5dd: OUTPUT¬´1‚ê§2‚ê§3‚ê§¬ª

[19:46] <Radvendii> nom: my $a=1; my $b=$a.clone; $b=2; say $a;

[19:46] <p6eval> nom 27a5dd: OUTPUT¬´1‚ê§¬ª

[19:46] <benabik> nom: my $a = 1; my $b = $a; $b = 2; say $a

[19:46] <p6eval> nom 27a5dd: OUTPUT¬´1‚ê§¬ª

[19:46] <benabik> nom: my $a = 1; my $b := $a; $b = 2; say $a

[19:46] <p6eval> nom 27a5dd: OUTPUT¬´2‚ê§¬ª

[19:46] <benabik> nom: my $a = 1; my $b := $a.clone; $b = 2; say $a

[19:46] <p6eval> nom 27a5dd: OUTPUT¬´Cannot assign to a non-container‚ê§  in block <anon> at /tmp/ufOuNPBTWL:1‚ê§  in <anon> at /tmp/ufOuNPBTWL:1‚ê§¬ª

[19:46] <benabik> awh.

[19:47] <Radvendii> ;P almost

[19:47] <Radvendii> nom: my $a=\1; my $b=$a.clone; $b=\2; say $a;

[19:47] <p6eval> nom 27a5dd: OUTPUT¬´1‚ê§¬ª

[19:47] <Radvendii> \ is still the way to create references right?

[19:47] <Radvendii> nom: my $a=(1,2,3); my $b=$a.clone; $b[0]='a'; say $a;

[19:47] <p6eval> nom 27a5dd: OUTPUT¬´Cannot assign to a non-container‚ê§  in block <anon> at /tmp/BdgBWrzT0O:1‚ê§  in <anon> at /tmp/BdgBWrzT0O:1‚ê§¬ª

[19:48] <Radvendii> nom: my @a=(1,2,3); my $b=@a.clone; $b[0]='a'; say @a;

[19:48] <p6eval> nom 27a5dd: OUTPUT¬´elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:4952‚ê§  in method REIFY at src/gen/CORE.setting:5186‚ê§  in method reify at src/gen/CORE.setting:4376‚ê§  in method gimme at src/gen/CORE.setting:4740‚ê§  in method exists at src/gen/CORE.sett‚Ä¶

[19:49] <benabik> Radvendii: I do not think that's doing what you think it's doing.

[19:49] <Radvendii> it appears not.

[19:49] <timotimo> https://raw.github.com/perl6/book/master/src/classes-and-objects.pod ‚Üê the line $some-task === any(@!dependencies) in "method depends-on" seems useless. its return value isn't used, is it? i suppose the intent was to make it the implicit return value, so adding an or in between the lines would fix it?

[19:49] <Radvendii> what is .clone doing?

[19:50] <moritz> Radvendii: see S12

[19:51] <Radvendii> clone should create an identical copy right? but it should be it's own variable, so when i modify it the original is untouched?

[19:52] <pmichaud> clone is typically for values, not containers

[19:52] <pmichaud> so "it should be its own variable" reads kind of wrongish there

[19:53] <pmichaud> nom: my @a = 1,2,3;  my $b = @a.clone; say $b.perl;

[19:53] <p6eval> nom 27a5dd: OUTPUT¬´elements() not implemented in class 'Mu'‚ê§  in method REIFY at src/gen/CORE.setting:4952‚ê§  in method REIFY at src/gen/CORE.setting:5186‚ê§  in method reify at src/gen/CORE.setting:4376‚ê§  in method reify at src/gen/CORE.setting:4376‚ê§  in method gimme at src/gen/CORE.setti‚Ä¶

[19:53] <benabik> I think that Array.clone has problems.

[19:53] <pmichaud> that looks buggy-ish

[19:53] <pmichaud> I agree; I think Array.clone is broken

[19:54] <jnthn> Array.clone is just doing whatever Mu.clone is doing. That's almost certainly inappropriate.

[19:54] <phenny> jnthn: 19:42Z <pmichaud> tell jnthn I'm working on the star configure, but will likely need at least one more day to finish it.

[19:54] <pmichaud> it's probably defaulting to Mu..... what jnthn++ said

[19:54] <jnthn> Array likely needs its own .clone but I dunno what it should look like

[19:54] <jnthn> (esp. with regard to what it does with the unreified bits)

[19:55] <pmichaud> Whoever is responsible for the Array and List implementation really nee.... er.  Hmm.

[19:55] <Radvendii> okay. but I am cloning an object i made, modifying the clone, and the original is modified as well...

[19:55] <jnthn> pmichaud: ;)

[19:55] <moritz> Radvendii: it's not doing a deep clone

[19:56] <jnthn> Mu.clone does something sane with scalar containers. If you've got an array or hash in there, it won't be doing much about that at the moment.

[19:56] <TimToady> unreified bits should generally be assumed to be idempotent, I think

[19:56] <Radvendii> so .clone is not very well implimented yet...

[19:56] <Radvendii> understood

[19:56] <pmichaud> since iterators/cursors are considered immutable, the cloned array probably shares that part

[19:57] *** bluescreen10 joined
[19:57] <jnthn> Sounds sane.

[19:57] <jnthn> pmichaud: (one more day) as in, might be done tomorrow, or at earliest Friday?

[19:58] <pmichaud> might be done tomorrow

[19:58] <jnthn> OK.

[19:58] * jnthn crosses fingers for that :)

[19:59] <pmichaud> I could push it through today, but I'd be taking a couple of shortcuts that we'd have to clean up later

[19:59] <pmichaud> having an extra evening to reflect on it a bit will give a better impl

[19:59] <jnthn> pmichaud: So long as we get it released this week, I'm happy enough.

[20:02] <pmichaud> (this week) as in "before Saturday" or ...?

[20:03] <jnthn> Yeah

[20:03] <Radvendii> something about .gist is printing out TrueTrueTrueTrueTrueTrue at the end of what i print

[20:03] <Radvendii> well, 8 true's...

[20:04] <Radvendii> which is the size of my array

[20:05] <pmichaud> I suspect you may be printing the result of say()

[20:05] <pmichaud> nom:  say say say "what you want"

[20:05] <p6eval> nom 3670b7: OUTPUT¬´what you want‚ê§Bool::True‚ê§Bool::True‚ê§¬ª

[20:05] <Radvendii> oh

[20:05] <Radvendii> yes i am

[20:05] <Radvendii> thanks

[20:06] *** GlitchMr left
[20:07] <pmichaud> nom: take take take "what you need"

[20:07] <p6eval> nom 3670b7: OUTPUT¬´stray take statement‚ê§  in block <anon> at /tmp/1VT3DvTK9K:1‚ê§  in <anon> at /tmp/1VT3DvTK9K:1‚ê§¬ª

[20:07] * pmichaud wonders if anyone recognizes the reference.  :-)

[20:07] <skids> Steppenwolf?

[20:08] <pmichaud> http://en.wikipedia.org/wiki/Say_Say_Say

[20:09] * Radvendii got that there was a reference

[20:10] <pmichaud> do we have a "pray" function yet?   ;-)   (   pray pray pray "everyday"  )

[20:11] <Radvendii> we should... and make it have something to do with bless...

[20:11] <jnthn> pmichaud: I didn't, but having looked at the page I realized that the reference is older than I am. ;-)

[20:11] * skids considers golfing Janis Joplin "Piece of My Heart" lyrics until they parse.

[20:12] <pmichaud> jnthn: yeah, I was afraid I now fall into the "Oldies" genre.  :-)

[20:12] <Radvendii> this is quite odd...

[20:12] <jnthn> pmichaud: Having just listened to a clip of the song, I am pretty sure I've heard it before, however. :)

[20:13] *** Guest20598 is now known as Khisanth

[20:13] <skids> .oO(it isn't that you're an oldie if you like songs made before you were born.  In that case you're an archivist, not an oldie.)

[20:13] <Radvendii> i run $a = ThisClass.new; $a.b = self.b;  $a[0]=1; and suddenly self[0] is 1! (@.b handles array)

[20:14] *** ksi joined
[20:14] <pmichaud> I was in high school when that song came out, so I don't fall in the "song made before I was born" category, though.  :-/

[20:17] <timotimo> niecza: multi barf($) { "meep" }; only sub barf(Int $a) { $a + 5 }; barf("a")

[20:17] <p6eval> niecza v13-352-g6694950: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Illegal redeclaration of routine 'barf' (see line 1) at /tmp/S5VBAvFAVi line 1:‚ê§------> [32mmulti barf($) { "meep" }; only sub barf[33m‚èè[31m(Int $a) { $a + 5 }; barf("a")[0m‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /hom‚Ä¶

[20:17] <timotimo> pugs: multi barf($) { "meep" }; only sub barf(Int $a) { $a + 5 }; barf("a")

[20:17] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "$)"‚ê§    expecting formal parameter or ")"‚ê§    at /tmp/5TBV_NF__4 line 1, column 12‚ê§¬ª

[20:19] *** birdwindupbird left
[20:20] <Radvendii> nom: Class A {has @.b=1,2,3; method c { my $a = A.new; $a.b=self.b; $a.b[0]=4; self.b.say;}}; my $x = A.new; A.c;

[20:20] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§You can't declare an attribute here; maybe you'd like a class or a role? at line 1, near "=1,2,3; me"‚ê§¬ª

[20:20] <Radvendii> nom: Class A {has @.b = (1,2,3); method c { my $a = A.new; $a.b=self.b; $a.b[0]=4; self.b.say;}}; my $x = A.new; A.c;

[20:20] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§You can't declare an attribute here; maybe you'd like a class or a role? at line 1, near " = (1,2,3)"‚ê§¬ª

[20:20] <jnthn> Radvendii: wRONG CASE

[20:21] <dalek> book: c6ccbe3 | timo++ | src/multi-dispatch.pod:

[20:21] <dalek> book: Rakudo implements "only sub YourSub", niecza and pugs still don't.

[20:21] <dalek> book: review: https://github.com/perl6/book/commit/c6ccbe3b29

[20:21] <Radvendii> nom: class A {has @.b = (1,2,3); method c { my $a = A.new; $a.b=self.b; $a.b[0]=4; self.b.say;}}; my $x = A.new; A.c;

[20:21] <p6eval> nom 3670b7: OUTPUT¬´Cannot look up attributes in a type object‚ê§  in method b at src/gen/CORE.setting:1384‚ê§  in method c at /tmp/gWyM3qRy6m:1‚ê§  in block <anon> at /tmp/gWyM3qRy6m:1‚ê§  in <anon> at /tmp/gWyM3qRy6m:1‚ê§¬ª

[20:21] <Radvendii> jnthn: thanks

[20:23] <Radvendii> i dont get the error...

[20:23] <Radvendii> what attribute am i look up in which type object?

[20:24] <pmichaud> self.b  from inside of A.c

[20:24] <Radvendii> why is that a problem?

[20:24] <pmichaud> because A is a type object

[20:24] <Radvendii> nom: class A {has @.b = (1,2,3); method c { my $a = A.new; $a.b=@.b; $a.b[0]=4; @.b.say;}}; my $x = A.new; A.c;

[20:24] <p6eval> nom 3670b7: OUTPUT¬´Cannot look up attributes in a type object‚ê§  in method b at src/gen/CORE.setting:1384‚ê§  in method c at /tmp/LgYglK6jPj:1‚ê§  in block <anon> at /tmp/LgYglK6jPj:1‚ê§  in <anon> at /tmp/LgYglK6jPj:1‚ê§¬ª

[20:24] <Radvendii> oh

[20:24] <Radvendii> that doesnt help

[20:25] <Radvendii> what does type object mean?

[20:25] <pmichaud> A is the object that represents the class

[20:25] <jnthn> Radvendii: Did you meant to call $x.c at the end?

[20:25] <Radvendii> ah

[20:25] <Radvendii> yes

[20:25] <Radvendii> nom: class A {has @.b = (1,2,3); method c { my $a = A.new; $a.b=@.b; $a.b[0]=4; @.b.say;}}; my $x = A.new; $x.c;

[20:25] <p6eval> nom 3670b7: OUTPUT¬´1 2 3‚ê§¬ª

[20:25] <pmichaud> so when you have A.c at the end, you're invoking the 'c' method on the type object, instead of an instance of the type object

[20:25] <Radvendii> right

[20:25] <Radvendii> that makes sense

[20:25] <Radvendii> i thought it was something i was doing within the c method

[20:26] <Radvendii> nom: class A {has @.b = (1,2,3); method c { my $a = A.new; $a.b=@.b; $a.b[0]=4; @.b.say; $a.b.say}}; my $x = A.new; $x.c;

[20:26] <p6eval> nom 3670b7: OUTPUT¬´1 2 3‚ê§4 2 3‚ê§¬ª

[20:27] *** tokuhirom joined
[20:28] <pmichaud> afk again for a while... probably won't be back until tomorrow morning

[20:28] <Radvendii> o/

[20:28] <jnthn> o/

[20:33] <Radvendii> nom: say <a b c>.map({$_})

[20:33] <p6eval> nom 3670b7: OUTPUT¬´a b c‚ê§¬ª

[20:34] *** skids left
[20:42] *** bbkr1 joined
[20:45] <masak> nom: class A { our method foo { say "OH HAI" unless self.^name eq "A"; return &foo } }; class B is A { method bar(&c) { self.&c } }; B.bar(A.foo)

[20:45] <p6eval> nom 3670b7: OUTPUT¬´OH HAI‚ê§¬ª

[20:45] <masak> \o/

[20:45] <masak> that's... sick :)

[20:45] <masak> niecza: class A { our method foo { say "OH HAI" unless self.^name eq "A"; return &foo } }; class B is A { method bar(&c) { self.&c } }; B.bar(A.foo)

[20:46] <p6eval> niecza v13-352-g6694950: OUTPUT¬´OH HAI‚ê§¬ª

[20:46] <masak> \o/

[20:46] <masak> niecza: class A { our method foo { say "OH HAI" unless self.^name eq "A"; return &foo } }; class B { method bar(&c) { self.&c } }; B.bar(A.foo)

[20:46] <p6eval> niecza v13-352-g6694950: OUTPUT¬´Unhandled exception: Nominal type check failed in binding self in A.foo; got B, needed A‚ê§  at /tmp/cS5Pj7J_Fl line 0 (A.foo @ 1) ‚ê§  at /tmp/cS5Pj7J_Fl line 1 (B.bar @ 3) ‚ê§  at /tmp/cS5Pj7J_Fl line 1 (mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.settin‚Ä¶

[20:46] <masak> indeed.

[20:47] <jnthn> masak: Why the "our"? :)

[20:48] <bbkr1> What is the best practice to define attribute default value in child class? Let's say I have class A { has Str $.id }. Now I can write class B is A { has $.id = 8 } which  is not good as it redeclares type. Or I can write class B is A { submethod BUILD { $.id = 8 } } which is also not good as this is slow runtime assignment and it has to be repeated in every BUILD method.

[20:48] <jnthn> You shouldn't be doing $.id in BUILD anyway

[20:48] *** ggoebel left
[20:49] <jnthn> BUILD submethod should always refer directly to the storage slot ($!id)

[20:49] <bbkr1> I know, that's why i search for better solution

[20:51] <masak> jnthn: so that the method gets registered in the namespace of class A, so that I can return &foo from it :)

[20:51] <jnthn> masak: ah, I see

[20:51] <bbkr1> for example P5-ism from Moose was: has '+id' => ('default' => 8 );

[20:51] <masak> jnthn: I bet there's an easier way to return a routine from itself... :)

[20:51] <jnthn> Guess you could return &?ROUTINE

[20:52] <jnthn> nom: sub foo() { say "hi"; return &?ROUTINE; }; my $x = foo(); $x()

[20:52] <p6eval> nom 3670b7: OUTPUT¬´hi‚ê§hi‚ê§¬ª

[20:52] *** fsergot left
[20:53] *** ggoebel joined
[20:54] *** MayDaniel joined
[21:01] <timotimo> rakudo: my %foo = 1 => "one", 2 => "two"; say %foo[1]

[21:01] <p6eval> rakudo 3670b7: OUTPUT¬´Failure.new(exception => Exception.new())‚ê§¬ª

[21:01] <timotimo> i must be very confused. why doesn't that work?

[21:01] <jnthn> Because you're doing array indexing, not hash indexing. :)

[21:02] <jnthn> rakudo: my %foo = 1 => "one", 2 => "two"; say %foo{1}

[21:02] <p6eval> rakudo 3670b7: OUTPUT¬´one‚ê§¬ª

[21:02] <timotimo> oooooooooh, duh!

[21:02] *** mj41 joined
[21:02] <Radvendii> nom: say ?('wK' !~~ 'b')

[21:02] <p6eval> nom 3670b7: OUTPUT¬´Bool::True‚ê§¬ª

[21:03] <Radvendii> nom: say ?('wK' !~~ 'w')

[21:03] <p6eval> nom 3670b7: OUTPUT¬´Bool::True‚ê§¬ª

[21:03] <Radvendii> nom: say ?('wK' !~~ /w/)

[21:03] <p6eval> nom 3670b7: OUTPUT¬´Bool::False‚ê§¬ª

[21:03] <[Coke]> nom: say ?('wK' !~~ /'w'/)

[21:03] <p6eval> nom 3670b7: OUTPUT¬´Bool::False‚ê§¬ª

[21:04] <Radvendii> <w b>.grep: -> $x {'wK' !~~ /$x/}

[21:04] <Radvendii> nom: say <w b>.grep: -> $x {'wK' !~~ /$x/}

[21:04] <p6eval> nom 3670b7: OUTPUT¬´b‚ê§¬ª

[21:05] <Radvendii> nom: sub a($l) { <w b>.grep: -> $x {$l !~~ /$x/} }; a('wK');

[21:05] <p6eval> nom 3670b7:  ( no output )

[21:05] <Radvendii> nom: sub a($l) { <w b>.grep: -> $x {$l !~~ /$x/} }; say a('wK');

[21:05] <p6eval> nom 3670b7: OUTPUT¬´b‚ê§¬ª

[21:06] <Radvendii> nom: sub a($l, $c = (<w b>.grep: -> $x {$l !~~ /$x/}) { say $c }; a('wK');

[21:06] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "($l, $c = "‚ê§¬ª

[21:06] <Radvendii> nom: sub a($l, $c = (<w b>.grep: -> $x {$l !~~ /$x/})) { say $c }; a('wK');

[21:06] <p6eval> nom 3670b7: OUTPUT¬´b‚ê§¬ª

[21:08] <Radvendii> ugh. lazy evaluating is so annoying sometimes!

[21:09] *** molaf left
[21:09] <Radvendii> is there any way to 'require' evaluation, without printing out the results?

[21:09] <jnthn> Radvendii: eager

[21:10] <Radvendii> can i just say eager $a;?

[21:10] <jnthn> Think so

[21:11] <Radvendii> nom: my $a=1; my @a = $a xx *; eager @a; $a=2; say @a[0];

[21:11] <p6eval> nom 3670b7: OUTPUT¬´2‚ê§¬ª

[21:11] <Radvendii> nope

[21:12] <Radvendii> nom: my $a=1; my @a = $a xx *; @a; $a=2; say @a[0];

[21:12] <p6eval> nom 3670b7: OUTPUT¬´2‚ê§¬ª

[21:14] <Radvendii> nom: my $a=0; my @a = $a xx *; while $a++ < 5 {say @a[$a]}

[21:14] <p6eval> nom 3670b7: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§5‚ê§¬ª

[21:14] <Radvendii> tee hee

[21:14] <PerlJam> nom: my $a=1; my @a = eager $a xx *;  $a=2; say @a[0];

[21:14] <p6eval> nom 3670b7: OUTPUT¬´2‚ê§¬ª

[21:15] <Radvendii> nom: my $a=1; eager my @a = $a xx *;  $a=2; say @a[0];

[21:15] <p6eval> nom 3670b7: OUTPUT¬´2‚ê§¬ª

[21:15] <[Coke]> I think when you say lazy you're not meaning what perl 6 lazy means.

[21:15] <[Coke]> I think you're confused about container semantics.

[21:15] <Radvendii> maybe?

[21:17] <Radvendii> nom: sub a($b is copy,$c=$b+1) {$b++; say $c}; a(1)

[21:17] <p6eval> nom 3670b7: OUTPUT¬´2‚ê§¬ª

[21:18] <Radvendii> nom: sub a($b is copy,$c=$b+1) {$b=3; say $c}; a(1)

[21:18] <p6eval> nom 3670b7: OUTPUT¬´2‚ê§¬ª

[21:18] <Radvendii> that's not happening for me...

[21:18] <Radvendii> well, not in that exact form, but close enough

[21:19] <Radvendii> nom: sub a($b is copy,$c=(<w b>.grep: -> $x { $l !~~ /$x/})) {$b='b'; say $c}; a('w')

[21:19] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Variable $l is not predeclared at line 1, near " !~~ /$x/}"‚ê§¬ª

[21:20] <Radvendii> nom: sub a($b is copy,$c=(<w b>.grep: -> $x { $b !~~ /$x/})) {$b='b'; say $c}; a('w')

[21:20] <p6eval> nom 3670b7: OUTPUT¬´w‚ê§¬ª

[21:20] <Radvendii> see?

[21:20] <Radvendii> nom: sub a($b is copy,$c=(<w b>.grep: -> $x { $b !~~ /$x/})) {say $c;$b='b';}; a('w')

[21:20] <p6eval> nom 3670b7: OUTPUT¬´b‚ê§¬ª

[21:21] <Radvendii> it's the .grep that's lazy

[21:21] <moritz> that's because grep is lazy

[21:21] <moritz> right

[21:22] <moritz> nom: sub a($b is copy, @c = (<w b>.grep({ !/$x/})) { $b = 'b'; say @c }; a('w')

[21:22] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Variable $x is not predeclared at line 1, near "/})) { $b "‚ê§¬ª

[21:22] <moritz> nom: sub a($b is copy, @c = (<w b>.grep(-> $x { !/$x/})) { $b = 'b'; say @c }; a('w')

[21:22] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Malformed block at line 1, near "($b is cop"‚ê§¬ª

[21:23] * moritz too tired to code

[21:24] <Radvendii> ;) go to bed

[21:25] <moritz> I will.

[21:29] <Radvendii> why does "say" return 1 or 0 and not what it said...

[21:29] <moritz> why should it?

[21:30] *** ggoebel left
[21:30] <Radvendii> because it's always more useful to get back what it said than it's success

[21:32] <masak> I disagree.

[21:32] <moritz> well, it's certainly p5ish to return the success status

[21:32] <masak> though I never use the return value of &say in any form whatsoever.

[21:32] <masak> yeah, was just going to say that :)

[21:33] <moritz> I'd expect it die violently if it fails

[21:33] <benabik> What is said may also be larger than you really want to keep a string around for.

[21:33] <masak> IIRC, Rakudo simply returns True always.

[21:33] <moritz> benabik: that would have been my next point to make

[21:33] <benabik> moritz: GMTA

[21:33] *** mj41 left
[21:33] <masak> benabik: well, a sink context optimizer would take care of that...

[21:34] <moritz> benabik: fsvo'G'

[21:34] <moritz> :-)

[21:34] *** alester left
[21:34] <masak> doing it with the other letters are worse insults :P

[21:34] <moritz> std: #`

[21:34] <p6eval> std 47c76b3: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Opening bracket is required for #` comment at /tmp/WjGbkadWON line 1:‚ê§------> [32m#`[33m‚èè[31m<EOL>[0m‚ê§Parse failed‚ê§FAILED 00:01 96m‚ê§¬ª

[21:35] *** ggoebel joined
[21:37] *** molaf joined
[21:39] <Radvendii> that's just my point, always returning true isn't helpful, and when i want to throw a say in to see what a function is returning, the return then stops returning what i want...

[21:43] <prammer> sounds like you want something like Dwarn (p5)  https://metacpan.org/module/Devel::Dwarn

[21:44] *** MayDaniel left
[21:45] <Radvendii> yes, unfortunately that's only for perl _5_ . also, it still doesn't make sense to me that say would return a boolean at all. it's just not helpful. or intuitive.

[21:45] <Radvendii> nom: say print "a"

[21:45] <p6eval> nom 3670b7: OUTPUT¬´aBool::True‚ê§¬ª

[21:51] <bbkr1> rakudo: class A { has Int $.id; }; class B is A { submethod BUILD ( :$!id = 10 ) { } }; B.new'

[21:51] <p6eval> rakudo 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "B.new'"‚ê§¬ª

[21:51] <bbkr1> rakudo: class A { has Int $.id; }; class B is A { submethod BUILD ( :$!id = 10 ) { } }; B.new

[21:51] <p6eval> rakudo 3670b7: OUTPUT¬´Null PMC access in get_pmc_keyed_str()‚ê§  in submethod BUILD at /tmp/NGnaIv23u2:1‚ê§  in method BUILDALL at src/gen/CORE.setting:583‚ê§  in method bless at src/gen/CORE.setting:573‚ê§  in method new at src/gen/CORE.setting:558‚ê§  in block <anon> at /tmp/NGnaIv23u2:1‚ê§  in <‚Ä¶

[21:51] <bbkr1> known bug? it only happens on inherited attributes.

[21:52] <bbkr1> another variation

[21:52] <bbkr1> rakudo: class A { has Int $.id; }; class B is A { submethod BUILD ( $!id? ) { } }; B.new

[21:52] <p6eval> rakudo 3670b7: OUTPUT¬´Null PMC access in get_pmc_keyed_str()‚ê§  in submethod BUILD at /tmp/qLZGBlS5WY:1‚ê§  in method BUILDALL at src/gen/CORE.setting:583‚ê§  in method bless at src/gen/CORE.setting:573‚ê§  in method new at src/gen/CORE.setting:558‚ê§  in block <anon> at /tmp/qLZGBlS5WY:1‚ê§  in <‚Ä¶

[21:54] <jnthn> bbkr1: That attribute ain't visible there.

[21:54] <jnthn> Why it doesn't explode is a bit mysterious though...

[21:54] <masak> nom: class A { has Int $.id; }; class B is A { submethod BUILD ( $!id ) { } }; B.new

[21:54] <p6eval> nom 3670b7: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in submethod BUILD at /tmp/8FMWmEVmBd:1‚ê§  in method BUILDALL at src/gen/CORE.setting:583‚ê§  in method bless at src/gen/CORE.setting:573‚ê§  in method new at src/gen/CORE.setting:558‚ê§  in block <anon> at /tmp‚Ä¶

[21:54] <masak> aha!

[21:54] <jnthn> Of course, we can catch that one at compile time.

[21:55] <masak> yeah, but what about the error above?

[21:55] <jnthn> masak: The error above is "right" though we should really catch the other one at compile time.

[21:55] <jnthn> masak: I mean, we'd not make it to runtime there.

[21:56] <Radvendii> nom: say 1 ^...^ 4

[21:56] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "say 1 ^..."‚ê§¬ª

[21:56] <Radvendii> ..?

[21:56] <[Coke]> nom: sub llog(*@a) { .say for @a ; return @a}; foo($a,$b) { return llog $a+$b}; foo(3,4);

[21:56] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Variable $a is not predeclared at line 1, near ",$b) { ret"‚ê§¬ª

[21:56] <Radvendii> shouldn't that produce 2,3?

[21:56] <colomon> ^,,,^ doesn't exist

[21:56] <colomon> ^...^, I mean

[21:56] <[Coke]> nom: sub llog(*@a) { .say for @a ; return @a}; sub foo($a,$b) { return llog $a+$b}; foo(3,4);

[21:56] <p6eval> nom 3670b7: OUTPUT¬´7‚ê§¬ª

[21:57] * bbkr1 reports LTA message in this BUILD example

[21:57] <[Coke]> nom: sub llog(*@a) { .say for @a ; return @a}; sub foo($a,$b) { return llog $a+$b}; say "foo(3,4) is" + foo(3,4); 

[21:57] <p6eval> nom 3670b7: OUTPUT¬´7‚ê§1‚ê§¬ª

[21:57] <[Coke]> nom: sub llog(*@a) { .say for @a ; return @a}; sub foo($a,$b) { return llog $a+$b}; say "foo(3,4) is" ~ foo(3,4); 

[21:57] <p6eval> nom 3670b7: OUTPUT¬´7‚ê§foo(3,4) is7‚ê§¬ª

[21:57] <Radvendii> i thought ^ at one end excluded the endpoint there

[21:57] <[Coke]> Radvendii: there you go. 

[21:58] <jnthn> bbkr1: Thanks. I'm done with $dayjob tasks, had a stroll and have a few tuits, so may see if I can improve that now. But do file the ticket, so we can get test coverage. ;)

[21:58] <colomon> Radvendii: that's true for Range, not true for sequence

[21:58] <Radvendii> but isn't ... also used if you dont know which side is larger?

[21:58] <Radvendii> nom: say 5..3

[21:58] <p6eval> nom 3670b7: OUTPUT¬´5..3‚ê§¬ª

[21:59] <Radvendii> nom: say (5..3).list

[21:59] <p6eval> nom 3670b7: OUTPUT¬´‚ê§¬ª

[21:59] <Radvendii> nom: say (5...3).list

[21:59] <p6eval> nom 3670b7: OUTPUT¬´5 4 3‚ê§¬ª

[21:59] <PerlJam> Radvendii: note that ... and ^... and ...^ and ^...^ would all be separate operators if they all existed.

[21:59] <Radvendii> PerlJam: why? there's no way to make that a meta-op?

[22:00] <PerlJam> perhaps with macros

[22:00] *** bluescreen10 left
[22:00] <colomon> The idea of using ... if you don't know which side is larger is very dangerous in general

[22:01] <colomon> .. and ... are very different

[22:02] <Radvendii> how so...

[22:02] <[Coke]> grok ..

[22:03] <[Coke]> is the grokbot still about?

[22:03] <masak> nope.

[22:03] <[Coke]> .u sad

[22:03] <phenny> U+0635 ARABIC LETTER SAD (ÿµ)

[22:05] *** chee joined
[22:06] <colomon> Radvendii: .. creates a Range object, which (if numeric) represents a portion of the real line.  ... creates a sequence of numbers.

[22:06] <colomon> for instance:

[22:06] <colomon> nom: say 4..5.5;

[22:06] <p6eval> nom 3670b7: OUTPUT¬´4..11/2‚ê§¬ª

[22:07] <colomon> nom: say 4...5.5

[22:07] <p6eval> nom 3670b7: OUTPUT¬´(timeout)¬ª

[22:07] <colomon> timeout because 4...5.5 is the infinite sequence 4, 5, 6, 7...

[22:07] <colomon> another example:

[22:08] <colomon> nom: say 4.1 ~~ 4..5.5

[22:08] <p6eval> nom 3670b7: OUTPUT¬´Bool::True‚ê§¬ª

[22:08] <colomon> nom: say 4.1 ~~ 4...6

[22:08] <p6eval> nom 3670b7: OUTPUT¬´(timeout)¬ª

[22:08] <colomon> errr... not sure why that one blows up

[22:08] <Radvendii> ah...

[22:09] <Radvendii> :P

[22:09] <colomon> if you want a Range from $a to $b, but you don't know which is bigger, you can say

[22:09] <colomon> nom: my $a = rand; my $b = rand; say $a ~ " " ~ $b; say ($a, $b).minmax.perl

[22:09] <p6eval> nom 3670b7: OUTPUT¬´0.0948716237480802 0.257618284409062‚ê§0.0948716237480802e0..0.257618284409062e0‚ê§¬ª

[22:09] <colomon> nom: my $a = rand; my $b = rand; say $a ~ " " ~ $b; say ($a, $b).minmax.perl

[22:09] <p6eval> nom 3670b7: OUTPUT¬´0.357001702374877 0.587949935670139‚ê§0.357001702374877e0..0.587949935670139e0‚ê§¬ª

[22:11] <Radvendii> that seems like a bit much for such an operation...

[22:11] <colomon> ?

[22:11] <colomon> ($a, $b).minmax is too much work for you?

[22:12] <Radvendii> oh

[22:12] <Radvendii> i just realized that the rest of it wasn't part of the actual operation

[22:12] <colomon> you can also say it $a minmax $b

[22:12] <Radvendii> :P

[22:12] <PerlJam> minmax++

[22:13] <Radvendii> and minmax does the same thing as .. except orders them first?

[22:13] <Radvendii> wait...

[22:13] <benabik> nom: say 2..1; say 2 minmax 1

[22:13] <p6eval> nom 3670b7: OUTPUT¬´2..1‚ê§1..2‚ê§¬ª

[22:13] <Radvendii> nom: say 5 ^minmax^ 1

[22:14] <p6eval> nom 3670b7: OUTPUT¬´one(5, Inf..-Inf, 1)‚ê§¬ª

[22:14] <colomon> no, minmax orders them and then makes a Range (ie ..)

[22:14] <cognominal> nom: say Signature.^methods[0].WHAT'

[22:14] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "say Signat"‚ê§¬ª

[22:14] <Radvendii> colomon: that's what i said...

[22:14] <PerlJam> colomon: 4.1 ~~ 4...6 blows up because it means (4.1 ~~ 4) ... 6,  or False ... 6

[22:14] <cognominal> nom: say Signature.^methods[0].WHAT

[22:14] <p6eval> nom 3670b7: OUTPUT¬´Can only use get_what on a SixModelObject‚ê§  in block <anon> at /tmp/S_ZupZj2K4:1‚ê§  in <anon> at /tmp/S_ZupZj2K4:1‚ê§¬ª

[22:14] <cognominal> this probably explains https://rt.perl.org/rt3//Public/Bug/Display.html?id=108968

[22:14] <colomon> PerlJam++: ah!  thanks! 

[22:14] <cognominal> nom: say Int.^methods[0].WHAT

[22:15] <p6eval> nom 3670b7: OUTPUT¬´Method()‚ê§¬ª

[22:15] <Radvendii> PerlJam: shouldn't False evaluate to 0 in numerical context?

[22:15] <colomon> who said ... was numerical context?

[22:16] <Radvendii> oh right...

[22:16] *** kaare_ left
[22:16] <PerlJam> Radvendii: ... is deep and powerful magic  :)

[22:16] <Radvendii> nom: say 5 ^minmax 1

[22:16] <p6eval> nom 3670b7: OUTPUT¬´one(5, 1..1)‚ê§¬ª

[22:16] * Radvendii cocks an eyebrow

[22:16] <Radvendii> oh

[22:17] <colomon> nom: say (True, * ^^ True ... *)[10]

[22:17] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2‚ê§¬ª

[22:17] <Radvendii> i see what it's doing

[22:17] <colomon> you can't use ^ with minmax like you can with Range

[22:17] <colomon> std: say 5 ^minmax 1

[22:17] <Radvendii> colomon: so then it doesn't solve my original problem. and why not?

[22:17] <masak> colomon: you have control chars in your programs again.

[22:17] <p6eval> std 47c76b3: OUTPUT¬´ok 00:01 109m‚ê§¬ª

[22:18] *** ksi left
[22:18] <colomon> nom: say (True, * ^^ True ... *)[10]

[22:18] <p6eval> nom 3670b7: OUTPUT¬´Bool::False‚ê§¬ª

[22:18] <colomon> doh!

[22:18] <colomon> nom: say (True, !* ... *)[10]

[22:18] <p6eval> nom 3670b7: OUTPUT¬´Bool::True‚ê§¬ª

[22:18] <colomon> nom: say !True

[22:18] <p6eval> nom 3670b7: OUTPUT¬´Bool::False‚ê§¬ª

[22:19] <colomon> hmmm, I don't remember False stopping sequences

[22:19] <colomon> Radvendii: I don

[22:19] <colomon> t

[22:20] <colomon> Radvendii: I don't think anyone ever thought of adding ^minmax

[22:20] <PerlJam> I'm not sure what ^minmax would even mean

[22:20] <Radvendii> PerlJam: minmax, except not including the operand on that side?

[22:21] <colomon> so 10 ^minmax 1 would be 1 ..^ 10

[22:21] <Radvendii> yeah.

[22:21] <Radvendii> or it could be that 10 ^minmax 1 would be 1 ^.. 10

[22:21] <Radvendii> and by the way, i do want ...

[22:21] <[Coke]> if part of the point of minmax is that you might not know the order ahead of time, that seems iffy.

[22:22] <Radvendii> because i am doing something like:

[22:22] <colomon> I'd think the first explanation makes a lot more sense

[22:23] <Radvendii> nom: ((10 ... 1) ¬´,¬ª 3).map -> $i, $j { say $i, ", ", $j }

[22:23] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "((10 ... 1"‚ê§¬ª

[22:24] <Radvendii> ...?

[22:25] <Radvendii> nom: (10 ... 1 ¬´,¬ª 3).map -> $i, $j { say $i, ", ", $j }

[22:25] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "(10 ... 1 "‚ê§¬ª

[22:25] <Radvendii> nom: (10 ... 1 ¬ª,¬ª 3).map -> $i, $j { say $i, ", ", $j }

[22:25] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "(10 ... 1 "‚ê§¬ª

[22:27] <PerlJam> Radvendii: so ... what would  @a ^minmax @b  mean?

[22:28] <PerlJam> Basically the ^  there would just exclude the end point on that side?

[22:29] <Radvendii> i thought it would make more sense if it excluded it on the lesser side

[22:29] <cognominal> jnthn, in BOOTSTRAP.pm I think the added method should be put in a container so as not to later trigger a bug. What it the nqp:: sub for that?

[22:29] <Radvendii> because you wouldn't use minmax if you knew which side that was

[22:29] <PerlJam> so if @a minmax @b == $a..$b, then @a ^minmax @b == $a^..@b (and presumably  @a minmax^ @b == $a..^$b)   ?

[22:30] <cognominal> nom: say  Proxy.^methods[0].WHAT

[22:30] <p6eval> nom 3670b7: OUTPUT¬´Can only use get_what on a SixModelObject‚ê§  in block <anon> at /tmp/5EqRkdDmEM:1‚ê§  in <anon> at /tmp/5EqRkdDmEM:1‚ê§¬ª

[22:30] <jnthn> cognominal: Well, probably need to re-arrange things a little in there to make sure Method etc exists.

[22:30] <Radvendii> yeah. i think so

[22:30] <jnthn> cognominal: And they probably want some kinda signature object piecing together too

[22:30] <cognominal> all the classes that uses the HOW.add_method have the problem.

[22:30] <jnthn> cognominal: Yeah.

[22:31] <jnthn> cognominal: The problem is that they're adding a Parrot sub.

[22:31] <jnthn> (more)

[22:31] <Radvendii> nom: say (1..4).map(&say)

[22:31] <p6eval> nom 3670b7: OUTPUT¬´1‚ê§2‚ê§3‚ê§4‚ê§True True True True‚ê§¬ª

[22:31] <Radvendii> :P

[22:31] <jnthn> That could be resolved by wrapping them all in Perl 6 Methods. Alternatively, NQP may be about to get code objects too.

[22:32] <PerlJam> Radvendii: I'm dubious of the utility, but otherwise it seems okay

[22:32] <cognominal> ok

[22:32] <Radvendii> because right now i need a ^minmax^ operator

[22:32] <Radvendii> well... what i really need is ^...^

[22:32] <PerlJam> Radvendii: that's another kettle of fish though

[22:32] <Radvendii> why?

[22:33] <Radvendii> nom: say 1...^10

[22:33] <p6eval> nom 3670b7: OUTPUT¬´1 2 3 4 5 6 7 8 9‚ê§¬ª

[22:33] <Radvendii> nom: say 1^...20

[22:33] <p6eval> nom 3670b7: OUTPUT¬´1^..1/5‚ê§¬ª

[22:33] <Radvendii> nom: say 1^...10

[22:33] <p6eval> nom 3670b7: OUTPUT¬´1^..1/10‚ê§¬ª

[22:33] <Radvendii> nom: say 1(^...)10

[22:33] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "say 1(^..."‚ê§¬ª

[22:34] <Radvendii> nom: say 1 ^... 10

[22:34] <p6eval> nom 3670b7: OUTPUT¬´===SORRY!===‚ê§Confused at line 1, near "say 1 ^..."‚ê§¬ª

[22:34] <Radvendii> what is going on?

[22:34] <PerlJam> ^... is probably not implemented?

[22:34] <Radvendii> right

[22:35] <Radvendii> oh...

[22:35] <Radvendii> that's because...

[22:35] <Radvendii> nope

[22:35] <Radvendii> can't think of a reason

[22:35] <colomon> because it would mean "drop the first element of your sequence"

[22:35] <Radvendii> yeah...

[22:36] <PerlJam> btw,  I think there's either a spec bug or a rakudo bug.  Compare the text at S03:1721 with the output of my @a = 1..^10; my @b = 5..7;  @a minmax @b

[22:36] <PerlJam> nom: my @a = 1..^10; my @b = 5..7;  @a minmax @b

[22:36] <p6eval> nom 3670b7:  ( no output )

[22:36] <PerlJam> nom: my @a = 1..^10; my @b = 5..7;  say @a minmax @b

[22:36] <p6eval> nom 3670b7: OUTPUT¬´1..9‚ê§¬ª

[22:36] <Radvendii> that makes sense at least...

[22:37] <PerlJam> the spec says "...except that if the corresponding C<excludes> flag is set in Range, the excludes flag is also set in the returned C<Range>."

[22:37] <PerlJam> which means it should be 1..^10

[22:37] <colomon> nom: my @a = 1..^10; say @a.WHAT

[22:37] <p6eval> nom 3670b7: OUTPUT¬´Array()‚ê§¬ª

[22:37] <Radvendii> PerlJam: ah.

[22:37] <colomon> it's not a Range

[22:37] <PerlJam> oh.

[22:37] <PerlJam> There's a PerlJam bug then :)

[22:38] <colomon> nom: say (1..^10) minmax (5..7)

[22:38] <p6eval> nom 3670b7: OUTPUT¬´1..9‚ê§¬ª

[22:38] <colomon> that, on the other hand, looks more like a bug

[22:38] <Radvendii> :P

[22:38] <colomon> hmmm...

[22:38] <colomon> nom: (1..^10, 5..7).minmax.say

[22:38] <Radvendii> (1..^10).WHAT

[22:38] <p6eval> nom 3670b7: OUTPUT¬´1..9‚ê§¬ª

[22:38] <Radvendii> nom: say (1..^10).WHAT

[22:38] <PerlJam> yeah, there you go

[22:38] <p6eval> nom 3670b7: OUTPUT¬´Range()‚ê§¬ª

[22:39] <Radvendii> good catch

[22:39] <colomon> nom: my $a = 1..^10; my $b = 5..7; say ($a, $b).minmax

[22:39] <p6eval> nom 3670b7: OUTPUT¬´1..^10..5..7‚ê§¬ª

[22:39] <colomon> that's a bug for sure

[22:39] <PerlJam> heh!

[22:39] <PerlJam> indeed

[22:39] <Radvendii> haha

[22:39] <colomon> niecza: my $a = 1..^10; my $b = 5..7; say ($a, $b).minmax

[22:39] <p6eval> niecza v13-352-g6694950: OUTPUT¬´5..7..1..^10‚ê§¬ª

[22:39] <colomon> blast

[22:39] <Radvendii> ouch

[22:39] <colomon> well, spectests to be added, bugs to be fixed...

[22:40] <colomon> ng: my $a = 1..^10; my $b = 5..7; say ($a, $b).minmax

[22:40] <Radvendii> colomon: i still dont get why ^... wouldn't make sense

[22:40] <colomon> b: my $a = 1..^10; my $b = 5..7; say ($a, $b).minmax

[22:40] <p6eval> b 1b7dd1: OUTPUT¬´123456789‚ê§¬ª

[22:40] <Radvendii> std: my $a = 1..^10; my $b = 5..7; say ($a, $b).minmax

[22:40] <p6eval> std 47c76b3: OUTPUT¬´ok 00:01 113m‚ê§¬ª

[22:41] <Radvendii> i take it std is not a perl6 implementation...

[22:42] * colomon could have sworn he had minmax working properly at one point back in the days of b.  :(

[22:42] <PerlJam> Radvendii: not one that has a runtime, no.

[22:42] <Radvendii> PerlJam: understood

[22:42] <PerlJam> Radvendii: std is basically a perl 6 syntax checker

[22:42] <Radvendii> PerlJam: got it. and std is for standard?

[22:42] <PerlJam> aye

[22:44] <dalek> rakudo/nom: 12f3505 | jnthn++ | src/Perl6/Metamodel/MethodContainer.pm:

[22:44] <dalek> rakudo/nom: Parentheticize a remark in an error.

[22:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/12f35054f0

[22:44] <dalek> rakudo/nom: f9d635c | jnthn++ | src/Perl6/Actions.pm:

[22:44] <dalek> rakudo/nom: Catch undeclared attributes mentions in signatures.

[22:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9d635cc35

[22:44] <Radvendii> still, what's wrong with ^...?

[22:46] <colomon> Radvendii: because $a ^... $b would be exactly equivalent to $a+1 ... $b -- just less clear

[22:46] <Radvendii> nope

[22:46] <Radvendii> 5 ^... 1 would not be the same as 6 ... 1

[22:46] <PerlJam> colomon: would it?  $a would just be omitted wouldn't it?

[22:47] <PerlJam> 5 ^... 1 -->  4 3 2 1,  'a'^...'d' --> 'b', 'c', 'd'

[22:48] <jnthn> phenny: tell moritz Things that use $*W.throw(...) (e.g. sub foo($x! = 42) { }) gives an error in -e or when run in a file, but the error is never shown in the REPL - it seems to swallow them.

[22:48] <colomon> sure, if it's a decreasing sequence it's $a-1..$b

[22:48] <phenny> jnthn: I'll pass that on when moritz is around.

[22:49] <PerlJam> Radvendii: the problem for me is when it's like 1, 3, 5 ^... 13   Is tha the same as 3, 5, 7, 9, 11, 13 ?

[22:49] <Radvendii> yes, but the whole _point_ is that i dont know whether it's bigger or not

[22:49] <Radvendii> if i did, i would use ^..

[22:49] *** phenny left
[22:49] <benabik> Radvendii: Use minmax to sort out the size, _then_ use ^..

[22:49] <Radvendii> PerlJam: yes, why wouldn't it be?

[22:50] <Radvendii> benabik: i could, but that doesn't sound a little silly to you?

[22:50] <PerlJam> just seems weird is all

[22:50] <Radvendii> PerlJam: why? it's non-inclusive

[22:50] *** phenny joined
[22:51] <benabik> "Non-inclusive" and "series" don't go together in my head

[22:51] <benabik> Radvendii: Given the potential confusions with what you're excluding with ^minmax, it doesn't seem silly at all.

[22:51] <Radvendii> benabik: why not? how else would i do $a, $b ^... $c without knowing what $a and $b are?

[22:52] *** overrosy left
[22:52] <benabik> Non-inclusive series...  "I need a set of numbers defined by these numbers that excludes one of them"

[22:52] <Radvendii> i could do ($a, $b ... $c)[1..*-1]

[22:53] <Radvendii> rather ($a, $b ... $c)[1..*]

[22:53] *** benabik left
[22:53] <Radvendii> benabik: that's true, if you know what all of those numbers are.

[22:53] *** overrosy joined
[22:54] <PerlJam> nom: 

[22:54] <PerlJam> nom: 1,3,5 ...^ 13,16,27

[22:54] <colomon> In general, if you don't know what the numbers $a, $b. and $c are, then $a, $b ... $c will almost certainly be an infinite sequence

[22:54] <p6eval> nom 3670b7:  ( no output )

[22:54] <PerlJam> blah

[22:55] <PerlJam> nom: say 1,3,5 ...^ 13,16,27

[22:55] <p6eval> nom 3670b7: OUTPUT¬´1 3 5 7 9 11 16 27‚ê§¬ª

[22:55] <PerlJam> I can't concile that with the proposed ^...

[22:55] <colomon> Radvendii: I think this is when sorear++ would quite sensibly say, can you please tell us what you are actually trying to do, rather than the way you think it ought to be done?

[22:55] <Radvendii> colomon: uless you know they are all integers

[22:55] <PerlJam> Radvendii: eh?

[22:56] <Radvendii> that was at his previous point

[22:56] <colomon> Radvendii: not even then, unless you know that $c % ($b - $a) == 0

[22:56] <colomon> errr, ($c - $a) % ($b - $a) == 0, I mean

[22:57] <Radvendii> what i want to do is $a ... $b except not include $a or $b. without knowing which is bigger

[22:58] <PerlJam> Radvendii: you forgot "... in one operation"  because you can certainly do that in multiple steps :)

[22:59] <PerlJam> (that ... was just an ellipsis)

[22:59] <Radvendii> yes. but that seems like the kind of thing that should be doable, considering that ... doesn't care about order and ^..^ exists

[22:59] <Radvendii> doesn't it just seem like the task involves putting those two together?

[22:59] <colomon> and you're sure $a and $b are integers?

[23:00] <Radvendii> yes

[23:00] <Radvendii> they are coordinates

[23:00] <Radvendii> so yeah

[23:00] <Radvendii> (on a grid)

[23:00] <Radvendii> or, more appropriately, they are indicies

[23:01] <Radvendii> it's just as much of a problem to say @a[$b]

[23:01] <Radvendii> because $b might be 1.5

[23:01] <Radvendii> hm...

[23:01] <colomon> @a[1.5] is perfectly legal

[23:01] <Radvendii> nom: my @a = <a b c>; say @a[1.5]

[23:01] <p6eval> nom 3670b7: OUTPUT¬´b‚ê§¬ª

[23:01] <Radvendii> wth?

[23:01] <dalek> nqp/bs: 36df449 | jnthn++ | t/serialization/01-basic.t:

[23:01] <dalek> nqp/bs: Tests for P6num and P6str serialization.

[23:01] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/36df449d01

[23:01] <dalek> nqp/bs: fd071cc | jnthn++ | src/6model/reprs/P6 (2 files):

[23:01] <dalek> nqp/bs: Implement serialize and deserialize for P6num and P6str representations.

[23:01] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/fd071cc5dd

[23:01] <Radvendii> that's bizzare

[23:02] <Radvendii> it just truncates

[23:02] <Radvendii> but reguardless, yes. i knwo they are integers.

[23:02] <masak> that's not bizarre.

[23:02] <masak> that's Perl.

[23:02] <colomon> it floors, actually, I believe

[23:02] <masak> right.

[23:02] <PerlJam> That's just Perl since it was born

[23:02] <jnthn> .oO( That's totally floored! )

[23:02] <Radvendii> colomon: isn't floor and truncate the same?

[23:02] <masak> probably rounds towards 0 :)

[23:03] <masak> colomon: it's impossible to tell since negative numbers are no longer allowed.

[23:03] <colomon> Radvendii: not for negative numbers.

[23:03] <Radvendii> also, when would i ever want to access @a[1.5] and _not_ be confused

[23:03] <masak> good night, #perl6

[23:03] <colomon> can't you (at least hypothetically) create an array with negative indices?

[23:03] <Radvendii> o/

[23:03] <masak> colomon: yes, when S09 is implemented.

[23:04] * masak sleeps

[23:04] <Radvendii> nom: my @a; @a[-4]=3; say @a;

[23:04] <p6eval> nom f9d635: OUTPUT¬´Cannot assign to a non-container‚ê§  in block <anon> at /tmp/jBVoKsOCl7:1‚ê§  in <anon> at /tmp/jBVoKsOCl7:1‚ê§¬ª

[23:04] <colomon> Radvendii: @a[@a.elems / 2] where there are three elements in the array

[23:04] <PerlJam> Radvendii: have a look at https://gist.github.com/21bbf1da86d0e495408b   Are those the semantics you think should exist?

[23:05] <Radvendii> indeed

[23:05] *** slavik left
[23:07] <PerlJam> the asymmetry bothers me

[23:07] <Radvendii> yeah, i would also prefer it if the 19 were removed

[23:07] <Radvendii> but

[23:07] <Radvendii> i understand why that cannot be

[23:07] <PerlJam> I could make a case for 1,3,5 ^...^ 13,16,19   --> 1 3 7 9 11 16 19  

[23:07] <PerlJam> :-)

[23:08] <Radvendii> just think of it as (1,3,5 ^...^ 13),16,19

[23:08] <Radvendii> because that's what it is

[23:08] *** slavik joined
[23:11] <PerlJam> Radvendii: convince TimToady and you're done modulo the implementation  :)

[23:11] *** zamolxes left
[23:11] <Radvendii> modulo the implementation?

[23:11] <Radvendii> oh

[23:11] <Radvendii> got it

[23:12] <Radvendii> it can't be too hard... 1,3,5 ^... 13 is exactly the same as (1,3,5 ... 13)[1..*]

[23:12] <jnthn> ugh, tired...'night o/

[23:12] <Radvendii> jnthn: \o

[23:14] <Radvendii> o> <--- check out his muscles

[23:15] <Radvendii> PerlJam: am i wrong?                         ^^ up there?

[23:16] *** xinming left
[23:18] <Radvendii> nom: say (1,3,5 ... 13)[1..*

[23:18] <p6eval> nom f9d635: OUTPUT¬´===SORRY!===‚ê§Unable to parse postcircumfix:sym<[ ]>, couldn't find final ']' at line 2‚ê§¬ª

[23:18] <Radvendii> nom: say (1,3,5 ... 13)[1..*]

[23:18] <p6eval> nom f9d635: OUTPUT¬´3 5 7 9 11 13‚ê§¬ª

[23:18] *** xinming joined
[23:18] <Radvendii> nom: say (13...4)[1..*]

[23:18] <p6eval> nom f9d635: OUTPUT¬´12 11 10 9 8 7 6 5 4‚ê§¬ª

[23:18] <Radvendii> yup

[23:18] <Radvendii> nom: say (13...^4)[1..*]

[23:18] <p6eval> nom f9d635: OUTPUT¬´12 11 10 9 8 7 6 5‚ê§¬ª

[23:22] <Radvendii> nom: say (4...^4)[1..*]

[23:22] <p6eval> nom f9d635: OUTPUT¬´‚ê§¬ª

[23:23] <Radvendii> nom: say (4...^4)

[23:23] <p6eval> nom f9d635: OUTPUT¬´‚ê§¬ª

[23:23] <Radvendii> nom: say (4...4)

[23:23] <p6eval> nom f9d635: OUTPUT¬´4‚ê§¬ª

[23:23] <Radvendii> nom: say (4...4)[1..*]

[23:23] <p6eval> nom f9d635: OUTPUT¬´‚ê§¬ª

[23:24] <Radvendii> nom: say <a b c> ¬´,¬ª ()

[23:24] <p6eval> nom f9d635: OUTPUT¬´(timeout)¬ª

[23:25] <Radvendii> nom: say 'a' ~~ 0

[23:25] <p6eval> nom f9d635: OUTPUT¬´Bool::True‚ê§¬ª

[23:26] <Radvendii> so why does it convert the 'a' into a number and not the 0 into a string?

[23:28] <Timbus> 0.ACCEPTS('a') makes sense to me

[23:31] <Radvendii> oh. is that what ~~ calls?

[23:32] <Timbus> yeah.

[23:32] <Radvendii> so what about 'a' ~~ /0/. does that do /0/.ACCEPTS('a') ?

[23:32] <Radvendii> or is that something else...

[23:33] <Timbus> i think that's what it does, but there's been a few issues regarding that

[23:33] <Radvendii> oh

[23:33] <Timbus> nom: say /0/.ACCEPTS('a')

[23:33] <p6eval> nom f9d635: OUTPUT¬´#<failed match>‚ê§¬ª

[23:33] <Radvendii> apparently

[23:34] <Timbus> nom: say /\w/.ACCEPTS('a')

[23:34] <p6eval> nom f9d635: OUTPUT¬´=> <a>‚ê§‚ê§¬ª

[23:34] <Timbus> so yeah thats how it works

[23:34] <Radvendii> o-oh

[23:35] <Radvendii> so it's easy to overload ~~

[23:35] <Timbus> yes

[23:35] <Radvendii> clever

[23:35] <Radvendii> :P

[23:35] <Timbus> the problem with ~~ and matches is that $_ is overridden during the match, but sometimes people use magical values in their matches and submatches

[23:36] <Radvendii> magical values?

[23:36] <Timbus> theres also the issue of how ~~ and substitution matches should work (i think they should not work at all)

[23:36] <Radvendii> i think it should return the string after substitution

[23:36] <Timbus> yes, like previous match values and the like

[23:37] <Radvendii> ah

[23:37] <Timbus> anything tied to $_ i guess..

[23:37] <Timbus> moritz wrote a blog entry about it but I can't find it

[23:38] <Radvendii> but yeah, i hardly ever want to modify the string itself. and if i did i could use ~~=

[23:38] <Radvendii> yeah, i experienced recently when i wanted to do .grep: {$i !~~ $_} or something like that

[23:41] <Radvendii> nom: say (one(<a b c>) ~~ /a/)

[23:41] <p6eval> nom f9d635: OUTPUT¬´This type cannot unbox to a native string‚ê§  in <anon> at src/gen/Metamodel.pm:2686‚ê§  in !cursor_init at src/stage2/QRegex.nqp:878‚ê§  in method ACCEPTS at src/gen/CORE.setting:7559‚ê§  in block <anon> at /tmp/Z4I_FuY25p:1‚ê§  in <anon> at /tmp/Z4I_FuY25p:1‚ê§¬ª

[23:41] <Radvendii> nom: say ((one(<a b c>) ~~ /a/).perl)

[23:41] <p6eval> nom f9d635: OUTPUT¬´This type cannot unbox to a native string‚ê§  in <anon> at src/gen/Metamodel.pm:2686‚ê§  in !cursor_init at src/stage2/QRegex.nqp:878‚ê§  in method ACCEPTS at src/gen/CORE.setting:7559‚ê§  in block <anon> at /tmp/aSMmL4cfBj:1‚ê§  in <anon> at /tmp/aSMmL4cfBj:1‚ê§¬ª

[23:42] <Radvendii> nom: say ?(one(<a b c>) ~~ /a/)

[23:42] <p6eval> nom f9d635: OUTPUT¬´This type cannot unbox to a native string‚ê§  in <anon> at src/gen/Metamodel.pm:2686‚ê§  in !cursor_init at src/stage2/QRegex.nqp:878‚ê§  in method ACCEPTS at src/gen/CORE.setting:7559‚ê§  in block <anon> at /tmp/4XUoXuhjMY:1‚ê§  in <anon> at /tmp/4XUoXuhjMY:1‚ê§¬ª

[23:42] <Radvendii> nom: say ?(one(<a b c>) eq 'a')

[23:42] <p6eval> nom f9d635: OUTPUT¬´Bool::True‚ê§¬ª

[23:42] <Radvendii> nom: say (one(<a b c>) eq 'a')

[23:42] <p6eval> nom f9d635: OUTPUT¬´one(Bool::True, Bool::False, Bool::False)‚ê§¬ª

[23:43] <Radvendii> is there any way to find out which of them was the 'one'?

[23:45] <Radvendii> nom: say (a ^^ 0)

[23:45] <p6eval> nom f9d635: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Undefined routine '&a' called (line 1)‚ê§¬ª

[23:45] <Radvendii> nom: say ('a' ^^ 0)

[23:45] <p6eval> nom f9d635: OUTPUT¬´a‚ê§¬ª

[23:46] *** molaf left
[23:46] *** bbkr1 left
[23:46] *** colomon left
[23:47] <Radvendii> nom: 4 ...^ 4

[23:47] <p6eval> nom f9d635:  ( no output )

[23:47] <Radvendii> nom: say 4 ...^ 4

[23:47] <p6eval> nom f9d635: OUTPUT¬´‚ê§¬ª

[23:47] <Radvendii> nom: say qx[pwd]

[23:47] <p6eval> nom f9d635: OUTPUT¬´qx, qqx is disallowed in safe mode‚ê§  in sub restricted at src/SAFE.setting:2‚ê§  in sub QX at src/SAFE.setting:9‚ê§  in block <anon> at /tmp/wiLcIEXBe3:1‚ê§  in <anon> at /tmp/wiLcIEXBe3:1‚ê§¬ª

[23:48] <Radvendii> figured :P

[23:49] <Radvendii> nom: say one(5,0)

[23:49] <p6eval> nom f9d635: OUTPUT¬´one(5, 0)‚ê§¬ª

[23:49] <Radvendii> nom: say +one(5,0)

[23:49] <p6eval> nom f9d635: OUTPUT¬´one(5, 0)‚ê§¬ª

[23:49] <Radvendii> nom: say ?one(5,0)

[23:49] <p6eval> nom f9d635: OUTPUT¬´Bool::True‚ê§¬ª

[23:49] <Radvendii> nom: say =one(5,0)

[23:49] <p6eval> nom f9d635: OUTPUT¬´===SORRY!===‚ê§Preceding context expects a term, but found infix = instead at line 1, near "one(5,0)"‚ê§¬ª

[23:49] <Radvendii> nom: say -one(5,0)

[23:49] <p6eval> nom f9d635: OUTPUT¬´one(-5, 0)‚ê§¬ª

[23:49] <Radvendii> nom: say -(1,2,3)

[23:50] <p6eval> nom f9d635: OUTPUT¬´-3‚ê§¬ª

[23:50] <Radvendii> nom: say -¬´ (1,2,3)

[23:50] <p6eval> nom f9d635: OUTPUT¬´-1 -2 -3‚ê§¬ª

[23:53] <Radvendii> Woah!

[23:53] *** bbkr1 joined
[23:53] <Radvendii> nom: say ?(one(0,0) !== 0)

[23:53] <p6eval> nom f9d635: OUTPUT¬´Bool::True‚ê§¬ª

[23:53] *** baest_ joined
[23:53] <Radvendii> uh

[23:53] <Radvendii> what??

[23:53] <Radvendii> nom: say ?(one(0,0) != 0)

[23:53] <p6eval> nom f9d635: OUTPUT¬´Bool::False‚ê§¬ª

[23:53] <Radvendii> so somehow !== is different from !=

[23:54] <Radvendii> and != is more correct

[23:55] *** baest left
[23:56] *** molaf joined
[23:57] <Radvendii> o-oh

[23:57] <Radvendii> is it that $a !== $b is the same as !($a == $b)

[23:57] <Radvendii> i think that's it

[23:57] <Radvendii> i dont know if that's good in this case...

