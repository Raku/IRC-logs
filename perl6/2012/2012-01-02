[00:00] *** raiph joined
[00:01] *** PZt left
[00:01] *** snearch left
[00:01] *** drbean joined
[00:07] *** icwiener joined
[00:12] *** drbean left
[00:13] <ggoebel> \o

[00:13] <ggoebel> Happy New Year's

[00:16] *** packetknife joined
[00:17] *** drbean joined
[00:22] <ggoebel> sorear: regarding niecza and publicity... never underestimate the seemingly little things. A simple yet clever visually appealing logo. A pithy quotable value statement, website, etc.

[00:22] *** icwiener left
[00:23] <ggoebel> a simple memorable searchable name

[00:23] *** icwiener joined
[00:23] <ggoebel> my greatest fear for niecza is you getting hit by a bus or losing interest

[00:23] <tadzik> I don't see how niecza is not simple or memorable :)

[00:23] <tadzik> but again, I'm Polish and I have no problem with Brzęczyszczykiewicz either :)

[00:24] <ggoebel> that might be it... I always hear Nietsche when I type it... and usually flip the vowels and consonants

[00:27] <tadzik> it's almost like Nietsche, but the 'e' is audible, like the 'e' in Perl

[00:49] <cognominal> nom: my %h;  say "Brzęczyszczykiewicz".split('').map: { %h{$_}++ }; say %h

[00:49] <p6eval> nom a7fd89: OUTPUT«0 0 0 0 0 1 0 0 2 1 3 1 0 0 0 0 1 2 4␤("B" => 1, "r" => 1, "z" => 5, "ę" => 1, "c" => 3, "y" => 2, "s" => 1, "k" => 1, "i" => 2, "e" => 1, "w" => 1).hash␤»

[00:49] <cognominal> nom: my %h;  "Brzęczyszczykiewicz".split('').map: { %h{$_}++ }; say %h

[00:49] <p6eval> nom a7fd89: OUTPUT«().hash␤»

[00:49] <cognominal> seems that some active code is optimized out :(

[00:50] <cognominal> or I need sleep

[00:50] * Timbus peers in

[00:50] * Timbus slaps cognominal's hand for doing that

[00:51] <cognominal> ??

[00:51] <Timbus> nom: my %h; %h{$_}++ for "Brzęczyszczykiewicz".split(''); say %h

[00:51] <p6eval> nom a7fd89: OUTPUT«("B" => 1, "r" => 1, "z" => 5, "ę" => 1, "c" => 3, "y" => 2, "s" => 1, "k" => 1, "i" => 2, "e" => 1, "w" => 1).hash␤»

[00:52] <cognominal> I want to use map for the mere side effects.

[00:53] <cognominal> at least to get a warming.

[00:53] <Timbus> maybe a /for method on lists is not as crazy as i thought

[00:53] <Timbus> .for

[00:54] <tadzik> split('') => comb

[00:56] *** PZt joined
[00:56] <cognominal> "Civilization advances by extending the number of important operations which we can perform without thinking of them". But programmers, when using a new language, advance by rethinking how to write important operations instead of using muscle memory.

[00:57] <sorear> some people think that all list generating functions should be eager when the result is ignored

[00:57] <sorear> I do not like this at all

[00:58] <raiph> sorear: what are your reasons for wanting niecza publicity?

[00:59] <cognominal> what would be the equivalent code in haskell?

[01:00] <sorear> maybe use mapM_

[01:00] <sorear> raiph: a lot of people outside the echo chamber think perl6 means parrot

[01:01] <cognominal> I want Perl6 on V8 :)

[01:01] <sorear> ehehehe... I doubt that will work well

[01:02] <raiph> sorear: outside the echo chamber they think perl6 is a blue norwegian ;) 

[01:02] <sorear> Perl6 can't be efficiently simulated on foreign VMs

[01:04] <cognominal> sorear: but that would mean Perl 6 on chrome (polychrome?) and world domination

[01:05] <ggoebel> sorear: if the motivation behind niecza is "make it fast"... in layman's terms what are the hurdles which need to be overcome in the short, mid, and long terms?

[01:10] <dalek> roast: cb88c13 | (Solomon Foster)++ | S02-types/anon_block.t:

[01:10] <dalek> roast: Fudge for niecza.

[01:10] <dalek> roast: review: https://github.com/perl6/roast/commit/cb88c1385c

[01:11] <Timbus> how much effort would it take to lift nqp from parrot and put it in llvm

[01:11] <dalek> niecza: 260335a | (Solomon Foster)++ | t/spectest.data:

[01:11] <dalek> niecza: Turn on S02-types/anon_block.t.

[01:11] <dalek> niecza: review: https://github.com/sorear/niecza/commit/260335aa5b

[01:11] <Timbus> gc and utility libraries aside

[01:12] <Timbus> i mean just getting it to compile itself into llvm for now

[01:13] <Timbus> you can always plug in a hans boehm i guess..

[01:14] <cognominal> Timbus:  indeed I think  .map  as a degenerated  form of the  .grep.map idiom I use a lot.  I use them both for side effecta. The former being your .for method.

[01:14] <Timbus> im not even a functional programmer, but side effects like that dont sit right for me

[01:16] *** drbean left
[01:16] <cognominal> bad habits are hard to die

[01:17] <cognominal> that's the perl 4 programmer in me\

[01:17] <Timbus> fortunately i missed that stage

[01:20] <colomon> ah, perl 4!

[01:22] *** drbean joined
[01:23] <colomon> niecza: say Order::Increase

[01:23] <p6eval> niecza v13-43-gd7bbde0: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/0WFpfPLDi4 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2613 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2614 (module-CORE @ 61…

[01:24] <cognominal> my first immortalized perl post date from 1991   https://groups.google.com/forum/?hl=fr#!searchin/soc.culture.french/payrard$20perl/soc.culture.french/v25ELImC4_4/HV7fT_e8iOIJ

[01:24] <cognominal> *dates

[01:24] <colomon> woah, I didn't learn perl until late 1994

[01:26] <cognominal> I note I did not know all the magic switches to gobble stdin.

[01:27] <colomon> I still don't.  ;)

[01:28] *** raiph left
[01:29] <tadzik> you mean the -plne stuff?

[01:29] <cognominal> I have lost the mails dating from the time where I was [email@hidden.address]   [email@hidden.address] was quite a mouthful.

[01:30] <cognominal> tadzik: yup

[01:30] <tadzik> heh, I ususally put them there at random until it starts to work

[01:35] *** bluescreen10 left
[01:39] <[Coke]>  cognominal: you at Oracle now?

[01:43] <cognominal> nope, I have quitted Sun a long time ago...

[01:47] * geekosaur wonders when mono-sgen will be fixed in macports (long delay then bus error; mono itself works)

[01:51] *** cspencer left
[01:53] *** cspencer joined
[01:56] <dalek> roast: 9ee6b08 | (Solomon Foster)++ | S12-class/attributes.t:

[01:56] <dalek> roast: Fudge for niecza.  Please note that IMO the last set of tests is at best misguided...

[01:56] <dalek> roast: review: https://github.com/perl6/roast/commit/9ee6b08a0b

[01:57] <dalek> niecza: cc39754 | (Solomon Foster)++ | t/spectest.data:

[01:57] <dalek> niecza: Turn on S12-class/attributes.t.

[01:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/cc3975499c

[02:03] <sorear> Timbus: look at the "6model" repo... nqp already has ports to luajit, java, and c#

[02:04] <Timbus> yeah but th- wait luajit

[02:04] *** Chillance left
[02:04] <Timbus> .. yeah but they're not quite as low level as llvm

[02:04] * sorear is younger than Perl itself

[02:05] *** Chillance joined
[02:05] <Timbus> also do these ports compile and run rakudo?

[02:06] <tadzik> I've not heard of any attempts

[02:07] <[Coke]> t/spec/S16-filehandles/filetest.t has failures in niecza.

[02:08] <[Coke]> I just added that file to spectest.data on 12/24

[02:08] <colomon> [Coke]: works locally for me.

[02:08] <sorear> Timbus: no.

[02:09] <Timbus> wouldn't have thought so

[02:11] <colomon> [Coke]: do you have the very latest niecza?

[02:24] <TimToady> perl6: say +(1 .. '10')

[02:24] <p6eval> niecza v13-43-gd7bbde0: OUTPUT«0␤»

[02:24] <p6eval> ..pugs b927740, rakudo a7fd89: OUTPUT«10␤»

[02:27] <geekosaur> *blink*

[02:29] <Timbus> i.. okay

[02:30] <colomon> TimToady: was there ever an official ruling on what to do with that case?

[02:32] <TimToady> S04:3414 covers that

[02:32] <TimToady> (in the context of numeric arg on the left)

[02:33] <colomon> S03:3414, you mean

[02:33] <TimToady> er, yeah, sorry

[02:34] <colomon> no worries, TimToady++

[02:35] <colomon> Is the effect intended to be, if the left-hand-side is Numeric and the right-hand-side is not, you cast the right-hand-side to Numeric?

[02:35] <TimToady> yes

[02:35] <colomon> so 0 .. '1.5' is 0 .. 1.5 and not 0 .. 1

[02:36] <TimToady> it should be like prefix:<+>

[02:36] <colomon> I ask because the text says "the right argument is coerced to the type of the left argument"

[02:36] <TimToady> hmm

[02:37] <TimToady> that's probably a specbug

[02:38] <colomon> so should it be something like:

[02:38] <colomon> 1) both numeric, take as is

[02:38] <colomon> 2) first numeric, prefix:<+> the second

[02:38] <colomon> 3) cast the right argument to the type of the left argument

[02:39] <colomon> (that's a sequence of whens, not a list of instructions.  :)

[02:40] <dalek> specs: 8fcd8d6 | larry++ | S03-operators.pod:

[02:40] <dalek> specs: spec 0 .. '1.5' better, colomon++

[02:40] <dalek> specs: review: https://github.com/perl6/specs/commit/8fcd8d6b6b

[02:41] <colomon> TimToady++

[02:41] <TimToady> 3 is not correct, it's "cast narrower to wider"

[02:41] <TimToady> cover by "as above" in the spec

[02:42] <colomon> gotcha

[02:43] * colomon is now hacking niecza

[02:49] <colomon> er, colomon is now helping his wife unload an ungodly quantity of groceries

[02:50] *** tokuhirom joined
[02:51] *** cspencer left
[02:57] *** icwiener_ joined
[02:59] <colomon> ..... not that I need a definition today, but how do you define "wider"?

[03:01] *** icwiener left
[03:02] <colomon> for instance, assume you've got a Rat and a Num.  Which is wider?

[03:02] <colomon> niecza> say +(1 .. '10')

[03:02] <colomon> 10

[03:04] <sorear> num is "wider"

[03:04] *** drbean left
[03:04] <sorear> (1/2) + 1.5e0 ~~ Num

[03:05] <colomon> ........... !

[03:05] <colomon> \

[03:05] <colomon> guess that makes a sort of sense

[03:05] <colomon> afk moment'

[03:08] <colomon> back

[03:10] *** drbean joined
[03:13] *** am0c left
[03:14] *** lutok left
[03:24] <dalek> niecza: ab2db52 | sorear++ | lib/ (2 files):

[03:24] <dalek> niecza: Implement prefix:<sleep>

[03:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ab2db52a66

[03:36] <Timbus> http://i.imgur.com/SlD8L.png

[03:36] <Timbus> :I thanks visual studio

[03:37] *** Patterner left
[03:38] *** c-lesh joined
[03:38] <c-lesh> hello

[03:38] *** Psyche^ joined
[03:38] *** Psyche^ is now known as Patterner

[03:38] <colomon> c-lesh: o/

[03:38] <c-lesh> I was wondering if there is a way to compile Java into Parrot bytecode.

[03:39] <Timbus> yes: by hand

[03:39] <Timbus> :D

[03:39] <c-lesh> No, I mean is there a translator for Parrot?

[03:40] <Timbus> none I am aware of, 

[03:41] <c-lesh> Is it true that Parrot can translate some of its bytecode into native code? If so then would Perl 6 be good for writing games?

[03:42] <Timbus> you'd be better off using niecza imo

[03:42] <c-lesh> niecza compiles into native code? or Parrot bytecode?

[03:43] <Timbus> to clr code

[03:43] <Timbus> it's for mono/.net

[03:43] <Timbus> which has a jit

[03:43] <c-lesh> ah, so clr does translate some of its code to native

[03:44] <c-lesh> or all of it?

[03:44] <Timbus> most of it

[03:44] <c-lesh> wow!

[03:44] <Timbus> but the other advantage is you can use .net libraries

[03:44] <c-lesh> that's nice

[03:45] <Timbus> whereas rakudo needs a bit of work in that area

[03:45] <c-lesh> my understanding is that Parrot does not yet compile its bytecode to native, right?

[03:45] <Timbus> correct, it used to have a jit

[03:45] <Timbus> but it was removed

[03:45] <c-lesh> why?

[03:45] <Timbus> maintenance nightmare

[03:46] <c-lesh> oh, I see

[03:46] <c-lesh> I'm just wondering how one would translate bytecode to native, say in c

[03:46] <Timbus> it makes more sense for parrot to target something else that jit's better (llvm was the idea for a while)

[03:46] <Timbus> well, you know what a jit is?

[03:47] <c-lesh> yes

[03:47] <Timbus> well.. that's how :P

[03:47] <c-lesh> I'm not sure how to translate bytecode to native at runtime

[03:47] <c-lesh> there is an __emit__ macro in C?

[03:48] <c-lesh> jits are written in C, right?

[03:49] <Timbus> they can be written in anything, really

[03:49] <c-lesh> I'll have to look at some source code.

[03:49] <Timbus> the difference between bytecode and native code is.. well, one is native bytecode

[03:49] <c-lesh> I'm writing an interpreter myself. It compiles to bytecode but I would like to compile this to native.

[03:49] <Timbus> oh i see

[03:50] <Timbus> well, let me warn you ahead of time that it's a lot of effort

[03:50] <Timbus> please consider an existing jit library. llvm, GNU lightning

[03:51] <c-lesh> Thanks, I'll check that out!

[03:53] <c-lesh> Did Parrot use any of the jit libraries you mentioned or did it implement its own?

[03:54] <Timbus> it was it's own

[03:54] <Timbus> .. its

[03:55] <c-lesh> So is there a chance that the Parrot community will use some of these libraries?

[03:55] <Timbus> eventually, yes i would hope so.

[03:56] <Timbus> it really depends on what happens to parrot.

[03:56] *** icwiener_ left
[03:57] *** icwiener_ joined
[03:57] <c-lesh> What is Larry Wall doing these days? Does he still work on Perl?

[03:58] <colomon> On Perl 6, sure.

[03:58] <c-lesh> That's cool!

[03:58] <colomon> He was on here about 70 minutes ago

[03:58] <c-lesh> Wow! Too bad I missed him!

[03:59] <c-lesh> Ok, so I'm curious about the history of Perl. Does Perl 1.0 have a garbage collector?

[03:59] <geekosaur> actually still here now, just being quiet and unobvious

[04:00] <geekosaur> as is his wont

[04:01] * geekosaur unfamiliar with perl < 3.0 but believes there's a reasonable history in the perl5 pods

[04:01] *** kaleem joined
[04:03] *** hundskatt left
[04:07] <Timbus> huh c-lesh http://www.gnu.org/software/dotgnu/libjit-doc/libjit.html check out this here. I hadn't seen it before but the tutorials are a helpful start

[04:15] <Timbus> http://blog.fallingsnow.net/2008/05/23/simple-vm-jit-with-llvm/ and this. took me a while to dig that one up :/

[04:15] <c-lesh> Thanks!

[04:17] <sorear> c-lesh: "unmaintainable" was only half of the storyy

[04:17] <c-lesh> What was the other problem?

[04:17] <sorear> c-lesh: it generated terrible code

[04:18] <c-lesh> Not efficient and fast?

[04:18] <sorear> it's extremely easy to write a naive native code compiler

[04:18] *** kaleem left
[04:18] <sorear> but naive native code is actually not much faster than bytecode

[04:18] <sorear> and is MUCH larger

[04:18] <c-lesh> Really!!!?

[04:19] <c-lesh> How can that be?

[04:19] <sorear> trade a lot of ram for a small amount of speed... not much win

[04:19] <sorear> c-lesh: performance of native code is ... complicated

[04:19] <sorear> c-lesh: say you have one bytecode instruction, which gets turned into 10 machine instructions by your naive compiler

[04:20] <c-lesh> So, for example, I write a game in, say, Python (I imagine this language is bytecode interpreted.) It would probably run fast.

[04:20] <sorear> a good C compiler could turn the switch-clause into 15 instructions, but because of better scheduling that runs faster

[04:20] <Timbus> jits come into their own when they unbox and such. the actual loop construct of an interpreter isn't much overhead no

[04:21] <c-lesh> I see.

[04:21] <c-lesh> So why are jits even used?

[04:21] <sorear> c-lesh: there is no "fast", only "fast enough"

[04:21] <sorear> c-lesh: because a jit starts to win once you have about 10 man-years into it

[04:21] <Timbus> well jits do add speed

[04:22] <Timbus> compare javascript performance to 4 years ago

[04:22] <sorear> c-lesh: you're oversimplifying, I feel

[04:22] <c-lesh> So a game written in python that takes advantage of graphics hardware acceleration can be faster than a game written in C that does not take advantage of graphics hardware acceleration.

[04:22] <Timbus> c-lesh, easily

[04:22] <sorear> c-lesh: I want you to stop thinking about "this will be fast"

[04:22] <c-lesh> I have seen a lot of javascript games!

[04:23] <c-lesh> Wow! This really cleared things up! Thanks!

[04:24] <sorear> c-lesh: unless you're trying to make the next DF, calculation speed is not normally a big issue for games

[04:24] <c-lesh> I understand branch prediction is good these days as an interpreter would have to compare its op codes.

[04:25] <c-lesh> especially for 2D games like Mario

[04:25] <sorear> even for 3D games

[04:25] <c-lesh> These are the games I'm writing for my interpreter

[04:25] <c-lesh> 3D games?

[04:25] <c-lesh> Are 3D games possible in python?

[04:26] <sorear> do you understand Amdahl's Law?

[04:26] <c-lesh> not really

[04:26] <sorear> if a program spends 90% of its time in module A and 10% of its time in module B, no amount of optimizing module B can ever give you more than a 10% speedup

[04:26] <sorear> this is Amdahl's Law

[04:27] <c-lesh> ah

[04:27] <sorear> I consider it common sense, but that's probably just because I've used it for so long

[04:27] <c-lesh> I'm new to the world of virtual machines, so to speak.

[04:27] <c-lesh> Actually, I'm writing one to make games.

[04:27] <sorear> so if you're writing a "typical" 3D game, 90% of the work is being done by the GPU, inside OpenGL

[04:28] <sorear> so optimizing your code won't help much

[04:28] <sorear> you can only make it faster by reducing the number of glXYZ calls

[04:28] <c-lesh> So taking advantage of hardware acceleration is key - not code optimization.

[04:28] <sorear> (why are you writing a VM?)

[04:29] <c-lesh> I'm writing it for fun and because I want to learn about them.

[04:29] <sorear> c-lesh: yes, but I have to stress that every case is different

[04:29] <sorear> when you have a good understanding of what's expensive and what's cheap, you'll naturally write faster code

[04:29] <sorear> experience matters, a lot

[04:30] <c-lesh> My VM takes advantage of hardware acceleration and I have gotten my first game to run quite fast on my netbook.

[04:30] <c-lesh> I have been writing code since 1998.

[04:30] <c-lesh> C++, Java, C, Perl, Python, Java, etc.

[04:30] <sorear> I'm sure you can access OpenGL from Python

[04:30] <c-lesh> Sure.

[04:31] <Timbus> panda3d and pygame come to mind

[04:31] <c-lesh> I have used pygame before.

[04:31] *** icwiener_ left
[04:32] <sorear> probably longer than me.

[04:32] <c-lesh> Python uses what kind of garbage collection? stop-the-world, etc.

[04:32] <sorear> python uses "fake" kind of garbage collection

[04:32] *** icwiener_ joined
[04:32] <c-lesh> I started using python on 2008 but didn't like the indentation stuff.

[04:32] <c-lesh> fake?

[04:32] <sorear> reference counting

[04:33] <sorear> fastish, but wastes memory and leaks like a sieve if you mess up cycle handling

[04:33] <c-lesh> So that means that memory is only marked as available?

[04:33] <sorear> perl 5 does the same thing

[04:33] <c-lesh> Parrot?

[04:33] <sorear> Parrot has a real GC

[04:33] <Timbus> parrot uses a generational gc

[04:34] <c-lesh> does this run whenever, like for example in a game loop?

[04:34] <Timbus> yep

[04:34] <c-lesh> is there a System.gc() like in Java?

[04:35] <Timbus> couldn't answer that since I havent used parrot in awhile, but probably

[04:35] <sorear> I would like to gently dissuade you from basing anything mission-critical on Parrot

[04:35] <c-lesh> My VM has no garbage collection and the programmer accesses the memory directly like in assembly.

[04:35] <kshannon> Yes.

[04:35] <c-lesh> sorry

[04:35] <sorear> e.g. last time I tried this, a simple sub call is 2 µs on Parrot and <50ns on Mono

[04:35] <sorear> s/mission/performance/

[04:35] <Timbus> mono is pretty boss.

[04:36] <Timbus> still mad android didnt use it

[04:36] <c-lesh> It's like of like a cross between assembly and C. I think it's cool.

[04:36] <sorear> what do you think of c--?

[04:36] <c-lesh> I write stuff for Android.

[04:36] <c-lesh> c--?

[04:37] <Timbus> http://www.cminusminus.org/

[04:37] <sorear>  it's like a cross between assembly and C.  I think it's cool.

[04:38] <sorear> although it's lost a lot of mindshare to LLVM IR

[04:38] <Timbus> i just liked the name

[04:39] <c-lesh> c-- looks cool but my VM is not assembly like. It has no registers and uses DMA (direct memory access). It encodes all expressions and structures in bytes and executes these.

[04:39] <sorear> I do not think DMA means what you think it means

[04:39] <c-lesh> what does it mean then?

[04:40] <sorear> DMA refers to a situation where hardware *other than the CPU* can access memory

[04:40] <sorear> like say you have a network card that writes packets directly into RAM

[04:40] <geekosaur> dma means devices can access memory directly insted of having the cpu poll and copy data

[04:40] <c-lesh> I see. Like what the SNES does.

[04:41] <c-lesh> Does that mean that one does not have to transfer from memory to register to memory again?

[04:41] <Timbus> in a roundabout way. yes?

[04:42] <sorear> yes, but you'd be stupid not to

[04:42] <c-lesh> why?

[04:42] <sorear> because transfer from memory to register to memory again is a million times faster than using DMA

[04:42] <c-lesh> ?

[04:42] <sorear> and I might not be exagerating, it's at least tens of thousands of times faster

[04:42] *** kaleem joined
[04:43] <c-lesh> but the snes uses it because according to the manual it is faster to block data transfers

[04:43] <sorear> that was 20 years ago

[04:43] <Timbus> but my pc.. it is not a snes

[04:43] <Timbus> that would be awesome

[04:44] <c-lesh> so dma is outdated

[04:44] <sorear> *MEGA HEAD DESK*

[04:44] <c-lesh> i have looked at snes assembly code and architecture

[04:44] <sorear> I give up.  geekosaur, you're up

[04:44] * geekosaur not sure he can do any better

[04:44] <c-lesh> these people hack Super Mario World all the time: http://www.smwcentral.net

[04:45] *** kaleem left
[04:46] <geekosaur> it depends on the system and bus design, plus even relatively slow DMA can be a net win if the system has enough other stuff to do while the DMA is occurring

[04:46] <c-lesh> So in a typical VM why are registers even used for register based VMs. For an addition why not just use arbitrary memory locations? 1 instruction with 3 params is better than 2 instructions, right?

[04:47] <c-lesh> I guess snes used this sinces its hardware was memory mapped instead of port mapped.

[04:47] <geekosaur> instruction decoding takes longer, memory fetch cycles may slow things down

[04:48] <geekosaur> in  modern system, performance isn't so much a function of individual design choices as the performance of the entire system on the intended load

[04:48] <c-lesh> i see

[04:49] <geekosaur> and individually "slower" designs may net a faster overall system if they are used appropriately

[04:49] <Timbus> the closer you get to the wire, the less sense it makes too. -_-

[04:49] <c-lesh> interesting

[04:50] <Timbus> simple jz loops often outperform repne even though it is a "single" instruction. why? pppfft

[04:50] <Timbus> idk

[04:50] <c-lesh> pppft?

[04:50] <Timbus> thats my answer

[04:51] <geekosaur> I think that's just onomatopoeia

[04:51] <c-lesh> i'm not familiar with the instruction repne

[04:51] <Timbus> repeat until not equal(?) its been so long

[04:51] <geekosaur> it's complex.  early on, certainly, jz loops often outperformed rep loops; now its more dpeendent on what you're doing

[04:52] <c-lesh> I'm learning quite a bit. Thanks!

[04:52] <geekosaur> x86 architecture has a number of "repeat" opcodes that act like automatic loops

[04:52] <c-lesh> This would be the CISC architecture.

[04:52] <c-lesh> RISC is better.

[04:52] <geekosaur> but, as they're designed to be general, they can be higher overhead than a well thought out explicit loop

[04:53] <c-lesh> So VM try to mirror the RISC architecture.

[04:53] <sorear> "RISC is better" ... this statement is so so very wrong

[04:53] <c-lesh> ?

[04:54] <sorear> it's complicated, like everything else

[04:54] <geekosaur> and, for example, a rep loop was almost always slower than the corresponding explicit loop on 8086/8088 and 80186; they got better in 80286 and again in 80386

[04:54] <c-lesh> interesting

[04:54] <geekosaur> indeed.  RISC is better if you code carefully to the strengths of the architecture, and hilariously bad if you code naively

[04:54] <sorear> RISC *was* better when it first came out.  but the supposed advantages of RISC don't stand up to processor evolution

[04:55] <geekosaur> also required more complex code generators

[04:55] <sorear> the original MIPS design was extremely efficient, but it exposed a lot of the internal structure of the original MIPS processor in the ISA

[04:55] <geekosaur> but CISC architectures evolved faster than code generators did, for the most part

[04:55] <sorear> once you start making small changes to the chip, like adding a pipeline stage, the code generation has to completely change

[04:56] <geekosaur> yep

[04:56] <sorear> a modern processor needs a recoding unit to isolate the user from changes in the processor

[04:56] <c-lesh> that's were cisc comes in, right?

[04:57] <sorear> right

[04:57] <geekosaur> there is less of a difference in that case, but the real problem is the red queen's race between RISC architecture changes and code generators

[04:57] <c-lesh> so modern processors like dual cores uses cisc

[04:57] * Timbus looks at dual core phone

[04:57] <Timbus> i.. hmm..

[04:57] <c-lesh> VMs also tend to emulate cisc, right?

[04:58] <sorear> c-lesh: VMs do whatever they want

[04:58] <sorear> CPU design is fundamentally different from fast VM design

[04:58] <geekosaur> and having to make sure you pick the right code generator for your current arch, or having to pick a general one that runs ok everywhere instead of very well natively and horribly if you copy the binary to an ostensibly similar system with a different cpu stepping

[04:58] <c-lesh> true, my VM doesn't even have registers or simple instructions

[04:58] <sorear> because transistors are *always on* while in a VM, *one instruction* is run at a time

[04:59] <c-lesh> some instruction is my VM can be up to 30 bytes!

[04:59] <sorear> think about this: your processor has, say, 10^8 transistors clocked 10^9 times per second.  Think about how many logical operations happen per second, and how much useful computation occurs.

[04:59] <c-lesh> they include expressions as their parameters

[05:00] <sorear> CPUs do a *lot* of redundant computation in order to minimize *logical depth*

[05:00] <c-lesh> i see

[05:00] <sorear> also, dual core systems have been around since forever.  "Modern cpus like dual cores" is ... not really meaningful

[05:00] <c-lesh> since when?

[05:01] <sorear> I don't know.  I have a copy of the Motorola 68020 system programmer's manual in my room and it talks about concurrent processing using CAS

[05:01] <c-lesh> P4 was not dual core

[05:02] *** cooper left
[05:02] <sorear> so at least 1984

[05:02] <sorear> but I'm sure this goes back much further, perhaps to the 60s

[05:02] <c-lesh> 1984? That long? I though they came out in the early 2000s.

[05:03] <geekosaur> if you only care about particular x86 implementations, sure

[05:03] *** cooper joined
[05:03] <geekosaur> dual cores on the same chunk of silicon is recent

[05:04] <sorear> it wasn't that long ago when a single core had to be split across many chunks of silicon

[05:04] <c-lesh> i see there were coprocessors before

[05:04] <sorear> especially back in the 50s and 60s when cores used discrete logic

[05:04] <c-lesh> cpu, gpu, spu

[05:04] <geekosaur> although even there it was more the "commonly available and easy for implementors to inegrate" that was the enhancement

[05:05] <sorear> geekosaur: were there any single-die multi-{ARMv1,6502,8080} systems back in the day?

[05:05] <geekosaur> I don't think so

[05:05] <sorear> geekosaur: for embedded systems wanting the ultimate fault isolation

[05:06] <geekosaur> single-die could be done as a tour de force, but not in any kind of quantity, IIRC

[05:07] <geekosaur> but there were multiple CPU mainframes in the 60s and multiple CPU microcomputers in the 70s

[05:08] <geekosaur> including hybrid logic machines such as the OSI C8D and the Commodore SuperPET

[05:08] <c-lesh> not familar with those

[05:08] <geekosaur> (6502/6800/8080 in the latter, IIRC)

[05:09] <sorear> I kind of want to see what the maximum clock speed of a 35nm 6502 would be, and how many of them / combined TFLOPs you can get onto a P4-sized chip

[05:10] <sorear> (ignoring the issue that small local memories are a huge pain for programming)

[05:10] <c-lesh> 64K

[05:10] <c-lesh> that sucks

[05:10] <sorear> I'm talking more like 4K

[05:10] <sorear> *small*

[05:10] <geekosaur> what sucked even more about the 6500 series was that the stack was hardcoded to page 2

[05:10] <c-lesh> 4K - I wrote pong in 256 bytes :)

[05:11] <geekosaur> that is, 256 bytes at $0200

[05:11] <c-lesh> there are clones of pong written in 256 bytes

[05:11] <c-lesh> 256 bytes was for the OS?

[05:11] <c-lesh> $0200

[05:12] <c-lesh> so 64K - 256 was for the program or programs

[05:12] <sorear> c-lesh: $0200 is how we used to write 0x0200

[05:12] <sorear> means that the stack occupies locations 512 to 767

[05:13] <c-lesh> I know but that was the starting address of where the program has to be loaded in 64K architectures.

[05:13] <sorear> also, 64k *addresses* does not mean 64k *bytes of memory*

[05:14] <c-lesh> there was an architecture that had only 64K of memory and 16 bit addressing without segmentation

[05:14] <c-lesh> i think that was the 8080

[05:14] <sorear> segmentation was *rare*, c-lesh

[05:14] <geekosaur> on 6500 your programs usually loded above $0300 or $0400; page 0 was used for indexing (!) and page 2 for stack, page 1 could hold a bootstrap but rarely an entire OS

[05:15] <sorear> *most* of the 16-bit systems didn't have anything even remotely like the 8086's segment registers

[05:15] <c-lesh> how big was a page

[05:15] <sorear> page means 256 bytes

[05:15] <sorear> on the 6502/8080/6800 and related systems

[05:15] <c-lesh> where was the os loaded to

[05:16] <geekosaur> depended on the OS.  CP/M on 8080 and successors loaded the program at $0100 and kept the OS in high memory, letting the program overwrite much of the OS while running and then reloading that part from disk when the program exited

[05:17] <c-lesh> virtual memory

[05:17] <c-lesh> so not much of the os had to be loaded

[05:17] <c-lesh> not even the shell, right?

[05:17] <sorear> Virtual memory for microcomputers did not exist at this point in time.

[05:18] <geekosaur> doing virtual memory well required CPU support that didn't exit back then.  this is more like explicitl overlays where a program or the OS had to explicitly load stuff into the overlay area and swap it around explicitly if needed

[05:18] <c-lesh> but overwriting the os is dangerous

[05:18] <sorear> CPU support for virtual memory on personal computers didn't really exist until the 286

[05:18] <geekosaur> indeed.  but, well, that was what was available at the time

[05:18] <sorear> well after this period

[05:19] *** tokuhirom left
[05:21] <c-lesh> how could the os be overwritten and maintain the stability of the system?

[05:21] <sorear> these weren't multiprogrammed systems.

[05:22] <c-lesh> so if the os was overwritten and the program exited what happened, was the shell still there?

[05:23] <sorear> The program crashes, the user reboots the system

[05:24] <Timbus> did.. did they reboot it with a crank handle

[05:24] <Timbus> :v

[05:24] <geekosaur> the shell was one of the things CP/M explicitly allowed to be overwritten during program execution; proper program exit allowed the OS to reload the shell

[05:24] <geekosaur> but if the program crashed, well, no memory protection or etc., so you got to hit the reset button or flip the power switch

[05:24] <sorear> I imagine the reloader only took a few dozen instructions

[05:24] <geekosaur> it was just the way things worked

[05:25] <sorear> It was a very different culture than we see today in the Land of UNIX Clones

[05:25] <sorear> (imo NT counts as a UNIX clone, even if it's really an OS/2 clone)

[05:26] <geekosaur> weird hybrid of OS/2 and VMS and Unix, really

[05:27] <geekosaur> but with a horrid lot of backward compatibility stuff, some of which microsoft is *still* trying to get rid of

[05:27] <sorear> Timbus: Usually the way things worked back then was that you had a normally-open push button switch that connected the \RESET line on the CPU to ground

[05:27] <sorear> If you were lucky you had another switch that did that for \NMI

[05:27] <Timbus> geekosaur, and Wine is *still* trying to add

[05:28] <Timbus> heh

[05:28] <sorear> (the closest thing to a "real" 70s-80s micro I've used was a 68040 Macintosh running System 7.1.)

[05:28] <c-lesh> the program would call a sub to reload the shell

[05:29] <c-lesh> right?

[05:29] <sorear> the Macintosh was a 32-bit system with 24 address lines; the bulk of the OS was stored in ROM, and the NMI vector pointed to a debugger

[05:30] <c-lesh> ROM as in BIOS

[05:30] <sorear> ROM as in read-only memory

[05:30] <sorear> BIOS is a term specific to PC clones

[05:31] <c-lesh> but doesn't the BIOS chip have some interrupts that allow files to be opened, etc. you know, os specific tasks

[05:31] <sorear> no, no, no, no

[05:31] <sorear> the BIOS chip in a PC is just memory

[05:31] <sorear> it stores 32-128 kilobytes of data

[05:32] <c-lesh> no programs?

[05:32] <sorear> the address decode logic on the motherboard causes some addresses to be routed to the chip

[05:32] <sorear> in particular, the PC starts executing instructions at $FFFF0

[05:32] <sorear> (there are some real horrors with initial CS setting that I'm not going into here)

[05:33] <sorear> so usually the BIOS memory range includes, at least, $F0000 to $FFFFF

[05:33] <c-lesh> memory mapped, right?

[05:33] <sorear> the BIOS doesn't know what files are

[05:33] <sorear> it does include a disk driver

[05:33] <c-lesh> that's true, just sectors

[05:33] <c-lesh> disk driver to read sectors?

[05:34] <sorear> the bios loads sector (512byte) 0 of the floppy disk at address $7A00 (?), checks the last 2 bytes for the magic signature $55AA, and if so jumps to address $7A00

[05:34] <sorear> might be $7C00 or $7E00

[05:34] <sorear> been a while since I wrote a boot sector

[05:35] <c-lesh> you wrote a boot sector, for what?

[05:35] <sorear> the BIOS also contains subroutines that the OS can use to access hardware

[05:35] <sorear> I wasted a few months of my life writing a toy OS... please don't judge

[05:35] <c-lesh> so the bios contains basic hardware drivers

[05:35] <sorear> yes

[05:35] <c-lesh> that sounds like fun

[05:35] <c-lesh> how did you debug the boot sector?

[05:36] <sorear> I used a PC emulator

[05:37] <c-lesh> that's cool

[05:37] <sorear> the BIOS *chip* does not interact with interrupts in any way

[05:37] <c-lesh> i see

[05:38] <sorear> when the x86 chip sees an instruction like $CD $13, it acts as though it had received an interrupt 13h from the bus

[05:38] <sorear> so it loads a long address from $0004C and calls it after saving the old CS:IP and flags

[05:38] <sorear> it's called an interrupt but it's really more like a subroutine call

[05:39] <c-lesh> i see

[05:39] <c-lesh> that's interesting

[05:39] <sorear> anyway the standard PC BIOS sets up interrupts 10h to 1Fh to different services

[05:39] <c-lesh> so the instruction initiates the interrupt

[05:39] <sorear> "interrupt" 10h is a disk driver, interrupt 13h controls the display

[05:41] <sorear> the idea was that you would write an OS, and the OS would use the BIOS-provided services so that IBM could change the PC hardware

[05:41] <sorear> sort of like how CISC makes it possible for processors to evolve

[05:41] <sorear> many problems can be solved by adding a layer of indirection

[05:41] <c-lesh> interesting

[05:41] <sorear> ... it didn't quite work, modern OSes generally don't use the BIOS for a variety of reasons

[05:43] <geekosaur> non-reentrant, non-interruptible, often quite slow compared to direct access, often uses scratchpad memory that interferes with OS memory

[05:43] <c-lesh> i see

[05:43] <geekosaur> although, I would say the BIOS is in many ways back; ACPI in particular

[05:44] <sorear> also, writing code to work around bugs in 10 PC clone BIOSes is just as hard as writing code to work with 10 diffierent pieces of PC clone hardware

[05:44] <geekosaur> another issue is, with disk drivers the generic BIOS entry point doesn't generally allow for intelligent scheduling of reads/writes which can be done by an OS's disk driver

[05:44] <geekosaur> yep

[05:46] <c-lesh> so the bios is not really used

[05:46] <sorear> another issue is that the BIOS uses 8086 instructions

[05:46] <sorear> this was especially a problem for the 286, because once a 286 has been switched to native mode, the only way to reenter 8086 compatibility mode is to reboot (!)

[05:47] <sorear> the 386 and later processors can switch back and forth freely, but it's still a performance and complexity cost

[05:48] <sorear> "new" subsystems like ACPI and VBE often provide an alternate entry point that uses 386 instructions

[05:53] <c-lesh> real mode

[06:03] <sorear> rakudo: say "foo".IO ~~ :s

[06:03] <p6eval> rakudo a7fd89: OUTPUT«Bool::False␤»

[06:03] <sorear> rakudo: say "README".IO ~~ :s

[06:03] <p6eval> rakudo a7fd89: OUTPUT«Bool::False␤»

[06:03] <sorear> rakudo: say "/".IO ~~ :s

[06:03] <p6eval> rakudo a7fd89: OUTPUT«Bool::True␤»

[06:03] <sorear> rakudo: say "/".IO.s

[06:03] <p6eval> rakudo a7fd89: OUTPUT«Bool::True␤»

[06:04] <sorear> rakudo: say "NQP_VERSION".IO.s

[06:04] <p6eval> rakudo a7fd89: OUTPUT«Bool::False␤»

[06:04] <sorear> rakudo: say "/etc/debian_version".IO.s

[06:04] <p6eval> rakudo a7fd89: OUTPUT«Bool::True␤»

[06:04] <sorear> rakudo: say "/etc/debian_version".IO.^methods(:local)

[06:04] <p6eval> rakudo a7fd89: OUTPUT«open close eof get getc lines read seek tell write opened print say slurp d e f l r s t w x z copy chmod ins chomp path␤»

[06:09] <c-lesh> cool

[06:10] <sorear> yes, I mean real mode

[06:11] <sorear> it seemed like the unneccessary obfuscation though, so I didn't say it

[06:12] <sorear> c-lesh: disclaimer: I'm 21 years old.  Everything I say about computer architectures in the 70s, don't assume I have first-hand knowledge

[06:13] *** tokuhirom joined
[06:15] *** fridim_ left
[06:22] <c-lesh> well, i'm going to sleep thanks for all the knowledge

[06:23] *** c-lesh left
[06:31] *** icwiener_ left
[06:32] *** icwiener_ joined
[06:43] *** icwiener_ left
[06:52] *** icwiener_ joined
[06:57] *** lateau_ joined
[06:58] *** wtw joined
[06:59] *** fridim_ joined
[07:09] *** packetknife left
[07:13] *** hundskatt joined
[07:28] *** sayu joined
[07:33] *** xjiujiu joined
[07:36] *** kaleem joined
[07:39] *** baest joined
[07:41] *** fridim_ left
[07:46] <frettled> Good moaning!

[07:46] <sorear> hi

[07:52] *** Mowah joined
[08:04] *** xjiujiu left
[08:08] *** tokuhirom left
[08:14] <Woodi> hi ppls today :)

[08:14] <Woodi> just backlogged :)

[08:15] <Woodi> sorear, geekosaur: pls, PLS, write blogs !

[08:21] <Woodi> colomon: me think part of fractal work goes to performance testing and this was marketed. and would be nice to spread knowledge about more application-way using of Perl6 GUI

[08:24] <sorear> Woodi: about what?

[08:24] <sorear> I have no idea which of the things I've done are worth blogging about.

[08:25] <Woodi> sorear, geekosaur you can easily blog about 'technology', just find problem or 'possible improvement' you want to comment, add historical view, add comparision of existing implementations...

[08:25] <Woodi> sorear: me think, for the start, would be nice some jurnalist ask some questions to you :)

[08:26] *** mj41 joined
[08:27] <Timbus> it was an alright read

[08:27] <Timbus> gotta admit

[08:28] <Woodi> sorear: I have question for example: how stable or rock solid (in room temperature) are basic niecza/Perl6 features/functionalities. eg. are 'if', 'say', misc loop production ready ?

[08:29] <Woodi> so scripting with that could be done

[08:29] <Woodi> what other features are stable ?

[08:29] <Woodi> how fast is niecza on linux with mono ?

[08:30] <Timbus> about thiiiis fast *gestures with arms*

[08:30] <Woodi> sorear: how fast would be web server or web backend using niecza ?

[08:30] <Woodi> which databases you can access today ?

[08:31] <Woodi> sorear: pls write some library or app (crud) ppls can copy 

[08:32] <sorear> Woodi: you're not going to be able to break if/say/misc loops.  Those are super-super-solid

[08:32] <sorear> niecza on linux with mono - varies a bit, comparable to Perl 5 but a bit slower

[08:33] *** x3nU left
[08:34] <sorear> web server - no clue

[08:34] <Woodi> do niecza GUI include business grid/table ?

[08:34] <Timbus> a what

[08:36] <Woodi> relational table/data from db presenting widget :)

[08:37] <Woodi> how stable is GUI ? small, stable Excel can be coded ?

[08:38] <Woodi> how stable text manipulation, regexes, grammars are ?

[08:39] *** x3nU joined
[08:39] <moritz> I'll be traveling most of the day, hope to be online in ~6h again

[08:39] <moritz> ciao

[08:39] <Woodi> sorear: problem with niecza is that it use worse then alien technology :) but one or two small but usefull apps will make it will be used

[08:39] *** x3nU is now known as Guest13145

[08:43] * Woodi tee

[08:46] *** risou_awy is now known as risou

[08:47] *** Mowah left
[08:57] <Woodi> anyway, ppl, do not forget moust of us have winter now so low on sunlight which make better feeling. bears can at least sleep over that season :) 

[08:58] <Woodi> but hot cup of tee make me usually better :)

[09:03] *** sayu left
[09:07] <sorear> the drink is spelled "tea"

[09:07] <Woodi> sorear: just found on Rosettacode that Niecza was 'using Perl5' initially. and in Niecza announcement that it is 'project focusing on optimization research'. is that goal done or to what point ? why architecture and how changed ? 

[09:07] * sorear smiles for the first time today

[09:07] <Woodi> damn

[09:08] <sorear> Woodi: I'm always asking how niecza can be made faster.

[09:08] <sorear> And use less memory

[09:08] <Woodi> I realy need to re learn basics...

[09:09] <Woodi> sorear: but what other Perl6 implementations can learn from niecza ?

[09:09] <sorear> how to implement features

[09:10] <sorear> having two implementations helps to keep the spec on top

[09:10] <sorear> but if you don't mind I'd like to sleep now

[09:11] <Woodi> sorear: no problem, I can still put questions, etc here and hope it helps somehow someday :)

[09:11] * sorear -> sleep

[09:14] *** Mowah joined
[09:26] *** kranius joined
[09:26] <masak> morning, #perl6!

[09:34] <Woodi> hallo

[09:36] <Woodi> masak: how you think, niecza could use niecza.perl6.org for now ?

[09:37] *** sftp left
[09:37] *** molaf joined
[09:38] <Woodi> I could submit it to freshmeat.net/freecode too

[09:48] <masak> er.

[09:48] *** ruoso left
[09:48] <masak> Woodi: (1) how do you mean, "use niecza.perl6.org"? (2) what is it you think you could submit to freshmeat, and why?

[09:49] <masak> stand down, soldier.

[09:49] <masak> don't make decisions that are really up to sorear.

[09:50] <Woodi> ad 1. just thinked about simple web page for now.

[09:51] <Woodi> ad 2. you must see it yourself :) it portal with announcements of opensource project, works seence '90

[09:51] <masak> I know what freshmeat is.

[09:51] <Woodi> url was freashmeat.net and stil works

[09:51] <masak> my question was more, why do you think you should submit something Niecza-related to freshmeat?

[09:52] *** icwiener_ left
[09:52] <Woodi> why you use Reddit ? :) another place :)

[09:52] *** icwiener_ joined
[09:54] *** kaleem left
[09:54] <masak> I know you're eager to publish sorear, but I really think it's better if he starts the process himself.

[09:54] <masak> otherwise we'll have one or more unmaintained pages claiming to contain up-to-date information on Niecza.

[09:55] <Woodi> Ithink sorear would like community will do simple and boring task for him...

[09:56] <masak> yeah, don't.

[09:56] <Woodi> k, I will ask sorear first

[09:59] <Woodi> later

[10:05] *** molaf left
[10:05] *** arlinius left
[10:07] *** kaleem joined
[10:17] *** arlinius joined
[10:24] *** sayu joined
[11:07] <kshannon> good * #perl6

[11:08] *** Mowah left
[11:24] <tadzik> hello #perl6

[11:25] *** ruoso joined
[11:25] *** lateau_ left
[11:27] *** kaleem left
[11:28] <tadzik> why is sleep() a sub:prefix rather than just a sub?

[11:30] <Juerd> I'll guess: precedence

[11:30] <Juerd> sleep 5, say "hi"

[11:31] <Juerd> Like Perl 5's ($)-prototyped subs

[11:31] <Juerd> </guess>

[11:34] *** sftp joined
[11:50] *** LlamaRider joined
[11:54] *** Trashlord left
[11:58] *** kaleem joined
[12:01] *** sayu_ joined
[12:02] *** sayu left
[12:02] *** Trashlord joined
[12:09] <masak> Juerd: yeah.

[12:10] <masak> Juerd: also, &time.

[12:10] <masak> I don't remember how we did with &rand.

[12:10] * masak checks the symbols in STD

[12:12] <masak> S03 gives 'sleep abs sin temp let' as examples.

[12:12] <tadzik> hrm

[12:12] <masak> ah;

[12:12] <masak> There is no unary C<rand> prefix in Perl 6, though there is a C<.rand>

[12:12] <masak> method call and an argumentless C<rand> term.

[12:12] <masak> perl6: say rand 5

[12:12] <p6eval> niecza v13-46-gab2db52: OUTPUT«===SORRY!===␤␤Unsupported use of rand(N); in Perl 6 please use N.rand or (1..N).pick at /tmp/UdmCAm4STk line 1:␤------> say rand⏏ 5␤␤Parse failed␤␤»

[12:12] <p6eval> ..pugs b927740: OUTPUT«3.425864913733676␤»

[12:12] <p6eval> ..rakudo a7fd89: OUTPUT«===SORRY!===␤Unsupported use of rand(N); in Perl 6 please use N.rand or (1..N).pick at line 1, near " 5"␤»

[12:12] <masak> \o/

[12:14] *** kaleem left
[12:24] <Timbus> nom: say 5.rand

[12:24] <p6eval> nom a7fd89: OUTPUT«4.18286033244387␤»

[12:24] <Timbus> so... 'why'

[12:26] <masak> maybe because there's the realization that unary-prefix subs are exceptions to the general rule of listop subs, and we want to cut down on them as much as possible?

[12:27] *** snearch joined
[12:27] <masak> without, for some reason, going all the way down to 0. :P

[12:27] <masak> maybe going all the way down to 0 would count as having an ideological axe to grind...

[12:28] <Timbus> rand is a listop?

[12:28] *** snearch left
[12:29] <Timbus> i think something flew over my head there

[12:29] <Timbus> it is far too hot for thinking

[12:30] *** kaleem joined
[12:31] <LlamaRider> aren't listops just shorthand for using associative operators?

[12:34] <masak> Timbus: &rand as a sub is deprecated in Perl 6. use the method instead.

[12:34] <masak> LlamaRider: I did not understand that question.

[12:34] * masak wants to reject https://rt.perl.org/rt3/Ticket/Display.html?id=107292

[12:35] <masak> also, https://rt.perl.org/rt3/Ticket/Display.html?id=107330 is a valid ticket but belongs in https://github.com/perl6/nqp/issues

[12:35] <dalek> roast: af353d6 | (Solomon Foster)++ | S0 (3 files):

[12:35] <dalek> roast: Refudge a bit to account for new, harder fails in Niecza.

[12:35] <dalek> roast: review: https://github.com/perl6/roast/commit/af353d6e63

[12:36] *** tokuhirom joined
[12:38] <LlamaRider> masak: scratch that question, i was thinking only of infix ops that end up as list ops

[12:42] <masak> ah, yes.

[12:43] <masak> well, even something like 'say' is a listop, long as you don't use parens.

[12:46] <masak> nom: enum LionelRichie <me naturally together you>; sub it(*@a) { @a }; say you; say me; say it together, naturally

[12:46] <p6eval> nom a7fd89: OUTPUT«LionelRichie::you␤LionelRichie::me␤together naturally␤»

[12:48] *** icwiener_ left
[12:50] <Timbus> <masak> Timbus: &rand as a sub is deprecated in Perl 6. use the method instead.

[12:50] <Timbus> :I copout

[12:52] *** icwiener_ joined
[12:53] <dalek> niecza: 3171346 | (Solomon Foster)++ | lib/CORE.setting:

[12:53] <dalek> niecza: Do numeric casting as needed in Range constructor.

[12:53] <dalek> niecza: review: https://github.com/sorear/niecza/commit/3171346f42

[12:55] * geekosaur thinks sleep is special-cased because you know it's never going to do anything sensible with a list, and 5.sleep is just weird

[12:55] <masak> Timbus: that was in response to your question "rand is a listop?", which doesn't make much sense since the sub's deprecated.

[12:58] *** icwiener_ left
[12:59] <masak> I guess it wasn't a listop before it got deprecated...

[12:59] <masak> pugs: say rand 4, 5

[12:59] <p6eval> pugs b927740: OUTPUT«3.76167444512248045␤»

[13:00] <masak> pugs: say rand 4, ":::", 5

[13:00] <p6eval> pugs b927740: OUTPUT«1.895408839918673:::5␤»

[13:00] <masak> right.

[13:00] *** snearch joined
[13:02] <masak> geekosaur: I think it would be more consistent to have sleep parse as a listop, but to complain (at parse time) whenever more than one argument was passed to it. as it is 'say 2, sleep 3, 4, 5' is hard to read and understand.

[13:02] *** icwiener_ joined
[13:08] <masak> though I guess it's no more tricky than scalar assignment :)

[13:09] <masak> it all depends on what expectations one has.

[13:20] *** snearch left
[13:38] *** spine joined
[13:40] *** kaleem left
[13:42] <dalek> roast: 35ebf63 | (Solomon Foster)++ | S03-operators/range.t:

[13:42] <dalek> roast: Add tests for string and array RHS of numeric ranges.

[13:42] <dalek> roast: review: https://github.com/perl6/roast/commit/35ebf63d8d

[13:48] *** Mowah joined
[13:58] *** daxim joined
[14:31] *** whiteknight joined
[14:31] *** whiteknight is now known as Guest25455

[14:39] *** owlEyes joined
[14:40] *** bao joined
[14:41] *** orafu left
[14:43] *** orafu joined
[14:46] *** PerlJam joined
[14:46] <PerlJam> greetings!

[14:46] <masak> earthlings!

[14:49] <spine> hi there, is there some way in rakudo to keep the list generated by the cross operator from flattening?

[14:49] <spine> S03 says to uses lol context, but that doesn't seem to be implemented.

[14:50] <spine> rakudo: say .perl for (1,2)X,(3,4)

[14:50] <p6eval> rakudo a7fd89: OUTPUT«1␤3␤1␤4␤2␤3␤2␤4␤»

[14:51] <bao> ?

[14:52] <masak> spine: correct -- I don't think it's implemented.

[14:52] <masak> bao: ¿

[14:53] *** snearch joined
[14:53] <spine> masak: so I'd be best off by implementing a version of <infix:X> myself, which makes items from the lists?

[14:53] <masak> bao: 你来自中国吗？

[14:54] <masak> spine: not sure what you'd be best off doing :) if you know the size of the items, you can simply iterate that size.

[14:55] <masak> nom: for 1..10 X 'a'..'j' -> $a, $b { say "$a$b" }

[14:55] <p6eval> nom a7fd89: OUTPUT«1a␤1b␤1c␤1d␤1e␤1f␤1g␤1h␤1i␤1j␤2a␤2b␤2c␤2d␤2e␤2f␤2g␤2h␤2i␤2j␤3a␤3b␤3c␤3d␤3e␤3f␤3g␤3h␤3i␤3j␤4a␤4b␤4c␤4d␤4e␤4f␤4g␤4h␤4i␤4j␤5a␤5b␤5c␤5d␤5e␤5f␤5g␤5h␤5i␤5j␤6a␤6b␤6c␤6d␤6e␤6f␤6g␤6h␤6i␤6j␤7a␤7b␤7c␤7d␤7e␤7f␤7g␤7h␤7i␤7j␤8a␤8b␤8c␤8d␤8e␤8f␤8g␤8h␤8i␤8j␤9a␤9b􏿽xE2

[14:58] <spine> masak: OK, thanks. I'll see if that is enough. trying to write down a nice solution to the tree problem from your coding contest ;)

[14:59] <masak> nice!

[15:02] <cognominal> "Foundations of Language : Brain, Meaning, Grammar, Evolution"  http://www.amazon.fr/dp/B001ODEPQ2

[15:02] <cognominal> may be of interest to people here

[15:03] <cognominal> better link : http://www.amazon.com/dp/B001ODEPQ2

[15:04] *** bao left
[15:10] *** kaare_ joined
[15:13] *** wtw left
[15:14] *** kaare_ left
[15:15] *** kaare_ joined
[15:16] *** kaare_ left
[15:16] *** kaare_ joined
[15:18] *** simcop2387 left
[15:20] *** simcop2387 joined
[15:23] *** sayu_ left
[15:24] *** sayu joined
[15:30] *** teeter joined
[15:30] <fsergot> nom: for 1..10 X 'a'..'j' -> $a { say $a }

[15:30] <p6eval> nom a7fd89: OUTPUT«1␤a␤1␤b␤1␤c␤1␤d␤1␤e␤1␤f␤1␤g␤1␤h␤1␤i␤1␤j␤2␤a␤2␤b␤2␤c␤2␤d␤2␤e␤2␤f␤2␤g␤2␤h␤2␤i␤2␤j␤3␤a␤3␤b␤3␤c␤3␤d␤3␤e␤3␤f␤3␤g␤3␤h␤3␤i␤3␤j␤4␤a␤4␤b␤4␤c␤4␤d␤4␤e␤4␤f␤4␤g␤4␤h␤4␤i␤4␤j␤5␤a␤5␤b␤5␤c␤5␤d␤5␤e␤5␤f␤5␤g␤5␤h␤5␤i␤5␤j␤6␤a␤

[15:30] *** teeter left
[15:30] <fsergot> nom: my @a := 1..10 X 'a'..'j'; say @a.WHAT;

[15:31] <p6eval> nom a7fd89: OUTPUT«List()␤»

[15:31] <fsergot> nom: my @a := 1..10 X 'a'..'j'; say @a.perl;

[15:31] <p6eval> nom a7fd89: OUTPUT«((ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (…

[15:31] <fsergot> nom: my @a := 1..10 X 'a'..'j'; say @a;

[15:31] <p6eval> nom a7fd89: OUTPUT«1 a 1 b 1 c 1 d 1 e 1 f 1 g 1 h 1 i 1 j 2 a 2 b 2 c 2 d 2 e 2 f 2 g 2 h 2 i 2 j 3 a 3 b 3 c 3 d 3 e 3 f 3 g 3 h 3 i 3 j 4 a 4 b 4 c 4 d 4 e 4 f 4 g 4 h 4 i 4 j 5 a 5 b 5 c 5 d 5 e 5 f 5 g 5 h 5 i 5 j 6 a 6 b 6 c 6 d 6 e 6 f 6 g 6 h 6 i 6 j 7 a 7 b 7 c 7 d 7 e 7 f 7 g …

[15:33] <fsergot> nom: my @a = 1..10 X 'a'..'j'; say @a;

[15:33] <p6eval> nom a7fd89: OUTPUT«1 a 1 b 1 c 1 d 1 e 1 f 1 g 1 h 1 i 1 j 2 a 2 b 2 c 2 d 2 e 2 f 2 g 2 h 2 i 2 j 3 a 3 b 3 c 3 d 3 e 3 f 3 g 3 h 3 i 3 j 4 a 4 b 4 c 4 d 4 e 4 f 4 g 4 h 4 i 4 j 5 a 5 b 5 c 5 d 5 e 5 f 5 g 5 h 5 i 5 j 6 a 6 b 6 c 6 d 6 e 6 f 6 g 6 h 6 i 6 j 7 a 7 b 7 c 7 d 7 e 7 f 7 g …

[15:34] <fsergot> Whats differences between := and =?

[15:34] <masak> I'd just like to say I like fluent interfaces, and I think they could be used more than they are today: http://martinfowler.com/bliki/FluentInterface.html

[15:34] <masak> fsergot: := binds a value to a variable, = assigns a value to the container associated with a variable.

[15:35] *** Mowah left
[15:35] <masak> fsergot: after the binding, you have variable->value. after the assignment, you have variable->container->value.

[15:35] *** baest left
[15:35] *** havinglargeballs joined
[15:35] <fsergot> nom: my @a = 1..3 X 'a'..'c'; say @a.perl;

[15:35] <p6eval> nom a7fd89: OUTPUT«Array.new(1, "a", 1, "b", 1, "c", 2, "a", 2, "b", 2, "c", 3, "a", 3, "b", 3, "c")␤»

[15:35] <masak> fsergot: the container allows you to do more assignments later.

[15:36] <fsergot> nom: my $a := 'a'; $a = 'b';

[15:36] <p6eval> nom a7fd89: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/7UHz7Z9JDf:1␤  in <anon> at /tmp/7UHz7Z9JDf:1␤»

[15:36] <fsergot> masak++ clear, thanks.

[15:36] <fsergot> :)

[15:38] <fsergot> the deeper in perl i am, the more interesting p6 is :)

[15:39] <masak> best explanation I've given so far :)

[15:39] <masak> fsergot: you might find http://strangelyconsistent.org/blog/plain-old-assignment-and-freaky-binding interesting, too.

[15:39] <fsergot> masak: where, in life examples, i can use := ? :)

[15:39] <fsergot> masak: thanks :)

[15:39] <masak> hm, that's slightly badly formatted. sorry about that.

[15:40] <masak> fsergot: that's too general a question.

[15:40] *** Mowah joined
[15:40] <masak> fsergot: but often binding involves less "copying" than assignment. I've seen people use if for performance reasons.

[15:41] <dalek> roast: f6f7478 | (Solomon Foster)++ | S03-sequence/nonnumeric.t:

[15:41] <dalek> roast: Fudge for niecza.

[15:41] <dalek> roast: review: https://github.com/perl6/roast/commit/f6f7478f49

[15:42] <fsergot> thanks :)

[15:43] <dalek> niecza: 1f4230f | (Solomon Foster)++ | t/spectest.data:

[15:43] <dalek> niecza: Turn on S03-sequence/nonnumeric.t.

[15:43] <dalek> niecza: review: https://github.com/sorear/niecza/commit/1f4230f787

[15:45] <masak> fsergot: for example http://strangelyconsistent.org/p6cc2010/p5-moritz/ uses binding for this reason.

[15:46] <masak> binds the array rather than clone it and copy all of the strings in it.

[15:48] <spine> fsergot; I've come to some problems with = when using lazy lists, e.g. my @a = map {$_}, 1..Inf; leads to an infinite loop, whereas my @a := map {$_}, 1..Inf; retains it's lazyness.

[15:48] <masak> oh yes. that's a good reason, too.

[15:49] <masak> array assignments are eager -- array bindings are lazy.

[15:49] <masak> it's even possible to bind a lazy list to an array constant :)

[15:50] <TimToady> niecza: constant @primes = 2, 3, { ($_ + 2, $_ + 4 ... *).first: -> $n { $n %% none @primes ... * > sqrt($n); } } ... *; say @primes[^20];

[15:50] <p6eval> niecza v13-47-g3171346: OUTPUT«2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71␤»

[15:50] <masak> \o/

[15:50] <colomon> niecza: constant @song := $*IN.lines; say @song[1]

[15:50] <p6eval> niecza v13-47-g3171346: OUTPUT«===SORRY!===␤␤Malformed constant at /tmp/2QeX4cP_Fd line 1:␤------> constant @song ⏏:= $*IN.lines; say @song[1]␤␤Parse failed␤␤»

[15:50] <colomon> niecza: constant @song = $*IN.lines; say @song[1]

[15:50] <p6eval> niecza v13-47-g3171346: OUTPUT«Unhandled exception: Unable to resolve method lines in class Any␤  at /tmp/h2aTGpinkC line 1 (@song init @ 2) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 0 (downcall @ 0) ␤  at /home/p6eval/niecza/src…

[15:50] <TimToady> the pseudo assignment works more like a binding here

[15:51] <masak> but surely binding should be syntactially allowed, too?

[15:51] * [Coke] starts skipping through backscroll.

[15:51] <TimToady> niecza: constant @song = lines($*IN); say @song[1]

[15:51] <p6eval> niecza v13-47-g3171346: OUTPUT«Unhandled exception: Unable to resolve method lines in class Any␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/IRlIdmlY4Y line 1 (@song init @ 2) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 0 (do…

[15:52] <TimToady> oh, should've expected that

[15:52] <colomon> niecza: constant @song = $*IN.slurp; say @song[1]

[15:52] <p6eval> niecza v13-47-g3171346: OUTPUT«Unhandled exception: Unable to resolve method slurp in class Any␤  at /tmp/R6diXdVUi1 line 1 (@song init @ 2) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 0 (downcall @ 0) ␤  at /home/p6eval/niecza/src…

[15:53] <colomon> niecza: constant @song = lines(); say @song[1]

[15:53] <p6eval> niecza v13-47-g3171346: OUTPUT«Unhandled exception: Unable to resolve method lines in class Any␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/qR9nBecSu4 line 1 (@song init @ 2) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/src/NieczaBackendDotnet.pm6 line 0 (do…

[15:53] <TimToady> the problem is $*IN is not there at compile time

[15:53] <colomon> ah

[15:53] *** havinglargeballs left
[15:53] <colomon> TimToady++

[15:54] *** daxim left
[15:54] <masak> d'oh!

[15:55] <[Coke]> masak: re: RT#107292 - is Perl6::Compiler in the specs anywhere?

[15:55] <masak> nope.

[15:56] <masak> it's a Rakudo thing.

[15:56] *** bluescreen10 joined
[15:56] <masak> I don't think the expectation that it'll be loadable at the user level is justified.

[15:57] *** LlamaRider left
[15:58] <PerlJam> Why not?  Seems like it falls under making "hard things possible"

[15:59] <[Coke]> PerlJam: because it's not in the spec, and is therefor one more thing we'd have to support if we refactored.

[15:59] *** snearch left
[15:59] *** snearch joined
[16:00] <masak> nqp is a different language than Perl 6, so even if the user find the file, he'd have to load it through with some :lang<nqp> modifier.

[16:00] <masak> s/find/found/

[16:01] <jnthn> afternoon, #perl6

[16:01] <phenny> jnthn: 21 Dec 20:01Z <moritz> tell jnthn at your convenience, please take a look at S12-attributes/mutators.t. It seems to die in   $!varies +=2  with "No applicable candidates found to dispatch to for 'Numeric'", which I find quite weird, since $!varies is typed Int

[16:01] <phenny> jnthn: 22 Dec 12:18Z <moritz> ask jnthn if he wants to get some commits in before the release

[16:01] <phenny> jnthn: 27 Dec 02:12Z <sorear> tell jnthn http://irclog.perlgeek.de/perl6/2011-12-27#i_4883396 I'd like a second opinion

[16:01] <PerlJam> [Coke]: I agree that those things are true, but that doesn't seem like a sufficient argument for not making it part of the spec.

[16:01] <[Coke]> +1 from me on rejecting it, anyway.

[16:02] <[Coke]> PerlJam: then you're forcing every implementation to use our (currently internal) API.

[16:02] <jnthn> Just dropping by to say I'm still alive. ;-)

[16:02] <[Coke]> jnthn: \o/

[16:02] <jnthn> Will be back home in a few days, and then back to my normal level of hacktivity. :)

[16:02] <PerlJam> [Coke]: no, I'm saying make the API public.  (at least I'm entertaining the idea a little more than the rest of you :)

[16:03] <masak> jnthn! \o/

[16:04] <[Coke]> so, don't make it spec, but make it supported? Still -1 from me. ;)

[16:05] *** owlEyes left
[16:05] <jnthn> Loading NQP code will need a :lang<nqp>.

[16:07] <PerlJam> I'm perfectly happy rejecting that ticket for the reasons cited, I just think the idea has some merit that should be considered.

[16:08] <jnthn> The Perl 6 grammar almost certainly should be accessible from Perl 6 space, with an appropriate use statement. The exact interface to doing so is something we probably want to try and standardize over implementations.

[16:08] <jnthn> Though not a priority at the moment, for me anyway.

[16:09] *** phenny joined
[16:12] <jnthn> huh, how come Pretence got changed to Pretense in a7fd89ea? :)

[16:12] <masak> goodness knows!

[16:12] * masak pretends to be innocent

[16:12] <jnthn> http://www.thefreedictionary.com/pretence is correct, y'know :P

[16:12] <jnthn> oh, pretense is the American spelling.

[16:13] <masak> aye.

[16:13] <masak> the commit comment says as much!

[16:13] <jnthn> But my MOP is proudly British! :P

[16:14] <PerlJam> jnthn: so ... do you "kick to the curb"  or "kick to the kerb"?

[16:14] <PerlJam> (or would you were you so inclined to do such a thing )

[16:14] <PerlJam> :)

[16:15] <jnthn> Well, it's spelt kerb of course :P

[16:15] <jnthn> But "kick to the kerb" sounds a bit of a gangsta thing to be doing to me :P

[16:15] * jnthn hasn't actually heard that expression before :)

[16:16] <PerlJam> it's probably american in origin, so it should be "kick to the curb"  :)

[16:16] <masak> jnthn: it is? I can see no other instances of British spelling in the MOP. that's why I thought "Pretence" was an honest mistake.

[16:16] <jnthn> masak: I was mostly kidding about.

[16:17] <jnthn> masak: Well, it's not so much mistake as "jnthn simply doesn't think about these things" 

[16:17] * PerlJam was just surprised at the "americanization" of the MOP  ;)

[16:17] <ruoso> happy new year... (for all of those in the gregorian or julian calendars :) )

[16:17] <masak> PerlJam: it wasn't so much "americanization" as... a silly commit.

[16:17] <masak> PerlJam: now they have to credit me in the January release. mwhahaha!

[16:17] <PerlJam> heh!

[16:18] <jnthn> masak: Bah, you were meant to do that by getting us macros. :P

[16:18] <masak> ok, I'll do some of that too, then.

[16:18] <jnthn> yay :)

[16:18] * jnthn well get back to his NCI work

[16:18] <jnthn> *will

[16:18] <jnthn> Friday or weekend at the latest.

[16:19] <jnthn> Doing family/friend/visiting stuff for last few days here :)

[16:20] <masak> jnthn: make sure you relax really well, and come back with batteries charged to the brim!

[16:20] <ruoso> jnthn: hey... I am getting some weird behaviors and segfaults with my junction-using sudoku solver

[16:21] <colomon> jnthn, \o/

[16:21] * PerlJam wished his xmas would have been of the battery-charging kind rather than the bettery-draining kind

[16:21] <PerlJam> s/wished/wishes/

[16:21] <jnthn> ruoso: OK. An RT ticket with code and, if you can get it, a backtrace would be helpful.

[16:21] <jnthn> ruoso: I'll look at it once I'm back do things...probably the weekend.

[16:23] *** bbkr joined
[16:27] * ruoso submitted

[16:29] <jnthn> Thanks!

[16:29] <jnthn> Looking forward to getting back to Perl 6 stuff in a few days time :)

[16:29] <jnthn> And with much more energy than I had by the end of December :)

[16:29] <jnthn> Tuit supply is looking reasonable for Jan/Feb too :)

[16:30] <masak> sounds wonderful.

[16:30] <masak> jnthn: looking forward to you getting back!

[16:30] <jnthn> :)

[16:32] *** kaleem joined
[16:33] <PerlJam> btw, anyone seen pmichaud?

[16:33] <Guest13145> hi

[16:33] *** Guest13145 is now known as x3nU

[16:33] <masak> hi, Guest25455^W x3nU

[16:34] <[Coke]> PerlJam: if anyone had actually seen him, I'd expect it to be you! ;)

[16:34] <x3nU> jnthn: someone told me to ask you

[16:34] <x3nU> i can't compile rakudo with msvc 2010

[16:34] <x3nU> http://pastebin.com/vnJy7JjP

[16:34] <x3nU> there's no error message

[16:34] <jnthn> 32 or 64?

[16:34] <x3nU> 32

[16:34] <x3nU> just "nqp.exe has stopped working" or something

[16:34] <jnthn> Hm

[16:34] <x3nU> like that

[16:35] <PerlJam> [Coke]: I was actually thinking something similar when I asked  the question :)

[16:35] <[Coke]> I have a 32-bit windows system; I can try on mine.

[16:35] <jnthn> How are you building?

[16:35] <jnthn> I wonder if it's the "need to copy libparrot.dll in some cases" issue

[16:35] <x3nU> perl Configure.pl --prefix=C:/Rakudo --gen-parrot --gen-nqp

[16:35] <x3nU> it fails on configure

[16:35] <jnthn> Try (in the NQP directory) copy ..\install\bin\libparrot.dll .

[16:36] <jnthn> Then give it another go.

[16:36] <x3nU> ok, i will check it :)

[16:36] <masak> jnthn++

[16:37] <jnthn> We have an RT for this issue (if this is the issue)

[16:37] <jnthn> Just didn't get to it yet.

[16:40] <jnthn> OK, back to relaxation mode here :)

[16:40] <jnthn> Probably back about on Thursday evening, once I get home :)

[16:40] <jnthn> o/

[16:41] <masak> \o

[16:41] <x3nU> bye :)

[16:42] *** kaleem left
[16:42] <tadzik> oh, I've just missed jnthn

[16:44] *** tokuhirom3 joined
[16:44] *** tokuhirom left
[16:49] *** sayu left
[16:50] <masak> tadzik: yes, but he promised to be back later in the week :)

[17:03] <x3nU> jnthn's solution worked :D

[17:03] *** fsergot left
[17:03] <x3nU> jnthn++

[17:03] <tadzik> yeah, I can see :)

[17:09] *** lateau_ joined
[17:10] *** estrabd left
[17:18] *** MayDaniel joined
[17:24] *** fsergot joined
[17:33] <colomon> std mavens: I'm looking at sort.t, and it defines a new multi for sub cmp (???) and then tests that sort uses it.  There's at least two major errors with that idea, right?

[17:34] *** c-lesh joined
[17:34] <c-lesh> hello again

[17:34] <colomon> \o

[17:35] <c-lesh> i was wondering if anyone has looked at the source for Parrot

[17:36] <colomon> I avoid it like the plague.  ;)

[17:36] <c-lesh> is it hard to read

[17:36] <c-lesh> is it object oriented

[17:37] <c-lesh> i was just wondering which module interprets the bytecode

[17:38] <colomon> c-lesh: there's probably someone around here who can answer that.  but there's an entire #parrot channel full of experts out there.

[17:38] * colomon doesn't recall whether it's on freenode or the perl IRC network.

[17:39] <tadzik> perl

[17:40] <c-lesh> does parrot development take place there

[17:40] <colomon> I believe so.

[17:41] <c-lesh> cool

[17:41] <colomon> as far as I know, it's the equivalent of this channel, but centered on parrot

[17:41] <x3nU> irc.perl.org #parrot

[17:41] <ruoso> jnthn: is rakudo autothreading using Tasks in the parrot level?

[17:42] <c-lesh> cool, i'll check it out!

[17:42] <c-lesh> I've been doing some research so that I can finish writing my VM.

[17:43] *** drbean left
[17:43] <colomon> ruoso: almost certainly not yet

[17:43] <c-lesh> Whoa! A camel made out of code on irc.perl.org! What is it supposed to do?

[17:44] <x3nU> just logo, when i said "irc.perl.org" i meant irc network to which you should connect

[17:44] <x3nU> ach, you're using webirc

[17:44] <x3nU> wait

[17:44] <x3nU> i will give you proper link

[17:44] <c-lesh> CTCP?

[17:45] <x3nU> c-lesh: http://wbe02.mibbit.com/?settings=1c154d53c72ad8cfdfab3caa051b30a2&server=irc.perl.org&channel=%23parrot&noServerTab=false&noServerNotices=true&noServerMotd=true&autoConnect=true

[17:45] <x3nU> here you can reach parrot folks

[17:45] <x3nU> c-lesh: that CTCP something meant that i was checking what irc client you were using

[17:45] <x3nU> you are*

[17:46] *** lateau_ left
[17:46] <c-lesh> Thanks!

[17:47] *** mj41 left
[17:47] <c-lesh> they all seem to be out to lunch

[17:48] <colomon> it is virtual new year's day...

[17:48] <ruoso> colomon: it is interesting that the errors I'm getting are somewhat consistent with threading...

[17:48] <c-lesh> haha :O

[17:48] * colomon is watching the rose bowl parade, and looking forward to football

[17:49] <colomon> ruoso: in what way?

[17:50] *** drbean joined
[17:51] *** thou joined
[17:51] <x3nU> c-lesh: on IRC it is normal to wait for reply for pretty long time

[17:51] <x3nU> just ask questions and wait...

[17:51] <c-lesh> did that

[17:51] <c-lesh> i guess many are at work

[17:51] <c-lesh> i work from home, though

[17:51] <ruoso> colomon: in the way that it fails in different points at different runs, and that sometimes it even succeeds

[17:51] <ruoso> but it may be just memory corruption

[17:52] <colomon> yes, memory corruption / GC issues are definitely a current rakudo problem.  :(

[17:52] <c-lesh> personally i detest garbage collection

[17:53] <c-lesh> why not implement something similar to C++ memory management and then have an "memory leaks" cleaned up at the end

[17:54] <colomon> C++ memory management isn't very practical with a lot of the idioms we'd like to use in p6

[17:54] <tadzik> 1) no one wants C++-like memory management 2) there'll be a hell load of those "memory leaks"

[17:54] <c-lesh> instead of having a stack one could just make sure each subroutine has its own memory

[17:54] <colomon> but I have to admit I'm frequently distressed at the side effects of NOT having C++-like memory management

[17:54] <c-lesh> but the interpreter could check for those at the end of its execution and alert the programmer

[17:55] <c-lesh> this was the programmer could fix his/her mistakes

[17:55] <c-lesh> a garbage collector running in a time critical loop is not cool

[17:56] *** Mowah left
[17:59] <ruoso> altough it definitely consistently segfaults in the same point

[17:59] <ruoso> #0  0xf6901c4c in mp_cmp_d () from /home/ruoso/devel/rakudo/install/lib/parrot/3.11.0-devel/dynext/nqp_bigint_ops.so

[17:59] <c-lesh> .so is an assembly file?

[18:00] <ruoso> my bet is rakudo is not built with debug by default

[18:00] *** Mowah joined
[18:00] <colomon> .so is a library file

[18:01] <thou> $ nom if.pl 

[18:01] <thou> > take the white beer and the big yellow cheese from the kitchen and put it under the couch

[18:01] <thou> (["take", ("beer" => ("white",).list.item, "cheese" => ("big", "yellow").list.item), {"prep" => "from", "noun" => ("kitchen" => ().list.item,)}], ["put", ("it" => ().list.item,), {"prep" => "under", "noun" => ("couch" => ().list.item,)}])

[18:01] <colomon> object file library

[18:01] <tadzik> thou: wow, what's that?

[18:02] <colomon> thou++

[18:02] <c-lesh> raduko is running on parrot?

[18:02] <thou> https://gist.github.com/1536817

[18:02] <thou> tadzik: it's a hack :)

[18:02] <colomon> thou: what will you do when "it" has two apparent antecedents?  ;)

[18:02] <thou> i thought it'd be fun to rewrite masak++ 's crypt.pl

[18:02] <tadzik> c-lesh: yes

[18:03] <thou> so this works OK, i could write some Noun class or whatever to make it usable

[18:04] *** MayDaniel left
[18:06] *** zby_home joined
[18:06] *** achromic left
[18:07] <thou> i was thinking about having a 2-pass method: first pass would map each word to a list of possible uses (e.g., "fire the rocket" -> (('fire' => ('transitive verb', 'singular noun')), ('the' => 'definite article'), ('rocket' => ('intransitive verb', 'singular noun'))), and then a 2nd pass to create a tree out of that.

[18:09] <thou> but i don't know how to use a grammar for that. can i use the grammar on a stream of objects instead of characters?

[18:09] <thou> i kind of think not

[18:09] *** tokuhirom joined
[18:18] <colomon> sort tests are making me see red

[18:26] <ruoso> thou: as long as you can implement your stream of objects in terms of the Str API

[18:27] <thou> hmmm

[18:27] *** risou is now known as risou_awy

[18:30] <masak> thou: ooh, rewrite crypt.pl?

[18:30] <masak> in what?

[18:30] <thou> masak, in perl6

[18:30] <thou> just in a different way

[18:30] <ruoso> thou: on the parsing natural languages topic... you do know that besides some very limited cases, this is a dead end, right?

[18:31] <masak> thou: honestly, I've been thinking of rewriting it as well -- I was stupid not to develop it with TDD.

[18:31] <thou> ruoso -- yeah, but i'm thinking of slightly more friendly than most Interactive Fiction

[18:31] <ruoso> i.e.: "fruit flies like bananas"

[18:31] <thou> sue

[18:31] <thou> sure

[18:31] <thou> time flies like an arrow

[18:31] <masak> see http://strangelyconsistent.org/blog/what-i-learned-from-the-june-blogging

[18:31] *** snearch left
[18:31] *** snearch joined
[18:31] <benabik> thou: There's an IF system for the Z-machine (info com) called Inform that has a pretty darn good parser.

[18:32] <ruoso> current trend on natural language processing is neural networks and lots and lots of data

[18:32] <thou> benabik: yeah, i have used TADS and some others, a little bit, that are really good

[18:32] <ruoso> all formally-described-grammar initiative fail too soon on real world usage

[18:32] <fsergot> masak++

[18:32] <thou> anyways, this was mainly just a thing to learn more about perl6 grammars

[18:33] <ruoso> In that case, yes... it's lots of fun... I did that myself for portuguese once :)

[18:33] <thou> and to have fun with a small but non-trivial project :-)

[18:34] <benabik> thou: Inform was put together by someone who did a thesis in natural language processing and his documentation is fairly clear...

[18:34] <thou> really, if i were wanting to make real IF, i should just use one of the existing systems. but i want to play with p6

[18:35] <thou> :-)

[18:35] <benabik> Well, he had a good chapter on how he did the parsing...

[18:35] <thou> cool

[18:35] <benabik> http://inform7.com/learn/papers/

[18:35] <thou> thanks!

[18:35] <benabik> Although none of those are the ones I was thinking of, I think.  Pity.

[18:37] <benabik> Ah!  This is what I was thinking of: http://www.inform-fiction.org/manual/html/s34.html

[18:37] *** awoodland joined
[18:38] *** awoodland left
[18:47] <colomon> niecza: say (1.1,2,NaN,-3.05,0.1,Inf,42,-1e-07,-Inf).sort.perl

[18:47] <p6eval> niecza v13-47-g3171346: OUTPUT«(Inf, -61/20, -Inf, -1E-07, 1/10, 2, 11/10, NaN, 42).list␤»

[18:48] <colomon> :\

[18:48] <colomon> niecza: say (1.1,2,NaN,-3.05,0.1,Inf,42,-1e-07,-Inf).sort({ $^a <=> $^b }).perl

[18:48] <p6eval> niecza v13-47-g3171346: OUTPUT«(-Inf, -61/20, -1E-07, 1/10, 11/10, 2, 42, NaN, Inf).list␤»

[18:49] <thou> benabik: the inform7 stuff is really interesting :-)

[18:50] <colomon> niecza: say (1.1,2,-3.05,0.1,Inf,42,-1e-07,-Inf).sort.perl

[18:50] <p6eval> niecza v13-47-g3171346: OUTPUT«(-61/20, Inf, -Inf, -1E-07, 1/10, 2, 11/10, 42).list␤»

[18:51] <masak> colomon: I can see why you're not entirely pleased, yes.

[18:51] <colomon> masak: with niecza or with the tests?

[18:52] <masak> the test looks OK to me.

[18:52] * colomon is cheesed off at both at the moment

[18:52] <colomon> You can't sort NaN

[18:52] <masak> ;)

[18:52] <masak> no, you can't.

[18:53] <colomon> yet there it is in sort.t

[18:54] <colomon> and defining a sub cmp should have never have an effect on the behavior of sort

[18:56] <benabik> thou: I was less than impressed with it because it's trying to do natural language programming, which I find somewhat irritating.  :-D

[18:56] <masak> colomon: not unless &cmp called dynamically, which it isn't.

[18:57] <thou> yeah, i guess if it makes sense anywhere, it's in a language for writing IF

[18:59] <masak> or SHRDLU.

[19:14] *** tokuhirom left
[19:14] *** cognominal left
[19:16] *** cognominal joined
[19:17] <colomon> masak: what do you mean by dynamically?

[19:17] <colomon> (sorry to drop out there, I've got a three-year-old tackling me atm.)

[19:18] <masak> :)

[19:19] <colomon> now he's back to playing with legos

[19:20] <masak> colomon: just like you can declare dynamically scoped variables, so you can define dynamically scoped subs.

[19:21] <masak> which can then be overridden, and sort would find the overriding variant.

[19:21] <masak> except &cmp isn't dynamical that way.

[19:22] <colomon> ah, okay.

[19:22] <colomon> more importantly, &cmp has nothing whatsoever to do with sort

[19:23] <masak> right :)

[19:23] *** arlinius left
[19:33] <colomon> huh.  next sort question: why should sort(@a) work?

[19:33] <kshannon> Ah, rakudo is depending on find_method dying with an appropriate error message rather than return NULL for quite a few things,  but that's not the correct interface for VTABLE_find_method which should return NULL instead.  There are quite a few places in the rakudo source which use VTABLE_find_method instead of STABLE(obj)->find_method;  I'm currently patching VTABLE_find_method to catch exceptions and return NULL to play nice with non-6model parrot stuff (in

[19:34] *** c-lesh left
[19:34] <kshannon> Jeez, I didn't realize the line had got that long :(

[19:34] <colomon> according to S32 containers, sort's first argument should be an ordering

[19:34] <colomon> oversight in S32?

[19:35] <kshannon> colomon: or the slurpy block.

[19:36] <kshannon> whoops, that's the method...

[19:40] <colomon> nom is doing 

[19:40] <colomon> multi sub sort(*@values)      {

[19:40] <colomon>     @values.at_pos(0).^does(Callable)

[19:40] <colomon>         ?? do { my $cmp := @values.shift; @values.sort($cmp) }

[19:40] <colomon>         !!  @values.sort;

[19:42] <colomon> guess I can make niecza do that too, and maybe TimToady can fix the spec.  (Or tell us to stop it!)

[19:44] <flussence> .oO( wouldn't it make more sense to use 2 multis instead of a ternary op there? )

[19:45] *** Vlavv` joined
[19:47] *** drbean left
[19:49] *** Vlavv left
[19:52] <colomon> niecza's sort really leaves a lot to be desired

[19:53] <colomon> since it doesn't appear to actually sort.  :(

[19:53] *** drbean joined
[19:54] <masak> yeah, that's usually a minimal requirement.

[19:55] <masak> you could consider it part of the "contract" of the &sort routine.

[19:55] <colomon> this is really frustrating -- sort doesn't work right, and the tests in sort.t are insane

[19:55] <colomon> is ~(42,).sort: { 0 }, "42"

[19:55] <colomon> { 0 }

[19:55] <colomon> ?

[19:55] <masak> 0 is a valid output from a comparator routine.

[19:55] *** Moukeddar joined
[19:55] <sorear> good * #perl6

[19:56] <masak> it means, essentially, "objects $^a and $^b are equivalent"

[19:56] <colomon> masak: it's valid output, but no current compiler can handle a 0-arg comparator

[19:56] <tadzik> good star sorear 

[19:56] <colomon> masak: and with good reason: wtf does a 0-arg comparator mean?

[19:56] <masak> good asterisk, sorear 

[19:56] <colomon> good multiplying, sorear

[19:56] <masak> colomon: aye, that seems slightly insane.

[19:57] <tadzik> now we see how #perl6 users pronounce '*'

[19:57] <masak> "here's the obj..." -- "ZERO!"

[19:57] * geekosaur reminded of haskell-cafe thread where someone sked about pathological comparators and he suggested _ _ -> GT

[19:58] <colomon> masak, geekosaur: the really crazy thing here is that the comparator has nothing to do with the point of the test, according to the comments.

[19:58] <geekosaur> (amd all good p6ers should know that * is prononced Whatever...)

[19:58] <colomon> geekosaur++

[19:58] <colomon> perl6: say (42,).WHAT

[19:58] *** mj41 joined
[19:58] <p6eval> rakudo a7fd89, niecza v13-47-g3171346: OUTPUT«Parcel()␤»

[19:58] <p6eval> ..pugs b927740: OUTPUT«Array␤»

[19:59] <colomon> nom: say Parcel ~~ Positional

[19:59] <p6eval> nom a7fd89: OUTPUT«Bool::True␤»

[20:00] <colomon> I think Henry is trying to figure out how to piledriver me.

[20:02] <colomon> now he's lying on me, trying to make me hold a lego, and chanting "Rock Island" from The Music Man

[20:02] <colomon>  

[20:03] <PerlJam> btw, is there a way to "unpack" a parameter and name it?    sub foo ([$head, *@tail]) {} will give me the parts, but how do I refer to the aggregate?  sub foo (@blah($head, *@tail)) {} is suggested by the tree node example

[20:04] <PerlJam> er, perhaps @blah[$head, *$tail]

[20:04] <masak> both should work, I think.

[20:04] <dalek> roast: 801c909 | (Solomon Foster)++ | S32-list/sort.t:

[20:04] <dalek> roast: Trying to make less pathological, plus light fudging for niecza.

[20:04] <dalek> roast: review: https://github.com/perl6/roast/commit/801c909ddf

[20:10] *** Moukeddar left
[20:11] *** drbean left
[20:14] <dalek> niecza: e224a62 | (Solomon Foster)++ | lib/CORE.setting:

[20:14] <dalek> niecza: Make sub sort recognize a callable first argument.

[20:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e224a62d43

[20:17] *** wolfman2000 joined
[20:17] *** drbean joined
[20:17] <masak> wolfman2000! \o/

[20:17] <wolfman2000> Afternoon

[20:17] <masak> evenin'

[20:18] <colomon> sorear: if you grab my latest patches, you can try sort.t and see where it is giving incorrect answers.  :(

[20:21] <masak> 27 people are now signed up for p6cc.

[20:22] <wolfman2000> p6cc? Alright, what am I behind on this time?

[20:22] <tadzik> :)

[20:22] <masak> wolfman2000: http://strangelyconsistent.org/blog/the-2011-perl-6-coding-contest

[20:22] <tadzik> . o O ( 28 people are now signed up for p6cc )

[20:22] <masak> :P

[20:23] <masak> as heard on twitter, "solve great problems, win great books".

[20:24] <felher> 28, wow. :)

[20:25] <masak> well, 27 outside of tadzik's thought bubble :)

[20:25] <wolfman2000> I'll pass. Sad to say, but I don't know how to solve all of these.

[20:25] <tadzik> I don't know either

[20:25] <felher> Oh, ah, okay, just 27, thats _much_ less impressive ;P

[20:25] <thou> anyone know a blog, etc. interpretation of http://perlcabal.org/syn/S12.html#Construction_and_Initialization :  when to use new, CREATE, BUILD, how they fit together....

[20:25] *** alvis joined
[20:25] <tadzik> what fun is it to solve things you know how to solve? :)

[20:26] <masak> moritz and I didn't choose problems that we knew immediately how to solve :)

[20:26] <tadzik> that's something to put in the new perldoc perloo

[20:26] <wolfman2000> fair enough

[20:26] <wolfman2000> Still...first thing I need to do is re-get perl 6 on here if I am to even consider it

[20:28] *** molaf joined
[20:28] <masak> do that regardless. :)

[20:29] *** PacoAir left
[20:29] * colomon just got charged $266 for a hammer made out of legos.

[20:29] <x3nU> sounds fun

[20:30] * masak .oO( and every problem looks like a little LEGO nail... )

[20:30] *** snearch left
[20:30] <tadzik> my first thought was: colomon has built a lego hammer which is illegal, and he got a ticket for that

[20:30] <tadzik> I've built a Lego Pirate Ship, I guess they're already after me

[20:31] <tadzik> good that we didn't build Lego Pirate Bay too

[20:31] <colomon> my little guy appears to be a shrewd businessman.  but not much of a hammer-maker, yet.

[20:32] *** packetknife joined
[20:34] <thou> e.g., i'm thinking of something like:   class Car is Word does Scenery { has $.word = 'car'; ... }; if Word.^find("car") -> $word { say "I recognize $word"; }  # Do I implement Word.BUILD to add 'car' to a hash of known words, so I can implement Word.^find()?

[20:34] <masak> tadzik: LEGO Pirate Bay, enabling users to share material using LEGO-bittorrent :)

[20:35] <masak> dang, that pun only works in Swedish... :)

[20:35] <masak> phenny: sv en "bit"?

[20:35] <phenny> masak: "piece" (en to en, translate.google.com)

[20:36] <thou> hmmm, now that i spent the time to write that question, i'm thinking i might just want my Thing $car does Scenery .= new(:word('car'));

[20:36] <tadzik> hehe

[20:38] *** pothos left
[20:39] *** pothos_ joined
[20:39] *** y3llow_ joined
[20:39] *** y3llow left
[20:41] *** y3llow_ left
[20:41] *** drbean left
[20:41] *** y3llow joined
[20:42] *** pothos_ left
[20:42] *** pothos joined
[20:43] <thou> still, i'm not sure even in class Thing where to implement storing the word; do I write Thing method new(|$args) { callsame; # Now get :$word out of $args and stuff it into %vocabulary } ?

[20:43] <thou> i have a feeling i should look at some example code :-)

[20:43] *** y3llow left
[20:44] *** y3llow joined
[20:44] *** pothos left
[20:45] *** pothos joined
[20:46] <thou> i see masak avoided this question with something like:  grass      => Grass.new(:name<grass>),

[20:46] *** PacoAir joined
[20:46] *** sudokode left
[20:48] *** drbean joined
[20:52] *** proller joined
[20:52] <masak> thou: could also be solved using MOP and reflection, but I didn't want to do pull in that kind of heavy machinery.

[20:53] <thou> i think what i want is simple. i'm going to write a quick example of it in P5. if i can remember how to do that. :-)

[20:56] <masak> :)

[21:00] <colomon> niecza: (2, 45, 6, 1, 3).sort.say

[21:00] <p6eval> niecza v13-47-g3171346: OUTPUT«1 2 3 6 45␤»

[21:00] <colomon> niecza: (2, 45, 6, 1, 3).sort(-> $a, $b { $b <=> $a }).say

[21:00] <p6eval> niecza v13-47-g3171346: OUTPUT«45 6 3 2 1␤»

[21:02] *** drbean left
[21:04] <colomon> niecza: { say $^b; say $^a; }("hello", "world")

[21:04] <p6eval> niecza v13-47-g3171346: OUTPUT«world␤hello␤»

[21:05] <masak> niecza: { &^c(&^a, &^b) }("hello", "world", &say)

[21:05] <p6eval> niecza v13-47-g3171346: OUTPUT«helloworld␤»

[21:05] <masak> \o/

[21:05] <tadzik> nice

[21:07] *** spine left
[21:09] *** drbean joined
[21:18] *** alvis left
[21:20] <sorear> good * #perl6 ... for real this time

[21:21] <masak> no-one expects the sorear inquisition!

[21:21] <sorear> masak: I think sleep as a prefix is a horrid fossil

[21:21] <masak> sorear: yeah; I don't really see what the fuss is about there.

[21:22] <tadzik> it just suprised me, reading the commit

[21:23] <sorear> TimToady: should $*IN exist at compile time?

[21:23] <sorear> jnthn!!!

[21:24] <colomon> niecza: (1.1,2,-3.05,0.1,Inf,42,-1e-07,-Inf).sort.say

[21:24] <p6eval> niecza v13-49-ge224a62: OUTPUT«-3.05 Inf -Inf -1E-07 0.1 2 1.1 42␤»

[21:25] <masak> sorear: jnthn's gone again... but he'll be back soon.

[21:25] <colomon> niecza: (1.1,2,-3.05,0.1,Inf,42,-1e-07,-Inf).sort.say

[21:25] <p6eval> niecza v13-49-ge224a62: OUTPUT«-3.05 Inf -Inf -1E-07 0.1 2 1.1 42␤»

[21:27] <sorear> colomon: last time I looked at sorting in niecza, the main issue that came up was that niecza doesn't use a "stable sort"

[21:28] <colomon> sorear: look again at those numbers.  that's not a sort at all

[21:31] <sorear> What.

[21:32] <sorear> niecza: say ('a'..'z').pick(*)

[21:32] <p6eval> niecza v13-49-ge224a62: OUTPUT«a v c g n s e f o z d h k l b r t q i y w m p x u j␤»

[21:32] <sorear> niecza: say ('a'..'z').pick(*).sort

[21:32] <p6eval> niecza v13-49-ge224a62: OUTPUT«a b c d e f g h i j k l m n o p q r s t u v w x y z␤»

[21:32] <colomon> -3.05 Inf -Inf -1E-07 is not sensible, either with numeric or string sort

[21:34] <sorear> I wonder why Str sorting seems to work

[21:34] <colomon> it seems like half the sorts work

[21:35] <colomon> errrr, 2/3rds by the sort.t count

[21:35] <sorear> niecza: say -3.05 cmp Inf

[21:35] <p6eval> niecza v13-49-ge224a62: OUTPUT«-Inf␤»

[21:35] <sorear> niecza: say -3.05 cmp -Inf

[21:35] <p6eval> niecza v13-49-ge224a62: OUTPUT«Inf␤»

[21:35] <sorear> niecza: say (-3.05) cmp Inf

[21:35] <p6eval> niecza v13-49-ge224a62: OUTPUT«-Inf␤»

[21:35] <colomon> that's one thing I was wondering about: is your sort routine okay with values other than -1, 0, and 1 internally?

[21:36] <colomon> niecza: say (1..100).pick(5).sort

[21:36] <p6eval> niecza v13-49-ge224a62: OUTPUT«4 24 52 73 98␤»

[21:38] <colomon> niecza: say (1..100).pick(5).sort({ $^b <=> $^a })

[21:38] <p6eval> niecza v13-49-ge224a62: OUTPUT«99 59 52 48 35␤»

[21:38] <colomon> niecza: say (1..100).pick(5).sort({ $^b cmp $^a })

[21:38] <p6eval> niecza v13-49-ge224a62: OUTPUT«86 62 21 20 13␤»

[21:38] <colomon> that's working fine.

[21:38] <sorear> looks like it's using (int) internally

[21:38] <sorear> so if <cmp> returns 0.2, that gets counted as 0

[21:38] <colomon> that would explain a lot

[21:40] <sorear> also, C# thinks that (int) double.PositiveInfinity == int.MinValue

[21:40] *** kaare_ left
[21:40] <colomon> that's a bad combination, indeed.

[21:41] <colomon> I just checked the spec, and Comparator says "negative/zero/positive", not -1 0 1, so infix:<cmp> seems okay

[21:43] <colomon> btw, as I read it, zero-argument "comparators" are not allowed.

[21:46] <colomon> the given types listed for Ordering are Comparator (arity 2), KeyExtractor (arity 1), OrderingPair (one of each of the two prior, as a Pair), a Signature, or a Whatever

[21:47] <sorear> niecza: for 0, 0.5, 0.5, :x, 0, :x -> $x, $y { say $x cmp $y } # look, non-transitive

[21:47] <p6eval> niecza v13-49-ge224a62: OUTPUT«-0.5␤Unhandled exception: Attempted to access slot key of type object for Pair␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1381 (Pair.Str @ 3) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/li…

[21:54] <dalek> niecza: e6a9ddc | sorear++ | lib/Kernel.cs:

[21:54] <dalek> niecza: Fix sorting of numbers differing by non-integral amounts

[21:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e6a9ddc670

[21:54] <dalek> niecza: d921607 | sorear++ | lib/CORE.setting:

[21:54] <dalek> niecza: Tweak cmp to be transitive with mixed number/non-number data

[21:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d92160757d

[21:57] <colomon> sorear++

[22:00] <kshannon> BLOODY SEGFAULTS!!  AAARRGGHH!!!!!!

[22:01] <colomon> niecza: say { $^a cmp $^b } ~~ Callable

[22:01] <p6eval> niecza v13-49-ge224a62: OUTPUT«Bool::True␤»

[22:02] *** snearch joined
[22:02] <colomon> niecza: say { $^b <=> $^a }(1, 10)

[22:02] <p6eval> niecza v13-49-ge224a62: OUTPUT«1␤»

[22:02] <colomon> niecza: say { $^a <=> $^b }(1, 10)

[22:02] * masak hugs kshannon 

[22:02] <p6eval> niecza v13-49-ge224a62: OUTPUT«-1␤»

[22:03] <masak> kshannon: if they're reproducible, please report them.

[22:06] <kshannon> It's to do with my exceptions catching patch for VTABLE_find_method for nqp https://github.com/perl6/nqp/pull/25

[22:07] <kshannon> and I think I just found the reason.  I need to somehow peel the runloops back to where they were on entry...

[22:09] <masak> kshannon++

[22:09] <masak> 'night, #perl6

[22:09] *** snearch left
[22:10] *** sayu joined
[22:11] <tadzik> g'night masak 

[22:12] *** icwiener_ left
[22:13] <wolfman2000> Hmm...any reason that it looks like the last Rakudo release was around July of last year? I guess I was expecting something more...recent.

[22:13] <sorear> sounds like you might be looking at Rakudo Star

[22:13] <wolfman2000> I am.

[22:13] <sorear> Rakudo releases are monthly

[22:14] <sorear> Star was something totally different

[22:14] <wolfman2000> Which do you recommend?

[22:15] *** munchor|afk joined
[22:15] *** munchor|afk left
[22:16] <sorear> dunno, I've never used star

[22:18] <tadzik> wolfman2000: at the moment I'll recommend the monthly release

[22:18] <tadzik> the new Star will probably happen sometime this month

[22:18] <wolfman2000> anyone want to try to recommend I just go straight to source?

[22:19] <colomon> going straight to the source works quite well, IMO

[22:20] <wolfman2000> at least I'm used to working with source

[22:23] *** proller left
[22:24] *** pothos left
[22:24] *** ruoso left
[22:24] *** tokuhirom3 left
[22:24] *** fhelmberger left
[22:24] *** athomason left
[22:24] *** TimToady left
[22:24] *** ranguard left
[22:25] *** pothos joined
[22:25] *** tokuhirom3 joined
[22:25] *** ruoso joined
[22:25] *** fhelmberger joined
[22:25] *** athomason joined
[22:25] *** TimToady joined
[22:25] *** ranguard joined
[22:25] *** pothos left
[22:25] *** molaf left
[22:25] <kshannon> WooHoo! free_runloop_jump_point FTW!

[22:25] *** pothos joined
[22:29] *** orafu left
[22:30] *** orafu joined
[22:30] *** drbean left
[22:35] *** drbean joined
[22:36] *** packetknife left
[22:36] <wolfman2000> t/01-sanity/99-test-basic.t ........ Dubious, test returned 1 (wstat 256, 0x100)  <-- felt I should report it

[22:40] <kshannon> What happens if you run that test by itself?

[22:41] <wolfman2000> kshannon: I forgot how to run individual tests by themselves.

[22:41] <kshannon> make t/01-sanity/99-test-basic.t

[22:41] *** ruoso left
[22:42] <wolfman2000> http://pastie.org/3115020

[22:42] *** orafu left
[22:45] <kshannon> Ooops, that's from tadzik-- 5b58e03 Cleanup Test.pm

[22:45] <wolfman2000> I have plenty to relearn now

[22:47] *** ruoso joined
[22:47] *** sayu left
[22:52] <kshannon> Fixed. https://github.com/rakudo/rakudo/pull/51

[22:53] <wolfman2000> Do I just git pull and then remake? Or do I have to configure again?

[22:55] <kshannon> Well I don't have access to the rakudo repository yet, so you'll have to "git pull git://github.com/KrisShannon/rakudo.git add-back-reasonless-skip"

[22:55] <tadzik> oh, gosh

[22:55] <tadzik> merging that now

[22:56] <tadzik> done

[22:56] <wolfman2000> Perhaps some of this should be explained on the how-to-get-rakudo page

[22:56] <dalek> rakudo/nom: 076bca2 | (Kris Shannon)++ | lib/Test.pm:

[22:56] <dalek> rakudo/nom: Add back argumentless skip to lib/Test.pm

[22:56] <dalek> rakudo/nom: 

[22:56] <dalek> rakudo/nom: t/01-sanity/99-test-basic.t breaks without it

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/076bca291d

[22:56] <dalek> rakudo/nom: ea03112 | tadzik++ | lib/Test.pm:

[22:56] <dalek> rakudo/nom: Merge pull request #51 from KrisShannon/add-back-reasonless-skip

[22:56] <dalek> rakudo/nom: 

[22:56] <dalek> rakudo/nom: Add back argumentless skip to lib/Test.pm

[22:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ea0311205d

[22:56] <wolfman2000> either way, glad I could help

[22:56] <kshannon> Heh.  OK,  now you can just git pull.

[22:57] <kshannon> no remake needed as it just touches lib/Test.pm

[22:57] <tadzik> which gets compiled to lib/Test.pir

[22:58] <tadzik> at the end of 'make', so that should be fast

[22:58] <kshannon> make test will automatically rebuild the lib/Test.pir for you.

[23:01] <wolfman2000> all tests successful

[23:02] <kshannon> \o/

[23:02] <wolfman2000> I'll relearn parts of the language proper after some evening activities

[23:13] <dalek> nqp: 390af1f | (Kris Shannon)++ | src/pmc/sixmodelobject.pmc:

[23:13] <dalek> nqp: Catch exceptions in VTABLE find_method

[23:13] <dalek> nqp: 

[23:13] <dalek> nqp: The sixmodel VTABLE find_method calls the find_method

[23:13] <dalek> nqp: in the containers STABLE which will throw instead of

[23:13] <dalek> nqp: returning NULL if it can't find the method.

[23:13] <dalek> nqp: 

[23:13] <dalek> nqp: Anything which is calling the VTABLE find_method is not

[23:13] <dalek> nqp: going to be expecting an exception so catch any exception

[23:13] <dalek> nqp: and return NULL.

[23:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/390af1fd14

[23:13] <dalek> nqp: b9c26af | (Kris Shannon)++ | src/pmc/sixmodelobject.pmc:

[23:13] <dalek> nqp: May also need to peel runloops after catching an exception

[23:13] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b9c26afc60

[23:14] *** PacoAir_ joined
[23:14] *** PacoAir left
[23:14] *** PacoAir_ is now known as PacoAir

[23:14] * japhb finally catches up with backlogging

[23:14] <kshannon> That probably should have read "Anything **outside of 6model** which is calling the VTABLE find_method is not going to be expecting an exception so catch any exception and return NULL"

[23:15] <sorear> o/ japhb

[23:16] <kshannon> The 6model stuff in nqp and the rakudo nom code all seem to expect VTABLE_find_method to possibly throw.

[23:16] <kshannon> The rakudo nom Failure type depends on it for how it works :(

[23:17] *** PacoAir left
[23:18] <japhb> sorear, apropos to the discussions re: VM performance, do you feel that you have already found most of the big (> 100%) performance boosts available for any Perl 6-on-mono implementation, or are there still significant areas that you have not researched/implemented?  If you've got all the really big ones, what about medium-level (>10%) boosts?  Is that still an area ripe with targets?

[23:19] <sorear> japhb: there are definitely specific cases left where there is considerable room for improvement.

[23:20] <japhb> sorear, Ah, fair enough.

[23:20] *** zby_home left
[23:25] *** molaf joined
[23:28] <colomon> ack.  I'm an idiot

[23:34] *** mj41 left
[23:38] *** Mowah left
[23:40] *** Trashlord left
[23:47] *** orafu joined
[23:57] *** cognominal left
[23:58] <thou> here's an example of using Moose BUILD() to take action during object creation; how to do this in rakudo nom?

[23:58] <thou> https://gist.github.com/1552694

[23:58] <benabik> submethod BUILD, IIRC

[23:59] *** cognominal joined
[23:59] <thou> i guess i'm not sure how to access the args, and it seems the object isn't created yet when submethod BUILD is called?

[23:59] <thou> https://gist.github.com/1552700

