[00:12] *** cognominal left
[00:13] *** tokuhiro_ left
[00:14] *** cognominal joined
[00:14] *** tokuhiro_ joined
[00:18] *** kst left
[00:18] *** tokuhiro_ left
[00:19] *** ihavetoes_ joined
[00:21] *** atrodo left
[00:21] *** atrodo joined
[00:21] <ihavetoes_> perl6: say 3;

[00:21] <p6eval> rakudo d8e7b6, niecza v19-13-g442e075: OUTPUT«3␤»

[00:22] *** ihavetoes_ left
[00:25] *** am0c joined
[00:39] *** Coleoid joined
[00:45] *** kst joined
[00:45] *** seldon left
[00:45] *** am0c left
[00:50] *** mikemol left
[00:55] *** odoacre left
[01:10] *** sudokode joined
[01:12] *** sftp left
[01:13] *** sftp joined
[01:14] *** ponbiki joined
[01:16] *** scott___ joined
[01:19] *** [particle] joined
[01:22] *** odoacre joined
[01:22] *** Gruber joined
[01:22] *** Gruber is now known as Guest96273

[01:23] *** samlt joined
[01:26] *** fgomez joined
[01:26] *** mikemol joined
[01:26] *** Guest44870 left
[01:31] *** odoacre left
[01:38] *** kst left
[01:39] *** odoacre joined
[01:44] *** geekosaur joined
[01:44] *** rafl joined
[01:46] *** am0c joined
[01:47] *** odoacre left
[01:47] *** odoacre joined
[01:54] *** aloha joined
[02:04] *** jaldhar joined
[02:08] *** quietfanatic left
[02:18] *** jaldhar left
[02:20] *** jaldhar joined
[02:45] *** kst joined
[02:54] *** atrodo left
[04:09] *** kaare__ joined
[04:52] *** birdwindupbird joined
[04:56] *** stephenlb left
[04:56] *** am0c left
[05:01] *** larks joined
[05:07] *** am0c joined
[05:12] *** jeffreykegler joined
[05:13] *** jeffreykegler left
[05:21] *** stephenlb joined
[05:23] *** kaleem joined
[06:02] *** wtw joined
[06:18] *** libertyprime left
[06:20] *** libertyprime joined
[06:26] *** zhutingting joined
[06:27] *** Su-Shee joined
[06:27] <Su-Shee> good morning everyone.

[06:28] <tadzik> hey hey Su-Shee 

[06:31] <moritz> \o *

[06:35] <sorear> o/

[06:36] <Su-Shee> moritz: are you throwing a snowball at me in JULY? ;)

[06:37] <moritz> Su-Shee: I'm just wild-card snowballing everyone :-)

[06:39] <Su-Shee> o/* <- I'm going to use that in winter. ;)

[06:56] *** nodmonkey joined
[07:04] *** brrt joined
[07:08] *** stephenlb left
[07:24] *** plobsing joined
[07:30] *** telex left
[07:33] *** telex joined
[07:41] *** thou joined
[07:42] *** BigBear joined
[07:45] *** mucker joined
[07:50] *** thou left
[07:50] *** thou joined
[07:53] *** fhelmberger joined
[07:53] <mathw> Morning o/

[07:53] <tadzik> hello mathw 

[07:54] <mathw> I have to find out some Perl 5-y stuff for work (unfortunately Perl 6 doesn't display the required performance characteristics yet), does anybody know the right place for me to look for database access best practice?

[07:56] <tadzik> http://bobby-tables.com/perl.html :)

[07:56] <Su-Shee> mathw: you mean other than using DBI? (or DBIx::Class if you prefer an ORM)

[07:57] <mathw> tadzik: that's a good start, fortunately I knew that bit already :)

[07:57] <tadzik> :)

[07:57] <moritz> the most important advise is 1) don't do stupid stuff 2) use indexes wisely

[07:57] <mathw> Su-Shee: I've always just used DBI before, but I'm looking at this blank screen here and wondering if the mess I always end up in is actually necessary

[07:59] <Su-Shee> mathw: well I don't have a mess usally, so I'd probably say: "no, it's not". but you use DBI, yes and then your application somewhat decides what else you really need - some SQL abstraction, something more ORM-ish and so on.. there isn't really a "do this that way" in the end (set aside "avoid injections" ;)

[07:59] <mathw> believe me, avoiding injections is always at the top of my priority list :)

[07:59] *** BigBear left
[08:00] <mathw> what's the performance overhead with DBIx::Class?

[08:00] <moritz> small enough that the bottleneck is still mostly the DB

[08:00] *** thou left
[08:00] <mathw> awesome

[08:00] <Su-Shee> mathw: measure it? after you made sure that you get your selects etc right?

[08:00] <moritz> though you have to be a bit careful to prefetch related objects that you're going to need anyway

[08:01] <moritz> otherwise you're setting off a ton of requests

[08:01] <moritz> but DBIx::Class has an awesome environment variable DBIC_TRACE=1

[08:01] <moritz> it shows all the DB quries fired

[08:01] <moritz> and it makes it pretty obvious where to add prefetches

[08:01] <Su-Shee> it has also quite good documentation what ORM construct gets translated into what kind of SQL

[08:02] <mathw> that's good

[08:02] <mathw> I've used entity framework a lot, and that can be a tad opaque without external sniffer tools to figure out what SQL's being generated

[08:03] <mathw> which is usually the key to figuring out why some query is unexpectedly slow

[08:03] <mathw> because the framework goes and generates 10,000 different selects when it could've done it in just one if you'd given it a bit more of a hint

[08:04] <moritz> well, DBIC_TRACE really helps there

[08:04] <mathw> sounds like it

[08:04] <mathw> I'll look into it, thanks

[08:04] <mathw> sorry about co-opting the channel to talk about Perl 5

[08:05] *** thou joined
[08:05] <Su-Shee> well so far I didn't really like treating SQL in an object manner so I tend to actually try to fetch data mostly and return it in a handy, meaningful way. I usally think more about what part I want to leave to the db and how much I put into the application level code...

[08:05] <Su-Shee> mathw: well the same problem would apply to a perl6 DBI versus DBIx::Class ...

[08:06] <Su-Shee> do you want ORM or not.

[08:06] *** yves_ joined
[08:06] <mathw> I oscillate wildly between the two, usually when one approach causes me headaches that wouldn't be caused by the other

[08:07] <mathw> For this particular application, it may well be easier just to tuck some plain DBI code away in its own module. All the database access and update code in one place and out of the way so there's not SQL scattered all over

[08:08] <Su-Shee> mathw: well not scattering sql all over is more of a discipline question. :) 

[08:08] <moritz> aye

[08:08] <moritz> if you use DBIx::Class, you can also scatter queries all over the code base

[08:09] <mathw> There is that :)

[08:09] <moritz> it's not directly SQL, but it still reflects the DB structure very closely

[08:09] <mathw> Can you tell that the code this is based on is a digusting mess?

[08:09] <Su-Shee> mathw: how do you mean?

[08:10] <moritz> so you need some discipline to put such queries in methods in the result or resultset classes

[08:10] <brrt> oh, there is a (there are many) solution to scattering sql queries

[08:10] <Su-Shee> mathw: if I see a DB related call somewhere within handling buttons to display whether or not userlevel X can have this interaction, I know the architecture is a mess.

[08:12] <mathw> The reassuring thing I'm getting from this conversation is that what I should be doing is exactly what I'd do in any other language.

[08:13] <Su-Shee> mathw: good architecture and good code is good architecture and good code in any of the code cultures...

[08:14] <Su-Shee> mathw: I personally put an effort into loose coupling which I have come to value a lot because it makes throwing away some old thingie and plugging in something new easier. So I try to do things not being tightly integrated with a lot of hidden magic.

[08:15] <brrt> what about the 'adapter pattern' (my own device)

[08:15] <Su-Shee> So I would keep my SQL relatively standing on its own so if in doubt, I could switch from let's say Perl DBI to something else.

[08:15] <moritz> loose coupling also helps a great deal with testing

[08:15] <brrt> its a class that reads a file of queries, and converts them into callable methods

[08:15] <brrt> i'll gist it

[08:15] <Su-Shee> brrt: I'm not a fan of pattern, I use and see value in maybe two or three

[08:16] <brrt> Su-Shee: i am fan of pattern because it can help you think about code abstractly

[08:16] <mathw> a lot of formalised patterns just say to me 'you're usin ghte wrong programming language', but sometimes pattern-y things are useful

[08:16] <Su-Shee> moritz: on top of that, yes. but it makes coding harder, you really have to understand how to pass things from A to B properly.

[08:17] <mathw> loose coupling is definitely the way to do Stuff.

[08:17] <brrt> then you are using the patterns wrongly

[08:17] <brrt> or, the wrong patterns

[08:17] <brrt> :-)

[08:17] <moritz> Su-Shee: OTOH it makes coding easier, because you only have to know the interface, not the whole layer

[08:17] <Su-Shee> brrt: you realize that in many dynamic languages most of the pattern are useless at best and really just "bad code" at worst?

[08:18] <Su-Shee> moritz: I've recently played with Mongrel2, which forced me into "no coupling" thinking, really interesting lessons.

[08:21] <brrt> https://gist.github.com/3081997

[08:21] <brrt> oh, yes, if think that all patterns are the patterns of 1995

[08:22] <brrt> dynamic languages need / use new patterns

[08:22] <brrt> its just that most of them are so short they are called idioms instead :-)

[08:23] <brrt> or bigger things, such as Active Record

[08:23] <brrt> (yes, thats php you see there, so sue me)

[08:23] * moritz sues brrt 

[08:23] <tadzik> hugme: sue brrt

[08:24] <Su-Shee> unless a concept or idea doesn't give me a real elegant simplification AND more flexibility, I'm not convinced. 

[08:24] <Su-Shee> and no, I'm not taking one without the other. so "more flexibility" for the price of "complicating things": no. 

[08:25] <moritz> http://hoelz.ro/blog/another-look-at-perl-6

[08:25] *** dakkar joined
[08:26] <jnthn> morning o/

[08:27] <moritz> \o jnthn

[08:27] <mathw> IJLTS: Visitor Pattern

[08:28] <brrt> i think there are lot of concepts and / or ideas that will simplify things

[08:29] <brrt> what about parallelisation?

[08:29] <brrt> there a lot of 'patterns' that hugely simplify things

[08:29] <brrt> map/reduce is perhaps the most hyped

[08:30] <brrt> but the 'unix process' is a pattern of sorts, too

[08:30] * moritz thinks about a completely generic visitor

[08:31] <moritz> sub visit(:$start, :&pre, :&post, :&children, :&assemble)  or so

[08:31] *** mucker left
[08:31] <moritz> $start is the root of the tree

[08:31] <moritz> &pre the code be run pre-order

[08:31] <moritz> &post is post-order

[08:31] <mathw> I always felt visitor is just a substitution for an insufficiently powerful programming language. Maybe that's because I learned it in Java.

[08:31] <Su-Shee> I usally think about how I can get rid of more code, throw away another module and make things simpler. ;) 

[08:31] <moritz> children($start) gives $start's children

[08:32] <moritz> mathw: well, Pod::To::{HTML,Text,$other_formats} need to visit all Pod nodes to do their work

[08:32] <Su-Shee> mathw: there's an interesting presentation by peter norvig why 17 of the 23 orginal pattern are obsolete in lisp, dylan or smalltalk... which probably means it applys to perl6 as well... 

[08:33] <mathw> moritz: that's a tree fold though, not a visitor pattern. visitor is a substitution for multiple dispatch.

[08:33] <moritz> mathw: oh

[08:33] <moritz> mathw: then my terminology is off :-)

[08:33] <mathw> to be fair, if I'd needed to name what you just talked about i'd probably have called it visiting

[08:33] <moritz> I never read the Gang of Four book

[08:34] <mathw> Su-Shee: I would imagine so, yes. Many of them are also obsolete in other good programming languages

[08:34] *** BigBear joined
[08:35] * mathw trawls the depths of his brain to remember how to write Perl 5 objects

[08:35] <Su-Shee> moritz: ignore it. it's really mostly irrelevant in our culture. the orginal book by alexander is really cool though and also the "book in the middle" by richard gabriel ("patterns of software hmhmhm") is very valuable to read (he's the lucid emacs lisp guy who wrote the "worse is better" articles - also a very good read.)

[08:35] <Su-Shee> mathw: use Moose;

[08:35] *** daxim joined
[08:36] <mathw> Su-Shee: succinct and to the point :)

[08:36] <mathw> actually I've never used Moose

[08:36] <brrt> mathw: Package foo; sub new { bless {}, shift; } 

[08:36] <moritz> Su-Shee: I hadn't planned on reading it

[08:36] <mathw> brrt: this is my usual approach :)

[08:36] <brrt> mine as well

[08:36] <brrt> dumb, fast, highly effective

[08:37] *** fgomez left
[08:37] <sorear> mathw: IJLTS eh.

[08:39] <mathw> sorear: call me a lazy typist

[08:41] <tadzik> I can't imagine when not using Moose is the Lazy approach :)

[08:41] <sorear> actually, I'm going to call you a probable zephyr user and/or mit alum

[08:41] <mathw> sorear: neither

[08:42] <mathw> tadzik: not using Moose probably gets out of control fairly quickly. I'm now reading the Moose docs

[08:42] <sorear> sleep&

[08:42] <arnsholt> I started using Moose (or actually Moo) for my most recent Perl 5 project

[08:42] <mathw> argh no Moose

[08:42] <arnsholt> I'm very happy with it so far

[08:43] <tadzik> mathw: get used to it, p5-mop is coming, want it or not :)

[08:43] <daxim> DO WANT!

[08:43] <moritz> I'm sure there will be lighter-than-moose OO solutions baesd on p5-mop

[08:43] <tadzik> see https://github.com/stevan/p5-mop/blob/master/t/000-examples/002-basic-example.t

[08:43] <moritz> (if nobody else does, I'll provide one :-)

[08:43] <tadzik> does that look good :]

[08:44] <mathw> oh

[08:44] <mathw> my

[08:44] <tadzik> yes. This test does run

[08:44] <moritz> tadzik: but that looks just like a class, not "real" MOP

[08:45] <tadzik> yes

[08:45] <mathw> I'm going to assume it's just using the default metaclass

[08:45] <tadzik> that's just an example of how Moose-like syntax looks there

[08:45] <tadzik> there are tests for mop bits as well

[08:48] *** sergot joined
[08:48] <sergot> hi o/

[08:48] <tadzik> \o

[08:48] *** BigBear left
[08:51] *** GlitchMr joined
[08:52] <Su-Shee> there are _three_ lighter moose-style MOPs already. mouse, moo and another one.

[08:52] <arnsholt> Mo is the bare-bonest of them I think

[08:54] <mathw> so the next one's going to be called M then?

[08:54] <arnsholt> I think mst did leave that option open, yes =)

[08:54] <moritz> and the next one after that will be called ''

[08:55] <moritz> you'll have to write $::{''} or so to get at it

[08:55] <mathw> use ''; object();

[08:55] <arnsholt> Ah, no. Mo is Ingy, actually

[08:55] <arnsholt> "Moose is huge. Moose led to Mouse led to Moo led to Mo. M is nothing. Mo is more. Not much."

[08:56] <tadzik> after M there will be this viking rune

[08:56] <tadzik> |\ or so

[08:56] <moritz> oh, and then I

[08:57] * moritz is sorely tempted to write Acme::I

[09:01] <mathw> So, it turns out I can't use Moose or Mouse or anything because the target box has a too-old Perl with a somehow-busted CPAN and I can't get it upgraded.

[09:01] <moritz> perlbrew to the rescure

[09:01] <moritz> *rescue

[09:02] *** muixirt joined
[09:03] <mathw> interesting

[09:03] * mathw has a think about how that might fit into this system

[09:03] <mathw> btw you guys are awesome

[09:04] <mathw> (and I'm sure you recognise my use of 'guys' in a colloquial sort of gender-neutral manner)

[09:05] <muixirt> hi there, will callbacks be implemented in zavolaj any time soon?

[09:11] <arnsholt> muixirt: My current plan was to wait a bit longer, but some of my other plans have fallen through so I might be convinced to change my mind

[09:11] <arnsholt> What're you looking at working with?

[09:12] <muixirt> arnsholt: nothing particular, but it seems callbacks are important for transfering data back and forth like libcurl

[09:14] <muixirt> not to mention gui frameworks...

[09:15] <arnsholt> Yeah, it's something I'd like to get in

[09:15] <moritz> (off-topic but cool: http://what-if.xkcd.com/1/ )

[09:21] <arnsholt> muixirt: But there are some issues with the implementation (namely, me not knowing how to actually implement it properly), so it might be a little while

[09:21] <jnthn> dyncall has some callback stuff that will do some of the heavy lifting. But then there's till plenty of other scary bits.

[09:22] <arnsholt> Yeah, it's the other scary bits that are the problem right now

[09:22] <muixirt> moritz: send that link to DHS, the pitchers have to be screened

[09:22] <arnsholt> The dyncallback stuff looks reasonably straightforward

[09:22] <muixirt> arnsholt: ok, no problem

[09:23] <muixirt> dyncallback?

[09:24] <arnsholt> It's the callback part of the dyncall library, which is what NQP uses to do the C-calling bits

[09:26] *** nodmonkey left
[09:27] <arnsholt> jnthn: What's a good place to look at for figuring how to call a P6/Parrot sub from C?

[09:27] <moritz> http://dyncall.org/stable/manual.pdf

[09:27] <tadzik> oh oh, stuff gets exciting

[09:28] <moritz> arnsholt: src/ops/perl6.ops has several examples

[09:28] <moritz> arnsholt: look for Parrot_pcc_invoke_sub_from_c_args

[09:28] <moritz> and Parrot_pcc_invoke_from_sig_object

[09:29] <arnsholt> Cheers!

[09:29] * moritz has fiddled with Parrot_pcc_invoke_sub_from_c_args for the exception stuff

[09:36] <hoelzro> how does one build the docs in github.com/perl6/doc?

[09:37] <moritz> hoelzro: you mean, generate the HTML?

[09:37] <moritz> panda install Pod::To::HTML; ./htmlify

[09:37] <moritz> erm, ./htmlify.pl

[09:38] <moritz> though you can use the bin/p6doc command to read some docs directly

[09:39] *** fgomez joined
[09:40] <moritz> http://dyncall.org/stable/manual.pdf page 49, Status "dyncallback is buggy"

[09:42] <jnthn> arnsholt: What moritz++ said. Building the sig object will be the slightly fun part. :)

[09:42] <arnsholt> That's for 32-bit PPC SysV (early OS X I assume), no?

[09:42] <arnsholt> jnthn: Yeah, I'm trying to figure out how these Parrot_pcc_* things work now

[09:43] <arnsholt> I think there might be some code using that which git blame will assign to me, but I cargo-culted all that from jnthn-code O:)

[09:44] <moritz> why do we need to build a signature object at all?

[09:44] <moritz> can't we just assume that callbacks have zero args, and handle all the marshalling with p6 level closures?

[09:45] <moritz> hm, might be more expensive though

[09:45] <moritz> oh, and I'm completely wrong. Never mind me.

[09:45] <arnsholt> Yeah, I was trying to see how to get the C-level data back to P6

[09:46] <moritz> maybe we need the same marshalling as for the existing NCI return values

[09:47] <arnsholt> Yeah, the callback handler will have to marshal all the C args to the correct objects, then set up the call and finally invoke it

[09:48] <moritz> sounds like a MMOP :-)

[09:48] <jnthn> Really though, that logic is similar to what we do now for marshalling return values.

[09:48] <moritz> (medium-sized atter of programming)

[09:48] <moritz> *matter

[09:49] <arnsholt> Yeah, the marshalling I'm expecting to be able to steal a lot of from the return value stuff

[09:49] <jnthn> Well, or refactor so those can be called directly.

[09:49] <arnsholt> Or that

[09:49] <arnsholt> You beat me to writing it =)

[09:52] <hoelzro> moritz: No such method 'f' for invocant of type 'Str'

[09:52] <hoelzro> I get that error from htmlify

[09:52] <moritz> hoelzro: then your rakudo isn't new enough

[09:53] <hoelzro> how new does it need to be?

[09:53] <hoelzro> I'm using Rakudo * 2012.06

[09:53] <moritz> needs to be newer than that

[09:53] <hoelzro> =(

[09:53] *** zhutingting left
[09:54] <hoelzro> does anyone have a tool for managing two Rakudo installs? =)

[09:54] <tadzik> hmm. Could we teach perlbrew to install Rakudo as well? :)

[09:55] <moritz> we might be better off writing our own 6brew

[09:55] <tadzik> Well, I don't think it's worth to duplicate the effort is there's a good, working thing. Maybe a fork would be better

[09:57] *** nodmonkey joined
[09:58] *** nodmonkey left
[09:59] <hoelzro> tadzik: but we'd need it to be in Perl6 =)

[09:59] <hoelzro> which presents a bootstrapping issue

[09:59] <hoelzro> unless we say "just install Rakudo *, then use 6brew"

[10:01] *** nodmonkey joined
[10:06] * arnsholt idly wonders what would happen if you did pthread_create(&my-function, ...) in Perl 6

[10:07] <moritz> segfault?

[10:07] <moritz> :-)

[10:07] <arnsholt> Well, actually yes

[10:08] * arnsholt misread the manpage

[10:08] <arnsholt> Actually, output parameters is something I don't think Zavolaj can do yet

[10:09] <moritz> you mean, besides arrays?

[10:09] *** kresike joined
[10:09] <kresike> hello all you happy perl6 people

[10:09] <moritz> \o kresike 

[10:09] <arnsholt> Right, the array hack. Forgot about that one

[10:10] <kresike> moritz, o/

[10:10] <flussence> outparams do work: https://github.com/flussence/perl6-XMMS2/blob/master/lib/XMMS2/Value.pm6#L9

[10:11] <moritz> wait, what?

[10:11] <moritz> you can just add 'is rw', and it DTRT?

[10:11] <flussence> yep

[10:11] <jnthn> o.O

[10:11] <jnthn> I didn't know that was implemented!

[10:12] <moritz> flussence: does that pointerize the parameter?

[10:12] <jnthn> But, nice! :)

[10:12] <flussence> moritz: honestly, I don't know how it works, other than it does :)

[10:12] <moritz> :-)

[10:12] * moritz wonders if it's an accident

[10:13] *** scott___ left
[10:13] <moritz> flussence: can you test if it still "works" if you remove the "is rw" (by accident, that is)?

[10:13] <arnsholt> I had no idea either. Wonder why

[10:13] <moritz> so, nobody implemented it :-)

[10:14] <flussence> moritz: don't have access to a working rakudo until I get out of $dayjob later :/

[10:14] <moritz> flussence: no hurry

[10:21] *** spider-mario joined
[10:22] *** Patterner left
[10:25] *** Psyche^ joined
[10:25] *** Psyche^ is now known as Patterner

[10:50] *** muixirt left
[12:04] *** spider-mario_ joined
[12:06] *** spider-mario_ left
[12:07] *** spider-mario left
[12:09] *** zamolxes joined
[12:10] *** Coleoid left
[12:13] *** gfldex left
[12:13] *** gfldex joined
[12:33] *** tokuhiro_ joined
[12:40] *** JimmyZ joined
[12:43] *** mtk left
[12:45] *** mtk joined
[12:54] *** PacoAir joined
[13:04] *** xinming left
[13:06] *** xinming joined
[13:08] *** atrodo joined
[13:10] * [Coke] chuckles at the internets:

[13:10] <[Coke]> ¯\(°_o)/¯

[13:11] <colomon> _/(°_o)\_

[13:16] <tadzik> （　｀ー´）

[13:16] <moritz> |.......|

[13:17] <JimmyZ> O(∩_∩)O

[13:17] <moritz> \      /

[13:18] *** skids joined
[13:19] *** zhutingting joined
[13:20] *** mtk left
[13:23] <PerlJam> .oO( ... and it's all valid Perl 6! )

[13:24] <[Coke]> r: ¯\(°_o)/¯

[13:24] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤Confused␤at /tmp/ZDamakwAex:1␤»

[13:24] <[Coke]> r: :P

[13:24] <p6eval> rakudo d8e7b6:  ( no output )

[13:24] <[Coke]> ... huh.

[13:24] <[Coke]> r: :P.say

[13:24] <p6eval> rakudo d8e7b6: OUTPUT«"P" => Bool::True␤»

[13:24] <jnthn> r: :D.say

[13:24] <p6eval> rakudo d8e7b6: OUTPUT«"D" => Bool::True␤»

[13:24] <jnthn> :)

[13:25] <tadzik> r: Cool:D

[13:25] <p6eval> rakudo d8e7b6:  ( no output )

[13:26] *** mtk joined
[13:26] <tadzik> r: Cool :D

[13:26] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤Confused␤at /tmp/V06VR6yF5F:1␤»

[13:26] <tadzik> bah

[13:27] *** zhutingting_ joined
[13:28] *** zhutingting left
[13:28] *** zhutingting_ is now known as zhutingting

[13:28] <moritz> r: Cool(:D)

[13:28] <p6eval> rakudo d8e7b6: OUTPUT«No such method 'Cool' for invocant of type 'Parcel'␤  in <anon> at src/gen/BOOTSTRAP.pm:804␤  in <anon> at src/gen/BOOTSTRAP.pm:801␤  in any <anon> at src/gen/BOOTSTRAP.pm:796␤  in block <anon> at /tmp/OopKddJzN2:1␤␤»

[13:29] <jnthn> r: not Cool

[13:29] <p6eval> rakudo d8e7b6:  ( no output )

[13:29] <moritz> r: not so Cool

[13:29] <p6eval> rakudo d8e7b6:  ( no output )

[13:31] <JimmyZ> r: so Cool

[13:31] <p6eval> rakudo d8e7b6:  ( no output )

[13:31] <JimmyZ> r: say so Cool

[13:31] <p6eval> rakudo d8e7b6: OUTPUT«False␤»

[13:33] *** bluescreen10 joined
[13:34] <JimmyZ> r: say not so Cool

[13:34] <p6eval> rakudo d8e7b6: OUTPUT«True␤»

[13:38] *** Woodi joined
[13:41] *** kaleem left
[13:52] <arnsholt> jnthn: Where does the -I flags adding the dyncall dirs get specified?

[13:52] <arnsholt> I need to fiddle with them to get the dyncallback header working

[13:52] <jnthn> arnsholt: In the Makefile, iirc

[13:53] <arnsholt> Well, yes. But the Makefile is generated, and I can't seem to pin down where it comes from

[13:53] <[Coke]> r: Rat and so not Cool but Whatever

[13:53] <p6eval> rakudo d8e7b6:  ( no output )

[13:54] <moritz> r: Rat and so Cool but not Whatever

[13:54] <p6eval> rakudo d8e7b6:  ( no output )

[13:54] <arnsholt> Looks like it's from @ccflags@

[13:55] <JimmyZ> r: say Rat and so not Cool but Whatever

[13:55] <p6eval> rakudo d8e7b6: OUTPUT«Rat()␤Cannot mix in non-composable type Whatever into object of type Cool␤  in sub infix:<but> at src/gen/CORE.setting:11329␤  in block <anon> at /tmp/4THWQqU0X8:1␤␤»

[13:55] <JimmyZ> r: say Rat and so Cool but not Whatever

[13:55] <p6eval> rakudo d8e7b6: OUTPUT«Rat()␤»

[13:56] <JimmyZ> n: say Rat and so not Cool but Whatever

[13:56] <p6eval> niecza v19-13-g442e075: OUTPUT«Rat()␤»

[13:57] <JimmyZ> so, rakudo  bug or niecza bug?

[13:58] <JimmyZ> n: say Rat and so Cool but not Whatever

[13:58] <p6eval> niecza v19-13-g442e075: OUTPUT«Rat()␤Unhandled exception: Cannot initialize a slot when mixing into a type object␤  at /home/p6eval/niecza/lib/CORE.setting line 1359 (infix:<does> @ 23) ␤  at /home/p6eval/niecza/lib/CORE.setting line 1363 (infix:<but> @ 4) ␤  at /tmp/CjkwhOIi3r line 1 (…

[13:58] <colomon> http://martinsprogrammingblog.blogspot.de/2012/02/why-is-clojure-so-slow.html

[13:59] <JimmyZ> hmm, niecza and rakudo are different outputs

[13:59] *** am0c left
[14:00] <colomon> http://clojureclr.blogspot.com/2011/12/using-ngen-to-improve-clojureclr.html

[14:04] <pmichaud> good morning, #perl6

[14:05] <pmichaud> jnthn: ping

[14:05] <moritz> good am, pm

[14:05] <colomon> \o

[14:07] <jnthn> pmichaud: pong

[14:07] <jnthn> arnsholt: Sorry, had phone call. tools/build/Makefile.in

[14:07] <jnthn> arnsholt: And running Configure.pl updates it.

[14:07] <JimmyZ> who can tell whether it's rakudo bug or niecza bug?

[14:08] <pmichaud> jnthn: I'm looking at typed arrays and typed lists; is there a strong reason why the TypedArray code was done in Array and not List ?

[14:08] *** tokuhiro_ left
[14:09] <jnthn> JimmyZ: Rakudo's error seems more awesome to me.

[14:09] <jnthn> JimmyZ: I'm not sure either implementation is wrong to refuse to do it.

[14:09] <jnthn> pmichaud: Hmm.

[14:09] *** am0c joined
[14:09] <jnthn> pmichaud: Perhaps not wanting to prematurely generalize.

[14:09] <JimmyZ> jnthn: thanks

[14:10] <jnthn> pmichaud: I don't think we have syntax for constructing a typed list? :)

[14:10] <pmichaud> jnthn: wouldn't it be just   List[Int]  ?

[14:10] <jnthn> pmichaud: ah

[14:10] <jnthn> pmichaud: Yeah

[14:10] <jnthn> Duh :)

[14:10] <moritz> erm

[14:10] * jnthn was thinking Parcel instead of List somehow

[14:10] <moritz> wouldn't that imply that List is a role?

[14:11] * jnthn blames thinking about difficult $dayjob problem at the same time as this :)

[14:11] <jnthn> moritz: Array manages not to be.

[14:11] <moritz> or is it simply a call to &.[] ?

[14:11] <jnthn> In general, the way I factored the MOP is that there's a fairly generic way to respond to "parameterize me"

[14:11] <pmichaud> and technically I'm wondering if   my Int @a   say something about the typed-ness of the @a symbol

[14:11] <jnthn> For RoleHOW it does what you'd expect.

[14:11] <pmichaud> *says

[14:12] <pmichaud> jnthn: that was my other question -- whether the interface used by Array for typedness is "canonical"

[14:12] <jnthn> For ClassHOW it calls a method on the type which, if it exists, can do the right thing.

[14:12] <moritz> Positional[Int] I'd guess

[14:12] <jnthn> Positional[Int] is a role. 

[14:12] <jnthn> Note that

[14:12] <jnthn> r: my @a; say @a.WHAT

[14:12] <p6eval> rakudo d8e7b6: OUTPUT«Array()␤»

[14:12] <jnthn> r: my Int @a; say @a.WHAT

[14:12] <p6eval> rakudo d8e7b6: OUTPUT«Array+{TypedArray}()␤»

[14:13] <jnthn> r: my Int @a; say @a ~~ Positonal[Int]

[14:13] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Positonal' called (line 1)␤»

[14:13] <moritz> (I mean, 'my Int @a' should type-constraint @a to Positional[Int])

[14:13] <jnthn> r: my Int @a; say @a ~~ Positional[Int]

[14:13] <p6eval> rakudo d8e7b6: OUTPUT«True␤»

[14:13] <jnthn> moritz: I think it is.

[14:13] <moritz> \o/

[14:13] <jnthn> my Int @a; my Str @b; @a := @b

[14:13] <jnthn> r: my Int @a; my Str @b; @a := @b

[14:13] <p6eval> rakudo d8e7b6: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Array+{TypedArray}'␤  in block <anon> at /tmp/1yhc6IvKQt:1␤␤»

[14:13] <moritz> r: my Int @a := Positional[Int]

[14:13] <p6eval> rakudo d8e7b6:  ( no output )

[14:13] <moritz> r: my Int @a := Positional[Str]

[14:13] <p6eval> rakudo d8e7b6: OUTPUT«Type check failed in binding; expected 'Positional' but got 'Positional'␤  in block <anon> at /tmp/nIniw5uvLu:1␤␤»

[14:13] <jnthn> The output of all this is sucky though. :/

[14:13] <jnthn> As in, error reporting output.

[14:14] *** thou left
[14:14] * jnthn was sure he'd implemented the naming stuff.

[14:14] <jnthn> r: say Positional[Int]

[14:14] <p6eval> rakudo d8e7b6: OUTPUT«Positional()␤»

[14:14] <jnthn> Hmm

[14:14] <moritz> r: say Positional[Int].^name

[14:14] <p6eval> rakudo d8e7b6: OUTPUT«Positional␤»

[14:17] <pmichaud> r: my Int @a;  say @a ~~ Positional

[14:17] <p6eval> rakudo d8e7b6: OUTPUT«True␤»

[14:17] <pmichaud> r: my Int @a;  say @a ~~ Positional[Mu]

[14:17] <p6eval> rakudo d8e7b6: OUTPUT«True␤»

[14:17] <pmichaud> r: my Int @a;  say @a ~~ Positional[Str]

[14:17] <p6eval> rakudo d8e7b6: OUTPUT«False␤»

[14:17] <pmichaud> r: my @a;  say @a ~~ Positional[Str]

[14:17] <moritz> it's... contravariant, iirc

[14:17] <p6eval> rakudo d8e7b6: OUTPUT«False␤»

[14:18] <pmichaud> r: my @a;  say @a ~~ Positional[Mu]

[14:18] <p6eval> rakudo d8e7b6: OUTPUT«False␤»

[14:18] <jnthn> There's another oddity. Since Array already has Positional (unparameterized) mixed in, the typed array now has Positional mixed in twice. :/

[14:18] <pmichaud> right.  That's the part that I'm worried about.

[14:18] <jnthn> s/mixed in/composed

[14:18] <jnthn> Me too.

[14:18] <pmichaud> I really want Array (and List) to have Positional[::T] already in them.

[14:19] <pmichaud> and not have a composed-in role for some arrays/lists but not for others

[14:19] <moritz> and the obvious solution is to introduce parametric classes

[14:19] <pmichaud> basically,   "Array"   and "List"  should act like "Array[Mu]"  and "List[Mu]"

[14:19] <jnthn> Do you want List and Array to not be a role too?

[14:20] * moritz hides from jnthn++'s death glares

[14:20] <pmichaud> I don't minid if List and Array are roles.... but just keep in mind that they're _really_ fundamental types to much of the system.

[14:20] <pmichaud> *mind

[14:20] <pmichaud> as in, we use List and Array directly in the binder

[14:20] *** wtw left
[14:20] <jnthn> Well, yeah, parametricism has always created bootstrappy fun.

[14:21] <jnthn> We'd end up doing this with Hash EnumMap too.

[14:21] <jnthn> *and

[14:22] <pmichaud> r:  say Positional[Str] ~~ Positional[Mu]

[14:22] <p6eval> rakudo d8e7b6: OUTPUT«True␤»

[14:22] <jnthn> moritz: The fact that classes are open and roles are closed plays into this.

[14:22] <pmichaud> r:  say Positional[Mu] ~~ Positional[Str]

[14:22] <p6eval> rakudo d8e7b6: OUTPUT«False␤»

[14:22] <pmichaud> very nice (and interesting)  :-)

[14:23] <moritz> jnthn: I thought so, yes

[14:23] <jnthn> moritz: When you do generic instantiation of a role, it produces a new meta-object to represnet the concrete role.

[14:23] <jnthn> That gets the stuff copied over.

[14:23] <jnthn> This goes quite a bit deeper than "just make classes take type parameters" :)

[14:23] *** muixirt joined
[14:24] <pmichaud> and in this case  "just make bootstrapped classes take type parameters"

[14:24] <jnthn> All of this said...

[14:24] <jnthn> A class is never generic on the invocant.

[14:25] <jnthn> Ho!

[14:25] <jnthn> I guess what we really want here is...

[14:26] <jnthn> That Array is able to claim to implement Positional[Int] or whatever if asked. And the decision is at an *object* level.

[14:26] <moritz> as long as it doesn't make type checking slower... (which we really want to be fast)

[14:26] <jnthn> Not at a type level.

[14:26] <jnthn> Yes, making this fast is a challenge. :)

[14:27] <pmichaud> shouldn't be

[14:27] <pmichaud> a typed array simply creates typed scalars

[14:27] <jnthn> But a solvable one.

[14:27] <moritz> pmichaud: but what does that make of typed lists?

[14:27] <jnthn> pmichaud: I'm more worried about the @foo ~~ Positional[Int] style checks.

[14:27] <pmichaud> jnthn: those have to be fast?

[14:27] <jnthn> pmichaud: Well, they have to be not slow :)

[14:28] <jnthn> pmichaud: I mean, sub foo(Int @bar) { } # boils down to that

[14:29] <pmichaud> basically, a typed array just has an 'of' method, yes?

[14:30] <jnthn> pmichaud: That's the introspection-y way of asking what kind of array it is, yes

[14:30] <jnthn> That method comes from the parametric Positional role.

[14:30] <jnthn> I think I'm starting to see how something could work out and perform decently.

[14:31] <pmichaud> jnthn: does it work out such that arrays (and lists)  don't get a new role composed into them?

[14:31] <jnthn> pmichaud: yes.

[14:31] <pmichaud> okay, then I'm happy.

[14:31] <jnthn> pmichaud: Well, it works out such that individual objects contribute to the type check.

[14:31] <pmichaud> what happens if I do  .WHAT on those objects?

[14:32] <jnthn> my Int @foo; # It's an Array as a type; under type check it will claim to do Positional[Int]

[14:32] <moritz> so

[14:32] <jnthn> pmichaud: Array type object

[14:32] <pmichaud> what about   @foo.WHAT ~~ Positional[Int]   ?

[14:32] <jnthn> False

[14:32] <moritz> my Int @a; my Str @b; @a.WHAT === @b.WHAT # True

[14:32] <pmichaud> ...and that's okay?

[14:32] <jnthn> That's the downside.

[14:33] <jnthn> Well, the point of the mixing in is to produce a new type.

[14:33] <jnthn> Is your problem the mixing in itself, or the visible fallout of doing so?

[14:33] <pmichaud> more the visible fallout, I think (more)

[14:33] <pmichaud> if this were a pure-ish Perl 6 then I'd be declaring     class List[::T] does Positional[T] { ... }

[14:34] <pmichaud> and _that's_ what I wish our List would start out as, without any mixing in

[14:34] <jnthn> *nod*

[14:34] <pmichaud> or, more precisely:

[14:34] <pmichaud> class List[::T = Mu] does Positional[T] { ... }

[14:35] <jnthn> Right

[14:36] <jnthn> But that means giving classes type args.

[14:36] <pmichaud> they don't have them now?

[14:36] <jnthn> No.

[14:36] <jnthn> Only roles are parametric.

[14:36] <pmichaud> oh!

[14:36] <jnthn> It's always been that way.

[14:36] <pmichaud> well, in that case, I'm in favor of our List starting out as a role :-)

[14:37] <moritz> oh oh oh

[14:37] <jnthn> :)

[14:37] <moritz> that will be rather confusing, and it will make it much harder to monkey-type with $!storage or whatever it's called from within other classes

[14:38] <jnthn> Indeed.

[14:38] <pmichaud> is it?

[14:38] <pmichaud> It just means we use $?CLASS instead of the hard-coded List, yes?

[14:38] <jnthn> Inside the class, yes.

[14:38] <pmichaud> well, outside we shouldn't be monkey-typing with the storage, I don't think.

[14:38] <moritz> oh, and in future we'll have attributes mixed in from a role stored separately

[14:39] <moritz> pmichaud: but we do now

[14:39] <moritz> pmichaud: for example in Array

[14:39] <jnthn> .oO( Why do I get the impression I'm about to spend a bunch of time re-working roles... )

[14:39] <moritz> (we mess with List's $!items in Array)

[14:40] <jnthn> pmichaud: Do we declare List and Array in bootstrap? If so, what for?

[14:40] <pmichaud> jnthn: I think various parts of the compilation process expect to know about Array

[14:40] <pmichaud> i.e., even when there's not a setting present.

[14:41] <pmichaud> for example:    my @a;

[14:41] <pmichaud> I don't have any heartache if List/Array aren't declared in bootstrap, no.

[14:41] <pmichaud> I just think other parts of the compiler might.  :)

[14:42] <jnthn> pmichaud: Ah, yeah.

[14:42] <moritz> $ ack -w '(List|Array)' src/Perl6/|wc -l

[14:42] <moritz> 45

[14:42] <jnthn> You can't partially declare roles really

[14:42] <jnthn> And until Array is known as a type, you can't write the @ sigil

[14:42] <pmichaud> moritz: the parts where Array monkeytypes with $!items is likely fixable

[14:42] <jnthn> We depend on the openness.

[14:44] <pmichaud> let's step back one moment :-)

[14:45] <pmichaud> I have a different question

[14:45] <pmichaud> r:  my $l = (3,4,5).list;   say $l.WHAT;

[14:45] <p6eval> rakudo d8e7b6: OUTPUT«List()␤»

[14:45] <pmichaud> good

[14:45] <pmichaud> r:  my $l = (3,4,5).list;   say $l.of;

[14:45] <p6eval> rakudo d8e7b6: OUTPUT«Mu()␤»

[14:45] * moritz steps back and decommutes

[14:45] <pmichaud> also good

[14:47] <pmichaud> so how would I use the result of .of  to constrain a scalar variable?  I.e., something like    my ::type = self.of;  my type $v;

[14:48] <jnthn> r: sub foo(::T) is rw { my ::T $v }; say foo(Int).VAR.of

[14:48] <p6eval> rakudo d8e7b6: OUTPUT«No such method 'of' for invocant of type 'Scalar'␤  in block <anon> at /tmp/qN4wpojw9a:1␤␤»

[14:48] <jnthn> r: sub foo(::T) is rw { my ::T $v }; say foo(Int).VAR.type

[14:48] <p6eval> rakudo d8e7b6: OUTPUT«No such method 'type' for invocant of type 'Scalar'␤  in block <anon> at /tmp/IBmi0HXAmt:1␤␤»

[14:48] <jnthn> hmm

[14:49] <jnthn> r: sub foo(::T) is rw { my ::T $v }; say foo(Int)

[14:49] <p6eval> rakudo d8e7b6: OUTPUT«Int␤»

[14:49] <pmichaud> isn't it   my T $v ?

[14:49] <pmichaud> (no colons)

[14:49] <jnthn> d'oh

[14:49] <jnthn> r: sub foo(::T) is rw { my T $v }; say foo(Int)

[14:49] <p6eval> rakudo d8e7b6: OUTPUT«Int␤»

[14:49] <jnthn> Yeah; I guess it ignores the colons

[14:49] <jnthn> r: sub foo(::T) is rw { my ::Te $v }; say foo(Int)

[14:49] <p6eval> rakudo d8e7b6: OUTPUT«Cannot call a method on type variable Te␤  in any find_method at src/gen/Metamodel.pm:282␤  in method gist at src/gen/CORE.setting:725␤  in sub say at src/gen/CORE.setting:6975␤  in block <anon> at /tmp/6YX5jV1k4j:1␤␤»

[14:50] *** cognominal left
[14:50] <jnthn> Oh heh, and there it declares it with an uninstantiated type var...

[14:50] <jnthn> That should probably not be allowed.

[14:50] <muixirt> hi again, is LWP::Simple known to work? I get a segfault at «use LWP::Simple»

[14:50] <pmichaud> what about      my $v of $type  ?  does that work at all?

[14:51] <tadzik> muixirt: it worked last time I tried

[14:51] <tadzik> muixirt: what Rakudo/LWP are you on?

[14:51] *** cognominal joined
[14:51] <pmichaud> r:  my $type = Int;  my $v of $type;  say $v

[14:51] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤Confused␤at /tmp/Q2xy7Va1rr:1␤»

[14:51] <muixirt> R* 2012.06

[14:51] <jnthn> pmichaud: Parse error; the of trait expects a type after it.

[14:52] <jnthn> pmichaud: It's probably easiest to create an op that knows how to create a Scalar based on a certain container descriptor

[14:53] <jnthn> (Since we only want one of those per array)

[14:54] <pmichaud> ...one of those per array?

[14:54] <jnthn> pmichaud: The container descriptor is the thing that holds the rw and type flags for a scalar.

[14:55] <pmichaud> right

[14:55] <jnthn> pmichaud: For a given array, all of the scalars we create should really share one.

[14:55] <pmichaud> when I declare a scalr, it doesn't have a type already?

[14:55] <pmichaud> or, put another way:   how is     my $x   different from  my Int $x   ?

[14:56] <jnthn> The $!descriptor pointed to by Scalar has a different value in $!of

[14:57] <jnthn> The descriptor is the "static bits" of the declaration.

[14:57] <pmichaud> every scalar gets its own descriptor?

[14:57] <jnthn> Yes

[14:57] <jnthn> Well, to be clear.

[14:57] <jnthn> Every scalar that statically appears in the source code gets its own descriptor.

[14:58] <muixirt> tadzik: your last try was with R* 2012.06?

[14:58] <jnthn> Every instance of Scalar just points to the relevant static one.

[14:58] <pmichaud> so how does    my T $v   work?

[14:58] <jnthn> It's a bit like how we used to put the type into the prophash. Apart from rather more efficient. :)

[14:59] <jnthn> The statically created descriptor contains a type variable.

[14:59] <jnthn> The declaration of the variable causes .instantiate_generic to be called with the current type environment.

[15:00] <tadzik> muixirt: according to http://tjs.azalayah.net/new.html my last try was at  2012-06-09T11:37:43Z on rakudo 2012.05-221-g0fde4a1 :)

[15:00] <jnthn> Which produces a specialized container descriptor.

[15:01] <jnthn> pmichaud: More specifically, it compiles down to something like

[15:01] <jnthn> $v := $v.VAR.instantiate_generic($type_env)

[15:03] <pmichaud> okay, that just went beyond my current level of understanding :)

[15:03] <jnthn> oops :)

[15:03] <jnthn> Which bit was confuzzling? :)

[15:03] <pmichaud> well, all of it was at the edge of understanding; that last bit just stepped over the line :)

[15:04] <PerlJam> jnthn: what's a "type environment"?

[15:04] <pmichaud> yeah, I think "type environment" threw me.

[15:04] <jnthn> Oh!

[15:04] <jnthn> Something that you can use to turn a type variable name into the current type.

[15:04] <jnthn> sub foo(::T) { my T $x }

[15:05] <pmichaud> does it have to be a type variable name, ooc?

[15:05] <jnthn> So here, when we compile this, we don't know what T is

[15:05] <pmichaud> I mean, why isn't it simply "turn this thing into the current type" ?

[15:05] <jnthn> When we call foo, we bind T to the type we captured.

[15:05] <jnthn> Say we did foo(42)

[15:05] <pmichaud> right....  isn't T just an entry in the lexpad?

[15:05] <jnthn> The type environment is like a hash T => Int

[15:06] <jnthn> pmichaud: At the moment we actually use the lexpad to be the type environment. That is...not the best of ideas it turns out.

[15:06] <PerlJam> jnthn: so, it's kind of like a thunk that maps variables to types (dynamically)?

[15:06] <jnthn> pmichaud: But the code just expects something hash-like.

[15:06] <pmichaud> r:  sub foo(::T $x) { say T; };   foo(42)

[15:06] <p6eval> rakudo d8e7b6: OUTPUT«Int()␤»

[15:06] <pmichaud> the lexpad seems the most logical to me, yes.

[15:06] <jnthn> PerlJam: It's just the map

[15:06] <jnthn> pmichaud: Well, it breaks down though :(

[15:07] <jnthn> In a silly way I shoulda seen coming.

[15:07] *** grondilu joined
[15:07] <jnthn> sub foo(::T1) { sub bar() { my T1 $x }; bar() }

[15:07] * grondilu failed compiling the  june edition of  rakudo-star

[15:07] <jnthn> lexpad isn't a view down through the scopes.

[15:07] <jnthn> It's just the current scope.

[15:07] <jnthn> So, d'oh. I need to fix this thing still.

[15:08] <pmichaud> but when you do the   instantiate_generic(...)   ---   can't the ... just be an expression lookup?

[15:08] <pmichaud> in the case of  my T1 $x, you just lexically lookup T1 and then use that to instantiate the variable?

[15:08] <jnthn> pmichaud: There's no reason it can't be compiled to .instantiate_generic(nqp::hash('T1', T1)), yes.

[15:09] <jnthn> That's the fix I'm thinking of.

[15:09] <jnthn> grondilu: How'd it fail?

[15:09] <pmichaud> I'm wondering why it's not     .instantiate_generic(PAST::Op(...))   ?

[15:09] <jnthn> pmichaud: I'm confused.

[15:10] <jnthn> :)

[15:10] <pmichaud> instantiate_generic is something called at runtime, yes?

[15:10] <jnthn> pmichaud: It may happen at compile time.

[15:10] <pmichaud> in the case of    my T1 $x

[15:10] <jnthn> pmichaud: Oh, wait, we may be not quite on the same page...

[15:10] <jnthn> Yes, that happens at runtime

[15:11] <jnthn> I was talking about the call that we'd make rather than the code that we emit

[15:11] <pmichaud> and when it's called, it gets passed a type object?

[15:11] <jnthn> What it gets passed today is the lexpad, which it uses to look up T1.

[15:11] <pmichaud> why not have it be passed the type object?

[15:12] <jnthn> Here it is:

[15:12] <jnthn> if %cont_info<bind_constraint>.HOW.archetypes.generic {

[15:12] <jnthn>     $past := QAST::Op.new(

[15:12] <jnthn>         :op('callmethod'), :name('instantiate_generic'),

[15:12] <jnthn>         QAST::Op.new( :op('p6var'), $past ),

[15:12] <jnthn>         QAST::Op.new( :op('curlexpad') ));

[15:12] <jnthn> }

[15:12] <jnthn> The whole instantiate_generic thing you see here is replicated in a bunch of places. It's not just about container descriptors.

[15:12] <jnthn> In

[15:13] <jnthn> role Foo[::T1, ::T2] { method bar(T1, T2) { } }

[15:13] <jnthn> When we make that into a concrete role, we pass the lexpad of the role down to instantiate_generic of each of the methods.

[15:13] <jnthn> So the answer in general is "there may be lots of type objects"

[15:13] <jnthn> In this *specific* case, yes, we could get away with passing down one type.

[15:14] <pmichaud> okay.

[15:14] <jnthn> But really it's just following a more general API.

[15:14] <jnthn> I also wonder if at some point we may need to handle:

[15:14] <jnthn> sub foo(::TCont, ::TValue) { my TCont[TValue] $x; } # ouch :)

[15:15] <jnthn> Oh, that may not be so bad

[15:15] <jnthn> Oh

[15:15] <jnthn> The badder one is:

[15:15] <pmichaud> yeah, that's where I feel like it ought to just be lexical lookups, instead of a specialized "type environment"

[15:15] <jnthn> sub foo(::T1, ::T2) { my T1(T2) $x; } # whee, generic coercion types...

[15:15] <pmichaud> I can see T1(T2) being a pain, yes.

[15:16] <jnthn> pmichaud: Well, if you mean "hash build out of lexical lookups"?

[15:16] <jnthn> Type variables are always lexically scoped. So at any point we know which ones are in scope.

[15:17] <jnthn> So it's be quite easy to handle this.

[15:17] <pmichaud> okay

[15:17] <pmichaud> so, back to my present predicament

[15:18] <pmichaud> Looking at the code again, I don't have any issue with the current role-composition mechanism for typed arrays, as long as

[15:18] <kresike> bye all

[15:18] <pmichaud> (1) I can put it in List instead of Array

[15:18] *** kresike left
[15:18] <pmichaud> (2) there's some way for me to create scalar variables that are constrained to an arbitrary type  (in this case, the type returned by self.of() )

[15:18] *** thelazydeveloper joined
[15:18] *** cognominal_ joined
[15:19] <jnthn> Do you need to create those scalars in List or Array?

[15:19] <pmichaud> in Array

[15:19] <jnthn> OK

[15:19] <pmichaud> in List I'll be wanting to type check the bindings, but I can already do that from .of

[15:20] <jnthn> In Array you already ahve a $!descriptor attribute. It should contain a ContainerDesciptor that has the correct type set in it.

[15:20] <jnthn> In container.c we have something called scalar_from_descriptor

[15:20] <pmichaud> I don't think I can use that if we're doing the role mixin, though.

[15:20] <pmichaud> because the role_mixin changes the Array's .of

[15:21] <jnthn> You can always set it to a fresh container descriptor when the array is created.

[15:21] <jnthn> There's already a perl6_create_container_descriptor

[15:22] <pmichaud> I'm sorry, I'm _really_ confused.

[15:22] *** cognominal left
[15:22] <pmichaud> I think you're implying some level of descriptor sharing that we don't have at present.

[15:22] <jnthn> Right.

[15:23] <jnthn> I'm saying that all of the scalars in a given array want to share a desciptor.

[15:23] <jnthn> *descriptor.

[15:23] <jnthn> Creating one for every scalar will be really wasteful

[15:23] <jnthn> Currently we get that for untyped arrays

[15:24] *** grondilu left
[15:24] <jnthn> STORE_AT_POS(\$pos, Mu $v is copy)

[15:24] <jnthn> iiuc, it's the "is copy" that creates a scalar, but since there's statically one $v the descriptor for that $v is shared.

[15:25] <jnthn> Actually over all arrays.

[15:25] <pmichaud> okay, I get that part.

[15:25] <pmichaud> eventually I was planning for that to become

[15:25] <pmichaud> STORE_AT_POS(\$pos, T $v is copy)

[15:26] <pmichaud> ...but that's probably not going to work.

[15:26] <jnthn> At the moment, that'll instantiate the container descriptor every single call and so we get no sharing.

[15:26] <pmichaud> got it.

[15:26] <pmichaud> so, what I really want is

[15:26] <jnthn> We *could* find a way to cache that I guess.

[15:26] <pmichaud> 1.  a way for an Array to give me a scalar based on its notion of ".of"

[15:27] <pmichaud> actually, that would be sufficient.  I'm fine if it gives me something from its $!descriptor attribute, as long as  PARAMETERIZE_TYPE(Mu $t)   is also setting that descriptor.

[15:28] <jnthn> Yes, that's what I was (badly) trying to get accross.

[15:28] <pmichaud> it doesn't look to me as though the current PARAMTERIZE_TYPE does that.

[15:28] <jnthn> No, it doesn't.

[15:28] <jnthn> That's what is missing.

[15:30] <jnthn> Or mroe to the point, what's missing is: 1) PARAMETERIZE_TYPE creating that desciptor. Difficulty: should be fairly easy, there's an op to do it. 2) A way to create a new Scalar with a certain container descriptor from code.

[15:30] <jnthn> Well, actually, 2 is possible if you use bindattr

[15:30] <jnthn> Since the descriptor is just an attribute on Scalar

[15:31] <pmichaud> #2 sounds like it needs to be an op also

[15:31] <jnthn> All this said, what is even more efficient is that you create a Scalar with the correct descriptor once, bind it somewhere, then just clone it 

[15:31] *** am0c left
[15:31] <pmichaud> oh, if that's the case, then just make that scalar an attribute of Array

[15:31] <jnthn> Right. :)

[15:32] <jnthn> And at that point you may as well create it in PARAMETERIZE_TYPE

[15:32] *** fhelmberger left
[15:32] <jnthn> $!protoscalar := (my T $elem); # done!

[15:32] <PerlJam> Couldn't that "prototype" scalar also hold the default for the array?

[15:32] <jnthn> PerlJam: Yes.

[15:32] <pmichaud> PerlJam: and in fact, it does.

[15:34] <pmichaud> when you do a lookup of a non-existent element, you get back the default scalar.  It's just that currently that's a simple "my" declaration.

[15:35] <pmichaud> jnthn: "clone a scalar"   is just  nqp::clone($scalar)   ?

[15:35] <jnthn> pmichaud: No, the 6model variant

[15:35] <pmichaud> I don't know the 6model variant

[15:35] <jnthn> pmichaud: See the method clone() in Mu

[15:36] <jnthn> Don't know if it has an nqp:: op yet.

[15:36] <pmichaud> repr_clone__PP

[15:36] <jnthn> Right

[15:36] <pmichaud> awesome.

[15:36] <jnthn> In the end I hope we can make everything 6model-y and unify these ops...

[15:36] <pmichaud> okay, I think I see where this goes now.

[15:36] <jnthn> ok :)

[15:36] <jnthn> btw

[15:36] <jnthn> At the moment the errors you get can contain spurious $v or whatever

[15:36] <jnthn> BUT

[15:36] <jnthn> The container descriptor is just an object with a has str $!name or so

[15:37] <pmichaud> got it.

[15:37] <jnthn> So you can maybe set it to "array element" so the errors read better :)

[15:37] <pmichaud> does   $!protoscalar := (my T $)   work?  ;-)

[15:37] <jnthn> Probably

[15:37] <jnthn> But then the errors will just talk about $ :)

[15:38] <pmichaud> anyway, yes, I see how I can muck with the name.

[15:38] <jnthn> r: my Int $ = 'lol'

[15:38] <p6eval> rakudo d8e7b6: OUTPUT«Type check failed in assignment to '$'; expected 'Int' but got 'Str'␤  in block <anon> at /tmp/hOn51LTP6T:1␤␤»

[15:38] <pmichaud> r:  r:  say (my Int $).VAR.name

[15:38] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤Confused␤at /tmp/QipTusEbYW:1␤»

[15:38] <pmichaud> r:  say (my Int $).VAR.name

[15:38] <p6eval> rakudo d8e7b6: OUTPUT«$␤»

[15:39] <pmichaud> neat.

[15:39] <jnthn> We use that in things like

[15:39] <jnthn> r: my $a; say +$a

[15:39] <p6eval> rakudo d8e7b6: OUTPUT«use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/8FJ3jIdkbO:1␤␤0␤»

[15:39] <pmichaud> yes; that's where the spurious container names come from :)

[15:40] <pmichaud> okay, thanks for all of the pointers.

[15:40] <jnthn> *you, *are, *welcome :)

[15:40] <pmichaud> I was working on some new List/Array code last night, then ran into spectest fails with typed arrays

[15:40] <pmichaud> and looked at the code and said "Huh? OMG"

[15:40] <jnthn> ;)

[15:41] * jnthn shoulda taken the Pm List and Array tutorial *before* writing that code :)

[15:41] <pmichaud> actually, it's not that bad, but TypeArray shouldn't be overloading at_pos/bind_pos whatever.  Array should already know how to do that.

[15:41] <pmichaud> because arrays and lists are already typed

[15:42] <pmichaud> (it's that they default to Mu)

[15:43] <pmichaud> *TypedArray

[15:43] <pmichaud> anyway, I'm about to do some more semi-radical refactors of the List code  :-/

[15:44] <jnthn> .oO( I hpoe the list of semi-radical refactors isn't infinite... )

[15:44] <pmichaud> so far the answer to that is "Mu"

[15:44] <jnthn> :P

[15:46] <pmichaud> but this next refactor should make things somewhat more efficient in memory and speed

[15:46] *** JimmyZ_ joined
[15:46] <pmichaud> it will also eliminate a few kludges

[15:47] <pmichaud> oh!

[15:47] <pmichaud> what's the best way to determine that an object is of an exact type?

[15:47] <pmichaud> in my case, I want to know that a given object is a List

[15:47] <pmichaud> (not a subclass of List)

[15:48] <jnthn> r: say List.WHAT === Array.WHAT

[15:48] <p6eval> rakudo d8e7b6: OUTPUT«False␤»

[15:48] <jnthn> r: say List.WHAT === List.WHAT

[15:48] <p6eval> rakudo d8e7b6: OUTPUT«True␤»

[15:48] *** JimmyZ left
[15:48] <jnthn> so, $obj.WHAT === List

[15:48] <pmichaud> ... what if I want to do that from C?  ;-)

[15:49] <jnthn> STABLE(obj)->WHAT == LookupListHere

[15:49] <jnthn> I think List is handy

[15:49] <pmichaud> it's available where I need it, yes (the binder, or as an opcode)

[15:49] <jnthn> Rakudo_types_list_get

[15:49] <pmichaud> I'm going to put in an optimization for building Lists from existing Lists

[15:50] <pmichaud> but it only works if the thing you're building from *is* a *List*

[15:50] <jnthn> Right. This'll get you an exact czech.

[15:52] *** JimmyZ_ left
[15:52] * TimToady feebly attempts to backlog a week...

[15:52] <phenny> TimToady: 02 Jul 16:46Z <bbkr> tell TimToady that / $. / regexp parsing using STD has some internal error "Use of uninitialized value $x in concatenation in line 66623" leaking and shown before "Unsupported use of $. variable" message (meant to be seen by user). RT 77550 shows that it did not happen in the past, so this is an regression in awesomness :)

[15:53] <TimToady> but re http://irclog.perlgeek.de/perl6/2012-07-03#i_5781272 I'd say that 'use fatal' must be lexically scoped, not dynamically

[15:53] <TimToady> 'no fatal' is the default

[15:54] <jnthn> TimToady: Lexically scoped, but somehow lifted by things like "open"?

[15:54] <TimToady> either the caller or the callee has to figure it out; I'd tend to think the caller would have an easier time of it

[15:55] <TimToady> so more of an implicit // die

[15:55] <TimToady> though as originally conceived, looking up the call stack from the callee to see what the lexical settings of the caller are

[15:56] <TimToady> but dynamic will just be a world of painful action at a distance

[15:56] <TimToady> we can't have the caller setting policy for the callee's lexical scope like that

[15:57] <pmichaud> so, basically CALLER::<$FATAL>  or somesuch

[15:57] <pmichaud> I understand the point now, yes.

[15:59] <jnthn> pmichaud: The current PAST formulation of exception handlers seems to tie them to blocks. So a block has a set of handlers. While that works out in a sense, I'm looking at the code in MapIter and thinking an nqp:: thing that set up handlers in a more fine-grained way would let us write code like that more easily.

[15:59] <jnthn> Er, I mean, not in PIR :)

[15:59] *** arlinius joined
[16:00] <pmichaud> jnthn: I didn't like the "tied to blocks" formulation, fwiw.

[16:00] <jnthn> pmichaud: OK, then that's both of us. :)

[16:00] <pmichaud> to me, handlers should be tied to code.

[16:00] <pmichaud> thus the original version of PAST used a   :pasttype<try>  node for handlers

[16:01] *** brrt left
[16:01] <pmichaud> Tene++ tried refactoring the handlers to be a specialized node type.... but it never really worked out.

[16:01] <jnthn> As a very first approximation, nqp::some-non-crap-name(code_to_protect(), CATCH => ..., LAST => ...)

[16:02] <jnthn> That is, we use named parameters on the node to name the different types of handlers.

[16:02] <pmichaud> as a first approximation, that works for me :)

[16:03] <jnthn> Not sure how best to convey the current exception though.

[16:04] <jnthn> Maybe some ops that only make sense in the context of a handling thing

[16:04] <pmichaud> wfm

[16:04] <jnthn> nqp::excpayload(), etc.

[16:04] <pmichaud> well, at some level payload ought to be an attribute of an exception, retrievable with getattr

[16:04] <pmichaud> rather than a specialized op

[16:05] <pmichaud> getting the exception itself can be an op, certainly.

[16:05] <jnthn> I'm not so sure. If we're talking about abstracting away the underlying VM...

[16:05] <jnthn> The way we'll communicate exceptiony things will be probably quite different.

[16:05] <pmichaud> ... the exception still probably wants to be 6model-y, I hope.

[16:06] <pmichaud> that said, I don't mind too much if we treat exception as a low-level thingy the same way we're doing list and hash

[16:06] <jnthn> Well, the payload (as in, what's actually thrown) probably wants to be. (more)

[16:06] <pmichaud> so in that context, nqp::excpayload would make sense to me.

[16:06] *** Coleoid joined
[16:06] <jnthn> But looking at VMs out there, they have their own constraints on what the thing you *actually* throw is.

[16:06] <pmichaud> I'd probably just use ::payload, though.

[16:07] <jnthn> For example, Parrot wants it to be something of its Exception PMC type. The CLR wants it to be a subclass of Exception. etc.

[16:07] <pmichaud> just like we have  ::push and ::pop without having to explicitly say "listpush" and "listpop"

[16:07] <jnthn> It's that low level "container" that I want to abstract away.

[16:07] <jnthn> +1 to payload

[16:07] <pmichaud> so yes, I'm fine with treating exceptions as low-level vm objects the same way we do lists and hashes

[16:08] <pmichaud> (with corresponding low-level ops)

[16:08] <jnthn> OK

[16:09] *** plobsing left
[16:10] <pmichaud> Util: ping

[16:11] <jnthn> pmichaud: Is nqp::handle(...) an OK name? I'm trying to think of something short but descriptive...I don't really like this one.

[16:11] <pmichaud> jnthn: why not nqp::try ?

[16:11] <jnthn> pmichaud: It carries the implication of Perl 6 "try", but actually may only be considering control exceptions

[16:12] <jnthn> pmichaud: That's a weak objection though.

[16:12] <jnthn> "try" is the Perl 6 keyword it's spiritually closest too :)

[16:12] <pmichaud> doesn't a try block with a  CONTROL { ... }   phaser also handle control exceptions?  ;-)

[16:12] <jnthn> True ;)

[16:12] <jnthn> OK, I go with nqp::try

[16:12] <pmichaud> "try" makes the most sense to me.

[16:13] <pmichaud> with the understanding that   nqp::try(protected, ...)  that doesn't have a CATCH handler doesn't actually catch things.

[16:13] <pmichaud> I could go for nqp::handle, though.

[16:14] <pmichaud> nqp::handle   reads pretty nicely, actually.

[16:14] <pmichaud> nqp::handle(code_to_protect, CATCH => dothis, CONTROL => dothat)

[16:14] <pmichaud> I think I prefer ::handle

[16:15] <jnthn> :)

[16:15] <pmichaud> I'm not worried about it being short; it shouldn't be all that common, and no matter how short the name is it'll be "long" because of the need to specify the handlers.

[16:16] <pmichaud> the implication of course is that nqp::handle(code)   with no handlers specified ends up not catching anything.

[16:16] <pmichaud> unlike 'try' in Perl 6, which has a default handler.

[16:19] * pmichaud is a little afraid to touch the List code again :-/

[16:20] <colomon> you should be glad you're not programming in Lisp, *everything* is List code there.  ;)

[16:20] <pmichaud> colomon: believe me, I'm very glad of that.  :)

[16:23] <TimToady> pmichaud: where did your questions end up?  I want to think about them while driving to SoCal today...

[16:25] <pmichaud> TimToady: we put them into the github issue tracker

[16:25] <pmichaud> I'll get the links... one sec

[16:25] <pmichaud> (we can move them back to a file if that's generally more convenient for you.)

[16:26] <pmichaud> generically:  https://github.com/perl6/specs/issues

[16:26] <pmichaud> specific tickets of interest (to me):

[16:26] <pmichaud> https://github.com/perl6/specs/issues/17

[16:26] <pmichaud> https://github.com/perl6/specs/issues/16

[16:26] <pmichaud> (that's it at the moment)

[16:26] <TimToady> thanks

[16:26] <arnsholt> jnthn: FYI, I derped on the include paths =)

[16:27] <pmichaud> I'll have some list interpolation types of questions, but they're not ready yet.

[16:27] <arnsholt> They were right there in plain sight

[16:27] <pmichaud> for lists (to fix the gather/take interpolation bugs) I need to smash a few more atoms together before I can get to the theoretical questions for you :)

[16:28] *** muixirt left
[16:28] *** thou joined
[16:28] <pmichaud> for list interpolation and other list issues, I'm planning to create a t/spec/S07-interpolation/mumble.t  file where we memoralize the pieces that we know have to work a certain way

[16:29] <pmichaud> that way when we come up with a change that might break something, I'll have the list of counter-examples handy :)

[16:29] <pmichaud> (should've done that years ago.)

[16:29] <jnthn> pmichaud++ # good idea :)

[16:30] <jnthn> Dinner...should have a few QAST exception-y tuits afterwards :)

[16:30] <jnthn> 7

[16:30] <jnthn> &

[16:30] <TimToady> ooh, let's call it...Test Driven Deportment, or something like that

[16:30] <pmichaud> 8

[16:30] <pmichaud> *

[16:31] <pmichaud> TimToady: yeah... I'm a little ashamed to have not thought of doing that before this last go-round.

[16:31] <jnthn> .oO( oh shift... )

[16:34] <pmichaud> TimToady: btw, very glad to see you back.  We missed you.  :)

[16:34] <TimToady> well, still gonna be offline a bunch this week, commuting to Irvine, Seattle, and Portland...

[16:35] <pmichaud> ...aren't those kind of in opposite directions?  ;-)

[16:35] <TimToady> but should be better than last week; doing IT at a large quiz meet turns out to be more than a full-time job

[16:35] <TimToady> but I did a lot of Perl 6 programming there, on the plus side :)

[16:36] <pmichaud> TimToady: niecza?  or rakudo?  :-P   (No, you don't have to answer that.)

[16:36] * pmichaud wonders if TimToady has a sekrit Perl 6 environment that none of us know about yet.

[16:36] <TimToady> I generally try to make sure my programs run on both

[16:36] <PerlJam> pmichaud: He may have used the TimToady implementation of Perl 6

[16:36] <PerlJam> :)

[16:37] <pmichaud> TimToady: You're going to be driving almost the whole of I5... considered making it border-to-border?  ;-)

[16:38] <TimToady> there is no part of I5 I am not already too familiar with :)

[16:39] <pmichaud> I've driven nearly all of I10 -- I'm just missing the part from Lake City FL to Jacksonville.

[16:39] <TimToady> even spent part of my honeymoon parked on I5 due to a broken fuel pump

[16:39] *** zhutingting left
[16:39] <TimToady> about 12 miles north of Grants Pass

[16:40] <pmichaud> anyway, safe travels

[16:45] *** fridim_ joined
[16:46] *** thou left
[16:53] *** fridim_ left
[16:56] *** lue left
[16:56] *** REPLeffect left
[16:57] *** dakkar left
[16:57] *** Su-Shee left
[16:58] *** daxim left
[17:00] *** mtk left
[17:01] *** mtk joined
[17:07] <arnsholt> jnthn: Any tricks for inspecting the type signature of a P6 routine, or do I just have to do a lot of Parrot_pcc_invoke_*?

[17:07] <arnsholt> (Inspecting it from C, that is)

[17:10] <moritz> arnsholt: I'm pretty sure the binder has more direct access

[17:10] *** lue joined
[17:12] <moritz> arnsholt: search for Rakudo_Parameter in src/binder/bind.* for example

[17:13] <moritz> and Rakudo_Signature

[17:13] <arnsholt> But that's Rakudo. The dyncall code lives in NQP, unfortunately

[17:14] *** zamolxes left
[17:15] <moritz> does all of it have to stay there?

[17:17] <pmichaud> how does the dyncall code get its signature information (in NQP) ?

[17:18] <moritz> it doesn't need any, afaict

[17:18] <pmichaud> I should probably ask a larger question -- like what's the overall goal of the question?  (I'm late to the conversation, yes.)

[17:18] <moritz> pmichaud: arnsholt tries to implement callbacks

[17:18] <pmichaud> callbacks from C into rakudo subs?

[17:18] <moritz> yes

[17:18] *** fridim_ joined
[17:18] <pmichaud> why would one need to inspect the signature?

[17:18] <sorear> good * #perl6

[17:19] <moritz> intuitively I'd say that it's OK for those to have rakudo-specific parts

[17:19] <moritz> well, there are two possible approaches

[17:19] <moritz> one is to have a marshaller in p6 land that can be invoked with whatever C passes

[17:19] <moritz> and that one introspects the signature of the p6 routine and marshalls the argumts

[17:20] <moritz> or one can do that directly in C land

[17:20] <pmichaud> I'm missing a piece, in "marshalling the arguments"

[17:21] <pmichaud> does the thing doing the callback know the types of arguments it's sending?

[17:21] <moritz> what do you mean by "doing the callback"?

[17:22] <moritz> the C library that invokes the calback has its own expectation

[17:22] <moritz> like, (uint64, char*, double*)

[17:22] <moritz> and somehow that needs to get mapped to signature like (Int, Str, Array[Double]) or so

[17:23] *** mucker joined
[17:23] <moritz> that is, the user probably write the p6 routine with a signature of (Int, Str, Array[Double])

[17:23] *** birdwindupbird left
[17:23] <pmichaud> well, presumably an "is native" in there somewhere, too.

[17:23] <moritz> or maybe s/Int/unit64/

[17:23] <moritz> presumably, yes

[17:24] <pmichaud> in which case the "is native" handles the translation between the C call and what the sub expects, yes?

[17:24] <pmichaud> or... no, I see.

[17:24] <pmichaud> I'm thinking about it backwards.

[17:25] *** REPLeffect joined
[17:27] <pmichaud> conceptually, I'd expect Rakudo blocks to have some sort of "callback" method/operation that can inspect the sub and return a pointer to a C-callable-routine that will transform the incoming C args into the corresponding Rakudo types and then do the dispatch.

[17:27] <pmichaud> the C-callable-routine is then what gets passed to the library.

[17:30] <pmichaud> alternatively, a C-callable routine gets its arguments and passes them to the Rakudo code object and says "here, you figure them out and invoke them" :-).  That's your first option, I guess.

[17:30] <pmichaud> (marshaller in p6 land)

[17:30] *** samlt left
[17:31] <moritz> though I guess some of the marshalling can't be easily done in p6 land either

[17:31] <moritz> "interpret that blob as a pointer to a double" isn't something that's safely done in p6

[17:31] <arnsholt> Sorry I disappeared

[17:32] * jnthn back

[17:32] <pmichaud> anyway, I understand the problem better now, thanks.  I don't have an easy answer; but introspecting the signature from nqp feels wrongish to me.

[17:32] <arnsholt> Yeah

[17:32] <pmichaud> afk for a bit

[17:32] <jnthn> oh, what are we on at the moment? :)

[17:32] <gfldex> magic

[17:32] <arnsholt> The existing code gets the type information from the Perl 6 code in Zavolaj

[17:32] <moritz> introspecting from rakudo C land sounds much saner to me

[17:32] <moritz> jnthn: callbacks in zavolaj

[17:32] <arnsholt> Yeah, that makes a lot of sense I think

[17:33] <moritz> especially since NQP and Rakudo signatures  aren't the same beasts at all

[17:33] <pmichaud> also, nqp is intended to support languages other than Rakudo... so that calls for an API

[17:33] <arnsholt> Quite

[17:34] <pmichaud> afk for a bit

[17:34] <jnthn> The nativecall "protocol" is just arrays, hashes and type objects :)

[17:34] <jnthn> We build those based on the Perl 6 signature.

[17:34] <arnsholt> jnthn: Basically, I need to get the argument and return types from a callback sub

[17:34] <arnsholt> From C

[17:35] <jnthn> arnsholt: Ah, no, that's probably the wrong way to do it :)

[17:36] <arnsholt> Right. Let's not do that then =)

[17:36] <jnthn> Lemme check something in S06..

[17:36] <jnthn> Yeah

[17:36] <jnthn> There's this syntax:

[17:37] <arnsholt> My basic idea was that a callback sub was just one whose argument and return types were compatible with the NativeCall types

[17:37] <jnthn> sub (int $n, &callback:(Str, int, int --> int)) is native { * }

[17:37] <jnthn> So, the way to do the marshalling of the callback's arguments lives in the signature of the native call declaration.

[17:37] <jnthn> So

[17:38] <arnsholt> Right! That makes a lot of sense

[17:38] <jnthn> sub foo(&x:(int, int)) is native { * }

[17:38] *** fridim_ left
[17:38] <jnthn> Would mean a native call to "foo" that takes a callback, and when the callback is invoked we shoudl expect two ints.

[17:39] <arnsholt> Yah

[17:39] <jnthn> And the protocol I had in mind for specifying this info is even written out at the top of dyncall.ops :)

[17:39] <arnsholt> Oh, right! =)

[17:40] <jnthn> Since we already have logic for mapping things in a signature to array of hashes that it desires...

[17:40] <jnthn> ...then that part should (hopefully) just be a not-too-hard refactor away.

[17:41] <gfldex> how would you handle c structs as parameters to c callbacks?

[17:41] <jnthn> Anyway, it means that we give all of the info out in one go, rather than having calls back into Rakudo to introspect stuff.

[17:41] <jnthn> gfldex: Same way we handle C structs as return values today, I should imagine.

[17:41] <arnsholt> Yeah, that's a lot better

[17:42] <gfldex> jnthn: that works already?

[17:42] <jnthn> gfldex: It just boils down to having some class written with the "is repr('CStruct')" as the type.

[17:42] <arnsholt> I'll probably have to fiddle a bit with param_hash_for

[17:42] <jnthn> gfldex: Returning a struct? I believe so.

[17:42] <jnthn> gfldex: https://github.com/jnthn/zavolaj/blob/master/t/06-struct.t has tests for it.

[17:43] <gfldex> nice

[17:44] <arnsholt> It doesn't support sized ints yet, so it's a bit limited, but the basics are there

[17:50] *** Su-Shee joined
[17:53] <jnthn> Oh...one technicality. I'm not sure if we parse the &a:(...) syntax yet.

[17:53] <jnthn> But can probably steal that from STD. Shouldn't be too bad.

[17:56] <arnsholt> Heh, right

[17:56] <moritz> r: sub f(&x(Int, Str --> Array)) { }

[17:56] <p6eval> rakudo d8e7b6:  ( no output )

[17:56] <moritz> we seem to parse it

[17:56] <moritz> r: sub f(&x(Int, Str --> Array)) { }; say &f.signatures.params[0].perl

[17:56] <p6eval> rakudo d8e7b6: OUTPUT«No such method 'signatures' for invocant of type 'Sub'␤  in block <anon> at /tmp/xp1QEUbN5Y:1␤␤»

[17:57] <moritz> r: sub f(&x(Int, Str --> Array)) { }; say &f.signature.params[0].perl

[17:57] <p6eval> rakudo d8e7b6: OUTPUT«&x :(Int , Str )␤»

[17:57] <moritz> woah

[17:57] *** Coleoid left
[17:57] <arnsholt> Looks like it works. Cool

[17:57] *** samlt joined
[17:57] <pmichaud> jnthn: ping

[17:58] <jnthn> You missed a colon.

[17:58] <jnthn> pmichaud: pong

[17:58] <jnthn> But I guess the above way works ;-)

[17:58] <pmichaud> jnthn: is there a (easy) way in the bootstrap code for class List to make sure that every created List has its $!items initialized to an empty RPA ?

[17:58] <jnthn> It's parsed differently though.

[17:59] <pmichaud> (no is an acceptable answer; I'm just getting tired of constantly checking+initializing $!items in every List method.)

[17:59] <jnthn> pmichaud: Thinking.

[17:59] <jnthn> pmichaud: I suspect the answer is "no".

[18:00] <pmichaud> okay.

[18:00] <jnthn> At least, I can't think of a way off hand.

[18:00] <pmichaud> I can probably do it in  nqp::p6list  (which uses the binder function to create lists)... but when I tried it last night there were still some Lists that ended up with uninitialized $!items

[18:00] <pmichaud> so, some Lists are still being created via nqp::create() 

[18:00] <pmichaud> (which is somewhat expected.)

[18:01] <jnthn> Well, and then there's the Array case :)

[18:01] <pmichaud> ...array case?

[18:01] <jnthn> my @a;

[18:01] <pmichaud> oh, that's probably the one that is doing it, yes :)

[18:01] <jnthn> Yeah. That one works interestingly :)

[18:01] <jnthn> (It clones whatever is in the static lexpad)

[18:01] <pmichaud> yeah.......

[18:02] <pmichaud> and probably wouldn't (shouldn't) be a deep clone.

[18:02] <jnthn> So if you initialize that one to have a $!items it'll be shared

[18:02] <jnthn> Right, it's shallow.

[18:02] <pmichaud> okay.

[18:02] <jnthn> I once pondered teaching P6opaque to be more configurable on that.

[18:02] <pmichaud> I *might* make an opcode to do it then.

[18:02] <jnthn> But we got by just fine so far.

[18:02] *** sergot left
[18:03] <pmichaud> actually, having an opcode do it would simplify a lot of things.

[18:03] <pmichaud> in Array too.

[18:04] <pmichaud> I'm not sure that's a pattern I'd want to see replicated throughout much of the codebase... but for List it might be worthy enough to do.  We already have some list-specific opcodes.

[18:04] *** birdwindupbird joined
[18:05] <pmichaud> I could do it as a C opcode for now; but it could easily also be managed as a nqp::-pseudoop

[18:05] *** sergot joined
[18:05] <jnthn> Well, everything should be an nqp:: thing these days.

[18:05] <jnthn> Then it can be replaced in whatever way.

[18:06] <pmichaud> it'd be a nqp:: pseudoop that builds a tree

[18:06] <pmichaud> and I'm not sure we can easily parameterize those yet.

[18:07] *** spider-mario joined
[18:07] <moritz> r: sub f(&x:(Int, Str --> Array)) { }; say &f.signature.params[0].perl

[18:07] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤invoke() not implemented in class 'Capture'␤»

[18:07] <pmichaud> I'll do it as a C op to begin with (with a  nqp:: alias in the code).  I'm most comfortable with knowing that will work properly.  We can generalize a bit later.

[18:07] *** stephenlb joined
[18:08] <pmichaud> and right now I have too many other variables that can cause thing to break so I'm wanting to keep the number small-ish :)

[18:08] <pmichaud> *things

[18:08] *** spider-mario left
[18:09] *** spider-mario joined
[18:09] <pmichaud> Mucking with the list code is always tricky.  Of the various experiments I've tried in my branch, about 80% of them cause non-trivial fails :)

[18:22] <pmichaud> afk # airport pickup, lunch

[18:22] <arnsholt> jnthn: Current plans for implementing the callbacks

[18:22] *** harmil left
[18:23] <dalek> doc: 337a4af | moritz++ | lib/glossary.pod:

[18:23] <dalek> doc: [glossary] explain "invocant"

[18:23] <dalek> doc: review: https://github.com/perl6/doc/commit/337a4afcfb

[18:23] <diakopter> moritz: s/that/on which/

[18:24] <moritz> diakopter: takk

[18:25] <dalek> doc: fde229c | moritz++ | lib/glossary.pod:

[18:25] <dalek> doc: [gloassary] grammar fix by diakopter++

[18:25] <dalek> doc: review: https://github.com/perl6/doc/commit/fde229c880

[18:25] <arnsholt> Or "called on"

[18:25] <diakopter> no..

[18:25] <arnsholt> I quite like dangling prepositions

[18:26] <diakopter> moritz: oh, I see what you were saying. now that you did the 'on which', you have to remove one of the 'is called' :)

[18:26] <diakopter> er

[18:26] <diakopter> NO

[18:26] <diakopter> sorry I'm wrong

[18:26] <diakopter> it just looked funny for a second

[18:27] <diakopter> my reading of what arnsholt said confused me :D

[18:27] <moritz> diakopter: you're welcome to rephrase if you have a better idea :-)

[18:27] <moritz> and a commit bit (hint hint :-)

[18:28] <dalek> nqp/toqast: d11e353 | jnthn++ | src/QAST/Var.nqp:

[18:28] <dalek> nqp/toqast: Add QAST::Var.default (not needed for Rakudo, but it's part of what replaces viviself, and NQP will need it).

[18:28] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/d11e353f40

[18:29] <moritz> is the plan to migrate nqp to QAST too?

[18:29] <jnthn> moritz: Yeah, but I'll not work on it until I've done Rakudo

[18:30] <jnthn> moritz: It's just that viviself is gone in QAST, and the above is one place we used it, so I'm just stubbing in the replacement while I think of it :)

[18:31] <jnthn> Plus it's LHF for any would be QAST::Compiler hacker :)

[18:31] <diakopter> arnsholt: (I see what you were saying now)

[18:36] *** arlinius left
[18:36] *** alvis```` joined
[18:37] *** brrt joined
[18:38] <dalek> doc: f10aa0d | moritz++ | lib/Complex.pod:

[18:38] <dalek> doc: start to document Complex

[18:38] <dalek> doc: review: https://github.com/perl6/doc/commit/f10aa0ddea

[18:38] *** samlt left
[18:39] *** jaldhar left
[18:40] *** jaldhar joined
[18:42] <arnsholt> diakopter: Yours is fine as well. Dangling prepositions are largely a question of style, I think

[18:42] *** harmil joined
[18:43] <diakopter> the dangling preposition, though "wronger", is probably clearer in this case because of the repeated "is called"

[18:44] <diakopter> but I don't have a good idea to reword it to get rid of the repeated "is called" and make it flow nicely

[18:45] *** bluescreen10 left
[18:45] *** bluescreen10 joined
[18:46] <[Coke]> (wait, TimToady is gone a week, and has only a SINGLE message from phenny? hurm...)

[18:49] <diakopter> folks trust him to backlog so they don't always use phenny

[18:53] *** harmil left
[18:53] *** harmil joined
[18:54] *** brrt left
[18:54] <moritz> and we've turned some questions into GH issues too

[18:55] *** fhelmberger joined
[18:55] *** spider-mario left
[18:55] *** spider-mario_ joined
[18:56] <masak> good evening, #perl6

[18:56] <jnthn> masak! \o/

[18:56] <moritz> \o masak

[18:57] <masak> \o/

[18:58] <sorear> MASAKK!

[19:06] *** GlitchMr left
[19:06] *** lichtkind joined
[19:08] *** brrt joined
[19:12] *** samlt joined
[19:13] <masak> happiness all around.

[19:13] * sjohnson could use some of dat

[19:13] * moritz hugs sjohnson 

[19:13] <sjohnson> :3

[19:13] <moritz> hugme: hug everybody

[19:13] * hugme hugs everybody

[19:14] * masak hugs sjohnson too

[19:14] <sjohnson> （　° ー°）

[19:14] <sjohnson> i feel better already !

[19:16] * sorear hugs sjohnson

[19:16] * sjohnson gives back a big #perl6 group hug

[19:18] <colomon> hugs!

[19:20] <sjohnson> someday #perl6 might turn into #hugs :)

[19:21] * sorear hugs colomon

[19:22] <lichtkind> mass hugging

[19:22] <lichtkind> oh man im away :)

[19:22] *** fhelmberger left
[19:22] <sjohnson> hugs are contageous

[19:24] <masak> wow, there actually is a channel #hugs on freenode.

[19:24] <masak> and I'm the 10th nick in there.

[19:27] <lichtkind> masak: im more like gagamel

[19:29] <diakopter> masak: maybe hugs refers to the haskell thing?

[19:29] <lichtkind> diakopter: i hope so

[19:31] <moritz> lichtkind: there's nothing wrong with hugging :-)

[19:32] <lichtkind> moritz: ich war immer schon mit gagamel, hab die schlümpfe gehasst,

[19:32] <lichtkind> also mach dich wenn ich vorbeikomm auf das schlimmste gefasst

[19:37] <masak> sjohnson: "We need 4 hugs a day for survival. We need 8 hugs a day for maintenance. We need 12 hugs a day for growth." -- Virginia Satir

[19:37] *** MayDaniel joined
[19:37] *** fhelmberger joined
[19:38] <lichtkind> masak: that statement is no surprise for someone naming itself satyr

[19:39] *** spider-mario_ is now known as spider-mario

[19:39] <sjohnson> masak: wise quote

[19:40] <masak> lichtkind: wow, I never made that connection, even though I've known the name for years.

[19:42] <lichtkind> masak: rumor has it perl atracts language affine people

[19:43] *** brrt left
[19:44] <masak> lichtkind: aye.

[19:44] * masak .oO( what's affine language like you're doing in a place like this? )

[19:45] <masak> s/you're/you/

[19:53] <sjohnson> it also attracts hug enthusiasts :)

[19:53] *** fgomez left
[19:55] *** fhelmberger left
[19:57] <dalek> doc: e8502de | moritz++ | lib/Complex.pod:

[19:57] <dalek> doc: [Complex] add polar; fix "returns" traits

[19:57] <dalek> doc: review: https://github.com/perl6/doc/commit/e8502deb84

[19:59] * colomon just had an out-of-control piece of $work code eat 4+ gigs of real memory...

[20:00] <sorear> ulimit -v is your friend

[20:04] <colomon> is there a Windows equivalent?  That's where my real problem lies, I managed to get the process under control on the Mac pretty easily.  My PC is still going off the rails, though...

[20:04] <masak> sjn: hm. I kinda like the name Adventure::World. I'll think a bit about it.

[20:06] <moritz> colomon: I don't know, but maybe there's a setting in the process manager (ctrl+alt+del) to limit it?

[20:07] <moritz> http://stackoverflow.com/questions/192876/set-windows-process-or-user-memory-limit

[20:08] <masak> moritz: [backlog] I also constantly mistake "visitor pattern" for "tree fold". I think it severely hinders my grokking of it. (along with "so you're saying the language doesn't do that kind of method dispatch? wha'..."_

[20:08] <masak> )

[20:09] <moritz> oh, that reminds me. I wanted to write that visitor :-)

[20:10] <masak> mathw: [backlog] check your nearest CPAN. M is there.

[20:11] <masak> also, I used to see a use for Mouse, but I don't any more. I'd consider Moo in all of the cases I would have considered Mouse before.

[20:11] <masak> Moo seems to do what Mouse intended, but better in all ways. (goas all the way with "no MOP", is *perfectly* compatible/substitutable with Moose)

[20:12] <sorear> why do people keep making new perl 5 object systems?

[20:12] *** kaare__ left
[20:13] <masak> sorear: the post-Moose landscape does look difference, in people's defence.

[20:13] <moritz> because there isn't one good in core

[20:13] <masak> sorear: Moose has a prohibitive startup cost in some domains.

[20:15] <masak> hoelzro++ # http://hoelz.ro/blog/another-look-at-perl-6

[20:15] <masak> hoelzro|away: what's wrong with $*OUT? ;)

[20:18] *** dukeleto joined
[20:19] <masak> oh wow. https://github.com/stevan/p5-mop/blob/master/t/000-examples/002-basic-example.t

[20:19] <masak> that's awesome.

[20:19] <sorear> aye

[20:30] *** seldon joined
[20:32] <sorear> o/ seldon, o/ dukeleto

[20:32] <seldon> \o sorear

[20:37] *** samlt left
[20:40] *** vlixes joined
[20:41] *** samlt joined
[20:41] <moritz> https://gist.github.com/3086115 # my mostly general tree folder

[20:43] <masak> moritz: nice.

[20:44] <masak> moritz: I'm looking at $root and &children, and thinking "refactor parameters into parameter object", though. :) and call it Node. :)

[20:44] <masak> not saying it's necessarily a better factoring. just that that's my first reaction.

[20:44] * masak .oO( refaction )

[20:45] <moritz> masak: erm, I can't quite imagine how that would look like

[20:45] <masak> ok.

[20:46] <moritz> masak: got a short example for me?

[20:46] <masak> the &children routine being passed in is just a mapping from parents to children, no? that's why you can keep passing it down.

[20:46] <moritz> right

[20:47] <masak> my proposal is just to ditch that routine and encode the same mapping in an object structure. class Node { has Node @.children }

[20:47] <moritz> same for &pre, &post and &assemble actually

[20:47] <masak> nothing more.

[20:47] <masak> well, all those are more obviously part of the *algorithm*.

[20:47] <masak> &children is more obviously part of the data structure.

[20:48] <moritz> masak: but when I have somethiing like a Pod tree, I'd have to recursively walk the whole structure to bring it into the form of Node objects

[20:48] <moritz> before passing it to &visit, which recursively walks the whole structure

[20:49] <masak> I see what you mean.

[20:49] <moritz> that's the point of having it a callback: it makes it usable on structures that don't already fit the pattern exactly

[20:49] <masak> it would be nice if there were "interface adapters" -- things that say "I know you need this, but adapt those things over there on a by-need basis".

[20:49] <moritz> $root could be an integer, and &children returns two divisors

[20:50] <masak> moritz: yeah, I see your use case now. that's pretty neat.

[20:50] <masak> interface adapters would do the same but with OO, though.

[20:50] <masak> I wonder if anyone has ever done something like that in a language.

[20:50] <moritz> I bet lisp has :-)

[20:50] <masak> heh :)

[20:51] *** MayDaniel left
[20:51] <moritz> well

[20:52] <moritz> in this case, I could simply add a parameter :$children-method-name

[20:52] <moritz> and then do   @children = $root."$children-method-name"().map: ... ;

[20:53] <moritz> that would be kind of poor man's interface adapter

[20:53] *** thelazydeveloper left
[20:54] <masak> yeahbut. yeech. :)

[20:54] <masak> now you've soiled your routine with adapter details.

[20:54] <masak> the thing with interface adapter would be that you can keep referring to the "nice" interface inside the routine. and handle all the ugly mapping in the interface adapter scope.

[20:56] <masak> moritz: "If an named argument was passed for C<assemble>...", but the code contains no conditional.

[20:56] <masak> also, s/an/a/ in there.

[20:56] <moritz> well, the "otherwise" case is handled through the default

[20:56] <moritz> which just returns Nil

[20:58] *** bruges_ joined
[20:58] <masak> oh, true.

[20:58] <PerlJam> that "interface adaptor" sounds interesting, but only if it got out of the way.

[20:59] <masak> PerlJam: yeah. I'm a bit fuzzy on how to actually hook it up when invoking the routine.

[20:59] * moritz -> sleep

[20:59] <PerlJam> masak: it seems kind of waterbedy to me right now.  Like you're just moving the essential complexity

[21:00] *** bruges left
[21:00] <masak> sleep well, moritz. dream of turtle-like callables all the way down.

[21:00] <masak> PerlJam: I will think about it some more. you may be right.

[21:01] *** birdwindupbird left
[21:02] *** thou joined
[21:03] *** samlt left
[21:05] *** cognominal_ left
[21:07] *** cognominal joined
[21:11] *** crab2313 joined
[21:12] *** skids left
[21:16] *** samlt joined
[21:18] <sjn> masak: about naming... I'm kinda keeping the "tell a story with code" idea in mind when coming with that suggestion

[21:19] <sjn> not sure how feasible it all is, but given that you're kinda creating a story to begin with, I think it would be nice to see if that idea is doable

[21:21] <masak> sjn: if I haven't licensed the code already, consider MIT license to apply. you're free to take story and/or code and do nice things with it according to your wishes.

[21:21] <sjn> no worries :)

[21:22] <sjn> just throwing some crazy ideas out there 

[21:23] <masak> well, I still think your "tell a story with code" idea is interesting. I'd like to see you produce a full-fledged example of it.

[21:23] <masak> no-one else is gonna do it for you :)

[21:26] <masak> lol I blogged! \o/ http://strangelyconsistent.org/blog/july-10-2012-things-which-can-be-opened

[21:27] * jnthn read it as "can beer opened" :P

[21:31] *** thou left
[21:33] *** Pleiades` left
[21:35] <felher> masak++ :)

[21:35] *** muixirt joined
[21:36] <felher> But that was quite a short one... can i get one of the two '+' back?

[21:36] * felher is just teasing :)

[21:38] <seldon> masak+=0.5?

[21:38] <lue> good post masak++

[21:39] <felher> seldon: yeah, something like that :)

[21:39] <masak> felher: sorry, '++' is an atomic operation. ;)

[21:40] * lue wonders if +=0.5 actually worked

[21:40] <felher> masak: ... good point :)

[21:40] <seldon> Does ++masak work?

[21:40] <seldon> Because I feel much more at home with preincrement, coming from ++C.

[21:40] *** jaldhar left
[21:41] <masak> in here, that means "you've promised to do something, there's actual karma in it for you if you do"

[21:41] *** Pleiades` joined
[21:41] *** jaldhar joined
[21:41] <seldon> Also, what does "work" mean? Does a bot keep score or something?

[21:42] <felher> aloha: karma masak

[21:42] <aloha> felher: masak has karma of 750.

[21:42] <gfldex> karma masak 

[21:42] <aloha> masak has karma of 750.

[21:42] <gfldex> masak+=0.5

[21:42] <gfldex> karma masak 

[21:42] <aloha> masak has karma of 750.

[21:45] <seldon> Karma can only be portioned out by the cosmos.

[21:45] <aloha> can only be portioned out by the cosmos. has karma of 0.

[21:46] <seldon> That bot is a bit on the cheeky side, isn't it?

[21:46] *** samlt left
[21:48] <jnthn> karma bots that don't know when to shut up

[21:48] <aloha> bots that don't know when to shut up has karma of 0.

[21:48] <jnthn> As they should! :P

[21:48] <seldon> karma i can

[21:48] <aloha> i can has karma of 0.

[21:48] <jnthn> *lol*

[21:49] <masak> :P

[21:50] <seldon> Hmm...

[21:51] <seldon> karma++

[21:56] *** PacoAir left
[22:01] *** spaceships joined
[22:02] * pmichaud reads

[22:02] *** stephenlb left
[22:07] *** alester left
[22:08] *** awwaiid left
[22:09] *** awwaiid joined
[22:10] *** Guest96273 is now known as Grrrr

[22:13] *** stephenlb joined
[22:16] <sergot> good night ! o/

[22:16] *** sergot left
[22:17] <masak> dobranoc, sergocie.

[22:19] <lichtkind> i noe see larry stole Q from ruby

[22:19] <lichtkind> thats hdeous

[22:22] * lue now hates wordpress (just lost a big post I finished writing because I tried adding a link in fullscreen mode) >:(

[22:27] <masak> lichtkind: isn't it %Q in Ruby, though?

[22:28] <masak> also, does Ruby really use the Q form in order to adverb the Q?

[22:28] <pmichaud> I think Q{}  actually came from p5's   q{}

[22:29] <lichtkind> pmichaud: yes but i was looking for a pun too, and it was just surprising to find it there

[22:30] *** muixirt left
[22:30] <masak> good night, #perl6

[22:31] <mhasch> good night, masak

[22:33] *** bluescreen10 left
[22:42] *** Khisanth left
[22:42] <lichtkind> good night fellas

[22:42] <lichtkind> o/

[22:42] *** lichtkind left
[22:46] *** crab2313 left
[22:49] *** majrmovies joined
[22:49] <majrmovies> Hi Perl6ers ..

[22:49] <majrmovies> If this is the output of the "perl6 -v" command

[22:49] <majrmovies> This is perl6 version 2012.06 built on parrot 4.5.0 revision 0

[22:49] <majrmovies> How would I require that version in a module?

[22:49] <majrmovies> Because "use Perl:<6.2012.06>;" doesn't work. ;-(

[22:50] <pmichaud> I think version requirment in modules is not yet implemented (NYI)

[22:50] <pmichaud> at any rate, it'd be a Rakudo version, not a Perl version.

[22:50] <majrmovies> Ahh... I see.

[22:51] <majrmovies> Thank you Mr. Michaud.

[22:51] <flussence> you'd write "use v6;"

[22:51] <pmichaud> if nobody else is able to give you a better answer here -- feel free to file a bug report (rakudobug@perl.org) with the question, or ask on perl6-users mailing list.

[22:51] <jnthn> 'night, #perl6

[22:51] <dalek> nqp/toqast: b6e9580 | jnthn++ | src/QAST/Operations.nqp:

[22:51] <dalek> nqp/toqast: Start sketching out various exception related operations.

[22:51] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/b6e95805b5

[22:52] <pmichaud> I'm not even certain that compiler-requirement versions are spec'd.

[22:52] <pmichaud> jnthn: later!

[22:52] <jnthn> pmichaud: Didn't get as far as hoped with exception impl today, brain too fuzzy... Maybe tomorrow evenin'. 

[22:52] <jnthn> o/

[22:52] <pmichaud> jnthn: all progress is good, though.

[22:52] <majrmovies> flussence: but there is a fix in rakudo 2012.06 that is required for this to run ... it will fail in 2012.05 or prior

[22:52] <pmichaud> I'm not as far along as I'd hoped with lists

[22:53] * diakopter is not as far along with qast stuff as I hoped

[22:54] <flussence> write code to spec, not to browsers^Wperl6s

[22:54] <pmichaud> someone still might want to provide a useful warning about compiler version.

[22:54] <pmichaud> in fact, we put a version number into one of the dynvars for this... just a sec

[22:54] <pmichaud> (looking)

[22:56] <pmichaud> r: say $*PERL<compiler><ver>

[22:57] <p6eval> rakudo d8e7b6: OUTPUT«2012.06-77-gd8e7b66␤»

[22:57] <pmichaud> r: say $*PERL<compiler>release-number>

[22:57] <p6eval> rakudo d8e7b6: OUTPUT«===SORRY!===␤Confused␤at /tmp/0Oek9TcNct:1␤»

[22:57] <pmichaud> r: say $*PERL<compiler><release-number>

[22:57] <p6eval> rakudo d8e7b6: OUTPUT«␤»

[22:58] <pmichaud> r: say %*PERL<compiler>.perl

[22:58] <p6eval> rakudo d8e7b6: OUTPUT«Failure.new(exception => X::AdHoc.new(payload => "postcircumfix:<\{ }> not defined for type Failure"))␤»

[22:58] <pmichaud> r: say %*PERL<compiler>;

[22:58] <p6eval> rakudo d8e7b6: OUTPUT«postcircumfix:<{ }> not defined for type Failure␤  in method gist at src/gen/CORE.setting:9533␤  in sub say at src/gen/CORE.setting:6975␤  in block <anon> at /tmp/cC0z7zCpIk:1␤␤»

[22:58] <pmichaud> r: say $*PERL<compiler>;

[22:58] <p6eval> rakudo d8e7b6: OUTPUT«("name" => "rakudo", "ver" => "2012.06-77-gd8e7b66", "release-number" => "", "build-date" => "2012-07-09T09:09:42Z", "codename" => "").hash␤»

[22:58] <pmichaud> hrm.

[22:59] *** Khisanth joined
[22:59] <majrmovies> Well $*Perl<compiler><ver> would work for my purposes

[22:59] <majrmovies> err $*PERL<compiler><ver>

[22:59] <pmichaud> majrmovies: yes.  Just make sure the $*PERL<compiler><ver> gt '2012.06'

[22:59] <pmichaud> er,   ge '2012.06'

[23:00] <pmichaud> we should probably provide a proper Version value, too.

[23:01] <pmichaud> I'm not sure what happened to release-number and codename, though.

[23:01] *** fgomez joined
[23:02] <pmichaud> majrmovies: anyway, I hope this is good enough for now.  I think the spec needs a little more clarification on specifying minimum requirements :-)

[23:02] *** spaceships left
[23:04] <majrmovies> Thanks for your help!

[23:05] *** majrmovies left
[23:05] *** nodmonkey left
[23:08] *** whiteknight joined
[23:08] *** whiteknight is now known as Guest62195

[23:10] *** cognominal_ joined
[23:11] *** Coleoid joined
[23:13] *** cognominal left
[23:30] *** vlixes left
[23:37] *** cognominal_ left
[23:38] *** cognominal_ joined
[23:41] *** zhutingting joined
[23:41] *** spider-mario left
[23:57] *** seldon left
[23:59] <Coleoid> Hi, #perl6...

[23:59] <Coleoid> I'm trying to get my

[23:59] <Coleoid> Windows Rakudo build going...

