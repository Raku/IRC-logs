[00:08] *** stanrifkin joined
[00:15] <pmichaud> diakopter: what version of nqp?  --target=past works for me

[00:16] <pmichaud> (it wasn't working as of last week, no)

[00:18] <pmichaud> you'll need a version of nqp as of 2012.06.1-16-gbec0eba or later.

[00:18] <pmichaud> afk

[00:25] *** samlt left
[00:39] <diakopter> ah

[00:39] <diakopter> thanks

[00:40] <diakopter> oh, maybe the toqast branch (which I'm using) didn't get that patch yet

[00:41] * diakopter tries just to be sure

[00:43] <diakopter> nqp --target=past -e "say(3)"

[00:44] <diakopter> dumps some output, but then ends with:

[00:44] <diakopter> No method cache and no find_method method in meta-object current instr.: 'parrot;Data;Dumper;Default;pmcDefault' pc 242 (runtime/parrot/library/Data/Dumper/Default.pir:203)

[00:49] <diakopter> (and a stack trace)

[00:50] <diakopter> the output just before the error is: "value" => PMC 'int'

[00:55] *** seldon left
[01:10] *** mikemol left
[01:34] *** tyatpi joined
[01:45] *** mikemol joined
[01:48] *** Entonian joined
[02:08] *** Guest30914 left
[02:08] *** Khisanth left
[02:23] *** Khisanth joined
[02:25] *** Entonian left
[02:47] *** xinming joined
[02:48] *** stanrifkin left
[02:50] *** xinming_ left
[02:57] *** stephenlb left
[03:07] *** adu joined
[03:13] *** kcwu joined
[03:31] *** tokuhiro_ joined
[04:19] <[Coke]> ugh. someone borked pugs in roast.

[04:20] *** tokuhiro_ left
[04:23] <lue> rakudo: my int8 $a = 255; say $a; my int8 $b = 256; say $b; # this shouldn't work, should it?

[04:23] <p6eval> rakudo 3e0008: OUTPUT«255␤256␤»

[04:24] <diakopter> r: my int8 $a = 3827982735982739482735523; say $a

[04:24] <p6eval> rakudo 3e0008: OUTPUT«522711971␤»

[04:25] <lue> r: say 522711971.base(16);

[04:25] <p6eval> rakudo 3e0008: OUTPUT«1F27F3A3␤»

[04:26] *** birdwindupbird joined
[04:29] *** tyatpi left
[04:32] *** _jaldhar left
[04:34] <diakopter> r: my int2 $a = 3827982735982739482735523; say $a

[04:34] <p6eval> rakudo 3e0008: OUTPUT«522711971␤»

[04:39] *** jaldhar joined
[04:40] <lue> r: my int8 $a = 0xFFFFFFFF; say $a; say $a.base(16); # this is an interesting bug

[04:40] <p6eval> rakudo 3e0008: OUTPUT«-1␤-1␤»

[04:44] * moritz didn't know rakudo implemented int8

[04:46] <lue> in src/core/natives.pm (although it looks a bit terse. I'm digging through rakudo's code to see if I can find what might be going wrong)

[04:46] <moritz> well, what you're doing wrong is assigning a number that's too big to hold in an int8

[04:47] <moritz> not much rocket science necessary to diagnose that :-)

[04:48] <lue> Of course, but it's handling that wrongly (unless int8 doesn't mean 8-bit, my int8 $a = 256 should fail)

[04:48] <moritz> but as the comment says, it's stubbed in, not really implemented

[04:49] <diakopter> but should it throw an error, always be 255 if it's higher, or do some modulus pretending to rollover

[04:50] <lue> (I found nativesize in NativeHOW, but it doesn't seem to do much there.)

[04:51] <moritz> it is mainly used for NativeCall.pm

[04:52] *** jaldhar left
[04:52] <lue> I just started messing with native types (for no reason) and found these interesting problems, that's all.

[04:55] *** jaldhar joined
[05:18] *** thelazydeveloper left
[05:19] *** adu left
[05:20] *** adu joined
[05:21] *** adu left
[05:21] *** adu joined
[05:22] *** adu left
[05:23] *** adu joined
[05:24] *** adu left
[05:24] *** adu joined
[05:25] *** adu left
[05:25] *** adu joined
[05:26] *** adu left
[05:29] <dalek> roast: 1e47107 | coke++ | / (20 files):

[05:29] <dalek> roast: pugs fudge

[05:29] <dalek> roast: review: https://github.com/perl6/roast/commit/1e471071fb

[05:30] <dalek> Pugs.hs: 7c05564 | coke++ | t/spectest.data:

[05:30] <dalek> Pugs.hs: these tests have changed too much to run

[05:30] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/7c05564ee3

[05:42] <[Coke]> there, that's a little better.

[05:43] <[Coke]> r: say 22847 * .4 - 9079

[05:43] <p6eval> rakudo 3e0008: OUTPUT«59.8␤»

[06:45] *** birdwindupbird left
[07:12] *** zby_home_ joined
[07:47] *** fgomez left
[07:49] *** fgomez joined
[07:51] *** GlitchMr joined
[08:07] *** samlt joined
[08:14] *** seldon joined
[08:15] *** seldon left
[08:16] *** seldon joined
[08:16] <sisar> hi, maybe someone can help me with C++ structs: http://ideone.com/o2SlU . Why do line 9 and line 10 both work ? Are the innner braces in line 10 just ignored ?

[08:24] <seldon> Yes and no. What you do in line 9 is inherited from C and generally considered bad style; it fills the POD struct in order of appearance. In this particular case that comes out the same, but if you fill substructs/arrays partially, you'll see differences.

[08:29] <seldon> Compare http://codepad.org/lu0FnPv3

[08:29] <sorear> huh, wow

[08:29] <sorear> a fact about C that I didn't know

[08:30] <sorear> I thought you needed the braces

[08:30] <sorear> seldon++

[08:30] <seldon> You do not technically need them, but you really should want them there.

[08:31] <seldon> Another little-known C fact: char const *foo = "Hello" ", " world."; is the same as char const *foo = "Hello, world."; This is useful for multi-line literals.

[08:32] *** kaare_ joined
[08:32] <seldon> I'm sorry, that's  char const *foo = "Hello" ", " "world."; of course.

[08:33] <shachaf> That C fact is much less little-known than the other one.

[08:34] <shachaf> It's also used a lot for e.g. preprocessor things.

[08:34] <seldon> Huh. I always thought it was the other way around.

[08:34] <shachaf> Well, I didn't know the brace thing, at least.

[08:35] <shachaf> On the topic of fun C facts: Can you guess what http://mauke.hopto.org/stuff/c/sizeof.c prints?

[08:35] <seldon> Depends on the platform. How large is int?

[08:35] <seldon> And is ASCII assumed?

[08:36] <seldon> On x86 and x86-64, it would be the ascii value of e, which is 101, if I'm not mistaken.

[08:36] <sorear> *sequesters*

[08:36] <shachaf> seldon: On your platform.

[08:37] <sorear> I made the same guess

[08:37] <shachaf> Try it and see!

[08:38] <sorear> but I don't really care about behavior in this case

[08:38] <seldon> Ah, wait. sizeof(0) is not int, it's siez_t.

[08:38] <seldon> *size_t

[08:38] <shachaf> The answer to that puzzle was surprising enough that it made me change my C habits.

[08:38] <seldon> So that could be 8.

[08:38] <sorear> sizeof(0) is stupid code and I think it's safe to just pretend it's undefined behavior

[08:38] <sorear> since 0 doesn't realllly have a type

[08:39] <shachaf> shachaf@carbon:~/c$ cc -o sizeof sizeof.c && ./sizeof

[08:39] <shachaf> 1

[08:39] <sorear> the only other circumstance I can think of where the type of 0 actually matters is implicit argument promotions for printf, where 0 is treated as int

[08:40] <seldon> 0 is of type int, yes. And the size_t thing I said just now was stupid, please ignore it.

[08:40] <sorear> mmh, stupid precedence.

[08:40] <seldon> Oooh.

[08:41] <seldon> Right, sizeof binds less strongly than []. I don't think I've ever run into that before, and I've been coding C and C++ for over a decade.

[08:42] <shachaf> sizeof on values doesn't actually use parentheses at all.

[08:42] <shachaf> Though I think [] is the only case where that makes a noticeable difference.

[08:42] <shachaf> Still, I've stopped doing sizeof(val). :-)

[08:43] <seldon> http://en.cppreference.com/w/cpp/language/operator_precedence <-- there are a few others, but you'd not expect to use them on a size_t.

[08:44] <seldon> Or, if they're unary, the question does not arise.

[08:44] <seldon> Mind you, you don't *really* expect to use [] on a size_t either.

[08:44] <seldon> If you use index[array] in production code, you ought to be fired.

[08:46] <shachaf> So no use for this fact in the underhanded C contest. :-(

[08:46] <seldon> You can still use that sizeof's argument is not evaluated at runtime. n = sizeof(x++); does not change x.

[08:47] <seldon> Nor sizeof x++, if you prefer.

[08:47] <shachaf> (sizeof x)++

[08:48] <seldon> That will get you a compiler error about requiring an lvalue.

[08:48] <shachaf> Yes.

[08:57] * sisar back

[08:57] <sisar> seldon++: thanks !

[08:57] <seldon> You're welcome.

[08:57] <seldon> Bringing the discussion back to perl 6, I have written tests for my little brainfuck module now, and the utility class I wrote to do that has, I think, the potential to be more useful than the actual module. It's modelled after IO but reads/writes from/to a Str -- the idea is akin to C++'s stringstream.

[08:58] <sorear> Does n = sizeof(n++) count as a sequence point error?

[08:58] <seldon> No, n++ is never evaluted.

[08:59] <sorear> seldon: bear in mind that i/o internals are not at all stabilized

[08:59] <sorear> your module sounds useful today

[09:02] <seldon> Well, if it is superceded by something more solid, I have no problems with that. And there are some design issues; mostly how to handle eof and the IO methods a stringstream cannot reasonably support.

[09:02] <seldon> And, you know, it was thrown together in a day by someone who's been writing perl6 for a week, so there *may* be room for improvement in the implementation.

[09:03] <seldon> http://codepad.org/jpcgJTS9 <-- this is what I have now.

[09:06] <tadzik> seldon: I don't quite understand why you have both a public accessor for $.eof and check_eof method

[09:06] <seldon> the check_eof method is meant to set eof to true if $!data is empty, since eof is only reached after you try to read past the end of the file.

[09:06] <seldon> eof handling is not really there yet, though.

[09:07] <tadzik> I see. I just think it's bound to confuse people, who would call .eof and see a false value where it should really be true, etc

[09:07] <tadzik> maybe just go for a private $!eof and a public method eof which does the calculations anyway

[09:07] <seldon> Is that consistent with IO?

[09:07] <seldon> If I open an empty file, is it eof right away?

[09:08] <tadzik> I don't know

[09:08] <seldon> I'll check.

[09:10] <seldon> No, it's not.

[09:10] <seldon> It's the same behaviour as in other languages, which I think is good. The eof flag is only set after something has tried to read past the end of the file.

[09:12] <tadzik> so you would tell users to always use .eof and the rest of the module is responsible for always keeping it up-to-date?

[09:13] <seldon> I want users to be able to use eof when they'd use eof on an IO object.

[09:13] *** sergot joined
[09:13] <sergot> hi o/

[09:13] <seldon> Hi

[09:13] <seldon> It should be as much of a drop-in replacement as possible.

[09:14] <tadzik> hello seldon 

[09:14] <tadzik> erm, sergot 

[09:16] <seldon> The main eof design question, I think, is what happens if a StringIO is eof and something writes to it. Does it remain eof or do the write ops unset it? And what if what was written to it is an empty string or suchlike?

[09:23] *** MayDaniel joined
[09:27] *** nodmonkey joined
[09:31] *** seldon_ joined
[09:31] *** seldon left
[09:31] *** seldon_ is now known as seldon

[09:36] *** _ilbot joined
[09:41] <seldon> r: ''.encode.decode;

[09:41] <p6eval> rakudo 3e0008:  ( no output )

[09:41] <seldon> r: say ''.encode.decode;

[09:41] <p6eval> rakudo 3e0008: OUTPUT«␤»

[09:43] <seldon> To the .deb package building cave!

[09:44] *** Infiltrator joined
[09:45] <Infiltrator> Hi all.  Could somebody please explain to me what is meant by "perl 6 is the little sister of perl 5"?  Is perl 6 not planned to superseed perl 5?

[09:46] <moritz> perl 6 is planned to superseed *all* other dynamic languages :-)

[09:46] <moritz> but the perl 5 folks will continue to develop their language, modules etc.

[09:51] <nodmonkey> I take the 'little sister' to mean younger, less mature. I agree it does have connotations that it is or is intended to be 'perl lite' or something. The language and design of the perl6.org site is  an interesting one; I hope it's not something that turns people off.

[09:52] <moritz> the idea is to turn off the wrong kind of people

[09:53] <seldon> I have a hard time googling this: In IO.pm I see proto method print(|$) { * }; is this meant to auto-flatten stuff that doesn't fit the other print signatures?

[09:53] <moritz> no

[09:53] <moritz> it is supposed to match any possible argument list

[09:54] <moritz> the proto re-dispatches to the various multi candidates

[09:54] <moritz> so its signature must allow anything that any of its candidates can match

[09:55] <jnthn> good noon, #perl6 :)

[09:55] <seldon> it seems to do that without the proto too, though.

[09:55] <seldon> since the other prints are declared with multi

[09:55] <jnthn> seldon: A proto like the one you saw in the setting gets auto-generated for you.

[09:55] *** ivan`` joined
[09:55] <seldon> Ah.

[09:55] <sorear> good jnthnnoon

[09:56] <jnthn> seldon: Or, if you add candidates in a nested scope, the outer proto is cloned.

[09:56] <jnthn> hi sorear :)

[09:57] <nodmonkey> The risk being you turn off new interest from the 'right kind of people' too because they don't see true objective of having pretty butterflies.

[09:58] <moritz> there's that, yes

[10:01] <Timbus> im more annoyed by the barren wasteland that is the rakudo website

[10:02] <Timbus> annoyed is the wrong term

[10:02] <Timbus> irked? worried? idk. its deader than a zen rock garden

[10:02] <nodmonkey> It keeps away the other wrong kind of person.

[10:03] <Timbus> a couple of people offered to make a more modern looking layout for p6.org but never delivered

[10:04] <Timbus> not that they were really encouraged to do it anyway :<

[10:07] <moritz> speaking of layouts

[10:07] <moritz> th doc.perl6.org website could use some layout love

[10:09] <Timbus> I would do it, if I weren't an awful designer

[10:10] <Timbus> my design choice is always 'throw bootstrap.css at it'. working pretty well so far

[10:13] <seldon> Okay, I think I gave the StringIO class reasonably sane eof behaviour. What you write in one end comes out the other, and writing to an eof'd stream uneofs it. StringIO class: http://codepad.org/yySYEpMX Tests: http://codepad.org/K0ZNY23d

[10:14] <moritz> seldon: now please put it in a git repo, add a META.info file and make it available as an installable module :-)

[10:15] <seldon> Is there a way to do it with mercurial?

[10:16] <Timbus> blasphemer!!!

[10:16] <seldon> I thought you'd like mercurial, what with the butterfly and all. :o

[10:16] <Timbus> http://hg-git.github.com/

[10:17] <moritz> well, we might not want to limit ourself to git and github forever

[10:17] <moritz> so it would be a nice experiement to do it with hg, and tadzik and I will try to patch the ecosystem to make it work

[10:18] <Timbus> s' a good idea

[10:19] <moritz> and I think panda is sufficiently modularized that it might not be such a big change

[10:20] <seldon> If that doesn't pan out, I've been meaning to look into git somewhen anyway. That time could be now, I suppose.

[10:21] <jnthn> Timbus: The Rakudo website last got updated just over a week ago. That doesn't feel so dead. What kind of aliveness are you wanting? :)

[10:22] <jnthn> More content beyond release announcements? Nicer layout/design? Something as "first post" on the homepage that isn't a release annoncement? I can kinda see the point of all of these...

[10:23] <Timbus> all of those

[10:23] <Timbus> yep

[10:23] <seldon> More release announcements.

[10:23] <moritz> seldon: that's just a question of time :-)

[10:23] *** Patterner left
[10:24] <seldon> A higher release announcements / time ratio.

[10:24] <moritz> but why?

[10:24] <dalek> doc: 5f283aa | moritz++ | / (2 files):

[10:24] <dalek> doc: [Positional] method of; indexing is done with postcircumfix; update TODO

[10:24] <dalek> doc: review: https://github.com/perl6/doc/commit/5f283aad0b

[10:24] <seldon> Because bleeding edge. :P

[10:24] <moritz> for many, one per month is close to too much

[10:24] <moritz> if you want more, build stuff from git

[10:24] <seldon> I'm not entirely serious.

[10:24] <moritz> ok :-)

[10:24] *** Psyche^ joined
[10:24] *** Psyche^ is now known as Patterner

[10:25] <Timbus> i always enjoyed reading the parrot blogs and stuff a few years ago. why aren't your 6model and advent calendars and perlgeek.de blogs all on rakudo.org? theyre all relevant

[10:25] <moritz> Timbus: there's planetsix.perl.org for getting them all

[10:25] <Timbus> yes this is true

[10:26] <moritz> nqp: my $x := try { 1 }; say($x)

[10:26] <p6eval> nqp: OUTPUT«1␤»

[10:26] <moritz> nqp: my $x := try { 42 }; say($x)

[10:26] <p6eval> nqp: OUTPUT«42␤»

[10:26] <Timbus> but 'a new month passed heres what changed' is just pretty 'eh'

[10:26] * moritz stupid

[10:27] <Timbus> also what happened to try.rakudo.org that was a neato page

[10:27] <moritz> lack of maintainer happened to it

[10:29] <Timbus> it needs maintenance?

[10:29] <moritz> yes

[10:30] <seldon> Thus spake the master programmer: "Though a program be but three lines long, someday it will have to be maintained."

[10:30] <shachaf> I have a tool that makes sure my three-line-long programs will never have to be maintained.

[10:31] <moritz> shachaf: is it called 'rm'?

[10:31] <huf> either that, or a text editor

[10:31] <shachaf> Yep!

[10:31] <huf> you add more lines to it and maintain that!

[10:31] <Timbus> cant you share p6eval's backend

[10:32] <moritz> Timbus: p6eval executes each statement in a separate interpreter/compiler

[10:32] <moritz> Timbus: so you can't remember declarations etc.

[10:33] <Timbus> bah

[10:34] <moritz> "bah" is a good reaction, yes

[10:49] *** spaceships joined
[11:04] *** spaceships left
[11:10] <dalek> rakudo/nom: 9428315 | moritz++ | src/Perl6/World.pm:

[11:10] <dalek> rakudo/nom: make World.rethrow more robust, harmil++

[11:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/94283154d1

[11:18] *** samlt left
[11:18] *** mikemol left
[11:19] *** MayDaniel left
[11:19] *** samlt joined
[11:22] *** whiteknight joined
[11:23] *** whiteknight is now known as Guest46314

[11:26] <moritz> any idea why this patch fails? http://moritz.faui2k3.org/tmp/0001-do-not-use-a-nested-class-for-Backtrace-Frame.patch

[11:27] <moritz> $ ./perl6 --ll-exception -e 'try { die "foo" }; say $!.backtrace.perl'

[11:27] <moritz> Could not find symbol 'Backtrace::&Frame'

[11:28] <moritz> the backtrace points to  $new.push: Backtrace::Frame.new( ... )

[11:29] <moritz> r: my class A::B { }; my class A { method x { say A::B } }

[11:29] <p6eval> rakudo 3e0008:  ( no output )

[11:29] <moritz> r: my class A::B { }; my class A { method x { say A::B } }; A.x

[11:29] <p6eval> rakudo 3e0008: OUTPUT«Could not find symbol 'A::&B'␤  in method x at /tmp/OvsGZroBwS:1␤  in block <anon> at /tmp/OvsGZroBwS:1␤␤»

[11:29] <moritz> oh

[11:30] <moritz> so how do I do that then?

[11:30] <jnthn> That should probably work. Though I suspect the workaround is...

[11:31] <moritz> r: my class A { class B { ... }; method x() { say A::B } }; my class A::B { }; A.x

[11:31] <p6eval> rakudo 3e0008: OUTPUT«B()␤»

[11:31] <jnthn> r: my class A { ... }; my class A::B { }; my class A { method x { say A::B } }; A.x

[11:31] <p6eval> rakudo 3e0008: OUTPUT«A::B()␤»

[11:31] <jnthn> It's meant to steal the .WHO of the stub. Wonder why it doesn't.

[11:32] <moritz> so, it's a bug?

[11:32] *** birdwindupbird joined
[11:33] *** GlitchMr left
[11:34] *** mikemol joined
[11:35] <moritz> ... submitted

[11:42] *** MayDaniel joined
[11:53] *** JimmyZ joined
[11:53] <dalek> doc: f521d36 | moritz++ | lib/Backtrace/Frame.pod:

[11:53] <dalek> doc: document Backtrace::Frame

[11:53] <dalek> doc: review: https://github.com/perl6/doc/commit/f521d36dd4

[12:21] *** nodmonkey left
[12:29] *** topologist left
[12:29] *** topologist joined
[12:35] *** birdwindupbird left
[13:17] *** GlitchMr joined
[13:20] <masak> hola, #perl6

[13:23] <sisar> hi masak !

[13:23] <eiro> ola everybody

[13:30] <colomon> o/

[13:31] *** MayDaniel left
[13:48] *** tokuhiro_ joined
[13:50] *** birdwindupbird joined
[14:03] *** thelazydeveloper joined
[14:07] *** cognominal_ left
[14:12] <tadzik> oh hey

[14:13] *** MayDaniel joined
[14:24] <arnsholt> jnthn: You around?

[14:29] *** PacoAir joined
[14:35] *** tokuhiro_ left
[14:35] *** tokuhiro_ joined
[14:39] *** tokuhiro_ left
[14:41] <jnthn> hi, arnsholt 

[14:42] <arnsholt> Looking at CArray.c, it looks like it supports most of the different sized int/num types, that right?

[14:42] <jnthn> I don't know that it considers size yet.

[14:42] <jnthn> oh, I'm mistaken! :)

[14:43] <jnthn> Yes, it seems to do those :)

[14:44] <arnsholt> Excellent. Then I'll remove that entry from the TODO file as well

[14:44] <arnsholt> I'm starting to think about sized things for structs

[14:44] *** moukeddar joined
[14:45] <jnthn> nice :)

[14:45] <arnsholt> Do you happen to know off-hand if there's a single correct answer for packing non-word sized things?

[14:45] <jnthn> Just need to be careful with alignment.

[14:45] <jnthn> It's generally about where things start.

[14:45] *** moukeddar left
[14:45] <arnsholt> Yeah, ISTR that usually things should be word-aligned, no?

[14:47] <jnthn> It's a bit more subtle than that.

[14:47] <arnsholt> I'd like to do something about not being able to assign to (non-reference) struct fields as well, but that'll require more guidance I think

[14:47] <jnthn> A struct which is just a bunch of int8s will have them laid out one after the other, for example.

[14:47] <jnthn> It depends on the contents of the structure.

[14:48] <arnsholt> Right

[14:48] <arnsholt> So I'll need to keep track of if I have partial words left for small-ish things?

[14:48] *** seldon left
[14:49] <jnthn> Yeah

[14:49] <jnthn> http://en.wikipedia.org/wiki/Data_structure_alignment#Typical_alignment_of_C_structs_on_x86 has a bunch of examples for how it is on x86/x64

[14:49] *** seldon joined
[14:49] <arnsholt> Awesome. Cheers!

[14:51] *** nodmonkey joined
[14:51] <arnsholt> A double is apparently eight-byte-aligned on Windows and 4-byte-aligned on Linux. Great =)

[14:52] *** nodmonkey left
[14:53] <jnthn> arnsholt: See also http://www.wambold.com/Martin/writings/alignof.html

[14:53] <arnsholt> Oh, that's useful!

[14:56] <arnsholt> Does Parrot have any official types similar to uint8_t and friends, or should I just use the C99 types?

[14:58] <tadzik> I suppose using C99 types may get nasty on Windows, no?

[14:58] <jnthn> It defines Parrot_int1 (for 1 byte = 8 bits), etc.

[14:58] <jnthn> tadzik: Yeah, 'cus MSVC doesn't do C99

[14:58] <tadzik> right

[14:59] <arnsholt> Excellent

[14:59] <arnsholt> Yeah, I remember Parrot targeting C89

[14:59] <arnsholt> (targetting?)

[14:59] <seldon> vc2010 has stdint.h (and <cstdint>). Not much else from C99, though.

[15:01] <seldon> Up to vc2008, you had to roll your own typedef unsigned __int64 uint64_t;

[15:02] <hoelzro> hi Perl6 folk, I found some interesting and (to me) unexpected behavior with Rakudo and temp variables

[15:02] *** lichtkind joined
[15:02] <hoelzro> running this script should demonstrate what I mean: https://gist.github.com/3071300

[15:03] <hoelzro> I see weird behavior when using temp variables and recursive calls

[15:03] <moritz> r: https://gist.github.com/3071300

[15:03] <p6eval> rakudo 942831: OUTPUT«before: 0␤after: 0␤before: 0␤after: 10␤»

[15:04] <moritz> yep, looks like over-sharing

[15:04] <moritz> shoudl be all 0

[15:06] <arnsholt> Hmm. Apparently my gcc doesn't like ALIGNOF

[15:06] <hoelzro> right

[15:06] <hoelzro> moritz: is that a bug?

[15:06] <moritz> hoelzro: yes

[15:06] <hoelzro> yay, I found a bug!

[15:08] <lichtkind> hoelzro++ :)

[15:12] * jnthn away for a bit

[15:24] *** mtk joined
[15:26] *** JimmyZ left
[15:27] *** lue left
[15:31] <pmichaud> good morning, #perl6

[15:33] <seldon> Good afternoon.

[15:40] <masak> pmichaud! \o/

[15:40] <hoelzro> let's say I have a superclass and a set of subclasses. I'd like to have a create method on the supreclass to serve as a factory method for subclasses, but Rakudo complains that it doesn't have a definition for the subclass in the factory method.  Here's an example of what I'm trying to achieve: https://gist.github.com/3071368

[15:41] *** lue joined
[15:42] <GlitchMr> perl6: say 'a' x 30 ~~ /a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?a?aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa/

[15:42] <p6eval> rakudo 942831, niecza v19-13-g442e075: OUTPUT«(timeout)»

[15:42] <pmichaud> hoelzro: that looks to me like a variant of RT #114034

[15:43] <arnsholt> Durr. Apparently GCC only has __builtin_offsetof(t,m) not offsetof(t,m)

[15:43] <seldon> You have to #include <stddef.h> for offsetof

[15:44] <arnsholt> Aha! That explains it. Thanks!

[15:44] <hoelzro> ooooh

[15:44] <hoelzro> pmichaud: thanks!

[15:44] <hoelzro> so it's not a declaration order thing at all

[15:45] <hoelzro> I'm thinking of not even using a subclass relationship and just defining a local "Stanzaesque" role for each class to consume

[15:45] <pmichaud> technically these aren't subclasses in your gist :)

[15:47] <pmichaud> they're just classes that are in three namespaces sharing a common Hexe::Stanza root

[15:47] <hoelzro> pmichaud: right, I forgot that bit =)

[15:49] <masak> r: say my @pascal = 1; say @pascal = @pascal, 0 Z+ 0, @pascal for ^10

[15:49] <p6eval> rakudo 942831: OUTPUT«1␤1 1␤1 2 1␤1 3 3 1␤1 4 6 4 1␤1 5 10 10 5 1␤1 6 15 20 15 6 1␤1 7 21 35 35 21 7 1␤1 8 28 56 70 56 28 8 1␤1 9 36 84 126 126 84 36 9 1␤1 10 45 120 210 252 210 120 45 10 1␤»

[15:50] <masak> man, that is short ;)

[15:50] <tadzik> This is madness!

[15:50] *** moukeddar joined
[15:50] <masak> this. is. #perl6.

[15:51] <tadzik> \o/

[15:51] <seldon> That is cool, at any rate.

[15:51] <tadzik> >-<-o

[15:51] * tadzik falls into a well

[15:51] <masak> I didn't even push him!

[15:51] <tadzik> I'm a ghost of an unpushed commit

[15:52] *** topologist left
[15:55] <seldon> If I want to supply a conversion operator, do I just declare a method Str returns Str?

[15:56] <masak> aye.

[15:56] <pmichaud> multi method, probably

[15:56] <seldon> Why multi?

[15:56] <pmichaud> you probably don't want to overload the meaning of .Str for the type object

[15:56] <masak> r: my @a = [1, 2], [3, 4]; my @b = [10, 20], [30, 40]; say (@a Z+ @b).perl; say (@a ZZ+ @b).perl

[15:56] <p6eval> rakudo 942831: OUTPUT«(4, 4).list␤(11, 22, 33, 44).list␤»

[15:57] <masak> \o/

[15:57] <seldon> Ah.

[15:57] <seldon> So multi method Str(StringIO:D) returns Str { ... } ?

[15:57] <pmichaud> seldon: yes, something like that

[15:57] <pmichaud> need a colon after the D

[15:57] <seldon> Right, right. Typo.

[15:57] <hoelzro> I have a type (Hexe::JID) that can create an instance from a String; is it possible to declare a type constraint on a method parameter that would automatically coerce a Str to a Hexe::JID?

[15:58] <tadzik> as Str

[15:58] <hoelzro> ex. has Hexe::JID $!from; submethod BUILD(:$!from) {}

[15:58] <tadzik> r: sub foo($a as Str) { say $a.WHAT }: foo 5

[15:58] <p6eval> rakudo 942831: OUTPUT«===SORRY!===␤Confused␤at /tmp/bji8U351ly:1␤»

[15:58] <tadzik> r: sub foo($a as Str) { say $a.WHAT }; foo 5

[15:58] <p6eval> rakudo 942831: OUTPUT«Str()␤»

[15:58] <tadzik> I think that's what you mean

[15:58] <pmichaud> tadzik: I think he wants to go the other way

[15:58] <hoelzro> I do

[15:58] <tadzik> hmm, let me reread that

[15:58] <tadzik> oh, I see

[15:58] <pmichaud> he wants to go from Str to Hexe::JID

[15:59] <hoelzro> I want to coerce a Str into a Hexe::JID

[15:59] <pmichaud> I'm not sure there's a way to do that (that works right now)

[15:59] <tadzik> there's a way to declare something of this sort I think; setting does it in a few places

[15:59] <pmichaud> the problem is the coercion to something in a nested namespace

[15:59] <tadzik> oh hmm

[16:00] <pmichaud> although I did have a proof of concept of a coercer yesterday.... just a sec

[16:00] *** MayDaniel left
[16:00] <hoelzro> ok

[16:00] <hoelzro> thanks for answering all of my silly questions, btw =)

[16:00] <hoelzro> I intend to write a blog post after I'm done with this to illustrate all the stuff I've learned

[16:01] <hoelzro> and maybe enhance the docs a bit =)

[16:01] <pmichaud> https://gist.github.com/3063969  # writing a Type() coercer

[16:01] <sisar> ++hoelzro

[16:01] <pmichaud> ...but I don't know what the 'as' keyword ends up using to do its coercion.  Just a sec

[16:01] <masak> this is for moukeddar :)

[16:02] <masak> r: my @mothers = <Anne Vivian Sylvia>; my @fathers = <Ben Waldo Thomas>; for @mothers Z @fathers -> $mother, $father { say "$mother is married to $father" }

[16:02] <p6eval> rakudo 942831: OUTPUT«Anne is married to Ben␤Vivian is married to Waldo␤Sylvia is married to Thomas␤»

[16:03] <masak> r: my @rows = 1..3; my @columns = 1..5; for @rows X @columns -> $row, $column { say "($row, $column)" }

[16:03] <p6eval> rakudo 942831: OUTPUT«(1, 1)␤(1, 2)␤(1, 3)␤(1, 4)␤(1, 5)␤(2, 1)␤(2, 2)␤(2, 3)␤(2, 4)␤(2, 5)␤(3, 1)␤(3, 2)␤(3, 3)␤(3, 4)␤(3, 5)␤»

[16:03] <pmichaud> looks like 'as' is expecting the method form to work :-/

[16:03] <pmichaud> https://gist.github.com/3071483   # example using 'as'

[16:04] <moukeddar> wow, never saw somthing like this

[16:04] <pmichaud> If we switch 'as' to instead call postcircumfix:<( )> on the type object, and combine that with sorear++'s suggestion at http://irclog.perlgeek.de/perl6/2012-07-07#i_5793391, then we could get 'as Type' to use either the Type or method form.

[16:04] <hoelzro> pmichaud: thanks!

[16:04] <hoelzro> pmichaud++

[16:06] <pmichaud> note that the use of postcircumfix:<( )> as coercer is already mentioned/covered at S13:135.... I think we may just need to get other parts of the spec to start using that.

[16:06] <masak> moukeddar: Perl 6 is quite cool lon all levels. this is just the "data processing" level. I really like the text handling and object orientation as well. and there are other bits too which I can't think of now.

[16:06] <masak> on*

[16:07] <masak> moukeddar: did you see how we do the fibonacci sequence? :)

[16:07] <pmichaud> Also, perhaps we should update S13 to note that the invocant to postcircumfix:<( )> should be marked :U (or :T) if it's to be used as a coercion.

[16:07] <moukeddar> i could say this is shocking to me, a whole new paradigm (i guess)

[16:07] <masak> r: constant @fib = 1, 1, *+* ... *; say @fib[^10]

[16:07] <p6eval> rakudo 942831: OUTPUT«1 1 2 3 5 8 13 21 34 55␤»

[16:08] <masak> moukeddar: *+* just means "take two things (not yet specified) and add them"

[16:08] <moukeddar> seriously?

[16:08] <masak> moukeddar: we call the '*' term "Whatever".

[16:08] <masak> r: say (*+*)(3, 4)

[16:08] <p6eval> rakudo 942831: OUTPUT«7␤»

[16:09] <masak> moukeddar: srsly.

[16:10] <tadzik> see also: { $^a + $^b }

[16:10] <tadzik> which look cleaner, while being almost exactly the same things

[16:11] <tadzik> or: -> $a, $b { $a + $b }

[16:11] <tadzik> or sub ($a, $b) { $a + $b }

[16:11] <moukeddar> is this like lambda expressions?

[16:11] <tadzik> yep

[16:11] * tadzik afks

[16:11] <moukeddar> nice :)

[16:12] <seldon> These fit in &argument slots, right?

[16:12] <masak> yes, they are blocks that bind parameters. which is another way of saying "yes, they are lambda expressions" :)

[16:13] <masak> the thing that *+* helps you with is that you don't have to type the {} for the block, and you don't have to name $^a and $^b.

[16:13] <moukeddar> but without the "=>" operator

[16:13] <masak> from C#?

[16:13] <masak> with us it's ->, like tadzik wrote above.

[16:14] <masak> and we write it before the params, not after.

[16:14] <moukeddar> now that's weird lol

[16:15] <masak> if you squint, it looks like a tilted λ :)

[16:16] *** cognominal joined
[16:17] <seldon> Since there are already unicode operators, would it not be easier to just use λ?

[16:17] *** Guest77817 left
[16:17] <moukeddar> kinda, you know what baffles me the most, is how it gets parsed,

[16:17] *** ponbiki joined
[16:17] *** ponbiki is now known as Guest19154

[16:18] <masak> moukeddar: not so strange. the parser sees a '->' and knows that a parameter list is coming, and then a block.

[16:18] <moukeddar> now i undertsant that article you sent me the other day :) Compilers Compilers

[16:19] <masak> cognominal: so, 'cōgnōmen' means 'nickname', basically? and 'cognominal' means 'related to/having something to do with nicknames'.

[16:19] * moritz is still baffled that Perl 6 can be parsed, at least mostly :-)

[16:19] * masak doesn't know which way to parse moritz' sentence ;)

[16:19] <masak> are you mostly baffled, or that it can be mostly parsed? :P

[16:20] <cognominal> masak, yup.

[16:20] <moritz> mostly parsed

[16:21] <dalek> nqp: 8137a66 | pmichaud++ | src/QRegex/Cursor.nqp:

[16:21] <dalek> nqp: [qregex]  Enable !cursor_more to receive other (ignored) named parameters.

[16:21] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8137a66878

[16:21] <masak> tadzik: -> $a, $b { $a + $b } and sub ($a, $b) { $a + $b } are different beasts in that only the latter binds 'return'.

[16:21] <masak> only the latter takes a continuation that 'return' executes :)

[16:22] <cognominal> maska, also in the production/consumption world that rules us all, I am supposed  to be a cog which works in a nominal  (in Nasa jargon) way meaning according to spec.

[16:22] <cognominal> masak

[16:22] <pmichaud> there's also a difference between -> and sub in how $_ is set up.

[16:23] <cognominal> masak:  http://en.wikipedia.org/wiki/Cognomen

[16:23] <masak> cognominal: nod. so there is a double meaning, too. I think before Strasbourg I had only heard (or at least understood) the latter meaning.

[16:23] <masak> cognominal: yes, I just saw that page :)

[16:23] <moritz> pmichaud: well, the default signature is different

[16:23] <cognominal> http://www.thefreedictionary.com/Cognominal

[16:24] <moritz> hm

[16:24] <moritz> r: $_ = 4; (-> { .say }).()

[16:24] <p6eval> rakudo 942831: OUTPUT«4␤»

[16:24] <moritz> r: $_ = 42; (sub () { .say }).()

[16:24] <p6eval> rakudo 942831: OUTPUT«Any()␤»

[16:24] <pmichaud> r: $_ = 4;  (-> $x { .say })()

[16:24] <p6eval> rakudo 942831: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in block <anon> at /tmp/SmyOsRJDpt:1␤␤»

[16:24] <moritz> right, they are different

[16:24] <pmichaud> r: $_ = 4;  (-> $x { .say })(3)

[16:24] <p6eval> rakudo 942831: OUTPUT«4␤»

[16:25] <moritz> r: $_ = 4;  (-> $_ { .say })(3)

[16:25] <p6eval> rakudo 942831: OUTPUT«3␤»

[16:27] <pmichaud> r: $_ = 4;  (sub ($x) { .say })(3)

[16:27] <p6eval> rakudo 942831: OUTPUT«Any()␤»

[16:28] <cognominal> masak, tadzik, jnthn, btw, my stuff in codeview starts to work even if its place in the great scheme of things is not readily apparent. I am waiting to test it with hairy perl6 parse trees.  https://github.com/cognominal/codeview

[16:28] <moukeddar> so much to learn

[16:29] <masak> cognominal: interesting. keep us posted.

[16:30] <cognominal> masak: I have yet to hook it up with Small Federated Wiki. Anyway, I learnt a few html5 trick by reading their code.

[16:31] <masak> nice :)

[16:43] <sisar> cognominal: are you talking about https://github.com/WardCunningham/Smallest-Federated-Wiki ?

[16:43] <cognominal> yup

[16:45] <cognominal> sisar: there is not much there but the code is clean unlike mine and there are a few things I need and I would be unable to write by myself.

[16:46] <cognominal> Basically it is a html5 wiki. I use html5 as a globbing term for everything useful in the modern web.

[16:46] *** thou joined
[16:46] <sisar> cognominal: i'm still trying to understand _what_ is the Smallest Federated Wiki.. is it a new kind of wiki-engine ?

[16:48] <cognominal> Currently it is a way for cunninngham, the inventor of the wiki, to have a front end for his domotic toys.

[16:49] <sisar> cognominal: and what will hooking up zbrew with SFW achieve ?

[16:49] <masak> 'domotic'?

[16:49] <cognominal> but the building bricks are general enough to be geared to do almost anything wikilike.

[16:51] <cognominal> In a few weeks, I would like to have an irc like tool and be able to drag and drop rakudo code in my code highlighter.

[16:51] <cognominal> Eventually I want rules in the parse path pane to link to Perl6 tutorials.

[16:51] <cognominal> irc is so passé :)

[16:52] <sisar> oh, 'Should eventually be a plugin for Small Federated wiki ", now i get it.

[16:53] *** moukeddar left
[16:53] <cognominal> sisar: sorry the doc as it is is very much for my own consumption

[16:53] <cognominal> masak:  http://en.wikipedia.org/wiki/Home_automation   sorry domotique is the french term

[16:54] <sisar> cognominal: yeah, looks like that

[16:54] <sisar> :)

[16:54] * sisar afk

[16:54] <cognominal> sisar, that will change soon

[16:55] <cognominal> anyway, eiro told me I should enter a proselytism phase. :)

[16:58] *** topologist joined
[16:59] <cognominal> masak: so, is cognominal an autopun?

[17:09] <hoelzro> if I have an attribute name in a variable (let's say $name), can I get the value of that attribute from self?

[17:09] <hoelzro> btw, the attribute is private

[17:09] <hoelzro> if that helps/hurts

[17:10] <jnthn> Well, it's easy if it's public, since you just call the accessor. :)

[17:10] <jnthn> Private is harder.

[17:10] <jnthn> You can get the attribute meta-object and then use .get_value on that.

[17:10] *** lichtkind left
[17:10] <jnthn> iirc

[17:11] <jnthn> What's the use case, though? Often there's a better way :)

[17:11] <hoelzro> jnthn: I'd like to implement gist to print out my object's attributes

[17:12] <hoelzro> ommitting attributes with an undefined value

[17:12] <jnthn> oh

[17:12] <jnthn> r: class A { has $!x = 42; method m() { self.^attributes.map({ .name ~ ' = ' ~ .get_value(self) }).join("\n") } }; A.new.m.say

[17:12] <p6eval> rakudo 942831: OUTPUT«$!x = 42␤»

[17:14] <hoelzro> ok, thanks!

[17:15] <cognominal> jnthn, have you though of the way to access the p6 parse tree. It will piss me off if I go public with my tool displaying a javascript or coffeescript parse tree

[17:16] <arnsholt> Hmm. My initial attempt doesn't cause a segfault or break any existing tests. Not sure if I should be suspicious or pleased

[17:16] <arnsholt> Or both, perhaps

[17:16] <cognominal> I am creating it in the first place for displaying Perl 6 stuff.

[17:18] <jnthn> cognominal: Think I know a way, just gotta try coding it up :)

[17:19] <cognominal> jnthn++

[17:20] <cognominal> coffeescript and jquery are already flooding me, so I have to delegate the hairy Perl 6 part

[17:22] <arnsholt> Hmm. I don't think 4399404817 actually fits in an int8

[17:23] <benabik> Not even close.

[17:24] <arnsholt> jnthn: Should the get_attribute method care about the number of bits in the attribute it's fetching?

[17:26] *** am0c joined
[17:26] <jnthn> arnsholt: The ref case should returns the attribute's location; it's up to the op doing the reading to se sure it pays attention to the correct number of bits.

[17:26] *** benabik left
[17:27] <arnsholt> Yeah, that's what I thought

[17:27] <arnsholt> So I have: is $cobj.int,    17,    'getting int from C-created struct';

[17:27] *** benabik joined
[17:28] <arnsholt> Where $cobj.int is specced as an int8 in the Perl class and char in the C code

[17:29] <arnsholt> And is claims that $cobj.int is 4399404817, which is a bit on the high side

[17:29] <arnsholt> Any thoughts?

[17:29] *** birdwindupbird left
[17:31] <jnthn> Hmmm.

[17:32] <arnsholt> Same thing happens if I create an intermediate int8 and test that, but the value is slightly different

[17:32] <arnsholt> Looks like it's reading into the padding space

[17:34] <jnthn> Ah, yes, repr_get_attr_int doesn't support sized attributes in general at the moment.

[17:34] <jnthn> That's gonna need a little thought.

[17:34] *** benabik_ joined
[17:34] <arnsholt> Ah, right

[17:36] *** benabik left
[17:36] *** benabik_ is now known as benabik

[17:36] <arnsholt> I'll just leave it for the time being then

[17:36] *** snearch joined
[17:36] <arnsholt> Looks like it'll be pretty straightforward, FWIW

[17:56] <sorear> good * #perl6

[17:57] <arnsholt> Hey sorear 

[18:01] *** Guest19154 left
[18:10] *** samlt left
[18:18] *** rsimoes joined
[18:19] *** adu joined
[18:20] <sorear> hello arnsholt 

[18:22] *** quietfanatic joined
[18:23] <quietfanatic> r: say 4399404817.fmt("%x")

[18:23] <p6eval> rakudo 942831: OUTPUT«6399711␤»

[18:23] <adu> hello sorear 

[18:23] <quietfanatic> yup

[18:25] <quietfanatic> jnthn: Shouldn't a simple +& 255 work around the problem for now?

[18:25] <quietfanatic> or arnsholt: rather

[18:27] *** samlt joined
[18:28] *** spider-mario joined
[18:48] <arnsholt> quietfanatic: I suppose, but we can't really tell users of Zavolaj that they'll have to handle that kind of stuff by hand

[18:53] <quietfanatic> Yeah, I meant in Zavolaj itself

[18:53] *** nodmonkey joined
[18:53] <quietfanatic> or is the repr_get_attr_int jnthn++ was talking about part of zavolaj too?

[18:53] <quietfanatic> I probably shouldn't be kibbitzing in matters I don't actually understand :)

[18:55] *** spider-mario left
[18:58] <arnsholt> repr_get_attr_int is in the 6model part of NQP, actually

[18:59] <arnsholt> And it has to do the correct kind of pointer deref, depending on the type of the attr you're getting

[18:59] <arnsholt> Which is the part that requires a bit of thought

[19:03] *** Woodi left
[19:05] <quietfanatic> Is this in Parrotland, or Cland?

[19:06] <arnsholt> NQP C code

[19:06] *** GlitchMr left
[19:07] <quietfanatic> Hm.

[19:20] *** mucker joined
[19:24] *** paul_ joined
[19:24] <paul_> hi all

[19:25] <sorear> Hello and welcome to #perl6.

[19:25] <paul_> i 've been using perl 5 for sometime now

[19:25] <paul_> just a general hacker that uses perl5 for computational biology problems

[19:25] <paul_> i just stumbled upon perl6 and was wondering if i should switch over

[19:25] <paul_> any advice?

[19:25] <quietfanatic> Hm, well, it depends on what you want.

[19:26] <paul_> well, maybe I should rephrase: why would I want to switch to perl6? what are the benefits?

[19:26] <quietfanatic> Do you mostly want more convenient programming?  Go ahead and give Perl 6 a try.

[19:27] <quietfanatic> If you want speed and stability, you're better off staying with Perl 5, at least until Perl 6 matures some more.

[19:27] <seldon> Computational biology means lots of number crunching, right?

[19:27] <quietfanatic> Hm, the benefits

[19:27] <paul_> yeah more convenient is better...I dont' need to worry much about speed and stability

[19:28] <paul_> i'm more into the string handling of DNA sequences rather than statistical number crunching

[19:29] <paul_> how long will Perl 5 be supported?

[19:29] <quietfanatic> As far as I know, Perl 5 will be supported as long as there are people wanting to use it.

[19:29] <paul_> what do you think the usage of perl 5 versus perl 6 is?

[19:29] <quietfanatic> Hmm...

[19:30] <quietfanatic> I'm not sure what you mean

[19:30] *** birdwindupbird joined
[19:30] <quietfanatic> oh, you mean, how many and what kind of people are using each?

[19:30] <paul_> yeah

[19:30] <quietfanatic> Perl 5 is still clearly dominant.  Most of the people using Perl 6 for real work are early adopters.

[19:31] <paul_> is perl 6 syntax easier to understand and write?

[19:31] <masak> paul_: yes, but it depends who you ask too.

[19:35] <masak> paul_: I once had a DNA string that was so long it crashed Perl 5's regex engine. Rakudo was slowish but did fine with it.

[19:35] <paul_> what is Rakudo?

[19:36] <quietfanatic> masak: really?  That's amusing.

[19:36] <quietfanatic> Rakudo is one implementation of Perl 6

[19:36] <quietfanatic> it's the most complete one so far.

[19:37] <paul_> will it work on Mac X or cygwin on Windows?

[19:38] <masak> quietfanatic: yes, really. this was something like three years ago, so Rakudo is slightly faster now. and maybe newer perls don't crash, but I wouldn't bet on it.

[19:38] <masak> paul_: yes.

[19:38] <jnthn> On Windows, best to run it "natively" rather than under cygwin.

[19:39] <jnthn> Though as far as I know it works on cygwin too.

[19:39] <sorear> paul_: tbh I'd be suprised if Perl 6 had more than 100 serious users at this point

[19:40] <arnsholt> Rakudo works fine on OS X as well. I do my stuff mostly on a Mac

[19:40] *** spider-mario joined
[19:40] <quietfanatic> masak: The perl 5 regex engine has undergone many internal improvements lately, as far as I've heard.  For instance, it's become re-entrant.

[19:40] <masak> aye.

[19:41] *** adu left
[19:41] <quietfanatic> paul_: Here's someone's blog describing many of the differences between Perl 5 and 6: http://perlgeek.de/en/article/5-to-6

[19:41] <masak> but the 1 Mb string limit might be quite hard-coded in the regex code. I dunno.

[19:41] <masak> er, MB

[19:41] <moritz> 32k characters, actually

[19:41] <masak> oh, right.

[19:42] <masak> moritz: you know if the limit is still there?

[19:42] <paul_> ok thanks all

[19:42] <masak> quietfanatic: "someone's". moritz'++ :)

[19:42] <quietfanatic> paul_: If you have any questions, feel free to ask them here

[19:42] <masak> er, moritz++'* :)

[19:42] <moritz> masak: it is on 5.16

[19:42] <quietfanatic> yeah

[19:43] <moritz> $ perl -Mre=debug -e '/.{2,}/'

[19:43] <moritz> ...

[19:43] <quietfanatic> I knew perlgeek.de belonged to someone with an m name

[19:43] <moritz>    1: CURLY {2,32767} (4)

[19:44] <masak> moritz++

[19:46] <masak> quietfanatic: yeah, it's hard to keep us apart if you're not a regular, I guess.

[19:47] * masak .oO( mberends is making it easier for us lately, though ) :/

[19:53] <quietfanatic> lunch with f&f &

[19:57] <timotimo> oh, i just noticed, that for 1..3 -> $a { ... } isn't even special syntax, the -> $a just makes a lambda. that's pretty cool

[19:57] <masak> yeah :)

[19:58] *** adu joined
[19:58] <colomon> rn: for 1..3 *.say

[19:58] <p6eval> niecza v19-13-g442e075: OUTPUT«===SORRY!===␤␤Missing block at /tmp/OgPgqOVROT line 1 (EOF):␤------> for 1..3 *.say⏏<EOL>␤␤Parse failed␤␤»

[19:58] <p6eval> ..rakudo 942831: OUTPUT«===SORRY!===␤Missing block␤at /tmp/i9RIQeUGLs:1␤»

[19:58] <colomon> didn't think that would work...

[19:59] <masak> right. except when it is special syntax :P

[19:59] <pmichaud> the 'for' statement does require a block of some sort.  But .map works

[19:59] <pmichaud> rn: (1..3).map(*.say)

[19:59] <p6eval> rakudo 942831, niecza v19-13-g442e075:  ( no output )

[19:59] <pmichaud> rn: (1..3).map(*.say).eager

[19:59] <p6eval> rakudo 942831, niecza v19-13-g442e075: OUTPUT«1␤2␤3␤»

[19:59] <masak> the 'for' needs to be a special form so that we can TTIAR the list and the block.

[20:00] <timotimo> (1..10).map(*.say).race

[20:00] <timotimo> r: (1..10).map(*.say).race

[20:00] <p6eval> rakudo 942831: OUTPUT«No such method 'race' for invocant of type 'List'␤  in block <anon> at /tmp/rOqas1gUn5:1␤␤»

[20:00] <timotimo> ah, NIY i guess?

[20:00] <masak> it's pretty new in the spec.

[20:00] <pmichaud> ...race?

[20:00] <masak> pmichaud: welcome back! :P

[20:00] * masak .oO( also, keep up! ) :P

[20:00] <colomon> race?

[20:01] * masak will get into trouble one of these days for using the "keep up" meme...

[20:01] <timotimo> for when you don't care about the order in which you get the results

[20:01] <masak> colomon: it's "worse than eager".

[20:01] <masak> er, sorry, "worse than hyper".

[20:01] <colomon> but slower than hyper

[20:01] <colomon> ?

[20:01] <colomon> ah.

[20:01] <timotimo> no, it's even faster!

[20:02] <masak> not so much slower as less orderly.

[20:02] <masak> it's "just throw it at me!" mode.

[20:02] <colomon> huh

[20:02] <jnthn> .oO( beware of race conditions... )

[20:02] <colomon> I guess it's not completely useless....

[20:02] <timotimo> a lot of data may be unsorted anyway

[20:03] <timotimo> so why keep the unsorted order?

[20:03] <pmichaud> I'm not exactly sure what .race is to be a method on, though.

[20:03] <masak> jnthn: I din't know you were so sensitive about race.

[20:03] *** adu left
[20:03] <jnthn> :P

[20:05] <colomon> what pm said.

[20:05] * pmichaud just aliases .race to .eager for now :-)

[20:06] <timotimo> is hyper implemented yet?

[20:08] <moritz> r: say <a b c>».uc

[20:08] <p6eval> rakudo 942831: OUTPUT«A B C␤»

[20:08] <moritz> the » is a hyper

[20:08] <timotimo> is it the same as calling .hyper?

[20:09] <timotimo> i think hyper was "don't guarantee execution order, but guarantee return order"?

[20:09] <pmichaud> ...   .hyper?

[20:09] <masak> :P

[20:09] <masak> I've only seen it as a listop, I think.

[20:09] <pmichaud> pmichaud@kiwi:~/p6/specs$ ack '\.hyper'

[20:09] <pmichaud> pmichaud@kiwi:~/p6/specs$ 

[20:10] <timotimo> OK

[20:10] <masak> right, S02 talks about '=head2 The C<hyper> operator'

[20:10] <masak> having it as a method feels strange, because we don't do that kind of Perl 5-like context magickery.

[20:11] <sorear> I'm not certain how race can work at all with current lists

[20:11] <sorear> our iteration system likes to be in-order

[20:11] <pmichaud> I suspect it's a flag passed to iterators

[20:12] <pmichaud> to tell the iterator "feel free to return things in any order you want"

[20:12] <pmichaud> so   .reify(*, :race)   tells the iterator "get as many as you want and give them back to me in whatever order you want"

[20:12] <masak> here's the thing that's "wrong" with the spec from a user documentation point of view. (I just realized this as I re-read the 'race' spec.)

[20:13] <masak> in order to grasp the spec to a sufficient degree, you have to have been already brainwashed by, well, us.

[20:13] <masak> or more specifically, @Larry, to the extent that that group still exists.

[20:14] <masak> if you haven't been brainwashed, what's there looks mostly like a science fiction writer's relaxed musings about programming languages of the future.

[20:15] <moritz> aren't we all a bit @Larry? :-)

[20:15] <masak> yes :)

[20:15] <masak> "...the community's rewrite of the language..."

[20:15] <masak> case in point: "This operator is agnostic towards flattening or slicing.  It merely changes the work-ahead policy for the value generator.  It is a transitive contextualizer insofar as iterators will have to pass on the policy to subiterators."

[20:16] * masak decides to have "It is a transitive contextualizer" put on a t-shirt

[20:16] <pmichaud> masak: bonus points if you can get it to go from your t-shirt to another :-P

[20:16] <masak> *lol*

[20:16] <masak> that would be an awesome autopun!

[20:17] *** paul_ left
[20:17] <timotimo> is that slice context thing still in perl6? haven't seen it yet except for that 5-to-6 article

[20:17] <masak> timotimo: it is, but we're saving S09 for last, apparently :)

[20:17] <masak> er oh wait. slice "context"? hm.

[20:17] *** Coleoid joined
[20:17] <timotimo> yeah, @@( ... )

[20:18] <masak> oh right.

[20:18] <pmichaud> @@( ... ) no longer exists, afaik

[20:18] <lue> hello world o/

[20:18] <masak> ack -Q '@@' on the spec gives nothing.

[20:18] <masak> lue! \o/

[20:19] <lue> hi masak o/ I've been following your text-adventure programming adventure

[20:20] <masak> lue: oh! I'm glad to hear it.

[20:20] <masak> lue: yeah, I figure you'd be interested in that.

[20:20] <masak> lue: does it make any sense? is my audience happy so far?

[20:20] <lue> [ Funny thing is, I spent the last days of June finally learning Inform 6. What a coincidence :) ]

[20:21] * masak .oO( Inform has all the charms and benefits of natlang BDD... )

[20:22] <lue> Yeah, it makes sense, at least so far :) . Your posts are at least teaching me about the magic of events (which I've never even bothered/needed to really know)

[20:23] <dalek> rakudo/nom: 138213a | moritz++ | src/core/Backtrace.pm:

[20:23] <dalek> rakudo/nom: do not use a nested class for Backtrace::Frame

[20:23] <dalek> rakudo/nom: 

[20:23] <dalek> rakudo/nom: mostly so that .WHAT gives the full name

[20:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/138213ad4c

[20:23] <masak> lue: events are indeed magical. we're beginning to use/teach them at $work too, which is awesome.

[20:24] <masak> lue: it's really evident with the last post, where we can just save the whole game because it can be represented as "the events so far".

[20:24] <pmichaud> ...I have "what is the least surprise" question

[20:24] <pmichaud> what kind of thing do we expect    $str.match( / pat /, :global)    to return ?

[20:24] *** snearch left
[20:24] <lue> masak: That's definitely a good side to events that I'll have to remember.

[20:25] <masak> pmichaud: a List of Match?

[20:25] <moritz> or a Match of Match

[20:25] <masak> yeah, those are the two contenders :)

[20:25] <masak> lue: it's also the events that allow me to do the testing I do in the game.

[20:25] * moritz has hacked too much on the subject to be able to talk about least surprise

[20:26] <moritz> and now, sleep

[20:26] <colomon> lazy list of Match?

[20:26] <pmichaud> List of Match is what I'm expecting, also.

[20:26] *** kaare_ left
[20:27] <pmichaud> so, if the pattern never matches, it returns an empty list?

[20:27] *** c1sung left
[20:27] <colomon> .....yes?

[20:28] <pmichaud> if the :global isn't present, so that we have   $str.match( / pat / )    we just return the match object (whether failed or successful) ?

[20:28] * colomon must admit that Match has always had weird magic going on from his perspective, and anything that simplifies it is a bonus....

[20:29] * colomon apologizes if he is talking nonsense, but there is a three-year-old three feet away loudly insisting that the Union Pacific train is going to go into the river unless I wave the lantern to signal it to stop....

[20:30] <pmichaud> Match has some strange semantics, yes, at least according to S05.  I'm hoping to clean it up a bit.

[20:30] <colomon> is there any real advantage to having the single pattern match that fails return a Match object?  does it have information about why the match failed?

[20:31] <pmichaud> it has information about the match, such as the original thing being matched against

[20:31] <pmichaud> it doesn't indicate why the match failed or anything like that.

[20:31] <colomon> huh

[20:32] <colomon> is there some advantage I'm not seeing to retaining the thing being matched against?

[20:32] <pmichaud> but returning the Match object means that when printed you can get "failed Match"  instead of just an empty list.

[20:32] <pmichaud> r:  say 'abc'.match( /x/ )

[20:32] <p6eval> rakudo 942831: OUTPUT«#<failed match>␤»

[20:32] <colomon> (by which I mean, it seems like it would generally be very easy to save the thing being matched yourself.)

[20:33] <colomon> n: say 'abc'.match( /x/ )

[20:33] <p6eval> niecza v19-13-g442e075: OUTPUT«Match()␤»

[20:33] <pmichaud> getting '#<failed match>' seems more useful/informative than getting an empty list in this case, yes.

[20:35] <colomon> Yeah, I guess there's something to that.

[20:35] <colomon> huh

[20:36] <pmichaud> a similar question is     'abc'.match( /./, :nth(6) )

[20:36] <colomon> does that seem to imply that maybe .match(/ pat /, :global) is a bad idea?  (because it returns a different kind of thing.)  maybe .match-global(/pat/) would be an improvement?

[20:37] <pmichaud> .match-global doesn't seem to resolve the difficulty I'm looking at, no.

[20:37] <pmichaud> I'm fairly certain that    'abc'.match( /./, :nth(2) )   should return a match object

[20:38] <pmichaud> and   'abc'.match( /./, :nth(1,3) )    should return a List of match objects

[20:38] <colomon> agreed, assuming 'abc'.match(/./) returns a Match object (on :nth(2))

[20:39] <masak> cognominal: hm, is 'cognominal' an autopun? well, it *does* confuse use and mention, but not quite in the way I'm used to. I don't consider things like "brief" or "word" to be autopins either, just autologues.

[20:40] *** c1sung joined
[20:40] <masak> er, s/autopins/autopuns/

[20:40] <colomon> so .match can return a Match object or a List of Match objects.

[20:40] *** sisar left
[20:41] <lue> What would :nth(*) cause? Could it mean the same thing as :global, or would it be an error?

[20:41] <masak> c1sung: 你好，來自台灣的人！

[20:41] <colomon> I guess maybe it *should* a failed Match object when it can't match anything with the :global setting

[20:42] <colomon> pmichaud: with 'abc'.match( /./, :nth(1,3) ), if :nth(1) succeeds and :nth(3) fails, does it return overall failure?  Or a list with a good Match and a failed Match?

[20:42] <masak> cognominal: https://en.wikipedia.org/wiki/Autological_word

[20:42] <pmichaud> colomon: that was to be my next question -- what about    'abc'.match( /./, :nth(1,3,6) )

[20:43] <pmichaud> I could see it being a list of two matches, a list of two matches and a Nil, or a list of two successful matches and a failed match

[20:43] <cognominal> masak: yes, but the point, like you said, is that I use as a nick. It is a word in a certain context.

[20:43] <cognominal> * use it

[20:43] <lue> Maybe a list of (Match, Match, failed match)

[20:43] <colomon> pmichaud: but it could also just be a failed Match, no? 

[20:44] <pmichaud> I suppose it could be a failed match.... but (unlike :x)  there's nothing in the spec to imply that not getting all of the n's requested will cause an overall failure

[20:44] <cognominal> masak: I guess that your sentence is that my nick should be one to qualify :)

[20:44] <pmichaud> in particular,   :n(1,1,*+*...*) is valid

[20:44] <colomon> pmichaud: oh, interesting

[20:45] <colomon> pmichaud: that example suggests it SHOULD NOT be Match, Match, failed Match, right?

[20:45] <colomon> because it would be Match, Match, infinite list of failed Matches.

[20:45] <colomon> oh, I guess it could be lazy, though.

[20:45] <pmichaud> colomon: well, it's lazy, and I don't have a problem with the notion of "infinite list of failed Matches"

[20:46] <colomon> right

[20:46] <colomon> it makes sense it should be lazy

[20:46] <cognominal> hum, your article leads to interesting stuff  https://en.wikipedia.org/wiki/Grelling-Nelson_paradox

[20:46] <pmichaud> all of these are intended to be lazy, fwiw.

[20:47] <colomon> in which case, it seems like Match, Match, failed Match is the only sensible answer

[20:47] * colomon realizes he just contradicted himself five lines back, but he wasn't taking laziness into account then.

[20:48] <masak> cognominal: well, the science of autopuns is still young. but it's something like "autopuns must be statements", or rather, the use and the mention are usually distinct even though they are confused.

[20:49] <jnthn> pmichaud: If :g returns a Match, will for $x.match(/y/, :g) -> $m { ... } do the right thing?

[20:49] <lue> What would happen if someone gets an infinite list of failed matches (with :nth(1,1,*+*...*) for instance) and would like to know how many matches they got? (what would .elems on the list return?)

[20:49] <pmichaud> jnthn: I've not advocated that :g returns a single Match

[20:49] <pmichaud> although Rakudo does that currently, unfortunately.

[20:49] <pmichaud> I think that :g should imply "List", unless it's modified by a :nth

[20:49] <jnthn> pmichaud: Oh, I thought it did the list of match thing...

[20:50] <jnthn> OK.

[20:50] <jnthn> It does mean that .match ends up having more than one return type.

[20:50] <pmichaud> we already have that.  :-)

[20:50] <cognominal> masak, that's fun because in #perlfr, someone was just asking who was talking of autopun in perl circles.

[20:50] <pmichaud> 'abc'.match( /./, :nth(3))    # single Match object

[20:51] <cognominal> Jung has a word for that that I always forget.

[20:51] <pmichaud> 'abc'.match( /./, :nth(1,3))    # List of two Match objects

[20:51] <cognominal> synchronicity!

[20:51] <masak> yes.

[20:51] <jnthn> pmichaud: Well, if we're returning a List in that case, then I'm certainly for :g returning a List too.

[20:51] <pmichaud> and if there are no matches, it returns an empty list?

[20:52] <masak> Jung is often not-even-wrong in ways I find highly intriguing :D

[20:52] <colomon> a list with just a failed Match/

[20:52] <colomon> ?

[20:52] <pmichaud> I'm not sure I want list with failed Match, though, because    for $x.match(/y/, :g) -> $m { ... }    doesn't really do what you might expect

[20:52] <pmichaud> unless you're expecting :g to return failed matches

[20:52] <jnthn> pmichaud: It'd see that is needed to get the "for" case to work out.

[20:53] <jnthn> *as needed

[20:53] <jnthn> It'd be weird to get a single iteration of the loop when nothing matched, imho.

[20:55] <pmichaud> okay, I think I know what I'll start with, then.

[20:55] <pmichaud> we'll have to see if TimToady++ will bless it into a spec or make us change it somehow :) :)

[20:55] <pmichaud> the current spec with Match of Match feels terribly wrong to me, on several levels.

[20:58] <pmichaud> basically, things that imply "list of Match" return empty lists if nothing matches.  Otherwise you get the (possibly failing) Match object

[20:59] <masak> +1

[20:59] <jnthn> wfm

[20:59] <colomon> +1

[21:00] <lue> +1

[21:02] *** birdwindupbird left
[21:04] *** rodney_ joined
[21:16] <masak> rn: sub a { my &x = { return }; &x }; my &y = a; &y()

[21:17] <p6eval> rakudo 138213: OUTPUT«(timeout)»

[21:17] <p6eval> ..niecza v19-13-g442e075: OUTPUT«Unhandled exception: Illegal control operator: return␤  at /tmp/Tc6z8vfHzf line 1 (ANON @ 4) ␤  at /tmp/Tc6z8vfHzf line 1 (mainline @ 6) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3918 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3919 (m…

[21:17] <masak> hm, locally on rakudo I get 'Attempt to return outside of any Routine'. I don't much like that error.

[21:17] <masak> the return is in a Routine.

[21:17] <pmichaud> ...a Routine that has already exited, though.

[21:18] <masak> it's just that the Routine in question is exhausted.

[21:18] <pmichaud> yes, that seems like a LTA error message

[21:18] <masak> right, I agree that the return heppens dynamically outside the dynamic scope of the Routine.

[21:18] * masak submits rakudobug

[21:20] <benabik> rn: sub a { my &x = { return }; &x }; sub b(&x) { &x() }; b(a)

[21:20] <p6eval> rakudo 138213: OUTPUT«(timeout)»

[21:20] <p6eval> ..niecza v19-13-g442e075:  ( no output )

[21:22] <masak> locally I still get 'Attempt to return outside of any Routine'

[21:22] <masak> benabik++

[21:22] <pmichaud> it looks to me like it's just the message that is suspect.

[21:22] <pmichaud> I can't find that X::ControlFlow::Return is used anywhere other than EXHAUSTED

[21:23] <pmichaud> (perhaps it is; I'm having trouble following all of the logic there)

[21:23] <pmichaud> I can see other references to X::ControlFlow::Return... but I don't know what if anything invokes them

[21:28] *** eviltwin_b joined
[21:40] *** rodney_ left
[21:46] *** cognominal left
[21:47] *** cognominal joined
[21:48] *** cognominal left
[21:50] *** cognominal joined
[22:03] *** PacoAir left
[22:04] *** zby_home_ left
[22:07] <masak> lol blig blag blog! http://strangelyconsistent.org/blog/july-8-blocked-exits

[22:11] *** adam7504 joined
[22:15] <seldon> I'll read that when I'm done cursing Protoman.

[22:16] *** sergot left
[22:16] *** sergot joined
[22:16] <sergot> good night! :)

[22:16] *** sergot left
[22:17] *** mucker left
[22:17] <lue> masak++

[22:19] <lue> Also, July 7th disappeared from your RSS feed (and this post is listed as being posted on July 7th, if that helps)

[22:19] <masak> oh noes.

[22:20] <masak> fixing.

[22:20] <pmichaud> anyone have some good tricks for determining the set of integers that are inside of a Range?

[22:21] <masak> lue++

[22:21] <pmichaud> or, perhaps better, finding out the smallest and largest integer inside of a Range?

[22:22] *** adam7504 left
[22:23] <seldon> Range as in array or range as in interval?

[22:23] <pmichaud> Range as an interval.   Like  3..5   or 1.4 ^..^ 7.2

[22:25] <seldon> (3..5).bounds 

[22:25] <pmichaud> r:  say (1.4 .. 7.2).bounds

[22:25] <p6eval> rakudo 138213: OUTPUT«1.4 7.2␤»

[22:25] <pmichaud> nope.

[22:26] <seldon> I daresay it should be possible to get the ints from that.

[22:26] <pmichaud> r:  say (7.2 .. 1.4).bounds

[22:26] <p6eval> rakudo 138213: OUTPUT«7.2 1.4␤»

[22:27] <quietfanatic> r: say {ceiling($^a), floor($^b)}((7.2 .. 1.4).bounds)

[22:27] <p6eval> rakudo 138213: OUTPUT«(timeout)»

[22:28] <quietfanatic> why did that timeout

[22:28] <pmichaud> I don't know.

[22:29] <pmichaud> although {...} looks like a hash in that context.

[22:29] <seldon> What do you want to get for 1.2 .. 1.8 ?

[22:29] <pmichaud> an empty list

[22:30] <pmichaud> or some way of knowing that there are no integers in that Range

[22:34] <pmichaud> r:  my $range = 7.2 .. 1.4;  say $range.max;  say $range.min.floor;   say $range.min.floor < $range.max;

[22:34] <p6eval> rakudo 138213: OUTPUT«1.4␤7␤True␤»

[22:34] <pmichaud> wtf?!

[22:36] <pmichaud> r:  my $range = 7.2 .. 1.4;  say $range.max;  say $range.max + 1;   say 7 < $range.max;

[22:36] <p6eval> rakudo 138213: OUTPUT«1.4␤2.4␤True␤»

[22:36] <diakopter> eh

[22:36] <pmichaud> ...what am I missing here?

[22:36] <pmichaud> r:  my $range = 7.2 .. 1.4;  say $range.max;  say $range.max + 1;   say 7 < $range.max;   say 7 < $range.max + 1;

[22:36] <p6eval> rakudo 138213: OUTPUT«1.4␤2.4␤True␤True␤»

[22:36] <seldon> http://codepad.org/Emo9hwae <-- how's that?

[22:37] <diakopter> max Always pulls from the right?

[22:37] <pmichaud> r:  say 7 < 2.4

[22:37] <p6eval> rakudo 138213: OUTPUT«True␤»

[22:37] <pmichaud> o_O

[22:38] <pmichaud> r:  say 7.0 < 2.4

[22:38] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:38] <quietfanatic> woah

[22:38] <lue> r: say 7 < 2

[22:38] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:38] <pmichaud> rn: say 7 < 2.4

[22:38] <p6eval> niecza v19-13-g442e075: OUTPUT«False␤»

[22:38] <p6eval> ..rakudo 138213: OUTPUT«True␤»

[22:38] <pmichaud> ...how did _that_ one slip past us?  ;-)

[22:38] <seldon> r: say 7.Num < 2.4

[22:38] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:38] <pmichaud> r: say 7.Rat < 2.4

[22:38] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:38] <quietfanatic> I guess it's so obvious it isn't tested

[22:39] <pmichaud> seldon: does that version work if the range is reversed -- i.e.,   7.2 .. 1.4 ?

[22:39] <pmichaud> I guess it doesn't matter in that case.

[22:39] <seldon> Yes. That's what the [min] and [max] stuff are for. Although I guess $r.max and $r.min is more concise.

[22:39] <quietfanatic> IIRC, backwards ranges are not considered to be containing anything.

[22:39] <pmichaud> correct, but I think I'll have to test for that specially anyway.

[22:39] <seldon> say (7.2 .. 1.4).reify

[22:40] <seldon> r: say (7.2 .. 1.4).reify

[22:40] <p6eval> rakudo 138213: OUTPUT«␤»

[22:40] <pmichaud> Now for the bigger bug... why does rakudo think   7 < 2.4   ?

[22:41] <pmichaud> r: say 7.Real < 2.4.Real

[22:41] <p6eval> rakudo 138213: OUTPUT«True␤»

[22:41] <masak> o.O

[22:41] <pmichaud> r: say 7.Real.Bridge

[22:41] <p6eval> rakudo 138213: OUTPUT«7␤»

[22:42] <pmichaud> r: say 7.Real.Bridge.WHAT

[22:42] <p6eval> rakudo 138213: OUTPUT«Num()␤»

[22:42] <pmichaud> r: say 2.4.Real.Bridge.WHAT

[22:42] <p6eval> rakudo 138213: OUTPUT«Num()␤»

[22:42] <pmichaud> r: say 7.Real.Bridge < 2.4.Real.Bridge

[22:42] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:43] <pmichaud> ...is there a way to find out which multi actually gets invoked in response to a given set of arguments?

[22:43] <pmichaud> (one that is implemented in Rakudo :-)

[22:44] <diakopter> r: say 2.4 > 7

[22:44] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:44] <diakopter> OO

[22:44] <lue> r: say 2 > 7.3

[22:44] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:45] <pmichaud> heh

[22:45] <masak> pmichaud: debug output statements? :)

[22:45] <pmichaud> https://gist.github.com/3073290  # whoooops!

[22:45] <pmichaud> Rat < Int   is correct

[22:45] <pmichaud> Int < Rat   is wrong

[22:46] <pmichaud> same for <=

[22:46] <jnthn> pmichaud: There's a method on Routine which will give you back the applicable candidates.

[22:46] <jnthn> r: say Routine.^methods(:local)

[22:46] <p6eval> rakudo 138213: OUTPUT«(timeout)»

[22:46] <pmichaud> well, I found the culprit :)

[22:46] <jnthn> OK :)

[22:48] <diakopter> r: say 7 > _2.4

[22:48] <p6eval> rakudo 138213: OUTPUT«===SORRY!===␤Confused␤at /tmp/MFVqeDSkrh:1␤»

[22:48] <diakopter> r: say 7 > 2.4

[22:48] <p6eval> rakudo 138213: OUTPUT«False␤»

[22:49] <pmichaud> yes, most of the Int,Rat comparators are wrong

[22:50] <jnthn> I...guess we're missing some test coverage.

[22:52] <pmichaud> actually, we have tests for those. 

[22:52] <pmichaud> our tests just aren't testing this case

[22:53] <pmichaud> I mean, we're testing Int < Rat and Int > Rat and the like

[22:53] <pmichaud> but the ints and rats used in the test don't expose this bug.

[22:54] * pmichaud goes ahead and files a ticket so he can reference it in the tests.

[22:54] <pmichaud> well, maybe not.

[22:56] *** samlt left
[22:59] *** plobsing joined
[23:02] <dalek> roast: 33d6754 | pmichaud++ | S03-operators/relational.t:

[23:02] <dalek> roast: Add some tests for the &infix:«<»(Int, Rat) bug discovered today.

[23:02] <dalek> roast: review: https://github.com/perl6/roast/commit/33d6754a7f

[23:02] *** spider-mario left
[23:07] *** cognominal_ joined
[23:08] *** thelazydeveloper left
[23:09] <dalek> roast: 997c786 | pmichaud++ | S03-operators/relational.t:

[23:09] <dalek> roast: Also add tests for &infix:«<=>»(Int,Rat)  and &infix:«<=>»(Rat,Int).

[23:09] <dalek> roast: review: https://github.com/perl6/roast/commit/997c786214

[23:10] *** cognominal left
[23:16] <masak> 'night, #perl6

[23:17] *** Infiltrator left
[23:30] *** quietfanatic left
[23:35] *** lue left
[23:35] <pmichaud> hmmmm... something broke spectests.

[23:44] *** eviltwin_b left
[23:57] *** tokuhiro_ joined
