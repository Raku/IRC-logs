[00:15] <masak> 'night, #perl6

[00:15] <TimToady> 'night

[00:16] <quietfanatic> nught

[00:21] *** skids joined
[00:32] <jnthn> 'night o/

[00:50] *** replore joined
[00:52] <clkao> /wnWW/WIN21

[01:00] *** zhutingting joined
[01:10] *** Guest65764 left
[01:21] *** fgomez joined
[01:22] *** drbean left
[01:25] *** drbean joined
[01:35] *** zhutingting left
[01:35] *** replore left
[02:03] *** orafu left
[02:04] *** orafu joined
[02:09] *** replore joined
[02:16] *** tokuhiro_ left
[02:32] *** replore left
[02:37] *** Psyche^ joined
[02:41] *** Patterner left
[02:41] *** Psyche^ is now known as Patterner

[02:55] <dalek> roast: e8c9ac5 | coke++ | S10-packages/scope.t:

[02:55] <dalek> roast: pugs fudge

[02:55] <dalek> roast: review: https://github.com/perl6/roast/commit/e8c9ac580a

[03:00] *** xinming left
[03:00] <takadonet> good job coke :)

[03:02] *** xinming joined
[03:19] *** crab2313 joined
[03:24] *** jaldhar joined
[03:25] <[Coke]> takd?

[03:25] <takadonet> yes?

[03:38] *** jaldhar left
[03:41] *** jaldhar joined
[04:00] <TimToady> nr: say ['a','b'] X~ 1 .. 3;

[04:00] <p6eval> rakudo f23a45: OUTPUT«a1 a2 a3 b1 b2 b3␤»

[04:00] <p6eval> ..niecza v19-15-g051783d: OUTPUT«a b1 a b2 a b3␤»

[04:00] <TimToady> niecza++

[04:00] <TimToady> rakudobug

[04:03] <TimToady> nr: say ['a','b'],() X~ 1 .. 3;

[04:03] <p6eval> rakudo f23a45, niecza v19-15-g051783d: OUTPUT«a b1 a b2 a b3␤»

[04:03] <TimToady> nr: say ['a','b'] Z~ 1 .. 3;

[04:03] <p6eval> rakudo f23a45: OUTPUT«a1 b2␤»

[04:03] <p6eval> ..niecza v19-15-g051783d: OUTPUT«a b1␤»

[04:03] <TimToady> same deal, rakudobug

[04:04] *** ironcamel joined
[04:04] <TimToady> nr: my $a = ['a','b']; say $a X~ 1..3

[04:05] <p6eval> rakudo f23a45: OUTPUT«a1 a2 a3 b1 b2 b3␤»

[04:05] <p6eval> ..niecza v19-15-g051783d: OUTPUT«a b1 a b2 a b3␤»

[04:05] <TimToady> same deal

[04:06] * TimToady is kinda surprised we haven't noticed this before

[04:09] <TimToady> nr: say 1..3 X~ ['a','b']

[04:09] <p6eval> rakudo f23a45: OUTPUT«1a 1b 2a 2b 3a 3b␤»

[04:09] <p6eval> ..niecza v19-15-g051783d: OUTPUT«1a b 2a b 3a b␤»

[04:13] <TimToady> nr: say ([1,2] X [3,4]).perl

[04:13] <p6eval> niecza v19-15-g051783d: OUTPUT«([1, 2], [3, 4]).list␤»

[04:13] <p6eval> ..rakudo f23a45: OUTPUT«((ListIter.new(),), (ListIter.new(),), (ListIter.new(),), (ListIter.new(),)).list␤»

[04:14] <TimToady> seems to be a generic problem with list infixes not binding both sides like slurpy lists

[04:15] * TimToady suspects this may be another manifestation of the problem that pmichaud++ is already working on

[04:25] *** benabik left
[04:31] *** benabik joined
[04:37] *** quietfanatic left
[04:39] *** provider joined
[04:39] *** provider left
[04:42] *** crab2313 left
[04:45] *** kaare_ joined
[04:47] *** tokuhiro_ joined
[04:58] *** skids left
[05:37] *** adu joined
[05:43] <moritz> \o

[05:49] <sorear> o/

[06:42] <TimToady> backlogged!

[06:42] <TimToady> 'course, now I'm about to go to bed and earn some more backlog...

[06:52] <moritz> sleep well, dream of short backlogs

[06:52] <TimToady> thanks, o/

[06:56] *** am0c joined
[07:23] <sjohnson> hi

[07:25] *** kaxing joined
[07:39] <dalek> star: 12b921c | pmichaud++ | skel/tools/build/ (3 files):

[07:39] <dalek> star: Refactor .msi building process a fair bit.

[07:39] <dalek> star: review: https://github.com/rakudo/star/commit/12b921c0c0

[07:39] <dalek> star: a280cf5 | pmichaud++ | skel/tools/build/star-product.wxs:

[07:39] <dalek> star: Change INSTALLLOCATION -> INSTALLROOT

[07:39] <dalek> star: review: https://github.com/rakudo/star/commit/a280cf5050

[07:39] <dalek> star: f2057b0 | pmichaud++ | skel/tools/build/Makefile.in:

[07:39] <dalek> star: Fix directory argument for building source .wxs file.

[07:39] <dalek> star: review: https://github.com/rakudo/star/commit/f2057b0daa

[07:56] *** GlitchMr joined
[08:01] *** benabik left
[08:04] <pmichaud> I'm about to publish the 2012.07 star release; anything I should look at or check before doing so?

[08:05] <pmichaud> (bbi10)

[08:10] *** sergot joined
[08:10] <sergot> hi o/

[08:12] *** cognominal_ joined
[08:12] *** plobsing left
[08:14] *** cognominal left
[08:23] <pmichaud> back again

[08:23] <moritz> \o sergot, pmichaud 

[08:25] <pmichaud> okay, time to upload the release files

[08:26] <moritz> pmichaud: does the MSI support installing to arbitrary paths?

[08:26] <pmichaud> moritz: no.

[08:27] <pmichaud> (because rakudo/parrot can't support it)

[08:27] <moritz> ok

[08:27] <moritz> thought so :(

[08:28] <pmichaud> indeed, the msi would've likely been a bit easier if we could've done that

[08:28] <pmichaud> (easier to build, that is)

[08:40] <moritz> another reason to investigate alternative backends

[08:40] <pmichaud> release published, announcements made to rakudo.org, p6c, p6u, and parrot-dev

[08:41] <moritz> pmichaud++

[08:41] <moritz> pmichaud: do you think it would be beneficial to upload a binary linux build?

[08:42] <pmichaud> I think if we do that, we'd want to package it as a .deb and/or .rpm

[08:42] <felher> If i want to have a enumeration of JAN/FEB/... to Date.new("2012-01-01"), is this how i'm supposed to to it:

[08:42] <felher> r: enum Months (JAN => BEGIN {Date.new("2012-01-01")}); JAN.year.say;

[08:42] <p6eval> rakudo f23a45: OUTPUT«2012␤»

[08:42] <felher> pmichaud++ :)

[08:42] <felher> *to do it

[08:43] <moritz> r: enum Months (Jan => Date.new("2012-01-01"), Feb => Date.new("2012-02-01"));

[08:43] <p6eval> rakudo f23a45: OUTPUT«===SORRY!===␤Enumeration value must be known at compile time␤at /tmp/9UjunzXE62:1␤»

[08:43] <moritz> I guess I should fix that

[08:43] <moritz> r: try eval 'enum Months (Jan => Date.new("2012-01-01");'; say $!.WHAT

[08:43] <p6eval> rakudo f23a45: OUTPUT«X::AdHoc()␤»

[08:44] <pmichaud> so, I've been considering publishing our own .deb and/or .rpm distros... but wanted to get the windows world handled first.

[08:44] <pmichaud> we'd also have to figure out how we'd want to coexist with the existing debian packaging, if at all.

[08:44] <moritz> which is why I'd simply go with tar'ing up /opt/rakudo-star-2012.07

[08:45] <pmichaud> I fear that if we did that people would then say "...why aren't you providing it as a .deb/.rpm ?"

[08:46] <moritz> then we can answer "because we haven't figured it out yet"

[08:46] <pmichaud> oh, but someone's figured it out, because rakudo .debs are already available.

[08:47] <pmichaud> they just tend to lag our release cycle by a lot

[08:49] <moritz> well, I'm trying to be pragmatic

[08:49] <pmichaud> sure

[08:49] <moritz> some people have trouble building rakudo due to memory requirements

[08:50] <moritz> and we're not currently in a position to provide polished .deb/.rpm packages

[08:50] <pmichaud> /opt/rakudo-star-2012.07 would include the parrot binaries?

[08:50] <moritz> hence my proposal to give them *something*

[08:50] <moritz> pmichaud: yes

[08:52] <pmichaud> I'll think about it a bit more.

[08:52] <masak> pmichaud++ # R*

[08:52] <pmichaud> having done the .msi stuff, and having done a few .debs and .rpms before (for other packages, not rakudo), I suspect we can come up with a way to handle .deb/.rpm without too much difficulty.

[08:53] <pmichaud> so, let's revisit it for august (perhaps around yapc::eu)

[08:53] <masak> (morning, #perl6)

[08:53] <pmichaud> since none of us are apparently giving talks, we may have time to work on other things :-/

[08:53] <masak> pmichaud: is it now final that none of us are giving talks?

[08:53] <masak> if so, that sucks.

[08:54] <pmichaud> masak: I've not heard anything final, no.

[08:54] * masak writes to the organizers with some nice but very precise wordings

[08:54] <pmichaud> but the longer things go without hearing anything changing, the less likely I think it is

[08:54] <moritz> masak: the last response from the organizers was that they'll try to figure out how to enable more talks

[08:54] <moritz> masak: please do, and set me CC

[08:54] <masak> will do.

[08:54] <masak> will cc pmichaud and jnthn too.

[08:55] <moritz> you might also mention that people in here have pondered not going to YAPC::EU due to absense of Perl 6 talks

[08:55] <moritz> and I'm not talking about the core hackers here

[08:56] <pmichaud> I can entirely understand that it may have been a statistical or logistical fluke that caused us to end up with no talks there.  And I know that my talk proposal wasn't very solid or concrete.

[08:57] <pmichaud> I can still update it and make it more solid or concrete; but things got a little hectic here as the talk deadline approached. 

[08:57] <masak> pmichaud: "Currently it seems as if some talk votes were counted differently from the expectations." http://blogs.perl.org/users/moritz/2012/07/no-accepted-perl-6-talks-at-yapceu-2012.html#comment-179251

[08:57] <pmichaud> masak: yes, I saw that note.  I'm not exactly sure what that meant.  :-)

[08:58] <masak> pmichaud: i.e. "we screwed up and accepted some talks before the ones we should've accepted, and now we can't take it back and we have a problem"

[08:59] <pmichaud> well, 49 talks seems like a fairly smallish number relative to yapc's past

[08:59] <pmichaud> (too)

[08:59] <pmichaud> I'm guessing they only have three tracks/rooms

[09:10] <masak> email sent.

[09:10] <moritz> masak++

[09:10] <moritz> I haven't reached my CC yet, but email isn't real-time

[09:10] <moritz> s/reached/received/

[09:10] * moritz should learn English one of these days

[09:11] <huf> did i wake up in another language again? :)

[09:12] <masak> oops, sent to questions@yapceu2012, not [email@hidden.address]
[09:12] <masak> re-sending, re-cc:ing. sorry 'bout that.

[09:15] <pmichaud> fwiw, yapc::na will be in Austin next year, and here's the first topic request that came on their mailing list:  https://github.com/rakudo/star/blob/master/skel/docs/announce/2012.07

[09:15] <pmichaud> Essentially, "Anyone have an idea on the topics or panel? Would love to see Perl 6

[09:15] <pmichaud> discussions."

[09:15] <pmichaud> oops, wrong url

[09:15] <pmichaud> http://mail.pm.org/pipermail/austin/2012-July/001807.html

[09:16] <pmichaud> anyway, I should get some sleep here -- bbiaw

[09:21] <dalek> roast: 17c51d7 | moritz++ | S32-exceptions/misc.t:

[09:21] <dalek> roast: remove an exception test where we do not strictly need to die

[09:21] <dalek> roast: review: https://github.com/perl6/roast/commit/17c51d70d7

[09:21] <dalek> rakudo/nom: 7d101ef | moritz++ | src/core/List.pm:

[09:21] <dalek> rakudo/nom: simplfy List.classify, make it return a Hash as per spec

[09:21] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d101ef2d7

[09:22] <dalek> rakudo/nom: b87659a | moritz++ | src/Perl6/Actions.pm:

[09:22] <dalek> rakudo/nom: compile-time evaluate enums

[09:22] <dalek> rakudo/nom: 

[09:22] <dalek> rakudo/nom: instead of complaining that they are not known at compile time

[09:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b87659a873

[09:22] <moritz> felher: ok, no more need for BEGIN magic in enums :-)

[09:24] <Coleoid> pmichaud++  # MSIs help me tempt friends...

[09:25] <felher> moritz++ # thanks a lot :)

[09:29] <jnthn> morning, #perl6

[09:29] <moritz> \o jnthn 

[09:30] *** hoelzro|away is now known as hoelzro

[09:31] <jnthn> pmichaud++ # Rakudo release

[09:31] <jnthn> *Star

[09:31] <hoelzro> morning perl6 folk

[09:31] <hoelzro> oh hey, release!

[09:31] <hoelzro> hooray

[09:32] <hoelzro> pmichaud++

[09:33] <hoelzro> masak: when you built that R* bundle for me, you just used the pristine R* 2012.06 archive, right? Did you provide any special options to Parrot's Configure.PL?

[09:36] <masak> no.

[09:36] <masak> I did not configure Parrot specifically. just R* itself.

[09:42] * au ponders making a rakuto-star-2012.07.pkg

[09:42] <hoelzro> masak: any special options to Configure.PL there? other than --prefix?

[09:43] <hoelzro> I ask because when I compile Parrot myself, I get the crash

[09:43] <hoelzro> but when I install your parrot and compile everything else, it works fine

[09:43] <hoelzro> I just want a working Rakudo =(

[09:47] *** MayDaniel joined
[09:49] <masak> I did `$ perl Configure.pl --gen-parrot`, just like the README says. actually, I just followed the README the whole time.

[09:50] <moritz> star: say 1

[09:50] <hoelzro> hmm

[09:50] <p6eval> star 2012.06: OUTPUT«1␤»

[09:51] <hoelzro> why does it crash for me?!

[09:51] <hoelzro> even the Parrot from Arch's repo causes the crash

[09:51] <moritz> star: say 1

[09:51] <p6eval> star 2012.07: OUTPUT«1␤»

[09:52] *** whiteknight joined
[09:52] *** whiteknight is now known as Guest74836

[10:00] *** cognominal_ left
[10:06] *** Patterner left
[10:07] *** tokuhiro_ left
[10:15] <hoelzro> wtf, now it works?!

[10:18] *** spider-mario joined
[10:20] *** crab2313 joined
[10:23] <masak> oh, good.

[10:24] *** Psyche^ joined
[10:24] *** Psyche^ is now known as Patterner

[10:25] <masak> lol, I blogged! \o/ http://strangelyconsistent.org/blog/july-27-2012-triggering-doom-and-dying

[10:26] <hoelzro> masak: I think I figured out the issue on my Arch box =)

[10:26] <hoelzro> we'll know in about 20 minutes

[10:28] *** cognominal joined
[10:28] <masak> people, this is an excellent opportunity to find bugs in the game -- after I finished the whole storyline, but before I've started general cleanup and refactoring.

[10:29] <masak> download the game at https://github.com/masak/crypt/ and start finding deficiencies. I wrote it, so I can guarantee that there are a few!

[10:30] * hoelzro goes to try it

[10:30] <masak> \o/

[10:31] <hoelzro> masak: I noticed it uses the executable 'nom'; can I run this with R*?

[10:33] *** benabik joined
[10:35] <moritz> masak: is it normal that the game takes ages to load?

[10:36] <hoelzro> is pmichaud still around? or past his bed time =)

[10:36] <moritz> 11:16 < pmichaud> anyway, I should get some sleep here -- bbiaw

[10:36] <hoelzro> moritz: thanks

[10:36] <masak> moritz: yes.

[10:36] <hoelzro> what time zone is pmichaud in, anyway?

[10:37] <masak> moritz: this will get lots better once I break the 3kLOC file into modules.

[10:37] <masak> hoelzro: you can. I have a /usr/bin/nom on my system, but it's running latest Rakudo.

[10:37] <hoelzro> masak: ok, cool

[10:38] <masak> er, /usr/local/bin/nom

[10:38] *** crab2313 left
[10:38] <hoelzro> should I just symlink it to $(which prel6)?

[10:38] <hoelzro> s/re/er/

[10:38] <moritz> hoelzro: you can just run  perl6 bin/crypt

[10:38] <hoelzro> oh, good point =)

[10:40] <masak> one of the talk proposals I submitted for YAPC::EU is about how I wrote this game and what I learned writing it.

[10:42] <hoelzro> I was hoping to do the same with my chat bot

[10:43] <moritz> ETOOLATE this time

[10:57] <hoelzro> ok, here's what is causing the crash on my Arch box

[10:57] <hoelzro> parrot is being built without --optimize

[10:58] <hoelzro> and that causes problems...for some reason.

[11:00] *** zby_home_ joined
[11:00] *** adu left
[11:07] <Woodi> afternoon

[11:10] *** crab2313 joined
[11:10] *** GlitchMr left
[11:11] <jnthn> hi Woodi 

[11:11] <masak> Woodi! \o/

[11:12] <Woodi> pmichaud: maybe we can create (deb|rpm)s into /usr/local ? probably Debian/Ubuntu/Fedora/... package maintainers want to compile their own packages to keep it under their control...

[11:12] <Woodi> hallo jnthn++ & masak++ :)

[11:13] <Woodi> btw. it is nice your boss(es) officially support Perl 6 :)

[11:16] *** GlitchMr joined
[11:16] <masak> that is nice.

[11:16] *** crab2313 left
[11:19] <jnthn> Aye :)

[11:20] *** spider-mario left
[11:24] *** jferrero left
[11:26] *** hoelzro is now known as hoelzro|away

[11:28] <moritz> they do?

[11:28] <moritz> ah yes, it says Perl 6 on http://www.edument.se/konsulter/

[11:29] <moritz> star: use LWP::Simple; say LWP::Simple.get('http://perl6.org/').substr(0, 20)

[11:29] <p6eval> star 2012.07: OUTPUT«<?xml version="1.0" ␤»

[11:29] <moritz> star: use LWP::Simple; say LWP::Simple.get('http://perl6.org/').match(rx{'<title>' <( .*? )> '</title>' }).Str

[11:30] <p6eval> star 2012.07: OUTPUT«Perl 6␤»

[11:30] <moritz> star: use LWP::Simple; say LWP::Simple.get('http://rakudo.org/').match(rx{'<title>' <( .*? )> '</title>' }).Str

[11:30] <p6eval> star 2012.07: OUTPUT«rakudo.org | Rakudo Perl 6␤»

[11:31] <moritz> jnthn: it's funny that module precompilation is so sensitive, and still it works to load a module that was precompiled with a different setting

[11:32] <moritz> I guess that's because the "different" setting is still being loaded for p6eval

[11:32] <masak> moritz: our bosses are also fine with us working about 80% so that we'll have time to do Perl 6 the remaining 20%.

[11:34] <jnthn> Not to mention disappearing for conferences... ;-)

[11:35] <jnthn> moritz: Different source or different compilation?

[11:36] <jnthn> moritz: It uses a sha-1 of the source code to determine "does it match"

[11:36] <mhasch> masak: you do what you do for Perl 6 in just 20% of your time?  Or is ist 80% of your leisure time and 20 % of your working time?

[11:38] <masak> mhasch: I try to allocate that time for the macro grant.

[11:38] <masak> with varying success. :)

[11:39] <masak> mhasch: the 20% fall inside the working week. in order to get the velocity right, I like to think of another 20% as falling in the weekend. I'm a bachelor, so that tends to work.

[11:39] <moritz> jnthn: well, p6eval runs with --setting=RESTRICTED

[11:40] <moritz> jnthn: but around it is still CORE, with which the modules were compiled

[11:40] <moritz> but of course the modules still see CORE

[11:40] <jnthn> moritz: Right.

[11:40] <moritz> which is why it probably works

[11:40] <jnthn> Yes. :)

[11:42] <mhasch> masak: I see.  It still takes a lot of focus to switch between different projects so frequently.

[11:43] *** UncleFester6 joined
[11:45] <UncleFester6> my "make install" has module precompilation failures for lots of modules under both cygwin and low memory linux (using parrot -G)

[11:45] <UncleFester6> Missing or wrong version of dependency 'src/gen/BOOTSTRAP.pm' (cygwin)

[11:46] <UncleFester6> Missing or wrong version of dependency 'src/gen/CORE.setting' (linux)

[11:46] <masak> mhasch: yes, but in a sense the work I do is already switch-intensive in that way.

[11:46] <masak> and mixing a bit of Perl 6 into my regular work seems to make my regular work more interesting, too. :)

[11:47] * jnthn actually can't concentrate on just one thing all the time for prolonged periods, so the variety works well :)

[11:47] <arnsholt> jnthn: Is there anything special I should know about the hash() not-quite-literal in NQP?

[11:47] <jnthn> arnsholt: As in nqp::hash?

[11:48] <jnthn> arnsholt: I guess that it expects string key/object value/string key/object value/...

[11:48] <jnthn> arnsholt: Other than that, I don't think there's anything particularly special.

[11:48] <jnthn> UncleFester6: Are you sure that it's not older .pir files?

[11:49] <arnsholt> Hmm. In World.pm there's a sub called just as hash() is that something else?

[11:49] <jnthn> arnsholt: Hmm :)

[11:49] <jnthn> arnsholt: Oh...

[11:49] <jnthn> yes, and I just saw its implementation and wtf...

[11:50] <jnthn> arnsholt: Anyway, it's correct, just inefficient

[11:50] <jnthn> arnsholt: But unlike nqp::hash it expects you to pass named args.

[11:52] <dalek> rakudo/macros-d2: c7c118d | masak++ | src/ (2 files):

[11:52] <dalek> rakudo/macros-d2: can parse unquotes in quasis

[11:52] <dalek> rakudo/macros-d2: 

[11:52] <dalek> rakudo/macros-d2: This now works:

[11:52] <dalek> rakudo/macros-d2: 

[11:52] <dalek> rakudo/macros-d2:     $ ./perl6 -e 'say "OH HAI"; my $a; {{{$a}}}'

[11:52] <dalek> rakudo/macros-d2:     ===SORRY!===

[11:52] <dalek> rakudo/macros-d2:     Can only use unquote syntax inside a quasi block

[11:52] <dalek> rakudo/macros-d2:     at -e:1

[11:52] <dalek> rakudo/macros-d2: 

[11:52] <dalek> rakudo/macros-d2:     $ ./perl6 -e 'say "OH HAI"; my $a; quasi { say "woo!"; {{{$a}}} }'

[11:52] <dalek> rakudo/macros-d2:     OH HAI

[11:52] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/c7c118d384

[11:52] <UncleFester6> I unpacked rakudo star into a fresh directory with nothing else in both cases ...

[11:52] * masak requests feedback on that initial commit, especially from moritz, jnthn, pmichaud but also from others

[11:52] <jnthn> star: say @*INC

[11:52] <p6eval> star 2012.07: OUTPUT«/home/p6eval/.perl6/lib /home/p6eval/star/lib/parrot/4.6.0/languages/perl6/lib␤»

[11:53] <arnsholt> Right. 'Cause for some reason my latest set of changes in Rakudo causes a segfault when compiling the setting, and the changes are pretty much just changing World.create_signature to take a hash and some hash literals

[11:53] <jnthn> UncleFester6: ^ shows that it will look in your home directory's .perl6 before the place that I guess modules are installed to.

[11:54] <UncleFester6> that could be a problem - checking

[11:58] *** crab2313 joined
[11:59] <arnsholt> Arg barg! Why U segfault?

[12:03] <jnthn> arnsholt: Hm, then what do you do with that data?

[12:04] <arnsholt> Not much ATM

[12:05] <arnsholt> Just unpack the parameters key into a variable in World.create_signature

[12:06] <jnthn> arnsholt: If you gist me a diff I can take a look at it and see if I spot anything.

[12:07] *** Chillance joined
[12:08] <arnsholt> jnthn: https://gist.github.com/3193047

[12:08] <moritz> masak: looks fine to me

[12:12] <masak> huh.

[12:12] <masak> ok, then. :)

[12:12] <masak> I'll just carry on in that direction.

[12:12] <jnthn> arnsholt: Hmm, nothing jumps out at me, other than that I guess I'm not looking at the full patch?

[12:13] <jnthn> arnsholt: e.g. I see a "+        $*W.create_signature(%signature_info)", but not where %signature_info is being set up.

[12:13] <arnsholt> Yeah, there are two more commits that lead up to this

[12:14] <jnthn> arnsholt: OK, and this is the "switchover" one?

[12:14] <arnsholt> Yeah

[12:14] <jnthn> I'm guessing it's possible that the issue is in a previous patch that is building up the data structure...that or I miss the issue in this one.

[12:14] <jnthn> arnsholt: How quickly does it segfault?

[12:15] <arnsholt> Pretty quickly. In the parse bit

[12:15] *** spider-mario joined
[12:15] *** dbr left
[12:16] <jnthn> arnsholt: I mean, I can imagine it getting very upset if it thinks it is about to get a parameter and then doesn't.

[12:16] <jnthn> That is, if the @parameters somehow ends up containingg something that's not a Parameter.

[12:16] *** dbr joined
[12:17] <UncleFester6> star: use LWP::Simple; say LWP::Simple.get('http://rakudo.org/').substr(0, 200)

[12:17] <p6eval> star 2012.07: OUTPUT«<!DOCTYPE html>␤<html dir="ltr" lang="en-US">␤<head>␤<meta charset="␤UTF-8" />␤<title>␤»

[12:17] <UncleFester6> star: use LWP::Simple; say LWP::Simple.get('http://rakudo.org/').substr(0, 2000)

[12:17] <p6eval> star 2012.07: OUTPUT«<!DOCTYPE html>␤<html ␤dir="ltr" lang="en-US">␤<head>␤<meta charset="␤»

[12:17] <arnsholt> Hmm. Troo

[12:17] <arnsholt> jnthn: Refresh and you'll have git diff HEAD^^

[12:19] * moritz took a while to not parse that as a smily :-)

[12:20] <moritz> but it's the same as HEAD~2

[12:21] <jnthn> arnsholt: +        my $p_sig := $*W.create_signature(hash(nqp::hash('parameters', [$*W.create_parameter(@p_params[0])])));

[12:21] <jnthn> arnsholt: That looks like a hash in a hash where it shouldn't be

[12:23] <jnthn> arnsholt: ah, think I see something serious.

[12:23] <jnthn> +    sub create_signature_object($/, %signature_info, $lexpad, :$no_attr_check) {

[12:23] <jnthn> Here we get %signature_info, and then

[12:23] <jnthn> for %signature_info<parameters> {

[12:23] <jnthn> We loop over what I guess are the hashes

[12:24] <jnthn> For each one we create a parameter object and then @parameters.push($param_obj);

[12:24] <jnthn> But then:

[12:24] <jnthn> - $*W.create_signature(@parameters)

[12:24] <jnthn> + $*W.create_signature(%signature_info)

[12:24] <jnthn> That's being passed to create_signature in the hash there is not the list of parameter objects; it's the list of hashes.

[12:25] <arnsholt> Oh derp. Thanks!

[12:27] <jnthn> masak: c7c118d looks good to me.

[12:27] <masak> \o/

[12:28] <masak> $*IN_QUASI is not a STD-ism. but STD derives a grammar Quasi there, and I'm not prepared to do that right now.

[12:32] <UncleFester6> jnthn: thanks that was it - think I came across an LWP::Simple bug but will deal with that later

[12:35] <moritz> star: use LWP::Simple; say LWP::Simple.get("http://perl6.org/").chars

[12:35] <p6eval> star 2012.07: OUTPUT«1755␤»

[12:37] <moritz> std: {{{1}}}

[12:37] <p6eval> std e52e3ca: OUTPUT«ok 00:00 40m␤»

[12:38] <UncleFester6> moritz: looking at the LWP::Simple code it seems pretty clear it is only pulling in the first packet of the reply and not later packets.  Will double check and plan to file later.

[12:38] *** cognominal_ joined
[12:40] <masak> moritz: it probably parses as three blocks outside of Quasi.

[12:40] <masak> moritz: personally, I'm fine with not allowing it.

[12:40] <moritz> masak: +1

[12:40] <masak> it's a bit like a `return` outside of a routine.

[12:41] *** cognominal left
[12:41] <moritz> masak: but getting STD's  behavior with your approach wouldn't be too hard either

[12:42] <moritz> just '{{{' <?{ !$*IN_QUASI }> <EXPR> '}}}'

[12:43] <moritz> masak: speaking of which, are you sure that there need to be an <EXPR> in there, and not something more general like a <statementlist>?

[12:44] *** cognominal_ left
[12:48] <masak> <statementlist> sounds more apt.

[12:48] <masak> I guess the latter allows `my $blabla = 5; $foo` and not just `$foo`.

[12:48] <masak> then yes.

[12:49] *** grondilu joined
[12:50] * grondilu is trying to compile rakudo-star on his new fedora system

[12:51] *** MayDaniel left
[12:52] <moritz> masak: exactly

[12:58] *** drbean left
[12:58] <masak> moritz: well, <?{ $*IN_QUASI }>, but yes ;)

[13:00] *** drbean joined
[13:01] <moritz> masak: erm, yes

[13:03] <dalek> rakudo/macros-d2: 8c2db63 | masak++ | src/ (2 files):

[13:03] <dalek> rakudo/macros-d2: backpedal on throwing an exception

[13:03] <dalek> rakudo/macros-d2: 

[13:03] <dalek> rakudo/macros-d2: as moritz++ points out, this is closer to how STD does it.

[13:03] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/8c2db6396d

[13:03] <dalek> rakudo/macros-d2: 163c626 | masak++ | src/Perl6/Grammar.pm:

[13:03] <dalek> rakudo/macros-d2: <statementlist>, not <EXPR>

[13:03] <dalek> rakudo/macros-d2: 

[13:03] <dalek> rakudo/macros-d2: Much better. moritz++

[13:03] <dalek> rakudo/macros-d2: 

[13:03] <dalek> rakudo/macros-d2:     $ ./perl6 -e 'say "OH HAI"; my $a; {{{say "woot!"; $a}}}'

[13:03] <dalek> rakudo/macros-d2:     OH HAI

[13:03] <dalek> rakudo/macros-d2:     woot!

[13:03] <dalek> rakudo/macros-d2: 

[13:03] <dalek> rakudo/macros-d2:     $ ./perl6 -e 'say "OH HAI"; my $a; quasi { say "woo!"; {{{$a}}} }'

[13:03] <dalek> rakudo/macros-d2:     OH HAI

[13:03] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/163c626a31

[13:04] <moritz> masak: fwiw I didn't mean to say throwing an exception is wrong, just pointing out that STD's behavior can easily be emulated too

[13:05] * grondilu failed to compile :(

[13:05] <moritz> grondilu: -v

[13:06] <grondilu> « invoke() not implemented in class '1257060743' »

[13:07] <moritz> :(

[13:07] <grondilu> pretty much the same as lately

[13:07] <grondilu> and it's a brand new linux system

[13:07] <grondilu> (Fedora 17)

[13:07] * moritz wonders if shipping parrot 4.5.0 would have helped

[13:07] <grondilu> (on i686)

[13:10] <takadonet> morning all

[13:14] <masak> moritz: still, I prefer this behavior.

[13:19] *** crab2313 left
[13:28] *** uvtc joined
[13:30] <uvtc> The README in the R* release says it's the 2012-06 version.

[13:30] *** fgomez left
[13:31] <masak> :(

[13:31] <uvtc> Also it doesn't mention using "--gen-nqp" in the build instructions. Is that no longer required?

[13:31] <uvtc> (In the "Configure.pl" step.)

[13:32] <GlitchMr> https://github.com/rakudo/rakudo

[13:32] <GlitchMr> $ perl Configure.pl --gen-parrot --gen-nqp

[13:32] <GlitchMr> I still see it

[13:32] <uvtc> Turn that frown upsidown, masak.

[13:32] <uvtc> I mean in the R* readme.

[13:32] <jnthn> It's not required, afaik.

[13:33] <uvtc> jnthn: thanks.

[13:33] *** birdwindupbird joined
[13:33] *** sergot left
[13:33] <masak> jnthn: about to create QAST::Unquote in nqp. `class QAST::Unquote is QAST::Node {}` in its own file in src/QAST -- anything else?

[13:34] <jnthn> masak: Update Makefile.in?

[13:34] <masak> good call. I will.

[13:35] <arnsholt> jnthn: Looks like you unbrokeded it. Thanks!

[13:36] <jnthn> arnsholt: \o/

[13:36] <masak> what's a BlockMemo? sounds like a three-dimensional corporate document to me. ;)

[13:37] <jnthn> masak: Used by QRegex, but endangered. :)

[13:37] <masak> ah.

[13:37] <jnthn> masak: It's used for attaching extra stuff to a block.

[13:37] <masak> I see.

[13:37] <jnthn> masak: All its usages should be refactored to use serialization.

[13:37] <jnthn> masak: But I didn't want to block toqast on that.

[13:38] *** grondilu left
[13:38] <arnsholt> jnthn++ # Unbrokededness

[13:38] <uvtc> Attempted to the 2012.07 R*, but it fails for me. Here's some of the leavings in my terminal window: https://gist.github.com/3193446

[13:39] <uvtc> This is on Xubuntu 12.04, using a Perl 5.16 that I built in my ~/opt.

[13:40] <uvtc> Please let me know if that's enough of the terminal window output, or if more is needed.

[13:40] *** tokuhiro_ joined
[13:40] <uvtc> Or if I should file a bug. I emailed rakudobug with the last one, but it may have been a duplicate.

[13:45] <masak> cognominal++ tweeted it, but it's worth posting here, for those who want to read it: http://blog.peterdonis.com/opinions/still-another-nerd-interlude.html -- briefly, inventor of Unix pipes Doug McIlroy is asked to do literary criticism of a literate program Knuth wrote. interesting stuff.

[13:46] <masak> critique*, I guess.

[13:46] <masak> I believe I referred vaguely to this exchange a few weeks back.

[13:47] <masak> "He has fashioned a sort of industrial-strength Fabergé egg—intricate, wonderfully worked, refined beyond all ordinary desires, a museum piece from the start."

[13:49] *** SamuraiJack joined
[13:53] *** leprevost joined
[14:00] <masak> "I need to put that on a Post-it note as an example of how to explain a script. The best part? It would fit on a Post-it note." :)

[14:02] <masak> yes, those two posts are worth reading.

[14:02] <uvtc> :)

[14:02] *** Celelibi left
[14:04] *** Celelibi joined
[14:13] *** birdwindupbird left
[14:16] <dalek> nqp: 1f54496 | masak++ | / (2 files):

[14:16] <dalek> nqp: added QAST::Unquote

[14:16] <dalek> nqp: review: https://github.com/perl6/nqp/commit/1f54496f46

[14:16] <masak> ideally, I would write tests for the new node type, as well.

[14:17] <masak> they would do something like "here's an AST with Unquote notes in it; here's an AST fragment. I apply the latter to the former, and get an AST with the fragment stitched in."

[14:18] <masak> (i.e. test the operational aspect of QAST::Unquote and stitching.)

[14:19] <masak> it's interesting, by the way, that "stitching in" actually happens twice during the macro call. once when the static quasi is incarnated into a run-time object (conceptually) on block entry.

[14:19] <masak> once when the AST from the macro call is stitched into the mainline code.

[14:19] *** cognominal joined
[14:20] <masak> both of these cases are "closure-like", in the sense that the stitching-in inside the macro has things carrying the mainline's context, and vice versa.

[14:20] <masak> it's really beautiful if you think about it. :)

[14:21] * masak .oO( hey, look. I'm philosophizing about macros again! )

[14:22] <masak> anyway, given what's in t/qast/qast.t, I'm fairly confident I'll be able to write such a test.

[14:23] *** cognominal left
[14:23] <masak> at least if the stitched-in bit doesn't do lexical lookups of free variables.

[14:24] *** cognominal joined
[14:25] <timotimo> is it possible to stitch in a function in the local scope of the macro into the ast that's returned?

[14:25] <timotimo> i'm imagining something like macro yoink() { sub frob($a) { $a + 1 }; return quasi { say {{{&frob}}}(99) } }; yoink;

[14:25] <timotimo> r: macro yoink() { sub frob($a) { $a + 1 }; return quasi { say {{{&frob}}}(99) } }; yoink;

[14:26] <p6eval> rakudo b87659: OUTPUT«sub frob($a) { ... }␤»

[14:27] <timotimo> that's ... interesting

[14:27] <moritz> masak: the double-closure thingy is what had us so confused during our early discussions, no?

[14:28] <moritz> masak: we tried to reduce it to one closure-like step, and it never worked out

[14:28] <moritz> uvtc: that bug is already in RT

[14:28] *** skids joined
[14:28] <uvtc> moritz: thanks.

[14:29] <uvtc> Anyone else having the same problem trying to build R*?

[14:31] <uvtc> moritz: is it the same "gc-gone-wild" problem I was previously having? It looks slightly different, because this time it's "invoke() not implemented in class '6778597130223229316'" rather than "invoke() not implemented in class '

[14:31] <uvtc> '". 

[14:31] *** tokuhiro_ left
[14:32] <jnthn> It'll be the same underlying issue.

[14:32] <uvtc> Anything I can do about it on my system?

[14:32] <jnthn> I haven't managed to track down what on earth is going on there yet :(

[14:32] <masak> moritz: that might well be it. it's a bit tricky to analyze confusion, though ;)

[14:33] <jnthn> uvtc: Adding -G to the Parrot flags on that invocation is known to avoid the issue.

[14:33] <jnthn> uvtc: I think it's documented in the ticket

[14:33] <jnthn> Or some ticket.

[14:34] <UncleFester6> https://rt.perl.org/rt3/Ticket/Display.html?id=113660 - towards the end

[14:35] <uvtc> UncleFester6++ thanks.

[14:36] <uvtc> Forgot to mention (in case it's important), I'm on 64-bit.

[14:36] <jnthn> uvtc: How much RAM?

[14:37] <uvtc> jnthn: that's a good question...

[14:37] <masak> moritz: `macro foo($y) { my $x = 1; quasi { say $x; say {{{$y}}} } }; my $x = 2; foo $x; # 1\n2\n` -- this captures it, I guess. nothing new to either of us at this point.

[14:37] <masak> moritz: though I'm guessing things can be done with it that neither of us thought about yet ;)

[14:39] <uvtc> jnthn: 1927MiB

[14:40] <jnthn> Thanks

[14:40] <uvtc> Is 2 GB good for building the whole enchilada?

[14:40] <jnthn> (It's enough, it's just that memory size determines how often GC runs, and it seems that soemthing is getting eaten too early.)

[14:40] <jnthn> (Thus having more memory reduces the probability of hitting the bug.)

[14:41] <moritz> uvtc: it's enough, yes

[14:41] <uvtc> Hm. Possible debugging technique: open hardware, remove a simm/dimm, try again. :)

[14:42] <jnthn> Oh, I don't think it's a memory/hardware issue.

[14:42] <jnthn> It's very likely something wrong in NQP.

[14:43] <uvtc> jnthn: No, I meant, if it might have something to do with how much memory is installed, removing some could help make the bug happen for you to make it easier to track down.

[14:43] <uvtc> More likely to bump it's head.

[14:45] <jnthn> ah, I see

[14:45] <UncleFester6> on linux/bash ulimit maybe

[14:45] <jnthn> I may also try a VM.

[14:46] <moritz> UncleFester6: I think parrot ignores ulimits :(

[14:46] <geekosaur> VM is how I'd do it, fwiw

[14:46] <geekosaur> ummm

[14:46] <geekosaur> ulimits are enforced by the kernel

[14:47] <uvtc> jnthn: You're going to test it on a Vending Machine?

[14:47] <uvtc> ;)

[14:47] <geekosaur> but they don't work the way one might naively think, so you need to be careful using them for this

[14:47] <jnthn> ;-)

[14:47] <arnsholt> Huh. For some reason my patch doesn't work

[14:47] <tadzik> oh oh, macros!

[14:49] *** UncleFester6 left
[14:51] <masak> tadzik: they're really not that complicated.

[14:51] <masak> IF YOU'RE ALREADY INSANE MWHAHAHAHA

[14:51] <moritz> geekosaur: it's not about enforcing

[14:52] <tadzik> SORRY I CAN'T HEAR YOU OVER THE SOUND OF HOW INSANE I AM

[14:52] <moritz> geekosaur: parrot uses the available memory for determining how big a pool can grow before running the GC

[14:52] <moritz> geekosaur: and parrot ignores ulimits for that purpose

[14:52] <geekosaur> right.  because ulimits are solely enforcement.

[14:53] <moritz> so if you set a strict ulimit and try to reproduce the bug, it'll simply OOM

[14:53] <geekosaur> again, "don't work the way one might naively expect"

[14:53] <geekosaur> (we're saying the same thing differently)

[15:00] *** fgomez joined
[15:09] *** fgomez left
[15:16] *** mucker joined
[15:27] *** fgomez joined
[15:28] *** fgomez left
[15:30] <arnsholt> jnthn: Could you have a look at https://gist.github.com/3193047 again?

[15:30] <arnsholt> It runs fine now, but for some reason &func.signature.returns is still Mu for sub func(Int --> Int) { ... }

[15:31] *** adu joined
[15:32] <jnthn> +        if %signature_info<returns> {

[15:32] <jnthn> A type object is always false.

[15:33] <jnthn> I guess you wanted if nqp::existskey(%signature_info, 'returns') { ... }

[15:33] <arnsholt> Durrr. Of course it is =)

[15:33] <dalek> rakudo/macros-d2: a908aa4 | masak++ | tools/build/NQP_REVISION:

[15:33] <dalek> rakudo/macros-d2: [tools/build/NQP_REVISION] bumped

[15:33] <dalek> rakudo/macros-d2: 

[15:33] <dalek> rakudo/macros-d2: For QAST::Unquote.

[15:33] <dalek> rakudo/macros-d2: review: https://github.com/rakudo/rakudo/commit/a908aa458e

[15:35] *** fgomez joined
[15:38] <arnsholt> jnthn++ # $ ./perl6 -e 'sub test(Int --> Int) { say "hi" }; say &test.signature.returns'\nInt()

[15:39] <masak> \o/

[15:39] <jnthn> \o/

[15:39] <jnthn> arnsholt++

[15:39] *** simcop2387 left
[15:40] *** simcop2387 joined
[15:41] *** SamuraiJack left
[15:41] *** SamuraiJack_ joined
[15:42] <arnsholt> And even $ ./perl6 -e 'sub test(&cb(Int --> Int)) { say "hi" }; say &test.signature.params[0].sub_signature.returns'\nInt()

[15:42] <arnsholt> Time for a full spectest

[15:44] <flussence> has that always been broken? I remember nativecall flipping out when I used the "-->" syntax instead of "returns".

[15:45] *** cognominal left
[15:46] <arnsholt> Yeah. Never been implemented 'till now, apparently =)

[15:48] <arnsholt> Or rather, implemented in the grammar but not passed on to the AST

[15:48] *** adu left
[15:51] *** zhutingting joined
[15:52] *** Guest74836 left
[15:53] <masak> \o/

[15:55] <zhutingting> hi~ I installed rakudo-star-2012.07.msi~ An error here: PARROT VM: Could not load bytecode

[15:55] <zhutingting> Could not load oplib `nqp_ops'

[16:00] *** kaxing left
[16:00] *** kaxing joined
[16:00] <masak> hm, that error message is very familiar.

[16:00] <masak> could it have something to do with previously installed versions of Parrot/

[16:00] <masak> ?

[16:03] <zhutingting> I installed rakudo2011.4 parrot 3.3 before

[16:04] <jnthn> Hmm

[16:04] <zhutingting> uninstall the old version first?

[16:04] <jnthn> zhutingting: Where did it install it to, ooc?

[16:05] <zhutingting> rakudo2011.4 install in c:\

[16:05] *** Guest74836 joined
[16:05] <zhutingting> 2012.7.msi auto install in e:\

[16:07] <jnthn> hmmm.

[16:07] <jnthn> And on mine it install it in d:\

[16:08] <jnthn> I'm almsot certain it's *meant* to install it on c:\

[16:08] <[Coke]> (parrot not relocatable) is there at least a ticket about parrot not being relocatable?

[16:09] <moritz> I think so

[16:10] <moritz> https://github.com/parrot/parrot/issues/search?q=relocatable seems like "no"

[16:22] *** MayDaniel joined
[16:25] *** birdwindupbird joined
[16:32] *** birdwindupbird left
[16:44] *** johnshoe joined
[16:45] *** johnshoe left
[16:52] *** uvtc left
[16:53] <pmichaud> good morning, #perl6

[16:53] *** zhutingting left
[16:53] <pmichaud> problems with the .msi?

[16:56] *** seldon joined
[16:57] <jnthn> pmichaud: My best guess is that it isn't forcing the installation to happen on drive C

[16:57] <pmichaud> I'm not sure how to do that.

[16:57] <jnthn> pmichaud: When I tested it on my laptop yesterday, there sin't anyway option. So it seemed fine.

[17:00] <dalek> nqp/pirt: c6b0eee | jnthn++ | src/QAST/ (2 files):

[17:00] <dalek> nqp/pirt: Consistently use :name for labels, not a mix of :result and :name.

[17:00] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/c6b0eee693

[17:00] <dalek> nqp/pirt: 544a992 | jnthn++ | / (3 files):

[17:00] <dalek> nqp/pirt: Add initial sketch of PIRT, which is to be a hopefully more memory efficient replacement for POST.

[17:00] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/544a992e78

[17:00] <dalek> nqp/pirt: e74e38c | jnthn++ | / (2 files):

[17:00] <dalek> nqp/pirt: Give PIRT::Sub support for loadlibs, name, subid and pirflags; also emit calls.

[17:00] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/e74e38c7bd

[17:00] <dalek> nqp/pirt: 2534c85 | jnthn++ | t/qast/qast.t:

[17:00] <dalek> nqp/pirt: Get QAST tests to expect QAST::Compiler to produce PIRT.

[17:00] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/2534c85e82

[17:00] <dalek> nqp/pirt: 6bc5c6c | jnthn++ | src/QAST/Compiler.nqp:

[17:00] <dalek> nqp/pirt: Start updating QAST::Compiler for PIRT. Gets some QAST tests passing again.

[17:00] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/6bc5c6c24d

[17:00] <dalek> nqp/pirt: d4ed168 | jnthn++ | src/QAST/Operations.nqp:

[17:00] <dalek> nqp/pirt: Update QAST::Operations for using PIRT, which gets many more of the QAST tests passing again.

[17:00] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/d4ed168d40

[17:00] *** unixms joined
[17:00] <pmichaud> aha.  apprently wix/msi installs to the drive with the most free space by default.

[17:01] <masak> huh.

[17:01] <jnthn> pmichaud: Hm. A user-friendly default apart from when it's not :)

[17:02] <pmichaud> so far googling the issue gives me a lot of messages from wix folks saying that we really don't want to force installation to c:\  :-(

[17:03] <jnthn> pmichaud: In the long run, no. In the shorter term, it's better than giving people an installation that looks like it's gonna work, then doesn't.

[17:03] *** unixms left
[17:04] *** UncleFester6 joined
[17:05] <UncleFester6> pmichaud: .msi wfm

[17:05] <pmichaud> UncleFester6:  excellent

[17:12] <pmichaud> 16:08 <[Coke]> (parrot not relocatable) is there at least a ticket about parrot not being relocatable?

[17:13] <pmichaud> I know that parrot isn't very relocatable on unix systems... but do we really know that it's not relocatable on windows?

[17:13] <pmichaud> maybe I should test that theory first

[17:14] <jnthn> Think it isn't, but I certainly haven't tried that in a long while.

[17:14] <moritz> pmichaud: jnthn tried for the first star release

[17:14] <jnthn> Oh, actually...

[17:14] * moritz is currently writing the ticket

[17:14] <jnthn> A while back I spent some time doing a disgusting attempt at binary patching the executable..

[17:14] <jnthn> So yeah, I guess it doesn't work.

[17:14] <jnthn> (I didn't manage to binary patch the executable either :P)

[17:15] <pmichaud> jnthn: do you remember if the binary actually had C:\ (or equivalent) in it, or did it just depend on a specific directory?

[17:17] <jnthn> pmichaud: I *think* it had the drive letter in.

[17:17] <jnthn> pmichaud: Certainly all the paths I get from parrot_config --dump have the C:\ in

[17:18] <jnthn> pmichaud: Maybe if you configure with a --prefix=\rakudo though... :)

[17:20] <moritz> https://github.com/parrot/parrot/issues/800

[17:21] <pmichaud> jnthn: good idea -- I'll try that.

[17:25] <TimToady> pmichaud: is http://irclog.perlgeek.de/perl6/2012-07-28#i_5853362 something new or the same old?

[17:26] <pmichaud> TimToady: same old; you're correct that it's one of those things I'm working on.

[17:26] <TimToady> good, just didn't want it to fall through the cracks if it was different

[17:27] <[Coke]> +# 07/28/2012 - rakudo++ (22930); niecza (89.91%); pugs (40.82%)

[17:27] <pmichaud> if you have any thoughts on https://github.com/perl6/specs/issues/18 it might help a bit :-)

[17:28] <pmichaud> (that's not directly related to the X/Z issues... but indirectly related things often have a habit of affecting other parts of list handling :)

[17:28] <[Coke]> moritz: I have a ticket open to tell parrot "this is your max memory, go no further" (just like java does) and it has never really gotten traction. perhaps upvoting it will help.

[17:28] <TimToady> maybe push on a list doesn't flatten, unlike push on an array

[17:28] <TimToady> er .plan

[17:29] <pmichaud> I could live with that; would non-flattening be true also for push/unshift, then?

[17:29] <pmichaud> (on List vs Array)

[17:30] <TimToady> I still think there are two sets of shifters, depending on whether you're binding slurpy vs non-slurpy

[17:31] <TimToady> give me the next positional arg vs give me the next slurpy arg

[17:31] *** jaldhar left
[17:31] <pmichaud> I follow what you mean by the different shifters; I don't see how they quite apply in this case.

[17:32] <pmichaud> right now slurpiness is a feature of the parameter list

[17:32] *** leprevost left
[17:33] <pmichaud> (and thus the method signature for plan/push/unshift)

[17:34] <TimToady> non-slurpiness can either be positional (single "arg") or lol (list of "arg") where arg is a subparcel

[17:36] <pmichaud> okay, I'll start with a more basic question:  what's the signature for   List.plan ?

[17:36] <TimToady> but each arg can be its own lazy parcel, so that X can somehow have two sublists that know not to look inside [] or $

[17:37] <TimToady> I'd suspect it's **@parcels

[17:37] <pmichaud> oh, was your "two sets of shifters" comment aimed at X/Z, and not .plan/.push ?

[17:38] *** fgomez left
[17:39] <TimToady> I'm just thinking of the "shifters" as the primitive difference between the two binding styles that do or do not unpack the next parcel in the arglist

[17:39] <TimToady> and it seems that such a difference should be accessible at a low level apart from only binding

[17:39] <pmichaud> okay.  I don't see that as a big issue (yet); to me, it's essentially the difference between **@slurpy and *@slurpy

[17:40] <TimToady> don't care whether they're actually called "shift"

[17:40] *** SamuraiJack__ joined
[17:41] *** SamuraiJack_ left
[17:41] <TimToady> but it's still basically the .getarg vs .getitem from the old S07 I'm thinking of

[17:41] <TimToady> .getitem being the slurpy one

[17:41] <pmichaud> s/slurpy/flattening ?

[17:41] <TimToady> yes

[17:43] <pmichaud> let's suppose I have    my $l = ( (1,2,3), (4,5,6) ).list;

[17:43] <pmichaud> and I do my $x = $l.getitem

[17:44] <pmichaud> what's left in $l ?

[17:44] <TimToady> (2,3),(4,5,6)

[17:44] <pmichaud> okay, so it "flattens" the first element but only long enough to get an element

[17:45] <pmichaud> i.e., it's not   2,3,(4,5,6)

[17:45] <TimToady> that seems ickier for some reason

[17:45] <TimToady> though for sure people don't usually switch from slurpy back to item

[17:45] <pmichaud> and if I have   $l = ( (3,), (4,5,6) ).list

[17:45] <TimToady> er, arg

[17:45] <pmichaud> and then do   $x = $l.getitem

[17:46] <pmichaud> $l ends up with... ?

[17:46] <TimToady> (4,5,6)

[17:47] <pmichaud> okay.  I haven't come up with a case where a list needs to be able to support both item-based and arg-based shifting

[17:47] <pmichaud> (at the same time)

[17:48] <pmichaud> and I suspect not having that case is where the item-based and arg-based shifting distinction escapes me.

[17:48] *** unixms joined
[17:49] <TimToady> I could imagine a signature that says (*$item, @arg, *@items), where $item would get 1, @arg would get (2,3), and @items would get (4,5,6)

[17:50] <TimToady> currently we'd generally do that with a subsig

[17:51] <pmichaud> also, the spec currently says that slurpy parameters follow any required/optional parameters

[17:51] <pmichaud> so  "*$item, @arg" seems illegal.

[17:52] <pmichaud> (if you're speculating that the spec might change to enable something like "*$item, @arg", I'm okay with that :)

[17:53] <TimToady> well, I guess I don't care about that so much as understand how "list X list" loses its don't look inside [] policy

[17:53] *** SamuraiJack__ left
[17:53] *** SamuraiJack joined
[17:54] <pmichaud> so, just to confirm, you're expecting the correct answer of   ['a', 'b'] X~ 1 .. 3   to be ... ?

[17:54] <TimToady> what niecza produces "a b1 a b2 a b3"

[17:54] <pmichaud> 'a b1', 'a b2', 'a b3'    is my expectation

[17:55] <TimToady> X basically takes two parcels that need to each be treated as a slurpy

[17:55] <pmichaud> as a flattening slurpy?  

[17:55] *** unixms left
[17:56] <TimToady> yes, list infixes flatten

[17:56] <TimToady> unlike hypers

[17:56] <pmichaud> "as a slurpy" is ambiguous to me;   both **@lol and *slurpy are "slurpies"

[17:56] <pmichaud> *@slurpy

[17:57] <pmichaud> "slurpy" to me simply means variadic in nature  (perhaps I need an adjustment)

[17:57] <TimToady> sure, in my mind those are slurp args vs slurp items, but when I say "slurpy" in isolation it's usually to distinguish from lol

[17:57] <TimToady> so maybe we need a term for *

[17:57] <pmichaud> slurp items vs slurp flat is what I tend to think of

[17:58] <TimToady> well, it's the flattening slurpy

[17:58] <pmichaud> right

[17:58] <pmichaud> I should say     slurp lists vs. slurp flat

[17:58] *** daftdude joined
[17:58] <pmichaud> **@lol is the list slurpy, while *@slurpy is the item/flattening slurpy

[17:59] <TimToady> I think of ** as arg slurp because it's the same as binding to a positional

[17:59] <TimToady> ...to multiple positionals

[17:59] <pmichaud> I'm fine if we use "slurpy" to mean the "list slurpy" case.... although almost everything that has been written about p6 until now tends to use "slurpy" in conjunction with the flattening / *@slurpy case.

[17:59] *** daftdude left
[18:00] *** snearch joined
[18:00] <pmichaud> I can live with "arg slurp" if that works better for you.

[18:00] <pmichaud> lol slurp might make more sense

[18:01] <TimToady> from the S09 viewpoint it's more like a dimensional slurp: "Don't lose dimensional info"

[18:01] *** snearch left
[18:02] <pmichaud> anyway, the problem with Rakudo's   X   has to do with its mishandling of **@lol arguments.

[18:02] <pmichaud> I basically know what the problem is there, and how to fix it.

[18:02] <TimToady> well, I guess X is a vararg anyway, so ** kinda makes sense

[18:02] <pmichaud> correct

[18:03] <pmichaud> the issue with Rakudo's X  is that **@lol  itemizes everything in it

[18:03] <pmichaud> so Rakudo's X defaults to processing everything in the item, which means it looks inside of [ ]

[18:03] <dalek> nqp/pirt: 6ff18e2 | jnthn++ | src/QAST/PIRT.nqp:

[18:03] <dalek> nqp/pirt: Implement method calling. Down to six tests for t/qast/qast.t that fail.

[18:03] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/6ff18e2aa8

[18:03] <dalek> nqp/pirt: 01a918f | jnthn++ | src/QAST/Operations.nqp:

[18:03] <dalek> nqp/pirt: Be consistent in how we call infer_type. Leaves just two tests in qast.t failing.

[18:03] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/01a918f779

[18:03] <dalek> nqp/pirt: 6568e10 | jnthn++ | src/QAST/ (2 files):

[18:03] <dalek> nqp/pirt: Fix inline, which tests the remaining qast.t tests passing when using PIRT instead of POST.

[18:03] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/6568e10229

[18:03] <TimToady> I guess it's confusing because the lol operator *does* itemize everything, but ** doesn't

[18:03] *** mucker left
[18:03] <[Coke]> pirt?

[18:04] <pmichaud> correct, that's why Rakudo's **@lol itemizes stuff.

[18:04] <jnthn> [Coke]: Replacing POST.

[18:04] <pmichaud> I was folloiwng the .lol pattern.

[18:04] <TimToady> so we should definitely not call ** a "lol"

[18:04] <jnthn> [Coke]: A much, much smaller job than replacing PAST. :)

[18:04] <jnthn> [Coke]: With hopeful memory benefits.

[18:04] <pmichaud> I'm fine with that.  how about "slurpy args", then?

[18:04] <pmichaud> and we write  **@args

[18:05] <TimToady> seems an improvement

[18:05] <[Coke]> no relation to PIR?

[18:05] <TimToady> does this address the other non-lazy-parcel problem we were talking about earlier?

[18:05] <TimToady> don't remember the example offhand...

[18:05] <pmichaud> not directly, unless you feel that .plan is indeed the way to concatenate lists

[18:06] <TimToady> well, add args to a list

[18:06] <pmichaud> or are you referring to some other problem we were talking about before today?

[18:06] <TimToady> something triggered this list rethink a couple three weeks ago

[18:06] <pmichaud> oh, sure

[18:06] <pmichaud> it was the issue with how gather/take works with parcels

[18:06] <TimToady> my brane has been topsy turvy since then

[18:06] <pmichaud> yes, this starts to address that as well

[18:07] <TimToady> right, that were it

[18:07] <pmichaud> fixing gather/take is what led me to   #18

[18:07] <pmichaud> but the gather/take problem isn't so much an issue of how we deconstruct args, but more a problem of how we construct return results

[18:07] <TimToady> it seems natural to me that list treat .plan as args rather than items

[18:07] <jnthn> [Coke]: POST is the thing that gets turned into PIR

[18:07] <jnthn> [Coke]: PIRT (PIR Tree) fills the same role.

[18:07] <pmichaud> but .push would still be items?

[18:08] *** fgomez joined
[18:08] <pmichaud> (having .plan == args and .push == items works for me, fwiw)

[18:08] <TimToady> I don't see that; parcels still have to live through the reification

[18:08] <flussence> .oO( coming soon: nqp/partridge )

[18:09] <TimToady> but maybe that's orthogonal to .plan vs .push

[18:09] <pmichaud> none of these really affect Array; Array forces flattening anyway.

[18:10] <TimToady> right; just seems odd to me to supply a flattening method to pushing list when lists are supposed to be agnostic to flattening

[18:10] <TimToady> can always .plan: flat @stuff

[18:10] <pmichaud> I'm fine if .push does args instead of items; I just want to know where the parallels are(n't)

[18:10] *** spider-mario left
[18:10] <TimToady> I think I'd be more comfy with list.push pushing args

[18:11] <pmichaud> and .unshift also?

[18:11] <TimToady> presumably

[18:11] <pmichaud> wfm

[18:11] <pmichaud> so, the major difference between .push and .plan is the eagerness involved

[18:12] <pmichaud> (as it's been up to now, iiuc)

[18:12] <TimToady> well, eagerness at the arg level, not at the stuff inside the arg

[18:12] <pmichaud> correct.

[18:12] <pmichaud> (and agreed)

[18:13] <TimToady> it seems to be fitting together better now

[18:13] <pmichaud> anyway, I still need a week or so for resolving X/Z stuff

[18:13] <pmichaud> there's still some fragility in the list implementation where small changes result in surprising breakages.  But I think that can be all resolved this go-round

[18:14] <TimToady> sure, just trying to see the big picture again after involunary brane shrinkage

[18:14] <TimToady> *tary

[18:14] <pmichaud> switching **@lol to **@args interpretation eliminates one of the problematic constraints

[18:14] <pmichaud> at least, I think that's what it does :)

[18:15] <pmichaud> I'll update #18 with our discussions here.

[18:17] <TimToady> on lazy warnings, I'm still of two minds, after several weeks of background think

[18:17] <moritz> jnthn: can I remove the QAST milestone from ROADMAP? or do the remainng nqp migration and inliner work make it worth keeping it?

[18:18] <jnthn> moritz: I was thinking we'd remove it after migrating NQP to QAST.

[18:18] <TimToady> the unification with failure seems like a good thing in the case of +«@foo and such

[18:18] *** jaldhar joined
[18:19] <TimToady> but I wonder if the laziness will eventually bite us; I suppose I should worry more about lazy fatals biting us than lazy warnings, and I don't worry about that (much) :)

[18:20] <TimToady> also, it's a bit odd to have an undefined failure that yet has a Cool value, but I suppose that could be worked out somehow

[18:21] <TimToady> probably means we would need a Failure analog that is spelled differently to easily distinguish the has-a-value-anyway behavior

[18:22] <TimToady> there's also the fact that warnings are currently considered control exceptions, iirc

[18:23] <pmichaud> yes, warn is listed as a control exception

[18:23] <TimToady> call 'em Bogons or some such :)

[18:24] <TimToady> and instead of fail() we have bogus(), except that's not a verb

[18:24] <TimToady> bogey() :)

[18:24] *** snearch joined
[18:24] <TimToady> which is both noun and verb

[18:24] <pmichaud> well, I wasn't hoping for a new Failure class.  :-/

[18:24] <pmichaud> (I wasn't hoping for anything specific... but a new class wasn't it :)

[18:24] <TimToady> maybe it's a Failure that contains a Warning

[18:25] <TimToady> instead of an Exceptoin

[18:25] <moritz> maybe Warning isa Exception

[18:25] <moritz> or manybe Exception has a fatality attribute

[18:25] <TimToady> it's just resumable (and control)

[18:25] <TimToady> but something would need to introspect that to return 0 or '' or False

[18:26] <TimToady> unless we do something mixiny

[18:27] <TimToady> or maybe it's just fail($mywarning, :return(Nil))

[18:27] <TimToady> or maybe it's just fail($mywarning, :value(Nil))

[18:28] <TimToady> hmm, except that would produce another warning when Nil is evaluated...

[18:28] <TimToady> :value('') maybe

[18:28] <pmichaud> r:  say +Nil

[18:28] <p6eval> rakudo b87659: OUTPUT«use of uninitialized value of type Nil in numeric context  in block  at /tmp/Zb4T2bNjHV:1␤␤0␤»

[18:28] <pmichaud> yup.

[18:28] <TimToady> r: say +''

[18:28] <p6eval> rakudo b87659: OUTPUT«0␤»

[18:29] <TimToady> n: say +''

[18:29] <p6eval> niecza v19-15-g051783d: OUTPUT«0␤»

[18:29] <TimToady> looks like '' works

[18:31] <seldon> n: say +'abc'

[18:31] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Cannot parse number: abc␤  at /home/p6eval/niecza/lib/CORE.setting line 1414 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3492 (ANON @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3494 (NumSyntax.str2num @ 5) ␤  at …

[18:31] <seldon> Okay, so it's not just fed to atoi.

[18:31] *** Guest74836 left
[18:31] <moritz> I'm currently brainstorming which spec changes rakudo still needs to chase

[18:31] <moritz> currently I've come up with: sigilless variables and parameters

[18:31] *** GlitchMr left
[18:31] <moritz> the changes that ? makes to match objects

[18:32] <TimToady> oh, you mean x? -> x or Nil

[18:32] <moritz> right

[18:32] <pmichaud> the List stuff I'm working on (although there Rakudo is leading the spec change as much as chasing it :)

[18:32] <moritz> any other major-ish things that need updating?

[18:32] <pmichaud> leading whitespace under :sigspace

[18:32] <skids> Type1(Type2) in parameter lists?

[18:32] <moritz> skids++

[18:33] <TimToady> there's http://irclog.perlgeek.de/perl6/2012-07-27#i_5850929

[18:33] <pmichaud> aye.

[18:33] <pmichaud> so, use of $_ in a block prevents it from hashing

[18:33] <TimToady> yes, you have to use a temp var to do that

[18:34] <moritz> last we discussed this, there was a spec issue with that

[18:34] <moritz> but I can't remember what exactly it was

[18:34] <skids> moritz: handles trait?

[18:35] <moritz> skids: that's implemented

[18:35] <moritz> (at least nearlly all of it)

[18:35] <pmichaud> if we remember the spec issue, then file a github ticket for it :)

[18:35] <TimToady> I think getting map to DWIM on { .key => transform .value } is pretty important

[18:35] <pmichaud> TimToady: +1

[18:35] <pmichaud> it shouldn't be that hard; we just flag a block as using $_ when we encounter it.

[18:35] <TimToady> just have to notice that .foo uses $_

[18:36] <pmichaud> we do that already;  it desugars to a lookup of $_ in the ast, iirc

[18:36] <moritz> that looks like something I might be able to do

[18:36] <pmichaud> then if a block is using $_, we don't let it de-hashify.

[18:36] <pmichaud> alternatively, we may want to see if the block is treating $_ as a parameter and key on that.

[18:37] <skids> {}.assuming() ?

[18:37] <moritz> r: say { $^a => $^b}.WHAT

[18:37] <p6eval> rakudo b87659: OUTPUT«Block()␤»

[18:38] <TimToady> r: say { $_ => $_ }.WHAT

[18:38] <p6eval> rakudo b87659: OUTPUT«use of uninitialized variable $!key of type Any in string context  in block  at /tmp/u_Cst6Q1fC:1␤␤Hash()␤»

[18:38] <TimToady> it's just not paying attention to $_, seems

[18:38] <dalek> rakudo/nom: bfb50b2 | moritz++ | docs/ROADMAP:

[18:38] <dalek> rakudo/nom: [ROADMAP] add missing features and spec chases

[18:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bfb50b2db9

[18:38] <pmichaud> well, that's partially it.

[18:38] <pmichaud> in the case of { $^a => $^b }, the block has non-zero arity, so we know it's not a hash constructor

[18:39] <moritz> pmichaud, jnthn: feel free up correct my commit if you don't share my point of view about priorities and effort

[18:39] <pmichaud> in the case of { $_ => $_ }, the arity is zero

[18:39] <TimToady> whereas $_ blocks have <-> $_ = CALLER::<$_> or some such

[18:39] <pmichaud> (and I don't know if it's been decided at that point as to whether $_ is a parameter to the block or not, in the ast)

[18:39] <dalek> rakudo/nom: 8435346 | moritz++ | src/core/ (2 files):

[18:39] <dalek> rakudo/nom: implement Str.codes and Cool.codes

[18:39] <dalek> rakudo/nom: 

[18:39] <dalek> rakudo/nom: currently an alias for .chars

[18:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8435346634

[18:40] <pmichaud> moritz++ # .codes

[18:40] <TimToady> well, if it's decided by defaulting at call time, then you just have to guess at compile time, and in this case it should guess "parameter", I think

[18:40] <masak> moritz: you mean '.chrs' ?

[18:41] <pmichaud> masak: no, .chars

[18:41] <pmichaud> masak: .codes returns the number of codepoints in a string

[18:41] <masak> oh!

[18:41] <masak> right.

[18:41] <moritz> pmichaud: my current plan for detecting $_ usage is to have a dynamic variable $*USES_DOLLAR_UNDERSCORE or so per block, and set it to 1 in blocks that use $_

[18:41] <TimToady> darn overloaded plurals in English...

[18:41] <masak> we have both .chrs and .chars. yet another reason to scrap .chrs

[18:42] <moritz> pmichaud: and if that's the case, we don't execute the block to produce a hash

[18:42] <TimToady> and then you get the opposite failure mode

[18:42] <moritz> pmichaud: does that sound sane?

[18:42] <TimToady> "why didn't .chars return the chars?"

[18:42] <pmichaud> moritz: I'm not sure a dynamic works there.  At the point where the hash constructor decision has to be made, you're already out of the block parse (I think)

[18:42] <masak> nr: say <79 72 32 72 65 73>>>.chr.join

[18:42] <p6eval> rakudo b87659, niecza v19-15-g051783d: OUTPUT«OH HAI␤»

[18:43] <pmichaud> we decide whether to change a block to a hash constructor in   circumfix:sym<{ }>

[18:43] <TimToady> unless we make .chars lazy enough to optimize +.chars on the fly

[18:43] <jnthn> pmichaud, moritz: We may want to start recording variable accesses that a block makes in .symbol somehow.

[18:43] <skids> r: class C { method a handles Int { 3 } }; my C $c; # This form of the handles trait

[18:43] <p6eval> rakudo b87659: OUTPUT«===SORRY!===␤Cannot call 'trait_mod:<handles>'; none of these signatures match:␤:(Attribute:D $target, $thunk)␤␤»

[18:43] <masak> TimToady: one can't map words optimally to their effect. at some point people will have to learn what the methods do.

[18:43] <pmichaud> jnthn: yeah, that was more of what I was thinking.

[18:43] <masak> TimToady: but having .chrs and .chars isn't helping matters.

[18:43] <jnthn> That would let us implement this but also:

[18:44] *** quietfanatic joined
[18:44] <jnthn> std: my $a; { say $a; my $a }

[18:44] <p6eval> std e52e3ca: OUTPUT«[31m===[0mSORRY![31m===[0m␤Lexical symbol '$a' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::<$a>␤  before you can unambiguously declare a new '$a' in this scope at /tmp/j1B9tTyUEs line 1:␤---…

[18:44] <jnthn> That one.

[18:44] <TimToady> .unords :)

[18:44] <masak> TimToady: also -- see p6eval above -- .chrs is redundant in a way which "it's diagonal" doesn't excuse, IMO.

[18:44] <pmichaud> jnthn: I'm thinking it'd be fine for .symbol to record "seen but not declared in this blook"

[18:44] <pmichaud> PAST left a lot of the details of .symbol up to the user, so I'm hoping QAST does the same :)

[18:45] <jnthn> pmichaud: It's only used as a fallback for finding :scope

[18:45] <jnthn> pmichaud: Otherwise it's just a hash of hash.

[18:45] <pmichaud> actually, just "seen in this block" would be worthwhile.

[18:45] <quietfanatic> .chrs currently returns a list of characters, right?

[18:46] <jnthn> pmichaud: Anyway, I'm +1 to this.

[18:46] <TimToady> well, yes, and .ords is just .comb».ord, so if we remove one, we should remove the other

[18:46] <moritz> quietfanatic: no, chrs applies chr() to a list of integers, and joins them and returns a string

[18:46] <quietfanatic> ah

[18:46] <quietfanatic> so, .comb gives you a list of characters

[18:46] <moritz> correct

[18:47] <quietfanatic> but what if I want a list of, say, codepoints?

[18:47] <TimToady> but it seems like that the optimizer will end up optimizing both of those to some internal .ords/.chrs method, so why not expose it

[18:47] <quietfanatic> because that takes up one more name.

[18:47] <quietfanatic> I mean two morw names

[18:47] <moritz> quietfanatic: in theory, .comb/rx:codes/./)

[18:47] <pmichaud> expose can be good; it's the names that are confusing, I think

[18:48] <moritz> quietfanatic: but I don't really believe that it's a good idea to expose strings at different Unicode levels through a single type

[18:48] <moritz> that's old p5 think, where binary strings and text strings are also intermingled

[18:49] <TimToady> well, we may well end up with CodeStr or some such as an intermediate between Buf and Str

[18:49] <pmichaud> jnthn: changing --prefix to '\rakudo' seems to have eliminated a lot of the C:'s from the config hash.  Now I'll see if it works at all when on a drive other than c: :-)

[18:49] <TimToady> or maybe they're called NFC, NFD, etc to keep those ideas straight too.

[18:50] <quietfanatic> How about just a list of X where X is whatever?

[18:50] <pmichaud> although all that does for us is mean that the install still works when it ends up on drive 'd' or whatever.  People will then ask "why did the installer put it on 'd'?  I want it on 'c'!"

[18:50] <quietfanatic> If I want to think of it as a continuous string, I'll use a Str.  If I want to think of it as a list of X, why not a real list of X?

[18:51] <pmichaud> ....on the plus side, if it works on any drive, that would mean it could work on a flash drive :-)  testing that now.

[18:51] <moritz> quietfanatic: and what is X? words?

[18:51] <TimToady> well, Buf is already positional

[18:51] <quietfanatic> characters, codepoints, bytes, whatever strings could be composed of

[18:51] <TimToady> but compact, whereas "real list" means high overhead to me

[18:51] <moritz> quietfanatic: that's how I think of text most of the time (list of words and punctuation chars)

[18:51] <masak> TimToady: I'd much rather see .comb».ord in my code than .ords, simply because I can mix and match .comb, », .ord and many other constructs to create a nice flexible result. .ords is a one-trick pony, like PHP's array_slice.

[18:52] <TimToady> so Buf[Codes] is already more or less specced to be listy

[18:52] <quietfanatic> Ah, I guess I'm still used to langugaes where lists are not very high-overhead.

[18:52] <pmichaud> idiomatically, I've been wondering lately if we should encourage a lot more use of », if only because it implies parallelization/optimization potential.

[18:52] <quietfanatic> like C, where most are arrays or intrusive linked lists

[18:53] <TimToady> masak: but we huffmanize for common one-trick ponies all the time

[18:53] <TimToady> see "say"

[18:53] <moritz> pmichaud: if we want that, we shoudl first benchmark if » is at least somewhat fast right now

[18:53] <quietfanatic> say now does something different though :)

[18:53] <masak> this is not an important huffminaztion. it's the relative lack of merit which bothers me.

[18:54] <masak> we should focus on overpopulating CORE with useful stuff :)

[18:54] <quietfanatic> I don't think .ords is very common, personally

[18:54] <masak> right.

[18:54] <pmichaud> moritz: I suspect it's about as fast as .map; if not, it can certainly be made so.  In fact, I bet it can be made a lot faster than .map because we don't have to worry about exceptions or laziness.

[18:54] <masak> I could argue for .abss as well, because sometimes I just want to do .abs on all those list elements.

[18:55] <moritz> pmichaud: iirc » uses .pick for non-determinstic order

[18:55] <pmichaud> moritz: we've been doing that simply to prevent people from misapplying » as map where order matters.

[18:56] <pmichaud> I can still come up with a faster » that does things in a non-deterministic order, I think.

[18:56] <TimToady> well, I guess I might argue that you really want .encode(NFG) instead of .ords, assuming a Buf[NFGChar] can listify appropriately

[18:56] <moritz> pmichaud: that's fine, but I just suspect it won't be fast right now

[18:57] <pmichaud> moritz: anyway, I was thinking primarily idiomatically.  We should probably first agree that encouraging » use is a good thing; and if so I'll happily update the hyper code in rakudo to be a lot faster than it is :)

[18:57] <quietfanatic> Bufs can act like lists, can't they?  They do Positional.

[18:57] <pmichaud> yeah, I think that .ords is just some form of Buf :-)

[18:58] <moritz> r: say 'OH HAI'.encode.list

[18:58] <p6eval> rakudo b87659: OUTPUT«79 72 32 72 65 73␤»

[18:58] <TimToady> nr: my $x = Buf.new("foobar"); .say for @$x;

[18:58] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'Buf' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1402 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/p6…

[18:58] <p6eval> ..rakudo b87659: OUTPUT«This type cannot unbox to a native integer␤  in method set_codes at src/gen/CORE.setting:6758␤  in method new at src/gen/CORE.setting:6750␤  in block  at /tmp/QN9yo49rod:1␤␤»

[18:58] <pmichaud> nr:  my $x = "foobar".decode;  .say for @($x);

[18:58] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method decode in type Str␤  at /tmp/PwbqtDhOn5 line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /home…

[18:58] <p6eval> ..rakudo b87659: OUTPUT«No such method 'decode' for invocant of type 'Str'␤  in block  at /tmp/wxi0PLd_SK:1␤␤»

[18:58] <TimToady> nr: my $x = Buf.new(65..70); .say for @$x;

[18:58] <p6eval> rakudo b87659: OUTPUT«65␤66␤67␤68␤69␤70␤»

[18:58] <p6eval> ..niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤        'Buf' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1402 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/p6…

[18:58] <moritz> TimToady: there's no Buf.new(Str) constructor

[18:59] <moritz> pmichaud: it's Buf.encode :-)

[18:59] <pmichaud> moritz: what's the method for going the other way?

[18:59] <TimToady> there should be one that handles ASCII, I suspect

[18:59] <moritz> pmichaud: erm sorry, Str.encode, Buf.decode

[18:59] <TimToady> and "foo" as a literal should allomorphically be both Buf and Str somehow, if the world were perfect

[19:00] <pmichaud> r:  .say for "foobar".encode

[19:00] <p6eval> rakudo b87659: OUTPUT«Buf:0x<66 6f 6f 62 61 72>␤»

[19:00] <pmichaud> r:  .say for "foobar".encode.list

[19:00] <p6eval> rakudo b87659: OUTPUT«102␤111␤111␤98␤97␤114␤»

[19:00] <pmichaud> r:  .say for "foobar".encode[]

[19:00] <p6eval> rakudo b87659: OUTPUT«102␤111␤111␤98␤97␤114␤»

[19:00] <quietfanatic> sounds like you want Haskell-style overloaded literals :)

[19:00] <TimToady> I'm sure I wanted them from before Haskell was on my radar

[19:01] * TimToady and allomorphism go way back

[19:01] <diakopter> i'd love for the regex engine to be able to operate on buf8 in utf8 mode

[19:02] <diakopter> while Im dreaming

[19:02] <quietfanatic> I'd personally prefer an object that coerces two ways than a type-classed polymorphic thing that is two objects simultaneously.

[19:02] <quietfanatic> s/than/over

[19:04] <pmichaud> jnthn: perhaps I should have the MSI always compile/install to "Program Files\Rakudo\..."  ?

[19:05] <pmichaud> (and yes, it appears that I have Rakudo running from E:\rakudo   just fine :)

[19:05] <diakopter> make shre to install to the 64-bit one as appropiate

[19:05] <moritz> pmichaud: and if you put it in %PATH%, can you call it from a different drive?

[19:05] <pmichaud> moritz: checking

[19:06] <pmichaud> moritz: ah, sadly no.

[19:07] <pmichaud> so, it's not really relocatable to a different drive.

[19:07] <jnthn> pmichaud: iirc, we have problems with paths with spaces in somewhere.

[19:07] <jnthn> Sure there's a ticket on that

[19:08] <pmichaud> jnthn: okay.

[19:08] <moritz> iirc that's our fault, parrot can handle it

[19:08] <pmichaud> So, I need to figure out how to get the installer to always go to C:\rakudo, no matter what.

[19:08] <pmichaud> I'll work on that.

[19:09] *** spider-mario joined
[19:09] <jnthn> moritz: I'm fairly sure t's an RT ticket I was thinking of. :)

[19:09] <jnthn> *it's

[19:09] <dalek> nqp/pirt: 16694d7 | jnthn++ | src/QAST/ (2 files):

[19:09] <dalek> nqp/pirt: Get hll and namespace bits added.

[19:09] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/16694d74ac

[19:09] <dalek> nqp/pirt: de2b269 | jnthn++ | src/QAST/PIRT.nqp:

[19:09] <dalek> nqp/pirt: Oops, forgot this important memory-freeing line!

[19:09] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/de2b269a49

[19:09] <dalek> nqp/pirt: dd40b44 | jnthn++ | src/QAST/PIRT.nqp:

[19:09] <dalek> nqp/pirt: Stub in node support for annotations, though not emitting them yet.

[19:09] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/dd40b448ff

[19:09] <dalek> nqp/pirt: 7fcb20b | jnthn++ | src/HLL/Compiler.pm:

[19:09] <dalek> nqp/pirt: Update HLL::Compiler.pir so it knows about PIRT as well as POST.

[19:09] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/7fcb20bcb8

[19:09] <TimToady> quietfanatic: sure, that's the direction we went overall with P6's Cool, rather than the P5 approach, but the problem is how you cache to avoid reconversion of heavy things like strings

[19:10] <mhasch> re allomorphism: for literals, it is not unusual for a language to make them compatible to different types at once. We did that in the 80's with Wirth languages all the time.

[19:10] <TimToady> also, Bufs, unlike Strs, are mutable

[19:10] <moritz> don't we have immutable bufs too?

[19:10] <moritz> we could use those instead of Buf

[19:12] <quietfanatic> mutability vs. immutability is something I'd like to see abstracted out

[19:12] <quietfanatic> rather than having two types for everything, one mutable and one immutable

[19:12] <quietfanatic> with names that don't convey that difference.

[19:13] <moritz> that would be nice, yes

[19:13] <pmichaud> I don't know that we have many of the "two types for everything" situation now

[19:13] <pmichaud> (so I agree we shouldn't introduce/extend it)

[19:14] <quietfanatic> yeah, it's not actually that bad

[19:15] <quietfanatic> but do we still have Seq, for instance?

[19:15] <pmichaud> not currently

[19:15] <moritz> it seems Blob is the immutable version of Buf

[19:15] <pmichaud> and I've been hoping to not reintroduce Seq

[19:15] <pmichaud> (and thus far, quite successful)

[19:15] <moritz> ok, we have Buf/Blob, Pair/Enum, Hash/EnumMap

[19:16] <pmichaud> I still don't think that Enum should be immutable; it's just a binding instead of a container relationship, like List/Array

[19:16] <pmichaud> same for Hash/EnumMap.  And we already remarked a couple of days ago that EnumMap is the wrong basis for Hash.

[19:16] <masak> aye.

[19:18] <quietfanatic> Is Enum just a single pair-like thing?

[19:18] <moritz> yes

[19:18] <quietfanatic> I'd have thought of an Enum as the whole listing

[19:18] <moritz> an immutable pair

[19:18] <moritz> and it's a terrible name

[19:18] <quietfanatic> An enum should be the whole thing, not a piece

[19:19] <pmichaud> I could be wrong, but I think Enum was trying to introduce a parallelism to List/Seq (that we've since eliminated)

[19:19] <quietfanatic> enumeration

[19:19] <masak> quietfanatic: you'll have to take that up with S12.

[19:19] <masak> quietfanatic: it's quite clear on the enum/enumeration distinction, to the point where it actually defines it.

[19:20] <quietfanatic> well

[19:20] <quietfanatic> it's all names anyway

[19:20] <quietfanatic> but it seems to me that singular of enumeration is like

[19:20] <quietfanatic> number

[19:21] <quietfanatic> :)

[19:21] <mhasch> I agree with moritz that the name "enum" is not very intuitive.

[19:21] <masak> quietfanatic: sometimes it's a number.

[19:21] <quietfanatic> numeral

[19:21] <masak> quietfanatic: of course, it's a name, too.

[19:21] * masak gets out of the bikeshed before things get "interesting"

[19:22] <quietfanatic> right, I think 'enum' has too far evolved from its etymological origins to be compared to it.

[19:22] <timotimo> how about "symbol" instead? :|

[19:23] <moritz> timotimo: too generic

[19:23] <timotimo> true. and "icon" makes one think about graphical things too much

[19:23] <quietfanatic> well, it's a mapping of one symbol to a thing

[19:23] <pmichaud> catalog.  dictionary.  mapping.

[19:23] <pmichaud> index.

[19:23] <timotimo> in't it the point that it isn't a catalog? just one thing inside a catalog?

[19:23] <quietfanatic> how about just a constant Pair, hm?

[19:23] <moritz> lets rename EnuMap to Mapping, and Enum to Mappy

[19:23] <moritz> because it's a mini Map

[19:24] <masak> :)

[19:24] <masak> +1

[19:24] <quietfanatic> Maplet?

[19:24] <quietfanatic> Mappy sounds like a role

[19:24] <masak> or Maplet.

[19:24] <moritz> +1 to Maplet

[19:24] <pmichaud> careful with "Map" named things; they pun with ".map"

[19:24] <jnthn> Who has ever used the fact that you can assign to a Pair's value, ooc?

[19:24] <masak> Mapka :)

[19:24] <jnthn> Mapka! \o/

[19:24] <masak> \o/

[19:24] <pmichaud> jnthn: TimToady was remarking that he wanted => to produce mutable things.

[19:24] <pmichaud> (at yapc::na)

[19:25] <quietfanatic> like a cons pair, yes

[19:25] <pmichaud> and certainly when iterating over a hash's pairs, you expect to be able to assign to them.

[19:25] <jnthn> r: my $a = foo => 42; say $a.value; $a.value = 100; say $a

[19:25] <p6eval> rakudo 843534: OUTPUT«42␤"foo" => 100␤»

[19:25] <jnthn> Hm, seems we already implement it

[19:25] <pmichaud> correct.

[19:25] <jnthn> Oh...the iteration thing is a decent use case I guess.

[19:26] <pmichaud> r:  my %h = a=>1, b=>2, c=>3;   for %h { .value *= 2; };   say %h.perl

[19:26] <p6eval> rakudo 843534: OUTPUT«("a" => 1, "b" => 2, "c" => 3).hash␤»

[19:26] <pmichaud> hmmm

[19:26] <pmichaud> r:  my %h = a=>1, b=>2, c=>3;   for %h.pairs { .value *= 2; };   say %h.perl

[19:26] <p6eval> rakudo 843534: OUTPUT«("a" => 1, "b" => 2, "c" => 3).hash␤»

[19:27] <pmichaud> hmmmm

[19:27] <pmichaud> that looks like a bug to me.

[19:27] <moritz> it is

[19:27] <quietfanatic> r:  my %h = a=>1, b=>2, c=>3;   for %h.pairs <-> $p { $p.value *= 2; };   say %h.perl

[19:27] <p6eval> rakudo 843534: OUTPUT«===SORRY!===␤Missing block␤at /tmp/ZH3gTo9iFY:1␤»

[19:27] <moritz> it seems we recontainerize at some point

[19:27] <pmichaud> I think that .pairs must not be returning the correct binding.

[19:27] <moritz> might be the .pairs

[19:28] <TimToady> n: my %h = a=>1, b=>2, c=>3;   for %h.pairs { .value *= 2; };   say %h.perl

[19:28] <p6eval> niecza v19-15-g051783d: OUTPUT«{"a" => 2, "b" => 4, "c" => 6}.hash␤»

[19:28] <moritz> niecza++

[19:28] <pmichaud> i.e., .pairs is constructing a new Pair instead of creating a Pair that is properly bound.

[19:28] <TimToady> p: my %h = a=>1, b=>2, c=>3;   for %h.pairs { .value *= 2; };   say %h.perl

[19:28] <p6eval> pugs: OUTPUT«\(\("a", 2), \("b", 4), \("c", 6))␤»

[19:28] <moritz> r: my %h = a => 1; %h.pairs[0].value = 5; say %h.perl

[19:28] <p6eval> rakudo 843534: OUTPUT«("a" => 1).hash␤»

[19:28] <pmichaud> ...which is why I continue to say that the Enum/Pair relationship is wrong.

[19:28] <pmichaud> (in Rakudo, at least.)

[19:30] * pmichaud reads S12 to find out why Enum is "Enum"

[19:30] *** hoelzro|away is now known as hoelzro

[19:30] <hoelzro> good evening P6 folk

[19:31] <timotimo> maybe it shouldn't be Enum, but ANum instead

[19:32] <quietfanatic> heheh

[19:32] <pmichaud> speculating a bit, I'd prefer to eliminate "Enum" as a separate type.  Just go with "Pair", which binds a name+value pair.   The => operator then produces a Pair with the rhs coreced into a scalar container.

[19:33] <hoelzro> if I were to submit a test for Perl6, I take it I should submit it to perl6/roast?

[19:33] <pmichaud> if we need a separate Enum type, I'd want it to be for more than a "immutable/mutable" distinction.

[19:33] <pmichaud> hoelzro: yes.

[19:33] <pmichaud> hoelzro: or even better, just commit it directly to roast :)

[19:34] <hoelzro> awesome =)

[19:34] <masak> pmichaud: +1

[19:34] <pmichaud> in other words, Pair is more analogous to what List does than what Array does.

[19:35] <pmichaud> (List doesn't force mutability of its elements, it just binds to them)

[19:36] <jnthn> pmichaud: To be clear: you're suggesting it's => that delivers the mutability, not Pair itself?

[19:36] <TimToady> .oO(cons cell)

[19:36] <pmichaud> jnthn: yes.

[19:36] <jnthn> pmichaud: Seems workable.

[19:36] <pmichaud> and if you want a Pair that is bound, use  :=>

[19:36] <pmichaud> or something like that.

[19:36] <jnthn> More smileys in Perl 6 syntax!

[19:37] <moritz> +1 to a separate syntax

[19:37] <moritz> pairs are very often used for named arguments

[19:37] <moritz> and those are bound RO by default

[19:38] <pmichaud> alternatively, let   => indicate the binding operation, and introduce a new one that handles mutability.   =$>

[19:38] <moritz> =$> is somwhat neat

[19:39] <quietfanatic> Now we're pushing the mutability system onto our operators

[19:39] <moritz> note that hashes could still automatically do mutability

[19:39] <pmichaud> quietfanatic: actually, it's more "coerce" or "containerize"  than "make mutable"

[19:39] <quietfanatic> which, arguably, is what we've been doing all along with ::= and such

[19:39] <pmichaud> quietfanatic: correct.

[19:40] <moritz> so  my %h = a => 1, b => 2;  %h<a> = 5; # still works even if => constructs immutable pairs by default

[19:40] <quietfanatic> pmichaud: right

[19:40] <pmichaud> moritz: yes, I still believe that Hash is analogous to Array

[19:40] <quietfanatic> Well, a Hash isn't stored as a list of Pairs, is it?

[19:40] <moritz> it's not

[19:40] <moritz> it's only notionally one

[19:40] <quietfanatic> I mean, it probably doesn't have actual Pair objects inside of it.

[19:41] <quietfanatic> though I suppose it could

[19:41] <pmichaud> and I think it's useful to have a non-container-forcing version of Hash ("Mapping"), but it shouldn't be EnumMap which seems to want Positional characteristics.

[19:41] <pmichaud> (and ordering)

[19:42] <mhasch> (and distinct values)

[19:42] <moritz> that seems to be what EnumMap is meant to be, according to S12

[19:42] <quietfanatic> Just pun the Associative role?

[19:42] <moritz> but then we shouldn't have Hash ~~ EnumMap

[19:42] <quietfanatic> or, that role doesn't provide a default implementation so never mind

[19:43] <moritz> which is what pmichaud++ said all along, iiuc

[19:43] <pmichaud> moritz: yes.  :)

[19:43] <pmichaud> I think EnumMap should be a Mapping that is also ordered.

[19:43] <masak> sounds about right.

[19:43] <pmichaud> and its pairs are bound directly to the enumerated values

[19:43] <hoelzro> if I add a new (Rakudo failing) test to roast, should I mark it as "fudged" for Rakudo

[19:43] <pmichaud> (currently called "Enumerations")

[19:44] <moritz> hoelzro: yes

[19:44] * hoelzro is still getting his head around all of the projects and how they fit together

[19:44] <pmichaud> hoelzro: yes, that would be helpful.  But getting the test into roast is more important to us than having it properly fudged.

[19:44] <hoelzro> ok

[19:44] <pmichaud> i.e., we can fudge the test if we discover it doesn't work.  we're mostly interested in having the test. 

[19:45] * quietfanatic still wants mutability as a graspable aspect of the type system

[19:45] <quietfanatic> more specifically, I'd like an easy mechanism to point to a mutable object and say "I want this except immutable"

[19:45] <quietfanatic> and vice-versa

[19:46] <masak> there's something to be said for that.

[19:46] <pmichaud> quietfanatic: there's been a lot of discussion about "readonly" objects.

[19:46] <masak> but I believe it's not as easy as it sounds.

[19:46] <masak> based on exactly those discussions.

[19:46] <TimToady> graspable, but not shoved in the face of newbies

[19:46] <quietfanatic> yes

[19:47] <quietfanatic> actually, the distinction between 'value' and 'container' types might be what I'm looking for

[19:47] <quietfanatic> at least, for making immutable things mutable

[19:48] <quietfanatic> like we have with putting Scalar objects in a List

[19:48] <pmichaud> I need lunch; I'll bbiaw

[19:48] <quietfanatic> but the other way around is a little more tricky

[19:48] <quietfanatic> maybe we don't need the other way around as much

[19:49] *** kaare_ left
[19:49] <moritz> well, I'd like a simple way to mark user-defined classes so that their objects are immutable once they are created

[19:49] <moritz> for example Date objects are immutable, but the compiler doesn't really know that

[19:49] <moritz> there just aren't any methods that mutate the values

[19:50] <TimToady> so the compiler knows it, it just doesn't know it knows it

[19:50] *** bonsaikitten joined
[19:51] <TimToady> if this was Haskell we'd s/class/data/ for immutables, and confuse everyone

[19:52] <TimToady> it always bothers me that "data" doesn't mean "data" in Haskell

[19:52] <quietfanatic> it's more like 'struct'

[19:52] *** am0c left
[19:53] <TimToady> data means metadata, and type means metatype :)

[19:53] <quietfanatic> I...don't think either of those is correct :)

[19:54] <quietfanatic> type is equivalent to typedef, by the way, so it really is type.

[19:54] <TimToady> well, but my impression is that they're really type classes, somewhat generic

[19:54] <quietfanatic> 'class' makes a type class.

[19:55] <TimToady> well maybe it's class is metaclass I was thinking of

[19:55] <quietfanatic> Actually, it's more like if you could templatize a typedef in C++

[19:55] <quietfanatic> that's more like it, yeah

[19:56] <quietfanatic> (re: metaclass)

[19:56] <quietfanatic> ('type' is more like a templatized typedef)

[19:56] *** birdwindupbird joined
[19:56] <TimToady> FP languages tend to unify the "meta" with the "generic"

[19:57] <quietfanatic> People show off object-oriented features and inheritance and such in Haskell's type classes, but they're hard to use since they're two levels of abstraction above normal object.

[19:57] <quietfanatic> normal classes are only one level of abstraction up.

[19:58] <TimToady> we put generics and metas 2 up, and classes 1 up in P6

[19:58] <quietfanatic> generics?

[19:58] <TimToady> roles

[19:58] <quietfanatic> metas?

[19:58] <masak> generic roles.

[19:58] <quietfanatic> ah

[19:58] <TimToady> .HOW

[19:58] <masak> well, the MOP in general. :)

[19:59] <TimToady> actually, .HOW is 3 up, since roles also have meta

[19:59] <quietfanatic> I think of a role as one level up though, just in kind of a different direction :)

[19:59] <hoelzro> yay! first pull request to perl6/roast!

[19:59] <jnthn> Roles have more than one manifestation in meta-space anyway :)

[19:59] <quietfanatic> Also, there's a unique .HOW for every class, right?  That suggests to me that it's on the same level

[19:59] <quietfanatic> maybe instead of levels of abstraction I mean levels of generalization.

[19:59] <jnthn> The default MOP makes it that way, yes.

[20:00] <TimToady> a unique metaobject, not necessarily a unique metaclass

[20:00] <quietfanatic> eh? huh? >.<

[20:00] * quietfanatic is now getting confused

[20:00] <quietfanatic> what is a metaclass?

[20:00] <TimToady> where metaclass means the class of the metaobject

[20:00] <jnthn> All of the meta-objects for classes are instances of the class Meatmodel::ClassHOW.

[20:00] <masak> there's a unique *instance* of ClassHOW per class.

[20:00] <jnthn> Right.

[20:01] <quietfanatic> Aah

[20:01] <TimToady> Meatmodel, yum

[20:01] <masak> there's only one ClassHOW type, by default.

[20:01] <masak> quietfanatic: sorry, the terminology is confusing.

[20:01] <masak> I tend to avoid the word "metaclass" because it's overloaded :)

[20:01] <quietfanatic> so ClassHOW is on the third leve.

[20:01] <masak> I'd say it's second level still.

[20:01] <quietfanatic> *level

[20:01] <jnthn> uh, Metamodel :P

[20:01] <TimToady> metacircularity at that level

[20:02] * masak .oO( I never metacircularity I didn't yo dawg )

[20:02] <quietfanatic> yeah, at the point where classes generalize over classes, you don't really have levels any more.

[20:02] <jnthn> Though if you chase 6model down far enough you get to "classes not invented yet". :)

[20:02] <masak> \o/

[20:02] <masak> that's *awesome*.

[20:02] <masak> you could build anything!

[20:02] <jnthn> Being a class is really just a function of having a meta-object that makes you behave like one.

[20:02] <quietfanatic> in fact, I'd say that a metaobject is already breaking the levels, being a first-level thing (an object) describing a second-level thing (a class)

[20:03] <TimToady> hence the need to cheat on .HOW's args

[20:03] * masak .oO( in Perl 6, classes aren't built in, they're just a question of attitude )

[20:03] <quietfanatic> stay classy, #perl6

[20:03] <jnthn> I don't really thing of it in "levels", tbh. A meta-object is just an object that describes how another object works.

[20:03] <moritz> so it's all(1, 3 ... *)

[20:03] <moritz> :-)

[20:04] <masak> moritz: at the very least! :P

[20:04] <TimToady> but it takes 2 to tango!

[20:04] <masak> guys, you're making poor Bertrand Russel faint.

[20:04] <masak> Russell*

[20:04] <quietfanatic> In Haskell you have to be acutely aware of what level you're working on.

[20:04] <quietfanatic> of course.

[20:04] <moritz> you have to in any language

[20:04] <TimToady> s/ <?after aware>.* //

[20:05] <moritz> it's just that in Haskell the type checker will smite you if you forgot

[20:05] <quietfanatic> What I mean is, in Haskell the three levels are very distinct and completely incompatible.

[20:06] <quietfanatic> whereas Perl 6 contains all these back doors that make them the same level in the end.

[20:06] <masak> in Smalltalk, too.

[20:06] <masak> but looking at the Smalltalk MOP nowadays makes it clear that it was married to inheritence in a way that no longer feels healthy.

[20:07] <masak> (Smalltalk 80, that is)

[20:07] <TimToady> that's so we can teach people using "Oh, by the way, an X is just a special kind of Y."

[20:07] <quietfanatic> Classical prototype-based object systems don't feel right to me

[20:07] <quietfanatic> for the same reason as making every method virtual by default.

[20:07] <quietfanatic> oh wait :)

[20:07] <TimToady> well Smalltalk -> traits -> P6 roles

[20:08] <TimToady> which is why we have non-virtual methods too; they're just not the default like in C++

[20:09] <TimToady> and they're really just disguised subs

[20:09] <quietfanatic> inheritance in general is kind of a broken concept IMO

[20:09] <quietfanatic> what do you mean?

[20:09] <quietfanatic> submethods?

[20:09] <TimToady> no, private methods

[20:09] <quietfanatic> but private methods are private.

[20:09] <TimToady> yup :)

[20:09] <TimToady> but you can trust others with the care and feeding of them

[20:10] <TimToady> we just don't make it easy

[20:10] <masak> we have subs *and* submethods *and* private methods -- and the latter two can be combined.

[20:10] <TimToady> we want people to do the right thing by accident most of the time

[20:10] <masak> and I find I'm using all of those hiding mechanisms.

[20:10] <quietfanatic> I don't think inheritance is the right thing though

[20:10] <TimToady> uh, no, submethods have different visibility from private methods

[20:10] <masak> aye.

[20:10] <moritz> aye

[20:11] <TimToady> submethods live in normal method namespace

[20:11] <jnthn> masak: Comining submethods and private methods is odd given private methods are non-virtual anyway. :)

[20:11] <quietfanatic> The problem with inheritance and virtual methods is that they make each class actually mean two things:

[20:11] <moritz> can submethods be multi?

[20:11] <masak> jnthn: hm, I might not have done private submethods, come to think of it :)

[20:11] <jnthn> (I presume you mean submethod !foo() { })

[20:11] <masak> moritz: yes.

[20:11] <masak> jnthn: yes.

[20:11] <TimToady> 'course, even virtual methods are just functions if you scratch away the dispatcher

[20:11] <jnthn> moritz: Mumble.

[20:11] <quietfanatic> the interface the class exposes, and the default implementation of that interface, which have the same name and can't be separated.

[20:11] <masak> moritz: private methods can be multi too, just not in Rakudo.

[20:12] <masak> TimToady: yes, but late binding makes them operationally very different even if they are "just functions".

[20:13] <quietfanatic> default-virtual functions make keeping invariants pretty hard too.

[20:13] <quietfanatic> s/functions/methods

[20:13] <quietfanatic> well, at this point I'm just ranting.  I doubt I'll actually be able to change anything.

[20:13] <moritz> quietfanatic: we do encourage role usage in Perl 6 for those reasons

[20:13] <TimToady> masak: sure, but that's all in the dispatch that I just scratched away

[20:14] <moritz> quietfanatic: and I guess there are places in core where we could more stuff out of classes and into roles

[20:14] <TimToady> quietfanatic: invariants are supposed to be calculatable at CHECK time, assuming there have been no declarations to keep a class open or non-final

[20:15] <TimToady> we just default finalization opposite to Java

[20:15] <moritz> quietfanatic: so, concrete feedback on how to factor things in more reusable ways are very welcome

[20:15] <quietfanatic> moritz: Roles are better, in that they encourage separation of interface from implementation, but they still allow you to do weird wrong things with them.

[20:15] <TimToady> alternately, you can look at roles as final classes done right

[20:15] <quietfanatic> (if you aren't disciplined)

[20:15] <moritz> quietfanatic: you won't get Haskell-level type safety in p6, no matter what you'll try

[20:16] <TimToady> well, I suppose one could define the Haskell subset(superset) of Perl 6

[20:16] <moritz> it's still a dynamic language, late bound and thus less safe

[20:16] <quietfanatic> TimToady: Explicit invariants made with 'where' clauses, sure, but other properties of classes you expect to hold may not hold if a subclass can override bits of it.

[20:17] <quietfanatic> yeah

[20:17] <quietfanatic> moritz: I get that, yeah

[20:17] <TimToady> that's what "final" means, there are no subclasses

[20:18] <quietfanatic> I'm more concerned with, as TimToady said, getting people to do the right thing by accident most of the time

[20:18] <quietfanatic> and the majority of object-oriented tutorials explain things with inheritance and virtual methods.

[20:19] <masak> r: role R[::T] { multi foo(T $x) { say "{T} $x!" } }; class C does R[Str] does R[Int] {}; given C.new { .foo("OH HAI"); .foo(42) }

[20:19] <p6eval> rakudo 843534: OUTPUT«No such method 'foo' for invocant of type 'C'␤  in block  at /tmp/s7ey2sVBWu:1␤␤»

[20:19] <masak> huh.

[20:19] <moritz> hoelzro: you now have commit access to roast, and a bunchof other repos in the perl6 organization

[20:19] <ingy> moin

[20:19] <masak> r: role R[::T] { multi method foo(T $x) { say "{T} $x!" } }; class C does R[Str] does R[Int] {}; given C.new { .foo("OH HAI"); .foo(42) }

[20:19] <p6eval> rakudo 843534: OUTPUT«use of uninitialized value of type Str in string context  in method foo at /tmp/7S5gG1LU8V:1␤␤ OH HAI!␤use of uninitialized value of type Int in string context  in method foo at /tmp/7S5gG1LU8V:1␤␤ 42!␤»

[20:19] <masak> r: role R[::T] { multi method foo(T $x) { say "{T.^name} $x!" } }; class C does R[Str] does R[Int] {}; given C.new { .foo("OH HAI"); .foo(42) }

[20:19] <p6eval> rakudo 843534: OUTPUT«Str OH HAI!␤Int 42!␤»

[20:19] <masak> \o/

[20:19] <masak> that's pretty nice.

[20:20] *** SamuraiJack left
[20:20] <TimToady> S12:188 and S12:2130 talk about closing and finalizing, but we don't implement it yet

[20:20] <quietfanatic> (now I'm just complaining.  Come one, TimToady, say something sharp and put me in my place :)

[20:20] <TimToady> oh, is that what you're gunning for? :)

[20:20] <quietfanatic> not exactly, but whatever

[20:21] <ingy> Scissors!

[20:21] <hoelzro> moritz: thanks!

[20:21] * masak pictures ingy running with scissors

[20:21] <masak> ingy: be careful! o.O

[20:21] <hoelzro> should I just push my change to roast?

[20:21] <TimToady> when I was eating lunch and watching quietfanatic++ enter battle on #perl6, I was desperately trying not to think about Denethor :)

[20:22] <moritz> hoelzro: you should adjust your system clock :-)

[20:22] <ingy> masak: I've made it this far running with scissors :)

[20:22] <moritz> hoelzro: temp $value = $value + 1;  # doesn't do what you think, I guess

[20:22] <hoelzro> moritz: what *should* it do?

[20:22] <TimToady> we always raised our kids by treating them like kids when they behaved like kids, and treating them like adults when they behaved like adults

[20:23] <moritz> hoelzro: temp acts immediately

[20:23] <hoelzro> eesh, my clock is f'ed up

[20:23] * TimToady thinks quietfanatic++ has been behaving like an adult

[20:23] <moritz> hoelzro: ie it's like    temp $value;  $value = $value + 1

[20:23] <quietfanatic> So behaving like an adult is going online and fussing about things you don't like?

[20:23] <moritz> hoelzro: which means that $value is Any, and you get a warning from the +

[20:23] <quietfanatic> :)

[20:23] <hoelzro> moritz: those two are equivalent?

[20:23] <moritz> quietfanatic: there's fussing and there's fussing

[20:23] <moritz> hoelzro: yes

[20:23] <hoelzro> ok, that's what I expected

[20:24] <masak> r: say "fussing" ne "fussing"

[20:24] <p6eval> rakudo 843534: OUTPUT«False␤»

[20:24] <hoelzro> in Perl 5 speak, it's local $value = $value; $value += 1, right?

[20:24] <masak> moritz: Rakudo claims they're the same, though :P

[20:24] <jnthn> r: my $a = 1; { temp $a = $a + 1; say $a; }; say $a

[20:24] <p6eval> rakudo 843534: OUTPUT«2␤1␤»

[20:24] <moritz> hoelzro: no

[20:24] *** cognominal joined
[20:24] <jnthn> temp doesn't throw away the old value 

[20:24] <moritz> erm

[20:24] <moritz> wait

[20:24] <moritz> now I'm confused

[20:24] <masak> why?

[20:24] <jnthn> That's what "my" would do :)

[20:24] <hoelzro> me too =/

[20:25] <masak> nope.

[20:25] <moritz> in p5, 'local $x = $x' the $x on the RHS is the old $x, right?

[20:25] <masak> r: my $a = 1; { my $a = $a + 1; say $a; }; say $a

[20:25] <hoelzro> temp is like local, isn't it?

[20:25] <p6eval> rakudo 843534: OUTPUT«use of uninitialized variable $a of type Any in numeric context  in block  at /tmp/sOzU03jliG:1␤␤1␤1␤»

[20:25] <moritz> and in p6 it's the new $x, right?

[20:25] <masak> r: my $a = 1; { my $a = $OUTER::a + 1; say $a; }; say $a

[20:25] <p6eval> rakudo 843534: OUTPUT«2␤1␤»

[20:25] <masak> right.

[20:25] <moritz> hoelzro: temp is like local, but I think the time it takes place is different

[20:25] <jnthn> temp takes effect where it's written.

[20:26] <moritz> right

[20:26] <jnthn> It doesn't declare a new variable.

[20:26] <ingy> masak: is there a p6 implementation that supports pcre style regexes yet?

[20:26] <jnthn> It just makes sure that we restore the original value.

[20:26] <hoelzro> ok, hang on

[20:26] <jnthn> (at LEAVE time)

[20:26] <hoelzro> temp $x; is like local $x = $x;

[20:26] <hoelzro> right?

[20:27] <TimToady> yes

[20:27] <TimToady> yet another default we changed

[20:27] <masak> ingy: no, I don't think so.

[20:27] <masak> pmichaud would know, though.

[20:28] <masak> didn't PGE have one?

[20:28] <mhasch> can you temp a lexical variable?

[20:28] <TimToady> didn't pugs have one?

[20:28] <TimToady> mhasch: yes

[20:28] <hoelzro> so temp $x = $x +1; saves the value of $x and increments it in the "new" version, right?

[20:28] <hoelzro> so before: 0 after: 1?

[20:28] <TimToady> you can just say temp $x += 1

[20:29] <masak> TimToady: Pugs had some kind of bridge to Perl 5 there, methinks.

[20:29] <TimToady> that won't work with local

[20:29] <hoelzro> ok, that's what I thought.

[20:29] <hoelzro> so...doesn't my test make sense?

[20:32] <moritz> hoelzro: I think it does, sorry for all the noise

[20:32] <hoelzro> ok, cool =)

[20:33] <hoelzro> should I just push it up to roast?

[20:33] <moritz> yes

[20:33] <hoelzro> ok =

[20:33] <dalek> roast: e0f4d0f | (Rob Hoelz)++ | S04-blocks-and-statements/temp.t:

[20:33] <dalek> roast: Add test for temp in recursive calls

[20:33] <dalek> roast: review: https://github.com/perl6/roast/commit/e0f4d0fa6d

[20:36] *** pmurias joined
[20:36] <pmurias> hi

[20:36] <pmurias> is it normal for nqp code to segfault when it's unable to match a multi?

[20:38] <moritz> I hope not :-)

[20:38] <moritz> nqp: multi f(int $x) { say('Int') }; f('str')

[20:38] <p6eval> nqp: OUTPUT«Sorry, no proto sub in scope, and auto-generation of protos is not yet implemented. at line 2, near "; f('str')"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8553) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:38] <moritz> nqp: proto f(|$) {*}; multi f(int $x) { say('Int') }; f('str')

[20:38] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 2, near "(|$) {*}; "␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8553) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:38] <moritz> nqp: proto f(|$) {*}; multi f(int $x) { say('Int') }; f('str')

[20:38] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 2, near "(|$) {*}; "␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8553) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:38] <moritz> nqp: proto f(*@) {*}; multi f(int $x) { say('Int') }; f('str')

[20:38] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 2, near "(*@) {*}; "␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8553) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:38] <masak> pmurias! \o/

[20:39] <moritz> nqp: class A { }; proto f(*@) {*}; multi f(A $x) { say('A') }; f('str')

[20:39] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 2, near "(*@) {*}; "␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8553) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:39] <moritz> nqp: class A { }; proto f(*@args) {*}; multi f(A $x) { say('A') }; f('str')

[20:39] <p6eval> nqp: OUTPUT«(signal SEGV)»

[20:39] <masak> o.O

[20:39] * masak submits nqpbug

[20:39] <moritz> pmurias: I'm sure that's not intended behavior :-)

[20:40] <masak> https://github.com/perl6/nqp/issues/49

[20:41] <moritz> pmurias++

[20:41] <moritz> masak++

[20:41] <jnthn> Maybe that you're passing it something that ain't a 6model object.

[20:41] <moritz> nqp: class A { }; class B { }; proto f(*@args) {*}; multi f(A $x) { say('A') }; f(B);

[20:41] <p6eval> nqp: OUTPUT«(signal SEGV)»

[20:42] <moritz> jnthn: I think B is a 6model object too

[20:42] <jnthn> ah

[20:42] <jnthn> Then I've no idea what's going on.

[20:42] <jnthn> Investigation welcome.

[20:43] <pmurias> jnthn: QAST::Block

[20:43] <jnthn> That's one.

[20:44] <jnthn> Well, all of QAST::Compiler hangs off multi-dispatch on QAST nodes, so clearly it can work, if you align the stars correctly. ;-)

[20:45] <pmurias> jnthn: I copied the catch all unknown error reporting thing 

[20:46] <jnthn> pmurias: I'm...not entirely sure which thing you're meaning?

[20:48] <moritz> r: macro funny_nil { quasi { {;}() } }; say funny_nil() === Nil

[20:48] <p6eval> rakudo 843534: OUTPUT«True␤»

[20:48] <moritz> masak: that test passes in t/spec/S06-macros/macros-d1.t since the toqast merge

[20:48] *** zby_home_ left
[20:48] <moritz> (erm, is still skipped, can be unfudged)

[20:49] <masak> ooh

[20:49] <masak> moritz++

[20:49] <moritz> autounfudge it an endless source of karma, it seems :-)

[20:50] <moritz> I should really get a patent on it!

[20:50] <pmurias> jnthn: multi method as_post($unknown) {...}

[20:50] <jnthn> pmurias: Ah, OK... Did that help?

[20:50] <moritz> I mean, on a machine doing an autounfudge :-)

[20:51] <masak> that might even work.

[20:51] <pmurias> jnthn: it replaces a segfault with an error message

[20:53] <pmurias> if I add a new file to rakudo do I have to register it in the build system?

[20:53] <moritz> pmurias: yes

[20:54] <moritz> pmurias: you need to add it to tools/build/Makefile.in

[20:54] <dalek> specs: 5dfd996 | larry++ | S04-control.pod:

[20:54] <dalek> specs: resumable failures for coercions

[20:54] <dalek> specs: 

[20:54] <dalek> specs: fixes #17

[20:54] <dalek> specs: review: https://github.com/perl6/specs/commit/5dfd99666b

[20:57] <dalek> roast: 8a9dbc0 | moritz++ | S (4 files):

[20:57] <dalek> roast: various rakudo unfudges

[20:57] <dalek> roast: review: https://github.com/perl6/roast/commit/8a9dbc0eb3

[20:59] <pmurias> is there vim syntax highlighting for nqp?

[21:00] <pmurias> or should I just use the regular p6 one

[21:00] <jnthn> Even Perl 5 highlighters make a decent job of NQP, apart from regexes, where things mess up...

[21:00] <jnthn> Well, grammars especially.

[21:00] <moritz> the p6 one is quite OK for nqp

[21:01] <jnthn> Ah, I missed the "I ahve a p6 one to hand" bit of that.

[21:02] <pmurias> jnthn: I only thought about the p6 one after asking the question ;)

[21:03] *** Coleoid left
[21:04] <pmurias> is QAST documented somewhere?

[21:06] <dalek> roast: 45454e3 | moritz++ | S04-blocks-and-statements/temp.t:

[21:06] <dalek> roast: clean up temp + recursion tests

[21:06] <dalek> roast: 

[21:06] <dalek> roast: * remove redundant tests

[21:06] <dalek> roast: * add test labels

[21:06] <dalek> roast: * fudge only the failing test for rakudo

[21:06] <dalek> roast: review: https://github.com/perl6/roast/commit/45454e3a4a

[21:08] <masak> lol, I blogged! \o/ http://strangelyconsistent.org/blog/july-28-2012-moving-around-iii-movement-synonyms

[21:09] <masak> pmurias: no, but the source code is in nqp, and very approachable.

[21:09] <masak> as in, both "in the nqp repo" and "written in nqp".

[21:10] *** bruges_ left
[21:10] <jnthn> It really wants some decent docs, but I didn't get a round tuit yet.

[21:10] <jnthn> Now that we know that it actually works well enough to build Rakudo though... :)

[21:11] <dalek> specs: c939721 | larry++ | S (3 files):

[21:11] <dalek> specs: clean up some ucfirst fossils

[21:11] <dalek> specs: 

[21:11] <dalek> specs: fixes #15

[21:11] <dalek> specs: review: https://github.com/perl6/specs/commit/c939721201

[21:11] *** snearch left
[21:11] *** bruges joined
[21:12] <hoelzro> hey guys, I wrote up a test illustrating a strange issue I saw when working on my chat bot: https://gist.github.com/3194797

[21:12] <hoelzro> it currently doesn't pass; is this a bug, or am I being stupid?

[21:13] <masak> hoelzro: https://rt.perl.org/rt3/Ticket/Display.html?id=113958

[21:13] <hoelzro> ah, thanks

[21:13] * masak bows

[21:13] <masak> doesn't solve your problem, of course :/

[21:13] <masak> but now you know it's not just you.

[21:13] <hoelzro> oh, haha

[21:13] <hoelzro> I forgot about that =/

[21:14] <masak> hah, it was you last time too :P

[21:14] <hoelzro> I know!

[21:14] <masak> this is why we need new people: they find new bugs for us

[21:14] <masak> again and again :P

[21:14] <hoelzro> I spent too much time getting a working Rakudo =P

[21:14] <hoelzro> well, that's part of why I decided to write my bot in Perl6

[21:15] <hoelzro> can anyone suggest a workaround?

[21:15] <masak> hoelzro: do you know about https://github.com/TiMBuS/Net--IRC/ , by the way?

[21:16] <hoelzro> masak: I did not!

[21:16] <hoelzro> my chat bot is for XMPP, though =)

[21:16] <masak> ah.

[21:16] <masak> still, might be good inspiration.

[21:16] <hoelzro> so I just need to write an XML parser

[21:16] <hoelzro> oh, good point!

[21:16] <masak> oh noes not another XML parser... :P

[21:17] <hoelzro> is there one for Perl6?

[21:17] <masak> hoelzro: why in the world would you want to parse XML in Perl 6, aside for the pure exercise value of writing a moderately big grammar?

[21:17] <masak> "write an XML parser" seems to be a phase that about 15% of the neophytes go through...

[21:17] <masak> I haven't seen a complete one, no.

[21:17] <hoelzro> masak: oh, I don't care if it's written in Perl6 or not; I would just need an XML parser for an XMPP client

[21:17] <masak> oh, good.

[21:17] <hoelzro> right now I'm using a very dodgy hack

[21:18] <hoelzro> I'd rather not waste my time writing an XML parser =)

[21:18] <hoelzro> I have cooler stuff to do!

[21:19] <masak> indeed.

[21:19] <masak> (and writing an XML parser may look trivial, but... it isn't.)

[21:20] <timotimo> huh? i'll just throw a regex at it and voila!

[21:21] <arnsholt> hoelzro: If you feel up for the challenge, you could try wrapping libxml with Zavolaj

[21:21] <arnsholt> Iæm not quite sure if quite all the pieces required are there, but most of them should be there

[21:21] <hoelzro> after I get my bot working, I might tackle it =)

[21:21] <arnsholt> If you find out what's missing, I can probably implement them =)

[21:21] <hoelzro> it's a pretty important library to have!

[21:22] <masak> aye.

[21:23] * masak would love to have it

[21:23] <arnsholt> Quite. But now, sleep

[21:23] <arnsholt> zzzzz &

[21:23] *** birdwindupbird left
[21:23] <masak> ...and to have nice repr thingies for access from Perl 6.

[21:23] <masak> arnsholt: 'night. dream of people wrapping cool things with Zavolaj.

[21:28] <sorear> good * #perl6

[21:28] <pmurias> sorear: hi

[21:28] <pmurias> is there a way to dump the QAST for a given bit of code?

[21:29] <pmurias> --target=past gives me strange errors

[21:29] <masak> sorear! \o/

[21:32] <pmichaud> jnthn: ping

[21:32] <jnthn> pmichaud: pong

[21:33] <pmichaud> I have a new .msi created; could you test it and see if it installs to your c: drive this time?

[21:33] <jnthn> sure; url?

[21:33] <pmichaud> just a sec, uploading

[21:33] <jnthn> .oO( mmm...url...sounds like öl... )

[21:34] <pmichaud> http://pmichaud.com/sandbox/rakudo-star-2012.07-3.msi

[21:35] <jnthn> pmichaud: Trying.

[21:39] <jnthn> pmichaud: yes, installed on C: and works \o/

[21:39] <pmichaud> okay, I'll replace the one on github with this one then.

[21:40] <jnthn> pmichaud++

[21:41] <pmichaud> thanks for the quick check

[21:42] <jnthn> np

[21:42] <jnthn> Just waiting for builds anyway.

[21:42] * jnthn is debugging building Rakudo using PIRT

[21:44] <dalek> star: d961bd7 | pmichaud++ | skel/tools/build/star-product.wxs:

[21:44] <dalek> star: Update Wix file to force installation to C:\ .

[21:44] <dalek> star: review: https://github.com/rakudo/star/commit/d961bd7992

[21:45] <pmichaud> okay, I'm going to go play with robots for a while.  :-)   bbl

[21:49] <jnthn> Have fun!

[21:56] *** larks left
[21:58] *** larks joined
[21:59] *** seldon left
[21:59] <hoelzro> is there a way to compile a regular expression from a string without using eval?

[21:59] <hoelzro> ex. Regex.new("^ $foo")

[22:01] <japhb> What base class do Perl6::Metamodel::* classes have?  What metaclass do they have? Is there a way to introspect them?

[22:02] <jnthn>  /^ <$foo>/

[22:03] <hoelzro> jnthn: thanks!

[22:03] *** kaxing left
[22:03] <jnthn> japhb: They're weird; initial NQPMu but then post-bootstrap they are twiddled to have Any.

[22:04] *** kaxing joined
[22:04] <japhb> jnthn, Ah, interesting.

[22:05] *** larks left
[22:05] <japhb> Are they all supposed to have metaclass Perl6::MetaModel::ClassHOW, just like "normal" classes?

[22:07] *** larks joined
[22:07] <jnthn> No

[22:07] <japhb> r: say Perl6::Metamodel::ClassHOW

[22:07] <p6eval> rakudo 843534: OUTPUT«Could not find symbol '&ClassHOW'␤  in method <anon> at src/gen/CORE.setting:9629␤  in <anon> at src/gen/Metamodel.pm:2304␤  in any find_method_fallback at src/gen/Metamodel.pm:2302␤  in any find_method at src/gen/Metamodel.pm:843␤  in <anon> at src/gen/BOOTSTRAP.p…

[22:07] <jnthn> r: say Metamodel::ClassHOW

[22:07] <p6eval> rakudo 843534: OUTPUT«Perl6::Metamodel::ClassHOW()␤»

[22:07] <jnthn> Hmm. It lies :)

[22:07] <japhb> Oh interesting

[22:08] <jnthn> Anyway, no, it's own .HOW is actually an instance of NQPClassHOW.

[22:08] <jnthn> *its

[22:08] <japhb> Is that true of all Metamodel classes, or just ClassHOW?

[22:08] <jnthn> All.

[22:09] <japhb> Ah, OK.

[22:09] <jnthn> It's factored primarily with roles.

[22:09] <jnthn> The only bit of inheritnace in there is that GrammarHOW inherits from ClassHOW.

[22:10] <japhb> Yeah, I'm getting back to work on my "visualizing the type graph" project, and discovered that the handling of the Metamodel classes/roles appears ... very fishy.

[22:11] *** larks left
[22:11] <japhb> jnthn, Hmmm, I have MethodDispatcher, MultiDispatcher, and WrapDispatcher all inheriting from BaseDispatcher.  Is that wrong?

[22:12] *** lue joined
[22:12] <lue> hello world o/

[22:12] <masak> lue! \o/

[22:12] <masak> lue: you have your inventory now.

[22:12] <jnthn> japhb: Ah...that sounds sane.

[22:13] <masak> lue: and shortcuts for directions, though not yet for verbs. that comes tomorrow.

[22:13] *** larks joined
[22:13] * lue reads blog posts

[22:16] <lue> "So you panic for three moves and then you die." :)

[22:16] <masak> yup.

[22:16] <japhb> jnthn, why do the Metamodel classes have names that start with Perl6:: in their definition, but appear in the namespaces without that prefix?

[22:16] <jnthn> japhb: They're defined with the prefix in NQP, but exported differently.

[22:17] <jnthn> japhb: But really I think .WHAT.gist ain't meant to include the fully qualified name.

[22:17] <masak> r: module A { class B::C {}; say B::C.new.^name };

[22:17] <p6eval> rakudo 843534: OUTPUT«B::C␤»

[22:17] <masak> r: module A { class B::C {} }; say A::B::C.new.^name

[22:17] <p6eval> rakudo 843534: OUTPUT«B::C␤»

[22:17] <masak> +1

[22:18] <hoelzro> is there a way to retrieve a role from a name?

[22:18] <hoelzro> ex. I have a role 'Hexe::Plugin::Echo'

[22:18] <masak> r: role R {}; class C does R {}; say C.new ~~ R

[22:18] <p6eval> rakudo 843534: OUTPUT«True␤»

[22:18] <hoelzro> and I want to dynamically apply the role of that name to an object

[22:18] <hoelzro> ex. $object does %roles($role);

[22:18] <japhb> jnthn, sure, I get the mechanism ... I meant "why" as in "what's the reasoning for that difference?" Is it because Metamodel:: within NQP would refer to NQP's metamodel, so this is how you create something in NQP's world that needs to appear in Perl6's world?

[22:19] <masak> r: role R {}; class C {}; my $c = C.new but R; say $c ~~ R

[22:19] <p6eval> rakudo 843534: OUTPUT«True␤»

[22:19] <japhb> s/appear/appear under the same name/

[22:19] *** lue left
[22:20] <hoelzro> masak: right, but I only have the string 'R'

[22:20] <tadzik> ::('R') may work

[22:21] <jnthn> japhb: I'm not sure there's a reason beyond me defining it one way in the first place, and then feeling it was a bit unweildy.

[22:21] <japhb> Ah, OK

[22:21] *** lue joined
[22:22] <dalek> nqp/pirt: e27a5eb | jnthn++ | src/ (2 files):

[22:22] <dalek> nqp/pirt: We still need to keep the Regex nodes emitting POST for the sake of NQP (which doesn't use the rest of QAST yet); this should make that possible.

[22:22] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/e27a5ebfcb

[22:22] <dalek> nqp/pirt: 69bc286 | jnthn++ | src/QAST/PIRT.nqp:

[22:22] <dalek> nqp/pirt: Labels need to automatically be uniquified.

[22:22] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/69bc286c57

[22:22] <dalek> nqp/pirt: 8c14cea | jnthn++ | src/Q (2 files):

[22:22] <dalek> nqp/pirt: Various fixes to regex compilation; this also means we'll be able to eliminate the PAST::Node usages that remain in Rakudo's Actions.

[22:22] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/8c14cea37c

[22:22] <dalek> nqp/pirt: 1f5406a | jnthn++ | src/QAST/Compiler.nqp:

[22:22] <dalek> nqp/pirt: One more regex tweak to get regex compilation under PIRT OK.

[22:22] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/1f5406aacd

[22:22] <dalek> nqp/pirt: dc95f4a | jnthn++ | src/QAST/PIRT.nqp:

[22:22] <dalek> nqp/pirt: For hysterial raisons, PIRT nodes should stringify to their results (for now).

[22:22] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/dc95f4a9ca

[22:22] <dalek> nqp/pirt: 17a5ef3 | jnthn++ | src/QAST/Compiler.nqp:

[22:22] <dalek> nqp/pirt: Final fix needed to get PIRT able to build Rakudo.

[22:22] <dalek> nqp/pirt: review: https://github.com/perl6/nqp/commit/17a5ef3a09

[22:22] <masak> r: role R {}; class C {}; my $c = C.new but ::('R'); say $c ~~ R

[22:22] <p6eval> rakudo 843534: OUTPUT«True␤»

[22:22] <lue> .oO(stupid randomly panicking kernel...)

[22:22] <tadzik> jnthn: what's pirt?

[22:22] <masak> tadzik: PIR in tree representation.

[22:22] <tadzik> nice

[22:25] <dalek> rakudo/pirt: 99d850b | jnthn++ | src/Perl6/Actions.pm:

[22:25] <dalek> rakudo/pirt: Initial update to get Rakudo to build with nqp/pirt. Eliminates the final PAST::Node usages also. Some test failures; seems CORE.setting memory is a bit lower with this, which was the aim.

[22:25] <dalek> rakudo/pirt: review: https://github.com/rakudo/rakudo/commit/99d850bc11

[22:25] <jnthn> tadzik: It's a replacement for POST that I hope reduces build memory a bit further when doing CORE.setting compilation.

[22:25] <hoelzro> tadzik: no dice =/

[22:26] <jnthn> tadzik: Today it's gone from not existing to being able to replace POST for the Rakudo build.

[22:26] <jnthn> Well, modulo a relatively small number of new test failures.

[22:26] <tadzik> awesome

[22:27] * tadzik builds

[22:29] <dalek> rakudo/pirt: 2b57323 | jnthn++ | src/Perl6/Grammar.pm:

[22:29] <dalek> rakudo/pirt: Fix user defined ops, which probably deals with many of the test regressions.

[22:29] <dalek> rakudo/pirt: review: https://github.com/rakudo/rakudo/commit/2b57323921

[22:29] <jnthn> tadzik: Grab ^^ first.

[22:30] <jnthn> It probably deals with most of the new failures.

[22:32] * lue considers attempting pirt

[22:32] <jnthn> lue: It's got some rough edges and I won't get to them today.

[22:34] <jnthn> Now too many though, looking at this test run.

[22:35] <jnthn> Yeah, few enough test files that you can count 'em on your fingers. Not bad to say I replaced an entire compilation stage in a day's hacking. :)

[22:37] <japhb> jnthn++

[22:37] <dalek> doc: fe96631 | (Geoffrey Broadwell)++ | type-graph.txt:

[22:37] <dalek> doc: Fix missing superclass: Perl6::Metamodel::GrammarHOW is Perl6::Metamodel::ClassHOW

[22:37] <dalek> doc: review: https://github.com/perl6/doc/commit/fe9663121d

[22:37] <dalek> doc: e0db752 | (Geoffrey Broadwell)++ | lib/Perl6/TypeGraph.pm:

[22:37] <dalek> doc: Defaulting superclass to Any should happen after roles get a chance to supply superclasses

[22:37] <dalek> doc: review: https://github.com/perl6/doc/commit/e0db752b2a

[22:38] <jnthn> Seems my first cut of the code is no slower (despite being in NQP - a HLL - rather than PIR) and sees us use less memory.

[22:39] <japhb> That is rather awesome.

[22:39] *** MayDaniel left
[22:43] <diakopter> 2

[22:45] <dalek> specs: 76c977a | larry++ | S05-regex.pod:

[22:45] <dalek> specs: :p is incompatible with scanners

[22:45] <dalek> specs: 

[22:45] <dalek> specs: :p may not be used with :ex, :ov, :g, :nth, or :x modifiers.

[22:45] <dalek> specs: fixes #16

[22:45] <dalek> specs: review: https://github.com/perl6/specs/commit/76c977a784

[22:49] <jnthn> OK, time for some rest.

[22:49] <jnthn> 'night o/

[22:53] <tadzik> 'night!

[22:56] *** hoelzro is now known as hoelzro|away

[23:08] *** sudokode left
[23:10] *** spider-mario left
[23:10] *** sudokode joined
[23:23] <dalek> specs: 003891a | larry++ | S0 (3 files):

[23:23] <dalek> specs: Explication of lazy warnings

[23:23] <dalek> specs: 

[23:23] <dalek> specs: Lazy warning are to be used for +, ~ and ? conversions, as well as

[23:23] <dalek> specs: for the ??? stub.

[23:23] <dalek> specs: review: https://github.com/perl6/specs/commit/003891a8e4

[23:23] <dalek> specs: 838a4b9 | larry++ | S04-control.pod:

[23:23] <dalek> specs: relax prev to numeric/string conversion

[23:23] <dalek> specs: 

[23:23] <dalek> specs: This is all Stringy/Numeric conversion, not just the ~/+ prefix operators.

[23:23] <dalek> specs: (And Bool conversion always succeeds, so ? need not apply).

[23:23] <dalek> specs: review: https://github.com/perl6/specs/commit/838a4b983e

[23:32] *** larks left
[23:32] *** larks joined
[23:42] *** takadonet left
[23:47] *** pmurias left
