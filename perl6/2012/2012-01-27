[00:14] <Radvendii> nom: sub a {say "shouldnt be here"}; 0 && a();

[00:14] <p6eval> nom 052cc6:  ( no output )

[00:14] <Radvendii> nom: sub a {say "shouldnt be here"}; 1 && a();

[00:14] <p6eval> nom 052cc6: OUTPUT«shouldnt be here␤»

[00:15] <Radvendii> nom: given 42 {when Int { 0 && proceed}; when 42 {say "shouldn't be here"}}

[00:15] <p6eval> nom 052cc6:  ( no output )

[00:16] <Radvendii> nom: given 42 {when Int {"hello" but (0 && proceed)}; when 42 {say "shouldn't be here"}}

[00:16] <p6eval> nom 052cc6:  ( no output )

[00:22] *** PacoAir left
[00:36] *** pmurias left
[00:45] *** `10 left
[00:45] *** `10 joined
[00:54] *** molaf__ joined
[00:58] *** molaf_ left
[01:17] <sorear> good * #perl6

[01:24] <[Coke]> I can now build partcl on nqp. but running it dies with: A method named 'backtrack' already exists in class 'PAST;Regex'. It may have been supplied by a role.

[01:30] <[Coke]> https://github.com/partcl/partcl-nqp/tree/nqp if anyone wants to hack on it.

[01:32] <sorear> Radvendii: I use 'rlwrap mono[-sgen] run/Niecza.exe' personally

[01:32] <sorear> Radvendii: niecza is carping about [||], which IMO doesn't make much sense

[01:33] <Radvendii> sorear: to which comment are you responding?

[01:34] <sorear> 14:30 < Radvendii> what does niecza mean by "This macro cannot be used as a  function"

[01:34] <sorear> 13:45 < Radvendii> Is there a way to get command history on niecza? (Like, i  know CPAN offers it only after you download some module or  something...)

[01:34] <Radvendii> ah

[01:34] <Radvendii> thank you

[01:34] <Radvendii> sorry, I couldn't remember what i had said

[01:42] *** tokuhirom left
[01:45] *** datums_nb joined
[01:48] *** datums_nb left
[02:10] *** lutok left
[02:25] <Radvendii> nom: note: 5.perl;

[02:25] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Confused at line 1, near "note: 5.pe"␤»

[02:26] <benabik> nom doesn't know the "fung: args" style yet

[02:27] <benabik> func!

[02:27] <Radvendii> nom: my $a=5; note :$a.perl;

[02:27] <p6eval> nom 052cc6: OUTPUT«"a" => 5␤»

[02:27] <Radvendii> that's not even what i was trying to do

[02:27] <Radvendii> nor did i know it existed

[02:27] <Radvendii> but that's cool

[02:31] <Radvendii> nom: 		<w b>.grep: {say $_};

[02:31] <p6eval> nom 052cc6:  ( no output )

[02:31] <Radvendii> nom: <w b>.grep: {say $_};

[02:31] <p6eval> nom 052cc6:  ( no output )

[02:31] <Radvendii> alright, why the no output?

[02:32] <Radvendii> nom: say <w b>.grep: {$_};

[02:32] <p6eval> nom 052cc6: OUTPUT«w b␤»

[02:32] *** wolfman2000 joined
[02:33] <Radvendii> but why no output before?

[02:37] <sorear> Radvendii: 'note: 5' is a noop statement that happens to have a label

[02:37] <sorear> you could use goto "note" elsewhere to go to the 5

[02:38] <Radvendii> oh right

[02:38] <Radvendii> but then why "func: args"?

[02:38] <Radvendii> it's not a function...

[02:38] <benabik> nom: <a b>.grep({say $_})

[02:39] <p6eval> nom 052cc6:  ( no output )

[02:39] <Radvendii> it's not a function...

[02:39] <Radvendii> damn it

[02:39] <benabik> Huh.  That does do output on my computer.

[02:39] <Radvendii> i keep tabbing into iTerm and then hitting "up-enter" to recompile my program, and accidentally being on IRC :P

[02:41] <Radvendii> benabik: not on mine. what version of rakudo are you using?

[02:41] <benabik> 2011.12-145-ged943e6

[02:42] <Radvendii> ah. i'm using 2012.01

[02:42] <Radvendii> it must have broken

[02:45] *** Chillance left
[02:45] <Radvendii> gah!

[02:45] <Radvendii> i keep forgetting to put my variables in //s when I regex them

[02:49] <sorear> Radvendii: you shouldn't put anything with side effects in the argument to grep

[02:52] <Radvendii> huh?

[02:53] <Radvendii> i keep doing <w b>.grep: {$l !~~ $^x} which only matches if $l doesn't "eq" $^x....

[02:53] <Radvendii> wait

[02:53] <Radvendii> i do have it in //s

[02:54] <Radvendii> e.g. /$^x/

[02:54] <Radvendii> oh

[02:54] <Radvendii> you were talking about the other thign

[02:54] <Radvendii> why shouldn't you put side effects in grep?

[02:54] <Radvendii> so long as it returns False or True...

[02:57] <Radvendii> nom: say ?(<w b>.grep: {'wK' !~~ /$^x/}); say ?(<w b>.grep: -> $x {'wK' !~~ /$x/} #is this a bug?

[02:57] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Unsupported use of ?: for the conditional operator;  in Perl 6 please use ??!!␤at /tmp/KMJ4g674Y5:1␤»

[02:57] <Radvendii> nom: say ?(<w b>.grep: {'wK' !~~ /$^x/}); say ?(<w b>.grep: -> $x {'wK' !~~ /$x/}) #is this a bug?

[02:57] <p6eval> nom 052cc6: OUTPUT«Bool::True␤Bool::True␤»

[02:57] <Radvendii> wait

[02:57] <Radvendii> what?

[02:58] <Radvendii> that's not what i'm getting...

[02:58] <Radvendii> oops

[02:58] <Radvendii> i didn't want bools

[02:58] <Radvendii> nom: say (<w b>.grep: {'wK' !~~ /$^x/}); say (<w b>.grep: -> $x {'wK' !~~ /$x/}) #is this a bug?

[02:58] <p6eval> nom 052cc6: OUTPUT«w b␤b␤»

[02:58] <Radvendii> there we go

[02:58] <Radvendii> why are they different?

[03:20] *** whiteknight left
[03:22] <gfldex> looks like a bug to me

[03:22] *** orafu left
[03:23] *** orafu joined
[03:23] <sorear> Radvendii: because grep is lazy and you can't rely on the sub being called in a specific order or at all

[03:23] <gfldex> but the bug might be in a different spot then you think it is

[03:23] <sorear> I die a little every time you write <a b>.grep({ say $_ }), Radvendii

[03:24] <Radvendii> :P o-oh that's right. lazy. that makes sense. sorry about the death and all.

[03:25] <gfldex> Radvendii: you may want to read http://perlcabal.org/syn/S05.html#Variable_%28non-%29interpolation

[03:26] <benabik> sorear++ # don't die

[03:28] <Radvendii> OH!

[03:28] <Radvendii> so what i want is /<$var>/

[03:28] <Radvendii> :D

[03:29] <gfldex> maybe

[03:29] <Radvendii> nom: my $var = 'w'; say 'wQ' ~~ /<$var>/

[03:29] <p6eval> nom 052cc6: OUTPUT«=> <w>␤␤»

[03:30] <Radvendii> nom: my $var = 'w'; say 'wQ' ~~ /$var/

[03:30] <p6eval> nom 052cc6: OUTPUT«=> <w>␤␤»

[03:30] <Radvendii> oh

[03:30] <Radvendii> fooey

[03:30] <Radvendii> so what's the difference?

[03:30] <gfldex> at times it helps to bang you head against the wall until you forget anything you know about Perl 5 before you write "use v6;"

[03:30] *** shinobicl___ joined
[03:31] <Radvendii> :P

[03:31] <gfldex> the difference is that <$var> forces the match engine to look for a rule with the name that is stored in $var

[03:31] <gfldex> unless you stick a regex into $var, then it should use that regex in place

[03:32] <gfldex> if you stick anything that is not Str|Match into $var, well good luck to you

[03:34] <Radvendii> oh. i figured out what my problem this time with them was, it didn't have to do with <>s or such. (and that makes sense, from what you're telling me)

[03:34] <Radvendii> but i find it odd that .grep: {'a' ~~ /$^x/} should have different results from .grep: -> {'a' ~~ /$x/}

[03:35] <Radvendii> unless you tell me that there's a reason for that

[03:37] <gfldex> $^x will be defined, $x will not be defined

[03:37] <gfldex> whereby defined is not in the perl 5 sense defined

[03:38] <gfldex> you imply that grep is calling the function with a parameter

[03:38] <gfldex> i would not bet on that

[03:38] <gfldex> if it would, you would get the same result for both cases

[03:38] <sorear> Radvendii: you get different results because you forgot to add $x to the signature in the second case

[03:39] <gfldex> he did not

[03:39] *** Psyche^ joined
[03:39] <sorear> {'a' ~~ /$^x/} is equivalent to -> $x {'a' ~~ /$x/}

[03:39] <Radvendii> oh

[03:39] <Radvendii> i did forget

[03:39] <Radvendii> but that's what i menat

[03:39] <Radvendii> meant*

[03:39] <gfldex> sorear: scroll up please

[03:39] <Radvendii> when i do supply $x as an argument

[03:40] <Radvendii> the later version works correctly

[03:40] <Radvendii> the former does not

[03:40] <sorear> possibly Rakudo is getting confused because // is a block itself, maybe the parameter is getting attached to the Regex block rather than the Block block

[03:41] <sorear> perl6: say (/$^x/).signature

[03:41] <p6eval> niecza v13-357-g9374d97: OUTPUT«===SORRY!===␤␤Placeholder variable $^x may not be used outside of a block at /tmp/1tq2y3ZtNL line 1:␤------> say (/⏏$^x/).signature␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting lin…

[03:41] <p6eval> ..rakudo 052cc6: OUTPUT«:(Mu , Mu %_!)␤»

[03:41] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Regex: "&signature"␤    at /tmp/EgzjfgjtTo line 1, column 5 - line 2, column 1␤»

[03:41] <Radvendii> apparently not

[03:41] <sorear> perl6: my $foo = { 'a' ~~ /$^x/ }; say $foo('cat'); say $foo('dog');

[03:41] <p6eval> rakudo 052cc6: OUTPUT«#<failed match>␤#<failed match>␤»

[03:41] <p6eval> ..pugs b927740: OUTPUT«*** No compatible multi variant found: "$foo"␤    at /tmp/lPd92MbBKn line 1, column 33-44␤»

[03:41] <p6eval> ..niecza v13-357-g9374d97: OUTPUT«Match()␤Match()␤»

[03:42] *** Patterner left
[03:42] *** Psyche^ is now known as Patterner

[03:42] <sorear> perl6: my $foo = -> $x { 'a' ~~ /$x/ }; say $foo('cat'); say $foo('dog');

[03:42] <p6eval> rakudo 052cc6: OUTPUT«#<failed match>␤#<failed match>␤»

[03:42] <p6eval> ..niecza v13-357-g9374d97: OUTPUT«Match()␤Match()␤»

[03:42] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[03:42] <Radvendii> 'a' !~~ /cat/; 'cat' ~~ /a/

[03:42] <sorear> er, wait, I got that backward

[03:42] <Radvendii> yup

[03:43] <sorear> perl6: my $foo = -> $x { 'cat' ~~ /$x/ }; say $foo('a'); say $foo('o');

[03:43] <p6eval> niecza v13-357-g9374d97: OUTPUT«#<match from(1) to(2) text(a) pos([].list) named({}.hash)>␤Match()␤»

[03:43] <p6eval> ..rakudo 052cc6: OUTPUT«=> <a>␤␤#<failed match>␤»

[03:43] <p6eval> ..pugs b927740: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** '<HAND…

[03:43] <sorear> perl6: my $foo = { 'cat' ~~ /$^x/ }; say $foo('a'); say $foo('o');

[03:43] <p6eval> rakudo 052cc6: OUTPUT«#<failed match>␤#<failed match>␤»

[03:43] <p6eval> ..niecza v13-357-g9374d97: OUTPUT«#<match from(1) to(2) text(a) pos([].list) named({}.hash)>␤Match()␤»

[03:43] <p6eval> ..pugs b927740: OUTPUT«*** No compatible multi variant found: "$foo"␤    at /tmp/VEWmgo0MET line 1, column 35-44␤»

[03:43] <Radvendii> that's what i've been experiencing

[03:43] <sorear> that's very strange

[03:43] <sorear> it's not a problem with you

[03:44] <sorear> I might even say bug

[03:44] <Radvendii> thanks for the assurence, i tend to assume everything is

[03:44] <sorear> perl6: my $foo = { 'cat' ~~ /$^x/ }; say $foo.signature

[03:44] <Radvendii> (my fault, that is)

[03:44] <p6eval> niecza v13-357-g9374d97: OUTPUT«:(Any $x)␤»

[03:44] <p6eval> ..pugs b927740: OUTPUT«:()␤»

[03:44] <p6eval> ..rakudo 052cc6: OUTPUT«:(Mu \$_)␤»

[03:44] <Radvendii> regexes tend to screw up all sorts of variables

[03:44] <sorear> nom: my $foo = { /$^x/ }; say $foo.signature

[03:44] <p6eval> nom 052cc6: OUTPUT«:(Mu \$_)␤»

[03:44] <Radvendii> $_, *, etc.

[03:44] <sorear> nom: my $foo = { /$^x/ }; say $foo('cat').signature

[03:44] <p6eval> nom 052cc6: OUTPUT«:(Mu , Mu %_!)␤»

[03:44] <gfldex> nom: my $foo = { say $^x; 'a' ~~ /$^x { say $^x } /;}; $foo('a');

[03:44] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Placeholder variable $^x may not be used here because the surrounding block takes no signature␤at /tmp/BM2GEerwsE:1␤»

[03:45] <sorear> Radvendii: remember that a Regex is just a funny kind of Sub, and it has a scope of its own

[03:45] <Radvendii> sorear: oh. that's weird. not expected at least... well, i know now

[03:45] <gfldex> and a block inside a Regex is a funny kind of sub aswell

[03:46] <Radvendii> i knew that much

[03:46] <Radvendii> why didnt the above code work?

[03:46] <gfldex> mine?

[03:46] <Radvendii> yeah

[03:47] <gfldex> because the regex engine called the most inner block with no parameter

[03:47] <Radvendii> ah

[03:47] <gfldex> that's a runtime error

[03:47] <Radvendii> i see

[03:47] <sorear> $^x, to a first approximation, attaches to the innermost curlies

[03:47] <sorear> gfldex: No, it's a compile time error.  Notice the '===SORRY!==='

[03:47] <Radvendii> those variables are like extra $_s

[03:47] <gfldex> wow, perl 6 got quite clever already

[03:48] <sorear> blocks embedded in a regex are forbidden to have parameters

[03:48] <sorear> gfldex: STD has caught this case for at least a year

[03:48] <sorear> nom: /{$^x}/

[03:48] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Placeholder variable $^x may not be used here because the surrounding block takes no signature␤at /tmp/H_3SLpUQpj:1␤»

[03:48] <sorear> b: /{$^x}/

[03:48] <p6eval> b 1b7dd1:  ( no output )

[03:48] <Radvendii> :P

[03:48] <Radvendii> ah b: does anyone use that anymore?

[03:49] <sorear> looks like b doesn't do it

[03:49] *** plutoid joined
[03:49] <sorear> Radvendii: yes

[03:49] <Radvendii> sorear: for real? for what?

[03:49] <sorear> Radvendii: nom still has more rough edges than b does

[03:49] <Radvendii> oh

[03:49] <sorear> so, officially, we tell production users to stick with b for now

[03:49] <Radvendii> i see

[03:50] <sorear> where 'production' approximately means 'star'

[03:50] <sorear> iiuc there's a star release planned for next week

[03:50] <gfldex> there are quite a few things that nom does better thought

[03:50] <Radvendii> gfldex: such as?

[03:51] <gfldex> better error messages as a start

[03:51] <gfldex> it's a fairly long list

[03:51] <Radvendii> mhmm

[03:51] <Radvendii> okay

[03:54] <Radvendii> (that wasn't meant to be doubtful, just asenting)

[04:13] <benabik> Ah....

[04:14] <benabik> Figured out the grep issue, I think.

[04:14] <benabik> Grep returns something lazy, so if you never ask for the values, it never calls the sub.

[04:14] <benabik> nom: (<a b>.grep: { .say })[0]

[04:14] <p6eval> nom 052cc6: OUTPUT«a␤»

[04:15] <benabik> Radvendii: ^^

[04:16] <Radvendii> benabik: yup. we were discussing that earlier. essentially, the take away lesson is never put code you want to run in a grep statement

[04:16] <benabik> Oh.  I got distracted in the middle here, missed that convo.

[04:17] <benabik> I was building a new copy of nom trying to figure out what "broke".  :-D

[04:18] <sorear> o/ benabik

[04:18] <benabik> o/ sorear 

[04:19] <Radvendii> there is something that we believe "broke"

[04:19] <Radvendii> (without the quotes... :P)

[04:20] <Radvendii> nom: my $f = -> { 'cat' ~~ /$^x/ }; say $f('a').perl

[04:20] <p6eval> nom 052cc6: OUTPUT«Too many positional parameters passed; got 1 but expected 0␤  in block <anon> at /tmp/OFrkFnzPvI:1␤  in block <anon> at /tmp/OFrkFnzPvI:1␤  in <anon> at /tmp/OFrkFnzPvI:1␤»

[04:21] <Radvendii> sorear: i guess indeed the regex makes it's own scope

[04:21] <Radvendii> quite inconvenient

[04:21] <Radvendii> how come it worked for you though?

[04:22] <benabik> nom: (-> { $^x }).signature.say

[04:22] <Radvendii> nom: my $foo = { 'cat' ~~ /$^x/ }; say $foo('a'); say $foo('o');

[04:22] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Placeholder variable cannot override existing signature␤at /tmp/8RxRLehpi3:1␤»

[04:22] <p6eval> nom 052cc6: OUTPUT«#<failed match>␤#<failed match>␤»

[04:22] <Radvendii> that's what it was

[04:22] <Radvendii> no lambda

[04:22] <Radvendii> nom: my $foo = { 'cat' ~~ /$^x/ }; say $foo('a'); say $foo('o');

[04:22] <p6eval> nom 052cc6: OUTPUT«#<failed match>␤#<failed match>␤»

[04:22] <Radvendii> nom: 'cat' ~~ /'a'/

[04:22] <p6eval> nom 052cc6:  ( no output )

[04:22] <Radvendii> nom: say 'cat' ~~ /'a'/

[04:22] <p6eval> nom 052cc6: OUTPUT«=> <a>␤␤»

[04:23] <Radvendii> sorear: if regexs did create their own scope, it wouldn't accept the argument at all...

[04:23] <Radvendii> nom: my $foo = { /$^x/.perl.say }; say $foo('a'); say $foo('o');

[04:23] <p6eval> nom 052cc6: OUTPUT«regex _block1014(Mu , Mu %_!) { ... }␤Bool::True␤regex _block1014(Mu , Mu %_!) { ... }␤Bool::True␤»

[04:24] * Radvendii cocks an eyebrow

[04:24] <Radvendii> nom: my $foo = { /$^x/.say }; say $foo('a'); say $foo('o');

[04:24] <p6eval> nom 052cc6: OUTPUT«_block1014␤Bool::True␤_block1014␤Bool::True␤»

[04:24] <Radvendii> oh...

[04:24] <Radvendii> any way to get it to print out what it really is?

[04:25] <colomon> doubt it

[04:25] <colomon> reverse engineering code like that is something none of the p6s do yet, to my knowledge

[04:25] <gfldex> there is a debugger for //

[04:26] <Radvendii> gfldex: how do i get my hands on it? / what do i type?

[04:26] <gfldex> http://perl6advent.wordpress.com/2011/12/02/grammartracer-and-grammardebugger/

[04:27] <gfldex> http://planetsix.perl.org/ for more

[04:27] <Radvendii> wow. i've gotta clean up all of my tabs

[04:27] <Radvendii> (in safari)

[04:29] <Radvendii> i'm still having trouble installing panda, so do any of you ahve the grammar debugger already?

[04:40] <Radvendii> im going to go take a shower, ill bbl

[04:51] *** birdwindupbird joined
[04:59] *** drbean left
[05:00] *** drbean joined
[05:04] *** Radvendii left
[05:22] *** dukeleto left
[05:23] *** dukeleto joined
[05:23] *** dukeleto left
[05:24] *** dukeleto joined
[05:25] *** dukeleto left
[05:26] *** dukeleto joined
[05:26] *** dukeleto left
[05:26] *** dukeleto joined
[05:26] *** dukeleto left
[05:26] *** dukeleto joined
[05:48] *** replore_ joined
[05:51] *** plutoid left
[05:55] *** shinobicl___ left
[06:00] <sorear> niecza: say 42.fmt('%08x')

[06:00] <p6eval> niecza v13-357-g9374d97: OUTPUT«0000002a␤»

[06:00] <sorear> niecza: say 42.fmt('%08X')

[06:00] <p6eval> niecza v13-357-g9374d97: OUTPUT«0000002A␤»

[06:00] <sorear> niecza: say (-42).fmt('%08X')

[06:00] <p6eval> niecza v13-357-g9374d97: OUTPUT«FFFFFFD6␤»

[06:00] <sorear> nom: say (-42).fmt('%08X')

[06:00] <p6eval> nom 052cc6: OUTPUT«FFFFFFFFFFFFFFD6␤»

[06:06] <moritz> o/

[06:06] <sorear> o/ moritz 

[06:07] <snarkyboojum> stupid question - how does one get a decimal representation of a Rat, i.e. I don't want scientific notation, I want decimal notation :D

[06:07] <tadzik> .Numeric?

[06:07] <sorear> niecza: say (1/1024).Num

[06:07] <p6eval> niecza v13-357-g9374d97: OUTPUT«0.0009765625␤»

[06:08] <sorear> niecza: say (1/1048576).Num

[06:08] <snarkyboojum> how about something like 1/998001

[06:08] <p6eval> niecza v13-357-g9374d97: OUTPUT«9.5367431640625E-07␤»

[06:08] <sorear> niecza: say (1/1048576).fmt('%f')

[06:08] <p6eval> niecza v13-357-g9374d97: OUTPUT«??␤»

[06:08] <snarkyboojum> doesn't seem to work

[06:08] <sorear> niecza: say (1/1048576).fmt('%d')

[06:08] <p6eval> niecza v13-357-g9374d97: OUTPUT«0␤»

[06:08] <sorear> niecza: say (1/1048576).fmt('%g')

[06:08] <p6eval> niecza v13-357-g9374d97: OUTPUT«Unhandled exception: invalid format specifier␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (sprintf @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 640 (Cool.fmt @ 3) ␤  at /tmp/UepwgQ_yd1 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.…

[06:08] <sorear> very strange result for %f

[06:08] <sorear> nom: say (1/1048576).fmt('%f')

[06:08] <p6eval> nom 052cc6: OUTPUT«0.000001␤»

[06:08] <sorear> nom: say (1/1048576).fmt('%.12f')

[06:08] <p6eval> nom 052cc6: OUTPUT«0.000000953674␤»

[06:08] <sorear> nom: say (1/998001).fmt('%.12f')

[06:08] <p6eval> nom 052cc6: OUTPUT«0.000001002003␤»

[06:09] <sorear> nom: say sqrt 998001

[06:09] <p6eval> nom 052cc6: OUTPUT«999␤»

[06:09] <snarkyboojum> say (1/998001).fmt('%.100f')

[06:09] <snarkyboojum> eek

[06:09] *** kaleem joined
[06:09] <sorear> that's an interesting number

[06:10] <sorear> nom: say (1/998001).fmt('%.100f')

[06:10] <p6eval> nom 052cc6: OUTPUT«0.0000010020030040050059552870663145962559781310119433328509330749511718750000000000000000000000000000␤»

[06:10] <snarkyboojum> nom: say (1/998001).fmt('%.100f')

[06:10] <p6eval> nom 052cc6: OUTPUT«0.0000010020030040050059552870663145962559781310119433328509330749511718750000000000000000000000000000␤»

[06:10] <tadzik> hehe, been reading hacker news, haven't you? :)

[06:10] <snarkyboojum> why the truncation?

[06:10] <snarkyboojum> :P

[06:10] <sorear> course it'll run into Num issues

[06:10] <snarkyboojum> @tadzik 

[06:10] <sorear> you can't get more than ~17 useful digits out of a general Num

[06:10] <snarkyboojum> how do get a useful 100 digit number out of it? :D

[06:11] <sorear> and currently you can't go from Rat to Str except through Num

[06:11] * snarkyboojum looks at colomon 

[06:11] <sorear> snarkyboojum: echo 'oscale=120; 1/998001' | bc

[06:11] <sorear> just 'scale', sorry

[06:11] <snarkyboojum> 0?

[06:11] <TimToady> .oO( %f for fatrats :)

[06:12] <snarkyboojum> awww.. I wanted to use perl6 ;)

[06:14] <snarkyboojum> sorear: thank ye ;) for the *nix pipeline

[06:14] <snarkyboojum> still want a perl6ish way to do it ;)

[06:15] <TimToady> if we can have a pi spigot, we can certaintly have any other kind of spigot

[06:17] <snarkyboojum> TimToady: a 'spigot' being a tap or valve? :D

[06:18] <sorear> it wouldn't hurt to be better than everyone at everything, but it's not much of a priority of mine atm

[06:18] <snarkyboojum> I particularly like the association with "bunghole" for some reason

[06:19] <snarkyboojum> sorear: I think it's a reasonable request - perhaps it's an unreasonably reasonable request tho ;D

[06:20] <sorear> it's an explicit priority of TimToady's

[06:21] <snarkyboojum> physical challenge for colomon then I reckon :P

[06:23] <TimToady> perl6: my $x = 1/998001; print $x.floor, '.'; for ^100 { $x *= 10; print my $digit = $x.floor; $x -= $digit; }; print "\n";

[06:23] <p6eval> pugs b927740, rakudo 052cc6, niecza v13-357-g9374d97: OUTPUT«0.0000010020030040050060070080090100110120130140150160170180190200210220230240250260270280290300310320␤»

[06:24] <TimToady> wow, complete agreement!

[06:26] *** arlinius left
[06:27] <TimToady> snarkyboojum: ^^

[06:27] <snarkyboojum> TimToady: sweet :)

[06:33] *** replore_ left
[06:33] <TimToady> note that won't work for negatives without stripping the sign

[06:34] *** koban joined
[06:35] *** koban left
[06:41] <sorear> niecza: say Bool.so

[06:41] <p6eval> niecza v13-357-g9374d97: OUTPUT«Bool()␤»

[06:45] <sorear> it seems several spectests expect <a b> === <a b> to be True

[06:45] <dalek> niecza: 301a891 | sorear++ | lib/ (2 files):

[06:45] <dalek> niecza: Add WHICH, proper ===, ObjAt modelled on (but significantly divergent from) Rakudo-nom

[06:45] <dalek> niecza: review: https://github.com/sorear/niecza/commit/301a891ec3

[06:46] <dalek> roast: b05a6c1 | sorear++ | / (4 files):

[06:46] <dalek> roast: Unfudge suprisingly few tests that depended on value-type === for niecza

[06:46] <dalek> roast: review: https://github.com/perl6/roast/commit/b05a6c199c

[06:48] <sorear> phenny: tell [Coke] multi method WHICH(Date:D:) { ObjAt.new(str => $!daycount, ref => self.WHAT) }

[06:48] <phenny> sorear: I'll pass that on when [Coke] is around.

[07:09] *** GlitchMr joined
[07:31] *** wtw joined
[07:37] *** GlitchMr left
[08:31] *** GlitchMr joined
[08:33] *** mj41 joined
[08:43] *** fsergot left
[08:49] *** bkolera joined
[08:57] *** pnu left
[09:00] *** koban joined
[09:00] *** koban left
[09:02] *** pnu joined
[09:05] * sorear -> sleep

[09:05] *** fsergot joined
[09:05] *** GlitchMr42 joined
[09:06] *** GlitchMr left
[09:07] *** MContagious joined
[09:10] *** agentzh joined
[09:12] <masak> good morning, #perl6!

[09:13] <moritz> \o masak

[09:19] <masak> perl6: say 1 / 998001

[09:19] <p6eval> rakudo 052cc6: OUTPUT«1.00200300400501e-06␤»

[09:19] <p6eval> ..niecza v13-358-g301a891: OUTPUT«1.002003004005006E-06␤»

[09:19] <p6eval> ..pugs b927740: OUTPUT«0.000001002003004005006007008009010011012␤»

[09:19] <masak> cf http://news.ycombinator.com/item?id=3514721

[09:23] <masak> nom: my $r = 1/998001; loop { say ($r * 1000).fmt("%03d"); $r *= 1000; $r -= $r.Int }

[09:23] <p6eval> nom 052cc6: OUTPUT«(timeout)000␤001␤002␤003␤004␤005␤006␤007␤008␤009␤010␤011␤012␤013␤014␤015␤016␤017␤018␤019␤020␤021␤022␤023␤024␤025␤026␤027␤028␤029␤030␤031␤032␤033␤034␤035␤036␤037␤038␤039␤040␤041␤042␤043␤044␤045␤046␤047␤048␤049␤050␤051␤052␤053␤054␤055␤056␤057␤058␤059␤060␤061␤062␤063␤064…

[09:23] <masak> niecza: my $r = 1/998001; loop { say ($r * 1000).fmt("%03d"); $r *= 1000; $r -= $r.Int }

[09:23] <p6eval> niecza v13-358-g301a891: OUTPUT«(timeout)000␤001␤002␤003␤004␤005␤006␤007␤008␤009␤010␤011␤012␤013␤014␤015␤016␤017␤018␤019␤020␤021␤022␤023␤024␤025␤026␤027␤028␤029␤030␤031␤032␤033␤034␤035␤036␤037␤038␤039␤040␤041␤042␤043␤044␤045␤046␤047␤048␤049␤050␤051␤052␤053␤054␤055␤056␤057␤058␤059␤060␤06…

[09:25] <masak> it's a rational number which produces the integer sequence 000..997, 999 :)

[09:28] *** c1sung left
[09:40] *** c1sung joined
[09:42] *** daxim joined
[09:43] <masak> also, another beautiful Wikipedia list via @luqui on Twitter: http://en.wiktionary.org/wiki/Category:English_double_contractions

[09:45] <masak> "That bo's'n over in the fo'c'sle wouldn't've amounted to a ha'p'orth!"

[09:45] *** domidumont left
[09:46] * masak .oO( English as she is s'p'ke )

[09:48] *** domidumont joined
[09:52] *** agentzh left
[10:07] <bbkr> rakudo: sub foo ( :$id? where { say "I should not be here when there is no param passed"} ) {}; foo() # is this a bug?

[10:07] <p6eval> rakudo 052cc6: OUTPUT«I should not be here when there is no param passed␤»

[10:09] <arnsholt> Don't think so. It's an optional argument, and it's not passed

[10:10] *** fasad joined
[10:10] <arnsholt> If you want to require the named to be passed, say :$id!

[10:11] <bbkr> yes, i made it optional on purpose to show that where{} section is triggered when it should not be

[10:11] <bbkr> i mean - how ca you check subset rule of something that was not passed to you ?

[10:12] <arnsholt> Herp. I can't read, apparently. Sorry

[10:12] *** agentzh joined
[10:13] <fasad> masak: hi !

[10:14] <fasad> masak: I just copy-pasted ur chomp! game (http://strangelyconsistent.org/blog/june-15-2011-chomp) but get i get this error: Confused at line 15, near "PLAYER:\nlo"

[10:15] <fasad> i'm using rakudo-nom

[10:17] <moritz> nom doesn't like the labels

[10:18] <fasad> moritz: u mean it can't handle labels?

[10:19] <moritz> correct

[10:19] <moritz> and it's spelled "you", not "u" :-)

[10:20] <fasad> hmm.. so i need to rewrite the code...

[10:21] <fasad> moritz: :-O

[10:21] <moritz> or implement labels in nom :-)

[10:21] <fasad> lol...

[10:21] <moritz> niecza: foo: while 1 { last foo; }

[10:21] <p6eval> niecza v13-358-g301a891:  ( no output )

[10:21] <moritz> or use niecza

[10:25] <fasad> one more doubt, on http://strangelyconsistent.org/blog/june-14-2011-logic-operators , towards the end, "binds tightly" & "binds loosely", is he talking about operator "precedence" ?

[10:26] <moritz> yes

[10:27] <fasad> ok, thanks

[10:28] <fasad> english is my second language so sometimes don't get the hang of some phrases :|

[10:31] <fasad> i installed rakudo-nom using http://rakudo.org/how-to-get-rakudo-nom/, how do i keep it updated?

[10:33] <moritz> you occasionally run 'git pull', and then 'make install' (and if that complains that you need to run Configure.pl, you run Configure.pl again, and then 'make install')

[10:34] <jnthn> morning, #perl6

[10:34] <fsergot> o/ :)

[10:36] *** Trashlord left
[10:36] <fasad> moritz: i should skip 'make' ?

[10:37] *** GlitchMr42 is now known as GlitchMr

[10:37] <moritz> fasad: 'make install' implies 'make'

[10:38] <fasad> moritz: oh. thanks

[10:47] <bbkr> how can I force empty method signature? for example I want to declare "method foo () {}" and I don't want to "foo(id=>123)" be dispatched to it.

[10:48] *** takesako_ left
[10:50] <moritz> bbkr: all method signatures have an implicit *%_ attached to it

[10:50] <moritz> but maybe

[10:50] <arnsholt> bbkr: That's multi sub foo(:$id!) IIRC

[10:50] <moritz> nom: class A { method a(*%a where !%a) } }; A.a(foo => bar)

[10:50] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Missing block at line 1, near "} }; A.a(f"␤»

[10:50] <moritz> nom: class A { method a(*%a where !%a)  {} }; A.a(foo => bar)

[10:50] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&bar' called (line 1)␤»

[10:51] <moritz> nom: class A { method a(*%a where !%a)  {} }; A.a(foo => 'bar')

[10:51] <p6eval> nom 052cc6: OUTPUT«Constraint type check failed for parameter '%a'␤  in method a at /tmp/GkikCo6H_E:1␤  in block <anon> at /tmp/GkikCo6H_E:1␤  in <anon> at /tmp/GkikCo6H_E:1␤»

[10:51] <moritz> bbkr: that would be a way

[10:51] <bbkr> that should do, thanks :)

[10:52] <arnsholt> nom: multi sub foo() { say "no" }; multi sub foo(:$id!) { say $id }; foo(); foo(id => 1); # Works as well

[10:52] <p6eval> nom 052cc6: OUTPUT«no␤1␤»

[11:02] *** MContagious left
[11:23] <jnthn> moritz: Does S03-metaops/not.rakudo fail for you also?

[11:23] <dalek> niecza: e993223 | (Paweł Murias)++ | p5test/ (8 files):

[11:23] <dalek> niecza: Added p5test which test various stages of linking in a perl5 interpreter to mono.

[11:23] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e99322344a

[11:24] *** pmurias joined
[11:24] <pmurias> colomon: hi

[11:25] * pmurias notices he wrote the commit msg in broken english :(

[11:27] <dalek> rakudo/nom: 966f65c | jnthn++ | src/core/ (3 files):

[11:27] <dalek> rakudo/nom: Implement <prior>, this time without busting a bunch of spectests.

[11:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/966f65c9ba

[11:27] <dalek> rakudo/nom: b890f79 | jnthn++ | t/spectest.data:

[11:27] <dalek> rakudo/nom: Run S05-metasyntax/prior.t.

[11:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b890f79d18

[11:27] <dalek> roast: d5e732f | jnthn++ | S05-metasyntax/prior.t:

[11:27] <dalek> roast: Correct what would appear to be a thinko.

[11:27] <dalek> roast: review: https://github.com/perl6/roast/commit/d5e732f387

[11:29] <pmurias> colomon: the p5test script which i comited should help diagnose why the p5 interop fails to build on your machine

[11:31] <dalek> niecza: 0aaf9bf | (Paweł Murias)++ | p5test/p5test.pl:

[11:31] <dalek> niecza: Avoid harcoding the .so extension when building shared libraries from p5test.

[11:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0aaf9bff81

[11:45] *** fasad left
[11:45] <colomon> pmurias++

[11:49] <bbkr> rakudo: one(Array,Hash) # should junction work on types? I cannot find in spec.

[11:49] <p6eval> rakudo 052cc6: OUTPUT«Cannot look up attributes in a type object␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method gimme at s…

[11:49] *** Trashlord joined
[11:50] <bbkr> consequence of syntax "$x ~~ Array" should be possibility to use "$x ~~ Array|Hash"

[11:50] <moritz> bbkr: I think it should work

[11:50] <jnthn> Should work.

[11:51] * bbkr reports bug

[11:51] <bbkr> rakudo: Array|Hash

[11:51] <moritz> bbkr++

[11:51] <p6eval> rakudo 052cc6: OUTPUT«Cannot look up attributes in a type object␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method gimme at s…

[11:55] <moritz> nom: 1|Any

[11:55] <p6eval> nom 052cc6:  ( no output )

[11:55] <moritz> nom: Any|1

[11:55] <p6eval> nom 052cc6:  ( no output )

[11:55] <moritz> nom: List|1

[11:55] <p6eval> nom 052cc6: OUTPUT«Cannot look up attributes in a type object␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method gimme at src/…

[11:55] <moritz> something is sensitive to listness

[11:55] <moritz> nom: say 2 | <a b c>

[11:56] <p6eval> nom 052cc6: OUTPUT«any(2, a b c)␤»

[11:56] <moritz> but why?

[11:56] <moritz> nom: say 2 | 1..*

[11:56] <p6eval> nom 052cc6: OUTPUT«(timeout)»

[11:57] <moritz> nom: say (List, List).eager

[11:57] <p6eval> nom 052cc6: OUTPUT«use of uninitialized value of type List in string context␤use of uninitialized value of type List in string context␤ ␤»

[11:59] <moritz> nom: sub f(*@a) { @a.eager }; f List, 1

[11:59] <p6eval> nom 052cc6: OUTPUT«Cannot look up attributes in a type object␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method gimme at src/gen/CORE.setting:4738␤  in method eager at src/gen/CORE.setting:4715␤  in sub f at /tmp/ig7i3cZ50h:1…

[11:59] <moritz> nom: (List, 1).eager

[11:59] <p6eval> nom 052cc6:  ( no output )

[12:01] <jnthn> nom: (List, 1).list.eager

[12:01] <p6eval> nom 052cc6: OUTPUT«Cannot look up attributes in a type object␤  in method infinite at src/gen/CORE.setting:4749␤  in method infinite at src/gen/CORE.setting:4432␤  in method gimme at src/gen/CORE.setting:4738␤  in method eager at src/gen/CORE.setting:4715␤  in block <anon> at /tmp/XcHBV…

[12:01] <moritz> mmm

[12:02] <TimToady> niecza: say 2 | 1..*

[12:02] <p6eval> niecza v13-358-g301a891: OUTPUT«any(2..Inf, 1..Inf)␤»

[12:02] <TimToady> niecza: Array|Hash

[12:02] <p6eval> niecza v13-358-g301a891:  ( no output )

[12:02] <TimToady> niecza: say Array|Hash

[12:02] <p6eval> niecza v13-358-g301a891: OUTPUT«any(Array, Hash)␤»

[12:03] <colomon> pmurias: tests 4 and 5 fail, both with System.DllNotFoundException: /Users/colomon/tools/niecza/p5test/test4lib.dylib

[12:03] <TimToady> those both give Unitialized value in string context warnings locally for niecza

[12:03] <TimToady> niecza: say (List, List).eager

[12:03] <p6eval> niecza v13-358-g301a891: OUTPUT«Unhandled exception: Unable to resolve method eager in class Parcel␤  at /tmp/UtoJ4OSD8V line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3609 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3610 (module-CORE @ 62) ␤  at /h…

[12:05] *** mj41 left
[12:06] <TimToady> I guess it's the REPL that is giving the warnings

[12:06] *** drbean left
[12:07] *** drbean joined
[12:12] <moritz> I might have a patch for the Array|Hash thing

[12:12] <moritz> but of course I'll only know in 20 minutes after the setting has been compiled ... :/

[12:13] <Timbus> i preferred when it just took 2gb of my ram

[12:15] <jnthn> Well, you're both welcome to contribute to the serialization work I'm doing. :P

[12:16] <moritz> jnthn: I do consider it

[12:17] <moritz> the bigint stuff showed me that I can do a bit C stuff, with guidance :-)

[12:17] <moritz> jnthn: what's the plan?

[12:18] <jnthn> moritz: I've started work on the nqp/bs branch (bs = bounded serialization, but I can't be bothered to type that everytime... :))

[12:18] <jnthn> moritz: So far the main engine for it is in src/6model/serialize.c. 

[12:18] <tadzik> yeah, keep telling yourself it's not a pun ;)

[12:18] <jnthn> tadzik: shh :P

[12:19] <jnthn> At least it's not as bad as the Perl 6 Coding Contest :P

[12:19] <tadzik> :>

[12:19] <jnthn> moritz: Also tests in t/serialize/01-basic.t.

[12:20] <moritz> (bs) yeah, I've guessed what it means :-)

[12:21] <jnthn> moritz: Plan is something like: 1) get P6opaque serialization working, which shouldn't be too bad. 2) make cross-references between objects work. Also in theory not too hard. 3) design closure serialization mechanism (hard). 4) get STable serialization in place, at which point we should be able to serialize types.

[12:21] *** mj41 joined
[12:22] *** drbean left
[12:22] <moritz> for serializing P6opaque objects, can we count on the type object being available?

[12:22] <moritz> I hope so :-)

[12:22] <jnthn> moritz: The rule is that you can rely on the representation data being available.

[12:22] <moritz> ok

[12:22] <jnthn> moritz: Which contains enough to do serialization.

[12:23] <jnthn> moritz: I didn't quite get to handling type-objectness yet.

[12:24] <dalek> roast: 806d3f7 | jnthn++ | S12-class/namespaced.t:

[12:24] <dalek> roast: Untodo a test and make it handle CHECK time detection of missing subs.

[12:24] <dalek> roast: review: https://github.com/perl6/roast/commit/806d3f7f2d

[12:24] <dalek> roast: cfcbb8c | jnthn++ | S05-grammar/polymorphism.t:

[12:24] <dalek> roast: Fix a thinko, and tweak to avoid an issue with compile-time detection of something that hadn't use to get that.

[12:24] <dalek> roast: review: https://github.com/perl6/roast/commit/cfcbb8c229

[12:25] <dalek> rakudo/nom: 7f8c71c | jnthn++ | src/ (3 files):

[12:25] <dalek> rakudo/nom: First crack at getting /<Foo::Bar::baz>/ working again...think we didn't have that since the alpha days. Passes various tests.

[12:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7f8c71cf55

[12:25] <dalek> rakudo/nom: 6eae67e | jnthn++ | t/spectest.data:

[12:25] <dalek> rakudo/nom: Run S12-class/namespaced.t and S05-grammar/polymorphism.t.

[12:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6eae67eb9f

[12:25] <masak> I notice from the backlog that snarkyboojum++ beat me to the 1/998001 thing ;)

[12:26] <jnthn> o/ masak!

[12:26] <masak> \o !

[12:26] <masak> was there ever a resolution about the /$^x/ thing? who's right, Niecza or Rakudo?

[12:26] <masak> I'm sort of siding with Niecza there...

[12:26] <jnthn> nom: /:my $x/; say $x

[12:26] <p6eval> nom b890f7: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter (must be quoted to match literally) at line 1, near "my $x/; sa"␤»

[12:26] <jnthn> nom: /:my $x;/; say $x

[12:26] <p6eval> nom b890f7: OUTPUT«Any()␤»

[12:27] <jnthn> nom: /$^x;/

[12:27] <p6eval> nom b890f7: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix / instead at line 1, near "$^x;/"␤»

[12:27] <jnthn> nom: /$^x/

[12:27] <p6eval> nom b890f7:  ( no output )

[12:27] <jnthn> Hm, that should really whine.

[12:27] <masak> it considers the regex to be a block.

[12:27] <jnthn> I wish they were.

[12:27] <jnthn> Alas, I think the spec says otherwise.

[12:28] <masak> nod.

[12:29] <jnthn> I am a tad surprised that the :my thing works out and $^x doesn't, though.

[12:29] <jnthn> masak: Macro hacking today? :)

[12:30] *** drbean joined
[12:33] <masak> yes \o/

[12:33] <jnthn> \o/

[12:33] <masak> but as with any day-at-home, a lot of other little things slip in... :)

[12:33] *** bkolera left
[12:33] *** amkrankruleuen left
[12:33] <masak> gonna do ~30 of $dayjob before I get going.

[12:34] <jnthn> heh, yes, I should do a little of that too :)

[12:36] *** bkolera joined
[12:36] <dalek> roast: a5ebaab | jnthn++ | S05-grammar/polymorphism.t:

[12:36] <dalek> roast: Oops meant to unfudge this one.

[12:36] <dalek> roast: review: https://github.com/perl6/roast/commit/a5ebaab86b

[12:41] *** drbean left
[12:43] *** drbean joined
[12:53] *** PacoAir joined
[12:54] *** drbean left
[12:54] <dalek> roast: 991dbdb | moritz++ | S03-metaops/not.t:

[12:54] <dalek> roast: rakudo does not like empty todo fudges

[12:54] <dalek> roast: review: https://github.com/perl6/roast/commit/991dbdb2d1

[12:54] *** drbean joined
[13:08] *** drbean left
[13:09] *** drbean joined
[13:09] <moritz> nom: my @t; sub tracked(&f) { @t.push: &f }; tracked sub f() { say 'OH HAI' }; @t>>.()

[13:09] <p6eval> nom 6eae67: OUTPUT«OH HAI␤»

[13:10] <moritz> pseudo DSLs ftw!

[13:10] <jnthn> :)

[13:10] * jnthn fixed >>.() recently :)

[13:12] <moritz> nom: sub stupid (|$) { }; stupid sub routine() { 'does nothing' }

[13:12] <p6eval> nom 6eae67:  ( no output )

[13:19] *** bluescreen10 left
[13:21] *** drbean left
[13:23] *** drbean joined
[13:25] *** bluescreen10 joined
[13:29] <moritz> jnthn: it seems that you haven't told ACT (the conference web system) that you want to attend GPW2012

[13:30] <jnthn> moritz: Really?

[13:30] <jnthn> moritz: I thought I had to do that in order to submit talks!

[13:31] <moritz> jnthn: at least the guy who writes the invoices said that... :-)

[13:32] <moritz> jnthn: seems you are signed up correctly, and our treasurer is confused

[13:32] <jnthn> moritz: Ah, I didn't buy a ticket...do I need to do that?

[13:32] <jnthn> Or are speakers immune from this? :)

[13:33] <moritz> jnthn: I think you should

[13:33] <moritz> it just triggers the treasurer to write an invoice to you, and leave him less confused

[13:35] <jnthn> done

[13:36] <moritz> thanks

[13:36] <dalek> roast: d22f208 | moritz++ | S32-str/split.t:

[13:36] <dalek> roast: a lone rakudo unfudge

[13:36] <dalek> roast: review: https://github.com/perl6/roast/commit/d22f208a98

[13:36] *** Trashlord left
[13:37] *** jlaire joined
[13:49] *** kaleem left
[13:49] <masak> oh!

[13:49] * masak checks if he has signed up

[13:50] <masak> seems I have.

[13:51] <masak> but... I should buy a ticket, too, by the above discussion...

[13:51] <masak> moritz: regular price, right?

[13:52] <pmurias> colomon: could you nopaste test4.exe.config?

[13:53] * masak has now bought a ticket

[13:54] <jnthn> masak: Speakers >= 20 mins get reduced rate (50 EUR)

[13:54] * [Coke] yawns.

[13:54] <phenny> [Coke]: 06:48Z <sorear> tell [Coke] multi method WHICH(Date:D:) { ObjAt.new(str => $!daycount, ref => self.WHAT) }

[13:57] <[Coke]> rss feeds for github aren't escaping xml in commit messages.

[13:57] *** jlaire left
[13:57] <[Coke]> <prior> vanished in one of them, e.g.

[13:58] *** jlaire joined
[13:58] <masak> jnthn: oh! too late. oh well, I'm happy to pay full price if it comes to that.

[13:58] <jnthn> [Coke]: Ouch! :)

[13:59] <masak> [Coke]: I'm sure github would like to hear about this.

[14:00] * jnthn ponders a troll commit ;)

[14:01] <[Coke]> jnthn: I will add it as a TODO.

[14:01] <colomon> pmurias: https://gist.github.com/1688920

[14:02] <colomon> pmurias: (sorry for delay, busy cleaning for company due to arrive in an hour)

[14:02] <pmurias> np ;)

[14:02] <pmurias> the .dylib file exists?

[14:03] <colomon> test4lib.dylib, yes

[14:03] <colomon> 8368 bytes long, does that sound right?

[14:03] <colomon> afm # shoveling snow

[14:03] <[Coke]> sorear, colomon: I now have rakudo's Temporal.pm building, we get 159 more tests and a lot of runtime issues; I'll clean those up and commit sometime this weekend.

[14:04] *** joe___ joined
[14:04] <[Coke]> jnthn: any feedback you might have on partcl/partcl-nqp's nqp branch is greatly appreciated. ;)

[14:04] <colomon> [Coke]++

[14:04] <jnthn> .oO( When will Niecza produce something Rakudo can nab to get more tests... )

[14:04] <[Coke]> jnthn: hee. ;)

[14:05] <[Coke]> how much of rakudo's perl6 came from pugs?

[14:05] <[Coke]> (any?)

[14:05] <moritz> maybe parts of Test.pm

[14:05] <joe___> hi perl6 ! a stupid question . what's this .()?

[14:05] <moritz> but nothing in the setting

[14:06] <timotimo> what's the correct way to assign "say" to a &var? it seems my &debug = say will call say without argument and try to set the return value to &debug.

[14:06] <masak> joe___: it's a function call.

[14:06] <masak> nom: sub foo { say "OH HAI" }; foo.()

[14:06] <p6eval> nom 6eae67: OUTPUT«OH HAI␤Method 'postcircumfix:<( )>' not found for invocant of class 'Bool'␤  in <anon> at src/gen/Metamodel.pm:3418␤  in block <anon> at /tmp/xCh4ZCXlFQ:1␤  in <anon> at /tmp/xCh4ZCXlFQ:1␤»

[14:06] <masak> oh right.

[14:06] <jnthn> masak: Need &

[14:06] <jnthn> :)

[14:06] <moritz> timotimo: $var = &say

[14:06] <masak> nom: sub foo { say "OH HAI" }; &foo.()

[14:06] <p6eval> nom 6eae67: OUTPUT«OH HAI␤»

[14:06] <masak> \o/

[14:06] <jnthn> The larger value Rakudo got from Pugs was the test suite built during it as well as the many spec improvements/clarifications.

[14:06] <timotimo> moritz: can you explain why that works? why wouldn't i use the &sigil?

[14:06] <joe___> thanks masak

[14:06] <masak> jnthn: yeah, brain not booted up enough yet. need coffee :P

[14:07] <jnthn> Generally, the later you start building a Perl 6 implementation, the better off you are. :)

[14:07] <moritz> timotimo: leaving out the sigil implies calling the sub immediately

[14:07] <jnthn> timotimo: You can put anything in a scalar

[14:08] <jnthn> nom: sub foo() { say 'hi' }; my &bar = &foo; bar()

[14:08] <p6eval> nom 6eae67: OUTPUT«hi␤»

[14:08] <jnthn> You can do that also.

[14:09] *** bkolera left
[14:10] <timotimo> ah. the error i was getting was actually from somewhere else - i was trying to set an empty block to &debug with &debug = {}, but of course that's an empty hash, not an empty block

[14:10] <timotimo> {$_} instead works great

[14:10] <jnthn> timotimo: &debug = -> { } # maybe clearer

[14:11] <moritz> or {;}

[14:11] *** xinming left
[14:12] <joe___> moritz's code .in the situation @t>>.() what is the function called?no function name?

[14:13] *** xinming joined
[14:13] <moritz> joe___: each entry in @t is a subroutine

[14:13] <moritz> (though there's just one inthere)

[14:13] <masak> I wonder what the big downside would be of having {} be a Hash, but auto-promote to an empty Block when someone expects it.

[14:14] <moritz> in my example

[14:14] <masak> (bad masak, trying to subvert the type system)

[14:14] <masak> timotimo: how's learning Perl 6 going? I'm curious.

[14:15] *** Maddingue left
[14:15] <joe___> moritz: thanks. where is the doc I can read it about it?

[14:15] <timotimo> lots of bashing my head against the interactive interpreter :)

[14:15] *** Maddingue joined
[14:15] <PerlJam> repl++

[14:16] <timotimo> now i'm trying to conditionally overwrite the global "say" if $debug is set to False, but that's not turning out so well

[14:16] <dalek> niecza: e0b4e76 | (Paweł Murias)++ | p5test/p5test.pl:

[14:16] <dalek> niecza: try various gcc invocations in p5test

[14:16] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e0b4e76cc2

[14:16] <timotimo> (i'm making a recursive fibonacci sequence calculator with memoization)

[14:17] <timotimo> (i was very, very pleased with "multi fib(Int $x where %memo) { %memo{$x} }")

[14:18] <moritz> joe___: S03 talks about the >> mhyper

[14:18] <moritz> timotimo: that's cute :-)

[14:18] <masak> nom: my &real-say = &say; sub say { &real-say("LOL, NO U CAN'T") }; say 42

[14:18] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'say' will never work with argument types (int) (line 1)␤    Expected: :()␤»

[14:18] <pmurias> colomon: i made p5test try various ways of creating the shared library, you could check if any of them helps

[14:18] <joe___> moritz: thanks again.

[14:18] <masak> nom: my &real-say = &say; sub say(*@) { &real-say("LOL, NO U CAN'T") }; say 42

[14:19] <p6eval> nom 6eae67: OUTPUT«maximum recursion depth exceeded␤  in sub say at /tmp/K5ymsi5EMb:1␤  in sub say at /tmp/K5ymsi5EMb:1␤  in sub say at /tmp/K5ymsi5EMb:1␤  in sub say at /tmp/K5ymsi5EMb:1␤  in sub say at /tmp/K5ymsi5EMb:1␤  in sub say at /tmp/K5ymsi5EMb:1␤  in sub say at /tmp/K5ymsi5EMb…

[14:19] <masak> oh right.

[14:19] <moritz> helps to introduce a new scope

[14:19] <masak> nom: sub say(*@) { $*OUT.say("LOL, NO U CAN'T") }; say 42

[14:19] <p6eval> nom 6eae67: OUTPUT«LOL, NO U CAN'T␤»

[14:19] <timotimo> it seems the sub say assignment happens before the code is run

[14:19] <masak> timotimo: right, I botched it up.

[14:20] <masak> timotimo: the '&say' in the assignment refers to my new sub.

[14:20] <moritz> my &outer-say = &say; my $debug = 1; do { my &say = $debug ?? &outer-say !! sub (|$) { 'do nothing' }; say 'foo' }

[14:20] <moritz> nom: my &outer-say = &say; my $debug = 1; do { my &say = $debug ?? &outer-say !! sub (|$) { 'do nothing' }; say 'foo' }

[14:20] <p6eval> nom 6eae67: OUTPUT«foo␤»

[14:20] <timotimo> that was also my problem in my MAIN, i set "only sub say(*@a) {}", but apparently that only set say in the MAIN. then i used our in front and it happened always, regardless of whether the if around it would pass or not. or something. didn't analyse it thoroughly

[14:21] <moritz> nom: my &outer-say = &say; my $debug = 0; do { my &say = $debug ?? &outer-say !! sub (|$) { 'do nothing' }; say 'foo' }

[14:21] <p6eval> nom 6eae67:  ( no output )

[14:21] <masak> \o/

[14:21] <moritz> timotimo: subroutines and subroutine lookup are both lexically scoped

[14:21] <moritz> timotimo: so an 'our' in front really doesn't change anything unless you explictly call with a namespace

[14:22] *** joe___ left
[14:22] <masak> moritz: what's the difference between 'subroutines' and 'subroutine lookup' in that sentence? :)

[14:22] <timotimo> nom: say "huh."; sub say (*@a) {}; say "oh well.";

[14:22] <p6eval> nom 6eae67:  ( no output )

[14:22] <timotimo> i'm used to this being different from python

[14:22] <timotimo> but that's okay, just need to learn it once :)

[14:23] <moritz> masak: well, there was a time where subroutines where lexical, but subroutine lookup was lexical + our-scope

[14:23] <masak> nom: our sub foo { say "OH HAI" }; main::foo

[14:23] <p6eval> nom 6eae67: OUTPUT«Could not find symbol 'main::&foo'␤  in block <anon> at /tmp/nOIgAI1Xr6:1␤  in <anon> at /tmp/nOIgAI1Xr6:1␤»

[14:23] <moritz> timotimo: subroutine lookup is done before runtime, and postdeclarations are OK

[14:23] <masak> shouldn't that be '&main::foo'?

[14:24] <moritz> nom: foo(); sub foo() { say 'in foo, postdeclared' }

[14:24] <timotimo> yes, that's what i thought. now i have to run

[14:24] <p6eval> nom 6eae67: OUTPUT«in foo, postdeclared␤»

[14:24] <masak> moritz: not sure I understand your distinction.

[14:25] <moritz> masak: if it help you, think of $*foo variables, which can be declared lexically, but looked up dynamically

[14:26] <moritz> *helps

[14:27] <masak> moritz: so you're talking about the scope on the one hand, and the lookup chain on the other?

[14:27] <masak> it's like the declaration and the use have to make contact, and both have different reach.

[14:28] <masak> or may have different reach.

[14:28] <moritz> correct

[14:29] <masak> but it's important not to be sloppy there. dynamic *variables* are still looked up statically/lexically. their *values* are looked up through the call chain.

[14:29] *** jaldhar left
[14:29] <masak> similarly with private attributes.

[14:29] <moritz> huh

[14:29] <masak> er, not a good comparison :)

[14:29] <moritz> in what way are dynamic variables looked up statically?

[14:29] <jnthn> huh

[14:29] <moritz> std: $*a

[14:29] <p6eval> std 47c76b3: OUTPUT«ok 00:01 108m␤»

[14:30] <jnthn> masak: They're looked up using the dynamic chain :)

[14:30] <moritz> if there was any kind of static lookup involved, that would die

[14:30] <masak> I thought you had to do 'my $*a' even with dynamic vars...

[14:30] <jnthn> masak: They're declared in a given lexical scope.

[14:30] <masak> right.

[14:30] <jnthn> masak: The lookup of them is entirely dynamic.

[14:30] <masak> ok.

[14:31] <masak> jnthn: it's weird, I distinctly remember us talking about this at the 2010 YAPC::EU attendees' dinner.

[14:32] <masak> but maybe I'm mixing up "lexical scope" with "lexical variable lookup".

[14:32] <jnthn> masak: You don't drink enough beer at YAPC::EU attendees' dinners. :P

[14:32] <masak> jnthn: O RLY? how else would I be able to understand macros? huh? huh? :P

[14:32] <jnthn> :P

[14:33] * jnthn is constantly bemused by masak's ability to remember discussions from years ago along with the location they took place :)

[14:34] * moritz remembers discussing macros with masak++ in breakfast hall of the hotel in Copenhaagen 2010

[14:34] <moritz> https://gist.github.com/1689053

[14:36] * masak remembers that breakfast discussion too

[14:36] <masak> that's when we first realized that ASTs aren't closures, but still need to retain the lexical environment in which they were created.

[14:37] <masak> then we forgot it for a while, and now we're back to being aware of it ;)

[14:38] <moritz> I remember that my conclusion was mostly "I don't want to be the guy who implements macros"

[14:38] <moritz> :-)

[14:40] <masak> yeah, ha ha! poor schmuck! :P

[14:40] <moritz> std: 1 1

[14:40] <masak> he's going to have to reach into the OUTER pointer or... something...

[14:40] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/9DoH7rgpR1 line 1:␤------> 1 ⏏1␤    expecting any of:␤ bracketed infix␤        infix or meta-infix␤    statement modifier loop␤Parse failed␤FAILED 00:01 108m␤»

[14:41] <masak> nom: sub foo($x? where { .defined }) { say "OH HAI" }; foo

[14:41] <p6eval> nom 6eae67: OUTPUT«Constraint type check failed for parameter '$x'␤  in sub foo at /tmp/nYpvuacgNi:1␤  in block <anon> at /tmp/nYpvuacgNi:1␤  in <anon> at /tmp/nYpvuacgNi:1␤»

[14:41] <masak> what say you? should the above run the where clause or not?

[14:41] <masak> this is re https://rt.perl.org/rt3//Public/Bug/Display.html?id=109182

[14:41] <jnthn> masak: I was dubious about that ticket.

[14:42] <moritz> masak: it's wrong

[14:42] <jnthn> masak: We used to have a bug where we didn't type check default values.

[14:42] <moritz> type checks also apply to defaults

[14:43] <jnthn> Right

[14:43] <jnthn> Yeah, I think the ticket is wrong.

[14:43] <moritz> and optional params are just some weird kind of automatic undefined default

[14:43] <jnthn> It's not so hard to imagine a where condition that matches on undefined and defined values.

[14:44] *** wolfman2000 left
[14:44] * masak rejects toclet

[14:46] <[Coke]> was ist eine toclet?

[14:47] <masak> typing from the wrong angle :P

[14:48] * [Coke] wonders why masak's reply to 109134 displays incorrectly.

[14:48] <jnthn> Yeah, it's best to hold your hands at a right angle to the keyboard :P

[14:49] <[Coke]> (to the point where it's showing as a different thread.)

[14:49] <[Coke]> Did you reply via email or inside of RT?

[14:49] <colomon> pmurias: https://gist.github.com/1689126  # and back to cleaning

[14:50] * jnthn goes for a stroll to help him ponder serialization stuff

[14:51] <pmurias> colomon: it turns out -m32 helps, thanks

[14:51] <masak> [Coke]: inside RT. it displayed correctly already when I wrote it.

[14:52] <masak> s/correctly/incorrectly/

[14:52] <masak> [Coke]: so RT botched it up somehow.

[14:58] <masak> jnthn: my keyboard is on the floor, and I was typing as I was standing up... :)

[14:59] <dalek> niecza: f54066a | (Paweł Murias)++ | p5test/p5test.pl:

[14:59] <dalek> niecza: Use the right compiler invocation in the last test in p5test.pl

[14:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f54066a6e7

[15:04] <fsergot> nom: my @a = <a b c>; say @a.elems;

[15:04] <p6eval> nom 6eae67: OUTPUT«3␤»

[15:05] *** birdwindupbird left
[15:06] *** tokuhirom joined
[15:08] <[Coke]> nqp: use NQPP6Regex; use NQPP6Regex; say "alive?"

[15:08] <p6eval> nqp: OUTPUT«Confused at line 1, near "say \"alive"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[15:08] <[Coke]> nqp: use NQPP6Regex; use NQPP6Regex; say "alive?";

[15:08] <p6eval> nqp: OUTPUT«Confused at line 1, near "say \"alive"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[15:08] <[Coke]> nqp: use NQPP6Regex; use NQPP6Regex; say("alive?");

[15:08] <p6eval> nqp: OUTPUT«alive?␤»

[15:10] <pmichaud> good morning, #perl6

[15:11] <masak> pmichaud! \o/

[15:11] <[Coke]> ho, pmichaud++

[15:13] <fsergot> nom: sub a( *%a? ) { say 1; }; a(); 

[15:13] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Malformed block at line 1, near "( *%a? ) {"␤»

[15:14] <fsergot> nom: sub a( *"a? ) { say 1; }; a(); 

[15:14] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Malformed parameter at line 1, near "*\"a? ) { s"␤»

[15:14] <fsergot> nom: sub a( *@a? ) { say 1; }; a(); 

[15:14] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Malformed block at line 1, near "( *@a? ) {"␤»

[15:14] <fsergot> nom: sub a(*@a?){ say 1; }; a(); 

[15:14] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Malformed block at line 1, near "(*@a?){ sa"␤»

[15:14] <masak> std: sub a( *@a? ) {}

[15:14] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Unable to parse signature at /tmp/F_u1oaPbOd line 1:␤------> sub a⏏( *@a? ) {}␤Couldn't find final ')'; gave up at /tmp/F_u1oaPbOd line 1:␤------> sub a( *@a⏏? ) {}␤    expecting any of:␤    constraint…

[15:15] <masak> fsergot: I don't think it makes much sense to make slurpy arrays optional.

[15:15] <fsergot> masak: You are right, I just wanted to check it. :)

[15:16] <masak> curiosity++

[15:16] <fsergot> nom: sub a(*@a){ say 1; }; a(); 

[15:16] <p6eval> nom 6eae67: OUTPUT«1␤»

[15:17] <fsergot> Hmm, works as if  ? was there :)

[15:18] <fsergot> nom: sub a(*%a){ say 1; }; a(); 

[15:18] <p6eval> nom 6eae67: OUTPUT«1␤»

[15:18] <fsergot> nom: sub a(*%a){ say defined %a; }; a(); 

[15:18] <p6eval> nom 6eae67: OUTPUT«Bool::True␤»

[15:18] <fsergot> Why not false? :)

[15:20] <[Coke]> niecza: sub a(*%a){ say defined %a; }; a();

[15:20] <masak> fsergot: because Array and Hash are created in a defined state.

[15:20] <p6eval> niecza v13-358-g301a891: OUTPUT«Bool::True␤»

[15:20] <[Coke]> niecza: sub a(*%a?){ say defined %a; }; a();

[15:20] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤Unable to parse signature at /tmp/gJJ05xJNQN line 1:␤------> sub a(⏏*%a?){ say defined %a; }; a();␤Couldn't find final ')'; gave up at /tmp/gJJ05xJNQN line 1:␤------> sub a(*%a⏏?){ say defi…

[15:20] <jnthn> o/ pmichaud 

[15:21] <masak> fsergot: there's a long rant/RT ticket about it, where I don't like it using many words to say so.

[15:21] <masak> fsergot: I was looking for it today; didn't find it.

[15:21] <masak> fsergot: nowadays, I think it's a good idea for arrays/hashes to always be defined and ready to be used.

[15:21] <masak> fsergot: mostly because the alternative would be a mess.

[15:22] <fsergot> masak: so is there any way to check if there is any items in *%hash?

[15:22] <jnthn> if %hash { ...yes there are... }

[15:23] <fsergot> thanks :)

[15:23] <masak> fsergot: oh, here it is: https://rt.perl.org/rt3/Ticket/Display.html?id=64928

[15:23] <fsergot> nom: sub a(*%a){ say %a.Bool; }; a(); 

[15:23] <p6eval> nom 6eae67: OUTPUT«Bool::False␤»

[15:23] <masak> fsergot: what jnthn said. or %hash.elems or %hash.keys or +%hash

[15:24] <fsergot> Thanks :)

[15:24] <jnthn> Though %hash burns least CPU cycles :)

[15:25] * masak hurries the optimizer along

[15:25] *** wtw left
[15:27] <pmichaud> even  ?%hash works

[15:27] <pmichaud> similarly,  ?@array works nicely without having to reify all of the elements of @array  :-P

[15:27] <masak> even ~%hash works!

[15:27] <masak> :P

[15:28] <pmichaud> as opposed to +@array, which does reification

[15:28] <fsergot> :)

[15:28] <masak> oh, true.

[15:28] <masak> yeah, I wouldn't write +@array in my own code.

[15:28] * jnthn assumes if @array { } works out just the same as ?@array

[15:28] <masak> I prefer my casts to be implicit.

[15:28] <masak> jnthn: yah, cus 'if' boolifies.

[15:29] <jnthn> Right.

[15:29] <pmichaud> since ?@array is better than +@array for checking non-emptiness, I recommend ?%hash over +%hash for the same reason.

[15:29] <pmichaud> s/for the same reason/for consistency/

[15:29] <jnthn> fwiw, in Rakudo, ?%hash will also be faster than +%hash, though only marginally.

[15:31] <pmichaud> a bit more than marginally, if you turn around and use the results in a boolean context

[15:31] <jnthn> True.

[15:31] <pmichaud> if ?%hash { ... }   is likely to be faster than   if ?+%hash { ... }

[15:32] <jnthn> Oh, for sure. I was more meaning that ?@array vs +@array is potentially the difference between O(1) and O(n), whereas ?%hash and +%hash are both O(1), just varying in constant factor.

[15:32] <pmichaud> wfm

[15:37] <dalek> nqp/bs: 6e75c9a | jnthn++ | src/PAST/Regex.pir:

[15:37] <dalek> nqp/bs: Fix what appears to be an inverted condition in the old regex engine's charlist prefix computation.

[15:37] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/6e75c9a0e9

[15:37] <dalek> nqp/bs: 95a5b70 | jnthn++ | t/serialization/01-basic.t:

[15:37] <dalek> nqp/bs: Correct test count.

[15:37] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/95a5b70dce

[15:37] <dalek> nqp/bs: a5990b0 | jnthn++ | src/6model/serialization.c:

[15:37] <dalek> nqp/bs: Initial twiddle to handle type objects a bit better during serialization.

[15:37] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/a5990b083e

[15:40] *** Chillance joined
[15:40] <masak> nom: my $a = 5; sub foo($b?) { $a += $b }; foo

[15:40] <p6eval> nom 6eae67: OUTPUT«use of uninitialized variable $b of type Any in numeric context␤»

[15:41] <pmichaud> what value should I give to --gen-nqp to mean "use whatever nqp/ source is already available" ?

[15:41] <pmichaud> i.e., to treat the current nqp/ source tree as being adequate without doing a git checkout/fetch/update

[15:42] <masak> nom: my $a = 5; sub foo($b?) { $a += $b }; BEGIN { foo }; say $a

[15:42] <p6eval> nom 6eae67: OUTPUT«use of uninitialized variable $b of type Any in numeric context␤5␤»

[15:42] <jnthn> pmichaud: Is a --use-nqp maybe clearer?

[15:42] <pmichaud> might be easily conflated with --with-nqp

[15:42] <jnthn> pmichaud: Oh, you mean it should build it

[15:43] <jnthn> But not fetch it

[15:43] <pmichaud> correct

[15:43] <jnthn> --build-nqp :)

[15:43] <jnthn> --gen-nqp=local

[15:44] <pmichaud> 'local' might work for now.

[15:44] <jnthn> pmichaud: Guess the difficulty is if we end wiht a branch called "local" :)

[15:44] *** Khisanth left
[15:44] <jnthn> .oO( --gen-nqp=this-one-right-here )

[15:44] <pmichaud> well, this will also ultimately end up in the nqp and rakudo configures as well, with similar meaning

[15:44] *** kaare_ joined
[15:45] <jnthn> pmichaud: We don't get to specify a directory that contains the nqp to build, which is why I wondered about another option

[15:45] <pmichaud> another option can work also... not sure what to call it

[15:45] <pmichaud> --nqp-source={dir}

[15:45] <jnthn> --nqp-source perhaps

[15:45] <pmichaud> maybe

[15:45] <jnthn> heh :)

[15:46] <pmichaud> but I'd like the option to Star's Configure.pl to be pretty minimal

[15:46] <jnthn> nom: say ('great minds', 'all fools').pick :)

[15:46] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Confused at line 1, near "say ('grea"␤»

[15:46] <jnthn> nom: say ('great minds', 'all fools').pick # :)

[15:46] <p6eval> nom 6eae67: OUTPUT«great minds␤»

[15:46] <jnthn> \o/

[15:46] <pmichaud> i.e., I don't want to have someone have to do   Configure.pl --nqp-source=nqp --parrot-source=parrot  

[15:47] <pmichaud> which is why  "--gen-nqp" and "--gen-parrot" kinda works

[15:47] *** tokuhirom left
[15:47] <jnthn> pmichaud: Could star's Configure have those as defaults? Or are they bad ones?

[15:47] <pmichaud> --build-nqp and --build-parrot are now sounding better

[15:47] *** tokuhirom joined
[15:47] <jnthn> Yeah, those work.

[15:47] <pmichaud> Configure.pl --build-parrot

[15:47] <jnthn> Does that still imply that you get an NQP?

[15:48] <pmichaud> yes

[15:48] <pmichaud> anytime you build a new parrot, you have to get a new NQP based on it

[15:48] <pmichaud> otherwise things don't work :)

[15:48] <jnthn> Makes sense. :)

[15:48] <jnthn> Yes, working is generlaly preferred :)

[15:48] <jnthn> *generally

[15:49] <pmichaud> if we do that, then --gen-parrot and --gen-nqp can always refer to the "retrieve copy via git" option, while --build-parrot={dir} and --build-nqp={dir} can be the "use the source already in {dir}" option.

[15:49] <pmichaud> and star's Configure.pl can default {dir} when they aren't supplied.

[15:50] <masak> TimToady: if 'macro infix:<+>' shadows the core definition of &infix:<+> in a scope, what does '[+]' do? (and other similar meta'd operators)

[15:51] *** aloha left
[15:52] *** tokuhirom left
[15:54] <masak> oh carp. in writing tests to cover my D1 progress so far, I discovered a case that I don't implement correctly! :)

[15:55] <masak> seems 'macro infix:<+>' works -- with any previously existing operator -- but 'macro infix:<foo>' doesn't work.

[15:55] <masak> strangely, it works fine with 'sub infix:<foo>'.

[15:55] <masak> ah well. tests++

[15:57] *** aloha joined
[15:58] *** Khisanth joined
[15:59] <jnthn> pmichaud: +1

[15:59] <jnthn> masak: See routine_def and you'll likely spot something you're missing in macro_def :)

[15:59] *** agentzh left
[16:00] <fsergot> nom : my @a = 1,2,3,4,5; say map { $_++ } <== @a;

[16:00] <fsergot> nom: my @a = 1,2,3,4,5; say map { $_++ } <== @a;

[16:00] <p6eval> nom 6eae67: OUTPUT«1 2 3 4 5␤»

[16:00] <fsergot> :(

[16:00] <jnthn> nom: my @a = 1,2,3,4,5; say map { ++$_ } <== @a;

[16:00] <p6eval> nom 6eae67: OUTPUT«1 2 3 4 5␤»

[16:00] <masak> jnthn: I had just concluded that, too :)

[16:00] <masak> jnthn++

[16:01] <masak> might be some more rebase slippage.

[16:01] <jnthn> fsergot: er, I dunno even know quite how that is parsing :)

[16:01] <masak> 'cus I copied routine_def way back then.

[16:01] <jnthn> nom: my @a = 1,2,3,4,5; say (map { ++$_ } <== @a);

[16:01] <p6eval> nom 6eae67: OUTPUT«2 3 4 5 6␤»

[16:01] * masak checks routine_def

[16:01] <jnthn> fsergot: Was just precedence. But note

[16:01] <fsergot> It works! :)

[16:02] <jnthn> nom: my @a = 1,2,3,4,5; @a ==> map { ++$_ } ==> say

[16:02] <p6eval> nom 6eae67: OUTPUT«2 3 4 5 6␤»

[16:02] <fsergot> jnthn: is there another way to do this?  :)

[16:02] <jnthn> fsergot: What exactly are you trying to do? Increment everything in the array?

[16:02] <fsergot> Yes :)

[16:03] <jnthn> nom: my @a = 1,2,3,4,5; @a>>++; say @a;

[16:03] <p6eval> nom 6eae67: OUTPUT«2 3 4 5 6␤»

[16:03] <jnthn> nom: my @a = 1,2,3,4,5; say ++<<@a;

[16:03] <p6eval> nom 6eae67: OUTPUT«2 3 4 5 6␤»

[16:03] <fsergot> nom: my @a = 1,2,3,4,5; say @a>>++;

[16:03] <p6eval> nom 6eae67: OUTPUT«1 2 3 4 5␤»

[16:04] <jnthn> fsergot: Right, because ++ is post-increment.

[16:04] <fsergot> Clear. :)

[16:04] <fsergot> jnthn, i was just trying. :)

[16:05] <jnthn> felher: I was just 'splainin'. :)

[16:05] <jnthn> er

[16:05] <jnthn> fsergot: ^^

[16:05] <jnthn> ...tab fail :)

[16:05] <masak> don't bring felher into this! :P

[16:11] * masak does a diff of routine_def and macro_def

[16:12] <pmichaud> hmmm... adding --build-parrot and --build-nqp makes a lot more permutations of options.

[16:13] <pmichaud> How about --gen-parrot={path} and --gen-nqp={path}  ?

[16:13] <masak> ah, I see moritz++' exceptions work in the changes... shouldn't matter...

[16:13] <fsergot> :)

[16:14] <pmichaud> ...where we detect {path} by the presence of a slash

[16:14] <pmichaud> (and maybe backslash, for those people burdened with windows)

[16:15] <masak> ...oh, and something about inlining information... no that shouldn't matter either...

[16:16] <masak> pmichaud: I always do just --gen-parrot. what does/would the {path} value mean if it didn't contain any slashes?

[16:16] <pmichaud> it means checkout a specific branch of parrot

[16:16] <pmichaud> --gen-parrot=master  always get's Parrot's master branch

[16:16] <pmichaud> *gets

[16:17] <jnthn> pmichaud: Disambiguating on slashes works I guess

[16:17] *** mj41 left
[16:17] <pmichaud> alternatively I could disambiguate by the existence of {path}

[16:17] <pmichaud> i.e., if the argument to --gen-nqp is a directory, use that directory, otherwise treat it like a tag for a git checkout

[16:17] <masak> jnthn: $*W.install_lexical_symbol now takes a :clone(1) argument. I don't have that in my code. might that make a difference?

[16:17] <jnthn> That also works

[16:18] <jnthn> masak: Make a difference for...what? :)

[16:18] <pmichaud> any preference among the folks here ?

[16:18] <jnthn> pmichaud: I don't feel too strongly. It's very unlikely that nqp will have a branch called nqp.

[16:18] <masak> jnthn: I can do 'sub infix:<foo>' just fine in my codebase, but 'macro infix:<foo>' fails for some reason. trying to understand why by looking at differences between routine_def and macro_def.

[16:19] <jnthn> pmichaud: So going on "does it exist as a directory" is likely fine.

[16:19] <pmichaud> I think that's ultimately cleaner

[16:19] <pmichaud> it's just a configure script, so we can change it if it becomes too problematic

[16:19] <masak> +1

[16:19] <jnthn> masak: Grammar.pm:1456

[16:20] * masak looks

[16:20] <masak> oh!

[16:21] <masak> dang, so I'm probably missing that bit in the macro_def rule!

[16:21] <masak> hadn't even thought to look there yet. jnthn++

[16:22] <masak> by the way, there's plenty of code duplication, but I'm not sure yet whether unifying macro_def and routine_def will lead to cleanitude, or insanitude.

[16:24] <moritz> maybe both :-)

[16:25] <jnthn> clear insanitude?

[16:25] * masak .oO( clearly insane )

[16:25] *** Trashlord joined
[16:27] *** daxim left
[16:30] <masak> jnthn: it's refreshing to see how previously insurmountable problem now translate to "do something clever with $*W"-type solutions :)

[16:30] <masak> s/problem/problems/

[16:33] <masak> jnthn++ # that did the trick

[16:33] <jnthn> yay

[16:35] <dalek> rakudo/macros2: ce3d4ac | masak++ | src/Perl6/Grammar.pm:

[16:35] <dalek> rakudo/macros2: copy new routine_def rule to macro_def

[16:35] <dalek> rakudo/macros2: 

[16:35] <dalek> rakudo/macros2: With judicious changes, of course.

[16:35] <dalek> rakudo/macros2: 

[16:35] <dalek> rakudo/macros2: Noticed that we were out of sync because new macro operators couldn't be

[16:35] <dalek> rakudo/macros2: defined (but new sub operators could).

[16:35] <dalek> rakudo/macros2: review: https://github.com/rakudo/rakudo/commit/ce3d4acb19

[16:37] <felher> hihi :0

[16:37] <felher> * :)

[16:38] <tadzik> masak: why did you remove { $*DECLARATOR_DOCS := '' }?

[16:38] <dalek> roast: 4bb04af | masak++ | S06-macros/macros-d1.t:

[16:38] <dalek> roast: [S06-macros/macros-d1.t] new test file

[16:38] <dalek> roast: 

[16:38] <dalek> roast: Tests the various forms of defining and calling macros. No

[16:38] <dalek> roast: real variable interaction yet, except between the macro body

[16:38] <dalek> roast: and the outside.

[16:38] <dalek> roast: review: https://github.com/perl6/roast/commit/4bb04af91d

[16:39] <masak> tadzik: 'cus I didn't see it routine_def...

[16:39] <tadzik> huh

[16:39] <masak> tadzik: I just copied things over as I saw them.

[16:39] <masak> ok, review welcome on that test file.

[16:39] <masak> it's perhaps worth pointing out that all of those 6 tests pass on the macros2 branch.

[16:40] <tadzik> well, if podtest passes that's fine with me :)

[16:40] *** raiph left
[16:41] <masak> tadzik: running podtest.

[16:41] <jnthn> masak: Need that test still be skipped?

[16:41] <dalek> roast: 83fb76d | masak++ | S06-macros/macros-d1.t:

[16:41] <dalek> roast: [S06-macros/macros-d1.t] oops, removed old 'skip'

[16:41] <dalek> roast: review: https://github.com/perl6/roast/commit/83fb76d0b7

[16:41] <jnthn> That was quick :P

[16:41] <masak> jnthn: :P

[16:41] * masak .oO( bet that masak guy codes when he's asleep, too... )

[16:44] <masak> tadzik: 'make podtest' passes in the macros2 branch.

[16:47] <tadzik> fine then :)

[16:47] <tadzik> is there anything like &sub_name.WHY related to macros, is it even possible?

[16:48] *** kaleem joined
[16:52] <moritz> ĸi  m., m......………………

[16:52] <masak> shouldn't be any different from a regular sub.

[16:52] <masak> moritz: hi Ronja!

[16:53] *** moritz is now known as ronja

[16:53] <masak> :P

[16:53] <ronja> he de!

[16:53] *** ronja is now known as moritz

[16:57] <bbkr> rakudo: class A { has $.x = 1; has $.y = $.x; }; class B is A { has $.x = 2; }; B.new.x.say # one should expect "2". however assignment to $.y in parent class broke it somehow.

[16:57] <p6eval> rakudo 6eae67: OUTPUT«Any()␤»

[16:58] <bbkr> without assignment it works

[16:58] <bbkr> rakudo: class A { has $.x = 1; }; class B is A { has $.x = 2; }; B.new.x.say

[16:58] <p6eval> rakudo 6eae67: OUTPUT«2␤»

[16:58] <jnthn> bbkr: $.x is *virtual*.

[16:58] <jnthn> bbkr: And attributes are initialized top-down.

[16:59] <jnthn> oh but...hm

[16:59] <timotimo> rakudo: sub postfix:<yourmom>(Str $a) { "$a is sooooooooo fat" }; say "Mrs. Foo" yourmom;

[16:59] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤Confused at line 1, near "say \"Mrs. "␤»

[16:59] * jnthn gets curious about what is going onthere

[16:59] <timotimo> how do i properly do this?

[16:59] <jnthn> timotimo: You're not allowed space before a postfix :P

[17:00] <timotimo> rakudo: sub postfix:<yourmom>(Str $a) { "$a is sooooooooo fat" }; say "Mrs. Foo"yourmom;

[17:00] <p6eval> rakudo 6eae67: OUTPUT«Mrs. Foo is sooooooooo fat␤»

[17:00] <timotimo> that's excellent!

[17:00] <jnthn> So was your mom!

[17:00] <timotimo> :)

[17:00] <moritz> rakudo: sub postfix:<yourmom>(Str $a) { "$a is sooooooooo  fat" }; say "Mrs. Foo"\yourmom;

[17:00] <p6eval> rakudo 6eae67: OUTPUT«Mrs. Foo is sooooooooo  fat␤»

[17:00] <bbkr> jnthn: should I report a bug with this one?

[17:00] <moritz> that also works

[17:01] <jnthn> bbkr: I think I know what's going on.

[17:01] <moritz> for example if you want to call postfix:<i> (imaginary number) on a variable, you have to write $x\i

[17:01] <timotimo> ah, i see

[17:01] <TimToady> or ($x)i

[17:01] <moritz> because $xi would parse the variable with identifier xi

[17:01] <jnthn> bbkr: The short answer is that you should be using has $.y = $!x;

[17:01] <TimToady> in any case, $x.i is something else

[17:01] <timotimo> does the \ serve other purposes other than separate things where no space would be allowed?

[17:02] <TimToady> sure, \t is still a tab :)

[17:02] <moritz> nom: say 'foo'.\    uc

[17:02] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Confused at line 1, near "say 'foo'."␤»

[17:02] <timotimo> of course

[17:02] <moritz> nom: say 'foo'\    .uc

[17:02] <p6eval> nom 6eae67: OUTPUT«FOO␤»

[17:02] <moritz> useful if you want line breaks or vertical alignment

[17:02] * TimToady is thinking about allowing an X. infix

[17:02] <jnthn> bbkr: The long answer is that your $.x call is virtual so it touches an attribute in the subclass, which we didn't initialize yet. Touching it results in a kind of auto-vivification. Then, when we get to applying the defaults, we see the attribute $!x in the subclass was already touched so don't re-initialize it.

[17:02] <timotimo> oh, you can put an arbitrary amount of whitespace there?

[17:02] <timotimo> neat.

[17:03] <moritz> we call that "unspace"

[17:03] <TimToady> \ as a hide newline falls neatly out of it too

[17:03] <jnthn> bbkr: I don't actually consider it a bug BUT the fact we let you write $.x there and not at least warn is a bug.

[17:03] <moritz> jnthn: I thought reading should never result in autoviv

[17:03] <moritz> not even here, I'd say

[17:04] <jnthn> moritz: It's not vivification per se.

[17:04] <jnthn> moritz: It's that the REPR lazily generates the scalar container.

[17:04] <jnthn> moritz: Touching $!x forces it to do so. The fact it's done so makes it consider the attribute "touched" and thus it won't get initialized.

[17:04] <TimToady> std: class A { submethod BUILD () { $.a }}

[17:04] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Virtual call $.a may not be used on partially constructed object at /tmp/xfSlMIimAD line 1:␤------> class A { submethod BUILD () { ⏏$.a }}␤Check failed␤FAILED 00:01 110m␤»

[17:05] <TimToady> perl6: class A { submethod BUILD () { $.a }}

[17:05] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤Virtual call $.a may not be used on partially constructed object at /tmp/Y3yO4g5tep line 1:␤------> class A { submethod BUILD () { ⏏$.a }}␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot…

[17:05] <p6eval> ..pugs b927740, rakudo 6eae67:  ( no output )

[17:05] <dalek> star: 6f77dda | pmichaud++ | skel/tools/lib/NQP/Configure.pm:

[17:05] <dalek> star: Copy NQP::Configure library from nqp repo.

[17:05] <dalek> star: review: https://github.com/rakudo/star/commit/6f77dda4d3

[17:05] <dalek> star: e798a04 | pmichaud++ | Makefile:

[17:05] <dalek> star: Some minor Makefile updates.

[17:05] <dalek> star: review: https://github.com/rakudo/star/commit/e798a04353

[17:05] <dalek> star: 7c94ff3 | pmichaud++ | skel/Configure.pl:

[17:05] <dalek> star: Initial re-write of Configure.pl (based on Rakudo's Configure.pl, with new options for --gen-nqp and --gen-parrot.)

[17:05] <dalek> star: review: https://github.com/rakudo/star/commit/7c94ff394f

[17:05] <pmichaud> that's a partial update of star's configure subsystem; I need lunch here and will finish it up when I get back.

[17:05] <TimToady> initializers should also prohibit virtual calls, I suspect

[17:05] <jnthn> TimToady: Same

[17:05] <PerlJam> bbkr: it's part of that assignment isn't assignment things that you get with = on declarations

[17:05] <timotimo> is infix:< \> > the right way to redeclare the > operator?

[17:06] <jnthn> std: class C { has $.x; has $.y = $!x; }

[17:06] <p6eval> std 47c76b3: OUTPUT«ok 00:01 109m␤»

[17:06] <TimToady> infix:«>» should work

[17:06] <TimToady> or infix:['>']

[17:06] <jnthn> TimToady: Before, ^^ was busted in STD, I think.

[17:06] <timotimo> cool :)

[17:06] <jnthn> std: class C { has $.x; has $.y = $.x; }

[17:06] <PerlJam> std:  my $\   x;

[17:06] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Virtual call $.x may not be used on partially constructed object at /tmp/OL8na0lAYT line 1:␤------> class C { has $.x; has $.y = ⏏$.x; }␤Check failed␤FAILED 00:01 109m␤»

[17:06] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Unsupported use of $\ variable; in Perl 6 please use the filehandle's :ors attribute at /tmp/n7eR2OQbik line 1:␤------> my $\⏏   x;␤Parse failed␤FAILED 00:01 108m␤»

[17:06] <PerlJam> std: my \\   x;

[17:07] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Malformed my at /tmp/e0xtnu_lFv line 1:␤------> my ⏏\\   x;␤    expecting any of:␤        scoped declarator␤      statement end␤  statement list␤Parse failed␤FAILED 00:01 107m␤»

[17:07] <jnthn> TimToady: Guess it got fixed in the initializer changes \o/

[17:07] <jnthn> TimToady: That solves my last blocker to nabbing the partial invocant stuff from STD.

[17:07] <dalek> roast: 5805a6f | moritz++ | integration/error-reporting.t:

[17:07] <dalek> roast: be less strict in line number matching

[17:07] <dalek> roast: review: https://github.com/perl6/roast/commit/5805a6ff03

[17:07] <bbkr> jnthn: thanks for detailed explanation, i'm confused now if I should report lack of warning bug since STD says this construct is OK

[17:07] <TimToady> unspace is only really allowed where a space might make a syntactic difference

[17:08] <jnthn> bbkr: We should complain about the code you wrote at compile time.

[17:08] <jnthn> bbkr: So please do file a ticket on that.

[17:08] <timotimo> rakudo: sub infix:['>($a){}']($a, $b) { say "$a and then something weird and $b" }; 99 >($a){} 100; 

[17:08] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "){} 100;"␤»

[17:08] <timotimo> i demand this to work!

[17:08] <timotimo> :))

[17:08] <TimToady> we can't check for unspace everywhere someone might crazily insert one

[17:08] <PerlJam> TimToady: I was just fishing for unintended consequences.

[17:08] <jnthn> timotimo: Feel free to file a Rakudo bug on that not working. :)

[17:09] <TimToady> and the spaceless unspace certainly only works at the postfix position, I think

[17:09] <PerlJam> (easier to empirically test than to look at the code to figure out what's what :)

[17:09] <moritz> rakudo: sub infix:«>($a){}>($a, $b) { say "$a and then something weird and $b" }; 99 >($a){} 100; 

[17:09] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "){}>($a, $"␤»

[17:09] <timotimo> didn't you forget to use »?

[17:09] <moritz> not enough LTM I guess

[17:09] <jnthn> moritz: Er, mis-matched «

[17:09] <moritz> erm, yes

[17:10] <moritz> not enough moritz brain :-)

[17:10] <moritz> rakudo: sub infix:«>($a){}»($a, $b) { say "$a and then something weird and $b" }; 99 >($a){} 100; 

[17:10] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤:w list must have a value known at compile time at line 1, near "($a, $b) {"␤»

[17:10] <timotimo> whu?

[17:10] <jnthn> ...heh, it tried to do interpolation? :)

[17:10] <moritz> timotimo: it tries to interpolate the $a

[17:10] <timotimo> that's amusing

[17:10] <moritz> rakudo: sub infix:«>(\$a){}»($a, $b) { say "$a and then something weird and $b" }; 99 >($a){} 100; 

[17:10] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤:w list must have a value known at compile time at line 1, near "($a, $b) {"␤»

[17:10] <moritz> aye

[17:11] <jnthn> And (quite correctly) whines that it doesn't know the value

[17:11] <moritz> well no

[17:11] <jnthn> moritz: The {} will be interpolated too :)

[17:11] <moritz> it should first complain that $a isn't declared, no? :-)

[17:11] <moritz> rakudo: sub infix:«>(\$a)\{}»($a, $b) { say "$a and then something weird and $b" }; 99 >($a){} 100; 

[17:11] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "){} 100;"␤»

[17:11] <moritz> bah, what a weird language... :-)

[17:13] <[Coke]> .u |

[17:13] <phenny> U+007C VERTICAL LINE (|)

[17:13] <[Coke]> .u '

[17:13] <phenny> U+0027 APOSTROPHE (')

[17:13] <timotimo> rakudo: sub infix:«>\»']»($a, $b) { say "$a, a fish and $b" }; "rakudo" >»'] "niecza";

[17:13] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤Confused at line 1, near "\"rakudo\" >"␤»

[17:14] <TimToady> std: sub infix:«>\»']»($a, $b) { say "$a, a fish and $b" }; "rakudo" >»'] "niecza";

[17:14] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Bogus term at /tmp/1vILsRfrru line 1:␤------>  { say "$a, a fish and $b" }; "rakudo" >⏏»'] "niecza";␤Parse failed␤FAILED 00:01 115m␤»

[17:15] <TimToady> hmm

[17:16] <TimToady> std: sub infix:«>O']»($a, $b) { say "$a, a fish and $b" }; "rakudo" >O'] "niecza";

[17:16] <p6eval> std 47c76b3: OUTPUT«ok 00:01 114m␤»

[17:17] <TimToady> something going wonky with the unicode maybe

[17:18] <timotimo> std: sub infix:«>☃']»($a, $b) { say "$a, a snowman and $b" }; "rakudo" >☃'] "niecza";

[17:18] <p6eval> std 47c76b3: OUTPUT«ok 00:01 114m␤»

[17:18] <TimToady> std: sub infix:['>»\']']($a, $b) { say "$a, a fish and $b" }; "rakudo" >»'] "niecza";

[17:18] <p6eval> std 47c76b3: OUTPUT«ok 00:01 115m␤»

[17:18] <TimToady> perl6: sub infix:['>»\']']($a, $b) { say "$a, a fish and $b" }; "rakudo" >»'] "niecza";

[17:18] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤Missing « or » at line 1, near "'] \"niecza"␤»

[17:18] <p6eval> ..niecza v13-358-g301a891: OUTPUT«rakudo, a fish and niecza␤»

[17:18] <p6eval> ..pugs b927740: OUTPUT«decodeUTF8': bad data: '\187'␤decodeUTF8': bad data: '\187'␤*** ␤    Unexpected ":['>\187\\']']($"␤    expecting "::", "handles", "is", bare trait, subroutine parameters, trait or block␤    at /tmp/ClYwbh8PZH line 1, column 10␤»

[17:19] <TimToady> niecza++

[17:19] <timotimo> awesome :)

[17:19] <TimToady> so something about parsing the :«» I guess

[17:20] <TimToady> and apparently a STD bug

[17:21] <jnthn> Rakudo simply doesn't do the infix:['...'] form yet, iirc.

[17:21] <timotimo> it doesn't?

[17:21] <TimToady> my guess is that the backslash isn't being removed from \»

[17:21] <jnthn> timotimo: oh, maybe it does'''

[17:22] *** Radvendii joined
[17:22] <TimToady> std: sub infix:«>\»']»($a, $b) { say "$a, a fish and $b" }; "rakudo" >\»'] "niecza";

[17:22] <p6eval> std 47c76b3: OUTPUT«ok 00:01 114m␤»

[17:22] <timotimo> rakudo: sub infix:['aha']($a, $b) { say "$a, mhm, aha, oh yes, $b!" }; "foo" aha "bar";

[17:22] <p6eval> rakudo 6eae67: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&aha' called (line 1)␤»

[17:22] <jnthn> nom: sub infix:['abc']($a, $b) { say 'lol' }; 1 abc 2

[17:22] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix  instead at line 1, near ""␤»

[17:22] <TimToady> yes, it's not removing the backslash

[17:22] <Radvendii> o/

[17:22] <jnthn> nom: sub infix:<abc>($a, $b) { say 'lol' }; 1 abc 2

[17:22] <p6eval> nom 6eae67: OUTPUT«lol␤»

[17:22] <TimToady> how can the grammar be trying to call a routine 'aha' that is in the infix position?

[17:24] <TimToady> nom: sub infix:['abc']($a, $b) { say 'lol' }; infix 1 2

[17:24] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix  instead at line 1, near ""␤»

[17:25] <TimToady> nom: sub infix:['abc']($a, $b) { say 'lol' }; infix 1, 2

[17:25] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix  instead at line 1, near ""␤»

[17:25] <TimToady> nom: sub infix :['abc'] ($a, $b) { say 'lol' }; infix 1, 2

[17:25] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Malformed block at line 1, near "($a, $b) {"␤»

[17:25] <jnthn> TimToady: Oh heh. I bet it's declaring an infix:<>, which matches the empty string

[17:25] <jnthn> TimToady: Therefore, it's considered a valid infix everywhere. :)

[17:25] <timotimo> oooooooh, that's terrible :))

[17:26] <TimToady> I was wondering if it was parsing the :[] as a trait, but apparently not

[17:26] <jnthn> timotimo: So it parses 1 <empty infix> aha <empty infix> 2 :)

[17:26] <jnthn> er, TimToady 

[17:26] <jnthn> ...why i no can tab complete today?

[17:26] <timotimo> apologies for nick-colliding

[17:26] <TimToady> I could rename myself to TMTOWTDI

[17:27] <jnthn> I could look at what I'm about to send too :)

[17:27] <TimToady> you have more of an excuse not to than most of us :)

[17:30] <timotimo> obviously, my contribution today will turn perl6 into a better language

[17:31] <TimToady> just don't suggest dropping the semicolons :)

[17:31] <timotimo> can i define a postfix:<;>? ;)

[17:32] <timotimo> sub postfix:[';']($a) { say "$a and a semicolon"; } <- this is an infinite recursion then?

[17:32] <TimToady> likely

[17:32] <Radvendii> try with a space before the ;

[17:33] <TimToady> niecza: sub postfix:[';']($a) { say "$a and a semicolon"; }

[17:33] <p6eval> niecza v13-358-g301a891: OUTPUT«Potential difficulties:␤  &postfix:<;> is declared but not used at /tmp/HwYPhBkEZC line 1:␤------> sub postfix:[';']⏏($a) { say "$a and a semicolon"; }␤␤»

[17:33] <TimToady> hmm

[17:33] <TimToady> didn't timeout

[17:33] <Radvendii> nom: sub postfix:[';']($a) { say "$a and a semicolon" ; }; "foo";

[17:33] <p6eval> nom 6eae67: OUTPUT«(timeout)»

[17:33] <TimToady> nom doesn't do []

[17:33] <Juerd> Did foo:['bar'] use to be foo:{'bar'} before?

[17:33] <timotimo> rakudo: sub postfix:[';']($a) { say "$a and a semicolon" }

[17:33] <timotimo> this timeouts for me locally - why?

[17:34] <p6eval> rakudo 6eae67: OUTPUT«(timeout)»

[17:34] <Radvendii> nom: sub postfix:<;>($a) { say "$a and a semicolon" ; } ; "foo";

[17:34] <p6eval> nom 6eae67: OUTPUT«foo and a semicolon␤»

[17:34] <Radvendii> bam

[17:34] <Radvendii> you just have to put a space before the ';' that ends a statement

[17:35] <Radvendii> timotimo: wait... you didn't have a ';' to end any statements...

[17:35] <jnthn> timotimo: It's all related to the postfix:['...'] form not working.

[17:35] <timotimo> interesting, with <;> it works, with [';'] it doesn't

[17:35] <timotimo> probably, yes

[17:35] <Radvendii> oh

[17:35] <Radvendii> jnthn: what do the specs say it should look like? <op> or ['op']?

[17:36] <jnthn> Radvendii: Both should work.

[17:36] <jnthn> (iirc)

[17:36] <TimToady> niecza: sub postfix:[';']($a) { say "$a and a semicolon"; }; "foo";

[17:36] <p6eval> niecza v13-358-g301a891: OUTPUT«Potential difficulties:␤  &postfix:<;> is declared but not used at /tmp/zpXh9c4_2q line 1:␤------> sub postfix:[';']⏏($a) { say "$a and a semicolon"; }; "foo␤␤»

[17:37] <TimToady> niecza is probably special casing the terminators liek ;

[17:37] <TimToady> *like

[17:37] <TimToady> niecza: sub postfix:[';']($a) { say "$a and a semicolon"; }; "foo"\;

[17:37] <p6eval> niecza v13-358-g301a891: OUTPUT«foo and a semicolon␤»

[17:37] <TimToady> hah

[17:37] <Radvendii> nice

[17:37] <TimToady> niecza: sub postfix:[';']($a) { say "$a and a semicolon"; }; "foo".;

[17:38] <p6eval> niecza v13-358-g301a891: OUTPUT«foo and a semicolon␤»

[17:38] <Radvendii> nom: say (a => "foo").WHAT

[17:38] <p6eval> nom 6eae67: OUTPUT«Pair()␤»

[17:38] <Radvendii> what happened to => just quoting the other side...

[17:38] <Radvendii> oh

[17:38] <Radvendii> i guess this allows you to do named arguments...

[17:39] <TimToady> if it didn't quote the a it would complain about starting a term with =>

[17:39] <TimToady> since a would be a listop

[17:40] <Radvendii> nono, i thought it _just_ quoted the a. not making a "pair()"

[17:40] <TimToady> => always makes a Pair

[17:40] <Radvendii> nom: .say for (a => "foo")

[17:40] <p6eval> nom 6eae67: OUTPUT«"a" => "foo"␤»

[17:41] <Radvendii> i expected that to print out "a"\n"foo"

[17:41] <Radvendii> i realize that that is wrong now

[17:41] <TimToady> why?  This isn't Perl 5, and => isn't a fat comma

[17:41] <dalek> nqp/bs: cec284e | jnthn++ | t/serialization/01-basic.t:

[17:41] <dalek> nqp/bs: Add a test for P6opaque serialization when attributes are natives.

[17:41] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/cec284e735

[17:41] <dalek> nqp/bs: 29fdcd0 | jnthn++ | src/6model/serialization. (2 files):

[17:41] <dalek> nqp/bs: Start to stub in reference serialization.

[17:41] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/29fdcd0de3

[17:41] <dalek> nqp/bs: 7c1c75a | jnthn++ | src/6model/reprs/P6opaque.c:

[17:41] <dalek> nqp/bs: Fill out P6opaque's serialize and deserialize.

[17:41] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7c1c75a5fd

[17:41] <dalek> nqp/bs: 0839038 | jnthn++ | t/serialization/01-basic.t:

[17:41] <dalek> nqp/bs: Fix P6opaque with native attrs tests.

[17:41] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/0839038a5d

[17:41] <timotimo> => doesn't make a pair if i override the infix:«=>» operator inappropriately :))

[17:41] * TimToady always lies, except when he doesn't

[17:43] <Radvendii> TimToady: right. i was still thinking in perl5, time to go hit my head against a wall again, :P

[17:44] <timotimo> does perl6 offer something like ruby wherein you can "open up" an already defined class and add new stuff?

[17:44] <bbkr> timotimo: yes, MONKEY_TYPING

[17:44] <TimToady> if you say "use MONKEY_TYPING;" and then use "augment"

[17:44] <PerlJam> Radvendii: It's okay if you let Perl 5 be your default assumption about how Perl 6 works, as long as you are flexible in adjusting that immediately  :)

[17:44] <timotimo> oh god, how terrible :)

[17:44] <PerlJam> timotimo: exactly!

[17:44] <TimToady> indeed

[17:44] <TimToady> an idea straight out of Ada

[17:45] <TimToady> "with UNCHECKED_TYPE_CONVERSION"

[17:45] <Radvendii> TimToady: i still like MONKEY_TYPING better. :P it's got a perl6 zing to it

[17:46] <TimToady> well, the Ada declaration was for unsafe conversions, not monkey typing

[17:46] <bbkr> timotimo: class A {}; use MONKEY_TYPING; augment class A { method foo { say "banana"}}; A.foo

[17:46] <TimToady> we used to call it monkey patching like everyone else, but monkey typing is funnier

[17:46] <PerlJam> FAQ:  I always expect to get the works of Shakespeare when I use MONKEY_TYPING, is there something less confusing?

[17:46] <bbkr> timotimo: where A{}is somethong you got from somewhere

[17:46] <TimToady> and it is, in fact, changing the type

[17:46] <timotimo> when does perl6 get A_THOUSAND_MONKEYS_TYPING?

[17:47] <TimToady> now that's an idea

[17:47] <PerlJam> timotimo: whenever it is needed.

[17:47] <Radvendii> but in all seriousness, you've gotta use "augment" anyways, why require people to use MONKEY_TYPING?

[17:47] <TimToady> to punish them for it

[17:48] <PerlJam> Radvendii: To *really* discourage people from doing it.

[17:48] <TimToady> and to put something right up at the front that their boss can see

[17:48] <Radvendii> :Þ why?

[17:48] <PerlJam> Radvendii: it's destructive enough that they should have to think at least tqice before doing it.

[17:48] <bbkr> Radvendii: to distinguish hacks and experiments from production code

[17:48] <PerlJam> er, twice

[17:49] <Radvendii> i guess...

[17:49] <Radvendii> but no thinking twice before overloading ';' eh?

[17:49] <Radvendii> :P

[17:49] <TimToady> monkeys don't usually think of that

[17:50] <TimToady> and there's not a major language *cough* like Ruby *cough* that does that

[17:50] <PerlJam> Radvendii: ruby has made monkey patching a way of life, so there's a whole slew of programmers ready to do it.  How many programmers do you know who think to overload .... blah TimToady types too fast

[17:51] <Radvendii> mhmm...

[17:51] * PerlJam idly wonders if "*cough*like Ruby*cough*" is an allomorph of tmesis

[17:52] <timotimo> prefix:<{> is also a nice sub to define

[17:52] <Radvendii> nom: my $a = "foo"; <a b c>.map: {say $a; say $^a}

[17:52] <p6eval> nom 6eae67:  ( no output )

[17:52] <Radvendii> timotimo: not at all!

[17:52] <PerlJam> I guess so

[17:52] <Radvendii> nom: my $a = "foo"; eager <a b c>.map: {say $a; say $^a}

[17:52] <p6eval> nom 6eae67: OUTPUT«a␤a␤b␤b␤c␤c␤»

[17:53] <Radvendii> yeah, i know why that's happening, but it's a little confusing. i guess i should be using longer names than "$a"

[17:53] <Radvendii> maybe the compiler should test that the $^a is the first reference to $a in a block

[17:53] <TimToady> std: my $a = "foo"; eager <a b c>.map: {say $a; say $^a}

[17:53] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤$a has already been used as a non-placeholder in the surrounding block,␤  so you will confuse the reader if you suddenly declare $^a here at /tmp/l1iVtelRJ_ line 1:␤------>  "foo"; eager <a b c>.map: {say $a; say ⏏$^a}[0…

[17:53] <TimToady> maybe it should :P

[17:53] <Radvendii> hahahahaha

[17:53] <Radvendii> touché

[17:54] <TimToady> that's one of my favorite messages

[17:54] <Radvendii> i thought niecza was being silly for complaining like that

[17:55] <Radvendii> but apparently it's in the specs

[17:56] *** face1 joined
[17:58] <face1> nom: my @a = 1..3; my @b = 4..6; (@a Z @b).map: { say $^a,$^b}

[17:58] <p6eval> nom 6eae67:  ( no output )

[17:59] <Radvendii> nom: my @a = 1..3; my @b = 4..6; eager (@a Z @b).map: { say $^a,$^b}

[17:59] <p6eval> nom 6eae67: OUTPUT«14␤25␤36␤»

[17:59] <Radvendii> face1: .map is lazy

[17:59] <face1> thanks!

[17:59] <Radvendii> np

[18:00] <Radvendii> np

[18:00] <Radvendii> agh!

[18:00] <Radvendii> i keep doing that

[18:03] *** face1 left
[18:06] *** cognominal left
[18:06] *** cognominal joined
[18:07] <TimToady> std: my $a = "foo"; eager <a b c>.map: {say $a; my $a = 42; }

[18:07] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Lexical symbol '$a' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as OUTER::<$a>␤  before you can unambiguously declare a new '$a' in this scope at /tmp/L162wxLG6f line 1:␤---…

[18:07] <TimToady> it's really the same category as that error

[18:08] <TimToady> std: my $a = "foo"; eager <a b c>.map: {say OUTER:<$a>; say $^a}

[18:08] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Undeclared name:␤    'OUTER:<$a>' used at line 1␤Check failed␤FAILED 00:01 111m␤»

[18:08] <TimToady> std: my $a = "foo"; eager <a b c>.map: {say OUTER::<$a>; say $^a}

[18:08] <p6eval> std 47c76b3: OUTPUT«ok 00:01 111m␤»

[18:08] <TimToady> niecza: my $a = "foo"; eager <a b c>.map: {say OUTER::<$a>; say $^a}

[18:08] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤$a has already been used as a non-placeholder in the surrounding block,␤  so you will confuse the reader if you suddenly declare $^a here at /tmp/XLl6jl2tXv line 1:␤------> ager <a b c>.map: {say OUTER::<$a>; say …

[18:09] <Radvendii> i think it's resonable not to allow it

[18:09] <TimToady> but the OUTER should fix that message

[18:09] <TimToady> niecza: my $a = "foo"; eager <a b c>.map: {say $^a}

[18:09] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤$a has already been used as a non-placeholder in the surrounding block,␤  so you will confuse the reader if you suddenly declare $^a here at /tmp/VSS2cDSuY4 line 1:␤------> my $a = "foo"; eager <a b c>.map: {say ⏏…

[18:09] <TimToady> hmm, it just doesn't like the shadowing

[18:10] <TimToady> niecza: my $a = "foo"; eager <a b c>.map: -> $a {say $a}

[18:10] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤Undeclared routine:␤    'eager' used at line 1␤␤Potential difficulties:␤  $a is declared but not used at /tmp/Vo7nTPBA6D line 1:␤------> my ⏏$a = "foo"; eager <a b c>.map: -> $a {sa␤␤Unhandled exception: Che…

[18:10] <TimToady> I find it difficult to believe that niecza has made it this far without eager

[18:11] <TimToady> I guess the fact that list assignment is eager hides the lack

[18:16] <TimToady> niecza: sub eager (|lst) { my @ = lst }; eager <a b c>.map: {say $_}

[18:16] <p6eval> niecza v13-358-g301a891: OUTPUT«a␤b␤c␤»

[18:16] <TimToady> and eager is so hard to implement :P

[18:17] <TimToady> niecza: sub eager (|lst) { my @ = lst }; my $foo = eager <a b c>.map: {$_}; say $foo.WHAT

[18:17] <p6eval> niecza v13-358-g301a891: OUTPUT«Array()␤»

[18:17] <TimToady> well, I guess that's not quite right

[18:17] <[Coke]> TimToady: it's clearly not impacting our ability to run spec tests. ;)

[18:18] <TimToady> erm

[18:19] <Radvendii> TimToady: i don't get that syntax, the (|lst) and the bare sigil...

[18:19] <TimToady> niecza: sub eager (|lst) { my \ = lst }; my $foo = eager <a b c>.map: {$_}; say $foo.WHAT

[18:19] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤Malformed my at /tmp/SZN12NCA0a line 1:␤------> sub eager (|lst) { my⏏ \ = lst }; my $foo = eager <a b c>.map:␤␤Parse failed␤␤»

[18:19] <TimToady> niecza: sub eager (|lst) { my (|) = lst }; my $foo = eager <a b c>.map: {$_}; say $foo.WHAT

[18:19] <p6eval> niecza v13-358-g301a891: OUTPUT«Parcel()␤»

[18:19] <TimToady> that's better

[18:20] <TimToady> you can always use a bare sigil to declare something anonymous

[18:20] <Radvendii> woah

[18:20] <Radvendii> and | is a sigil?

[18:21] <TimToady> not really...for the others, see S06:1140

[18:21] <TimToady> it's more like the * in a slurpy parameter

[18:21] <Radvendii> oh

[18:22] <TimToady> but it can also be used anonymously, which is something we just fixed a couple days ago

[18:23] <TimToady> niecza: sub eager (|lst) { my (|) = lst }; eager <a b c>.map: *.say

[18:23] <p6eval> niecza v13-358-g301a891: OUTPUT«a␤b␤c␤»

[18:23] <TimToady> niecza: sub eager (|lst) { my (|) = lst }; <a b c>.map: *.say

[18:23] <p6eval> niecza v13-358-g301a891: OUTPUT«Potential difficulties:␤  &eager is declared but not used at /tmp/njV6d5ITzf line 1:␤------> sub eager ⏏(|lst) { my (|) = lst }; <a b c>.map: *.␤␤a␤b␤c␤»

[18:23] <TimToady> niecza: sub eager (|lst) { my (|) = lst }; gather <a b c>.map: *.say

[18:23] <p6eval> niecza v13-358-g301a891: OUTPUT«Potential difficulties:␤  &eager is declared but not used at /tmp/ygskLXTCNP line 1:␤------> sub eager ⏏(|lst) { my (|) = lst }; gather <a b c>.␤␤»

[18:23] <TimToady> niecza: sub eager (|lst) { my (|) = lst }; gather eager <a b c>.map: *.say

[18:24] <p6eval> niecza v13-358-g301a891:  ( no output )

[18:24] <TimToady> hmm that should have output if eager is being...eager...

[18:25] <TimToady> I guess assignment to a sig turned it into more of a binding

[18:25] <TimToady> niecza: sub eager (|lst) { return |my @ = lst }; gather eager <a b c>.map: *.say

[18:25] <p6eval> niecza v13-358-g301a891:  ( no output )

[18:25] <TimToady> niecza: sub eager (|lst) { my @ = lst }; gather eager <a b c>.map: *.say

[18:25] <p6eval> niecza v13-358-g301a891:  ( no output )

[18:26] <TimToady> that should work

[18:26] <TimToady> sorear: ^^

[18:27] <TimToady> niecza: sub eager (|lst) { my @ = |lst }; gather eager <a b c>.map: *.say

[18:27] <p6eval> niecza v13-358-g301a891:  ( no output )

[18:27] *** PacoAir left
[18:27] *** c1sung left
[18:27] *** zamolxes left
[18:27] *** slavik left
[18:27] *** cxreg left
[18:27] *** Yappoko___ left
[18:27] *** sirhc left
[18:27] *** tokuhirom3 left
[18:28] *** zamolxes joined
[18:28] *** cxreg joined
[18:28] *** sirhc joined
[18:28] *** sirhc left
[18:28] *** sirhc joined
[18:28] *** c1sung joined
[18:28] *** Yappoko___ joined
[18:28] *** tokuhirom3 joined
[18:28] <TimToady> niecza: sub eager (|lst) { my @x = |lst; say @x; @x }; gather eager <a b c>.map: *.say

[18:28] <p6eval> niecza v13-358-g301a891:  ( no output )

[18:28] *** slavik joined
[18:29] <TimToady> niecza: sub eager (|lst) { my @x = lst; say @x; @x }; gather eager <a b c>.map: *.say

[18:29] <p6eval> niecza v13-358-g301a891:  ( no output )

[18:29] <TimToady> niecza: sub eager (|@lst) { my @x = @lst; say @x; @x }; gather eager <a b c>.map: *.say

[18:29] <p6eval> niecza v13-358-g301a891: OUTPUT«Potential difficulties:␤  Unsupported use of | with sigil; nowadays please use | without sigil at /tmp/vQjYPw805H line 1:␤------> sub eager (|@lst⏏) { my @x = @lst; say @x; @x }; gather e␤␤»

[18:30] <TimToady> nom: sub eager (|@lst) { my @x = @lst; say @x; @x }; gather eager <a b c>.map: *.say

[18:30] <p6eval> nom 6eae67:  ( no output )

[18:31] <TimToady> nom: sub eager (|@lst) { my @x = @lst; say @x; @x }; (gather eager <a b c>.map: *.say)[0]

[18:31] <p6eval> nom 6eae67: OUTPUT«Nominal type check failed for parameter '@lst'; expected Positional but got Capture instead␤  in sub eager at /tmp/gd9RHVUKOI:1␤  in code <anon> at /tmp/gd9RHVUKOI:1␤  in sub coro at src/gen/CORE.setting:4621␤  in method reify at src/gen/CORE.setting:4596␤  in method …

[18:31] <TimToady> niecza: sub eager (|lst) { my @x = lst; say @x; @x }; (gather eager <a b c>.map: *.say)[0]

[18:31] <p6eval> niecza v13-358-g301a891: OUTPUT«a␤b␤c␤\((Bool::True, Bool::True, Bool::True).list)␤»

[18:31] <dalek> nqp/bs: 516fc77 | jnthn++ | t/serialization/01-basic.t:

[18:31] <dalek> nqp/bs: Sketch out a test for serializing circular references between objects.

[18:31] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/516fc77832

[18:31] <dalek> nqp/bs: f29733c | jnthn++ | t/serialization/01-basic.t:

[18:31] <dalek> nqp/bs: Use the official op for adding things to an SC.

[18:31] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/f29733cf1b

[18:31] <dalek> nqp/bs: ecb463b | jnthn++ | src/6model/serialization (3 files):

[18:31] <dalek> nqp/bs: Implement serialization of references to other objects, which makes a cross-reference to another SC if needed, or if the object is in no SC adds it to ours and puts it onto the serialization worklist. Test for circular reference serialization now passes.

[18:31] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/ecb463b66b

[18:32] <TimToady> okay, that seems to have worked

[18:32] <TimToady> niecza: sub eager (|lst) { my (|) = lst; }; (gather eager <a b c>.map: *.say)[0]

[18:32] <p6eval> niecza v13-358-g301a891: OUTPUT«a␤b␤c␤»

[18:33] <TimToady> \o/

[18:33] <TimToady> niecza: sub eager (|lst) { my (|) = lst; }; (gather say eager <a b c>.map: *.say)[0]

[18:33] <p6eval> niecza v13-358-g301a891: OUTPUT«a␤b␤c␤\((Bool::True, Bool::True, Bool::True).list)␤»

[18:36] <TimToady> sorear: ^^ I think is a correct(-ish) implementation of eager :)

[18:38] <TimToady> niecza: sub sink (|lst) { my (|) = lst; return; }; (gather sink <a b c>.map: *.say)[0]

[18:38] <p6eval> niecza v13-358-g301a891: OUTPUT«===SORRY!===␤␤Action method statement_prefix:sink not yet implemented at /tmp/QsFVYs3KP8 line 1:␤------> turn; }; (gather sink <a b c>.map: *.say⏏)[0]␤␤Unhandled exception: Unable to resolve method statement_level in c…

[18:39] <TimToady> heh

[18:39] <TimToady> niecza: sub sink (|lst) { my (|) = lst; return; }; (gather sink(<a b c>.map: *.say))[0]

[18:40] <p6eval> niecza v13-358-g301a891: OUTPUT«a␤b␤c␤»

[18:41] <TimToady> niecza: sub sink (|lst) { my (|) = lst; return; }; my $x := sink(<a b c>.map: *.say);

[18:41] <p6eval> niecza v13-358-g301a891: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/XDkgjEn62E line 1:␤------> nk (|lst) { my (|) = lst; return; }; my ⏏$x := sink(<a b c>.map: *.say);␤␤a␤b␤c␤»

[18:41] <TimToady> \o/

[18:42] <Radvendii> what does sink do?

[18:42] <Radvendii> never mind

[18:43] <colomon> TimToady: are there spectests for eager?

[18:44] <TimToady> a few

[18:44] <[Coke]> more unicode: http://www.unicode.org/versions/Unicode6.1.0/

[18:45] <dalek> nqp/bs: 11ac086 | jnthn++ | t/serialization/01-basic.t:

[18:45] <dalek> nqp/bs: A test for multi-level tracing of the object graph during serialization; passes.

[18:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/11ac086f0a

[18:46] <Radvendii> never mind

[18:46] <Radvendii> aaaagh

[18:54] <Radvendii> nom: say -1 < [&](0,7) < 1

[18:54] <p6eval> nom 6eae67: OUTPUT«all(Bool::True)␤»

[18:54] <Radvendii> ..?

[18:55] <Radvendii> nom: say -1 < all(0,7) < 1

[18:55] <p6eval> nom 6eae67: OUTPUT«all(Bool::True, Bool::False)␤»

[18:55] <Radvendii> nom: say -1 < ([&](0,7)) < 1

[18:55] <p6eval> nom 6eae67: OUTPUT«all(Bool::True, Bool::False)␤»

[18:55] <Radvendii> so what's happening without parens?

[18:56] <TimToady> niecza: say -1 < [&](0,7) < 1

[18:56] <p6eval> niecza v13-358-g301a891: OUTPUT«all(Bool::True, Bool::False)␤»

[18:56] <TimToady> bug, I'd say

[18:56] <sorear> good * #perl6

[18:57] <TimToady> o/

[18:57] <colomon> \o

[18:57] <Radvendii> o/

[18:58] <TimToady> nom: say all(0,7).perl

[18:58] <p6eval> nom 6eae67: OUTPUT«all(0, 7)␤»

[18:58] <TimToady> nom: say [&](0,7).perl

[18:58] <p6eval> nom 6eae67: OUTPUT«all((0, 7))␤»

[18:58] <Radvendii> i assume the extra ()s doesn't effect anything?

[18:58] <TimToady> hmm

[18:59] <TimToady> it shouldn't, but apparently it does

[18:59] <TimToady> all provides a list context, so extra parens should just flatten

[18:59] <TimToady> nom: say all((0,7)).perl

[18:59] <p6eval> nom 6eae67: OUTPUT«all(0, 7)␤»

[18:59] <TimToady> and in fact they do flatten in the actual call

[19:00] <Radvendii> [&](0,7).perl.perl

[19:00] <TimToady> but the [&] is not flattening something it should

[19:00] <Radvendii> nom: say [&](0,7).perl.perl

[19:00] <p6eval> nom 6eae67: OUTPUT«all("(0, 7)")␤»

[19:00] <colomon> Radvendii++

[19:00] <TimToady> nom: say ([&] 0,7).perl

[19:00] <p6eval> nom 6eae67: OUTPUT«all(0, 7)␤»

[19:00] <TimToady> ooh, it's keeping the extra argument parens, seemingly

[19:00] <Radvendii> thank you colomon, what for though?

[19:01] <colomon> Radvendii: coming up with an interesting variation to try

[19:01] <TimToady> our newest fuzzer :)

[19:01] <Radvendii> TimToady: so we'll just have to go all lisp with ([&] 0,7) :P

[19:02] <TimToady> the other should be equivalent, but isn't in nom

[19:02] <Radvendii> colomon: oh, thank you

[19:02] <TimToady> jnthn: ^^

[19:06] <sorear> TimToady: Chaining operators currently desugar to &&-chains, which does not do so well with junctions ...

[19:07] <sorear> TimToady: why should gather eager ... work?  Doesn't gather suppress execution of the RHS?

[19:07] <sorear> TimToady: I don't understand what my (|) = rhs is supposed to do, and I am certain Niecza does not implement it correctly

[19:08] <TimToady> that's why I added a [0] on the gather one

[19:09] <TimToady> sorear: niecza was correct on the junction, but not nom

[19:09] <Radvendii> nom: my $a=5; $a.undef; say defined $a;

[19:10] <p6eval> nom 6eae67: OUTPUT«Method 'undef' not found for invocant of class 'Int'␤  in block <anon> at /tmp/WeBSCElGHE:1␤  in <anon> at /tmp/WeBSCElGHE:1␤»

[19:10] <Radvendii> nom: my $a=5; undef $a; say defined $a;

[19:10] <p6eval> nom 6eae67: OUTPUT«===SORRY!===␤Unsupported use of undef as a verb;  in Perl 6 please use undefine function or assignment of Nil␤at /tmp/fGsCGpFSr_:1␤»

[19:10] <Radvendii> :D i love good error messages

[19:11] <jnthn> nom: [&](0,7).perl

[19:11] <p6eval> nom 6eae67:  ( no output )

[19:11] <jnthn> nom: [&](0,7).perl.say

[19:11] <p6eval> nom 6eae67: OUTPUT«(0, 7)␤»

[19:12] <jnthn> TimToady: Does the method call not bind tighter than [&]?

[19:12] <Radvendii> oh... that's right...

[19:12] <TimToady> [&]() should be a special form just like foo()

[19:13] <Radvendii> nom: say Nil

[19:13] <p6eval> nom 6eae67: OUTPUT«Nil␤»

[19:14] <jnthn> TimToady: Hm, oddness. Will have to see what STD's doing that Rakudo's grammar ain't.

[19:15] <sorear> niecza: say 0 <= any(-5,15) <= 10;

[19:15] <p6eval> niecza v13-358-g301a891: OUTPUT«any(Bool::True, Bool::False)␤»

[19:16] <TimToady> at line 3325 STD is forcing [&] to parse as a term, so () is a postfix to it, rather than [&] being a prefix

[19:17] <TimToady> sorear: right, it should not work like that

[19:18] <jnthn> TimToady: Thanks, will take a look after dinner

[19:18] <jnthn> bbi20

[19:19] <TimToady> chained operator really need to act like a function with multiple args: chain:['<=','<=']($a,$b,$c) or some such

[19:20] <TimToady> or chain([&[<=],&[<=]], $a, $b, $c)

[19:20] *** jevin joined
[19:21] <TimToady> so that it threads the N-way comparisons correctly

[19:21] <awwaiid> you gunna make a 3-op and 4-op and 5-op version of that?

[19:21] <awwaiid> oh wit

[19:21] <awwaiid> I misread

[19:21] <TimToady> well, it's slightly problematic to thread a *@foo parameter

[19:22] <awwaiid> chain is the function that takes a list of ops and a list of thigns to go between them

[19:22] <awwaiid> forget I kabitzed anything

[19:22] <TimToady> but I don't think we currently autothread slurpies, so it is potentially a real problem

[19:23] <TimToady> might have to gen such a function at need, or treat Any *@terms specially

[19:23] <sorear> I'm sure something can be done

[19:24] <TimToady> there's something vaguely macro-y about it, that wants it to pretend there's a variadic list of non-variadic parameters...

[19:25] <TimToady> I'm sure something can be hacked too, but it'd be nice if it just fell out from some other generaliztion

[19:25] <TimToady> *zat

[19:29] <TimToady> otoh, it's supposed to short-circuit, so we really need to be passing a list of thunks, which is probably harder to get the typology right on, if we're going to rely on type mismatch to dispatch junctions outside of Any

[19:30] <TimToady> 0 > any(2,3) > die "phooey"   # shouldn't die

[19:30] <TimToady> so that part of && semantics can't go away

[19:31] <TimToady> niecza: say 0 > any(2,3) > die "phooey"

[19:31] <p6eval> niecza v13-358-g301a891: OUTPUT«any(Bool::False, Bool::False)␤»

[19:34] <TimToady> another possiblity if it gets too intractable is to prohibit junctions after the 2nd term, and define chain($, $, *@ [&]) or so

[19:35] *** kaleem left
[19:35] <TimToady> chain($, $, Callable *@) is perhaps more readable

[19:36] <TimToady> oh, forgot the operator list, but you take my meaning...

[19:36] <dalek> star: 1339c15 | pmichaud++ | skel/tools/lib/NQP/Configure.pm:

[19:36] <dalek> star: Updates to enable --gen-parrot and --gen-nqp to accept directory path values.

[19:36] <dalek> star: review: https://github.com/rakudo/star/commit/1339c1502d

[19:38] * jnthn back

[19:39] <sorear> o/ jnthn, pmichaud

[19:40] <TimToady> the basic problem is that you can't know the lazy callable is going to return a junction until you call it, and then you're already past the junction threader dispatch

[19:40] <sorear> oh, hmm

[19:41] <sorear> and that makes it difficult to implement the &/| precedence rule :|

[19:42] <TimToady> maybe junctions have to transitively thunk their parts when they find themselves thunked

[19:42] <TimToady> so we know it's a junction argument, but it evaluates the junction itself lazily

[19:43] <TimToady> or just a specially marked junctive thunk

[19:49] <TimToady> basically we need to turn Thunk of Junction into Junction of Thunk for chaining, and perhaps other thunky spots

[19:50] <TimToady> gah, I've been trying to backlog all morning, and failing, and soon I will throw a lunch exception...

[19:51] * pmichaud hopes to not be around for the lunch tossing

[19:51] <TimToady> maybe I could have a tossed salad

[19:51] <pmichaud> for me, it's a toss-up

[19:52] *** PacoAir joined
[19:53] <TimToady> masak: the trouble with promoting {} to Block is that you don't know it until someone actually calls .() on it

[19:54] <TimToady> so we'd have to make Hash respond to .(), and probably succeed only if the Hash is empty

[19:54] <jnthn> TimToady: Ah, and it's line 2042 where it checks the <term> flag, if I follow correctly?

[19:54] * jnthn thinks he sees what's going on :)

[19:54] <sorear> pmichaud: I could use a high-level overview of Rakudo LoL and how it integrates with **@list, iteration, etc

[19:55] <TimToady> jnthn: yes

[19:55] *** bluescreen10 left
[19:56] *** mj41 joined
[19:57] *** birdwindupbird joined
[19:58] * sorear hopes TimToady's Lunch exception is resumable

[20:01] <TimToady> maybe {}.() should warn "{} better written as {;}" if we can pass the original line info through to the run-time

[20:02] <TimToady> or maybe it should just silently DWTM

[20:03] <TimToady> like we try to do with other allomorphic literals

[20:03] *** GlitchMr left
[20:04] <TimToady> the difference here is that {} has to be mutable

[20:06] <TimToady> and it's a bit bogus to respond to () after you've put data into it

[20:07] <TimToady> but the thing is, there are many places where {} is perfectly fine for an empty block, so we probably also need to treat it as one when binding to Callable

[20:07] <TimToady> otherwise we suddenly have the situation that built-ins are different from user-defined control structures

[20:08] *** bluescreen10 joined
[20:08] <TimToady> so maybe we just need a HashBlock of some sort that transmutes to a Hash when you put stuff in it

[20:09] <sorear> we already have that situation, the builtins are syntactical statement_prefixes

[20:10] <TimToady> yes, I think about that from time to time too, and wonder if there's a way to fix that so that listops can override builtins

[20:11] <TimToady> the grammar is not as unified as it could be on that

[20:13] <TimToady> some way of treating grammar rules that look like listops as in the same namespace

[20:14] <TimToady> 'course, then people would have to start writing OUTER::<if> $x {...}   # :-)

[20:14] <sorear> No comma?

[20:14] <TimToady> OUTER::<if> referring to the keyword if

[20:15] <TimToady> assuming sub if was defined and treated if as a listop

[20:15] *** buubot_backup left
[20:15] <TimToady> it's...not something I'm contemplating changing right now :)

[20:15] <dalek> star: b5588c2 | pmichaud++ | skel/ (2 files):

[20:15] <dalek> star: Update Configure.pl and Makefile.in for new configuration.

[20:15] <dalek> star: review: https://github.com/rakudo/star/commit/b5588c2c0f

[20:16] *** Trashlord left
[20:16] <sorear> If if were a listop, wouldn't it need to be OUTER::<if> $x, {...} # ?

[20:16] <TimToady> at the moment, requiring if() is probably good enough, and more than other languages provide

[20:16] <TimToady> no, the outer one is the special syntax we already have

[20:16] <TimToady> !

[20:17] <TimToady> OUTER::<if> would be statement_prefix:if

[20:17] <TimToady> the inner if would be the user's shadow if

[20:17] <TimToady> it's right on the borderline of how far do we want to go to get rid of the concept of keywords

[20:18] <TimToady> alas, either way we go will break future programs if we decide to go the other way

[20:18] <dalek> star: 4abcc07 | pmichaud++ | skel/ (2 files):

[20:18] <dalek> star: Move module-install script into tools/build (where the rest of the build things go nowadays).

[20:18] <dalek> star: review: https://github.com/rakudo/star/commit/4abcc07535

[20:20] <dalek> star: 25725a6 | pmichaud++ | / (3 files):

[20:20] *** phenny left
[20:20] <dalek> star: Update Makefile to download modules again; remove obsolete build/ scripts.

[20:20] <dalek> star: review: https://github.com/rakudo/star/commit/25725a6c25

[20:25] <dalek> niecza: e9ac09d | sorear++ | src/NieczaActions.pm6:

[20:25] <dalek> niecza: Fix compilation of "is endsym"

[20:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/e9ac09d2ff

[20:26] <pmichaud> jnthn: ping

[20:27] <pmichaud> ENOPHENNY

[20:28] <sorear> pmichaud: ping.  Where is a good place to start studying LoL?

[20:28] <jnthn> pmichaud: pong

[20:28] <sorear> nom: use MONKEY_TYPING; augment class Any { method pie() { 5 } }; say Any.pie

[20:28] <pmichaud> jnthn: I'll have to take care of kid stuff here for a while; star's Configure.pl is pretty well set as far as the basics go.  "make VERSION=2012.01" will create a image in rakudo-star-2012.01/  ,  "make tarball VERSION=2012.01" will make a tarball from that dir

[20:28] <p6eval> nom 6eae67: OUTPUT«5␤»

[20:29] <sorear> nom: use MONKEY_TYPING; augment class Any { method pie() { 5 } }; say "moo".pie

[20:29] <p6eval> nom 6eae67: OUTPUT«5␤»

[20:29] <pmichaud> sorear: the synopses are the only good place afaik.  That and the TimToady master himself.  :)

[20:29] <jnthn> pmichaud: OK, thanks :)

[20:29] <pmichaud> the makefile templates and the like have been moved into tools/ and tools/build/, just like nqp & rakudo

[20:29] <jnthn> pmichaud: Excellent.

[20:29] <sorear> pmichaud: the synopses don't adequately explain how LoL is implementable

[20:30] <pmichaud> the system is good enough to get to building + installing rakudo, I didn't work on module precompile or install yet

[20:30] <pmichaud> sorear: agreed, they don't.

[20:30] <pmichaud> I have to go pick up kids from school now; next time we catch each other online I can try to explain what little I've figured out :)

[20:30] <sorear> I beleive you implemented LoL for Rakudo

[20:30] <sorear> OK

[20:30] <sorear> nom: use MONKEY_TYPING; augment class Any { method pie() { 5 } }; say "moo".^find_method('pie')

[20:30] <jnthn> pmichaud: I'll give it a try and see how it works out.

[20:30] <p6eval> nom 6eae67: OUTPUT«pie␤»

[20:30] <pmichaud> I implemented _a_  LoL for Rakudo, I'm not sure it's correct (I'm not sure it's incorrect either, for now it's pretty close)

[20:31] <pmichaud> jnthn: msg me if you run into any problems, feel free to be mucking with configure/makefiles/build scripts.

[20:31] <sorear> nom: use MONKEY_TYPING; augment class Any { method pie() { 5 } }; say "moo".^can('pie')

[20:31] <p6eval> nom 6eae67: OUTPUT«pie␤»

[20:31] <pmichaud> afk # kid pickup

[20:33] <sorear> nom: use MONKEY_TYPING; class A { method x() { 5 } }; class B is A { }; class C is B { }; augment class B { method x() { 17 } }; say C.x

[20:33] <p6eval> nom 6eae67: OUTPUT«5␤»

[20:34] <sorear> thought so

[20:34] <jnthn> yeah, I know about that one.

[20:35] <sorear> any plans to make it work?

[20:35] *** Chillance left
[20:35] <jnthn> sorear: I intend to, but I didn't decide how 6model's "announcements" or whatever system should look like.

[20:36] <sorear> jnthn: you're going to do announcements in 6model?

[20:36] <[Coke]> TimToady: go all tcl on everybody. keyword, schmeeword.

[20:36] *** Chillance joined
[20:36] *** buubot_backup joined
[20:37] <sorear> jnthn: the conclusion I've come to is that 6model + serialization + announcements are absolutely incompatible

[20:37] <jnthn> sorear: Dunno. Somebody suggested that to me, I didn't figure it out sufficiently yet.

[20:37] *** buubot_backup left
[20:37] <sorear> jnthn: and that when I add 6model, either serialization or announcements has to go :|

[20:37] <sorear> which means worse augment support

[20:39] <jnthn> sorear: Yeah, how to do augment + serialization sanely without re-implementing object-level git is a tricky one. :)

[20:41] <TimToady> sorear: the basic idea of lol is implicit in the getarg described in S07:212; lol is a function that does getarg on each parcel/item and turns it into something that doesn't flatten (Seq in the old school terminology, though maybe something different now)

[20:41] <sorear> .oO( use the new Parrot libgit2 bindings )

[20:41] <jnthn> ;-)

[20:41] * [Coke] wonders why autounfudge keeps hanging on niecza (not even while running mono.)

[20:43] <jnthn> sorear: It's plausbile to imagine some kinda write-barrier that triggers if you modify an object that is in any SC other than the current one, and adds it to the current compilation unit's SC in some way such that there's enough info to do replacement as needed.

[20:44] <TimToady> I guess lol is really just .tree(*.item)

[20:44] <TimToady> maybe tree should be renamed .retree

[20:45] <TimToady> or .treemap

[20:45] *** ksi joined
[20:45] <TimToady> though it's specifically mapping by level, not node type, so maybe some other name is better

[20:46] <TimToady> .stratify or some such

[20:46] <Radvendii> i love/hate that awkward moment when one put's in debug 'say' statements, and all of a sudden it works. and then when one takes out all of the debug, it still works... and as far as one knows, one didn't change any of the actual code...

[20:47] <TimToady> I usually do that with u in vim, so I know exactly what state it was in before regarding semicolons and such (but I rely heavily on :autowrite when I ^Z)

[20:49] <TimToady> .oO(vim as a poor man's version control system)

[20:49] <[Coke]> TimToady: didn't you used to use emacs and mock vim users?

[20:50] <TimToady> I haven't used emacs since it was Gosling's emacs, and vim didn't exist yet

[20:50] * [Coke] conflates vim and vi, sorry. ;)

[20:51] <TimToady> gnu emacs was always too much for my arthritic pinkie

[20:52] <doy> TimToady: have you tried the new persistent undo feature yet? (in vim 7.3)

[20:53] <Radvendii> :autowrite?

[20:53] <Radvendii> does that do what it sounds like it does?

[20:55] *** silug left
[20:56] <Radvendii> alright, why would nom not give me the line number for this error: use of uninitialized variable $v of type Any in numeric context

[20:59] <TimToady> it writes the file out every time you suspend, so your workflow can go back and forth between editing and testing very rapidly

[21:00] <TimToady> assuming you want to test from the command line

[21:00] <Radvendii> TimToady: sweet

[21:00] <doy> persistent undo tracks the state of the undo tree between vim invocations, so you can do that same thing even if you close/reopen vim

[21:00] <TimToady> doy: no I haven't

[21:00] <TimToady> ah, that's nice

[21:00] <Radvendii> it doesn't recognize autowrite

[21:01] <doy> Radvendii: :set autowrite

[21:01] <TimToady> I just keep it set in my .vimrc

[21:02] <TimToady> and occasionally get very confused when editing with vim on someone else's login :)

[21:02] <TimToady> "That should have fixed it!  Why did it fail again!?!  Oh, right..."

[21:03] <Radvendii> hahah

[21:03] *** phenny joined
[21:04] <sorear> Radvendii: what's the difference between Radvendii and Ravdendii?

[21:04] *** buubot_backup joined
[21:06] *** jferrero joined
[21:06] *** silug joined
[21:06] <Radvendii> in one of them the v comes first?

[21:06] *** bacek left
[21:06] <Radvendii> sorear: is this a trick question?

[21:06] *** bacek joined
[21:06] <sorear> one of them is your NICK string, the other is your USER string

[21:07] <Radvendii> oh

[21:07] <Radvendii> it was probably a typo :P

[21:07] * sorear wonders if the argument to USER has a name

[21:07] <bbkr1> hmm, I have problem with IO::Socket::INET listener not fetching whole request or recv(). has anyone else experienced this on NOM?

[21:07] <TimToady> timotimo: the usual idiom for memoization is %memo{$key} //= newvalue(), which has the advantage of not looking the memo up twice, and the disadvantage of still being broken in nom because //= isn't short-circuiting right

[21:08] <Radvendii> sorear: what do you mean?

[21:08] <TimToady> nom: my $x = 42; $x //= die "oops"  # just checking

[21:08] <p6eval> nom 6eae67: OUTPUT«oops␤  in block <anon> at /tmp/g_8k5HjU8n:1␤  in <anon> at /tmp/g_8k5HjU8n:1␤»

[21:09] <TimToady> pugs: my $x = 42; $x //= die "oops"  # just checking

[21:09] <p6eval> pugs b927740:  ( no output )

[21:09] <TimToady> niecza: my $x = 42; $x //= die "oops"  # just checking

[21:09] <p6eval> niecza v13-358-g301a891:  ( no output )

[21:09] <TimToady> yes, just broken in nom

[21:10] <Radvendii> im off for shabbat. see y'all on saturday night/sunday

[21:10] <TimToady> shalom

[21:11] *** bacek left
[21:12] *** Radvendii left
[21:13] <pmurias> sorear: hi

[21:14] <pmurias> sorear: where should I put a p5 script I want to use to build the p5 interop?

[21:17] *** buubot_backup left
[21:22] <dalek> roast: f1da377 | jnthn++ | S05- (3 files):

[21:22] <dalek> roast: Re-fudging for Rakudo.

[21:22] <dalek> roast: review: https://github.com/perl6/roast/commit/f1da377d1d

[21:22] <dalek> rakudo/nom: d707ddf | jnthn++ | src/Perl6/ (3 files):

[21:22] <dalek> rakudo/nom: Pull the entire assertion:name handling into Rakudo by overriding the one in P6Regex. Clears up a hack from this morning's patch. Also make it possible for /<x>/ to call a lexical regex x { ... }; it's a compile time decision.

[21:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d707ddf2d9

[21:22] <dalek> rakudo/nom: c8a80fb | jnthn++ | t/spectest.data:

[21:22] <dalek> rakudo/nom: Run three more test files.

[21:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c8a80fb70a

[21:28] <dalek> rakudo/nom: 0bcf489 | jnthn++ | docs/ChangeLog:

[21:28] <dalek> rakudo/nom: Start on this month's ChangeLog.

[21:28] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0bcf489ed9

[21:31] <dalek> niecza: bef38b1 | (Paweł Murias)++ | / (3 files):

[21:31] <dalek> niecza: Make the perl5 interop work outside the niecza directory and hopefully on Mac OS X too (not tested yet).

[21:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bef38b1f2f

[21:32] <pmurias> colomon: ping

[21:32] <colomon> pong

[21:32] <pmurias> colomon: see above commit ;)

[21:33] <colomon> have some tax stuff I really need to get done in the next 20 minutes.  (sigh)

[21:33] <pmurias> ok

[21:33] <pmurias> it can wait

[21:33] *** estrabd left
[21:33] <pmurias> ;)

[21:33] <pmurias> the niecza stuff that is

[21:37] *** mtk left
[21:40] <cognominal> jnthn, sorear, What are annoncement?

[21:41] <cognominal> *announcements

[21:44] *** buubot_backup joined
[21:56] <jnthn> cognominal: Essentially events expressed in terms of objects.

[21:58] <dalek> nqp/bs: fa9ba4f | jnthn++ | t/serialization/01-basic.t:

[21:58] <dalek> nqp/bs: Tests for Integer/Float/String serialization (not really 6model stuff, but we need to be able to).

[21:58] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/fa9ba4fce7

[21:58] <dalek> nqp/bs: bc443c1 | jnthn++ | src/6model/serialization.c:

[21:58] <dalek> nqp/bs: Implement serialization of Integer/Float/String; tests pass.

[21:58] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/bc443c11ae

[21:58] *** kaare_ left
[21:59] <sorear> pmurias: hi

[22:04] <colomon> pmurias: is there a simple test I can use to see if things are working?  (pause in taxes while wife writes cover letter)

[22:04] <dalek> star: 7c1a236 | jnthn++ | Makefile:

[22:04] <dalek> star: Remove a stray slash.

[22:04] <dalek> star: review: https://github.com/rakudo/star/commit/7c1a23658b

[22:11] *** birdwindupbird left
[22:16] *** alvis joined
[22:19] <masak> TimToady: letting {}.() work and produce nothing sounds like quite a benign exception, actually. as long as it still fails for all other hashes.

[22:21] *** mj41 left
[22:22] <cognominal> jnnthn: like that? http://book.pharo-project.org/book/LanguageAndLibraries/announcements/

[22:24] <colomon> pmurias: still having issues.   must run to kinkos to fax what looks like a short novel to the IRS

[22:26] *** kfo_ joined
[22:28] *** kfo left
[22:36] *** mj41 joined
[22:39] *** jferrero left
[22:39] <pmurias> colomon: perl t/run_spectests_p5 runs the p5 interop tests

[22:40] <pmurias> colomon: and p5test tries to pin down what is broken

[22:40] *** jferrero joined
[22:42] *** mj41 left
[22:44] *** skids joined
[22:45] <jnthn> phenny: ask moritz if he could drop a latest book build into the star repo - I don't have the build environment for it on this machine

[22:45] <phenny> jnthn: I'll pass that on when moritz is around.

[22:46] <jnthn> phenny: tell moritz also Pie.pm compilation fails in svg-plot, so I removed it from the modules list for this release

[22:46] <phenny> jnthn: I'll pass that on when moritz is around.

[22:47] <masak> jnthn: ooc, why does Pie.pm compilation fail?

[22:47] <jnthn> phenny: tell moritz That said, my release plan is tomorrow afternoon so if you have it fixed by then...

[22:47] <phenny> jnthn: I'll pass that on when moritz is around.

[22:47] <benabik> That's not a good tag line:  "Rakudo Star, now with less Pie"

[22:47] <jnthn> masak: It tries to use some trait that doesn't exist

[22:47] <masak> huh!

[22:47] <jnthn> masak: I didn't dig any further

[22:47] <masak> ok.

[22:47] <masak> sounds eminently fixable, though.

[22:47] <jnthn> I may in a moment. Just one this in a state where all the stuff in it works. Adding more working stuff in is fine from that.

[22:48] <jnthn> s/one/want/

[22:49] <jnthn> eek, I missed including Grammar::Debugger

[22:50] <dalek> star: 5b0bc3e | jnthn++ | Makefile:

[22:50] <dalek> star: Various module list tweaks.

[22:50] <dalek> star: review: https://github.com/rakudo/star/commit/5b0bc3e9a2

[22:57] *** jferrero left
[23:06] *** pmurias left
[23:06] *** jferrero joined
[23:07] <dalek> star: 3e76f85 | jnthn++ | / (2 files):

[23:07] <dalek> star: Add back svg-plot; one file not building doesn't bust the overall build. Also sync the other modules list in Makefile.in.

[23:07] <dalek> star: review: https://github.com/rakudo/star/commit/3e76f852b7

[23:11] <dalek> star: a2d802f | jnthn++ | / (2 files):

[23:11] <dalek> star: Case fail.

[23:11] <dalek> star: review: https://github.com/rakudo/star/commit/a2d802f2b1

[23:13] *** jferrero left
[23:16] *** whiteknight joined
[23:17] <sorear> hello, whiteknight

[23:17] <whiteknight> Hello sorear

[23:18] <PerlJam> greetings

[23:23] *** cognominal_ joined
[23:25] *** cognominal left
[23:27] *** jferrero joined
[23:30] <sorear> niecza: sub foo(|x) { say x }; foo(:q)

[23:30] <p6eval> niecza v13-363-ge9ac09d: OUTPUT«\(|{"q" => Bool::True})␤»

[23:30] <sorear> :q

[23:30] * hugme hugs sorear, good vi(m) user!

[23:34] <[Coke]> :wq!

[23:34] * hugme hugs [Coke], good vi(m) user!

[23:41] <masak> спокойной ночи, #perl6 o/

[23:41] <sorear> o/ masak

[23:41] <dalek> niecza: 2537901 | sorear++ | lib/CORE.setting:

[23:41] <dalek> niecza: Fudge typing on Match.synthetic

[23:41] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2537901c39

[23:41] <dalek> niecza: 4c94673 | sorear++ | src/NieczaGrammar.pm6:

[23:41] <dalek> niecza: Remove last straggling use of nextwith

[23:41] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4c9467373a

[23:41] * masak спит

[23:41] <dalek> roast: 0c93c21 | coke++ | S02-types/ (2 files):

[23:41] <dalek> roast: niecza autounfudge

[23:41] <dalek> roast: review: https://github.com/perl6/roast/commit/0c93c213be

[23:42] <jnthn> спиттинг is a disgusting habbit :P

[23:48] <bbkr1> do we have any working HTTP standalone server? except HTTP::Easy and HTTP::Server::Simple as both are broken when it comes to multipart request reading

[23:49] *** bkolera joined
[23:49] <bbkr1> this silence means "no, you are stuck with PSGI" :)

[23:51] <jnthn> bbkr1: I think HTTP::Easy is the most maintained one of those, so you could file a github issue about it there.

[23:53] <sorear> looks like I'm going to have to reinstate the role cache somehow

