[00:01] *** Chillance left
[00:01] *** cognominal left
[00:04] *** cognominal_ left
[00:06] *** adu joined
[00:10] <skids> Probably it's more useful to throw the user's failure, whether the throw is immediate on typecheck, or whether the failure is passed through lazily, either way.

[00:13] <diakopter> pmichaud: on the latest rakudo, I'm getting some failed spectests, and some loop forever eating all my memory

[00:14] <diakopter> owait.

[00:14] <[Coke]> +# 07/31/2012 - rakudo++ (22941); niecza (89.88%); pugs (40.99%)

[00:14] <diakopter> I'm still on toqast branch..... oops.

[00:14] <[Coke]> huh. the pugs failures on the specrun... vanished.

[00:15] <[Coke]> p: say 40.99/89.88

[00:15] <p6eval> pugs: OUTPUT«0.4560525144637294170004450378282153983089␤»

[00:15] <[Coke]> niecza: 8 failures; rakudo: 3

[00:15] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row at /tmp/q0Y6oAArXq line 1:␤------> [32m8 [33m⏏[31mfailures; rakudo: 3[0m␤␤Parse failed␤␤»

[00:18] <skids> .oO(evalbot gets the colon)

[00:19] <[Coke]> I think that's the 2nd time I've done that. whoops.

[00:21] <dalek> specs: 12ee078 | larry++ | S05-regex.pod:

[00:21] <dalek> specs: relationship of :sigspace with %

[00:21] <dalek> specs: 

[00:21] <dalek> specs: The rules follow from the way sigspace is enabled by previous matcher.

[00:21] <dalek> specs: fixes #22

[00:21] <dalek> specs: review: https://github.com/perl6/specs/commit/12ee0787e9

[00:22] <diakopter> TimToady: signicant typo

[00:23] * diakopter slowly races to fix..

[00:25] <TimToady> now I have to figure out how to implement it in STD as specced

[00:26] <TimToady> basically ms/ <atom> * / needs to turn into / [<atom><.ws>]* /

[00:27] <adu> woah

[00:28] <TimToady> and ms/ <atom>* / turns into / <atom>* <.ws>

[00:28] <adu> I would expect the latter

[00:28] <adu> the former is unexpected

[00:29] <TimToady> well, it's either that or force everyone to write [<atom> ]+ % ','  al over the place

[00:29] <TimToady> *all

[00:29] <dalek> specs: 00da791 | u11++ | S05-regex.pod:

[00:29] <dalek> specs: S05 - insignicant typo

[00:29] <dalek> specs: review: https://github.com/perl6/specs/commit/00da791461

[00:29] <TimToady> I think <atom> +% ',' works better

[00:29] <diakopter> hrm. how am I now named u11

[00:30] <diakopter> oh.

[00:32] <TimToady> but it means overhauling STD not to treat sigspace as its own atom

[00:33] <TimToady> std: / :s <ident> * /

[00:33] <p6eval> std f43a358: OUTPUT«ok 00:00 41m␤»

[00:33] <TimToady> I'm a little surpised that parses

[00:33] *** UncleFester6 joined
[00:34] <diakopter> nqp: my @a := [[]]; say(@a);

[00:34] <p6eval> nqp: OUTPUT«1␤»

[00:35] <benabik> r: my @a = [[]]; say(@a)

[00:35] <p6eval> rakudo c1bfbb: OUTPUT«␤»

[00:36] <diakopter> r: my @a := [[]]; say(@a.perl);

[00:36] <p6eval> rakudo c1bfbb: OUTPUT«Array.new([])␤»

[00:36] <diakopter> r: my @a := [[[]]]; say(@a.perl);

[00:36] <p6eval> rakudo c1bfbb: OUTPUT«Array.new([[]])␤»

[00:36] <diakopter> heh

[00:36] <[Coke]> r: r: my @a = [[]]; say(+@a);

[00:36] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/OJK4HLivLg:1␤»

[00:36] <[Coke]> r: my @a = [[]]; say(+@a);

[00:36] <p6eval> rakudo c1bfbb: OUTPUT«1␤»

[00:38] *** tokuhiro_ joined
[00:42] * diakopter uses 3 nested gathers/take for something; whee

[00:46] <colomon> diakopter++

[00:47] *** cognominal_ joined
[00:47] <[Coke]> colomon,sorear: https://gist.github.com/3222097

[00:47] <[Coke]> I cannot remember current fudging rules, so I leave it to you.

[00:47] <colomon> oh, right, forgot to finish those changes....

[00:49] <diakopter> r: say join(" a ", gather { for [1,2] { take join(" $_ ", gather { for [3,4] { take join(" $_ ", gather { for [5,6] { take "$_" } }) } }) } }) # halp

[00:49] <p6eval> rakudo c1bfbb: OUTPUT«5 6␤»

[00:50] <diakopter> r: say join(" a ", gather { for (1,2) { take join(" $_ ", gather { for (3,4) { take join(" $_ ", gather { for (5,6) { take "$_" } }) } }) } }) # halp

[00:50] <p6eval> rakudo c1bfbb: OUTPUT«5 3 6 1 5 4 6 a 5 3 6 2 5 4 6␤»

[00:52] *** raiph joined
[00:52] <diakopter> doesn't seem right to me

[00:53] <diakopter> oh hm, it's right

[00:53] <diakopter> nm; sry

[00:55] <dalek> roast: 88d6e1d | (Solomon Foster)++ | S32-str/substr.t:

[00:55] <dalek> roast: Fudge for niecza.

[00:55] <dalek> roast: review: https://github.com/perl6/roast/commit/88d6e1d702

[01:01] <dalek> roast: fedb957 | (Solomon Foster)++ | S05-interpolation/regex-in-variable.t:

[01:01] <dalek> roast: Fudge for niecza.

[01:01] <dalek> roast: review: https://github.com/perl6/roast/commit/fedb957e57

[01:03] *** scott___ joined
[01:07] <TimToady> course now I've *really* broken STD: Unrecognized regex metacharacter < (must be quoted to match literally)

[01:07] *** tokuhiro_ left
[01:08] <diakopter> uh oh; do we now have to go through gimme5 again?

[01:08] <dalek> roast: f5b1f2e | (Solomon Foster)++ | S02-lexical-conventions/comments.t:

[01:08] <dalek> roast: Fudge for niecza.

[01:08] <dalek> roast: review: https://github.com/perl6/roast/commit/f5b1f2e161

[01:09] <dalek> niecza: ddf93f9 | (Solomon Foster)++ | t/spectest.data:

[01:09] <dalek> niecza: Turn off obsolete lcfirst and ucfirst tests.

[01:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ddf93f991d

[01:09] <TimToady> nah, it's not that broken

[01:10] * TimToady crosses his fingers

[01:16] <diakopter> std: /a***/

[01:16] <p6eval> std f43a358: OUTPUT«Can't bless non-reference value at CursorBase.pm line 1163.␤FAILED 00:00 41m␤»

[01:17] <diakopter> O_O

[01:30] <diakopter> std: /a/

[01:30] <p6eval> std f43a358: OUTPUT«Can't bless non-reference value at CursorBase.pm line 1163.␤FAILED 00:00 41m␤»

[01:30] <diakopter> :J

[01:44] *** cognominal_ left
[01:46] *** Entonian joined
[01:54] <diakopter> sorear: what makes you think the nobootstrap branch has failed? I'm curious what insurmountable difficulties you've struck

[01:54] <sorear> diakopter: I can't think of any way to move the parser forward

[01:55] *** Entonian left
[01:56] <diakopter> forward.. on what axis

[01:58] <diakopter> (I mean, I assume you don't mean forward in the input)

[02:01] <diakopter> (or do you merely mean make progress on the parser?)

[02:02] <sorear> I merely mean progress

[02:02] <sorear> there are ... issues ... because the parser is written in Perl 6

[02:03] <diakopter> my first thought is the hardest problem will be mimicking the continuable RxFrame

[02:06] <diakopter> .. or were you planning to use RxFrame

[02:07] <diakopter> (and the trampoline)

[02:08] *** lucas_ left
[02:09] <pmichaud> TimToady: thanks for speedy issue #22 update

[02:09] <pmichaud> now I have to implement it also :)

[02:10] <sorear> diakopter: I was kind of thinking of using RxFrame

[02:10] <sorear> something broke in my head and I started ranking designs in a non-transitive way

[02:11] <sorear> design 2 beats 1, 3 beats 2, 4 beats 3, 5 beats 4, 6 beats 5, but 6 is identical to 1

[02:11] <sorear> I stopped when I realized I was going in circles

[02:11] <diakopter> oh.

[02:12] <diakopter> I've experienced that a few times

[02:12] <diakopter> except I usually don't notice I'm looping until a few times around the cycle

[02:15] <diakopter> sorear: why would niecza not have a future just because the nobootstrap branch currently appears ill-fated

[02:16] <diakopter> (I mean, what hope were you pinning on the nobootstrap branch?)

[02:16] <sorear> diakopter: macros, slangs, fast startup

[02:17] <diakopter> sorear: I suspect at least one of the "beats" in "design 2 beats 1, 3 beats 2, 4 beats 3, 5 beats 4, 6 beats 5, but 6 is identical to 1" has another interpretation

[02:18] <diakopter> I'd be curious to hear about those designs

[02:20] <pmichaud> I think I should stop asking questions; every time I do, the spec changes.  :)

[02:20] <pmichaud> on the other hand, when people ask "why is Perl 6 taking so long", I guess we can say "it's Pm's fault."  :-P

[02:22] <diakopter> Perl 6: where our standards are so high, we keep tweaking the standards.

[02:24] <sorear> diakopter: ok

[02:25] <sorear> diakopter: this will be a bit rambly, I apologize in advance

[02:25] <sorear> there are two major goals here:

[02:26] <sorear> - .net metadata is demand-loaded using C code and is generally a lot more efficient than trying to load our Perl6 metadata, so reducing the amount of P6 code in the compiler will speed up starting

[02:27] <sorear> - using a Perl 6 compiler requires isolating the compiler from user code in order to make bootstrapping not explode; the isolation layer makes it impossible for things like slangs and 'is parsed' macros to link directly into the parser, and is itself a large amount of awkward to maintain code

[02:28] <sorear> in the nobootstrap branch, I've already moved almost all of the compiler midend to C#

[02:28] <sorear> the parser, however-

[02:28] <sorear> we need the parser to be implemented using RxFrame/Cursor in order for it to integrate with user macros

[02:28] <sorear> there are then a couple choices

[02:29] <sorear> * hand written RxFrame/Cursor parser

[02:29] <sorear> * use STD, but write a MiniParser that can parse about the same fraction of Perl6 as gimme5

[02:29] <sorear> * use STD, and do bootstrapping just for STD

[02:30] <sorear> * translate a minimal subset of STD to C# and have it dynamically parse the rest of itself as augments

[02:30] <sorear> complicating issues include coping with binary-incompatible changes to the runtime support code

[02:31] <sorear> __END__

[02:31] <diakopter> hm

[02:33] <diakopter> what are the detriments to option #2

[02:34] <diakopter> slash relative costs

[02:35] <diakopter> er, option #2, 1-indexed

[02:36] *** Psyche^ joined
[02:38] *** mikemol joined
[02:39] <sorear> having to design a parser, mostly

[02:39] *** UncleFester6 left
[02:39] <sorear> questions like whehter to bring in something like 'jay' and how much to reuse the regex mident

[02:39] <sorear> EBRAINOVERFLOW

[02:40] *** Patterner left
[02:40] *** Psyche^ is now known as Patterner

[02:40] * diakopter goes to read a bit about Jay

[02:41] <sorear> all I really know about jay is that mcs uses it

[02:42] <[Coke]> pmichaud: I'd blame larry, not you. If he'd just get the spec right /first/, we could go much faster. ;)

[02:42] *** cognominal joined
[02:42] *** crab2313 joined
[02:43] <[Coke]> ... I think my stomach just made an angry birds noise. wtf?

[02:44] *** gongyiliao joined
[02:44] <diakopter> sorear: oh. berkeley yacc to C#

[02:48] <diakopter> sorear: I asked about option #2 because it was the option I preferred and planned to use ... several times (in several abortive projects)

[02:50] <diakopter> like, the minimal subset of P6 in which STD *can be* reasonably readably/concisely written

[02:51] <diakopter> ... as strongly-typed as possible

[02:51] <diakopter> strongly/primitively

[02:52] <diakopter> 'course, that'd be a lot of work.

[02:53] <diakopter> (to get an edition of STD like that)

[02:53] <benabik> diakopter: something like NQP?

[02:53] *** sftp left
[02:53] <diakopter> benabik: NQP will be quite close once it gets native/primitive locals/lexicals

[02:54] <diakopter> and compact arrays

[02:55] <diakopter> it already has native attributes (yay)

[02:57] *** orafu left
[02:59] *** orafu joined
[03:00] <diakopter> benabik: I assume you mean NQP's subset of P6, not the NQP implementation. .. because we're talking about writing a parser for a language implementation written in C#.. (not looking for an existing parser)

[03:01] *** cognominal left
[03:01] <sorear> nqp: my int $x;

[03:01] <p6eval> nqp:  ( no output )

[03:03] <sorear> nqp: my int $x := 1; my int $y := 0; while ($y < 20) { say($x); $x := $x * 1000; $y := $y + 1; }

[03:03] <p6eval> nqp: OUTPUT«1␤1000␤1000000␤1000000000␤1000000000000␤1000000000000000␤1000000000000000000␤1000000000000000000000␤1000000000000000000000000␤1000000000000000000000000000␤1000000000000000000000000000000␤1000000000000000000000000000000000␤1000000000000000000000000000000000000␤100000000000000…

[03:03] * sorear wonders if nqp ints are bigints now

[03:03] <diakopter> ah, I didn't know it got them

[03:05] <diakopter> sorear: does option #3 involve viv?

[03:08] <sorear> probably not, that's an idea I had not considered

[03:08] <diakopter> one of the options I considered was to write a (C in my case) emitter in viv

[03:10] *** crab2313 left
[03:13] <diakopter> (but alas, merely pipe dreams..)

[03:14] *** crab2313 joined
[03:25] *** lue joined
[03:34] <benabik> diakopter: Just meant to point out the similarities.  :-)

[03:54] *** crab2313 left
[03:55] <skids> What's the specced behavior of something like int8(256)?  A failure, or does that constitute "treating it as an object" and result in an Int?

[04:00] <sorear> skids: per spec it has to coerce to int8, and native types don't support failures

[04:01] <sorear> so it either coerces to int8 somehow, or dies

[04:01] <sorear> I don't think the actual method of coercion is specced

[04:01] <sorear> it probably shouldn't be, for the same sorts of reasons that led C to not spec signed overflow

[04:03] <skids> sorear++.  That sounds like an interesting dilemma :-)

[04:15] *** kaare_ joined
[04:23] *** telex left
[04:23] *** telex joined
[04:29] *** skids left
[04:34] *** telex left
[04:36] *** telex joined
[04:51] *** SamuraiJack joined
[04:56] *** alc joined
[05:11] *** alc left
[05:26] *** alc joined
[05:43] *** SamuraiJack left
[05:43] <moritz> \o

[05:46] *** adu left
[05:52] *** wtw joined
[05:59] *** birdwindupbird joined
[06:09] *** telex left
[06:10] *** telex joined
[06:11] *** kaleem joined
[06:12] <arnsholt> o/

[06:21] *** kaare_ left
[06:30] *** alc left
[06:34] *** thou left
[06:34] *** cognominal joined
[06:36] *** cognominal left
[06:40] <masak> morning, #perl6

[06:44] <sorear> o/ masak

[06:45] <masak> final blog post in place now: http://strangelyconsistent.org/blog/july-31-2012-the-finished-game

[06:53] <masak> oh, and I found a MAIN-related bug yesterday when splitting things up into modules. reported it now: https://rt.perl.org/rt3/Ticket/Display.html?id=114354

[06:57] <sorear> RFC period starts.

[06:57] <dalek> niecza: 2d14b99 | sorear++ | docs/announce.v20:

[06:57] <dalek> niecza: Add v20 announce

[06:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/2d14b99510

[07:09] * masak reads

[07:10] *** GlitchMr joined
[07:10] <masak> sorry to hear about non-bootstrap running into a dead end. it seemed like an interesting direction.

[07:11] <shachaf> ingy: Ping?

[07:13] <masak> sorear: announcement looks good.

[07:15] *** fhelmberger joined
[07:16] *** crab2313 joined
[07:18] *** crab2313 left
[07:19] <moritz> aye, it does

[07:20] <moritz> sorear: why did non-bootstrap run into a dead end? tuit starvation? or technical problems? or both?

[07:22] <moritz> http://seedmagazine.com/content/article/seeing_in_the_dark/ woah, subconscious-only seeing after a stroke damaged the visual cortex

[07:23] <sorear> moritz: I guess you could call it technical problems

[07:23] <sorear> moritz: the technical problems mounted to a point where I lost all motivation to continue.  So my weekend tuits went to other things.

[07:25] <moritz> sorear: that does sound like a good time to rething the direction, yes

[07:28] *** xinming left
[07:29] *** xinming joined
[07:30] <sorear> looks like niecza's makefile is not best friends with BSD cp

[07:35] <dalek> niecza: 7f550a2 | sorear++ | Makefile:

[07:35] <dalek> niecza: Fix package generation with BSD cp

[07:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7f550a229e

[07:38] *** cognominal joined
[07:40] *** cognominal left
[07:45] <moritz> r: say Block.^mro

[07:45] <p6eval> rakudo c1bfbb: OUTPUT«Block() Code() Any() Mu()␤»

[07:51] *** alc joined
[07:55] *** alc left
[07:55] <masak> rn: say "\x2028 \x2029"

[07:55] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«   ␤»

[07:56] <masak> .u    

[07:56] <phenny> U+2028 LINE SEPARATOR ( )

[07:56] <phenny> U+0020 SPACE ( )

[07:56] <phenny> U+2029 PARAGRAPH SEPARATOR ( )

[07:56] <masak> JavaScript considers "\u2028" and "\u2029" to be line terminators.

[07:57] <masak> I was thinking of things like .lines; how should it behave in the face of such characters?

[07:57] <GlitchMr> \u2028?

[07:57] <GlitchMr> I remember this. It's reason why JSON isn't subset of JavaScript.

[07:58] <masak> er? how can JavaScript's support of \u2028 be a reason JSON isn't a subset?

[07:59] <sorear> masak: I think because JSON allows \u2028 to appear unescaped in a string

[08:00] <masak> ah.

[08:02] <GlitchMr> But, I guess it's just small detail that Crockford hasn't noticed

[08:02] <moritz> rn: say Routine ~~ Block

[08:02] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[08:06] <masak> GlitchMr: probably.

[08:06] <masak> rn: say Method ~~ Routine

[08:06] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[08:06] <masak> I noticed today that S06 says that MAIN should be a Routine, which implies that it can be a Method. which I think isn't so.

[08:08] <moritz> I think it must be a Sub

[08:10] <moritz> masak: and I might have a patch for MAIN being executed in modules

[08:10] <moritz> unles $*W.is_precompilation_mode { ... }

[08:10] <moritz> oh wait, that's not quite enough

[08:13] <sorear> yay, looks like my message went through

[08:14] *** jdrab joined
[08:18] <masak> sorear++ # v20

[08:20] *** fgomez left
[08:21] <masak> moritz: 'unles' is not quite enough, no. it's missing an 's' :P

[08:23] <moritz> masak: I meant, a simple   use MyModule;  doesn't put MyModule in precompilationi mode

[08:24] <moritz> jnthn: or does it?

[08:24] *** dakkar joined
[08:25] <masak> "the compilation unit was directly invoked rather than by being required by another compilation unit" -- this is what we want to test.

[08:26] <masak> if that's called $*W.is_precompilation_mode or not, I don't know.

[08:26] <moritz> unfortunately for patching rakudo, I need to know if it's spelled that way :-)

[08:26] <moritz> or how to spell it

[08:27] <jnthn> moritz: No, is_precompilation_mode just means "Rakudo was run with --target=pir" I think.

[08:28] <moritz> I've now tried   if !$*W.is_precompilation_mode && +@*MODULES == 0 && $unit.symbol('&MAIN') { ... }

[08:28] <moritz> and now it never runs MAIN :/

[08:28] <moritz> I need to debug which of those conditions failed

[08:30] *** xinming_ joined
[08:31] <moritz> it seems that +@*MODULES is always at least 1

[08:32] * masak .oO( 412 )

[08:32] *** xinming left
[08:33] <moritz> which is very odd, given that the only place that adds to @*MODULES is the module loader

[08:35] <masak> what does it contain?

[08:35] <moritz> the module loading backtrace, so to say

[08:36] <jnthn> moritz: Does it pop off again?

[08:36] <moritz> jnthn: there's code for popping off it

[08:36] <moritz> jnthn: not sure if I've tested it properly

[08:36] *** mscha joined
[08:37] <jnthn> Yeah. It looks right at least.

[08:38] *** SamuraiJack joined
[08:39] <moritz> I'm now trying to create a new   my @*MODULES in the loader instead

[08:39] <moritz> which should be more robust

[08:39] <moritz> my current theory is that loading the setting populates @*MODULES somehow

[08:40] <moritz> and doesn't clean up properly

[08:40] *** cognominal joined
[08:42] *** cognominal left
[08:43] <moritz> ok, that seems to fix things

[08:43] <moritz> oh, I now see why

[08:43] <moritz> for the first module, there are *two* hashes pushed onto @*MODULES

[08:44] <moritz> one for the calling location, one for the module itself

[08:44] <jnthn> The setting does use Perl6::BOOTSTRAP or so.

[09:02] <dalek> rakudo/nom: 558ea68 | moritz++ | src/core/IO.pm:

[09:02] <dalek> rakudo/nom: remove IO::Path and IO::Dir

[09:02] <dalek> rakudo/nom: 

[09:02] <dalek> rakudo/nom: as the deprecation notice predicted

[09:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/558ea68780

[09:02] <dalek> rakudo/nom: 85b7789 | moritz++ | src/core/IO.pm:

[09:02] <dalek> rakudo/nom: fixup

[09:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/85b7789d6b

[09:02] <dalek> rakudo/nom: 2cdf1c6 | moritz++ | src/Perl6/ (2 files):

[09:02] <dalek> rakudo/nom: Only run MAIN in the mainline. Closes RT #114354

[09:02] <dalek> rakudo/nom: 

[09:02] <dalek> rakudo/nom: Includes a small refactoring of @*MODULES handling, which avoids

[09:02] <dalek> rakudo/nom: leaving traces in @*MODULES after the first module load (which

[09:02] <dalek> rakudo/nom: is always the setting)

[09:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2cdf1c62ce

[09:02] * moritz forgot to rebase -i before committing. Sadface :(

[09:19] <moritz> I'm now trying to write tests for that patch

[09:20] <moritz> and it's surprisingly hard

[09:20] <moritz> I don't know how to propagate state through 'use' or 'require' boundaries

[09:20] <moritz> I've tried package variables and dynamic variables

[09:20] <masak> dynamicals?

[09:20] <masak> oh, of course you tried that already.

[09:21] <masak> even package vars don't work? :/

[09:21] <moritz> and I got a dispatch failure for   ++$*tracker  in the module

[09:21] <masak> did you declare it?

[09:21] <moritz> in the caller, sure

[09:21] <masak> r: sub foo { say ++$*tracker }; my $*tracker = 0; foo

[09:21] <p6eval> rakudo c1bfbb: OUTPUT«1␤»

[09:22] <masak> my intuition tells me dynamicals should survive a 'use' or 'require'.

[09:23] <moritz> ok, one more idea

[09:23] <moritz> I die() in sub MAIN

[09:23] <moritz> and do a lives_ok { require TestMOdule; }

[09:24] <moritz> \o/ that works

[09:24] <masak> moritz++

[09:25] <arnsholt> "Like the famous mad philosopher said, when you stare into the void, the void stares also; but if you cast into the void, you get a type conversion error. (Which just goes to show Nietzsche wasn’t a C++ programmer.)"

[09:25] <arnsholt> Figured that quote might amuse some of you =)

[09:25] <moritz> :-)

[09:26] <dalek> roast: 95987ec | moritz++ | / (2 files):

[09:26] <dalek> roast: sub MAIN in modules should not run. RT #114354

[09:26] <dalek> roast: review: https://github.com/perl6/roast/commit/95987ecd5d

[09:28] <masak> moritz: I can get dynamicals and require to work locally.

[09:28] <masak> moritz: my guess is you couldn't get 'use' to work because you used BEGIN blocks and the dynamical went out of (lexical) scope.

[09:29] <moritz> I did not

[09:29] <masak> I should know better than to underestimate you :)

[09:30] <masak> anyway, dynamicals+'require' works here.

[09:33] <moritz> well, I did do something wrong

[09:34] <moritz> hm, I might have an idea

[09:34] <moritz> maybe MAIN ran *after* the require 

[09:34] <moritz> so the dynvar wasn't in scope anymore at all

[09:34] <masak> maybe. :)

[09:34] <moritz> but I thought it didn't run at all :/

[09:34] * masak is again reminded of HPMoR today

[09:35] <moritz> no new episode so far :(

[09:35] <moritz> just a new episode of the podcast

[09:35] <masak> too early in the day yet.

[09:37] *** cognominal joined
[09:44] *** daxim joined
[09:53] <mscha> perl6: say reverse 0..Inf;

[09:54] <p6eval> rakudo c1bfbb: OUTPUT«Cannot reverse an infinite list␤  in method gist at src/gen/CORE.setting:9624␤  in sub say at src/gen/CORE.setting:7024␤  in block  at /tmp/oCOFAIOTpZ:1␤␤»

[09:54] <p6eval> ..niecza v19-15-g051783d: OUTPUT«(timeout)»

[09:55] <mscha> (My copy of Rakudo Star 2012.4 said "Cannot reverse and infinite list", which has apparently been fixed.

[09:55] <mscha> )

[09:56] <masak> X::Infinite::YouKnowWhatIMean

[09:58] <GlitchMr> Reversing infinite list would require knowing its last position

[09:59] <moritz> but we know it. It's Inf :-)

[09:59] <GlitchMr> So, reverse 0 .. Inf should return infinite list of Inf

[09:59] <masak> this is the danger of confusing actual numbers with concepts representing limits.

[09:59] <masak> Inf isn't a natural number.

[10:00] <moritz> nr: say Inf.WHAT

[10:00] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«Num()␤»

[10:00] <masak> it's the limit towards which natural numbers tend.

[10:00] <moritz> rakudo and niecza agrees that it's not a natural number :-)

[10:00] <GlitchMr> gather for ^Inf { take Inf }

[10:00] <GlitchMr> Is there better way of representing such list?

[10:01] <jnthn> 1..*

[10:01] <moritz> GlitchMr: Inf xx Inf

[10:01] <jnthn> Oh, you wanted all Infs...

[10:01] <moritz> or Inf xx *

[10:01] <GlitchMr> > Inf xx Inf

[10:01] <moritz> shorter :-)

[10:01] <GlitchMr> Cannot coerce Inf to an Int

[10:01] <GlitchMr> huh

[10:01] <jnthn> Sorry, I thought we were doing useful things :)

[10:01] <moritz> yes, xx wants an Int on the RHS

[10:01] <GlitchMr> Inf xx * seems to work

[10:03] <GlitchMr> Actually, reversing infinite list would be possible, but it's impossible

[10:03] *** Bzek joined
[10:04] <GlitchMr> or something

[10:04] <GlitchMr> The list 0 xx * could be easily reversed

[10:05] <GlitchMr> Just wondering, does reverse return iterator?

[10:05] <moritz> a lazy list

[10:05] <moritz> iterators aren't exposed to the user

[10:05] <GlitchMr> > pop 0 xx *

[10:05] <GlitchMr> .pop from an infinite list NYI

[10:05] <GlitchMr> huh?

[10:06] <GlitchMr> So, if somehow .pop will be implemented on infinite list, reverse will be possible too

[10:06] <GlitchMr> But... why .pop on infinite list would be possible?

[10:07] <moritz> I guess I just wasn't sure if it might be possible oneday

[10:08] <moritz> feel free to submit a patch for a better error message

[10:08] <GlitchMr> Wouldn't getting last element from infinite list require getting every element before?

[10:11] <GlitchMr> I can see it possible with shift or unshift... but with pop()

[10:11] <GlitchMr> (by the way, push() on infinite list could be nop)

[10:11] <GlitchMr> But error is better

[10:13] <arnsholt> I don't really see how pop on an infinite list would be impossible

[10:14] <moritz> it's possible for a potentially-infinite list

[10:14] <moritz> but for a really infinite list?

[10:14] <masak> I think it's a bad idea.

[10:14] <GlitchMr> http://paste.uk.to/22f651a2

[10:15] <GlitchMr> So, I have unshift() for infinite arrays

[10:16] <moritz> unshift is already implemented

[10:16] <GlitchMr> oh, ok

[10:16] <moritz> and it's the same for finite and infinite lists

[10:16] <moritz> because it just works on the reified part

[10:17] *** cognominal left
[10:18] <moritz> r: my @a = 1, 2; @a.unshift: <a b>.list: @a[0] = 4; say @a

[10:18] <p6eval> rakudo c1bfbb: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in method list at src/gen/CORE.setting:4614␤  in block  at /tmp/8zypWOWaui:1␤␤»

[10:19] <moritz> r: my @a = 1, 2; @a.unshift: <a b>.list; @a[0] = 4; say @a

[10:19] <p6eval> rakudo c1bfbb: OUTPUT«4 b 1 2␤»

[10:19] * moritz has no idea where the container in @a[0] comes from

[10:22] <masak> arrays provide containers.

[10:22] * arnsholt fails to spot the difference between moritz's two snippets

[10:23] <masak> arnsholt: colon vs semicolon

[10:23] <moritz> just a few pixels

[10:23] <masak> yes, it was subtle :)

[10:23] <arnsholt> Oh, now I see it =)

[10:25] <GlitchMr> pop and push should be errors on infinite lists

[10:25] <GlitchMr> pop because it's impossible

[10:25] <GlitchMr> push because it's useless

[10:25] *** cognominal joined
[10:27] <arnsholt> Durr, of course. I had things confused >.<

[10:27] <arnsholt> Of course pop is impossible =)

[10:27] <Coleoid> But what if it's only infinite in the middle?

[10:28] <GlitchMr> Infinite in the middle?

[10:28] <Coleoid> :D

[10:28] <GlitchMr> What?

[10:28] <GlitchMr> But, well, I don't think we plan infinite reverse lists.

[10:29] <Timbus> 1 .. Inf .. 1

[10:29] <GlitchMr> (read: end is known, but beginning isn't)

[10:29] <arnsholt> But there's a different problem. We can't detect all possible infinite lists, so sometimes we'll just have to be satisfied with an infinite loop/recursion

[10:29] *** cognominal left
[10:29] <GlitchMr> This list looks interesting

[10:29] *** cognominal joined
[10:30] <GlitchMr> (aside of that Inf .. 1 won't work in Perl 6)

[10:30] *** scott___ left
[10:30] <Timbus> i wanted perl 6 to just assume lists were infinite unless provably finite, but it went the other way =/

[10:31] <arnsholt> Depends on which is worse I suppose. Not being able to do something on a list that you can do it on, or hanging because you're asking for something infinite

[10:33] <Coleoid> Timbus: That surprises me--are there many benefits to infinite lists that we'd gain from their... pervasivity?  Defaultitude?

[10:33] <masak> GlitchMr: and aside from that infix:<..> doesn't chain.

[10:35] <masak> s/from/from the fact/

[10:36] <Coleoid> No problem--If I ever need such behavior, I can write a class.  Technically I see no hitches, the hard part will be naming it.

[10:39] <Timbus> Coleoid, i guess the benefit is mostly that there are no surprises. if everyone knows lists are lazy there's no issues. if the computer knows the list is finite, or you know the list is finite, you can force finiteness.

[10:40] <Timbus> it means you can avoid hanging yourself ;]

[10:45] *** Bzek left
[10:52] *** JimmyZ joined
[10:55] <Coleoid> That makes some sense.  I haven't worked in an area where I didn't know (at coding time) whether a list was infinite or not...

[10:59] <Timbus> i think its more likely if the language enables it. gather/take for example. I am predicting that libraries will be returning infinite lists from time to time

[11:00] <Coleoid> So I don't expect them to look as similar as they do--in a way I still don't 'get' how one can say "infinite list", instead of "infinite sequence generator".

[11:00] <Timbus> by making them look the same :p

[11:00] <Coleoid> :D

[11:04] *** cognominal left
[11:14] *** SamuraiJack left
[11:18] *** eiswar joined
[11:18] *** SamuraiJack joined
[11:25] *** cognominal joined
[11:30] *** sergot joined
[11:30] <sergot> hi o/

[11:31] <masak> sergocie! \o/

[11:31] <sergot> masaku \o/

[11:33] *** bruges left
[11:35] *** fhelmberger left
[11:35] *** mtk joined
[11:36] *** sergot1 joined
[11:36] *** sergot left
[11:37] *** mtk left
[11:38] *** mtk joined
[11:42] *** jdrab left
[11:43] *** sergot joined
[11:45] *** sergot1 left
[11:46] *** sftp joined
[12:00] *** cognominal left
[12:01] *** kaleem left
[12:02] *** fhelmberger joined
[12:10] *** gongyiliao left
[12:18] *** jaldhar left
[12:23] <felher> r: say "BLAR" ~~ /:ignorecase blar/

[12:23] <p6eval> rakudo c1bfbb: OUTPUT«q[BLAR]␤␤»

[12:23] <felher> r: say "BLAR" ~~ /:ignorecase [blar | blubb]/

[12:23] <p6eval> rakudo c1bfbb: OUTPUT«#<failed match>␤»

[12:23] <felher> Is it supposed to work that way?

[12:24] <moritz> it's supposed to match

[12:24] <moritz> r: say "BLAR" ~~ /:ignorecase [blar || blubb]/

[12:24] <p6eval> rakudo c1bfbb: OUTPUT«q[BLAR]␤␤»

[12:24] <moritz> seems it's an NFA issue

[12:24] <jnthn> Hm

[12:24] <moritz> nqp: say('BLAR' ~~ /:ignorecase [blar || blubb]/)

[12:24] <jnthn> Yeah, guess the NFA builder doesn't know anything about :i

[12:24] <p6eval> nqp: OUTPUT«BLAR␤»

[12:24] <moritz> nqp: say('BLAR' ~~ /:ignorecase [blar | blubb]/)

[12:24] <p6eval> nqp: OUTPUT«␤»

[12:25] <moritz> felher: please submit rakudobug

[12:25] <jnthn> .oO( well, this'll be fun to fix... )

[12:25] <felher> moritz: will do :)

[12:28] *** spider-mario joined
[12:28] * masak submits rakudobug

[12:28] <masak> oh, felher is on it.

[12:28] * masak unsubmits :)

[12:29] *** mucker joined
[12:32] <pmichaud> ...nfabuilder is supposed to know about :i

[12:32] <pmichaud> I mean, there's an ignorecase opcode for it (or at least, I thought there was!)

[12:33] <pmichaud> anyway, I'll look at it a bit, since I'm already in the regex engine guts working on sigsp

[12:33] <jnthn> ++pmichaud

[12:34] <jnthn> I don't remember seeing such a thing, but maybe I suppressed memories of the NFA builder... :)

[12:34] <moritz> what strikes me is that we didn't have tests for it

[12:36] <jnthn> Aye, that is a bit surprising.

[12:37] *** jaldhar joined
[12:37] <moritz> nqp: say('BLAR' ~~ /:ignorecase blar | blubb/)

[12:37] <p6eval> nqp: OUTPUT«␤»

[12:38] <moritz> is the :i scoped to the left branch in this case?

[12:38] <jnthn> Don't think so

[12:38] <jnthn> %*RX is localized per nibbler.

[12:39] <moritz> nr: say so 'a' ~~ /:i b | A/

[12:39] <jnthn> oh, it's possible it still is...

[12:39] <p6eval> rakudo c1bfbb: OUTPUT«False␤»

[12:39] <p6eval> ..niecza v19-15-g051783d: OUTPUT«True␤»

[12:39] <moritz> nr: say so 'a' ~~ /:i b || A/

[12:39] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[12:39] *** cognominal joined
[12:39] <jnthn> Yeah, think that's right.

[12:39] <jnthn> (the || result, taht is)

[12:39] <moritz> and niecza in both cases

[12:39] <jnthn> yeah

[12:40] <gfldex> p6: sub foo(Str $s){ return "$s</$s>" }; say foo 'abc';

[12:40] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Cannot use hash access on an object of type Str␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 354 (Any.at_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/RSUkojt_Zn line 1 (foo @ 3…

[12:40] <p6eval> ..rakudo c1bfbb: OUTPUT«postcircumfix:<{ }> not defined for type Str␤  in method Str at src/gen/CORE.setting:9623␤  in method Stringy at src/gen/CORE.setting:717␤  in sub foo at /tmp/9lE75RDJra:1␤  in block  at /tmp/9lE75RDJra:1␤␤»

[12:42] *** kaleem joined
[12:42] <dalek> roast: ca2353f | moritz++ | S05-modifier/ignorecase.t:

[12:42] <dalek> roast: test LTM + :ignorecase

[12:42] <dalek> roast: review: https://github.com/perl6/roast/commit/ca2353f230

[12:43] <pmichaud> nqp:  say('BLAR' ~~ /:ignorecase [ blar | blubb]/)

[12:43] <p6eval> nqp: OUTPUT«␤»

[12:43] <pmichaud> nqp:  say('BLAR' ~~ /:ignorecase [ blar || blubb]/)

[12:43] <p6eval> nqp: OUTPUT«BLAR␤»

[12:44] <pmichaud> nqp:  say('blar' ~~ /:ignorecase [ blar | blubb]/)

[12:44] <p6eval> nqp: OUTPUT«blar␤»

[12:44] <pmichaud> yeah, okay.

[12:44] <pmichaud> I remember; I didn't do a lowercase nfa opcode; the idea is to generate a node containing x|X

[12:45] <moritz> that approach won't scale for :ignoremark

[12:46] <moritz> there might be only two or three cases for each letter, but there can be quite many marked variants of a letter

[12:50] <pmichaud> well, until we have an opcode that can handle ignoremark'ed comparisons, it's a moot point anyway :)

[12:50] *** tokuhiro_ joined
[12:51] <pmichaud> regardless, ignorecase (or cases with small numbers of options) is far better handled by multiple nodes that can do codepoint (integer) compares than by (sub)string compares

[12:52] * moritz wonders how far one can get to :ignoremark by converting to NFD and comparing base characters only

[12:52] <pmichaud> that may be possible also

[12:52] <pmichaud> anyway, time to leave here;  bbiaw

[12:52] *** PacoAir joined
[12:56] *** pdurbin joined
[12:57] <pdurbin> moritz: i enjoyed this article of yours. thanks. From Iterative to Functional Perl 6 Code - http://perl6maven.com/from-iterative-to-functional-perl6-code

[12:57] <jnthn> walk &

[12:59] <moritz> pdurbin: nice to hear, thanks

[12:59] <moritz> pdurbin: what other Perl 6 related topics would you like to read about?

[13:00] <moritz> that question goes out to everyone else too

[13:00] <pdurbin> hmm, well, i'm only a beginner. i was trying to do a couple katas. parsing json for example. i have perl5, ruby, and python working. but i was having trouble with perl6. as if it was hung or something...

[13:02] <moritz> you'll get an infinite loop when quantifying a rule that can match zero characters

[13:02] <pdurbin> huh. ok

[13:03] <moritz> pdurbin: do you realize that the "Using Perl 6" book has a JSON parser as an example of the grammar chapter?

[13:03] <moritz> (it's not meant to be that way, it's just something that's not easy to guard against in the regex engine)

[13:03] <pdurbin> nope

[13:03] <moritz> https://github.com/perl6/book/downloads

[13:04] <moritz> and yes, I do value input from beginners on what to write

[13:05] <pdurbin> moritz: i used this as a starting point for how to parse json with perl6: https://github.com/moritz/json/blob/master/t/02-structure.t

[13:05] <moritz> ah yes, that repo served as a template for the book chapter too

[13:06] <pdurbin> but i'm not really interested in (or experienced enough) to write a grammar. i'm more interested in using your json library

[13:07] <moritz> ah

[13:07] <moritz> that's easy

[13:07] *** nightlord joined
[13:07] <moritz> star: use JSON::Tiny; say to-json({ nick => 'pdurbin', state => 'advancing'})

[13:07] <p6eval> star 2012.07: OUTPUT«{ "nick" : "pdurbin", "state" : "advancing" }␤»

[13:08] <moritz> star: use JSON::Tiny; say from-json('{ "nick" : "pdurbin", "state" : "advancing" }')<state>

[13:08] <p6eval> star 2012.07: OUTPUT«advancing␤»

[13:09] <pdurbin> just "advancing"? is there supposed to be more output from from-json()?

[13:10] *** bruges joined
[13:10] <JimmyZ> star: use JSON::Tiny; say from-json('{ "nick" : "pdurbin", "state" : "advancing" }')

[13:10] <p6eval> star 2012.07: OUTPUT«("nick" => "pdurbin", "state" => "advancing").hash␤»

[13:10] <tadzik> note the <state> at the very end

[13:10] <moritz> pdurbin: I only print the value of the 'state' key

[13:10] <JimmyZ> star: use JSON::Tiny; say from-json('{ "nick" : "pdurbin", "state" : "advancing" }').perl

[13:10] <moritz> star: use JSON::Tiny; say from-json('{ "nick" : "pdurbin", "state" : "advancing" }').perl

[13:10] <p6eval> star 2012.07: OUTPUT«{"nick" => "pdurbin", "state" => "advancing"}␤»

[13:10] <JimmyZ> oh my

[13:11] <pdurbin> ah, i see what you mean. thanks

[13:13] *** crab2313 joined
[13:15] *** bluescreen10 joined
[13:15] *** atrodo joined
[13:18] <pdurbin> hmm, having a bit of trouble getting a rakudo-star rpm to build on centos 6 but i'm planning on switching to fedora anyway, where the rpm installs fine. https://admin.fedoraproject.org/pkgdb/acls/name/rakudo-star

[13:19] *** GlitchMr left
[13:20] *** sergot1 joined
[13:20] *** wtw left
[13:20] *** GlitchMr joined
[13:21] * moritz just compiles from source

[13:21] *** Chillance joined
[13:22] *** skids joined
[13:22] * JimmyZ too

[13:22] *** sergot left
[13:23] * PerlJam is compiling from source right now.

[13:25] *** GlitchMr left
[13:26] <dalek> rakudo/nom: e3d4092 | moritz++ | docs/ChangeLog:

[13:26] <dalek> rakudo/nom: update ChangeLog with IO::{File,Dir} removal

[13:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e3d4092e51

[13:29] <pmichaud> back again, for another morning of perl 6 hacking in the park :)

[13:29] <[Coke]> pmichaud: sounds like fun!

[13:30] <pmichaud> it'd be more fun if it was just slightly cooler outside

[13:30] <PerlJam> sounds like a YAPC event or somethign

[13:30] * [Coke] ponders putting a day in at the library on a day when he has no phone calls to do.

[13:31] *** eiswar left
[13:31] <pdurbin> moritz and JimmyZ: i added some notes to myself here: http://wiki.greptilian.com/perl6 . thanks!

[13:32] <JimmyZ> pmichaud: http://trac.parrot.org/parrot/wiki/WhyDoesNQPGenerateInefficientCode is still a problem after 6model ?

[13:35] <pmichaud> JimmyZ: I'm not sure how to answer that.  Yes, 6model (and Rakudo's new container storage model) changes a lot of the axioms that were affecting nqp code generation.

[13:35] <pmichaud> I don't entirely agree that NQP's code generation before was "inefficient" -- it did what it had to do within the constraints of the vm.

[13:38] <JimmyZ> pmichaud: thanks

[13:38] <moritz> but we still have two GCables for every element of an array of Int, right?

[13:39] <pmichaud> yes.  not sure how to avoid that, though.

[13:43] <moritz> wow, I've managed to put setting compilation into an infinite loop

[13:43] <moritz> that hasn't happened to me in quite a while

[13:47] <moritz> r: class A { has $.x; submethod BUILD(:X(:$!x)) { } }; say A.new(:X<ofo>).x

[13:47] <p6eval> rakudo c1bfbb: OUTPUT«ofo␤»

[13:49] <pmichaud> r:  say 'b b b b' ~~ /:sigspace b * /

[13:49] <p6eval> rakudo c1bfbb: OUTPUT«q[b ]␤␤»

[13:49] <moritz> .oO( dark matter is really the invisible part of Chuck Norris' muscle matter )

[13:49] <pmichaud> Am I correct that this changes under https://github.com/perl6/specs/commit/12ee0787e9c2a0aced82bf3ad4951e5808fd40b9 ?

[13:50] <pmichaud> and also

[13:50] <moritz> yes

[13:50] <moritz> it's supposed to match the whole string now

[13:50] <pmichaud> r: say 'bbbb' ~~ /:sigspace b * /   # will now be different too

[13:50] <p6eval> rakudo c1bfbb: OUTPUT«q[bbbb]␤␤»

[13:51] <moritz> will match just the final b now

[13:51] *** JimmyZ left
[13:51] <pmichaud> first b

[13:51] <pmichaud> oh, final b

[13:51] <moritz> actually, empty string

[13:51] <pmichaud> correct.

[13:52] <moritz> with + it would match the final b

[13:52] *** JimmyZ joined
[13:52] <pmichaud> right.

[13:52] *** fhelmberger left
[13:54] <moritz> the fun of matching regexes in your head :-)

[13:54] <moritz> it's a good thing we teach machines how to do it, because it's really hard to get right when done by hand :-)

[13:55] <moritz> s/hand/head/

[13:55] <pmichaud> when I first saw the commit I thought "okay, that works", but now that I see some of the effects I'm not so sure.

[13:55] <pmichaud> I kind of think that  "[b ]*"  is superior to   "b *"  in this case.

[13:56] <dalek> roast: 279df78 | moritz++ | S32-io/io-path.t:

[13:56] <dalek> roast: initial tests for IO::Path

[13:56] <dalek> roast: review: https://github.com/perl6/roast/commit/279df78566

[13:58] * pmichaud looks at some JSON::Tiny code

[13:58] <masak> explain to me how /:sigspace b * / matches the *final* 'b'?

[13:58] <aloha> positive: nothing; negative: nothing; overall: 0.

[13:58] <masak> aloha: shut. up.

[13:58] <moritz> masak: :s b *   is like [b<.ws>]* now

[13:58] <tadzik> explain yourself!

[13:58] <aloha> positive: nothing; negative: nothing; overall: 0.

[13:58] <masak> moritz: yes...?

[13:58] <pmichaud> actually, that should be /:sigspace b + / to match the final b.

[13:58] <moritz> masak: and <.ws> doesn't match between b's

[13:58] <moritz> right

[13:59] <moritz> so the only b after which <.ws> matches is the final one

[13:59] <pmichaud> with the * it will be the null string

[13:59] <pmichaud> (as moritz++ said)

[13:59] <masak> oh, <.ws> doesn't match between b's?

[13:59] <pmichaud> <.ws> doesn't match between word chars

[13:59] <masak> right, because it's 'bbbbb'. I see.

[13:59] <moritz> masak: no. <.ws> desguars to  <.ww> | \s+

[13:59] <masak> rightright.

[13:59] <masak> I see it now.

[13:59] <masak> moritz++ pmichaud++

[13:59] <pmichaud> <!ww>

[14:00] <moritz> erm, yes

[14:00] <pmichaud> oh yeah, <.www> might work.  Anyway, it checks for word chars

[14:01] <pmichaud> (I'm on a laggy connection this morning, pardon typos please)

[14:01] <pmichaud> well, in the case of something like <pair> * % ','  I agree that the brackets aren't an improvement.

[14:02] <pmichaud> [<pair> ]* % [',' ]    

[14:07] <pmichaud> for   / <element> + % ',' /   S05:1138 claims a redundancy for the whitespace between <element> and '+' and the '+' and the '%', but I'm not sure it's redundant if the quantifier is '*'

[14:08] <pmichaud> i.e.,  in / <element> * % ',' /   the whitespace isn't redundant.

[14:08] *** thou joined
[14:10] <pmichaud> i.e., it's rewritten to    / [ <element> <.ws> ] * % [ ',' <.ws> ]  <.ws> /    and all of the <.ws>'s are needed.

[14:11] *** zhutingting joined
[14:14] *** tokuhiro_ left
[14:14] *** sergot joined
[14:14] *** pdurbin left
[14:16] *** sergot1 left
[14:19] <pmichaud> I'm also wondering if some of the smarts about when to call consecutive <.ws>'s should be moved into the regex engine itself.

[14:19] <masak> sounds like a good idea.

[14:19] <pmichaud> i.e., to eliminate Rakudo's <MARKED(...)> rule and the equivalents for STD

[14:19] <pmichaud> well, perhaps not eliminate, but definitely to hotpath it

[14:20] <masak> &

[14:21] *** bruges left
[14:28] <pmichaud> jnthn: ping

[14:28] *** GlitchMr joined
[14:30] <[Coke]> ack -ic pir src | awk -F: '{sum +=$2} END{print sum}'

[14:30] <[Coke]> 637

[14:30] <[Coke]> I assume the eventual goal is to move that to 0ish. (by hiding things in NQP instead.)

[14:31] <pmichaud> that number is way too high

[14:32] <pmichaud> sicne it includes src/pmc

[14:32] <pmichaud> *since

[14:33] <[Coke]> pmichaud: only one instance of "pir" in that dir.

[14:33] <pmichaud> yeah, I'm checking that too

[14:33] <[Coke]> (ina  comment)

[14:33] <pmichaud> a *lot* of the pir::'s look like they could be converted to nqp:: now.

[14:33] *** kaare_ joined
[14:34] <pmichaud> try \bpir\b  instead, though.

[14:35] <pmichaud> so you don't get all of the _pirop_mapping calls, and others

[14:35] <pmichaud> and the comments that have words like "expires"  :-)

[14:36] <[Coke]> ack -icw pir | sort -t: -n -k2 # shows 5 files with 30 or more references

[14:37] *** cognominal left
[14:39] <pmichaud> anyway, yes, the goal is to move the pir:: stuff to nqp, but only for stuff that isn't vm-specific.  If it's specific to Parrot, it should remain pir::

[14:40] <pmichaud> i.e, nqp:: shouldn't just be a renaming of parrot opcodes

[14:42] *** cognominal joined
[14:44] *** jaldhar left
[14:45] *** sergot1 joined
[14:47] *** sergot2 joined
[14:47] <[Coke]> should the specific to parrot stuff be in rakudo, though?

[14:47] *** sergot left
[14:49] <pmichaud> I suspect rakudo will have some parrot-specific stuff for a while, yes.

[14:49] *** sergot joined
[14:49] <pmichaud> rakudo-specific stuff probably shouldn't go into nqp

[14:49] *** sergot1 left
[14:49] * JimmyZ thinks it's better to improve parrot other than target other vms

[14:51] <pmichaud> JimmyZ: who will be doing the improving, though?

[14:51] *** sergot2 left
[14:52] <[Coke]> I agree. faster/better rakudo with no work on rakudo would be awesome, though. ;)

[14:53] <[Coke]> s/though//

[14:53] * JimmyZ wonders who will do work to target other vms

[14:53] <[Coke]> Oh, I'd probably work on a JVM target.

[14:54] <[Coke]> Be nice to be able to use perl6 at work.

[14:54] *** mucker left
[14:54] <hoelzro> [Coke]: or on Android =)

[14:54] <[Coke]> JimmyZ: making nqp generate something other than PIR sounds much easier to me than writing C code for parrot.

[14:55] <[Coke]> if writing C code for parrot was easy for me, I'd do more of it, for sure.

[14:55] *** mucker joined
[14:56] <JimmyZ> somebody said the ruby community is so unitive that they only have one framework :)

[14:56] *** kaleem left
[15:01] *** sergot left
[15:03] *** crab2313_ joined
[15:03] <zhutingting> dancer was inspired by sinatra

[15:03] <JimmyZ> 朱婷婷你好

[15:03] <zhutingting> ;-)

[15:05] <zhutingting> many projects were inspired by ruby and python and etc

[15:05] *** crab2313 left
[15:06] *** sergot joined
[15:07] <pmichaud> I'm afk again... bbl

[15:08] <zhutingting> just rip off have fun

[15:15] *** sergot1 joined
[15:18] *** sergot left
[15:21] *** kaleem joined
[15:23] *** kaleem left
[15:27] *** nightlord left
[15:36] <TimToady> masak: \x2028 is discussed in S02:64

[15:39] *** cognominal left
[15:42] <TimToady> arnsholt: re http://irclog.perlgeek.de/perl6/2012-08-01#i_5865547, "Sink me!" --The Scarlet Pimpernel

[15:45] *** cognominal joined
[15:45] *** adu joined
[15:45] *** thelazydeveloper joined
[15:45] <jnthn> pmichaud: pong, though I see you already left

[15:50] *** JimmyZ left
[15:53] *** cognominal left
[15:58] *** Ex joined
[15:58] *** Ex left
[15:58] *** Ex joined
[16:02] *** cognominal joined
[16:08] *** flussence left
[16:08] *** flussence_ joined
[16:09] *** flussence_ is now known as flussence

[16:11] *** Ex left
[16:14] *** am0c joined
[16:25] *** flussence left
[16:27] *** SamuraiJack left
[16:28] *** SamuraiJack joined
[16:29] *** flussence joined
[16:30] <dalek> specs: 0d42d6c | larry++ | S05-regex.pod:

[16:30] <dalek> specs: The spaces are not redundant under *, pmichaud++

[16:30] <dalek> specs: review: https://github.com/perl6/specs/commit/0d42d6cbd3

[16:35] <sorear> good * #perl6

[16:35] <spider-mario> hi

[16:38] <jnthn> o/ sorear 

[16:40] <crab2313_> o/ sorear 

[16:41] *** zhutingting left
[16:43] *** Ex joined
[16:52] *** SamuraiJack left
[16:52] *** spider-mario left
[16:53] <masak> TimToady: yes, but that's the source code. I was talking about .lines

[16:54] <arnsholt> jnthn: When I'm adding a new opcode in NQP to be exposed as an nqp:: does it go in src/PAST/NQP.pir, src/QAST/Operations.nqp or both?

[16:55] *** daxim left
[16:55] *** SamuraiJack joined
[16:57] *** birdwindupbird left
[16:58] *** dakkar left
[16:59] <pmichaud> arnsholt: definitely src/QAST/Operations.nqp .  If the opcode is needed for building nqp itself, then it also needs to go into src/PAST/NQP.pir until we get nqp switched over to QAST

[17:04] <arnsholt> Right. Not gonna bother with PAST then. Cheers

[17:07] <pmichaud> jnthn: ping (re-attempt :)

[17:07] <jnthn> pmichaud: o/

[17:12] *** cognominal left
[17:12] *** bluescreen10 left
[17:12] <pmichaud> how much would it be worth to save an attribute in Cursor?  ;-)

[17:13] <pmichaud> a lot?  a little?

[17:13] <jnthn> pmichaud: Every time I shaved an attribute off QAST::Node we won a measurable amount of memory.

[17:13] <pmichaud> so, worth a fair bit, then? 

[17:13] <jnthn> pmichaud: Er, saved a measurable amount.

[17:14] <jnthn> pmichaud: It's worth something, yes.

[17:14] <jnthn> Which one are you thinking we can lose?

[17:14] <pmichaud> I'm thinking we can combine $!orig and $!target

[17:15] <pmichaud> (and possibly others, but those are the obvious ones)

[17:15] <jnthn> Hmm...how'd we do that?

[17:15] <pmichaud> if we create a struct to hold both of those attributes, since they're invariant over a match, we can keep track of them with a single object reference in each cursor object instead of two

[17:15] <jnthn> Every problem can be solved by... :)

[17:16] <pmichaud> class NQPCursorSource { has $!orig; has str $!target; }

[17:16] <jnthn> Right :)

[17:16] <jnthn> Probably a net win.

[17:16] <pmichaud> then each Cursor just keeps a reference to $!source

[17:16] <pmichaud> we have to do an extra attribute lookup for each subrule invocation, but ....

[17:16] <pmichaud> we also lose an attribute lookup and bind operation for each cursor creation

[17:17] <jnthn> Right, so probably it ties in that regard.

[17:17] <pmichaud> (because we can do a single bind when creating the cursor instead of two)

[17:17] <pmichaud> the NQPCursorSource can also cache information about the overall match

[17:17] <pmichaud> for example, it's an obvious place to keep track of line offsets

[17:18] <pmichaud> (the starting position of each line)

[17:18] <pmichaud> lastly, we could even attach something like STD.pm6's  @*MEMOS array there, to be able to optimize rule stuff

[17:19] <jnthn> Ooh

[17:19] <pmichaud> i.e., we could let the regex engine itself decide not to even call the <.ws> rule when it knows that it's already matched.

[17:20] <jnthn> Are you pondering putting the MARKED thing there? :)

[17:20] <pmichaud> or things like that.

[17:20] <GlitchMr> perl6: :2<1.0011101111100111011011001000101101000011100101011>.print

[17:20] <p6eval> niecza v19-15-g051783d: OUTPUT«1.234»

[17:20] <p6eval> ..rakudo c1bfbb: OUTPUT«1.2340000000000000»

[17:20] <pmichaud> well, being able to wisely handle consecutive <.ws> calls is what led me to it, yes.

[17:21] <pmichaud> STD.pm6 uses @*MEMOS for quite a bit of stuff, though, so it might not be a way to eliminate everything.  But if we can cache some per-match information that lets us prune subrule calls, it might be a really good optimization.

[17:22] <dalek> nqp: df6015a | jnthn++ | src/QAST/Compiler.nqp:

[17:22] <dalek> nqp: Provide a way to let a HLL specify that returned values should always be boxed. Outsourcing this to QAST has various benefits, including keeping this out of the QAST tree itself. Then inlining doesn't have to worry over this detail.

[17:22] <dalek> nqp: review: https://github.com/perl6/nqp/commit/df6015a05e

[17:22] <pmichaud> and having a separate struct to hold $!orig might be a natural place for such per-match scratchpad stuff.

[17:23] <pmichaud> anyway, I think it would be a simple change to make, so I'll go ahead and prototype it.

[17:23] <pmichaud> it will save one str attribute per Cursor, and one bind operation per subrule invocation

[17:24] <dalek> rakudo/nom: 6956baf | jnthn++ | tools/build/NQP_REVISION:

[17:24] <dalek> rakudo/nom: Bump to latest NQP_REVISION for QAST improvements.

[17:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/6956bafff3

[17:24] <dalek> rakudo/nom: 7adef40 | jnthn++ | src/Perl6/ (2 files):

[17:24] <dalek> rakudo/nom: Kill off box_native_if_needed; QAST having HLL-configurable boxing means that we don't need to do it any more. Results: cleaner code, less QAST nodes needed, slight performance/memory win.

[17:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7adef40f9c

[17:24] <jnthn> pmichaud: Sounds good to me.

[17:25] <TimToady> masak: I see nothing in that section that limits "and has consistent Unicode semantics" to the source code.

[17:26] <PerlJam> pmichaud: random peanut gallery question ... would the thing you just proposed also be usable for quantified quantifiers ?  (i.e. so that you know when you've already matched the inner match of something like (a*)* zero times and so can fail faster)

[17:26] <pmichaud> PerlJam: I think I already figured out how to break that loop, using the bstack.

[17:26] <PerlJam> ok

[17:27] <pmichaud> but yes, if my other approach ends up not working then the scratchpad might help.

[17:27] *** mucker left
[17:28] <pmichaud> essentially, I'm thinking that push_mark can refuse to push a duplicate mark onto the bstack

[17:29] <pmichaud> or, it can signal "I already have this mark" and the caller can figure out "oh, I should not loop here"

[17:34] *** sergot joined
[17:35] <jnthn> dinner; bbl

[17:35] *** xinming_ left
[17:36] *** sergot1 left
[17:39] *** am0c left
[17:41] *** am0c joined
[17:41] <moritz> r: my @a = 1..4; say @a[1..*]

[17:41] <p6eval> rakudo c1bfbb: OUTPUT«2 3 4␤»

[17:42] <moritz> r: my @a = 1..4; say @a[1..*-2]

[17:42] <p6eval> rakudo c1bfbb: OUTPUT«2 3␤»

[17:42] *** xinming joined
[17:44] <dalek> doc: e0b2b30 | moritz++ | lib/WhateverCode.pod:

[17:44] <dalek> doc: WhateverCode

[17:44] <dalek> doc: review: https://github.com/perl6/doc/commit/e0b2b301c5

[17:44] <dalek> doc: c73b3cb | moritz++ | lib/Whatever.pod:

[17:44] <dalek> doc: explain that Range operators curry WhateverCode but not Whatever

[17:44] <dalek> doc: review: https://github.com/perl6/doc/commit/c73b3cbe15

[17:44] <dalek> doc: e1ffe9b | moritz++ | lib/Whatever.pod:

[17:44] <dalek> doc: emphasize that Whatever-currying is syntactic

[17:44] <dalek> doc: review: https://github.com/perl6/doc/commit/e1ffe9b04b

[17:47] *** fgomez joined
[17:47] *** fgomez left
[17:49] *** GlitchMr left
[17:49] *** cognominal joined
[17:52] *** fgomez joined
[17:54] <moritz> jnthn: I'm curious about   sub istype  in Actions.pm. In what cases does nqp::istype die?

[17:54] <moritz> if $type isn't a type?

[17:56] <moritz> seems most usages of it have $Pair or so as type, which was retrieved as $*W.find_symbol(['Pair'])

[17:56] <moritz> r: say ObjAt.^mro

[17:56] <p6eval> rakudo c1bfbb: OUTPUT«ObjAt() Any() Mu()␤»

[17:57] *** cognominal left
[18:02] <dalek> doc: a878b89 | moritz++ | lib/Mu.pod:

[18:02] <dalek> doc: Mu.WHICH, ObjAt

[18:02] <dalek> doc: review: https://github.com/perl6/doc/commit/a878b89a36

[18:03] <jnthn> moritz: Type variables

[18:05] <moritz> jnthn: ah

[18:06] <moritz> jnthn: so where the type is clearly not a type variable, we can change it to nqp::istype?

[18:07] <moritz> for example    if istype($type_obj, $*W.find_symbol(['Numeric'])) {

[18:07] <moritz> or does it die $type_obj is a type variable?

[18:07] <jnthn> It's about the LHS too.

[18:08] <moritz> r: role A[::T] { my T enum B <C D> }

[18:08] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Cannot auto-generate a proto method for 'Numeric' in the setting␤»

[18:08] <jnthn> ...wow

[18:09] <moritz> I guess that would need the same declaration deferal as declarations in quasi

[18:09] <jnthn> To the degree we care to make roles that macro-ish, yes

[18:10] * moritz submits LTA error rakudo bug, justin case

[18:10] <moritz> r: role A[::T] { my T $x }

[18:10] <p6eval> rakudo c1bfbb:  ( no output )

[18:12] <moritz> r: role A[::T] { class B is T { } }

[18:12] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Cannot type check against type variable T␤»

[18:18] *** sergot left
[18:19] *** sergot joined
[18:35] *** Coleoid left
[18:35] *** sergot1 joined
[18:37] *** sergot left
[18:37] *** crab2313_ left
[18:47] *** cognominal joined
[18:56] *** cognominal left
[18:56] *** cognominal joined
[19:01] *** sergot joined
[19:02] <[Coke]> .u  *

[19:02] <phenny> U+0001 - ()

[19:02] <phenny> U+0002 - ()

[19:02] <phenny> U+0003 - () [...]

[19:02] <[Coke]> .u *

[19:02] <phenny> U+002A ASTERISK (*)

[19:03] *** sergot1 left
[19:03] *** sergot1 joined
[19:04] <[Coke]> .u *

[19:04] <phenny> U+002A ASTERISK (*)

[19:04] <[Coke]> whew.

[19:05] *** sergot left
[19:08] *** sergot joined
[19:09] *** sergot1 left
[19:12] *** sergot left
[19:12] *** sergot1 joined
[19:14] *** brrt joined
[19:15] *** brrt1 joined
[19:16] <shachaf> preflex: seen ingy

[19:16] <preflex>  ingy was last seen on #perl6 1 day, 21 hours and 44 seconds ago, saying: I think people will get it...

[19:16] *** sergot joined
[19:16] *** GlitchMr joined
[19:18] *** sergot1 left
[19:18] *** brrt left
[19:20] *** sergot1 joined
[19:21] *** sergot left
[19:22] <GlitchMr> http://robert.duckduckgo.com/?q=perl6+lcfirst

[19:22] <GlitchMr> ok...

[19:23] <moritz> http://robert.duckduckgo.com/?q=perl6+tc

[19:24] <moritz> misses a linebreak between the two method signature lines

[19:24] <GlitchMr> I know

[19:24] <moritz> otherwise very cool

[19:24] <GlitchMr> It seems that DuckDuckGo doesn't understand &#10;

[19:25] <GlitchMr> I already have pushed a commit to use <br> instead

[19:25] <GlitchMr> But it might take a while to be pulled into experimental version of DuckDuckGo

[19:25] <crazedpsyc> it's in a <pre>

[19:25] <crazedpsyc> use \n?

[19:26] <GlitchMr> This is so confusing and there is no real documentation

[19:26] <dalek> rakudo/inliner: 558ea68 | moritz++ | src/core/IO.pm:

[19:26] <dalek> rakudo/inliner: remove IO::Path and IO::Dir

[19:26] <dalek> rakudo/inliner: 

[19:26] <dalek> rakudo/inliner: as the deprecation notice predicted

[19:26] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/558ea68780

[19:26] *** dalek left
[19:26] <GlitchMr> Also:

[19:26] <GlitchMr> http://robert.duckduckgo.com/?q=Perl+6+Str

[19:26] <crazedpsyc> yeah, fathead is the next in line to get refactored and documented

[19:26] <GlitchMr> Except something went wrong...

[19:26] *** dalek joined
[19:26] *** ChanServ sets mode: +v dalek

[19:27] <GlitchMr> I guess I've found a bug in DuckDuckGo

[19:27] <moritz> happens :-)

[19:27] <GlitchMr> http://robert.duckduckgo.com/?q=Perl+6+Mu

[19:27] <GlitchMr> :)

[19:27] <crazedpsyc> hah

[19:27] * crazedpsyc adds to bug list

[19:28] <dalek> rakudo/inliner: 4c3f769 | jnthn++ | src/Perl6/ (2 files):

[19:28] <dalek> rakudo/inliner: Elimination of boxable_native, and better handling of literal allomorphy.

[19:28] <dalek> rakudo/inliner: review: https://github.com/rakudo/rakudo/commit/4c3f76931b

[19:28] <moritz> GlitchMr: it would also make sense to show the first paragraph of the description of a type

[19:29] <GlitchMr> Hmmm... yeah...

[19:29] <GlitchMr> That probably could be done by adding generic "Str"

[19:29] *** birdwindupbird joined
[19:29] <GlitchMr> https://github.com/GlitchMr/zeroclickinfo-fathead/blob/perl6-doc/perl6_doc/output.txt

[19:30] <GlitchMr> Well, there is also problem with disambig

[19:31] <GlitchMr> It ought to work, but doesn't (I don't know why)

[19:33] *** GlitchMr left
[19:33] <masak> I don't think 'role A[::T] { my T enum B <C D> }' should be made to work, no.

[19:34] <jnthn> phew ;)

[19:34] <masak> not sure why I think so. I've never seen roles as being that macro-like, I guess.

[19:34] <masak> better to use a macro if that's what you want.

[19:34] <jnthn> Aye

[19:34] <masak> and leave roles to be simple.

[19:34] <jnthn> "simple" :P

[19:34] <masak> well, "si..." what jnthn said ;)

[19:35] *** sergot joined
[19:37] *** sergot1 left
[19:54] <arnsholt> jnthn: Is QAST/Operations.nqp the place to expose things as nqp::? It seems I didn't get beyond pir::

[19:56] <jnthn> arnsholt: Yes, but maybe run what you're adding by Pm or me first :)

[19:57] <jnthn> Also if it's very Perl 6 specific it may belong in src/Perl6/Ops.pm

[20:02] <arnsholt> It's exposing the dyncall writebarrier stuff, so I'm pretty sure it has to be in NQP first

[20:03] *** fibo joined
[20:03] <lue> hello world o/

[20:05] <jnthn> arnsholt: ah, yes, then add it with the other nativecall ops

[20:05] <masak> lue! \o/

[20:06] *** cognominal left
[20:08] *** SamuraiJack left
[20:09] <arnsholt> jnthn: Cool. I'll see if I can figure out why it's not working then =)

[20:18] <lue> masak: I can't get my demo game to work, would you like to take a look at it?

[20:19] <moritz> arnsholt: are you using it in rakudo or in nqp?

[20:22] <arnsholt> Using it from Rakudo

[20:22] <arnsholt> Doesn't work from the NQP REPL either, actually

[20:23] <moritz> did you install nqp?

[20:23] <moritz> (stupid question, I know)

[20:23] *** cognominal joined
[20:24] <jnthn> Wait, using it in Perl 6 code or in NQP code?

[20:24] <masak> lue: sure.

[20:25] <lue> https://github.com/lue/skytemple/blob/master/demo/demo.p6

[20:26] <masak> lue: BUILD sybmethod looks good.

[20:26] <masak> sub*

[20:26] <masak> lue: oh, but you need .place_player, too

[20:26] <lue> Specifically it's a "Cannot look up attributes in a type object" error once you try to type in a command :/

[20:26] <lue> oh. That would help :)

[20:26] *** brrt1 left
[20:27] <arnsholt> moritz: Yeah, it's installed

[20:27] <masak> lue: my $game = IFGame::Demo;

[20:27] <masak> lue: need .new there.

[20:28] <masak> that's why you get the "type object" error.

[20:30] <lue> Alright, got everything fixed (although going north from the bunker doesn't cause the remarks. At least I can play now :) )

[20:30] <moritz> that error always means a method isn't strict enough on its invocant

[20:31] *** brrt joined
[20:31] *** sergot1 joined
[20:32] <masak> lue: in the final for @events, you need to handle Adventure::GameRemarked. see crypt.

[20:32] *** sergot left
[20:32] <lue> masak: just saw that poking through crypt.

[20:33] <arnsholt> Hmm. Looks like I might've forgotten to rebuild Rakudo

[20:33] <arnsholt> Thought I'd done it

[20:33] *** sergot joined
[20:33] <masak> lue: the CLI is a "read side", with "event listeners" that mostly print updates for the user.

[20:34] <lue> OK. I feel I'm starting to get the hang of how to use Adventure::Engine.

[20:35] *** cognominal left
[20:35] <masak> yay.

[20:35] *** sergot1 left
[20:35] <masak> lue++ # Adventure::Engine's first downstream!

[20:36] <masak> let me know of any feature requests, and we'll discuss them.

[20:36] <masak> I haven't forgotten about your noun synonym one.

[20:36] <masak> and feedback from other sources tells me I want something like that.

[20:36] *** cognominal joined
[20:36] <lue> I feel I'll get more used to it when I write a sub MAIN without any stolen^Wborrowed code from crypt. :)

[20:39] *** sergot left
[20:39] <masak> aye, good idea.

[20:39] *** brrt left
[20:42] *** adu left
[20:51] <dalek> Heuristic branch merge: pushed 55 commits to nqp/toqast by jnthn

[20:52] *** birdwindupbird left
[20:53] <moritz> toqast?

[20:53] <moritz> jnthn: are you reviving that branch?

[20:54] <dalek> doc: 2b6e4f4 | (Felix Herrmann)++ | lib/Date.pod:

[20:54] <dalek> doc: [Date] fix duplicated text

[20:54] <dalek> doc: review: https://github.com/perl6/doc/commit/2b6e4f4c3d

[20:56] <jnthn> moritz: Yes, for its original purpose :)

[20:56] <dalek> doc: d864a34 | moritz++ | lib/Date.pod:

[20:56] <dalek> doc: [Date] fix duplicate word

[20:56] <dalek> doc: review: https://github.com/perl6/doc/commit/d864a34ddc

[20:56] <moritz> jnthn: oh, moving nqp to qast

[20:56] <jnthn> Right :)

[20:57] <jnthn> Initial bits of the work are quite mechanical, so just picking off a little of it.

[20:58] <jnthn> (Inliner is coming along, but I need some time to ponder literal allomorphism stuff...)

[20:58] <felher> :/ ... the commit at least got moritz to fix it ...

[20:58] <felher> * moritz++ to fix it

[20:59] *** fibo_ joined
[20:59] <moritz> felher: I found it quite amusing, you removed duplicate sentence fragment, I removed duplicate word :-)

[20:59] * moritz -> sleep

[21:00] <felher> moritz: sleep well :)

[21:00] *** fibo left
[21:00] <masak> moritz: dream of duplicate removals of duplicate things.

[21:00] *** fibo_ is now known as fibo

[21:04] *** skids left
[21:04] <fibo> hi! works only on chrome : http://tris3d.com/

[21:04] *** fibo left
[21:12] <dalek> nqp/toqast: ae3c767 | jnthn++ | / (5 files):

[21:12] <dalek> nqp/toqast: Add a temporary NQPQ to do the initial bits of QAST migration; yes, the missing dependency in the Makefile is deliberate.

[21:12] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/ae3c767984

[21:17] *** kaare_ left
[21:18] <dalek> rakudo/nom: eb46da2 | jnthn++ | src/Perl6/Actions.pm:

[21:18] <dalek> rakudo/nom: Toss a use statement that we no longer need.

[21:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/eb46da2d70

[21:19] *** atrodo left
[21:20] <masak> ...a 'use' statement that we no longer 'need'... :P

[21:20] <jnthn> We totally don't require it any more, dude!

[21:21] <jnthn> Totally unimportant.

[21:26] <masak> ;)

[21:34] *** benabik left
[21:47] <dalek> nqp/toqast: 077f198 | jnthn++ | src/NQPQ/ (2 files):

[21:47] <dalek> nqp/toqast: Translate PAST::Stmt/PAST::Stmts to QAST::Stmt/QAST::Stmts.

[21:47] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/077f19882a

[21:47] <dalek> nqp/toqast: c58ae6d | jnthn++ | src/NQPQ/Actions.pm:

[21:47] <dalek> nqp/toqast: Do a bunch of the easy PAST => QAST translations.

[21:47] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/c58ae6d130

[21:47] <jnthn> Well, there's that little project started.

[21:50] <masak> jnthn++

[21:52] <jnthn> The good thing: NQP is rather smaller than Rakudo. The bad thing: NQP relies much more heavily on things I tossed in QAST that will not be coming back.

[21:54] <sorear> NQPQ is the part where we convert NQP to use QAST and drop PAST for good?

[21:54] <jnthn> Right.

[21:54] <jnthn> I also get to kill off use of Parrot Undef along the way.

[21:54] <jnthn> That will...have some fallout.

[21:55] <jnthn> (Like, less suckage in the codebase...)

[21:55] <sorear> we use parrot undef?

[21:55] <jnthn> NQP does, sadly.

[21:55] <sorear> ++jnthn

[21:56] *** bluescreen10 joined
[21:56] <jnthn> Well, NQP was initially Perl 6 like syntax on top of Parrot primitives, and times have kinda changed since.

[22:04] *** benabik joined
[22:05] *** bluescreen100 joined
[22:06] *** bluescreen100 left
[22:06] *** bluescreen10 left
[22:10] *** cognominal left
[22:15] *** PacoAir left
[22:20] *** cognominal joined
[22:22] <jnthn> rest &

[22:23] *** am0c left
[22:44] <masak> 'night, #perl6

[22:45] *** skids joined
[22:58] *** mscha left
[23:03] *** cognominal left
[23:03] *** cognominal joined
[23:10] *** cognominal left
[23:14] *** ggoebel joined
[23:19] *** whiteknight joined
[23:20] *** whiteknight is now known as Guest21411

[23:22] *** thou left
[23:31] *** raiph left
[23:39] *** MayDaniel left
[23:55] *** cognominal joined
[23:58] *** thelazydeveloper left
