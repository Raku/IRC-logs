[00:02] <colomon> o/

[00:05] *** tokuhirom left
[00:08] *** Maddingu1 joined
[00:09] *** Maddingue left
[00:09] *** rafl left
[00:10] *** rafl joined
[00:15] *** rjbs- joined
[00:15] *** jrockway_ joined
[00:16] *** geekosaur left
[00:16] *** jrockway left
[00:16] *** Vlavv` left
[00:16] *** rjbs left
[00:16] *** eviltwin_b joined
[00:17] *** Vlavv` joined
[00:19] *** bbkr2 joined
[00:21] *** rafl left
[00:21] *** bbkr1 left
[00:21] *** rafl joined
[00:23] <TimToady> maybe we should outlaw precedence traits on multi candidates?

[00:25] <TimToady> after all, that's changing the language, so should follow lexical macro scoping rules really

[00:26] *** Maddingu1 is now known as Maddingue

[00:28] <TimToady> re flattening, the real issue here is that different declarators want different semantics for their initializers, so I think I need to make a table so we can all glare at it

[00:39] <dalek> niecza: 9a50d69 | sorear++ | src/ (2 files):

[00:39] <dalek> niecza: Tweak parameter name generation to work more like Rakudo

[00:39] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9a50d6979f

[00:44] <sorear> now that pmichaud++ is back I stand a decent chance of understanding LoL context and the difference between list and flat

[00:45] <sorear> niecza is treating constant @foo = ... as binding to @(...), that is (...).list

[00:49] <dalek> specs: 57a871c | larry++ | S06-routines.pod:

[00:49] <dalek> specs: outlaw macro-ish traits on multi

[00:49] <dalek> specs: review: https://github.com/perl6/specs/commit/57a871c7ab

[00:51] <TimToady> I suspect it should probably be more like binding to *@foo, but I need to see how my table turns out

[00:51] <sorear> I also don't understand how [||] 1, 0, 1..* is possibly supposed to work

[00:51] <TimToady> it's a lazy list

[00:53] <TimToady> it quits after reading the first 1

[00:53] <TimToady> of course [||] 0 xx * is going to hang

[00:59] *** Trashlord joined
[00:59] <sorear> TimToady: but generic [] has to turn the lazy list into a Capture

[01:00] <colomon> TimToady: it's easy to see how you can implement it as a special case, but how do you implementation it as an example of a general case?

[01:03] <TimToady> which general case are you thinking of? thunky, or list associative?  the latter need to have a (*@args) form if the semantics differ from binary; thunk suppression is a separate issue

[01:04] <TimToady> as it happens, || can probably work from the binary semantics, but ^^ can't

[01:04] <TimToady> not without playing games like Icon does, anyway

[01:04] *** Chillance left
[01:07] *** sftp_ left
[01:12] *** clkao_ is now known as clkao

[01:34] <dalek> niecza: b2c1062 | sorear++ | lib/ (2 files):

[01:34] <dalek> niecza: Improved Rakudo-inspired Str.perl

[01:34] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b2c10620d3

[01:37] *** lutok joined
[01:44] <TimToady> if we get bad connectivity to host02 on Tuesday, it's probably another solar flare

[01:46] <sorear> hmm... does that mean that the problems are caused by particles moving much slower than c, and so we have warning because we saw a flare?

[01:48] <colomon> niecza: say 1

[01:48] <p6eval> niecza v13-335-g9a50d69: OUTPUT«1␤»

[01:48] <colomon> how to we trigger a rebuild?

[01:49] <colomon> (evalbot, I mean)

[01:51] <TimToady> sorear: yes

[01:55] <dalek> roast: e7c703c | (Solomon Foster)++ | S02-names-vars/perl.t:

[01:55] <dalek> roast: Fudge test which now fails, unfudge a batch which now work.

[01:55] <dalek> roast: review: https://github.com/perl6/roast/commit/e7c703c5ac

[01:57] *** wolfman2000 joined
[02:00] <sorear> evalbot rebuild niecza

[02:00] <p6eval> OK (started asynchronously)

[02:01] *** thou left
[02:01] <dalek> Rebuild of niecza complete.

[02:02] *** xinming joined
[02:06] *** drbean joined
[02:11] *** drbean left
[02:17] *** drbean joined
[02:19] *** whiteknight left
[02:23] <colomon> sorear++

[02:23] <dalek> roast: 48791d6 | (Solomon Foster)++ | S05- (2 files):

[02:23] <dalek> roast: Unfudge tests that now work in niecza.

[02:23] <dalek> roast: review: https://github.com/perl6/roast/commit/48791d6822

[02:25] <dalek> niecza: 566fb13 | sorear++ | / (2 files):

[02:25] <dalek> niecza: Fix "\r\n".perl

[02:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/566fb13d29

[02:28] *** lutok left
[02:29] <dalek> roast: a39b6df | (Solomon Foster)++ | S02-names-vars/perl.t:

[02:29] <dalek> roast: Unfudge test that sorear++ just fixed.

[02:29] <dalek> roast: review: https://github.com/perl6/roast/commit/a39b6df656

[02:43] *** thou joined
[02:53] *** Radvendii joined
[02:53] <Radvendii> i just had a great idea for debugging in perl6

[02:54] <Radvendii> Have a function that enters an interactive loop (like when you just type in perl6 in the command line) and it exits when you type in a different command.

[02:54] <Radvendii> so you can just stick it into the program

[02:54] <Radvendii> and then check variables as you need, modify them if you want, etc

[03:00] <Radvendii> eh?

[03:00] *** cognominal left
[03:00] <Radvendii> what'd'ya guys think?

[03:02] <abercrombie> Hi all,   my $str = "abcccdef"; if $str ~~ /ab <?before (c) $0**2> (.*)/ { say $0;} how can I get 'c' instead of 'cccdef'? I want the 2nd $0 be the same as the first $0

[03:02] *** cognominal joined
[03:03] <Radvendii> nom: my $str = "abcccdef"; if $str ~~ /ab <?before  (c) $0**2> (.*)/ { say $0;}

[03:03] <p6eval> nom 4ffbd6: OUTPUT«=> <cccdef>␤␤»

[03:03] <sorear> Radvendii: it's a great idea, I had it a few weeks ago but I haven't gotten around to implementing it

[03:04] <sorear> Radvendii: it's already available for Perl 5 in the Devel::REPL and Carp::REPL modules

[03:04] <Radvendii> nom: my $str = "abcccdef"; if $str ~~ /ab <?before  (c) $0**2> [.*]/ { say $0;}

[03:04] <p6eval> nom 4ffbd6: OUTPUT«Any()␤»

[03:04] <Radvendii> sorear: oh, okay. sweet.

[03:05] <sorear> abercrombie: Why do you have the (.*) in there at all?

[03:05] <Radvendii> sorear: also, is there a way to tell from within a sub what called that sub

[03:05] <sorear> 'caller'

[03:05] <Radvendii> woah

[03:05] <sorear> nom: say caller.^methods

[03:05] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&caller' called (line 1)␤»

[03:05] <sorear> nom: say callframe(1).^methods

[03:05] <p6eval> nom 4ffbd6: OUTPUT«new line file callframe level annotations my␤»

[03:05] <TimToady> while prompt "And then? " -> $a { eval $a }

[03:06] <abercrombie> sorear: because I use that to verify which is the real '$0'

[03:07] <sorear> abercrombie: <?before> by its nature forgets everything inside

[03:07] <sorear> abercrombie: if you don't want the forgetting, you'll need to save state with a {}-block, or use a conjuction instead, or something

[03:07] <abercrombie> so there is no way to refer to it later? in perl5 I can refer to it

[03:07] <abercrombie> a {} block? can you show me a simple example?

[03:15] <Radvendii> sorear: what do you think about the idea that if you call, let's say @a.unknownmethod, instead of just failing, it first tries unknownmethod(@a). that would remove the need to implement things twice to make them functions and methods...

[03:19] *** lutok joined
[03:24] <abercrombie> sorear: {} works, thanks, I will try that in my example

[03:25] *** orafu left
[03:25] *** orafu joined
[03:27] <Radvendii> what's the diference between ^^ and ^

[03:27] <abercrombie> begin of word vs begin of line

[03:27] <Radvendii> not in regex

[03:28] <Radvendii> as in 

[03:28] <Radvendii> nom: 1 ^^ 0

[03:28] <p6eval> nom 4ffbd6:  ( no output )

[03:28] <abercrombie> not include vs include

[03:28] <Radvendii> nom: say 1 ^^ 0

[03:28] <p6eval> nom 4ffbd6: OUTPUT«1␤»

[03:28] <abercrombie> oh, no, I know what you mean

[03:28] <Radvendii> nom: say 1 ^ 0

[03:28] <p6eval> nom 4ffbd6: OUTPUT«one(1, 0)␤»

[03:28] <Radvendii> oh

[03:28] <Radvendii> i know

[03:29] <Radvendii> it's like & vs &&

[03:29] <Radvendii> ^ creates a junction ^^ just evaluates

[03:32] <abercrombie> really? I think xor should be +^ instead of ^^

[03:32] <abercrombie> nom: say 1^^3

[03:32] <p6eval> nom 4ffbd6: OUTPUT«Nil␤»

[03:32] <colomon> that's bitwise, ^^ is logical

[03:33] <Radvendii> is there a way to cross (X) with the application of a function?

[03:34] <Radvendii> so i would say ( * + 1, *+2) X 1,2

[03:34] <Radvendii> and it would spit out 2,3,3,4

[03:34] <Radvendii> (obviously, i'd being using more than just addition

[03:34] <Radvendii> )

[03:34] *** xinming left
[03:35] *** xinming joined
[03:35] <abercrombie> what's your expected output?

[03:35] <Radvendii> what do you mean?

[03:35] <abercrombie> colomon: I didn't get it

[03:36] <abercrombie> nom: say 1 ^^ 1

[03:36] <p6eval> nom 4ffbd6: OUTPUT«Nil␤»

[03:36] <colomon> nom: say "blue" ^^ "green"

[03:36] <p6eval> nom 4ffbd6: OUTPUT«Nil␤»

[03:36] <doy> nom: say (* + 1, * + 2) X 1, 2

[03:36] <p6eval> nom 4ffbd6: OUTPUT«_block1011 1 _block1011 2 _block1015 1 _block1015 2␤»

[03:36] <colomon> ^^ is logical & short-circuiting the way && and || are

[03:36] <doy> nom: say ((* + 1, * + 2) X 1, 2)()

[03:36] <p6eval> nom 4ffbd6: OUTPUT«Method 'postcircumfix:<( )>' not found for invocant of class 'List'␤  in <anon> at src/gen/Metamodel.pm:3418␤  in block <anon> at /tmp/mh5VjCvugM:1␤  in <anon> at /tmp/mh5VjCvugM:1␤»

[03:37] <colomon> nom: say ((* + 1, * + 2) X 1, 2)>>.()

[03:37] <p6eval> nom 4ffbd6: OUTPUT«Not enough positional parameters passed; got 0 but expected 1␤  in whatevercode <anon> at /tmp/wvXVlTrRua:1␤  in method reify at src/gen/CORE.setting:4471␤  in method reify at src/gen/CORE.setting:4376␤  in method reify at src/gen/CORE.setting:4376␤  in method gimme a…

[03:37] <abercrombie> colomon: so it's a NYI now?

[03:37] <colomon> abercrombie: what is?

[03:37] <abercrombie> ^^

[03:37] <colomon> no, it's working in the above examples

[03:38] <colomon> nom: say "blue" ^^ False

[03:38] <p6eval> nom 4ffbd6: OUTPUT«blue␤»

[03:38] <colomon> nom: say "blue" ^^ False ^^ False

[03:38] <p6eval> nom 4ffbd6: OUTPUT«blue␤»

[03:38] <colomon> nom: say "blue" ^^ False ^^ False ^^ "green"

[03:38] <p6eval> nom 4ffbd6: OUTPUT«Nil␤»

[03:38] <benabik> nom: say 0 but True ^^ 'bob' but False

[03:38] <Radvendii> there is a bug with [^^] however

[03:38] <p6eval> nom 4ffbd6: OUTPUT«bob␤»

[03:38] *** Psyche^ joined
[03:38] <Radvendii> BUT??

[03:39] <abercrombie> oh, i see

[03:39] <colomon> nom: say (0 but True) ^^ ('bob' but False)

[03:39] <p6eval> nom 4ffbd6: OUTPUT«bob␤»

[03:39] <Radvendii> oh, i remember but now

[03:39] <Radvendii> nom: say [^^] 1,1,1

[03:39] <colomon> that seems wrong to me...

[03:39] <p6eval> nom 4ffbd6: OUTPUT«1␤»

[03:40] <Radvendii> that's also wrong

[03:40] <Radvendii> :P

[03:40] <benabik> nom: say 1 ^^ 1 ^^ 1

[03:40] <p6eval> nom 4ffbd6: OUTPUT«Nil␤»

[03:40] <colomon> right (it's wrong)

[03:40] <Radvendii> in any case, is there a way to cross apply functions yet?

[03:42] *** Patterner left
[03:42] *** Psyche^ is now known as Patterner

[03:42] <colomon> other than directly calling the routine that implements Xop (which is probably not spec) I can't think of anything.

[03:42] <colomon> but if you define an operator....

[03:43] <Radvendii> which applies a sub

[03:43] <Radvendii> like in haskell

[03:43] <colomon> nom: sub infix:<apply>(&a, $b) { a($b); }; say ((* + 1, * + 2) Xapply (1, 2))

[03:43] <p6eval> nom 4ffbd6: OUTPUT«2 3 3 4␤»

[03:43] *** lutok left
[03:44] <Radvendii> BAM

[03:44] <colomon> niecza: sub infix:<apply>(&a, $b) { a($b); }; say ((* + 1, * + 2) Xapply (1, 2))

[03:44] * Radvendii applaudes colomon++

[03:44] <Radvendii> i feel like that is a worthwhile operator to have in the main code.

[03:45] <colomon> implementing new operators to take advantage of the meta ops is a handy trick to keep in your toolkit

[03:45] <Radvendii> yeah, i didn't know that was possible, but it makes sense

[03:47] <colomon> I hope in the long run there will be a normal sub interface for all the metaop routines, because implementing an operator and just using it once is kind of cheesy, IMO.

[03:47] <colomon> bedtime.  'night all.

[03:48] <Radvendii> now i dont know what to call it... :P

[03:48] <Radvendii> o/

[03:56] <Radvendii> o̊O

[03:56] <Radvendii> what's a hyperwhatever?

[03:56] <Radvendii> it says it's not yet implemented...

[03:59] <sorear> Radvendii: @a.foo falling back to foo(@a) - this used to be how it was done, but they changed it, before my time

[03:59] <sorear> Radvendii: ** in term context is "hyperwhatever"

[03:59] <sorear> it's reserved syntax for use with multidim arrays

[04:00] <Radvendii> yay :D more Splats!

[04:00] <Radvendii> :P

[04:00] <doy> that's how it works in perl 5, and it's almost universally hated

[04:00] <Radvendii> why is it hated?

[04:00] <doy> makes it really hard to tell how something is going to parse

[04:00] <doy> and leads to confusing error messages

[04:01] <doy> actually, it works the other way around in perl5, never mind

[04:01] <Radvendii> i guess...

[04:01] <Radvendii> i guess i tend to think about methods as infix operators with an object on one side and a list on the other

[04:05] <Radvendii> nom: $a="h"; say "hi"~~/$a/

[04:05] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "=\"h\"; say "␤»

[04:05] <Radvendii> nom: my $a="h"; say "hi"~~/$a/

[04:05] <p6eval> nom 4ffbd6: OUTPUT«=> <h>␤␤»

[04:05] <Radvendii> how do i make an argument optional?

[04:06] <sorear> add ?

[04:06] <Radvendii> thanks

[04:07] <Radvendii> or just give it a default value, right?

[04:07] *** shinobicl_ joined
[04:11] <Radvendii> i <3 perl. where you can turn 5 lines into one, with the bat of an eye

[04:12] <Radvendii> and somehow, it ends up MORE readable than any other language...

[04:17] <sorear> nom: sub foo($x = 5) { }; say &foo.signature.params[0].optional

[04:17] <p6eval> nom 4ffbd6: OUTPUT«Bool::True␤»

[04:18] <Radvendii> haha, nice.

[04:18] <sorear> ?

[04:18] <sorear> at me?

[04:18] <Radvendii> i just think the &foo.signature.params[0].optional line is funny

[04:20] *** packetknife joined
[04:20] *** packetknife left
[04:21] *** packetknife joined
[04:21] <Radvendii> nom: "a" ~~ /a/; say $0

[04:21] <p6eval> nom 4ffbd6: OUTPUT«Any()␤»

[04:22] <Radvendii> nom: "a" ~~ /(a)/; say $0

[04:22] <p6eval> nom 4ffbd6: OUTPUT«=> <a>␤␤»

[04:22] <Radvendii> nom: "a" ~~ /(a)/; given "b" {when 'b' {}} say $0

[04:22] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Confused at line 1, near "given \"b\" "␤»

[04:23] <Radvendii> nom: "a" ~~ /(a)/; given "b" {when 'b' {say "in"}} say $0

[04:23] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Confused at line 1, near "given \"b\" "␤»

[04:23] <Radvendii> huh?

[04:24] <Radvendii> nom: "a" ~~ /(a)/; given "b" {when 'b' {say "in"}}; say $0

[04:24] <p6eval> nom 4ffbd6: OUTPUT«in␤=> <a>␤␤»

[04:25] <Radvendii> ah

[04:26] <Radvendii> is there a shorthand for $a eq 'b' ?? 'c' !! 'b'

[04:26] <Radvendii> as in, like !$a except that $a is not a boolean

[04:26] <Radvendii> you want to make it the inverse, of an enumeration

[04:27] <Radvendii> oh

[04:28] <Radvendii> nom: $a='b'; (a,b).grep($a)

[04:28] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "='b'; (a,b"␤»

[04:28] <Radvendii> nom: my $a='b'; (a,b).grep($a)

[04:28] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a' called (line 1)␤Undefined routine '&b' called (line 1)␤»

[04:28] <Radvendii> nom: my $a='b'; <a b>.grep($a)

[04:28] <p6eval> nom 4ffbd6:  ( no output )

[04:28] <Radvendii> nom: my $a='b'; say <a b>.grep($a)

[04:28] <p6eval> nom 4ffbd6: OUTPUT«b␤»

[04:29] <Radvendii> nom: my $a='b'; say <a b>.grep(!$a)

[04:29] <p6eval> nom 4ffbd6: OUTPUT«␤»

[04:29] <sorear> * ne $a, maybe

[04:29] <Radvendii> nom: my $a='b'; say <a b>.grep(* ne$a)

[04:29] <doy> nom: my $a = 'c'; say <b c>[$a eq 'b']

[04:29] <p6eval> nom 4ffbd6: OUTPUT«a␤»

[04:29] <p6eval> nom 4ffbd6: OUTPUT«b␤»

[04:30] *** packetknife left
[04:30] <Radvendii> nom: my $a='b'; say <a b>.grep(* ne $a)

[04:30] <p6eval> nom 4ffbd6: OUTPUT«a␤»

[04:30] <Radvendii> alright

[04:31] <Radvendii> that does it

[04:36] *** birdwindupbird joined
[04:37] *** packetknife joined
[04:41] <Radvendii> What method do i overload to do more initialization after the 

[04:41] <Radvendii> "has"ed variables have been initialized?

[04:44] <sorear> you write a submethod BUILD

[04:44] *** rsimoes1 left
[04:44] <sorear> although technically it's supposed to run BEFORE has initialization

[04:44] <Radvendii> exactly

[04:44] <Radvendii> and then initialization doesn't occur

[04:46] <Radvendii> nom: class A {$.b=3; submethod BUILD {$a does role {method test {} } } } say A.new.b;

[04:46] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near " does role"␤»

[04:46] <Radvendii> nom: class A {$.b=3; submethod BUILD {$.b does role {method test {} } } } say A.new.b;

[04:46] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Confused at line 1, near "class A {$"␤»

[04:47] <Radvendii> nom: class A {ihas $.b=3; submethod BUILD {$.b does role {method test {} } } } say A.new.b;

[04:47] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Confused at line 1, near "class A {i"␤»

[04:47] <Radvendii> haha, ihas. been using vim too much :P

[04:47] <Radvendii> nom: class A {has $.b=3; submethod BUILD {$.b does role {method test {} } } } say A.new.b;

[04:47] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Confused at line 1, near "class A {h"␤»

[04:47] <sorear> needs more ;s

[04:47] <TimToady> Radvendii: you overload BUILDALL if you really want to get the final say

[04:47] <Radvendii> nom: class A {has $.b=3; submethod BUILD {$.b does role {method test {} } } }; say A.new.b;

[04:48] <p6eval> nom 4ffbd6: OUTPUT«Cannot use 'does' operator with a type object␤  in sub infix:<does> at src/gen/CORE.setting:8661␤  in submethod BUILD at /tmp/qrd10ZVU0z:1␤  in method BUILDALL at src/gen/CORE.setting:583␤  in method bless at src/gen/CORE.setting:573␤  in method new at src/gen/CORE.se…

[04:48] <sorear> (but Perl 6 *still* doesn't have anything like Moose's "after")

[04:49] <Radvendii> nom: class A {has $.b=3; submethod BUILD {$.b = 2} }; say A.new.b;

[04:49] <p6eval> nom 4ffbd6: OUTPUT«Cannot assign to a readonly variable or a value␤  in submethod BUILD at /tmp/iBQTLYkMkD:1␤  in method BUILDALL at src/gen/CORE.setting:583␤  in method bless at src/gen/CORE.setting:573␤  in method new at src/gen/CORE.setting:558␤  in block <anon> at /tmp/iBQTLYkMkD:1␤…

[04:49] <Radvendii> nom: class A {has $.b=3 is rw; submethod BUILD {$.b = 2} }; say A.new.b;

[04:49] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[04:49] <Radvendii> nom: class A {has $.b=3 is rw; submethod BUILD {$.b = 2}; }; say A.new.b;

[04:49] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[04:50] <Radvendii> i dont understand...

[04:50] <TimToady> std: class A {has $.b=3 is rw; submethod BUILD {$.b = 2}; }; say A.new.b;

[04:50] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/2H5eNxibqF line 1:␤------> class A {has $.b=3 ⏏is rw; submethod BUILD {$.b = 2}; }; say␤    expecting any of:␤ bracketed infix␤        infix or meta-infix␤    statement modifier loop␤Parse failed␤FAIL…

[04:51] <TimToady> doesn't make sense to have '3 is rw' :)

[04:51] <Radvendii> nom: class A {has $.b is rw=3; submethod BUILD {$.b = 2}; }; say A.new.b;

[04:51] <p6eval> nom 4ffbd6: OUTPUT«2␤»

[04:51] <Radvendii> so BUILD executes first, yet the output is 2

[04:52] <TimToady> the default is used only if it's needed

[04:52] <Radvendii> but i think it also get's ousted if you do something like $.b does MyRole in BUILD

[04:52] <TimToady> it's wasted energy to initialize it one way and then the other, so it only does one or the other

[04:54] * TimToady wonders if there's way to lazily attach the default to the first FETCH

[04:54] <TimToady> then you could say $.b += 2 and it'd fetch the default if there's a fetch before the store

[04:56] <TimToady> but if you store before fetch, it never needs to evaluate the default thunk

[04:56] <Radvendii> nom: role MyRole {method hello {say "hi"} }; my @a does MyRole; @a.hello;

[04:56] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Array'␤  in block <anon> at /tmp/fFHCyI9lmE:1␤  in <anon> at /tmp/fFHCyI9lmE:1␤»

[04:57] <sorear> TimToady: I'm pretty sure jnthn++ has talked about doing just that in the past

[04:57] <TimToady> not that I've noticed, but I'm not (quite) omniscient...

[04:58] <TimToady> anyway, if it can be made to work nicely, we can logically apply the initializers first without wasting much effort

[04:58] <dalek> niecza: 9a16f57 | sorear++ | lib/Kernel.cs:

[04:58] <dalek> niecza: |$foo capture current state, not initial state

[04:58] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9a16f57d44

[04:59] <TimToady> the apply after is just laziness reinvented poorly, in that view of things

[05:00] <Radvendii> is there a way to say something like <a b c> does role MyRole and have it work?

[05:00] <TimToady> but if you have 'has $.b = die "Didn't initialize required attribute"' it had better not call the thunk unless you actually fetch it first

[05:01] <doy> nom: role MyRole {method hello {say "hi"} }; my @a is MyRole; @a.hello;

[05:01] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Array'␤  in block <anon> at /tmp/axSM9c9On4:1␤  in <anon> at /tmp/axSM9c9On4:1␤»

[05:01] <TimToady> you can't modify the type of data in place; you need to use 'but' instead of 'does'

[05:01] <doy> nom: role MyRole {method hello {say "hi"} }; my @a ub MyRole; @a.hello;

[05:01] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Confused at line 1, near "my @a ub M"␤»

[05:01] <doy> nom: role MyRole {method hello {say "hi"} }; my @a but MyRole; @a.hello;

[05:01] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Array'␤  in block <anon> at /tmp/XyDcKQvlzO:1␤  in <anon> at /tmp/XyDcKQvlzO:1␤»

[05:02] <sorear> 'does' there is a trait modifying the declarator

[05:02] <sorear> not the 'does' operator

[05:02] <TimToady> I was ansering the <a b c> question

[05:02] <Radvendii> huh?

[05:03] <Radvendii> oh

[05:03] <dalek> niecza: cecbb7c | sorear++ | / (4 files):

[05:03] <dalek> niecza: First batch of signature introspection additions, largely cribbed from Rakudo

[05:03] <dalek> niecza: review: https://github.com/sorear/niecza/commit/cecbb7cb12

[05:04] <TimToady> nom: role MyRole {method hello {say "hi"} }; my @a := [<a b c>] but MyRole; @a.hello

[05:04] <p6eval> nom 4ffbd6: OUTPUT«hi␤»

[05:04] <TimToady> like that

[05:06] <Radvendii> nom: role MyRole {method hello {say "hi"} }; Class A {has @a := [<a  b c>] but MyRole,[<d,e,f>] but MyRole;}; A.new.a[0].hello

[05:06] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤You can't declare an attribute here; maybe you'd like a class or a role? at line 1, near " := [<a  b"␤»

[05:06] <Radvendii> nom: role MyRole {method hello {say "hi"} }; Class A {has @a := [<a  b c>] does MyRole,[<d,e,f>] does MyRole;}; A.new.a[0].hello

[05:06] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤You can't declare an attribute here; maybe you'd like a class or a role? at line 1, near " := [<a  b"␤»

[05:07] <TimToady> a 'does' must come before the block

[05:07] <Radvendii> what do you mean?

[05:07] <TimToady> oh, wait, I was misreading

[05:07] <benabik> Are keywords case sensitive?   'Class A' vs 'class A'

[05:07] <TimToady> you're more confused than I thought  :)

[05:08] <TimToady> yes, keywords are case sensitive

[05:09] <Radvendii> TimToady: do you see what i'm trying to do?

[05:09] *** Trashlord left
[05:09] <TimToady> yes, I see that you're trying to confuse me, which is redundant :)

[05:11] <Radvendii> haha. no. im trying to make it "has" an array of anonymous arrays, all of which "does" a role

[05:11] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has @a = [<a b c>] but MyRole, [<d e f>] but MyRole }; A.new.a[0].hello

[05:11] <p6eval> nom 4ffbd6: OUTPUT«Method 'a' not found for invocant of class 'A'␤  in block <anon> at /tmp/a4oc4_ZhDP:1␤  in <anon> at /tmp/a4oc4_ZhDP:1␤»

[05:12] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has @.a = [<a b c>] but MyRole, [<d e f>] but MyRole }; A.new.a[0].hello

[05:12] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Str'␤  in block <anon> at /tmp/iUDrjtg6tm:1␤  in <anon> at /tmp/iUDrjtg6tm:1␤»

[05:13] <sorear> TimToady: in sub foo(|bar) { ... }, is the name of the introduced variable 'bar' or '|bar'?

[05:13] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has @.a = ([<a b c>] but MyRole, [<d e f>] but MyRole) }; A.new.a[0].hello

[05:13] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Str'␤  in block <anon> at /tmp/YRaNhmB0_m:1␤  in <anon> at /tmp/YRaNhmB0_m:1␤»

[05:13] <TimToady> must be flattening bogusly

[05:14] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has @.a = ([<a b c>] but MyRole, [<d e f>] but MyRole) }; A.new.a[0].say

[05:14] <p6eval> nom 4ffbd6: OUTPUT«a␤»

[05:14] <TimToady> yes, the [] is flattening in a list, boo hiss

[05:14] <TimToady> well, maybe it's arguable that it should after the but

[05:15] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has @.a = $([<a b c>] but MyRole), $([<d e f>] but MyRole) }; A.new.a[0].say

[05:15] <p6eval> nom 4ffbd6: OUTPUT«a b c␤»

[05:15] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has @.a = $([<a b c>] but MyRole), $([<d e f>] but MyRole) }; A.new.a[0].hello

[05:15] <p6eval> nom 4ffbd6: OUTPUT«hi␤»

[05:15] <TimToady> there you go

[05:15] <Radvendii> oh, that's weird. why should it?

[05:15] <Radvendii> ooh

[05:15] <TimToady> because function calls don't commit to either .item or .list

[05:15] <Radvendii> that's good

[05:15] <Radvendii> thanks so much

[05:15] <TimToady> and 'but' is really just a function call

[05:16] <TimToady> so returns an uncommited parcel

[05:16] <TimToady> sorear: just 'bar'

[05:16] <sorear> yeah, I can see how that would happen

[05:16] <Radvendii> so can i say [but MyRole] followed by a list?

[05:16] <TimToady> likewise \bar

[05:16] <Radvendii> and it will apply it to all of the elements?

[05:16] <sorear> in Rakudo, the thing that makes [foo] not flatten is the Scalar wrapper; 'but' returns a naked Array, which flattens

[05:17] <TimToady> no

[05:17] <TimToady> only infixes can be reduced on

[05:17] <TimToady> and metaops never allow embedded whitespace

[05:17] <sorear> Radvendii: you can say Object but (Role1, Role2, Role3)

[05:17] <sorear> and it does summation automatically

[05:17] <TimToady> besides, that's more like a map or a hyper, not a reduce

[05:18] <sorear> seems more like a foldl to me

[05:18] <TimToady> map * but MyRole, [], [], []

[05:18] <TimToady> there's no folding

[05:18] <Radvendii> oh

[05:18] <Radvendii> i see

[05:18] <sorear> oh, I misunderstood

[05:19] <TimToady> std: role MyRole {}; ([], [], []) »but» MyRole

[05:19] <p6eval> std 40d10f7: OUTPUT«ok 00:01 111m␤»

[05:19] <TimToady> std: role MyRole {}; [], [], [] Xbut MyRole

[05:19] <p6eval> std 40d10f7: OUTPUT«ok 00:01 111m␤»

[05:19] <Radvendii> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = map * but MyRole, [<a b c>], [<d e f>] };  A.new.a[0].hello

[05:19] <p6eval> nom 4ffbd6: OUTPUT«No applicable candidates found to dispatch to for 'map'. Available candidates are:␤:(Callable &code, *@values)␤␤  in method <anon> at /tmp/tAVx7zqpyJ:1␤  in method BUILDALL at src/gen/CORE.setting:583␤  in method bless at src/gen/CORE.setting:573␤  in method new at sr…

[05:20] <TimToady> perhaps it's not whatevering 'but' successfully

[05:20] <TimToady> try { $_ but MyRole } instead

[05:20] <Radvendii> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = map {$_ but MyRole} [<a b c>], [<d e f>] };  A.new.a[0].hello

[05:20] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Unable to parse infixish, couldn't find final ']' at line 2␤»

[05:20] <TimToady> with a comma

[05:20] <Radvendii> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = map {$_ but MyRole}, [<a b c>], [<d e f>] };  A.new.a[0].hello

[05:20] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Str'␤  in block <anon> at /tmp/9OyG7xZD26:1␤  in <anon> at /tmp/9OyG7xZD26:1␤»

[05:21] <TimToady> same deal

[05:21] <sorear> try { $( $_ but MyRole ) }

[05:21] <Radvendii> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = map {$_ but MyRole}, $([<a b c>]), $([<d e f>]) };  A.new.a[0].hello

[05:21] <p6eval> nom 4ffbd6: OUTPUT«Method 'hello' not found for invocant of class 'Str'␤  in block <anon> at /tmp/D1w7gc02D2:1␤  in <anon> at /tmp/D1w7gc02D2:1␤»

[05:21] <TimToady> { ($_ but MyRole).item }

[05:21] <Radvendii> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = map {($_ but MyRole).item}, [<a b c>], [<d e f>] };  A.new.a[0].hello

[05:21] <TimToady> maybe

[05:21] <p6eval> nom 4ffbd6: OUTPUT«hi␤»

[05:21] <Radvendii> YAY :D

[05:21] <sorear> \o/

[05:22] <Radvendii> \o/*RAINBOWS*\o/

[05:22] *** koban joined
[05:22] <TimToady> hyper probably doesn't care about .item

[05:22] <Radvendii> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = map {$($_ but MyRole)}, [<a b c>], [<d e f>] };  A.new.a[0].hello

[05:22] <p6eval> nom 4ffbd6: OUTPUT«hi␤»

[05:22] <Radvendii> that works too

[05:22] *** thou left
[05:23] *** koban left
[05:23] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = ([<a b c>], [<d e f>]) »but» MyRole }; A.new.a[0].hello

[05:23] <p6eval> nom 4ffbd6: OUTPUT«Method 'specialize' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in <anon> at src/gen/Metamodel.pm:2075␤  in <anon> at src/gen/Metamodel.pm:2071␤  in compose at src/gen/Metamodel.pm:2069␤  in mixin at src/gen/Metamodel.pm:947␤  in sub infix:<but> at …

[05:23] <TimToady> wow

[05:23] <Radvendii> uh... saywhatnow?

[05:24] <TimToady> nom: role MyRole {method hello {say "hi"} }; class A { has  @.a = [<a b c>], [<d e f>] Xbut MyRole }; A.new.a[0].hello

[05:24] <p6eval> nom 4ffbd6: OUTPUT«Method 'specialize' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in <anon> at src/gen/Metamodel.pm:2075␤  in <anon> at src/gen/Metamodel.pm:2071␤  in compose at src/gen/Metamodel.pm:2069␤  in mixin at src/gen/Metamodel.pm:947␤  in sub infix:<but> at …

[05:24] <Radvendii> is »something» the same as Xsomething?

[05:24] <TimToady> it really doesn't want to meta-but

[05:24] <Radvendii> out of context, that sounds hillarious

[05:25] <TimToady> Radvendii: more or less, if there's only one thing on the right, and you squint to not see the differences in precedence and listiness

[05:25] <TimToady> and eager/laziness

[05:25] <TimToady> Xop is lazy, »op» is so eager it parallelizes

[05:25] <moritz> \o

[05:25] <Radvendii> o/

[05:26] <Radvendii> TimToady: ah. i see

[05:26] <sorear> o/

[05:26] <sorear> niecza: 1

[05:26] <p6eval> niecza v13-339-gcecbb7c:  ( no output )

[05:27] <sorear> niecza: .signature.perl.say for &open.candidates

[05:27] <p6eval> niecza v13-339-gcecbb7c: OUTPUT«:(Any $filename, Any :$w, Any :$a, Any :$r, Any :$rw)␤»

[05:27] *** jaldhar joined
[05:29] <sorear> nom: multi MAIN('foo') { }; multi MAIN('bar', $quux) { }; @*ARGS = '--help'

[05:29] <p6eval> nom 4ffbd6: OUTPUT«Usage:␤  --setting=SAFE foo␤  --setting=SAFE bar <quux>␤»

[05:29] <TimToady> niecza: role MyRole {method hello {say "hi"} }; class A { has  @.a = [<a b c>], [<d e f>] Xbut MyRole }; A.new.a[0].hello

[05:30] <p6eval> niecza v13-339-gcecbb7c: OUTPUT«hi␤»

[05:30] *** shinobicl_ left
[05:30] <TimToady> \o/ (maybe)

[05:31] <TimToady> niecza: role MyRole {method hello {say "hi"} }; class A { has  @.a = [<a b c>], [<d e f>] »but» MyRole }; A.new.a[0].hello

[05:31] <p6eval> niecza v13-339-gcecbb7c: OUTPUT«Unhandled exception: Unable to resolve method hello in class Array␤  at /tmp/cVEydQLl75 line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3325 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3326 (module-CORE @ 59) ␤  at /ho…

[05:31] <Radvendii> oh bam. niecza takes the prize!

[05:31] <Radvendii> kind of...

[05:31] <TimToady> niecza: role MyRole {method hello {say "hi"} }; class A { has  @.a = ([<a b c>], [<d e f>]) »but» MyRole }; A.new.a[0].hello

[05:31] <p6eval> niecza v13-339-gcecbb7c: OUTPUT«Unhandled exception: Unable to resolve method hello in class Array␤  at /tmp/igzNfdoUkR line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3325 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3326 (module-CORE @ 59) ␤  at /ho…

[05:31] <Radvendii> more of the prize than rakudo?

[05:31] <Radvendii> :P

[05:31] <sorear> »but» is recursing all the way down

[05:31] <sorear> buttifying the Strs

[05:31] <sorear> and packing them in Arrays

[05:32] <sorear> "buttifying"?  really?

[05:32] <sorear> butterflying, maybe

[05:32] <TimToady> ah, well, I've been on the warpath with deepmap semantics for hypers for a while now

[05:33] <Radvendii> there should be new terminology made, new conjugations, new suffixes, the whole 9 yards!

[05:34] <TimToady> if nobody wants to implement duckmap semantics instead, we'll have to put them back to shallow only, or at least only as far as the first shaped array

[05:34] <sorear> what was duckmap?

[05:34] <TimToady> actually, duckmap was only proposed for unaries, so nevermind

[05:35] <Radvendii> ugh. does initialisation of "has"ed variables know about "self"

[05:35] <TimToady> S03:4281

[05:35] <TimToady> Radvendii: supposed to, but probably NYI

[05:36] <Radvendii> damn.

[05:36] <TimToady> BUILD knows about self

[05:36] <TimToady> and if you're going to have interdependencies, probably better to have them in one place

[05:36] <Radvendii> BTW @sorear: This is why everyone keeps asking "when is perl6 going to be finished"

[05:37] <Radvendii> it's not interdependencies... I have to pass "self" to the role

[05:37] <TimToady> this really sounds like something you want to do in BUILD

[05:39] <Radvendii> i dont think so... https://gist.github.com/1668204

[05:40] <Radvendii> (it's a chess board in case you're wondering)

[05:42] <Radvendii> is there any way to get the object that "has" you?

[05:42] <Radvendii> and by you i mean from the point of view of the variable

[05:42] <TimToady> self is supposed to work, but NYI

[05:43] <TimToady> the variable itself can't know

[05:43] <Radvendii> right, but as of now, can i say @.a.super?

[05:43] <Radvendii> oh

[05:43] <TimToady> it might have instantiations in any number of arguemtns

[05:43] <TimToady> er, of objects

[05:43] <Radvendii> okay

[05:43] <TimToady> it's just an "offset" into an abstract structure

[05:44] <Radvendii> so i just want to move all of this code into the BUILD submethod, even though that's not ideal

[05:44] <Radvendii> at least temporarily

[05:44] <Radvendii> is that right?

[05:44] <TimToady> can probably be made to work

[05:45] <Radvendii> as is?

[05:45] <Radvendii> oh

[05:45] <Radvendii> if i were to move it

[05:45] <dalek> rakudo/nom: 78bee73 | moritz++ | src/core/Exceptions.pm:

[05:45] <dalek> rakudo/nom: simplify exceptions code a bit by bringing in X::Base inheritance through X::Comp

[05:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/78bee73306

[05:45] <dalek> rakudo/nom: 95f97e4 | moritz++ | src/ (2 files):

[05:45] <dalek> rakudo/nom: first X::Parameter class; many more to come...

[05:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/95f97e4e7e

[05:45] <TimToady> as long as you don't depend on other = defaults

[05:45] <Radvendii> nope. my other ones depend on it

[05:45] <Radvendii> but not the other way around

[05:45] <Radvendii> and i may as well move them all into BUILD no?

[05:45] <moritz> nom does allow attributes in defaults

[05:46] <Radvendii> to keep them in one place so they're easy to find later?

[05:46] <moritz> nom: class A { has $.a = 3; has $.b = 2 * $a; }; say A.new.b

[05:46] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "; }; say A"␤»

[05:46] <Radvendii> s/$a/$.a/

[05:46] <moritz> nom: class A { has $.a = 3; has $.b = 2 * $.a; }; say A.new.b

[05:46] <p6eval> nom 4ffbd6: OUTPUT«6␤»

[05:46] <Radvendii> yeah i know, but i specifically want to use "self"

[05:47] <Radvendii> not access some other one

[05:47] <TimToady> nom: class A { has $.a = 3; has $.b = 2 * self.a; }; say A.new.b

[05:47] *** wolfman2000 left
[05:47] <p6eval> nom 4ffbd6: OUTPUT«6␤»

[05:47] <Radvendii> oh!

[05:47] <Radvendii> weird

[05:47] <TimToady> nom: class A { has $.a = 3; has $.b = self; }; say A.new.b.a

[05:48] <p6eval> nom 4ffbd6: OUTPUT«3␤»

[05:48] <TimToady> looks like it works

[05:48] <Radvendii> then why isn't it working for me...

[05:48] <Radvendii> Symbol 'self' not predeclared in <anonymous> (./chess_struct.pl:27)

[05:48] *** kaleem joined
[05:49] <TimToady> are you using a recent version?

[05:49] <Radvendii> 2011.12

[05:49] <Radvendii> is there a newer one?

[05:49] <TimToady> probably too old

[05:49] <Radvendii> i thought i checked recently

[05:50] <TimToady> most of us just use the bleading edge from github

[05:50] <Radvendii> i thought i was

[05:50] <Radvendii> is there any way to make it autoupdate?

[05:51] <TimToady> you don't want that, it would always be recompling at the wrong time

[05:53] <Radvendii> yay :D we finally get a --prefix option!

[05:55] <Radvendii> TimToady: what do you mean? it would just recompile when there is a newer version...

[05:56] <moritz> rakudo has had --prefix for ages

[05:56] <Radvendii> it didn't have it for 2011.12

[05:56] <moritz> nom: sub f($?x) { }

[05:56] <p6eval> nom 4ffbd6: OUTPUT«===SORRY!===␤In signature parameter, '$?x', it is illegal to use '?' twigil at line 1, near ") { }"␤»

[05:56] <Radvendii> or maybe the one vefore that

[05:57] <moritz> Radvendii: of course it had

[05:57] <Radvendii> alright, maybe i missed it/ dont remember

[05:58] <Radvendii> if this works, ill be too happy to care :P

[05:58] <sorear> perl6: sub f($*x) { } ; say &f.signature.params[0].name

[05:59] <p6eval> rakudo 4ffbd6, niecza v13-339-gcecbb7c: OUTPUT«$*x␤»

[05:59] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&params"␤    at /tmp/yTL8ISt1WK line 1, column 22 - line 2, column 1␤»

[06:01] *** ponbiki joined
[06:02] <Radvendii> i just noticed that [+] can be used instead of any() if you know they're all going to be booleans...

[06:02] <sorear> [?|] probably best

[06:03] <TimToady> well, [*] can be used for all()

[06:03] <Radvendii> best speed wise or funny wise?

[06:03] <Radvendii> TimToady: true dat

[06:03] <TimToady> congratulations, you've discovered Boolean algebra

[06:03] <sorear> clarity of intent wise

[06:03] <Radvendii> TimToady: haha

[06:04] <Radvendii> sorear: mhmm... is there any difference between [|] and any()

[06:04] <sorear> No

[06:04] <sorear> Except that [|] is a listop and so flattens lists

[06:04] <Radvendii> ooh. any() shall henceforth begone from my memory

[06:05] <TimToady> so's any

[06:05] <sorear> oh, right

[06:05] <sorear> you don't like any()?

[06:05] <Radvendii> but when would you ever want to evaluate a list as a boolean

[06:05] <sorear> 1. any doesn't have anything to do with booleans

[06:06] <Radvendii> i don't like specific functions for things that could be generalized. like having a sum() function when [+] is what you mean

[06:06] <Radvendii> sorear: yeah, i just remembered that

[06:06] <TimToady> if all(@stations) { say "Go for launch!

[06:06] <TimToady> ")

[06:06] <TimToady> "} even

[06:06] <sorear> 2. if @list { } is nicer than if @list.elems != 0 { }

[06:07] <Radvendii> sorear: how is that relevant... oh, as an example of a special case?

[06:07] <sorear> 22:05 < Radvendii> but when would you ever want to evaluate a list as a boolean

[06:07] <TimToady> but [|] is exactly equivalent to any as far as I can tell

[06:07] <TimToady> sometimes the name reads better though

[06:07] <Radvendii> sorear: oh...

[06:07] <Radvendii> sorear: i see

[06:08] <TimToady> er, that's a rather different meaning than any or all

[06:08] <Radvendii> TimToady: i see what you mean, but i personally tend to disagree

[06:08] <Radvendii> (about the [|] vs any())

[06:08] <sorear> the current version of niecza can't do constant folding with higher-order functions like &reduce

[06:08] <Radvendii> what does &reduce do?

[06:09] <sorear> so $foo eq any < foo bar > will be quite a bit faster than $foo eq [|] <foo bar>

[06:09] <TimToady> oh, you think the typical Perl user is going to automatically intuit what [|] means?

[06:09] <TimToady> besides, this is Perl, so TMTOWTDI

[06:09] <Radvendii> TimToady: no, but i will

[06:09] <sorear> Radvendii: [|] <foo bar> means roughly &reduce(&infix:<|>, <foo bar>)

[06:09] <Radvendii> TMTOWTDI?

[06:09] <sorear> There (is) More Than One Way To Do It

[06:09] <TimToady> There's

[06:10] <Radvendii> sorear: right. exactly. I'm not saying we should get rid of it by any means

[06:10] <Radvendii> just saying [|] makes more sense to _me_

[06:10] <TimToady> how...postmodern...

[06:11] *** rsimoes left
[06:11] <sorear> well, uh, Radvendii, TMTOWTDI means the language can adapt to the quirks of you and your problems...

[06:11] <sorear> (not to suggest that I don't have my own quirks.)

[06:12] <Radvendii> TimToady: how so? (postmodern, that is)

[06:12] <TimToady> TMTOWTD is a postmodern attitude

[06:12] <TimToady> *DI

[06:12] <sorear> niecza: $*OUT.say(5)

[06:12] <p6eval> niecza v13-339-gcecbb7c: OUTPUT«Unhandled exception: Cannot unbox a TextWriter from an object of repr P6opaque␤  at /home/p6eval/niecza/lib/CORE.setting line 3165 (TextWriter.say @ 5) ␤  at /tmp/ClxUKgm4ZW line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3325 (ANON …

[06:12] <Radvendii> sorear: yup

[06:12] <Radvendii> TimToady: ah

[06:13] <Radvendii> TimToady: i really can't see why anyone would use Java over Perl... I really can't.

[06:13] <Radvendii> oh

[06:13] <Radvendii> maybe for web stuff

[06:13] <Radvendii> but for applications?

[06:13] <TimToady> http://www.wall.org/~larry/pm.html

[06:13] <sorear> Java is/was more likely to work out of the box on Windows

[06:14] <sorear> Java uses less memory and is faster

[06:14] <Radvendii> sorear: what??

[06:14] <TimToady> so far

[06:14] *** birdwindupbird left
[06:14] <Radvendii> oh, well perl6 yeah. but if you're concerned about that then perl5

[06:15] <sorear> no, I'm talking about perl5

[06:15] <sorear> the biggest thing perl5 as a platform has going for it is startup speed

[06:15] <Radvendii> http://onlyjob.blogspot.com/2011/03/perl5-python-ruby-php-c-c-lua-tcl.html

[06:15] <TimToady> we could use some HotSpot optimizing at some point

[06:16] <sorear> have you seen the size of struct sv?

[06:17] *** revdiablo left
[06:17] <sorear> my @array = (15) x 1_000_000; # this will allocate about 20MB, twice that on 64-bit

[06:17] <Radvendii> i dont even know what struct sv is...

[06:17] <sorear> actually more than that because of temp storage on the stack

[06:18] *** revdiablo joined
[06:18] *** revdiablo left
[06:18] *** revdiablo joined
[06:18] <Radvendii> I assume that's a lot more than it should...

[06:19] <Radvendii> I'm still getting the symbol "self" undeclared error

[06:19] <Radvendii> even with the most up-to-date rakudo

[06:20] <Radvendii> whats the difference between a symbol and subroutine?

[06:20] <Radvendii> and which should "self" be?

[06:20] <sorear> a symbol is a name

[06:20] <sorear> a subroutine is a thing

[06:20] *** s1n joined
[06:21] <Radvendii> so self is a... symbol?

[06:21] <sorear> subroutines can (but need not) be bound to symbols

[06:21] <sorear> yes, self is a symbol

[06:21] <sorear> I think

[06:21] <TimToady> it is a term, so doesn't expect any expression after

[06:21] <TimToady> std: self self

[06:21] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤'self' used where no object is available at /tmp/DeWV1e4Wck line 1:␤------> self⏏ self␤Confused at /tmp/DeWV1e4Wck line 1:␤------> self ⏏self␤    expecting any of:␤   bracketed infix␤        infix or meta-in…

[06:21] <sorear> it's really somewhat unclear in the spec, but both rakudo and niecza use a symbol named 'self' to implement the term:self production

[06:22] <Radvendii> so why doesn't it recognize self in the initialization?

[06:22] <sorear> niecza: self self

[06:22] <p6eval> niecza v13-339-gcecbb7c: OUTPUT«===SORRY!===␤␤'self' used where no object is available at /tmp/bTukeZjtgM line 1:␤------> self⏏ self␤␤Confused at /tmp/bTukeZjtgM line 1:␤------> self ⏏self␤␤Parse failed␤␤»

[06:22] <Radvendii> i thought we determined that it should.

[06:22] <TimToady> std: class A { method foo { self self } }

[06:22] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/SOQAoHiAvR line 1:␤------> class A { method foo { self ⏏self } }␤    expecting any of:␤        bracketed infix␤        infix or meta-infix␤    statement modifier loop␤Parse failed␤FAILED 00:01 109m␤»…

[06:23] <TimToady> std: rand rand

[06:23] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Two terms in a row at /tmp/3vXyxyURbP line 1:␤------> rand ⏏rand␤    expecting any of:␤   bracketed infix␤        infix or meta-infix␤    statement modifier loop␤Parse failed␤FAILED 00:01 108m␤»

[06:23] <Radvendii> nom: class A { $.a = 3; $.b=self}; say A.new.b.a;

[06:23] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/g8xvFAFKum:1)␤»

[06:23] <Radvendii> ah ha!

[06:23] <Radvendii> nom: class A { $.a = 3; $.b= self}; say A.new.b.a;

[06:23] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/FRwULEUfyC:1)␤»

[06:23] <TimToady> there's no object!

[06:24] <Radvendii> nom: class A { has $.a = 3; has $.b = self}; my A $a.=new;say $a.b.a;

[06:24] <p6eval> nom 95f97e: OUTPUT«3␤»

[06:25] <Radvendii> oh

[06:25] <Radvendii> nom: class A { has $.a = 3; has $.b = self};say A.b.a;

[06:25] <p6eval> nom 95f97e: OUTPUT«Cannot look up attributes in a type object␤  in method b at src/gen/CORE.setting:1384␤  in block <anon> at /tmp/k7rHgXOslO:1␤  in <anon> at /tmp/k7rHgXOslO:1␤»

[06:25] <Radvendii> that's really the difference?

[06:25] <Radvendii> huh.

[06:26] <Radvendii> but in my code i _do_ have an object...

[06:26] *** rsimoes joined
[06:26] * sorear adds logic to flush $*OUT at END time ...

[06:30] <moritz> nom: class A is repr { }

[06:30] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Method 'cursor' not found for invocant of class 'Match'␤»

[06:31] <Radvendii> role MyRole[$s] {method bar {say $s} }; class A { has @.a = ([<a b>],[<c d>]).map: {$($_ but MyRole[self])} } my A $foo .= new; $foo.a[0].bar;

[06:31] <Radvendii> nom: role MyRole[$s] {method bar {say $s} }; class A { has @.a = ([<a b>],[<c d>]).map: {$($_ but MyRole[self])} }; my A $foo .= new; $foo.a[0].bar;

[06:31] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/wkLcYDHmti:1)␤»

[06:31] <Radvendii> and there we have it

[06:33] <moritz> std: @*a.*&uc

[06:33] <p6eval> std 40d10f7: OUTPUT«ok 00:01 111m␤»

[06:33] <Radvendii> nom: role MyRole[$s] {method bar {say $s} }; class A { has $.a = 5 but MyRole[self])} }; my A $foo .= new; $foo.a.bar;

[06:33] <TimToady> Radvendii: that's a closure problem, not a self problem per se

[06:33] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[06:34] <Radvendii> TimToady: how so?

[06:34] <Radvendii> nom: role MyRole[$s] {method bar {say $s} }; class A { has $.a = 5 but MyRole[self])}; my A $foo .= new; $foo.a.bar;

[06:34] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[06:34] <TimToady> there

[06:34] <TimToady> there's a self in the = thunk, but maps's closure isn't closing over that self

[06:36] <Radvendii> i don't understand.

[06:36] <Radvendii> shouldn't it search the broader scope if it doesnt find self in map's scope?

[06:37] <TimToady> I just said that

[06:37] <moritz> right. And it doesn't do that correctly

[06:37] *** araujo left
[06:37] <TimToady> that's what "closing over" means

[06:37] <Radvendii> oh

[06:37] <Radvendii> i see

[06:37] <moritz> nom: eval '$^x'

[06:37] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Cannot use placeholder parameter $^x in the mainline at line 1, near ""␤»

[06:37] *** araujo joined
[06:38] <Radvendii> so would it even help to move it into the BUILD submethod?

[06:38] <moritz> there's an easy way to check

[06:38] <Radvendii> true dat

[06:40] <moritz> std: my $::('f')

[06:40] <p6eval> std 40d10f7: OUTPUT«ok 00:01 108m␤»

[06:40] * moritz not convinced :-)

[06:40] *** birdwindupbird joined
[06:44] <Radvendii> well, it works. :

[06:44] <Radvendii> :-D

[06:44] <Radvendii> now i've got other bugs to work out

[06:44] <Radvendii> D-:

[06:46] <dalek> niecza: 6dab8a6 | sorear++ | lib/ (4 files):

[06:46] <dalek> niecza: Implement $*OUT and $*ERR

[06:46] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6dab8a6b89

[06:52] <Radvendii> If I overload the at_pos of an array to return a proxy where the FETCH just returns @a[$i], it'll end up in an infinite loop

[06:53] <Radvendii> and by @a[$i] i mean self[$i]

[06:53] <sorear> ...What did you think would happen?

[06:53] <Radvendii> no no, that's reasonable

[06:54] <Radvendii> the question is, how do i overload at_pos to make it do normal stuff and something else as well

[06:54] <Radvendii> there's no super.at_pos...

[06:54] <moritz> there's nextsame

[06:55] <moritz> and nextwith and callwith

[06:55] <moritz> and callsame

[06:57] <dalek> niecza: 7f9a514 | sorear++ | / (3 files):

[06:57] <dalek> niecza: More sub introspection fiddles, add MAIN_HELPER to setting

[06:57] <dalek> niecza: review: https://github.com/sorear/niecza/commit/7f9a5148be

[06:57] <Radvendii> i'm looking through the documentation and not getting what those subroutines do...

[06:58] <sorear> there is no "super" in Perl 6

[06:58] <Radvendii> sorear: i am aware

[06:59] <Radvendii> sorear: i just dont understand how to do this without it

[07:00] <Radvendii> or what (call|next)(same|with) does...

[07:00] <moritz> Radvendii: then look for them in the test suite

[07:02] <Radvendii> i am.

[07:02] <Radvendii> callsame.t

[07:02] <Radvendii> it's very confusing...

[07:02] <Radvendii> it calls the other multi sub?

[07:03] <moritz> corect

[07:03] <sorear> nextsame is, in a very loose sense, a fossil

[07:04] <sorear> its design can only be understood if you recognize that multi subs and methods used to be the same thing

[07:04] <TimToady> er, not really

[07:04] <TimToady> there were always different dispatchers

[07:04] <moritz> sorear: huh?

[07:04] <Radvendii> oh. so if i call it from a method, it calls the next method up? (or the method from the "super" (i know it doesnt exist) class?

[07:04] <Radvendii> )

[07:05] <TimToady> they did have failover semantics at one point, but we weren't confusing them

[07:05] <TimToady> well, except when we were :)

[07:05] <moritz> Radvendii: it calls the next matching method, wherever it was defined

[07:05] <TimToady> it calls whatever is next in the implicit loop of whichever dispatcher called you

[07:05] <moritz> Radvendii: could even be a multi method in the same class

[07:06] <Radvendii> but if it's just a single method, it will call the method of the super class?

[07:06] <TimToady> what is "the" super class under multiple inheritance?

[07:06] <Radvendii> it picks a "random" one, from my perspective?

[07:06] <TimToady> bzzt

[07:07] <Radvendii> or the first one that shows up when i say class XXX _is_ YYY

[07:07] <sorear> haha!

[07:07] *** wtw_ joined
[07:07] <Radvendii> as in, when i say class X is Y is Z, it'll first go to Y?

[07:07] <TimToady> and then where?

[07:08] <TimToady> Z is not the super of Y

[07:08] <Radvendii> then Y's superclass?

[07:08] <TimToady> that would be Perl 5

[07:08] <dalek> niecza: 123be0f | sorear++ | / (2 files):

[07:08] <dalek> niecza: Auto-call MAIN_HELPER when MAIN is defined; MAIN is now a supported feature

[07:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/123be0f6b0

[07:08] <Radvendii> but in perl6 it goes to Z?

[07:08] <TimToady> it will go to siblings as well as parents

[07:08] <Radvendii> both _at-the-same-time_?

[07:08] <TimToady> no

[07:09] <Radvendii> :P

[07:09] <Radvendii> siblings first?

[07:09] <TimToady> there is a dispatcher loop, which is working from a list

[07:09] <TimToady> it knows all the candidates before it starts, or at least how to find all the candidates

[07:09] <Radvendii> okay.

[07:10] <TimToady> imagine a dispatcher loop labeled CANDIDATE:

[07:10] <TimToady> nextsame is just "next CANDIDATE;" in loop terms

[07:10] <TimToady> (plus making sure the same args go to it)

[07:10] <Radvendii> oh. so callsame calls the method i am in right now?

[07:11] <TimToady> no, it it's nextsame plus return here

[07:11] <TimToady> nextsame doesn't return

[07:11] <TimToady> it's a tailcall

[07:11] <Radvendii> so callsame is the same as "return nextsame"

[07:12] <TimToady> except nextsame doesn't return

[07:12] *** wtw left
[07:12] <TimToady> nextsame is "return callsame"

[07:12] <Radvendii> but callsame _already_ returns, right?

[07:12] <TimToady> it returns to *here*

[07:12] <Radvendii> oh

[07:13] <Radvendii> i see

[07:13] <TimToady> you can put other statements after it

[07:13] <TimToady> nextsame is a goto

[07:13] <Radvendii> got it

[07:13] <sorear> I never noticed before the inherent irony that "return" is a statement that never returns

[07:13] <Radvendii> :P

[07:14] <Radvendii> so making a Proxy object who's FETCH and STORE methods are just "method {nextsame}" will do nothing?

[07:15] <Radvendii> (nothing differently than just using the normal at_pos that is)

[07:17] <Radvendii> is that right?

[07:18] <moritz> Radvendii: nonono

[07:18] <moritz> Radvendii: if you write Proxy.new(FETCH => method () { nextsame } ), then nextsame won't have anywhere to go to

[07:19] <moritz> because it's called from an anonymous method, which doesn't know about any parent classes or so

[07:19] *** molaf joined
[07:19] <Radvendii> because method is anonymous?

[07:19] <Radvendii> ah

[07:19] <Radvendii> understood

[07:19] <moritz> and it's not in the same class hierarchy as the at_pos you want to delegate to

[07:19] <moritz> maybe you really want the $obj.YourClass::method syntax

[07:20] <Radvendii> how does that work?

[07:20] <moritz> it calls the method named 'method' that is defined in YourClass

[07:21] <moritz> not the best possible match, as $obj.method would do

[07:21] <Radvendii> why do we even need $obj.? why not "YourClass::method"?

[07:21] <Radvendii> the class is not linked to the $obj

[07:23] *** raiph joined
[07:24] <moritz> because A::b is for accessing subs, not methods

[07:25] <moritz> and of course $obj must conform to YourClass to be able to do that

[07:25] <Radvendii> what if i just made an instance variable array which stored the values i wanted. and then just accessed that in FETCH?

[07:26] <moritz> sounds good

[07:26] <moritz> (though I really don't know what you want to achieve in the end)

[07:26] *** ponbiki left
[07:26] <Radvendii> i want to make something that looks exactly like a two-dimensional array, except that it has other effects when you try to write to it

[07:31] <dalek> niecza: 6e9a6a7 | sorear++ | src/niecza:

[07:31] <dalek> niecza: Only run MAIN from directly invoked units

[07:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/6e9a6a739b

[07:31] <dalek> niecza: f9b5518 | sorear++ | t/spectest.data:

[07:31] <dalek> niecza: Run the MAIN tests

[07:31] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f9b5518537

[07:31] <dalek> roast: 75d071e | sorear++ | S06-multi/syntax.t:

[07:31] <dalek> roast: [S06-multi/syntax] Unfudge for Niecza capture-parameter fix

[07:31] <dalek> roast: review: https://github.com/perl6/roast/commit/75d071ea52

[07:31] <dalek> roast: f72b2e8 | sorear++ | S06-other/main-usage.t:

[07:31] <dalek> roast: [S06-other/main-usage] Fudge for Niecza

[07:31] <dalek> roast: review: https://github.com/perl6/roast/commit/f72b2e81fb

[07:32] *** GlitchMr joined
[07:33] <dalek> features: 5d939e6 | sorear++ | features.json:

[07:33] <dalek> features: Niecza can do MAIN and some protos now

[07:33] <dalek> features: review: https://github.com/perl6/features/commit/5d939e6a5e

[07:34] <moritz> \o/

[07:38] <sorear> std: my \foo

[07:38] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Malformed my at /tmp/02AwghqL96 line 1:␤------> my ⏏\foo␤    expecting any of:␤   scoped declarator␤      statement end␤  statement list␤Parse failed␤FAILED 00:01 107m␤»

[07:40] <sorear> TimToady: I am guessing my \foo = EXPR should behave more like my \foo ::= EXPR; read-only-izing to reflect the "SSA nature"?

[07:42] <TimToady> that doesn't seem to follow; a parcel is about as unassuming as you can get

[07:42] <sorear> so my $x; my \y = $x; y = 5; say $x # 5 ?

[07:43] <TimToady> it's the old "is ref" semantics

[07:43] <sorear> also: do we want to keep '|$foo' supported as a synonym indefinitely, or only for a deprecation cycle?

[07:44] <sorear> '\$foo' too

[07:44] <TimToady> well, in some sense those are okay, if you know what you're doing wrt item vs list interpolation, so I'm not in a rush to destroy them

[07:45] <TimToady> long term, they are likely to cause misunderstanding though

[07:45] <moritz> +1 to abolishing them in the long run

[07:46] *** Radvendii left
[07:46] <TimToady> re SSA, std does allow ::= as one of its four initializer infixes

[07:47] <TimToady> not sure if that works though, since ::= just means ordinary sig binding with readonly default

[07:47] <TimToady> it's possible we need some other syntactic help for SSA style

[07:52] <TimToady> something equivalent to 'my \y = decontainerize $x'

[07:52] <sorear> nom: my \y

[07:52] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Malformed my at line 1, near "\\y"␤»

[07:52] <sorear> nom: sub foo(\y) { }

[07:52] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Malformed parameter at line 1, near "\\y) { }"␤»

[07:52] <sorear> nom: sub foo(|y) { }

[07:52] <p6eval> nom 95f97e: OUTPUT«===SORRY!===␤Malformed parameter at line 1, near "|y) { }"␤»

[07:53] <TimToady> I'm not even sure std parses it yet...

[07:53] <TimToady> std: my \y = 42;

[07:53] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Malformed my at /tmp/LCO6RCc8OH line 1:␤------> my ⏏\y = 42;␤    expecting any of:␤       scoped declarator␤      statement end␤  statement list␤Parse failed␤FAILED 00:01 107m␤»

[07:53] <TimToady> nope

[07:53] <sorear> I'm going to try and add it to niecza this week... I feel I've put this off long enough already

[07:54] <TimToady> maybe I can have a glare at STD tomorrow and see if it's obvious

[07:55] <sorear> there would seem to be a trick in allowing my \y to parse but not accidentally stealing the \y capturing syntax

[07:56] <sorear> since they both go through <variable>

[07:56] <sorear> probably needs an <?{ $*IN_DECL }> or two

[07:57] * TimToady needs to head off to bed; will try to look at it soon if you don't get to it

[07:57] <sorear> g'night

[07:58] *** lutok joined
[08:09] *** xinming left
[08:16] *** GlitchMr42 joined
[08:19] *** charsbar___ joined
[08:19] *** GlitchMr left
[08:19] *** Woodi left
[08:19] *** p6eval left
[08:19] *** phenny left
[08:19] *** nsh_ left
[08:19] *** ascent__ left
[08:19] *** Juerd left
[08:20] *** Gothmog_ joined
[08:20] *** yeltzooo joined
[08:21] *** p6eval joined
[08:21] *** ChanServ sets mode: +v p6eval

[08:21] *** phenny joined
[08:21] *** Woodi joined
[08:21] *** ascent_ joined
[08:21] *** Juerd joined
[08:22] *** Yappoko___ joined
[08:23] *** nsh joined
[08:23] *** lrnperl6 joined
[08:27] *** aloha joined
[08:34] *** lrnperl6 left
[08:35] <sorear> \o/ patch successfully transplanted the latest STD changes to niecza

[08:40] <sorear> std: constant foo == 5;

[08:40] <p6eval> std 40d10f7: OUTPUT«ok 00:01 108m␤»

[08:40] <sorear> phenny: tell TimToady std: constant foo == 5;

[08:40] <phenny> sorear: I'll pass that on when TimToady is around.

[08:40] *** mj41 joined
[08:59] <sorear> std: my Set $x .= new

[08:59] <p6eval> std 40d10f7: OUTPUT«ok 00:01 110m␤»

[09:00] <sorear> std: my Set $x .=new

[09:00] <p6eval> std 40d10f7: OUTPUT«ok 00:01 110m␤»

[09:00] <sorear> std: my Set $x = pies

[09:00] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'pies' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[09:00] <sorear> std: my Set $x = new

[09:00] <p6eval> std 40d10f7: OUTPUT«ok 00:01 110m␤»

[09:00] <sorear> std: my Set $x .= pies

[09:00] <p6eval> std 40d10f7: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'pies' used at line 1␤Check failed␤FAILED 00:01 110m␤»

[09:01] <sorear> phenny: tell TimToady std: my Set $x .= pies # also, why is 'new' a function in CORE.setting?

[09:01] <phenny> sorear: I'll pass that on when TimToady is around.

[09:01] *** packetknife left
[09:09] <dalek> rakudo/nom: 583949d | moritz++ | src/ (2 files):

[09:09] <dalek> rakudo/nom: more typed parameter exceptions

[09:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/583949d149

[09:09] <dalek> rakudo/nom: fbddce7 | moritz++ | src/Perl6/Actions.pm:

[09:09] <dalek> rakudo/nom: fail better on 'is repr' without parameter

[09:09] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fbddce7cd2

[09:10] *** kaleem_ joined
[09:12] *** kaleem left
[09:14] * sorear -> sleep

[09:14] *** kaleem_ left
[09:14] *** kaleem joined
[09:27] *** spine_ joined
[09:32] *** mj41 left
[09:34] *** dakkar joined
[09:35] *** daxim joined
[09:35] *** odoacre left
[09:41] <dalek> rakudo/nom: 2042efb | moritz++ | src/ (2 files):

[09:41] <dalek> rakudo/nom: turns out we do not yet know which paramater a double type constraint is attached to

[09:41] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2042efb2f3

[09:42] <dalek> roast: 8d41f56 | moritz++ | S32-exceptions/misc.t:

[09:42] <dalek> roast: more typed exception tests, better diagnosis

[09:42] <dalek> roast: review: https://github.com/perl6/roast/commit/8d41f56572

[09:42] *** Alias left
[09:42] *** Alias joined
[09:42] <moritz> and with that rakudo passe 52 tests for typed exceptions

[09:45] <dalek> roast: 6ff177c | moritz++ | S32-exceptions/misc.t:

[09:45] <dalek> roast: even nicer test output

[09:45] <dalek> roast: review: https://github.com/perl6/roast/commit/6ff177cf1b

[09:46] *** mj41 joined
[09:47] <moritz> nom: class A { ... }; sub f(A $x) { }

[09:47] <p6eval> nom fbddce: OUTPUT«===SORRY!===␤The following packages were stubbed but not defined:␤    A␤␤»

[09:47] <moritz> nom: sub f(::A $x) { }

[09:47] <p6eval> nom fbddce:  ( no output )

[09:48] <moritz> nom: sub f(::A $x, A $y) { }

[09:48] <p6eval> nom fbddce:  ( no output )

[09:48] <moritz> nom: my 1 $x;

[09:48] <p6eval> nom fbddce: OUTPUT«===SORRY!===␤Malformed my at line 1, near "1 $x;"␤»

[09:49] <moritz> nom: 1.*"foo"()

[09:49] <p6eval> nom fbddce:  ( no output )

[09:49] <moritz> nom: 1.*&uc()

[09:49] <p6eval> nom fbddce:  ( no output )

[09:49] <moritz> nom: 1.*WHAT()

[09:49] <p6eval> nom fbddce: OUTPUT«===SORRY!===␤Cannot use .* on a non-identifier method call at line 1, near ""␤»

[09:57] *** packetknife joined
[10:04] <moritz> nqp: say(:foo('bar'))

[10:04] <p6eval> nqp: OUTPUT«too many named arguments: 1 passed, 0 used␤current instr.: 'say' pc 2783 (src/stage2/gen/NQPCORE.setting.pir:893) (src/stage2/NQPCORE.setting:193)␤»

[10:05] <moritz> nqp: say(method => 1)

[10:05] <p6eval> nqp: OUTPUT«Routine declaration requires a signature at line 1, near "=> 1)"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[10:05] <moritz> nqp: say(:method(1))

[10:05] <p6eval> nqp: OUTPUT«too many named arguments: 1 passed, 0 used␤current instr.: 'say' pc 2783 (src/stage2/gen/NQPCORE.setting.pir:893) (src/stage2/NQPCORE.setting:193)␤»

[10:10] <jnthn> morning, #perl6

[10:11] <moritz> \o jnthn 

[10:13] <jnthn> My word, how much backlog?!

[10:16] * moritz has skipped most of it

[10:22] * jnthn skimmed it

[10:23] <jnthn> Folks re-discovered the "self on RHS of has initializer" issue, which is why I wanted the STD changes (which have no happened). :)

[10:24] <jnthn> s/no/now/

[10:24] <jnthn> So...how is Star release formed...

[10:25] <jnthn> ...not on Windows, given the README. :)

[10:25] <moritz> I think we run 'make'

[10:26] <moritz> but we really need to go through the list of modules shipped with it

[10:26] <moritz> and see which ones work on nom

[10:26] <moritz> and exclude or fix the others

[10:27] <moritz> I guess blizkost can be safely assumed to be broken, right?

[10:27] <jnthn> Right.

[10:28] <jnthn> Didn't get chance to update that.

[10:28] <moritz> does Test::Mock work?

[10:28] <jnthn> Though probably wants some more fundemental re-thinks in the light of representation poly

[10:28] <jnthn> I think panda is using it, so I assume so

[10:28] <moritz> ah right

[10:30] <jnthn> moritz: Just pushed a few Makefile updates

[10:30] <jnthn> (versions etc)

[10:32] <jnthn> Ah...I wonder if this needs updating to build NQP also.

[10:32] <dalek> rakudo/nom: 7d0453e | moritz++ | src/ (2 files):

[10:32] <dalek> rakudo/nom: typed exceptions for some private method call fails

[10:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7d0453efbe

[10:32] <moritz> it probably does :/

[10:33] <jnthn> Since before we got parrot-nqp from just building Parrot

[10:33] <dalek> star: ce7a072 | jnthn++ | Makefile:

[10:33] <dalek> star: Update version and remove Blizkost for now.

[10:33] <dalek> star: review: https://github.com/rakudo/star/commit/ce7a0725a8

[10:33] * tadzik wonders if the last Star is still neutro days :)

[10:34] <moritz> ok, Term::ANSIColor works with nom

[10:34] <jnthn> tadzik: Seems so

[10:34] <tadzik> nah

[10:34] <tadzik> how about shipping Bailador?

[10:34] <jnthn> moritz: Grammar::Debugger almost certainly wants including :)

[10:34] <jnthn> +1

[10:35] <moritz> +1 to both

[10:35] <tadzik> it'd need HTTP::Easy rather than HTTP::Server::Simple

[10:35] <tadzik> https://github.com/supernovus/perl6-http-easy/

[10:36] <moritz> Algorithm::Viterbi doesn't work with nom :/

[10:36] <tadzik> I'm leaving for my classes now, may have some tuits after the noon

[10:37] <moritz> arnsholt: do you know if it's blocking on something?

[10:38] <moritz> phenny: tell pmichaud to please turn on dalek pushing for the rakudo/star repo, see https://github.com/perl6/mu/blob/master/misc/dalek-push.txt for instructions

[10:38] <phenny> moritz: I'll pass that on when pmichaud is around.

[10:39] <moritz> phenny: tell pmichaud and maybe turn the 'rakudo' user into an organization, and give jnthn and maybe me administrative powers?

[10:39] <phenny> moritz: I'll pass that on when pmichaud is around.

[10:40] <jnthn> moritz: Since I did some fixes, I think MiniDBI can be safely included also.

[10:42] <moritz> jnthn: added it

[10:42] <moritz> also bailador

[10:43] <moritz> fwiw I've emailed with mberends++, he hopes to get back to Perl 6 hacking in a few weeks

[10:44] <jnthn> \o/

[10:44] <dalek> star: 2abd837 | moritz++ | Makefile:

[10:44] <dalek> star: change list of shipped modules

[10:44] <dalek> star: 

[10:44] <dalek> star: Algorithm::Viterbi is currently broken, remove it.

[10:44] <dalek> star: Replace HTTP::Server::Simple with HTTP:Easy, include Baildor and MiniDBI

[10:44] <dalek> star: review: https://github.com/rakudo/star/commit/2abd837abc

[10:47] <moritz> jnthn: how does one trigger the 'private method call must be qualified' error?

[10:49] <dalek> star: 4d4d217 | jnthn++ | Makefile:

[10:49] <dalek> star: Try to update Star Makefile to grab NQP releases also; untesed.

[10:49] <dalek> star: review: https://github.com/rakudo/star/commit/4d4d217574

[10:50] *** nornagest joined
[10:52] <jnthn> nom: self!foo()

[10:52] <p6eval> nom 2042ef: OUTPUT«===SORRY!===␤Private method call to 'foo' must be fully qualified with the package containing the method at line 1, near ""␤»

[10:52] <jnthn> nom: my $a; $a!foo()

[10:52] <p6eval> nom 2042ef: OUTPUT«===SORRY!===␤Private method call to 'foo' must be fully qualified with the package containing the method at line 1, near ""␤»

[10:53] <moritz> jnthn: thanks

[10:53] <jnthn> moritz: Take the second as first could also whine about no self.

[10:53] <moritz> 1!foo()

[10:53] <moritz> even shorter :-)

[10:53] <jnthn> :)

[10:54] <dalek> roast: c01e5d6 | moritz++ | S32-exceptions/misc.t:

[10:54] <dalek> roast: tests for typed private method call exceptions

[10:54] <dalek> roast: review: https://github.com/perl6/roast/commit/c01e5d67b4

[10:54] <dalek> star: 29531ce | jnthn++ | skel/build/Makefile.in:

[10:54] <dalek> star: Initial round of updates to skeleton Makefile.

[10:54] <dalek> star: review: https://github.com/rakudo/star/commit/29531ce355

[10:54] <dalek> star: 303d04f | moritz++ | Makefile:

[10:54] <dalek> star: fix PARROT_REL

[10:54] <dalek> star: review: https://github.com/rakudo/star/commit/303d04f89c

[10:57] <daxim> perl6: say sprintf '%s', "foo\nbar"

[10:58] <p6eval> pugs b927740, rakudo 2042ef, niecza v13-344-gf9b5518: OUTPUT«foo␤bar␤»

[10:58] <daxim> can that be golfed?

[10:59] <moritz> sure

[10:59] <moritz> perl6: say "foo\nbar"

[10:59] <p6eval> pugs b927740, rakudo 2042ef, niecza v13-344-gf9b5518: OUTPUT«foo␤bar␤»

[10:59] <daxim> ah ah

[11:00] <moritz> or what did you want?

[11:01] <daxim> now what if the argument is a complex expression?  is there any limit to what I may put into the {} style interpolation, or when should I resort to sprintf?

[11:01] <moritz> argument to what?

[11:02] <daxim> say

[11:02] <moritz> no, it an be an arbitrary expression

[11:03] <jnthn> We just parse Perl 6 inside of there

[11:03] <moritz> except that if you call it without parens, the precedence is not allowed to be loser than listop

[11:04] <jnthn> ("inside of there" = inside of the {...} when doing closure interpolation)

[11:04] <jnthn> bbi10

[11:07] <moritz> somehow I seem to get a corrupted nqp-2012.01.tar.gz from github

[11:08] <moritz> I've tried to upload it, but gave me an error during upload

[11:08] <moritz> then I refreshed, and github showed me that file with nearly the correct size (837K instead of 840K)

[11:09] <moritz> and when I then re-download it, it's only 20k

[11:09] <moritz> could somebody else please try to put up http://moritz.faui2k3.org/tmp/nqp-2012.01.tar.gz onto https://github.com/perl6/nqp/downloads ?

[11:12] *** Trashlord joined
[11:14] <moritz> http://news.perlfoundation.org/2012/01/craigslist-charitable-fund-don.html wow, another 100k USD for TPF

[11:24] <jnthn> moritz: Lemme try.

[11:24] <jnthn> moritz: https://github.com/perl6/nqp/downloads - better?

[11:24] <jnthn> oh no, it says 837 again

[11:24] <moritz> hm

[11:25] <moritz> maybe my 'du' command is just rounding it weirdly

[11:26] <moritz> jnthn: thanks, that step works now

[11:26] <moritz> $ tar -C rakudo-star-2012.01/nqp-2012.01 -xvzf nqp-2012.01.tar.gz

[11:26] <moritz> tar: rakudo-star-2012.01/nqp-2012.01: Cannot chdir: No such file or directory

[11:27] <moritz> ah, the tar line is wrong

[11:27] <jnthn> oh. :)

[11:27] <moritz> fixed.

[11:27] <moritz> the -C means 'chdir here', not 'unpack into this dir'

[11:28] <moritz> afk

[11:28] * jnthn didn't know what a bunch of the flags being given were ;)

[11:31] <dalek> star: 05ad4ae | moritz++ | Makefile:

[11:31] <dalek> star: fix nqp un-tar-ing

[11:31] <dalek> star: review: https://github.com/rakudo/star/commit/05ad4aea94

[11:49] *** yves left
[11:54] *** yves joined
[11:54] *** bacek left
[11:57] *** kcwu left
[11:57] <dalek> star: 7eea93b | jnthn++ | Makefile:

[11:57] <dalek> star: Use git:// for clones; for some reason, the http:// variant doesn't work out on my Linux box.

[11:57] <dalek> star: review: https://github.com/rakudo/star/commit/7eea93b81b

[11:59] *** Bzek left
[12:01] *** icwiener joined
[12:02] <dalek> star: 42bd9ab | jnthn++ | Makefile:

[12:02] <dalek> star: Fix PARROT_REVISION handling; add NQP_REVISION copying too.

[12:02] <dalek> star: review: https://github.com/rakudo/star/commit/42bd9ab10c

[12:03] *** dbr joined
[12:04] *** icwiener left
[12:05] *** icwiener joined
[12:15] *** icwiener left
[12:15] *** icwiener joined
[12:26] <moritz> woah, skel/build/gen_parrot.pl tries to build a parrot-3.6.0

[12:26] *** benabik left
[12:28] <jnthn> eek!

[12:28] <jnthn> moritz: oh...

[12:29] <jnthn> oh no...it doesn't git Rakudo from git, so it can't be that it's pulling master.

[12:29] <jnthn> *get

[12:29] <moritz> skel/ is inside the star repo

[12:29] <moritz> so it's a hardcoded path in there

[12:31] <jnthn> What's in your build/PARROT_REVISION?

[12:31] <jnthn> It looks like Configure.pl pulls from that.

[12:32] <moritz> that's RELEASE_3_11_0

[12:33] <moritz> jnthn: skel/build/gen_parrot.pl (star repo)  has 3.6.0 hardcoded

[12:34] <jnthn> oh, I see.

[12:34] <moritz> jnthn: and inside the rakudo-star-2012.01 repo, that's available as build/gen_parrot.pl

[12:34] <moritz> which is quite redundant

[12:34] <moritz> we could just as well pass that job to rakudo's Configure.pl

[12:35] <jnthn> moritz: If it can be told where to find the files rather than to check them out, yes

[12:35] <jnthn> moritz: But really it needs larger tweaks because it needs to build NQP too

[12:35] <moritz> jnthn: ah, right

[12:38] *** icwiener left
[12:39] *** icwiener joined
[12:39] *** [particle] left
[12:41] *** [particle] joined
[12:42] *** Exodist left
[12:42] *** trippeh_ joined
[12:42] *** Exodist joined
[12:43] *** icwiener left
[12:44] *** icwiener joined
[12:45] <jnthn> my ($reqsvn, $reqpar) = split(' ', <$REQ>);

[12:45] <jnthn> svn?!

[12:46] <moritz> might have been adopted (but not renamed) to git revisions. Or not, dunno.

[12:49] <jnthn> moritz: Think I'm going to hold on for an hour or two and see if pmichaud++ appears. He re-did the Configure stuff in NQP/Rakudo since the Star stuff was put together, and may have some ideas on the best way to update things.

[12:50] <moritz> jnthn: aye; it might be as simple as  use lib 'rakudo/tools/lib/'; and a few function calls

[12:50] <jnthn> moritz: aye.

[12:51] *** wollmers joined
[12:51] <moritz> at least I don't feel like going through a bunch of p5 code that looks remarkably like a bunch of p5 code that I've already fiddled with before... :-)

[12:52] <wollmers> \o

[12:52] <moritz> o/ wollmers 

[12:55] <wollmers> moritz: IO::Socket::INET seems to have a bug. It does not return FALSE (empty string) at eof, i.e. hangs in 'while ($line = $server.get)' after the last record. The same with .recv().

[12:59] <wollmers> Also IO::Socket::INET does not provide a 'timeout' parameter, which IMHO should be specced.

[13:00] <moritz> wollmers: thanks for the report

[13:00] <moritz> wollmers: unfortunately I don't know how to fix either of those, since the rakudo thing is really just a thin wrapper around parrot's Socket PMC

[13:01] <moritz> and that provides neither EOF check nor timeout

[13:02] <moritz> nom: say so Buf.new()

[13:02] <p6eval> nom 7d0453: OUTPUT«Bool::True␤»

[13:02] <moritz> hm, maybe that's the problem?

[13:02] <moritz> ah wait, recv returns a Str (but why?

[13:02] <moritz> )

[13:03] *** benabik joined
[13:03] <moritz> wouldn't it make much sense to return a Buf from recv?

[13:03] *** daemon left
[13:04] *** dalek left
[13:04] <moritz> hm, parrot's Socket.pmc has a get_bool vtable

[13:05] *** dalek joined
[13:05] *** ChanServ sets mode: +v dalek

[13:06] *** daemon joined
[13:06] <moritz> wollmers: LWP::Simple solves that problem by doing only a single $sock.recv(), not a loop

[13:06] <dalek> nqp/bs: 2c42b1f | jnthn++ | src/6model/serialization.h:

[13:06] <dalek> nqp/bs: Stub in a few serialization related data structures.

[13:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2c42b1f620

[13:06] <dalek> nqp/bs: 5c91393 | jnthn++ | / (2 files):

[13:06] <dalek> nqp/bs: Add serialize/deserialize functions to REPR function table.

[13:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5c91393465

[13:07] <moritz> wollmers: would that be a workaround for you?

[13:09] <wollmers> I know LWP::Simple. It parses the return code in the massage. I also do a 'last if $line ...'. This works, but isn't a solution to catch exceptional cases.

[13:11] <wollmers> One recv() is not enough, because recv does not return the complete message, if the message is larger than $somesize.

[13:12] *** moritz left
[13:12] *** moritz joined
[13:13] *** kcwu joined
[13:15] *** wolverian left
[13:16] <moritz> netsplit--

[13:16] *** kaleem left
[13:19] *** wolverian joined
[13:20] *** kaleem joined
[13:22] *** icwiener left
[13:33] *** kaleem left
[13:36] *** spine_ left
[13:36] *** bkolera joined
[13:48] * [Coke] yawns.

[13:49] * moritz too

[13:53] * jnthn three

[13:53] * benabik downs more coffee to resist.

[13:54] * moritz has now opened the window and, and to the poor chap sitting right in front of the window he shouted "freeze!"

[13:54] *** dakkar left
[13:55] * [Coke] drinks a tepid Coffee. . o O (and misses the /drink command from his MOO server.)

[13:56] *** dakkar joined
[13:59] <moritz> wow, I've just read some papers about image denoising and compression, and most used (among others) the same image. Now I've found http://www.cs.cmu.edu/~chuck/lennapg/ which explains where it comes from :-)

[14:00] *** djanatyn left
[14:04] *** djanatyn joined
[14:05] <jnthn> hehe :)

[14:05] <dalek> nqp/bs: 514c160 | jnthn++ | / (3 files):

[14:05] <dalek> nqp/bs: Stub in serialize/deserialize functions; initial bits of buffer allocation and sketch for writer.

[14:05] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/514c16086e

[14:05] <dalek> nqp/bs: 0f3e7a5 | jnthn++ | src/ops/nqp.ops:

[14:05] <dalek> nqp/bs: Add dynops that will be the interface to serialization.

[14:05] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/0f3e7a57de

[14:09] *** wollmers left
[14:12] <dalek> rakudo/nom: 3946ccf | moritz++ | src/core/Buf.pm:

[14:12] <dalek> rakudo/nom: make the empty Buf False

[14:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3946ccf658

[14:12] <dalek> roast: a6c38c4 | moritz++ | S03-operators/buf.t:

[14:12] <dalek> roast: test Buf boolification

[14:12] <dalek> roast: review: https://github.com/perl6/roast/commit/a6c38c4df9

[14:24] *** not_gerd joined
[14:25] <not_gerd> hello, #perl6

[14:25] *** alvis left
[14:25] *** shabble joined
[14:25] *** shabble left
[14:25] *** shabble joined
[14:26] <not_gerd> how do I get rakudo to print where a warning comes from?

[14:26] <not_gerd> specifically: use of uninitialized value of type Any in string context

[14:28] <moritz> hm, good question, let me experiment a bit

[14:28] <moritz> nom: CONTROL { default { say $_; say .backtrace } }; ~Any

[14:28] <p6eval> nom 7d0453: OUTPUT«use of uninitialized value of type Any in string context␤»

[14:28] <moritz> nom: CONTROL { default { say "in CONTROL"; say $_; say .backtrace } }; ~Any

[14:28] <p6eval> nom 7d0453: OUTPUT«use of uninitialized value of type Any in string context␤»

[14:29] <benabik> Why CONTROL instead of CATCH?

[14:29] <moritz> benabik: because warn throws control exceptions

[14:29] <benabik> :-/

[14:30] <moritz> but eeks

[14:30] <moritz> Mu.pm uses note, not warn

[14:31] <moritz> I'll have to change that.

[14:32] *** shabble left
[14:36] *** PacoAir joined
[14:44] *** xinming joined
[15:00] <dalek> rakudo/nom: b7cce80 | moritz++ | src/core/Mu.pm:

[15:00] <dalek> rakudo/nom: use &warn for uninitialized warnings

[15:00] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b7cce807c3

[15:00] <moritz> not_gerd: if you upgrade ot latest rakudo, you can do something like    CONTROL { default { .say; say .backtrace } }

[15:07] <fsergot> hi o/

[15:20] <not_gerd> moritz: doesn't really help - the backtrace only goes up to Mu.Str :(

[15:21] <moritz> not_gerd: that's weird; Do you have some example code that I could test?

[15:22] *** wtw_ left
[15:22] <not_gerd> moritz: the warning probably originates in the setting and can probably only be reproduced on Cygwin under Win64

[15:23] <moritz> eeks

[15:23] <not_gerd> (I'm trying to use Cygwin to cross-compile native Win64 binaries...)

[15:23] <not_gerd> that's the ultimate goal behind all my recent fixes...

[15:23] <moritz> not_gerd: try .backtrace.full

[15:24] *** kmwallio joined
[15:24] <moritz> that should give you all frames, including non-routine blocks from the setting

[15:26] <not_gerd> that only helps if the warning originates in user-supplied code - the one I'm looking for is already triggered with perl6 -e ''

[15:26] <moritz> not_gerd: oh. Does --ll-exception help?

[15:27] <not_gerd> no

[15:27] <moritz> eeks.

[15:27] <[Coke]> not_gerd: it should be possible to generate them directly with the MSVC free tools, neh?

[15:28] <not_gerd> [Coke]: where's the fun in that?

[15:28] <not_gerd> ;)

[15:28] <[Coke]> heee!

[15:28] * [Coke] is seeing a few autounfudges, wonder when sorear slipped these features in.

[15:30] <not_gerd> does make spectest work with -j5

[15:31] <moritz> not_gerd: test concurrency is controlled by the TEST_JOBS env var

[15:31] <moritz> not by the concurrency option you pass to 'make'

[15:31] <moritz> (but yes, rakudo build is safe for multiple jobs; you just don't win very much)

[15:35] *** tokuhirom joined
[15:38] *** kmwallio left
[15:40] *** fsergot left
[15:58] *** tokuhirom left
[16:06] <dalek> nqp/bs: 938a5f3 | jnthn++ | src/pmc/serializationcontext.pmc:

[16:06] <dalek> nqp/bs: When we get an object added and it has an STable that was never tagged with an SC, tag it with this one.

[16:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/938a5f3b09

[16:06] <dalek> nqp/bs: af3d1e4 | jnthn++ | t/serialization/01-basic.t:

[16:06] <dalek> nqp/bs: Add sanity test for serializing an empty SC, then deserializing it back to one.

[16:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/af3d1e40bb

[16:06] <dalek> nqp/bs: 2e1ef0f | jnthn++ | src/6model/serialization. (2 files):

[16:06] <dalek> nqp/bs: First crack at writing of SC header and assembly of the various tables and data segments. Gets the initial sanity tests to pass.

[16:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2e1ef0f947

[16:14] *** bkolera left
[16:23] *** birdwindupbird left
[16:30] *** bkolera joined
[16:37] *** bkolera left
[16:42] *** kaleem joined
[16:55] *** bkolera joined
[17:06] *** thou joined
[17:14] *** GlitchMr42 is now known as GlitchMr

[17:25] *** ruoso left
[17:25] *** sudokode left
[17:26] *** jrockway_ left
[17:26] *** sivoais left
[17:26] *** jrockway joined
[17:26] *** ruoso joined
[17:26] *** kshannon left
[17:26] *** sivoais joined
[17:27] *** kshannon joined
[17:27] * [Coke] ponders a #perl6-offcolor

[17:30] *** cognominal left
[17:30] <sorear> good * #perl6

[17:30] <sorear> off...color?

[17:31] *** cognominal joined
[17:33] <[Coke]> rude.

[17:33] <dalek> roast: cf47754 | coke++ | S (11 files):

[17:33] <dalek> roast: niecza autounfudge

[17:33] <dalek> roast: review: https://github.com/perl6/roast/commit/cf47754110

[17:34] * jnthn is glad the default is to be oncolor :)

[17:34] <moritz> ydy<<<<<<<yxxxxxxxx2 jhu hju juh l5555

[17:37] <TimToady> children and linguists both say whatever they feel like :)

[17:37] <phenny> TimToady: 08:40Z <sorear> tell TimToady std: constant foo == 5;

[17:37] <phenny> TimToady: 09:01Z <sorear> tell TimToady std: my Set $x .= pies # also, why is 'new' a function in CORE.setting?

[17:47] <pmichaud> good morning, #perl6

[17:47] <phenny> pmichaud: 10:38Z <moritz> tell pmichaud to please turn on dalek pushing for the rakudo/star repo, see https://github.com/perl6/mu/blob/master/misc/dalek-push.txt for instructions

[17:47] <phenny> pmichaud: 10:39Z <moritz> tell pmichaud and maybe turn the 'rakudo' user into an organization, and give jnthn and maybe me administrative powers?

[17:47] <jnthn> pmichaud! \o/

[17:48] <[Coke]> pmichaud++: \o/

[17:49] *** not_gerd left
[17:50] <dalek> star: 05ad4ae | moritz++ | Makefile:

[17:50] <dalek> star: fix nqp un-tar-ing

[17:50] <dalek> star: review: https://github.com/rakudo/star/commit/05ad4aea94

[17:50] <dalek> star: 7eea93b | jnthn++ | Makefile:

[17:50] <dalek> star: Use git:// for clones; for some reason, the http:// variant doesn't work out on my Linux box.

[17:50] <dalek> star: review: https://github.com/rakudo/star/commit/7eea93b81b

[17:50] <dalek> star: 42bd9ab | jnthn++ | Makefile:

[17:50] <dalek> star: Fix PARROT_REVISION handling; add NQP_REVISION copying too.

[17:50] <dalek> star: review: https://github.com/rakudo/star/commit/42bd9ab10c

[17:50] *** not_gerd joined
[17:51] <pmichaud> dalek pushing now enabled for star repo

[17:51] <jnthn> yay

[17:51] <jnthn> pmichaud: I'd like to seek help on updating Star in a "we build NQP" world. I suspect that the Configure refactors you did should play a part in this?

[17:52] <pmichaud> probably (more)

[17:52] *** rsimoes1 joined
[17:52] <pmichaud> iirc, most of star's configure actually delegates to other configures

[17:53] <jnthn> pmichaud: Well, it has its own gen_parrot script.

[17:53] <pmichaud> that's left over from the days when rakudo had its own gen_parrot script :)

[17:53] <jnthn> I'd be happy if it delegated that, but it seems that what it delegates to would want to check out.

[17:53] <jnthn> aha :)

[17:53] <pmichaud> you're correct that star hasn't had its configure updated the way that i updated nqp/rakudo

[17:53] <jnthn> Well, it's the first nom-based Star. :)

[17:54] <pmichaud> when are you wanting to have this done?

[17:54] <jnthn> And the configure updates weren't done in master, iirc.

[17:54] <pmichaud> I could probably re-do star's configuration tomorrow morning.

[17:54] <masak> * *, #perl6

[17:55] <jnthn> pmichaud: That'd be fine (more)

[17:55] <pmichaud> anyway, the new configure scripts for nqp/nom have a "shared" configure library of sorts; it's clear that star ought to use that same library (and currently does not)

[17:55] <jnthn> pmichaud: I want to have the Star release out this week. I'm happy enough to wait until tomorrow.

[17:56] <pmichaud> I can do an update for tomorrow.  That's a good place for me to be re-starting.

[17:56] <jnthn> pmichaud: I don't trust myself to make a decent job of the Configure stuff, tbh. Or I suspect if I do it, you'll spot things you'd want to do differently. :)

[17:56] <jnthn> pmichaud: So if you're up for it, I'd happily "delegate" this bit to you ;)

[17:56] <pmichaud> okay, it's mine.

[17:56] <jnthn> pmichaud: Means I can continue working on serialization stuff this evening. :)

[17:56] <pmichaud> that's a much better division of labor for today/tomorrow, methinks.

[17:57] <jnthn> wfm :)

[17:57] <pmichaud> afk for a bit

[17:57] *** dakkar left
[18:00] *** cognominal_ joined
[18:02] <tadzik> 'evening

[18:03] <jnthn> hi, tadzik 

[18:03] *** cognominal left
[18:03] <masak> tadzik! \o/

[18:04] <tadzik> \o/

[18:05] <dalek> mu: 75408b3 | moritz++ | misc/dalek-conf.json:

[18:05] <dalek> mu: disable rakudo/star pulling, since we push to it

[18:05] <dalek> mu: review: https://github.com/perl6/mu/commit/75408b3915

[18:08] <sorear> TimToady: of the two tells, the second is much more problematic

[18:12] <TimToady> I've already got a fix for both tells, but it's tangled with the \ and | changes currently :/

[18:15] <TimToady> the latter is also almost done, but need to add the new terms so the checker doesn't complain about missing subs

[18:16] *** xinming left
[18:16] *** xinming joined
[18:19] *** fsergot joined
[18:22] *** kmwallio joined
[18:24] <jnthn> dinner &

[18:25] <dalek> nqp/bs: 01163e3 | jnthn++ | t/serialization/01-basic.t:

[18:25] <dalek> nqp/bs: Add next set of tests, currently failing, for really being able to serialize something with P6int representation.

[18:25] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/01163e314d

[18:25] <dalek> nqp/bs: 2f738dc | jnthn++ | src/6model/serialization. (2 files):

[18:25] <dalek> nqp/bs: Sketch out main serialization work loop.

[18:25] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2f738dc24c

[18:25] <dalek> nqp/bs: 188c5d1 | jnthn++ | src/6model/serialization_context. (2 files):

[18:25] <dalek> nqp/bs: Quick and dirty functions for finding object and stable indexes in SCs.

[18:25] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/188c5d1a00

[18:25] <dalek> nqp/bs: b4d65ed | jnthn++ | src/6model/serialization_context. (2 files):

[18:25] <dalek> nqp/bs: Add convenience functions for getting SC handle and description.

[18:25] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b4d65edca0

[18:25] <dalek> nqp/bs: 3d9cc14 | jnthn++ | src/6model/serialization. (2 files):

[18:26] <dalek> nqp/bs: First cut of individual object serialization processing (though no REPRs yet implement actually serializing themselves). Also add inital code for making SC dependency table entries and string heap addition.

[18:26] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/3d9cc14cd4

[18:26] <[Coke]> http://news.ycombinator.com/item?id=3504160 - sorear, thought you'd like the niecza comment there.

[18:27] <[Coke]> also, craigslist++

[18:28] *** preflex joined
[18:29] *** MayDaniel joined
[18:31] *** MayDaniel left
[18:33] *** MayDaniel joined
[18:34] <moritz> std: 1 := 2

[18:34] <p6eval> std 40d10f7: OUTPUT«ok 00:01 109m␤»

[18:34] <TimToady> std knows next to nothing about lvalue-ness

[18:34] <moritz> ok

[18:34] <TimToady> or bvalue-ness

[18:34] <moritz> thought so

[18:36] <moritz> niecza: 1 := 2

[18:36] <p6eval> niecza v13-344-gf9b5518: OUTPUT«===SORRY!===␤␤Cannot use bind operator with this LHS at /tmp/5RxjzyRKZz line 1 (EOF):␤------> 1 := 2⏏<EOL>␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /ho…

[18:39] *** daxim left
[18:40] <sorear> [Coke]: interesting

[18:40] <sorear> [Coke]: what about craigslist?

[18:41] <doy> sorear: http://news.perlfoundation.org/2012/01/craigslist-charitable-fund-don.html

[18:41] <moritz> sorear: they've donated 100k USD for p5 development

[18:42] *** birdwind1pbird joined
[18:43] <sorear> ah.  craigslist++ indeed

[18:43] *** kmwallio left
[18:44] *** bkolera left
[18:45] *** raiph left
[18:45] <[Coke]> ONE HUNDRED KILODOLLARS!

[18:47] *** birdwindupbird joined
[18:53] *** MayDaniel left
[18:54] * cognominal_ is reading Array.pm and does not understand how the $!whence attribue is executed

[18:54] <sorear> evil?

[18:56] <cognominal_> maybe scalar->whence in container.c ...

[19:00] *** bkolera joined
[19:02] *** raiph joined
[19:04] <sorear> cognominal_: probably

[19:05] * [Coke] determines that partcl is still mostly dead. Ah well.

[19:11] * sorear looks for something smallish to do while TimToady++ sorts out kinks in declarator parsing

[19:11] <[Coke]> add ObjAt?

[19:12] <[Coke]> I have no idea how small that is. ;)

[19:12] <[Coke]> (but it's blocking the borrowing of rakudo's Temporal)

[19:14] <cognominal_> rakudo feels like a 5 cushion billiard

[19:17] *** kaleem left
[19:18] <TimToady> sorear: add Sets?

[19:21] *** fsergot left
[19:22] <sorear> cognominal_: What is a 5 cushion billiard?

[19:25] <cognominal_> http://en.wikipedia.org/wiki/Three-cushion_billiards, only more difficult

[19:25] *** _dbr joined
[19:26] *** sudokode joined
[19:26] <cognominal_> meaning, one must go thru many files in different languages (pir, nqp, perl6) to understand the inner working.

[19:27] <cognominal_> A call ripples thru these layers of code like a billiard ball bounces on cushions.

[19:27] *** dbr left
[19:27] * sorear looks for a list of the requirements for Set

[19:28] <TimToady> just make the Set gist I posted work :)

[19:28] <TimToady> well, it works already, but probably not as built-in

[19:28] <jnthn> cognominal_: There's hardly any PIR in Rakudo these days.

[19:28] <sorear> o/ jnthn

[19:28] <jnthn> hi sorear 

[19:29] <jnthn> cognominal_: You missed C off the list of languages you maybe need to read though :)

[19:30] <cognominal_> at least this one is well defined :)

[19:30] * sorear is now trying to figure out how Rakudo's WHICH/ObjAt subsystem works

[19:31] <jnthn> At the moment, I think that handling is entirely done in the setting.

[19:31] <sorear> (At some point I'd like an overview of how LoL, $obj.lol, **@foo, etc work and fit together in Rakudo.)

[19:31] <jnthn> (Me too.)

[19:32] <jnthn> sorear: I think pmichaud++'s work on the synopsis on iterator/list stuff should help a lot.

[19:32] <sorear> phenny: tell pmichaud At some point I'd like an overview of how LoL, $obj.lol, **@foo, etc work and fit together in Rakudo

[19:32] <phenny> sorear: I'll pass that on when pmichaud is around.

[19:34] <sorear> jnthn: seems ObjAt is also mentioned in BOOTSTRAP

[19:34] <sorear> hey, what is this "stub" declarator?

[19:35] <jnthn> sorear: Just an NQP-specific package declarator that comes in handy with bootstrapping.

[19:36] <cognominal_> I don't think I am not yet proficient enough to wire in the  resizable(bool|ineteger|float)array.pmc into rakudo but at least it gives me a motivation to understand the innards of rakudo.

[19:36] <sorear> nom: class A  { }; say A.new.WHICH

[19:36] <p6eval> nom b7cce8: OUTPUT«A|-6577862525767062189␤»

[19:36] <jnthn> sorear: I think it's need to exist will likely go away once I'm done with the current serialization work, though.

[19:36] <sorear> nom: class A  { }; say A.new.WHICH.perl

[19:36] <p6eval> nom b7cce8: OUTPUT«ObjAt.new()␤»

[19:36] <cognominal_> num:  my int @a; @a[666] = 42

[19:36] <sorear> Why is nqp::where returning a negative number?

[19:37] <sorear> nom: class A  { }; say nqp::where(A.new)

[19:37] <p6eval> nom b7cce8: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤  in sub say at src/gen/CORE.setting:5935␤  in block <anon> at /tmp/8PScieUBRV:1␤  in <anon> at /tmp/8PScieUBRV:1␤»

[19:37] <cognominal_> nom:  my int @a; @a[666] = 42

[19:37] <p6eval> nom b7cce8: OUTPUT«Method 'postcircumfix:<[ ]>' not found for invocant of class 'Integer'␤  in block <anon> at /tmp/77lBvzd0AT:1␤  in <anon> at /tmp/77lBvzd0AT:1␤»

[19:37] <sorear> nom: class A  { }; say nqp::p6box_i(nqp::where(A.new))

[19:37] <p6eval> nom b7cce8: OUTPUT«7140166736082218007␤»

[19:37] <sorear> nom: class A  { }; say nqp::p6box_i(nqp::where(A.new))

[19:37] <p6eval> nom b7cce8: OUTPUT«-5162438105098349581␤»

[19:37] <sorear> Some kind of xor-masking protocol?

[19:38] <sorear> nom: class A  { }; say nqp::p6box_i(nqp::where(A.new)).fmt('%x')

[19:38] <p6eval> nom b7cce8: OUTPUT«4c12b9c29ccd7b7d␤»

[19:38] <sorear> nom: class A  { }; say nqp::p6box_i(nqp::where(A.new)).fmt('%x')

[19:38] <p6eval> nom b7cce8: OUTPUT«6d2ac891d03ab96b␤»

[19:38] <jnthn> Beats me. :)

[19:38] <jnthn> cognominal_: That's not a simple task at all. I'm not sure if it's the right approach either.

[19:40] <jnthn> cognominal_: It won't pack int8 properly, for example. Or some my SomeCompactStruct @foo

[19:40] * jnthn hides IRC and digs back into coding

[19:41] *** pyrimidine joined
[19:42] *** bkolera left
[19:45] *** fsergot joined
[19:45] *** not_gerd left
[19:47] <TimToady> hmm, there are a bunch of tests that use a signature of (|$), and I'm wondering what that should change to...

[19:48] <TimToady> I could allow (|) I suppose

[19:49] <TimToady> or a proto could just assume that, maybe, if you don't give any sig

[19:53] <TimToady> I worry that (|) will be taken as a Rorschach test...

[19:54] *** birdwind1pbird left
[19:55] *** colomon left
[19:56] <TimToady> jnthn: what does (|$) actually do that leaving out the sig wouldn't do?

[19:58] *** colomon joined
[19:58] <jnthn> TimToady: An empty sig would mean "0 arguments"

[19:58] <TimToady> doesn't () mean that?

[19:59] <jnthn> TimToady: proto foo() { } and proto foo { } are currently treated the same

[19:59] <jnthn> TimToady: As elsewhere. Modulo using placeholders.

[19:59] <TimToady> proto foo() actually makes no sense

[19:59] <TimToady> can't have multi without args

[20:00] <jnthn> Well, it'd only permit you to write one candidate, yeah. :)

[20:00] <jnthn> Well

[20:00] <jnthn> proto method foo() { } # kinda does

[20:00] *** bkolera joined
[20:00] <jnthn> That one is useful in some cases too

[20:00] <TimToady> maybe {*} acts kind of like a placeholder if there's no ()

[20:01] <jnthn> That's not much hassle to do.

[20:01] <jnthn> We use proto foo(|$) { * } a load in CORE.setting

[20:02] <jnthn> Because the setting wants explicit protos.

[20:02] <TimToady> at *best*, (|) would be call the "butt operator"

[20:02] <jnthn> But most users don't ever bother writing a proto, they rely on generation.

[20:02] <TimToady> *called

[20:02] <jnthn> ...wow!

[20:02] <jnthn> I hadn't made that, er, association. :)

[20:03] <TimToady> Rorschach of course admits to many interpretations of bilateral symmetry

[20:03] <TimToady> "It's...a coffee bean...yeah, that's the ticket!"

[20:06] <jnthn> .oO( If I thought it was an odd-looking Perl 6 signature, do I pass or fail my Rorschach test? :) )

[20:06] *** fsergot2 joined
[20:08] <sorear> What is the one-argument candidate for === used for?

[20:10] <benabik> sorear: [===], I would guess

[20:10] *** fsergot left
[20:11] *** Radvendii joined
[20:11] <Radvendii> o/ everyone

[20:12] <tadzik> hey Radvendii 

[20:12] <TimToady> jnthn: you have to XOR that with whether your therapist is a Freudian

[20:13] <sorear> Wait, wait, wait, wait

[20:13] <sorear> S03:4471 appears to say that the degenerate cases should be defined as multis *against the reduction operator itself* !?

[20:13] <TimToady> nom: say [===] 42;

[20:13] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[20:14] <sorear> as in, multi infix:<[+]>() { 0 }

[20:14] <Radvendii> TimToady: what's ===?

[20:16] <TimToady> Radvendii: sometimes we get just a little bit tired of reading out the documents to you for things you could grep

[20:16] <Radvendii> sorry

[20:16] <Radvendii> i'm on it

[20:16] <colomon> sorear: huh.  it does seem to make sense, assuming the system can handle both a meta op and an explicitly specified op with the same name.

[20:17] <sorear> Radvendii: look for 'Value identity' in S03

[20:17] <Radvendii> is the documentation somewhere i can download? (because google ignores characters like =)

[20:17] <[Coke]> github.com/perl6/specs

[20:17] <Radvendii> vielen dank

[20:18] <jnthn> colomon: "huh" is my reaction to. :) I'd always known it as a 0-arity candidate of the operator itself.

[20:18] <[Coke]> Kein Problem.

[20:18] <colomon> right, I implemented a bunch of those back in the ng days

[20:19] <TimToady> ah well, S03 allows reduction ops to be defined either way

[20:19] <bbkr2> rakudo: my $x = :(Int); $x.^methods>>.say

[20:19] <p6eval> rakudo b7cce8: OUTPUT«(signal SEGV)perl␤params␤returns␤count␤»

[20:19] <TimToady> if it can be generated adequately from the bare op, that's fine

[20:19] * bbkr2 reports

[20:19] <TimToady> if we don't really need the [op] forms, we can ignore that bit

[20:19] <jnthn> bbkr2: Wow. :)

[20:20] <jnthn> bbkr2: SEGVs in Rakudo are relatively rare these days :)

[20:20] <sorear> TimToady: when generating from a bare op, what does [op] () mean?

[20:21] <[Coke]> bbkr2++!

[20:26] <sorear> also, I need to find a cheap way to implement Mu.WHICH

[20:27] <sorear> 'memory address' doesn't work so well when you having a moving/compacting GC

[20:28] <sorear> hmm, S03 says that WHICH is a macro, not a method.  How are user classes intended to provide WHICH functionality?

[20:28] <dalek> std: b808250 | larry++ | / (2 files):

[20:28] <dalek> std: initializer and capture/parcel fixes

[20:28] <dalek> std: 

[20:28] <dalek> std: Various tweaks related to initializer fix.  We now allow:

[20:28] <dalek> std:     my \x = 42;

[20:28] <dalek> std:     sub foo (\x)

[20:29] <dalek> std:     sub bar (|y)

[20:29] <dalek> std:     sub baz (:\z)

[20:29] <dalek> std:     proto thing (|)

[20:29] <dalek> std:     my Foo $x .= foomethod;

[20:29] <dalek> std: Removed new function from CORE.

[20:29] <dalek> std: review: https://github.com/perl6/std/commit/b808250f87

[20:29] <Radvendii> y'know how [||@a] is used for multidimensional arrays (NYI)

[20:29] <Radvendii> well, how do i fold over ||?

[20:29] <sorear> you can only fold over infix operators

[20:29] <Radvendii> || is infix, is it not?

[20:29] <sorear> in [||@a], || is a prefix

[20:30] <Radvendii> no no, i just have [||] in my code

[20:30] <sorear> TimToady++ !

[20:30] <Radvendii> but it says "multidimensional indexes [indicies] are not supported"

[20:30] *** birdwindupbird left
[20:30] <sorear> Radvendii: do you have [||] properly in term context?

[20:31] <bbkr2> Can I match array/parcel/hash against Signature? For example I received some JSON Request object and I need to check if it meets the spec defined as :(Str :$method, :@params, Int :$id)

[20:31] <Radvendii> i have the equivalent of [||](@list)

[20:31] <sorear> I think you need a space there

[20:31] <Radvendii> ah

[20:32] <sorear> std: [||](1,2,3)

[20:32] <p6eval> std 40d10f7: OUTPUT«ok 00:01 110m␤»

[20:32] <sorear> std: [||] (1,2,3)

[20:32] <p6eval> std 40d10f7: OUTPUT«ok 00:01 110m␤»

[20:32] <sorear> nom: [||](1,2,3)

[20:32] <p6eval> nom b7cce8:  ( no output )

[20:32] <sorear> hmm

[20:32] <Radvendii> thes space doesn't help

[20:32] <sorear> nom: say [||](False,True,False)

[20:32] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[20:33] <sorear> seems to work

[20:33] <sorear> nom: my @list = 0,1,0; say [||](@list)

[20:33] <p6eval> nom b7cce8: OUTPUT«1␤»

[20:33] *** molaf left
[20:34] <Radvendii> nom: sub a {return [||](1,0,1)}; say a();

[20:34] <p6eval> nom b7cce8: OUTPUT«1␤»

[20:34] <sorear> you should get in the habit of using spaces more often

[20:34] <Radvendii> okay.

[20:35] <Radvendii> alright, that isn

[20:36] <Radvendii> isn't the issue, because the same error occurs when i use any()

[20:37] <Radvendii> also, why do the error messages give "near XXX" but not actually include the text which produces the error?

[20:37] *** ksi joined
[20:40] *** pyrimidine left
[20:41] <jnthn> Radvendii: Sometimes Rakudo's sense of exactly where the error was isn't as accurate as it should be.

[20:44] <Radvendii> ah

[20:44] <Radvendii> i see

[20:44] <jnthn> Radvendii: On the todo list, along with much else. :)

[20:44] <Radvendii> or what the error was :P

[20:45] <dalek> nqp/bs: 8bd5e5b | jnthn++ | src/6model/serialization. (2 files):

[20:45] <dalek> nqp/bs: Get write function table entries in place for int/num/str.

[20:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/8bd5e5b27a

[20:45] <dalek> nqp/bs: c81280c | jnthn++ | src/6model/reprs/P6int.c:

[20:45] <dalek> nqp/bs: Give P6int a serialize method.

[20:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/c81280cecd

[20:45] <dalek> nqp/bs: aff34ae | jnthn++ | src/6model/serialization.c:

[20:45] <dalek> nqp/bs: Oops helps to write into the correct table.

[20:45] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/aff34aee09

[20:46] <Radvendii> jnthn: yeah, no worries. just confused.

[20:50] *** kaare_ joined
[20:52] *** Radvendii left
[20:59] *** jjore left
[21:03] *** kcwu left
[21:05] *** kaare_ left
[21:09] *** GlitchMr left
[21:13] *** kaare_ joined
[21:15] *** kcwu joined
[21:16] *** kcwu_ joined
[21:16] *** kcwu_ left
[21:17] *** Radvendii joined
[21:18] *** kaare_ left
[21:19] <Radvendii> nom: class A {method a {say "hi"} method b {a} }; A.b

[21:19] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[21:19] <Radvendii> nom: class A {method a {say "hi"}; method b {a} }; A.b

[21:19] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a' called (line 1)␤»

[21:19] <Radvendii> nom: class A {method a {say "hi"}; method b {self.a} }; A.b

[21:19] <p6eval> nom b7cce8: OUTPUT«hi␤»

[21:19] <Radvendii> nom: class A {method a {say "hi"}; method b {.a} }; A.b

[21:19] <p6eval> nom b7cce8: OUTPUT«Method 'a' not found for invocant of class 'Any'␤  in method b at /tmp/VOhx_aRL_e:1␤  in block <anon> at /tmp/VOhx_aRL_e:1␤  in <anon> at /tmp/VOhx_aRL_e:1␤»

[21:20] <Radvendii> so self is needed to call methods from within the class...

[21:20] <jnthn> Yes.

[21:21] *** kaare_ joined
[21:22] *** kaare_ left
[21:22] *** kaare__ joined
[21:22] <colomon> nom: class A {method a(A:U:) {say "hi"}; method b {.a} }; a.b

[21:22] *** kaare__ is now known as kaare_

[21:22] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a' called (line 1)␤»

[21:22] <colomon> nom: class A {method a(A:U:) {say "hi"}; method b {.a} }; A.a

[21:22] <p6eval> nom b7cce8: OUTPUT«hi␤»

[21:23] <jnthn> colomon: .b is a call on $_

[21:24] *** Radvendii left
[21:25] <cognominal_> I often fall for that one too :(

[21:30] <cognominal_> nom: my Int @a = "foo"

[21:30] <p6eval> nom b7cce8:  ( no output )

[21:30] <cognominal_> nom: my Int @a = "foo"; say @a

[21:30] <p6eval> nom b7cce8: OUTPUT«foo␤»

[21:30] <cognominal_> nom: my Int @a; @a = "foo"; say @a

[21:30] <p6eval> nom b7cce8: OUTPUT«foo␤»

[21:31] <jnthn> wtf, I though we were passing tests on typed arrays...

[21:31] <jnthn> *thought

[21:31] <jnthn> nom: my Int @a; @a[0] = 'foo'

[21:32] <p6eval> nom b7cce8: OUTPUT«Type check failed in assignment to '$v'; expected 'Int' but got 'Str'␤  in block <anon> at /tmp/rtNhwZTdvu:1␤  in <anon> at /tmp/rtNhwZTdvu:1␤»

[21:32] <jnthn> Ah...some crap with assignment.

[21:32] <jnthn> er, list assignment

[21:32] <jnthn> Or more likely Array.STORE

[21:32] <cognominal_> yup

[21:32] <jnthn> Though I know Array.STORE to be problematic in multiple ways.

[21:33] <cognominal_> reading the code, I know how to make it fail :)

[21:34] <cognominal_> probably should be redefined in TypedArray

[21:43] *** molaf joined
[21:49] *** kaare_ left
[21:51] *** _RobiX_ joined
[21:53] *** _RobiX_ left
[21:56] *** Radvendii joined
[21:57] <Radvendii> o/

[22:02] *** cognominal joined
[22:04] <Radvendii> nom: say ( given 5 {when 5 {3} } );

[22:04] <p6eval> nom b7cce8: OUTPUT«3␤»

[22:04] *** _dbr left
[22:05] *** cognominal_ left
[22:06] <dalek> nqp/bs: 2ec73d0 | jnthn++ | src/6model/serialization. (2 files):

[22:06] <dalek> nqp/bs: Start to sketch out deserialization related state and overall algorithm.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/2ec73d0825

[22:06] <dalek> nqp/bs: 5bf6da5 | jnthn++ | src/6model/serialization. (2 files):

[22:06] <dalek> nqp/bs: Fill out initial steps of deserialization: disecting the data into tables/sections and bounds/offset sanity checking.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/5bf6da5ea0

[22:06] <dalek> nqp/bs: d020e73 | jnthn++ | src/ops/nqp.ops:

[22:06] <dalek> nqp/bs: Fossil.

[22:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/d020e739fa

[22:06] <Radvendii> nom: my $a = 5; given "$a" { when 5 {say "yes" } };

[22:06] <p6eval> nom b7cce8: OUTPUT«yes␤»

[22:09] <cognominal> nom: given "5" {  say "yes" when 5 }

[22:09] <p6eval> nom b7cce8: OUTPUT«yes␤»

[22:10] <benabik> nom: say 5 ~~ '5'

[22:10] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[22:12] <cognominal> #perl6 as progressive optimizer

[22:13] <Radvendii> is $s special somehow? because it keeps confusing my syntax highlighter (it might just be the syntax highlighter, im just curious)

[22:17] *** cognominal_ joined
[22:20] *** cognominal left
[22:22] <Radvendii> nom: say 'a' !~~ 'b'

[22:22] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[22:22] <Radvendii> nom: say 'a' !~ 'b'

[22:22] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Unsupported use of !~ to do negated pattern matching; in Perl 6 please use !~~ at line 1, near "'b'"␤»

[22:23] <benabik> Radvendii: $s shouldn't be special.

[22:23] <benabik> Radvendii: What are you using for highlighting?

[22:23] <Radvendii> vim 7.3

[22:23] <Radvendii> why is it "!~~" as opposed to "!~"? it's not "!=="...

[22:24] <jnthn> It can be.

[22:24] <Radvendii> oh.

[22:24] <Radvendii> never mind then

[22:24] <Radvendii> but isnt !== the negation of ===?

[22:24] <jnthn> != is, something like, "so we don't get lynched by the court of language expectations" or something :)

[22:25] <jnthn> No, != and ne are the only irregular ones, I think

[22:25] <jnthn> Everywhere else, the rule is !op

[22:25] <benabik> vim 7.3 doesn't do anything strange with $s vs $foo with both filetype perl or filetype perl6

[22:25] <Radvendii> oh

[22:25] <Radvendii> cool

[22:25] <Radvendii> good to know

[22:25] <Radvendii> and... != goes out of my memory!

[22:26] <Radvendii> benabik: try typing in given $s { \n when 'a' { } \n }

[22:26] <Radvendii> benabik: or role MyRole[$s,$i] {\n method a { } \n }

[22:27] <Radvendii> the role one works better than given, but still screws up later on in my code

[22:28] <benabik> Radvendii: It seems to be confusing $s with the s/// operator.  Bug in the highligher.

[22:28] <Radvendii> That would make sense

[22:28] <benabik> The role works better because it escapes back out to code when it sees the {

[22:28] <Radvendii> but it doesnt entirely...

[22:28] <benabik> But for `given $s {}` it expects `s{}{}`, I think.

[22:29] <Radvendii> if you have a more complex thing (with method at_pos and FETCH =>, STORE =>) it screws up on the STORE => method { }

[22:29] <Radvendii> benabik: yup. I

[22:29] <Radvendii> I'll let the author know, if i can find who he is...

[22:30] *** bkolera left
[22:31] <Radvendii> jnthn: can you also do !eq?

[22:31] <jnthn> nom: say "a" !eq "a"

[22:31] <p6eval> nom b7cce8: OUTPUT«Bool::False␤»

[22:31] <jnthn> nom: say "a" !eq "b"

[22:31] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[22:31] <jnthn> Appears so :)

[22:31] <Radvendii> sweet

[22:32] <Radvendii> sorry, should have just done that 

[22:32] <jnthn> Radvendii: It's actually parsed as '!' <infix>

[22:32] <jnthn> Or along those lines

[22:32] <Radvendii> so ! is a meta-op? like X or Z?

[22:32] <jnthn> Exactly.

[22:32] <Radvendii> cool

[22:33] <Radvendii> nom: say 'a' !!eq 'a'

[22:33] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[22:33] <Radvendii> tee hee

[22:33] <Radvendii> you can double up the bangs

[22:36] <colomon> nom: say 'a' !!!!!!!!!!!eq 'a'

[22:36] <p6eval> nom b7cce8: OUTPUT«Bool::False␤»

[22:36] <Radvendii> so !!!=== would be a valid operator :P

[22:37] <Radvendii> yup. as many !s as you want

[22:37] <Radvendii> nom: say <a b c> XX (1,2,3)

[22:37] <p6eval> nom b7cce8: OUTPUT«a 1 a 2 a 3 b 1 b 2 b 3 c 1 c 2 c 3␤»

[22:38] <Radvendii> nom: say <[<a b>],[<c d>]> XX ([1,2,3],[4,5,6],[7,8])

[22:38] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Confused at line 1, near "],[<c d>]>"␤»

[22:38] <Radvendii> nom: say [<a b>],[<c d>] XX ([1,2,3],[4,5,6],[7,8])

[22:38] <p6eval> nom b7cce8: OUTPUT«a 1 a 2 a 3 b 1 b 2 b 3 a 4 a 5 a 6 b 4 b 5 b 6 a 7 a 8 b 7 b 8 c 1 c 2 c 3 d 1 d 2 d 3 c 4 c 5 c 6 d 4 d 5 d 6 c 7 c 8 d 7 d 8␤»

[22:39] <Radvendii> it'll do it to a deapth of 2

[22:42] *** slavik left
[22:42] <TimToady> um, nom is being too accepting there with !!

[22:42] <TimToady> std: say 'a' !!eq 'a'

[22:42] <p6eval> std b808250: OUTPUT«===SORRY!===␤An infix may not start with !! at /tmp/HHkq_qDaBr line 1:␤------> say 'a' !!eq⏏ 'a'␤Parse failed␤FAILED 00:01 110m␤»

[22:43] <Radvendii> awww....

[22:43] <Radvendii> party pooper

[22:43] <Radvendii> ;)

[22:43] <Radvendii> niecza: say 'a' !!eq 'a'

[22:43] <p6eval> niecza v13-344-gf9b5518: OUTPUT«===SORRY!===␤␤An infix may not start with !! at /tmp/3Tx17OOP_7 line 1:␤------> say 'a' !!eq⏏ 'a'␤␤Parse failed␤␤»

[22:43] <TimToady> otherwise we can't parse ??!! unambiguously

[22:44] <Radvendii> i know, i'm kidding. there's no use for a double-negative

[22:44] <TimToady> however, you can still do it, if you're sneaky

[22:44] <Radvendii> nom: say 'a' x 0

[22:44] <p6eval> nom b7cce8: OUTPUT«␤»

[22:44] <TimToady> niecza: 'a' ![!eq]' 'a'

[22:44] <p6eval> niecza v13-344-gf9b5518: OUTPUT«===SORRY!===␤␤Two terms in a row at /tmp/uV74ok8wmY line 1:␤------> 'a' ![!eq]' '⏏a'␤␤Parse failed␤␤»

[22:44] <Radvendii> :P

[22:44] <colomon> niecza: say 'a' !!eq 'a'

[22:45] <TimToady> hmm, that should work

[22:45] <p6eval> niecza v13-344-gf9b5518: OUTPUT«===SORRY!===␤␤An infix may not start with !! at /tmp/vwlFYWufPt line 1:␤------> say 'a' !!eq⏏ 'a'␤␤Parse failed␤␤»

[22:45] <Radvendii> apparently, not sneaky enough

[22:45] <TimToady> oh

[22:45] <TimToady> niecza: 'a' ![!eq] 'a'

[22:45] <p6eval> niecza v13-344-gf9b5518:  ( no output )

[22:45] <TimToady> niecza: say 'a' ![!eq] 'a'

[22:45] <p6eval> niecza v13-344-gf9b5518: OUTPUT«Bool::True␤»

[22:45] <Radvendii> oh, you had an extra '

[22:45] <TimToady> niecza: say 'a' ![![!eq]] 'a'

[22:45] <p6eval> niecza v13-344-gf9b5518: OUTPUT«Bool::False␤»

[22:45] <Radvendii> still, not as spectacular as !!!!!!!!eq

[22:46] <Radvendii> im kidding, of course

[22:46] <TimToady> we're not optimizing for spectacular, at least not in that dimension :0

[22:46] <TimToady> niecza: say 'a' !R!R!R!R!R!eq 'a'

[22:46] <p6eval> niecza v13-344-gf9b5518: OUTPUT«Bool::True␤»

[22:46] *** ksi left
[22:47] <Radvendii> niecza: say [<a b>],[<c d>] XX [1,2],[3,4]

[22:47] <p6eval> niecza v13-344-gf9b5518: OUTPUT«a b 1 2 a b 3 4 c d 1 2 c d 3 4␤»

[22:47] <Radvendii> double-cross still works

[22:47] <Radvendii> what's R though?

[22:47] <colomon> reverse

[22:47] <TimToady> reverse the arguments

[22:47] <TimToady> no-op on eq

[22:47] <colomon> !R!R!R!R!R!R should be called the pirate op

[22:48] <Radvendii> nom: say 5 R- 3

[22:48] <p6eval> nom b7cce8: OUTPUT«-2␤»

[22:48] <Radvendii> woah

[22:48] <Radvendii> cool

[22:48] <Radvendii> colomon: agreed

[22:49] <TimToady> see S03:3973 for all the meta operators

[22:49] *** Fried_ joined
[22:49] *** Fried_ left
[22:49] *** LlamaRider joined
[22:55] <Radvendii> can one use meta-ops with anonmyous functions? i can't think of a way to do it, because meta-ops don't allow whitespace...

[22:57] <Radvendii> o.O $a === $b should be $a = $a == $b. i guess it's not because that's not a very convenient operator to have...

[22:58] *** Chillance joined
[22:59] <Radvendii> nom: @foo = 1,2,3; @foo Z-= 1,2,3

[22:59] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Variable @foo is not predeclared at line 1, near " = 1,2,3; "␤»

[22:59] <Radvendii> nom: my @foo = 1,2,3; @foo Z-= 1,2,3

[22:59] <p6eval> nom b7cce8:  ( no output )

[22:59] <Radvendii> nom: my @foo = 1,2,3; say @foo Z-= 1,2,3

[22:59] <p6eval> nom b7cce8: OUTPUT«0 0 0␤»

[22:59] <flussence> nom: my $a = 1; my $b = 2; $a =[==] $b; say $a.perl

[22:59] <p6eval> nom b7cce8: OUTPUT«Bool::True␤»

[22:59] *** LlamaRider left
[22:59] <PerlJam> Radvendii: You don't like === as value identity?

[22:59] <flussence> that's... not quite right

[22:59] <Radvendii> PerlJam: no no, that's what i'm saying, it makes snese

[23:00] <Radvendii> sense*

[23:00] <flussence> nom: my $a = 1; my $b = 2; $a = [==] $a, $b; say $a.perl

[23:00] <p6eval> nom b7cce8: OUTPUT«Bool::False␤»

[23:00] <flussence> that is.

[23:00] <flussence> (and pretty awful to read)

[23:00] <Radvendii> yeah...

[23:01] <Radvendii> nom: my $a = 1; my $b = 2; $a [==] $a, $b; say $a.perl

[23:01] <p6eval> nom b7cce8: OUTPUT«1␤»

[23:01] <Radvendii> nom: my $a = 1; my $b = 2; $a [==]= $a, $b; say $a.perl

[23:01] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead at line 1, near " $a, $b; s"␤»

[23:01] <flussence> the [==] acts as a reduction op there

[23:01] <Radvendii> nom: my $a = 1; my $b = 2; $a [==]= $b; say $a.perl

[23:01] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead at line 1, near " $b; say $"␤»

[23:01] <Radvendii> reduction op?

[23:01] <Radvendii> oh

[23:01] <Radvendii> foldr

[23:01] <Radvendii> right

[23:01] <flussence> that one, yeah

[23:01] <TimToady> can't, that would be a ttiar

[23:02] <Radvendii> ttiar?

[23:02] <PerlJam> Radvendii: two terms in a row

[23:02] <TimToady> std: my $a = 1; my $b = 2; $a [==]= $a, $b; say $a.perl

[23:02] <p6eval> std b808250: OUTPUT«===SORRY!===␤Cannot make assignment out of == because chaining operators are diffy at /tmp/EvhBrn66B2 line 1:␤------> my $a = 1; my $b = 2; $a [==]=⏏ $a, $b; say $a.perl␤Check failed␤FAILED 00:01 112m␤»

[23:02] <Radvendii> but op= is a metha-op

[23:03] <Radvendii> so $a [==]= $b should be $a = $a == $b

[23:03] <TimToady> but that changes the type of $a

[23:03] <TimToady> so STD won't do it

[23:03] <Radvendii> o-oh

[23:03] <TimToady> it's slightly biased in favor of FP

[23:03] <Radvendii> FP?

[23:04] <TimToady> I don't know what nom thinks it's doing with it

[23:04] <flussence> nom: my ($a=1, $b=2); $a &[==]= $b; say $a

[23:04] <flussence> ominous silence...

[23:04] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix [==] instead at line 1, near "= $b; say "␤»

[23:04] <PerlJam> Radvendii: functional programming

[23:04] <Radvendii> ah

[23:04] <PerlJam> Radvendii: hang around long enough and you'll be speaking in tongues too

[23:04] <flussence> nom: my ($a=1, $b=2); $a &[==]= $b; say $a # wait, did that really just take 10 seconds to run?

[23:04] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix [==] instead at line 1, near "= $b; say "␤»

[23:04] <TimToady> flussence: that makes no sense

[23:05] <Radvendii> is that the same reason @a Z= @b does @a = @a Z @b rather than zipping with =?

[23:05] <dalek> nqp/bs: a9a934e | jnthn++ | src/6model/serialization.c:

[23:05] <dalek> nqp/bs: Further stubbing out of the deserialization algorithm, including allocating space for objects we're to deserialize.

[23:05] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/a9a934e310

[23:05] <dalek> nqp/bs: c5910a6 | jnthn++ | src/6model/serialization.c:

[23:05] <dalek> nqp/bs: First cut of resolving SC dependencies.

[23:05] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/c5910a6b43

[23:05] <dalek> nqp/bs: 25677b2 | jnthn++ | t/serialization/01-basic.t:

[23:05] <dalek> nqp/bs: Fix thinko in test.

[23:05] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/25677b2a8d

[23:05] <dalek> nqp/bs: 11488d7 | jnthn++ | src/6model/s (5 files):

[23:05] <dalek> nqp/bs: Fill out common bits of object deserialization, doing STable reassociation, memory allocation, and delegating off to the REPR for deserializing the object body.

[23:05] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/11488d7b8c

[23:05] <Radvendii> it's kind of confusing... i dont like that meta-ops can be prefix or suffix

[23:05] <TimToady> the meaning of the first bit takes precedence

[23:05] <Radvendii> why?

[23:05] <TimToady> you can always disambiguate

[23:05] <Radvendii> oh... i guess Z[=]

[23:06] <benabik> nom: my $a = 1; my $b = 2; $a ==== $b; say $a

[23:06] <TimToady> [Z]= vs Z[=]

[23:06] <p6eval> nom b7cce8: OUTPUT«Bool::False␤»

[23:06] <TimToady> STD won't take that one either

[23:06] <flussence> nom: my ($a=1, $b=2); $a &infix:<==>= $b; say $a

[23:06] <p6eval> nom b7cce8: OUTPUT«Method 'STORE' not found for invocant of class 'Any'␤  in method reify at src/gen/CORE.setting:4471␤  in method reify at src/gen/CORE.setting:4376␤  in method reify at src/gen/CORE.setting:4376␤  in method gimme at src/gen/CORE.setting:4740␤  in method eager at src/ge…

[23:06] <TimToady> std: my $a = 1; my $b = 2; $a ==== $b; say $a

[23:06] <p6eval> std b808250: OUTPUT«===SORRY!===␤Cannot make assignment out of === because chaining operators are diffy at /tmp/BTmOK_NnJx line 1:␤------> my $a = 1; my $b = 2; $a ====⏏ $b; say $a␤Check failed␤FAILED 00:01 111m␤»

[23:06] <flussence> whoa, what

[23:06] <Radvendii> :P

[23:06] <TimToady> flussence: you can't just stick a &foo in where an infix is expected

[23:07] <TimToady> & is a noun marker

[23:07] <flussence> .oO( I haven't failed, I've just found 10000 ways that don't work! )

[23:07] <TimToady> then you should have 10 light bulbs by now

[23:07] <PerlJam> flussence: coding by brownian motion rarely works mr. edison

[23:08] <Radvendii> you guys are silly

[23:09] <PerlJam> flussence: although there has been a proof for perl 5 that a random bit of text is more likely to be valid perl code than not.  I wonder if something similar is true for perl 6

[23:09] <TimToady> we already know that, so you're silly for pointing it out

[23:09] <TimToady> I sincerely doubt that proof

[23:10] *** slavik joined
[23:10] <Radvendii> nom: my( $a=1,$b=2,@a:=$a,$b ); @a Z[=] 4,5; say $a;

[23:10] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "=1,$b=2,@a"␤»

[23:10] <TimToady> it might possibly be true for 1 or 2 character programs, but that's about it

[23:11] <Radvendii> nom: my( @a=1,2 ); @a Z[=] 4,5; say @a;

[23:11] <p6eval> nom b7cce8: OUTPUT«===SORRY!===␤Variable @a is not predeclared at line 1, near "=1,2 ); @a"␤»

[23:11] <Radvendii> nom: my @a=1,2; @a Z[=] 4,5; say @a;

[23:11] <p6eval> nom b7cce8: OUTPUT«1 2␤»

[23:11] <Radvendii> nom: my ($a, $b, @a)=1,2,($a,$b); @a Z[=] 4,5; say @a;

[23:11] <TimToady> looks kinda like a bug to me

[23:11] <p6eval> nom b7cce8: OUTPUT«1 2␤»

[23:12] <Radvendii> TimToady: that my code doesnt do what we expect?

[23:12] <flussence> std: my (@a = 1,2);

[23:12] <PerlJam> TimToady: http://perl.plover.com/idiocy/RandProg.html  :-)

[23:12] <p6eval> std b808250: OUTPUT«===SORRY!===␤Cannot put required parameter after optional parameters at /tmp/zCaGHF33Ni line 1:␤------> my (@a = 1,2⏏);␤Check failed␤FAILED 00:01 112m␤»

[23:12] <Radvendii> nom: my ($a, $b)=1,2;my @a:= $a,$b; @a Z[=] 4,5; say $a;

[23:12] <p6eval> nom b7cce8: OUTPUT«1␤»

[23:12] <TimToady> no list assignments in parameter defaults

[23:13] <Radvendii> yeah, i figured

[23:13] <PerlJam> TimToady: but it clearly says something different than I did, so I misspoke

[23:13] <flussence> std: my ($a=1, $b=2); # just making sure I haven't gone insaner than usual

[23:13] <p6eval> std b808250: OUTPUT«ok 00:01 112m␤»

[23:13] <Radvendii> ǧis al čiuj!

[23:14] <Radvendii> see y'all

[23:14] <flussence> that std error is a bit incomprehensible to me

[23:14] *** Radvendii left
[23:14] *** tokuhirom joined
[23:15] <TimToady> it thinks @a = 1 is the first parameter, and 2 is the second parameter, because they have a comma between them, just like parameters are supposed to

[23:16] <TimToady> defaults in signatures cannot be parsed as lists

[23:16] <TimToady> (without parens)

[23:17] <TimToady> 2 is a perfectly value parameter, btw, though it makes little sense in a 'my'

[23:17] <TimToady> *valid

[23:19] <flussence> the () part after "my" behaves as a signature?

[23:20] <TimToady> it is parsed as a signature

[23:21] <flussence> oh, so it does. that's kinda neat.

[23:21] <flussence> (and makes much more sense to me now)

[23:21] *** colomon left
[23:30] <dalek> nqp/bs: f4aeff9 | jnthn++ | src/6model/serialization. (2 files):

[23:30] <dalek> nqp/bs: Implement readers for native int, num and str.

[23:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/f4aeff90cd

[23:30] <dalek> nqp/bs: 0c824b7 | jnthn++ | src/6model/reprs/P6int.c:

[23:30] <dalek> nqp/bs: Implement deserialize REPR function for P6int and...test cases pass! \o/ This means we can successfully serialize a (very simple) object with a cross-ref to an STable in another SC.

[23:30] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/0c824b7905

[23:30] *** colomon joined
[23:33] <jnthn> Tssk, wrist is sore...guess that means I wrote enough code for the day.

[23:34] <jnthn> &

[23:38] *** jfried is now known as jan

[23:39] *** jan is now known as jfried

[23:42] *** packetknife left
[23:55] *** mtk left
