[00:01] *** cognominal joined
[00:02] *** aBound joined
[00:03] *** aBound left
[00:07] *** lue joined
[00:09] *** erkan joined
[00:09] *** erkan left
[00:09] *** erkan joined
[00:11] *** cognominal left
[00:13] *** thou left
[00:21] *** cognominal joined
[00:27] *** thou joined
[00:30] *** bowtie left
[00:30] *** MayDaniel left
[01:07] *** cognominal left
[01:15] *** rindolf left
[01:16] *** marloshouse joined
[01:48] *** dayangkun left
[01:54] *** whiteknight left
[01:54] *** ifim left
[01:55] *** erkan left
[02:01] *** dayangkun joined
[02:12] *** fgomez left
[02:19] *** thou left
[02:37] *** popl joined
[02:40] *** fgomez joined
[02:50] *** PacoAir left
[02:56] *** FROGGS_ joined
[02:58] *** FROGGS left
[03:02] *** hash_table joined
[03:25] *** noggle joined
[03:29] *** noggle_ left
[03:30] *** hash_table left
[03:32] *** cognominal joined
[03:47] *** jaldhar joined
[03:50] *** Chillance left
[03:52] *** cognominal left
[04:09] *** stevan_ left
[04:11] *** stevan_ joined
[05:32] *** xinming left
[05:36] *** xinming joined
[06:21] *** araujo joined
[06:54] *** am0c joined
[06:57] *** SamuraiJack joined
[07:29] *** donghongbo joined
[07:32] *** popl left
[07:51] *** slayer101_ joined
[07:52] *** slayer101_ left
[08:01] <timotimo> the advent post turned out good. except "thats how Perl 6 spells Perl 5‚Ä≤s qr operator,<unnecessary linebreak>" and "Larry Wall also likes to joke that he back the ‚Äúregular‚Äù back" has one back too much

[08:03] *** GlitchMr joined
[08:12] *** SamuraiJack left
[08:16] *** kaare_ joined
[08:23] <diakopter> hi

[08:41] <diakopter> Thats needs apostrophe

[08:47] *** donghongbo left
[08:55] *** am0c left
[08:59] <GlitchMr> std: /(?:\d\w)+/

[08:59] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of (?: ... ) for grouping; in Perl 6 please use [ ... ] at /tmp/orxEAYSjF4 line 1:‚ê§------> [32m/(?:[33m‚èè[31m\d\w)+/[0m‚ê§Parse failed‚ê§FAILED 00:00 41m‚ê§¬ª

[09:00] <GlitchMr> std: /(?!(?=what)(?!....the)that)+/

[09:00] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of (?! ... ) for lookahead; in Perl 6 please use <!before ... > at /tmp/HkLsCRyBJm line 1:‚ê§------> [32m/(?![33m‚èè[31m(?=what)(?!....the)that)+/[0m‚ê§Parse failed‚ê§FAILED 00:00 41m‚ê§¬ª

[09:23] *** MayDaniel joined
[09:23] *** pmurias joined
[09:35] *** fgomez left
[09:36] <moritz> travel&

[09:41] *** Psyche^ joined
[09:42] *** Patterner left
[09:42] *** Psyche^ is now known as Patterner

[10:01] *** donghongbo joined
[10:10] *** donghongbo left
[10:34] *** donghongbo joined
[10:41] <tadzik> damn wordpress is horrible

[10:41] <tadzik> but still, loliblogged! http://ttjjss.wordpress.com/2012/12/22/threads-for-rakudo-perl-6/

[10:43] *** Kharec joined
[11:00] *** PacoAir joined
[11:00] *** gaussblurinc_ joined
[11:00] <pmurias> jnthn: ping

[11:02] *** PacoAir left
[11:02] *** Vlavv joined
[11:02] <pmurias> tadzik: don't green threads which block on IO have very little usefullness?

[11:03] <pmurias> * usefulness

[11:03] *** PacoAir joined
[11:03] <tomgj> Suppose I'm returning a Proxy object from a read write method.  What's the best way to access the outer object's private data from within the Proxy object's methods?

[11:03] <tadzik> pmurias: they do, yeah

[11:03] <tadzik> it is a bit imperfect, but it's the best we've got

[11:04] *** lichtkind joined
[11:05] <tomgj> ie do something like this but with a private variable instead of $.bar: 

[11:05] <tomgj> class Foo { has $.bar is rw; method my_bar($foo:) is rw { return Proxy.new: FETCH => method () { $foo.bar }, STORE => method ($new) {$foo.bar = $new}  } }

[11:05] <lichtkind> masak: great work reads lot smoother, hoever is still a &mash; in it

[11:06] <tadzik> tomgj: won't $!bar just work?>

[11:08] <tomgj> tadzik: do you mean like this:

[11:08] <tomgj> class Foo { has $!bar is rw; method my_bar($foo:) is rw { return Proxy.new: FETCH => method () { $!bar }, STORE => method ($new) {$!bar = $new}  } }

[11:08] <tadzik> yeah, doesn't that work?

[11:08] <tadzik> oh, hold on

[11:08] <tadzik> you don't need has $!bar is rw;

[11:09] <tomgj> I get "Method 'bar' not found for invocant of class 'Foo'" from rakudo 2012-11

[11:09] <tadzik> (I think)

[11:09] <tadzik> can you nopaste the whole code somewhere?

[11:13] *** am0c_ joined
[11:13] <tomgj> tadzik: http://nopaste.info/e989c26d09.html

[11:14] <tomgj> takzik: apologies, the error is actually "Cannot assign to a non-container ..."

[11:15] <tomgj> with rakudo-star-2012.11

[11:15] <tadzik> indeed, I see

[11:17] <tadzik> tomgj: http://nopaste.info/c887b0f688.html

[11:17] <tadzik> I feel that it may be more of a workaround than a solution, but seems to work :)

[11:17] <pmurias> what should the method to convert to a nqp number be called?

[11:17] <pmurias> and the ones to convert to a nqp integer and string?

[11:18] <tadzik> p6unbox_n or something

[11:18] <tadzik> if that's what you mean

[11:19] <tadzik> rakudo has nqp::unbox_n, nqp::unbox_i and so

[11:21] *** am0c_ left
[11:22] <tomgj> tadzik: thanks, interesting.  So what kind of thing would one say $ is in that?

[11:25] *** Pleiades` joined
[11:26] *** am0c_ joined
[11:29] <tomgj> hmm, I see that S12-attributes/mutators.t has an example that's very similar, but is disabled for rakudo

[11:39] <tadzik> tomgj: well, method is not much different from a sub, which first argument is the invocant

[11:39] <tadzik> I write '$' as "here be the invocant, whatever it is"

[11:40] <hoelzro> afternoon #perl6

[11:41] <pmurias> tadzik: I need a method to implement the conversion in nqp-js

[11:51] *** Pleiades` left
[11:54] <sorear> fun little logic puzzle for y'all to solve (in perl 6 or otherwise): https://gist.github.com/4358598

[11:54] <sorear> spoilers can be found easily by searching on the description

[11:55] <tomgj> okay, so the invocant of that proxy method is a Foo?

[11:56] <tomgj> as well as being a Proxy?

[11:56] <tomgj> btw this segfaults my rakudo: http://nopaste.info/232ed09242.html

[11:56] *** Pleiades` joined
[11:56] <tadzik> jnthn may be interesting in segfaults

[11:57] <tadzik> tomgj: I must say I'm not sure what's the invocant in that case

[11:57] <tadzik> synopses probably know

[11:57] <tomgj> err, my last paste should have been more like http://nopaste.info/0a7d389e98.html - still segfaults it

[12:13] <masak> hola, #perl6

[12:14] *** jokar joined
[12:16] <masak> diakopter: s/thats/that's/ fixed.

[12:16] <masak> timotimo: thanks for proofing.

[12:17] <masak> tadzik++ # http://ttjjss.wordpress.com/2012/12/22/threads-for-rakudo-perl-6/

[12:17] *** att__ joined
[12:18] *** gaussblurinc_ left
[12:19] <tadzik> hola masak :)

[12:20] <sorear> moin masak.

[12:20] <sorear> my last link was intended largely for you.

[12:20] <sorear> but now sleep&

[12:21] <jokar> Excuse me, A beginner user can use perl 6?

[12:22] <masak> jokar: yes, absolutely.

[12:22] <masak> it's easy:

[12:22] <masak> r: say "oh hai!"

[12:22] <p6eval> rakudo c8de2e: OUTPUT¬´oh hai!‚ê§¬ª

[12:22] <masak> a beginner user can do that :)

[12:23] <jokar> if it is not know any programming language,

[12:23] <tadzik> you have to start with some

[12:23] *** rindolf joined
[12:24] <jokar> You recommended Perl 5 or 6?

[12:25] <jokar> :-/

[12:25] <tadzik> both!

[12:25] <rindolf> jokar: what for?

[12:25] <jokar> for start

[12:25] <tadzik> Perl 6 is very insightful, but it may not be suitable for real-world applications

[12:26] <tadzik> for learning, Perl 6 is perfectly fine, probably saner than Perl 5 too

[12:26] <jokar> OK, Thank you

[12:27] <masak> jokar: if you start with Perl 5, you have to live with all the misfeatures that we've improved in Perl 6.

[12:27] <masak> jokar: but you'll get a more complete platform to code on.

[12:27] <masak> jokar: inversely with Perl 6: the language experience is nicer, but not all tools are there for you, and some assembly required.

[12:27] <jokar> misfeatures?

[12:27] <masak> jokar: yes, I can give you a few examples if you want.

[12:27] <jokar> yes

[12:28] <masak> sigil variance.

[12:28] <masak> thought to be a really cool idea when it was introduced.

[12:28] <jokar> masak: Can i send Pm?

[12:28] <masak> eval: my @a = (1, 2, 3); $a[1]

[12:28] <buubot_backup> masak: 2

[12:28] <masak> jokar: yes, but there are some advantages to doing the discussion here on #perl6.

[12:28] *** am0c_ left
[12:28] <masak> more people are able to respond to you.

[12:29] <masak> (and I'll have access to the evalbots) :)

[12:29] <masak> jokar: see that $a[1]?

[12:30] <masak> that's sigil variance. the @ changes to a $ because we access one scalar value from the array.

[12:30] <huf> it's arguable if that's a misfeature in p5

[12:30] <huf> still, i get why it was changed ni p6

[12:30] <masak> huf: it's very arguable, yes.

[12:30] <masak> huf: I've heard sigil variance being defended by staunch p5ers.

[12:30] <huf> i *like* it in p5. it makes sense.

[12:31] <masak> oh, I agree.

[12:31] <tomgj> talking of evalbots, what's the output here from the bot if rakudo segfaults?

[12:31] <masak> huf: do you agree that it's not geared towards, hm, pleasing beginners? :)

[12:31] <tomgj> is it okay if i try?

[12:31] <huf> but the very bottom of p6 is so vastly different from p5, it's no wonder it was changed

[12:31] <huf> masak: i dont see the point in pleasing beginners

[12:31] <huf> and every language/ecosystem has beginner-unfriendly warts

[12:32] <tomgj> r: class Foo { has $.bar is rw; method my_bar($foo:) is rw { return Proxy.new: FETCH => method () { print self.WHAT; return $foo.bar; }, STORE => method ($new) { print self.WHAT; $foo.bar = $new; } } } my $foo = Foo.new; $foo.my_bar = 7;

[12:32] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/jMFEQoEoDI:1‚ê§------> [32mprint self.WHAT; $foo.bar = $new; } } } [33m‚èè[31mmy $foo = Foo.new; $foo.my_bar = 7;[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§  ‚Ä¶

[12:32] <masak> huf: you didn't answer my question.

[12:32] <masak> we can talk about the point of pleasing beginners separately ;)

[12:32] <huf> masak: well, i dont know. i see people struggling with it on #perl, but fwiw, i never got stuck at that point

[12:33] <masak> I think it's one of those "easy if you know it" things.

[12:33] <huf> they strugle _far_ more with explicit references, and i think those are brilliant too

[12:33] <huf> same for the autoflatten behavior

[12:33] <masak> it's definitely something that goes into a Perl course.

[12:33] <huf> so yeah, it's different, but i dont think it's complicated or a misfeature :)

[12:33] <huf> but i know the reasons why people dont like it 

[12:35] <masak> Perl 6 has autoflattening too, although a bit less of it in places.

[12:35] <masak> and the autoflattening happens a bit more lazily.

[12:36] <masak> Perl 6 gets rid of the explicit references, and goes all-out implicit references.

[12:36] *** ServerSage left
[12:36] <huf> what does the sigil do in p6? constrain the types a variable can hold?

[12:36] <masak> aye.

[12:36] <huf> and maybe affect how it interpolates in specific contexts?

[12:36] <huf> a list of 1, @a flattens, a list of 1, $a doesnt (where both @a and $a are an array of things)

[12:36] <huf> or am i misremembering?

[12:37] <masak> what Perl 5 succeeds with brilliantly is to make the language core feel "small". (amazingly) you could define a core of Perl 5 consisting of scalars, arrays, and hashes, and that'd describe most of it.

[12:37] <masak> huf: sounds about right.

[12:37] <masak> huf: the $ sigil signals "I'm an item, don't autoflatten me".

[12:37] <huf> cause yeah, in this world, the sigil-variance of p5 would make no sense :)

[12:37] <masak> right.

[12:38] <huf> masak: implicit refs as in everything is a ref everywhere?

[12:38] <huf> and apart from =, and sub params declared is copy, no magic copying?

[12:40] <masak> huf: yes, that kind of implicit refs.

[12:40] <masak> huf: not 100% about the magic copying, but I think so.

[12:40] <huf> hm. so if i'm mangling complicated self-referential datastructures, i just switch to := instead of =

[12:40] <huf> and it just works? :)

[12:41] <huf> iirc = tries hard to pretend you're still in perl5

[12:41] <huf> ... as far as copying goes

[12:42] <pmurias> masak: re core language doesn't Perl 6 also have the small core property?

[12:42] <masak> I think = will work as well as := for complicated self-referential datastructures.

[12:42] <masak> since most things are references.

[12:43] <huf> so how do you get copies?

[12:43] <masak> pmurias: quite possibly, but I personally don't see it as clearly, as core aspects such as lists keep changing around.

[12:43] <masak> pmurias: so, ask me again in 10 years or so ;)

[12:43] <masak> huf: oh, I think I see what you mean.

[12:43] <masak> r: my @a = 1, 2, 3; my @b = @a; say @a === @b

[12:43] <p6eval> rakudo c8de2e: OUTPUT¬´False‚ê§¬ª

[12:43] <masak> huf: yeah, that's a copy.

[12:43] <huf> $x = 1; $y = $x; $y++; # i'd expect $x to still be 1 :)

[12:43] <masak> right.

[12:44] <masak> r: $x = 1; $y = $x; $y++; say $x

[12:44] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $x is not declared‚ê§at /tmp/nOy2L4Nce2:1‚ê§------> [32m$x[33m‚èè[31m = 1; $y = $x; $y++; say $x[0m‚ê§    expecting any of:‚ê§        postfix‚ê§¬ª

[12:44] <masak> ehm :)

[12:44] <masak> r: my $x = 1; my $y = $x; $y++; say $x

[12:44] <p6eval> rakudo c8de2e: OUTPUT¬´1‚ê§¬ª

[12:44] <huf> r: my $x = 1; my $y := $x; $y++; say $x

[12:44] <p6eval> rakudo c8de2e: OUTPUT¬´2‚ê§¬ª

[12:44] <huf> well. nice.

[12:44] <huf> thanks for allowing me this braindrain :)

[12:45] <huf> i have a very hazy understanding of p6 concepts and then every now and then i pester someone to explain 

[12:47] <masak> it's always fun to have discussions with well-versed p5ers.

[12:47] <masak> and important, I would say.

[12:48] <masak> we need advocates in both camps, to combat all the FUD.

[12:48] *** FROGGS_ left
[12:48] <huf> oh yes.

[12:50] *** am0c_ joined
[12:59] <masak> sorear: what a delightful little problem. https://gist.github.com/4358598

[13:00] <masak> sorear: and the search space is small enough for a brute-force approach :)

[13:00] <masak> I might attempt that.

[13:00] <masak> the interesting part is still modeling the problem, even with a brute-force approach.

[13:02] *** GlitchMr left
[13:02] <masak> rn: say "how many pairs (X, Y) of integers exist such that X & Y > 1 and X + Y < 100?"

[13:02] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´how many pairs (X, Y) of integers exist such that X & Y > 1 and X + Y < 100?‚ê§¬ª

[13:03] <masak> rn: my $c = 0; for 2..100 -> $X { for 2..100 -> $Y { if $X + $Y < 100 { $c++ } } }; say $c

[13:03] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´4656‚ê§¬ª

[13:03] <masak> rn: say +(2..100 X 2..100).grep({ $^X + $^Y < 100 })

[13:03] <p6eval> rakudo c8de2e: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in block  at /tmp/S6jDrfgXYE:1‚ê§‚ê§¬ª

[13:03] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´Unhandled exception: No value for parameter '$Y' in 'ANON'‚ê§  at /tmp/EWghYwbodg line 0 (ANON @ 1) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1058 (Block.ACCEPTS @ 4) ‚ê§  at <unknown> line 0 (KERNEL grep @ 2) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting l‚Ä¶

[13:04] <masak> aw, that still doesn't work? :(

[13:05] <masak> rn: say +(2..100).map(-> $X { [(2..100).map(-> $Y {[$X, $Y]})] )

[13:05] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse block at /tmp/OX4XDxs9E9 line 1:‚ê§------> [32msay +(2..100).map(-> $X {[33m‚èè[31m [(2..100).map(-> $Y {[$X, $Y]})] )[0m‚ê§Couldn't find final '}'; gave up at /tmp/OX4XDxs9E9 line 1:‚ê§------> [32m> $X { [(2..1‚Ä¶

[13:05] <p6eval> ..rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse expression in block; couldn't find final '}'‚ê§at /tmp/km1uFdFuyU:1‚ê§------> [32m> $X { [(2..100).map(-> $Y {[$X, $Y]})] [33m‚èè[31m)[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix st‚Ä¶

[13:07] <felher> sorear++ #posting a logic puzzle that was fun to solve :)

[13:07] <masak> rn: say +(2..100).map(-> $X { (2..100).map(-> $Y { [$X, $Y] if $X + $Y < 100 }) })

[13:08] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´99‚ê§¬ª

[13:08] <p6eval> ..rakudo c8de2e: OUTPUT¬´4656‚ê§¬ª

[13:08] <masak> felher: oh, you already solved it? :)

[13:08] <masak> sorear: surely something wrong there.

[13:08] <masak> (with niecza's output just now)

[13:08] *** renormalist joined
[13:08] <felher> masak: yes, I did :)

[13:09] <masak> dang, I'm behind the curve :P

[13:09] <masak> time to start coding it, then.

[13:11] <dalek> rakudo-js: b16d865 | (Pawe≈Ç Murias)++ | TODO:

[13:11] <dalek> rakudo-js: start of TODO

[13:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/b16d8650a2

[13:11] <dalek> rakudo-js: 780cb6c | (Pawe≈Ç Murias)++ | TODO:

[13:11] <dalek> rakudo-js: [nqp] add stuff to TODO

[13:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/780cb6cc20

[13:11] <dalek> rakudo-js: 4ea22c5 | (Pawe≈Ç Murias)++ | / (3 files):

[13:11] <dalek> rakudo-js: [nqp] keep lexicals in the ctx object so we can access from called subs,pass test 29, implement !make

[13:11] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/4ea22c52df

[13:11] * felher has another problem to solve right now...

[13:11] <felher> 0 139 root@win6071d [ /home/felher ] #> mount

[13:11] <felher> zsh: segmentation fault  mount

[13:12] <masak> felher: "I was sure that you could not find them" corresponds to the product X*Y not having unique factors, right?

[13:12] <felher> Mount should not get me a segmentation fault...

[13:12] <masak> oh, and I think moritz will like this puzzle as well.

[13:12] <masak> he's been known to post "knowledge-based" math problems before.

[13:13] <masak> heh, this kind of problem would be completely impossible to solve for someone without a Theory of Mind... :P

[13:13] <felher> masak: Correct :) "i was sure..." means "the sum I know can not be expressed as the sum of two primes"

[13:14] <masak> oh, right. S is saying that.

[13:15] <masak> I'll post my solution here as a gist when I've solved the problem.

[13:19] <felher> oO... mount - segmentation fault. dmesg - input/output error, cat /var/log/messages - input/output error.

[13:19] <tadzik> oh noes

[13:19] * felher reboots and hopes he comes back on again...

[13:21] <masak> rn: say +(2..100).map(-> $X { ($X..100).map(-> $Y { [$X, $Y] if $X + $Y < 100 }) })

[13:21] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´99‚ê§¬ª

[13:21] <p6eval> ..rakudo c8de2e: OUTPUT¬´2352‚ê§¬ª

[13:22] <masak> I briefly forgot about symmetry breaking ;)

[13:22] *** Chillance joined
[13:28] * felher is eager to see masaks gist :)

[13:31] <masak> rn: my @primes = (1..100).grep(*.is-prime); sub isn't_sum_of_2_primes($n) { return !@primes.first( { is-prime $n - $_ } ) }; say (2..100).grep(&isn't_sum_of_2_primes)

[13:31] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´2 3 11 17 23 27 29 35 37 41 47 51 53 57 59 65 67 71 77 79 83 87 89 93 95 97‚ê§¬ª

[13:31] <masak> well, this simplifies matters further :)

[13:38] *** lichtkind left
[13:41] *** isBEKaml joined
[13:43] <isBEKaml> p6advent post looks good. We need an apostrophe in "Thats still kinda clunky" 

[13:44] <isBEKaml> "If we‚Äôre interested in the individual integers" -- one too many "the", maybe that's just me. :)

[13:46] <isBEKaml> "inside of the bigger Perl 6 language" -- doesn't sound too good. How about "within" ?

[13:46] <isBEKaml> </end>

[13:50] *** bowtie joined
[13:53] *** donghongbo left
[14:01] <masak> isBEKaml: good points. fixing.

[14:02] <isBEKaml> masak++ #blog post, proofing, rewording. 

[14:03] <masak> updated.

[14:03] *** donghongbo joined
[14:08] <colomon> rn: my @primes = (1..100).grep(*.is-prime); my $prime-sums = set @primes X+ @primes; say (2..100).grep(* !(elem) $prime-sums);

[14:08] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´2 3 11 17 23 27 29 35 37 41 47 51 53 57 59 65 67 71 77 79 83 87 89 93 95 97‚ê§¬ª

[14:09] <colomon> can you import MAIN from a module?

[14:11] * colomon is trying to figure out how to re-engineer the Collatz benchmarking framework to more precisely measure the time the actual calculations take -- right now overhead is swamping the timings of the faster routines.

[14:12] *** dayangkun left
[14:12] *** rindolf left
[14:14] * colomon is now dreaming about lazy infinite Sets...

[14:16] <masak> how do you ensure that a membership query on a lazy infinite set terminates?

[14:18] *** Kharec left
[14:19] <colomon> masak: I was specifically thinking sets of numbers, and they'd have to be ordered to work.

[14:19] <colomon> well, I guess anything that was ordered could work.

[14:21] <donghongbo> join coffeescript

[14:21] <masak> donghongbo: :)

[14:21] <donghongbo> sorry

[14:21] <isBEKaml> donghongbo: phel :)

[14:22] <masak> donghongbo: what brings you to #coffeescript?

[14:22] * masak still hasn't decided if CoffeeScript is a good idea or not

[14:23] <donghongbo> i just think it's simple, and type less

[14:25] <masak> right.

[14:25] <masak> but suddenly you're working one step away from the actual substrate of programming.

[14:25] <masak> error messages happen in code you didn't directly write.

[14:26] <masak> your mental model has to accommodate for both JavaScript and CoffeeScript.

[14:47] * felher is afk for some hours.

[14:48] <felher> masak: I would appreciate it, if you highlight me, when posting your gist. So I find it quickly when I return :)

[14:49] *** GlitchMr joined
[14:53] *** GlitchMr left
[14:53] *** GlitchMr joined
[14:54] <timotimo> colomon: maybe have a probabilistic membership query instead?

[14:54] *** am0c_ left
[14:55] <masak> felher: will do. :)

[14:55] <masak> working on the solution now.

[14:56] <timotimo> like is-prime, there may be a formula that approximates the probability of an error

[14:57] <dalek> nqp: 3370a7d | (Pawe≈Ç Murias)++ | t/nqp/21-contextual.t:

[14:57] <dalek> nqp: Test that contextuals are not implemented as globals.

[14:57] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3370a7d103

[15:06] *** rindolf joined
[15:07] *** am0c joined
[15:07] <pmurias> masak: of course coffescript is a bad idea, that's why I'm working on nqp-js ;) (and once that's done on rakudo-js)

[15:07] <timotimo> so do you think nqp-js can be used semi-properly for website scripting? or would you feed it to node.js instead?

[15:09] *** donghongbo left
[15:11] <pmurias> timotimo: I don't really on anything really node specific ATM, it could be easily tweaked for website scripting

[15:11] <timotimo> that amuses me :)

[15:20] *** lolage joined
[15:27] *** bot48 left
[15:29] *** sw joined
[15:29] *** bot48 joined
[15:29] *** sw left
[15:31] *** isBEKaml left
[15:32] <timotimo> r: my &fullwidth := *.trans("a".."z" => chrs(0xFF41..0xFF5A), "A".."Z" => chrs(0xFF21..0xFF3A)); say fullwidth("Hello all you happy perl6 people")

[15:32] <p6eval> rakudo c8de2e: OUTPUT¬´Ôº®ÔΩÖÔΩåÔΩåÔΩè ÔΩÅÔΩåÔΩå ÔΩôÔΩèÔΩï ÔΩàÔΩÅÔΩêÔΩêÔΩô ÔΩêÔΩÖÔΩíÔΩå6 ÔΩêÔΩÖÔΩèÔΩêÔΩåÔΩÖ‚ê§¬ª

[15:34] *** lorn joined
[15:34] <timotimo> r: my &fullwidth := *.trans("a".."z" => chrs(0xFF41..0xFF5A), "A".."Z" => chrs(0xFF21..0xFF3A)); say fullwidth("azAZ")

[15:34] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩÅÔΩöÔº°Ôº∫‚ê§¬ª

[15:35] <GlitchMr> my &fullwidth := *.trans(chrs(0x20..0x7F) => chrs(0xFF41..0xFF5A)); say fullwidth("Hello all you happy perl6 people")

[15:35] <timotimo> r: my &fullwidth := *.trans("a".."z" => "ÔΩÅ".."ÔΩö", "A".."Z" => "Ôº°".."Ôº∫"); say fullwidth("Hello all you beautiful and silly unicode characters")

[15:35] <GlitchMr> r: my &fullwidth := *.trans(chrs(0x20..0x7F) => chrs(0xFF41..0xFF5A)); say fullwidth("Hello all you happy perl6 people")

[15:35] <p6eval> rakudo c8de2e: OUTPUT¬´(timeout)¬ª

[15:35] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩèÔΩíÔΩôÔΩôÔΩÇÔΩÅÔΩéÔΩôÔΩôÔΩÅÔΩåÔΩÇÔΩàÔΩÅÔΩïÔΩéÔΩÉÔΩÉÔΩåÔΩÅÔΩÉÔΩíÔΩÖÔΩôÔΩóÔΩÅÔΩÉÔΩíÔΩÇÔΩÉÔΩôÔΩí‚ê§¬ª

[15:35] <GlitchMr> oh, rite

[15:36] * rindolf kicks Dist-Zilla's documentation.

[15:36] <GlitchMr> r: my &fullwidth := *.trans(chrs(0x20..0x7F) => chrs(0xFF20..0xFF7F)); say fullwidth("Hello all you happy perl6 people")

[15:36] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩàÔΩ•ÔΩ¨ÔΩ¨ÔΩØÔº†ÔΩ°ÔΩ¨ÔΩ¨Ôº†ÔΩπÔΩØÔΩµÔº†ÔΩ®ÔΩ°ÔΩ∞ÔΩ∞ÔΩπÔº†ÔΩ∞ÔΩ•ÔΩ≤ÔΩ¨Ôº∂Ôº†ÔΩ∞ÔΩ•ÔΩØÔΩ∞ÔΩ¨ÔΩ•‚ê§¬ª

[15:36] <rindolf> It needs a FAQ fast!

[15:36] <timotimo> what caused the timeout? :\

[15:36] <GlitchMr> oh, right, it doesn't map to ASCII

[15:36] <timotimo> r: +("ÔΩÅ".."ÔΩö")

[15:36] <timotimo> r: say +("ÔΩÅ".."ÔΩö")

[15:36] <GlitchMr> Or they do

[15:37] <p6eval> rakudo c8de2e: OUTPUT¬´(timeout)¬ª

[15:37] <p6eval> rakudo c8de2e: OUTPUT¬´(timeout)¬ª

[15:37] <timotimo> this surprises me.

[15:37] <GlitchMr> r: my &fullwidth := *.trans(chrs(0x20..0x7E) => chrs(0xFF00..0xFF5E)); say fullwidth("Hello all you happy perl6 people")

[15:37] <p6eval> rakudo c8de2e: OUTPUT¬´Ôº©ÔΩÜÔΩçÔΩçÔΩêÔºÅÔΩÇÔΩçÔΩçÔºÅÔΩöÔΩêÔΩñÔºÅÔΩâÔΩÇÔΩëÔΩëÔΩöÔºÅÔΩëÔΩÜÔΩìÔΩçÔºóÔºÅÔΩëÔΩÜÔΩêÔΩëÔΩçÔΩÜ‚ê§¬ª

[15:37] <timotimo> r: say "ÔΩÅ".succ

[15:37] <GlitchMr> Close enough

[15:37] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩÅ‚ê§¬ª

[15:37] <timotimo> huh?

[15:37] <timotimo> r: say chr("ÔΩÅ".ord.succ)

[15:37] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩÇ‚ê§¬ª

[15:37] <timotimo> is this a rakudobug?

[15:38] <timotimo> r: say "a".succ

[15:38] <p6eval> rakudo c8de2e: OUTPUT¬´b‚ê§¬ª

[15:38] <timotimo> perhaps it only works for "a".."z"? as a special case?

[15:38] <GlitchMr> r: my &fullwidth := *.trans(chrs(0x21..0x7E) => chrs(0xFF01..0xFF5E)); say fullwidth("Hello all you happy perl6 people")

[15:38] <p6eval> rakudo c8de2e: OUTPUT¬´Ôº®ÔΩÖÔΩåÔΩåÔΩè ÔΩÅÔΩåÔΩå ÔΩôÔΩèÔΩï ÔΩàÔΩÅÔΩêÔΩêÔΩô ÔΩêÔΩÖÔΩíÔΩåÔºñ ÔΩêÔΩÖÔΩèÔΩêÔΩåÔΩÖ‚ê§¬ª

[15:38] <tadzik> whoa

[15:38] <tadzik> Text::Fatspeak

[15:38] <GlitchMr> r: my &fullwidth := *.trans(chrs(0x21..0x7E) => chrs(0xFF01..0xFF5E)); say fullwidth("int main() { return 0; }")

[15:38] <p6eval> rakudo c8de2e:  ( no output )

[15:39] <GlitchMr> right

[15:39] <GlitchMr> r: my &fullwidth := *.trans(chrs(0x21..0x7E) => chrs(0xFF01..0xFF5E)); say fullwidth('int main() { return 0; }')

[15:39] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩâÔΩéÔΩî ÔΩçÔΩÅÔΩâÔΩéÔºàÔºâ ÔΩõ ÔΩíÔΩÖÔΩîÔΩïÔΩíÔΩé ÔºêÔºõ ÔΩù‚ê§¬ª

[15:39] <GlitchMr> perl6: sub full-width { .trans: chrs(0x21..0x7E) => chrs(0xFF01..0xFF5E) } ; say full-width('int main() { return 0; }')

[15:39] <p6eval> rakudo c8de2e: OUTPUT¬´===SORRY!===‚ê§CHECK FAILED:‚ê§Calling 'full-width' will never work with argument types (str) (lines 1, 1)‚ê§    Expected: :()‚ê§¬ª

[15:39] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´ÔΩâÔΩéÔΩî ÔΩçÔΩÅÔΩâÔΩéÔºàÔºâ ÔΩõ ÔΩíÔΩÖÔΩîÔΩïÔΩíÔΩé ÔºêÔºõ ÔΩù‚ê§¬ª

[15:40] <tadzik> I find it entertaining that the "" one didn't work

[15:40] <timotimo> tadzik: if you want to, that'd be a nice exercise for me

[15:40] <tadzik> timotimo: I want to what?

[15:40] <GlitchMr> perl6: sub full-width (Cool $_) { .trans: chrs(0x21..0x7E) => chrs(0xFF01..0xFF5E) } ; say full-width('int main() { return 0; }')

[15:40] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´ÔΩâÔΩéÔΩî ÔΩçÔΩÅÔΩâÔΩéÔºàÔºâ ÔΩõ ÔΩíÔΩÖÔΩîÔΩïÔΩíÔΩé ÔºêÔºõ ÔΩù‚ê§¬ª

[15:40] <tadzik> timotimo: you want to roll out a module?

[15:40] <timotimo> er, if you want to have Text::Fatspeak

[15:40] <tadzik> yeah, go for it :)

[15:41] <tadzik> consider Acme:: for it :)

[15:41] <timotimo> surely will

[15:41] <tadzik> or maybe not :)

[15:41] <timotimo> hey, maybe i'll keep that idea around until i'm back at home with my fat desktop and i'll turn it into an educational screencast

[15:41] <GlitchMr> This would be serious module.

[15:41] <GlitchMr> Some people like fullwidth letters.

[15:41] <tadzik> that'd be awesome

[15:42] <GlitchMr> Just make sure it supports every ASCII character.

[15:42] <timotimo> in fact, i could use one of my parent's computers while i'm here. i even brought a cheap microphone :]

[15:42] <pmurias> timotimo: amuses you?

[15:43] <timotimo> the possibility of writing javascript things in nqp

[15:43] <GlitchMr> Fullwidth letters are useful.

[15:43] <GlitchMr> Especially when mixing them in CJK text.

[15:43] <GlitchMr> https://upload.wikimedia.org/wikipedia/commons/1/14/KoreanDOSPrompt.png

[15:44] *** hash_table joined
[15:44] <timotimo> i could offer this as an online service on heroku for people who can't get to the required amount of pages in their thesis or something

[15:44] <timotimo> there once was a post on how to host perl6 services on heroku, but it got lost somehow

[15:48] <timotimo> oh, GlitchMr, it does map ascii to unicode 1:1? that's neat :)

[15:48] <GlitchMr> Yes

[15:48] <GlitchMr> Range 0x21 .. 0x7E is mapped to 0xFF01 .. 0xFF5E.

[15:48] <GlitchMr> But it sadly doesn't have fullwidth space.

[15:48] <GlitchMr> You could try putting two spaces instead or something.

[15:50] <GlitchMr> And yes, 'a' .. 'z' is special case. Otherwise, code like this wouldn't work properly:

[15:50] <GlitchMr> rn: ('a0' .. 'b9').perl.say;

[15:50] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´"a0".."b9"‚ê§¬ª

[15:50] <GlitchMr> ...

[15:50] <GlitchMr> rn: @('a0' .. 'b9').perl.say;

[15:50] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´("a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9").list‚ê§¬ª

[15:50] <pmurias> timotimo: what does the amount of pages have to do with compiling Perl 6 to JavaScript? 

[15:51] *** rurban1 joined
[15:53] <pmurias> timotimo: making things extra complex on purpose?

[15:53] <timotimo> pmurias: er, pardon?

[15:53] *** am0c left
[15:53] <pmurias> timotimo: sorry got confused

[15:54] <timotimo> perl6 goes in, javascript comes out. never a miscommunication.

[15:54] <timotimo> you can't explain that!

[15:55] <pmurias> I wouldn't be so sure about the lack of miscommunication ;)

[16:04] <masak> felher, sorear: here's my solution: https://gist.github.com/4359618

[16:05] <masak> (it ended up being a port of the Python solution on the Wikipedia article. but the Python solution contained a lot of Pythonesque repetition that I removed, and I renamed all the variables.)

[16:13] <timotimo> rename all the variables: prof won't find it on google: full score

[16:16] <masak> nah, I just had better names ;)

[16:28] <timotimo> allowing - in names is really something nice, methinks

[16:30] <moritz> \o

[16:31] <moritz> seems I've missed a lot of backlog

[16:31] <timotimo> i'm still missing a whole lot of frontlog :(

[16:32] <timotimo> scrolling through the frontlog is crazy slow :[

[16:35] <masak> moritz! \o/

[16:35] <masak> timotimo: the frontlog is realtime, with no expected improvements.

[16:38] <timotimo> i sometimes perceive certain jumps in the speed in which frontlogs populate. they seem to do multiple hours almost in an instant. happens approximately daily. do you know if that technology could be harnessed to unlock whole chapters of the frontlog in advance?

[16:38] *** isBEKaml joined
[16:40] <masak> surely there must be a much shorter solution than mine, by the way.

[16:41] <masak> I'm populating hashes with cumbersome for loops and if statements. there's probably a few-liner that uses sets and closures in a straightforward way.

[16:41] * masak attempts to write one

[16:45] <moritz> what's this puzzle you're talking about?

[16:46] <GlitchMr> t1?

[16:46] <masak> moritz: sorear posted it in the backlog.

[16:47] <masak> https://gist.github.com/4358598

[16:47] <masak> hm, using sets and bags works, but seems to be affecting readability a bit more than I'd like.

[16:47] <masak> I bet a Haskell solution would look pretty, though.

[16:49] <moritz> ... and a normal human programmer takes three days to understand a pretty Haskell solution :-)

[16:50] <masak> the problem is nice, because it's all about pairs of numbers, predicates/sets of these pairs, and four distinct mental states about these sets.

[16:50] <masak> moritz: half of me wants to agree with you, half of me wants to disagree :)

[16:50] * masak goes ahead and writes the Haskell solution

[16:51] *** skids left
[16:53] *** raiph joined
[16:54] <timotimo> with perl6s lazyness and multi-dispatch with pattern matching, how close does one get to haskell?

[16:54] <moritz> well, the typ-y stuff is still missing :-)

[16:58] <mst> moritz: but that's ok, since we're not normal programmers

[16:58] <mst> in any case, "takes 3 days to understand" is the sort of valueless comment people make about perl a lot

[16:58] <moritz> I know, I know

[16:59] <mst> I will admit, however, that a pretty haskell solution would probably take a while for -me- to understand

[16:59] <mst> but presumably that just means I'm the wrong sort of not normal :D

[16:59] <moritz> or the normal sort of not normal :-)

[17:03] <masak> I remember being in #haskell and someone told me "no, you can write it like this", and their solution was this beautiful pretzel of logic that I could understand momentarily if I made my brain a pretzel, too. but each time I relaxed it looked incomprehensible.

[17:03] <masak> could be it's just a matter of habit. there are many things I understand perfectly fine now that I didn't five years ago.

[17:05] <isBEKaml> yeah, I sort of wondered what makes people say things like that can just be made clear with just a little more effort. 

[17:06] <isBEKaml> for example, if I come across something I don't understand, I just usally try to break it down. Of course, that means you know your way around debugging these things. I cannot say this about haskell, mainly because I'm relatively new at it. :)

[17:08] * isBEKaml feels too much justified. Wrong end of the road.. :/

[17:08] <isBEKaml> "just"ified. 

[17:09] <moritz> btw: new HPMoR chapter!

[17:11] *** pigi joined
[17:11] <pigi> ciao

[17:12] <pigi> !lista

[17:12] <masak> ciao, pigi.

[17:12] <masak> moritz: ooh!

[17:13] <masak> I've been so busy this week that I've only had time to re-read Ch. 85.

[17:13] <masak> so now I have two new chapters to read :D

[17:15] <pigi> ciao

[17:15] <pigi> !lista

[17:15] *** pigi left
[17:15] * moritz has read stuff up, and now has a pretty good idea how to attack t1

[17:15] <masak> \o/

[17:16] <moritz> actually I'm of two minds about this stuff

[17:16] * masak has no idea what went through the mind of pigi during those four minutes

[17:16] <moritz> on the one hand I see that you don't want to drop too many hints

[17:16] <masak> right.

[17:17] *** PacoAir left
[17:17] <moritz> on the other hand I find it kinda unfair to those not knowing a specific bit of theory to not even know what to read up, and thus having a sever disadvantage in the contest

[17:18] <masak> well, the sharpest example of that happened in the 2010 edition of p6cc.

[17:18] <moritz> you mean the nim sums?

[17:18] <masak> with the two-player game that turned out to have a simple analyzable solution.

[17:18] <masak> yes, the num sums.

[17:18] <moritz> or whatever they were called

[17:19] <arnsholt> Kayles!

[17:19] * moritz still hasn't finished more than the first two or three chapters of the book on mathematical games he promised himself to read

[17:19] <masak> the theory is called the Sprague-Grundy theorem. https://en.wikipedia.org/wiki/Sprague%E2%80%93Grundy_theorem

[17:19] <masak> heh, yes, arnsholt was the *only* person who solved that problem using the theory.

[17:20] <masak> ...which delighted me, since it showed that knowing the theory helped, and that not everyone would make the connection.

[17:21] <masak> moritz: in essence, I guess it is "kinda unfair". all I can say is if you're a programmer, there's not much standing in your way of spending a fraction of those five weeks trying to find relevant theory.

[17:21] <masak> "ability to Google", as Tim Minchin beat-poems.

[17:22] <tadzik> hehehe

[17:22] <arnsholt> That's pretty much how I got there

[17:22] <masak> I rest my case.

[17:22] <arnsholt> The problem statement just felt like perfect play should be possible

[17:23] <arnsholt> I think I found it by way of the game whose name I can't remember, with the depressions with little tokens in them

[17:23] <masak> indeed, there is a bootstrapping paradox in there somewhere. you can't know you don't know some thing when you don't know it, etc.

[17:23] *** GlitchMr left
[17:23] <arnsholt> Which I happened to know was perfectly playable

[17:23] <masak> but part of the thing I want to score people on is the ability to find their bearings in unknown problem situations.

[17:24] <moritz> on the first hand again, when you try to solve a real-world programming problem, the problem doesn't come with a theory name either

[17:24] <masak> arnsholt: that game has many names. https://en.wikipedia.org/wiki/Mancala

[17:25] <masak> moritz: one of my heroes, Eric Evans, has a knack for finding a kernel of theory to exploit in real-world problems.

[17:26] <hoelzro> hi #perl6 folk

[17:26] <masak> hoelzro! \o/

[17:26] <arnsholt> masak: Yeah, that's the one

[17:27] <arnsholt> Reading about the theory of that game's perfect play led me to making and breaking and the fun theories

[17:27] <masak> moritz: you've been co-organizing once, so you know my thought process when it comes to selecting the puzzles. they should look simple, but preferably have unexpected depth and subtlety.

[17:27] <arnsholt> Octal notation for example =D

[17:27] <masak> arnsholt: if you haven't read the "Winning Ways" books yet, you totally should.

[17:28] <moritz> masak: for some time I thought that t1 had more depth than I wanted to tackle :-)

[17:28] <arnsholt> Yeah, they turned up in my research, but no copies conveniently available at the time IIRC

[17:31] <hoelzro> so I'm reading the specs on Unicode bracketing characters for Perl 6...am I correct in thinking that bracketing characters are any defined in the BidiMirroring document, or with Ps/Pe/Pi/Pf properties, with the latter definition taking precedence?

[17:37] *** rummik left
[17:37] *** rummik joined
[17:39] <arnsholt> Hmm. t5 smells faintly of knapsacks

[17:42] *** isBEKaml left
[17:42] <hoelzro> ok, well, you guys think about it =) I'll be back later!

[17:46] <moritz> arnsholt: faintly :-)

[17:51] * masak gets stuck because he doesn't manage to print a list of results in Haskell

[17:51] <masak> :/

[17:51] <masak> something about do notation and monads, I guess.

[17:52] * masak tries #haskell

[17:52] <moritz> masak: did I read the p6cc announcement correctly, that there's no separate sign-up deadline this year?

[17:53] <masak> moritz: "Registration is open for two weeks, starting *now*." from http://strangelyconsistent.org/blog/the-2012-perl-6-coding-contest

[17:53] <moritz> ok, I didn't read correctly

[17:54] * moritz brings the p6cc news to perlmonks

[18:00] <tomgj> So I've read http://markmail.org/message/rzvfkbsxlkp4ewex

[18:00] <masak> excellent. :)

[18:00] <tomgj> heh.  My app has a doubly linked data structure where the nodes are of varying types.

[18:01] *** isBEKaml joined
[18:02] *** FROGGS_ joined
[18:02] <tomgj> I've done a "class Foo {...};" declaration instead of a "use Foo;" in Bar.pm6

[18:02] <moritz> and then rakudo complains that you haven't declared class Foo

[18:03] <masak> #haskell could help me :>

[18:03] <tomgj> For this application, it's fine, as Foo.pm6 gets loaded elsewhere.

[18:04] *** GlitchMr joined
[18:04] <tomgj> But in general I want Bar to be usable in applications where Foo isn't necessarily used from elsewhere.  And now that I don't "use Foo" from Bar, that isn't the case.

[18:06] *** not_gerd joined
[18:06] <not_gerd> hello, #perl6

[18:06] <tomgj> Ideally I'd want something which either does equivalent of "use Foo" or equivalent of "class Foo {...}" depending on whether Foo.pm6 is already being loaded, ie get behaviour close to Perl 5 ;) 

[18:07] <not_gerd> masak: %sums_with_ambiguous_products is a rather perculiar name for a hash containing the *un*ambiguous ones...

[18:07] <dalek> mu: 69504a5 | duff++ | misc/perl6advent-2012/schedule:

[18:07] <dalek> mu: [advent] claim Dec 24

[18:07] <dalek> mu: review: https://github.com/perl6/mu/commit/69504a58f1

[18:08] <tomgj> is there a standard approach to this issue?  I'd have thought mutually referential types were a pretty common requirement.

[18:09] <PerlJam> I wrote something for Dec. 24 and would appreciate a review.  Right now I've got some family stuff to do, but I'll check back for commentary later.  See http://perl6advent.wordpress.com/?p=1841&preview=true

[18:09] * PerlJam bbl

[18:09] <masak> PerlJam++

[18:10] <masak> PerlJam: `constant @months` line is way too long as it stands now.

[18:10] <masak> could use a linebreak or two.

[18:11] <isBEKaml> masak: day24 has code? I thought it was special. :-)

[18:11] <arnsholt> tomgj: Declare the two types in the same file

[18:11] <masak> PerlJam: apart from that, looks like a nice post :)

[18:12] <masak> not_gerd: yeah.. I realized that too late. :/

[18:12] <masak> not_gerd: serves me right for trying to come up with better names.

[18:12] <masak> not_gerd: and the gist was made anonymously, so I can't change it.

[18:15] <tomgj> arnsholt: okay, I guess I will in this case.  Would be interested to hear about any solutions that would work for types in two different modules maintained by two different authors that need to refer to each other.

[18:17] *** spider-mario joined
[18:18] <arnsholt> In that case you'd probably want parametric types or some such

[18:18] <arnsholt> Hardcoded deps between types in wildly different codebases would be insane

[18:18] <arnsholt> The reason you have to do this is that "use Foo" doesn't necessarily mean that a type Foo will be defined (just most of the time)

[18:19] <arnsholt> And the Perl 6 syntax requires all types to be properly declared, so if you want mutually dependent types, you're gonna have to put them in the same compilation unit

[18:20] <arnsholt> (And temporarily stub one of them with "class Foo { ... }")

[18:20] <tomgj> I'll read up on parametric types, but I am assuming that the types in mutual use have well specified and stable interfaces, so the comment about "wildly different codebases" doesn't apply -- they are both just using something else by contract

[18:24] <arnsholt> Parametric types are sort of like generics in Java (to first order, anyways)

[18:24] <arnsholt> Which is what you want for a proper linked list type anyways

[18:27] <tomgj> It's not a linked list.  Just a data structure with two way references between the nodes.  But each node is of a specific type, so no generics or similar required.  That is all I meant by "doubly linked data structure".

[18:30] <tomgj> I'm happy with making a stub class declaration in my current application, I just don't see how this scales to cases where Foo needs Bar, Bar needs Foo, and neither one knows whether something other than itself is going to load the thing it needs.

[18:34] <moritz> the solution is to design your applications not to need that kind of dependencies

[18:37] <moritz> applications and libraries in all languages are designed to fit well with the language

[18:37] <moritz> people are used to the fact that perl fits most design approach, but it simply can't fit all possible approaches

[18:42] <moritz> nr: my @a = <a b c>; my %h; %h{.value} //= .key for @a.pairs

[18:42] <p6eval> niecza v24-12-g8e50362:  ( no output )

[18:42] <p6eval> ..rakudo c8de2e: OUTPUT¬´Method 'key' not found for invocant of class 'Any'‚ê§current instr.: '' pc 177 ((file unknown):174270982) (/tmp/ZDd4dvFElF:1)‚ê§called from Sub 'METAOP_TEST_ASSIGN:<//>' pc 128320 (src/gen/CORE.setting.pir:58643) (src/gen/CORE.setting:12563)‚ê§called from Sub '' pc 238 (‚Ä¶

[18:42] <moritz> rakudobug

[18:42] <moritz> afaict the first one uncovered by this year's p6cc :-)

[18:43] <moritz> r: $_ = 'abc'; my $x //= .uc;

[18:43] <p6eval> rakudo c8de2e:  ( no output )

[18:43] <moritz> r: $_ = 'abc'; my $x //= .uc; say $x

[18:43] <p6eval> rakudo c8de2e: OUTPUT¬´ABC‚ê§¬ª

[18:43] <masak> moritz++

[18:43] <moritz> r:  my $x //= .uc for 'a'

[18:43] <p6eval> rakudo c8de2e: OUTPUT¬´Method 'uc' not found for invocant of class 'Any'‚ê§current instr.: '' pc 135 ((file unknown):87) (/tmp/MLZb5oFAnf:1)‚ê§called from Sub 'METAOP_TEST_ASSIGN:<//>' pc 128320 (src/gen/CORE.setting.pir:58643) (src/gen/CORE.setting:12563)‚ê§called from Sub '' pc 171 ((file un‚Ä¶

[18:43] * masak submits rakudobug

[18:43] <moritz> that's the golfed variation

[18:43] <masak> noted.

[18:46] * moritz propose methods Hash.pop and Hash.unshift

[18:46] <moritz> they do the reverse of .push

[18:47] <moritz> method pop($key) { self{$key} ~~ Positional ?? self{$key}.pop || self{$key}:delete }

[18:48] <masak> sounds sane.

[18:48] <masak> though I've never felt a need for it yet myself.

[18:48] <masak> maybe because I don't much use the magic behavior of Hash.push

[18:48] <moritz> I just have the need

[18:49] <moritz> I want to order thing in the same order in which they original appeared in a list

[18:49] <moritz> so the obvious approach is to put the original indexes in a hash

[18:49] <moritz> but one thing can appear twice in the original list

[18:49] <not_gerd> bye, #perl6

[18:49] *** not_gerd left
[18:50] <moritz> so I need to use Hash.push, and then when sorting reconsider stuff

[18:51] <hoelzro> I had an interesting thought while I was out

[18:51] <hoelzro> wouldn't it be cool if you could tell a Perl 6 grammar to print out a Pygments lexer version of itself?

[18:51] <hoelzro> it's probably wishful thinking, but it would be pretty neat.

[18:54] *** cognominal joined
[18:56] *** huf joined
[18:57] <masak> hoelzro: sounds like a nice module.

[18:57] <hoelzro> maybe I should write that instead of working on this Pygments lexer ;)

[18:59] <rindolf> Hi all.

[18:59] <rindolf> Hi masak , moritz , hoelzro 

[18:59] <hoelzro> rindolf: hello

[18:59] <rindolf> So how's life past the end of the world?

[19:00] <isBEKaml> world ended? I didn't know!

[19:00] <rindolf> isBEKaml: it was supposed to do.

[19:01] <isBEKaml> was it? I thought it was some kind of out of memory error on Mayan's part. :P

[19:01] <rindolf> isBEKaml: heh.

[19:01] <isBEKaml> yeah, failed malloc(), maybe.

[19:01] <masak> "Rumors of the world's end have been greatly exaggerated." :)

[19:02] <pmurias> hoelzro: what do you need a Pygments lexer of Perl6 for?

[19:02] <hoelzro> pmurias: I want Perl6 code to be properly highlighted on Github.

[19:04] <isBEKaml> hoelzro: If you've already spent some time with pygments, I guess you'd not want to redo all of that with a perl6 grammar. :-) Ofcourse, it'd make a nice exercise coming up with a module so we don't have to do it all over again for an update. 

[19:04] <hoelzro> isBEKaml: well, I've got the basics working. I was thinking that it would be cool to just Perl6::Grammar.pygmentize, though

[19:04] *** xinming left
[19:05] <moritz> that'll be note quite trivial :-)

[19:05] <hoelzro> indeed

[19:05] <moritz> s/note/not/

[19:06] <pmurias> hoelzro: have you looked at Perl6::Grammar?

[19:06] <isBEKaml> hoelzro: awesome. You could push whatever you've got so far (so you don't throw away your time you've put in this)

[19:06] <hoelzro> pmurias: a little bit

[19:06] <hoelzro> isBEKaml: my lexer is on bitbucket

[19:06] *** xinming joined
[19:06] <pmurias> the hard part of that seems to all the bits of imperative code

[19:08] <pmurias> so in order to turn that into a pygments lexer we would need a Perl6->python compiler

[19:08] <pmurias> s/Perl6/NQP

[19:08] <pmurias> which seems to be loads of work for little clear benefitsd

[19:08] <pmurias> * benefits

[19:09] <mst> with the possible exception of "fun"

[19:09] *** am0c joined
[19:09] *** PacoAir joined
[19:10] <pmurias> mst: targeting python doesn't seem significantly more fun than targeting JavaScript

[19:10] <hoelzro> I was hoping that most of the imperative stuff would be confined to Perl6::Actions, but I suppose that was a silly assumption to make

[19:10] <pmurias> mst: which I'm already doing

[19:10] <mst> I said "possible" advisedly.

[19:10] <cognominal> reading the backlog. What is nqp-js?

[19:11] <mst> presumably something that compiles NQP to javascript

[19:11] <pmurias> yes

[19:11] <masak> cognominal: it's pmurias implementation of nqp on JavaScript.

[19:11] <mst> I mean, it could turn out to be a toaster

[19:11] <mst> but that doesn't seem amazingly likely given the name

[19:11] <masak> :P

[19:11] <masak> cognominal: with the eventual goal of giving Rakudo a JavaScript backend.

[19:11] <cognominal> masak: is that on github?

[19:11] <pmurias> yes

[19:12] <masak> https://github.com/pmurias/rakudo-js

[19:12] <cognominal> thx

[19:13] <pmurias> it actually evolved from a (very incomplete) Rakudo JavaScript backend

[19:14] <masak> I've decided I like Haskell for this problem.

[19:20] *** am0c left
[19:22] *** huf left
[19:23] *** thou_ joined
[19:23] <pmurias> masak: this problem = the logical problem you are solving?

[19:27] <masak> pmurias: aye.

[19:27] <masak> almost done.

[19:28] *** Vlavv left
[19:28] *** Vlavv joined
[19:32] <masak> ...and now I want Haskell's list comprehensions in Perl 6. :)

[19:32] <masak> maybe there'll be a module (and a blog post) coming out of this exercise.

[19:34] *** lorn left
[19:35] <moritz> r: say <1 2>.sum

[19:35] <p6eval> rakudo c8de2e: OUTPUT¬´No such method 'sum' for invocant of type 'Parcel'‚ê§  in block  at /tmp/gBAun135Z2:1‚ê§‚ê§¬ª

[19:36] <moritz> r: say ([1, 4], 3).sort: &sum

[19:36] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared name:‚ê§    &sum used at line 1‚ê§‚ê§¬ª

[19:36] <moritz> r: say ([1, 4], 3).sort: &prefix:<[+]>

[19:36] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared name:‚ê§    &prefix:<[+]> used at line 1‚ê§‚ê§¬ª

[19:36] *** rummik left
[19:38] *** FROGGS joined
[19:38] <FROGGS> hi there

[19:38] *** lorn joined
[19:38] <masak> FROGGS! \o/

[19:39] <FROGGS> masak: hi, what a greeting ;o)

[19:39] *** huf joined
[19:39] *** rummik joined
[19:41] <masak> FROGGS: well, it's great that you're here :D

[19:43] <GlitchMr> https://github.com/rakudo/rakudo/commit/0199241400c09c858623717bce2aa84ff7614133

[19:43] <GlitchMr> huh?

[19:43] <GlitchMr> Wouldn't that cause code like `my $variable = $variable;` break

[19:44] <GlitchMr> (moving variable to higher scope)

[19:44] <moritz> well, first of all that doesn't work as you'd expect it to

[19:44] <GlitchMr> It worked in Perl 5.

[19:44] <masak> that was wrong :)

[19:44] <moritz> because in Perl 6, variables are visible immediately after declaration

[19:45] <masak> not on the statement after.

[19:45] <masak> (which is insane)

[19:45] <moritz> and secondly, the commit makes it complain if the mention of the variable happens *before* the declaration

[19:45] <moritz> so this case isn't affected at all

[19:49] <hoelzro> q'...

[19:49] <hoelzro> sorry, formulating a question.

[19:50] <hoelzro> q'...', qq'...', and Q'...' can all work with the various bracketing characters, yes?

[19:50] <moritz> yes.

[19:50] <hoelzro> ok, good to know

[19:54] <hoelzro> http://hoelz.ro/files/perl6-pygments3.png

[19:54] <hoelzro> (for anyone who's interested in my progress)

[19:56] <GlitchMr> Better than my syntax highlighting :-)

[19:57] <GlitchMr> Also, interesting prompt

[19:57] <hoelzro> thanks

[19:57] <isBEKaml> hoelzro: about the prompt - oh-my-zsh? :)

[19:57] <hoelzro> isBEKaml: nah, I converted my bash profile a few weeks ago to try out zsh

[19:58] <hoelzro> so far, so good =)

[19:58] <isBEKaml> hoelzro: nice work, keep going!

[19:58] *** pmurias left
[19:58] <hoelzro> thanks!

[20:00] *** GlitchMr left
[20:03] <hoelzro> it feels like every time I tick a TODO item off this lexer list, I add another =/

[20:09] <masak> that's how TODO lists always work for me.

[20:09] <hoelzro> heh

[20:09] <dalek> rakudo-js: 89c7a01 | (Pawe≈Ç Murias)++ | / (4 files):

[20:09] <dalek> rakudo-js: [nqp] <?{...}> assertions, pass test 34, use .to_s,.to_i,.to_n for

[20:09] <dalek> rakudo-js: conversions

[20:09] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/89c7a018d8

[20:24] *** popl joined
[20:27] *** rodasac joined
[20:27] <moritz> hoelzro: TODO is not a list, it's a queue :-)

[20:28] *** pmurias joined
[20:30] *** rodasac left
[20:31] *** snearch joined
[20:32] <popl> moritz: a list is an implementation of a queue, isn't it?

[20:32] <popl> I mean, queue is abstract.

[20:33] <masak> an array has all the operations needed for a queue, but it also has a bit too many.

[20:33] <moritz> popl: I meant more in the sense of how you perceive the data structures

[20:34] <masak> for a queue, you only need .push and .shift -- but if you also have .pop, you can violate the protocol invariants of the queue.

[20:34] <moritz> a TODO list is something where you tick off items, and then you're done

[20:34] <popl> My first thought was that you meant TODO has some sorting based on priority

[20:35] <popl> masak: violating protocol invariants sounds like my idea of a good time

[20:35] * popl sorts some hashes

[20:36] <moritz> when in fact a TODO is an ever-growing lump of items

[20:36] <popl> moritz: indeed!

[20:36] <moritz> like, a stack overflow :-)

[20:36] <isBEKaml> 'night, #perl6 folks! 

[20:36] *** isBEKaml left
[20:37] <masak> fare thyself well, isBEKaml.

[20:37] <felher> masak: sweet, thnx :)

[20:37] <masak> Rust seems an interesting beast to me, in that they evolve their implementation quite rapidly: https://github.com/mozilla/rust/wiki/Doc-detailed-release-notes

[20:37] <popl> masak: Are you wearing a cloak and drinking out of a horn?

[20:38] <masak> reminds me of Perl 6 somehow, except that they seem to do more of an implement-is-spec thing.

[20:38] <popl> Ok, quit it. You just rhymed.

[20:38] <popl> /Rust seems an interesting beast to me/in that they evolve their implementation quite rapidly/

[20:38] <masak> :D

[20:39] * popl waits for masak to bring out a lute and start dancing

[20:39] *** xinming left
[20:39] <masak> popl: it was not my intention to rhyme; but yes, it's *my* idea of a good time :P

[20:40] <popl> http://www.encyclopediaofukraine.com/pic%5CH%5CU%5CHutsul_dance.jpg # masak's idea of a good time

[20:40] <masak> oh, I've done my fair share of that.

[20:41] <masak> not necessarily in full uniform, though.

[20:41] *** xinming joined
[20:41] <popl> masak: my friend did morris dancing at his wedding

[20:41] <masak> felher: I wrote a Haskell version of it, too: https://gist.github.com/4360642

[20:41] <masak> felher: it's pretty, but it has a bug somewhere, so it outputs too many solutions :/

[20:42] *** sergot joined
[20:42] <sergot> hi o/ !

[20:42] <masak> sergocie! \o/

[20:42] <sergot> masaku ! 

[20:42] <sergot> How are You? :)

[20:43] <felher> masak: oh, cooooooooooooooooooool! I'll take a look at it after one episode of simpsons and maybe implementing it in haskell, too, before I look at yours :)

[20:43] <sergot> It's Christmas time! I should dive into perl6 again! :)

[20:43] <popl> humbug

[20:44] <moritz> masak: it's easy to get the wrong answer in O(beautiful code) :-)

[20:45] *** cognominal left
[20:45] <popl> moritz: doesn't matter if it's pretty

[20:51] <masak> felher: I'd be happy to compare solutions, and be influenced by your solution.

[20:51] <masak> moritz: I'm sure I missed something fairly trivial. the port was fairly straightforward, modulo five-or-so beginned questions on my part on #haskell.

[20:54] * moritz has reworked his t5 solution to be Moar Good[tm]

[20:56] <diakopter> Moar Good is Good

[20:58] * masak whacks diakopter over the head with a feather :)

[20:58] <masak> I'm glad to report we have a second prize for this yer's p6cc, too.

[20:59] <masak> I'll be changing the blog post now to reflect that.

[21:07] <felher> masak: seems like you have to wait another day. I'm quite tired and heading for bed now. And since I'm far away from knowing haskell by heart, doing it in Haskell would take a while.

[21:07] <felher> night, #perl6 :)

[21:07] <diakopter> o/

[21:08] <masak> 'night, felher 

[21:09] <masak> (and I know what you mean. feeling stumped at printing things in a loop was a refreshing experience.) :)

[21:10] *** Moukeddar joined
[21:11] <Moukeddar> \o/ #perl6

[21:12] <masak> Moukeddar! \o/

[21:12] <masak> second prize now published: http://strangelyconsistent.org/blog/the-2012-perl-6-coding-contest

[21:12] <masak> sign up sign up sign up

[21:12] <masak> less than one week left to sign up. do it before it's too late.

[21:12] * masak tweets

[21:12] <Moukeddar> o/ masak

[21:13] <Moukeddar> saw your blog o HNews the other day, strangelyConsistent is catchy 

[21:13] <masak> Perl 6 is strangely consistent ;)

[21:13] *** snearch left
[21:15] <Moukeddar> so, how's the best community doing ? 

[21:15] *** Pleiades` left
[21:15] <masak> we're having a blast today. :)

[21:15] <masak> Moukeddar: would you like to see a nifty math problem? :)

[21:16] *** cognominal joined
[21:16] <Moukeddar> let's see :)

[21:16] *** am0c joined
[21:16] <masak> Moukeddar: https://gist.github.com/4358598

[21:16] <masak> (courtesy of sorear++)

[21:17] *** nyuszika7h joined
[21:17] <Moukeddar> somehow this problems bring some bad memories about arithmitics and its sadistic teacher 

[21:19] <masak> yeah, well, we have weird tastes here :)

[21:19] <masak> I wrote a solution in Perl 6 earlier today (which worked).

[21:19] <masak> and then one in Haskell (which didn't).

[21:21] <Moukeddar> i fail to see the role of S and P here 

[21:21] <Moukeddar> could you elaborate?

[21:21] *** Pleiades` joined
[21:22] <masak> oh, sure. S and P are two people. S knows the sum X+Y, and P knows the product X*Y. but S doesn't know the product and P doesn't know the sum.

[21:23] <masak> all they can do is analyze the other person's thinking process.

[21:24] <Moukeddar> is there a specific math rules i should know in order to solve this, i did study some Arithmitics

[21:24] <masak> nah, not really.

[21:24] <masak> you need to know how to add and multiply.

[21:24] <masak> factors come in a bit too. but nothing fancy.

[21:26] <Moukeddar> so, if S says their sum, P gotta figure the numbers and their product, right ?

[21:26] *** mj41 joined
[21:27] <masak> yes, but the weird thing about this problem is that neither S nor P ever say any numbers.

[21:27] <Moukeddar> find every two numbers which thei sum is equal to what S said, and calculate their product ? 

[21:27] <masak> they just talk about what they learn from the (very small) clues they are giving each other.

[21:27] <Moukeddar> what, so, find every two numbers which their sum is under 100, calculate their product, no ?

[21:32] <sorear> good * #perl6

[21:32] <pmurias> hi

[21:32] <masak> sorear! \o/

[21:32] <masak> Moukeddar: yeah, that's a good start, but far from it.

[21:32] *** thou_ left
[21:32] <masak> Moukeddar: the objective is to find X and Y.

[21:33] *** mj41 left
[21:33] <cognominal> speaking of thinking about  knowledge involving many people, I like this problem.    http://discuss.joelonsoftware.com/default.asp?interview.11.179310.37   

[21:34] <Moukeddar> given that X+Y <100 , and X,Y >1 , right ?

[21:34] <masak> Moukeddar: right.

[21:34] <masak> Moukeddar: also, you might as well assume X<Y to avoid duplicate solutions.

[21:35] <masak> cognominal: ah, that one.

[21:35] <masak> cognominal: there's something that deeply disturbs me about that class of problems.

[21:36] <masak> cognominal: maybe the fact that it assumes that the participants are far more rational than normal people, in the sense that they reason arbitrarily deeply down the he-knows-she-knows stack.

[21:36] <cognominal> it assumes many things, the the husbands are intellegent enough to figure out and that they play by the rules...

[21:36] <masak> right.

[21:39] <popl> "he-knows she-knows stack" # masak++

[21:39] <Moukeddar> is it finite?

[21:39] <popl> We can hope.

[21:39] <cognominal> the mathematician Jean Yves Girard is very critical of these kinds of problems and about people who enjoys unchecked conceptual recursions and meta levels and trashe authors that loosely play on that, like the author of g√∂del, escher, bach. Too bad I am not sharp enough to understand his own logic.

[21:40] <popl> Moukeddar: sorry, conflation

[21:40] <popl> popl--

[21:40] <sorear> cognominal: is that the calc of constructions guy?

[21:41] <popl> sorear: so-rear or s-orear?

[21:41] <popl> or s-or-ear?

[21:41] <popl> OH

[21:41] * popl does /whois

[21:41] <popl> sorear: sorry

[21:42] <FROGGS_> or-ear, lol

[21:42] <popl> masak: I think I am in that class of people. :(

[21:42] <cognominal> that is the guy which created System F used to infer types thru unification. Language like haskell tries to push forward that logic.

[21:43] <masak> popl: what class of people?

[21:44] <popl> some subset of the complement of the set of ideal people in those problems

[21:44] <masak> :)

[21:45] <masak> it's somewhat a matter of habit, I guess.

[21:45] <masak> that, and pattern matching.

[21:45] <popl> it is horrible and depressing :P

[21:46] <cognominal> Jean Yves Girard explains that the incompletude theorem is just an encoding that permits to apply the Cantor's diagonal.  

[21:46] <cognominal> That cuts most of the crap written by many authors.

[21:49] <masak> the incompleteness theorem affects any system that's smart enough to start describing itself.

[21:49] <masak> it's basically the possibility of autopuns infecting the system, bringing it down.

[21:49] <masak> :)

[21:51] *** cognominal left
[21:54] *** cognominal joined
[21:57] *** kaare_ left
[22:07] *** leont joined
[22:14] *** LlamaRider joined
[22:19] *** rindolf left
[22:24] *** rurban left
[22:32] *** Moukeddar left
[22:34] <LlamaRider> Hi. Any tips on what are the most detailed docs on P6 grammars out there? I just "experimentally" found out that you can't mix <names> with 'string literals'  in grammar "rules" and am wondering if I could've read about it beforehand.

[22:34] <pmurias> LlamaRider: you have seen the synopsis?

[22:35] <LlamaRider> I've seen S05 and it seemed quite brief.

[22:36] <diakopter> O_O

[22:37] <diakopter> well, the section on grammars, comparatively, I suppose

[22:37] <LlamaRider> then again I entered from http://perlcabal.org/syn/S05.html#Grammars, which seems quite close to the end of S05

[22:37] <LlamaRider> didn't read the entirety of it

[22:38] *** FROGGS_ left
[22:38] <timotimo> moritz: perl-6.de is a bit out of date, no? "kinda perl6"? :)

[22:38] <diakopter> LlamaRider: can you show an example of mixing <names> with 'string literals'? I'm curious what you mean

[22:40] <LlamaRider>  rule compare {<name> ' and ' <name> ' are of ' <type_claim> '.'}

[22:40] <LlamaRider> what I managed to get working was:

[22:40] <LlamaRider> rule compare {<name><and><name><are><type_claim><dot>}

[22:40] <LlamaRider> where I just moved the literals into their own tokens

[22:41] <diakopter> was there an error before?

[22:41] <LlamaRider> just the matching was failing, it seemed permitted

[22:41] <diakopter> oh

[22:41] <diakopter> it's because a rule eats whitespace between terms

[22:41] <diakopter> so the ' and...' won't match

[22:42] <LlamaRider> even withing apostrophes? sigh.

[22:42] <LlamaRider> within*

[22:42] <diakopter> no, I mean

[22:42] <diakopter> the rule processor chews through the whitespace in the string before it gets to the ' and ' portion

[22:42] <LlamaRider> that's fine, I never needed that whitespace

[22:43] <LlamaRider> I just need the whitespace within the apostrophes

[22:43] <LlamaRider> token and {' and '}

[22:43] <diakopter> did you try changing compare to a token instead of a rule?

[22:43] <LlamaRider> O_O

[22:43] <LlamaRider> it worked...

[22:44] <LlamaRider> yes, that is the kind of difference I would've liked to read about :)

[22:44] <LlamaRider> but wait... then why is the rule failing?

[22:45] <diakopter> see http://perlcabal.org/syn/S05.html#Regex_Routines%2C_Named_and_Anonymous

[22:45] <diakopter> it shows the equivalents to regex/token/rule

[22:46] <diakopter> see how rule inserts the <.ws>

[22:52] <timotimo> is it possible (but please don't spoil the solution) to make a lazy list of all combinations of my enum Blah<A, B>? i was trying to make a lazy self-referencing list with the sequence operator that uses X, but that didn't work very well.

[22:53] <timotimo> i'd like one or two non-spoily hints, please :)

[22:54] * diakopter has no hints, spoily or otherwise

[22:55] *** leont left
[23:00] <LlamaRider> I still find it baffling why the rule clashes with single-quoted whitespace. But I guess that's that, I'll just avoid using rules when I have whitespace chars.

[23:01] <diakopter> if you require whitespace between the terms, use a rule, but don't put whitespace in the literals

[23:02] <timotimo> r: sub mysub() { "hey" }; mysub\ ()

[23:02] <p6eval> rakudo c8de2e: OUTPUT¬´No such method 'postcircumfix:<( )>' for invocant of type 'Str'‚ê§  in  at src/gen/BOOTSTRAP.pm:852‚ê§  in any  at src/gen/BOOTSTRAP.pm:836‚ê§  in block  at /tmp/KrKe1OW5Iy:1‚ê§‚ê§¬ª

[23:02] <timotimo> is this a bug? shouldn't the unwhitespace reduce to this?

[23:02] <timotimo> r: sub mysub() { "hey" }; mysub()

[23:02] <p6eval> rakudo c8de2e:  ( no output )

[23:03] <diakopter> no; to invoke there has to be nothing before the (

[23:03] <timotimo> i thought unwhitespace turns whitespace into nothing?

[23:03] <diakopter> places where comments and unwhitespace can appear, yes

[23:04] <diakopter> so the comment tells the parser it's done parsing the term mysub

[23:04] <diakopter> what does niecza do?

[23:04] *** am0c left
[23:05] <diakopter> n: sub mysub() { "hey" }; mysub\ ()

[23:05] <p6eval> niecza v24-12-g8e50362:  ( no output )

[23:05] <diakopter> n: sub mysub() { "hey" }; mysub\ .WHAT().say

[23:05] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Str()‚ê§¬ª

[23:05] <diakopter> n: sub mysub() { "hey" }; mysub\ ()()

[23:05] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Str‚ê§  at /tmp/5aOO25TQCh line 1 (mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4219 (module-CORE @ 580‚Ä¶

[23:05] <diakopter> n: sub mysub() { "hey" }; mysub\ ()\ ()

[23:05] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Str‚ê§  at /tmp/wIkKeFYV5N line 1 (mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4219 (module-CORE @ 580‚Ä¶

[23:06] <diakopter> looks like niecza doesn't do that

[23:06] <timotimo> heh.

[23:09] *** spider-mario left
[23:11] *** cognominal left
[23:12] *** cognominal joined
[23:13] *** cognominal left
[23:16] *** mj41 joined
[23:16] <timotimo> gotta run, bye

[23:21] *** mj41 left
[23:28] *** popl left
[23:28] *** popl joined
[23:28] *** popl left
[23:28] *** popl joined
[23:34] <masak> 'night, #perl6

[23:34] <sorear> night masak

[23:46] *** bot48 left
[23:56] *** Celelibi left
[23:58] *** popl left
