[00:01] *** donaldh left
[00:04] *** molaf_ joined
[00:06] *** whiteknight joined
[00:07] *** molaf left
[00:09] *** lestrrat left
[00:10] *** lestrrat joined
[00:16] *** hundskatt left
[00:22] <dalek> roast: c027a2f | jnthn++ | S05-match/make.t:

[00:22] <dalek> roast: Untodo a test.

[00:22] <dalek> roast: review: https://github.com/perl6/roast/commit/c027a2f305

[00:24] <dalek> rakudo/nom: bcf2a4e | jnthn++ | src/Perl6/Actions.pm:

[00:24] <dalek> rakudo/nom: Fix a couple of $/ handling issues. Of note, $/ was not available to code blocks inside of regexes, and the code that shoulda been setting it was binding, whereas we assign to $/.

[00:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bcf2a4ea27

[00:24] <dalek> rakudo/nom: dba6048 | jnthn++ | src/core/ (2 files):

[00:24] <dalek> rakudo/nom: Fix using make inside a regex (it only worked when used in the action method before now).

[00:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/dba604867f

[00:24] <dalek> rakudo/nom: d3471b9 | jnthn++ | t/spectest.data:

[00:24] <dalek> rakudo/nom: Run S05-match/make.t.

[00:24] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d3471b9e67

[00:26] <sorear> jnthn: you... assign to $/ ?

[00:26] <jnthn> phenny: tell moritz I fixed 'abc' ~~ / (a) { say $0 } bc / this evening, but don't immediately see a test to cover it...well, tbh, tired and need sleep now, so only looked so hard. ;-) If you don't find one, one of us can always file a ticket and tag it testneeded... ;)

[00:26] <phenny> jnthn: I'll pass that on when moritz is around.

[00:27] <jnthn> sorear: Yeah, pmichaud++ and I settled on assigning it rather than binding it ages back. Guess the reasoning is some way back in the ir clog...

[00:28] * jnthn remembers a discussion on that here, just not the outcome.

[00:28] <jnthn> er

[00:28] <jnthn> not the details, I mean.

[00:28] <jnthn> grr, my fingers won't type what my brain is thinking :)

[00:28] *** huf left
[00:28] <sorear> I remember a discussion involving myself and one or more of {jnthn, TimToady, pmichaud} that decided on binding

[00:29] <jnthn> er:/

[00:29] <jnthn> Well, it doesn't matter much.

[00:29] <jnthn> The problem was that we were doing assignment in all cases but one.

[00:30] <jnthn> Which, innevitably, made a mess.

[00:30] <sorear> jnthn: what do you think of $CALLER::x seeing 'has $x' ?

[00:30] *** huf joined
[00:30] <jnthn> sorear: Ugh.

[00:31] <jnthn> sorear: I'm not going to make that work without serious contortions.

[00:31] <sorear> I started to implement that in niecza but the yak shaving got quite out of hand

[00:31] <jnthn> sorear: We re-write $x to $!x at compile time in Rakudo

[00:33] <jnthn> meh. S04-declarations/constant.t thinks that constants are still spec'd as my-scoped...

[00:33] <jnthn> And thanks to $other-bug I fixed earlier today, we passed a test for that.

[00:34] <jnthn> constant yak = 'shaving';

[00:34] <jnthn> bwaha

[00:37] <dalek> roast: 1a61221 | jnthn++ | S04-declarations/constant.t:

[00:37] <dalek> roast: Constants are spec'd as our scoped by default, not my scoped.

[00:37] <dalek> roast: review: https://github.com/perl6/roast/commit/1a61221378

[00:40] <sorear> perl6: say pi

[00:40] <p6eval> rakudo 77e31a: OUTPUT«3.14159265␤»

[00:40] <p6eval> ..pugs b927740: OUTPUT«3.141592653589793␤»

[00:40] <p6eval> ..niecza v13-285-g83e8bea: OUTPUT«3.1415926535897931␤»

[00:40] <jnthn> perl6: say pi.WHAT

[00:40] <p6eval> rakudo 77e31a, niecza v13-285-g83e8bea: OUTPUT«Num()␤»

[00:40] <p6eval> ..pugs b927740: OUTPUT«Rat␤»

[00:42] <jnthn> eek, time is WHAT?

[00:42] <TimToady> with latest spec change should be a RatStr, I think

[00:42] <TimToady> (pi)

[00:43] * jnthn -> sleep &

[00:45] <TimToady> perl6: time.WHAT.say

[00:45] <p6eval> niecza v13-285-g83e8bea: OUTPUT«Num()␤»

[00:45] <p6eval> ..pugs b927740: OUTPUT«Rat␤»

[00:45] <p6eval> ..rakudo 77e31a: OUTPUT«Int()␤»

[00:46] <TimToady> rakudo appears to be the only correct one here...

[00:47] <TimToady> that is, according to http://perlcabal.org/syn/S32/Temporal.html#time

[00:50] *** simcop2387 left
[00:52] *** simcop2387 joined
[00:54] *** Radvendii joined
[00:56] *** Radvendii left
[01:00] *** am0c left
[01:02] *** pat_js left
[01:12] <sorear> niecza: say time

[01:12] <p6eval> niecza v13-285-g83e8bea: OUTPUT«1326760281.4643641␤»

[01:23] *** Chillance left
[01:23] *** Chillance joined
[01:23] *** Chillance left
[01:24] *** Chillance joined
[01:24] <dalek> niecza: b5b8434 | sorear++ | lib/ (4 files):

[01:24] <dalek> niecza: Truly vile hack to allow defining dualvar types

[01:24] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b5b8434a47

[01:33] *** sudokode left
[01:37] *** sudokode joined
[01:39] *** shinobicl_ joined
[01:39] *** shinobicl_ left
[01:41] *** tokuhirom left
[01:58] *** Patterner left
[01:59] *** Psyche^ joined
[01:59] *** Psyche^ is now known as Patterner

[02:00] <dalek> roast: bc6e9d2 | (Solomon Foster)++ | S04-declarations/constant.t:

[02:00] <dalek> roast: Refudge for niecza.

[02:00] <dalek> roast: review: https://github.com/perl6/roast/commit/bc6e9d29b7

[02:16] *** xinming joined
[02:20] *** packetknife left
[02:21] <colomon> hmmm, how to do runtime base conversion in Niecza?

[02:22] <TimToady> there's always eval

[02:23] <TimToady> niecza: say eval '0xffff'

[02:24] <p6eval> niecza v13-287-gb5b8434: OUTPUT«65535␤»

[02:26] <colomon> TimToady++ # I was just about to try making a hacky call into Niecza's internals to do it...

[02:29] *** zjmarlow left
[02:29] <colomon> Action method assertion:sym<...> not yet implemented  :\

[02:31] <colomon> proto token value { <...> };

[02:32] <sorear> it's spelled proto token value {*} nowadays

[02:33] *** zjmarlow joined
[02:33] <colomon> that's what I was just trying to figure out

[02:33] <colomon> sorear++

[02:34] <colomon> I'm working on trying to get panda running on niecza.

[02:34] <colomon> interesting, lots of the grammar bits seem to be obsolete

[02:35] <colomon> <pair> ** [ \, ]  is now  <pair>+ % [\,]   ?

[02:40] <colomon> sorear: any suggestions?  https://gist.github.com/1624222

[02:43] *** leprevost joined
[02:44] <sorear> colomon: yes, althoguh the old syntax should still work

[02:44] <sorear> niecza: / [a] / # curious

[02:44] <p6eval> niecza v13-287-gb5b8434:  ( no output )

[02:44] <sorear> looks like I never got around to porting over check_old_cclass

[02:46] <colomon> sorear: any thoughts on the gist?  it's the error I get, apparently while still loading the use statements in panda.

[02:46] <sorear> yes

[02:46] <sorear> that would be an error from use

[02:48] <sorear> somehow, one of your .ser files has come out of alignment with one of your .dlls

[02:49] <colomon> in the core niecza stuff, or in the project I'm working on?

[02:49] <sorear> which shouldn't even be possible

[02:50] <colomon> "King of the impossible!"

[02:50] <sorear> I don't understand

[02:51] <sorear> what did you do last/

[02:52] <sorear> did you get any errors before this?

[02:52] <colomon> Not like this one

[02:53] <colomon> just your usual run-of-the-mill problems, like the <pair> ** [\,] one

[02:53] <sorear> any other internal errors?

[02:53] <colomon> I don't think so

[02:53] <sorear> that's not an error

[02:53] <sorear> niecza: / . ** . /

[02:53] <p6eval> niecza v13-287-gb5b8434: OUTPUT«Potential difficulties:␤  Unsupported use of atom ** . as separator; nowadays please use atom+ % . at /tmp/cmSXvOMvZ7 line 1:␤------> / . ** .⏏ /␤␤»

[02:54] <colomon> ah, well, there were definitely the ($a as Str) errors

[02:54] <sorear> delete the offending .ser files

[02:54] <colomon> in niecza/obj

[02:54] <colomon> ?

[02:54] <sorear> yes

[02:54] <sorear> that's the only place they are kept

[02:55] <colomon> you're going to love this: just got the error again

[02:56] <sorear> which ser files did you delete?

[02:57] <sorear> but yes, I do love it when errors are reproducable

[02:58] <colomon> the ones that went with these: https://gist.github.com/1624270

[02:58] <colomon> I'm assuming ContainsUnicode is core niecza, it was created 30 minutes before any of the others

[02:58] <sorear> no

[02:58] <colomon> (Or spectest, anyway, if not core.)

[02:59] <sorear> and there isn't a distinction between "core' and "not core" here

[02:59] <colomon> it's spectest

[02:59] <colomon> I just meant core versus panda

[02:59] <sorear> obj/ is just the compiled module cache... it cares not from whence the modules came

[03:00] <colomon> do I need to delete all .ser files?

[03:00] <sorear> but anyways, that error you got, should NEVER happen

[03:00] <sorear> if you can reproduce it, please send everything needed to reproduce it my way

[03:01] <sorear> deleting all .ser files will help since this is fundamentally a .ser staleness problem

[03:01] *** whiteknight left
[03:02] *** am0c joined
[03:02] <colomon> can still duplicate after deleting all .ser files

[03:03] *** jferrero left
[03:03] <colomon> give me a minute to figure out how to send it all to you

[03:05] <sorear> do you get '[auto-compiling setting]'?

[03:06] <colomon> yes

[03:07] <colomon> Do you know how to switch a local git repo to a different external source?

[03:08] <colomon> I'm thinking I should fork panda, commit my changes to the fork, and send you that link

[03:08] <colomon> guess I could just send it as a patch against the standard if you're okay with that.

[03:13] *** xinming left
[03:21] <colomon> sorear: https://github.com/colomon/panda

[03:22] <colomon> you'll need to tweak bootstrap.sh to match your paths, and then run it.  should duplicate the error for you

[03:24] *** agentzh joined
[03:27] *** Chillance left
[03:29] *** xinming joined
[03:31] *** am0c left
[03:31] *** orafu left
[03:32] *** orafu joined
[03:33] *** am0c joined
[03:36] *** cognominal joined
[03:37] *** xinming left
[03:37] *** lestrrat left
[03:37] *** xinming joined
[03:38] *** Psyche^ joined
[03:39] *** lestrrat joined
[03:42] *** Patterner left
[03:42] *** Psyche^ is now known as Patterner

[03:47] *** lutok left
[03:54] <sorear> colomon: \o/ it works!

[03:54] <colomon> as in you don't see the bug, or you fixed it?

[03:55] <sorear> as in, the bug reproduces fine for me

[03:55] <colomon> ah, well, that's the first step!

[04:07] *** am0c_ joined
[04:10] *** am0c left
[04:11] <colomon> 'night

[04:21] *** am0c_ left
[04:44] *** molaf_ left
[05:00] <sorear> phenny: tell colomon The root problem is the proto in JSON::Tiny.  Importing modules that import modules that export protos is broken, and that proto is wrong anyway; it should be an only sub

[05:00] <phenny> sorear: I'll pass that on when colomon is around.

[05:01] <sorear> I feel like the only person in this channel who believes "don't use a multi when only will suffice"

[05:02] <sorear> phenny: tell colomon (it appears to be alpha code, in terms of the contents of the proto)

[05:02] <phenny> sorear: I'll pass that on when colomon is around.

[05:02] *** birdwindupbird joined
[05:04] * geekosaur suspects that feels to most people a bit like Java's "final", with similar "don't prematurely optimize" cautions (don't assume your only calling sequence will necessarily remain the only one)

[05:13] <sorear> multi doesn't just make code slower, it also makes it more complicated and fragile

[05:18] *** _jaldhar left
[05:19] *** jaldhar joined
[05:19] *** am0c joined
[05:24] <moritz> \o

[05:24] <phenny> moritz: 00:26Z <jnthn> tell moritz I fixed 'abc' ~~ / (a) { say $0 } bc / this evening, but don't immediately see a test to cover it...well, tbh, tired and need sleep now, so only looked so hard. ;-) If you don't find one, one of us can always file a ticket and tag it testneeded... ;)

[05:24] <sorear> o\ morits

[05:24] <sorear> z

[05:26] * sorear is mucking around in code ey no longer really understands

[05:28] *** kaare__ joined
[05:28] *** mikemol left
[05:30] *** am0c_ joined
[05:33] *** am0c left
[05:41] *** jaldhar left
[05:45] <dalek> roast: 6bcda09 | moritz++ | S05-capture/subrule.t:

[05:45] <dalek> roast: test availability of $/ in embedded blocks in regexes

[05:45] <dalek> roast: review: https://github.com/perl6/roast/commit/6bcda091cf

[05:45] <moritz> phenny: tell jnthn tests added

[05:45] <phenny> moritz: I'll pass that on when jnthn is around.

[05:45] *** jaldhar joined
[05:58] *** panterax left
[05:59] <moritz> jnthn: oh, turns out we have a passing TODO test in t/spec/S05-metachars/closure.t for it too :-)

[06:01] *** am0c_ left
[06:06] <dalek> roast: 11b621b | moritz++ | S (5 files):

[06:06] <dalek> roast: rakudo refudging; make S06-signature/errors.t a bit more liberal

[06:06] <dalek> roast: review: https://github.com/perl6/roast/commit/11b621b313

[06:08] <dalek> niecza: ee02ddf | sorear++ | lib/ (2 files):

[06:08] <dalek> niecza: Tweaks to allow saving and thawing cross-unit deep sub clones, such as when a proto is imported

[06:08] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ee02ddf77a

[06:08] <sorear> phenny: tell colomon The niecza issue is now fixed

[06:08] <phenny> sorear: I'll pass that on when colomon is around.

[06:12] <TimToady> nom: my $d = Duration.new(1/2); say "one"; sleep 1/2; say "two"; sleep $d; say "three"

[06:12] <p6eval> nom d3471b: OUTPUT«(timeout)one␤two␤»

[06:12] <TimToady> nom: my $d = Duration.new(1/2); say "one"; sleep 1/2; say "two"; sleep $d.Rat; say "three"

[06:12] <p6eval> nom d3471b: OUTPUT«one␤two␤three␤»

[06:12] <TimToady> shouldn't have to convert a Duration to a Rat in order to sleep it

[06:13] <moritz> $d = Duration.new(1/2); say "one"; sleep 1/2; say "two"; sleep $d.Num; say "three"

[06:13] <moritz> nom: $d = Duration.new(1/2); say "one"; sleep 1/2; say "two"; sleep $d.Num; say "three"

[06:13] <p6eval> nom d3471b: OUTPUT«===SORRY!===␤Variable $d is not predeclared at line 1, near " = Duratio"␤»

[06:13] <moritz> nom: my $d = Duration.new(1/2); say "one"; sleep 1/2; say "two"; sleep $d.Num; say "three"

[06:13] <p6eval> nom d3471b: OUTPUT«(timeout)one␤two␤»

[06:21] *** koban joined
[06:27] <moritz> nom: say 1 <=> 2

[06:27] <p6eval> nom d3471b: OUTPUT«Order::Increase␤»

[06:29] *** kaleem joined
[06:31] *** ponbiki joined
[06:32] <TimToady> nom: my $d = Duration.new(1/2).Num; say "alive"

[06:33] <p6eval> nom d3471b: OUTPUT«(timeout)»

[06:33] <moritz> nom: say Duration.^methods(:local)

[06:33] <p6eval> nom d3471b: OUTPUT«new Bridge Str perl x␤»

[06:34] *** wolfman2000 left
[06:36] *** hundskatt joined
[06:40] *** koban left
[06:44] <sorear> TimToady: I find myself thinking that +val('1_2') should strip the Str nature and return a pure Int

[06:46] <TimToady> seems reasonable

[06:47] <sorear> is IntStr supposed to be a user-visible class?

[06:47] <TimToady> I was thinking of it that way

[06:47] <moritz> nom: eval 'class A { }' for 1..3

[06:47] <p6eval> nom d3471b: OUTPUT«===SORRY!===␤Illegal redeclaration of symbol A at line 1, near "{ }"␤»

[06:47] <moritz> should that work?

[06:47] <sorear> -1

[06:48] <moritz> ok

[06:48] <TimToady> it has a collision in package space

[06:48] <TimToady> not in lexical space

[06:48] <moritz> ok, then we have a wrong test for that

[06:48] <moritz> ... which rakudo incidentally just started to fail :-)

[06:48] <TimToady> std: { class A {} }; { class A {} }

[06:49] <p6eval> std dc62e1d: OUTPUT«===SORRY!===␤Illegal redeclaration of symbol 'GLOBAL::<A>' (from line 1) at /tmp/QcSkRkYiZt line 1:␤------> { class A {} }; { class A ⏏{} }␤Check failed␤FAILED 00:01 107m␤»

[06:49] <TimToady> much like that, I think

[06:49] <TimToady> std: { my class A {} }; { my class A {} }

[06:49] <p6eval> std dc62e1d: OUTPUT«ok 00:01 107m␤»

[06:49] <dalek> niecza: 69e36aa | sorear++ | lib/CORE.setting:

[06:49] <dalek> niecza: Add a prototype val().  Only numbers and strings for now.

[06:49] <dalek> niecza: review: https://github.com/sorear/niecza/commit/69e36aa2a7

[06:50] <TimToady> no problem with the lexical parts of the names

[06:50] <dalek> roast: d843543 | moritz++ | S02-names-vars/names.t:

[06:50] <dalek> roast: correct a test, sorear++ TimToady++

[06:50] <dalek> roast: review: https://github.com/perl6/roast/commit/d843543fa6

[06:51] <sorear> std: :(:$foo, :$bar?)

[06:51] <p6eval> std dc62e1d: OUTPUT«===SORRY!===␤Cannot put optional positional parameter after variadic parameters at /tmp/7VUp10jepV line 1:␤------> :(:$foo, :$bar?⏏)␤Check failed␤FAILED 00:01 109m␤»

[06:51] <moritz> niecza: sub MAIN() { say 'x' }

[06:51] <p6eval> niecza v13-288-gee02ddf: OUTPUT«Potential difficulties:␤  &MAIN is declared but not used at /tmp/bkI5kquhqj line 1:␤------> sub MAIN⏏() { say 'x' }␤␤»

[06:51] <sorear> no MAIN quite yet

[06:51] <sorear> (however, the blocker of MAIN was ... val!)

[06:51] <moritz> but you're working on it, right?

[06:51] <sorear> not as such :)

[06:51] *** thou left
[06:52] <moritz> you should. MAIN seems to be the main (sic) blocker to running most Perl 6 coding contest submissions (both last year and this year) straight in niecza

[07:00] *** wtw joined
[07:00] *** zby_home left
[07:01] *** satyavvd joined
[07:05] <moritz> niecza: say 124.base(2)

[07:05] <p6eval> niecza v13-288-gee02ddf: OUTPUT«1111100␤»

[07:09] <dalek> std: 13da5b0 | sorear++ | STD.pm6:

[07:09] <dalek> std: Fix :(:$x. :$y?)

[07:09] <dalek> std: review: https://github.com/perl6/std/commit/13da5b04f1

[07:11] <sorear> TimToady: that's a copy of the fix I used in niecza... I don't think there's too much potential for controversy in it

[07:12] <sorear> TimToady: So... *which* shell is «» supposed to emulate the quoting and interpolation rules of? :)

[07:14] <sorear> niecza: my $x = 'a b'; say < \qq[$x] >.perl

[07:14] <p6eval> niecza v13-289-g69e36aa: OUTPUT«["a", "b"].list␤»

[07:14] <dalek> niecza: 32cb82d | sorear++ | src/STD.pm6:

[07:14] <dalek> niecza: Fix overlooked case in optional-named handling

[07:14] <dalek> niecza: review: https://github.com/sorear/niecza/commit/32cb82d79d

[07:15] <sorear> niecza: say val('3+4i').WHAT

[07:15] <p6eval> niecza v13-289-g69e36aa: OUTPUT«Str()␤»

[07:16] <sorear> oh, forgot a case

[07:16] <sorear> niecza: say +val('123_456')

[07:16] <p6eval> niecza v13-289-g69e36aa: OUTPUT«123456␤»

[07:16] <sorear> niecza: say ~val('123_456')

[07:16] <p6eval> niecza v13-289-g69e36aa: OUTPUT«123_456␤»

[07:16] <sorear> niecza: say val('123_456')

[07:16] <p6eval> niecza v13-289-g69e36aa: OUTPUT«123_456␤»

[07:16] <sorear> niecza: say val('123_456').perl

[07:16] <p6eval> niecza v13-289-g69e36aa: OUTPUT«val("123_456")␤»

[07:16] <sorear> niecza: say val('123_456').WHAT

[07:16] <p6eval> niecza v13-289-g69e36aa: OUTPUT«IntStr()␤»

[07:16] <moritz> that's cool

[07:17] <sorear> niecza: say IntStr ~~ Cool

[07:17] <p6eval> niecza v13-289-g69e36aa: OUTPUT«Bool::True␤»

[07:19] <moritz> niecza: say IntStr.^parents

[07:19] <p6eval> niecza v13-289-g69e36aa: OUTPUT«Unhandled exception: Unable to resolve method parents in class ClassHOW␤  at /tmp/SGWL32KHLF line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3050 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3051 (module-CORE @ 63) ␤  a…

[07:19] <dalek> niecza: ca7eb73 | sorear++ | lib/CORE.setting:

[07:19] <dalek> niecza: ComplexStr needs to exist too

[07:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ca7eb73d4b

[07:19] *** kaare__ left
[07:19] *** ponbiki left
[07:19] <moritz> niecza: say val('1') + val('5')

[07:20] <p6eval> niecza v13-289-g69e36aa: OUTPUT«6␤»

[07:20] <moritz> niecza: say (val('1') + val('5')).WHAT

[07:20] <p6eval> niecza v13-289-g69e36aa: OUTPUT«Int()␤»

[07:21] <sorear> pugs: say pi.FatRat

[07:21] <p6eval> pugs b927740: OUTPUT«*** No such method in class Rat: "&FatRat"␤    at /tmp/3dzsZlb2qd line 1, column 5 - line 2, column 1␤»

[07:21] *** fridim_ joined
[07:22] <moritz> nom: say pi.Rat(1e-14).perl

[07:22] <p6eval> nom d3471b: OUTPUT«62831853/20000000␤»

[07:22] <moritz> nom: say pi.perl

[07:22] <p6eval> nom d3471b: OUTPUT«3.14159265e0␤»

[07:23] <sorear> niecza: say pi.Rat(1e-14).perl

[07:23] <p6eval> niecza v13-289-g69e36aa: OUTPUT«<58466453/18610450>␤»

[07:23] <dalek> rakudo/nom: 02d6448 | moritz++ | src/core/Duration.pm:

[07:23] <dalek> rakudo/nom: more conversion methods in Duration

[07:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/02d644823e

[07:24] <dalek> roast: a6a06ef | moritz++ | S02-names/our.t:

[07:24] <dalek> roast: another small rakudo unfudge

[07:24] <dalek> roast: review: https://github.com/perl6/roast/commit/a6a06ef90a

[07:24] <sorear> phenny: tell TimToady Perhaps (2/3).perl should return '+<2/3>' instead of '<2/3>' -- since the latter is actually RatStr not Rat

[07:24] <phenny> sorear: I'll pass that on when TimToady is around.

[07:27] <sorear> to everyone: I would like to see a better nailing-down of just what « and » are supposed to do

[07:28] <sorear> I get that «'$x' "$y"» is supposed to mean ('$x', $y), possibly with a val() call thrown in on $y

[07:28] <sorear> I also get that «12 23» should be (val(12), val(23))

[07:28] <moritz> afaict they are supposed to parse the contents as a whitespace-delimited list of val-things, falling back to just plain strings if a piece can't be parsed

[07:29] <sorear> and «$y» should be either map &val, $y.comb(/\S+/) or $y.comb(/\S+/)

[07:29] <moritz> the former, I think

[07:29] <sorear> moritz: It's more than that.  Internal quotes are supposed to affect behavior.

[07:30] <moritz> sorear: doesn't val() handle string literals too?

[07:30] <moritz> ah, but probably not interpolation

[07:30] <moritz> then you're right, it's more than just val

[07:32] <sorear> val doing string literals feels wrong to me, because then how do you get at the original string?

[07:33] <moritz> hm, right

[07:34] * moritz -> commute

[07:34] <masak> morning, #perl6

[07:36] <sorear> o/ masak

[07:36] *** lutok joined
[07:42] <dalek> specs: 8e232ce | masak++ | S02-bits.pod:

[07:42] <dalek> specs: [S02] fix tiny typo

[07:42] <dalek> specs: review: https://github.com/perl6/specs/commit/8e232ce9ae

[07:46] *** GlitchMr joined
[07:47] *** fridim_ left
[07:49] <masak> new S02: "In case multiple dispatch determines that it could dispatch as either string or number, a tie results, while may result in an ambiguous dispatch error."

[07:49] <masak> so... it's not quite pure MI, but something else applied on top of it?

[07:51] <geekosaur> "while may results in"?

[07:51] <geekosaur> er, result

[07:51] <sorear> s/while/which/

[07:52] <sorear> masak: no, that's pure MI

[07:52] <sorear> masak: our multiple dispatch doesn't respect C3 ordering

[07:53] <masak> this is news to me.

[07:54] * masak patches the s/while/which/ typo

[07:55] <dalek> specs: 5675fe8 | masak++ | S02-bits.pod:

[07:55] <dalek> specs: [S02] fix another typo

[07:55] <dalek> specs: review: https://github.com/perl6/specs/commit/5675fe80e0

[07:59] <masak> sorear: I'm pretty sure I've seen "C3MRO" sprinkled all over Rakudo's MOP.

[08:05] *** jrockway_ left
[08:06] *** jrockway joined
[08:09] <sorear> masak: that's only used for method (single) dispatch

[08:13] <sorear> currently, all the multiple dispatch implementations in use require that candidates can be statically partial-ordered

[08:14] <sorear> given :(Int $x) and :(Str $x), neither is more specific than the other

[08:14] <sorear> I just came up with an extension of Perl 6 MMD to support C3, but it requires variable candidate ordering

[08:15] <sorear> (my algorithm in a nutshell: A is more specific than B if A precedes B in the MRO of the value under consideration)

[08:15] <moritz> nom: say Str.^methods()

[08:15] <p6eval> nom 02d644: OUTPUT«BUILD Int Num chomp chop substr pred succ ll-match ords lines samecase samespace trim-leading trim-trailing trim words encode capitalize trans WHICH Bool Str ACCEPTS Numeric gist perl comb match subst split␤»

[08:16] <moritz> nom: say Str.^methods(:all)

[08:16] <p6eval> nom 02d644: OUTPUT«BUILD Int Num chomp chop substr pred succ ll-match ords lines samecase samespace trim-leading trim-trailing trim words encode capitalize trans WHICH Bool Str ACCEPTS Numeric gist perl comb match subst split abs conjugate sqrt sign rand sin asin cos acos tan atan atan2…

[08:17] <sorear> I wonder if it would be worth implementing this in niecza

[08:18] <sorear> (niecza already diverges slightly from Rakudo on MMD)

[08:18] <masak> we definitely want to converge on MMD in the long run.

[08:18] <masak> but that doesn't mean we can't do some exploration now.

[08:20] <sorear> perl6: class A {};class B is A {}; class C is B {}; multi foo(A,A){"AA"};multi foo(A,B){"AB"};multi foo(A,C){"AC"};multi foo(B,A){"BA"};multi foo(C,A){"CA"};  say foo(B,C)

[08:20] <p6eval> niecza v13-291-gca7eb73: OUTPUT«Unhandled exception: Ambiguous dispatch for &foo; matched candidates are:␤    A, A␤    A, B␤    A, C␤    B, A␤  at /tmp/exlFcyxt46 line 1 (mainline @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3052 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.set…

[08:20] <p6eval> ..rakudo 02d644: OUTPUT«AC␤»

[08:20] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "A"␤    expecting word character, "|", ":", "*", parameter name or ")"␤    at /tmp/jMxCrHpfdc line 1, column 56␤»

[08:23] * sorear is curious what masak's reaction to this example is

[08:23] <masak> sorear: I think you've brought this up before.

[08:24] <sorear> masak: yes, I have

[08:24] <sorear> I don't think *you* responded though

[08:24] <sorear> also, I didn't have that great example before

[08:24] <masak> and I'm tentatively in jnthn's camp, that while your way of doing MMD might sift out a few more ambiguous cases, it also loses some of the nice static features that Rakudo's MMD has.

[08:25] <masak> it's a good example in that it's short. it's still a bit artificial. :)

[08:26] <masak> the thing that's on the line here is static predictability. I don't consider that worth sacrificing for a few extra disambiguations in cases which are not use cases for anyone right now.

[08:38] *** hundskatt left
[08:39] <sorear> masak: what do you mean by 'static predictability'?

[08:40] *** satyavvd left
[08:41] <masak> good question. :) jnthn explained over a beer once, and I've forgotten the details.

[08:41] <masak> but it's to do with the type DAG that is computed for determining narrowness.

[08:42] <masak> every dispatch should fall out of the information in that DAG, and only that.

[08:42] <sorear> um, where clauses

[08:42] <moritz> modulo that, yes :-)

[08:42] <masak> right :)

[08:42] <sorear> the current niecza model does everything using a DAG too

[08:43] <masak> oh, ok.

[08:43] <masak> well, then you and jnthn have something to talk abou.

[08:43] <masak> about*

[08:44] <sorear> the model I proposed at XX:15 requires the DAG to be recomputed every time, which is LTA

[08:45] <masak> ah -- and that must be what is meant by "static predictability" (or whatever the term was)

[08:46] <sorear> given class A { }; class B { }; class C is A is B { }; class D is B is A { };

[08:47] <sorear> multi foo(A) { }; multi foo(B) { }

[08:47] <sorear> which candidate is narrower?

[08:47] <sorear> C and D both match both candidates

[08:47] <sorear> but they have different C3 MROs

[08:47] <sorear> if everything is decided based on a static DAG, C3 

[08:47] <sorear> cannot be respected

[08:47] <sorear> clear?

[08:49] <masak> yes, I think so.

[08:50] <masak> though I understand the example, I don't feel qualified to argue things one way or the other.

[08:50] <moritz> same here

[08:50] <masak> I'm wary about burning out jnthn though, and he didn't seem enthused by re-doing Rakudo's MMD again :)

[08:50] <moritz> I think the real question is how to build the DAG in the case of method dispatch

[08:51] <moritz> ie if you build a single DAG, or one per inheritance level

[08:51] <moritz> and I think the spec has gone back and forth here a few times

[08:51] <sorear> this change can implemented as a small patch

[08:51] <moritz> and I don't remember what the current iteration says :-)

[08:51] <sorear> basically, niecza keeps an int[] blockers; on each candidate

[08:51] *** drbean_ joined
[08:51] <sorear> both rakudo and niecza linearize the DAG for fast access

[08:52] <sorear> and linearly scan for a matching candidate

[08:52] *** mj41 joined
[08:52] <sorear> rakudo groups the candidate list into "levels", and declares a tie if there is a second match from the same level

[08:52] <sorear> niecza explicitly tracks which candidates tie which others

[08:53] <sorear> if cand_A precedes cand_B in the list, but cand_A is not narrower than cand_B, then cand_A.blockers contains cand_B

[08:53] <sorear> that was iff

[08:54] *** nornagest joined
[08:58] <masak> meeting &

[09:14] <sorear> sleep &

[09:25] <moritz> fwiw I've written a script twice, once in p6 and once in p5. niecza took 4 seconds, perl 5 took 2.6s

[09:26] *** dakkar joined
[09:26] <tadzik> 'morning

[09:27] <jnthn> < sorear> the model I proposed at XX:15 requires the DAG to be recomputed every time, which is LTA

[09:27] <phenny> jnthn: 05:45Z <moritz> tell jnthn tests added

[09:27] <jnthn> ==> then that model is broken.

[09:27] <jnthn> moritz: thanks! :)

[09:27] <jnthn> 10:19 < moritz> I think the real question is how to build the DAG in the case of method dispatch

[09:27] <jnthn> 10:19 < moritz> ie if you build a single DAG, or one per inheritance level

[09:27] <jnthn> 10:20 < moritz> and I think the spec has gone back and forth here a few times

[09:27] <moritz> jnthn: though it turns out we had a passing TODO to for it anyway

[09:27] <moritz> s/to/test/

[09:28] <jnthn> ==> you build a DAG incorporating all candidates visible at the current level

[09:28] <jnthn> (Which is differnt from a DAG per level with only the candidates at that level.)

[09:30] *** daxim joined
[09:37] <jnthn> moritz: May be worth an autounfudge run, btw - I think there may be more tests dependent on the Role(42) thingy I implemented last night that I didn't find.

[09:37] <dalek> roast: 1d471ee | moritz++ | S05-metasyntax/angle-brackets.t:

[09:37] <dalek> roast: yet another rakudo unfudge

[09:37] <dalek> roast: review: https://github.com/perl6/roast/commit/1d471eed88

[09:38] <moritz> jnthn: that's the result of the autounfudge run (which I forgot to push earlier)

[09:39] <jnthn> moritz: ah, ok :(

[09:39] * jnthn had hoped for more than that

[09:39] <dalek> roast: ed909c2 | moritz++ | S16-filehandles/unlink.t:

[09:39] <dalek> roast: tweak a fudge message

[09:39] <dalek> roast: review: https://github.com/perl6/roast/commit/ed909c2a9a

[09:42] *** xinming left
[09:44] *** xinming joined
[09:47] <moritz> perl6: enum A <b c d>; say A(2)

[09:47] <p6eval> rakudo 02d644: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&A' called (line 1)␤»

[09:47] <p6eval> ..niecza v13-291-gca7eb73: OUTPUT«A::d␤»

[09:47] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/lyIYyJLyJj line 1, column 1-15␤»

[09:47] <moritz> perl6: enum A <b c d>; say A.(2)

[09:47] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/YKa43aP0EZ line 1, column 1-15␤»

[09:47] <p6eval> ..rakudo 02d644, niecza v13-291-gca7eb73: OUTPUT«A::d␤»

[09:47] <moritz> hm

[09:56] <jnthn> std: enum A <b c d>; say A(2)

[09:56] <p6eval> std 13da5b0: OUTPUT«ok 00:01 108m␤»

[09:57] <jnthn> Guess we have a missing check somewhere.

[09:59] <moritz> I guess that falls under the same coercive forms as Int("42")

[10:00] <jnthn> Yeah.

[10:00] *** xinming left
[10:01] *** xinming joined
[10:03] <jnthn> moritz: Any chance you could ticket it? I'll try and fix those coercive forms soon...gotta focus on $dayjob for a bit now though.

[10:04] <moritz> jnthn: ok, will do

[10:08] *** olanol joined
[10:11] *** olanol left
[10:19] *** nornagest left
[10:33] <moritz> jnthn: turns out we already have a ticket for that: https://rt.perl.org/rt3//Ticket/Display.html?id=65658

[10:34] <jnthn> moritz: ah, nice :)

[10:34] <moritz> (and tests!)

[10:35] <jnthn> \o/

[10:35] <jnthn> Will see what tuits I get at le hotel this evening. :)

[10:37] <jnthn> ...though I should probably spend them on that backtracking bug.

[10:39] *** xinming left
[10:39] *** xinming joined
[10:42] *** spine_ joined
[10:42] <moritz> what does the fix involve? when we parse Foo(), check if &Foo is in scope, and if not, but a type Foo is predeclared, change the codegen to invoke Foo instead of &Foo?

[10:43] <moritz> niecza: enum A <b c>; sub A($x) { $x }; say A(0)

[10:43] <jnthn> moritz: I'm not sure quite how STD makes the distinction.

[10:43] <p6eval> niecza v13-291-gca7eb73: OUTPUT«A::b␤»

[10:43] <moritz> I'm pretty sure that's wrong

[10:43] <jnthn> moritz: oh?

[10:43] <moritz> <identifier>() should always decide in favor of the sub, no?

[10:43] <jnthn> nom: enum A <b c>; sub A($x) { $x }; say A(0)

[10:43] <p6eval> nom 02d644: OUTPUT«0␤»

[10:44] <jnthn> moritz: Hm, even in the type case?

[10:44] <jnthn> If so, then STD is wrong, but also Int($x) is dubious too.

[10:44] <jnthn> Unless we plan to go on "if there's a sub", but that's very problematic because subs are post-declared.

[10:46] <moritz> ah, I mis-remembered

[10:47] <moritz> this disambiguation rules applies to the short name of enum *values*

[10:47] <moritz> ie

[10:47] <moritz> perl6: enum A <b c>; sub b() { 'sub' }; say b(); say b

[10:47] <p6eval> rakudo 02d644: OUTPUT«sub␤A::b␤»

[10:47] <p6eval> ..niecza v13-291-gca7eb73: OUTPUT«Unhandled exception: No value for parameter $key in CommonEnum.postcircumfix:<( )>␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (CommonEnum.postcircumfix:<( )> @ 1) ␤  at /tmp/f4au61f2Nq line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting…

[10:47] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/pi5TszGbpz line 1, column 1-13␤»

[10:48] * moritz opens niecza issue

[10:48] <jnthn> aha

[10:49] *** arlinius left
[10:50] *** arlinius joined
[10:51] <moritz> std: Foo()

[10:51] <p6eval> std 13da5b0: OUTPUT«===SORRY!===␤Undeclared name:␤    'Foo' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[10:51] <moritz> std: foo()

[10:51] <p6eval> std 13da5b0: OUTPUT«===SORRY!===␤Undeclared routine:␤ 'foo' used at line 1␤Check failed␤FAILED 00:01 107m␤»

[10:52] <moritz> std: Foo(); sub Foo() { }

[10:52] <p6eval> std 13da5b0: OUTPUT«ok 00:01 108m␤»

[10:54] *** xinming left
[10:54] *** xinming joined
[10:58] *** nornagest joined
[11:06] <felher> Here we go: http://rosettacode.org/wiki/Miller-Rabin_primality_test#Perl_6

[11:06] <felher> moritz++ for enhancing the code :)

[11:06] <moritz> felher++ for writing it; I just commented on trivialities

[11:07] <masak> felher++ # nice use of subtypes

[11:08] <masak> I'd've inlined that modexp sub, but that's probably just me ;)

[11:09] <masak> er, I mean I'd've put it inside the other sub. not eliminated it altogether.

[11:10] <dalek> roast: dbb6654 | moritz++ | S03- (16 files):

[11:10] <dalek> roast: rename S03-operator/binding-*.t to S03-binding/*.t

[11:10] <dalek> roast: review: https://github.com/perl6/roast/commit/dbb6654486

[11:10] <dalek> rakudo/nom: 8975299 | moritz++ | t/spectest.data:

[11:10] <dalek> rakudo/nom: track test file renaming

[11:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8975299436

[11:12] <dalek> niecza: ad5617d | moritz++ | t/spectest.data:

[11:12] <dalek> niecza: track test file renaming

[11:12] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ad5617d574

[11:14] *** stefanZ joined
[11:17] <felher> masak: Yeah, i though about it, too. I didn't do it, because modexp is a utility function that is only in the file because we currently lack a math-module that handles it. Putting it in the function may suggest, that it is something that is special to that function (so special, that it won't get a module). But i totally see your point. I just couldn't really decide :)

[11:19] *** dbr joined
[11:21] <masak> http://rosettacode.org/wiki/Symmetric_difference#Perl_6 should have a solution involving sets, too.

[11:24] <felher> masak: right :)

[11:25] <moritz> felher: fwiw I've locally changed the call to modexp to the nqp::expmod_I opcode, and it reduced runtime from 9.3 seconds to 6.7..7.0s

[11:25] <moritz> though the call is a bit ugly:

[11:25] <moritz> my $x = nqp::expmod_I(nqp::p6decont($a), nqp::p6decont($d), nqp::p6decont($n), Int);

[11:26] <felher> moritz: Hm, nice :)

[11:28] <moritz> I'm pretty sure one can speed up things more by using a loop with native ints as iterators

[11:28] <jnthn> Pushed handouts fixes.

[11:28] <jnthn> er, oops

[11:28] <jnthn> ww

[11:31] <jnthn> moritz: libtommath seems to make quite a cost out of creating and freeing loads of mp_ints.

[11:32] <jnthn> moritz: If I get the tuits, I may see about maintaining a free list of them or something.

[11:35] <moritz> felher: and if I rewrite the inner loop to use a native int as iterator, I get down to 5.4s

[11:35] *** pothos_ joined
[11:35] *** jnthn joined
[11:36] *** felher left
[11:36] *** kthakore joined
[11:36] *** HarryS left
[11:36] *** felher joined
[11:37] *** chra joined
[11:37] <felher> moritz: nice :) Quite a speedup :)

[11:37] *** cooper left
[11:37] *** pothos left
[11:37] *** pothos_ is now known as pothos

[11:37] <moritz> it looks a bit ugly though

[11:37] *** cooper joined
[11:37] <moritz> that's the thing I'd do in a math library, not on a show-off page like rosettacode :-)

[11:38] *** HarryS joined
[11:38] <felher> moritz: yeah :D

[11:38] *** jasonmay joined
[11:38] <felher> moritz: gist of the loop? :)

[11:40] *** c1sung left
[11:40] *** Maddingue left
[11:40] *** xinming left
[11:40] *** Maddingue joined
[11:40] *** cognominal left
[11:40] *** cognominal joined
[11:40] *** c1sung joined
[11:43] *** zjmarlow left
[11:54] <colomon> o/

[11:54] <phenny> colomon: 05:00Z <sorear> tell colomon The root problem is the proto in JSON::Tiny.  Importing modules that import modules that export protos is broken, and that proto is wrong anyway; it should be an only sub

[11:54] <phenny> colomon: 05:02Z <sorear> tell colomon (it appears to be alpha code, in terms of the contents of the proto)

[11:54] <phenny> colomon: 06:08Z <sorear> tell colomon The niecza issue is now fixed

[11:55] *** lestrrat left
[11:55] *** lestrrat joined
[11:55] *** nornagest_ joined
[11:55] *** nornagest_ left
[11:59] *** zjmarlow joined
[11:59] *** nornagest left
[12:12] *** bluescreen10 joined
[12:13] *** xinming joined
[12:26] <colomon> niecza: say $*CWD

[12:26] <p6eval> niecza v13-291-gca7eb73: OUTPUT«Any()␤»

[12:26] *** lichtkind joined
[12:39] <moritz> felher: https://gist.github.com/75b078d082ce95d5972a

[12:39] <jnthn> moritz: my int $max = nqp::unbox_i($s);

[12:39] <jnthn> ...did you need that explicit unbox?

[12:40] <jnthn> If you did, and it generates different code without it, then it's a Rakudo bug.

[12:40] <moritz> jnthn: it's not needed, but iirc we emit a vtable call otherwise

[12:40] <jnthn> moritz: I thought I fixed that once... 

[12:40] <moritz> jnthn: ah, maybe my information is outdated

[12:41] <jnthn> darn

[12:41] <jnthn> no, you're right :/

[12:42] <jnthn> QAST is going to have language-configurable coercion, to solve this once and for all.

[12:42] *** bluescreen10 left
[12:45] *** sftp left
[12:46] *** sftp joined
[12:48] *** bluescreen10 joined
[12:50] *** donri joined
[12:53] *** xinming left
[12:56] <moritz> jnthn: well, what should it compile to?

[12:56] <moritz> just an unbox?

[12:56] <moritz> or type check + unbox?

[12:57] <jnthn> An unbox is a type check in a sense.

[12:57] <jnthn> If it fails to unbox, it's not assignable.

[12:57] <jnthn> nom: nqp::unbox_i('lol')

[12:57] <p6eval> nom 897529: OUTPUT«This type cannot unbox to a native integer␤  in block <anon> at /tmp/jRi65R2Cgi:1␤  in <anon> at /tmp/jRi65R2Cgi:1␤»

[12:59] <dalek> niecza: 3649559 | (Solomon Foster)++ | lib/ (2 files):

[12:59] <dalek> niecza: cwd plus crude implementations of $*CWD, chdir.

[12:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/36495591d3

[12:59] <dalek> niecza: 49b1577 | (Solomon Foster)++ | t/spectest.data:

[12:59] <dalek> niecza: Turn on S28-named-variables/cwd.t.

[12:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/49b1577e3a

[13:00] <colomon> phenny: tell sorear $*CWD is a complete hack and chdir isn't catching exceptions properly -- but never-the-less both are there enough to be useful atm

[13:00] <phenny> colomon: I'll pass that on when sorear is around.

[13:08] <dalek> rakudo/nom: 0ac25d0 | jnthn++ | src/core/ (2 files):

[13:08] <dalek> rakudo/nom: First cut implementation of <prior>; seems to work, but sadly not for the m/.../ form.

[13:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0ac25d036d

[13:08] <jnthn> Just had time for that quick hack before I head to the station. Feel free to improve it.

[13:08] <jnthn> travel to Gothenburg &

[13:10] *** xinming joined
[13:16] *** mtk joined
[13:17] *** am0c_ joined
[13:23] *** GlitchMr left
[13:23] *** drbean_ left
[13:27] *** molaf joined
[13:28] *** Chillance joined
[13:29] *** drbean_ joined
[13:30] <colomon> roast has no tests for cwd or printf.  :(

[13:31] <moritz> well, sprintf is much easier to test :-)

[13:31] <colomon> granted

[13:32] <dalek> niecza: b11c7b5 | (Solomon Foster)++ | lib/CORE.setting:

[13:32] <dalek> niecza: Wholesale theft of printf from Rakudo.

[13:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/b11c7b50d6

[13:33] *** drbean_ left
[13:41] *** xinming left
[13:47] *** kaleem left
[13:47] <PerlJam> greetings

[13:48] <colomon> o/

[13:48] <masak> \o

[13:49] <moritz> -o-

[13:49] *** am0c_ left
[13:49] <PerlJam> starting to look like semaphores :)

[13:51] <dalek> niecza: 64527c0 | (Solomon Foster)++ | lib/CORE.setting:

[13:51] <dalek> niecza: Rearrange chdir a bit, it doesn't actually work any better, alas.

[13:51] <dalek> niecza: review: https://github.com/sorear/niecza/commit/64527c0b0b

[14:02] <felher> moritz: interesting, thnx :)

[14:12] *** overrosy left
[14:13] *** overrosy joined
[14:18] *** mikemol joined
[14:22] *** Chillance left
[14:22] *** Chillance joined
[14:36] *** agentzh left
[14:38] *** muixirt joined
[14:40] <muixirt> nom: my @a1=1,2,3,4; my @a2=@a1[2 ..^ @a1]; my @a3=@a2[1 ..^ @a2]

[14:41] <p6eval> nom 0ac25d: OUTPUT«(timeout)»

[14:41] <moritz> nom: my @a1=1,2,3,4; my @a2=@a1[2 ..^ @a1]; say 'alive'

[14:41] <p6eval> nom 0ac25d: OUTPUT«alive␤»

[14:42] <moritz> nom: my @a1=1,2,3,4; my @a2=@a1[2 ..^ @a1]; say @a2; say 1..^@a2

[14:42] <p6eval> nom 0ac25d: OUTPUT«3 4␤1..^[3, 4]␤»

[14:43] <muixirt> nom: my @a1=1,2,3,4; my @a2=@a1[2 ..^ @a1]; say @a2; say 1..^@a2.elems

[14:43] <p6eval> nom 0ac25d: OUTPUT«3 4␤1..^2␤»

[14:44] * masak doesn't like "1..^[3, 4]"

[14:44] <muixirt> nom: my @a1=1,2,3,4; my @a2=@a1[2 ..^ @a1]; my @a3=@a2[1 ..^ @a2.elems]; say 'alive'

[14:44] <p6eval> nom 0ac25d: OUTPUT«alive␤»

[14:44] <moritz> nom: my @a1=1,2,3,4; my @a2=@a1[2 ..^ @a1]; say @a2; (1..^@a2).list

[14:44] <p6eval> nom 0ac25d: OUTPUT«3 4␤»

[14:48] *** mikemol left
[14:49] *** mikemol joined
[14:49] *** tokuhirom joined
[14:52] *** benabik joined
[14:52] *** PacoAir joined
[14:56] *** xinming joined
[14:58] *** cognominal left
[14:59] *** nornagest joined
[14:59] <masak> what's the word on :instanceof in Parrot?

[14:59] <masak> will Parrot release with or without it?

[14:59] <moritz> with; the commit has been reverted

[15:00] *** cognominal joined
[15:02] *** xinming left
[15:02] <masak> \o/

[15:12] *** xinming joined
[15:16] *** wtw left
[15:19] *** xinming left
[15:20] *** xinming joined
[15:24] *** xinming left
[15:24] *** xinming_ joined
[15:26] *** sayu joined
[15:30] *** skids joined
[15:31] *** xinming_ left
[15:31] *** xinming joined
[15:36] *** xinming left
[15:39] * flussence successfully saves nyan cat from crash land

[15:46] *** xinming joined
[15:46] *** xinming left
[15:47] *** GlitchMr joined
[15:48] *** xinming joined
[15:50] *** xinming left
[15:50] *** xinming joined
[15:53] <masak> quiet here today. everybody's holding their breath for Parrot 4.0.0, p'haps?

[16:03] *** thou joined
[16:04] <skids> jnthn++ for fixing regexp make and $/ in block.  That was a blocker for my dabblings.

[16:04] *** nnunley left
[16:05] *** sayu left
[16:12] <skids> .oO(its a good thing I don't have a commit bit judging by how many times I accidentally told git to try to push to rakudo/rakudo while trying to fast forward my github fork.)

[16:19] <muixirt> masak: oh, everybody is waiting for big enhancements in Parrot 4.0.0?

[16:19] * muixirt wasn't aware of that...

[16:20] *** nebuchadnezzar left
[16:20] <colomon> muixirt: not that I'm aware of

[16:21] <benabik> There tends to be a lull in Rakudo around Parrot's release in preparation for its own release.

[16:22] <colomon> jnthn's traveling right now, that's my explanation.  

[16:23] <colomon> and sorear's asleep.  ;)

[16:23] <masak> muixirt: I wasn't entirely serious. at least I don't think I was. :)

[16:23] * muixirt keeps a straight face

[16:24] <masak> :|

[16:25] <muixirt> but benabik++, moritz++ and others for updating the links

[16:27] <muixirt> masak: do you have an explanation for the ..^@a hang ups?

[16:27] <masak> muixirt: I don't.

[16:28] <masak> seems the @a doesn't get numified, and that causes problems in some loop or other.

[16:28] <masak> but that much is obvious.

[16:28] <muixirt> on the bright side: it doesn't eat up memory :-)

[16:28] <masak> \o/

[16:30] *** hundskatt joined
[16:33] *** nebuchadnezzar joined
[16:35] *** zjmarlow left
[16:37] * jnthn makes it to Gothenburg

[16:37] <jnthn> Train was on time! o.O

[16:37] *** tokuhirom left
[16:39] <colomon> \o/

[16:40] *** jferrero joined
[16:51] *** stefanZ left
[16:58] <masak> jnthn: just you wait until the snow arrives... :)

[16:58] * masak decommutes

[17:00] *** birdwindupbird left
[17:01] *** jerome_ joined
[17:03] *** cognominal_ joined
[17:04] *** cognominal left
[17:08] * [Coke] kicks off the daily run.

[17:11] *** localhost left
[17:12] *** ggoebel_ joined
[17:14] *** kaleem joined
[17:15] <ggoebel_> perl6: 'Happy Easter'.say

[17:15] <p6eval> pugs b927740, rakudo 0ac25d, niecza v13-296-g64527c0: OUTPUT«Happy Easter␤»

[17:15] <ggoebel_> glad to see the distributions lifting each other to greater heights

[17:15] <PerlJam> you're a little early for easter :)

[17:16] <ggoebel_> perhaps it is time for http://perl6.org/compilers/ to be updated? "not yet well realized" no longer seems to apply to Niecza

[17:17] <[Coke]> PerlJam: easter is a reference to niecza beating rakudo in the spec tests.

[17:17] <ggoebel_> And here I thought I was late ;-)

[17:17] <[Coke]> for one apparently brief moment. ;)

[17:18] *** Chillance left
[17:18] <ggoebel_> looks forward to celebrating Easter every other day...

[17:18] <PerlJam> ggoebel++

[17:19] *** HarryS left
[17:20] *** HarryS joined
[17:23] *** cognominal___ joined
[17:26] *** cognominal_ left
[17:27] *** BinGOs left
[17:27] *** jerome_ left
[17:31] *** fridim_ joined
[17:32] *** daxim left
[17:33] *** BinGOs joined
[17:35] <dalek> perl6.org: 042d48e | moritz++ | source/compilers/index.html:

[17:35] <dalek> perl6.org: be less pessimistic about niecza. ggoebel++

[17:35] <dalek> perl6.org: review: https://github.com/perl6/perl6.org/commit/042d48ec9a

[17:35] *** bluescreen10 left
[17:38] *** ggoebel_ left
[17:40] *** ocharles left
[17:42] *** ocharles joined
[17:45] *** lichtkind_ joined
[17:45] *** lichtkind left
[17:45] *** lichtkind_ is now known as lichtkind

[17:46] *** mj41 left
[17:46] <tadzik> 'evening

[17:47] <sorear> good * #perl6

[17:47] <phenny> sorear: 13:00Z <colomon> tell sorear $*CWD is a complete hack and chdir isn't catching exceptions properly -- but never-the-less both are there enough to be useful atm

[17:47] <colomon> \o

[17:48] <TimToady> vv probably

[17:48] <phenny> TimToady: 07:24Z <sorear> tell TimToady Perhaps (2/3).perl should return '+<2/3>' instead of '<2/3>' -- since the latter is actually RatStr not Rat

[17:48] *** ocharles left
[17:48] <TimToady> but then maybe (2/3) is good enuf

[17:49] <TimToady> since other .perl emissions seem to rely on some degree of constant folding and/or construction

[17:49] *** ocharles joined
[17:50] *** bluescreen10 joined
[17:50] <TimToady> or maybe we need a rule that says spaceless <> constructs throw away the Str component

[17:51] <TimToady> so <2/3> and <1+2i> are really special forms

[17:51] <colomon> +1

[17:51] *** spine_ left
[17:52] * colomon thought that's the way it was going to work originally....  ;)

[17:52] *** dakkar left
[17:53] <TimToady> the main oddity of that is that ~<2/3> makes .66666666 while ~< 2/3 > makes 2/3

[17:53] <TimToady> but we could probably live with that

[17:53] <TimToady> sorear: opinions? ^^

[17:53] *** fridim_ left
[17:53] <TimToady> sorear: certainties? ^^  :)

[17:54] <sorear> I think I could live with that

[17:54] <sorear> would <abc> continue to be allowed?

[17:55] *** alester joined
[17:55] <TimToady> sure

[17:55] <TimToady> and if we allow enums in val, don't apply the rule to those, I think

[17:56] <TimToady> that is, <False> woudl stay a string

[17:56] <[Coke]> b: say 19223-19135 ; # niecza at 99.54%

[17:56] <p6eval> b 1b7dd1: OUTPUT«88␤»

[17:57] *** ocharles left
[17:57] <[Coke]> rakudo has 27 more failures than it did yesterday.

[17:57] <TimToady> I've been looking at http://rosettacode.org/wiki/Miller-Rabin_primality_test#Perl_6 and wondering how close our optimizers are to moving $n - 1 out of the loop as effectively nonmutating

[17:57] <jnthn> [Coke]: ugh, I thought I'd cleared up the regressions last night :/

[17:57] *** BinGOs left
[17:58] <moritz> my last spectest run showed a single failure, in t/spec/S12-methods/multi.rakudo

[17:58] *** ocharles joined
[17:58] <TimToady> it's interesting that the Perl 6 code follows the pseudocode so closely at the beginning, but I suspect right now an implementation that precalculated $n - 1 would be significantly faster

[17:58] <TimToady> and maybe 1 | $n - 1 as well

[17:59] <jnthn> TimToady: The underlying variable analysis that would support such a transformation is relatively high on my optimizer todo list. But the optimizer todo list is just one of my todo lists. :)

[17:59] <[Coke]> moritz: we're up to 57 total.

[18:00] <[Coke]> https://gist.github.com/1476841

[18:00] <jnthn> [Coke]: Platform?

[18:00] <[Coke]> feather

[18:00] <jnthn> k

[18:00] <[Coke]> 32bit linux mumble.

[18:01] <TimToady> jnthn: I have a great appreciation for your todo lists, and for how often you mutate them :)

[18:01] <[Coke]> hurm. maybe not? Linux feather 2.6.32-5-amd64 #1 SMP Mon Mar 7 21:35:22 UTC 2011 x86_64 GNU/Linux

[18:01] *** zby_home_ joined
[18:01] <[Coke]> jnthn: http://feather.perl6.nl/~coke/rakudo_summary.txt

[18:02] <[Coke]> ... wait a sec.

[18:02] <[Coke]> http://feather.perl6.nl/~coke/rakudo_summary.out , sorry.

[18:02] * jnthn wonders why his hotel room is so hot when outside it's below freezing.

[18:03] <moritz> oh drat, the overflow tests are platform dependent

[18:03] <jnthn> Very. Some fail here too.

[18:03] <jnthn> Though less than before.

[18:04] <[Coke]> moritz: yah, we knew this already.

[18:04] *** BinGOs joined
[18:04] <moritz> jnthn: maybe the constant folder changed that?

[18:04] <moritz> or isn't that wired up for those cases yet?

[18:05] <jnthn> moritz: The only place it's wired up is for enums

[18:06] *** ocharles left
[18:07] <TimToady> perl6: (1 .. 1_000_000_000_000).pick(5).say  # another potential problem with the Miller-Rabin code

[18:07] <moritz> nom: try { die "foo" }; say so $! ~~ /foo/

[18:07] <p6eval> niecza v13-296-g64527c0: OUTPUT«(timeout)»

[18:07] <p6eval> ..pugs b927740: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[18:07] <p6eval> ..rakudo 0ac25d: OUTPUT«Failed allocation of 4096 bytes␤Parrot VM: PANIC: Out of mem!␤C file src/gc/alloc_memory.c, line 105␤Parrot file (not available), line (not available)␤␤We highly suggest you notify the Parrot team if you have not been working on␤Parrot.  Use parrotbug (located in p…

[18:07] <p6eval> nom 0ac25d: OUTPUT«Method 'substr' not found for invocant of class 'Exception'␤  in method Str at src/gen/CORE.setting:7276␤  in method Stringy at src/gen/CORE.setting:678␤  in sub prefix:<~> at src/gen/CORE.setting:961␤  in method ACCEPTS at src/gen/CORE.setting:7437␤  in block <anon> …

[18:08] <moritz> TimToady: oh, that one should be easy to fix

[18:08] <TimToady> I think .pick needs to switch to a different algorithm for large ranges and small selections

[18:08] *** ocharles joined
[18:09] <tadzik> perl6: (1 .. 1_000_000_000_000).roll(5).say

[18:09] <TimToady> that's actually what MR specifies

[18:09] <moritz> jnthn: that seems to be the problem, the regex engine now calls .substr on the topic instead of coercing it to Str first

[18:09] <p6eval> niecza v13-296-g64527c0: OUTPUT«(timeout)»

[18:09] <p6eval> ..pugs b927740: OUTPUT«pugs: out of memory (requested 1048576 bytes)␤»

[18:09] <p6eval> ..rakudo 0ac25d: OUTPUT«Failed allocation of 4096 bytes␤Parrot VM: PANIC: Out of mem!␤C file src/gc/alloc_memory.c, line 105␤Parrot file (not available), line (not available)␤␤We highly suggest you notify the Parrot team if you have not been working on␤Parrot.  Use parrotbug (located in p…

[18:09] *** itz left
[18:09] <TimToady> it doesn't say you can't pick the same number twice, at least according to the pseudocode

[18:10] <moritz> now for .roll there's really no reason to evaluate the list at all

[18:10] <TimToady> yes, .roll should just work

[18:10] <tadzik> looks like my roll optimization was not ported to nom

[18:10] <TimToady> but .pick can also be made to work by filtering out previously seen values

[18:10] <moritz> aye

[18:11] *** fridim_ joined
[18:11] <jnthn> moritz: oops, which patch did I do that in?

[18:11] <TimToady> interestingly, using .pick in the MR code gives you more certainty for smaller candidates, since it exhausts the set of possible composites faster

[18:12] <TimToady> and if $k is big enough, considers each candidate once

[18:12] <TimToady> but .pick should degrade gracefully when possible

[18:12] *** Chillance joined
[18:13] <felher> Yes, i used pick because it doesn't make sense to pick things twice.

[18:13] <TimToady> but the pseudocode does :)

[18:13] <moritz> tadzik: I'll backport your Range.roll thingy

[18:13] <tadzik> ++moritz

[18:13] <tadzik> that was my first patch, I think :)

[18:14] <felher> TimToady: indeed. Yeah, maybe one should change that. I don't have any time right now. If someone wants to do it, go ahead. Otherwise i will look at it as soon as i'm home :)

[18:15] <TimToady> also been thinking about how $x == 1 or $x == $n - 1 is or is not equivalent to $x == 1 | $n - 1 or to not( 1 < $x < $n - 1 ) or to not( $x ~~ 1 ^..^ $n -1 )

[18:15] <TimToady> and whether all those can be optimized to whatever is fastest

[18:16] <TimToady> oh, there's also 1 != $x != $n - 1 I imagine

[18:17] *** fridim_ left
[18:17] <TimToady> felher: but the .pick reads better, and is arguably more correct :)

[18:19] *** _dbr joined
[18:20] *** dbr left
[18:21] *** cognominal___ left
[18:21] <TimToady> felher: I agree with your reasoning on leaving modexp outside too

[18:22] *** cognominal joined
[18:23] <TimToady> masak: re http://irclog.perlgeek.de/perl6/2012-01-17#i_5002372, that's one of the reasons I was writing the new Set.pm I gisted a while ago

[18:24] * felher fehler is to busy to answer, but will backlog :)

[18:25] <TimToady> and the next optimization is probably to run each of the $k tests in a separate core :)

[18:26] <TimToady> that would probably be worth adding a second entry; leaving the first as a beautiful translation of the pseudocode

[18:27] <TimToady> (and you guys think libtommath produces garbage fast with one core... :)

[18:28] <TimToady> I still think we're likely to see pointer robbing for smallish integers on any VM that can support it, for just this reason

[18:29] <TimToady> .o(Crook: "It's not really stealing; they'll never miss it...")

[18:32] <TimToady> actually, I think the parallel version should (eventually) simply work from saying "hyper for (2 ..^ $n).pick($k)"

[18:34] <TimToady> any core can falsify by returning False, but True is returned only if all the core's threads terminate for the hyper statement's sequence point

[18:34] <TimToady> that would be 

[18:34] <TimToady> Way Cool

[18:34] *** kaleem left
[18:34] <moritz> is it 'sink hyper for' or 'hyper sink for'?

[18:35] <TimToady> sink hyper

[18:35] <TimToady> but the sink is implied by not being the final statement

[18:35] *** kaleem joined
[18:35] <jnthn> dinner &

[18:37] <TimToady> and it might eventually be a common optimization to throw an implicit hyper on the front of any loop statement that provably does not have interactions from one iteration to the next

[18:42] <masak> TimToady: oh! I wish I had time to help you debug your Set.pm -- it looked like a really good start.

[18:43] *** Bucciarati left
[18:55] <masak> TimToady: is 'hyper' a special form? I don't really see how it can have the effect it does on for.

[18:56] <moritz> masak: remember that 'for' is just a call to map, really

[18:56] <moritz> masak: so it returns a lazy list

[18:56] <moritz> masak: and 'hyper @lazy_list' can does its non-lazy magic

[18:57] <dalek> specs: ea9fd14 | larry++ | S13-overloading.pod:

[18:57] <dalek> specs: imported multis automatically re-export

[18:57] <dalek> specs: 

[18:57] <dalek> specs: The rationale is to get as close as we can to "global MMD" without

[18:57] <dalek> specs: sacrificing lexically static candidate lists.

[18:57] <dalek> specs: review: https://github.com/perl6/specs/commit/ea9fd1499e

[18:57] <TimToady> remember also that "hyper" is just a modified form of "eager"

[18:58] <TimToady> "so eager we don't care which parts of it you do first"

[18:59] <TimToady> perl6: say hyper 1 ... 5

[18:59] <p6eval> rakudo 0ac25d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'hyper' will never work with argument types (Mu) (line 1)␤    Expected any of:␤    :(Any \$op, Any \$a, Any \$b, Any :dwim-left(:$dwim-left), Any :dwim-right(:$dwim-right))␤    :(Any \$op, Any \$obj)␤    :(Any \$op, Associative \$…

[18:59] <p6eval> ..niecza v13-296-g64527c0: OUTPUT«Unhandled exception: No value for parameter $dwimr in hyper␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (hyper @ 1) ␤  at /tmp/UFoAu_cWoD line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3068 (ANON @ 3) ␤  at /home/p6eval/niecza/…

[18:59] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "5"␤    expecting operator, ":" or ","␤    at /tmp/MhB6RWVPXZ line 1, column 17␤»

[19:00] <TimToady> wow

[19:00] <TimToady> perl6: say eager 1,2,3,4,5

[19:00] <p6eval> pugs b927740: OUTPUT«12345␤»

[19:00] <p6eval> ..niecza v13-296-g64527c0: OUTPUT«===SORRY!===␤␤Undeclared routine:␤    'eager' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1144 (P6.comp_unit @ 32) ␤  at /ho…

[19:00] <p6eval> ..rakudo 0ac25d: OUTPUT«1 2 3 4 5␤»

[19:01] <TimToady> pugs: say hyper 1,2,3,4,5

[19:01] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&hyper"␤    at /tmp/CyReSqHviX line 1, column 5 - line 2, column 1␤»

[19:03] <dalek> rakudo/nom: aa1d8b6 | moritz++ | src/core/Range.pm:

[19:03] <dalek> rakudo/nom: optimize Range.roll, and Range.pick if the number of range elems is much larger than the number of elements to pick

[19:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aa1d8b6451

[19:03] <dalek> roast: b896f6d | moritz++ | S32-list/ (2 files):

[19:03] <dalek> roast: tests for Range.roll and .pick

[19:03] <dalek> roast: review: https://github.com/perl6/roast/commit/b896f6d612

[19:03] <[Coke]> huh.rakudo autounfudge run hangs on  t/spec/S02-types/mixed_multi_dimensional.rakudo during the actual call to "fudge"

[19:06] <masak> EMULTIDIMENSIONALFUDGE

[19:07] <moritz> [Coke]: I've had hangs in fudge before, but they are rare

[19:11] *** Trashlord left
[19:13] *** spine joined
[19:15] *** Trashlord joined
[19:19] *** birdwindupbird joined
[19:20] * [Coke] tries just a subset in a higher synopsis.

[19:21] <[Coke]> moritz: have you autounfudged lately?

[19:21] <[Coke]> (if so, I won't bother.)

[19:21] <moritz> [Coke]: yes

[19:21] <[Coke]> ok.

[19:22] <masak> perl6: { our sub foo { say "OH HAI" } }; our &foo; foo

[19:22] <p6eval> rakudo 0ac25d, niecza v13-296-g64527c0: OUTPUT«OH HAI␤»

[19:22] <p6eval> ..pugs b927740: OUTPUT«*** Cannot use Undef as a Code object␤    at /tmp/b1ToOCQhas line 1, column 45 - line 2, column 1␤»

[19:23] <masak> perl6: { our sub foo { say "OH HAI" } }; { our sub foo { say "OH HAI again" } }; our &foo; foo

[19:23] <p6eval> pugs b927740: OUTPUT«*** Cannot use Undef as a Code object␤    at /tmp/WbeTpy39he line 1, column 85 - line 2, column 1␤»

[19:23] <p6eval> ..niecza v13-296-g64527c0: OUTPUT«===SORRY!===␤␤Two definitions found for symbol ::GLOBAL::&foo␤␤  first at ??? line 0␤  second at ??? line 0 at /tmp/kEDMC3OaDH line 1:␤------> b foo { say "OH HAI" } }; { our sub foo ⏏{ say "OH HAI again" } }; our &foo; fo…

[19:23] <p6eval> ..rakudo 0ac25d: OUTPUT«OH HAI again␤»

[19:23] <masak> rakudobug?

[19:24] <moritz> std: { our sub foo { say "OH HAI" } }; our &foo; foo

[19:24] <p6eval> std 13da5b0: OUTPUT«===SORRY!===␤Illegal redeclaration of routine 'GLOBAL::<&foo>' (from line 1) at /tmp/NIvKzhGKZg line 1:␤------> our sub foo { say "OH HAI" } }; our &foo⏏; foo␤Check failed␤FAILED 00:01 113m␤»

[19:24] <moritz> seems like yes

[19:24] *** x3nU left
[19:24] <masak> not the one I meant, but sure. :)

[19:25] <masak> if STD is correct, then it's a nieczabug too.

[19:25] <moritz> I don't think STD makes sense.

[19:25] <moritz> either rakudo or niecza

[19:26] *** _ilbot joined
[19:26] *** Trashlord left
[19:27] <moritz> it seems I've broken Range.pick for many cases :(

[19:29] <TimToady> yes, STD is being too strict there, and isn't distinguishing declaration from definition

[19:29] <masak> ah, so no nieczabug.

[19:29] <masak> but rakudo allows the second 'our sub foo' to overwrite the first.

[19:29] <TimToady> in fact, niecza++ is being very accurate in detecting two *definitions*

[19:29] *** x3nU joined
[19:29] * masak submits rakudobug

[19:33] <masak> sorear: "line 0"?

[19:35] <moritz> can somebody on a recent-ish rakudo build please tell me how large their src/gen/CORE.setting.pir is?

[19:35] <moritz> w 19

[19:35] <moritz> sorry

[19:36] * masak hugs silly irssi user moritz! :D

[19:36] <[Coke]> 281562L

[19:36] <tadzik> moritz: 14Msrc/nom/src/gen/CORE.setting.pir

[19:36] <[Coke]> that's < 1 hour old.

[19:36] <tadzik> 14 MB I guess

[19:36] <moritz> tadzik: thanks

[19:36] <moritz> [Coke]: also thanks

[19:37] <[Coke]> 281562   991826 13849492 src/gen/CORE.setting.pir # wc output.

[19:39] <TimToady> perl6: my $d = Duration.new(1/2); sleep $d

[19:39] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&Duration"␤    at /tmp/hkzbbEWazS line 1, column 4-26␤»

[19:39] <p6eval> ..rakudo aa1d8b: OUTPUT«This type cannot unbox to a native number␤  in <anon> at src/gen/Metamodel.pm:2674␤  in sub sleep at src/gen/CORE.setting:496␤  in block <anon> at /tmp/lH41l6Pcxg:1␤  in <anon> at /tmp/lH41l6Pcxg:1␤»

[19:39] <p6eval> ..niecza v13-296-g64527c0: OUTPUT«===SORRY!===␤␤Undeclared name:␤       'Duration' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1144 (P6.comp_unit @ 32) ␤  at /ho…

[19:40] <TimToady> well, nom is closer...

[19:42] <TimToady> nom: my $later = now + 1; sleep $later - now;   # more to the point

[19:42] <p6eval> nom aa1d8b: OUTPUT«This type cannot unbox to a native number␤  in <anon> at src/gen/Metamodel.pm:2674␤  in sub sleep at src/gen/CORE.setting:496␤  in block <anon> at /tmp/VQEpGWqiKx:1␤  in <anon> at /tmp/VQEpGWqiKx:1␤»

[19:42] *** overrosy left
[19:42] *** mj41 joined
[19:44] *** overrosy joined
[19:46] *** molaf left
[19:47] *** MayDaniel joined
[19:52] <jnthn> om nom

[19:52] <masak> jnthn: eating? :)

[19:55] <jnthn> eated :)

[19:56] *** mattp_ left
[19:56] <jnthn> perl6: { our $x = 42 }; { our $x = 43; }

[19:56] <p6eval> pugs b927740, rakudo aa1d8b, niecza v13-296-g64527c0:  ( no output )

[19:56] <jnthn> So...why is that declaration OK, but the sub one not?

[19:57] <sorear> masak: ??? line 0 means "unknown" ... might be worth adding a special case to the printer

[19:57] <sorear> jnthn: Because 'our $x' has COMMON semantics

[19:57] <sorear> and the = 42 isn't really part of the declarator

[19:57] <jnthn> heh

[19:58] <jnthn> yeah, assignments aren't part of declarators...apart from the majority of situations when they are :)

[19:58] * jnthn still hopes STD changes the way it parses those.

[19:59] <jnthn> sorear: COMMON - is that a spec term?

[19:59] <sorear> No, it's a FORTRAN term

[19:59] <sorear> so, now you expect *consistency*?  you're so difficult :p

[20:00] <jnthn> Oh. The only FORTRAN I did was fixing some physicists attempt to write it. :)

[20:00] <jnthn> It got it to work, but it was probably as much luck as judgement. :)

[20:02] <sorear> I've never actually written any FORTRAN

[20:03] <TimToady> our is supposed to do the initialization at INIT time, and should probably ensure that the values are eqv at that point

[20:03] <slavik> fortran looks very similar to C

[20:04] <slavik> although I realize that is a redundant statement

[20:04] <geekosaur> except it's not really fortran COMMON, or all your "our"s would have to be in the same order in every file using them (or at least overlap sensibly)

[20:05] <masak> sorear: ah.

[20:08] <PerlJam> What's that saying?  "You haven't lived until you've done X"?  In this case, it's more like "you haven't died a little until you've written fortran" :)

[20:09] <geekosaur> but then "you can write FORTRAN in any language"...

[20:09] <doy> i worked on a c project once that was ported from fortran

[20:09] <doy> contained a file block_data.c with ~500 lines of global variable declarations

[20:10] <PerlJam> when I first met pmichaud, he had converted a 90-ish page fortran program to about a 2 page perl program.

[20:10] <PerlJam> (that's the only allowable fortran operation ... getting rid of it)

[20:15] * felher is back.

[20:16] <sorear> hola, felher

[20:16] <felher> So about the pick/roll issue. Do we prefer translation of the pseudo-code to using pick? 

[20:17] <TimToady> there's a choice to make if declarators parse their pseudoassignment; either the declarator has to detect assignment to a tighter operator on the left, or it has to be an assymetric precedence loosener like a listop

[20:18] <felher> Also i like to change the 'or's to '|' as TimToady mentioned. I really like '|', just didn't think of it when writing the code :)

[20:19] <TimToady> I prefer pick because in some sense it's even smarter than the standard algorithm, which can duplicate work

[20:19] <TimToady> (though mostly only for small candidates)

[20:19] *** zjmarlow joined
[20:20] <sorear> TimToady: you are speaking of the 5 * constant $x = 2 funny business?

[20:20] <TimToady> though there may be intermediate values where it's more overhead to tracked which values have been tried than to just use roll semantics

[20:20] <TimToady> yes, though in this case the subject is 'our'

[20:21] *** thou left
[20:21] *** thou joined
[20:21] <TimToady> it looks hard to tell the term what its leftward context is, so I'm inclined to just make it drop precedence to = level

[20:22] <TimToady> it's kinda what people will expect half the time anyway

[20:23] *** MayDaniel left
[20:25] <felher> Okay. So i just use the junctive-ors. I like them. Nobody would say "if the car is blue or the car is red or the car green". Everybody just says "if the car is red, green or blue" :)

[20:25] <TimToady> and we already do it that way for s[foo] = 'bar'

[20:29] <TimToady> the only difference being that in sibble, the assignment is not optional

[20:31] <dalek> roast: 2fae5d6 | moritz++ | S32-list/ (2 files):

[20:31] <dalek> roast: more Range.{roll,pick} tests

[20:31] <dalek> roast: review: https://github.com/perl6/roast/commit/2fae5d6b6d

[20:31] <dalek> rakudo/nom: 0deac24 | moritz++ | src/core/control.pm:

[20:31] <dalek> rakudo/nom: try to fix sleep() with non-Num argument

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0deac24dfe

[20:31] <dalek> rakudo/nom: 2fd18f4 | moritz++ | src/core/Range.pm:

[20:31] <dalek> rakudo/nom: fix Range.{roll,pick}

[20:31] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2fd18f4b66

[20:36] <masak> what, if anything, does 'sibble' stand for?

[20:37] <tadzik> Super Nibble!

[20:37] <benabik> Wikipedia: Sibble is a locality situated in Botkyrka Municipality, Stockholm County, Sweden with 280 inhabitants in 2005.

[20:37] <masak> heh.

[20:37] <felher> wow, using "$x == 1 | $n - 1" instead of "$x == 1 or $n - 1" triples execution-time for MR in nom.

[20:38] <PerlJam> that's not surprising (to me)

[20:38] <masak> felher: not surprized.

[20:38] <TimToady> it has to reconstruct the junction each time

[20:38] <TimToady> which is why I thought about factoring that out along with the $n - 1

[20:38] <jnthn> masak: Wow, that must be the 10th biggest city in Sweden or something! :)

[20:38] <tadzik> :>

[20:38] <TimToady> and why I was thinking about all the other forms of comparison that it could be optimized to

[20:39] <TimToady> masak: it's for substitution nibble

[20:39] <masak> aha!

[20:39] <TimToady> to go with tribble, etc

[20:40] <masak> jnthn: you laugh now, but one day small hamlets will take over the world. mwhahaha.

[20:40] <jnthn> masak: A hamlet sounds like a cute little ham. :)

[20:41] <felher> Hm, then maybe changing 'or's to '|'s should wait until its faster. Although it is nicer, there may be people to try that code and ^C it after 20 seconds... :)

[20:42] <TimToady> and a bullet is a cute little bull

[20:42] <masak> or a cute little bul

[20:42] <masak> felher: use the fast version and add a comment.

[20:43] <jnthn> Well, I don't really want a bull or a bullet coming at me :)

[20:44] *** kaare__ joined
[20:44] * TimToady considers jnthn's feelings and omits pun on seeing red...

[20:44] <jnthn> :)

[20:47] *** kaare__ left
[20:47] *** kaare_ joined
[20:47] *** birdwindupbird left
[20:47] *** kaleem left
[20:48] <jnthn> Gee, Pm wasn't joking when he said getting this backtracking into subrules in place would be tricky...

[20:58] <masak> well, I guess subrules are methods. then it's tricky simply because that method has already returned and now it needs to be resumed.

[20:58] <masak> at least conceptually.

[20:59] <jnthn> omgz, I think it...might have just worked or something

[20:59] <masak> o.O

[21:00] <[Coke]> jnthn++

[21:01] <dalek> roast: 7176c48 | coke++ | S (6 files):

[21:01] <dalek> roast: niecza (auto)unfudge

[21:01] <dalek> roast: review: https://github.com/perl6/roast/commit/7176c48c98

[21:01] <felher> masak: done :)

[21:01] * felher goes back to $job

[21:03] <dalek> nqp: 08e07d7 | jonathan++ | src/Q (2 files):

[21:03] <dalek> nqp: First crack at getting backtracking into subrules working. Needs testing with Rakudo yet.

[21:03] <dalek> nqp: review: https://github.com/perl6/nqp/commit/08e07d777b

[21:03] <masak> felher++

[21:04] <sorear> TimToady: so... «».  which shell is it supposed to emulate? :-)

[21:05] <jnthn> sorear: How about cmd.exe on Windows? ;-)

[21:06] <jnthn> </windows_trolling>

[21:06] <sorear> .oO( my $x; say « foo %x% bar »

[21:06] <sorear> )

[21:07] *** GlitchMr left
[21:08] <jnthn> There will be modules.

[21:11] <masak> :)

[21:12] <jnthn> nom: say ('aaaaabaaaaa' ~~ /^(<[a..z]>*) b/)

[21:12] <p6eval> nom 2fd18f: OUTPUT«#<failed match>␤»

[21:12] <jnthn> Locally:

[21:12] <jnthn> > say ('aaaaabaaaaa' ~~ /^(<[a..z]>*) b/)

[21:12] <jnthn> => <aaaaab> 0 => <aaaaa>

[21:14] <tadzik> nice :)

[21:15] <sorear> jnthn++ jnthn++

[21:16] <jnthn> oh, I had a question

[21:16] <jnthn> /(.)($0)/

[21:16] <jnthn> Should that match e.g. 'aa'

[21:16] <jnthn> niecza: say 'aa' ~~ /(.)($0)/

[21:16] <p6eval> niecza v13-296-g64527c0: OUTPUT«Use of uninitialized value in string context␤  at /home/p6eval/niecza/lib/CORE.setting line 979 (warn @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 188 (Mu.Str @ 10) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/u0K9A6pmwy line 0 (ANON @ 5) ␤…

[21:17] <jnthn> I've an RT that expects it to, but I'm not sure it should.

[21:17] <sorear> I'm not sure either way

[21:18] <jnthn> At least it's not just me that thinks it ain't obvious :)

[21:18] <sorear> I lean towards 'it should work'

[21:18] <PerlJam> Why wouldn't it?

[21:18] <sorear> with a side order of 'invariant meaning of $/ in a regex'

[21:18] <PerlJam> (I think it should work too :)

[21:19] <jnthn> Well, but inside the (...) it's a "different $/" really

[21:19] <jnthn> (The match object you'll get back from $/[0] of the regex overall)

[21:19] <masak> of course it should work.

[21:20] <jnthn> Note that

[21:20] <TimToady> not obvious

[21:20] <jnthn> nom: 'ab' ~~ /((a)(b))/; say $0

[21:20] <p6eval> nom 2fd18f: OUTPUT«=> <ab>␤ 0 => <a>␤ 1 => <b>␤␤»

[21:20] <jnthn> nom: 'ab' ~~ /((a)(b))/; say $1

[21:20] <p6eval> nom 2fd18f: OUTPUT«Any()␤»

[21:20] <jnthn> nom: 'ab' ~~ /((a)(b))/; say $0[1]

[21:20] <p6eval> nom 2fd18f: OUTPUT«=> <b>␤␤»

[21:20] <jnthn> etc

[21:20] <TimToady> and we start $0 renumbering in alternatives

[21:21] *** fridim_ joined
[21:21] <TimToady> niecza: say 'aa' ~~ /(.)($OUTER::0)/

[21:21] <p6eval> niecza v13-296-g64527c0: OUTPUT«===SORRY!===␤␤Variable $OUTER:: is not predeclared at /tmp/ac2xHzHdfh line 1:␤------> say 'aa' ~~ /(.)(⏏$OUTER::0)/␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 919 (die @ 2) …

[21:22] *** y3llow_ joined
[21:22] *** bluescreen10 left
[21:22] *** pothos_ joined
[21:22] <TimToady> niecza: say 'aa' ~~ /((.)$0)/

[21:22] <p6eval> niecza v13-296-g64527c0: OUTPUT«#<match from(0) to(2) text(aa) pos([#<match from(0) to(2) text(aa) pos([#<match from(0) to(1) text(a) pos([].list) named({}.hash)>].list) named({}.hash)>].list) named({}.hash)>␤»

[21:22] <TimToady> I think that is conclusive :)

[21:22] <TimToady> it can't be that and the other at the same time

[21:23] <sorear> Nice try, but niecza is very careful to only count explicit braced constructs as OUTER

[21:23] *** ksi joined
[21:23] <TimToady> () makes a lexical scope in regex

[21:23] <TimToady> so does []

[21:23] <jnthn> Bad news. My patch breaks stuff. :(

[21:24] *** y3llow left
[21:24] *** pothos left
[21:24] *** y3llow_ left
[21:25] *** y3llow joined
[21:25] <TimToady> .oO( $<..>[0] )  # runs away

[21:25] *** pothos_ left
[21:25] *** pothos joined
[21:25] *** cognominal_ joined
[21:26] <jnthn> Better news: it doesn't look deep.

[21:26] <TimToady> niecza: say 'aa' ~~ / (^) (^) ((.)$0)/  # make sure it's not working accidentally on partial outer $0

[21:27] *** y3llow left
[21:27] <p6eval> niecza v13-296-g64527c0: OUTPUT«#<match from(0) to(2) text(aa) pos([#<match from(0) to(0) text() pos([].list) named({}.hash)>, #<match from(0) to(0) text() pos([].list) named({}.hash)>, #<match from(0) to(2) text(aa) pos([#<match from(0) to(1) text(a) pos([].list) named({}.hash)>].list)…

[21:27] <TimToady> no, $0 is truly referring to the inner ()

[21:27] *** y3llow joined
[21:27] <jnthn> OK, so if I follow, /(.)($0)/ ain't gonna work?

[21:27] <TimToady> so it can't also refer to the outer ()

[21:27] <TimToady> nope, can't

[21:28] <PerlJam> TimToady: Could $¢.[0] wor or would it suffer the same problem as $0 ?

[21:28] <TimToady> same

[21:28] <PerlJam> s/wor/work/

[21:28] <jnthn> The cursor is also scoped to the inner thingy

[21:28] <jnthn> Now I understand why pmichaud++ has it the way he does.

[21:28] <PerlJam> that's what I thought

[21:28] *** pothos left
[21:28] *** pothos joined
[21:29] <TimToady> hmm

[21:29] *** cognominal left
[21:29] *** y3llow left
[21:29] <TimToady> niecza: say 'aa' ~~ /(.)$1=$0)/

[21:29] <p6eval> niecza v13-296-g64527c0: OUTPUT«===SORRY!===␤␤Unable to parse regex; couldn't find final '/' at /tmp/RNKwMQxpi0 line 1:␤------> say 'aa' ~~ /(.)$1=$0⏏)/␤␤Parse failed␤␤»

[21:29] *** y3llow joined
[21:29] <TimToady> niecza: say 'aa' ~~ /(.)$1=$0/

[21:29] <p6eval> niecza v13-296-g64527c0: OUTPUT«#<match from(0) to(2) text(aa) pos([#<match from(0) to(1) text(a) pos([].list) named({}.hash)>, Cursor.new(...)].list) named({}.hash)>␤»

[21:29] <TimToady> tada

[21:30] <TimToady> niecza: 'aa' ~~ /(.)$1=$0/; say $1

[21:30] <jnthn> oh, clever.

[21:30] <p6eval> niecza v13-296-g64527c0: OUTPUT«Cursor.new(...)␤»

[21:30] <jnthn> oh, less clever :)

[21:31] <TimToady> niecza: 'aa' ~~ /(.)$<foo>=$0/; say $<foo>

[21:31] <p6eval> niecza v13-296-g64527c0: OUTPUT«Cursor.new(...)␤»

[21:31] <TimToady> hmm

[21:31] <TimToady> buglet of some sort

[21:31] *** pothos left
[21:31] <TimToady> which is, of course, a small bugle

[21:31] *** pothos joined
[21:34] *** pothos left
[21:34] *** pothos joined
[21:35] <PerlJam> while "hamlet" made me think of food, none of the others gave that reaction

[21:37] *** pothos left
[21:37] <TimToady> a pilot is also food

[21:37] *** pothos joined
[21:38] <TimToady> a cutlet, however, is not

[21:39] <colomon> ??

[21:41] *** benabik left
[21:41] *** benabik joined
[21:41] *** benabik left
[21:41] <PerlJam> gives new meaning to the "let" varaibles  :)

[21:41] <PerlJam> s/ai/ia/

[21:47] *** spine left
[21:47] <mj41> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); $a.succ; say $a;

[21:47] <p6eval> rakudo 2fd18f: OUTPUT«Date.new(2011, 1, 1)␤»

[21:50] <jnthn> mj41: .succ is not in place

[21:50] <dalek> nqp: a2b60b7 | jonathan++ | src/QRegex/Cursor.nqp:

[21:50] <dalek> nqp: Prevent a crash when building CAPHASH if one of the cstack entries is there solely for backtracking into rather than serving as a capture.

[21:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a2b60b77da

[21:51] <mj41> jnthn: thx, just found problem is elsewhere

[21:51] <tadzik> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); $a.=succ; say $a

[21:51] <p6eval> rakudo 2fd18f: OUTPUT«Date.new(2011, 1, 2)␤»

[21:51] *** benabik joined
[21:52] <mj41> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); $a += 1; say $a.perl

[21:52] <p6eval> rakudo 2fd18f: OUTPUT«Date.new(2011, 1, 2)␤»

[21:55] <mj41> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); say $a.perl

[21:55] <p6eval> rakudo 2fd18f: OUTPUT«Date.new(2011, 1, 1)␤»

[21:57] *** wooden_ is now known as wooden

[21:57] <jnthn> phenny: ask moritz if he could run a spectest of Rakudo on latest NQP master to see if there's any serious regressions from fixing the backtracking into subrules. (I assume you have ICU, which I don't.)

[21:57] <phenny> jnthn: I'll pass that on when moritz is around.

[21:58] <jnthn> sleep...teaching tomorrow &

[21:58] <mj41> why Date instead of myDate ?

[21:59] <mj41> jnthn: dobrou noc

[21:59] <colomon> rakudo: class myDate is Date { has $.dummy = 1; }; my $a=myDate.new("2011-01-01"); say $a.perl

[21:59] <p6eval> rakudo 2fd18f: OUTPUT«Date.new(2011, 1, 1)␤»

[21:59] <colomon> bug

[22:00] <mj41> jnthn: or 'dobrú noc' in Slovak

[22:00] <PerlJam> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); say $a.WHAT

[22:00] <TimToady> obvioiusly anything named "dummy" isn

[22:00] <p6eval> rakudo 2fd18f: OUTPUT«myDate()␤»

[22:00] <TimToady> isn't really there

[22:01] <colomon> rakudo: class myDate is Date { has $.timtoady = 1; }; my $a=myDate.new("2011-01-01"); say $a.perl

[22:01] <p6eval> rakudo 2fd18f: OUTPUT«Date.new(2011, 1, 1)␤»

[22:01] <colomon> not bug

[22:01] <TimToady> I'm not there either; I'm just here

[22:01] <colomon> mj41 if you don't define a .perl for your class, you get the parent's .perl

[22:02] <TimToady> maybe .perl should be a submethod, and we inherit a reasonable default like .new does

[22:04] <colomon> :\

[22:05] <PerlJam> I guess we could get a reasonable default with sufficient introspection.

[22:06] *** kaare_ left
[22:06] <TimToady> submethod PERL {...}

[22:06] <TimToady> and .perl is more like BUILDALL

[22:06] <mj41> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); my myDate $b = $a; $b += 1;

[22:06] <p6eval> rakudo 2fd18f: OUTPUT«Type check failed in assignment to '$b'; expected 'myDate' but got 'Date'␤  in block <anon> at /tmp/4_R8K2Adj9:1␤  in <anon> at /tmp/4_R8K2Adj9:1␤»

[22:07] <colomon> rakudo: class myDate { has $.member:timtoady = 1; }; my $a=myDate.new("2011-01-01"); say $a.perl

[22:07] <p6eval> rakudo 2fd18f: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:561␤  in block <anon> at /tmp/vlFM1pUrhd:1␤  in <anon> at /tmp/vlFM1pUrhd:1␤»

[22:07] <colomon> rakudo: class myDate { has $.member:timtoady = 1; }; my $a=myDate.new(timtoady => "2011-01-01"); say $a.perl

[22:07] <p6eval> rakudo 2fd18f: OUTPUT«myDate.new(member:timtoady => 1)␤»

[22:07] <mj41> rakudo: class myDate is Date { }; my $a=myDate.new("2011-01-01"); my myDate $b = $a; say $b.WHAT; $b += 1;

[22:07] <p6eval> rakudo 2fd18f: OUTPUT«myDate()␤Type check failed in assignment to '$b'; expected 'myDate' but got 'Date'␤  in block <anon> at /tmp/X2ikut2pcx:1␤  in <anon> at /tmp/X2ikut2pcx:1␤»

[22:08] <colomon> does seem odd that if you don't have a parent, you get a decent .perl for free, but if you do have a parent, you get an incorrect .perl unless you write your own...

[22:11] <TimToady> which is why a .perl override should probably be a PERL submethod

[22:11] <TimToady> it cannot speak for its descendants without a lot of extra work

[22:12] <colomon> +1

[22:13] <TimToady> same for GIST maybe

[22:13] <colomon> what would the default do?

[22:14] <dalek> nqp: c9fd128 | jonathan++ | src/QRegex/Cursor.nqp:

[22:14] <dalek> nqp: Oops, I meant this...

[22:14] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c9fd128ac6

[22:15] <TimToady> something like a .perl wrapper around internal gists, maybe

[22:15] * jnthn was just about to hit the sack when he realized he'd done a silly

[22:15] <jnthn> OK, really bed now

[22:15] <jnthn> dobru noc ;)

[22:16] * TimToady will nap on this a bit hisownself...

[22:23] *** dnewkirk joined
[22:30] *** fridim_ left
[22:31] <colomon> perl6: class Foo is Cool { method Str() { "t"; }; }; my $a = Foo.new; say $a.Foo.IO ~~ :d

[22:31] <p6eval> rakudo 2fd18f: OUTPUT«Method 'Foo' not found for invocant of class 'Foo'␤  in block <anon> at /tmp/UgavqbevJ1:1␤  in <anon> at /tmp/UgavqbevJ1:1␤»

[22:31] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Foo: "&Foo"␤    at /tmp/BJRpjQlbZm line 1, column 68 - line 2, column 1␤»

[22:31] <p6eval> ..niecza v13-296-g64527c0: OUTPUT«Unhandled exception: Unable to resolve method Foo in class Foo␤  at /tmp/kg8NV0OQWy line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3068 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3069 (module-CORE @ 64) ␤  at /home/p…

[22:32] <colomon> perl6: class Foo is Cool { method Str() { "t"; }; }; my $a = Foo.new; say $a.IO ~~ :d

[22:32] <p6eval> pugs b927740: OUTPUT«*** No such method in class Foo: "&IO"␤    at /tmp/o7ld7Eqnza line 1, column 68 - line 2, column 1␤»

[22:32] <p6eval> ..niecza v13-296-g64527c0: OUTPUT«Unhandled exception: Unable to resolve method IO in class Foo␤  at /tmp/ULvA5scUWI line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3068 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3069 (module-CORE @ 64) ␤  at /home/p6…

[22:32] <p6eval> ..rakudo 2fd18f: OUTPUT«Bool::False␤»

[22:32] <colomon> should that work or not?

[22:39] *** lichtkind left
[22:40] <masak> good night, #perl6.

[22:40] <colomon> o/

[22:46] <felher> o/ masak :)

[22:48] *** muixirt left
[22:51] *** mj41 left
[22:52] *** bacek left
[22:52] *** _dbr left
[23:01] *** bacek joined
[23:06] *** whiteknight joined
[23:08] *** fk_ joined
[23:08] *** fk_ left
[23:09] *** donri left
[23:14] *** donaldh joined
[23:18] *** nornagest left
[23:22] *** donaldh left
[23:24] *** overrosy left
[23:26] *** overrosy joined
[23:30] *** benabik left
[23:33] *** tokuhirom joined
[23:39] *** cognominal___ joined
[23:41] *** whiteknight left
[23:41] *** whiteknight joined
[23:42] *** cognominal_ left
[23:58] *** bacek left
[23:58] *** bacek joined
[23:59] *** zjmarlow left
