[00:02] *** fgomez left
[00:05] *** aloha left
[00:06] *** aloha joined
[00:07] *** cognominal joined
[00:07] <dalek> perl6-roast-data: 3301233 | coke++ | / (2 files):

[00:07] <dalek> perl6-roast-data: today (automated commit)

[00:07] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/3301233177

[00:07] <dalek> perl6-roast-data: bbb17a8 | coke++ | / (2 files):

[00:07] <dalek> perl6-roast-data: today (automated commit)

[00:07] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/bbb17a8589

[00:41] *** pecastro left
[00:42] *** sixpairsoffeet joined
[00:44] *** pecastro joined
[00:44] <lichtkind> good night

[00:44] <diakopter> o/

[00:48] *** sixpairsoffeet left
[00:48] *** pecastro left
[00:50] *** pecastro joined
[01:00] <lichtkind> good night

[01:00] <lichtkind> :)

[01:00] *** lichtkind left
[01:09] *** fgomez joined
[01:10] *** anuby joined
[01:17] *** cognominal_ joined
[01:19] *** cognominal left
[01:20] *** hypolin joined
[01:22] *** japhb_ joined
[01:25] <japhb_> A performance weirdness in Rakudo:  'for ^100 X ^100 -> $i, $j { $i + $j }' takes >56x as long as 'for ^100 -> $i { for ^100 -> $j { $i + $j } }'  (In niecza, the difference is around 1.45x.)

[01:25] <japhb_> jnthn: ^^

[01:26] <diakopter> japhb_: what about for ^10000 in the outside and nothing on the inside

[01:27] <diakopter> wait, what's X again

[01:27] <dalek> perl6-bench: 99da16f | (Geoffrey Broadwell)++ | bench:

[01:27] <dalek> perl6-bench: Pull after fetching; for now, this DWIM, but will probably need to be readdressed later.  Also, simply splitting into loops is not trouncing Rakudo bug #115390.  :-(

[01:27] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/99da16f384

[01:27] <dalek> perl6-bench: 846839e | (Geoffrey Broadwell)++ | microbenchmarks.pl:

[01:27] <dalek> perl6-bench: Add more microbenchmarks, this time for multiple ways to visit all indices for a 2D array

[01:27] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/846839eb95

[01:28] *** pecastro left
[01:28] *** pecastro joined
[01:28] <japhb> diakopter, it's not so much X again as not looping over multiple indices.

[01:29] <japhb> Though if you're curious about just hitting the loop body that many times ...

[01:29] <diakopter> what's X again

[01:29] <diakopter> permute?

[01:30] <japhb_> Oh, sorry, I thought you said "that's X again"  :-)

[01:30] <japhb_> cartesian (AKA cross) product

[01:31] <japhb_> time perl6 -e 'for ^100 X ^100 -> $i, $j { }'  ==> ~20s

[01:31] <japhb_> time perl6 -e 'for ^10000 -> $i { }'  ==> ~1s

[01:31] <diakopter> _._.

[01:36] <diakopter> r: my @a = ^100; for (@a X @a) -> $i, $j { }; say 'alive'

[01:36] *** dayangkun joined
[01:36] <p6eval> rakudo 53daef: OUTPUT«alive␤»

[01:36] <diakopter> japhb_: what's that on your machine

[01:37] <japhb_> ~14s

[01:38] <diakopter> hm

[01:41] *** pecastro left
[01:41] <diakopter> the compiler could detect the constant-ness of the sequence and inline a loop

[01:43] <japhb> The thing is, it really doesn't seem like X should be *that* much slower than just a double loop.

[01:44] <japhb_> (And in niecza, it's really not.)

[01:50] *** dayangkun left
[01:52] <japhb> diakopter, also, circling back on the concat v. push/join question: push/join is much faster in niecza, and much slower in Rakudo.

[01:53] <diakopter> :S

[01:53] <japhb> Yeah, don't I know it.

[02:18] *** hypolin left
[02:19] *** FROGGS__ joined
[02:22] *** hypolin joined
[02:22] *** colomon left
[02:22] *** FROGGS_ left
[02:22] *** colomon joined
[02:24] *** colomon_ joined
[02:24] *** colomon left
[02:24] *** colomon_ is now known as colomon

[02:26] <sorear> #116026 is kind of sad

[02:27] <diakopter> the say line?

[02:27] <diakopter> or everything? :)

[02:27] <sorear> no, the "I don't know about Str.flip" part and the "I'm patching one implementation when I really want to patch the spec" part

[02:30] * diakopter sees subname(|) for the first time

[02:42] *** tokuhiro_ left
[02:50] *** hash_table joined
[02:50] *** whiteknight left
[02:56] <colomon> sorear: aye

[03:04] *** noggle_ joined
[03:06] *** noggle left
[03:09] *** hash_table left
[03:11] *** am0c joined
[03:11] *** wamba left
[03:36] *** kurahaupo left
[03:42] *** sftp left
[04:03] *** noggle_ left
[04:11] *** noggle joined
[04:13] *** fgomez left
[04:14] *** Chillance joined
[04:40] *** Patterner left
[04:41] <japhb> How do you set the maximum recursion depth in NQP (and Rakudo and Niecza, for that matter), and what are the default values?

[04:42] *** Psyche^ joined
[04:42] *** Psyche^ is now known as Patterner

[04:42] <japhb> NQP fails man-or-boy-test 10 (and passes 9) because of a low maximum recursion depth

[04:44] <sorear> niecza does not have a maximum recursion depth; I keep meaning to fix this

[04:44] <dalek> perl6-bench: 7cf00e5 | (Geoffrey Broadwell)++ | timeall:

[04:44] <dalek> perl6-bench: Minor whitespace tweak to ease visual comparison

[04:44] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/7cf00e58ca

[04:44] <dalek> perl6-bench: ee77445 | (Geoffrey Broadwell)++ | / (4 files):

[04:44] <dalek> perl6-bench: Add rc-man-or-boy-test

[04:44] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/ee774455c2

[04:44] <japhb> sorear, Ah, interesting

[04:45] <sorear> japhb: infinite recursion on niecza will allocate activation frames continuously until all ram and swap is used up

[04:46] <sorear> a "deep recursion" error would be much more user-friendly

[04:46] <japhb> Sure, of course

[04:47] <sorear> I think you can do pir::getinterp__p().some_method(100000)

[04:47] <sorear> but I forget the details

[04:47] <japhb> FWIW, man-or-boy 9, ignoring startup: nqp: .112s/1.000x    rakudo: .267s/2.380x    niecza:  1.055s/9.411x

[04:47] <japhb> (Using the version of the rc-man-or-boy-test files that I just committed)

[04:48] * japhb wanders off for a while ... will backlog

[05:30] *** telex left
[05:35] *** telex joined
[05:44] *** xinming_ joined
[05:47] *** xinming left
[06:03] *** Chillance left
[06:09] *** SamuraiJack joined
[06:10] *** fgomez joined
[06:20] *** kurahaupo joined
[06:21] *** Kharec joined
[06:22] *** glass joined
[06:49] *** birdwindupbird joined
[06:52] *** quester joined
[06:56] *** wamba joined
[07:16] *** ggoebel_ left
[07:29] *** kaleem joined
[07:33] *** glass left
[07:36] *** glass joined
[07:54] *** glass left
[07:54] *** glass joined
[07:54] *** glass left
[08:03] <FROGGS__> morning

[08:03] *** FROGGS__ is now known as FROGGS

[08:14] <dalek> roast: ac01495 | moritz++ | integration/99problems- (3 files):

[08:14] <dalek> roast: correct some tests in light of lazy "for"

[08:14] <dalek> roast: review: https://github.com/perl6/roast/commit/ac01495ad3

[08:14] *** rindolf joined
[08:16] <rindolf> Hi all.

[08:16] <moritz> hi rindolf.

[08:16] <FROGGS> hi rindolf 

[08:16] <rindolf> moritz, FROGGS : what's up?

[08:17] <FROGGS> well, coffee and a bit $work, thats all

[08:20] <moritz> work, and sink context

[08:21] <jnthn> morning, #perl6

[08:21] <FROGGS> morning jnthn 

[08:21] <jnthn> Snow. We haz it. :)

[08:22] <FROGGS> we have it for days... already built a snowman with my kids

[08:22] <moritz> yesterday we went sledging with $daughter for the first time

[08:22] <jnthn> :D

[08:23] <FROGGS> 'twas a shame that we had no carrot :/

[08:23] <jnthn> Sledging...that was a fun thing to do as a kid :)

[08:24] <moritz> Ronja quite liked it :-)

[08:25] <jnthn> hm, that "make uniq faster" patch also makes it unlazy...

[08:25] <FROGGS> well, it's still fun

[08:26] <moritz> jnthn: aye

[08:26] <jnthn> Though I suspect it can be made faster while still retainign laziness

[08:26] <moritz> jnthn: though maybe using grep instead of gather/take would both speed it up and keep it lazy

[08:26] <jnthn> also...it should be using an object hash

[08:26] <tadzik> 0925        jnthn | hm, that "make uniq faster" patch also makes it unlazy...

[08:26] <tadzik> 0925       FROGGS | well, it's still fun

[08:26] <tadzik> heh

[08:26] <jnthn> :D

[08:26] <tadzik> good morning, #perl6 :)

[08:26] <moritz> \o tadzik 

[08:26] <jnthn> hi tadzik 

[08:26] <tadzik> Finally, Monday!

[08:26] <tadzik>   -- said no one ever

[08:27] <jnthn> Worse, at this time of year it's dark outside when you're meant to get up

[08:28] <tadzik> yeah, the worst part of the year, when you only see the sun through the office window

[08:28] <FROGGS> morning tadzik 

[08:28] <tadzik> waking up, dark. Getting back home, dark

[08:28] <tadzik> hi FROGGS 

[08:29] <FROGGS> ya, dark--

[08:29] *** pecastro joined
[08:29] <sorear> morning folks

[08:29] <FROGGS> morning sorear 

[08:29] <FROGGS> wow, getting full here

[08:30] <sorear> is somebody going to respond to #116026?  it's too depressing for me

[08:30] <sorear> FROGGS: full in what sense?

[08:30] * FROGGS gets some more chairs

[08:30] <FROGGS> many ppl

[08:30] <sorear> #perl6?

[08:30] <jnthn> sorear: Hey, don't flip out... :P

[08:30] <FROGGS> many talking ppl to be more specific

[08:30] <jnthn> sorear: I will this evening if nobody beats me to it.

[08:31] <moritz> sorear: I've already replied, and rejected the ticket d

[08:31] <jnthn> moritz++

[08:31] <moritz> nr: say try { die "foo" }

[08:31] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Any()␤»

[08:31] <p6eval> ..rakudo 53daef: OUTPUT«foo␤  in block  at /tmp/YOjTt0XJQX:1␤␤»

[08:31] <rindolf> jnthn: morning.

[08:31] <moritz> jnthn: how do I change try to return Nil (or Any) instead of the exception on failure?

[08:32] <sorear> moritz: your reply never reached p6c

[08:32] <moritz> sorear: that's unfortunate

[08:33] <moritz> 7 remaining failing test files in qast-sink-1

[08:34] <jnthn> moritz: Something in statement_thingy:sym<try>

[08:35] <jnthn> I think in the CATCH part of the handle node in there

[08:37] *** cognominal_ left
[08:37] *** am0c left
[08:37] <moritz> I'll try

[08:38] <hoelzro> hey Perl 6 folk

[08:39] <FROGGS> hi hoelzro 

[08:39] <hoelzro> I was reading the compiler overview in the the rakudo tree, and I found a reference to http://use.perl.org/~JonathanWorthington/journal/39772

[08:39] <hoelzro> afaik, use.perl.org is no longer up, yes?

[08:41] <hoelzro> because a) the URL should probably be moved to another copy of that article, and b) I'd really like to read that article =)

[08:42] <moritz> iirc there's a way to mnagle the URL to still work, and recover the article that way

[08:42] <moritz> but I can't remember how :(

[08:43] <hoelzro> curses

[08:43] <hoelzro> there really should be a no-brainer mirror to that content, though

[08:43] <cedrvint> hoelzro: http://use.perl.org/use.perl.org/_JonathanWorthington/journal/39772.html

[08:43] <hoelzro> cedrvint: thanks!

[08:44] <arnsholt> Greetings from Mumbai! o/

[08:46] <jnthn> o/ arnsholt 

[08:46] *** pecastro left
[08:46] <jnthn> Bet you don't have snow there :P

[08:47] <arnsholt> Thankfully!

[08:47] *** cognominal_ joined
[08:52] *** sisar joined
[08:54] <moritz> jnthn: it's not that easy, it seems (returning Nil from try)

[08:57] *** noggle left
[09:01] *** [particle]1 left
[09:02] *** [particle] joined
[09:12] *** noggle joined
[09:15] <moritz> oh, I think it is, I was just too dumb :-)

[09:16] <moritz> appending a value to a Past::Stmts doesn't change the return value if :resultchild(0) is present :-)

[09:17] *** kaleem left
[09:18] *** quester left
[09:30] *** fhelmberger joined
[09:31] <dalek> rakudo/qast-origin-1: f5a8f2b | moritz++ | src/core/traits.pm:

[09:31] <dalek> rakudo/qast-origin-1: fix "handles"

[09:31] <dalek> rakudo/qast-origin-1: 

[09:31] <dalek> rakudo/qast-origin-1: this actually points to a bug in sinking some statements which needs

[09:31] <dalek> rakudo/qast-origin-1: to be tracked down separately

[09:31] <dalek> rakudo/qast-origin-1: review: https://github.com/rakudo/rakudo/commit/f5a8f2bac2

[09:31] <dalek> rakudo/qast-origin-1: 9831e45 | moritz++ | src/Perl6/Actions.pm:

[09:31] <dalek> rakudo/qast-origin-1: return Nil from a try when an error was thrown

[09:31] <dalek> rakudo/qast-origin-1: review: https://github.com/rakudo/rakudo/commit/9831e4543f

[09:33] <jnthn> That must get us down to very few failures?

[09:34] <dalek> roast: 42d1a93 | moritz++ | S29-context/die.t:

[09:34] <dalek> roast: [die.t] do not return a lazy list that dies when we really want to die right away

[09:34] <dalek> roast: review: https://github.com/perl6/roast/commit/42d1a93a47

[09:34] *** wamba left
[09:34] <moritz> jnthn: curiously enough the return value from try wasn't the problem

[09:34] <moritz> (sunk exceptions generally aren't, just sunk Failures)

[09:34] <moritz> the code was more like

[09:35] <moritz> is try { map { die }, 1, 2, 3}, ....

[09:35] <jnthn> ah

[09:35] <moritz> so the lazy list passed through the try

[09:35] <moritz> and then died outside of it

[09:35] <moritz> this will surprise people.

[09:35] <jnthn> yeah

[09:35] * moritz runs another spectest

[09:35] <jnthn> A few things about sink context will.

[09:41] <moritz> down to 6 failing test files

[09:42] <hoelzro> total?

[09:42] <moritz> what total?

[09:42] <moritz> seems I haven't quite fixed delegation after all :(

[09:42] <hoelzro> 6 failing tests in total?

[09:43] <moritz> 6 failing test files in total

[09:43] <hoelzro> is that just in the Rakudo tree, or roast too?

[09:43] <moritz> just roast

[09:43] <moritz> I haven't checked the local tests yet

[09:43] <moritz> I always forget about those :-)

[09:43] <hoelzro> ;)

[09:43] <hoelzro> moritz: is that with fudging off?

[09:44] <moritz> hoelzro: no

[09:44] <hoelzro> ah =(

[09:44] <hoelzro> I was about to freak out at how close you were =)

[09:45] <felher> jnthn++ # I didn't know that you can put one heredoc after another, and even call different methods on them. :)

[09:47] <jnthn> :)

[09:48] <moritz> hoelzro: this is about a branch reaching the same readiness as our main branch

[09:48] <jnthn> moritz: It would be a near miracle to pass almost all of spectest with failing make test ;)

[09:48] <hoelzro> moritz: \o/ which branch?

[09:48] <hoelzro> macros?

[09:48] <moritz> hoelzro: qast-sink-q

[09:48] <moritz> erm

[09:48] <moritz> qast-sink-1

[09:48] <hoelzro> ah ha

[09:51] *** noggle left
[09:57] *** kurahaupo left
[09:57] *** noggle joined
[10:02] *** dakkar joined
[10:06] *** hypolin left
[10:07] *** Kharec left
[10:14] *** wamba joined
[10:17] *** Kharec joined
[10:21] *** SmokeMachine joined
[10:21] *** SmokeMachine left
[10:21] *** SmokeMachine joined
[10:26] *** baest_ joined
[10:26] *** SmokeMachine left
[10:26] *** immortal joined
[10:26] *** immortal left
[10:26] *** immortal joined
[10:27] <moritz> r: say do given 42 { when Int { 23 } }

[10:27] <p6eval> rakudo 53daef: OUTPUT«23␤»

[10:27] *** wooden_ joined
[10:27] *** wooden_ left
[10:27] *** wooden_ joined
[10:29] *** mikemol_ joined
[10:29] *** breinbaa1 joined
[10:29] *** huf_ joined
[10:29] *** cxreg2 joined
[10:29] *** PerlPilot joined
[10:32] <dalek> roast: 4677a6f | moritz++ | S04-phasers/next.t:

[10:32] <dalek> roast: make S04-phasers/next.t robuster wrt laziness

[10:32] <dalek> roast: review: https://github.com/perl6/roast/commit/4677a6f398

[10:33] *** Some-body_ joined
[10:34] *** wamba left
[10:34] *** countley left
[10:34] *** erkan left
[10:34] *** wooden left
[10:34] *** mikemol left
[10:34] *** cxreg left
[10:34] *** Some-body_ is now known as DarthGandalf

[10:35] *** [particle] left
[10:36] *** [particle] joined
[10:40] *** BinGOs joined
[10:42] *** wamba joined
[10:48] *** sisar left
[10:49] *** BinGOs left
[10:49] *** BinGOs joined
[10:50] <dalek> rakudo/qast-origin-1: c02d13a | moritz++ | src/core/ (2 files):

[10:50] <dalek> rakudo/qast-origin-1: fix more built-ins to deal with sink context

[10:50] <dalek> rakudo/qast-origin-1: review: https://github.com/rakudo/rakudo/commit/c02d13aedc

[10:50] <moritz> jnthn: a tricky one remains: the CATCH block isn't evaluated in sink context

[10:51] <moritz> oh, just tricky because I'm loooking at the wrong piece of code

[10:51] *** baest_ is now known as baest

[10:51] * moritz tries another approach

[10:52] *** xenoterracide left
[10:57] *** SmokeMachine joined
[10:57] <moritz> I guess set_block_handler needs a :sink option or so

[10:58] <jnthn> When do we not want it to sink?

[10:58] *** SmokeMachine left
[10:59] <moritz> good question

[10:59] <moritz> are there any handlers that modify the return value?

[11:01] * moritz tries perl6_invoke_catchhandler__vPP, starts a spectest run and departs for lunch&

[11:01] *** BinGOs_ joined
[11:04] *** BinGOs left
[11:04] *** BinGOs_ is now known as BinGOs

[11:04] *** SmokeMachine joined
[11:05] *** BinGOs left
[11:05] *** BinGOs joined
[11:05] *** Su-Shee_ joined
[11:08] <grondilu> rn:  given "foo" { s/foo/bar; .say }  # testing if 'given' affects $_ as rw 

[11:08] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed replacement part; couldn't find final $stop␤at /tmp/CttKUcAxSs:1␤------> [32m}  # testing if 'given' affects $_ as rw[33m⏏[31m<EOL>[0m␤»

[11:08] <p6eval> ..niecza v24-5-g599cbcb: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Malformed replacement part; couldn't find final / at /tmp/0fOC3R2dOx line 1:␤------> [32mgiven "foo" { s/foo/[33m⏏[31mbar; .say }  # testing if 'given' affect[0m␤␤Parse failed␤␤»

[11:08] <grondilu> rn:  given "foo" { s/foo/bar/; .say }  # testing if 'given' affects $_ as rw 

[11:08] <p6eval> rakudo 53daef: OUTPUT«Cannot assign to a non-container␤  in sub infix:<=> at src/gen/CORE.setting:11971␤  in block  at /tmp/TT1mgWqMgy:1␤␤»

[11:08] <p6eval> ..niecza v24-5-g599cbcb: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /home/p6eval/niecza/lib/CORE.setting line 593 (Cool.subst @ 88) ␤  at /tmp/ar_B1uaR6W line 1 (ANON @ 4) ␤  at /tmp/ar_B1uaR6W line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4208 (AN…

[11:09] *** Su-Shee left
[11:10] <grondilu> do I have to write '$_ = "foo"; ..." if I want to modify $_ ?

[11:13] <Ulti> r: "foo"; say $_;

[11:13] <p6eval> rakudo 53daef: OUTPUT«Any()␤»

[11:13] <Ulti> :/

[11:16] *** anuby left
[11:16] *** amkrankruleuen joined
[11:36] <moritz> grondilu: yes

[11:36] <moritz> or anything else that creates a variable

[11:36] <moritz> r: givem my $ = 'abc' { s/a/A/; .say }

[11:36] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/bShMMK8KWC:1␤------> [32mgivem my $ = 'abc' [33m⏏[31m{ s/a/A/; .say }[0m␤»

[11:36] <moritz> r: givem  (my $ = 'abc') { s/a/A/; .say }

[11:36] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/Ll53FOy9pf:1␤------> [32mgivem  (my $ = 'abc') [33m⏏[31m{ s/a/A/; .say }[0m␤»

[11:37] <moritz> r: given my $ = 'abc' { s/a/A/; .say }

[11:37] <p6eval> rakudo 53daef: OUTPUT«Abc␤»

[11:37] <moritz> helps if I spell 'given' correctly :-)

[11:41] *** tokuhiro_ joined
[11:42] *** noggle left
[11:45] *** tokuhiro_ left
[11:49] *** FROGGS left
[11:49] *** GlitchMr joined
[11:53] *** amkrankr1leuen joined
[11:54] *** sftp joined
[11:56] *** amkrankruleuen left
[11:59] *** amkrankr1leuen is now known as amkrankruleuen

[11:59] *** amkrankruleuen left
[11:59] *** amkrankruleuen joined
[12:08] *** amkrankruleuen left
[12:08] <jnthn> r: given "foo" -> $_ is copy { s/o/O/; .say } 

[12:08] <p6eval> rakudo 53daef: OUTPUT«fOo␤»

[12:09] <grondilu> 'given my $ = Whatever {...}' will do, I guess

[12:15] *** cognominal_ left
[12:15] <dalek> rakudo/qast-sink-1: f5a8f2b | moritz++ | src/core/traits.pm:

[12:15] <dalek> rakudo/qast-sink-1: fix "handles"

[12:15] <dalek> rakudo/qast-sink-1: 

[12:15] <dalek> rakudo/qast-sink-1: this actually points to a bug in sinking some statements which needs

[12:15] <dalek> rakudo/qast-sink-1: to be tracked down separately

[12:15] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/f5a8f2bac2

[12:15] <dalek> rakudo/qast-sink-1: 9831e45 | moritz++ | src/Perl6/Actions.pm:

[12:15] <dalek> rakudo/qast-sink-1: return Nil from a try when an error was thrown

[12:15] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/9831e4543f

[12:15] <dalek> rakudo/qast-sink-1: c02d13a | moritz++ | src/core/ (2 files):

[12:15] <dalek> rakudo/qast-sink-1: fix more built-ins to deal with sink context

[12:15] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/c02d13aedc

[12:16] <moritz> I accidentally pushed to the wrong branch before; sorry for duplicate commits

[12:22] *** cognominal_ joined
[12:39] * timotimo forces emself to do more perl6

[12:41] *** cognominal_ left
[12:43] <timotimo> currently trying to make a histogram of characters in a string

[12:43] <timotimo> classify seemed the way to go, but the result was kind of ugly

[12:44] <moritz> how so?

[12:45] *** cognominal joined
[12:45] <moritz> r: say 'this is a longish string'.comb.classify({; $_ => 1 } ).pairs.map({; .key => .value.elems }).perl

[12:45] <p6eval> rakudo 53daef: OUTPUT«("t\t1" => 2, "h\t1" => 2, "i\t1" => 4, "s\t1" => 4, " \t1" => 4, "a\t1" => 1, "l\t1" => 1, "o\t1" => 1, "n\t1" => 2, "g\t1" => 2, "r\t1" => 1).list␤»

[12:45] <timotimo> that's a bit prettier than mine:

[12:45] <timotimo> "8438947349873498574398".comb.classify({$_}).map: { $^a.key => +$^a.value }

[12:45] <timotimo> r: "8438947349873498574398".comb.classify({$_}).map: { $^a.key => +$^a.value }

[12:45] <p6eval> rakudo 53daef:  ( no output )

[12:45] <timotimo> r: "8438947349873498574398".comb.classify({$_}).map: { $^a.key => +$^a.value }.perl.say

[12:45] <p6eval> rakudo 53daef: OUTPUT«Block.new()␤»

[12:46] <timotimo> oh, whoops :)

[12:46] <timotimo> r: "8438947349873498574398".comb.classify({$_}).map({ $^a.key => +$^a.value }).perl.say

[12:46] <p6eval> rakudo 53daef: OUTPUT«("8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1).list␤»

[12:46] <moritz> actually yours works :-)

[12:46] <moritz> though of course you can just use a hash and ++ each element per character

[12:46] <timotimo> what's the ; for in your map block? forces it to be a block rather than being evaluated on the spot?

[12:47] <timotimo> i tried that as a second option

[12:47] <moritz> right

[12:47] <timotimo> r: "8438947349873498574398".comb.map({$_ => ++(state %a){$_}}).perl

[12:47] <p6eval> rakudo 53daef:  ( no output )

[12:47] <timotimo> but didn't quite know how to get the %a out of there afterwards

[12:47] <timotimo> r: "8438947349873498574398".comb.map({$_ => ++(state %a){$_}}).perl.say

[12:47] <p6eval> rakudo 53daef: OUTPUT«("8" => 1, "4" => 1, "3" => 1, "8" => 2, "9" => 1, "4" => 2, "7" => 1, "3" => 2, "4" => 3, "9" => 2, "8" => 3, "7" => 2, "3" => 3, "4" => 4, "9" => 3, "8" => 4, "5" => 1, "7" => 3, "4" => 5, "3" => 4, "9" => 4, "8" => 5).list␤»

[12:47] <timotimo> currently it's like a triangle reduce

[12:48] <timotimo> except in a triangle reduce i could get out the last result and that would be the one i would want - in this case if i try that i get one pair rather than a complete hash

[12:49] <moritz> r: my %count; ++%count{$_} for '8438947349873498574398'.comb; say %count.perl

[12:49] <p6eval> rakudo 53daef: OUTPUT«("8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1).hash␤»

[12:49] <timotimo> that's not a true one-liner :D

[12:49] <moritz> good old imperative, easy-to-get-right code

[12:49] <timotimo> i've got a very silly idea that i'm going to try involving horrible abuse of hyperops

[12:49] <moritz> r: say (do {my %count; ++%count{$_} for '8438947349873498574398'.comb; }).perl

[12:49] <p6eval> rakudo 53daef: OUTPUT«(1, 1, 1, 2, 1, 2, 1, 2, 3, 2, 3, 2, 3, 4, 3, 4, 1, 3, 5, 4, 4, 5).list␤»

[12:50] <moritz> r: say (do {my %count; ++%count{$_} for '8438947349873498574398'.comb; }; %count).perl

[12:50] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable %count is not declared␤at /tmp/7BKW7Xa2AT:1␤------> [32m'8438947349873498574398'.comb; }; %count[33m⏏[31m).perl[0m␤»

[12:50] <moritz> r: say (do {my %count; ++%count{$_} for '8438947349873498574398'.comb;  %count}).perl

[12:50] <p6eval> rakudo 53daef: OUTPUT«("8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1).hash␤»

[12:50] <moritz> there you go.

[12:50] <timotimo> so "do" is actually short for "do_it_in_one_statement"?

[12:52] <moritz> "do" means "turn this statement or expression into an expression, and call it if it's a block"

[12:57] <timotimo> how come this works:

[12:57] <timotimo> r: ("8438947349873498574398".comb »Z=>» (1,)).perl.say

[12:57] <p6eval> rakudo 53daef: OUTPUT«("8" => 1, "4" => 1, "3" => 1, "8" => 1, "9" => 1, "4" => 1, "7" => 1, "3" => 1, "4" => 1, "9" => 1, "8" => 1, "7" => 1, "3" => 1, "4" => 1, "9" => 1, "8" => 1, "5" => 1, "7" => 1, "4" => 1, "3" => 1, "9" => 1, "8" => 1).list␤»

[12:57] <timotimo> but this doesn't:

[12:58] <timotimo> r: ("8438947349873498574398".comb »Z=>» ((state %h),)).perl

[12:58] <p6eval> rakudo 53daef: OUTPUT«(timeout)»

[12:58] <moritz> I wouldn't call the first one "working"

[12:59] <timotimo> 1 is just a dummy value in this case

[12:59] <timotimo> i want to try to have the same hash as the value for each of the keys in the resulting list

[12:59] <moritz> anyway, I don't even see what the second one is supposed to do

[12:59] <timotimo> so ("8" => %h, "4" => %h, ...).list

[12:59] <moritz> but you don't ever change %h

[12:59] <timotimo> not yet :)

[12:59] <moritz> ah

[13:00] <moritz> r: say ("8438947349873498574398".comb X=> ((state %h),)).perl

[13:00] <p6eval> rakudo 53daef: OUTPUT«().list␤»

[13:00] <moritz> r: say ("8438947349873498574398".comb X=> (state %h).item).perl

[13:00] <p6eval> rakudo 53daef: OUTPUT«().list␤»

[13:00] <timotimo> is it because %h is empty and the X op tries to unpack it?

[13:00] <moritz> I think so, yes

[13:00] <moritz> r: say ("8438947349873498574398".comb X=> {}).perl

[13:00] <p6eval> rakudo 53daef: OUTPUT«().list␤»

[13:00] <moritz> r: say ("8438947349873498574398".comb X=> Any).perl

[13:00] <p6eval> rakudo 53daef: OUTPUT«("8" => Any, "4" => Any, "3" => Any, "8" => Any, "9" => Any, "4" => Any, "7" => Any, "3" => Any, "4" => Any, "9" => Any, "8" => Any, "7" => Any, "3" => Any, "4" => Any, "9" => Any, "8" => Any, "5" => Any, "7" => Any, "4" => Any, "3" => Any, "9" => Any, "8" => Any).…

[13:01] <moritz> it probably should respect its itemness, but doesn't

[13:01] <timotimo> mhm

[13:01] <moritz> r: say ("8438947349873498574398".comb X=> []).perl

[13:01] <p6eval> rakudo 53daef: OUTPUT«().list␤»

[13:01] <moritz> same problem here

[13:01] <timotimo> i think i've got a workaround

[13:02] <timotimo> now to figure out which way i want the dwim to point

[13:02] <timotimo> oh, X=> solves it nicer than Z=> + dwim

[13:02] <timotimo> r: ("8438947349873498574398".comb X=> ((state %h,).tree)).perl.say

[13:02] <p6eval> rakudo 53daef: OUTPUT«("8" => {}, "4" => {}, "3" => {}, "8" => {}, "9" => {}, "4" => {}, "7" => {}, "3" => {}, "4" => {}, "9" => {}, "8" => {}, "7" => {}, "3" => {}, "4" => {}, "9" => {}, "8" => {}, "5" => {}, "7" => {}, "4" => {}, "3" => {}, "9" => {}, "8" => {}).list␤»

[13:04] <timotimo> r: ("8438947349873498574398".comb X=> ((state %h,).tree)).map({.value{.key}++; .value}).perl.say # i think this gives me a list of the hash multiple times

[13:04] <p6eval> rakudo 53daef: OUTPUT«({"8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1}, {"8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1}, {"8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1}, {"8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1}, {"8" => 5, "4" =…

[13:05] <timotimo> r: ("8438947349873498574398".comb X=> ((state %h,).tree)).map({.value{.key}++; .value})[*-1]

[13:05] <p6eval> rakudo 53daef:  ( no output )

[13:05] <timotimo> r: ("8438947349873498574398".comb X=> ((state %h,).tree)).map({.value{.key}++; .value})[*-1].perl.say

[13:05] <p6eval> rakudo 53daef: OUTPUT«{"8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1}␤»

[13:05] <timotimo> what i don't understand yet is this:

[13:05] <timotimo> r: ("8438947349873498574398".comb X=> ((state %h,).tree)).map({.value{.key}++; .value})[0].perl.say

[13:05] <p6eval> rakudo 53daef: OUTPUT«{"8" => 1}␤»

[13:06] <moritz> r: my %a = a => 1, b => 2; say %a[0]

[13:06] <p6eval> rakudo 53daef: OUTPUT«("a" => 1, "b" => 2).hash␤»

[13:06] <moritz> r: my %a = a => 1, b => 2; say %a[1]

[13:06] <p6eval> rakudo 53daef: OUTPUT«Index out of range. Is: 1, should be in 0..0␤  in method gist at src/gen/CORE.setting:10189␤  in sub say at src/gen/CORE.setting:7474␤  in block  at /tmp/pkT761oYpB:1␤␤»

[13:06] <moritz> r: my %a = a => 1, b => 2; say %a.list[0]

[13:06] <p6eval> rakudo 53daef: OUTPUT«"a" => 1␤»

[13:06] <moritz> I guess something in there flattens

[13:07] <timotimo> that could be, yes

[13:11] *** [particle] left
[13:12] *** [particle] joined
[13:13] <timotimo> r: ("8438947349873498574398".comb X=> ((state %h,).tree)).map({.value{.key}++; .value}).hash[0].perl.say

[13:13] <p6eval> rakudo 53daef: OUTPUT«("8" => 5, "4" => 5, "3" => 4, "9" => 4, "7" => 3, "5" => 1).hash␤»

[13:13] <timotimo> that doesn't make sense to me, either.

[13:16] <timotimo> the community of perl6 could initiate the Unintentional Code Obfuscation Contest 2013 :D

[13:16] <timotimo> (not saying this task couldn't be done in a very transparent, readable and obvious way, because i'm sure it can. with ease, too)

[13:16] *** SamuraiJack_ joined
[13:17] *** SamuraiJack left
[13:18] <timotimo> moritz: so, was the thing where Z=> or X=> wouldn't respect the itemness even if .item was called, a rakudobug? i'll check what niecza has to say.

[13:18] <timotimo> n: say ("8438947349873498574398".comb X=> (state %h).item).perl

[13:18] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Potential difficulties:␤  %h is declared but not used at /tmp/pS34JeHBKf line 1:␤------> [32m8438947349873498574398".comb X=> (state [33m⏏[31m%h).item).perl[0m␤␤("8" => {}, "4" => {}, "3" => {}, "8" => {}, "9" => {}, "4" => {}, "7" => {}, "3" => {}, "4"…

[13:19] <timotimo> there we have our answer, i guess!

[13:19] <timotimo> rn: say ("8438947349873498574398".comb X=> (state %h,)).perl

[13:19] <p6eval> rakudo 53daef: OUTPUT«().list␤»

[13:19] <p6eval> ..niecza v24-5-g599cbcb: OUTPUT«Potential difficulties:␤  %h is declared but not used at /tmp/6PcVs5UQVr line 1:␤------> [32m8438947349873498574398".comb X=> (state [33m⏏[31m%h,)).perl[0m␤␤().list␤»

[13:19] <moritz> timotimo: yes, it's a bug

[13:19] <timotimo> would you like to file it?

[13:20] <moritz> I can

[13:20] <moritz> nr: say <a b> X=> [];

[13:20] <p6eval> niecza v24-5-g599cbcb: OUTPUT«"a" => [] "b" => []␤»

[13:20] <p6eval> ..rakudo 53daef: OUTPUT«␤»

[13:21] <moritz> (just a minimal test case for the ticket)

[13:21] <timotimo> only if you have time left over that you don't know what to do with :P

[13:21] *** kivutar joined
[13:21] <timotimo> otherwise i can do it

[13:21] <moritz> nr: say <a b> Z=> [];

[13:21] <p6eval> niecza v24-5-g599cbcb: OUTPUT«"a" => []␤»

[13:21] <p6eval> ..rakudo 53daef: OUTPUT«␤»

[13:23] <moritz> submitted.

[13:23] <timotimo> thank you

[13:23] <timotimo> pugs: say <a b> Z=> [];

[13:23] <p6eval> pugs: OUTPUT«*** ␤    Unexpected ">"␤    at /tmp/WDCS9Ud0v7 line 1, column 13␤»

[13:23] *** SamuraiJack_ left
[13:24] <moritz> Z as metaop is way younger than pugs' last features

[13:24] <timotimo> OK

[13:24] <timotimo> n: say <a b> X=> [state %h]

[13:25] <p6eval> niecza v24-5-g599cbcb: OUTPUT«Potential difficulties:␤  %h is declared but not used at /tmp/QIoIHLEoOK line 1:␤------> [32msay <a b> X=> [state [33m⏏[31m%h][0m␤␤"a" => [] "b" => []␤»

[13:25] <tadzik> masak: http://oxforddictionaries.com/definition/english/grandiloquent autopun? :)

[13:25] <tadzik> grandiloquent (adj.) – pompous or extravagant in language, style, or manner

[13:26] <moritz> nice one, tadzik++

[13:26] <tadzik> robertj++ actually (https://twitter.com/robertjacobsen/status/278093159181979649)

[13:27] <moritz> r: https://gist.github.com/4250553

[13:27] <p6eval> rakudo 53daef: OUTPUT«("A", "B", "Z", "-").list␤("a", "b", "c", "_").list␤»

[13:28] <moritz> for some reason that produces   ("Z", "-", "A", "B").list␤("_", "a", "b", "c").list("_", "a", "b", "c").list␤ in the qast-sink-1 branch

[13:29] <timotimo> is there a \n missing in your last line, moritz?

[13:29] <timotimo> r: ("_", "a", "b", "c").list("_", "a", "b", "c").say

[13:29] <p6eval> rakudo 53daef: OUTPUT«Too many positional parameters passed; got 5 but expected 1␤  in method list at src/gen/CORE.setting:5023␤  in block  at /tmp/luNLRme_Zy:1␤␤»

[13:29] <timotimo> r: ("_", "a", "b", "c").list(("_", "a", "b", "c")).say

[13:29] <p6eval> rakudo 53daef: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in method list at src/gen/CORE.setting:5023␤  in block  at /tmp/8bnLviawJx:1␤␤»

[13:29] <timotimo> ah, the implicit self, i suppose?

[13:30] <moritz> timotimo: there's a ␤

[13:31] <timotimo> i see two, i believe there should be three

[13:31] <moritz> anyway, the amount of newlines isn't the issue here

[13:31] <moritz> that might be copy&paste gone wrong

[13:31] <timotimo> of course :)

[13:32] <moritz> rather the order of returned values

[13:32] <timotimo> oh, now i see it

[13:32] <timotimo> i thought the mistake was that it somehow returns three lists for two walls and was very surprised

[13:35] *** Kharec left
[13:36] *** breinbaa1 left
[13:36] <[Coke]> moritz: when rejecting/responding to tickets, I find it helpful to reply to the list also. Did you intentionally not reply to list on 116026?

[13:37] *** breinbaas joined
[13:39] <moritz> [Coke]: no; I simply though that when I hit "reply", it includes everybody who's relevant

[13:39] <[Coke]> yes, for RT's definition.

[13:39] *** brrt joined
[13:40] <timotimo> is there a possibility to get proper perl6 syntax highlighting up on github? how about better support for rendering the POD that's used for the perl6book?

[13:40] <[Coke]> you must check the "cc" box, or it doesn't get cc'd to the list. (despite the fact that the initial bug report is always sent to the list.)

[13:40] *** wamba left
[13:41] <moritz> heh, I have a another autopun, from an internal software release:

[13:41] <moritz>    * #13332033: Encoding-Fixes fÃ¼r Wheezy

[13:42] *** dalek left
[13:42] <moritz> timotimo: you probably "just" have to patch whatever syntax hilighter github uses to support Perl 6

[13:42] *** dalek joined
[13:42] *** ChanServ sets mode: +v dalek

[13:43] <hoelzro> I was thinking of patching it a while ago

[13:43] <hoelzro> not enough tuits =(

[13:43] <hoelzro> timotimo: if you want to patch it, it's called linguist, iirc

[13:44] <timotimo> it's probably ruby software?

[13:44] <hoelzro> looks like

[13:44] <timotimo> triage mode engaged: https://rt.perl.org/rt3/Public/Bug/Display.html?id=71356 - this bug seems resolved. can be closed.

[13:45] <hoelzro> oh, interesting.

[13:45] <hoelzro> linguist is just the language detection framework

[13:45] <moritz> rakudo: class A { has $!b is readonly = "foo"; method b { say $!b } }; A.new.b

[13:45] <p6eval> rakudo 53daef: OUTPUT«foo␤»

[13:45] <[Coke]> timotimo: are there tests?

[13:45] <hoelzro> it actually uses pygments under the hood for the coloring

[13:46] <moritz> rakudo: class A { has $!b is readonly = "foo"; method b { say $!b }; method set-b { $!b = 'blubb' } }; give A.new { .set-b; say .b }

[13:46] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/8EMEuQyTiD:1␤------> [32md set-b { $!b = 'blubb' } }; give A.new [33m⏏[31m{ .set-b; say .b }[0m␤»

[13:46] <timotimo> [Coke]: doesn't seem so. are tests required for each bug to be closed? that would probably be a good thing so do.

[13:46] <moritz> timotimo: yes, we do require tests

[13:46] <[Coke]> for testable things, aye.

[13:46] <timotimo> ok, sure. they go into roast, right?

[13:46] <moritz> right

[13:47] <timotimo> i'll see if i can add a test :)

[13:47] <[Coke]> we can mark that one testneeded, though.

[13:47] <[Coke]> timotimo: ok - then add a pointer to the test in a comment on the ticket, and we can close it out.

[13:48] <timotimo> should the test refer to the bug number, too?

[13:48] *** skids left
[13:48] <moritz> yes, in a comment

[13:49] <timotimo> i'll get started then :)

[13:49] <[Coke]> awesome.

[13:49] <[Coke]> timotimo: do you have an RT id?

[13:50] <timotimo> i don't think i do yet. do i just sugn up for a bitcard?

[13:52] *** colomon left
[13:53] <[Coke]> ... probably? It's been 10 years, I unno. :)

[13:54] <moritz> timotimo: I think so, yes

[13:56] <timotimo> good, i'm in now

[13:56] <moritz> timotimo: what's your RT id?

[13:57] <dalek> rakudo/qast-sink-1: cd1ab4c | moritz++ | src/core/Str.pm:

[13:57] <dalek> rakudo/qast-sink-1: work around a sink bug

[13:57] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/cd1ab4ca46

[13:57] *** brrt left
[13:57] <timotimo> is it the one on the top right where it says "logged in as timo"?

[13:57] *** Su-Shee_ is now known as Su-Shee

[13:57] <moritz> right

[13:58] <moritz> [Coke]: can you make timo a bug admin please?

[13:58] <timotimo> whoa!

[13:58] *** atrodo_ joined
[13:59] <diakopter> hm, 3 not-quite-spam emails today saying "2 days left"

[14:00] <timotimo> huh? isn't the world going to end on the 22nd?

[14:00] *** atrodo left
[14:00] *** atrodo_ is now known as atrodo

[14:01] *** atrodo left
[14:01] *** atrodo joined
[14:02] *** PacoAir joined
[14:05] <moritz> jnthn: I can't seem to find out how to sink CATCH (and similar) blocks.. HALP PLZ!

[14:05] <timotimo> oh. well, is readonly works as in "can be written and won't crash", but the variable isn't actually readonly

[14:05] <timotimo> well, at least i can write tests.

[14:06] <moritz> timotimo: that's what I feared

[14:06] <timotimo> tests will reveal all.

[14:06] *** am0c joined
[14:07] <moritz> all hail the tests!

[14:07] <timotimo> the tests shall test your faith. do not falter!

[14:08] <timotimo> i'm considering modifying Configure.pl so that checking out parrot and nqp won't give a big "oh god oh no no no no detached head oh god what am i gonna do? what are YOU gonna do? we're doomed!" message

[14:09] <moritz> timotimo: but please only do that if the last commit in the branch is the same revision as the requested revision

[14:09] <diakopter> speaking of which.. is there a way to make nqp --gen-parrot clone parrot with none of the .git history?

[14:09] <moritz> otherwise you won't get the right revision

[14:09] <moritz> diakopter: no

[14:09] <timotimo> yes, of course. i was going to add branches that tell you "required by perl6 version uiaeo" and checking those out

[14:09] <diakopter> <sad>

[14:09] <Woodi> hallo today

[14:10] <moritz> timotimo: that doesn't seem too helpful

[14:10] <timotimo> if it's not, i'm going to leave it be

[14:10] <moritz> timotimo: instead of getting a warning about a detached head, you'll get commits to a branch that nobody cares about

[14:10] <moritz> and is stuck on 'git pull' without a good error message

[14:10] <timotimo> oh, hadn't thought of that properly.

[14:11] <timotimo> then a tag would be more appropriate?

[14:11] <diakopter> moritz: I guess I was more asking "is there a way to do that in git" (clone a particular revision without history)

[14:11] <moritz> timotimo: a tag won't prevent the detached head warning

[14:11] <timotimo> doh.

[14:12] <timotimo> in that case, it'll be fine to leave it be.

[14:12] <moritz> the problem is really that we want a specific revision, and the specific revision is not what the user wants when he wants to patch nqp or parrot

[14:12] <Woodi> just tried star 2012.11 with --profile and compiling nqp SEGFAULTs at stage1. 2Gb here, but retrying 'make' explodes in 0,5s - maybe it can't fill all memory so fast ? 

[14:12] *** PacoAir left
[14:12] <Woodi> *parrot with --profile

[14:12] *** bphillips joined
[14:13] *** PacoAir joined
[14:13] <timotimo> diakopter: i know how to make git clone only the needed stuff for the newest revision, i'll look into Configure.pl to see if i can figure out how it works since i know even less perl5 than i do perl6

[14:14] <diakopter> timotimo: I think it'd be a neat option like --no-parrot-history or something

[14:14] *** hash_table joined
[14:14] <timotimo> oh, configure-pl doesn't do very much by itself. i'll see.

[14:14] <moritz> diakopter: git supports it with the --depth option

[14:15] <diakopter> cool

[14:16] *** benabik left
[14:16] <moritz> though the resulting repo doesn't support many operations

[14:16] <timotimo> uh, that's not completely true

[14:16] <moritz> google for 'git shallow clone' for more info ;-)

[14:17] <timotimo> well, yeah, it doesn't do blame or history

[14:17] <timotimo> but you can push from it, i believe

[14:17] <timotimo> and you can easily expand the history after the fact, i think.

[14:17] <moritz> "(you cannot clone or fetch from it, nor push from nor into it)" says man git-clone

[14:18] <timotimo> o_O

[14:18] <timotimo> i must have something confused here.

[14:18] <timotimo> at least git pull --depth can expand the history as i remembered

[14:19] <moritz> timotimo: or maybe newer git revisions can do it

[14:19] <bphillips> I'm playing around with implementing a Spore REST client in perl6 (i.e. https://metacpan.org/module/Net%3A%3AHTTP%3A%3ASpore).  Can someone point me to a reasonably good example or doc on metaprogramming in perl6 (specifically, adding a dynamically named method+signature to an instance)

[14:20] <timotimo> hum. i have 1.7, but 1.8 is the current stable one. i should investigare

[14:21] <diakopter> I'd argue that nqp/parrot developers are not going to use the --gen-parrot option to do development. I can't tell you how many times I've waited for parrot to clone over a slow connection

[14:21] <diakopter> I change systems too often

[14:22] <moritz> bphillips: $obj.^add_method($name, method (\c) { # check arguments yoursel here }); $obj.^compose;

[14:22] <timotimo> at least the documentation still says, that you can't pull to or push from it :(

[14:22] <moritz> diakopter: I regularly develop nqp, and occasinally parrot, and I do use --gen-{nqp,parrot}

[14:22] <diakopter> oh

[14:23] <bphillips> moritz: Is there no way to create the signature dynamically as well so that perl6 does argument checking for me?

[14:23] <timotimo> not being able to pull into a shallow clone is a problem with how gen-nqp and gen-parrot do updates

[14:23] *** hash_table left
[14:24] <diakopter> n00b question: segfault in arbitrary C program on linux. I know how to debug on Windows MSVC. where do I start with gcc/linux

[14:24] <timotimo> diakopter: gdb binary_name and then run and see what happens, bt is the most interesting command for you

[14:24] <timotimo> in some distros you will get a list of packages you have to install to get complete symbol tables for your program, so that you can have complete tracebacks

[14:24] <moritz> diakopter: valgrind $programname

[14:25] <moritz> bphillips: not that I know of. Parameters in signatures are tied to lexical variables, and you can't easily create them at run time

[14:27] <diakopter> moritz: Invalid read of size 4

[14:27] <diakopter> yay!

[14:27] <diakopter> neat, it found the debug symbols automagically

[14:27] <bphillips> moritz: cool, I'll give it a whirl

[14:28] *** cognominal_ joined
[14:29] *** cognominal left
[14:29] <moritz> though I wonder if we could provide an API for creating a signature that only does checking, but no binding

[14:29] <timotimo> there are spectests for the is readonly trait in S06-traits/is-readonly.t, but i can't run them because my perl6 doesn't know what VAR is

[14:29] <diakopter> moritz: thanks!

[14:30] <diakopter> too scared to try gdb

[14:31] <moritz> timotimo: that' test is fudged, no?

[14:31] *** pmurias joined
[14:32] <timotimo> well, it says #?rakudo skip VAR, so apparently yes

[14:32] <timotimo> the other one where VAR is used is #?rakudo skip 'segfault', which isn't better

[14:34] *** colomon joined
[14:35] <timotimo> AFK for a bit

[14:35] <moritz> anyway, I think you can remove those VAR tests

[14:36] <moritz> I don't see how they add any value

[14:36] <timotimo> after that, should i see that i make tests that test is readonly with classes rather than local variables?

[14:37] <moritz> ss/rather than/in addition to/

[14:38] <timotimo> er, yes, i meant that. would they go into S12-traits?

[14:40] <moritz> put them into S06-traits/is-readonly.t too

[14:41] <[Coke]> timotimo, moritz: timo is now a bugadmin.

[14:42] <moritz> thanks [Coke]++

[14:43] <jnthn> moritz: Can have a look at the CATCH sinking when I get home from $dayjob

[14:44] <moritz> jnthn: thanks

[14:45] *** yves_ joined
[14:45] *** wamba joined
[14:46] *** Kharec joined
[14:52] *** PerlPilot is now known as PerlJam

[14:52] *** kaare_ joined
[14:58] *** Patterner left
[15:00] *** Psyche^ joined
[15:00] *** Psyche^ is now known as Patterner

[15:02] *** stopbit joined
[15:09] *** fgomez left
[15:11] *** birdwindupbird left
[15:13] <Woodi> strange, after installtion I getting: Missing or wrong version of dependency 'src/gen/CORE.setting' (from ModuleLoader.pbc)? ...

[15:13] <moritz> Woodi: probably you have an old installation, or old .pir files, which interfer with the new one

[15:15] <Woodi> no, strace shows that it is accessing /*/star-2012.11/*/ModuleLoader.pbc... or something happend during compilation

[15:18] <moritz> try  export RAKUDO_MODULE_DEBUG=1 

[15:21] *** wamba left
[15:22] *** wamba joined
[15:24] *** skids joined
[15:31] *** PacoAir left
[15:31] <Woodi> looks: use Config::INI; triggered this. so probably precompiled old modules...

[15:32] *** PacoAir joined
[15:33] *** fgomez joined
[15:33] *** wamba left
[15:34] *** huf_ is now known as huf

[15:36] *** cognominal_ left
[15:36] *** FROGGS joined
[15:38] <Woodi> ok, thanx moritz++

[15:39] *** PacoAir left
[15:39] *** hash_table joined
[15:40] *** kaleem joined
[15:40] *** fgomez left
[15:41] *** Kharec left
[15:42] <Woodi> so I think there is problem with NativeCall: while my $a = native_function( $sock, $structure, $kind-of-C-iterator-on-structure ) { ... }  exploding with SEGFAULT... cannot find user error this time...

[15:42] <Woodi> similiar while $b = native_without_C_iterator(...) { ... } works

[15:43] *** cognominal joined
[15:45] *** kst joined
[15:45] <timotimo> http://t.h8.lv/0001-test-for-RT-71356-readonly-trait-for-private-attribu.patch - does this look correct? i'll push it if it's deemed good.

[15:46] *** kivutar left
[15:46] <timotimo> oh, another question: niecza doesn't seem to implement is readonly. can i write the test so that instead of crashing(?) niecza would get a "not ok" for the class definition?

[15:47] *** kivutar joined
[15:48] <moritz> timotimo: niecza probably doesn't run the test file if it crashes on the trait

[15:48] <timotimo> hah! duh :)

[15:49] <bphillips> (perl6 newb alert) does declaring an empty submethod BUILD {} in a class affect the initialization of an instance of that class?

[15:50] <moritz> bphillips: yes

[15:50] <bphillips> moritz: what are the requirements for the BUILD method? should it return something?

[15:50] <moritz> bphillips: please see http://doc.perl6.org/language/objects#Object+Construction

[15:51] <bphillips> mortiz++ thanks

[15:54] <timotimo> i see there's lots of tests for advent2009, but none for 2010, 2011, 2012 in roast/integration. were the newer advent calendars not fit for their own tests because the test suite around them has already matured well enough in 2010?

[15:55] <moritz> timotimo: I think nobody got around to make test out of the posts

[15:55] <timotimo> is duplicating tests an issue?

[15:55] <timotimo> hm, actually, integration tests are sufficiently different from the rest of the spec test suite, aren't they?

[15:56] <timotimo> do you think making test cases for the rest of the advent calendars is a worthwile project for getting familiar and comfortable with perl6 and tests?

[15:56] <timotimo> and would perl6 benefit?

[15:58] *** atrodo left
[15:58] <moritz> yes, and yes

[15:59] <timotimo> cool :)

[15:59] <moritz> though only do it for posts that are well-suited for tests

[15:59] <timotimo> yes, certainly

[15:59] <jnthn> decommute, bbiab &

[16:00] *** atrodo_ joined
[16:00] *** cognominal left
[16:00] *** atrodo_ is now known as atrodo

[16:01] *** telex left
[16:02] *** telex joined
[16:03] <GlitchMr> glitchmr@feather ~/examples> /usr/bin/perl6 --version

[16:03] <GlitchMr> This is perl6 version 2012.11-27-g53daeff

[16:03] <GlitchMr> Up-to-date version of perl6 in /usr/bin. Surprised...

[16:07] <GlitchMr> Anyway, I've problem. You see, Rakudo complains about my custom operator not iffy enough.

[16:07] <GlitchMr> https://gist.github.com/4251501

[16:07] <GlitchMr> How can I make it iffy enough?

[16:08] *** cognominal joined
[16:10] <[Coke]> GlitchMr: if you make that a file rather than a shell session, you could have the evalbot run it from here.

[16:11] <[Coke]> r: https://gist.github.com/7c78460908e96476bf3e

[16:11] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/thRDO6p6pb:1␤------> [32mhttps[33m⏏[31m://gist.github.com/7c78460908e96476bf3e[0m␤»

[16:12] <[Coke]> ... or at least you used to be able to. :P

[16:13] <diakopter> public gists only I think

[16:13] <GlitchMr> r: https://gist.github.com/4251559

[16:13] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot negate in because it is not iffy enough␤at /tmp/39hJ6K2TVh:9␤------> [32msay 'lol'  !in[33m⏏[31m 'face';[0m␤»

[16:13] <GlitchMr> n: https://gist.github.com/4251559

[16:14] <p6eval> niecza v24-5-g599cbcb: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Cannot negate in because additive operators are not iffy enough at /tmp/7TmJ67zdo1 line 9:␤------> [32msay 'lol'  !in[33m⏏[31m 'face';[0m␤␤Parse failed␤␤»

[16:14] <GlitchMr> std: https://gist.github.com/4251559

[16:14] <p6eval> std a8bc48f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot negate in because additive operators are not iffy enough at /tmp/PAfiKpUwOT line 9:␤------> [32msay 'lol'  !in[33m⏏[31m 'face';[0m␤Parse failed␤FAILED 00:01 52m␤»

[16:14] <GlitchMr> Huh?

[16:14] <GlitchMr> How can I make actually iffy enough operator. I even have marked it returns boolean.

[16:14] <[Coke]> ah. didn't realize I had made it private, whoops!

[16:17] <[Coke]> GlitchMr: in the grammar, you declare it iffy:

[16:17] <[Coke]>         Perl6::Grammar.O(':prec<m=>, :assoc<left>, :iffy<1>, :pasttype<chain>',  '%chaining');

[16:17] <[Coke]> I have no idea how to mark it iffy outside the grammar, though.

[16:19] <[Coke]> it's not introspecting the signature for a boolish return, though.

[16:19] <GlitchMr> Well, specification says "You may negate only those operators that return a Bool".

[16:19] <GlitchMr> It doesn't depend on any internal "iffy" property.

[16:20] <[Coke]> GlitchMr: I'm just telling you what's in rakudo src.

[16:20] <[Coke]> I don't see any examples in roast that test for adding new iffy operators, just for testing that + isn't iffy enough.

[16:21] <[Coke]> your request seems reasonable to me. no clue how hard it would be to update the iffy test to check the signature as opposed to the iffy flag.

[16:22] <[Coke]> (or to update the iffy flag based on the sig for new items.)

[16:22] *** [particle]1 joined
[16:23] *** [particle] left
[16:26] <[Coke]> std: sub infix:<in>(Str $a, Str $b --> Bool) { True } ; say "a" in "b"

[16:26] <p6eval> std a8bc48f: OUTPUT«Potential difficulties:␤  $b is declared but not used at /tmp/W4frjONWe5 line 1:␤------> [32msub infix:<in>(Str $a, Str [33m⏏[31m$b --> Bool) { True } ; say "a" in "b"[0m␤  $a is declared but not used at /tmp/W4frjONWe5 line 1:␤------> [32msub infix:<in>(Str [3…

[16:26] <[Coke]> std: sub infix:<in>(Str $a, Str $b --> Bool) { $a, $b; True } ; say "a" in "b"

[16:26] <p6eval> std a8bc48f: OUTPUT«ok 00:00 47m␤»

[16:26] <[Coke]> std: sub infix:<in>(Str $a, Str $b --> Bool) { $a, $b; True } ; say "a" !in "b"

[16:26] <p6eval> std a8bc48f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot negate in because additive operators are not iffy enough at /tmp/U6VgRNhrym line 1:␤------> [32m--> Bool) { $a, $b; True } ; say "a" !in[33m⏏[31m "b"[0m␤Parse failed␤FAILED 00:00 47m␤»

[16:26] *** spider-mario joined
[16:27] <GlitchMr> Iffy flag looks like hack to me

[16:27] <[Coke]> std: sub infix:<asdfasdf>(Str $a, Str $b --> Bool) { $a, $b; True } ; say "a" !asdfasdf "b"

[16:27] <p6eval> std a8bc48f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Cannot negate asdfasdf because additive operators are not iffy enough at /tmp/O1ljUoRF0S line 1:␤------> [32mol) { $a, $b; True } ; say "a" !asdfasdf[33m⏏[31m "b"[0m␤Parse failed␤FAILED 00:00 47m␤»

[16:27] <GlitchMr> Of course, I could make infix:<!in> operator, but that's hax.

[16:28] <[Coke]> probably your quickest way to working code, and leave a comment that it shouldn't be needed.

[16:28] <[Coke]> looks like std doesn't allow it yet, either.

[16:28] <GlitchMr> I wonder if infix:<not in> operator, just like in Python would work

[16:29] *** atrodo left
[16:29] *** atrodo joined
[16:29] <GlitchMr> Seems to work

[16:30] <GlitchMr> Even if I put space between "not" and "in". Impressive.

[16:30] <GlitchMr> put more than one space*

[16:31] *** kaleem_ joined
[16:34] *** wamba joined
[16:34] *** kaleem left
[16:39] <jnthn> If you put it at the same precedence level as a relational operator, it should get the iffy-ness of that.

[16:44] <GlitchMr> That's... hacky

[16:44] <GlitchMr> What precedence would have with iffy-ness.

[16:44] *** grondilu left
[16:45] <jnthn> GlitchMr: It's exactly what STD does.

[16:45] *** am0c left
[16:46] <jnthn> GlitchMr: The precedence level relational operators have, as I told you.

[16:46] <jnthn> is equiv(&infix:<==>) for example

[16:47] *** wamba left
[16:49] *** colomon left
[16:53] *** colomon joined
[16:54] *** aindilis left
[16:54] *** [particle]1 left
[16:56] *** [particle] joined
[16:57] <[Coke]> r: sub infix:<in> is equiv(&infix:<==>) (Str $a, Str $b --> Bool) { $a, $b; True } ; say "a" !in "b"

[16:57] <p6eval> rakudo 53daef: OUTPUT«[31m===[0mSORRY![31m===[0m␤Missing block␤at /tmp/qEBaxfAzxf:1␤------> [32msub infix:<in> is equiv(&infix:<==>) [33m⏏[31m(Str $a, Str $b --> Bool) { $a, $b; True[0m␤»

[16:57] <[Coke]> r: sub infix:<in> (Str $a, Str $b --> Bool) is equiv(&infix:<==>) { $a, $b; True } ; say "a" !in "b"

[16:57] <p6eval> rakudo 53daef: OUTPUT«False␤»

[17:00] <japhb> jnthn: Did you see the Rakudo performance issues with 'for ^100 X ^100' and with push/join in the backlog?

[17:02] <japhb> diakopter, Regarding the parrot/nqp cloning issue: Since perl6-bench makes a LOT of clones of everything, it starts out by making one --mirror clone of each major component, and then doing local (very fast) clones as needed; in particular, before building Rakudo (or NQP), it starts by local-cloning the NQP and Parrot into place inside the Rakudo checkout, and then --gen-parrot recognizes those are there and just builds.

[17:03] <japhb> diakopter, if you change machines a lot, but are only in one or two locations, you might get a win by mirroring the repos to a single machine in each location, and cloning from that as needed.

[17:04] *** SamuraiJack_ joined
[17:05] <japhb> (Just make sure to 'git fetch -t' and 'git fetch -u' starting at the mirror when you want to update -- or run a cronjob on the mirror to do that.)

[17:05] <jnthn> japhb: Yes it's already in RT.

[17:05] <japhb> jnthn, ah, sorry, my bad

[17:05] <jnthn> japhb: np

[17:05] <jnthn> japhb: I didn't get to the bottom of why last time I looked at it.

[17:07] <japhb> As I spend more time with perl6-bench, I'm starting to get a feel for when something is out of whack in the sense that a performance problem goes way past the general slowdown of Parrot + several layers of abstraction.  Sometimes just seeing a really large difference between NQP and Rakudo on a test raises that flag.

[17:07] *** stanley joined
[17:08] *** MayDaniel joined
[17:08] <japhb> And sometimes it's a matter of niecza and Rakudo scaling very differently -- regardless of which one was faster for the "small" case.

[17:09] <jnthn> Yeah, it's good to look at those ones.

[17:09] *** SamuraiJack joined
[17:10] *** bluescreen10 joined
[17:10] *** SamuraiJack_ left
[17:11] <jnthn> I'm curious what difference the sink changes will make

[17:11] <japhb> ditto that.

[17:11] <jnthn> (They keep for loops in sink context from keeping all the results.)

[17:11] <jnthn> Well, from building up a result list.

[17:11] <japhb> It's now easy in perl6-bench to compare builds from different branches, so we can even compare before the merge if we like.

[17:12] <japhb> (I figured I'd do that anyway once more of the bugs were shaken out.)

[17:12] *** arlinius joined
[17:12] *** MayDaniel left
[17:14] <japhb> Oh, that reminds me: I'm thinking perl6-bench really belongs under the perl6 org; it should be a community thing, so I was thinking of forking my repo into the perl6 one on github and declaring the fork "official".  Anyone disagree and think that's a bad idea?  If so, why?

[17:15] *** ggoebel_ joined
[17:17] *** MayDaniel joined
[17:19] <moritz> japhb: go ahead

[17:20] <japhb> moritz, Thank you.  I'll wait for a bit to see if anyone has any objections, just in case.

[17:21] <japhb> Also, I'm assuming that code I wrote should be officially placed under Artistic 2, and code derived from RosettaCode should be explicitly marked Gnu FDL, correct?

[17:22] *** wamba joined
[17:22] <jnthn> moritz: So, should all CATCH blocks be sunk?

[17:23] <jnthn> moritz: Same with CONTROL?

[17:24] *** pmurias left
[17:27] <jnthn> moritz: I'm a bit surprised things aren't already considered in sink context there.

[17:27] <jnthn> moritz: Because of the rethrow added at the end.

[17:28] <jnthn> oh, wait, I see it...

[17:29] <FROGGS> is there a spec that says something about module search paths?

[17:30] <jnthn> r: try { die 'omg'; CATCH { for 1..10 { .say } } }

[17:30] <p6eval> rakudo 53daef: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤omg␤  in block  at /tmp/jXeQmLYA01:1␤␤»

[17:32] *** Kharec joined
[17:33] *** bphillips1 joined
[17:33] *** bphillips left
[17:34] <TimToady> jnthn: typo in "by using the ident method on strings,"

[17:35] <jnthn> uh, indent, yes :)

[17:35] <jnthn> fixed, thanks

[17:36] *** bphillips joined
[17:36] <jnthn> moritz: Got a fix.

[17:37] *** fhelmberger left
[17:38] *** bphillips1 left
[17:41] <dalek> rakudo/qast-sink-1: 5886931 | jnthn++ | src/Perl6/Actions.pm:

[17:41] <dalek> rakudo/qast-sink-1: Sink in CACTH and CONTROL blocks.

[17:41] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/58869313cc

[17:46] <felher> ... I had to read TimToady's line four times to see the typo. Two times even after I realized it was in i[n]dent. And I did only realize that becaue jnthn said so :)

[17:47] <FROGGS> I've got a problem, I've got a string like 'Dog:auth({ .substr(0,5) eq "cpan:"})' and I've got a token like { 'Dog:auth({' .+ '})' }

[17:47] <FROGGS> my problem is that .+ even matches the last }) of my string, so the token itself wont match in the end

[17:47] <FROGGS> how do I prevent it from matching the enclosing braces?

[17:48] <flussence> /.+?/ maybe

[17:48] * FROGGS tries

[17:49] <FROGGS> flussence: hmm, no, doesnt work

[17:49] <FROGGS> same result

[17:49] <FROGGS> ohh wait

[17:49] <FROGGS> it works somehow

[17:50] <FROGGS> flussence: thanks!

[17:51] <flussence> I guess you could also use the ~ operator in that case since it's two delimiters...

[18:03] *** MayDaniel left
[18:04] *** MayDaniel joined
[18:04] *** kaleem_ left
[18:07] *** PacoAir joined
[18:09] *** dakkar left
[18:09] *** benabik joined
[18:15] *** atrodo_ joined
[18:15] <TimToady> nr: sub postfix:<-> ($x) is equiv(&prefix:<->) { -$x }; say 2**3-

[18:16] <p6eval> rakudo 53daef, niecza v24-5-g599cbcb: OUTPUT«0.125␤»

[18:16] <TimToady> this is perhaps a clearer example of the postfix prec bu

[18:16] <TimToady> *bug

[18:16] <TimToady> looks like a STD bug

[18:17] <jnthn> If you can fix it in STD, I can take a look at transliterating the fix into Rakudo's EXPR

[18:17] *** atrodo left
[18:17] *** atrodo_ is now known as atrodo

[18:19] *** bapa joined
[18:21] <jnthn> r: class A { method Str() { 'a' } }; my @a = A.new xx 10; say @a.uniq.elems

[18:21] <p6eval> rakudo 53daef: OUTPUT«1␤»

[18:21] <jnthn> Got a fix for that one locally

[18:24] *** kurahaupo joined
[18:27] *** mikemol_ is now known as mikemol

[18:27] * diakopter learns that TimToady mentally pronounces STD as standard

[18:28] <TimToady> how do you pronounce 'stdin'?

[18:29] <TimToady> besides, S.T.D. means something gross :)

[18:29] <rindolf> TimToady: I call it standard-in.

[18:29] <rurban> me too

[18:30] <rindolf> Or maybe S.T.D.in.

[18:31] <rjbs> stuh-DIN

[18:31] <diakopter> ^

[18:31] <flussence> stiddin'

[18:31] <rjbs> and stuh-DOUT and stuh-DAIR

[18:31] <rjbs> I used to say "standard in" until confound converted me.

[18:32] *** colomon left
[18:32] <skids> If you are adequately antisocial, you never have to worry about such verbal pronunciations.

[18:32] <skids> Also no hazard of STDs.

[18:33] <TimToady> well, there are antisocial behaviors that can lead to STDs...

[18:34] <[Coke]> I read stdin in my head as "stand in"

[18:36] <[Coke]> http://www.quickmeme.com/meme/3qm3f8/

[18:38] <jnthn> [Coke]: And to make something appear on the terminal, your program has to "stand out"? :P

[18:39] <dalek> rakudo/nom: 8e02c1e | jnthn++ | src/core/List.pm:

[18:39] <dalek> rakudo/nom: Give uniq === semantics, not eq.

[18:39] <dalek> rakudo/nom: 

[18:39] <dalek> rakudo/nom: Also sink the for that is being gathered. Once the sink branch lands,

[18:39] <dalek> rakudo/nom: this should decrease memory usage also.

[18:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8e02c1ec3f

[18:40] *** MayDaniel left
[18:40] <GlitchMr> 0, [\+] 2 ** 15 xx 2 ** 15 # hash keys needed to make hash collision attack on PHP

[18:40] *** bapa left
[18:41] *** MayDaniel joined
[18:41] *** Chillance joined
[18:41] <[Coke]> jnthn: eh. it doesn't mean that, it's just how it's pronounced. :)

[18:42] <jnthn> :)

[18:43] *** bapa joined
[18:44] <dalek> perl6-roast-data: d345408 | coke++ | / (3 files):

[18:44] <dalek> perl6-roast-data: today (automated commit)

[18:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/d345408c68

[18:44] <[Coke]> https://github.com/coke/perl6-roast-data/blob/master/rakudo_summary.out#L1857 - 2 todo PASSED

[18:45] <GlitchMr> "unknon"

[18:45] <GlitchMr> This is really proffesional

[18:45] <diakopter> ...

[18:45] <GlitchMr> (I know, professional is written with one f and two s)

[18:46] <[Coke]> GlitchMr: do you have commit access to roast?

[18:46] <GlitchMr> Yes

[18:46] <[Coke]> You know what you have to do. :)

[18:46] <GlitchMr> ok, I'm going to find "unknon"

[18:47] <jnthn> Typos happen :)

[18:47] <jnthn> darn! I meant to typo that to make a joke then got it right 

[18:48] <[Coke]> mmmhehehe.

[18:48] <dalek> roast: a18f56f | GlitchMr++ | integration/99problems-11-to-20.t:

[18:48] <dalek> roast: Unknown, not unknon.

[18:48] <dalek> roast: review: https://github.com/perl6/roast/commit/a18f56fcd9

[18:48] *** immortal left
[18:48] <[Coke]> if you could track down the 2 passing TODOs while you're in there, that would be awesome.

[18:51] <GlitchMr> Sure

[18:52] *** benabik left
[18:53] <[Coke]> \o/

[18:54] <GlitchMr> Both of those TODO tests pass. But they pass just by accident.

[18:54] <GlitchMr> oh wait, they don't

[18:54] <GlitchMr> I was confused by two similar tests

[18:55] <GlitchMr> They don't pass. No idea why they pass for you.

[18:55] <dalek> rakudo/nom: a1eff00 | jnthn++ | docs/ChangeLog:

[18:55] <dalek> rakudo/nom: Update ChangeLog.

[18:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a1eff00b54

[18:56] <GlitchMr> https://github.com/perl6/roast/blob/a18f56fcd9a4488e5c5604d1d07ebee753058dde/integration/99problems-11-to-20.t#L136

[18:56] <GlitchMr> It's this test.

[18:56] <GlitchMr> But...

[18:56] <GlitchMr> not ok 5 - .. or a n-ary list with always same element

[18:57] *** kurahaupo left
[18:57] <GlitchMr> Oh wait, it's "unknown", not "unknon"

[18:58] <dalek> roast: b8d4388 | GlitchMr++ | integration/99problems-11-to-20.t:

[18:58] <dalek> roast: Passing TODOs :-).

[18:58] <dalek> roast: review: https://github.com/perl6/roast/commit/b8d4388de2

[18:59] <GlitchMr> [Coke]: Fixed.

[19:03] *** colomon joined
[19:06] *** cooper left
[19:06] *** cooper joined
[19:08] *** popl joined
[19:09] *** PacoAir left
[19:10] *** PacoAir joined
[19:11] *** atrodo left
[19:12] *** atrodo joined
[19:15] *** PacoAir left
[19:16] <timotimo> so there was an advent calendar post on quoting, but there was no mention of quoting shell commands?

[19:17] *** cognominal left
[19:17] <jnthn> timotimo: It missed out quote words and various other things too. :)

[19:17] *** PacoAir joined
[19:18] <jnthn> It wasn't meant to be exhaustive. 'cus otherwise it woulda been exhausting to write :P

[19:18] <timotimo> mhm

[19:20] *** pecastro joined
[19:20] <timotimo> er, what do i have to search in the synopses to find what quote word starts a shell execution quote? :|

[19:21] <jnthn> execute? :)

[19:21] <jnthn> In S02

[19:22] <timotimo> ah, indeed.

[19:22] *** SamuraiJack left
[19:22] <timotimo> that part didn't show up in the search results sadly

[19:24] <bphillips> moritz: what does the "\c" part of the method (\c) { ... } indicate in your message from earlier?

[19:25] <bphillips> (or if someone else knows, please feel free to chime in)

[19:26] <[Coke]> GlitchMr++ 

[19:28] <jnthn> bphillips: It means "take an argument and don't contextualize it in any way"

[19:28] <jnthn> It can be referred to as just "c" within the method

[19:28] *** japhb_ left
[19:28] <jnthn> moritz: Turns out my CATCH sink patch earlier wasn't enough, and didn't handle the default inside the CATCH needing sinking 

[19:30] <timotimo> what do i have to do to get a perl6 binary with line history and in-line-editing?

[19:30] *** ggoebel_ left
[19:31] <jnthn> timotimo: Thinks that needs having a libreadline (or perhaps the dev for it) installed at the time you build Parrot.

[19:31] <timotimo> ah, at parrot build time

[19:31] <timotimo> that's the key

[19:38] <timotimo> so with :x i get the stdout and with run/shell i get the exit code. any way to get both at the same time without executing something twice?

[19:42] *** spider-mario left
[19:43] *** spider-mario joined
[19:43] <TimToady> timotimo: well, there's always redirecting to a file and then reading that

[19:44] <timotimo> well, since you're already the parent process, why not give pipes as stdout and stderr and read their contents to a buffer?

[19:44] <TimToady> or a named fifo, on Unix

[19:45] <TimToady> well, it's certainly possible to teach perl6 how to do such things; I was just suggesting a workaround

[19:46] *** spider-mario left
[19:51] *** kivutar left
[19:52] <rindolf> Hi all. Are there any open Rakudo / Niezca / Perlito Junior Jobs?

[19:53] *** MayDaniel left
[19:53] *** cognominal joined
[19:53] *** MayDaniel joined
[19:53] *** ggoebel_ joined
[19:54] <[Coke]> tasks or actual paying jobs?

[20:03] <dalek> rakudo/qast-sink-1: f1b8fed | jnthn++ | src/Perl6/Actions.pm:

[20:03] <dalek> rakudo/qast-sink-1: Sink when/default in CATCH/CONTROL also.

[20:03] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/f1b8fed8bd

[20:04] <jnthn> moritz: With that last patch, spectest in qast-sink-1 looks quite good now (though not got the ICU tests running, so maybe we've some leftovers in there).

[20:04] *** SmokeMachine left
[20:05] <dalek> rakudo/nom: 24e882f | jnthn++ | docs/ROADMAP:

[20:05] <dalek> rakudo/nom: Give estimates for a couple of tasks.

[20:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/24e882f76e

[20:06] *** fgomez joined
[20:06] *** kurahaupo joined
[20:06] *** kurahaupo left
[20:08] *** arlinius left
[20:10] <timotimo> is there a forecast yet for when fork and wait might go into rakudo or niecza?

[20:10] *** cognominal_ joined
[20:11] *** cognominal left
[20:11] *** ingy left
[20:11] *** ingy joined
[20:16] *** aindilis joined
[20:18] *** cognominal_ left
[20:24] *** cognominal joined
[20:26] *** rindolf left
[20:30] *** rindolf joined
[20:30] <masak> ahoj, #perl6

[20:31] <hoelzro> o/ masak

[20:31] <TimToady> ajoi   <- Californian

[20:35] <jnthn> hola, señor masak

[20:38] * masak takes the ~ from the n and uses it as a funny 'stache

[20:38] *** kaare__ joined
[20:40] *** kaare_ left
[20:41] <masak> TimToady: should the indentation from an interpolated variable figure in the de-indentation of a heredoc?

[20:41] <masak> jnthn++ # Matryoshka dolls for Christmas! \o/

[20:43] <masak> <jnthn> Typos happen :)

[20:43] <masak> <jnthn> darn! I meant to typo that to make a joke then got it right

[20:44] <masak> what's even more scary, I *read* it as containing a typo! o.O

[20:44] <masak> and only then discovered that it didn't, to my great surprise.

[20:44] *** kivutar joined
[20:44] <masak> even now that I know that it doesn't contain a typo, just glancing at it, my brain expects one to be there.

[20:45] <masak> I think I'm finally turning into an autopun.

[20:46] <masak> timotimo: [backlog] so... essentially, you are wait-ing for a fork-ast... :P

[20:51] *** fgomez left
[20:51] <bphillips> I'm certain I must be doing something wrong, but can I expect $foo ~~ s/$search/$replace/ to return a boolean indicating that the search/replace was actually done?

[20:51] *** cognominal left
[20:52] <bphillips> I'm looping over a list of substitutions and once one matches, the ~~ s/// operation always seems to return true

[20:52] <timotimo> masak: *snrk* :D

[20:53] <bphillips> (the relevant gist: https://gist.github.com/4253309)

[20:53] <masak> bphillips: what s/// should return is a discussion that was never fully resolved.

[20:54] <masak> at one point, Niecza and Rakudo returned different things.

[20:54] <masak> rn: $_ = "foo"; say s/foo/bar/

[20:54] *** noggle joined
[20:54] <p6eval> rakudo 24e882: OUTPUT«bar␤»

[20:54] <p6eval> ..niecza v24-5-g599cbcb: OUTPUT«True␤»

[20:54] <masak> oh, they still do.

[20:54] <masak> :/

[20:54] *** wamba left
[20:55] <bphillips> regardless of the actual return value, if the subject of the search isn't matched, shouldn't it return something False-ish?

[20:55] *** fgomez joined
[20:55] <bphillips> or, should I do this differently? (I'm <24 into my perl6 adventure, my mind is primarily filled with p5 equivalents)

[20:56] *** arlinius joined
[20:57] <masak> :)

[20:57] <masak> moritz is the resident expert on smartmatching, I believe. he may have a good answer for you, once he rezzes.

[21:00] *** fgomez left
[21:00] *** kaare_ joined
[21:00] <bphillips> if I explicitly set $/ to False before doing the s///, that seems to "work" (although that seems like the worst way to go about this)

[21:02] <FROGGS> k, my Grammar for parsing "use" statements is set up and correctly matches 'auth', I got donuts, coffee and star trek is playing... life can be good

[21:02] *** kaare__ left
[21:05] *** GlitchMr left
[21:07] <dalek> rakudo/stdier: b9b110b | jnthn++ | src/Perl6/World.pm:

[21:07] <dalek> rakudo/stdier: Good error for unexpected closing bracket.

[21:07] <dalek> rakudo/stdier: review: https://github.com/rakudo/rakudo/commit/b9b110b9f0

[21:15] <masak> \o/

[21:16] <masak> anything is better than "Confused" :)

[21:18] *** Chillance left
[21:19] *** atrodo left
[21:19] *** rindolf left
[21:20] *** atrodo joined
[21:20] *** Kharec left
[21:20] *** hash_table left
[21:21] *** wamba joined
[21:25] <timotimo> i like that branch name

[21:25] <tadzik> standardier

[21:26] <sergot> hi o/ !

[21:26] <timotimo> http://t.h8.lv/0001-test-for-RT-71356-readonly-trait-for-private-attribu.patch - does this patch look good btw? i forgot to push it, so i just thought i'd ask before i do

[21:26] <sergot> There something wrong with p6's libs on feather. :(

[21:28] *** grondilu joined
[21:28] <jnthn> timotimo: did you forget to bump the plan?

[21:28] <[Coke]> where is p6 installed on feather?

[21:28] <timotimo> oh, yes i did. thanks!

[21:29] * [Coke] finds /usr/bin/perl6, which looks surprisingly recent.

[21:29] <masak> tadziku, sergocie! \o/

[21:30] <tadzik> o/

[21:30] *** kurahaupo joined
[21:35] *** cognominal joined
[21:35] <timotimo> can i have push permission to perl6/roast? i'm timo on github

[21:35] <[Coke]> +1

[21:36] <sergot> masaku ! o/

[21:37] <masak> vocative++

[21:37] <dalek> nqp/highexpect: e6ea357 | jnthn++ | src/QRegex/Cursor.nqp:

[21:37] <dalek> nqp/highexpect: Lookaheads should not change highexpect.

[21:37] <dalek> nqp/highexpect: review: https://github.com/perl6/nqp/commit/e6ea357f55

[21:37] <dalek> nqp/highexpect: 45ecaf8 | jnthn++ | src/QRegex/Cursor.nqp:

[21:37] <dalek> nqp/highexpect: Provide a way to manipulate highexpect.

[21:37] <dalek> nqp/highexpect: review: https://github.com/perl6/nqp/commit/45ecaf8f20

[21:38] <dalek> rakudo/stdier: 53e70fb | jnthn++ | src/Perl6/Grammar.pm:

[21:38] <dalek> rakudo/stdier: Fresh highexpect in ws, as per STD.

[21:38] <dalek> rakudo/stdier: review: https://github.com/rakudo/rakudo/commit/53e70fbd71

[21:38] <grondilu> rn:  say .[0] for [[<foo bar>], [^10]];

[21:38] <p6eval> rakudo 24e882, niecza v24-5-g599cbcb: OUTPUT«foo bar␤»

[21:38] <[Coke]> hurm. looks like timo is already a member of perl6.

[21:38] * grondilu was expecting "foon0"

[21:39] <jnthn> rn: say .[0] for ([<foo bar>], [^10]);

[21:39] <p6eval> rakudo 24e882, niecza v24-5-g599cbcb: OUTPUT«foo␤0␤»

[21:39] <jnthn> [...] is an item

[21:39] <[Coke]> but it looks like I'm not an admin. I think. So hopefully someone else can sort you out.

[21:39] <grondilu> rn:  say .[0] for [[<foo bar>], [^10]].list;

[21:39] <p6eval> rakudo 24e882, niecza v24-5-g599cbcb: OUTPUT«foo␤0␤»

[21:40] <grondilu> jnthn: thanks

[21:40] <jnthn> timotimo: done

[21:42] <sergot> "Could not find JSON::Tiny in any of:" I need JSON::Tiny on feather. :)

[21:42] <jnthn> bah, somehow implemetning highexpect busts...1 macros test? o.O

[21:42] <masak> O.o

[21:42] <jnthn> oh...that's unfortuante

[21:42] <jnthn> ...and easily fixed

[21:42] * masak .oO( nobody expects the macro inquisition! )

[21:43] <jnthn> nah, just that I put the highexpect things into an @.expected in X::Comp

[21:44] *** cognominal left
[21:44] <jnthn> And when that got mixed in to a type check exception, hid the expected type.

[21:44] <dalek> roast: 1fa9ddf | (Timo Paulssen)++ | S06-traits/is-readonly.t:

[21:44] <dalek> roast: test for RT #71356: readonly trait for private attributes

[21:44] <dalek> roast: review: https://github.com/perl6/roast/commit/1fa9ddfa9e

[21:45] <[Coke]> timotimo++ jnthn++

[21:45] *** cognominal joined
[21:47] *** bluescreen100 joined
[21:48] <dalek> rakudo/stdier: 324cb25 | jnthn++ | src/ (2 files):

[21:48] <dalek> rakudo/stdier: Rename to avoid a conflict.

[21:48] <dalek> rakudo/stdier: review: https://github.com/rakudo/rakudo/commit/324cb2540a

[21:48] * jnthn does another spectest

[21:48] <jnthn> If this passes, I'll merge the next round of error reporting improvements :)

[21:49] *** spider-mario joined
[21:49] <timotimo> jnthn++ sounds great!

[21:49] *** bluescreen10 left
[21:50] <popl> I'd like to help with Perl 6 but I suck. Is there anything I could do (documentation, sweeping up, etc.)?

[21:51] <masak> anything that stirs the pot is a good help.

[21:51] *** cognominal left
[21:52] <masak> I started my activity here on #perl6 basically trying out the spec, piece by piece.

[21:52] <masak> dragged up a few things :)

[21:52] <FROGGS> popl: if you wanna learn Perl 6 while helping, you could skim through the bugtrackers and check for already solved things, add tests or try to solve something on your own

[21:52] <FROGGS> thats what I did to get a feeling for the internals

[21:53] *** cognominal joined
[21:53] <popl> Ok.

[21:53] <FROGGS> masak: is version comparision implemented yet?

[21:53] <dalek> nqp: b30fb7a | jnthn++ | src/Q (2 files):

[21:53] <dalek> nqp: Keep :dba(...) values for a bit longer.

[21:53] <dalek> nqp: 

[21:53] <dalek> nqp: This will allow them to make it unti NFA construction time.

[21:53] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b30fb7aded

[21:53] *** dalek left
[21:53] <popl> I will look into it.

[21:53] <popl> Thanks FROGGS.

[21:53] *** SmokeMachine joined
[21:53] <FROGGS> popl: you're welcome

[21:54] *** dalek joined
[21:54] *** ChanServ sets mode: +v dalek

[21:54] <masak> FROGGS: try it and see.

[21:54] <FROGGS> how?

[21:54] <masak> rn: say v3 > v2

[21:54] <p6eval> rakudo 24e882: OUTPUT«Cannot call 'Real'; none of these signatures match:␤:(Mu:U \v: Mu *%_)␤␤  in method Real at src/gen/CORE.setting:804␤  in sub infix:<>> at src/gen/CORE.setting:2822␤  in block  at /tmp/QCXQ6GlTvf:1␤␤»

[21:54] <p6eval> ..niecza v24-5-g599cbcb: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method value:version not yet implemented at /tmp/sJy3iCqPQK line 1:␤------> [32msay v3[33m⏏[31m > v2[0m␤␤Action method value:version not yet implemented at /tmp/sJy3iCqPQK line 1 (EOF):␤------> [32msay v3 > v2[33…

[21:54] <masak> rn: say v3 after v2

[21:54] <FROGGS> r: say so 1.2.3 > 3.2.0

[21:54] <p6eval> niecza v24-5-g599cbcb: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method value:version not yet implemented at /tmp/moSDYyJ9Sz line 1:␤------> [32msay v3[33m⏏[31m after v2[0m␤␤Action method value:version not yet implemented at /tmp/moSDYyJ9Sz line 1 (EOF):␤------> [32msay v3 afte…

[21:54] <p6eval> ..rakudo 24e882: OUTPUT«True␤»

[21:54] <p6eval> rakudo 24e882: OUTPUT«[31m===[0mSORRY![31m===[0m␤Confused␤at /tmp/ES0xIx9I7E:1␤------> [32msay so 1.2.[33m⏏[31m3 > 3.2.0[0m␤»

[21:55] <dalek> rakudo/nom: 4068131 | jnthn++ | src/ (2 files):

[21:55] <dalek> rakudo/nom: Try reporting what was expected at high watermark.

[21:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4068131609

[21:55] <dalek> rakudo/nom: 0118e3b | jnthn++ | src/Perl6/Grammar.pm:

[21:55] <dalek> rakudo/nom: Add a bunch of missing :dba(...)s.

[21:55] *** dalek left
[21:55] <FROGGS> okay, NYI

[21:55] <masak> r: say v4.beta after v4

[21:55] <p6eval> rakudo 24e882: OUTPUT«No such method 'beta' for invocant of type 'Version'␤  in block  at /tmp/MEEZIeeGaq:1␤␤»

[21:55] <masak> r: say v4beta after v4

[21:55] <p6eval> rakudo 24e882: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&after' called (line 1)␤Undefined routine '&v4beta' called (line 1)␤»

[21:55] <masak> r: say v4 after v4

[21:55] <p6eval> rakudo 24e882: OUTPUT«False␤»

[21:55] *** dalek joined
[21:55] *** ChanServ sets mode: +v dalek

[21:55] <masak> hm. I should read up on version number syntax.

[21:55] <FROGGS> r: say v5 after v4

[21:55] <p6eval> rakudo 24e882: OUTPUT«True␤»

[21:56] <jnthn> OK, it's merged :)

[21:56] *** wamba left
[21:56] *** cognominal_ joined
[21:56] <FROGGS> masak: let me read ;o)

[21:57] <[Coke]> jnthn++

[21:57] <dalek> rakudo/nom: 41a658a | jnthn++ | docs/ROADMAP:

[21:57] <dalek> rakudo/nom: Remove completed highwater task.

[21:57] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/41a658a8cf

[21:57] *** SmokeMachine left
[21:58] *** kivutar left
[21:59] *** wamba joined
[21:59] *** cognominal__ joined
[21:59] *** cognominal left
[22:00] <timotimo> is "highwater" an established term/concept? what do i have to look for to find more about how it works without digging into code?

[22:01] *** cognominal_ left
[22:01] <cognominal__> masak:  "Everywhere I look, I see people falling prey to confirmation bias. Just as I suspected."

[22:02] *** ggoebel_ left
[22:02] <jnthn> timotimo: Not really sure what to point you at. But I can explain it...

[22:02] <masak> cognominal__: oh, it's a variant of "Is confirmation bias prevalent? Yes, I see it everywhere!" # autopun

[22:03] *** popl left
[22:03] <jnthn> One of the reasons Rakudo has given dodgy location information at times is because certain kinds of errors make the parser try a bunch of alternatives, and in doing so it might jump back quite a long way in order to do so.

[22:03] <jnthn> This means at the point it finally gives up, it may be quite a long way from where the real problem was.

[22:04] <timotimo> OK, that seems plausible - if frustrating

[22:04] <jnthn> The highwater mark just records the furthest place we got to.

[22:04] <timotimo> ah, and that's the point that gets reported as having the error?

[22:04] <jnthn> The highexpect is a kind of "black box recorder" of the parse that keeps track of what we were looking for at the time.

[22:04] <jnthn> Yes.

[22:05] *** skids left
[22:05] <jnthn> And that's basically it :)

[22:05] <timotimo> seems reasonable. and if it works, that's great, too :)

[22:06] <jnthn> The only other bit to mention is that analyzing the contents of highexpect and the stuff immediately after the highwater is the way we manage to re-write some "Confused" messages into something a bit smarter.

[22:06] <masak> that raises a question for me. why all the backtracking? I thought Perl 6 syntax mostly didn't involve backtracking.

[22:06] *** cognominal__ left
[22:07] <jnthn> masak: It's not backtracking in the sense of quantifier backtracking.

[22:07] <jnthn> If you do

[22:07] <timotimo> maybe it's got something to do with longest expression matching?

[22:07] <jnthn> [ <foo_that_matches_lots_then_fails> || <bar_that_does_less> || <.panic: 'Confused'> ]

[22:08] <masak> oh, troo.

[22:08] <jnthn> Then you can end up a long way back.

[22:08] <masak> it's just resetting to a cursor that lets you retry something.

[22:08] <jnthn> Well, just returning up the callstack really

[22:08] <jnthn> We don't reset cursors, just throw away ones that didn't work out.

[22:09] <timotimo> i wonder if it makes any sense to autothread grammars, if they can be reset anyway?

[22:09] <jnthn> To give an example of highexpect, if I do:

[22:09] <jnthn> perl6 -e "42.\  "

[22:09] <jnthn> Then the error location also now has some info on what it wanted:

[22:09] <jnthn> ------> 42.<HERE>\

[22:09] <jnthn>     expecting any of:

[22:09] <jnthn>         dotty method or postfix

[22:11] <jnthn> timotimo: That may create issues with various other bits of parse state kept around in contextuals. Cursors aren't the only thing going on.

[22:12] <timotimo> feared as much :(

[22:13] *** hash_table joined
[22:13] <jnthn> I don't think it'd be a huge win anyway, fwiw

[22:13] <jnthn> The LTM-er often guesses right first time.

[22:14] <timotimo> cool

[22:14] <jnthn> Thus the overhead of actually syncing up the various threaded runs (if you meant using multiple threads) would risk dominating any wins.

[22:14] *** cognominal__ joined
[22:14] <timotimo> i was meaning multiple threads, yes.

[22:15] <jnthn> When I put in the LTM stuff I had a load of traces running to help me debug it, and I noticed it was guesing quite well.

[22:16] <timotimo> that's pretty amazing actually. i have no clue how it does that :|

[22:17] <sorear> I think a more promising approach would be to scrape your code for "use" statements using a simple regex, and then start background precompilation of modules

[22:17] <jnthn> sorear: mmm...yes :)

[22:18] <jnthn> (separate compilation)++

[22:21] *** bbkr_ left
[22:21] <masak> 'night, #perl6

[22:23] <FROGGS> gnight

[22:23] <timotimo> night masak

[22:25] *** kaare_ left
[22:31] *** cognominal__ left
[22:38] *** MayDaniel left
[22:40] *** cognominal joined
[22:41] *** hash_table left
[22:42] <grondilu> rn: say ^(3/2+1)

[22:43] <p6eval> niecza v24-5-g599cbcb: OUTPUT«0..^<5/2>␤»

[22:43] <p6eval> ..rakudo 41a658: OUTPUT«0..^5/2␤»

[22:43] *** PacoAir left
[22:43] <grondilu> rn: say eager ^(3/2+1)

[22:43] <p6eval> rakudo 41a658: OUTPUT«0 1 2␤»

[22:43] <p6eval> ..niecza v24-5-g599cbcb: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'eager' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /hom…

[22:44] <grondilu> rn: say my @ = ^(3/2)

[22:44] <p6eval> rakudo 41a658, niecza v24-5-g599cbcb: OUTPUT«0 1␤»

[22:44] <grondilu> rn: say my @ = ^(<3/2>.floor)

[22:44] <p6eval> rakudo 41a658, niecza v24-5-g599cbcb: OUTPUT«0␤»

[22:45] <grondilu> So I guess  prefix:<^> doesn't use floor to convert to Int.

[22:46] *** pecastro left
[22:46] *** jaldhar_ left
[22:48] <timotimo> hm. should integration tests for the older perl6advent posts be there to point out inconsistencies between claims and implementation so that if spec changes, the advent post can be updated as well?

[22:48] *** spider-mario left
[22:50] *** cognominal left
[22:55] *** cognominal joined
[22:59] <jnthn> r: say 18.333 / 0.62

[22:59] <p6eval> rakudo 41a658: OUTPUT«29.569355␤»

[23:02] *** grondilu left
[23:04] <dalek> rakudo/nom: 8fb8bc1 | jnthn++ | src/core/Junction.pm:

[23:04] <dalek> rakudo/nom: Optimize the junction auto-threader.

[23:04] <dalek> rakudo/nom: 

[23:04] <dalek> rakudo/nom: This makes the benchmark:

[23:04] <dalek> rakudo/nom: 

[23:04] <dalek> rakudo/nom:     for 1..10 { say so 9999 == any(1..2000) }

[23:04] <dalek> rakudo/nom: 

[23:04] <dalek> rakudo/nom: Complete somewhere around 30 times faster.

[23:04] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8fb8bc1d19

[23:06] <dalek> rakudo/nom: a308f34 | jnthn++ | docs/ChangeLog:

[23:06] <dalek> rakudo/nom: Update ChangeLog.

[23:06] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a308f34d1c

[23:06] <timotimo> what, auto-threading is in rakudo already?

[23:06] *** jerome joined
[23:07] *** stopbit left
[23:07] <jnthn> timotimo: Auto-threading of junctions doesn't have anything to do with threads.

[23:07] <jnthn> I mean, it potentially could

[23:07] <jnthn> It just means that an operation threads through the junction.

[23:07] <timotimo> oh, so it goes faster not because it actually threads

[23:07] <timotimo> but because the code that does it is just more efficient

[23:07] <jnthn> Right.

[23:07] <timotimo> 30 times, though. wow!

[23:07] <jnthn> Quite a lot more efficient. :)

[23:08] <jnthn> Yeah, now I know why people kept telling me auto-threading was slow. It really was!

[23:08] *** jaldhar_ joined
[23:08] <timotimo> i ran into that once, too ...

[23:08] <timotimo> and i have absolutely no clue why your code changes improve performance

[23:08] <jnthn> Well, this should make it hurt a bit less :)

[23:15] <[Coke]> timotimo: if the old advent posts are wrong, it is awesome to update the tests to say "here's how that actually works these days".

[23:15] <[Coke]> I don't think we have to update the old post itself.

[23:16] <timotimo> well, there are no tests yet for most of the advent posts

[23:18] *** benabik joined
[23:21] *** jaldhar_ left
[23:22] <timotimo> hm. can c++ libraries like SFML be wrapped using zavolaj?

[23:22] <timotimo> i fear they can't :(

[23:23] *** jaldhar_ joined
[23:24] *** bluescreen10 joined
[23:25] *** colomon left
[23:25] <jnthn> japhb: Think I may have found a clue to the X issue, but out of hacking time for now. Will see if I can have a go at it tomorrow...

[23:25] <jnthn> timotimo: I think C++ libs are tricky because of the name mangling etc.

[23:26] <dalek> tablets: dd5acfd | (Herbert Breunung)++ | docs/appendix-a-index.txt:

[23:26] <dalek> tablets: add spurt to A

[23:26] <dalek> tablets: review: https://github.com/perl6/tablets/commit/dd5acfdc99

[23:27] <jnthn> sleep; night o/

[23:27] *** cognominal left
[23:29] <timotimo> night jnthn 

[23:31] <timotimo> if i have a role with has @!foo and a class that does that role, will it have access to it? or would that have to be has @.foo instead?

[23:34] *** ponpon joined
[23:35] *** cognominal joined
[23:35] *** am0c joined
[23:35] <timotimo> ah, i see.

[23:40] *** fgomez joined
[23:44] *** lichtkind joined
[23:46] <timotimo> r: say $result if my $result = 5 + 6;

[23:46] <p6eval> rakudo a308f3: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $result is not declared␤at /tmp/7Y88nJVFHa:1␤------> [32msay $result[33m⏏[31m if my $result = 5 + 6;[0m␤»

[23:46] <timotimo> std: say $result if my $result = 5 + 6;

[23:46] <p6eval> std a8bc48f: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $result is not predeclared at /tmp/S8Wo7FYaP5 line 1:␤------> [32msay [33m⏏[31m$result if my $result = 5 + 6;[0m␤Check failed␤FAILED 00:00 43m␤»

[23:46] <timotimo> right.

[23:47] <diakopter> r: say my $result if $result = 5 + 6;

[23:47] <p6eval> rakudo a308f3: OUTPUT«11␤»

[23:47] <timotimo> oh, that's simple

[23:48] <timotimo> i'm doing some wicked necromancy

[23:48] <timotimo> a bit of software that used to require the "alpha" branch of rakudo :)

[23:48] <timotimo> not saying what it is until i manage to actually make it run

[23:50] <timotimo> why would $foo ~~ $.bar ever giev me "sorry: virtual call $.bar may not be used on partially constructed objects" inside a submethod?

[23:51] <timotimo> oh, interestign

[23:51] <diakopter> if it's called from a constructor?

[23:51] <timotimo> turning it from a submethod into a method makes the error go away

[23:51] <timotimo> so basically submethods might be called from the objects own constructor before it's constructed completely? or something?

[23:52] <diakopter> :?

[23:52] <dalek> tablets: e91970d | (Herbert Breunung)++ | docs/appendix-a-index.txt:

[23:52] <dalek> tablets: added some see also

[23:52] <dalek> tablets: review: https://github.com/perl6/tablets/commit/e91970dc7c

[23:53] <timotimo> well, there must be some limitation to methods that are not limitations of submethods

[23:53] <lichtkind> hai guys

[23:54] *** ggoebel_ joined
[23:55] *** ponpon is now known as ponbiki

[23:57] <lichtkind> is there still a byte smethod but not in Str?

[23:57] <benabik> Buf.bytes, perhaps?  (guessing)

[23:58] *** fgomez left
[23:59] <lichtkind> benabik: thanks i thought so buts where can i look this up?

