[00:00] *** REPLeffect joined
[00:02] *** libertyprime left
[00:03] *** libertyprime joined
[00:03] *** libertyprime left
[00:04] *** Facefox left
[00:04] *** libertyprime joined
[00:07] *** crazedpsyc joined
[00:07] *** crazedpsyc is now known as Guest32104

[00:09] *** ivan`` joined
[00:11] *** Facefox joined
[00:13] *** helloworld_ joined
[00:15] *** helloworld left
[00:15] *** helloworld_ is now known as helloworld

[00:16] *** helloworld is now known as replSOS

[00:19] *** cotto joined
[00:21] *** Guest32104 left
[00:23] *** InfiniteLoop joined
[00:23] <InfiniteLoop> hi all

[00:23] *** fgomez left
[00:24] *** fgomez joined
[00:24] <TimToady> howdy

[00:24] <InfiniteLoop> Im trying to compile rakudo on my ppc powerbook g4

[00:24] <InfiniteLoop> and I get this error compiling nqp:

[00:24] <InfiniteLoop> Unknown serialization format version 16777216

[00:25] <InfiniteLoop> any suggestions on how to fix this ?

[00:25] <TimToady> hmm, I'm not an expert on that bit, but are you trying to use an existing parrot, or using --gen-parrot on the Configure?

[00:26] <TimToady> is this a new install?

[00:26] <InfiniteLoop> this is what I have: perl Configure.pl --gen-parrot   --parrot-option=--without-pcre --gen-parrot-option=--optimize 

[00:26] <InfiniteLoop> yes a new install

[00:26] * TimToady also wonders if the serialization has been tested on a bigendian machine

[00:26] <InfiniteLoop> ah

[00:27] <TimToady> the number near 2**24 is suspicious

[00:27] <InfiniteLoop> anyway here's the relevant compiler error: http://snipt.org/ujfhe2

[00:29] <TimToady> unfortunately most of the experts on compiling rakudo are already asleep

[00:29] <InfiniteLoop> thanks TimToady, I'll try my luck later

[00:33] *** aloha left
[00:34] <TimToady> in fact, exactly 2**24

[00:37] *** jrockway joined
[00:38] *** jtpalmer joined
[00:44] *** am0c joined
[00:44] *** InfiniteLoop left
[00:47] *** jrockway left
[00:53] *** jrockway joined
[00:53] <TimToady> phenny: ask jnthn has the serialization been tested on a big-endian machine?

[00:53] <phenny> TimToady: I'll pass that on when jnthn is around.

[00:58] *** jrockway left
[01:03] *** jrockway joined
[01:03] <[Coke]> kid51 might have tested it.

[01:04] <sorear> I know lue had a ppc mac, but I think he left pre-bs

[01:07] *** aloha joined
[01:07] *** scott_ joined
[01:07] *** scott_ is now known as Guest28776

[01:14] *** jrockway left
[01:14] *** tokuhirom left
[01:16] *** jrockway joined
[01:17] *** vinian joined
[01:20] *** jrockway left
[01:26] *** jrockway joined
[01:36] *** Guest36290 left
[01:44] *** Guest14083 joined
[01:46] *** Guest14083 is now known as crazedpsyc

[01:49] *** raiph joined
[02:11] *** leprevost joined
[02:12] *** benabik joined
[02:13] *** pyrimidine left
[02:19] *** orafu left
[02:19] *** orafu joined
[02:29] *** thou joined
[03:00] *** orafu left
[03:01] *** cognominal joined
[03:04] *** cognominal_ left
[03:11] *** HarryS left
[03:11] *** HarryS joined
[03:12] *** xinming left
[03:13] *** TimToady left
[03:13] *** xinming joined
[03:13] *** jaldhar joined
[03:14] *** TimToady joined
[03:14] *** estrabd left
[03:16] *** estrabd joined
[03:41] *** leprevost left
[03:51] *** replSOS left
[03:52] *** replSOS joined
[03:56] *** vinian left
[03:57] *** replSOS left
[04:07] *** xinming left
[04:07] *** xinming joined
[04:27] *** xinming left
[04:28] *** actualeyes joined
[04:39] *** xinming joined
[04:41] *** thou left
[04:54] *** libertyprime left
[04:54] *** fgomez left
[04:54] *** libertyprime joined
[04:56] *** thou joined
[04:59] *** fgomez joined
[05:05] *** birdwindupbird joined
[05:06] *** SHODAN left
[05:08] *** SHODAN joined
[05:09] <moritz> \o

[05:13] *** actualeyes left
[05:16] <sorear> o/

[05:35] *** replsos joined
[05:38] <cognominal> \o

[05:39] *** stephenlb left
[05:40] *** am0c left
[05:40] <cognominal> about my p6peg project.  I have hit 2 bugs as show by the following stack trace.  https://gist.github.com/2778559

[05:41] <cognominal> 1/ the error lines for QRegex.nqp are wrong

[05:43] <cognominal> 2/  my grammar has no associated action class, nevertheless the 'not' method is called. That means there is a leftover $*ACTIONS dyn variable that leaked.

[05:44] <cognominal> *-2 shown

[05:45] <cognominal> hoping that Whatever is correctly implemented in this irc channel  :)

[05:45] <cognominal> must go. Will read the backlog.

[05:49] <cognominal> phenny, tell jnthn, I have probably two bugs that fall on you lap. see  http://irclog.perlgeek.de/perl6/2012-05-24#i_5631348

[05:49] <phenny> cognominal: I'll pass that on when jnthn is around.

[05:52] <dalek> tablets: 39afed0 | (Herbert Breunung)++ | docs/ (2 files):

[05:52] <dalek> tablets: clarifying statement

[05:52] <dalek> tablets: review: https://github.com/perl6/tablets/commit/39afed0c63

[05:55] *** thou left
[05:55] *** vlixes left
[05:55] *** sudokode left
[05:58] *** NamelessTee joined
[06:04] *** kaleem joined
[06:24] <moritz> cognominal: it is usually a good idea to avoid regex names that collides with methods in class Any

[06:25] <moritz> cognominal: I guess that the Actions class is just Any, and it looks if method 'not' is available in class Any, which is it. Then it tries to call it => BOOM

[06:39] *** adu joined
[07:04] *** DreamingInCode left
[07:08] <moritz> r: my @blocks := (0..*).map: -> $n { -> $x, $y { $x * $y * $n } }; say @blocks.infinite

[07:08] <p6eval> rakudo 558fd0: OUTPUT«Mu()␤»

[07:08] <moritz> I think that should be "potentially infinite"

[07:12] <moritz> r: say (1..*).infinite

[07:12] <p6eval> rakudo 558fd0: OUTPUT«True␤»

[07:12] <moritz> r: say (1..*).map(-> $x { $x } ).infinite

[07:12] <p6eval> rakudo 558fd0: OUTPUT«Mu()␤»

[07:15] *** replsos_ joined
[07:16] <moritz> r: say (67.base(2).flip.comb Z* 1, 2, 4 ... *).grep: {$_}

[07:16] <p6eval> rakudo 558fd0: OUTPUT«1 2 64␤»

[07:16] *** brrt joined
[07:16] <moritz> http://www.perlmonks.org/?node_id=972098

[07:16] <moritz> r: say (67.fmt('%b').flip.comb Z* 1, 2, 4 ... *).grep: {$_}

[07:16] <p6eval> rakudo 558fd0: OUTPUT«1 2 64␤»

[07:19] *** replsos left
[07:19] *** replsos_ is now known as replsos

[07:19] <moritz> r: say (67.base(2).flip.comb Z* (^64) X** 2).grep: {$_}

[07:19] <p6eval> rakudo 558fd0: OUTPUT«1 36␤»

[07:19] <moritz> r: say (67.base(2).flip.comb Z* (1..64) X** 2).grep: {$_}

[07:19] <p6eval> rakudo 558fd0: OUTPUT«1 4 49␤»

[07:20] <moritz> r: say (1..64) X** 2

[07:20] <p6eval> rakudo 558fd0: OUTPUT«1 4 9 16 25 36 49 64 81 100 121 144 169 196 225 256 289 324 361 400 441 484 529 576 625 676 729 784 841 900 961 1024 1089 1156 1225 1296 1369 1444 1521 1600 1681 1764 1849 1936 2025 2116 2209 2304 2401 2500 2601 2704 2809 2916 3025 3136 3249 3364 3481 3600 3721 384…

[07:20] <moritz> r: say (67.base(2).flip.comb Z* 2 X** ^Inf).grep: {$_}

[07:20] <p6eval> rakudo 558fd0: OUTPUT«1 2 64␤»

[07:22] <moritz> r: say (67.base(2).flip.comb Z* 2 X**^Inf).grep: {$_}

[07:22] <p6eval> rakudo 558fd0: OUTPUT«1 2 64␤»

[07:22] *** NamelessTee left
[07:22] <moritz> r: say (67.base(2).flip.comb Z* 2X**^Inf).grep: {$_}

[07:22] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤Confused␤at /tmp/mVYGEY_AxB:1␤»

[07:22] <moritz> r: say (67.base(2).flip.comb Z* 2 X**^Inf).grep: {$_}

[07:22] <p6eval> rakudo 558fd0: OUTPUT«1 2 64␤»

[07:23] <tadzik> morning good

[07:23] <moritz> I wonder if you can use regexes to get the binary representation of a number

[07:23] <moritz> \o tadzik 

[07:25] <moritz> r: my regex a { ^ 1 $ | <a> $<a> }; say (1 x 67) ~~ /<a>*/

[07:25] <p6eval> rakudo 558fd0: OUTPUT«No such method 'a' for invocant of type 'Cursor'␤  in regex a at /tmp/LtdGyrXXYf:1␤  in method INTERPOLATE at src/gen/CORE.setting:9247␤  in regex <anon> at /tmp/LtdGyrXXYf:1␤  in method ACCEPTS at src/gen/CORE.setting:9304␤  in block <anon> at /tmp/LtdGyrXXYf:1␤␤»…

[07:26] <moritz> r: my regex a { ^ 1 $ | <a=&a> $<a> }; say (1 x 67) ~~ /<a>*/

[07:26] <p6eval> rakudo 558fd0: OUTPUT«(timeout)»

[07:26] <moritz> r: my regex a { ^ 1 $ | <a=&a> $<a> }; say (1 x 14) ~~ /<a>+/

[07:26] <p6eval> rakudo 558fd0: OUTPUT«(timeout)»

[07:27] *** kresike joined
[07:27] <kresike> morning all

[07:28] <moritz> r: say (67, * div 2 ... 0).grep(* %% 2).reverse

[07:28] <p6eval> rakudo 558fd0: OUTPUT«0 2 4 8 16␤»

[07:28] <moritz> hello kresike 

[07:33] <tadzik> hi kresike 

[07:36] *** replsos left
[07:38] <sorear> o/ kresike !

[07:44] *** stol_ joined
[07:52] *** fglock joined
[08:00] *** replsos joined
[08:04] <jnthn> morning

[08:04] <phenny> jnthn: 00:53Z <TimToady> ask jnthn has the serialization been tested on a big-endian machine?

[08:04] <phenny> jnthn: 05:49Z <cognominal> tell jnthn I have probably two bugs that fall on you lap. see  http://irclog.perlgeek.de/perl6/2012-05-24#i_5631348

[08:05] <tadzik> hello jnthn 

[08:05] <jnthn> phenny: tell TimToady No, there are comments there saying "this probably needs fixing for big-endian". But I didn't manage to get myself access to such a box.

[08:05] <phenny> jnthn: I'll pass that on when TimToady is around.

[08:06] <jnthn> hi tadzik 

[08:08] <kresike> moritz, tadzik, sorear o/

[08:09] <moritz> jnthn: re the regex thing by cognominal, I have a short analysis of that in the backlog

[08:09] <kresike> jnthn, o/

[08:11] <jnthn> moritz: OK, will look later on

[08:12] <jnthn> Today I'm meant to be doing @stuff for $client, but so far only succeeded in BSOding my machine and drinking coffee :)

[08:12] <jnthn> Well, s/my/their/ really :)

[08:12] *** fhelmberger joined
[08:12] *** replsos left
[08:14] *** Timbus left
[08:14] *** geekosaur left
[08:15] *** kresike left
[08:16] *** shachaf left
[08:16] *** Timbus joined
[08:16] *** shachaf joined
[08:16] <moritz> (basically $*ACTIONS ends up as Any, and Any has a method 'not', and we try to call that)

[08:17] <moritz> I wonder if we should special-case $*ACTIONS === Any

[08:17] *** kresike joined
[08:17] <moritz> or keep a $.has-actions flag around

[08:17] <jnthn> Or better, never set $*ACTIONS 

[08:17] <jnthn> OTOH, that means it'd leak if you called a grammar from inside a grammar

[08:17] <jnthn> So that also sucks.

[08:22] <moritz> r: my @a := { state $x; $x++ } ... *; say @a[^5]

[08:22] <p6eval> rakudo 558fd0: OUTPUT«0 1 2 3 4␤»

[08:23] <moritz> r: my @a := sub () { state $x; $x++ } ... *; say @a[^5]

[08:23] <p6eval> rakudo 558fd0: OUTPUT«0 1 2 3 4␤»

[08:23] <masak> gowd mownin', #pewl6

[08:23] <jnthn> r: my @a := { (state $x)++ } ... *; say @a[^5]

[08:23] <p6eval> rakudo 558fd0: OUTPUT«0 1 2 3 4␤»

[08:23] *** geekosaur joined
[08:24] <moritz> good antenoon masak

[08:24] <jnthn> o/ masak

[08:24] <moritz> r: my @a := { (state $)++ } ... *; say @a[^5]

[08:24] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤Contextual $*GOAL not found␤»

[08:24] <moritz> \o\ a bug!

[08:25] *** adu left
[08:25] <moritz> http://www.perlmonks.org/?node_id=972105 dunno if that's a bug or not

[08:25] <jnthn> Looks familiar.

[08:27] <masak> it is.

[08:27] <masak> problem is in making the var anonymous.

[08:27] <masak> r: my @a := { (state $camel)++ } ... *; say @a[^5]

[08:27] <p6eval> rakudo 558fd0: OUTPUT«0 1 2 3 4␤»

[08:31] <masak> this one seems closest, and probably has the same ground cause: https://rt.perl.org/rt3/Ticket/Display.html?id=98854

[08:32] <masak> s/ground/root/

[08:40] *** Timbus left
[08:40] *** Timbus joined
[08:44] <timotimo> r: class A { method foo($a) { ... } }; class A { method foo($a) { say $a } }; A().foo(99);

[08:44] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤Redeclaration of symbol A␤at /tmp/_S23zMKgKq:1␤»

[08:45] *** stol_ left
[08:45] <masak> timotimo: what's your use case?

[08:45] <timotimo> defining not-completely-empty classes at the top of a module, then implementing all methods later

[08:46] <timotimo> i know i can class A { ... } and later implement it

[08:46] <moritz> so, do that :-)

[08:46] <timotimo> hm.

[08:46] <masak> or define a role with the methods as { ... }, and have the class do the role.

[08:47] <masak> don't work against the grain of the language ;)

[08:47] <timotimo> that role idea doesn't sound completely bad

[08:47] <timotimo> after all, what i'd be defining is sort of like an "interface" i want the class to implement later

[08:48] <moritz> "the trick is to exploint perl's strengths, not its weaknesses"

[08:48] <timotimo> r: role IFoo { method foo($a) { ... } }; class Foo does IFoo { method foo($a) { say $a + 1 } }; Foo().foo(99)

[08:48] <p6eval> rakudo 558fd0: OUTPUT«No such method 'Foo' for invocant of type 'Parcel'␤  in <anon> at src/gen/BOOTSTRAP.pm:804␤  in <anon> at src/gen/BOOTSTRAP.pm:801␤  in any <anon> at src/gen/BOOTSTRAP.pm:796␤  in block <anon> at /tmp/zXPzx7rHDp:1␤␤»

[08:49] <timotimo> oh, whoops?

[08:49] <masak> Foo, not Foo()

[08:49] <timotimo> right

[08:49] <timotimo> r: role IFoo { method foo($a) { ... } }; class Foo does IFoo { method foo($a) { say $a + 1 } }; Foo.new().foo(99)

[08:49] <p6eval> rakudo 558fd0: OUTPUT«100␤»

[08:49] <timotimo> not bad, not bad.

[08:49] <moritz> roles rock.

[08:49] <masak> +1

[08:49] <timotimo> to someone used to separating implementation and declaration of methods like c++ would, it would seem like a hack

[08:49] <timotimo> but i think it's all right

[08:50] <masak> getting past the high coding standards imposed by C++ can be a challenge :P

[08:53] <moritz> timotimo: curiously most C++ I've recently seen implement all the classes in the headers

[08:53] <timotimo> that's necessary for templates

[08:53] <moritz> right

[08:53] <timotimo> so maybe that's what that was?

[08:53] <timotimo> i've seen non-templated code by some other person at my uni do that, too. perhaps it's some java business leaking into c++ coding?

[08:54] <moritz> well, it's simpler

[08:54] <moritz> and you don't have to restructure your whole build system when you start to use templates

[08:54] *** daxim joined
[08:54] <moritz> and the API docs can be extracted automatically anyway

[08:54] <timotimo> well, that's true

[08:54] <moritz> so yes, just like Java :-)

[08:54] <moritz> not everything that Java does is bad :-)

[08:55] <timotimo> that's true

[08:55] <timotimo> perl6 even goes a bit past the "api doc extraction" with pod, doesn't it?

[08:55] <moritz> oh and speaking of Java, Google won the patent case against oracle

[08:55] <moritz> yes

[08:57] <masak> phew. the case wasn't really ever about anything substantial, but it would've been bad news for Android if Oracle had won.

[08:58] <timotimo> bad news for more than just android

[08:58] <timotimo> for languages in general

[08:58] <moritz> well, and if the judge decides that APIs are copyrightable, that would be a huge mess

[08:58] <moritz> that decision is still pending

[08:59] <timotimo> oh, i thought you meant that was over, too

[08:59] <moritz> no, just the patent case

[08:59] <timotimo> but i read somewhere that the judge himself is a programmer, so i'd think he would understand reasonably well what's at stake here

[08:59] <moritz> he's not a programmer, but he started to learn programming during the trial

[09:00] <tadzik> talk about a dedications

[09:00] <timotimo> ah, that's very good

[09:00] <tadzik> it makes sense to judge something you have at least a vague idea about

[09:00] <tadzik> (that guy)++

[09:00] <moritz> and his second name is Haskell :-)

[09:00] <timotimo> though APIs and all that business is a bit deeper into a programmer's education i'd think

[09:01] <moritz> http://www.fjc.gov/servlet/nGetInfo?jid=2827&cid=999&ctype=na&instate=na

[09:02] <brrt> his second name is seriously haskell

[09:04] * masak .oO( "Do I know Haskell? My middle *name* is Haskell!" ) :P

[09:04] <tadzik> ;)

[09:17] *** NamelessTee joined
[09:17] <moritz> timotimo: but if you learn Java, you at least *use* APIs from the very start (System.out.println for one :-)

[09:17] *** telex joined
[09:19] *** Antichoc joined
[09:21] <Antichoc> Salut à vous

[09:21] <Antichoc> Je cherches quelques informations sur ILBOT, est-ce que quelqu'un connait la procédure d'installation ?

[09:21] <moritz> Antichoc: moi

[09:22] <Antichoc> salut moritz

[09:22] <moritz> Antichoc: do you speak english?

[09:22] <Antichoc> en effet, je pouvais pas mieux tomber

[09:22] <Antichoc> A little but I can try

[09:22] <moritz> Antichoc: and we should go to private message with that

[09:22] <Antichoc> ok

[09:24] *** stol_ joined
[09:24] * moritz -> afk

[09:25] *** Antichoc left
[09:32] *** SatoAmbush joined
[09:33] <timotimo> moritz: that's certainly true, but the concept of different implementations of the same API might not be clear until you progress much further (for instance until someone asks you to implement some specified api or something)

[09:33] <timotimo> although usage of interfaces seems somewhat similar and i believe you do that rather often if you do Swing, but i'm not sure.

[09:35] <tadzik> it depends on how do you think about it. Go for example has no concept of classes, only interfaces

[09:38] <timotimo> interesting. how are implementations of interface-defined methods implemented (or, more interestingly, organised)?

[09:42] <tadzik> you can define methods for any data type (int, string, map[string]int, or whatever struct you name a type)

[09:43] <tadzik> then any type that implements all the required methods implicitly satisfies an interface that requires those

[09:43] <tadzik> so you can, for example, add methods to built-in types to make them satisfy the interfaces you specified elsewhere

[09:44] <tadzik> I quite like the idea of focusing on the behaviours rather than data

[09:48] <timotimo> ah, ok

[09:53] *** sisar left
[09:54] *** sisar joined
[10:04] *** cj left
[10:05] *** cj joined
[10:20] *** stol_ left
[10:24] *** mtk left
[10:42] *** PZt left
[10:46] *** mtk joined
[10:59] *** PZt joined
[11:10] *** benabik left
[11:10] *** sisar left
[11:11] *** JimmyZ joined
[11:12] *** sisar joined
[11:13] *** brrt left
[11:19] *** brrt joined
[11:21] *** brrt left
[11:47] *** sporous left
[11:47] *** sporous joined
[11:48] *** benabik joined
[11:52] *** brrt joined
[11:53] *** jaldhar left
[11:53] *** jaldhar joined
[11:58] *** skids left
[12:26] *** domidumont left
[12:26] *** domidumont joined
[12:27] *** domidumont left
[12:29] *** brrt left
[12:32] *** brrt joined
[12:34] *** sergot joined
[12:34] <sergot> hi o/

[12:34] <phenny> sergot: 23 May 21:18Z <sjn> tell sergot Send sjn the reimbursement receipts! :)

[12:41] *** NamelessTee left
[12:44] *** PZt left
[12:45] *** sftp left
[12:46] *** bluescreen10 joined
[12:46] *** SatoAmbush left
[12:54] *** PacoAir joined
[12:56] *** wooden left
[12:59] *** domidumont joined
[13:02] *** sergot left
[13:02] *** araujo left
[13:07] <Woodi> hallo

[13:07] *** Psyche^ joined
[13:07] <tadzik> hello Woodi 

[13:09] *** bluescreen10 left
[13:11] <Woodi> I was thinking about modules which are "required" for Perl6 and imagined implementing all of them... but CPAN is there, full of *implemented* modules...

[13:11] *** Patterner left
[13:11] *** Psyche^ is now known as Patterner

[13:12] *** bluescreen10 joined
[13:13] <tadzik> right

[13:13] <tadzik> that's where the desire for Perl 5 interop comes from

[13:14] <tadzik> it used to be blizkost, now it's probably going to be done on nqp, or even Rakudo level

[13:15] <tadzik> I wonder how possible would that be to use the C API of Perl 5 through zavolaj to provide some interop

[13:15] <jnthn> tadzik: I'd wondered that too.

[13:15] <tadzik> one could write a Perl5ClassHOW which would be a Perl 6 <-> Perl 5 bridge

[13:16] <jnthn> tadzik: It's probably not the way though.

[13:16] <jnthn> (the zavolaj approach, that is)

[13:16] <tadzik> why not?

[13:16] <jnthn> Well, to really integrate Perl 5 at 6model level you want to write representations, I think.

[13:16] <jnthn> You may well want a custom meta-class too

[13:17] <tadzik> is repr('P5_SV') or such?

[13:17] <tadzik> I'm just wondering what's not possible to be done while having 6model in Rakudo

[13:18] *** araujo joined
[13:18] *** araujo left
[13:18] *** araujo joined
[13:19] <jnthn> tadzik: Kinda like that, yeah.

[13:19] <tadzik> that's Zavolaj-doable

[13:20] <tadzik> (I think)

[13:20] <jnthn> Well, the current design is that REPRs are very low level things, written in C.

[13:20] <sisar> r: say 42.fmt("%05d");

[13:20] <p6eval> rakudo 558fd0: OUTPUT«00042␤»

[13:20] <tadzik> right

[13:20] <sisar> if that 5 is actually in a variable, how do I use it ?

[13:21] <jnthn> sisar: Interpolate it.

[13:21] <tadzik> r: my $five = 5; say 42.fmt("%0$fived");

[13:21] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤Variable $fived is not declared␤at /tmp/6G2cKik85X:1␤»

[13:21] <tadzik> r: my $five = 5; say 42.fmt("%0{$five}d");

[13:21] <p6eval> rakudo 558fd0: OUTPUT«use of uninitialized value of type Any in string context  in block <anon> at /tmp/dBdYaMarA0:1␤␤d␤»

[13:21] <sisar> r: my $i = 5 ; say 42.fmt("%0{$i}d");

[13:21] <p6eval> rakudo 558fd0: OUTPUT«use of uninitialized value of type Any in string context  in block <anon> at /tmp/_zDpu1EJcI:1␤␤d␤»

[13:21] <jnthn> huh...that should work

[13:22] <sisar> jnthn: how ?

[13:22] <jnthn> r: my $i = 5 ; say 42.fmt("%0{say $i; $i}d");

[13:22] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤multi-dimensional indexes not yet implemented. Sorry. ␤at /tmp/ABXb4mMWy4:1␤»

[13:22] <jnthn> oh!

[13:22] <jnthn> r: my $i = 5 ; say 42.fmt("%0$($i)d");

[13:22] <p6eval> rakudo 558fd0: OUTPUT«00042␤»

[13:23] <jnthn> It was treating %0{$i} as a hash index into %0 :)

[13:23] *** wolfman2000 left
[13:23] <tadzik> heh

[13:23] <sisar> how does $($i) work ?

[13:23] <sisar> is $() a function ?

[13:23] <jnthn> sisar: $($i) is really $i.item which for an Int is a no-op

[13:24] <jnthn> No, it's a contextualizer.

[13:24] <jnthn> It's a bit of a hack to use it there

[13:24] <jnthn> May just be nicer not to use interpolation

[13:24] <jnthn> '%0' ~ $i ~ 'd'

[13:25] <jnthn> r: my $i = 5 ; say 42.fmt(Q:b"%0{$i}d");

[13:25] <sisar> r: my $i = 5 ; say 42.fmt(%0~$i~d);

[13:25] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤Colons may not be used to delimit quoting constructs at line 1, near ":b\"%0{$i}d"␤»

[13:25] <p6eval> rakudo 558fd0: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&d' called (line 1)␤»

[13:25] <felher> go geeks

[13:25] <sisar> r: my $i = 5 ; say 42.fmt(%0~$i~'d');

[13:25] <p6eval> rakudo 558fd0: OUTPUT«use of uninitialized value of type Any in string context  in block <anon> at /tmp/Mb3zGMtmqP:1␤␤5d␤»

[13:25] <felher> this should be /go geeks

[13:25] <jnthn> sisar: quoting

[13:25] <felher> *should have been :)

[13:26] *** skids joined
[13:28] <flussence> r: my $i = 5; say 42.fmt($i.fmt('%%0%dd'));

[13:28] <p6eval> rakudo 558fd0: OUTPUT«00042␤»

[13:28] * flussence runs

[13:33] *** JimmyZ left
[13:34] *** sftp joined
[13:34] *** JimmyZ_ joined
[13:34] *** JimmyZ_ is now known as JimmyZ

[13:38] <Woodi> how about parrot lvl perl5 modules integration into all parrot languages ?

[13:39] <tadzik> blizkost tried to do that

[13:39] <tadzik> https://github.com/jnthn/blizkost

[13:39] <tadzik> it worked to some extend

[13:40] <tadzik> see https://github.com/jnthn/blizkost/blob/master/examples/cgi.pl

[13:49] <Woodi> so how about parsing 95% Perl5 with grammars ? :)

[13:49] *** pmurias joined
[13:51] <[Coke]> we really need to write down these historical paths so we can point folks at the story instead of having to tell it all the time.

[13:51] *** fgomez left
[13:51] <[Coke]> ... though I suppose the oral traditions of our forefathers are something to respect. (nah, I'm lazy.)

[13:51] *** fgomez joined
[13:51] <tadzik> Woodi: reimplementing Perl 5 is probably quite tough :)

[13:52] *** fgomez left
[13:52] <masak> [Coke]: full ACK on writing the history down.

[13:52] <masak> both how the language evolves and how the community evolves.

[13:57] *** fgomez joined
[14:00] *** lm joined
[14:02] *** lm left
[14:05] *** mikemol joined
[14:13] *** JimmyZ left
[14:14] *** JimmyZ joined
[14:19] *** brrt left
[14:21] *** sudokode joined
[14:27] *** brrt joined
[14:29] *** JimmyZ left
[14:30] *** kresike left
[14:31] *** Khisanth left
[14:33] *** JimmyZ joined
[14:36] *** JimmyZ left
[14:37] *** JimmyZ joined
[14:37] <tadzik> jnthn: am I right to assume that we'd want Perl 5 interop to be not parrot-dependent, on nqp level?

[14:38] <felher> I'd really like to have a syntax for "call method on $object if $object ist defined", let's say ".#", so that one can write $object.#getA().#getB().#getC(), which just returns the first undefined value, if there is any, or the last value. ".?" is a bit like that, but since undefined objects can have methods, it's not the same. This is a bit like the Maybe-Monad in Haskell. Just do it, or fail somewhere on 

[14:38] <felher> the way. I don't care where.

[14:38] <jnthn> tadzik: I build as little as I can Parrot dependent these days.

[14:38] <felher> Any thoughts on that? :)

[14:38] <tadzik> right

[14:39] <jnthn> felher: Hmm. $obj.//a() would go well with // 

[14:39] <tadzik> I'm looking at blizkost code, particularly ParrotCC to PerlCC conversions, and wonder how much of that can be reused

[14:39] <felher> jnthn: yeah :)

[14:39] <Juerd> felher: Isn't that a matter of temporarily decorating the global undef class (role?) with an autoload method?

[14:39] <masak> felher: ($object // $guard).getA().getB().getC()

[14:40] <masak> felher: *handwaving about how $guard looks*, not so important

[14:40] * PerlJam idly wonders if [.] $obj, $meth1, $meth2, $meth3  works

[14:40] <Juerd> PerlJam: I want it to.

[14:40] <jnthn> No :)

[14:40] <masak> a special object whose metaobject hijacks method dispatch would work.

[14:40] <Juerd> jnthn: Aww, why not? We have .=, so why not [.]?

[14:41] <masak> PerlJam: no, dot pretends to be an operator, but it really isn't.

[14:41] <jnthn> I said it doesn't work, not that it could not be made to.

[14:41] <Juerd> :)

[14:41] <masak> well, at least not an infix operator.

[14:41] <jnthn> masak: Yes, it is just that.

[14:41] <jnthn> .= is a special form.

[14:41] <masak> right.

[14:41] <masak> it's a sham, and it falls apart here.

[14:41] <jnthn> We need to be really careful here.

[14:41] <Juerd> jnthn: I know. I'm still not sure about the whitespace stuff with += versus .= :)

[14:41] <masak> that said, you could easily *define* [.] yourself ;)

[14:41] <jnthn> Because otherwise we bust up the catching of . mis-used for concat

[14:41] <jnthn> std: 'a' . 'b'

[14:41] <p6eval> std 8632387: OUTPUT«Use of uninitialized value $x in pattern match (m//) at STD.pm line 66537.␤Use of uninitialized value $x in concatenation (.) or string at STD.pm line 66576.␤[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/LE…

[14:42] <jnthn> std: [.] 'a', 'b'

[14:42] <Juerd> Personally I don't care much for catching that error.

[14:42] <p6eval> std 8632387: OUTPUT«Use of uninitialized value $x in pattern match (m//) at STD.pm line 66537.␤Use of uninitialized value $x in concatenation (.) or string at STD.pm line 66576.␤[31m===[0mSORRY![31m===[0m␤Unsupported use of . to concatenate strings; in Perl 6 please use ~ at /tmp/G0…

[14:42] <jnthn> STD actually realizes that is the now-gone . op here

[14:42] <felher> masak: the problem is that i would need a guard on every part of the chain that can fail @ ($object // $guard).getA();

[14:43] <Juerd> I don't think the mistake of using . for concatention is likely; you'll have dots for method calls all over the place, as a reminder of the change.

[14:44] * jnthn ponders $foo.:foo('bar')($normal-arg, $another-arg)

[14:44] *** adu joined
[14:44] <jnthn> Where :foo('bar') is passed to .^find_method

[14:44] <masak> r: sub prefix:<[.]> ($obj is copy, *@methods) { for @methods -> &m { $obj = $obj.&m }; return $obj }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] A.new, &A::foo, &A::bar;

[14:44] <p6eval> rakudo 558fd0: OUTPUT«A.new()foobar␤»

[14:44] <masak> aww :)

[14:44] <masak> r: sub prefix:<[.]> ($obj is copy, *@methods) { for @methods -> &m { $obj = $obj.&m }; return $obj }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] (A.new, &A::foo, &A::bar);

[14:44] <p6eval> rakudo 558fd0: OUTPUT«A.new() foo bar␤»

[14:44] <masak> r: sub prefix:<[.]> ($obj is copy, *@methods) { for @methods -> &m { $obj = $obj.&m }; return $obj }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.](A.new, &A::foo, &A::bar);

[14:44] <p6eval> rakudo 558fd0: OUTPUT«A.new() foo bar␤»

[14:44] <masak> aww :)

[14:44] *** Khisanth joined
[14:45] <Juerd> "purl, tell masak about play with the bot"

[14:45] <Juerd> Haven't been there in a decade or so I guess :)

[14:45] <masak> felher: right. so you want to actually wrap the original object using 'but'.

[14:45] <masak> Juerd: what would it have said? I'm doing important research here. :)

[14:46] <Juerd> masak: It'd sneer at you for flooding the channel, and request (demand) that you do things like that in a private conversation with it.

[14:47] <Juerd> I don't really care; it just came to mind.

[14:47] <Juerd> Later many factoids were changed to be much friendlier

[14:48] <masak> I'm glad we don't have a bot for sneering at people.

[14:48] <felher> masak: i don't know if i want that. What i want is a method-call syntax that works like Haskells Maybe-Monad ($object >>= method1 >>= method2 >>= method3 >>= method 4). If this can be achieved with 'but', then that may be exactly what i want :)

[14:48] <masak> sorry if I pushed out too much noise into the channel. it would have been so much more impressive if it'd worked :P

[14:48] <felher> :D

[14:48] <Juerd> masak: #perl on efnet was a very unfriendly channel in many ways. I don't know what that channel is like now.

[14:49] <PerlJam> It would be interesting to have a channel just for bot talk that was logged so that you could refer people to your "research" via links without interrupting the flow of conversation between actual people ;)

[14:49] <Juerd> masak: As I said, I don't really care about the noise. I'm quite intruiged by the code actually.

[14:49] <flussence> felher: seems like "and.=" maybe should work like "and=" does, but it doesn't :(

[14:49] <masak> PerlJam: that presumes that the research isn't part of the flow of conversation between actual people.

[14:49] <PerlJam> indeed.

[14:49] <masak> PerlJam: I wasn't trying random stuff. I was defining up the prefix:<[.]> operator.

[14:50] <Juerd> masak: Maybe you should define infix:<.> instead. I wonder what that will blow up.

[14:50] <masak> ooh

[14:50] <masak> ok, more noise coming up.

[14:51] <masak> r: sub infix:<.>($obj, &method) { $obj.&method }; class A { our method bar { "OH HAI" } }; say A.new . &A::bar

[14:51] <p6eval> rakudo 558fd0: OUTPUT«OH HAI␤»

[14:51] <masak> \o/

[14:51] <felher> flussence: at a first glance, and.= could be what i want, yes. But the nicest syntax was jnthn's .// :)

[14:51] <masak> r: sub infix:<.>($obj, &method) { $obj.&method }; class A { our method bar { "OH HAI" } }; say [.] A.new, &A::bar

[14:51] <p6eval> rakudo 558fd0: OUTPUT«OH HAI␤»

[14:51] <masak> r: sub infix:<.>($obj, &method) { $obj.&method }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] A.new, &A::foo, &A::bar

[14:51] <p6eval> rakudo 558fd0: OUTPUT«OH HAI␤»

[14:51] <masak> \o/

[14:51] <masak> Juerd++

[14:51] <tadzik> hmm

[14:52] <Juerd> Haha

[14:52] <masak> that is pretty awesome.

[14:52] <tadzik> r: sub infix:<.>($obj, $method) { $obj.$method }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] A.new, 'foo', 'bar'

[14:52] <p6eval> rakudo 558fd0: OUTPUT«No such method 'postcircumfix:<( )>' for invocant of type 'Str'␤  in <anon> at src/gen/BOOTSTRAP.pm:811␤  in any <anon> at src/gen/BOOTSTRAP.pm:807␤  in sub infix:<.> at /tmp/owqKTJFJdG:1␤  in sub <anon> at src/gen/CORE.setting:11108␤  in block <anon> at /tmp/owqKT…

[14:53] <masak> tadzik: $obj."$method"()

[14:53] <tadzik> ah, yes

[14:53] <tadzik> r: sub infix:<.>($obj, $method) { $obj."$method"() }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] A.new, 'foo', 'bar'

[14:53] <p6eval> rakudo 558fd0: OUTPUT«OH HAI␤»

[14:54] <tadzik> r: sub infix:<.>($obj, $method) { $obj."$method"() }; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] A.new, <foo bar>

[14:54] <p6eval> rakudo 558fd0: OUTPUT«OH HAI␤»

[14:54] <jnthn> Nice :)

[14:54] <Juerd> This is incredible :)

[14:55] <tadzik> r: module InfixDot { sub infix:<.>($obj, $method) is export { $obj."$method"() } }; import InfixDot; class A { our method foo { self }; our method bar { "OH HAI" } }; say [.] A.new, <foo bar>

[14:55] <p6eval> rakudo 558fd0: OUTPUT«OH HAI␤»

[14:55] <tadzik> . o O ( There's a module for that! )

[14:55] <masak> felher: by tweaking the definition of infix:<.>, you can easily do what you want, too.

[14:55] <adu> I'm getting an infinite recursion in a grammar

[14:55] <adu> so wierd

[14:56] * jnthn decommutes

[14:56] <felher> yeah, [.] looks quite nice. I wonder how i would use arguments with that.

[14:56] <Juerd> felher: Just because you can, doesn't mean you should, use it.

[14:56] <jnthn> Maybe pass a pair :)

[14:57] <jnthn> meth_name => \(args here)

[14:57] <jnthn> ;)

[14:57] * jnthn really goes

[14:57] <felher> o/ jnthn  :)

[14:59] *** thou joined
[15:00] *** tokuhirom joined
[15:00] <PerlJam> Hrm.

[15:00] <adu> Captures are very JavaScripty

[15:01] <PerlJam> Here's an LTA error message: use of uninitialized variable $pos of type Any in numeric context  in block <anon> at ./foo:15

[15:01] <PerlJam> I got it when I accidentally typed  @array[$1]  instead of @array[$i]

[15:03] *** NamelessTee joined
[15:07] <felher> Well, obviously i'd like ".//" to get into the specs. Of course, as masak++ mentioned the last time i wanted something to go into the specs, just because i wan't it or use it often doesn't mean it should get specced. I fully agree on that. The real question is probably: Will it be used enough to say it's worth to spec it instead of having everyone who needs it build it for himself. I think it would be 

[15:07] <felher> feature which won't do something great, but quite a few nice things all over the place. Other questions (which i sadly am not able to answer) are: Is it easy to spec? Is it easy to implement? ...

[15:07] <adu> how do I debug "maximum recursion depth exceeded"?

[15:08] <felher> adu: maybe this helps you: https://github.com/jnthn/grammar-debugger/blob/master/lib/Grammar/Tracer.pm 

[15:09] <felher> adu: i never used it, but i did see it do great things in one of jnthn's talks, think :)

[15:09] <adu> hmm, maybe

[15:09] <adu> if i can figure out how to use it

[15:10] <adu> what does EXPORTHOW.WHO.<grammar> mean?

[15:11] <felher> adu: i think it tells rakudo to use this class as the Meta-Class for grammars.

[15:12] <felher> adu: http://6guts.wordpress.com/2011/08/01/a-hint-of-meta-programming/ might be of interest :)

[15:14] <adu> hmm

[15:14] <adu> ok

[15:17] *** SatoAmbush joined
[15:20] *** JimmyZ_ joined
[15:21] <adu> omg I'm so dense

[15:21] <adu> I was definining token ws { <ws> }

[15:21] <adu> :P

[15:22] <pmurias> Woodi: perlito is a perl5 (re)implementation

[15:22] <felher> Yeah, this could take a while... :)

[15:22] *** JimmyZ left
[15:22] *** JimmyZ_ is now known as JimmyZ

[15:26] <masak> adu: ah, so the reason you got an infinite loop was that you had coded one.

[15:26] <adu> masak: it took awhile to see

[15:26] <adu> but it was actually indirect

[15:26] *** JimmyZ left
[15:27] <adu> token ws { <atmosphere>* } ; token atmosphere { <ws> | <comment> }

[15:28] <masak> ah.

[15:28] <masak> I'm wondering how that translates to a DFA. feels like there should be some problem with recursion there.

[15:29] <adu> DFA?

[15:29] <masak> http://en.wikipedia.org/wiki/Deterministic_finite_automaton

[15:30] <masak> it's to do with parsing.

[15:30] *** alester left
[15:31] <adu> i see

[15:32] *** fglock left
[15:32] *** SatoAmbush left
[15:38] * jnthn home

[15:40] *** PacoAir left
[15:45] *** alester joined
[15:46] <TimToady> felher: see S02:1355

[15:46] <phenny> TimToady: 08:05Z <jnthn> tell TimToady No, there are comments there saying "this probably needs fixing for big-endian". But I didn't manage to get myself access to such a box.

[15:46] * felher sees

[15:47] <felher> better: /me looks for it

[15:47] <adu> jnthn oh, so that's what you mean by "decommutes"

[15:47] * adu thought of some kind of real-life algebraic maneuver 

[15:47] <moritz> \o

[15:48] *** sergot joined
[15:48] <adu> o/^

[15:48] * skids was about to offer access to re-set up his alpha for bigendian tests, but them remembered how much RAM rakudo needs.

[15:48] <skids> *then

[15:48] <sergot> o/

[15:49] <TimToady> masak: the lexer-generator just assumes it should stop when it sees left-recursion, and that something else will constrain it somewhere

[15:50] <TimToady> it could probably usefully emit a warning though

[15:50] <masak> oh yes.

[15:50] <adu> ♪

[15:50] <masak> adu: going home from work *is* some kind of real-life algebraic maneuver :P

[15:50] <adu> masak: :) tell me about it

[15:51] <felher> TimToady: oha. yes, i think this is very similiar to what i wanted and i think i can live with that. Thanks :) TimToady++

[15:51] *** am0c joined
[15:51] <TimToady> I don't know that any implementation actually does that yet...

[15:54] *** tokuhirom left
[15:55] *** tokuhirom joined
[15:59] *** shevy joined
[15:59] <shevy> hi

[15:59] <shevy> when can use perl6 on GNU Hurd please?

[15:59] *** tokuhirom left
[15:59] <brrt> lol

[15:59] <brrt> whenever gnu hurd is done

[16:00] * [Coke] seriously wonders who will get done first!

[16:01] <TimToady> oh, surely gnu hurd

[16:01] <TimToady> Perl 6 is supposed to be a 100-year language

[16:01] <jnthn> Hopefully hurd, because a programming langauge being "done" means it's dead and over with. :)

[16:01] <masak> I wouldn't be surprised if using Perl 6 on GNU Hurd is just a matter of firing up GNU Hurd and compiling Rakudo.

[16:01] <jnthn> It may well actually run there already, yeah.

[16:01] <masak> wouldn't surprise me.

[16:01] <masak> someone should try it, just for kicks.

[16:02] <jnthn> If somebody gets me access to a big endian box running GNU Hurd, we can kill two birds with one stone :P

[16:02] <TimToady> you might have to find yourself a Gnu c compiler...oh wait...

[16:02] <[Coke]> masak: You should totally do that, and post a blog article about it, so that people have one more thing to point and say "see? waste of time."

[16:02] <sorear> meh, the hurd doesn't have to be completely done to run programs

[16:02] <masak> [Coke]: yeah. :)

[16:02] <TimToady> someone should rewrite hurd in Perl 6

[16:02] <masak> [Coke]: I should write a small game in Perl 6 on GNU Hurd, called "Duke Nukem Forever".

[16:02] <moritz> afaict running programs has worked in the hurd for many years

[16:02] *** kaare_ joined
[16:03] <moritz> it's "just" device drivers that are missing

[16:03] <moritz> and some details

[16:03] <sorear> masak: you are aware DNF came out last year?

[16:03] <[Coke]> masak: that would funnier if DNF hadn't shipped yet.

[16:03] * [Coke] stares at sorear.

[16:03] <[Coke]> . o O (GET OUT OF MY MIND!)

[16:03] <masak> the GNU Hurd people are in the really thankless position of chugging along with a project whose relevance is dubious since Linux is so successful. unlike Perl 6, which totally isn't overshadowed by Perl 5 in any way.

[16:04] <masak> sorear, [Coke]: yeah. agree, it would be funnier if DNF hadn't finally shipped.

[16:04] *** wooden joined
[16:04] *** wooden left
[16:04] *** wooden joined
[16:04] <masak> we should call them up and suggest they help us, now that they're between projects and all.

[16:05] *** brrt left
[16:10] *** kaleem left
[16:14] <adu> DNF = disjunctive normal form?

[16:14] <TimToady> Did Not Finish

[16:15] <masak> adu: http://en.wikipedia.org/wiki/Duke_Nukem_Forever

[16:15] <adu> sorear: is that right?

[16:16] * masak looks at the cover art of that Wikipedia article, and thinks "that guy looks like he has some issues..." :)

[16:17] <sorear> adu: look at what masak said

[16:17] <daxim> balls of steel

[16:18] <adu> ah ok

[16:18] <masak> "The game was a financial success but received middling to negative critical notice." -- as opposed to Perl 6, which is loved, despised, ridiculed, and not on the financial radar :P

[16:18] <adu> I don't see why it isn't

[16:18] <moritz> is it just me, or are we having an usually high level of meta discussions these days?

[16:19] <adu> I'm interested in using Perl6 for code quality automation

[16:19] <sorear> masak: incidentally, I am really, really looking forward to a resolution of the is-QC-possible-in-the-real-world question

[16:20] <sorear> adu: Why can't you use Perl 5 for that?

[16:20] <adu> sorear: you can, and for that matter, you can also use brainfuck, it's Turing equivalent

[16:21] <masak> sorear: me too. but I'm squarely on Aaronson's side here. it would be shocking if it weren't. right now it just seems difficult.

[16:21] <TimToady> is Quantum Chromodynamics possible in the real world? eh...

[16:21] <masak> adu: what sorear is saying is that some tools are better suited for the job.

[16:21] <adu> sorear: I think if your going to write an app to do static analysis and check quality of code, it should be written with quality code, and I'm not confident I can do that with Perl5

[16:22] <masak> TimToady: Quantum Computing.

[16:22] <TimToady> I figgered that out.

[16:22] <sorear> masak and I are having a conversation with a time lag of half a day

[16:23] <TimToady> that's about right for the impedance of my brane

[16:24] <sorear> out&

[16:24] <adu> moritz: is it too meta for you?

[16:25] <moritz> adu: no. But often it's more productive to hack than to meta-discuss

[16:26] <masak> not so much meta as OT, I guess.

[16:27] <adu> Google Wave?

[16:27] <masak> and it's probably partly my fault. I like the intelligent discussions that happen here, so I encourage them.

[16:28] <moritz> masak: I don't think you were involved in most of the meta discussions I'm talking about

[16:28] <masak> adu: when you ask a question consisting entirely of a noun phrase, there has to be some surrounding context for the reader to latch on to so that it's possible to derive what you mean. there isn't in this case. what do you mean? :)

[16:28] <masak> moritz: ooc, which ones were you talking about?

[16:29] <[Coke]> TimToady: there is a very excellent book about branes and the origin (sort of) of the universe. wish I could remember the title.

[16:29] <moritz> masak: all of those tha occured within that last (or last two) weeks

[16:29] <adu> masak: do you mean OT = operational transform? the kind used in the now dead Google Wave (r.i.p)?

[16:29] <[Coke]> adu: OT == off topic

[16:29] <adu> oh

[16:29] <masak> adu: ah! that was the missing link. thank you.

[16:29] <adu> too many TLAs

[16:29] * [Coke] does miss the factoid boid.

[16:30] <[Coke]> er... factoid bot!

[16:30] <[Coke]> aloha, OT?

[16:30] <[Coke]> aloha, coke?

[16:30] <TimToady> OT isn't a TLA, it's only a TLA.

[16:30] *** wooden left
[16:30] <adu> lol

[16:31] <adu> how do I make a bot remember that

[16:32] <TimToady> the meatbots remember it automatically

[16:32] <masak> terribly useful, those bags of meat.

[16:32] * adu goes to lunch

[16:33] *** adu left
[16:38] <shevy> pls that helped me not I install hurrd now

[16:38] *** shevy left
[16:38] *** mucker joined
[16:40] <masak> "help-me-not", the lesser known flower of the Myosotis genus. fiercly independent.

[16:40] <masak> fiercely*

[16:44] *** daxim left
[16:45] *** felher left
[16:46] *** PacoAir joined
[16:46] *** fgomez left
[16:53] *** sergot_ joined
[16:56] *** sergot left
[17:12] *** birdwindupbird left
[17:13] <moritz> http://quasimal.com/posts/2012-05-21-funsh.html

[17:13] <moritz> now that's some nice evil

[17:17] *** fhelmberger left
[17:38] *** adu joined
[17:42] *** felher joined
[17:43] *** japhb left
[17:44] *** birdwindupbird joined
[17:45] <sisar> r: say 12345678910.fmt("%11d");

[17:45] <p6eval> rakudo 558fd0: OUTPUT« -539222978␤»

[17:45] <sisar> ^bug .

[17:46] <sisar> n: say 12345678910.fmt("%11d");

[17:46] <p6eval> niecza v17-23-gfb775fb: OUTPUT«-2147483648␤»

[17:46] <sisar> ^bug.

[17:47] <sisar> it works upto %10d, but gives wrong output on %11d

[17:47] <sisar> r: say 1234567891.fmt("%10d");

[17:47] <p6eval> rakudo 558fd0: OUTPUT«1234567891␤»

[17:47] * masak submits rakudobug

[17:47] * masak submits nieczabug

[17:47] <sisar> masak++

[17:47] <moritz> it's known, afaict

[17:48] <sisar> i wonder what  is so special about 11 ?

[17:48] <masak> moritz: in RT? but not for Niecza?

[17:48] <moritz> at least we know that rakudo's fmt/sprintf cannot handle bigints, and that's just one more instance of it

[17:48] <masak> sisar: looks like just 2**31 to me.

[17:48] <moritz> masak: I think there's one in RT about $bigint.fmt('%b') or so

[17:48] <masak> ok, good.

[17:48] <sisar> masak: right.

[17:49] <moritz> r: sprintf('%d')

[17:49] <p6eval> rakudo 558fd0: OUTPUT«Null PMC access in get_integer()␤  in sub sprintf at src/gen/CORE.setting:1998␤  in block <anon> at /tmp/rQ0P1gF2cp:1␤␤»

[17:49] <moritz> nearly the same underlying problem

[17:49] <[Coke]> r: say Whatever.fmt("%03i");

[17:49] <p6eval> rakudo 558fd0: OUTPUT«No such method 'fmt' for invocant of type 'Whatever'␤  in block <anon> at /tmp/ru47CAJ1KO:1␤␤»

[17:49] <sisar> it hurts when both compilers bite you with the same bug !

[17:49] <[Coke]> r: say "»ö«".fmt("%03i");

[17:49] <p6eval> rakudo 558fd0: OUTPUT«000␤»

[17:50] <moritz> sisar: that's because it's a rather deep bug

[17:50] <sisar> or maybe niecza<->rakudo copied each other's bug ? :p

[17:50] <moritz> another bug is that sprintf uses native types to convert between numbers

[17:50] <sisar> s/bug/code

[17:51] <moritz> so that if you have a format that coerces a bigish float to int, you'll hit the system's integer limit

[17:51] <sisar> I still don't know the difference between int and Int? and the term 'boxing'.

[17:51] <moritz> sisar: well, both use the underlying parrot/CLR sprintf

[17:51] <moritz> an Int can store arbitrarily large numbers

[17:51] <moritz> p6: say 2**66

[17:51] <p6eval> pugs, rakudo 558fd0, niecza v17-23-gfb775fb: OUTPUT«73786976294838206464␤»

[17:52] <moritz> you can't do that with int. int is limited to whatever your processor, OS and VM understand as integer

[17:52] <sisar> oh int is your int from C, which depends from system to system.

[17:52] <[Coke]> sisar++

[17:52] <moritz> and an int is not a "real" object; you cannot call methods on it (if it seems like you can, that's because it has been boxed into an Int for you)

[17:52] <[Coke]> boxing == putting int "in a box" so it can be treated like an Int.

[17:53] <PerlJam> sisar: boxing is wrapping a value type in an object and then using the object

[17:53] <[Coke]> unboxing - take out of the box. autoboxing - convert between the two without any programmer effort, if possible.

[17:53] <sisar> so C is not so portable after all.

[17:53] <geekosaur> oh dear

[17:53] <geekosaur> C has never been very portable

[17:53] <moritz> sisar: C is just more portable than assembler; that's all :-)

[17:54] <sisar> or maybe boxing == box together as many system int's as needed to store an Int.

[17:54] <dalek> rakudo/nom: 32a6d06 | moritz++ | src/core/operators.pm:

[17:54] <dalek> rakudo/nom: make sequence deduction not assume numbers

[17:54] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32a6d063a4

[17:54] <sisar> moritz++, [Coke]++, PerlJam++, geekosaur++ #explanations

[17:55] <PerlJam> C is *incredibly* portable ... as long as you don't mind potentially large semantic differences between platforms   ;)

[17:55] <dalek> roast: d73fb04 | moritz++ | S03-sequence/nonnumeric.t:

[17:55] <dalek> roast: a non-numeric sequence test

[17:55] <dalek> roast: review: https://github.com/perl6/roast/commit/d73fb042d1

[17:55] <geekosaur> despite the efforts of various standards groups, any real program is going to have a maze of compatibility #defines and #ifdefs somewhere.  autoconf and Metaconfig are tools to set up all the compatibility defines that let you pretend C is slightly portable

[17:55] *** pmurias left
[17:58] <sisar> if I remember correctly, realizing that C's int was not the same for all computers, came really as a setback to me. I remember being felt cheated or something...

[17:59] <sisar> that was my first setback with programming language

[17:59] <PerlJam> It's a shock to some people.

[17:59] *** Chillance joined
[17:59] <sisar> it gives me a warm feeling that Perl6 Int is _same_ everywhere :)

[18:00] <moritz> modulo bugs, of course :-)

[18:00] *** fgomez joined
[18:01] <PerlJam> I remember helping a guy with some code that talked to a sensor.  He couldn't understand why the sensor in ascii mode gave different numbers than when he unpacked the sensor data that was transmitted in binary mode.   The machine he was unpacking on had a different endianness than the sensor.

[18:01] <sisar> bugs are just hurdles. the fact that C99 deliberately left it to the compiler to decide int's length was a setback.

[18:06] *** fgomez left
[18:09] *** estrabd left
[18:12] <moritz> did TestML ever work?

[18:12] *** aes joined
[18:17] <aes> perl6: say 666;

[18:17] <p6eval> pugs, rakudo 32a6d0, niecza v17-23-gfb775fb: OUTPUT«666␤»

[18:18] <dalek> rakudo/nom: 2b36193 | moritz++ | src/core/ (2 files):

[18:18] <dalek> rakudo/nom: switch to strict numification by default

[18:18] <dalek> rakudo/nom: 

[18:18] <dalek> rakudo/nom: But allow numification of '' to 0 without failure

[18:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2b36193aa3

[18:18] <dalek> rakudo/nom: 525a664 | moritz++ | docs/ChangeLog:

[18:18] <dalek> rakudo/nom: update ChangeLog

[18:18] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/525a66434a

[18:18] <moritz> ok, this might be a pretty big change for our users

[18:18] <moritz> so, everyone please test (and fix) their code after this commit :-)

[18:19] <aes> perl6: my @blocks := (0..*).map: -> $n { -> $x, $y { $x * $y * $n } };

[18:20] <p6eval> niecza v17-23-gfb775fb: OUTPUT«Potential difficulties:␤  @blocks is declared but not used at /tmp/owaqaEmWKh line 1:␤------> [32mmy [33m⏏[31m@blocks := (0..*).map: -> $n { -> $x, $y[0m␤␤»

[18:20] <p6eval> ..pugs: OUTPUT«(timeout)»

[18:20] <p6eval> ..rakudo 32a6d0:  ( no output )

[18:20] <jnthn> r: say 666 ** 666

[18:20] <p6eval> rakudo 32a6d0: OUTPUT«2715417592887128558260874551700217860278385210650169871782230046965783675347846036880134178612873170810403693946181369253763907767348141423592699549814385853090580057925757772865477669740320306227094006360766303376954723573441938832586188596016367470293927056824802…

[18:20] <jnthn> aes: You need "say" or something to get it to output.

[18:21] <moritz> but don't "say" the whole thing; it's infinite :-)

[18:21] <jnthn> er, though that looks to be making a lazy list of closures too :)

[18:21] <moritz> r: say (666 ** 666).chars

[18:21] <p6eval> rakudo 32a6d0: OUTPUT«1881␤»

[18:21] <aes> Howdy moritz.

[18:21] <moritz> r: say log(666, 10) * 666

[18:21] <p6eval> rakudo 32a6d0: OUTPUT«1880.43383662742␤»

[18:21] <moritz> r: say ceiling log(666, 10) * 666

[18:21] <p6eval> rakudo 32a6d0: OUTPUT«1881␤»

[18:22] <moritz> hello aes 

[18:22] <sergot_> nom: my $s = 'aaa'; $s ~~ s:g/a//; say $s;

[18:22] <p6eval> rakudo 32a6d0: OUTPUT«␤»

[18:22] <sergot_> nom: my $s = 'aaa'; $s ~~ s/a+//; say $s;

[18:22] <p6eval> rakudo 32a6d0: OUTPUT«␤»

[18:22] <jnthn> hah...if we implemented "cat" then "ceiling cat" is valid Perl 6... :)

[18:23] <jnthn> ...and useless. :)

[18:23] *** [particle] left
[18:23] *** alester left
[18:23] <aes> perl6: my @blocks := (0..*).map: -> $n { -> $x, $y { $x * $y * $n } }; say @blocks[0].(3,5), @blocks[1].(3,5), @blocks[2].(3,5);

[18:23] *** alester joined
[18:23] <p6eval> rakudo 32a6d0, niecza v17-23-gfb775fb: OUTPUT«01530␤»

[18:23] <p6eval> ..pugs: OUTPUT«(timeout)»

[18:24] *** fibo joined
[18:24] *** [particle] joined
[18:25] <moritz> Q: how can a vocabular trainer be political? A: by teaching you 'priest' right after 'plague' :-)

[18:25] <moritz> so happened on memrise.com while trying to learn bokmål

[18:27] *** mikemol left
[18:27] *** araujo left
[18:27] *** ponpon left
[18:27] *** aes left
[18:28] *** ponpon joined
[18:28] *** bluescreen10 left
[18:28] *** takesako left
[18:29] *** ponpon is now known as Guest26382

[18:29] *** araujo joined
[18:29] *** bluescreen10 joined
[18:31] *** takesako joined
[18:33] *** PacoAir left
[18:33] *** PacoAir joined
[18:34] *** aes joined
[18:35] <eiro> masak, jnthn, tadzik: any news about your flight ? rafl is trying to find his way to fpw. if we have a tight flight schedule at the same airport, maybe i can take you by car 

[18:35] <eiro> also josette 

[18:36] <eiro> and maybe mst 

[18:36] <[Coke]> NOT MST!

[18:37] <[Coke]> jnthn: DOOOO IT

[18:37] <[Coke]> can can be an alias for print!

[18:37] <[Coke]> *cat

[18:37] <eiro> damn it! fpw at Strasbourg and rafl will be the only one german! such a shame! 

[18:38] <jnthn> eiro: No, I didn't look at flights yet...will try and figure something out soon :)

[18:38] <jnthn> [Coke]: cat is already in the spec, iirc

[18:39] <eiro> ok

[18:40] <jnthn> [Coke]: Yes, S03 :)

[18:42] <tadzik> eiro: I'll probably be able to get to FPW :)

[18:43] <tadzik> My last exam is 28th

[18:43] <eiro> tadzik, YEAH! 

[18:43] <tadzik> \o/

[18:44] <moritz> $ perl6 -Ilib -e 'say $*PROGRAM_NAME'

[18:44] <moritz> -Ilib

[18:44] <moritz> /o\

[18:44] <diakopter> once I get around to reading S03, I expect I will start fuzzing a lot more again.

[18:45] <diakopter> skimming through it, I realize I haven't read it ever, or at least don't remember doing so.

[18:45] <diakopter> no wonder I don't understand list context

[18:45] * tadzik decomutees

[18:48] *** mucker left
[18:50] *** brrt joined
[18:50] <masak> I'm not sure S03 will help so much with list context.

[18:51] <diakopter> oh :'(

[18:51] * masak submits $*PROGRAM_NAME bug

[18:52] <aes> r: my @blocks := (0..*).map: -> $n { -> $x, $y { $x + $y + $n } }; say @blocks[0].(3,5); say @blocks[1].(3,5); say @blocks[2].(3,5);

[18:52] <p6eval> rakudo 32a6d0: OUTPUT«8␤9␤10␤»

[18:53] <aes> r: my @blocks := (0..*).map: -> $n { -> $x, $y { $x + $y + $n } }; say @blocks[2].(3,5); say @blocks[1].(3,5); say @blocks[0].(3,5);

[18:53] <p6eval> rakudo 32a6d0: OUTPUT«10␤9␤8␤»

[19:00] *** fgomez joined
[19:05] <masak> diakopter: I would turn to S07 for that. but be aware that S07 has been pending revision for a long time.

[19:06] *** Antichoc-Mob joined
[19:07] <Antichoc-Mob> moritz, 

[19:08] <Antichoc-Mob> i have a problème

[19:08] <Antichoc-Mob> i chant sray connecting

[19:08] <moritz> Antichoc-Mob: if you are not in a hurry, we can try tomorrow, in the hope that your connection is more stable then

[19:09] <Antichoc-Mob> tes

[19:09] <Antichoc-Mob>  wich time do you prefer?

[19:10] <Antichoc-Mob> yes sorry

[19:10] <masak> just show up; we'll be around to help you :)

[19:11] <Antichoc-Mob> ok i m connecting tommorow all the day..

[19:12] <Antichoc-Mob> sorry 

[19:12] <moritz> no problem

[19:12] <moritz> masak: Antichoc-Mob is looking for help with the IR clogs, not with Perl 6, I'm afraid :-)

[19:15] <[Coke]> whoa. I just showed my daughter a screen of an app I'm working on for work, and she got excited, and proceeded to describe to me the binary search I explained to her months ago the last time I was working from home. sweet.

[19:15] <moritz> wow.

[19:17] *** aes left
[19:17] <[Coke]> (4th grader)

[19:17] *** dukeleto joined
[19:18] <moritz> does that mean ~10 years old?

[19:18] <masak> moritz: oh, I see.

[19:19] <masak> [Coke]: daughter++

[19:20] *** brrt left
[19:21] *** aesundstrom joined
[19:26] <[Coke]> moritz: 9

[19:27] *** Guest26382 is now known as ponpon

[19:28] <moritz> nqp: try { pir::die('foo'); CATCH { pir::exit(1) } }; say 'alive'

[19:28] <p6eval> nqp: OUTPUT«Confused at line 1, near "say 'alive"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22008 (src/stage2/gen/NQPHLL.pir:7047) (src/stage2/gen/NQPHLL.pm:329)␤»

[19:28] <moritz> nqp: try { pir::die('foo'); CATCH { pir::exit(1) } }; say('alive')

[19:28] <p6eval> nqp:  ( no output )

[19:29] *** NamelessTee left
[19:35] *** adu left
[19:39] *** Antichoc-Mob left
[19:48] *** bluescreen10 left
[19:52] <dalek> nqp/toqast: a5d179c | masak++ | src/QAST/Operations.nqp:

[19:52] <dalek> nqp/toqast: [QAST::Operations] simplified copy/pasted code some

[19:52] <dalek> nqp/toqast: 

[19:52] <dalek> nqp/toqast: Not using this variable; removing it.

[19:52] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/a5d179c5bb

[19:52] <dalek> nqp/toqast: a6c9a36 | masak++ | / (2 files):

[19:52] <dalek> nqp/toqast: [QAST::Operations] implement repeat_while/repeat_until

[19:52] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/a6c9a36d59

[19:54] <dalek> nqp/qbootstrap: 2e354d1 | jnthn++ | src/QHLL/Grammar.pm:

[19:54] <dalek> nqp/qbootstrap: Toss a couple of commented out lines from debugging/updating.

[19:54] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/2e354d13a8

[19:55] *** aesundstrom left
[19:58] *** aesundstrom joined
[19:58] *** sergot_ left
[20:02] *** am0c left
[20:04] *** fgomez left
[20:05] <moritz> nqp: class A { }; if nqp::create(A) { say('true') }

[20:05] <p6eval> nqp: OUTPUT«true␤»

[20:10] *** Facefox left
[20:12] <dalek> nqp: c4cc06a | moritz++ | src/HLL/Compiler.pm:

[20:12] <dalek> nqp: expose parsed command line options and arguments to the user

[20:12] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c4cc06a1f9

[20:13] *** Facefox joined
[20:14] *** thou left
[20:15] <dalek> rakudo/nom: 5da3671 | moritz++ | / (2 files):

[20:15] <dalek> rakudo/nom: fix $*PROGRAM_NAME in the presence of command line options

[20:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5da3671100

[20:16] *** DreamingInCode joined
[20:29] *** brrt joined
[20:31] *** brrt left
[20:34] *** sivoais left
[20:37] *** sivoais joined
[20:41] *** NamelessTee joined
[20:45] *** fgomez joined
[20:46] <masak> good $night, #perl6

[20:46] <tadzik> 'night

[20:46] <raiph> http://www.tbray.org/ongoing/When/200x/2009/09/27/Concur-dot-next

[20:48] *** aesundstrom left
[20:50] *** fgomez left
[20:51] *** fibo left
[20:53] *** birdwindupbird left
[20:54] <raiph> (Lots of great stuff such as "Ingredients that might go into the winning formula that brings concurrent programming to the mainstream.")

[20:56] *** kaare_ left
[21:00] *** tyatpi left
[21:00] <DreamingInCode> raiph: This is indeed good stuff. Traditional imperative programming hits a brick wall at a certain point, and it's a big question mark as to how to solve this problem pragmatically. Unfortunately most concurrent programming languages seem to be ill suited to this type of task from a developer standpoint.

[21:01] <raiph> http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies.html

[21:06] *** Facefox left
[21:06] <raiph> http://lambda-the-ultimate.org/node/3465 # nice overview of programming paradigms

[21:06] *** skids left
[21:07] <raiph> DreamingInCode: I've been digging around the net, provoked by the comments to http://www.reddit.com/r/perl/comments/u1y3z/larry_wall_primary_author_of_perl_on_productizing/ 

[21:08] *** bruges left
[21:09] *** benabik left
[21:10] *** bruges joined
[21:12] *** aesundstrom joined
[21:12] *** Antichoc joined
[21:13] *** tyatpi joined
[21:13] <jnthn> Today's lesson: Parrot's ResizableIntegerArray doesn't give you a zeroed out array. 

[21:14] <jnthn> (Unfun way to discover this: your NFA seemingly randomly trims branches when it shouldn't, because sometimes you get unlucky enough to ahve exactly the "right" values in there chunk of memory you get...)

[21:15] <DreamingInCode> Even at this late date, I suspect the broader engineering community has a poor level of comprehension of just how scary and non-scalable traditional threading models are. 

[21:19] <jnthn> (fwiw, Parrot doesn't anywhere I can see promise to zero 'em, so it's not a bug. Just a bad assumption to took a while to track down...)

[21:19] <PerlJam> jnthn: seems like that's a good promise for parrot to make if it wanted to though

[21:20] <diakopter> jnthn: I can imagine there being *lots* of places you'll want to update to zero things yourself now.  Or write a version of RIA that zeroes and use that instead.

[21:21] <jnthn> diakopter: We don't use RIAs all that heavily. But I am gonna go audit places I do.

[21:22] *** aesundstrom left
[21:25] *** aesundstrom joined
[21:25] *** fgomez joined
[21:26] <dalek> nqp/qbootstrap: 7da814f | jnthn++ | src/ops/nqp.ops:

[21:26] <dalek> nqp/qbootstrap: Turns out that ResizableIntegerArrays aren't zeroed to start with, which caused random failures when running NFAs. This fixes the various sporadic, seemingly random parse failures under qbootstrap.

[21:26] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/7da814f54a

[21:29] *** fgomez left
[21:30] *** aesundstrom left
[21:30] *** aesundstrom joined
[21:36] <raiph> DreamingInCode: Agreed. From the tbray link: "very hard to find humans who can actually reason about threads well enough to be usefully productive."

[21:37] <flussence> I tried writing threaded p5 code a while back in $dayjob. Did not go well...

[21:39] <DreamingInCode> In theory the solution is simple: use haskell. lol. However turning your brain (and your database driven application) inside-out to do that is non-trivial.

[21:43] <DreamingInCode> same goes for any language that is decent with concurrency far as I'm aware. We humans prefer to think linearly, which requires more mental gymnastics than are practical when you have to "get shit done" (TM)

[21:43] <DreamingInCode> So instead, we bide our time, clinging to our imperative programming for as long as our hardware will bear. sucks

[21:46] *** aesundstrom left
[21:49] *** aesundstrom joined
[21:49] *** libertyprime left
[21:49] *** aesundstrom left
[21:50] *** raiph left
[21:51] *** libertyprime joined
[21:52] *** PacoAir left
[21:53] *** Antichoc left
[21:59] *** thou joined
[22:07] *** tyatpi left
[22:07] *** dukeleto left
[22:11] *** lestrrat left
[22:13] *** lestrrat joined
[22:16] *** benabik joined
[22:20] <dalek> nqp/qbootstrap: c13c4e2 | jnthn++ | src/QHLL/Actions.pm:

[22:20] <dalek> nqp/qbootstrap: Fix :w quotemod check in action method (this is faster than what was done before, though it probably shoulda still worked the way it originally was). This means qbootstrap is down to just three test files with failures in t/nqp.

[22:20] <dalek> nqp/qbootstrap: review: https://github.com/perl6/nqp/commit/c13c4e2cad

[22:32] *** tokuhirom joined
[22:32] * diakopter prepares to push fixes to grammaros and typos in S03. I like editing.

[22:32] *** skids joined
[22:33] *** NamelessTee left
[22:43] *** PZt joined
[22:45] *** lestrrat left
[22:46] *** lestrrat joined
[22:49] *** tyatpi joined
[22:54] *** fgomez joined
[22:57] *** mikemol joined
[22:58] *** fgomez left
[23:01] *** wolfman2000 joined
[23:09] *** whiteknight joined
[23:10] *** whiteknight is now known as Guest57249

[23:16] *** Chillance left
[23:17] *** stephenlb joined
[23:20] *** wolfman2000 left
[23:28] *** lestrrat left
[23:28] <diakopter> std: say({3}␤,3)

[23:28] <p6eval> std 8632387: OUTPUT«[31m===[0mSORRY![31m===[0m␤Unable to parse argument list at /tmp/0KxtvRAqnz line 1:␤------> [32msay[33m⏏[31m({3}[0m␤Couldn't find final ')'; gave up at /tmp/0KxtvRAqnz line 2:␤------> [32m<BOL>[33m⏏[31m,3)[0m␤    expecting any of:␤ argument list␤  block␤  p…

[23:29] *** lestrrat joined
[23:30] <jnthn> .u ␤

[23:30] <phenny> U+2424 SYMBOL FOR NEWLINE (␤)

[23:30] <sorear> note, p6eval munges U+2424 into U+000A on input

[23:30] <jnthn> oh!

[23:30] <diakopter> oh, heh

[23:31] <diakopter> oops. I meant to put a newline there

[23:31] <diakopter> oh. now I see what you're saying sorear

[23:35] <diakopter> I was testing something I read in S03 (that }␤ terminates an argument list)

[23:35] <diakopter> r: say({3}␤,3)

[23:35] <p6eval> rakudo 5da367: OUTPUT«Block.new()3␤»

[23:36] *** fgomez joined
[23:37] <diakopter> n: say(|@(|@(3,5)))

[23:37] <p6eval> niecza v17-23-gfb775fb: OUTPUT«35␤»

[23:37] <diakopter> r: say(|@(|@(3,5)))

[23:37] <p6eval> rakudo 5da367: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&prefix:<|>' called (line 1)␤»

[23:38] <diakopter> pugs: say(|@(|@(3,5)))

[23:38] <p6eval> pugs: OUTPUT«35␤»

[23:39] *** fgomez left
[23:39] *** DreamingInCode left
[23:39] *** fgomez joined
[23:43] <dalek> specs: a2c0304 | (Matthew Wilson)++ | S03-operators.pod:

[23:43] <dalek> specs: first batch of my S03 typo/grammaro fixes

[23:43] <dalek> specs: review: https://github.com/perl6/specs/commit/a2c0304603

[23:43] <diakopter> ergh. my git username is still wrong.

[23:44] <diakopter> there, fixed I think

[23:53] *** wolfman2000 joined
[23:54] *** Facefox joined
[23:54] *** DreamingInCode joined
