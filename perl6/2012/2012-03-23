[00:11] *** wolfman2000 joined
[00:14] <dalek> rakudo/nom: c2f008d | pmichaud++ | src/core/Array.pm:

[00:14] <dalek> rakudo/nom: Make use of existing scalar instead of repeating getattr.

[00:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c2f008db49

[00:14] <dalek> rakudo/nom: e2ebf39 | pmichaud++ | src/core/Array.pm:

[00:14] <dalek> rakudo/nom: Add a comment to hotpath checks added in c10792f (RT #111848).

[00:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e2ebf3993c

[00:16] *** havenn joined
[00:27] *** jferrero left
[00:32] <sorear> good * #perl6

[00:35] *** localhost left
[00:36] *** localhost joined
[00:40] *** havenn left
[00:43] *** havenn joined
[00:53] <japhb> sorear, I forget ... which distro do you use?  And if it is Ubuntu or Debian, what are your thoughts on/experience with using badgerports to get a modern mono for an Ubuntu 11.04 system?

[01:02] <sorear> I use debian sid.  I have never touched badgerports.

[01:02] <japhb> Ah well.

[01:02] <sorear> debian has modern mono now; for a long time I was using a mono built from source

[01:03] <sorear> it's a little involved, but much less so than (say) building a kernel

[01:03] <sorear> took around 70 minutes on the dinosaur

[01:05] <japhb> Yeah, and it appears from http://mono-project.com/DistroPackages/Ubuntu that 12.04 LTS will have a modern Mono, but sadly the Ubuntu I'm running (11.04) is from just before the 2.10 transition.

[01:05] <japhb> Since I don't want to wait for the end of April to get a full-speed Niecza ... I'm considering risking the death of F-Spot and using badgerports.

[01:06] <sorear> if you want safety, build your own mono

[01:06] <sorear> then it'll go in /usr/local and you can play with $PATH

[01:07] <sorear> use --prefix=/opt/mono-2.10 if you're really paranoid, and nuke the whole tree when you're done

[01:08] <sorear> (the latter will require fiddling with more variables; see http://www.mono-project.com/Parallel_Mono_Environments )

[01:08] <sorear> google-- # making it difficult to copy links from search results

[01:09] <japhb> google-- # Not being DuckDuckGo

[01:09] <japhb> :-)

[01:10] *** jferrero joined
[01:12] *** Chillance left
[01:13] *** scott_ joined
[01:14] *** scott_ is now known as Guest81734

[01:33] *** havenn left
[01:39] *** mucker left
[01:43] *** shinobicl___ joined
[01:48] *** mucker joined
[02:02] <japhb> New HPatMoR chapter up ...

[02:03] * japhb prepares to settle in for a long Mono build while reading.  :-)

[02:03] <sorear> "long"?

[02:04] <sorear> it always built faster than Rakudo for me.

[02:04] <TimToady> maybe he meant 32 bits :)

[02:05] <japhb> sorear, pretty old 32-bit laptop.  And for Rakudo, I tend to start a build and then go do something else for a while.  I expected much the same.  :-)

[02:05] *** whiteknight left
[02:05] <japhb> Oy vey, just cloning the Git repo is taking a while.

[02:07] *** sisar joined
[02:20] <jnthn> evening, #perl6

[02:21] <colomon> o/

[02:23] <jnthn> Ooh, more pmichaud++ patches

[02:23] <sorear> it's funny that people have to say 32 bits now.

[02:23] <sorear> o/ jnthn , colomon , sisar 

[02:24] <sisar> sorear, hi :)

[02:32] *** alester joined
[02:34] *** sisar left
[02:34] <jnthn> masak++ # release

[02:39] *** cbk1090 left
[02:41] *** pyrimidine left
[02:44] <colomon> ooo, masak++

[02:44] <japhb> Damn.  Chapter finished before compile.  :-(

[02:46] *** cogno joined
[02:50] *** ascent_ left
[02:57] *** REPLeffect left
[03:01] *** cogno left
[03:02] *** Guest18067 left
[03:05] *** cogno joined
[03:06] *** benabik joined
[03:07] *** ascent_ joined
[03:07] <japhb> Sheesh.  At this point, it's pretty clear mono is taking longer to build than Rakudo does.  By a fair margin, methinks.

[03:14] *** REPLeffect joined
[03:18] *** cogno left
[03:22] *** lestrrat left
[03:23] *** jferrero left
[03:23] *** lestrrat joined
[03:26] <pmichaud> jnthn: ping

[03:26] <jnthn> pmichaud: pong

[03:26] <pmichaud> I forgot you were in the western hemisphere :)

[03:27] <pmichaud> not used to that

[03:27] *** jferrero joined
[03:27] <pmichaud> I think we may be to the point where we need a container type that is equivalent to Scalar but also flattens

[03:27] <jnthn> :)

[03:28] <jnthn> OK

[03:28] <pmichaud> this might also be useful to finally fix the array/hash initialization issue (which somehow got dropped from NOMMAP)

[03:28] <jnthn> Can it not be a flag on scalar? Or do you want a type differentiation?

[03:28] <jnthn> (we already have space for a flag)

[03:29] <pmichaud> I'm fine with making it a flag on scalar, but that means you would likely need to set the flag on every scalar that gets created

[03:29] <pmichaud> and several things become flag checks instead of type checks

[03:29] <jnthn> Hm

[03:29] <jnthn> Well, and sometimes you need the type check to know you can flag check :)

[03:29] <pmichaud> it feels to me like it ought to be a base class of scalar

[03:30] <pmichaud> *Scalar

[03:30] <jnthn> Scalar is a perfectly normal object these days, so that should be no problem.

[03:30] <pmichaud> and then Scalar is the type that we use for non-flattening things

[03:30] <jnthn> What would you call the other one?

[03:30] <jnthn> Container? :)

[03:30] <pmichaud> Container works for me

[03:31] <pmichaud> but since that gets reasonably low-level I figured you'd be the person to come up with the appropriate name

[03:31] <pmichaud> even just Variable works :)

[03:31] <japhb> phenny, ask sorear I've compiled and 'make install'ed the base mono into /opt/mono/ .  What other mono-related repos (presumably mostly under https://github.com/mono ) should I clone/build/install to get Maximum Happiness (tm) from niecza?

[03:31] <phenny> japhb: I'll pass that on when sorear is around.

[03:31] <sorear> pmichaud: Huh?

[03:31] <phenny> sorear: 03:31Z <japhb> ask sorear I've compiled and 'make install'ed the base mono into /opt/mono/ .  What other mono-related repos (presumably mostly under https://github.com/mono ) should I clone/build/install to get Maximum Happiness (tm) from niecza?

[03:32] <sorear> I hear you trying to change the Perl 6 bottom turtles in the background, I vanna know what's up

[03:32] <pmichaud> I'm trying to get rakudo to match the spec.  :-)

[03:32] <pmichaud> Rakudo's bottom turtles don't match the spec's bottom turtles

[03:32] <pmichaud> so, I'm really fixing Rakudo's bottom turtles, not Perl 6's

[03:32] <pmichaud> :-)

[03:32] <sorear> is this an S09 thing?

[03:33] <pmichaud> not really

[03:33] <pmichaud> rakudo:  my @a;  say @a.defined;  

[03:33] <p6eval> rakudo e2ebf3: OUTPUT«True␤»

[03:33] <pmichaud> I suspect that should be False.

[03:33] <sorear> japhb: glib is the only library that niecza will automatically use without asking

[03:33] *** mucker left
[03:33] <sorear> pmichaud: I don't understand how that can be False in any reasonable model

[03:34] <pmichaud> sorear: my understanding is that arrays and hashes aren't defined until they have a value assigned to them.  this has been discussed before; most recently last summer

[03:35] <pmichaud> Rakudo has mis-implemented this for quite some time; it's been on the "to do" list for fixing for a while also.

[03:35] <pmichaud> let me see if I can find the relevant #perl6 discussions

[03:36] <sorear> I think this is completely insane.  Niecza has implemented the sane version for a while ;)

[03:36] <sorear> I'd be interested in knowing what model you're using, since you seem to not think it is insane.

[03:36] <pmichaud> sorear: it's not my choice of model either

[03:37] <pmichaud> I'm not switching Rakudo out of a preference, I'm switching based on previous discussions of the spec

[03:37] <sorear> by "model" I mean "that which I physically cannot begin to implement a spec without first having"

[03:37] <japhb> sorear, 1) Is there a particular repo I need to build to make that work?  I don't see a bare 'glib' listed there, but I do see dbus-sharp-glib and gtk-sharp (and gtk-sharp-beans, whatever that is ...)  2) I'm one of those people who likes to just install all the optional libs that some project might want, so that I don't later get annoyed that some example code somewhere doesn't work.  :-)

[03:38] <shinobicl___> rakudo: my @a; say @a.empty;

[03:38] <p6eval> rakudo e2ebf3: OUTPUT«Method 'empty' not found for invocant of class 'Array'␤  in block <anon> at /tmp/kjeFloO1TU:1␤␤»

[03:38] <jnthn> pmichaud: I don't feel strongly on the name, fwiw.

[03:38] <pmichaud> perl 5 uses something along this line.

[03:38] <sorear> I guess I'm using it in the mathematical sense - the spec is a list of axioms, but I need to know that they are consistant

[03:38] <jnthn> pmichaud: I don't have an awesome suggestion right off.

[03:38] <shinobicl___> hehe... to much php for me on the last weeks

[03:38] <sorear> having a model == convincing myself that there is *a* way to implement the axioms

[03:39] <jnthn> sorear: If pmichaud++ implements it in Rakudo I guess that's a proof. ;)

[03:39] <sorear> apparently pmichaud does not think that (my @a).defined is unimplementable

[03:39] <pmichaud> no, I know it's implementable.  

[03:39] <sorear> sure, I can just copy it after he's done ;)

[03:39] <pmichaud> essentially   my @a;  initializes itself to be Array of Any  (a type object)

[03:40] <pmichaud> same as how   my $a  is initialized to a type of object

[03:40] <pmichaud> s/type of/type/

[03:40] <jnthn> sorear: I forget the details, but I remember discussing this some time back and being happy it was doable. I forgot the details, but hopefully Pm remembers them better ;)

[03:40] <pmichaud> yeah, I'm having to search.  I wish there was a place where I could ack the #perl6 logs

[03:41] <pmichaud> the search on perlgeek.de isn't quite powerful enough to narrow it down on its own

[03:42] <pmichaud> I suppose I could scrape perlgeek.de's site via the text.pl hook 

[03:43] <sorear> oh right, I reamamber now

[03:43] *** shinobicl___ left
[03:43] <pmichaud> anyway, earlier #perl6 discussion today indicates that arrays (and hashes) need to have containers that aren't Scalar

[03:44] <pmichaud> i.e., currently treats an Array as being an aggregate of Scalar objects.... but Scalars don't flatten.  So I want a container type that flattens.

[03:44] <sorear> the big question that came up for me is - when autovivifying an Array object, we need to do $magic to write Array.new into the atomic container

[03:44] <pmichaud> yes, it's related to autoviv as well :)

[03:44] *** colomon left
[03:45] <sorear> as I understand this model, my @a; push @a, 5; say @a; does exactly the same operations as with s/'@'/$/g

[03:45] <pmichaud> correct.

[03:45] <sorear> anyways, the autoviv magic is *not* @a = Array.new

[03:45] <sorear> because that changes the items of the array, not the @a atomic container

[03:46] <sorear> I guess we want some kind of primitive STORE(@a, Array.new) macro

[03:46] <sorear> which coincides with &infix:<=> for scalar containers

[03:46] <pmichaud> anyway, before I can make much progress on Rakudo's side I need to have the container type that is distinguishable from Scalar somehow :)

[03:47] <pmichaud> then I can play with it all a bit and hopefully come up with something sane that also matches what TimToady has been describing

[03:47] <jnthn> pmichaud: To add it, edit BOOTSTRAP.pm. Search for Scalar. It should be relatively clear what to do.

[03:47] <sorear> re 'Variable' - I've actually seriously considered renaming it to SV, because 1. I have to type it a mazillion times 2. helps a possibly significant fraction of would-be core hackers to get it

[03:48] <sorear> oh, and wb pmichaud

[03:48] <pmichaud> jnthn: okay, I'll give it a shot.  I didn't know if there would be any big gotchas in fiddling with Scalar.

[03:48] <sorear> how are y'all michauds doing?

[03:48] <jnthn> pmichaud: Well, there's the "container spec" thing which you can likely cargo cult your way through.

[03:49] <jnthn> pmichaud: It's the thingy that says "I'm see-through"

[03:49] <jnthn> BOOTSTRAP.pm just configures it on the type.

[03:49] *** cogno joined
[03:49] <pmichaud> jnthn: well, part of the problem is that istr that there are some places where we treat "iscont" and "Scalar" as being roughly equivalent.

[03:49] <jnthn> pmichaud: You may need to diddle some bits in src/binder/container.c

[03:50] <pmichaud> ...and yes, it impacts the bindery :)

[03:50] <jnthn> pmichaud: Yes, you'll likely also have to clean up there

[03:50] <pmichaud> sorear: we michaud's continue to ride the rollercoasters here

[03:50] *** orafu left
[03:50] <cogno> Masak, that may be of interest to you : http://convergepl.org/documentation/1.2/ctmp/

[03:50] <jnthn> pmichaud: fwiw, the "binder" directory thse days would probably be  better called "guts-written-in-c" or something :)

[03:50] *** leprevost joined
[03:50] *** orafu joined
[03:50] <pmichaud> jnthn: yes, that's true also :)

[03:51] <jnthn> It never quite bugged me enough to change it yet.

[03:51] <pmichaud> anyway, I'll see if I can barrel my way through it, but I'm likely to have some questions/problems along the way

[03:52] <jnthn> OK. I'm gonna sleep now, but I'll be about online relatively often; just phenny me, or privmsg.

[03:52] <pmichaud> will do.  thanks for the pointers

[03:52] <jnthn> I don't always take the time to fully backlog while on vacation :)

[03:52] <pmichaud> I don't even take the time to fully backlog while not on vacation :)

[03:52] <jnthn> ;-)

[03:54] <jnthn> OK, sleep time... :)

[03:54] <jnthn> 'night o/

[03:56] <japhb> o/

[03:57] <pmichaud> afk for me too

[03:57] <pmichaud> bbt

[04:04] *** cogno left
[04:06] *** birdwindupbird joined
[04:11] *** parthm joined
[04:21] *** alester left
[04:27] *** Su-Shee left
[04:29] *** Su-Shee joined
[04:45] <sorear> n:  1, 2i, -4 ... 256

[04:45] <p6eval> niecza v15-4-g1f35f89:  ( no output )

[04:45] <sorear> n: say 1, 2i, -4 ... 256

[04:45] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 0+2i -4 0-8i 16+0i 0+32i -64+0i 0-128i 256+0i␤»

[04:46] *** odoacre joined
[05:22] *** leprevost left
[05:34] *** stepnem left
[05:39] *** stepnem joined
[05:41] *** bbkr left
[05:49] <moritz> o morning

[05:49] <moritz> r: say (1, 2i, -4 ... 256

[05:49] <p6eval> rakudo e2ebf3: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2␤»

[05:49] <moritz> r: say (1, 2i, -4 ... 256)[^°]

[05:49] <p6eval> rakudo e2ebf3: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix ^ instead at line 1, near "\x{b0}]"␤»

[05:49] <moritz> r: say (1, 2i, -4 ... 256)[^10]

[05:49] * moritz not quite awake yet

[05:50] <p6eval> rakudo e2ebf3: OUTPUT«(timeout)»

[05:52] *** kaleem joined
[05:54] <sorear> hi moritz

[05:55] <sorear> moritz: see p6l

[05:58] <moritz> nom: say (-4) / 2i

[05:58] <p6eval> rakudo e2ebf3: OUTPUT«0+2i␤»

[05:59] <moritz> nom: say (-4) / 2i == 2i / 1

[05:59] <p6eval> rakudo e2ebf3: OUTPUT«True␤»

[05:59] *** lestrrat left
[05:59] *** lestrrat joined
[06:06] * moritz doesn't see any explanation for the hang on p6l

[06:06] <TimToady> perl6: say (-16+0i) * (-16+0i) ~~ 256

[06:06] <p6eval> rakudo e2ebf3, niecza v15-4-g1f35f89: OUTPUT«True␤»

[06:06] <p6eval> ..pugs: OUTPUT«␤»

[06:07] <TimToady> seems to smartmatch okay

[06:07] <moritz> it seems it hangs while trying to deduce the sequence, not while generating it

[06:07] <moritz> r: say (1, 2, 4 ... 250)[^10]

[06:07] <p6eval> rakudo e2ebf3: OUTPUT«1 2 4 8 16 32 64 128 256 512␤»

[06:08] <TimToady> so it should work even if 256 doesn't match

[06:08] <moritz> correct

[06:11] <moritz> oh

[06:11] <moritz> nom: say 2i != 0

[06:12] <p6eval> rakudo e2ebf3: OUTPUT«(timeout)»

[06:12] <moritz> nom: say 2i !== 0

[06:12] <p6eval> rakudo e2ebf3: OUTPUT«True␤»

[06:12] <TimToady> huh, dededededesugaring?

[06:13] <TimToady> nom: say not 2i == 0

[06:13] <p6eval> rakudo e2ebf3: OUTPUT«True␤»

[06:14] <TimToady> nom: say i != 0

[06:14] <p6eval> rakudo e2ebf3: OUTPUT«(timeout)»

[06:14] <TimToady> nom: say i != 0i

[06:14] <moritz> != doesn't just redispatch to !==

[06:14] <moritz> but has its own candidates

[06:14] <p6eval> rakudo e2ebf3: OUTPUT«(timeout)»

[06:15] <moritz> and the ones for Complex are missing

[06:16] <moritz> and so it t

[06:16] <moritz> tries to convert to .Numeric, and then redispatches

[06:16] <moritz> and ends up in the same candidate

[06:18] * TimToady wonders if implementing != that way can do the correct not-raising in the face of junctions that a true ! metaop can do as a higher-order function

[06:19] *** mucker joined
[06:19] <TimToady> seems like rewriting to !== would be cleaner in that respect

[06:19] <moritz> nom: my $j = 1|2|3; say $j != 3; say $j !== 3

[06:19] <p6eval> rakudo e2ebf3: OUTPUT«any(True, True, False)␤False␤»

[06:20] <TimToady> niecza: my $j = 1|2|3; say $j != 3; say $j !== 3

[06:20] <p6eval> niecza v15-4-g1f35f89: OUTPUT«False␤False␤»

[06:21] <TimToady> niecza has it right

[06:21] <moritz> dispatching to the !== form has another advantage

[06:21] <moritz> fewer ops to define when adding custom types

[06:21] <TimToady> indeed

[06:22] *** lestrrat left
[06:23] *** lestrrat joined
[06:26] <TimToady> perl6: my $j = 1|2|3; say $j ne 3; say $j !ne 3

[06:26] <p6eval> rakudo e2ebf3, niecza v15-4-g1f35f89: OUTPUT«False␤True␤»

[06:26] <p6eval> ..pugs: OUTPUT«any(VBool False,VBool True)␤any(VBool False,VBool True)␤»

[06:26] <tadzik> good morning

[06:27] <TimToady> perl6: my $j = 1|2|3; say $j ne 3; say $j !eq 3

[06:27] *** benabik left
[06:27] <p6eval> rakudo e2ebf3, niecza v15-4-g1f35f89: OUTPUT«False␤False␤»

[06:27] <p6eval> ..pugs: OUTPUT«any(VBool False,VBool True)␤any(VBool False,VBool True)␤»

[06:27] <TimToady> pugs doesn't do not-raising since it hadn't been specced yet

[06:29] *** benabik joined
[06:43] <dalek> rakudo/nom: 4a247b1 | moritz++ | src/core/ (5 files):

[06:43] <dalek> rakudo/nom: make != redispatch to not ==

[06:43] <dalek> rakudo/nom: 

[06:43] <dalek> rakudo/nom: this fixes both a hang of != with complex numbers, and not-raising with Junctions

[06:43] <dalek> rakudo/nom: only natively typed variants of != and a (Mu, Mu) candidate remain

[06:43] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4a247b1a34

[06:45] *** wolfman2000 left
[06:50] <dalek> roast: 57f0c48 | moritz++ | S32-num/complex.t:

[06:50] <dalek> roast: != and complex numbers

[06:50] <dalek> roast: review: https://github.com/perl6/roast/commit/57f0c4883f

[06:52] *** y3llow left
[06:53] *** kcwu left
[06:54] *** bruges left
[06:55] *** benabik_ joined
[06:56] *** benabik left
[06:56] *** benabik_ is now known as benabik

[07:00] *** benabik left
[07:02] *** benabik joined
[07:02] *** havenn joined
[07:05] *** NamelessTee joined
[07:14] *** wtw joined
[07:29] <moritz> \o/ new HPMoR chapter!

[07:31] *** havenn left
[07:31] *** bruges joined
[07:32] *** kcwu joined
[07:32] *** y3llow joined
[07:34] *** y3llow left
[07:34] *** y3llow joined
[07:36] *** y3llow left
[07:36] *** y3llow joined
[07:40] *** tarch joined
[07:46] *** araujo left
[07:48] *** benabik_ joined
[07:49] *** benabik left
[07:49] *** benabik_ is now known as benabik

[08:03] *** mj41 joined
[08:11] *** pjcj left
[08:18] *** fglock joined
[08:20] *** pjcj joined
[08:22] <tadzik> I'm running late on those

[08:33] *** lestrrat left
[08:34] *** lestrrat joined
[08:39] *** am0c joined
[08:46] *** parthm left
[08:55] *** lestrrat left
[08:56] *** lestrrat joined
[08:59] <moritz> I'm upgrade feather2 to Debian stable now

[08:59] <moritz> *upgrading

[09:00] <moritz> just noticed that it runs oldstable, which doesn't receive security updates anymore

[09:00] <tadzik> moritz++

[09:01] <moritz> Juerd: can I safely reboot feather2 after the kernel upgrade?

[09:07] *** sisar joined
[09:18] <moritz> oh, and I'm also running upgrades on feather{1,3}

[09:19] <moritz> though they don't involve major version upgrades

[09:26] <moritz> The apache2 configtest failed, so we are trying to kill it manually. This is almost certainly suboptimal, so please make sure your system is working as you'd expect now! ... (warning).

[09:26] <moritz> eeks.

[09:28] *** nwc10 joined
[09:37] <moritz> /usr/sbin/apache2: symbol lookup error: /usr/sbin/apache2: undefined symbol: pcre_info

[09:42] <moritz> oh, fun

[09:42] <moritz> libpcre3 dropped some symbols

[09:43] <moritz> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=665300

[09:52] <moritz> ok, apache runs again

[09:54] <moritz> nom: (anon sub tract($n) { say $n; tract($n-1) if $n }).(5)

[09:54] <p6eval> rakudo 4a247b: OUTPUT«===SORRY!===␤Cannot use 'anon' with sub declaration␤at /tmp/EaunHq68DB:1␤»

[09:55] <moritz> hm

[10:11] *** colomon joined
[10:12] *** Guest81734 left
[10:31] *** sisar left
[10:32] *** retup_work left
[10:35] *** bbkr joined
[10:36] <bbkr> release \o/

[10:43] <felher> If i write >>echo -e 'my $x; $x := 1' | nom<<  it works just fine. But if i write >>echo -e 'my $x;\n $x := 1' | nom<< i get 'Cannot use bind operator with this left-hand side'. Is this expected behavior?

[10:45] *** daxim joined
[10:47] *** retup_work joined
[10:49] <arnsholt> felher: Two things to try, I think. 1) Does the same thing happen if you put the two in files? 2) What happens if you type the two into the REPL?

[10:54] <felher> arnsholt: Piping the output of echo to nom should be the same as typing them into repl.

[10:55] <arnsholt> Should be the same, yes. Is it? (I don't have an updated nom on hand, so I can't test myself)

[10:56] <felher> arnsholt: if i put in a file an run it, it doesn't happen (NQP only allows binding, so NQP wouldn't work at all if re-binding on different lines wouldn't work) :)

[10:56] <bbkr> same behavior on OSX, weird...

[10:57] <felher> arnsholt: yes, it is. As long as nom doesn't do something strange with a detected pipe. But since >> cat | nom << just works like repl, i don't think it does :)

[10:58] <bbkr> for me it happens also if put in file and piped using "cat file | perl6"

[10:59] <felher> bbkr: yeah, >> cat file | perl6 << is the same as executing perl6 and then typing it in. 

[11:02] <felher> bbkr: i don't know how high your unix-skillz are, but that is how it works: if you write programm | other-program, then other-program's standard input gets connected to the standard output of program. The catch is, that the standard input is where what you type comes from. So the other-program doesn't see a difference between you typing whats in the file and the 'cat file | other-program' 

[11:03] <felher> bbkr: it can, however, detect it if it wants to. There a 'isatty(int fd)' function, that checks if your input is a tty or something different.

[11:05] <felher> to be more precise. It checks if the 'thing' associated with the file-descriptor fd is a tty or something else :)

[11:11] *** xinming joined
[11:12] <bbkr>  echo -e 'my $x;\nsay $*IN.get' | perl6 - this one works as expected, I thought that string that should be interpreted is somehow bound to $*IN, but it's not the case

[11:16] <felher> bbkr: if you do what you've written, then perl6 'consumes' everything including 'say $*IN.get' to execute it. $*IN.get gets executed and is waiting for a some input. But since you didn't supply any more input, it doesn't get any and sees that it has read all that there is and returns an empty string.

[11:17] <felher> bbkr: >>echo -e 'my $x;\nsay $*IN.get\nblar' | perl6<< will also get you "blar" printed, fwiw :)

[11:19] <bbkr> oh, nice trick for torturing people on job interviews, thanks!

[11:20] <felher> bbkr: what is the job you interview people for?

[11:22] <bbkr> perl development for getresponse.com engine

[11:24] <felher> bbkr: ah, so i guess you are from germany, too?

[11:25] <bbkr> Poland

[11:27] <felher> bbkr: kk :) 

[11:27] <tadzik> bbkr: where are you hiring, ooc?

[11:29] *** pernatiy joined
[11:29] <bbkr> Trojmiasto

[11:30] <tadzik> I see

[11:31] <bbkr> what should I do to include JSON::RPC in Star release? is there any review process?

[11:32] <tadzik> is it useful and does it pass its tests? If so, then I (or anyone else) can include it any time

[11:32] *** jlaire left
[11:33] <masak> good postnoon, #perl6.

[11:33] <bbkr> useful. checking compatibility with .03 release right now.

[11:34] * masak enjoyed a nice antenoon with breakfast and HPMoR

[11:36] <tadzik> hello masak 

[11:40] *** jlaire joined
[11:40] <masak> ooh, more nice p6l emails.

[11:40] <masak> we should predict the imminent death of other fora we wish to enliven :P

[11:46] <bbkr> .03 release failed to build with: "/opt/local/include/unicode/uset.h:250: error: function declaration isn't a prototype"

[11:46] <tadzik> are you using blead parrot, maybe?

[11:46] <benabik> ...  I thought we fixed that.

[11:47] <benabik> How do you specify ICU's location?

[11:47] <bbkr> I downloaded tarball and ran " perl Configure.pl --gen-parrot", ICU is installed from MacPorts (no problem with previous release building)

[11:49] <benabik> Oh dear, did we fix that after the release?  Blarg.

[11:49] <bbkr> I use icu 4.6.1

[11:49] <benabik> We upgraded something to an error, but the way we included ICU makes the check hit it.

[11:50] *** araujo joined
[11:50] *** am0c left
[11:51] *** skids left
[11:52] <benabik> Blarg.  I have to go and don't have a quick answer for you.  It was fixed in a6b93466fca7d6a7c335d649954e5bb71e339aa7

[11:55] <masak> r: .say for 1, 2i, -4 ... 256

[11:55] <p6eval> rakudo 4a247b: OUTPUT«1␤0+2i␤-4␤-0-8i␤16+-0i␤0+32i␤-64+0i␤-0-128i␤256+-0i␤»

[11:56] <masak> \o/

[12:01] <masak> moritz++

[12:06] *** not_gerd joined
[12:07] <not_gerd> hello, #perl6

[12:07] <not_gerd> bbkr: use --gen-parrot=master or fix the ICU header by replacing `uset_openEmpty();` with `uset_openEmpty(void);`

[12:09] <bbkr> testing right now

[12:24] *** jaldhar left
[12:32] *** kaleem left
[12:32] *** kaleem joined
[12:33] *** fgomez left
[12:39] *** benabik left
[12:46] *** jaldhar joined
[12:58] <bbkr> --gen-parrot=master did not help :(

[13:00] *** xinming left
[13:04] <dalek> roast: f7b449b | moritz++ | S03-junctions/autothreading.t:

[13:04] <dalek> roast: test that != autothreads like !==

[13:04] <dalek> roast: review: https://github.com/perl6/roast/commit/f7b449b00c

[13:04] <not_gerd> bbkr: can you paste your config_lib.pir somewhere?

[13:05] *** xinming joined
[13:06] *** xinming left
[13:06] *** xinming joined
[13:11] *** xinming left
[13:12] *** xinming joined
[13:19] *** NamelessTee left
[13:19] *** skids joined
[13:24] <jnthn> phenny: any messages for me? :)

[13:24] <jnthn> ah, no then

[13:24] *** xinming left
[13:24] <nwc10> lucky you. More time for holiday.

[13:24] <moritz> jnthn: but there's something I wanted to ask you :-)

[13:25] <moritz> jnthn: at GPW we discussed throwing exceptions by having a hash of subs that generate those exceptions...

[13:25] <jnthn> Ja.

[13:25] <moritz> jnthn: somehow that needs to be installed in a parrot namespace

[13:25] <moritz> jnthn: the question is, when and how?

[13:26] *** xinming joined
[13:26] <moritz> immediately after it is assembled, and then at startup?

[13:27] <bbkr> http://bbkr.org/~bbkr/config_lib.pir

[13:27] <jnthn> moritz: Try putting them in a Pelr 6 hash at BEGIN time (e.g. in a BEGIN block). Then in the setting mainline or in an INIT block after that, grab said hash, use nqp::getattr to pull out the storage (a Parrot hash) and stick it into the Parrot ns like we do with PROCESS in BOOTSTRAP.pm

[13:27] <jnthn> *Perl

[13:28] <jnthn> nwc10: Well, waiting for a vaguely infrequent bus to take me out to a cable car so I can see some nice views at the moment :)

[13:28] <jnthn> So have some spare minutes anyway :)

[13:30] <moritz> jnthn: is the setting mainline run every time we run a Perl 6 program?

[13:30] <not_gerd> bbkr: your ICU headers are in /opt/local/include?

[13:30] <jnthn> Once

[13:30] *** xinming left
[13:31] *** sisar joined
[13:31] <moritz> are the namespaces serialized?

[13:32] <bbkr> not_gerd: /opt/local/include/unicode/icudataver.h

[13:32] <bbkr> not_gerd: and /opt/local/include/unicode/icuplug.h

[13:33] <jnthn> moritz: No

[13:33] <jnthn> moritz: That's why I said build a Perl 6 hash in a BEGIN block :)

[13:33] <jnthn> And install it each time. :)

[13:33] <jnthn> e.g.

[13:33] <moritz> ah, the INIT block is run each time

[13:34] <jnthn> pir::op_to_install(..., nqp::getattr(BEGIN { }, Hash, '$!storage'))

[13:34] <moritz> but is INIT early enough?

[13:35] <jnthn> moritz: The setting's INIT time happens when it's loaded

[13:35] <jnthn> moritz: That happens before any program-space BEGIN blocks

[13:36] <moritz> jnthn: ah, good

[13:37] <moritz> nom: constant %h = 1, 2; say %h.WHAT

[13:37] <p6eval> rakudo 4a247b: OUTPUT«Parcel()␤»

[13:37] * moritz submits rakudobug

[13:37] <jnthn> Hm :)

[13:38] * jnthn wonders how that one is meant to work :)

[13:38] <jnthn> Though, constant %h = { ... } gets you what you want.

[13:38] <moritz> maybe like  constant %h := (my % = ...)

[13:38] <jnthn> Or that.

[13:39] <moritz> n: constant %h = 1, 2; say %h.WHAT

[13:39] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Hash()␤»

[13:40] <moritz> nom: 1.foo

[13:40] <p6eval> rakudo 4a247b: OUTPUT«Method 'foo' not found for invocant of class 'Int'␤  in block <anon> at /tmp/B6qDyNoYwE:1␤␤»

[13:41] <moritz> nom: role a { }; a.foo

[13:41] <p6eval> rakudo 4a247b: OUTPUT«Method 'foo' not found for invocant of class 'a'␤  in <anon> at src/gen/Metamodel.pm:1166␤  in block <anon> at /tmp/H3JPtdWv1O:1␤␤»

[13:42] <pmichaud> good morning, #perl6

[13:42] <moritz> good am, pm

[13:42] <not_gerd> bbkr: could you apply https://gist.github.com/2170678 to your parrot checkout?

[13:43] <not_gerd> after that, do a perl Configure.pl --optimize --prefix=/Users/bbkr/Developer/Perl6/rakudo/install from your parrot source directory

[13:43] <not_gerd> if you config_lib.pir then contains some -isystem lines, running make should work again...

[13:45] <jnthn> morning, pmichaud 

[13:45] <jnthn> Hey, we have the same idea of morning! :)

[13:45] <pmichaud> jnthn: yes, very odd

[13:46] <nwc10> the declination on his compass will differ

[13:47] *** xinming joined
[13:48] <pmichaud> well, that's just because of my magnetic personality :)

[13:49] <jnthn> :)

[13:50] *** kaleem left
[13:50] <jnthn> OK, time for me to go and find my bus :)

[13:50] <jnthn> back in some hours

[13:52] <moritz> r: my $h := pir::get_root_global__PS('perl6'); nqp::bindkey($h, 'abc', 'foo')

[13:52] <p6eval> rakudo 4a247b:  ( no output )

[13:52] <pmichaud> might need a 'Mu'

[13:53] <moritz> my-variables are Mu-typed by default

[13:54] *** plutoid joined
[13:56] *** mucker left
[13:57] *** mucker joined
[14:01] <moritz> r: INIT { constant %h := { 'abc' => 'foo' } }

[14:01] <p6eval> rakudo 4a247b:  ( no output )

[14:01] *** ascent_ left
[14:01] *** ascent_ joined
[14:02] *** havenn joined
[14:02] *** mucker left
[14:02] <masak> r: say <h d r f sh>.pick(*) X~ 'uffle'

[14:02] <p6eval> rakudo 4a247b: OUTPUT«duffle fuffle shuffle huffle ruffle␤»

[14:03] *** mucker joined
[14:03] <moritz> r: INIT { constant %h := { 'abc' => { 2.sqrt(:$^foo, :$^bar) } } }

[14:03] <p6eval> rakudo 4a247b:  ( no output )

[14:03] <moritz> r: say <h d r f sh>.roll(4) X~ 'uffle'

[14:03] <p6eval> rakudo 4a247b: OUTPUT«ruffle huffle ruffle shuffle␤»

[14:03] <moritz> pseudo-random poetry ftw!

[14:04] <pmichaud> is there a way to determine that a Parameter is slurpy positional?

[14:04] <masak> this backlog is brought to you by Dr Seuss.

[14:04] <moritz> theres a .slurpy method

[14:04] <moritz> and I think !.named

[14:05] *** mucker left
[14:05] <moritz> yes, .slurpy && !.named

[14:05] <moritz> pmichaud: if you're doing that for arity/count thing, you also need to consider .capture

[14:05] <pmichaud> sub xyz(*%abc) { 1 };  say xyz.signature.params.perl

[14:05] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say xyz.signature.params.perl

[14:05] <p6eval> rakudo 4a247b: OUTPUT«Method 'signature' not found for invocant of class 'Int'␤  in block <anon> at /tmp/vcEGzqNMzq:1␤␤»

[14:05] *** mucker joined
[14:05] <moritz> &xyz

[14:05] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say &xyz.signature.params.perl

[14:05] <p6eval> rakudo 4a247b: OUTPUT«(%abc!,).list␤»

[14:06] <moritz> note that Parameter.perl isn't very good at the moment

[14:06] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say &xyz.signature.params{'abc'}.perl

[14:06] <p6eval> rakudo 4a247b: OUTPUT«Method 'at_key' not found for invocant of class 'List'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1184␤  in block <anon> at /tmp/jqIjDeQNiA:1␤␤»

[14:06] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say &xyz.signature.params[0]

[14:06] <p6eval> rakudo 4a247b: OUTPUT«%abc!␤»

[14:06] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say &xyz.signature.params[0].slurpy

[14:06] <p6eval> rakudo 4a247b: OUTPUT«True␤»

[14:06] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say &xyz.signature.params[0].named

[14:06] <p6eval> rakudo 4a247b: OUTPUT«True␤»

[14:06] <pmichaud> rakudo: sub xyz(*%abc) { 1 };  say &xyz.signature.params[0].positional

[14:06] <p6eval> rakudo 4a247b: OUTPUT«False␤»

[14:06] <pmichaud> hmmm.

[14:07] *** nwc10 left
[14:07] <pmichaud> okay, .slurpy and !.named

[14:07] <pmichaud> rakudo: sub xyz(*@abc) { 1 };  say &xyz.signature.params[0].positional

[14:07] <p6eval> rakudo 4a247b: OUTPUT«False␤»

[14:07] <pmichaud> rakudo: sub xyz(*@abc) { 1 };  say &xyz.signature.params[0].named

[14:07] <p6eval> rakudo 4a247b: OUTPUT«False␤»

[14:07] <pmichaud> rakudo: sub xyz(*@abc) { 1 };  say &xyz.signature.params[0].slurpy

[14:07] <p6eval> rakudo 4a247b: OUTPUT«True␤»

[14:08] <pmichaud> moritz: .capture, yes, thanks.

[14:08] *** NamelessTee joined
[14:10] *** JimmyZ joined
[14:10] *** mucker left
[14:12] *** leprevost joined
[14:15] *** havenn left
[14:18] *** havenn joined
[14:19] <bbkr> not_gerd: your patch worked, thanks!

[14:20] <not_gerd> moritz: https://github.com/parrot/parrot/pull/748

[14:21] <masak> not_gerd++

[14:21] <bbkr> not_gerd++

[14:21] <moritz> not_gerd: thanks. Sadly I know next to nothing about mac os, so I'd like to wait for somebody who does to apply it

[14:24] <masak> moritz: any thoughts on the two test failures from yesterday?

[14:24] <moritz> masak: just that it's specific to Mac OS

[14:24] <moritz> masak: I got a similar report at GPW

[14:25] <moritz> masak: is it new(ish)?

[14:26] <moritz>     method dispatch:<.^>(Mu \$self: $name, |$c) {

[14:26] <moritz>         self.HOW."$name"($self, |$c)

[14:26] <moritz>     }

[14:27] <moritz> that one is causing infinite recursion during compilation during my experiments

[14:27] <moritz> probably because it's called before .Stringy or .Str or so isn't yet set up correctly

[14:27] <moritz> any idea how to make that more robust?

[14:29] <pmichaud> is $name not a string at that point?

[14:29] <moritz> I have no idea

[14:29] <pmichaud> as listed there it seems pretty robust-ish to me

[14:29] <moritz> I'm trying to create a hash at compile time inside the setting

[14:31] <pmichaud> at what point inside the setting?

[14:31] <pmichaud> before Stringy/Str are defined?

[14:31] <moritz> no, later (in Exception.pm)

[14:31] <masak> moritz: I'm not on Mac OS. I made the release on Arch Linux for the first time yesterday.

[14:31] <moritz> masak: oh.

[14:31] <moritz> masak: then it is dependent on some other parameter that I don't know

[14:32] <moritz> (maybe ICU version?)

[14:32] <masak> maybe.

[14:32] <moritz> masak: do you have ICU installed?

[14:32] <masak> yes.

[14:32] <masak> icuinfo says 'Compiled-Version: 4.8.1.1'

[14:32] *** jaldhar left
[14:33] <masak> it's from 2011.

[14:33] <moritz> https://gist.github.com/2171207 that's the bottom of the backtrace

[14:34] *** havenn left
[14:34] *** havenn joined
[14:35] <pmichaud> my patch for .count seems to work -- all spectests pass

[14:36] <moritz> \o/

[14:36] <felher> If i want to specify this sub returns a String-Array would i write "my Array of Str sub returns-array-of-strings() { ... }"?

[14:36] <not_gerd> bbkr: alester just merged my pull request, ie --gen-parrot=master should work again

[14:37] <moritz> n: say 0, sub { @_.elems } ... 5

[14:37] <p6eval> niecza v15-4-g1f35f89: OUTPUT«0 1 2 3 4 5␤»

[14:37] <moritz> pmichaud: does that sequence work with your patch?

[14:37] <moritz> felher: yes (though NYI)

[14:37] <pmichaud> moritz: nope

[14:37] <pmichaud> but I can likely fix that.

[14:37] <moritz> :(

[14:37] <moritz> :)

[14:38] <sjn> (:

[14:38] <pmichaud> need a short break, first -- brb

[14:39] <felher> moritz: good :)

[14:39] <felher> ty

[14:41] <TimToady> ◡̈

[14:42] <masak> ?

[14:43] <TimToady> might look better at http://irclog.perlgeek.de/perl6/2012-03-23#i_5340249

[14:43] <masak> oh, Unicode sorcery.

[14:43] <masak> I desperately need to get gnome-terminal configured properly on Arch.

[14:43] <TimToady> doesn't print right on my gnome terminal

[14:44] <tadzik> looks fine in Konsole

[14:44] <masak> I'm not desperate enough to install KDE stuff. :)

[14:44] <masak> yet.

[14:45] <TimToady> well, there's always sourcery as a fallback

[14:45] <huf> is it supposed to be a smiley?

[14:45] <TimToady> yes

[14:45] <tadzik> masak: I think it's a matter of font, not a terminal

[14:45] <TimToady> looks good in firefox on my machine

[14:45] <huf> i wonder why my browser cant display it right but urxvt can :D

[14:45] <huf> yeah, probably a bad font

[14:45] <tadzik> I'm using Dejavu sans mono

[14:45] <masak> tadzik: know any good fixed-width Linux fonts that do the whole Unicode thingy?

[14:46] <huf> masak: fixed is pretty good

[14:46] <huf> at least one size of it ;)

[14:46] <tadzik> masak: dejavu sans mono is fine, terminus also has plenty of characters

[14:46] <tadzik> although I had no, this...

[14:46] <tadzik> r: say ''

[14:46] <p6eval> rakudo 4a247b: OUTPUT«␤»

[14:46] <tadzik> yeah, this square on terminus on arch, while I have it on terminus on debian :)

[14:47] *** tokuhiro_ joined
[14:47] <masak> I have both DejaVu Sans Mono and Terminus installed already. neither of them gives me any Unicode characters :(

[14:47] <masak> I tried playing around with the LANG envvar earlier today, but in vain.

[14:48] <tadzik> do you see lots of UTF-8 upon typing 'locale'?

[14:49] <masak> no, it be filled with "POSIX".

[14:49] <masak> maybe that's the problem.

[14:49] <moritz> try setting  LANG=en_US.UTF-8

[14:50] *** thou joined
[14:51] *** thou left
[14:52] <masak> that's what I tried earlier today, through 'export LANG=en_US.UTF-8'

[14:52] <masak> no change.

[14:53] <moritz> it won't affect the terminal you're in

[14:53] <tadzik> masak: go for /etc/locale-gen, see if they're there

[14:53] <moritz> you need to start a new terminal from within the shell where you changed the variable

[14:53] <tadzik> or locale.gen

[14:53] <masak> moritz: yes, I restarted gnome-terminal. no change.

[14:54] <masak> tadzik: ok, looking.

[14:54] <moritz> masak: where did you define the env variable?

[14:55] *** jferrero left
[14:56] <pmichaud> was there an RT ticket filed for the slurpy sequences issue?

[14:57] <moritz> dunno

[14:57] <masak> moritz: in ~/.bash_profile

[14:57] <moritz> masak: that's probably too late

[14:57] <masak> tadzik: hm, yes. I found /etc/locale-gen, and commented out en_US.UTF-8

[14:57] <masak> moritz: any recommendations where to put it?

[14:58] <moritz> masak: how do you launch the terminal?

[14:58] *** jferrero joined
[14:58] <moritz> if it's a desktop icon, it probably has some options to define env variables, or execute shell scripts

[14:58] <moritz> that's where you should do it

[14:59] <masak> no, so far I've just beeing typing 'gnome-terminal' in xterm.

[14:59] <moritz> then it's ok, if you source the .bashrc inside the xterm

[15:00] <tadzik> masak: no no, don't comment it _out_

[15:00] <masak> tadzik: er, sorry. uncommented :)

[15:01] <tadzik> masak: ok, now run locale-gen

[15:02] <masak> moritz++' suggestion (source .bash_profile and then start gnome-terminal) works and causes locale to spew out a lot of en_US.UTF-8 lines.

[15:02] <pmichaud> pmichaud@kiwi:~/p6/rakudo$ ./perl6

[15:02] <pmichaud> > say 0, sub { @_.elems } ... 5

[15:02] <pmichaud> 0 1 2 3 4 5

[15:02] <moritz> \o/

[15:02] <masak> possibly tadzik's help was necessary for this to work as well (I did run locale-gen after editing the file)

[15:02] <pmichaud> spectesting

[15:02] <masak> but I'm still not getting Unicode chars in gnome-terminal :/

[15:02] <tadzik> ok, good that it works :)

[15:03] <tadzik> masak: what font are you using?

[15:03] <moritz> masak: none at all?

[15:03] <pmichaud> fwiw, I've been using rxvt-unicode as my terminal for some time and I like it.

[15:03] <tadzik> masak: how about zażółć gęślą jaźń?

[15:03] <tadzik> yeah, urxvt is nice

[15:03] *** eiro left
[15:03] <masak> tadzik: DejaVu Sans Mono.

[15:04] <tadzik> should be fine

[15:04] <masak> yeah, it should!

[15:04] <masak> pmichaud: ok, I'll try that one.

[15:04] <tadzik> masak: are you _now_ on the terminal with dejavu and a proper locale?

[15:04] <pmichaud> package is likely urxvt

[15:04] <tadzik> try copypasting zażółć gęślą jaźń there, if not

[15:05] <masak> tadzik: I am _now_ on that gnome-terminal, yes.

[15:05] <tadzik> okay

[15:05] <tadzik> hmm

[15:05] <masak> tadzik: I see 'za?ï¿½?? g??l? ja??'

[15:06] <masak> though there are more question marks on my screen than in the backlog.

[15:06] <tadzik> okay, that's interesting

[15:06] *** jferrero left
[15:07] <moritz> masak: try   xterm -en utf8   just for the lulz

[15:07] <tadzik> masak: are you on ssh by any chance?

[15:07] <masak> fwiw, the `locale` output on feather (to where I'm ssh'ing and where I'm using screen) is all "POSIX".

[15:08] <moritz> masak: first test Unicode stuff locally

[15:08] <moritz> http://perlgeek.de/en/article/set-up-a-clean-utf8-environment

[15:08] <masak> but the ssh connexion has never been the problem before, so I assumed that wasn't it.

[15:08] *** eiro joined
[15:08] <masak> ok.

[15:08] <pmichaud> the font I've been using with my terminal is called "Monospace"

[15:08] <pmichaud> it appears to come from the cups package

[15:09] <pmichaud> although I could be wrong about its source

[15:09] *** xinming left
[15:09] <masak> moritz: the euro sign test works locally.

[15:09] <masak> works in my ssh'd session on feather, too.

[15:09] <moritz> masak: then don't mess with the terminal, the problem is somewhere else

[15:09] *** araujo left
[15:10] <TimToady> whenever I try to look at my gnome-terminal profile, it blows up all my terminals, *and* my firefox, *and* my gnome-panel, sigh

[15:10] *** araujo joined
[15:10] * TimToady is starting to hate harder on Ubuntu

[15:10] <masak> moritz: my `locale` output is now very similar to the one in your article. just my last line LC_ALL is empty.

[15:11] <moritz> masak: that's OK (LC_ALL is just a mechanism to set all the other LC_ entries)

[15:11] <masak> moritz: "Setting up the terminal emulator for your terminal emulator" -- you probably meant "Setting up the encoding" there.

[15:11] <moritz> masak: ah, yes

[15:11] * masak .oO( yo dawg )

[15:11] <moritz> will fix when I get home

[15:12] <dalek> rakudo/nom: 4d6754b | pmichaud++ | src/core/ (3 files):

[15:12] <dalek> rakudo/nom: Fix .count for subs with slurpy positionals.  Partially addresses RT #111646.

[15:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4d6754bc5e

[15:12] *** pyrimidine joined
[15:12] <masak> ah. screen -U was the last necessary step.

[15:12] <masak> moritz++

[15:12] <moritz> any students around? Parrot Foundation would be available to mentor Rakudo GSoC projects

[15:12] <masak> ah, that's nice.

[15:12] <masak> it's like getting color vision :)

[15:12] *** eiro left
[15:13] <masak> tadzik: zażółć gęślą jaźń! zażółć gęślą jaźń!

[15:13] <tadzik> congratulations! :)

[15:13] <masak> \»ö«/

[15:13] <tadzik> I'll buy you a beer if you can tell me what it means without asking a native Polish speaker

[15:13] *** eiro joined
[15:14] <pmichaud> masak:  Hey!  Watch where you're flapping those things!

[15:14] <masak> :P

[15:14] <moritz> ¡ǝɔıu sı ʇɹoddns ǝpoɔıu∩

[15:14] *** PacoAir joined
[15:14] *** plutoid left
[15:15] <masak> tadzik: it's the "lorem ipsum" of Polish, but I'm not sure what it means.

[15:16] <masak> if anything.

[15:16] <masak> frankly it looks too mark-dense to be real Polish.

[15:16] <tadzik> it's a unicode check, I think it just contains all the diacritics

[15:16] <tadzik> it means "yellow the self-counsciousness of a goose"

[15:16] <moritz> :-)

[15:16] <tadzik> phenny: pl en "jaźń?"

[15:16] <tadzik> phenny: pl en "jaźń"?

[15:16] <phenny> tadzik: "self" (pl to en, translate.google.com)

[15:17] <moritz> that's like "the quick brown fox..."

[15:17] <tadzik> yes

[15:17] <masak> tadzik: so, "yellow" as a verb? as a... czasownik?

[15:18] <tadzik> exactly. To make something yellow

[15:18] <masak> got it.

[15:18] <tadzik> and a order-ish one

[15:18] <tadzik> as in "yellow it, soldier!"

[15:18] <masak> imperative.

[15:18] <tadzik> right

[15:18] <masak> imperatyw

[15:18] <tadzik> tryb rozkazujący

[15:18] <tadzik> which probably means "imperative mode"

[15:18] <masak> right.

[15:18] <tadzik> phenny: "tryb rozkazujący"?

[15:18] <phenny> tadzik: "imperative" (pl to en, translate.google.com)

[15:18] <masak> well, "mood", actually.

[15:19] <tadzik> right

[15:19] <tadzik> I don't think so

[15:19] <masak> yes. that's the term.

[15:19] <tadzik> I thought mood is about how you feel about yourself

[15:19] <masak> there are a number of grammatical moods for verbs. they sit outside of the time forms, for example.

[15:20] <masak> indicative is the one with all the time forms. imperative is for orders. subjunctive mood is the weird one. conditional is for speaking hypothetically.

[15:21] <tadzik> yeah. Tryb oznajmujący, rozkazujący, something and przypuszczający

[15:21] <masak> see http://en.wikipedia.org/wiki/Realis_mood

[15:21] * pmichaud cleans up his patch a bit.

[15:21] <tadzik> phenny: en pl "subjunctive mood"?

[15:21] <phenny> tadzik: "subjunctive nastrój" (en to pl, translate.google.com)

[15:21] <moritz> in French, subjunctive is slightly hypothetically

[15:21] <moritz> is that normal?

[15:21] <moritz> I mean, is it similar in other languages?

[15:22] <TimToady> in classical Greek, subjunctive is less hypothetical than optative, so maybe it's an Indo-European thing

[15:22] <masak> moritz: it's used for wish/emotion/possibility/judgement/opinion/necessity, according to Wikipedia.

[15:23] <moritz> masak: ok, thanks

[15:23] <masak> moritz: "I am locking my car, so that it not be stolen."

[15:23] <moritz> though the logic in French always seemed leaky

[15:23] <masak> moritz: "Mi shlosas mian auton, por ke neniu shtel*u* ghin."

[15:24] <moritz> in particular I never understood why hoping didn't introduce subjonctif

[15:24] <moritz> phenny: "J'espere que"

[15:24] <moritz> phenny: "J'espere que"?

[15:24] <phenny> moritz: "J'espere that" (es to en, translate.google.com)

[15:24] <TimToady> you're hoping for a certainty :)

[15:25] <pmichaud> > my @list = <a b c d>;  say @list.reduce(&infix:<~>)

[15:25] <pmichaud> abcd

[15:25] <masak> moritz: I would indeed have guessed that such a wording would introduce the subjunctive, yes.

[15:25] <moritz> phenny: "J'esper que"?

[15:25] <phenny> moritz: "J'esper that" (es to en, translate.google.com)

[15:25] <masak> but my French is verry rousty. and maybe it was never that good. :)

[15:25] * moritz can't remember the spelling either

[15:25] <masak> first was right, I believe.

[15:25] <pmichaud> google is translating es to en for some reason there

[15:25] <moritz> phenny: en fr "I hope that"?

[15:25] <phenny> moritz: "J'espère que" (en to fr, translate.google.com)

[15:25] *** araujo left
[15:26] <masak> phenny: en fr "I hope that no-one steals my car!"?

[15:26] <phenny> masak: "J'espère que personne ne vole ma voiture !" (en to fr, translate.google.com)

[15:26] <masak> phenny: en fr "I hope that no-one will steal my car!"?

[15:26] <phenny> masak: "J'espère que personne ne volera ma voiture!" (en to fr, translate.google.com)

[15:26] <masak> looks like ordinary indicative to me.

[15:26] <masak> phenny: en fr "I wish that no-one will steal my car!"?

[15:26] <phenny> masak: "Je souhaite que personne ne volera ma voiture!" (en to fr, translate.google.com)

[15:28] <moritz> phenny: en fr "I admire that no-one steals my car"?

[15:28] <phenny> moritz: "J'admire que personne ne vole ma voiture" (en to fr, translate.google.com)

[15:28] <masak> phenny: en fr "I sincerely conjecture that no-one steals my car!"?

[15:28] <phenny> masak: "Je conjecture sincèrement que personne ne vole ma voiture !" (en to fr, translate.google.com)

[15:28] <moritz> I'm pretty sure that admire should trigger the subjunctif

[15:28] <TimToady> phenny: en fr "I wish that no-one would steal my car!"?

[15:28] <phenny> TimToady: "Je souhaite que personne ne volerait ma voiture!" (en to fr, translate.google.com)

[15:29] <masak> ooh

[15:29] <masak> but isn't that conditional?

[15:29] <TimToady> would/should are subjunctive in English

[15:29] <masak> ah, right.

[15:29] <TimToady> though it's going away

[15:30] <pmichaud> moritz: I have a question on the 2012.01 Rakudo release

[15:30] <TimToady> mostly being replaced by past tense "If I should go" --> "If I went"

[15:30] <moritz> pmichaud: ask away

[15:31] *** araujo joined
[15:31] *** araujo left
[15:31] *** araujo joined
[15:31] <pmichaud> there's a discussion taking place on the debian packaging lists regarding Parrot and Rakudo packaging.... 2012.01 was shipped as requiring Parrot 3.11.0 -- I forgot why we didn't ship with a requirement for Parrot 4.0.0

[15:31] <moritz> pmichaud: it was simply a mistake

[15:31] <pmichaud> so, 2012.01 should work with 4.0.0 then, yes?

[15:32] <moritz> pmichaud: nobody changed PARROT_REVISION during the development cycle, so when I looked at the file while doing the release, I thought it was already bumped

[15:32] <moritz> pmichaud: should work with both, yes

[15:32] <pmichaud> okay, I'll inform the list.

[15:32] <moritz> s/both/either/

[15:32] <pmichaud> thanks.

[15:32] <moritz> you're welcome

[15:32] <moritz> that was the first nom release, right?

[15:33] <pmichaud> yes, I think so.

[15:34] <moritz> hm, no

[15:34] <moritz> 2011.09 was

[15:34] <pmichaud> anyway, my question was answered :)

[15:34] <moritz> "This is the first compiler release from the latest development branch

[15:34] <moritz> of Rakudo."

[15:36] <dalek> rakudo/typed-ex-hash: c812679 | moritz++ | src/Perl6/Actions.pm:

[15:36] <dalek> rakudo/typed-ex-hash: allow "anon sub" again

[15:36] <dalek> rakudo/typed-ex-hash: review: https://github.com/rakudo/rakudo/commit/c8126794e2

[15:36] <dalek> rakudo/typed-ex-hash: e55477f | moritz++ | src/core/List.pm:

[15:36] <dalek> rakudo/typed-ex-hash: try to optimize the common case of List.Bool

[15:36] <dalek> rakudo/typed-ex-hash: review: https://github.com/rakudo/rakudo/commit/e55477fe67

[15:36] <moritz> note that those two commits are not really what that branch is about

[15:37] *** wtw left
[15:37] <moritz> might be interesting to benchmark e55477f cherry-picked into nom

[15:39] *** JimmyZ left
[15:40] *** not_gerd left
[15:40] <dalek> rakudo/nom: 69920db | pmichaud++ | src/core/Signature.pm:

[15:40] <dalek> rakudo/nom: Refactor Signature.count to properly handle arity for capture parameters.  Fixes RT #111646.

[15:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69920db585

[15:40] * masak takes a Fine Walk in the Fine Weather

[15:42] <moritz> pmichaud: ah, I see you made the same prototype changes as I did in the slurpy-sequence branch

[15:43] <pmichaud> yes, the prototypes were wrong.  :-)

[15:47] <moritz> and you found out while spectesting the sequence tests :-)

[15:49] <pmichaud> Correct.

[15:50] *** Patterner left
[15:52] *** pjcj is now known as TPF|pjcj

[15:52] *** Psyche^ joined
[15:52] *** Psyche^ is now known as Patterner

[15:52] <flussence> .oO( CSS would be a good macro language for HTML, now I think about it... )

[15:53] <sorear> good * #perl6

[15:53] <moritz> n: sub f(*@a) { say f.count }

[15:53] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Potential difficulties:␤  @a is declared but not used at /tmp/ETwmhGhFtL line 1:␤------> [32msub f(*[33m⏏[31m@a) { say f.count }[0m␤␤»

[15:53] *** jferrero joined
[15:54] <moritz> n: sub f(*@a) { say f.count }; f

[15:54] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Potential difficulties:␤  @a is declared but not used at /tmp/4VeAuRYkPa line 1:␤------> [32msub f(*[33m⏏[31m@a) { say f.count }; f[0m␤␤Stacktrace:␤␤Segmentation fault␤»

[15:54] *** rafl is now known as rafl|tpf

[15:54] <moritz> n: sub f(*@a) { }; say &f.count

[15:54] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Potential difficulties:␤  @a is declared but not used at /tmp/ZSIm_Rfcu_ line 1:␤------> [32msub f(*[33m⏏[31m@a) { }; say &f.count[0m␤␤Inf␤»

[15:54] <moritz> n: sub f(*@a) { @a }; say &f.count

[15:54] *** rafl|tpf is now known as TPF|rafl

[15:54] *** tokuhiro_ left
[15:54] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Inf␤»

[15:55] *** tokuhiro_ joined
[15:55] <sorear> moritz: do you have a clue why it's segfaulting>

[15:55] <moritz> sorear: wait, what is segfaulting?

[15:55] <TimToady> f calling f is an infinite regress

[15:55] <tadzik> doesn't it segfaulting when it tries to print a stacktrace?

[15:55] <moritz> ah, that one

[15:55] <tadzik> s/ing//

[15:56] <moritz> n: sub f() { f }; f

[15:56] <sorear> ok, that I won't worry too much about

[15:56] <p6eval> niecza v15-4-g1f35f89: OUTPUT«(timeout)»

[15:56] <flussence> whoa, niecza really doesn't like running in gdb..

[15:56] <pmichaud> is S03-sequence/limit-arity-2-or-more.t  still correct per spec?

[15:57] <moritz> pmichaud: some of them are certainly wrong

[15:57] <pmichaud> the spec talks about smartmatching against the current candidate

[15:57] <sorear> if the backtrace printer is overflowing the C stack, things will go wrong

[15:57] <dalek> roast: ca63a93 | moritz++ | S03-sequence/limit-arity-2-or-more.t:

[15:57] <dalek> roast: remove several surely unspecced tests

[15:57] <dalek> roast: review: https://github.com/perl6/roast/commit/ca63a93cf4

[15:58] <sorear> masak: what mail client do you use?

[15:58] <moritz> pmichaud: well, that test does seem to do proper smartmatching

[15:58] *** ascent_ left
[15:58] *** ascent_ joined
[15:58] <flussence> when I run it locally, that segfault line... isn't

[15:59] <moritz> flussence: might be related to the resource limit on the host

[15:59] <pmichaud> I don't understand how it's doing proper smartmatching.

[15:59] <moritz> pmichaud: the RHS is something like (*-*).abs < 2

[15:59] <moritz> which is a WhateverCode object

[15:59] <pmichaud> right, which takes two arguments

[15:59] <pmichaud> but the current candidate is a single scalar

[15:59] <moritz> ah

[15:59] <flussence> moritz: probably. I just did a ulimit -v 512MB before I ran it and I think mono's stuck in a GC loop now :)

[16:00] <moritz> pmichaud: dunno if it's specced, but it seems like useful-ish feature... maybe :-)

[16:00] <moritz> for aborting sequences when they have converged enough

[16:00] <flussence> well, with no limit it successfully eats all my RAM before crashing.

[16:00] <pmichaud> the spec says:

[16:01] <pmichaud> Assuming the next candidate value is in C<$x> and the

[16:01] <pmichaud> first element of the right side is in C<$limit>, the two operators

[16:01] <pmichaud> are implemented respectively as:

[16:01] <pmichaud> ...     last($x) if $x ~~ $limit; ...^    last     if $x ~~ $limit;

[16:01] <moritz> which implies it's non-spec

[16:01] <pmichaud> right

[16:05] <TimToady> perl6: my $x = 42; $x //= say "phooey";

[16:05] <p6eval> pugs, niecza v15-4-g1f35f89:  ( no output )

[16:05] <p6eval> ..rakudo 69920d: OUTPUT«phooey␤»

[16:06] <moritz> EINSUFFICIENTTHUNKING

[16:06] <TimToady> oh, you were just doing conditional initialization with //= {}

[16:06] <TimToady> but it still creates the {} unnecessarily

[16:07] *** tokuhir__ joined
[16:08] * TimToady is waybacklogging :)

[16:08] <moritz> I think that was less than 36 hours ago

[16:08] *** havenn left
[16:08] <TimToady> that's way back in backlogging years :)

[16:11] *** tokuhiro_ left
[16:11] *** tokuhir__ left
[16:13] * colomon is considering the fact that from C to C++, printf ("Hello world!n); became std::cout << "Hello world!" << endl; whereas from perl 5 to perl 6, it went from print "Hello worldn"; to say "Hello world";

[16:13] * colomon missed a std:: in the C++ example....

[16:13] * moritz proposes to add the &h built-in, which prints "Hello, Worldn"

[16:14] <moritz> then you can just write   h

[16:14] <colomon> :p

[16:14] <TimToady> "Overloading << for I/O--you think that's cute now..."

[16:15] *** pernatiy left
[16:15] <TimToady> though one could argue that << represents an IO monad, implemented poorly

[16:15] *** daxim left
[16:15] <pmichaud> make it &H instead of &h :-)

[16:15] *** simcop2387 left
[16:16] <colomon> Hey, then even my 3-year-old could program Hello world!

[16:17] <colomon> TimToady: my real objection is the complete anti-Huffmanization of C++.  All these really common things like I/O take more characters to do in C++ than in C.

[16:17] *** simcop2387 joined
[16:19] <TimToady> well, maybe C++ is just trying to discourage you from doing I/O.  :)

[16:19] * colomon is also remembering why he really (if ever) does test first coding in C++.  The tests end up being so crazily verbose....

[16:19] <colomon> TimToady++

[16:19] <TimToady> *rarely?

[16:19] *** havenn joined
[16:19] <colomon> *rarely

[16:21] <sorear> making perl 6 a superset of hq9+

[16:22] *** MayDaniel joined
[16:24] *** lestrrat left
[16:26] *** lestrrat joined
[16:29] *** mj41 left
[16:38] *** szbalint left
[16:40] *** fglock left
[16:40] <TimToady> sorear: does niecza have anything like viv's --yaml option?

[16:45] <sorear> No.

[16:46] <sorear> it used to, but I haven't figured out how that would interact with BEGIN

[16:49] <sorear> I am now thinking that a working --yaml would have a lot of properties in common with a working quasi { }

[16:49] * sorear pokes masak

[16:49] <moritz> -quaml

[16:51] <pmichaud> TimToady: I have some questions about flattening, when you have time

[16:56] *** birdwindupbird left
[17:00] * TimToady has some time, and possibly even some answers, which have some vague possibility of being correct...ish...

[17:03] <pmichaud> I should first note that I haven't been expecting   %h<a> = 1,2,3;  to ultimately store a Parcel into %h<a>.  In earlier versions of Rakudo and the spec, the item assignment resulted in the Parcel being converted to something else (e.g., a Seq).

[17:03] <pmichaud> In nom I just never got around to figuring out what it should be converted to.

[17:04] <pmichaud> the somewhat analogous case is something like   %h<a> = @b

[17:04] <moritz> one thing i like about the "every array element is an item" is that it means that whenever I do @a[$i], I know that i have to @() it to iterate over it

[17:04] <pmichaud> which ends up turning the flattening-array @b into a scalar array

[17:04] <moritz> if that changes, I need to introspect the array item, or always contextualize it

[17:05] <sorear> +1 to keeping "every array element is an item"

[17:05] <pmichaud> r: my @b = <a b c>;  my %h;  %h<a> = @b;  say %h.perl

[17:05] <p6eval> rakudo 69920d: OUTPUT«("a" => ["a", "b", "c"]).hash␤»

[17:05] <moritz> r: my @b = <a b c>;  my %h;  %h<a> = @b;  say 1 for %h<a>

[17:05] <p6eval> rakudo 69920d: OUTPUT«1␤»

[17:05] <moritz> r: my @b = <a b c>;  my %h;  %h<a> = @b;  say 1 for @%h<a>

[17:05] <p6eval> rakudo 69920d: OUTPUT«===SORRY!===␤Invalid hard reference syntax at line 1, near "%h<a>"␤»

[17:05] <moritz> r: my @b = <a b c>;  my %h;  %h<a> = @b;  say 1 for @(%h<a>)

[17:05] <p6eval> rakudo 69920d: OUTPUT«1␤1␤1␤»

[17:07] <sorear> pmichaud: do you still think Parcel should mutate into some sort of List when assigned to a non-flattening container?

[17:07] <pmichaud> sorear: I have no problem with it remaining a Parcel... but it needs to be a scalar Parcel I think.

[17:07] <pmichaud> i.e., something that doesn't flatten unless commanded (because it's in a container)

[17:08] <pmichaud> we'd mutate it into some form of List if we wanted to keep Parcel itself as an uncommon sort of thing to appear in data structures

[17:09] <moritz> currently I don't see much use in mutating it

[17:09] * TimToady hates having to put .list in so many places

[17:09] <pmichaud> TimToady: well, prefix @ then

[17:09] <moritz> TimToady: better than having to put a contextualizer everywhere

[17:09] <pmichaud> join ';', @%hash<a>

[17:09] * TimToady hates that too

[17:09] <TimToady> that doesn't work

[17:10] <moritz> so, can we make a prefix:<@> ?

[17:10] <moritz> join ':', @ %hash<a>

[17:10] <TimToady> to me, it's like any other function return that is non-commital on flattening

[17:10] <pmichaud> TimToady: you mean the .<a> part?

[17:11] <TimToady> yes

[17:11] <TimToady> foo 1,2,3, bar(), 4,5

[17:11] <pmichaud> actually, it's not the .<a> that is making it scalar

[17:11] <pmichaud> it's the fact that the element is in a scalar container

[17:11] <TimToady> bar does not commit to whether the result flattens until foo binds it

[17:12] <pmichaud> in particular, if we were to have   %h<a> := @b    then I might indeed expect %h<a> to flatten

[17:12] <sorear> TimToady: I see %foo<h> as being like $foo_h

[17:12] <TimToady> sorear: well, I don't see a $ there

[17:13] <pmichaud> if we have    my @b = <a b c>;  my %h;  %h<a> = @b;  say join ';', %h<a>

[17:13] <sorear> pmichaud: the idea that hashes and especially arrays could contain flattening elements makes me uneasy

[17:13] <pmichaud> would we expect %h<a> to flatten there?

[17:14] <pmichaud> sorear: yes, I have the same uneasiness, and especially for arrays

[17:14] <TimToady> I'd expect that to flatten

[17:14] <pmichaud> ouch.

[17:15] <pmichaud> example coming up.

[17:15] <TimToady> but it's the join that flattens it

[17:15] <pmichaud> my @b = <a b c>;   my @a = 0..3;   @a[2] = @b;   my @c = @a

[17:16] <pmichaud> does @c end up with 4 elements or 6?

[17:19] *** mj41 joined
[17:19] <TimToady> what you're really asking there is whether = flattens or keeps the () as one element

[17:20] <pmichaud> well, if we assume it keeps the () as one element, then    my @d = (1, 2, (3, 4), 5)   becomes very different from what we have now, I think.

[17:20] <TimToady> nodnod

[17:21] <pmichaud> currently it flattens, but all of the elements of @a are scalar so that we end up with @c.elems == @a.elems when were done

[17:22] <TimToady> perl6: my @a = 0..3; @a[1] := (1,2,3); say join ';', @a[1]

[17:22] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 2 3␤»

[17:22] <p6eval> ..pugs, rakudo 69920d: OUTPUT«1;2;3␤»

[17:22] <TimToady> perl6: my @a = 0..3; @a[1] := 1,2,3; say join ';', @a[1]

[17:22] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 2 3␤»

[17:22] <p6eval> ..pugs: OUTPUT«1␤»

[17:22] <p6eval> ..rakudo 69920d: OUTPUT«1;2;3␤»

[17:25] <TimToady> perl6: my @b = <a b c>;   my @a = 0..3;   @a[2] = @b;   my @c = @a; say @c.perl

[17:25] <p6eval> niecza v15-4-g1f35f89: OUTPUT«[0, 1, ["a", "b", "c"], 3].list␤»

[17:25] <p6eval> ..rakudo 69920d: OUTPUT«Array.new(0, 1, ["a", "b", "c"], 3)␤»

[17:25] <p6eval> ..pugs: OUTPUT«[0, 1, ["a", "b", "c"], 3]␤»

[17:26] *** kaare_ joined
[17:27] <TimToady> perl6: my @b = <a b c>;   my @a = 0..3;   @a[2] = @b;   my @c = @a; say join ';', @c[2]

[17:27] <p6eval> pugs, rakudo 69920d, niecza v15-4-g1f35f89: OUTPUT«a b c␤»

[17:27] <TimToady> perl6: my @b = <a b c>;   my @a = 0..3;   @a[2] = @b;   my @c = @a; say join ';', @c[2][]

[17:27] <p6eval> rakudo 69920d, niecza v15-4-g1f35f89: OUTPUT«a;b;c␤»

[17:27] <p6eval> ..pugs: OUTPUT«a b c␤»

[17:27] <TimToady> perl6: my @b = <a b c>;   my @a = 0..3;   @a[2] = @b;   my @c = @a; say join ';', @c[2][*]

[17:27] <p6eval> rakudo 69920d: OUTPUT«a;b;c␤»

[17:27] <p6eval> ..pugs: OUTPUT«a␤»

[17:27] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Unhandled exception: Cannot use value like Whatever as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 256 (Any.Numeric @ 5) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/VlODS_wCRF line 1 (mainline @ 2…

[17:30] <TimToady> perl6: my @b = <a b c>;   my @a = 0..3;   @a[2] := @b;   my @c = @a; say join ';', @c[2]

[17:30] <p6eval> pugs: OUTPUT«a;b;c␤»

[17:30] <p6eval> ..rakudo 69920d: OUTPUT«a␤»

[17:30] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«a b c␤»

[17:30] <TimToady> perl6: my @a = 0..3;   @a[2] := <a b c>;   my @c = @a; say join ';', @c[2]

[17:30] <p6eval> pugs: OUTPUT«a;b;c␤»

[17:30] <p6eval> ..rakudo 69920d: OUTPUT«a␤»

[17:30] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«a b c␤»

[17:31] *** Vlavv_ joined
[17:32] *** tarch left
[17:32] *** fglock joined
[17:32] <TimToady> perl6: my @a = 0..3;   @a[2] := <a b c>;   my @c = @a; say join ';', @a[2]

[17:32] <p6eval> pugs, rakudo 69920d: OUTPUT«a;b;c␤»

[17:32] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Potential difficulties:␤  @c is declared but not used at /tmp/gJvZiXESPE line 1:␤------> [32mmy @a = 0..3;   @a[2] := <a b c>;   my [33m⏏[31m@c = @a; say join ';', @a[2][0m␤␤a b c␤»

[17:33] *** Chillance joined
[17:33] *** pernatiy joined
[17:33] * TimToady doesn't see a great deal of agreement in the "current model"

[17:34] *** Vlavv` left
[17:35] <TimToady> I think I'm willing to flatten/itemize = as it currently does, but := probably needs to stay non-committal

[17:36] *** mucker joined
[17:36] <TimToady> and postfix:<[]> is less of a problem to me than .list

[17:38] <TimToady> perl6: my @a = 0..3;   @a[2] := <a b c>; say @a[2].WHAT

[17:38] <p6eval> rakudo 69920d, niecza v15-4-g1f35f89: OUTPUT«Parcel()␤»

[17:38] <p6eval> ..pugs: OUTPUT«Array␤»

[17:41] <masak> sorear: I'm on Gmail; why?

[17:41] <masak> the web application, that is.

[17:41] <pmichaud> by "not a great deal of agreement" -- do you mean among implementations or self-consistency within nom?

[17:45] <TimToady> among impls

[17:46] <masak> sorear: re working --yaml output having lots of properties in common with working quasi { }: I love how everyone is thinking of macros these days. ;)

[17:46] <masak> though I don't see the connection.

[17:46] <masak> maybe you're after the AST objects, and feel that quasis fit in there somewhere.

[17:46] <pmichaud> well, iirc pugs predates Parcel handling, so I'm not surprised it isn't in agreement

[17:47] <pmichaud> pugs:  say (1,2,3).WHAT

[17:47] <p6eval> pugs: OUTPUT«Array␤»

[17:47] *** havenn left
[17:47] <geekosaur> that's my recollection too, the whole "oh, list wont work for that" happened later than Pugs

[17:48] <pmichaud> niecza's differences seem to be in handling of := in array elements.  And I suspect much of that is because sorear++ is (smartly) waiting for the relevant specs to solidify a bit :)

[17:49] <pmichaud> anyway, if we can leave things as they are-ish, I'm happy.  :)

[17:49] <TimToady> here's the proximate cause of my frustration, trying to get https://gist.github.com/2173143 to work without .list, or at least without hte first .list

[17:50] <TimToady> (btw, this only works in niecza right now at all; rakudo seems to not like the any() === Burning, so the fire never propgates)

[17:50] <pmichaud> how about @!neighbors[$i][$j].any  ?

[17:51] <pmichaud> it kind of puts the action on the wrong side, yes.

[17:51] <masak> pmichaud++ # for prodding TimToady about list semantics

[17:51] <TimToady> that doesn't work either

[17:51] <masak> TimToady++ # for trying to get to the bottom of the pros and cons of the different models

[17:52] <pmichaud> perl6: my @a;  @a[2] = <a b c>;   say @a[2].any.perl

[17:52] <p6eval> pugs: OUTPUT«(#<Array:0x7fbcbbd226d1>)␤»

[17:52] <p6eval> ..rakudo 69920d, niecza v15-4-g1f35f89: OUTPUT«any("a", "b", "c")␤»

[17:53] <pmichaud> "doesn't work" as in "isn't working in niecza with .any" or as in "no, I don't want to do it that way"?

[17:54] <pmichaud> r:  my @a = 'r', 2, 's';  my @b;  @b[2] = @a;  say @b.perl

[17:54] <p6eval> rakudo 69920d: OUTPUT«Array.new(Any, Any, ["r", 2, "s"])␤»

[17:54] <TimToady> it works in niecza with .any, but not rakudo

[17:54] <pmichaud> r:  my @a = 'r', 2, 's';  my @b;  @b[2] = @a;  say @b[2].any.perl

[17:54] <p6eval> rakudo 69920d: OUTPUT«any("r", 2, "s")␤»

[17:54] <TimToady> problem might be more to do with enums

[17:55] <pmichaud> r:  my @a = 'r', 2, 's';  my @b;  @b[2] = @a;  say @b[2].any === 2

[17:55] <p6eval> rakudo 69920d: OUTPUT«any(False, True, False)␤»

[17:55] <masak> TimToady: if you manage to golf it, I'll submit it.

[17:55] <pmichaud> yeah, I'm guessing it's an enum issue more than a junction / array issue

[17:56] <masak> r: enum A <b c d>; my @l = (b, b, c, d); say "OH HAI" if any(@l) === c

[17:56] <p6eval> rakudo 69920d: OUTPUT«OH HAI␤»

[17:57] <masak> r: enum A <b c d>; say "OH HAI" if any(b, b, c, d) === c

[17:57] <p6eval> rakudo 69920d: OUTPUT«OH HAI␤»

[17:57] <masak> worksforme

[17:58] <pmichaud> r: enum CS <Empty Tree Burning>; my $a = [Empty, Empty, Tree];  say $a.any === Tree

[17:58] <p6eval> rakudo 69920d: OUTPUT«any(False, False, True)␤»

[17:59] <pmichaud> r: enum CS <Empty Tree Burning>; my $a = [Empty, Empty, Tree];  say $a.any === Burning

[17:59] <p6eval> rakudo 69920d: OUTPUT«any(False, False, False)␤»

[17:59] <pmichaud> r: enum CS <Empty Tree Burning>; my @a = [Empty, Empty, Tree];  say @a[0].any === Burning

[17:59] <p6eval> rakudo 69920d: OUTPUT«any(False, False, False)␤»

[17:59] <pmichaud> r: enum CS <Empty Tree Burning>; my @a = [Empty, Empty, Tree];  say @a[0].any === Tree

[17:59] <p6eval> rakudo 69920d: OUTPUT«any(False, False, True)␤»

[17:59] <TimToady> it's acting more like maybe it's not calculating the neighbors right, maybe

[17:59] <pmichaud> r: enum CS <Empty Tree Burning>; my @a = [Empty, Empty, Tree];  say ? ( @a[0].any === Tree )

[17:59] <p6eval> rakudo 69920d: OUTPUT«True␤»

[18:01] *** mucker left
[18:01] <TimToady> ooh, a clue, every cell has 3 neighbors

[18:02] <pmichaud> r: enum CS <Empty Tree Burning>; my @a = [123, [Empty, Empty, Tree]];  say ? ( @a[0][1].any === Tree )

[18:02] <p6eval> rakudo 69920d: OUTPUT«True␤»

[18:05] <pmichaud> r: my @a = <a b c>;  given @a { say .[1] }

[18:05] <p6eval> rakudo 69920d: OUTPUT«b␤»

[18:07] *** am0c joined
[18:09] <pmichaud> fwiw, the line

[18:09] <pmichaud>     has Cell-State @!grid;

[18:09] <pmichaud> looks wrongish to me

[18:10] <pmichaud> (probably not at all a source of the bug, but the elements of @!grid aren't directly Cell-States if I'm reading this correctly.)

[18:10] *** am0c_ joined
[18:12] <pmichaud> also, how about  @!grid = @new   at the end of method step, instead of the for loop?

[18:13] <pmichaud> or is it important to keep the same array containers?

[18:13] * pmichaud guesses the latter.

[18:13] *** am0c left
[18:15] <pmichaud> r: my $a = [2,1,0];  my @b = <x y z>;  say @b[$a]  # curious

[18:15] <p6eval> rakudo 69920d: OUTPUT«z y x␤»

[18:15] *** am0c__ joined
[18:15] <pmichaud> feels like .list might not be necessary in method Str

[18:15] <pmichaud> since @!grid[$i] is already Positional, it gets treated like a slice

[18:16] <pmichaud> (I could be wrong/missing something there though)

[18:17] <masak> pmichaud: agree on 'has Cell-State @!grid;' looking wrong. this is why I don't use array element typing yet, or in general any NYI-but-silent feature that might break my code.

[18:17] <pmichaud> oh, I see @b[$a]  returned a scalar result, though.

[18:17] <pmichaud> r: my $a = [2,1,0];  my @b = <x y z>;  say @b[$a.list]  # curious

[18:17] <p6eval> rakudo 69920d: OUTPUT«z y x␤»

[18:17] <pmichaud> r: my $a = [2,1,0];  my @b = <x y z>;  say @b[$a.list].perl  # curious

[18:17] <p6eval> rakudo 69920d: OUTPUT«("z", "y", "x")␤»

[18:18] <pmichaud> r: my $a = [2,1,0];  my @b = <x y z>;  say @b[$a].perl  # curious

[18:18] <p6eval> rakudo 69920d: OUTPUT«("z", "y", "x")␤»

[18:18] <pmichaud> oh, nm, it didn't return a scalar result.  It got .gisted

[18:18] *** am0c_ left
[18:20] <TimToady> https://gist.github.com/2173143 now has a half golfed example; nieca makes 3 different neighbor lists of 8 Bools, while rakudo makes 3 identical lists

[18:21] <pmichaud> I'm wondering if the nested if/for modifiers are confusing rakudo

[18:21] <pmichaud> ...or if rakudo is even parsing that correctly :-)

[18:22] <pmichaud> the 'if' and 'for' apply to ....   the take?

[18:23] <TimToady> they're both inside the gather

[18:23] <TimToady> take if for is the list comprehension

[18:24] <pmichaud> I also wonder if this is a variant of the 'take' bug

[18:24] * pmichaud experiments

[18:24] <TimToady> yes, inverting to an outer 'for' fixes it

[18:24] *** buubot_backup left
[18:25] <TimToady> maybe not scoping $_ right?

[18:25] <pmichaud> putting { } around the take also fixes it

[18:25] <pmichaud> (including the if/for)

[18:25] <pmichaud> http://gist.github.com/2173487

[18:26] <TimToady> changine it to a grep also fixes

[18:26] <TimToady> *ng

[18:26] <pmichaud> so yes, I suspect a parsing or other bug with the list comprehension

[18:29] <pmichaud> TimToady: okay, thanks for the help re: flattening -- I'll be able to rest easier now :)

[18:32] <TimToady> and my quibble with niecza is that this requires a .list: my @a = 0..3; @a[2] := <a b c>; say any(@a[2].list) eq 'b'

[18:32] *** mj41 left
[18:32] <TimToady> (which shouldn't because of the :=)

[18:33] <TimToady> perl6: my @a = 0..3; @a[2] := <a b c>; say so any(@a[2]) eq 'b'

[18:33] <p6eval> pugs: OUTPUT«*** No such subroutine: "&so"␤    at /tmp/ixp4oNBGj7 line 1, column 37 - line 2, column 1␤»

[18:33] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«False␤»

[18:33] <p6eval> ..rakudo 69920d: OUTPUT«True␤»

[18:34] <TimToady> perl6: my @a = 0..3; @a[2] = <a b c>; say so any(@a[2]) eq 'b'

[18:34] <p6eval> rakudo 69920d, niecza v15-4-g1f35f89: OUTPUT«False␤»

[18:34] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&so"␤    at /tmp/bqMaBypncK line 1, column 36 - line 2, column 1␤»

[18:34] <TimToady> perl6: my @a = 0..3; @a[2] = <a b c>; say so any(@a[2][]) eq 'b'

[18:34] <p6eval> pugs: OUTPUT«*** No such subroutine: "&so"␤    at /tmp/KWYAtvdGZJ line 1, column 36 - line 2, column 1␤»

[18:34] <p6eval> ..rakudo 69920d, niecza v15-4-g1f35f89: OUTPUT«True␤»

[18:34] <TimToady> I think I can live with .[]

[18:35] <TimToady> for the assigned case

[18:35] <masak> I can sort of see why it's a pity that it's needed, though.

[18:35] <masak> but I don't know the exact consequences of "fixing" it.

[18:35] * TimToady wants to have his cake and eat it to and also not be allergic to wheat

[18:35] <TimToady> *too

[18:35] *** am0c_ joined
[18:37] <pmichaud> I think "fixing it" likely involves either a major re-think of many already settled cases, or else some hard-to-explainish special casing to get it to work

[18:38] <pmichaud> (at the spec level)

[18:38] <TimToady> but assigning a list to a scalar does something much different in Perl 5 anyway, so maybe this falls into the category of making assignment do what a P5 programmer expects if they expected something that P5 doesn't in fact do :)

[18:38] *** am0c joined
[18:38] <TimToady> and as usual, use binding to do anything with purer semantics

[18:38] <pmichaud> afk for a bit

[18:39] * TimToady was gonna write a p5 parser this morning, sigh

[18:39] *** am0c__ left
[18:39] <TimToady> I guess it's viv or PPI or MAD

[18:40] <TimToady> doing it in viv is harder, but has more potential upside for us here

[18:41] *** am0c_ left
[18:44] *** am0c left
[18:44] *** TPF|rafl is now known as rafl

[18:45] *** TPF|pjcj is now known as pjcj

[18:46] *** buubot_backup joined
[18:48] *** thou joined
[18:52] <masak> were you gonna write a p5 parser for something primarily not related to #perl6?

[18:57] *** am0c joined
[18:58] <masak> r: say q:to /EOT/

[18:58] <p6eval> rakudo 69920d: OUTPUT«===SORRY!===␤Colons may not be used to delimit quoting constructs at line 1, near ":to /EOT/"␤»

[18:58] <masak> r: say q :to /EOT/

[18:58] <p6eval> rakudo 69920d: OUTPUT«===SORRY!===␤Colons may not be used to delimit quoting constructs at line 1, near ":to /EOT/"␤»

[18:58] <masak> n: say q :to /EOT/

[18:58] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Unhandled exception: Here document used before body defined␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/src/Op.pm6 line 320 (HereStub.zyg @ 4) ␤  at /home/p6eval/niecza/src/Op.pm6 line 23 (Op.ctxzyg @ 3) ␤  a…

[18:58] <masak> sorear: what does that error message mean?

[18:59] <TimToady> yes, for $job

[18:59] <masak> anyone against the idea of adding "here documents" as a feature in http://perl6.org/compilers/features ?

[18:59] <masak> I think it belongs there.

[18:59] <pmichaud> isn't it there already?  I thought I saw it.

[18:59] <masak> TimToady: I was looking at STD5.pm6 the other day.

[19:00] <pmichaud> anyway, +1 to adding heredocs to features if not already present

[19:00] <masak> TimToady: it looks like a pared-down version of STD.pm6, with a little too much Perl 6 think still in it. did it ever parse any Perl 5?

[19:01] <masak> pmichaud: I tried greeping for various things -- and I really don't see it in there.

[19:01] <pmichaud> maybe add autoviv there too

[19:01] <masak> aye.

[19:01] <pmichaud> masak: I think I was thinking of something else

[19:02] <pmichaud> oh, autoviv is there

[19:02] <pmichaud> moritz++ # autoviv on features page

[19:07] <TimToady> only the P5Regex part actually worked

[19:08] <masak> ah.

[19:08] <TimToady> and doubtless the rest has bitrotted wrt P6's STD

[19:09] <masak> TimToady: there's some sort of cosmic irony in you getting to write a second Perl 5 parser ;)

[19:10] <TimToady> don't I know it

[19:16] <pmichaud> I'm not sure "irony" is the correct word.  :-P

[19:16] <pmichaud> perhaps "justice"  :-P

[19:18] <masak> it's just made more funny because STD.pm6 came in between.

[19:18] <TimToady> maybe I should just copy over the yacc grammar and see if it parses :)

[19:19] <PerlJam> "second perl 5 parser"?  isn't more like 3rd?

[19:20] <pmichaud> those who learn from the mistakes of the past are doomed to repeat them

[19:20] <pmichaud> ummmm, hmm.  

[19:20] <TimToady> 3rd perl parse, but not 3rd p5 parser

[19:23] *** PacoAir left
[19:23] <dalek> rakudo/nom: a4c78fb | pmichaud++ | src/core/Parcel.pm:

[19:23] <dalek> rakudo/nom: Use "$()" in Parcel.perl to show when a Parcel is in a scalar container.

[19:23] <dalek> rakudo/nom: 

[19:23] <dalek> rakudo/nom: I'm not sure that the spec ultimately end up with something like

[19:23] <dalek> rakudo/nom: "scalar Parcels" (cf. "scalar arrays"), but since they exist in Rakudo

[19:23] <dalek> rakudo/nom: for the time being we should at least make their presence clearer

[19:23] <dalek> rakudo/nom: to the people who encounter them.

[19:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a4c78fb1d2

[19:23] *** PacoAir joined
[19:28] *** alester joined
[19:32] <dalek> features: 98cf39f | (Carl Mäsak)++ | features.json:

[19:32] <dalek> features: [features.json] added heredocs

[19:32] <dalek> features: review: https://github.com/perl6/features/commit/98cf39fd0d

[19:32] <PerlJam> Coding in C is *so* tedious these days.

[19:33] <TimToady> well, there's a start: Can't locate object method "parse" via package "STD_P5" at ./viv5 line 4206.

[19:33] <alester> I still like it!

[19:34] <PerlJam> alester: yeah, but for some things where I can think of a solution in 2 seconds but it needs some of the higher level construct from a HLL, there's just so much typing involved.

[19:34] <alester> Oh, I know.

[19:34] * pmichaud hands PerlJam a COBOL compiler.

[19:35] *** havenn joined
[19:36] <TimToady> You have a problem in C, so you say, "I know!  I'll use macros!"...and so on

[19:38] <TimToady> You have a problem, so you say "I know!

[19:39] <TimToady> now you don't know that you have two problems

[19:39] * colomon has a problem

[19:40] <TimToady> look in the back of the book

[19:45] *** havenn left
[19:48] *** leprevost left
[19:55] *** GlitchMr joined
[20:01] *** alester left
[20:07] <awwaiid> at the index? OH IC! You are so wise sir. I will build an index of my problems.

[20:07] *** thou left
[20:08] *** havenn joined
[20:08] <masak> "...now you have an indexed problem."

[20:13] *** thou joined
[20:14] *** lichtkind joined
[20:18] <masak> C has an austere kind of elegance about it. but I'd better be needing all that runtime speed it provides, 'cus I'm not about to express my ideas in it just for the fun of it.

[20:19] *** thou left
[20:19] *** MayDaniel left
[20:23] *** thou joined
[20:25] <Tene> masak: I express ideas in C mostly for the fun of it.  The majority of my C coding is recreational.

[20:30] <jnthn> Afternoon

[20:30] <masak> jnthn! \o/

[20:31] <jnthn> masak! \o/

[20:31] <masak> Tene: mine too, in the sense of "hobby coding". not in the sense of "I think this is the most expressive medium for this idea".

[20:31] <jnthn> masak: Curious release naming reason. :P 

[20:35] *** M_o_C joined
[20:36] <masak> jnthn: have you met any Perl people down there? :)

[20:36] <jnthn> No. :)

[20:37] <jnthn> I didn't really make any effort to, mind. 

[20:37] <jnthn> uh-oh...Kiev Perl workshop dates are out

[20:37] <jnthn> <- temptation

[20:38] <dalek> features: 42afc5c | (Carl Mäsak)++ | features.json:

[20:38] <dalek> features: [features.json] unbroke the json

[20:38] <dalek> features: 

[20:38] <dalek> features: Sorry 'bout that. :/

[20:38] <dalek> features: review: https://github.com/perl6/features/commit/42afc5ca42

[20:39] <jnthn> .oO( Just Some Old Notation )

[20:39] *** fgomez joined
[20:40] *** fgomez left
[20:41] *** fgomez joined
[20:41] <jnthn> pmichaud: How goes the refactors?

[20:44] * colomon just learned that the openNURBS 5.0 libraries have a .NET version....

[20:44] <pmichaud> jnthn: since we were able to resolve the most recent flattening issues, refactoring Scalar is much less urgent and less of a potential blocker

[20:44] <pmichaud> (see backlog for discussion, starting at...

[20:45] <pmichaud> http://irclog.perlgeek.de/perl6/2012-03-23#i_5341181 )

[20:45] <jnthn> Will do, thanks

[20:46] <pmichaud> I was able to clean up .count and .arity a bit, especially on signatures with slurpies

[20:46] <pmichaud> and/or captures

[20:46] <jnthn> Just saw those patches. Nice.

[20:46] <pmichaud> r:  my $p = (1,2,3);  say $p.perl;

[20:46] <p6eval> rakudo a4c78f: OUTPUT«$(1, 2, 3)␤»

[20:47] <masak> \o/

[20:47] <pmichaud> r: my %h;  %h<a> = 1,2,3;   say %h.perl;

[20:47] <p6eval> rakudo a4c78f: OUTPUT«("a" => $(1, 2, 3)).hash␤»

[20:47] <pmichaud> r: my @a = 0..3;  @a[1] = 1,2,3;  say @a.perl;

[20:47] <p6eval> rakudo a4c78f: OUTPUT«Array.new(0, $(1, 2, 3), 2, 3)␤»

[20:50] <masak> r: my %h; %h<a> = 1, 2, 3; .say for %h<a>

[20:50] <p6eval> rakudo a4c78f: OUTPUT«1 2 3␤»

[20:50] <masak> r: my %h; %h<a> = 1, 2, 3; .say for %h<a>[]

[20:50] <p6eval> rakudo a4c78f: OUTPUT«1␤2␤3␤»

[20:50] <masak> r: my %h; %h<a> = 1, 2, 3; .say for @ %h<a>

[20:50] <p6eval> rakudo a4c78f: OUTPUT«===SORRY!===␤Non-declarative sigil is missing its name␤at /tmp/gUAL1NqNnu:1␤»

[20:50] <masak> r: my %h; %h<a> = 1, 2, 3; .say for @(%h<a>)

[20:50] <p6eval> rakudo a4c78f: OUTPUT«1␤2␤3␤»

[20:50] <masak> r: my %h; %h<a> = 1, 2, 3; .say for @%h<a>

[20:50] <p6eval> rakudo a4c78f: OUTPUT«===SORRY!===␤Invalid hard reference syntax at line 1, near "%h<a>"␤»

[20:51] <masak> r: my %h; %h<a> = 1, 2, 3; .say for %h<a>.list

[20:51] <p6eval> rakudo a4c78f: OUTPUT«1␤2␤3␤»

[20:51] <pmichaud> @%var doesn't exist :)

[20:51] <masak> nodnod

[20:51] <pmichaud> although @$var does

[20:51] <pmichaud> (in the spec, not necessarily in nom)

[20:52] <masak> r: my $var = [1, 2, 3]; .say for @$var

[20:52] <p6eval> rakudo a4c78f: OUTPUT«1␤2␤3␤»

[20:52] <pmichaud> r: my $var = [1,2,3];  say for $var;

[20:52] <p6eval> rakudo a4c78f: OUTPUT«␤»

[20:52] <masak> dot.

[20:52] <pmichaud> r: my $var = [1,2,3];  .say for $var;

[20:52] <p6eval> rakudo a4c78f: OUTPUT«1 2 3␤»

[20:52] <pmichaud> \o/

[20:52] <pmichaud> rakudo++

[20:53] <masak> it's 2012. rakudo is nice to use. :)

[20:53] <pmichaud> so..... what happened to improve startup time so much?

[20:53] <masak> bs.

[20:53] <pmichaud> (I missed the discussions/commits/changes that made that possible)

[20:54] <masak> in other news, jnthn++ rocks.

[20:54] <Tene> pmichaud: jnthn's bounded serialization work

[20:54] <masak> (what I said.) :)

[20:55] <Tene> although it made startup time about 2x longer for me

[20:55] <Tene> I should check if that's still the case.

[20:55] <gfldex> pmichaud: http://6guts.wordpress.com/2012/02/10/bounded-serialization-better-regexes-and-better-errors/

[20:57] <lichtkind> pmichaud: glad to see you back

[20:57] *** GlitchMr left
[20:58] <pmichaud> on the one test that I ran, start time was... good enough that I wondered if I had accidentally run p5 by mistake :)

[20:58] <pmichaud> lichtkind: glad to be back, at least for a bit. 

[20:58] <jnthn> pmichaud: Essentially, we serialize meta-objects when pre-compiling

[20:58] <pmichaud> jnthn: I figured it would be something like that.  fantastic.

[20:58] <jnthn> pmichaud: And just deserialize them now at startup rather than doing all the work to recreate them.

[20:59] <jnthn> pmichaud: It also means World.pm got a bunch shorter and less messy :)

[20:59] <jnthn> And if you compute a constant and pre-compile, then it's not recomputed again.

[20:59] <jnthn> For an evil use for this, see example in http://jnthn.net/papers/2012-gpw-meta-programming.pdf

[21:00] <pmichaud> <x> in a regex can call a predeclared regex?

[21:00] <pmichaud> (lexical)?

[21:00] <jnthn> yes

[21:00] <pmichaud> there were a number of design issues with that, I thought.

[21:01] <pmichaud> especially when being used in a grammar

[21:01] <masak> do tell.

[21:01] <jnthn> pmichaud: It's a compile time decision, in case you were wondering.

[21:01] <jnthn> pmichaud: The predeclaration requirement will catch people out though, I fear...

[21:02] <jnthn> It means you can't write mutual recursion. Well, unless you stub. :)

[21:02] <jnthn> But maybe we should be pushing people to grammars for that...

[21:02] <jnthn> Or maybe we need a totally different design.

[21:02] <masak> r: say "foo" /<x>/; my regex x { foo };

[21:02] <p6eval> rakudo a4c78f: OUTPUT«===SORRY!===␤Confused␤at /tmp/r_6yzUyfr9:1␤»

[21:03] <pmichaud> so, if at compile time there's a &x in scope, the regex always uses that even if a subgrammar defines a 'x' regex?

[21:03] <masak> r: say "foo" ~~ /<x>/; my regex x { foo };

[21:03] <p6eval> rakudo a4c78f: OUTPUT«Method 'x' not found for invocant of class 'Cursor'␤  in regex <anon> at /tmp/YNc4hRZeAp:1␤  in method ACCEPTS at src/gen/CORE.setting:8300␤  in block <anon> at /tmp/YNc4hRZeAp:1␤␤»

[21:03] <masak> r: my regex x { foo }; say "foo" ~~ /<x>/;

[21:03] <p6eval> rakudo a4c78f: OUTPUT«=> <foo>␤ x => <foo>␤␤»

[21:03] <jnthn> That isn't predeclared.

[21:03] <jnthn> That latter one is.

[21:03] <masak> right. I was testing what you were saying.

[21:04] <jnthn> pmichaud: Yes. Note that an &x in scope has to be a regex. A sub x will not do it.

[21:04] <masak> yeah, that's unintuitive.

[21:04] <masak> r: sub x { say "OH NOES" }; say "foo" ~~ /<x>/;

[21:04] <p6eval> rakudo a4c78f: OUTPUT«Method 'x' not found for invocant of class 'Cursor'␤  in regex <anon> at /tmp/O0lUpTPLWK:1␤  in method ACCEPTS at src/gen/CORE.setting:8300␤  in block <anon> at /tmp/O0lUpTPLWK:1␤␤»

[21:04] <jnthn> masak: Welcome to one pass parsing.

[21:04] <pmichaud> r: my regex x { foo };  grammar ABC { rule TOP { <x> }; rule x { bar }; };   say ABC.parse('foo').perl

[21:04] <p6eval> rakudo a4c78f: OUTPUT«Match.new(orig => "foo", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new("x", Match.new(orig => "foo", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new()), ))␤»

[21:04] <masak> jnthn: subs manage this.

[21:04] <jnthn> masak: A sub call is unambiguous.

[21:05] <jnthn> You're comparing apples and oranges.

[21:05] <pmichaud> I'm worried about the example I just pasted.

[21:05] <masak> ah, because no method-call fallback.

[21:05] <pmichaud> It prefered the outer lexical regex to the one defined in the grammar.

[21:05] <jnthn> pmichaud: It bothers me too.

[21:05] <masak> I'm starting to feel it's a syntactical muddling of two things.

[21:05] <pmichaud> it is

[21:05] <pmichaud> we had a huge discussion about this around a year or so ago

[21:05] <masak> well, I'm starting to feel I don't like it.

[21:06] <jnthn> pmichaud: Frankly, I'd be happy to make people write <&x> always if they must write regexes outside of grammars.

[21:06] <pmichaud> and that's why nom wasn't supporting lexical regexes... because there's a huge conflict present

[21:06] <masak> jnthn: +1

[21:06] *** skids left
[21:06] <pmichaud> what about....

[21:06] <masak> jnthn: always &x if you mean a lexical regex.

[21:06] <jnthn> pmichaud: It was one of those cases where the 15 minutes to implement it seemed to be the most likely way to make people realize it was nasty and get a clarification. ;-)

[21:07] <pmichaud> r: grammar ABC { method x { foo }; method TOP { <x> } };  grammar DEF is ABC { method x { bar } };  say DEF.parse('foo').perl

[21:07] <p6eval> rakudo a4c78f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&foo' called (line 1)␤Undefined routine '&bar' called (line 1)␤»

[21:07] <jnthn> At which point all the tests that rely on it can also be declared wrong and fixed. :)

[21:07] <pmichaud> r: grammar ABC { rule x { foo }; rule TOP { <x> } };  grammar DEF is ABC { rule x { bar } };  say DEF.parse('foo').perl

[21:07] <p6eval> rakudo a4c78f: OUTPUT«Match.new(orig => "foo", from => 0, to => -3, ast => Any, list => ().list, hash => EnumMap.new())␤»

[21:07] <pmichaud> r: grammar ABC { rule x { foo }; rule TOP { <x> } };  grammar DEF is ABC { rule x { bar } };  say DEF.parse('bar').perl

[21:07] <p6eval> rakudo a4c78f: OUTPUT«Match.new(orig => "bar", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new("x", Match.new(orig => "bar", from => 0, to => 3, ast => Any, list => ().list, hash => EnumMap.new()), ))␤»

[21:08] <pmichaud> okay, that one is okay.  but

[21:08] <pmichaud> r: grammar ABC { my rule x { foo }; rule TOP { <x> } };  grammar DEF is ABC { rule x { bar } };  say DEF.parse('bar').perl

[21:08] <p6eval> rakudo a4c78f: OUTPUT«Match.new(orig => "bar", from => 0, to => -3, ast => Any, list => ().list, hash => EnumMap.new())␤»

[21:08] <jnthn> Yeah, no lexical one there

[21:08] <pmichaud> that one isn't.

[21:08] <jnthn> You explicitly have to write "my" to install it as lexical

[21:08] <jnthn> Right, that one sure ain't, and it's awkward.

[21:08] <pmichaud> anyway, we chose not to enable lexical regexes specifically so that people wouldn't rely on code that we know will someday break.

[21:09] <pmichaud> I'll see if I can find the #perl6 thread

[21:09] <jnthn> Can we choose to get a spec clarification while ripping them out? :) Or can I be free to remove reliance on this out of any spectests too? :)

[21:10] <pmichaud> the spec clarification is incredibly non-trivial

[21:10] <jnthn> Ugh.

[21:10] <pmichaud> last I heard, TimToady+ was speculating that anonymous regexes were in fact part of another inheritance component

[21:10] <pmichaud> sort of like braids

[21:10] <jnthn> Only deserves one + for that ;)

[21:10] <jnthn> mmmm...braids...

[21:10] <pmichaud> TimToady++

[21:11] *** thou left
[21:11] <pmichaud> (gotta fix the +'s)

[21:11] <jnthn> :)

[21:12] *** orafu left
[21:13] *** orafu joined
[21:15] <masak> pmichaud: oh btw, the .gist output of Match nowadays is often informative enough for .perl to be omittable:

[21:15] <masak> r: grammar ABC { my rule x { foo }; rule TOP { <x> } };  grammar DEF is ABC { rule x { bar } };  say DEF.parse('bar')

[21:15] <p6eval> rakudo a4c78f: OUTPUT«#<failed match>␤»

[21:15] <pmichaud> masak++

[21:15] *** sudokode left
[21:15] <masak> um, bad example :)

[21:15] <pmichaud> no, that was good enough.

[21:16] <pmichaud> it shows the match failed, much better than the .perl output did :)

[21:16] <masak> r: say "foo" ~~ /o*/

[21:16] <p6eval> rakudo a4c78f: OUTPUT«=> <>␤␤»

[21:16] <masak> huh!?

[21:16] * masak submits rakudobug

[21:16] <pmichaud> that matched at the beginning :-)

[21:16] <masak> oh!

[21:16] <pmichaud> IT'S NOT A BUG!!!  :)

[21:16] <masak> r: say "foo" ~~ /o+/

[21:16] <p6eval> rakudo a4c78f: OUTPUT«=> <oo>␤␤»

[21:16] <jnthn> :D

[21:16] * masak unsubmits

[21:17] <masak> stupid quantifiers... :P

[21:17] <fglock> regex is hard :P

[21:17] <pmichaud> we could unspec the quantifiers if you want :)

[21:17] <masak> I could totally do that right now.

[21:17] <masak> don't tempt me :P

[21:17] <masak> "Perl 6 regexes no longer support quantifiers. They're too hard to learn."

[21:18] * jnthn wonders if masak's commits to the specs are a negative number :)

[21:18] <Tene> "Perl 6 recommends going shopping as an alternative to learning quantifiers."

[21:18] <masak> I counted something like 11 removals of stuff from the spec in 2011.

[21:18] <masak> that I did, that is.

[21:21] <pmichaud> anyway, I'll find the current state of lexical regexes.

[21:21] <pmichaud> I do remember it as being a huge "here be dragons" area

[21:21] <jnthn> I'm quite sure it is. :)

[21:21] <jnthn> Seemed I made it breathe a little fire. :)

[21:21] <Tene> yep, I still have slower startup, around 0.7-0.8s rather than 0.4 like it was before the bs merge

[21:22] <jnthn> Wow.

[21:23] *** dorlamm joined
[21:23] <Tene> It drops a bit if I unset PERL6LIB, or maybe that's just sampling variance.

[21:23] <Tene> Both parrot and rakudo were built from clean checkouts.

[21:25] <timotimo> how would i manually override the  ?? !! operator?

[21:25] <timotimo> or rather, how do i define my own ternary operators?

[21:26] <pmichaud> jnthn: https://github.com/perl6/mu/blob/master/misc/pm.txt#L447   has part of it

[21:27] <jnthn> pmichaud: oh...just regexes outside of grammars...

[21:27] <masak> timotimo: infix:<?? !!>

[21:27] <pmichaud> those would be lexical, though.

[21:28] <Tene> jnthn: if you'd like to get access to my laptop to diagnose the issue, let me know.

[21:28] <pmichaud> the point being that <x> should make use of a regex defined in the grammar slang, not lexical

[21:28] <jnthn> pmichaud: Aha.

[21:29] <pmichaud> I'll still find the discussion -- now I have a date range :)

[21:29] <jnthn> Tene: OK. I'm kinda hoping the release that just went out advertising faster startup will spring up somebody else whose like "LIES!!!" and then there's a couple of data points and it's easier to extract the commonality

[21:30] <jnthn> Tene: At the moment I have on report of slower and many of faster.

[21:30] <masak> 1. negative PR 2. ??? 3. profit!

[21:31] <jnthn> *one

[21:31] <jnthn> Tene: I dunno if you have a C-level profiler you could run on it. Then I could compare it to what I see in such a run.

[21:31] <Tene> jnthn: I can run whatever you'd like me to run.

[21:31] <timotimo> p6: sub infix:<blip bloop>($a, $b, $c) { say "a: $a"; say "b: $b"; say "c: $c"; }; 1 blip 2 bloop 3;

[21:31] <p6eval> rakudo a4c78f: OUTPUT«===SORRY!===␤Confused␤at /tmp/7ACm5BiEr7:1␤»

[21:31] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected "blip"␤    expecting operator␤    at /tmp/1w4Avdcdb8 line 1, column 82␤»

[21:31] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Unhandled exception: No value for parameter '$c' in 'infix:<blip bloop>'␤  at /tmp/K2KhtV5Pl7 line 0 (infix:<blip bloop> @ 1) ␤  at /tmp/K2KhtV5Pl7 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home/p6eval/niec…

[21:32] <Tene> If you can give me appropriate arguments to valgrind or whatever, I can run that.

[21:32] <jnthn> Tene: Not right off, but I can likely figure something out.

[21:32] <Tene> great

[21:32] <timotimo> that didn't work so well

[21:32] <jnthn> If it produces output that kcachegrind can read, then I have a box back home where I managed to get that running.

[21:33] <timotimo> it does work with <?? !!>, though

[21:33] *** Trashlord left
[21:33] *** Trashlord joined
[21:33] <masak> timotimo: maybe it's still the case that one can't define new operators.

[21:33] <masak> at least there used to be a bug like that.

[21:35] <timotimo> mhm

[21:37] <timotimo> will i also be able to define a quarterny operator? like infix:<a b c>?

[21:37] <pmichaud> gotta shuttle kids to practice -- bbl or bbt

[21:38] <masak> timotimo: I suppose so.

[21:38] <pmichaud> looks like 2010-07-20 was the bulk of the discussion on lexical regexes

[21:39] <masak> so, about around the Rakudo Star release?

[21:39] <Tene> jnthn: http://allalone.org/callgrind.out.11171

[21:39] <pmichaud> yes

[21:39] <pmichaud> http://irclog.perlgeek.de/perl6/2010-07-20#i_2578599   # a good bit of the discussion

[21:39] <pmichaud> gotta run -- bbl

[21:40] <jnthn> Tene: Thanks.

[21:42] <Tene> jnthn: I've only used callgrind a couple of times ever; if that doesn't work for you, or you want me to run other benchmarks or whatever, please let me know.

[21:43] <jnthn> Tene: Will do. Thanks.

[21:43] *** fgomez left
[21:44] *** fgomez joined
[21:44] *** fgomez left
[21:44] *** fgomez joined
[21:57] *** fglock left
[21:57] *** am0c_ joined
[21:58] <masak> r: class A { has $.req = die 'You must supply the parameter :req to the .new method' }; say A.new

[21:58] <p6eval> rakudo a4c78f: OUTPUT«You must supply the parameter :req to the .new method␤  in method <anon> at /tmp/dG4xh7V9MM:1␤  in block <anon> at src/gen/CORE.setting:600␤  in method BUILDALL at src/gen/CORE.setting:578␤  in method bless at src/gen/CORE.setting:568␤  in method new at src/gen/COR…

[21:58] <masak> \o/

[21:58] <masak> tadzik++

[21:59] <tadzik> hm>

[21:59] <tadzik> ?

[22:00] <tadzik> looks like I accidentally Tene's karma :)

[22:00] <jnthn> masak: Now write a module to add an "is required" trait :)

[22:00] <masak> tadzik: no, that's from 2010 :)

[22:00] <tadzik> hm

[22:01] *** am0c left
[22:01] <masak> tadzik: the irclog URL that pmichaud provided.

[22:01] <tadzik> howdy, that was long ago

[22:01] <masak> jnthn: should be entirely possible.

[22:02] <tadzik> that was not my idea either :)

[22:02] <tadzik> "tadzik | and bless myself, like in Perl 5"

[22:02] <tadzik> oh joy :)

[22:03] <tadzik> and I was asking for Moose-like BUILD back then

[22:03] <tadzik> oh, I was supposed not to speak of that never again

[22:04] <masak> :P

[22:04] <masak> yah, 'cus you're wrong :P

[22:04] <tadzik> right

[22:05] <TimToady> only half wrong :)

[22:06] <TimToady> after that we did discuss the possibility of setting lazy thunks beforehand

[22:06] <TimToady> which would also not die prematurely, but would have the advantage that you could use the default in the BUILD

[22:07] <TimToady> has $!foo = 42; submethod BUILD() { $!foo *= 2 }   # 84

[22:07] *** colomon_ joined
[22:07] *** colomon left
[22:07] *** colomon_ is now known as colomon

[22:07] <TimToady> but = would just STORE without a FETCH and throw away the lazy value

[22:08] <tadzik> that demoralizes me again :)

[22:08] <TimToady> not sure what the performance ramifications would be though

[22:09] <TimToady> probably not big, but it has to hang the thunk off the FETCH call somehow

[22:10] <TimToady> it might also have surprising results by not running code at BUILD time either, but at first reference to the attr later

[22:11] <masak> yeah.

[22:11] <TimToady> has $!start = now;  # would be at first $.start call, not at .new time

[22:11] <TimToady> unless BUILD forced the call at the point it now calls the default thunks

[22:12] <masak> feels like what we have now is simpler to explain and reason about.

[22:12] <TimToady> and works with native structs that can't support lazy attrs

[22:13] <masak> and that.

[22:13] * TimToady was just thinking about rotates on compact arrays of bits...

[22:13] <TimToady> for http://rosettacode.org/wiki/Bitwise_operations#Perl_6

[22:15] *** fgomez left
[22:16] <tadzik> good night #perl6

[22:16] <lichtkind> http://blogs.perl.org/users/lichtkind/2012/03/atgr-another-tiny-grant-report.html

[22:17] <masak> 'branoc, tadziku.

[22:17] <lichtkind> TimToady: did you consider actors (sorry if disturbs your circles)

[22:17] <lichtkind> good night

[22:18] *** alester joined
[22:18] *** fgomez joined
[22:18] <masak> lichtkind: sure TimToady considered actors -- you don't get to have "scripts" and "programs" without first having actors. ;)

[22:26] <TimToady> the guy who disturbed our circles was Kepler...

[22:27] <masak> I thought he just bend them a little.

[22:27] <masak> bent*

[22:27] * masak .oO( Kepler was an excentric )

[22:28] <TimToady> no, that was Copernicus :)

[22:29] <masak> dang!

[22:30] <TimToady> then there's Newton, who confused parabolas with the ends of ellipses...

[22:30] *** am0c_ left
[22:31] <TimToady> because we all know that artillery shells go in parabolas until the reach orbit, and then their paths magically turn into ellipses instead

[22:31] <TimToady> *they

[22:32] <masak> TimToady: have you perchance read the Baroque Cycle?

[22:32] *** tokuhiro_ joined
[22:32] <TimToady> remind me not to sail across the Pacific

[22:32] <masak> :P

[22:33] *** Patterner left
[22:34] *** Psyche^ joined
[22:34] *** Psyche^ is now known as Patterner

[22:37] *** skids joined
[22:40] <sisar> .pm , .pm6 , .pl - what is the difference among them ? is there a .pm5 ?

[22:41] <sisar> masak: hm, The Baroque Cycle looks interesting... any good ?

[22:43] <masak> sisar: I've only read the first book. it's slow and long, but I liked the tone of it. the second and third are said to be better.

[22:43] <sisar> ah, will add it to my oh-so-long list of to-read books :)

[22:44] <masak> sisar: think of it as a weird kind of reverse SF. it's in the past, it's about things that sorta-kinda actually happened, but with a mix of characters that did and did not exist in actual history.

[22:46] *** japhb_ joined
[22:47] <japhb_> I never made it past the first book in The Baroque Cycle.  It was just too slow for me.

[22:47] * [Coke] sees pmichaud++ in backscroll: o/

[22:48] <japhb_> TimToady, is RosettaCode the primary place you're putting "Here's how to do this in Perl 6" examples these days?

[22:48] <TimToady> I did read them all, in fact, eventually, but after getting stuck in the first book for a year :)

[22:48] <masak> japhb_: I think I would've considered it too slow if not for MJD's judgement that this is the form of writing where Stephenson finally has room for all he wants to say.

[22:48] <TimToady> fortunately, they're the sort of book you can pick up again, and there are enough reminders of what went before

[22:49] <TimToady> I don't know of anyone else who can make economics that interesting

[22:49] <masak> I was a bit confuzzled by the rather broad person gallery in the first book. not fatally so, but still.

[22:49] <masak> yeah, the economics angle surprised me.

[22:49] <sisar> masak: i would love to see a blog post titled 'What is a macro ?' with both a general discussion/definition and macros in the perl6 context :)

[22:49] <japhb_> masak, I can see that.  But I think Cryptonomicon was about as slow as I could manage and still love it.  Slower than that ... and I've got faster things to read.  :-)

[22:49] <masak> I expected it to be mostly Newton/science.

[22:49] <TimToady> all Stephenson's books are about economics on one level or another

[22:50] <masak> sisar: http://strangelyconsistent.org/blog/macros-what-are-they-really

[22:50] <sisar> huh, masak++

[22:50] <masak> instant gratisfaction :P

[22:50] <TimToady> as for the person gallery, you already know Newton, so you really only have to track Daniel, Eliza and Jack strongly

[22:51] <masak> nod, but there were all these nobles...

[22:51] <TimToady> well, and there's Liebnitz

[22:51] *** alester left
[22:51] <masak> Liebnitz is cool :)

[22:51] <masak> he's doing mines *and* differential calculus.

[22:51] <TimToady> mines is actually where I got stuck for a year :)

[22:51] <masak> heh :)

[22:53] <sisar> masak: "Forget the "abstract" part, it's just been put there to scare you into thinking this is tricky." <- love this line :)

[22:53] <sisar> (from your blog post)

[22:54] <masak> well, in a very real sense "Syntax Tree" would've conveyed the concept just as well.

[22:54] <sisar> exactly !

[22:54] <masak> maybe people just love their TLAs.

[22:55] <sisar> MIA - masak is awesome :)

[22:55] * masak blushes :)

[22:55] * japhb_ nudges TimToady re: his RosettaCode question

[22:56] *** kaare_ left
[22:56] <sisar> my previous question, re extensions... anyone ?

[22:57] <masak> sisar: .pm and .pm6 -- no real difference, except that the former may be Perl 5 code.

[22:58] <masak> sisar: .pm extension means "this is a module", .pl extension tends to mean "this is a script"

[22:58] <masak> sisar: some people don't use the .pl extension so much. if you're on Unix, there's no real need to give your Perl script an extension.

[22:58] *** havenn left
[22:59] <sisar> yeah, but ain't a module a script... i mean both have the same perl code, it's not a differetn type of file format

[22:59] <japhb_> .pl tends to have a connotation of "This is a perl script, and I want it to run in an environment that pays attention to file extensions -- e.g. web servers (in CGI mode), Windows, etc."

[23:00] *** sudokode joined
[23:00] <sisar> anyways, thanks for the answer

[23:00] <sisar> every module begins with Module::Name ?

[23:00] <masak> sisar: a module is just Perl code, yes. but if you do .pm you create the expectation that it'll be imported by other code.

[23:01] <masak> sisar: that's the difference. such an expectation does not exist for .pl

[23:01] <sisar> i meant "module Module::Name; "

[23:01] * [Coke] wonders how many days of backlog this is. yeesh.

[23:02] <masak> sisar: every *module* begins with that, yes. every .pm file does not.

[23:02] <masak> sisar: could equally well be a role or a class or a grammar.

[23:03] <masak> or it could begin with some other declarational stuff.

[23:04] <sisar> but if i see such a line at the beginning of a .pm file, what is it there for ?

[23:05] <japhb_> 'module' says among other things that it is a Perl 6 module, not a Perl 5 module (which typically begins with 'package Module::Name;'

[23:05] * jnthn -> dinner

[23:06] <masak> sisar: it declares the contents of the file as being part of a particular namespace, and the namespace being a module.

[23:07] <sisar> oh, ok.

[23:08] <sisar> any good guide for learning to write tests using TAP ?

[23:09] <sisar> (from basics)

[23:12] <masak> three step guide: (1) 'plan <some number>;' (2) 'ok <some test>;' (3) there is no third step, that's it.

[23:14] <sisar> masak, you do like 'three-step guides' don't you ? ;-)

[23:14] <masak> (1) yes (2) yes (3) yes

[23:15] <japhb_> 1. yes 2. ??? 3. profit!

[23:16] <sisar> 1. ask masak 2. ??? 3. profit!

[23:17] <masak> now that is a meme that I wouldn't mind spreading.

[23:17] <masak> maybe I should print that on t-shirts and hand out to people.

[23:22] *** NamelessTee left
[23:22] *** wooden left
[23:23] <sisar> i found a good exercise, try to understand the Pod::To::HTML. Why good? Because you end up learning three languages, perl6, Pod, & HTML in the process !

[23:23] <sorear> masak: I was wondering what you were using for the (>) (>>) stuff

[23:24] <sorear> masak: not just "ASTs" but "ASTs that defer declarators"

[23:24] <sisar> i thought he did that by hand... # >, >> stuff

[23:24] <sisar> s/by hand/manually

[23:26] <masak> sorear: I'm doing that by hand. it's become a sort of Zen exercise at this point.

[23:26] <masak> it's how I would like a decent email client to work, ideally.

[23:27] <masak> sorear: what does deferring declarators have to do with --yaml ?

[23:27] <sorear> hahah I love the use of 木 there

[23:27] <masak> :)

[23:28] <sorear> masak: The error is fundamentally about BEGIN { say q:to/bar/ } ...

[23:28] <sorear> masak: I guess it's triggering because of questionable folding

[23:28] <sisar> masak, i agree. It looks much cleaner than the usual cruft 'john doe wrote on $date $time'

[23:29] <masak> I've done that for years.

[23:29] <masak> I tend to put the name that people put in their signatures. that makes it hard to automate.

[23:32] <sorear> whee, present.

[23:32] *** dorlamm left
[23:34] <masak> it'd be cool if you could somehow overshoot backlogging and end up in the future.

[23:34] * masak .oO( I accidentally forelogged five minutes )

[23:37] <sorear> <3

[23:38] *** whiteknight joined
[23:39] <masak> then you would watch in some sort of tingly horror as the IRC log unfolded *exactly* as you had seen it, and no matter what you did, there was no way to change it.

[23:42] <pmichaud> ...where do you guys think I've been the past several months!  I saw the future irclog and realized I shouldn't be in it.  :)

[23:42] <pmichaud> but, the log is back to the point where I'm suppose to be writing again.

[23:43] * masak boggles at trying to imagine a seven-month forelogging

[23:43] <pmichaud> "tingly horror", yes.

[23:44] <masak> more like electric shocks.

[23:45] *** sivoais_ joined
[23:47] *** eiro_ joined
[23:53] <masak> 'night, #perl6

[23:53] <masak> see you in the forelog.

[23:55] *** eiro left
[23:55] *** geekosaur left
[23:55] *** jevin left
[23:55] *** TimToady left
[23:55] *** sivoais left
[23:55] *** Tene left
[23:55] *** krakan left
[23:55] *** ivan`` left
[23:55] <sorear> nocht masak

[23:59] *** wooden joined
[23:59] *** wooden left
[23:59] *** wooden joined
