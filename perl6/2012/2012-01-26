[00:00] <Timbus> nom: say ?(one(0,0) == 0)

[00:00] <p6eval> nom f9d635: OUTPUT«Bool::False␤»

[00:00] <Timbus> nom: say ?(one(0,0) != 0)

[00:00] <p6eval> nom f9d635: OUTPUT«Bool::False␤»

[00:00] <Timbus> and this is the correct answer?

[00:00] <Timbus> uh

[00:00] *** colomon joined
[00:03] <Radvendii> yes

[00:03] <Radvendii> because one(0,0) == 0 means one(0==0,0==0)

[00:04] <Radvendii> and one(0,0) != 0 means one(0!=0,0!=0)

[00:04] <Radvendii> both evaluate to false

[00:05] <Radvendii> it's one of those things to watch out for, that 0 != 0^0 is not the same as !(0==0^0)

[00:09] <Timbus> i guess i was getting hung up more on the contrived construct more than anything. im sure theres a more likely case where its a problem

[00:09] <[Coke]> "I know, I'll use Junctions!"

[00:10] <Radvendii> [Coke]: are you saying that about yourself, or quoting it...

[00:11] <Timbus> if you have a problem and think, 'hey maybe i should use threads', you now have two problems. if you have a problem and think 'hey maybe i should use junctions', you now have 1|2 problems

[00:11] <Radvendii> nice

[00:13] <Radvendii> nom: 5 «,» () # this dies rather ungracefully

[00:13] <p6eval> nom f9d635: OUTPUT«(timeout)»

[00:14] <Radvendii> why not just return an empty list?

[00:14] <Timbus> technically didn't die :v

[00:14] <Radvendii> :P even less graceful

[00:16] <Radvendii> nom: say 5 Z, ()

[00:16] <p6eval> nom f9d635: OUTPUT«␤»

[00:17] <Radvendii> oh, because 5 «,» () tries to repeat () until it has one element in it

[00:17] <Radvendii> which it never will

[00:19] <Radvendii> nom: say ("ab" | "a").chars

[00:19] <p6eval> nom f9d635: OUTPUT«any(2, 1)␤»

[00:19] <Radvendii> sweet

[00:20] *** PacoAir left
[00:23] <Radvendii> niecza: say ?(0^0 !== 0)

[00:23] <p6eval> niecza v13-352-g6694950: OUTPUT«Bool::True␤»

[00:36] *** Chillance left
[00:36] <Radvendii> nom: say (<a b c> Z... <d e f>)[0]

[00:36] <p6eval> nom f9d635: OUTPUT«a␤»

[00:37] <Radvendii> nom: .say for (<a b c> Z... <d e f>)

[00:37] <p6eval> nom f9d635: OUTPUT«a␤b␤c␤d␤b␤c␤d␤e␤c␤d␤e␤f␤»

[00:37] <Radvendii> it doesn't split them into separate sublists...

[00:40] *** lestrrat left
[00:40] <colomon> std: .say for (<a b c> Z... <d e f>)

[00:40] <p6eval> std 47c76b3: OUTPUT«ok 00:01 110m␤»

[00:40] *** lestrrat joined
[00:43] <Radvendii> niecza: .say for (<a b c> Z... <d e f>)

[00:43] <p6eval> niecza v13-352-g6694950: OUTPUT«a␤b␤c␤d␤b␤c␤d␤e␤c␤d␤e␤f␤»

[00:44] <Radvendii> &[Z...]([1,2,3],[4,5,6])

[00:44] <Radvendii> nom: say &[Z...]([1,2,3],[4,5,6])

[00:45] <p6eval> nom f9d635: OUTPUT«Could not find sub &infix:<Z...>␤  in block <anon> at /tmp/jUeKFWcjAl:1␤  in <anon> at /tmp/jUeKFWcjAl:1␤»

[00:45] <Radvendii> nom: say &[Z](&[...],[1,2,3],[4,5,6])

[00:45] <p6eval> nom f9d635: OUTPUT«infix:<...> 1 4␤»

[00:45] <Radvendii> nom: say &[Z]...([1,2,3],[4,5,6])

[00:45] <p6eval> nom f9d635: OUTPUT«(timeout)»

[00:45] <Radvendii> nom: say &[Z[...]]([1,2,3],[4,5,6])

[00:45] <p6eval> nom f9d635: OUTPUT«Could not find sub &infix:<Z[...]>␤  in block <anon> at /tmp/7Bd803C0rz:1␤  in <anon> at /tmp/7Bd803C0rz:1␤»

[00:46] <Radvendii> nom: say &[Z&[...]]([1,2,3],[4,5,6])

[00:46] <p6eval> nom f9d635: OUTPUT«===SORRY!===␤Unable to parse variable, couldn't find final ']' at line 2␤»

[00:46] <timotimo> can i do anything with Mu?

[00:46] <Radvendii> nom: say &[«,»]([1,2,3],[4,5,6])

[00:46] <p6eval> nom f9d635: OUTPUT«Could not find sub &infix:<«,»>␤  in block <anon> at /tmp/xfzE538N2Q:1␤  in <anon> at /tmp/xfzE538N2Q:1␤»

[00:46] <Radvendii> timotimo: what do you mean "do anything with"?

[00:47] <Radvendii> is there any way to use meta-ops as prefixes?

[00:54] <timotimo> Radvendii: i dunno. call it, instantiate it, derive from it, use it as a role, i have no idea. i don't even know what it is

[00:55] *** molaf_ joined
[00:58] *** molaf left
[01:02] *** pmurias left
[01:06] <sorear> good * #perl6

[01:07] <timotimo> what's the difference between /foo|bar/ and /foo||bar/?

[01:09] <sorear> none

[01:10] <Radvendii> timotimo: @your earlier question, Mu is a class, from which everything else comes. so an Int is also a Mu, as is a Junction

[01:10] <Radvendii> nom: my $i; say $i.WHAT

[01:10] <p6eval> nom f9d635: OUTPUT«Any()␤»

[01:11] <Radvendii> hm...

[01:11] <Radvendii> nom: my $i = 'a' | 'b'; say $i.WHAT

[01:11] <p6eval> nom f9d635: OUTPUT«Junction()␤»

[01:11] *** lichtkind left
[01:13] <timotimo> :)

[01:14] <timotimo> i'm kind of missing the simple introspection that i'm used to from python. is there some equivalent to the help function or dir function that list all methods of an object?

[01:15] <sorear> nom: say 5.^methods

[01:15] <p6eval> nom f9d635: OUTPUT«Int Num Rat abs Bridge chr succ pred sqrt base floor round ceiling WHICH perl Bool Str Rat abs sign conjugate sqrt sin asin cos acos tan atan atan2 sec asec cosec acosec cotan acotan sinh asinh cosh acosh tanh atanh sech asech cosech acosech cotanh acotanh floor ceili…

[01:16] <timotimo> any way to get at the documentation? i hear POD is pretty awesome, so it would be sensible to be able to introspect it?

[01:19] <timotimo> or maybe i'm just too spoiled by pythons docstrings ;)

[01:21] *** bkolera left
[01:21] <sorear> you can introspect POD

[01:21] <sorear> I don't think there's any POD in the setting though

[01:22] <timotimo> "setting"?

[01:24] <timotimo> bbl

[01:25] <dalek> niecza: 931be35 | sorear++ | src/ (2 files):

[01:25] <dalek> niecza: Import latest STD changes, various tweaks to make my \term:<∞> work...

[01:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/931be3560b

[01:25] <dalek> niecza: dceb6f3 | sorear++ | lib/CORE.setting:

[01:25] <dalek> niecza: Consistantly use \: in setting

[01:25] <dalek> niecza: review: https://github.com/sorear/niecza/commit/dceb6f35f2

[01:27] *** arlinius left
[01:29] *** replore joined
[01:31] *** benabik joined
[01:33] *** arlinius joined
[01:36] *** bkolera joined
[01:38] *** tokuhirom left
[01:38] *** rjbs left
[01:38] *** tokuhirom joined
[01:40] *** replore left
[01:42] *** tokuhirom left
[01:43] <Radvendii> timotimo: yo

[01:45] <sorear> pmichaud: ping

[01:46] <[Coke]> aloha: seen pmichaud?

[01:46] <aloha> [Coke]: pmichaud was last seen in #perl6 5 hours 18 mins ago saying "afk again for a while... probably won't be back until tomorrow morning".

[01:47] <sorear> mm

[01:47] * sorear makes ffffy noises because :D in signatures is broken *again*

[01:47] *** whiteknight joined
[01:53] <Radvendii> aloha: seen [Coke]?

[01:53] <aloha> Radvendii: [Coke] was last seen in #perl6 6 mins 30 seconds ago saying "seen pmichaud?".

[01:53] <Radvendii> woah...

[01:53] <Radvendii> that's crazy

[01:53] <sorear> what is?

[01:53] <Radvendii> is that available on all channels?

[01:53] <sorear> no

[01:53] <Radvendii> aww...

[01:54] <Radvendii> what else does aloha do?

[01:54] <Radvendii> aloha: help

[01:54] <aloha> Radvendii: Ask me for help about: seen, karma (say 'help <modulename>').

[01:54] <Radvendii> aloha: help panda

[01:54] <aloha> Radvendii: I don't know anything about 'panda'.

[01:54] <sorear> aloha's original reason was so that bacek could tab-complete his normal greeting

[01:55] <Radvendii> haha

[01:55] <Radvendii> really? :P

[01:55] <sorear> "panda" wasn't even on the list

[01:55] <sorear> really

[01:55] <Radvendii> aloha: help niecza

[01:55] <aloha> Radvendii: I don't know anything about 'niecza'.

[01:55] <sorear> what makes you think 'help niecza' will do anything?

[01:55] <Radvendii> aloha: help karma

[01:55] <aloha> Radvendii: Gives karma for or against a particular thing. Usage: <thing>++ # comment, <thing>-- # comment, karma <thing>, explain <thing>.

[01:55] <Radvendii> i dont know... we're on the perl6 channel...

[01:56] <sorear> 17:54 < aloha> Radvendii: Ask me for help about: seen, karma (say 'help  <modulename>').

[01:56] <Radvendii> o-oh

[01:56] <Radvendii> i get it now

[01:57] <Radvendii> wait, so karma doesn't work on all channels? i thought it was an IRC thing...

[01:57] <[Coke]> no, you need a bot to track it.

[01:58] <Radvendii> question: How does one apply a meta-operator on a list of two arguments?

[01:58] <Radvendii> besides doing @a[0] op @a[1]

[01:59] <sorear> Radvendii: what do you mean by a "meta-operator"?

[01:59] <sorear> I think you may have a term wrong - meta-operators cannot be applied to arguments

[01:59] <[Coke]> [op] @a ?

[01:59] <sorear> meta-operators, like »«, can only be applied to other operators

[01:59] <[Coke]> my @a = 1,2,3; say [+] @a;

[01:59] <Radvendii> nom: say &[Z~]([<a b>],[<c d>])

[01:59] <p6eval> nom f9d635: OUTPUT«Could not find sub &infix:<Z~>␤  in block <anon> at /tmp/H6G_tnuq2n:1␤  in <anon> at /tmp/H6G_tnuq2n:1␤»

[02:00] <Radvendii> nom: say [Z~]([<a b>],[<c d>])

[02:00] <p6eval> nom f9d635: OUTPUT«ac bd␤»

[02:00] <Radvendii> oh

[02:00] <Radvendii> i see

[02:00] <Radvendii> that makes sense

[02:04] <dalek> niecza: 253de26 | sorear++ | src/NieczaActions.pm6:

[02:04] <dalek> niecza: Fix :D ...again

[02:04] <dalek> niecza: review: https://github.com/sorear/niecza/commit/253de26ed4

[02:11] <timotimo> sorear: what's "the setting"? (re: POD introspection)

[02:13] <flussence> the setting is all the code (default subs etc.) that gets loaded before your script does

[02:17] *** tarski left
[02:20] <timotimo> ah, like what is called Prelude in haskell?

[02:41] <sorear> sort of, yes

[02:42] *** abercrombie left
[02:43] *** abercrombie joined
[02:44] *** wolfman2000 joined
[02:50] *** jaldhar joined
[02:56] <Radvendii> is there a way to force @a Z... @b to return a list of lists, or a list of references to lists?

[02:58] *** whiteknight left
[02:59] <Radvendii> nom: say ((1,2,3) Z (4,5,6)).map(&[...])

[02:59] <p6eval> nom f9d635: OUTPUT«No applicable candidates found to dispatch to for 'infix:<...>'. Available candidates are:␤:(Any $a, Any $b)␤␤  in sub infix:<...> at src/gen/CORE.setting:8861␤  in method reify at src/gen/CORE.setting:4471␤  in method reify at src/gen/CORE.setting:4376␤  in method re…

[02:59] <Radvendii> nom: say ((1,2,3) Z (4,5,6)).map: {[...]@$_}

[02:59] <p6eval> nom f9d635: OUTPUT«No applicable candidates found to dispatch to for 'infix:<...>'. Available candidates are:␤:(Any $a, Any $b)␤␤  in sub infix:<...> at src/gen/CORE.setting:8861␤  in sub <anon> at src/gen/CORE.setting:9023␤  in block <anon> at /tmp/6hz8tkEA0X:1␤  in method reify at src…

[03:00] <Radvendii> nom: say ((1,2,3) Z (4,5,6)).map: {$_[0] [...] $_[1]}

[03:00] <p6eval> nom f9d635: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu:U \$v, Mu %_!)␤␤  in method Numeric at src/gen/CORE.setting:649␤  in sub infix:<==> at src/gen/CORE.setting:2276␤  in sub infix:<cmp> at src/gen/CORE.setting:1218␤  in sub coro…

[03:00] <Radvendii> nom: say ((1,2,3) Z (4,5,6)).map: {.say}

[03:00] <p6eval> nom f9d635: OUTPUT«1␤4␤2␤5␤3␤6␤True True True True True True␤»

[03:01] <Radvendii> oh. so Z in general flattens the lists...

[03:02] <Radvendii> nom: say ((1,2,3) »,« (4,5,6)).map: {.say}

[03:02] <p6eval> nom f9d635: OUTPUT«1␤4␤2␤5␤3␤6␤True True True True True True␤»

[03:03] <Radvendii> nom: say ((1,2,3) »,« (4,5,6))

[03:03] <p6eval> nom f9d635: OUTPUT«1 4 2 5 3 6␤»

[03:03] <Radvendii> nom: say ((1,2,3) »,« (4,5,6)).perl

[03:03] <p6eval> nom f9d635: OUTPUT«((1, 4), (2, 5), (3, 6)).list␤»

[03:03] *** arlinius left
[03:04] <Radvendii> so why doesn't .map loop over the first order list

[03:04] <Radvendii> ?

[03:05] <timotimo> nom: say ((1, 2, 3),) >>,<< ((4, 5, 6),)

[03:05] <timotimo> like that?

[03:05] <p6eval> nom f9d635: OUTPUT«1 4 2 5 3 6␤»

[03:06] * Radvendii cocks an eyebrow

[03:07] <Radvendii> as in, why, when i do @multidimensionallist.map: {.say} does it ignore the multi-dimensionality

[03:07] <Radvendii> nom: (((1,2,3), ) »,« ((4,5,6), )).perl

[03:07] <p6eval> nom f9d635:  ( no output )

[03:07] <timotimo> hm, automatic flattening?

[03:08] <Radvendii> yeah, that's what i thought. but it's kind of silly

[03:08] <timotimo> mhm

[03:08] <Radvendii> for (<a b c>,<d e f>) {.say}

[03:09] <Radvendii> nom: for (<a b c>,<d e f>) {.say}

[03:09] <p6eval> nom f9d635: OUTPUT«a␤b␤c␤d␤e␤f␤»

[03:09] <Radvendii> nom: for (<a b c>,<d e f>).list {.say}

[03:09] <p6eval> nom f9d635: OUTPUT«a␤b␤c␤d␤e␤f␤»

[03:09] <timotimo> ah

[03:09] <timotimo> i think i might see what the problem is

[03:09] <timotimo> when you say a multidim list, it will be flattened

[03:09] <Radvendii> yeah?

[03:10] <Radvendii> what do you mean?

[03:10] <timotimo> nom: say ([[1, 2, 3], [4, 5, 6]] >>,<< [[9, 8, 7], [7, 8, 9]]).perl

[03:10] <p6eval> nom f9d635: OUTPUT«([1, 9, 2, 8, 3, 7], [4, 7, 5, 8, 6, 9]).list␤»

[03:10] <Radvendii> right. i know one can do it with references

[03:10] <Radvendii> the problem is that @a Z @b returns something of the form ((a,b),(a,b)(a,b))

[03:11] <Radvendii> nom: say ((1,2,3) Z... (4,5,6)).perl

[03:11] <p6eval> nom f9d635: OUTPUT«(1, 2, 3, 4, 2, 3, 4, 5, 3, 4, 5, 6).list␤»

[03:11] <Radvendii> and Z... flattens it already

[03:11] <timotimo> nom: say ([[1, 2, 3], [4, 5, 6]] Z [[9, 8, 7], [7, 8, 9]]).perl

[03:12] <p6eval> nom f9d635: OUTPUT«(([1, 2, 3], [9, 8, 7]), ([4, 5, 6], [7, 8, 9])).list␤»

[03:12] <[Coke]> b: say 19409-19357; # 01/25/2012 - niecza at 100.26%

[03:12] <timotimo> i'm confused

[03:12] <p6eval> b 1b7dd1: OUTPUT«52␤»

[03:12] <Radvendii> oh yeah

[03:12] <Radvendii> that is confusing

[03:12] <[Coke]> niecza has 20 new failures

[03:12] <Radvendii> :-(

[03:12] <timotimo> well, i don't know exactly what you want to end up with, also i just started with perl6 today :)

[03:13] <Radvendii> oh, congratz!

[03:13] <Radvendii> welcome to the club

[03:13] <Radvendii> it's lots of fun

[03:13] <timotimo> hah, i can see how much fun you're having :))

[03:13] *** am0c joined
[03:13] <Radvendii> :P

[03:13] <Radvendii> at times it can be frustrating that things are NYI (not yet implimented), but overall it's a great language

[03:16] <Radvendii> nom: (([1, 2, 3], [9, 8, 7]), ([4, 5, 6], [7,  8, 9])).list

[03:16] <p6eval> nom f9d635:  ( no output )

[03:16] <Radvendii> nom: say (([1, 2, 3], [9, 8, 7]), ([4, 5, 6], [7,  8, 9])).list

[03:16] <p6eval> nom f9d635: OUTPUT«1 2 3 9 8 7 4 5 6 7 8 9␤»

[03:16] <Radvendii> nom: say (([1, 2, 3], [9, 8, 7]), ([4, 5, 6], [7,  8, 9])).list.perl

[03:16] <p6eval> nom f9d635: OUTPUT«(([1, 2, 3], [9, 8, 7]), ([4, 5, 6], [7, 8, 9])).list␤»

[03:16] <Radvendii> nom: say (([1, 2, 3], [9, 8, 7]), ([4, 5, 6], [7,  8, 9])).list.map: {.say}

[03:16] <p6eval> nom f9d635: OUTPUT«1 2 3␤9 8 7␤4 5 6␤7 8 9␤True True True True␤»

[03:16] <Radvendii> grrr

[03:16] <Radvendii> stupid flattening

[03:17] <Radvendii> nom: say ([[1, 2, 3], [4, 5, 6]] Z [[9, 8, 7], [7, 8,  9]]).map: {.say}

[03:17] <p6eval> nom f9d635: OUTPUT«1 2 3␤9 8 7␤4 5 6␤7 8 9␤True True True True␤»

[03:17] <Radvendii> WHAT??

[03:17] <Radvendii> oh

[03:17] <Radvendii> oops

[03:17] <Radvendii> didn't see the Zip :P

[03:18] <sorear> [Coke]: last time you posted a test_summary log, I was able to find the failing tests by grepping it for 'not ok'

[03:18] <Radvendii> nom: say ([[1, 2, 3], [4, 5, 6]], [[9, 8, 7], [7, 8,  9]]).map: {.say}

[03:18] <p6eval> nom f9d635: OUTPUT«1 2 3 4 5 6␤9 8 7 7 8 9␤True True␤»

[03:18] <Radvendii> that's what it should be doing...

[03:19] <Radvendii> nom: say ([[1, 2, 3], [4, 5, 6]], [[9, 8, 7], [7, 8,  9]]).perl

[03:19] <p6eval> nom f9d635: OUTPUT«([[1, 2, 3], [4, 5, 6]], [[9, 8, 7], [7, 8, 9]])␤»

[03:19] <[Coke]> updated http://feather.perl6.nl/~coke 

[03:19] <Radvendii> it's just the Zip operator that's flattening lists

[03:19] <[Coke]> S02-types/bag.t, S04-declarations/state.niecza

[03:21] * sorear wonders when it would be appropriate to update roast to use foo and |foo

[03:26] *** raiph joined
[03:26] *** orafu left
[03:26] <Radvendii> std: [«,»]((1,2,3) Z... (4,5,6))

[03:26] <p6eval> std 47c76b3: OUTPUT«ok 00:01 111m␤»

[03:26] <Radvendii> nom: [«,»]((1,2,3) Z... (4,5,6))

[03:26] <p6eval> nom f9d635: OUTPUT«Nominal type check failed for parameter '$op'; expected Any but got Mu instead␤  in sub METAOP_REDUCE at src/gen/CORE.setting:9009␤  in block <anon> at /tmp/abwdNl2Tc3:1␤  in <anon> at /tmp/abwdNl2Tc3:1␤»

[03:27] <Radvendii> i dont see the problem...

[03:28] *** orafu joined
[03:28] <Radvendii> std: [Z,]((1,2,3) Z... (4,5,6))

[03:28] <p6eval> std 47c76b3: OUTPUT«ok 00:01 111m␤»

[03:28] <Radvendii> nom: [Z,]((1,2,3) Z... (4,5,6))

[03:28] <p6eval> nom f9d635:  ( no output )

[03:28] <Radvendii> nom: say [Z,]((1,2,3) Z... (4,5,6))

[03:28] <p6eval> nom f9d635: OUTPUT«1 6␤»

[03:29] <raiph> hi. i'm reading perl6/book; "Perl is community (perl5-porters, perl6-language)"; suggest s/perl6-language/#perl6/; maybe it's time for me to learn to use github

[03:30] <Radvendii> bye guys, I might be back later tonight or tomorrow

[03:30] <colomon> o/

[03:30] <Radvendii> o/

[03:30] *** Radvendii left
[03:31] <[Coke]> raiph: perl6-language is the mailing list.

[03:32] <[Coke]> [email@hidden.address]
[03:38] *** Psyche^ joined
[03:39] *** zamolxes joined
[03:42] *** Patterner left
[03:42] *** Psyche^ is now known as Patterner

[03:46] <sorear> o/ colomon

[03:46] <colomon> \o

[03:46] <colomon> how's it going?

[03:47] <sorear> ok

[03:47] <raiph> [Coke]: right, but it doesn't seem to represent the community near as much as #perl6

[03:47] <sorear> [Coke] says that bag.t is failing all over

[03:47] <colomon> really?  it's fine here.

[03:48] * colomon just did a spec test, failures are in lexical-array-in-inner-block.t, error-reporting.t, env.t, and state.t

[03:49] <sorear> I'm looking at the state.t failures now

[03:49] <sorear> the others passed for [Coke]

[03:50] <sorear> see http://feather.perl6.nl/~coke/niecza_summary.out

[03:51] <colomon> hmmm.... my fudges aren't there in roast

[03:52] <dalek> roast: de474dc | (Solomon Foster)++ | S (4 files):

[03:52] <dalek> roast: Merge branch 'master' of github.com:perl6/roast

[03:52] <dalek> roast: review: https://github.com/perl6/roast/commit/de474dcd57

[03:53] <colomon> huh.  don't know what's up with that being the only commit announced, but that got my fudging in there.

[03:54] <colomon> [Coke]: apologies for the slip-up.  that's what I get for trying to do a quick patch before my whistle lesson.  :)

[03:54] <sorear> Whistle lesson?

[03:54] <Util> nom: say ((1,2,3) Z (4,5,6)).map({[$^x, $^y]}).perl;

[03:54] <p6eval> nom f9d635: OUTPUT«([1, 4], [2, 5], [3, 6]).list␤»

[03:55] <Util> Radvendii: Is that what you were trying to do?

[03:56] <sorear> niecza: my ($x = 5)

[03:56] <p6eval> niecza v13-356-g253de26: OUTPUT«Potential difficulties:␤  $x is declared but not used at /tmp/QhOhrGz9QM line 1:␤------> my ⏏($x = 5)␤␤»

[03:56] <sorear> niecza: my ($x = 5); say $x

[03:56] <p6eval> niecza v13-356-g253de26: OUTPUT«Any()␤»

[03:56] <colomon> sorear: I skype with Gerry Strong from Newfoundland and pick up a couple of tunes from him once a month or so.  http://personainternet.com/gstrong/

[03:59] *** birdwindupbird joined
[03:59] <colomon> 'night

[04:01] <sorear> 'night

[04:03] <[Coke]> colomon: no worries, we'

[04:03] <[Coke]> 'll get them back in tomorrow's ru.

[04:03] <[Coke]> n.

[04:03] <[Coke]> *sheesh*

[04:06] <dalek> niecza: 9374d97 | sorear++ | src/STD.pm6:

[04:06] <dalek> niecza: Allow whitespace before state-variable initializers

[04:06] <dalek> niecza: review: https://github.com/sorear/niecza/commit/9374d970bf

[04:06] <sorear> phenny: tell TimToady RFC on https://github.com/sorear/niecza/commit/9374d970bf

[04:06] <phenny> sorear: I'll pass that on when TimToady is around.

[04:09] *** lutok left
[04:42] <sorear> [Coke]: I have a plan for WHICH/ObjAt now but it's enough different from Rakudo's ObjAt that you won't be able to just copy Temporal.WHICH

[05:08] *** kcwu left
[05:10] *** s1n left
[05:13] *** kcwu joined
[05:14] *** Khisanth left
[05:34] *** Khisanth joined
[05:37] *** koban joined
[05:37] *** koban left
[06:01] <moritz> \o

[06:01] <phenny> moritz: 25 Jan 22:48Z <jnthn> tell moritz Things that use $*W.throw(...) (e.g. sub foo($x! = 42) { }) gives an error in -e or when run in a file, but the error is never shown in the REPL - it seems to swallow them.

[06:02] <moritz> that's nasty :/

[06:09] *** birdwindupbird left
[06:20] *** lestrrat left
[06:21] *** lestrrat joined
[06:31] <moritz> ah, i might have an idea what's going on

[06:33] <moritz> nqp's REPL method just prints ~$!

[06:35] <moritz> but rakudo "hides" the error message in $!<payload>.message

[06:35] *** autark left
[07:01] *** wtw joined
[07:08] *** am0c left
[07:18] *** lutok joined
[07:23] *** benabik left
[07:24] *** benabik joined
[07:32] <dalek> rakudo/nom: 2e1c5d1 | moritz++ | src/core/Exception.pm:

[07:32] <dalek> rakudo/nom: fix printing of typed exceptions in the REPL

[07:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2e1c5d1f2d

[07:32] <dalek> rakudo/nom: 88c330c | moritz++ | src/ (2 files):

[07:32] <dalek> rakudo/nom: throw X::Syntax::Name::NotNull from Grammar.pm

[07:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/88c330ccb2

[07:32] <dalek> roast: 03faea7 | moritz++ | S32-exceptions/misc.t:

[07:32] <dalek> roast: X::Syntax::Name::NotNull

[07:32] <dalek> roast: review: https://github.com/perl6/roast/commit/03faea747c

[07:33] <moritz> commute &

[07:52] *** am0c^ joined
[07:57] *** mj41 joined
[08:05] *** nornagest left
[08:06] <moritz> jnthn: fixed exception printing in the REPL, and made rakudo exceptions a bit more friendly for HLL interop

[08:06] <moritz> nom: class A { has Int $.id; }; class B is A { submethod BUILD ( :$!id = 10 ) { } }; B.new

[08:06] <p6eval> nom 88c330: OUTPUT«===SORRY!===␤Attribute $!id not declared in class B␤at /tmp/rWRXNc46HN:1␤»

[08:19] *** Trashlord left
[08:23] *** baest_ is now known as baest

[08:36] *** drbean left
[08:38] *** drbean joined
[09:09] *** baest left
[09:12] *** am0c^ left
[09:16] <jnthn> morning, #perl6

[09:16] <jnthn> moritz++

[09:17] *** dakkar joined
[09:18] *** baest joined
[09:21] <jnthn> sorear: (update spectest for \ and | changes) I don't plan to leave it much longer before getting them in to Rakudo. Probably will have tuits at le weekend.

[09:22] *** GlitchMr joined
[09:26] *** robinsmidsrod left
[09:32] *** robinsmidsrod joined
[09:34] *** robinsmidsrod left
[09:35] *** kshannon left
[09:35] *** robinsmidsrod joined
[09:36] *** kshannon joined
[09:47] <moritz> nqp: my %h; %h<a> := 'a'; %h<b> := 'x'; for %h -> $x { $x.value := nqp::uc($x.value) }; say %h<a>

[09:47] <p6eval> nqp: OUTPUT«rtype not set␤current instr.: 'parrot;PCT;HLLCompiler;panic' pc 154 (compilers/pct/src/PCT/HLLCompiler.pir:111)␤»

[09:47] <moritz> nqp: my %h; %h<a> := 'a'; %h<b> := 'x'; for %h -> $x { %h{$x.key} := nqp::uc($x.value) }; say(%h<a>)

[09:47] <p6eval> nqp: OUTPUT«A␤»

[09:48] *** bacek joined
[09:48] *** grondilu joined
[09:50] <grondilu> With rakudo I tried to create a module in ~/.perl6/lib, I run "use MyModule;" with no error, but then when I call a function MyModule::foo, I get a "could not find symbol MyModule::&foo".  ??

[09:50] <jnthn> grondilu: subs are lexically scoped by default

[09:51] <moritz> grondilu: did you write 'our sub foo'?

[09:51] <grondilu> I tried 'our sub ...' with same result

[09:51] <jnthn> grondilu: You need to explicitly label it "our sub ..." for that to work. Just just add "is export" to export it.

[09:51] <jnthn> grondilu: I assume your module has a declaration "module MyModule;" at the top or some such?

[09:51] <moritz> grondilu: did you put it into a  module MyModule { .. }?

[09:51] <grondilu> I don't want to export it

[09:51] <grondilu> hang on

[09:52] <moritz> jnthn: it seems we have the same ideas nearly at the same time

[09:52] <grondilu> http://pastebin.com/rJRey0pn is my Foo test module

[09:52] <moritz> uhm, did you check that paste URL?

[09:52] <grondilu> no

[09:52] <moritz> it wants a captcha

[09:52] <grondilu> hang on again

[09:53] *** raiph left
[09:53] <jnthn> moritz: Are you thinking of having bacon for lunch also? ;)

[09:53] <grondilu> http://s0.barwen.ch/~grondilu/Foo.pm6

[09:53] <moritz> jnthn: I'm going to some canteen, so I don't have much choice

[09:54] <grondilu> It's really basic:  just module Foo; sub talk { say "hi" }

[09:55] <grondilu> s/sub /our sub/

[09:55] <jnthn> moritz: Heh...seems out sharedthought just extends to Perl 6 things then :)

[09:55] <grondilu> so?

[09:55] <jnthn> > use Foo; Foo::talk()

[09:55] <jnthn> hi

[09:56] <jnthn> Hm, works here.

[09:56] <grondilu> oh indeed

[09:56] <jnthn> grondilu: I'd ask what Rakudo version you're using but...

[09:56] <moritz> works here too

[09:56] <jnthn> ...I can't imagine one in a while where this didn't work. :) But may as wel ask.

[09:56] <grondilu> but why does it work only when the call is on the same line???

[09:57] <moritz> grondilu: are you in the REPL?

[09:57] * grondilu doesn't know what REPL is

[09:57] <jnthn> oh, I see

[09:57] <moritz> the interactive Read-Evaluate-Print-Loop

[09:57] <grondilu> yes

[09:57] <jnthn> moritz: If you do "use Foo" then hit enter then "Foo::talk()" then it is fail.

[09:58] * grondilu is using "This is perl6 version 2012.01-24-g27a5dd3 built on parrot 3.11.0 revision RELEASE_3_11_0"

[09:58] <grondilu> this is a bug, right?

[09:58] <moritz> grondilu: it's worth mentioning that in error reports, since the interactive env is less reliable then the "normal" compiler

[09:58] <grondilu> ok

[09:58] <jnthn> grondilu: Yes. It's specific to the interactive mode, it seems.

[09:58] <moritz> jnthn: new GLOBAL for each line?

[09:59] <jnthn> moritz: Yeah, precisely. I fixed eval to share the caller's GLOBAL recently, but guess the REPL needs fixing too.

[09:59] <grondilu> anyway I'll try to rely less on the REPL from now on.  Thanks.

[10:01] <grondilu> rakudo: my int $n = 0;

[10:01] <p6eval> rakudo 88c330:  ( no output )

[10:01] <grondilu> rakudo: say my int $n = 0;

[10:01] <p6eval> rakudo 88c330: OUTPUT«0␤»

[10:02] <grondilu> this was an other thing that didn't work with REPL (native ints)

[10:02] <grondilu> s/didn't/doesn't/

[10:02] <moritz> I know; there's a ticket for that

[10:02] <grondilu> ok

[10:03] <grondilu> is there an equivalent to 'pack' with perl6 ?

[10:03] <moritz> not yet; masak++ is occasionally working on that

[10:03] <grondilu> ok, I'll wait

[10:04] <jnthn> heh, masak++ is about to arrive at my place. I'll harrass him about it :D

[10:04] <moritz> nom: try eval 'class A { }; subset A of Str where *;'; say $!.WHAT

[10:04] <p6eval> nom 88c330: OUTPUT«Exception()␤»

[10:05] <moritz> nom: try eval 'class A { }; class A { }'; say $!.WHAT

[10:05] <p6eval> nom 88c330: OUTPUT«Exception()␤»

[10:05] <moritz> nom: try eval 'sub A { }; sub A { }'; say $!.WHAT

[10:05] <p6eval> nom 88c330: OUTPUT«X::Redeclaration()␤»

[10:05] <grondilu> gotta go, keep on the good work guys :)

[10:05] *** grondilu left
[10:05] <moritz> that's kind of a problem for testing

[10:05] <moritz> it'd be nice to have tests for those that are different codepaths

[10:05] <moritz> but that's compiler dependent, of course

[10:06] <jnthn> moritz: Earlier you added X::Syntax::Name::NotNull. But the problem is that the name *is* Null, not that it's not null :)

[10:07] <jnthn> Wondering if just X::Syntax::Name::Null works better.

[10:07] <moritz> jnthn: I noticed that I have some inconsistency in the naming, sometimes the error class describes the error, and sometimes how it should be instead

[10:07] <jnthn> moritz: Yeah. I think I prefer describing the error.

[10:07] <moritz> I should probably stick to the first class

[10:09] <moritz> std: subset A;

[10:09] <p6eval> std 47c76b3: OUTPUT«ok 00:01 107m␤»

[10:12] *** fasad joined
[10:13] <dalek> rakudo/nom: 16f7623 | moritz++ | src/Perl6/Grammar.pm:

[10:13] <dalek> rakudo/nom: more typed redeclaration errors

[10:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/16f7623f16

[10:18] <fasad> i really like the "loop" keyword, does exactly what i mean, OTOH "last" it has potential for confusion, why was it chosen? (see http://strangelyconsistent.org/blog/june-4-2011-loops , masak needs to clear the confusion)

[10:18] <moritz> it makes the current iteration the last one

[10:19] *** tokuhirom joined
[10:20] <fasad> no it does not make the current iteration the last one, i quote from the same page "it doesn't just mean "after we're finished with this round of the loop, we won't do any more". It really means "stop doing the loop right now, and continue after it""

[10:24] <fasad> btw, it's the last but one paragraph

[10:30] <masak> fasad: yes, it's confusing in that way.

[10:31] <masak> fasad: that's why I felt the need to clarify it :)

[10:31] <jnthn> Maybe we should call it "gtfo"

[10:31] <masak> fasad: it helps knowing that all of those, next/redo/last, are immediate in effect.

[10:31] <masak> fasad: if you want some delayed effect, you're really looking for a phaser, like END or LAST.

[10:36] <fasad> masak: "break" from C is unambiguous (?)

[10:36] <fasad> one can even think of it as break(out of the loop)

[10:36] *** abercrombie left
[10:41] <masak> fasad: there's a reason next/redo/last are all 4 letters long.

[10:41] <masak> ('cus they're swearwords) :P

[10:42] <masak> it's because they line up nicely, and they're supposed to be short.

[10:42] <masak> break in C does too many things. in Perl 6 parlance, it does both "last" and "succeed".

[10:43] *** daxim joined
[10:45] <masak> ("succeed" takes you out of a "when" block, Perl 6's variant of a "case" statement)

[10:47] <dalek> rakudo/nom: 569f9d0 | moritz++ | src/ (3 files):

[10:47] <dalek> rakudo/nom: rename exception classes

[10:47] <dalek> rakudo/nom: 

[10:47] <dalek> rakudo/nom: jnthn++ noted some inconsistency. Now all the names describe the error condition (and not some how it should be)

[10:47] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/569f9d0cfb

[10:48] <dalek> roast: 4aeddd7 | moritz++ | S06-signature/errors.t:

[10:48] <dalek> roast: test for RT #109064

[10:48] <dalek> roast: review: https://github.com/perl6/roast/commit/4aeddd7ffa

[10:48] <dalek> roast: a97dc2a | moritz++ | S32-exceptions/misc.t:

[10:48] <dalek> roast: track change of error class names; add some more redeclaration tests

[10:48] <dalek> roast: review: https://github.com/perl6/roast/commit/a97dc2a5e0

[11:04] *** Trashlord joined
[11:05] <masak> fasad: I'm happy to hear you're reading the tutorial. let me know if other questions arise -- I'll gladly provide fixes/explanations.

[11:20] *** tokuhirom left
[11:20] *** tokuhirom joined
[11:24] *** tokuhirom left
[11:26] <moritz> nom: say pir::perl6ize_type__PP(pir::set__PS('foo'))

[11:26] <p6eval> nom 569f9d: OUTPUT«Null PMC access in set_string_native()␤  in block <anon> at /tmp/Mr4vzV41YS:1␤  in <anon> at /tmp/Mr4vzV41YS:1␤»

[11:27] <moritz> nom: say pir::perl6ize_type__PP(Q:PIR { $S0 = 'foo'␤%r = box $s␤})

[11:27] <p6eval> nom 569f9d: OUTPUT«use of uninitialized value of type Mu in string context␤use of uninitialized value of type Mu in string context␤===SORRY!===␤error:imcc:'$s' is not a valid register name␤   in file '(file unknown)' line 39839790␤»

[11:28] <moritz> nom: say pir::perl6ize_type__PP(Q:PIR { $S0 = 'foo'␤%r = box $S0␤})

[11:28] <p6eval> nom 569f9d: OUTPUT«foo␤»

[11:29] *** mj41 left
[11:32] <jnthn> moritz: pir::box__Ps('foo') # btw

[11:45] *** mj41 joined
[11:47] *** tokuhirom joined
[11:51] *** tokuhirom left
[11:52] *** Trashlord left
[11:52] *** tokuhir__ joined
[11:52] *** fasad left
[11:56] *** tokuhir__ left
[11:56] *** birdwindupbird joined
[11:59] *** fsergot joined
[12:18] *** orafu left
[12:18] *** bkolera left
[12:18] *** DarthGandalf left
[12:23] *** orafu joined
[12:23] *** bkolera joined
[12:23] *** DarthGandalf joined
[12:34] <moritz> nqp: my $a; my $b; $a := nqp::isnull($b) ?? 'foo' !! 'bar; say($a)

[12:34] <p6eval> nqp: OUTPUT«Confused at line 1, near "$a := nqp:"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[12:34] <moritz> nqp: my $a; my $b; $a := nqp::isnull($b) ?? 'foo' !! 'bar'; say($a)

[12:34] <p6eval> nqp: OUTPUT«bar␤»

[12:35] <moritz> locally I'm trying to do all the boxing to p6 types in method throw

[12:35] <moritz> so that I don't have to clutter up actions.pm and grammar.pm with the boxing

[12:36] <moritz> now curiously, all the tests passed, but when I tried if some exceptions where still printed correctly, I got "Cannot assign a non-Perl 6 value to a Perl 6 container"

[12:37] <moritz> the backtrace indicating that it came from $ex.new call inside throw

[12:37] <fsergot> nom: class Abc { has $.name is rw; method create( Str $name ){ return self.new(:name($name)); } } 

[12:37] <p6eval> nom 569f9d:  ( no output )

[12:37] <moritz> and it drove me mad; why do the tests still pass?

[12:37] <moritz> then I noticed that when running from a file, I don't get an error. Running anything from -e failed

[12:38] <moritz> (I mean, running from a file I got those error messages that I expected)

[12:38] <fsergot> nom: class Abc { has $.name is rw; method create( Str $name ){ return self.new(:name($name)); } }  my $abc = Abc.create('abc'); say $abc.name;

[12:38] <p6eval> nom 569f9d: OUTPUT«===SORRY!===␤Confused at line 1, near "class Abc "␤»

[12:38] <fsergot> nom: class Abc { has $.name is rw; method create( Str $name ){ return self.new(:name($name)); } } ; my $abc = Abc.create('abc'); say $abc.name;

[12:38] <moritz> which mostly solves the mystery: I have probably messed up boxing the file name

[12:38] <p6eval> nom 569f9d: OUTPUT«abc␤»

[12:38] <moritz> I can't see where i messed it up, but at least it's a lead

[12:52] <fsergot> nom: class Abc { has $!test is rw = 'test'; method new { callsame; say $!test; } } Abc.new;

[12:52] <p6eval> nom 569f9d: OUTPUT«===SORRY!===␤Confused at line 1, near "class Abc "␤»

[12:52] <fsergot> nom: class Abc { has $!test is rw = 'test'; method new { callsame; say $!test; } }; Abc.new;

[12:52] <p6eval> nom 569f9d: OUTPUT«Cannot look up attributes in a type object␤  in method new at /tmp/rXxLeaVaDu:1␤  in block <anon> at /tmp/rXxLeaVaDu:1␤  in <anon> at /tmp/rXxLeaVaDu:1␤»

[12:53] <fsergot> nom: class Abc { has $!test is rw = 'test'; method new { callsame; say $self!test; } }; Abc.new;

[12:53] <p6eval> nom 569f9d: OUTPUT«===SORRY!===␤Variable $self is not predeclared at line 1, near "!test; } }"␤»

[12:54] <fsergot> How to use private variable in methods? :)

[12:54] <tadzik> new may be too early

[12:55] <tadzik> nom: class A { has $!a = "foo"; method b { $!a } }; A.new.b.say

[12:55] <p6eval> nom 569f9d: OUTPUT«foo␤»

[12:55] <masak> fsergot: method m { $!p }

[12:55] <fsergot> Even if it has 'default' value?

[12:56] <masak> what does that have to do with anything?

[12:57] <tadzik> fsergot: what are you trying to do?

[12:59] <fsergot> I want to make dir (using makedir() ) after. new.. And make thir dir in $!path. :)

[12:59] <fsergot> s/makedir/mkdir/

[12:59] *** jevenus joined
[13:01] <tadzik> ah, my favourite "do something after new" problem :)

[13:01] <masak> usually goes in BUILD, no?

[13:01] <fsergot> :)

[13:01] *** jevenus left
[13:01] <tadzik> shh, or TimToady will shoult

[13:02] <tadzik> I guess write your own new(), which does bless() and then do stuff

[13:02] <moritz> well, BUILD does work

[13:03] *** bluescreen10 joined
[13:03] <fsergot> gist.github.com/1682667

[13:04] <fsergot> What is the easiest way to solve this?  :)

[13:05] <masak> tadzik: the only thing TimToady doesn't want to do is repeat the error of Moose in that regard.

[13:06] <fsergot> Line 10 is problematic. :)

[13:07] *** bacek left
[13:38] *** shinobicl_ joined
[13:49] <PerlJam> greetings!

[13:49] <flussence> speaking of Moose, yesterday I found out about its BUILDARGS method, which probably would've fixed that problem I had with a lack of simple way to have new() take positional args.

[13:58] *** Trashlord joined
[14:06] <cosimo> masak: what's the problem with that? excuse my ignorance

[14:07] <masak> cosimo: I don't quite remember; I confess to not having grokked this issue 100%

[14:07] <masak> TimToady usually talks about performance with this, though.

[14:07] <masak> cosimo: I bet you'll find loads if you grep for tadzik/BUILD in the IR clogs.

[14:10] *** raiph joined
[14:11] *** benabik left
[14:15] <raiph> hi. next/redo/last. the ambiguity of last has tricked me too. next/redo/done would wfm.

[14:16] <PerlJam> raiph: what abiguity?

[14:16] <raiph> PerlJam: s/ambiguity/misguidance/

[14:17] <raiph> PerlJam: last suggests your in the last time around the loop, but it really means done, now

[14:17] <PerlJam> raiph: Ah, I see.

[14:17] <PerlJam> I guess I'm just too used to Perl to notice that sublty

[14:19] <raiph> it made me wonder once. i noticed fasad's comment earlier

[14:20] <flussence> .oO( whee, I just got Devel::Dwarn to hang on 5.14 and segfault on 5.12 at $dayjob... )

[14:20] *** mj41 left
[14:20] <raiph> in http://www.modernperlbooks.com/mt/2011/08/ chromatic mentions "my list of requirements to use Rakudo for practical purposes"

[14:21] <raiph> links it to http://ttjjss.wordpress.com/2011/08/24/what-is-production-ready/#comment-92

[14:22] <raiph> is Rakudo Star meant to meet those requirements?

[14:23] <PerlJam> raiph: not quite.

[14:23] <flussence> (that Str.indent I wrote for rakudo-b seems to have passed all those tests :)

[14:24] <raiph> PerlJam: is it meant to fully meet some of them, but not others? or not quite match up to any of them? or...?

[14:24] <PerlJam> raiph: it is and it isn't.  R* is just meant to be something useful enough that people will use it, that it happens to meet any of chromatic's "requirements" is somewhat happenstance.

[14:25] <flussence> perl6: say "  a\n   b\n      c".indent(*).perl

[14:25] <raiph> PerlJam: so no commitments, might happen if all goes well from one R* to next?

[14:25] <p6eval> pugs b927740: OUTPUT«*** No such method in class Str: "&indent"␤    at /tmp/gJhsd5NP1y line 1, column 5 - line 2, column 1␤»

[14:25] <p6eval> ..niecza v13-357-g9374d97: OUTPUT«"a\n b\n    c"␤»

[14:25] <p6eval> ..rakudo 569f9d: OUTPUT«Method 'indent' not found for invocant of class 'Str'␤  in block <anon> at /tmp/dEh5o0I7qf:1␤  in <anon> at /tmp/dEh5o0I7qf:1␤»

[14:25] *** tokuhirom joined
[14:25] <PerlJam> raiph: something like that.

[14:26] <raiph> PerlJam: thanks. that's what i thought. (http://perlmonks.org/?node_id=950041)

[14:28] <PerlJam> raiph: once R* has been vetted a little bit (there have been several releases and we've gotten some feedback about the pain points) chromatic's requirements will fall out naturally I think.

[14:29] <[Coke]> It's not like chromatic hangs out on channel or list to provide feedback on these things.

[14:32] <PerlJam> raiph: blah ... now you've got me looking at perlmonks again 

[14:34] <raiph> PerlJam: sorry. it and i got ugly. 

[14:34] *** packetknife joined
[14:34] <PerlJam> I can see that.

[14:34] *** packetknife left
[14:34] *** mj41 joined
[14:35] <PerlJam> I used to think that chromatic was chaotic-good or maybe chaotic-neutral, but now I'm not so sure anymore.

[14:37] <raiph> i wondered if r* could/should/would consider what it would take to meet chaotic-bad chromatic on some level

[14:38] <raiph> or rather, find the good bits among the bad moments

[14:38] *** jaldhar left
[14:42] <PerlJam> chromatic says regarding speed optimizations, "Yes, and several of them I identified years ago. A few of them I volunteered to fix ages ago too, but they turned me down."

[14:42] <PerlJam> Does anyone know to what he is referring?

[14:43] <PerlJam> (me take is that chromatic is conflating Rakudo and Parrot because I don't recall any such discussion wrt Rakudo, but I do remember some wrt Parrot)

[14:43] <PerlJam> s/me/my/

[14:48] *** PacoAir joined
[14:50] <raiph> that's what i think he meant. i think he thinks changes like 6model were a mistake, an avoidable disastrous delay

[14:51] <PerlJam> raiph: only if we're omniscient or have perfect knowledge.

[14:53] <jnthn> Well, yeah, you can always avoid solving the real problems. :)

[14:53] <jnthn> I don't think one has to be omniscient to know that ignoring deep issues will end nowhere good, though.

[14:57] <raiph> jnthn: right. Whiteknight, current Parrot lead dev: "6model is far superior to what Parrot provides now"

[14:59] <[Coke]> eh. parrot has had a LOT of sunk costs. I think rakudo is going forward just fine with what parrot is providing now.

[14:59] <jnthn> If us Rakudo devs had perfect knowledge we'd have known to build 6model a couple of years before we did, known to factor the compiler as Grammar/Actions/World instead of just Grammar/Actions, and known which Parrot primitives were badly mis-matched and not even tried to build things on them in the first place, and known what better ones should replace them. I, for one, have far from perfect knowledge though.

[15:04] *** rsimoes left
[15:05] *** fsergot left
[15:06] <raiph> jnthn: right. action is art, knowledge science.

[15:06] <raiph> the science bit is that you can absolutely know if something's wrong, but not if it's right

[15:07] <raiph> the art bit is you can know you've got to act to tear out mistakes, but not that anything you're currently doing may turn out to be a mistake

[15:07] *** tokuhirom left
[15:12] <raiph> er. i know what i meant. ;) anyway, thanks for your explanations. bas.

[15:15] <jnthn> :)

[15:17] <jnthn> Time for $dayjob evening event, back in a few hours &

[15:21] *** fasad joined
[15:26] *** wtw left
[15:37] <dalek> rakudo/nom: 052cc6a | moritz++ | src/Perl6/ (3 files):

[15:37] <dalek> rakudo/nom: moving boxing of error arguments to Perl6::World

[15:37] <dalek> rakudo/nom: 

[15:37] <dalek> rakudo/nom: previously they were scattered all over Actions.pm and Grammar.pm, and annoyed

[15:37] <dalek> rakudo/nom: me to no end. Now it happens centrally

[15:37] <dalek> rakudo/nom: 

[15:37] <dalek> rakudo/nom: No visible functional changes.

[15:37] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/052cc6a4a6

[15:38] *** shinobicl_ left
[15:40] *** fsergot joined
[15:44] <pmichaud> good morning, #perl6

[15:44] *** kaare_ joined
[15:45] <moritz> good am, pm

[15:45] <moritz> nom: /<foo: 'positional', key => 'value'>/

[15:45] <p6eval> nom 569f9d:  ( no output )

[15:45] <moritz> nqp: /<foo: 'positional', key => 'value'>/

[15:45] <p6eval> nqp: OUTPUT«regex assertion not terminated by angle bracket at line 1, near ", key => '"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[15:45] <moritz> nqp: /<foo: 'positional', :key('value')/

[15:45] <p6eval> nqp: OUTPUT«regex assertion not terminated by angle bracket at line 1, near ", :key('va"␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[15:46] <moritz> that is inconvenient

[15:53] *** arlinius joined
[15:56] <PerlJam> pmichaud: greets!

[15:58] *** fsergot left
[15:59] *** benabik joined
[16:02] <pmichaud> PerlJam: o/

[16:02] *** fasad left
[16:16] *** shinobicl_ joined
[16:17] *** zipf joined
[16:19] *** zipf left
[16:20] *** fsergot joined
[16:21] *** GlitchMr left
[16:25] *** GlitchMr joined
[16:26] *** shinobicl_ left
[16:43] *** fsergot left
[16:45] *** mj41 left
[16:53] *** Trashlord left
[17:01] *** birdwindupbird left
[17:03] *** wolfman2000 left
[17:25] *** fsergot joined
[17:28] *** shinobicl__ joined
[17:38] <fsergot> how to check if file exists using  .IO. ?::)

[17:39] <benabik> 'file'.IO.e

[17:39] <benabik> I think there's another way, but I don't recall it.

[17:40] <PerlJam> stat is still an option isn't it?

[17:40] <PerlJam> (I mean calling stat directly)

[17:40] <fsergot> benabin++ thanks

[17:40] <fsergot> benabik++

[17:45] *** bluescreen10 left
[18:04] <TimToady> hello phenny

[18:04] <phenny> Hey TimToady

[18:04] <phenny> TimToady: 04:06Z <sorear> tell TimToady RFC on https://github.com/sorear/niecza/commit/9374d970bf

[18:04] <TimToady> sorear: initializers are already endsym<ws>

[18:09] <TimToady> so the cleaner fix is to make dottyopish into a rule, I think

[18:09] <TimToady> (well, if we actually followed current sigspace spec, many tokens could turn into rules

[18:09] <TimToady> )

[18:10] *** bluescreen10 joined
[18:11] *** jaldhar joined
[18:12] *** dakkar left
[18:15] <TimToady> actually, dottyopish doens't need a fix either, it already works since the EXPR parsing the declarator/initializer will eat any final space

[18:16] <TimToady> I fooled myself by testing with "my $x .= 42 ;" which failed with an LTA error

[18:19] *** Trashlord joined
[18:26] *** mj41 joined
[18:26] *** Radvendii joined
[18:27] <Radvendii> how does one report errors in perl6? $! seems to be lexically scoped

[18:28] <Radvendii> nom: sub err {$!="testing"}; err; say $!;

[18:28] <p6eval> nom 052cc6: OUTPUT«Any()␤»

[18:28] <Radvendii> nom: sub err {$!="testing"; say $!}; err; say $!;

[18:28] <p6eval> nom 052cc6: OUTPUT«testing␤Any()␤»

[18:28] <Radvendii> mhmm

[18:28] <Radvendii> so what to do?

[18:28] <TimToady> generally, use 'fail'

[18:28] <TimToady> or 'die' if you are inclined to be violent

[18:29] <Radvendii> nom: sub err {fail "testing";}; err; say $!;

[18:29] <p6eval> nom 052cc6: OUTPUT«Any()␤»

[18:29] <doy> global flags are a particularly bad way to report errors

[18:29] <benabik> $! is connected to the exception system

[18:29] <Radvendii> TimToady: what does 'fail' do?

[18:30] <benabik> nom: sub err { fail "testing"; }; say err

[18:30] <p6eval> nom 052cc6: OUTPUT«Failure.new(exception => Exception.new())␤»

[18:30] <TimToady> returns an unthrown exception

[18:30] <benabik> nom: sub err { fail "testing"; }; say ~err

[18:30] <p6eval> nom 052cc6: OUTPUT«testing␤  in method Str at src/gen/CORE.setting:7215␤  in method Stringy at src/gen/CORE.setting:678␤  in sub prefix:<~> at src/gen/CORE.setting:961␤  in block <anon> at /tmp/Gw4TU7S2td:1␤  in <anon> at /tmp/Gw4TU7S2td:1␤»

[18:30] <TimToady> which is supposed to get thrown if you ignore it

[18:30] <Radvendii> doy: it's not really errors, so much as information i need outside as to why i returned false...

[18:30] <TimToady> nom: sub err {fail "testing";}; err // die "Exception: $!"

[18:30] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Null regex not allowed at line 1, near " die \"Exce"␤»

[18:30] <doy> Radvendii: global flags are a bad choice for that too

[18:30] <doy> (:

[18:31] <Radvendii> can i return different things depending on the context i call it in?

[18:31] <TimToady> nom: sub err {fail "testing";}; err() // die "Exception: $!"

[18:31] <p6eval> nom 052cc6: OUTPUT«use of uninitialized value of type Any in string context␤Exception: ␤  in block <anon> at /tmp/O9tenxTTgd:1␤  in <anon> at /tmp/O9tenxTTgd:1␤»

[18:31] <TimToady> that seems like a bug

[18:32] <Radvendii> oh!

[18:32] <Radvendii> i now

[18:32] <Radvendii> know*

[18:32] <Radvendii> i'll return "string blah blah" but False

[18:32] <Radvendii> :D

[18:32] <TimToady> I believe that would be classified as a hack :)

[18:33] <Radvendii> wait... is that a good thing or a bad thing?

[18:33] <TimToady> s/or/and/

[18:33] <Radvendii> :P

[18:33] <Radvendii> how so?

[18:33] <doy> it's good that you are able to do it, it's bad that you think you need to(:

[18:34] <Radvendii> nom: say ?(True but False) #just curious...

[18:34] <p6eval> nom 052cc6: OUTPUT«Bool::True␤»

[18:34] <TimToady> and lying to other parts of your program is usually a code smell

[18:34] <Radvendii> what do you mean lying?

[18:34] <Radvendii> won

[18:35] <Radvendii> if i call the function in string context, it'll return the string, and in Bool context, it'll return False

[18:35] <doy> Radvendii: why are you not using exceptions?

[18:35] <Radvendii> because it's not an error...

[18:36] <Radvendii> it's a method that returns whether a move is legal or not, and I want to also return _why_ the move wasn't legal

[18:36] <doy> why not just do that then?

[18:36] <doy> you're allowed to return multiple things from a function

[18:36] <Radvendii> you are?

[18:37] <Radvendii> doesn't return exit the subroutine?

[18:37] <TimToady> doy means you can return a list

[18:37] <doy> yeah, that

[18:37] <TimToady> return 1,2

[18:37] <Radvendii> oh... but isn't this exactly what 'but' is for?

[18:37] <TimToady> but is for lying

[18:37] <Radvendii> how so...

[18:38] <TimToady> it's a form of deceit

[18:38] <doy> it makes things more confusing

[18:38] * Radvendii cocks an eyebrow

[18:39] <TimToady> in general, mixins are kind of a bad idea if there's a better compile-time way to do the same thing

[18:39] <doy> you have to know you're receiving this special thing that does different things in string and boolean context

[18:39] <TimToady> fail is supposed to be able to return interesting values of undef

[18:39] <Radvendii> right... just like you would have to know you're recieving a list that contains a boolean and a string...

[18:40] <doy> and you end up making mistakes like "my $err = $ret; ... <somewhere later in the code>; if ($err) { print $err }" and then get confused as to why it doesn't work

[18:40] <TimToady> the Failure type is already there to communicate failure plus why

[18:40] <doy> you're breaking assumptions that people will be making without thinking about them

[18:40] <doy> which is a useful thing to be able to do when necessary, but really should be avoided if not

[18:40] *** pmurias joined
[18:40] <pmurias> sorear: hi

[18:41] <Radvendii> okay...

[18:41] <Radvendii> how do i handle the exception once it's thrown?

[18:41] <TimToady> mixins are like eval or BEGIN that way; these are 'big cannons' that let you swat a fly with an asteroid

[18:41] <Radvendii> (from 'fail')

[18:42] <TimToady> fail doesn't throw; use die to force a throw

[18:42] <doy> what's wrong with returning a list (or a Failure object)?

[18:42] <doy> if it's not an error, those seem like better options

[18:42] <Radvendii> i just do: Failure.new("err_message") ?

[18:43] <Radvendii> nom: say ~Failure.new("test")

[18:43] <TimToady> you handle exceptions with try {...} or with a CATCH block

[18:43] <p6eval> nom 052cc6: OUTPUT«Method 'throw' not found for invocant of class 'Str'␤  in method Str at src/gen/CORE.setting:7215␤  in method Stringy at src/gen/CORE.setting:678␤  in sub prefix:<~> at src/gen/CORE.setting:961␤  in block <anon> at /tmp/KpRLKU5fEC:1␤  in <anon> at /tmp/KpRLKU5fEC:1␤»…

[18:43] <TimToady> you handle failure (unthrown exception) by testing for definedness

[18:44] *** birdwindupbird joined
[18:44] <Radvendii> huh?

[18:44] <Radvendii> im having a hard time working in the abstract, which sNUM is this in?

[18:45] <TimToady> Failure is in many S's; grep is your friend

[18:46] <TimToady> biab

[18:48] *** mj41 left
[18:50] <cognominal> jnthn, thx for opening my eyes. Reading zavolaj and sixmodel code, I understand that messing with specialized array pmc would be a bad idea.

[18:50] <cognominal> *specialized parrot array pmcs

[18:53] <Radvendii> nom: say ?"test" #strings evaluate to...

[18:53] <p6eval> nom 052cc6: OUTPUT«Bool::True␤»

[18:53] <Radvendii> nom: say ?"" #strings evaluate to...

[18:53] <p6eval> nom 052cc6: OUTPUT«Bool::False␤»

[18:54] *** Chillance joined
[18:56] <Radvendii> nom: say +(False but 5) ##Is this a bug??

[18:56] <p6eval> nom 052cc6: OUTPUT«0␤»

[18:57] <benabik> nom: say +(False but Int(5))

[18:57] <p6eval> nom 052cc6: OUTPUT«Can only supply an initialization value for a role if it has a single public attribute␤  in sub infix:<but> at src/gen/CORE.setting:8757␤  in block <anon> at /tmp/k_wRRhko1r:1␤  in <anon> at /tmp/k_wRRhko1r:1␤»

[18:57] <benabik> Oh.  Hm.

[18:57] <benabik> I think but isn't fully implemented.  I think it can mix-in roles, but not values.

[18:58] <Radvendii> oh...

[18:58] <Radvendii> and 'but False' automatically makes a role with .BOOL returning Fals?

[18:58] <Radvendii> False*

[18:58] <benabik> I think it's suppose to?

[18:59] <benabik> nom: say +(False but role { method Numeric { 5 } })

[18:59] <p6eval> nom 052cc6: OUTPUT«5␤»

[18:59] <benabik> nom: say +(False but role { method Int { 5 } })

[18:59] <p6eval> nom 052cc6: OUTPUT«0␤»

[19:00] <Radvendii> weird...

[19:01] <Radvendii> nom: say +(False but +(5))

[19:01] <p6eval> nom 052cc6: OUTPUT«0␤»

[19:01] <Radvendii> nom: say +(False but 5.0) ##maybe with decimals?

[19:01] <p6eval> nom 052cc6: OUTPUT«0␤»

[19:01] <Radvendii> ##nope

[19:02] <Radvendii> what about big numbers... those are 'Numeric' right?

[19:02] <Radvendii> nom: say +(False but 1233543534634534) ## big numbers

[19:02] <p6eval> nom 052cc6: OUTPUT«0␤»

[19:02] <Radvendii> :P

[19:02] <cognominal> nom: say +(False but 5)

[19:02] <benabik> Ahh....

[19:02] <p6eval> nom 052cc6: OUTPUT«0␤»

[19:02] <benabik> nom: say (False but 5).Int

[19:02] <p6eval> nom 052cc6: OUTPUT«5␤»

[19:03] <Radvendii> it's a problem with + not calling int

[19:03] <Radvendii> nom: say +(False but sqrt(5))

[19:03] <p6eval> nom 052cc6: OUTPUT«0␤»

[19:03] <benabik> Yes.  + looks for Numeric, which is a roll that Int, Num, etc implement.

[19:03] <benabik> *role

[19:04] <Radvendii> And Int's Numeric isn't returning the right value...

[19:04] <benabik> Bool has a .Numeric already, and the mixin isn't overriding it.

[19:04] <Radvendii> ooooh

[19:04] <Radvendii> right

[19:04] <benabik> The mixing only overrides Int.

[19:05] <Radvendii> I understand...

[19:05] <benabik> Which is interesting.  Perhaps value mixin should override conversions for all roles that the mixed in value does but the original value doesn't.

[19:06] <colomon> what should happen if you say +(5.0 but 6)?

[19:06] <benabik> In that scheme, 5.0 is already Numeric, so it would be 5.0...

[19:06] * Radvendii cries

[19:07] <colomon> nom: say Bool ~~ Numeric

[19:07] <Radvendii> who would do 5.0 but 6?

[19:07] <p6eval> nom 052cc6: OUTPUT«Bool::False␤»

[19:07] <Radvendii> say defined Bool.Numeric

[19:07] <Radvendii> nom: say defined Bool.Numeric

[19:07] <p6eval> nom 052cc6: OUTPUT«use of uninitialized value of type Bool in numeric context␤Bool::True␤»

[19:07] <colomon> Who would do False but 5?  ;)

[19:07] <benabik> Oh.  5.0 isn't Numeric?

[19:08] <Radvendii> colomon: well, that makes more sense, at least it's two different categories...

[19:08] <colomon> 5.0 is Numeric.  According to spec, Bool is too

[19:08] <benabik> nom: say Numeric ~~ 5.0.WHAT

[19:09] <p6eval> nom 052cc6: OUTPUT«Bool::False␤»

[19:09] <[Coke]> nom: my $a="three" but "four"; say $a;

[19:09] <p6eval> nom 052cc6: OUTPUT«three␤»

[19:09] <[Coke]> nom: my $a="three" but "four"; say ~$a;

[19:09] <p6eval> nom 052cc6: OUTPUT«three␤»

[19:09] * [Coke] gives up. ;)

[19:10] <benabik> but $value is a strange strange thing.

[19:11] * [Coke] wonders how much nicer nqp is than npq-rx

[19:11] <Radvendii> npq?

[19:11] <[Coke]> (and if it is worth switching partcl-nqp to use it insted)

[19:11] <[Coke]> typo

[19:12] <benabik> [Coke]: nqp has 6model and dyncall and a lot of framework that Rakudo uses, but the rest of Parrot uses.

[19:12] <benabik> *Parrot doesn't

[19:12] <benabik> (That said, I find many of the things nqp added very interesting and probably useful.  But they haven't been stolen back yet, which makes interaction interesting.)

[19:15] *** rsimoes joined
[19:18] <Radvendii> nom: my $a = {say "test"}; $a();

[19:18] <p6eval> nom 052cc6: OUTPUT«test␤»

[19:19] <[Coke]> benabik: most of partcl-nqp is just nqp. There's as little PIR as I can get away with.

[19:19] <Radvendii> nom: my %a = {b => "b", c => (%a{b} ~ 'c')}; say %a<c>

[19:19] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&b' called (lines 1, 1)␤»

[19:20] <Radvendii> nom: my %a = {b => "b", c => (%a<b> ~ 'c')}; say %a<c>

[19:20] <p6eval> nom 052cc6: OUTPUT«use of uninitialized value of type Any in string context␤c␤»

[19:20] <benabik> [Coke]: NQP builds 6model objects.  If you try to interact with non-6model parrot, it can be interesting.

[19:20] <Radvendii> nom: my %a = {b => "b", c => {%a<b> ~ 'c'}}; say %a<c>

[19:20] <p6eval> nom 052cc6: OUTPUT«Block.new()␤»

[19:20] <Radvendii> nom: my %a = {b => "b", c => {%a<b> ~ 'c'}}; say %a<c>.eval

[19:20] <p6eval> nom 052cc6: OUTPUT«Method 'eval' not found for invocant of class 'Block'␤  in block <anon> at /tmp/Dr0eJoJ32k:1␤  in <anon> at /tmp/Dr0eJoJ32k:1␤»

[19:20] <[Coke]> benabik: interacting with other things on parrot has never been stable, so that's not really an issue for me.

[19:20] <Radvendii> nom: my %a = {b => "b", c => {%a<b> ~ 'c'}}; say %a<c>.try

[19:20] <p6eval> nom 052cc6: OUTPUT«Method 'try' not found for invocant of class 'Block'␤  in block <anon> at /tmp/5_iS2nVOAd:1␤  in <anon> at /tmp/5_iS2nVOAd:1␤»

[19:21] <benabik> [Coke]: Fair enough.

[19:21] <[Coke]> it worked briefly thanks to... Tene? but it's not something that is regularly tested. at this point I'd be happy to be able to interact with rakudo, so that's fine.

[19:22] *** Transformer joined
[19:24] *** Transformer left
[19:24] <Radvendii> does "shaped variable declarations" (e.g. %{$b}) mean that there will be a hash named with whatever is inside $b?

[19:27] <Tene> [Coke]: I'm very sad about what happened with parrot hll interop. :(

[19:31] *** spine joined
[19:32] *** daxim left
[19:41] *** pyrimidine joined
[19:54] <[Coke]> Tene: me too. sorry. :(

[19:54] * [Coke] notes that nqp is not a drop in replacement for parrot-nqp

[19:56] <[Coke]> any pointers on doing that cutover?

[19:58] <moritz> at first glance, the two are pretty similar

[19:58] <moritz> nqp has a bit stricter parsing rules

[19:58] <[Coke]> no HLL::Actions or HLL::Compiler, e.g.

[19:58] <moritz> but if you don't emit 6modelish code, you don't have to use it much

[20:03] *** bluescreen10 left
[20:03] *** bluescreen10 joined
[20:03] <pmichaud> nqp can have HLL::Actions and HLL::Compiler; you just have to be sure to "import" them, I think.

[20:04] <diakopter> !

[20:04] <[Coke]> (this is the file I'm trying to update) https://github.com/partcl/partcl-nqp/blob/master/src/ARE/Actions.pm

[20:04] <pmichaud> certainly NQP uses HLL::Actions and HLL::Compiler

[20:04] * [Coke] tries the import.

[20:04] <pmichaud> see src/NQP/Actions.pm and src/NQP/Compiler.pm

[20:05] <pmichaud> I'm not sure that NQP supports the semi-colon-terminated declaration form anymore

[20:05] <pmichaud> might need curlies

[20:05] <pmichaud> (or that might not be the problem)

[20:06] <[Coke]> pmichaud: there's no import in src/NQP/Actions.pm

[20:06] <pmichaud> [Coke]: yeah, I just noticed that; so perhaps I'm mis-thinking about that.

[20:06] <pmichaud> (probably)

[20:07] <pmichaud> still, it shows that NQP itself is able to make use of HLL:: stuff somehow

[20:07] <pmichaud> rakudo does it also

[20:08] <[Coke]> nqp: class Foo is HLL::Actions {}

[20:08] <p6eval> nqp: OUTPUT«Could not find parent class 'HLL::Actions' at line 1, near ""␤current instr.: 'nqp;HLL;Grammar;panic' pc 23433 (src/stage2/gen/NQPHLL.pir:6734) (src/stage2/gen/NQPHLL.pm:329)␤»

[20:08] <[Coke]> nqp: use HLL::Actions; class Foo is HLL::Actions {}

[20:08] <p6eval> nqp: OUTPUT«"load_bytecode" couldn't find file 'HLL/Actions.pbc'␤current instr.: 'nqp;ModuleLoader;_block1104' pc 2314 (src/stage2/gen/module_loader.pir:1073) (src/ModuleLoader.pm:63)␤»

[20:08] <Radvendii> i thought i rememberd, but can't find, there was a syntax for anonymous arguments or the like. the way it worked was something like @a.map: {$b ~ $c} and the compiler would know that you want two variables out of @a. Was this just in my imagination?

[20:09] <pmichaud> Radvendii: placeholder variables, perhaps/

[20:09] <pmichaud> ?

[20:09] <Radvendii> i know i can just do @a.map: -> $b,$c {$b ~ $c}, im wondering if there's a way to implicitly declare that

[20:09] <pmichaud>   { $^b ~ $^c }

[20:09] <Radvendii> pmichaud: what does that look like?

[20:09] <Radvendii> ah

[20:09] <Radvendii> yes

[20:09] <Radvendii> that's what i was missing

[20:09] <Radvendii> thanks

[20:10] <TimToady> -> [$a, $b] {...}

[20:10] <TimToady> oh, you want them separate, nm

[20:10] <Radvendii> but that's interesting... you can do patern matching in lambdas?

[20:11] <pmichaud> Radvendii: yes.  :-)

[20:11] <Radvendii> that's quite useful...

[20:12] <pmichaud> [Coke]: src/NQP/World.pm does "use NQPP6Regex"

[20:12] <PerlJam> I know I asked this before, but I've since forgotten the answer ... does  -> @foo[$a,$b] { ... }  work to refer to the aggregate as @foo and the parts as $a and $b?

[20:12] <[Coke]> nqp: use NQPP6Regex; class Foo is HLL::Actions {}

[20:12] <p6eval> nqp:  ( no output )

[20:12] <pmichaud> I think that brings in the HLL::* classes

[20:12] <[Coke]> pmichaud: heh. I just found that. ;)

[20:12] <[Coke]> pmichaud++ # thanks.

[20:13] <TimToady> PerlJam: yes, but I would write it @foo [$a, $b] to make it clear it isn't subscripting

[20:13] <PerlJam> aye. good point.

[20:13] <Radvendii> indeed, that confused me,

[20:14] <Radvendii> nom: my $1 # numerical variables?

[20:14] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Cannot declare a numeric variable at line 1, near " # numeric"␤»

[20:14] <Radvendii> D-:

[20:14] <Radvendii> why not?

[20:15] <colomon> std: my $1

[20:15] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Cannot declare a numeric variable at /tmp/Hl_YxxMVOn line 1:␤------> my $1⏏<EOL>␤Parse failed␤FAILED 00:01 108m␤»

[20:15] <TimToady> $1 really means $/[1]

[20:15] <Radvendii> oh right...

[20:15] <Radvendii> std: my $1a

[20:15] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Cannot declare a numeric variable at /tmp/OcV5P40LHN line 1:␤------> my $1⏏a␤Parse failed␤FAILED 00:01 108m␤»

[20:16] <Radvendii> so it can't even start with a number eh?

[20:16] <TimToady> illegal identifier in any case

[20:17] <TimToady> std: $1a

[20:17] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Whitespace is required between alphanumeric tokens at /tmp/LnBf5lLTye line 1:␤------> $1⏏a␤Two terms in a row at /tmp/LnBf5lLTye line 1:␤------> $1⏏a␤    expecting any of:␤   POST␤   bracketed infix␤        in…

[20:18] <Radvendii> TimToady: Eh... it's resonable not to allow numbers at the beginning of variables, chances are you're making a mistake

[20:18] <TimToady> we don't allow them after - or ' either

[20:18] <TimToady> std: my $foo-bar; # ok

[20:18] <p6eval> std 47c76b3: OUTPUT«ok 00:01 108m␤»

[20:19] <TimToady> std: my $foo-1st; # not ok

[20:19] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Whitespace is required between alphanumeric tokens at /tmp/bOZbmtTzc0 line 1:␤------> my $foo-1⏏st; # not ok␤Two terms in a row at /tmp/bOZbmtTzc0 line 1:␤------> my $foo-1⏏st; # not ok␤    expectin…

[20:19] <TimToady> it took it as $foo - 1st

[20:19] <Radvendii> oh...

[20:19] <Radvendii> that makes some sense

[20:19] <TimToady> well $foo - 1 plus garbage

[20:20] <Radvendii> nom: sub a-b {}; a_b(); #i've been curious...

[20:20] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a_b' called (line 1)␤»

[20:20] <TimToady> we subtly discourge the use of variable names for indexing :)

[20:20] <Radvendii> resonable, that's what arrays are for

[20:20] <Radvendii> but how come sometimes people refer to at_pos and sometimes at-pos?

[20:20] <TimToady> no, we don't canonicalize anything that is visually distinctive, and we're not sure about NFC vs NFD :)

[20:21] <TimToady> maybe rakudo and niecza have it different?

[20:21] <Radvendii> NFC? NFD?

[20:21] <TimToady> those functions are not part of the spec

[20:21] <Radvendii> oh... that would be weird

[20:21] <TimToady> Unicode normalization forms

[20:21] <pmichaud> not *yet* part of the spec :)

[20:22] <pmichaud> (we need to decide what part of the spec provides them :)

[20:22] <benabik> Presumably it should actually be AT_POS, like most of the other magic methods.

[20:22] <TimToady> anything both implementations agree on, and will not adversely affect future implementations, is fair game for the spec, if it's really a language-level issue

[20:23] *** ksi joined
[20:23] <TimToady> pmichaud: I'd think this is S09 territory

[20:23] <pmichaud> could be S07 also

[20:23] <pmichaud> (since S07 covers lists)

[20:23] <TimToady> you guys might accidentally have implemented part of S09 already :P

[20:24] <Radvendii> nom: $a=[<a b>]; say $a.WHAT

[20:24] <p6eval> nom 052cc6: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "=[<a b>]; "␤»

[20:24] <Radvendii> nom: my $a=[<a b>]; say $a.WHAT

[20:24] <p6eval> nom 052cc6: OUTPUT«Array()␤»

[20:25] <TimToady> speaking of which, I've been leaning towards making shape declarations dynamic like in Algol, on the assumption that the compiler can recognize constants and optimize shapes known at compile time

[20:25] <Radvendii> but it's a reference...

[20:25] <moritz> Radvendii: everything is a reference... well, except the things that aren't

[20:25] <benabik> nom: my $a=[<a b>]; say $a.WHAT; say $a[0].WHAT

[20:25] <p6eval> nom 052cc6: OUTPUT«Array()␤Str()␤»

[20:26] <Radvendii> right, i know you can use it as an array... never mind

[20:26] <Radvendii> nom: say ([«,»]((<a b> Z <d e>).map: {[$^a...$^b]})).perl

[20:26] <p6eval> nom 052cc6: OUTPUT«Nominal type check failed for parameter '$op'; expected Any but got Mu instead␤  in sub METAOP_REDUCE at src/gen/CORE.setting:9018␤  in block <anon> at /tmp/jISdQrB1gU:1␤  in <anon> at /tmp/jISdQrB1gU:1␤»

[20:26] <Radvendii> why's that?

[20:26] <moritz> Radvendii: http://perl6advent.wordpress.com/2011/12/16/where-have-all-the-references-gone/

[20:26] <Radvendii> it works if i use s/[«,»]/[Z]/

[20:27] <Radvendii> moritz: :P @ title

[20:27] <moritz> wtf is «,» supposed to do?

[20:27] <benabik> Can you use [«op»]?

[20:28] <moritz> std: [«+»]

[20:28] <p6eval> std 47c76b3: OUTPUT«===SORRY!===␤Prefix requires an argument at /tmp/tPbnMVB5b4 line 1 (EOF):␤------> [«+»]⏏<EOL>␤Parse failed␤FAILED 00:01 108m␤»

[20:28] <moritz> std: [«+»] 1, 2

[20:28] <p6eval> std 47c76b3: OUTPUT«ok 00:01 109m␤»

[20:28] <moritz> benabik: in principle, yes

[20:29] <Radvendii> I'm using it because in my actual code i dont know which one is longer

[20:29] <Radvendii> like:

[20:29] <TimToady> basically, any container that is not declared to hold a native type is a reference

[20:29] <TimToady> which means, if you think about it, that a reference is just the default native type

[20:29] <moritz> Some people, when faced with a problem, think "oh, I could solve that with three nested levels of meta operators".

[20:30] <[Coke]> moritz+++++++

[20:30] <Radvendii> :P

[20:30] <Radvendii> it really is the best solution though.

[20:30] <Radvendii> idealy

[20:30] <Radvendii> i would say Z...

[20:31] <Radvendii> but that fails, because the list flattnes

[20:31] <Radvendii> flattens*

[20:31] <TimToady> unfortunately, the end of that is "Now they have {(0..4).pick} problesm"

[20:31] <Radvendii> TimToady: that doesnt use any meta-ops...

[20:32] <TimToady> it was a meta-utterance already

[20:32] <[Coke]> should nqp support -o <foo>? (right now it seems to require the =)

[20:32] <TimToady> or perhaps meta-meta-

[20:33] <Radvendii> look. i have two arrays with two values each (indicies in a grid) i want to get all of the spaces in between them (the trajectory). you tell me how to do it without three meta-ops

[20:33] <[Coke]> er, I lied. -o=foo fails, but -o foo also dumps to std.

[20:34] <moritz> [Coke]: oh, one more thing. the new nqp sometimes doesn't like upper-case targets

[20:34] <moritz> [Coke]: ie --target=pir instead of PIR

[20:35] <moritz> it's supposed to be the same, but there seem to be one or two places where an lc() is missing

[20:36] *** birdwindupbird left
[20:37] <dalek> nqp: 173935c | moritz++ | src/HLL/Compiler.pm:

[20:37] <dalek> nqp: missing downcase for %adverbs<target>

[20:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/173935c895

[20:37] <moritz> not anymore, hopefully :-)

[20:44] <[Coke]> moritz: how about this regex: token barechar { <-[\\\[*+?^$]> }

[20:45] <[Coke]> (it dies in nqp, works in nqp-rx)

[20:51] <moritz> nqp: token barechar { <-[\ß\[*+?^$]> }

[20:51] <p6eval> nqp:  ( no output )

[20:51] <moritz> nqp: token barechar { <-[\\\[*+?^$]> }

[20:51] <p6eval> nqp:  ( no output )

[20:52] <[Coke]> if I uncomment it from my grammar, I get:

[20:52] <[Coke]> ResizablePMCArray: Can't shift from an empty array!

[20:52] <[Coke]> current instr.: 'nqp;PAST;Regex;prefix_enumcharlist' pc 532 (src/PAST/Regex.pir:

[20:52] <[Coke]> 257)

[20:56] * [Coke] will get things mostly working in a branch of partcl-nqp and push and then beg for help on the remaining broken bits, but not not.

[20:56] <[Coke]> not now.

[20:57] *** apesma joined
[20:58] <[Coke]> moritz++ pmichaud++

[20:58] *** Trashlord left
[20:58] <Radvendii> where can i report bugs? i understand that it's not very important because it's very infrequent that one needs [«,»], but it's probably good to know that it's broken, no?

[21:01] <colomon> [email@hidden.address] for rakudo bugs.

[21:01] <colomon> but are you really certain it's a bug?  It's not at all clear to me that [«op»] makes any sense

[21:02] <Radvendii> well, the alternative is @a[0] «,» @a[1] which seems like exactly what [op] is for

[21:03] <colomon> https://github.com/sorear/niecza/issues for niecza bugs

[21:03] <Radvendii> niecza: say ([«,»]((<a b> Z <d e>).map: {[$^a...$^b]})).perl

[21:03] <p6eval> niecza v13-357-g9374d97: OUTPUT«[$("a", "b"), $("b", "c"), $("c", "d"), $("d", "e")].list␤»

[21:04] <Radvendii> bam. it can't be on purpose, niecza allows it.

[21:04] *** MayDaniel joined
[21:06] *** GlitchMr left
[21:06] * jnthn back

[21:07] <jnthn> mmm...birthday beer :)

[21:07] <pmichaud> oh yeah!  Happy birthday!

[21:07] <jnthn> ;)

[21:07] <pmichaud> I even had that on my calendar, but haven't checked my calendar yet.

[21:07] <jnthn> pmichaud: Thanks! :)

[21:07] <Radvendii> \o/ party on #perl6 time \o.

[21:07] <jnthn> (Yes, I consuemd some beers)

[21:07] <jnthn> *consumed # wow, evidently sufficient :P

[21:08] <jnthn> pmichaud: How's the Star configure stuff coming along?

[21:08] <pmichaud> I worked on it some more this morning but got a little sidetracked.  I should be able to get most of it done tonight, however.

[21:08] <tadzik> happy birthday jnthn!

[21:08] <jnthn> pmichaud: yay :)

[21:09] <jnthn> pmichaud: Tomorrow I'll have tuits, though Perl 6 has to compete with writing a bunch of talks for next week. Next week is a bit away, though. :)

[21:09] <jnthn> tadzik: :)

[21:09] <flussence> hb o/

[21:11] <Radvendii> the niecza website says 2.6.7 fails on mac os x, 2.6.4 is fine, but it says nothing about 2.8.2 or 2.10 (which it recomends)

[21:11] <Radvendii> which do i download?

[21:11] <jnthn> [Coke]: I didn't backlog in detail, but if you have parrot-nqp to nqp migration issues still, let me know.

[21:11] <Radvendii> and by niecza website i mean github

[21:11] <jnthn> [Coke]: It's much stricter about needing "use" statements - it actually does separate compilation. :)

[21:11] <colomon> Radvendii: I'm using mono version 2.10.2 on OS X 10.6.

[21:12] <Radvendii> colomon: sweet.

[21:12] <Radvendii> do i have to download mono somewher else?

[21:14] <benabik> Radvendii: http://www.go-mono.com/mono-downloads/download.html

[21:14] <colomon> benabik++ just beat me to it.

[21:14] <colomon> hmmm, I'm .6 versions behind now, I see.  :)

[21:14] <Radvendii> sorry guys... you don't have to do that, you could just say "yes"

[21:15] <benabik> I'm using niecza v13-193-g3edf7eb on mono 2.10.8.1

[21:15] <benabik> Radvendii: It's not a big deal.  Finding URLs in browser history is rather fast.

[21:15] * masak back

[21:16] <[Coke]> jnthn: my current problem is this line:

[21:16] <[Coke]> https://github.com/partcl/partcl-nqp/blob/master/src/ARE/Grammar.pm#L27

[21:16] <Radvendii> benabik: okay... Someone just told me at some point not to ask questions i could just look up, (which is totally resonable)

[21:17] <[Coke]> (the rest of the file was updated for the needed "use", and changed the grammar to use curlies instead of a ; declaration.

[21:17] <[Coke]> jnthn++

[21:17] <benabik> Radvendii: It's generally nice to look something up first, but grabbing the URL isn't much slower than saying yes for me.  :-)

[21:17] <Radvendii> benabik: okay.

[21:18] <jnthn> [Coke]: Yes, those were pretty much the only two changes Rakudo's grammar/actions needed.

[21:19] <jnthn> [Coke]: How's it failing? I'm a bit surprised about a failure there since nqp master still uses the old regex engine. If it were using QRegex I'd not be so surprised...

[21:20] <[Coke]> https://gist.github.com/1685180

[21:20] <[Coke]> If I comment out that line, no error.

[21:20] *** MayDaniel left
[21:20] <masak> today only 3 days remain until we close p6cc for submissions!

[21:20] <tadzik> aw, snap

[21:22] *** Trashlord joined
[21:22] <Radvendii> i'm assuming p6cc is not a chinese website with sexually explicit material

[21:22] <tadzik> it is!

[21:22] <Radvendii> yes, but i assume that's not what you're refering to?

[21:23] <jnthn> nqp: grammar g { token barechar { <-[\\\[*+?^$]> } }

[21:23] <p6eval> nqp: OUTPUT«ResizablePMCArray: Can't shift from an empty array!␤current instr.: 'nqp;PAST;Regex;prefix_enumcharlist' pc 532 (src/PAST/Regex.pir:257)␤»

[21:23] <tadzik> ...there is something like this, seriously?

[21:23] <tadzik> No, don't link to it

[21:23] <jnthn> o.O

[21:23] <Radvendii> it's just p6cc.com

[21:24] <Radvendii> aaaanyways...

[21:24] <Radvendii> what's p6cc as far as you're concerned?

[21:24] <jnthn> Perl 6 Coding Contest :)

[21:25] <Radvendii> oh

[21:25] <Radvendii> that would make more sense

[21:25] <masak> jnthn: heh -- you never harassed me about &pack as you were supposed to, according to les logs ;)

[21:26] <pmichaud> perhaps he was harassing you with silence

[21:26] <masak> wait, p6cc is a what website? o.O

[21:26] *** y3llow_ joined
[21:27] *** pothos_ joined
[21:27] <masak> I suddenly feel like I should've checked this before choosing an acronym...

[21:28] <benabik> Whenever naming a project, remember to google it.

[21:28] <benabik> (With safe search off.)

[21:28] *** y3llow left
[21:28] <Radvendii> :P indeed

[21:28] <masak> I'll keep that in mind.

[21:29] *** pothos left
[21:29] *** y3llow_ left
[21:29] <masak> still, there's 3 days remaining in our contest which doesn't have a lot of sexually explicit material in it at all.

[21:29] *** y3llow joined
[21:30] *** pothos_ left
[21:30] *** pothos joined
[21:31] <Radvendii> i wish i'd heard of this earlier, nonetheless i'll get to trying them out at some point, for or not for the contest

[21:32] *** y3llow left
[21:32] *** y3llow joined
[21:33] *** pothos left
[21:33] *** pothos joined
[21:33] <masak> yeah, it's a bit late to sign up for them this time around.

[21:33] <masak> but there will be another one next Christmas, I'm sure ;)

[21:34] *** y3llow left
[21:34] <Radvendii> colomon: I can't find the mac executable for Niecza...

[21:34] <Radvendii> (v13)

[21:34] *** y3llow joined
[21:34] <colomon> Radvendii: there is no such thing.  there's just a single executable

[21:35] <Radvendii> .exe?

[21:35] <colomon> yes

[21:35] <benabik> mono run/Niecza.exe

[21:35] <Radvendii> that'll run on a mac?

[21:35] <Radvendii> oh

[21:35] <Radvendii> i see

[21:35] <colomon> mono run/Niezc.... what benabik said

[21:35] <benabik> colomon: :-D

[21:35] <colomon> benabik++ # one step faster than me again

[21:35] <benabik> colomon: Normally I don't get praised for interrupting.  :-D

[21:36] <colomon> benabik: we prefer to say answering.  :)

[21:36] <jnthn> [Coke]: On the one hand, I can sorta see why it explodes. OTOH, the bit of code that does is unchanged since ages.

[21:36] *** y3llow left
[21:37] *** y3llow joined
[21:37] <Radvendii> oh! is there any way to niecza a file?

[21:37] <colomon> errr, what?

[21:37] <colomon> you mean run a script with niecza?

[21:38] <colomon> mono run/Niecza.exe mandelbrot.pl

[21:38] <Radvendii> ah

[21:38] <Radvendii> cool

[21:38] *** kaare_ left
[21:39] <Radvendii> can i include the entire path to Niecza.exe and run it from anywhere?

[21:39] <Radvendii> like mono /path/to/Niecza.exe file.pl

[21:39] <colomon> yes

[21:43] <[Coke]> jnthn: so, is there a way to get that token without 'sploding?

[21:44] <jnthn> [Coke]: Well, my first attempt at a patch made NQP compilation explode... :)

[21:45] <[Coke]> WHEE!

[21:45] <Radvendii> Is there a way to get command history on niecza? (Like, i know CPAN offers it only after you download some module or something...)

[21:46] <Radvendii> nor can I even go "back" in a line of code...

[21:47] <jnthn> [Coke]: oh, looking again, it may just be an inverted conditional

[21:48] <jnthn> [Coke]: https://gist.github.com/1685315 seems to help

[21:49] <Radvendii> niecza: say (1,2,3)[*-2]

[21:50] <p6eval> niecza v13-357-g9374d97: OUTPUT«2␤»

[21:50] <jnthn> [Coke]: It passes tests so, pushing it.

[21:50] <dalek> nqp: c9a8997 | jnthn++ | src/PAST/Regex.pir:

[21:50] <dalek> nqp: Fix what appears to be an inverted condition in the old regex engine's charlist prefix computation.

[21:50] <dalek> nqp: review: https://github.com/perl6/nqp/commit/c9a8997602

[21:51] *** apesma left
[21:56] <Radvendii> is there a way to use 'when{}' _without_ the break associated with it? to fall through to the other 'when's?

[21:57] <jnthn> Radvendii: use "proceed"

[21:58] <Radvendii> as the last statment?

[21:58] <Radvendii> well, duh :P

[21:59] <masak> perl6: given 42 { say 1; succeed; say 2 }; say 3

[22:00] <p6eval> niecza v13-357-g9374d97: OUTPUT«1␤3␤»

[22:00] <p6eval> ..rakudo 052cc6: OUTPUT«1␤succeed without when clause␤  in block <anon> at /tmp/Xpqe7jLGGp:1␤  in block <anon> at /tmp/Xpqe7jLGGp:1␤  in <anon> at /tmp/Xpqe7jLGGp:1␤»

[22:00] <p6eval> ..pugs b927740: OUTPUT«1␤*** No such subroutine: "&succeed"␤    at /tmp/zMqNV3st0l line 1, column 19-26␤»

[22:00] <masak> I'm with Niecza here, but I haven't checked the spec.

[22:00] <masak> if Niecza is wrong, how does one break out of a 'given' block between 'when' statements?

[22:02] <[Coke]> if I have src/A/B.pm that isa src/D/E.pm , how can I "use" that? do I need to muck with INC?

[22:02] <[Coke]> (nqp)

[22:02] <tadzik> :)

[22:02] <tadzik> ww

[22:04] <[Coke]> (use src::D::E; seems to work. ;)

[22:04] <Radvendii> masak: no no, i want to do a when statement without breaking out

[22:04] <masak> Radvendii: got you.

[22:04] <masak> Radvendii: I just got to thinking about the above use case.

[22:05] <Radvendii> oh

[22:05] <masak> since 'given' is not technically a loop, you can't 'last' out of it.

[22:05] <masak> so the question is, how *do* you get out of it?

[22:05] <masak> (maybe the correct answer is "you should do 'for 42', duh!". I dunno.)

[22:06] <colomon> return!

[22:06] <jnthn> masak: leave!

[22:06] <colomon> fly, you fools!

[22:07] <Radvendii> :P

[22:09] <Radvendii> niecza: given 42 { when Int {say "test"; proceed}; when 42 {say "YAY!"}}

[22:09] <p6eval> niecza v13-357-g9374d97: OUTPUT«test␤YAY!␤»

[22:10] <Radvendii> niecza: say ?("5" but False || True) # precidence of 'but' test

[22:11] <p6eval> niecza v13-357-g9374d97: OUTPUT«Bool::True␤»

[22:15] <Radvendii> does niecza support :arg(value) syntax yet?

[22:15] <Radvendii> niecza: sub a(:$foo) { say $foo }; a(:foo("bar"));

[22:15] <p6eval> niecza v13-357-g9374d97: OUTPUT«bar␤»

[22:16] <masak> jnthn: oh! 'leave', of course. thanks :)

[22:16] <Radvendii> niecza: sub a(:$foo) { say $foo }; a(:foo(False));

[22:16] <p6eval> niecza v13-357-g9374d97: OUTPUT«Bool::False␤»

[22:17] <[Coke]> jnthn: how do I get a hash-like class in nqp?

[22:18] <masak> sorear: S04 seems pretty clear about Niecza being too permissive with 'succeed' outside 'when'.

[22:18] <[Coke]> (before I could say "class TclArray is Hash")

[22:21] <Radvendii> You guys wanna see meta-op overuse? https://gist.github.com/1685478

[22:22] <PerlJam> Radvendii: if that works ... nice!  ;)

[22:22] <Radvendii> yup. well... in niecza at least. in theory... i haven't actually gotten all the rest of my code to work in order to test it but i've tried similar things

[22:23] <[Coke]> "and that's why people hate perl"

[22:24] *** estrabd joined
[22:24] <PerlJam> It's one of those waterbed things 

[22:24] <PerlJam> and ... with great power comes great responsibility

[22:26] <jnthn> [Coke]: Ah...yeah, you can't inherit from PMCs with 6model. What does "hash-like" actually mean here?

[22:27] <Radvendii> [Coke]: indeed.

[22:27] <[Coke]> something like my %foo = {}; but with methods ?

[22:27] <[Coke]> er, using the right thing instead of curlies.

[22:28] <jnthn> [Coke]: It should act like a hash, and just be able to have methods also?

[22:28] <[Coke]> yes.

[22:28] <PerlJam> does Associative? 

[22:29] <[Coke]> ah. if it can't inherit from a PMC, it probably doesn't matter.

[22:29] <[Coke]> (since all I'm doing in TclArray is using hll_map

[22:29] <[Coke]> ah, TclLexPad could benefit, though.

[22:29] <jnthn> [Coke]: In that case, give it an attribute (has %!hash) and then use "is parrot_vtable_handler(...)"

[22:29] *** shinobicl__ left
[22:30] <jnthn> [Coke]: See src/core/NQPCapture.pm

[22:30] <[Coke]> (and TclList for @arrays, TclString for strings...)

[22:30] <PerlJam> [Coke]: are you updating partcl?

[22:30] *** ksi left
[22:30] <Radvendii> what does niecza mean by "This macro cannot be used as a function"

[22:30] <jnthn> [Coke]: It's delegation rather than inheritance. Though in a sense that's what Parrot did before. However, in 6model this mechanism is 1 PMC lighter per object.

[22:30] <[Coke]> PerlJam: trying to.

[22:30] <jnthn> [Coke]: And likely performs better.

[22:30] <PerlJam> [Coke]: cool

[22:31] <[Coke]> jnthn: ah, sneaky.

[22:32] <Radvendii> what's a macro... (in terms of perl6)

[22:34] *** benabik left
[22:34] <PerlJam> Radvendii: a macro is a routine that is executed immediately and it should return either an AST or some actual perl code that doesn't something useful

[22:35] <PerlJam> Radvendii: the AST or code is "injected" into original program at the point that  the macro was called.

[22:36] *** bkolera left
[22:37] <[Coke]> PerlJam: "that doesn't" ?

[22:37] <PerlJam> sorry, weird braino

[22:37] <PerlJam> ...some actual perl code that *does* something useful

[22:40] <Radvendii> okay

[22:40] <Radvendii> thanks

[22:42] <Radvendii> so why is niecza considering the last part of this line a "macro":

[22:42] <Radvendii> 		return [||] (%.h.keys.grep(/$c/).map: -> $p { self.legal($p, $l, :flag(False)) } );

[22:42] <Radvendii> ignore the first two characters...

[22:45] <Radvendii> niecza: sub a {True}; <a b c>.grep: {a};

[22:45] <p6eval> niecza v13-357-g9374d97:  ( no output )

[22:45] <Radvendii> niecza: sub a {True}; say <a b c>.grep: {a};

[22:45] <p6eval> niecza v13-357-g9374d97: OUTPUT«a b c␤»

[22:45] <jnthn> Time for some rest...night o/

[22:45] <Radvendii> o/

[22:47] <PerlJam> g'night jnthn!

[22:47] <Radvendii> niecza hasn't implimented Proxy or eager yet?

[22:49] <masak> 'night, #perl6

[22:49] *** preflex left
[22:50] *** preflex_ joined
[22:50] *** estrabd left
[22:50] *** preflex_ is now known as preflex

[22:50] *** estrabd joined
[22:52] <colomon> Radvendii: correct

[23:07] *** bacek joined
[23:11] *** bbkr2 joined
[23:11] *** bbkr1 left
[23:12] <Radvendii> colomon: then i guess rakudo is the lesser of the two evils for what i am doing...

[23:16] *** bbkr1 joined
[23:16] *** bbkr2 left
[23:27] *** spine left
[23:30] *** bluescreen10 left
[23:39] *** whiteknight joined
[23:44] <Radvendii> is there any ways to print out what you are going to print out, and what it evaluates to without typing it out twice?

[23:45] <Radvendii> oh... probably not. because it evaluates before being passed to 'say'

[23:46] *** bluescreen10 joined
[23:51] <Radvendii> nom: say 'a' ~~ /b|c|a/

[23:51] <p6eval> nom 052cc6: OUTPUT«=> <a>␤␤»

[23:51] <Radvendii> nom: say 'aasdf' ~~ /b|c|a/

[23:51] <p6eval> nom 052cc6: OUTPUT«=> <a>␤␤»

[23:54] <Radvendii> nom: say 'aasdf' ~~ /b|c|a/

[23:54] *** benabik joined
[23:54] <p6eval> nom 052cc6: OUTPUT«=> <a>␤␤»

[23:55] <Radvendii> oops. sorry guys, wrong tab

[23:59] *** tokuhirom joined
