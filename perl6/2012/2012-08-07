[00:17] *** gongyiliao joined
[00:17] *** PacoAir left
[00:17] *** adu joined
[00:18] *** nodmonkey left
[00:19] *** thelazydeveloper left
[00:19] *** spider-mario left
[00:27] *** tokuhiro_ joined
[01:01] *** benabik left
[01:07] *** popl left
[01:09] *** scott_ joined
[01:10] *** scott_ is now known as Guest39520

[01:21] *** thou left
[01:22] *** Guest39520 left
[01:25] *** benabik joined
[01:30] *** scott__ joined
[01:39] *** benabik left
[01:43] *** sivoais left
[01:44] *** benabik joined
[01:44] *** sivoais joined
[01:46] *** tokuhiro_ left
[01:51] *** jaldhar left
[01:59] *** adu left
[02:12] *** leprevost joined
[02:41] *** Patterner left
[02:43] *** Psyche^ joined
[02:43] *** Psyche^ is now known as Patterner

[02:54] *** orafu left
[02:56] *** orafu joined
[03:01] *** jeffreykegler joined
[03:05] *** jeffreykegler left
[03:10] *** Woodi left
[03:15] *** sftp left
[03:16] *** localhost joined
[03:19] *** adu joined
[03:49] *** skids left
[04:02] *** Chillance left
[04:22] *** leprevost left
[04:32] *** adu_ joined
[04:33] *** adu left
[04:33] *** adu_ is now known as adu

[04:48] <moritz> \o

[04:55] *** birdwindupbird joined
[05:11] <sorear> o/

[05:11] *** GlitchMr joined
[05:16] *** adu_ joined
[05:16] *** adu left
[05:21] *** adu_ is now known as adu

[05:33] *** erkan left
[05:41] *** SamuraiJack joined
[05:45] *** awwaiid left
[05:48] *** jdrab_ left
[05:55] *** nodmonkey joined
[06:08] <dalek> doc: 53087db | moritz++ | lib/Attribute.pod:

[06:08] <dalek> doc: document Attribute

[06:08] <dalek> doc: review: https://github.com/perl6/doc/commit/53087dbe52

[06:19] *** nodmonkey left
[06:20] *** quietfanatic left
[06:25] *** awwaiid joined
[06:49] *** jdrab joined
[07:02] *** cognominal left
[07:02] *** jdrab left
[07:02] *** cognominal_ joined
[07:03] *** GlitchMr left
[07:06] *** kaleem joined
[07:13] *** adu left
[07:13] *** brrt joined
[07:15] <dalek> rakudo/nom: fefacce | moritz++ | src/core/IO.pm:

[07:15] <dalek> rakudo/nom: [IO::Path] fix handling of local paths in .new(Str)

[07:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fefacce830

[07:16] <tadzik> fefacce

[07:18] <moritz> r: say 0xfefacce

[07:18] <p6eval> rakudo d9c09e: OUTPUT«267365582␤»

[07:19] <moritz> r: say 0xfefacceF

[07:19] <p6eval> rakudo d9c09e: OUTPUT«4277849327␤»

[07:19] <moritz> ronja added that F :-)

[07:20] <moritz> \o tadzik 

[07:20] *** cotto left
[07:21] <tadzik> o/ moritz 

[07:22] <brrt> \O ALL

[07:22] <brrt> ... oopscaps

[07:28] *** Timbus left
[07:32] *** daniel-s left
[07:32] *** colomon left
[07:32] *** daniel-s joined
[07:41] *** Timbus joined
[07:42] *** mathw_ joined
[07:43] *** moritz_ joined
[07:43] *** kaleem left
[07:43] *** mathw left
[07:43] *** moritz left
[07:43] *** Pleiades` left
[07:43] *** rhr_ left
[07:43] *** huf left
[07:43] *** cxreg left
[07:43] *** [particle] left
[07:43] *** pjcj left
[07:43] *** ranguard left
[07:43] *** PerlJam left
[07:43] *** Tene left
[07:43] *** charsbar_____ left
[07:44] *** cxreg joined
[07:46] *** fhelmberger joined
[07:51] *** hoelzro|away is now known as hoelzro

[07:53] *** Timbus left
[07:53] *** Timbus joined
[07:54] *** cognominal__ joined
[07:55] *** sudokode left
[07:57] *** cognominal_ left
[08:00] *** MayDaniel joined
[08:11] *** kaleem joined
[08:11] *** Pleiades` joined
[08:11] *** rhr_ joined
[08:11] *** huf joined
[08:11] *** [particle] joined
[08:11] *** pjcj joined
[08:11] *** ranguard joined
[08:11] *** PerlJam joined
[08:11] *** Tene joined
[08:11] *** charsbar_____ joined
[08:22] <dalek> doc: 73e7393 | moritz++ | htmlify.pl:

[08:22] <dalek> doc: [htmlify] only write type graph images when necessary

[08:22] <dalek> doc: 

[08:22] <dalek> doc: It takes quite a while, and is only necessary once in a while.

[08:22] <dalek> doc: The heuristic isn't perfect, which is why you can force the

[08:22] <dalek> doc: generation with a command line option.

[08:22] <dalek> doc: review: https://github.com/perl6/doc/commit/73e7393a20

[08:27] *** MayDaniel left
[08:28] <jnthn> morning o/

[08:28] <moritz_> \o jnthn 

[08:29] <jnthn> Short backlog...

[08:29] *** MayDaniel joined
[08:30] *** [hds] joined
[08:40] *** [hds] left
[08:53] *** MayDaniel left
[08:56] <masak> morning, #perl6

[08:57] *** nwc10 joined
[08:57] <moritz_> .. is short

[08:57] <moritz_> \o jnthn, masak 

[08:57] <nwc10> how goes the awesome?

[08:58] <masak> the proceedings are proceeding.

[08:58] <jnthn> oh my, the proceedings...

[08:59] * masak .oO( proceed; succeed; )

[08:59] <jnthn> .oO( but don't break )

[08:59] <masak> breaks are obsolete.

[09:05] <sorear> masak: proceedings?

[09:06] <masak> sorear: YAPC::Europe speakers are given the chance to send in proceedings for their talks.

[09:06] <masak> this year I decided to take that chance. the deadline is tomorrow.

[09:07] <sorear> :|.  time, a-slipping.  sleep&

[09:12] <masak> phenny: en fr "time, a-slipping"?

[09:12] <phenny> masak: "le temps , une - glissement" (en to fr, translate.google.com)

[09:13] <masak> :P

[09:13] <moritz_> it's the 21st century, and machine translation still sucks.

[09:15] <bonsaikitten> because it's a darn hard problem

[09:15] <moritz_> jnthn++ # decreased resource usage makes hacking on rakudo much more fun

[09:15] *** brrt left
[09:15] <jnthn> moritz_: Builds faster/with less hassle now?

[09:17] <moritz_> jnthn: yes, a lot (compared to before QAST, mostly)

[09:17] *** moritz_ is now known as moritz

[09:18] <nwc10> moritz: did your machine used to swap? If not, I'd guess that more of it fits in the L2 cache more of the time

[09:23] *** MayDaniel joined
[09:24] <moritz> nwc10: I've disabled swap space on my machine :-)

[09:24] <moritz> nwc10: but I used to shut down firefox before compiling the setting. Not necessary anymore :-)

[09:25] <arnsholt> Still having trouble with stubbing classes :/

[09:25] <moritz> with 3GB memory, you usually want a process to die rather than to thrash everything :-)

[09:25] <moritz> arnsholt: in p6 land?

[09:25] <arnsholt> Yeah

[09:25] <arnsholt> See https://gist.github.com/3283766

[09:26] <bonsaikitten> moritz: ulimit to the rescue

[09:26] <arnsholt> I can't do the stubbing without keeping all the class defs in a single file, which is going to be really annoying

[09:26] <bonsaikitten> (but you already knew that, right?)

[09:26] <nwc10> yes, this reminds me of an ex emplyer

[09:26] <nwc10> systems explain that some CGI scripts are coredumping at 16G (or something)

[09:26] <moritz> bonsaikitten: switching off swap space has helped to

[09:27] <nwc10> and I ask "why are they allowed to get that big before being killed?"

[09:27] <nwc10> never got a good answer, let alone a fix

[09:27] <moritz> arnsholt: try to "use B"; in A, instead of stubbing it

[09:27] <bonsaikitten> nwc10: even more fun if you use cgroups so that all cgi scripts together can't grow over $size

[09:28] <bonsaikitten> but that'd be, like, lame

[09:28] <moritz> hm

[09:28] <arnsholt> moritz: Nope. That just moves the problem from A.pm complaining about B not being defined to B complaining about A not being defined

[09:28] *** huf left
[09:30] <moritz> arnsholt, jnthn: I came up with https://gist.github.com/3283800 yesterday

[09:30] <moritz> but it complains about some access to Undef

[09:30] <moritz> while building

[09:30] <moritz> the idea is to handle mutually recursive 'use' statements at the Rakudo level

[09:31] <arnsholt> Yeah, that makes sense

[09:31] <arnsholt> It seems circular HAS-A relations aren't terribly supported yet

[09:32] <jnthn> moritz: huh, that's gonna catch *any* kind of module loading failure?

[09:35] <jnthn> Anyway, the reason the original thing didn't work is that modules should really compile completely given a "blank slate". That's the whole separate compilation thing.

[09:36] <moritz> jnthn: oh, I didn't mean to catch, just to clean and rethrow. Guess I forgot the rethrow part :(

[09:36] <jnthn> moritz: Oh...then I understand better

[09:36] <moritz> nqp: nqp::die("foo"); CATCH { say($_); nqp::rethrow($_) }

[09:36] <p6eval> nqp: OUTPUT«foo␤foo␤current instr.: '_block1000' pc 115 ((file unknown):109) (/tmp/FVh092sy3A:1)␤»

[09:37] <moritz> anyway, it dies with

[09:37] <moritz> get_attr_str() not implemented in class 'Undef'

[09:37] <moritz> current instr.: 'nqp;Perl6;World;load_module' pc 6160 (src/gen/perl6-symboltable.pir:2402) (src/Perl6/World.pm:216)

[09:37] <moritz> that line is return pir::getattribute__PPs($module, 'lex_pad');

[09:37] <jnthn> Probably because of the last statement of load_module or so

[09:37] <jnthn> Right

[09:37] <jnthn> Well, if you aren't throwing out of there, then it expects to have a return value.

[09:38] <moritz> but

[09:38] <moritz> even before my patch

[09:38] <moritz> there was a line after the load_bytecode

[09:39] <moritz> DEBUG("done loading ", %chosen<load>) if $DEBUG;

[09:39] <moritz> why does adding a CATCH after that change the return value?

[09:41] <jnthn> moritz: If the CATCH handles the exception rather than rethrowing it, then $module will be empty

[09:41] <jnthn> And then it tries to find the lexpad.

[09:43] <moritz> jnthn: but there shouldn't even be an exception in the case of compiling the setting, no?

[09:44] <jnthn> I hope not

[09:44] <jnthn> oh, that broke setting compilation?

[09:44] <moritz> yes

[09:44] <moritz> oh, I now see

[09:45] <moritz> it's the pir::load_bytecode that sets $*MAIN_CTX;

[09:45] *** jaldhar joined
[09:46] <moritz> which means that now I have no idea how to fix it :(

[09:47] <jnthn> moritz: What are you trying to fix, exactly?

[09:48] <moritz> jnthn: I want to make mutual recursive "use" statements not loop infinitely

[09:48] <jnthn> By detecting them and explaining what's going on?

[09:48] <jnthn> Or by trying to make it somehow work?

[09:48] *** spider-mario joined
[09:48] <masak> it should work.

[09:48] <moritz> by making it work somehow

[09:49] <jnthn> It can't work.

[09:49] <masak> ok, it should not hang.

[09:49] <masak> it also should not bail.

[09:49] <jnthn> Explain to me how it's meant to work.

[09:49] <aloha> positive: nothing; negative: nothing; overall: 0.

[09:49] <masak> aloha: shut. up.

[09:49] <jnthn> fuck off, aloha

[09:49] * jnthn almost reaches for his op bit to kick it

[09:49] * moritz starts to see how it doesn't work

[09:50] <arnsholt> Yeah, it probably can't. But my code in https://gist.github.com/3283766 should be possible I think

[09:50] <masak> jnthn: A.pm contains 'use B;', B.pm contains 'use A;'. when I compile/run either file, nothing happens. no error, nothing.

[09:50] *** huf joined
[09:50] <moritz> my initial idea was to do the same caching that causes multiple 'use A;' statements not to reread the file each time

[09:51] <masak> right.

[09:51] <masak> I guess Perl 5 does something like this.

[09:51] <moritz> but the problem is that the cache entry for that can only be written once A has finished loading

[09:51] <masak> well, you can say "A.pm has been entered" early.

[09:51] <moritz> but A can't finish loading, because it uses B, which uses A

[09:51] <jnthn> Let's walk through this.

[09:51] <jnthn> module A;

[09:51] <jnthn> use B;

[09:51] <moritz> doesn't have its cache entry written yet

[09:51] <jnthn> B.new();

[09:51] <jnthn> module B;

[09:51] <jnthn> use A;

[09:52] <jnthn> A.new()

[09:52] <jnthn> So, two modules

[09:52] <jnthn> You do "use A"

[09:52] <jnthn> It in turn does "use B"

[09:52] <jnthn> In parsing module B we then encounter "use A" again.

[09:52] <jnthn> The proposal seems to be "well, we just cope"

[09:52] <jnthn> So, let's suppose we say "OK, I won't load A again"

[09:53] <jnthn> We go ahead and parse module B

[09:53] <masak> right.

[09:53] <jnthn> We encounter the symbol "A"

[09:53] <jnthn> Which we compile as a list-op

[09:53] <jnthn> Because we have no idea it's a type yet because we didn't yet parse mdoule A

[09:53] <jnthn> See the problem?

[09:53] <masak> std: A.new; class A {}

[09:53] <p6eval> std f43a358: OUTPUT«[31m===[0mSORRY![31m===[0m␤Illegally post-declared type:␤       'A' used at line 1␤Check failed␤FAILED 00:00 40m␤»

[09:53] <masak> then you get this error.

[09:53] <masak> not an infinite use loop.

[09:54] <masak> I see the problem. I don't disagree at all.

[09:54] <jnthn> I'm not saying it should loop

[09:54] <jnthn> But you seem to want it to work out somehow.

[09:54] <jnthn> Which I'm saying "it can't because one-pass parsing"

[09:54] <arnsholt> jnthn: But how to do an A that has a B while B has an A, and keeping A and B is separate source files?

[09:54] <masak> it's not "it" that can't work. it's assumptions related to doing mutual 'use' statements.

[09:55] <masak> but given that that is so, maybe it would actually make sense to detect 'use' cycles and fail on them?

[09:55] <jnthn> I'm not even sure we can produce that erorr STD does because it does it at CHECK time. Which happens *per module*, and at no point during the compilation of B do we encounter the post-declaration.

[09:56] <moritz> masak: that's something I might manage to do :-)

[09:56] <masak> \o/

[09:57] <jnthn> arnsholt: I think one-pass parsing implies that you cannot; maybe consider collecting the data structures that the other modules both want access to together in a source file?

[09:57] <jnthn> moritz++

[09:58] <arnsholt> Right. That's annoying, but oh well

[09:58] <arnsholt> This is going to be a great big source file, but that's livable I guess

[09:59] * jnthn can't help but suspect that circular dependencies are more annoying in the long run.

[09:59] <moritz> note that we have lots of circular dependencies in CORE

[09:59] <moritz> and we manage them just fine

[09:59] <jnthn> Yes, which is one compilation unit :)

[09:59] <moritz> module BOOTSTRAP.pm

[10:00] <jnthn> BOOTSTRAP.pm only gets away with what it does because it's piecing things together at the MOP level

[10:01] <jnthn> You can do the same in Perl 6 code if you wish, but it means you're exporting uncomposed types.

[10:01] <jnthn> Which can hurt.

[10:02] <jnthn> (You may remember some of the nasty bugs when a type was stubbed in BOOTSTRAP.pm and then not finished up in CORE.setting)

[10:03] <masak> rn: say (1356 / 2874 * 100).fmt("%5.2f")

[10:03] <p6eval> rakudo fefacc, niecza v19-15-g051783d: OUTPUT«47.18␤»

[10:04] <tadzik> rakudo fefacc :P

[10:04] <tadzik> I can't wait for rakudo deadbeef

[10:04] <masak> (percentage of rakudobugs that I submitted)

[10:04] <jnthn> huh, I thought it may be over 50%

[10:04] <jnthn> :)

[10:04] * masak resolves to work harder

[10:05] <jnthn> :P

[10:05] <nwc10> surely resolving to resolve harder is most useful? :-)

[10:06] <masak> people are good at different things.

[10:06] <masak> my special skill seems to be creating RT tickets. ;)

[10:06] <jnthn> As the bug gets weirder, the resolving gets trickier. :)

[10:06] <masak> I sometimes dabble in resolving tickets, or writing tests... but somehow that doesn't "do it for me" in the same way.

[10:07] <masak> it's just a lot of work. :)

[10:07] <masak> whereas bug submitting sneaks in as something that my brain considers to be "zero work".

[10:08] <moritz> $ perl6 -I. test.pl 

[10:08] <moritz> ===SORRY!===

[10:08] <moritz> Recursive module loading detected involving module 'A'

[10:08] <masak> moritz: "Mutually recursive", perhaps?

[10:08] <moritz> masak: not necessarily

[10:08] <masak> or does this go even for 'use A' in A.pm?

[10:08] <masak> carry on, then :)

[10:08] <mhasch> how wbout circular

[10:09] <masak> yeah.

[10:09] * masak prefers "circular"

[10:09] <jnthn> Yeah, circular is clearer to me too

[10:09] * moritz spectests

[10:10] <masak> mhasch++

[10:10] <tadzik> circular logic is the best kind of logic

[10:10] <moritz> :-)

[10:11] *** scott__ left
[10:12] <masak> tadzik: BECAUSE IT'S CIRCULAR! \o/

[10:17] <masak> r: say ((2874 - 621) / 2874 * 100).fmt("%5.2f") # percentage of closed perl6 tickets in RT

[10:17] <p6eval> rakudo fefacc: OUTPUT«78.39␤»

[10:18] <jnthn> ooh

[10:18] <masak> r: say ((1356 - 342) / 1356 * 100).fmt("%5.2f") # percentage of closed perl6 tickets submitted by me

[10:18] <p6eval> rakudo fefacc: OUTPUT«74.78␤»

[10:19] <masak> hrm. :)

[10:19] *** daxim joined
[10:19] <moritz> masak: so your average ticket is slightly nastier than usual :-)

[10:19] * masak wonders why

[10:21] <masak> man, I really need a mirror of RT that I can do time-based statistics on.

[10:21] * masak puts it on the long TODO list

[10:21] *** crab2313 joined
[10:22] <masak> I guess the above number is quite sensitive to how "caught up" we are on the queue. people have been diligent in closing tickets recently, so that probably plays in.

[10:25] <jnthn> aye

[10:25] <dalek> roast: 7c3f87a | moritz++ | S (2 files):

[10:25] <dalek> roast: RT #114394, type captures and containers

[10:25] <dalek> roast: review: https://github.com/perl6/roast/commit/7c3f87a1c8

[10:25] * jnthn wonders how long the testneeded queue is

[10:25] <masak> huh!

[10:25] <jnthn> heh, moritz++ just made it one shorter :)

[10:25] <masak> http://irclog.perlgeek.de/perl6/2012-04-22#i_5477831

[10:26] <masak> when I re-read this it seems the numbers are roughly similar then and now, and I just made the *opposite* conclusion then that I should've. :(

[10:26] <moritz> fwiw the testneeded numbers are notoriously unreliable

[10:26] <masak> *sob*, my tickets are statistically significantly *worse* than general tickets :/

[10:26] <jnthn> That's curious in so far as they tend to be well formed.

[10:27] <moritz> worse?

[10:27] <jnthn> moritz: Less likely to be fixed.

[10:27] <masak> I guess my tickets are often difficult to fix.

[10:27] <jnthn> That doesn't mean the ticket's worse in so far as the ticket itself is to blame though.

[10:27] <masak> even if they are well-formed.

[10:27] <jnthn> It may mean that it's worse for whoever has to fix it :P

[10:27] <jnthn> (As in, harder problem.)

[10:27] <masak> that's a slight comfort :)

[10:28] <masak> r: say 100 - 23.56; say 100 - 28.71

[10:28] <p6eval> rakudo fefacc: OUTPUT«76.44␤71.29␤»

[10:28] <masak> good news is that since April, the proportion of fixed tickets has gone up by two or three percentage points.

[10:30] <dalek> roast: 2eb9d53 | moritz++ | S14-roles/basic.t:

[10:30] <dalek> roast: RT #114380, type attributes in roles

[10:30] <dalek> roast: review: https://github.com/perl6/roast/commit/2eb9d534c6

[10:30] *** brrt joined
[10:30] <moritz> another masakneededbug down :-)

[10:31] <masak> \o/

[10:31] *** nodmonkey joined
[10:33] <dalek> rakudo/nom: 78c5c17 | moritz++ | / (2 files):

[10:33] <dalek> rakudo/nom: Detect and carp at circular module loading

[10:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/78c5c179c0

[10:34] <moritz> r: say (1, 2).classify: -> $x { 1|2 }

[10:34] <p6eval> rakudo fefacc: OUTPUT«Cannot assign to a readonly variable or a value␤  in sub infix:<=> at src/gen/CORE.setting:11393␤  in method push at src/gen/CORE.setting:1193␤  in sub AUTOTHREAD_METHOD at src/gen/CORE.setting:1863␤  in <anon> at src/gen/Metamodel.pm:2296␤  in method classify at s…

[10:35] <moritz> r: my %h = a => 1; %h{1|2} = 3; say %h.perl

[10:35] <p6eval> rakudo fefacc: OUTPUT«No such method 'STORE' for invocant of type 'Any'␤  in sub AUTOTHREAD_METHOD at src/gen/CORE.setting:1863␤  in <anon> at src/gen/Metamodel.pm:2296␤  in block  at /tmp/EBzmMuG96g:1␤␤»

[10:36] *** seldon joined
[10:41] <moritz> nr: say $*IN.eof

[10:41] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method eof in type TextReader␤  at /tmp/aT95qt9SrY line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /…

[10:41] <p6eval> ..rakudo fefacc: OUTPUT«False␤»

[10:43] *** wtw joined
[10:44] * moritz resolves the longest-standing open masakbug

[10:45] <moritz> r: try eval q[class B0rk { has $.a } ]; say $!.perl

[10:45] <p6eval> rakudo fefacc: OUTPUT«Any␤»

[10:45] <moritz> r: [class B0rk { has $.a } 

[10:45] <p6eval> rakudo fefacc: OUTPUT«===SORRY!===␤Redeclaration of symbol B0rk␤at /tmp/pnZJfuYO6m:1␤»

[10:45] <moritz> r: class B0rk { has $.a } 

[10:45] <p6eval> rakudo fefacc:  ( no output )

[10:45] <moritz> r: class B0rk { say $.a } 

[10:45] <p6eval> rakudo fefacc: OUTPUT«===SORRY!===␤Variable $.a used where no 'self' is available␤at /tmp/XvOn8_HDZ5:1␤»

[10:46] <moritz> r: try eval q[class B0rk { say $.a } ]; say $!.perl

[10:46] <p6eval> rakudo fefacc: OUTPUT«X::Syntax::NoSelf.new(variable => "\$.a", filename => "eval_0", line => 1, column => Any, modules => Array.new())␤»

[10:47] <moritz> nr: class A { my $.x = 7; say $.x }

[10:47] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $.x used where no 'self' is available at /tmp/5Ev8FoOooo line 1:␤------> [32mclass A { my $.x = 7; say [33m⏏[31m$.x }[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 14…

[10:47] <p6eval> ..rakudo fefacc: OUTPUT«===SORRY!===␤Variable $.x used where no 'self' is available␤at /tmp/t26m2_VAsf:1␤»

[10:47] <dalek> roast: b3c2006 | moritz++ | S32-exceptions/misc.t:

[10:47] <dalek> roast: RT #59118

[10:47] <dalek> roast: review: https://github.com/perl6/roast/commit/b3c2006762

[10:48] * moritz closes the longest standing open ticket in the perl6 queue

[10:48] <tadzik> \o/

[10:56] <dalek> roast: 59ded64 | moritz++ | S32-list/reduce.t:

[10:56] <dalek> roast: RT #66352, List.reduce and multi subs

[10:56] <dalek> roast: review: https://github.com/perl6/roast/commit/59ded64b95

[10:57] <moritz> this one was a bug submitted by ruoso++

[10:57] <nwc10> masak resolves to work harder, moritz works to resolve harder

[11:01] <moritz> r: say ([X] <a b c> xx 2).perl

[11:01] <p6eval> rakudo fefacc: OUTPUT«((ListIter.new(),),).list␤»

[11:01] <moritz> r: say ([X] <a b c> xx 2).tree.perl

[11:01] <p6eval> rakudo fefacc: OUTPUT«(["a", "b", "c", "a", "b", "c"],).list␤»

[11:04] *** crab2313 left
[11:07] *** JimmyZ_ joined
[11:10] *** fridim_ joined
[11:14] <masak> nwc10: and jnthn just works harder :P

[11:15] <nwc10> although I suspect that he's working on paid work today (yesterday, and tomorrow)

[11:16] <jnthn> Taking care of some $dayjob bits, yeah.

[11:16] <jnthn> The more I take care of in the summer, the less snowed-under I am in the autumn. :)

[11:17] <moritz> does it really work like that?

[11:18] <moritz> usually I'm always snowed-under

[11:18] <moritz> there's just an infinite amount of work to be done

[11:18] <moritz> in good approximation

[11:19] <moritz> r: 0 but last; say 'alive'

[11:19] <p6eval> rakudo 78c5c1: OUTPUT«===SORRY!===␤Method 'has_compile_time_value' not found for invocant of class 'Undef'␤»

[11:19] <moritz> that one is curious

[11:20] <jnthn> Compiler fail

[11:22] <moritz> r: sub f() { }; 1 but last()

[11:22] <p6eval> rakudo 78c5c1: OUTPUT«===SORRY!===␤Method 'has_compile_time_value' not found for invocant of class 'Undef'␤»

[11:22] <moritz> r: sub f() { }; 1 but f()

[11:22] <p6eval> rakudo 78c5c1: OUTPUT«===SORRY!===␤Method 'has_compile_time_value' not found for invocant of class 'Undef'␤»

[11:23] * moritz might know how to fix it

[11:23] <jnthn> OK...guess --ll-exception is informative

[11:23] <jnthn> lemme know if not...I'll have some Perl 6 tuits this afty.

[11:24] <moritz> it's $rhs[0] that's Undef

[11:24] <moritz> for a zero-arg call

[11:24] <moritz> so, just don't try to be all fancy for zero-arg calls, and everything should be fine

[11:25] <moritz> yes, --ll-exception is informative

[11:27] *** mucker joined
[11:30] *** UncleFester6 left
[11:45] *** fridim_ left
[11:49] <dalek> rakudo/nom: 34e8d4d | moritz++ | src/Perl6/Actions.pm:

[11:49] <dalek> rakudo/nom: guard infix:<but> against zero-arg calls on the RHS

[11:49] <dalek> rakudo/nom: 

[11:49] <dalek> rakudo/nom: closes RT #73990

[11:49] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/34e8d4d83f

[11:50] *** MayDaniel left
[11:55] <dalek> roast: a0df9db | moritz++ | S14-roles/mixin.t:

[11:55] <dalek> roast: RT #73990, "1 but last"

[11:55] <dalek> roast: review: https://github.com/perl6/roast/commit/a0df9db4b8

[12:04] *** gongyiliao left
[12:06] <lumi_> I'm having trouble building nqp

[12:08] *** mtk joined
[12:08] *** tokuhiro_ joined
[12:10] <lumi_> parrot segfaults while generating stage1/nqpmo.pbc (if I'm reading this right)

[12:27] *** colomon joined
[12:31] <arnsholt> lumi_: That sounds bad. Could you give some more details?

[12:32] <arnsholt> jnthn: Have you looked at https://github.com/jnthn/zavolaj/pull/8 ?

[12:32] <lumi_> arnsholt: I'm investigating, it seems I had earlier trouble building parrot, that was masked because we moved back from 4.5 to 4.4

[12:32] <lumi_> arnsholt: So my new complaint is that I can't build parrot :P

[12:32] <arnsholt> Right. Try wiping out nqp/install (assuming you're doing --gen-parrot)

[12:33] <lumi_> arnsholt: Yep, except I'm actually building rakudo. So wipe out rakudo/install?

[12:34] <arnsholt> Yeah

[12:35] *** sivoais left
[12:35] <lumi_> OK

[12:36] <daxim> pugs, say "echo echo hilight daxim"

[12:37] <daxim> pugs: say "echo echo hilight daxim"

[12:37] <p6eval> pugs: OUTPUT«echo echo hilight daxim␤»

[12:37] *** sivoais joined
[12:39] <[Coke]> aloha: msg bacek to please disable the "explain" command in #perl6, as well as its reaction to negative karma. Thanks.

[12:41] <[Coke]> or did someone already boot it?

[12:42] * jnthn resisted the temptation to :)

[12:42] <jnthn> arnsholt: Yeah. moritz++'s comment is valid.

[12:42] <jnthn> arnsholt: Also I wasn't entirely sure on the name.

[12:43] <arnsholt> Yeah, me too

[12:43] <arnsholt> I was thinking perhaps is native($libname, $realname)

[12:43] <jnthn> is_symbol($realname) also works

[12:43] <jnthn> er

[12:43] <jnthn> is symbol

[12:44] <jnthn> It kinda refers to dlsym

[12:44] <arnsholt> Right. Was about to say that

[12:44] <arnsholt> Yeah, I like symbol as well

[12:44] <JimmyZ_> is native($realname, :$symbol? )

[12:44] <jnthn> I don't think doing that with is native is a good idea

[12:44] <jnthn> Because what if you are doing the "is native" with no arg trick for current assebly?

[12:45] <jnthn> *assembly

[12:45] * JimmyZ_ likes is symbol too

[12:46] <arnsholt> is native(Mu, $symbol) would work I guess, but looks a bit clunky

[12:46] <jnthn> Yeah, I don't like that.

[12:47] <arnsholt> Cool. is symbol it is

[12:48] *** atrodo joined
[12:50] <lumi_> arnsholt: Everything works now, arnsholt++ :)

[12:51] <arnsholt> Excellent!

[12:51] <dalek> zavolaj: eb3e3d8 | duff++ | / (2 files):

[12:51] <dalek> zavolaj: Add a way to name native routines

[12:51] <dalek> zavolaj: 

[12:51] <dalek> zavolaj: Sometimes the names used in a particular native library may not mesh

[12:51] <dalek> zavolaj: well with their usage in Perl. Rather than force our Perl subroutines to

[12:51] <dalek> zavolaj: have the same name as their native counterparts, we provide a way to

[12:51] <dalek> zavolaj: specify the name of the routine in the native library that our arbitrarily-

[12:51] <dalek> zavolaj: named Perl subroutine maps to.

[12:51] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/eb3e3d88ef

[12:51] <dalek> zavolaj: 4af0a9a | (Arne Skjærholt)++ | / (2 files):

[12:51] <dalek> zavolaj: Merge pull request #8 from perlpilot/master

[12:51] <dalek> zavolaj: 

[12:51] <dalek> zavolaj: Provide a way to use a different name in your Perl than the native library

[12:51] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/4af0a9aaaf

[13:01] <dalek> zavolaj: bc26b5e | (Arne Skjærholt)++ | / (4 files):

[13:01] <dalek> zavolaj: Clean up pull request. As discussed on #perl6.

[13:01] <dalek> zavolaj: 

[13:01] <dalek> zavolaj: Renames is named trait to is symbol, use defined-or instead of boolean-or when

[13:01] <dalek> zavolaj: checking return value of native_symbol (moritz++). Add basic test to make sure

[13:01] <dalek> zavolaj: it works.

[13:01] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/bc26b5e378

[13:02] <colomon> oooo, sounds nice

[13:05] <arnsholt> There. Now the only open Zavolaj issues are actual issues

[13:05] <jnthn> \o/

[13:05] <jnthn> arnsholt++

[13:06] * arnsholt tries to figure out how to detect OS compile-time

[13:06] <hoelzro> that change makes me want to learn Perl 6 even more in depth =)

[13:10] *** xinming left
[13:10] <moritz> arnsholt: same as run time, but in a BEGIN block

[13:11] <moritz> r: say $*OS

[13:11] <arnsholt> moritz: In C =)

[13:11] <p6eval> rakudo 34e8d4: OUTPUT«linux␤»

[13:11] <arnsholt> Sorry, was too far into my own brain =)

[13:11] <moritz> :(

[13:11] <jnthn> arnsholt: What do you really need?

[13:11] <jnthn> Feature detection tends to beat OS detection...

[13:11] *** xinming joined
[13:11] <arnsholt> I'd like to add a fallback for OS X when library loading fails

[13:12] <jnthn> Is there something you can rely on being #define'd when on OS X?

[13:12] <arnsholt> Not sure :/

[13:12] *** fgomez left
[13:12] <arnsholt> (Or, more specifically I think I want to test for Mach, since that's where the .bundle/.dylib distinction comes from)

[13:12] <moritz> http://stackoverflow.com/questions/6802903/c-ifdef-mac-os-x-question

[13:13] <hoelzro> arnsholt: __APPLE_CC__ will be defined in C on OS X

[13:13] <hoelzro> http://sourceforge.net/apps/mediawiki/predef/index.php?title=Operating_Systems

[13:13] <arnsholt> Nifty! Thanks

[13:14] <arnsholt> Although, looking at NativeCall.pm6 again, the appending of the extension is done in Perl

[13:17] * arnsholt ponders

[13:19] *** Chillance joined
[13:20] <jnthn> arnsholt: One option may be that we pass the C code an array of symbol names to try rather than just one name.

[13:20] <jnthn> (nqp::list(...) of them, that is)

[13:20] <jnthn> Then we can construct the possibles in order in Perl 6 land.

[13:21] <arnsholt> Yeah, that's probably the most extensible

[13:21] *** skids joined
[13:21] <arnsholt> I'm considering just using PARROT_LOAD_EXT from parrot/config.h as well

[13:23] *** tokuhiro_ left
[13:23] <dalek> roast: 4adc21e | moritz++ | S12-attributes/instance.t:

[13:23] <dalek> roast: RT #74636, flattening of array attributes

[13:23] <dalek> roast: review: https://github.com/perl6/roast/commit/4adc21edf0

[13:24] <arnsholt> How attached are we to ``$libname ~~ /\.\w+$/ ?? $libname !! "$libname$*VM<config><load_ext>";''?

[13:25] <jnthn> I'm rather open to the idea that there's a better way :)

[13:26] <arnsholt> What I'm thinking of is dropping that bit, which means that we'll lose the ability to load libs with weird extensions

[13:26] <arnsholt> Not sure it's very important though

[13:26] *** bluescreen10 joined
[13:27] <arnsholt> And then first try loading "$lib . PARROT_LOAD_EXT", and if that fails try "$lib . PARROT_SHARE_EXT" before giving up

[13:28] <arnsholt> That way we'll work on OS X, without any extra OS detection shenanigans (but we'll try loading the same library twice on linux since both _LOAD_EXT and _SHARE_EXT is .so there)

[13:28] <jnthn> We'll only try twice if it fails

[13:28] <jnthn> Can always do a quick compare of them also

[13:29] <arnsholt> Indeed

[13:29] <arnsholt> I guess the simplest would actually be strcmp()ing the two defines

[13:30] <jnthn> yeah

[13:30] <moritz> r: say $*VM<config><load_ext>

[13:30] <p6eval> rakudo 34e8d4: OUTPUT«.so␤»

[13:30] <moritz> r: say $*VM<config><share_ext>

[13:30] <p6eval> rakudo 34e8d4: OUTPUT«.so␤»

[13:34] <pmichaud> good morning, #perl6

[13:34] <jnthn> hi, pmichaud o/

[13:34] <JimmyZ_> good morning, pm

[13:34] <colomon> o\

[13:34] <moritz> good am, pm

[13:34] <moritz> \o JimmyZ_, colomon 

[13:34] <moritz> std: 1.>>.uc

[13:34] <p6eval> std f43a358: OUTPUT«ok 00:00 40m␤»

[13:34] <moritz> r: 1.>>.uc

[13:34] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Confused␤at /tmp/bta8JrKH1K:1␤»

[13:35] <JimmyZ_> \o/ moritz 

[13:36] *** jerome joined
[13:37] <masak> pmichaud! \o/

[13:39] *** jaldhar left
[13:41] *** cognominal joined
[13:45] *** cognominal__ left
[13:45] *** cognominal left
[13:45] *** cognominal joined
[13:46] <dalek> roast: db2d40c | moritz++ | S32-exceptions/misc.t:

[13:46] <dalek> roast: RT #75776, correct syntax error for missing block

[13:46] <dalek> roast: review: https://github.com/perl6/roast/commit/db2d40c6fc

[13:49] *** thou joined
[13:50] <moritz> r: my @a; say @a.^methods.elems

[13:50] <p6eval> rakudo 34e8d4: OUTPUT«68␤»

[13:51] <moritz> r: my @a; say @a.^methods.sort.elems

[13:51] <p6eval> rakudo 34e8d4: OUTPUT«68␤»

[13:51] <masak> phew :)

[13:51] <jnthn> Those...once gave different answers?

[13:51] <moritz> not selvfølgelig

[13:51] <moritz> https://rt.perl.org/rt3/Ticket/Display.html?id=76918

[13:53] <jnthn> ah

[13:53] <moritz> I guess that were parrot multis

[13:53] <moritz> somehow

[13:53] <jnthn> perhaps that yes

[13:53] <masak> phenny: no de "selvfølgelig"?

[13:53] <phenny> masak: "natürlich" (no to de, translate.google.com)

[13:54] <masak> well, yeah, but no.

[13:54] <moritz> phenny: de nb "selbstverständlich"?

[13:54] <phenny> moritz: "selvfølgelig" (de to nb, translate.google.com)

[13:54] * masak loves how that ticket was submitted by "shirtless" :P

[13:55] *** sftp joined
[13:59] <moritz> r: my Array $a; $a[0] = 3; say $a.perl

[13:59] <p6eval> rakudo 34e8d4: OUTPUT«[3]␤»

[13:59] *** daxim left
[14:00] *** fhelmberger left
[14:02] *** Tedd1^ left
[14:02] *** Tedd1 joined
[14:06] <dalek> roast: 5436ea7 | moritz++ | S02-types/autovivification.t:

[14:06] <dalek> roast: RT #77048, autovivification of Array-typed scalars

[14:06] <dalek> roast: review: https://github.com/perl6/roast/commit/5436ea74fd

[14:08] <moritz> std: say :a<>

[14:08] <p6eval> std f43a358: OUTPUT«Potential difficulties:␤  Pair with <> really means a Nil value, not null string; use :a('') to represent the null string,␤  or :a() to represent Nil more accurately at /tmp/z3fifA_HRD line 1:␤------> [32msay :a<>[33m⏏[31m<EOL>[0m␤ok 00:00 41m␤»

[14:08] *** MayDaniel joined
[14:08] <moritz> r: say :a<>

[14:08] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Unsupported use of <>;  in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list␤at /tmp/79p_AxbTUU:1␤»

[14:10] <masak> std: :a<>

[14:10] <p6eval> std f43a358: OUTPUT«Potential difficulties:␤  Pair with <> really means a Nil value, not null string; use :a('') to represent the null string,␤  or :a() to represent Nil more accurately at /tmp/RutkWhB4Ud line 1:␤------> [32m:a<>[33m⏏[31m<EOL>[0m␤ok 00:00 40m␤»

[14:10] <pmichaud> r: say (:a<hello>)

[14:10] <p6eval> rakudo 34e8d4: OUTPUT«"a" => "hello"␤»

[14:10] <pmichaud> r: say (:a<>)

[14:10] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Unsupported use of <>;  in Perl 6 please use lines() to read input, ('') to represent a null string or () to represent an empty list␤at /tmp/3l7AwI4fL2:1␤»

[14:11] <pmichaud> I'm afk for a while

[14:14] *** jaldhar joined
[14:14] *** leprevost joined
[14:22] *** wtw left
[14:23] *** JimmyZ_ left
[14:26] *** kaare_ joined
[14:39] <moritz> phenny: tell [Coke] can you please check on your 32bit system if the tests in S03-operators/overflow.t that are skipped as "fails on 32bit" still fail?

[14:39] <phenny> moritz: I'll pass that on when [Coke] is around.

[14:49] <moritz> r: 1 = 2

[14:49] <p6eval> rakudo 34e8d4: OUTPUT«Cannot assign to a non-container␤  in block  at /tmp/UBt68fMHur:1␤␤»

[14:51] <dalek> roast: 16bb6f8 | moritz++ | S32-exceptions/misc.t:

[14:51] <dalek> roast: unfudge rakudo tests for RT #113534

[14:51] <dalek> roast: review: https://github.com/perl6/roast/commit/16bb6f80dd

[14:52] *** SamuraiJack_ joined
[14:53] *** SamuraiJack left
[15:01] *** adu joined
[15:03] *** GlitchMr joined
[15:07] *** jaldhar left
[15:08] <moritz> r: class A { }; try A.foo; say $!.perl

[15:08] <p6eval> rakudo 34e8d4: OUTPUT«X::Method::NotFound.new(method => "foo", typename => "A", private => Bool::False)␤»

[15:08] <masak> that is so cool.

[15:09] * moritz closes a ticket with it :-)

[15:09] <moritz> perl6: sub foo { my $s; for 1..3 { $s += $_ } } ; say foo()

[15:09] <p6eval> rakudo 34e8d4: OUTPUT«6 6 6␤»

[15:09] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Use of uninitialized value in numeric context␤  at /home/p6eval/niecza/lib/CORE.setting line 1272 (warn @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 296 (Any.Numeric @ 8) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/343rO3NQJL line 1 (foo @ …

[15:10] <moritz> perl6: sub foo { my $s = 0; for 1..3 { $s += $_ } } ; say foo()

[15:10] <p6eval> niecza v19-15-g051783d: OUTPUT«Nil␤»

[15:10] <p6eval> ..rakudo 34e8d4: OUTPUT«6 6 6␤»

[15:11] <moritz> masak: yes, I'm a bit proud on the X::Method::NotFound one; it took some evil hackery to get there

[15:11] <masak> moritz++

[15:12] <masak> the above looks... right.

[15:12] <masak> 6 6 6

[15:12] <masak> unless things from a for loop should be decontainerized.

[15:12] <moritz> https://rt.perl.org/rt3/Ticket/Display.html?id=77334

[15:12] <jnthn> Blocks don't normally decont.

[15:12] <masak> right.

[15:12] <jnthn> It's routines

[15:13] <masak> hm, pmichaud says it should in that ticket.

[15:13] <masak> not the 'for', though, so much as the 'for' body block.

[15:15] *** kaleem left
[15:16] <jnthn> Hm, that'd imply that we make blocks decont their results also.

[15:16] <jnthn> Which we can I guess...it just means if you don't want that you have to write "also is rw;" or something

[15:17] <moritz> note that pmichaud's last comment was from 2010

[15:17] <moritz> our understanding of containers might have changed since then

[15:17] <jnthn> ah, true :)

[15:20] <moritz> nr: say .Str for ('ab' ~~ /<alpha>+/)<alpha>

[15:20] <p6eval> niecza v19-15-g051783d: OUTPUT«a b␤»

[15:20] <p6eval> ..rakudo 34e8d4: OUTPUT«a␤b␤»

[15:21] <moritz> https://rt.perl.org/rt3/Ticket/Display.html?id=77340 argues for rakudo's current behavior

[15:27] <moritz> rakudo: use Test; eval_lives_ok '1<&1'

[15:27] <p6eval> rakudo 34e8d4: OUTPUT«use of uninitialized variable $v of type Any in numeric context  in block  at eval_0:1␤␤ok 1 - ␤»

[15:34] <jnthn> r: $*LOL-I-DON'T-EXIST

[15:34] <p6eval> rakudo 34e8d4:  ( no output )

[15:34] <jnthn> r: say $*LOL-I-DON'T-EXIST

[15:34] <p6eval> rakudo 34e8d4: OUTPUT«Dynamic variable $*LOL-I-DON'T-EXIST not found␤  in method gist at src/gen/CORE.setting:9659␤  in sub say at src/gen/CORE.setting:7046␤  in block  at /tmp/svLnxXABOi:1␤␤»

[15:34] <jnthn> r: say $*LOL-I-DON'T-EXIST.WHAT

[15:34] <p6eval> rakudo 34e8d4: OUTPUT«Failure()␤»

[15:36] *** sudokode joined
[15:45] <[Coke]> moritz: you could trigger a run yourself by just unskipping them and seeing if I complain. ;)

[15:45] <phenny> [Coke]: 14:39Z <moritz> tell [Coke] can you please check on your 32bit system if the tests in S03-operators/overflow.t that are skipped as "fails on 32bit" still fail?

[15:45] <[Coke]> (i'll run 'em shortly.)

[15:47] *** brrt left
[15:47] <[Coke]> moritz: how recent a rakudo do I need? is yesterday's ok?

[15:49] *** thelazydeveloper joined
[15:49] <[Coke]> moritz: yup, tests pass.

[15:49] <[Coke]> want me to commit the unfudge?

[15:51] <dalek> roast: f66dad4 | coke++ | S03-operators/overflow.t:

[15:51] <dalek> roast: rakudo unfudge

[15:51] <dalek> roast: moritz++

[15:51] <dalek> roast: review: https://github.com/perl6/roast/commit/f66dad489e

[15:51] <[Coke]> curses.

[15:52] <dalek> nqp/toqast: 6849356 | jnthn++ | / (2 files):

[15:52] <dalek> nqp/toqast: Add QAST::VarWithFallback, a way to give a handful of variables a fallback way to do a lookup should the initial lookup return null. For use of things like contextuals, or when the fallback is to throw an error.

[15:52] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/6849356710

[15:52] <dalek> nqp/toqast: 43dfb24 | jnthn++ | src/QAST/Compiler.nqp:

[15:52] <dalek> nqp/toqast: Compilation of QAST::VarWithFallback.

[15:52] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/43dfb24585

[15:52] <dalek> nqp/toqast: e714e6e | jnthn++ | src/QAST/Compiler.nqp:

[15:52] <dalek> nqp/toqast: Corrections to contextual scope compilation.

[15:52] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/e714e6e8d6

[15:52] <dalek> nqp/toqast: 64f922a | jnthn++ | src/NQPQ/Actions.pm:

[15:52] <dalek> nqp/toqast: Get a basic cut of contextuals working again. Fixes the contextuals tests entirely plus another test file that depended on them.

[15:52] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/64f922acfd

[15:54] <masak> ooh, QAST::VarWithFallback

[15:57] *** skids left
[15:57] *** hoelzro is now known as hoelzro|away

[15:59] *** nodmonkey left
[16:09] * TimToady_ wonders whether there's any reason we can't support closures on the right side of X, so that we could have 100..999 X { $_ .. 999 }

[16:09] <TimToady_> kind of a pity that 100..999 X *..999 doesn't work out

[16:09] <jnthn> The compiler already has to thunk it.

[16:09] <jnthn> oh, wait

[16:09] <jnthn> that's the LHS

[16:09] <moritz> no, LHS of xx

[16:09] <jnthn> oh

[16:10] <jnthn> ...that also

[16:10] * jnthn shuts up and continues compiler hacking :)

[16:10] *** skids joined
[16:12] * TimToady_ still wonders whether *..999 could turn into something like -> $_ = -Inf { $_ .. 999 }, that just defaults to the infinity in question

[16:12] <PerlJam> TimToady_: I've occasionally wanted a version of X that passed its results through a closure en passant, but then I just use map   ;-)

[16:13] *** nodmonkey joined
[16:13] <TimToady_> nr: say (* ... 999).WHAT

[16:13] <p6eval> rakudo 34e8d4, niecza v19-15-g051783d: OUTPUT«List()␤»

[16:13] <TimToady_> hmm

[16:14] <TimToady_> maybe we should force that to be a WhateverCode

[16:14] <moritz> that's going to be a "bit" confusing

[16:15] <moritz> considering that it explicitly doesn't autocurry on the RHS

[16:17] <nwc10> jnthn++ # continuing compiler hacking

[16:17] <nwc10> :-)

[16:21] *** birdwindupbird left
[16:23] *** brrt joined
[16:29] <dalek> nqp/toqast: 207256a | jnthn++ | src/QAST/ (2 files):

[16:29] <dalek> nqp/toqast: Add a (per-HLL configurable) to do positional and associative lookup/binding using a QAST::Var. This may mean that even Rakudo can use this approach for its array/hash accesses, by configuring them to call the appropriate methods. Doing things that way come in highly useful with analysis/optimization of native array accesses.

[16:29] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/207256afbe

[16:29] <dalek> nqp/toqast: 90adf5a | jnthn++ | src/NQPQ/Actions.pm:

[16:29] <dalek> nqp/toqast: Fix array and hash indexing; wins back some more tests.

[16:29] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/90adf5a1b1

[16:29] <jnthn> er, way to do...

[16:30] <brrt> leto: thanks for your mail

[16:34] *** simcop2387 left
[16:39] *** simcop2387 joined
[16:39] *** simcop2387 left
[16:41] *** simcop2387 joined
[16:41] *** mucker left
[16:45] *** benabik left
[16:46] <dalek> nqp/toqast: 0143bc0 | jnthn++ | src/NQPQ/ (2 files):

[16:46] <dalek> nqp/toqast: Assorted fixes to package scoped things. Fixes our subs amongst other things.

[16:46] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/0143bc0ad9

[16:47] *** benabik joined
[16:47] <jnthn> 35 out of 60 test files pass with nqpq (NQP with QAST) now

[16:47] <jnthn> (that's tests from t/nqp)

[16:49] *** spider-mario left
[16:51] *** spaceships left
[16:52] *** spaceships joined
[16:55] <dalek> nqp/toqast: 50bb7ae | jnthn++ | src/NQPQ/Actions.pm:

[16:55] <dalek> nqp/toqast: Eliminate a few more viviself usages and remove vivitype. These updates fix a few more package scoping issues, winning a couple more test files back.

[16:55] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/50bb7aeb8f

[16:58] *** brrt left
[16:59] *** colomon left
[17:02] *** SamuraiJack_ left
[17:08] <[Coke]> +S14-roles/mixin.niecza aborted 32 test(s)

[17:09] <dalek> perl6-roast-data: c7782d5 | coke++ | / (4 files):

[17:09] <dalek> perl6-roast-data: today

[17:09] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c7782d5fa6

[17:09] <sorear> good * #perl6

[17:11] <diakopter> sorear: howdy

[17:11] <[Coke]> ingy, au, masak: pugs is over 40.89% of max spec tests and dropping. We'll drop below 40 again if moritz keeps adding tests. ;)

[17:12] <[Coke]> sorear, colomon: niecza has dropped below 90% of rakudo (89.58%).

[17:13] <[Coke]> n: say 22997*.9-20601

[17:13] <p6eval> niecza v19-15-g051783d: OUTPUT«96.3␤»

[17:13] *** SamuraiJack joined
[17:13] <[Coke]> p: say abs(22997*.4-9404)

[17:13] <p6eval> pugs: OUTPUT«205.2␤»

[17:14] <[Coke]> p: 9404/.4 -22997 # whoops, wrong way

[17:14] <p6eval> pugs:  ( no output )

[17:14] <[Coke]> p: say 9404/.4 -22997 # whoops, wrong way

[17:14] <p6eval> pugs: OUTPUT«513␤»

[17:14] <[Coke]> ok, still have a little time there. ;)

[17:14] *** _fall0ut_ is now known as driador

[17:15] *** driador left
[17:15] *** driador joined
[17:23] <dalek> nqp/toqast: 3f525aa | jnthn++ | t/nqp/38-quotes.t:

[17:23] <dalek> nqp/toqast: Update a pir:: op in a test to the appropriate nqp:: one.

[17:23] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/3f525aa59c

[17:23] <dalek> nqp/toqast: eeeaea0 | jnthn++ | src/NQPQ/Actions.pm:

[17:23] <dalek> nqp/toqast: Fix array constructor.

[17:23] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/eeeaea0a7a

[17:23] <dalek> nqp/toqast: 2524810 | jnthn++ | t/nqp/40-lists.t:

[17:23] <dalek> nqp/toqast: Update a test to not use pir:: ops.

[17:23] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/252481084b

[17:23] <dalek> nqp/toqast: 4660299 | jnthn++ | src/ (2 files):

[17:23] <dalek> nqp/toqast: Add an nqp::ishash.

[17:23] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/4660299231

[17:24] *** SamuraiJack left
[17:25] *** skids left
[17:26] *** sirrobert joined
[17:26] *** colomon joined
[17:26] <sirrobert> where does panda install things by default?

[17:31] <masak> ~/.perl6/lib, methinks.

[17:31] <sirrobert> yep, that's it; thanks =)

[17:32] <masak> yep: https://github.com/tadzik/panda/blob/master/bin/panda#L72

[17:37] *** fridim_ joined
[17:38] *** PZt left
[17:39] <PerlJam> arnsholt++  ("is symbol" is much better)

[17:41] *** skids joined
[17:41] *** ashleyde1 is now known as ashleydv

[17:41] *** ashleydv is now known as ashleydev

[17:51] <ingy> [Coke]: tests++ :)

[17:51] <masak> tests. they rock.

[17:52] <tadzik> arduino. It rocks

[17:53] <tadzik> http://www.youtube.com/watch?v=PiU0KI9sxas \o/

[17:53] <tadzik> now I need a Perl 6 compiler for that :)

[18:00] <mhasch> nqp might be a tad more realistic... :-)

[18:02] <tadzik> probably

[18:02] <tadzik> I need to find mberends' code, we started Perlduino iirc

[18:05] *** fridim_ left
[18:06] *** kcwu_ left
[18:08] *** PZt joined
[18:11] *** kcwu joined
[18:14] *** crab2313 joined
[18:21] *** SamuraiJack joined
[18:24] <masak> today's mini-challenge: test whether an integer is a perfect square. try to be fast and/or to avoid floating-point math.

[18:25] <diakopter> masak: :S

[18:25] *** sporous left
[18:25] *** SamuraiJack left
[18:25] *** sporous joined
[18:25] *** SamuraiJack joined
[18:26] <masak> diakopter: why the wry face?

[18:26] <colomon> masak: that's easy.  $n == one((1..*).map({ $_ * $_}))

[18:27] <masak> haha

[18:27] <masak> it returns true or doesn't halt. I like your style. :)

[18:27] <benabik> 1..$n or 1..($n/2) is probably better

[18:27] <colomon> it clearly avoids floating-point math.  And it must be fast, because it uses quantum mechanics!  ;)

[18:27] <jnthn> Now you just need to wrap it in something that decides whether it halts or not.

[18:28] <colomon> jnthn: that's an exercise left for the reader.  I'm on vacation.

[18:28] <diakopter> just stop when it's greater than n

[18:28] *** fhelmberger joined
[18:29] <sorear> masak: !($n +& 2).  Nice quick way to eliminate half of non-perfect squares, but sadly does not quite get all of them

[18:30] <masak> sorear: cool.

[18:30] <masak> the SO thread I'm reading talk about analyzing the last 6 bits for quick elimination.

[18:30] <masak> it also talks about the John Carmack hack.

[18:30] <colomon> link for the lazy?

[18:31] <masak> http://stackoverflow.com/questions/295579/fastest-way-to-determine-if-an-integers-square-root-is-an-integer

[18:33] <colomon> masak++

[18:38] <PerlJam> Seems like that should be a rosetta code entry if it's not already

[18:38] <sorear> all I can come up with atm is quadratic reciprocity

[18:39] <masak> never heard of it.

[18:40] <masak> ooh.

[18:40] <masak> there's so much math out there... :)

[18:41] *** SamuraiJack left
[18:41] <PerlJam> masak: It's the closest we get to programming the universe

[18:44] <dalek> nqp/toqast: 737fd97 | jnthn++ | / (4 files):

[18:44] <dalek> nqp/toqast: Get ++ and -- back in place; since we don't have a container model, it really maps down to binding and stuff. Dubious, but removing it will probably cause riots...

[18:44] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/737fd97d98

[18:45] <jnthn> 41/60 of t/nqp pass now. :)

[18:45] <nwc10> first goal is 60/60 ?

[18:45] <nwc10> then you start seeing how well NQP does on actually compiling Rakudo?

[18:45] *** SamuraiJack joined
[18:45] <nwc10> with suitable breaks for "drink beer" on the way?

[18:45] *** fhelmberger left
[18:46] *** benabik left
[18:46] *** benabik_ joined
[18:47] <masak> sounds like a full evening! :)

[18:48] <sorear> MATH

[18:48] *** benabik_ left
[18:49] *** benabik joined
[18:49] * masak pictures sorear jumping in through the window of a math conference, shouting "MATH" and running off

[18:49] <jnthn> I...probably should work on my proceedings thing rather than hack on this all evening :)

[18:49] <masak> oh right! les proceedings!

[18:50] * [Coke] wonders if y'all are just making up papers to go with the talks and calling them proceedings.

[18:50] <PerlJam> masak: ETOOMUCHXKCD

[18:50] <[Coke]> PerlJam: ... I don't have that error on my system. huh.

[18:50] <masak> PerlJam: I'm not sure what you mean by "too much"... :P

[18:51] <[Coke]> in an academic setting, the proceedings would be actual pre-existing work like a thesis, no?

[18:51] <PerlJam> [Coke]: Depends.

[18:51] <PerlJam> [Coke]: many times you just have to submit an abstract to get a talk accepted.  The actual paper doesn't have to exist until just before the conference

[18:52] <nwc10> "conference driven development"

[18:52] <masak> absolutely.

[18:52] <[Coke]> PerlJam: ah. Thanks.

[18:53] * [Coke] will miss yapc::eu, but is going to a work-hosted "agile" developer conference at disney this month.

[18:54] <[Coke]> I will attempt to bring up perl at least once. ;)

[18:54] <nwc10> but not in the way that Pythonista bring up Perl? :-)

[18:54] <PerlJam> "at disney"?  Will Mickey Mouse host?  ;-)

[18:54] * colomon is missing all perl conferences this year, but will hopefully get to stay up until 1am playing music in a bar every night this week.

[18:54] *** thou left
[18:55] <jnthn> .oO( Disney Agile: keep the development cycles Minnie )

[18:55] * nwc10 groans

[18:55] * masak .oO( Donald Duck typing )

[18:55] <PerlJam> nwc10: creativity requires sacrifices sometiems.

[18:56] <sorear> colomon: is that a sarcastic 'get' ?

[18:56] <colomon> sorear: it is not

[18:56] <sorear> in that case, \o/

[18:56] <PerlJam> colomon: Playing covers or originals?

[18:57] <colomon> PerlJam: Irish traditional, so all covers unless I sneak in one of my own.  but then no one else would know how to play along, and what would be the fun of that?

[18:57] <PerlJam> ah

[18:58] <PerlJam> I was hoping you'd say "some originals" so that we could compose and ode to Perl 6 or something :)

[18:58] <PerlJam> s/and/an/

[18:58] <colomon> well, there always is the "Star of Rakudo".  ;)

[19:00] *** GlitchMr left
[19:01] *** SamuraiJack left
[19:03] <colomon> We're here for http://celticfestival.ca/fr_celticcollege.cfm -- my wife is taking classes all day while I watch our three-year-old, and then once he's in bed at night I get to go out and hit the bars to play music with the teachers and students.  Only problem with this approach is I'm now about four hours behind on my sleep...

[19:08] <PerlJam> colomon: doesn't your 3 year old take naps?   Seems like a handy way you could catch up too  :-)

[19:09] <colomon> PerlJam: he never naps.

[19:09] <PerlJam> then you aren't running him hard enough when he's awake ;)

[19:10] <colomon> on the rare occasions he does nap, he then invariably stays up at least three hours past his bedtime -- usually pretty cranky the entire time, too.

[19:17] <sorear> On the bright side, in less than a year you won't have a 3-year-old to worry about.

[19:17] *** birdwindupbird joined
[19:18] *** quietfanatic joined
[19:18] <PerlJam> yeah, but in about 10 years you'll have a teenager to worry about 

[19:25] <[Coke]> (disney) just using a conf. room at one of the resorts.

[19:26] *** cotto joined
[19:27] *** seldon left
[19:35] *** ilogger2 joined
[19:35] *** ChanServ sets mode: +v ilogger2

[19:47] *** fgomez joined
[19:51] *** seldon joined
[19:54] *** brrt joined
[19:54] *** fgomez left
[20:02] *** thou joined
[20:18] <sirrobert> Is there a way to scan the loaded packages in a process?

[20:31] <sirrobert> just another quick ping =)  Is there a way to see the classes/modules/packages that have been loaded?

[20:32] <tadzik> hm. I think Perl 5 has something which shows loaded files, maybe Perl 6 has is too

[20:32] <[Coke]> do we have %INC?

[20:32] <tadzik> yeah, %INC

[20:32] <tadzik> r: say %*INC.perl

[20:32] <p6eval> rakudo 34e8d4: OUTPUT«Failure.new(exception => X::AdHoc.new(payload => "Dynamic variable \%*INC not found"))␤»

[20:32] <tadzik> apparently not

[20:33] <tadzik> n: say %*INC.perl

[20:33] <p6eval> niecza v19-15-g051783d: OUTPUT«Any␤»

[20:33] <[Coke]> n: use Test; say %*INC.perl;

[20:33] <p6eval> niecza v19-15-g051783d: OUTPUT«Any␤»

[20:34] <jnthn> If you just care about "what do we have", you can look in places like GLOBAL and ::

[20:34] <jnthn> r: use Test; say GLOBAL::.keys

[20:34] <p6eval> rakudo 34e8d4: OUTPUT«Test␤»

[20:34] <sirrobert> ok

[20:34] <sirrobert> I didn't know about GLOBAL

[20:34] <sirrobert> thanks =)

[20:34] <jnthn> note that

[20:34] <sorear> except that loaded modules only go into GLOBAL if they are declared 'our'

[20:34] <sorear> or have a double colon in the name

[20:34] <jnthn> r: use Test; say ::.keys

[20:34] <p6eval> rakudo 34e8d4: OUTPUT«&isa_ok &ok &dies_ok &nok &lives_ok &is GLOBALish &eval_dies_ok &isnt EXPORT &eval_lives_ok &is_approx $?PACKAGE &is_deeply &todo ::?PACKAGE &done_testing &skip $_ &done $/ &skip_rest $=pod $! &diag !UNIT_MARKER &plan &flunk &pass␤»

[20:35] <[Coke]> pugs: use Test; say ::.keys

[20:35] <p6eval> pugs: OUTPUT«pugs: *** Unsafe function 'use' called under safe mode␤    at /tmp/55tFahu1ED line 1, column 1␤»

[20:35] <[Coke]> O_o

[20:36] <sirrobert> r: class Foo { }; say Global::.keys;

[20:36] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Global' called (line 1)␤»

[20:36] <sirrobert> r: class Foo { }; say GLOBAL::.keys;

[20:36] <p6eval> rakudo 34e8d4: OUTPUT«Foo␤»

[20:36] <sorear> r: my class Foo { }; say GLOBAL::.keys;

[20:36] <p6eval> rakudo 34e8d4: OUTPUT«␤»

[20:36] <sirrobert> that's cool

[20:36] <sorear> r: class Foo::Bar { }; say GLOBAL::.keys;

[20:36] <p6eval> rakudo 34e8d4: OUTPUT«Foo␤»

[20:36] <sorear> r: my class Foo::Bar { }; say GLOBAL::.keys;

[20:36] <p6eval> rakudo 34e8d4: OUTPUT«␤»

[20:37] <sirrobert> r: class Foo { }; class Bar::Baz { }; say GLOBAL::;

[20:37] <sorear> name handling for stuff with :: in the name is quite an embarrasment now

[20:37] <p6eval> rakudo 34e8d4: OUTPUT«("Foo" => Foo, "Bar" => Bar).hash␤»

[20:37] <sorear> probably an embarrassment we'll not be able to fix before 6.0

[20:38] <sirrobert> well, presumably you have to dig into it ...?

[20:38] <jnthn> sorear: The rule in Rakudo with my and multi-jointed things is "it means put the top-level thing in the lexical scope only"

[20:38] <sirrobert> hrm

[20:39] <sorear> it still breaks in quite a few ways

[20:39] <sorear> r: use Test; my class Test::More { }

[20:39] <p6eval> rakudo 34e8d4:  ( no output )

[20:39] <sorear> r: my class Test::More { }; use Test

[20:40] <p6eval> rakudo 34e8d4:  ( no output )

[20:40] <sirrobert> how do I make this dwim?

[20:40] <sirrobert> r: class F::B { }; say GLOBAL::; for GLOBAL::.keys -> $space { say GLOBAL::$space::}; }

[20:40] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2, near "say GLOBAL"␤»

[20:40] <jnthn> GLOBAL::{$space}

[20:40] <sirrobert> r: class F::B { }; say GLOBAL::; for GLOBAL::.keys -> $space { say GLOBAL::{$space}::}; }

[20:40] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2, near "say GLOBAL"␤»

[20:40] <sirrobert> r: class F::B { }; say GLOBAL::; for GLOBAL::.keys -> $space { say GLOBAL::{$space}}; }

[20:40] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Confused␤at /tmp/ZEYxBd7AZk:1␤»

[20:40] <sorear> for GLOBAL::.kv -> $space, $obj { say $obj.WHO.keys }

[20:40] <sirrobert> hmmm... haven't used WHO before ... reading =)

[20:42] <jnthn> It's just like a hash.

[20:42] <sirrobert> interesting

[20:43] <sirrobert> it's a Stash() =)

[20:43] <sorear> the combination of the hash, the serialization on precompilation, and the ways Perl 6 tries to enforce lexical scope everywhere it can makes for interactions that break my head

[20:43] <sirrobert> r: my $f; say $f.WHO.WHAT;

[20:43] <p6eval> rakudo 34e8d4: OUTPUT«Stash()␤»

[20:44] <sorear> what you are seeing there is that WHO means .WHAT.WHO

[20:44] <sorear> you're seeing the symbol table Any::

[20:44] <sorear> r: our sub Any::moo() { }; my $f; say $f.WHO.keys

[20:44] <p6eval> rakudo 34e8d4: OUTPUT«␤»

[20:45] <sorear> r: sub Any::moo() { }; my $f; say $f.WHO.keys

[20:45] <p6eval> rakudo 34e8d4: OUTPUT«␤»

[20:45] <sorear> r: use MONKEY_TYPING; augment class Any { our sub moo() { }; }; my $f; say $f.WHO.keys

[20:45] <p6eval> rakudo 34e8d4: OUTPUT«&moo␤»

[20:45] <sorear> does Rakudo not implement sub Foo::bar syntax?

[20:45] <jnthn> Hm...I'm guessing not.

[20:45] * jnthn wonders if anybody has ever wanted it :)

[20:46] <nwc10> Perl 5 has to be better for something :-)

[20:46] <sorear> Niecza uses it to hide setting subs

[20:46] <sorear> like sub Niecza::GENERATE-SERIES ...

[20:46] <jnthn> ah

[20:48] * sorear feels like jnthn has a much better grasp on Perl 6's maze of confusing scope logic

[20:49] * jnthn still feels like he's missing some pieces

[20:50] <sirrobert> if I have something like $foo = Foo; $bar = $bar;

[20:50] <sirrobert> how do I access $foo::$bar as an object?

[20:50] <sirrobert> err $bar = Bar

[20:50] <tadzik> ::($foo)::$bar I think

[20:51] <tadzik> but... Why? :P

[20:51] <sirrobert> plugins, etc. =)

[20:52] <sorear> ::($foo) is a *symbolic* reference, which requires $foo to contain a string

[20:52] <sorear> I think you wanted:

[20:53] <sorear> n: class Foo { class Bar { method hi() { say "hello world"; }; };  my $foo = $foo.new;  $foo.WHO<Bar>.hi;

[20:53] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unable to parse block at /tmp/v3R82exUU4 line 1:␤------> [32mclass Foo {[33m⏏[31m class Bar { method hi() { say "hello wo[0m␤Couldn't find final '}'; gave up at /tmp/v3R82exUU4 line 1 (EOF):␤------> [32m  my $foo = $foo…

[20:53] <sorear> n: class Foo { class Bar { method hi() { say "hello world"; }; }; }; my $foo = $foo.new;  $foo.WHO<Bar>.hi;

[20:53] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method hi in type Any␤  at /tmp/ofWdEv9qi2 line 1 (mainline @ 7) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /home/p6e…

[20:53] <sorear> n: class Foo { our class Bar { method hi() { say "hello world"; }; }; }; my $foo = $foo.new;  $foo.WHO<Bar>.hi;

[20:53] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method hi in type Any␤  at /tmp/Mq6gjvQ0jE line 1 (mainline @ 7) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /home/p6e…

[20:53] <sorear> n: our class Foo { our class Bar { method hi() { say "hello world"; }; }; }; my $foo = $foo.new;  $foo.WHO<Bar>.hi;

[20:53] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method hi in type Any␤  at /tmp/pytWUJeCBJ line 1 (mainline @ 7) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564) ␤  at /home/p6e…

[20:53] <sorear> n: our class Foo { our class Bar { method hi() { say "hello world"; }; }; }; my $foo = Foo.new;  $foo.WHO<Bar>.hi;

[20:54] <p6eval> niecza v19-15-g051783d: OUTPUT«hello world␤»

[20:57] *** brrt left
[20:58] *** sftp joined
[21:06] <masak> r: multi detect(Str $foo where { /O/ }) {}; detect "O"

[21:06] <p6eval> rakudo 34e8d4: OUTPUT«No such method 'match' for invocant of type 'Any'␤  in method Bool at src/gen/CORE.setting:9912␤  in sub detect at /tmp/5xYZYnV9gY:1␤  in block  at /tmp/5xYZYnV9gY:1␤␤»

[21:06] <masak> r: multi detect(Str $foo where /O/) {}; detect "O"

[21:06] <p6eval> rakudo 34e8d4:  ( no output )

[21:07] <masak> r: multi detect(Str $foo where /O/) { say "OH HAI" }; detect "O"

[21:07] <p6eval> rakudo 34e8d4: OUTPUT«OH HAI␤»

[21:07] <masak> r: sub detect(Str $foo where { /O/ }) {}; detect "O"

[21:07] <p6eval> rakudo 34e8d4: OUTPUT«No such method 'match' for invocant of type 'Any'␤  in method Bool at src/gen/CORE.setting:9912␤  in sub detect at /tmp/M9N_VOniLZ:1␤  in block  at /tmp/M9N_VOniLZ:1␤␤»

[21:07] <jnthn> Oh...is that a sink context oopsie?

[21:07] <masak> r: subset Ostring of Str where { /O/ }; say "O" ~~ Ostring

[21:07] <p6eval> rakudo 34e8d4: OUTPUT«No such method 'match' for invocant of type 'Any'␤  in method Bool at src/gen/CORE.setting:9912␤  in any accepts_type at src/gen/Metamodel.pm:2443␤  in method ACCEPTS at src/gen/CORE.setting:562␤  in block  at /tmp/9k10u4Evhm:1␤␤»

[21:07] <masak> seems so.

[21:08] <jnthn> Not surprising given we don't really do sink context properly yet.

[21:08] <jnthn> A curious place for it to fall out though

[21:09] * masak updates the ticket

[21:09] <masak> r: say "O" ~~ { /O/ }

[21:09] <p6eval> rakudo 34e8d4: OUTPUT«␤»

[21:10] <moritz> I guess the problem is that at the point where the regex is evaluated in boolean context, $_ isn't bound to 'O'

[21:11] <benabik> r: "O" ~~ { .say }

[21:11] <p6eval> rakudo 34e8d4: OUTPUT«O␤»

[21:11] *** cognominal_ joined
[21:19] <pmichaud> I see no sink context there, fwiw.

[21:19] <jnthn> pmichaud: There shouldn't be one.

[21:20] <pmichaud> r: say "0" ~~ { /0/.Bool }

[21:20] <p6eval> rakudo 34e8d4: OUTPUT«True␤»

[21:21] <masak> rn: sub foo(:$) {}; say &foo.signature.perl

[21:21] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Abbreviated named parameter must have a name at /tmp/BAHjOlMIKM line 1:␤------> [32msub foo(:$[33m⏏[31m) {}; say &foo.signature.perl[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting l…

[21:21] <p6eval> ..rakudo 34e8d4: OUTPUT«:()␤»

[21:21] <masak> sorear: no, it mustn't. where did you read that?

[21:21] <pmichaud> I don't understand the ticket, then.

[21:21] <masak> maybe it's a non-bug.

[21:22] * masak re-opens https://rt.perl.org/rt3/Ticket/Display.html?id=69492

[21:22] <pmichaud> I somewhat agree that 'no such method 'match' for invocant isn't quite right.

[21:22] <moritz> r: m/a/

[21:22] <p6eval> rakudo 34e8d4: OUTPUT«No such method 'match' for invocant of type 'Any'␤  in block  at /tmp/jtiiOpmO2H:1␤␤»

[21:22] <pmichaud> r: sub detect(Str $foo where /O/) {};  detect "O";

[21:22] <p6eval> rakudo 34e8d4:  ( no output )

[21:23] <sorear> std: sub foo(:$) { }

[21:23] <p6eval> std f43a358: OUTPUT«ok 00:00 41m␤»

[21:23] <sorear> masak: please explain to me how a named parameter without a name makes any sense at all.

[21:23] <sorear> r: sub foo(:$) {}; say &foo.signature

[21:24] <p6eval> rakudo 34e8d4: OUTPUT«:()␤»

[21:24] <sorear> r: sub foo(:$) {}; say &foo.signature.params

[21:24] <p6eval> rakudo 34e8d4: OUTPUT«Parameter<-1329049004>␤»

[21:24] <sorear> r: sub foo(:$) {}; say &foo.signature.params[0].perl

[21:24] <p6eval> rakudo 34e8d4: OUTPUT«␤»

[21:24] <sorear> r: sub foo(:$) {}; say &foo.signature.params[0].name.perl

[21:24] <p6eval> rakudo 34e8d4: OUTPUT«""␤»

[21:24] <sorear> r: sub foo(:$) {}; say &foo.signature.params[0].named.perl

[21:24] <p6eval> rakudo 34e8d4: OUTPUT«Bool::True␤»

[21:25] <moritz> r: sub foo(:$) { say 'lol' }; foo |{ '' => 42}

[21:25] <p6eval> rakudo 34e8d4: OUTPUT«lol␤»

[21:25] <moritz> r: sub foo() { say 'lol' }; foo |{ '' => 42}

[21:25] <p6eval> rakudo 34e8d4: OUTPUT«Unexpected named parameter '' passed␤  in sub foo at /tmp/IAcMaG3QFH:1␤  in block  at /tmp/IAcMaG3QFH:1␤␤»

[21:25] <masak> sorear: it does make sense. the name is ''

[21:25] <masak> like moritz++ just showed.

[21:25] <sorear> masak: '' isn't a valid identifier

[21:25] <masak> right.

[21:25] <masak> so what?

[21:25] <pmichaud> r: sub foo(*%named) { say %named{''} };   foo |{ '' => 42 }

[21:25] <p6eval> rakudo 34e8d4: OUTPUT«42␤»

[21:25] <masak> moritz++ also showed that you can pass by hash.

[21:26] <masak> $ is a valid *variable* declaration.

[21:26] <sorear> it's still confusing and wrong

[21:26] *** spider-mario joined
[21:26] <masak> it's confusing but not wrong.

[21:26] <masak> it's a very valid corner case.

[21:26] <masak> this happened to me in actual code at one point.

[21:26] <masak> with multis and sublasses and stuff.

[21:26] <masak> subclasses*

[21:26] <pmichaud> r: sub foo(*%named) { say %named{42} };  foo |{ 42 => 'bar'};    # not a valid identifier but still valid

[21:26] <p6eval> rakudo 34e8d4: OUTPUT«bar␤»

[21:26] <sorear> it's a dubiously valid corner case that I'm going to rule illegal until I see a non-contrived use case

[21:27] <pmichaud> hmm, I always thought that Perl tended to not rule corner cases illegal until there was a clear reason to do so.

[21:27] <masak> sorear: ok. I'm not going to push it. just noting that there's nothing in principle to prevent it from working out.

[21:27] <sorear> I would really like a general way to define parameters with non-identifier names

[21:27] <moritz> fwiw non-identifier named args might be useful for HLL interop

[21:27] <sorear> exactly

[21:28] <sorear> in particular this came up while I was working with Tk and blizkost

[21:28] <pmichaud> since STD.pm6 feels that :$ is a valid parameter name, I think compilers should honor that 

[21:28] <sorear> std: $::::

[21:28] <p6eval> std f43a358: OUTPUT«ok 00:00 40m␤»

[21:29] <sorear> but, masak, if you have a legit use, I don't think adding :$ will break anthing

[21:29] <moritz> std: :(:$::::)

[21:29] <p6eval> std f43a358: OUTPUT«[31m===[0mSORRY![31m===[0m␤Invocant is too exotic at /tmp/GVY608xYbs line 1:␤------> [32m:(:$[33m⏏[31m::::)[0m␤Cannot put required parameter after variadic parameters at /tmp/GVY608xYbs line 1:␤------> [32m:(:$:::[33m⏏[31m:)[0m␤Check failed␤FAILED 00:00 4…

[21:30] <moritz> "too excotic"++

[21:30] <moritz> r: :(:$::::)

[21:30] <p6eval> rakudo 34e8d4: OUTPUT«===SORRY!===␤Cannot use :: as a type name at line 2, near ":)"␤»

[21:30] <sorear> n: $::::

[21:30] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Name component may not be null at /tmp/Zg0XyhRUGp line 1:␤------> [32m$::[33m⏏[31m::[0m␤␤Parse failed␤␤»

[21:30] <sorear> n: $::::x

[21:31] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Name component may not be null at /tmp/c48WLdSwax line 1:␤------> [32m$::[33m⏏[31m::x[0m␤␤Parse failed␤␤»

[21:43] <moritz> p6: say "foo" & "a nice old foo" ~~ /foo/

[21:44] <p6eval> niecza v19-15-g051783d: OUTPUT«all(#<match from(0) to(3) text(foo) pos([].list) named({}.hash)>, #<match from(11) to(14) text(foo) pos([].list) named({}.hash)>)␤»

[21:44] <p6eval> ..rakudo 34e8d4: OUTPUT«This type cannot unbox to a native string␤  in any <anon> at src/gen/BOOTSTRAP.pm:104␤  in any !cursor_init at src/stage2/QRegex.nqp:487␤  in method ACCEPTS at src/gen/CORE.setting:9889␤  in block  at /tmp/8_WHndcNAF:1␤␤»

[21:45] <moritz> p6: say so 'u ' ~~ /<.ws>.$/

[21:45] <p6eval> rakudo 34e8d4, niecza v19-15-g051783d: OUTPUT«False␤»

[21:45] <masak> sorear: I don't have a legit use offhand. I don't think I retain the code where this happened. it's also possible that what I had in that code was an anon positional parameter, and that made me think of anon named parameters.

[21:46] <moritz> why doesn't that regex match?

[21:46] <moritz> is it because <.ws> doesn't backtrack?

[21:46] <masak> p6: say so '' ~~ /<.ws>/

[21:46] <p6eval> rakudo 34e8d4, niecza v19-15-g051783d: OUTPUT«True␤»

[21:47] <masak> p6: say so 'u' ~~ /<.ws>./

[21:47] <p6eval> rakudo 34e8d4, niecza v19-15-g051783d: OUTPUT«True␤»

[21:47] <masak> moritz: yeah, I think it's because <.ws> doesn't backtrack.

[21:47] <moritz> but why not? I thought it was the regex that calls it that controls the backtracking

[21:49] <moritz> maybe I'm wrong though; it's late here, and the whole backtracking thing was never transparent to me

[21:49] <moritz> nr: say so ' ' ~~ /\s* . $/

[21:49] <p6eval> rakudo 34e8d4, niecza v19-15-g051783d: OUTPUT«True␤»

[21:49] <moritz> nr: say so ' ' ~~ /[:r \s*] . $/

[21:49] <p6eval> rakudo 34e8d4, niecza v19-15-g051783d: OUTPUT«False␤»

[21:50] <moritz> I guess that's the same principle

[21:51] <pmichaud> I tend to think of <.ws> as being defined as a token, not a regex.

[21:51] <masak> meaning that it doesn't backtrack.

[21:52] <pmichaud> Certainly STD.pm6 defines 'ws' as a token.

[21:52] <moritz> ok

[21:52] * moritz rejects ticket

[21:53] <pmichaud> one can always define a custom ws that backtracks, though.

[21:53] <sorear> masak: I think the logic I was using was something like 'it doesn't make sense for, out of the infinity of non-identifiers, only one of them be allowed as a parameter name'

[21:53] <sorear> *shrug* it's not a big deal to me

[21:54] <masak> not to me either.

[21:55] <masak> but I agree with pmichaud: Perl generally doesn't prohibit corner cases "just because".

[21:55] <masak> rather, it tends to allow corner cases "just because" :)

[21:55] * moritz goes to bed, "just because" :-)

[21:56] <masak> moritz: goodnight, just because :P

[22:13] *** spaceships joined
[22:15] <TimToady_> http://rosettacode.org/wiki/Odd_word_problem#Perl_6

[22:20] <masak> that is the weirdest problem I've seen on Rosetta Code.

[22:20] <masak> anyway, nice solution.

[22:22] <felher> TimToady++ # odd word problem :)

[22:32] *** fridim_ joined
[23:00] *** fridim_ left
[23:01] *** quietfanatic_ joined
[23:03] <masak> '♞, »ö«

[23:05] *** benabik joined
[23:10] *** gongyiliao joined
[23:20] <timotimo> { [ ow(in), .print ][0]; } <- this is a cute trick to do A, then B and return the value of B, i must say.

[23:21] <timotimo> r: sub yoink() { say "whoa"; BEGIN { say "yay!" } }; say "the return value of yoink is:", yoink

[23:21] <p6eval> rakudo 34e8d4: OUTPUT«yay!␤whoa␤the return value of yoink is:True␤»

[23:22] <timotimo> ah, so BEGIN blocks will return True on success and False on failure or something similar?

[23:22] <timotimo> r: sub yoink() { say "whoa"; CHECK { say "yay!" } }; say "the return value of yoink is:", yoink

[23:22] <p6eval> rakudo 34e8d4: OUTPUT«yay!␤whoa␤the return value of yoink is:True␤»

[23:22] <timotimo> or maybe that's the return value of say?

[23:22] <timotimo> r: say (say "hello")

[23:22] <p6eval> rakudo 34e8d4: OUTPUT«hello␤True␤»

[23:22] <timotimo> indeed it is

[23:22] <timotimo> r: sub yoink() { say "whoa"; 9; CHECK { say "yay!"; 5 } }; say "the return value of yoink is:", yoink

[23:22] <p6eval> rakudo 34e8d4: OUTPUT«yay!␤whoa␤the return value of yoink is:5␤»

[23:23] <timotimo> using that would be cute, too :D

[23:23] <timotimo> but probably unnecessarily complicated

[23:33] *** benabik left
[23:51] *** crankin joined
[23:51] *** crankin left
[23:52] *** fgomez joined
[23:53] *** benabik joined
