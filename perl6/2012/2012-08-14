[00:08] * diakopter spent a lot of time on this a few years ago: https://alioth.debian.org/tracker/download.php/30402/413100/311929/3410/biginteger.js

[00:09] <diakopter> (and this) http://shootout.alioth.debian.org/u64/program.php?test=pidigits&lang=v8&id=1

[00:09] <diakopter> unfortunately it's extremely slow compared to the other languages

[00:15] <lichtkind> ahoj #perl6

[00:16] <japhb_> diakopter, the first of those two links triggers an evil website warning in Firefox

[00:16] <diakopter> I noticed that too

[00:17] *** simcop2387 joined
[00:17] <benabik> http://safebrowsing.clients.google.com/safebrowsing/diagnostic?site=https%3A%2F%2Falioth.debian.org%2Ftracker%2Fdownload.php%2F30402%2F413100%2F311929%2F3410%2Fbiginteger.js&client=googlechrome&hl=en-US

[00:17] <diakopter> but... I'm pretty certain there are no javascript exploits in that code, since I touched every line and have no idea about any exploits.  here, I'll gist it for you:

[00:17] <benabik> Probably because alioth is too liberal in comment contents or something.

[00:18] <diakopter> weird

[00:18] <diakopter> https://gist.github.com/3345041

[00:26] *** fgomez joined
[00:28] *** adu joined
[00:34] *** skids joined
[00:35] <dalek> niecza: c86e8e5 | (Solomon Foster)++ | lib/CORE.setting:

[00:35] <dalek> niecza: When pushing a Pair onto a Hash, convert the key to a Str.

[00:35] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c86e8e555d

[00:54] *** Guest62198 left
[01:04] *** adu left
[01:07] <diakopter> most of the other languages use gmp or some other bigint library (like the built-in one in ghc)

[01:14] <dalek> doc: 45793f0 | (Tim Smith)++ | lib/ (9 files):

[01:14] <dalek> doc: Normalize use of X<>, L<>, and C<> somewhat

[01:14] <dalek> doc: 

[01:14] <dalek> doc: In particular, change some X<foo> to L<foo>.

[01:14] <dalek> doc: 

[01:14] <dalek> doc: Not all L<foo> are generating working links yet; this is something for

[01:14] <dalek> doc: future commits to handle. When a term is used frequently in a region of

[01:14] <dalek> doc: text, the first occurrance is usually linked (with L<foo>), and later

[01:14] <dalek> doc: ones are marked as code (C<foo>) or emphasized (I<foo>) as appropriate.

[01:14] <dalek> doc: review: https://github.com/perl6/doc/commit/45793f0203

[01:19] <dalek> doc: 94bc5b0 | (Tim Smith)++ | .gitignore:

[01:19] <dalek> doc: Ignore html/op

[01:19] <dalek> doc: review: https://github.com/perl6/doc/commit/94bc5b0d23

[01:29] <diakopter> [Coke]: the reason I said I found it hard to imagine it was a problem with PASM is: why would parrot accept invalid bytecode or bytecode that would make it segfault? PASM compiles to bytecode, right? So either the bytecode validator is missing something, there is no bytecode validator, or on amd64 parrot has a problem with the program represented by the bytecode from that PASM.

[01:30] <benabik> diakopter: I don't think there's a validator.

[01:31] *** japhb_ left
[01:31] <diakopter> oh :)

[01:34] <diakopter> it's just.. how could changing a constant integer value by 1 in the program make it segfault

[01:36] <sorear> diakopter: context?

[01:38] <diakopter> oh, primes.pasm in parrot's examples/benchmarks - 17619 works, 17620 segfaults

[01:38] <diakopter> and anything I tried above 17620

[01:38] <sorear> 17620 isn't a prime

[01:38] <diakopter> on amd64 linux, and amd64 windows

[01:38] <diakopter> who said it was a prime?

[01:39] <diakopter> I found it by bisecting

[01:39] <sorear> how did you put 17619 into primes.pasm?

[01:39] <diakopter> line 26

[01:40] <diakopter> set P2

[01:40] <diakopter> rurban said he couldn't reproduce it on 32-bit

[01:40] <sorear> my guess is that 17619 is the first number that triggers a garbage collection, and running imcc over pasm files corrupts memory in a way that crashes the GC when run on 64-bit

[01:41] <sorear> as far as I know PASM is unused and unmaintained

[01:41] <diakopter> well, it could easily be translated to a PIR version

[01:42] <sorear> I wonder if the PIR version also segfaults

[01:42] <diakopter> .. that's what I was saying :P

[01:46] * diakopter stares at 1600 lines of completely un-run/un-tested code

[01:47] *** telex left
[01:47] *** scott_ joined
[01:47] *** scott_ is now known as Guest89821

[01:48] *** telex joined
[01:53] *** jeffreykegler joined
[01:57] *** cognominal left
[01:58] *** cognominal joined
[02:02] *** sftp left
[02:02] *** sftp joined
[02:05] *** Entonian joined
[02:06] *** Entonian left
[02:09] *** perigrin joined
[02:35] *** leprevost left
[02:38] *** Psyche^ joined
[02:42] *** Patterner left
[02:42] *** Psyche^ is now known as Patterner

[02:43] *** orafu left
[02:43] *** orafu joined
[02:55] *** colomon left
[02:56] *** lichtkind left
[03:18] *** colomon joined
[03:18] *** sftp left
[03:35] <benabik> Converting it to PIR is...  pretty darn simple.

[03:36] <benabik> https://gist.github.com/3346083

[03:36] <benabik> That's not the way PIR code is normally written, but it's perfectly valid.

[03:39] *** cognominal left
[03:55] *** adu joined
[03:59] *** jaldhar joined
[04:00] *** skids left
[04:02] <diakopter> benabik: it doesn't run for me; error:imcc:syntax error, unexpected IDENTIFIER, expecting '\n' ('main') in file 'primes.pir' line 20

[04:02] *** Guest89821 left
[04:04] *** scott_ joined
[04:05] *** scott_ is now known as Guest93569

[04:06] *** adu left
[04:06] *** dbr left
[04:06] *** woosley left
[04:06] *** DarthGandalf left
[04:06] *** larks left
[04:10] <benabik> diakopter: Strange.  Runs for me...  Even after copy/pasting back from gist.

[04:10] *** telex left
[04:13] <TimToady> masak++ for the idea to add http://rosettacode.org/mw/index.php?title=Same_Fringe&rcid=146944

[04:15] *** telex joined
[04:17] <diakopter> benabik: I'm confused - your gist is PIR?

[04:17] <benabik> diakopter: Yes.

[04:17] <benabik> diakopter: The difference between PIR and PASM are fairly small.

[04:18] *** DarthGandalf joined
[04:26] *** telex left
[04:37] *** telex joined
[04:50] <pmichaud> .u ✌

[04:50] <phenny> U+270C VICTORY HAND (✌)

[04:51] <sorear> o/ pmichaud

[04:59] *** adu joined
[04:59] *** dbr joined
[04:59] *** woosley joined
[04:59] *** larks joined
[05:04] *** dayangkun joined
[05:14] *** xinming_ joined
[05:16] *** xinming left
[05:19] *** adu left
[05:19] *** dbr left
[05:19] *** woosley left
[05:19] *** larks left
[05:21] <jeffreykegler> r: grammar g; regex r { a }; say 'a' ~~ m/<r>/

[05:21] <p6eval> rakudo 94aa2b: OUTPUT«No such method 'r' for invocant of type 'Cursor'␤  in regex  at /tmp/em8ZxKwFEX:1␤  in method match at src/gen/CORE.setting:4009␤  in block  at /tmp/em8ZxKwFEX:1␤␤»

[05:21] *** birdwindupbird joined
[05:22] <jeffreykegler> What's the problem here?  Why doesn't it find subrule <r>?

[05:23] <TimToady> well, that's kinda like calling a method without a self

[05:24] <TimToady> grammar g { regex r { a } }; g.parse('a', :rule('r')).say

[05:24] <TimToady> nr: grammar g { regex r { a } }; g.parse('a', :rule('r')).say

[05:24] <p6eval> rakudo 94aa2b: OUTPUT«｢a｣␤␤»

[05:24] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[05:25] <TimToady> .parse is a constructor for a current parse

[05:25] <TimToady> a "Cursor"

[05:25] <jeffreykegler> Gotcha

[05:26] <jeffreykegler> Is there a cleaner syntax to define regexes on the fly and apply them?

[05:26] <TimToady> nr: my regex r { a }; say 'a' ~~ / <&r> /

[05:26] <p6eval> rakudo 94aa2b: OUTPUT«｢a｣␤␤»

[05:26] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[05:26] *** Senthil joined
[05:27] <jeffreykegler> r: my regex r { a }; say 'a' ~~ / <&r> /

[05:27] <p6eval> rakudo 94aa2b: OUTPUT«｢a｣␤␤»

[05:27] <TimToady> nr: my $r = rx /a/; say 'a' ~~ / <$r> /

[05:27] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&rx' called (line 1)␤»

[05:27] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[05:28] <TimToady> nr: my $r = rx/a/; say 'a' ~~ / <$r> /

[05:28] <p6eval> rakudo 94aa2b: OUTPUT«｢a｣␤␤»

[05:28] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«#<match from(0) to(1) text(a) pos([].list) named({}.hash)>␤»

[05:28] <TimToady> I guess rakudo doesn't like the space there

[05:29] <jeffreykegler> Gotcha

[05:29] <pmichaud> rakudo likes the space fine; it just thinks that 'rx' is no longer a quote token then.

[05:29] <TimToady> anyway, an assertion with a sigil is whatever scope the symbol is, while <r> is class scoped to the grammar

[05:30] <TimToady> r: say q /foo/

[05:30] <p6eval> rakudo 94aa2b: OUTPUT«foo␤»

[05:30] <TimToady> treats that differently then

[05:30] <jeffreykegler> Yeah, but for, say, a command line the bare <r> sure looks nicer

[05:30] <pmichaud> TimToady: yeah, checking.

[05:31] <pmichaud> TimToady: yes, they're getting treated differently (and shouldn't).

[05:31] <TimToady> r: my $r = rx:i/a/; say 'a' ~~ / <$r> /

[05:31] <p6eval> rakudo 94aa2b: OUTPUT«｢a｣␤␤»

[05:31] <TimToady> r: my $r = rx :i/a/; say 'a' ~~ / <$r> /

[05:31] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Confused␤at /tmp/Y67ADM1LEl:1␤»

[05:32] <TimToady> jeffreykegler: we're not optimizing much for the command line these days :)

[05:32] <jeffreykegler> Understood

[05:33] <jeffreykegler> I'm trying to make the syntax do stuff it wasn't designed for

[05:33] <pmichaud> that's challenging, since the syntax is designed to enable things we didn't think of :)

[05:33] <jeffreykegler> Yeah

[05:34] <pmichaud> bedtime for me -- bbl

[05:34] *** snearch joined
[05:34] <jeffreykegler> The approach I think I'll take is do a first cut with the actuall Perl 6 syntax

[05:35] <jeffreykegler> Learn to ride the bike before rebuilding it

[05:36] <jeffreykegler> Sleep is a good idea

[05:36] <jeffreykegler> Thanks, all!!!

[05:51] *** wtw joined
[05:55] *** jeffreykegler left
[05:55] *** jeffreykegler joined
[05:56] *** jeffreykegler left
[05:58] *** am0c joined
[06:02] *** charsbar_____ left
[06:03] *** charsbar_____ joined
[06:08] *** jaldhar left
[06:09] *** jaldhar joined
[06:14] *** kaleem joined
[06:23] *** jaldhar left
[06:25] *** jaldhar joined
[06:32] *** SamuraiJack joined
[06:34] *** dbr joined
[06:34] *** woosley joined
[06:34] *** larks joined
[06:41] *** DarthGandalf left
[06:44] *** SamuraiJack_ joined
[06:44] *** SamuraiJack left
[06:47] *** am0c left
[07:02] *** DarthGandalf joined
[07:05] *** topo left
[07:06] *** topo joined
[07:16] *** brrt joined
[07:23] *** topo left
[07:23] *** topo joined
[07:26] *** dayangkun left
[07:30] <moritz> \o

[07:30] <brrt> o/

[07:30] <phenny> brrt: 11 Aug 18:31Z <colomon> tell brrt Cat is a hypothetical lazy string type.  (Unless someone implemented it while I was on vacation.)

[07:31] <brrt> colomon++ thats awesome

[07:33] *** dayangkun joined
[07:34] <shachaf> Cat?

[07:38] <moritz> Cat.

[07:44] *** kresike joined
[07:44] <kresike> good morning all you happy perl6 people

[07:45] *** gongyiliao left
[07:47] *** SamuraiJack_ left
[07:48] <moritz> good morning all you happy kresike :-)

[07:48] <kresike> hello moritz 

[07:52] *** gongyiliao joined
[07:54] *** hoelzro|away is now known as hoelzro

[07:56] <hoelzro> o/ perl6 crew

[07:58] <dalek> doc/htmlify-refactor: 7dc74d2 | moritz++ | htmlify.pl:

[07:58] <dalek> doc/htmlify-refactor: use the registry for writing operator files

[07:58] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/7dc74d2711

[07:58] <dalek> doc/htmlify-refactor: feb6c9a | moritz++ | htmlify.pl:

[07:58] <dalek> doc/htmlify-refactor: small simplification

[07:58] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/feb6c9a2e5

[07:59] <sorear> o/ moritz, brrt, kresike, shachaf, hoelzro

[08:00] <shachaf> \o sorear

[08:00] <moritz> good UGT morning *

[08:00] <brrt> \o sorear

[08:00] <moritz> sorear: how are your travel plans coming along?

[08:01] <sorear> moritz: I am at this point absolutely coming.  Trip to is booked and payed for.

[08:02] <moritz> \o/

[08:02] <sorear> once masak/jnthn/mberends are awake I'm going to chat with them and determine absolutely how long I'm staying post-YAPC so I can get the return trip booked

[08:02] <moritz> now I just need to fix mine :-)

[08:03] <hoelzro> when I call self.Role::method(|@args), the self in Role::method *should* be the same as the original self, right?

[08:03] <moritz> hoelzro: correct

[08:03] <sorear> hoelzro: it should be but it's not due to yucky interactions

[08:03] <moritz> sorear: how so?

[08:03] <hoelzro> =(

[08:04] <kresike> \o sorear 

[08:04] <sorear> moritz: it becomes Role.^find_method('method')(self, |@args), which autopuns

[08:04] <tadzik> hello #perl6

[08:04] <sorear> so "self" is replaced automatically by Role.new

[08:04] <sorear> maybe we need a :noautopun flag to find_method

[08:05] <hoelzro> right, that's what I'm observing

[08:06] <sorear> niecza copied rakudo's design for .:: and autopunning and has the same bug because I couldn't see an easy fix for it

[08:09] <sorear> .oO( a bug-compatible reimplementation of Perl 6 )

[08:11] <hoelzro> sorear: do you know of any good work-arounds?

[08:13] <moritz> nr: role R { method x() { say self } }; class C does R { has $.s handles <Str>; method x { self.R::x() } }; C.new(:s<42>).x

[08:14] <p6eval> rakudo 94aa2b: OUTPUT«R()␤»

[08:14] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method trait_mod:handles not yet implemented at /tmp/mEa_nSV46G line 1:␤------> [32m; class C does R { has $.s handles <Str>[33m⏏[31m; method x { self.R::x() } }; C.new(:s<4[0m␤␤Trait 0 not available on variables …

[08:14] <moritz> :(

[08:15] <sorear> nr: role R { our method x() { say self } }; class C does R { has $.s handles <Str>; method x { R::x(self) } }; C.new(:s<42>).x

[08:15] <p6eval> rakudo 94aa2b: OUTPUT«Could not find symbol '&x'␤  in method <anon> at src/gen/CORE.setting:9704␤  in <anon> at src/gen/Metamodel.pm:2304␤  in any find_method_fallback at src/gen/Metamodel.pm:2302␤  in any find_method at src/gen/Metamodel.pm:843␤  in <anon> at src/gen/BOOTSTRAP.pm:824␤ …

[08:15] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Action method trait_mod:handles not yet implemented at /tmp/rill693kg5 line 1:␤------> [32m; class C does R { has $.s handles <Str>[33m⏏[31m; method x { R::x(self) } }; C.new(:s<42[0m␤␤Trait 0 not available on variables …

[08:15] <sorear> nr: role R { our method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; C.new(:s<42>).x

[08:15] <p6eval> rakudo 94aa2b: OUTPUT«Could not find symbol '&x'␤  in method <anon> at src/gen/CORE.setting:9704␤  in <anon> at src/gen/Metamodel.pm:2304␤  in any find_method_fallback at src/gen/Metamodel.pm:2302␤  in any find_method at src/gen/Metamodel.pm:843␤  in <anon> at src/gen/BOOTSTRAP.pm:824␤ …

[08:15] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«42␤»

[08:16] <sorear> suprised rakduo doesn't like that one

[08:16] <hoelzro> I have a (fairly) minimal example here: https://gist.github.com/3344225

[08:16] <hoelzro> (this is for my chat bot)

[08:16] <sorear> oh, R is parametric in rakudo

[08:16] <moritz> all roles are parameteric in rakudo

[08:16] <sorear> nr: role R { &R::x := method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; C.new(:s<42>).x

[08:16] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«42␤»

[08:17] <p6eval> ..rakudo 94aa2b: OUTPUT«===SORRY!===␤Cannot use bind operator with this left-hand side␤at /tmp/TLg56cWqoP:1␤»

[08:17] <moritz> (parametric on ::?CLASS)

[08:17] <sorear> nr: role R { &R::x = method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; C.new(:s<42>).x

[08:17] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«42␤»

[08:17] <p6eval> ..rakudo 94aa2b: OUTPUT«Nominal type check failed for parameter ''; expected $?CLASS but got C instead␤  in method x at /tmp/xVbu12BuFA:1␤  in method x at /tmp/xVbu12BuFA:1␤  in block  at /tmp/xVbu12BuFA:1␤␤»

[08:18] <sorear> r: role R { our method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; say R.WHO.keys # C.new(:s<42>).x

[08:18] <p6eval> rakudo 94aa2b: OUTPUT«␤»

[08:18] <sorear> r: role R { our method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; say R[].WHO.keys # C.new(:s<42>).x

[08:18] <p6eval> rakudo 94aa2b: OUTPUT«Null PMC access in find_method('keys')␤  in block  at /tmp/K_mtiPFRbh:1␤␤»

[08:18] <sorear> r: role R { our method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; say C.^roles.map(*.name) # C.new(:s<42>).x

[08:18] <p6eval> rakudo 94aa2b: OUTPUT«No such method 'name' for invocant of type 'R'␤  in <anon> at src/gen/Metamodel.pm:1191␤  in block  at /tmp/rWeczCK8GH:1␤␤»

[08:18] <sorear> r: role R { our method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; say C.^roles.map({.^name}) # C.new(:s<42>).x

[08:19] <p6eval> rakudo 94aa2b: OUTPUT«R␤»

[08:19] <sorear> r: role R { our method x() { say self.s } }; class C does R { has $.s; method x { R::x(self) } }; say C.^roles[0].WHO.keys # C.new(:s<42>).x

[08:19] <p6eval> rakudo 94aa2b: OUTPUT«␤»

[08:19] *** thou left
[08:19] <hoelzro> thanks for the input guys; I'll be back later

[08:19] *** hoelzro is now known as hoelzro|away

[08:24] *** lumi__ joined
[08:26] *** dakkar joined
[08:37] *** tarch joined
[08:37] *** tarch left
[08:37] *** lumi_ joined
[08:40] *** lumi__ left
[08:53] *** snearch left
[08:56] *** frettled left
[08:56] *** bbkr joined
[08:56] *** frettled joined
[08:57] <dalek> rakudo/sigilless: 060e430 | moritz++ | src/Perl6/ (2 files):

[08:57] <dalek> rakudo/sigilless: fix "our" constants

[08:57] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/060e430c8a

[08:58] *** Coleoid joined
[09:15] <masak> good antenoon, #perl6

[09:15] *** gongyiliao left
[09:15] <moritz> good UGT morning, masak

[09:16] <tadzik> hello masak 

[09:21] *** dayangkun left
[09:22] *** fhelmberger joined
[09:25] <sorear> masak!

[09:38] <dalek> rakudo/sigilless: 50c1845 | moritz++ | src/core/Any.pm:

[09:38] <dalek> rakudo/sigilless: switch Any to sigilless parameters

[09:38] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/50c1845d09

[09:45] *** dakkar left
[09:50] <masak> TimToady: 'return' in an unquote returns from the macro body, right? just checking.

[09:51] <masak> in fact, it seems that for all intents and purposes, unquote code runs as if it were not part of a quasi at all, directly in the macro body.

[09:56] <moritz> yes

[09:57] *** spider-mario joined
[09:57] <moritz> just like   "foo { closure here }" runs as part of the outer routine, not of the string

[09:57] <masak> right.

[09:57] <masak> though the closure has its own lexical scope. I'm not sure the unquotes do.

[09:57] <masak> unquotes are slowly starting to work locally. it's thrilling to observe.

[09:58] <moritz> \o/

[09:59] *** dakkar joined
[09:59] <moritz> masak: commit early, commit often :-)

[10:00] *** fgomez left
[10:00] *** birdwindupbird left
[10:00] * masak hasn't forgotten :)

[10:00] <masak> just ironing out a few show-stopper bugs.

[10:01] *** sergot joined
[10:01] *** Guest93569 left
[10:01] <sergot> Hi! o/

[10:01] *** birdwindupbird joined
[10:01] <tadzik> o/

[10:02] *** hoelzro|away is now known as hoelzro

[10:03] <hoelzro> what would be the correct term for a method call like this: $obj.Super::Class::method()?

[10:03] <hoelzro> I'm adding a test to roast for the behavior I'm seeing

[10:05] <moritz> qualified method call

[10:05] <hoelzro> moritz: thanks

[10:09] <dalek> doc/htmlify-refactor: df46991 | moritz++ | / (2 files):

[10:09] <dalek> doc/htmlify-refactor: switch writing index and disambiguation files to ues the Registry

[10:09] <dalek> doc/htmlify-refactor: 

[10:09] <dalek> doc/htmlify-refactor: currently not quite awesome yet, since it duplicates entries

[10:09] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/df46991705

[10:09] <dalek> doc/htmlify-refactor: e6d28fd | moritz++ | / (3 files):

[10:09] <dalek> doc/htmlify-refactor: make disambiguations more awesome

[10:09] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/e6d28fd1fa

[10:10] *** fhelmberger left
[10:14] *** MayDaniel joined
[10:14] <hoelzro> is it ok to use 'is' to compare objects for testing? or is there a more suitable function to use?

[10:18] <masak> 'is' will stringify the objects and compare the strings. that may or may not be what you want.

[10:19] <masak> r: use Test; class A { has $.x }; is A.new(:x(5)), A.new(:x(42))

[10:19] <p6eval> rakudo 94aa2b: OUTPUT«not ok 1 - ␤#      got: 'A<-809628722>'␤# expected: 'A<-809602341>'␤»

[10:19] <masak> r: use Test; class A { has $.x }; is A.new(:x(5)), A.new(:x(5))

[10:19] <p6eval> rakudo 94aa2b: OUTPUT«not ok 1 - ␤#      got: 'A<-1153073948>'␤# expected: 'A<-1153093643>'␤»

[10:19] <hoelzro> masak: I mean, that's acceptable

[10:19] <hoelzro> because the default stringification should be the class + address

[10:19] <masak> aye.

[10:20] <masak> so it essentially compares on object identity.

[10:20] <dalek> roast: 892a1d7 | (Rob Hoelz)++ | S12-methods/qualified.t:

[10:20] <dalek> roast: Add test for self-preservation in qualified method calls

[10:20] <dalek> roast: review: https://github.com/perl6/roast/commit/892a1d750b

[10:20] <sorear> masak: hi

[10:20] <sorear> is jnthn around?

[10:21] *** Senthil1 joined
[10:21] <hoelzro> ok, I've written a few tests for roast; time to start pulling my weight =)

[10:22] <masak> sorear: no, he doesn't seem to be around at the moment.

[10:22] <hoelzro> how do you Rakudo folk work on Rakudo? do you just work with the binary out of your working copy, or do you do a temp install somewhere?

[10:23] <hoelzro> I'd like to contribute to Rakudo, but I also want to maintain my Rakudo ★ installation

[10:23] *** MayDaniel left
[10:24] *** Senthil left
[10:24] <masak> I mostly have a working copy per branch I own, plus one for the nom branch. I install the one for the nom branch, not the others.

[10:24] <hoelzro> so ./perl6 *should* just work, right?

[10:25] <masak> does here.

[10:26] <hoelzro> ok, cool =)

[10:26] <tadzik> hoelzro: as long as you did 'make install'

[10:26] <hoelzro> tadzik: huh?

[10:26] *** topo left
[10:27] *** topo joined
[10:28] <tadzik> hoelzro: you need 'make install' for stuff to work

[10:28] <hoelzro> I see..

[10:34] <hoelzro> is there a way to call a role's version of a method other than $obj.My::Role::method()? I need to get around the bug with that to continue with my chat bot

[10:38] <hoelzro> something along the lines of My::Role.^find_method('method').bind(self).call(|@args)

[10:41] <sorear> hoelzro: Try using a class instead?  MI

[10:45] *** JimmyZ_ joined
[10:47] <JimmyZ_> good evening, #perl6

[10:48] <moritz> good UGT morning, JimmyZ_ 

[10:49] <JimmyZ_> morning, moritz 

[10:49] <hoelzro> sorear: =(

[10:50] <sorear> hoelzro: that's the internalized MI-phobia talking.  Drop the long face and give it a try.

[10:51] <hoelzro> but...but...roles?

[10:51] <sorear> Are roles working for you?

[10:54] <hoelzro> they were

[11:03] <dalek> doc/htmlify-refactor: 98aa7f7 | moritz++ | htmlify.pl:

[11:03] <dalek> doc/htmlify-refactor: switch write-routine-file to use the type registry. Get rid of some global vars

[11:03] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/98aa7f757e

[11:05] *** daxim joined
[11:08] <jnthn> ohhai

[11:08] * jnthn the whole morning in meetings

[11:09] * daxim gives jnthn a cookie

[11:10] * jnthn 14

[11:10] <jnthn> er, /win, not /me

[11:10] *** Coleoid left
[11:11] <sorear> jnthn: ping.

[11:11] <jnthn> sorear: pong

[11:12] <sorear> pm.

[11:12] <jnthn> ?

[11:13] <daxim> ↑ query incoming ↑

[11:14] *** broquain1 joined
[11:14] *** cosimo__ joined
[11:14] *** masak_ joined
[11:18] *** drbean left
[11:19] *** drbean joined
[11:19] *** masak_ is now known as masak

[11:19] *** jeffreykegler joined
[11:22] *** tadzik joined
[11:24] *** prammer joined
[11:25] *** hoelzro is now known as hoelzro|away

[11:34] <arnsholt> Huh. Apparently one of the changes in my dyncall-sized-num breaks Rakudo

[11:49] <masak> chromatic writes about testing and Perl: http://www.modernperlbooks.com/mt/2012/08/why-i-use-perl-testing.html

[11:50] <moritz> http://www.perlmonks.org/?node_id=987033 # optimizing compiler for Perl 5?

[11:50] <masak> I half-expected the influence of the Pugs project to be mentioned in the article. knowing chromatic, I'd guess the omission is intentional and he has some good reason.

[11:50] *** Senthil1 left
[11:50] <masak> (but of course, this is not a place where we psycho-analyze chromatic) :)

[11:52] <tadzik> I'd love to get it done and released at YAPC 2013, which will hopefully be held here in Austin.

[11:52] <tadzik> Invent a time machine and send the code back from 2023.

[11:52] <tadzik> rurban++ nails it ;)

[11:52] <tadzik> oh, that's chromatic++ actually

[11:52] <masak> moritz++ # nice answer!

[11:52] <jnthn> You know you have a tricky problem on your hands when implemetning a time machine is the easier option.

[11:53] <moritz> well, at least you don't have scheduling problems with the time machine (if you manage to build it at all)

[11:54] * masak .oO( "the time machine was tricky too, but made signficantly simpler because I had this design I sent back!" )

[11:54] <masak> I think that's an autopun.

[11:54] *** jeffreykegler left
[11:55] <tadzik> so you have the bootstraping problem to which the solution is "wait"?

[11:57] <moritz> tadzik: no need for waiting

[11:58] <jnthn> Doesn't this approach mean that you're assuming your future self would rather leave your past self waiting around for longer than needed, rather than going back to the point when you first had started wanting the time machine?

[11:58] <moritz> tadzik: because if you'll have a time machine, your future self would present it to you right *now*

[11:58] <moritz> (unless your future self wants to wait until you're on your own :-)

[11:59] <jnthn> .oO( Why does my future self always think he knows better than I do now? :P )

[11:59] *** Senthil joined
[11:59] <moritz> jnthn: second system syndrome, I'm sure :-)

[12:01] <masak> jnthn: seems to be a very human way of thinking.

[12:02] <masak> similarly, we feel we know better than people in the 19th century, not because science has progressed by leaps and bounds since then -- which it has -- but since they come from an era where photographs were black-and-white, if that, and they dressed very outmodedly and said funny things.

[12:04] <jnthn> Yeah. I bet they didn't even dress in hacker t-shirts when they went to hackathons. :P

[12:05] *** Senthil left
[12:06] <masak> :D

[12:06] * jnthn tries to focus on this $reporting task

[12:06] <jnthn> On the up side, I just had the hand-off meeting about it :)

[12:06] <masak> jnthn: they were probably helped by some cocky valley girl who spoke their language.

[12:07] <masak> wow, the comment about Perl in http://news.ycombinator.com/item?id=4379541 are not negative.

[12:07] <moritz> maybe the ruby folks haven't woken up yet? :-)

[12:08] <masak> there was at least one Ruby person among the commenters.

[12:09] <moritz> I know. I was joking.

[12:13] <masak> right. hence the smiley. :)

[12:13] *** fridim_ joined
[12:14] <jnthn> Ruby folks get to sleep in? Geez...good job I didn't know that when picking a language to hack on :P

[12:17] <moritz> nr: say <a b c A B>.uniq(*.uc)

[12:17] <p6eval> rakudo 94aa2b: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in method uniq at src/gen/CORE.setting:1094␤  in block  at /tmp/RtD_SMbk4a:1␤␤»

[12:18] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«Unhandled exception: Excess arguments to Any.uniq, used 1 of 2 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Any.uniq @ 1) ␤  at /tmp/hi_m4Ozt3i line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /ho…

[12:19] <jnthn> awww

[12:19] <jnthn> It'd be nice if .uniq could do that :)

[12:21] <tadzik> oh yes

[12:21] <tadzik> even List::Util has uniq_by in TODO

[12:22] <tadzik> I'm missing it from time to time

[12:23] * jnthn uses the Linq equivalent to that a reasonable amount in real world code

[12:29] <colomon> seems like it would be easy enough to add to List::Utils...

[12:29] <tadzik> yep

[12:29] <tadzik> I was planning to make that my first contribution to Perl 5 :)

[12:32] <dalek> doc/htmlify-refactor: 43ee365 | moritz++ | htmlify.pl:

[12:32] <dalek> doc/htmlify-refactor: kill some dead code

[12:32] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/43ee365d74

[12:32] <dalek> doc/htmlify-refactor: 0945572 | moritz++ | htmlify.pl:

[12:32] <dalek> doc/htmlify-refactor: remove %types. Switch search to the type registry instead

[12:32] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/0945572f1f

[12:33] <sirrobert> I really agree with this from that article (fwiw):  Of all the languages I've used for pay and for hobby, none compare to Perl in terms of testing culture and ecosystem.

[12:33] <sirrobert> take out "testing" and it's still true

[12:33] <moritz> ok, htmlify-refactor branch is ready for merging

[12:33] <moritz> I've synced its output to doc.perl6.org

[12:33] <daxim> tadzik, leonerd said he wants to merge his <http://p3rl.org/List::UtilsBy> *_by functions into List::Util

[12:33] *** scottdware joined
[12:34] <moritz> if anybody finds something wrong the site, please tell me soon

[12:34] <moritz> otherwise I'll merge later today

[12:34] <colomon> tadzik: no, List::Utils, the p6 version.  ;)

[12:34] <tadzik> colomon: oh, I see :)

[12:34] <tadzik> daxim: bah, too late then :)

[12:35] <daxim> a reminder can't hurt, I also want MOAR functional prog

[12:35] <moritz> disambiguation pages like http://doc.perl6.org/Str have changed, they now list each separately documented variant of a routine

[12:39] <sirrobert> http://doc.perl6.org/routine/Str

[12:39] <sirrobert> there's an odd ordered list at the top of the page.

[12:39] <sirrobert> (at least, *I* don't understand it =)

[12:41] <sirrobert> or rather

[12:41] <daxim> that list should say:  Str from Mu, Str from List   and so on

[12:41] <sirrobert> I guess I mean:  I think the section labels could be better

[12:41] <moritz> right

[12:42] <jnthn> maybe "routine Str from Mu"

[12:42] <jnthn> is it hard to differentiate sub from method?

[12:42] <sirrobert> Mu.Str ?

[12:43] <sirrobert> It's nice when docs use language-like syntax

[12:43] <sirrobert> reduces the cognitive load

[12:43] <jnthn> Mu.Str (method)

[12:43] <jnthn> Str (type)

[12:43] <jnthn> perhaps

[12:43] <sirrobert> on that page, the primary info is Mu, List, etc.

[12:43] <sirrobert> not Str

[12:43] <moritz> jnthn: not hard, just nasty (differentiate sub from method)

[12:44] <moritz> sirrobert: ok, will fix

[12:44] <sirrobert> I'll scan for other stuff

[12:44] <jnthn> moritz: Nasty in what sense?

[12:44] <moritz> jnthn: I need to extract the first code block from the pod tree, and see if it declares a sub or a method

[12:44] <moritz> and all of that is nasty to do

[12:45] <moritz> the first needs nasty walking of nasty doc tree

[12:45] <moritz> the second needs partial parsing of Perl 6 declarations

[12:45] *** MayDaniel joined
[12:46] <jnthn> ah, ok

[12:46] <jnthn> I'll settle with routine for now then :)

[12:48] *** scottdware left
[12:48] <sirrobert> looks good.  (this is the first time I've seen doc.perl6.org)  Thanks =)

[12:50] *** cognominal joined
[12:55] *** scottdware joined
[12:56] *** PacoAir joined
[12:57] *** scottdware left
[12:58] *** scottdware joined
[12:59] *** JimmyZ_ left
[13:01] *** scottdware left
[13:02] *** scottdware joined
[13:02] *** snearch joined
[13:05] <sirrobert> when I worked at my old company, we used a proprietary docs format (not POD).  Where can I find the docs on perl6 POD -- especially for someone not used to POD

[13:06] <diakopter> it's complicated, because there's the perl6 POD that's specified in S26, and then there's what's implemented, and they're extremely different

[13:06] <sirrobert> ok ... I'll go with implemented for now =)

[13:06] <sirrobert> I'm writing production code

[13:06] <sirrobert> heh

[13:07] <diakopter> afaik, what's implemented is basically the same as p5

[13:07] <jnthn> huh?

[13:07] <sirrobert> ok hmm

[13:07] <diakopter> ?

[13:07] <sirrobert> ?

[13:07] <sirrobert> =)

[13:07] * jnthn thought the implementation tadzik++ did in Rakudo followed S26 rather well

[13:07] * diakopter missed a year or two here or there

[13:08] <jnthn> As in, it can parse S26 which is written in Perl 6 Pod. :)

[13:08] <sirrobert> tell you what, I'll just follow S26 and let you know if anything breaks.  

[13:08] <moritz> not all of S26 is implemented, but a good part of it

[13:08] <diakopter> ohh..

[13:09] <diakopter> I didn't realize it was better than STD in that regard....

[13:09] <moritz> http://doc.perl6.org/routine/Str now with more varied headings

[13:09] <moritz> doc.perl6.org is all powered by p6 doc and Pod::To::HTML and a large piece of custom glue code

[13:09] <sirrobert> thanks, Moritz

[13:10] <moritz> ) can't easily get rid of the 'Str' subheadings, at least not now

[13:10] <sirrobert> oh wait, I mean:  moritz++ =)

[13:10] <dalek> doc/htmlify-refactor: ee09646 | moritz++ | htmlify.pl:

[13:10] <dalek> doc/htmlify-refactor: better headings for routine files

[13:10] <dalek> doc/htmlify-refactor: review: https://github.com/perl6/doc/commit/ee09646f6b

[13:11] <dalek> doc: 6e06b33 | moritz++ | lib/Perl6/Documentable.pm:

[13:11] <dalek> doc: Perl6::Documentable skeleton

[13:11] <dalek> doc: review: https://github.com/perl6/doc/commit/6e06b339fd

[13:11] <dalek> doc: 05d0485 | moritz++ | lib/Perl6/Documentable.pm:

[13:11] <dalek> doc: flesh out Documentable a bit

[13:11] *** dalek left
[13:12] *** dalek joined
[13:12] *** ChanServ sets mode: +v dalek

[13:13] *** scottdware left
[13:14] *** bluescreen10 joined
[13:14] *** scottdware joined
[13:17] <mathw> While I would very much like to be writing this code in a glorious Perl 6 implementation, I have to admit that Perl 5 is pretty awesome in itself :)

[13:20] *** leprevost joined
[13:22] <tadzik> well, I +1 jnthn, I think I implented S26 rather well ;)

[13:22] <tadzik> sirrobert: if you find something which S26 likes and Rakudo doesn't, please yell at me until I fix it

[13:23] <moritz> tadzik: speaking of pod stuff...

[13:23] <sirrobert> tadzik: wilco

[13:23] <moritz> tadzik: in htmlify.pl in the perl6/doc repo, I have sub pod-gist

[13:23] <moritz> tadzik: which I use to debug/inspect pod trees

[13:23] <moritz> tadzik: please try it on some pod docs, and see if you like the output

[13:24] <moritz> tadzik: if yes, I'll be happy to port it to rakudo

[13:24] <moritz> (or you can do it)

[13:25] <tadzik> moritz: so it's like Pod.gist?

[13:26] <moritz> tadzik: no, IMHO it's better :-)

[13:26] <tadzik> ;)

[13:26] <moritz> tadzik: but a possible replacement for Pod::Block.gist, yes

[13:26] <tadzik> okay, I'll take a look after $work

[13:27] *** fhelmberger joined
[13:30] *** JimmyZ joined
[13:30] <masak> TimToady++ # http://rosettacode.org/mw/index.php?title=Same_Fringe#Perl_6

[13:30] *** fhelmberger left
[13:33] <masak> TimToady: how can 'not samefringe $a, $x' work? doesn't Z=== stop when the shortest list finishes?

[13:33] <masak> rn: say 1,2,3,4,5,6,7,8 Z=== 1,2,3,4,5,6,7,8,9

[13:33] * [Coke] ~~

[13:33] <p6eval> rakudo 94aa2b, niecza v19-21-gc86e8e5: OUTPUT«True True True True True True True True␤»

[13:34] <masak> rn: say all 1,2,3,4,5,6,7,8 Z=== 1,2,3,4,5,6,7,8,9

[13:34] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«all(Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True, Bool::True)␤»

[13:34] <p6eval> ..rakudo 94aa2b: OUTPUT«all(True, True, True, True, True, True, True, True)␤»

[13:34] <masak> rn: say so all 1,2,3,4,5,6,7,8 Z=== 1,2,3,4,5,6,7,8,9

[13:34] <p6eval> rakudo 94aa2b, niecza v19-21-gc86e8e5: OUTPUT«True␤»

[13:34] <masak> [Coke]: \o

[13:35] <moritz> masak: if we had a meta-operator for roundrobin, that might be a use case for it

[13:35] <moritz> (if you want the comparison to return False because one list is longer)

[13:36] *** skids joined
[13:36] <masak> I don't want more metaoperator, I want fewer. :/

[13:36] <masak> s*

[13:37] *** fridim_ left
[13:38] <[Coke]> gabor sez: "Note! This site is about Perl 6, the future version of Perl." Is that "close enough" or should we suggest an alternate phrasing.

[13:38] <[Coke]> http://perl6maven.com/perl5-to-perl6-arrays

[13:38] <pmichaud> I'd prefer an alternate phrasing, yes.

[13:38] <masak> I think "the future version of Perl" hits two of the red buttons that mst and I agreed we would try not to push.

[13:39] <masak> "future" angers sixers, "version" angers fivers.

[13:43] <moritz> "This site is about Perl 6. If you don't know which Perl version you are using, it is likely version 5. See perl5maven.com for more information on Perl 5"

[13:45] *** scottdware left
[13:46] <masak> s/Perl version/Perl/

[13:46] <masak> s/version 5/Perl 5/

[13:48] <moritz> "This site is about Perl 6. If you don't know which Perl you are using, it is likely Perl 5"

[13:49] <dalek> rakudo/sigilless: d3d3555 | moritz++ | src/core/Str.pm:

[13:49] <dalek> rakudo/sigilless: switch Str to sigilless params

[13:49] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/d3d3555cac

[13:49] <dalek> rakudo/sigilless: c9417ca | moritz++ | src/core/ (5 files):

[13:49] <dalek> rakudo/sigilless: switch IO, PseudoStash, traits, control.pm and stubs.pm to sigilless params

[13:49] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/c9417ca52c

[13:49] <dalek> rakudo/sigilless: 217d1e3 | moritz++ | src/core/Bool.pm:

[13:49] <dalek> rakudo/sigilless: switch Bool to sigilless params

[13:49] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/217d1e3e33

[13:49] <dalek> rakudo/sigilless: 44730d6 | moritz++ | src/core/ (2 files):

[13:49] <dalek> rakudo/sigilless: switch Regex and MapIter to sigilless params

[13:49] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/44730d6787

[13:49] <dalek> rakudo/sigilless: 96e60eb | moritz++ | src/core/Enum (2 files):

[13:49] <dalek> rakudo/sigilless: switch Enum and EnumMap to sigilless params

[13:49] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/96e60eb1bb

[13:49] <dalek> rakudo/sigilless: 56f00c7 | moritz++ | src/core/ (2 files):

[13:49] <dalek> rakudo/sigilless: switch Num and a few others to use sigilless params

[13:49] <dalek> rakudo/sigilless: review: https://github.com/rakudo/rakudo/commit/56f00c752d

[13:50] <[Coke]> http://news.perlfoundation.org/2012/08/2012q3-grant-proposals.html -      

[13:50] <[Coke]> public comments on the 2 grants this quarter welcome.  

[13:50] <moritz> anybody wants a dumb but necessary Perl 6 task?

[13:50] <[Coke]> (one of them is sixian.)

[13:50] <[Coke]> no, I'm full up on <insert name of developer here>!

[13:51] <moritz> in the sigilless branch, go through the setting and replace    sub f(\$x) { uses $x here }   with  sub f(\x) { uses x here }

[13:52] *** BlueT_ left
[13:52] <felher> moritz: why do we change everything to sigilless?

[13:52] <[Coke]> anyone know Aliaksandr Zahatski?

[13:52] <[Coke]> sigils impose a context which the setting doesn't want to use.

[13:52] <pmichaud> impose?  or imply?

[13:53] <jnthn> .oO( nobody expects the sigil imposition )

[13:53] <[Coke]> I believe impose was the word used yesterday: I am merely parroting.

[13:53] <moritz> [Coke]: because the old syntax isn't valid Perl 6 anymore

[13:53] <moritz> and yes, they (are supposed to) impose a context

[13:53] <[Coke]> oh, \$x, not $x

[13:54] <pmichaud> if they impose a context, then that's a significant change to Rakudo.

[13:54] <moritz> that's why there are now several hundred (felt) warnings while compiling the setting, in the the sigilless branch

[13:54] <pmichaud> you mean that the following no longer holds...?

[13:55] <pmichaud> r:  my $x := Array.new(1,2,3);    for $x { .say };

[13:55] <p6eval> rakudo 94aa2b: OUTPUT«1␤2␤3␤»

[13:55] <moritz> pmichaud: correct

[13:55] <pmichaud> is that fixed in the sigilless branch?

[13:55] <moritz> no

[13:55] <moritz> it's only the first step

[13:55] <pmichaud> that's going to be a significant task to implement.

[13:56] <pmichaud> because it means that flattening behavior is no longer tied to containerness.

[13:56] <felher> Ah, okay. sub a (\$variable) is not valid anymore. It's sub a (\variable) now ?

[13:56] <moritz> unless every scalar var  gets a container

[13:56] <moritz> felher: correct

[13:56] <pmichaud> if every scalar var gets a container, then   my $x :=    doesn't dtrt

[13:56] <felher> moritz, coke: okay, thanks :)

[13:57] <jnthn> fwiw, I hadn't understood that we were changing the semtnics of binding to a scalar

[13:57] <moritz> pmichaud: sigilless now just provides the correct way to do it without the $ sigil

[13:57] <pmichaud> moritz: I'm worried about the notion that the $ imposes a context.

[13:57] <moritz> n: my $a := Array.new(1, 2, 3); .say for $a

[13:57] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«Unhandled exception: Excess arguments to List.new, used 1 of 4 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (List.new @ 1) ␤  at /tmp/OKetQ47nnG line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /ho…

[13:57] <moritz> n: my $a := (1, 2, 3); .say for $a

[13:57] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«1 2 3␤»

[13:58] <jnthn> I'd understood it as "having the $ sigil on something that we know may or may not be a container is suboptimal"

[13:58] <jnthn> pmichaud: I'm bothered about that too :(

[13:59] *** kaleem left
[13:59] <jnthn> If it's the case and spec'd.

[14:00] <pmichaud> I'm just saying that if we say that the $ always imposes a non-flattening context, even under := binding, then that's a very significant change to Rakudo and its internals.

[14:01] <jnthn> Indeed

[14:01] <pmichaud> it also greatly affects lists and flattening behavior.

[14:01] <pmichaud> as in, I have to rethink the model yet again a bit.

[14:01] <jnthn> :(

[14:01] <pmichaud> I'm afk again for a few minutes.

[14:01] * jnthn wonders when enough is enough on this stuff

[14:02] <masak> I guess part of the torment is the ground moving under the implementor.

[14:03] <masak> if it's any consolation, it's painful for app developers, too.

[14:05] <jnthn> Yes, but there's limited tuits and we're worrying about increasingly tiny warts, fixing of which threatens to spend a lot of tuits.

[14:05] <masak> aye.

[14:05] <jnthn> Imagine if we spent them on, oh, I dunno, async IO, or making pre-comp more robust, or more memory/performance improvements, or S09...

[14:06] <masak> you know those tuits aren't fungible :) but point taken.

[14:06] <masak> well, what pmichaud is doing is *very* important: distilling a sane underlying model on top of which we can build the rest.

[14:06] <masak> what I'd like to optimize for more than other things is for pmichaud to be able to do that as efficiently as possible.

[14:07] <moritz> fwiw even if we decide that $ does not always impose context, I think the sigilless stuff is worth it

[14:08] <moritz> because it reduce the number of times that a user is exposed to a $-sigiled var that is not a scalar

[14:08] <jnthn> moritz: Oh, the sigilless stuff is worth it, I agree.

[14:08] <jnthn> moritz: Well, yes, if you have to *explicitly* bind with := then I think it's much less of an issue.

[14:10] *** tanzdebil joined
[14:10] <tanzdebil> morning, peoples

[14:10] *** SamuraiJack joined
[14:10] <tanzdebil> r: say caller.WHAT

[14:11] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&caller' called (line 1)␤»

[14:11] <tanzdebil> n: say caller.WHAT

[14:11] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Anon.1.Run.MAIN.C0mainline (Niecza.Frame ) [0x00000] in <filename unknown>:0 ␤  at Niecza.Kernel.RunCore (Niecza.Frame& cur) [0x00000] in <filenam…

[14:11] <tanzdebil> so, no caller?

[14:12] <jnthn> No, though CALLER:: pseudo-packager is implemented if that does what you want

[14:13] <tanzdebil> ok...

[14:13] <jnthn> What do you need to do, ooc?

[14:15] <moritz> tanzdebil: it's called callframe in Perl 6

[14:15] <jnthn> oh!

[14:15] <pmichaud> back again

[14:16] *** fridim_ joined
[14:16] <pmichaud> I totally agree that sigilless is worth it.  I'm not arguing against that at all.

[14:16] <masak> r: say callframe.^name

[14:16] <p6eval> rakudo 94aa2b: OUTPUT«CallFrame␤»

[14:16] <sirrobert> trying to install DBIish with panda:  Unrecognized nqp:: opcode 'nqp::nativecallrefresh' at line 274, near ";\n    1;\n}"

[14:16] <masak> r: say callframe.^methods>>.name

[14:16] <p6eval> rakudo 94aa2b: OUTPUT«new line file callframe <anon> <anon> <anon>␤»

[14:17] <sirrobert> apparently it couldn't resolve some dependency resolution for "NativeCall"

[14:17] <sirrobert> is this a known issue?

[14:17] <pmichaud> I very much like the notion that I can bind a symbol to something without a sigil implying something that isn't true.

[14:17] <masak> sirrobert: that's zavolaj.

[14:17] <moritz> sirrobert: does 'use NativeCall;' work?

[14:17] <jnthn> arnsholt++ has been doing quite a few bits with NativeCall of late.

[14:17] <sirrobert> moritz:  seems to

[14:17] <jnthn> Maybe current depends on having a very recent Rakudo or NQP or something.

[14:17] <tanzdebil> r: sub foo { say callframe^.name } foo()

[14:17] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Confused␤at /tmp/2ZV7903UMx:1␤»

[14:18] <pmichaud> semicolon

[14:18] <pmichaud> std:  sub abc(\$x) { say $x; };   # just checking

[14:19] <p6eval> std 235f71b: OUTPUT«Potential difficulties:␤  Unsupported use of \ with sigil; nowadays please use \ without sigil at /tmp/mhtuVVR8iL line 1:␤------> [32msub abc(\$x[33m⏏[31m) { say $x; };   # just checking[0m␤ok 00:00 43m␤»

[14:19] *** snearch left
[14:19] <moritz> tanzdebil: .^ is always a call to the meta class -- not what you want

[14:19] <sirrobert> despite the fact that "use NativeCall;" works when I try it, installing DBIish still tries to grab and install it (maybe a version thing?)

[14:19] <sirrobert> when I did: panda install NativeCall it gives the same error.

[14:19] <pmichaud> std:  sub abc(\@x) { say @x; };   

[14:19] <p6eval> std 235f71b: OUTPUT«Potential difficulties:␤  Unsupported use of \ with sigil; nowadays please use \ without sigil at /tmp/y3VRz4jIsp line 1:␤------> [32msub abc(\@x[33m⏏[31m) { say @x; };[0m␤ok 00:00 43m␤»

[14:20] <arnsholt> It's the bat^wNativeCall signal!

[14:20] * arnsholt reads

[14:21] <pmichaud> That gives me a twinge; it means we no longer have the equivalent of "is ref" for sigiled variables.

[14:21] <tanzdebil> r: sub foo { say callframe.WHAT } foo()

[14:21] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Confused␤at /tmp/H_c_q5VZuw:1␤»

[14:21] <pmichaud> maybe we don't need (or want) it, but it feels like we've lost something there.

[14:21] <jnthn> r: sub foo { say callframe.WHAT }; foo()

[14:21] <p6eval> rakudo 94aa2b: OUTPUT«CallFrame()␤»

[14:21] <sirrobert> woops... MiniDBI uses NativeCall too =)

[14:21] <arnsholt> sirrobert: I think it might be an old Rakudo/NQP pair. Do you compile and install your own, or do your install a package from somewhere?

[14:22] <sirrobert> install my own, but it's been a month or so

[14:22] <tanzdebil> moritz:  ok, thanks -- I just want something that, well, acts sort of like the way caller is described in S06-advanced/caller.t

[14:22] <sirrobert> compile my own, I mean

[14:22] <tanzdebil> if such a thingy exists

[14:22] <moritz> tanzdebil: what do you need it for?

[14:22] <arnsholt> Hmm. Think that should be recent enough

[14:22] <arnsholt> Oh, no!

[14:22] <moritz> tanzdebil: if you want the caller's name, Backtrace is currently the best route

[14:22] <sirrobert> arnsholt: let me do a re-compile and see (just takes a few minutes)

[14:22] <tanzdebil> to behave like caller() in p5

[14:22] <arnsholt> That'll fix it

[14:23] <sirrobert> arnsholt: ok =)  What's the thing, do you think?

[14:23] *** brrt left
[14:23] <arnsholt> nativecallrefresh is a recent addition

[14:23] <pmichaud> anyway, since STD.pm6 doesn't like \ in front of sigiled variables, I totally agree that the sigilless branch will need to convert all of the \$x to \x in the setting.

[14:23] <moritz> r: sub f { g() }; sub g { say Backtrace.new.[0].subname }; f()

[14:23] <p6eval> rakudo 94aa2b: OUTPUT«new␤»

[14:23] <jnthn> moritz: We will warn about it in the next release, iiuc?

[14:23] <moritz> r: sub f { g() }; sub g { say Backtrace.new.[1].subname }; f()

[14:23] <p6eval> rakudo 94aa2b: OUTPUT«g␤»

[14:23] <arnsholt> It's an opcode to manually refresh objects that have been twiddled by C code while you weren't looking, so to speak

[14:23] <moritz> r: sub f { g() }; sub g { say Backtrace.new.[2].subname }; f()

[14:23] <jnthn> moritz: And remove it further down the line?

[14:23] <p6eval> rakudo 94aa2b: OUTPUT«f␤»

[14:23] <moritz> jnthn: that's up for discussion

[14:23] <pmichaud> Whether we go further and say that $ on a variable ->imposes<- a context in expressions needs further discussion.

[14:24] <moritz> jnthn: currently the parser issues a warning, and that's hard-coded

[14:24] <moritz> jnthn: whether we merge the branch before or after the release can be discussed

[14:24] *** scottdware joined
[14:24] <arnsholt> (We check arguments to functions for modifications, but if a previous function has saved a reference to a memory location and a later function, not taking the object as an argument directly, changes it, you have to manually refresh)

[14:24] <tanzdebil> r: sub g { say Backtrace.new.[0].WHAT }; g()

[14:24] <p6eval> rakudo 94aa2b: OUTPUT«Backtrace::Frame()␤»

[14:24] <tanzdebil> r: sub g { say Backtrace.new.[0].subname }; g()

[14:24] <p6eval> rakudo 94aa2b: OUTPUT«new␤»

[14:24] <tanzdebil> r: sub g { say Backtrace.new.[1].subname }; g()

[14:24] <p6eval> rakudo 94aa2b: OUTPUT«g␤»

[14:25] <tanzdebil> awesome!

[14:25] <moritz> also depends a bit on if and what policy we adopt for managing changes

[14:25] <[Coke]> does std have a test suite? --lazyCoke

[14:25] <moritz> [Coke]: roast :-)

[14:25] <pmichaud> [Coke]: std uses roast also

[14:26] <pmichaud> I have to run errands; I'm afk for a while.

[14:26] <tanzdebil> moritz -- thanks!

[14:27] <[Coke]> I wonder if I should add std to the list of daily spec testers.

[14:27] <moritz> http://doc.perl6.org/Str # now knows that some of them are methods

[14:28] <masak> r: sub g { .say for Backtrace.new.list>>.subname }; g

[14:28] <p6eval> rakudo 94aa2b: OUTPUT«new␤g␤␤␤»

[14:28] <dalek> perl6-roast-data: 8d6f501 | coke++ | / (4 files):

[14:28] <dalek> perl6-roast-data: today

[14:28] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/8d6f5016f2

[14:28] <moritz> rakudo introduces two callframes for the mainline

[14:29] <moritz> that's why there are two empty lines in the output

[14:29] <[Coke]> rakudo just hit 23000

[14:29] <masak> \o/

[14:30] <jnthn> \o/

[14:31] *** scottdware left
[14:31] *** scottdware joined
[14:32] *** scottdware left
[14:32] *** scottdware joined
[14:32] *** thou joined
[14:33] *** scottdware left
[14:33] *** scottdware joined
[14:34] *** scottdware left
[14:35] *** sftp joined
[14:35] *** wtw left
[14:36] <arnsholt> [Coke]: Having std check the spectests sounds good to me

[14:37] *** alester joined
[14:40] *** benabik left
[14:42] *** benabik joined
[14:44] * colomon had to foolishly go and add one more test for existing code to List::Utils, and it doesn't work under Niecza.  :(

[14:45] * colomon will take some of the credit for 23000, having added new tests in the last couple of days.  ;)

[14:46] * diakopter can't push to github :(

[14:47] <masak> diakopter: works here.

[14:47] *** scottdware joined
[14:47] <diakopter> :/ looks like dns problem at my end.

[14:52] *** tanzdebil left
[14:59] <kresike> bye all

[15:00] *** kresike left
[15:01] *** JimmyZ left
[15:02] <TimToady> masak: that is why I tack an Any on the end of each list

[15:04] <colomon> oh, you are testing this case, aren't you?  TimToady++

[15:04] <colomon> wait... what about 1 => 2 => 3 => 4 => 5 => 6 => 7 => 8 => Any versus 1 => 2 => 3 => 4 => 5 => 6 => 7 => 8  ?

[15:05] <TimToady> Any === Any

[15:05] <TimToady> and I assume the leaves don't contain an Any

[15:06] <TimToady> I wanted to use Nil, but it disappears in list context by the currently implemented semantics

[15:06] <TimToady> (I think that's one of the things OKness was going to change)

[15:19] <masak> TimToady: ah, that clears it up.

[15:19] *** havenn joined
[15:25] *** jeffreykegler joined
[15:27] <TimToady> a couple other things: rakudo's Z isn't lazy, and niecza doesn't allow fringeˊ with the MODIFIER LETTER ACUTE ACCENT on the end

[15:29] <TimToady> and while niecza's Z is lazy, Z=== isn't

[15:30] <masak> there's three bug reports in what you just said. I think only the first may have been submitted.

[15:32] *** Timothy69 joined
[15:32] <jnthn> decommute &

[15:33] <Timothy69> bleh:)

[15:34] <colomon> is for really supposed to be eager if the list passed is not known infinite, or is that a rakudo-bug?

[15:34] *** Timothy69 left
[15:34] <colomon> nr: for 1..* Z 1..* -> $a { say $a; last if $a == 3 }

[15:34] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«1␤1␤2␤2␤3␤»

[15:34] <p6eval> ..rakudo 94aa2b: OUTPUT«(timeout)»

[15:37] <colomon> nr: for 1..* -> $a { say $a; last if $a == 3 }

[15:37] <p6eval> rakudo 94aa2b, niecza v19-21-gc86e8e5: OUTPUT«1␤2␤3␤»

[15:39] *** havenn left
[15:40] *** tanzdebil joined
[15:40] *** thelazydeveloper joined
[15:41] <TimToady> to see the lack of laziness, put 'say $leaf' in with the 'take $leaf'

[15:42] <TimToady> for is supposed to be eager in sink context, and lazy when it's functioning as a map

[15:42] <colomon> oh!  Is my bug a Z bug rather than a for bug?

[15:43] <TimToady> I don't see a bug in what you put up above

[15:43] <TimToady> oh, wait

[15:43] <TimToady> that was niecza

[15:43] <colomon> do we have an idiom for "I want to lazily loop through this array and have side-effects rather than results?"

[15:44] <colomon> wait, is map also supposed to be eager in sink context?

[15:44] <moritz> sure

[15:44] <TimToady> yes

[15:45] <TimToady> colomon: sure, we have such an idiom, called read the next element of the list

[15:45] <colomon> TimToady: how do you do that without destroying the list?

[15:45] <TimToady> but using lazy lists for side effects is kinda...fraught...

[15:45] <TimToady> lists are meant to be destroyed

[15:45] <moritz> colomon: a lazy loop without results would just never do anything

[15:46] <TimToady> use an array if you want to keep the values

[15:46] <colomon> of for pete's sake

[15:47] <colomon> https://gist.github.com/3350408 # how do you suggest implementing this so it can handle lazy lists as input?

[15:48] * colomon has already used "gather for" four times this morning...

[15:48] <sirrobert> arnshold et al.:  recompiling rakudo from the latest tarball didn't fix the NativeCall error

[15:49] <sirrobert> going to look into a workaround =)

[15:49] <TimToady> why wouldn't that handle lazy lists?  gather provides a sink context, so the for runs, and it stops at the take unless there is demand for the next value

[15:49] *** tokuhiro_ left
[15:49] <arnsholt> sirrobert: You need a new NQP as well. Not sure if the NQP revision Rakudo currently wants is new enough

[15:49] <arnsholt> (If it isn't we'll probably want to fix that)

[15:49] *** tokuhiro_ joined
[15:50] <sirrobert> arnsholt:  hrm.  Where do I get a new NQP (and what's NQP? =)

[15:50] <colomon> TimToady: "for is supposed to be eager in sink context"

[15:50] <sirrobert> ah, found it on github.  reading

[15:50] <moritz> arnsholt: should I bump rakudo's NQP_REVISION to nqp master?

[15:50] <TimToady> the for is eager, sure

[15:50] <TimToady> that doesn't mean the loop doesn't hang when it needs to

[15:50] <sirrobert> moritz:  let me see if that fixes my problem, at least 

[15:50] <sirrobert> (or do it for other reasons)

[15:51] <arnsholt> moritz: I think that should fix it

[15:51] <TimToady> okay, let's rephrase that

[15:51] <colomon> TimToady: maybe we're not talking about for being eager in the same way.  I mean eagerly evaluating the list it is passed before starting to executre

[15:51] <moritz> arnsholt: it's already on newest

[15:51] <TimToady> right

[15:51] <moritz> arnsholt: maybe you need to merge your branch first?

[15:51] <arnsholt> Oh!

[15:51] <arnsholt> I feel silly now =)

[15:51] <arnsholt> :q

[15:51] * hugme hugs arnsholt, good vi(m) user!

[15:51] <TimToady> the 'for' is eager in the sense that it keeps trying to get the next value of the lazy list

[15:52] <sirrobert> arnsholt:  any ideas about my issue?

[15:52] <TimToady> it is not eager in the sense of slapping an eager() around the argument list

[15:52] <colomon> TimToady: ah.  it certainly has done that in Rakudo in the past.

[15:52] <TimToady> and that confusion may be at the root of most of the eagerness bugs in rakudo

[15:52] <masak> TimToady: that's not a distinction I've seen made anywhere before.

[15:53] *** joyv joined
[15:53] <TimToady> anything eager just keeps reading the lazy list.  eager() merely does that till it runs out of list, and returns the whole list

[15:53] <masak> TimToady: so, you're saying that the difference in eagerness between 'for' and 'map'... is non-syntactical?

[15:53] <TimToady> there is no difference

[15:53] <masak> ok.

[15:53] <moritz> (if we do sink context properly, there is no difference)

[15:54] <TimToady> there is not supposed to be a difference, I should say

[15:54] *** tokuhiro_ left
[15:54] <colomon> nr: https://gist.github.com/3350456

[15:54] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Missing block␤at /tmp/c4vhQQ9sz9:10␤»

[15:54] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Missing block at /tmp/oOIw6xlR_V line 10 (EOF):␤------> [32m}[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[15:55] <colomon> nr: https://gist.github.com/3350456

[15:55] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Missing block␤at /tmp/0622KMBDYq:10␤»

[15:55] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Missing block at /tmp/Ti2HUhvHyM line 10 (EOF):␤------> [32m}[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[15:56] <arnsholt> moritz: It's not in a branch

[15:56] <arnsholt> master has nqp::nativecallrefresh inserted in QAST/Operations.nqp

[15:56] <arnsholt> So latest NQP should fix it

[15:56] <TimToady> std: https://gist.github.com/3350456

[15:56] <p6eval> std 235f71b: OUTPUT«ok 00:00 45m␤»

[15:57] <colomon> nr: https://gist.github.com/3350456

[15:57] <moritz> arnsholt: we are talking about 83e2a14cc9f8e6fd09bb78a897c39deba8809f70 in nqp as "latest master", right?

[15:57] <sirrobert> arnsholt: compiling now

[15:57] <p6eval> rakudo 94aa2b: OUTPUT«(timeout)»

[15:57] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«1␤2␤3␤»

[15:57] <arnsholt> moritz: Yup

[15:58] <moritz> that's what rakudo/nom uses as NQP_REVISION

[15:58] <arnsholt> Bah!

[15:58] <colomon> TimToady: yeah, Rakudo's for effectively slaps an eager around the argument list still.  (Though only if it is not known infinite)

[15:58] <arnsholt> In that case, I have no idea what's wrong

[15:58] <TimToady> colomon: I'm surprised niecza didn't give you a better message there

[15:58] <colomon> TimToady: me too

[15:58] <TimToady> std: for lines -> {...}

[15:59] <p6eval> std 235f71b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'lines' needs parens to avoid gobbling block at /tmp/e8a8p3obI7 line 1:␤------> [32mfor lines[33m⏏[31m -> {...}[0m␤Missing block (apparently gobbled by 'lines') at /tmp/e8a8p3obI7 line 1:␤------> [32mfor lines -> {...}[33…

[15:59] <TimToady> that message

[15:59] <TimToady> std: sub generate {...}; for generate -> {...}

[15:59] <p6eval> std 235f71b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'generate' needs parens to avoid gobbling block at /tmp/IeAbHuFnGC line 1:␤------> [32msub generate {...}; for generate[33m⏏[31m -> {...}[0m␤Missing block (apparently gobbled by 'generate') at /tmp/IeAbHuFnGC line 1:␤------…

[15:59] <colomon> n: sub generate {...}; for generate -> {...}

[15:59] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Missing block at /tmp/qRGlHPjh1o line 1 (EOF):␤------> [32mub generate {...}; for generate -> {...}[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[15:59] <TimToady> oh, I think that uses %*MEMOS, which niecza has avoided

[15:59] *** am0c joined
[16:00] <TimToady> errands &

[16:01] <sirrobert> arnsholt: hrm... ok.  Going to get some lunch.  Will try to think of something while I'm gone =)

[16:02] <sirrobert> worst case scenario is I can just wire it up manually for this deadline and integrate with a DBI later.

[16:03] *** joyv left
[16:04] <arnsholt> Sounds like a plan, yeah =)

[16:05] <colomon> Okay, List::Utils now has uniq-by, though one of the tests for it hangs in Rakudo.  (Everything works in Niecza.)

[16:07] <masak> hm, I wonder if there's a case for spec'ing .uniq to do what .uniq-by does...

[16:07] * jnthn home

[16:09] <tadzik> I'd +1 that

[16:12] <colomon> masak: I believe so. 

[16:13] <colomon> masak: but part of the rationale for List::Utils has always been, "maybe some of these should be a core part of p6"

[16:13] <masak> well, in that case, colomon++

[16:13] <colomon> note that there are some interesting questions about just how it should work

[16:14] <masak> it doesn't feel *obvious* that .uniq should have an optional &by argument... but it feels kinda, um, strangely consistent that it do.

[16:14] <masak> thus placing it in the same "class" of methods as .min and .sort

[16:15] <colomon> The niecza source code says "[uniq] needs a way of taking a user-defined comparison specifier, but AFAIK nothing has been spec'd yet."  Mind you, I probably wrote that myself.  ;)

[16:16] <masak> heh.

[16:17] <masak> as to "some interesting questions about just how it should work" -- how about this: run the &by code, and compare results with === :)

[16:18] <masak> simple and works for anything I can think of.

[16:18] <colomon> and O(N^2), no?

[16:19] <jeffreykegler> Reading STD.pm it looks like precedence is set using an <O(...)> assertion

[16:19] <jeffreykegler> Which synopsis is that documented in?

[16:19] <colomon> I meant specifically, do you return the original $element from the list, or &by($element)?

[16:19] <masak> colomon: original, of course.

[16:19] <colomon> yeah, that's what I'm thinking too

[16:19] <masak> otherwise you'd just .map.uniq

[16:19] <colomon> exactly

[16:20] <masak> jeffreykegler: in STD.pm :)

[16:20] <jeffreykegler> masak: Doesn't count!!  I said synopsis :-)

[16:21] <arnsholt> I'm not sure the exact mechanism of setting precedence levels is specced

[16:21] <masak> S05 definitely talks about precedence levels.

[16:22] <masak> I don't hink it talks about <O(...)>

[16:22] <masak> but I've always thought of that one as STD.pm6-specific.

[16:25] <arnsholt> Yeah, I'm pretty sure it is

[16:26] <arnsholt> Although NQP (and by extension Rakudo, I guess) have adopted the same convention I think

[16:26] *** tanzdebil left
[16:26] <moritz> <O($level)> parses any expression with precedence tighter (or equal?) than $level

[16:26] <thou> tadzik: i found a few things that don't work right w/ rakudo S26 handling

[16:26] <thou> r: my $pod = eval "=head1 Foo\n\n    =head1 Bar\n\n\$=pod\n"; say $pod.perl;

[16:26] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead␤at eval_0:3␤»

[16:26] *** scottdware left
[16:26] <jeffreykegler> Is  <O(...)> a builtin?

[16:27] <moritz> not in Perl 6, no

[16:27] <moritz> we haven't found a good way to expose the precedence parse to user space

[16:27] <thou> (indented pod block doesn't work unless it's the first block)

[16:27] <moritz> but it's soemthing we've been wanting to do for ages

[16:28] <jeffreykegler> moritz: I'd always wondered about that

[16:28] <tadzik> thou: gist please?

[16:28] <thou> tadzik: sure, one minute

[16:28] <jeffreykegler> I mean I get the basic idea of mixing operation precedence and LL

[16:29] <jeffreykegler> But now that I have experience with boundaries between parsers I know they can be very hard to document in any reasonable way

[16:29] <masak> you do? cool!

[16:29] <masak> yeah, and there's been some bugs in the boundaries as well.

[16:29] <masak> so it's not trivial.

[16:29] <moritz> one thing that always bothered me about the precedence parser is that it "just" uses special names

[16:29] <moritz> ie things like 'term' are hard coded in there

[16:30] *** dakkar left
[16:30] <jeffreykegler> Sure, the basic idea is when you need to parse you call the "do what I mean" function and it chooses

[16:30] <moritz> (or at least that's my understanding... feel free to correct me)

[16:31] *** cognominal_ joined
[16:31] <masak> moritz: well, there's only a finite set of those. I don't see the problem with hardcoding them.

[16:31] <moritz> masak: it's a problem if you want to use multiple OPPs in the same grammar

[16:32] <thou> oops, wrong channel :-)

[16:32] <thou> r: https://gist.github.com/3350640

[16:32] <masak> hm.

[16:32] <p6eval> rakudo 94aa2b: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix = instead␤at /tmp/3dYwKjXG4b:3␤»

[16:32] * masak takes the opportunity to mention "precircumfix" in the backlog ;)

[16:32] *** jaldhar left
[16:32] <tadzik> thou: interesting. Looking

[16:33] *** cognominal left
[16:35] *** birdwindupbird left
[16:39] <diakopter> .u 2ADC

[16:39] <phenny> U+2ADC FORKING (􏿽xE2􏿽xAB􏿽x9C)

[16:40] <daxim> this character is ridiculous

[16:40] <tadzik> thou: ok, I have no idea why this happens :)

[16:40] <thou> tadzik: here's another

[16:40] <thou> r: https://gist.github.com/3350658

[16:40] <p6eval> rakudo 94aa2b: OUTPUT«Array.new(Pod::Heading.new(level => 1, config => ("numbered" => "1").hash, content => Array.new(Pod::Block::Para.new(config => ().hash, content => Array.new("= :nested(2) This doesn't work right")))))␤»

[16:40] <thou> the :nested(2) should wind up in %config

[16:40] <tadzik> right

[16:41] <thou> that one i know why. the regex in Perl6::Grammar is all kinds of ugly for that stuff

[16:41] <thou> using $<spaces> in some places, and not in others....

[16:41] <thou> and lots of cut-n-paste for that handling

[16:42] <tadzik> scumbugs :)

[16:42] <thou> yeah

[16:42] <tadzik> thou: which lines?

[16:42] <tadzik> that's all my work, I'm afraid :)

[16:42] <masak> moritz: well, what it suggests is this. an OPP is a separate thing, like a grammar. you should be able to instantiate several of them from one grammar, and configure them with ops separately from each other.

[16:43] <thou> tadzik: e.g., L291

[16:43] <thou>         [ [\n '=']? \h+ <colonpair> ]* 

[16:43] <thou> that line shows up a lot

[16:43] <thou> and it's always missing $<spaces>

[16:43] <tadzik> yeah, that's wrong, indeed

[16:44] <thou> i think there's some kind of factoring out of the indenting that could be done

[16:45] <tadzik> indeed

[16:45] <tadzik> I'll make it work for now and refactor this thing on the YAPC

[16:45] <tadzik> or midway

[16:45] <tadzik> I'll need some sort of parametrized token

[16:46] <tadzik> like <configuration ($<spaces>)>

[16:48] <tadzik> I hope it could be done better than with some dynamic variable

[16:50] <tadzik> hah, token foo($a) { } just works :)

[16:50] <jnthn> We use it in several places :)

[16:51] <pmichaud> Rakudo's "for" eagerly evaluates its argument; mainly because we don't have a good handle on sink context yet.

[16:52] <pmichaud> no, wait, that's not right.

[16:52] * pmichaud checks.

[16:52] <pmichaud> (1) Rakudo's "for" is eagerly evaluated because we don't have a good handle on sink context yet.

[16:53] <pmichaud> (2) The implementation of ListIter also inadvertently causees its argument to be evaluated more eagerly than it should; I'm currently working on this.

[16:54] <pmichaud> but a lot of it is also tied up in getting Parcel and List handling worked out.

[16:55] <pmichaud> so yes, Rakudo cheats a bit by converting    for something { block }   into      (something,).map( { block } ).eager

[16:55] <jeffreykegler> Big car show in Carmel today.  Goodbye for now

[16:56] * pmichaud wonders if Carmel has one really big car that is being shown.  :-)

[16:56] <TimToady> but it's acting like the eager is inside the .map rather than outside

[16:56] <pmichaud> I think that's due to the ListIter bug.

[16:56] <TimToady> more like (something).eager.map()

[16:56] <TimToady> okay

[16:57] <pmichaud> that one ought to be somewhat easier to fix.

[16:57] <pmichaud> once I get away from Texas I'm expecting to have a bit more tuits/time to work on these things :)

[16:57] <thou> tadzik: here's a hard one

[16:57] <thou> r: https://gist.github.com/3350812

[16:57] <p6eval> rakudo 94aa2b: OUTPUT«Array.new(Pod::Block::Table.new(caption => Any, headers => Array.new("Superhero", "Secret Identity", "Superpower"), config => ("caption" => "'The Other Guys'").hash, content => Array.new(["B<The Shoveller>", "Eddie Stevens", "King Arthur's singing shovel"], ["Blue …

[16:58] <tadzik> okay, I hope it's not actually hard :)

[16:58] *** jeffreykegler left
[16:58] <pmichaud> I do wish my flight across the pond would have power, though.  I might try bringing an extra battery.

[16:58] <tadzik> I'm spectesting the patch for the previous one

[17:00] *** MayDaniel left
[17:00] <tadzik> thou++ #excellent bughunter

[17:00] <tadzik> or Warrior, as the Perl 6 MMORPG describes it

[17:01] <masak> heh.

[17:02] *** bbkr left
[17:02] <masak> actually, The Warrior seems to be an application writer in general.

[17:02] <thou> tadzik: i was using this on S26 source:  https://gist.github.com/3350872

[17:02] *** cognominal__ joined
[17:02] <masak> but yes, that involves finding, fighting, and neutralizing a lot of bugs.

[17:02] <masak> Priests submit bug tickets, apparently.

[17:03] <thou> got onto that by wanting to hack on p6doc

[17:03] <thou> hehe

[17:03] <thou> sorry, masak, i should be doing that :-)

[17:04] <thou> tadzik: on the 3350812 issue, i really don't know how to fix it, because I think the table rows need to be merged first, and *then* their contents re-parsed as pod_textcontent

[17:04] <tadzik> nqp: my $a = Undef;

[17:04] <p6eval> nqp: OUTPUT«Assignment ("=") not supported in NQP, use ":=" instead at line 2, near " Undef;"␤current instr.: 'nqp;HLL;Grammar;panic' pc 21408 (src/stage2/gen/NQPHLL.pir:8190) (src/stage2/gen/NQPHLL.pm:326)␤»

[17:04] <tadzik> nqp: my $a := Undef;

[17:04] <p6eval> nqp:  ( no output )

[17:05] <pmichaud> I guess I'm a "Mage".   If I was associated with Apple then I'd be an   iMage  :-)

[17:05] <pmichaud> afk, kid pickup

[17:05] <tadzik> :>

[17:05] *** cognominal_ left
[17:05] <masak> thou: I have no idea what you are apologizing for :P

[17:05] <thou> masak, for not being a priest in this instance, and just throwing bugs at tadzik instead of rakudobug

[17:06] <tadzik> that's better

[17:06] <tadzik> I forgot about tickets assigned to me :)

[17:06] <masak> pmichaud: I thought Smalltalk programmers were the one worrying about their image... :)

[17:06] <masak> thou: no, that's useful too.

[17:06] <tadzik> . o O ( if I'm not listening to Priest' request, does that make me an unbeliever in the game? :P )

[17:07] <thou> Heathen

[17:07] <masak> :D

[17:07] <masak> tadzik: nah, it just means you're not allowed a Christian burial...

[17:08] *** MayDaniel joined
[17:08] <tadzik> oh noes

[17:09] <tadzik> nqp: return unless 1;

[17:09] <p6eval> nqp: OUTPUT«Confused at line 2, near "return unl"␤current instr.: 'nqp;HLL;Grammar;panic' pc 21408 (src/stage2/gen/NQPHLL.pir:8190) (src/stage2/gen/NQPHLL.pm:326)␤»

[17:09] <masak> nqp: return;

[17:09] <p6eval> nqp:  ( no output )

[17:09] <tadzik> nqp: unless 1 { return };

[17:09] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 2, near "return };"␤current instr.: 'nqp;HLL;Grammar;panic' pc 21408 (src/stage2/gen/NQPHLL.pir:8190) (src/stage2/gen/NQPHLL.pm:326)␤»

[17:09] <masak> nqp: return; say("OH HAI")

[17:09] <p6eval> nqp: OUTPUT«OH HAI␤»

[17:09] <tadzik> no unless I guess

[17:09] <tadzik> nqp: return if 1;

[17:09] <p6eval> nqp: OUTPUT«Confused at line 2, near "return if "␤current instr.: 'nqp;HLL;Grammar;panic' pc 21408 (src/stage2/gen/NQPHLL.pir:8190) (src/stage2/gen/NQPHLL.pm:326)␤»

[17:09] <masak> tadzik: no, see above.

[17:09] <tadzik> nqp: if 1 { return }; # last chance...

[17:09] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 2, near "return }; "␤current instr.: 'nqp;HLL;Grammar;panic' pc 21408 (src/stage2/gen/NQPHLL.pir:8190) (src/stage2/gen/NQPHLL.pm:326)␤»

[17:09] <masak> tadzik: no argumentless 'return'.

[17:10] <tadzik> a-ha

[17:10] <masak> tadzik: this has bitten me before.

[17:10] * masak .oO( it has bitten me and made me bitter... )

[17:10] <tadzik> now I need a full-blown, serialized Any :)

[17:10] <masak> heh :)

[17:10] <tadzik> or not

[17:11] <tadzik> I wonder what the spec says

[17:11] <thou> tadzik: is it easy to hook up --doc=Some::ModuleOrClass.routine and have DOC INIT (or whatever?) call routine($=pod) or similar?

[17:12] <tadzik> thou: why won't you just write class Some::ModuleOrClass { method render($pod) { ... } } ?

[17:12] <thou> um

[17:12] <tadzik> and if you're asking if it's easy to implement, then I guess it's possible

[17:12] <moritz> if you run rakudo with the --doc=Foo switch, it'll try to load the Pod::To::Foo module

[17:12] <thou> ah

[17:12] <thou> ok, that's what i was missing

[17:13] <thou> so htmlify.pl can actually call perl6 --doc=HTML instead of that nasty eval trick?

[17:14] <thou> (perl6/doc/htmlify.pl)

[17:15] <thou> my $pod  = eval slurp($file.path) ~ "\n\$=pod"; 

[17:15] <thou> or should that be Perl6::Grammar.parse(...) somehow

[17:15] <tadzik> not really

[17:15] <tadzik> yes, it should, but it's not possible atm

[17:15] <tadzik> hence the hack

[17:15] <tadzik> (I think)

[17:15] <thou> OK

[17:17] <dalek> rakudo/nom: c07eba2 | tadzik++ | src/Perl6/ (3 files):

[17:17] <dalek> rakudo/nom: Refactor Pod configuration and make it more correct. thou++

[17:17] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c07eba2ca9

[17:18] <tadzik> thou: this fixes https://gist.github.com/3350658 partly, it still fails for the reason from your first gis

[17:18] <tadzik> gist

[17:18] <tadzik> I'll see if I can quick-fix the tables thing

[17:20] <tadzik> ah yes, table rows are post-processed, and for a reason

[17:21] <tadzik> that's hard indeed then :)

[17:21] *** kaare__ joined
[17:21] <thou> :-)

[17:21] <tadzik> thou: could you open RT tickets for those two things? I'll promise to look at them at the YAPC

[17:22] <thou> pod_configuration looks good, tadzik++

[17:22] <tadzik> and if I don't, tell masak to smack me ;)

[17:22] <thou> tadzik: OK, will do (for the first and last ones I reported)

[17:22] <moritz> nr: say Inf cmp Inf

[17:22] <p6eval> rakudo 94aa2b, niecza v19-21-gc86e8e5: OUTPUT«Same␤»

[17:32] *** REPLeffect left
[17:37] <thou> tadzik: here's another, maybe it's related to the 1st:  https://gist.github.com/3351102

[17:38] <tadzik> I think it may be to the spec actually

[17:38] <tadzik> while it's not really DWYM

[17:40] <thou> OK. then that one is a bug in S26 (to fix the diagram so it displays correctly)

[17:42] <tadzik> I may want to email-ask Damian about it actually

[17:42] <tadzik> but that comes tomorrow or later

[17:42] <tadzik> afk&

[17:45] *** REPLeffect joined
[17:51] *** fgomez joined
[17:53] *** daxim left
[17:55] *** fhelmberger joined
[17:57] <TimToady> nr: say 'ˊ' ~~ /\w/

[17:57] <p6eval> rakudo 94aa2b: OUTPUT«｢ˊ｣␤␤»

[17:57] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«Match()␤»

[17:57] * TimToady wonders who is right

[17:57] <moritz> .u ˊ

[17:57] <phenny> U+02CA MODIFIER LETTER ACUTE ACCENT (ˊ)

[17:58] <TimToady> eval: 'ˊ' =~ /\w/

[17:58] <buubot_backup> TimToady: 1

[17:58] <TimToady> nieczabug, I suspect

[17:58] <moritz> p5 considers all modifiers \w

[17:59] <moritz> which kinda makes sense, so that \w+ matches a word that includes them

[17:59] <TimToady> that's why it says "MODIFIER LETTER"

[17:59] <dalek> doc: e9b61ab | moritz++ | htmlify.pl:

[17:59] <dalek> doc: save a bit of duplicate work

[17:59] <dalek> doc: review: https://github.com/perl6/doc/commit/e9b61ab8c6

[17:59] <dalek> doc: 2ca51ac | moritz++ | htmlify.pl:

[17:59] <dalek> doc: distiniguish subs and methods, if we can

[17:59] <dalek> doc: review: https://github.com/perl6/doc/commit/2ca51ac7be

[17:59] <dalek> doc: adc0bd7 | moritz++ | lib/Str.pod:

[17:59] <dalek> doc: harmonize markup

[17:59] <dalek> doc: review: https://github.com/perl6/doc/commit/adc0bd7b28

[17:59] <TimToady> there are plenty of marks that aren't letters, of course

[18:00] <TimToady> std: my $fooˊ = 42;

[18:00] <p6eval> std 235f71b: OUTPUT«ok 00:00 42m␤»

[18:00] <TimToady> nieczabug then

[18:01] <moritz> nr: say so ' ̈' ~~ /\w/

[18:01] <p6eval> rakudo 94aa2b: OUTPUT«False␤»

[18:01] <p6eval> ..niecza v19-21-gc86e8e5: OUTPUT«True␤»

[18:01] <moritz> :-)

[18:01] <moritz> .u  ̈

[18:01] <phenny> U+0020 SPACE ( )

[18:01] <phenny> U+0308 COMBINING DIAERESIS (◌̈)

[18:02] <TimToady> when we switch to NFG these should all just match \w when marking a letter as the base char

[18:05] * colomon wonders if he could sort out how to fix this in niecza....

[18:14] *** fhelmberger left
[18:15] *** fhelmberger joined
[18:16] *** fhelmberger left
[18:32] *** benabik left
[18:35] *** flussence left
[18:45] *** benabik joined
[19:02] *** topo left
[19:04] *** benabik left
[19:07] *** benabik joined
[19:08] <sorear> good * #perl6

[19:09] <colomon> \o

[19:11] *** SamuraiJack left
[19:19] *** Patterner left
[19:19] *** Psyche^ joined
[19:19] *** Psyche^ is now known as Patterner

[19:19] *** brrt joined
[19:28] *** mastersrp joined
[19:29] *** mastersrp is now known as necrophcoder

[19:34] *** vlixes joined
[19:35] *** colomon left
[19:37] *** birdwindupbird joined
[19:45] <[Coke]> is phasers dead?

[19:45] <[Coke]> #phasers, sorry.

[19:46] <masak> don't call it dead call it "a tradition worthy of a comeback" ;)

[19:48] <[Coke]> k.

[19:49] <moritz> it would have been 2 hours ago

[19:49] <moritz> and yes, I think we should have such meetings again

[19:49] <moritz> maybe not weekly

[19:49] <PerlJam> there are people joining #phasers all the time ... It can't be dead  ;)

[19:50] <TimToady> it's...stable...

[19:51] *** leprevost left
[19:54] * [Coke] tries to build std.

[20:01] *** kaare__ left
[20:03] *** kaare__ joined
[20:03] *** leprevost joined
[20:04] *** fgomez left
[20:06] <japhb> moritz, http://doc.perl6.org/routine/Str is looking a bit like it has an echo ... can you get rid of the second level 'Str' headings underneath each 'Type.Str' heading?  Might as well dump the 'From Type' line as well, since that's implied.  You could make it fully parallel for subs by doing 'Type::Str' instead of 'Type.Str', so you don't have to have two code paths for method and sub.

[20:11] <moritz> japhb: dropping the second-level Str headings is non-trivial

[20:11] <moritz> japhb: and I've kept the "from" thing because it's a link

[20:12] *** colomon joined
[20:14] *** sweet|kid joined
[20:15] *** birdwindupbird left
[20:18] *** kaare__ left
[20:19] <japhb> moritz, sure, but the Type in 'Type.Str' should be that link.

[20:20] <japhb> And when I next have doc tuits, I can try thinking about the second level Str heading

[20:20] * [Coke] needs to change "make snaptest" in std. to use "prove"

[20:23] <japhb> moritz, actually, you could make the whole 'Type.Str' be a link to the other page, and start putting a '^Top' link in there somewhere (preferably de-emphasized so it doesn't compete)

[20:32] *** am0c left
[20:36] *** brrt left
[20:43] <TimToady> I have been saying that $ never interpolates in a list for many years now

[20:43] <TimToady> I don't see why this should be suddenly surprising

[20:47] <masak> the example `my $x := Array.new(1,2,3); for $x { .say }` surprises me.

[20:47] <masak> it surprises me that that flattens, I mean.

[20:47] <sorear> um

[20:47] <masak> r: my $x := Array.new(1,2,3); for $x { .say }

[20:47] <p6eval> rakudo c07eba: OUTPUT«1␤2␤3␤»

[20:47] <sorear> ahahahahaha

[20:47] <masak> n: my $x := Array.new(1,2,3); for $x { .say }

[20:47] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«Unhandled exception: Excess arguments to List.new, used 1 of 4 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (List.new @ 1) ␤  at /tmp/Ej1mH3vl0R line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /ho…

[20:47] <sorear> rn: my $x := [1,2,3]; for $x { .say }

[20:47] <p6eval> rakudo c07eba, niecza v19-21-gc86e8e5: OUTPUT«1 2 3␤»

[20:47] <masak> niecza++

[20:48] <sorear> rn: my $x := [1,2,3].list; for $x { .say }

[20:48] <p6eval> niecza v19-21-gc86e8e5: OUTPUT«1 2 3␤»

[20:48] <p6eval> ..rakudo c07eba: OUTPUT«1␤2␤3␤»

[20:48] <sorear> I feel vindicated

[20:48] <TimToady> just so you're not vindictive :)

[20:48] <sorear> in Rakudo, any Iterable instance that isn't wrapped in a container is considered flattening

[20:49] <sorear> in Niecza, flattening is strictly opt-in and the type of the object is irrelevant

[20:49] *** necrophcoder left
[20:49] <sorear> now I _know_ my way is better :D

[20:50] <TimToady> well, at least for that example :)

[20:54] <sirrobert> what does "method !name ..." do?  (the exclamation point)

[20:54] <sirrobert> private method?

[20:54] <sorear> yes

[20:54] <sirrobert> thanks

[20:55] <japhb> sirrobert, you have to call it as $obj!foo rather than $obj.foo if you declare it with that leading !

[20:55] <sirrobert> makes sense

[20:55] <sirrobert> oh, you can call it from outside?

[20:55] <sirrobert> not just self!foo?

[20:56] <sirrobert> hey, so I haven't been able to get DBIish or miniDBI to install because of an error with "NativeCall"

[20:57] <sorear> sirrobert: private methods are implicitly namespaces by the class

[20:57] <sirrobert> sorear: ok 

[20:57] <sirrobert> I'm trying to work to a deadline at work; what's the best way to get some help with getting DBIish or miniDBI working?

[20:57] <sorear> $obj!foo means $obj!A::foo, where A is the statically enclosing class or GLOBAL if there is none

[20:58] <sorear> sirrobert: it sounds like your actual problem might be with NativeCall, so ping the NativeCall maintainer

[20:58] <sirrobert> sorear: ahh, that helps =)

[20:58] <sorear> jnthn: ping

[20:58] <sirrobert> good idea =)  found it on github just now

[20:59] <sorear> $obj!SomeOtherClass::method is syntactically valid but requires a 'trusts UsingClass' declaration in SomeOtherClass's body

[20:59] <jnthn> sirrobert: Are you using the NativeCall/DBIish from the last Star release or bleeding edge stuff from repos?

[21:00] *** cognominal__ left
[21:00] <sirrobert> hmm.  I don't know =)  "panda install DBIish" just failed

[21:00] <sirrobert> Also I tried "panda install NativeCall" which also failed

[21:00] <jnthn> OK, that'll be pulling the latest.

[21:00] <sirrobert> I can give you a bitbucket of the error if that helps

[21:00] <jnthn> Which, given arnsholt++ has been doing a load of work recently, means you probably need a very recent Rakudo/NQP too.

[21:00] <sirrobert> (I updated Rakudo to the latest, btw, and it still happened

[21:01] <sirrobert> Unrecognized nqp:: opcode 'nqp::nativecallrefresh' at line 274, near ";\n    1;\n}"

[21:01] <sirrobert> (that's the error)

[21:01] <sirrobert> woops... I'm driving the carpool today-- I'll ask again about it tomorrow.

[21:02] <sirrobert> thanks sorear and jnthn

[21:02] <jnthn> I think I see what may be up

[21:02] <sirrobert> I'll scroll back and read what you say in the morning =)  thanks

[21:02] <jnthn> The last NQP_REVISION update was Sat Aug 11

[21:02] <jnthn> oh...

[21:02] <jnthn> But hmm

[21:03] *** skids left
[21:03] <[Coke]> TimToady: any object to adding a "tools/testfile" to std that generates tap compliant output?

[21:03] <jnthn> yeah, it looks like the NQP_REVISION in Rakudo is up to date enough after all :S

[21:04] * jnthn is confused, then.

[21:04] <[Coke]> (then I can run "prove -r -e tools/testfile ../roast")

[21:05] <[Coke]> ... this is not going to be a clean run. :|

[21:07] *** cognominal joined
[21:08] <[Coke]> so, there's really no way to get a clean run of std against roast, is there?

[21:08] <[Coke]> since roast is explicitly testing broken things to make sure they're broken.

[21:14] *** perigrin left
[21:15] *** perigrin joined
[21:19] *** jeffreykegler joined
[21:21] <jeffreykegler> pmichaud: I found out about the "big car show" in Carmel that you'd wondered about

[21:22] <jeffreykegler> pmichaud: It's the operator precedence parse, not the LL one

[21:22] *** bruges_ left
[21:24] *** bruges joined
[21:29] <sorear> [Coke]: anything which is supposed to not compile should be wrapped in eval_dies_ok so that std will ignore it

[21:30] <sorear> std USED to run over the spectests fine,it even has a test script

[21:39] *** leprevost left
[21:39] *** cog joined
[21:39] *** cog left
[22:01] *** benabik left
[22:03] *** benabik joined
[22:03] <masak> 'night, #perl6

[22:06] *** MayDaniel left
[22:09] *** bluescreen10 left
[22:12] *** awwaiid left
[22:14] *** awwaiid joined
[22:15] *** bluescreen10 joined
[22:18] *** broquaint joined
[22:18] *** broquain1 left
[22:19] *** hanekomu joined
[22:23] *** bluescreen10 left
[22:24] <TimToady> well, it never really got above about 93% of the .t files parsing

[22:27] <[Coke]> TimToady: we

[22:27] <[Coke]> 'll fix that.

[22:27] <TimToady> though roughly half of the problems are really test problems

[22:28] <TimToady> Placeholder variable $^a may not be used here because the surrounding block takes no signature at /home/larry/perl6/roast/S32-list/sort.t line 147:

[22:30] <TimToady> Variable $.cool used where no 'self' is available at /home/larry/perl6/roast/S12-traits/parameterized.t line 19:

[22:30] <TimToady> Too late for semicolon form of class definition at /home/larry/perl6/roast/S12-attributes/undeclared.t line 16:

[22:30] <TimToady> things like that

[22:32] <TimToady> a lot of it is just missing library support

[22:32] <TimToady> or CORE not being entirely up-to-day

[22:33] <[Coke]> http://feather.perl6.nl/~coke/std.fails

[22:33] <[Coke]> (the end of a test run, because I had to rely on screen hardcopy to get it.)

[22:34] <[Coke]> let me rerun capturing the whole thing.

[22:35] *** thou left
[22:36] <[Coke]> there's "make snaptest", but it's not using prove.

[22:41] *** sergot left
[22:45] <[Coke]> if eval_dies_ok works in std, then we should be able to get it 100%. \o/

[22:46] <[Coke]> once I get the run, I'll invert the warnings so they're grouped by type, and folks can clean up the tests.

[22:46] <[Coke]> (or std, whichever.)

[22:59] *** thou joined
[23:01] *** alester left
[23:01] *** raiph joined
[23:08] <raiph> phenny: tell pmichaud the 5 appears on supervisor's tees which are yellow, not the tees for sale; if you are getting yellow tees for sale with a big 6 on them, i think u should let the organizers know asap

[23:08] <phenny> raiph: I'll pass that on when pmichaud is around.

[23:23] *** araujo left
[23:24] *** kst left
[23:24] *** araujo joined
[23:27] *** Coleoid joined
[23:29] *** ObseLeTe joined
[23:30] *** whiteknight joined
[23:30] *** whiteknight is now known as Guest44561

[23:30] *** kst joined
[23:33] *** thou left
[23:33] <[Coke]> http://feather.perl6.nl/~coke/std.fails updated with all the fails

[23:36] <dalek> roast: ff41d5c | coke++ | S02-lexical-conventions/comments.t:

[23:36] <dalek> roast: Fix typo found by std++

[23:36] <dalek> roast: review: https://github.com/perl6/roast/commit/ff41d5c130

[23:37] *** skids joined
[23:38] <[Coke]> std: my $var := LAZY { $was_in_lazy++; 42 };

[23:38] <p6eval> std 235f71b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $was_in_lazy is not predeclared at /tmp/Ls3i_Y_FfN line 1:␤------> [32mmy $var := LAZY { [33m⏏[31m$was_in_lazy++; 42 };[0m␤Undeclared name:␤    'LAZY' used at line 1␤Check failed␤FAILED 00:00 42m␤»

[23:40] <[Coke]> phenny: ask moritz : you added LAZY to S04-statements/lazy.t, but it's not spec, or recognized by std. Where's the bug?

[23:40] <phenny> [Coke]: I'll pass that on when moritz is around.

[23:41] *** PacoAir left
[23:48] <[Coke]> std; multi with_cap($a,$b,|$cap) { return with_cap($a + $b, |$cap) }

[23:48] <[Coke]> std: multi with_cap($a,$b,|$cap) { return with_cap($a + $b, |$cap) }

[23:48] <p6eval> std 235f71b: OUTPUT«Potential difficulties:␤  Unsupported use of | with sigil; nowadays please use | without sigil at /tmp/01L51Tx4vu line 1:␤------> [32mmulti with_cap($a,$b,|$cap[33m⏏[31m) { return with_cap($a + $b, |$cap) }[0m␤ok 00:00 45m␤»

[23:49] <[Coke]> std: multi with_cap($a,$b,|cap) { return with_cap($a + $b, |$cap) }

[23:49] <p6eval> std 235f71b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Variable $cap is not predeclared at /tmp/DF0rXtDj44 line 1:␤------> [32m$a,$b,|cap) { return with_cap($a + $b, |[33m⏏[31m$cap) }[0m␤Check failed␤FAILED 00:00 45m␤»

[23:49] <[Coke]> std: multi with_cap($a,$b,|cap) { return with_cap($a + $b, |cap) }

[23:49] <p6eval> std 235f71b: OUTPUT«ok 00:00 45m␤»

[23:49] <[Coke]> O_o

[23:49] <[Coke]> . o O (I don't know what |cap means.)

[23:50] <benabik> std: multi with_cap($a,$b,|cap) { return with_cap($a + $b, cap) }

[23:50] <p6eval> std 235f71b: OUTPUT«ok 00:00 45m␤»

[23:50] <benabik> Flatten the capture into the call?

[23:50] <[Coke]> benabik: there's a few tests in roast that have that and probably need updating.

[23:55] <[Coke]> std: mkdir("hi")

[23:55] <p6eval> std 235f71b: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared routine:␤ 'mkdir' used at line 1␤Check failed␤FAILED 00:00 41m␤»

[23:55] <[Coke]> looks like mkdir is no longer a function, per std and the spec, aye?

[23:58] <dalek> roast: 98e812a | coke++ | / (2 files):

[23:58] <dalek> roast: ucfirst is gone, wrap tc instead

[23:58] <dalek> roast: 

[23:58] <dalek> roast: std++

[23:58] <dalek> roast: review: https://github.com/perl6/roast/commit/98e812ac8f

[23:59] <sorear> jnthn: around by any chance?

