[00:13] *** pernatiy joined
[00:20] <cbk1090> tadzik, Thank you for your advise the other night regarding modules.  I looked at the Acme::Meow module and figured it out.  My example wasn't working due to the missing :: thingy I just had one word for the name of the class.

[00:20] <cbk1090> tadzik++

[00:21] <timotimo> exceptions and failure are bad, why not Maybe? :)

[00:22] *** cogno joined
[00:28] <shinobicl___> hi... how can i know if an object has some attribute?

[00:28] <shinobicl___> rakudo: my $var = Date.new('2011-11-11'); say $var.^attributes;

[00:28] <p6eval> rakudo 1a468d: OUTPUT«$!year $!month $!day $!daycount␤»

[00:29] <shinobicl___> rakudo: my $var = Date.new('2011-11-11'); say $var.^attributes; my $attrs = $var.^attributes;

[00:29] <p6eval> rakudo 1a468d: OUTPUT«$!year $!month $!day $!daycount␤»

[00:30] <shinobicl___> rakudo: my $var = Date.new('2011-11-11'); say $var.^attributes; my $attrs = $var.^attributes; say "ok" if '$!year' ~~ $attrs;

[00:30] <p6eval> rakudo 1a468d: OUTPUT«$!year $!month $!day $!daycount␤»

[00:32] <shinobicl___> rakudo: my $var = Date.new('2011-11-11'); say $var.^attributes; my $attrs = $var.^attributes; say "ok" if '$!year' eq any($attrs.list);

[00:32] <p6eval> rakudo 1a468d: OUTPUT«$!year $!month $!day $!daycount␤ok␤»

[00:32] <shinobicl___> well.. that wasn't hard :)

[00:32] *** cogno left
[00:35] *** localhost left
[00:36] *** localhost joined
[00:37] <shinobicl___> rakudo: class A { has $.dot }; my A $a .= new; say $a.^attributes.list;

[00:37] <p6eval> rakudo 1a468d: OUTPUT«$!dot␤»

[00:38] <shinobicl___> if i declared the attribute with a dot, why is shown as "$!dot"  ?

[00:39] <geekosaur> because $!foo is the actual attribute

[00:40] <geekosaur> $.foo is an accessor for the attribute

[00:40] <geekosaur> (think of it as perl automatically defining an accessor method for you)

[00:41] <sorear> timotimo: ultimately the problem is with the lifting.

[00:42] *** benabik joined
[00:42] <sorear> Maybe's structure as an applicative functor allows "stupid" operations like + to be lifted, but helps not at all with other stuff

[00:42] * timotimo has not done enough haskell to know how to understand that :\

[00:43] *** Vespakoen left
[00:45] *** Vespakoen joined
[00:52] <shinobicl___> geekosaur: then, is there a way to show it as "$.dot"?

[00:52] *** sporous left
[00:52] *** sporous joined
[00:52] <shinobicl___> not that i need to, is enough for me to see if it exists.

[00:55] <shinobicl___> i'm just curious to see if there an alternative to ^attributes. 

[00:58] *** Chillance left
[00:59] *** ponbiki joined
[01:00] *** envi_ joined
[01:03] *** lestrrat left
[01:05] *** lestrrat joined
[01:14] *** wolfman2000 joined
[01:15] *** scott_ joined
[01:16] *** scott_ is now known as Guest32079

[01:17] *** Vespakoen left
[01:19] *** envi_ left
[01:19] *** ponbiki left
[01:21] <geekosaur> shinobicl___, since it's an accessor, it should be in the methids

[01:21] <geekosaur> rakudo: class A { has $.dot }; my A $a .= new; say $a.^methods.list;

[01:21] <p6eval> rakudo 1a468d: OUTPUT«dot␤»

[01:21] *** ponbiki joined
[01:22] <geekosaur> ...but not with the dot, ok.  you probably should not expect to see the $.foo form

[01:22] <geekosaur> since it's kinda a macro

[01:24] *** havenn joined
[01:35] *** scott__ joined
[01:35] *** Guest32079 left
[01:42] <shinobicl___> thanks geekosaur

[01:42] <shinobicl___> good night all! and bye

[01:42] *** shinobicl___ left
[02:05] *** jaldhar joined
[02:12] *** whiteknight left
[02:25] *** lestrrat left
[02:26] *** explorer__ joined
[02:26] *** lestrrat joined
[02:26] *** jferrero left
[02:29] *** ponbiki left
[02:34] <colomon> continued fractions experiments now have handled basic addition, subtraction, multiplication, and division!

[02:39] *** leprevost joined
[02:48] <sorear> colomon: are you doing finite or infinite CFs?

[02:48] <colomon> finite so far

[02:48] <colomon> was just looking at HAKMEM to see if they had a decent CF to test

[02:48] <colomon> *infinite CF

[02:49] <colomon> sqrt 2 = 0; 2 2 2 2 2 2 2 2 2... ?

[02:50] <colomon> ah, 1; 2 2 2 2 2

[02:50] <colomon> duh

[02:53] <sorear> e is also pretty cool

[02:54] <colomon> ah, yes

[02:54] <sorear> one of the few non-contrived trancedental numbers with a "nice" representation as a normal CF

[02:55] <sorear> I'm a little bit concerned about the focus on normality though

[02:56] <colomon> eh?

[02:56] <sorear> because discontinuous functions of real numbers are non-computable in all the real number models I've seen

[02:56] <sorear> if you insist that the first term be equal to the floor of the number, then you're requiring discontinuity in the normalizer

[02:56] <colomon> ah

[02:57] <colomon> this is the sqrt(2) * sqrt(2) problem, more or less?

[02:57] <colomon> oooo, should add a first test for that

[02:57] <sorear> I haven't heard of that problem under that name

[02:58] <colomon> well, I just made up the name

[02:58] <sorear> but in general you can construct \sum_{i = 0}^\inf (turing machine M halts in i steps ? 1 : 0) * 2^{-i}

[02:59] <colomon> but the issue (as I understand it) is that you can never actually figure out the first digit of sqrt(2) * sqrt(2)

[02:59] <colomon> the floor, I mean.

[02:59] <sorear> in any real number system that supports infinite sums, finding the first digit of a number is equivalent to the halting problem

[02:59] <colomon> I've actually been pondering work arounds

[02:59] <sorear> the standard workaround is to allow a small amount of inaccuracy

[03:00] <sorear> you print the number to N digits, allowing the printed value to differ from the real value by up to 10^-N

[03:00] <sorear> so maybe 1.99999999, maybe 2.00000000

[03:00] <sorear> if you allow multivalueness, the undecidability goes away

[03:01] <colomon> each step makes the possible interval get smaller, eh?  hmm.

[03:02] <benabik> Multivalueness?

[03:02] <colomon> btw, sqrt(2) + 1/2 works to ten values

[03:03] <sorear> benabik: fuzzy_positive_negative(0, 1e-9) is allowed to return 1 or -1

[03:03] <sorear> benabik: and it does NOT respect logical identity on the reals

[03:05] *** am0c joined
[03:07] <colomon> n: say 1, 2, 2 ... *

[03:08] <p6eval> niecza v15-4-g1f35f89: OUTPUT«(timeout)»

[03:08] <colomon> n: say (1, 2, 2 ... *)[^10]

[03:08] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 2 2 2 2 2 2 2 2 2␤»

[03:14] *** fgomez left
[03:15] <colomon> n: say (2, 1, 2, 1, -> $a, $b, $c { 1, $b + 2, 1 } ... *)[^20]

[03:15] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Potential difficulties:␤  $a is declared but not used at /tmp/_e6T6t_RdL line 1:␤------> [32msay (2, 1, 2, 1, -> [33m⏏[31m$a, $b, $c { 1, $b + 2, 1 } ... *)[^20][0m␤  $c is declared but not used at /tmp/_e6T6t_RdL line 1:␤------> [32msay (2, 1, 2, 1, -…

[03:16] <colomon> n: say (2, 1, 2, 1, -> $, $b, $ { 1, $b + 2, 1 } ... *)[^20]

[03:16] <p6eval> niecza v15-4-g1f35f89: OUTPUT«2 1 2 1 1 4 1 1 3 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1 1 5 1␤»

[03:16] <colomon> r: say (2, 1, 2, 1, -> $, $b, $ { 1, $b + 2, 1 } ... *)[^20]

[03:16] <p6eval> rakudo 1a468d: OUTPUT«2 1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1 14 1 1 16 1 1 18 1 1 20 1 1 22 1 1 24 1 1 26 1 1 28 1 1 30 1 1 32 1 1 34 1␤»

[03:17] <colomon> n: say (2, (2, 4 ... *).map({ 1, $_, 1 }))[^10]

[03:17] <p6eval> niecza v15-4-g1f35f89: OUTPUT«(timeout)»

[03:18] <colomon> ?

[03:18] <colomon> n: say (2, 4 ... *).map({ 1, $_, 1 })[^10]

[03:18] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1 14 1 1 16 1 1 18 1 1 20 1␤»

[03:18] <colomon> n: say (2, 4 ... *).map({ 1, $_, 1 }).flat[^10]

[03:19] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 2 1 1 4 1 1 6 1 1␤»

[03:19] <colomon> n: say (2, 4 ... *).map({ 1, $_, 1 }).flat[^20]

[03:19] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1 2 1 1 4 1 1 6 1 1 8 1 1 10 1 1 12 1 1 14␤»

[03:22] *** aindilis left
[03:28] *** havenn left
[03:37] *** wooden joined
[03:37] *** wooden left
[03:37] *** wooden joined
[03:51] *** orafu left
[03:52] *** orafu joined
[04:16] *** araujo left
[04:23] *** Su-Shee_ joined
[04:27] *** Su-Shee left
[04:27] *** envi_ joined
[04:28] *** thou joined
[05:00] *** shinobicl___ joined
[05:11] <moritz> good morning

[05:12] <moritz> n: multi sub infix:<:::>($a, $b, $c) is assoc<list> { say "from $a to $b in steps of $c" }; 1 ::: 10 ::: 2

[05:12] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Rebuild in progress␤»

[05:12] <japhb> phenny, tell masak You mentioned earlier a new stretch goal for Perl 6 implementations.  Here's one that's near and dear to my heart: At least one Perl 6 implementation that is no more than 10x slower than Perl 5 at any task both can reasonably do.  (That last part is to allow for e.g. things that are easy in Perl 6 but an insane pain in Perl 5, or conversely handling some bit of native integration that Perl 6 implementations don't yet sup

[05:12] <phenny> japhb: I'll pass that on when masak is around.

[05:12] <japhb> port.)

[05:12] <moritz> n: multi sub infix:<:::>($a, $b, $c) is assoc<list> { say "from $a to $b in steps of $c" }; 1 ::: 10 ::: 2

[05:12] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Unhandled exception: Cannot call &infix:<:::>; none of these signatures match:␤    Any, Any, Any␤  at /tmp/54eQvURtLz line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3839 …

[05:13] <japhb> I guess that should be perl5, but I think the intent is clear ....

[05:14] *** skids left
[05:15] <shinobicl___> r: my %h; %h<a>=(b => 99); say %h.perl; say %h<a><b>'

[05:15] <p6eval> rakudo 1a468d: OUTPUT«===SORRY!===␤Confused␤at /tmp/STH5y3FgcF:1␤»

[05:15] <shinobicl___> r: my %h; %h<a>=(b => 99); say %h.perl; say %h<a><b>

[05:15] <p6eval> rakudo 1a468d: OUTPUT«("a" => "b" => 99).hash␤99␤»

[05:16] <shinobicl___> is there a faster way to create %h<a><b> ?

[05:16] <shinobicl___> i mean, shorter, not faster

[05:17] <moritz> r: my %h = a => b => 99; say %h.perl

[05:17] <p6eval> rakudo 1a468d: OUTPUT«("a" => "b" => 99).hash␤»

[05:17] <moritz> r: my %h = a => b => 99; say %h<a>.perl

[05:17] <sorear> japhb: hey, I just haved to bolt a fast parser to niecza

[05:17] <p6eval> rakudo 1a468d: OUTPUT«"b" => 99␤»

[05:17] <sorear> n: my %h; %h<a><b> = 99; say %h.perl

[05:17] <p6eval> niecza v15-4-g1f35f89: OUTPUT«{"a" => {"b" => 99}}.hash␤»

[05:17] <moritz> r: my %h = a => {b => 99}; say %h<a>.perl

[05:17] <p6eval> rakudo 1a468d: OUTPUT«{"b" => 99}␤»

[05:17] <sorear> n: my %h; %h{'a';'b'} = 99; say %h.perl

[05:17] <p6eval> niecza v15-4-g1f35f89: OUTPUT«{"a" => {"b" => 99}}.hash␤»

[05:18] <japhb> n: my %h; %h<a><b> = 99; say %h.perl;

[05:18] <p6eval> niecza v15-4-g1f35f89: OUTPUT«{"a" => {"b" => 99}}.hash␤»

[05:18] <japhb> It's just a Rakudo limitation, shinobicl___

[05:18] <sorear> r: my %h; %h<a><b> = 99; say %h.perl

[05:18] <p6eval> rakudo 1a468d: OUTPUT«Method 'at_key' not found for invocant of class 'Any'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1184␤  in block <anon> at /tmp/Mq2K58CP32:1␤␤»

[05:19] <japhb> sorear, seriously?  With a faster parser you'd be there?  You're even compiling grammars to be as fast as perl5 regexen?

[05:19] <shinobicl___> oh, ok

[05:20] *** araujo joined
[05:20] *** araujo left
[05:20] *** araujo joined
[05:20] <japhb> s/as fast as/nearly as fast as/

[05:22] *** leprevost left
[05:36] *** shinobicl___ left
[05:36] *** envi_ left
[05:53] *** NamelessTee joined
[06:02] <sorear> japhb: I haven't done comparative benchmarking for regexen; I suspect it will be slower there, especially for very simple regexes

[06:02] *** mdupont joined
[06:02] <moritz> most p6 regex engines are optimized for the grammar use case, not for regexes

[06:02] <sorear> exactly

[06:03] <sorear> generally speaking I find that basic niecza features (hashes, arithmetic) tend to peak at about 5-20x slower than perl5 after an optimization focus

[06:03] *** havenn joined
[06:04] <sorear> arrays are slower than you'd think because of laziness and perl 6's difficult-to-implement-well autoviv model

[06:04] <moritz> do you do compile time multi dispatch and such fun yet?

[06:04] <sorear> junctions, otoh, really suprised me with how fast they are

[06:04] <sorear> no

[06:06] <sorear> I kind of reneged on the optimization thing; niecza puts a lot of effort on being fast in the worst case

[06:06] <sorear> my least favorite features of Perl 6 are the ones that have to pay for whether you use them or not, like gather/take

[06:07] <sorear> s/that <()> have/you/

[06:07] *** kaleem joined
[06:20] *** birdwindupbird joined
[06:23] <moritz> std: / <( <( /

[06:23] <p6eval> std 1ad3292: OUTPUT«ok 00:01 109m␤»

[06:27] <sorear> maybe ought to warn, but certainly not fail

[06:27] <sorear> it's a dead store, $from = $/.pos ; $from = $/.pos ;

[06:27] *** thou left
[06:28] <sorear> I think we allow [ ab <( c | d <( ef ]

[06:28] <moritz> n: / <( /

[06:28] <p6eval> niecza v15-4-g1f35f89:  ( no output )

[06:29] <sorear> n: say ~( $_ ~~ / ab <( c | d <( ef /) for <abc def>

[06:29] <p6eval> niecza v15-4-g1f35f89: OUTPUT«c␤ef␤»

[06:32] <moritz> <( seems easy enough to do

[06:32] <moritz> not sure about )>

[06:33] <moritz> it seems it requires additional storage (a $!to in addition to $!pos)

[06:43] *** lestrrat left
[06:45] *** lestrrat joined
[06:50] *** mucker joined
[06:55] *** NamelessTee left
[06:58] <sorear> iirc in niecza <( and )> are implemented by pushing psuedo-captures

[07:19] *** birdwindupbird left
[07:33] *** Su-Shee_ is now known as Su-Shee

[07:34] *** birdwindupbird joined
[07:34] *** havenn left
[07:56] *** nebuchadnezzar joined
[08:16] *** fglock joined
[08:27] *** y3llow left
[08:27] *** bruges_ left
[08:27] *** y3llow joined
[08:27] *** bruges joined
[08:29] *** y3llow left
[08:29] *** y3llow joined
[08:31] *** y3llow left
[08:32] *** y3llow joined
[08:37] *** Vespakoen joined
[08:38] *** tarch joined
[08:43] *** xinming_ left
[08:46] *** odoacre_ joined
[08:46] *** odoacre_ left
[08:47] *** NamelessTee joined
[08:50] *** pernatiy left
[09:13] *** lestrrat left
[09:14] *** lestrrat joined
[09:22] <masak> morning, #perl6

[09:22] <phenny> masak: 05:12Z <japhb> tell masak You mentioned earlier a new stretch goal for Perl 6 implementations.  Here's one that's near and dear to my heart: At least one Perl 6 implementation that is no more than 10x slower than Perl 5 at any task both can reasonably do.  (That last part is to allow for e.g. things that are easy in Perl 6 but an insane pain in Perl 5, or conversely handling some bit of native integration that Perl 6 implementations don't yet sup

[09:22] * masak backlogs to get the rest :)

[09:23] <masak> geekosaur: $.foo is not a macro :)

[09:23] <moritz> \o masak

[09:23] <tadzik> hello #perl6

[09:23] <masak> tadzik: sup, tadziku.

[09:24] *** preflex left
[09:25] *** Vespakoen left
[09:25] *** preflex_ joined
[09:25] *** Vespakoen joined
[09:25] *** preflex_ is now known as preflex

[09:28] <tadzik> not bad, dayjobbing atm. How about you?

[09:31] <masak> also dayjobbing :)

[09:32] <masak> and also not bad.

[09:37] *** daxim joined
[09:47] *** dwierenga left
[09:49] *** dwierenga joined
[09:52] *** envi_ joined
[10:03] *** sftp left
[10:03] *** sftp joined
[10:17] *** scott__ left
[10:18] *** mtk left
[10:25] * [Coke] yawns

[10:26] <masak> good [morning], Coke.

[10:27] <tadzik> hello [Coke] 

[10:27] <tadzik> [Coke] yawns? Coke is supposed to be caffeinated...

[10:32] <[Coke]> sick.jetlagged

[10:33] <moritz> :(

[10:33] <moritz> [Coke]: get well soon!

[10:39] *** kaleem left
[10:40] *** kaleem joined
[10:40] <masak> that explains why you're up at this hour.

[10:42] *** benabik left
[10:45] * [Coke] is in leeds. been up for 4-5 hours

[10:51] * moritz recommends reading the commit messages on https://github.com/diiq/Tainted-Oyster/commits/master?page=4 in chronologic order

[10:59] <arnsholt> That's... odd =)

[10:59] <au> quite Poe-tic, though.

[11:00] <masak> I read the first few. can't determine whether I find them amusing or disturbing.

[11:02] <tadzik> oh joy :)

[11:02] <masak> no, I've decided I like it. :)

[11:02] <masak> the project description is "I feel an indescribable ecstasy and delirium in melting; (what salutes of cannon and small arms!)"

[11:04] <masak> reminds me of the book dedication in "Patterns of the Hypnotic Techniques of Milton H. Erickson": (loosely, from memory) "this book is dedicated to: a little snow in summer -- and Mazda, the car for people who can hear"

[11:08] <felher> What would i use instead of NULL in Perl6, if i have a typed variable (my Str $x)?

[11:08] <felher> $x = Str?

[11:09] <felher> (to tell it is undefined)

[11:10] <masak> take a step back. what problem are you trying to solve?

[11:11] <felher> Tell that some container doesn't point to a value. Like NULL in C/C++, null in Java.

[11:12] <masak> take more steps back. what programming task was it that led you to the thought of undefined/NULL/null values?

[11:13] <felher> Some kind of linked list, to mark its end. (And i didn't want to create a special end-class/object)

[11:13] <masak> ah.

[11:13] <masak> then yes, a type object like Str will do just fine.

[11:14] <felher> \o/ :)

[11:14] <felher> masak: thnx :)

[11:14] <masak> 'undef' in Perl 5 corresponds to type objects in Perl 6.

[11:14] <masak> one for each type.

[11:17] <masak> if you're in a situation where you don't know how the container is typed, and you want to assign that container's type object to it, you can assign nil.

[11:17] *** Vespakoen left
[11:17] <masak> p6: my Str $s = "OH HAI"; $s = Nil; say $s

[11:17] <p6eval> rakudo 1a468d: OUTPUT«Type check failed in assignment to '$s'; expected 'Str' but got 'Nil'␤  in block <anon> at /tmp/2EWyRnXHAg:1␤␤»

[11:17] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&Nil"␤    at /tmp/KGM8yvs_gn line 1, column 23-31␤»

[11:17] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Str()␤»

[11:18] * masak submits rakudobug

[11:19] <au> p6: my Str $x; VAR($x).WHAT

[11:19] <felher> masak++ #bug-report-bot <- this should be 53 time, right? :)

[11:19] <p6eval> rakudo 1a468d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&VAR' called (line 1)␤»

[11:19] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared name:␤ 'VAR' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1362 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /home/p6e…

[11:19] <p6eval> ..pugs:  ( no output )

[11:19] <au> p6: my Str $x; $x.VAR.WHAT.say

[11:19] <p6eval> rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«Scalar()␤»

[11:19] <p6eval> ..pugs: OUTPUT«Str␤»

[11:24] <masak> japhb: yes. stretch goal. we need it. we need to declare a goal, and then work towards it, with statistics and real-world use cases and stuff.

[11:24] <masak> something ridiculously quantifiable.

[11:30] <felher> perl6: my Str sub a() { return "xxx" }; a().WHAT.say

[11:30] *** pmurias joined
[11:30] <p6eval> niecza v15-4-g1f35f89: OUTPUT«Unhandled exception: Cannot unbox a String from an object of repr P6opaque␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (Str.say @ 1) ␤  at /tmp/ZjiQsJstBO line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3838 (ANON @ 3) ␤  at /home…

[11:30] <p6eval> ..pugs: OUTPUT«Str␤»

[11:30] <p6eval> ..rakudo 1a468d: OUTPUT«Str()␤»

[11:30] <pmurias> fglock: hi

[11:31] <pmurias> fglock: i'm trying to add support for multiple heredocs in one line

[11:31] <felher> perl6: my Str sub a() { return 777 }; a().WHAT.say

[11:31] <p6eval> pugs: OUTPUT«Int␤»

[11:31] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«Int()␤»

[11:31] <pmurias> fglock: but the assigment for the first placeholder seems to have no effect

[11:31] <pmurias> fglock: do we clone the ast somewhere?

[11:32] <felher> Specifying return value of a function is NYI?

[11:33] *** havenn joined
[11:33] <masak> I'm not sure that's how you'd do it.

[11:34] <pmurias> perl6: $a=55;say $a ~~ Int;

[11:34] <masak> maybe it is, and my memory is fuzzy.

[11:34] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "="␤    expecting "::"␤    Variable "$a" requires predeclaration or explicit package name␤    at /tmp/HIE36lVzlP line 1, column 3␤»

[11:34] <p6eval> ..rakudo 1a468d: OUTPUT«===SORRY!===␤Variable $a is not declared␤at /tmp/lHUzzdOpBB:1␤»

[11:34] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Variable $a is not predeclared at /tmp/pjH_GMAupu line 1:␤------> [32m<BOL>[33m⏏[31m$a=55;say $a ~~ Int;[0m␤␤Variable $a is not predeclared at /tmp/pjH_GMAupu line 1:␤------> [32m$a=55;say [33m⏏[31m$a ~~ Int;[0m␤␤Unha…

[11:34] <pmurias> perl6: my $a=55;say $a ~~ Int;

[11:34] <p6eval> pugs: OUTPUT«1␤»

[11:34] <p6eval> ..rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«True␤»

[11:36] <felher> masak: i think it is (S06-routines.pod:265)

[11:42] *** benabik joined
[11:43] *** envi_ left
[11:44] *** odoacre left
[11:44] *** havenn left
[11:45] <felher> But what i really wanted to ask is: Will there be/is there a way to specify "this routine doesn't return anything", like 'void'?

[11:50] <pmurias> std: sub foo($a -->) {...}

[11:51] <p6eval> std 1ad3292: OUTPUT«[31m===[0mSORRY![31m===[0m␤No type found after --> at /tmp/IXwS9NQJuP line 1:␤------> [32msub foo($a -->[33m⏏[31m) {...}[0m␤    expecting any of:␤  constraint␤     name␤   param_sep␤      trait␤  type_constraint␤Parse failed␤FAILED 00:01 110m␤»

[11:57] <benabik> Is it possible to not return anything?  At best I think you can return Nil.

[12:05] <masak> all functions return something, even if it's implicit.

[12:06] <masak> if you want to make sure it doesn't return anything informative, it seems your best bet is to make it return Nil.

[12:06] <felher> I know that they at least return their last expression.

[12:08] <felher> But wouldn't it be nice to be able to specify something like that?

[12:09] <benabik> r: sub foo() {}; foo().perl.say

[12:09] <p6eval> rakudo 1a468d: OUTPUT«Nil␤»

[12:10] <felher> I see your point in returning Nil. But i don't think it is the same as if the signature of a sub already tells that it won't return anything.

[12:11] <flussence> p6: sub foo(--> Nil) { }

[12:11] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "-->"␤    expecting formal parameter or ")"␤    at /tmp/UjLPPZH8Kq line 1, column 9␤»

[12:11] <p6eval> ..rakudo 1a468d:  ( no output )

[12:11] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«Potential difficulties:␤  &foo is declared but not used at /tmp/KASsvr9B9d line 1:␤------> [32msub foo[33m⏏[31m(--> Nil) { }[0m␤␤»

[12:12] *** dakkar joined
[12:12] <flussence> r: sub foo(--> Nil) { return 'something' }; say foo.perl

[12:12] <p6eval> rakudo 1a468d: OUTPUT«"something"␤»

[12:12] <flussence> hm, that's not right.

[12:13] <flussence> r: sub foo returns Nil { return 'something' }; say foo.perl

[12:13] <p6eval> rakudo 1a468d: OUTPUT«Type check failed for return value␤  in sub foo at /tmp/YmTUo4a8Q8:1␤  in block <anon> at /tmp/YmTUo4a8Q8:1␤␤»

[12:13] <flussence> there you go

[12:14] <felher> flussence: ah, nice. I thought Nil is something like Mu.

[12:14] <fglock> pmurias: multiple heredocs were supported, I might have broken it (we don't clone the ast)

[12:14] * felher really has to read what Nil is again :(

[12:15] <pmurias> fglock: i'll recheck if the hack is nessary then

[12:15] <benabik> r: say Nil.WHAT

[12:15] <p6eval> rakudo 1a468d: OUTPUT«Nil␤»

[12:15] <fglock> looking here too

[12:17] <fglock> as long as there is something in the @Here_doc stack, there can be several in the same line

[12:17] <pmurias> they are parsed

[12:18] <pmurias> but something wrong happens when they are filled in

[12:18] <masak> felher: Nil is not just "empty list", but "there isn't anything here". it's an undefined ().

[12:18] <fglock> maybe the newline is being missed for some reason

[12:18] <masak> felher: it's like Nil represents the absence not only of elements, but of a list to contain them as well.

[12:18] <benabik> r: ().WHAT.say

[12:18] <p6eval> rakudo 1a468d: OUTPUT«Parcel()␤»

[12:18] <pmurias> fglock: look at the commit with the hack

[12:18] <fglock> ok

[12:18] <benabik> r: say () ~~ Nil

[12:18] <p6eval> rakudo 1a468d: OUTPUT«False␤»

[12:18] <pmurias> fglock: if you turn placeholder2 into placeholder they break

[12:20] <pmurias> fglock: they placeholder gets filled in but the ast seems to contain it's copy

[12:20] <flussence> masak: and if I understand right, Mu means "nothing here yet" and Any means "this space intentionally left blank"? :)

[12:20] <felher> masak: I see. So Nil and void really express the same thing. :) Awesome :)

[12:20] <pmurias> fglock: with 3 heredocs only the first one is affected

[12:21] <benabik> If you're used to functional programming, P6's Nil is what most FP calls Uni.

[12:21] <benabik> *Unit

[12:23] <fglock> I think I see a fencepost error in the double_quote section, maybe $m->{to} advanced 1 extra char

[12:23] <fglock> testing

[12:24] <masak> flussence: Any, to me, just means "default default", i.e. "this is the undefined value you get when you didn't specify a type".

[12:25] <masak> felher: there are always irreconcilable differences in nuance across languages. but yes, sorta.

[12:26] <masak> flussence: also, Mu, to me, means "outside-of-normal-type-hierarchy trickery going on! probably something involving junctions. here be dragons."

[12:27] <fglock> pmurias: it seems to work, can you check?

[12:27] <fglock> (pushed)

[12:31] <fglock> test 20 pass; now looking at test 19

[12:32] *** pernatiy joined
[12:34] <fglock> this is hard :P

[12:34] <fglock> now it has an extra newline

[12:39] <masak> flussence: s/involving junctions/involving junctions or metaclasses/

[12:39] *** snearch joined
[12:41] *** JimmyZ joined
[12:43] <pmurias> fglock: any ideas why we need placeholder2?

[12:46] <fglock> I don't think we need it anymore, my fix seems to work with or without the hack - not sure why it worked in the first place

[12:49] *** pernatiy left
[12:50] *** shinobicl joined
[12:52] <fglock> aha, I think I found the second problem (extra newline)

[12:53] <pmurias> fglock: your fix doesn't seem to make ok 12 appear

[12:54] <fglock> ah, right - looking

[12:54] <pmurias> fglock: the placeholder filling sub is called without the hack, but it's effect seems to disapper

[12:57] *** tokuhiro_ joined
[13:00] *** mucker left
[13:00] *** shinobicl left
[13:01] *** am0c left
[13:01] <moritz> http://lwn.net/Articles/485569/ # perl 5 release process, explained by Dave Rolsky. Also briefly mentions Perl 6

[13:02] <masak> oh, right. he solicited feedback on that article here a while ago.

[13:03] <fglock> pmurias: I'll test & commit my fixes, then look at test 12 (passes all until 20 now)

[13:05] <pmurias> fglock: ok

[13:06] *** simcop2387 left
[13:06] <pmurias> fglock: do you pass test 5?

[13:07] <fglock> actually no - I didn't notice

[13:08] *** pernatiy joined
[13:09] <masak> TimToady: why does sink return () and not Nil?

[13:09] <moritz> masak: the plan is to make Nil more Failure-like

[13:09] <moritz> masak: so returning Nil would make sinking a sink die, or something

[13:10] <pmurias> fglock: i'm fixing that

[13:10] *** simcop2387 joined
[13:11] <masak> I agree with the need to simplify/unify failure types, but I'm not sold on TimToady++'s first attempt at it.

[13:12] <masak> short story, angels don't sing when I read about the proposed changes.

[13:14] * moritz feels much the same

[13:14] *** shinobicl joined
[13:18] <masak> they're big enough to be uprooting/destructive to various things, but I don't see the immediate benefit they would give, other than making Perl 6 typology... stranger and less mainstream.

[13:20] <benabik> Failure is already outside the "mainstream" of language design by design.  I know of no other language that lets you handle exceptions as normal data, but then throws it if you try to use it.

[13:22] <pmurias> benabik: it feels like the extensions of letting you handle the error value as normal data and the segfaulting it you try to ;)

[13:23] <benabik> pmurias: That's not a bad description of it, although it's somewhat "nicer" than a segfault.

[13:23] <masak> benabik: I do not buy the argument that because Perl 6 is 'already outside the "mainstream"', that it should amble further outside it for no particular good reason.

[13:24] <benabik> masak: The feature in question is already outside the norms, so putting it outside the "normal" of Any makes sense.

[13:25] <masak> aye. that part makes some sense to me.

[13:25] <masak> but TimToady's proposal is on a grander scale than that.

[13:25] <masak> here it is, for reference: https://gist.github.com/1828667

[13:26] <benabik> Hm. I would disagree that Failure and Nil are the same thing.  Nil is no information, Failure is "something bad happened"

[13:26] *** skids joined
[13:27] <moritz> Nil is more like fail('Nothing to see here, move along')

[13:28] <benabik> I suppose.  Then () would be how you spell unit again, I suppose.

[13:28] <masak> there are some things in there that I buy outright. making fail/succeed a semantically matched pair makes me happy. I don't know if wiring things up so that fail still works in subs and succeed still works in whens would be trivial.

[13:28] <pmurias> benabik: Perl6 is supposed to be much "nicer" than C

[13:28] <masak> and then there's the question of what proceed does in a sub :)

[13:29] <benabik> pmurias: Everything is supposed to be nicer than C.  The only thing less nice than C is assembler.  ;-)

[13:29] <shinobicl> hi... another newbie question... What is "the gist"... and what is the .gist method for?

[13:30] <moritz> shinobicl: &say calls .gist. .gist is supposed to return a human-readable summary of an object

[13:30] <masak> benabik: not true. I discovered a language yesterday called ABAP, which is decidedly not nicer than C. it looks like someone wanted really dearly to reinvent COBOL.

[13:30] <masak> shinobicl: "gist" in English means "a summary". github has a paste service (tied to git repositories) called gist.github.com

[13:31] <benabik> masak: Okay, most things are supposed to be nicer than C.  Some things try to be as nice as C.  And some things just fail.

[13:31] <shinobicl> oh, thanks!.. I thought it was an acronym.

[13:31] <benabik> masak: C occupies the "one step above assembler" level in my head.  :-)

[13:32] <masak> according to dictionary.com: [C18: from Anglo-French, as in cest action gist en  this action consists in, literally: lies in, from Old French gésir  to lie, from Latin jacēre,  from jacere  to throw]

[13:38] * masak .oO( the die is gist )

[13:38] <masak> phenny: eo en "gisto"?

[13:38] <phenny> masak: "gisto" (eo to en, translate.google.com)

[13:39] <masak> apparently not a common word in the corpora. means "yeast".

[13:39] <moritz> phenny: "hefe"?

[13:39] <phenny> moritz: "yeast" (de to en, translate.google.com)

[13:41] <masak> phenny: "Mia kusenveturilo estas plena de angiloj."?

[13:41] <phenny> masak: "My kusenveturilo is full of eels ." (eo to en, translate.google.com)

[13:41] <masak> almost :)

[13:42] <moritz> phenny: "Mein Luftkissenboot ist voller Aale"?

[13:42] <phenny> moritz: "My hovercraft is full of eels" (de to en, translate.google.com)

[13:42] <[Coke]> moritz++

[13:42] <masak> phenny: "Min svävare är full av ålar."?

[13:42] <phenny> masak: "My hovercraft is full of eels." (sv to en, translate.google.com)

[13:42] <moritz> phenny: "svä"?

[13:42] <phenny> moritz: "sulfur" (sv to en, translate.google.com)

[13:42] <moritz> phenny: "vare"?

[13:42] <phenny> moritz: "either" (sv to en, translate.google.com)

[13:42] <moritz> erm

[13:42] <[Coke]> phenny: "Моят кораб на въздушна възглавница е пълен на змиорки

[13:42] <[Coke]> phenny: "Моят кораб на въздушна възглавница е пълен на змиорки"?

[13:42] <phenny> [Coke]: "My hovercraft is full of eels" (bg to en, translate.google.com)

[13:43] <arnsholt> moritz: From the verb meaning to float. svever would be the norwegian variant

[13:43] <moritz> phenny: "sväv"?

[13:43] <phenny> moritz: "fluidised" (sv to en, translate.google.com)

[13:43] <moritz> phenny: "are"?

[13:43] <phenny> moritz: "are" (en to en, translate.google.com)

[13:43] <moritz> phenny: se en "are"?

[13:43] <phenny> moritz: "are" (en to en, translate.google.com)

[13:43] <moritz> phenny: sv en "are"?

[13:43] <phenny> moritz: "are" (sv to en, translate.google.com)

[13:43] <arnsholt> It's a floater =D

[13:43] <moritz> "Luftkissenboot" is "air cushion boat" :-)

[13:43] <masak> moritz: sv:"att sväva" == en:"to hover"

[13:44] <arnsholt> Yeah, it's luftputebåt in Norwegian too

[13:44] <arnsholt> Apparently it's just the Swedes being weird again ;)

[13:44] <masak> moritz: then it's closer to eo's kusen-vetur-ilo -- cushion-travel-tool.

[13:44] <moritz> that sounds cute :-)

[13:45] * moritz likes weird people and languages

[13:45] <masak> phenny: en is "hovercraft"?

[13:45] <phenny> masak: "Láttu" (en to is, translate.google.com)

[13:45] <masak> arnsholt: we have Icelandic on our side!

[13:45] <masak> what do you say now? huh, huh? :P

[13:45] <arnsholt> Icelandic doesn't have voiced plosives. I don't trust 'em ;p

[13:46] <masak> some of my best friends are weird people and use weird languages.

[13:46] <arnsholt> OTOH, I'm no stranger to weird languages =D

[13:50] <benabik> Hm.  OKness feels like an attempt to promote the concept of boolean into the type system.

[13:52] <geekosaur> re $.foo, it's not a macro but it has some vaguely macro-like qualities.  (really more meta than macro I suppose though)

[13:52] <moritz> what macro-like qualities?

[13:53] <masak> it's a form that the parser recognizes and serializes into some target code. nothing more.

[13:53] <moritz> well, that's true for every piece of Perl 6 code :-)

[13:54] <masak> yes!

[13:54] <masak> if what's macro-like about it is "it's sugar for something else", then a lot of things that don't even remotely involve macros are macro-like.

[13:54] <moritz> well, and then we'd need a new word for macros :-)

[13:58] <fglock> pmurias: I've simplified the code, but I've kept your hack - I can't find the problem

[14:00] <geekosaur> that is sort of where I was trying tog owith "more meta than macro" --- but yes, I would in fact claim a lot of P6 is sugar, which to my mind is macro nature.  macros the language feature is just exposing the mechanisms thereof to the user in a hopefully hygienic fashion

[14:01] <pmurias> fglock: Object::Dies claims that the arguments list was accessed by the precedence parser

[14:04] <moritz> geekosaur: then let me tell you that most people around here have a quite different understanding of the nature of macros

[14:04] <moritz> geekosaur: we mostly consider constructs macro-ish that delay evaluating their arguments, for example

[14:04] <moritz> like infix:<&&>, which only evaluates the RHS if the LHS is True

[14:07] <fglock> pmurias: it is probably trying to optimize - maybe trying to join 2 "list<.>" together

[14:08] <fglock> not a big problem, the workaround works fine

[14:14] <pmurias> that's the source of the problem: src5/lib/Perlito5/Expression.pm:291

[14:18] *** jaldhar left
[14:24] *** snearch left
[14:29] *** mtk joined
[14:29] *** mtk left
[14:29] *** mtk joined
[14:40] <moritz> update on the evalbot status:

[14:40] <moritz> I have now set up all the depenencies for running evalbot itself on feather3

[14:41] <moritz> and I've built rakudo, b and niecza on feather1, and I'm now investigating how to best rsync them to feather3

[14:41] <moritz> if you want to help, compile more compilers under the 'p6eval' user on feather1

[14:44] <flussence> would be useful if that rakudo could be used by tryrakudo too, it'd save me having to update that all the time :)

[14:46] *** wolfman2000 left
[14:46] <moritz> ah, currently it doesn't work (missing libgmp3-dev)

[14:47] <fglock> moritz: can you install node.js in feather1?

[14:47] <moritz> flussence: but once it works, feel free to use ~p6eval/nom-inst/bin/perl6

[14:48] <flussence> \o/

[14:52] *** Araq joined
[14:56] *** benabik left
[15:00] *** benabik joined
[15:00] *** lumi__ left
[15:01] *** lumi_ joined
[15:03] *** havenn joined
[15:07] *** stepnem joined
[15:07] *** PacoAir joined
[15:08] *** araujo left
[15:09] *** benabik left
[15:11] *** lumi_ left
[15:11] *** benabik joined
[15:13] *** araujo joined
[15:13] *** araujo left
[15:13] *** araujo joined
[15:13] *** araujo left
[15:22] *** birdwindupbird left
[15:25] *** araujo joined
[15:32] *** benabik left
[15:34] *** benabik joined
[15:37] <moritz> flussence: works now

[15:38] <moritz> (after installing several shared libraries, after I fixed apt-file, added a gpg key to aptitude and other nice stuff)

[15:39] *** thou joined
[15:41] <flussence> I'll see if I can get tryrakudo working again once I get out of $dayjob later :)

[15:46] *** Psyche^ joined
[15:51] *** Patterner left
[15:51] *** Psyche^ is now known as Patterner

[15:55] *** JimmyZ left
[15:55] *** kaleem left
[15:56] *** tokuhiro_ left
[15:57] *** tokuhiro_ joined
[16:01] *** tokuhiro_ left
[16:03] *** Araq left
[16:17] *** havenn left
[16:19] <fglock> blogged: http://blogs.perl.org/users/flavio_s_glock/2012/03/perl5-in-the-browser-update.html

[16:20] <moritz> fglock: nodejs installed on feather1

[16:21] <fglock> moritz++ thanks!

[16:21] <moritz> fglock++ # perlito hacking

[16:27] <fglock> moritz: I can't find node, where is it installed? I'm logged in at "This is feather1.perl6.nl (ONE)"

[16:28] <moritz> fglock: oh sorry, installation failed, but I didn't notice it in a flurry of warning messages

[16:29] <moritz> fglock: try again please

[16:29] <fglock> yay - works

[16:29] <moritz> \o/

[16:35] *** snearch joined
[16:40] *** Mayya joined
[16:40] <moritz> r: sub f { @_.join }; say f 1, 2, 3

[16:40] <p6eval> rakudo 1a468d: OUTPUT«123␤»

[16:41] *** Mayya left
[16:42] <moritz> p6: sub f { @_.join }; say f 1, 2, 3

[16:42] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«123␤»

[16:44] *** fglock left
[16:46] *** snearch left
[16:48] <masak> moritz++ # the future is already here

[16:48] <moritz> p6: sub f(*@a) { say @a.elems }; f [1, 2, 3]

[16:48] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«1␤»

[16:48] <moritz> p6: sub f(*@a) { say @a.elems }; f |[1, 2, 3]

[16:48] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«3␤»

[16:50] <moritz> ok, I know why slurpies and sequences don't mix

[16:50] <moritz> slurpies aren't reflected in .count and .signature

[16:50] <moritz> erm, .arity

[16:51] <masak> oh!

[16:51] <masak> only positionals are?

[16:51] <moritz> r: sub a(*@a) { }; say &a.count, ' ', &a.arity

[16:51] <p6eval> rakudo 1a468d: OUTPUT«0 0␤»

[16:52] <masak> there you go.

[16:52] <masak> that makes sense.

[16:52] <moritz> last time I tried to fix it, it failed because I had it retur Inf

[16:52] <moritz> which isn't an Int

[16:52] <moritz> which set up some other code in the setting

[16:53] <masak> brrrlgh. can't we rename .count and .arity to .mincount and .maxcount instead? :) I'll never learn which is which!

[16:53] <moritz> +0.1

[16:53] <moritz> .count and .arity are really the wrong approach nearly always

[16:53] *** sisar joined
[16:53] <masak> I probably got it wrong just now. point is, I just have no idea.

[16:53] <shinobicl> r: my %h; %h<a> = 99; my %g; %g<c> = 100; %h<a> = %g<c>; say %h.perl;

[16:53] <p6eval> rakudo 1a468d: OUTPUT«("a" => 100).hash␤»

[16:54] <shinobicl> rakudo: my %h; %h<a> = 99; my %g; %g<c> = 100; %h<a> = %g<c>; say %h.perl;

[16:54] <p6eval> rakudo 1a468d: OUTPUT«("a" => 100).hash␤»

[16:54] <sisar> o/

[16:54] <masak> sisar! \o/

[16:55] <sisar> masak, re your fascination with grammars, have you had the chance to study Sanskrit ?

[16:55] <shinobicl> rakudo: my %h; %h<a> = 99; my %g; %g<c> = 100; %h<a> = %g; say %h.perl; say %h<a><c>

[16:55] <p6eval> rakudo 1a468d: OUTPUT«("a" => {"c" => 100}).hash␤100␤»

[16:55] <sisar> its grammar is amazing too

[16:57] <masak> sisar: no, I haven't gotten there yet. I have a "Teach Yourself" book, and I've talked to people who've studied it.

[16:58] <masak> I want to get there at some point. it does seem amazing.

[17:00] * masak decommutes

[17:00] *** alvis joined
[17:00] <sisar> masak, Sanskrit's grammar is very strict and complicated, which scares most people away, but is actually very interesting. Unfortunately, i belong to the scared-away group.

[17:04] *** kaare_ joined
[17:08] *** tarch left
[17:11] <sisar> what is the state of 'proto' ? is it used anywhere ?

[17:11] <moritz> the module installer? it's superseeded by 'panda'

[17:12] <moritz> nom: given (sub a(|$a) { }).signature.params[0] { say .capture; say .parcel }

[17:12] <p6eval> rakudo 1a468d: OUTPUT«True␤False␤»

[17:15] <moritz> hah, if I fix slurpy sequences, I fail a spectest

[17:15] <moritz> because there's one that uess &prefix:<!> as generator

[17:15] <moritz> ... which has a (|$) prototype

[17:16] <moritz> which is, like, slurpy

[17:16] <moritz> so I pass 2 arguments to prefix:<!>, because the proto lied

[17:18] *** mj41 joined
[17:19] *** fglock joined
[17:24] <dalek> rakudo/slurpy-sequence: 0604d1b | moritz++ | src/core/ (3 files):

[17:24] <dalek> rakudo/slurpy-sequence: bring back sequences with slurpy generators

[17:24] <dalek> rakudo/slurpy-sequence: review: https://github.com/rakudo/rakudo/commit/0604d1bf00

[17:25] *** dakkar left
[17:29] *** havenn joined
[17:37] *** pernatiy left
[17:50] <pmichaud> shouldn't need the $is-slurpy thingy in patch 0604d1bf  (re-adding slurpy generators)

[17:51] <pmichaud> $count should be Inf in that case.

[17:52] <pmichaud> for that matter, shouldn't need the "slurpy" method either.  I thought we already had a way to detect that, too.

[17:54] *** havenn left
[17:54] <pmichaud> looks like we don't.  That's likely a nom regression, unless the spec has changed

[17:57] <pmichaud> (regression:  &foo.count should be Inf if it has slurpy args)

[18:04] <moritz> pmichaud: I've tried to change that, but some other code tried to unbox_i the return value from .count

[18:04] <moritz> pmichaud: and I didn't know how to fix that

[18:05] <pmichaud> okay, I can look at it a bit.

[18:05] <pmichaud> b:  sub foo(*@a) { 1 };  say &foo.count;  # checking

[18:05] <p6eval> b 1b7dd1: OUTPUT«Inf␤»

[18:06] *** mucker joined
[18:07] <shinobicl> rakudo: my %h; for (1 .. 3) -> $n { for ('A' .. 'C') -> $c { my %tmp; %tmp{$c} = 'X'; %h{$n} = %tmp}  }; say %h.perl;

[18:07] <p6eval> rakudo 1a468d: OUTPUT«("1" => {"C" => "X"}, "2" => {"C" => "X"}, "3" => {"C" => "X"}).hash␤»

[18:08] *** mj41 left
[18:08] <shinobicl> I need to have "1" => { {"A" => "X"}, {"B" => "X"}, {"C" => "X"}} .....

[18:08] <shinobicl> how should i do it?

[18:11] <pmichaud> rakudo: $h{$_} = {{ A => 'X'}, {B => 'X'}, {C => 'X'}} for 1..3;   say %h.perl

[18:11] <p6eval> rakudo 1a468d: OUTPUT«===SORRY!===␤Variable $h is not declared␤at /tmp/C5zGO6Wlvy:1␤»

[18:11] <pmichaud> rakudo: my %h; %h{$_} = {{ A => 'X'}, {B => 'X'}, {C => 'X'}} for 1..3;   say %h.perl

[18:11] <p6eval> rakudo 1a468d: OUTPUT«("1" => Block.new(), "2" => Block.new(), "3" => Block.new()).hash␤»

[18:11] <pmichaud> grrrrrrr

[18:12] <pmichaud> rakudo: my %h; %h{$_} = {{ A => 'X';}, {B => 'X';}, {C => 'X';}} for 1..3;   say %h.perl

[18:12] <p6eval> rakudo 1a468d: OUTPUT«("1" => Block.new(), "2" => Block.new(), "3" => Block.new()).hash␤»

[18:13] <moritz> shinobicl: either you need a list on the second level, or hash keys

[18:13] <pmichaud> rakudo: my %h; %h{$_} = (hash 'A', 'X', 'B', 'X', 'C', 'X') for 1..3;   say %h.perl

[18:13] <p6eval> rakudo 1a468d: OUTPUT«("1" => {"A" => "X", "B" => "X", "C" => "X"}, "2" => {"A" => "X", "B" => "X", "C" => "X"}, "3" => {"A" => "X", "B" => "X", "C" => "X"}).hash␤»

[18:14] <pmichaud> say (<A B C> X <X>).perl

[18:14] <pmichaud> rakudo: say (<A B C> X <X>).perl

[18:14] <p6eval> rakudo 1a468d: OUTPUT«((ListIter.new(),), (ListIter.new(),), (ListIter.new(),)).list␤»

[18:14] <pmichaud> rakudo: say (<A B C> X <X>)

[18:14] <p6eval> rakudo 1a468d: OUTPUT«A X B X C X␤»

[18:14] <pmichaud> rakudo: say (<A B C> X <X>).hash.perl

[18:15] <p6eval> rakudo 1a468d: OUTPUT«("A" => "X", "B" => "X", "C" => "X").hash␤»

[18:15] <moritz> rakudo: say (<A B C> X <X>).tree.hash.perl

[18:15] <p6eval> rakudo 1a468d: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:5675␤  in method hash at src/gen/CORE.setting:1031␤  in block <anon> at /tmp/VE92WpYAiy:1␤␤»

[18:15] <moritz> rakudo: say (<A B C D> X <X>).tree.hash.perl

[18:15] <p6eval> rakudo 1a468d: OUTPUT«("A X" => ["B", "X"], "C X" => ["D", "X"]).hash␤»

[18:15] <shinobicl> niecza: my %h; for (1 .. 3) -> $n { for ('A' .. 'C') -> $c { %h{$n}{$c} = 'X' } }; say %h.perl; 

[18:15] <p6eval> niecza v15-4-g1f35f89: OUTPUT«{"1" => {"A" => "X", "B" => "X", "C" => "X"}, "2" => {"A" => "X", "B" => "X", "C" => "X"}, "3" => {"A" => "X", "B" => "X", "C" => "X"}}.hash␤»

[18:15] * moritz loves free-style improvising

[18:15] *** havenn joined
[18:20] <shinobicl> rakudo: my %h; for (1 .. 3) -> $n { for ('A' .. 'C') -> $c { my %tmp; %tmp{$c} = 'X'; %h{$n} = %tmp; say '==>' ~ %h.perl; }; say "|"; };

[18:20] <p6eval> rakudo 1a468d: OUTPUT«==>("1" => {"A" => "X"}).hash␤==>("1" => {"B" => "X"}).hash␤==>("1" => {"C" => "X"}).hash␤|␤==>("1" => {"C" => "X"}, "2" => {"A" => "X"}).hash␤==>("1" => {"C" => "X"}, "2" => {"B" => "X"}).hash␤==>("1" => {"C" => "X"}, "2" => {"C" => "X"}).hash␤|␤==>("1" => {"C" =>…

[18:32] <flussence> r: say (1..3 X=> [$({$_=>'X'} for <A B C>)]).perl

[18:32] *** thou left
[18:33] <p6eval> rakudo 1a468d: OUTPUT«(1 => ({"A" => "X"}, {"B" => "X"}, {"C" => "X"}).list.item, 2 => ({"A" => "X"}, {"B" => "X"}, {"C" => "X"}).list.item, 3 => ({"A" => "X"}, {"B" => "X"}, {"C" => "X"}).list.item).list␤»

[18:33] *** Chillance joined
[18:34] *** sisar left
[18:35] *** thou joined
[18:45] <shinobicl> the problem is that i need to create the hash elements inside a loop

[18:46] <moritz> and what's the problem with that?

[18:47] <shinobicl> sorry, i meant inside a loop inside a loop

[18:47] <shinobicl> give me a minute please

[18:48] <shinobicl> http://pastebin.ca/2131164

[18:49] <pmichaud> %h<a><b> doesn't work?

[18:49] <shinobicl> this is the part of the code i'm working on. I have 2 loops, 

[18:49] <pmichaud> rakudo:  my %h;  %h<a><b> = 'X';   say %h.perl

[18:49] <p6eval> rakudo 1a468d: OUTPUT«Method 'at_key' not found for invocant of class 'Any'␤  in method postcircumfix:<{ }> at src/gen/CORE.setting:1184␤  in block <anon> at /tmp/6WtKw2ltlN:1␤␤»

[18:49] <shinobicl> pmichaud: not in rakudo

[18:49] <pmichaud> huh

[18:49] <pmichaud> that's... surprising

[18:50] <TimToady> perl6: nom doesn't do autoviv yet

[18:50] <PerlJam> pmichaud: autovivification bug I'd warrant.

[18:50] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "'"␤    expecting "::", dot, ":", "(", term postfix, operator or ","␤    at /tmp/gu7QXOxqxz line 1, column 10␤»

[18:50] <p6eval> ..rakudo 1a468d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&yet' called (line 1)␤Undefined routine '&autoviv' called (line 1)␤Undefined routine '&doesn't' called (line 1)␤Undefined routine '&nom' called (line 1)␤»

[18:50] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routines:␤     'autoviv' used at line 1␤       'doesn't' used at line 1␤       'nom' used at line 1␤   'yet' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1362 (die @

[18:50] <moritz> shinobicl: is that inside a class?

[18:50] <p6eval> ..3) ␤  at…

[18:50] <pmichaud> rakudo:  my @a;  @a[0][1] = 'X';  say @a.perl;

[18:50] <p6eval> rakudo 1a468d: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/a7eU8DzyIK:1␤␤»

[18:50] <shinobicl> yes moritz 

[18:50] <moritz> shinobicl: or inside a method?

[18:50] <pmichaud> oh, I can/should fix that.

[18:50] <shinobicl> o

[18:50] <pmichaud> at least for a simple case

[18:50] <shinobicl> its a method inside my "Scheduler" class

[18:50] <TimToady> perl6: my %hash; %hash<a> = 1,2,3; say join ';', %hash<a>; # parcel should flatten in list context

[18:51] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«1 2 3␤»

[18:51] <TimToady> but nobody does flatten the parcel

[18:51] <shinobicl> there's the whole Schedule.pm file: http://pastebin.ca/2131165

[18:52] <moritz> shinobicl: I don't understand why you first create a string, and then parse the string to get at the elements

[18:52] <moritz> shinobicl: is your underlying problem that you want to create a hash of arbitrary depth?

[18:53] <shinobicl> moritz: yes

[18:53] <moritz> shinobicl: ah. That's easier to discuss in isolation. Let me come up with an example

[18:54] *** fgomez joined
[18:54] <shinobicl> i have a "schedule" definition like this: http://pastebin.ca/2131168

[18:54] <shinobicl> ahh... ok then

[18:54] <TimToady> perl6: my %hash; %hash<a> = 1,2,3; say join ';', |%hash<a>;   # the | should not be necessary, methinks

[18:54] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«1;2;3␤»

[18:54] <TimToady> much like self shouldn't itemize

[18:55] <shinobicl> the schedule propoerties are convertet to strings to "combine" them, and to create all the moments where the task (not yet implemented) should run

[18:56] <TimToady> lunch & # and change position from back-spasm-inducing chair...

[18:57] <moritz> shinobicl: https://gist.github.com/2161803

[18:59] <moritz> of course the call be prettified to   fill my %h, <a b c d e>, 'foo';

[19:05] <shinobicl> that worked perfect... would serve as a workaround for now, thanks moritz++ !

[19:05] <shinobicl> btw,i've never seen //= before

[19:06] *** mdupont left
[19:19] *** raiph joined
[19:20] *** mdupont joined
[19:21] <japhb> masak, In my misspent youth I worked at SAP (creator of ABAP).  While it is an UGLY language, the underlying engine/VM is actually quite powerful.  Among other things, it papers over weaknesses in databases to such a degree that there is an internal class taught on "ABAP optimization" that basically boils down to teaching you when not to use the full power available, because your database is having to work like mad to do things that look t

[19:21] <japhb> rivial in ABAP.

[19:22] <japhb> Mind you, ABAP is one of those languages that really shows you how maintaining backwards compatibility deep into the mainframe era is not always a win ....

[19:22] <fgomez> ra

[19:23] <fgomez> ra: 1,2,3...9,10,20,30...100

[19:23] <fgomez> how

[19:23] <fgomez> perl6: 1,2,3...9,10,20,30...100

[19:23] <japhb> fgomez, either just 'r:' or 'rakudo:'

[19:23] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "9"␤    expecting operator␤    at /tmp/JChNVm4Z73 line 1, column 9␤»

[19:23] <p6eval> ..rakudo 1a468d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'infix:<...>' will never work with argument types (Mu, Mu, int) (line 1)␤    Expected any of:␤    :(Any $a, Any $b)␤»

[19:23] <p6eval> ..niecza v15-4-g1f35f89:  ( no output )

[19:23] <fgomez> oh ok

[19:24] <fgomez> r: 1,2,3...9,10,20,30...100

[19:24] <p6eval> rakudo 1a468d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'infix:<...>' will never work with argument types (Mu, Mu, int) (line 1)␤    Expected any of:␤    :(Any $a, Any $b)␤»

[19:24] <fgomez> Hmm

[19:24] <benabik> Interesting.  ... chains?

[19:24] <doy> n: say for 1,2,3...9,10,20,30...100

[19:24] <p6eval> niecza v15-4-g1f35f89: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/tHX9J57Lk5 line 1:␤------> [32msay[33m⏏[31m for 1,2,3...9,10,20,30...100[0m␤␤Unhandled exception: C…

[19:24] <doy> n: .say for 1,2,3...9,10,20,30...100

[19:24] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤20␤30␤40␤50␤60␤70␤80␤90␤100␤»

[19:25] <fgomez> r: .say for 1,2,3...9,10,20,30...100

[19:25] <p6eval> rakudo 1a468d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'infix:<...>' will never work with argument types (Mu, Mu, int) (line 1)␤    Expected any of:␤    :(Any $a, Any $b)␤»

[19:25] <japhb> masak, what in your mind would be needed to turn my suggested stretch goal into something you'd be satisfied with?  I wanted it general enough that once agreement on the principle can be reached, people can simultaneously work towards the goal, and begin defining the benchmark suite that would help put it on solid ground.

[19:25] *** MayDaniel joined
[19:34] *** havenn left
[19:38] *** ksi joined
[19:41] *** fgomez left
[19:42] *** daxim left
[19:44] *** mdupont left
[19:46] *** fgomez joined
[19:46] <TimToady> b: .say for 1,2,3...9,10,20,30...100

[19:46] <p6eval> b 1b7dd1: OUTPUT«No applicable candidates found to dispatch to for 'infix:<...>'. Available candidates are:␤:(@lhs, @rhs)␤:(@lhs, Any $limit)␤:(Any $lhs, @rhs)␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/0P_3cAizAo␤»

[19:47] <TimToady> b: .say for 1,2,3...10,20,30...100

[19:47] <p6eval> b 1b7dd1: OUTPUT«No applicable candidates found to dispatch to for 'infix:<...>'. Available candidates are:␤:(@lhs, @rhs)␤:(@lhs, Any $limit)␤:(Any $lhs, @rhs)␤:(Any $lhs, Any $rhs)␤␤  in main program body at line 22:/tmp/lk8CnUKJse␤»

[19:48] *** fgomez left
[19:48] *** fgomez joined
[19:52] <PerlJam> Hmm. I couldn've sworn that worked in rakudo at one time.

[19:52] <PerlJam> s/n//

[19:54] <dalek> rakudo/slurpy-sequence: 048f1b7 | moritz++ | docs/announce/2012.03:

[19:54] <dalek> rakudo/slurpy-sequence: add first draft of 2012.03 release announcement

[19:54] <dalek> rakudo/slurpy-sequence: review: https://github.com/rakudo/rakudo/commit/048f1b7fd4

[19:55] <moritz> oops, wrong branch

[19:55] <pmichaud> TimToady: why would %hash<a> be considered a list and not an item?

[19:55] <dalek> rakudo/nom: 4c7f568 | moritz++ | docs/announce/2012.03:

[19:55] <dalek> rakudo/nom: add first draft of 2012.03 release announcement

[19:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/4c7f568762

[19:55] <colomon> PerlJam: I'm pretty sure it never has

[19:56] <PerlJam> moritz: you're doing the release this month?

[19:56] <moritz> PerlJam: no, masak++ does

[19:56] <PerlJam> ah

[19:56] <moritz> PerlJam: but I'm doing some release prep anyway

[19:56] <moritz> so that he has less work to do

[19:57] <PerlJam> colomon: Really?  I remember  that specific example as one of the things that made me start thinking ... was really neat.

[19:57] <PerlJam> moritz++ you always seem to do release prep

[19:57] <colomon> PerlJam: that example has been in the specs for a long time....  :)

[19:57] <PerlJam> maybe so

[19:58] <PerlJam> n: .say for 1,2,3...9,10,20,30...100

[19:58] <p6eval> niecza v15-4-g1f35f89: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤20␤30␤40␤50␤60␤70␤80␤90␤100␤»

[19:58] <PerlJam> Works in niecza :)

[20:01] <fgomez> guess you could 

[20:01] <pmichaud> autoviv isn't listed in feature comparison, I guess

[20:02] <fgomez> r:1,2,3...9,list(10,20,30...90),list(100,200,300...900)

[20:02] <moritz> it should be, probably

[20:02] <fgomez> r: say 1,2,3...9,list(10,20,30...90),list(100,200,300...900)

[20:02] <p6eval> rakudo 1a468d: OUTPUT«1 2 3 4 5 6 7 8 9 10 20 30 40 50 60 70 80 90 100 200 300 400 500 600 700 800 900␤»

[20:03] <fgomez> is @(...) the same as list(...) ?

[20:03] <moritz> I think it's the same as .list

[20:04] <TimToady> pmichaud: parcels bound into a slurpy are supposed to flatten

[20:04] <fgomez> and what's the difference between .list and list()?

[20:04] <moritz> fgomez: I have no idea

[20:04] <pmichaud> TimToady: that confuses me

[20:04] <fgomez> Haha

[20:05] <moritz> p6: say join '|', <a b c>, <d e f>

[20:05] <p6eval> pugs, rakudo 1a468d, niecza v15-4-g1f35f89: OUTPUT«a|b|c|d|e|f␤»

[20:05] <pmichaud> if I have:  my @a;   @a[0] = (1,2,3); ---- doesn't the 1,2,3 get itemized?

[20:05] <pmichaud> r: my @a; @a[0] = (1,2,3);  say @a.perl;

[20:05] <p6eval> rakudo 1a468d: OUTPUT«Array.new((1, 2, 3))␤»

[20:06] <TimToady> (1,2,3) sure looks like a parcel to me

[20:06] <dalek> features: aa40c49 | moritz++ | features.json:

[20:06] <dalek> features: autovivification

[20:06] <dalek> features: review: https://github.com/perl6/features/commit/aa40c49e39

[20:06] <TimToady> r: my @a; @a[0] = (1,2,3);  say @a[0].WHAT

[20:06] <p6eval> rakudo 1a468d: OUTPUT«Parcel()␤»

[20:06] <pmichaud> oh.  Are Parcels visible now?

[20:06] <pmichaud> is that a change from last summer?

[20:06] <TimToady> no

[20:07] <pmichaud> b:  my @a;  @a[0] = (1,2,3);  say @a[0].WHAT

[20:07] <p6eval> b 1b7dd1: OUTPUT«Seq()␤»

[20:07] <TimToady> well, maybe on that level it's different

[20:07] <pmichaud> that's what confuses me.

[20:07] <pmichaud> I'm very surprised that @a[0] ended up being "Parcel"

[20:08] <pmichaud> that feels very much like a spec change to me, or else I'm horribly misremembering stuff.

[20:09] *** raiph left
[20:09] <benabik> r: my @a; @a[0] = 1; say @a[0].WHAT

[20:09] <p6eval> rakudo 1a468d: OUTPUT«Int()␤»

[20:09] <benabik> You gave it a parcel, it gave one back.  Not too surprising to me.

[20:09] <pmichaud> benabik: Parcels are normally more invisible than that.

[20:10] <pmichaud> traditionally it was rare to find one without having to do something special to get it

[20:10] <pmichaud> s/are normally/were normally/

[20:11] <pmichaud> I'm building an older version of nom to see if it's been that way for a while

[20:12] <TimToady> these days functions try to return values that are non-commital on the issue of flattening, and array/hash subscripts are just a funny kind of function

[20:12] <pmichaud> the model I had been working from treated every element of a hash/array as an item, though.

[20:13] <pmichaud> so if that's no longer the case, then I have to do a major rethink of my model

[20:13] <TimToady> it's an item as in an object, but not an item as in $ prevents flattening

[20:13] <TimToady> the whole business of binding to a \term is going the same direction

[20:14] <pmichaud> right, so that's a change from what we had last summer then

[20:14] <TimToady> it used to be \$term, but then join ';', $term did something unexpected

[20:14] <TimToady> so now it's term, to not commit to non-flattening like $ does

[20:14] <TimToady> and recently we're trying to make self behave the same way

[20:14] <TimToady> like any function that returns a list to be interpolated

[20:15] <pmichaud> okay, this may make some serious changes to nom's container and flattening model then

[20:15] <moritz> /o\ another list refactor :/

[20:15] <pmichaud> very likely.

[20:15] *** mdupont joined
[20:16] <pmichaud> depending on the degree to which people have been updating things in my absence.

[20:16] *** libertyprime left
[20:16] <pmichaud> (updating == to match these newer interpretations)

[20:17] <pmichaud> nom's internal model has been that arrays and hashes are basically aggregations of scalar (non-flattening) containers

[20:18] <pmichaud> if that's not really the case, then the flattening logic has to be re-thunk

[20:18] *** fglock left
[20:19] <PerlJam> It's kind of still true

[20:19] <pmichaud> PerlJam: not if @a[0] can flatten.

[20:19] <TimToady> I seem to recall saying more than a year ago that flattening has to be an attribute of arguments, not of the objects themselves

[20:20] <pmichaud> over time, you've said a lot of things regarding flattening :) :) :)

[20:20] *** libertyprime joined
[20:20] <PerlJam> pmichaud: well, arrays and hashes are aggregations of non-commital containers (wrt flattening) 

[20:21] <pmichaud> PerlJam: that's significantly different from what nom has been implementing

[20:21] <PerlJam> pmichaud: so ... did you ever finish that grant?  ;)

[20:21] <pmichaud> and this isn't new to nom -- the notion that arrays are aggregates of scalars goes all the way back to the original rakudo star release

[20:21] <pmichaud> (in 2010)

[20:24] <masak> ah, #perl6.

[20:25] <masak> so I heard you like Rakudo releases.

[20:25] <pmichaud> PerlJam: no, I didn't finish the grant yet -- and it looks like it's a good thing I didn't.  :)

[20:28] <pmichaud> not also that nom doesn't treat flattening as an attribute of the objects -- it's an attribute of containers

[20:28] <pmichaud> not the objects the containers contain

[20:28] <pmichaud> thus  $a is non-flattening, @a is flattening, even if they're bound to the same object

[20:29] <masak> this conforms to my mental model.

[20:29] <pmichaud> s/not also/note also/

[20:29] <masak> is it about to change? :/

[20:29] <pmichaud> may have already changed and we've been thinking of it wrong, if I'm understanding TimToady++ correctly

[20:30] <masak> I mean, about to change in either or both of my two favorite implementations.

[20:30] <pmichaud> well, rakudo wants to conform to the spec :)

[20:30] *** noteventime joined
[20:30] <pmichaud> so if this is a mismatch, then rakudo will need to change

[20:31] <masak> huh, then I'll need a new mental rule for when things flatten.

[20:31] <pmichaud> well, yeah, that's what I'm trying to develop for myself as well

[20:31] <masak> the current is "when they have a @ sigil or when you cast with @() or when you do .list"

[20:33] <pmichaud> apparently   @a[0]   and %h{'a'}  should flatten as well

[20:33] <TimToady> none of which are true when you way return 1,2,3 from a function

[20:33] <pmichaud> return 1,2,3  isn't an issue because there aren't any containers involved

[20:33] <pmichaud> (in my mental model)

[20:33] <TimToady> it's a parcel

[20:34] <masak> o moricie, you even wrote a release announcement.

[20:34] <masak> apparently, the name of this month's release is "TODO".

[20:34] <pmichaud> s/containers/scalar containers/   # then

[20:34] <TimToady> I don't expect it to be fixed this month

[20:34] <masak> I've been having many good beers with TODO.pm... :)

[20:35] <pmichaud> TimToady: sure, but I still have to get in my head what the correct model is, especially for diving back into list-ish sorts of things

[20:35] <masak> moritz: what's the closest thing to Erlangen.pm ?

[20:36] <masak> dang, we already had Erlangen back in 2010 :)

[20:36] <pmichaud> as moritz intimated above -- this is one of those things that tends to spread throughout a lot of the list code

[20:37] <pmichaud> and in this case, into the binder code as well it would seem. 

[20:38] <masak> anyone have a better suggestion than Argentina.pm ? :P

[20:38] <tadzik> how about Warsaw.pm? :)

[20:39] <pmichaud> have we had many south-american names yet?

[20:39] <pmichaud> if not, Argentina.pm (or something in that area) works very much for me

[20:40] *** MayDaniel left
[20:40] <masak> tadzik: Warsaw.pm sounds neat. what'd they do that's better than refreshing one of our core devs? :)

[20:40] <tadzik> not much, I guess :)

[20:41] <pmichaud> core dev refreshment is very important, though.

[20:41] <masak> pmichaud: no names from the South American continent in Rakudo releases to date.

[20:41] <pmichaud> imagine jnthn++'s productivity level if beer were not available in sufficient quantities

[20:41] <masak> tadzik: come back when Warsaw.pm has held a Perl 6 hackathon or something. sheesh. :P

[20:42] <pmichaud> oslo hackathon activity:  decide on a release name to commemorate the hackathon (since Oslo.pm has already been used :)

[20:42] *** cbk1090 left
[20:42] * masak .oO( Bergen.pm )

[20:43] <masak> (which doesn't exist) :)

[20:43] <PerlJam> Is is okay if we start PM groups just so we have some good names for Rakudo releases?

[20:43] <masak> ok, starting the release process. people, don't commit to master unless you're helping me with the release.

[20:43] <PerlJam> :)

[20:43] <pmichaud> No.

[20:44] <PerlJam> masak++

[20:44] <masak> PerlJam: one of these months, we'll run out of .pm groups :)

[20:44] <masak> we'll run out of good reasons long before, of course.

[20:44] *** pernatiy joined
[20:45] <pmichaud> anyway, I can explore to find out what happens when arrays/hashes aren't aggregations of scalar (non-flattening) containers, but I suspect we'll have some real surprises.

[20:46] <PerlJam> I know it's kind of boring to just have "release #57" or whatever, but why exactly are we naming and numbering releases?  Is anyone going talk about the "ThousandOaks.pm release"?  Probably only the person that did the release and briefly some people from ThousandOaks.pm.

[20:46] <PerlJam> Perhaps we should just give releases numbers only, then for _significant_ releases, give them a name.

[20:46] <pmichaud> the numbering makes it easier to know how many there have been

[20:47] <pmichaud> I'd prefer not to have to debate about what constitutes a "significant" release. (more)

[20:47] <pmichaud> I'd rather relax the "contributes to Perl 6" restriction and start picking .pm names we like

[20:47] <masak> PerlJam: you may have missed us using the code names, but it actually happens quite a lot. with some releases more than others.

[20:48] <pmichaud> indeed, we do refer to "Beijing" from time to time :)

[20:48] <masak> yeah, I was gonna say.

[20:48] <PerlJam> pmichaud: you wouldn't have to debate about significance.  It would be an emergent property  :)

[20:48] <pmichaud> some products have themed names for every release (e.g., stars, birds, felines, etc.).  Our theme just happens to be .pm groups

[20:48] <masak> that's probably the most referred-to release code name to date.

[20:49] <pmichaud> PerlJam: see "stable release" for a counter example :)

[20:49] <pmichaud> and significance is often only observable in retrospect :)

[20:49] <masak> pmichaud: I suggest when we run out of virtuous reasons to pick .pm groups, we instead pick them out of spite :>

[20:49] <pmichaud> masak: that works for me also

[20:49] <masak> mwhaha

[20:49] <PerlJam> Which pm group does Damian frequent or is closest to?

[20:50] <pmichaud> I'd be happy to see Austin.pm and/or DFW.pm listed someday.

[20:50] <pmichaud> DFW.pm does have regular (montly) discussions of Perl 6, even if there are many contributors besides myself

[20:50] <pmichaud> *monthly

[20:51] <pmichaud> *aren't

[20:51] <PerlJam> pmichaud: wait ... does that mean you talk to DFW.pm about perl 6 every month?  :)

[20:51] <pmichaud> well, "DFW.pm" is kind of an umbrella sort of thing at the moment (more)

[20:52] <pmichaud> because the DFW metroplex is so geographically large, it's hard to have regular "DFW.pm meetings"

[20:52] <dalek> nqp: fd67256 | masak++ | VERSION:

[20:52] <dalek> nqp: bump VERSION to 2012.03

[20:52] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fd6725660a

[20:52] <pmichaud> instead, there's a sub-group of us that meet every second Tuesday in one of the suburb cities -- usually there's 6-12 attendees at each meeting

[20:52] <pmichaud> and yes, Perl 6 progress and latest tidbits is always an item of discussion at those meetings

[20:53] *** jaldhar joined
[20:53] <moritz> fwiw at most Erlangen.pm meetings Perl 6 also comes up, and I tell them a bit about the current state

[20:53] <pmichaud> we've encouraged other DFW suburb areas to form regular meetings and advertise them on the DFW.pm list... but so far nobody has done that that I know of.

[20:54] <japhb> I'd love to see a Sonoma.pm release (that's my local PM), but the "group has done something significant for Perl 6" has always been a blocker to me suggesting it -- since we do talk about Perl 6 most times, but the group seems more in the general mood to discuss and inform than to hackathon.

[20:55] <dalek> rakudo/nom: 77dcb04 | masak++ | tools/build/NQP_REVISION:

[20:55] <dalek> rakudo/nom: [tools/build/NQP_REVISION] to latest NQP release

[20:55] <dalek> rakudo/nom: 

[20:55] <dalek> rakudo/nom: ...and it's only minutes old! That's how current we are!

[20:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/77dcb04420

[20:55] <PerlJam> "Evangelizes Perl 6 more than any other PM group"

[20:55] <tadzik> masak: we had a party with a cake on Rakudo Star release, does that count? :P

[20:56] <PerlJam> "Has more Perl 6 discussion than #perl6"

[20:56] *** cbk1090 joined
[20:56] <PerlJam> "Had a party for Perl 6"

[20:56] <pmichaud> I'm fine with us simply choosing .pm groups based on people who hang out on #perl6/#parrot, too :)

[20:56] <masak> tadzik: were you contributing to Rakudo at the time you ate the cake? :)

[20:56] <PerlJam> japhb: those look like "something significant" to me  ;-)

[20:56] <pmichaud> I'm especially fine with choosing .pm groups based on the fact that they ultimately produce a core dev :) :)

[20:57] <pmichaud> we should have more of those.  :)

[20:57] <tadzik> masak: we were planning to blow the candles with an air coming out of CPU cooler while it was compiling Rakudo :P

[20:57] <PerlJam> tadzik: lol

[20:57] <masak> tadzik: that, sir, is *awesome*.

[20:57] <pmichaud> if the air is hot enough, you could perhaps use it to light the candles

[20:57] <tadzik> http://warszawa.pm.org/

[20:57] <tadzik> possibly

[20:58] <pmichaud> or, disable the fan and light the candles directly from the CPU

[20:58] *** skids left
[20:58] <pmichaud> afaic, warsaw qualifies for a name based on having a picture of their Perl 6 cake :) :)

[20:58] <PerlJam> the dripping wax will even help the mother board (probably)

[21:00] <pmichaud> anyway, I like the naming-of-each-release.  Even if only a few people end up talking about the named group, that's more than would happen otherwise.  And at least for me, hearing names of other groups at least inspires me to put "SomeGroup.pm" into my browser to see what it looks like :)

[21:00] <benabik> rochester.pm looks sad.  :-(

[21:01] <pmichaud> although, we could start picking .pm groups that seem to have nothing to do with Perl 6, in the hopes of "shaming" them into contributing something :-) :-) :-)

[21:01] <pmichaud> er... "shaming" --> "enticing"  :-)

[21:02] <masak> uploaded nqp-2012.03.tar.gz to https://github.com/perl6/nqp/downloads -- despite this not being in the nqp release guide.

[21:02] <masak> someone++ is welcome to fix the nqp release guide, while I continue releasing Rakudo ;)

[21:03] *** fsergot left
[21:03] <pmichaud> "Starting with the Deadbeats.pm release, we will be naming each Rakudo compiler release after a group that ought to be contributing to future releases."

[21:03] *** shinobicl left
[21:06] <moritz> masak: iirc github offers .zip downloads automatically for each tag

[21:06] <moritz> masak: so that's what the folks who think they need a source package can use; everybody else just uses --gen-nqp

[21:08] <masak> moritz: be that as it may -- jnthn pointed out that I had not done this step last time. this time I remembered doing it.

[21:09] <moritz> fairy nuff

[21:09] <moritz> I suppose you're right

[21:10] <masak> tools/update-tai-utc.pl # This program should next be run in August.

[21:10] <masak> I wanted to write some humorous reaction to that...

[21:11] <masak> ...but I just think it's funny in itself. the program gives advice on when it's to be run next time.

[21:11] <pmichaud> seems like it ought to be able to run itself at that point :)

[21:11] <moritz> sleep 3600 while Date.today < Date.new(2012, 8)

[21:12] <masak> it's a bit like the box with a button that when pushed has an arm come out of the box and push the button to turn it off.

[21:13] <tadzik> haha

[21:13] <masak> http://www.youtube.com/watch?v=UmQ5LsNMXZ4

[21:13] <masak> luddite tech.

[21:14] * pmichaud considers building a machine like that out of Legos

[21:15] <benabik> ...  It runs away?

[21:15] <moritz> wow, that's quite an advanced version

[21:15] <moritz> pmichaud: exactly my thought :-)

[21:16] <moritz> and then "hey, I have an Arduino" :-)

[21:16] <pmichaud> http://youtube.com/pmichaud   

[21:16] <pmichaud> (the FLL championship videos, not the wheel matching one :)

[21:17] <benabik> pmichaud: Of course, the wheel matching one is the one I started watching.

[21:19] <masak> pmichaud: that is impressive.

[21:19] <pmichaud> yeah, the team did well this year (our first year)

[21:28] *** fsergot joined
[21:30] *** shinobicl joined
[21:31] *** benabik left
[21:32] <dalek> rakudo/nom: c15aecd | masak++ | docs/announce/2012.03:

[21:32] <dalek> rakudo/nom: [docs/announce/2012.03] finalized

[21:32] <dalek> rakudo/nom: 

[21:32] <dalek> rakudo/nom: s/TODO/Argentina/. other small fixes.

[21:32] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/c15aecd5a7

[21:32] <masak> feel free to review at your convenience.

[21:33] <pmichaud> March 2012 release, yes?

[21:34] <pmichaud> first sentence says "February"

[21:34] <masak> indeed.

[21:34] <masak> pmichaud++

[21:34] <masak> fixing.

[21:34] <masak> (I initially had the ending paragraph as "an indescribable ecstasy and delirium in melting; (what salutes of cannon and small arms!)", but I looked at it and decided it was probably too spurious for a Rakudo release)

[21:34] <masak> s/an/Have an/

[21:35] <dalek> rakudo/nom: 5dab131 | masak++ | docs/announce/2012.03:

[21:35] <dalek> rakudo/nom: [docs/announce/2012.03] s/February/March/

[21:35] <dalek> rakudo/nom: 

[21:35] <dalek> rakudo/nom: pmichaud++ eagle eyes.

[21:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5dab131b1d

[21:39] <PerlJam> masak: I really like that last paragraph

[21:39] <masak> thanks.

[21:39] <PerlJam> masak++ always making things better :)

[21:40] <pmichaud> I will get autoviv working before the next release.

[21:40] <pmichaud> I didn't realize it wasn't working.

[21:42] <dalek> rakudo/nom: 5dda9a7 | masak++ | docs/release_guide.pod:

[21:42] <dalek> rakudo/nom: [docs/release_guide.doc] current release => past

[21:42] <dalek> rakudo/nom: 

[21:42] <dalek> rakudo/nom: Also extended the future a little.

[21:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5dda9a7142

[21:43] <felher> masak++

[21:44] <felher> and with that important thing said, im going out for nightly walk

[21:44] *** Trashlord left
[21:45] <masak> Trashlord: I think we won't have time to cut down/poison/catch everything before the oil runs out.

[21:46] <masak> and then we'll realize that everything, including the economy, ran on oil.

[21:47] *** justdroppingby joined
[21:48] <masak> PerlJam: for some reason, I was reminded of the quote "Do your work with your whole heart, and you will succeed -- there's so little competition." -- Elbert Hubbard

[21:48] <masak> justdroppingby: hi!

[21:48] <justdroppingby> hello

[21:48] <masak> are you staying for long, or... :P

[21:48] *** Trashlord joined
[21:49] <justdroppingby> just dropping by ...

[21:50] <masak> somehow I had that feeling.

[21:50] <tadzik> heh, I saw that one coming

[21:50] <pmichaud> justdroppingby: you're in good company.  :-)

[21:50] <masak> perl6: say <just dropping by>.pick(*)

[21:50] <p6eval> rakudo 77dcb0: OUTPUT«by just dropping␤»

[21:50] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«just dropping by␤»

[21:50] <p6eval> ..pugs: OUTPUT«bydroppingjust␤»

[21:51] <masak> niecza++

[21:51] <pmichaud> perl6: say <just dropping by>.pick(*)

[21:51] <p6eval> rakudo 77dcb0: OUTPUT«just dropping by␤»

[21:51] <p6eval> ..pugs: OUTPUT«droppingjustby␤»

[21:51] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«dropping just by␤»

[21:51] <masak> rakudo++

[21:51] <pmichaud> just checking that our random number generators were still "random"  :)

[21:54] <justdroppingby> perl6: say < dropping just by>.pick(*)

[21:54] <p6eval> rakudo 77dcb0: OUTPUT«by just dropping␤»

[21:54] <p6eval> ..pugs: OUTPUT«droppingjustby␤»

[21:54] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«by dropping just␤»

[21:54] <masak> quick, what's the probability that at least one of the three implementations will get the right order? :)

[21:54] <tadzik> 1/2

[21:55] <masak> how'd you arrive at that?

[21:55] <tadzik> 3*2*1 permutations, 3 chances to hit

[21:55] <masak> it's 1/6 that a given implementation will get it. so it's 5/6 that it won't get it. that all three won't get it is (5/6)**3

[21:55] <masak> thus, that at least one will get it right is 1-(5/6)**3

[21:56] <masak> p6: say 1-(5/6)**3

[21:56] <tadzik> oh, that's the thing I keep forgetting about :)

[21:56] <p6eval> pugs: OUTPUT«0.4212962962962962962962962962962962962963␤»

[21:56] <p6eval> ..rakudo 77dcb0: OUTPUT«0.421296296296296␤»

[21:56] <p6eval> ..niecza v15-4-g1f35f89: OUTPUT«0.42129629629629628␤»

[21:56] <masak> yeah, you can't just add probabilities.

[21:56] <tadzik> right

[21:56] <masak> that way, you'll hit 1.0 pretty fast :P

[21:56] <masak> and that's just silly.

[21:56] <pmichaud> well, you *can* add probabilities, but you'll probably be wrong for doing so.  :)

[21:57] <masak> you can only really add probabilities that refer to the same event falling out in different ways.

[21:57] <masak> but these refer to three different events.

[21:57] <justdroppingby> is this really a perl6 channel? :)

[21:58] <masak> *lol*

[21:58] <tadzik> haha

[21:58] <tadzik> sometimes I don't believe it either

[21:58] <tadzik> masak: quick, Przypadki!

[21:58] <masak> quick, everyone put on their Perl 6 masks!

[21:59] <masak> tadzik: I'm all out of przypadki... :)

[21:59] <justdroppingby> what is przypadki? googling..

[21:59] <masak> justdroppingby: if you have an on-topic Perl 6 question/comment, don't let our frivolities stop you.

[21:59] <masak> justdroppingby: it's "grammatical cases" in Polish. that was the off-topic topic the other day.

[22:00] <masak> man, this box is fast.

[22:00] <justdroppingby> and probability is on-topic. :)

[22:01] <tadzik> everything is, as long as it's not disturbing the Perl 6 discussion ongoing

[22:01] <pmichaud> afk for me for a while -- bbl

[22:01] <masak> justdroppingby: hey, we were talking probability in the context of Perl 6 implementations giving the right answer :P

[22:02] <justdroppingby> haha

[22:02] <justdroppingby> what is easiest way to start with perl6?

[22:02] *** pjcj left
[22:03] * masak just sits and watches in awe as `TEST_JOBS=8 time make stresstest` chews through the spectest suite

[22:03] <tadzik> justdroppingby: perl6.org/documentation

[22:03] <justdroppingby> considering I know *very little* perl5

[22:04] <justdroppingby>  thank you.

[22:04] <masak> justdroppingby: type 'r: say "OH HAI"' here on the channel -- voila! you've started with Perl 6!

[22:04] <masak> justdroppingby: also, why should we invest time in helping you? you're just gonna leave soon anyway. :P

[22:04] <justdroppingby> masak: what is r?

[22:05] *** pernatiy left
[22:05] <justdroppingby> sorry for asking silly questions

[22:05] <masak> short for "rakudo".

[22:05] <masak> the compiler I'm in the process of doing a monthly release for right now.

[22:05] *** thou left
[22:06] <masak> you have r/rakudo, n/niecza, p/pugs, and for all three, p6/perl6.

[22:06] <justdroppingby> I am new to irc as well.

[22:06] <justdroppingby> ok

[22:07] <masak> the individual that replies when you do this, p6eval, is a bot.

[22:07] <masak> r: say "hi!"

[22:07] <p6eval> rakudo 5dda9a: OUTPUT«hi!␤»

[22:07] <masak> the funny NL character means "newline"

[22:07] <justdroppingby> r: say "Hello Perl6 Folks!"

[22:07] <p6eval> rakudo 5dda9a: OUTPUT«Hello Perl6 Folks!␤»

[22:07] <tadzik> hello!

[22:08] <masak> o/

[22:08] <masak> hah! burned through the stresstest suite in 3:43.53!

[22:08] <masak> man, that feels good!

[22:08] <justdroppingby> n: say " Hi tadzik"

[22:08] <p6eval> niecza v15-4-g1f35f89: OUTPUT« Hi tadzik␤»

[22:09] *** havenn joined
[22:09] <masak> so, we have three failures in t/spec/S19-command-line/dash-e.t

[22:09] <masak> anyone able to reproduce this on HEAD?

[22:09] <masak> moritz: is this a known one?

[22:10] <masak> havenn: hi! welcome back!

[22:11] <masak> justdroppingby: we have other nice bots that do other useful things for us.

[22:11] <masak> dalek++ reports commits on the channel.

[22:11] <havenn> masak: hi! how goes perl6 development?

[22:11] <justdroppingby> commits to perl6 repository?

[22:11] <masak> phenny++ helps us with Unicode, delivering messages to people who are AFK or logged out, and translating language.

[22:12] <masak> justdroppingby: we have dozens of repositories. none is called perl6 :)

[22:12] <tadzik> hugme: hug me

[22:12] * hugme hugs tadzik

[22:12] <tadzik> that one is the best

[22:12] <tadzik> hugme: hug justdroppingby 

[22:12] * hugme hugs justdroppingby

[22:12] <masak> havenn: just about to release the best Rakudo monthly, ever.

[22:12] <justdroppingby> I meant related to perl6

[22:12] <masak> right.

[22:12] <masak> hugme hugs people, and also gives them commit bits so they can contribute.

[22:12] <hugme> masak: 

[22:13] <masak> and she's noisy sometimes :)

[22:14] <masak> Imma go ahaed and fudge t/spec/S19-command-line/dash-e.t for now. but I don't like that it fails and no-one noticed.

[22:14] <masak> still interested in an independent reproduce from someone.

[22:14] <flussence> .oO( hugme should have an `$output ||= ')';` line added... )

[22:15] <justdroppingby> ok. its late for me. I will download rakudo soon and start playing with it. once I know how to :)

[22:15] *** explorer__ left
[22:16] *** __sri left
[22:16] <masak> let us know if you figure out how to download rakudo ;)

[22:17] *** jnthn left
[22:17] *** _sri joined
[22:17] *** literal left
[22:17] *** mathw left
[22:18] *** literal joined
[22:18] *** mathw joined
[22:19] *** justdroppingby left
[22:20] *** mj41 joined
[22:21] *** skids joined
[22:23] <fsergot> 'night #perl6 \o

[22:23] <masak> 'night, fsergocie.

[22:23] <dalek> roast: 4cfafd6 | masak++ | S19-command-line/dash-e.t:

[22:23] <dalek> roast: [S19-command-line/dash-e.t] fudged for rakudo

[22:23] <dalek> roast: review: https://github.com/perl6/roast/commit/4cfafd6979

[22:23] <tadzik> masak++ # good :)

[22:23] <tadzik> fsergot: g'night

[22:24] *** jferrero joined
[22:25] *** kaare_ left
[22:27] <dalek> rakudo/nom: fb64898 | masak++ | VERSION:

[22:27] <dalek> rakudo/nom: [release] bump VERSION

[22:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fb648983db

[22:27] *** ksi left
[22:31] <masak> ooh, another nice p6l email thread.

[22:31] <masak> started by the same (Daniel Carrera)++

[22:39] <masak> I'm now at the stage where I'm re-running the test suites from a fresh unpack of the tarball.

[22:39] <masak> getting a failure in the last 'make test' file, t/02-embed/01-load.t

[22:39] <masak> should I be concerned?

[22:39] *** whiteknight joined
[22:39] <masak> running the stresstest suite to see if there is more fallout. if there isn't I'm inclined to ignore the one failure in t/02-embed/01-load.t

[22:41] *** fgomez left
[22:42] *** fgomez joined
[22:42] <masak> all stresstests successful. full steam ahead.

[22:44] <masak> github tarball uploaded; Rakudo wikipedia page updated; p6c email sent.

[22:44] <tadzik> Steady as she goes, Lt. Sulu

[22:44] <masak> monthly release releng mode completed.

[22:44] <masak> you can now make awesome commits as usual ;)

[22:45] *** pjcj joined
[22:46] * felher builds newest rakudo to try to reproduce masaks broken test.

[22:46] <masak> pjcj: hi! long time no see.

[22:46] <colomon> masak++

[22:49] <masak> so, who's doing the May release? :)

[22:51] *** shinobicl_ joined
[22:53] <felher> masak: is a to execute './perl6 t/spec/S19-command-line/dash-e.t' sufficient? If so, it doesn't fail here. 

[22:53] <felher> gives me three oks

[22:53] <felher> s/a//

[22:54] *** pmurias left
[22:54] <masak> felher: that should be sufficient, yes.

[22:54] <masak> maybe my setup is causing the error, then.

[22:55] <masak> felher++ # thanks for checking

[22:55] <masak> felher: what about t/02-embed/01-load.t ? does it pass?

[22:56] <felher> masak: not sure.  './perl6 t/02-embed/01-load.t' doesn't give me a okay. But it doesn't say it failed neither. It just gives me '1..1'

[22:57] <pjcj> masak: I'm usually idling here and you only notice me when my net connection comes back up ;-)

[22:57] <felher> if thats enough for passnig, that it passes :)

[22:57] <masak> pjcj: ah. you've been idling since October 2005, just so you know. :)

[22:58] <pjcj> heh

[22:58] <masak> felher: it should say one OK, too :/

[22:58] *** NamelessTee left
[22:58] <masak> $ ./perl6 -e 'print q[\c[LATIN SMALL LETTER A WITH DOT ABOVE]]'

[22:58] <masak> ===SORRY!===

[22:58] <masak> Confused

[22:58] <masak> at -e:1

[22:58] <masak> :/

[22:58] *** jnthn joined
[22:58] <masak> this is why dash-e.t fails here.

[22:58] <masak> could be something ICU-related. I do have ICU installed.

[22:59] <felher> oO? This fails here, too.

[22:59] <felher> i'm getting the same error as you get

[22:59] <felher> But the test works just fine

[23:04] *** mj41 left
[23:04] *** alester left
[23:04] *** shinobicl_ left
[23:04] <masak> how can the test work just fine when it's all about the execution not failing?

[23:04] <masak> are you running the same executable both times?

[23:06] <felher> masak: yes

[23:06] <felher> masak: maybe thats the catch:

[23:07] <felher> masak: \c[LATIN SMALL LETTER A WITH DOT ABOVE] gets substitutet _before_ its given to an argument to perl -e

[23:08] <felher> so its executing "perl -e 'print q[<some-weird-symbol>]'

[23:09] *** shinobicl_ joined
[23:09] <masak> what would substitute it before? bash?

[23:09] <masak> that doesn't make any sense.

[23:10] <felher> masak: the problem ist that the bash doesn't substitute. But the perl-test does.

[23:10] <masak> oh! you're right, of course.

[23:10] <masak> yes, the substitution happens in the test file.

[23:11] <felher> :)

[23:11] <felher> The first time i was here, in this channel, my perl6 wisdom was cleary zero. But i tell you, it has doubled since then! :)

[23:12] <masak> felher++

[23:12] <masak> yes, now I got it to run.

[23:12] *** havenn left
[23:15] *** noteventime left
[23:16] <felher> Hm, i think that should be: "cleary was zero", shouldn't it?

[23:17] <masak> both sound fine to me.

[23:17] <masak> if you discount the s/cleary/clearly/ typo ;)

[23:18] <felher> Oh, yeah, right :)

[23:18] * masak heads to bed

[23:18] <masak> 'night, #perl6

[23:18] <felher> o/ sleep well :)

[23:39] *** shinobicl_ left
[23:51] *** PacoAir left
