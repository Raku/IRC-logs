[00:02] <xenoterracide> hmm... well I can't seem to get things to work on the newer parrot now

[00:02] <xenoterracide> I wonder what's up with that

[00:03] <xenoterracide> I give up for the time being

[00:04] *** Kharec left
[00:08] *** hash_table left
[00:12] *** zjmarlow__ joined
[00:16] *** qu1j0t3 left
[00:47] *** zjmarlow__ left
[00:49] *** wamba left
[01:02] <xenoterracide> r: say Date.new;

[01:02] <p6eval> rakudo cecc9f: OUTPUT¬´2012-12-24‚ê§¬ª

[01:02] <xenoterracide> that seems so arbitrary

[01:03] <sorear> xenoterracide: it is, in fact, completely arbitrary

[01:04] <xenoterracide> why doesn't it throw an exception

[01:07] *** dedis6 joined
[01:07] *** anuby joined
[01:09] <sorear> that's the way it is.  not my call.

[01:15] *** dedis6 left
[01:18] *** Chillance left
[01:23] *** hypolin joined
[01:25] <xenoterracide> so asked this early but think it may have gotten lost in another conversation. can I apply a role at runtime but where it's also new time? meaning not after the object is constructed

[01:37] *** tokuhiro_ left
[01:38] *** tokuhiro_ joined
[01:53] <xenoterracide> r: class T { has $.foo }; my $t = T.new; $t.foo('test');

[01:53] <p6eval> rakudo cecc9f: OUTPUT¬´Too many positional parameters passed; got 2 but expected 1‚ê§  in method foo at src/gen/CORE.setting:1794‚ê§  in block  at /tmp/KuoZG3JWXh:1‚ê§‚ê§¬ª

[01:53] <xenoterracide> I don't understand that error

[01:53] *** sirrobert left
[01:56] *** sirrobert joined
[02:09] <sorear> xenoterracide: the correct syntax is $t.foo = 'test';

[02:10] <sorear> r: class C { } ; role R { method foo() { 42 } }; say (C but R).new.foo # something like this xenoterracide?

[02:10] <p6eval> rakudo cecc9f: OUTPUT¬´42‚ê§¬ª

[02:11] <xenoterracide> I thought `but` allowed things to be removed not added... yeah I suppose something like

[02:12] <xenoterracide> I guess I don't quite understand `but` yet

[02:13] <sorear> but only adds.

[02:13] <sorear> (C but R) is the same as (anon class :: is C does R { })

[02:16] *** fgomez left
[02:17] <xenoterracide> using the word `but` for this grates against my sense since I see but as a negation

[02:17] <xenoterracide> still thanks

[02:21] *** bowtie left
[02:21] *** fgomez joined
[02:21] *** fgomez left
[02:22] *** whiteknight left
[02:26] *** fgomez joined
[02:46] *** FROGGS_ joined
[02:49] *** rurban_ joined
[02:49] *** fgomez left
[02:49] *** fgomez joined
[02:50] *** flightrecorder left
[02:50] *** FROGGS left
[02:51] *** flightrecorder joined
[02:52] <felher> 'night #perl6 :)

[02:53] <doy> 'but' isn't a negation, even in the linguistic/logical sense

[02:53] <doy> "this object is green but small"

[02:53] <doy> means it's both green and small

[02:55] <geekosaur> but is a constraint, even in natural language.  negation is the simplest constraint but far from the only one

[02:56] <sorear> 'but' indicates an unexpected propert

[02:56] <sorear> y

[02:57] <sorear> "this tungsten ball is small but quite heavy"

[02:57] <sorear> "after '$x = 0 but True', $x is numerically zero but true in boolean context"

[02:58] <sorear> you expect small things to be light, and zero things to be false (at least in Perl)

[03:00] *** hash_table joined
[03:12] <xenoterracide> http://privatepaste.com/1130814e00 O.o

[03:15] *** hash_table left
[03:32] *** ifim joined
[03:32] <lue> r: say "foo bar".^methods; my @array = "foo bar".^methods; my @array = "foo bar".words; say @array.perl'

[03:32] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Redeclaration of symbol @array‚ê§at /tmp/hHARka2VXg:1‚ê§¬ª

[03:33] <lue> (IIRC rakudo's REPL isn't the most reliable way of testing P6 code)

[03:36] <ifim> you declared @array twice

[03:36] <ifim>  r: say "foo bar".^methods;

[03:36] <p6eval> rakudo cecc9f: OUTPUT¬´BUILD Int Num chomp chop substr pred succ match ords lines samecase samespace trim-leading trim-trailing trim words encode capitalize wordcase trans indent codes tclc path WHICH Bool Str ACCEPTS Numeric gist perl comb subst split‚ê§¬ª

[03:36] <doy> r: say "foo bar".words.perl

[03:36] <p6eval> rakudo cecc9f: OUTPUT¬´("foo", "bar").list‚ê§¬ª

[03:37] <ifim> r: my @array = "foo bar".words; say @array.perl';

[03:37] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/QAltXN0pPT:1‚ê§¬ª

[03:37] <doy> r: my @array = "foo bar".words; say @array.perl

[03:37] <p6eval> rakudo cecc9f: OUTPUT¬´Array.new("foo", "bar")‚ê§¬ª

[03:37] <ifim> r: my @array = "foo bar".words; say @array.perl;

[03:37] <p6eval> rakudo cecc9f: OUTPUT¬´Array.new("foo", "bar")‚ê§¬ª

[03:37] <ifim> sorry

[03:37] <lue> r: my @array = "foo bar".^methods; say @array.perl;

[03:37] <p6eval> rakudo cecc9f: OUTPUT¬´Array.new(submethod BUILD(Str : :value(:$value) = { ... }, Mu *%_) { ... }, method Int(Str:D : Mu *%_) { ... }, method Num(Str:D : Mu *%_) { ... }, method chomp(Str:D : Mu *%_) { ... }, method chop(Str:D : Mu *%_) { ... }, method substr(Str:D : $start, $length? is ‚Ä¶

[03:38] <lue> Apparently the REPL will ignore a redeclaration without telling you (+ giving the appearance of success).

[03:51] *** orafu left
[03:51] *** orafu joined
[03:58] *** ifim left
[04:09] *** takesako joined
[04:28] *** dedis joined
[04:31] <dalek> perl6-bench: b47060b | (Geoffrey Broadwell)++ | bench:

[04:31] <dalek> perl6-bench: Remove unixism by switching to Shell::Command for rm_rf

[04:31] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/b47060be8c

[04:31] <dalek> perl6-bench: 5268d41 | (Geoffrey Broadwell)++ | bench:

[04:31] <dalek> perl6-bench: Change 'extract-releases' command to just 'extract', but leave the longer name as an alias for the short one

[04:31] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/5268d41924

[04:31] <dalek> perl6-bench: 04e2158 | (Geoffrey Broadwell)++ | / (2 files):

[04:31] <dalek> perl6-bench: Add 'time' command to time individual checkouts; change timeall program to support this (minimally, at least)

[04:31] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/04e215888f

[04:50] <dalek> perl6-bench: 273e045 | (Geoffrey Broadwell)++ | bench:

[04:50] <dalek> perl6-bench: Remove redundant line that had been copy-pasted to three places

[04:50] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/273e045aba

[04:50] <dalek> perl6-bench: e48cabb | (Geoffrey Broadwell)++ | bench:

[04:50] <dalek> perl6-bench: Move 'clean' command multi back to where it was supposed to be

[04:50] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/e48cabbd13

[05:29] <dalek> perl6-bench: 45eee9e | (Geoffrey Broadwell)++ | bench:

[05:29] <dalek> perl6-bench: Factor out some boilerplate from most of the command multis

[05:29] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/45eee9ec0e

[05:43] *** skids left
[05:46] *** birdwindupbird joined
[05:52] <dalek> perl6-bench: ccf9079 | (Geoffrey Broadwell)++ | bench:

[05:52] <dalek> perl6-bench: Improve error handling and sanity checking in 'extract' command

[05:52] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/ccf9079640

[06:14] <moritz> \o

[06:15] <moritz> https://gist.github.com/4109216 # qast-sink-1 spectest summary

[06:18] *** kaleem joined
[06:33] *** circlepuller left
[06:33] *** circlepuller joined
[06:35] *** zby_home_ joined
[06:58] *** FROGGS_ left
[06:59] *** flightrecorder left
[07:00] *** zby_home_ left
[07:09] *** cognominal joined
[07:14] *** cognominal left
[07:15] *** drbean left
[07:21] *** drbean joined
[07:22] *** flightrecorder joined
[07:27] *** Bzek joined
[07:31] *** FROGGS joined
[07:31] <FROGGS> morning

[07:33] <FROGGS> phenny: ask jnthn if these fails ( http://smolder.parrot.org/app/projects/report_details/32307 ) need to be fixed before release

[07:33] <phenny> FROGGS: I'll pass that on when jnthn is around.

[07:34] *** rurban_ left
[07:44] *** SamuraiJack joined
[07:47] <moritz> FROGGS: yes, they need to be fixed (or in some cases the tests need to be fudged)

[07:47] <moritz> FROGGS: I might look at them tonight

[07:47] <FROGGS> moritz: k, thanks

[07:50] *** domidumont joined
[07:51] <moritz> S12-class/attributes is a new test

[07:52] <dalek> roast: ac70806 | moritz++ | S12-class/attributes.t:

[07:52] <dalek> roast: avoid a name conflict

[07:52] <dalek> roast: review: https://github.com/perl6/roast/commit/ac708062f8

[07:52] <moritz> same with S32-exception/misc

[07:55] <dalek> roast: f631233 | moritz++ | S06-other/main-usage.t:

[07:55] <dalek> roast: fudge two new, failing tests

[07:55] <dalek> roast: review: https://github.com/perl6/roast/commit/f6312330c6

[07:59] *** odoacre left
[07:59] *** odoacre joined
[08:04] *** drbean left
[08:04] *** fgomez left
[08:04] <jnthn> morning o/

[08:04] <phenny> jnthn: 07:33Z <FROGGS> ask jnthn if these fails ( http://smolder.parrot.org/app/projects/report_details/32307 ) need to be fixed before release

[08:05] <FROGGS> morning

[08:05] <jnthn> yes, and it looks like moritz++ is on with it

[08:05] <FROGGS> ya, he is

[08:05] <FROGGS> ;o)

[08:05] *** sorenso joined
[08:08] *** wamba joined
[08:09] *** drbean joined
[08:13] *** fgomez joined
[08:23] *** domidumont left
[08:24] *** domidumont joined
[08:24] *** Kharec joined
[08:31] <tipdbmp> What's the difference between 'has $!attr;' and 'has $.attr;' and how does one redifine the accessor methods generated for 'has $.attr;'?

[08:32] <tadzik> you don't get an accessor method with has $!attr

[08:33] <tipdbmp> How do I use $!attr from outsdie the class?

[08:33] <tadzik> you don't :)

[08:34] <tadzik> you need an accessor method for that

[08:34] <tadzik> either use $.attr or write your own accessor method

[08:34] <tadzik> r: class A { has $!attr = 5; method attr { "I'ts {$!attr}" }; A.new.attr.say

[08:34] *** drbean left
[08:34] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Unable to parse expression in block; couldn't find final '}' at line 2, near ""‚ê§¬ª

[08:34] <tadzik> p6eval: pfffft!

[08:34] <tadzik> r: class A { has $!attr = 5; method attr { "I'ts {$!attr}" } }; A.new.attr.say

[08:34] <p6eval> rakudo cecc9f: OUTPUT¬´I'ts 5‚ê§¬ª

[08:35] <tipdbmp> That's a get method for $!attr, what about a set one?: method attr($value) { $!attr = $value; } # ?

[08:36] <tadzik> yeah, you can write one :)

[08:40] <FROGGS> tipdbmp: the ! makes is a private attribute, so IMO it makes not much sense to have another accessor that looks like a public attribute

[08:40] *** drbean joined
[08:40] <tipdbmp> Okay.

[08:40] <FROGGS> tipdbmp: but keep in mind that the ! is just needed for declaring a private attr, to use it within your class always use $.attr

[08:41] <FROGGS> so the ! only appears once

[08:41] <tadzik> s/within/outside/?

[08:41] <tipdbmp> Yes.

[08:42] *** thou left
[08:42] <FROGGS> tadzik: when assessing to $!attr within your class, you dont use the !, right?

[08:42] <mathw> externally accessible set methods for private attributes are useful when you need to do something more complex than just set the attribute. But maybe writing setter methods rather than assignment-ish syntax is considered more idiomatic Perl 6?

[08:44] <FROGGS> mathw: dunno, I do like addignment-ish syntax, and I dont care what the class is doing with it

[08:44] *** sqirrel joined
[08:44] <tadzik> FROGGS: I do

[08:44] <tadzik> well, depends on what I mean

[08:44] <tadzik> but it avoids a virtual method call

[08:45] <tadzik> (virtual in C++-speak)

[08:51] <tipdbmp> So how do I write my own accessors for has $.attr is rw; that are used outside the class as: $obj.attr; # get accessor for $.attr  and $ob.attr = 5; # set accessor for $.attr;

[09:03] <tipdbmp> multi method attr { $!attr } and multi method attr($value) { $!attr = $value) work, but $obj.attr(5); # is the set accessor, while the autogenerated set accessor allows $.attr = 5; 

[09:04] <tadzik> r: class A { has $!attr; method attr($a) is lvalue { $!attr = $a } }; A.new.attr = 5

[09:04] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Cannot call 'trait_mod:<is>'; none of these signatures match:‚ê§:(Mu:U $child, Mu:U $parent)‚ê§:(Attribute:D $attr, :rw(:$rw)!)‚ê§:(Attribute:D $attr, :readonly(:$readonly)!)‚ê§:(Attribute:D $attr, :box_target(:$box_target)!)‚ê§:(Routine:D $r, :rw(:$rw)!)‚ê§:(Rout‚Ä¶

[09:04] <tadzik> pffft!

[09:07] *** xinming_ joined
[09:08] <moritz> is rw

[09:08] <tadzik> r: class A { has $!attr; method attr($a) is rw { $!attr = $a } }; A.new.attr = 5

[09:09] <p6eval> rakudo cecc9f: OUTPUT¬´Not enough positional parameters passed; got 1 but expected 2‚ê§  in method attr at /tmp/_IBD_rzp23:1‚ê§  in block  at /tmp/_IBD_rzp23:1‚ê§‚ê§¬ª

[09:09] <tadzik> hrm

[09:09] <tadzik> ah, yeah

[09:09] <tadzik> it should return a Proxy probably

[09:10] <moritz> r: class A { has $!attr; method attr() is rw { $!attr } }; my $x = A.new; $x.attr = 5; say $x.attr

[09:10] <p6eval> rakudo cecc9f: OUTPUT¬´5‚ê§¬ª

[09:10] <tadzik> oh, cool :)

[09:11] <tadzik> moritz++

[09:11] *** xinming left
[09:16] <tipdbmp> Okay... I still don't get how I can "validated" what value the set accessor assigns to the $!attr;

[09:18] <tipdbmp> using the $x.attr = <something>; syntax

[09:30] *** dakkar joined
[09:39] *** kresike joined
[09:39] <kresike> hello all you happy perl6 people

[09:42] <jnthn> tipdbmp: Well, using a subset type is a good way

[09:43] <jnthn> Otherwise it'll have top be a proxy

[09:43] <jnthn> *to

[09:47] *** cognominal joined
[09:49] <jnthn> moritz: spectest fail list for sink isn't terribly long

[09:57] <nwc10> jnthn: I'm not hugely worried about memory ups or downs w.r.t. forcing a poor little ARM board to build Rakudo for the sake of building Rakudo

[09:57] <nwc10> also, bad news - I failed to spot the factor of 1000 difference - the purloined charger is for *mini* USB, not *micro* USB.

[09:58] <jnthn> nwc10: oh noes!

[09:58] *** brrt joined
[09:59] <nwc10> yes. back to where we were 24 hours ago. :-/

[09:59] <sorear> What's this in reference to?

[10:01] <nwc10> what am I burbling on about - stuff I can get at zero cost that powers hardware I already had.

[10:01] <nwc10> note, "zero cost" seems to be the fun bit here - saving unloved things from landfill (or quietly sleeping in a box somewhere)

[10:02] <sorear> nwc10: I just feel like I'm missing the context here.  did I accidentally delete a p6c mailing related to the Pi compilation saga more recent than this summer?

[10:02] *** hypolin left
[10:08] *** fhelmberger joined
[10:09] <nwc10> sorear: no, a comment I made here on IRC about 2 or 3 days ago, saying it's slower again. About 24 hours. But does complete and pass tests

[10:18] *** anuby left
[10:18] <sorear> I see

[10:23] *** bbkr_ left
[10:31] *** brrt left
[10:34] *** brrt joined
[10:34] <arnsholt> masak: You familiar with a book called "Tecknens rike"?

[10:37] *** bbkr joined
[10:37] *** bbkr left
[10:40] <dalek> niecza: da13155 | sorear++ | / (6 files):

[10:40] <dalek> niecza: Allow different compartments to have different load paths and compiler hooks

[10:40] <dalek> niecza: review: https://github.com/sorear/niecza/commit/da13155685

[10:41] <sorear> sleep&

[10:51] *** masak left
[10:53] *** masak joined
[10:54] <masak> good antenoon, #perl6

[10:54] <tadzik> hello hello

[10:59] <masak> arnsholt: yes, I have that book here on my shelf.

[10:59] <masak> arnsholt: I almost, but now quite, met the author.

[11:01] <masak> lue: re redeclarations in the REPL not giving an error: that's fairly consistent with redeclarations in Perl 6 in general not giving an error.

[11:01] <arnsholt> Oh, that's a shame. I came across it accidentally recently. It's quite interesting

[11:02] *** mucker joined
[11:02] <masak> lue: re "the appearance of working", I think you found a bug. lue++

[11:02] *** cognominal left
[11:03] *** gootle left
[11:03] <masak> https://gist.github.com/4110132 -- surely this doesn't look right?

[11:04] <masak> when the corresponding statements are put in a file, Rakudo currently dies when parsing the third statement.

[11:05] *** gootle joined
[11:05] *** gootle left
[11:05] <masak> rn: my $a = 42; $a = 43; my $a = 5; say $a

[11:05] <p6eval> niecza v22-33-gda13155: OUTPUT¬´Potential difficulties:‚ê§  Useless redeclaration of variable $a (see line 1) at /tmp/eZH4qY53Je line 1:‚ê§------> [32mmy $a = 42; $a = 43; my $a [33m‚èè[31m= 5; say $a[0m‚ê§‚ê§5‚ê§¬ª

[11:05] <p6eval> ..rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Redeclaration of symbol $a‚ê§at /tmp/2LWYeAWef0:1‚ê§¬ª

[11:05] <masak> Niecza has it right, IMO.

[11:05] *** Su-Shee_ joined
[11:09] *** Su-Shee left
[11:11] *** cognominal joined
[11:11] <jnthn> masak: We don't have any worry/panic distinction yet

[11:12] <jnthn> masak: repl thing is fine

[11:13] <jnthn> every line is a new scope

[11:13] <jnthn> the utility of a repl is greatly reduced if you can't redeclare things. We allow it just through lexical scoping.

[11:14] <jnthn> so, working as designed

[11:16] *** brrt left
[11:21] *** cognominal left
[11:22] <jnthn> masak: oh, I see the issue...it somehwo gets the wrong value at the end

[11:22] <jnthn> wtf

[11:30] *** cognominal joined
[11:34] *** brrt joined
[11:36] *** cognominal left
[11:39] *** cognominal joined
[11:41] *** Kharec left
[11:41] *** brrt left
[12:03] <masak> jnthn: right.

[12:03] * masak submits rakudobug

[12:04] *** wamba left
[12:04] *** Su-Shee_ is now known as Su-Shee

[12:07] <masak> jnthn: I know about the REPL and scopes. also, as I argued above in my response to lue, even if the REPL *didn't* create a new scope with every line, it still should allow redeclarations just fine, because Perl 6 in general does.

[12:07] *** Kharec joined
[12:10] <masak> in http://blogs.perl.org/users/shlomi_fish/2012/11/three-command-line-utilities.html -- I'm curious what resources rindolf's countdown prototype ended up consuming, and how the script looked.

[12:14] *** mtk joined
[12:23] *** tokuhiro_ left
[12:23] *** tokuhiro_ joined
[12:28] *** mtk left
[12:28] *** mtk joined
[12:28] *** mtk left
[12:29] *** mtk joined
[12:36] *** Psyche^ joined
[12:37] <jnthn> masak: yes, but the repl shouldn't warn

[12:37] <jnthn> and normall things should

[12:37] *** cognominal left
[12:39] *** Patterner left
[12:39] *** Psyche^ is now known as Patterner

[12:41] *** cognominal joined
[12:46] *** cognominal_ joined
[12:48] *** cognominal left
[12:56] <masak> jnthn: I agree.

[12:57] <jnthn> Getting @*WORRIES etc in place should not be too hard

[12:57] <masak> I'm reading http://research.microsoft.com/pubs/170528/msr-tr-2012-79.pdf with interest. about a quarter way through.

[12:58] <masak> from the text: "The heart of reference immutability is that a reference's permission applies transitively. Any new references acquired through a reference with a given permission cannot allow mofidications that the root reference disallows."

[12:58] <masak> that seems to me to be a component that Perl 6 has been missing, sometimes to its detriment.

[13:00] <jnthn> Looks like another attempt to solve the has @.x; style issues

[13:00] <masak> for example, the spec says that arrays made immutable (by being passed as a readonly parameter, or by being returned from a readonly accessor) should have immutable elements.

[13:00] <masak> jnthn: right.

[13:00] <masak> there's a great p6l thread about that somewhere.

[13:00] <jnthn> yeah, that's not been a problem anybody has really desired to attack.

[13:00] <masak> sorear is saying that he hasn't seen a cure that wasn't worse than the problem, IIRC.

[13:00] <masak> so far in this paper, this cure looks quite sane and pleasant.

[13:00] <jnthn> That's probably a big part of why :)

[13:01] <masak> I say this as a total threads/concurrency layman, though.

[13:01] <jnthn> Scanning through, at least looks worth reading.

[13:07] *** wamba joined
[13:08] *** cognominal_ left
[13:12] *** cognominal_ joined
[13:36] *** pmurias joined
[13:36] <pmurias> hi

[13:36] <pmurias> jnthn: can the gotos in rules jump to a label in a different rule?

[13:45] * masak re-reads the bits about "lexotic" and realizes he now understands this concept fully

[13:45] <jnthn> pmurias: never

[13:46] <masak> pmurias: S04 says you cannot goto into a lexical scope if that scope has parameters that need special initialization.

[13:46] <masak> so you cannot goto past a parameter-binding boundary.

[13:46] <masak> well, not into it. out of it is fine.

[13:47] <pmurias> masak: the goto is in pir

[13:47] <masak> oh, then it's even simpler, I think.

[13:47] <masak> goto in PIR simply doesn't work across routine boundaries.

[13:48] *** Kharec left
[13:48] <masak> if you wanted to do some of the exotic goto moves Perl 6 permits in PIR, you'd have to emulate it somehow with some other construct.

[13:49] *** SamuraiJack left
[13:53] <pmurias> jnthn: what does $!restart in Cursor contain?

[13:59] *** cognominal_ left
[14:00] <pmurias> should commits on rakudo-js be reported by dalek?

[14:00] <tadzik> I'd enjoy that :)

[14:04] *** atrodo joined
[14:05] * masak too

[14:10] <masak> wow, precompilation really does make a huge difference in startup speed.

[14:11] <tadzik> it does

[14:11] *** flightrecorder left
[14:13] *** flightrecorder joined
[14:13] <masak> hm, I seem to have neglected to remove lib/Event.pm from crypt when adding it to Adventure::Engine. fixing.

[14:13] *** FROGGS left
[14:13] *** PacoAir joined
[14:13] <dalek> Perlito: 131944d | (Flavio S. Glock)++ | TODO-perlito5:

[14:13] <dalek> Perlito: Perlito5 - TODO update; add more references to documentation and tests

[14:13] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/131944def0

[14:16] <masak> jnthn, moritz: good news, everyone: crypt and Adventure::Engine now work under precompilation. jnthn++!

[14:17] *** am0c joined
[14:18] <tadzik> did they not?

[14:18] *** tokuhiro_ left
[14:19] *** tokuhiro_ joined
[14:20] *** Kharec joined
[14:21] *** jlaire joined
[14:22] *** kaleem left
[14:22] *** hash_table joined
[14:22] *** cognominal joined
[14:23] <masak> tadzik: up until a few days ago, no.

[14:24] <tadzik> oh, recent fixes by jnthn++

[14:25] *** drbean left
[14:25] *** rurban_ joined
[14:26] *** FROGGS joined
[14:27] <pmurias> masak: how do I make dalek report commits for a repo?

[14:27] *** hash_table left
[14:28] *** drbean joined
[14:32] <masak> good question.

[14:32] <tadzik> it's documented in perl6/mu somewhere, I thin

[14:33] <colomon> how do you capture a Pair in a signature?

[14:36] <masak> r: sub foo(Pair $p) { say "captured!" }; foo( (bar => 42) )

[14:36] <p6eval> rakudo cecc9f: OUTPUT¬´captured!‚ê§¬ª

[14:37] <masak> colomon: was your question really "how do you pass a pair when calling a routine?"

[14:37] *** rurban_ left
[14:37] <colomon> no, I'm looking for 

[14:38] <colomon> for @array-of-pairs -> $key => $value { blah }

[14:38] <colomon> except I know that's not right.

[14:38] <colomon> (At least, I don't think it is)

[14:38] <colomon> ooo, crashed google chrome!

[14:38] <colomon> I've worked around my question for the moment, but I'm still curious.

[14:39] <masak> these is a way, using nested signatures. it's quite neat.

[14:39] *** kaleem joined
[14:40] <masak> rn: for foo => 1, bar => 2 -> $p (:$key, :$value) { say $key }

[14:40] <p6eval> niecza v22-33-gda13155: OUTPUT¬´Potential difficulties:‚ê§  $p is declared but not used at /tmp/McEYGRsG2V line 1:‚ê§------> [32mfor foo => 1, bar => 2 -> [33m‚èè[31m$p (:$key, :$value) { say $key }[0m‚ê§  $value is declared but not used at /tmp/McEYGRsG2V line 1:‚ê§------> [32mfor foo => 1, ‚Ä¶

[14:40] <p6eval> ..rakudo cecc9f: OUTPUT¬´foo‚ê§bar‚ê§¬ª

[14:40] <masak> rn: for foo => 1, bar => 2 -> $ (:$key) { say $key }

[14:40] <p6eval> niecza v22-33-gda13155: OUTPUT¬´Any()‚ê§Any()‚ê§¬ª

[14:40] <p6eval> ..rakudo cecc9f: OUTPUT¬´Unexpected named parameter 'value' passed in sub-signature‚ê§  in block  at /tmp/G4lUSkUKX5:1‚ê§‚ê§¬ª

[14:40] <masak> r: for foo => 1, bar => 2 -> (:$key, :$value) { say $key }

[14:40] <p6eval> rakudo cecc9f: OUTPUT¬´foo‚ê§bar‚ê§¬ª

[14:41] <colomon> masak++

[14:42] <colomon> do the names have to be key and value?  (I'm guessing yes.)

[14:42] *** cognominal left
[14:42] * colomon looks again and is sure.

[14:44] <masak> since they bind to attributes in the Pair, yes.

[14:44] <masak> r: for foo => 1, bar => 2 -> (:key($k), :value($v)) { say $key }

[14:44] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Variable $key is not declared‚ê§at /tmp/3UbT5wIzW8:1‚ê§¬ª

[14:45] <masak> r: for foo => 1, bar => 2 -> (:key($k), :value($v)) { say $k }

[14:45] <p6eval> rakudo cecc9f: OUTPUT¬´foo‚ê§bar‚ê§¬ª

[14:45] <masak> however; as above.

[14:45] <masak> r: for foo => 1, bar => 2 -> (:key($k), :value($)) { say $k }

[14:45] <p6eval> rakudo cecc9f: OUTPUT¬´foo‚ê§bar‚ê§¬ª

[14:45] <masak> n: for foo => 1, bar => 2 -> (:key($k), :value($)) { say $k }

[14:45] <p6eval> niecza v22-33-gda13155: OUTPUT¬´Any()‚ê§Any()‚ê§¬ª

[14:45] <masak> sorear: awww :)

[14:45] * masak submits nieczaissue

[14:46] <colomon> masak++ again

[14:51] *** am0c left
[14:57] *** stopbit joined
[14:57] <colomon> rn: say "this is a test".trans(" " => "\\ ")

[14:57] <p6eval> rakudo cecc9f, niecza v22-33-gda13155: OUTPUT¬´this\is\a\test‚ê§¬ª

[14:58] <colomon> ooo... it's character based rather than string based.

[14:58] *** GlitchMr joined
[14:58] <moritz> rn: say "this is a test".trans([' '] => ['\\ '])

[14:58] <p6eval> rakudo cecc9f, niecza v22-33-gda13155: OUTPUT¬´this\ is\ a\ test‚ê§¬ª

[14:59] <moritz> colomon: not in this form

[14:59] <colomon> moritz: 

[14:59] <colomon> moritz++

[14:59] <colomon> but .subst is easier for the "one change" case anyway.

[14:59] <colomon> I was just all excited because I'd come up with a practical use for .trans minutes before.  ;)

[15:00] <colomon> err, needs global in the subst case.

[15:00] * colomon appears to be having a lots of small stupid mistakes sort of morning.

[15:02] <masak> .trans violates the Principle of Least Surprise.

[15:04] <moritz> .trans tries to do too many things at once

[15:04] <GlitchMr> This .trans function actually reminds me strtr() in PHP.

[15:04] <GlitchMr> http://php.net/strtr

[15:05] <GlitchMr> Not sure if copying bad PHP design is good idea.

[15:07] <masak> as far as I know, Perl 6 hasn't copied anything from PHP's design.

[15:08] <GlitchMr> Yet, .trans looks similar to strtr() from PHP.

[15:09] <masak> they seem to have roughly the same function.

[15:09] <masak> they are quite different in their signatures.

[15:10] <masak> which still doesn't make Perl 6's .trans intuitive.

[15:10] *** birdwindupbird left
[15:10] <masak> I kinda liked pmichaud's suggestion to put the multi-char translation on .subst instead.

[15:10] <GlitchMr> In PHP, it looks like strtr("this is a test", [' ' => '\\ '])

[15:10] <GlitchMr> Close enough

[15:10] <masak> the only counterargument to that is that it may be too late to do so.

[15:11] <masak> GlitchMr: I couldn't see from that page what the PHP function does in the case of several keys matching at the same time. (i.e. I see no LTM going on)

[15:12] <masak> GlitchMr: also, there's no mention of regexes as keys.

[15:12] <pmurias> masak: it doesn LTM

[15:12] <pmurias> * does

[15:12] <pmurias> masak: according to the example

[15:13] <GlitchMr> masak: "The longest keys will be tried first."

[15:13] <GlitchMr> From PHP documentantion.

[15:13] <GlitchMr> documentation*

[15:13] <GlitchMr> I guess this counts as LTM.

[15:13] <masak> pmurias: oh, indeed.

[15:13] *** skids joined
[15:13] <masak> it does.

[15:13] <jnthn> pmurias: $!restart contains the thing to call back into the restart the match and produce the next cursor

[15:14] <masak> .trans is the only routine I know that expects an argument on the form [...] => [...]

[15:14] <masak> that alone is a bit confusing, I guess.

[15:14] <masak> I've seen TimToady get this one wrong ;)

[15:15] <jnthn> masak: If you had a ticket for the AE precomp bug, feel free to clsoe it...I thought you did but when I looked I didn't see it

[15:17] <masak> I didn't have a separate one.

[15:18] <masak> the one referred to when I discovered my problem is the one you marked testneeded the other day.

[15:20] <jnthn> ah, cool, we pre-empted duping :)

[15:23] *** sorenso left
[15:24] <masak> moritz++ did. :)

[15:25] *** jlaire left
[15:26] <jnthn> yeah. Now the operator one is fixed too, I think we may have fixed all the module precomp issues...

[15:28] <jnthn> ...which is pre-req for the automatically maintained pre-comp cache

[15:30] <[Coke]> r: say "bar" ~~ /:i frb | BAR/;

[15:30] <p6eval> rakudo cecc9f: OUTPUT¬´ÔΩ¢barÔΩ£‚ê§‚ê§¬ª

[15:30] <[Coke]> is the :i there supposed to impact BAR or just frb? 

[15:30] <jnthn> I'm not immediately sure

[15:30] <[Coke]> ok. there's a ticket on that one. you fixed:

[15:30] <jnthn> Would have to go read STD more closely

[15:31] <[Coke]> r: say "bar" ~~ /:i [frb | BAR]/;

[15:31] <p6eval> rakudo cecc9f: OUTPUT¬´ÔΩ¢barÔΩ£‚ê§‚ê§¬ª

[15:31] <[Coke]> where is more obviously the right thing.

[15:31] <jnthn> right, but that wasn't a precedence issue, but an NFA one.

[15:31] *** prammer left
[15:32] <masak> [Coke]: I read the :i in /:i frb | BAR/ as affecting both alternatives, and here's why: it affects the rest of the "scope", where a scope is either the whole rule, or the innermost enclosing [] or () group.

[15:32] * colomon is watching jnthn on his other computer....

[15:32] <masak> [Coke]: I don't know if that reasoning holds water, but that's my intuition about it.

[15:34] <jnthn> colomon: oh my...what am I doing? :P

[15:34] <colomon> presentation on the perl 6 debugger

[15:34] <jnthn> ah, the lightning talk :)

[15:35] <colomon> ah, yes it is.  I thought it was a full lecture

[15:35] <colomon> well, I guess it won't distract me from work for long!

[15:36] <colomon> jnthn++

[15:36] <jnthn> but playing with the debugger might :P

[15:36] <[Coke]> masak: if you can get someone to agree with you, that's a closable ticket.

[15:36] <colomon> jnthn: indeed it might.  but I must press on with $work!

[15:36] <masak> well, hearing what pmichaud or TimToady has to say on the topic would be interesting.

[15:37] <colomon> wait, you just debugged a macro!?!

[15:37] <masak> :D

[15:38] <masak> not sure what happens if the macro actually puts a big chunk of code there, though.

[15:38] <[Coke]> r: say 659-86

[15:38] <p6eval> rakudo cecc9f: OUTPUT¬´573‚ê§¬ª

[15:39] <jnthn> masak: hopefully, the right thing

[15:39] <dalek> rakudo-js: 84d6d4e | (Pawe≈Ç Murias)++ | run_tests:

[15:39] <dalek> rakudo-js: fix run_tests

[15:39] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/84d6d4e7ec

[15:39] <dalek> rakudo-js: 7ef98d5 | (Pawe≈Ç Murias)++ | / (3 files):

[15:39] <dalek> rakudo-js: [nqp] pass 33

[15:39] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/7ef98d53f7

[15:39] <dalek> rakudo-js: 1087377 | (Pawe≈Ç Murias)++ | / (2 files):

[15:39] <dalek> rakudo-js: [nqp] pass 39

[15:39] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/10873778fb

[15:40] <jnthn> a mildly-distracted reading of STD seems to support Rakudo's :i scoping

[15:40] *** hash_table joined
[15:41] *** aindilis left
[15:44] <masak> jnthn: "the right thing" being... what, exactly? the debugger stepping through scores of statements while highlighting the original macro call on each step?

[15:47] <masak> the event types of Adventure::Engine: https://gist.github.com/4111373

[15:48] <jnthn> masak: I suspect it'll step into the quasi

[15:48] <jnthn> Or let you single tep through it

[15:50] <jnthn> masak: try it ;)

[15:51] <dalek> rakudo-js: b0154c7 | (Pawe≈Ç Murias)++ | / (3 files):

[15:51] <dalek> rakudo-js: [nqp] implement slurpy positionals, pass test 40

[15:51] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/b0154c748d

[15:51] <masak> jnthn: ok :)

[15:54] *** kaleem left
[16:01] *** brrt joined
[16:03] *** bowtie joined
[16:03] *** cognominal joined
[16:04] <jnthn> decommuten &

[16:05] <dalek> rakudo-js: 15def0e | (Pawe≈Ç Murias)++ | / (3 files):

[16:05] <dalek> rakudo-js: [nqp] pass 37,implement slurpy named arguments

[16:05] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/15def0e2d1

[16:07] <kresike> bye folks

[16:07] *** kresike left
[16:07] <dalek> rakudo-js: 86c9904 | (Pawe≈Ç Murias)++ | run_tests:

[16:07] <dalek> rakudo-js: [nqp] add passing test 42 to run_tests

[16:07] <dalek> rakudo-js: review: https://github.com/pmurias/rakudo-js/commit/86c9904e82

[16:13] *** REPLeffect joined
[16:13] *** sisar joined
[16:14] *** spider-mario joined
[16:21] <masak> ===SORRY!===

[16:21] <masak> Missing or wrong version of dependency 'lib/Adventure/Engine.pm'

[16:21] <masak> so... if I *don't* precompile, but have an old .pir file sitting around, Rakudo dies?

[16:22] <masak> hm, no, that does not seem to be it.

[16:22] * [Coke] wonders if we need a command line argument for rakudo to wipe any precompiled files.

[16:22] <masak> oh!

[16:23] <masak> so this is what happens.

[16:23] <masak> B depends on A.

[16:23] <masak> precompile both.

[16:23] <masak> then change A and precompile it.

[16:23] <masak> now if you *don't* re-precompile B, you'll get the above error.

[16:24] *** domidumont left
[16:25] <masak> or, put differently, precompiling a module will break all the modules dependencies unless you precompile them also.

[16:25] <masak> module's*

[16:26] <[Coke]> without keeping track of everything that was precompiled's dependencies, that seems thorny.

[16:27] <masak> well, a softer fallback would be to use the .pm version of the module.

[16:35] *** xillver left
[16:41] *** grondilu joined
[16:41] <pmurias> shouldn't precompilation happend automatically?

[16:41] <moritz> eventuelly, yes

[16:46] <masak> if it did, this problem would be nonexistent, yes.

[16:47] <masak> so far I've been staying away from precompilation because it seemed to have many problems.

[16:47] <masak> I'd rather have slow startup and consistency than fast inconstencies.

[16:48] <masak> the "Missing or wrong version" error message isn't the end of the world. the cause is easily identifiable, and easily fixable.

[16:48] <masak> but it seems a bit harsh to throw such a message at a downstream module user who just happened to upgrade an upstream module on her system.

[16:49] <masak> especially since the .pir files are always secondary artifacts, and the .pm files are always available.

[16:52] *** mucker left
[16:53] *** cognominal left
[16:54] *** cognominal joined
[16:57] <[Coke]> so which is preferably? fall back to .pm on conflict, or re-precompile on conflict?

[16:57] <[Coke]> *preferable

[16:58] <[Coke]> I don't mind seeing the occasional warning from niecza about compiling the setting, as a data point.

[16:58] <pmurias> is the precompilation always done in the same way or do people pass compilation flags

[16:58] <pmurias> ?

[16:59] <masak> I've never passed compilation flags to precompilation, or heard of anyone who did.

[16:59] *** Kharec left
[17:00] *** brrt left
[17:00] * pmurias passes vmlibs in a cargo culted rakudo-js Makefile

[17:00] *** FROGGS left
[17:00] <masak> [Coke]: falling back to .pm is "safe", in that it'll always work. but slow.

[17:01] *** flightrecorder left
[17:01] <masak> [Coke]: re-precompile is going above and beyond the call of duty... but what I'd expect from Perl 6, if there are no risks associated with it.

[17:01] <pmurias> but that's too nqp

[17:01] <pmurias> s/too/in

[17:02] * jnthn back

[17:02] <pmurias> if we re-precompile automatically wouldn't it make sense to move to a fully automatic soultion and get rid of the makefiles?

[17:02] *** cognominal left
[17:03] <masak> gladly.

[17:03] <jnthn> Yes, but it's really hard to get it right

[17:04] <jnthn> People and OSes have all sorts of opinions on where the pre-compiled stuff should be stored.

[17:04] <jnthn> Probably it takes O(weeks) to make it work at all (probably enabled by an environment variable), then O(months) to make it so most people like it...

[17:06] <pmurias> so you are waiting for volunteers? ;)

[17:07] <jnthn> pmurias: I'm very happy if somebody steps up to do it.

[17:07] *** wamba left
[17:07] *** MayDaniel joined
[17:08] <jnthn> Well, maybe best is what I take care of making it work at all and get the Windows side taken care of, and leave @other to sort out the Linux, OSX, BSD etc details of it.

[17:08] <jnthn> Because there's lots of folks who use/know about those, and where stuff should be put. But I ain't one of them. :)

[17:09] <pmurias> &

[17:10] *** cognominal joined
[17:12] <cognominal> rn:  say :($a) ~~ \(1)

[17:12] *** pmurias left
[17:12] <p6eval> niecza v22-33-gda13155: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Action method fakesignature not yet implemented at /tmp/RIlBvoteAa line 1:‚ê§------> [32msay :($a[33m‚èè[31m) ~~ \(1)[0m‚ê§‚ê§Action method sigterm not yet implemented at /tmp/RIlBvoteAa line 1:‚ê§------> [32msay :($a)[33m‚èè[31m‚Ä¶

[17:12] <p6eval> ..rakudo cecc9f: OUTPUT¬´False‚ê§¬ª

[17:12] <jnthn> cognominal: ur doin it backwards

[17:13] <jnthn> r: say \(1) ~~ :($a)

[17:13] <p6eval> rakudo cecc9f: OUTPUT¬´True‚ê§¬ª

[17:13] <cognominal> thx

[17:14] <cognominal> that makes sense

[17:22] *** thou joined
[17:26] *** Kharec joined
[17:28] *** raiph left
[17:33] * TimToady ponders whether it would be more useful to make that bind only to a pre-existing $a variable, since you can always write :($) to mean the other

[17:40] <cognominal> TimToady, is there way to unpack structures like signatures do outside function calls?

[17:42] <TimToady> what do you mean by "unpack"?

[17:43] <TimToady> if you mean "introspect", there are ways to do that, but if you mean "get data out of them", then signatures never contain data

[17:43] <TimToady> they only say where to put data

[17:44] <TimToady> which has to be elsewhere in a lexpad or object

[17:44] <jnthn> r: my ($a, *@rest) := \(1, 2, 3); say $a; say @rest;

[17:44] <p6eval> rakudo cecc9f: OUTPUT¬´1‚ê§2 3‚ê§¬ª

[17:44] <jnthn> cognominal: you mean ^

[17:44] <jnthn> ?

[17:44] *** Kharec_ joined
[17:45] <TimToady> in that case the "my" is declaring the actual locations, yes

[17:45] <TimToady> so the sig knows where to bind the data to

[17:45] *** Kharec left
[17:45] <jnthn> Aye.

[17:45] *** cognominal left
[17:47] <TimToady> how hard would it be to make :($a, *@rest) := \(1,2,3) bind to existing variables in the current scope?

[17:48] <TimToady> that is, when there's no declarator on the :()

[17:49] <TimToady> this is currently seeming like a saner set of semantics than just ignoring the names

[17:49] <TimToady> and potentially useful

[17:50] <TimToady> certainly fakesignature has its own rule in STD, so we can know when we're in that situation

[17:50] <jnthn> TimToady: Just taken a look...I don't think it'd be hard ot make work.

[17:50] <jnthn> *to

[17:52] <TimToady> we might need to relax the sig parsing rules a bit to allow variables that are not lexicals

[17:52] *** cognominal joined
[17:52] <TimToady> so in addition to $!foo we might be able to bind existing globals and such

[17:53] <cognominal> Nov 19 18:45:30 <cognominal>	Also S06 uses the expression pattern matching both for this unpacking and for regex,  Are they different operations, with regex there is not structure to be recognized but some pattern (sic) in a string while there are already a structure from which one extract information when unpacking using signatures. Or regex could be eventually applied to other things than strings? In that case, signature would be a specialization of

[17:53] <cognominal>  these extented regexen

[17:53] <cognominal> Nov 19 18:49:55 <cognominal>	my :( $a ) := 1  # that would be a use of signature outside functions. Not interesting unless when doing unpacking

[17:53] <cognominal> Nov 19 18:50:21 <cognominal>	:( my $a, $b  ) := 1, 2  # that would be a use of signature outside functions. Not interesting unless when doing unpacking

[17:53] <cognominal> Nov 19 18:51:05 <cognominal>	one could imagine using an existing variable, and declare a new one at once

[17:53] <cognominal> sorry about my bad connexion and the lame xchat

[17:54] <cognominal> I have to read the web irc log to figure out if what I say goes thru

[17:54] <TimToady> okay, need to backlog, I guess...

[17:57] <cognominal> TimToady: apparently my line of thougt was parallel to yours :)

[17:58] *** Kharec_ left
[18:00] <TimToady> we could perhaps also allow :() within a normal signature to bind the current argument to a fake signautre referencing existing variables

[18:00] <TimToady> though that's a bit more problematical from a closure point of view

[18:00] *** wamba joined
[18:02] <jnthn> TimToady: Hm, I don't think we need to complicate signatures any more

[18:02] *** Kharec joined
[18:03] <jnthn> TimToady: Normal signatures can already bind to attributes and rw accessors.

[18:03] <jnthn> Binding to existing ours...well, that's just a lexical alias.

[18:03] <jnthn> Don't need to provide a way to bind into more complex package names.

[18:04] <TimToady> nodnod

[18:05] <TimToady> we can fiddle the fakesigs first, and then see if any sane use cases present themselves, then evaluate

[18:05] *** brrt joined
[18:06] <TimToady> for now, one can always bind a fakesig as the first thing inside a function and get the same effect as if it were embedded in the function's signature, I expect

[18:06] *** domidumont joined
[18:07] <cognominal> what are fakesigs? I don't see that in S06. Is it the use of sigs outside fonctions?

[18:07] <TimToady> and it can be argued that, since () in a sig already is declarative, it would be confusing to introduce a non-declarative :() inside an existing sig

[18:07] <TimToady> :() without a declarator

[18:07] <TimToady> (counting function sigs as a kind of implicit 'my' declarator)

[18:08] <jnthn> fwiw, Rakudo already has a very clean separation of the declaration/binding.

[18:08] <jnthn> Typically, we look at a signature and declare all the things it mentions.

[18:08] <jnthn> That's a compile-time thing

[18:08] <jnthn> And the binding of those things is a separate step.

[18:09] <TimToady> if we did do the :() inside sig, it would just be a lookup instead of a declaration, but I do think it might be confusing, and unnecessary

[18:09] <jnthn> back in a bit

[18:10] *** dakkar left
[18:12] *** SamuraiJack joined
[18:12] *** brrt left
[18:13] *** grondilu left
[18:15] <cognominal> TimToady: about the word unpacking intead of introespecting : "unpack" is the word you use in S06.

[18:16] <cognominal> is the context any different? :)

[18:17] *** sisar left
[18:23] <Su-Shee> wow, there isn't much mussing anymore in rakudo.. :)

[18:25] *** jaldhar left
[18:26] *** FROGGS joined
[18:28] *** flightrecorder joined
[18:29] <jnthn> No, but there's still some things we mussed do... :)

[18:30] <Su-Shee> jnthn: still looks nice all the green in the feature matrix. :)

[18:30] *** cognominal_ joined
[18:30] <jnthn> Su-Shee: Yes, I'm happy with the progress there :)

[18:32] *** jaldhar joined
[18:32] *** cognominal left
[18:33] <Su-Shee> jnthn: it also looks like things are actually getting to some definition of finish line so many people insist on..

[18:37] *** Chillance joined
[18:41] <jnthn> Aye, though people insist on faster too :)

[18:42] <Su-Shee> and they're going to want books and then modules and then applications.. :)

[18:42] <Su-Shee> and then t-shirts.. and mugs.. and .. 

[18:42] <jnthn> Don't give them mugs! They'll throw them and then who knows what we get... :P

[18:44] <dalek> perl6-roast-data: c55d7f9 | coke++ | / (4 files):

[18:44] <dalek> perl6-roast-data: today (automated commit)

[18:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/c55d7f9649

[18:44] <dalek> perl6-roast-data: 707a004 | coke++ | / (3 files):

[18:44] <dalek> perl6-roast-data: today (automated commit)

[18:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/707a004131

[18:44] <dalek> perl6-roast-data: fe0db5a | coke++ | / (4 files):

[18:44] <dalek> perl6-roast-data: today (automated commit)

[18:44] <dalek> perl6-roast-data: review: https://github.com/coke/perl6-roast-data/commit/fe0db5a802

[18:45] *** telex left
[18:46] *** telex joined
[18:49] * [Coke] arglebargles, as his primary (work) laptop has to be shipped to corporate for reimaging.

[18:50] *** rurban_ joined
[18:56] <jnthn> TimToady: Got a potential patch here, but SIG_STOMACH... :) 

[18:56] <jnthn> bbiab

[19:03] *** rurban_ left
[19:07] <sorear> good * #perl6

[19:08] *** zjmarlow joined
[19:15] <moritz> \o

[19:20] *** atrodo left
[19:20] <moritz> r: say nqp::p6box_i(nqp::can(1|2, 'randommethod'))

[19:20] <p6eval> rakudo cecc9f: OUTPUT¬´1‚ê§¬ª

[19:20] *** MayDaniel_ joined
[19:20] *** atrodo joined
[19:20] <moritz> jnthn: that's what cause the spectest failures of the qast-sink-1 branch

[19:21] *** atrodo left
[19:21] <moritz> r: say (1|2).?randommethod

[19:21] <p6eval> rakudo cecc9f: OUTPUT¬´No such method 'randommethod' for invocant of type 'Int'‚ê§  in sub AUTOTHREAD_METHOD at src/gen/CORE.setting:2119‚ê§  in  at src/gen/Metamodel.pm:2394‚ê§  in block  at /tmp/b210TB5OVy:1‚ê§‚ê§¬ª

[19:21] *** atrodo joined
[19:22] <moritz> it emits the equivalent for   my \temp = 1|2; temp.sink if nqp::can(temp, 'sink')

[19:23] *** MayDaniel left
[19:23] *** alester joined
[19:26] <moritz> I guess I can work around that with a custom sink method in Junction

[19:28] *** sisar joined
[19:29] *** kaare_ joined
[19:30] <moritz> no, I can't

[19:30] <moritz> it still autothreads :(

[19:30] <moritz> ah no, I'm just silly

[19:31] <moritz> TimToady: what should .sink on a Junction do? sink all eigenstates? or nothing at all?

[19:31] <moritz> (I'm leaning towards the former)

[19:33] <masak> what's the observable difference?

[19:34] *** sisar left
[19:35] *** sisar joined
[19:36] <sisar> i'm really fed up with these errors on cygwin: "[main] perl6 8740 child_info_fork::abort: address space needed by 'io_ops.dll' (0x360000) is already occupied"

[19:36] <sisar> rebasing doen't work :(

[19:36] <sisar> (http://www.cygwin.com/faq/faq-nochunks.html#faq.using.fixing-fork-failures)

[19:36] <sisar> i'm unable to install panda because of this error

[19:36] <moritz> masak: I guess the differences are pretty obscure

[19:37] <sisar> any pointers to resolve this ?

[19:37] <moritz> masak: like, if you have a junction of file handles, and one of them is a Failure from a failed open()

[19:39] <skids> <joke>Obviously perl6 should fork a process for each state and then die one of them</joke>

[19:39] *** cognominal_ left
[19:44] *** cognominal_ joined
[19:44] <[Coke]> sisar: I don't think any of the core perl6 folks use cygwin - rurban on #parrot on irc.perl.org is probably the best parrot/rakudo/cygwin resource.

[19:46] <TimToady> moritz: "sink" means "force any lazy side effects to happen", so if it's possible to have lazy side effects in a junction, it should probably fire them off; it might or might not make sense to emit a "Useless use of junction" warning though

[19:47] <sisar> [Coke]: ok, thanks.

[19:47] *** SamuraiJack left
[19:47] <TimToady> or you can view it as a "pretend you're eager but don't go to any extra effort to actually return the results"

[19:48] *** sisar left
[19:48] *** cognominal joined
[19:49] *** cognominal_ left
[19:49] <TimToady> arguably junctions in sink context could be used to express parallelism, but the analog with shell's & and | is imperfect

[19:49] <skids> Wouldn't a sink on a junction constitute testing any Failures therein for Bool, and thus marking them handled?

[19:50] <TimToady> why would sink supply a Bool context?

[19:50] <TimToady> generally sinking a Failure should throw an exception

[19:50] <TimToady> s/a/an unhandled/

[19:51] <skids> OK, well, the exact opposite of what I said, then :-)

[19:51] * skids sometimes has logical dyslexia

[19:52] *** cognominal_ joined
[19:52] <TimToady> is that sonotlexia or notsolexia?

[19:53] <skids> I'm more often precisely wrong than "off to the side"

[19:53] <TimToady> well, physicists think that's better

[19:53] <skids> This tends to lead to a lot of naval gazing.

[19:53] <TimToady> "not even wrong" is a slam, coming from a physicist

[19:54] *** cognominal left
[19:54] <skids> It actually is a benefit, because I'm usually sure that the answer is one of two things.

[19:55] <TimToady> well, not if the actual answer is on the continuum somewhere in the middle :)

[19:56] <TimToady> maybe you should go into politics :)

[19:56] *** Kharec left
[19:56] <skids> If it is, then I will precisely identify the point opposite where it is, and seize on it as the answer :-)

[19:56] <TimToady> that works if it's really a circle instead of a continuum

[19:57] <TimToady> like both fascism and communism wrap around to totalitarianism on the opposite side from freedom

[19:58] <skids> No, on a continuum, it still works, you just take the answer equidistant from the midpoint, on the other side :-)

[19:58] <TimToady> perhaps you should find the midpoint, where you can be both right and wrong simultaneously

[19:59] <skids> I have friends like that.

[20:02] *** Kharec joined
[20:02] *** brrt joined
[20:03] <skids> Anyway, since actually using a junction involves testing it for Bool, then the only way to actually throw a Failure that's in a Junction would be through a special construct, so if we want to be able to do that, sink should probably, or we'll need another construct.

[20:04] *** fhelmberger left
[20:05] <brrt> well, p6, i'm not sure if it counts, but ruby might have outdone you in the madness departement

[20:05] <brrt> http://blog.headius.com/2012/11/refining-ruby.html - dynamically scoped methods!

[20:06] *** cognominal joined
[20:06] *** cognominal_ left
[20:11] *** cognominal_ joined
[20:12] *** cognominal left
[20:12] *** sorenso joined
[20:13] *** kurahaupo joined
[20:16] *** domidumont left
[20:17] <FROGGS> masak: this can be closed, right? https://rt.perl.org/rt3/Ticket/Display.html?id=114246

[20:17] <dalek> rakudo/qast-sink-1: 6cc0d6c | moritz++ | src/core/Junction.pm:

[20:17] <dalek> rakudo/qast-sink-1: work around nqp::can(Junction, $anything) always returning True

[20:17] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/6cc0d6c4d9

[20:17] <dalek> rakudo/qast-sink-1: 318e56c | moritz++ | src/ (3 files):

[20:17] <dalek> rakudo/qast-sink-1: Revert "only sink when --sink command line option is provided"

[20:18] <dalek> rakudo/qast-sink-1: 

[20:18] <dalek> rakudo/qast-sink-1: This reverts commit 3f12074d13a51b2602039ece5f95454055e8abd0.

[20:18] <dalek> rakudo/qast-sink-1: review: https://github.com/rakudo/rakudo/commit/318e56c9d9

[20:19] <skids> r: "OHAI".say if 1&2&fail(3)&4 + 4

[20:19] <p6eval> rakudo cecc9f:  ( no output )

[20:20] <skids> r: say 1&2&fail(3)&4 + 4

[20:20] <p6eval> rakudo cecc9f:  ( no output )

[20:20] <moritz> skids: note that fail() returns from the current routine

[20:21] <skids> That last eval throws in Oct star.

[20:22] <TimToady> brrt: yes, they'be been working on refinements for several years now; it makes me glad we decided to keep a strict separation between lexical dispatch and OO dispatch

[20:23] <masak> FROGGS: needstest, I guess.

[20:23] *** cognominal__ joined
[20:23] <FROGGS> ya

[20:23] <FROGGS> I'll have a look if there is something already

[20:24] <[Coke]> FROGGS - if you find one, please add a comment pointing back to the ticket, and mention the test file when you close it out. Danke.

[20:24] <masak> skids: "naval gazing" is the one where you stare at ships, no?

[20:24] *** cognominal_ left
[20:25] <FROGGS> [Coke]: thats the plan ;o)

[20:25] <[Coke]> FROGGS++

[20:26] <skids> masak: right you are!

[20:26] <sergot> hi o/

[20:26] <skids> r: "HIYA".say if 1&2&Failure.new(X::AdHoc.new())&4 + 4

[20:26] <p6eval> rakudo cecc9f:  ( no output )

[20:26] <tadzik> hello hello

[20:26] <skids> r: say 1&2&Failure.new(X::AdHoc.new())&4 + 4

[20:27] <p6eval> rakudo cecc9f: OUTPUT¬´use of uninitialized value of type Str in string context  in block  at /tmp/Wnus6mvrfh:1‚ê§‚ê§use of uninitialized variable  of type Any in string context  in block  at /tmp/Wnus6mvrfh:1‚ê§‚ê§use of uninitialized value of type Str in string context‚ê§use of uninitialized var‚Ä¶

[20:27] <masak> tadzik! \o/

[20:27] <tadzik> masak! \o/

[20:29] <tipdbmp> my $x, $y, $z = 1, 2, 3; # Is incorrect?

[20:29] <tipdbmp> How come?

[20:30] <moritz> tipdbmp: precedence

[20:30] <FROGGS> = is tighter than ,

[20:30] *** cognominal__ left
[20:30] <FROGGS> there was a reason, but I forgot :/

[20:31] <moritz> well, there are two ='s

[20:31] <moritz> the item assignment one if the LHS has $ sigil

[20:31] <moritz> it has tighter precedence than =

[20:31] <moritz> and the list assignment one if the sigil on the left is @ or %

[20:31] <moritz> which has looser precedence than =

[20:32] <moritz> so both   my @a = 1, 2, 3   and  $a = 1, $b = 2, $c = 3  work

[20:32] <moritz> but you can't make that *AND* $x, $y, $z = 1, 2, 3 work

[20:32] <tipdbmp> What about: my $x, $y, $z;

[20:32] <moritz> r: my $x, $y, $z

[20:32] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Variable $y is not declared‚ê§at /tmp/F1ezlTV6mz:1‚ê§¬ª

[20:34] <[Coke]> r: my ($x, $y, $z);

[20:34] <p6eval> rakudo cecc9f:  ( no output )

[20:37] <brrt> r: my ($x, $y, $z) = 1, 2, 3; say $x + $y +$z;

[20:37] <p6eval> rakudo cecc9f: OUTPUT¬´6‚ê§¬ª

[20:38] <zjmarlow> hi.  is there a way to get the current line number of an open file or does it have to be kept track of separately?

[20:38] <tipdbmp> One more place to get rid of the parens? =)

[20:39] <brrt> r: say IO.^methods

[20:39] <p6eval> rakudo cecc9f: OUTPUT¬´‚ê§¬ª

[20:39] <brrt> that is odd

[20:39] <brrt> it works for me

[20:39] <brrt> r: say IO.^methods.perl

[20:39] <p6eval> rakudo cecc9f: OUTPUT¬´()‚ê§¬ª

[20:39] <brrt> oh, wait, sandbox?

[20:40] <geekosaur> likely

[20:43] <dalek> roast: 266acab | (Tobias Leich)++ | S11-modules/import.t:

[20:43] <dalek> roast: Note about corresponding RT ticket

[20:43] <dalek> roast: review: https://github.com/perl6/roast/commit/266acab391

[20:44] <TimToady> tipdbmp: no, we're trying to discourage use of my ($x, $y, $z) because it tends to encourage people to group unrelated declarations; I'd much rather see a separate 'my' for each declaration, with its own initializer.

[20:44] * jnthn back

[20:44] <FROGGS> TimToady: ... and maybe its own comment describing what the var does

[20:45] <skids> zjmarlow: basically not all file reads happen as lines, so the offered interface is in characters, not lines ($*IN.tell).  But if you are using a single loop, $*IN.kv -> $linenum, $content works.

[20:45] <skids> erm, $*IN.lines.kv that is

[20:46] <lue> It seems the SCGI module isn't getting the entire netstring. Could this be an issue with IO::Socket::INET?

[20:46] <dalek> rakudo/nom: bf472b0 | jonathan++ | src/Perl6/Actions.pm:

[20:46] <dalek> rakudo/nom: Make :($a, $b) := \(1, 2) update $a and $b.

[20:46] <dalek> rakudo/nom: 

[20:46] <dalek> rakudo/nom: Previously, the spec had such a construct doing nothing. We'll try it

[20:46] <dalek> rakudo/nom: like this for a bit to see how it works out. Note, shortest patch that

[20:46] <dalek> rakudo/nom: could possibly work; probably needs some tuning.

[20:46] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bf472b05a0

[20:47] <jnthn> TimToady: Doesn't bust any spectests, so let's give it a go. :)

[20:50] <moritz> jnthn: in the qast-sink-1 branch,  t/spec/S02-types/bool.t now segfaults violently

[20:50] <moritz> .. on one of my machines

[20:50] <moritz> on the other, it's fine

[20:52] <moritz> apart from that, the spectests look good

[20:52] <jnthn> moritz: That test file has been known to do that occasionally with little pattern.

[20:52] <jnthn> moritz: It sometimes does in the daily roast runs

[20:52] <moritz> jnthn: oh, ok

[20:52] <jnthn> And not other days

[20:52] <jnthn> So I'd not hold merging off for it.

[20:52] *** dedis left
[20:52] <moritz> I'm pretty sure I want to wait until after the release

[20:53] <jnthn> My last attempt to track that segfault down didn't go far. :(

[20:53] <jnthn> OK, that works too :)

[20:53] <jnthn> Probably safer given that this can have quite some side-effects...

[20:53] <jnthn> Probably good to smoke the cheese too

[20:53] *** ifim joined
[20:55] <moritz> my next experiment is to turn off the 'eager' that is now emitted for for-loops

[20:55] <jnthn> ah, yes

[20:55] <jnthn> One of us probably should look at getting MapIter to sink in a good way too

[20:55] <moritz> so far I just forward it to .eager

[20:55] *** Bzek left
[20:55] <jnthn> Yeah

[20:56] <jnthn> That's enough for now

[20:56] <moritz> oh, and another problem

[20:56] <jnthn> But really it needs to throw away the results

[20:56] <moritz> the last statement in the mainline isn't evaluated in sink context

[20:56] <jnthn> Yeah, that's a bit tricky

[20:57] <jnthn> Because in an eval, or at the REPL, it shouldn't be.

[20:57] <mj41> rhr: https://gist.github.com/4113825

[20:57] <jnthn> Provided we can find a way to distinguish, though, it's easy to fix: just push an lookup of Nil onto the statement list :)

[20:58] *** Bzek joined
[20:59] <mj41> hi, File::Spec::Unix is broken (rakudo HEAD) ... https://gist.github.com/4113825 https://github.com/FROGGS/p6-File-Spec/blob/master/lib/File/Spec/Unix.pm#L23

[21:00] <FROGGS> mj41: whats wrong with it?

[21:00] <moritz> r: eval 'sub MAIN() { say 42 }'

[21:00] <p6eval> rakudo cecc9f: OUTPUT¬´42‚ê§¬ª

[21:00] <moritz> :(

[21:00] <FROGGS> r: https://gist.github.com/4113825

[21:00] <p6eval> rakudo cecc9f: OUTPUT¬´===SORRY!===‚ê§Couldn't find terminator $stop at line 4, near "]+[\\/|$]] "‚ê§¬ª

[21:01] <moritz> jnthn: and we have to worry about stuff like putting traits into sink context (or not, dunno)

[21:01] <moritz> ie where we cross the nqp <-> rakudo boundary

[21:03] <skids> .oO(multi sub a ( --> Int) {...}; multi sub a ( --> Str) {...}; :(Int $a) := a(); # the return of wantarray?)

[21:05] <moritz> there's a reason we abolished want() :-)

[21:05] * moritz -> sleep

[21:06] <arnsholt> skids: Polymorphism on return values aren't possible

[21:06] * masak perks up

[21:06] <masak> arnsholt: why not?

[21:07] <masak> arnsholt: I mean, not even if you *specify* the return type in the signatures, as here?

[21:07] <arnsholt> The problem is selecting the right candidate when the multi is called

[21:07] <skids> Well, I notice they aren't in .signature as of now.

[21:07] <arnsholt> (Modulo my memory)

[21:07] <masak> arnsholt: indeed.

[21:08] *** kaare_ left
[21:08] <masak> but right now I can't construct an example that feels really problematic :)

[21:08] <arnsholt> Getting it right in the general case requires a sufficiently intelligent optimizer I think (heck, I wouldn't be surprised if it were undecidable)

[21:09] <arnsholt> Well, "my $foo = return-value-polymorphic()" can be a problem, 'cause now you have to trace through the program to find clues as to the possible types of $foo

[21:09] *** GlitchMr left
[21:09] <arnsholt> Suddenly it's very, very non-local to the invocation

[21:10] <jnthn> If you want such things, make a return value that contextualizes appropriately.

[21:10] <skids> But then we're essentially back to wantarray on the inside of subs, just using lots of buts.

[21:10] <FROGGS> cool, only one fail in current spectest!

[21:11] <jnthn> skids: It's not wantarray 'cus you're not deciding anything in the sub.

[21:11] <mj41> FROGGS: Does it make sense to fix it or should we wait for rakudo fix?

[21:12] <FROGGS> mj41: I still dont know whats broken

[21:12] * colomon thinks building rakudo just shut down his linux box...

[21:12] <skids> Well, you're doing a lot of extra work then, unless the contextualization happens lazily.

[21:12] <mj41> FROGGS: see updated https://gist.github.com/4113825

[21:12] <FROGGS> ohh

[21:12] <FROGGS> let me test

[21:13] <jnthn> skids: Still less work than solving an undecidable problem :P

[21:14] <skids> .oO(if it were only allowed explicitly...)

[21:14] <jnthn> Module. :)

[21:14] <skids> :-)

[21:14] * colomon is now pretty sure that must be it, because it just happened again.

[21:14] <jnthn> colomon: Um.

[21:14] <colomon> jnthn: no worries, it's something wrong with my linux box.

[21:14] <jnthn> How can compiling something shut down a machine?

[21:14] <skids> overheat?

[21:14] <jnthn> Oh, maybe that :)

[21:15] <jnthn> Well, with all those hot new features...

[21:15] <FROGGS> ;o)

[21:15] *** brrt left
[21:15] <colomon> I don't think it's overheat... at least, the box doesn't seem hot and the one time I monitored the temp it was stable.

[21:16] <colomon> somehow the box is borked and when processes use too much memory it just turns off.  as far as I can tell, anyway.

[21:16] <lue> for the record, rakudo compilation could easily shutdown my old laptop :)

[21:16] <colomon> I mean, turns off for sure.

[21:16] <mj41> FROGGS: patch here https://gist.github.com/4113825 ... or I can fork and send pull request or I can ask for commit bit :-) 

[21:16] <colomon> the memory thing is conjecture but seems to match what I'm seeing.  I guess it might be too much processing in general, hard to separate the two.

[21:17] <colomon> the machine is five or six years old now, I think I'm just going to have to break down and replace it.

[21:17] <lue> colomon: I've experienced seemingly-random shutdowns before, I would agree that it's your computer.

[21:17] <FROGGS> mj41: I just pushed a patch, all tests are fine on my box

[21:17] <mj41> FROGGS: thx

[21:17] <lue> s/computer/computer's memory/

[21:17] <colomon> I'm sure it's not a rakudo issue, other than rakudo being a bit of a pig.  ;)

[21:17] <FROGGS> mj41: whats your github id?

[21:18] <mj41> FROGGS: https://github.com/mj41/

[21:18] <FROGGS> mj41: you have commit bit

[21:19] <mj41> FROGGS: thanks

[21:19] <skids> colomon: don't feel bad.  My BIOS menus overheat my laptop to the point that linux will turn itself off on boot. BIOS coders are savages.

[21:21] <lue> colomon: Even though this new comp has 1GiB RAM (which compiles rakudo well enough), I still wish we didn't have The CORE.setting Step‚Ñ¢

[21:22] * skids guesses that ‚Ñ¢ has a tight precedence

[21:22] <FROGGS> I'm pretty happy with my box, stage parse takes 78s

[21:23] <colomon> lue: the box in question has 8 GB ram.

[21:23] <lue> For me it's now about 1500s (IIRC). Which is a big improvement over my old laptop, which had a time on the last rakudos I tried of ‚àûs :)

[21:25] <lue> colomon: that's.. interesting. I always blamed my RAM/computer age, in any case. (My last best guess is some issue with the kernel, but that's as specific an idea as I can get.)

[21:36] *** hash_table left
[21:37] *** xilo joined
[21:44] <lue> would I be correct in assuming nqp/src/QAST is where the nqp->pir step occurs?

[21:47] <jnthn> lue: Yes, specifically in Compiler.pm and Operations.pm

[21:50] <masak> two of my favorite files of all time.

[21:50] <jnthn> masak: Weirdo :P

[21:50] <jnthn> They do the ugly stuff :)

[21:51] <masak> much nicer than previous iterations. :)

[21:51] <masak> it's HOP! it's OO!

[21:51] <jnthn> .oO( just wait until you see the JVM versions :P )

[21:51] <lue> Ah, that's why you like them.

[21:51] *** sirrobert left
[21:51] <jnthn> masak: Well, yeah, I wrote it so of course it's a paradigm mashup :P

[21:52] * lue is again considering porting NQP to LLVM

[21:53] <jnthn> lue: The trouble is how LL it is...

[21:54] * masak .oO( jnthn, paradigm DJ )

[21:54] <lue> well, if the effort fails miserably, there's always NQP to C/++ (and therefore to Clang) :)

[21:54] <masak> lue: whatever happened to your plans to use Adventure::Engine for something?

[21:54] <masak> I was looking forward to that... :)

[21:55] <lue> I got distracted by a new computer in the first days of August, and I have yet to be reinterested in IF games (I haven't even installed gargoyle yet!)

[21:56] <masak> ;)

[21:57] <masak> well, I'm diving back into all those modules, so now would be a good time to ask me stuff.

[21:58] *** MayDaniel_ left
[21:58] <lue> The past week or so I've gotten into Perl 6 For The Web (hence the SCGI question earlier), and am currently pondering that NQP->LLVM thing again :)

[21:59] <diakopter> lue: you'd need to write a GC (or use a packaged one)

[22:01] <lue> bright side of life: I get to learn what a GC does, in thrilling high definition^W^W detail! :)

[22:02] * masak advises taking smaller bites of life :)

[22:04] <diakopter> the original acronym of LLVM meant VM in the "instruction set that sits above the hardware" sense, not the "language runtime/environment" sense

[22:04] <lue> (What is likely helping my optimism is how oddly fun I've found assembler the one or two times I've used it (for simple,small things, but still))

[22:07] *** cognominal joined
[22:10] *** skids left
[22:12] <arnsholt> lue: An alternative approach to Perl 6 for the Web would be wrapping ZMQ with NativeCall and doing HTTP with Mongrel2

[22:13] <arnsholt> There're some holes in Zavolaj that need workarounds ATM, but I think it's feasible

[22:13] <lue> arnsholt: ye olde CGI works fine, it just the P6 FastCGI and SCGI modules that I haven't yet gotten to work (right now I think I prefer SCGI of the two)

[22:14] *** sorenso left
[22:19] *** erkan left
[22:21] *** snearch joined
[22:27] <tadzik> good knight

[22:28] *** Exodist joined
[22:30] <lue> jnthn: did you mean .nqp instead of .pm ?

[22:30] *** spider-mario left
[22:31] *** hash_table joined
[22:33] <jnthn> lue: yes

[22:35] *** pmurias joined
[22:37] <pmurias> lue: the problem with targeting LLVM is that you would have to write loads of runtime stuff (basically a whole VM on top of it)

[22:38] <pmurias> lue: targeting C and LLVM is basically the same level of abstraction

[22:38] <diakopter> (except llvm can compile and run bitcode at runtime in the same process)

[22:39] <pmurias> you could compile and dynamically load C 

[22:39] <lue> Well, my main goal with the port is to have Perl 6 compiled to native machine code. It's not as much of an issue now, but I still think it'll be (a) fun (learning experience).

[22:40] <lue> (At least I didn't pick GCC. That never looked like a lot of fun)

[22:40] <diakopter> lue: perhaps easier would be to think about a JIT for an interpreter

[22:40] <pmurias> the javascript backend compiles Perl 6 to native code (through V8)

[22:40] *** erkan joined
[22:40] *** erkan left
[22:40] *** erkan joined
[22:42] * lue is not aware of other nqp backends

[22:42] <pmurias> lue: and there's a lot of things I could use help with that (a lot of them moderately easy like write extra tests for nqp)

[22:42] <pmurias> https://github.com/pmurias/rakudo-js

[22:44] *** zjmarlow left
[22:44] *** zjmarlow joined
[22:44] <lue> (I also have a small, dismal no-supporting-evidence hope that LLVM instead of PIR makes the CORE.setting step faster)

[22:48] <pmurias> that depends how good the LLVM backend is

[22:49] <lue> of course. Like I said: small, dismal, no-supporting-evidence :)

[22:51] <lue> Hm. I'm thinking that instead of trying to learn two things at once, I should start by implementing a joke language in LLVM, and then moving to nqp.

[22:52] <masak> (small steps)++

[22:54] * lue feels a package manager metaphor floating around somewhere...

[22:54] <jnthn> 'night

[22:54] <TimToady> o/

[22:55] *** xilo left
[22:55] *** Kharec left
[22:56] *** PacoAir left
[22:57] *** snearch left
[23:03] <masak> 'night, #perl6

[23:03] <lue> good knight, masak o/

[23:04] <TimToady> now where did I put my round table...

[23:04] <TimToady> std: 1 !~~~ 2

[23:04] <p6eval> std d38bbd0: OUTPUT¬´Potential difficulties:‚ê§  ~~~ is not an infix operator (to suppress warning put space between infix ~~ and prefix ~) at /tmp/_gNDMDsqp_ line 1:‚ê§------> [32m1 !~~[33m‚èè[31m~ 2[0m‚ê§ok 00:00 42m‚ê§¬ª

[23:06] *** zjmarlow left
[23:08] *** zjmarlow joined
[23:10] *** tokuhiro_ left
[23:10] *** wamba left
[23:10] *** tokuhiro_ joined
[23:13] *** xilo joined
[23:17] *** zjmarlow left
[23:23] *** whiteknight joined
[23:24] *** bapa left
[23:40] *** stopbit left
[23:40] *** skids joined
