[00:30] *** sudokode joined
[00:33] *** mcglk left
[00:34] *** mcglk joined
[00:36] *** sudokode left
[00:40] *** sudokode joined
[00:44] <[Coke]> sorear, masak: yay, I could that on irclog just before boarding. ;) (+%)

[00:44] *** sudokode left
[00:45] <[Coke]> Now the last bug remaining is trying to find the "compreg"

[00:45] <[Coke]> d Partcl compiler.

[00:50] *** tokuhiro_ joined
[01:00] *** flexibeast left
[01:04] *** FROGGS_ joined
[01:06] *** cjbot left
[01:08] *** FROGGS left
[01:08] <sorear> [Coke]: boarding?

[01:15] *** spider-mario left
[01:25] *** jeffreykegler left
[01:25] *** jeffreykegler joined
[01:30] *** broquaint left
[01:31] *** sudokode joined
[01:39] *** am0c_ joined
[01:46] *** mcglk left
[01:47] *** mcglk joined
[01:57] *** mcglk left
[01:58] *** mcglk joined
[02:07] *** dbr left
[02:17] <[Coke]> sorear: yes, I've been talking to you from hotels and airports.

[02:17] * [Coke] is now at his final destination for the day.

[02:18] *** cjbot joined
[02:27] *** tokuhiro_ left
[02:31] *** whiteknight left
[02:35] *** mucker joined
[02:48] *** thelazydeveloper left
[02:50] *** jeffreykegler left
[03:02] *** am0c left
[03:04] *** am0c_ left
[03:15] *** adu joined
[03:27] <[Coke]> er, not "I could that", but "I caught that"

[03:30] *** mucker left
[03:31] *** MikeFair_ joined
[03:31] <MikeFair_> sorear: hey ther

[03:31] <sorear> yo.

[03:31] <MikeFair_> sorear: Actually I was on #perl6 on the Perl Network

[03:31] <MikeFair_> sorear: no matter though, all here now :)

[03:32] <MikeFair_> sorear: So you were saying (and I was doing my best to keep up) :)

[03:33] <sorear> mm, it that a thing?

[03:35] <MikeFair_> Guess we're just a bunch of confused souls over there not realizing we belong here? 

[03:35] <sorear> I think most of them joined so that they could tell off other people who join

[03:35] <sorear> but in doing so they've prevented the channel from expiring

[03:36] <MikeFair_> Well I just left (and then there were 9)

[03:36] <MikeFair_> :)

[03:39] <MikeFair_> There are two ways to interact with the GAC: the Global Assembly Cache Tool (gacutil.exe) and the Assembly Cache Viewer (shfusion.dll).

[03:39] <MikeFair_> sorear: Does that help?

[03:40] <sorear> 1. it needs to be problematic

[03:40] <sorear> 2. the mono gac layout is such that it cannot be quickly scanned on Linux, unless there's a database somewhere I'm missing

[03:40] <sorear> s/problematic/programmatic/

[03:42] <MikeFair_> 1. totally agreed, 2. Mono has to load them, how does it do it?

[03:42] *** bubaflub left
[03:42] <MikeFair_> sorear: I guess I'm just not seeing why you have to scan?  Are we building a bunch of *.pm files?

[03:42] <sorear> when mono or mcs wants to load an assembly from the gac, it *knows the name*

[03:43] <sorear> oh, I thought you were recommending a scan

[03:43] <sorear> Note

[03:43] <sorear> You must have administrator privileges to use Gacutil.exe.

[03:43] <diakopter>  /o\

[03:43] <MikeFair_> sorear: I wonder what shfusion.dll is like...

[03:44] <sorear> it sounds like it's probably related to shell32.dll

[03:44] <sorear> anyways, i don't think a gac scan would buy much at all

[03:45] <MikeFair_> sorear: And one thing I've never known is whether or not the GAC is literally a Cache (like a local copy perhaps that's stored after a JIT has processed it) or is it the actual installation location

[03:45] <sorear> it is an installation location

[03:45] <sorear> it does not do line-fill/eviction like most "cache"s

[03:46] <MikeFair_> that location is known at run-time?

[03:47] <sorear> huh?

[03:47] <MikeFair_> sorear: Perhaps I'm missing something, you were saying that you didn't know the name of the assembly when Perl tried to load it

[03:48] <sorear> MikeFair_: I think at this point I don't understand the problem you are trying to solve

[03:48] <sorear> Currently the syntax is CLR::("assembly name")::Namespace::Class

[03:49] <MikeFair_> You were having some crazy ideas on how to redo niecza's name binding mechanism so 'use gtk:from<clr gtk-sharp>' Just Works

[03:50] <MikeFair_> And I thought, likely mistakenly, finding out what assembly to load was a problem

[03:51] <sorear> MikeFair_: No, the problem is with niecza's current insane semantics for scoping of nested names

[03:51] <MikeFair_> I was also saying that the System.Reflection classes could help with creating an auto-binding

[03:51] <sorear> on the CLR side, the problem is solved

[03:52] <sorear> sorry

[03:52] <MikeFair_> ahh ok

[03:54] <MikeFair_> So if i'm hearing you correctly, niezca currently needs to be told about an assembly because dynamically finding it based on the namespace is problematic due to scoping for nested names?

[04:04] <sorear> no.

[04:05] <sorear> it is _by design_ that you need the assembly name

[04:05] *** colomon left
[04:05] <sorear> assembly names are the mechanism by which the CLR tames type name conflicts

[04:06] *** Telgalizer joined
[04:07] <MikeFair_> sorear: ok.... and the GAC for being able to install the same named thing multiple times for different versions

[04:07] <sorear> MikeFair_: the GAC is a weird pariah thing

[04:08] <sorear> it's mostly there to hold copies of System.dll et al

[04:08] <sorear> anything third-party should go into your application directory, the CLR looks there for assemblies

[04:08] <MikeFair_> sorear: I guess, I see it as how they can install .Net 2.0 and .Net 3.0 on the same box and have each directory holds its own version of "System"

[04:08] * MikeFair_ nods.

[04:09] *** birdwindupbird joined
[04:09] <MikeFair_> sorear: Why isn't the namespace sufficient for taming type name conflicts?

[04:09] <sorear> well, where it gets interesting is transitivity

[04:09] <sorear> say module D comes in two versions, D 1.0 and D 2.0, both of which export a type D.D

[04:10] <sorear> module, I mean assembly, B, requires D 1.0

[04:10] <sorear> assembly C requires D 2.0

[04:10] <MikeFair_> sorear: There's a few pages I was reading the other month on when and how you can nest namespaces, mask type names, etc

[04:10] <sorear> D versions 1.0 and 2.0 are not compatible

[04:10] <sorear> assembly A requires both B and C

[04:10] <sorear> this works

[04:11] <sorear> it works because of the way the CLR handles class names as subordinate to assembly full names (including version & pubkey)

[04:11] <sorear> Perl 6 is actually supposed to do something very similar

[04:12] <MikeFair_> Right and those get embedded in at compile time in CLR land?

[04:12] <sorear> use Foo:auth<cpan:DCONWAY>:ver<1.0>

[04:12] <sorear> yes

[04:13] <MikeFair_> sorear: But in practice I assume everyone just writes use Foo::auth making the construct nearly useless?

[04:13] <sorear> no.

[04:13] <MikeFair_> sorear: Are is it been a adopted and accepted as a best practice?

[04:13] <MikeFair_> s/Are/Or

[04:14] <MikeFair_> s/is/has/

[04:14] <sorear> because Foo::auth means nothing unless there is a "use Foo" in scope, and the use statement can define, lexically, an implicit auth/ver

[04:14] <sorear> well, it hasn't been adopted mostly because it hasn't been implemented yet :D

[04:14] <MikeFair_> hehe - that could be a problem ;)

[04:15] <MikeFair_> Well I guess what you're now saying then is that if you replaced "cpan" with "clr" you could do something similar?

[04:15] <MikeFair_> (Or am I skipping ahead too many steps and ending up in the wrong place)

[04:18] <sorear> subtly wrong

[04:18] <sorear> the idea with :auth is that it represents some kind of naming authority

[04:19] <sorear> a URI which represents someone or something that issues names

[04:19] * MikeFair_ nods.  "Makes sense"

[04:19] <sorear> if cpan:TOM and cpan:DICK decide to use the same module name, there won't be a problem because the authorities are different

[04:19] <sorear> presumably cpan:TOM will not use the same name for unrelated modules, if he's right in the head

[04:20] <sorear> and cpan: IDs are unique becuase they are centrally allocated

[04:20] <MikeFair_> right

[04:21] <sorear> there is an additional name adverb :from which is more appropriate here

[04:21] <sorear> use Foo means use Foo:from<perl6>:auth(*):ver(*)

[04:21] <MikeFair_> naming conflicts are easy once that gets distributed and there isn't a central naming authority

[04:21] <MikeFair_> ahhh

[04:21] <MikeFair_> I think I see where you're going now

[04:22] <sorear> actually there is one more, :name

[04:22] <sorear> when you say 'use Foo' you are importing a module Foo and you are creating an alias Foo in the lexical scope

[04:23] <sorear> usually, you want them to have the same name

[04:23] <sorear> but the lexical alias has to be a valid Perl 6 identifier, and foreign module names don't always oblige

[04:23] <MikeFair_> I can see that

[04:25] <sorear> you might do use SWF:from<clr>:name<System.Windows.Forms>

[04:25] <MikeFair_> Yeah, that's what I was thinking

[04:25] <sorear> as for :auth I would ideally do pk:HASHHERE

[04:25] <MikeFair_> Though I'm not exactly clear on the distinction between from and auth

[04:26] <sorear> with the usual Perl 6 convention that no auth = any auth is fine, I can't be bothered to check

[04:26] <moritz> \o

[04:26] <sorear> o/ moritz

[04:27] <MikeFair_> auth = author? 

[04:27] <MikeFair_> which conceptually stands for some unique namespace?

[04:27] <sorear> use Cecil:from<clr>:ver<0.9.4.0>:auth<pk:0738eb9f132ed756>:name<Mono.Cecil>

[04:28] <sorear> is the most complete syntax

[04:28] <sorear> auth = authority

[04:28] <sorear> think like a certificate authority

[04:29] <sorear> Larry's standard grammar starts with rammar STD:ver<6.0.0.alpha>:auth<http://perl.org>;

[04:29] <sorear> s/^/g/

[04:30] <MikeFair_> yeah I was thinking that "auth" might go really well with a domain name or a standards body

[04:30] <MikeFair_> Something that can provide sanity to the names it hosts

[04:31] <MikeFair_> Can an assembly have the same version and a different public key?

[04:34] *** colomon joined
[04:35] <MikeFair_> auth almost seems like it would be the runtime version

[04:35] <MikeFair_> and pk part of the version

[04:36] <MikeFair_> well maybe not auth

[04:38] <MikeFair_> use Cecil:from<clr 2.0>:ver<v:0.9.4.0,pk:0738eb9f132ed756>:auth<publisher_name>:name<Mono.Cecil>

[04:41] <sorear> you can't put that into ver

[04:41] <MikeFair_> bbiab

[04:41] <sorear> ver is fixed-format

[04:41] <sorear> also, publisher name is not part of the programmatic name of CLR modules

[04:46] *** kaare_ joined
[05:07] *** birdwindupbird left
[05:09] *** birdwindupbird joined
[05:10] <MikeFair_> sorear: Well ok then, that settles that :)

[05:11] <MikeFair_> sorear: auth seems like a great place to put pk :)

[05:12] <MikeFair_> sorear: It's a bummer about version though, kind of prevents coming up with a better way to track versions in the future :)

[05:14] <MikeFair_> sorear: Anyway, regardless of that I can't help but remember how excited I was to read Larry's Apocolypses on what Perl6 was to become, I was thinking so many of the same things at the time I read those

[05:14] <MikeFair_> sorear: a fixed version format seems a trivial price to pay for the rest of all this goodness. :)

[05:15] <sorear> It's linguistically defined so it falls under the language update mechanism

[05:15] <sorear> If Perl 6.3 changes the version syntax, you can enable the new syntax with use v6.3;

[05:16] <sorear> we do a few things differently from the days of the apocalypses. we're much more focused on the present.

[05:25] <sorear> r: my class A::B {}; { my class A::C {}; say A::B }

[05:25] <p6eval> rakudo 196572: OUTPUT«A::B()␤»

[05:27] <sorear> jnthn: low-priority ping

[05:41] *** crab2313 joined
[05:46] *** adu left
[05:48] *** Telgalizer left
[05:50] *** cjbot left
[05:55] <MikeFair_> sorear: There's a lot here that I'm wanting to learn

[06:01] <sorear> MikeFair_: in my last p6eval line or more generally?

[06:01] <sorear> whee, I have a built Rakudo

[06:01] <sorear> 3m26s :D

[06:02] <MikeFair_> sorear: that seems fast

[06:02] <MikeFair_> sorear: more generally

[06:02] <sorear> MikeFair_: I started Niecza in large part because in Q2 2010, with the computer I was using at the time, Rakudo builds were more of a 10h thing

[06:02] <MikeFair_> seeing the word class in Perl code without some pointer next to it will take some getting used to ;)

[06:03] <sorear> "some pointer"?

[06:03] <MikeFair_> ->

[06:03] <MikeFair_> or ::

[06:03] <sorear> what's the connection between class and ::/-> in Perl code?

[06:04] <MikeFair_> sorear: i'm just not used to seeing "class" as a keyword, and the various evolutions in Perl5 (and earlier) have used the module stuff 

[06:05] <MikeFair_> sorear: It's totally a misrepresentation on my part, just a keyword that's new to me for perl.  That's all I'm really saying. :)

[06:09] *** erkan left
[06:09] *** erkan joined
[06:09] <Timbus> i think a more visible difference is using . instead of ->

[06:11] <MikeFair_> Timbus: Yeah that too

[06:11] <MikeFair_> It's going to be cool

[06:11] <MikeFair_> Hey question, i've actually been really impressed with what the .Net stuff has done with enumerations

[06:13] <MikeFair_> Anything special in Perl6 regarding enumerations?  I mean a lot of it probably doesn't apply because of how strict .net is, but I thought I'd ask

[06:15] <benabik> r: enum A <a b c>; say A::a

[06:15] <p6eval> rakudo 196572: OUTPUT«a␤»

[06:16] <sorear> n: enum A <a b c>; say A::a # long name

[06:16] <sorear> n: enum A <a b c>; say a # short name

[06:16] <p6eval> niecza v19-44-g55e895a: OUTPUT«(timeout)[auto-compiling setting]␤»

[06:16] <p6eval> niecza v19-44-g55e895a: OUTPUT«(timeout)[auto-compiling setting]␤»

[06:17] <sorear> ok, I broke niecza on p6eval

[06:17] <MikeFair_> :)

[06:17] <sorear> r: enum A <a b c>; say A::a # long name

[06:17] <benabik> http://perlcabal.org/syn/S12.html#Enumerations

[06:17] <p6eval> rakudo 196572: OUTPUT«a␤»

[06:17] <sorear> b: enum A <a b c>; say A::a # short name

[06:17] <p6eval> b 922500: OUTPUT«0␤»

[06:17] <sorear> r: enum A <a b c>; say A::a # 

[06:17] <p6eval> rakudo 196572: OUTPUT«a␤»

[06:17] <sorear> ignore b

[06:17] <sorear> r: enum A <a b c>; say +A::c # knows its index

[06:17] <p6eval> rakudo 196572: OUTPUT«2␤»

[06:18] <sorear> r: enum A <a b c>; say A::c.WHAT() # knows its type

[06:18] <p6eval> rakudo 196572: OUTPUT«A()␤»

[06:18] <sorear> r: enum A <a b c>; say A::c.perl # long name

[06:18] <p6eval> rakudo 196572: OUTPUT«A::c␤»

[06:18] <MikeFair_> ok that's cool

[06:19] <sorear> r: enum A <a b c>; say +A("c"); say +A(1); # niecza supports using enums as coercers, but niecza is broken right now, let's see if rakudo works too

[06:19] <p6eval> rakudo 196572: OUTPUT«use of uninitialized value of type A in numeric context  in block  at /tmp/9dazyzIKWV:1␤␤0␤1␤»

[06:20] <MikeFair_> ok, so there's this one other thing I've been thinking about lately about replacing the base types of int/float/string with infinite enumerables

[06:20] <MikeFair_> the main reason I've been thinking about it has to do with I/O and internationalization

[06:20] <sorear> what do you mean?  why?

[06:20] <MikeFair_> So let's take int for a second

[06:20] <MikeFair_> 1 2 3

[06:21] <sorear> int isn't infinite, anyway

[06:21] <MikeFair_> Well numeric 

[06:21] <MikeFair_> ok string

[06:22] <MikeFair_> it's not as easy to explain with string

[06:22] <sorear> be advised that type names in Perl 6 are case sensitive and 'int' and 'Int' are entirely different things

[06:22] <sorear> Int is a reference type which points to an integer of arbitrary size

[06:22] <sorear> int is a CPU-level integer

[06:23] <MikeFair_> Ok let's talk Int then

[06:23] <MikeFair_> the idea simply is that the string characters used to represent a number exist inside a character set

[06:23] <MikeFair_> and in different langauges even use different symbols

[06:24] <MikeFair_> and to some extent, the same number can be represented in different basis

[06:25] <MikeFair_> (well they most definitely can it's just not as common to speak about Int outside of base10)

[06:25] <sorear> I have a bad feeling about this.

[06:26] <MikeFair_> The think I was considering was if there was an enumerable type to line up with the character set or locale, it could mapped back to the actual "Int"

[06:26] <sorear> What would be the point?

[06:26] <MikeFair_> The same number could be expressed by casting it through its enumerable

[06:27] <MikeFair_> It creates a presentation layer between the machine and the human

[06:27] <MikeFair_> but it makes it rather transparent to the programmer

[06:28] <sorear> dear #perl6, I am having trouble coming up with a tactful reply

[06:28] <MikeFair_> sounds good

[06:28] <MikeFair_> thanks for listening :)

[06:28] <sorear> so I'm not going to say anything at all

[06:28] * MikeFair_ withdraws his comments. :)

[06:29] <benabik> I'm not following completely, but skimming it looks like "all we need is another layer of indirection".

[06:30] <MikeFair_> the idea was that my application could have a locale, which would implicitly select enumerables that knew how to express the concept of that number in a locale specific way

[06:31] <sorear> enumerables are for things you can enumerate.

[06:31] <MikeFair_> benabik: It's actually more like, We have this layer of indirection that we do poorly or not at all, and maybe there's a better way to do it

[06:31] <MikeFair_> sorear: You can enumerate Integers

[06:31] <sorear> if you want to add a type coercion from Str to Num, say _that_ instead

[06:31] <huf> is this for code or for formatting numbers in a locale-specific way in output?

[06:32] <huf> or do you want strange integer literals that change their meaning depending on locale? or ... i'm lost

[06:33] <MikeFair_> huf: they don't change their meaning, just their representation

[06:33] <huf> ?

[06:33] <sorear> MikeFair_: did you come from [email@hidden.address]
[06:33] <MikeFair_> huf: it's primarily for input and output with an end user

[06:33] <MikeFair_> sorear: umm, no, I take it that's not a compliment. ;)

[06:33] <huf> so this is just serialization

[06:34] <huf> i thought this was about internal representation or literals...

[06:34] <MikeFair_> it's something that crossed my mind when reading about enumerables in .Net that are programmaticly defined

[06:34] <MikeFair_> Like fibonacci

[06:35] <MikeFair_> Doing locale specific representation and input

[06:35] <sorear> MikeFair_: I think you are making the mistake of thinking IEnumerable and System.Enum have anything whatsoever to do with each other

[06:35] <MikeFair_> so yeah it's more about serialization

[06:35] <MikeFair_> sorear: likely

[06:35] <MikeFair_> sorear: plus I'm talking about it in Perl6

[06:36] <MikeFair_> sorear: So yeah, I'm fairly easily convincable that I should be locked up :)

[06:36] <sorear> This is, I am sorry to say, not a p6-ready idea.  We've been shipping compilers for several years now and there will be no modifications to the core language unless you can 1. explain why they are needed in a way convincing to the people whose production code you've just broken 2. implement it in at least one shipping compiler

[06:38] <MikeFair_> sorear: Totally agreed, I'm not asking for changes, god no, and this _should be_ doable in the existing language

[06:38] <MikeFair_> sorear: Or not do it

[06:38] <MikeFair_> sorear: And it shouldn't break any existing code

[06:38] <sorear> Then I don't think I understand you

[06:38] *** araujo left
[06:38] <sorear> It seems like you want to rip out Str and replace it with a gigantic enum

[06:39] <MikeFair_> sorear: More like Str->enum->Int

[06:39] <MikeFair_> sorear: If code chooses to do that

[06:39] <sorear> for a purpose having ... something ... to do with locales

[06:40] <MikeFair_> Yes, to create a distinction between "how we present and receive" a number as separate from the number itself

[06:41] <sorear> well, in an hour or so the #perl6 core folks from Germany, Poland, Norway, and Sweden will be up and we'll be able to have a proper discussion about locales

[06:41] <MikeFair_> Another use case is for unit s convestion

[06:41] <MikeFair_> err conversions

[06:41] <huf> so instead of (pseudocode) int parse_int(str s), you'd like int parse_int(str s, enum map) where the default map is an infinitely large enum that maps "0" => 0 and so on?

[06:42] <huf> but you can replace it to "balin" => 0, "dwalin" => 1, .... ? 

[06:42] <MikeFair_> huf: Yeah, and "infinitely large" to me means "some code does the conversion"

[06:43] <MikeFair_> huf: More like "zero"=>0, "one"=>1

[06:43] <sorear> MikeFair_: What advantage would this have over just calling the correct codein the first place?

[06:44] <MikeFair_> And my code could receive "one hundred thousand and sixty" and the number 1,060 could end up in the Int

[06:45] <sorear> FOUR TWO NINER FOUR NINER SIX SEVEN TWO NINER FIVE

[06:45] * sorear ducks

[06:46] <MikeFair_> sorear: That would be another enumerable type that could be defined 

[06:46] <MikeFair_> sorear: hehe :)

[06:47] <sorear> I recognize that this is not a valid form of argument, but INTERCAL has had this feature for decades.

[06:47] <MikeFair_> sorear: That's interesting.... I didn't know that

[06:47] * MikeFair_ feels less insane.

[06:51] <MikeFair_> Not that any of us would, but we could use a "Roman Numeral" representation

[06:51] <MikeFair_> Or someone who wanted to have a Roman Numeral calculator

[06:51] * sorear waits for MikeFair_ to find and read a definition of INTERCAL

[06:51] <sorear> I would prefer something like Lingua::EN::Number.parse("one")

[06:52] <sorear> it's just a function call, no need to make it fancy

[06:52] <sorear> also Lingua::EN::Number is just a module, so someone other than me can write it

[06:52] <MikeFair_> Create the enumeration type to do the conversion, then take any perl calculator program and set the new interface locale which uses that representation for I/O

[06:54] <MikeFair_> sorear: that sounds similar to what I'm talking about

[06:54] *** araujo joined
[06:54] *** araujo left
[06:54] *** araujo joined
[06:54] <MikeFair_> The idea is that I have no idea what the end user needs to understand the numbers on the screen

[06:55] <sorear> What do you mean by I/O?

[06:55] <sorear> What if the calculator program uses a GUI?

[06:56] <sorear> What if the calculator program outputs to HTTP?  Content-Length: MLMVII isn't going to fly.

[06:56] <MikeFair_> sorear: by I/O I mean the act of taking a character set and converting it to an Int and vice versa

[06:56] <huf> that sounds like two steps

[06:56] <huf> reading in bytes, taking a charset and getting a string

[06:56] <sorear> We don't use character sets here.

[06:57] <huf> and _then_ figuring out what int that string might represent

[06:59] <MikeFair_> huf: yes, this is more about the "figuring out what that string meant" and "outputting the meaning of the Int"

[06:59] <sorear> Anyways we got rid of $" outright so I can't see us _adding_ a globabl variable that controls the stringification of Int

[06:59] <huf> but that's not I/O...

[06:59] <MikeFair_> sorear: The environment shell has one

[06:59] <MikeFair_> huf: My apologies

[07:00] <MikeFair_> huf: What do you call that?

[07:00] <sorear> Str/Int type coercions

[07:00] <MikeFair_> huf: It's such a transparent single thing that rarely gets discussed (at least in the circles I travel in)

[07:01] <sorear> anyways, I had a hell of a time getting Niecza to run on tadzik's machine

[07:01] <sorear> because Niecza uses a partially text-based serialization scheme

[07:02] <sorear> and Polish versions of .NET have a different and incompatible definition of "number" from the US versions, *even when you don't use locale calls*

[07:02] <sorear> I am not going to make 'print 12345' in Niecza locale-sensitive, and I am not budging on this

[07:03] * MikeFair_ nods.

[07:03] <sorear> I don't beleive in perpetuating cycles of abuse

[07:03] <MikeFair_> Me too, my thought is that a lot of the problem is because there's this unexamined assumption of what "print 12345" means

[07:04] <sorear> I could budge on 'say 1234', since say is explicitly intended for human consumption as opposed to protocols

[07:04] <MikeFair_> sorear: fair enough, what about on the input side

[07:04] <sorear> print 12345 means to output the characters "12345

[07:05] <sorear> print 12345 means to output the characters "12345"; we define it precisely because it needs to be usable in network protocols

[07:05] <sorear> Perl has no way of telling whether input comes directly from the user or from another program

[07:05] <MikeFair_> sorear: And those are UTF-8 characters?  or Unicode

[07:06] <sorear> There is no such thing as "UTF-8 characters".

[07:06] <sorear> UTF-8 is the name of a reversable function mapping sequences of Unicode code points to sequences of bytes

[07:07] <sorear> If we err on the side of locale sensitivity, code written in the US which does input from other programs will break, often messily, when run in other locales

[07:07] <MikeFair_> ok, I always just thought of it as an encoding methodology that's different from ASCII and different from Unicode

[07:07] <sorear> If we err on the side of consistency code will be less usable but it won't break outright

[07:07] <sorear> Unicode is not an encoding methodology.

[07:08] <sorear> Some people use Unicode when they mean UTF-16, but they're wrong.

[07:09] <MikeFair_> Ok, I know that when I'm dealing with character data, if I get the encoding wrong things break

[07:09] <sorear> Perl 6 strings are character data, not byte data, so nothing can break there

[07:10] <sorear> Perl 6 also has a Buf type for byte data

[07:10] <MikeFair_> What is the internal representation of characters?  I mean will it take japanese characters?

[07:10] <sorear> File handles have an associated encodings which allow them to be dwimmy

[07:10] <sorear> Unspecified and undetectable.

[07:10] <sorear> It is required to handle all 0x10FFFE Unicode characters.

[07:11] <MikeFair_> sorear: So if Unicode isn't an "encoding methodology" but there are things such as Unicode characters, what do you consider Unicode?

[07:12] <shachaf> If a picture isn't an "encoding methodology" but you can still save it in a file, what do you consider a picture?

[07:13] <sorear> Unicode is a map between 21-bit code points like 0x3080 and abstract characters like 

[07:13] <sorear> む

[07:13] <MikeFair_> ok, yeah, I consider "bitmap" an encoding methodology for a picture

[07:13] <MikeFair_> you can't put a picture in a file

[07:14] <sorear> A character encoding, in general, is an algorithm which transforms sequences of 21-bit code points into (longer) sequences of 8-bit byte

[07:14] <MikeFair_> you can only put a representation in a file

[07:14] <sorear> You're changing definitions in the middle of the conversation.  Stop it.

[07:14] * MikeFair_ nods.

[07:14] <MikeFair_> Yes, clearly I don't have it as clearly delineated as you do yet

[07:15] <sorear> 00:07 < MikeFair_> ok, I always just thought of it as an encoding methodology  that's different from ASCII and different from Unicode

[07:15] <sorear> 00:07 < sorear> Unicode is not an encoding methodology.

[07:15] <MikeFair_> right

[07:15] <sorear> no. I screwed up there.

[07:15] <sorear> I should have said first "You mean 'character encoding'"

[07:16] <moritz> Unicode is mostly a character repertoire

[07:16] <sorear> yay moritz.

[07:16] <moritz> plus some associated semantics

[07:17] <sorear> moritz: if I understand the gist correctly, MikeFair_ wants to do something to the effect of { temp $*OUT.number-formatter = &Lingua::EN::Number::format; Some::Other::Module::prints_to_stdout; }

[07:18] <sorear> moritz: as someone who maybe has actual experience with l10n and numerics, what do you make of this?

[07:19] <moritz> I don't really have that

[07:19] <moritz> the way to do it is to subclass $*OUT.WHAT and add custom print/say methods though, I'd guess

[07:20] *** SamuraiJack joined
[07:22] <MikeFair_> moritz: one of the assumptions is that the methods to do it the right way have to be assignable at runtime

[07:23] <moritz> MikeFair_: erm, what? 

[07:23] <moritz> methods have to be assignable at runtime?

[07:23] <moritz> you can just create the class at compile time, and chose at runtime which one you use

[07:24] <moritz> bog-standard OO polymorphism

[07:24] <sorear> MikeFair_: if you haven't already done so, I recommend you look up what INTERCAL is

[07:25] <MikeFair_> sorear: I did.  I think I understand that you're saying this sounds like a really "trumped up" idea and is something to be made fun of

[07:25] <MikeFair_> sorear: Obviously I haven't read everything about it yet

[07:27] <MikeFair_> moritz: I guess I just considered the routines to convert Str <-> Int weren't "interruptable"

[07:29] <MikeFair_> The main thing I noticed is that programs do "non-US" based thinking and interaction really badly and even the l10n stuff we have is mostly second class and "difficult"

[07:30] <MikeFair_> and yes, I've had to write some, and my conclusion is that "we haven't figured this part out yet"

[07:31] <MikeFair_> The enumerables thing was just a clue that I thought gave me some insight.  One of the problems is that the string "12345" and the Int 12,345  are too closely coupled

[07:32] <moritz> MikeFair_: I think the real problem with that l10n is that most code isn't clear about which conversions are user-visible, and which aren't

[07:32] <moritz> and l10n must only change user-visible conversions

[07:33] <MikeFair_> moritz: Well even our code goes into the compiler as strings.  It's "user visible" to the developer

[07:35] <moritz> I didn't mean the developer with "user"

[07:35] <MikeFair_> moritz: I was dawning on me that the concept "12,345" stored in an 'Int' could a bazillion different representations

[07:35] <MikeFair_> s/I/It

[07:37] <MikeFair_> especially if you start taking into account what the units are as a second part of the 'Int' (like meters, widgets, dollars)

[07:38] <MikeFair_> That's where the enumerated types started showing up.... Maybe they should be full blown classes

[07:40] <MikeFair_> Regardless, you guys have been great at giving me feedback on this here

[07:42] <MikeFair_> It's not a totally baked suggestion yet, and like sorear showed me, I don't have my terminology sorted out yet

[07:42] *** SamuraiJack left
[07:43] <dalek> std: d93fffe | larry++ | / (5 files):

[07:43] <dalek> std: checkpoint STD_P5 mods in case of a bus

[07:43] <dalek> std: 

[07:43] <dalek> std: currently parsing 831 lines of viv

[07:43] <dalek> std: review: https://github.com/perl6/std/commit/d93fffe32b

[07:44] <TimToady> the basic principle is that we don't like accidentally generic code, but you can have intentionally generic code if you declare it so

[07:44] <TimToady> most L18n turns out to be accidentally generic

[07:44] *** SamuraiJack joined
[07:45] <TimToady> so we tend to dislike locales intensely

[07:45] * TimToady goes to see the parade &

[07:46] <MikeFair_> TimToady: That's interesting... My experience was that it was maddeningly abstract because everything had to be done explicitly 

[07:47] <MikeFair_> TimToady: I can appreciate not wanting anything to happen by accident.

[07:49] <MikeFair_> TimToady: I haven't quite decided if I like locales yet or not.  I clearly appreciate the problem they are attempting to solve and think it's a decent first attempt approach at it.

[07:50] <MikeFair_> sorear: And for what it's worth, I'm not about to ask you to rewrite anything.  It's my itch to scratch if I feel so strongly about it right.  :)

[07:51] <MikeFair_> Thanks guys, good night! :)

[08:00] <MikeFair_> sorear: So I couldn't resist following up on Intercal before I went to bed. :)

[08:01] <MikeFair_> sorear: It's pretty hilarious, and I clearly described almost every single one of its idiosyncrocies

[08:01] <MikeFair_> sorear: That's funny

[08:04] <MikeFair_> gnight

[08:04] <sorear> gnight

[08:16] <masak> I can see the use for localization. much of the time even s/use/requirement/.

[08:16] <masak> (morning, #perl6)

[08:17] *** popl left
[08:17] <masak> but I also think I agree about overgeneralizing it being a bad idea.

[08:17] <masak> i18n libs probably become one of those things where you use <10% of the provided functionality, and the rest is dead weight.

[08:18] <sorear> good morning masak.

[08:18] *** Psyche^ joined
[08:18] <sorear> in sweden yet?

[08:19] <masak> sorear: morning. yes, been in Sweden since late wednesday evening. :)

[08:19] *** Patterner left
[08:19] *** Psyche^ is now known as Patterner

[08:20] <masak> sorear: how was the flight back? was the jetlag going west easier to take than the one going east?

[08:22] <sorear> I don't think I particularly experienced it either way

[08:23] <sorear> I went to sleep quite early Fri night, but I think that was a function of not sleeping ~at all Thu night

[08:23] <masak> oh, good to hear.

[08:23] <masak> sometimes jet lag can be quite bad, but it seems you didn't have any of that, then.

[08:26] <sorear> Probably the best way to put it is that jet lag was the least of my problems

[08:27] * shachaf always finds GMT+2 -> GMT-8 much easier than GMT-8 -> GMT+2

[08:28] <sorear> also, when I arrived in GMT+2 I landed in an extremely regimented environment

[08:28] <sorear> Liz and Wendy basically planned out all of our waking hours in advance

[08:31] <masak> shachaf: it seems to vary from person to person. I find going west slightly bothersome, because I *really* need sleep when I get there.

[08:32] <moritz> just limit your travel speed to what you can do by foot (or horse or ship or bycicle)

[08:33] * sorear wonders if you can get jet lag on foot deep in the Arctic

[08:35] <sorear> jnthn or anyone else who is interested: I am toying with some ideas for changing lexical package handling in Niecza and I'd like feedback

[08:42] * masak is interested

[08:42] <moritz> http://www.pm.org/ has a new design

[08:43] <moritz> I am also interested, but I don't think I can provide the feedback level that sorear++ seeks

[08:43] <masak> oh, I don't think so either. still, I'm willing to listen. maybe I can be the teddy bear outside the sysadmin's office ;)

[08:44] <FROGGS_> ya, just listen and nod ;o)

[08:44] * masak nods

[08:44] *** FROGGS_ is now known as FROGGS

[08:45] <FROGGS> I'm interested too btw, but since I started hacking perl6 just a few days ago I won't be of any help

[08:46] <sorear> well we have a couple of obvious use cases that simply don't work

[08:47] <sorear> because lexicality of package names is limited to the first level only

[08:48] <sorear> if you do 'class Foo::Quux {}; { my class Foo::Bar {}; #`( code here ) }' the outer Foo::Quux cannot be seen because Foo is shadowed by the inner lexical package

[08:48] <sorear> so far it seems like a DIHWIDT but it really causes problems with lexical imports

[08:49] <sorear> use Test; use Test::More; # this doesn't look quite so contrived now does it?

[08:49] <sorear> niecza & rakudo have no way to create a true lexical Test::More, so they bind the second import to 'More' in the Test:: package

[08:49] <sorear> but Test:: isn't private to the compilation unit

[08:50] <sorear> you've just polluted the Test module's namespace

[08:50] <sorear> and anything else in your program that does 'use Test' will see Test::More because of the shared package hash

[08:51] <sorear> so basically what I want to do is to allow lexical names like Test::More

[08:51] <sorear> possibly in a preparsed format

[08:51] <masak> rn: class Foo::Quux { our $x = "OH HAI"; }; { my class Foo::Bar {}; say $Foo::Quux::x }

[08:51] <sorear> this would require a bit of smarts in the MY:: name resolver, but it seems doable

[08:52] <p6eval> niecza v19-44-g55e895a: OUTPUT«(timeout)[auto-compiling setting]␤»

[08:52] <p6eval> ..rakudo 196572: OUTPUT«OH HAI␤»

[08:52] <masak> sorear: "cannot be seen..."? it seems to work at least in Rakudo.

[08:52] <masak> as I would very much expect it to.

[08:53] <sorear> masak: rakudo is breaking the other way, then

[08:53] <masak> could you demonstrate "breaking the other way" on p6eval?

[08:53] <sorear> class Foo::Quux { our $x = "OH HAI"; }; { my class Foo::Bar { our $x = "In FooBar"; }; }; say $Foo::Bar::x

[08:53] <sorear> rclass Foo::Quux { our $x = "OH HAI"; }; { my class Foo::Bar { our $x = "In FooBar"; }; }; say $Foo::Bar::x

[08:53] <sorear> r: class Foo::Quux { our $x = "OH HAI"; }; { my class Foo::Bar { our $x = "In FooBar"; }; }; say $Foo::Bar::x

[08:53] <p6eval> rakudo 196572: OUTPUT«In FooBar␤»

[08:53] <masak> hm.

[08:54] <masak> yeah, that seems odd.

[08:55] <sorear> I think STD did something similar to what I'm proposing

[08:55] <sorear> I thought it was insane in 2010 but now I'm coming around

[08:56] * moritz doesn't see the breakage

[08:56] <moritz> there's just one $Foo::Bar::x 

[08:57] <moritz> and you assign twice to it, so of course it prints the second value

[08:57] <sorear> No, I only assign once to it

[08:57] <masak> moritz: it's visible outside the lexical scope of Foo::Bar

[08:58] <sorear> Foo::Bar is a my package, it ought not to be visible from outside the blcok

[08:58] <moritz> masak: sure, because you said "our"

[08:58] <moritz> ok, so the real question is "what does 'our' mean"?

[08:58] <masak> moritz: something *inside* a 'my' package is visible outside of that 'my' package's scope.

[08:58] <sorear> r: class Foo::Quux {}; { my class Foo::Bar { method hi() { "OH HAI" }; }; }; say Foo::Bar.hi

[08:58] <p6eval> rakudo 196572: OUTPUT«OH HAI␤»

[08:58] <sorear> # look moritz no our in sight

[08:59] <sorear> I used to think this is OK, but MikeFair_ made me take a step back

[08:59] <masak> moritz: it'd be like the hash keys of a lexical hash variable could be declared "our" and then made visible outside of the hash's lexical scope.

[08:59] <moritz> masak: that's totally analogous to   { our $x = 3; } ; our $x; say $x

[08:59] <moritz> masak: there you have a lexical block, and you can still see an our-variable from the outside

[08:59] <sorear> r: my class Foo::Quux {}; { my class Foo::Bar { method hi() { "OH HAI" }; }; }; say Foo::Bar.hi

[08:59] <p6eval> rakudo 196572: OUTPUT«OH HAI␤»

[09:00] <masak> moritz: no, it's not analogous. because the package that $x is declared in there is an 'our' package.

[09:00] <moritz> sorear: so the problem is that namespaces with :: only work as 'our'?

[09:00] <sorear> Yes

[09:01] * masak finds that while he may not be very informed on these issues, he certainly is opinionated ;)

[09:01] <sorear> It's clearly working as designed

[09:01] <moritz> ok, crazy idea

[09:02] <moritz> what if we just stored 'Foo::Bar' in a lexical scope?

[09:02] <moritz> if it's my class Foo::Bar { }

[09:02] <moritz> instead of going through the Foo/Bar hierarchy

[09:03] <sorear> moritz: that's what I just proposed, only more concisely.  moritz++

[09:03] <moritz> that means I'm not totally off track then :-)

[09:04] <sorear> the single biggest flaw I see is that it breaks the Foo::Bar - Foo.WHO<Bar> equivalence

[09:04] <sorear> which ISTR jnthn being fond of

[09:05] <moritz> I haven't really thought it through

[09:05] <moritz> what about our-classes?

[09:05] <moritz> if we have

[09:05] <moritz> our class A::B { our class C::D { } }

[09:05] <moritz> and

[09:06] <moritz> our class A { our class B::C { } }

[09:06] <moritz> etc.

[09:06] <masak> I'm for the above idea too. in fact, I thought it worked like that already.

[09:06] <moritz> can we make sure that lookup of A::B::C::D doesn't have to go through ridiculously many possible combinations?

[09:07] <sorear> moritz: I was imagining that lexicality only applies to prefixes, and greedily takes the longest

[09:07] <sorear> I'll go look at what STD is doing

[09:08] * moritz tries to process that

[09:08] <moritz> std: A::B

[09:08] <p6eval> std d93fffe: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'A::B' used at line 1␤Check failed␤FAILED 00:00 40m␤»

[09:08] <moritz> std: my class A::B { our class C::D { } }; C::D

[09:08] <p6eval> std d93fffe: OUTPUT«[31m===[0mSORRY![31m===[0m␤Undeclared name:␤    'C::D' used at line 1␤Check failed␤FAILED 00:00 41m␤»

[09:08] <moritz> std: my class A::B { our class C::D { } }; A::B::C::D

[09:08] <p6eval> std d93fffe: OUTPUT«ok 00:00 41m␤»

[09:08] <sorear> is A::B::C::D in %*CURLEX?  No.  Is A::B::C?  No.  Is A::B?  Yes! (alias installed by our class).  Let's look for C::D under the A::B class alias

[09:09] <masak> right.

[09:09] <moritz> and if not, you still have to go looking A, right?

[09:09] <masak> so it's not "ridiculously many possible combinations", it's a linear thing.

[09:09] <moritz> and then in A, look for B::C::D, recursively

[09:09] <moritz> oh no

[09:09] <masak> hm, troo.

[09:09] <moritz> now I understand

[09:10] <moritz> I think what sorear++ meant was that this is only done for the first level

[09:10] <moritz> so no recursion

[09:10] <sorear> right

[09:10] <sorear> because the package entries point to packages, not lexpads

[09:10] <sorear> recursion wouldn't make sense, typologically

[09:11] <masak> oh good.

[09:11] <masak> I don't understand why that is, but I'm releaved that it is :)

[09:12] <moritz> masak: a use case for macros \o/ http://blog.racket-lang.org/2012/08/fully-inlined-merge-sort.html

[09:13] <masak> moritz: nice.

[09:13] <moritz> that could be kind of a "man-or-boy" test for a macro implementation :-)

[09:13] <masak> moritz: I think with what's in nom now, we can do that. let me try during the day :0

[09:13] <masak> :)

[09:14] <masak> moritz++

[09:14] * felher wants to see that using perl6 macros :)

[09:14] <sorear> o/ felher

[09:15] <felher> o/ sorear 

[09:17] <moritz> I don't want to discourage you, but I wonder how recursive macros can work when there's a big bug in the hygiene

[09:17] <masak> heh :)

[09:17] <masak> it's big bug, but I expect to find and fix that one quickly.

[09:17] *** birdwindupbird left
[09:17] <masak> I'm more concerned about the other, more subtle bug that I know about.

[09:17] <sorear> What big bug?

[09:18] <masak> sorear: seems unquotes get the macro's lexical scope, not the mainline's.

[09:18] <masak> r: macro foo($x) { my $v = "inside"; quasi { {{{$v}}}() } }; my $v = "outside"; say foo sub { $v }

[09:18] <p6eval> rakudo 196572: OUTPUT«===SORRY!===␤Can not get non-existent attribute '$!past' on class 'AST'␤»

[09:19] <masak> :/

[09:19] <masak> ok, that's not the failure mode I wanted to demonstrate....

[09:20] <moritz> http://irclog.perlgeek.de/perl6/2012-08-25#i_5930171

[09:20] <masak> r: macro call($a) { my $x = "how very"; quasi { say $x; {{{$a}}}() } }; my $x = "lexical"; call { say $x }

[09:20] <p6eval> rakudo 196572: OUTPUT«how very␤how very␤»

[09:20] <masak> r: macro foo($x) { my $v = "inside"; quasi { {{{$v}}}() } }; my $v = "outside"; say foo { say $v }

[09:20] <p6eval> rakudo 196572: OUTPUT«===SORRY!===␤Can not get non-existent attribute '$!past' on class 'AST'␤»

[09:21] <masak> r: macro foo($x) { my $v = "inside"; quasi { say $v; {{{$v}}}() } }; my $v = "outside"; say foo { say $v }

[09:21] <p6eval> rakudo 196572: OUTPUT«===SORRY!===␤Can not get non-existent attribute '$!past' on class 'AST'␤»

[09:21] <masak> hm... what's different between 'call' and 'foo'?

[09:21] <masak> oh!

[09:21] <masak> r: macro foo($x) { my $v = "inside"; quasi { say $v; {{{$x}}}() } }; my $v = "outside"; foo { say $v }

[09:21] <p6eval> rakudo 196572: OUTPUT«inside␤inside␤»

[09:21] <masak> there we go.

[09:22] <masak> ah, and the LTA error message is because there's not AST typecheck on unquote trees.

[09:22] * masak makes a note to add that ASAP

[09:23] <ChoHag> Well that's a bit shit. Emacs thinks the contents of a heredoc is just more code and tries to indent it.

[09:24] <ChoHag> (Not perl 6, just randing)

[09:24] <ChoHag> (ranting)

[09:25] <sorear> to be fair multiline contextual constructs like regex blocks and heredocs and pod blocks are pretty hard on editors in general

[09:25] <masak> they're pretty hard on parsers, too :)

[09:25] <sorear> I think it would be nice if we had single-line versions of the abovew

[09:26] <ChoHag> Single-line multi line heredocs?

[09:26] <sorear> ChoHag: you can make a block comment editor-friendly by prefixing each line with #

[09:27] <sorear> what if there was something you could use to prefix each line of a heredoc?

[09:27] <ChoHag> Ah.

[09:27] <sorear> masak: a code-aware editor is a parser that has to be able to parse malformed documents starting from the middle of the file :D

[09:27] <masak> something like that.

[09:28] <masak> seems to me a savvy editor would save intermediate parse states in order not to have to parse the whole document each time.

[09:28] <sorear> editing STD.pm6 gets very annoying when vim's highlighter decides to start in the middle of a regex and then messes up the entire screen

[09:28] <sorear> well, you can do that, but then any edit requires a huge amount of reparsing

[09:30] <ChoHag> If when parsing you save the state of the parse every n-hundred bytes, then a change at byte 706 doesn't have to parse the first 700 bytes.

[09:30] <ChoHag> And the rest can be ignored until it's visible.

[09:30] <ChoHag> Or something like that.

[09:32] *** broquaint joined
[09:33] <sorear> wait.

[09:34] <sorear> n: say qq:to[OUTER];␤  hello { qq:to[INNER] } world␤  insidestuff␤  INNER␤  more stuff␤  OUTER␤

[09:34] <p6eval> niecza v19-44-g55e895a: OUTPUT«(timeout)[auto-compiling setting]␤»

[09:34] <sorear> evalbot control restart

[09:34] *** p6eval left
[09:36] *** p6eval joined
[09:37] *** ChanServ sets mode: +v p6eval

[09:37] <sorear> moritz, why do I get rsync error: unexplained error (code 255) at io.c(605) [sender=3.0.9] when p6eval restarts?

[09:37] <sorear> n: say qq:to[OUTER];␤  hello { qq:to[INNER] } world␤  insidestuff␤  INNER␤  more stuff␤  OUTER␤

[09:37] <p6eval> niecza v19-44-g55e895a: OUTPUT«Unhandled exception: Here document used before body defined␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1402 (die @ 5) ␤  at /home/p6eval/niecza/src/Op.pm6 line 331 (HereStub.zyg @ 5) ␤  at /home/p6eval/niecza/src/Op.pm6 line 23 (Op.ctxzyg @ 4) ␤  …

[09:39] <sorear> perl 6: might be the first language to support NESTED HERE DOCUMENTS

[09:40] <dalek> evalbot: 3bb2f7e | sorear++ | evalbot.pl:

[09:40] <dalek> evalbot: p6eval only sees the costs of installable mode, so force inplace mode for niecza

[09:40] <dalek> evalbot: review: https://github.com/perl6/evalbot/commit/3bb2f7ec54

[09:41] <moritz> sorear: I have no clue

[09:41] <sorear> I found the problem

[09:42] <sorear> I ran 'git pull' in the evalbot dir and it pulled changes to rsync handling

[09:42] <sorear> which had been in the github repo but not live since Aug 2 or so

[09:45] *** p6eval left
[09:45] *** p6eval joined
[09:45] *** ChanServ sets mode: +v p6eval

[09:45] <sorear> moritz: what is "ulimit -u 80" intended to accomplish?

[09:47] <sorear> looks like on feather3 "ulimit -u" is supported by bash but not by dash

[09:48] <masak> hm, I can't really use dies_ok with macros I know are going to fail during application...

[09:48] <masak> (because application is at compile time)

[09:48] <masak> I think I will need to use an eval() there.

[09:49] <sorear> you need to use ... eval_dies_ok!

[09:49] <masak> ah!

[09:49] <sorear> and put the macro inside the eval block, hmm

[09:49] <mst> http://p3rl.org/Test::Fatal

[09:49] <mst> ^^ this API replaces all the Test::Exception rubbish nicely

[09:49] <mst> simpler, more orthogonal, more pleasant to work with

[09:50] <masak> mst: I've seen that one before. it's nice.

[09:50] <masak> agree about "more orthogonal".

[09:50] <mst> the only reason Test::Exception is useful is that it can do various bits of caller() and etc. hackery and my argument would be that that's more a "working around 5core limitations" thing than a feature

[09:51] *** JimmyZ joined
[09:51] <masak> it might be too late to do a full switchover for S24 :/

[09:51] <mst> what's S24 ?

[09:51] <masak> the testing synopsis.

[09:51] <masak> I'm guessing it specifies eval_dies_ok et al.

[09:52] <masak> if people think it's a good idea to make Perl 6's Test.pm API more like Test::Fatal, I'm willing to work on that a bit.

[09:52] <masak> essentially try it out in a branch and prepare a patch that switches us over.

[09:52] <mst> I would suggest that, instead, you add the exception { ... } construct

[09:52] <mst> and then wait and see which you find it easier to explain to people how to write tests using

[09:52] <masak> nod.

[09:53] <masak> I like that idea.

[09:53] <mst> since it occurs to me that the converse of my previous statement could be valid as well

[09:53] <moritz> there's no reason not provide both for a while

[09:53] <masak> right.

[09:53] <mst> in that it may be that it's the workarounds ib T::Exception

[09:53] <masak> mst++ # suggestion

[09:53] <mst> that make Test::Fatal superior

[09:53] <mst> also, one could build the lives_ok etc. -atop- the exception { construct

[09:53] <mst> once they become trivial sugar

[09:53] <mst> I mean

[09:54] <mst> lives_ok = f ($block, $words) { is(!exception($block), $words); };

[09:54] <mst> for example

[09:54] <dalek> roast: 7e37729 | masak++ | S06-macros/macros-d2.t:

[09:54] <dalek> roast: [S06-macros/macros-d2.t] new test file

[09:54] <dalek> roast: review: https://github.com/perl6/roast/commit/7e37729213

[09:54] <mst> then they're hardly going to be a maint bruden

[09:55] <mst> masak: while I'm here I'd like to help ensure that #perl6 avoids as many perl5 mistakes as possible

[09:55] <dalek> rakudo/nom: d21d35d | masak++ | t/spectest.data:

[09:55] <dalek> rakudo/nom: [spectest.data] added macros-d2.t

[09:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d21d35d04d

[09:55] <moritz> note that either you'd need to write   isa_ok   exception({block}), X::Foo  # with parens

[09:55] <masak> reviews on the above file are very welcome.

[09:55] <mst> masak: that way you can make all new mistakes that I can learn something from :D

[09:56] <moritz> or we'd have make exception a prefix operator

[09:56] <masak> "Perl 5 and Perl 6: two very good sets of complementary mistakes"

[09:56] <moritz> (because we have no function prototypes in p6)

[09:57] <moritz> masak: reviewing

[09:57] <moritz> masak: first of all, can haz better tets file name puleze?

[09:57] <moritz> d2 makes sense from your perspective, but not from anybody elses

[09:58] <masak> moritz: good point. I can do that.

[09:58] <moritz> after reading "macro podolsky" I went like "and where is rosen"?

[09:58] <moritz> and then I scrolled down

[09:58] <moritz> masak++

[09:59] <masak> :)

[09:59] <moritz> masak: the last test is wrong

[09:59] <moritz> masak: 'cause eval_dies_ok evals in the context of eval_dies_ok, not in the context of your sub

[10:00] <moritz> s/sub/code/

[10:00] <moritz> so it doesn't see macro bohm

[10:00] <moritz> (which is why the test succeeds, even though the feature you are trying to test doesn't work

[10:01] <masak> moritz: er.

[10:01] *** crab2313 left
[10:01] <masak> moritz: oh!

[10:01] <masak> moritz: you're saying eval_dies_ok's context is inside of Test.pm?

[10:01] <moritz> masak: correct

[10:01] <masak> because it's a string, so it doesn't have closure semantics....

[10:01] <masak> shoulda seen that, yes.

[10:01] <moritz> I'd love to change that, it's a very common mistake

[10:02] <moritz> but &eval doesn't have an option for evalling in a different context

[10:03] <sorear> masak: what was the bug with einstein?

[10:03] <sorear> 02:49 < sorear> and put the macro inside the eval block, hmm

[10:03] <moritz> (&eval is probably the wrong abstractioin level to add that though. We should have a &compile function that compiles the code but doesn't run it yet, and that one can have such strings and wires attached like compiling in a different context)

[10:04] <masak> sorear: einstein works in rakudo.

[10:05] <masak> sorear: podolsky doesn't currently, even though it should be equivalent.

[10:05] <masak> &

[10:05] <moritz> [1] 8244

[10:06] <moritz> now you can just type 'fg 1' to summon masak++ again :-)

[10:07] <ChoHag> Free ++ with every &?

[10:07] <sorear> OH

[10:08] *** drejk joined
[10:08] *** spider-mario joined
[10:09] <sorear> r: macro foo() { quasi { 2 }; }; say foo

[10:09] <p6eval> rakudo d21d35: OUTPUT«2␤»

[10:09] <sorear> r: macro foo() { my $q = quasi { 0 }; $q = quasi { 1 + {{{$q}}} } for ^5; $q }; say foo

[10:09] <p6eval> rakudo d21d35: OUTPUT«1␤»

[10:10] <sorear> nm

[10:10] <sorear> &

[10:11] <moritz> r: macro upto($a, $b) { return quasi { $a } unless $b; return upto(quasi { 1 + {{{$a}}} }, $b - 1 }; say upto(0, 5)

[10:11] <p6eval> rakudo d21d35: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2, near "}; say upt"␤»

[10:11] <moritz> r: macro upto($a, $b) { return quasi { $a } unless $b; return upto(quasi { 1 + {{{$a}}} }, $b - 1) }; say upto(0, 5)

[10:11] <p6eval> rakudo d21d35: OUTPUT«===SORRY!===␤Cannot call 'Numeric'; none of these signatures match:␤:(Mu:U \v, Mu *%_)␤␤»

[10:15] *** drejk left
[10:18] <ChoHag> Does perl 6 have a DBI-like (specifically, postgres) module?

[10:20] <arnsholt> jnthn: Any particular reason NativeHOW.nativesize expects an argument besides the invocant, since it just returns the size?

[10:20] <FROGGS> ChoHag: https://github.com/perl6/DBIish/

[10:20] <FROGGS> since its on modules.perl6.org I can guess its in rakudo*?

[10:22] <ChoHag> Cheers

[10:29] <moritz> FROGGS: the reasoning isn't valid, but it's still in R*

[10:30] <moritz> and yes, it supports postgresql. With prepared statements and placeholders

[10:30] <moritz> .

[10:47] <arnsholt> Mmmm. Debug printf output in my compiler ^_^

[10:48] *** MayDaniel joined
[10:53] <moritz> are you debugging output from printf? or using printf to debug?

[10:55] <arnsholt> The latter, thankfully =)

[10:55] <arnsholt> Making sure I get the right numbers in my metamodel hackery (actually storing and using sizes for native types)

[11:28] <FROGGS> arnsholt: I can pass my callback sub just like: thing_that_takes_a_cb( &subname )

[11:28] <FROGGS> right?

[11:28] <arnsholt> Yup

[11:29] <FROGGS> passing a anonymous sub and passing a $subref doesnt work right now?

[11:30] <arnsholt> Dunno, TBH

[11:30] <arnsholt> Did you try?

[11:31] <FROGGS> I did, no warnings, but the callback doesnt get called

[11:31] <arnsholt> Huh. That's a bit odd, I guess

[11:33] <arnsholt> I'll try to look into it

[11:34] <FROGGS> cool, great, thanks

[11:35] *** tokuhiro_ joined
[11:35] <FROGGS> passung Mu as the arg will end up as a NULL in C?

[11:35] <FROGGS> passing

[11:36] <arnsholt> I think so

[11:36] <arnsholt> But most often you'll want to pass the type object

[11:37] <FROGGS> I mean, it works as expected (callback get unregistered) but I want to make sure

[11:37] <FROGGS> type object?

[11:38] <FROGGS> like the type identifier of a subroutine reference?

[11:38] <FROGGS> is it "Code"?

[11:40] *** whiteknight joined
[11:40] *** tokuhiro_ left
[11:40] <FROGGS> k, passing Code works too... its like it is some sort of bitch, no complains, just takes everything

[11:46] *** thelazydeveloper joined
[11:49] *** MayDaniel left
[11:57] <arnsholt> FROGGS: The type object is part of the meta-object protocol

[11:58] <dalek> roast: 8e15845 | masak++ | S06-macros/macros-d2.t:

[11:58] <dalek> roast: [macros-d2.t] fix mis-context

[11:58] <dalek> roast: 

[11:58] <dalek> roast: moritz++ for pointing this out: strings aren't passed as

[11:58] <dalek> roast: closures, and eval_dies_ok evaluates things in Test.pm's

[11:58] <dalek> roast: lexical context. moving the macro into the string fixes

[11:58] <dalek> roast: it.

[11:58] <dalek> roast: review: https://github.com/perl6/roast/commit/8e158459ed

[11:58] <arnsholt> When you say "my $x = Something.new" or "my Something $x .= new" what happens is that a method is invoked on the Something metaobject

[11:59] <arnsholt> And the type object of a class is used as a typed undef value, which makes sense for NULL values

[12:00] <dalek> roast: 0710d57 | masak++ | S06-macros/ (4 files):

[12:00] <dalek> roast: [S06-macros] gave test files more descriptive names

[12:00] <dalek> roast: 

[12:00] <dalek> roast: moritz++ for suggestion. now they are not tied to the

[12:00] <dalek> roast: grant milestones, but to what functionality they

[12:00] <dalek> roast: exercise... just like the rest of the test suite.

[12:00] <dalek> roast: review: https://github.com/perl6/roast/commit/0710d57620

[12:00] *** kaare_ left
[12:02] <dalek> rakudo/nom: f7ec305 | masak++ | t/spectest.data:

[12:02] <dalek> rakudo/nom: [spectest.data] chased macro test files rename

[12:02] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f7ec305a7b

[12:23] *** tokuhiro_ joined
[12:28] *** tokuhiro_ left
[12:29] *** tokuhiro_ joined
[12:34] *** tokuhiro_ left
[12:42] *** DrEeevil is now known as bonsaikitten

[13:02] * arnsholt is starting to really like tmux

[13:08] *** cognominal left
[13:10] *** cognominal joined
[13:13] * JimmyZ is using byobu, which is tmux-based

[13:14] <masak> ah; nice name for a screen-like application :)

[13:16] <arnsholt> Hmm. Looks interesting

[13:17] <arnsholt> Although, I already have much of what it prints out in my xmobar status line

[13:18] *** birdwindupbird joined
[13:18] <FROGGS> arnsholt: is there a way to declare default argument values using NativeCall? like: our sub my_sub( int $a, int $b = -1) is native ...

[13:18] <FROGGS> when trying it and calling this sub with only one arg I get a coredump

[13:18] <arnsholt> Don't think that'll work

[13:19] <arnsholt> What you'll probably want to do if you want that functionality is create a wrapper Perl 6 function that calls the dyncall function

[13:19] <FROGGS> is it on the wishlist already? :P

[13:19] <arnsholt> Nope, hadn't really considered that one

[13:19] <FROGGS> arnsholt: I did that too (wrapper func), but it crashes as well

[13:19] <arnsholt> That's odd...

[13:19] <FROGGS> ya

[13:19] <FROGGS> the subs have different names btw, its no multi stuff

[13:20] <arnsholt> What happens if you just call the C function directly?

[13:20] <FROGGS> when I call it with all args, it does what it should (plays music actually)

[13:21] <arnsholt> That's odd

[13:21] <arnsholt> Could you gist the relevant bits, perhaps?

[13:21] <FROGGS> that crashes: https://github.com/PerlGameDev/SDL6/blob/froggs/lib/SDL/Mixer/Channels.pm6#L10

[13:22] <FROGGS> its not much though

[13:23] <arnsholt> Huh. Odd

[13:26] <arnsholt> Not sure what's going on

[13:26] <arnsholt> Could you try running it through gdb?

[13:26] <arnsholt> See where it segfaults

[13:29] <FROGGS> I will, gtg for a walk now, will report to you then

[13:30] <arnsholt> Excellent

[13:33] *** MayDaniel joined
[13:46] *** josp joined
[13:47] *** josp left
[13:47] *** kaare_ joined
[13:49] <masak> nwc10++ # nicest "how do I unsubscribe?" reply I've ever read, on p6c

[13:50] <masak> I also found myself thinking "whatever this guy has a PhD in, I bet it isn't mailing lists" :) people have different backgrounds.

[13:55] *** daxim joined
[14:12] *** marmay joined
[14:13] <frettled> masak: yep. And looking in message headers isn't necessarily trivial in a modern GUI-based email client, they mostly hide it somewhere for experts.

[14:15] *** simcop2387 left
[14:15] *** simcop2387 joined
[14:17] <masak> I'm not sure I'd think to look there, actually.

[14:18] <frettled> One of the points of the list-headers is to make it easy for email clients to identify mailinglists _and_ to unsubscribe.  Look at how well that's panning out.  :(

[14:21] * masak likes this quote from the distant past: http://irclog.perlgeek.de/perl6/2005-06-28#i_-584545

[14:22] <pmichaud> good afternoon, #perl6

[14:23] <ChoHag> How do you call up the pod of an installed module?

[14:23] <geekosaur> as for the list headers, they are indeed for clients.  don't think I've seen a clientother than gmail that offers unsubscribe etc. to the actual user

[14:24] *** xinming joined
[14:24] <masak> good morning, pmichaud.

[14:25] <ChoHag> Reality isn't all it's cracked up to be.

[14:25] <ChoHag> It can barely be said to exist, for one thing.

[14:25] <pmichaud> ...morning?

[14:25] <pmichaud> hmmmm

[14:25] <masak> pmichaud: UGT, Universal Greeting Time.

[14:25] <pmichaud> wfm

[14:25] <pmichaud> it's morning in #perl6, the dawn of a new era

[14:25] <pmichaud> or something like that.

[14:38] <arnsholt> jnthn is at the MOP hacakthon thingy these days, right?

[14:50] *** kst left
[14:53] <pmichaud> arnsholt: yes. 

[14:53] *** Circlepuller joined
[14:56] <spider-mario> I now provide arch linux builds of rakudo star. :)

[14:56] *** Circlepuller_ left
[14:56] <spider-mario> a pacman repository.

[14:57] <spider-mario> [rakudo]

[14:57] <spider-mario>  Server = http://spidermario.free.fr/archlinux/$repo/$arch

[14:59] <masak> \o/

[15:01] <ChoHag> Are there docs anywhere describing a simple perl6 tcp server?

[15:02] <ChoHag> Also, has anything like an http daemon been written, or even something more freaky like rest or soap?

[15:05] <JimmyZ> ChoHag: https://github.com/tadzik/Bailador

[15:06] <ChoHag> That looks even better.

[15:06] <pmichaud> ChoHag: : https://github.com/mberends/http-server-simple/

[15:07] <pmichaud> I'm afk for a while -- bbl

[15:07] <JimmyZ> ChoHag: and https://github.com/tadzik/zblog

[15:10] *** GlitchMr joined
[15:13] *** perl5 joined
[15:14] <masak> perl5: hi. I saw you on the back of lots of YAPC::Europe t-shirts. :)

[15:16] *** perl5 left
[15:24] *** ponbiki joined
[15:28] <jnthn> ohhai o/

[15:30] <arnsholt> jnthn: \o/

[15:32] <arnsholt> I'm having some trouble extracting the nativesize stuff in the P6{int,num} REPRs

[15:34] <masak> jnthn! \o/

[15:34] <jnthn> arnsholt: I could tell you how, but I'm gonna change the answer pretty shortly...

[15:35] <arnsholt> Aha. Might as well wait for the new answer then =)

[15:35] <jnthn> dammit, libuv builds fine as a .lib but I can't get it to build as a .dll

[15:36] *** JimmyZ left
[15:40] <ingy> greetings. seeking 2 things. 1) the current perl6 grammar. 2) A succinct idiom comparison between perl5 and perl6.

[15:42] <masak> ingy: (1) https://github.com/perl6/std/blob/master/STD.pm6

[15:43] <diakopter> (2) that would be lovely to me as well

[15:43] <masak> I've seen such documents, but it's been a while.

[15:51] <ingy> thanks!

[15:51] *** flussence left
[15:51] *** flussence joined
[16:04] <arnsholt> jnthn: FROGGS gets what looks like a decontainerize of something that isn't a container in https://github.com/PerlGameDev/SDL6/blob/froggs/lib/SDL/Mixer/Channels.pm6#L10 (in play_channel)

[16:04] <arnsholt> Backtrace at http://nopaste.info/2f9f16692a.html

[16:04] *** marmay_ joined
[16:05] <arnsholt> Doesn't look like it's the literal -1 that's it. Any thoughts on what it might be?

[16:05] *** tokuhiro_ joined
[16:06] <arnsholt> FROGGS: Oh. What happens if you remove the type decorations of the args in play_channel?

[16:06] <FROGGS> how should I pass the args then?

[16:07] <FROGGS> is there a $_ or @_?

[16:07] <FROGGS> or is it like (shift, shift, shift)?

[16:08] <arnsholt> Oh, you can leave the argument list, but try making it play_channel( $channel, $sample, $loops )

[16:08] <FROGGS> ahh, misread

[16:08] <FROGGS> will try

[16:08] *** marmay left
[16:08] <FROGGS> its working

[16:09] <FROGGS> I need to recheck that I did no mistake

[16:10] *** tokuhiro_ left
[16:11] <arnsholt> Excellent!

[16:11] *** saran joined
[16:11] <arnsholt> Looks like native typed args don't end up in containers

[16:11] <FROGGS> ya, it fails again if I add the "int" to the first arg

[16:11] *** saran left
[16:11] <arnsholt> Which then explodes when we try to decontainerize

[16:11] *** spider-mario left
[16:16] *** Circlepuller_ joined
[16:17] *** saran joined
[16:19] *** snearch joined
[16:19] *** Circlepuller left
[16:24] *** Circlepuller joined
[16:27] *** Circlepuller_ left
[16:31] *** saran_ joined
[16:31] <arnsholt> FROGGS: I think I've figured out what the problem is. I'll prod you when it's fixed

[16:32] <pmichaud> back again

[16:33] *** saran_ left
[16:34] <pmichaud> reading backscroll and email

[16:34] *** saran left
[16:39] <FROGGS> arnsholt++

[16:39] <FROGGS> thank you ;o)

[16:40] <arnsholt> Well, I didn't fix it yet =)

[16:40] <FROGGS> ya, but guessing the problem is the hardest part most times

[16:43] *** birdwindupbird left
[16:47] *** marmay_ left
[17:11] *** am0c joined
[17:15] *** benabik left
[17:16] *** benabik joined
[17:21] *** spider-mario joined
[17:38] <arnsholt> jnthn: What's the best way to get access to smo_id (in sixmodelobject.c) from nqp_dyncall.ops?

[17:40] <dalek> doc: a5c90a5 | moritz++ | / (2 files):

[17:40] <dalek> doc: X::Mixin::NotComposable

[17:40] <dalek> doc: review: https://github.com/perl6/doc/commit/a5c90a5be7

[17:43] <tadzik> 0901        sorear | anyways, I had a hell of a time getting Niecza to run on 

[17:43] <tadzik>                    | tadzik's machine

[17:43] <dalek> specs: c80acf9 | moritz++ | S32-setting-library/Exception.pod:

[17:43] <dalek> specs: [S32::Exception] rename an exception class, for consistency

[17:43] <dalek> specs: review: https://github.com/perl6/specs/commit/c80acf9413

[17:44] <tadzik> ...when were you... oh, I remember the case now

[17:44] <tadzik> good evening #perl6

[17:44] <moritz> \o tadzik 

[17:45] <arnsholt> Nm. Found it

[17:46] <dalek> doc: 5f9c9f4 | moritz++ | lib/X/NoDispatcher.pod:

[17:46] <dalek> doc: X::NoDispatcher

[17:46] <dalek> doc: review: https://github.com/perl6/doc/commit/5f9c9f4491

[17:48] <dalek> doc: 278a4cd | moritz++ | lib/X/Declaration/Scope/Multi.pod:

[17:48] <dalek> doc: X::Declaration::Scope::Multi

[17:48] <dalek> doc: review: https://github.com/perl6/doc/commit/278a4cd561

[17:52] <dalek> doc: 0edd594 | moritz++ | lib/X/Syntax/Variable/Twigil.pod:

[17:52] <dalek> doc: X::Syntax::Variable::Twigil

[17:52] <dalek> doc: review: https://github.com/perl6/doc/commit/0edd594344

[17:54] <dalek> doc: 4bb78ba | moritz++ | lib/X/Syntax/Self/WithoutObject.pod:

[17:54] <dalek> doc: X::Syntax::Self::WithoutObject

[17:54] <dalek> doc: review: https://github.com/perl6/doc/commit/4bb78baed0

[17:56] <masak> good morning, tadzik.

[17:56] <masak> rn: constant o = 42; \o

[17:56] <p6eval> rakudo f7ec30, niecza v19-44-g55e895a:  ( no output )

[17:56] <masak> rn: constant o = 42; say \o

[17:56] <p6eval> niecza v19-44-g55e895a: OUTPUT«\(42)␤»

[17:56] <p6eval> ..rakudo f7ec30: OUTPUT«42␤»

[18:04] <colomon> rn: constant o = 42; say o

[18:04] <p6eval> rakudo f7ec30, niecza v19-44-g55e895a: OUTPUT«42␤»

[18:07] <benabik> rn: constant o = 42; say \o/     1

[18:07] <p6eval> rakudo f7ec30: OUTPUT«1␤»

[18:07] <p6eval> ..niecza v19-44-g55e895a: OUTPUT«Unhandled exception: Cannot use value like Capture as a number␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 293 (Any.Numeric @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/veIlHDuYsG line 1 (mainline @ 4…

[18:07] <benabik> Amusing.

[18:07] *** snearch left
[18:09] <moritz> nr: say Capture ~~  Cool

[18:09] <p6eval> rakudo f7ec30, niecza v19-44-g55e895a: OUTPUT«False␤»

[18:10] <dalek> rakudo/nom: bd23ad4 | moritz++ | src/core/ (2 files):

[18:10] <dalek> rakudo/nom: rename an exception class

[18:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bd23ad4609

[18:10] <dalek> roast: d4fa5e8 | moritz++ | S32-exceptions/misc.t:

[18:10] <dalek> roast: follow exception class rename

[18:10] <dalek> roast: review: https://github.com/perl6/roast/commit/d4fa5e8773

[18:24] <moritz> nr: sub f(::T) { class A is T { } }

[18:24] <p6eval> niecza v19-44-g55e895a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤GLOBAL::T does not name any package at /tmp/EYl_nY1i4o line 1:␤------> [32msub f(::T[33m⏏[31m) { class A is T { } }[0m␤␤A type must be provided at /tmp/EYl_nY1i4o line 1:␤------> [32msub f(::T[33m⏏[31m) { class A is T…

[18:24] <p6eval> ..rakudo f7ec30: OUTPUT«===SORRY!===␤Cannot type check against type variable T␤at /tmp/aUJgGyqScX:1␤»

[18:28] *** odoacre left
[18:30] <masak> how is '\o/' parsed above in benabik's evaluation?

[18:30] <benabik> masak: It seems to be parsed as \o / 1, given that neicza complained about capture to number.

[18:34] <dalek> tablets: 4eff6da | (Herbert Breunung)++ | docs/ (3 files):

[18:34] <dalek> tablets: removing noneexisting book

[18:34] <dalek> tablets: review: https://github.com/perl6/tablets/commit/4eff6da5e3

[18:34] <masak> r: constant o = 42; say o/

[18:34] <p6eval> rakudo f7ec30: OUTPUT«===SORRY!===␤Confused␤at /tmp/Q8b9OJmTkQ:1␤»

[18:34] <masak> r: constant o = 42; say \o/

[18:34] <p6eval> rakudo f7ec30: OUTPUT«===SORRY!===␤Confused␤at /tmp/ATzNEqDZUn:1␤»

[18:34] <benabik> masak: I used \o/    1

[18:34] <masak> oh! :)

[18:34] <benabik> :-D

[18:34] <masak> mystery solved :)

[18:34] <masak> sneaky ;)

[18:35] *** xinming left
[18:36] *** xinming joined
[18:37] *** daxim left
[18:47] *** larks left
[18:47] <dalek> doc: 19f2c5a | moritz++ | lib/X/Syntax/P5.pod:

[18:47] <dalek> doc: X::Syntax::P5

[18:47] <dalek> doc: review: https://github.com/perl6/doc/commit/19f2c5ad97

[18:49] *** larks joined
[18:51] *** popl joined
[18:51] * masak .oO( Perl 6 is so different, Perl 5 is represented in it as an exception type ) :P

[18:52] <moritz> the Pod:: classes need documentation

[18:53] <moritz> any takers?

[18:53] <moritz> masak: oh, and the Macro class needs documentation

[18:53] <moritz> r: macro a { }; say &a.WHAT

[18:53] <p6eval> rakudo f7ec30: OUTPUT«Macro()␤»

[18:53] <masak> noted.

[18:53] <moritz> \o/

[18:54] * moritz imagines the memo percolating to the different masak clones

[18:54] <masak> "A macro is a Routine whose invocation typically happens during parsing."

[18:54] <masak> or s/m/M/ perhaps.

[18:56] <moritz> r: say Macro.^mro

[18:56] <p6eval> rakudo f7ec30: OUTPUT«Macro() Routine() Block() Code() Any() Mu()␤»

[18:56] <moritz> why doesn't it inherit from Sub?

[18:57] <masak> why should it?

[18:57] <masak> why doesn't Method inherit from Sub?

[18:57] <moritz> because it's very sub-like

[18:57] <masak> so is Method.

[18:57] <moritz> nonono

[18:57] <masak> sure it is.

[18:57] <moritz> methods are scoped differently by default

[18:57] <moritz> and are usually called in a different way

[18:57] <masak> so are macros.

[18:58] <moritz> called, yes. Scoped?

[18:58] <moritz> I hope not :-)

[18:58] <masak> methods are *scoped* the same too. they are registered differently.

[18:58] <masak> methods adhere to lexical scoping just as much as macros and subs do.

[18:59] <masak> but please, tell me what would be different in practice if I made Macro a subclass of Sub. that should be the determiner of this.

[18:59] <masak> not some fuzzy philosophical similarity.

[19:00] <masak> see, src/core/Sub.pm is empty :)

[19:01] <sorear> good * #perl6

[19:01] <moritz> you're right, it's probably not important

[19:01] <moritz> just different from what I expected

[19:01] <moritz> good morning sorear 

[19:02] <masak> moritz: I will remember your surprise and take it in consideration in case any empirical difference manifests itself.

[19:02] <masak> good morning, sorear.

[19:03] <dalek> doc: 9795da9 | moritz++ | lib/Macro.pod:

[19:03] <dalek> doc: stub documentation for Macro

[19:03] <dalek> doc: review: https://github.com/perl6/doc/commit/9795da999e

[19:06] *** larks left
[19:06] *** larks joined
[19:06] <masak> moritz++

[19:08] *** ObseLeTe joined
[19:10] *** gongyiliao joined
[19:10] <masak> gongyiliao: hi.

[19:10] <gongyiliao> hi

[19:11] <masak> rn: say "Welcome to #perl{ 1 + 2 + 3 }"

[19:11] <p6eval> rakudo bd23ad, niecza v19-44-g55e895a: OUTPUT«Welcome to #perl6␤»

[19:12] *** birdwindupbird joined
[19:13] <moritz> rn: say "Welcome to #perl{ [+] ^4 }"

[19:13] <p6eval> rakudo bd23ad, niecza v19-44-g55e895a: OUTPUT«Welcome to #perl6␤»

[19:13] <sorear> haven't I seen that name before?

[19:15] <sorear> ah, only in the sense that gongyiliao has joined #perl6 53 times since my records begin

[19:16] <masak> oh :)

[19:18] * sorear was momentarily confused by "nwc10"

[19:18] <sorear> silly internetwork name differences

[19:21] <FROGGS> is there a pod2html or something that can handle several =for pod blocks?

[19:22] *** GlitchMr left
[19:23] <moritz> there's Pod::To::HTML

[19:23] <FROGGS> ohh, cool

[19:24] <moritz> that's what we use to generate the HTML on doc.perl6.org

[19:24] <sirrobert> is there a special var that knows the name of the file currently being worked on?

[19:25] <sirrobert> (and:  hi p6 =)

[19:28] <sorear> rn: say $*FILE

[19:28] <p6eval> rakudo bd23ad: OUTPUT«Dynamic variable name not found␤  in method gist at src/gen/CORE.setting:9757␤  in sub say at src/gen/CORE.setting:7125␤  in block  at /tmp/28zi11Lu1v:1␤␤»

[19:28] <p6eval> ..niecza v19-44-g55e895a: OUTPUT«Any()␤»

[19:28] <sorear> rn: say $?FILE

[19:28] <p6eval> rakudo bd23ad: OUTPUT«/tmp/vPw47tI1pw␤»

[19:28] <p6eval> ..niecza v19-44-g55e895a: OUTPUT«/tmp/t0BITImhAC␤»

[19:28] <sirrobert> huh

[19:28] <sirrobert> I haven't seen $? before

[19:28] <sorear> rn: say callframe(0).file

[19:28] <p6eval> niecza v19-44-g55e895a: OUTPUT«/tmp/snl5S79OLb␤»

[19:28] <p6eval> ..rakudo bd23ad: OUTPUT«/tmp/0Se6AQrLK4␤»

[19:29] <sirrobert> if $* means global, what does $? mean?

[19:29] <sorear> $? is for constants

[19:29] <sorear> lexically scoped compile time values

[19:29] <sirrobert> ahh... cool

[19:29] <sorear> in a way it's closely related to $*

[19:29] <felher> sirrobert: you may want to take a look at: http://perlcabal.org/syn/S02.html#Twigils 

[19:29] <FROGGS> so you are talking about __FILE__?

[19:29] <moritz> nr: say $?FILE

[19:29] <p6eval> niecza v19-44-g55e895a: OUTPUT«/tmp/FWp6A5Lqde␤»

[19:29] <p6eval> ..rakudo bd23ad: OUTPUT«/tmp/vC7WDrAdxp␤»

[19:29] <sorear> because with recursive descent parsing, lexical scopes in the program correspond to dynamic scopes in the compiler

[19:30] <sorear> $? support is spotty

[19:30] <sirrobert> sorear|felher: thanks--reading

[19:30] <sirrobert> sorear: hm ok 

[19:30] <sorear> niecza has &?BLOCK, &?ROUTINE, $?FILE, $?LINE, $?POSITION, $?ORIG, and I think that's it

[19:30] <moritz> http://doc.perl6.org/language/variables#Twigils # needs much more work

[19:31] <sorear> rakudo I think has about the same number, it adds $?CLASS and friends but lacks $?LINE?

[19:31] <sorear> nr: say $?LINE

[19:31] <p6eval> rakudo bd23ad, niecza v19-44-g55e895a: OUTPUT«1␤»

[19:31] <sorear> nr: 1␤1␤say $?LINE

[19:31] <p6eval> niecza v19-44-g55e895a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Two terms in a row (previous line missing its semicolon?) at /tmp/Ug7FX83imF line 2:␤------> [32m<BOL>[33m⏏[31m1[0m␤␤Parse failed␤␤»

[19:31] <p6eval> ..rakudo bd23ad: OUTPUT«===SORRY!===␤Confused␤at /tmp/HoGtJg5BT4:1␤»

[19:31] <sorear> nr: 1;␤1;␤say $?LINE

[19:31] <p6eval> rakudo bd23ad, niecza v19-44-g55e895a: OUTPUT«3␤»

[19:31] <sorear> mmh

[19:31] <sorear> nr: say &?BLOCK

[19:31] <p6eval> rakudo bd23ad: OUTPUT«Nil␤»

[19:31] <p6eval> ..niecza v19-44-g55e895a: OUTPUT«routine mainline() { ... }␤»

[19:31] <sorear> nr: say &?MOO

[19:31] <p6eval> rakudo bd23ad: OUTPUT«Nil␤»

[19:31] <p6eval> ..niecza v19-44-g55e895a: OUTPUT«Any()␤»

[19:32] <sorear> ok, there's one niecza has

[19:33] <MikeFair_> howdy #perl6

[19:33] <moritz> nr: say Nil ~~ Cool

[19:33] <p6eval> rakudo bd23ad, niecza v19-44-g55e895a: OUTPUT«True␤»

[19:33] <sirrobert> hi

[19:33] <MikeFair_> gmorning

[19:33] <masak> MikeFair_: morning!

[19:34] <felher> moritz: maybe i can do a bit of work on twigils in p6doc on wednesday. Today/Mon/Tue are filled up with work ($job).

[19:34] <felher> o/ MikeFair_ 

[19:35] <moritz> felher: that would be great

[19:35] <dalek> rakudo/uncool-iterable: c7e1713 | moritz++ | src/ (3 files):

[19:35] <dalek> rakudo/uncool-iterable: Iterable should not inherit from Cool

[19:35] <dalek> rakudo/uncool-iterable: 

[19:35] <dalek> rakudo/uncool-iterable: while that might be cool for core classes, it is not in the general case

[19:35] <dalek> rakudo/uncool-iterable: review: https://github.com/rakudo/rakudo/commit/c7e1713eb1

[19:35] <dalek> rakudo/uncool-iterable: c6fac5b | moritz++ | src/core/Nil.pm:

[19:35] <dalek> rakudo/uncool-iterable: Nil is Cool

[19:35] <dalek> rakudo/uncool-iterable: review: https://github.com/rakudo/rakudo/commit/c6fac5b63f

[19:37] <sirrobert> r: dir

[19:37] <p6eval> rakudo bd23ad:  ( no output )

[19:37] <sirrobert> r: dir.WHAT

[19:37] <p6eval> rakudo bd23ad:  ( no output )

[19:37] <felher> r: dir.perl.say

[19:37] <p6eval> rakudo bd23ad: OUTPUT«Array.new(IO::Path.new(basename => "star", directory => "."), IO::Path.new(basename => "src", directory => "."), IO::Path.new(basename => ".bashrc", directory => "."), IO::Path.new(basename => "nom-inst1", directory => "."), IO::Path.new(basename => "toqast", direc…

[19:37] <sirrobert> r: for dir -> $f { say $f}

[19:37] <p6eval> rakudo bd23ad: OUTPUT«===SORRY!===␤Missing block␤at /tmp/Evirw6da_2:1␤»

[19:38] <sirrobert> why is that a missing block?

[19:38] <moritz> r: for dir() -> $f { say $f }

[19:38] <p6eval> rakudo bd23ad: OUTPUT«IO::Path<star>␤IO::Path<src>␤IO::Path<.bashrc>␤IO::Path<nom-inst1>␤IO::Path<toqast>␤IO::Path<test3.pl>␤IO::Path<.profile>␤IO::Path<t>␤IO::Path<nom-inst2>␤IO::Path<nom-inst>␤IO::Path<toqast-inst>␤IO::Path<toqast-inst2>␤IO::Path<examples>␤IO::Path<Makefile>␤IO::Path<…

[19:38] <sirrobert> hm

[19:38] <moritz> sirrobert: because the block is taken as an argument to the dir function

[19:38] <sirrobert> ohh

[19:38] <moritz> n: for dir -> $f { say $f }

[19:38] <p6eval> niecza v19-44-g55e895a: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Missing block at /tmp/GET_0Y3r4G line 1 (EOF):␤------> [32mfor dir -> $f { say $f }[33m⏏[31m<EOL>[0m␤␤Parse failed␤␤»

[19:38] <moritz> std: for dir -> $f { say $f }

[19:38] <p6eval> std d93fffe: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'dir' needs parens to avoid gobbling block at /tmp/eX_uOAhYR_ line 1:␤------> [32mfor dir[33m⏏[31m -> $f { say $f }[0m␤Missing block (apparently gobbled by 'dir') at /tmp/eX_uOAhYR_ line 1:␤------> [32mfor dir -> $f { say …

[19:38] <moritz> std has a better message

[19:38] <sirrobert> yeah

[19:39] <sirrobert> hey... you know what would be cool

[19:39] <sirrobert> a separate project housed only error messages.  When an error got thrown out, it has something like a code

[19:39] <sirrobert> a separate github repo houses messages to make them helpful?

[19:39] <sirrobert> then is fed in during compile?

[19:40] <sirrobert> I would happily contribute better error messages when I came across weird stuff, but don't have time to dig into the guts

[19:40] <moritz> sirrobert: the problem is not the message itself

[19:40] <moritz> sirrobert: the hard part is detecting the error condition in the first place

[19:40] <sirrobert> well, in this case

[19:41] <sirrobert> but having a lexicon of errors could be helpful in general =)

[19:41] <moritz> https://github.com/rakudo/rakudo/blob/nom/src/core/Exception.pm isn't too bad to hack on

[19:41] <moritz> sirrobert: well, doc.perl6.org has a nearly complete list

[19:41] <sirrobert> moritz: fair enough =)

[19:42] *** tokuhiro_ joined
[19:43] * jnthn back from nom

[19:44] <moritz> wb jnthn 

[19:45] <moritz> std: rxs//

[19:45] <p6eval> std d93fffe: OUTPUT«[31m===[0mSORRY![31m===[0m␤Bogus term at /tmp/5MniyHlIb6 line 1 (EOF):␤------> [32mrxs//[33m⏏[31m<EOL>[0m␤Undeclared routine:␤      'rxs' used at line 1␤Parse failed␤FAILED 00:00 42m␤»

[19:45] <jnthn> Method and Sub inherit from Routine.

[19:45] <jnthn> That's what factors out their commonalities.

[19:45] <jnthn> It's fine. :)

[19:45] <moritz> jnthn: yes, that much isn't debated at all

[19:46] <dalek> doc: 3afc269 | moritz++ | lib/X/Syntax/Regex/Adverb.pod:

[19:46] <dalek> doc: X::Syntax::Regex::Adverb

[19:46] <dalek> doc: review: https://github.com/perl6/doc/commit/3afc269c1c

[19:46] <moritz> jnthn: the question was really whether Macro should inherit from Sub, or directly from Routine

[19:46] <jnthn> Routine. :)

[19:46] <jnthn> imho ;)

[19:46] *** kst joined
[19:46] *** tokuhiro_ left
[19:46] <jnthn> I'd not really want a macro to ~~ Sub

[19:46] <jnthn> That feels excessively surprising.

[19:49] <dalek> doc: d1d8a9d | moritz++ | lib/X/Syntax/Reserved.pod:

[19:49] <dalek> doc: X::Syntax::Reserved

[19:49] <dalek> doc: review: https://github.com/perl6/doc/commit/d1d8a9d00a

[19:51] <dalek> nqp: a886a77 | (Arne Skjærholt)++ | src/ops/nqp_dyncall.ops:

[19:51] <dalek> nqp: Properly handle non-Sixmodel objects in dyncall ops.

[19:51] <dalek> nqp: 

[19:51] <dalek> nqp: Two issues:

[19:51] <dalek> nqp: - decontainerize in nqp_dyncall.ops was out of sync with decontainerize in

[19:51] <dalek> nqp:   sixmodelobject.c (didn't consider possibility of non-SMO arguments)

[19:51] <dalek> nqp: - unmarshalling code (to int/float types) need to dispatch to VTABLE_get_* in

[19:51] <dalek> nqp:   case of non-SMO arguments.

[19:51] <dalek> nqp: 

[19:51] <dalek> nqp: FROGGS++ for uncovering the problem.

[19:51] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a886a77147

[19:52] <jnthn> nemesys: Hmm...I'm curious why the second bit was needed.

[19:52] <jnthn> grr

[19:52] <jnthn> arnsholt: ^^

[19:53] <arnsholt> The VTABLE stuff?

[19:53] <arnsholt> If it isn't SMO, REPR(value)->box_funcs->get_foo(...) kinda isn't there, no?

[19:54] <dalek> doc: 87275f7 | moritz++ | lib/X/Constructor/Positional.pod:

[19:54] <dalek> doc: X::Constructor::Positional

[19:54] <dalek> doc: review: https://github.com/perl6/doc/commit/87275f7d7b

[19:54] <jnthn> arnsholt: Right. I meant...where on earth is the non-6model object coming from?

[19:55] <arnsholt> Native types it seems

[19:56] <moritz> erm, what?

[19:56] <moritz> you mean,  sub f(int) is native(...) ?

[19:58] <dalek> zavolaj: d47cd3f | (Arne Skjærholt)++ | t/02-simple-args. (2 files):

[19:58] <dalek> zavolaj: Add test for wrapper sub with native parameter types.

[19:58] <dalek> zavolaj: 

[19:58] <dalek> zavolaj: Closes issue #12 in conjunction with NQP commit a886a77

[19:58] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/d47cd3f855

[19:58] <dalek> zavolaj: 3d6ee45 | (Arne Skjærholt)++ | lib/NativeCall.pm6:

[19:58] <dalek> zavolaj: Merge branch 'master' of github.com:jnthn/zavolaj

[19:58] <sorear> JNTHN!

[19:58] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/3d6ee457af

[19:58] <jnthn> SOREAR!

[19:58] <moritz> if those box into parrot PMCs, then they need more care on the callee side, I guess

[19:58] <arnsholt> jnthn, moritz: See the new test in zavolaj d47cd3f up there

[20:00] <dalek> doc: b84221e | moritz++ | lib/X/Syntax/Obsolete.pod:

[20:00] <dalek> doc: X::Syntax::Obsolete

[20:00] <dalek> doc: review: https://github.com/perl6/doc/commit/b84221e64e

[20:00] <arnsholt> A wrapper around a native function, where the wrapper has native types on its args and passes them through to the function apparently passes the natives through

[20:01] <sirrobert> this is cool, but syntactically, why does it work?

[20:01] <sirrobert> r: my $a = {a => 1}; my $b = {b => 2}; my %h = $a, $b; say %h;

[20:01] <p6eval> rakudo bd23ad: OUTPUT«("a" => 1, "b" => 2).hash␤»

[20:01] <sorear> jnthn: I hear you're in Norway now.  Anyways, I'd like you to read http://irclog.perlgeek.de/perl6/2012-08-26#i_5931019

[20:01] <sirrobert> why is ($h1,$h2) a hash?

[20:01] <sirrobert> s/$/%/

[20:01] *** sftp left
[20:02] <sorear> jnthn: 8:46 to 9:11

[20:02] <moritz> sirrobert: it seems that hash assignment flattens out hashes regardless of the sigil

[20:02] <sorear> sirrobert: it's not, it's a parcel

[20:02] <moritz> sirrobert: which looks like a bug to me

[20:02] <sirrobert> hm

[20:02] *** sftp joined
[20:02] <moritz> n: my $a = {a => 1}; my $b = {b => 2}; my %h = $a, $b; say %h.perl

[20:02] <p6eval> niecza v19-44-g55e895a: OUTPUT«Unhandled exception: Unmatched key in Hash.LISTSTORE␤  at /tmp/jAmTUPUiEk line 1 (mainline @ 16) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4138 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4139 (module-CORE @ 571) ␤  at /home/p6eval/nie…

[20:02] <sirrobert> r: say ({a => 1}, {b=>2}).WHAT

[20:02] <p6eval> rakudo bd23ad: OUTPUT«Parcel()␤»

[20:03] <sirrobert> r: %h = ({a => 1}, {b=>2}); say %h.WHAT; say %h;

[20:03] <p6eval> rakudo bd23ad: OUTPUT«===SORRY!===␤Variable %h is not declared␤at /tmp/1r2mmum6ga:1␤»

[20:03] <sirrobert> r: my %h = ({a => 1}, {b=>2}); say %h.WHAT; say %h;

[20:03] <p6eval> rakudo bd23ad: OUTPUT«Hash()␤("a" => 1, "b" => 2).hash␤»

[20:03] <moritz> sorear: is that error the same as "odd numer of elements in hash assignment"?

[20:03] <arnsholt> moritz: I dunno. If Rakudo possibly passes around bare Parrot PMCs I think the dyncall stuff is the right place to handle the possibility

[20:03] <sorear> moritz: yes

[20:04] <sorear> moritz: except you can get it with even numbers too

[20:04] <sorear> n: my %h = (a => 2), 'b';

[20:04] <p6eval> niecza v19-44-g55e895a: OUTPUT«Potential difficulties:␤  %h is declared but not used at /tmp/tZi5QKRtaz line 1:␤------> [32mmy [33m⏏[31m%h = (a => 2), 'b';[0m␤␤Unhandled exception: Unmatched key in Hash.LISTSTORE␤  at /tmp/tZi5QKRtaz line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/l…

[20:04] <sirrobert> huh...

[20:04] <moritz> sorear: so it specifically handles hashes iin hash assignment?

[20:04] <sirrobert> r: my %h = {a=>1, b => 3}; %h ,= {c=>3}; say %h;

[20:04] <p6eval> rakudo bd23ad: OUTPUT«("a" => 1, "b" => 3, "c" => 3).hash␤»

[20:04] <sirrobert> that's pretty cool.

[20:05] <sorear> moritz: yes

[20:05] <moritz> sorear: is that specced? (I'm not saying it's wrong, I'm just curious :-)

[20:05] <sorear> I know I've seen real-world code that does 'my %h = $h'

[20:06] <sorear> niecza might be wrong in allowing Hashes to be freely admixed into lists of pairs, keys, and values

[20:06] * sorear looks for relevant spec

[20:07] <sorear> The relevant spec is S02:4711, which does NOT allow passing Hash objects to Hash.LISTSTORE

[20:08] *** SamuraiJack left
[20:09] *** cognominal left
[20:09] *** cognominal joined
[20:09] *** cognominal left
[20:09] *** cognominal joined
[20:11] <moritz> let's wait for a word from TimToady though. It might be an omission, since in p5 a hash would simply flatten out

[20:14] * felher should teach his address bar to recognize things like S02:4711

[20:16] *** gongyiliao left
[20:19] <sirrobert> I love it when you get to that magic moment when your subs and modules and such turn into a perfect DSL.

[20:21] <masak> sirrobert: that's why I tend to start most designs by pretending I have the perfect DSL already :) kinda top-down.

[20:21] <sirrobert> masak: me too... super smooth  =)

[20:21] <sirrobert> it tends to be multi-pass for me

[20:22] <sirrobert> usually 3 or 4

[20:22] <sorear> sirrobert: The Forth community has a wonderful additude to this.  Every sub you define is defining an incremental new language

[20:22] *** bruges left
[20:22] <sirrobert> huh

[20:22] <sirrobert> never heard of "The Forth"

[20:22] <sorear> The (Forth community)

[20:23] <sirrobert> ohhh

[20:23] <sirrobert> heh

[20:23] <jnthn> sorear: Yeah, there are some issues in Rakudo around that area.

[20:23] <sorear> Forth is a languagey thing from many years ago

[20:23] <sirrobert> I think I've heard of but, but know nothing about it

[20:24] *** bruges joined
[20:26] <sorear> Forth's niche is a local optimum very low on the expressiveness/implementation complexity curve

[20:27] <sorear> you can use it for fair-sized apps, it has a REPL, and it can be implemented in about 1-4k of machine code

[20:27] <dalek> Heuristic branch merge: pushed 30 commits to nqp/toqast by jnthn

[20:27] <benabik> Forth is used in RedPower.

[20:27] <benabik> (Mod that adds a 6502 processor to minecraft)

[20:27] <sorear> these days it gets most use in embedded systems, for the last reason

[20:28] <masak> they totally should've called the language "The Forth", though. :D

[20:28] <colomon> Forth++

[20:28] <colomon> \

[20:28] <sorear> it may be a language, but it's the kind of language that has builtins for accessing a block storage device

[20:28] <benabik> May the Forth be with you?

[20:29] <sorear> 42 LOAD

[20:33] <masak> when I last studied the Forth culture, I got the same kind of vibes from it of "we hold the ultimate truth to how computing should be done" that I sometimes get from Lisp or Smalltalk people.

[20:33] <masak> not putting any value judgement in that. that's how it felt.

[20:34] <sorear> to put it bluntly, when a language loses its core niche, most of the people who remains are True Beleivers.

[20:34] <pmichaud> good evening, #perl6

[20:35] <sorear> good evening pmichaud

[20:36] *** REPLeffect left
[20:36] <colomon> masak: actually, I think there are really interesting parallels between Forth and Lisp.  

[20:37] *** fgomez left
[20:37] <sirrobert> masak:  Forth is Force with a lisp?

[20:38] <sorear> Forth is a fourth-generation language on a limited OS that had 5-character command names

[20:38] <sorear> same reason we have SCHEME instead of the originally intended SCHEMER.

[20:38] <sorear> .oO( if Scheme were created today, it would obviously have been named Schemr)

[20:40] <masak> :P

[20:40] <masak> and it would've had rounded corners and would only hire rock stars and ninjas.

[20:44] <benabik> roundrects everywhere

[20:45] *** birdwindupbird left
[20:50] *** REPLeffect joined
[20:54] <jnthn> Do we *need* multi-jointed lexical packages?

[20:54] <jnthn> What happens if we kill them?

[20:59] <ChoHag> If you were working on a project for fun, and you weren't really sure what it was, what would you call it?

[20:59] *** kaare_ left
[20:59] <pmichaud> ChoHag: pick a fun name

[20:59] <ChoHag> I ask here because it will feature perl 6 for a significant part of it.

[21:00] <ChoHag> But what's fun about a name?

[21:01] <sirrobert> ChoHag:  pick a commonplace thing in the same conceptual broad swath as the project.

[21:01] <ChoHag> Hmm.

[21:01] <ChoHag> It's a swathe of quite significant proportions.

[21:01] <sirrobert> ChoHag: e.g. if you're working on something to do brownian motion, dfo "

[21:01] <sirrobert> do "riverbed" 

[21:01] <sirrobert> or something

[21:02] <ChoHag> hmm

[21:02] <sirrobert> what's the project (in like... 10 words or less)?

[21:03] <ChoHag> Code that writes itself.

[21:03] <ChoHag> Not in the quine sense.

[21:03] <ChoHag> 9.

[21:04] <sirrobert> back

[21:04] <sirrobert> how about something like "meta"

[21:05] <sirrobert> oh, here you go

[21:05] <ChoHag> I dunno.

[21:05] <ChoHag> Isn't that a bit ... meta?

[21:05] <sirrobert> Ouroboris

[21:05] <FROGGS> or "cloud", everything is a cloud nowadays

[21:05] <masak> jnthn: I wouldn't mind, I think.

[21:05] <ChoHag> This has emphatically nothing to do with clouds.

[21:06] <sirrobert> Ouroboros, I guess

[21:06] <sirrobert> (s/i/o)

[21:06] <ChoHag> That might be a good choice.

[21:06] <ChoHag> Maybe Youroboros.

[21:06] <sirrobert> or if you want something with more popular recognition,

[21:06] <sirrobert> Escher

[21:06] <ChoHag> Because it's not really mine.

[21:06] <sirrobert> anyway, you get the idea

[21:07] <ChoHag> Yeah that'll do.

[21:07] <ChoHag> I'm not a big one for names.

[21:07] <sirrobert> it's a different skill, for sure.

[21:07] <ChoHag> My little girl's only 14 months and I've called her the cat's name on numerous occasions.

[21:07] <sirrobert> heh

[21:08] <FROGGS> I always swap the names of my two sons :/

[21:08] <sirrobert> When my son was 5 last year, he said to his mom:  Hey ... <short pause> ... you, with the glasses.

[21:08] <FROGGS> hehe

[21:08] <ChoHag> That wouldn't work in our house.

[21:08] <sirrobert> it didn't work in ours either

[21:08] <sirrobert> (we both wear them)

[21:09] <ChoHag> My dad and brother have the same name too, and sound the same on the phone.

[21:09] <ChoHag> That was always fun.

[21:09] <FROGGS> your dad, your brother and you have the same name?

[21:10] <FROGGS> thats basically not the idea of names

[21:10] <ChoHag> My dad and brother have the same name in addition to most of my (previous) household wearing glasses.

[21:10] <ChoHag> Sorry I thought this was #perl.

[21:10] <ChoHag> Weird language being the order of the day, month and indeed year.

[21:11] <FROGGS> gnight

[21:12] <ChoHag> What's @INC changed to and how do I make it include . (or lib)?

[21:12] <ChoHag> (In rakudo)

[21:12] <sirrobert> use lib?

[21:13] <ChoHag> Are you asking me?

[21:13] <ChoHag> I'm asking you.

[21:13] <sirrobert> I'm asking you if that didn't work

[21:13] <FROGGS> use lib 'lib';

[21:13] <FROGGS> I use it

[21:14] <ChoHag> Apparently it does.

[21:15] <ChoHag> Too often questions have the answer 'the same as perl 5'.

[21:18] <felher> Yeah, and if you want it for a quick test/check/whatever, you may use:

[21:18] <felher> export PERL6LIB=yourPathHere

[21:18] <felher> And then start your program :)

[21:21] *** fgomez joined
[21:22] <sorear> ChoHag: pass -I. to the compiler

[21:22] <sorear> "use lib" is deeply problematic

[21:22] <sorear> jnthn: What do you mean by multi-joined lexical packages?

[21:23] <ChoHag> deeply?

[21:24] *** grondilu joined
[21:25] <sorear> yes, deeply.

[21:26] <sorear> it's kind of like very.

[21:26] <grondilu> There has been no news for a while on rakudo.org.  What's up?

[21:27] <sorear> I just went to Rakudo.org and it has a post from last month concerning the release

[21:27] <sirrobert> where do I find the Test module?

[21:27] <sorear> All Perl 6 compilers come with a Test module preinstalled

[21:27] <jnthn> sorear: my class Foo::Bar { }

[21:28] <sirrobert> sorear:  yeah, but where do I find it in the/a github repo?

[21:28] <sirrobert> sorear: I want to look at the code

[21:28] <sorear> sirrobert: each compiler has a different (but mostly compatible) Test module

[21:29] <pmichaud> sirrobert: https://github.com/rakudo/rakudo/blob/nom/lib/Test.pm

[21:29] <sirrobert> pmichaud: ahh, thanks

[21:30] <sorear> sirrobert: https://github.com/sorear/niecza/blob/master/lib/Test.pm6

[21:30] <pmichaud> time for sleep here -- be back tomorrow for some real hacking :)

[21:30] <sirrobert> wave

[21:30] <sirrobert> sorear: thanks

[21:31] <sorear> sirrobert: https://github.com/perl6/Pugs.hs/blob/master/Pugs/ext/Test/lib/Test.pm

[21:32] <sorear> https://github.com/fglock/Perlito/blob/master/src6/lib/Perlito6/Test.pm

[21:32] <sorear> https://github.com/fglock/Perlito/blob/master/src5/lib/Perlito5/Test.pm

[21:33] <sorear> are there any productiony implementations I'm missing here?

[21:37] <sirrobert> dunno, but pmichaud had a dwimmier parser =)

[21:38] <ChoHag> Is there any automagic done on the import list of a module?

[21:38] <ChoHag> I can see _that_ you write an import sub, but can't find examples of any that take arguments.

[21:39] <ChoHag> And just parsing @_ myself seems so perl 5 .. ago.

[21:40] <sirrobert> ChoHag: sorry, dunno =)

[21:42] *** Circlepuller left
[21:42] *** Circlepuller joined
[21:42] <jnthn> ChoHag: If you mean what I think you do, see lib.pm6 in Rakudo

[21:43] <sirrobert> ok, clean tests

[21:43] <ChoHag> I don't think that was.

[21:43] <sirrobert> heading home; later all

[21:43] *** sirrobert left
[21:43] <sorear> wait, it that defining GLOBAL::<&EXPORT> ?

[21:43] <ChoHag> I want to know what to do about the foo bar in 'use Module <foo bar>;'

[21:44] <sorear> our sub EXPORT(*@a)

[21:44] <sorear> ChoHag: sub foo is export () { }

[21:44] <sorear> ChoHag: that's how you make it work.

[21:44] <ChoHag> So that would call foo and bar as subs when Module is loaded?

[21:44] <dalek> nqp/toqast: 9b48c83 | jonathan++ | src/QAST/Operations.nqp:

[21:44] <dalek> nqp/toqast: Don't re-use the result register of the protected region in handle op for being the overall result.

[21:44] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/9b48c831ed

[21:44] <dalek> nqp/toqast: 442c735 | jonathan++ | src/NQPQ/ (2 files):

[21:44] <dalek> nqp/toqast: Update try, CATCH and CONTROL for QAST.

[21:44] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/442c73573f

[21:44] <dalek> nqp/toqast: c2b37e4 | jonathan++ | t/nqp/44-try-catch.t:

[21:44] <dalek> nqp/toqast: Eliminate a bogus test, plus some other updating to the exception tests.

[21:44] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/c2b37e456e

[21:44] <dalek> nqp/toqast: 62dddd0 | jonathan++ | src/QAST/ (2 files):

[21:44] <dalek> nqp/toqast: Fix register allocation bug involving handlers and resumable exceptions.

[21:44] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/62dddd09fa

[21:45] *** ObseLeTe left
[21:46] *** ObseLeTe joined
[21:46] <sorear> ChoHag: no, it would copy them to the caller's namespace when Module is loaded

[21:47] <sorear> A.pm: 'module A; sub x is export { }' B.pm: 'use A;'

[21:47] <sorear> erm

[21:47] <sorear> A.pm: 'module A; sub x is export { }' B.pm: 'use A "x";'

[21:47] <ChoHag> So does nothing replace the Module->import(LIST) from perl 5?

[21:47] <sorear> Did you read lib.pm6 like jnthn said?

[21:47] <ChoHag> It was 4 lines.

[21:48] <ChoHag> One of them was }

[21:48] <ChoHag> Didn't take long.

[21:48] <sorear> Can you understand line 2?

[21:49] <ChoHag> Unless the semantics of our are radically different, yes.

[21:49] <sorear> line 2 is the answer to your question

[21:49] <ChoHag> Right.

[21:49] <sorear> line 2 replaces the Module->import(LIST) from perl 5

[21:50] <sorear> if you have the answer, why are you asking? *confused*

[21:50] <ChoHag> Because I only had the answer just now when you showed me.

[22:01] *** worr joined
[22:01] *** worr left
[22:10] <sorear> jnthn: I am going to make fairly significant changes to the way niecza handles 'my class Foo::Bar' and 'use Foo::Bar'.  I think that these changes are necessary for proper handling of the multiload provisions of S11.  I do not expect much short-term support.

[22:12] *** Circlepuller_ joined
[22:12] *** preflex_ joined
[22:13] *** preflex left
[22:13] *** preflex_ is now known as preflex

[22:14] *** Circlepuller left
[22:17] *** Circlepuller_ left
[22:18] <dalek> nqp/toqast: 8d4da1b | jonathan++ | src/NQPQ/Actions.pm:

[22:18] <dalek> nqp/toqast: Fix closure interpolation.

[22:18] <dalek> nqp/toqast: review: https://github.com/perl6/nqp/commit/8d4da1ba6a

[22:20] <jnthn> sorear: multiload as in, multiple versions?

[22:26] <sorear> jnthn: yes

[22:27] <jnthn> sorear: Happy hacking. If you can write up a description of what you do, I'd be interested to see it.

[22:35] <jnthn> sleep & 

[22:56] <masak> 'night, #perl6

[23:05] *** s1n left
[23:13] *** MayDaniel left
[23:18] *** tokuhiro_ joined
[23:23] *** tokuhiro_ left
[23:23] *** grondilu left
[23:29] *** adu joined
[23:29] *** gongyiliao joined
[23:40] *** colomon_ joined
[23:42] *** colomon left
[23:42] *** colomon_ is now known as colomon

[23:54] *** spider-mario left
