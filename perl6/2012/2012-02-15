[00:02] *** xinming left
[00:03] *** xinming joined
[00:06] *** MayDaniel left
[00:08] *** xinming left
[00:11] *** xinming joined
[00:15] *** xinming left
[00:21] *** snearch left
[00:22] *** xinming joined
[00:22] *** replore_ joined
[00:25] *** retupmoca left
[00:26] *** xinming left
[00:29] *** Chillance left
[00:30] *** isBEKaml left
[00:32] *** dayangkun joined
[00:34] *** isBEKaml joined
[00:40] *** Trashlord left
[00:42] *** isBEKaml left
[00:44] *** xinming joined
[00:44] *** isBEKaml joined
[00:48] *** xinming left
[00:54] *** isBEKaml left
[00:56] *** isBEKaml joined
[00:58] *** scott_ joined
[00:58] *** scott_ is now known as Guest79334

[00:59] *** dayangkun left
[01:21] * araujo looks in

[01:26] *** xinming joined
[01:26] *** zby_home left
[01:30] <sorear> araujo \o/

[01:30] <sorear> good * #perl6

[01:30] <araujo> sorear, /o/

[01:31] <araujo> hehe

[01:31] <shachaf> sorear: Hello.

[01:31] *** xinming left
[01:32] *** isBEKaml left
[01:34] *** zby_home_ joined
[01:35] *** xinming joined
[01:41] *** zby_home_ left
[01:42] *** dayangkun joined
[01:46] *** xinming left
[01:46] *** dayangkun left
[01:51] *** benabik joined
[01:56] *** replore_ left
[02:01] *** zby_home_ joined
[02:06] *** tokuhirom left
[02:09] *** lestrrat left
[02:10] *** lestrrat joined
[02:20] *** packetknife joined
[02:44] *** xinming joined
[02:49] *** xinming left
[02:54] *** xinming joined
[03:01] *** xinming left
[03:02] *** whiteknight left
[03:07] *** xinming joined
[03:09] *** pat_js left
[03:10] *** benabik left
[03:34] *** orafu left
[03:34] *** orafu joined
[03:46] <TimToady> sorear: if you haven't, see discussion from http://irclog.perlgeek.de/perl6/2012-02-14#i_5149103 and following

[03:47] *** xinming left
[03:47] <TimToady> (the gist has been revised a couple times since then, however)

[03:49] *** xinming joined
[03:52] <sorear> is REALLY an existing concept?

[03:55] *** xinming left
[03:56] *** xinming joined
[03:58] *** Bucciarati joined
[04:03] *** xinming left
[04:03] *** xinming joined
[04:09] <TimToady> no

[04:10] <TimToady> see the further discussion of "delegate" and such

[04:10] <TimToady> though it might possibly be a pointer in the object header that is already there

[04:11] <TimToady> we're basically trying to suss out the bits and pointer of something SV-esque

[04:14] *** xinming left
[04:15] *** xinming joined
[04:19] <TimToady> of course, this meaning of "delegate" could also just be composition for simple types, depending on VM support for this and that

[04:20] *** xinming left
[04:30] *** xjiujiu joined
[04:30] *** packetknife left
[04:30] *** packetknife joined
[04:32] *** dalek left
[04:32] *** xinming joined
[04:33] *** dalek joined
[04:33] *** ChanServ sets mode: +v dalek

[04:33] *** rsimoes1 left
[04:35] *** noam joined
[04:35] *** rsimoes1 joined
[04:40] *** packetknife left
[04:48] *** thou joined
[04:50] <sorear> TimToady: I don't like this "intrinsic truth" thing - niecza only has one concept of truthiness atm

[04:51] <sorear> I'm only looking at the gist currently

[04:53] *** jaldhar left
[04:54] <sorear> less charitably, niecza has a lot riding on .Bool being the only real truth. :D

[04:55] *** retupmoca joined
[04:57] *** odoacre joined
[04:57] <sorear> TimToady: what do you mean by OK and Nil being *roles*?!  and how is it possible for a role to be "in" Any?

[04:57] <sorear> o/ retupmoca 

[04:57] <retupmoca> \o

[05:12] *** birdwindupbird joined
[05:16] <TimToady> sorear: please read the backlog on that; they aren't really roles

[05:18] <TimToady> I'm just trying to talk about low-level concepts in terms of high-level concepts that don't quite fit

[05:23] *** am0c joined
[05:23] <TimToady> sorear: so, if you don't have a low-level concept of "true", how do you tell if the result of .Bool is true or not?  :)

[05:29] *** daemon left
[05:29] *** daemon joined
[05:30] *** diakopter left
[05:32] *** diakopter joined
[05:32] *** sorear left
[05:33] *** sorear joined
[05:40] *** xjiujiu left
[05:45] *** kaleem joined
[05:45] *** X99 joined
[05:52] *** X99 left
[05:52] *** X99 joined
[05:56] *** xinming left
[05:56] *** kcw left
[05:56] *** xinming joined
[06:03] *** birdwindupbird left
[06:05] *** birdwindupbird joined
[06:06] <moritz> \o

[06:08] <sorear> o/ moritz

[06:09] <sorear> I am not going to understand this proposal until I've had a chance to talk to jnthn, I think

[06:14] <moritz> phenny: tell jnthn that on the bs branch, t/hll/01-language.t segfaults here in default_type_check -- want a backtrace or anything?

[06:14] <phenny> moritz: I'll pass that on when jnthn is around.

[06:33] *** xinming left
[06:42] *** stepnem left
[06:44] *** xinming joined
[06:55] *** X99 left
[06:55] *** xinming left
[06:59] *** thou left
[07:00] *** xinming joined
[07:04] *** zby_home_ left
[07:07] *** tarch joined
[07:07] <TimToady> perl6: for [1..5] X [0..2] -> $a, $b { say "A $a B $b" }

[07:07] <p6eval> pugs b927740: OUTPUT«A 1 0 B 1 1␤A 1 2 B 2 0␤A 2 1 B 2 2␤A 3 0 B 3 1␤A 3 2 B 4 0␤A 4 1 B 4 2␤A 5 0 B 5 1␤A 5 2 B ␤»

[07:07] <p6eval> ..niecza v14-42-g1d02da9: OUTPUT«A 1 2 3 4 5 B 0 1 2␤»

[07:07] <p6eval> ..rakudo bd5adb: OUTPUT«A 1 B 0␤A 1 B 1␤A 1 B 2␤A 2 B 0␤A 2 B 1␤A 2 B 2␤A 3 B 0␤A 3 B 1␤A 3 B 2␤A 4 B 0␤A 4 B 1␤A 4 B 2␤A 5 B 0␤A 5 B 1␤A 5 B 2␤»

[07:08] *** tarch left
[07:08] <TimToady> only niecza++ gets that right

[07:09] <TimToady> unfortunately, http://rosettacode.org/wiki/Knapsack_problem/Unbounded#Perl_6 depends on rakudo's incorrect behavior

[07:09] *** wtw joined
[07:12] *** xinming_ joined
[07:13] <TimToady> perl6: for 1..5 X 0..2 -> $a, $b { say "A $a B $b" }

[07:13] <p6eval> pugs b927740: OUTPUT«A 1 0 B 1 1␤A 1 2 B 2 0␤A 2 1 B 2 2␤A 3 0 B 3 1␤A 3 2 B 4 0␤A 4 1 B 4 2␤A 5 0 B 5 1␤A 5 2 B ␤»

[07:13] <p6eval> ..rakudo bd5adb, niecza v14-42-g1d02da9: OUTPUT«A 1 B 0␤A 1 B 1␤A 1 B 2␤A 2 B 0␤A 2 B 1␤A 2 B 2␤A 3 B 0␤A 3 B 1␤A 3 B 2␤A 4 B 0␤A 4 B 1␤A 4 B 2␤A 5 B 0␤A 5 B 1␤A 5 B 2␤»

[07:14] *** xinming left
[07:14] <TimToady> pugs appears to be assuming a lol that it shouldn't, but both rakudo++ and niecza++ get that one right

[07:20] *** xinming_ left
[07:21] <sorear> fwiw, what you're seeing at :07 is what I call the major design flaw with **@foo

[07:22] <sorear> well, "most major".  I could live with it in 6.0 if nobody has a good fix, it's not blocker-level by any means

[07:22] <sorear> ...wait, we had this discussion already, wrt removing the Any/list fallback

[07:23] *** tarch joined
[07:25] <sorear> heh.  over on #p5p we see... a guy ranting about Perl 5.16 removing a feature.  Which has been officially deprecated since 1998.

[07:28] <moritz> oh. Which one?

[07:29] <sorear> defined(@array)

[07:29] <moritz> oh

[07:35] *** Guest79334 left
[07:35] *** fsergot joined
[07:38] *** pomysl joined
[07:38] *** pomysl left
[07:38] *** pomysl joined
[07:40] *** scott_ joined
[07:40] *** scott_ is now known as Guest83103

[07:48] *** SHODAN left
[07:49] *** SHODAN joined
[07:50] *** xinming joined
[07:50] *** overrosy_ left
[08:02] *** kaleem left
[08:03] *** kaleem joined
[08:06] *** ab5tract left
[08:12] *** fsergot left
[08:13] *** am0c left
[08:20] *** ab5tract joined
[08:22] *** mj41 joined
[08:30] *** noam left
[08:32] *** stepnem joined
[08:34] *** noam joined
[08:46] *** zihan joined
[08:47] <zihan> hi

[08:48] *** zihan left
[09:03] *** lestrrat left
[09:04] *** lestrrat joined
[09:11] *** noam left
[09:12] *** noam joined
[09:25] *** fsergot joined
[09:26] <moritz> nom: say 'foo'.split('+')[0]

[09:26] <p6eval> nom bd5adb: OUTPUT«foo␤»

[09:26] <moritz> nom: say 'foo'.split('+', 2)[0]

[09:26] <p6eval> nom bd5adb: OUTPUT«foo␤»

[09:29] *** mj41 left
[09:29] * moritz has several things to discuss with jnthn++, and really wishes for a higher bandwidth medium than IRC

[09:32] <masak> sort of like a Perl workshop or something.

[09:33] <masak> good antenoon, #perl6.

[09:33] <moritz> oh right, and we two coming up \o/

[09:33] <moritz> I've decided not to tackle <*foo> right now. But I think it's worth attacking sink context.

[09:39] <masak> ++moritz

[09:40] <moritz> I just don't know if it's within my reach

[09:41] *** mj41 joined
[09:41] *** jnthn joined
[09:42] <dalek> rakudo/nom: a94a530 | moritz++ | src/core/Backtrace.pm:

[09:42] <dalek> rakudo/nom: make backtraces a bit more awesome

[09:42] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a94a530a8a

[09:43] <jnthn> morning, #perl6

[09:43] <phenny> jnthn: 06:14Z <moritz> tell jnthn that on the bs branch, t/hll/01-language.t segfaults here in default_type_check -- want a backtrace or anything?

[09:43] *** dakkar joined
[09:43] <jnthn> Dang, irssi hung, lost all my windows. :(

[09:44] <jnthn> Granted it'd been running for six months straight or something...

[09:44] <apejens> 10:44 Irssi uptime: 468d 22h 57m 8s

[09:44] <sorear> morning, jnthn

[09:45] * sorear wonders if jnthn has used /upgrade

[09:45] <jnthn> sorear: no

[09:45] <moritz> apejens: cool

[09:45] <jnthn> apejens: wow. :)

[09:45] <apejens> only thing as stable around here must be the box it runs on :p

[09:46] * jnthn figures he should get stuff ready for this week's Stockholm trip.

[09:47] <moritz> jnthn: I've noticed that string interpolation generates code that boxes the literal chunks, and calls infix:<~> on them and the variables

[09:48] <moritz> jnthn: wouldn't it be more efficient to deal with native strings, and emit concat calls directly?

[09:48] <jnthn> moritz: huh, the literal chunks should be coming from the constant table...

[09:49] <jnthn> moritz: Though yeah, we could just embed them as STRING* literals.

[09:49] <moritz> jnthn: should I add that as an optimizer ROADMAP item, maybe?

[09:49] <jnthn> moritz: You could even make an argument for code-genning it as a join

[09:50] <moritz> ah yes, that's even more efficient, probably

[09:50] <jnthn> moritz: I'd be more inclined to just code-gen it faster in the first place ;-)

[09:54] <moritz> jnthn: second question, I've been thinking about object hashes

[09:54] <moritz> the obvious approach would be have a role, just like for typed hashes, and mix it into Hash

[09:54] <moritz> but that doesn't scale well; if you want both typed keys and values, you're in trouble

[09:55] <moritz> so I think we need a better general approach - have you possibly though of something already?

[09:55] * masak reads what S09 has to say on the topic

[09:55] *** snearch joined
[09:55] <moritz> masak: iirc it just states the expected behavior, not how it's supposed to be done

[09:56] <moritz> ie you write  my %h{Any}, and then can use Any keys

[09:56] <moritz> without stringification, that is

[09:57] <moritz> I've prototyped that functionality in https://gist.github.com/1826725 but that seems to be the easiest part of it

[09:57] *** daxim joined
[09:57] <masak> ooh

[09:58] <masak> yes, that seems to be what S09 says.

[10:05] *** Trashlord joined
[10:13] <jnthn> moritz: I think we should be able to do more efficiently then needing two hashes (one for keys, one for values), fwiw. Parrot's Hash PMC has a set_key_type method, for example. That in turn winds up calling VTABLE_hashvalue.

[10:15] <jnthn> moritz: Beyond that it's mostly wiring that up to .WHICH.

[10:17] <jnthn> moritz: Is your prototype relying on ObjAt stringification?

[10:17] <moritz> jnthn: yes. ObjAt boxes a string right now, so unboxing that would also work

[10:18] <jnthn> Ah, so in this view of things object hashes just call .WHICH on their argument.

[10:19] *** PZt left
[10:19] *** cosimo left
[10:19] *** jtpalmer_ left
[10:19] *** ranguard left
[10:19] *** ranguard joined
[10:20] *** jtpalmer joined
[10:20] * moritz isn't aware of alternative views that would work, and DWIS on value types

[10:20] *** JimmyZ joined
[10:21] *** cosimo joined
[10:22] *** Trashlord left
[10:25] *** Trashlord joined
[10:26] <jnthn> moritz: I guess another override of the role TypedHash that introduces a %!keys would do it

[10:27] *** wolv is now known as wolverian

[10:34] *** PZt joined
[10:35] *** PZt left
[10:37] *** Pzt3 joined
[10:38] <masak> given a shaped array of hashes @AoH, I should be able to do @AoH[*; 'key2'] = @AoH[*; 'key1'], and it assigns the value of 'key1' to the value of 'key2' of every hash in the array, right?

[10:38] *** Pzt3 is now known as PZt

[10:39] *** birdwind1pbird joined
[10:39] <masak> I just got asked the corresponding question from a colleague, but in Perl 5. the best I could give him was either 'for my $hash_ref (@AoH) { $hash_ref->{key2} = $hash_ref->{key1} }' or '$_->{key2} = $_->{key1} for @AoH'.

[10:39] <moritz> can you really do hash indexing in .[]?

[10:39] * masak checks S09 again

[10:40] <moritz> I don't trust S09 too much here, because it's never been implemented

[10:42] <masak> I don't find it in S09.

[10:42] <masak> I agree it's not immediate that it should work.

[10:43] <masak> but that's why I said "shaped array of hashes", because I figgered the compiler or the runtime would need to know that @AoH has a "array of hashes" structure.

[10:43] <jnthn> moritz: I'm quickly playing with something while packing.

[10:44] * masak .oO( repeat while .pack { ... } )

[10:45] <jnthn> My train is an hour later than I'd first thought :)

[10:45] <masak> :)

[10:47] *** birdwind1pbird left
[10:50] *** birdwind1pbird joined
[10:51] <dalek> rakudo/sink: 4d0f65c | moritz++ | / (3 files):

[10:51] <dalek> rakudo/sink: Add a stub Perl6::Sinker to add &sink annotations

[10:51] <dalek> rakudo/sink: 

[10:51] <dalek> rakudo/sink: This is blatantly stolen from Perl6::Optimizer,

[10:51] <dalek> rakudo/sink: and currently just walks the tree and does nothing else

[10:51] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/4d0f65c16f

[10:54] <moritz> nom: say do { if 1 { 2 } }

[10:54] <p6eval> nom bd5adb: OUTPUT«2␤»

[10:57] *** Trashlord left
[11:08] *** Guest83103 left
[11:11] <jnthn> moritz: https://gist.github.com/1835111

[11:12] <moritz> \o/

[11:12] <jnthn> Let's see if I busted any spectests.

[11:14] <moritz> meh, a working PAST dumper would be helpful for the sink stuff

[11:15] <moritz> I'm trying to come up with a list of things that don't need &sink

[11:15] <moritz> and at the same time I wonder if it wouldn't be easier to add :nosink annotations in Perl6::Actions for the less obvious stuff

[11:21] *** birdwind1pbird left
[11:22] *** xinming left
[11:25] <dalek> rakudo/nom: e89eb10 | jnthn++ | src/core/Hash.pm:

[11:25] <dalek> rakudo/nom: First cut of getting moritz++'s object hash prototype work integrated into Hash itself.

[11:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e89eb1088d

[11:25] <dalek> rakudo/nom: b7a852a | jnthn++ | src/Perl6/ (2 files):

[11:25] <dalek> rakudo/nom: Wire up the my %h{SomeType} syntax.

[11:25] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/b7a852a5de

[11:25] <jnthn> moritz: May well be.

[11:26] <jnthn> moritz: It'd perhaps have to be a <nosink> annotation now, but figuring out what we want there means we can put it more neatly into QAST.

[11:28] * moritz nods

[11:30] *** pernatiy left
[11:34] <jnthn> 2 **    Rat/FatRat/Rational cleanup

[11:34] <jnthn> Is that ROADMAP item done now?

[11:45] *** MayDaniel joined
[11:53] *** am0c joined
[11:56] *** sisar joined
[12:04] <jnthn> stockholm ^

[12:04] <jnthn> & even

[12:08] <masak> safe journey.

[12:25] <moritz> jnthn: well, we have Rat and FatRat, but in theory Rational should be a parametric role, and it isn't yet (but I consider that a rather low priority goal right now)

[12:25] *** am0c left
[12:27] <masak> I'm vaguely bothered by the word "OKness". feels like we could do better.

[12:36] *** benabik joined
[12:40] *** pernatiy joined
[12:50] *** bacek joined
[13:11] *** skids left
[13:13] <moritz> that's... my smallest concern with that proposal :-)

[13:14] *** noam left
[13:16] <masak> sure, naming isn't a big deal, and nothing to get stuck on.

[13:16] <masak> but they are often an indication that a concept is missing, or has been overlooked.

[13:17] <masak> to me, "OKness" seems an unwieldy version of a word that we haven't discovered yet.

[13:26] <dalek> roast: 1b362ee | moritz++ | S09-hashes/objecthash.t:

[13:26] <dalek> roast: initial object hash tests

[13:26] <dalek> roast: review: https://github.com/perl6/roast/commit/1b362eeec5

[13:27] <dalek> rakudo/nom: fd74491 | moritz++ | / (2 files):

[13:27] <dalek> rakudo/nom: test object hashes; remove them from the roadmap

[13:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/fd74491c97

[13:28] *** noam joined
[13:34] <masak> moritz++

[13:48] *** kaleem left
[13:48] <dalek> rakudo/nom: e238121 | moritz++ | src/core/Hash.pm:

[13:48] <dalek> rakudo/nom: make Hash.push aware of non-Str keys

[13:48] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/e238121363

[13:48] <dalek> roast: 38ed6b6 | moritz++ | S09-hashes/objecthash.t:

[13:48] <dalek> roast: Hash.push + typed hashes

[13:48] <dalek> roast: review: https://github.com/perl6/roast/commit/38ed6b646f

[13:49] <moritz> so, writing tests does find bugs :-)

[13:49] <moritz> turns out that Hash.push allows creation of arrays as elements in the case that a hash is both typed and key-typed

[13:50] <moritz> if it's just typed, it is correctly prevented

[13:54] *** kaleem joined
[13:55] * JimmyZ can't understands why 0.5 dies ok, but 0.9 lives ok

[13:56] <moritz> JimmyZ: because 0.5 already has a value

[13:56] <moritz> JimmyZ: so Hash.push turns it into an array [$old_value, $new_value]

[13:57] <moritz> JimmyZ: but the type constraint on the hash forbids the creation of an array

[14:00] <JimmyZ> moritz: thanks, just see the old value in the top

[14:05] <masak> nom: sub balanced { return if (my $c += $_ eq "[" ?? 1 !! -1) < 0 for $^s.comb; return !$c }; .say if .&balanced for map { .fmt("%06b").trans("01" => "[]") }, ^64

[14:06] <p6eval> nom bd5adb: OUTPUT«[[[]]]␤[[][]]␤[[]][]␤[][[]]␤[][][]␤»

[14:06] <JimmyZ> it's give me an impression  that typed hash is slower than untyped hash

[14:06] *** raoul joined
[14:07] <JimmyZ> *giving

[14:07] <moritz> JimmyZ: how did you arrive at that conclusion? did you benchmark the two?

[14:08] <masak> nom: sub balanced { return if (my $c += $_ eq "[" ?? 1 !! -1) < 0 for $^s.comb; return !$c }; .say when &balanced for map { .fmt("%06b").trans("01" => "[]") }, ^(2 ** 6)

[14:08] <p6eval> nom bd5adb: OUTPUT«[[[]]]␤[[][]]␤[[]][]␤[][[]]␤[][][]␤»

[14:09] <JimmyZ> moritz: same pir ops, but typed hash uses more

[14:09] <moritz> JimmyZ: that's not a good way to judge performance. Not at all.

[14:10] <JimmyZ> moritz: just an impression, hehe

[14:12] <moritz> but you are right, they are slower

[14:13] <moritz> 6.6s (no types) vs 8.5 (just value types) vs 12s (both values and keys typed)

[14:14] <JimmyZ> moritz: yes, pmc hash object is the killer, from bacek++'s gist

[14:17] *** jaldhar joined
[14:18] *** kaleem left
[14:26] <masak> nom: sub balanced { all((my $c += $_ eq "[" ?? 1 !! -1) < 0 for $^s.comb) && !$c }; .say when &balanced for (^(2 ** 6))».fmt("%06b")».trans("01" => "[]")

[14:26] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Redeclaration of symbol $c␤at /tmp/f7OZkWSnoP:1␤»

[14:27] <masak> huh.

[14:27] <moritz> nom: my $x = $_ for 1..2

[14:27] <p6eval> nom bd5adb:  ( no output )

[14:28] <masak> hehe, I just did that locally :P

[14:28] <moritz> but why all()?

[14:28] <masak> yeah, that's a bad choice.

[14:28] <masak> shoulda gone with [&&]

[14:29] <masak> all() doesn't guarantee me order, and I want that here.

[14:30] <masak> nom: say all(my $c for ())

[14:30] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Redeclaration of symbol $c␤at /tmp/ihiTsgEUHA:1␤»

[14:30] <masak> nom: all(my $c for ())

[14:30] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Redeclaration of symbol $c␤at /tmp/XLWPyMzIwp:1␤»

[14:30] <masak> that's the shortest I can make it.

[14:30] * masak submits rakudobug

[14:31] <masak> nom: sub balanced { ([&&] ((my $c += $_ eq "[" ?? 1 !! -1) < 0 for $^s.comb)) && !$c }; .say when &balanced for (^(2 ** 6))».fmt("%06b")».trans("01" => "[]")

[14:31] <p6eval> nom bd5adb:  ( no output )

[14:31] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[', ??  1, -1}; @c[*-1] == 0 && not grep * < 0, [\+] @c }; say balanced '[]'

[14:31] <p6eval> nom bd5adb: OUTPUT«False␤»

[14:32] <masak> too many [\+]

[14:32] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[', ??  1, -1}; @c[*-1] == 0 && not grep * < 0, @c }; say balanced '[]'

[14:32] <p6eval> nom bd5adb: OUTPUT«False␤»

[14:32] <masak> and 'not grep' better written 'none' :)

[14:33] <moritz> nom: my $c = '[[][]]'; my @c = [\+] $c.comb.map: { $_ eq '[' ?? 1, -1 }; say @c

[14:33] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Found ?? but no !! at line 1, near ", -1 }; sa"␤»

[14:33] <moritz> nom: my $c = '[[][]]'; my @c = [\+] $c.comb.map: { $_ eq '[' ?? 1 !! -1 }; say @c

[14:33] <p6eval> nom bd5adb: OUTPUT«1 2 1 2 1 0␤»

[14:33] <masak> yeah, huh, how did the above even compile?

[14:33] <masak> that seems to be yet another bug.

[14:33] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ??  1, -1}; @c[*-1] == 0 && not grep * < 0, @c }; say balanced '[]'

[14:33] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Found ?? but no !! at line 1, near ", -1}; @c["␤»

[14:33] <moritz> which "above"?

[14:33] <masak> oh ', ??'

[14:33] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ??  1 !! -1}; @c[*-1] == 0 && not grep * < 0, @c }; say balanced '[]'

[14:33] <p6eval> nom bd5adb: OUTPUT«True␤»

[14:34] <masak> nevermind.

[14:34] <masak> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ??  1 !! -1}; @c[*-1] == 0 && none(@c) < 0 }; say balanced '[]'

[14:34] <p6eval> nom bd5adb: OUTPUT«none(False, False)␤»

[14:34] <masak> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ??  1 !! -1}; @c[*-1] == 0 && so none(@c) < 0 }; say balanced '[]'

[14:34] <p6eval> nom bd5adb: OUTPUT«True␤»

[14:34] <masak> \o/

[14:34] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ??  1 !! -1}; @c[*-1] == 0 && not grep * < 0, @c }; say $_, balanced $_ for '[[][]]', '][', ['

[14:34] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Confused␤at /tmp/L0yD9O0N9k:1␤»

[14:35] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ??  1 !! -1}; @c[*-1] == 0 && not grep * < 0, @c }; say $_, balanced $_ for '[[][]]', '][', '['

[14:35] <p6eval> nom bd5adb: OUTPUT«[[][]]True␤][False␤[False␤»

[14:35] *** skids joined
[14:35] <moritz> masak: you can replace '&& so none'  with '?& none' I think

[14:36] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ?? 1 !! -1}; @c[*-1] == 0 ?& none(@c) < 0 }; say balanced '[]'

[14:36] <p6eval> nom bd5adb: OUTPUT«False␤»

[14:36] * moritz sucks at this

[14:37] <masak> :)

[14:37] <moritz> nom: sub balanced($c) { my @c = [\+] $c.comb.map: { $_ eq '[' ?? 1 !! -1}; @c[*-1] == 0 ?& (none(@c) < 0) }; say balanced '[]'

[14:37] <p6eval> nom bd5adb: OUTPUT«True␤»

[14:37] <moritz> precedence. You must be aware of it.

[14:37] *** xinming joined
[14:37] <masak> :)

[14:37] *** PacoAir joined
[14:39] <moritz> it's a bit sad that @c must be checked for two conditions, so we can't use it anonymously

[14:42] <masak> nom: subset NonNegative of Positional where { none(@^l) < 0 }; subset LastZero of Positional where { @^l[*-1] == 0 }; sub balanced { ([\+] $^s.comb.map: { $_ eq '[' ?? 1 !! -1 }) ~~ NonNegative && LastZero }; say balanced '[]'

[14:42] <p6eval> nom bd5adb: OUTPUT«Positional()␤»

[14:42] <masak> augh.

[14:42] <masak> nom: subset NonNegative of Positional where { none(@^l) < 0 }; subset LastZero of Positional where { @^l[*-1] == 0 }; sub balanced { ([\+] $^s.comb.map: { $_ eq '[' ?? 1 !! -1 }) ~~ NonNegative & LastZero }; say balanced '[]'

[14:42] <p6eval> nom bd5adb: OUTPUT«Type check failed in assignment to '$v'; expected 'Mu' but got 'NonNegative'␤  in sub balanced at /tmp/dybF1FYbfQ:1␤  in block <anon> at /tmp/dybF1FYbfQ:1␤␤»

[14:43] *** tarch left
[14:43] <masak> o.O

[14:43] <masak> there... is no '$v'.

[14:48] <moritz> nom: say 5.rand for 1..10;

[14:48] <p6eval> nom bd5adb: OUTPUT«0.589615948633782␤2.73160865109944␤1.31823730208515␤1.8823077592376␤1.39960468810878␤2.44574718286451␤1.20200606364206␤2.38582855111002␤3.67438593525735␤1.49030266708337␤»

[14:48] <lumi___> nom: subset Foo of Int where { * }; say Foo

[14:48] <p6eval> nom bd5adb: OUTPUT«Foo()␤»

[14:48] <lumi___> nom: subset Foo of Positional where { * }; say Foo

[14:49] <p6eval> nom bd5adb: OUTPUT«Positional()␤»

[14:49] <lumi___> That's kind of weird

[14:49] <moritz> nom: role A { }; subset Foo of A where True; say Foo;

[14:49] <p6eval> nom bd5adb: OUTPUT«A()␤»

[14:49] <moritz> seems subsets of roles aren't OK

[14:50] *** preflex_ joined
[14:51] <masak> they don't identify themselves well.

[14:51] <moritz> nom: https://gist.github.com/1836329

[14:51] <p6eval> nom bd5adb: OUTPUT«[][][][][[]]␤»

[14:51] <moritz> nom: https://gist.github.com/1836329

[14:51] <p6eval> nom bd5adb: OUTPUT«[[[]]][][][]␤»

[14:52] *** preflex left
[14:52] *** preflex_ is now known as preflex

[14:52] <moritz> masak: I guess they aren't uniformly distributed, but IMHO it's a nice solution

[14:52] <masak> was just gonna say :)

[14:52] <moritz> nom: say 0.rand

[14:52] <p6eval> nom bd5adb: OUTPUT«0␤»

[14:52] <masak> nice, but I can almost guarantee that they aren't uniformly distributed.

[14:53] <masak> I've been toying with the idea of a binary decision tree during the day.

[14:53] <masak> that idea might fly if there's a way to generate the weights of the tree without first generating all strings.

[14:53] <masak> and that seems plausible.

[14:53] <moritz> I'd like to see an indication that they aren't uniformely distributed

[14:54] <moritz> let's try to do the math for $c == 2, so a total string of length 4

[14:55] <moritz> we have [][] and [[]] as possible solutions

[14:55] <moritz> so once we've generated the '[', the probabilities for '[' and ']' should be equal

[14:55] <masak> running a simulation for $c == 4.

[14:55] <moritz> and... they are not

[14:55] <moritz> they are 1/3 vs. 2/3 in my code

[14:56] <masak> "[][][][]" is about 8 times as common as "[[[[]]]]".

[14:56] <masak> I like this problem, it's elusive ;)

[14:57] <moritz> should ']' and '[' be equally probable as long as both are allowed?

[14:57] <masak> no.

[14:57] <masak> the first char is always '['.

[14:58] <masak> the second, in the case of '[][][]'-length strings, is '[' with prob 2/5 and ']" with prob 3/5.

[14:58] <masak> s/"/'/

[14:58] <moritz> that's what my code does, curiously

[14:59] <masak> oops, sorry. i got the probabiliries reversed just there.

[14:59] <masak> '[' is 3/5, ']' is 2/5.

[15:00] <moritz> indeed.

[15:00] <masak> nom: https://gist.github.com/1836395

[15:00] <p6eval> nom bd5adb: OUTPUT«[][][][[][]]␤»

[15:00] <moritz> there are 5 distinct ways to write them with $c == 3, right?

[15:00] <masak> factored out some repetition :)

[15:00] <masak> moritz: right.

[15:01] <masak> because https://oeis.org/A000108

[15:01] <moritz> masak: ah yes, I've thought of that too (but didn't do it)

[15:02] <masak> not sure it was worth it.

[15:03] *** birdwindupbird left
[15:10] *** sisar left
[15:17] <moritz> masak: maybe the closed form for the number of total strings can be used to construct the probabilities

[15:17] <moritz> for each step, that is

[15:18] <masak> the closed form for the total number of strings will be equal to the denominator in the first choice, yes.

[15:19] <masak> it doesn't immediately indicate what the numerators are, or how to make subsequent choices.

[15:20] <moritz> well, I thought that maybe one can find paths in pascal's triangle that represent the numerators of the probabilities, or something

[15:21] <masak> ooh

[15:23] <moritz> but it's really just a rather handwavy idea

[15:23] *** tokuhirom joined
[15:24] <masak> it gave me a lot of new ideas :)

[15:28] <masak> ok, I'm now convinced that the probabilities can be calculated *a priori*.

[15:28] *** kmwallio joined
[15:29] *** Bucciarati left
[15:29] <moritz> what do you mean by "a priori"?

[15:30] <masak> "without precalculating all the strings of that length"

[15:31] <moritz> ok

[15:31] <masak> the probabilities can be derived from the geometry of a Pascal-like triangle.

[15:31] <moritz> I think so, but I'm not sure how the exact rules for deriving those numbers are

[15:32] <moritz> but there are interesting recursion properties in there

[15:32] <moritz> for example if you construct a string of length 6, the probabilities after '[[]' and after '[][' are the same as for constructing a string of length 4 after '[' has been given

[15:32] <masak> I've basically worked it out now.

[15:33] <masak> just need to write something up.

[15:33] *** snearch left
[15:34] <moritz> maybe it even makes sense to build them up from the end

[15:35] <masak> by symmetry it makes no difference... :)

[15:35] <masak> the algorithm I have in sight can do it from either end.

[15:35] <moritz> the probability table, not the strings :-)

[15:36] <masak> oh, I've left the idea of building a probability table.

[15:36] <masak> I just calculate the probabilities on demand.

[15:36] <moritz> I'm still in the process of trying to understand the probabilities

[15:36] <moritz> so I want to build a table to understand how they are calculated

[15:37] <moritz> and once I understood them, I can find closed forms to calculate them as I go along

[15:37] <moritz> but you're two steps ahead of me here :-)

[15:37] <masak> here's how I started down the current path: I imagined a "[" as a leftwards diagonal arrow, and a "]" as a rightwards diagonal arrow.

[15:37] <masak> so each string forms a path.

[15:38] <masak> it's significant that the paths diverge and converge.

[15:38] <masak> and all of them form a triangular kind of graph.

[15:38] *** tarch joined
[15:39] <moritz> aye

[15:42] <moritz> I was thinking of a function a(n, i), where n is the number characters to go, and i the number of already used '[' minus the number of already used ']'

[15:42] <moritz> so a(n, 0) = c(2n), where c are the catalan numbers

[15:43] *** sisar joined
[15:43] <moritz> and a(n, i) tells me how many options I have left at that point

[15:44] *** tokuhir__ joined
[15:44] <moritz> and I know that a(n, n/2) == 1

[15:44] *** Psyche^ joined
[15:44] *** thou joined
[15:45] <moritz> and a(n-1, 1) is also c(2n)

[15:45] *** tokuhir__ left
[15:45] *** tokuhir__ joined
[15:46] <moritz> but that alone isn't enough

[15:46] * moritz waits for more enlightenment from masak++

[15:46] <masak> enlightenment coming up.

[15:46] *** tokuhirom left
[15:47] <moritz> ah, and of course a(n, k) = a(n-1, k) + a(n-1, k+1)

[15:47] *** Patterner left
[15:47] *** Psyche^ is now known as Patterner

[15:47] <moritz> erm no

[15:48] <moritz> a(n, k) = a(n-1, k-1) = a(n-1, k+1)

[15:48] <moritz> which shows the bit-like-Pascal-triangle-but-not-quite relation

[15:48] <sisar> since nqp is a subset of perl6, is it 'feature'-frozen? i mean, if you continue to add more and more specs of p6, what prevents it from becoming a full-fleged compiler itself?

[15:48] <sisar> its possible i'm might have a completly wrong picture here, so please correct me

[15:48] *** tokuhirom joined
[15:50] <moritz> sisar: nqp is a tool. It's not feature frozen, but we only enhance it if we see it as the path of least resistance to get something done

[15:50] <moritz> sisar: also nqp should stay fast, so it won't implement stuff that is hard to do on top of parrot (or whatever platforms it will run on in the future)

[15:52] *** tokuhir__ left
[15:53] <sisar> so speed and 'path of least resistance' mark the line between what goes into nqp ? no other considerations ?

[15:54] *** wtw left
[15:54] <sisar> ah, if something is required for bootstrapping, then it might also be needed in nqp

[15:54] <sisar> mean implemented in nqp

[15:54] <masak> nom: my $L = 4; sub p($x, $y) { $y && $x + $y < $L ?? p($x + 1, $y) + p($x, $y - 1) !! 1 }; my ($x, $y) = 0, $L; while $x < $L { if $L - ($x + $y) == 0 { print "["; $y-- } elsif $y == 0 { print "]"; $x++ } else { my ($d, $r) = p($y - 1, $x), p($y - 1, $x + 1); if ($d + $r).rand < $d { print "["; $y-- } else { print "]"; $x++ } } }

[15:54] <p6eval> nom bd5adb: OUTPUT«[][[][]]»

[15:54] <masak> presto.

[15:55] <masak> uniform distribution in a box.

[15:55] <masak> ladies and gentlemen, we have arrived.

[15:55] <moritz> sisar: one could argue that "required for bootstrapping" is part of "least resistance"

[15:56] <JimmyZ> nom: my Int %hash{int}; %hash{1} = 2;

[15:56] <p6eval> nom bd5adb: OUTPUT«===SORRY!===␤Shaped variable declarations are not yet implemented at line 1, near "; %hash{1}"␤»

[15:56] <TimToady> re balanced brackets: http://irclog.perlgeek.de/search.pl?channel=perl6&nick=&q=Quincunx

[15:56] <sisar> moritz: i agree

[15:57] <masak> TimToady: oh, right. I had forgotten you had mentioned that.

[15:57] <moritz> masak: your p() is a bit like my a(), and has the same recurrence

[15:57] <masak> TimToady: to what extent is my solution above similar to the one you arrived on, with the table?

[15:58] *** lateau_ joined
[15:58] <masak> moritz: 'p' is for 'number of choice points' (from here on and downstream)

[15:58] <moritz> masak: and note that p() recurses, so that can be equivalently written as a table

[15:58] <masak> I have a feeling it has a closed form too.

[15:58] <moritz> (so that it doesn't have to be recomupted)

[16:04] <moritz> wait, it's not the same recurrence

[16:06] *** JimmyZ left
[16:08] *** tokuhirom left
[16:09] <moritz> masak: so, $y is the number of [' to be still printed, and $x is the number of ]'s already printed?

[16:10] <moritz> then it does map to my recurrence, with n == $x + $y and k = $L + $x - $y, I think

[16:10] * moritz too confused

[16:10] <masak> nod.

[16:11] <masak> it's possible that there's a much better coordinate system for that algorithm.

[16:11] <moritz> I like mine because it doesn't have to carry $L around

[16:11] <masak> well, you need $L in some form.

[16:11] <masak> to get uniformity.

[16:12] <TimToady> in diamond quincunx terms, you can turn it 45° and run the x and y as choice of left or right, and the limit is the size of the square 

[16:12] <moritz> masak: yes, in my case n starts out as $L

[16:12] <moritz> erm no, that's not right

[16:13] <moritz> 2 * $L

[16:13] <moritz> but then the mapping isn't right

[16:13] <moritz> GRRRRR

[16:13] * moritz too distracted

[16:13] <masak> :)

[16:13] <masak> I feel we have gotten somewhere today, though.

[16:13] <moritz> well, you have, mostly :-)

[16:13] <masak> I can't find a closed form for &p, but if I do, I'll consider this problem solved.

[16:13] <TimToady> you can start both x and y at the length of a side of the square, and just decrement randomly till both are 0

[16:14] <masak> TimToady: making sure never to cross the diagonal.

[16:14] *** tarch left
[16:14] *** tarch joined
[16:14] <TimToady> right

[16:14] <masak> and "randomly" still needs to be weighted in a certain way to make the results come out uniform.

[16:15] <masak> and that's what I do above.

[16:15] <TimToady> yes, Aron figured that out last year, and wrote it down, but I don't think it got online

[16:15] <masak> yes, it did.

[16:15] <TimToady> okay

[16:15] <masak> http://irclog.perlgeek.de/perl6/2011-07-31#i_4196730

[16:16] <TimToady> I believe he figured it out from the back end

[16:16] <masak> http://irclog.perlgeek.de/perl6/2011-07-31#i_4198360

[16:17] <masak> my insight today was that the probability of a given choice is proportional to the number of possible paths downstream of the current choice point.

[16:18] <masak> er, downstream of following that choice.

[16:19] <masak> yes, Aron's solution looks like it has the same thinking behind it.

[16:19] <TimToady> that was how Aron thought of it :)

[16:23] *** tarch_ joined
[16:23] *** tarch left
[16:29] <masak> now I'm a bit annoyed that my calculate-the-probabilities solution reduces to Aron's DP solution :P

[16:31] <TimToady> now you know how I feel every time I invent something independently and then someone claims it was derived from such and such in the literature that I never read :)

[16:31] <masak> curse you, connectedness of everything! :P

[16:33] <skids> damn math.  why does it have to be so universal?

[16:33] <TimToady> masak: careful, the connectedness of everything might be listening...

[16:35] * masak sucks up a bit to the connectedness of everything, just in case

[16:36] <masak> maybe someone in here can help me find the closed formula?

[16:36] * [Coke] listens to TimToady give a talk about how he drinks Pepsi. The horror.

[16:37] <geekosaur> the connectedness of everything may be listening, but if it were competent the world wouldnt be such a mess :p

[16:38] <TimToady> non-messes are boring

[16:39] <masak> it has two parameters, so it's a sequence of sequences. the first sequence is 1, 1, 1, 1, 1, 1..., the second is 1, 2, 3, 4, 5..., the third is 1, 4, 8, 13..., and each new sequence starts with 1, and then each term is the sum of the previous one (in the current sequence) and the next one (in the previous sequence).

[16:41] <masak> oeis.org says that the formula for the third one is C($n + 1, 2) + $n - 1, but it has no clue about that fourth one.

[16:42] *** isBEKaml joined
[16:42] <masak> isBEKaml! \o/

[16:43] <isBEKaml> \masak/

[16:44] <skids> nom: class A { multi method postcircumfix:<( )> (::T $s: $c) { T.say; $c.WHAT.say; }}; my $a = A.(4); # specs on this are strange, why the unflattening capture OOC?

[16:44] <p6eval> nom bd5adb: OUTPUT«A()␤Capture()␤»

[16:44] <isBEKaml> masak: you saw my pugs msg? Do you intend to bring it back alive? 

[16:45] *** tarch__ joined
[16:46] *** tarch_ left
[16:46] <masak> this one? http://irclog.perlgeek.de/perl6/2012-02-14#i_5149217

[16:47] <masak> it'd be fun to dig into Pugs, yes. I think it'd be good for everyone if the project were actively developed again.

[16:47] <isBEKaml> masak: yeah. it was quite easy to set it up once I had cabal installed. 

[16:48] <skids> pugs served to remind other implementations how far they had to go WRT laziness :-)

[16:48] *** dakkar left
[16:49] <masak> isBEKaml: cabal was already installed for me on feather. I installed all the dependencies. everything built fine until I suddenly got a compile error in the second-last step.

[16:49] <isBEKaml> skids: lazy bum on the beach, working his ass off! (pugs) :D

[16:50] <isBEKaml> masak: that was what prompted me to send out that msg. :)

[16:51] *** Trashlord joined
[16:51] *** dakkar joined
[16:51] <isBEKaml> masak: I didn't upgrade GHC since 7.4 with all parallel processing bells and whistles don't make much sense on an ancient machine. 

[16:51] <masak> isBEKaml: right. moritz got it to run on 7.4.1, though.

[16:52] <masak> no idea how he did it, both [Coke] and I get the error. :/

[16:55] <isBEKaml> masak: oh, peek into his .cabal tree? :)

[16:55] <masak> TimToady: should I expect something like '@AoH[*]<key2> = @AoH[*]<key1>;' to work in Perl 6? can it be sugared into '@AoH[*, "key2"] = @AoH[*, "key1"];'?

[16:55] <masak> isBEKaml: it was identical to [Coke], IIUC.

[16:55] <masak> er, to [Coke]'s.

[16:56] *** raoul left
[16:57] * masak decommutes

[16:57] <TimToady> masak: I think as currently defined you'd have to write it with hypers: @AoH[*]»<key2> = @AoH[*]»<key1>

[17:00] *** cognominal___ joined
[17:01] *** pernatiy left
[17:02] *** cognominal_ left
[17:08] *** kcw joined
[17:10] <TimToady> for the record, OKness is the third or fourth word I've had there...most candidates are too long or too overloaded or too confusing

[17:14] *** tarch joined
[17:15] *** tarch__ left
[17:16] *** tarch_ joined
[17:17] *** tarch_ left
[17:18] *** tarch__ joined
[17:18] *** tarch left
[17:21] *** hemi22189 joined
[17:22] *** kaare_ joined
[17:22] <TimToady> #phasers in 7?

[17:22] <hemi22189> hi

[17:23] <TimToady> howdy

[17:23] *** hemi22189 left
[17:27] <isBEKaml> nom: my $x = 42 but False; say "Foo!" unless $x; say "bar" if $x;

[17:27] <p6eval> nom bd5adb: OUTPUT«bar␤»

[17:27] <isBEKaml> ^^ is that right? 

[17:28] <geekosaur> I think that's a known issue

[17:29] <isBEKaml> jnthn++ said he fixed it in his #phasers report. Got me curious. 

[17:29] <benabik> Fixed in d4d4a2

[17:29] <isBEKaml> so nom not built yet. I see.

[17:29] <benabik> p6eval just needs to be updated.

[17:29] <moritz> I could imagine that the rakudo builds start to fail due to memory requirements

[17:30] <moritz> no

[17:31] <moritz> it says it couldn't find nqp::div_In

[17:31] <moritz> which implies that NQP is too old

[17:31] <moritz> but I did bump NQP_REVISION, didn't I?

[17:32] <moritz> has anybody else trouble building latest nom with --gen-parrot / --gen-nqp?

[17:33] *** localhost joined
[17:33] <TimToady> trying, didn't require a reConf with I said make

[17:34] *** yeltzooo left
[17:35] <moritz> well, the last NQP bump was 2 days ago

[17:35] *** yeltzooo joined
[17:35] *** tarch__ left
[17:35] *** tarch joined
[17:36] *** kaleem joined
[17:36] <TimToady> colomon: #phasers?

[17:37] <TimToady> trying a hilite...

[17:37] <colomon> ooo, right!@

[17:37] <colomon> !

[17:37] <benabik> NQP_REVISION seems to be correct.

[17:39] <TimToady> tadzik: #phasers?

[17:39] <TimToady> [Coke]: #phasers?

[17:48] *** lateau_ left
[17:49] *** Chillance joined
[17:53] *** dakkar left
[17:53] *** tarch left
[18:07] *** mj41 left
[18:10] *** pernatiy joined
[18:16] *** jaldhar left
[18:16] *** jaldhar joined
[18:21] *** kaleem left
[18:21] <TimToady> just did a fairly heavy revision of http://rosettacode.org/wiki/Knapsack_problem/Unbounded#Perl_6 to make it work under niecza

[18:21] <TimToady> niecza doesn't like:

[18:22] <TimToady> has ($.foo, $.bar);

[18:22] <TimToady> it doesn't seem to do $object."$methname"() yet

[18:22] <TimToady> and it blew up for mysterious reasons on the printf

[18:23] <TimToady> there's an interesting indentation idiom on the for ... X ... X ... -> $p, $i, $g

[18:25] *** Trashlord left
[18:26] <colomon> TimToady: I've seen niecza blow up on printfs as well, that was one of the issues I ran into during the panda port.

[18:29] <[Coke]> sorry about phasers. it was lunch time here.

[18:33] *** Teratogen left
[18:33] *** sisar left
[18:36] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; say Blah.new([10, 12, 14])

[18:36] <p6eval> niecza v14-42-g1d02da9: OUTPUT«Unhandled exception: Excess arguments to List.new, used 1 of 2 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (List.new @ 1) ␤  at /tmp/BKNyZ3K7fj line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3773 (ANON @ 3) ␤  at /ho…

[18:37] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; say Blah.new(Array{ [10, 12, 14] })

[18:37] <p6eval> niecza v14-42-g1d02da9: OUTPUT«Unhandled exception: Excess arguments to List.new, used 1 of 2 positionals␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (List.new @ 1) ␤  at /tmp/w6Jxmrw2ej line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3773 (ANON @ 3) ␤  at /ho…

[18:37] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; say Blah.new()

[18:37] <p6eval> niecza v14-42-g1d02da9: OUTPUT«␤»

[18:41] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; my $a = Blah.new(); $a[0] = 10; say ~$a;

[18:41] <p6eval> niecza v14-42-g1d02da9: OUTPUT«10␤»

[18:42] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; my $a = Blah.new(); $a[0] = 10; $a[1] = 11; say ~$a;

[18:42] <p6eval> niecza v14-42-g1d02da9: OUTPUT«10␤»

[18:42] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; my $a = Blah.new(); $a[] = 1..10; say ~$a;

[18:42] <p6eval> niecza v14-42-g1d02da9: OUTPUT«Unhandled exception: No value for parameter 'index' in 'postcircumfix:<[ ]>'␤  at /home/p6eval/niecza/lib/CORE.setting line 0 (postcircumfix:<[ ]> @ 1) ␤  at /tmp/xVFbuk8Nwy line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3773 (ANON @…

[18:42] <colomon> niecza: class Blah is Array { method Str { ~self[0]; }; }; my $a = Blah.new(); $a[0..9] = 1..10; say ~$a;

[18:42] <p6eval> niecza v14-42-g1d02da9: OUTPUT«1␤»

[18:43] *** localhost left
[18:45] <moritz> nom: .say if 0 but True

[18:45] <p6eval> nom e23812: OUTPUT«Any()␤»

[18:45] <moritz> nom: my %foo{Int} = 3; say %foo.keys[0].WHAT

[18:45] <p6eval> nom e23812: OUTPUT«Odd number of elements found where hash expected␤  in method STORE at src/gen/CORE.setting:5529␤  in block <anon> at /tmp/1rIUWs9ZAq:1␤␤»

[18:46] <moritz> nom: my %foo{Int}; %foo{2} = 3; say %foo.keys[0].WHAT

[18:46] <p6eval> nom e23812: OUTPUT«Int()␤»

[18:46] *** localhost joined
[18:49] *** Trashlord joined
[18:52] *** tarch joined
[18:53] *** xinming left
[18:57] <skids> nom: my grammar G { token foo { <?{ fail("other") }> }}; my $s = "a" ~~ m/<?{fail "local"}>/; $s.perl.say; $s = "a" ~~ m/<G::foo>/; $s.perl.say;

[18:57] <p6eval> nom e23812: OUTPUT«Bool::False␤Can not get non-existent attribute '$!pos' on class 'Cursor'␤  in regex <anon> at /tmp/iqQkhFtT8E:1␤  in method ll-match at src/gen/CORE.setting:3522␤  in method match at src/gen/CORE.setting:3570␤  in block <anon> at /tmp/iqQkhFtT8E:1␤␤»

[18:59] *** GlitchMr joined
[18:59] <moritz> that error message sucks

[18:59] <moritz> but I think it's wrong to use fail there

[19:01] <skids> Works for the local case, just unusual it doesn't work for the imported grammar.  According to TimToady++ , the actual interwork of fail and backtracking is still TBD.

[19:04] *** daxim left
[19:05] <skids> my grammar G { token foo { <?{ fail("other") }> }}; my $s = G.parse("a", :rule<foo>); $s.perl.say; #also works fine with .parse

[19:06] *** birdwindupbird joined
[19:07] *** retup-work left
[19:09] *** raoul joined
[19:09] *** retup-work joined
[19:14] <dalek> rakudo/nom: f9fcb24 | moritz++ | src/core/Hash.pm:

[19:14] <dalek> rakudo/nom: hide Hash.STORE from backtraces

[19:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f9fcb24c8d

[19:26] *** rindolf joined
[19:27] <TimToady> in looking at some of the style changes I tend to apply to other folk's RC entries, I see something that puzzles me

[19:27] <TimToady> it's when people value DRY above clarity

[19:28] <TimToady> it most often shows up when people do everything in their power to avoid using the same declarator on multiple lines, preferring instead to declare a list of things, and then assign a list of initializers to that

[19:28] <TimToady> this is often quite unclear

[19:29] <TimToady> whereas the vertical lining up of similar constructs, while a technical violation of DRY, should be encouraged when clarity is enhanced

[19:30] <TimToady> Perl 6 gives more ways to factor things out, and hence more ways to avoid visual parallelism

[19:30] <colomon> examples?  I"m having a hard time visualizing either approach....

[19:30] <TimToady> but avoiding visual parallelism is often the path to more gobbledygooky code

[19:31] <colomon> (please)

[19:32] <TimToady> well, first understand I'm not just picking on one person here, but here's the latest example

[19:32] <TimToady> compare http://rosettacode.org/mw/index.php?title=Knapsack_problem/Unbounded&oldid=132299#Perl_6

[19:33] <flussence> perl6: say [] + [], [] + {}, {} + []

[19:33] <p6eval> rakudo f9fcb2, niecza v14-42-g1d02da9: OUTPUT«000␤»

[19:33] <p6eval> ..pugs b927740: OUTPUT«00␤»

[19:33] <TimToady> to http://rosettacode.org/mw/index.php?title=Knapsack_problem/Unbounded&oldid=132333#Perl_6

[19:33] <flussence> 00␤?

[19:33] <flussence> pugs: say [] + []

[19:33] <p6eval> pugs b927740: OUTPUT«0␤»

[19:33] <TimToady> the diff is at http://rosettacode.org/mw/index.php?title=Knapsack_problem/Unbounded&curid=3196&diff=132333&oldid=132299

[19:34] <flussence> pugs: say ([] + {}).WHAT, ({} + []).WHAT

[19:34] <p6eval> pugs b927740: OUTPUT«NumNum␤»

[19:34] <flussence> perl6: say ([] + []), ([] + {}), ({} + []) # oh, probably a precedence thing...

[19:34] <p6eval> pugs b927740, rakudo f9fcb2, niecza v14-42-g1d02da9: OUTPUT«000␤»

[19:36] <colomon> TimToady: you're talking about initializing $panacea, etc and $max_val etc?

[19:37] <TimToady> things like: my ($max_val, @solutions, %max_items) = 0;

[19:37] <colomon> you'd prefer it with three mys, yes?

[19:37] *** snearch joined
[19:38] <TimToady> yes, that's what is in the other solution

[19:38] <TimToady> there's another use of indirect method calls to avoid write two parallel "next ifs", which is a similar DRY over clarity, in my opinion

[19:38] <TimToady> *writing

[19:39] <colomon> I'm with you 100% on my ($max_val, @solutions, %max_items) = 0;

[19:39] <mikemol> !define DRY

[19:39] <TimToady> Don't Repeat Yourself

[19:40] <colomon> I'm a big fan of DRY, but I don't consider saying "my" three times instead of one to count.  :)

[19:40] <flussence> non-sequitur code between an infix and its args (though this is just my opinion :) = bad stuff

[19:40] <TimToady> I'm mostly just trying to understand how people think, when they don't think like I do. :)

[19:41] <mikemol> FWOW, I don't like the my "($max_val, @solutions, %max_items) = 0;" line, because it's a lot for a newcomer to chew over in a single line.

[19:41] <TimToady> I know Perl, and I had to read it three times.

[19:42] <TimToady> it's not just newcomers :)

[19:42] <mikemol> What does it mean to assign 0 to an array and to a dict? Individually, they'd be quick to understand, but having them that close in context makes it trickier for me to grok them that way.

[19:42] <TimToady> after it uses up the 0, all that is left to assign to the others is ()

[19:43] *** Trashlord left
[19:43] <mikemol> Ok, now *that* completely flew past me on reading.

[19:43] <mikemol> I read it more like the 0 being applied to each of the vars declared in the (...)

[19:44] <TimToady> but I'd like to know why some people prefer to write it that way

[19:44] <mikemol> Ok, so (...) is a bad way to describe it, as that probably has its own semantic meaning...

[19:44] <TimToady> mikemol: that's how I read it the first time, and realized it couldn't be true :)

[19:46] <TimToady> it parses the (...) as a signature, but if it looks like a Perl 5 list assignment, it trying to keep those semantics, making the array and hash implicitly slurpy

[19:46] <TimToady> *tries

[19:46] <TimToady> but this is not terribly obvious to people not coming from Perl 5

[19:47] <colomon> "indirect method calls to avoid write two parallel "next ifs"" -- finally looked at this code, it's nearly completely insane IMO.  But hey, TMTOWTDI...

[19:47] <TimToady> I think it's just treating DRY as a supreme principle, but that's just a guess

[19:48] <mikemol> Honestly, it looks like something I might write, if I understood Perl 6 well enough. Thing is, I'd do it that way because I *deplore* tedium in code, which leats to a lot of utility methods so I can reach DRY.

[19:48] <TimToady> good rhetoricians know that repeating yourself is essential to effective communication

[19:49] <TimToady> at some point, adding indirection is more obfuscatory than not

[19:50] <mikemol> Looking at the code, it wouldn't be so obfuscatory if $c were a more descriptive variable name. Even giving it the name $method would help be expository.

[19:51] <skids> Well, to play devil's advocate, it is more extendible.  One could just add an element to add another criteria.

[19:51] <mikemol> Which reminds me...

[19:51] <TimToady> sure, and if I had five of them stacked up, I might start to consider such a solution

[19:51] * colomon is sure he has done many worse things in his own p6 code....

[19:52] <mikemol> The go-to task for demonstrating too many ways to do something: http://rosettacode.org/wiki/FizzBuzz#Perl_6

[19:52] <TimToady> heh

[19:52] <mikemol> Well, the P6 example not so much. Others, somewhat.

[19:52] <mikemol> Also, that page is hell on my server. I need to get caching implemented around the syntax highlighter.

[20:03] <jnthn> evening, #perl6

[20:03] <colomon> o/

[20:07] <[Coke]> blah!

[20:07] *** ksi joined
[20:09] <moritz> just a quick reminder, the day after tomorrow is the deadline for the prisoner's dilemma mini challenge

[20:09] <[Coke]> blah blah!

[20:13] <moritz> blah blah blah?

[20:15] <jnthn> Blah! Blaaah blah blah!

[20:15] <jnthn> .oO( conversation here is pretty straightforward here some days... 0

[20:15] <jnthn> ...er. :)

[20:16] * jnthn gets a build of Rakudo and NQP and ponders a little hacking

[20:28] *** skids left
[20:30] *** GlitchMr left
[20:33] *** localhost left
[20:34] *** localhost joined
[20:35] *** tarch_ joined
[20:36] *** tarch left
[20:46] *** tarch_ is now known as tarch

[20:50] *** birdwindupbird left
[20:58] *** cooper left
[20:58] *** cooper joined
[21:06] <dalek> nqp/bs: b0cca57 | jonathan++ | src/guts/multi_dispatch.c:

[21:06] <dalek> nqp/bs: Get multi-dispatcher able to work with the new NQPRoutine (but leave the original DispatcherSub PMC hanlding in for now too).

[21:06] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/b0cca57fb8

[21:08] *** Chillance left
[21:12] *** Trashlord joined
[21:24] *** awoodland joined
[21:25] *** rindolf left
[21:35] *** freeu4 joined
[21:36] *** ksi left
[21:36] <freeu4> i install rakudo-start , but after tun ./perl6 give error PARROT VM: Could not load bytecode  Could not load oplib `nqp_ops'

[21:36] <freeu4>  

[21:38] <masak> freeu4: did you do 'make install'?

[21:38] <freeu4> masak: yes,

[21:38] <masak> then the binary in ./install/bin/perl6 should work.

[21:39] <freeu4> i run ./install/bin/perk6

[21:39] <freeu4> and ./install/bin/nqp 

[21:39] <freeu4> but give error

[21:39] <jnthn> freeu4: What platform?

[21:39] <freeu4> linux ,kubuntu ,

[21:39] <jnthn> Hm. Nothing unusual then.

[21:40] <freeu4> jnthn: linux,kubuntu

[21:43] <freeu4> after first run perl6 , give error about libparrot.so.3.11.0 ,i add ./install/lib to my lib system

[21:45] *** skids joined
[21:48] *** freeu4 left
[21:51] *** thou left
[21:57] *** kaare_ left
[22:00] *** noam left
[22:04] *** noam joined
[22:07] <masak> you shouldn't need to add anything, I think.

[22:07] *** havenn joined
[22:10] <[Coke]> do you have an older version installed somehwere?

[22:10] <[Coke]> (nevermind, 3.11 parrot is the latest one we use.)

[22:10] <[Coke]> Did you remove the build directory?

[22:11] <[Coke]> I remember an old parrot bug where installed parrot depended on parrot source dir.

[22:11] <flussence> rakudo keeps working after a `make clean`, last time I tried it

[22:21] *** icwiener joined
[22:22] *** thou joined
[22:31] *** ab5tract left
[22:32] *** snearch left
[22:32] *** snearch joined
[22:46] *** kmwallio left
[22:48] *** Teratogen joined
[22:56] *** benabik left
[23:09] *** snearch left
[23:19] <masak> 'night, #perl6

[23:20] *** MayDaniel left
[23:40] *** PacoAir left
[23:41] *** havenn left
[23:42] *** tarch left
