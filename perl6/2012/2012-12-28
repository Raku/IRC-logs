[00:00] <alec> yeah, i read from your blog ages ago, you got laid off at your university it job or something after being sick, geekosaur?

[00:01] <geekosaur> I'm employed again now but thr US banking system turns out not to think much of folks who built up debt while unemployed... I have 3 paychecks I can't get any money out of :/

[00:02] <alec> ahhh, that's a shame

[00:03] <alec> collections?

[00:03] <doy> Ayiko: yeah, that's also a bit weird

[00:07] <doy> S05 doesn't seem to talk about substitutions barely at all

[00:08] <Ayiko> r: my $foo = 'foo'; say $foo ~~ s/f//, (so $/); 'a'~~/b/;  say $foo ~~ s/b//, (so $/); #ugly hack

[00:08] <p6eval> rakudo c8de2e: OUTPUT¬´TrueTrue‚ê§TrueFalse‚ê§¬ª

[00:09] <doy> r: my $foo = "foo"; $foo ~~ s/f//; say so $/; $foo ~~ s/a//; say so $/ # how is this different?

[00:09] <p6eval> rakudo c8de2e: OUTPUT¬´True‚ê§True‚ê§¬ª

[00:12] <doy> oh, missed the 'a'~~/b/ part in there

[00:17] <Ayiko> I warned you it was ugly (and a bit hidden)

[00:22] *** thou joined
[00:34] *** bluescreen10 left
[00:39] <Ulti> http://blogs.msdn.com/b/kirillosenkov/archive/2009/09/08/first-videos-of-the-structured-editor-prototype.aspx   having a structured editor for perl6 would be cool :)

[00:43] *** sid_ joined
[00:43] <sid_> hi

[00:43] <sid_> hello?

[00:43] <Ulti> hi

[00:44] <sid_> my name is sid, i like everything computers, i was wondering how i could help out w/ perl 6

[00:45] <sid_> i can do some basic c#, python, basic java... but i'll happily learn anything that I need to learn

[00:45] <Ulti> heh I'm not the right person to ask, but just trying it out and writing some programs with one of the main implementations is a good way to start

[00:45] <sid_> iight thanks

[00:46] <sid_> rakudo: 

[00:46] <sid_> my b

[00:47] <Ulti> if you know c# then you might want to check out https://github.com/sorear/niecza targetting the .net runtime

[00:49] *** raiph joined
[00:50] *** denisboyun_ left
[00:51] *** pmurias left
[00:52] <sid_> i went to this link

[00:52] <sid_> https://github.com/sorear/niecza 

[00:52] <sid_> but i wasn't too sure what exactly do to do aftewards

[00:52] *** aindilis left
[00:52] <sid_> is theres something i should install first to use in visual studio?

[00:53] *** aindilis joined
[00:58] *** anuby joined
[01:10] *** Chillance left
[01:11] *** Chillance joined
[01:15] *** hypolin joined
[01:15] *** sid_ left
[01:17] *** gcole joined
[01:18] *** raiph left
[01:22] *** atrodo left
[01:23] *** thou left
[01:32] *** Kharec left
[01:51] *** aindilis left
[01:51] *** aindilis joined
[01:58] *** whiteknight left
[02:44] *** FROGGS_ joined
[02:48] *** FROGGS left
[03:01] <[Coke]> pretty sure there's no build files for VS for niecza.

[03:02] <[Coke]> just a makefile.

[03:06] *** orafu left
[03:06] *** orafu joined
[03:21] *** REPLeffect left
[03:54] <xenoterracide> hi alec

[03:54] *** xenoterracide left
[03:54] *** xenoterracide joined
[04:00] *** colomon left
[04:22] *** thou joined
[04:43] *** Chillance left
[04:48] *** fgomez joined
[04:48] *** crazedpsyc joined
[04:55] *** fgomez left
[05:00] *** kaleem joined
[05:07] *** aindilis left
[05:12] *** telex left
[05:17] *** sivoais is now known as msivoaisw

[05:19] *** msivoaisw is now known as sivoais

[05:20] *** telex joined
[05:26] *** thou left
[05:27] *** thou joined
[05:33] *** telex left
[05:35] *** telex joined
[06:08] *** fgomez joined
[06:14] *** fgomez left
[06:20] *** araujo left
[06:28] *** drbean_ joined
[06:31] *** drbean_ is now known as drbean

[06:37] *** SamuraiJack joined
[06:45] *** quester joined
[07:13] *** xinming_ joined
[07:15] *** xinming left
[07:36] *** arkydo joined
[07:42] *** thou left
[07:45] *** Kharec joined
[07:48] *** kaare_ joined
[08:05] <Woodi> Ulti: realy nice improvement in code visualization just by changing font-bg-color :) and drag&drop such 'ractangles' is nice extract-foohere refactoring...  but still 2D only :)

[08:06] <Woodi> morning :)

[08:12] <Woodi> anyway, what happen to GUIs in last years ?? eg:  import QtQuick 1.0\n Rectangle {\n width: 100\n ...  looks like every GUI now a) should be done in SDL-like-shape; b) need to be implemented from scratch

[08:12] <moritz> \o

[08:13] <quester> Does anyone know if "make -j2" is a good idea for a Rakudo Star build?

[08:13] <Woodi> not necessarily bad for new languages on the block :)

[08:14] <moritz> quester: it's not

[08:14] <moritz> erm wait

[08:15] <moritz> for 'make' it's OK, but not for 'make install'

[08:15] <flussence> I've been using -j4

[08:15] *** quester left
[08:16] <flussence> (I should probably stop using it for the install part...)

[08:16] *** quester joined
[08:16] <moritz> it's fine in rakudo, just not in star

[08:18] <quester> Oh.  Okay.  Thank you very much, moritz++ and flussence++

[08:18] <moritz> star: say 'oh hai'

[08:18] <p6eval> star 2012.12: OUTPUT¬´oh hai‚ê§¬ª

[08:19] <moritz> p6eval update to star 2012.12

[08:38] *** drbean left
[08:43] *** drbean joined
[08:44] *** GlitchMr joined
[08:48] *** arkydo left
[09:14] *** quester left
[09:16] *** MayDaniel joined
[09:18] <Woodi> moritz: Star v2012.12 announcement typo: Rakudo 2012.12 not 2012.11, (link links correctly to v12)

[09:21] *** Nola joined
[09:21] <Nola> good morning

[09:42] <FROGGS_> morning

[09:42] *** FROGGS_ is now known as FROGGS

[09:44] *** Patterner left
[09:46] *** Psyche^ joined
[09:46] *** Psyche^ is now known as Patterner

[09:50] *** TreyRust joined
[09:52] *** SmokeMachine joined
[09:54] *** SmokeMachine left
[09:54] <Nola> Is there a way to pass multiple arrays to a subroutine without having them flatened or using references to arrays?

[09:54] <Nola> I tried using the "slurp" mechanic (sub foo(*@arrays) {...}) but it seems to flatten them.

[09:55] *** SmokeMachine joined
[09:57] <sorear> sub foo(@x, @y, @z) { ... }

[09:57] <sorear> if you want a variable number, use arrays of arrays

[09:58] <sorear> also, we don't really say "references" here

[09:58] <sorear> in perl 6, everything is a reference so nothing is

[09:59] <Nola> Okay

[09:59] <Nola> [D[A[C[A[D[B[B[C[A[D

[09:59] <Nola> encoding fail on my part.

[10:01] *** hypolin left
[10:02] <doy> is there a reason that class stubs are written as "class Foo {...}" but method stubs are written as "method foo {*}"?

[10:04] <sorear> doy: true method stubs use {...}.  {*} is used for multimethods

[10:06] <doy> hmmm

[10:06] <doy> seems like "method foo {*}" could stand to have a warning or something

[10:16] <Nola> sorear: http://pastebin.com/iE3BkaXP - Do you mean like this? Or can you think of a better way?

[10:19] *** anuby left
[10:32] <doy> is there a decent perl6 vim syntax file somewhere?

[10:33] <hoelzro> doy: https://github.com/vim-perl/vim-perl is where it's being developed

[10:33] <hoelzro> it's a WIP

[10:34] <doy> yeah, that's what i'm using now

[10:34] <doy> it's a bit buggy

[10:34] <hoelzro> it works pretty well for now, but I intend to improve it when I get the tuits

[10:34] <hoelzro> doy: if you find bugs that aren't already in the tracker, feel free to add them =)

[10:34] <hoelzro> I'll get around to them when I can

[10:36] <doy> also, syntax files that auto-enable folding are pretty hateful

[10:37] <hoelzro> doy: does the perl6.vim in vim-perl do that?

[10:38] <hoelzro> afaik, only my branch does ATM, and I have it on by default for ease of debugging

[10:38] <hoelzro> I intend to have it off by default before I merge that into master

[10:39] <doy> https://github.com/vim-perl/vim-perl/blob/master/syntax/perl6.vim#L2246

[10:39] <hoelzro> thanks for pointing that out!

[10:43] *** TreyRust left
[10:46] <doy> part of the bugginess is really just vim's syntax engine being awful i think

[10:47] <doy> "syntax sync fromstart" doesn't seem to really mean "fromstart"

[10:47] <hoelzro> ah

[10:47] <doy> if i have a comment with a single quote in it, things are highlighted properly when the comment is visible on the screen, but they act like there's an open single quote if the comment has scrolled off the top

[10:48] <moritz> Woodi: fixed

[10:48] <hoelzro> how odd

[10:50] <hoelzro> doy: would you mind directing me to the file that's causing this issue?

[10:51] <doy> any file, just have a line with ¬´# '¬ª in it, followed by some perl 6 code

[10:51] <hoelzro> sure enough

[10:52] <hoelzro> thanks for pointing that out; I'll add it to the bug tracker

[10:53] <masak> greetings, #perl6

[10:53] <hoelzro> ahoy masak 

[11:09] *** araujo joined
[11:09] *** araujo left
[11:09] *** araujo joined
[11:25] *** klaus___ joined
[11:25] *** klaus___ is now known as muixirt

[11:25] <muixirt> good morning

[11:28] <doy> r: role Foo { has $.bar; submethod BUILD (:$!bar) { } }; class Baz does Foo { }; say Foo.new(bar => "BAR")

[11:28] <p6eval> rakudo c8de2e: OUTPUT¬´Can not get attribute '$!bar' declared in class 'Foo' with this object‚ê§  in submethod BUILD at /tmp/9hxFlqanBm:1‚ê§  in method BUILDALL at src/gen/CORE.setting:738‚ê§  in method bless at src/gen/CORE.setting:723‚ê§  in method new at src/gen/CORE.setting:708‚ê§  in  at src/‚Ä¶

[11:28] <doy> r: role Foo { has $.bar; submethod BUILD (:$bar) { $!bar = $bar } }; class Baz does Foo { }; say Foo.new(bar => "BAR")

[11:28] <p6eval> rakudo c8de2e: OUTPUT¬´Foo.new(bar => "BAR")‚ê§¬ª

[11:28] <doy> shouldn't these be equivalent?

[11:28] <doy> or am i misunderstanding something

[11:29] <muixirt> the command 'panda --installed list' prints nothing (Rakudo Star 2012.12). Why?

[11:30] <hoelzro> muixirt: did it print something with Rakudo Star 2012.11?

[11:30] <hoelzro> there was a recent change in the default value for @*INC, iirc

[11:30] <hoelzro> I think that was from 10 -> 11, though

[11:32] *** GlitchMr left
[11:32] *** Nola left
[11:32] <doy> actually, that's not even useful, since defining BUILD in a role will just break things anyway if the class defines any attributes

[11:33] <muixirt> hoelzro: no, 2012.11 doesn't print something either

[11:33] <hoelzro> muixirt: and 2012.10?

[11:33] <doy> BUILD in general seems quite hard to actually use effectively

[11:33] *** am0c joined
[11:34] <muixirt> hoelzro: i don't know

[11:34] <hoelzro> muixirt: I'm not 100% sure, but I'm pretty sure that the default lib dir and installation stuff was changed in 2012.11

[11:37] <muixirt> hoelzro: i have to admit that i don't know what it is supposed to print, maybe only modules that are installed via panda

[11:38] <hoelzro> that's what I think

[11:40] <FROGGS> muixirt: right, the panda that is shipped with rakudo star doesnt know what already is installed

[11:40] <FROGGS> its database file is empty

[11:40] <FROGGS> dont know if that is intended or not

[11:41] <muixirt> hoelzro, FROGGS ok, thanks

[11:43] <masak> doy: I feel your pain. there are certainly kinks to iron out.

[11:44] <masak> especially in the area you're currently investigating, object initialization and roles.

[11:44] <masak> I'm not sure the extent to which it has been designed.

[11:44] <doy> this may just be my moose background coloring my opinions, but the way that BUILD is used for both attribute initialization and other things to do at construction time seems odd

[11:45] <doy> (moose separates this out with BUILDARGS vs BUILD)

[11:46] * masak .oO( background-coloring my opinions )

[11:47] <masak> doy: yeah, tadzik and TimToady has had that discussion at least twice. see the backlog.

[11:47] <masak> doy: ISTR TimToady saying something to the effect of "I can't help it if Moose uses BUILD for that thing, we're still not doing that".

[11:48] <masak> and he invokes efficiency as one of his design criteria.

[11:48] <masak> but the backlog will have more.

[11:49] <doy> yeah, i don't particularly care if the moose design is what is used, but as it currently stands, there are some things that you just are unable to do at all as far as i can tell

[11:50] <masak> at some point, some of us should probably sit down and enumerate the problems with the current factoring.

[11:53] *** colomon joined
[11:56] *** bbkr left
[12:07] *** arkydo joined
[12:09] <colomon> resolve stage failed for File::Find::Duplicates: File::Find::Duplicates depends on File::Find, which was not found in the ecosystem

[12:09] <colomon> :(

[12:10] <moritz> I guess that star simply installs stuff without registering it with panda

[12:16] *** MayDaniel left
[12:17] <doy> r: role Foo { method bar {...} }; say Foo.perl

[12:17] <p6eval> rakudo c8de2e: OUTPUT¬´Method 'bar' must be implemented by Foo because it is required by a role‚ê§  in  at src/gen/Metamodel.pm:2127‚ê§  in compose_method_table at src/gen/Metamodel.pm:2118‚ê§  in any apply at src/gen/Metamodel.pm:2136‚ê§  in  at src/gen/Metamodel.pm:2271‚ê§  in any compose at src‚Ä¶

[12:17] <doy> ^^ bug?

[12:20] <doy> r: role Foo { method bar {...} }

[12:20] <p6eval> rakudo c8de2e: OUTPUT¬´Method 'bar' must be implemented by Foo because it is required by a role‚ê§current instr.: '' pc 23697 (src/gen/perl6-metamodel.pir:10767) (src/gen/Metamodel.pm:2127)‚ê§called from Sub 'compose_method_table' pc 23492 (src/gen/perl6-metamodel.pir:10696) (src/gen/Metamod‚Ä¶

[12:20] <doy> hmmm

[12:24] <masak> that doesn't feel like it should error out.

[12:24] <masak> r: role Foo { method bar {...} }; say 42

[12:24] <p6eval> rakudo c8de2e: OUTPUT¬´42‚ê§¬ª

[12:24] <masak> oh, it has something to do with role Foo being used as a return value or something.

[12:24] <doy> yeah

[12:25] <masak> and evaluating it causes it to auto-pun itself into an anonymous class, maybe?

[12:25] <masak> if so, then that's the part that feels wrong.

[12:25] <masak> it must be possible to talk about a role with unimplemented methods without it throwing an error.

[12:25] * masak submits rakudobug

[12:25] <doy> i'm not sure why that second one gives a parrot stack trace either

[12:26] <masak> probably because the mainline block returns to the Rakudo internals.

[12:27] <masak> that's just a guess, but it feels like a safe one.

[12:27] <masak> n: role Foo { method bar {...} }; say Foo.perl

[12:27] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Unhandled exception: Method 'bar' must be implemented by 'Foo' because it is required by role 'Foo[curried][...]'‚ê§  at /tmp/eJUSqd8EGZ line 1 (mainline @ 4) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.‚Ä¶

[12:27] <masak> n: role Foo { method bar {...} }

[12:27] <p6eval> niecza v24-12-g8e50362:  ( no output )

[12:28] <masak> Niecza half agrees.

[12:28] <masak> unless the spec absolutely *mandates* that a role should auto-pun to a class when .perl'd, I think it's a bad idea.

[12:29] *** werwerwer_ left
[12:30] <doy> all of the stringification methods have the same issue, which is why i ran into this

[12:31] <timotimo> hello all you happy perl6 people

[12:32] <masak> timotimo! \o/

[12:34] <FROGGS> hi kresi... err, timotimo

[12:35] <masak> FROGGS: my thought exactly ;)

[12:36] <doy> r: class Foo { }; say Foo.HOW.^methods

[12:36] <p6eval> rakudo c8de2e: OUTPUT¬´No such method 'gist' for invocant of type 'NQPRoutine'‚ê§  in method gist at src/gen/CORE.setting:5047‚ê§  in sub say at src/gen/CORE.setting:7514‚ê§  in block  at /tmp/8DPMpjnynI:1‚ê§‚ê§¬ª

[12:37] <doy> how do i see what metamethods are available

[12:38] *** sorear left
[12:39] *** sorear joined
[12:39] <doy> also: its not just stringification methods, it seems that calling any method at all on a role with required methods is broken

[12:39] <doy> r: role Foo { method bar {...} }; say Foo.^name

[12:40] <p6eval> rakudo c8de2e: OUTPUT¬´Method 'bar' must be implemented by Foo because it is required by a role‚ê§  in  at src/gen/Metamodel.pm:2127‚ê§  in compose_method_table at src/gen/Metamodel.pm:2118‚ê§  in any apply at src/gen/Metamodel.pm:2136‚ê§  in  at src/gen/Metamodel.pm:2271‚ê§  in any compose at src‚Ä¶

[12:40] <masak> :/

[12:40] <masak> r: role Foo { method bar {} }; say Foo.^name

[12:40] <p6eval> rakudo c8de2e: OUTPUT¬´Foo‚ê§¬ª

[12:40] * masak adds that to the ticket

[12:41] <masak> sometimes it feels like a consolation that even when I can't fix people's problems, I can file them away in RT for later fixing.

[12:50] *** MayDaniel joined
[12:56] <doy> masak: on another note, do you have any ideas about how to tell if a substitution succeeded or not?

[12:56] *** hash_table joined
[12:57] <masak> rn: say "foo".subst(/f/, 'ph')

[12:57] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT¬´phoo‚ê§¬ª

[12:57] <masak> rn: say "foo" ~~ s[f] = "ph"

[12:58] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Unhandled exception: Writing to readonly scalar‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 593 (Cool.subst @ 88) ‚ê§  at /tmp/Sx1s9KDdiu line 1 (mainline @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 4218 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/C‚Ä¶

[12:58] <p6eval> ..rakudo c8de2e: OUTPUT¬´Cannot assign to a non-container‚ê§  in sub infix:<=> at src/gen/CORE.setting:12183‚ê§  in block  at /tmp/m1xiog3HyD:1‚ê§‚ê§¬ª

[12:58] <masak> oh, right.

[12:58] <masak> rn: $_ = "foo"; say s[f] = "ph"

[12:58] <p6eval> rakudo c8de2e: OUTPUT¬´phoo‚ê§¬ª

[12:58] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´True‚ê§¬ª

[12:58] <masak> doy: in niecza, you'll get True back.

[12:58] <masak> rn: $_ = "foo"; say s[q] = "ph"

[12:58] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´False‚ê§¬ª

[12:58] <p6eval> ..rakudo c8de2e: OUTPUT¬´foo‚ê§¬ª

[12:58] <masak> if it succeeded.

[12:58] <moritz> I could try to teach Rakudo the same behavior

[12:59] <doy> r: my $foo = "foo"; say $foo ~~ s/a//; say $foo; say $foo ~~ s/f//; say $foo

[12:59] <p6eval> rakudo c8de2e: OUTPUT¬´True‚ê§foo‚ê§True‚ê§oo‚ê§¬ª

[13:00] <doy> rakudo seems to return a boolean in some cases too, it's just always True

[13:01] <moritz> no, it's the ~~ that returns a Boolean

[13:01] <moritz> not the s///

[13:01] *** kaleem_ joined
[13:01] <doy> so s/// on its own returns something different from $_ ~~ s///?

[13:02] <moritz> yes

[13:02] <doy> weird

[13:02] <doy> why?

[13:03] *** kaleem left
[13:03] <moritz> because $a ~~ $b is short for something like  do { my $_ = $a; $b.ACCEPTS($_) }

[13:05] <doy> well, i guess i mean: why is it useful for them to return different things?

[13:05] <moritz> it's not, in this particular case

[13:05] <doy> okay

[13:05] <moritz> but in the big picture, the current factoring has some benefits

[13:06] <moritz> though I'm not totally happy with it

[13:08] <doy> seems like both s/// and $foo ~~ s/// should return something that boolifies to "did the substitution succeed"

[13:09] *** hash_table left
[13:13] *** rindolf joined
[13:17] <moritz> when I fix s/// to return True or False, that'll happen

[13:17] <moritz> though it won't fix the $str ~~ m:g// case

[13:21] <masak> trying to please too many use cases at the same time.

[13:29] <doy> r: my $foo = try { die "foo"; CATCH { warn $_; default {} } }; say "alive"; say $foo // "bar"

[13:29] <p6eval> rakudo c8de2e: OUTPUT¬´foo  in block  at /tmp/uVw2MG1iy0:1‚ê§‚ê§alive‚ê§foo‚ê§  in block  at /tmp/uVw2MG1iy0:1‚ê§‚ê§¬ª

[13:29] <doy> why is the block returning the exception there?

[13:31] <moritz> r: my $foo = try die 'foo'; say $foo

[13:31] <p6eval> rakudo c8de2e: OUTPUT¬´Nil‚ê§¬ª

[13:31] <moritz> no idea

[13:31] <moritz> but it shouldn't, afaict

[13:36] * doy rakudobugs

[13:36] *** Chillance joined
[13:39] <moritz> r: $_ = 'abc'; s/a/A/; s/X/Y/; say $/

[13:39] <p6eval> rakudo c8de2e: OUTPUT¬´ÔΩ¢aÔΩ£‚ê§‚ê§¬ª

[13:39] <moritz> another rakudobug

[13:39] <moritz> n: $_ = 'abc'; s/a/A/; s/X/Y/; say $/

[13:39] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´#<match from(0) to(1) text(a) pos([].list) named({}.hash)>‚ê§¬ª

[13:39] <moritz> hm, niecza doesn't reset $/ on failure either

[13:40] <moritz> rn: $_ = 'abc'; m/a/; m/X/; say $/

[13:40] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´Match()‚ê§¬ª

[13:40] <p6eval> ..rakudo c8de2e: OUTPUT¬´#<failed match>‚ê§¬ª

[13:42] * masak submits rakudobug

[13:47] *** am0c left
[13:49] *** PacoAir joined
[13:52] <masak> oh! oh! last day to sign up for http://strangelyconsistent.org/blog/the-2012-perl-6-coding-contest !

[13:52] <masak> (after which I will stop nagging y'all about it)

[13:52] <masak> we *almost* have the same number of signups as last year.

[13:52] <masak> seems we've hit some kind of saturation level for signups :)

[13:52] * hoelzro looks

[13:54] <doy> r: role Foo { method bar { "ROLE:" ~ (self.defined ?? "D" !! "U") } }; class Bar does Foo { method bar { "CLASS:" ~ (self.defined ?? "D" !! "U") ~ "-" ~ self.Foo::bar } }; say Bar.new.bar

[13:54] <p6eval> rakudo c8de2e: OUTPUT¬´CLASS:D-ROLE:U‚ê§¬ª

[13:54] <masak> nice prize lineup. significant quantities of Amazon bookage.

[13:55] <doy> ^^ bug?

[13:55] <doy> or is there another way i'm supposed to be doing that call

[13:56] <masak> doy: in-ter-es-ting.

[13:56] <masak> doy++

[13:56] * masak submits rakudobug

[13:58] <masak> r: role Foo { method bar { say self.WHICH } }; class Bar does Foo { method bar { say self.WHICH; self.Foo::bar } }; Bar.new.bar

[13:58] <p6eval> rakudo c8de2e: OUTPUT¬´Bar|549956910‚ê§Foo‚ê§¬ª

[13:58] <masak> I'd argue 'self' should still be the original invocant, even in the role method.

[13:58] <doy> agreed

[13:59] <masak> r: role Foo { method baz { say self.WHICH } }; class Bar does Foo { method bar { say self.WHICH; self.baz } }; Bar.new.bar

[13:59] <p6eval> rakudo c8de2e: OUTPUT¬´Bar|1974449900‚ê§Bar|1974449900‚ê§¬ª

[13:59] <masak> ...and it's particular to the self.Role::meth syntax. bingo.

[13:59] <hoelzro> masak: is that related to the role punning thing I found a few months ago?

[14:00] <masak> hoelzro: url?

[14:00] <hoelzro> S12-methods/qualified.t

[14:00] * hoelzro wonders if he actually submitted a rakudobug for that...

[14:02] <masak> &

[14:02] <hoelzro> is there a way to sort these tickets by date?

[14:06] <doy> r: role Foo { method bar { return self.defined ?? "D" !! "U" } }; class Bar does Foo { method baz { my $bar = Foo.^find_method('bar'); return self.$bar } }; say Bar.new.baz

[14:06] <p6eval> rakudo c8de2e: OUTPUT¬´Nominal type check failed for parameter ''; expected Foo but got Bar instead‚ê§  in method bar at /tmp/52qL89bcEj:1‚ê§  in method baz at /tmp/52qL89bcEj:1‚ê§  in block  at /tmp/52qL89bcEj:1‚ê§‚ê§¬ª

[14:07] <moritz> you can click on date column of the head row to sort by date

[14:08] <hoelzro> that doesn't seem to work for me...

[14:08] <moritz> you might need to be logged in

[14:08] <doy> i'm not entirely sure what that error message is trying to say, but i don't think it should be erroring at all

[14:09] *** Nola joined
[14:09] <hoelzro> doy: what's happening is a fake object with the role is being created and being used as the invocant

[14:09] * moritz fails to fix s///

[14:09] <hoelzro> it's called role punning, I guess

[14:10] <doy> a fake class, you mean?

[14:10] <Nola> Hello!

[14:10] <hoelzro> doy: basically

[14:10] <moritz> it loops before entering Str.subst (which IMHO is really weird)

[14:10] <moritz> hello Nola 

[14:10] <Nola> I tried to read a file (using open() and get()) and I get an exception of malformed UTF-8.

[14:10] <hoelzro> well, it's an empty object with just the role in question applied

[14:10] <Nola> I know that the file is not utf-8, but how can I set the encoding?

[14:11] <doy> hoelzro: so is this basically the same issue as the previous one then

[14:11] <hoelzro> doy: I think so, yes

[14:11] <doy> okay

[14:11] <moritz> Nola: open($filename, :encoding('ISO-8859-1')) or so

[14:11] <hoelzro> I'm sad to see it's still not fixed =/

[14:11] <hoelzro> I reported it in July, I think

[14:11] <Nola> moritz: Thanks I am going to try it.

[14:12] *** PacoAir left
[14:12] <hoelzro> apparently, you *do* need to be logged in to sort?

[14:12] <hoelzro> how silly

[14:13] <moritz> hoelzro: we have 4 year old bug reports open

[14:13] <hoelzro> also, I think I *did* forget to file a rakudobug for this

[14:13] *** Nola left
[14:13] <doy> well, luckily, masak++ just did

[14:13] <hoelzro> moritz: it's more something I wished worked than a criticism of the Rakudo team

[14:13] <doy> (:

[14:13] <hoelzro> indeed, masak++

[14:14] <doy> hmmm

[14:14] <doy> so i wonder what i can do to work around this problem

[14:14] *** jlhg joined
[14:14] *** jlhg left
[14:14] <moritz> self.Foo::methodname doesn't work?

[14:14] <hoelzro> doy: let me know if you figure it out; it halted my chatbot's development =(

[14:15] <doy> moritz: no, it passes the Foo type object as the invocant

[14:18] <moritz> r: s/a/b/i

[14:18] <p6eval> rakudo c8de2e: OUTPUT¬´No such method 'subst' for invocant of type 'Any'‚ê§  in block  at /tmp/eI7cwaCdpa:1‚ê§‚ê§¬ª

[14:18] <moritz> std: s/a/b/i

[14:18] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of suffix regex modifiers; in Perl 6 please use prefix adverbs at /tmp/TOH6ArPfuc line 1:‚ê§------> [32ms/a/b/i[33m‚èè[31m<EOL>[0m‚ê§Other potential difficulties:‚ê§  Unsupported use of /i; in Perl 6 please use :i at /tmp/TO‚Ä¶

[14:18] <moritz> r: m/a/i

[14:18] <p6eval> rakudo c8de2e: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of /i; in Perl 6 please use :i‚ê§at /tmp/e_o3DaFFvF:1‚ê§------> [32mm/a/i[33m‚èè[31m<EOL>[0m‚ê§¬ª

[14:18] *** eiro left
[14:19] <arnsholt> I wonder when the Perl 5 compiler will start to catch sixisms... =)

[14:19] <arnsholt> </idle-pondering>

[14:20] <moritz> it already does

[14:20] <moritz> erm, at least 'use v6;' :-)

[14:20] <arnsholt> Oh, that's fun. Didn't know that

[14:21] <moritz> though it's the same general mechanism used for 'use 5.010;' and stuff

[14:22] <arnsholt> Yeah, that makes sense

[14:23] *** eiro joined
[14:24] <moritz> japhb: the rakudo docs/ROADMAP has an item 'Failure changes (japhb)'. What does that mean?

[14:24] *** grondilu left
[14:25] *** GlitchMr joined
[14:25] *** att__ left
[14:27] <dalek> rakudo/nom: a11bad6 | moritz++ | src/Perl6/Grammar.pm:

[14:27] <dalek> rakudo/nom: catch p5 regex adverbs after s///

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a11bad6b51

[14:27] <dalek> rakudo/nom: 69bbd1a | moritz++ | docs/ROADMAP:

[14:27] <dalek> rakudo/nom: [ROADMAP] add two missing language features

[14:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69bbd1aeab

[14:28] *** att__ joined
[14:29] *** PacoAir joined
[14:35] *** jlhg_ joined
[14:35] *** jlhg_ left
[14:37] *** jlhg joined
[14:37] *** jlhg left
[14:37] *** jlhg joined
[14:38] *** jlhg left
[14:41] <doy> is there any built-in way to do lazy attributes (where the values aren't assigned until the first time the accessor is called)?

[14:41] <doy> the default values, that is

[14:45] *** brrt joined
[14:45] <brrt> hi folks, merry christmas and all that; why are for loops lazy?

[14:46] <hoelzro> I'd guess too much pie and beer.

[14:47] *** stopbit joined
[14:48] *** yves_ joined
[14:52] <doy> that is a question that has come up several times lately

[14:53] <arnsholt> Because they're lazy, I think

[14:54] <arnsholt> There was a bug I saw in the scrollback that made me think there might be some interaction with sink context as well

[15:09] <hoelzro> on line 227 of S05-regex.pod in the spec, it talks about :sigspace; shouldn't this be talking about :samecase instead?

[15:09] <hoelzro> (same goes for L232)

[15:10] *** atrodo joined
[15:15] <Ulti> Woodi you want a 3D text editor?

[15:17] *** dayangkun left
[15:23] *** rindolf left
[15:23] *** rindolf joined
[15:30] *** kaleem_ left
[15:33] <hoelzro> is there a variable I can query in Rakudo to ask what the version is?

[15:33] <hoelzro> $?PERL.version *should* say something, right?

[15:34] <moritz> r: say $?PERL.perl

[15:34] <p6eval> rakudo 69bbd1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $?PERL is not declared‚ê§at /tmp/6yqSUhc1Dw:1‚ê§------> [32msay $?PERL.perl[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        method arguments‚ê§        postfix‚ê§¬ª

[15:34] <moritz> r: say $*VM

[15:34] <p6eval> rakudo 69bbd1: OUTPUT¬´("name" => "parrot", "config" => {"git_describe" => "RELEASE_4_10_0", "sha1" => "08a70fe50d07fc932b5505b13f09fa74b01622e9", "a" => ".a", "ar" => "ar", "ar_extra" => "", "ar_out" => "", "archname" => "i486-linux-gnu-thread-multi-64int", "arflags" => "cr", "as" => "a‚Ä¶

[15:34] <moritz> r: say $*VM.keys

[15:34] <p6eval> rakudo 69bbd1: OUTPUT¬´name config‚ê§¬ª

[15:37] <doy> r: multi sub foo (Pair $p) { say "pair" }; foo(a => 1)

[15:37] <p6eval> rakudo 69bbd1: OUTPUT¬´Cannot call 'foo'; none of these signatures match:‚ê§:(Pair $p)‚ê§‚ê§  in block  at /tmp/DUF4fTXMJz:1‚ê§‚ê§¬ª

[15:37] <doy> would it make sense for that to fall back to looking for a Pair signature

[15:37] <doy> if no candidates are available for named arguments?

[15:37] <doy> considering that this works

[15:37] <doy> r: multi sub foo (Pair $p) { say "pair" }; foo([] => 1)

[15:37] <p6eval> rakudo 69bbd1: OUTPUT¬´pair‚ê§¬ª

[15:43] *** isBEKaml joined
[15:47] <masak> rn: say "0b100000 signups!"

[15:47] <p6eval> rakudo 69bbd1, niecza v24-12-g8e50362: OUTPUT¬´0b100000 signups!‚ê§¬ª

[15:47] <masak> rn: say "{0b100000} signups!"

[15:47] <p6eval> rakudo 69bbd1, niecza v24-12-g8e50362: OUTPUT¬´32 signups!‚ê§¬ª

[15:48] <masak> \o/

[15:48] *** mtk left
[15:48] *** mtk joined
[15:50] <masak> doy: no, there's no way to make attributes lazy at present.

[15:50] <masak> I don't know the metaobject protocol well enough to say if it's possible to hack something up that does that.

[15:51] <doy> seems like it'd be a fairly easy addition

[15:51] <masak> r: say Attribute.can('get_value')

[15:51] <p6eval> rakudo 69bbd1: OUTPUT¬´get_value‚ê§¬ª

[15:52] <masak> seems to me if you override this one in the right way...

[15:52] <masak> r: say Attribute.can('set_value')

[15:52] <p6eval> rakudo 69bbd1: OUTPUT¬´set_value‚ê§¬ª

[15:52] <masak> and maybe this one...

[15:55] *** xinming_ left
[15:57] *** xinming joined
[15:58] <doy> hmmm

[15:58] <doy> can't seem to figure out how dynamic variables work

[15:59] <masak> r: sub foo { my $*dyn = "like this! :)"; bar }; sub bar { say $*dyn }; foo

[15:59] <p6eval> rakudo 69bbd1: OUTPUT¬´like this! :)‚ê§¬ª

[16:00] <arnsholt> doy: Instead of lexical position the scope is along the call stack (essentially)

[16:00] <arnsholt> If that's what you were curious about

[16:00] <doy> arnsholt: no, i meant how you actually use them(:

[16:00] <arnsholt> Oh, right =)

[16:00] <doy> masak: i guess what i'm doing is a bit more complicated

[16:01] <masak> ...but that's the only way to use them... ;)

[16:01] <arnsholt> Do you have an example of what you're doing?

[16:02] <masak> ...and why are you making it so complicated? :P

[16:02] <doy> that is what i do d:

[16:02] <doy> and working on getting a simple example

[16:04] *** hash_table joined
[16:05] <doy> r: sub foo (Array $thing, Callable $body) { my $*dyn; if $*dyn { $thing.push($*dyn) }; $*dyn = $thing; $body.(); $thing }; say foo([1, 2], { foo([3, 4], { foo([5, 6], sub {}) }) }).perl

[16:05] <p6eval> rakudo 69bbd1: OUTPUT¬´[1, 2]‚ê§¬ª

[16:06] <doy> basically, i'm looking for something like this, except that it gives me [1, 2, [3, 4, [5, 6]]]

[16:08] *** isBEKaml left
[16:09] <arnsholt> doy: my $*dyn inside foo establishes a new binding

[16:09] <doy> right

[16:09] <arnsholt> It's like "my $foo; { my $foo; ... }"

[16:09] <doy> i understand why that version doesn't work, but that doesn't get me to what exactly would work

[16:09] <doy> (:

[16:10] <arnsholt> I think just nuking the "my $*dyn" declaration in foo should do it

[16:10] <arnsholt> Just access $*dyn directly

[16:10] <masak> well, you need to declare it somewhere.

[16:10] <masak> probably in the top scope.

[16:10] <masak> r: say $*dyn

[16:11] <p6eval> rakudo 69bbd1: OUTPUT¬´Dynamic variable $*dyn not found‚ê§  in method gist at src/gen/CORE.setting:10337‚ê§  in sub say at src/gen/CORE.setting:7514‚ê§  in block  at /tmp/hKzrs08mzM:1‚ê§‚ê§¬ª

[16:11] <masak> not declaring it does not work.

[16:11] <arnsholt> If there exists a binding up the call stack it will use that binding, or it will error out if none exists

[16:11] <doy> r: my $*dyn; sub foo (Array $thing, Callable $body) { if $*dyn { $thing.push($*dyn) }; $*dyn = $thing; $body.(); $thing }; say foo([1, 2], { foo([3, 4], { foo([5, 6], sub {}) }) }).perl

[16:11] <p6eval> rakudo 69bbd1: OUTPUT¬´[1, 2]‚ê§¬ª

[16:11] <arnsholt> Yeah, right. And add a declaration before the call

[16:12] <arnsholt> Huh. Didn't expect that

[16:13] <skids> .oO(needs an else?)

[16:14] <skids> erm, nevermind, ENOCAFFEINE.

[16:15] <doy> oh, no, i'm just being dumb

[16:15] <doy> my $*dyn; sub foo (Array $thing, Callable $body) { if $*dyn { $*dyn.push($thing) }; $*dyn = $thing; $body.(); $thing }; say foo([1, 2], { foo([3, 4], { foo([5, 6], sub {}) }) }).perl

[16:15] <doy> the .push was backwards

[16:15] <doy> r: my $*dyn; sub foo (Array $thing, Callable $body) { if $*dyn { $*dyn.push($thing) }; $*dyn = $thing; $body.(); $thing }; say foo([1, 2], { foo([3, 4], { foo([5, 6], sub {}) }) }).perl

[16:15] <p6eval> rakudo 69bbd1: OUTPUT¬´[1, 2, [3, 4, [5, 6]]]‚ê§¬ª

[16:15] <arnsholt> Right, right =)

[16:15] <masak> r: sub foo(@thing, &body) { [@thing, &body()] }; say $body.(); $thing }; say foo([1, 2], { foo([3, 4], { foo([5, 6], sub {}) }) }).perl

[16:15] <p6eval> rakudo 69bbd1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $body is not declared‚ê§at /tmp/oMolWCn6KL:1‚ê§------> [32mody) { [@thing, &body()] }; say $body.()[33m‚èè[31m; $thing }; say foo([1, 2], { foo([3, 4][0m‚ê§    expecting any of:‚ê§        dotty method or postfix‚ê§        argument li‚Ä¶

[16:15] <masak> r: sub foo(@thing, &body) { [@thing, &body()] }; say foo([1, 2], { foo([3, 4], { foo([5, 6], sub {}) }) }).perl

[16:15] <p6eval> rakudo 69bbd1: OUTPUT¬´[1, 2, [3, 4, [5, 6]]]‚ê§¬ª

[16:16] <masak> my way is simpler. look ma, no dynamicals.

[16:16] <arnsholt> Neat!

[16:17] <doy> hmmm

[16:17] <doy> still getting "dynamic variable not found" in my real code when i do that though

[16:17] <doy> wonder what's different

[16:18] <masak> must be you're referring to a dynamic variable somewhere.

[16:20] <doy> by "that" i mean the thing i pasted, not the thing you pasted(:

[16:22] <masak> well, assuming you don't have a very old version of Rakudo where dynamicals are mis-implemented, what's happening to you is very simple.

[16:22] <masak> you're accessing a dynamical without being somewhere in the call stack where one had been declared.

[16:23] <masak> r: sub foo { my $*dyn }; sub bar { baz }; sub baz { flooz }; sub flooz { say $*dyn }; bar

[16:23] <p6eval> rakudo 69bbd1: OUTPUT¬´Dynamic variable $*dyn not found‚ê§  in method gist at src/gen/CORE.setting:10337‚ê§  in sub say at src/gen/CORE.setting:7514‚ê§  in sub flooz at /tmp/Bejec2IicP:1‚ê§  in sub baz at /tmp/Bejec2IicP:1‚ê§  in sub bar at /tmp/Bejec2IicP:1‚ê§  in block  at /tmp/Bejec2IicP:1‚ê§‚ê§¬ª‚Ä¶

[16:23] <masak> like that.

[16:33] <masak> r: sub foo { my $*dyn }; (sub bar { baz })(); sub baz { flooz }; sub flooz { say $*dyn }

[16:33] <p6eval> rakudo 69bbd1: OUTPUT¬´Dynamic variable $*dyn not found‚ê§  in method gist at src/gen/CORE.setting:10337‚ê§  in sub say at src/gen/CORE.setting:7514‚ê§  in sub flooz at /tmp/zAsvkqOlzo:1‚ê§  in sub baz at /tmp/zAsvkqOlzo:1‚ê§  in sub bar at /tmp/zAsvkqOlzo:1‚ê§  in block  at /tmp/zAsvkqOlzo:1‚ê§‚ê§¬ª‚Ä¶

[16:34] *** thou joined
[16:36] <doy> r: https://gist.github.com/3dc5fb0153bf69a83c6d

[16:36] <p6eval> rakudo 69bbd1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/ZdgIDRgHvx:1‚ê§------> [32mhttps[33m‚èè[31m://gist.github.com/3dc5fb0153bf69a83c6d[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        sta‚Ä¶

[16:37] <doy> r: http://gist.github.com/3dc5fb0153bf69a83c6d

[16:37] <p6eval> rakudo 69bbd1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/h3AkxZsYd1:1‚ê§------> [32mhttp[33m‚èè[31m://gist.github.com/3dc5fb0153bf69a83c6d[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        stat‚Ä¶

[16:37] <doy> i thought p6eval could do gists

[16:38] <masak> it can. something's off.

[16:38] <masak> but I see the problem in your gist.

[16:38] <masak> line 13.

[16:38] <masak> you're declaring $*dyn.

[16:39] <masak> that declaration is *not* in the dynamically surrounding scope of its usage. told you :)

[16:39] <doy> so... what do i do?

[16:39] <doy> (:

[16:39] <masak> I would recommend going back to the drawing-board and understanding dynamic variables. let me know if I can help.

[16:40] <doy> well

[16:40] <masak> from the way you're using them, I'm not sure they're actually what you want.

[16:40] <doy> right

[16:40] <doy> that was more my question

[16:40] <doy> i tried using dynamic variables because this worked via our and local in perl 5

[16:40] <masak> by line 22, $*dyn goes out of (dynamic) scope, and doesn't come back in.

[16:40] <doy> but if there's a better way of doing it, i'd be interested in that too

[16:41] <masak> as far as I know, you'd have the same problem in Perl 5.

[16:41] <doy> nope

[16:41] <masak> an 'our' variable might serve you in this case.

[16:41] <masak> but to be honest, I'm a bit wary of doing anything with modules. I prefer to bake process information such as this into objects.

[16:42] <masak> then I have more fine-grained control.

[16:42] <doy> aha

[16:42] <doy> yeah, just converting it to our/temp makes it work

[16:43] <masak> r: https://gist.github.com/4380959

[16:43] <hoelzro> anyone going to FOSDEM next year?

[16:43] <p6eval> rakudo 69bbd1: OUTPUT¬´Nominal type check failed for parameter '@dependencies'; expected Positional but got Array instead‚ê§  in method new at /tmp/NSeQDO9eIS:6‚ê§  in block  at /tmp/NSeQDO9eIS:27‚ê§‚ê§¬ª

[16:43] <masak> r: https://gist.github.com/3dc5fb0153bf69a83c6d

[16:43] <p6eval> rakudo 69bbd1: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row‚ê§at /tmp/xXlasF0asb:1‚ê§------> [32mhttps[33m‚èè[31m://gist.github.com/3dc5fb0153bf69a83c6d[0m‚ê§    expecting any of:‚ê§        argument list‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix stopper‚ê§        sta‚Ä¶

[16:43] <masak> seems p6eval doesn't recognize the new, extended gist URL format.

[16:44] *** brrt1 joined
[16:44] <doy> https://gist.github.com/46da99bcb774f2eb98fa # this works

[16:44] *** brrt left
[16:44] <doy> i'll come back to this stuff to see if there are better ways of doing things later

[16:45] <doy> just trying to see how much effort getting things working at all would be first

[16:46] <masak> *nod*

[16:46] *** arkydo_ joined
[16:47] <masak> doy: it's fascinating to see what things you run into. you obviously have a good grasp of Perl 5 and Moose.

[16:47] *** brrt1 left
[16:48] *** arkydo left
[16:52] <doy> i've been hanging out here long enough, figured i should at least give something a shot to see how well things work these days

[16:52] *** arkydo_ left
[16:54] <masak> :)

[16:54] <masak> you haven't considering doing p6cc this year? :)

[16:54] <masak> considered*

[16:55] <doy> figured i'd be more likely to stay motivated if it was something that might actually be useful

[16:55] *** denisboyun_ joined
[16:55] <masak> fair enough.

[17:01] <moritz> r: say <<foo :bar(2)>>.perl

[17:01] <p6eval> rakudo 69bbd1: OUTPUT¬´("foo", "bar" => 2)‚ê§¬ª

[17:03] * moritz closes a three year old masakbug

[17:03] <masak> \o/

[17:03] <moritz> rakudo: sub infix:<!+>(*@a) is assoc('list') { [*] @a }; say 7 !+ 6 !+ 10

[17:03] <p6eval> rakudo 69bbd1: OUTPUT¬´420‚ê§¬ª

[17:04] <moritz> rakudo: sub infix:<!+>(*@a) is assoc('list') { @a.perl }; say 7 !+ 6 !+ 10

[17:04] <p6eval> rakudo 69bbd1: OUTPUT¬´Array.new("Array.new(7, 6)", 10)‚ê§¬ª

[17:04] <masak> o.O

[17:04] <moritz> that doesn't look very list-assocy

[17:04] <moritz> rakudo: sub infix:<!+>(*@a) is assoc('right') { @a.perl }; say 7 !+ 6 !+ 10

[17:04] <p6eval> rakudo 69bbd1: OUTPUT¬´Array.new("Array.new(7, 6)", 10)‚ê§¬ª

[17:04] <masak> also, that there is a... string.

[17:04] <masak> eeew.

[17:05] <moritz> that's ok

[17:05] <arnsholt> Eeew, indeed

[17:05] <moritz> the return value from .perl

[17:05] <masak> oh. right.

[17:06] <masak> not as bad as I feared ;)

[17:06] <arnsholt> Oh, right

[17:07] <moritz> huh, I don't even see where the precedence or assoc information is used

[17:14] <moritz> ... is used

[17:14] <skids> rakudo,star: sub infix:<!+>(*@a) is assoc("list") { @a.perl }; say 7 !+ 6 !+ 10

[17:14] <skids> hrm what's star's p6eval hook?

[17:15] *** denisboyun_ left
[17:15] <moritz> star:

[17:15] <skids> because on star the output is different, and all I changed was 'list' -> "list"

[17:16] <moritz> star: sub infix:<!+>(*@a) is assoc("list") { @a.perl }; say 7 !+ 6 !+ 10

[17:16] <p6eval> star 2012.12: OUTPUT¬´Array.new(7, 6, 10)‚ê§¬ª

[17:16] <moritz> r: sub infix:<!+>(*@a) is assoc("list") { @a.perl }; say 7 !+ 6 !+ 10

[17:16] <p6eval> rakudo 69bbd1: OUTPUT¬´Array.new("Array.new(7, 6)", 10)‚ê§¬ª

[17:17] <moritz> so it's a regression since the release?

[17:17] <doy> r: multi foo (Str $name, *%params) { say "named params" }; multi foo (Str $name, Any $value) { say "value" }; foo('bar', (a => 1, b => 2))

[17:17] <p6eval> rakudo 69bbd1: OUTPUT¬´value‚ê§¬ª

[17:17] <doy> lack of list flattening does take some getting used to

[17:17] *** FROGGS left
[17:17] <moritz> lists flatten, but not everywhere

[17:17] <doy> yeah

[17:18] <doy> where do they flatten, exactly?

[17:18] <moritz> on list assignment

[17:18] <moritz> and on list methods that flatten

[17:19] *** muixirt left
[17:20] *** Abcxyz joined
[17:21] *** denisboyun_ joined
[17:23] <skids> r: sub infix:<!+>(*@a) is assoc("not_a_specced_assoc") { @a.perl }; say 7 !+ 6 !+ 10

[17:23] <p6eval> rakudo 69bbd1: OUTPUT¬´Array.new("Array.new(7, 6)", 10)‚ê§¬ª

[17:26] <dalek> rakudo/nom: 9303692 | moritz++ | src/core/traits.pm:

[17:26] <dalek> rakudo/nom: work around missing sink context from traits

[17:26] <dalek> rakudo/nom: 

[17:26] <dalek> rakudo/nom: fixes "is assoc"

[17:26] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/930369237a

[17:30] <japhb> moritz: I'm guessing the Failure changes ROADMAP item was making some operations that currently error return Failures instead, once we had sink context right.  (Note: I haven't backlogged yet, so if someone else commented on that, I haven't seen it yet.)

[17:32] <moritz> japhb: ok, makes sense

[17:33] <pmichaud> good morning, #perl6

[17:33] <moritz> good am, pm

[17:34] <skids> .oO(non-lazy paradigms frontload all your calculations so you do even the ones you would throw away.  Lazy paradigms rear-load them so they all the churn happens right when you would rather have a quick response time.  Quandry.)

[17:34] *** slavik1 joined
[17:41] <masak> pmichaud! \o/

[17:42] *** raiph joined
[17:43] <pmichaud> moritz++  # 2012.12 star release

[17:43] <pmichaud> I have the .msi on my calendar for tonight

[17:43] *** hash_table left
[17:46] <raiph> happy merry #*f adopted this as season's greet

[17:48] *** nyuszika7h left
[17:49] *** nyuszika7h joined
[17:52] *** nyuszika7h left
[17:59] *** FROGGS joined
[18:01] <moritz> std: no strict; $x

[18:01] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Variable $x is not predeclared at /tmp/VXARs3kDQt line 1:‚ê§------> [32mno strict; [33m‚èè[31m$x[0m‚ê§Check failed‚ê§FAILED 00:00 41m‚ê§¬ª

[18:05] <Abcxyz> What is the advantage (or even difference) of a scripting language over a compiled language providing the eval keyword / function?

[18:05] <moritz> Abcxyz: what exactly is a scripting language?

[18:06] <doy> hrm, now i have "warn $!foo.defined; $!foo //= "foo"; warn $!foo.defined", where both of the warns are printing False

[18:06] <doy> not entirely sure how to reproduce this on its own

[18:07] *** nyuszika7h joined
[18:07] <skids> doy: is $!foo rw?

[18:08] <doy> skids: does that matter?

[18:08] <doy> it's generated from "has $.foo", and i don't want the public foo accessor to be rw

[18:09] <moritz> the $!foo form is writable wherever it is visble

[18:09] <doy> yeah, that's what i thought

[18:11] <skids> (aside, generally I find private attribs to be problematic due to NYI role trusts, and the occasional quirk.)

[18:11] <masak> Abcxyz: if you have eval, you have some dynamism that's very hard to recreate without it.

[18:11] <doy> it's a public attribute, i'm just writing a custom accessor for it

[18:12] <skids> Right, but I've found working with the $! forms to sometimes be a bit treacherous.

[18:12] <masak> Abcxyz: that said, eval is one of those sharp-edged tools which computer science seems happy to replace with slightly less powerful, safer tools as we go along.

[18:13] <masak> Abcxyz: in JavaScript, the general consensus seems to be "eval -- don't do it". in Perl 5/6, it's more "eval -- it's there if you want it, but mind the risks".

[18:14] <skids> doy: That is, there are some things not yet quite up to spec with them.

[18:15] <doy> if i do "my $foo = $!foo", i can also reproduce it with $foo

[18:17] *** rking left
[18:17] *** rking joined
[18:18] *** avar left
[18:18] *** groky left
[18:22] *** avarab joined
[18:22] *** groky joined
[18:23] *** avarab is now known as avar

[18:23] <skids> doy: I can try to golf it, if you have a gist...

[18:24] *** SamuraiJack left
[18:24] *** mtk left
[18:24] *** mtk joined
[18:42] <doy> aha, found it

[18:44] <doy> r: role Foo { }; class Bar { has Foo $.foo; method baz { my $foo = $!foo; my $replacement = Foo.new; say $replacement.defined; say $foo.defined; $foo //= $replacement; say $foo.defined } }; Bar.new.baz

[18:44] <p6eval> rakudo 930369: OUTPUT¬´True‚ê§False‚ê§False‚ê§¬ª

[18:44] <doy> role type constraints seem to break things

[18:45] * masak submits rakudobug

[18:45] <masak> doy++ # nicely golf'd

[18:46] <masak> r: role Foo {}; my $x = Foo; $x //= Foo.new; say $x.defined

[18:46] <p6eval> rakudo 930369: OUTPUT¬´False‚ê§¬ª

[18:46] <masak> r: role Foo {}; say Foo.new.defined

[18:46] <p6eval> rakudo 930369: OUTPUT¬´True‚ê§¬ª

[18:46] <masak> yeah. definitely something wrong there.

[18:48] <masak> r: role Foo {}; my $x = Foo; $x = $x // Foo.new; say $x.defined

[18:48] <p6eval> rakudo 930369: OUTPUT¬´False‚ê§¬ª

[19:10] <skids> r: role Foo { }; my Foo $x.= new(); $x.defined.say # also this.

[19:10] <p6eval> rakudo 930369: OUTPUT¬´Cannot assign to a non-container‚ê§  in method dispatch:<.=> at src/gen/CORE.setting:949‚ê§  in  at src/gen/Metamodel.pm:1277‚ê§  in block  at /tmp/5h2_CfCZAb:1‚ê§‚ê§¬ª

[19:11] *** Chillance left
[19:11] *** Chillance joined
[19:12] <doy> all of the stringification methods not being able to handle recursive data structures is a bit annoying when debugging

[19:13] <masak> I'm a bit surprised we haven't fixed that yet.

[19:13] <masak> rn: my $a = []; $a[0] = $a; say $a.perl

[19:13] <doy> s/recursive/cyclical/

[19:14] <p6eval> niecza v24-12-g8e50362: OUTPUT¬´(timeout)¬ª

[19:14] <p6eval> ..rakudo 930369: OUTPUT¬´maximum recursion depth exceeded‚ê§current instr.: 'print_exception' pc 94134 (src/gen/CORE.setting.pir:44736) (src/gen/CORE.setting:9354)‚ê§called from Sub 'flattens' pc 255839 (src/gen/CORE.setting.pir:115657) (src/gen/CORE.setting:5724)‚ê§called from Sub '' pc 249168 ‚Ä¶

[19:15] <skids> Bug or feature?  Could be viewed as a generator.  Maybe what's missing is Cat?

[19:15] <masak> skids: no, .perl should by definition produce code that generates the structure.

[19:16] <masak> it's a finite structure, it just happens to link to itself.

[19:16] <skids> OK, I'll buy that for .perl.

[19:16] <skids> But Str?

[19:18] <masak> possibly .Str should just loop forever on it, yes.

[19:18] <masak> personally, I don't think having good Cat support is going to make this issue go away.

[19:19] <masak> how does it know it's in an infinite regress and needs to produce a Cat?

[19:19] <doy> i'm not sure why looping forever is a reasonable behavior for any kind of printing of a finite data structure

[19:19] <masak> besides, we asked for a .Str

[19:19] <skids> No of course not :-)  .oO(some Cats don't even make mice go away)

[19:22] <skids> masak: but as to the decision as to when to produce a Cat in such a situation, I don't see why finite Cats are not permissible.

[19:22] <doy> r: class Foo { method bar { "BAR" } }; class Baz { has $.foo handles 'bar'; method foo { $!foo //= Foo.new; $!foo } }; say Baz.new.bar

[19:22] <p6eval> rakudo 930369: OUTPUT¬´No such method 'bar' for invocant of type 'Any'‚ê§  in method bar at src/gen/CORE.setting:267‚ê§  in block  at /tmp/TLZqaU2zdA:1‚ê§‚ê§¬ª

[19:22] <doy> shouldn't delegation be using the accessor?

[19:23] <doy> or do i actually have to declare the delegation on the accessor in this case

[19:23] <doy> if i'm writing my own

[19:25] <skids> well, before that, you might want to actually invoke method foo.

[19:25] <doy> the $.foo attribute handles the bar method

[19:25] <doy> so i assumed it would get the value out of the $.foo attribute using the foo method

[19:26] <skids> it might be specced that way...

[19:31] <skids> It's a matter of when classes are allowed to optimize to direct access to attributes within their own code.

[19:31] <doy> right

[19:31] *** quester joined
[19:34] <skids> The spec says that "has $tail handles 'wag';" generates the equivalent of "method wag (|$args) { $!tail.wag(|$args) }" so yes probably you want the method form of delegation.  ISTR that might have been just recently implemented.

[19:36] <doy> yeah, that's reasonable enough

[19:36] <doy> and yeah, it works

[19:39] <skids> r: class a { method b handles "say" { 1 } }; a.new.say; #caveat

[19:39] <p6eval> rakudo 930369: OUTPUT¬´1‚ê§¬ª

[19:39] <skids> r: role a { method b handles "say" { 1 } }; a.new.say; #caveat

[19:39] <p6eval> rakudo 930369: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Method 'add_method' not found for invocant of class 'Perl6::Metamodel::GenericHOW'‚ê§at /tmp/TjBOSV8Q59:1‚ê§------> ‚ê§¬ª

[19:43] *** GlitchMr left
[19:43] *** GlitchMr joined
[19:45] <Ayiko> r: for ^0 { FIRST say 'first'; LAST say 'last'; LEAVE say 'leave'; } # should this LAST be run?

[19:45] <p6eval> rakudo 930369: OUTPUT¬´last‚ê§¬ª

[19:46] <masak> Ayiko: S04 says "at loop termination time". even an empty loop could be said to terminate.

[19:46] <masak> r: for ^0 { my $a = 42; LAST { say $a }

[19:46] <p6eval> rakudo 930369: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unable to parse expression in block; couldn't find final '}'‚ê§at /tmp/0twlDG6Xpp:1‚ê§------> [32mfor ^0 { my $a = 42; LAST { say $a }[33m‚èè[31m<EOL>[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        infix st‚Ä¶

[19:46] <masak> r: for ^0 { my $a = 42; LAST { say $a } }

[19:46] <p6eval> rakudo 930369: OUTPUT¬´Any()‚ê§¬ª

[19:46] <Ayiko> but then FIRST runs at loop initialization time, shouldn't that run too then?

[19:47] *** Vlavv` joined
[19:47] *** Vlavv_ left
[19:47] <Ayiko> I understand there's a logic to it, it just happens to interfere with my current use case...

[19:49] <masak> Ayiko: I may be wrong.

[19:49] <masak> it also says "after any LEAVE", which would indicate that it is indeed tied to block entry/exit.

[19:49] <masak> I definitely agree that FIRST and LAST should behave similarly.

[19:50] * masak submits rakudobug

[19:50] <masak> today is a good day for rakudobugs :)

[19:50] <skids> well, I wouldn't say "after any LEAVE" ties it that way, but would tend to agree whichever way they should behave, FIRST/LAST should be consistent.

[19:50] <Ayiko> that's what I'd expect too (though I can see a use for a LAST2 that also runs on empty loops :)

[19:51] <masak> eeew

[19:51] <masak> just put the bloody code after the loop! :P

[19:51] <flussence> .oO( maybe &wrap should work on control structures )

[19:51] <Ayiko> my @result isn't defined there :(

[19:55] *** am0c joined
[19:56] *** quester left
[20:00] <Ayiko> r: do for m:ov/aa/ -> $m { say "$m $_"; } given 'aaaa';

[20:00] <p6eval> rakudo 930369: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Unsupported use of do...given; in Perl 6 please use repeat...given‚ê§at /tmp/HYePDD4wFf:1‚ê§------> [32m/aa/ -> $m { say "$m $_"; } given 'aaaa'[33m‚èè[31m;[0m‚ê§    expecting any of:‚ê§        postfix‚ê§        infix or meta-infix‚ê§        in‚Ä¶

[20:00] <Ayiko> r: repeat for m:ov/aa/ -> $m { say "$m $_"; } given 'aaaa';

[20:00] <p6eval> rakudo 930369: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Missing block‚ê§at /tmp/QBcxUuVhsK:1‚ê§------> [32mrepeat [33m‚èè[31mfor m:ov/aa/ -> $m { say "$m $_"; } give[0m‚ê§    expecting any of:‚ê§        statement list‚ê§        parameterized block‚ê§¬ª

[20:04] <labster> good *, #perl6

[20:05] <skids> o/

[20:05] <labster> \o

[20:06] <labster> Last night, I was looking for a way to find the inodes of files (since I'm looking for duplicates, and thus hard links)

[20:06] <masak> ohayo, labster 

[20:07] <labster> ohaiyo gozaimasu, masak

[20:09] <labster> IO.stat isn't implemented yet, though it is in nqp, so I can just call nqp::stat for a single part of it, though I have no idea how to call the entire buffer

[20:09] <masak> the two oldest masakbugs that are still open: https://rt.perl.org/rt3/Ticket/Display.html?id=61602 and https://rt.perl.org/rt3/Ticket/Display.html?id=62086

[20:10] <masak> browsing through the very oldest masakbugs, it's encouraging to see how many were actually resolved (or, sometimes, rejected).

[20:10] <moritz> r: say Inf.Int

[20:10] <p6eval> rakudo 930369: OUTPUT¬´Cannot coerce Inf to an Int‚ê§  in method gist at src/gen/CORE.setting:10338‚ê§  in sub say at src/gen/CORE.setting:7515‚ê§  in block  at /tmp/NM9FRbZvnd:1‚ê§‚ê§¬ª

[20:10] <moritz> r: say NaN.Int

[20:10] <p6eval> rakudo 930369: OUTPUT¬´0‚ê§¬ª

[20:11] <moritz> I'd argue that Inf.Int is correct now

[20:11] <moritz> and NaN.Int should do the same

[20:11] <moritz> it's likely a small patch

[20:12] *** GlitchMr left
[20:12] <labster> but is IO::stat a place where we actually want to a stat buffer, or should we return an object to get .stat.inode, .stat.d, etc?

[20:12] <moritz> and the other one ... it might actually be correct to throw an exception from ~

[20:12] <moritz> labster: the atter

[20:12] <masak> moritz: according to that ticket, the spec considered Inf to be a valid Int.

[20:12] <moritz> *latter

[20:12] <masak> moritz: if it still does, then a coercion error is surely wrong.

[20:13] <moritz> masak: but according to the spec, Inf is also a Num

[20:13] <moritz> ETYPEERROR

[20:13] <masak> moritz: S02:701

[20:13] *** SmokeMachine left
[20:13] <masak> yes, I'm aware of the difficulties of Inf and NaN.

[20:14] <masak> I haven't heard a good solution.

[20:14] <masak> but still. that is what the spec says. to make it work somehow.

[20:14] <masak> not to throw an error.

[20:15] <masak> do we have prior art on this kind of problem? ten years ago, we would have said "junctive type! Int|Num"

[20:15] <masak> we don't do that any more. we aim for saner solutions.

[20:15] <masak> what would be a sane-but-still-permissive/interesting solution here?

[20:17] <masak> rn: say +^1

[20:17] <p6eval> rakudo 930369, niecza v24-12-g8e50362: OUTPUT¬´-2‚ê§¬ª

[20:17] <masak> :)

[20:20] * skids doesn't grep -i any nan/inf in libtomath so no guidance there.

[20:21] <masak> looking outside of numbers, Inf is meant to work with strings as well.

[20:21] *** spider-mario joined
[20:22] <masak> something like `-Inf before "foo" before Inf` is supposed to hold, for any "foo".

[20:22] <masak> though I don't think it goes deeper than that -- I mean, Inf can probably be a number type and still do that.

[20:23] <arnsholt> Is -Inf < -Inf (or <=, for that matter)?

[20:23] <masak> rn: say -Inf < -Inf

[20:23] <p6eval> rakudo 930369, niecza v24-12-g8e50362: OUTPUT¬´False‚ê§¬ª

[20:23] <masak> rn: say -Inf <= -Inf

[20:24] <p6eval> rakudo 930369, niecza v24-12-g8e50362: OUTPUT¬´True‚ê§¬ª

[20:24] <masak> no, and yes. :)

[20:24] <arnsholt> rn: say -Inf == -Inf

[20:24] <p6eval> rakudo 930369, niecza v24-12-g8e50362: OUTPUT¬´True‚ê§¬ª

[20:24] <skids> .oO(why do we insist on asking computers questions that explode human heads and expect any different.)

[20:24] <masak> arnsholt: I think this is in line with 754.

[20:25] <arnsholt> skids: Because poking at the hard problems in life is fun =)

[20:25] <masak> skids: oh, come on. Georg Cantor was the last human whose head needed to explode in order for us to grok infinities.

[20:25] <arnsholt> masak: Right, right. That makes a lot of sense

[20:27] <doy> "Cannot put a type constraint on an 'our'-scoped variable" # why is that?

[20:27] <masak> doy: because the point of declaration isn't unique.

[20:29] *** lue left
[20:29] <rindolf> Hi all.

[20:30] <masak> ohaiyo, rindolf.

[20:30] <rindolf> masak: iowa!

[20:30] <rindolf> masak: what's up?

[20:30] <arnsholt> Having Inf/NaN in line with 754 makes a very much sense, really. The full mathematical reality would force the equality test to be ternary

[20:31] <masak> rindolf: roof. night sky. space. :)

[20:32] <rindolf> masak: http://www.shlomifish.org/humour/fortunes/show.cgi?id=shlomif-fact-chuck-35

[20:34] <masak> rindolf: did you come up with that before or after people here on #perl6 started answering you literally when you asked "what's up?" :P

[20:35] <masak> rindolf: actually, even considering the actual meaning of that question, I'm not sure what answer you are expecting...

[20:35] <flussence> .oO( up is where I come from when I don't tie my shoelaces )

[20:35] <masak> "well, it's the 13th year. we're still developing the language. it's going fine."

[20:35] <rindolf> masak: I said various variations using /me is .

[20:36] <rindolf> masak: but I added this factoid to my site about a month ago.

[20:36] <rindolf> masak: it's original AFAIK.

[20:36] *** atrodo left
[20:48] *** spider-mario left
[20:49] *** spider-mario joined
[20:53] <doy> r: our $thing = False; proto foo {*}; multi foo { temp $thing = True }; sub bar { die "???" if $thing }; foo; bar;

[20:53] <p6eval> rakudo 930369: OUTPUT¬´???‚ê§  in sub bar at /tmp/RpPbtuBs5A:1‚ê§  in block  at /tmp/RpPbtuBs5A:1‚ê§‚ê§¬ª

[20:53] <doy> r: our $thing = False; sub foo { temp $thing = True }; sub bar { die "???" if $thing }; foo; bar;

[20:54] <p6eval> rakudo 930369:  ( no output )

[20:54] <doy> seems like temp doesn't work properly in multisubs?

[20:55] * masak submits rakudobug

[20:59] <tadzik> 1247         masak | doy: yeah, tadzik and TimToady has had that discussion at least twice.

[20:59] <tadzik> the moment I saw it I knew it has to be about BUILD

[21:00] <tadzik> (good evening #perl6) :)

[21:00] <masak> tadzik! \o/

[21:00] <masak> tadzik: we all have our "favorite" discussion topics... :)

[21:00] <tadzik> hehe

[21:01] <tadzik> I'm no longer discussing BUILD, since whenever I do I get shouted at, and probably for good reason :P

[21:06] <skids> .oO(Hrm, maybe if BUILD were a multi instead of an only, BUILDALL could just be calling all candidates (still in an order)) # /me sees if he can get shouted at.

[21:07] <tadzik> after 'BUILD' => { ... }; oh,-wait(...)

[21:07] <tadzik> std: sub oh,-wait() { }

[21:07] <p6eval> std a8bc48f: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Malformed block at /tmp/o06pni52LI line 1:‚ê§------> [32msub oh[33m‚èè[31m,-wait() { }[0m‚ê§    expecting any of:‚ê§     new name to be defined‚ê§ routine_def‚ê§Parse failed‚ê§FAILED 00:00 41m‚ê§¬ª

[21:07] <tadzik> dang ;)

[21:17] <skids> r: sub prefix:< oh,-wait > (|d) { {"HIYA".say} }; oh,-wait();

[21:17] <p6eval> rakudo 930369: OUTPUT¬´HIYA‚ê§¬ª

[21:17] *** buubot_backup left
[21:26] *** telex left
[21:28] *** telex joined
[21:31] *** TreyRust joined
[21:45] *** snearch joined
[21:54] <masak> 'night, #perl6

[21:55] <rindolf> masak: night.

[21:56] <timotimo> i wish i had started doing more with perl6 much earlier, i could totally do a lightning talk about perl6 at the 29c3 tomorrow :|

[21:59] <skids> timotimo: well, starting earlier also meant putting up with much less complete implementations.

[21:59] <timotimo> that is true, but i don't even know the basics

[21:59] <timotimo> i tried demonstrating how nice perl6 is to a friend last week and it was pretty pityful

[21:59] <skids> I think your timing is pretty good, actually.

[22:00] <timotimo> i do, too.

[22:05] <arnsholt> If you plan your talk it can probably go fairly well

[22:05] *** sjohnson left
[22:05] *** sjohnson joined
[22:05] <arnsholt> And I think there are some slides available from other people's more in-depth intros to Perl 6

[22:06] <arnsholt> For a lightning talk, you can get away with "look at these awesome features! Come play with us!"

[22:06] <timotimo> right. but i couldn't really back them up with "come find me in the hackcenter afterwards to play with cool stuff" ;)

[22:10] *** Kharec left
[22:10] *** Kharec joined
[22:13] *** Kharec left
[22:14] *** Kharec joined
[22:32] <arnsholt> Yeah, that might be a bit more limited

[22:33] <timotimo> and everyone is going to sleep so early around here ;)

[22:33] *** pmurias joined
[22:33] <timotimo> (here being the irc, in relation to the congress)

[22:33] *** lue joined
[22:34] <arnsholt> Which congress?

[22:34] *** rindolf left
[22:35] <timotimo> 29c3

[22:36] <arnsholt> I had to Wikipedia it, but now it makes sense

[22:36] <arnsholt> CCC, that's very cool!

[22:37] <timotimo> it always is :)

[22:37] <timotimo> but there's a lot of sexism going on in the hacker jeopardy right now, i hear :(

[22:37] <timotimo> at least people are massively complaining about it on twitter. not sure if they are also speaking up in the hall, too

[22:37] <arnsholt> Unfortunately, I'm not surprised =/

[22:38] <arnsholt> That's a good first step, at least

[22:38] <timotimo> there's an official harrassment response team this year around, but the 'creeper move cards' (which come from a separate group) are getting quite a bit of ridicule :|

[22:40] <arnsholt> Hopefully people keep doing it

[22:41] <arnsholt> *will keep

[22:41] *** am0c left
[22:42] <timotimo> they do have a point about the creeper move cards. they are hard to take seriously. the way they are used is you give people you already like green cards and use the red cards for trolling or as jokes

[22:42] <timotimo> i have no idea how to fix the cards

[22:42] <timotimo> but the harassment team (and their internal/external dect number) are a good start for sure.

[22:43] <arnsholt> Yeah, that's a good idea

[22:43] *** snearch left
[22:43] <arnsholt> The cards are a good idea if they're used as intended, I think

[22:44] <timotimo> yes, but i don't see that work at all any time soon :(

[22:49] *** thou left
[22:58] <jnthn> evening, for a moment o/

[22:58] <phenny> jnthn: 23 Dec 20:37Z <FROGGS> tell jnthn that this is my questionable patch: https://github.com/FROGGS/rakudo/commit/ebf6acec98780f15a58d0183fc888d213da2b43d

[22:58] <arnsholt> Yeah, there's that. But on a more positive note, you can start planning a talk (maybe submitting a full-length one, even) for next year's CCC ;)

[23:02] <jnthn> phenny: tell FROGGS the reason you get odd results is probably 'cus it looks like you add the other proto to the candidate list, rather than the other proto's dispatchees.

[23:02] <phenny> jnthn: I'll pass that on when FROGGS is around.

[23:03] <jnthn> phenny: tell FROGGS also you should only do this auto-merging for onlystar dispathcers; real competition to "own the proto" is a problem, I suspect.

[23:03] <phenny> jnthn: I'll pass that on when FROGGS is around.

[23:04] <jnthn> masak: the "temp" issue is a well known one of LEAVE/multi interaction, which is already field.

[23:05] *** MayDaniel left
[23:05] <pmurias> jnthn: if I want to insert info into a setting so I can load it when compiling other units how should I do that?

[23:05] <jnthn> "insert info"?

[23:06] <pmurias> jnthn: I want to compile a setting both to pir and javascript and have a mapping between object in both of that forms

[23:06] <pmurias> jnthn: stuff that says "this object is compiled to OBJ143 in javascript"

[23:06] <jnthn> Settings just become outer lexical scopes, so anything the setting puts in scope is visible, if that makes any sense.

[23:06] <pmurias> yes

[23:07] <doy> hmmm, can i dump a compiled regex somehow?

[23:07] <timotimo> i talked to the talker here: http://events.ccc.de/congress/2012/Fahrplan/events/5104.en.html

[23:07] <jnthn> It sounds like you're about to re-invent the existing serialization stuff I already invented once... :)

[23:07] <timotimo> i said perl6 has a .net based interpreter

[23:07] <jnthn> That's *exactly* what the serialization context stuff does: gives objects indexes.

[23:08] <timotimo> can niecza be embedded like ironpython for instance?

[23:08] <pmurias> jnthn: that makes sense

[23:09] <pmurias> jnthn: how can I get the serialization context index for a given object in the setting?

[23:09] <jnthn> pmurias: mmm...hm

[23:09] <jnthn> There's an op to do it I *think*

[23:09] <jnthn> Look for where QAST::WVal is compiled

[23:09] <doy> r: rx/foo.*bar/.perl

[23:09] <p6eval> rakudo 930369:  ( no output )

[23:09] <doy> r: say rx/foo.*bar/.perl

[23:09] <p6eval> rakudo 930369: OUTPUT¬´regex(Mu : Mu *%_) { ... }‚ê§¬ª

[23:09] <doy> not particularly helpful(:

[23:10] <jnthn> doy: Well, apart from if we make .perl dump the actual body we'd just have to include the whole program source.

[23:10] <jnthn> Which I've resisted doing by default.

[23:10] <doy> (:

[23:11] <doy> something for .gist though would be nice

[23:11] <jnthn> Certainly for Rakudo, there's not a good way to work back from the compiled output back to a source representation (ala deparse)

[23:11] <jnthn> At the moment I suspect it just does whatever it does for any method (since regexes are really methods)

[23:12] <doy> yeah

[23:12] <doy> carrying around the originally parsed string maybe?

[23:13] <doy> having something to look at would be pretty useful for testing and debugging

[23:13] <jnthn> Just for regexes, or for methods in general?

[23:13] <doy> hmmm

[23:13] <doy> good question!

[23:13] <pmurias> jnthn: do we only have on serialisation context? are the serialiasation ids unique?

[23:14] <jnthn> pmurias: There is an SC per compilation unit.

[23:14] *** thou joined
[23:14] *** Kharec left
[23:14] <jnthn> The contexts themselves have unique names; to fully resolve a reference you need to know both the name and the index.

[23:15] <jnthn> I may have been thoughtful enough to explain some of this in the serialization format docs, fwiw. :)

[23:16] *** MayDaniel joined
[23:16] <jnthn> doy: At the "is it hard to implement" level, it'd be a very easy feature to add.

[23:16] <doy> is that a hint?

[23:16] <doy> (:

[23:16] <pmurias> jnthn: nqp_get_sc_object returns a context which should provide both a context name and a index

[23:17] <jnthn> More just clarifying that it's unimplemented due to me wondering if it should be, rather than 'cus it's hard to do :)

[23:17] *** PacoAir left
[23:17] <jnthn> pmurias: I think that's the op that actually does the lookup...

[23:17] *** PacoAir joined
[23:18] <jnthn> pmurias: https://github.com/perl6/nqp/blob/master/src/QAST/Compiler.nqp#L946

[23:18] <jnthn> $node.value is the object

[23:19] <jnthn> After the operations you see there, $handle is the SC name and $idx is the numerical index.

[23:19] *** stopbit left
[23:19] <jnthn> It code-gens a nqp_get_sc_object to actually do the lookup

[23:20] <pmurias> .handle is the context name?

[23:20] <jnthn> Yeah

[23:21] <pmurias> that's what I need, thanks

[23:21] <jnthn> It's fairly consistently called "handle"

[23:22] <pmurias> nqp_get_sc_object will work for stuff which is loaded from a setting?

[23:22] <timotimo> please tell me again how i can tell someone who's AFK something using the bot?

[23:22] <jnthn> phenny: tell timotimo that you use phenny like this

[23:22] <phenny> jnthn: I'll pass that on when timotimo is around.

[23:23] <jnthn> pmurias: yes

[23:23] <jnthn> pmurias: So long as it got loaded at some point, all is good

[23:23] <jnthn> pmurias: I just have a global in-memory "registry" of all the loaded ones.

[23:23] *** MayDaniel left
[23:23] <jnthn> pmurias: It works out even for nqp because I ensure that different bootstrap stages end up with different handles.

[23:24] <jnthn> (otherwise you could get all kinds of confusion :))

[23:25] <timotimo> phenny: tell sorear http://events.ccc.de/congress/2012/Fahrplan/events/5104.en.html this guy wrote a neat protocol analysis/fuzzing/MITM gui software using .net and i was telling him about niecza. can niecza be embedded like ironpython?

[23:25] <phenny> timotimo: I'll pass that on when sorear is around.

[23:25] <phenny> timotimo: 23:22Z <jnthn> tell timotimo that you use phenny like this

[23:27] <sorear> timotimo: I'm sure it's *possible*

[23:27] <phenny> sorear: 23:25Z <timotimo> tell sorear http://events.ccc.de/congress/2012/Fahrplan/events/5104.en.html this guy wrote a neat protocol analysis/fuzzing/MITM gui software using .net and i was telling him about niecza. can niecza be embedded like ironpython?

[23:27] <timotimo> oh, there you are :)

[23:28] <timotimo> the question was is the api similar?

[23:29] <sorear> I doubt it

[23:32] *** kaare_ left
[23:32] <pmurias> jnthn: how can I check what the handle of a current unit is?

[23:33] *** nyuszika7h left
[23:35] *** nyuszika7h joined
[23:35] <jnthn> pmurias: At compile time?

[23:36] <jnthn> World exposes it, I think

[23:36] <jnthn> Yes, .handle

[23:38] *** Abcxyz left
[23:45] <jnthn> time for some sleep &

[23:46] *** grondilu joined
[23:47] <grondilu> rn: my $n = 4; $n [+>]= 2;

[23:47] <p6eval> niecza v24-12-g8e50362:  ( no output )

[23:47] <p6eval> ..rakudo 930369: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix = instead‚ê§at /tmp/87fIYgtr0e:1‚ê§------> [32mmy $n = 4; $n [+>]=[33m‚èè[31m 2;[0m‚ê§¬ª

[23:47] <grondilu> rn: my $n = 4; say $n [+>]= 2;

[23:47] <p6eval> rakudo 930369: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Preceding context expects a term, but found infix = instead‚ê§at /tmp/6SZBCJCyDT:1‚ê§------> [32mmy $n = 4; say $n [+>]=[33m‚èè[31m 2;[0m‚ê§¬ª

[23:47] <p6eval> ..niecza v24-12-g8e50362: OUTPUT¬´1‚ê§¬ª

[23:47] <grondilu> rn: my $n = 4; say $n +>= 2;

[23:47] <p6eval> rakudo 930369, niecza v24-12-g8e50362: OUTPUT¬´1‚ê§¬ª

[23:48] <grondilu> rn: my @n = 1, 2, 4 ... 16; say @n X[+>] 2

[23:48] <p6eval> rakudo 930369, niecza v24-12-g8e50362: OUTPUT¬´0 0 1 2 4‚ê§¬ª

[23:54] *** denisboyun_ left
