[00:01] *** masak left
[00:01] *** dalek left
[00:02] *** pmichaud left
[00:02] *** PerlJam left
[00:02] *** topo left
[00:03] *** [Coke] left
[00:03] *** hugme left
[00:03] *** whiteknight left
[00:05] *** Juerd left
[00:05] *** sergot left
[00:11] *** Juerd joined
[00:11] *** topo joined
[00:13] *** masak joined
[00:14] *** pmichaud joined
[00:14] *** [Coke] joined
[00:17] *** lawrmcfa left
[00:19] *** PerlJam joined
[00:20] *** sergot joined
[00:22] *** arlinius left
[00:26] *** p6eval joined
[00:26] *** ChanServ sets mode: +v p6eval

[00:26] *** hugme joined
[00:26] *** ChanServ sets mode: +v hugme

[00:29] *** dayangkun left
[00:36] *** dayangkun joined
[00:36] *** dayangkun left
[00:37] <felher> TimToady++ # new rosettacode entry :)

[00:43] <cognominal> inifinte lazyness

[00:43] <cognominal> *infinite

[01:02] *** FROGGS_ joined
[01:03] *** sivoais left
[01:04] *** anuby joined
[01:04] *** flightrecorder left
[01:05] *** stopbit left
[01:05] *** FROGGS left
[01:06] *** flightrecorder joined
[01:06] *** sivoais joined
[01:08] *** japhb_ left
[01:09] *** hypolin joined
[01:12] *** jerome left
[01:15] *** preflex left
[01:21] *** sergot_ joined
[01:24] *** gootle joined
[01:25] *** sergot left
[01:25] *** skids left
[01:26] *** jerome joined
[01:26] *** tokuhiro_ left
[01:27] *** ServerSage left
[01:32] *** ServerSage joined
[01:33] *** skids joined
[01:52] *** tadzik joined
[01:55] *** grondilu left
[02:11] *** hypolin left
[02:13] *** hypolin joined
[02:23] *** _jaldhar joined
[02:35] <colomon> japhb_: I did that recently as well, see the first line of either source code block here: http://justrakudoit.wordpress.com/2012/10/05/sums-of-fourth-powers/

[02:35] <colomon> It's quite handy.

[02:38] *** orafu left
[02:38] *** orafu joined
[02:39] *** _jaldhar left
[02:40] <TimToady> not just handy...it also avoids recalculating the sequence each time

[02:41] *** _jaldhar joined
[02:56] *** lawrmcfa joined
[03:02] *** cibs joined
[03:04] *** x19290 joined
[03:05] *** x19290 left
[03:07] *** xinming left
[03:08] *** newbie joined
[03:08] *** newbie is now known as Guest35851

[03:11] *** newbie1 joined
[03:12] *** newbie1 left
[03:12] *** Guest35851 left
[03:12] *** newbie1 joined
[03:13] <masak> it doesn't seem possible to reconcile infinite lazy lists and conc lists/mapreduce.

[03:13] <masak> there's probably even a proof of that.

[03:14] *** newbie1 left
[03:15] *** x19290 joined
[03:15] <shachaf> Does "conc list" mean "binary tree"?

[03:15] *** xinming joined
[03:15] *** x19290 left
[03:16] <masak> yeah.

[03:17] <masak> I think it's Guy Steele's name for it.

[03:17] <shachaf> Have you seen FMList in Haskell?

[03:17] <sorear> masak: do you mean cons lists?

[03:18] <shachaf> I don't know if it's particularly related to what you're after but it's neat.

[03:18] *** hypolin left
[03:19] *** hypolin joined
[03:21] <masak> sorear: infinite lazy lists can be implemented with cons lists. mapreducible lists can be implemented with conc lists.

[03:22] <masak> it seems that even Perl 6 to some extent flirts with the duality (or whatever) of these two.

[03:22] <japhb> colomon, hmmm ... that construction in your fourth-powers post is very similar in spirit, but not quite the same construction as TimToady's.  He uses a sequence in both places, rather than a mapped range and a clipping sequence.  I guess conceptually this generalizes well.

[03:22] <masak> some builtins provide laziness. some provide hyperness. you can indicate which of the two you want.

[03:24] <masak> I guess I'm just curious *why* lazy and mapreduce seem irreconcilable. it seems perfectly obvious that they are.

[03:28] <masak> or rather, here's the thing. with both kinds of lists you can start iterate from the head of the list and nextwards. no problem. but then lazy seems to make one guarantee and mapreduce makes another. and those guarantees are incompatible.

[03:29] <masak> lazy: "I promise not to disappear in the mists of computation just because the list is potentially infinite"

[03:29] <masak> hyper: "it doesn't matter which part of the list we do first, 's all good"

[03:30] <shachaf> What does "do first" mean?

[03:30] <shachaf> As in an associative operation?

[03:30] <masak> yes, I think "associative" captures what hyper guarantees here.

[03:30] <masak> very interesting!

[03:31] <masak> hm, but lazy seems to be a guarantee about termination, whereas hyper is a guarantee about ordering...

[03:32] <shachaf> What's hyper?

[03:32] <masak> @values>>.abs

[03:32] * shachaf probably ought to know basic Perl 6.

[03:33] <masak> does .abs on each individual value, in an arbitrary order. the returned values are in the original order, though.

[03:33] <Timbus> 'conversational perl 6'

[03:33] <masak> shachaf: more generally, hyper does a computation on the elements of a container, in an arbitrary order and possibly in parallel.

[03:33] <masak> think GPU.

[03:34] <shachaf> Oh, that doesn't have to do with associativity in particular. I was thinking you meant a fold.

[03:34] *** skids left
[03:35] <TimToady> this incompatibility is precisely why we have both Z* and »*«

[03:36] <Timbus> masak, is there a case where you wouldn't want a hyper operator? in terms of Z+ vs >>+<< and so TimToady beats me to it

[03:36] <shachaf> Z+ is zipped?

[03:36] <Timbus> but have you ever wanted a side effecty Z

[03:36] <TimToady> it's a zip-with meta-operator

[03:36] <shachaf> Right.

[03:37] <TimToady> why would anyone ever want side effects?  <hides under the FP hat>

[03:37] <Timbus> heh

[03:37] <shachaf> So what's »*«? Cartesian product?

[03:38] <TimToady> that's simply a parallel operation, not to be confused with mathematical vectors and such

[03:38] <shachaf> Oh.

[03:38] <TimToady> which is why we no longer call them "vector ops" :)

[03:38] *** sftp left
[03:38] <TimToady> use a different operator for that

[03:39] <TimToady> but generally you use X* for normal cross-multiplication

[03:39] <TimToady> rn: say 1,2,3 X* 2,3

[03:39] <p6eval> rakudo dbf347, niecza v22-7-g7df6137: OUTPUT«2 3 4 6 6 9␤»

[03:39] <Timbus> TimToady, well i'm being more specific. have you had to use side effects in a zip or cross op in any of your rosettacode submissions for example? im actually interested in their use

[03:40] <shachaf> Are "X" and "Z" part of the language syntax or can users define things like that?

[03:40] * shachaf should probably read the language syntax.

[03:40] <masak> I'm aware that we have both Z* and >>*<<. I'm curious about the incompatibility itself.

[03:40] <TimToady> as far as I know I've only ever used internal side effects to track state in a stateful generator

[03:40] <Timbus> sub infix:<myop>

[03:40] <masak> seems the data structures (lazy list and conc list) are simply geared towards doing different things.

[03:41] <TimToady> sure, though people will often misuse them

[03:41] <masak> a lazy list is "self-similar" in a way that allows it to continue indefinitely and thus allow infinite lazy lists.

[03:41] <shachaf> masak: You can have a lazy infinite tree but it'll be lazy in a different way from a lazy infinite list.

[03:41] <TimToady> and it's not out of all reason to do some parallel ops even on an infinite list

[03:41] <masak> trees could potentially be infinite but for our purposes that's the wrong kind of infinite (destroys well-ordering).

[03:42] <TimToady> whether by handing out bits to work on, or by dividing by some sequence of sizes that converges on infinity...

[03:42] <TimToady> 1, 2, 4, 8, 16 elements at a time, and such

[03:42] <masak> whereas the strength of trees seems to be divide-and-conquer, something that linked lists don't do well at all.

[03:42] <shachaf> masak: You can traverse the tree any way you like. :-)

[03:42] <TimToady> or more likely some kind of fibonacci divvying up as the problem scales up

[03:43] <TimToady> nobody says you can't have an infinite tree :)

[03:43] <masak> TimToady: hm. I see how it can be done but not how the process would know to stop. there's plenty of room at infinity.

[03:44] <masak> TimToady: re infinite trees, see above. they don't give you list indexes.

[03:44] <TimToady> well, sure, but I thought we were talking about doing parallel ops on something infinite

[03:44] <Timbus> the infinite tree. feels like ive been pruning this thing forever

[03:44] <shachaf> masak: Are you thinking of the "first" element as "the one all the way on the left" or something along those lines?

[03:44] <TimToady> or unbounded, anyway

[03:44] <masak> "unbounded" is a much nicer word than "infinite". I must remember to use it more.

[03:45] <masak> shachaf: yes.

[03:45] <shachaf> Well, pick the root as the first element instead.

[03:45] <TimToady> an arbitrarily long tree can still know how to find any element N, albeit without promising equal efficiency to the early elements

[03:46] <TimToady> that being said, I think problems naturally fall into one or the other situation most of the time

[03:46] <masak> right.

[03:46] <masak> so maybe incompatible in practice rather than inherently.

[03:46] <TimToady> either you're trying to work behind or you're trying to work ahead

[03:47] <masak> "work behind"? :)

[03:47] <TimToady> be lazy or be anti-lazy

[03:47] <masak> ah, laziness.

[03:47] <masak> oh, that's a rather cute way of viewing it. TimToady++

[03:48] <TimToady> Rule 1: don't do it.  Rule 2: don't do it now.  Rule 3: don't just do one of it now. :)

[03:48] <masak> it also illustrates why "working ahead" and "unbounded" are a bad combination most of the time.

[03:48] <TimToady> we do allow for batching though, much like STDIO buffers

[03:49] <masak> yeah; every time I've run into batching in Rakudo I've hated it.

[03:49] <TimToady> though we also need to know when not to batch, or we can't generate Hamming numbers recursively

[03:49] <masak> thinking "you promised me laziness and now you do this...." :(

[03:49] <masak> right.

[03:49] <masak> things like that.

[03:49] <TimToady> if you're programming in the FP idiom it shouldn't be very noticeable

[03:50] <masak> seems the guarantee not to work ahead can sometimes be as important as the attempt to work behind.

[03:50] <TimToady> obviously you should only batch where there's an obvious overhead that can be factored out

[03:51] <TimToady> if we can stall when we notice we're using something self-referentially lazy, it should work out okay

[03:51] <TimToady> but that's a big "if"

[03:53] <TimToady> maybe we just say that batching only works with known values, and never unlazies more than the one value necessary to progress

[03:53] * TimToady waves hands in a parady of himself

[03:55] <TimToady> but you could, say, map over all the reified bits of the input, or 1 element if there are no reified elements available

[03:57] <TimToady> speaking of Hamming, been thinking more about a putative list merge metaoperator

[03:58] <TimToady> for Mop, we could say that if $value Mop $value returns either True or Order::Same, we assume they want duplicates, and otherwise remove duplicates

[03:59] <TimToady> so Mleg or Mge would allow duplicates, but Mlt or Mgt would not

[03:59] <TimToady> or something like that

[03:59] <TimToady> we'd have to decide if the default should be Mcmp or Mbefore

[03:59] <TimToady> (for a bare M op)

[04:01] <TimToady> by the above rule, Mcmp would include duplicates, but Mbefore would not

[04:01] *** lawrmcfa left
[04:02] <TimToady> assuming M defaults to including duplicates, we get a Hamming rule of:

[04:02] <TimToady> constant @hamming = 1, dedup (@hamming X* 2) M (@hamming X* 3) M (@hamming X* 5);

[04:02] <TimToady> with the dedup necessary

[04:02] <TimToady> if instead it defaults to deduping semantics, then it'd just be

[04:03] <TimToady> constant @hamming = 1, ((@hamming X* 2) M (@hamming X* 3) M (@hamming X* 5));

[04:03] <TimToady> or maybe one would write

[04:03] <TimToady> constant @hamming = 1, do (@hamming X* 2) M (@hamming X* 3) M (@hamming X* 5);

[04:04] <sorear> moritz: ping

[04:04] *** cognominal_ joined
[04:06] *** cognominal left
[04:10] <TimToady> masak: another thing you should consider is that some of the things Google uses mapreduce for are essentially open-ended, much like arbitrary lists

[04:10] <TimToady> if you search for something very common, you'll never get to the end of that list by clicking in your browser

[04:11] <TimToady> so you can do mapreduce on an infinite list, as long as you can identify when there's demand for another batch

[04:20] <masak> why 'dedup' and not 'uniq'? what does the former do that the latter doesn't?

[04:21] <sorear> nub!

[04:21] <masak> TimToady: I don't buy the Google analogy. the lazy bit is in sending the result over the wire. the mapreduce has been run long before that as part of all the precomputations they do.

[04:22] <sorear> google can't anticipate every posisble search

[04:22] <masak> indeed.

[04:23] <masak> but by the time you search, the algorithmic challenge is combining the right indices and iterating through them.

[04:23] <masak> that's a lazy task, not a hyper task.

[04:24] <TimToady> I'll wager they don't mapreduce the parts of the search they figure you won't get to; the N results is likely a guess

[04:27] <TimToady> however, when they give you related searches, they very likely have precalculated your results out as far to however far they think you might go, since obviously someone else has tried those searches earlier

[04:28] * masak is still very fond of the "work ahead" and "work behind" terms

[04:28] <TimToady> or they otherwise have some knowledge that those new keywords will cut down your search space significantly, which I suppose could be derived from the page contents somehow

[04:31] <diakopter> I think they have magic elves

[04:38] <diakopter> rn: say e ** (pi * i)

[04:38] <p6eval> niecza v22-7-g7df6137: OUTPUT«-1+1.2246063538223773E-16i␤»

[04:38] <p6eval> ..rakudo dbf347: OUTPUT«-1-7.28641469046904e-10i␤»

[04:38] <diakopter> niecza is closer

[04:39] <sorear> rn: say sin pi

[04:39] <p6eval> niecza v22-7-g7df6137: OUTPUT«1.2246063538223773E-16␤»

[04:39] <p6eval> ..rakudo dbf347: OUTPUT«-3.52688866664137e-10␤»

[04:39] <sorear> rn: say pi.WHAT

[04:40] <p6eval> rakudo dbf347, niecza v22-7-g7df6137: OUTPUT«Num()␤»

[04:40] <masak> diakopter: re magic elves: "You confuse a high conditional likelihood from your hypothesis to the evidence with a high posterior probability of the hpothesis given the evidence" :P

[04:40] <sorear> rn: say pi

[04:40] <p6eval> rakudo dbf347: OUTPUT«3.14159265394248␤»

[04:40] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«3.1415926535897931␤»

[04:41] <sorear> interesting

[04:42] <diakopter> one of those seems... off

[04:43] <sorear> yes

[04:43] <sorear> the value in Rakudo's source code agrees with the value that Niecza prints

[04:43] <sorear> my constant pi = 3.14159_26535_89793_238e0;

[04:44] <sorear> r: say 3.14159_26535_89793_238e0;

[04:44] <p6eval> rakudo dbf347: OUTPUT«3.14159265394248␤»

[04:44] <diakopter> r: say 3.14156 + 0.0000026535

[04:44] <p6eval> rakudo dbf347: OUTPUT«3.1415626535␤»

[04:45] <sorear> r: say 0.00000000001

[04:45] <p6eval> rakudo dbf347: OUTPUT«0.00000000001␤»

[04:45] <sorear> r: say 0.0000000000001

[04:45] <p6eval> rakudo dbf347: OUTPUT«0.0000000000001␤»

[04:45] *** kaleem joined
[04:45] <sorear> r: say 0.0000000000001e0

[04:45] <p6eval> rakudo dbf347: OUTPUT«1e-13␤»

[04:45] <diakopter> r: say 3.14156 + 0.0000026535 + 0.000000000089793

[04:45] <p6eval> rakudo dbf347: OUTPUT«3.141562653589793␤»

[04:45] <sorear> r: say 1.0000000000001e0

[04:45] <p6eval> rakudo dbf347: OUTPUT«1.0000000000001␤»

[04:45] <diakopter> r: say 3.14156 + 0.0000026535 + 0.000000000089793e0

[04:45] <p6eval> rakudo dbf347: OUTPUT«3.14156265358979␤»

[04:45] <diakopter> r: say 3.14156 + 0.0000026535e0 + 0.000000000089793e0

[04:45] <p6eval> rakudo dbf347: OUTPUT«3.14156265358979␤»

[04:45] <diakopter> r: say 3.14156e0 + 0.0000026535e0 + 0.000000000089793e0

[04:45] <p6eval> rakudo dbf347: OUTPUT«3.14156265358979␤»

[04:46] <diakopter> r: say 3.14156 + 0.0000026535 + 0.000000000089793 + 0.000000000000000238

[04:46] <p6eval> rakudo dbf347: OUTPUT«3.141562653589793238␤»

[04:46] <diakopter> well then

[04:46] <TimToady> r: say atan2(1,1)*4

[04:46] <p6eval> rakudo dbf347: OUTPUT«3.14159265358979␤»

[04:47] <sorear> r: say sin atan2(1,1)*4; say sin pi

[04:47] <p6eval> rakudo dbf347: OUTPUT«1.22460635382238e-16␤-3.52688866664137e-10␤»

[04:47] <sorear> r: say atan2(1,1)*4 - pi

[04:47] <p6eval> rakudo dbf347: OUTPUT«-3.52688989124772e-10␤»

[04:51] <TimToady> nr: say 3.14159_26535_89793_238e0.base(10)

[04:51] <p6eval> rakudo dbf347: OUTPUT«3.14159265␤»

[04:51] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«Unhandled exception: Unable to resolve method base in type Num␤  at /tmp/JdkNqY1JmM line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4198 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 4199 (module-CORE @ 574) ␤  at /home/p6…

[04:51] <diakopter> rn: say acos(-1)

[04:51] <p6eval> rakudo dbf347: OUTPUT«3.14159265358979␤»

[04:51] <p6eval> ..niecza v22-7-g7df6137: OUTPUT«3.1415926535897931␤»

[04:52] <diakopter> rn: say 2*i*log((1-i)/(1+i))

[04:52] <p6eval> niecza v22-7-g7df6137: OUTPUT«3.1415926535897931+0i␤»

[04:52] <p6eval> ..rakudo dbf347: OUTPUT«3.14159265358979+0i␤»

[04:53] <TimToady> sorear's original say 3.14159_26535_89793_238e0; prints a more correct value in my rakudo here.  64-bit processor maybe?

[04:54] <TimToady> 10 places of accuracy corresponds approximately to the size of a 32-bit integer

[04:55] <TimToady> npr: say 1.1111111111111111111111111111111111111

[04:55] <p6eval> niecza v22-7-g7df6137: OUTPUT«1.1111111111111112␤»

[04:55] <p6eval> ..rakudo dbf347: OUTPUT«1.111111111109391735851659177569672465324␤»

[04:55] <p6eval> ..pugs: OUTPUT«1.1111111111111111111111111111111111111␤»

[04:56] *** cognominal_ left
[04:56] <TimToady> I get more 1's in my rakudo: 1.111111111111111116045435665000695735216

[04:57] <diakopter> npr: say (1/9).Num

[04:57] <p6eval> rakudo dbf347: OUTPUT«0.111111111111111␤»

[04:57] <p6eval> ..niecza v22-7-g7df6137, pugs: OUTPUT«0.1111111111111111␤»

[04:57] <diakopter> whatevs

[04:59] <sorear> TimToady: p6eval is a 64 bit machine but the rakudo binary is 32-bit.  also, the rakudo binary is dated oct 11

[04:59] <sorear> erm, that's today, nevermind

[05:00] <diakopter> hee

[05:00] <TimToady> well, mine was older, so trying a recompile to see if I lose accuracy :D

[05:05] <TimToady> same answer, so probably 32 vs 64

[05:07] * Woodi thinks acos(-1) should return π... hovewer replacing calculator with symbolic operation handling can be not optimal for common cases :)

[05:08] <Woodi> but it probably depends on π use cases...

[05:08] <Woodi> heavy morning # :)

[05:09] <sorear> yo Woodi

[05:11] <masak> Woodi: you can always build your own symbolic algebra library on top of Perl 6.

[05:11] <masak> though I agree that having complex numbers and rationals is already going partway in that direction.

[05:14] * sorear just uses maxima

[05:14] * sorear thinks it's kind of weird using software that was written when his father was 6

[05:15] <moritz> sorear: pong

[05:15] <sorear> PM

[05:16] <masak> phenny: en fr "PM"?

[05:16] <phenny> masak: "PM" (en to fr, translate.google.com)

[05:17] * moritz is pretty sure that would be MP or so :-)

[05:17] *** erkan joined
[05:17] *** erkan left
[05:17] *** erkan joined
[05:18] <sorear> phenny: en fr "MP"?

[05:18] <phenny> sorear: "MP" (en to fr, translate.google.com)

[05:18] *** aharoni joined
[05:20] <Woodi> btw. last month there was discusion about Excel sequenes continuation like [1,2] and guesing 3... Shadows in my memory says that finding formula having few sequence numbers was popular tormenting during discret math course...

[05:20] <diakopter> masak: what's the shortest program that can timeout rakudo

[05:21] <Woodi> diakopter: :)

[05:21] <diakopter> p6eval

[05:21] <sorear> r: redo

[05:21] <p6eval> rakudo dbf347: OUTPUT«redo without loop construct␤  in block  at src/gen/CORE.setting:378␤  in block  at src/gen/CORE.setting:448␤  in block  at /tmp/bzQ4Bwbxhf:1␤␤»

[05:21] <Woodi> r: sleep $max+1

[05:21] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Variable $max is not declared␤at /tmp/v8IsoVE8ya:1␤»

[05:21] <sorear> r: loop;

[05:21] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Missing block␤at /tmp/oRDSJPzhnT:1␤»

[05:21] <sorear> r: loop ;

[05:21] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Missing block␤at /tmp/8XFANYLFc0:1␤»

[05:21] <sorear> r: loop{}

[05:21] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Whitespace required after 'loop' at line 2, near "{}"␤»

[05:21] <sorear> r: loop {}

[05:21] <p6eval> rakudo dbf347: OUTPUT«(timeout)»

[05:22] <sorear> r: +^Inf

[05:22] <p6eval> rakudo dbf347: OUTPUT«Cannot coerce Inf to an Int␤  in method Numeric at src/gen/CORE.setting:9932␤  in sub prefix:<+^> at src/gen/CORE.setting:2652␤  in sub prefix:<+^> at src/gen/CORE.setting:2652␤  in block  at /tmp/1tep_kwU91:1␤␤»

[05:22] <sorear> r: [^Inf]

[05:22] <p6eval> rakudo dbf347:  ( no output )

[05:23] <TimToady> r: pi xx*

[05:23] <p6eval> rakudo dbf347:  ( no output )

[05:24] <sorear> n: do redo

[05:24] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)»

[05:27] *** \n is now known as nyuszika7h

[05:27] <sorear> TimToady: should loop control s work without braces?

[05:27] <TimToady> well, they certainly shouldn't work without a loop

[05:27] *** hash_table left
[05:28] <sorear> do {} is a loop

[05:31] <masak> r: loop{}

[05:31] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Whitespace required after 'loop' at line 2, near "{}"␤»

[05:31] <TimToady> wow, that part of the spec is so old I'd forgotten it :)

[05:31] <masak> r: loop {}

[05:31] <masak> beat that ;)

[05:31] <p6eval> rakudo dbf347: OUTPUT«(timeout)»

[05:32] <masak> oh, it's as short as 'do redo'

[05:32] <masak> how come 'do' is a loop, by the way?

[05:33] *** birdwindupbird joined
[05:34] <TimToady> why not?

[05:34] <diakopter> masak: sorear beat you to that one

[05:38] <masak> oh.

[05:39] <masak> TimToady: both the "why" and "why not" questions are motivated, but it seems to me the burden of explanation is on the person who wants it to be a loop. since, well, it isn't.

[05:39] <masak> neither was it in Perl 5, even though "do" had different semantics there.

[05:39] <TimToady> nr: 9**9**9

[05:39] <masak> s/was/is/, s/had/has/

[05:39] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)»

[05:39] <p6eval> ..rakudo dbf347:  ( no output )

[05:39] <sorear> masak: it's a loop in niecza because S04-statements/do.t wants it to be one.

[05:40] <sorear> masak: it was a cheap way to get lots of spectests.

[05:40] <diakopter> TimToady: I've been trying that one for a while

[05:40] <diakopter> :D

[05:40] <sorear> masak: I recognize this may not be a fully satisfactory answer either

[05:40] <masak> sorear: what part of 'do' (as per the spec) indicates that it is a loop?

[05:41] <masak> I just see it as an statement-to-expression converter.

[05:41] <masak> a*

[05:41] <TimToady> the part that also occurs in "redo"?

[05:41] <masak> ok, point very well taken.

[05:41] <sorear> masak: S04-statements/do.t line 86

[05:42] <sorear> masak: also, you don't need a keyword to convert statemtnes to expressions in p6

[05:42] <masak> sorear: sure. though spectests, especially old ones, have disagreed with the synopses before.

[05:42] <sorear> n: say (if 1 { 5 } else { 10 })

[05:42] <p6eval> niecza v22-7-g7df6137: OUTPUT«5␤»

[05:42] <masak> sorear: well, it's nice sometimes because it needs no ending brace.

[05:42] <diakopter> n: 9*****9

[05:43] <p6eval> niecza v22-7-g7df6137: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.StashCursor.Core (System.String key, Boolean final, Niecza.StashCursor& sc, Niecza.Variable& v, Niecza.Variable bind_to) [0x00000] in <filen…

[05:43] <diakopter> 0_0

[05:43] <diakopter> I'll stash your core cursor

[05:44] <sorear> n: no strict; moo;

[05:44] <p6eval> niecza v22-7-g7df6137: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'moo' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/…

[05:44] <sorear> n: no strict; &moo();

[05:44] <p6eval> niecza v22-7-g7df6137: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤      'moo' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 37) ␤  at /home/…

[05:44] <sorear> n: no strict; $moo();

[05:44] <p6eval> niecza v22-7-g7df6137: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.StashCursor.Core (System.String key, Boolean final, Niecza.StashCursor& sc, Niecza.Variable& v, Niecza.Variable bind_to) [0x00000] in <filen…

[05:44] <sorear> n: $::('x');

[05:44] <p6eval> niecza v22-7-g7df6137: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.StashCursor.Core (System.String key, Boolean final, Niecza.StashCursor& sc, Niecza.Variable& v, Niecza.Variable bind_to) [0x00000] in <filen…

[05:44] <sorear> n: $::('pi');

[05:44] <p6eval> niecza v22-7-g7df6137: OUTPUT«Unhandled exception: System.NullReferenceException: Object reference not set to an instance of an object␤  at Niecza.StashCursor.Core (System.String key, Boolean final, Niecza.StashCursor& sc, Niecza.Variable& v, Niecza.Variable bind_to) [0x00000] in <filen…

[05:45] <sorear> yikes

[05:49] <TimToady> pity we don't have postfix:<!> as a builtin, or it'd be easy to get a shorter timeout

[05:50] <diakopter> rn: say 2^^4&&&9||5~~3

[05:50] <p6eval> niecza v22-7-g7df6137: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤"^^" and "||" are non-associative and require parens at /tmp/gOIZ58Idw4 line 1:␤------> [32msay 2^^4&&&9||[33m⏏[31m5~~3[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die …

[05:50] <p6eval> ..rakudo dbf347: OUTPUT«2␤»

[05:50] <masak> r: say 1..*

[05:50] <p6eval> rakudo dbf347: OUTPUT«1..Inf␤»

[05:51] <masak> r: +(1..*)

[05:51] <p6eval> rakudo dbf347:  ( no output )

[05:51] <masak> r: +(1...*)

[05:51] <p6eval> rakudo dbf347:  ( no output )

[05:51] <masak> r: say +(1...*)

[05:51] <p6eval> rakudo dbf347: OUTPUT«Inf␤»

[05:51] <masak> r: say +(1,3...*)

[05:51] <p6eval> rakudo dbf347: OUTPUT«Inf␤»

[05:53] *** xinming left
[05:53] <TimToady> n: + ^Inf

[05:53] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)»

[05:55] <masak> new record.

[05:55] <diakopter> shortest program that fills p6eval output buffer

[05:55] <masak> n: (^Inf)>>.say

[05:55] <diakopter> masak: well, the original was for rakudo

[05:56] <moritz> n: say^Inf

[05:56] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)0␤1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤12␤13␤14␤15␤16␤17␤18␤19␤20␤21␤22␤23␤24␤25␤26␤27␤28␤29␤30␤31␤32␤33␤34␤35␤36␤37␤38␤39␤40␤41␤42␤43␤44␤45␤46␤47␤48␤49␤50␤51␤52␤53␤54␤55␤56␤57␤58␤59␤60␤61␤62␤63␤64␤65␤66␤67␤68␤69␤70␤71␤72␤73␤74␤75␤76␤77␤78␤79􏿽xE2

[05:56] <p6eval> niecza v22-7-g7df6137: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Unsupported use of bare 'say'; in Perl 6 please use .say if you meant $_, or use an explicit invocant or argument at /tmp/ctOiTmQHBU line 1:␤------> [32msay[33m⏏[31m^Inf[0m␤␤Unhandled exception: Check failed␤␤  at /home/p…

[05:56] <moritz> n: say ^Inf

[05:56] <p6eval> niecza v22-7-g7df6137: OUTPUT«0..^Inf␤»

[05:56] <masak> (ranges having a sensible output)++

[05:56] <masak> n: say ~^Inf

[05:56] <p6eval> niecza v22-7-g7df6137: OUTPUT«Unhandled exception: Buffer bitops NYI␤  at /home/p6eval/niecza/lib/CORE.setting line 1437 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3345 (prefix:<~^> @ 4) ␤  at /tmp/wUWOFpvH0j line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.settin…

[05:56] <masak> n: say ~ ^Inf

[05:57] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)»

[05:57] <masak> heh.

[05:57] <moritz> it tries to stringify the range before printing

[05:57] <moritz> n: say @(^Inf)

[05:57] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)»

[05:59] *** popl left
[06:01] <Woodi> hmm, any idea for ufo for C ?

[06:09] <tadzik> good morning

[06:09] <masak> tadzik! \o/

[06:09] <tadzik> masak! \o/

[06:10] *** FROGGS_ left
[06:10] <masak> we're discussing matters of the infinite.

[06:11] <tadzik> for how long?

[06:11] <tadzik> (Hahahahaha)

[06:14] <japhb> awww, ENODALEK

[06:14] *** flightrecorder left
[06:17] <masak> tadzik: all I can tell you is that so far, the discussion has never ended.

[06:19] <tadzik> eye see

[06:24] *** dalek joined
[06:24] *** ChanServ sets mode: +v dalek

[06:24] <diakopter> wb

[06:24] <sorear> I wonder why dalek exited

[06:24] *** woosley joined
[06:24] <sorear> nothing obvious on the screen

[06:25] <diakopter> EXTERMINATE

[06:27] <masak> moritz: in generalizing nested sets to DAGs, do you want multi-parent subtrees to be visited multiple times during traversal?

[06:27] <masak> or just once?

[06:28] <masak> which operations do you care about making fast?

[06:30] <diakopter> sorear: maybe some 64-bit counter rolled over on dalek

[06:34] *** rindolf joined
[06:36] <diakopter> get it?

[06:39] <sorear> no.

[06:39] <sorear> yo, rindolf

[06:39] <diakopter> a 64-bit counter can't roll over...

[06:40] <sorear> it can if the computer is poorly secured on a slope

[06:40] <diakopter> hee

[06:40] <TimToady> I want one grain on the first square, two grains on the second square, four on the third, and so on...

[06:43] <rindolf> sorear: hi.

[06:43] <diakopter> TimToady I guess I meant counting by 1

[06:44] <TimToady> my point is that a chessboard holds a lot of 1s

[06:45] *** wk joined
[06:45] <TimToady> alluding to http://en.wikipedia.org/wiki/Wheat_and_chessboard_problem

[06:51] <diakopter> and it takes a very long time to count that many by 1s

[06:52] *** flightrecorder joined
[06:53] <jnthn> morning o/

[06:53] <diakopter> o/

[06:53] <sorear> o/

[06:59] *** kurahaupo left
[07:05] <jnthn> gee, a lot of backlog

[07:07] <jnthn> phenny: tell [Coke] looking at the spectest roast data, I can't help but wonder if your Rakudo is failing to update.

[07:07] <phenny> jnthn: I'll pass that on when [Coke] is around.

[07:07] <jnthn> phenny: tell [Coke] all the S02 and S05 failures relate to features recently added to Rakudo.

[07:07] <phenny> jnthn: I'll pass that on when [Coke] is around.

[07:08] <jnthn> phenny: tell [Coke] Yes, something is wrong because a bunch of the most recent additions to t/spectest.data like S05-modifier/perl5_[2..4].t aren't being run.

[07:08] <phenny> jnthn: I'll pass that on when [Coke] is around.

[07:08] *** wk left
[07:09] <jnthn> [Coke]++ # for doing these runs

[07:11] *** fibo left
[07:11] *** xinming joined
[07:14] *** rindolf left
[07:15] *** rindolf joined
[07:15] *** Su-Shee joined
[07:15] <Su-Shee> good morning. 

[07:23] *** rurban left
[07:26] *** cognominal joined
[07:30] *** zby_home joined
[07:31] *** SamuraiJack joined
[07:36] *** brrt joined
[07:36] *** rurban joined
[07:48] *** cognominal left
[07:50] *** cognominal joined
[08:01] *** fgomez left
[08:05] *** fhelmberger joined
[08:05] <masak> how much time *does* it take, assuming some achievable counting speed by today's computers, to rol over a 64-bit counter?

[08:07] *** fhelmberger left
[08:07] <brrt> 2^64 ticks?

[08:07] <frettled> If you know it's linear counting, you can probably parallelize it a lot.

[08:07] <brrt> simplifying a bit, making a hertz a tick

[08:07] *** fhelmberger joined
[08:07] <brrt> 3ghz is 3e12 ticks

[08:08] <brrt> 2^64 = 4e6?

[08:08] <brrt> so about 3000 seconds, less than an hour i'd guess

[08:08] <diakopter> 4e6?

[08:09] <brrt> wait, thats wrong

[08:09] *** wamba joined
[08:09] <frettled> If you run it on a 1e4-core GPU (and you can still count 1/tick), it will take 10 seconds or so, then?

[08:09] <sorear> brrt: g is 1e9

[08:09] <frettled> (sounds implausible)

[08:09] <sorear> masak: most modern cpus have a 64-bit register that increments on every clock cycle

[08:10] <brrt> you get 3 orders of magnitude for every 10 orders of 2

[08:10] <sorear> useful for some timing tasks

[08:10] <masak> sorear: sounds highly useful, yes.

[08:10] <brrt> so, 2^64 =  2^4 *10^(6*3)

[08:10] <brrt> 16e18

[08:10] <sorear> if, somehow, you got a state-of-2012 Intel CPU to run continuously for 68 years, the timestamp counter would roll over

[08:11] <frettled> So use an Nvidia or AMD GPU instead.

[08:11] <sorear> er, actually it would be 136

[08:11] * jnthn has a C program running. Let's find out! :P

[08:11] <jnthn> Well

[08:11] <jnthn> Yeah, let's not

[08:11] * brrt was also writing a c program

[08:11] <diakopter> hee

[08:11] <jnthn> To get 32-bit to roll over is 4s. :)

[08:11] <sorear> frettled: parallelism does not help here, because of diakopter's scotsmanning :p

[08:11] <brrt> 16e18 / 3e9 = 5e9 seconds

[08:12] <sorear> brrt: protip: 2038 - 1970 = 2**31 seconds

[08:12] <Woodi> r: my int @a; push @a, 3;

[08:12] <p6eval> rakudo dbf347: OUTPUT«Cannot call 'push'; none of these signatures match:␤:(Any:U \SELF: *@values, Mu *%_)␤␤  in method push at src/gen/CORE.setting:1241␤  in sub push at src/gen/CORE.setting:5869␤  in block  at /tmp/Nyh_c3S2Od:1␤␤»

[08:12] <sorear> you should have 2038 burned into your mind by now

[08:12] <diakopter> sorear: yeah, sorry, you can't count by 2**64 :P

[08:12] <jnthn> r: say (1 << 32) * 4

[08:12] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤Unsupported use of << to do left shift;  in Perl 6 please use +< or ~<␤at /tmp/zooxKKq56R:1␤»

[08:12] <jnthn> r: say (1 +< 32) * 4

[08:12] <p6eval> rakudo dbf347: OUTPUT«17179869184␤»

[08:12] <sorear> also, a state of 2012 processor has a clock frequency of 2**31 +- 1

[08:12] <jnthn> r: say "{((1 +< 32) * 4) / 3600} hours"

[08:12] <p6eval> rakudo dbf347: OUTPUT«4772185.884444 hours␤»

[08:13] <frettled> sorear: well, if you increase the counter in parallel on a few thousand cores, you might just increase it a few thousand times per tick instead of just once.

[08:13] <jnthn> r: say "{((1 +< 32) * 4) / (3600 * 24 * 365.5)} years"

[08:13] <p6eval> rakudo dbf347: OUTPUT«544.0248386 years␤»

[08:13] <frettled> Just saying.

[08:13] <frettled> I don't know if that's possible with CUDA programming etc.

[08:13] * brrt can't imagine it takes that long

[08:13] <sorear> frettled: if you increase it more than once per tick, diakopter will hate you.

[08:13] <diakopter> frettled: you can't increment a memory location in parallel; if you want it incremented, you'd have to use atomic instructions anyway

[08:14] <frettled> diakopter: well, it turns out you can, if you know you're going to count _all_ the numbers from 0 to MAXINT_64.

[08:15] <frettled> diakopter: because you know that you will parallelize it, you know you can tell each of e.g. 1000 cores to start at numbers 1 through 1000, and then each increments by 1000.

[08:16] <brrt> well, it takes some time, though

[08:16] <brrt> also, clang is pretty awesome

[08:16] <diakopter> heh

[08:17] <diakopter> frettled: but you're not guaranteed they'll assign in order

[08:17] *** fgomez joined
[08:18] <brrt> r: say (5e9)/(365*24*3600)

[08:18] <p6eval> rakudo dbf347: OUTPUT«158.548959918823␤»

[08:18] <frettled> diakopter: that's not very important, the first one to reach MAX_INT_64 may get the privilege of counting from MAX_INT_64-999 to MAX_INT_64-1.

[08:18] *** cognominal left
[08:18] <sorear> brrt: told you

[08:19] <brrt> yeah, its true

[08:20] *** cognominal joined
[08:20] <masak> r: class Unit { has $.scale }; constant years = Unit.new(:scale(3600 * 24 * 365.24), :name<years>); class Seconds { has $.seconds; method as(Unit $unit) { "{$.seconds / $unit.scale} $unit.name()" } }; sub postfix:<seconds>($seconds) { Seconds.new(:$seconds) }; say ((1 +< 32) * 4)seconds.as(years)

[08:20] <p6eval> rakudo dbf347: OUTPUT«No such method 'name' for invocant of type 'Unit'␤  in method as at /tmp/x_BAPcrkRJ:1␤  in block  at /tmp/x_BAPcrkRJ:1␤␤»

[08:20] <masak> r: class Unit { has $.scale; has $.name }; constant years = Unit.new(:scale(3600 * 24 * 365.24), :name<years>); class Seconds { has $.seconds; method as(Unit $unit) { "{$.seconds / $unit.scale} $unit.name()" } }; sub postfix:<seconds>($seconds) { Seconds.new(:$seconds) }; say ((1 +< 32) * 4)seconds.as(years)

[08:20] <p6eval> rakudo dbf347: OUTPUT«544.4121085 years␤»

[08:21] <masak> \o/

[08:21] <brrt> nice

[08:21] <diakopter> that's a long-running program

[08:21] *** wamba left
[08:22] <diakopter> like, longer than computing

[08:23] <sorear> some day computing will be 1000 years old.

[08:23] <sorear> what, then, will the longest-running computation have been?

[08:24] <diakopter> quick, start one now

[08:24] <masak> clearly you're not watching enough "ancient aliens" TV shows.

[08:24] <masak> :P

[08:24] <brrt> the longest running computation?

[08:24] <brrt> the answer to the question of life, the universe, and everything

[08:24] <sorear> masak: I watched one once, it was one too many

[08:25] <masak> sorear: same.

[08:26] * jnthn just saw the reviews and was like...nah, not downloading that...

[08:26] <masak> sorear: it made intelligent design seem quite reasonable in comparison.

[08:26] <tadzik> :D

[08:27] <masak> relatedly, I've never been able to understand how The X Files show could have the tagline "I want to believe" with a straight face.

[08:28] <brrt> different times

[08:28] <masak> not that different. it was after the invention of irony, for sure.

[08:29] <masak> and I remember thinking it at the time.

[08:29] <diakopter> irony breeds rusty

[08:30] <jnthn> r: class A { method m() { eval 'say self' } }; A.m

[08:30] <p6eval> rakudo dbf347: OUTPUT«===SORRY!===␤'self' used where no object is available␤at eval_0:1␤»

[08:30] <jnthn> r: class A { method m() { $_ = 42; eval 'say $_' } }; A.m

[08:30] <p6eval> rakudo dbf347: OUTPUT«Any()␤»

[08:31] <jnthn> r: class A { method m() { try { die "in a fire" }; eval 'say $!' } }; A.m

[08:31] <p6eval> rakudo dbf347: OUTPUT«Any()␤»

[08:31] <jnthn> Hm

[08:31] <jnthn> I don't like any of those answers. :)

[08:31] <masak> moritz: re DAGs and nested sets: they don't, can't generalize cleanly. cf parsing: dividing a stream of tokens into nested sets/a parse tree. a "parse DAG" could group non-contiguous tokens, and the crucial comparison trick wouldn't work.

[08:32] <masak> moritz: of course, now that I've said that, someone is going to prove me wrong :P

[08:32] <moritz> masak: searching the internets for DAGs in SQL, I didn't find any such generalization either

[08:33] *** hoelzro|away is now known as hoelzro

[08:33] <moritz> masak: and the only saneish approach seems to be store the transitive closure of the edges (ie all paths) in the DB.

[08:33] <moritz> which is quite a stretch, that lets nested sets look like a child's toy by comparison

[08:33] <jnthn> .oO( using a graph database may just be saner...if only it were an option... )

[08:33] <moritz> jnthn: correct

[08:34] <moritz> jnthn: and if only we didn't have ~80kloc of code and how knows how many tens of millions of row that depend on the that f*cking mysql installation+schema

[08:34] <jnthn> (The Neo4j folks are based in Malmo... :))

[08:35] <jnthn> moritz: It's OK - no, *good* - to use different persistence strategies for different bounded contexts in a system...

[08:36] <moritz> well, but we don't want a context boundary at the place where the DAG comes in :(

[08:36] <jnthn> Hm.

[08:41] *** dakkar joined
[08:46] <Woodi> I remember once hearing somone was storing SQL queries in LDAP db becouse it is specialized in searches on mainly readonly, hierarchical data...

[08:47] *** wamba joined
[08:48] <brrt> if you use clang on mac os x, it is going to take a /lot/ longer than 160 hours

[08:48] <jnthn> .oO( Please say brrt isn't talking about time to compile Rakudo... )

[08:49] <brrt> 160 years, and its about the 64-bit counter thing :-)

[08:49] <jnthn> oh! :)

[08:49] <brrt> i still have to compile rakudo on this machine

[08:50] <tadzik> now roll over an int on Rakudo

[08:51] <brrt> how large is a rakudo int?

[08:51] <moritz> as large as a parrot INTVAL

[08:53] *** Celelibi left
[08:57] *** cognominal left
[08:57] <brrt> intval is, afaik, just int

[08:58] <brrt> which will compile into a 32 bit integer even on 64 bit processors

[08:59] <jnthn> Nope

[08:59] <jnthn> It's 64-bit here

[08:59] <brrt> ok, thats fair

[09:00] <brrt> int has been 32 bit on darwin on amd64 and  linux on amd64 on two occasions for me now

[09:00] <brrt> with clang and gcc both

[09:00] <sorear> brrt: INTVAL is usually intptr_t

[09:00] <jnthn> Good news: I've got eval of self and attributes to work if they're in scope

[09:00] <jnthn> Better news: that means you can inspect attributes in the debugger

[09:00] <jnthn> Bad news: I've caused some spectest fails ;/

[09:01] <sorear> parrot needs a type that will allow it to pretend pointers and integers are the same

[09:01] <arnsholt> First you make it run, then you make it right, no? =)

[09:01] <jnthn> It's not in any way clear to me why I've busted it...

[09:01] <arnsholt> Yeah, that sucks

[09:02] * jnthn tries one tweak

[09:02] *** cognominal joined
[09:02] <jnthn> ah, that fixes at least one test...

[09:03] <jnthn> multiple, actaully

[09:05] <moritz> fwiw I have a local commit that adds \A, \Z and \z to nqp's p5regex

[09:06] <jnthn> \o/

[09:06] <moritz> I just haven't yet got around to it test

[09:06] <moritz> (all the old tests still pass :-)

[09:06] <jnthn> There's quite a few in S05

[09:06] <jnthn> S05-modifier/perl5_(5 or 6 or 7).t iirc

[09:07] <jnthn> hmmm

[09:07] <jnthn>         class A61354_1 {

[09:07] <jnthn>             eval('method x { "OH HAI" }')

[09:07] <jnthn>         };

[09:07] <jnthn>         A61354_1.x;

[09:07] <jnthn> This now actually works locally

[09:07] <jnthn> We have a test that expects it to die.

[09:07] <jnthn> It works now because $?PACKAGE is correctly see to A61354_1, whereas before it was set to GLOBAL

[09:09] <jnthn> So, we passed the test due to a bug really. But...is the test actually valid?

[09:10] <jnthn> r: class A { BEGIN eval('method x { "OH HAI" }'); }; A.x

[09:10] <p6eval> rakudo dbf347: OUTPUT«Useless declaration of a has-scoped method in mainline␤No such method 'x' for invocant of type 'A'␤  in block  at /tmp/h0H0gtY6Hl:1␤␤»

[09:10] <jnthn> The patch I have makes that work, fwiw. Which seems useful.

[09:10] <masak> aye.

[09:11] <jnthn> I don't have a good way to make the one work at not the other, afaict.

[09:11] <masak> with the BEGIN, it definitely should work.

[09:11] <jnthn> *and

[09:11] <masak> hm, even without the begin, it should work.

[09:11] <masak> BEGIN*

[09:11] <jnthn> So you're arguing that the test is wrong?

[09:11] <masak> if the test expects the code to die, I argue it's wrong, yes.

[09:12] <jnthn> wfm

[09:12] * jnthn is happy to hear any other views

[09:13] <jnthn> oh...

[09:13] * masak realized during a walk today that he wants to give a talk "In Praise of Views and Models"

[09:13] <jnthn> And the other test failure I have is rather interesting too

[09:14] <jnthn> class One::Two { }

[09:14] <brrt> masak: views as in sql views?

[09:14] <jnthn> eval_dies_ok 'class One::Two { }', 'cannot redeclare an existing class';

[09:14] <jnthn> This used to work because eval always saw the current package as GLOBAL.

[09:15] <jnthn> Now it is broken because the eval call itself is done in Test, so it's checking you can declare Test::One::Two, which of course is fine.

[09:16] <sorear> sleep&

[09:16] <brrt> sleep well

[09:16] <jnthn> night, sorear 

[09:18] <masak> brrt: SQL views are one specific implementation of the more general concept. the "V" in "MVC" is another. caches and indices are another. read models in a CQRS-esque architecture are another.

[09:18] <brrt> yeah, i see what you mean

[09:18] <masak> the general theme is perhaps "derived information".

[09:19] <brrt> they are useful

[09:22] <masak> I've come to consider them to be slightly more than useful in recent months. I feel they are verging on necessary for some types of complexity. at least I don't know of any alternative way to keep complexity in check.

[09:22] <brrt> what, object oriented programming is not enough? :-p

[09:26] <masak> heh. I used to be more sceptical towards OO then I am now.

[09:26] <masak> though I still believe we're liking inheritance a little too much. call it our Platonic bias.

[09:27] * brrt is pretty sceptical towards 'conventional wisdom' than to OO in general

[09:30] <masak> I've seen some quite beautifully crafted OO systems. I've seen a lot of crap rendered as OO systems. a mediocre programmer is probably more likely to mess up an OO API than merely a procedural one. but to an experienced designer (and the system's consumers), the OO bits can be a real help.

[09:31] <moritz> in my early days of OO programming, I used to read a lot of books on OO design

[09:31] <brrt> no arguing there

[09:31] <moritz> and mostly my designs were crap

[09:32] <moritz> over-engineered and impractical

[09:32] <moritz> what worked for me is starting procedural

[09:32] <brrt> in my experience, the nicer OO design border on functional

[09:32] <brrt> s/design/designs

[09:32] <moritz> and then I tended to notice that I passed the same set of parameters to some functions

[09:33] <moritz> and then I made objects of those common parameters, and replaced the subroutine calls by method calls

[09:33] <moritz> and while the resulting design wasn't beautiful, it usually worked

[09:33] *** kenjiskywalker left
[09:33] <moritz> and slowly I'm getting more experience, and can kinda forsee what kind of objects/classes I'll need

[09:35] <masak> moritz: that's a really nice way to think of it. OOD as "emerging" out of procedural design.

[09:35] <dalek> rakudo/nom: 5a92ef1 | jnthn++ | src/Perl6/Grammar.pm:

[09:35] <dalek> rakudo/nom: Improve eval and the REPL.

[09:35] <dalek> rakudo/nom: 

[09:35] <dalek> rakudo/nom: This makes eval able to see any self that is in scope and also attributes.

[09:35] <dalek> rakudo/nom: It also means $?PACKAGE in eval will work. Furtheremore, GLOBAL now is

[09:35] <dalek> rakudo/nom: handled properly in the REPL, carried between lines rather than a fresh

[09:35] <dalek> rakudo/nom: one per line.

[09:35] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a92ef1c0e

[09:37] <moritz> jnthn: are all the enabled p5regex spectests supposed to pass?

[09:37] <moritz> 'cause I have a few failures here, and the first I looked at looks pretty much unrelated to anything that I did

[09:38] <jnthn> moritz: They've been passing here.

[09:38] <jnthn> They all pass in a current spectest run for me

[09:38] <dalek> roast: 2267094 | jnthn++ | S (2 files):

[09:38] <dalek> roast: Fix some package/eval related issues.

[09:38] <dalek> roast: 

[09:38] <dalek> roast: eval now has a better idea of current package and this can caused

[09:38] <dalek> roast: some issues for various tests that assumed that an eval would always

[09:38] <dalek> roast: start out with the current package being GLOBAL.

[09:38] <dalek> roast: review: https://github.com/perl6/roast/commit/2267094de3

[09:40] <moritz> weird, the failing tests passes in isolation

[09:40] * jnthn makes it so you can just write "self" at the debugger prompt to look at self.

[09:41] <moritz> no, related to interpolation

[09:41] <moritz> r: use Test; my $bang = "!"; is(("a!" ~~ rx:P5/((((((((((a))))))))))$bang/ && $/), "a!", "re_tests 330/0 (428)"); done;

[09:41] <p6eval> rakudo dbf347: OUTPUT«not ok 1 - re_tests 330/0 (428)␤#      got: ''␤# expected: 'a!'␤1..1␤# Looks like you failed 1 tests of 1␤»

[09:43] <moritz> r: use Test; is(("a!" ~~ rx:P5/((((((((((a))))))))))!/ && $/), "a!", "re_tests 330/0 (428)"); done;

[09:43] <p6eval> rakudo dbf347: OUTPUT«ok 1 - re_tests 330/0 (428)␤1..1␤»

[09:43] <moritz> passes without the interpolation

[09:43] <jnthn> huh, I thought all the interpolation tests were fudged

[09:43] <jnthn> You are running the fudged version of the test file, yes? :)

[09:43] <moritz> oh, my roast copy was stale

[09:44] <jnthn> oh :)

[09:44] <moritz> 'cause I ran 'make localtest' instead of 'make spectest'

[09:44] <moritz> sorry for the noise then

[09:44] <jnthn> That also explains it :)

[09:46] <moritz> The program 'perl6' is currently not installed.  You can install it by typing:

[09:46] <moritz> sudo apt-get install rakudo

[09:48] <jnthn> Wow!

[09:51] <masak> \o/

[09:52] <brrt> brew doesn't have it yet

[09:52] <moritz> (that's an off-the-shelf Ubuntu installation)

[09:53] <brrt> nice, i thought fedora contained it as well, will have to check

[09:54] *** wamba left
[09:54] <tadzik> ha, I have the same thing here

[09:54] *** wamba joined
[09:54] <tadzik> only in bash though

[09:54] *** Psyche^ joined
[09:57] *** Patterner left
[09:57] *** Psyche^ is now known as Patterner

[09:57] <tadzik> well, it'd be a lot nicer if they had something newer than 2011.07 :P

[09:58] <jnthn> oh, ouch!

[09:58] <masak> such small things matter a lot. we'll never get hard numbers of how many people will install Rakudo because of that message... but if we saw it, we'd probably consider it significant.

[09:58] <masak> oh and yes, we should make the Ubuntu people package a newer Rakudo :)

[09:58] <tadzik> I'm afraid "hey, how about we package it for you?" would be better received

[09:59] <tadzik> and I have this Ubuntu machine at work...

[09:59] <tadzik> and a PM group friend who used to maintain a PPA with rakudo and star I think

[10:00] <moritz> somehow my \Z and \z always seem to match :(

[10:02] *** cognominal_ joined
[10:04] *** cognominal left
[10:08] <jnthn> moritz: Gotta head for a meeting now, but if you're still stuck with it I can look later on

[10:10] *** anuby left
[10:14] *** cognominal__ joined
[10:14] *** cognominal_ left
[10:17] <jnthn> back in a few hours &

[10:21] *** wamba left
[10:33] *** daxim joined
[10:57] *** kaleem_ joined
[11:00] *** kaleem left
[11:00] *** gootle left
[11:04] *** wamba joined
[11:06] *** Su-Shee_ joined
[11:09] *** Su-Shee left
[11:16] *** Su-Shee_ is now known as Su-Shee

[11:24] <brrt> yay, rakudo installed w/o a hig

[11:24] <brrt> tch

[11:29] *** wamba left
[11:41] *** gerhard2 joined
[12:02] *** mikemol left
[12:04] *** mikemol joined
[12:06] *** flightrecorder left
[12:07] *** mucker joined
[12:22] *** sftp joined
[12:28] *** wamba joined
[12:29] *** flightrecorder joined
[12:33] *** wamba left
[12:36] <[Coke]> jnthn: this is not the first time rakudo has failed to update in place. I suspect I need to cut over to doing a fresh checkout each time.

[12:36] <phenny> [Coke]: 07:07Z <jnthn> tell [Coke] looking at the spectest roast data, I can't help but wonder if your Rakudo is failing to update.

[12:36] <phenny> [Coke]: 07:07Z <jnthn> tell [Coke] all the S02 and S05 failures relate to features recently added to Rakudo.

[12:36] <phenny> [Coke]: 07:08Z <jnthn> tell [Coke] Yes, something is wrong because a bunch of the most recent additions to t/spectest.data like S05-modifier/perl5_[2..4].t aren't being run.

[12:38] <[Coke]> jnthn: did a manual rebase, next run should go better.

[12:40] *** gerhard2 left
[13:01] *** fgomez left
[13:01] *** fgomez joined
[13:01] *** am0c joined
[13:03] *** hash_table joined
[13:19] *** GlitchMr joined
[13:19] *** mikemol left
[13:19] *** flightrecorder left
[13:31] *** bluescreen10 joined
[13:31] *** marloshouse joined
[13:32] *** hash_table left
[13:47] *** kaleem joined
[13:49] *** kaleem_ left
[13:49] *** Bob_ joined
[13:50] *** mikemol joined
[13:52] <arnsholt> I'm going on a research stay in Copenhagen in a bit, and it turns out it's in the same area as the Perl 6 CPH hackathon

[13:52] *** Bob_ left
[13:53] <moritz> \o/

[13:54] *** flightrecorder joined
[13:59] *** Celelibi joined
[14:04] *** flightrecorder left
[14:05] *** flightrecorder joined
[14:07] *** stopbit joined
[14:12] *** Celelibi left
[14:13] *** zamolxes_ left
[14:15] *** skids joined
[14:15] *** fgomez left
[14:15] <dalek> nqp: 56ae4f0 | moritz++ | / (3 files):

[14:15] <dalek> nqp: [p5regex] implement \A, \z and \Z

[14:15] <dalek> nqp: 

[14:15] <dalek> nqp: also add some basic tests

[14:15] <dalek> nqp: review: https://github.com/perl6/nqp/commit/56ae4f0071

[14:17] *** zamolxes joined
[14:19] <dalek> roast: 567f3ca | moritz++ | S05-modifier/perl5_8.t:

[14:19] <dalek> roast: refudge perl5_8.t for rakudo

[14:19] <dalek> roast: review: https://github.com/perl6/roast/commit/567f3cac4b

[14:20] <dalek> rakudo/nom: 547fcb3 | moritz++ | t (2 files):

[14:20] <dalek> rakudo/nom: bump NQP revision to get p5regex \A, \z and \Z

[14:20] <dalek> rakudo/nom: 

[14:20] <dalek> rakudo/nom: also enable two more test files

[14:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/547fcb3d86

[14:29] *** mikemol left
[14:29] *** PacoAir joined
[14:33] *** kaare_ joined
[14:34] *** Celelibi joined
[14:36] *** fgomez joined
[14:36] *** sqirrel joined
[14:37] * jnthn back from meeting

[14:37] *** mikemol joined
[14:38] <brrt> \o jnthn

[14:39] <jnthn> arnsholt: If you have time and wanna meet up for dinner and/or beer in Copenhagen some time while you're there, let me know. It's only 45 mins from here by train :)

[14:39] *** Celelibi left
[14:40] <arnsholt> Oooh, that's an excellent idea!

[14:40] <arnsholt> I'll be there for three weeks, so I'll definitely have to take you up on that offer

[14:40] <jnthn> moritz: wow, we got test files 7 and 8! Nice!

[14:40] <arnsholt> (I'm there from the 22nd to the 8th)

[14:41] <arnsholt> October 22nd to November 8th, that is

[14:43] <moritz> jnthn: I had to fudge one test though (that uses \G)

[14:44] *** hash_table joined
[14:46] <jnthn> \G...hmm...I even forget what that one is :)

[14:46] <arnsholt> Anchor to end of last match under /g

[14:47] <jnthn> ah

[14:48] <colomon> jnthn: I was meaning to ask the European guys around here, there's a decent chance I'll be spending a week or so in Switzerland in the near future for $work.  Dunno if anyone is close enough to visit or not, looks like all of Germany is in the way for you...

[14:49] <moritz> colomon: feel free to drop in southern Germany at my place :-)

[14:49] <jnthn> And Denmark!

[14:49] <moritz> (though we're planning to move on 2012-11-03, that might be a bit chaotic then)

[14:49] <colomon> Mind you, I have no idea where in Switzerland...

[14:50] <moritz> it's not that big :-)

[14:50] <colomon> And I don't know if I'll have any free time at all.  :)

[14:50] <jnthn> Was gonna say, Switzerland is fairly small

[14:50] <jnthn> Compared to Germany, at least

[14:50] <jnthn> And it has awesome mountains. \o/

[14:51] <brrt> and a fair train system, also

[14:51] * colomon is very much a flatlander

[14:51] <jnthn> brrt: Yes, that's also really quite good.

[14:51] <colomon> where I grew up, the next town over had a hill.  it's maybe 50 feet high.

[14:51] <arnsholt> In USian terms, Wikipedia informs me that Switzerland is somewhere between Maryland and West Virginia in area (closer to Maryland, really)

[14:52] * daxim blinks

[14:52] <jnthn> colomon: Sounds like the bit of Sweden I live in at the moment :)

[14:52] <arnsholt> Or Denmark. Switzerland is a bit more hilly, let's say =)

[14:52] <colomon> the township I lived in built an artificial hill so kids could go sledding in the winter.  :)

[14:53] <colomon> come to think of it, so did the city I live in now.  ;)

[14:57] *** att joined
[14:57] * colomon suddenly wonders about the status of his passport.

[15:02] <colomon> found!

[15:02] <colomon> and not yet expird.

[15:02] <colomon> *e

[15:11] *** Celelibi joined
[15:14] <colomon> jnthn: just parsed a 4.3 meg STEP file in 6m48s (on my Mac, which is a bit faster than the Linux box)

[15:15] <jnthn> OK, with latest Rakudo?

[15:15] *** flightrecorder left
[15:15] <jnthn> colomon: moritz's version bump should also have pulled in some code-gen improvements I did yesterday :)

[15:15] * jnthn works on teaching the debugger some more things

[15:16] *** Celelibi left
[15:16] <colomon> oooo, will try again soon...

[15:16] <jnthn> There's more I can do in the code-gen area but I've switched to debugger work for now because I've got a talk on it on Saturday and want to have moar shiny stuffs :)

[15:18] <colomon> :)

[15:20] *** MayDaniel joined
[15:20] <jnthn> I'm *so* glad I built this so I can write most of it in Perl 6 :)

[15:20] *** ruz joined
[15:23] <TimToady> colomon: note that some countries will not honor a passport with less than six months left on it

[15:24] <colomon> TimToady: that's good to know!  But I've got several years left, it turns out.

[15:26] * jnthn has until 2014, and thinks that'll conincide nicely with when he runs out of pages

[15:27] <colomon> Mine is pretty spectacularly unused, though ... I only got it so that I could continue going to Canada post-9/11, and that function is now handled by an enhanced driver's license.

[15:28] *** lostuser23 joined
[15:29] *** brrt left
[15:29] <moritz> sysadm@monitor1:~ > sudo -l

[15:29] <moritz> User sysadm may run the following commands on this host: (root) NOPASSWD: /etc/init.d/nagios3, /usr/sbin/nagios3, /usr/bin/pkill -9 nagios3, /usr/sbin/slay nagios,

[15:30] <moritz> (it seems every employer can log in as sysadm on this machine)

[15:30] <jnthn> moritz: mischannel? :)

[15:30] <jnthn> .oO( I mean, er, what's the IP?! :D )

[15:30] <moritz> jnthn: you can't :-)

[15:31] <moritz> jnthn: not mischannel; just found it funny that there are several ways to kill nagios, available to everybody at $work :-)

[15:31] <jnthn> moritz: Oh! :)

[15:31] <moritz> (and stuff is usually pretty locked down at OS level)

[15:32] <TimToady> masak: oh, I didn't answer http://irclog.perlgeek.de/perl6/2012-10-11#i_6051257 for you.  Unlike 'uniq', the putative 'dedup' has the added feature of *not* treasuring up everything in a set, since it only worries about adjacent dups

[15:32] *** thou joined
[15:33] *** lostuser23 left
[15:33] <TimToady> maybe it would be better named 'noruns' or something

[15:34] <jnthn> ...but that sounds like an anti-diarrhea product

[15:35] <TimToady> or a baseball game

[15:35] *** rindolf left
[15:36] <TimToady> well, if we build the functionality into M, then it'll be fairly rare, and we could name it something like remove-adjacent-duplicates :)

[15:38] *** MikeFair_ left
[15:40] <[Coke]> TimToady: (less than six months) That is crazy talk, sir. (but I do not dispute its truthiness)

[15:40] *** MikeFair_ joined
[15:44] <TimToady> [Coke]: the theory being that they don't want to give you a visa that is theoretically longer than your passport is good for

[15:44] <TimToady> even if you only plan to stay a week

[15:44] <[Coke]> ... they clearly need smarter visa end dating!

[15:45] <[Coke]> (dedup) coalesce? collapse? (suggestions from some of my alums)

[15:45] <TimToady> which is such a joy to deal with--see .ru

[15:45] <[Coke]> one said "oh, that's like shell's uniq" :)

[15:46] <TimToady> so maybe uniq is misnamed...

[15:47] <moritz> let's just have uniq and unique :-)

[15:47] <moritz> (with different semantic, of course)

[15:47] <[Coke]> http://docs.python.org/library/itertools.html#recipes - "unique_justseen"

[15:47] <[Coke]> meh.

[15:48] <TimToady> wait, if we distinguish Mle from Mlt, then dedup is just Mne  :)

[15:49] <TimToady> well, it's ()Mne to work on one list :)

[15:53] <am0c> To comprehend large sketch of what has been changed during years or months with perl6 and rakduo, where should I look at first?

[15:54] <[Coke]> "non-repeating" ?

[15:54] <[Coke]> am0c: do you really need to know what changed, or is just "how it is now" sufficient?

[15:55] <daxim> http://blob.perl.org/perlweb/dev/perl6/talks/2001/dconway-Perl6.pdf

[15:56] <daxim> ancient history

[15:56] <daxim> http://strangelyconsistent.org/blog/happy-10th-anniversary-perl-6

[15:56] <am0c> now may be sufficient. but I want to know tiny history just for 'months' or so.

[15:56] <daxim> recent history, but not very detailed

[15:57] <am0c> thank you so much, daxim

[15:57] <[Coke]> GlitchMr is writing up (recently only) a what's changed blog.

[15:57] <am0c> I see

[15:57] <daxim> then there are of course the changelogs of the softwares themselves

[15:59] <[Coke]> I think non-repeating is the best suggestion from the RPI crowd.

[16:00] <am0c> thank you!

[16:03] *** am0c left
[16:05] *** Celelibi joined
[16:10] *** paul3X joined
[16:11] *** kaleem left
[16:12] <paul3X> Hello, who of you use Perl on the Internet as CGI?

[16:13] <bbkr> newest version of JSON::RPC::Server uses PSGI

[16:14] <moritz> paul3X: are you asking about Perl 5 or Perl 6?

[16:14] <paul3X> moritz: Perl 5

[16:15] <moritz> paul3X: then you're a bit off-topic here

[16:15] <paul3X> moritz: ohh, I see, sorry then

[16:16] *** paul3X left
[16:21] *** hoelzro is now known as hoelzro|away

[16:25] *** tadzik left
[16:27] *** daxim left
[16:29] *** preflex joined
[16:30] *** Pleiades` left
[16:32] *** Pleiades` joined
[16:40] *** rindolf joined
[16:44] *** tadzik joined
[16:46] *** dakkar left
[16:46] <jnthn> Debugger now supports self, attribute introspection, step over a call and step out of the current routine. :)

[16:47] <ingy> jnthn: sounds ossum!

[16:47] <rindolf> jnthn++

[16:47] <jnthn> r: say 588 + 406

[16:47] <p6eval> rakudo 547fcb: OUTPUT«994␤»

[16:48] <jnthn> Total debugger implementation still under 1000 lines of code :)

[16:48] <jnthn> (first number is Perl 6, second is NQP)

[16:48] <ingy> r: say 867-5309

[16:48] <p6eval> rakudo 547fcb: OUTPUT«-4442␤»

[16:49] *** birdwindupbird left
[16:53] *** fgomez left
[16:54] *** fglock joined
[16:55] <jnthn> dinner &

[16:58] *** integral left
[17:00] *** integral joined
[17:00] *** integral left
[17:00] *** integral joined
[17:03] *** Juerd left
[17:04] *** tadzik left
[17:06] <TimToady> is it already a logged bug that niecza doesn't have @*ARGS or %*ENV at BEGIN time?

[17:07] <dalek> Perlito: b93e775 | (Flavio S. Glock)++ | / (5 files):

[17:07] <dalek> Perlito: Perlito5 - js - move Array implementation to a separate package

[17:07] <dalek> Perlito: review: https://github.com/fglock/Perlito/commit/b93e775746

[17:07] * TimToady tried to define a constant in terms of @*ARGS, anit dint werk

[17:12] *** Chillance joined
[17:13] *** topo left
[17:24] <[Coke]> [6~[6~[5~

[17:38] <colomon> jnthn: 6m48s before "member:moritz's version bump", 6m27s after.

[17:43] *** tadzik joined
[17:44] <tadzik> who killed feather? :(

[17:45] *** Juerd joined
[17:45] <tadzik> savior!

[17:46] *** fhelmberger left
[17:47] *** tadzik1 joined
[17:47] *** topo joined
[17:48] *** kaleem joined
[17:48] *** wamba joined
[17:48] *** tadzik left
[17:49] *** tadzik1 is now known as tadzik

[17:53] <[Coke]> looks like niecza got stuck in the daily run.

[17:58] *** flightrecorder joined
[17:59] * colomon pulls latest niecza and starts looking at it on Linux.

[18:04] <[Coke]> ah. wonder if someone killed the thing running the tests, but not the niecza tests themselfes, which are now running while rakudo is building.

[18:07] <jnthn> colomon: Another little improvement. Nice :)

[18:08] <colomon> indeed!  :)

[18:09] *** sivoais left
[18:11] <[Coke]> me just kills the whole daily run for today. everything was in a weird state.

[18:11] *** kaleem left
[18:12] <colomon> [Coke]: I get two test files failing in my niecza spectest run, but no hangs.

[18:16] <[Coke]> hokay. I'll do individual runs this evening to make sure it isn't likely to explode tomorrow.

[18:16] <[Coke]> colomon++

[18:21] *** sivoais joined
[18:36] *** kaleem joined
[18:39] *** kaleem left
[18:44] *** wk joined
[18:48] *** kurahaupo joined
[18:51] <dalek> roast: 12d03bf | (Solomon Foster)++ | S12-class/basic.t:

[18:51] <dalek> roast: Refudge for niecza. (new test added?)

[18:51] <dalek> roast: review: https://github.com/perl6/roast/commit/12d03bf7cd

[18:52] *** SamuraiJack left
[18:54] *** wk left
[18:54] *** tokuhiro_ joined
[18:54] *** SamuraiJack joined
[18:54] *** fgomez joined
[19:00] *** birdwindupbird joined
[19:03] <sorear> good * #perl6

[19:06] <diakopter> o/

[19:06] <colomon> o\

[19:07] <jnthn> o/

[19:08] <sorear> |o

[19:19] *** popl joined
[19:19] *** birdwindupbird left
[19:20] *** SamuraiJack left
[19:21] *** birdwindupbird joined
[19:23] <sergot_> hi o/

[19:24] <sorear> hey sergot_

[19:24] *** sergot_ is now known as sergot

[19:26] <japhb> Mmmm, fooood ...

[19:27] <jnthn> Something nice?

[19:27] <japhb> Goan.  Chicken Xacuti, Garlic Naan, rice to soak up the Xacuti ...  :-)

[19:28] <jnthn> Mmmmmm.

[19:28] <sorear> garlic nyaan

[19:28] <japhb> Can you get decent Indian-subcontinent food in Sweden?

[19:28] *** kurahaupo left
[19:28] <jnthn> Decent, yes.

[19:29] <jnthn> Quality varies, but there's some decent stuff to be had.

[19:29] <jnthn> Only a few really stand-out places I've found.

[19:29] <japhb> I remember as a youngin' having Indian food in London, and it was amazing.  I think I would miss moving away from that.

[19:29] <jnthn> Yeah, it's much easier to find great Indian-subcontinent food in the UK than here.

[19:30] <jnthn> Stockholm has some reasonable places. The one I like most is a bit out of the way from where I normally am for teaching.

[19:31] <jnthn> In Gothenburg it took me ages to find a place that was any better than average, but I eventually hit on one.

[19:31] <japhb> heh

[19:31] <japhb> Probably a fun research project.  :-)

[19:31] <jnthn> Yes :)

[19:32] <jnthn> Trouble is, since I found the good one, I didn't have another class in Gothenburg...

[19:32] <jnthn> Think I've got one or more in November.

[19:35] <jnthn> OK, question.

[19:35] <jnthn> I'm adding trace points to the Rakudo debugger

[19:35] <jnthn> They're like breakpoints, but instead of breaking, they evaluate an expression of some kind and log the result.

[19:36] *** fgomez left
[19:36] <jnthn> It's a relatively easy feature to add, but I'm not quite sure how adding/working with them wants to look.

[19:36] <diakopter> macro-ish?

[19:36] <jnthn> The breakpoint adding syntax is just

[19:36] <jnthn> bp add SomeFile:42

[19:36] <jnthn> I can do something like

[19:37] <jnthn> tp add SomeFile:42 $some_var

[19:37] <jnthn> But I'm figuring most useful is if you can do things like, say you want it logged to a file.

[19:37] <japhb> Oh, that reminds me jnthn, why do you use 'step out' instead of 'return' to mean "continue until leaving the current routine"?  (I ask because 'return' is the term I'm used to, and the one the perl5 debugger uses.)

[19:38] <diakopter> visual studio uses "step out"; eclipse uses "step return"

[19:38] <japhb> Do you have conditional breakpoints?

[19:38] <jnthn> japhb: Probably because that's (a) the term the VS debugger uses, which I'm far more used to than the perl5 one, and (b) I already used 'r' to mean "run"

[19:39] <jnthn> japhb: No, not yet. It's another "easy feature", but I can think of a good syntax for that.

[19:39] <japhb> diakopter, weird.  Maybe it's Windows v. *nix convention

[19:39] <jnthn> japhb: I'm not strongly attached to "step out".

[19:39] <japhb> jnthn, the perl5 debugger just adds it as a boolean expression after the location.  In your syntax:

[19:39] <japhb> bp add Somefile:42 $some_var > 12

[19:40] <jnthn> japhb: I was going to for for a "if" or "unless" before the condition

[19:40] <jnthn> japhb: Maybe that's just noise though

[19:40] <japhb> jnthn, I'm not attached to 'return' either, it was just curiosity.  In perl5db, 'r' is 'return', and 'c' is continue (what you seem to mean by 'run')

[19:41] <diakopter> jnthn: will the evaluation of the expression modify some global hash of counters? %*tp{'my_tp'}++

[19:41] <japhb> perl5db is a little *too* huffmanized, really.  I can't remember a debugging session in which I haven't had to use the builtin cheat sheet.

[19:41] <diakopter> if you wanted to count multiple things

[19:41] <jnthn> diakopter: No, it'll just push that evaluation onto the list of seen results

[19:42] <jnthn> diakopter: They aren't for counting

[19:42] <jnthn> They're for seeing how something changes over time.

[19:42] <sorear> japhb: gdb uses 'finish' to mean 'step until end of routine', and 'return' to mean 'inject a return statement *now* and don't run the rest of the routine'

[19:42] <japhb> 'b' for set breakpoint, 'B' for delete, for instance

[19:42] <diakopter> or, a logging watch expression

[19:42] <diakopter> *oh

[19:42] <sorear> japhb: the WebKit Javascript debugger uses 'Step In', 'Step Out', and 'Step Over'

[19:43] <jnthn> It's like print statement debugging without adding anything to the program and being able to add them dynamically

[19:43] <jnthn> japhb: Yeah, that's a little too huffmanized for me.

[19:43] <japhb> Huh.  I guess this is an opportunity for us to decide what linguistically makes the most sense for us, since there isn't a really clear precedent.

[19:43] <jnthn> japhb: That also.

[19:44] <jnthn> Mostly I want to strike a balance between not having to type too much when you learn it and learnability.

[19:44] <japhb> I like your syntax a bit better. "bp add"-style syntax is easier to remember

[19:44] <sorear> japhb: ever play with DEBUG.COM and/or the Macintosh ROM debugger?

[19:46] <japhb> Man, I'd almost forgotten the DEBUG.COM days.  Actually, I don't think I used that one much.  More of Turbo Debugger, once I started DOS programming.  Before that I was using EDTASM+ on the Color Computer, and before that ... well, I didn't really know how to use a debugger in my CP/M days.  :-)

[19:51] <colomon> CP/M!

[19:54] *** raiph joined
[19:54] <sjohnson> ahh. debug.com

[19:59] *** Patterner left
[20:03] *** grondilu joined
[20:06] *** GlitchMr left
[20:06] *** mucker left
[20:06] <flussence> it seems absurd now, but the first "programming" I ever did was on one of those game console add-on cartridges with a built in hex editor... 1kB of user code! Over 4 opcodes to choose from!

[20:07] <flussence> (fortunately I got an actual computer not long after that :)

[20:08] <moritz> it took me a while to realize that "debug.com" isn't a domain, but a DOS executable :-)

[20:08] *** am0c joined
[20:08] <jnthn> :D

[20:09] <jnthn> Conversely, when I first saw a foo.com I momentarily wondered if websites were executables... :)

[20:09] <flussence> I've come across a few that use .exe CGIs...

[20:16] *** kaare_ left
[20:16] *** zby_home left
[20:20] *** arlinius joined
[20:22] *** wamba left
[20:22] <popl> You people are old. ;P My first programmable computer was a Color Computer 2. 

[20:23] <tadzik> mine was 386, but I'm the youngest one here ;)

[20:24] <sorear> mine may also have been a 386?  all I know for sure is that it was running Windows for Workgroups 3.11 and had 8 MB of RAM

[20:24] <grondilu> my API to openssl digests (https://github.com/grondilu/openssl) do not work with binary numbers (charactrs above 128).  I can't figure out why.  If someone has an idea, feel free to leave a comment, tell me later or something.

[20:24] <tadzik> mine had 3.1, later upgraded to 3.11

[20:24] <tadzik> also, Norton Commander

[20:25] <grondilu> s/binary numbers/binary strings/

[20:26] <moritz> define "does not work"

[20:26] <moritz> does give wrong results? or segfault?

[20:26] <popl> sorear: Windows 3.1 only required a 286 so it could have been a 286.

[20:26] <popl> oh wait

[20:26] <popl> 3.11

[20:27] *** hoelzro|away is now known as hoelzro

[20:27] <popl> sorear: 386 then

[20:27] <hoelzro> hi guys

[20:27] * moritz started with 684

[20:27] <grondilu> moritz: it does not return the expected digest.

[20:28] *** wamba joined
[20:28] <popl> s/with/in/ ?

[20:28] <popl> I am joking, I do not even know you moritz. Please do not take offense. :P

[20:28] <hoelzro> so I'm trying to build a rakudo * package on Arch Linux, and during make install, nqp is complaining that it can't find Perl6/Grammar.pbc. That's probably because the PBC file has been written to a staging directory for now; is there an environment variable I can set to get nqp/parrot/whatever to look in that location?

[20:28] <moritz> erm, 486

[20:28] <moritz> popl: no offense taken

[20:29] <[Coke]> my earliest programmable computer was the atari400. (followed sooner after by the C64, the C128, and the Atari500)

[20:29] <popl> atari!

[20:29] <[Coke]> er, Amiga500. ETOOMUCHATARI

[20:29] <sorear> also, I was approximately 7 when I started playing with said 386

[20:29] <moritz> grondilu: that's because Str.chars returns number of codepoints

[20:30] <moritz> grondilu: but openssl wants the number of bytes

[20:30] <sorear> surely openssl bindings should use Buf, not Str ?

[20:31] <popl> Haha: 'also known as the A500 (or its code name "Rock Lobster")'

[20:31] <popl> [Coke]: ^

[20:31] <moritz> sorear: there's no easy way to use Buf and NativeCall together atm

[20:34] <hoelzro> is anyone able to help me with my issue building a rakudo * package?

[20:35] * grondilu modifies code to avoid using chars for buffers

[20:38] <dalek> niecza: bbf7bbd | (Solomon Foster)++ | lib/ (3 files):

[20:38] <dalek> niecza: Pull in John D. Cook's Special Functions C# module and use it to implement Real versions of gamma and expm1.

[20:38] <dalek> niecza: review: https://github.com/sorear/niecza/commit/bbf7bbd230

[20:40] <[Coke]> hoelzro: I don't understand what you mean by staging directory - how is this different from a normal build?

[20:41] <sorear> [Coke]: when you're building a .rpm or .deb, you don't want the build to affect the build system

[20:41] <sorear> [Coke]: so you do somethinkg like --prefix=$PWD/tmp

[20:42] <sorear> [Coke]: but, if the software compiles in paths (like Rakudo does), they need to be correct for a _final_ install location of /usr

[20:43] <hoelzro> right

[20:43] <hoelzro> so make install is trying to compile the debugger

[20:43] <sorear> moritz: uh oh

[20:43] <hoelzro> but Perl6/Grammar.pbc is still in $pkgdir/...

[20:46] *** kurahaupo joined
[20:48] *** zpmorgan joined
[20:50] <grondilu> even if I explicitely use $buf.elems for the length of the string made out of $buf, it still does not give the expected digest:  http://paste.siduction.org/20121011204932

[20:50] <[Coke]> so you install it where you know it doesn't go and then fixup paths later?

[20:53] <sorear> [Coke]: sounds about right

[20:56] <hoelzro> is there a way to tell NQP additional directories to search?

[20:56] <hoelzro> like PERL6LIB

[20:57] <flussence> r: say +$*IN.lines

[20:57] <p6eval> rakudo 547fcb: OUTPUT«1␤»

[20:58] <flussence> if I do "say +open('/usr/share/dict/words').lines", niecza takes 6 seconds and rakudo takes 51.

[20:59] *** sqirrel left
[21:01] *** hash_table left
[21:02] *** skids left
[21:02] <hoelzro> does anyone have a Rakudo * 2012.09 RPM/DEB spec file I could look at?

[21:02] <hoelzro> I'd really like to make a package for Arch.

[21:03] *** birdwindupbird left
[21:12] <dalek> perl6-bench: b8957ae | (Geoffrey Broadwell)++ | bench:

[21:12] <dalek> perl6-bench: Detect compiler versions at start of benchmark run

[21:12] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/b8957ae387

[21:14] <jnthn> Debugger has some basic tracepoint support now

[21:14] * jnthn thinks he probably has almost enough stuff to show in his talk on it now :)

[21:14] *** flightrecorder left
[21:16] <japhb> jnthn++

[21:16] *** hoelzro is now known as hoelzro|away

[21:17] <japhb> jnthn, have you hooked up the debugger repo to feed dalek?

[21:18] <jnthn> no

[21:18] <jnthn> Is it interesting/worthwhile?

[21:18] <japhb> I think so, yes

[21:19] <japhb> I like the warm fuzzies I get from seeing commit messages on cool projects.  :-)

[21:19] <japhb> Plus I learn a lot by clicking on diff links for interesting-sounding commits.

[21:20] <dalek> rakudo-debugger: 9bec898 | jnthn++ | lib/Debugger/UI/CommandLine.pm:

[21:20] <dalek> rakudo-debugger: Implement step over.

[21:20] <dalek> rakudo-debugger: 

[21:20] <dalek> rakudo-debugger: It takes care to try and do the right thing in the case of recursion,

[21:20] <dalek> rakudo-debugger: and recognizes when you step to a stack frame below the one you were

[21:20] <dalek> rakudo-debugger: doing a step over in, so it will pause just outside of it.

[21:20] <dalek> rakudo-debugger: review: https://github.com/jnthn/rakudo-debugger/commit/9bec89886c

[21:20] <dalek> rakudo-debugger: e2daca3 | jnthn++ | lib/Debugger/UI/CommandLine.pm:

[21:20] <dalek> rakudo-debugger: Factor out file/line pos parsing.

[21:20] <dalek> rakudo-debugger: review: https://github.com/jnthn/rakudo-debugger/commit/e2daca36cb

[21:20] <dalek> rakudo-debugger: 93a4325 | jnthn++ | lib/Debugger/UI/CommandLine.pm:

[21:20] <dalek> rakudo-debugger: Implement basic tracepoints.

[21:20] <dalek> rakudo-debugger: review: https://github.com/jnthn/rakudo-debugger/commit/93a4325c17

[21:20] *** wamba left
[21:20] <jnthn> japhb: be happy :)

[21:21] <japhb> I already am.  ;-)

[21:22] *** fgomez joined
[21:22] *** sisar joined
[21:22] <flussence> ooh, it does colour!

[21:23] *** wamba joined
[21:29] *** tokuhiro_ left
[21:32] *** fgomez left
[21:32] *** Chillance left
[21:36] <flussence> that code's a lot easier to understand than I would've imagined a debugger to be :) jnthn++

[21:38] *** thou left
[21:43] <tadzik> self.complain_about_being_dying()

[21:43] <tadzik> so existentional... ;)

[21:46] *** MayDaniel left
[21:47] <jnthn> :)

[21:47] *** cognominal_ joined
[21:47] <jnthn> sleep &

[21:48] *** cognominal__ left
[21:50] *** whiteknight joined
[21:51] *** thou joined
[21:53] *** thou left
[21:59] *** aharoni left
[21:59] *** hash_table joined
[22:02] *** bluescreen10 left
[22:03] *** fgomez joined
[22:09] *** wamba left
[22:15] *** cognominal__ joined
[22:17] *** cognominal_ left
[22:18] *** am0c left
[22:24] *** stopbit left
[22:31] *** flightrecorder joined
[22:38] *** cognominal__ left
[22:40] *** cognominal__ joined
[22:44] *** flightrecorder left
[22:45] <japhb> Opinions requested: perl6-bench is currently a monolithic 'bench' script written in Perl 5 (to minimize timing effects from Perl 6 compilers), along with a few test files and mini-docs.  However, the 'bench' script now has enough functionality in it, and more to come, that I'd like to split it into two: one script to do the core timing function, and another to do all the other things: formatting summaries, comparing multiple benchmarking r

[22:45] <japhb> uns, etc.

[22:45] <japhb> So here's the part where I'd like the opinions:

[22:46] <japhb> That core timing script pretty much has to remain Perl 5, as perl5 is the only thing that can do timings efficiently and with low enough variance.

[22:46] <japhb> But the second script could be converted to Perl 6, which would of course -Ofun considerably.

[22:48] <japhb> *However*, I hesitate a bit to do this because some of the Perl 6 compilers that perl6-bench can test (Perlito6 and I hope soon Pugs) could not compile/run modern Perl 6 code of that complexity.  So even though I can benchmark them, they wouldn't be able to run the formatting program to see the results. 

[22:48] *** cognominal__ left
[22:48] <japhb> My question is:  Is this an important enough consideration that I should leave the second script in Perl 5?

[22:48] <diakopter> why not use only one compiler for the results

[22:49] <japhb> I'm leaning towards no, since I personally want to do the results script in Perl 6, but I'm not sure.

[22:49] <japhb> diakopter, What exactly do you mean?

[22:49] *** cognominal__ joined
[22:51] <diakopter> eh

[22:51] <diakopter> I'm not sure how else to put it

[22:51] <diakopter> why not use only one compiler to run the script that formats the results?

[22:52] <japhb> Meaning, insist that e.g. Rakudo is the compiler I will assume when writing the formatting script?

[22:52] <japhb> And anything else is Not Supported (tm)?

[22:54] <diakopter> sure

[22:54] <japhb> Fairy nuff.

[22:55] <diakopter> or write in the rakudo/niecza subset intersection

[22:55] <diakopter> and support two

[22:56] <japhb> I was probably going to lean that way (supporting the intersection of the two) anyway, though I'm not above filing a bug for a feature I really want to use that's missing from one of them.  ;-)

[22:57] *** DeltaZ joined
[23:05] *** DeltaZ left
[23:11] *** grondilu left
[23:11] *** cognominal__ left
[23:21] *** cognominal__ joined
[23:26] *** grondilu joined
[23:26] <grondilu> rn: my $m = module {}; say $m.WHAT;

[23:26] <p6eval> niecza v22-7-g7df6137: OUTPUT«(timeout)[auto-compiling setting]␤»

[23:26] <p6eval> ..rakudo 547fcb: OUTPUT«<anon>()␤»

[23:27] <grondilu> weird

[23:27] * grondilu had the idea of trying that while reading S11

[23:28] <grondilu> « A named module declaration can occur as part of an expression, just like named subroutine declarations

[23:28] <grondilu> »

[23:32] *** cognominal__ left
[23:35] *** rindolf left
[23:37] *** thou joined
[23:48] *** skids joined
[23:53] *** rhr left
[23:55] *** rhr joined
