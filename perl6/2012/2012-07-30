[00:34] *** fgomez joined
[01:07] <dalek> rakudo/nom: 1d4eb48 | pmichaud++ | / (2 files):

[01:07] <dalek> rakudo/nom: Refactor unary hypers to avoid .pick(*) and for loops, resulting in a 9x speed improvement for @array>>.xyz calls.

[01:07] <dalek> rakudo/nom: 

[01:07] <dalek> rakudo/nom: Even with this level of improvement, unary hyper methods are not yet

[01:07] <dalek> rakudo/nom: faster than @array.map( *.xyz ).  This is partially due to some

[01:07] <dalek> rakudo/nom: indirect block call overhead and some unneeded boxing of native

[01:07] <dalek> rakudo/nom: values..  More improvements are forthcoming, but this is a really

[01:07] <dalek> rakudo/nom: good first step.

[01:07] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1d4eb481ef

[01:11] *** scott___ joined
[01:28] *** whiteknight joined
[01:29] *** whiteknight is now known as Guest87046

[01:35] <sergot> good night o/

[01:36] *** sergot left
[01:40] *** UncleFester6 left
[01:44] *** Ex left
[01:57] *** Guest87046 left
[02:01] *** orafu left
[02:01] *** orafu joined
[02:02] *** mucker_ joined
[02:10] *** adu left
[02:12] *** Ex joined
[02:12] *** Ex left
[02:12] *** Ex joined
[02:23] *** adu joined
[02:36] *** Psyche^ joined
[02:40] *** Patterner left
[02:40] *** Psyche^ is now known as Patterner

[02:59] *** orafu left
[02:59] *** orafu joined
[03:28] <[Coke]> S32-list/first.t uses 1...10; doesn't have to be a series, does it?

[03:31] *** mucker left
[03:32] *** mucker_ left
[03:38] *** cognominal left
[03:39] *** cognominal joined
[03:51] <TimToady> nope

[03:52] <TimToady> and wouldn't need the parens with ..

[04:10] *** fbjork joined
[04:15] *** fbjork left
[04:42] <diakopter> hm

[04:42] <TimToady> hmm, don't need them with ... either, I guess

[04:43] <TimToady> nr: my @x = 1 ... 10; say +@x;

[04:43] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«10␤»

[04:46] <diakopter> n: say my @x .. @x

[04:46] <p6eval> niecza v19-15-g051783d: OUTPUT«[]..[]␤»

[04:48] <diakopter> n: say (my @x .. @x)[0].WHAT

[04:48] <p6eval> niecza v19-15-g051783d: OUTPUT«Array()␤»

[04:49] <diakopter> n: say (my @x .. @x)[1].WHAT

[04:49] <p6eval> niecza v19-15-g051783d: OUTPUT«Any()␤»

[04:50] <TimToady> r: (my @x .. @x)[0].WHAT

[04:50] <p6eval> rakudo c1bfbb: OUTPUT«No such method 'succ' for invocant of type 'Array'␤  in sub postfix:<++> at src/gen/CORE.setting:1348␤  in method reify at src/gen/CORE.setting:4865␤  in method reify at src/gen/CORE.setting:4987␤  in method gimme at src/gen/CORE.setting:5365␤  in method exists at …

[04:51] <TimToady> r: say [] ~~ []

[04:51] <p6eval> rakudo c1bfbb: OUTPUT«True␤»

[04:51] <TimToady> r: (my @x ... @x)[0].WHAT

[04:51] <p6eval> rakudo c1bfbb:  ( no output )

[04:51] <TimToady> r: say [] ... []

[04:52] <p6eval> rakudo c1bfbb: OUTPUT«(timeout)»

[04:52] <TimToady> n: say [] ... []

[04:52] <p6eval> niecza v19-15-g051783d: OUTPUT«␤»

[04:52] <TimToady> why is rakudo not smartmatching the [] and stopping immediately?

[04:53] <TimToady> r: say [] .. []

[04:53] <p6eval> rakudo c1bfbb: OUTPUT«[]..[]␤»

[04:53] <TimToady> r: print [] .. []

[04:53] <p6eval> rakudo c1bfbb: OUTPUT«No such method 'succ' for invocant of type 'Array'␤  in sub postfix:<++> at src/gen/CORE.setting:1348␤  in method reify at src/gen/CORE.setting:4865␤  in method reify at src/gen/CORE.setting:4987␤  in method gimme at src/gen/CORE.setting:5365␤  in method print at s…

[04:53] <TimToady> and why is it looking for a .succ when (presumably) it has turned the .. into a ...?

[04:54] <TimToady> n: print [] .. []

[04:54] <p6eval> niecza v19-15-g051783d:  ( no output )

[04:54] <diakopter> o_O

[04:55] <TimToady> n: print [], *.succ ... []

[04:55] <p6eval> niecza v19-15-g051783d:  ( no output )

[04:55] <TimToady> r: print [], *.succ ... []

[04:55] <p6eval> rakudo c1bfbb: OUTPUT«No such method 'succ' for invocant of type 'Array'␤  in block  at /tmp/myIBzUnMPR:1␤␤»

[04:55] <TimToady> rakudo should be smartmaching the [] first, methinks

[04:56] <TimToady> n: print [].succ

[04:56] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: cannot increment a value of type Array␤  at /home/p6eval/niecza/lib/CORE.setting line 1414 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 272 (Mu.succ @ 9) ␤  at /tmp/8ZH84JxK3p line 1 (mainline @ 3) ␤  at /home/p6eval/niecz…

[04:56] <TimToady> yes, it's not that it's defined in niecza either, it just doesn't call it

[04:59] <diakopter> r: say [] ~~ []

[04:59] <p6eval> rakudo c1bfbb: OUTPUT«True␤»

[05:00] <diakopter> r: say ~~ [] ~~ []

[05:00] <p6eval> rakudo c1bfbb: OUTPUT«False␤»

[05:00] <diakopter> 0_0

[05:01] <diakopter> n: say ~~ [] ~~ []

[05:01] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/eFZwaDVzaB line 1:␤------> [32msay ~~[33m⏏[31m [] ~~ [][0m␤␤Parse failed␤␤»…

[05:02] <diakopter> rn: say [] ~~~ []

[05:02] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[05:02] *** quietfanatic left
[05:03] <diakopter> someone explain  r: say ~~ [] ~~ []

[05:04] <diakopter> oh nm

[05:05] <diakopter> rn: say ([] ^^ []).WHAT

[05:05] <p6eval> rakudo c1bfbb: OUTPUT«Array()␤»

[05:05] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Any␤  at /tmp/etWH_osYdY line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564…

[05:06] <diakopter> well, one of them's wrong

[05:07] <diakopter> rn: say ([] ^^^ []).WHAT

[05:07] <p6eval> niecza v19-15-g051783d: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in type Any␤  at /tmp/7eF9VXRR7v line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3929 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3930 (module-CORE @ 564…

[05:07] <p6eval> ..rakudo c1bfbb: OUTPUT«Range()␤»

[05:11] <diakopter> o__

[05:19] *** birdwindupbird joined
[05:20] *** am0c joined
[05:28] <moritz> \o

[05:28] <diakopter> o/

[05:33] <diakopter> o__ .> ___

[05:34] <moritz> is that diakopter lying down?

[05:34] <diakopter> eye closing

[05:35] <moritz> sleep well then :-)

[05:37] *** test_ joined
[05:39] *** test_ left
[05:44] *** wtw joined
[05:45] <moritz> r: <a b c d>».say

[05:45] <p6eval> rakudo c1bfbb: OUTPUT«a␤c␤d␤b␤»

[05:53] *** brrt joined
[06:14] *** brrt left
[06:18] *** xdbr joined
[06:22] *** birdwindupbird left
[06:24] *** birdwindupbird joined
[06:42] *** SamuraiJack joined
[06:44] *** kaleem joined
[06:55] *** PacoAir left
[06:59] *** drbean left
[07:00] *** drbean joined
[07:01] *** GlitchMr joined
[07:03] *** vinian joined
[07:08] *** brrt joined
[07:08] *** crab2313 joined
[07:13] *** brrt left
[07:13] <tadzik> hello #perl6

[07:17] <sjohnson> （　｀ー´）

[07:17] <moritz> \o tadzik, sjohnson 

[07:18] <sjohnson> moritz: *equivalent happy fat face emoticon*

[07:18] <sjohnson> :3

[07:24] *** hoelzro|away is now known as hoelzro

[07:35] *** cognominal left
[07:36] *** cognominal joined
[07:43] *** cognominal left
[07:44] *** cognominal joined
[07:45] *** rhr joined
[07:49] <dalek> Heuristic branch merge: pushed 217 commits to nqp/dyncall-callbacks by arnsholt

[07:49] <dalek> zavolaj/callbacks: dc43e90 | (Arne Skjærholt)++ | lib/NativeCall.pm6:

[07:49] <dalek> zavolaj/callbacks: Change to right Parameter accessor for signatures.

[07:49] <dalek> zavolaj/callbacks: review: https://github.com/jnthn/zavolaj/commit/dc43e90891

[07:49] <dalek> zavolaj/callbacks: 2680acd | (Arne Skjærholt)++ | lib/NativeCall.pm6:

[07:49] <dalek> zavolaj/callbacks: Unbreak everything.

[07:49] <dalek> zavolaj/callbacks: review: https://github.com/jnthn/zavolaj/commit/2680acda34

[07:49] <dalek> zavolaj/callbacks: 79429d9 | (Arne Skjærholt)++ | / (3 files):

[07:49] <dalek> zavolaj/callbacks: Return values from callbacks seem to work now as well.

[07:49] <dalek> zavolaj/callbacks: 

[07:49] <dalek> zavolaj/callbacks: Tests and some small tweaks to the code.

[07:49] <dalek> zavolaj/callbacks: review: https://github.com/jnthn/zavolaj/commit/79429d93b9

[07:49] <arnsholt> 217 commits? I think most of those weren't mine ^_^

[07:50] <moritz> arnsholt: probably the toqast and pirt merges

[07:50] <arnsholt> Just toqast I think

[07:50] <moritz> "Unbreak everything."

[07:50] <moritz> I like that commit

[07:50] <frettled> especially my heart

[07:50] <arnsholt> Yeah, not sure why it worked before that commit, but that's life

[07:51] <arnsholt> And since the previous commits were already there I couldn't rewrite history

[07:51] * moritz hopes frettled's comment was purely rhetorical

[07:52] <moritz> arnsholt: I know the desire for a clean history, but in the end it's in a branch anyway :-)

[07:52] <arnsholt> True true

[07:52] <arnsholt> Now, to see if pirt (what's that stand for anyways?) has any conflicts with my branch

[07:53] <moritz> PIR Tree

[07:53] <moritz> Promiscuous IR Trap

[07:53] <GlitchMr> Unbreak everything?

[07:53] <GlitchMr> But why it wouldn't work with "return"?

[07:54] <moritz> Probabilistic Intermediate Representation Transformer

[07:54] <arnsholt> GlitchMr: jnthn and pmichaud explained it to me last night (Europe time)

[07:55] <arnsholt> Since the value I'm returning isn't actually a Perl 6 object (but an NQP entity) return and falling of the end of the block are slightly different after all

[07:55] <GlitchMr> Exception catching?

[07:56] <moritz> ah yes, return is just a p6 code object

[07:56] <moritz> &return, that is

[07:56] <moritz> r: say &return.WHAT

[07:56] <p6eval> rakudo c1bfbb: OUTPUT«Block()␤»

[07:56] <GlitchMr> return is just exception behind the scenes, am I right?

[07:56] <moritz> yes

[07:58] <arnsholt> GlitchMr: http://irclog.perlgeek.de/perl6/2012-07-29#i_5858172

[07:59] *** fhelmberger joined
[08:11] *** kaleem left
[08:11] *** dudz joined
[08:15] <jnthn> morning o/

[08:15] <arnsholt> \o

[08:16] <moritz> mrnng

[08:17] <jnthn> arnsholt++

[08:18] <jnthn> Callback support seems pretty advanced. :D

[08:18] <arnsholt> You wanna review my changes before I merge it back into master?

[08:19] <arnsholt> Yeah, callbacks are looking fairly good

[08:19] <arnsholt> Wasn't ridiculously tricky to get working either, as it turns out

[08:20] <jnthn> arnsholt: If you're comfortable with it, feel free to merge

[08:20] <arnsholt> 'k

[08:20] <frettled> moritz: it was :)

[08:20] <jnthn> I'll take a look over it, but not right now... Gotta do $dayjob sometimes. ;)

[08:20] *** Chillance joined
[08:20] <frettled> moritz: </joe cocker>

[08:21] <moritz> frettled: unresolved culutural reference at frettled line *-3 :-)

[08:24] <dalek> nqp: 3a126fd | (Arne Skjærholt)++ | / (4 files):

[08:24] <dalek> nqp: Initial callback handling.

[08:24] <dalek> nqp: 

[08:24] <dalek> nqp: It works, but it'll leak memory since all the information needed to handle a

[08:24] <dalek> nqp: callback is recreated (and allocated on the heap) on each call without ever

[08:24] <dalek> nqp: being freed.

[08:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/3a126fd73a

[08:24] <dalek> nqp: 0897370 | (Arne Skjærholt)++ | src/ops/nqp_dyncall.ops:

[08:24] <dalek> nqp: Add caching of callback handling data.

[08:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/0897370953

[08:24] <dalek> nqp: fc4115b | (Arne Skjærholt)++ | / (12 files):

[08:24] <dalek> nqp: Merge branch 'master' into dyncall-callbacks

[08:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/fc4115b2d1

[08:24] <dalek> nqp: e74bc7e | (Arne Skjærholt)++ | / (37 files):

[08:24] <dalek> nqp: Merge branch 'master' into dyncall-callbacks

[08:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e74bc7ea33

[08:24] <dalek> nqp: e63f932 | (Arne Skjærholt)++ | src/ops/nqp_dyncall.ops:

[08:24] <dalek> nqp: Decontainerize callback return value.

[08:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e63f9325fd

[08:24] <dalek> nqp: ef3e3e4 | (Arne Skjærholt)++ | / (10 files):

[08:24] <dalek> nqp: Merge remote branch 'origin/master' into dyncall-callbacks

[08:24] <dalek> nqp: review: https://github.com/perl6/nqp/commit/ef3e3e4b29

[08:25] *** dakkar joined
[08:26] *** cognominal left
[08:26] *** cognominal joined
[08:27] *** kaleem joined
[08:27] <frettled> woops, I confused Toni Braxton with Joe Cocker

[08:27] <frettled> Joe Cocker had «Unchain My Heart», Toni Braxton had «Unbreak My Heart».  Both are pop hits, the latter from sometime during the nineties.

[08:28] <frettled> http://www.youtube.com/watch?v=pU2LzuVrqLQ

[08:29] <moritz> frettled: I've heard both

[08:29] <moritz> frettled: but I didn't quite make the connection

[08:30] *** nwc10 joined
[08:31] <nwc10> jnthn++

[08:34] *** sergot joined
[08:35] <hoelzro> if I'm consuming a role and I impelment a method that a role provides, is there a way to call the consumed role's version of that method from my own?

[08:35] <moritz> hoelzro: self.Role::Name::methodname(args)

[08:36] <hoelzro> moritz: thanks!

[08:36] <sergot> hi o/

[08:38] *** fgomez left
[08:40] <moritz> nwc10++ # rakudo on raspberry pi

[08:43] *** IamContagious joined
[08:43] <nwc10> but I might be -- for distracting jnthn further

[08:44] <nwc10> what I forgot to say - I've no access to other ARM systems to try to rule out different things

[08:44] <nwc10> as all the ARM boxes on the GCC compile farm are offline and have been for a while

[08:44] <moritz> nwc10: do you know how to detect ARM in perl 5 code_

[08:44] <moritz> s/_/?/

[08:44] <moritz> (for nqp's Configure.pl)

[08:45] <nwc10> you can't get that fixed upstream?

[08:45] <moritz> that would be the better approach :-)

[08:47] <nwc10> something like this would probably bodge it:

[08:47] <nwc10> $ perl -MConfig -le 'print $Config{archname} =~ /^arm[a-z0-9]*-/ ? "Y" : "n"'

[08:47] <nwc10> Y

[08:47] <nwc10> But it might trip up on armbe

[08:47] <moritz> maybe just /^arm/ ?

[08:48] <nwc10> would still trip up on armbe, but not sure how many people are using the big endian "port", or how finished it even is

[08:48] <masak> good antenoon, #perl6

[08:49] *** benabik_ joined
[08:51] <jnthn> nwc10++ # just saw the post on perl6-compiler \o/

[08:51] *** benabik left
[08:51] *** benabik_ is now known as benabik

[08:56] *** Tedd1 joined
[08:58] *** crab2313 left
[08:58] <dalek> zavolaj: 46d9cce | (Arne Skjærholt)++ | / (3 files):

[08:59] <dalek> zavolaj: Functionality and tests for callbacks.

[08:59] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/46d9cce0be

[08:59] <dalek> zavolaj: dc43e90 | (Arne Skjærholt)++ | lib/NativeCall.pm6:

[08:59] <dalek> zavolaj: Change to right Parameter accessor for signatures.

[08:59] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/dc43e90891

[08:59] <dalek> zavolaj: 2680acd | (Arne Skjærholt)++ | lib/NativeCall.pm6:

[08:59] <dalek> zavolaj: Unbreak everything.

[08:59] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/2680acda34

[08:59] <dalek> zavolaj: 79429d9 | (Arne Skjærholt)++ | / (3 files):

[08:59] <dalek> zavolaj: Return values from callbacks seem to work now as well.

[08:59] <dalek> zavolaj: 

[08:59] <dalek> zavolaj: Tests and some small tweaks to the code.

[08:59] <dalek> zavolaj: review: https://github.com/jnthn/zavolaj/commit/79429d93b9

[08:59] *** cognominal left
[08:59] *** daxim joined
[08:59] *** cognominal joined
[08:59] <arnsholt> Hmm...

[08:59] <arnsholt> r: sub foo(--> Int) returns Str { say "hi" }

[08:59] <p6eval> rakudo c1bfbb:  ( no output )

[08:59] <nwc10> at what level of parrot's toolchain does PIRT interact?

[08:59] * nwc10 is curious

[09:01] <jnthn> nwc10: PIRT produces PIR which is then fed to Parrot to get bytecode.

[09:01] <nwc10> POST also produces PIR etc?

[09:01] <jnthn> Yes

[09:01] <jnthn> PIRT is a replacement of POSt

[09:01] <jnthn> *POST

[09:02] <nwc10> direct replacement

[09:02] <GlitchMr> perl6: sub foo(--> Int) returns Str { say "hi" }; foo

[09:02] <p6eval> rakudo c1bfbb: OUTPUT«hi␤Type check failed for return value; expected 'Str' but got 'Bool'␤  in sub foo at /tmp/cRqLY1iFF9:1␤  in block  at /tmp/cRqLY1iFF9:1␤␤»

[09:02] <p6eval> ..niecza v19-15-g051783d: OUTPUT«hi␤»

[09:02] <jnthn> Fairly direct

[09:02] <GlitchMr> perl6: sub foo(--> Int) returns Str { "hi" }; foo

[09:02] <p6eval> rakudo c1bfbb, niecza v19-15-g051783d:  ( no output )

[09:02] <jnthn> The API it exposes is basically the same.

[09:02] <jnthn> The way it does stuff on the inside is quite different.

[09:02] <jnthn> And it's written in NQP, not PIR. :)

[09:03] <nwc10> it benefits from several years more experience, and 6model can lay things out more tightly in memory?

[09:03] <jnthn> Also it collapses the tree more often.

[09:04] <arnsholt> r: sub foo of Str { ... }; say &foo.signature.returns;

[09:04] <p6eval> rakudo c1bfbb: OUTPUT«Str()␤»

[09:05] <arnsholt> r: sub foo of Str returns Int { ... }; say &foo.signature.returns;

[09:05] <p6eval> rakudo c1bfbb: OUTPUT«Int()␤»

[09:05] <jnthn> With POST we built the whole tree up and turned it into PIR. PIRT can be told "this bit of the tree won't change any more", and then immediately turns that bit into PIR and throws away the more memory-intensive data structures it held onto before.

[09:05] <GlitchMr> http://duckduckgo.com/?q=say+perl

[09:06] <GlitchMr> Actually, I might attempt to make version of this for Perl 6 :P

[09:08] <daxim> please do, then blog about it

[09:08] <GlitchMr> I like DuckDuckGo and I would like it to help in Perl 6 programming too

[09:09] <GlitchMr> Possibly http://search.cpan.org/~dconway/Perl6-Perldoc-v0.0.5/lib/Perl6/Perldoc/Parser.pm will work

[09:09] <daxim> ddg have a dev kit somewhere so you can easily integrate this specialised search

[09:09] <GlitchMr> I know :P

[09:10] <daxim> U+1F44D

[09:10] <arnsholt> jnthn: Would throwing an exception in trait_mod:<of>/trait_mod:<is> be the best solution to handle setting the return type of something that already has one?

[09:10] <GlitchMr> Except that parser fails tests

[09:10] <GlitchMr> so no

[09:10] <jnthn> arnsholt: Yes, and moritz++ would probably like it if it were a typed exception ;-)

[09:12] <GlitchMr> Or this: http://search.cpan.org/dist/Perl6-Pod/lib/Perl6/Pod.pm

[09:13] <GlitchMr> ... possibly this will work

[09:13] <tadzik> GlitchMr: or just doc.perl6.org, maybe

[09:13] <tadzik> we have our own Pod renderer and a doc infrastructure built around it

[09:13] <GlitchMr> Hmm... ok :)

[09:14] <GlitchMr> But parsing doc.perl6.org could be problematic

[09:14] <GlitchMr> It's HTML file

[09:16] <jnthn> But it's produced from Pod, no?

[09:17] <GlitchMr> Hmmm... parsing it would be possible

[09:18] *** nwc10 left
[09:18] <tadzik> I don't think that reparsing formatted Pod is the right way to do it:)

[09:18] *** cognominal_ joined
[09:19] <moritz> GlitchMr: htmlify.pl in the perl6/doc repo is what generates the HTML files on doc.perl6.org

[09:19] <GlitchMr> It's Perl 5 script?

[09:19] <GlitchMr> ... oh, Perl 6

[09:20] <GlitchMr> Well, it probably will be Fathead, just like Perl 5 documentation :)

[09:21] *** cognominal left
[09:22] <moritz> the Pod in perl6/doc is pretty basic

[09:23] <moritz> I guess existing p5 based parsers for it can easily work for it too

[09:25] <arnsholt> Hmm. Can I throw exceptions and such from methods added in BOOTSTRAP.pm?

[09:25] <jnthn> Not easily

[09:26] <jnthn> Not typed ones at least

[09:26] <arnsholt> Right. Problem is that Signature.set_returns, which the trait_mods use to set the return type is defined there

[09:27] *** brrt joined
[09:28] <arnsholt> I suppose I could just diddle the object directly with nqp:: stuff in traits.pm

[09:29] *** MayDaniel joined
[09:29] <jnthn> What exactly do you need to do?

[09:30] <arnsholt> I need to check whether the $!returns attribute of the Signature is set (current idea is nqp::defined(nqp::getattr(...))) and throw an exception if it is set

[09:30] <moritz> uhm

[09:30] <moritz> $!returns will hold a type, yes?

[09:31] *** kaleem left
[09:31] <moritz> if so, it's not defined

[09:31] <arnsholt> Yes. I was hoping nqp::defined was on the level below that

[09:31] <arnsholt> =)

[09:31] *** kaleem joined
[09:31] <moritz> r: nqp::say nqp::defined :(--> Int).returns

[09:31] <p6eval> rakudo c1bfbb: OUTPUT«0␤»

[09:31] <arnsholt> But yeah, that's another problem

[09:31] <moritz> r: nqp::say nqp::isnull :(--> Int).returns

[09:31] <p6eval> rakudo c1bfbb: OUTPUT«0␤»

[09:31] <moritz> r: nqp::say nqp::isnull :().returns

[09:31] <p6eval> rakudo c1bfbb: OUTPUT«0␤»

[09:31] <arnsholt> Well darn

[09:31] <moritz> I guess whatever comes from .returns (which is a p6 level method) can never be null

[09:32] <moritz> r: nqp::say nqp::isnull nqp::getattr(:(), Signature, '$!returns')

[09:32] <p6eval> rakudo c1bfbb: OUTPUT«1␤»

[09:32] <moritz> r: nqp::say nqp::isnull nqp::getattr(:(--> Int), Signature, '$!returns')

[09:32] <p6eval> rakudo c1bfbb: OUTPUT«0␤»

[09:32] <arnsholt> There we go

[09:32] <moritz> ok, nqp::isnull works for you

[09:35] <arnsholt> Indeed. Testing with just die and a string now

[09:35] <arnsholt> Then I'll go looking for a nice typed exception I can use =)

[09:36] <moritz> you could abuse X::Redeclaration for that

[09:36] <arnsholt> Yeah. Sounds good

[09:37] <moritz> X::Redeclaration.new(what => 'return type for', symbol => &theroutine, postfix => " (previous return type was {$prevtype.^name}").throw

[09:37] <moritz> or so

[09:37] <arnsholt> Buh, "Can not get non-existent attribute '$!returns' on class 'Signature'"?

[09:37] <moritz> did you decontainerize?

[09:37] <moritz> and is Signature fully set up already?

[09:38] <arnsholt> Oh, that's it perhaps

[09:38] <arnsholt> traits.pm is before Signature.pm in the list, so it might not be set up properly?

[09:38] <moritz> the funs of bootstrapping

[09:39] <moritz> isn't Signature set up in BOOTSTRAP.pm?

[09:39] <moritz> if so, that shouldn't be the problem

[09:39] <jnthn> That error is pretty much always a failure to decontainerize

[09:39] <arnsholt> Hmm. Troo

[09:39] <jnthn> Or you're passing an object of the wrong type in

[09:39] <arnsholt> Oh, durr. I didn't decontainerize the string

[09:39] *** SamuraiJack left
[09:41] *** MayDaniel left
[09:41] <arnsholt> Although from other nqp::getattrs that doesn't seem to be required?

[09:41] <moritz> it always depends what you work on

[09:42] <arnsholt> Aha

[09:42] <moritz> if you work on a variable to which you have bound an object (and not another variable, and not assigned), you don't need to decontainerize

[09:43] <moritz> erm, to to rephrase, you only need to decont if there's actually a container

[09:43] *** GlitchMr left
[09:43] *** bbkr joined
[09:43] <arnsholt> It's just nqp::getattr(decont($obj), Signature, '$!returns') which should be ok, no?

[09:43] <moritz> yes

[09:44] <moritz> nqp::decont

[09:44] <moritz> nqp::p6decont akshually

[09:46] *** SamuraiJack joined
[09:49] <arnsholt> Not pir::perl6_decontainerize? Looks like that's what most of the rest of the code uses

[09:50] <jnthn> That wants updating (and probably can be now).

[09:50] <jnthn> Oh, unless you mean in BOOTSTRAP.pm

[09:50] <arnsholt> No, this is traits.pm

[09:51] <jnthn> Then nqp::p6decont is preferable

[09:51] <arnsholt> I'll have a whack at that after lunch then

[09:51] <arnsholt> noms &

[10:08] *** scott___ left
[10:10] *** vinian left
[10:10] <dalek> rakudo/nom: 3a20b76 | moritz++ | / (2 files):

[10:10] <dalek> rakudo/nom: remove some deprecated subs and methods

[10:10] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3a20b76b46

[10:12] *** mucker joined
[10:23] *** colomon joined
[10:28] *** GlitchMr joined
[10:29] *** cognominal_ left
[10:29] *** cognominal_ joined
[10:33] *** gongyiliao left
[10:45] <arnsholt> Hmm. Still can't get non-existent attribute, even when I p6decont all the things

[10:45] <jnthn> What's the code look like?

[10:46] <arnsholt> my $returns := nqp::getattr(nqp::p6decont($target), nqp::p6decont(Signature), nqp::p6decont('$!returns')); # decont all the things

[10:46] <arnsholt> From similar code elsewhere, it looks like only decont($target) should be necessary

[10:47] *** cognominal_ left
[10:47] <jnthn> What is $target?

[10:47] <arnsholt> Routine:D $target

[10:47] <jnthn> Right, so you need $target.signature, no?

[10:48] <arnsholt> Durr. That might be it >.<

[10:48] <arnsholt> Of course =)

[10:48] *** cognominal_ joined
[10:48] <tadzik> "What is $target?" -- Routine :D

[10:49] *** spider-mario joined
[10:49] <arnsholt> Yeah, I like that particular bit of syntax =)

[10:49] <tadzik> r: sub a(LoL:D) { }; say &a.signature.perl

[10:49] <p6eval> rakudo c1bfbb: OUTPUT«:(LoL:D )␤»

[10:49] <tadzik> p6eval: what's so funny?

[10:51] <jnthn> Lunch &

[10:53] <flussence> does Cat operate non-recursively? if so, would that make a recursive one a LoLCat?

[10:55] <tadzik> /o\

[10:56] <tadzik> r: class Cat {}; sub a(Lol:D, Cat:D) {}; say &a.signature.perl

[10:56] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Invalid typename in parameter declaration at line 2, near ", Cat:D) {"␤»

[10:56] <tadzik> r: class Cat {}; sub a(Lol:D, Cat) {}; say &a.signature.perl

[10:56] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Invalid typename in parameter declaration at line 2, near ", Cat) {};"␤»

[10:56] <tadzik> r: class Cat {}; sub a(Lol:D $a, Cat $b) {}; say &a.signature.perl

[10:56] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Invalid typename in parameter declaration at line 2, near " $a, Cat $"␤»

[10:57] <tadzik> oh

[10:57] <tadzik> r: class Cat {}; sub a(LoL:D $a, Cat $b) {}; say &a.signature.perl

[10:57] <p6eval> rakudo c1bfbb: OUTPUT«:(LoL:D $a, Cat $b)␤»

[10:57] <tadzik> r: class Cat {}; sub a(LoL:D, Cat) {}; say &a.signature.perl

[10:57] <p6eval> rakudo c1bfbb: OUTPUT«:(LoL:D , Cat )␤»

[10:58] *** adu left
[10:58] <flussence> oh nice, nqp/master just built without needing -G on the stage1 bit. Just needs the stage2 to work now...

[11:08] *** JimmyZ_ joined
[11:13] <arnsholt> moritz: With your exception snippet, I get "Redeclaration of return type for  (previous return type was Str)". Should :symbol be &target.name or something like that instead?

[11:15] <masak> .u 😶

[11:15] <phenny> U+1F636 (No name found)

[11:15] <arnsholt> Oh, never mind. I think I just typoed it

[11:16] <arnsholt> jnthn++ # Spotting my brainos

[11:20] <arnsholt> WTF? My code works for of, but if I add it to returns compiling the setting segfaults.

[11:24] <arnsholt> jnthn: Segfault is in container.c, so I'm guessing it's a rakudobug?

[11:26] <arnsholt> Oooh, fun. STABLE(var) (container.c:20) is 0x1

[11:28] <jnthn> arnsholt: Only if you can reproduce it when you ain't using nqp:: ops and stuff :)

[11:28] <jnthn> arnsholt: What is var?

[11:28] <jnthn> Does it claim to be a 6model object?

[11:28] <jnthn> (look at the v-table)

[11:30] *** colomon left
[11:32] <arnsholt> Looks like it isn't a sixmodel object, yeah. Vtable looks like it's all Parrot_default_*

[11:33] <arnsholt> Although shouldn't my variable be a sixmodel thing when it's multi trait_mod:<returns>(Routine:D $target, Mu:U $type) { ... }?

[11:33] <jnthn> Looks like it sneaked in somewhere that we don't have a check that it really is one

[11:34] <jnthn> Should be

[11:34] <moritz> arnsholt: ah, yes, &sym.name

[11:35] <arnsholt> moritz: Actually that wasn't necessary. The problem was that I had &target where it should've been $target

[11:39] <arnsholt> jnthn: Any ideas for the best way to track down the error?

[11:41] <masak> r: say [] ... []

[11:41] <p6eval> rakudo c1bfbb: OUTPUT«(timeout)»

[11:41] * masak submits rakudobug

[11:41] <masak> <TimToady> why is rakudo not smartmatching the [] and stopping immediately?

[11:42] <moritz> wait

[11:42] <masak> n: say [] ... []

[11:42] <p6eval> niecza v19-15-g051783d: OUTPUT«␤»

[11:42] <moritz> it doesn't even generate list elements

[11:42] <moritz> it's in sink context

[11:42] <moritz> so it must loop in the detection stage somewhere

[11:42] <masak> ...still a bug...

[11:42] <moritz> yes

[11:45] *** birdwindupbird left
[11:48] <moritz> r: say [] ~~ []

[11:48] <p6eval> rakudo c1bfbb: OUTPUT«True␤»

[11:53] *** colomon joined
[11:59] <colomon> o/

[11:59] * colomon is back from the great white north

[11:59] <moritz> r: [] ... []

[11:59] <p6eval> rakudo c1bfbb:  ( no output )

[12:00] <moritz> ok, I was wrong, just missed to see the say

[12:00] <moritz> wb colomon 

[12:00] <colomon> moritz: thanks!

[12:00] <colomon> did qast go live in rakudo master while I was gone?

[12:01] <moritz> colomon: yes

[12:01] <colomon> I see someone beat me to building rakudo on Raspberry Pi... (mine arrived while I was gone)

[12:01] <moritz> PIRT (a replacement for POST written in NQP) also landed

[12:01] <moritz> now compiling the setting just takes ~1GB virtual memory

[12:02] <masak> hm, Doug Crockford uses 'closure' (in the CS sense) as a mass noun.

[12:02] *** mtk joined
[12:03] <arnsholt> masak: Wuh? That's a bit odd, innit?

[12:03] *** cotto left
[12:03] *** cotto joined
[12:05] <masak> it's a little intriguing.

[12:05] <masak> it makes it an *effect*, not a *thing*.

[12:05] <masak> he does it very consistently at http://www.youtube.com/watch?v=ya4UHuXNygM

[12:10] *** skids left
[12:11] <masak> I have never encountered this usage before. I wonder where he got it from. I know he's very history-savvy.

[12:12] <GlitchMr> function foo() {} expands to var foo = undefined; foo = function foo() { };

[12:12] <GlitchMr> sure...

[12:12] <moritz> GlitchMr: anything wrong with that statement?

[12:13] <cognominal_> what the T stands for in PIRT?

[12:13] <cognominal_> translation?

[12:13] <moritz> cognominal_: tree

[12:13] <cognominal_> ha! moritz++

[12:14] <GlitchMr> moritz: http://jsfiddle.net/JZqUN/

[12:14] <GlitchMr> It's more complex than Crockford has said

[12:14] <cognominal_> I forgot where the nqp:: are translated into their PIR equivalent

[12:15] <jnthn> src/QAST/Operations.nqp 

[12:16] <GlitchMr> var foo = function foo() {} is not function foo() {}

[12:16] <cognominal_> jnthn++

[12:17] <GlitchMr> In case of function statement, its moved to top as whole (with function itself).

[12:17] <GlitchMr> But with var, only declaration itself is moved to top

[12:18] <cognominal_> that's  add_core_pirop_mapping?

[12:19] <jnthn> cognominal_: That declares the translation, yes.

[12:19] <cognominal_> sounds like a nice cleaning of stuff that was elsewhere

[12:20] <cognominal_> nice to see the decoupling from PIR get cleaner

[12:24] <masak> GlitchMr: but that's exactly what Crockford says in that talk.

[12:26] * moritz has trouble not to understand "pseudo" as "sudo", his "p" is so soft :-)

[12:26] <moritz> r: say try die "foo"

[12:27] <p6eval> rakudo c1bfbb: OUTPUT«foo␤  in block  at /tmp/8E2QgHAkB0:1␤␤»

[12:29] <timotimo> strange. i was sure pseudo was supposed to sound just like sudo

[12:30] <hoelzro> some people pronounce it 'soo-doo'

[12:30] <arnsholt> Depends I think. The French pronounce it (and Greek words in ps- in general) with clear p and s

[12:30] <hoelzro> sudo, that is

[12:33] <moritz> jnthn: I'm curious, why do print, say etc. get a :pure(1) mark in QAST::Operations?

[12:33] <moritz> they don't look very pure to me

[12:34] <jnthn> moritz: This is why I didn't really like the name "pure"

[12:34] <jnthn> moritz: It really means "can inline without it causing problems"

[12:35] <moritz> what are examples of non-"pure" ops in that sense?

[12:35] <jnthn> call

[12:35] <jnthn> Calls involve a lexical lookup of the thing we wish to dispatch to.

[12:36] <jnthn> And thus transplanting it into the caller's scope could yield very different results.

[12:36] <moritz> but currently the :pure thing isn't even stored, right?

[12:36] <jnthn> No

[12:36] <jnthn> That's the next step. :)

[12:37] <arnsholt> jnthn: Is there a Perl6-accesible way to figure out if what I have in a variable actually is a sixmodely thing?

[12:38] <moritz> try $thing.WHAT; if $! { say "no 6model" }

[12:38] <jnthn> That kind of introspection is rather discouraged.

[12:39] <jnthn> nqp::p6type(...) will make the thing you have safe.

[12:39] <jnthn> Or at least, should.

[12:39] <arnsholt> Well yeah, but since my problem is that I get a non-sixmodely thing the easiest way to figure out where it comes from I'm thinking is to check in Perl 6 and die if it isn't

[12:39] <[Coke]> nwc10++

[12:40] <jnthn> arnsholt: Ah, if it's just for debugging then try what moritz++ said then.

[12:40] <moritz> arnsholt: if you want to die anyway, just do $thing.WHAT

[12:40] <moritz> r: say pir::set__Ps('foo').WHAT

[12:40] <p6eval> rakudo c1bfbb: OUTPUT«Null PMC access in set_string_native()␤  in block  at /tmp/YguO1tSq4t:1␤␤»

[12:41] <arnsholt> Cool. Trying that now

[12:41] <moritz> r: my $x := pir::new__Ps('String'); $x.WHAT

[12:41] <p6eval> rakudo c1bfbb: OUTPUT«Can only use get_what on a SixModelObject␤  in block  at /tmp/qcqWMeMeql:1␤␤»

[12:48] <arnsholt> Bah. Still segfaults if I add $target.signature.WHAT before the call

[12:50] <moritz> r: QAST::Operations.add_core_pirop_mapping('exit', 'exit', '0i', :pure(1));

[12:50] <p6eval> rakudo c1bfbb: OUTPUT«Could not find symbol '&Operations'␤  in method <anon> at src/gen/CORE.setting:9629␤  in <anon> at src/gen/Metamodel.pm:2304␤  in any find_method_fallback at src/gen/Metamodel.pm:2302␤  in any find_method at src/gen/Metamodel.pm:843␤  in <anon> at src/gen/BOOTSTRAP…

[12:50] <moritz> sorry, miss-copy

[12:50] <moritz> r: say Date.new('2012-12-24').truncated-to(:week)

[12:50] <p6eval> rakudo c1bfbb: OUTPUT«2012-12-24␤»

[12:51] <moritz> r: say Date.new('2012-12-24').day-of-week

[12:51] <p6eval> rakudo c1bfbb: OUTPUT«1␤»

[12:52] <dalek> doc: ea27baf | moritz++ | lib/Date.pod:

[12:52] <dalek> doc: [Date] document truncated-to

[12:52] <dalek> doc: review: https://github.com/perl6/doc/commit/ea27baf409

[12:53] *** MayDaniel joined
[12:53] <felher> Anyone here to review and maybe even apply the following rakudo patch: https://gist.github.com/3206000 . I attached a spectest log and the output of the two failing tests. I don't think the failing tests have anything todo with my patch.

[12:56] <moritz> r: BEGIN { @*ARGS.push: '--foo' }; sub MAIN() { }

[12:56] <p6eval> rakudo c1bfbb: OUTPUT«Unexpected named parameter 'foo' passed␤  in sub MAIN at /tmp/yfkqRKz8X5:1␤  in block  at /tmp/yfkqRKz8X5:1␤␤»

[12:57] *** PacoAir joined
[12:57] <moritz> felher: and the patch changes that to instead print the usage message?

[12:57] * moritz compiles it

[12:57] <felher> moritz: yeah. It works on my machine.

[12:59] <daxim> the rakudo deatch star has TWO lazzz0rs? impressive.

[13:05] <dalek> rakudo/nom: f4b83df | moritz++ | tools/build/NQP_REVISION:

[13:05] <dalek> rakudo/nom: bump NQP revision to get dyncall callbacks, arnsholt++

[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4b83df6d7

[13:05] <dalek> rakudo/nom: 705fabb | (Felix Herrmann)++ | src/core/Main.pm:

[13:05] <dalek> rakudo/nom: make Main.pm output a usage message on an unexpected named argument instead of bind failing

[13:05] <dalek> rakudo/nom: 

[13:05] <dalek> rakudo/nom: Signed-off-by: Moritz Lenz [email@hidden.address]
[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/705fabb531

[13:05] <felher> \o/

[13:05] <felher> moritz++: thnx

[13:06] <dalek> roast: 9ca79dd | moritz++ | S06-other/main-usage.t:

[13:06] <dalek> roast: test that MAIN + unexpected named args trigger USAGE message

[13:06] <dalek> roast: review: https://github.com/perl6/roast/commit/9ca79dd711

[13:06] *** IamContagious left
[13:10] *** kaleem left
[13:15] *** atrodo joined
[13:26] *** bluescreen10 joined
[13:26] <cognominal_> what is a "local variable" in QAST?

[13:27] *** PacoAir left
[13:27] *** benabik left
[13:27] *** PacoAir joined
[13:27] *** benabik joined
[13:27] *** drbean left
[13:27] <cognominal_> local versus lexical does not say much about what is local

[13:28] *** thou joined
[13:29] *** drbean joined
[13:34] <diakopter> cognominal_: afaik, local translates to a PIR local register; lexical transates to a PIR find_lex from lexical to register, store_lex from register to lexical

[13:35] <diakopter> I assume you're talking about :scope on QAST::Var

[13:37] <cognominal_> ok. so I should see the PIR doc. thx. diakopter++

[13:37] <diakopter> well, if you want the variable to be able to be used in closures taken from the block you're in, use a lexical.. otherwise, local.

[13:39] *** kaleem joined
[13:40] *** brrt left
[13:40] <cognominal_> "The C<.local> directive indicates that the named register is only needed inside the current subroutine (that is, between C<.sub> and C<.end>)."

[13:42] <diakopter> what about it? :)

[13:42] <cognominal_> well, I just cite the doc.

[13:43] <cognominal_> which confirms what you just said

[13:43] *** skids joined
[13:47] <pmichaud> good morning, #perl6

[13:47] <colomon> \o

[13:48] <hoelzro> morning pmichaud 

[13:49] <[Coke]> pmichaud: hio

[13:49] <moritz> good am, pm

[13:50] * [Coke] wonders what the perl6 folks attending yapc::eu are going to do. Take over the cafeteria or something?

[13:50] <[Coke]> Just have a week long hackathon?

[13:51] <moritz> I might not attend (though not because of the talks, but rather because of timing issues)

[13:51] <moritz> it's not decided yet

[13:51] <moritz> [Coke]: in Pisa (2010) we had an inofficial p6 hallway track :-)

[13:52] *** fhelmberger left
[13:53] <pmichaud> [Coke]: I have no idea.  I'm guessing we'll figure something out.

[14:02] <moritz> nr: say (a => 42)<a>

[14:02] <p6eval> rakudo c1bfbb: OUTPUT«42␤»

[14:02] <p6eval> ..niecza v19-15-g051783d: OUTPUT«Unhandled exception: Cannot use hash access on an object of type Pair␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 354 (Any.at_key @ 9) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/wwCIi9OKlQ line 1 (mainli…

[14:05] <dalek> doc: 5a88982 | moritz++ | lib/Associative.pod:

[14:05] <dalek> doc: document Associative

[14:05] <dalek> doc: review: https://github.com/perl6/doc/commit/5a8898246f

[14:05] <dalek> doc: 8ea8a99 | moritz++ | lib/X/Comp.pod:

[14:05] <dalek> doc: X::Comp (needs more work)

[14:05] <dalek> doc: review: https://github.com/perl6/doc/commit/8ea8a9964e

[14:10] *** cognominal_ left
[14:10] <jnthn> o/ pmichaud 

[14:11] <pmichaud> o/ jnthn

[14:11] *** cognominal joined
[14:11] * pmichaud works outdoors in the 30degC weather

[14:13] <pmichaud> today's forecast is 40degC, though :-(

[14:13] <jnthn> ouch :/

[14:13] <jnthn> Today we finally got some rain, which has made things less stuffy.

[14:13] * jnthn focuses on $dayjob stuff again for a bit

[14:15] <moritz> nrp: say ?all()

[14:15] <p6eval> pugs: OUTPUT«all()␤»

[14:15] <p6eval> ..rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[14:16] <moritz> nrp: say ?none()

[14:16] <p6eval> pugs: OUTPUT«none()␤»

[14:16] <p6eval> ..rakudo c1bfbb, niecza v19-15-g051783d: OUTPUT«True␤»

[14:17] *** MayDaniel left
[14:28] *** MayDaniel joined
[14:34] *** fr0g joined
[14:35] <dalek> doc: 4296057 | moritz++ | TODO:

[14:35] <dalek> doc: update TODO

[14:35] <dalek> doc: review: https://github.com/perl6/doc/commit/4296057d0f

[14:37] *** wtw left
[14:38] *** dudz left
[14:42] *** jerome left
[14:43] *** jerome joined
[14:44] *** cognominal left
[14:44] *** cognominal joined
[14:49] <dalek> doc: dbc6f4e | moritz++ | / (2 files):

[14:49] <dalek> doc: Junction

[14:49] <dalek> doc: review: https://github.com/perl6/doc/commit/dbc6f4e756

[14:49] <dalek> doc: 7ef8834 | moritz++ | / (2 files):

[14:49] <dalek> doc: remove TODO

[14:49] <dalek> doc: 

[14:49] <dalek> doc: instead add a script which shows missing types, using type-graph.txt as reference

[14:49] <dalek> doc: review: https://github.com/perl6/doc/commit/7ef8834e1b

[14:52] <pmichaud> moritz++ # docs

[14:53] <moritz> has anybody check if p6doc works with star?

[14:53] <moritz> *checked

[14:54] <pmichaud> not me

[14:56] <moritz> fascinating. It seems that Num has no methods except those provided by roles or superclasses

[14:57] <dalek> doc: beb5d73 | moritz++ | lib/Num.pod:

[14:57] <dalek> doc: Num

[14:57] <dalek> doc: review: https://github.com/perl6/doc/commit/beb5d730ce

[14:58] *** birdwindupbird joined
[15:00] <dalek> doc: e951297 | moritz++ | lib/Int.pod:

[15:00] <dalek> doc: [Int] method/sub chr

[15:00] <dalek> doc: review: https://github.com/perl6/doc/commit/e951297e71

[15:01] <moritz> I find that I don't live under the constant fear that the majority of the docs will be obsolete soon

[15:01] <moritz> (though I also avoid documenting stuff of which I suspect that it'll go away)

[15:04] <[Coke]> r: say .chr()

[15:04] <p6eval> rakudo c1bfbb: OUTPUT«No such method 'chr' for invocant of type 'Any'␤  in block  at /tmp/Ljf5v_vjEL:1␤␤»

[15:04] <[Coke]> r: say Int.chr()

[15:04] <p6eval> rakudo c1bfbb: OUTPUT«Parameter '' requires an instance, but a type object was passed␤  in method chr at src/gen/CORE.setting:2764␤  in block  at /tmp/JJWAox2GHx:1␤␤»

[15:10] <moritz> r: say v1.0.*

[15:10] <p6eval> rakudo c1bfbb: OUTPUT«v1.0.*␤»

[15:10] <moritz> r: say v1.0.*+

[15:10] <p6eval> rakudo c1bfbb: OUTPUT«v1.0.*+␤»

[15:11] <moritz> r: say v1.alpha.*+

[15:11] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/kcCtr07_Y1:1␤»

[15:12] <moritz> r: say v

[15:12] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&v' called (line 1)␤»

[15:17] *** kaleem left
[15:18] <masak> why is v1.0.*+ allowed?

[15:18] <masak> I mean, what does it add on v1.0.0+ ?

[15:19] <moritz> just no reason to forbid it

[15:20] <dalek> doc: 7a00159 | moritz++ | lib/Version.pod:

[15:20] <dalek> doc: document Version (missing: method new)

[15:20] <dalek> doc: review: https://github.com/perl6/doc/commit/7a001592b5

[15:21] <pmichaud> ...versions can contain alphas

[15:21] <pmichaud> ah, it says "version literals". never mind.

[15:22] <moritz> which is why it would be important to document method new

[15:22] <moritz> because it's currently the only way to create versions with alphas

[15:22] <pmichaud> yup

[15:22] <pmichaud> .new just takes a string and makes a version out of it :-)

[15:22] <pmichaud> I can work on that one.

[15:25] * moritz thinks that the docs for Whatever will be fun to write

[15:26] <moritz> in general, I've tried to include language features that relate to a type in the documentation for that type

[15:26] <moritz> ie autothreading is documented in Junction.pod

[15:26] <moritz> so Whatever.pod would explain Whatever-currying

[15:27] <moritz> but I wouldn't go so far to document grammars in Grammar.pod :-)

[15:31] *** p6eval left
[15:31] <dalek> doc: 1e8e00f | pmichaud++ | lib/Version.pod:

[15:31] <dalek> doc: Add draft of method 'new'.

[15:31] <dalek> doc: review: https://github.com/perl6/doc/commit/1e8e00f22a

[15:33] *** dalek left
[15:33] *** Juerd left
[15:35] *** pmichaud left
[15:37] *** tadzik left
[15:38] *** dalek joined
[15:38] *** ChanServ sets mode: +v dalek

[15:38] *** Juerd joined
[15:38] *** Util left
[15:38] *** Util joined
[15:39] <GlitchMr> Is version like v1.*.2 pointless?

[15:41] *** pmichaud joined
[15:43] <masak> std: v1.*.2

[15:43] <masak> oh, p6eval is on holiday since 17:32.

[15:44] <jnthn> Well, it is summer.

[15:45] <geekosaur> brb watching olympic evalthlon?

[15:46] <TimToady> std sez ok

[15:47] <TimToady> but pragmatically, it's likely to be pointless, unless community standards require .2 to mean something in every case

[15:47] <TimToady> which they ain't gonna

[15:48] <TimToady> otoh, we're talking about versions in general, so it's not just Perl community standards

[15:48] <geekosaur> it occurred to me that while v1.*.2 /per se/ is dubious, v1.*.0 is potentially useful

[15:48] <TimToady> a nd 1.*.0 might make more sense

[15:48] <TimToady> you beat me :)

[15:52] *** p6eval joined
[15:52] *** ChanServ sets mode: +v p6eval

[15:53] *** cognominal left
[15:56] *** raiph joined
[16:00] *** JimmyZ_ left
[16:01] *** SamuraiJack left
[16:02] *** zamolxes joined
[16:02] <moritz> 1.*.alpha

[16:03] <geekosaur> right, same idea

[16:04] <geekosaur> there are some milestone-like things that are useful, but 1.*.2 isn't really a meaningful milestone that is at all coordinated over values for the whatever

[16:04] *** SamuraiJack joined
[16:05] <moritz> unless you create a piece of software where it is

[16:05] <moritz> or somebody else does

[16:06] *** xinming_ joined
[16:07] <GlitchMr> https://gist.github.com/3208055

[16:07] <GlitchMr> :)

[16:08] <GlitchMr> So, I think I parse Perl 6 documentation :)

[16:08] <GlitchMr> (order doesn't matter0

[16:08] <GlitchMr> )

[16:08] <moritz> \o/

[16:08] <GlitchMr> Now to convert it to DuckDuckGo's output.txt format

[16:09] *** cognominal joined
[16:09] <crazedpsyc> GlitchMr++ :)

[16:10] * moritz has received two duckduckgo t-shirts today :-)

[16:10] *** xinming left
[16:10] <flussence> .oO( v1.(* %% 2).* would be useful, but that's overcomplicating things. )

[16:10] <moritz> (wrong size, but still close enough to wear them)

[16:10] <GlitchMr> Well, they wanted to give me DuckDuckGo's T-Shirts

[16:10] <GlitchMr> But why I would take them :P

[16:10] *** bbkr left
[16:11] <GlitchMr> For "contributions"

[16:11] <moritz> why wouldn't you?

[16:11] <GlitchMr> Why I would

[16:11] * moritz has lots of geek t-shirts at home, and isn't shy about wearing them

[16:12] <jnthn> Most of my t-shirts come from conferences :)

[16:12] * masak 's too

[16:12] <GlitchMr> Now, only my problem is colon thing

[16:12] <GlitchMr> "Takes a format string, and returns a string the key and value parts of the Pair formatted. Here's an example:"

[16:12] <GlitchMr> "Adds the @new elements to the hash with the same semantics as hash assignment, but with three exceptions:"

[16:13] <GlitchMr> Well, I guess that example thing could be removed... simply as that

[16:13] *** sergot left
[16:13] <moritz> GlitchMr: what is the problem with the excerpts you cited?

[16:14] <GlitchMr> Here's an example:

[16:17] *** tadzik joined
[16:19] <GlitchMr> It currently looks like http://paste.uk.to/ada2216b

[16:22] <moritz> ah, it requires more effort to parse

[16:22] <moritz> elsif ( $tags[-1] eq 'pre' && !$fields{prototype}) # might help

[16:23] <GlitchMr> oh thanks

[16:23] <GlitchMr> I haven't noticed

[16:24] <GlitchMr> == Numeric.succ ==

[16:24] <GlitchMr> '12.34'.succ      # 13.34

[16:24] <GlitchMr> 'img001.png'.succ # img002.png

[16:24] <GlitchMr> something went wrong... weird

[16:24] <GlitchMr> oh, I see

[16:25] *** shinobicl joined
[16:25] <shinobicl> hello!

[16:25] <shinobicl> i'm having troubel compiling perl6

[16:25] <shinobicl> "invoke() not implemented in class '$post'"

[16:26] <GlitchMr> $fields{prototype} ||= $dtext; would work too, I guess?

[16:26] <moritz> shinobicl: is that while compiling nqp?

[16:26] <masak> shinobicl: in which part of the build?

[16:26] <moritz> GlitchMr: but then you'd skip the examples

[16:27] <moritz> GlitchMr: which might be weird if text before or after the examples talks about them

[16:27] <GlitchMr> No space

[16:27] <shinobicl> make: *** [src/stage1/NQPCORE.setting.pbc] Error 1

[16:27] <shinobicl> yep, NQPCORE

[16:27] <GlitchMr> I will try to remove examples instead

[16:27] <masak> shinobicl: hm. :/

[16:27] <moritz> shinobicl: that's a known bug

[16:28] <moritz> shinobicl: as a workaround, you can try to add the -G flag to the command that failed

[16:28] <GlitchMr> All I want is function prototype and short description

[16:28] <GlitchMr> Just like with http://duckduckgo.com/?q=perl+split

[16:28] <moritz> GlitchMr: then you should probably only ever use the first paragraph

[16:29] <GlitchMr> Yes, I only use first paragraph

[16:29] <shinobicl> this is my script for updating rakudo: http://pastebin.ca/2175902

[16:29] *** sergot joined
[16:29] <tadzik> shinobicl: git clean -fdx may save you some bandwidth :)

[16:30] <GlitchMr> Unless I've done something wrongly?

[16:30] <moritz> (but needs to be repeated in rakudo/parrot/ and rakudo/nqp/)

[16:30] <tadzik> hm, true

[16:30] <shinobicl> ahh i have lots of bandwidth :) i use that machine mostly for playing with perl6 and i update like once a week

[16:30] <shinobicl> so, i should add -G in the like with MAKE then

[16:30] <shinobicl> like=line

[16:30] <moritz> shinobicl: no

[16:31] <moritz> shinobicl: you have to add that to the last command that the build process ran before it encountered that error

[16:31] <GlitchMr> http://doc.perl6.org/routine/new#EnumMap

[16:31] <moritz> (as I said, it's a workaround)

[16:31] <GlitchMr> It seems that lack of information confused my script

[16:32] <shinobicl> thanks moritz, i'll look into that

[16:32] <moritz> GlitchMr: oops, that shouldn't be like that

[16:34] <dalek> doc: 19335e2 | moritz++ | lib/EnumMap.pod:

[16:34] <dalek> doc: elaborate on EnumMap.new, GlitchMr++

[16:34] <dalek> doc: review: https://github.com/perl6/doc/commit/19335e24d3

[16:35] <dalek> doc: a3cad24 | moritz++ | lib/X/AdHoc.pod:

[16:35] <dalek> doc: harmonize markup

[16:35] <dalek> doc: review: https://github.com/perl6/doc/commit/a3cad24533

[16:35] <masak> moritz++ # untiring work on perl6/doc

[16:36] <dalek> doc: c5af24c | moritz++ | .gitignore:

[16:36] <dalek> doc: [gitignore] ignore html dir

[16:36] <dalek> doc: review: https://github.com/perl6/doc/commit/c5af24c8af

[16:37] <GlitchMr> http://doc.perl6.org/routine/Str#Match

[16:37] <GlitchMr> No prototype

[16:37] <GlitchMr> multi method Str(Match:D:) returns Str:D?

[16:41] <GlitchMr> Actually, whole Match lacks prototypes

[16:41] <GlitchMr> I should make it ignore lack of prototypes

[16:43] *** hoelzro is now known as hoelzro|away

[16:44] *** birdwindupbird left
[16:46] <TimToady> moritz: re 'say [] ... []' I fail to see how the ... is in sink context, since 'say' is looser than ...

[16:47] <moritz> TimToady: yes, I noticed that too (later in the backlog)

[16:48] <moritz> GlitchMr: there are actually many methods without prototypes :(

[16:52] *** thelazydeveloper joined
[16:53] *** dakkar left
[17:01] *** shinobicl left
[17:05] *** pyrimidine joined
[17:08] *** mtk left
[17:09] *** mtk joined
[17:10] <arnsholt> moritz: Could you have a look at https://gist.github.com/3206774 (my patch for not having several return types) when you get a chance?

[17:11] <arnsholt> Two weird things: 1) Doing X::Redeclaration.throw nets me two "use of uninitialized value of type Any in string context  in any apply_trait at src/Perl6/World.pm:1301", but just doing die works fine

[17:12] <arnsholt> 2) The segfault thing if you don't comment out the code in trait_mod:<is>

[17:12] <masak> arnsholt: that double "use of uninitialized..." behavior has hit some of us previously. it's mysterious.

[17:13] <arnsholt> Good to know, I suppose

[17:13] <arnsholt> The second one seems mysterious as well :/

[17:16] <masak> arnsholt: ...um, which trait_mod:<is>?

[17:17] <arnsholt> Bah. <returns>

[17:17] <arnsholt> I keep thinking it's sub foo is returns, not sub foo returns

[17:18] <masak> arnsholt: what about commenting out a subset of those lines of code?

[17:20] <moritz> arnsholt: I think I know where the warnings come from

[17:20] <moritz> arnsholt: X::Redeclaration is X::Comp, which carries around file name and line number of the error

[17:21] <flussence> Q: is there a way to get at a module's pod? Something like "use Foo::Bar; Foo::Bar::$=pod;"?

[17:21] <moritz> flussence: not yet :(

[17:21] <flussence> aww :(

[17:21] <moritz> flussence: p6doc helps itself with eval slurp($file) ~  "\n\$=pod"

[17:21] *** mtk left
[17:22] <moritz> which MTA (More Than Aweful)

[17:22] *** mtk joined
[17:22] <moritz> arnsholt: so if you don't provide file name and line number, you get uninit warnings for both (more)

[17:22] <masak> flussence: it would probably be $=Foo::Bar::pod, because of how sigils/twigils and package names nest.

[17:23] *** shinobicl joined
[17:23] *** am0c left
[17:23] <moritz> arnsholt: the correct way to supply those is to wrap the location where the trait handler is called in  $*W.rethrow($/, { codeblock that calls the trait handler});

[17:24] <moritz> which catches the exception, adds file and line number, and rethrows

[17:24] <masak> moritz++

[17:24] *** am0c joined
[17:24] <dalek> doc: 1c0e7f4 | raiph++ | lib/Junction.pod:

[17:24] <dalek> doc: typos

[17:24] <dalek> doc: review: https://github.com/perl6/doc/commit/1c0e7f4427

[17:25] <moritz> wow, people actually read what I write :-)

[17:26] <arnsholt> moritz: Aha! That explans the the undefs. Thanks!

[17:26] *** seldon joined
[17:27] *** fr0g left
[17:29] <moritz> http://moritz.faui2k3.org/tmp/p6doc # crude visitor stats for doc.perl6.org. About 75 per day so far

[17:31] *** Raimiss joined
[17:38] <dalek> doc: 448d5cf | raiph++ | lib/List.pod:

[17:38] <dalek> doc: typos

[17:38] <dalek> doc: review: https://github.com/perl6/doc/commit/448d5cf39e

[17:42] *** [particle] left
[17:47] <moritz> Failed to copy 'html-files/favicon.ico' to 'html': Is a directory

[17:47] <moritz> of course, 'html' is a directory

[17:47] <moritz> that's the whole point, stupid

[17:48] *** cognominal_ joined
[17:49] <dalek> doc: d5477a8 | moritz++ | html (2 files):

[17:49] <dalek> doc: [htmlify] add copying of static files; add favicon

[17:49] <dalek> doc: review: https://github.com/perl6/doc/commit/d5477a86d7

[17:51] *** cognominal left
[17:52] *** [particle] joined
[18:06] *** ilogger2 joined
[18:06] *** ChanServ sets mode: +v ilogger2

[18:06] *** birdwindupbird joined
[18:09] *** Raimiss joined
[18:10] <arnsholt> Progress! The segfault isn't triggered by the attribute get part

[18:12] <arnsholt> moritz: When I wrap the trait application in $*W.ex-handle(...) I get "Can not bind non-existent attribute '$!filename' on class 'X::Comp::AdHoc'" instead of what I expected. Familiar?

[18:13] *** Raimiss left
[18:14] <moritz> arnsholt: not expected, but I might know how to fix that

[18:15] *** Raimiss joined
[18:21] <moritz> arnsholt: basically World.rethrow doesn't handle that case yet

[18:21] <moritz> arnsholt: currently it assumes an untyped exception, and turns that into X::Comp::AdHoc

[18:21] <moritz> arnsholt: but of course it shouldn't do that with something that is already X::Comp

[18:22] <moritz> I need to refactor that routine a bit :(

[18:22] <arnsholt> Right

[18:22] <arnsholt> I'll leave it for now, then

[18:23] <moritz> arnsholt: https://gist.github.com/3208907 totally untested shot-in-the-dark patch

[18:23] <moritz> it compiles :-9

[18:25] <moritz> jnthn: halp. In Perl6::World, I need to find out into which class (of potentially several superclassses) a role was applied to

[18:26] <moritz> hm

[18:26] <moritz> maybe I simply provide a setter method

[18:30] *** birdwindupbird left
[18:31] <moritz> r: role A { has $.x; method set { $!x = 5 } }; class B does A { }; given B.new { .set; say .x }

[18:31] <p6eval> rakudo c1bfbb: OUTPUT«5␤»

[18:32] <arnsholt> jnthn: While we're on the subject (ish), I'm starting to suspect the segfault is triggered somewhere in the callgraph above the returns trait application when an exception is thrown

[18:39] <moritz> arnsholt: https://gist.github.com/3208907 updated with less ad-hoc patch

[18:41] <arnsholt> Cool. I'll play with it tomorrow

[18:42] <arnsholt> Right now I'm trying to squash that annoying segfault bug >.<

[18:46] <jnthn> r: role R { }; class A { }; class B is A does R { }; class C is B { }; say C.^mro.grep(*.^roles(:local).grep(R).elems)

[18:46] <p6eval> rakudo c1bfbb: OUTPUT«use of uninitialized value of type B in string context  in block  at /tmp/jsuL8j85KO:1␤␤␤»

[18:46] <jnthn> er

[18:46] <jnthn> r: role R { }; class A { }; class B is A does R { }; class C is B { }; say C.^mro.first(*.^roles(:local).grep(R).elems)

[18:46] <p6eval> rakudo c1bfbb: OUTPUT«B()␤»

[18:46] <jnthn> moritz: Like ^

[18:46] <jnthn> ?

[18:46] *** MayDaniel joined
[18:46] <jnthn> Oh, but in world...but the approach works :)

[18:47] <moritz> I'm just going with an all-caps setter method now

[18:47] <jnthn> arnsholt: Did you add something on the code-path that leads to the segfault to validate that we really have a 6model object there?

[18:48] *** [particle] joined
[18:48] <arnsholt> Yeah, I think I've tried $thing.WHAT on all the relevant things before the exception throwing, so I'm not sure what it is

[18:50] <arnsholt> Also, commenting out the exception throwing fixes it, so it's not the nqp::getattr. It's not the nqp::isnull($returns) either, since putting just that it doesn't break it either

[18:50] <jnthn> arnsholt: No, I meant a check like https://github.com/rakudo/rakudo/blob/nom/src/binder/container.c#L65

[18:50] <moritz> sometimes exception + segfault is an infinite loop of exceptions + catching + rethrowing, which leads to stack overflow or so

[18:50] <jnthn> Could be that also I guess.

[18:51] <arnsholt> Hmm. Is there a way to do that vtable thing from Perl 6?

[18:51] <jnthn> No

[18:51] <arnsholt> Hmm

[18:52] <jnthn> But the segfault is in container.c somewhere, no?

[18:52] <jnthn> So look down the stacktrace to see where the object entered C land.

[18:54] <arnsholt> runops_fast_core > Parrot_perl6_enter_multi_dispatch_from_onlystar_block_p > Rakudo_md_dispatch > find_best_candidate > Rakudo_cont_decontainerize

[18:54] <arnsholt> With some more Parrot stuff above runops_fast_core, of course

[18:58] *** Psyche^ joined
[18:58] *** Psyche^ is now known as Patterner

[18:58] <raiph> r:     sub f(\$parcel, $non-parcel) { } 

[18:58] <p6eval> rakudo c1bfbb:  ( no output )

[19:00] <jnthn> arnsholt: eek, a non-Perl 6 value is getting passed into the multi-dispatcher.

[19:00] <jnthn> That's gonna be ungood.

[19:01] <arnsholt> Weird. Kinda odd that it didn't blow up already

[19:01] <jnthn> But it tells you what you're looking for: some place we do a multi-dispatch with the "wrong thing"

[19:01] <arnsholt> Hmm

[19:02] *** fgomez joined
[19:08] <arnsholt> jnthn: Is there a way to poke at things in gdb and find the name of the sub we're multidispatching for?

[19:16] <raiph> r: sub f(\$parcel, $non-parcel) { say $parcel.WHAT; say $non-parcel.WHAT }; f((), ())

[19:16] <p6eval> rakudo c1bfbb: OUTPUT«Parcel()␤Parcel()␤»

[19:17] <raiph> moritz: i'm looking at http://doc.perl6.org/type/Parameter

[19:18] <raiph> specifically http://doc.perl6.org/type/Parameter#parcel

[19:18] <raiph> i don't understand why you've included the line of code i sent above to p6eval 

[19:19] <moritz> raiph: the terminology is a bit misleading... (more)

[19:19] <moritz> raiph: if a parameter is prefixed with \ it means that it doesn't decontainerize

[19:19] <moritz> so if you pass a variable to it, you can assign to the parameter

[19:19] <moritz> and if not, you cannot

[19:20] <moritz> (which is in contrast to 'is rw', which (should) fail at bind time if a non-variable is bound to it)

[19:23] *** fridim_ joined
[19:24] <moritz> r: class A is Real { }

[19:24] <p6eval> rakudo c1bfbb:  ( no output )

[19:24] <moritz> r: module A { }; class B is A { }

[19:24] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤B cannot inherit from A because it is not inheritable␤»

[19:25] *** Raimiss left
[19:29] <jnthn> arnsholt: Hmm...not easily, I fear.

[19:31] <arnsholt> Drat. Also, I have to admit I'm mystified by find_best_candidate

[19:31] <arnsholt> Or at least a bit

[19:32] <arnsholt> I guess GETATTR_CallContext_positionals is a macro masquerading as a function

[19:32] *** birdwindupbird joined
[19:38] <arnsholt> Nah. I'll try this again tomorrow. Brain full now

[19:38] <raiph> moritz: i'm still mulling what you wrote. i don't yet see a connection from what u just said to the code sample

[19:39] <moritz> raiph: the code sample isn't too helpful :(

[19:40] <raiph> moritz: (and also the one for the .capture entry:     sub f(\capture) { } )

[19:41] <raiph> hmm. i'll just finish the typo check and come back to this another time.

[19:42] <moritz> raiph: I'll try to improve the docs

[19:43] <dalek> doc: b7e4919 | raiph++ | lib/Parameter.pod:

[19:43] <dalek> doc: typos

[19:43] <dalek> doc: review: https://github.com/perl6/doc/commit/b7e4919fef

[19:50] *** crab2313 joined
[19:50] <dalek> doc: 8666fe3 | moritz++ | lib/Parameter.pod:

[19:50] <dalek> doc: [Parameter] elaborate on parcel and capture params, raiph++

[19:50] <dalek> doc: review: https://github.com/perl6/doc/commit/8666fe3f8b

[19:54] <dalek> rakudo/trait-exceptions: afe141b | moritz++ | src/ (2 files):

[19:54] <dalek> rakudo/trait-exceptions: refactor World.rethrow a bit

[19:54] <dalek> rakudo/trait-exceptions: 

[19:54] <dalek> rakudo/trait-exceptions: you can now throw typed exceptions without file/line information, and have World.ex-handle add them for you

[19:54] <dalek> rakudo/trait-exceptions: previously only untyped exceptions were supported, and wrapped into X::Comp::AdHoc.

[19:54] <dalek> rakudo/trait-exceptions: arnsholt++ for poking me

[19:54] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/afe141bda9

[19:54] <dalek> rakudo/trait-exceptions: de73915 | moritz++ | src/ (3 files):

[19:54] <dalek> rakudo/trait-exceptions: enable throwing of X::Comp exceptions from trait handlers

[19:54] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/de73915ef9

[19:55] <moritz> arnsholt: I'm spectesting that branch now. If it passes tests, that can serve as foundation for the exception stuff you want to do, instead of the crappy patches I pasted earlier :-)

[19:56] <moritz> and we'll finally get line numbers from failed traits

[19:56] <moritz> (at least, some of them :-)

[20:00] <moritz> nqp: my $_ := 3; ( -> { say $_ })()

[20:00] <p6eval> nqp: OUTPUT«Missing block at line 2, near "-> { say $"␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8523) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:01] <moritz> nqp: my $_ := 3; ({ say $_ })()

[20:01] <p6eval> nqp: OUTPUT«Unable to parse blockoid, couldn't find final '}' at line 2, near "say $_ })("␤current instr.: 'nqp;HLL;Grammar;panic' pc 22407 (src/stage2/gen/NQPHLL.pir:8523) (src/stage2/gen/NQPHLL.pm:326)␤»

[20:02] <moritz> nqp: my $_ := 3; ({ say($_) })()

[20:02] <p6eval> nqp: OUTPUT«3␤»

[20:03] <dalek> rakudo/trait-exceptions: 92b627f | moritz++ | src/Perl6/Actions.pm:

[20:03] <dalek> rakudo/trait-exceptions: ex-handle routine traits

[20:03] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/92b627fc9e

[20:15] <dalek> rakudo/trait-exceptions: 85800a0 | moritz++ | src/ (2 files):

[20:15] <dalek> rakudo/trait-exceptions: more exception fixes

[20:15] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/85800a066f

[20:29] *** birdwindupbird left
[20:30] *** birdwindupbird joined
[20:38] <dalek> rakudo/trait-exceptions: ff98fd1 | moritz++ | src/core/Exception.pm:

[20:38] <dalek> rakudo/trait-exceptions: X::Export::NameClash now also does X::Comp

[20:38] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/ff98fd1f50

[20:40] *** birdwindupbird left
[20:44] <dalek> rakudo/trait-exceptions: fe675c9 | moritz++ | src/Perl6/ (2 files):

[20:44] <dalek> rakudo/trait-exceptions: fix pod

[20:44] <dalek> rakudo/trait-exceptions: review: https://github.com/rakudo/rakudo/commit/fe675c9cc5

[20:46] <moritz> I hope that cleans up the spectest again

[21:01] <dalek> rakudo/nom: afe141b | moritz++ | src/ (2 files):

[21:01] <dalek> rakudo/nom: refactor World.rethrow a bit

[21:01] <dalek> rakudo/nom: 

[21:01] <dalek> rakudo/nom: you can now throw typed exceptions without file/line information, and have World.ex-handle add them for you

[21:01] <dalek> rakudo/nom: previously only untyped exceptions were supported, and wrapped into X::Comp::AdHoc.

[21:02] *** dalek joined
[21:02] *** ChanServ sets mode: +v dalek

[21:04] <lue> hello world o/

[21:05] <masak> lue! \o/

[21:05] <moritz> \o

[21:05] <sorear> lue! \o/

[21:06] <masak> sorear! \o/

[21:07] <moritz> masak! \o/

[21:08] <dalek> rakudo/nom: 96699c0 | jnthn++ | docs/ChangeLog:

[21:08] <dalek> rakudo/nom: Be a little more precise/informative about magnitude of memory improvements.

[21:08] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/96699c0ae5

[21:08] * masak does a little happy dance

[21:09] *** pnu joined
[21:10] *** preflex joined
[21:10] <moritz> jnthn: ChangeLog also doesn't mention PIRT yet

[21:10] *** Exodist joined
[21:11] <dalek> rakudo/nom: 7b678c3 | jnthn++ | docs/ChangeLog:

[21:11] <dalek> rakudo/nom: Mention PIRT.

[21:11] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7b678c3971

[21:13] *** DarthGandalf joined
[21:13] <dalek> rakudo/nom: 7c4c8b1 | moritz++ | docs/ChangeLog:

[21:13] <dalek> rakudo/nom: mention trait exception improvements in ChangeLog

[21:13] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/7c4c8b1359

[21:14] <moritz> sleep time here

[21:15] <lue> goodnight moritz o/

[21:15] <jnthn> 'night, moritz 

[21:15] <masak> good night, moritz. dream of wonderful ChangeLogs and squeaky-clean documentation.

[21:16] <moritz> and informative exceptions!

[21:17] <masak> sssh! :P

[21:22] *** benabik joined
[21:25] <masak> > x right rod

[21:25] <masak> It's a rod and it's on the right. It's made of liquorice.

[21:25] <masak> Nah, just kidding! It looks to be made of copper or something.

[21:25] <masak> :P

[21:26] * PerlJam starts cranking his portable Van der Graaf generator and stands near the rod

[21:26] <[Coke]> uhoh, we're in trouble.

[21:27] <sorear> Does the description change if you move it to your left?

[21:27] <[Coke]> I just heard that the Hobbit is going to be /3/ movies.

[21:28] <masak> sorear: the rod is fixed to the floor.

[21:28] <PerlJam> "Van der Graaf"?  or "Van de Graaf"?

[21:28] <sorear> masak: you can use your feet to move the floor in your reference frame, though.

[21:28] <sorear> unless the floor is also fixed to you?

[21:29] <benabik> [Coke]: It should not take the same amount of film for the Hobbit as the entire Lord of the Rings.

[21:29] <benabik> 2 was stretching it, I thought

[21:30] * sorear hands PerlJam a Wimshurst Machine.

[21:31] <dalek> nqp: 127288f | jnthn++ | src/QAST/Operations.nqp:

[21:31] <dalek> nqp: Using 'pure' is gonna confuse everyone as to what it means, so just call it inlinable.

[21:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/127288f242

[21:31] <dalek> nqp: d94369f | jnthn++ | src/QAST/Operations.nqp:

[21:31] <dalek> nqp: Collect op inlinability information and allow it to be queried.

[21:31] <dalek> nqp: review: https://github.com/perl6/nqp/commit/d94369fccc

[21:32] <masak> sorear: you can use your feet to move the floor in your reference frame, but only at the granularity of rooms. (in my game)

[21:36] <[Coke]> benabik: they're pulling in some of the other source material.

[21:37] * masak doesn't know whether to like that or not

[21:39] <lue> masak: safe to say it's probably going to anger a few fans :) .oO(Ooh, there's this part in The Lion, the Witch, and the Wardrobe that'll work perfectly for this scene!)

[21:39] *** fridim_ left
[21:43] *** benabik left
[21:44] *** benabik joined
[21:45] <masak> lue: I just pushed today's crypt work.

[21:45] <masak> lue: you can now 'put the tiny disk on the right rod'.

[21:45] * masak blogs

[21:45] <lue> \o/

[21:47] <huf> i wonder what ties in with the hobbit so strongly that you can include it...

[21:47] <huf> lotr is written to be much "wider", so i'd think it'd be easier to add things to it

[21:47] * masak too

[21:47] <huf> were it not already too goddam long for a movie

[21:48] <huf> i can't really imagine bits of the silmarillion in the mittle of the hobbit, and what else is there?

[21:48] <huf> cutting to the story of celebrimbor in the middle of the movie to explain the origin of the ring is ... doesnt sound very fortunate

[21:50] <huf> they shouldda picked the story of turin. also has a dragon in it AND is sad enough to make stone weep

[21:52] *** MayDaniel left
[21:55] <lue> masak: finally beat the game! (also, I half-expected > x camelia to work :P)

[21:55] <masak> lue: I also beat the game on the CLI for the first time tonight ;)

[21:56] <masak> lue: how should I make 'x camelia' work? I don't have noun synonyms...

[21:56] * lue looks at how other synonyms work in crypt before making an answer

[21:56] <masak> do we have an ASCII art Camelia?

[21:57] <huf> "Camelia" is fairly distinctive...

[21:57] <sorear> masak: yes.

[21:57] <sorear> masak: well, latin1 art

[21:58] <lue> »ö«

[21:58] <TimToady> it's only, like, in the topic

[21:58] *** crab2313 left
[21:59] <masak> I know about that one ;)

[21:59] <masak> I meant a bigger one, like 15x20.

[21:59] <TimToady> ah

[21:59] <TimToady> we could probably do one in braille dots...

[22:01] <masak> :P

[22:02] <lue> maybe a .make_synonym or .make_alias method? .oO(make_ln)

[22:05] <masak> could work. not a half-bad idea, actually.

[22:05] <masak> I haven't needed it for crypt, but I could see how other games might need it.

[22:05] <masak> and we only do that for directions.

[22:05] <masak> lue++

[22:05] <masak> s/only/already/

[22:06] <lue> you have a %exit_aliases hash in Adventure::Engine, so I don't think %object_aliases should be too difficult :)

[22:06] *** tanzdebil joined
[22:06] <tanzdebil> evening

[22:06] <masak> ooh -- got an email with bug reports!

[22:07] <jnthn> evening, tanzdebil 

[22:07] <tanzdebil> was wondering if anyone was up on the state of KeyBag & friends in rakudo

[22:07] <masak> lue: %thing_aliases, keeping with the naming scheme, but yes :)

[22:07] <masak> r: KeyBag; say "well, we have KeyBag"

[22:07] <p6eval> rakudo c1bfbb: OUTPUT«well, we have KeyBag␤»

[22:07] <masak> lol, I blogggggggggged! \o/ http://strangelyconsistent.org/blog/july-30-2012-tying-up-various-loose-ends

[22:08] <masak> (only one day to go! *pant* *pant*)

[22:08] <jnthn> Looking at the test list, we certainly run a bunch of tests for KeyBag and KeySet.

[22:08] * masak reads the email

[22:10] <tanzdebil> as in, looks like the nice little set operators are in the spec but not yet impl - yes?

[22:10] <ingy> where is the p6 cpan and what is it called?

[22:11] <tanzdebil> r: my $x = KeyBag.new({a => 1}); my $y = KeyBag.new({a => 2}); my $z = $x ⊍ $y; say "z = ", $z;

[22:11] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/qfkI0fnNOu:1␤»

[22:11] <masak> ingy: modules.perl6.org

[22:12] <TimToady> n: my $x = KeyBag.new({a => 1}); my $y = KeyBag.new({a => 2}); my $z = $x ⊍ $y; say "z = ", $z;

[22:12] <p6eval> niecza v19-15-g051783d: OUTPUT«z = keybag("a" => 1)␤»

[22:12] <TimToady> hmm

[22:12] * colomon is suddenly paying attention...

[22:13] <ingy> masak: does it have a common name? 6pan?

[22:13] <TimToady> looks like an entymological entity

[22:14] <sorear> colomon! \o/

[22:14] <masak> ingy: no, nothing like that. it's generally considered a temporary solution, because we have a "real" CPAN.

[22:15] <tanzdebil> TT:  ok, double checking...

[22:15] <ingy> well I'll call it 6PAN in the talk proposal

[22:15] <ingy> I think people will get it...

[22:15] <masak> [Coke], lue: you just got completely ousted by the guy (Kevin Colyer) who just sent me an email about crypt.

[22:15] <jnthn> tanzdebil: Right, we don't have the unicode forms of them in Rakudo at least.

[22:15] <lue> masak: how so?

[22:15] <masak> he sent me a transcript of things he tried!

[22:15] <colomon> sorear: I started scheming on vastly improved case-routines while up north, but decided to fish more instead of actually trying to implement them.

[22:16] <masak> with dozens of good suggestions!

[22:16] <jnthn> Hmm...or even the ascii ones it seems.

[22:16] <tanzdebil> jnthn:  ok cool, just making sure.

[22:17] <sorear> colomon: what's a case routine?

[22:17] <jnthn> tanzdebil: I guess they're not terribly hard to implement, just nobody got to 'em yet.

[22:17] <dalek> nqp: a8df907 | jnthn++ | / (12 files):

[22:17] <dalek> nqp: Add a QAST::InlinePlaceholder to represent a place in the QAST where an argument needs to be filled in when inlining. Implement a first cut of producing a tree with the placeholders substituted in.

[22:17] <dalek> nqp: review: https://github.com/perl6/nqp/commit/a8df907adb

[22:17] <lue> I thought the unicode set ops were NYI, and it seems still to be so (unless I'm awful at searching through perlcabal.org's google search)

[22:18] <masak> lue: I added his email to https://gist.github.com/3034482

[22:19] <masak> the totality of all the things he unearthed makes him an easy winner of this month's contest.

[22:19] <masak> there's still time left, though :)

[22:19] <tanzdebil> r: my $x = KeyBag.new({a => 1}); my $y = KeyBag.new({a => 2}); my $z = $x ⊍ $y; say "z = ", $z;

[22:19] <p6eval> rakudo c1bfbb: OUTPUT«===SORRY!===␤Confused␤at /tmp/zGS9ZlOYgp:1␤»

[22:19] <masak> phenny: de en "tanz"?

[22:19] <phenny> masak: "dance" (de to en, translate.google.com)

[22:20] <masak> phenny: es en "debil"?

[22:20] <phenny> masak: "weak" (es to en, translate.google.com)

[22:20] <jnthn> S03-operators/set.t has a bunch of tests. 280 of 'em. Tempting... :)

[22:20] <tanzdebil> tanzdebil = made up german word

[22:20] <masak> ah.

[22:20] <tanzdebil> tho not made up by me:)

[22:22] <tanzdebil> OK, thx everyone who answered.  am new to the source, and not entirely sure when to trust my own eyes.

[22:22] <lue> masak: one nice thing, although you'd probably need NativeCall for it, would be "up arrow=go back in history" (also: the OOPS command, though I usually use the up arrow instead :) )

[22:23] <TimToady> n: my $x = KeyBag.new({a => 3}); my $y = KeyBag.new({a => 2}); my $z = $x ⊍ $y; say "z = ", $z;

[22:23] <p6eval> niecza v19-15-g051783d: OUTPUT«z = keybag("a" => 3)␤»

[22:24] <masak> lue: yes, there should definitely be bindings for a readline with history. I think that's possible at this point, thanks to arnsholt++

[22:24] <tanzdebil> n: my $x = KeyBag.new({a => 1}); my $y = KeyBag.new({a => 2}); my $z = $x ⊍ $y; say "z = ", $z;

[22:24] <p6eval> niecza v19-15-g051783d: OUTPUT«z = keybag("a" => 1)␤»

[22:24] <tanzdebil> n: my $x = KeyBag.new({a => 2}); my $y = KeyBag.new({a => 1}); my $z = $x ⊍ $y; say "z = ", $z;

[22:24] <p6eval> niecza v19-15-g051783d: OUTPUT«z = keybag("a" => 2)␤»

[22:24] <tanzdebil> hmm

[22:24] <TimToady> n: my $x = KeyBag.new({a=> 2}); my $y = KeyBag.new({a => 3}); my $z = $x ⊍ $y; say "z = ", $z;

[22:24] <p6eval> niecza v19-15-g051783d: OUTPUT«z = keybag("a" => 2)␤»

[22:25] <masak> looks rong to me.

[22:25] <TimToady> seems to just take the first one

[22:25] <tanzdebil> okay, so it's all up in the air then.

[22:25] <masak> would make more sense if it took the max of the values.

[22:25] <TimToady> precedence maybe?

[22:25] <tanzdebil> masak:  well there are two interpretations -- for union, max does seem more reasonable.

[22:26] <TimToady> n: my $x = KeyBag.new({a => 3}); my $y = KeyBag.new({a => 2}); my $z = ($x ⊍ $y); say "z = ", $z;

[22:26] <p6eval> niecza v19-15-g051783d: OUTPUT«z = bag("a" => 6)␤»

[22:26] <tanzdebil> for +, which I'm not sure is defined yet (because it's not in set.t) a sum of the weights may be more reasonable.

[22:26] <TimToady> yes, listop looser than item assignment

[22:26] <tanzdebil> that way people can use ⊍ for max, and + for sum of weights.

[22:27] <tanzdebil> n: my $x = KeyBag.new({a => 5}); my $y = KeyBag.new({a => 2}); my $z = $x - $y; say "z = ", $z;

[22:27] <p6eval> niecza v19-15-g051783d: OUTPUT«z = 3␤»

[22:27] <tanzdebil> and - functions just like we think it should.

[22:27] <masak> tanzdebil: I'm not that comfortable with infix:<+> being anything other than scalar addition.

[22:28] <masak> we work pretty hard in Perl to keep it that way.

[22:28] <tanzdebil> ok then

[22:28] <TimToady> n: my $x = KeyBag.new({a => 3}); my $y = KeyBag.new({a => 2}); my $z = ($x ∪ $y); say "z = ", $z;

[22:28] <p6eval> niecza v19-15-g051783d: OUTPUT«z = bag("a" => 3)␤»

[22:29] <tanzdebil> but then - is not, symmetrically, scalar subtraction in this case

[22:29] <TimToady> n: my $x = KeyBag.new({a => 3}); my $y = KeyBag.new({a => 2}); my $z = ($x ⨄ $y); say "z = ", $z;

[22:29] <p6eval> niecza v19-15-g051783d: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/kr9ZFjCuP1 line 1:␤------> [32m $y = KeyBag.new({a => 2}); my $z = ($x [33m⏏[31m⨄ $y); say "z = ", $z;[0m␤␤Parse failed␤␤»

[22:30] <TimToady> there's plenty of unicode without overloading things that maybe shouldn't be

[22:30] *** cognominal_ joined
[22:41] <dalek> nqp/sigsp: 5c0a24b | pmichaud++ | src/ (2 files):

[22:41] <dalek> nqp/sigsp: Initial patches to ignore leading whitespace in rules.

[22:41] <dalek> nqp/sigsp: review: https://github.com/perl6/nqp/commit/5c0a24b64c

[22:48] <tanzdebil> TT:  cool

[22:48] * jnthn is happy to see pmichaud++ taking this on :)

[22:48] *** snearch joined
[22:50] <pmichaud> nqp works with the new spacing requirements; now it's time to get rakudo to work :)

[22:51] <masak> \o/

[22:56] <jnthn> TimToady: Are the set operators (some/all) in standard Perl 6?

[22:57] <jnthn> TimToady: STD doesn't include them, nor does S03.

[22:57] <lue> jnthn: I've never found them (although I'm not too trusting of perlcabal's google search)

[22:58] <jnthn> No, though they are covered in spectest.

[22:58] <jnthn> And I note that Niecza doesn't need a "use" statement to get at them at present.

[22:59] <jnthn> Dunno if that's intended for the long them though.

[23:00] *** kaare_ joined
[23:01] *** whiteknight joined
[23:01] *** whiteknight is now known as Guest47300

[23:06] <dalek> rakudo/setops: f0c5c2d | jnthn++ | src/ (4 files):

[23:06] <dalek> rakudo/setops: Initial stab at porting of set operations from Niecza's CORE.setting. Doesn't pass set.t yet, but worse somehow slows down CORE.setting parse quite a bit. Pushing this to allow @other to investigate either issue; need to resolve whether the ops even belong in core before this is merged also.

[23:06] <dalek> rakudo/setops: review: https://github.com/rakudo/rakudo/commit/f0c5c2d7b9

[23:07] <jnthn> Hm. Seems that raises more questions than answers, but it gives it a shove in some direction. :)

[23:08] <sorear> jnthn: it slows down CORE.setting parse quite a bit because you've just added characters >= 256 to the setting

[23:08] <pmichaud> actually, I think because they're in the grammar.

[23:08] <pmichaud> The setting should be able to handle codepoints above 256 just fine.

[23:08] <sorear> now the setting has to be encoded in UTF-8 becuase Parrot's support for UTF-32 sucks

[23:08] <pmichaud> doesn't matter too much, we do ucs4 internally.

[23:08] <jnthn> Apart from the regex engine does everything in ucs4 afaik.

[23:08] <jnthn> Which is why it's kinda surprising.

[23:08] <pmichaud> not *everything*

[23:09] <pmichaud> it encodes the target string as ucs4, yes.  but source literals might not be.

[23:09] <jnthn> Evidently. ;-)

[23:09] <jnthn> Ah, that's possible.

[23:09] <sorear> pmichaud: oh, that finally got fixed?  I thought you couldn't use ucs4 in the grammar because parrot's UCS4 required ICU

[23:09] <pmichaud> there's also the possible problem that the regex method names aren't latin1

[23:09] <pmichaud> ucs4 requires ICU for a lot of operations, but not for basic string comparison.

[23:09] <pmichaud> i.e., you can't upcase/downcase codepoints >= 256 in ucs4 without icu

[23:10] <pmichaud> well.... actually larger than 256 iirc; we do some good cheating there when icu isn't present.

[23:10] <jnthn> *nod*

[23:10] <jnthn> Well, a way to reproduce the slowdown is there for anyone who wants to have a dig. :)

[23:11] *** benabik left
[23:11] * jnthn will be spending his tuits on the inlining stuff mostly in the next days, though.

[23:14] <masak> good night, #perl6

[23:15] <lue> goodnight, masak o/

[23:17] <jnthn> hm, some rest sounds like a good idea...

[23:17] <jnthn> 'night o/

[23:23] *** snearch left
[23:23] *** gongyiliao joined
[23:26] *** benabik joined
[23:35] *** Transformer joined
[23:35] <tanzdebil> nitey ~~ all

[23:36] *** Transformer left
[23:44] *** kaare_ left
[23:51] <dalek> doc: 82c90c5 | (Geoffrey Broadwell)++ | lib/Perl6/TypeGraph.pm:

[23:51] <dalek> doc: Pre-sort types by name before doing topo sort

[23:51] <dalek> doc: review: https://github.com/perl6/doc/commit/82c90c5d88

[23:52] *** tanzdebil left
[23:52] *** japhb_ joined
[23:55] <japhb_> moritz, in doc commits c5af24c8af and d5477a86d, did you intend to move the JS/CSS out of html/ and into html-files/ (this would of course require the html-files copying to become recursive)?

[23:55] <japhb_> moritz, or did you intend instead to only .gitignore the *generated* directories within html/ ?

