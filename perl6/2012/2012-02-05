[00:01] <TimToady> errands &

[00:03] *** imarcusthis left
[00:10] *** bluescreen10 left
[00:15] <[Coke]> whiteknight: pull requests seem to have worked in the past.

[00:15] <whiteknight> thanks [Coke]. I'm not ready yet, but good to know for future reference

[00:16] *** cognominal left
[00:21] *** cognominal joined
[00:38] *** imarcusthis joined
[00:44] *** imarcusthis left
[01:01] <cognominal> I have a bad day with grammars. Why does this parse fail? 

[01:01] <cognominal> rakudo:  grammar A { rule TOP { ^  a }; token ws { \s* } }; say A.parse(" a")

[01:01] <p6eval> rakudo a47a56: OUTPUT«#<failed match>␤»

[01:01] <cognominal> niecza:  grammar A { rule TOP { ^  a }; token ws { \s* } }; say A.parse(" a")

[01:01] <p6eval> niecza v14-14-gc008e24: OUTPUT«A()␤»

[01:02] <cognominal> niecza:  grammar A { rule TOP { ^  a }; token ws { \s* } }; say A.parse(" a").perl

[01:02] <p6eval> niecza v14-14-gc008e24: OUTPUT«A␤»

[01:08] *** Radvendii joined
[01:09] <Radvendii> is there no -p option in perl6 yet?

[01:11] *** Radvendii left
[01:21] <cognominal> Radvendii: You can't group uniletter switch

[01:21] <cognominal> echo foo | perl6 -p -e '$_'

[01:22] <cognominal> using rakudo perl6

[01:28] *** grizzlysmit joined
[01:32] <dalek> roast: 902702c | (Solomon Foster)++ | S32-num/complex.t:

[01:32] <dalek> roast: Use eval_dies-ok because Niecza catches comparison errors at compile time.

[01:32] <dalek> roast: review: https://github.com/perl6/roast/commit/902702c2c1

[01:34] *** chee is now known as bot-chee

[01:34] *** bot-chee is now known as chee

[01:35] *** chee is now known as bot-chee

[01:35] <dalek> roast: 9e532ca | (Solomon Foster)++ | S04-statements/for.t:

[01:35] <dalek> roast: Additional fudging for niecza.

[01:35] <dalek> roast: review: https://github.com/perl6/roast/commit/9e532ca606

[01:36] *** bot-chee is now known as chee

[01:42] <colomon> nom: try { 1 div 0 }

[01:42] <p6eval> nom a47a56:  ( no output )

[01:43] <colomon> niecza: try { 1 div 0 }

[01:43] <p6eval> niecza v14-14-gc008e24: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Constant folding threw exception: System.DivideByZeroException: Division by zero␤  at Builtins.divop (Int32 opc, Niecza.Variable a1, Niecza.Variable a2) [0x00000] in <filename unknown>:0 ␤  at Run.CORE.C1206infix:<div> (Niec…

[01:43] <colomon> sorear: errr... is this getting carried away with the exception folding?

[01:47] *** chee is now known as bot-chee

[01:48] *** bot-chee is now known as chee

[01:50] <TimToady> cognominal: the match fails because the sigspace before ^ traverses the initial whitespace, at which point ^ fails

[01:50] *** cognominal left
[01:50] <TimToady> this is one reason the sigspace rules have been revised (but not yet implemented)

[01:51] *** cognominal joined
[01:52] <TimToady> colomon, sorear: in Ada (at least originally), an error like 1/0 constant-folds into a throw, but it still happens at run time

[01:52] *** cognominal left
[01:53] *** cognominal joined
[01:59] *** Radvendii joined
[02:01] <Radvendii> is there any way to force operations to not flatten lists?

[02:02] <Radvendii> nom: ("a b c", "d e f").split(" ").perl.say

[02:02] <p6eval> nom a47a56: OUTPUT«("a", "b", "c", "d", "e", "f").list␤»

[02:04] *** Trashlord left
[02:04] <Radvendii> cognominal++ #thanks for earlier response, found it on IRC logs :D

[02:05] <gfldex> nom: .split(" ").perl.say for ("a b c", "d e f");

[02:05] <p6eval> nom a47a56: OUTPUT«("a", "b", "c").list␤("d", "e", "f").list␤»

[02:06] *** Trashlord joined
[02:07] <Radvendii> nom: ("a b c", "d e f").»split(" ").perl.say

[02:07] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Confused␤at /tmp/3mtsYnL5QI:1␤»

[02:07] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = @a.map({.split(" ")}); say @b.perl;

[02:07] <p6eval> nom a47a56: OUTPUT«Array.new("a", "b", "c", "d", "e", "f")␤»

[02:08] <Radvendii> nom: ("a b c", "d e f")».split(" ").perl.say

[02:08] <p6eval> nom a47a56: OUTPUT«(("a", "b", "c").list, ("d", "e", "f").list)␤»

[02:08] <Radvendii> there we go

[02:08] <Radvendii> nom: eager ("a b c", "d e f")».split(" ").map(&say)

[02:08] <p6eval> nom a47a56: OUTPUT«a␤b␤c␤d␤e␤f␤»

[02:08] <Radvendii> dammit

[02:08] <Radvendii> why does 

[02:08] <Radvendii> .map flatten everything?

[02:09] <gfldex> because map is perl5ish

[02:09] <Radvendii> is there a different operator to use? or is that going to be fixed?

[02:10] <gfldex> >>. seams to work quite nicely

[02:10] <Radvendii> that's only if you're applying a method to them each

[02:10] <Radvendii> not if you're trying to do something more complicated

[02:13] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = { split(" ", *) } for @a; say @b.perl;

[02:13] <p6eval> nom a47a56: OUTPUT«Array.new(Block.new())␤»

[02:13] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = { split(" ", *) } for @a; say @b.flat.perl;

[02:13] <p6eval> nom a47a56: OUTPUT«Array.new(Block.new())␤»

[02:13] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = split(" ", *) for @a; say @b.flat.perl;

[02:13] <p6eval> nom a47a56: OUTPUT«Nominal type check failed for parameter '$target'; expected Cool but got Whatever instead␤  in sub split at src/gen/CORE.setting:1904␤  in block <anon> at /tmp/qoFdWGVOxc:1␤  in method reify at src/gen/CORE.setting:4475␤  in method reify at src/gen/CORE.setting:4380␤ …

[02:14] <Radvendii> no worries, all i've gotta do is grep them anyways

[02:14] <Radvendii> although it *is* kind of silly...

[02:14] <Radvendii> I'm guessing Lists of Lists is one of those things that they'll get to at some point

[02:14] <gfldex> nom: LoL.WHAT.say;

[02:14] <p6eval> nom a47a56: OUTPUT«LoL()␤»

[02:15] <gfldex> problem is that the dispatcher doesn't take return values into account. As a result you can't force map to return a LoL.

[02:15] <Radvendii> dispatcher?

[02:16] <gfldex> but you can solve your problem by providing a generator

[02:16] <gfldex> the thing that does MMD

[02:16] <Radvendii> MMD? (sorry...)

[02:17] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = for @a -> @l { take split(@l, " ") }; say @b.perl;

[02:17] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Confused␤at /tmp/Dq8FHbdSxv:1␤»

[02:17] <gfldex> multi method dispatch

[02:17] <gfldex> same function name, different signature

[02:19] <Radvendii> oooh... i see

[02:21] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = gather for @a { take split(*, " ") }; say @b.perl;

[02:21] <p6eval> nom a47a56: OUTPUT«No applicable candidates found to dispatch to for 'split'. Available candidates are:␤:(Str:D , Regex $pat, Any $limit = { ... }, Any :all(:$all), Mu %_!)␤:(Str:D , Cool $delimiter, Any $limit = { ... }, Any :all(:$all), Mu %_!)␤:(Cool , Regex $pat, Any $limit = { ... …

[02:21] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = gather for @a { take split($_, " ") }; say @b.perl;

[02:21] <p6eval> nom a47a56: OUTPUT«Array.new(" ", " ")␤»

[02:22] *** Chillance joined
[02:22] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = gather for @a { say $_.perl; take split($_, " ") }; say @b.perl;

[02:22] <p6eval> nom a47a56: OUTPUT«"a b c"␤"d e f"␤Array.new(" ", " ")␤»

[02:23] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = gather for @a { take split(" ", *) }; say @b.perl;

[02:23] <p6eval> nom a47a56: OUTPUT«Nominal type check failed for parameter '$target'; expected Cool but got Whatever instead␤  in sub split at src/gen/CORE.setting:1904␤  in block <anon> at /tmp/8ArEje7qzy:1␤  in method reify at src/gen/CORE.setting:4475␤  in method reify at src/gen/CORE.setting:4380␤ …

[02:23] <gfldex> nom: my @a = ("a b c", "d e f"); my @b = gather for @a { take split(" ", $_) }; say @b.perl;

[02:23] <p6eval> nom a47a56: OUTPUT«Array.new("a", "b", "c", "d", "e", "f")␤»

[02:23] <TimToady> btw, you generally want .words rather than .split(" ")

[02:23] <Radvendii> right, but i'm actually doing .split(", ")

[02:24] <Radvendii> and i also prefer fewer primitive subroutines

[02:24] <Radvendii> i think .split(" ") better describes what i'm doing than .words

[02:25] <TimToady> nom: sub lol (**@lol) { @lol.map: {[@$_]} }; (<a b c>, <d e f>).lol.map: *.say

[02:25] <p6eval> nom a47a56:  ( no output )

[02:25] <Radvendii> nom: eager ("a b c", "d e f")».split(" ")>>.say

[02:25] <p6eval> nom a47a56: OUTPUT«f␤e␤a␤d␤c␤b␤»

[02:26] <TimToady> nom: sub lol (**@lol) { @lol.map: {[@$_]} }; lol(<a b c>, <d e f>).map: *.say

[02:26] <p6eval> nom a47a56:  ( no output )

[02:26] <Radvendii> awww... that flattens as well

[02:26] <TimToady> nom: sub lol (**@lol) { @lol.map: {[@$_]} }; eager lol(<a b c>, <d e f>).map: *.say

[02:26] <p6eval> nom a47a56: OUTPUT«a b c␤d e f␤»

[02:26] <TimToady> that doesn't

[02:26] <TimToady> nom: eager (<a b c>, <d e f>).lol.map: *.say

[02:26] <p6eval> nom a47a56: OUTPUT«a b c␤d e f␤»

[02:26] <TimToady> that doesn't flatten

[02:27] <TimToady> nom: eager (<a b c>, <d e f>).lol.perl.say

[02:27] <p6eval> nom a47a56: OUTPUT«LoL.new(("a", "b", "c"), ("d", "e", "f"))␤»

[02:27] <Radvendii> what? is there a built in lol function?

[02:27] <TimToady> lol, yes

[02:27] <gfldex> no, p6eval is just clever

[02:27] <Radvendii> haha, nice. cool

[02:27] <TimToady> no, Cool is a type

[02:27] <TimToady> and nice is a Unix command

[02:28] <Radvendii> hardy har har.

[02:28] <TimToady> nom: eager lol(<a b c>, <d e f>).map: *.say

[02:28] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&lol' called (line 1)␤»

[02:28] <TimToady> aww

[02:28] <TimToady> niecza: eager lol(<a b c>, <d e f>).map: *.say

[02:28] <p6eval> niecza v14-14-gc008e24: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routines:␤    'eager' used at line 1␤ 'lol' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.co…

[02:29] <TimToady> niecza: lol(<a b c>, <d e f>).map: *.say

[02:29] <p6eval> niecza v14-14-gc008e24: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Undeclared routine:␤     'lol' used at line 1␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ␤  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ␤  at /home…

[02:29] <TimToady> niecza: (<a b c>, <d e f>).lol.map: *.say

[02:29] <p6eval> niecza v14-14-gc008e24: OUTPUT«Unhandled exception: Unable to resolve method lol in class Parcel␤  at /tmp/_Gj_sJlcYN line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3609 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3610 (module-CORE @ 63) ␤  at /home…

[02:29] <TimToady> nom++

[02:29] <TimToady> for the method, not for missing the listop

[02:30] <Radvendii> oh, yeah :P

[02:33] <TimToady> nom: eager (<a b c>, <d e f>).lol.map(-> @x { @x».uc }).lol.[1].say

[02:33] <p6eval> nom a47a56: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <anon> at /tmp/M4gtyoYKlA:1␤  in <anon> at /tmp/M4gtyoYKlA:1␤»

[02:34] <TimToady> I guess nom only implements .lol on parcels so far

[02:35] <TimToady> nom: eager (<a b c>, <d e f>).lol.map(-> @x { @x».uc })[1].say

[02:35] <p6eval> nom a47a56: OUTPUT«D E F␤»

[02:35] <TimToady> I guess it doesn't really need the second lol

[02:36] <Timbus> nom: (<a b c>, <d e f>).lol.map(-> @x { @x».uc })[1].say

[02:36] <p6eval> nom a47a56: OUTPUT«D E F␤»

[02:37] <Timbus> no need to be too eager

[02:37] <TimToady> nom: sub lol (**@lol) { @lol.map: {[@$_]} }; .say for lol <a b c>, <d e f>

[02:37] <p6eval> nom a47a56: OUTPUT«a b c␤d e f␤»

[02:38] <TimToady> niecza: sub lol (**@lol) { @lol.map: {[@$_]} }; .say for lol <a b c>, <d e f>

[02:38] <p6eval> niecza v14-14-gc008e24: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Slice parameters NYI at /tmp/Rt49KOXxdl line 1:␤------> [32msub lol (**@lol[33m⏏[31m) { @lol.map: {[@$_]} }; .say for lol <a[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344…

[02:40] <TimToady> lol slices are a prerequisite for much of S09

[02:42] <colomon> Isn't sorear++ still waiting for pmichaud++ to explain how they are supposed to work?

[02:43] <colomon> LoL, I mean

[02:43] <Radvendii> nom: my $a = "foo"; say "foobar" ~~ /$a/;

[02:43] <p6eval> nom a47a56: OUTPUT«=> <foo>␤␤»

[02:43] <Radvendii> so it does match...

[02:43] <Radvendii> nom: my $a = "(baz|foo)"; say "foobar" ~~ /$a/;

[02:43] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[02:44] <Radvendii> nom: my $a = "<[baz|foo]>"; say "foobar" ~~ /$a/;

[02:44] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[02:44] * colomon is trying to figure out why Testing / perl6-Testing doesn't appear in the ecosystem as far as Panda is concerned.

[02:44] <Radvendii> what's the new syntax for this *or* that

[02:44] <Radvendii> nom: my $a = "[baz|foo]"; say "foobar" ~~ /$a/;

[02:44] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[02:45] <TimToady> you can't just match it as a string

[02:45] <TimToady> you have to force it to interpret it as a regex

[02:45] <TimToady> nom: my $a = "[baz|foo]"; say "foobar" ~~ /<$a>/

[02:45] <p6eval> nom a47a56: OUTPUT«=> <foo>␤␤»

[02:46] <TimToady> regexes are not strings in Perl 6

[02:46] <TimToady> so you can't use string interpolation to interpolate regex

[02:46] <Radvendii> TimToady: a-ah, thanks

[02:46] <Radvendii> and what's the difference between <[]> and [] inside regex?

[02:47] <TimToady> S05 explains all this

[02:47] <Radvendii> TimToady: thanks

[02:53] <Radvendii> nom: my @a = "[0|1]", "blah"; say "0" ~~ /<$a[0]>/

[02:53] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near "[0]>/"␤»

[02:54] <Radvendii> nom: my @a = "[0|1]", "blah"; say "0" ~~ /<@a[0]>/

[02:54] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤regex assertion not terminated by angle bracket at line 1, near "[0]>/"␤»

[02:54] <Radvendii> nom: my @a = "[0|1]", "blah"; say "0" ~~ /<{a[0]}>/

[02:54] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&a' called (line 1)␤»

[02:54] <Radvendii> nom: my @a = "[0|1]", "blah"; say "0" ~~ /<{@a[0]}>/

[02:54] <p6eval> nom a47a56: OUTPUT«=> <0>␤␤»

[02:54] <TimToady> \o/

[02:54] <Radvendii> there we go

[02:54] <Radvendii> :D

[02:54] <TimToady> yes, <{ ... }> is available for fancy stuff

[02:55] <Radvendii> these regex have such complicated syntax! (granted, i see that it's very powerful)

[02:55] <TimToady> it no more complicated than p5 regex, and much more powerful

[02:55] *** kmwallio joined
[02:56] <TimToady> well, maybe a little more complicated...but the simple things are simpler

[02:56] <Radvendii> well... i guess just different

[02:56] <TimToady> except for things we've intentionally dehuffmanized, like character classes

[02:57] <Radvendii> huffmanized?

[02:57] <Radvendii> humanized you mean?

[02:57] <TimToady> common things should be short, less common things should be longer

[02:57] <TimToady> a generalization of Huffman coding

[02:58] <TimToady> http://en.wikipedia.org/wiki/Huffman_coding

[02:59] <Radvendii> ah, i knew the philosophy, just not the name

[02:59] <TimToady> "Easy things should be easy, and hard things should be possible."

[03:00] <TimToady> but it's a design principle here that we think about how hard or easy we want things to be, and try to give them shorter or longer syntax to support that

[03:01] <TimToady> it's why "my" is shorter than "our", for instance

[03:02] <TimToady> and why verbs have an easier way to leave off sigils than nouns do, because good OO or FP programming tends to be verb heavy rather than noun heavy

[03:03] <Radvendii> huh. interesting

[03:03] <Radvendii> nom: $^a=5; say $a;

[03:03] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Cannot use placeholder parameter $^a in the mainline␤at /tmp/0TyJROvayV:1␤»

[03:03] <Radvendii> dang.

[03:04] <TimToady> nom: sub MAIN { say $^a }

[03:04] <p6eval> nom a47a56: OUTPUT«Usage:␤  --setting=SAFE <a>␤»

[03:05] <TimToady> nom: sub MAIN ($a = 5) { say $a }

[03:05] <p6eval> nom a47a56: OUTPUT«5␤»

[03:05] <Radvendii> i was just seeing if i could use $^a instead of my $a

[03:06] <Radvendii> nom: say (<a b c>,<d e f>).lol

[03:06] <p6eval> nom a47a56: OUTPUT«a b c d e f␤»

[03:06] *** wolfman2000 joined
[03:06] <TimToady> placeholders are only legal in curlies

[03:06] <Radvendii> nom: say (<a b c>.list,<d e f>.list).lol

[03:06] <p6eval> nom a47a56: OUTPUT«a b c d e f␤»

[03:06] <Radvendii> TimToady: i figured

[03:06] <Radvendii> nom: say (<a b c>,<d e f>).lol.perl

[03:06] <p6eval> nom a47a56: OUTPUT«LoL.new(("a", "b", "c"), ("d", "e", "f"))␤»

[03:07] <Radvendii> nom: say (<a b c>,<d e f>).lol.map: {$^a.say}

[03:07] <p6eval> nom a47a56: OUTPUT«a b c␤d e f␤True True␤»

[03:07] <Radvendii> nom: say (<a b c>,<d e f>).lol.map: {$^a.grep: {True}}

[03:07] <p6eval> nom a47a56: OUTPUT«a b c d e f␤»

[03:07] <Radvendii> nom: say ((<a b c>,<d e f>).lol.map: {$^a.grep: {True}}).perl

[03:07] <p6eval> nom a47a56: OUTPUT«("a", "b", "c", "d", "e", "f").list␤»

[03:07] <Radvendii> why doesn't the '.grep' hold onto the lol context?

[03:08] <timotimo> where do i look to find out things like "can i use SDL with perl6 yet?" searching perl6 on cpan only gives me modules for perl5 it seems

[03:08] <TimToady> might be a bug

[03:08] <TimToady> each map is supposed to return a Parcel

[03:08] *** imarcusthis joined
[03:08] <Radvendii> timotimo: there's panda

[03:08] <Radvendii> but im not sure if that works yet... i haven't gotten it too on my computer

[03:08] *** PacoAir left
[03:08] *** grizzlysmit left
[03:08] *** Trashlord left
[03:09] <Radvendii> TimToady: dang...

[03:09] <TimToady> nom: use SDL

[03:09] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Could not find SDL in any of: lib, /home/p6eval/.perl6/lib, /home/p6eval/nom-inst1/lib/parrot/4.0.0-devel/languages/perl6/lib, .␤»

[03:09] <TimToady> well, it worked at one point

[03:09] <TimToady> colomon: you know anything about s

[03:09] <TimToady> SDL?

[03:09] <timotimo> what is panda?

[03:10] <timotimo> i only know panda3d, but that's python/c++ stuff

[03:10] <Radvendii> by the way, why is perl6 called perl6 if it's not supposed to replace perl5, it makes search results very confused...

[03:10] <colomon> TimToady: not really.

[03:11] <Radvendii> timotimo: https://github.com/tadzik/panda

[03:11] <colomon> TimToady: doesn't seem to be much there yet

[03:12] <colomon> And it's from six months ago, so it probably doesn't work with nom yet.

[03:12] <TimToady> parrot has SDL, so maybe it's accessible

[03:13] <colomon> it's using NativeCall

[03:14] <Radvendii> nom: say ((<a b c>,<d e f>).lol.map: {$^a.grep(/< a b c d >}).perl

[03:14] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter (must be quoted to match literally) at line 1, near " a b c d >"␤»

[03:14] <Radvendii> nom: say ((<a b c>,<d e f>).lol.map: {$^a.grep(/< a b c d >/).perl

[03:14] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Unrecognized regex metacharacter (must be quoted to match literally) at line 1, near " a b c d >"␤»

[03:15] <Radvendii> nom: say ((<a b c>,<d e f>).lol.map: {$^a.grep(/[a|b|c|d]/)).perl

[03:15] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[03:15] *** Trashlord joined
[03:15] <Radvendii> nom: say ((<a b c>,<d e f>).lol.map: {$^a.grep(/[a|b|c|d]/)}).perl

[03:15] <p6eval> nom a47a56: OUTPUT«("a", "b", "c", "d").list␤»

[03:16] *** imarcusthis left
[03:16] <TimToady> nom: <a b c>.map({ 1,2,3 }).perl.say

[03:16] <p6eval> nom a47a56: OUTPUT«((1, 2, 3), (1, 2, 3), (1, 2, 3)).list␤»

[03:17] <TimToady> nom: <a b c>.map({ (1,2,3).grep: * % 2 }).perl.say

[03:17] <p6eval> nom a47a56: OUTPUT«(1, 3, 1, 3, 1, 3).list␤»

[03:18] <TimToady> nom: <a b c>.map({ ((1,2,3).grep: * % 2)  }).perl.say

[03:18] <p6eval> nom a47a56: OUTPUT«(1, 3, 1, 3, 1, 3).list␤»

[03:18] <TimToady> nom: <a b c>.map({ ((1,2,3).grep: * % 2),  }).perl.say

[03:18] <p6eval> nom a47a56: OUTPUT«(((1, 3).list,), ((1, 3).list,), ((1, 3).list,)).list␤»

[03:18] <TimToady> yes, for some reason the map isn't returning the grep's result as a subparcel

[03:19] <sorear> colomon: it's not getting "carried away", it's a deliberate decision - when something can't work, we SORRY at compile time

[03:19] <TimToady> it can work if it's in a try though

[03:19] <colomon> exactly

[03:19] <TimToady> which is why Ada only replaced such with a run-time throw

[03:19] *** xith_kymous joined
[03:24] <TimToady> also, it's a bit of a jump from "allowed to complain" to "dies with SORRY"

[03:26] *** kmwallio left
[03:27] <TimToady> I'd put it more in the category of a warning that can be suppressed with #OK

[03:29] <Radvendii> TimToady++ #workaround with extra ','

[03:38] *** tokuhir__ left
[03:40] <Radvendii> .grep being lazy keeps giving me problems...

[03:40] <Radvendii> (until i realize what's happening)

[03:44] <Radvendii> nom: say (<a b c>, <d e f>).list.lol

[03:44] <p6eval> nom a47a56: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <anon> at /tmp/s7b1VmwvG3:1␤  in <anon> at /tmp/s7b1VmwvG3:1␤»

[03:44] <Radvendii> grrr.... the problem is that a bunch of functions return stuff in .list format, which then get's flattened

[03:45] <Radvendii> nom: say (<a b c>, <d e f>).lol.map({$_}).perl

[03:45] <p6eval> nom a47a56: OUTPUT«(("a", "b", "c"), ("d", "e", "f")).list␤»

[03:45] <Radvendii> nom: say (<a b c>, <d e f>).lol.map({$_}).say

[03:45] <p6eval> nom a47a56: OUTPUT«a b c d e f␤True␤»

[03:46] <Radvendii> aaand what?

[03:46] <Radvendii> nom: (<a b c>, <d e f>).lol.map({$_})>>.say

[03:46] <p6eval> nom a47a56: OUTPUT«d e f␤a b c␤»

[03:46] <Radvendii> hmm...

[03:47] <Radvendii> nom: ((("00", "10").list,), (("101",).list,)).list>>.say

[03:47] <p6eval> nom a47a56: OUTPUT«00␤101␤10␤»

[03:47] <Radvendii> oh. it does them in a random order?

[03:47] <Radvendii> that's odd

[03:48] <Radvendii> but still, why is it separating them all with '\n's

[03:48] <Radvendii> <a b c>.say

[03:48] <TimToady> hypers are unordered

[03:48] <Radvendii> nom: <a b c>.say

[03:48] <p6eval> nom a47a56: OUTPUT«a b c␤»

[03:48] <Radvendii> TimToady: yeah, i figured

[03:48] <TimToady> (in side effects)

[03:48] <TimToady> not in result

[03:49] <Radvendii> but still, shouldn't it be printing 101\n00 10?

[03:49] <Radvendii> because the lists are (("00", "10"), ("101"))

[03:50] <Radvendii> nom: (("00", "10"), ("101"))>>.say

[03:50] <p6eval> nom a47a56: OUTPUT«10␤101␤00␤»

[03:50] <Radvendii> ôʃō

[03:50] <Radvendii> nom: (("00", "10"), ("101")).lol>>.say

[03:50] <p6eval> nom a47a56: OUTPUT«00 10␤101␤»

[03:50] <Radvendii> nom: (("00", "10"), ("101")).list>>.say

[03:51] <p6eval> nom a47a56: OUTPUT«00␤10␤101␤»

[03:51] <Radvendii> nom: (("00", "10"), ("101")).list.lol>>.say

[03:51] <p6eval> nom a47a56: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <anon> at /tmp/RaGXT4Rm7f:1␤  in <anon> at /tmp/RaGXT4Rm7f:1␤»

[03:51] <Radvendii> is there any way to get rid of the .list status so i can make it .lol?

[03:51] <Radvendii> nom: (("00", "10"), ("101")).list.item.lol>>.say

[03:51] <p6eval> nom a47a56: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <anon> at /tmp/ydP_BI11Fe:1␤  in <anon> at /tmp/ydP_BI11Fe:1␤»

[03:52] <Radvendii> nom: (("00", "10"), ("101")).list.item.perl.say

[03:52] <p6eval> nom a47a56: OUTPUT«(("00", "10"), "101").list.item␤»

[03:53] *** orafu left
[03:54] <Radvendii> nom: (("00", "10"), ("101")).list.perl.subst('list', 'lol').eval.say

[03:54] <p6eval> nom a47a56: OUTPUT«00 10 101␤»

[03:54] <Radvendii> nom: (("00", "10"), ("101")).list.perl.subst('list', 'lol').eval.perl.say

[03:54] <p6eval> nom a47a56: OUTPUT«LoL.new(("00", "10"), "101")␤»

[03:54] <Radvendii> :P

[03:54] <Radvendii> that's what i want to do

[03:54] <Radvendii> except less kludgy

[03:55] <Radvendii> because i'm sure regex-replacing a .perl and then '.eval'ing that is *really* bad practice

[03:55] <Radvendii> nom: (("00", "10"), ("101")).list.perl.subst('list', '').eval.perl.say

[03:55] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤Confused␤at /tmp/47j5BT3EdP:1␤»

[03:55] <Radvendii> nom: (("00", "10"), ("101")).list.perl.subst('.list', '').eval.perl.say

[03:55] <p6eval> nom a47a56: OUTPUT«(("00", "10"), "101")␤»

[03:58] <Radvendii> any ideas guys?

[03:58] <Radvendii> sorry, i can figure it out. no worries

[03:58] *** orafu joined
[04:00] *** whiteknight left
[04:02] <sorear> TimToady: I do not understand the purpose of folding a throw.

[04:03] <sorear> TimToady: why replace "1 / 0" with "die 'Division by zero'"?  Or rather, why did Ada do that?

[04:03] <sorear> TimToady: did Ada programs often have a problem with 1 / 0 not being fast enough?

[04:10] <TimToady> the point was not to gratuitously change the semantics, I suspect

[04:12] <eviltwin_b> IIRC that was actually specified originally, that optimizations were not allowed to change semantics, so they had to fold it that way to be compliant

[04:16] <eviltwin_b> (also meant many optimizations common in other languages couldn't be considered because they changed the operational semantics in some corner cases)

[04:21] <Radvendii> nom: https://gist.github.com/1742671

[04:21] <p6eval> nom a47a56: OUTPUT«Nominal type check failed for parameter ''; expected Int+{MyRole} but got Int+{MyRole} instead␤  in method test at /tmp/UhkJ_27AhL:2␤  in block <anon> at /tmp/UhkJ_27AhL:20␤  in <anon> at /tmp/UhkJ_27AhL:1␤»

[04:21] <Radvendii> anyone got a second to check that out? might be a bug...

[04:21] <sorear> TimToady: no, I'm wondering why not just leave it as "1 / 0"

[04:22] <eviltwin_b> again, braindamaged spec

[04:22] <sorear> Radvendii: I agree with nom.

[04:22] <eviltwin_b> there's a reason most of the world looked at the original Ada spec and said "are you nuts?" and ignored it

[04:23] <Radvendii> sorear: what's wrong then?

[04:23] <Radvendii> what's parameter ''?

[04:23] <sorear> "self", apparently

[04:23] <sorear> what's wrong is that you wrote an impure FETCH method

[04:23] <Radvendii> impure?

[04:23] <sorear> FETCH should return the same value if it's called twice in a row

[04:24] <Radvendii> and it does...

[04:24] <sorear> no, it doesn

[04:24] <sorear> 't

[04:24] <sorear> every time that FETCH method is called, it calls &infix:<but>, which constructs a new anonymous subclass of Int

[04:24] <eviltwin_b> Radvendii, each "but" creates a new anonymous class

[04:25] <eviltwin_b> so, LTA error, but otherwise correct

[04:25] <sorear> eviltwin_b: I'm curious what in the spec was sufficiently braindamaged to *require* folding 1/0 to die("Divide by zero")

[04:26] <eviltwin_b> I don't remember details, but the original spec was a masterpiece of overspecification

[04:26] <Radvendii> eviltwin_b: so what do i do? if i return $.b does MyRole it stacks the MyRoles so that it has Int+{MyRole}+{MyRole}+{MyRole}...

[04:26] *** simcop2387 left
[04:27] <Radvendii> nom: https://gist.github.com/1742671

[04:27] <p6eval> nom a47a56: OUTPUT«Nominal type check failed for parameter ''; expected Int+{MyRole} but got Int+{MyRole} instead␤  in method test at /tmp/plCaSzm_o5:2␤  in block <anon> at /tmp/plCaSzm_o5:20␤  in <anon> at /tmp/plCaSzm_o5:1␤»

[04:27] *** xith_kymous left
[04:27] <sorear> I have a hunch that whatever you're trying to do, can be done more easily by not using roles or Proxy at all

[04:28] *** simcop2387 joined
[04:29] *** araujo left
[04:30] <Radvendii> sorear: 1) it does require Proxy because what i'm trying to do involeves at_key 2) i'm trying to make every value of the hash be able to have a method called on them

[04:32] <Radvendii> (i'm not using at_key in the example because I wanted to keep it as simple as possible)

[04:39] <Radvendii> sorear: ôʃō? what were you suggesting I do?

[04:39] *** simcop2387 left
[04:39] *** simcop2387 joined
[04:39] <sorear> erm, have you tried ... putting values of the correct type in the hash to begin with?

[04:40] <sorear> and just using a vanilla hash, not some weird custom thing

[04:46] <Radvendii> vanilla hash?

[04:49] <Radvendii> nom: https://gist.github.com/1742709

[04:49] <p6eval> nom a47a56:  ( no output )

[04:50] <Radvendii> nom: https://gist.github.com/1742709

[04:50] <p6eval> nom a47a56: OUTPUT«Scalar()␤»

[04:50] <Radvendii> that's what happens when i try putting "values of the correct type in the [variable] to begin with"

[04:55] <TimToady> sorear++ is trying to suggest that you have an XY problem, and that you might well do better by a completely different approach to your problem, by not using FETCH or proxies AT ALL.

[04:57] <TimToady> http://meta.stackoverflow.com/questions/66377/what-is-the-xy-problem

[05:04] *** drbean left
[05:05] <Radvendii> that's why i incuded information about what i wanted to do... i want to have each element of the hash be able to do a method, on itself. one way to do this would be to have it be a method to the hash like %hash.delete(key) OR i could do it as an adverb (e.g. %hash<key> :delete) but that's NYI, so i opted to go with %hash<key>.delete any other suggestions? (i'm not actually doing this with "delete")

[05:05] *** drbean joined
[05:07] <TimToady> that's the X, what's your Y?

[05:10] <Radvendii> wait... what? i'm confused, which is which? i thought X is what one is supposed to give?

[05:26] <Radvendii> TimToady: ...?

[05:30] <sorear> nom needs a more strongly worded error message for people who try to do "3 does SomeRole"

[05:33] <Radvendii> why? it's supposed to be "3 but SomeRole"?

[05:33] *** xinming left
[05:40] <sorear> yes

[05:40] <sorear> "does" modifies the LHS in place

[05:42] *** xinming joined
[05:59] <Radvendii> right, i tried it with "but" also

[06:02] *** tokuhir__ joined
[06:02] <dalek> niecza: d61f697 | sorear++ | src/NieczaPassSimplifier.pm6:

[06:02] <dalek> niecza: Change constant folding failure to be a warning

[06:02] <dalek> niecza: review: https://github.com/sorear/niecza/commit/d61f697fb0

[06:15] <Radvendii> TimToady: What do you want me to tell you? what i want to do, or how i want to do it?

[06:23] *** awoodland left
[06:44] *** cooper left
[06:52] *** ponbiki joined
[06:53] *** Chillance left
[06:54] *** Chillance joined
[06:55] *** Chillance left
[07:03] *** rasto left
[07:14] *** zby_home_ joined
[07:16] *** imarcusthis joined
[07:18] *** rasto joined
[07:20] *** kaare_ joined
[07:27] *** imarcusthis left
[07:30] *** alvis left
[07:31] *** abhishekisnot joined
[07:32] *** araujo joined
[07:32] *** araujo left
[07:32] *** araujo joined
[07:32] *** abhishekisnot left
[07:34] *** alvis joined
[07:39] *** rasto left
[07:57] *** birdwindupbird joined
[08:00] *** imarcusthis joined
[08:02] *** Trashlord left
[08:04] *** Trashlord joined
[08:10] *** imarcusthis left
[08:15] *** imarcusthis joined
[08:24] *** mucker joined
[08:50] *** birdwindupbird left
[08:53] *** tokuhir__ left
[08:55] *** birdwindupbird joined
[08:58] *** cognominal left
[09:00] *** cognominal joined
[09:11] *** drbean left
[09:11] *** drbean joined
[09:13] *** birdwindupbird left
[09:15] *** birdwindupbird joined
[09:24] *** birdwindupbird left
[09:47] *** ponbiki left
[09:47] *** Psyche^ joined
[09:48] *** Patterner left
[09:48] *** Psyche^ is now known as Patterner

[09:53] *** Pzter left
[09:54] *** PZt joined
[10:10] *** GlitchMr joined
[10:14] <jnthn> morning, #perl6

[10:14] <tadzik> good morning

[10:17] <jnthn> tadzik: omg, early for you! :)

[10:18] <tadzik> yeah ;)

[10:18] * jnthn would probably still be snoozing if he didn't have a train to catch in the near future

[10:24] *** Trashlord left
[10:32] *** mj41 joined
[10:33] *** Trashlord joined
[10:58] *** spine joined
[11:00] <jnthn> station &

[11:03] *** y3llow left
[11:03] *** y3llow joined
[11:19] *** drbean left
[11:20] *** drbean joined
[11:26] <masak> afternoon, #perl6

[11:27] <masak> man, I'm up after tadzik today... :P

[11:28] <masak> [backlog] waiwait, type coercions like $obj.Str don't call a .Str method, but get snatched up by the parser as special cases?

[11:28] <masak> then what have I been doing declaring .Str methods in my classes up until now? :/

[11:29] <tadzik> hahaha!

[11:29] <masak> <TimToady> otoh, we didn't have .& back then

[11:30] <masak> it's funny -- .& wasn't added, it was *discovered*.

[11:30] <masak> it fell out of all the other stuff we had. :)

[11:31] <masak> also, I must confess I still don't grok the "method/submethod semantics" distinction.

[11:31] <masak> even though I can speak the words and do the dance moves, I don't feel it in my bones.

[11:33] *** drbean left
[11:35] *** drbean joined
[11:37] *** Trashlord left
[11:41] *** tarch joined
[11:47] *** drbean left
[11:48] *** drbean joined
[11:52] *** jaldhar left
[11:54] *** jaldhar joined
[11:56] *** birdwindupbird joined
[12:05] *** awoodland joined
[12:09] *** awoodland left
[12:15] *** iktome joined
[12:15] *** iktome left
[12:17] *** tarch left
[12:25] *** drbean left
[12:28] *** drbean joined
[12:28] *** icwiener joined
[12:29] <colomon> So, do we really want postfix:<++> and postfix:<--> to be part of the KeySet interface?

[12:30] <colomon> ie $keyset<foo>++ to add "foo" to the KeySet, and $keyset<foo>-- to remove it?

[12:32] * colomon has an efficient implementation of KeySet using Proxy and $keyset<foo> = True and $keyset<foo> = False, but isn't sure how to make postfix:<++> and postfix:<--> work efficiently.

[12:33] *** fasad joined
[12:39] *** drbean left
[12:42] *** drbean joined
[12:42] <masak> colomon++

[12:42] <masak> setting to True and False sounds like a very solid start.

[12:43] <masak> the postfix:<++>, postfix:<--> has that $| feel to it.

[12:43] <masak> but I actually don't quite know how Bool behaves in this regard in Perl 6 in general.

[12:43] <masak> time to experiment :)

[12:44] <masak> perl6: my Bool $b; say $b; $b++; $b++; say $b; $b--; say $b; $b--; say $b

[12:44] <p6eval> niecza v14-15-gd61f697: OUTPUT«Bool()␤True␤False␤False␤»

[12:44] <p6eval> ..pugs b927740: OUTPUT«Bool␤2␤1␤0␤»

[12:44] <p6eval> ..rakudo a47a56: OUTPUT«Bool()␤Type check failed in assignment to '$b'; expected 'Bool' but got 'Int'␤  in sub postfix:<++> at src/gen/CORE.setting:1241␤  in block <anon> at /tmp/Y9i3pF5TWX:1␤  in <anon> at /tmp/Y9i3pF5TWX:1␤»

[12:44] *** whiteknight joined
[12:44] <masak> I'm with Niecza on this one.

[12:45] <masak> but it's a deviation from how enum types behave in general, I guess...

[12:48] *** simcop2387 left
[12:48] *** simcop2387_ joined
[12:48] *** simcop2387_ is now known as simcop2387

[12:53] *** drbean left
[12:53] *** drbean joined
[12:59] <colomon> masak: is it? 

[13:00] *** grondilu joined
[13:00] <grondilu> perl6: class Foo {}; package Bar { our Foo $foo .= new; }

[13:00] <colomon> perl6: enum Test <a b c d>; my $a = Test::a; $a++; $a++; $a++; $a++; $a++; say $a

[13:00] <p6eval> pugs b927740:  ( no output )

[13:00] <p6eval> ..niecza v14-15-gd61f697: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Common variables are not unique definitions and may not have types at /tmp/vM51MdmbrY line 1:␤------> [32mlass Foo {}; package Bar { our Foo $foo [33m⏏[31m.= new; }[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eva…

[13:00] <p6eval> ..rakudo a47a56: OUTPUT«===SORRY!===␤Cannot put a type constraint on an 'our'-scoped variable at line 1, near " .= new; }"␤»

[13:00] <p6eval> rakudo a47a56: OUTPUT«5␤»

[13:00] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/StCuFEg4o7 line 1, column 1-20␤»

[13:00] <p6eval> ..niecza v14-15-gd61f697: OUTPUT«d␤»

[13:00] <grondilu> perl6: class Foo {}; package Bar { our Foo $foo .= new; }

[13:00] <p6eval> pugs b927740:  ( no output )

[13:00] <p6eval> ..rakudo a47a56: OUTPUT«===SORRY!===␤Cannot put a type constraint on an 'our'-scoped variable at line 1, near " .= new; }"␤»

[13:00] <p6eval> ..niecza v14-15-gd61f697: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Common variables are not unique definitions and may not have types at /tmp/w8L4y8zCMD line 1:␤------> [32mlass Foo {}; package Bar { our Foo $foo [33m⏏[31m.= new; }[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eva…

[13:01] <grondilu> rakudo doesn't accept 'our'-scoped member variables??

[13:03] *** simcop2387_ joined
[13:03] *** simcop2387_ left
[13:04] *** simcop2387_ joined
[13:04] *** simcop2387 left
[13:04] *** simcop2387_ is now known as simcop2387

[13:05] *** tokuhirom joined
[13:05] <colomon> nom:  class Foo {}; package Bar { our $foo .= new; }

[13:06] <p6eval> nom a47a56:  ( no output )

[13:20] <tadzik> grondilu: doesn't accept type constraint, it seems

[13:24] * masak wonders why

[13:30] *** Trashlord joined
[13:33] *** MayDaniel joined
[13:33] *** MayDaniel left
[13:34] *** MayDaniel joined
[13:34] *** MayDaniel left
[13:35] <arnsholt> masak: I suspect that Niecza's error may be a clue, but I don't quite get what it means

[13:36] <masak> oh!

[13:36] <masak> I know what it is.

[13:36] <masak> Perl 6 has to do "unification" of packages during 'use' and import and stuff.

[13:37] <masak> that's where one variable could be defined in two places, and conceivably that could lead to contradictions if the variables could be typed.

[13:37] <masak> oh!

[13:37] <masak> it's simpler than that -- even inside of one packages, several 'our'-scoped declarations of the same variable can be made.

[13:37] *** xinming left
[13:38] <fasad> what does "Mu" mean?

[13:38] <masak> it's the type at the top/base of the type system.

[13:39] <masak> at least of the Perl 6 type system :) other types outside that may exist.

[13:39] <masak> it used to be called "Object", but TimToady changed it.

[13:40] <masak> it *means* a lot of things. see S02:1250 for the list.

[13:41] <masak> mostly, I suspect, it's a reference to the Japanese term for nothingness, 無

[13:41] * fasad wants the S02:1250 to be clickable !

[13:41] <masak> it is in the logs.

[13:41] <masak> http://irclog.perlgeek.de/perl6/2012-02-05#i_5105140

[13:41] <arnsholt> fasad: http://irclog.perlgeek.de/perl6/2012-02-05

[13:42] <fasad> yeah, but i need to refresh the log everytime :(

[13:42] <masak> but it also ties nicely in with the Hofstadterian "this answer is outside of the range of possible answers".

[13:42] * fasad wants a bot

[13:42] <masak> write an IRC client (or plugin) that highlights the links for you.

[13:42] * masak should do that hisself

[13:42] <masak> irssi is open-source, right? :D

[13:43] <fasad> masak++

[13:43] *** xinming joined
[13:43] *** PacoAir joined
[13:43] <masak> it is. GNU-licensed, and in an svn repo, which means I could use git-svn with it. \o/

[13:44] <masak> (spend the past week speaking warmly of git, and how even when you're cursed with lesser VCSes X, you can often use git-X and live in a slightly better world.)

[13:51] <fasad> TimToday's rosettacode userpage says his Perl 6 proficeincy is "Mu", hehe :)

[13:53] *** tokuhirom left
[13:55] *** birdwindupbird left
[13:55] *** shinobicl___ joined
[13:56] <masak> and his Perl (5) prodiciency is "Regrettable" :P

[13:56] <masak> proficiency*

[13:56] *** tokuhirom joined
[13:57] <masak> I guess it's fair to say that the "proficiency landscape" for Perl 6 is still very much in flux.

[13:58] <masak> or it's a bit like a storm, and TimToady is in its eye.

[13:58] <fasad> :)

[13:59] * masak crafts a blog post about blog engine ambitions

[14:03] *** Radvendii left
[14:06] *** grondilu left
[14:10] * fasad has been reading TimToady as TimToday the whole time and has just noticed it !! Unbelievable !

[14:10] <fasad> thankfully, perl6 wants every variablt ot be declared :p

[14:10] <fasad> *variable

[14:10] <fasad> *to

[14:13] *** tokuhirom left
[14:13] *** icwiener left
[14:22] *** tarch joined
[14:22] *** BooK__ left
[14:22] *** BooK_ joined
[14:40] *** shinobicl___ left
[14:47] *** DarthGandalf left
[14:50] *** DarthGandalf joined
[14:57] *** DarthGandalf left
[15:01] *** Su-Shee joined
[15:01] <Su-Shee> hi all.

[15:06] <colomon> o/

[15:12] *** mucker left
[15:12] <masak> Su-Shee! \o/

[15:12] <masak> we've missed you!

[15:15] <Su-Shee> I had a Perl crisis and had to dip into other languages. ;)

[15:17] *** Some-body_ joined
[15:19] <masak> understandable. :) welcome back!

[15:19] <masak> which other languages did you dip into?

[15:20] <Su-Shee> more smalltalk and I did some ruby and python at work... 

[15:21] <masak> nice.

[15:22] <masak> blog post! http://strangelyconsistent.org/blog/a-four-quarter-plan-for-psyde

[15:22] <Su-Shee> kind of.. I realize every time how few things I really miss in Perl.. ;) 

[15:25] <masak> is that so? I usually feel I miss a host of things when I'm not coding in Perl 5 or Perl 6.

[15:25] <masak> I even miss a bunch of Perl 6 things when I code in Perl 5, though those can usually be worked around or found in modules.

[15:26] <Su-Shee> that's what I mean.. I do stuff in other languages and realize that there are only a very few things I miss in Perl...

[15:28] *** Some-body_ left
[15:29] <masak> oh, ok.

[15:30] <masak> mostly it seems to me that people's objections to other languages, and their preferences for one language over another, are rooted in the fact that they've used some runtime enough to evolve high levels of sympathy with its semantics, and so everything else will feel strange.

[15:31] <masak> so most discussions about the relative merits of various languages read to me like "I like weaing my shirt but not your shirt, I dunno, there's just something about the texture that doesn't feel right".

[15:31] <Su-Shee> I've mostly missed a certain whipuptitude-feeling in other languages and I really really hate "a match object" when working with regex. :)

[15:32] <masak> I've been having a strong sense of that feeling of whipuptitude when writing Perl 6 in Niecza lately.

[15:33] <masak> mostly I just write out the program in near-pseudocode (this is a programmer's way of saying "I don't even notice the syntax anymore"), and it mostly just works!

[15:34] <masak> thing with junctions especially tend to read really well.

[15:34] <Su-Shee> the image-based thing in smalltalk is extremely nice, this "hack as you go operate on the open heart" feeling is quite nice. 

[15:34] <masak> yeah. too bad images are a bit all-or-nothing.

[15:35] <masak> but a big ++ to interactive programming, and evolving code from REPL to program. I should do that more.

[15:35] <masak> apparently SLIME in Emacs is really good for that as well.

[15:35] <Su-Shee> it's a very closed ecosystem. nonetheless the convenience for the developer is amazing. smalltalks web framework doesn't even distinguish between "the webpade you're having in the browser in developer mode" and "the code on the server"

[15:36] <Su-Shee> "webpage"

[15:36] *** Some-body_ joined
[15:37] <masak> sould that be Seaside?

[15:37] <masak> would*

[15:38] <Su-Shee> yes, but I think others support it as well. but: they're all extremely unrestful, very tightly coupled. they gave productivity and development speed the clear preference.

[15:40] <Su-Shee> mostly I realized that I would love to have that kind of development style as a window manager.

[15:40] *** Some-body_ left
[15:44] *** Some-body_ joined
[15:44] <masak> aye.

[15:46] *** Some-body_ left
[15:49] <Su-Shee> do I want star or rakudo january?

[15:49] <dalek> roast: f2903a0 | (Solomon Foster)++ | S02-types/keyset.t:

[15:49] <dalek> roast: Lots more KeySet tests, inspired by the Set tests.  Also fudge for Niecza.

[15:49] <dalek> roast: review: https://github.com/perl6/roast/commit/f2903a03ab

[15:50] *** Some-body_ joined
[15:50] *** Some-body_ left
[15:50] <colomon> Su-Shee: star

[15:51] <masak> they're the same compiler. but star has a bunch of modules and other goodies, too.

[15:51] <colomon> I thought star had a few days improvements over january

[15:53] *** Some-body_ joined
[15:55] <masak> quite possibly.

[15:56] <masak> I remember it though as the compiler release being delayed a bit less than a week so that no-one'd have to cut another compiler release just for the distribution.

[15:56] <Su-Shee> star already installed.. ;)

[15:59] <colomon> masak: turns out I hadn't actually made the $keyset<foo> = True form work yet, and when I did, the $keyset<foo>++ form just started working too.  I'm spectesting now.

[16:02] <masak> colomon<foo>++

[16:02] <masak> colomon: I'm eager to see that code.

[16:03] * moritz back

[16:05] *** jferrero left
[16:05] <masak> moritz! \o/

[16:11] <colomon> \o/

[16:11] <colomon> masak: the code is not terribly impressive, IMO.  but it gets the job done!

[16:13] <masak> that's what I'm interested in. I'm curious how to get started down the Proxy road.

[16:13] <moritz> jnthn: did you see the parrot-dev discussion about de-magicifying 'self'? does that require nqp/rakudo codegen chanegs?

[16:16] *** xinming left
[16:18] *** xinming joined
[16:20] <dalek> niecza: ea84dbe | (Solomon Foster)++ | / (2 files):

[16:20] <dalek> niecza: Working and reasonably efficient implementation of KeySet.

[16:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ea84dbe15d

[16:20] <dalek> niecza: 0ef17b0 | (Solomon Foster)++ | lib/CORE.setting:

[16:20] <dalek> niecza: Change $dummy to just $ to silence a warning.

[16:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0ef17b0425

[16:21] <colomon> whoops, just noticed Str, gist, and perl are clearly wrong. :)

[16:21] <colomon> need more tests!

[16:26] * masak looks at the code

[16:26] <masak> heh, Niecza really needs 'handles' :)

[16:27] <masak> it's syntactic sugar, but it's very nice sugar.

[16:28] <masak> that class would be very short indeed if it used 'handles'.

[16:29] <masak> anyway, colomon++

[16:30] <rafl> hello perl 6 peeps

[16:30] <colomon> \o

[16:30] <rafl> GSoC is starting up again and we're collecting project ideas at http://wiki.enlightenedperl.org/gsoc2012/ideas

[16:31] <colomon> Unless something unexpected happens (or someone beats me to it) I'll probably pound out KeyBag during the Super Bowl

[16:31] <rafl> could you have a go over the perl 6 projects there from last year and remove the ones that aren't in need of a student anymore and possibly add new ones as you see fit?

[16:32] <rafl> we're not in a rush at this point, but i'd like that page to be in a reasonable shape before the 9th of march for our organisation application to google

[16:37] <masak> rafl++ # for the heads-up

[16:38] <masak> I think the MMD optimization has been done at this point, or at least started.

[16:38] <masak> jnthn will know whether it should be changed or removed.

[16:38] <masak> XML parser binding is still needed, and a good GSoC project.

[16:39] <masak> I'm sure we can think up more.

[16:39] <rafl> super - thanks

[16:39] <cognominal> nom:   grammar A { rule TOP { ^ a }; token ws { \s+ } }; say A.parse('a')

[16:39] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[16:40] <cognominal> nom:   grammar A { rule TOP { ^ a }; }; say A.parse(' a')

[16:40] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[16:40] <cognominal> I am puzzled.

[16:43] <tadzik> yay, gsoc starts :)

[16:44] <rafl> still studying, huh? :)

[16:44] <tadzik> heh, well, studying

[16:45] <rafl> excellent! that's the best kind of studying there is :)

[16:45] <tadzik> I got tricked into this "student life" :P "it gets easier after the first year!" Yeah, right ;)

[16:46] <rafl> so does gsoc! :)

[16:46] <rafl> honest!

[16:46] <tadzik> dun'worry, I'm already decided :)

[16:46] <rafl> \o/

[16:46] <tadzik> it's way too fun to miss

[16:46] *** Radvendii joined
[16:47] <Radvendii> o/ #perl6

[16:47] <tadzik> hey Radvendii 

[16:47] <Radvendii> hey tadzik 

[16:47] * rafl schedules a welcome-go-gsoc beverage of his choice for tadzik early next month

[16:47] <rafl> *to

[16:48] <tadzik> \o/

[16:50] <arnsholt> masak: For the text-oriented graphics library, maybe TikZ can serve as some kind of inspiration?

[16:50] <Radvendii> nom: say <a b c>.map: {1,2,3}

[16:50] <p6eval> nom a47a56: OUTPUT«1 2 3 1 2 3 1 2 3␤»

[16:51] <Radvendii> nom: <a b c>.map({1,2,3}).perl.say

[16:51] <p6eval> nom a47a56: OUTPUT«((1, 2, 3), (1, 2, 3), (1, 2, 3)).list␤»

[16:51] <Radvendii> nom: <a b c>.map({1,2,3}).map({.say})

[16:51] <p6eval> nom a47a56:  ( no output )

[16:51] *** Chillance joined
[16:51] <Radvendii> nom: <a b c>.map({1,2,3}).map(*.say)

[16:51] <p6eval> nom a47a56:  ( no output )

[16:51] <Radvendii> nom: eager <a b c>.map({1,2,3}).map(*.say)

[16:51] <p6eval> nom a47a56: OUTPUT«1␤2␤3␤1␤2␤3␤1␤2␤3␤»

[16:52] <Radvendii> nom: eager <a b c>.map({1,2,3}).lol.map(*.say)

[16:52] <p6eval> nom a47a56: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <anon> at /tmp/KJo1O8MSfy:1␤  in <anon> at /tmp/KJo1O8MSfy:1␤»

[16:52] <Radvendii> grrr

[16:52] <Radvendii> it's doing this just to piss me off :P

[16:54] <Radvendii> nom: eager map {.say} <a b c>.map({1,2,3})

[16:54] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&c' called (line 1)␤Undefined routine '&b' called (line 1)␤Undefined routine '&a' called (line 1)␤»

[16:54] <Radvendii> nom: eager map {.say}, <a b c>.map({1,2,3})

[16:54] <p6eval> nom a47a56: OUTPUT«1␤2␤3␤1␤2␤3␤1␤2␤3␤»

[16:54] *** jferrero joined
[16:54] <fasad> "Pod ... is a purely descriptive mark-up notation, with no presentational components." What does it mean?

[16:55] <dalek> rakudo/nom: a177364 | tadzik++ | / (2 files):

[16:55] <dalek> rakudo/nom: Remove trailing whitespace in declarator blocks

[16:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a177364f19

[16:55] <tadzik> some official-ish blubber :) Whatcha wanna know? :)

[16:55] *** mj41 left
[16:56] <fasad> tadzik: "presentational components" ?

[16:56] <Radvendii> '.lol' is supposed to make something not flatten right?

[16:56] <tadzik> I have no idea what would that mean :)

[16:57] <Radvendii> so why can't i '.lol' a list?

[16:57] <tadzik> maybe 'supporting something for presentation writing?'. I have no idea, frankly

[16:57] <gfldex> fasad: it's not telling you how to display it

[16:57] <fasad> tadzik:no problem

[16:57] <cognominal> can someone comment the result I get with my grammars?

[16:57] <tadzik> nom: grammar A { regex TOP { ^ a }; }; say A.parse(' a')

[16:57] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[16:58] <tadzik> nom: grammar A { rule TOP { ^ ' a' }; }; say A.parse(' a')

[16:58] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[16:58] <cognominal> I would expect a match

[16:58] <tadzik> nom: grammar A { token TOP { ^ ' a' }; }; say A.parse(' a')

[16:58] <p6eval> nom a47a56: OUTPUT«=> < a>␤␤»

[16:58] <fasad> gfldex: bold, italics? "how to display" ?

[16:58] <fasad> gfldex: maybe if you contrast it with HTML i might get it

[16:59] <gfldex> fasad: if I call something bold and then display it as italics, will the universe stop dead?

[17:00] * tadzik afks

[17:00] *** jferrero left
[17:02] *** jferrero joined
[17:02] <cognominal> do you think it is a bug or, as usual, do I miss something?

[17:02] <fasad> gfldex: sorry for being cryptic. i meant, "how to display it" part was not clear to me. If you tell it to display something as bold, or in fixed-width font, i though you *were* telling it how to disply the text.

[17:02] <cognominal> masak, what do you think?

[17:02] <fasad> gfldex: anyways, nevermind.

[17:15] <skids> cognominal: My crazy wild-ass guess -- implicit <.ws> in rule is being put before ^, matches '', and then ^ doesn't match.

[17:16] <Radvendii> nom: say LoL(<a b c>.list)

[17:16] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&LoL' called (line 1)␤»

[17:16] <Radvendii> nom: say lol(<a b c>.list)

[17:16] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&lol' called (line 1)␤»

[17:17] <Radvendii> nom: say ~(<a b c>.list)

[17:17] <p6eval> nom a47a56: OUTPUT«a b c␤»

[17:17] <Radvendii> nom: say (<a b c>.list.eval.perl)

[17:17] <p6eval> nom a47a56: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&c' called (line 1)␤Undefined routine '&b' called (line 1)␤Undefined routine '&a' called (line 1)␤»

[17:18] <Radvendii> nom: say print (<a b c>.list)

[17:18] <p6eval> nom a47a56: OUTPUT«abcTrue␤»

[17:18] *** alvis left
[17:22] <cognominal> skids: may be. But it should match anyway. /me search the relevant S05 part

[17:22] <Radvendii> nom: eager (<a b c>.list.item.lol>>.say)

[17:22] <p6eval> nom a47a56: OUTPUT«Method 'lol' not found for invocant of class 'List'␤  in block <anon> at /tmp/Z3pbgpyEzg:1␤  in <anon> at /tmp/Z3pbgpyEzg:1␤»

[17:23] <Radvendii> nom: eager (<a b c>.list>>.item.lol>>.say)

[17:23] <p6eval> nom a47a56: OUTPUT«c␤b␤a␤»

[17:23] <Radvendii> nom: eager (<a b c>.list>>.item.lol.perl.say)

[17:23] <p6eval> nom a47a56: OUTPUT«LoL.new("a", "b", "c")␤»

[17:23] <Radvendii> nom: eager ((<a b c>, <d e f>).list>>.item.lol.perl.say)

[17:23] <p6eval> nom a47a56: OUTPUT«LoL.new("a", "b", "c", "d", "e", "f")␤»

[17:24] <cognominal> S05:355 says the <.ws> should not be implied before the ^

[17:24] <jnthn> moritz: (self changes) we don't rely on :method or self in NQP or Rakudo as far as I know.

[17:24] <jnthn> moritz: At most it's maybe in some obscure bits of PIR that we're going to kill soon anyway.

[17:25] <cognominal> jnthn, what do you think of this grammar problem?

[17:25] <jnthn> cognominal: Where?

[17:25] * jnthn hasn't backloggd besides where people addressed him :)

[17:26] <jnthn> cognominal: ah, I see

[17:26] <cognominal> nom: grammar A { rule TOP { ^ ' a' }; }; say A.parse(' a')

[17:26] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[17:26] <jnthn> cognominal: Well, it was correct.

[17:26] <jnthn> But TimToady changed sigspace rules not so long back, so I ain't so sure any more.

[17:27] <jnthn> nom: grammar A { rule TOP { ^' a' }; }; say A.parse(' a')

[17:27] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[17:27] <jnthn> hm

[17:27] <jnthn> OK, maybe something odd is going on there

[17:27] <jnthn> nom: grammar A { rule TOP {^' a' }; }; say A.parse(' a')

[17:27] <p6eval> nom a47a56: OUTPUT«=> < a>␤␤»

[17:27] <jnthn> oh, it's that.

[17:27] <jnthn> <.ws> snatches the space before the anchor.

[17:27] <jnthn> ^ then won't match

[17:28] <jnthn> And you wrote rule, which means no backtracking, so it fails immediately.

[17:28] <skids> nom: grammar A { rule TOP { a}; }; say A.parse(' a')

[17:28] <p6eval> nom a47a56: OUTPUT«=> < a>␤␤»

[17:28] <jnthn> I think the latest sigspace changes mean that we don't stick a <.ws> in where we're currently doing so, though. They probably fix this case to work as you expect. I didn't look at them closely yet.

[17:28] <skids> nom: grammar A { rule TOP {a}; }; say A.parse(' a')

[17:28] <p6eval> nom a47a56: OUTPUT«#<failed match>␤»

[17:29] <cognominal> so a regex would be more appropriate

[17:29] <jnthn> cognominal: Depends what you want. :)

[17:29] <jnthn> cognominal: If you can solve a problem without backtracking, it's preferable to not rely on it.

[17:30] *** tarch left
[17:31] <cognominal> TimToady pointed me yesterday to S05:319

[17:33] <cognominal> here S05:355 is relevant

[17:34] <moritz> I'm about to propose custom sprintf implementation for GSOC

[17:34] <moritz> who would be willing to mentor that?

[17:34] *** hundskatt left
[17:37] <Radvendii> nom: say "a\n\nb\n".subst(/^^$$/, 'HERE')

[17:37] <p6eval> nom a17736: OUTPUT«a␤HERE␤b␤␤»

[17:37] <Radvendii> shouldn't the last one match?

[17:37] <Radvendii> or does end of string not match end of line?

[17:37] <skids> .oO(Some people when faced with a problem think "Oh I know, I'll use a rule!" Then they have a significant problem space.)

[17:39] <moritz> Radvendii: .subst only substitutes once by default

[17:39] <moritz> Radvendii: use :g to change that

[17:39] <Radvendii> ooooh

[17:39] <Radvendii> right

[17:39] <Radvendii> thanks

[17:40] <Radvendii> skids: ô.ō

[17:40] <Radvendii> nom: say "a\n\nb\n".subst(:g, /^^$$/, 'HERE')

[17:40] <p6eval> nom a17736: OUTPUT«a␤HERE␤b␤␤»

[17:41] <Radvendii> º·º

[17:41] <masak> arnsholt: interesting. it's different enough for me to feel that I can add something by making my own, and yet it's fun to see someone work within the same problem space.

[17:41] <moritz> nom: print "a\n\nb\n".subst(:g, /^^[$|$$]/, 'HERE')

[17:41] <p6eval> nom a17736: OUTPUT«a␤HERE␤b␤»

[17:42] <Radvendii> nom: say "a\n\nb\n".subst(:g, /^^$/, 'HERE')

[17:42] <p6eval> nom a17736: OUTPUT«a␤␤b␤␤»

[17:42] <moritz> nom: say "a\n\nb\n".subst(:g, /^^/, 'START')

[17:42] <p6eval> nom a17736: OUTPUT«STARTa␤START␤STARTb␤␤»

[17:43] <Radvendii> ??ô.ō??

[17:44] <Radvendii> does it chomp it??

[17:44] <Radvendii> nom: say "a\n".perl

[17:44] <p6eval> nom a17736: OUTPUT«"a\n"␤»

[17:44] <Radvendii> nom: $a = "a\n"; say $a.perl

[17:44] <p6eval> nom a17736: OUTPUT«===SORRY!===␤Variable $a is not predeclared at line 1, near " = \"a\\n\"; "␤»

[17:44] <Radvendii> nom: my $a = "a\n"; say $a.perl

[17:44] <p6eval> nom a17736: OUTPUT«"a\n"␤»

[17:45] <Radvendii> shouldn't it print out a(weird super(N)sub(L))?

[17:45] <Radvendii> nom: my $a = "a\n\n"; say $a.perl

[17:45] <p6eval> nom a17736: OUTPUT«"a\n\n"␤»

[17:45] <Radvendii> nom: my $a = "a\n\nb"; say $a.perl

[17:45] <p6eval> nom a17736: OUTPUT«"a\n\nb"␤»

[17:45] <Radvendii> ...

[17:45] <Radvendii> oh

[17:45] <Radvendii> whoops

[17:45] <Radvendii> i forgot about .perl

[17:45] <Radvendii> :P

[17:45] <Radvendii> nom: my $a = "a\n\nb"; say $a

[17:45] <p6eval> nom a17736: OUTPUT«a␤␤b␤»

[17:45] <Radvendii> nom: my $a = "a\n\nb\n"; say $a

[17:45] <p6eval> nom a17736: OUTPUT«a␤␤b␤␤»

[17:46] <Radvendii> yeah... it's printing the newline right...

[17:46] <moritz> nom: say "\n".match(:g, /^^/).elems

[17:46] <p6eval> nom a17736: OUTPUT«1␤»

[17:46] <moritz> still I wonder why ^^ doesn't match after the final \n

[17:46] <Radvendii> it seems to be in .match

[17:46] <Radvendii> but not in .subst

[17:47] <Radvendii> nom: say "\n".subst(:g, /^^/, "BOO")

[17:47] <p6eval> nom a17736: OUTPUT«BOO␤␤»

[17:47] <Radvendii> ôʃō

[17:47] <Radvendii> it is...

[17:47] <Radvendii> nom: say "b\n".subst(:g, /^^/, "BOO")

[17:47] <p6eval> nom a17736: OUTPUT«BOOb␤␤»

[17:47] <Radvendii> nom: say "a\nb\n".subst(:g, /^^/, "BOO")

[17:47] <p6eval> nom a17736: OUTPUT«BOOa␤BOOb␤␤»

[17:48] <Radvendii> ooh... no it's not

[17:48] <Radvendii> with one \n it should match BOO twice

[17:49] <moritz> niecza: say "\n" ~~ m:g/^^/

[17:49] <p6eval> niecza v14-17-g0ef17b0: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Regex modifier g not yet implemented at /tmp/jooW9LOVqg line 1:␤------> [32msay "\n" ~~ m:g[33m⏏[31m/^^/[0m␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ␤  at /ho…

[17:49] <moritz> niecza: say "\n" ~~ m:c(1)/^^/

[17:49] <p6eval> niecza v14-17-g0ef17b0: OUTPUT«False␤»

[17:49] <moritz> niecza doesn't match there either

[17:49] <Radvendii> nom: say "a\n\nb\n".subst(:g, /\n[$|$$]/, 'HERE')

[17:49] <p6eval> nom a17736: OUTPUT«aHERE␤bHERE␤»

[17:49] <Radvendii> ## workaround

[17:50] <Radvendii> nom: say "a\n\nb\n".subst(:g, /\n[$|$$]/, '\nHERE') #better

[17:50] <p6eval> nom a17736: OUTPUT«a\nHERE␤b\nHERE␤»

[17:51] <Radvendii> is .perl going to be implementation independent?

[17:51] <Radvendii> so nom isn't going to switch it up on me?

[17:54] <moritz> note that this doesn't put a "HERE" before the first "a"

[17:54] <skids> I think the answer might be yes then no, because the spec could still be changed and nom would follow it -- but defer to experts.

[17:57] <masak> Radvendii: you shouldn't depend on the exact output of .perl

[17:57] <masak> Radvendii: if you do, "then you have two problems"

[17:57] <fasad> a small typo i noticed. while S26 talks about the '.contents' method, rakudo's pod test suite uses '.content'

[17:58] <Radvendii> masak: it's a workaround to begin with. nom is being a pain and not letting me .lol a .list

[17:58] *** icwiener joined
[17:58] <Radvendii> so i'm doing .perl.subst(/.list$/, '.lol').eval

[17:59] <Radvendii> which i understand is kludgy and bad practice

[17:59] <masak> oh yes.

[17:59] <Radvendii> but like i said, it's not working the normal way

[17:59] <masak> you're simply wanting a feature too early :)

[17:59] <masak> I've been in that position myself a few times :)

[18:00] <masak> I think you're best off reproducting the functionality you want using nested arrays instead of lists.

[18:00] <masak> let me see if I can throw together a quick example.

[18:00] <Radvendii> mhmm... it's kind of annoying writing something, saying "this *should* work. but doesn't" and then buckling down and writing a kludgy workaround

[18:01] <moritz> of course you're welcome to make it work in the first place

[18:01] <moritz> hacking a compiler is no magic, and you don't need a diplom to get started

[18:02] <Radvendii> :s but... but... i'll make it all not-optimized and all...

[18:02] <Radvendii> and it'll be full of bugs...

[18:03] <masak> nom: multi t(@a, &c) { [map { t $_, &c }, @a] }; multi t($i, &c) { &c($i) }; my @tree = [1, 2, [3, [4, 5], 6]]; say t(@tree, { $_ * 10 }).perl

[18:03] <p6eval> nom a17736: OUTPUT«[[10, 20, [30, [40, 50], 60]]]␤»

[18:03] <masak> there we go.

[18:03] <masak> something like that help?

[18:04] <masak> argh.

[18:04] <masak> nom: multi t(@a, &c) { [map { t $_, &c }, @a] }; multi t($i, &c) { &c($i) }; my $tree = [1, 2, [3, [4, 5], 6]]; say t($tree, { $_ * 10 }).perl

[18:04] <p6eval> nom a17736: OUTPUT«[10, 20, [30, [40, 50], 60]]␤»

[18:04] <jnthn> dinner &

[18:04] <masak> classic mistake :)

[18:05] <masak> Radvendii: my point is that you can write code that traverses nested arrays, and it doesn't take a lot of code, either.

[18:05] <Radvendii> huh...

[18:06] <Radvendii> but the whole point is that i _don't_ wan't to go that deep... i want to go only one layer in, and that's what .map is supposed to do

[18:06] <Radvendii> it just flattens *everything* at the moment

[18:06] <masak> sure, when you use lists.

[18:07] <masak> that's why I am suggesting you use nested arrays.

[18:07] <masak> LoLs will eventually do what you want, but they don't today.

[18:07] <masak> and trying to create LoLs from nothing today is more work than trying to use arrays for what you want to do.

[18:09] <Radvendii> i'm having trouble applying that to my situation, let me explain:

[18:09] <moritz> re full of bugs, that's why we write tests

[18:09] <moritz> all of us are writing code that's full of bugs.

[18:10] <Radvendii> masak: i have input in the form of a bunch of lines of a comma separated list

[18:10] <Radvendii> masak: so what i do is $*IN.lines>>.split(', ')

[18:10] *** IRCMonkey_ joined
[18:11] <Radvendii> now if i want to loop over the outer layer of arrays i do $*IN.lines>>.split(', ').lol.map: {...}

[18:11] <moritz> nom: say (1, 2, (3, 4)).lol.perl

[18:11] <p6eval> nom a17736: OUTPUT«LoL.new(1, 2, (3, 4))␤»

[18:11] <Radvendii> moritz: yeah i know, i'm just afraid of screwing stuff up for everyone else :P

[18:11] <moritz> Radvendii: don't be.

[18:12] <moritz> Radvendii: if it doesn't break the test suite, it's unlikely to be very, very wrong

[18:12] <Radvendii> moritz: mhmm...

[18:13] <Radvendii> masak: how would i do that without LoLs?

[18:13] <moritz> Radvendii: also I think you really need .tree (which is NYI), not .lol

[18:13] <moritz> or is it?

[18:13] <Radvendii> moritz: :P great. why, though?

[18:13] <moritz> nom: say (1, 2, (3, 4)).tree.perl

[18:13] <p6eval> nom a17736: OUTPUT«Method 'tree' not found for invocant of class 'Parcel'␤  in block <anon> at /tmp/wApUxnxnWz:1␤  in <anon> at /tmp/wApUxnxnWz:1␤»

[18:14] <moritz> nom: say (1, 2, (3, 4)).list.tree.perl

[18:14] <p6eval> nom a17736: OUTPUT«(1, 2, (3, 4)).list␤»

[18:14] <moritz> nom: say (1, 2, [3, 4]).perl

[18:14] <p6eval> nom a17736: OUTPUT«(1, 2, [3, 4])␤»

[18:14] <TimToady> my @AoA = $*IN.lines.map: { [.split(', ')] }

[18:14] <moritz> hm, seems it's there, but doesn't work

[18:15] <arnsholt> masak: Definitely. Being TeX, it's definitely not directly mappable to the web world (and the implementation is likely kinda twisted when seen with imperative glasses), but it does seem similarish to what you want

[18:15] <Radvendii> TimToady: hmm... i could do *that*... seems like that's what >>. was _made_ for, but hey, that's what i get for using a language in beta

[18:16] <TimToady> wanting to think in terms of >> and nothing else is where the XY problem comes from; now that you've actually said what you want, we can help

[18:16] <moritz> nom: say MapIter.new(:list(1, 2, (3, 4)), :block({ say "|$_|"}).list.eager

[18:16] <p6eval> nom a17736: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2␤»

[18:16] <moritz> nom: say MapIter.new(:list(1, 2, (3, 4)), :block({ say "|$_|"})).list.eager

[18:16] <p6eval> nom a17736: OUTPUT«Method 'gimme' not found for invocant of class 'Parcel'␤  in method reify at src/gen/CORE.setting:4475␤  in method reify at src/gen/CORE.setting:4380␤  in method gimme at src/gen/CORE.setting:4744␤  in method eager at src/gen/CORE.setting:4719␤  in block <anon> at /tm…

[18:17] <moritz> nom: say MapIter.new(:list((1, 2, (3, 4)).list), :block({ say "|$_|"})).list.eager

[18:17] <p6eval> nom a17736: OUTPUT«|1|␤|2|␤|3 4|␤True True True␤»

[18:17] <moritz> nom: say MapIter.new(:list((1, 2, (3, 4)).list), :block({ say "|$_|"; my $ = $_})).list.eager

[18:17] <p6eval> nom a17736: OUTPUT«|1|␤|2|␤|3 4|␤1 2 3 4␤»

[18:17] <moritz> nom: say MapIter.new(:list((1, 2, (3, 4)).list), :block({ say "|$_|"; my $ = $_})).list.perl

[18:17] <p6eval> nom a17736: OUTPUT«|1|␤|2|␤|3 4|␤(1, 2, (3, 4)).list␤»

[18:18] <moritz> nom: say MapIter.new(:list((1, 2, (3, 4)).list), :block({ say "|$_|"; .elems == 1 ?? $_ !! [.list]})).list.perl

[18:18] <p6eval> nom a17736: OUTPUT«|1|␤|2|␤|3 4|␤(1, 2, [3, 4]).list␤»

[18:18] <Radvendii> TimToady: right... but why is >>.foo *there* if for a bunch of things you have to use .map(*.foo) anyways?

[18:18] <Radvendii> i guess when things are more fully implemented it'll work better

[18:19] <moritz> and if we manage to abolish duck mapping again

[18:19] <TimToady> we had a slogan in the early days of Perl 6 that still applies: It's a good thing there's more than one way to do it, because most of them are broken.

[18:19] <Radvendii> TimToady: hahahaha

[18:19] <Radvendii> TimToady: that's good.

[18:20] <TimToady> moritz: how can we abolish it? we've never even tried it...

[18:21] <Radvendii> what's duck this and duck that. i see it everywhere...

[18:21] <moritz> TimToady: well, we had a spec before duck mapping, and I think it was much saner

[18:22] <Radvendii> although i can't actualy remember any other occurences...

[18:22] <Radvendii> (at the moment)

[18:22] <TimToady> moritz: the only difference when you do something that didn't make any sense at all in the old case

[18:23] <TimToady> it now means something sane; how can this be worse

[18:23] <moritz> Radvendii: http://en.wikipedia.org/wiki/Duck_typing

[18:23] <moritz> TimToady: now code becomes more fragile when you decide to add a method in some class. I don't think that's a plus.

[18:23] <TimToady> it eliminates a FAQ; Why did my @array».[1] not work?

[18:24] <moritz> it would be much easier by speccing that ». only goes one level deep. Always.

[18:26] <TimToady> and would you impose similar restrictions on infix hypers, which currently can do cool APL semantics?

[18:26] <Su-Shee> Radvendii: it means that you treat/work on/decide/use objects via their methods "whichever fits" and not by type. If an object has an "add" method, then you call it and not go by "if int.. obj.add.."

[18:26] <Radvendii> ah

[18:27] <moritz> TimToady: no

[18:27] <TimToady> a flat hyper is just a hyper map, so why not make something a bit more useful?

[18:27] <Su-Shee> Radvendii: "the object knows what to do with its own methods". you'll see add (some numbers, add an item to something) or send (send an email, send a jabber message, send a data package) as examples.

[18:28] <moritz> because it's too easy to turn into a nasty surprise

[18:29] <TimToady> I deem this quite unlikely.

[18:29] <Su-Shee> nasty surprises can be sent and can be added, too. ;)

[18:30] <Radvendii> Su-Shee: i mean... it's kind of like calling foo($bar) you don't know what type of object $bar is necessarily. you trust that foo can handle it

[18:33] <Su-Shee> Radvendii: it's just an expression because in many languages you just don't need to be interested in an object's type that much - or wether it comes from the "proper" class. if you can call "send" on it, call it. period. 

[18:33] *** fasad left
[18:33] *** chra left
[18:33] <Radvendii> mhmm

[18:34] <Radvendii> mhmm

[18:34] <Su-Shee> Radvendii: think of it as a more bohemian OO instead of a more military hierachy one. ;) wave you hand, call the object's method and be done with it. ;)

[18:34] <Radvendii> that makes sense

[18:36] *** chra joined
[18:36] <Su-Shee> well in ruby/javascript/smalltalk/perl etc yes, in c++/java etc there are types. also, it's a different style of OO, trying not to care for the object's provenance so much. 

[18:37] *** wolfman2000 left
[18:50] <Su-Shee> Radvendii: here, this is one of the best articles about "OO is not little databases with attributes and inheritance" but "little objects sending each other messages" -> http://fitzgeraldnick.com/weblog/39/

[18:53] *** Chillance left
[18:54] *** Chillance joined
[18:59] <sorear> good * #perl6

[18:59] <masak> arnsholt: I think I need to write out some examples of what I want.

[18:59] <masak> sorear! \o/

[19:00] *** pernatiy left
[19:00] *** avarab is now known as avar

[19:01] *** birdwindupbird joined
[19:02] <arnsholt> masak: Actually I've been pondering a TeX/Sexp-inspired thing for blog comments/documents lately

[19:03] *** abhishekisnot joined
[19:05] *** abhishekisnot left
[19:10] <dalek> roast: 8ce3751 | moritz++ | S12-class/attributes.t:

[19:10] <dalek> roast: refudge attributes.t for rakudo

[19:10] <dalek> roast: review: https://github.com/perl6/roast/commit/8ce375166f

[19:13] *** abhishekisnot joined
[19:13] *** abhishekisnot left
[19:14] *** simcop2387 left
[19:15] *** simcop2387 joined
[19:16] *** awoodland joined
[19:18] <dalek> roast: 66b3e5c | moritz++ | S06-routine-modifiers/lvalue-subroutines.t:

[19:18] <dalek> roast: fix rakudo fudging of lvalue-subroutines.t

[19:18] <dalek> roast: review: https://github.com/perl6/roast/commit/66b3e5c1fe

[19:24] *** mj41 joined
[19:31] *** MayDaniel joined
[19:34] *** cosimo joined
[19:36] <dalek> roast: 04346b3 | moritz++ | S02-lists/tree.t:

[19:36] <dalek> roast: basic list.tree tests

[19:36] <dalek> roast: review: https://github.com/perl6/roast/commit/04346b3e47

[19:37] *** rajvm256 joined
[19:39] *** rajvm256 left
[19:40] *** MayDaniel left
[19:41] *** MayDaniel joined
[19:49] *** Radvendii left
[19:55] *** rindolf joined
[19:56] *** nebuchadnezzar left
[19:58] *** awoodland left
[20:01] *** nebuchadnezzar joined
[20:01] *** Patterner left
[20:02] *** MayDaniel left
[20:14] *** birdwindupbird left
[20:15] <dalek> rakudo/nom: 5a2c7d2 | moritz++ | / (3 files):

[20:15] <dalek> rakudo/nom: make List.tree more useful

[20:15] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5a2c7d279a

[20:16] *** zby_home_ left
[20:17] *** zby_home joined
[20:23] <moritz> nom: sub f(@ [$a, @r]) { say @r.perl }; f (1, 2, 3)

[20:23] <p6eval> nom a17736: OUTPUT«Nominal type check failed for parameter '@r'; expected Positional but got Int instead in sub-signature␤  in sub f at /tmp/eyhLPnvml1:1␤  in block <anon> at /tmp/eyhLPnvml1:1␤  in <anon> at /tmp/eyhLPnvml1:1␤»

[20:23] <moritz> nom: sub f(@ [$a, *@r]) { say @r.perl }; f (1, 2, 3)

[20:23] <p6eval> nom a17736: OUTPUT«Array.new(2, 3)␤»

[20:25] *** Psyche^ joined
[20:25] *** Psyche^ is now known as Patterner

[20:25] *** rindolf left
[20:26] <moritz> nom: say (1, (2, 3)).elems

[20:26] <p6eval> nom a17736: OUTPUT«2␤»

[20:26] <moritz> nom: say (1, (2, 3)).flat.elems

[20:26] <p6eval> nom a17736: OUTPUT«3␤»

[20:28] <masak> nom: role Foo[::T] { has T @.a = [T] }; class Bar {}; say Foo[Bar].new.a[0]

[20:28] <p6eval> nom a17736: OUTPUT«Cannot type check against type variable T␤  in type_check at src/gen/Metamodel.pm:271␤  in method at_pos at src/gen/CORE.setting:5213␤  in method at_pos at src/gen/CORE.setting:4706␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1140␤  in block <anon> at /tmp…

[20:28] <masak> jnthn: what's up with this?

[20:41] <jnthn> hm

[20:42] <jnthn> nom: (role Foo[::T] { has T @.a }).^attributes.perl.say

[20:42] <p6eval> nom 5a2c7d: OUTPUT«Could not instantiate role 'Foo':␤Not enough positional parameters passed; got 1 but expected 2␤  in specialize at src/gen/Metamodel.pm:1695␤  in <anon> at src/gen/Metamodel.pm:2075␤  in <anon> at src/gen/Metamodel.pm:2071␤  in compose at src/gen/Metamodel.pm:2069␤  i…

[20:42] <jnthn> oops

[20:42] <jnthn> nom: my $r = role Foo[::T] { has T @.a }; $r.HOW.attributes($r).perl.say

[20:42] <p6eval> nom 5a2c7d: OUTPUT«Method 'mro' not found for invocant of class 'Perl6::Metamodel::ParametricRoleHOW'␤  in <anon> at src/gen/Metamodel.pm:622␤  in parents at src/gen/Metamodel.pm:620␤  in attributes at src/gen/Metamodel.pm:342␤  in block <anon> at /tmp/QRW18phCpg:1␤  in <anon> at /tmp/Q…

[20:43] <jnthn> ...interesting.

[20:43] <jnthn> nom: my $r = role Foo[::T] { has T @.a }; $r.HOW.attributes($r, :local).perl.say

[20:43] <p6eval> nom 5a2c7d: OUTPUT«(Attribute.new(),)␤»

[20:43] <jnthn> nom: my $r = role Foo[::T] { has T @.a }; $r.HOW.attributes($r, :local).[0].type.perl.say

[20:43] <p6eval> nom 5a2c7d: OUTPUT«Positional␤»

[20:44] <jnthn> nom: my $r = role Foo[::T] { has T @.a }; $r.HOW.attributes($r, :local).[0].type.HOW.archetypes.generic

[20:44] <p6eval> nom 5a2c7d:  ( no output )

[20:44] <jnthn> nom: my $r = role Foo[::T] { has T @.a }; $r.HOW.attributes($r, :local).[0].type.HOW.archetypes.generic.say

[20:44] <p6eval> nom 5a2c7d: OUTPUT«1␤»

[20:44] *** Patterner left
[20:44] <jnthn> Hm, that much is right then.

[20:45] <jnthn> masak: Not sure without going for a deeper dig...some kind of generic instantiation failure.

[20:45] * masak submits rakudobug

[20:45] *** ksi joined
[20:46] <masak> does the spec spec what value a `while` loop returns?

[20:46] <masak> perl6: say (my $i = 0; while (++$i < 10) { $i }).perl

[20:46] <p6eval> niecza v14-17-g0ef17b0: OUTPUT«Nil␤»

[20:46] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected ";"␤    expecting "x", octal digit, "o", "b", fraction, exponent, term postfix, operator or ")"␤    at /tmp/0jLS93DJ2w line 1, column 15␤»

[20:46] <p6eval> ..rakudo 5a2c7d: OUTPUT«Bool::False␤»

[20:48] <jnthn> oh

[20:48] <moritz> nom: say do { while 0 { } }

[20:48] <p6eval> nom 5a2c7d: OUTPUT«0␤»

[20:49] <jnthn> nom: role Foo[::T] { has T @.a = [T] }; class Bar {}; say Foo[Bar].new.a[0]

[20:49] <p6eval> nom 5a2c7d: OUTPUT«Cannot type check against type variable T␤  in type_check at src/gen/Metamodel.pm:271␤  in method at_pos at src/gen/CORE.setting:5214␤  in method at_pos at src/gen/CORE.setting:4707␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1141␤  in block <anon> at /tmp…

[20:49] <moritz> it returns the last condition in nom

[20:49] <jnthn> nom: role Foo[::T] { has T @.a = [] }; class Bar {}; say Foo[Bar].new.a[0]

[20:49] <p6eval> nom 5a2c7d: OUTPUT«Cannot type check against type variable T␤  in type_check at src/gen/Metamodel.pm:271␤  in method at_pos at src/gen/CORE.setting:5214␤  in method at_pos at src/gen/CORE.setting:4707␤  in method postcircumfix:<[ ]> at src/gen/CORE.setting:1141␤  in block <anon> at /tmp…

[20:49] <jnthn> ah, ok, it is the failure in the place I expected then...

[20:49] * jnthn wondered for a moment if it was to do with the default closure or something

[20:52] *** Psyche^ joined
[20:52] *** Psyche^ is now known as Patterner

[21:05] <dalek> roast: 2ee3f57 | (Solomon Foster)++ | S02-types/keybag.t:

[21:05] <dalek> roast: Add a slew of new KeyBag tests, fudge for Niecza.

[21:05] <dalek> roast: review: https://github.com/perl6/roast/commit/2ee3f57109

[21:16] *** GlitchMr left
[21:32] <dalek> niecza: c83b9cd | (Solomon Foster)++ | / (2 files):

[21:32] <dalek> niecza: Simple implementation of KeyBag.

[21:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/c83b9cd3d6

[21:35] *** PZt left
[21:37] <sorear> ooooh

[21:38] *** Trashlord left
[21:39] <masak> colomon++

[21:39] <jnthn> That looks very easily Rakudo-able :)

[21:39] *** Trashlord joined
[21:40] <masak> and Rakudo has 'handles', too.

[21:40] <jnthn> yeah

[21:40] <jnthn> :)

[21:41] <jnthn> Well, I'll has plenty of tuits on Thursday, but anyone who feels like beating me to it can feel free :)

[21:41] <sorear> colomon: eeerm... what does submethod BUILD (%!elems) { } mean?

[21:41] <masak> needs a colon, p'haps?

[21:42] <sorear> ... I think the answer is "rely on the fact that niecza still implements named calling of positional parameters"

[21:44] <masak> oh noes

[21:46] <[Coke]> b: say 19605 - 19551 # 02/05/2012 - niecza at 99.72%

[21:46] <p6eval> b 1b7dd1: OUTPUT«54␤»

[21:46] <tadzik> perl6: say 19605 - 19551 # 02/05/2012 - niecza at 99.72%

[21:46] <p6eval> pugs b927740, rakudo 5a2c7d, niecza v14-17-g0ef17b0: OUTPUT«54␤»

[21:47] *** Patterner left
[21:47] *** kaare_ left
[21:48] <masak> perl6: say "I like yams".comb.sort.join

[21:48] <[Coke]> niecza has a bunch of failures in S05-mass/properties-general.niecza 

[21:48] <p6eval> pugs b927740: OUTPUT«Ilikeyams␤»

[21:48] <p6eval> ..rakudo 5a2c7d, niecza v14-17-g0ef17b0: OUTPUT«  Iaeiklmsy␤»

[21:48] *** zby_home left
[21:49] <benabik> Is .sort broken in pugs?

[21:49] <tadzik> comb, I guess

[21:49] <masak> no, it's .comb that has different semantics, I think.

[21:49] <masak> it probably used to mean .words

[21:49] <sorear> [Coke]: yeah, whoever wrote that test file didn't think about the fact that Unicode is a moving target

[21:50] <benabik> pugs: "I like yams".comb.perl.say

[21:50] <p6eval> pugs b927740: OUTPUT«(Match.new(␤  ok => Bool::True, ␤  from => 0, ␤  to => 1, ␤  str => "I", ␤  sub_pos => (), ␤  sub_named => {}␤), Match.new(␤  ok => Bool::True, ␤  from => 1, ␤  to => 5, ␤  str => "like", ␤  sub_pos => (), ␤  sub_named => {}␤), Match.new(␤  ok => Bool::True, ␤  from…

[21:50] <benabik> That is not really what I expected.

[21:51] <masak> it is what you got, though, so better live with it :)

[21:51] <masak> pugs: say "I like yams".comb>>.str

[21:51] <p6eval> pugs b927740: OUTPUT«*** No such method in class Array: "&>>str"␤    at /tmp/jakhmyHH4q line 1, column 5 - line 2, column 1␤»

[21:52] <masak> pugs: say .str for "I like yams".comb

[21:52] <p6eval> pugs b927740: OUTPUT«*** No such method in class Match: "&str"␤    at /tmp/uCGzP5G6Eg line 1, column 5-10␤»

[21:52] <masak> oh, so it's an attr but not a method.

[21:53] <[Coke]> perhaps we need a $* to tell us which version of unicode we're supporting.

[21:53] <jnthn> 'night, #perl6

[21:53] <sorear> bye

[21:54] * masak takes aim at [Coke] with the pipe from $|

[21:56] <Juerd> A unicode metavariable should at least have a non-ascii identifier

[21:56] <Juerd> May I suggest $☃? :)

[21:57] <sorear> .u ☃

[21:57] <phenny> U+2603 SNOWMAN (☃)

[22:00] <masak> Juerd: are you familiar with the snowman-comet bug in Rakudo?

[22:00] <masak> Juerd: the bug was so well-liked that there was talk about reintroducing it through a module. :)

[22:00] <Juerd> No, but it sounds like the most fun category of bugs

[22:00] <benabik> .u �

[22:00] <phenny> U+FFFD REPLACEMENT CHARACTER (�)

[22:01] <masak> Juerd: for some inscrutable reason, the bug allowed the snowman and comet characters to be used as "matching bracketing characters" around a regex.

[22:01] *** zjmarlow joined
[22:01] <tadzik> tee-hee

[22:01] <masak> here it is: https://rt.perl.org/rt3/Ticket/Display.html?id=66498

[22:03] <tadzik> "Can't quote a string with a snowman and comet (U+2603 and U+2604)"

[22:03] <tadzik> nice

[22:07] <masak> I think you agree that there should be a module to re-enable this :)

[22:07] <masak> you know, just because.

[22:07] <tadzik> because we can

[22:07] <benabik> use Snowman::Comet;

[22:07] <Juerd> masak: Wow. Just wow.

[22:12] <masak> Juerd: this is what I like about bughunting. sometimes the bugs just leave me speechless.

[22:19] *** PacoAir left
[22:20] <sorear> Did we ever understand that one?

[22:25] *** icwiener left
[22:25] *** icwiener joined
[22:29] <masak> I didn't. maybe pmichaud did.

[22:30] <colomon> sorear: I dunno what the BUILD is there for, that's how TimToady++ had it and it seemed to work so I didn't tinker with it (and copied it from Set to Bag, KeySet, and KeyBag).

[22:32] *** mj41 left
[22:42] <masak> oh, you made Bag, too? colomon++

[22:56] *** zjmarlow left
[23:00] *** pernatiy joined
[23:03] *** Radvendii joined
[23:04] *** Some-body_ is now known as DarthGandalf

[23:04] *** DarthGandalf left
[23:04] *** DarthGandalf joined
[23:05] <Radvendii> o/

[23:08] <masak> \o

[23:08] <masak> 'night, #perl6

[23:09] *** icwiener left
[23:36] *** spine left
[23:56] *** zjmarlow joined
