[00:06] <sjohnson> *peek a boo*

[00:07] *** s1n joined
[00:09] * [Coke] finally can check IRC today. hey, perl6eeps.

[00:09] <sorear> hey, [Coke]]

[00:09] <TimToady> .oO(perlbeeps?)

[00:09] <phenny> TimToady: 28 Jun 23:06Z <pmichaud> tell TimToady I'm hoping you can answer the question on p6u about the rationale behind say vs print (gist versus string).  I can write a response, but I'm fearfull I'll miss some of the nuances you ran into.

[00:12] <[Coke]> you BEEPing perlians.

[00:12] <diakopter> 6leeper

[00:14] *** Chillance left
[00:18] <TimToady> .oO(perl b from outer space)

[00:27] <[Coke]> http://www.youtube.com/watch?v=chfwaUtuOEk :: WTF?

[00:34] <flussence> Wat.

[00:37] *** spider-mario left
[00:39] *** jaldhar joined
[00:44] *** tyatpi left
[00:45] *** tyatpi joined
[01:12] *** pat_js left
[01:17] *** s1n left
[01:30] *** scott_ joined
[01:30] *** scott_ is now known as Guest41876

[01:31] *** s1n joined
[01:39] *** Guest57355 left
[01:39] *** vlixes left
[01:41] *** harmil1 joined
[01:42] *** benabik_ joined
[01:45] *** smash_ joined
[01:45] *** apejens_ joined
[01:45] *** pochi_ joined
[01:45] *** BlueT__ joined
[01:45] *** estrai_ joined
[01:45] *** am0c left
[01:45] *** alester left
[01:46] *** benabik_ is now known as benabik

[01:46] *** flussence joined
[01:46] *** harmil joined
[01:46] *** am0c joined
[01:46] *** p6eval joined
[01:46] *** ChanServ sets mode: +v p6eval

[01:50] <colomon> sorear: ping?

[01:54] *** Exio joined
[01:56] *** aloha joined
[02:00] *** jaldhar left
[02:23] <sorear> colomon: pong

[02:24] <colomon> sorear: I'm trying to figure out how to fix postinc and postdec for Bools

[02:25] <colomon> I wanted to ask you how to create a Bool object in Builtins.cs, but that's Kernel.FalseV and Kernel.TrueV, right?

[02:25] <sorear> right.

[02:25] <colomon> I'm very puzzled at the moment because I've somehow managed to fix 2 of the 5 fails.

[02:26] *** shinobicl joined
[02:27] *** Exio is now known as Ex

[02:27] * colomon took an embarrassingly long time searching the source to figure out TrueV and FalseV

[02:28] <colomon> ah, wait, fixed 2 of 3, the other 2 are something else.

[02:32] <colomon> sorear: still there?

[02:33] <sorear> yes.

[02:34] <colomon> turns out I fixed the bit I was trying to fix, and it's the other bit that's still wrong

[02:34] <colomon> can you break down what bit of v.AssignO(o1.mo.mro_succ.Get(v), false) does what?

[02:35] <colomon> o1 is the value of the variable... mro_succ gets the next value

[02:35] <colomon> but why is Get(v) there?

[02:35] *** leprevost joined
[02:35] <colomon> n: my $x = Bool; my $y = $x--; say $x

[02:35] <p6eval> niecza v19-5-g75130da: OUTPUT¬´Potential difficulties:‚ê§  $y is declared but not used at /tmp/EmnF9Ls52Q line 1:‚ê§------> [32mmy $x = Bool; my [33m‚èè[31m$y = $x--; say $x[0m‚ê§‚ê§Bool()‚ê§¬ª

[02:36] <colomon> that should be False, as far as I can tell.

[02:37] <sorear> colomon: o1.mo.mro_succ returns a ContextHandler<Variable> object that implements succ()

[02:38] <sorear> colomon: for some of the hottest methods, a vtable-like mechanism is used to avoid the mro_methods hash table

[02:39] <sorear> colomon: ContextHandler<Variable> is a virtual class with an abstract method Get().  So you can implement succ() in C# code and it will be directly called

[02:39] <colomon> ah!

[02:39] <sorear> colomon: we could also have used delegates here, but they're measurably slower and a bit less nice from a serialization POV

[02:40] <colomon> There doesn't seem to be a CtxBoolSuccish?

[02:43] <sorear> no, there isn't

[02:43] <sorear> so mro_succ is a CtxCallMethod instance

[02:43] <sorear> which forwards the call to Perl 6 code

[02:43] <colomon> which calls.... CommonEnum.succ?

[02:43] <sorear> it's just method succ() { True }, iirc

[02:44] <sorear> quite possibly CommonEnum.succ

[02:46] <colomon> yup.

[02:47] <colomon> okay, I'm going to bed, but I think I know how to sort this now.

[02:47] <colomon> sorear++

[02:47] *** shinobicl left
[02:49] <colomon> afk

[02:53] *** xinming_ joined
[03:07] *** jaldhar joined
[03:09] *** CRAZEDPSYC is now known as crazedpsyc

[03:16] *** cognominal left
[03:19] *** cognominal joined
[03:25] *** stephenl1 left
[03:46] *** tyatpi left
[03:48] *** tyatpi joined
[04:07] *** leprevost left
[04:11] *** tyatpi left
[04:35] <pmichaud> http://static.happyplace.com/assets/images/2012/02/4f4d13c92d3d4.jpeg   # answers from a new perl 6 programmer?

[04:37] *** tyatpi joined
[04:49] <cognominal> pmichaud, the exercice does not talk about comparing numbers. That's where the fail lies.

[04:49] *** birdwindupbird joined
[04:50] <pmichaud> r:  print < or >;   

[04:50] <p6eval> rakudo 39087a: OUTPUT¬´or¬ª

[04:50] <pmichaud> looks correct to me!  :-)

[04:50] <cognominal> TimToady would say something about context.

[04:50] <pmichaud> r:  my &Write = &say;    Write < or >.

[04:50] <p6eval> rakudo 39087a: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/_3KEtA7Fel:1‚ê§¬ª

[04:50] <pmichaud> r:  my &Write = &say;    Write < or >

[04:50] <p6eval> rakudo 39087a: OUTPUT¬´or‚ê§¬ª

[04:50] <cognominal> ho, I forgot about the syntax. You did set up the context. But I am not yet awake.

[04:52] <cognominal> pmichaud, I guess I will add that jpeg to my fpw presentation

[04:53] <pmichaud> I found it via http://www.happyplace.com/3907/unintentionally-inappropriate-test-responses-from-children

[04:58] *** kaleem joined
[05:16] *** fhelmberger joined
[05:18] *** s1n left
[05:33] <moritz> \o

[05:35] <sorear> o/

[05:51] <cognominal> pmichaud what is the url of your presentation about lists/iterators and laziness?

[05:51] *** jaldhar left
[06:06] <cognominal> i got it

[06:19] *** wtw joined
[06:47] *** cognominal left
[06:49] *** odoacre left
[06:51] *** cognominal joined
[06:56] *** Entonian joined
[06:58] *** Entonian left
[07:05] *** odoacre joined
[07:22] *** cognominal left
[07:23] *** am0c_ joined
[07:26] *** eiro left
[07:28] <tadzik> hello from FPW #perl6

[07:34] *** eiro joined
[07:41] *** am0c_ left
[07:46] *** tyatpi left
[07:46] *** adam7504 joined
[07:50] *** yves_ joined
[07:54] *** am0c_ joined
[07:58] *** kresike joined
[07:58] <kresike> good morning all you happy perl6 people

[08:00] <sorear> good morning kresike

[08:00] *** adam7504 left
[08:00] <kresike> hello sorear o/

[08:03] <moritz> r: say <a b c>[^10].perl

[08:03] <p6eval> rakudo 39087a: OUTPUT¬´("a", "b", "c")‚ê§¬ª

[08:03] <moritz> r: say <a b c>.list[^10].perl

[08:03] <p6eval> rakudo 39087a: OUTPUT¬´("a", "b", "c")‚ê§¬ª

[08:09] *** MayDaniel joined
[08:17] *** mucker joined
[08:22] <moritz> r: say <a b c>.Arry[^10].perl

[08:22] <p6eval> rakudo 39087a: OUTPUT¬´No such method 'Arry' for invocant of type 'Parcel'‚ê§  in block <anon> at /tmp/cGxLbqoyu2:1‚ê§‚ê§¬ª

[08:22] <moritz> r: say <a b c>.Array[^10].perl

[08:22] <p6eval> rakudo 39087a: OUTPUT¬´("a", "b", "c", Any, Any, Any, Any, Any, Any, Any)‚ê§¬ª

[08:22] <moritz> oh

[08:24] *** am0c_ left
[08:25] *** cj left
[08:26] *** cj joined
[08:30] *** cognominal joined
[08:33] <moritz> r: say <a b c>

[08:33] <p6eval> rakudo 39087a: OUTPUT¬´a b c‚ê§¬ª

[08:33] *** mucker left
[08:33] <moritz> r: print <a b c>

[08:33] <p6eval> rakudo 39087a: OUTPUT¬´abc¬ª

[08:38] <moritz> r: my Date $x; say $x; print $x;

[08:38] <p6eval> rakudo 39087a: OUTPUT¬´Date()‚ê§use of uninitialized variable $v of type Date in string context  in block <anon> at /tmp/4Og3VnYutO:1‚ê§‚ê§¬ª

[08:41] <dalek> faq: 2945628 | moritz++ | answers.md:

[08:41] <dalek> faq: explain difference between say and print, .Str and .gist

[08:41] <dalek> faq: review: https://github.com/perl6/faq/commit/2945628ee6

[08:47] *** GlitchMr joined
[08:48] <dalek> faq: 493f417 | moritz++ | answers.md:

[08:48] <dalek> faq: advocacy tweaking

[08:48] <dalek> faq: review: https://github.com/perl6/faq/commit/493f417c28

[08:50] *** cognominal left
[08:56] *** am0c_ joined
[08:56] *** brrt joined
[09:00] *** fglock joined
[09:01] *** cognominal joined
[09:03] *** cognominal left
[09:12] *** felher joined
[09:12] *** cognominal joined
[09:14] *** moritz left
[09:14] *** moritz joined
[09:16] <dalek> roast: 4214a48 | moritz++ | S32-array/push.t:

[09:16] <dalek> roast: RT #109476

[09:16] <dalek> roast: review: https://github.com/perl6/roast/commit/4214a482bc

[09:26] *** cognominal left
[09:31] *** cognominal joined
[09:33] *** thou_ joined
[09:35] *** odoacre left
[09:37] *** thou left
[10:00] *** daxim joined
[10:00] *** cognominal left
[10:05] *** am0c_ left
[10:05] *** cognominal joined
[10:09] *** Guest41876 left
[10:10] *** cognominal left
[10:22] <dalek> faq: ecfb825 | moritz++ | questions:

[10:22] <dalek> faq: update questions file with answered questions

[10:22] <dalek> faq: review: https://github.com/perl6/faq/commit/ecfb825eec

[10:29] *** spider-mario joined
[10:38] *** GlitchMr left
[10:56] *** snearch joined
[11:05] <dalek> niecza: 02206bd | (Solomon Foster)++ | lib/ (2 files):

[11:05] <dalek> niecza: Fix postinc and postdec to properly initialize return values from undefined Bool objects.  Add Bool.succ and Bool.pred so we get proper results from Bool.

[11:05] <dalek> niecza: review: https://github.com/sorear/niecza/commit/02206bdd92

[11:06] <colomon> So, I just had a flash that the spec and our discussion yesterday was all wrong.

[11:08] <colomon> rn: my $x = Rat; my $y = $x++; say $x.WHAT say $y.WHAT

[11:08] <p6eval> rakudo 39087a: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/5BRwSxsJ5C:1‚ê§¬ª

[11:08] <p6eval> ..niecza v19-5-g75130da: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Two terms in a row (method call requires colon or parens to take arguments) at /tmp/7UUpsp6mjE line 1:‚ê§------> [32mmy $x = Rat; my $y = $x++; say $x.WHAT [33m‚èè[31msay $y.WHAT[0m‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[11:09] <colomon> rn: my $x = Rat; my $y = $x++; say $x.WHAT; say $y.WHAT

[11:09] <p6eval> niecza v19-5-g75130da: OUTPUT¬´Rat()‚ê§Int()‚ê§¬ª

[11:09] <p6eval> ..rakudo 39087a: OUTPUT¬´Int()‚ê§Int()‚ê§¬ª

[11:09] <colomon> by the logic we talked about yesterday, those should both be Rat.  The spec and both compilers are wrong.

[11:09] <colomon> pugs: my $x = Rat; my $y = $x++; say $x.WHAT; say $y.WHAT

[11:09] <p6eval> pugs: OUTPUT¬´Int‚ê§Int‚ê§¬ª

[11:09] <colomon> all three compilers

[11:10] <colomon> afk # "yoo hoo daddy, you're good at reading..."

[11:17] <moritz> maybe the spec should say "coerce the 0 to the container type if the container type ~~ Numeric'

[11:24] *** safinaskar joined
[11:24] <colomon> moritz: exactly my thought

[11:24] <safinaskar> rakudo: say 2 + 2

[11:24] <p6eval> rakudo 39087a: OUTPUT¬´4‚ê§¬ª

[11:24] * colomon just read "Knuffle Bunny Too" twice

[11:25] <safinaskar> what is this rakudo and p6eval?

[11:25] <moritz> safinaskar: rakudo is a Perl 6 compiler

[11:25] <colomon> rakudo (in this context) is one of a series of nicks which call the p6eval program to run a snippet of Perl 6

[11:25] <safinaskar> moritz: colomon: thanks

[11:25] <moritz> safinaskar: and p6eval is a but that runs rakudo and other perl 6 compilers with some sample input

[11:26] <colomon> bot

[11:26] <moritz> n: say 'niecza also exists'

[11:26] <p6eval> niecza v19-5-g75130da: OUTPUT¬´niecza also exists‚ê§¬ª

[11:26] <safinaskar> okey, okey

[11:26] <moritz> erm, yes. :-)

[11:26] <colomon> r: say "and the one letter abbreviations are easier to type"

[11:26] <p6eval> rakudo 39087a: OUTPUT¬´and the one letter abbreviations are easier to type‚ê§¬ª

[11:27] <moritz> nrp: say 'and they can be combined :-)'

[11:27] <p6eval> rakudo 39087a, niecza v19-5-g75130da, pugs: OUTPUT¬´and they can be combined :-)‚ê§¬ª

[11:28] <flussence> quick question: does defining a multi method new() in a class always remove access to the built in one?

[11:29] *** safinaskar left
[11:30] <moritz> no

[11:30] <flussence> rn: class A { has $.v; multi method new(Str $q) { A.new(:v($q)) }; A.new('q');

[11:30] <p6eval> niecza v19-5-g75130da: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Unable to parse block at /tmp/Si132pPjrF line 1:‚ê§------> [32mclass A {[33m‚èè[31m has $.v; multi method new(Str $q) { A.n[0m‚ê§Couldn't find final '}'; gave up at /tmp/Si132pPjrF line 1 (EOF):‚ê§------> [32mw(Str $q) { A.new(:‚Ä¶

[11:30] <p6eval> ..rakudo 39087a: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 2, near ""‚ê§¬ª

[11:30] <flussence> rn: class A { has $.v; multi method new(Str $q) { A.new(:v($q)) } }; A.new('q');

[11:30] <p6eval> niecza v19-5-g75130da: OUTPUT¬´Unhandled exception: Cannot call new; none of these signatures match:‚ê§    A, Str‚ê§  at /tmp/eeAAjaEte6 line 1 (A.new @ 4) ‚ê§  at /tmp/eeAAjaEte6 line 1 (mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3916 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/li‚Ä¶

[11:30] <p6eval> ..rakudo 39087a:  ( no output )

[11:31] <flussence> oh, maybe it's a nieczabug

[11:31] <moritz> it seems to not declare Mu.new a multi

[11:33] *** baest joined
[11:45] *** eiro left
[11:46] *** eiro joined
[11:50] *** jaldhar joined
[11:50] <colomon> moritz: are there tests relying on Mu.new being a multi?

[11:52] * colomon is trying to see if there is a performance impact of switching right now, but suspects that any spectests which test this must be skipped in niecza right now.

[11:52] <moritz> colomon: I guess there aren't any (or many) tests relying on it

[11:54] <colomon> moritz: is it actually required by the spec?  I was under the impression it wasn't, but that may have been as a result of hitting this very bug in Niecza....

[11:55] <moritz> colomon: I don't think it's specced so far, but it should be

[11:55] <moritz> because it's quite important for user-space code

[12:01] *** GlitchMr joined
[12:13] <huf> what's the grammatical mood (or perhaps that's not even the right category name) for sentences like "do take a seat!"?

[12:14] <moritz> imperative?

[12:14] <moritz> erm

[12:14] <moritz> imperative!

[12:15] <huf> i'm actually trying to find out what "do" is doing there

[12:15] <huf> and what happened to the form "do you take a seat!"

[12:15] <huf> which i found while reading sherlock holmes

[12:15] <moritz> it's kind of an emphasis

[12:15] <moritz> not sure if there's a grammatical name for it; I'm not a linguist :-)

[12:15] <huf> yeah, that's how far i got ;)

[12:15] <huf> i was hoping fishing in this channel would get me a linguist :D

[12:16] <moritz> I hope arnsholt (where is that guy when you need him?) or TimToady or so know :-)

[12:16] <huf> i found this: http://en.wikipedia.org/wiki/Hortative

[12:16] <huf> but it doesnt appear to be what i'm looking for

[12:18] <dalek> specs: 13a69e8 | moritz++ | S32-setting-library/Basics.pod:

[12:18] <dalek> specs: [S32] Mu cleanup

[12:18] <dalek> specs: 

[12:18] <dalek> specs: Mu is a class, not a role.

[12:18] <dalek> specs: There is no need for an undefine method.

[12:18] <dalek> specs: new() must be a multi method

[12:18] <dalek> specs: review: https://github.com/perl6/specs/commit/13a69e809d

[12:18] <moritz> colomon: there, now it's specced

[12:18] <colomon> moritz: the change appears to not hurt Niecza's performance, so I'd be glad to make it, if you'd change the .... wait, you just did!

[12:18] <moritz> colomon: :-)

[12:19] <colomon> you actually pushed the change while I was typing that sentence!  awesome!

[12:19] <colomon> now if we can just figure out some tests...

[12:20] <moritz> I'll add some to S12-construction/new.t

[12:20] <colomon> moritz++

[12:20] <dalek> niecza: 5e25209 | (Solomon Foster)++ | lib/CORE.setting:

[12:20] <dalek> niecza: Make Mu.new a multi method.

[12:20] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5e252093ce

[12:20] *** brrt left
[12:20] *** tyatpi joined
[12:23] <dalek> roast: d578243 | moritz++ | S12-construction/new.t:

[12:23] <dalek> roast: test that Mu.new is a multi method

[12:23] <dalek> roast: review: https://github.com/perl6/roast/commit/d57824323e

[12:25] <flussence> colomon++ moritz++

[12:28] <colomon> moritz: in your NewFromMu test, should you be declaring NewFromMu.new to be a multi?

[12:29] <colomon> oh, I see you did that in the next one...

[12:31] <colomon> huh.  I declared Mu.new to be a multi method, but it doesn't see to help with the tests at all.

[12:33] <moritz> n: class A { has $.a; multi method new($a) { $.new(:$a) } }; say A.new(a => 42).a

[12:33] <p6eval> niecza v19-6-g02206bd: OUTPUT¬´Unhandled exception: Cannot call new; none of these signatures match:‚ê§    A, Any‚ê§  at /tmp/HbOOelBYuG line 1 (mainline @ 5) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3918 (ANON @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 3919 (module-CORE @ 5‚Ä¶

[12:33] <moritz> that's still the old version

[12:33] <moritz> colomon: what does that do on an up-to-date niecza?

[12:53] *** smash_ is now known as smash

[12:54] <colomon> Cannot call new; none of these signatures match:

[12:54] <colomon>     A, Any

[12:55] <moritz> huh

[12:55] <moritz> looks like it doesn't consider the one from Mu

[12:55] <moritz> there isn't another 'new' method in Any, by chance?

[12:56] <masak> hi from FPW!

[12:56] * masak just gave his talk

[12:56] <moritz> \o

[12:56] <moritz> masak: what did you talk about?

[12:56] <moritz> macros?

[12:57] <masak> aye.

[12:57] <masak> slightly refurbished talk.

[12:57] <masak> but basically the same.

[13:01] <colomon> heh, there are method news all over the place in Niecza.

[13:01] *** kaleem left
[13:01] <colomon> none of which are Any.new, as far as I can see.

[13:02] <colomon> I need to get going, need to take the little guy to http://www.traindoctor.com/GLBTE_poster.pdf

[13:02] *** kaleem joined
[13:04] * masak read "GLBTE" as gay/lesbian/bi/trans/extraterrestrial

[13:06] <huf> huh.

[13:06] <huf> i just assumed it's some lgbt thing too

[13:10] *** Psyche^ joined
[13:14] *** kaleem left
[13:14] *** Patterner left
[13:14] *** Psyche^ is now known as Patterner

[13:14] *** snearch left
[13:20] *** Gesh joined
[13:20] <colomon> "Great Lakes Bay" is a terrible name for our area... as if there is only one bay in the Great Lakes.

[13:21] <PerlJam> colomon: obviously there' only one of any importance ;)

[13:23] <moritz> obviously there's one with first claim on the name :-)

[13:23] <PerlJam> perhaps not first, but certainly most vociferous :)

[13:37] <colomon> as far as I know, our area only started using the name in the last decade.  but maybe no one else grabbed the URL before them...

[13:42] *** pupoque joined
[13:42] *** evgeny joined
[13:42] *** [hds] joined
[13:43] *** pupoque left
[13:43] *** Gesh left
[13:43] *** evgeny left
[13:48] *** sisar joined
[13:52] *** alvis left
[13:53] *** mikemol joined
[13:57] *** JimmyZ joined
[13:58] <JimmyZ> http://qore.org/    # Perl-ish language?

[13:59] <JimmyZ> Perl6-ish

[14:05] *** Pleiades` left
[14:08] *** MayDaniel left
[14:10] <[hds]> The "short description" of the language is way too long.

[14:10] *** Pleiades` joined
[14:13] *** jaldhar left
[14:15] *** Pleiades` left
[14:16] *** PacoAir joined
[14:19] <moritz> pseudo-methods - so each type now has a "pseudo-class" whose methods can be run on any value of that type (ex: "this is a string".size())

[14:19] <moritz> erm, how does that differ from any normal method?

[14:20] <moritz> anyway, looks interesting

[14:20] <PerlJam> that's a warning sign

[14:21] *** fgomez joined
[14:21] <PerlJam> "these are faked up method-like things that aren't really methods"

[14:24] <kresike> could use some interpolation

[14:25] * kresike dislikes printf

[14:45] *** jaldhar joined
[14:47] *** kaleem joined
[14:47] *** fhelmberger left
[14:54] *** jaldhar left
[14:57] *** wtw left
[15:16] <sirrobert> Is there a perl6 equivalent to javascript's ".hasOwnProperty" method?

[15:16] <sirrobert> (testing to see if an object has a property/method)

[15:17] <timotimo> you can check .^methods, can't you?

[15:17] <moritz> .can('methodname')

[15:17] <timotimo> that sounds better actually

[15:17] <sirrobert> great, thanks

[15:17] <moritz> note that attributes are only exposed to the outside via getter/setter methods

[15:17] <sirrobert> righto

[15:18] <moritz> r: class A { has $.x }; say so A.can('x')

[15:18] <p6eval> rakudo 39087a: OUTPUT¬´True‚ê§¬ª

[15:18] <moritz> r: class A { has $.x }; say A.can('x')

[15:18] <p6eval> rakudo 39087a: OUTPUT¬´x‚ê§¬ª

[15:18] <moritz> r: class A { has $.x }; say A.can('x').WHAT

[15:18] <p6eval> rakudo 39087a: OUTPUT¬´Parcel()‚ê§¬ª

[15:18] <moritz> r: class A { has $.x }; say A.can('x')[0].WHAT

[15:18] <p6eval> rakudo 39087a: OUTPUT¬´Method()‚ê§¬ª

[15:18] <sirrobert> huh... what's a parcel?

[15:19] <moritz> parenthesis cell. Something list-y

[15:19] <moritz> if you write  (1, 2, 3)  that's a Parcel

[15:19] <sirrobert> ah, ok

[15:19] <PerlJam> except it's not the parens that make the parcel

[15:20] <moritz> and it's immutable, unless you put variables into it

[15:20] <moritz> my ($x, $y) = (2, 3)# here the ($x, $y) is an immutable parcel, but you can still assign to the variables inside the parcel

[15:21] <timotimo> oh, interesting. .can('x') will give all multi-methods called x, yes?

[15:21] <sirrobert> hmmm... interesting.

[15:21] <moritz> timotimo: I... think so

[15:21] <moritz> r: class A { multi method x() { }; multi method x() { }}; say A.can('x').elems

[15:21] <p6eval> rakudo 39087a: OUTPUT¬´1‚ê§¬ª

[15:21] <moritz> hm, no

[15:21] <moritz> those are grouped inside a proto method

[15:21] <moritz> r: class A { multi method x() { }; multi method x() { }}; say A.can('x').candidates.elems

[15:21] <p6eval> rakudo 39087a: OUTPUT¬´No such method 'candidates' for invocant of type 'Parcel'‚ê§  in block <anon> at /tmp/J767OIoA88:1‚ê§‚ê§¬ª

[15:22] <moritz> r: class A { multi method x() { }; multi method x() { }}; say A.can('x')[0].candidates.elems

[15:22] <p6eval> rakudo 39087a: OUTPUT¬´2‚ê§¬ª

[15:22] <moritz> r: class A { method x() { } }; class B is A { method x {} }; say B.can('x').elems

[15:22] <p6eval> rakudo 39087a: OUTPUT¬´2‚ê§¬ª

[15:22] <moritz> ah

[15:22] <moritz> it returns all methods from the class hierarchy in mro order

[15:23] <sirrobert> mro?

[15:23] <moritz> method resolution order

[15:23] <sirrobert> ah

[15:23] <sirrobert> wow, that's coool

[15:23] <moritz> r: say Str.^mro

[15:23] <p6eval> rakudo 39087a: OUTPUT¬´Str() Cool() Any() Mu()‚ê§¬ª

[15:24] <timotimo> and for each candidate i can query which class it comes from, yes?

[15:24] <moritz> hmmm

[15:24] <moritz> r: class A { method x() { } }; class B is A { method x {} }; say B.can('x')[0].signature.parameters[0].perl

[15:24] <p6eval> rakudo 39087a: OUTPUT¬´No such method 'parameters' for invocant of type 'Signature'‚ê§  in block <anon> at /tmp/Ny1aRJOFpj:1‚ê§‚ê§¬ª

[15:25] <moritz> r: class A { method x() { } }; class B is A { method x {} }; say B.can('x')[0].signature.params[0].perl

[15:25] <p6eval> rakudo 39087a: OUTPUT¬´B ‚ê§¬ª

[15:25] <timotimo> also: what's the use of two multi methods with the exact same signature?

[15:25] <moritz> r: class A { method x() { } }; class B is A { method x {} }; say B.can('x')[0].signature.params[0].type

[15:25] <p6eval> rakudo 39087a: OUTPUT¬´B()‚ê§¬ª

[15:25] <moritz> that way you can get at the invocant type

[15:25] <timotimo> will the one defined earlier be used and it could delegate to the next one will nextsame or something like that?

[15:26] <moritz> timotimo: no, there will be an ambiguous dispatch

[15:26] <moritz> timotimo: that was just for illustration

[15:26] <timotimo> ambiguous dispatch means the compiler will yell at me?

[15:26] <moritz> timotimo: although you can call $obj.*x() and call all matching methods

[15:26] <moritz> yes

[15:26] <moritz> r: multi a() { }; multi a() { }; a()

[15:26] <p6eval> rakudo 39087a: OUTPUT¬´Ambiguous call to 'a'; these signatures all match:‚ê§:()‚ê§:()‚ê§‚ê§  in block <anon> at /tmp/AIk854ml5d:1‚ê§‚ê§¬ª

[15:26] <timotimo> perl is weird sometimes :)

[15:27] *** JimmyZ left
[15:27] * moritz is also weird sometimes

[15:27] <moritz> :-)

[15:27] <timotimo> if i can use .* to call all matching methods, how do i do it with multi subs?

[15:27] <moritz> you cannot

[15:27] <timotimo> OK

[15:27] <moritz> except...

[15:28] <moritz> you can abuse subs as methods

[15:28] <timotimo> r: class A { method a() { say "foo"; 1; }; method a() { say "blergh"; 10; }; say A.new().*a()

[15:28] <p6eval> rakudo 39087a: OUTPUT¬´===SORRY!===‚ê§Package 'A' already has a method 'a' (did you mean to declare a multi-method?)‚ê§at /tmp/MrSB0850m_:1‚ê§¬ª

[15:28] <timotimo> r: class A { multi a() { say "foo"; 1; }; multi a() { say "blergh"; 10; }; say A.new().*a()

[15:28] <p6eval> rakudo 39087a: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 2, near ""‚ê§¬ª

[15:28] <timotimo> r: class A { multi a() { say "foo"; 1; }; multi a() { say "blergh"; 10; }; } say A.new().*a()

[15:28] <p6eval> rakudo 39087a: OUTPUT¬´===SORRY!===‚ê§Confused‚ê§at /tmp/updzJbhHaP:1‚ê§¬ª

[15:28] <moritz> r: multi a($, $?) { 1 }; multi a($) { 2 }; say Any.*&a()

[15:28] <p6eval> rakudo 39087a: OUTPUT¬´Ambiguous call to 'a'; these signatures all match:‚ê§:(, )‚ê§:()‚ê§‚ê§  in sub a at /tmp/kJ7OMJcERz:1‚ê§  in method dispatch:<.*> at src/gen/CORE.setting:864‚ê§  in block <anon> at /tmp/kJ7OMJcERz:1‚ê§‚ê§¬ª

[15:28] <timotimo> r: class A { multi a() { say "foo"; 1; }; multi a() { say "blergh"; 10; }; }; say A.new().*a()

[15:28] <p6eval> rakudo 39087a: OUTPUT¬´‚ê§¬ª

[15:28] <moritz> hm, seems .* doesn't mix with sub-as-method abuse

[15:29] <timotimo> .* also doesn't seem to work at all

[15:29] <moritz> timotimo: you need to write 'multi method'

[15:29] <timotimo> oh, ok

[15:29] <timotimo> r: class A { multi method a() { say "foo"; 1; }; multi method a() { say "blergh"; 10; }; }; say A.new().*a()

[15:29] <p6eval> rakudo 39087a: OUTPUT¬´Ambiguous call to 'a'; these signatures all match:‚ê§:(A , Mu *%_)‚ê§:(A , Mu *%_)‚ê§‚ê§  in method a at src/gen/CORE.setting:320‚ê§  in method dispatch:<.*> at src/gen/CORE.setting:864‚ê§  in block <anon> at /tmp/UPlVRbwFBn:1‚ê§‚ê§¬ª

[15:29] <moritz> timotimo: right now you have two multi subs, and .* cannot find any matching methods, and is happy with it

[15:29] <moritz> hm

[15:30] <moritz> maybe I'm wrong about how .* works

[15:30] <moritz> and it only works on only-methods

[15:31] <timotimo> how does "call every candidate" translate to only methods? will it call each candidate in the mro?

[15:31] <moritz> yes

[15:35] *** Pleiades` joined
[15:38] *** fglock left
[15:39] *** domidumont left
[15:40] <kresike> bye all

[15:40] *** kresike left
[15:42] *** Pleiades` left
[15:47] *** MayDaniel joined
[15:57] <sirrobert> does Test.pm have some version of no_plan?

[15:59] *** birdwindupbird left
[16:03] *** kaleem left
[16:06] *** birdwindupbird joined
[16:21] *** Pleiades` joined
[16:26] <pmichaud> good morning, #perl6

[16:26] <pmichaud> sirrobert: (no_plan)  I think it's   'plan *'

[16:26] <pmichaud> see lib/Test.pm:32

[16:27] <GlitchMr> perl6: my $variable = 'the cake'; print $$$$$$$variable;

[16:27] <pmichaud> # "plan 'no_plan';" is now "plan *;"

[16:27] <pmichaud> # It is also the default if nobody calls plan at all

[16:27] <p6eval> rakudo 39087a, niecza v19-7-g5e25209: OUTPUT¬´the cake¬ª

[16:27] *** vmspb joined
[16:27] <GlitchMr> So, pugs was removed?

[16:27] <pmichaud> pugs:  my $variable = 'the cake';  print $$$$$$$variable;

[16:27] <p6eval> pugs: OUTPUT¬´the cake¬ª

[16:27] <pmichaud> pugs is just not in the default 'perl6:' set

[16:27] <pmichaud> but you can also do

[16:27] <GlitchMr> I guess it's because I convert scalar into scalar

[16:28] <pmichaud> npr: my $variable = 'the cake';  print $$$$$$$variable;

[16:28] <p6eval> rakudo 39087a, niecza v19-7-g5e25209, pugs: OUTPUT¬´the cake¬ª

[16:30] <sorear> good * #perl6

[16:30] <sorear> mmm npr.

[16:32] <pmichaud> moritz++  # faq.perl6.org

[16:34] <tadzik> hello #perl6

[16:34] <sorear> hello tadzik.

[16:35] <dalek> ufo: d3123ea | tadzik++ | bin/ufo:

[16:35] <dalek> ufo: Make it work after &dir changes

[16:35] <dalek> ufo: review: https://github.com/masak/ufo/commit/d3123eaa3e

[16:35] <pmichaud> ...are we sure the &dir changes are going to stay?

[16:36] <tadzik> I feel sort of uneasy about them

[16:36] <tadzik> especially the "what used to work now needs basename()" bit

[16:36] *** [hds] left
[16:36] <pmichaud> yeah

[16:38] <tadzik> r: for ^1 { when 1 { .path } }

[16:38] <p6eval> rakudo 39087a:  ( no output )

[16:38] <tadzik> r: for ^1 { when 1 { say .path } }

[16:38] <p6eval> rakudo 39087a:  ( no output )

[16:38] <masak> doesn't seem to be reproducible.

[16:39] <masak> maybe it's been fix'd in recent rakudos.

[16:39] <tadzik> no, this one doesn't work either

[16:39] <tadzik> hold on

[16:39] <pmichaud> right now I'm feeling more like I want to leave &dir as it was (perhaps working towards phasing it out entirely) and introduce a new function or method that is the improved version.

[16:39] <masak> +1

[16:40] <tadzik> for Range.new(0, 1) -> $p { when $p { say $_.perl; say $_.path } }

[16:40] <masak> &dir has been widely popular, but I think we can do better.

[16:40] <tadzik> r: for Range.new(0, 1) -> $p { when $p { say $_.perl; say $_.path } }

[16:40] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/bhcZACNkRT:1‚ê§‚ê§Null PMC access in find_method('perl')‚ê§  in block <anon> at /tmp/bhcZACNkRT:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen/CORE.set‚Ä¶

[16:40] <tadzik> there we are

[16:40] * masak submits rakuodbug

[16:40] <masak> rakudobug* :)

[16:40] <pmichaud> ...why is that a bug, ooc?

[16:40] <masak> pmichaud: Null PMC access

[16:40] <tadzik> NPA

[16:40] <pmichaud> oh, I see.

[16:41] <masak> r: for ^1 -> $p { when $p { .foo } }

[16:41] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/HzMxDYTCaC:1‚ê§‚ê§Null PMC access in find_method('foo')‚ê§  in block <anon> at /tmp/HzMxDYTCaC:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen/CORE.sett‚Ä¶

[16:41] <timotimo> that's more interesting

[16:42] <pmichaud> ...variable $a, hmm.

[16:43] <tadzik> that's usual

[16:43] <tadzik> it says random names when it doesn't know the real one

[16:43] <pmichaud> they aren't "random"

[16:43] <tadzik> I've noticed that a few times already

[16:43] <tadzik> yeah, I know

[16:43] <pmichaud> they're internal to CORE

[16:43] <tadzik> I think it catches the name... right

[16:43] <pmichaud> r: use fatal; for ^1 -> $p { when $p { .foo } }

[16:43] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/VxGqGx5w3a:1‚ê§‚ê§Null PMC access in find_method('foo')‚ê§  in block <anon> at /tmp/VxGqGx5w3a:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen/CORE.sett‚Ä¶

[16:45] <pmichaud> oh, it's the .ACCEPTS bug

[16:45] <masak> oh?

[16:45] <pmichaud> sure, it's the   when $p    that is attempting to convert Any into a number

[16:45] <pmichaud> in order to smart match it against $p

[16:45] <masak> the interesting thing is that the Range, the 'when' and the $_.foo call are all irreducible parts of triggering the bug.

[16:46] <masak> remove any of them, and the Null PMC Access disappears.

[16:46] <pmichaud> r: for (0,1) -> $p { when $p { .foo } }

[16:46] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/VgCIK_kuoP:1‚ê§‚ê§Null PMC access in find_method('foo')‚ê§  in block <anon> at /tmp/VgCIK_kuoP:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen/CORE.sett‚Ä¶

[16:46] <masak> maybe not. :)

[16:46] <pmichaud> r: for 0 -> $p { when $p { .foo } }

[16:46] <masak> ok, the Range is not essential, then.

[16:46] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/2BcvX6lmnC:1‚ê§‚ê§Null PMC access in find_method('foo')‚ê§  in block <anon> at /tmp/2BcvX6lmnC:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen/CORE.sett‚Ä¶

[16:46] <masak> huh.

[16:46] <masak> tadzik: I'm pretty sure we tested that.

[16:47] <masak> hm.

[16:47] <pmichaud> given 0 -> $p { when $p { .foo } }

[16:47] <pmichaud> r: given 0 -> $p { when $p { .foo } }

[16:47] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/SJ1JbHQSej:1‚ê§‚ê§Null PMC access in find_method('foo')‚ê§  in block <anon> at /tmp/SJ1JbHQSej:1‚ê§  in block <anon> at /tmp/SJ1JbHQSej:1‚ê§‚ê§¬ª

[16:47] <tadzik> masak: yeah, same. Odd

[16:47] <pmichaud> (-> $p { when $p { .foo } }).(0)

[16:47] <pmichaud> r: (-> $p { when $p { .foo } }).(0)

[16:47] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/5zdWF1O_Fa:1‚ê§‚ê§No such method 'foo' for invocant of type 'Any'‚ê§  in block <anon> at /tmp/5zdWF1O_Fa:1‚ê§  in block <anon> at /tmp/5zdWF1O_Fa:1‚ê§‚ê§¬ª

[16:47] <masak> there. it disappeared.

[16:47] <masak> I think iteration is involved somehow, anyway.

[16:48] <pmichaud> well, not with 'given'

[16:48] <pmichaud> there's no iteration with the .given

[16:48] <masak> hm, troo.

[16:48] <masak> so, why does it trigger with 'for' and 'given', but not with that last one, with a block?

[16:48] <pmichaud> r: my $ps = -> $p { when $p { .foo } };  $ps(0);

[16:48] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/Ap9xU9dVVo:1‚ê§‚ê§No such method 'foo' for invocant of type 'Any'‚ê§  in block <anon> at /tmp/Ap9xU9dVVo:1‚ê§  in block <anon> at /tmp/Ap9xU9dVVo:1‚ê§‚ê§¬ª

[16:49] <pmichaud> 0.map( -> $p { when $p { .foo } }).eager

[16:49] <pmichaud> r: 0.map( -> $p { when $p { .foo } }).eager

[16:49] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/JRkifpk737:1‚ê§‚ê§No such method 'foo' for invocant of type 'Any'‚ê§  in block <anon> at /tmp/JRkifpk737:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen‚Ä¶

[16:50] <pmichaud> the NPA has to be something in the way the closures are being built when part of 'for' or 'given'

[16:50] <pmichaud> which means it's a bug in <xblock>

[16:50] <pmichaud> (in Actions.pm)

[16:50] <pmichaud> here's another, then

[16:50] <pmichaud> r: if 1 -> $p { when $p { .foo } }

[16:50] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/C8Mba0rmGT:1‚ê§‚ê§¬ª

[16:50] <pmichaud> hmm.

[16:51] <pmichaud> r: while 1 -> $p { when $p { .foo }; }

[16:51] <pmichaud> oops

[16:51] <p6eval> rakudo 39087a: OUTPUT¬´(timeout)use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/h2Ig9XgW2m:1‚ê§‚ê§use of uninitialized variable $a of type Any in numeric context  in block <anon> at /tmp/h2Ig9XgW2m:1‚ê§‚ê§use of uninitialized variable $a of type Any in nu‚Ä¶

[16:52] <pmichaud> okay, so, the "unintialized variable $a..." is coming from an ACCEPTS call

[16:52] <pmichaud> I'm guessing it's this one:

[16:52] <pmichaud> src/core/Numeric.pm:4:    multi method ACCEPTS(Numeric:D: $a) {

[16:53] <pmichaud> The NPA is because the pointy block is somehow getting the wrong outer $_

[16:54] <masak> ah.

[16:54] <pmichaud> but only when being used as part of 'for' or 'given' (so far... could be other structures)

[16:55] <pmichaud> r: $_ = 'hello'; if 1 -> $p { when $p { .say } }  

[16:55] <p6eval> rakudo 39087a: OUTPUT¬´Cannot convert string to number: base-10 number must begin with valid digits or '.' in '‚èèhello' (indicated by ‚èè)‚ê§  in method Numeric at src/gen/CORE.setting:9480‚ê§  in sub infix:<==> at src/gen/CORE.setting:2509‚ê§  in sub infix:<==> at src/gen/CORE.setting:2509‚ê§  in ‚Ä¶

[16:56] <pmichaud> r: $_ = Bool; if 1 -> $p { when $p { .say } }  

[16:56] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Bool in numeric context  in block <anon> at /tmp/amepJyEJYf:1‚ê§‚ê§¬ª

[16:56] <pmichaud> r:  Bool.say

[16:56] <p6eval> rakudo 39087a: OUTPUT¬´Bool()‚ê§¬ª

[16:56] <pmichaud> *there*

[16:57] <masak> \o/

[16:58] <pmichaud> the .say got a $_ that isn't the one with the Bool

[16:58] <pmichaud> even though the one with the Bool is the one that was used for the smartmatching 'when'

[16:58] <masak> I'm lost, but I'm including this in the report anyway :P

[16:59] <pmichaud> please do, it's pretty well golfed.

[16:59] <masak> pmichaud++

[16:59] <pmichaud> or, more directly:

[16:59] <pmichaud> r: $_ = Bool;  .say ; if 1 -> $p { when $p { .say } }

[16:59] <p6eval> rakudo 39087a: OUTPUT¬´Bool()‚ê§use of uninitialized variable $a of type Bool in numeric context  in block <anon> at /tmp/aXNaM4d6Ty:1‚ê§‚ê§¬ª

[16:59] <pmichaud> the second .say isn't the same as the first.

[17:01] <masak> &

[17:11] *** alvis joined
[17:13] *** birdwindupbird left
[17:17] *** oftl joined
[17:18] <pmichaud> phenny: tell moritz  should the faq be listed on perl6.org somewhere?  (e.g., the front page might be good?)

[17:18] <phenny> pmichaud: I'll pass that on when moritz is around.

[17:19] <sirrobert> is there a difference between .pm and .pm6?

[17:20] *** Je joined
[17:21] *** alester joined
[17:25] *** Je left
[17:27] *** Je joined
[17:27] <moritz> pmichaud: faq.perl6.org was kind of an underground project so far

[17:27] <phenny> moritz: 17:18Z <pmichaud> tell moritz  should the faq be listed on perl6.org somewhere?  (e.g., the front page might be good?)

[17:27] <pmichaud> moritz: okay, that's fine with me.

[17:27] <moritz> pmichaud: if people like it, we should link to it. If not, we should improve it :-)

[17:28] <pmichaud> I'll work on the improving it part a bit.

[17:28] <pmichaud> I like it, fwiw.

[17:28] <moritz> \o/

[17:28] <moritz> I've also got a private email from finanalyst who liked it too

[17:30] *** xinming_ left
[17:31] <sirrobert> What's a good paradigm for writing a class that has provides a standard set of objects.  

[17:31] <sirrobert> for example:  an HTTP status class that gives you objects like $status.code; $status.definition

[17:31] <sirrobert> (and there's a defined list).  Or error codes

[17:32] *** smash left
[17:33] *** Je left
[17:33] <sisar> sirrobert: afaik, there is no difference between .pm and .pm6. Modules can have either extension.

[17:35] <sisar> giving Perl6 modules a .pm6 is (maybe) a good idea. ( for eg .STD.pm6)

[17:35] <sirrobert> sisar: thanks =)

[17:37] *** xinming joined
[17:39] <sisar> moritz: in S32/Exception, the X::Hash::Store::OddNumber entry, "Thrown when hash assignment finds a trailing hash key with a value."... s/with/without ?

[17:40] <pmichaud> just as an initial comment, I find it very difficult to decipher the X::... entries in CORE.setting when I encounter them.

[17:43] <pmichaud> it makes the code much less readable, imho.

[17:43] <pmichaud> a good example is Str.pm:547, which basically reads

[17:43] <pmichaud>             else {

[17:43] <pmichaud>                 X::Str::Match::x.new(got => $x).throw;

[17:43] <pmichaud>             }

[17:43] <pmichaud> I have no idea what error condition is being detected there.  Compare to:

[17:45] <pmichaud>             else {

[17:45] <pmichaud>                 die "Invalid argument to :x, must be Int or Range, got type {$x.^name}";

[17:45] <pmichaud>             }

[17:46] *** mucker joined
[17:46] <pmichaud> I understand (and mostly agree with) the rationale for typed exceptions... but it feels like we could do much better.

[17:48] <sisar> pmichaud: you seem to have the same question which oetiker++ asks here: https://github.com/rakudo/rakudo/pull/59#discussion_r505731

[17:48] <pmichaud> I think I would *much* prefer something like

[17:48] <pmichaud> well.... maybe not

[17:49] <pmichaud> the advantage of having exception classes declared centrally is that it's easier to find them all and perhaps provide localizations

[17:49] <pmichaud> at least, that's the advantage I would envision.

[17:50] <pmichaud> Still,  "X::Str::Match::x" tells me very little about the exception being raised.

[17:50] <sisar> pmichaud: yes that is one big advantage, but it tells very little... yes, what you said.

[17:52] <flussence> it's hard for me to make sense of that example even in context :/

[17:53] <flussence> why's the type check done that way, and not in the signature?

[17:53] <moritz> because type checks from signatures give very unspecific error messages

[17:53] <flussence> ah

[17:54] <sorear> o/ moritz

[17:54] <moritz> \o sorear 

[17:54] <flussence> would be nice if there were a way to say "throw this instead of the generic exception in this scope"...

[17:56] <pmichaud> r: $_ = Bool;  .say ; if 1 -> $p { when $p { .say } }

[17:56] <p6eval> rakudo 39087a: OUTPUT¬´Bool()‚ê§use of uninitialized variable $a of type Bool in numeric context  in block <anon> at /tmp/0juX88KhmQ:1‚ê§‚ê§¬ª

[17:56] <pmichaud> r: $_ = Bool;  .say ; if 1 -> $p { when $p { say 'matched'; .say; } }

[17:56] <p6eval> rakudo 39087a: OUTPUT¬´Bool()‚ê§use of uninitialized variable $a of type Bool in numeric context  in block <anon> at /tmp/Xp2KfnzIoF:1‚ê§‚ê§¬ª

[17:57] <pmichaud> r: $_ = Bool;  .say ; unless 0 -> $p { when $p { say 'matched'; .say; } }

[17:57] <p6eval> rakudo 39087a: OUTPUT¬´Bool()‚ê§use of uninitialized variable $a of type Bool in numeric context  in block <anon> at /tmp/quU8s4LhiS:1‚ê§‚ê§matched‚ê§Bool()‚ê§¬ª

[17:57] <pmichaud> never mind, my earlier 'if' example didn't prove anything.

[17:58] <moritz> flussence: that's what CATCH is for

[17:58] <moritz> flussence: but it's usually a terrible idea

[17:58] <pmichaud> r: $_ = Bool; for ^1 -> $p { when $p { say 'matched'; $_.say; } };

[17:58] <p6eval> rakudo 39087a: OUTPUT¬´use of uninitialized variable $a of type Bool in numeric context  in block <anon> at /tmp/zEMNrAQfoT:1‚ê§‚ê§matched‚ê§Null PMC access in find_method('say')‚ê§  in block <anon> at /tmp/zEMNrAQfoT:1‚ê§  in method reify at src/gen/CORE.setting:5079‚ê§  in method reify at src/gen/‚Ä¶

[17:58] <moritz> flussence: because you can never pin-point the location sufficiently enoguh

[17:59] <moritz> flussence: you only seldomly see the actual location of an exception in a lexical scope; usually it's from a dynamic scope inside a lexical scope

[17:59] <moritz> which means that anything "down the stack" gets caught

[18:04] * pmichaud updates #113904.

[18:10] *** mikemol left
[18:11] *** Chillance joined
[18:19] *** akshay_ joined
[18:20] *** akshay_ left
[18:23] * TimToady wonders what will happen if the next implementation is named "rpn" or some such...

[18:23] <pmichaud> We'll adjust somehow.  :)

[18:25] <au> npr: say [*] 1..3

[18:25] <p6eval> rakudo 39087a, niecza v19-7-g5e25209, pugs: OUTPUT¬´6‚ê§¬ª

[18:31] *** pupoque joined
[18:33] <pmichaud> au: o/

[18:33] <sorear> au!! o/

[18:40] <au> o/

[18:42] *** je joined
[18:42] <sirrobert> What are the class methods to use to define string context for print and say?

[18:43] <sorear> .Str and .gist, respectively

[18:43] <sirrobert> ah, thanks

[18:43] <sorear> it's amusing to see je and thou_.

[18:44] <thou_> o/

[18:44] *** thou_ is now known as thou

[18:44] <TimToady> "do" is a proverb that, in "do take a seat", serves as an intensifier, since the "take" is also there

[18:45] <huf> hmm

[18:45] <huf> TimToady: when did the form "do you take a seat" fall out of usage? is it even the same thing?

[18:45] <huf> or a more intense version of the same

[18:47] * TimToady is not a historical linguist; could never remember the examples...

[18:47] <huf> :)

[18:47] <sorear> although for completeness we need tu and I

[18:48] <pmichaud> these spectests look wrong to me...

[18:48] <huf> so this is still just... imperative mood, with an intensifier?

[18:48] <pmichaud> # numeric context on undefined values

[18:48] <pmichaud> ok($foo == 0,      "Any == 0");

[18:48] <pmichaud> ok(@foo[0] == 0,   "Array Any == 0");

[18:48] <pmichaud> anyone agree?

[18:48] *** daxim left
[18:48] <sirrobert> huf: yes; the "do" adds the connotation of insistance

[18:48] <pmichaud> (I think comparing Any == 0 should produce a warning or failure)

[18:49] <sirrobert> huf: they're denotatively equivalent

[18:49] <sorear> pmichaud: it is very traditional Perl behavior that undefined values act as "" or 0 depending on context

[18:49] <sorear> pmichaud: warning, not failure

[18:49] <pmichaud> sorear: it's also traditional that they warn.

[18:49] <sorear> ok() ignores warnings

[18:49] <TimToady> "do" is perhaps more properly called a "propredicate", since its antecedent is the whole action: "

[18:49] <TimToady> "Shall I take a seat?"  "Please do."

[18:49] <TimToady> it stands in for "take a seat", not just "take"

[18:50] <pmichaud> note that failures can also act as "" or 0 depending on context

[18:52] <pmichaud> ok() doesn't ignore warnings, fwiw.

[18:53] <pmichaud> (it doesn't fail on warnings, but they still show up)

[18:54] <pmichaud> I'm fine if we say that type objects warn (versus fail) on stringification/numification.  I'd just like to know the use case or rationale for treating them differently from other forms of numification.  

[18:55] <pmichaud> I think I'd also like a pragma that increases the strictness of such numification; i.e., that treats numification of undef as a fail instead of a warn (but still falls short of being fatal)

[18:56] <pmichaud> btw, the context for this is getting    Any ~~ 0   to dtrt

[18:57] <sirrobert> What's the best way to implement a two-way lookup in perl6?

[18:58] <sirrobert> instead of a hash (values and keys are both unique and should be able to look each other up)

[18:58] *** bluescreen10 joined
[19:00] <TimToady> my %revhash = %hash.invert;  # if there are no dups

[19:00] * sisar just recompiled parrot, rakudo, nqp from scratch because of the oh-so annoying 'Wrong or missing version of dependency...' error :(

[19:00] <sirrobert> TimToady: thanks

[19:02] <sisar> "perl Configure.pl --gen-parrot" was not able to remove the "Wrong or missing ...." error. I had to reclone everyting and build from scratch.

[19:03] <pmichaud> could be a missing dependency somewhere.

[19:03] <sisar> pmichaud: like ?

[19:04] <pmichaud> sisar: I don't know; trying it with MODULE_DEBUG set would probably give more clues.

[19:04] <pmichaud> I'd also need to know what you were running.

[19:04] <pmichaud> (i.e., what 'perl6' command were you doing?)

[19:04] <sisar> pmichaud: now ican't try it, I cleaned everything.

[19:05] <sisar> pmichaud: i did (more)

[19:05] <moritz> you might need rm -rf ~/.perl6/lib install/ ~/.panda/

[19:05] <pmichaud> sisar: right... so, we can find out more the next time it occurs.  But "Wrong or missing version of dependency" by itself isn't sufficient to know what dependency may be broken.  :)

[19:06] *** je left
[19:06] <moritz> the proper error message would be "Trying to load $pirfile for module $module, but it was precompiled with a different rakudo version"

[19:07] <pmichaud> (Any.Numeric)   another possibility is that Any.Numeric always returns a Failure, but it's marked as already handled so that the exception isn't thrown.

[19:07] <TimToady> "but it was compiled with version X instead of version Y"

[19:07] <pmichaud> moritz: +1

[19:07] <pmichaud> TimToady: +1

[19:08] <sisar> pmichaud: oh that error I have in my terminal log. It always says "Missing or wrong version of dependency 'src/stage2/QRegex.nqp' current instr.: '' pc 496 (src/gen/perl6.pir:200) (src/main.nqp src/gen/main-version.nqp:0)"

[19:08] <pmichaud> although "version X" doesn't quite fit in this context.

[19:08] <pmichaud> it's not version so much as "compilation instance"

[19:08] <pmichaud> sisar: I'd still need to see what was loading it and where.

[19:09] <sisar> pmichaud: ok, next time I encounter it, i'll use the MODULE_DEBUG option. How do I set it ?

[19:09] <pmichaud> export MODULE_DEBUG=1

[19:09] <pmichaud> I think

[19:09] <moritz> TimToady: that might cause confusion when the two different versions don't have different version identifier

[19:09] <moritz> export RAKUDO_MODULE_DEBUG=1

[19:09] <TimToady> then the version identifier doesn't identify a version :P

[19:10] <moritz> well

[19:10] <moritz> that's correct

[19:10] <sisar> pmichaud, moritz: these are env variables ?

[19:10] <pmichaud> but it was precompiled with a different rakudo instance

[19:10] <moritz> sisar: yes

[19:10] <sisar> ok

[19:10] <sisar> thhanks

[19:10] <pmichaud> "...but it was precompiled with a different rakudo binary'

[19:11] <moritz> +1

[19:12] <pmichaud> although in some cases it also has to be "...but it was precompiled with a different nqp binary"

[19:12] <pmichaud> actually, it's not the binaries that make the difference.

[19:12] <sirrobert> what can I read about best practices for throwing errors?

[19:13] <moritz> sirrobert: there's not much literature on the subject yet

[19:13] <moritz> sirrobert: what do you want to know?

[19:13] <sirrobert> I've got a dictionary that basically has valid codes and their meanings.  I want to throw an error if someone tries to use a code that's not in the dictionary.

[19:14] <pmichaud> "Trying to load module $module with signature $sig, but the one I found at $pirfile has signature $sig."

[19:14] <pmichaud> *that's* really what we want.

[19:14] <sirrobert> if (!%CODE.exists($code)) { ...? }

[19:14] <sirrobert> I don't even know what syntax I should use inside the if there =)

[19:15] <moritz> class X::YourApp::NoSuchCode is Exception { has $.code; method message { "trying to access YourApp-code $.code, but it does not exist" } };

[19:15] <pmichaud> sirrobert: p5ish would be   die "error" unless %CODE.exists($code)

[19:15] <moritz> if (!%CODE.exists($code)) {  X::YourApp::NoSuchCode.new(:$code).throw }

[19:15] <sirrobert> what is X::?  is that something I should fill in?

[19:15] <pmichaud> X is the exceptions namespace

[19:15] <sirrobert> ohh

[19:16] <moritz> no, it's the namespace we use for exceptions

[19:16] <pmichaud> it's a literal 'X'

[19:16] <moritz> YourApp is something you should fill in :-)

[19:16] <sirrobert> heh nod

[19:16] <sirrobert> it's just in library class.  I suppose I can make it arbitrarily long? =)

[19:16] <pmichaud> moritz: does   fail X::YourApp::NoSuchCode   work?

[19:16] <moritz> pmichaud: fail X::YourApp::NoSuchCode.new works

[19:17] <pmichaud> how about  X::YourApp::NoSuchCode.new.fail ?

[19:17] <moritz> that's harder to do

[19:17] <moritz> doesn't work right now

[19:17] <pmichaud> oh yes, that would be quite a bit harder.

[19:17] <TimToady> sirrobert: one should generally fail rather than throw if there's any chance the caller wants to handle failure that way

[19:18] <pmichaud> yes, if we're keeping Failure, then the canonical "error handler" should be  "fail something"  and not X::Something.new.throw

[19:19] <pmichaud> I'm fine if it's "fail X::Something.new"... but that seems to want better syntactic sugar to me

[19:19] <pmichaud> fail X::Something, code=>$code, msg=>$msg   # maybe

[19:19] * sorear still does not quite grok fail semantics

[19:20] <sirrobert> TimToady:  Ok... how does one handle a fail() in general?

[19:22] <TimToady> the caller can decide, by testing with //, or by "use fatal", or by letting the failure hit a sink or an attempt to use the bogus value as a real value (a lazy throw, as it were)

[19:22] <sirrobert> sounds dangerous =)

[19:23] <TimToady> it lets you treat failure as data rather than control flow, if you want to

[19:23] <pmichaud> it's a "soft fail".

[19:24] <pmichaud> as opposed to something like "die" which is a "hard fail" that has to be caught and handled immediately

[19:24] <TimToady> this becomes more important as parallelism introduces more implicit control flowish ideas

[19:24] <sirrobert> ah

[19:24] <pmichaud> ...this feels like a good faq entry :)

[19:24] <pmichaud> I need lunch now but will write one upon returning from lunch.

[19:24] <sirrobert> I was trying to figure out a use case for treating the failure as data (in a non TRY-CATCH fashion)

[19:25] <sirrobert> thanks, pmichaud

[19:25] <pmichaud> TimToady: if you have an opinion on Mu.Numeric doing warn versus fail, it would help me to resolve 3.ACCEPTS(Any)

[19:25] <pmichaud> bbiaw

[19:25] <moritz> currently fail() is more dangerous than die() (in rakudo) becase we don't have sink context which would cause the failures to throw

[19:26] <sorear> there are a lot of unanswered questions about sink context.

[19:26] <sorear> also it's one of those features that you have to pay for whether or not you use, which always grates on my nerves.

[19:26] <sirrobert> Find out more in Stephen King's next thriller.... Sinkholes!

[19:27] <pmichaud> I can certainly get Rakudo to have a sink context quickly enough, I think.

[19:27] <TimToady> sorear: I don't see that. Pure FP never has sink contexts, since its point is induce side effects.

[19:28] <TimToady> lunch &

[19:29] <moritz> pmichaud: I'd appreciate that

[19:29] <moritz> pmichaud: I have tried and failed, but that was mostly due to my lack of understanding of rakudo's codegen

[19:29] <sorear> TimToady: I'm not necessarily talking about pure FP; also imperative code that uses assignments a lot but never fail()

[19:30] <sorear> pmichaud: are you going to implement the version of fail() that eagerizes lists and searches them for Failures?

[19:30] *** Entonian joined
[19:30] <sorear> pmichaud: sorry, the version of sink() that...

[19:37] <moritz> oh, Exception.throw isn't hard to do either

[19:38] <moritz> erm, .fail

[19:39] *** GlitchMr left
[19:39] <dalek> rakudo/nom: 1180041 | moritz++ | / (2 files):

[19:39] <dalek> rakudo/nom: Exception.fail

[19:39] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/1180041d53

[19:42] *** Entonian left
[19:42] *** ChibaPet joined
[19:42] <ChibaPet> Ah, many more people here. =drops into lurk-and-learn mode=

[19:42] <flussence> more compared to what? :)

[19:42] <ChibaPet> Compared to #perl6 on MAGnet

[19:43] <moritz> that's not hard to do :-)

[19:43] <sirrobert> one more:  can someone explain the first argument to .bless?

[19:43] <sirrobert> I just copied out of the perl book, but I don't understand the asterisk.

[19:44] <flussence> I assume it's the same as perl5, so the asterisk means the class being constructed

[19:45] <sirrobert> yeah, I assumed the same thing, but ... would rather work from some more concrete knowledge =)

[19:45] <sirrobert> in case there's subtlety.

[19:45] <moritz> sirrobert: think of it as a piece of malloc()ed memory that is to be turned into an object; a * means "do the allocation for me"

[19:45] <pmichaud> in this case, asterisk means "please create a new instance for me" rather than "use this instance I already created"

[19:45] <sirrobert> hmmm ok, I can handle that...

[19:46] <sirrobert> is that true anywhere?

[19:46] <sirrobert> or just inside bless?

[19:46] <pmichaud> asterisk in general means "whatever"

[19:46] <sirrobert> ok

[19:46] <pmichaud> it's up to the thing being called to decide what "whatever" means

[19:46] <pmichaud> thus   5..*   is "5 up to whatever"  (Infinity)

[19:46] <sirrobert> that's pretty cool.

[19:46] <moritz> 5 + * # 5 plus whatever, creates a closure that adds 5 to its argument

[19:46] <pmichaud> @a[*-1]   is "the last element"  or "one less than whatever the biggest one is"

[19:47] <sirrobert> r: 5 + *

[19:47] <p6eval> rakudo 39087a:  ( no output )

[19:47] <sirrobert> how would I *use* that?

[19:47] <pmichaud> r: my $x = 5 + *;   say $x(20)

[19:47] <p6eval> rakudo 39087a: OUTPUT¬´25‚ê§¬ª

[19:47] <sirrobert> ahh

[19:47] <pmichaud> r: my $x = 5 + *;   say $x(3)

[19:47] <p6eval> rakudo 39087a: OUTPUT¬´8‚ê§¬ª

[19:47] <pmichaud> it's a closure.

[19:47] <sirrobert> that's super nice

[19:47] <moritz> r: say map *+5, 1, 2, 3

[19:47] <p6eval> rakudo 39087a: OUTPUT¬´6 7 8‚ê§¬ª

[19:48] <pmichaud> moritz++ # better example

[19:48] <sirrobert> I get the closure aspect... just didn't get the syntax for using it =)

[19:48] <pmichaud> you use it like any other block or closure, then :)

[19:48] <sirrobert> moritz: nice

[19:48] <moritz> r: say (1..10).grep: * %% 2

[19:48] <p6eval> rakudo 39087a: OUTPUT¬´2 4 6 8 10‚ê§¬ª

[19:48] <sirrobert> well, closure in general is broader than a block ...

[19:48] <moritz> right

[19:48] <sirrobert> there's no particular syntax associated

[19:49] <moritz> but usually it only makes sense to generate small closures with the * syntax

[19:49] <sirrobert> yeah

[19:49] <moritz> and usually blocks are used when small, anonymous pieces of code are needed

[19:49] <pmichaud> not sure I understand "closure in general is broader than a block" in a p6 sense... but... whatever :-)

[19:49] <sirrobert> r: say * + *, 1, 3

[19:49] <p6eval> rakudo 39087a: OUTPUT¬´WhateverCode.new()13‚ê§¬ª

[19:49] <moritz> pmichaud: routines are also closures

[19:50] <moritz> r: say (* + *)(1, 3)

[19:50] <p6eval> rakudo 39087a: OUTPUT¬´4‚ê§¬ª

[19:50] <pmichaud> moritz: routines are also blocks

[19:50] <sirrobert> ah, kinda lispy for the grouping

[19:50] <pmichaud> well, maybe not.

[19:50] <moritz> r: say Routine ~~ Block

[19:50] <p6eval> rakudo 39087a: OUTPUT¬´True‚ê§¬ª

[19:50] <pmichaud> yes, Routines are also Blocks :-)

[19:50] <moritz> r: my $c = * + *; say $c(1, 3)

[19:50] <p6eval> rakudo 39087a: OUTPUT¬´4‚ê§¬ª

[19:50] *** je joined
[19:50] <sirrobert> closure is just the principle of preservation of context past the scope's accessibility

[19:51] <pmichaud> sirrobert: but that happens for all blocks in Perl 6, at least conceptually

[19:51] <moritz> sirrobert: that's a nice way to put it

[19:51] <sirrobert> moritz: thanks =)

[19:51] <sirrobert> pmichaud: true, but the reverse isn't true

[19:51] <sirrobert> pmichaud: (not necessarily, I mean)

[19:51] <pmichaud> ...reverse isn't true?

[19:52] <sirrobert> just because all blocks offer closures doesn't mean all closures create blocks

[19:52] <sirrobert> that's all I meant =)

[19:52] <pmichaud> that's the part I don't understand (in a P6 context)

[19:53] <pmichaud> r:  say (* + 1) ~~ Block

[19:53] <p6eval> rakudo 39087a: OUTPUT¬´False‚ê§¬ª

[19:53] <pmichaud> okay, now I understand it.

[19:53] <moritz> pmichaud: fwiw I've emailed back and forth with szabgab++ for feedback on my &dir experiments (because he seems to use &dir at the moment). He likes it better than what we have now, and had some small ideas for further improvements

[19:54] <pmichaud> moritz: do your &dir experiments keep some level of API compatibility with 2012.06 ?

[19:54] *** adu joined
[19:54] <moritz> oh, speaking of &dir, that's also a backwards compatiblity break that wasn't already in 2012.06

[19:54] <moritz> pmichaud: some level, yes

[19:54] <moritz> pmichaud: they return Cool objects that stringify to the short name

[19:54] <pmichaud> that's likely sufficient for me.

[19:54] <moritz> whereas 2012.06 returns strings that are short names

[19:54] <moritz> ok

[19:55] <moritz> then I'll work on getting it into nom

[19:55] <pmichaud> at this point I don't think &dir has to return Str; it just has to return something that acts like a Str (which Cool would do)

[19:55] <moritz> oh, and I should do the star release this weekend, unless somebody else wants the honor

[19:56] <pmichaud> sorear: (sink)  I'm thinking of getting enough of sink context in place to handle the Failure case; eager might be a bit more than a first cut implementation.

[19:56] <moritz> it's all prepared; just needs some final glances, maybe a second look through the announcement, and a 'make VERSION=2012.07' + tar czf

[19:57] <pmichaud> but I also think we may have made a fundamental misassumption on sink, so I'm trying to figure out how to illustrate/word the misassumption

[19:57] <pmichaud> that's after lunch

[19:57] <pmichaud> moritz: +1 to a star release whenever you're ready

[19:57] <sorear> pmichaud: yeah, I just get a bit antsy about some-function-which-incidentally-returns-a-million-element-array; 2 could do a lot more work than the user expects

[19:58] <pmichaud> oh, I'm not too worried about million element arrays.  It should be costly only in the case of function that generates a million-element-array

[19:58] <pmichaud> in which case you really *do* want the function to be fully executed, to get its side effects.

[19:59] *** ChibaPet left
[19:59] <pmichaud> i.e.,   function that returns 1..1000000  can be cheap in sink context.

[19:59] <sorear> what if the function is like sub modinplace($arr, $ix, $v) { $arr[$ix] = $v; $arr; }

[19:59] *** brrt joined
[19:59] <sorear> and then the user does modinplace($bigarr, 1000, 2);

[19:59] <pmichaud> but function that returns   1..100000.map(&block)  should do the full thing

[20:00] <sorear> (this is a contrived example, but I beleive it illustrates a real problem that will wind up on the 'Perl 6 Warts' FAQ if we aren't careful)

[20:00] <pmichaud> sorear: I don't see how the example is problematic in sink context.

[20:01] <sorear> pmichaud: sink needs to rescan $bigarr for Failures

[20:01] <moritz> more than that

[20:01] <moritz> sink context empties arrays, no?

[20:01] <pmichaud> not in this context, no.

[20:01] <sorear> the user would have expected that sequence of operations to be constant in the size of $bigarr

[20:01] <moritz> there are multiple sink contexts?

[20:01] <pmichaud> I don't understand "sink content empties arrays"

[20:01] *** birdwindupbird joined
[20:02] *** je left
[20:02] <moritz> my @a = 1, 2, 3; @a; say @a; # what output do you expect?

[20:02] <pmichaud> I expect 1 2 3

[20:02] <sorear> I expect 1 2 3

[20:02] <moritz> ok

[20:02] <moritz> the never mind

[20:03] <pmichaud> sink context eagerly evaluates things.  in the case of an iterator, it may throw away the results of the iteration

[20:03] <pmichaud> but arrays aren't iterators

[20:04] <sorear> When would sink() ever see a naked iterator?

[20:04] <moritz> ok

[20:04] *** brrt left
[20:04] <dalek> specs: 9a73239 | moritz++ | S32-setting-library/Exception.pod:

[20:04] <dalek> specs: [S32::Exception] add Exception.fail

[20:04] <dalek> specs: review: https://github.com/perl6/specs/commit/9a732390c9

[20:04] <dalek> specs: 010e028 | moritz++ | S32-setting-library/Exception.pod:

[20:04] <dalek> specs: [S32::Exception] error message typos spotted by Nick Glencross

[20:04] <dalek> specs: review: https://github.com/perl6/specs/commit/010e0281ad

[20:04] <pmichaud> sink on a list could get propagated to its iterator

[20:04] <pmichaud> sink would not likely see an iterator directly.

[20:05] <pmichaud> but this gets back to my notion that we have a misassumption on sink context.... and I really need lunch so I'll be back in a while

[20:05] <pmichaud> afk for real this time bbl I really mean it good bye

[20:05] <moritz> pmichaud: don't let us hold you off

[20:05] *** brrt joined
[20:05] <sorear> 'we have a misassumption on sink context' yay, I'm not the only one who thinks this

[20:07] *** Tangaroa joined
[20:09] *** sisar left
[20:10] *** sisar joined
[20:22] <sirrobert> I can't seem to get "diag" to output anything in Test.pm

[20:22] <sirrobert> Any ideas why?

[20:23] <sorear> r: use Test; diag "Moo"

[20:23] <p6eval> rakudo 118004: OUTPUT¬´# Moo‚ê§¬ª

[20:23] <sirrobert> in my actual tests, it doesn't output anything.

[20:23] <sorear> npr: use Test; diag "Moo"

[20:23] <p6eval> rakudo 118004, niecza v19-7-g5e25209: OUTPUT¬´# Moo‚ê§¬ª

[20:23] <p6eval> ..pugs: OUTPUT¬´pugs: *** Unsafe function 'use' called under safe mode‚ê§    at /tmp/WQVp8fws1j line 1, column 1‚ê§¬ª

[20:24] <sorear> sirrobert: how are you running your tests?

[20:24] <sirrobert> I ran ufo, then doing make test

[20:24] <moritz> the harness catches those, I believe

[20:24] <sirrobert> which calls: prove -e 'perl6' -r t/

[20:24] <moritz> if you run   perl6 -Iblib/lib t/yourtestfile.t   you should see it

[20:24] <sorear> that's your problem.

[20:24] <sorear> prove hides diagnostics

[20:25] <sorear> it's just intended to give a summary

[20:25] <sorear> you could run prove -v -e perl6 -r t/

[20:26] <sorear> that will give you all the diagnostics - maybe more than you expect, Test.pm calls diag() internally for all failing tests

[20:26] * moritz finds that very useful

[20:26] <sorear> I like prove -v because it automatically color-codes the output

[20:26] <sorear> you could also run the tests directly with moritz' command

[20:27] <sirrobert> working on getting the right dirs...

[20:28] <sirrobert> there we go

[20:28] <sirrobert> had to set my env correctly.

[20:28] <sirrobert> thanks, both.

[20:30] <sirrobert> how can I coerce a string '123' into the int?

[20:30] <moritz> +'123'

[20:30] <moritz> or '123'.Int

[20:30] <sirrobert> ok

[20:34] <masak> evening, #perl6

[20:34] <moritz> \o masak

[20:34] <moritz> how's fpw?

[20:34] <sirrobert> hey

[20:34] <masak> moritz: great.

[20:35] <masak> moritz: spent the evening with jnthn and tadzik at a cozy restaurant by the riverside.

[20:35] <masak> moritz: it's bloody hot here, but the evenings are manageable.

[20:40] *** MayDaniel left
[20:41] *** brrt left
[20:44] <moritz> masak: I hope you'll like that commit...

[20:44] <dalek> rakudo/nom: 36922f3 | moritz++ | src/Perl6/Metamodel/MultiMethodContainer.pm:

[20:44] <dalek> rakudo/nom: improve error message for missing proto in the setting

[20:44] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/36922f396f

[20:44] <dalek> rakudo/nom: 9394f7d | moritz++ | / (2 files):

[20:44] <dalek> rakudo/nom: &dir rework part 2

[20:44] <dalek> rakudo/nom: 

[20:44] <dalek> rakudo/nom: &dir now returns IO::File and IO::Dir objects.

[20:44] <dalek> rakudo/nom: It restores partial backwards compatiblity by returning Cool

[20:44] <dalek> rakudo/nom: objects that stringify to the basename, but still has a .path method

[20:44] <dalek> rakudo/nom: that returns the full path, enabling the things that masak++ wanted to

[20:44] <dalek> rakudo/nom: achieve with his first rework. You can still call file test methods on the

[20:44] <dalek> rakudo/nom: result objects.

[20:44] <dalek> rakudo/nom: 

[20:45] <dalek> rakudo/nom: Apologies to everyone who has to update their &dir-using code a second

[20:45] <dalek> rakudo/nom: time within two weeks, but I firmly believe this is a good way forward.

[20:45] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9394f7d289

[20:45] <moritz> tomorrow I'll update ufo and File::Tools, unless somebody beats me to it

[20:47] *** vmspb left
[20:49] <pmichaud> back again

[20:49] <pmichaud> in general, I suspect that sink context should not cause Failures in scalar variables to throw

[20:49] <pmichaud> that would resolve the issue with sorear++'s example

[20:50] <pmichaud> the fact that a Failure is stored into a scalar variable is really enough to say "it's safe to handle this later"

[20:50] <moritz> that sounds interesting

[20:51] <moritz> my $f = open 'nosuchfile'; $f; # lives

[20:51] <moritz> my $f: = open 'nosuchfile'; $f; # dies

[20:51] <masak> moritz++ # &dir

[20:51] <moritz> I know, it's the "doctor, it hurts when I do this" stuff

[20:51] <pmichaud> yeah, if you're doing a bind, you're already saying "I know what I'm doing here."

[20:51] <pmichaud> (a low-level bind)

[20:52] <moritz> we just need to document that :-)

[20:52] <masak> moritz: just from reading the commit comment, it does sound like the best of two worlds.

[20:53] <moritz> masak: I hope it is. I've put a fair amount of thinking and work into it

[20:53] <pmichaud> should I put a blank notice into the announcement(s) that the IO system is likely to undergo some changes in the next few releases?

[20:53] <tadzik> good evening

[20:53] <pmichaud> s/blank/blanket/

[20:53] <sorear> pmichaud: doesn't that still leave the issue with repeated rescanning of arrays for bound failures?

[20:53] <moritz> pmichaud: yes; but we should also document stuff that'll continue to work

[20:53] <pmichaud> sorear: not sure about "bound failures"

[20:54] <pmichaud> sorear: afaic, I think of arrays as containers

[20:54] <pmichaud> and a container somewhat implies "you don't have to scan me for Failures"

[20:55] * masak almost said "hm, maybe I should thoughtlessly break more stuff so that smart and ambitious people will consider how to Do Them Right..." :P

[20:55] <pmichaud> the fact that a container is holding a Failure shouldn't be enough to make that Failure want to throw.

[20:55] <masak> s/Them/It/. 'stuff' is singular, I guess.

[20:55] <masak> my ability to parse French in real time still surprises and shocks me a bit.

[20:55] <sorear> pmichaud: what does sink [ map { maybe_fails($_) }, 1..* ] do?

[20:56] <sorear> pmichaud: I am supposing you want to make this a difference between List and Arraty

[20:56] <pmichaud> I'm more looking at it as a difference between contained and not-contained

[20:57] <pmichaud> but if that sink [ ... ]   didn't throw any failures, it wouldn't bother me.

[20:58] <moritz> masak: heh, ufo doesn't even need any changes after the last change

[20:58] <pmichaud> in some sense having the brackets there is like doing a bunch of    $a[0] = maybe_fails(1);  $a[1] = maybe_fails(2); ...

[20:58] <pmichaud> and assignments shouldn't throw failures

[20:58] <moritz> masak: but one can remove some redundant code

[20:59] <dalek> ufo: 1593c6b | moritz++ | bin/ufo:

[20:59] <dalek> ufo: simplify &dirwalk code after last rakudo &dir update

[20:59] <dalek> ufo: review: https://github.com/masak/ufo/commit/1593c6bd5a

[21:01] <masak> moritz++

[21:01] *** pupoque left
[21:01] <sorear> pmichaud: what about sink do { my @foo; @foo[0] := maybe_fails(1) }

[21:01] <masak> tadzik++ fixed ufo earlier today, because it turned out some dunce had committed a &dirwalk "fix" that actually broke the thing.

[21:01] <pmichaud> I'm not sure that a binding should throw failures, either.

[21:02] <tadzik> hah, funny, just recently we've talked abot basename-alike being core-ish

[21:02] <tadzik> moritz++ making stuff sane

[21:03] <moritz> tadzik: maybe you want to change File::Find to return IO::File and IO::Dir objects instead of file File::Find::Result

[21:03] <pmichaud> but since there's a := there, I'd be okay if it threw.  That's a case that I'm willing to postpone a decision upon for the moment, unless there's a clear use case where it's a problem.

[21:03] <moritz> tadzik: now that we have 'em

[21:03] <sorear> pmichaud: should a List which contains failures throw?

[21:03] <masak> so much of Perl 6 development is investing brain cycles in making stuff sane. I like that.

[21:04] <pmichaud> sorear: if the List is being evaluated eagerly, I could see that.

[21:04] <tadzik> moritz: I shall look into that tomorrow

[21:04] <moritz> tadzik: https://gist.github.com/3020637 that's a patch to make it work

[21:04] <moritz> (but still uses File::Find::Result)

[21:05] <pmichaud> I can imagine that a List being evaluated eagerly and sunk would throw any Failures it encounters.

[21:06] <tadzik> moritz: do you have a commit bit? If not then please send me a pull request and I'll merge it tomorrow once I get the proper internet

[21:06] *** drbean joined
[21:07] <sorear> pmichaud: but not an Array being evaluated eagerly and sunk?

[21:07] <moritz> tadzik: I don't think I have one

[21:07] <pmichaud> sinking an array wouldn't throw away its values; they're stored.  

[21:07] <moritz> going to bed now, will pull request tomorrow

[21:07] <pmichaud> put another way, sinking an Array is simply performing bindings/assignments on its elements

[21:08] <sorear> pmichaud: sinking Lists throws away values?

[21:08] <pmichaud> sorear: if they're unbound, yes.

[21:08] <sorear> pmichaud: "unbound"?

[21:09] <pmichaud> my @a := map &block, 1..*;   # bound List

[21:09] * tadzik disconnects

[21:09] <pmichaud> map &block 1..*;   # unbound List

[21:10] <pmichaud> so, the other idea I had and have been playing with is to revisit the notion of 'want'

[21:10] <sorear> pmichaud: how can &sink tell the difference?  is this where my decision to go with a GC instead of reference counting is about to bite me?

[21:10] <pmichaud> sorear: Rakudo also doesn't do reference counting, so we want to avoid the same thing

[21:11] <pmichaud> iiuc, we eliminated 'want' because it's too hard to understand context in the presence of multiple dispatch

[21:12] <pmichaud> however, just because we're eliminating context such as list context, boolean context, etc for dispatch doesn't mean that all 'contextual' information has to be gone.  Indeed, any 'context' that doesn't affect the results of multiple dispatch could still be detected.

[21:12] <pmichaud> and perhaps sink context is one of those.

[21:13] <pmichaud> the other big context that we had to throw out was lvalue context, because it's definitely affecting multiple dispatch in the sense of 'is rw'

[21:14] <sorear> I don't understand how this aside on &want is related to the discussion of &sink

[21:15] <pmichaud> because a function can decide how to respond to sink context, instead of having to return something that knows how to do it

[21:15] <sorear> Are you saying that we should syntactically not call &sink on the results of the bind macro?

[21:15] <pmichaud> I'm saying that  sink is literally a (p5-style) context that a called function will decide how to handle.

[21:15] <pmichaud> instead of something to be invoked on the return from that function

[21:16] <sorear> ah..

[21:16] <pmichaud> thus assignment would ignore sink context altogether

[21:16] <sorear> I'll play with this idea

[21:16] <pmichaud> while .map would say "oh, I'm in sink context, so eagerly evaluate and throw what I get"

[21:17] <sorear> I need to add p5-style contexts to the Niecza VM anyway to support 'use v5' in uncooperative environments

[21:19] <pmichaud> there are some tricky parts to this approach, though

[21:20] <pmichaud> sub foo() { something; 1..*.map(&block); }  would need to pass the context of foo()'s caller to the map

[21:20] <pmichaud> same for things like   'return' and the like.

[21:21] <pmichaud> it's just an idea I had that might be worth exploring as opposed to trying to always sink return values.

[21:21] <sorear> pmichaud: thank you for reminding me of this

[21:22] <sorear> pmichaud: timtoady has been very clear in the past that 'am I being called in sink context' is a bit in the callframe

[21:22] <sirrobert> what's the right way to do this in a regex:  /blah \s* (<alpha>|<ws>*) $/

[21:22] <pmichaud> for all of these discussions, it would be really helpful to have a list of things that we know must sink (wrt eagerness and failure throwing) and things that never sink

[21:22] <sirrobert> ?

[21:22] <pmichaud> sirrobert: <ws>*  seems not-very-useful

[21:22] <sorear> sirrobert: <ws>* is always wrong, becuase <ws> matches zero or more whitespace characters

[21:22] <sirrobert> yeah, I want the * to apply to both <alpha> and <ws>

[21:23] <sorear> it's like [\s*]*

[21:23] <pmichaud> sirrobert: (<alpha>|<ws>)*   ?

[21:23] <sirrobert> I want to capture something like, "I am here" with that snippet.

[21:23] <sirrobert> words with spaces

[21:23] <sorear> /blah \s* (<alpha+space>*)/

[21:23] <sirrobert> hmmm

[21:23] <sirrobert> hrm!

[21:23] <sorear> /blah \s* (<:Alpha+:Space>*)/ # will be much faster on niecza

[21:24] <pmichaud> sirrobert: you want "I am here" to be caught by the parens?

[21:24] <pmichaud> i.e., not including the 'blah' ?

[21:24] <sirrobert> yeah

[21:24] <sirrobert> and in my particular case, the blah is always numerical

[21:24] <sirrobert> let's say it's always \d*

[21:24] <sirrobert> so that's easy =)

[21:25] <pmichaud> ( \w+ %% <.ws> )

[21:25] <sirrobert> what's %%?

[21:25] <masak> sirrobert: separator modifier.

[21:25] <pmichaud> or perhaps it's ( \w+ % <.ws> )

[21:25] <sirrobert> lots of voodoo going on here ;)

[21:26] *** fioc joined
[21:26] <pmichaud> sirrobert: foo %% ','   will match "foo", "foo,foo", "foo,foo,foo", etc.

[21:26] <sirrobert> (<:alpha+:space>*) seems to work

[21:26] <masak> the %% form will match 'foo,foo,foo,' as well.

[21:27] <masak> the % form won't.

[21:27] <pmichaud> right

[21:27] <pmichaud> I'm still having to learn the new %% and % forms; I'm still used to ** :-)

[21:27] <sirrobert> ok, I almost grok that

[21:27] <sirrobert> I can see it, but I'll have to use it a few times...

[21:27] <sirrobert> so is non-greedy the same?  *?

[21:27] <pmichaud> basically    <abc> % <def>   means "one or more <abc> separated by <def>"

[21:27] <sirrobert> same as perl5 I mean

[21:27] <masak> this is strangely consistent with % in arith being "modulo" and %% being "evenly divides". um, I guess :)

[21:27] <pmichaud> adding ? after a quantifier makes it frugal, yes.

[21:27] <masak> it makes more sense if you don't think about it :P

[21:28] <pmichaud> (frugal == non-greedy)

[21:28] <sirrobert> bon mot =)

[21:28] <pmichaud> adding : after a quantifier makes it non-backtracking

[21:28] <sirrobert> not thinking is slightly psychoallergenic for me, masak ;)

[21:28] <flussence> .oO( for symmetry we should define infix:</>(Str, Regex) to call split() :)

[21:29] <sirrobert> btw, I did some regex a minute ago that spun for a long, long time (never finished... I had to ^C out)

[21:29] <sirrobert> want me to try to reproduce?

[21:29] <pmichaud> it's possible to create regexes that infinite loop, yes.

[21:29] <pmichaud> especially if you quantify a zero-width match.

[21:30] *** zby_home_ joined
[21:31] <pmichaud> sorear: (sink bit in callframe)  yeah, that's what led me to think of this.  But I'm still not sure of all the mechanics of handling it, nor of the list of use cases we have to handle.

[21:32] <pmichaud> and in some places (e.g. metaoperators and the like) we may have to work to keep the intermediate callers "invisible" to sink bit stuff.

[21:32] <masak> sirrobert: about 'not thinking is slightly psychoallergenic for me', I know what you mean. I wasn't entirely serious. :)

[21:33] <masak> it's not as bad as I first thought with the meanings of % and %% in arith and regexes. it does make sense even when you think about it, actually.

[21:34] <sirrobert> masak:  I knew you were kidding =)  

[21:36] <masak> in both, %% means 'evenly divides'. in the regex world this comes out as meaning 'the "foo" and "," things are the same in amount'

[21:36] <masak> s/amount/quantity/

[21:37] <sirrobert> hmmm 

[21:37] <sirrobert> I think I like that6

[21:37] <sirrobert> -6

[21:38] <sirrobert> I didn't know %% meant anything arithmetically =)

[21:38] <sirrobert> arithmatically?

[21:38] <pmichaud> sirrobert: "evenly divisible by"

[21:39] <pmichaud> r:  say 100 %% 5

[21:39] <p6eval> rakudo 9394f7: OUTPUT¬´True‚ê§¬ª

[21:39] <pmichaud> r:  say 100 %% 3

[21:39] <p6eval> rakudo 9394f7: OUTPUT¬´False‚ê§¬ª

[21:39] <pmichaud> it's the short form of   (a % b == 0), in effect.

[21:40] <sirrobert> neat

[21:40] <sirrobert> ok, one more regex change...

[21:40] <sirrobert> how can I also capture hyphens in that capture?

[21:41] <sirrobert> (<:alpha+:space>*)

[21:41] <pmichaud> (<:alpha+:space+[-]>*)

[21:41] <sirrobert> I need alphas, whitespaces, and hyphens... =)

[21:41] <sirrobert> ahh

[21:41] <sirrobert> I had tried it without the brackets

[21:41] <pmichaud> brackets are the "and these characters" part.

[21:41] <sirrobert> that makes sense... an anonymous char class

[21:41] <pmichaud> right... same idea as   <[aeiou]>

[21:42] <pmichaud> thus you can do   <+[aeiou]+:space>

[21:42] <sirrobert> FINALLY... all tests passed =)  

[21:42] * pmichaud is still not used to the colon syntax there

[21:42] <sirrobert> going to go get dinner

[21:42] <pmichaud> sirrobert: \o/

[21:42] <sirrobert> (yeah, colon is weird for me still too =)

[21:43] <sirrobert> thanks a lot; ttyl.

[21:43] <sirrobert> well, I guess I should commit and push first ;)

[21:43] <pmichaud> commit early and often, yes :)

[21:45] <pmichaud> TimToady: (sink context)   what mechanism would you imagine being used to detect things like   "3 + $a; 1"  resulting in "useless use of + in sink context"?  Is that a compile-time detection, based on a trait of &infix:<+>, or is it something that &infix:<+> would carp about at runtime?

[21:47] <pmichaud> TimToady: do I need to resurrect a version of misc/pm.txt for these questions?  ;-)

[21:49] <sorear> based on talking to TimToady in the past, I imagined the former

[21:51] *** birdwindupbird left
[21:52] <pmichaud> is it a trait on the proto sub, then?

[22:06] *** whiteknight joined
[22:06] *** whiteknight is now known as Guest8599

[22:18] *** spider-mario left
[22:22] *** alester left
[22:23] <dalek> specs: d067a9c | pmichaud++ | S05-regex.pod:

[22:23] <dalek> specs: Add a note about declarative semantics to the section on interpolated arrays.

[22:23] <dalek> specs: review: https://github.com/perl6/specs/commit/d067a9cb0d

[22:23] <dalek> specs: 58b9c43 | pmichaud++ | questions.txt:

[22:23] <dalek> specs: Add "questions.txt", a place where spec-related implementation

[22:23] <dalek> specs: questions can be asked/answered.

[22:23] <dalek> specs: review: https://github.com/perl6/specs/commit/58b9c430b3

[22:26] <pmichaud> https://github.com/perl6/specs/blob/master/questions.txt # resurrection of misc/pm.txt

[22:34] *** shinobicl joined
[22:35] *** cistos joined
[22:36] *** cistos left
[22:40] *** bluescreen10 left
[22:51] *** zby_home_ left
[22:51] *** adu left
[22:52] *** mucker left
[22:53] *** bluescreen10 joined
[22:54] *** fioc left
[22:57] *** shinobicl left
[23:23] <sorear> pmichaud: I would put it as a trait on the proto sub.

