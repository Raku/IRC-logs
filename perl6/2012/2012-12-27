[00:02] <flussence> this makes no sense... `panda install Bailador` fails on test 05 with «No such method 'decode' for invocant of type 'Any'». The test runs fine when I run it manually

[00:05] <tadzik> perl6 -Ilib t/test or perl6 -Iblib/lib t/test?

[00:05] <tadzik> may be a precomp bug? :/

[00:06] <flussence> -Ilib

[00:06] <tadzik> yeah, try -Iblib/lib

[00:07] <flussence> yeah, fails there

[00:07] <tadzik> jnthn needs to be told, yea

[00:11] *** MayDaniel left
[00:12] <flussence> I wonder if the other problem I was having was caused by that too

[00:12] *** cognominal left
[00:17] *** rindolf left
[00:17] *** cognominal joined
[00:21] *** ServerSage left
[00:39] <japhb_> flussence, I'm thinking so; I'm getting precompile problems during panda's own bootstrap, when panda tries to compile itself (lib/Panda/Ecosystem.pm, in particular), after compiling its prereq modules:

[00:39] <japhb_> When pre-compiling a module, its dependencies must be pre-compiled first.

[00:39] <japhb_> Please pre-compile /home/geoff/git/rakudo/install/lib/parrot/4.10.0-devel/languages/perl6/site/lib/JSON/Tiny.pm

[00:40] <japhb_> Given that it just did that halfway up the screen, I call shenanigans.

[01:04] *** anuby joined
[01:14] *** hypolin joined
[01:38] *** geekosaur left
[01:41] *** anuby left
[01:42] *** anuby joined
[01:42] *** geekosaur joined
[01:44] *** japhb_ left
[01:54] *** sorear joined
[01:57] *** cognominal left
[02:17] *** mst is now known as humbug

[02:17] *** humbug is now known as mst

[02:50] *** FROGGS left
[03:03] *** FROGGS joined
[03:07] *** orafu left
[03:07] *** orafu joined
[03:23] *** aindilis joined
[03:36] *** colomon left
[04:19] *** jaldhar_ joined
[04:23] <lue> [backtracking] is that socket reading problem the reason why P6's SCGI module wouldn't work for me? ISTR noticing it didn't receive the entire message (although I never bothered to count how many bytes were returned)

[04:49] *** aindilis left
[05:16] <alec> what does the operator that looks like french quotation marks do?

[05:16] <alec> it's like >>, but it's a single character

[05:16] <alec> i can't type it because i'm in a TTY

[05:17] <alec> i think it's called 'hyper'?

[05:18] *** telex left
[05:19] <alec> also, it's not possible to simply type it as >>, is it? does it have to be the special unicode char?

[05:19] *** sftp left
[05:20] *** telex joined
[05:20] <alec> anyway, the character displays fine in my TTY, but i don't know how to type it...

[05:20] <alec> the line i am trying to figure out is:

[05:20] <alec> well, it's two lines:

[05:21] <alec> my ($s, $t) = open('rosalind_hamm.txt').lines();

[05:21] *** colomon joined
[05:22] <alec> say [+] ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:22] <alec> where >> is replaced by the character in question

[05:23] <doy> for what it's worth, >> and » are interpreted the same

[05:23] <alec> i see

[05:23] <alec> yes

[05:23] <alec> ok, that's comforting

[05:24] <doy> everything has an ascii representation, there are just some things that look nicer when reading the code

[05:24] <alec> ok

[05:24] <doy> r: say [1.5, 2.5, 3.5]>>.Int

[05:24] <p6eval> rakudo c8de2e: OUTPUT«1 2 3␤»

[05:24] <colomon> it's the hyper meta-op, in this case it's basically the same as say [+] ($s.comb Zeq $t.comb).map({ $_.not }).map({ $_.Int })

[05:25] <alec> ok

[05:25] <alec> Z makes it a zip, right?

[05:25] <colomon> though in theory the hyper version is allowed to operate in parallel while .map is sequential

[05:25] <alec> ok

[05:25] <colomon> Zeq is zipped eq, yes

[05:27] <alec> my ($s, $t) = open('rosalind_hamm.txt').lines();

[05:27] <alec> that's the first line

[05:27] <colomon> I'm not clear why you'd want to do Zeq and >>.not instead of just Zne

[05:27] <alec> it's not my code

[05:27] <alec> it's a solution to a rosalind.info problem

[05:27] <colomon> yes, I understand that, generic "you".  :)

[05:28] <alec> ah

[05:28] <alec> grondilu wrote it, dunno if he is a regular here

[05:28] <colomon> he is

[05:28] <alec> ok

[05:29] <alec> the first line basically makes sense to me, and i know what the code is doing already because i had to do it in order to see the solutions

[05:29] <alec> but the second line is not clear

[05:29] <alec> what does [+] do?

[05:29] <alec> i'm new to perl btw

[05:30] <colomon> It adds list that follows.

[05:30] *** telex left
[05:30] <alec> i don't know any perl, but i like the look of perl6 so much that i desperately want to learn it

[05:30] <alec> ok

[05:30] <colomon> [+] is new to perl 6.

[05:30] <alec> yeah

[05:30] <alec> does having an $ mean it's a string?

[05:30] <colomon> [ op] is the reduce meta-op.... so [+] 1, 2, 3 is the same is 1 + 2 + 3

[05:30] <alec> ahh

[05:30] <colomon> no, $ is just a normal scalar variable in perl

[05:30] <alec> i see

[05:30] <alec> ok

[05:31] <alec> what does .comb do?

[05:31] <colomon> with no arguments, it turns a string in a list of characters.

[05:31] <sorear> alec: what language(s), if any, do you already know?

[05:31] <colomon> r: say "Hello!".comb

[05:31] <p6eval> rakudo c8de2e: OUTPUT«H e l l o !␤»

[05:31] <colomon> sorear!  \o/

[05:31] * colomon is relieved sorear++ is around, as colomon needs to get to bed

[05:31] <alec> i can write/read python but i'm no python god

[05:31] <sorear> 'eh, colomon.

[05:32] <alec> and i'm very comfortable in bash

[05:32] <alec> i've dabbled in haskell a bit

[05:32] <alec> but i'm just at the level where i can read it and sorta get what's going on

[05:32] <sorear> [+] = Prelude.sum

[05:32] <alec> ok

[05:33] <colomon> r: say ("Hello".comb Zeq "hello".comb)

[05:33] <p6eval> rakudo c8de2e: OUTPUT«False True True True True␤»

[05:33] <sorear> also foldl (+) 0

[05:33] <colomon> r: say ("Hello".comb Zeq "hello".comb)>>.not

[05:33] <alec> ahh

[05:33] <p6eval> rakudo c8de2e: OUTPUT«True False False False False␤»

[05:33] <alec> nice

[05:33] <sorear> [foo] = foldl/foldr

[05:33] <alec> yeah

[05:33] <colomon> r: say ("Hello".comb Zeq "hello".comb)>>.not>>.Int

[05:33] <p6eval> rakudo c8de2e: OUTPUT«1 0 0 0 0␤»

[05:33] <colomon> r: say [+] ("Hello".comb Zeq "hello".comb)>>.not>>.Int

[05:33] <p6eval> rakudo c8de2e: OUTPUT«1␤»

[05:33] <sorear> it uses the operator's declared direction and neutral element

[05:33] <alec> ahhhh

[05:33] <colomon> should be the same as

[05:33] <alec> yes

[05:33] <colomon> r: say [+] ("Hello".comb Zne "hello".comb)>>.Int

[05:33] <p6eval> rakudo c8de2e: OUTPUT«1␤»

[05:34] <colomon> r: say [+] ("Hello".comb Zne "hello".comb) # or even

[05:34] <p6eval> rakudo c8de2e: OUTPUT«1␤»

[05:34] <colomon> (ne is "strings are not equal", just as eq is "strings are equal")

[05:34] <alec> yes

[05:35] <alec> r: say "Hello".comb

[05:35] <p6eval> rakudo c8de2e: OUTPUT«H e l l o␤»

[05:35] <alec> ok, i'm getting it i think

[05:35] <colomon> okay, I've got to get to bed.  good night, all

[05:35] <alec> night colomon

[05:36] *** telex joined
[05:36] <alec> r: my $s = "hello"; my $t = "world; say [+] ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:36] <p6eval> rakudo c8de2e: OUTPUT«===SORRY!===␤Unable to parse expression in double quotes; couldn't find final '"'␤at /tmp/RsSoCh6FwE:1␤------> y [+] ($s.comb Zeq $t.comb)>>.not>>.Int;⏏<EOL>␤    expecting any of:␤        method arguments␤»

[05:36] <alec> hmm

[05:36] <alec> why didn't that execute?

[05:37] <alec> oops

[05:37] <alec> r: my $s = "hello"; my $t = "world"; say [+] ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:37] <p6eval> rakudo c8de2e: OUTPUT«4␤»

[05:37] <alec> ok

[05:37] <alec> getting it now

[05:37] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:37] <p6eval> rakudo c8de2e: OUTPUT«1 1 1 0 1␤»

[05:37] <alec> yeah

[05:37] <alec> i still don't fully understand >> but that's because i don't fully understand the $_

[05:38] <sorear> foo>>.bar => map (\x -> x.bar) foo

[05:38] <sorear> interpreting .bar as a method call

[05:38] <sorear> $_ is not involved

[05:40] <alec> right, it's just that colomon described >>.not as being somehow equivalent to .map({ $_.not })

[05:40] <alec> is there a way to think of it in terms of sets and functions?

[05:41] <sorear> that's the same as .map(-> $_ { $_.not })

[05:41] <sorear> -> $foo { CODE } is how you write a lambda in perl 6

[05:41] <alec> ok

[05:41] <sorear> if you leave off -> $foo, -> $_ is assumed

[05:41] <alec> yes, i've seen that in the one other perl6 snippet i've looked at

[05:41] <alec> ok

[05:41] <alec> but what is $_? is it familiar from perl5?

[05:42] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb);

[05:42] <p6eval> rakudo c8de2e: OUTPUT«False False False True False␤»

[05:43] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb)>>.not;

[05:43] <p6eval> rakudo c8de2e: OUTPUT«True True True False True␤»

[05:43] *** geekosaur left
[05:43] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb)>>.Int;

[05:43] <p6eval> rakudo c8de2e: OUTPUT«0 0 0 1 0␤»

[05:43] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb)>>.not.Int;

[05:43] <p6eval> rakudo c8de2e: OUTPUT«5␤»

[05:44] <sorear> alec: $_ is just an ordinary "anonymous" variable

[05:44] <alec> ok

[05:44] <sorear> alec: perl 5 uses $_ too in some cases.  for instance (p5) for @list { $_ is valid here }

[05:44] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:44] <p6eval> rakudo c8de2e: OUTPUT«1 1 1 0 1␤»

[05:44] <alec> ok

[05:44] <sorear> er, for (@list) { $_ is valid here }

[05:44] *** geekosaur joined
[05:45] <sorear> you could of course also do for my $whatever (@list) { $whatever is valid here }

[05:45] <alec> ok

[05:45] <sorear> but for very short loops, for @stuff { $_++ } can be a nice saving

[05:45] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb).not.Int;

[05:45] <p6eval> rakudo c8de2e: OUTPUT«0␤»

[05:45] <alec> yes

[05:45] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb).not.>>Int;

[05:45] <p6eval> rakudo c8de2e: OUTPUT«===SORRY!===␤Confused␤at /tmp/RNnYdVJQ72:1␤------>  "world"; say ($s.comb Zeq $t.comb).not.⏏>>Int;␤    expecting any of:␤        dotty method or postfix␤»

[05:45] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb).not>>.Int;

[05:45] <p6eval> rakudo c8de2e: OUTPUT«0␤»

[05:46] <alec> r: my $s = "hello"; my $t = "world"; say [+] ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:46] <p6eval> rakudo c8de2e: OUTPUT«4␤»

[05:47] <alec> r: my $s = "hello"; my $t = "world"; say ($s.comb Zeq $t.comb)>>.not>>.Int;

[05:47] <p6eval> rakudo c8de2e: OUTPUT«1 1 1 0 1␤»

[05:47] <alec> i'm still a bit confused

[05:47] <doy> which part don't you understand?

[05:47] <alec> hmmm

[05:48] <alec> do you think it's important to understand why >> does what it does in order to use it?

[05:48] <alec> because if it's not, then i needn't bother i guess

[05:48] <doy> what do you mean by "why"?

[05:48] <doy> it does what it does because it's a useful thing to do on occasion

[05:48] <alec> yes

[05:49] <alec> i mean how it causes things to happen

[05:49] <alec> how it actually functions under the hood

[05:49] <doy> a lot of the point of >>. vs something like an explicit map is that you don't know how it works under the hood

[05:49] <doy> if i understand things correctly

[05:49] <alec> ok

[05:49] <flussence> the important thing to understand about » is that it's allowed to do each item of the list in random order

[05:49] <doy> that way, it's free to do things like parallelize the operation if possible

[05:50] <doy> or do other things like that

[05:51] <doy> as far as i'm aware, all current implementations just treat it as equivalent to a map, but that's not guaranteed

[05:51] <alec> ok

[05:52] <alec> how can i play around with rakudo on my own?

[05:52] <alec> as a command interpreter?

[05:52] <flussence> doy: nope, they actually randomise the order so that people don't depend on it behaving like map

[05:52] <doy> flussence: ah, that's a good idea

[05:53] <doy> alec: you can install it via your distro's package manager, or build it from source from the github repository

[05:53] <alec> yes, i've got it

[05:53] <alec> do i just start perl6 if i want an interpreter?

[05:56] <alec> nvm

[05:56] <alec> i got it

[06:03] <moritz> \o

[06:06] <sorear> o/

[06:13] <alec> ok, got a question regarding that stuff

[06:14] <alec> r: my $s="suetohaueas"; my $t="zzzzzzozzzz"; say ($s.comb Zeq $t.comb).Int;

[06:14] <p6eval> rakudo c8de2e: OUTPUT«11␤»

[06:14] <alec> r: my $s="suetohaueas"; my $t="zzzzzzozzzz"; say ($s.comb Zeq $t.comb)>>.Int;

[06:14] <p6eval> rakudo c8de2e: OUTPUT«0 0 0 0 0 0 0 0 0 0 0␤»

[06:14] <alec> why does .Int alone make it 11?

[06:15] <doy> the .Int method on arrays returns the length

[06:15] <alec> aaah

[06:15] <alec> i see

[06:15] <alec> ok

[06:15] <alec> that makes sense

[06:15] <alec> thank you

[06:15] <alec> where can i read about these methods?

[06:15] *** skids left
[06:18] <doy> not entirely sure where the most useful place is, but the language spec is here http://perlcabal.org/syn/

[06:18] <doy> looks like the Numeric section of S32 has some information

[06:18] <alec> ok

[06:18] <alec> ah, i already had that site open in a tab

[06:24] *** quester joined
[06:25] *** adu joined
[06:27] *** skids joined
[06:29] *** jokar joined
[06:35] *** SamuraiJack joined
[06:44] *** adu left
[06:57] *** DaVe joined
[06:57] <DaVe> ?

[06:57] <DaVe> who am I?

[06:57] *** DaVe is now known as Guest84522

[06:57] <Guest84522> where am I?

[06:58] <Guest84522> Why should I wait till next Christmas to get perl6 in production? 

[06:59] <Guest84522> I have been waiting for 5 Christmases

[07:02] *** Guest84522 left
[07:08] <moritz> don't wait, just use it

[07:13] <sorear> moritz: ey's gone

[07:13] * moritz noticed

[07:14] *** xinming_ joined
[07:17] *** xinming left
[07:19] *** elkng joined
[07:20] <elkng> "does Perl 6 compiler uses a slab allocator for internal memory management same as Perl 5 compiler ?"

[07:23] <moritz> "how is compiler baby made?"

[07:29] *** am0c joined
[07:45] *** arkydo joined
[08:04] *** ServerSage joined
[08:04] *** GlitchMr joined
[08:10] *** rindolf joined
[08:15] *** kaare_ joined
[08:15] *** SamuraiJack_ joined
[08:17] *** SamuraiJack left
[08:20] *** SamuraiJack_ left
[08:21] *** SamuraiJack_ joined
[08:30] *** SamuraiJack_ left
[08:33] *** SamuraiJack_ joined
[08:46] *** quester left
[08:59] *** arkydo left
[09:11] *** rummik joined
[09:11] *** labster joined
[09:14] <labster> Hi all.  I've been following Perl 6 for a couple of years now, eagerly awaiting Christmas.  Not that I'm a good enough programmer to make Christmas come any faster, so I haven't felt like contributing much.

[09:14] <labster> though I finally got myself together, and decided to make a port of File::Find::Duplicates, because perl can always use more modules.  https://github.com/labster/perl6-File-Find-Duplicates

[09:16] <moritz> labster: cool

[09:17] <moritz> labster: I've given you commit access so that you can add the META.info URL to https://github.com/perl6/ecosystem/

[09:18] <moritz> (to META.list)

[09:19] <labster> oh, thanks.  The code isn't that great yet, and I'm sure I lost most of the laziness in the evaluation, but hey, it works.  at least on rakudo.

[09:23] *** arkydo joined
[09:27] <doy> does Test come with rakudo?

[09:28] <dalek> ecosystem: 4699222 | (Brent Laabs)++ | META.list:

[09:28] <dalek> ecosystem: Added File::Find::Duplicates

[09:28] <dalek> ecosystem: review: https://github.com/perl6/ecosystem/commit/46992225f1

[09:32] <moritz> 

[09:32] <moritz> v

[09:32] <labster> according to S24, it does come with rakudo.  At least it came with r* for me.

[09:34] *** scottp joined
[09:35] *** ShaluS joined
[09:36] <sorear> doy: yes

[09:36] <doy> what is the appropriate way to use rakudo after building it from a checkout

[09:36] <moritz> make install

[09:36] <sorear> doy: make install, then run it.  PREFIX defaults to $PWD/install to make this work

[09:36] <moritz> then put the install/bin dir into your $PATH

[09:37] <felher> good morning, #perl6

[09:37] <sorear> elkng: semantic error in question.  perl 6 is a language with several implementations; neither rakudo nor niecza directly uses the system malloc for objects

[09:38] <elkng> "moritz what is baby made?"

[09:38] <moritz> oh, that was a question? I thought it was a quote

[09:38] <moritz> so I replied with a quote in kind

[09:38] <sorear> elkng: why are you surrounding your questions with quotes?

[09:39] *** FROGGS left
[09:39] <elkng> sorear: I tryed it once

[09:41] *** Psyche^ joined
[09:45] *** ShaluS left
[09:45] *** Patterner left
[09:45] *** Psyche^ is now known as Patterner

[09:50] *** arkydo left
[09:52] *** SmokeMachine joined
[10:04] *** hypolin left
[10:07] *** Kharec joined
[10:29] *** anuby left
[10:46] *** labster left
[10:51] *** Kharec left
[11:15] <masak> g'day, #perl6

[11:18] <tadzik> hey hey

[11:21] <elkng> questions should be specifically aboutperl6 to post here ?

[11:22] <masak> moritz: it's "compiler babby formed", not "baby made". :P

[11:23] <masak> elkng: we're quite lenient about off-topic discussions. but it's good if you at least try to have some connection to Perl 6, yes.

[11:23] *** rummik left
[11:29] *** proller joined
[11:36] *** proller left
[11:39] *** proller joined
[11:39] <masak> only two days left to sign up to p6cc2012! http://strangelyconsistent.org/blog/the-2012-perl-6-coding-contest

[11:40] <masak> don't be left out. sign up now. :)

[11:42] <elkng> is perl6 finished allready ?

[11:43] *** mcglk left
[11:46] *** FROGGS joined
[11:47] <masak> elkng: I'll answer, but first: is Perl 5 finished already?

[11:47] <masak> (I need to know your definition of "finished" here.)

[11:48] <FROGGS> hi there

[11:49] <masak> FROGGS! \o/

[11:49] <FROGGS> masak! \o/

[11:49] <FROGGS> :o)

[11:49] *** proller left
[11:54] <elkng> masak: is said perl6 was developed for very long period and how its now ? can be used as much as perl 5 ?

[11:58] *** proller joined
[11:58] <FROGGS> elkng: Perl 6 has not that much modules of course, but the language is ready and more powerful of course

[11:59] <FROGGS> and Perl 6 is as fast/slow as Perl 5 + Moose

[12:01] <masak> FROGGS: er.

[12:01] <masak> elkng: what FROGGS said except the last part. :)

[12:02] <masak> elkng: I started using Perl 6 in earnest back in 2008. back then, the leading implementation had *lots* of bugs.

[12:02] <masak> now, not so much. now it's very usable.

[12:02] <masak> there are things missing, mostly in the modules camp.

[12:02] <masak> and documentation is still lacking.

[12:02] *** rummik joined
[12:02] <masak> people are working on that.

[12:04] <FROGGS> masak: whats wrong with the last part?

[12:06] <masak> FROGGS: putting aside the fact that it's Rakudo/Niecza that's slow or fast, not Perl 6...

[12:06] <masak> FROGGS: ...neither implementation beats Perl 5 in terms of runtime speed.

[12:06] *** proller left
[12:06] <masak> you must be thinking of startup speed.

[12:07] <huf> what's rakudo/niecza's startup speed now?

[12:07] <masak> but advertising that as "Perl 6 is as fast/slow as Perl 5 + Moose" is *wildly* misleading.

[12:07] <FROGGS> masak: right, I mean rakudo in this case, not the spec

[12:07] <masak> huf: Rakudo's is quite good nowadays. on the order of .3 seconds, I think.

[12:07] <huf> oh, that *is* close to p5+Moose

[12:07] <masak> FROGGS: because the spec can't be executed directly.

[12:07] <huf> which is ~.25 on my box

[12:08] <masak> huf: I shouldn't give hard figures like that. it will depend a lot on your hardware, of course.

[12:08] <masak> look, someone likes Rakudo's new error messages: https://twitter.com/leed0/status/281887675840094208/photo/1

[12:08] <FROGGS> masak: there was a talk at YAPC::EU 2012 about speed comparision, rakudo was in some cases faster than Perl 5 + Moose, and IIRC it was not just about startup times

[12:08] <masak> jnthn++

[12:09] <masak> FROGGS: I'm sure there are isolated cases where Rakudo can compete, yes.

[12:09] <masak> we're not yet at the point where we can pretend it can compete in all areas.

[12:09] <FROGGS> ya, that is true

[12:11] *** bbkr left
[12:12] <FROGGS> FWIW, "Perl 6" or better its implementations is ready when there is an announcement saying that

[12:12] <FROGGS> and I believe this could be made already

[12:20] <masak> sure. the *announcement* that Perl 6 implementations are ready could've been made at any time.

[12:20] <masak> as early as the day after the announcement to start Perl 6 itself.

[12:20] <masak> ...doesn't make it useful. :)

[12:20] <masak> ...or true.

[12:24] *** proller joined
[12:25] <masak> the reality of it all is, and has always been, that there isn't a "ready" bit for Perl 6 and its implementations, which we have to inspect carefully and announce when it flips over to True.

[12:26] <masak> instead, every day the implementations grow a little more useful, and will cover a few new use cases for a few new people. gaining in speed and stability.

[12:27] <masak> the trick is to be clear about those new features, to blog about them and speak about them at conferences, and to craft informative release announcements. this will pull in the right people.

[12:27] <masak> but I seriously don't believe in all this "ding! cake's done!" crap. sorry.

[12:31] *** MayDaniel joined
[12:31] <FROGGS> well, if you wanna wait for the day when there is no bug anymore in rakudo or niecza, then you can wait very long

[12:32] <FROGGS> is there a roadmap of important features that need to implemented in order to call it ready?

[12:33] * au wonders if such announcements can be made by anyone, whenever and wherever they found perl6 to be ready for their particular use. "cake's good enough for me here!"

[12:33] <FROGGS> as you said earlier, a software is never complete and never will be stalled, so there must be made a decision at some point to call it ready

[12:34] <FROGGS> au: good point

[12:35] <masak> FROGGS: bugs isn't a big blocker, and hasn't been for years. that was not what I was going for.

[12:36] <masak> FROGGS: speed. user-facing documentation. a realistic connection to CPAN. those are the big three.

[12:36] <masak> (that's my personal roadmap, mind)

[12:36] <FROGGS> okay, I think I agree with these points

[12:37] <masak> here's a roadmap for Rakudo: https://github.com/rakudo/rakudo/blob/nom/docs/ROADMAP

[12:38] <masak> Niecza usually does planning in its release messages, but I see no such planning in v24's.

[12:38] <arnsholt> au: I like that approach. Very distributed systems-ish

[12:38] <masak> very anarchic. :)

[12:39] <masak> but there's nothing stopping anyone from doing that already.

[12:39] <au> yup. :)

[12:39] <masak> some people have.

[12:39] <masak> I think ingy did such a post.

[12:39] <masak> http://blogs.perl.org/users/ingy_dot_net/2010/07/rakudos-really-really-release-ready.html

[12:39] <masak> in *2010*.

[12:40] <timotimo> :D

[12:40] <FROGGS> hmmm, at work I use about 80 Perl 5 modules, I believe the half of them have not that many deps, maybe none at all... would be a cool thing to actually replace all that with Perl 6 code...

[12:40] * FROGGS writes his own roadmap

[12:41] <FROGGS> but I dont wanna write DateTime::SpanSet

[12:43] <FROGGS> NET::EMI (to send SMS) might be done in a day

[12:44] <masak> FROGGS: I like this way of thinking. :)

[12:51] *** proller left
[12:52] *** proller joined
[12:55] <masak> more precisely, the "what can I use Perl 6 for today, with what's there?" kind of thinking.

[12:56] *** colomon left
[12:56] <FROGGS> well, I recognized that Perl 6 code because of its OO nature is more readable as the crap I wrote years ago with Perl 5

[12:57] <FROGGS> so I hope it is easier to maintain

[12:57] <FROGGS> and doing new things is always cool and fun

[13:00] <Ayiko> cake is fun!

[13:01] * FROGGS .oO( the cake is a lie )

[13:01] <Ayiko> it can also do useful stuff now and then :)

[13:02] <Ayiko> and cool things! (unlike what I need to use at work)

[13:02] *** proller left
[13:03] *** colomon joined
[13:03] *** proller_ joined
[13:03] *** proller joined
[13:03] *** proller_ left
[13:05] *** proller_ joined
[13:08] *** proller left
[13:09] *** cognominal joined
[13:13] *** Khisanth left
[13:19] *** pmurias joined
[13:26] *** Khisanth joined
[13:44] * diakopter waves hi from an airport

[13:44] <tadzik> hi hi

[13:50] <FROGGS> hi

[13:54] <masak> o/, diakopter 

[13:58] *** proller_ left
[13:59] *** proller_ joined
[14:02] *** elkng_ joined
[14:02] *** elkng left
[14:03] *** DrEeevil joined
[14:04] *** elkng_ is now known as elkng

[14:05] *** ivan`` left
[14:06] *** ivan`` joined
[14:13] *** PacoAir joined
[14:25] *** pmurias left
[14:31] *** denisboyun_ joined
[14:37] *** jokar left
[14:39] *** atrodo joined
[14:48] *** am0c left
[14:55] *** denisboyun_ left
[15:06] *** dayangkun joined
[15:07] *** dayangkun left
[15:07] *** pmurias joined
[15:07] *** dayangkun joined
[15:14] *** cognominal left
[15:16] *** stopbit joined
[15:32] *** lorn left
[15:34] *** lorn joined
[15:34] *** grondilu joined
[15:35] *** rummik left
[15:35] *** rummik joined
[15:36] *** isBEKaml joined
[15:39] *** pmurias left
[15:41] *** isBEKaml left
[15:42] *** cognominal joined
[15:47] *** werwerwer_ joined
[15:50] *** werwerwer left
[15:50] *** denisboyun_ joined
[15:54] *** pmurias joined
[15:54] <pmurias> jnthn: should http://pastie.org/5584751 produce a correct setting?

[15:55] <pmurias> jnthn: I get http://pastie.org/5584758 when trying to load that

[15:56] *** arkydo joined
[15:56] *** lk joined
[15:57] *** lk left
[16:04] <grondilu> rn: say sqrt(9) ~~ Int

[16:04] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT«False␤»

[16:07] <masak> rn: say sqrt(9) ~~ Num

[16:07] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT«True␤»

[16:07] <masak> \o/

[16:08] <masak> rn: say 2 ** 128

[16:08] <p6eval> rakudo c8de2e, niecza v24-12-g8e50362: OUTPUT«340282366920938463463374607431768211456␤»

[16:08] <masak> rn: say sqrt 2 ** 128

[16:08] <p6eval> niecza v24-12-g8e50362: OUTPUT«1.8446744073709552E+19␤»

[16:08] <p6eval> ..rakudo c8de2e: OUTPUT«1.84467440737096e+19␤»

[16:12] *** am0c joined
[16:12] <masak> apparently, the Lisp term for "macroish" is https://en.wikipedia.org/wiki/Fexpr

[16:13] *** Chillance joined
[16:24] <pmurias> masak: is "macroish" a term we define somewhere?

[16:30] *** denisboyun_ left
[16:30] <masak> people keep using it on the channel to mean "its operands look like ordinary parameters, but they're more like thunks"

[16:31] <masak> examples: 'if', '&&', '||', '//', attribute initializations.

[16:31] *** xinming_ is now known as xinming

[16:32] *** denisboyun_ joined
[16:33] *** pmurias left
[16:36] *** bluescreen10 joined
[16:36] *** pmurias joined
[16:43] *** SamuraiJack_ left
[16:46] *** denisboyun_ left
[16:49] *** am0c left
[16:53] *** bluescreen10 left
[16:57] *** arkydo left
[17:02] *** bluescreen10 joined
[17:05] *** sftp joined
[17:10] *** pmurias left
[17:12] *** pmurias joined
[17:17] *** alec left
[17:35] *** proller_ left
[18:04] *** REPLeffect left
[18:04] *** REPLeffect joined
[18:05] *** denisboyun_ joined
[18:29] *** denisboyun_ left
[18:42] *** cognominal left
[18:49] *** snearch joined
[18:51] *** arkydo joined
[18:54] *** fgomez left
[18:57] *** denisboyun_ joined
[19:02] *** REPLeffect left
[19:16] *** fgomez joined
[19:24] *** arkydo left
[19:26] <doy> rpn: class Foo { has Hash of Hash $.foo = {} }; Foo.new

[19:26] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "of"␤    expecting variable name␤    at /tmp/BfDFlYmEB9 line 1, column 22␤»

[19:26] <p6eval> ..niecza v24-12-g8e50362: OUTPUT«===SORRY!===␤␤Coercive declarations NYI at /tmp/24VpPs2B34 line 1:␤------> class Foo { has Hash of Hash⏏ $.foo = {} }; Foo.new␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1443…

[19:26] <p6eval> ..rakudo c8de2e: OUTPUT«Type check failed in assignment to '$!foo'; expected 'Hash+{TypedHash}' but got 'Hash'␤  in block  at src/gen/CORE.setting:755␤  in method BUILDALL at src/gen/CORE.setting:733␤  in method bless at src/gen/CORE.setting:723␤  in method new at src/gen/CORE.setting:708…

[19:27] <doy> am i misunderstanding how this works, or is this just not properly implemented yet

[19:28] <flussence> I think typed hash/arrays aren't quite there

[19:32] <masak> I don't recall seeing 'of' in working code.

[19:32] *** denisboyun_ left
[19:32] <doy> okay

[19:33] <doy> it just looked like it was trying to work, so i wasn't sure

[19:36] <doy> heh, and running that line in rakudo's repl makes it segfault once you exit

[19:37] * masak tries to reproduce that

[19:37] *** rummik left
[19:37] <masak> yep.

[19:38] *** rummik joined
[19:38] * masak submits rakudobug

[19:42] *** thou left
[19:46] <dalek> star: 1300bc2 | moritz++ | docs/announce/2012.12:

[19:46] <dalek> star: [announce] fix some numbers

[19:46] <dalek> star: review: https://github.com/rakudo/star/commit/1300bc210b

[19:49] *** Kharec joined
[19:54] *** denisboyun joined
[19:54] <dalek> star: 0feb3a0 | moritz++ | tools/star/release-guide.pod:

[19:54] <dalek> star: add 2012.12 release to release-guide.pod

[19:54] <dalek> star: review: https://github.com/rakudo/star/commit/0feb3a0a63

[19:56] <moritz> Rakudo star 2012.12 released.

[19:59] <doy> r: class Foo { method foo { self.bar; return }; method bar { for (1, 2, 3) -> $a { die "???" }; return } }; Foo.new.foo

[19:59] <p6eval> rakudo c8de2e: OUTPUT«???␤  in method bar at /tmp/BvHMVayfXJ:1␤  in method foo at /tmp/BvHMVayfXJ:1␤  in block  at /tmp/BvHMVayfXJ:1␤␤»

[19:59] <doy> r: class Foo { method foo { self.bar; return }; method bar { for (1, 2, 3) -> $a { die "???" } } }; Foo.new.foo

[19:59] <p6eval> rakudo c8de2e:  ( no output )

[19:59] <doy> r: class Foo { method foo { self.bar }; method bar { for (1, 2, 3) -> $a { die "???" } } }; Foo.new.foo

[19:59] <p6eval> rakudo c8de2e: OUTPUT«???␤current instr.: 'throw' pc 329649 (src/gen/CORE.setting.pir:147534) (src/gen/CORE.setting:9196)␤called from Sub 'die' pc 34121 (src/gen/CORE.setting.pir:13473) (src/gen/CORE.setting:558)␤called from Sub '' pc 332 ((file unknown):187) (/tmp/bbLj_nOXKc:1)␤called …

[20:00] <doy> ^^ another bug?

[20:00] <masak> moritz++ # release!

[20:00] <masak> doy: wh...

[20:00] <masak> oh.

[20:01] <masak> lazy for loop.

[20:01] <masak> I'm telling you, that stuff is confusing to people.

[20:02] <masak> TimToady++ suggested putting in a warning for that. may be a good idea.

[20:02] <doy> i find it quite odd that a for loop behaves differently as the last statement in a block than it does anywhere else

[20:03] <doy> that third one gets the error message wrong in any case

[20:03] <moritz> I don't see the point of warning of laziness

[20:03] <moritz> either lazy is what we want; then we educate people

[20:03] <moritz> or lazy is not what we want; then I throw out the whole sink stuff

[20:04] <moritz> but warnings gives you the worst of both worlds

[20:04] <moritz> you can't really use the laziness because the warnings are annoying

[20:04] <moritz> but still you have to factor in the fact that stuff could be lazy

[20:05] <doy> the confusing part here is that it's not always lazy

[20:05] <doy> i mean, why does the first one work properly?

[20:06] <timotimo> oh, a release!

[20:07] <masak> doy: because the for loop isn't the last statement, the 'return' is.

[20:08] <doy> oh right, i was thinking in terms of dynamic context, which i suppose isn't how perl 6 works

[20:08] <doy> or wait

[20:08] <doy> hmmm

[20:09] <doy> yeah

[20:09] <doy> i think

[20:09] <japhb> (Thinking out loud ...)  Is the unification of:  for @a -> $b { ...} ---> @a.map: -> $b {...}  a false one?  Even though they *can* be computationally equivalent, is it doing the right thing in programmer's brains?  Do we really just want a special form for map to avoid TTIAR (so it looks like a for does now) that does *not* like to be sunk?

[20:09] <japhb> .oO( Useless use of map in sink context )

[20:10] *** Kharec left
[20:10] <doy> for what it's worth, i would expect map to be lazy, but not for

[20:10] <colomon> japhb: yeah, I've never been convinced the unification makes sense.

[20:10] <colomon> what doy said.

[20:10] <japhb> agreed.

[20:11] <colomon> to be more precise: I would expect for to be lazy in evaluating the list you want to loop over.  But I would expect it to start looping right away.

[20:12] <doy> what's the difference?

[20:12] <japhb> colomon, I assume you mean so that you can 'last' out of a loop over an infinite sequence?

[20:12] <colomon> what japhb said.

[20:12] <doy> ah, right

[20:13] <colomon> or return from it, or any of perl's many other flow control operationrs.

[20:13] <japhb> Sure.  :-)

[20:13] <xenoterracide> question on Str.tc, I assume it's short for "Title Case" but is it Title Case? because I would say that ucfirst and title case imply different behaviors

[20:13] <japhb> Flow control operators: We haz them.

[20:14] *** denisboyun left
[20:14] <colomon> xenoterracide: it's supposed to be title case, but how well it is currently implemented I do not know.

[20:15] <japhb> xenoterracide, it is indeed titlecase.  I believe the removal of ucfirst is because people *think* that is correct behavior, but in many languages it isn't.  And we're trying to steer people towards default-correct behavior, rather than making them think about when it's correct and when not.

[20:15] <japhb> (Niecza may well have this better than Rakudo, because sorear++ spent a lot of time working through the Unicode specs, but I don't know for sure.)

[20:17] <xenoterracide> hmm

[20:17] <doy> so regardless of the lazy for issue, is the third snippet worth a bug report?

[20:18] <moritz> xenoterracide: there are some languages where there is a special uppercase char for the start of the word, or something

[20:18] <xenoterracide> interesting

[20:18] <japhb> doy: There may already be one, since I'm pretty sure that's been seen before.  Basically, VM errors should never escape raw all the way out to the user.

[20:19] <doy> okay

[20:19] <xenoterracide> well I'm off to job, maybe when I bore of games I'll get back to rakudo

[20:19] <japhb> (Hence much time spent squashing any number of NPMCA (Null PMC Access) errors)

[20:20] *** Kharec joined
[20:20] <doy> so one more design sort of question

[20:20] <doy> if i have an attribute in a role

[20:20] <doy> and want it to have a strict type constraint, but allow more lax values in the constructor (which get coerced to a standard form)

[20:20] <doy> what's the right way to do that

[20:21] <doy> overriding new works, but doesn't really make a lot of sense in a role

[20:21] <masak> so, your question is about coercion?

[20:21] <doy> yeah

[20:21] <masak> might help to talk around some small piece of code.

[20:21] <doy> okay, sec

[20:21] <moritz> you add a submethod BUILD to the role which calls a method that coerces the value before binding to the attribute?

[20:22] <doy> moritz: oh, BUILD is run before attributes are assigned?

[20:22] <masak> the new(-ish) syntax for coercien is TargetType(SourceType)

[20:22] <masak> BUILD assigns the attributes.

[20:22] <moritz> doy: BUILD is what binds the attributes

[20:22] <moritz> masak: but it's not properly implemented yet :(

[20:22] <doy> BUILD runs from least derived to most derived though, doesn't it?

[20:22] *** cognominal joined
[20:23] <doy> so shouldn't the attributes already be bound by the time it gets to the BUILD in my class?

[20:23] <moritz> yes, and no

[20:23] * moritz -> sleep

[20:24] <moritz> doy: have you read http://doc.perl6.org/language/objects#Object+Construction ?

[20:24] <moritz> really sleep&

[20:24] <doy> i skimmed it a while ago

[20:24] <doy> i'll read it over

[20:26] <masak> roles don't enter into the type hierarchy.

[20:26] <masak> they flatten into the class.

[20:28] <doy> oh, so a BUILD is actually generated that assigns the attributes, if you don't write one

[20:28] <doy> i was thinking that all happened at the base Object level

[20:33] *** denisboyun_ joined
[20:46] *** fgomez left
[20:46] *** buubot_backup left
[20:49] *** buubot_backup joined
[20:49] *** SmokeMachine left
[20:51] <doy> so i guess the issue i'm asking about involves typed hashes

[20:52] <doy> i want to turn Foo.new(things => [$bar, $baz]) into assigning $.things = { $bar.name => $bar, $baz.name = $baz }

[20:52] <doy> i'm not really clear on what would be involved to make something like that happen via the type system

[20:54] <doy> (i want the type of $.things to be "Hash of MyApp::Thing")

[20:55] <masak> r: class Thing { has $.name }; class Foo { has %.things; method new(@things) { my %things = map {; .name => $_ }, @things; self.bless(*, :%things) } }; my $bar = Thing.new(:name<bar>); my $baz = Thing.new(:name<baz>); say Foo.new(things => [$bar, $baz]).things.perl;

[20:55] <p6eval> rakudo c8de2e: OUTPUT«Not enough positional parameters passed; got 1 but expected 2␤  in method new at /tmp/Buw_1Vw09H:1␤  in block  at /tmp/Buw_1Vw09H:1␤␤»

[20:55] <masak> ah.

[20:55] <masak> r: class Thing { has $.name }; class Foo { has %.things; method new(:@things) { my %things = map {; .name => $_ }, @things; self.bless(*, :%things) } }; my $bar = Thing.new(:name<bar>); my $baz = Thing.new(:name<baz>); say Foo.new(things => [$bar, $baz]).things.perl;

[20:55] <p6eval> rakudo c8de2e: OUTPUT«("bar" => Thing.new(name => "bar"), "baz" => Thing.new(name => "baz")).hash␤»

[20:55] <doy> right, that's what i'm doing now

[20:55] <masak> doy: goodenuf?

[20:55] <doy> but $.things is defined in a role

[20:55] <doy> and it'd be nice to be able to have that coercion be encapsulated in the role

[20:56] <doy> i can't really have two roles that both override new like that

[20:56] <masak> I'm not sure I know of a good trick to do .new-like stuff from a role. sorry. :/

[20:56] <doy> okay

[20:57] <doy> i'm just fiddling with some existing moose code, and in that code, it works by having a coercion on the type constraint

[20:57] <doy> but i get the impression that that sort of thing works quite a bit differently in perl 6

[20:58] *** denisboyun_ left
[21:00] <masak> we don't fully have coercion on type constraints yet.

[21:00] <masak> it's not yet implemented, I mean.

[21:00] *** snearch left
[21:00] <doy> okay

[21:04] *** elkng left
[21:04] *** GlitchMr left
[21:20] *** raiph left
[21:30] *** REPLeffect joined
[21:32] *** kaare_ left
[21:33] *** pmurias left
[21:34] *** bbkr joined
[21:50] *** rindolf left
[21:51] <masak> 'night, #perl6

[21:52] <colomon> o/

[21:53] *** aindilis joined
[21:53] <FROGGS> wtf: http://www.ebay.de/itm/160914072789 ?

[21:55] * colomon is completely failing at paying his taxes for the month.

[21:58] <grondilu> FROGGS: that's kind of racist

[21:59] <FROGGS> racist/humor, something like that ;o)

[22:00] <FROGGS> I've seen black construction workers in a lego duplo box today, that is some sort of racism

[22:00] <FROGGS> the other ppl (bus driver, police men) are white

[22:02] * colomon finally got the taxes paid on the third try

[22:03] <FROGGS> colomon: online payment?

[22:04] <colomon> ETFS phone payment.

[22:04] <colomon> I've been using it for better than a decade, yet managed to completely screw it up twice this time around.

[22:04] <colomon> using it every month...

[22:04] <grondilu> .oO(yet I had laughed a lot when watching "the I.T crowd")

[22:05] *** fgomez joined
[22:06] *** pmurias joined
[22:07] <FROGGS> it crowd is cool, ya

[22:10] <sorear> colomon: what kind of taxes do you have to pay monthly?

[22:10] *** cognominal left
[22:11] * grondilu is a bit curious about that as well

[22:12] *** fgomez left
[22:13] *** denisboyun_ joined
[22:14] <colomon> sorear: state and federal withholding, social security, and medicare.

[22:15] *** labster joined
[22:20] *** cognominal joined
[22:24] *** denisboyun_ left
[22:26] <labster> How would I go about getting the inode of a path?

[22:28] <arnsholt> The stat sytem call, I'd imagine

[22:30] <arnsholt> If it's not exposed via the .IO stuff somehow, you'll probably have to FFI stat(2) with NativeCall

[22:30] *** denisboyun_ joined
[22:30] <labster> stat and lstat are in the synopsis as methods for IO, but they're not exposed yet.

[22:31] <arnsholt> Ah, right. Have you seen if they're implemented?

[22:31] <labster> I assume they're being called somewhere, because :d and :f work

[22:31] <arnsholt> It might not be too hard to fix up and a good Rakudo hacking first experience if it's reasonably simple

[22:32] <arnsholt> Unfortunately, I'm not terribly well acquainted with the IO stuff

[22:32] *** thou joined
[22:33] <arnsholt> If you're not afraid of an adventure, try finding out how :d and :f and friends are implemented

[22:33] <arnsholt> That should show how to implement it

[22:33] <labster> Eh, I'm not either, but I'll take a look into it.  I just made a port File::Find::Duplicates, but it's more of a port of fdupes than the p5 FFD, which is pretty low in features.

[22:36] <dalek> perl6-bench: 1e9fcfa | (Geoffrey Broadwell)++ | bench:

[22:36] <dalek> perl6-bench: Get rid of a reliable segfault/glibc dump by adding 'eager do ' to a few for loops.  This ... bites.

[22:36] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/1e9fcfad7b

[22:38] <arnsholt> labster: If you check in a bit earlier tomorrow for example, there're probably more people around who do know the answers

[22:38] <arnsholt> A lot of the core devs are Europe-based, so it's getting a bit late

[22:41] *** PacoAir left
[22:41] <labster> yeah, I noticed... I've been lurking on the IRC logs for a while, before finally deciding to contribute.  California here, so it's more "check late at night".

[22:41] <Timbus> nqp::stat(nqp::unbox_s($.path), pir::const::STAT_EXISTS)

[22:41] <Timbus> src/core/IO.pm line 38

[22:41] <doy> what do people use to run test suites?

[22:43] <japhb> I think the above perl6-bench commit has convinced me I don't want for loops to be lazy unless I ask for it.  Sure, Rakudo/Parrot's failure mode for late evaluation (crashing) was bad, and that needs to be fixed.  But it took me a really long time to nail down the problem, because my mental model of 'for' is strongly oriented towards default-eager instead of default-lazy.

[22:44] <japhb> .oO( We just need to get jnthn++ to move to California, and we'll have the timezone problem solved.  :-)

[22:46] <japhb> doy, perl5's prove, usually.  I thought I saw something about someone adding a native prove function to panda, but I dunno what happened with that.

[22:46] <doy> how do you get perl5's prove to work with perl6?

[22:47] <japhb> prove -e 'perl6', as I recall

[22:47] <skids> japhb: Well, except that the whole idea of for loops returning a list is new in Perl6 in the first place.

[22:48] <pmurias> perl5's prove works great

[22:48] <doy> prove -e '../src/rakudo/install/bin/perl6 -I lib' t

[22:48] <doy> the '-I lib' needs to be inside the -e option, but yeah

[22:48] <japhb> skids, I like that it returns a list.  I like the general mappish behavior.  I don't like that it is as lazy as map, by default.

[22:49] <japhb> I want for to be a default-eager map

[22:51] *** fgomez joined
[23:03] *** denisboyun_ left
[23:04] *** MayDaniel left
[23:05] *** denisboyun_ joined
[23:07] *** cognominal left
[23:10] *** fgomez left
[23:10] *** stopbit left
[23:12] *** fgomez joined
[23:20] <doy> hmmm

[23:21] <doy> r: my $foo = "foo"; say $foo ~~ s/a//; say $foo; say $foo ~~ s/f//; say $foo

[23:21] <p6eval> rakudo c8de2e: OUTPUT«True␤foo␤True␤oo␤»

[23:21] <doy> why do both of those return True

[23:22] <doy> how do you tell if a substitution successfully matched?

[23:25] *** fgomez left
[23:31] <dalek> perl6-bench: 64ba332 | (Geoffrey Broadwell)++ | bench:

[23:31] <dalek> perl6-bench: Sigh, another 'eager do for' required to get sane semantics

[23:31] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/64ba3325c1

[23:31] *** whiteknight joined
[23:32] *** thou left
[23:38] <dalek> perl6-bench: a5ad579 | (Geoffrey Broadwell)++ | README:

[23:38] <dalek> perl6-bench: Add a note in the prereqs section of the README about required Perl 6 modules

[23:38] <dalek> perl6-bench: review: https://github.com/japhb/perl6-bench/commit/a5ad579e52

[23:44] *** alec joined
[23:45] <alec> is there a way i can open a flat text file and then automagically turn it into a hash from the perl6 prompt?

[23:45] <alec> the flat text file in question is formatted like:

[23:45] <alec> A 58583.989

[23:45] <alec> B 494858.494

[23:45] <alec> C 443839.393

[23:45] <alec> and so on

[23:46] <alec> of course, editing it into a perl6 script i can use %name= < (flat text) >; but the point is that i want to be able to read in data from the prompt

[23:47] * alec sees, on an unrelated note, two nicks in this channel from unix.stackexchange.com, geekosaur and xenoterracide... hi guys!

[23:47] <pmurias> jnthn: fix the problem by passing :target('pir')

[23:48] *** Kharec left
[23:48] *** Kharec joined
[23:49] <Ayiko> alec: my %h = (slurp 'filename').split(/\s+/);

[23:49] <japhb> alec, perhaps "%name = slurp($filename).comb(/\S+/)" ?

[23:49] <Ayiko> lol

[23:49] <japhb> heh

[23:49] <alec> ok

[23:49] <flussence> %( open('input').lines.map(*.split(/\s+/, 2)) )

[23:49] <japhb> "Great minds think in complementary operations"?

[23:49] <alec> lol

[23:49] <alec> thanks guys, i'm sure one of those will fit the bill

[23:50] * alec has to admit, perl6 is probably the first programming language he's ever actually fallen in LOVE with

[23:51] <Ayiko> doy: I hoped $/ would help for making the difference, but unsuccessful match doesn't seem to reset $/

[23:51] <alec> is there any syntactic reason to use % over $ when defining a hash, or is it just more readable that way?

[23:52] <japhb> r: say "I \x[2665] Perl 6"

[23:52] <p6eval> rakudo c8de2e: OUTPUT«I ♥ Perl 6␤»

[23:53] <japhb> alec: % improves readability, but also constrains the variable to an Associative container

[23:54] <alec> ok

[23:54] <japhb> And also implies list assignment

[23:54] <alec> ok

[23:54] <alec> i'm also just blown away by how, from the raukdo interpreter, i can start typing a filename, and get tab completion

[23:54] <alec> that's just too good to be true

[23:55] <alec> programming languages aren't supposed to be that cool

[23:58] <geekosaur> but I'm not very active there of late... life still to ****ed up atm :/

[23:58] <flussence> actually that's just because nobody bothered to change the default libreadline behaviour in the repl

