[00:05] *** drschumtzenberg joined
[00:15] *** Entonian joined
[00:16] *** xinming_ joined
[00:16] *** crab2313 left
[00:17] *** wolfman2000 joined
[00:19] *** xinming left
[00:20] *** Entonian left
[00:22] *** lestrrat left
[00:23] *** lestrrat joined
[00:24] *** crab2313 joined
[00:25] *** thelazydeveloper left
[00:34] *** cogno left
[00:45] *** cogno joined
[00:47] *** zhutingting joined
[00:59] *** cogno left
[01:06] *** smf left
[01:21] *** crab2313 left
[01:32] *** PacoAir left
[01:39] *** thou left
[01:43] *** thou joined
[01:45] *** isBEKaml left
[01:59] *** zhutingting left
[02:01] *** zhutingting joined
[02:02] *** zhutingting left
[02:05] *** zhutingting joined
[02:07] *** dbr left
[02:11] *** zhutingting_ joined
[02:12] *** zhutingting left
[02:12] *** zhutingting_ is now known as zhutingting

[02:13] *** zhutingting left
[02:26] *** Guest17862 left
[02:33] *** orafu left
[02:37] *** orafu joined
[02:39] *** cognominal left
[02:39] *** Chillance left
[02:46] *** alim left
[02:48] *** adu joined
[02:53] *** colomon joined
[02:57] <diakopter> nqp: my $a; ~$a // 0

[02:57] <p6eval> nqp: OUTPUT«Null PMC access in set_string_native()␤current instr.: '_block1000' pc 51 ((file unknown):48) (/tmp/bAKPeVH6FZ:1)␤»

[03:01] *** sudokode left
[03:01] <adu> hi diakopter 

[03:01] <diakopter> o/

[03:02] <adu> so I'm starting to think that maybe I should have started learning with perl5 instead of pearl6

[03:03] <adu> it just seems like perl5 is a swiss army knife language, and perl6 is the entire swiss army

[03:03] <diakopter> ha

[03:03] <diakopter> it can feel that way if you read the Synopses

[03:04] <adu> the Synopses are very detailed

[03:06] *** sudokode joined
[03:08] *** DrEeevil is now known as bonsaikitten

[03:09] <diakopter> unfortunately the Synopses are now misnamed, as they don't summarize anything anymore, and they need summaries themselves

[03:13] <sorear> the exegeses were supposed to be that.

[03:14] <PerlJam> no, the exegeses were to explain the synopses.  :)

[03:14] <diakopter> the exegeses were supposed to explain the apocalypses, I thought.

[03:14] <PerlJam> oh, yes.  that's it.

[03:15] <diakopter> and the synopses were supposed to summarize both...

[03:15] <diakopter> but the synopses turned into the spec

[03:16] <PerlJam> Perl 6 is *big*  I think the Synopses are still the "least words" explanation

[03:17] <diakopter> really? I thought S02 now dwarfed all other documents combined

[03:17] <diakopter> well, maybe S02+S05

[03:20] <sorear> S03 is bigger than S02, but not by much

[03:20] <adu> heh I just happened to be reading S02

[03:20] <adu> maybe that's why I thought perl6 was the swiss army

[03:20] <sorear> S06, S12, and S26 also exceed 2000 libnes

[03:21] <PerlJam> https://gist.github.com/2674590

[03:21] <sorear> adu: note that nobody has ever bothered to write out Perl 5's behavior in full

[03:21] <sorear> adu: it would be at least comparable to Perl 5 if so, I think

[03:22] <adu> how many implementations of Perl are there?

[03:22] <adu> s/Perl/Perl5/

[03:22] <sorear> One.

[03:22] <adu> that's why

[03:22] <sorear> No

[03:22] <sorear> Having few implementations is not evidence for a language being simple

[03:22] <adu> no

[03:22] <sorear> It is the exact opposite

[03:22] <sorear> if Perl 5 was as simple as Perl 6, it would have dozens of implementations

[03:23] <adu> I mean I suspect people never reimplemented because there was no specification

[03:23] <diakopter> it is rumored that Microsoft made a Perl 5 on the CLR as a proof of concept before releasing the CLR

[03:23] <diakopter> I don't remember where I read that; sorry

[03:23] <adu> IronPerl?

[03:24] <diakopter> no; long before the Iron*

[03:24] <adu> so Niecza is IronPerl6 so to speak

[03:25] <diakopter> well, the Iron* languages use the 'dynamic' feature of CLR.. niecza doesn't, afaik

[03:26] <sorear> adu: In any case, I strongly dispute your assertion that Perl 6 is more complicated than Perl 5

[03:27] <adu> once I figure stuff out, I should write a ___'s poignant guide to Perl6 

[03:27] <PerlJam> adu: that would be neat.

[03:27] <adu> with cartoons

[03:27] <diakopter> I'd read that for a dollar

[03:28] <adu> diakopter: in which direction?

[03:28] <diakopter> heh

[03:28] <diakopter> either

[03:28] <adu> I mean would you pay me, or the other way around?

[03:28] <diakopter> right, either

[03:28] * adu is confused

[03:29] <diakopter> I mean, if I'd pay $1 to read it, then I'd certainly read it for free

[03:29] <PerlJam> adu:  excellent!

[03:29] <diakopter> and if I'd read it for free, I'd certainly appreciate getting a dollar for reading it

[03:29] <adu> PerlJam: but I have to figure stuff out first

[03:29] <adu> diakopter: lol

[03:30] <diakopter> adu: with which language(s) are you already familiar? 

[03:32] <adu> diakopter: Python, C, C++, Haskell, ML, Forth, Maple, Mathematica, Prolog, Oz, R, Go, Groovy, Scheme

[03:32] <diakopter> ha

[03:32] <diakopter> (impressive)

[03:32] <diakopter> oh yeah, you were talking about Go the other day

[03:32] <PerlJam> What's Oz?

[03:32] <adu> Oz is a multiparadigm language

[03:32] <diakopter> Oz/Mozart?

[03:32] <adu> yes

[03:32] <adu> Mozart is the compiler

[03:32] <adu> Oz is the language

[03:33] * PerlJam takes that as a hint to google it.

[03:33] <adu> I wrote a puzzle solver in it

[03:34] <adu> and I had some trouble constraining the search space, so I rewrote it in prolog

[03:35] <adu> I tried really hard to learn Ruby, but I never got it

[03:35] <sorear> adu: with a background like that, I'm suprised you're having issues.  How can I help?

[03:35] <adu> sorear: I don't understand the PAST API

[03:36] * sorear does NOT know Maple, Mathematica, Oz, R, or Groovy

[03:36] <sorear> adu: PAST != Perl6

[03:36] <adu> and whenever I talk about PAST here, they refer me to #parrot, whenever I mention it in #parrot, they refer me to #perl6

[03:36] <PerlJam> heh

[03:37] <adu> it's very frustrating

[03:37] <sorear> adu: The only person who understands PAST is pmichaud

[03:37] <adu> I'm thinking of scrapping the parrot way, and just writing my scheme in pure perl6

[03:37] <PerlJam> sorear: you really think that's true?

[03:38] *** JimmyZ joined
[03:38] <PerlJam> I mean jnthn has to understand enough of PAST to make QAST.

[03:38] <sorear> PerlJam: That statement is too vague to be true or false in a strict sense.

[03:39] <sorear> jnthn certainly knows more than nothing about PAST

[03:39] <adu> but there are so many things that are in the "learn-by-example" in the PAST documentation, like $<X> that I don't understand, which seems to be perl6, not parrot

[03:39] <sorear> PAST is a data structure library

[03:39] *** tyatpi joined
[03:39] <PerlJam> sorear: well, *I* konw more than nothing about PAST too  :)

[03:39] <sorear> '$<X>' is not part of the PAST concept, at all

[03:41] <PerlJam> adu: It seems like most of your difficulty is separating things into the appropriate conceptual bins.

[03:41] <JimmyZ> $<X> just means $/<X>, where $/ is a hash var?

[03:41] <sorear> PAST is just a library, it has no syntax at all

[03:41] <sorear> $<X> is Perl 6/NQP syntax

[03:42] <sorear> nothing whatsoever to do with PAST

[03:42] <diakopter> PerlJam: there are many bins

[03:42] <adu> so $<X> = $/.X

[03:42] <sorear> if you asked that question to #parrot, they were right to send you here

[03:42] <adu> or whatever

[03:42] <JimmyZ> $<X> = $/{'X'}

[03:42] <sorear> adu: Making up syntax will get you nowhere.

[03:43] <adu> $/{'X'}]

[03:43] *** tokuhirom joined
[03:43] <adu> ack

[03:43] <adu> maybe I should come back after more research

[03:43] <sorear> Here is the place for research.  Do research here.

[03:44] <adu> ok

[03:44] <JimmyZ> adu: see http://perlcabal.org/syn/S05.html#When_%24%2F_is_valid

[03:44] <adu> I'd like to know general things that I haven't found in the synoppses yet

[03:44] <sorear> adu: Am I being rude?

[03:44] <adu> like can grammars be composed?

[03:44] <adu> sorear: nope

[03:45] <sorear> If by 'composed' you mean general compositionality, then yes

[03:45] <adu> like if you have grammar A {…} and grammar B {…} can you do something like grammar C { rule TOP { <A> | <B> }}?

[03:46] <sorear> yes, you can use <A::TOP> or [ :lang(A) <TOP> ]

[03:46] <adu> ah A::TOP

[03:46] <adu> ok

[03:46] <sorear> niecza only supports the latter form; I don't know if Rakudo does either

[03:47] <sorear> n: grammar G { rule TOP { :lang(Niecza::NumSyntax) <integer> } }; say G.parse('0x1F,pie')

[03:47] <p6eval> niecza v17-4-ge5b869e: OUTPUT«G()␤»

[03:47] <sorear> n: grammar G { rule TOP { :lang(Niecza::NumSyntax) <integer> } }; say G.parse('0x1F')

[03:47] <p6eval> niecza v17-4-ge5b869e: OUTPUT«#<match from(0) to(4) text(0x1F) pos([].list) named({"integer" => #<match from(0) to(4) text(0x1F) pos([].list) named({"hexint" => #<match from(2) to(4) text(1F) pos([#<match from(2) to(4) text(1F) pos([].list) named({}.hash)>].list) named({}.hash)>}.hash)>…

[03:47] <adu> so

[03:47] <JimmyZ> you may wants grammar C is A { ... } or something?

[03:47] <adu> the :lang(A), does that add a pair to <integer> or <TOP>?

[03:48] <sorear> It looks like a pair but it isn't one

[03:48] <adu> what?

[03:48] <sorear> It's a pragma

[03:48] <adu> what?

[03:49] <sorear> Remember that inside regexes the language is completely different

[03:49] <sorear> 1*3 is a multiplication in the main language, but {3,13,113,1113,...} in a regex

[03:49] *** sisar joined
[03:50] <adu> I thought everything was quoted

[03:50] <TimToady> regexes are not strings in Perl 6

[03:50] <sorear> Likewise, :lang(A) in a regex has almost nothing to do with :lang(A) in the main language

[03:50] <TimToady> it's just a different language

[03:51] <TimToady> likewise the inside of a quoted string is a different language

[03:51] <adu> ok

[03:51] <adu> I see the pragma section in S05, but it doesn't mention :lang

[03:52] <adu> oh right you said that was impl-specific

[03:53] <sorear> S05 should mention :ignorecase

[03:53] <sorear> pragmas inside regexes begin with colons

[03:53] <sorear> :lang functions in a similar way to :ignorecase

[03:53] <adu> that's outside of the quotation

[03:53] <sorear> There is no quotation

[03:53] <adu> it looks like pragmas are inside the quotation

[03:54] <sorear> Where do you see a quotation?

[03:54] <adu> what are {} or // called?

[03:54] <TimToady> basically those are lexical scope delimiters

[03:55] <diakopter> adu: outside the regex they are modifiers

[03:55] <sorear> TimToady: do we have a better name for them than 'nibblers'?

[03:55] <adu> diakopter: and modifiers are not pairs?

[03:55] <diakopter> no

[03:55] <diakopter> I mean, correct

[03:56] <sorear> adu: see S05:594

[03:56] <sorear> 'can be placed inside the regex'

[03:57] <TimToady> we reuse the pair syntax for many things that are not pairs

[03:57] <TimToady> r: say :16<deadface>

[03:57] <p6eval> rakudo f685cb: OUTPUT«3735943886␤»

[03:59] <adu> lexically scoped delimiters

[03:59] <adu> ok

[03:59] <adu> so a colon inside delimiters might be a modifier or a pragma

[04:00] <TimToady> depends on the language at that spot

[04:00] <sorear> No, it's always both

[04:00] <adu> so pragmas are modifiers?

[04:00] <sorear> Modifiers are a kind of pragma

[04:00] <adu> heh

[04:01] <TimToady> almost any kind of declaration tweaks the current language into a different language

[04:01] <sorear> A pragma is anything that tweaks the local interpretation of the language

[04:01] <sorear> 'use strict' is a pragma.  So is :ignorecase inside Prl 6 regexes

[04:01] <TimToady> an operator declaration is merely a dramatic version of that

[04:01] <adu> TimToady: sounds very Huffman

[04:02] <sorear> Huffman has been a concious influence on us all

[04:02] <TimToady> well, it's more like defining all languages in terms of a universal root, much like URLs

[04:02] <sorear> Perl 6 tries to make the common things short and irregular while uncommon things are long and regular

[04:03] <adu> :)

[04:03] <sorear> IMO one of the things that sets Perl 6 apart is how much we steal from bona fide linguistics

[04:03] *** ranguard left
[04:04] <adu> bona fide?

[04:04] <sorear> possibly a bad choice

[04:04] <adu> proper linguistics?

[04:05] <adu> natural linguistics?

[04:05] <sorear> natural stuff, yes

[04:05] <PerlJam> What would you expect from a programming language designed by a linguist?

[04:05] <geekosaur> ^^ that

[04:05] <adu> so I shouldn't assume every colon is a pair

[04:06] <adu> can I assume that every :: is a module/package/namespace?

[04:06] <TimToady> depends on the language

[04:06] <PerlJam> no

[04:06] <TimToady> :: means something else in regex language

[04:06] <sorear> Larry's Law of Language Design: Everybody wants the colon.

[04:06] <PerlJam> adu: sometimes :: is a cut operator :)

[04:06] <adu> o right the backtracking

[04:06] *** sudokode left
[04:06] <adu> but that uses different whitespace conventions, I don't think I was confused the first time I saw that

[04:07] <adu> I think I thought "WTF", I'm pretty sure I didn't think "that's a funny namespace"

[04:07] <TimToady> we try to make different things look different, except when we don't

[04:07] <sorear> I think that, in the languages that Perl 6 enables by default, :: is always either namespacey or a cut operator

[04:08] <sorear> I'm not entirely certain though

[04:08] <PerlJam> I don't usually think of prefix :: as namespacey

[04:08] <TimToady> we changed ??:: to ??!! to avoid overloading :: another way

[04:08] <diakopter> std: use Test:: ::;

[04:08] <p6eval> std 8632387: OUTPUT«ok 00:00 41m␤»

[04:08] <adu> also, the MAIN thing confused me

[04:08] *** sudokode joined
[04:09] <adu> but the example has 4 parameters, and rakudo didn't act like the synapses

[04:09] <diakopter> TimToady what does that mean ^^

[04:10] <adu> TimToady: that would make a nice ternary op

[04:10] <TimToady> n: say 42 ?? "yes" :: "no"

[04:10] <p6eval> niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤Please use !! rather than :: at /tmp/VjEIclV8Ez line 1:␤------> say 42 ?? "yes" ⏏:: "no"␤␤Parse failed␤␤»

[04:10] <sorear> diakopter: in niecza, :: returns the root of the virtual package tree

[04:11] <sorear> n: say (::).<CORE>.WHO.<pi>

[04:11] <p6eval> niecza v17-4-ge5b869e: OUTPUT«3.1415926535897931␤»

[04:11] <diakopter> niecza: use Test:: ::;

[04:11] <p6eval> niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤'use' with arguments NYI at /tmp/M4V0bV0a3V line 1:␤------> use Test:: ::⏏;␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1364 (die @ 3) ␤  at /home/p6eval/niecza/s…

[04:12] <adu> in S06, it gives sub MAIN ($directory, :$verbose, *%other, *@filenames) as an example, but the other hash never seemed to capture anything

[04:12] <adu> and I don't understand how :$verbose works

[04:12] <sorear> --verbose

[04:12] <sorear> --other

[04:12] <adu> oh

[04:12] <adu> that's why

[04:13] <TimToady> :$verbose is short for :verbose($verbose)

[04:13] <sorear> which is how subs take named arguments in Perl 6

[04:13] <adu> which is short for verbose => $verbose?

[04:14] <sorear> in an expression, yes

[04:14] <TimToady> well, not in that context

[04:14] <sorear> in a parameter list, no

[04:14] <adu> so named arguments aren't pairs

[04:14] <sorear> correct

[04:14] <TimToady> right, just borrowed the syntax

[04:14] <adu> is there anything else that aren't pairs?

[04:14] <PerlJam> heh

[04:14] <adu> I mean that start with colon

[04:15] <TimToady> I mentioned :16<abcd>

[04:15] <adu> ah

[04:15] <sorear> :foo is a pair if and only if it is in expression context

[04:15] <adu> radix syntax

[04:15] <adu> I remember that briefly

[04:16] <TimToady> we also use colon syntax to extend identifiers with bits that aren't identifiery

[04:16] <TimToady> postfix:<!> for instance

[04:16] <adu> and :sym<foo>?

[04:16] <TimToady> well, not without a category on the front

[04:17] <PerlJam> We still have :{...} don't we?

[04:17] <adu> another thing, is do I have to use :sym? or can I use :stuff<foo>?

[04:17] <PerlJam> adu: or were you only limiting to things that match :\w+ ?

[04:17] <TimToady> well, sym does more magic

[04:18] <TimToady> but where we don't care to define <sym>, you can put anything there

[04:18] <TimToady> you'll see entries like term:ident

[04:18] <TimToady> that just describe what's being matched

[04:18] <adu> PerlJam: I realize that :\W is a very large space, so I guess I did mean :\w

[04:19] <adu> I definitely didn't mean the sigils and twigils

[04:19] <TimToady> r: say :{ 42 }.perl

[04:19] <p6eval> rakudo f685cb: OUTPUT«Block.new()␤»

[04:19] <TimToady> r: say :foo{ 42 }.perl

[04:19] <p6eval> rakudo f685cb: OUTPUT«"foo" => Block.new()␤»

[04:20] <TimToady> arguable the first should be '' => Block.new()

[04:20] <TimToady> *bly

[04:21] <adu> TimToady: ok

[04:21] <TimToady> certain colonpair syntaxes are restricted in certain spots

[04:22] <TimToady> for instance, colonpairs as match modifers may only use the paren form

[04:22] <TimToady> since we want to reserve the rest of the brackets to delimit the pattern

[04:23] <TimToady> and certain forms that require literals can't depend on running code, so the {} forms are not allowe there

[04:23] <TimToady> but generally you don't notice this details

[04:23] <TimToady> unless of course you have a mind like diakopter, who writes weird code

[04:24] <TimToady> every project needs one of those...

[04:24] <adu> where can I find docs on ~~?

[04:24] <PerlJam> adu: As TimToady says, there's a method to the madness.  And once you "get it", you'll notice the principle of least surprise everywhere.

[04:25] <PerlJam> (well, you *won't* notice it  ;)

[04:25] <adu> @*ARGS ~~ /<MyGrammar::top>/;

[04:25] <adu> $obj ~~ :!defined

[04:25] <adu> how can those ^ be the same operator?

[04:26] <TimToady> for ~~ see 'Smart matching' in S03

[04:26] <adu> TimToady: thanks

[04:26] <TimToady> those are the same because they are really sugar for RHS.ACCEPTS(LHS)

[04:27] <TimToady> so they dispatch on the righthand type

[04:27] <TimToady> and Pair.ACCEPTS does something different from Regex.ACCEPTS

[04:27] <adu> ok

[04:29] <adu> "<TimToady> every project needs one of those…" lol

[04:30] <TimToady> diakopter++ is our best "fuzzer"

[04:30] * diakopter just notice

[04:30] <diakopter> I fuzzed a Microsoft language out of existence, or at least I like to think so.

[04:31] <sisar> example of diakopter's "weird" code ?

[04:31] <diakopter> just line noise

[04:31] <TimToady> cleverly crafted line noise though

[04:35] *** ranguard joined
[04:36] <adu> couldn't you uncleverly generate it until a parser for it didn't fail?

[04:37] <diakopter> that requires lots of cleverness to make it not take forever

[04:37] <adu> POLSE

[04:38] <diakopter> POLSE?

[04:38] <adu> I remember reading somewhere that PEG were good at text => grammar, and CFG's were good at grammar => text

[04:38] <adu> diakopter: Principle of Least Surprise Everywhere

[04:39] <adu> possibly because PEG's are not invertible

[04:45] *** zhutingting joined
[04:52] <diakopter> std: /\/\/////\/\/////\/\/\/\/////\/\/\/\/////\/\/\/\/\//

[04:52] <p6eval> std 8632387: OUTPUT«ok 00:00 42m␤»

[04:53] <geekosaur> 52 pick-up

[04:53] <adu> diakopter++

[04:55] <diakopter> niecza: say '//'~~/\/\/////\/\/////\/\/\/\/////\/\/\/\/////\/\/\/\/\//

[04:55] <p6eval> niecza v17-4-ge5b869e: OUTPUT«#<match from(0) to(2) text(//) pos([].list) named({}.hash)>␤»

[05:02] *** kaare_ joined
[05:07] *** araujo left
[05:09] *** JimmyZ left
[05:12] *** ranguard left
[05:26] <sorear> I can't parse that, and I'm not sure I want to.

[05:26] * TimToady is not sure of the significance of 2 2 4 4 5

[05:28] <diakopter> tee hee

[05:28] <moritz> \o

[05:29] <TimToady> yo daddy!

[05:30] <TimToady> p6: (:36<abigradixendswithz>/:36<10000000>).base(36)

[05:30] <p6eval> niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Unable to resolve method base in class Rat␤  at /tmp/8gUj_GhQ4C line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65) ␤  at /home/p6…

[05:30] <p6eval> ..rakudo f685cb:  ( no output )

[05:30] <p6eval> ..pugs: OUTPUT«*** No such method in class Rat: "&base"␤    at /tmp/L2Ze9Fh0Wj line 1, column 1 - line 2, column 1␤»

[05:31] <TimToady> r: say (:36<abigradixendswithz>/:36<10000000>).base(36)

[05:31] <p6eval> rakudo f685cb: OUTPUT«ABIGRADIXEN.DSWITHZ␤»

[05:31] <TimToady> \o/

[05:31] *** ranguard joined
[05:40] <TimToady> r: say (:36<abigradixendswithz>/:36<1000000000>).base(36)

[05:40] <p6eval> rakudo f685cb: OUTPUT«ABIGRADIX.ENDSWITHZ␤»

[05:45] *** ranguard left
[05:46] <sorear> r: say log(36**9, 2)

[05:46] <p6eval> rakudo f685cb: OUTPUT«46.5293250129808␤»

[05:51] *** isBEKaml joined
[05:55] <dalek> rakudo/nom: f5288fc | moritz++ | src/core/Version.pm:

[05:55] <dalek> rakudo/nom: flesh out Version a bit

[05:55] <dalek> rakudo/nom: 

[05:55] <dalek> rakudo/nom: * fixed constructor to properly handle :plus

[05:55] <dalek> rakudo/nom: * .Str now properly handles * wildcards and trailing +

[05:55] <dalek> rakudo/nom: * first shot at ACCEPTS

[05:55] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f5288fc65f

[05:56] *** ranguard joined
[05:57] *** adu left
[05:58] *** NamelessTee joined
[06:05] *** isBEKaml left
[06:06] *** isBEKaml joined
[06:07] <moritz> adu++ # "it just seems like perl5 is a swiss army knife language, and perl6 is the entire swiss army"

[06:10] <diakopter> keep reading :)

[06:12] <moritz> sorear++ # "Perl 6 tries to make the common things short and irregular while uncommon things are long and regular"

[06:14] <dalek> rakudo/nom: 2ac5691 | moritz++ | / (2 files):

[06:14] <dalek> rakudo/nom: eqv and === for Version. Run test file

[06:14] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/2ac569182d

[06:14] <dalek> roast: a4ec6e3 | moritz++ | S02-literals/version.t:

[06:14] <dalek> roast: [version.t] fix one test, fudge a second one for rakudo

[06:14] <dalek> roast: review: https://github.com/perl6/roast/commit/a4ec6e3373

[06:14] <dalek> roast: 52a96fb | moritz++ | S02-literals/version.t:

[06:14] <dalek> roast: unfudge a version.t test

[06:14] <dalek> roast: review: https://github.com/perl6/roast/commit/52a96fb4dd

[06:15] <moritz> ok, I now have Version implemented, except the scary parts

[06:15] <moritz> (ie no support for alphanumeric stuff)

[06:16] <moritz> diakopter++ # say '//'~~/\/\/////\/\/////\/\/\/​\/////\/\/\/\/////\/\/\/\/\//

[06:18] *** ranguard left
[06:22] <sorear> moritz++ # I look forward to stealing Version after $finals

[06:23] *** isBEKaml left
[06:27] *** ranguard joined
[06:29] <TimToady> sorear: we appreciate that you're prioritizing school

[06:32] *** cognominal joined
[06:33] <moritz> we've had our fair share of hackers burning out while prioritizing p6 hacking. We don't want that to repeat

[06:33] *** spaceships left
[06:41] *** tokuhirom left
[06:41] *** mikec_ left
[06:41] *** sftp left
[06:41] *** baest left
[06:41] *** pomysl_ left
[06:41] *** ivan`` left
[06:41] *** jnthn left
[06:41] *** odoacre left
[06:41] *** estrai left
[06:41] *** ivan`` joined
[06:41] *** sftp joined
[06:41] *** odoacre joined
[06:44] *** isBEKaml joined
[06:56] * TimToady prioritizes bed &

[06:56] <moritz> have the appropriate amount of sleep :-)

[07:09] *** tyatpi left
[07:19] <isBEKaml> moritz: you're still up? :|

[07:20] *** mdupont left
[07:26] <isBEKaml> moritz: nvm, I see it's something of early morning where you are. :-) 

[07:34] *** araujo joined
[07:34] *** araujo left
[07:34] *** araujo joined
[07:55] *** zhutingting left
[08:04] *** cognominal_ joined
[08:06] *** raiph joined
[08:07] *** cognominal left
[08:11] *** tokuhirom joined
[08:11] *** mikec_ joined
[08:11] *** baest joined
[08:11] *** pomysl_ joined
[08:11] *** jnthn joined
[08:11] *** estrai joined
[08:11] <moritz> isBEKaml: yes, I'm still up :-)

[08:11] *** raiph left
[08:11] *** raiph joined
[08:13] <moritz> though on and off, being distracted by $family and Mother's Day

[08:15] <isBEKaml> moritz: /family/ problems. :P  

[08:16] * isBEKaml ducks before anyone's out to get him

[08:20] <StuntmanMike> aaah, Mother's Day!

[08:30] <moritz> isBEKaml: today just $family, not $family.problems

[08:31] <moritz> at least so far :-)

[08:35] <dalek> roast: ea734f1 | moritz++ | S12-enums/pseudo-functional.t:

[08:35] <dalek> roast: simplify an enum test a bit

[08:35] <dalek> roast: review: https://github.com/perl6/roast/commit/ea734f1539

[08:36] *** raiph left
[08:36] <moritz> r: enum day (:Sun(1), 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'); say day(Tue).Str

[08:36] <p6eval> rakudo 2ac569: OUTPUT«Method 'Str' not found for invocant of class 'Undef'␤  in block <anon> at /tmp/dR0d80NyvO:1␤␤»

[08:36] <moritz> r: enum day (:Sun(1), 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'); say day(Tue) eq day(3)

[08:36] <p6eval> rakudo 2ac569: OUTPUT«(signal SEGV)»

[08:36] * moritz submits rakudobug

[08:37] <isBEKaml> SEGV, really? :(

[08:38] <diakopter> r: enum day (); ~day()

[08:38] <p6eval> rakudo 2ac569: OUTPUT«(signal SEGV)»

[08:39] <moritz> diakopter++

[08:40] <moritz> r: enum day <a b>; say ~day(1)

[08:40] <p6eval> rakudo 2ac569: OUTPUT«b␤»

[08:40] *** mdupont joined
[08:40] <isBEKaml> r: enum day <x y x xx>; say ~day(2)

[08:40] <p6eval> rakudo 2ac569: OUTPUT«x␤»

[08:41] <isBEKaml> I thought enums rejected duplicate entries? Not an error scenario?

[08:41] <isBEKaml> r: enum foo();

[08:41] <p6eval> rakudo 2ac569:  ( no output )

[08:41] <isBEKaml> r: enum foo(); ~foo;

[08:41] <p6eval> rakudo 2ac569: OUTPUT«use of uninitialized value of type foo in string context  in block <anon> at /tmp/ZjvSBtYwkC:1␤␤»

[08:41] <moritz> n: enum day <a b a>;

[08:41] <p6eval> niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤Illegal redeclaration of symbol 'a' (see line 1) at /tmp/E8W7vaE4tl line 1:␤------> enum day <a b a>⏏;␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1364 (die @ 3) …

[08:42] <isBEKaml> p: enum foo<x y x xx>; ~foo(2);

[08:42] <p6eval> pugs: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/_DpMXzAohu line 1, column 1-19␤»

[08:42] <isBEKaml> perl6: enum foo<x y x xx>; ~foo(2);

[08:42] <p6eval> niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤Illegal redeclaration of symbol 'x' (see line 1) at /tmp/7kB9uNqC_u line 1:␤------> enum foo<x y x xx>⏏; ~foo(2);␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1364…

[08:42] <p6eval> ..rakudo 2ac569:  ( no output )

[08:42] <p6eval> ..pugs: OUTPUT«*** No such subroutine: "&enum"␤    at /tmp/Adqvbg4njr line 1, column 1-19␤»

[08:42] <isBEKaml> moritz: yes, rakudobug?

[08:43] <moritz> isBEKaml: yes

[08:43] <diakopter> where are rakudobugs tracked these days

[08:43] <moritz> thttp://rt.perl.org/rt3/

[08:43] <moritz> rm

[08:44] <moritz> http://rt.perl.org/rt3/

[08:44] <diakopter> oh

[08:44] <moritz> noone was fond of migrating ~600 open and probably as many closed tickets

[08:45] <isBEKaml> moritz: petdance did something like that for parrot in their move to github issues. 

[08:45] <moritz> isBEKaml: I know

[08:46] <isBEKaml> moritz: IIRC, they had far more tickets than rakudo.

[08:46] <moritz> isBEKaml: but their primary motivation was a huge spam problem with their trac instance

[08:46] <moritz> a pressure which we don't have

[08:46] <isBEKaml> moritz: our motivation? RT sucks? ;)

[08:47] <moritz> well yes, it sucks, but we can work with it

[08:47] <moritz> I haven't tried any other github tracker with such a largish number of tickets

[08:48] <moritz> erm

[08:48] <moritz> any other issue tracker

[08:48] <isBEKaml> moritz: I think somebody needs to force you to be with $family today. :-)

[08:50] <moritz> I am, on and off :-)

[08:50] <isBEKaml> not unlike a flip-flop. ;)

[08:51] <moritz> that flip was a flop :-)

[08:52] * diakopter waits for jnthn to awaken

[08:53] <isBEKaml> moritz: :) While you're here, I need your help with git. 

[08:53] <StuntmanMike> r: USAGE()

[08:53] <p6eval> rakudo 2ac569: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&USAGE' called (line 1)␤»

[08:53] <StuntmanMike> that's LTA :/

[08:53] <isBEKaml> moritz: I'm doing some changes to tablets. git pull'd and immediately ran into conflicts. git stash didn't help either. What can I do here?

[08:53] *** StuntmanMike is now known as tadzik

[08:54] <isBEKaml> tadzik: \o/

[08:54] <tadzik> \o/

[08:54] <tadzik> isBEKaml!

[08:54] <isBEKaml> tadzik: now we know what you had been upto these past days!

[08:54] <tadzik> ha

[08:54] <tadzik> you know, stuff :)

[08:54] <isBEKaml> tadzik: jumping on the trampoline! :D

[08:54] <tadzik> yeah, that too :P

[08:55] <isBEKaml> tadzik: JUMP!

[08:55] <tadzik> o-<-<

[08:55] <isBEKaml> tadzik: higher!

[08:55] <tadzik> o->-|

[08:55] <tadzik> o-<-<

[08:55] <tadzik> o->-|

[08:55] <isBEKaml> :D

[08:56] *** icwiener joined
[08:58] <diakopter> omg. /me looks at the rakudo bug list

[08:59] <moritz> isBEKaml: what do you mean by "git stash didn't help"?

[09:01] <isBEKaml> moritz: I first git stash'd my changes and git pull'd. Even then, it ran into conflicts. 

[09:01] <moritz> isBEKaml: which means you had local changes/commits

[09:02] <moritz> isBEKaml: do you want to get rid of them?

[09:02] <isBEKaml> moritz: yes and they were in my own local branch. 

[09:02] <isBEKaml> moritz: No. I guess that's what git stash is for. 

[09:02] <moritz> ah

[09:02] <moritz> so do a 

[09:02] <moritz> git checkout master

[09:02] <moritz> git merge origin/master

[09:03] <moritz> if your changes are in a different local branch, that shouldn't lead to any conflicts

[09:03] <moritz> and then

[09:03] <moritz> git merge yourlocalbranch

[09:03] <moritz> and resolve any conflicts you might get

[09:04] <isBEKaml> gco master                                                                                                           

[09:04] <isBEKaml> docs/tablet-2-basic-syntax.txt: needs merge

[09:04] <isBEKaml> :(

[09:04] <isBEKaml> error: you need to resolve your current index first

[09:04] <moritz> eeks

[09:05] <isBEKaml> moritz: git status gives me a list of files that were from the pull'd logs. None modified by me.

[09:05] <isBEKaml> moritz: but the file I modified - is on the add queue. wtf?

[09:06] <moritz> isBEKaml: did you do a 'git pull' or a 'git pull --rebase'?

[09:06] <isBEKaml> moritz: git pull

[09:06] <isBEKaml> moritz: I need to rebase?

[09:06] <moritz> no

[09:06] <moritz> just asking

[09:07] <isBEKaml> moritz: I don't do rebase unless I wanted to wipe my history. 

[09:08] <isBEKaml> moritz: alright, I'm moving my file out, doing a clean checkout and writing my history. 

[09:08] <moritz> isBEKaml: when I'm in a situation like this, and I know that all my local changes have been committed or stashed, I do a   git checkout .

[09:08] <moritz> but that can lose information if not all local changes have been comitted or stashed

[09:09] <moritz> (plus and minus some git reset magic)

[09:09] <isBEKaml> moritz: yeah, I git stashed first and did a git pull. resulted in a dirty branch. :/

[09:09] <isBEKaml> moritz: now I can't even unstash or do a checkout to master. 

[09:10] <moritz> hm

[09:10] <moritz> now that we are at destructive things, does   git reset --hard HEAD  help at all?

[09:10] <isBEKaml> didn't want to try that. Now that I have moved my file, I might as well try it.

[09:11] <tadzik> backup the conflicting file, git checkout -f it?

[09:11] <isBEKaml> tadzik: that wouldn't help. dirty branch, right?

[09:11] <tadzik> hm

[09:11] <tadzik> but checkout -f the file?

[09:11] <tadzik> not the branch. Not sure

[09:12] <tadzik> doesn't git status say what comment shold you use to abort it?

[09:12] <isBEKaml> tadzik: git status gave me a list of unmerged files from my last pull. 

[09:12] <tadzik> right. So those are the one that you should do something about, right?

[09:12] <isBEKaml> tadzik: so yes, I can't do anything unless I resolve all my conflicts, can't even move out to another branch. 

[09:12] <dalek> rakudo/nom: 32b1731 | moritz++ | src/core/Enumeration.pm:

[09:12] <dalek> rakudo/nom: make invocations of enums much more robust, and a bit more magic.

[09:12] <dalek> rakudo/nom: 

[09:12] <dalek> rakudo/nom: fixes RT #112906

[09:12] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/32b1731e43

[09:13] <moritz> r: enum day <a b c d e>;say day(3) === d; "foo" but d; say "alive"; "foo" but day(3)

[09:13] <p6eval> rakudo 2ac569: OUTPUT«True␤alive␤Type check failed in assignment to '$!day'; expected 'day' but got 'Int'␤  in block <anon> at src/gen/CORE.setting:650␤  in method BUILD_LEAST_DERIVED at src/gen/CORE.setting:637␤  in sub infix:<but> at src/gen/CORE.setting:10579␤  in block <anon> at /tm…

[09:13] <isBEKaml> tadzik: but the problem is - I git stashed my files. it shouldn't give me conflicts. 

[09:13] <tadzik> maybe stash gets confused on unmerged files

[09:13] <isBEKaml> tadzik: anyway, I did a hard reset for a clean local branch. 

[09:13] <moritz> about that enum thing: WTF?

[09:14] <moritz> day(3) === d  is True, but '"foo" but d' and '"foo" but day(3)' dies?

[09:14] <isBEKaml> moritz: I did a hard reset now. I'm moving my files back in, so that helped!

[09:14] <moritz> isBEKaml: glad to hear that

[09:15] <isBEKaml> yeah, that enum thing is a whaddeyeff.. 

[09:15] <moritz> r: enum A <b c>; say nqp::iscont(b); say nqp::iscont(A(0))

[09:15] <p6eval> rakudo 2ac569: OUTPUT«Method 'gist' not found for invocant of class 'Integer'␤  in sub say at src/gen/CORE.setting:6621␤  in block <anon> at /tmp/kpp3b_i_2I:1␤␤»

[09:15] <moritz> r: enum A <b c>; nqp::say nqp::iscont(b); nqp::say nqp::iscont(A(0))

[09:15] <p6eval> rakudo 2ac569: OUTPUT«0␤0␤»

[09:16] <isBEKaml> moritz: OOC, these sort of errors used to give us NPMCA, right?

[09:16] <isBEKaml> :)

[09:16] <moritz> r: enum day <a b c d e>;say day(3) === d; "foo" but d; say "alive"; "foo" but d; # just checking that it works twice

[09:16] <p6eval> rakudo 2ac569: OUTPUT«True␤alive␤»

[09:16] <moritz> isBEKaml: yes :-)

[09:17] <isBEKaml> moritz: darkest days are over. whew! :-)

[09:17] <moritz> now we just get segfaults :-)

[09:17] <moritz> no, I fixed that one

[09:17] <isBEKaml> r: enum day <a b c a b c>; 

[09:17] <p6eval> rakudo 2ac569:  ( no output )

[09:17] <tadzik> pugs: Missing required parameters: $_ -- what does that mean?

[09:17] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "what"␤    expecting operator, ":" or ","␤    at /tmp/jI_Ycgb4Y1 line 1, column 36␤»

[09:18] <tadzik> eek, pardon

[09:18] <isBEKaml> tadzik! working with pugs!

[09:18] <tadzik> yeah :)

[09:18] <tadzik> I wanted to see if my todo runs faster than 1 second per command

[09:18] <tadzik> and all pugs says is: pugs: Missing required parameters: $_

[09:19] <tadzik> does it have MAIN?

[09:20] <moritz> prolly not

[09:20] <moritz> pugs: sub MAIN() { say "OH SHARK" }

[09:20] <p6eval> pugs:  ( no output )

[09:20] <moritz> pugs doesn't like sharks :-(

[09:21] <moritz> rakudobug submitted

[09:22] <moritz> (about that enum+but wtf)

[09:22] <moritz> that's two enum bugs found in S12-enums/pseudo-functional.t

[09:23] <moritz> erm, rakudobugs detected by that test file

[09:23] <isBEKaml> tadzik: I think it runs off its own Prelude. 

[09:23] <isBEKaml> tadzik: no MAIN

[09:23] <tadzik> I see

[09:24] <isBEKaml> pugs: sub BAR() { say "OH SHARK!" }; BAR();

[09:24] <p6eval> pugs: OUTPUT«OH SHARK!␤»

[09:24] <isBEKaml> pugs: sub MAIN() { say "OH SHARK!" }; MAIN();

[09:24] <p6eval> pugs: OUTPUT«OH SHARK!␤»

[09:24] <isBEKaml> so, to pugs, MAIN is just a sub, not a very special one at that. 

[09:25] <moritz> r: enum A <b c>; say b ~~ A

[09:25] <p6eval> rakudo 2ac569: OUTPUT«True␤»

[09:25] <moritz> r: enum A <b c>; say ("foo" but b) ~~ A

[09:25] <p6eval> rakudo 2ac569: OUTPUT«False␤»

[09:26] <moritz> r: enum A <b c>; say ("foo" but b) ~~ b

[09:26] <p6eval> rakudo 2ac569: OUTPUT«True␤»

[09:26] <moritz> wait. b ~~ A, but ("foo" but b) ~~ b  and ("foo" but b) !~~ A?

[09:27] <moritz> that seems... odd

[09:28] <moritz> I kinda thought our type system was transitive :-)

[09:28] * moritz submits rakudobug

[09:31] <moritz> wow, that test file really is full of all <weird good> stuff

[09:40] <jnthn> mornin'

[09:40] *** crab2313 joined
[09:40] *** thelazydeveloper joined
[09:41] *** paul1234 joined
[09:42] <moritz> \o jnthn

[09:42] <jnthn> r: enum A <b c>; say ("foo" but b) ~~ A

[09:42] <p6eval> rakudo 2ac569: OUTPUT«False␤»

[09:42] <isBEKaml> jnthn: \o

[09:42] <jnthn> There's a good reason for that one.

[09:43] <jnthn> When you do "but b", it generates a role from the enum.

[09:43] <moritz> r: enum A <b c>; say ("foo" but b) ~~ b

[09:43] <p6eval> rakudo 2ac569: OUTPUT«True␤»

[09:43] <jnthn> Then *that* role is mixed in.

[09:44] <moritz> ah, and the matching against b isn't a type check

[09:44] <jnthn> Right.

[09:44] <isBEKaml> r: enum A <a b c>; say ("foo" but b).WHAT

[09:44] <p6eval> rakudo 2ac569: OUTPUT«Str+{<anon>}()␤»

[09:44] <moritz> so it's not an intransitivity in the type check after all

[09:44] <moritz> s/check/system/

[09:44] * moritz relieved

[09:45] <jnthn> Yeah. I'm a little nervous about making that come back with "true" also.

[09:45] <moritz> which one? the ("foo" but b) ~~ b ?

[09:45] <jnthn> No, the ~~ A one.

[09:46] <moritz> r: enum A <b c>; say 0 ~~ b

[09:46] <p6eval> rakudo 2ac569: OUTPUT«True␤»

[09:46] <jnthn> r: enum A <b c>; say A.^mro; say ("foo" but b).^mro

[09:46] <p6eval> rakudo 2ac569: OUTPUT«A() Int() Cool() Any() Mu()␤Str+{<anon>}() Str() Cool() Any() Mu()␤»

[09:46] <moritz> jnthn: I'm finde with that. Some test file wants it to be True, but that doesn't mean much

[09:47] <isBEKaml> jnthn: so, by mro, A() => ("foo" but b ) ~~ A should return true? 

[09:47] <moritz> isBEKaml: no

[09:48] <moritz> A doesn't appear in the ("foo" but b ) MRO

[09:48] <jnthn> Right, and that's the problem.

[09:48] <isBEKaml> moritz: Ah, I **can't** read. :/

[09:48] * isBEKaml cusses irssi for hiding NLs off the end.

[09:49] <jnthn> If we make that outcome of the mixin say "yes, I'm an A", we'll get a whole load of fascinating bugs when the optimizer relies on that. :)

[09:49] <jnthn> Or, well, when just about anything does really.

[09:49] <isBEKaml> jnthn: blog about our type system someday? :)

[09:50] <jnthn> e.g. ("foo" but b ) ~~ Int would become true

[09:50] <isBEKaml> jnthn: don't ask me to buy that book about MOP (it's way over my pockets) :(

[09:50] <isBEKaml> s/over/beyond/

[09:50] <jnthn> isBEKaml: The book about MOP wouldn't be terribly helpful here anyway.

[09:51] <isBEKaml> jnthn: so yes, blog?

[09:51] <jnthn> Yeah, I'll try and make some post on that...could be interesting. :)

[09:51] <isBEKaml> \o/ jnthn++

[09:51] <jnthn> Anyway, we should only have the result of the mixin claiming it's a subtype of the enum type iff it is capable of the things the enum type is.

[09:52] <moritz> r: enum A <b c>; say +("foo" but c)

[09:52] <p6eval> rakudo 2ac569: OUTPUT«0␤»

[09:52] <jnthn> hmmm

[09:52] <moritz> r: enum A <b c>; say +("foo" but c).c

[09:52] <p6eval> rakudo 2ac569: OUTPUT«Method 'c' not found for invocant of class 'Str+{<anon>}'␤  in block <anon> at /tmp/2AtTC_j7E5:1␤␤»

[09:52] <moritz> r: enum A <b c>; say +("foo" but c).A

[09:52] <p6eval> rakudo 2ac569: OUTPUT«1␤»

[09:53] <moritz> currently enum mixins establish more of a has-a relation, not an is-a relation

[09:53] <isBEKaml> o.O(moritz coming up with his punches to jnthn)

[09:53] <moritz> I'm fine with that

[09:53] <jnthn> moritz: I think that's how we've always had it. as-role.t all passes with the current implementation, fwiw.

[09:54] <jnthn> Don't suppose you're in the thorough.t wonderland? :)

[09:55] <moritz> jnthn: no, pseudo-functiona.t

[09:55] <moritz> *functional

[09:55] <moritz> we don't run that file yet

[09:55] <moritz> because the first test segfaulted :-)

[09:55] <moritz> I fixed that

[09:55] <jnthn> ah, OK :)

[09:55] <moritz> but some of the tests are at least questionable (checking ("foo" but C) ~~ A)), and another one is segfaulting too

[09:56] <moritz> and then there's the wonderful https://rt.perl.org/rt3/Ticket/Display.html?id=112908

[09:56] <moritz> which this file also uncovered

[09:57] <masak> oh hai #perl6

[09:57] <masak> \o/

[09:58] <jnthn> r: enum day <a b c d e>;say day(3) === d; "foo" but d; say "alive"; "foo" but day(3)

[09:58] <p6eval> rakudo 2ac569: OUTPUT«True␤alive␤Type check failed in assignment to '$!day'; expected 'day' but got 'Int'␤  in block <anon> at src/gen/CORE.setting:650␤  in method BUILD_LEAST_DERIVED at src/gen/CORE.setting:637␤  in sub infix:<but> at src/gen/CORE.setting:10579␤  in block <anon> at /tm…

[09:58] <jnthn> r: enum day <a b c d e>;say day(3) === d; "foo" but d; say "alive"; "foo" but day(b)

[09:58] <p6eval> rakudo 2ac569: OUTPUT«True␤alive␤»

[09:58] *** localhost left
[09:58] <jnthn> moritz: Remember that "foo but some-role(bar)" is a special form.

[09:59] * masak is logging in from the backseat of a car!

[09:59] <moritz> jnthn: but day isn't a role

[09:59] <jnthn> er, s/role/type

[09:59] <masak> this is awesome! but slow.

[09:59] <jnthn> But the compiler is still doing the transform, anyways.

[10:00] <isBEKaml> this github UI keeps changing. What's up with github these days? 

[10:00] *** localhost joined
[10:00] <moritz> r: enum day <a b c d e>;say day(3) === d; say ("foo but (my $ = day(3))

[10:00] <p6eval> rakudo 2ac569: OUTPUT«===SORRY!===␤Non-variable $ must be backslashed at line 1, near "$ = day(3)"␤»

[10:00] <moritz> r: enum day <a b c d e>;say day(3) === d; say ("foo but (my $x = day(3))

[10:00] <p6eval> rakudo 2ac569: OUTPUT«===SORRY!===␤Variable $x is not declared␤at /tmp/DD5gtSDwaY:1␤»

[10:00] <jnthn> Missing quote

[10:00] <moritz> r: enum day <a b c d e>;say day(3) === d; say ("foo" but (my $x = day(3))

[10:00] <p6eval> rakudo 2ac569: OUTPUT«===SORRY!===␤Redeclaration of symbol $x␤at /tmp/jE2opvCVxm:1␤»

[10:00] <moritz> takk

[10:00] <moritz> eeks

[10:00] <isBEKaml> wtf?

[10:00] <moritz> r: enum day <a b c d e>; my $x = day(3); say "foo" but $x

[10:01] <p6eval> rakudo 2ac569: OUTPUT«foo␤»

[10:01] <isBEKaml> where did the redeclaration come from?

[10:01] <moritz> isBEKaml: from a misguided backtracking, probably

[10:01] <jnthn> An issue that's already in RT...it's..yes, backtracking.

[10:01] <jnthn> I dunno where.

[10:01] <jnthn> I'm hoping it will magically go away when qbootstrap arrives. :)

[10:02] *** xinming_ left
[10:03] <jnthn> moritz: Anyway, the problem with "but day(3)" I guess is where to put the coercion.

[10:06] *** dbr joined
[10:07] * jnthn tries a possible patch

[10:24] <jnthn> Seems to work

[10:27] *** JimmyZ joined
[10:29] <dalek> rakudo/nom: 9c85a3b | jnthn++ | src/core/operators.pm:

[10:29] <dalek> rakudo/nom: When mixing in an enumeration and supplying an initialization value, we should also apply coercion if needed, so day(2) works as well as day(tue).

[10:29] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9c85a3baa9

[10:32] *** spider-mario joined
[10:34] *** isBEKaml left
[10:41] <jnthn> moritz: ^^ should deal with #112908

[10:41] *** thou left
[10:53] <spider-mario> why does True ^^ True return Nil instead of False?

[10:53] <spider-mario> (or is it precisely what #112908 is about?)

[10:54] *** PacoAir joined
[10:55] <jnthn> huh?

[10:55] <jnthn> #112908 is about enums

[10:56] <spider-mario> ok

[10:57] <spider-mario> but shouldn’t True ^^ True be False?

[10:57] <spider-mario> just like False ^^ False

[10:57] <spider-mario> it seems to produce Nil, currently

[10:58] <spider-mario> r: say (False, True X^^ False, True).perl

[10:58] <p6eval> rakudo 32b173: OUTPUT«(Bool::False, Bool::True, Bool::True).list␤»

[10:59] <spider-mario> r: say (True ^^ True).perl

[10:59] <p6eval> rakudo 32b173: OUTPUT«Nil␤»

[11:00] *** whiteknight joined
[11:00] *** whiteknight is now known as Guest28866

[11:00] <colomon>  spider-mario: what should 45 ^^ True return?  45 ^^ 23

[11:00] <colomon> ?

[11:01] <spider-mario> False, I guess

[11:01] <colomon> r: say (45 ^^ False).perl

[11:02] <p6eval> rakudo 32b173: OUTPUT«45␤»

[11:02] <spider-mario> I’m sorry, I fail to see your point

[11:03] <colomon> ^^ isn't an operation that returns Bool

[11:03] <colomon> It returns one of its arguments when possible

[11:03] <spider-mario> the spec says: “Returns Bool::False otherwise (when more than one argument is true).”

[11:03] <spider-mario> not “Nil”

[11:04] <colomon> perl6: say 45 ^^ 23

[11:04] <p6eval> rakudo 32b173: OUTPUT«Nil␤»

[11:04] <p6eval> ..niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/E1YSLxL6K2 line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65)…

[11:04] <p6eval> ..pugs: OUTPUT«␤»

[11:04] <colomon> perl6: say (45 ^^ 23).perl

[11:04] <p6eval> rakudo 32b173: OUTPUT«Nil␤»

[11:04] <p6eval> ..niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/0NBCKHTnQr line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65)…

[11:04] <p6eval> ..pugs: OUTPUT«Bool::False␤»

[11:05] <spider-mario> n: say (True ^^ True).perl

[11:05] <p6eval> niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Any␤  at /tmp/0UIAjgMXOy line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3843 (module-CORE @ 65)…

[11:05] <colomon> I suspect you've found a bug in the spec.

[11:06] <colomon> but I admit I'm not familiar enough with that corner of it to be sure.

[11:07] *** mdupont left
[11:13] <dalek> tablets: de4db14 | isBEKaml++ | docs/tablet- (2 files):

[11:13] <dalek> tablets: language cleanups and spurious wordings.

[11:13] <dalek> tablets: 

[11:13] <dalek> tablets: * I'm not sure we need buzzword lingo when talking about perl6

[11:13] <dalek> tablets: * WIP - with tablet 2.

[11:13] <dalek> tablets: review: https://github.com/perl6/tablets/commit/de4db1404c

[11:13] <dalek> tablets: 68aef27 | isBEKaml++ | docs/tablet-2-basic-syntax.txt:

[11:13] <dalek> tablets: [tablets] round 2

[11:13] <dalek> tablets: review: https://github.com/perl6/tablets/commit/68aef27710

[11:13] <dalek> tablets: b5f516d | isBEKaml++ | / (13 files):

[11:13] <dalek> tablets: merges from master

[11:13] <dalek> tablets: review: https://github.com/perl6/tablets/commit/b5f516de3f

[11:13] <dalek> tablets: 5c61f5d | isBEKaml++ | docs/tablet-2-basic-syntax.txt:

[11:13] <dalek> tablets: more corrections.

[11:13] <dalek> tablets: review: https://github.com/perl6/tablets/commit/5c61f5df20

[11:13] <dalek> tablets: 43c8bc0 | (Herbert Breunung)++ | docs/tablet- (2 files):

[11:13] <dalek> tablets: Merge pull request #9 from svatsan/svatsan

[11:13] <dalek> tablets: 

[11:13] <dalek> tablets: thank you very much

[11:13] <dalek> tablets: review: https://github.com/perl6/tablets/commit/43c8bc02ad

[11:20] *** crab2313 left
[11:20] <moritz> \o/ commits

[11:22] * moritz just had lunch. Asparagus. Very tasty :-)

[11:22] *** goraki joined
[11:22] <moritz> later: mango and strawberrys

[11:23] <moritz> and then cake

[11:23] <moritz> phenny: "rhabarberstreuselkuchen"?

[11:23] <phenny> moritz: "rhubarb crumble" (de to en, translate.google.com)

[11:23] <dalek> tablets: 3025a94 | (Herbert Breunung)++ | docs/tablet-2-basic-syntax.txt:

[11:23] <dalek> tablets: small fixes

[11:23] <dalek> tablets: review: https://github.com/perl6/tablets/commit/3025a94b69

[11:23] <dalek> tablets: 7cd6b8f | (Herbert Breunung)++ | docs/tablet- (2 files):

[11:23] <dalek> tablets: Merge branch 'master' of github.com:perl6/tablets

[11:23] <dalek> tablets: review: https://github.com/perl6/tablets/commit/7cd6b8ffd2

[11:23] <moritz> hm, not quite, but close

[11:23] <jnthn> mmm..crumble :)

[11:23] <moritz> phenny: "streuselkuchen"?

[11:23] <phenny> moritz: "streusel" (de to en, translate.google.com)

[11:23] <goraki> I just entered to see "mango and strawberries, and then cake"

[11:23] <goraki> now I'm hungry...

[11:24] <jnthn> goraki: I'm currently frying some bacon...

[11:24] <jnthn> :P

[11:24] <diakopter> o/

[11:24] <moritz> goraki: well, that's my food plan for today. But I'm not hungry at all right now, having just had lunch

[11:24] <goraki> jnthn: yeah, you're not helping.

[11:24] <goraki> and I just finished breakfast.

[11:24] <goraki> but I think we're in the same timezone.

[11:24] <moritz> there's a well-known recipe against hunger :-)

[11:25] <jnthn> hi, diakopter o/

[11:25] <goraki> eating again?

[11:25] <moritz> goraki: yes

[11:26] <diakopter> I should eat,but it's almost time to wake up.. I mean... go to bed.

[11:27] <moritz> r: enum Day <Mon Tue Wed>; ("Today" but Tue).Tue

[11:27] <p6eval> rakudo 9c85a3: OUTPUT«Method 'Tue' not found for invocant of class 'Str+{<anon>}'␤  in block <anon> at /tmp/waoA_5cgw7:1␤␤»

[11:28] *** drschumtzenberg left
[11:29] <dalek> roast: 1a88785 | moritz++ | S12-enums/pseudo-functional.t:

[11:29] <dalek> roast: fix one test, and remove two wrong ones

[11:29] <dalek> roast: review: https://github.com/perl6/roast/commit/1a88785a83

[11:29] <moritz> jnthn: that test file now segfaults after test 4 here

[11:30] <moritz> r: enum Day <Mon Tue Wed>; ("Today" but day(Tue)).Tue

[11:30] <p6eval> rakudo 9c85a3: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&day' called (line 1)␤»

[11:30] <moritz> r: enum Day <Mon Tue Wed>; ("Today" but Day(Tue)).Tue

[11:30] <p6eval> rakudo 9c85a3:  ( no output )

[11:30] <moritz> r: enum Day <Mon Tue Wed>; so ("Today" but Day(Tue)).Tue

[11:30] <p6eval> rakudo 9c85a3:  ( no output )

[11:30] <moritz> hm

[11:30] <moritz> not so easy to reduce, it seems

[11:31] <jnthn> Hm :/

[11:31] <diakopter> what's the full one?

[11:31] <moritz> diakopter: S12-enums/pseudo-functional.t after test 4

[11:31] <moritz> ok $x.Tue,         'day(Tue).Tue';

[11:32] <moritz> oh no

[11:32] <moritz> it segfaults in the test before

[11:32] <moritz> r: enum Day <Mon Tue Wed>; so Day("Today" but Day(Tue))

[11:32] <p6eval> rakudo 9c85a3: OUTPUT«(signal SEGV)»

[11:32] <moritz> there ya go

[11:33] <jnthn> wtf does that even mean...

[11:34] <jnthn> r: enum Day <Mon Tue Wed>; Day("Today" but Day(Tue))

[11:34] <p6eval> rakudo 9c85a3:  ( no output )

[11:34] <jnthn> r: enum Day <Mon Tue Wed>; say Day("Today" but Day(Tue)).WHAT

[11:34] <p6eval> rakudo 9c85a3: OUTPUT«Can only use get_what on a SixModelObject␤  in block <anon> at /tmp/y6uN4fsnjm:1␤␤»

[11:35] <diakopter> r: enum Day <Mon Tue Wed>; say ("Today" but Day(Tue)).WHAT

[11:35] <p6eval> rakudo 9c85a3: OUTPUT«Str+{Day}()␤»

[11:35] <jnthn> r: say ("Today" but Day(Tue)).WHAT

[11:35] <p6eval> rakudo 9c85a3: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&Tue' called (line 1)␤Undefined routine '&Day' called (line 1)␤»

[11:35] <diakopter> r: enum Day <Mon Tue Wed>; say ("Today" but Day(Tue)).perl

[11:35] <p6eval> rakudo 9c85a3: OUTPUT«"Today"␤»

[11:35] <diakopter> r: enum Day <Mon Tue Wed>; say ("Today" but Day(Tue)).WHAT

[11:35] <p6eval> rakudo 9c85a3: OUTPUT«Str+{Day}()␤»

[11:35] <moritz> jnthn: ah, I guess I know what's wrong

[11:36] <jnthn> moritz: OK... afk for 10 mins or so

[11:36] <moritz> jnthn: we return %!vales_to_enum{$value} from that

[11:36] <moritz> and it's a parrot hash

[11:36] <moritz> so it returns Undef if there's no such key

[11:41] <dalek> tablets: 6ec44f3 | (Herbert Breunung)++ | docs/tablet-2-basic-syntax.txt:

[11:41] <dalek> tablets: slash has to be before space;spidermario++

[11:41] <dalek> tablets: review: https://github.com/perl6/tablets/commit/6ec44f3502

[11:44] <jnthn> moritz: oh...that 'splains it

[11:51] *** birdwindupbird joined
[11:53] *** amkrankruleuen joined
[11:54] *** snearch joined
[11:56] <dalek> rakudo/nom: f4837f5 | moritz++ | src/Perl6/Metamodel/EnumHOW.pm:

[11:56] <dalek> rakudo/nom: in value_to_enum, return the type object instead of parrot Null on lookup failure

[11:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/f4837f5310

[11:57] <dalek> roast: 5c7bb81 | moritz++ | S12-enums/pseudo-functional.t:

[11:57] <dalek> roast: fix another enum test

[11:57] <dalek> roast: review: https://github.com/perl6/roast/commit/5c7bb81f70

[11:58] <dalek> rakudo/nom: bdc4bb8 | moritz++ | t/spectest.data:

[11:58] <dalek> rakudo/nom: run the last remaining enum test file

[11:58] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/bdc4bb8853

[11:58] <jnthn> ooh :)

[11:58] <jnthn> moritz++

[11:58] <dalek> features: 4e735a4 | moritz++ | features.json:

[11:58] <dalek> features: give rakudo the green light on enums

[11:58] <dalek> features: review: https://github.com/perl6/features/commit/4e735a4604

[11:59] <moritz> r: enum A <b c b>;

[11:59] <p6eval> rakudo 9c85a3:  ( no output )

[11:59] <moritz> that one still needs to die

[11:59] <moritz> I might get to that later today

[11:59] <jnthn> ok :)

[11:59] <jnthn> moritz: What does "use" need in order to get the green light?

[11:59] <jnthn> moritz: Versioned modules has a separate entry, so I guess not that...

[12:00] <moritz> after that, maybe I should revisit typed exceptions

[12:00] <moritz> jnthn: I guess we can make it green too

[12:00] <moritz> it's not macroish yet, but I guess that's OK

[12:00] <jnthn> Yeah, at the moment the yellowness reason is "limited import lists". But we support all the tagged stuff...

[12:00] <moritz> and might even deserve a second entry at some point

[12:00] <jnthn> Well, that's more about dynamic exportation than "use".

[12:01] <moritz> and we even support positional arguments to use

[12:01] <jnthn> Right. :)

[12:01] <moritz> r: use lib 'foobar'; say @*INC;

[12:01] <p6eval> rakudo 9c85a3: OUTPUT«foobar /home/p6eval/.perl6/lib /home/p6eval/nom-inst2/lib/parrot/4.3.0-devel/languages/perl6/lib␤»

[12:01] <jnthn> \o/

[12:02] <tadzik> \o/

[12:04] <icwiener> Hmm.

[12:05] <icwiener> r: my $source = "xyz"; say $source.rindex("a").WHAT;

[12:05] <p6eval> rakudo 9c85a3: OUTPUT«Failure()␤»

[12:05] <icwiener> r: my $source = "xyz"; say $source.index("a").WHAT;

[12:05] <p6eval> rakudo 9c85a3: OUTPUT«Str()␤»

[12:05] <icwiener> Is it intended that they return different things?

[12:11] <jnthn> Looks odd to me.

[12:16] <moritz> probably an artifact of loose speccing

[12:16] <moritz> and easy to fix

[12:18] <icwiener> Just a stupid question: Would it be possible (and feasible) to have index() evaluate to true/false in boolean contex?

[12:20] *** mucker joined
[12:20] <moritz> icwiener: well, functions don't know their context

[12:20] <moritz> icwiener: so one could return '0 but True' or something

[12:22] <icwiener> Hmm, ok. So .defined is the way to go with index when used in boolean context?

[12:22] <moritz> iirc the specs says that it should return a StrPos object, which tracks things like byte, code point and grapheme indexes

[12:22] <moritz> icwiener: yes

[12:23] <icwiener> moritz: Ok, thanks.

[12:23] <icwiener> And yes, Spec says, it returns StrPos.

[12:23] <moritz> jnthn: any chance you can fix the roles + precompilation fix before the rakudo release on Thursday?

[12:23] <moritz> well, we could just cheat

[12:23] <Timbus> i think relying on '0' in boolean context is a bit of a C thing to do. it has its uses but really now

[12:23] <phenny> Timbus: 30 Apr 15:15Z <masak> tell Timbus I tried to use Net::IRC but https://gist.github.com/2559145

[12:23] <Timbus> waah

[12:23] <jnthn> moritz: Should be able to.

[12:24] <Timbus> someone used my code O_o

[12:24] <moritz> and have an   class StrPos is Int { multi method Bool(StrPos:D:) { True } } 

[12:24] <jnthn> moritz: I already figured out what's going on.

[12:24] <moritz> jnthn: ah right, I remember, OwnedList or so required

[12:25] <jnthn> moritz: Yeah

[12:25] <jnthn> This week is fairly light $dayjob wise, and it ain't a huge task. I should be able to have it in before the release.

[12:26] <icwiener> moritz: I I do not understand what you mean by that.

[12:26] <icwiener> ... in case that was meant for me. ;)

[12:27] <moritz> icwiener: partially

[12:27] <moritz> icwiener: what I proposed was simply an object that is just like an Int, except that it evalutes to True in boolean context even if its 0

[12:29] <icwiener> moritz: Sounds confusing. :)

[12:31] *** snearch left
[12:35] *** mdupont joined
[12:35] <Timbus> okay so um, how do you set public attributes in BUILD these days

[12:36] <tadzik> r: class A { has $.b; submethod BUILD { $!b = 7 } }; A.new.b.say

[12:36] <p6eval> rakudo bdc4bb: OUTPUT«7␤»

[12:36] <tadzik> on the other hand...

[12:36] <Timbus> wait what

[12:36] <tadzik> r: class A { has $.b = 4; submethod BUILD { $!b++ } }; A.new.b.say # won't work

[12:36] <p6eval> rakudo bdc4bb: OUTPUT«1␤»

[12:37] <tadzik> r: class A { has $.b = 4; submethod BUILD(:$!b) { $!b++ } }; A.new.b.say # should work

[12:37] <p6eval> rakudo bdc4bb: OUTPUT«1␤»

[12:37] <tadzik> eek

[12:37] <Timbus> i uh. alright.

[12:37] <tadzik> disregard the last one, I never know how to use that one

[12:38] <jnthn> You can't refer to virtual stuff in a submethod.

[12:38] <jnthn> $.b is $(self.b)

[12:38] <tadzik> I don't think I did

[12:38] <jnthn> tadzik: I explaining to Timbus :)

[12:38] <tadzik> okay :)

[12:39] <tadzik> so how do I use something like the above?

[12:40] <tadzik> that works when the user supplies $!b

[12:40] <tadzik> r: class A { has $.b = 4; submethod BUILD(:$!b) { $!b++ }; A.new(b => 12).b.say

[12:40] <p6eval> rakudo bdc4bb: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[12:41] <tadzik> r: class A { has $.b = 4; submethod BUILD(:$!b) { $!b++ } }; A.new(b => 12).b.say

[12:41] <p6eval> rakudo bdc4bb: OUTPUT«13␤»

[12:41] <jnthn> tadzik: Like that - as a named :)

[12:41] <Timbus> on to my next problem: why do default values override what I pass to new, if i have a submethod BUILD

[12:41] *** mdupont left
[12:41] <tadzik> jnthn: hmm, but how to make it work using the defaults?

[12:41] <Timbus> do i really need to handle everything in BUILD

[12:42] <tadzik> maybe I can't

[12:42] <jnthn> Timbus: Yes, if you're not using the default BUILD

[12:42] <Timbus> oh

[12:42] <jnthn> Timbus: But you can list them is the signature rather than doing assignments to them all

[12:42] <jnthn> Like tadzik just showed

[12:43] <jnthn> :$!attr1, :$!attr2 ...

[12:44] <Timbus> i tried typing words to express my feelings about this but here is a summary:  :I

[12:46] <tadzik> :)

[12:51] *** sergot joined
[12:51] <sergot> hi! o/

[12:51] *** raiph joined
[12:52] *** tyatpi joined
[13:02] <moritz> \o sergot 

[13:02] <moritz> r: say (1/10000000000).base(3)

[13:02] <p6eval> rakudo bdc4bb: OUTPUT«0.0000000000000000000010␤»

[13:03] <moritz> r: say :3<0.0000000000000000000010>

[13:03] <p6eval> rakudo bdc4bb: OUTPUT«0.000000000096␤»

[13:03] *** birdwind1pbird joined
[13:14] <Timbus> Cannot call 'said'; none of these signatures match:

[13:14] <Timbus> :(Net::IRC::Modules::Tell , $ev, Mu *%_)

[13:14] <Timbus>   in method dispatch:<.*> at src/gen/CORE.setting:839

[13:14] <Timbus> well.. yeah?

[13:14] <Timbus> i thought that was the point of .*

[13:15] *** cognominal_ left
[13:15] <Timbus> man domt tell me .* was re-specced

[13:15] *** cognominal joined
[13:16] <Timbus> because that would pretty much ruin all of the things i did in perl 6 D:

[13:22] *** Ulti joined
[13:23] <Ulti> out of interest is any of the perl6 regex/grammar stuff inspired by TXL?

[13:25] *** birdwindupbird left
[13:27] <Timbus> phenny, tell masak I fixed the bot. It's still broken though (because the `.*` style method call dies if nothing matches). Thanks for letting me know.

[13:27] <phenny> Timbus: I'll pass that on when masak is around.

[13:37] *** goraki left
[13:42] <raiph> Timbus: what did u think was the point of ".*" ?

[13:42] <raiph> Timbus: if you want to call whatever methods match, and still succeed if none do, that's ".?"

[13:42] *** birdwind1pbird left
[13:43] <raiph> Timbus: (iirc)

[13:44] <Timbus> i want to call all of them if there's more than one

[13:45] <Timbus> otherwise, .* and .+ are the same thing?

[13:46] <raiph> Timbus: i'm wrong

[13:47] <Timbus> in which case that means . and .? now just call every match i gue oh okay nevermind then

[13:59] <moritz> r: class A { }; A.*foo()

[13:59] <p6eval> rakudo bdc4bb:  ( no output )

[13:59] <moritz> r: class A { }; A.*foo(1, 2, :someargs)

[13:59] <p6eval> rakudo bdc4bb:  ( no output )

[14:00] <Timbus> r: class A { multi method foo(){} }; A.*foo(1, 2, :someargs)

[14:00] <p6eval> rakudo bdc4bb: OUTPUT«Cannot call 'foo'; none of these signatures match:␤:(A , Mu *%_)␤␤  in method foo at src/gen/CORE.setting:310␤  in method dispatch:<.*> at src/gen/CORE.setting:839␤  in block <anon> at /tmp/1P723aSDhZ:1␤␤»

[14:03] *** isBEKaml joined
[14:03] <isBEKaml> Sharkey, #perl6!

[14:04] *** adu joined
[14:12] *** icwiener left
[14:16] *** icwiener joined
[14:17] *** tyatpi left
[14:22] <isBEKaml> spider-mario++ #spotting mistakes!

[14:22] <spider-mario> :)

[14:40] <moritz> \o spider, shark and all the other animals here

[14:42] <isBEKaml> moritz: it's a jungle! ;)

[14:42] *** spider-mario left
[14:43] <isBEKaml> o.O(er, shark in a jungle?)

[14:43] *** Celelibi left
[14:44] <moritz> river sharks in the jungle!

[14:44] <moritz> r: say 0.base(2)

[14:44] <p6eval> rakudo bdc4bb: OUTPUT«0␤»

[14:47] <dalek> roast: 259bfe3 | moritz++ | S32-num/base.t:

[14:47] <dalek> roast: test 0.base(2), RT #112872

[14:47] <dalek> roast: review: https://github.com/perl6/roast/commit/259bfe3f64

[14:48] <geekosaur> sharkū?

[14:50] *** tokuhirom left
[14:50] *** tokuhirom joined
[14:55] *** mucker left
[14:55] *** tokuhirom left
[14:55] *** adu left
[14:56] *** adu joined
[14:58] <isBEKaml> geekosaur: LOTR? :D

[14:58] <geekosaur> yep

[15:03] <isBEKaml> geekosaur: well, we're not Orcs, are we? :)

[15:03] <isBEKaml> and there's no grey wizard. Only white cloaks. :)

[15:06] *** Celelibi joined
[15:07] <masak> lol shark, #perl6.

[15:07] <phenny> masak: 13:27Z <Timbus> tell masak I fixed the bot. It's still broken though (because the `.*` style method call dies if nothing matches). Thanks for letting me know.

[15:07] <masak> hm, .* shouldn't die if nothing matches.

[15:07] <masak> Timbus: we're planning to use the bot as part of a demonstration of Perl 6 for non-Perl programmers in Bristol next week.

[15:08] <masak> r: class A {}; A.new.*foo; say "alive"

[15:08] <p6eval> rakudo bdc4bb: OUTPUT«alive␤»

[15:08] <moritz> maybe it's some dependent stuff that fails?

[15:09] <masak> mebbe.

[15:11] <masak> Tene: yes, I'm familiar with your experiences with Parrot interop. I was mostly expressing my surprise that others hadn't rushed in to realize that dream (since it seems to be central to Parrot).

[15:12] <jnthn> masak: Looking at the backlog...it's this:

[15:12] <jnthn> r: class A { multi method foo(){} }; A.*foo(1, 2, :someargs)

[15:12] <p6eval> rakudo bdc4bb: OUTPUT«Cannot call 'foo'; none of these signatures match:␤:(A , Mu *%_)␤␤  in method foo at src/gen/CORE.setting:310␤  in method dispatch:<.*> at src/gen/CORE.setting:839␤  in block <anon> at /tmp/8kVM77IRVD:1␤␤»

[15:13] <jnthn> Of course, since the spec changed on multis to the proto-controls model, .* only applies to the MRO search.

[15:13] *** Guest28866 left
[15:14] <masak> hm.

[15:14] <masak> why do people think RT sucks? once you get over the search interface being wonky and alien, it's not that bad.

[15:14] *** kaare_ left
[15:15] <Tene> masak: agreed; the lack of interest has surprised me too.

[15:16] <jnthn> masak: I don't think RT sucks, fwiw :)

[15:19] <masak> \o/

[15:21] *** shinobicl joined
[15:29] <Tene> masak: a few people have expressed the feeling that language interop isn't as desirable without first having sufficiently good languages, so they're focusing on that instead.

[15:30] <masak> well, yes and no.

[15:31] <masak> we can't pretend that language interop would layer nicely on top of the sufficiently good languages once they're in place.

[15:31] <masak> it'd have to be iterated, just like everything else.

[15:31] <Tene> I certainly agree.

[15:33] <Tene> There's also the issue of directing volunteer effort; nobody has personally decided that their time would be best used on language interop.

[15:34] <masak> oh, sure.

[15:34] <masak> but that's still odd considering the way Parrot was imagined.

[15:35] <masak> like a cross-dynlang VM.

[15:36] <masak> Tene: you're the only person I know who ever tried making that happened. and as I understand, you stopped when your stuff broke due to upstream changes in Parrot.

[15:36] <Tene> masak: after the third time it broke, and I felt like nobody else cared and got rather burned out.

[15:38] <Tene> Specifically, I added language interop stuff to PCT (or whatever it was named then), and there were several large refactors that just dropped language interop on the floor.

[15:38] *** Celelibi left
[15:39] <Tene> It might have gone better if I had managed to get language smoke testing or something like it.

[15:42] <masak> aye.

[15:42] <Tene> these days things are further complicated by 6model; if 6model ever gets integrated into parrot, I might reconsider trying it again.

[15:43] <Tene> I've talked with three or four people with interest in working on language interop, but they've never followed up.

[15:43] <adu> Tene: is 6model part of NQP?

[15:43] <JimmyZ> and everybody want 6model in parrot, but nobody pick it up.

[15:43] <moritz> yes

[15:44] *** Celelibi joined
[15:46] <isBEKaml> are there perl6 folks working on parrot too? or is it the other way round?

[15:46] <isBEKaml> or neither? :|

[15:46] <moritz> some of the rakudo hackers occasionally implement/fix stuff in parrot when needed

[15:47] <moritz> and some people like benabik++ mostly focus on parrot, and occasionally contribute to rakudo

[15:47] <tadzik> and Parrot hackers sometimes submit patches for incompatibile Parrot changes

[15:47] <moritz> but mostly it's just what tadzik++ says

[15:47] <benabik> whiteknight said he'd work on 6model/Parrot integration this summer.

[15:47] <isBEKaml> okay, the reason I asked this was, if there were regulars on parrot and perl6, they could push for integration on either side. 

[15:48] <isBEKaml> benabik: it's summer! :D

[15:48] <benabik> isBEKaml: Indeed it is.

[15:48] <moritz> isBEKaml: well, the parrot folks are very much interested in integrating 6model

[15:49] <isBEKaml> benabik: I have said this before, I guess - parrot seems to be working out of an echo chamber. I used to see a lot of news from parrot side of things, but now it's almost nothing. 

[15:49] <isBEKaml> benabik: the blogosphere is nearly empty except for occasional posts from whiteknight.

[15:50] <benabik> isBEKaml: Parrot's trying to work on some hard problems and we're down to only three or four main devs, none of whom can put a lot of time into it.

[15:50] <isBEKaml> :(

[15:50] <benabik> isBEKaml: Whiteknight is definitely the most productive blogger, yes.  I'm better with code than English.

[15:51] <benabik> isBEKaml: Yes, it's sad.  What irritates me the most is the number of people who complain about it rather than come help us.

[15:51] <benabik> We've had several new language people show up recently, which is nice.  Hope they stay around past their initial poking around.

[15:51] <isBEKaml> benabik: I could if I can - but there'd be some amount of handholding involved since it's been quite a _long_ time I did some C coding.

[15:52] *** mucker joined
[15:52] <benabik> isBEKaml: Parrot's codebase is a somewhat unique beast.  But we're more than happy to help someone learn it.

[15:52] *** JimmyZ left
[15:52] <isBEKaml> benabik: I'm mostly irritated that rakudo is a _slow_ beast on parrot. If parrot side of affairs are sped up, rakudo benefits the most!

[15:53] <isBEKaml> benabik: and I can't even build it on my machine. :/

[15:54] <benabik> isBEKaml: What's the problem getting it to build?

[15:55] <isBEKaml> benabik: space/memory issues. I'm talking about rakudo, not parrot. 

[15:55] <isBEKaml> I can build parrot fine, though it takes some time. 

[15:58] *** goraki joined
[15:58] <isBEKaml> benabik: I'll do some reading on parrot first. You should be hearing from me soon. (unique beast or not)

[15:58] <benabik> isBEKaml: Excellent.  </burns>

[16:24] *** crab2313 joined
[16:25] *** Araq joined
[16:25] <adu> does 'grammar' define a package?

[16:26] <jnthn> Yes, module/class/grammar/role are all kinds of package.

[16:30] <moritz> in fact, 'grammar' just introduces a class that inherits from the class Grammar

[16:31] <jnthn> Cursor, innit?

[16:31] <jnthn> r: say (grammar Foo { }).^mro

[16:31] <p6eval> rakudo bdc4bb: OUTPUT«Foo() Grammar() Cursor() Any() Mu()␤»

[16:31] <moritz> so a grammar can has attributes, you can instantiate it

[16:31] <jnthn> Heh. :)

[16:31] <jnthn> moritz++

[16:31] <moritz> compose roles into it etc.

[16:31] <moritz> jnthn++ implemented it :-)

[16:31] <jnthn> Apparently :P

[16:32] <jnthn> GrammarHOW is a subclass of ClassHOW, that just diddles the default parent. I think that's the only difference.

[16:33] <adu> so grammar < class < module < package

[16:33] *** TimToady left
[16:33] *** TimToady joined
[16:34] <adu> jnthn++

[16:34] *** mst joined
[16:34] <adu> karma jnthn 

[16:34] <aloha> jnthn has karma of 2613.

[16:34] <adu> wow

[16:35] <mst> dear gentlemen: please note that if Mr. Wall shows up without the @perl/timtoady from now in, it means somebody needs to tell him that his nickserv auto-login broke again :)

[16:35] <adu> karma moritz 

[16:35] <aloha> moritz has karma of 3146.

[16:35] <mst> uh, s/dear gentlemen/dear gentlepeople/

[16:35] <mst> eh, you knew what I meant

[16:35] <mst> ta

[16:35] *** mst left
[16:36] <jnthn> adu: In terms of what they're capable of, you can kinda see it that way.

[16:37] <jnthn> adu: Under the hood though, the meta-objects implementing them don't have an inheritance relationship.

[16:37] <jnthn> adu: It's factored in terms of roles instead.

[16:37] <jnthn> It's quite pretty. :)

[16:38] <adu> :)

[16:40] *** amkrankruleuen left
[16:49] <sorear> good * #perl6

[16:50] <sorear> good * #perl6

[16:51] <adu> yey

[16:51] <adu> that was easy: http://pastebin.com/raw.php?i=qnUB2Gpg

[16:52] <jnthn> o/ sorear 

[16:56] <TimToady> p6: lines».trans('a..m' => 'n..z', 'n..z' => 'a..m').say

[16:57] <p6eval> pugs: OUTPUT«*** No such subroutine: "&lines"␤    at /tmp/R1Ubtu0XSN line 1, column 1 - line 2, column 1␤»

[16:57] <p6eval> ..niecza v17-4-ge5b869e: OUTPUT«Lnaq qre Bretr, Lnaq nz Sgebzr, Lnaq qre Äpxre, Lnaq qre Dbzr, Lnaq qre Häzzre, mhxhasgfervpu! Hrvzng ovfg qh tebßre Söuar, Vbyx, ortanqrg süe qnf Spuöar, ivrytreüuzgrf Öfgreervpu, ivrytreüuzgrf Öfgreervpu!  Hrvß hzsruqrg, jvyq hzfgevggra yvrtfg qrz Eeqgrvy…

[16:57] <p6eval> ..rakudo bdc4bb: OUTPUT«Lnaq qre Bretr, Lnaq nz Sgebzr, Lnaq qre Äpxre, Lnaq qre Dbzr, Lnaq qre Häzzre, mhxhasgfervpu! Hrvzng ovfg qh tebßre Söuar, Vbyx, ortanqrg süe qnf Spuöar, ivrytreüuzgrf Öfgreervpu, ivrytreüuzgrf Öfgreervpu!  Hrvß hzsruqrg, jvyq hzfgevggra yvrtfg qrz Eeqgrvy qh vazv…

[16:57] <TimToady> you don't need an explicit loop :)

[17:01] *** kaare_ joined
[17:04] *** isBEKaml left
[17:05] <adu> is there an unlines method?

[17:05] *** shinobicl left
[17:08] <adu> or join('\n')?

[17:11] *** paul1234 left
[17:13] <adu> can I do that with fmt?

[17:13] *** shinobicl joined
[17:13] <adu> @x.fmt(:separator('\n'))?

[17:14] *** shinobicl left
[17:14] <goraki>  r: say [1, 2, 3, 4].join("<rabbits>");

[17:14] <p6eval> rakudo bdc4bb: OUTPUT«1<rabbits>2<rabbits>3<rabbits>4␤»

[17:14] <goraki> adu: the same thing works for a newline.

[17:15] <adu> I don't see that in http://perlcabal.org/syn/S32/Str.html

[17:16] <adu> p6: say "uv\njbeyq".trans('a..m' => 'n..z', 'n..z' => 'a..m');

[17:16] <p6eval> pugs, rakudo bdc4bb, niecza v17-4-ge5b869e: OUTPUT«hi␤world␤»

[17:16] <adu> TimToady: I guess you're right

[17:21] *** adu left
[17:25] <Araq> multi method samecase ( Str $string: Str $pattern --> Str ) is export  # ':' a separator for parameters?

[17:26] <moritz> phenny: tell aduo that .join is a method on lists, not strings, so it won't appear in S32::Str

[17:26] <phenny> moritz: I'll pass that on when aduo is around.

[17:27] <gfldex> Araq: the colon in that spot "unhides" the hidden parameter any method will get that holds the reference to the object (self)

[17:28] <moritz> phenny: tell adu that .join is a method on lists, not strings, so it won't appear in S32::Str

[17:28] <phenny> moritz: I'll pass that on when adu is around.

[17:28] <moritz> it helps to spell the name right :-)

[17:28] <Araq> and parameters are separated by whitespace only?

[17:29] <moritz> no, by comma

[17:29] <gfldex> Araq: by , or ; (latter for slices)

[17:29] <moritz> r: sub f($x, $y) { say $x * $y }; f(42, 23)

[17:29] <p6eval> rakudo bdc4bb: OUTPUT«966␤»

[17:30] <Araq> Str $string: Str $pattern --> Str  # no , or ; here

[17:31] <moritz> well yes, the invocant is delimited with a colon, as gfldex explained

[17:31] <moritz> and --> Str  is just the type of the return value

[17:31] <moritz> but if you want more "normal" parameters, you delimit them with commas

[17:32] <Araq> so it's either , or ; or : ?

[17:32] <gfldex> no, the : is a special case as is the ;

[17:33] <moritz> Araq: yes, basically

[17:33] <gfldex> there is further a special special case where you need ;;

[17:34] <moritz> don't go there :-)

[17:34] <moritz> I've never need that, and I've been coding p6 for several years

[17:34] <Araq> so the "I want this explicit" marker is also a separator

[17:35] *** dx_ joined
[17:35] <gfldex> yes

[17:35] <gfldex> are longname parameters implemented?

[17:35] <Araq> ok, so when would I need ;; ?

[17:35] *** dx_ left
[17:36] <moritz> Araq: if you want to exclude parameters from participating in multi dispatch decisions

[17:36] <Araq> and I guess they would follow after ;; then?

[17:36] <moritz> see S06

[17:36] <moritz> yes

[17:37] <Araq> so sub f($a, $b)  is the same as  multi method f(: ;; $a, $b) ?

[17:38] <gfldex> no

[17:38] <Araq> why not?

[17:38] <gfldex> mostly because not providing an invocant in front of a : is illegal

[17:39] <gfldex> and that you don't let it take part in MMD does not mean it's not a multi

[17:39] <gfldex> there will be some proto somewhere autogenerated

[17:40] <Araq> MMD = "multi method ?"

[17:40] <Araq> "dispatch"?

[17:40] <gfldex> yes

[17:40] <gfldex> whereby it does not have to be a method, a sub can have MMD too

[17:40] <gfldex> it's a lack-of-better-name-problem

[17:41] <Araq> so how would a sub participate in MMD?

[17:41] <jnthn> We should really just call it multiple dispatch because it's orthogonal to method dispatch even when it is a multi-method.

[17:42] <gfldex> r: multi sub f(Str $s){ say $s }; multi sub f(Int $i){ say $i }; say 10; say "hello";

[17:42] <p6eval> rakudo bdc4bb: OUTPUT«10␤hello␤»

[17:44] <gfldex> r: multi sub f(Str $s){ say $s }; multi sub f(Int $i){ say $i }; f 10; f "hello"; # silly me

[17:44] <p6eval> rakudo bdc4bb: OUTPUT«10␤hello␤»

[17:44] * gfldex goes for a nice cup of tea

[17:45] <Araq> so "multi" means dynamic dispatch?

[17:45] <Araq> and "sub" means "no self/this" whereas "method" means "with self/this"?

[17:45] <gfldex> sub don't got a self indeed

[17:46] <jnthn> Araq: Yes, that's a fairly good summary...depending on your definition of dynamic dispatch ;)

[17:46] <gfldex> and the dynamic dispatch is kinda build in, in a dynamic language 

[17:46] <gfldex> r: sub f(){ say "boooring" }; &f.wrap({ say 'tricked you!'}); f

[17:46] <p6eval> rakudo bdc4bb: OUTPUT«tricked you!␤»

[17:48] <Araq> what if module A has a sub f and so does module B; and both modules are imported

[17:48] <Araq> what would f() invoke?

[17:48] <gfldex> the compiler should complain when you import

[17:48] <Araq> ok

[17:48] <Araq> what if both are "multi sub"s?

[17:49] <gfldex> then the first multi that got a full match on the provided signature wins

[17:49] *** alim joined
[17:49] <gfldex> don't ask me about order, they may or may not be any

[17:49] <Araq> what does "first" mean here?

[17:50] <jnthn> If a couple of multis are imported from different modules, they are just subject to the usual multi-dispatch rules.

[17:50] <jnthn> And if they have the same signatures, the dispatch will fail due to ambiguity.

[17:50] <Araq> ok

[17:51] *** cogno joined
[17:52] * jnthn wanders off to make some dinner

[17:52] *** cogno left
[17:54] *** thou joined
[17:55] *** spider-mario joined
[17:59] *** cogno joined
[18:11] *** alim left
[18:12] *** birdwindupbird joined
[18:13] *** cogno left
[18:13] <dalek> tablets: d1d65de | (Herbert Breunung)++ | docs/appendix-f-faq.txt:

[18:13] <dalek> tablets: short faq answer for:"why is it called perl"

[18:13] <dalek> tablets: review: https://github.com/perl6/tablets/commit/d1d65deea0

[18:18] *** sisar left
[18:34] *** sporous left
[18:35] *** crab2313 left
[18:36] *** sporous joined
[18:43] *** adu joined
[18:44] *** goraki left
[18:57] *** crab2313 joined
[19:16] *** adu left
[19:19] <moritz> meh

[19:19] <moritz> I just spend half an hour chasing a dispatch failure in IO::Prompter

[19:19] <diakopter> ?

[19:19] <moritz> and it turns out the reason was

[19:19] <moritz> a parameter   Bool :$someName = sub { False }

[19:20] <moritz> well, if you leave out that parameter, the candidate fails to bind. Thank you very much!

[19:20] <dalek> rakudo/nom: aeca2f8 | moritz++ | src/Perl6/Actions.pm:

[19:20] <dalek> rakudo/nom: fix a typo

[19:20] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/aeca2f857b

[19:21] <dalek> roast: 840bfda | moritz++ | S32-exceptions/misc.t:

[19:21] <dalek> roast: test for X::Signature::NameClash

[19:21] <dalek> roast: review: https://github.com/perl6/roast/commit/840bfdaabc

[19:24] *** wolf2k_away joined
[19:24] *** wolfman2000 left
[19:24] *** wolf2k_away is now known as wolfman2000

[19:26] <Araq> what does the :$ sigil mean?

[19:26] <moritz> there is no :$ sigil

[19:26] <moritz> :$foo means that $foo is a named parameter

[19:26] <Araq> Bool :$someName = sub { False } # well?

[19:27] <moritz> Araq: see http://perlcabal.org/syn/S06.html

[19:29] <Araq> sorry the spec assumes deep perl 5 knowledge and is full of jargon ...

[19:29] <Araq> so it's quicker to ask here

[19:34] *** mucker left
[19:40] <moritz> so if we want to motivate you to read the specs, we should be slower to answer? :-)

[19:47] <Araq> search the spec for "sigil"

[19:48] <Araq> a list of them is nowhere to be found

[19:48] *** wolfman2000 left
[19:49] <Araq> and to answer your question: it motivates to search in the spec ;-)

[19:49] <Araq> not to actually read it

[19:50] <Araq> though I must admit that it is amusing

[19:51] <Araq> "Leftover named arguments can be slurped into a slurpy hash."

[19:53] <dalek> nqp/PackfileView: d3a9cc2 | diakopter++ | / (5 files):

[19:53] <dalek> nqp/PackfileView: whiteknight's PackfileView patch, with whitespace and stage0 changes removed

[19:53] <dalek> nqp/PackfileView: review: https://github.com/perl6/nqp/commit/d3a9cc242f

[19:53] <diakopter> ^^ make test succeeds

[19:54] <jnthn> diakopter: make test in nqp?

[19:54] <diakopter> yes

[19:54] * jnthn suspects it may be worth a Rakudo build/spectest run atop of that.

[19:54] <diakopter> didn't try rakudo

[19:54] <jnthn> OK

[19:54] <diakopter> k I'll work on that

[19:55] <jnthn> Thanks :)

[19:55] * Araq wonders what the 'slurpy hash's sigil would look like ...    ()===%

[20:00] <diakopter> jnthn: well, that was a fail

[20:01] <moritz> yes, rakudo needs a patch too

[20:01] <moritz> Araq: hashes have the % sigil

[20:01] <moritz> Araq: and slurpies are marked with *

[20:01] <moritz> diakopter: whiteknight did a partial patch for rakudo, but another file needed a patch too

[20:02] <diakopter> which other file?

[20:02] <Araq> *%slurp ?

[20:02] <Araq> or %

[20:02] <Araq> %*slurp ?

[20:02] <moritz> diakopter: the module loader, iirc

[20:02] <jnthn> *%slurp

[20:03] <Araq> is the * narrowed for hash access?

[20:03] <Araq> *$slurp{'x'} ?

[20:03] <Araq> oh wait

[20:04] <Araq>  % is kept for hash access in perl6, right?

[20:08] <moritz> right

[20:09] <Araq> so is it  *%slurp{'x'}  or %slurp{'x'} ?

[20:10] *** PacoAir left
[20:10] <jnthn> It's %slurp{'x'}. The * is nothing to do with the variable. It's an instruction to the signature binder to put all of the leftover named parameters into the hash that follows it.

[20:11] *** fgomez joined
[20:11] <Araq> well the thing got its own name ("slurpy hash") so I was misguided

[20:12] <Araq> though I guess it would have been "slurpy-hash" then

[20:13] *** Chillance joined
[20:17] *** libertyprime left
[20:17] *** az5112 joined
[20:22] *** fgomez left
[20:22] *** kaare_ left
[20:25] *** thou left
[20:26] *** raiph left
[20:29] *** libertyprime joined
[20:34] <diakopter> moritz: let's say I have a commit to my fork of rakudo on github. how easy is it for someone working in the main rakudo nom branch to apply that patch?

[20:35] <diakopter> someone needs to make a parallel make spectest

[20:36] <jnthn> diakopter: I do a 6-way.

[20:37] <jnthn> diakopter: But it's not the default...gotta pass --jobs or something

[20:37] <diakopter> ohh

[20:38] <diakopter> moritz or anyone ^^

[20:41] <jnthn> diakopter: Oh, and on the patch, it'd be "git remote add diakopter the-github-url" and then fetch. And then the patch can be applied.

[20:42] <benabik> `git fetch <URL> <branch>` will store it in FETCH_HEAD

[20:42] <jnthn> oooh :)

[20:45] <diakopter> well, the commit dalek mentioned above and this one comprise whiteknight's patches to nqp&rakudo for PackfileView.  one or both need work, because there are *tons* of rakudo spectest failures.  https://github.com/diakopter/rakudo/commit/bbf0170df9f91112998dad46222bbafe18b5f5c9

[20:45] <Araq> "Note that all routines are (by default) considered to be candidates for inlining and constant folding. The optimizer is allowed to start making these optimizations after the main program's CHECK time, but not before. After any routine is "hard" inlined or constant folded, it is explicitly retyped as immutable; any attempt to wrap an immutable routine will result in failure of the wrap call....

[20:45] <Araq> ...An immutable routine is so marked by recasting to type HardRoutine, a subclass of Routine."

[20:45] <Araq> what does that mean?

[20:45] <Araq> that the implementation is allowed to freeze routine definitions for optimization purposes?

[20:46] <jnthn> Seems so :)

[20:46] <jnthn> It doesn't seem to set many boundaries for when the implementation is allowed to do that either... :)

[20:46] <jnthn> ...so if you want to be able to wrap a routine, you'd better not make it an inlining candidate! :P

[20:47] <jnthn> That's potentially a little unfortunate since pretty much every auto-generated proto sub is an inlining candidate...

[20:51] <Araq> so how would one mark a sub to be not freezable?

[20:52] <jnthn> Araq: Dunno. I don't think any of the implementations have tried to implement the bit you just quoted though.

[20:53] <jnthn> Araq: And I suspect it needs tweaks.

[20:53] <geekosaur> I think that's one of those bits of spec that was just put out there waiting for someone to try to actually follow it and thereby come up witht he real spec :)

[20:55] <Araq> alright, so I'm not the only one who doesn't read the spec :P

[20:58] <diakopter> (see my above) so I'm handing it off someone who knows how to debug it from there...

[21:03] <jnthn> diakopter: OK, thanks.

[21:05] <Araq> p6: sub f(Str %lie) {}

[21:05] <p6eval> niecza v17-4-ge5b869e: OUTPUT«Potential difficulties:␤  %lie is declared but not used at /tmp/5OFXBdddl1 line 1:␤------> sub f(Str ⏏%lie) {}␤  &f is declared but not used at /tmp/5OFXBdddl1 line 1:␤------> sub f⏏(Str %lie) {}␤␤»

[21:05] <p6eval> ..pugs, rakudo aeca2f:  ( no output )

[21:06] <Araq> p6: sub f(Str %lie) { say %lie{'0'} }  f("hi")

[21:06] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤Confused␤at /tmp/NiOA1DgBfd:1␤»

[21:06] <p6eval> ..niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/5AyrFP3Lsk line 1:␤------> sub f(Str %lie) { say %lie{'0'} }⏏  f("hi")␤␤Parse failed␤␤»

[21:06] <p6eval> ..pugs: OUTPUT«*** Odd number of elements found where hash expected: VStr "hi"␤    at /tmp/0Kblfwv3ha line 1, column 36 - line 2, column 1␤»

[21:06] <Araq> p6: sub f(Str %lie) { say %lie{'0'} };  f("hi")

[21:06] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'f' will never work with argument types (str) (line 1)␤    Expected: :(%lie)␤»

[21:06] <p6eval> ..pugs: OUTPUT«*** Odd number of elements found where hash expected: VStr "hi"␤    at /tmp/cztMTaryd_ line 1, column 37 - line 2, column 1␤»

[21:06] <p6eval> ..niecza v17-4-ge5b869e: OUTPUT«Unhandled exception: Nominal type check failed in binding '%lie' in 'f'; got Str, needed Associative␤  at /tmp/k8VAtv27Wj line 0 (f @ 1) ␤  at /tmp/k8VAtv27Wj line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3842 (ANON @ 3) ␤  at /home/…

[21:07] <sorear> Araq: can I help?

[21:07] <Araq> trying to figure out how perl handles sigil lies

[21:08] <sorear> Str %lie isn't a lie

[21:08] <Araq> why not?

[21:08] <sorear> %lie has type Hash[Str]

[21:08] <sorear> a hash that can hold Strs

[21:08] <sorear> like int foo[40] in C

[21:08] *** NamelessTee left
[21:09] <Araq> ah hm

[21:09] <Araq> what's Str $x then? a string string?

[21:09] <sorear> just a Str-holding variable.

[21:09] <Araq> a scalar string?

[21:09] <sorear> I am uncertain what "string string" means

[21:09] <Araq> me too :D

[21:10] <Araq> so what would a hash[string, int] look like?

[21:12] *** birdwindupbird left
[21:13] <sorear> Hash[Str,Int] is a kind error

[21:13] <sorear> Hash only takes one argument

[21:15] <Araq> a hash is a mapping from key to values, so it naturally takes 2 arguments

[21:15] <diakopter> in Perl it's a mapping from Str to values

[21:15] <Araq> I see

[21:16] <sorear> diakopter: Perl 6 supports non-Str keys

[21:16] <sorear> however, the key type is not reflected in the hash type

[21:16] <Araq> and I guess it's a scalar and not a Str anyway?

[21:16] <sorear> huh?

[21:16] <sorear> where are you getting this 'scalar' thing?

[21:16] *** NamelessTee joined
[21:17] <sorear> my Str %foo{Str}; my Str %bar{Int}; # %foo and %bar are both Hash[Str], but they use different kinds of keys.  Types are not the whole story

[21:17] <diakopter> that's confusing for someone familiar with Java's Map<,> or .NET's Dictionary<,>

[21:19] <Araq> I mean the implicti key type is '$' and not 'Str'

[21:19] <Araq> well I guess that

[21:19] <geekosaur> $ sigil isn't a type

[21:20] <Araq> what is it then?

[21:20] <Araq> I thought  $  == Num|Str|... and others

[21:21] *** geistteufel left
[21:21] * jnthn goes for some rest... 'night o/

[21:22] <geekosaur> technically it *is* a type, but it's a container type, which is a different kind of thing from a value type such as Num, Str, etc.

[21:22] <Araq> well yes it appears to be a sum type

[21:22] <geekosaur> Num, Str, etc. are what you can put inside a container; they say nothing about what the container itself is, though.  contrariwise $ says what a container is but nothing about the things it contains

[21:23] <gfldex> $ is a marker for the compiler that tells it it's not a function

[21:23] <Araq> still looks like a sum type to me

[21:24] <gfldex> it's easier to understand if you think of it what it not is

[21:24] <diakopter> $ can be a function

[21:24] *** bip` joined
[21:24] <gfldex> $ can hold a reference to a function

[21:25] <gfldex> you can't really touch the thing that is the function (unless you are the runtime)

[21:25] <diakopter> you're being confusing. 

[21:26] <Araq> lol? if anything it's the sigils that are confusing

[21:26] <dalek> tablets: 0bc8303 | (Herbert Breunung)++ | docs/appendix- (2 files):

[21:26] <dalek> tablets: more links in B and rework the explanation of "slang"

[21:26] <dalek> tablets: review: https://github.com/perl6/tablets/commit/0bc83033b7

[21:27] <gfldex> it's actually quite easy to understand if you speak a language that forces you to capitalise the beginning of nouns

[21:27] <gfldex> the capital at the beginning doesn't really make it a noun but it's an indication that helps you a lot to spot one

[21:29] <diakopter> gfldex: your distinction of $ holding a reference to a function but not holding a reference to other values is wrong, I think.

[21:30] <gfldex> it's a reference in any case

[21:30] <gfldex> but to get a reference to a function you have to ask for one explicitly

[21:30] <diakopter> what?

[21:32] <Araq> ja ja im Deutschen werden alle Nomen großgeschrieben. Und nu? Wir haben aber $ und % und @ (und weitere)

[21:32] <Araq> und die unterscheiden sich je nach Typ

[21:32] <diakopter> gfldex: what do you mean by 'ask for one explicitly'?

[21:32] <gfldex> ofc, they do

[21:32] <gfldex> you take a concept that works and extend it

[21:33] <gfldex> my $func = &somefunc

[21:33] <gfldex> vs. my $o = SomeObject.new;

[21:33] <sorear> Araq: $, @, %, and & are grammatical particles that modify the way variable references are compiled.  They have essentially nothing to do with types

[21:33] <Araq> lol?

[21:33] <diakopter> gfldex: what about my $a = sub { }

[21:33] <sorear> Araq: given &foo, you can say foo; but if you have $foo, you have to do $foo()

[21:34] <sorear> TimToady: we need you

[21:34] <Araq> of course it's about types

[21:34] <gfldex> diakopter: you get a reference because you asked for one

[21:34] *** mtk left
[21:34] <Araq> otherwise a single $ for "variable" would suffice

[21:34] <gfldex> r: my $a = sub(){ 'lol' }();

[21:34] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&sub' called (line 1)␤»

[21:34] <gfldex> r: my $a = (sub(){ 'lol' }).();

[21:34] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&sub' called (line 1)␤»

[21:35] <gfldex> well, in javascript you can do that :)

[21:35] <diakopter> gfldex: wtf are you talking about

[21:35] <gfldex> you are not running the function and store the return value but ask for a reference instead

[21:36] <diakopter> how is 'my $a = sub { }' not getting a reference to a function?

[21:36] <diakopter> gfldex: you are totally misunderstanding everything I've been saying

[21:36] <gfldex> that is very well possible

[21:36] <gfldex> or you could say it politely and assume that you misunderstood me

[21:37] <Araq> so if % is a hash, aka map[Str, T] and $ is a Num|Str| ... and @ is an array, how come they have nothing to do with types?

[21:37] <gfldex> % and @ promise an interface, not a type

[21:38] <sorear> Because the first half of your sentence is entirely wrong.

[21:38] <Araq> an interface is a type too

[21:38] <Araq> maybe not in perl6's lingo

[21:38] <gfldex> no it's not, not in perl6

[21:38] <diakopter> gfldex: anyway, you could answer my question.

[21:39] <gfldex> you don't need an interface because you got late binding

[21:39] <Araq> so what does $ promise? is it an 'atom'?

[21:39] <gfldex> diakopter: and what question would that be?

[21:39] <sorear> $ promises nothing

[21:39] <Araq> and what does @ promise?

[21:39] <diakopter> gfldex: how is 'my $a = sub { }' not getting a reference to a function?

[21:39] <sorear> @ doesn't "promise" anything either

[21:40] <gfldex> diakopter: i never wrote that, did i?

[21:40] <sorear> it just changes the way certain operations are done

[21:40] <sorear> for instance, (in niecza), @foo = 1, 2, 3 is rewritten into @foo.LISTSTORE(1, 2, 3)

[21:41] <diakopter> gfldex: I asked you what you meant by 'ask for one explicitly', and you gave the &func example. 

[21:41] <gfldex> sorear: i don't agree on that not being a promise and believe that there are quite a few other such promises

[21:41] <gfldex> diakopter: yes, and an anonymous function is another

[21:41] <sorear> the biggest difference is with list contexts; if $foo and @foo contain references to the same object, [$foo] and [@foo] are still different, because the @ causes the object to be iterated

[21:42] <gfldex> the @ gives you the promise to do something reasonable with my @a; for @a -> {...}

[21:43] <gfldex> and i'm quite sure it promises @a.push('some') to work too

[21:43] <gfldex> sorear: from the point of view of a language implementator you are right ofc

[21:44] <gfldex> from the standpoint of a teacher i would not agree

[21:45] <Araq> gimme the "language implementator view" please ;-)

[21:45] <sorear> fine then, Araq is yours.  I give up.

[21:46] <diakopter> gfldex: my original point was that ' < gfldex> $ is a marker for the compiler that tells it it's not a function' is just plain wrong

[21:46] <gfldex> diakopter: do you know the concept of "lies for children"?

[21:47] <diakopter> I know what you mean by that, yes. I think your claim is so completely wrong, it can't fall into that category.

[21:48] <gfldex> is it?

[21:48] <gfldex> what if i say: it's not a function but a reference to a function

[21:48] <gfldex> a function and a reference to a function can't be the same thing, can it?

[21:48] <diakopter> that's a false distinction, because the other sigils can't hold "functions as opposed to references to functions"

[21:49] *** crab2313 left
[21:50] <diakopter> that's like saying, a truck is distinct from other vehicles because it can't hold continents.

[21:51] <diakopter> the other vehicles can't hold continents, so how is that helpful...

[21:53] *** lestrrat left
[21:53] <Araq> well I don't want the "lie for children"

[21:54] <Araq> I'd like to know what the purpose of the sigils is except from some string interpolation

[21:54] *** lestrrat joined
[21:54] <gfldex> Araq: there you go: http://perlcabal.org/syn/S02.html#Sigils

[21:55] <Araq> "Perl 6 includes a system of sigils to mark the fundamental structural type of a variable: ..."

[21:55] <Araq> so it's about types ...

[21:55] <gfldex> no, it's not

[21:55] <gfldex> a structual type is not a type

[21:56] <gfldex> a type is an actual object, a structural type is syntax

[21:56] <gfldex> r: Str.WHAT.say;

[21:56] <p6eval> rakudo aeca2f: OUTPUT«Str()␤»

[21:56] <Araq> a green house is no house?

[21:56] <Araq> that's news to me

[21:56] <gfldex> if you want to be snotty, just tell me and i will kindly ignore you

[21:57] <Araq> I'm enjoying this conversation, but I don't want to be snotty

[21:57] <diakopter> they're orthogonal measurements. "type" here is the usual notion in programming languages. "structural type" is "kind of structure"

[21:58] <Araq> so is it about contexts?

[21:58] <diakopter> it's more about roles. @ does Positional and Iterable. % does Associative.

[21:58] <Araq> and $ ?

[21:59] <Araq> & does callable then?

[21:59] <diakopter> I don't think that role has a name... just "reference and dereference" I guess

[21:59] <diakopter> yes, & is Callable

[21:59] <Araq> so can I do $foo{'x'} too?

[22:00] <diakopter> let's see.. sec

[22:00] <gfldex> $ is syntax and so is @ and %, but @ & % have some extra meaning on to of that

[22:00] <gfldex> r: $foo = Hash.new; $foo{'x'} = 10;

[22:00] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤Variable $foo is not declared␤at /tmp/BVQ9agnDHj:1␤»

[22:00] <gfldex> r: my $foo = Hash.new; $foo{'x'} = 10;

[22:00] <p6eval> rakudo aeca2f:  ( no output )

[22:00] <gfldex> r: my $foo = Hash.new; $foo{'x'} = 10; say $foo.perl;

[22:00] <p6eval> rakudo aeca2f: OUTPUT«{"x" => 10}␤»

[22:01] <diakopter> niecza: my %a = { a => 2 }; my $b = %a; say $b{'a'}

[22:01] <p6eval> niecza v17-4-ge5b869e: OUTPUT«2␤»

[22:01] <gfldex> you can do that because $foo{'x'} is the same then $foo.{'x'} what is defined in a Role

[22:01] <gfldex> that role is Associative IIRC

[22:02] <gfldex> being able to obmit the . is syntactical sugar

[22:02] <gfldex> perl6 is so sweet :)

[22:04] <diakopter> gfldex: did you understand my answer to your question?

[22:04] <gfldex> diakopter: i believe so and we are both wrong

[22:04] <gfldex> because it's pretty futile to think about it as something that is

[22:04] <gfldex> in the end it's just text fed to a compiler

[22:05] <gfldex> it has meaning tho

[22:05] <Araq> so basically $ means "variable" and may be a hash too

[22:05] <gfldex> and one of the meanings of sigils is to make a destinction between stuff that is a function and stuff that may not be a function

[22:06] <gfldex> Araq: you can think like that as long as you don't think about constants

[22:06] <gfldex> r: my constant $i = 10; $i = 20;

[22:06] <p6eval> rakudo aeca2f: OUTPUT«Cannot assign to a non-container␤  in block <anon> at /tmp/FOo8j5aHlg:1␤␤»

[22:06] <Araq> hm yeah well, variable as opposed to "routine" perhaps

[22:07] <Araq> r: my $x = sub { 0 }; $x();

[22:07] <p6eval> rakudo aeca2f:  ( no output )

[22:07] <diakopter> variables can hold routines!

[22:08] <Araq> ok so it basically means nothing at all :-)

[22:08] <diakopter> it just means container

[22:09] <gfldex> it means: hey compiler, here comes a name that is no the name of a function. You don't really need to bother what that name is unless you want to give me an error message.

[22:09] <diakopter> but all the other sigils mean that too!!!!!!!!

[22:09] <diakopter> except &, which means a function.

[22:10] <gfldex> and if you really want to confuse yourself you have a look at: http://perlcabal.org/syn/S06.html#Parcel_binding

[22:10] <diakopter> Araq: don't listen to gfldex's function-vs-nonfunction distinction. the only sigil that has anything to do with that is &.

[22:10] <gfldex> hmm, i would say & means: here comes a function name that i don't want you to execute

[22:11] <diakopter> that's wrong

[22:11] <diakopter> niecza: my &a = sub { say 'b' }; &a()

[22:11] <p6eval> niecza v17-4-ge5b869e: OUTPUT«b␤»

[22:12] <gfldex> it's wrong when it comes after my or our

[22:12] <gfldex> r: sub f(){}; &f;

[22:12] <p6eval> rakudo aeca2f:  ( no output )

[22:13] <gfldex> see: i told the compiler to not call a function by giving it's name

[22:13] <gfldex> & got context or you can think of it as actually two different things with the same name

[22:14] <gfldex> p6: sub foo(\x, \y) { x = y; }

[22:14] <p6eval> pugs: OUTPUT«*** ␤    Unexpected "\\"␤    expecting formal parameter or ")"␤    at /tmp/glWJqcAwYQ line 1, column 9␤»

[22:14] <p6eval> ..rakudo aeca2f: OUTPUT«===SORRY!===␤Malformed parameter␤at /tmp/uxMnlJ_Lq0:1␤»

[22:14] <p6eval> ..niecza v17-4-ge5b869e: OUTPUT«Potential difficulties:␤  &foo is declared but not used at /tmp/_bEe5u4pi2 line 1:␤------> sub foo⏏(\x, \y) { x = y; }␤␤»

[22:15] <gfldex> n: sub foo(\x, \y) { x = y; } my $a; my $b = 42; foo($a, $b); say $a;

[22:15] <p6eval> niecza v17-4-ge5b869e: OUTPUT«===SORRY!===␤␤Strange text after block (missing comma, semicolon, comment marker?) at /tmp/8OgELI_euI line 1:␤------> sub foo(\x, \y) { x = y; }⏏ my $a; my $b = 42; foo($a, $b); say $a;␤␤Parse failed␤␤»

[22:15] <gfldex> n: sub foo(\x, \y) { x = y; }; my $a; my $b = 42; foo($a, $b); say $a;

[22:15] <p6eval> niecza v17-4-ge5b869e: OUTPUT«42␤»

[22:15] <gfldex> niecza++

[22:16] <gfldex> i would really like to know what parcel binding is for

[22:16] <gfldex> beside confusing folk :)

[22:16] <Araq> so if perl6 tries to adhere to huffman encoding, why all the pointless $ ? how do they aid readability given they do not even describe any constraint/interface/role?

[22:17] <diakopter> Araq: what are you suggesting instead? no sigil at all?

[22:17] <gfldex> r: my $a = 42; sub f(){}; f $a; f $a; f $a;

[22:17] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'f' will never work with argument types (Mu) (lines 1, 1, 1)␤    Expected: :()␤»

[22:17] * sorear pokes TimToady

[22:17] <Araq> diakopter: yes

[22:17] <sorear> to be honest I've had the same thought

[22:17] <gfldex> r: my $a = 42; sub f(){}; f($a); f($a); f($a);

[22:17] <p6eval> rakudo aeca2f: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'f' will never work with argument types (Mu) (lines 1, 1, 1)␤    Expected: :()␤»

[22:18] <sorear> but ditching sigils in Perl ain't never gonna happen

[22:18] <sorear> especially now that perl 6 is quasi-stabilized

[22:18] <gfldex> it makes it easer to leave () home and allowes for string interpolation

[22:19] <gfldex> fprint is nice if you use the advanced stuff but for easy stuff sigil powered interpolation is much easer to read

[22:19] <gfldex> and at least for me, starting nouns with a capital helps with readability too

[22:19] <Araq> but you can easily have "$foo" in strings and foo without the $ everywhere else

[22:20] <gfldex> you could do that but i would not bet on better readability

[22:20] <gfldex> the human mind is a funky thing :)

[22:20] *** dom96 joined
[22:20] <gfldex> and sigils give you another name space

[22:21] <gfldex> if you have more then one sigil you get even multiple namespaces

[22:21] <Araq> what about type-ability? typing $ requires a shift on a german keyboard ...

[22:21] <spider-mario> so does % on an azerty keyboard

[22:21] <gfldex> that depends on your keyboard mapping

[22:21] <spider-mario> @ requires Alt Gr

[22:22] <spider-mario> fortunately for me, I don’t use azerty :)

[22:22] <gfldex> you could have food pedals that map to $ % @

[22:22] <Araq> indeed the other sigils are no better in this respect

[22:22] <gfldex> and i'm not kidding, you can buy that stuff and stick it into a USB port

[22:22] <spider-mario> I use bépo

[22:22] <spider-mario> http://bepo.fr/

[22:22] *** havenn joined
[22:23] <spider-mario> funny how $ is at the far left, @ in the middle and % at the right of the layout

[22:23] <spider-mario> it might be on purpose

[22:23] <Araq> but then why should I? a $redudant $letter $hardly $helps $readability $anyway

[22:24] <Araq> you know, I'd say it hurts much more than it helps

[22:24] <Araq> my sentences don't improve with $, do they?

[22:24] <diakopter> perl marks nouns with sigils, not every word

[22:25] <Araq> a so 'class' is no noun? :P

[22:25] *** benabik left
[22:25] <diakopter> class is a keyword, reserved

[22:25] <Araq> I know

[22:25] <sorear> Araq: US keyboard require shift for all of $, @, %, and &

[22:26] <sorear> diakopter: Araq means classes like Int, Num...

[22:26] <Araq> no I meant the keyword

[22:26] <Araq> but Int and Str are good examples too :-)

[22:26] *** NamelessTee left
[22:28] *** xinming joined
[22:28] <gfldex> Araq: this keyboard could releave you from pressing shift ever again: http://www.alternate.de/p/450x450/n/Roccat_Valo_Gaming_Keyboard@@ntzr90.png

[22:29] <gfldex> 44 extra keys :)

[22:29] *** pomysl_ left
[22:30] <spider-mario> yuck

[22:30] <spider-mario> I’d rather press shift

[22:30] *** pomysl joined
[22:30] *** pomysl left
[22:30] *** pomysl joined
[22:30] <sergot> 'night o/

[22:30] *** sergot left
[22:31] <Araq> indeed that's nice but then people may compare Perl6 to -say- Python and come to the conclusion that they don't need new keyboards to program in Python ... ;-)

[22:31] <Araq> what would you say to these people? :-)

[22:32] <tadzik> "Grow your 5th fingers" ;)

[22:32] <spider-mario> :D

[22:32] <gfldex> i would say to them that they should subclass Perl6 (what is a grammar) and solve their problem

[22:32] <diakopter> they are silly to insist on typing with Shift key.

[22:32] <diakopter> without.

[22:32] <dalek> tablets: 4fcad8b | (Herbert Breunung)++ | docs/appendix-g-glossary.txt:

[22:32] <dalek> tablets: minest fixes

[22:32] <dalek> tablets: review: https://github.com/perl6/tablets/commit/4fcad8b284

[22:33] <timotimo> spider-mario: i use http://neo-layout.org/ - extra-special keyboard layout users of the world unite!

[22:33] <diakopter> that's like saying, I won't use a language where capital letters are necessary.

[22:33] <gfldex> what would the world be without the sensation to hold down a key and see all those little metal stomps move up a bit

[22:33] <tadzik> huh, that's even weirder than my Colemak :)

[22:33] <sorear> DECLARE X AS INTEGER COMPUTATIONAL;

[22:33] <gfldex> diakopter: err, there are plenty of germans who refuse to use capitals

[22:34] <diakopter> probably not out of laziness

[22:34] <timotimo> colemak and dvorak are way too mainstream nowadays

[22:34] <spider-mario> timotimo : that looks like the german equivalent of dvorak, bépo, and others

[22:34] <spider-mario> can it be described that way?

[22:34] <Araq> in fact, it's like saying "I won't use a language with ALLCAPS keywords"

[22:34] <Araq> and indeed nobody uses Modula 2 and 3 ... nor Oberon

[22:34] <timotimo> neo is optimised for german, english, programming, shell usage. dunno if that's the same for bepo. i think it isn't for dvorak

[22:35] <timotimo> also for mathematics. it has greek letters and mathematical symbols easily accessible

[22:35] <spider-mario> hm, bépo is not really optimized for english and programming

[22:35] <Araq> there may be other reasons for that but allcaps keywords certainly don't help

[22:35] <spider-mario> it’s mainly for writing french

[22:35] <sorear> C has plenty of all-caps 'keywords' but people use it

[22:36] <spider-mario> return EXIT_SUCCESS;

[22:36] <Araq> no keyword :P

[22:36] <spider-mario> there’s CHAR_BIT as well

[22:36] <spider-mario> and others

[22:36] <tadzik> really, people use EXIT_SUCCESS? :P

[22:36] <spider-mario> I do

[22:36] <tadzik> okay

[22:36] <spider-mario> even in C++, I include <cstdlib> to have it. :D

[22:37] <diakopter> Araq: as sorear said, Perl won't make sigils optional, if only to maintain some level of historical consistency.

[22:37] <tadzik> I like sigils, and even for readability reasons

[22:37] <gfldex> i like sigils for the little bit of extra meaning that @ % get me opposed to $

[22:38] <tadzik> good knight #perl6

[22:38] <gfldex> but then i can count only like that: one thing, many things, things with names

[22:38] * araujo greets

[22:38] <spider-mario> I use & as well

[22:39] <spider-mario> but that may come from my use of functional programming languages

[22:39] <spider-mario> I like higher-order functions

[22:39] <timotimo> spider-mario: does bepo or colemak or something 

[22:39] <timotimo> ... have something like neos layers?

[22:40] <spider-mario> I’m not sure what it is

[22:40] <timotimo> because neo2 has a modifier for each layer on both sides and you can hold both to lock those

[22:40] <timotimo> mouse over "ebene 3, and "ebene 4" in the image on neo-layout.org

[22:40] <Araq> good night

[22:40] <spider-mario> ok

[22:40] <spider-mario> then, sort of

[22:40] <sorear> 'night Araq

[22:40] *** Araq left
[22:40] <spider-mario> there are shift and Alt Gr as modifiers

[22:40] <spider-mario> both can be pressed at the same time

[22:41] <spider-mario> but that makes only 4 layers

[22:41] <spider-mario> http://download.tuxfamily.org/dvorak/wiki/images/Carte-bepo-complete.png

[22:42] *** alim joined
[22:42] *** dom96 left
[22:42] <timotimo> bleh, the brackets and parens are in uncomfortable places, as well as the angular brackets :\

[22:43] <spider-mario> that’s one criticism sometimes made

[22:43] <timotimo> much like the original german layout actually, have you seen that? it's crazy. the curly braces are altgr + 7 and 0

[22:43] <timotimo> gotta run, catch some sleep now. good night!

[22:43] <spider-mario> in azerty, it’s 4 and + (far right)

[22:44] <spider-mario> good night

[22:44] <spider-mario> (and Alt Gr, actually)

[22:44] <spider-mario> Alt Gr + 4, Alt Gr + far right

[22:45] <spider-mario> .U 😒

[22:45] <spider-mario> hm, that’s two characters

[22:45] <spider-mario> well, no

[22:45] <spider-mario> .u 😒

[22:45] <phenny> U+1F612 (No name found)

[22:45] *** Entonian joined
[22:47] *** alim left
[22:48] *** NamelessTee joined
[22:53] *** mikemol left
[22:55] <spider-mario> .u 𝄞

[22:55] <phenny> U+1D11E MUSICAL SYMBOL G CLEF (𝄞)

[22:57] <spider-mario> !seen spider-mario

[22:57] <spider-mario> .seen spider-mario

[22:57] <phenny> spider-mario: I last saw spider-mario at 2012-05-13 22:57:03 UTC on #perl6

[22:58] *** spider-mario left
[22:59] *** spider-mario joined
[23:02] <tadzik> hmm, that's interesting

[23:03] <tadzik> phenny: seen spider-mario?

[23:03] <tadzik> phenny: seen spider-mario

[23:03] <tadzik> hmm, I thought it worked that way

[23:03] <tadzik> aloha: seen spider-mario?

[23:03] <aloha> tadzik: spider-mario was last seen in #perl6 4 mins 6 seconds ago joining the channel.

[23:03] <spider-mario> there’s a dot

[23:03] <tadzik> there we are

[23:03] <spider-mario> .seen tadzik

[23:03] <phenny> spider-mario: I last saw tadzik at 2012-05-13 23:03:30 UTC on #perl6

[23:03] <tadzik> yeah, it's just that I remembered output to be different

[23:03] <spider-mario> oh

[23:03] <tadzik> and that was because we have two bots :)

[23:03] <spider-mario> I didn’t see that :D

[23:07] *** spider-mario left
[23:11] *** NamelessTee left
[23:11] *** Entonian left
[23:33] *** thelazydeveloper left
[23:37] *** eternaleye left
[23:38] *** eternaleye joined
[23:39] *** az5112 left
[23:48] *** s1n joined
