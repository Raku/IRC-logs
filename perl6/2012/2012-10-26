[00:02] *** armitage81 joined
[00:02] *** armitage81 left
[00:02] *** armitage81 joined
[00:05] *** armitage81 left
[00:06] *** armitage81 joined
[00:09] *** adu left
[00:10] *** fgomez left
[00:10] <diakopter> erm

[00:10] <diakopter> rn: say 'alive'

[00:11] <diakopter> ...

[00:11] <p6eval> rakudo 3619d7, niecza v22-14-g136ddcf: OUTPUT«alive␤»

[00:30] *** bbkr_ left
[00:31] *** snearch joined
[00:33] *** bbkr_ joined
[00:36] *** fgomez joined
[00:59] *** benabik joined
[00:59] *** anuby joined
[01:00] *** arlinius left
[01:11] <diakopter> benabik: what's your Dr. topic? anything interesting to #perl6 ?

[01:11] *** fgomez left
[01:15] *** snearch left
[01:19] *** armitage81 left
[01:26] *** fgomez joined
[01:27] <[Coke]> http://www.shamusyoung.com/twentysidedtale/?p=17585 - nice article about programming from a video game POV, dealing with bugs, complexity, and user's inability to trust what the developer's done.

[01:31] *** armitage81 joined
[01:32] <benabik> diakopter: Not yet decided.  I am currently in the compiler research group, so maybe.

[01:32] *** armitage81 left
[01:43] *** Alpha64 joined
[02:12] *** bapa left
[02:18] *** am0c joined
[02:22] *** MikeFair joined
[02:23] *** orafu left
[02:27] *** orafu joined
[03:00] *** adu joined
[03:26] *** rafl left
[03:26] *** rafl joined
[03:31] *** am0c left
[03:42] *** Entonian joined
[03:42] *** Entonian left
[03:45] *** kaleem joined
[03:46] <diakopter> benabik: do you have an interest in JITs?

[03:47] <benabik> diakopter: Some, although I haven't poked at it much.

[03:47] *** tokuhiro_ left
[03:57] <benabik> diakopter: vmkit is interesting, but I wasn't terribly impressed by the GC: Use a java-based system by translating it to native code by our own custom Java VM.

[03:57] <benabik> diakopter: But I'm heading to bed now.

[03:59] <diakopter> o/

[04:03] *** shmup left
[04:07] *** thou left
[04:15] *** bluescreen10 joined
[04:17] *** fgomez left
[04:18] *** fgomez joined
[04:31] *** telex left
[04:36] *** fgomez left
[04:36] *** telex joined
[04:37] *** adu left
[04:43] *** fgomez joined
[04:54] *** cognominal joined
[04:58] *** cognominal left
[05:00] *** dayangkun left
[05:04] *** cognominal joined
[05:05] *** cognominal left
[05:06] *** cognominal joined
[05:21] *** cognominal left
[05:32] *** cognominal joined
[05:32] *** colomon left
[05:32] *** am0c joined
[05:34] *** bluescreen10 left
[05:36] *** Alpha64 left
[05:36] *** cognominal left
[05:37] *** Alpha64 joined
[05:37] *** Alpha64 left
[05:37] *** cognominal joined
[05:44] *** GlitchMr joined
[05:49] *** hash_table left
[05:56] <cognominal> rn:  say (1 => 2).key.WHAT

[05:56] <p6eval> rakudo 3619d7, niecza v22-14-g136ddcf: OUTPUT«Int()␤»

[05:57] <cognominal> That is what is expected but .fatarrow is defined as          make make_pair($<key>.Str, $<val>.ast);     How come the key is not stringified?

[06:02] *** colomon joined
[06:12] *** cognominal_ joined
[06:14] *** cognominal left
[06:16] *** azawawi joined
[06:17] <azawawi> hi

[06:17] <phenny> azawawi: 25 Oct 06:05Z <tadzik> tell azawawi indeed, fixed now. Strange thing though :)

[06:17] <azawawi> tadzik: thx

[06:17] <azawawi> tadzik++

[06:17] *** skids left
[06:26] *** VXZ left
[06:28] <azawawi> what environment variables does perl6 rakudo use besides PERL6LIB? Any documentation on that?

[06:29] <azawawi> Just to make my question a bit clearer; are there any shared environment variables besides PERL6LIB between perl6 implementations? 

[06:30] <sorear> r and n both explicitly use $HOME

[06:31] <azawawi> sorear: hi

[06:32] <azawawi> sorear:  i was wondering how to detect different perl6 runtimes inside Farabi6

[06:32] <azawawi> sorear: that's what i asked about shared env variables (if any)

[06:32] <sorear> rn: say $*PERL // $?PERL

[06:32] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤Variable $?PERL is not declared␤at /tmp/RApncUw9FG:1␤»

[06:32] <p6eval> ..niecza v22-14-g136ddcf: OUTPUT«{"build-time" => 1350511210.0345931e0, "name" => "niecza", "version" => "v22-14-g136ddcf"}␤»

[06:32] <sorear> rn: say $*PERL // eval '$?PERL'

[06:32] <p6eval> niecza v22-14-g136ddcf: OUTPUT«{"build-time" => 1350511210.0345931e0, "name" => "niecza", "version" => "v22-14-g136ddcf"}␤»

[06:32] <p6eval> ..rakudo 3619d7: OUTPUT«("name" => "rakudo", "compiler" => {"name" => "rakudo", "ver" => "2012.10-30-g3619d77", "release-number" => "", "build-date" => "2012-10-25T22:09:21Z", "codename" => ""}).hash␤»

[06:34] <azawawi> is there a webservice like this IRC bot that i can utilize for running snippets inside Farabi6?

[06:34] <sorear> there used to be try.rakudo.org

[06:35] <sorear> right now I think your best bet is perlito

[06:35] <sorear> phenny: "farabi"?

[06:35] <phenny> sorear: "farabi" (tr to en, translate.google.com)

[06:35] <sorear> phenny: ar en "farabi"?

[06:35] <phenny> sorear: "farabi" (ar to en, translate.google.com)

[06:36] <sorear> phenny: il en "farabi"?

[06:36] <phenny> sorear: "farabi" (tr to en, translate.google.com)

[06:36] <azawawi> i will try running farabi under niecza also

[06:36] <sorear> phenny: he en "farabi"?

[06:36] <phenny> sorear: "farabi" (iw to en, translate.google.com)

[06:37] <azawawi> sorear: https://metacpan.org/module/Farabi

[06:39] <sorear> aha

[06:39] * azawawi tries niecza 

[06:40] *** fgomez left
[06:40] *** raiph joined
[06:42] *** cognominal_ left
[06:46] *** kurahaupo left
[06:47] *** marloshouse left
[06:48] *** domidumont joined
[06:48] *** fgomez joined
[06:56] *** dayangkun joined
[07:02] *** kurahaupo joined
[07:02] *** azawawi left
[07:03] *** brrt joined
[07:03] *** domidumont left
[07:03] *** domidumont joined
[07:05] *** flightrecorder joined
[07:05] *** birdwindupbird joined
[07:09] *** hoelzro|away is now known as hoelzro

[07:10] *** kurahaupo left
[07:15] *** FROGGS joined
[07:23] *** kurahaupo joined
[07:29] *** kresike joined
[07:29] <kresike> good morning all you happy perl6 people

[07:37] <brrt> \o kresike

[07:38] <kresike> brrt, o/

[07:40] *** the-golem joined
[07:40] <the-golem> moritz: ping

[07:44] <sorear> o/

[07:44] <colomon> \o

[07:44] *** sjohnson left
[07:44] *** sjohnson joined
[07:45] <sjohnson> -o-

[07:47] *** marloshouse joined
[07:49] <the-golem> \o/

[07:49] <brrt> everybody awake?

[07:50] <hoelzro> \o/

[07:50] <brrt> now dance

[07:50] <brrt> \o 

[07:50] <brrt> o/

[07:50] *** mars__ joined
[07:50] <the-golem> o\

[07:55] <FROGGS> _o_

[07:55] <FROGGS> \o\

[07:55] <FROGGS>  /o/

[07:55] <FROGGS> morning

[07:56] *** kurahaupo left
[08:00] <moritz> |o|

[08:00] <FROGGS> ohh, the mechanical

[08:01] <FROGGS> \o_ <-- saturday night fever

[08:03] *** am0c left
[08:03] *** am0c joined
[08:04] *** fgomez left
[08:17] *** daniel-s_ left
[08:19] *** domidumont left
[08:22] *** domidumont joined
[08:24] *** fgomez joined
[08:38] *** telex left
[08:39] *** telex joined
[08:43] <colomon> [o]

[08:44] <jnthn> morning o/

[08:44] <FROGGS> hi

[08:46] <FROGGS> macarena ->   =o   o=   /o\   --o--

[08:47] <sorear> ō̱

[08:48] <jnthn> .oO( it's easy to backlog when it's mostly ascii-art dancing :D )

[08:49] <jnthn> phenny: tell [Coke] nqp only pays attention to types in signatures when it's a multi sub or multi method, or when it's int/num/str in which case it uses a native lexical to store the parameter.

[08:49] <phenny> jnthn: I'll pass that on when [Coke] is around.

[08:55] *** GlitchMr left
[08:56] *** kresike left
[08:59] *** kresike joined
[09:17] *** CharellKing joined
[09:34] *** kaleem left
[09:37] *** dayangkun left
[09:56] <dalek> perl6-examples: 57bdd7d | (Gerhard R)++ | euler/prob029-gerdr.pl:

[09:56] <dalek> perl6-examples: [euler/prob029] modify algorithm

[09:56] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/57bdd7df6b

[09:56] <dalek> perl6-examples: 1e2d228 | (Gerhard R)++ | euler/prob029-gerdr.pl:

[09:56] <dalek> perl6-examples: [euler/prob029] add version using feeds

[09:56] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/1e2d22899f

[09:59] *** hoelzro is now known as hoelzro|away

[10:00] <masak> good mroing, #perl6

[10:01] <brrt> \o masak

[10:02] *** mars__ left
[10:02] <CharellKing> good afternoon

[10:03] <jnthn> good moonring, masak

[10:05] *** CharellKing left
[10:06] *** domidumont left
[10:06] *** domidumont joined
[10:08] <arnsholt> :q

[10:08] * hugme hugs arnsholt, good vi(m) user!

[10:08] <phenny> hugme: 05 Oct 17:31Z <sjohnson> tell hugme to fulfill its hugging quota

[10:08] *** anuby left
[10:08] *** not_gerd joined
[10:08] <not_gerd> hello, #perl6

[10:09] <masak> phenny: tell cognominal keys are not stringified in pairs. if they were, pairs would be a bad fit for hashes that didn't coerce their keys to strings.

[10:09] <phenny> masak: I'll pass that on when cognominal is around.

[10:09] * not_gerd having fun with project euler and perl6

[10:09] <not_gerd> r: (-> \A, \B = A { 2..Int(sqrt A) ==> map -> \a { (a, a**2, a**3 ...^ * > A) Z=> (a X 1..*).tree } ==> reverse() ==> hash() ==> values() ==> (-> @a, @b { @a X @b })(2..B) ==> map -> \n, [\r, \e] { (r) => e * n } ==> (-> @a { @a - @a.uniq })() ==> ((A - 1) * (B - 1) - *)() })(100).say

[10:09] <p6eval> rakudo 3619d7: OUTPUT«9183␤»

[10:09] <masak> ooh

[10:11] * not_gerd let's try for timeout

[10:11] <not_gerd> r: +(2..100 X=> 2..100).classify({ .key ** .value }).say

[10:11] <p6eval> rakudo 3619d7: OUTPUT«(timeout)»

[10:11] <not_gerd> ;)

[10:11] *** hoelzro|away is now known as hoelzro

[10:12] <not_gerd> r: say +(2..100 X=> 2..100).classify({ .key ** .value })

[10:13] <p6eval> rakudo 3619d7: OUTPUT«(timeout)»

[10:13] <FROGGS> r: my @a = 0..9,3,5,8; @a -= @a.uniq; @a.say

[10:13] <p6eval> rakudo 3619d7: OUTPUT«3␤»

[10:14] <FROGGS> ^--- why not 3 5 8 ?

[10:14] <tadzik> well, er

[10:14] <tadzik> r: my @a = 0..9,3,5,8; say +@a; say +@a.uniq

[10:14] <p6eval> rakudo 3619d7: OUTPUT«13␤10␤»

[10:15] <tadzik> you substracted those 2

[10:15] <FROGGS> so it is not like array a complement array b ?

[10:16] <tadzik> infix:<-> numifies both arrays, and gives back a Numeric

[10:16] <tadzik> (I guses)

[10:16] <FROGGS> r: my @a = 0..9,3,5,8; @a -= 1; @a.say

[10:16] <p6eval> rakudo 3619d7: OUTPUT«12␤»

[10:16] <FROGGS> k

[10:18] <not_gerd> r:  set(0..9,6..12).say

[10:18] <p6eval> rakudo 3619d7: OUTPUT«set(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)␤»

[10:21] *** bapa joined
[10:24] <masak> FROGGS: the thinko you're making is assuming infix:<-> ever means "set subtraction". it doesn't -- it always means numeric subtraction.

[10:25] <masak> (unless you redefine it against the core principles of Perl)

[10:25] <masak> Perl is operator-based, that is, a lot of the type information can be found in the choice of operator. when you see +-*/, you know it's about numbers.

[10:29] *** bbkr_ left
[10:29] <FROGGS> ya, I just thought there is some special magic about +- on array when I saw not_gerd's "... (-> @a { @a - @a.uniq })() ..."

[10:35] *** brrt left
[10:35] *** azawawi joined
[10:36] *** MayDaniel joined
[10:38] <masak> no, arithmetic operators always numify their operands before arithmeting on them.

[10:39] *** SamuraiJack joined
[10:40] <masak> similarly, if you do prefix:<!> on an array, it will be boolified before it's negated.

[10:41] <masak> and if you do infix:<~> on two things, the two things will be stringified before being concatenated.

[10:41] *** azawawi left
[10:44] <not_gerd> bye, #perl6

[10:44] *** not_gerd left
[10:45] <masak> fare thyself well, not_gerd.

[10:57] *** dayangkun joined
[10:58] *** dayangkun left
[10:58] *** dayangkun joined
[11:05] *** Su-Shee_ joined
[11:06] *** Su-Shee left
[11:06] *** Su-Shee_ is now known as Su-Shee

[11:11] *** kijanka joined
[11:13] *** brrt joined
[11:24] *** rindolf joined
[11:27] *** fgomez left
[11:32] *** GlitchMr joined
[11:42] *** fgomez joined
[11:48] *** colomon left
[12:04] *** sqirrel joined
[12:21] *** jaldhar left
[12:22] <masak> heh. http://en.wikipedia.org/wiki/Poes_law -- "Any sufficiently advanced parody is indistinguishable from a genuine kook." :)

[12:22] <masak> partly this is built into irony and sarcasm, I guess. they thrive on the uncertainty of the actual viewpoint.

[12:23] <masak> but the low bandwidth of text only serves to make the signal harder to pick up in the noise.

[12:32] * moritz tries hard to refrain from saying "Oh really?"

[12:32] * moritz fails

[12:32] <jnthn> YA RLY

[12:34] <masak> moritz: wait, I'm confused. did you really mean to be sarcastic there, or are you actually questioning the premise?

[12:34] <masak> (that was sacrasm, by the way. just so you know.)

[12:35] <masak> how many levels up are we now? three? four? dang.

[12:38] *** flightrecorder left
[12:38] *** FROGGS left
[12:38] <moritz> we don't need to know the exact count, as long as we know if it's even or odd :-)

[12:39] <brrt> are you suggesting that sarcasm negates?

[12:39] <masak> no!

[12:40] * masak .oO( odd-length sarcasm circularity detected. your sarcasm has fallen victim to paradoxical undecidability. )

[12:47] *** hash_table joined
[12:52] *** brrt left
[12:54] <eiro> hello

[12:54] <moritz> eiro/

[12:55] <eiro> http://doc.perl6.org/type/IO doesn't contain slurp method, open() returns an IO and can be slurped 

[12:55] <eiro> how is it so ? 

[12:56] <masak> eir\o

[12:56] <eiro> hello moritz! thanks for replying on the list :) i haven't answered yet. i will. (i'm trying to figure out how to use named captures of the match)

[12:57] <eiro> i'm trying to find the simplest way to save an array in a file (1 element by line) 

[13:01] <moritz> what are the elements?

[13:04] *** adu joined
[13:04] <eiro> just strings. i'm trying somehting like open('foo',:w).lines(@foo) 

[13:04] *** Psyche^ joined
[13:04] <eiro> i meant i wish it would be so simple

[13:05] <eiro> but as i said: open returns an IO and i don't see slurp in the IO doc so i'm confused

[13:05] <moritz> my $f = open('foo', :w); $f.say($_) for @lines; $f.close;

[13:06] <moritz> @lines = 'foo'.IO.slurp.lines; # reading back

[13:06] <moritz> or for writing:

[13:06] <moritz> spurt 'foo', join '', @lines.map: * ~ "\n";

[13:06] <eiro> moritz, that's quiet long when you're used to IO::All

[13:07] <eiro> spurt ? /me search the doc

[13:07] *** Patterner left
[13:07] *** Psyche^ is now known as Patterner

[13:09] <masak> spurt is quite new, mostly because it took us forever to arrive on a non-gross name for it.

[13:11] *** brrt joined
[13:12] <eiro> spurt "/tmp/foozzzzzzzzzzzz"

[13:12] <eiro> , @foo.join("\n")

[13:12] <eiro> , :append;

[13:13] <eiro> :-) fine! that's not as short as io('') but it's ok

[13:13] <eiro> IO::All could be nice in perl6

[13:13] *** cognominal joined
[13:13] <eiro> hello cognominal 

[13:13] <masak> eiro: putting the commas like that makes me think of http://blog.urth.org/2012/10/please-dont-write-snowflake-code.html

[13:14] <masak> eiro: do you agree that it's common practice to put commas before the linebreak, not after?

[13:14] <eiro> masak, i have strong ideas on it: postfixed , sucks :)

[13:14] <masak> eiro: right, but do you agree about the common practice?

[13:14] <[Coke]> I could not disagree with the gentleman across the aisle more.

[13:14] <phenny> [Coke]: 08:49Z <jnthn> tell [Coke] nqp only pays attention to types in signatures when it's a multi sub or multi method, or when it's int/num/str in which case it uses a native lexical to store the parameter.

[13:14] <masak> [Coke]: yay, an enlightened discussion! :)

[13:15] <eiro> mostly by habits and not thinking about it but yes 

[13:15] <masak> I'm thinking about it right now.

[13:15] <cognominal> hi, eiro

[13:15] <phenny> cognominal: 10:09Z <masak> tell cognominal keys are not stringified in pairs. if they were, pairs would be a bad fit for hashes that didn't coerce their keys to strings.

[13:15] <masak> I sill prefer comma-before-linebreak.

[13:15] <eiro> masak, bugs are much easier to catch, lines to continues, tabs to save when you prefix with ,

[13:17] <masak> please take me through that argument step by step. when it's summarized like that, I don't buy it.

[13:17] <eiro> masak, it was a coding style in a former employer and i hated it first. then i wondered why the company code was easier to debug than mine. i realized that the prefixed style was one of the reasons 

[13:17] *** hash_table left
[13:17] <masak> I'm future-proofing my comma code, too. I do it by adding a trailing comma to the last element when I can.

[13:17] *** gootle joined
[13:17] <eiro> sure: step 1 (i made the experience with many coworkers)

[13:18] <masak> that way, I can re-order my items freely.

[13:18] <eiro> my @foo = (

[13:18] <masak> with your style, the first line is special.

[13:18] <eiro>   'a',

[13:18] <eiro>   'b',

[13:18] <eiro>   'c',

[13:18] <eiro> ), 

[13:18] <eiro> show it, show that compiles. he'll say "ok"

[13:19] <masak> I've never made that error, or seen it made by someone else.

[13:19] <eiro> now make him watch out, remove a trailing , and recompile 

[13:19] <masak> or did you really mean ');' ?

[13:19] <eiro> "bang! where is the bug?" : he'll take some times to catch it 

[13:19] <eiro> same experience with

[13:19] <eiro> @foo =

[13:19] <eiro> ( 'a'

[13:19] <masak> I'm all for putting in the trailing comma. I do that, too.

[13:20] <eiro> , 'b'

[13:20] <eiro> 'c'

[13:20] <eiro> ); 

[13:20] <eiro> the error is now obvious 

[13:20] <moritz> I doo that too,

[13:20] <masak> moritz: :P

[13:20] <masak> eiro: this does not convince me.

[13:21] <masak> eiro: I put trailing commas in. the code is now such that I can move whole lines around without breaking the code. that is enough.

[13:21] <eiro> masak, arf ...

[13:21] <masak> eiro: want me to gist you an example?

[13:21] <masak> oh wait, my style is like the 'my @foo = (' example you pasted above. never mind.

[13:21] <masak> except I usually end the statement with a semicolon :P

[13:22] <eiro> masak, this is a long discution! i'll be delighted to show you some stupid bugs seen because of it but i have no time. will yuou join fosdem ?

[13:22] <masak> heh :)

[13:22] <masak> the conference or the IRC channel?

[13:22] <flussence> .oO( I usually use qw() to avoid all that... )

[13:22] <eiro> (because i really would like to expose my thoughts about it)

[13:22] <masak> flussence: indeed. I do that when applicable.

[13:23] <brrt> in javascript, ie6 thinks having a trainling comma is an error in an object literal

[13:23] <brrt> only ie6 thinks so

[13:23] <brrt> that, my friend, is a nice source of bugs

[13:23] <masak> eiro: I'd like to continue listen to your thoughts about it. I think it looks really ugly, but some practical advantage might help. still haven't seen the practical advantage.

[13:23] <eiro> i remember a funny bug when mixing missing , and minus prefixed key

[13:23] <masak> eiro: maybe the different is that copy whole lines? as long as I do that, no bugs.

[13:23] <eiro> (because minus becomes the - operator)

[13:23] <masak> or rather, no comma-related surprises.

[13:24] <masak> eiro: your style makes the first line special.

[13:24] <brrt> and, i now sql server management studio (ms tool) does it in eiro's style too

[13:24] <flussence> brrt: IE6 is actually right in that case. You'll get a warning about it if you use firebug with strict mode enabled.

[13:24] <brrt> honestly?

[13:24] <brrt> i haven't seen it in /any/ other browser

[13:24] <brrt> and, i think the other behavior is useful

[13:24] <cognominal> too bad, TimToady does not own the semicolon and the comma. He would save us endless discussion

[13:24] <flussence> it's pedantic and useless correctness, but it *is* following spec

[13:25] <masak> brrt: trailing commas aren't allowed in JavaScript object literals (or arrays).

[13:25] <flussence> (for a change...)

[13:25] <moritz> JSON and SQL don't allow trailing commas :(

[13:25] <masak> was just gonna say :(

[13:25] *** gootle left
[13:25] <masak> C allows it, IIRC.

[13:25] <masak> it's a nice kind of laxness that really helps sometimes.

[13:25] <brrt> i can see how it makes parsing - a bit - harder

[13:26] <eiro> masak, ok: kivutar and me are writing an experimental static blog engine in perl6. my first blog post will be for you. ok ?

[13:26] * eiro copy paste the chatlog

[13:26] *** flightrecorder joined
[13:26] <masak> eiro: :D

[13:27] *** fgomez left
[13:27] * eiro need to set the engine up: almost working and kivutar is leaving soon so i want to finish it 

[13:27] <eiro> back to the code

[13:27] <masak> eiro: sorry if I come off as obtuse. the style is so ugly I was sure you had some good reason for preferring it. I just wanted to know if I could understand that reason. so far, no.

[13:28] <masak> [Coke]: and you -- did you just disagree for the sake of it, or did you have something more to say? :)

[13:30] <eiro> masak, as i said: i have to explain it. hope it will not be as slow as accept it as a best practice i saw 

[13:31] <masak> I doubt I'll change my style, but I'll keep an open mind.

[13:31] <eiro> is there a way to pipe an array to a command ? (ipc open3) easily ? 

[13:32] <eiro> i doubt too but you asked me, this is a good thing to share (even if it's wrong) and it's a good idea for your engine 

[13:33] <masak> *nod*

[13:36] *** leont joined
[13:37] *** leont left
[13:39] <eiro> any project of syntax hilighter in perl6? this would be a usefull show off of grammars ?

[13:39] <hoelzro> eiro: I was thinking of adding it to linguist and pygments

[13:40] <moritz> hoelzro: that's syntax hilighters *for* Perl 6, not *in* Perl 6

[13:40] <the-golem> moritz: hi :-)

[13:41] <eiro> hoelzro, i meant: we're using pygments to highlight our codes ( zsh, perl5, perl6 ) in the blog posts. it would be great to have perl6 modules for that 

[13:41] <hoelzro> oh, ok =)

[13:43] <masak> I would like to see a good, solid syntax highlighter written in Perl 6. one that preferably didn't pull in a whole parser of the Perl 6 language.

[13:44] <eiro> sure ... for the moment i'm just stuggle with the basics. ask cognominal :) 

[13:45] <masak> it's an interesting question how close a highlighter that just did lexing would come to doing things "right".

[13:45] <masak> most highlighters just do lexing, or mostly lexing, I think.

[13:46] *** jlaire left
[13:52] *** jlaire joined
[13:52] <cognominal> masak, problem is that Perl 6 lexing use context from the parser

[13:53] <flussence> I guess the job's a lot easier if you ignore things like user-defined syntax

[13:53] <masak> cognominal: indeed.

[13:53] <flussence> (but even with that, p5 still manages to make it hard...)

[13:53] <masak> cognominal: so does Perl 5 lexing.

[13:54] <cognominal> and syntax highlighter is a (common) misnomer if what you do is just hiliting tokens

[13:54] <[Coke]> masak: I very much dislike that style., along with if(cond)\n{\n... *shrug*. it's what you're used to. I don't think either is inherently more bugcatchier.

[13:55] <[Coke]> If your team has a style, follow it. Any thing else is taste.

[13:55] <[Coke]> (if you can enforce your team's style automatically, for goodness sake, do that!)

[13:55] <[Coke]> we cannot easily do that here, so I find myself slowing fixing style when I bugfix other people's code. PITA>

[13:57] <cognominal> I dream the day the reference for the "source" would be the AST so that anyone could choose his own style for the view.

[13:57] <masak> [Coke]: full ACK on following @team's style. I have no problem with that. still have personal preferences when I code on my own.

[13:57] <cognominal> that would means that diff would not been line based

[13:58] <cognominal> that would put to rest one Timtoady's claim to fame, patch

[13:59] <flussence> .oO( I think I need a better @team. Nobody else has worked on the codebase at $dayjob but me in 4 years, and when they do look at it they only nitpick the formatting... )

[13:59] <masak> cognominal: gofmt does that, except there's only one true formatting.

[13:59] <cognominal> gofmt?

[14:00] <masak> cognominal: in the Google Go toolset.

[14:00] <masak> flussence: nitpicking on the formatting is missing the point. formatting isn't where the features sit.

[14:00] <brrt> … how much sense would it make

[14:00] <brrt> to implement p6 in go

[14:01] <masak> flussence: as one who has judged two Perl 6 Coding Contexts, one learns to look past formatting differences ;)

[14:01] *** stopbit joined
[14:02] *** the-golem left
[14:03] <flussence> masak: exactly! worse still, my boss seems to be *un*learning perl5. I had to spend 10 minutes explaining to him a "%var = map {...;($x, $y)} @input" last week...

[14:04] <masak> :/

[14:04] * masak .oO( bet he was asking where the comma after the block went ) :P

[14:05] <flussence> ...he was asking what the parentheses were for :(

[14:06] * flussence considers quitting for the sake of my mental health

[14:07] *** benabik left
[14:09] <masak> flussence: uh, what are the parentheses for? :) https://gist.github.com/3959020

[14:10] <flussence> I'd put them in on the misguided assumption that it'd make the code more readable to people who struggle with concepts like "returning mulitple values from a block" :)

[14:10] <cognominal> people always think the parentheses are the list composer and not the comma

[14:11] <cognominal> Perl 6 will help to put that to rest with the assigment low precedence in list context

[14:12] *** PacoAir joined
[14:15] * masak 's "Perl 6 will" alarm triggers

[14:17] <GlitchMr> Perl 6 will work

[14:17] <GlitchMr> Perl 6 will be released

[14:18] <GlitchMr> (oh, wait, it already was)

[14:20] <masak> depends what you mean, I guess.

[14:20] <flussence> I doubt that particular $dayjob will ever get to use p6. I pointed out to them 5.10 is half a decade old and ubuntu LTS comes with 5.14, and the response was pretty much a blank stare.

[14:21] <brrt> flussence, you don't seem to be happy about $dayjob

[14:21] <masak> flussence: we're hiring.

[14:23] <flussence> I think I need a few months rest before I go looking for another programmer job...

[14:23] <jnthn> We'll still be hiring in a few months :P

[14:24] <flussence> I'll think about it then :)

[14:24] <masak> also, our employer is awesome and both jnthn and I really like working for them.

[14:26] *** hash_table joined
[14:27] *** bapa left
[14:28] <[Coke]> flussence: you can be on my team! You just have to move here and do cold fusion. :P

[14:30] *** kijanka_ joined
[14:31] *** bapa joined
[14:33] *** kijanka left
[14:34] <brrt> jnthn, masak: will you still be hiring in two years?

[14:36] <masak> dunno.

[14:36] <brrt> :-)

[14:36] <brrt> don't expect too

[14:40] *** average_drifter left
[14:41] *** kijanka_ left
[14:44] *** adu left
[14:46] *** xinming joined
[14:47] *** mucker joined
[14:48] *** MayDaniel left
[14:50] *** xinming_ left
[14:50] *** MayDaniel joined
[14:52] *** domidumont left
[14:53] *** kresike left
[14:54] *** adu joined
[14:54] *** MikeFair left
[15:00] *** MikeFair_ joined
[15:01] <masak> hey, what's the Perl 5 equivalent of <?{ $0 ~~ /foo/ }> in a regex?

[15:01] *** benabik joined
[15:03] <doy> what does that do?

[15:05] <masak> it fails the current branch of the regex if the first capture group doesn't contain "foo".

[15:06] <doy> (?{$1 =~ /foo/}) probably

[15:06] <doy> hmmm

[15:07] <doy> don't remember if $1 is available yet

[15:07] <masak> should be.

[15:07] <masak> does regex re-entrancy enter into this situation?

[15:08] <doy> probably, although p5 regexes have been reentrant since 5.10

[15:08] <masak> perdoc perlre says that (?{}) always suceeds.

[15:10] <doy> ah, (?((?{$1 =~ /foo}))(*ACCEPT)|(*FAIL)) i guess

[15:10] <masak> yes, that's what I was looking for. doy++

[15:12] <masak> um, except I think I should have '' there rather than '(*ACCEPT)'

[15:13] <doy> oh, right

[15:13] <doy> i don't really use the weird regex stuff very often

[15:13] <doy> (:

[15:14] <masak> and there shouldn't be double parens around that inner (?{}), it seems...

[15:15] *** birdwindupbird left
[15:15] *** sqirrel left
[15:17] *** adu left
[15:17] <doy> perl -E'say "foo" =~ /(...)(?(?{$1 =~ m[foo]})|(*FAIL))/' # yeah, this appears to work for me

[15:17] <masak> \o/

[15:17] <masak> I've abandoned this approach, though.

[15:18] <masak> I'm doing that logic in the substitution part of s///e instead.

[15:18] <masak> comes out slightly cleaner.

[15:18] *** cognominal left
[15:18] *** SamuraiJack_ joined
[15:18] <masak> hehe, fell into the "a ? b ! c" trap again :)

[15:19] *** SamuraiJack left
[15:19] <masak> Perl 5 should have an error messages that catches that for poor Perl 6 programmers like me ;)

[15:19] <doy> (:

[15:22] *** MikeFair_ left
[15:23] *** kaare_ joined
[15:25] <masak> "the more you try to emulate parsing with just regexes, the more silly you will look" -- masak

[15:26] *** brrt left
[15:26] <masak> I say that as someone whose substitution part ended up containing three nested s/// expressions.

[15:28] *** MikeFair_ joined
[15:29] *** cognominal joined
[15:29] <jnthn> Only 3? :P

[15:30] <masak> I got away easy ;)

[15:31] *** hoelzro is now known as hoelzro|away

[15:34] *** MikeFair_ left
[15:37] *** adu joined
[15:38] *** cognominal_ joined
[15:38] *** skids joined
[15:39] *** cognominal left
[15:44] *** tokuhiro_ joined
[15:45] *** tokuhiro_ left
[15:45] <PerlJam> masak: re ternary op.  I wonder how prescient perl 6 can be with it's error messages?  "Hey, it looks like you're trying to do <insert some common idiom from some non-perl language>, perhaps you want <insert the appropriate Perl 6 idiom>"

[15:47] <PerlJam> (and I doubt that Perl 5 will suddenly start spoiling us like Perl 6 has :-)

[15:47] <jnthn> r: class A { }; my $x = new A();

[15:47] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤Unsupported use of C++ constructor syntax;  in Perl 6 please use method call syntax␤at /tmp/Utt5O9bW5C:1␤»

[15:47] <jnthn> ;)

[15:47] <PerlJam> okay, okay, the future is already here :)

[15:49] <PerlJam> We just need to add some for Ruby, Java, Python, Javascript, C, and Haskell ...

[15:51] <cognominal_> next step is "should I correct it for you and start over?"

[15:51] <TimToady> by removing the other parser? :D

[15:51] <PerlJam> heh

[15:52] <cognominal_> :)

[15:52] <masak> std: <<<<<<<

[15:52] <p6eval> std 64edd1c: OUTPUT«===SORRY!===␤Unable to parse shell-quote words at /tmp/rQqao7Qycg line 1:␤------> <BOL>⏏<<<<<<<␤Couldn't find final '>>'; gave up at /tmp/rQqao7Qycg line 1 (EOF):␤------> <<<<<<<⏏<EOL>␤Parse failed␤FAILED 00:00 …

[15:53] <masak> std: say "OH HAI";␤<<<<<<<

[15:53] <p6eval> std 64edd1c: OUTPUT«===SORRY!===␤Unable to parse shell-quote words at /tmp/aqQWgN2SM_ line 2:␤------> <BOL>⏏<<<<<<<␤Couldn't find final '>>'; gave up at /tmp/aqQWgN2SM_ line 2 (EOF):␤------> <<<<<<<⏏<EOL>␤Parse failed␤FAILED 00:00 …

[15:53] <flussence> .oO( I think git actually checks for that one... )

[15:53] <masak> hm, trying to trigger the "version control marker" error.

[15:54] <PerlJam> flussence: oddly, I was thinking of git too.  It goes "assuming you meant <blah> in N second(s)" and then goes ahead

[15:54] <PerlJam> (maybe I just crossed the streams though :)

[15:54] <TimToady> std: <<<<<<<␤=======␤>>>>>>>␤

[15:54] <p6eval> std 64edd1c: OUTPUT«===SORRY!===␤Found a version control conflict marker at /tmp/rzAS1qpjc2 line 1:␤------> <<<<<<<⏏<EOL>␤Check failed␤FAILED 00:00 40m␤»

[15:55] <timotimo_> that's cute

[15:56] *** MikeFair_ joined
[15:56] *** arkydo joined
[15:57] <masak> TimToady++

[16:01] *** am0c left
[16:01] *** am0c joined
[16:03] *** MikeFair_ left
[16:05] *** havenn joined
[16:07] <TimToady> masak: cognominal_ expected the non-stringified key, but wanted to know why the .Str in the code seemed to not do anything

[16:07] <cognominal_> indeed

[16:08] <cognominal_> but the code I pasted is not called when I do   :   1 => 2

[16:08] <TimToady> I misread it the first time too, y'see...

[16:08] <TimToady> is that the :foo(42) code instead?

[16:08] <cognominal_> I did not find the code that parse it?

[16:08] <TimToady> that *does* stringify

[16:09] <cognominal_> indeed

[16:09] *** gdey joined
[16:09] <cognominal_> so what is the rule that parses  1 => 2

[16:09] <TimToady> well, I'm guessing an ack for Pair might find it eventually...

[16:09] <cognominal_> TimToady: pesky natural languages, so ambiguous

[16:10] <TimToady> mais oui!

[16:10] <PerlJam> cognominal_: fatarrow?

[16:10] <cognominal_> nope, that the action I pasted

[16:11] *** colomon joined
[16:11] <TimToady> that's probably called only on the bareword => form

[16:11] <masak> oh!

[16:12] <TimToady> I'd guess the action method for infix:« => » is what you're looking for

[16:12] <masak> I'm happy to accept that I misunderstood cognominal_.

[16:12] <cognominal_> TimToady: indeed

[16:12] <masak> still not clear on what he wanted, though :)

[16:12] *** benabik left
[16:12] <masak> could you perhaps show the surprising behavior in a p6eval?

[16:13] <cognominal_> masak: I was surprised that fatarrow always generated a pair with a string. Now, I know it is not called on code like   1 => 2

[16:15] <masak> fatarrow is not called on code like 1 => 2?

[16:15] <masak> I'm confused.

[16:15] <cognominal_> because 1 is not a bareword in Perl 6

[16:16] <TimToady> the fatarrow rule is called only on lookahead of => from a bareword

[16:16] <TimToady> at least in STD

[16:16] <cognominal_> I mean even before a =>

[16:17] <masak> I see.

[16:17] <TimToady> the fatarrow token is defined in STD as <key=.identifier> \h* '=>' <.ws> <val=.EXPR(item %item_assignment)>

[16:17] <masak> r: say (1 => 2).key.^name; say (foo => 2).key.^name

[16:17] <p6eval> rakudo 3619d7: OUTPUT«Int␤Str␤»

[16:17] <masak> looks right to me.

[16:18] <masak> or do you expect the 1 to be a Str?

[16:18] <cognominal_> Timtoady, searching for => in Grammar.pm is like finding an needle in a haystack, indeed search for Pair was the way to go.

[16:18] *** perigrin left
[16:18] <cognominal_> * for the good =>

[16:18] <jnthn> If you know it's called fatarrow, you can get there quickly :)

[16:19] *** perigrin joined
[16:19] <TimToady> the normal => (non bareword) is parsed by token infix:sym« => »

[16:19] <jnthn> TimToady: Rakudo's parsing is the same as STDs there :)

[16:19] <cognominal_> jnthn, indeed, but I thougt it was called for  1 => 2 too

[16:19] <jnthn> cognominal_: No, since 1 ain't an identifier :)

[16:19] <TimToady> jnthn: cognominal_ was looking for *not* fatarrow

[16:20] <cognominal_> that why I was surprised by the key stringification

[16:20] <jnthn> Oh!

[16:20] <jnthn> OK :)

[16:20] <cognominal_> TimToady++

[16:20] <jnthn> Also

[16:20] <jnthn> r: my %h = class => 42;

[16:20] <p6eval> rakudo 3619d7:  ( no output )

[16:20] *** FROGGS joined
[16:20] <jnthn> The fact it's \h* and not <.ws> matters for LTM to work out right in the above case too.

[16:20] <TimToady> yup

[16:21] *** bluescreen10 joined
[16:21] <jnthn> .oO( I hope nobody has a coding style where they put the => on the line below )

[16:21] <TimToady> can't really have tokens containing <.ws>

[16:21] <TimToady> I mean LTM tokens, not token keyword

[16:22] <jnthn> Indeed

[16:22] <jnthn> Thus the sigspace changes, so things in rule can meaningfully particpate in LTM

[16:24] <masak> jnthn: I usually put all my => in a separate file, and then .gitignore it :P

[16:27] *** domidumont joined
[16:29] *** armitage81 joined
[16:30] *** armitage81 left
[16:30] *** armitage81 joined
[16:30] <masak> rn: say "hi ", ([~] <d m d m nt> Z~ <o i u o>)

[16:30] <p6eval> rakudo 3619d7, niecza v22-14-g136ddcf: OUTPUT«hi domidumo␤»

[16:30] <masak> oh, right.

[16:31] <masak> rn: say "hi ", ([~] <d m d m nt> Z~ <o i u o "">)

[16:31] <p6eval> rakudo 3619d7, niecza v22-14-g136ddcf: OUTPUT«hi domidumont""␤»

[16:31] <diakopter> :)

[16:31] <masak> nono

[16:31] *** thou joined
[16:31] <masak> rn: say "hi ", ([~] <d m d m nt> Z~ <<o i u o "">>)

[16:31] <p6eval> rakudo 3619d7: OUTPUT«hi domidumont␤»

[16:31] <p6eval> ..niecza v22-14-g136ddcf: OUTPUT«hi domidumont""␤»

[16:31] <masak> nieczabug.

[16:31] <domidumont> uh ?

[16:31] <masak> rakudo++

[16:32] <TimToady> nyi

[16:32] *** literal left
[16:32] *** literal_ joined
[16:32] <masak> rn: say "hi, armitage{9 ** 2}"

[16:32] <p6eval> rakudo 3619d7, niecza v22-14-g136ddcf: OUTPUT«hi, armitage81␤»

[16:32] <masak> domidumont: just greating people through p6eval. please ignore me as applicable.

[16:32] <masak> (though I was kinda pleased I managed to troll an "uh ?" out of you) :P

[16:33] <TimToady> s/greating/grating/ :)

[16:33] <PerlJam> domidumont: just understand that masak is crazy ... but in a good way :)

[16:33] <jnthn> masak: It's pretty greet that you do that :P

[16:33] <armitage81> hi

[16:33] <PerlJam> armitage81: greetings

[16:34] <domidumont> masak: no problem  :-)

[16:35] * masak shows PerlJam his crazy grin

[16:35] <diakopter> masak: re syntax highlighter, yeah. with the latest version of Notepad++, I think it's become flexible enough to do such a thing

[16:36] <armitage81> im here because im learning perl by my self 

[16:36] <PerlJam> armitage81: Perl 5 or Perl 6?

[16:36] <PerlJam> (or both?)

[16:36] <masak> armitage81: just curious, do you belong to a long, proud line of armitages?

[16:36] <armitage81> i think i have 5

[16:36] <PerlJam> heh, nice juxtaposition :)

[16:37] <armitage81> im a network engineer student  not developer

[16:37] <diakopter> masak: but that doesn't help you

[16:37] <masak> armitage81: Perl 5 is great. you could probably learn a lot of Perl 5 here. just be aware that this is #perl6.

[16:37] <armitage81> what the diference on 6 ?

[16:37] <masak> armitage81: lots of them.

[16:37] <armitage81> really?

[16:37] <masak> ya really.

[16:37] <PerlJam> armitage81: it's like the difference between C and C++ only more so.

[16:37] <armitage81> wow i didn't know that

[16:38] <diakopter> uncountable (by me)

[16:38] <masak> armitage81: see http://strangelyconsistent.org/blog/perl-6-and-perl-5-are-different-languages

[16:38] <armitage81> oh that 's what i was thinking

[16:38] <armitage81> c and c ++

[16:38] <armitage81> oh thanks

[16:38] <flussence> to use a network analogy, it's sort of like the difference between ipv4 and 6...

[16:38] <PerlJam> masak: wow ... that was 2010?  seems like just yesterday-ish

[16:39] <TimToady> hmmm, how many years has IPv6 been coming now?

[16:39] <masak> PerlJam: I agree.

[16:39] <flussence> IIRC ipv6 is almost 20 years old by now... /me checks

[16:40] <armitage81> yeah

[16:40] <flussence> oh, way off. 1998.

[16:40] <masak> TimToady: since 1998. so, 14 years I guess.

[16:40] <TimToady> so we got a couple more years :)

[16:40] <armitage81> but was released officialy few months ago

[16:40] <masak> armitage81: what was? IPv6?

[16:41] <armitage81> anyway we still have ipv4 for a long time 

[16:41] <masak> yeah. same with Perl 5 ;)

[16:41] <flussence> masak: yeah, there was some thing on 6/6 where a bunch of companies enabled it full time

[16:41] <PerlJam> armitage81: I think you and I measure time differently  :)

[16:41] <masak> Perl 5 is putting food on people's families. Perl 6 isn't, at least not to a significant degree, yet.

[16:42] <PerlJam> I don't think my family wants food put on them; they'd rather eat it.

[16:42] <TimToady> Food fight!

[16:42] <armitage81> nop ipv6 existe for a years   but offcially was realeased  few months ago

[16:43] <armitage81> sweet listen dead in june

[16:44] <masak> PerlJam: you probably do know the reference, but just in case: http://www.youtube.com/watch?v=O_RSQSYgGB4

[16:47] *** s1n left
[16:53] *** kcwu left
[16:55] *** kcwu joined
[16:56] <cognominal_> also, arguably, C++ made C worse, Perl 6 should make Perl better

[16:56] <doy> well, the idea was certainly for c++ to make c better

[16:58] <masak> it probably did. maybe some of the features from C++ would have ended up in C had not C++ existed to absorb them :P

[16:58] <cognominal_> Larry did not rush Perl 6 using Perl 5 unliked C++ that was originally C with heavy preprocessing if my memory serves me well.

[16:58] <tadzik> some of the features of C++ did end up in C, iirc

[16:59] <tadzik> but that's probably not what you mean :)

[16:59] <cognominal_> well, STD is Perl 5  based

[16:59] <doy> well, in theory the features did end up in c, but too many people are still stuck on c89, even now

[17:00] <cognominal_> same in Perl :)

[17:00] <tadzik> ISTR reading some article by Dennis Ritchie, and he mentioned some of the really obvious things that were actually stolen from C++

[17:00] <cognominal_> meaning, stuck in 89

[17:01] <cognominal_> reading a lof of Perl code is like time travelling

[17:01] <doy> i think most perl people are at least stuck in 99

[17:01] <doy> (:

[17:02] <PerlJam> cognominal_: It depnds on what you read as to which direction in time you're traveling though.

[17:03] <diakopter> #perl6, I'd really like folks to be able to write lock-free data structures in Perl 6, so I need language support for CAS.  Should it be merely a built in routine that takes an lvalue and two values, or special syntax?

[17:03] <cognominal_> reading code here is time travelling to Christmas

[17:04] <diakopter> (special syntax so the lvalue is handled... as an lvalue)

[17:06] <masak> tadzik: actually, I was mostly being facetious.

[17:06] <diakopter> also, I think we need to be explicit about saying something like, "when a data structure such as a scalar, array, or hash starts to be used by multiple threads, its operation become atomic (either through global lock or lock-free-ness or whatever)"

[17:07] <masak> agree that we need a strategy on parallelism.

[17:09] <PerlJam> and then a *good* strategy if possible  :)

[17:09] <masak> one step at a time ;)

[17:09] <masak> but CAS, from what I know about it, seems a very sensible foundation.

[17:12] *** pmurias joined
[17:12] <diakopter> ..

[17:12] <pmurias> cognominal_: how did C++ make C worse?

[17:13] <cognominal_> C was portable, not C++ for years

[17:14] * flussence tries to write a non-static website in p6, and fails almost instantly

[17:14] <pmurias> cognominal_: you mean C++ was not portable for years

[17:14] <rking> cognominal_: You mean writing C++ that would be interpreted equally on various compilers?

[17:14] <masak> flussence: it's been done :P

[17:14] <flussence> masak: what, the writing part or the failing part? :)

[17:14] <rking> Because g++ was pretty portable (though not as widely-installed as it is now)

[17:15] <cognominal_> rn:  { eval " / :s() / "; CATCH {  when * { say  "hi "~ ($_.message ~~ /l.*?l/) }}  }

[17:15] <masak> rking: or that would not work on all compilers.

[17:15] <p6eval> niecza v22-14-g136ddcf: OUTPUT«Unhandled exception: Action method mod_arg not yet implemented␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1437 (die @ 5) ␤  at /home/p6eval/niecza/src/STD.pm6 line 5633 (STD.sorry @ 7) ␤  at /home/p6eval/niecza/src/NieczaActions.pm6 line 63 (Niecz…

[17:15] <p6eval> ..rakudo 3619d7: OUTPUT«hi literal␤»

[17:15] <masak> flussence: both, I suppose ;)

[17:15] <cognominal_> I am proud of my "hi literal"  :)

[17:16] <rking> So the original statement was "C++ made C worse, Perl 6 should make Perl better". So is that referring to the language itself or system details like how widely available a consistent interpreter will be?

[17:16] *** arkydo left
[17:17] <cognominal_> may be that was just a troll :(

[17:17] * PerlJam is sorry he mentioned C/C++

[17:18] <flussence> of the things I've tried so far, this part of the ecosystem is a mess: couldn't get lighttpd to talk to SCGI, Bailador errors out because it can't find the current directory, and Web won't install through panda... going to try that FastCGI thing now

[17:21] <flussence> oh that's a relief, DBIish's `make test` is a lot more sane than MiniDBI...

[17:21] <masak> cognominal_: innovative with the error message :)

[17:22] <cognominal_> :)

[17:23] <cognominal_> I like to obfuscate using error messages

[17:23] <eiro> s:g[.] = uc *  # my naive attempt 

[17:23] <eiro> anyone so tell me how to write it ?

[17:24] <cognominal_> to write what?

[17:24] <GlitchMr> Replace every letter with it's uppercase version?

[17:24] <GlitchMr> .uc

[17:24] <GlitchMr> its*

[17:24] <masak> rn: $_ = 'abc'; s:g[.] .= uc; .say

[17:24] <p6eval> niecza v22-14-g136ddcf: OUTPUT«ABC␤»

[17:24] <p6eval> ..rakudo 3619d7: OUTPUT«===SORRY!===␤Missing assignment operator␤at /tmp/BdVdBKjSry:1␤»

[17:26] <PerlJam> r: $_ = 'abc'; s:g[.] = uc; .say

[17:26] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤CHECK FAILED:␤Calling 'uc' will never work with no arguments (line 1)␤    Expected: :(Cool $s)␤»

[17:27] <PerlJam> r: $_ = 'abc'; s:g[.] = uc($/); .say

[17:27] <p6eval> rakudo 3619d7: OUTPUT«ABC␤»

[17:27] <PerlJam> I guess rakudo doesn't grok .= in that position?

[17:28] <eiro> what if i want to launch a function there ? 

[17:28] <PerlJam> eiro: What do you mean?  What do you think uc is ?

[17:30] <eiro> s/./f $&/ge # that's what i want to do 

[17:30] *** adu left
[17:30] <eiro> f is a complex translation, not just uc

[17:30] *** adu joined
[17:32] <PerlJam> eiro: the complexity of the function doesn't matter to s///

[17:33] <eiro> sure. i'm just trying to figure out how to translate the match by the image of itself through f 

[17:33] *** tokuhiro_ joined
[17:33] <eiro> as i said: the perl5 code would be s/./f $&/ge

[17:34] <eiro> or s/(.)/f $1/ge

[17:34] <PerlJam> eiro: s:g[.] = f($/);  # perl 6

[17:35] <eiro> but $/ is a hash. isn't it ? 

[17:35] <cognominal_> it is a match

[17:35] *** adu left
[17:36] *** adu joined
[17:36] <PerlJam> eiro: if it makes you feel better ... s:g[.] = f(~$/);

[17:36] <cognominal_> it has the role Associative and Positional

[17:36] *** Chillance joined
[17:36] <PerlJam> (or maybe you find  $/.Str more self documenting?)

[17:36] <cognominal_> so what you do with it depends on what you want

[17:37] *** adu left
[17:38] *** adu joined
[17:38] <eiro> i saw Type/Match.Str but i have to admit i'm confused with it for now 

[17:38] *** tokuhiro_ left
[17:38] <eiro> i mean: $ is a scalar but it also seems to be a hash ...

[17:39] <cognominal_> eiro, I seem to be cast back in a thread we know both too well

[17:39] <cognominal_> happily unkonwn from #perl6

[17:40] <cognominal_> a little knowledge is dangerous...

[17:40] <PerlJam> I was thinking that there was too must cogitation and too little trust-and-try-it.

[17:40] <PerlJam> s/must/much/

[17:41] <cognominal_> r: Match.^roles

[17:41] <p6eval> rakudo 3619d7:  ( no output )

[17:41] <cognominal_> r: sat Match.^roles

[17:41] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&sat' called (line 1)␤»

[17:42] <cognominal_> r: say Match.^roles

[17:42] <p6eval> rakudo 3619d7: OUTPUT«␤»

[17:42] <cognominal_> hum

[17:42] <flussence> yay, got SCGI to work!

[17:45] <cognominal_> According to S02, I think Match.^roles should be  Positional Associative

[17:46] <eiro> cognominal_, i know that. but as you can see: i'm here :)

[17:47] <tadzik> flussence: what were the problems with Bailador, btw?

[17:48] <cognominal_> anyway, my point to Eiro, is that you can get many information thru a match using  $/.list $/.hash  $/.Str

[17:50] <flussence> tadzik: Bailador.pm line 15 was complaining about an undefined string, then it tried loading templates from /views instead of `pwd`/views

[17:51] <tadzik> flussence: 

[17:51] <tadzik> oh

[17:51] <tadzik> you need Bailador::import

[17:51] <tadzik> that's due to rakudobug

[17:51] <tadzik> like in tests :)

[17:51] <flussence> ah

[17:52] *** SamuraiJack__ joined
[17:52] *** SamuraiJack_ left
[17:53] <flussence> ok, time to abandon plan E and try that again. I don't feel like writing my own URL code :)

[18:00] *** cognominal_ left
[18:00] <[Coke]> given:             QAST::Var.new( :name<lexpad>, :scope<lexical>, :decl<var>);

[18:01] <[Coke]> if I'm in a normal nqp function that has that in the QAST that spawned it, how can I get at that lexical

[18:01] <[Coke]> ?

[18:01] *** benabik joined
[18:01] <masak> tadzik: what would it take for Bailador::import to go away, ooc?

[18:02] <tadzik> masak: import() being called automatically

[18:02] <arnsholt> [Coke]: If it's like PAST, just without the :decl I think

[18:02] <tadzik> masak: essentially, Bailador needs caller()'s pwd() in use time

[18:03] <[Coke]> arnsholt: so, drop the decl... and then? sub stuff {} { ... how to get at lexpad here? }

[18:03] <masak> tadzik: do any of the synopses specify that behavior?

[18:03] <tadzik> masak: I think so

[18:03] <masak> import() being called automatically, I mean.

[18:04] <PerlJam> [Coke]: Not to be the second clock that makes you not know the time, but I thought there was a find_lexical() or something you could call.

[18:05] <[Coke]> nqp/docs-opcode.txt has no lexical.

[18:05] <arnsholt> [Coke]: I'm not sure what you want. You're building the AST, right?

[18:06] <[Coke]> yes. and then later the AST calls out to functions writen in nqp.

[18:06] <[Coke]> *written

[18:06] * [Coke] finds pir::find_lex

[18:06] <arnsholt> Oh, you want to access a lexical variable from part of your runtime code?

[18:07] <arnsholt> I'm not sure you can do that. The runtime code isn't inside the lexical scope the var is declared in, after all

[18:08] <[Coke]> one of the  many things that "used to work". :)

[18:08] <arnsholt> Really?

[18:08] * [Coke] sees I'm already using find_dynamic_lex - perhaps it's the :decl<var> that was killing me.

[18:09] <arnsholt> 'Cause I'd think you had to use dynamic variables for that

[18:09] <[Coke]> even debugging this is painful: > set a 3

[18:09] <[Coke]> Null PMC access in get_pmc_keyed()

[18:09] <[Coke]> arnsholt: I am translating code from parrot-nqp to nqp

[18:10] <[Coke]> (now, where is that Null PMC errr...)

[18:11] <jnthn> [Coke]: I'm tied up with doing dinner at the moment, but will try and help you afterwards.

[18:11] <[Coke]> jnthn: I appreciate that. I am making slow and steady progress, but emphasis on teh slow. :)

[18:23] * [Coke] will be on and offline for a bit.

[18:25] *** domidumont left
[18:31] <jnthn> .oO( quantum [Coke] - simultaneously on and offline )

[18:33] <jnthn> [Coke]: Looking for a lexical in the dynamic scope is find_dynamic_lex.

[18:33] <jnthn> Hm, there's no nqp:: op for it yet

[18:38] *** s1n joined
[18:39] *** cognominal joined
[18:45] <diakopter> masak: I'm not sure what you mean by "sensible foundation". What other option is there?

[18:47] <dalek> nqp: 6f5ea29 | jnthn++ | src/QAST/Operations.nqp:

[18:47] <dalek> nqp: Add nqp:: ops for runtime variable lookup.

[18:47] <dalek> nqp: 

[18:47] <dalek> nqp: If you're building a QAST tree up, QAST::Var is just fine. But for

[18:47] <dalek> nqp: lookups where we don't know what we want until runtime, or to write

[18:47] <dalek> nqp: in NQP code, these are useful.

[18:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/6f5ea2939e

[18:47] <dalek> nqp: e4e732c | jnthn++ | src/stage0/ (9 files):

[18:47] <dalek> nqp: Update bootstrap.

[18:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e4e732c3f3

[18:47] <dalek> nqp: 8c8d5ea | jnthn++ | src/QRegex/ (3 files):

[18:47] <dalek> nqp: Use nqp::getlexdyn in place of pir:: op.

[18:47] <dalek> nqp: review: https://github.com/perl6/nqp/commit/8c8d5ea189

[18:48] <jnthn> [Coke]: With latest NQP you can use nqp::getlexdyn('foo') to do what you're after. If you don't want to update for now, the pir variant will do it.

[18:48] *** cognominal left
[18:48] <PerlJam> Coke++ and jnhtn++

[18:48] <PerlJam> that's some nice synergy there (not to be too buzz-wordy)

[18:50] <masak> diakopter: mutexes? that thing Java does, with "synchronized"? Go channels? ithreads?

[18:57] *** cognominal joined
[18:58] <jnthn> Grr. I managed to do the generic NFA stuff in such a way that if I use it in NQP I get bootstrap phases coupled.

[18:59] <masak> :/

[18:59] *** jeffreykegler joined
[18:59] <jnthn> At least fixing it shouldn't be as hard as doing it in the first place...

[19:02] <flussence> argh, Template::Mojo is eating leading indent space on the first line after a ^%.*$ and ruining my neat output. I have to fix this!

[19:03] *** adu left
[19:03] *** not_gerd joined
[19:03] <tadzik> please do!

[19:03] <not_gerd> r: role Foo { has $.foo }; class Bar does Foo { submethod BUILD(:$!foo) {} }

[19:03] <p6eval> rakudo 3619d7: OUTPUT«===SORRY!===␤Attribute $!foo not declared in class Bar␤at /tmp/mjBJp_yiFz:1␤»

[19:03] *** jeffreykegler left
[19:03] <not_gerd> what's the correct way to initialize a role's attributes?

[19:12] <diakopter> masak: but a mutex just uses CAS under the covers

[19:13] <diakopter> masak: There is a concurrency Synopsis

[19:13] <diakopter> TimToady pointed me to it

[19:14] <flussence> tadzik: pull request sent in 3... 2... 1...

[19:17] *** snearch joined
[19:19] <masak> diakopter: there is. it's one of the more liquid one. Pugs implements some of it, I believe, but not much.

[19:19] <jnthn> not_gerd: There's no way that I find especially satisfying tbh. If you don't need to control the initialization explicitly then the default constructor/bless/etc. cycle will do the right thing. Otherwise there's only afaik having some method in the role to do it.

[19:19] *** not_gerd left
[19:19] <jnthn> TimToady: See not_gerd++ question; curious if we have a better answer that I'm not aware of. Or if we can find a better answer ;)

[19:20] *** not_gerd joined
[19:20] <not_gerd> jnthn: thanks

[19:21] <diakopter> masak: so, I don't see how your suggestion of "synchronized"? Go channels? ithreads? has anything to do with what I said

[19:21] <diakopter> I wasn't asking about general concurrency.

[19:21] <diakopter> at all.

[19:21] <diakopter> I thought my question was specific enough

[19:22] * not_gerd has problems with his Irssi after cygwin update

[19:22] <diakopter> (both claims/questions)

[19:22] <not_gerd> jnthn: I'll think about how to best factor my code and leave to fix my setup

[19:22] <jnthn> TimToady: As a datapoint, afaict, it'd not be horribly hard for me to arrange so that the BUILD submethods of composed roles are also called. It'd be something specific to construction time rather than a general mechanism in terms of roles/submethods, which feels sort of a special case, but hey, it's uppercase...

[19:22] <not_gerd> good night, #perl6

[19:22] <jnthn> o/, not_gerd.

[19:23] *** not_gerd left
[19:26] *** GlitchMr left
[19:26] *** GlitchMr joined
[19:28] <rurban> not_gerd: it's the perl update. You can install the old perl manually, and the new perl manually afterwards to keep irssi working.

[19:28] <dalek> nqp: 346be83 | jnthn++ | t/nqp/66-pararole.t:

[19:28] <dalek> nqp: Remove debugging code in a test.

[19:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/346be83703

[19:28] <dalek> nqp: 91543c1 | jnthn++ | t/nqp/66-pararole.t:

[19:28] <dalek> nqp: Test for role/mixin/grammar/LTM interaction.

[19:28] <dalek> nqp: review: https://github.com/perl6/nqp/commit/91543c1d2f

[19:29] <TimToady> r: role Foo { has $.foo }; class Bar does Foo { }; my $b = Bar.new: Foo{ :foo(42) }; say $b.perl;

[19:29] <p6eval> rakudo 3619d7: OUTPUT«Default constructor only takes named arguments␤  in method new at src/gen/CORE.setting:707␤  in block  at /tmp/vJ7TWDEHbG:1␤␤»

[19:29] <TimToady> you're supposed to be able to pass a WHENCE to do that

[19:30] <jnthn> Hm, I now have a patch that makes the NQP test suite run in 36s instead of the 23s it ran in before...

[19:31] <jnthn> TimToady: nyi, though I wasn't aware that'd work out for roles

[19:31] *** benabik left
[19:31] *** benabik_ joined
[19:31] <jnthn> TimToady: It doesn't answer the "what if a role wants to do some of its own initialization work" very well though.

[19:31] *** benabik_ left
[19:32] *** benabik joined
[19:32] <TimToady> well, one can put a default initializer on an attribute, at least

[19:32] <jnthn> I think that bit works already.

[19:32] <jnthn> It's more if you want to do more interesting logic, like a BUILD submethod allows.

[19:32] <TimToady> I'm thinking we need something special that we can put after = that says to take the appropriate arg from BUILDs args

[19:32] <TimToady> BUILD's rather

[19:33] <jnthn> Even if we do that, I suspect people will still in some cases hunger for a BUILD-y thing in roles.

[19:33] <jnthn> We can always say "module space!" for that, mind.

[19:33] <TimToady> something in the role to say that BUILD is allowed to manage it

[19:34] <TimToady> well, we've conjectured COMPOSE phasers before

[19:34] <jnthn> Well, but a role's BUILD-y logic probably belongs int he role...

[19:34] <jnthn> *in the

[19:35] *** birdwindupbird joined
[19:36] <TimToady> anyway, a WHENCE is supposed to allow you to direct a packet of initial values to any typed subpart of the current object

[19:36] <jnthn> *nod*

[19:36] <jnthn> I agree that should be made to work.

[19:37] <TimToady> though to the first approximation we want flat named args to be useful too, when the user doesn't want to be aware of the current factoring of the objects in question

[19:38] <TimToady> so an object's initialization oughta be able to deal with that somehow; whether that means a role's private attrs are visible in BUILD or not is not clear to me

[19:39] <diakopter> no one has a comment on whether the language needs a CAS built-in for lvalues?

[19:40] <jnthn> diakopter: To the degree that they're scalar containers, it's perhaps the scalar container that needs to have it...

[19:40] <diakopter> okay. I meant things like array and hash slots in addition to scalars

[19:40] <jnthn> TimToady: To clarify what I'm suggesting: I don't think the role's attrs should be visible in the class. I'm suggesting that a role can have a BUILD method too, and we arrange to call it *in addition* to any BUILD submethod in the class.

[19:41] <jnthn> diakopter: True, though that only applies in the binding case.

[19:41] <TimToady> diakopter: it seems like more of a "primitive" concept than a "built-in" to me; it's not clear to me where this would show up in the user view

[19:41] <jnthn> diakopter: (Since array and hash values are scalar containers)

[19:41] <jnthn> (in the non-native case)

[19:42] <jnthn> er, I meant s/method/submethod/

[19:43] <diakopter> TimToady: in order to implement a lock on an object, the user could have an attribute that toggles between zero and one. A thread that wished to obtain the lock requests to toggle it from 0 to 1.

[19:43] <diakopter> The thread releases the lock by toggling it back to 0

[19:43] <diakopter> the CAS attempt from 0 to 1 fails if it's already 1

[19:43] <diakopter> and signifies that by returning what was there previously - 1

[19:44] <diakopter> all mutexes/atomic counters/monitors/locks/synchronization can be built on that primitive

[19:45] <diakopter> and lock-free data structures in particular need such a thing, definitively

[19:45] <diakopter> though some can get by with just atomic increment/decrement (which would also be nice)

[19:45] *** s1n left
[19:46] <pmurias> can we portably support CAS?

[19:46] <TimToady> you just said that lock-free data structures need locks

[19:46] <diakopter> lock-free data structure means no global lock on the whole object. All of them still have locks at some much smaller level

[19:47] <diakopter> in the form of CAS - a CPU core claims ownership of a memory location while it tests/updates it

[19:47] <diakopter> pmurias: if the VM can support it, yes :)

[19:47] <TimToady> if the CPU supports *any* form of locking you can implement CAS, but it might not be efficient :)

[19:48] <diakopter> you're right

[19:48] <jnthn> CPUs often provide something CAS-ish.

[19:49] <TimToady> we can put the bit right next to the taint bit that no one implements yet...

[19:49] <diakopter> jnthn: explain more? how does a hash slot need to be bound but a scalar just needs assigned

[19:50] <diakopter> I seem to have forgotten what binding is, for the 8th time or so

[19:51] <diakopter> (or else I would be able to understand)

[19:51] <TimToady> binding is just copying a pointer rather than a value

[19:51] <TimToady> so you can't bind something to a native location, but you can assign to it

[19:51] <jnthn> diakopter: %h<a> = 42; # really boils down to looking up %h<a>, which gives you the scalar, and then = assigns the value into it.

[19:52] <diakopter> ah yes. now I remember; thanks :)

[19:52] <TimToady> in a compact array, you can assign to elements, but you can't bind them

[19:52] <diakopter> so to CAS on a hash value would be a CAS on its scalar

[19:53] <TimToady> CAS on a native would have to be handled differently than CAS on something that can carry its own bit around

[19:53] <diakopter> I don't get what this bit would be for

[19:53] <TimToady> it's your 0 or 1 bit you were just talking about

[19:54] * masak .oO( oh, it's a 0 or 1 bit! ) :P

[19:54] <jnthn> TimToady: You don't use the bit for the lock, you substitute the value itself.

[19:54] <jnthn> TimToady: diakopter was just saying how you'd implement a crappy mutex in terms of CAS.

[19:55] *** rindolf left
[19:55] <jnthn> TimToady: More typically you use it as a kind of optimistic concurrency.

[19:55] <flussence> masak: well, the alternative's a signed int1...

[19:55] <jnthn> Build a new version of the thing, and put it into place conditional on nobody else having done so.

[19:55] <TimToady> well, I'm talking about how you would *use* that, so apples and oranges

[19:55] <diakopter> lunch; bbiab &

[19:55] <jnthn> Ah :)

[19:56] <TimToady> I'm just assuming that an "attribute" that is that important warrants a bit in the header

[19:56] <TimToady> like taint

[20:00] * jnthn discovers one reason having the quote language be the same as the main language causes a little fun...

[20:01] *** s1n joined
[20:01] *** hash_table left
[20:01] <TimToady> by definition it can't be "the same"

[20:01] <TimToady> so I'm not sure what you mean

[20:01] *** vlixes joined
[20:01] <jnthn> TimToady: As in, same grammar.

[20:02] <jnthn> TimToady: Regex is a separate grammar, but quotes are in with the main language grammar.

[20:02] <TimToady> well, yes, up till the first mixin

[20:03] <TimToady> then it's merely a derived grammar

[20:03] <jnthn> In STD there's a separate Q.

[20:03] <jnthn> Also Rakudo doesn't mix in starter/stopper, it does them out of contextuals.

[20:03] <TimToady> ah, yes, you mean rakudo doesn't start with a Q

[20:03] <jnthn> Yeah.

[20:04] <jnthn> How much of a problem do you consider that?

[20:04] * jnthn is trying to find a way to improve quoting stuff that makes everybody happy...

[20:04] *** GlitchMr left
[20:04] <TimToady> contextuals can get out of sync with the "current language"

[20:05] <TimToady> so when possible it's better that the current language be defined by the current type

[20:05] <TimToady> for instance, suppose we make some way of naming a quote language

[20:05] <TimToady> wheneve you invoke that quote language, you'd have to remember to reinstante the contextuals as well

[20:06] <jnthn> Hm, true.

[20:06] <TimToady> if it's baked into the cursor type, it's not a problem

[20:06] <TimToady> contextuals also make it difficult to "braid" languages

[20:07] <TimToady> though admitedly STD is doing the braiding itself with a contextual at the moment

[20:07] *** mhasch left
[20:07] <TimToady> but that's just a way of naming languages to get back to a certain language

[20:08] <TimToady> actually defining a given language using contextuals will tend to interfere with that

[20:08] <flussence> tadzik: ooc, is there any obvious way to do this sort of thing with Bailador (workingly)? https://gist.github.com/3961161

[20:08] <TimToady> Perl 6 really, really wants to know exactly what language something is at every point, and if there are parts of the definition floating around outside the cursor, it can lose track

[20:09] *** fgomez joined
[20:09] <jnthn> OK, makes sense.

[20:09] * jnthn guesses this means "be more STD-ish"

[20:10] <TimToady> it's just a specific case of the P6 design philosophy of figuring out everywhere P5 hung things on the wrong peg, and hanging things on the right peg instead

[20:12] <TimToady> P5 didn't even have the contextuals peg, so there's a little bit of temptation to overuse them now

[20:13] <TimToady> and using them for two interleaved purposes will have about as good a result is nesting source filters in P5

[20:13] <TimToady> s/is/as/

[20:13] <TimToady> s/interleaved/interleaved and related/

[20:13] <TimToady> it's fine to interleave orthogonal purposes, I think

[20:14] * masak .oO( weaving orthogonal purposes )

[20:15] <jnthn> TimToady: OK. Supposing I do split out Q and do things STD-like, is caching quoting langauges OK to avoid doing the mixins every single time?

[20:15] <TimToady> or to look at it another way, if a language definition is a kind of continuation, that contuation doesn't capture contextuals properly

[20:17] <eiro> perl6 powered blog: first render: http://ramirez.u-strasbg.fr:5000/

[20:17] <jnthn> e.g. the first time we see the Q:qq language, we derive it, then cache the derived type for future use?

[20:17] <TimToady> it might have to be a per-parent-language cache in some cases

[20:17] <TimToady> unless we elevate it to the level of a braid

[20:18] <TimToady> otoh, maybe some languages need to be distinguised by being the peg on which a braid hangs

[20:19] <TimToady> that is, instead of %*LANG being a pure contextual, it'd be something you'd look up based on the current language's pedigree somehow

[20:20] <TimToady> maybe it's just a lookup method for a particular braid member

[20:20] <jnthn> TimToady: OK. I just know we're gonna need to cache it somehow for performance to not suck.

[20:20] <TimToady> well, methods to parent types are supposed to be fast :)

[20:21] <jnthn> Yes, the bit I'm worrying about is all the derived langauges. :)

[20:21] <TimToady> so maybe $cursor.braidQ returns Q

[20:21] <jnthn> (creating one has a bit of cost)

[20:21] <flussence> hm, I fixed the previous gist so it works, but it *looks* suboptimal...

[20:21] <TimToady> and .braidqq returns the cached qq

[20:21] <TimToady> modulo a bikeshed or two

[20:22] <jnthn> So long as the bikeshed has polka dots, I don't care...

[20:22] <TimToady> I can probably prototype this in STD, and it might even make STD run faster

[20:22] <jnthn> eiro: for ( %tree.kv ) -> $link is copy, $child { 

[20:22] <jnthn> eiro: Doesn't need the parens around %tree.kv

[20:23] <jnthn> eiro: And to avoid needing is copy then consider:

[20:23] <jnthn>         $link ~~ s/^data\///;

[20:23] <jnthn>         my $label = $link.split('/').pop;

[20:23] <jnthn> instead being

[20:23] <jnthn>         my $label = $link.subst(/^data/, '').split('/').pop;

[20:24] <jnthn> oh

[20:24] <TimToady> .[*-1] maybe

[20:24] <jnthn> but $link gets re-used in a few places

[20:24] <jnthn> Well, can always put the diddled version in another variable :)

[20:24] <TimToady> I wouldn't bank on split returning a mutable

[20:24] <eiro> https://github.com/Kivutar/hyde/blob/master/translate.p6

[20:25] <eiro> jnthn, the article isn't mine (it's kivutar one) but yes: i'll tell him)

[20:27] <masak> lol, I blogged! \o/ http://strangelyconsistent.org/blog/sweet-ports

[20:27] <masak> (yes, it's been a while)

[20:27] *** s1n left
[20:27] <pmurias> I'm unsure how to map the nqp calling convention to js, I'm considering named_as_object,positional1,positional2,...

[20:28] <jnthn> pmurias: Maybe wants to be something capture-ish

[20:30] <pmurias> Maybe?

[20:30] <jnthn> tadzik: Any idea why https://github.com/perl6/ecosystem/commit/8990776b3491dfeec8a8f11e57455fdbb1101c03 hasn't been reflected on modules.perl6.org?

[20:30] *** spider-mario joined
[20:30] *** cognominal left
[20:31] <jnthn> pmurias: One other way is to pass everything positional and pass as the first thing a "descriptor"

[20:31] <masak> spider-mario! \o/

[20:31] <spider-mario> hi there \o/

[20:31] <jnthn> pmurias: the descriptor saying which are positional and which are named and including the names

[20:31] <jnthn> pmurias: And the descriptor is static (just made at startup)

[20:31] <pmurias> jnthn: that's what I'm considering

[20:32] <pmurias> but with the descriptor being an object containing the named arguments

[20:32] <pmurias> jnthn: do we care about the order of the named arguments?

[20:33] <eiro> bonsoir #perl6 :)

[20:34] <jnthn> pmurias: But if you put the named arguments into the descriptor then it's not static...

[20:34] <jnthn> pmurias: Rakudo doesn't preserve the order of named args, no

[20:34] *** benabik_ joined
[20:35] <pmurias> jnthn: I think v8 packs hashmaps into compact objects

[20:35] <pmurias> when JITing code

[20:35] <jnthn> pmurias: Then it's probably less of an issue but potentially you can get away with one less object per call.

[20:37] *** cognominal joined
[20:37] <dalek> nqp: 5e80295 | jnthn++ | src/ (2 files):

[20:37] <dalek> nqp: A little re-working on generic NFA storage.

[20:37] <dalek> nqp: 

[20:37] <dalek> nqp: This means we can do them in a way that doesn't end up with different

[20:37] <dalek> nqp: NQP bootstrap layers ending up linked.

[20:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/5e80295c3b

[20:38] *** benabik left
[20:38] *** benabik_ is now known as benabik

[20:45] *** fgomez left
[20:45] *** s1n joined
[20:47] *** rindolf joined
[20:48] <pmurias> jnthn: I think I'll implement named arguments in a simple way for now, and then benchmark it later

[20:49] <jnthn> pmurias: +1

[20:50] *** arlinius joined
[20:51] *** am0c left
[20:53] *** hash_table joined
[21:04] *** fgomez joined
[21:05] *** SamuraiJack__ left
[21:06] *** skids left
[21:06] *** vlixes left
[21:06] *** mucker left
[21:07] *** cognominal left
[21:08] *** cognominal joined
[21:08] *** pmurias left
[21:10] *** benabik_ joined
[21:12] *** spider-mario left
[21:13] *** benabik left
[21:13] *** benabik_ is now known as benabik

[21:14] *** pmurias joined
[21:16] * [Coke] upgrades nqp

[21:20] *** birdwindupbird left
[21:20] <cognominal> TimToady, you can't bind to native because they can end up in processor registers?

[21:22] <masak> cognominal: no, because they lack the "shell" that you'd normally bind to. what we call a "container", sometimes.

[21:22] <masak> cognominal: the thing associated with a variable, array element, etc, that the value resides in.

[21:23] <masak> "scalar container", even.

[21:25] <[Coke]> jnthn: building nqp now segfaults. :P

[21:26] <jnthn> Um.

[21:26] *** kaare_ left
[21:26] <jnthn> realclean and re-Configure?

[21:27] <cognominal> so a fortiori, when within a register they don't have such a "container"

[21:28] * cognominal like to be right even if it si for the edge case :)

[21:28] <[Coke]> jnthn: git rb ; git clean -xdf ; perl Configure.pl --prefix=$HOME/bird

[21:28] <[Coke]> dies with:

[21:28] <[Coke]> make: *** [src/stage1/QASTNode.pbc] Segmentation fault: 11

[21:29] <[Coke]> This is Parrot version 4.9.0-devel built for i386-darwin

[21:30] <pmurias> cognominal: when out of a register they don't have such a container too

[21:32] *** bluescreen10 left
[21:33] <[Coke]> backtrace: https://gist.github.com/3961694

[21:33] *** fgomez left
[21:33] <jnthn> [Coke]: Sadly, a segfault there tells me little :(

[21:34] * [Coke] will try with --gen-parrot :|

[21:35] <jnthn> I struggle to imagine anything that's changed recently that could induce segfaults.

[21:35] <jnthn> ...in NQP.

[21:35] <jnthn> This is nqp version 2012.10-69-g5e80295 built on parrot 4.4.0 revision RELEASE_4_4_0 

[21:36] <[Coke]> arg. running with --gen-parrot in nqp triggers the parrot init::manifest bug randal was complaining about.

[21:41] *** tokuhir__ joined
[21:42] *** japhb_ joined
[21:42] <japhb_> [Coke], I repeat the recommendation I gave to Randal.  Take off and nuke it from orbit, it's the only way to be sure.  ;-)

[21:44] <diakopter> [Coke]: think it runs make clean or realclean; perhaps parrot's make clean is blowing that file

[21:44] *** MayDaniel left
[21:44] <japhb_> --gen-parrot really doesn't like it when tools/build/PARROT_REVISION rewinds

[21:45] <japhb_> You want to go down the "making a new clone of parrot" code path, not the "updating an existing clone of parrot" path

[21:47] * japhb_ has not had the spare tuits to investigate and fix that bug.  :-/

[21:47] <diakopter> I suspect make clean/realclean

[21:48] <diakopter> in parrot

[21:48] <japhb_> yeah.

[21:48] *** Pleiades` left
[21:49] *** snearch left
[21:49] <japhb_> Probably wants to do the equivalent of 'git fetch; make clean; git checkout $PARROT_REVISION; make realclean; perl Configure.pl; make; make install'

[21:49] *** bro_grammer joined
[21:50] *** Pleiades` joined
[21:51] <japhb_> Actually I guess that wouldn't work.  Hmmm.

[21:52] *** eternaleye joined
[21:52] <japhb_> Probably wants to do the equivalent of 'git fetch; make realclean; git checkout $PARROT_REVISION; perl Configure.pl; make realclean; perl Configure.pl; make; make install'

[21:53] <japhb_> Wasteful, but should handle 'make realclean' changing meaning before and after checking out a new $PARROT_REVISION

[21:54] *** hash_table left
[21:59] *** pmurias left
[22:01] *** rindolf left
[22:01] *** bro_grammer left
[22:03] *** bro_grammer joined
[22:03] *** mhasch joined
[22:04] *** rindolf joined
[22:07] *** fgomez joined
[22:09] <masak> 'night, #perl6

[22:10] <japhb_> o/

[22:13] <rindolf> masak: night.

[22:13] <phenny> rindolf: 25 Oct 04:54Z <azawawi> tell rindolf you werent getting any input because of a bug in new commits of HTTP::Easy

[22:13] <rindolf> phenny: thanks.

[22:13] *** fgomez left
[22:13] <rindolf> phenny: tell azawawi OK, I understand now - regarding HTTP::Easy.

[22:13] <phenny> rindolf: I'll pass that on when azawawi is around.

[22:13] <rindolf> phenny++

[22:16] *** whiteknight joined
[22:28] *** fgomez joined
[22:29] *** benabik left
[22:30] *** stopbit left
[22:50] *** fgomez left
[22:53] *** raiph left
[22:53] *** pjcj left
[22:55] *** pjcj joined
[23:03] *** Rix left
[23:04] *** fgomez joined
[23:07] <tadzik> jnthn: nope

[23:07] <tadzik> I'm more curious why it's not on http://feather.perl6.nl/~sergot/modules/ :)

[23:07] <tadzik> cronjobs..

[23:07] <jnthn> tadzik: We fixed it.

[23:07] <jnthn> tadzik: masak++ noticed I'd put the private github URL in source-url, not the public one

[23:08] <tadzik> a-ha

[23:08] <jnthn> So, JSON::Path is now on modules.perl6.org \o/

[23:08] <tadzik> but Test::Harness is also not thhere

[23:08] <rindolf> jnthn: awesome.

[23:08] <tadzik> oh, it is

[23:12] *** aindilis left
[23:16] <jnthn> 'night o/

[23:18] *** benabik joined
[23:33] *** benabik left
[23:38] *** benabik joined
