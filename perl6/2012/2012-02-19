[00:00] *** retupmoca left
[00:10] *** tarch left
[00:15] <fsergot> Good night everyone. o/

[00:19] <masak> 'night, fsergot 

[00:19] <dalek> rakudo/macros2: 39ff0b2 | masak++ | src/ (4 files):

[00:19] <dalek> rakudo/macros2: partial commit

[00:19] <dalek> rakudo/macros2: 

[00:19] <dalek> rakudo/macros2: This is really close to working -- the code in this commit

[00:19] <dalek> rakudo/macros2: sets the OUTER of the incarnated quasi to the correct context.

[00:19] <dalek> rakudo/macros2: 

[00:19] <dalek> rakudo/macros2: But this code still doesn't work, and we really expect it to:

[00:19] <dalek> rakudo/macros2: 

[00:19] <dalek> rakudo/macros2: ./perl6 -e 'macro foo { my $a = "OH HAI"; quasi { say $a } }; foo'

[00:19] <dalek> rakudo/macros2: review: https://github.com/rakudo/rakudo/commit/39ff0b21f6

[00:20] <masak> jnthn++ and I 've had a really productive hackathon tonight. we *almost* got macro OUTER fixups working. :)

[00:21] <masak> fixed a bunch of thinkos along the way. only one left.

[00:21] <sjn> yay!

[00:25] <masak> this macro stuff is actually quite straightforward, once the beer kicks in.

[00:30] <masak> 'night, #perl6

[00:31] *** MayDaniel left
[00:43] *** snearch left
[01:00] <colomon> o/

[01:05] <[Coke]> "pugs",      2150,     0,   989,     9,  3148, 22754

[01:06] * jnthn safely back from $masak-place :)

[01:07] <[Coke]> a lot of my perl mail from 2007 is bouncing today.

[01:07] <[Coke]> weird.

[01:07] <[Coke]> s/a lot/some/, anyway.

[01:10] <colomon> au++ # brilliant cheating in the PD tournament.  

[01:12] *** Maddingu1 joined
[01:17] *** ab5tract left
[01:25] * jnthn -> sleep

[01:27] <colomon> niecza: sub pangram($s) { "a".."z" ‚äÜ $s.comb; }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.") 

[01:27] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Unhandled exception: Unable to resolve method Capture in class Range‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (to-set @ 1) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at <unknown> line 0 (&to-set @ 0) ‚ê§  at ‚Ä¶

[01:27] <colomon> niecza: sub pangram($s) { (set "a".."z") ‚äÜ $s.comb; }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.") 

[01:27] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´False‚ê§True‚ê§¬ª

[01:28] <colomon> niecza: sub pangram($s) { (set "a".."z") ‚äÜ $s.lc.comb; }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.") 

[01:28] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´False‚ê§True‚ê§¬ª

[01:30] * sjn wonders if a the russian pangram would work :) http://en.wikipedia.org/wiki/Pangram

[01:31] *** Maddingu1 left
[01:31] <TimToady> why did it work without the lc?

[01:32] <colomon> .....

[01:32] <TimToady> oh, it has another t

[01:32] <colomon> right

[01:32] <colomon> and excess characters (like the ending period) are okay

[01:32] <colomon> I'm changing it on RC right now

[01:33] <colomon> niecza: sub pangram($s) { set "a".."z" ‚äÜ $s.lc.comb; }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.") 

[01:33] <TimToady> I wonder why you have to say set, if ‚äÜ implies set

[01:33] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Unhandled exception: Unable to resolve method Capture in class Range‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (to-set @ 1) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at <unknown> line 0 (&to-set @ 0) ‚ê§  at ‚Ä¶

[01:33] <colomon> it's a weird niecza bug, I think

[01:33] <TimToady> ‚äÜ is tighter than set()

[01:35] <TimToady> niecza: sub pangram($s) { 'a'..'z' ‚äÜ set $s.lc.comb }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.")

[01:35] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Unhandled exception: Unable to resolve method Capture in class Range‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (to-set @ 1) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at <unknown> line 0 (&to-set @ 0) ‚ê§  at ‚Ä¶

[01:35] *** Maddingue joined
[01:35] <TimToady> niecza: sub pangram($s) { 'a'...'z' ‚äÜ $s.lc.comb }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.")

[01:35] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Unhandled exception: Cannot coerce "z" to a Set; use set("z") to create a one-element set‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1360 (die @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 2018 (to-set @ 6) ‚ê§  at /home/p6eval/niecza/lib/CORE.set‚Ä¶

[01:35] <TimToady> niecza: sub pangram($s) { ('a'...'z') ‚äÜ $s.lc.comb }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.")

[01:35] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´False‚ê§True‚ê§¬ª

[01:35] <TimToady> niecza: sub pangram($s) { ('a'..'z') ‚äÜ $s.lc.comb }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.")

[01:36] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Unhandled exception: Unable to resolve method Capture in class Range‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 0 (to-set @ 1) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at <unknown> line 0 (&to-set @ 0) ‚ê§  at ‚Ä¶

[01:36] <TimToady> niecza: sub pangram($s) { ('a'..'z').list ‚äÜ $s.lc.comb }; say pangram("hello"); say pangram("The quick brown fox jumps over the lazy dog.")

[01:36] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´False‚ê§True‚ê§¬ª

[01:36] <colomon> yes, it's Range that's doing it

[01:36] <TimToady> inrstn...

[01:37] <TimToady> oughta work, anyway

[01:37] <colomon> yes

[01:37] <TimToady> I assume it defaults to set rather than bag semantics?

[01:38] <colomon> The set operators always use set semantics

[01:38] <TimToady> I though I saw some bag tests using set operators

[01:38] <colomon> even if you give it two bags

[01:38] <TimToady> okay

[01:39] <TimToady> do we have ‚äç and ‚äé for bags?

[01:39] <colomon> not yet

[01:39] <colomon> should we?

[01:40] * colomon terminal draws those symbols impractically small for middle-aged eyes

[01:40] <TimToady> probably, if ordinary ‚à™ and ‚à© force set ops

[01:40] <TimToady> tell me about it

[01:40] <colomon> that's bag union and bag intersection?

[01:41] <TimToady> .u ‚äç‚äé

[01:41] <phenny> U+228D MULTISET MULTIPLICATION (‚äç)

[01:41] <phenny> U+228E MULTISET UNION (‚äé)

[01:41] <araujo> is there exist any variable that keeps the number of iterations inside a for or loop block?

[01:42] <TimToady> no, that would be silly, since it's so easy to declare your own

[01:43] <TimToady> perl6: for ('a'..'z').kv -> $i, $letter { say "$i $letter" }

[01:43] <colomon> TimToady: I really can't tell the difference between those symbols.  :(

[01:43] <p6eval> rakudo 14c84d, niecza v14-43-gc4ecd5c: OUTPUT¬´0 a‚ê§1 b‚ê§2 c‚ê§3 d‚ê§4 e‚ê§5 f‚ê§6 g‚ê§7 h‚ê§8 i‚ê§9 j‚ê§10 k‚ê§11 l‚ê§12 m‚ê§13 n‚ê§14 o‚ê§15 p‚ê§16 q‚ê§17 r‚ê§18 s‚ê§19 t‚ê§20 u‚ê§21 v‚ê§22 w‚ê§23 x‚ê§24 y‚ê§25 z‚ê§¬ª

[01:43] <p6eval> ..pugs b927740: OUTPUT¬´*** Not a keyed value: VList [VStr "a",VStr "b",VStr "c",VStr "d",VStr "e",VStr "f",VStr "g",VStr "h",VStr "i",VStr "j",VStr "k",VStr "l",VStr "m",VStr "n",VStr "o",VStr "p",VStr "q",VStr "r",VStr "s",VStr "t",VStr "u",VStr "v",VStr "w",VStr "x",VStr "y",VStr "z"]‚ê§ ‚Ä¶

[01:43] <TimToady> colomon: you could try a bigger font :)

[01:43] <TimToady> or reading glasses :)

[01:43] <colomon> TimToady: I did

[01:44] <araujo> I see

[01:44] <araujo> is that pugs breaking there?

[01:44] <araujo> :P

[01:44] <TimToady> U+228D has a star in the middle (I think) and U+228E has a +

[01:44] <colomon> TimToady: at 36-points it looks like a dot and a +

[01:45] <TimToady> I guess dot makes sense

[01:45] <colomon> so ‚äç is "intersection" and ‚äé "union"?

[01:45] *** pullphing joined
[01:46] *** pullphing left
[01:46] <TimToady> yes, for union you just add the two values

[01:46] <TimToady> hence a +

[01:46] <[Coke]> soooo tiny.

[01:46] <TimToady> I suppose the other is the minimum of two values

[01:47] <araujo> ok, thanks TimToady , '.kv' is what I wanted...

[01:47] <colomon> yeah.

[01:47] <colomon> TimToady: notions for Texas versions?

[01:47] <TimToady> well, (.) and (+) are available, I suppose

[01:47] <colomon> ah, and a sensible first approximation, for sure!

[01:52] *** Maddingue left
[01:53] *** Maddingue joined
[01:53] * colomon is now compiling his first stab at implementing them

[01:57] <colomon> and the first stab fails miserably.  :)

[01:58] * colomon luckily has some lovely single malt to cushion the blow.

[02:01] <colomon> niecza: my $a = bag { a => 10, b => 2 }; my $b = bag { a => 3, b => 5 }; say ($a ‚à™ $b).map({ $_ => $a{$_} min $b{$_} })

[02:01] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1222 (warn @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 229 (Mu.Str @ 10) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.settin‚Ä¶

[02:01] <colomon> niecza: my $a = bag { a => 10, b => 2 }; my $b = bag { a => 3, b => 5 }; say ($a ‚à™ $b)

[02:01] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´set(a, b)‚ê§¬ª

[02:02] <colomon> niecza: my $a = bag { a => 10, b => 2 }; my $b = bag { a => 3, b => 5 }; say ($a ‚à™ $b).map(~*)

[02:02] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´a b‚ê§¬ª

[02:02] <colomon> niecza: my $a = bag { a => 10, b => 2 }; my $b = bag { a => 3, b => 5 }; say ($a ‚à™ $b).map({ $_ => 1 })

[02:03] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´Use of uninitialized value in string context‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1222 (warn @ 3) ‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 229 (Mu.Str @ 10) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /home/p6eval/niecza/lib/CORE.settin‚Ä¶

[02:03] <colomon> niecza: my $a = bag { a => 10, b => 2 }; my $b = bag { a => 3, b => 5 }; say ($a ‚à™ $b).map({; $_ => 1 })

[02:03] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´"a" => 1 "b" => 1‚ê§¬ª

[02:03] <colomon> niecza: my $a = bag { a => 10, b => 2 }; my $b = bag { a => 3, b => 5 }; say ($a ‚à™ $b).map({; $_ => $a{$_} min $b{$_} })

[02:03] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´"a" => 3 "b" => 2‚ê§¬ª

[02:04] <colomon> think that's it.  really don't understand the error....

[02:05] <colomon> niecza> bag { a => 10, b => 3, c => 17 } ‚äç bag { a => 3, b => 1, d => 2 }

[02:05] <colomon> bag("a" => 3, "b" => 1, "c" => 0, "d" => 0)

[02:05] <colomon> that's nearly got it, looks like there's a bug in the bag constructor

[02:06] <colomon> niecza> bag { a => 10, b => 3, c => 17 } ‚äé bag { a => 3, b => 1, d => 2 }

[02:06] <colomon> bag("a" => 13, "b" => 4, "c" => 17, "d" => 2)

[02:06] <colomon> .... should that be + or max?

[02:06] <colomon> + is mildly useless, as you can just do that with the normal bag constructor

[02:08] <TimToady> well, same is true for sets

[02:09] <colomon> true

[02:10] * colomon is trying to deal with the bug in the bag constructor before anything else...

[02:10] * colomon loves git stash

[02:16] <colomon> so what should bag { a => -10 } do?

[02:18] <dalek> roast: 49f02a2 | (Solomon Foster)++ | S02-types/ (2 files):

[02:18] <dalek> roast: Make sure zero-valued pairs are properly ignored in the constructors.

[02:18] <dalek> roast: review: https://github.com/perl6/roast/commit/49f02a26da

[02:19] <dalek> niecza: 8488bba | (Solomon Foster)++ | lib/CORE.setting:

[02:19] <dalek> niecza: Ignore pair arguments with 0 values in Bag and KeyBag .new.

[02:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/8488bba5f6

[02:23] <TimToady> probably warn and treat it like 0

[02:24] <TimToady> or just assume the values are well-formed, if the overhead of checking is too much

[02:25] <colomon> I'd definitely not worry about the overhead of checking

[02:26] <TimToady> there might be use cases for negative and/or complex weights, but maybe we don't call those bags

[02:26] <colomon> or fractional

[02:26] <TimToady> currently specced as a KeyWeight

[02:28] <colomon> ooooo

[02:30] <colomon> no equivalent constant version?

[02:31] <TimToady> EnumMap maybe

[02:32] <TimToady> perl6: enum Foo (:a(1.5)); say a

[02:32] <p6eval> niecza v14-43-gc4ecd5c: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Enum values must be Int or Str, but got Rat‚ê§  at /home/p6eval/niecza/lib/CORE.setting line 1598 (List.gist @ 4) ‚ê§  at <unknown> line 0 (ExitRunloop @ 0) ‚ê§  at /tmp/SxmjBKf1GW line 0 (ANON @ 2) ‚ê§  at <unknown> line 0 (ExitRun‚Ä¶

[02:32] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&enum"‚ê§    at /tmp/GCcnPRA_9t line 1, column 1-19‚ê§¬ª

[02:32] <p6eval> ..rakudo 14c84d: OUTPUT¬´===SORRY!===‚ê§This type cannot unbox to a native integer‚ê§¬ª

[02:47] <TimToady> well, there's always constant %hash = ...

[02:49] <colomon> that doesn't do the roll / pick magic, does it?

[02:54] <dalek> roast: 52a5eb9 | (Solomon Foster)++ | S03-operators/bag.t:

[02:54] <dalek> roast: Tests for the bag operators.

[02:54] <dalek> roast: review: https://github.com/perl6/roast/commit/52a5eb97a2

[02:56] *** leprevost left
[02:58] <sorear> colomon: I thought Hash.pick was supposed to do stuff

[02:58] <colomon> I could be wrong... (easily.  it's a big spec.)

[02:58] <sorear> I'm not even basing this off the spec; rather, a half-remembered conversation from 2010

[02:59] <sorear> ... have I really been here two whole years now?  *shudder*

[02:59] <TimToady> that's like, most of your life :)

[03:00] <colomon> :)

[03:05] <dalek> roast: cc6c403 | (Solomon Foster)++ | S03-operators/bag.t:

[03:05] <dalek> roast: Remove unneeded lines.

[03:05] <dalek> roast: review: https://github.com/perl6/roast/commit/cc6c40366a

[03:06] <sorear> "remove unneeded lines: s/A/Œõ/"

[03:08] <sorear> TimToady: do you have a preferred font where ‚äå and ‚äç are easily distinguishable at normal text sizes?

[03:09] <[Coke]> "total",      2580,     1,  1343,    12,  3936, 23185

[03:09] <[Coke]> (pugs)

[03:09] <dalek> roast: 77ec25f | coke++ | S (27 files):

[03:09] <dalek> roast: pugs fudge

[03:09] <dalek> roast: review: https://github.com/perl6/roast/commit/77ec25fedf

[03:10] <sorear> it's worse than ‰∫∫ÂÖ• :D

[03:10] <dalek> Pugs.hs: 1de17bd | coke++ | t/spectest.data:

[03:10] <dalek> Pugs.hs: run more fudged tests

[03:10] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/1de17bd3b0

[03:10] <dalek> niecza: 49030d6 | (Solomon Foster)++ | lib/CORE.setting:

[03:10] <dalek> niecza: Add bag operators.

[03:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/49030d607b

[03:10] <dalek> niecza: f90cb5b | (Solomon Foster)++ | t/spectest.data:

[03:10] <dalek> niecza: Turn on S03-operators/bag.t.

[03:10] <dalek> niecza: review: https://github.com/sorear/niecza/commit/f90cb5bf76

[03:11] <TimToady> I can tell the apart with Monospace 17 on Ubuntu

[03:11] <TimToady> *them

[03:21] *** wknight8111 left
[03:22] <sorear> yow xft:Monospace-17 is a big font

[03:29] *** orafu left
[03:30] *** orafu joined
[03:30] <[Coke]> phenny: tell masak I only have about 490 more passes before I run out of LHF.

[03:30] <phenny> [Coke]: I'll pass that on when masak is around.

[03:30] <dalek> Pugs.hs: ce76481 | coke++ | t (2 files):

[03:30] <dalek> Pugs.hs: use perl6-limited.pl

[03:30] <dalek> Pugs.hs: -- courtesy of rakudo

[03:30] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/ce76481cef

[03:30] <dalek> Pugs.hs: ae046ee | coke++ | t/spectest.data:

[03:30] <dalek> Pugs.hs: run more fudged tests

[03:30] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/ae046eeaf5

[03:44] *** sisar joined
[03:47] *** PacoAir left
[04:07] <sisar> masak++ # for the Bret Victor video

[04:14] *** cogno joined
[04:27] *** cogno left
[04:33] *** thou joined
[04:52] <sorear> Why is "Pugs.hs" called that?

[04:55] <benabik> Well the .hs is the standard extension for Haskell files.

[04:55] <benabik> I dunno where the Pugs part came from.

[04:55] <sorear> :p

[04:55] <sorear> Haskell *files*.

[04:55] <sorear> Pugs.hs is a directory.

[04:55] <sorear> Not a file.

[04:56] <sorear> So it does not make sense.

[04:56] <benabik> To emphasize that pugs is written in haskell.

[04:56] <benabik> I'd guess.

[04:57] <sorear> (Incidentally, "Pugs" stands for "Perl6 User's Gopher System"; it's a riff off of Hugs, the "Haskell User's Gopher System", which is a Haskell implementaion that emulates the user experience of Gofer, one of Haskell's immediate ancestors.)

[04:57] <sorear> (Haskell has about 15 immediate ancestors; it was created to unify the huge number of very similar languages that existed at the time)

[04:59] *** thou left
[05:30] *** thou joined
[05:32] <TimToady> new entry: http://rosettacode.org/wiki/Parsing/RPN_to_infix_conversion#Perl_6

[06:07] *** ribayr left
[06:08] <TimToady> phenny: tell sjn re Russian pangrams, see my latest rev to colomon++'s pangram checker at http://rosettacode.org/wiki/Pangram_checker#Perl_6

[06:08] <phenny> TimToady: I'll pass that on when sjn is around.

[06:17] *** birdwindupbird joined
[06:18] *** mucker joined
[06:53] *** thou left
[07:02] <TimToady> pugs:

[07:03] <TimToady> sorear: it currently says: Welcome to Pugs -- Perl6 User's Golfing System

[07:03] <araujo> ?

[07:09] <TimToady> zzz &

[07:09] <araujo> night TimToady 

[07:15] <sorear> araujo: http://irclog.perlgeek.de/perl6/2012-02-19#i_5173395

[07:20] <au> moritz++ great post-tournament analysis

[07:22] <au> moritz: ftr, "me" also detects whether it's playing against tit-for-tat (or another variant that copies values from @theirs). :)

[07:22] <sorear> o/ au

[07:23] <au> hey sorear

[07:23] <araujo> sorear, ah

[07:24] <au> Pugs.hs is called that because for a while there's also Pugs.pm (and Pugs/**.pm e.g. http://search.cpan.org/~fglock/Pugs-Compiler-Rule-0.37/ ) :)

[07:26] <au> (eventually the p5 prong became Perlito (and various Moosey extensions).)

[07:29] <araujo> ah, that explains the .hs ;)

[07:38] *** GlitchMr joined
[07:55] <moritz> \o

[07:57] <sorear> o/ moritz 

[07:57] <sorear> au: so you're saying there was a "Pugs.pm" directory for a while?

[07:58] <au> sorear: there was a Pugs.pm file for a while

[07:58] <au> when I created this new repo intending only for hackage, that part was not included in the source tree

[07:58] <au> .

[07:59] <dalek> niecza: 3699928 | sorear++ | src/niecza:

[07:59] <dalek> niecza: Detect hashness at pblock reduce time, before optimizing

[07:59] <dalek> niecza: review: https://github.com/sorear/niecza/commit/36999287e1

[08:00] <au> and since Perlito (and MooseX::*) subsumes the original p6-on-p5 Pugs.pm effort, I didn't feel necessary to preserve the early p5 parts into its own repo... if I did, though, the repo would probably have been named Pugs.pm or Pugs.p5 or some such.

[08:00] <sorear> au: I'm just wondering why your repo's name has an extension

[08:00] <au> *nod*

[08:01] <au> other candidate names where hs-Pugs/ and Pugs-hs/

[08:01] <sorear> I didn't realize that perlito was ever called pugs

[08:01] <au> yeah. it was back when we were working on a hybrid runtime

[08:01] <fsergot> o/

[08:01] <sorear> "hybrid runtime"?

[08:02] <au> libperl used not only for eval(:lang<perl5>) but also for grammars

[08:02] <sorear> for...grammars?

[08:02] <au> yeah, that's Pugs::Compiler::Rule above

[08:03] <au> and so most of the compilation phase will take place in the p5vm

[08:03] <au> while execution takes places in ghc-based vm

[08:03] <sorear> why is that a good idea at all?

[08:03] <au> mostly because STD (wasn't called that back then) might be easier to transpile into p5 than into parsec.

[08:03] <sorear> poor parser support in haskell?

[08:04] <au> also p5 by that time had a pretty good metaobject system to use during parsing (Moose.pm) while the haskell equivalent (MO.hs) is less developed.

[08:04] <au> .

[08:04] * sorear is hacking on a bootstrapped compiler mostly because STD.pm6 is easier to run using a Perl 6 implementation

[08:05] <au> and it's definitely the Right Thing

[08:06] <sorear> at this point I've convinced myself that anything that can parse Perl 6 will look very much like a Perl 6 rules engine

[08:06] <au> the idea of 6to5'ing STD.pm6 was expedient, but probably too much trouble in the long run, especially if you're targetting a vm other than p5's own.

[08:06] <au> *nod* fully concurred.

[08:06] <moritz> especially if you want to be able to expand it with p6 grammar rules

[08:06] <au> exactly.

[08:07] <sorear> I have vague dreams of somehow transplanting STD into user space, so that it can be expanded by user rules

[08:07] <au> "tell me more about those dreams... what else do you remember?"

[08:08] *** kaare_ joined
[08:08] <au> :)

[08:08] <sorear> well, the fundamental problem is that STD would then have to run with no setting whatsoever

[08:09] <sorear> I'd need to move most of the logic that isn't strictly parsing into NieczaActions.pm6

[08:09] *** xinming left
[08:09] <au> ah. makes sense.

[08:11] *** ribayr joined
[08:13] <sorear> right now STD is linked against the uplevel CORE

[08:13] <sorear> which precludes "is parsed" and "augment slang"

[08:20] *** xinming joined
[08:46] *** proller joined
[08:51] <sorear> I am growing not-entirely-fond of the way action methods work in perl6

[08:51] <moritz> how so?

[08:52] <sorear> the fact that you can only pass information up, not down

[08:53] <sorear> the fact that there's no way to avoid building a parse tree

[08:53] *** proller_ joined
[08:54] <moritz> you can avoid building a parse tree by not calling make()

[08:55] <sorear> you can avoid building an AST by not calling make()

[08:55] <sorear> the parse tree is always built

[08:57] *** proller left
[08:59] <moritz> you can decide not to capture

[08:59] *** bkolera left
[08:59] <moritz> and you can use <cut> (iirc) assertions to get rid of the pieces you don't need anymore

[08:59] <sorear> If you want to use the result, you have to capture.

[09:00] <sorear> When ingy was complaining about grammar design, I too defended the status quo

[09:01] <sorear> and <cut> is no good here because it's all or nothing

[09:01] <moritz> did ingy find a better solution?

[09:01] *** pmurias joined
[09:01] <sorear> No

[09:02] <sorear> ingy has *very* thin skin and probably stopped trying as soon as you/we opposed him

[09:02] <pmurias> sorear: re avoiding builiding the parse tree - you want to speed things up?

[09:03] <sorear> pmurias: requiring 300mb of ram to parse a 2000 line file is simply unacceptable

[09:08] <pmurias> sorear: maybe try adding a no-parse-tree flag?

[09:08] *** icwiener joined
[09:10] <sorear> That can't work.

[09:10] <pmurias> sorear: theoretically the optimizer could hopefully find that out but it doesn't seem something that can be quickly done

[09:10] <sorear> That doesn't even make sense.

[09:11] <pmurias> sorear: if we don't use the parse tree anywhere why are we forced to keep it?

[09:13] <sorear> I'm too upset to explain that right now.  It will be easy enough to figure out.

[09:13] *** tarch joined
[09:13] * sorear -> sleep

[09:13] * moritz hopes sorear++ isn't too upset to sleep

[09:14] *** ruoso joined
[09:15] *** bkolera joined
[09:25] *** pmurias_ joined
[09:27] *** pmurias_ left
[09:28] *** pmurias left
[09:28] *** pmurias joined
[09:29] *** icwiener left
[09:29] *** icwiener joined
[09:33] <moritz> nom: {YOU_ARE_HERE}

[09:33] <p6eval> nom 14c84d:  ( no output )

[09:34] <moritz> perl6: {YOU_ARE_HERE}

[09:34] <p6eval> niecza v14-47-g3699928: OUTPUT¬´Unhandled exception: System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.‚ê§  at System.Collections.Generic.Dictionary`2[System.String,Niecza.SubInfo].get_Item (System.String key) [0x00000] in <filename unknown>:0‚Ä¶

[09:34] <p6eval> ..pugs b927740: OUTPUT¬´*** No such subroutine: "&YOU_ARE_HERE"‚ê§    at /tmp/vfQ2hDzf2P line 1, column 2-14‚ê§¬ª

[09:34] <p6eval> ..rakudo 14c84d:  ( no output )

[09:52] <Teratogen> perl6: print 1+1

[09:52] <p6eval> pugs b927740, rakudo 14c84d, niecza v14-47-g3699928: OUTPUT¬´2¬ª

[09:55] *** xinming_ joined
[09:55] <Teratogen> well, that works!

[09:55] <Teratogen> =)

[09:56] *** xinming left
[10:02] *** mj41 joined
[10:13] *** birdwindupbird left
[10:26] *** pmurias left
[10:38] *** pmurias joined
[10:41] <moritz> phenny: tell masak about http://julialang.org/manual/metaprogramming/

[10:41] <phenny> moritz: I'll pass that on when masak is around.

[10:55] *** noam_ left
[10:56] *** noam_ joined
[10:59] *** icwiener left
[10:59] *** icwiener joined
[11:06] *** fridim_ joined
[11:07] *** lateau_ joined
[11:07] *** icwiener left
[11:07] *** icwiener joined
[11:08] *** Chillance joined
[11:11] *** icwiener left
[11:11] *** icwiener joined
[11:13] *** snearch joined
[11:18] *** tokuhirom joined
[11:21] *** bkolera left
[11:34] *** icwiener left
[11:34] *** icwiener joined
[11:36] *** yeltzooo joined
[11:40] <jnthn> morn...no, afternoon, #perl6 :)

[11:41] <Teratogen> good morning

[11:42] <araujo> o/

[11:43] <masak> afternoon! \o/

[11:43] <phenny> masak: 03:30Z <[Coke]> tell masak I only have about 490 more passes before I run out of LHF.

[11:43] <phenny> masak: 10:41Z <moritz> tell masak about http://julialang.org/manual/metaprogramming/

[11:43] <masak> [Coke], ok. moritz, looking.

[11:44] <Teratogen> hi masak

[11:44] <araujo> masak, /o/

[11:44] <masak> greetings, earthlings.

[11:46] *** GlitchMr left
[11:55] *** icwiener left
[11:56] *** icwiener joined
[12:08] *** icwiener left
[12:09] *** icwiener joined
[12:12] <masak> moritz: http://julialang.org/manual/metaprogramming/ is an interesting read.

[12:12] <masak> I find two big differences between Julia and Perl 6 in terms of macros. maybe they're a bit related.

[12:13] <masak> the first is the treatment of unbound variables. in Perl 6, the lookup is lexical from the static context of the quasi. in Julia, the lookup is, as far as I can tell, dynamic from the dynamic context of the injected code.

[12:14] <masak> such dynamic lookup is similar to Perl 5's package variables and its `local` keyword -- and to contextual variables in Perl 6, of course.

[12:15] <Teratogen> Perl 6 should have local

[12:15] <masak> Teratogen: Perl 6 has contextuals and `temp`. feel free to read up on these in S02, S03 and S06 :)

[12:16] <Teratogen> ok!

[12:17] <masak> the second is that Julia provides you with an explicit gensym mechanism, and unhygiene is the default. in Perl 6, hygiene is the default, and you have to use the COMPILING namespace to trample over stuff.

[12:18] * masak would like to make a similar analysis of the macro system at http://scalamacros.org/

[12:18] *** birdwindupbird joined
[12:18] <masak> I really liked Julia's facilities for creating and introspecting Expr objects.

[12:19] <masak> so far, I've assumed that we need to keep Perl6::AST objects mostly opaque to manage cross-implementation compatibility... but I have a feeling that people will start clamoring for introspection capabilities fairly soon.

[12:21] *** lateau_ left
[12:28] *** icwiener left
[12:33] *** whiteknight joined
[12:33] *** mucker left
[12:36] *** mucker joined
[12:40] *** mucker left
[12:47] *** mucker joined
[12:49] *** Util left
[12:50] *** Util joined
[12:51] *** mucker left
[12:53] <dalek> rakudo/macros2: e4552e2 | masak++ | src/Perl6/Actions.pm:

[12:53] <dalek> rakudo/macros2: [Perl6::Actions] fix lexical issues

[12:53] <dalek> rakudo/macros2: 

[12:53] <dalek> rakudo/macros2: ...this is the other half of the partial commit from yesterday.

[12:53] <dalek> rakudo/macros2: Fixes two problems:

[12:53] <dalek> rakudo/macros2: 

[12:53] <dalek> rakudo/macros2: - Arranges so that the injected code doesn't get a static outer

[12:53] <dalek> rakudo/macros2:   set at compile time, overriding the one we want for it.

[12:53] <dalek> rakudo/macros2: 

[12:53] <dalek> rakudo/macros2: - Fixes a strange discrepancy where ordinary variables were

[12:53] <dalek> rakudo/macros2:   recognized from inside the quasi block, but macro parameters

[12:53] <dalek> rakudo/macros2:   weren't.

[12:53] <dalek> rakudo/macros2: review: https://github.com/rakudo/rakudo/commit/e4552e22f2

[12:53] *** mucker joined
[12:53] <masak> macros in the macros2 branch are now at a point where they're interesting for early adopters.

[12:53] <masak> hint, hint.

[12:53] <jnthn> masak: Will the branch be mergable soon?

[12:54] <jnthn> masak: So we can have basic macro support in le release?

[12:54] <jnthn> That'll be a good way to get some early adopters ;)

[12:54] <masak> I was just going to say -- I consider it mergeable now, but I still have two things I would prefer to do before an actual merge.

[12:54] <masak> (1) understand (and possibly) fix the signature issue we just found.

[12:55] <masak> (2) write spectests to cover the weekend's hacking.

[12:55] <masak> I expect to do both during the day.

[12:55] <masak> then I'll probably rebase into a macros3 branch, and then we can merge that.

[12:57] <jnthn> +1

[12:59] <masak> jnthn++ # vital assistance

[13:05] <dalek> rakudo/nom: ac5d99f | jnthn++ | docs/ChangeLog:

[13:05] <dalek> rakudo/nom: A few more ChangeLog entries.

[13:05] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ac5d99f6b7

[13:07] *** robins is now known as robinsmidsrod

[13:28] *** kranius joined
[13:35] *** PacoAir joined
[13:39] <felher> masak++  :)

[13:40] *** snearch left
[13:41] *** ab5tract joined
[13:41] <felher> masak: what can macros do right now, when you say "interesting for early adopters"? :)

[13:42] *** leprevost joined
[13:43] *** birdwind1pbird joined
[13:44] <tadzik> masak: I can't wait for the first module you write using macros :)

[13:45] *** tokuhirom left
[13:48] <Teratogen> I like C's text macro preprocessor

[13:51] *** MayDaniel joined
[14:03] <masak> felher: WORKS: macro definitions, macro invications, quasi quotes, sane variable lookup from within quasi quotes. (the last thing was what we worked on last night.) TO DO: quasi splicing, the COMPILING namespace, other things I can't think of now.

[14:03] <masak> Teratogen: then you should probably enjoy Perl 5's source filters very much.

[14:04] <Teratogen> I liked the convenience of doing Perl -H

[14:04] <Teratogen> I liked the convenience of doing Perl -P I mean

[14:04] <Teratogen> at least on *nix systems

[14:04] <Teratogen> I hear -P has been removed

[14:05] <arnsholt> The C macro preprocessor isn't too good though =)

[14:05] * arnsholt likes TeX

[14:05] <Teratogen> the C preprocessor is simple yet powerful

[14:06] <Teratogen> Perl is written in C and that C code makes extensive use of the preprocessor

[14:06] <masak> good riddance on -P, I say.

[14:06] <masak> just reading the documentation on it makes me shudder.

[14:06] <arnsholt> I know. IIRC it's one of the reasons the perl guts are so hard to hack

[14:07] <masak> :(

[14:07] <arnsholt> If you're doing text-substitution macros, I much prefer the TeX approach (Turing-completeness by string rewriting)

[14:07] <arnsholt> Alternatively, AST-style macros like Lisp, Perl 6 and such are quite nice too

[14:11] <Teratogen> I like the simplicity and power of the C preprocessor

[14:11] <Teratogen> maybe I am showing my age. =/

[14:12] *** GlitchMr joined
[14:13] *** birdwind1pbird left
[14:15] <masak> the C preprocessor has simplicity as an advantage, but I wouldn't call it powerful.

[14:15] <masak> rather, it trips on itself for anything remotely complex.

[14:15] *** noam__ joined
[14:16] <masak> its strengths come from the fact that it's most often used for simple things.

[14:18] *** noam_ left
[14:18] <Teratogen> masak, I looked at a Perl 6 macro definition

[14:18] <Teratogen> looked overly complicated

[14:18] <felher> masak: following your old blogpost "What macros really are", i tried 'macro LOG($message) { quasi { say {{{$message}}}; } }; LOG("some string");'. But this just gives me 'Block.new()'. Don't {{{}}} work any more?

[14:19] <felher> masak: Or did i just misunderstand something?

[14:20] <masak> felher: {{{}}} does not work *yet*.

[14:20] <masak> it's the D2 step of my grant work.

[14:20] <masak> I'm at the end of D1 now.

[14:20] *** ab5tract left
[14:20] <masak> ({{{}}} is the "quasi splicing" I wrote under TO DO above)

[14:21] <felher> masak: ah, i see, thanks :)

[14:22] *** tarch left
[14:22] *** p6eval left
[14:22] *** tarch joined
[14:24] *** Util left
[14:24] *** p6eval joined
[14:24] *** ChanServ sets mode: +v p6eval

[14:25] *** Util joined
[14:27] <masak> Teratogen: macros in Perl 6 are fundamentally quite non-complicated, I think.

[14:27] <masak> they're just routines that deal in ASTs.

[14:29] *** Chillance left
[14:33] *** ab5tract joined
[14:40] *** lateau_ joined
[14:42] <masak> re the custome string prefixes in Julia (last on the metaprogramming page), it's a nice unification. of course, from the Perl 6 perspective, it doesn't go far enough, since all the strings are still just strings, and not first-class citizens to the parser.

[14:43] <masak> it's essentially a two-pass solution, even though it's a bit neater than Perl 5's.

[14:45] <masak> &

[14:45] *** Chillance joined
[14:57] *** xinming_ left
[14:57] *** GlitchMr left
[14:59] *** xinming joined
[15:11] *** att joined
[15:18] *** att left
[15:21] *** icwiener joined
[15:35] *** att joined
[15:36] *** att is now known as att_

[15:44] *** Psyche^ joined
[15:44] *** noam__ left
[15:44] *** noam__ joined
[15:47] *** mj41 left
[15:48] *** Patterner left
[15:48] *** Psyche^ is now known as Patterner

[15:48] *** retupmoca joined
[15:52] *** pmurias left
[15:53] *** pmurias joined
[16:06] *** birdwindupbird left
[16:06] <flussence> yay, Array()! now I can port all my terrible PHP code to rakudo :D

[16:13] <jnthn> Oh my, what have I done... :P

[16:15] <tadzik> :P

[16:18] <masak> nom: say Array(1, 2, 3)

[16:18] <p6eval> nom ac5d99: OUTPUT¬´1 2 3‚ê§¬ª

[16:18] <masak> nom: say Hash(1, 2, 3, 4)

[16:18] <p6eval> nom ac5d99: OUTPUT¬´Method 'Hash' not found for invocant of class 'Parcel'‚ê§  in <anon> at src/gen/Metamodel.pm:3430‚ê§  in <anon> at src/gen/Metamodel.pm:3427‚ê§  in <anon> at src/gen/Metamodel.pm:3422‚ê§  in block <anon> at /tmp/zb8zldT4tP:1‚ê§‚ê§¬ª

[16:18] <flussence> actually, php does have one nice feature I wish more languages had - you can do $hash += $default_values, which is a bit shorter than (p5) %hash = {%default_values, %hash}.

[16:19] <masak> if Array() works, why shouldn't Hash()

[16:19] <masak> flussence: yeahbut

[16:19] <flussence> masak: =>?

[16:19] <masak> flussence: + is arithmetic

[16:19] <flussence> oh, didn't read the error

[16:19] *** pothos left
[16:20] *** pothos joined
[16:20] <masak> also, in p5, it's %hash = %default_values, %hash. which is pretty short if you ask me.

[16:20] <flussence> tr/{}/()/ :)

[16:22] <masak> oh, right.

[16:22] <masak> without the parens is p6.

[16:22] <flussence> perl6: my %a = one => 1, two => 2; my %b = three => 3, four => 4, two => 7; %a.=push(%b); say %a.perl;

[16:22] <p6eval> niecza v14-47-g3699928: OUTPUT¬´{"four" => 4, "one" => 1, "three" => 3, "two" => [2, 7]}.hash‚ê§¬ª

[16:22] <p6eval> ..rakudo ac5d99: OUTPUT¬´("one" => 1, "two" => [2, 7], "three" => 3, "four" => 4).hash‚ê§¬ª

[16:22] <p6eval> ..pugs b927740: OUTPUT¬´*** Can't modify constant item: VUndef‚ê§    at /tmp/HdHjYh0iln line 1, column 70-82‚ê§¬ª

[16:22] *** pothos left
[16:22] <flussence> hm, something like that but without the magic arrays

[16:22] *** pothos joined
[16:23] <masak> niecza sorts its keys alphametically. rakudo seems to prefer to retain insertion order.

[16:23] <masak> nom: my %a = one => 1, two => 2; my %b = three => 3, four => 4, two => 7; %a = %b, %a; say %a.perl

[16:23] <p6eval> nom ac5d99: OUTPUT¬´("three" => 3, "four" => 4, "two" => 2, "one" => 1).hash‚ê§¬ª

[16:24] <flussence> perl6: my %a = one => 1, two => 2; my %b = three => 3, four => 4, two => 7; %a ,= %b; say %a.perl; # just wondering...

[16:24] <p6eval> niecza v14-47-g3699928: OUTPUT¬´{"four" => 4, "one" => 1, "three" => 3, "two" => 7}.hash‚ê§¬ª

[16:24] <p6eval> ..rakudo ac5d99: OUTPUT¬´("one" => 1, "two" => 7, "three" => 3, "four" => 4).hash‚ê§¬ª

[16:24] <p6eval> ..pugs b927740: OUTPUT¬´{("one" => 1), ("two" => 2)}‚ê§¬ª

[16:24] <flussence> :D

[16:25] <flussence> perl6: my %a = one => 1, two => 2; my %b = three => 3, four => 4, two => 7; %a R,= %b; say %a.perl;

[16:25] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "R"‚ê§    expecting operator‚ê§    at /tmp/OwQtcT__Kw line 1, column 73‚ê§¬ª

[16:25] <p6eval> ..rakudo ac5d99: OUTPUT¬´("one" => 1, "two" => 2).hash‚ê§¬ª

[16:25] <p6eval> ..niecza v14-47-g3699928: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Cannot reverse the args of ,= because assignment operator operators are too fiddly at /tmp/4Mkuamoh7m line 1:‚ê§------> [32m three => 3, four => 4, two => 7; %a R,=[33m‚èè[31m %b; say %a.perl;[0m‚ê§‚ê§Unhandled exception: Unable‚Ä¶

[16:25] *** pothos left
[16:25] <flussence> perl6: my %a = one => 1, two => 2; my %b = three => 3, four => 4, two => 7; %a [R,]= %b; say %a.perl;

[16:25] <p6eval> rakudo ac5d99: OUTPUT¬´===SORRY!===‚ê§Preceding context expects a term, but found infix = instead at line 1, near " %b; say %"‚ê§¬ª

[16:25] <p6eval> ..niecza v14-47-g3699928: OUTPUT¬´{"four" => 4, "one" => 1, "three" => 3, "two" => 2}.hash‚ê§¬ª

[16:25] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "["‚ê§    expecting operator‚ê§    at /tmp/6m2mqy7gco line 1, column 73‚ê§¬ª

[16:25] *** pothos joined
[16:25] <flussence> niecza++

[16:27] <masak> sorear: notice 'assignment operator operators' above.

[16:33] <flussence> (the best part is I didn't have to look that up in a manual!)

[16:34] *** araujo left
[16:35] *** araujo joined
[16:37] *** mucker left
[16:41] <jnthn> masak: Hash(...) - just an unimpl Parcel.Hash method.

[16:45] *** thou joined
[16:50] <masak> nod.

[17:01] *** noam__ left
[17:02] *** noam__ joined
[17:12] *** mucker joined
[17:14] *** mucker left
[17:15] <moritz> \o

[17:15] <jnthn> hi, moritz 

[17:16] <jnthn> Just a couple of weeks to the GPW ;)

[17:17] <moritz> yes, you should make travel arrangements!

[17:17] <moritz> (unless you already did)

[17:17] <moritz> fwiw I'm not having much lock with the sink branch

[17:17] <moritz> statements inside subroutines don't get sink context

[17:17] <moritz> and I don't see why

[17:18] *** mucker joined
[17:18] <moritz> I've even tried to add a call to Perl6::Sinker.sink inside the statementlist action method

[17:18] <moritz> but it didn't any good

[17:18] <jnthn> moritz: masak and I already have travel arrangements

[17:18] <moritz> and since we don't have a working PAST dumper, I don't know how to approach debugging

[17:19] <moritz> jnthn, masak: then please /msg or email me your arrival and departure dates

[17:19] <moritz> maybe we can make a Lasagne for dinner one day, or so :-)

[17:19] <tadzik> om nom

[17:20] <jnthn> moritz: oh, I shoulda seen this sooner

[17:20] <jnthn> moritz: in visit_block:

[17:20] <jnthn> $block[1] := self.visit_children($block[1]);

[17:20] <jnthn> That will visit the statements

[17:21] <jnthn> But any *nested* PAST::Blocks will live in $block[0]

[17:21] <jnthn> You want to ignore the other things inside [0], but anything that .isa(PAST::Block) wants to be visited.

[17:26] *** shinobicl___ joined
[17:28] <masak> ooh, lasagna!

[17:30] <sorear> pmurias: I'm sorry for taking out frustration on you last night.

[17:30] <sorear> good * #perl6

[17:30] <colomon> o/

[17:32] <masak> sorear! \o/

[17:32] <sorear> the trouble with getting angry at how slow my compiler is, it doesn't actually make it faster...

[17:34] <sorear> std: 1 ![=] 2

[17:34] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Cannot negate = because list assignment operators are too fiddly at /tmp/BH_9_Gtt86 line 1:‚ê§------> [32m1 ![=][33m‚èè[31m 2[0m‚ê§Cannot negate [=] because list assignment operators are not iffy enough at /tmp/BH_9_Gtt86 line 1:‚ê§------> ‚Ä¶

[17:35] <sorear> std: 2 R,= 3

[17:35] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Cannot reverse the args of ,= because assignment operator operators are too fiddly at /tmp/YYkX9l0bLd line 1:‚ê§------> [32m2 R,=[33m‚èè[31m 3[0m‚ê§Check failed‚ê§FAILED 00:01 109m‚ê§¬ª

[17:38] <masak> ah, STD has the LTA error too.

[17:39] *** MayDaniel left
[17:42] *** birdwindupbird joined
[17:55] *** tarch left
[18:00] *** birdwind1pbird joined
[18:00] *** birdwind1pbird left
[18:00] *** birdwind1pbird joined
[18:00] *** birdwindupbird left
[18:01] *** birdwind1pbird is now known as birdwindupbird

[18:01] *** pmurias left
[18:02] *** MayDaniel joined
[18:03] *** pmurias joined
[18:07] *** countley left
[18:16] *** GlitchMr joined
[18:17] *** pmurias_ joined
[18:17] *** pmurias_ left
[18:19] *** mucker left
[18:33] *** sisar left
[18:48] <sjn> but one thing that's missing is someone who's working on niecza. sorear isn't able to come

[18:48] <phenny> sjn: 06:08Z <TimToady> tell sjn re Russian pangrams, see my latest rev to colomon++'s pangram checker at http://rosettacode.org/wiki/Pangram_checker#Perl_6

[18:48] <sjn> oops

[18:48] <sjn> #wrong

[18:49] <sjn> ooh :)

[18:49] * sjn looks at rosettacode.org

[18:49] *** lateau_ left
[18:53] *** hundskatt joined
[18:53] *** hundskatt left
[18:54] *** hundskatt joined
[19:01] *** birdwindupbird left
[19:05] <masak> that might have been the first time on the channel that a ww triggers a phenny message ;)

[19:07] <sjn> hehe

[19:07] <sjn> btw

[19:07] <sjn> is the "set" keyword available in 2012.01?

[19:08] <jnthn> No

[19:09] <jnthn> We do now (as of a few days ago) have object hashes, however...so Rakudo should be able to get sets quite properly now

[19:09] *** hundskat` joined
[19:09] *** shinobicl___ left
[19:10] <sjn> ok, cool

[19:23] <dalek> nqp/bs: 11f08d2 | jnthn++ | src/core/NQPRoutine.pm:

[19:23] <dalek> nqp/bs: Update dispatcher derevation so it clones the things it should.

[19:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/11f08d27b9

[19:23] <dalek> nqp/bs: 7500b8a | jnthn++ | src/ (3 files):

[19:23] <dalek> nqp/bs: Ensure we do the required attachment of code objects to code refs.

[19:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7500b8ad00

[19:23] <dalek> nqp/bs: 3169880 | jnthn++ | src/ (2 files):

[19:23] <dalek> nqp/bs: Last couple of fixes needed to get new multi-method stuff passing tests again.

[19:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/3169880b46

[19:23] <dalek> nqp/bs: 985e7d1 | jnthn++ | src/NQP/World.pm:

[19:23] <dalek> nqp/bs: Fix a thinko; gets us much further into deserializing NQPCORE.setting.

[19:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/985e7d1667

[19:23] <dalek> nqp/bs: 9cc8b4a | jnthn++ | src/6model/serialization.c:

[19:23] <dalek> nqp/bs: Fix some issues in type object deserialization.

[19:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/9cc8b4af2f

[19:23] <dalek> nqp/bs: 1b41ba7 | jnthn++ | src/NQP/World.pm:

[19:23] <dalek> nqp/bs: Add a missing $NEW_SER check, which gets us a little further into the build.

[19:23] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/1b41ba7c88

[19:26] *** mikemol joined
[19:28] *** MayDaniel left
[19:29] *** hundskat` left
[19:29] *** hundskatt left
[19:38] *** dbr joined
[19:39] *** icwiener left
[19:45] *** fridim_ left
[19:50] *** aindilis joined
[20:03] *** fridim_ joined
[20:09] *** mj41 joined
[20:09] <dalek> niecza: ade397a | sorear++ | src/ (4 files):

[20:09] <dalek> niecza: A first attempt to reduce parse tree data retention; does not help as much as I would like

[20:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ade397a9fa

[20:11] <sorear> looking at some output from the Mono heap profiler, it seems that the largest portion of the memory allocation is ... the LTM engine

[20:12] * masak is less than surprised

[20:12] <sorear> I am.  The LTM engine uses about 5% of the runtime but apparently accounts for around 50% of the heap load

[20:13] *** Trashlord left
[20:14] *** Trashlord joined
[20:15] <sorear> now I get to tackle the problem of the massively overlarge automatons that STD generates...

[20:20] *** pothos left
[20:22] *** y3llow joined
[20:22] *** pothos joined
[20:22] <dalek> rakudo/sink: c25fcb8 | moritz++ | /:

[20:22] <dalek> rakudo/sink: Merge branch 'sink', remote branch 'origin/sink' into sink

[20:22] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/c25fcb8db8

[20:22] <dalek> rakudo/sink: 8274182 | moritz++ | src/Perl6/Sinker.pm:

[20:22] <dalek> rakudo/sink: [sinker] recurse into nested blocks

[20:22] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/82741829c2

[20:24] <moritz> still doesn't run for-loops inside subs

[20:25] *** pothos left
[20:25] *** pothos joined
[20:29] *** Chillance left
[20:30] *** Chillance joined
[20:32] <dalek> nqp/bs: ba5e046 | jnthn++ | src/6model/serialization.c:

[20:32] <dalek> nqp/bs: Improve an error to aid debugging.

[20:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/ba5e046338

[20:32] <dalek> nqp/bs: 7876241 | jnthn++ | src/Regex.pir:

[20:32] <dalek> nqp/bs: Pop a couple of things from the PIR-based Regex engine into an SC, so we don't try and serialize things from here.

[20:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7876241b72

[20:32] <dalek> nqp/bs: 7c96cef | jnthn++ | src/6model/serialization.c:

[20:32] <dalek> nqp/bs: Another error tweak.

[20:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/7c96cef634

[20:32] <dalek> nqp/bs: 8768530 | jnthn++ | src/6model/serialization.c:

[20:32] <dalek> nqp/bs: On deserialization, make sure an SCs static code refs are all correctly annotated.

[20:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/87685306c4

[20:32] <dalek> nqp/bs: bacf8fb | jnthn++ | src/Regex (4 files):

[20:32] <dalek> nqp/bs: More SC fakery for the old PIR-based regex engine, so the serializer doesn't get upset over it (it's all throwaway once we bootstrap with QRegex anyway). With this, we now complete the build of NQP, with serialization/deserialization of compilation units along the way. The final executable doesn't actually work just yet, though the immediate cause is a known NYI. \o/

[20:32] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/bacf8fb458

[20:32] *** pmurias left
[20:33] *** localhost left
[20:34] <jnthn> moritz: If you put a say(...) before the call to visit_block does it ever run?

[20:34] <jnthn> moritz: btw, you can for @($block[0]) { ... } instead of the while loop :)

[20:34] <moritz> jnthn: yes (though not very often, about 5 to 10 times while compiling the setting)

[20:34] *** localhost joined
[20:35] <moritz> and can I then bind back into $_ and have the changes in $block[0][$i] ?

[20:35] <jnthn> moritz: Uh. We'd expect it to do it LOADS of time at the end though?

[20:35] <jnthn> moritz: No but...we don't ever replace the block wholesale, do we?

[20:36] <jnthn> moritz: That is, we only fiddle with stuff inside the block.

[20:36] <jnthn> So the binding of it there is probably useless anyway.

[20:36] <moritz> jnthn: well, I've changed the all the visit_ calls to return the modified value, since I was confused by the different ways that different visit_ blocks either return modified stuff or modified the arguments

[20:37] <jnthn> moritz: Heh. I had those cases very deliberately separated out in the optimizer to keep things sane. :)

[20:37] <moritz> :-)

[20:38] <jnthn> moritz: OK, here's my guess

[20:38] <jnthn> moritz: The few bits of output you're seeing are coming from when we do dynamic compilation

[20:38] <jnthn> moritz: Meaning that the final big sinkage at the end isn't doing much of anything.

[20:39] <dalek> rakudo/sink: 5705951 | moritz++ | src/core/traits.pm:

[20:39] <dalek> rakudo/sink: remove a workaround in "is export" trait. Now we can load Test.pm, but the underlying problem is not fixed

[20:39] <dalek> rakudo/sink: review: https://github.com/rakudo/rakudo/commit/5705951bc2

[20:39] <moritz> jnthn: yes, that's my guess too

[20:40] <moritz> also memory consumption would be much higher (due to many more PAST nodes) during compilation if it worked properly

[20:40] <jnthn> moritz: oh!

[20:41] <jnthn> moritz: Try passing $unit to Sinker in Actions, not $mainline

[20:41] <moritz> oh

[20:42] <moritz> but, don't I do a second pass over the whole setting then?

[20:43] <jnthn> moritz: oh, are you calling sinker from elsewhere too?

[20:43] * jnthn had thought it was a final pass at the end

[20:43] <moritz> well, I do one pass over the setting while compiling the setting

[20:43] <moritz> and I don't want to do a second pass while compiling a user program

[20:44] <moritz> erm, no, braino

[20:44] <moritz> nevermind

[20:44] <jnthn> moritz: :)

[20:44] <fsergot> nom: my Sub $s = sub { say 1; }; $s; $s();

[20:44] <p6eval> nom ac5d99: OUTPUT¬´1‚ê§¬ª

[20:44] <jnthn> nom: my Sub &s = sub { say 1; }; s; s(); # btw

[20:44] <p6eval> nom ac5d99: OUTPUT¬´Type check failed in assignment to '&s'; expected 'Callable' but got 'Sub'‚ê§  in block <anon> at /tmp/jnzDL3YhiD:1‚ê§‚ê§¬ª

[20:44] <jnthn> er :)

[20:45] <moritz> nom: say Sub ~~ Callable

[20:45] <p6eval> nom ac5d99: OUTPUT¬´True‚ê§¬ª

[20:45] <jnthn> nom: my &s = sub { say 1; }; s; s(); # btw

[20:45] <p6eval> nom ac5d99: OUTPUT¬´1‚ê§1‚ê§¬ª

[20:45] <jnthn> moritz: my Sub &s = ... would mean a sub that returns a Sub.

[20:45] <moritz> oh 'Sub &' is like Callable[Sub]

[20:45] <jnthn> Yeah

[20:45] <jnthn> That error reporting could most certainly be better.

[20:46] <sorear> there is one NFA in STD, with 18,760 states, that is generated from an |-alternation in some anonymous regex

[20:46] <moritz> wow

[20:47] <sorear> now I just need more instrumentation to figure out *which* anonymous regex :/

[20:49] *** zby_home___ joined
[20:49] <moritz> isn't that obvious from the states? :-)

[20:49] *** zby_home___ left
[20:50] *** whiteknight left
[20:50] *** whiteknight joined
[20:52] *** zby_home joined
[20:57] <masak> good night, #perl6

[20:57] <jnthn> sleep well, masak 

[20:57] <jnthn> moritz: btw, the reason i added that <sunk> thing the other day is to make sure that we don't re-sink things that got sunk due to dynamic comp.

[20:58] <moritz> sinking $unit instead of $mainline doesn't seem to have helped

[21:00] *** GlitchMr left
[21:01] * moritz runs out of ideas

[21:04] <jnthn> moritz: OK, I may get to look at it a bit later...

[21:04] <fsergot> Could somebody help me? :)

[21:04] <jnthn> fsergot: No. You're on your own.

[21:04] <jnthn> :P

[21:04] <jnthn> fsergot: Just ask. :)

[21:06] <fsergot> I have a class with $.subr, I want to assign to it a subroutine. How should i do this? :)

[21:07] <tadzik> object.subr = sub {}; assuming $.subr is rw

[21:07] <fsergot> I tried has Sub $.subr;

[21:07] <fsergot> And has &.subr;

[21:07] <jnthn> fsergot: Assign at what point?

[21:07] <tadzik> that's not necessary

[21:07] <jnthn> nom: class A { has $.subr }; my $x = A.new(subr => sub { say 42 }); $x.subr().()

[21:07] <p6eval> nom ac5d99: OUTPUT¬´42‚ê§¬ª

[21:08] <jnthn> fsergot: ^^ is one example

[21:08] <jnthn> fsergot: Note that $x.subr() won't call the sub - because the () are going to calling the accessor method.

[21:08] <fsergot> This is exactly what I want. :)

[21:08] *** plobsing joined
[21:08] <fsergot> Looks strange with. .() :)

[21:09] <fsergot> tadzik++, jnthn++ thanks. :)

[21:09] <jnthn> Welcome

[21:12] <fsergot> jnthn, another question... :)

[21:13] <fsergot> How can I execute $.subr in class' method?

[21:13] <jnthn> nom: class A { has $.subr; method exec { $.subr().() }; my $x = A.new(subr => sub { say 42 }); $x.exec

[21:13] <p6eval> nom ac5d99: OUTPUT¬´===SORRY!===‚ê§Unable to parse blockoid, couldn't find final '}' at line 2‚ê§¬ª

[21:13] <jnthn> oops

[21:14] <jnthn> nom: class A { has $.subr; method exec { $.subr().() } }; my $x = A.new(subr => sub { say 42 }); $x.exec

[21:14] <p6eval> nom ac5d99: OUTPUT¬´42‚ê§¬ª

[21:14] <jnthn> nom: class A { has $.subr; method exec { $!subr() } }; my $x = A.new(subr => sub { say 42 }); $x.exec

[21:14] <p6eval> nom ac5d99: OUTPUT¬´42‚ê§¬ª

[21:14] <fsergot> Ehh, it's clear now. :) Thank You.

[21:14] <jnthn> That second way is non-virtual.

[21:14] <jnthn> But may be what you want anyway ;)

[21:14] *** snearch joined
[21:15] <fsergot> jnthn, why $! ? What does it mean?

[21:15] <jnthn> fsergot: $!foo refers to the attribute storage slot in the object

[21:16] <jnthn> $.foo gets the attribute by calling the accessor method

[21:16] *** MayDaniel joined
[21:16] <jnthn> has $.foo; # actually like "has $!foo; method foo() { $!foo }"

[21:17] <fsergot> Great. thanks. :)

[21:21] <tadzik> nom: class A { has $.subr }; my $x = A.new(subr => sub { say 42 }); $x.subr.()

[21:21] <p6eval> nom ac5d99: OUTPUT¬´42‚ê§¬ª

[21:21] <sorear> moritz: looking at the states makes me think it's the condition in 'signature'. I think I have some overzealous 'anonymous regex' checking

[21:22] <sorear> moritz: in [ <a> || <b> ], is <a> supposed to be visible to LTM?  Does it say one way or the other anywhere?

[21:24] <moritz> sorear: I have no idea

[21:25] <jnthn> fwiw, I'm pretty sure QRegex votes "no" here

[21:29] <dalek> niecza: 5f47b81 | sorear++ | src/STD.pm6:

[21:29] <dalek> niecza: Fix inside of [ ] being treated as anonymous

[21:29] <dalek> niecza: review: https://github.com/sorear/niecza/commit/5f47b81a04

[21:30] <sorear> All I know is I've gone back and forth on this a few times :|

[21:33] *** dbr left
[21:38] *** ab5tract left
[21:38] *** conntrack joined
[21:44] *** awwaiid joined
[21:46] *** kaare_ left
[21:47] <dalek> niecza: 94ee991 | sorear++ | lib/Cursor.cs:

[21:47] <dalek> niecza: Add a less verbose way to get node count info

[21:47] <dalek> niecza: review: https://github.com/sorear/niecza/commit/94ee9913c2

[21:49] <dalek> roast: 5adcc30 | coke++ | / (12 files):

[21:49] <dalek> roast: pugs fudge

[21:49] <dalek> roast: review: https://github.com/perl6/roast/commit/5adcc30ba9

[21:52] <dalek> Pugs.hs: 23b7d35 | coke++ | t/spectest.data:

[21:52] <dalek> Pugs.hs: run more fudged tests

[21:52] <dalek> Pugs.hs: review: https://github.com/perl6/Pugs.hs/commit/23b7d35dc8

[21:52] <dalek> nqp/bs: 83d190d | jnthn++ | src/6model/serialization.c:

[21:52] <dalek> nqp/bs: Serialize mode flags.

[21:52] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/83d190d10a

[21:52] <dalek> nqp/bs: 96892f6 | jnthn++ | src/NQP/World.pm:

[21:52] <dalek> nqp/bs: We don't want to serialize the Parrot-specific vtable mapping stuff, so make sure we fix it up after deserialization.

[21:52] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/96892f60c6

[21:52] <dalek> nqp/bs: 067d904 | jnthn++ | src/6model/serialization.c:

[21:52] <dalek> nqp/bs: Serialize/deserialize boolification spec. Now we get an NQP executable that basically works.

[21:52] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/067d90448d

[21:52] <dalek> nqp/bs: 25e15e6 | jnthn++ | src/NQP/World.pm:

[21:52] <dalek> nqp/bs: Turn on serializer by default now. Some tests fail...triage time.

[21:52] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/25e15e6ce5

[21:54] <[Coke]> "total",      2760,     2,  1426,    12,  4200, 23233

[21:54] <[Coke]> (pugs)

[21:57] <sorear> % of rakudo? :)

[21:57] <sorear> perl6: say ("foobar" ~~ / foo | foobar /)

[21:57] <p6eval> niecza v14-48-gade397a: OUTPUT¬´#<match from(0) to(6) text(foobar) pos([].list) named({}.hash)>‚ê§¬ª

[21:57] <p6eval> ..rakudo ac5d99: OUTPUT¬´=> <foo>‚ê§‚ê§¬ª

[21:57] <p6eval> ..pugs b927740: OUTPUT¬´Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {‚ê§    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20111008/blib6/pugs/perl5/lib';‚ê§    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;‚ê§}‚ê§'Pugs::Runtime::Match::HsBridge'‚ê§"‚ê§*** '<HAND‚Ä¶

[21:58] <sorear> perl6: grammar G { token TOP:foo { foo } ; token TOP:foobar { foobar } } ; say G.parse("foobar")

[21:58] <p6eval> pugs b927740: OUTPUT¬´*** No such method in class G: "&parse"‚ê§    at /tmp/jyYWX7RZ9B line 1, column 73 - line 2, column 1‚ê§¬ª

[21:58] <p6eval> ..niecza v14-48-gade397a: OUTPUT¬´#<match from(0) to(6) text(foobar) pos([].list) named({}.hash)>‚ê§¬ª

[21:58] <p6eval> ..rakudo ac5d99: OUTPUT¬´Method 'TOP' not found for invocant of class 'G'‚ê§  in method parse at src/gen/CORE.setting:8006‚ê§  in block <anon> at /tmp/pqFnkr5Y__:1‚ê§‚ê§¬ª

[21:58] <sorear> perl6: grammar G { proto token TOP {*} ; token TOP:foo { foo } ; token TOP:foobar { foobar } } ; say G.parse("foobar")

[21:58] <p6eval> niecza v14-48-gade397a: OUTPUT¬´#<match from(0) to(6) text(foobar) pos([].list) named({}.hash)>‚ê§¬ª

[21:58] <p6eval> ..rakudo ac5d99: OUTPUT¬´#<failed match>‚ê§¬ª

[21:58] <p6eval> ..pugs b927740: OUTPUT¬´*** No such method in class G: "&parse"‚ê§    at /tmp/7ExKliFxsR line 1, column 95 - line 2, column 1‚ê§¬ª

[21:59] <sorear> Why is rakudo failing?

[22:00] <jnthn> Needs to be TOP:sym<foo>

[22:00] <sorear> perl6: grammar G { proto token TOP {*} ; token TOP:sym<foo> { foo } ; token TOP:sym<foobar> { foobar } } ; say ~G.parse("foobar")

[22:00] <p6eval> pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "<foo"‚ê§    expecting ":", "is" or "{"‚ê§    at /tmp/zzvFGMHoZf line 1, column 48‚ê§¬ª

[22:00] <p6eval> ..rakudo ac5d99, niecza v14-48-gade397a: OUTPUT¬´foobar‚ê§¬ª

[22:00] <sorear> perl6: grammar G { proto token TOP {*} ; token TOP:sym<foo> { foo } ; token TOP:sym<foobar> { foobar || foobar } } ; say ~G.parse("foobar")

[22:00] <p6eval> rakudo ac5d99: OUTPUT¬´foo‚ê§¬ª

[22:00] <p6eval> ..pugs b927740: OUTPUT¬´*** ‚ê§    Unexpected "<foo"‚ê§    expecting ":", "is" or "{"‚ê§    at /tmp/XViFSsb5WL line 1, column 48‚ê§¬ª

[22:00] <p6eval> ..niecza v14-48-gade397a: OUTPUT¬´foobar‚ê§¬ª

[22:00] <sorear> jnthn: I'm curious why

[22:01] <jnthn> We've never had the TOP:foo sugar in NQP or Rakudo

[22:01] <jnthn> I forget exactly what Pm said about it. :)

[22:02] <jnthn> Probably ain't so hard to implement.

[22:04] *** szabgab_ is now known as szabgab

[22:05] <jnthn> sorear: oh, or did you meant the behavior just a moment ago?

[22:06] <jnthn> sorear: In that case - because the NFA builder simply doesn't pay any attention to alt_seq

[22:09] <sorear> No, I meant TOP:foo.

[22:09] <jnthn> ah, OK

[22:10] <sorear> "Whitespace required after keyword" sub none (*@p) is pure { no‚èène @p }

[22:11] <sorear> apparently, making that change to SeqAlt *does* break STD

[22:11] <jnthn> Ah. Then I can probably take that to mean that Rakudo's seq_alt behavior is wrong.

[22:13] <sorear> or maybe niecza's STD is just brokenly depending on nieczabugs.

[22:14] <jnthn> Also possible; I was guessing you'd copied STD's interpretation of seq_alt somewhere though, and STD tends to be good as spec in many cases...

[22:15] <dalek> nqp/bs: 08757d6 | jnthn++ | src/NQP/World.pm:

[22:15] <dalek> nqp/bs: Various fixes to handling of code refs. NQP with the serializer now passes all of t\nqp. \o/ Doesn't mean were there yet, mind; role serialization is still busted, meaning that QRegex can't be compiled. But...closer.

[22:15] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/08757d6000

[22:15] * sorear pokes TimToady

[22:15] <jnthn> s/were/we're/

[22:17] *** tarch joined
[22:24] *** MayDaniel left
[22:28] <dalek> nqp/bs: bbe4085 | jnthn++ | src/NQP/World.pm:

[22:28] <dalek> nqp/bs: Remove option to use the serializer (it's always on now) and all old deserialization code gen for NQP, which muchly clears up World.pm.

[22:28] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/bbe4085ca9

[22:33] <benabik> It would be interesting if dalek reported basic diffstat information...

[22:33] <benabik> 39 additions and 263 deletions (for bbe4085)

[22:38] <fsergot> "Incorrect pre-compiled version of src/gen/Metamodel.pm loaded"

[22:38] <fsergot> What can I do with this? :)

[22:39] <fsergot> I have nom v. 2012.01-152

[22:39] <jnthn> fsergot: Probably means you've some pre-compiled .pir module.

[22:39] <jnthn> (Which is now out of date)

[22:39] <fsergot> IO::Select probably

[22:40] <fsergot> It's the only module I use in this script.

[22:41] <sorear> niecza: no$a

[22:41] <p6eval> niecza v14-50-g94ee991: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Two terms in a row (listop with args requires whitespace or parens) at /tmp/4gXhl04eTS line 1:‚ê§------> [32mno[33m‚èè[31m$a[0m‚ê§‚ê§Undeclared routine:‚ê§    'no' used at line 1‚ê§‚ê§Parse failed‚ê§‚ê§¬ª

[22:41] <sorear> niecza: my$a

[22:41] <p6eval> niecza v14-50-g94ee991: OUTPUT¬´Potential difficulties:‚ê§  $a is declared but not used at /tmp/HEHpoo98mO line 1:‚ê§------> [32mmy[33m‚èè[31m$a[0m‚ê§‚ê§¬ª

[22:41] <sorear> niecza: if2

[22:41] <p6eval> niecza v14-50-g94ee991: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§‚ê§Undeclared routine:‚ê§     'if2' used at line 1‚ê§‚ê§Unhandled exception: Check failed‚ê§‚ê§  at /home/p6eval/niecza/boot/lib/CORE.setting line 1344 (die @ 3) ‚ê§  at /home/p6eval/niecza/src/STD.pm6 line 1147 (P6.comp_unit @ 33) ‚ê§  at /home‚Ä¶

[22:42] <sorear> std: if$a { }

[22:42] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Two terms in a row (listop with args requires whitespace or parens) at /tmp/FK8q2fxHE4 line 1:‚ê§------> [32mif[33m‚èè[31m$a { }[0m‚ê§    expecting any of:‚ê§   POST‚ê§   argument list‚ê§  bracketed infix‚ê§        infix or meta-infix‚ê§    postfix‚ê§       

[22:42] <p6eval> ..postfix_prefi‚Ä¶

[22:42] <sorear> std: no+5

[22:42] <p6eval> std 52f3895: OUTPUT¬´[31m===[0mSORRY![31m===[0m‚ê§Undeclared routine:‚ê§ 'no' used at line 1‚ê§Check failed‚ê§FAILED 00:01 109m‚ê§¬ª

[22:56] *** fridim_ left
[22:56] <dalek> nqp/bs: 790fc9a | jnthn++ | src/6model/serialization.c:

[22:56] <dalek> nqp/bs: Use a seen hash to avoid duplicate strings in the string heap.

[22:56] <dalek> nqp/bs: review: https://github.com/perl6/nqp/commit/790fc9a4db

[22:57] *** tokuhirom3 joined
[22:58] *** mj41 left
[22:59] *** thou left
[23:00] <jnthn> Enough for today... o/

[23:01] <tadzik> o/

[23:06] *** Trashlord left
[23:13] *** pernatiy joined
[23:16] *** PacoAir left
[23:24] <sorear> phenny: tell TimToady I would like explicit confirmation that in [ <a> || <b> ], <a> is supposed to be visible to LTM.

[23:24] <phenny> sorear: I'll pass that on when TimToady is around.

[23:25] <sorear> having changed the behavior, STD is quite completely broken.  This is not an easy fix.

[23:25] *** y3llow left
[23:26] *** pothos left
[23:27] *** pothos joined
[23:28] *** y3llow joined
[23:29] *** pothos left
[23:30] *** pothos joined
[23:30] *** y3llow left
[23:30] <sorear> There is a problem in that LTM automatons are often far too "rich", modelling the grammar to a much greater extent than is really needed

[23:30] *** y3llow joined
[23:32] *** tarch left
[23:32] *** pothos left
[23:32] *** y3llow left
[23:33] *** pothos joined
[23:33] *** y3llow joined
[23:35] *** y3llow left
[23:35] *** y3llow joined
[23:35] *** pothos_ joined
[23:37] *** pothos left
[23:38] *** pothos_ is now known as pothos

[23:44] *** sftp left
[23:47] *** sftp joined
[23:50] *** sftp left
[23:55] *** sftp joined
[23:58] *** Trashlord joined
[23:59] *** shinobicl___ joined
