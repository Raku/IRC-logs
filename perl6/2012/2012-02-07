[00:01] *** jevin joined
[00:01] *** tarch joined
[00:02] *** tarch left
[00:04] <TimToady> perl6: say (1 ... *) min (2 ... *)

[00:05] <p6eval> rakudo 33fb02, niecza v14-19-g256172a: OUTPUT«(timeout)»

[00:05] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected " min"␤    at /tmp/2q4vFjni03 line 1, column 14␤»

[00:05] <TimToady> perl6: say [1 ... 5] min [2 ... 6]

[00:05] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "["␤    expecting bare or pointy block construct, ":", identifier or operator␤    at /tmp/412ncUxsUC line 1, column 5␤»

[00:05] <p6eval> ..rakudo 33fb02, niecza v14-19-g256172a: OUTPUT«1 2 3 4 5␤»

[00:05] <TimToady> but...

[00:05] <TimToady> perl6: say ([1 ... *] min [2 ... *])[^20]

[00:06] <p6eval> niecza v14-19-g256172a: OUTPUT«(timeout)»

[00:06] <p6eval> ..rakudo 33fb02: OUTPUT«2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21␤»

[00:06] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "["␤    expecting expression or ")"␤    at /tmp/HDgLNYfup2 line 1, column 6␤»

[00:06] <TimToady> rakudo is closest to correct, but, er, not

[00:07] <TimToady> perl6: say [1 ... 5] min [2 ... 4]

[00:07] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "["␤    expecting bare or pointy block construct, ":", identifier or operator␤    at /tmp/gPrXS_9SYU line 1, column 5␤»

[00:07] <p6eval> ..niecza v14-19-g256172a: OUTPUT«2 3 4␤»

[00:07] <p6eval> ..rakudo 33fb02: OUTPUT«1 2 3 4 5␤»

[00:08] <TimToady> rakudo: say [1 ... *] cmp [2 ... *]

[00:08] <p6eval> rakudo 33fb02: OUTPUT«-1␤»

[00:09] <TimToady> oops, missing Order enum...

[00:10] <TimToady> but if it's correctly an Increase, why is min picking the max of 1...* and 2...*

[00:11] <TimToady> (and why doesn't it work with () lists instead of [], if list comparisons are done lazily?)

[00:12] <doy> [1 ... *] cmp [2 ... *] should clearly be 0, shouldn't it?

[00:13] <TimToady> no, Positionals should compare position by position until a difference is found, so it should return after only examining the first position

[00:14] <TimToady> (s)

[00:14] *** bluescreen100 joined
[00:15] <TimToady> this is obviously what it is doing in the finite case, since it correctly returns 1...5

[00:15] *** rgrau left
[00:15] <TimToady> nom: say ([1 ... *] min [2 ... 5])[^20]

[00:15] <p6eval> nom 33fb02: OUTPUT«2 3 4 5 Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any()␤»

[00:16] <TimToady> that's just wrong

[00:16] <TimToady> nom: say ([1 ... 5] min [2 ... *])[^20]

[00:16] <p6eval> nom 33fb02: OUTPUT«1 2 3 4 5 Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any() Any()␤»

[00:16] <TimToady> that's correct

[00:16] <TimToady> well, except that [^20] should probably be autotrimming

[00:18] <TimToady> or maybe it's only infinite ranges that autotruncate these days, hmm

[00:19] <TimToady> nom: say ([1 ... 5] min [2 ... *]).munch(20)

[00:19] <p6eval> nom 33fb02: OUTPUT«1 2 3 4 5␤»

[00:19] <TimToady> I guess there's that

[00:20] <TimToady> nom: say munch 20, [1 ... 5] min [2 ... *]

[00:20] <p6eval> nom 33fb02: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&munch' called (line 1)␤»

[00:20] <TimToady> aww

[00:22] <TimToady> perl6: say 1 => 2 => 3 min 2 => 3 => 4;

[00:22] <p6eval> rakudo 33fb02, niecza v14-19-g256172a: OUTPUT«1 => 2 => 2 => 3 => 4␤»

[00:22] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "min"␤    expecting operator, ":" or ","␤    at /tmp/f_ATPAavE4 line 1, column 17␤»

[00:23] <TimToady> oops

[00:23] <TimToady> perl6: say (1 => 2 => 3) min (2 => 3 => 4);

[00:23] <p6eval> pugs b927740: OUTPUT«*** ␤    Unexpected "min"␤    expecting operator, ":" or ","␤    at /tmp/tAEpV2uIbW line 1, column 19␤»

[00:23] <p6eval> ..rakudo 33fb02, niecza v14-19-g256172a: OUTPUT«1 => 2 => 3␤»

[00:26] <TimToady> perl6: my $a; my $l = 1 => 2 => $a; $a = 3 => 4; $l = $l.value; say $l

[00:26] <p6eval> niecza v14-19-g256172a: OUTPUT«2 => 3 => 4␤»

[00:26] <p6eval> ..pugs b927740: OUTPUT«2  ␤»

[00:26] <p6eval> ..rakudo 33fb02: OUTPUT«2 => Any␤»

[00:26] <TimToady> niecza++

[00:26] <TimToady> (can do cons lists that can GC the head when no longer referenced)

[00:27] <TimToady> probably need to maintain $a = Nil on the end to keep pushing though

[00:35] *** Trashlord left
[01:00] <sorear> good * #perl6

[01:30] * TimToady wonders if there's any way to generate a => list lazily using ...

[01:34] *** tokuhirom left
[01:45] *** scott__ joined
[01:47] *** Chillance left
[02:06] <colomon> \o

[02:08] <colomon> niecza: say ('a' => 1, { .key++ => .value++ } ... *.value > 10).perl

[02:08] <p6eval> niecza v14-19-g256172a: OUTPUT«Unhandled exception: Unable to resolve method key in class Any␤  at /tmp/eTJ5Jb_Nur line 1 (mainline @ 4) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3705 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3706 (module-CORE @ 65) ␤  at /home/p6…

[02:09] <colomon> niecza: say ('a' => 1, -> $p { $p.key++ => $p.value++ } ... *.value > 10).perl

[02:09] <p6eval> niecza v14-19-g256172a: OUTPUT«Unhandled exception: Writing to readonly scalar␤  at /tmp/CV9TWjT2tU line 1 (ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2988 (ANON @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2995 (ANON @ 17) ␤  at <unknown> line 0 (KERNEL dogather …

[02:29] *** bluescreen100 left
[02:29] *** bluescreen10 left
[02:54] *** whiteknight left
[02:56] *** woosley joined
[03:01] <dalek> niecza: 18249a6 | (Solomon Foster)++ | lib/CORE.setting:

[03:01] <dalek> niecza: Improve (?) KeyBag.new, tweaks to a bunch of KeyBag routines, O(number of different keys) routine for KeyBag.pick and KeyBag.roll.

[03:01] <dalek> niecza: review: https://github.com/sorear/niecza/commit/18249a6ec0

[03:01] <dalek> roast: c46f211 | (Solomon Foster)++ | S02-types/keybag.t:

[03:01] <dalek> roast: Another 44 tests.

[03:01] <dalek> roast: review: https://github.com/perl6/roast/commit/c46f2119b9

[03:09] <colomon> sorear: running a proper timing now, but I'd swear a spectest run takes twice as long as it did a week ago.

[03:12] *** benabik left
[03:12] <TimToady> niecza: say <a b c> ∪ <b c d>

[03:12] <p6eval> niecza v14-20-g18249a6: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Confused at /tmp/gFVtTuIflF line 1:␤------> [32msay <a b c> [33m⏏[31m∪ <b c d>[0m␤␤Parse failed␤␤»

[03:12] * TimToady wants that to work

[03:15] <colomon> TimToady: sorry, I wasn't able to get the operators to work on the first go

[03:15] <colomon> I've been meaning to get back to it, but the basic functionality for all of them isn't in place yet

[03:18] <sjn> rakudo: say <a b c> ∪ <b c d>

[03:18] <p6eval> rakudo 33fb02: OUTPUT«===SORRY!===␤Confused␤at /tmp/DZx2lmeptV:1␤»

[03:18] *** benabik joined
[03:18] <sjn> aw :-(

[03:18] * sjn likes that thought too

[03:18] * colomon needs to port the KeyBag tests / fixes back to Bag

[03:19] <TimToady> well, I like the way you're doing it better than the way I'm not doing it. :)

[03:20] <colomon> Actually, that does bring up a question, as long as I've got your ear

[03:20] <TimToady> yessir

[03:21] <colomon> right now IO

[03:21] <colomon> 'v

[03:21] <colomon> try that again

[03:22] *** jferrero left
[03:23] <colomon> right now I've got KeyBag.new set up so it's a slurpy list, and if any of the components of the list are Sets, Bags, KeyBags, KeySets, Hashes, or Pairs, it treats them like you wanted to add the components of that object to the KeyBag

[03:23] <TimToady> as opposed to their keys

[03:23] <colomon> no, I mean it adds the key / value pairs.

[03:23] *** wolfman2000 joined
[03:23] <TimToady> which is different from how hash assignment works

[03:24] <colomon> like KeyBag.new(set <a b c>, set<a c d>) would give you a=>2, b=>1, c=>2, d

[03:24] <TimToady> you mean it adds the pair as a key?

[03:24] <colomon> no, it splits up the Pair into key and value

[03:24] <TimToady> I think that's probably right

[03:24] *** jferrero joined
[03:25] <TimToady> I don't think we should optimize for sets of sets and such

[03:25] <colomon> yeah, that's what I was wondering about

[03:25] <TimToady> can always add (foo => bar) => True

[03:25] <TimToady> generally we want to optimize for sets of values, I think

[03:26] <colomon> okay, great, that's how I've been doing it.

[03:26] <TimToady> well, it should really fall out of list context anyway that way

[03:26] <TimToady> since in list context a set or a bag is not the pairs

[03:26] <TimToady> just hte keys

[03:26] <TimToady> *th

[03:26] <colomon> hmmm, really?

[03:26] <colomon> I've got it that way for sets, but not for bags.  

[03:27] <TimToady> niecza: say join ',', set <a b c>

[03:27] <p6eval> niecza v14-20-g18249a6: OUTPUT«set(< a b c >)␤»

[03:27] <TimToady> that's not right

[03:27] <colomon> well, I thought I had it that way for sets...

[03:27] <colomon>     method list() { %!elems.keys }

[03:27] <TimToady> say join ',', set(<a b c>).list

[03:28] <TimToady> niecza: say join ',', set(<a b c>).list

[03:28] <p6eval> niecza v14-20-g18249a6: OUTPUT«a,b,c␤»

[03:28] <TimToady> that's more like

[03:28] <TimToady> but I don't think the .list should be necessary, by spec

[03:28] <colomon> you think Bag.list should do the same, rather than being a=>1, b=>1, c=>1?

[03:28] <sorear> colomon: a timing run wouldn't do much good unless you can also find out _why_

[03:29] <sorear> colomon: also, please don't leave notes here and expect me to read them

[03:29] <colomon> sorear: it will at least establish I'm not dreaming.

[03:29] <sorear> colomon: I *won't*

[03:29] <TimToady> colomon: yes, you can always ask for .pairs if you want it

[03:29] <colomon> sorear: oh, okay

[03:29] <sorear> I don't have time this week/month/semester

[03:30] *** jaldhar joined
[03:30] <colomon> sorear: I'll try to get a proper binary search for the slowdown going tomorrow, if I have time.  

[03:30] <TimToady> niecza: my %set := set < a b c >; say %set

[03:30] <p6eval> niecza v14-20-g18249a6: OUTPUT«set(a, b, c)␤»

[03:30] <colomon> sorear: would you prefer I leave messages for you with phenny or e-mail?  Or should I just not bug you for a month?

[03:30] <TimToady> that should flatten

[03:31] <TimToady> niecza: my $set := set < a b c >; say $set

[03:31] <p6eval> niecza v14-20-g18249a6: OUTPUT«set(a, b, c)␤»

[03:31] <TimToady> that shouldn't

[03:34] <sorear> colomon: email's better because I can save emails

[03:34] <colomon> sorear: okay

[03:34] <skids> What should I be setting to make niecza's '@path' happy?

[03:34] <colomon> skids: for "use" paths? 

[03:34] <skids> yes

[03:35] <colomon> skids: -Idir

[03:35] <colomon> so mono run/Niecza.exe -Ilib (for instance)

[03:35] <skids> thx colomon++

[03:36] <colomon> sorear: okay, I've got a timing.  remember me saying it took me 5 minutes to run a spectest a few weeks ago?  Well, it's 24 minutes now.  Like I said, I'll bisect things looking for the slowdown ASAP.

[03:38] <colomon> TimToady: thanks for the help

[03:43] *** am0c joined
[03:47] <sorear> colomon: thanks a lot

[03:50] *** orafu left
[03:50] *** orafu joined
[03:53] *** Transformer joined
[03:53] *** Transformer left
[03:59] *** Psyche^ joined
[03:59] *** Psyche^ is now known as Patterner

[04:03] *** Patterner left
[04:04] *** Psyche^ joined
[04:04] *** Psyche^ is now known as Patterner

[04:23] *** Su-Shee_ joined
[04:27] *** Su-Shee left
[04:27] *** xinming left
[04:28] *** Patterner left
[04:31] *** Psyche^ joined
[04:31] *** Psyche^ is now known as Patterner

[04:33] *** chee is now known as bot-chee

[04:34] *** bot-chee is now known as chee

[04:37] *** xinming joined
[04:39] *** am0c left
[04:56] *** Patterner left
[04:58] *** Psyche^ joined
[04:58] *** Psyche^ is now known as Patterner

[05:02] *** birdwindupbird joined
[05:24] *** Patterner left
[05:24] *** Psyche^ joined
[05:24] *** Psyche^ is now known as Patterner

[05:54] *** Patterner left
[05:55] <moritz> o/

[05:55] *** Psyche^ joined
[05:55] *** Psyche^ is now known as Patterner

[05:56] <sorear> o/

[06:07] *** Patterner left
[06:15] *** Psyche^ joined
[06:15] *** Psyche^ is now known as Patterner

[06:17] *** koban joined
[06:17] *** koban left
[06:25] *** ruoso left
[06:33] *** ruoso joined
[06:40] *** 13WAAFDVP left
[06:40] *** tarch joined
[07:04] *** dbr joined
[07:09] *** GlitchMr joined
[07:11] *** Patterner left
[07:11] *** Psyche^ joined
[07:11] *** Psyche^ is now known as Patterner

[07:19] *** wtw joined
[07:22] <masak> o/

[07:24] <sorear>  /o

[07:38] <jnthn> wtf, it's already morning again...

[07:38] <phenny> jnthn: 06 Feb 22:50Z <not_gerd> tell jnthn turns out what I'm proposing is actually the addition of a second meta-object which only known how to deal with a fixed set of parrot-specific messages

[07:38] <phenny> jnthn: 06 Feb 22:50Z <not_gerd> tell jnthn feel free to leave a comment at the gist instead of leaving a note with phenny 

[07:38] <jnthn> I mean, er, good morning #perl6

[07:39] *** benabik left
[07:39] <moritz> mrning jnthn

[07:40] *** benabik joined
[07:46] <masak> mornington, Worthingwon.

[07:47] <masak> *Worthington

[07:50] <sorear> masak++ # finally got around to reading ze psyde post.

[07:50] <masak> ooh, feedback :)

[07:50] <masak> thanks for that.

[07:51] <masak> yeah, I need to push myself to do these things. I'm happy about my blog, but I've realized I won't ever reach those goals without predeclaring them.

[07:52] *** Patterner left
[07:56] *** PacoAir joined
[07:59] <jnthn> masak: bleh, I ain't staying at the mornington this time...

[07:59] <jnthn> I'm at this other place 30 mins away

[08:01] <masak> pun fail :)

[08:03] <jnthn> At least I could use the metro

[08:03] <jnthn> But it seems so crappy compared to the Moscow one.

[08:03] <jnthn> ok, time for class :)

[08:05] <masak> every metropolitan railway system -- except for maybe Tokyo's and/or Seoul's -- seems crappy compared to Moscow's.

[08:06] <masak> I mean, you can't beat a marbled underground castle with stairs and chandeliers. you just can't.

[08:06] <bonsaikitten> masak: tried shanghai? they are doing a pretty good job at getting there

[08:07] <bonsaikitten> including the fastest maglev train to connect the airport with some random place outside the city

[08:08] *** PacoAir left
[08:10] *** Su-Shee_ is now known as Su-Shee

[08:14] *** bbkr1 left
[08:14] *** GlitchMr left
[08:17] <masak> no, haven't tried Shanghai yet. sounds like another place that might be doing pretty well on the metro scale, though.

[08:18] <bonsaikitten> largest metro system these days in terms ok track length, and I think they are #1 with passengers too

[08:22] <tadzik> 'morning

[08:23] <masak> morning-tadzik! \o/

[08:28] *** DrEeevil joined
[08:29] *** bonsaikitten left
[08:30] *** broquaint joined
[08:34] *** DrEeevil is now known as bonsaikitten

[08:36] *** mj41 joined
[08:37] *** woosley left
[08:43] *** bonsaikitten left
[08:43] *** bonsaikitten joined
[08:44] <cognominal_> Calvin or TimToady? :) "verbing weird languages"

[08:47] *** snearch joined
[08:47] <masak> both Calvin and TimToady uses "verb" as a verb quite a bit, I believe.

[08:48] <masak> it's a delightful habit. I should habit verbing a bit more myself, I believe.

[08:48] <masak> use*

[08:48] <moritz> right, we don't verb enough!

[08:49] <cognominal_> we don't weird enough either.

[08:51] *** am0c joined
[08:56] *** woosley joined
[08:58] * masak ponders whether we language enough

[08:59] <masak> I just realized that the majority of "how many <X> does it take to screw in a light bulb?" jokes qualify as autopuns.

[09:00] <moritz> nom: my @a = <a b c d e f g>; my $start = 2; my $dir = -1; say @a[$start, { ($_ + $dir) % @a ...^ $start]

[09:00] <p6eval> nom 33fb02: OUTPUT«===SORRY!===␤Unable to parse blockoid, couldn't find final '}' at line 2␤»

[09:00] <moritz> nom: my @a = <a b c d e f g>; my $start = 2; my $dir = -1; say @a[$start, { ($_ + $dir) % @a} ...^ $start]

[09:00] <p6eval> nom 33fb02: OUTPUT«␤»

[09:01] <moritz> huh?

[09:01] <moritz> nom: my @a = <a b c d e f g>; my $start = 2; my $dir = -1; say $start, { ($_ + $dir) % @a} ...^ $start

[09:01] <p6eval> nom 33fb02: OUTPUT«␤»

[09:01] <moritz> nom: my @a = <a b c d e f g>; my $start = 2; my $dir = 1; say $start, { ($_ + $dir) % @a} ...^ $start

[09:01] <p6eval> nom 33fb02: OUTPUT«␤»

[09:01] <moritz> why is that empty?

[09:02] <moritz> nom: my @a = <a b c d e f g>; my $start = 2; my $dir = 1; say ($start, { ($_ + $dir) % @a} ...^ $start).perl

[09:02] <sorear> aggressive trimming is my guess

[09:02] <p6eval> nom 33fb02: OUTPUT«().list␤»

[09:02] <sorear> TimToady has in the past expected ...^ to be as lazy as possible

[09:03] <sorear> I doubt it even *sees* the generator, rather aborting during the literal prefix

[09:03] <moritz> oh.

[09:03] <masak> nom: say .for 1, * + 1 ...^ 1

[09:03] <p6eval> nom 33fb02: OUTPUT«===SORRY!===␤Confused␤at /tmp/UWNiZ0VVuw:1␤»

[09:03] <sorear> .say for

[09:03] <masak> nom: .say for 1, * + 1 ...^ 1

[09:03] <p6eval> nom 33fb02:  ( no output )

[09:03] <masak> nom: .say for 1, * + 1 ...^ 1; say "alive"

[09:03] <p6eval> nom 33fb02: OUTPUT«alive␤»

[09:04] <moritz> niecza: .say for 1, * + 1 ...^ 1; say "alive"

[09:04] <p6eval> niecza v14-20-g18249a6: OUTPUT«alive␤»

[09:04] <masak> moritz: I think it's because it figures "oh, 1 already, and then don't print the 1".

[09:04] <moritz> maybe we should change that?

[09:04] <masak> moritz: so it's the *same* 1 in some sense.

[09:04] <moritz> masak: right

[09:04] <moritz> masak: but is it useful as is?

[09:04] <masak> moritz: I dunno, could go both ways on what's actually right here.

[09:04] <masak> it feels wrong in this use case.

[09:04] <masak> might be just right in others.

[09:04] <moritz> right

[09:04] <masak> try changing it in nom and see what spectests fail :)

[09:04] <sorear> but we're very constrained by the maximal-laziness thing

[09:05] <sorear> I don't think TimToady's prime generating one-liner is an actual spectest but he whined when I broke it in niecza last :p

[09:05] <masak> nom: my @a = 1..10; .say for @a ...^ 5

[09:05] <moritz> the thing that feels wrong is that the LHS of the ... does not appear in the output

[09:05] <p6eval> nom 33fb02: OUTPUT«1␤2␤3␤4␤»

[09:05] * sorear zzz

[09:06] <masak> good zzz, sorear.

[09:06] <moritz> dream of repeated characters :-)

[09:06] <masak> :)

[09:07] <timotimo> nom: sub postfix:<zzz>($a) { say "$_ little fluffy sheeple..." for 0 .. * }; "sorear"zzz;

[09:08] <p6eval> nom 33fb02: OUTPUT«(timeout)0 little fluffy sheeple...␤1 little fluffy sheeple...␤2 little fluffy sheeple...␤3 little fluffy sheeple...␤4 little fluffy sheeple...␤5 little fluffy sheeple...␤6 little fluffy sheeple...␤7 little fluffy sheeple...␤8 little fluffy sheeple...␤9 little fluffy …

[09:08] <timotimo> hm, zzz is pure, i could make repeated usages of it faster with memoization!

[09:09] <timotimo> well, not only pure, but constant

[09:09] <moritz> timotimo: pure? it produces output

[09:09] <timotimo> ... excuse me, i'll go wake up before producing any more code/text

[09:13] <moritz> nom: say 'foo'; say $*OUT.tell

[09:13] <p6eval> nom 33fb02: OUTPUT«foo␤4␤»

[09:14] <timotimo> oh, that's cute, $*OUT behaves like a file?

[09:14] <moritz> well, it's an IO handle

[09:14] <timotimo> can i seek backwards, though? or does it only do it if i tell it to buffer everything?

[09:14] <moritz> you can't seek in a stream

[09:14] <timotimo> well, i suppose the right question would be if i can read from it

[09:14] <timotimo> probably not, then

[09:14] <moritz> no, it's opened for writing only

[09:15] <moritz> you like you can't read from open('foo', :w)

[09:15] <moritz> s/you/just/

[09:17] *** chee left
[09:23] <masak> I just got a great idea for a module: InPlaceIO.

[09:23] <masak> it basically removes all the boilerplate for when you want to do 'perl -i'-like processing inside a program.

[09:24] <masak> InPlaceIO.open($filename).grep($regex).map(&transformation).save;

[09:25] <moritz> +1

[09:25] <moritz> though I'd factor it a bit differently

[09:25] <moritz> InPlaceIO.new(:$filename).map: { ... }

[09:25] <moritz> or maybe don't call it 'map'

[09:25] *** am0c left
[09:26] *** dakkar joined
[09:26] <moritz> reasons:

[09:26] <moritz> 1) dealing propery with exceptions

[09:27] <moritz> 2) if you just get a lazy list and return one, you aren't restricted to return stuff that can .save

[09:27] <moritz> hm, then that doesn't even need to be OOish

[09:27] <moritz> in-place($filename, &closure);

[09:29] <masak> ooh, I like that one best.

[09:29] <masak> the fluent interface was a red herring in this case.

[09:30] <tadzik> lovely!

[09:30] <moritz> I know, but I couldn't miss the opportunity to press on that point a bit

[09:30] <masak> but I think that &closure should be per-line, and that 'next' and 'last' and 'redo' should work as expected in them.

[09:30] <tadzik> maybe with stuff like :lines, :words, :chars etc

[09:31] <masak> tadzik: how do you mean?

[09:31] <tadzik> well, it'll default to :lines

[09:31] <tadzik> I'm still thinking about a usecase though, so it may be not worth it :)

[09:31] <moritz> well, if you do in-place($filename, :words, &closure) the closure is processed word by word

[09:31] <jnthn> for in-place($filename) -> $line is rw { $line *= 2 }

[09:32] <jnthn> do gather/take...after it comes back from the take, it will write the line back

[09:32] <jnthn> take-rw of course.

[09:32] <jnthn> May work.

[09:32] <moritz> jnthn: then a 'last' will skip writing the file :/

[09:32] <jnthn> arse.

[09:32] <jnthn> OK, then making next/last etc. work will be...fun. :S

[09:33] <moritz> well

[09:33] <moritz> once we've got DESTROY

[09:33] <masak> maybe it's a macro? :)

[09:33] <moritz> that might be possible

[09:33] <jnthn> DESTROY is like "yeah, write the file...sometime before VM shutdown" :)

[09:33] <moritz> masak: some people, when faced with a problem, ...

[09:33] <masak> moritz: I wouldn't place any... what jnthn said.

[09:34] <masak> moritz: ...help create a better world by making the language more expressive using macros? :D

[09:34] <masak> I'm pretty sure that's how the saying goes.

[09:38] <masak> I think `inplace($filename, &closure)` is the nicest solution.

[09:38] <tadzik> +1

[09:38] <masak> ...at least until we have good enough macros.

[09:39] <masak> I should tell the guy who's supposed to be working on that to hurry up.

[09:39] <jnthn> masak: When will macros be released?

[09:39] <jnthn> masak: When will we have macros 6.0.0?

[09:40] * jnthn hopes we'll have something in the next release ;)

[09:40] * masak too

[09:40] <masak> maybe we should have a macrathon sometime soon? :)

[09:41] <masak> jnthn: you're free to do other stuff, of course, as long as I can pester you with silly questions about the innards of Rakudo. ;)

[09:42] *** daxim joined
[09:42] <jnthn> masak: Sure, did we manage to pick any of our Perl 6 days this month on the same day? :)

[09:42] *** woosley left
[09:44] *** arlinius left
[09:45] <moritz> https://gist.github.com/1758788

[09:46] <moritz> that's the very first shot at in-place file editing

[09:47] <masak> jnthn: I dunno, do you have any Fridays?

[09:47] <masak> otherwise my weekends are pretty fungible.

[09:47] <masak> I expect people here will appreciate http://www.romancortes.com/blog/1k-rose/

[09:47] <jnthn> no, all out of Fridays. The great Friday shortage of February.

[09:47] <masak> oh, ok.

[09:48] <jnthn> Weekends...yeah, can do those.

[09:48] <masak> \o/

[09:48] <moritz> oh btw, we need a release manager for February

[09:49] <jnthn> Guess its the 23rd.

[09:49] <masak> moritz: I think what 'perl -i' does is rename the original, and open the new file for writing.

[09:49] <jnthn> it's

[09:49] <jnthn> moritz's way seems a little safer...

[09:50] <jnthn> The CATCH may need to close $tmp-f before unlinking it.

[09:50] <jnthn> (if the open worked out)

[09:51] * moritz adds $tmp.?close;

[09:51] <jnthn> Guess the level of need for it varies by OS :)

[09:52] <moritz> aye

[09:52] <moritz> well, it doesn't work on windows anyway, since I use shell("mv")

[09:54] <masak> Perl 5 has &rename

[09:54] <moritz> I know

[09:54] <moritz> and it's really awefull

[09:54] <masak> why is it awful?

[09:54] <moritz> because it doesn't work across file system boundaries, for example

[09:54] <masak> huh.

[09:54] <moritz> it just redispatches to the rename() system call

[09:55] <masak> right, even `perldoc -f rename` refers to using File::Copy instead :)

[09:55] <masak> I can see the point of doing it the simple way, like Perl 5, and just redispatching to the rename() system call.

[09:56] <moritz> it was a sensible decision back in the days.

[09:56] <masak> sometimes I feel we do too little of that in Perl 6, and just shoot for perfection.

[09:56] <moritz> we want to offer safer defaults, no?

[09:56] <masak> oh, most definitely.

[09:57] <masak> I'm not saying it's an easy balance.

[10:01] <masak> I'm saying something like -- I'd prefer to have Perl 5's crappy &rename in Rakudo CORE than none at all.

[10:01] <moritz> agreed

[10:03] *** spine_ joined
[10:05] *** dbr left
[10:06] *** scott__ left
[10:07] <masak> moritz++ # figuring out on #parrot how to implement &rename in Rakudo

[10:08] *** scott__ joined
[10:09] *** scott__ left
[10:11] *** woosley joined
[10:16] *** sftp left
[10:17] *** sftp joined
[10:22] *** wtw left
[10:23] *** dbr joined
[10:25] *** wtw joined
[10:25] *** sftp left
[10:25] *** sftp joined
[10:35] *** sftp left
[10:41] <moritz> nom: say ().pick.defined

[10:41] <p6eval> nom 33fb02: OUTPUT«True␤»

[10:41] <moritz> nom: say ().pick.perl

[10:41] <p6eval> nom 33fb02: OUTPUT«().list␤»

[10:41] <moritz> uhm

[10:41] <moritz> shouldn't that return something like Nil?

[10:41] <moritz> niecza: say ().pick.perl

[10:41] <p6eval> niecza v14-20-g18249a6: OUTPUT«Any␤»

[10:41] <moritz> or that

[10:43] <masak> I think I can make a stronger case for Nil than for Any.

[10:43] <masak> but it depends on how much a special case .pick() is compared to .pick($n).

[10:44] <moritz> perl6: say (1, 2).pick(3).perl

[10:44] <p6eval> rakudo 33fb02, niecza v14-20-g18249a6: OUTPUT«(2, 1).list␤»

[10:44] <p6eval> ..pugs b927740: OUTPUT«(1, 2)␤»

[10:45] <moritz> perl6: say ().roll.perl

[10:45] <p6eval> niecza v14-20-g18249a6: OUTPUT«Any␤»

[10:45] <p6eval> ..rakudo 33fb02: OUTPUT«Nil␤»

[10:45] <p6eval> ..pugs b927740: OUTPUT«*** No such method in class Array: "&roll"␤    at /tmp/84DMEkAF45 line 1, column 5 - line 2, column 1␤»

[10:45] *** sftp joined
[10:51] <masak> nom: say ().pick.defined; say ().roll.defined

[10:51] <p6eval> nom 33fb02: OUTPUT«True␤False␤»

[10:51] <masak> yeah. not kosher.

[10:51] * masak submits rakuodbug

[10:56] <moritz> https://github.com/moritz/perlgeek.de/blob/master/source/blog-source-en/perl-6/iterated-prisoners-dilemma.txt any comments before I publish it?

[10:57] * masak reads

[10:58] <masak> huh -- you don't mention the actual scores anywhere... :)

[10:59] <masak> surely it makes a difference to the strategy if the defect penalty is twice the cooperation reward, or 1e6 times as big?

[10:59] <masak> I see the scores are in the code gist, but IMHO they belong in the post as well, along with a clarification on what they mean.

[10:59] <moritz> right; they are in the gist I linked to

[11:00] <moritz> ok

[11:00] <masak> s/Friday 17's February/Friday February 17/

[11:01] <masak> I will probably enter this contest, but I don't expect to win.

[11:02] <moritz> please do anyway; it's not about winning, but about the fun of it

[11:02] *** woosley left
[11:02] <masak> oh, sure.

[11:02] * masak will spend lunch thinking about strategies now

[11:03] <masak> moritz++

[11:04] <masak> oh, and I didn't say it during the p6cc prep, so I'll say it now: reading the harness code, I can see why you enjoyed writing it. it's good code.

[11:04] <moritz> thanks

[11:04] *** sftp_ joined
[11:04] <masak> Perl 6 is really coming of age.

[11:05] *** sid__ joined
[11:05] *** sftp left
[11:07] <daxim> http://stackoverflow.com/questions/9173043/how-can-i-use-perl-5-modules-from-perl-6

[11:07] <moritz> blog post draft updated

[11:09] <masak> moritz: if it's not too late to change it -- the named parameters 'my' and 'theirs' are a bit inconsistent.

[11:09] <masak> it should be 'mine' and 'theirs'

[11:09] <moritz> not too late

[11:09] <masak> or -- less likely -- 'my' and 'their'

[11:10] <moritz> I thought about s/my/mine/

[11:10] <masak> you may or may not need to update your checksum as a consequence ;)

[11:10] <moritz> but since you mention it, it's the tipping point

[11:10] <moritz> masak: that will give you important hints :-)

[11:10] <masak> I just noticed it.

[11:10] <masak> yeah, but quite a weak hint ;)

[11:11] <moritz> a much stronger hint would be to check the p6cc repo :-)

[11:14] <masak> didn't think of that -- I don't feel tempted to, though.

[11:14] <masak> I want to figure out a strategy on my own.

[11:14] <moritz> that's good

[11:15] * moritz publishes the blog post

[11:16] <moritz> http://perlgeek.de/blog-en/perl-6/iterated-prisoners-dilemma.html

[11:17] * moritz hopes lots of people will submit strategies

[11:18] <masak> publish it to reddit :)

[11:19] <masak> then you'll get lots of... comments of how Perl 6 is dead, and besides that irrelevant and slow.

[11:21] <moritz> http://www.reddit.com/r/programming/comments/pejx7/minichallenge_write_your_prisoners_dilemma/ there you go

[11:21] *** woosley joined
[11:23] * masak .oO( redditor's dilemma )

[11:24] <masak> should a random commenter cooperate, and say "this is pretty cool!", or defect, and say "Perl 6 has missed the boat, stop posting stuff about it" :P

[11:25] <moritz> and the obvious answer is "no, ey should submit one or two strategies"

[11:25] <masak> fwiw, the boat comes once a year to pick up emergent languages from The Island of Obscurity to The Mainland of Mainstream. Haskell consistently refuses to get in it, because the boat is impure.

[11:27] <masak> moritz: oh, have you started spivaking too now?

[11:27] *** pernatiy left
[11:27] <moritz> spivaking?

[11:28] <masak> "ey".

[11:28] <masak> http://en.wikipedia.org/wiki/Spivak_pronoun

[11:28] <moritz> not consistently

[11:29] <moritz> .oO( strangely inconsistent, the evil twin blog )

[11:29] <masak> mwhahaha

[11:30] *** benabik left
[11:34] <tadzik> nom: say 3**4**5; say (3**4**5)/2

[11:34] <p6eval> nom 33fb02: OUTPUT«3733918487410200435329597541848665882254097767837340077506369317220790406172652512299936889388039772204687650654314751581087270545921608585813513369828091873141917485942625809388070199519564042855718180410466812887974029255176680123406172983965747316191523867230462351…

[11:34] <tadzik> nom: say (3**4**5)/2; say 3**4**5; 

[11:34] <p6eval> nom 33fb02: OUTPUT«Inf␤373391848741020043532959754184866588225409776783734007750636931722079040617265251229993688938803977220468765065431475158108727054592160858581351336982809187314191748594262580938807019951956404285571818041046681288797402925517668012340617298396574731619152386723046…

[11:34] <tadzik> so Inf is smaller than 3**4**5, it

[11:34] <tadzik> 'd seem

[11:35] <jnthn> nom: say ((3**4**5)/2).perl

[11:35] <p6eval> nom 33fb02: OUTPUT«3733918487410200435329597541848665882254097767837340077506369317220790406172652512299936889388039772204687650654314751581087270545921608585813513369828091873141917485942625809388070199519564042855718180410466812887974029255176680123406172983965747316191523867230462351…

[11:36] <jnthn> Something with Rat stringification I guess. Forget the exact wording of the spec there.

[11:36] <jnthn> I guess we .Num it to show it

[11:37] <jnthn> And that's where the Inf slips in.

[11:38] <tadzik> aye

[11:41] *** xinming left
[11:42] *** xinming joined
[11:53] <colomon> I've been thinking we maybe should spec smarter Rat -> Num conversions.

[11:59] <flussence> re: rename -

[11:59] <flussence> nom: use NativeCall; module POSIX; sub rename(Str $oldpath, Str $newpath) returns Int is native() is export { ... }

[11:59] <p6eval> nom 33fb02: OUTPUT«===SORRY!===␤Could not find NativeCall in any of: lib, /home/p6eval/.perl6/lib, /home/p6eval/nom-inst1/lib/parrot/4.0.0-devel/languages/perl6/lib, .␤»

[12:00] <flussence> (you get the idea)

[12:15] <jnthn> try star

[12:15] *** PacoAir joined
[12:15] <flussence> star: use NativeCall; module POSIX; sub rename(Str $oldpath, Str $newpath) returns Int is native() is export { ... }

[12:16] <p6eval> star 2012.01:  ( no output )

[12:16] <flussence> I keep forgetting that's there now :)

[12:25] *** xinming left
[12:25] <flussence> $ perl6 -e 'for $*ARGFILES.lines { next unless /^ "extern" \s+ (.*?) \s+ (.*?) \s* "(" (.*) ")" \s* ";" $/; say "sub $1\($2) returns $0 is native() \{ ... }"; }' /usr/include/stdio.h    # one-liner to get 70% of stdio.pm6

[12:30] *** xinming joined
[12:34] *** dbr left
[12:34] *** bluescreen10 joined
[12:38] *** benabik joined
[12:40] <masak> flussence: if you're looping over $*ARGFILES.lines, why not use -n ?

[12:40] <masak> perl6 -n -e 'next unless /^ "extern" \s+ (.*?) \s+ (.*?) \s* "(" (.*) ")" \s* ";" $/; say "sub $1\($2) returns $0 is native() \{ ... }" }'

[12:40] <flussence> I keep forgetting about things like that too :)

[12:41] <masak> :)

[12:41] <moritz> and even if not, lines() is shorter than $*ARGFILES.lines :-)

[12:45] *** pernatiy joined
[12:53] <masak> I went straight for the shortest one ;)

[12:54] <masak> I think "why does `for lines { ... }` not do what I want will be a FAQ.

[12:54] <masak> std: for lines { .say }

[12:54] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Function 'lines' needs parens to avoid gobbling block at /tmp/jUWEOog4aR line 1:␤------> [32mfor lines[33m⏏[31m { .say }[0m␤Missing block (apparently gobbled by 'lines') at /tmp/jUWEOog4aR line 1:␤------> [32mfor lines { .say }[33…

[12:54] <timotimo> in soviet tetris?

[12:54] <masak> that is a good error message, though.

[12:54] <timotimo> in wrong channel?

[12:54] <masak> s/what I want/what I want?/

[12:55] <masak> timotimo: I thought all tetris was Soviet...

[13:00] <dalek> niecza: 4561a78 | (Solomon Foster)++ | lib/CORE.setting:

[13:00] <dalek> niecza: Switch KeyBag.list to return just keys.

[13:00] <dalek> niecza: review: https://github.com/sorear/niecza/commit/4561a78bcd

[13:02] <dalek> roast: afb17b9 | (Solomon Foster)++ | S02-types/keybag.t:

[13:02] <dalek> roast: Fix tests after discussion with TimToady++.

[13:02] <dalek> roast: review: https://github.com/perl6/roast/commit/afb17b92d5

[13:03] <dalek> rakudo/nom: 8c84b8e | moritz++ | src/core/ (2 files):

[13:03] <dalek> rakudo/nom: implement &rename

[13:03] <dalek> rakudo/nom: 

[13:03] <dalek> rakudo/nom: ... until we get the real thing.

[13:03] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/8c84b8ed97

[13:05] *** xinming left
[13:06] *** xinming joined
[13:06] *** xinming left
[13:07] *** skids left
[13:08] <masak> heh -- I decided to try and find the first few emails in the perl6-language list.

[13:08] <masak> look at the number of the last page: http://code.activestate.com/lists/perl6-language/?page=1337

[13:08] <huf> cant be a coincidence

[13:10] <timotimo> wow, the first message is from 1980? people really spent a long time thinking about how to bring perl to the next level

[13:11] <moritz> huh? I only see some from 2000

[13:11] <masak> timotimo: yeah, saw that too. must be a mis-dating somehow.

[13:11] <moritz> ah, the last in the list

[13:11] <benabik> I'm guessing someone had a misconfigured mail client.

[13:11] <masak> but holy schmoly the list had a lot of traffic on 2000-08-01.

[13:11] <benabik> (And the list software trusts the headers)

[13:11] <masak> compared to that, Perl 6 is practically dead today :)

[13:12] <masak> guess even people with short attention spans were active and eager back then...

[13:12] <masak> moritz++ # rename

[13:13] *** xinming joined
[13:13] <masak> jnthn: can AUTOLOAD behavior be emulated through a metaclass? my guess is "yes" :)

[13:14] <colomon> silly masak.  you can do ANYTHING with a metaclass.  ;)

[13:14] <moritz> masak: I think that several MOP examples that jnthn++ produced override find_method

[13:15] <moritz> you can also use add_fallback in ClassHOW

[13:17] <masak> http://code.activestate.com/lists/perl6-language/406/ -- "I wouldn't even mind if someone wrote a pragma that lets you program Perl in Latin."

[13:17] <masak> four months later... Lingua::Perligata hits CPAN :P

[13:18] <masak> moritz: ooh, add_fallback.

[13:18] *** xinming left
[13:18] *** xinming_ joined
[13:19] <timotimo> my god

[13:19] <masak> timotimo: what what?

[13:20] <timotimo> the latin thing is really elaborate

[13:20] <masak> yes. it is.

[13:21] *** benabik left
[13:25] <masak> ooh -- http://dev.perl.org/perl6/rfc/meta/larry-3.txt -- so *that's* how far the "take my marbles and go home"/"nuclear blackmail" meme stretches.

[13:26] <masak> it's almost two years ago now. k23z__ was unhappy at me because I suggested he might be a troll.

[13:27] <timotimo> what happened then?

[13:27] <timotimo> did he turn out to be a troll or did he turn out to be a really important asset to the perl6 community?

[13:28] <masak> <k23z__> if you label me a troll again I will never enter this channel

[13:29] <masak> <TimToady> nuclear blackmail? then stay away, by all means

[13:29] *** simcop2387 left
[13:29] *** simcop2387 joined
[13:29] <masak> <TimToady> take your marbles and run while you can

[13:30] <moritz> hm, http://irclog.perlgeek.de/search.pl?nick=k23z__;channel=perl6;q=;offset=0 doesn't find that

[13:31] <masak> moritz: http://irclog.perlgeek.de/perl6/2010-03-06#i_2071596

[13:31] <masak> 15 minutes later, I end up hugging k23z__ ;)

[13:31] <masak> and he ends up admitting that he was wrong.

[13:32] <timotimo> aaw, that's sweet

[13:32] *** baest_ joined
[13:32] <timotimo> i admire people who are able to change their minds in situations where it makes sense

[13:32] <flussence> .oO( "Blackmail that glows in the dark!™" )

[13:32] <masak> in retrospect, he wasn't a troll (just like diakopter thought), but he had some communication trouble and acted a bit threatening.

[13:33] <dalek> rakudo/nom: 96ef170 | moritz++ | src/SAFE.setting:

[13:33] <dalek> rakudo/nom: mask &rename in SAFE.setting

[13:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/96ef170ae2

[13:33] <dalek> rakudo/nom: 0dc3384 | moritz++ | tools/build/Makefile.in:

[13:33] <dalek> rakudo/nom: missing dependency in Makefile

[13:33] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0dc3384527

[13:34] *** woosley left
[13:34] *** baest left
[13:35] *** xinming_ left
[13:36] <jnthn> add_fallback is the meta-space hook for AUTOLOADy things.

[13:36] <jnthn> For now. :)

[13:37] *** xinming joined
[13:38] <dalek> niecza: 68c9f28 | masak++ | lib/Test.pm6:

[13:38] <dalek> niecza: [lib/Test.pm6] removed sigils from \ parameters

[13:38] <dalek> niecza: 

[13:38] <dalek> niecza: Annoyance-driven development: warnings kept showing up in my

[13:38] <dalek> niecza: test runs, and they weren't from my code but from Niecza.

[13:38] <dalek> niecza: Now they're gone.

[13:38] <dalek> niecza: review: https://github.com/sorear/niecza/commit/68c9f2893c

[13:44] *** ab5tract joined
[13:45] *** Woodi left
[13:46] <timotimo> nom: say { say "hello" }.^methods

[13:46] <p6eval> nom 8c84b8: OUTPUT«Method 'gist' not found for invocant of class 'Sub'␤  in method gist at src/gen/CORE.setting:4061␤  in sub say at src/gen/CORE.setting:5958␤  in block <anon> at /tmp/T17lDyp6IT:1␤  in <anon> at /tmp/T17lDyp6IT:1␤»

[13:46] <timotimo> how do i understand this? a block is not an object?

[13:46] <moritz> no

[13:47] <moritz> the problem is that one of the returned objects from the list doesn't have a .gist method

[13:47] <timotimo> oh, do i need to add ()?

[13:47] <moritz> no

[13:47] <jnthn> Our metacircularity is still a little square in places

[13:47] <moritz> aye

[13:47] * masak .oO( metasquareularity )

[13:47] <timotimo> nom: my @methods = { say "hello" }.^methods

[13:47] <timotimo> not better

[13:47] <p6eval> nom 8c84b8: OUTPUT«Cannot assign a non-Perl 6 value to a Perl 6 container␤  in method REIFY at src/gen/CORE.setting:5206␤  in method reify at src/gen/CORE.setting:4381␤  in method gimme at src/gen/CORE.setting:4763␤  in method eager at src/gen/CORE.setting:4738␤  in method STORE at src/…

[13:48] <masak> hm, that's a bug, I think.

[13:48] <moritz> well, the error message points much closer to the thruth

[13:48] <jnthn> Needs fixing in the BOOTS TRAP. Need to ponder exactly how...

[13:49] <timotimo> it's interesting to me that there is a thing as a "non-Perl 6 value" in perl6 :)

[13:49] * masak submits rakudobug

[13:49] <masak> timotimo: it's because Perl 6 really is all the world's languages in disguise.

[13:49] <timotimo> niecza: my @methods = { say "hello" }.^methods

[13:49] <p6eval> niecza v14-21-g4561a78: OUTPUT«Potential difficulties:␤  @methods is declared but not used at /tmp/1xUm5OmrpZ line 1:␤------> [32mmy [33m⏏[31m@methods = { say "hello" }.^methods[0m␤␤Unhandled exception: Unable to resolve method methods in class ClassHOW␤  at /tmp/1xUm5OmrpZ line 1 (…

[13:49] <timotimo> ah, that

[13:49] <timotimo> niecza: my @methods = { say "hello" }.^methods; say @methods[0];

[13:49] <moritz> timotimo: mostly parrot objects leaking through

[13:49] <p6eval> niecza v14-21-g4561a78: OUTPUT«Unhandled exception: Unable to resolve method methods in class ClassHOW␤  at /tmp/PvFKab6lvQ line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3738 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3739 (module-CORE @ 65) ␤  at…

[13:49] <timotimo> no, do i have to use { } there? or < >?

[13:50] <masak> [], like you did.

[13:50] <masak> { } for hashes, or for arrays with a hash interface (NYI).

[13:50] <masak> .<> is just sugar for .{}

[13:50] <moritz> niecza doesn't do that part of introspection yet

[13:50] <timotimo> what's the difference between {} and .{}?

[13:51] <moritz> the dot :-)

[13:51] <moritz> there's no semantic difference

[13:51] <timotimo> ah, and it's sugar, because you could write {"foo"} or <foo>, right?

[13:51] <moritz> correct

[13:52] <masak> right.

[13:52] <timotimo> that also neatly explains, why it shouldn't be (and isn't) sugar for []

[13:52] <masak> nom: my %h = 1..6; say %h<3 3 1 5>

[13:52] <p6eval> nom 8c84b8: OUTPUT«4 4 2 6␤»

[13:52] <timotimo> that returns a list? or a parcel maybe?

[13:52] <masak> timotimo: <foo bar baz> is sugar for ('foo', 'bar', 'baz'), though.

[13:53] <masak> nom: my %h = 1..6; say %h<3 3 1 5>.^name

[13:53] <p6eval> nom 8c84b8: OUTPUT«Parcel␤»

[13:53] <timotimo> oh, is that syntax for a tuple?

[13:53] <masak> no, it's also just a Parcel :)

[13:53] <timotimo> OK

[13:53] <masak> nom: say <foo bar baz>.^name

[13:53] <p6eval> nom 8c84b8: OUTPUT«Parcel␤»

[13:53] *** benabik joined
[13:53] <timotimo> i was audibly happy when i heard, that i could put a junction into .{}, btw. that was really cool.

[13:54] <timotimo> but it's kind of hard to get a real overview over perl6. there's just so much stuff! but all of it seems to make lots of sense, so that's really good

[13:55] <moritz> that's good to hear

[13:55] <masak> timotimo: we always want to make the learning process easier, simpler, and more fun for newcomers.

[13:55] <timotimo> of course, i haven't done much yet, so that might just be the outermost layer being well-designed, hiding lots of ugly internals ;)

[13:55] <[Coke]> b: say 19612 - 19655 ; # 02/06/2012 - niecza at 100.21%

[13:55] <p6eval> b 1b7dd1: OUTPUT«-43␤»

[13:55] <masak> timotimo: we're working on it all the time, but it's a slow process by nature.

[13:55] <masak> timotimo: if you have any ideas, feel free to share them.

[13:55] <[Coke]> colomon++ # the pendulum swings.

[13:55] <masak> oh noes, Niecza is ahead again!

[13:55] <masak> how long was it since last time?

[13:56] <timotimo> is there a reason for try.perl6.org to not exist any more? and back when it existed, it didn't work at all for me (that one time i tried)

[13:56] <jnthn> Fear not! I have Rakudo day on Thursday and look forward to swinging! :)

[13:56] <masak> timotimo: short answer: try.perl6.org is brittle and doesn't really have a maintainer.

[13:56] * [Coke] is reminded to keep hacking on DateTime!

[13:57] <moritz> jnthn: have you had a chance to think about throwing typed exceptions from the MOP and C?

[13:57] <colomon> jnthn: I don't know, once I port the new KeyBag tests back to Bag, Set, and KeySet, that's a probably a couple hundred more tests for Niecza.

[13:57] <timotimo> does the parrot vm give you sandboxing for free or something?

[13:57] <colomon> of course, you could just port the implementations of those classes to nom, I suppose.... ;)

[13:58] <moritz> colomon: no

[13:58] <moritz> colomon: that's the plan :-)

[13:58] <moritz> sorry, the "no" was meant for timotimo 

[13:58] <jnthn> colomon: Yes, I'll be happy to grab those classes into Rakudo :)

[13:58] <colomon> don't port them yet, I've still got some fixes that need to go in there!   

[13:58] <jnthn> ;)

[13:59] * moritz also advises against porting much of the exceptions stuff to niecza just yet

[14:01] *** GlitchMr joined
[14:03] *** xinming left
[14:06] *** xinming joined
[14:11] *** xinming left
[14:11] * colomon just decided KeyBag wasn't done yet either.

[14:11] *** xinming joined
[14:20] *** xinming left
[14:21] *** xinming joined
[14:23] *** Trashlord joined
[14:27] *** Woodi joined
[14:31] *** xinming left
[14:37] <moritz> nom: sub f() { return }; say f.perl

[14:37] <p6eval> nom 0dc338: OUTPUT«Nil␤»

[14:42] *** xinming joined
[14:43] <masak> nom: sub Nil { return }; say Nil() === Nil

[14:43] <p6eval> nom 0dc338: OUTPUT«True␤»

[14:43] <moritz> cute.

[14:43] <masak> nom: sub Nil { say "called!"; return }; say Nil() === Nil

[14:43] <p6eval> nom 0dc338: OUTPUT«called!␤True␤»

[14:43] <masak> and very correct. I was afraid it might get called twice.

[14:44] <moritz> no, that's a part that rakudo does correctly

[14:45] *** zjmarlow left
[14:45] <TimToady> fsdo correctly

[14:45] *** zjmarlow joined
[14:48] <moritz> hm, did you expect/want it to be differently?

[14:48] <TimToady> it depends on whether you think keywords exist

[14:49] <masak> it does?

[14:49] <moritz> only to the extend that constants and terms exist

[14:50] <masak> I'm happy with the above behavior.

[14:50] <masak> it's unsurprising, and flexible.

[14:50] <moritz> perl6: constant a = 5; {my sub a() { 10 }; say a, a(); }

[14:50] <p6eval> rakudo 0dc338: OUTPUT«510␤»

[14:50] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "="␤    expecting ":" or "("␤    at /tmp/ASpTWyyYlE line 1, column 12␤»

[14:50] <p6eval> ..niecza v14-21-g4561a78: OUTPUT«Unhandled exception: Unable to resolve method postcircumfix:<( )> in class Int␤  at /tmp/0Q77yJsuep line 1 (ANON @ 3) ␤  at /tmp/0Q77yJsuep line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3738 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/…

[14:50] <TimToady> just pointing out that it's not the only value of "correct"

[14:51] <TimToady> in another value of correct, you'd have to use 'Nil() === CORE::<Nil>'

[14:51] *** colomon left
[14:51] <moritz> how does the spec define 'correct'?

[14:52] <TimToady> the spec is largely silent on the subject

[14:52] *** skids joined
[14:52] <TimToady> but we seem to have re-invented keywords, with () as an escape hatch, which, as you say, is at least okay

[14:53] *** DarthGandalf left
[14:54] <masak> here's a suggestion: both &say and &print use .gist on things which aren't Str already. semantics become consistent between &print and &say again, and easier to explain and defend to beginners. anyone who wants .Str semantics just need to do 'print ~$a' instead of 'print $a'.

[14:54] <TimToady> it would be possible, however, to set things up such that you can override any identifier, and that system would be more flexible; not saying I want to go that far, but it's another view of "correct"

[14:54] *** xinming left
[14:55] <masak> we have only re-invented keywords in the sense that they fall nicely out of how other things work in the language.

[14:55] <TimToady> or we resurrect spew or some such

[14:55] <masak> was spew ever dead?

[14:55] <masak> I thought it was just a bad idea that was never taken seriously.

[14:55] <TimToady> I was hoping for a different verb :)

[14:55] <masak> that's what I mean.

[14:56] <moritz> spew?

[14:56] <masak> opposite of slurp.

[14:56] <moritz> oh

[14:56] <masak> I don't really see the connection to &print and &say, to be honest.

[14:56] <masak> spew works on files.

[14:56] *** xinming joined
[14:56] <dalek> rakudo/nom: 925e3cd | moritz++ | src/core/List.pm:

[14:56] <dalek> rakudo/nom: return Nil for ().pick and .roll (RT #110038)

[14:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/925e3cd0fd

[14:57] <moritz> niecza: say ().pick.perl

[14:57] <p6eval> niecza v14-21-g4561a78: OUTPUT«Any␤»

[14:57] <moritz> niecza: say ().roll.perl

[14:57] <p6eval> niecza v14-21-g4561a78: OUTPUT«Any␤»

[14:57] <TimToady> that should probably be Nil

[14:57] <moritz> ok, then I'll test it as such

[14:59] <TimToady> and I'm still thinking that Match, Nil, and Failure are all signalling types that pass through smartmatching like Bool does.

[15:00] <TimToady> they are varying degrees of success and failure

[15:00] <dalek> roast: b13a406 | moritz++ | S32-list/ (2 files):

[15:00] <dalek> roast: ().pick and .roll return Nil

[15:00] <dalek> roast: review: https://github.com/perl6/roast/commit/b13a406866

[15:00] *** xinming left
[15:01] *** xinming joined
[15:02] *** birdwindupbird left
[15:03] <masak> RT ticket was open for 4 hours. nice turnover. moritz++

[15:05] *** snearch left
[15:09] *** DarthGandalf joined
[15:09] * TimToady thinks we do in fact weird enough

[15:11] <moritz> but do we language enough?

[15:11] *** birdwindupbird joined
[15:13] <TimToady> the fact that ... tests the LHS for ending the list is by design, and has nothing to do with laziness per se

[15:14] <TimToady> 2,4,6 ... $end   # this is the sequence of even integers, even if you want fewer than the ones on the left

[15:14] * masak guessed as much

[15:14] <TimToady> we tried the other semantics, and they were bogus

[15:15] <TimToady> or at least, incompatible with any kind of dwimmery

[15:17] <masak> the more I think about the current semantics, the more I like things the way they are.

[15:18] <moritz> it just wasn't convenient for the thing I just had in mind :-)

[15:18] <TimToady> it was a fairly long spiral getting to them, so I'm not likely to change them any time soon :)

[15:18] <masak> nom: my @a = 1..99; my $ARBITRARY_MAXIMUM = 11; .say @a ... $ARBITRARY_MAXIMUM

[15:18] <p6eval> nom 0dc338: OUTPUT«===SORRY!===␤Confused␤at /tmp/8LCrgaZQ1Z:1␤»

[15:18] <masak> nom: my @a = 1..99; my $ARBITRARY_MAXIMUM = 11; .say for @a ... $ARBITRARY_MAXIMUM

[15:18] <p6eval> nom 0dc338: OUTPUT«1␤2␤3␤4␤5␤6␤7␤8␤9␤10␤11␤»

[15:19] <masak> nom: my @a = 1..5, *+2; my $ARBITRARY_MAXIMUM = 11; .say for @a ... $ARBITRARY_MAXIMUM

[15:19] <p6eval> nom 0dc338: OUTPUT«1␤2␤3␤4␤5␤7␤9␤11␤»

[15:20] *** baest_ is now known as baest

[15:20] *** wtw left
[15:32] <TimToady> we might go as far as to say that Nil is just a degenerate case of Failure, or that Failure is Nil with a message in the bottle

[15:33] * masak gets a hesitant look

[15:33] <TimToady> .oO(Conservatives!)

[15:34] <jnthn> Given we were also pondering putting Failure outside of Any... :)

[15:34] <TimToady> so maybe Nil belongs there too

[15:34] <jnthn> heh :)

[15:34] <PerlJam> Any is starting to look more like Mostly

[15:35] <arnsholt> Some?

[15:35] <TimToady> well, Nil is arguably very similar to one()  "one of nothing"

[15:35] *** tarch left
[15:35] <masak> everyone except complete Failures qualifies as Any!

[15:35] <PerlJam> heh

[15:36] <masak> TimToady: only if you squint so hard you're actually closing your eyes.

[15:36] <PerlJam> masak: though, a complete Failure would have a message I think

[15:36] <PerlJam> But, I guess the absense of message is a message too

[15:36] * masak read that as "a complete Failure would have a massage, I think"

[15:36] <TimToady> well, Nil and one() behave rather differently in a pragmatic sense

[15:37] <PerlJam> ... and that's why we now call it Spa

[15:37] *** sid__ left
[15:43] <masak> nom: class Spa { method massage(Failure $f) { .say for "come in, dear $f.^name()!", "lie down.", "prepare to be kneaded." } }; sub complete_failure { fail }; Spa.massage( complete_failure )

[15:43] <p6eval> nom 925e3c: OUTPUT«come in, dear Failure!␤lie down.␤prepare to be kneaded.␤»

[15:44] *** Psyche^ joined
[15:44] *** Psyche^ is now known as Patterner

[15:46] *** xinming left
[15:48] *** colomon joined
[15:50] <PerlJam> What's the way to bias .pick() or .roll()?   Or am I imagining that there was something built-in for that?

[15:50] <colomon> PerlJam: Bag / KeyBag

[15:51] <colomon> but as far as I know, it's only implemented semi-sanely in niecza's KeyBag

[15:52] <colomon> niecza: my $kb = KeyBag.new({ a => 10, b => 1}); say $kb.roll(5).perl

[15:52] <p6eval> niecza v14-21-g4561a78: OUTPUT«("a", "a", "a", "a", "a").list␤»

[15:52] <colomon> niecza: my $kb = KeyBag.new({ a => 10, b => 1}); say $kb.roll(20).perl

[15:52] <p6eval> niecza v14-21-g4561a78: OUTPUT«("a", "a", "a", "b", "a", "a", "a", "a", "a", "a", "a", "b", "a", "a", "a", "a", "a", "a", "a", "b").list␤»

[15:53] <masak> at least it's implemented. colomon++

[15:54] <PerlJam> indeed. colomon++

[15:54] <colomon> niecza: my $kb = KeyBag.new({ a => 100000000000, b => 1}); say $kb.roll(20).perl

[15:54] <p6eval> niecza v14-21-g4561a78: OUTPUT«("a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a", "a").list␤»

[15:55] <TimToady> looks pretty darn sane to me

[15:55] <colomon> it's still O(N) per roll, where N is the number of keys

[15:55] <colomon> so it definitely could be better

[15:56] <colomon> hmm, probably also subject to the limitations in rand TimToady++ was talking about the other day

[15:56] <TimToady> ah, yes, I believe you mentioned binary searching the key/cutoff list

[15:56] <colomon> right now it's a linear search

[15:57] <TimToady> a block search using sqrt # of keys is another way of cutting it down

[15:58] <TimToady> O(2*sqrt(n)) I believe

[15:59] <TimToady> but binary search probably wins unless cache lookahead allows fast traversal of short linear scans

[16:00] *** xinming joined
[16:00] <TimToady> another approach, sort the 20 random numbers and do 1 linear scan, then shuffle the results :)

[16:01] <colomon> :)

[16:01] <dalek> roast: 9d4d2d7 | (Solomon Foster)++ | S02-types/keybag.t:

[16:01] <dalek> roast: More ways of getting things into KeyBags.

[16:01] <dalek> roast: review: https://github.com/perl6/roast/commit/9d4d2d709d

[16:02] <TimToady> arguably the .gist of a KeyBag should be the pairs form

[16:03] <TimToady> since .gist is a kind of summary

[16:03] <[Coke]> moritz: when I edit, say, the "rakudo" tag on the stackoverflow wiki, are you one of the peers reviewing the edits?

[16:04] <colomon> niecza: say KeyBag.new({ a => 100000000000, b => 1}).gist

[16:04] <p6eval> niecza v14-21-g4561a78: OUTPUT«keybag("a" => 100000000000, "b" => 1)␤»

[16:04] <colomon> TimToady: how does that differ from what you'd like?

[16:05] <TimToady> it's fine

[16:06] <TimToady> unless we want xx there instead of =>

[16:06] <TimToady> something to be said for that

[16:07] <TimToady> but => is probably good education

[16:08] * colomon notes that Bag would try to print 100000000000 "a"s -- a lot of the KeyBag improvements need to be ported back

[16:09] <TimToady> how many of those should be in a Baggy role that is common to both?

[16:10] <TimToady> arguably the simplest implementation of Bag is just to reuse KeyBag and pretend it's immutable :)

[16:12] <TimToady> .oO(Dirty Baggy: Go ahead, make my day!)

[16:13] <jnthn> decommute &

[16:13] <colomon> yeah, I've been wondering that myself

[16:14] *** birdwindupbird left
[16:14] <colomon> the differences between the two are very minor

[16:14] *** kmwallio joined
[16:14] <TimToady> we should probably spec some official way to declare immutability, and have it enforced wherever necessary

[16:16] <TimToady> we could declare it as data instead of class, and confuse everyone

[16:16] <TimToady> oh wait, Haskell already tried that...

[16:18] <masak> that's one of the things I've never really managed to learn about Haskell -- which things are data declarations and which are type declarations, and so on.

[16:18] <masak> whenever I get back to the language, I have to look it up.

[16:19] *** icwiener joined
[16:24] <Su-Shee> on the subject of haskell just found on twitter: "Some people see a problem and think "I know, I'll use Haskell!" Now they have a monoid in the category of problems."

[16:25] <colomon> :)

[16:25] * masak .oO( what would the functors of that monoid be? )

[16:25] *** kmwallio left
[16:25] <Su-Shee> masak: DONT GO THERE. ;)

[16:28] <masak> my god it's full of notation

[16:32] <dalek> roast: 9b1c972 | (Solomon Foster)++ | S32-list/ (2 files):

[16:32] <dalek> roast: Refudge for niecza.

[16:32] <dalek> roast: review: https://github.com/perl6/roast/commit/9b1c97277d

[16:32] <dalek> niecza: 0699296 | (Solomon Foster)++ | lib/CORE.setting:

[16:32] <dalek> niecza: Add Bag.pairs, rewrite KeyBag.new to handle arbitrary Associative and Positional arguments.

[16:32] <dalek> niecza: review: https://github.com/sorear/niecza/commit/0699296993

[16:36] <TimToady> beware of geeks bearing lifts...

[16:53] <timotimo> what do i have to do to a modern nom to get NativeCall?

[16:56] <PerlJam> S02:2400 says "Declarators generally make the colon optional: my ($a,$b,$c);      # parsed as signature"  That seems to imply that "my :($a,$b,$c)" should also work.    Should that be the case?

[16:57] <PerlJam> timotimo: install zavolaj

[16:58] *** icwiener left
[16:58] *** icwiener joined
[16:58] <PerlJam> timotimo: See https://github.com/jnthn/zavolaj for more info

[16:59] *** wolfman2000 left
[16:59] <masak> PerlJam: yes, I think it should.

[16:59] <masak> std: my :($a, $b, $c)

[16:59] <p6eval> std 48335fc: OUTPUT«[31m===[0mSORRY![31m===[0m␤Malformed my at /tmp/c7SbkbRS7L line 1:␤------> [32mmy [33m⏏[31m:($a, $b, $c)[0m␤    expecting scoped declarator␤Parse failed␤FAILED 00:01 107m␤»

[16:59] <masak> or maybe not. :)

[16:59] * masak decommutes

[17:00] <PerlJam> I think it should too (std notwithstanding)

[17:01] <PerlJam> because then, I could say  my ($n = 50, $m = $n) = @*ARGS;  rather than my($n,$m) = @*ARGS; $n //= 50; $m //= $n;  # and this makes me smile :)

[17:02] <TimToady> perl6: my ($n = 50, $m = $n) = @*ARGS; say $m

[17:02] <sorear> good * #perl6

[17:02] <p6eval> niecza v14-21-g4561a78: OUTPUT«Unhandled exception: Lexical symbol '$n' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as $n␤  before you can unambiguously declare a new '$n' in this scope␤  at /home/p6eval/niecza/boot/lib/CORE…

[17:02] <p6eval> ..rakudo 925e3c: OUTPUT«Nil␤»

[17:02] <p6eval> ..pugs b927740: OUTPUT«␤»

[17:02] <TimToady> perl6: my ($n = 50, $m = $n) ::= @*ARGS; say $m

[17:02] <p6eval> niecza v14-21-g4561a78: OUTPUT«Unhandled exception: Lexical symbol '$n' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as $n␤  before you can unambiguously declare a new '$n' in this scope␤  at /home/p6eval/niecza/boot/lib/CORE…

[17:02] <p6eval> ..pugs b927740: OUTPUT«pugs: *** Wrong number of binding parameters: 1 actual, 2 expected␤    at /tmp/WpAJJrUAbp line 1, column 1␤»

[17:02] <p6eval> ..rakudo 925e3c: OUTPUT«===SORRY!===␤Cannot use bind operator with this left-hand side␤at /tmp/YU5OQhlxb_:1␤»

[17:03] <TimToady> it ought to already be considered a signature

[17:04] <TimToady> std: my ($n = 50, $m = $n) ::= @*ARGS; say $m

[17:04] <p6eval> std 48335fc: OUTPUT«ok 00:01 114m␤»

[17:04] <timotimo> what's .WHY again?

[17:04] <[Coke]> timotimo: (nativecall) or use r-*

[17:04] <benabik> timotimo: documentation

[17:04] <[Coke]> star: use NativeCall; say "ALIVE"

[17:05] <p6eval> star 2012.01: OUTPUT«ALIVE␤»

[17:05] <timotimo> the perl6 book doesn't mention it. i guess i'll look into the synopses

[17:05] * [Coke] wonders if the's only one on channel who hears "WEIRD SCIENCE" every time someone uses the "alive" trick.

[17:06] <PerlJam> [Coke]: now you've infected me with the meme at least :)

[17:06] * TimToady thinks of #5

[17:07] <PerlJam> TimToady: so ... "my :($a,$b)" should parse as well?

[17:08] <TimToady> probably

[17:09] <TimToady> the interesting question is whether it prevents demontion to a parcel of lvalues

[17:09] <TimToady> *demotion

[17:09] *** kaare_ joined
[17:09] <PerlJam> It seems like ":($a,$b,$c)" should be a short-hand for "my ($a,$b,$c)"

[17:10] <TimToady> which makes a difference if the signature contains @ or %

[17:10] <TimToady> a parcel assignment will assume the last @ or % is slurpy

[17:10] <TimToady> in a sig, that would have to be explicit

[17:10] <PerlJam> Hmm.

[17:11] <timotimo> i'm unable to assign anything to the .WHY as in S26. wouldn't it be my $blob; #= some text  -  and then say $blob.WHY ?

[17:13] <benabik> timotimo: I believe that's how it's supposed to work.  I think it's NYI

[17:13] <TimToady> I suspect it's NYI on variables

[17:13] <[Coke]> flussence++ # browser analogy for perl5,6

[17:13] <timotimo> OK

[17:13] <timotimo> it's still nice to have it

[17:16] <PerlJam> timotimo: it works on subs and methods and classes and such though

[17:17] <timotimo> oh, great

[17:18] *** xinming left
[17:19] * [Coke] gets sucked into reading a perlmonks flamewar. there's 5 minutes I'll never get back.

[17:19] *** am0c joined
[17:19] *** xinming joined
[17:21] *** spine_ left
[17:21] <TimToady> well, you already know that if either of the main culprits gets involved, it's gonna go down to level 25 or 30

[17:22] <[Coke]> thankfully, pm is so slow I rarely dig to lower levels. ;)

[17:24] <TimToady> not naming any names, but "silence betokens consent" is a lame excuse for always wanting the last word, in my opinion.

[17:26] <moritz> [Coke]: (stackoverflow edits) no, I'm not reviewing edits there

[17:26] * PerlJam notes how most of #perl6 is consenting to TimToady 

[17:27] <Su-Shee> this is one of those "bonmots" which are driving me crazy as a political scientist. 

[17:28] <pmichaud> good morning, #perl6

[17:29] <moritz> good am, pm

[17:29] <[Coke]> PerlJam: no, he just talks a lot. odds are he's got the last word.

[17:30] * TimToady ♥ baysian statistics

[17:32] <[Coke]> .u spade

[17:32] <phenny> U+2660 BLACK SPADE SUIT (♠)

[17:32] * [Coke] is reminded to finally finish masak's poker hand ranker.

[17:33] <TimToady> .oO( spa.de )

[17:34] *** MayDaniel joined
[17:38] *** daxim left
[17:43] *** bluescreen10 left
[17:48] <TimToady> ♨̈

[17:49] <timotimo> jnthn: i'm trying to run your SDL.pl, but i get "Unknown type SDL_Surface used in native call.", although the class is created before

[17:50] <timotimo> wait. that is yours, right? if not, look here: https://raw.github.com/PerlGameDev/SDL6/master/SDL.pl

[17:52] <timotimo> never mind. is repr('CPointer') works

[17:53] *** MayDaniel left
[17:54] <timotimo> would it be interesting if i were to bind SDL a bit more completely the same way?

[17:54] <timotimo> or is that the wrong way to do it?

[17:56] <moritz> I wonder if 'copy' and 'rename' should be subs in the setting, or static methods in IO

[17:56] *** xinming left
[17:57] *** bluescreen10 joined
[17:57] *** pernatiy left
[17:58] *** xinming joined
[17:58] *** dakkar left
[18:00] <flussence> +1 for IO methods, I'm not a big fan of adding loose subs when there's a pre-existing namespace they'd fit into

[18:00] *** am0c left
[18:01] <flussence> timotimo: I wrote some NativeCall stuff, it might give you a few ideas: https://github.com/flussence/perl6-XMMS2/tree/master/lib/XMMS2

[18:07] <timotimo> ah, i'm a fan of xmms2 and i read that perl6advent, too

[18:07] <timotimo> but sdl can't be handled with OpaquePointer only

[18:09] *** tarch joined
[18:09] *** xinming left
[18:10] *** birdwindupbird joined
[18:10] *** xinming joined
[18:11] *** tarch left
[18:11] *** DarthGandalf left
[18:11] *** tarch_ joined
[18:12] *** DarthGandalf joined
[18:13] *** am0c joined
[18:13] *** tarch__ joined
[18:13] *** tarch_ left
[18:16] *** mj41 left
[18:17] *** xinming left
[18:18] *** xinming joined
[18:30] <dalek> rakudo/nom: 9d8b140 | moritz++ | src/ (3 files):

[18:30] <dalek> rakudo/nom: implement &copy

[18:30] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/9d8b140d57

[18:31] *** tarch__ left
[18:33] <moritz> fwiw I've just implemented &copy and &rename, just so that they are available. I don't expect that to be the real thing

[18:35] *** preflex_ joined
[18:37] <moritz> I just hope I gave them more awesome error messages than is standard

[18:37] *** preflex left
[18:37] *** preflex_ is now known as preflex

[18:37] <moritz> $ ./perl6 -e 'rename("foo", "bar")'

[18:37] <moritz> Failed to rename file from 'foo' to 'bar': No such file or directory

[18:37] <moritz> should probably remove the 'from'

[18:38] <PerlJam> or even remove "file from "

[18:38] <PerlJam> Failed to rename 'foo' to 'bar': No such file or directory

[18:38] <moritz> aye

[18:39] <TimToady> funny thing is you can get that error from the right side as well as the left

[18:39] <TimToady> rename("foo", "nonesuch/bar")

[18:40] <dalek> rakudo/nom: 3808f94 | moritz++ | src/core/Exceptions.pm:

[18:40] <dalek> rakudo/nom: awesomize error messages, PerlJam++

[18:40] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/3808f94670

[18:40] <masak> maybe indicate which side, then.

[18:40] <moritz> TimToady: I know

[18:40] <moritz> TimToady: but I cannot provide information that the OS doesn't give me :/

[18:40] <TimToady> well, errno doesn't help, but you can probe

[18:40] <TimToady> so yes, you can give info that the OS provides in subsequent calls :)

[18:41] <PerlJam> yeah, if you're dying anyway, a little extra work on the way out can be very beneficial to the users

[18:43] *** mj41 joined
[18:49] <skids> https://github.com/skids/perl6netpack  # <-- first (tiny bit of) usable code from my dabblings.  Comments welcome.

[19:01] * colomon just realized that niecza's speed is fine, it's colomon's brain which is the problem

[19:02] <sorear> what happened to your brain?

[19:03] <colomon> lost an underscore somewhere

[19:03] <colomon> TESTJOBS=4 is much slower than TEST_JOBS=4

[19:11] <masak> skids: looks nice so far.

[19:12] <masak> lots of documentation. :)

[19:12] <masak> worthy of a CPAN module, I guess.

[19:23] <dalek> rakudo/nom: d69ad77 | moritz++ | src/core/IO.pm:

[19:23] <dalek> rakudo/nom: fix class name, kboga++

[19:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d69ad77a1d

[19:23] <sorear> colomon: glad that's resolved

[19:24] <colomon> sorear: very sorry to have worried you about nothing

[19:24] <sorear> colomon: it kind of worked out fine because I've been too busy to worry. :)

[19:25] <moritz> ehm, I should test the stuff before I commit it :/

[19:26] <moritz> it feels I should unify X::IO::Rename and X::IO::Copy

[19:27] <moritz> they are both of the form "Cannot $.operate $.from to $.to: $.os-error"

[19:27] <moritz> but what should the class be called?

[19:27] <moritz> X::IO::SourceDestOperation? sounds ugly

[19:27] <benabik> X::IO::BinaryOp?

[19:28] <moritz> opening a pipe is also a binary operation

[19:34] <dalek> rakudo/nom: a0a467a | moritz++ | src/core/IO.pm:

[19:34] <dalek> rakudo/nom: fix previous commit, moritz--

[19:34] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/a0a467a890

[19:36] <masak> moritz: X::IO::Copy.

[19:36] <moritz> masak: you mean &rename should use X::IO::Copy too?

[19:36] <masak> I mean that.

[19:36] <moritz> hm.

[19:38] <masak> copying may not be how the rename is implemented underneath -- it's probably something clever with inodes -- but a move feels like a copy plus a remove when you think about it.

[19:39] <masak> and in that sense, it's the "copy" part of the move that goes wrong, and so it makes sense for both of them to be X::IO::Copy :)

[19:43] *** icwiener left
[19:43] *** icwiener joined
[19:50] *** birdwindupbird left
[19:54] <masak> nice, easy-to-understand benchmarking statistics: http://bos.github.com/criterion/

[19:54] <masak> (in case someone is pondering doing something similar for rakudo/niecza benchmarks)

[19:59] *** MayDaniel joined
[20:00] *** snearch joined
[20:00] *** tarch__ joined
[20:07] <masak> [Coke]: yes, please finish the poker hand ranker. \o/

[20:07] <masak> PerlJam: it's funny, I was just discussing signatures/defaults like that the other day. I'll see if I can find it in the backlog.

[20:13] *** snearch left
[20:13] <masak> PerlJam: ah yes, here: http://irclog.perlgeek.de/perl6/2012-01-29#i_5070174

[20:14] <moritz> niecza; say 123.fmt('b')

[20:14] <moritz> niecza: say 123.fmt('%b')

[20:14] <p6eval> niecza v14-23-g0699296: OUTPUT«1111011␤»

[20:15] <sorear> ow, lots I need to read for criterion

[20:15] <sorear> cool that bos is still around

[20:16] * sorear looks at moritz' latest ticket, finds eirself kind of disagreeing

[20:17] <sorear> mv(1) calls rename, and if that fails falls back to copy&delete

[20:17] <sorear> there's a lot of policy inherent in the latter

[20:18] <sorear> Perl 6 needs a certain amout of policy-free functionality, and we can't do that so easily if the policy is baked in at the Parrot level

[20:20] *** pernatiy joined
[20:22] <masak> sorear: ticket url?

[20:22] <PerlJam> masak: it might get confusing when someone does   my ($a,$b = 5) = @stuff;  # since those = don't quite mean the same thing.

[20:22] <sorear> https://github.com/parrot/parrot/issues/713

[20:23] <masak> PerlJam: so maybe it makes sense to relegate such tricks to the ':($a, $b = 5) = ...' form?

[20:23] <masak> sorear: thank you.

[20:25] <masak> seems discussion gets going after people implement a working version of something. :) that's probably a force we can use to our advantage.

[20:33] <moritz> sorear: I'm not suggesting to *replace* rename

[20:36] *** icwiener_ joined
[20:36] <timotimo> perl6: my $exitcode = 5 but False; if $exitcode { say "yup" } else { say "nop" }

[20:36] <p6eval> pugs b927740: OUTPUT«*** Cannot cast from VBool False to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[20:36] <p6eval> ..niecza v14-23-g0699296: OUTPUT«nop␤»

[20:36] <p6eval> ..rakudo a0a467: OUTPUT«yup␤»

[20:36] <timotimo> hooray

[20:37] *** icwiener left
[20:42] <benabik> Hm.  Why does (5 but False) .Bool and .so to False, but eval to True in if statements? (in nom)

[20:45] <PerlJam> benabik: you're using an old nom ?

[20:46] <benabik> PerlJam: On p6eval.

[20:46] <benabik> nom: my $n = 5 but False;  say ?$n; say $n ?? 'T' !! 'F'

[20:46] <p6eval> nom a0a467: OUTPUT«False␤T␤»

[20:46] <PerlJam> crazy

[20:47] <timotimo> how exactly does but False work? is False a type, a class or is it an instance?

[20:47] <timotimo> perl6: Bool.WHAT

[20:47] <p6eval> pugs b927740, rakudo a0a467, niecza v14-23-g0699296:  ( no output )

[20:47] <timotimo> perl6: say Bool.WHAT

[20:47] <p6eval> rakudo a0a467, niecza v14-23-g0699296: OUTPUT«Bool()␤»

[20:47] <p6eval> ..pugs b927740: OUTPUT«Bool␤»

[20:48] <benabik> False is an instance of the Bool enum.  (more)

[20:48] * timotimo hits return

[20:48] <benabik> 5 but False returns an object that is 5 except that the .Bool method returns False.

[20:49] <timotimo> how exactly does perl6 get from "Bool::False" to "overide only .Bool to return False"?

[20:49] <benabik> $foo but $bar overrides the "$bar.WHAT" method in $foo to return $bar.

[20:49] <benabik> IIUC

[20:50] *** y3llow_ joined
[20:50] *** pothos_ joined
[20:50] <timotimo> how come evaluation in boolean context goes over .WHAT?

[20:50] <timotimo> instead of directly?

[20:50] <timotimo> or is every "direct" call done via .WHAT?

[20:50] <timotimo> like .^ is done via .HOW

[20:51] <benabik> It doesn't call .WHAT...  It calls .Bool

[20:51] <benabik> nom: class Foo { method Bool() { True } }; say Foo.new ?? 'Hi' !! 'nope'

[20:51] <timotimo> so how does changing .WHAT change what .Bool does?

[20:51] <p6eval> nom a0a467: OUTPUT«Hi␤»

[20:51] *** y3llow left
[20:52] *** pothos left
[20:52] *** y3llow_ left
[20:52] <benabik> It doesn't change .WHAT.  It overrides the method with the same name as $bar's .WHAT

[20:52] <timotimo> perl6: my $nom = True but False; say $nom; say ?$nom;

[20:52] <benabik> (Sorry if that wasn't clear)

[20:52] <p6eval> rakudo a0a467: OUTPUT«True␤True␤»

[20:52] <p6eval> ..niecza v14-23-g0699296: OUTPUT«True␤False␤»

[20:52] <p6eval> ..pugs b927740: OUTPUT«*** Cannot cast from VBool False to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[20:52] *** y3llow joined
[20:52] <benabik> Poor pugs.

[20:52] <timotimo> yeah

[20:53] *** pothos_ left
[20:53] *** pothos joined
[20:53] <timotimo> so class Foo { method Bool() { True } }; my $toot = 5 but Foo;  should not actually change the Bool method of $toot, because the class is called Foo?

[20:54] <benabik> Right.

[20:54] <timotimo> because Foo.WHAT is "Foo"

[20:54] <timotimo> i see

[20:54] <benabik> It'll change the .Foo method.

[20:54] <benabik> But 5 does Foo will override Bool because it's mixing in the role.

[20:54] *** y3llow left
[20:55] *** y3llow joined
[20:55] <timotimo> ah!

[20:55] <benabik> nom: class Foo { method Bool() { True } }; my $x = 5; say ($x but Foo.new).Bool; say ($x does Foo).Bool

[20:55] <p6eval> nom a0a467: OUTPUT«True␤Method 'specialize' not found for invocant of class 'Perl6::Metamodel::ClassHOW'␤  in <anon> at src/gen/Metamodel.pm:2075␤  in <anon> at src/gen/Metamodel.pm:2071␤  in compose at src/gen/Metamodel.pm:2069␤  in mixin at src/gen/Metamodel.pm:947␤  in sub infix:<doe…

[20:55] <benabik> Oops?

[20:55] <benabik> nom: role Foo { method Bool() { True } }; my $x = 5; say ($x but Foo.new).Bool; say ($x does Foo).Bool

[20:55] <p6eval> nom a0a467: OUTPUT«True␤True␤»

[20:55] <benabik> nom: role Foo { method Bool() { False } }; my $x = 5; say ($x but Foo.new).Bool; say ($x does Foo).Bool

[20:55] <p6eval> nom a0a467: OUTPUT«True␤False␤»

[20:56] <benabik> Hard to see the difference when both cases do the same thing.

[20:59] <dalek> rakudo/nom: 0711f9f | moritz++ | src/ (2 files):

[20:59] <dalek> rakudo/nom: X::Undeclared errors for undeclared variables

[20:59] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0711f9f510

[21:04] *** GlitchMr left
[21:05] <timotimo> perl6: say (True but 5).Int; say +(True but 5);

[21:06] <timotimo> how come?

[21:06] <p6eval> pugs b927740: OUTPUT«*** Cannot cast from VInt 5 to VCode (VCode)␤    at Prelude.pm line 541, column 5-16␤»

[21:06] <p6eval> ..rakudo a0a467, niecza v14-23-g0699296: OUTPUT«5␤1␤»

[21:06] <timotimo> does + call .Num or something?

[21:06] <timotimo> seems so

[21:06] <masak> yeah.

[21:07] <benabik> .Numeric, IIRC

[21:07] <benabik> Yes.  I've said before that I think but should create methods for all roles the new value has that the old one doesn't.  That way more cases like that can be caught.

[21:08] <timotimo> is that easily introspectable?

[21:08] <benabik> Probably?

[21:09] <timotimo> via the .HOW object/metaobject?

[21:09] <benabik> Yes.

[21:11] <timotimo> oh, what did i do now?

[21:11] <timotimo> perl6: say 5^.^methods; say 5.^methods

[21:11] <p6eval> niecza v14-23-g0699296: OUTPUT«Unhandled exception: Unable to resolve method methods in class ClassHOW␤  at /tmp/Xz7JcA3V8j line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3744 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3745 (module-CORE @ 65) ␤  at…

[21:11] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "^.^"␤    expecting "_", fraction, exponent, term postfix, operator, ":" or ","␤    at /tmp/lk5xTHDXoy line 1, column 6␤»

[21:11] <p6eval> ..rakudo a0a467: OUTPUT«one(5, eager elems end classify uniq infinite flat tree hash list pick roll reverse sort values keys kv pairs Array grep first join map min max minmax postcircumfix:<[ ]> at_pos all any one none postcircumfix:<{ }> reduce ACCEPTS)␤Int Num Rat abs Bridge chr succ pr…

[21:11] <timotimo> i somehow made a junction?

[21:11] <timotimo> at least in rakudo

[21:12] <timotimo> std: say 5^.^methods

[21:12] <p6eval> std 48335fc: OUTPUT«ok 00:01 109m␤»

[21:12] <benabik> nom: say (5^).WHAT

[21:12] <p6eval> nom a0a467: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2␤»

[21:12] <PerlJam> timotimo: 5^ doesn't do what ever you think it does

[21:13] <benabik> Oh.

[21:13] <timotimo> i didn't think it did anything

[21:13] <benabik> It's doing (5) ^ (.^methods)

[21:13] <timotimo> i just thought ^.^ looked cute ;)

[21:13] <timotimo> aaaaaaah, hehehe

[21:13] <PerlJam> timotimo: what benabik said

[21:13] <benabik> aka (5) ^ ($_.^methods)

[21:14] <PerlJam> timotimo: there's a high probability that random text not only looks cute, but is a valid Perl 6 program  ;)

[21:14] <timotimo> what's the failure in niecza related to? not being able to enumerate the methods of the $_?

[21:14] <timotimo> i hope i'm not annoying you with my senseless prodding at the perl6 grammar

[21:14] <moritz> timotimo: I think niecza simply doesn't do introspection yet

[21:14] <timotimo> that would of course explain it nicely

[21:15] <moritz> nom: class A { sub f { has $.x } }

[21:15] <p6eval> nom a0a467: OUTPUT«use of uninitialized value of type Mu in string context␤use of uninitialized value of type Mu in string context␤===SORRY!===␤error:imcc:syntax error, unexpected '\n'␤       in file '(file unknown)' line 488␤␤»

[21:15] <moritz> wow :-)

[21:15] <benabik> imcc syntax error?

[21:17] <[Coke]> moritz++ #well played, sirl.

[21:17] <[Coke]> *sir

[21:17] * masak submits rakudobug

[21:20] *** MayDaniel left
[21:20] *** explorer__ joined
[21:21] *** explorer__ left
[21:24] <[Coke]> masak++ editing my send in post.

[21:25] <moritz> niecza: class A { sub f { has $.x } }

[21:25] <p6eval> niecza v14-23-g0699296: OUTPUT«[31m===[0mSORRY![31m===[0m␤␤Attribute $!x declared outside of any class at /tmp/Xm690Y8LyV line 1:␤------> [32mclass A { sub f { has $.x [33m⏏[31m} }[0m␤␤Potential difficulties:␤  &f is declared but not used at /tmp/Xm690Y8LyV line 1:␤------> [32m…

[21:27] <masak> [Coke]: I always do that.

[21:27] <masak> in my bug reports, everyone's an excellent writer. :)

[21:28] <masak> I even made did talk about that twice.

[21:28] <masak> s/did //

[21:29] <moritz> masak: did you think of any interesting strategies for prisoner's dilemma over lunch?

[21:29] <[Coke]> \o/, I finally got enough karma in SO to actually do things. ;)

[21:29] <[Coke]> too bad moritz already answered all the perl6 questions. ;)

[21:30] <moritz> not the last one :-)

[21:30] <moritz> (about :from<perl5>)

[21:32] <[Coke]> yah, i was avoiding that, as I'm pretty sure the answer is still NYI.

[21:32] <masak> moritz: no, I got sucked into a conversation with a colleague about solutions to t4... :/

[21:32] <[Coke]> moritz: is there a way to see who upvoted you?

[21:33] <moritz> [Coke]: I don't think so

[21:34] *** tokuhirom joined
[21:38] <moritz> fwiw I've got the first prisoner's dilemma submission

[21:38] * moritz -> sleep

[21:44] *** jferrero left
[21:44] *** kaare_ left
[21:46] *** icwiener_ left
[21:47] <masak> 'night, moritz. dream of the ultimate prisoner's dilemma strategy ;)

[21:48] *** sudokode left
[21:52] *** sudokode joined
[21:59] *** bluescreen10 left
[22:13] *** bluescreen10 joined
[22:14] *** bluescreen10 left
[22:17] *** skids left
[22:18] *** ab5tract left
[22:24] *** unobe joined
[22:36] *** jferrero joined
[22:52] <masak> ...and 'night, #perl6

[23:10] *** whiteknight joined
[23:22] *** jlaire left
[23:31] *** mj41 left
[23:35] *** stepnem left
[23:40] *** stepnem joined
[23:40] *** jlaire joined
[23:41] *** zjmarlow left
[23:42] *** PacoAir left
[23:43] *** tarch__ left
[23:44] *** skids joined
[23:45] *** mtk left
