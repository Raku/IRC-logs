[00:03] *** b1rkh0ff left
[00:04] *** PacoAir left
[00:08] <diakopter> karam niecza

[00:08] <diakopter> karma niecza

[00:08] <aloha> niecza has karma of 75.

[00:08] <diakopter> karma rakudo

[00:08] <aloha> rakudo has karma of 67.

[00:08] <sorear> karma sorear

[00:08] <aloha> sorear has karma of 2159.

[00:08] <sorear> karma jnthn

[00:08] <aloha> jnthn has karma of 2642.

[00:08] <diakopter> karma pugs

[00:08] <aloha> pugs has karma of 20.

[00:10] *** libertyprime left
[00:10] *** libertyprime joined
[00:12] <sorear> pugs predates aloha :p

[00:14] *** Chillance left
[00:16] *** adu left
[00:17] *** libertyprime left
[00:18] *** libertyprime joined
[00:21] *** ab5tract left
[00:22] *** libertyprime left
[00:22] *** libertyprime joined
[00:25] *** libertyprime left
[00:26] *** libertyprime joined
[00:47] <TimToady> r: my module A { enum X is export <x> }; import A <x>; x

[00:47] <p6eval> rakudo 024843: OUTPUT«===SORRY!===␤Error while importing from 'A': no EXPORT sub, but you provided positional argument in the 'use' statement␤»

[00:47] <TimToady> two bugs for the price of one

[00:48] <TimToady> r: my module A { enum X is export <x> }; import A <X>; x

[00:48] <p6eval> rakudo 024843: OUTPUT«===SORRY!===␤Error while importing from 'A': no EXPORT sub, but you provided positional argument in the 'use' statement␤»

[00:49] <TimToady> (the second one being that I didn't provide a 'use' statement...)

[00:51] <TimToady> should be something more on the order of "Don't know how to import X from A"

[00:51] <TimToady> the first bug being that it should know how...

[00:52] <diakopter> hm, I'm starting to suspect I've been spamming people all day.. whoever's subscribed to rakudo RT

[00:53] <TimToady> receiving death threats?

[00:53] <diakopter> not yet

[00:54] <diakopter> r: my module A { }; require A;

[00:54] <p6eval> rakudo 024843: OUTPUT«Could not find A in any of: /home/p6eval/.perl6/lib, /home/p6eval/nom-inst2/lib/parrot/4.4.0-devel/languages/perl6/lib␤  in any load_module at src/Perl6/ModuleLoader.pm:99␤  in block <anon> at /tmp/mQmeWOiwNw:1␤␤»

[00:54] <diakopter> what should it do if there's already a module A loaded

[00:55] <diakopter> n: my module A { }; use A;

[00:55] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Unable to locate module A in @path␤  at /home/p6eval/niecza/boot/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/src/NieczaPathSearch.pm6 line 23 (NieczaPathSearch.load_module @ 17) ␤  at /home/p6eval/niecza/src/NieczaCom…

[00:57] <diakopter> rt's down again

[00:58] <TimToady> n: my module A { }; need A

[00:58] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Action method statement_control:need not yet implemented at /tmp/TIg2g20bLr line 1 (EOF):␤------> my module A { }; need A⏏<EOL>␤␤Unhandled exception: Unable to resolve method statement_level in type Any␤  a…

[00:58] <TimToady> r: my module A { }; need A

[00:58] <p6eval> rakudo 024843: OUTPUT«===SORRY!===␤Could not find A in any of: /home/p6eval/.perl6/lib, /home/p6eval/nom-inst2/lib/parrot/4.4.0-devel/languages/perl6/lib␤»

[01:00] <TimToady> it doesn't really make sense to 'need' a module you've already defined in this unit

[01:02] <TimToady> need and require are only for pulling in external modules

[01:02] <diakopter> r: use Test; use Test;

[01:02] <p6eval> rakudo 024843: OUTPUT«===SORRY!===␤Cannot import symbol '&plan' from package 'Test', since it already exists in the lexpad␤»

[01:03] <diakopter> is that a good error?

[01:03] <TimToady> implicit imports should also probably follow the cancellation policy of enums

[01:03] <TimToady> and enums should just be a special case of that

[01:03] <TimToady> here's the reasoning

[01:03] <TimToady> modules change over time, and new exports are added

[01:04] <TimToady> if you blow up on a collision, you potentially break programs merely by upgrading the module

[01:04] <TimToady> if you merely blow up on use of a colliding symbol, you at least don't blow up if the user doesn't care about that symbol

[01:05] <TimToady> you only blow up if they've actually used it, and it has become ambiguous

[01:05] <TimToady> so 'use A; use B;' might collide with symbol X, but that doesn't matter unless you actually use X

[01:05] <diakopter> if a module you 'use' 'use's another module that auto-imports stuff, do you get the imports too?

[01:06] <TimToady> there should be a way to import/export transitively

[01:07] <diakopter> gobble Test;

[01:07] <TimToady> see S11:153

[01:08] <diakopter> oh, so all the intervening ones must also pass through their imports

[01:09] <TimToady> there may be a better syntax for this

[01:09] * TimToady glares at the inside of his eyelids and sees nothing much

[01:10] <diakopter> maybe there's a way to exclude a module from exporting certain symbols to you, so you can pre-use dependencies to import from them

[01:10] <diakopter> or specify which ones you do want... oh wait.

[01:10] <diakopter> there's the problem of conflicting symbols from imports, and you really do want one of them

[01:12] <diakopter> oh wait.  /me reads further on S11

[01:13] <diakopter> so you can send unwanted symbols to a dummy namespace/scope

[01:14] <TimToady> it is not clear to me that S11 is actually coherent on this subject

[01:15] *** libertyprime left
[01:15] *** libertyprime joined
[01:16] <diakopter> well, I finished going through all of rakudo rt

[01:18] <diakopter> now there's 129 testneeded tickets, up from about 80. 5 merged, a couple resolved, a couple rejected because of spec changes

[01:18] <diakopter> now to go through the testneeded ones.... :|

[01:19] <diakopter> I guess that'll be my chance to learn the test suite

[01:19] <diakopter> again.

[01:20] *** thou left
[01:20] *** libertyprime left
[01:21] *** libertyprime joined
[01:26] *** thou joined
[01:28] *** scott_ joined
[01:28] *** scott_ is now known as Guest5520

[01:28] *** Guest22737 left
[01:38] *** libertyprime left
[01:38] *** libertyprime joined
[01:47] <diakopter> I'm guessing most of the ones marked testneeded actually have tests already

[01:53] <TimToady> you should test that :)

[01:58] <diakopter> I'm stuck on the first one. #53804

[01:58] <diakopter> I can't tell whether it needs a test or not

[01:58] <diakopter> both the version without and with whitespace work

[01:59] <TimToady> shouldn't tests be commented with the RT they test for?

[01:59] *** thou left
[02:00] <TimToady> or are you looking for accidental tests?  :)

[02:01] <diakopter> ones that are now succeeding, and cover the functionality testing the brokenness of the bug, and the person who wrote the test didn't know about the bug ticket (probably because it didn't exist), or the person who wrote the ticket didn't know about the test, and

[02:01] <diakopter> the unfudger didn't know there was a bug ticket relating to that functionality

[02:05] *** thou joined
[02:06] *** tokuhiro_ left
[02:10] <diakopter> TimToady: is this correct? 

[02:11] <diakopter> r: my @array = 1, 2, 3; say @array.min:{ $^a <=> $^b }

[02:11] <p6eval> rakudo 024843: OUTPUT«1␤»

[02:11] <diakopter> the RT ticket has to do with the lack of space between : and {

[02:12] <diakopter> previously rakudo didn't parse that

[02:12] <diakopter> pmichaud++ guessed it should be parsed by colonpair

[02:13] <diakopter> TimToady: https://rt.perl.org/rt3//Public/Bug/Display.html?id=53804

[02:14] <diakopter> n: my @array = 1, 2, 3; say @array.min:{ $^a <=> $^b }

[02:14] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«1␤»

[02:18] <dalek> roast: ed219b0 | diakopter++ | S32-list/minmax.t:

[02:18] <dalek> roast: add test for adverbial block form of min (RT #53804)

[02:18] <dalek> roast: review: https://github.com/perl6/roast/commit/ed219b0768

[02:18] <dalek> roast: aaab8c2 | diakopter++ | S (9 files):

[02:18] <dalek> roast: Merge branch 'master' of git://github.com/perl6/roast

[02:18] <dalek> roast: review: https://github.com/perl6/roast/commit/aaab8c2b55

[02:19] *** leprevost joined
[02:21] *** wooden left
[02:27] <diakopter> TimToady: such as the TODO ticket to implement NEXT. the tests didn't know about the RT and vice versa.

[02:34] *** libertyprime left
[02:34] *** libertyprime joined
[02:39] *** JimmyZ_ joined
[02:39] <JimmyZ_> diakopter: ping

[02:40] <[Coke]> diakopter: it's good you send out the messages on the tickets. I prefer to always cc perl6.

[02:40] * [Coke] waves from a undisclosed bunker in CT.

[02:40] * sorear waves back to [Coke]

[02:41] <[Coke]> diakopter++ RT carnage.

[02:42] <diakopter> [Coke]: actually I'm not on whatever list receives those

[02:42] <diakopter> which one does

[02:43] <diakopter> [Coke]: how do I write a test that just tests whether eval code doesn't die

[02:43] *** xinming joined
[02:43] <diakopter> doesn't misparse, I mean

[02:44] <TimToady> put a leave; first

[02:45] <TimToady> :{} not recognized as a valid name extension, so it parses as if there were a space there

[02:45] <TimToady> after the :

[02:46] *** xinming_ left
[02:46] <diakopter> ok. it works on rakudo now, however it parses

[02:46] <diakopter> put a leave; first where?

[02:48] <TimToady> eval "leave; stuff-to-parse"

[02:48] <buubot_backup> TimToady: leave; stuff-to-parse

[02:48] <TimToady> heh

[02:48] *** JimmyZ_ left
[02:49] <diakopter> what does the leave do? 

[02:50] <[Coke]> diakopter: you have to explicitly hit the "cc the list" button to spam the list.

[02:50] <[Coke]> if you close a ticket, the OP is notified.

[02:50] <diakopter> ah

[02:50] <[Coke]> diakopter: eval_lives_ok

[02:51] <diakopter> ah

[02:52] * diakopter thinks a test for #63596 should go in S06-signature/named-parameters.t

[02:53] <diakopter> oh wait; std/niecza doesn't like the test

[02:53] <diakopter> p6: sub s($i is copy) { my @array; for 1..3 { @array.push($i); my $i = 1 + $i; }}; s(9);

[02:53] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Lexical symbol '$i' is already bound to an outer symbol (see line 1);␤  the implicit outer binding at line 1 must be rewritten as $i␤  before you can unambiguously declare a new '$i' in this scope at /tmp/47XafYYQoo line 1:␤-…

[02:53] <p6eval> ..rakudo 024843: OUTPUT«use of uninitialized variable $i of type Any in numeric context  in sub s at /tmp/tG2G1TJxh3:1␤␤use of uninitialized variable $i of type Any in numeric context  in sub s at /tmp/tG2G1TJxh3:1␤␤use of uninitialized variable $i of type Any in numeric context  in sub s…

[02:53] <p6eval> ..pugs: OUTPUT«*** ␤    Unexpected ";"␤    expecting "::", term postfix or operator␤    Redeclaration of "$i" conflicts with earlier OUTER references in the same scope␤    at /tmp/fZQERhne6f line 1, column 74␤»

[02:54] <diakopter> the bug was originally that it Null PMC

[02:55] <diakopter> it doesn't do the right thing in rakudo (error), but at least it doesn't Null PMC

[02:55] <diakopter> anyway that's testable.

[03:01] *** libertyprime left
[03:02] *** libertyprime joined
[03:09] <dalek> roast: 7ea105f | diakopter++ | S02-names-vars/variables-and-packages.t:

[03:09] <dalek> roast: add test for RT #63596 (null pmc) - rakudo still does not do the right thing, so it fails the test, but for another reason.

[03:09] <dalek> roast: review: https://github.com/perl6/roast/commit/7ea105f5a6

[03:10] <diakopter> [Coke]: oh noes. https://rt.perl.org/rt3/perl6/testneeded is broken

[03:10] *** adu joined
[03:11] *** wolfman2000 left
[03:15] *** aesundstrom left
[03:15] <diakopter> [Coke]: nm... oops wrong url

[03:15] <diakopter> sorry

[03:19] *** adu left
[03:20] *** adu joined
[03:37] <dalek> roast: a9a75b0 | diakopter++ | S02-types/lists.t:

[03:37] <dalek> roast: add test for RT #63986 - negative indexes; rakudo and niecza pass it

[03:37] <dalek> roast: review: https://github.com/perl6/roast/commit/a9a75b0a13

[03:52] *** crab2313 left
[03:56] <dalek> roast: 87dfafd | diakopter++ | S03-operators/assign.t:

[03:56] <dalek> roast: fix tests for RT #64818 - R~= actually does parse. test it.

[03:56] <dalek> roast: review: https://github.com/perl6/roast/commit/87dfafdf7c

[04:08] *** thou left
[04:24] *** adu left
[04:28] *** sisar left
[04:29] *** sisar joined
[04:51] *** kcwu left
[04:52] *** kcwu joined
[04:56] *** leprevost left
[05:06] *** Entonian joined
[05:07] *** Entonian left
[05:10] *** fgomez left
[05:11] <moritz> r: say q=>1     

[05:11] <p6eval> rakudo 024843: OUTPUT«␤»

[05:11] <moritz> r: say (q=>1)

[05:11] <p6eval> rakudo 024843: OUTPUT«"q" => 1␤»

[05:13] *** birdwindupbird joined
[05:13] *** birdwind1pbird joined
[05:14] <moritz> r: say (q=>1), (p=)

[05:14] <p6eval> rakudo 024843: OUTPUT«>1), (p␤»

[05:14] <moritz> r: my @a := 1..*; @a := @a[1, 3 ... *]; say @a[^5]

[05:15] <p6eval> rakudo 024843: OUTPUT«(timeout)»

[05:16] <moritz> std: say (q=>1), (p=)

[05:16] <p6eval> std f179a1b: OUTPUT«Use of uninitialized value $x in pattern match (m//) at STD.pm line 66577.␤Use of uninitialized value $x in concatenation (.) or string at STD.pm line 66616.␤===SORRY!===␤Bogus term at /tmp/s4FYlZo4YE line 1:␤------> say (q=>1), (p=⏏)…

[05:31] *** Telg left
[05:31] *** stephenlb left
[05:33] *** Telg joined
[05:50] *** lestrrat left
[05:51] *** lestrrat joined
[06:00] *** wtw joined
[06:04] *** kaleem joined
[06:13] *** araujo left
[06:26] *** araujo joined
[06:27] *** pupoque joined
[06:33] *** araujo left
[06:55] *** araujo joined
[07:05] *** kurahaupo left
[07:16] <tadzik> hello #perl6

[07:17] <moritz> \o tadzik 

[07:33] *** kresike joined
[07:33] <kresike> morning all you happy perl6 people

[07:34] <tadzik> hey hey kresike 

[07:34] <kresike> hello tadzik 

[07:37] *** lestrrat left
[07:37] *** brrt joined
[07:38] *** lestrrat joined
[07:55] *** fhelmberger joined
[08:01] *** lestrrat left
[08:02] *** lestrrat joined
[08:20] <jnthn> morning o/

[08:21] <moritz> \o jnthn 

[08:22] <moritz> jnthn: I looked at STD.pm6's handling of 'Null pattern not allowed' -- it requires access to $*GOAL

[08:22] <moritz> ie the rightest token of things like  \[ ~ \]

[08:22] <moritz> jnthn: is that accessible from within an NQP grammar?

[08:24] <jnthn> moritz: Ah, it's not being placed in a contextual at the moment.

[08:25] <jnthn> Is it spec that it goes in $*GOAL?

[08:25] <jnthn> Also, does :dba(...) populate $*DBA? I may as well fix that at the same time...

[08:26] <jnthn> STD doesn't mention any contextual variables, fwiw.

[08:26] <jnthn> er

[08:26] <jnthn> *S05* doesn't mention.

[08:26] <moritz> the spec mentions $GOAL when talking about ~ expansion

[08:26] <eiro> tadzik, can you please fill your proposal ? 

[08:27] <jnthn> moritz: I wonder if it means $*GOAL.

[08:27] <moritz> jnthn: wait :-)

[08:27] <moritz> STD.pm6 explicitly sets $*GOAL occasionally

[08:27] <eiro> also: tadzik jnthn cognominal masak : how about a hackathlon to implement spore spec in perl6 ( https://github.com/SPORE/specifications ) 

[08:27] <moritz> maybe it's not supplied by the regex engine after all

[08:28] <eiro> would be great with bailador to write web workers 

[08:28] *** sergot joined
[08:28] <sergot> hi o/

[08:29] <tadzik> eiro: yeah, sure. I'll probably do it later today

[08:29] <tadzik> hackathon: sounds cool :)

[08:29] <tadzik> hello sergot 

[08:32] <eiro> if everyone is ok: i'll make an announcement on that 

[08:38] <jnthn> moritz: OK. Well, wasn't going to do it right away...but can probably find tuits today if we can figure out how it should be :)

[08:39] *** pupoque left
[08:59] <moritz> nqp: say(' ' ~~ /<-[\w\s]>/)

[08:59] <p6eval> nqp: OUTPUT«␤»

[08:59] <moritz> nqp: say('.' ~~ /<-[\w\s]>/)

[08:59] <p6eval> nqp: OUTPUT«.␤»

[09:00] *** dakkar joined
[09:12] *** daxim joined
[09:17] *** grondilu joined
[09:17] <grondilu> p6: class Foo { has $.x }; my Foo $f .= new; $f.x = 42;

[09:17] <p6eval> pugs, niecza v18-1-gc86e3f0:  ( no output )

[09:17] <p6eval> ..rakudo 024843: OUTPUT«Cannot assign to a readonly variable or a value␤  in block <anon> at /tmp/UocfsFH6fH:1␤␤»

[09:17] <grondilu> ??

[09:18] <cognominal> eiro: for the frech workshop, my goal is to deliver tutorial and exercises to  help people bootstrap themselves into Perl 6. And I think existing contributors who will come have already a full agenda of things to do. Not that I have anything agains your goal.

[09:18] <moritz> grondilu: !!

[09:19] <jnthn> rakudo++ gets that one right

[09:19] <moritz> giving a hackathon a goal or topic is always a good idea

[09:19] <moritz> but you shouldn't be too disappointed if people get distracted by other stuff

[09:21] <eiro> cognominal, there would be 0 preparation for the hackathlon: it can be done as background job of the classroom ?

[09:21] <cognominal> yes.

[09:26] <tadzik> grondilu: public accessors are ro by default

[09:26] *** lestrrat left
[09:28] *** lestrrat joined
[09:31] <grondilu> tadzik: ok.  But then why do rakudo behaves diff than pugs and niecza?

[09:32] <tadzik> grondilu: because pugs and niecza are wrong

[09:32] <grondilu> Also, to me when a member is public, I should be able to write on it.

[09:32] <moritz> no

[09:32] <tadzik> member is never public. Accessors are

[09:32] <moritz> you should be allowed to see my face, but not change my nose

[09:33] <tadzik> nice one

[09:33] *** emias joined
[09:33] <moritz> you can always stick an 'is rw' on the accessor

[09:33] <moritz> r: class A { has $.x is rw }; given A.new { .x = 3; say .perl }

[09:33] <p6eval> rakudo 024843: OUTPUT«A.new(x => 3)␤»

[09:34] <grondilu> r: class Foo { has $.x; method set($x) { $.x = $x } }; my Foo $f .= new; $f.set: 42;

[09:34] <p6eval> rakudo 024843: OUTPUT«Cannot assign to a readonly variable or a value␤  in method set at /tmp/mnPJLkLzO6:1␤  in block <anon> at /tmp/mnPJLkLzO6:1␤␤»

[09:34] <grondilu> what about this??

[09:34] <moritz> grondilu: $.x is just the accessor, and not writable

[09:34] <moritz> grondilu: if you want to write to the attribute, assign to $!x

[09:35] <grondilu> oh

[09:35] <grondilu> I had no clue.

[09:35] <moritz> now you have :-)

[09:35] <grondilu> So I write to $!x even for $.x .  Ok I'll remember.  Thanks.

[09:37] <moritz> Perl 6 OO tutorials should really start with private attributes

[09:37] <grondilu> Also, if I have a method foo and a member $.foo, how do I call one and not the other?

[09:37] <moritz> and only later add accessors

[09:38] <moritz> grondilu: you don't

[09:38] <moritz> grondilu: the member is called $!foo; you can still access from the inside of your class

[09:38] <moritz> grondilu: but to the outside, only methods are visible

[09:39] <tadzik> if you declare $.foo, you get $!foo and a method foo { $!foo }

[09:40] <moritz> ... unless you already have a method foo

[09:40] <tadzik> right

[09:40] <moritz> in which case you don't get a new accessor

[09:40] <grondilu> r: class Foo { has $.x = "member"; method x { "method" } }; my Foo $x .= new; say $x.x

[09:40] <p6eval> rakudo 024843: OUTPUT«method␤»

[09:41] <grondilu> so in other words a method can hide an accessor.

[09:41] * kresike is watching a very entertaining perl6 OO tutorial

[09:41] <moritz> yes

[09:41] <moritz> kresike: when you're done, please summarize it in a blog post or so :-)

[09:41] <grondilu> well, it happens to suits me anyway :)

[09:41] <moritz> and tell us the URL

[09:42] <moritz> grondilu: though if you don't want the accessor, you can simply write   has $!x;   in the first place

[09:42] <moritz> no accessor, no hiding

[09:42] <kresike> moritz, after the perl5 OO, this thing in perl6 version will need a serious tutorial :)

[09:43] <grondilu> I thought $!var was really only for private members, but that's fine if I can use it for public vars too.

[09:43] <moritz> grondilu: all members are private in Perl 6

[09:43] <moritz> grondilu: if you write 'has $.var', you get the private member, plus the accessor method

[09:44] <grondilu> Ok.

[09:45] <moritz> though there is one more difference

[09:45] <moritz> initialization

[09:45] <moritz> r: class A { has $.foo }; say A.new(foo => 'x').perl

[09:46] <p6eval> rakudo 024843: OUTPUT«A.new(foo => "x")␤»

[09:46] * grondilu needs to read S12 much more.

[09:46] <moritz> r: class A { has $!foo; method foo() { $!foo } }; say A.new(foo => 'x').foo

[09:46] <p6eval> rakudo 024843: OUTPUT«Any()␤»

[09:46] <moritz> this is by design

[09:46] *** wolverian joined
[09:46] *** wolverian left
[09:47] <moritz> if you want to keep your stuff private, you also don't want anybody from the outside to initialize it

[09:47] *** wolverian joined
[09:48] <grondilu> That an other point I wanted to ask.  There is no way to call a constructor with initial value for private members?

[09:48] <grondilu> I mean: unless I write one.

[09:49] <moritz> r: class A { has $!foo; method foo() { $!foo }; submethod BUILD(:$!foo) { } }; say A.new(foo => 'x').foo

[09:49] <p6eval> rakudo 024843: OUTPUT«x␤»

[09:49] <moritz> you can do this submethod BUILD hack to actively enable the initialization again

[09:49] *** [particle]1 left
[09:50] *** b1rkh0ff joined
[09:50] <grondilu> I don't understand your signature:   ':$!foo'

[09:50] * moritz should really write a longer tutorial on that subject

[09:50] <moritz> grondilu: : indidcates a named parameter

[09:51] <moritz> and its name is 'foo'

[09:51] <moritz> but instead of using a separate variable slot, the attribute/memeber $!foo is reused

[09:51] <moritz> so, when BUILD is called with named parameter   foo => 'x',  $!foo is filled with 'x'

[09:52] * grondilu gets it

[09:52] <moritz> \o/

[09:52] <grondilu> Ok, makes sense.

[09:52] <grondilu> pretty neat

[09:52] <moritz> aye, but it does need a thorough explanation

[10:00] *** tyatpi left
[10:11] <grondilu> damn it I don't understand git.  I have a local modif on Buf.pm and git tells me it prevents me from updating rakudo.  It says I should stash them but I don't understand the git-stash manual page at all.  Anyone can give me a quick help?

[10:13] <jnthn> git stash

[10:13] <jnthn> git pull

[10:13] <jnthn> git stasy apply

[10:13] <jnthn> It's like a stack of stuff.

[10:13] *** skids left
[10:13] <jnthn> stash pushes your current changes onto it

[10:14] <jnthn> "git stash apply" later applies whatever is on the current stack top

[10:15] <grondilu> ok.  Thanks

[10:18] *** tyatpi joined
[10:23] *** Guest5520 left
[10:23] <apejens> note that apply doesn't remove the stash from your stash list

[10:23] <apejens> git stash pop applies, then removes

[10:27] <jnthn> Aye

[10:27] <jnthn> I guess I tend to apply out of not wanting to lose stuff.

[10:27] <jnthn> OTOH, there'd still be the reflog...

[10:28] * moritz often just commits before doing a 'git pull --rebase'

[10:29] *** fgomez joined
[10:34] *** fgomez left
[10:34] *** fgomez joined
[10:55] *** JimmyZ joined
[11:04] *** JimmyZ left
[11:05] *** JimmyZ joined
[11:05] *** sftp left
[11:20] *** grondilu left
[11:27] *** preflex left
[11:27] *** PacoAir joined
[11:28] *** preflex_ joined
[11:28] *** sftp joined
[11:29] *** preflex_ is now known as preflex

[11:41] *** skids joined
[11:59] *** replore_ joined
[12:08] <gfldex> for the records: if perl6 is persisent about a missing ICU on cygwin while it's not, rm -r rakudo helps

[12:09] <gfldex> how do i quote # in a grammar?

[12:12] <jnthn> Backslash it, or put it in single quotes

[12:12] <jnthn> r: say '#' ~~ /\#/

[12:12] <p6eval> rakudo 024843: OUTPUT«q[#]␤␤»

[12:12] <jnthn> r: say '#' ~~ /'#'/

[12:12] <p6eval> rakudo 024843: OUTPUT«q[#]␤␤»

[12:13] <gfldex> r: https://gist.github.com/2835895

[12:13] <p6eval> rakudo 024843: OUTPUT«Constraint type check failed for parameter '$a'␤  in sub alternator at /tmp/qM7j02hKzH:5␤  in block <anon> at /tmp/qM7j02hKzH:11␤␤»

[12:16] <gfldex> r: say '#00aa00' ~~ / '#' <:hexdigit> ** 6 /;

[12:16] <p6eval> rakudo 024843: OUTPUT«q[#00aa00]␤␤»

[12:17] <gfldex> r: say ('#00aa00' ~~ / '#' <:hexdigit> ** 6 /).Bool;

[12:17] <p6eval> rakudo 024843: OUTPUT«True␤»

[12:23] *** rsimoes left
[12:25] *** _jaldhar left
[12:28] <moritz> r: subset HTMLColor of Str where /  '#' <:hexdigit> ** 6 /; say '#00aa00' ~~ HTMLColor

[12:28] <p6eval> rakudo 024843: OUTPUT«True␤»

[12:28] <moritz> r: subset HTMLColor of Str where /  '#' <:hexdigit> ** 6 /; say '#00XX00' ~~ HTMLColor

[12:28] <p6eval> rakudo 024843: OUTPUT«False␤»

[12:28] <gfldex> r: say ('#00AA00' ~~ / '#' <:hexdigit> ** 6 /).Bool;

[12:28] <p6eval> rakudo 024843: OUTPUT«True␤»

[12:29] <moritz> gfldex: the problem is that * does not always cause currying; some operators treat it differently

[12:29] <moritz> so * ~~ /.../ does not create a closure

[12:29] <gfldex> i noticed :)

[12:29] <moritz> but since the right-hand side of the 'where' clause is used for smart-matching, the regex itself is sufficient

[12:36] *** tyatpi left
[12:36] *** rsimoes joined
[12:37] <gfldex> r: subset HTMLColor of Str where / '#' <:hexdigit> ** 6 /; sub alternator (HTMLColor *@l) { say 'triple' }; alternator('#00aa00', '#00bb00', '#00cc00');

[12:37] <p6eval> rakudo 024843: OUTPUT«Nominal type check failed for parameter '@l'; expected Positional but got Array instead␤  in sub alternator at /tmp/Y1FcoW07vr:1␤  in block <anon> at /tmp/Y1FcoW07vr:1␤␤»

[12:38] <daxim> -Ofun: http://stackoverflow.com/questions/10815907/parserecdescent-performance-issue shows a real-world grammar, I think it would be interesting to see how a perl6 grammar would fare, any takers?

[12:38] <gfldex> is there a way to have typed slurpy arrays in signatures?

[12:39] <moritz> gfldex: no

[12:44] *** am0c joined
[12:49] *** tyatpi joined
[12:55] *** mucker joined
[12:55] <gfldex> r: subset Foo of Str where /a|b|c/; sub bar(*@a){ @a >>~~>> Foo }; say bar(<a b c>).Bool;

[12:55] <p6eval> rakudo 024843: OUTPUT«Cannot call 'hyper'; none of these signatures match:␤:(\$op, Associative \$h)␤:(\$op, Associative \$a, Associative \$b, :dwim-left(:$dwim-left), :dwim-right(:$dwim-right))␤:(\$op, \$obj)␤:(\$op, Associative \$a, \$b, :dwim-left(:$dwim-left), :dwim-right(:$dwim-righ…

[12:56] <gfldex> is that because ~~ isn't really an operator?

[12:56] <moritz> probably

[12:56] *** bluescreen10 joined
[12:57] <moritz> r: subset Foo of Str where /a|b|c/; sub bar(*@a){ [&&] @a X~~ Foo }; say bar(<a b c>)

[12:57] <p6eval> rakudo 024843: OUTPUT«Type check failed in assignment to '$v'; expected 'Mu' but got 'Foo'␤  in method REIFY at src/gen/CORE.setting:5655␤  in method reify at src/gen/CORE.setting:4949␤  in method gimme at src/gen/CORE.setting:5323␤  in method elems at src/gen/CORE.setting:5303␤  in blo…

[12:57] <moritz> that does look like a bug

[12:58] <moritz> subset Foo of Str where /a|b|c/; [&&] <a b c> X~~ Foo

[12:58] <moritz> r: subset Foo of Str where /a|b|c/; [&&] <a b c> X~~ Foo

[12:58] <p6eval> rakudo 024843: OUTPUT«Type check failed in assignment to '$v'; expected 'Mu' but got 'Foo'␤  in method REIFY at src/gen/CORE.setting:5655␤  in method reify at src/gen/CORE.setting:4949␤  in method gimme at src/gen/CORE.setting:5323␤  in method elems at src/gen/CORE.setting:5303␤  in blo…

[12:58] *** sisar left
[12:58] <moritz> r: subset Foo of Str where /a|b|c/; ~( <a b c> X~~ Foo )

[12:58] <p6eval> rakudo 024843: OUTPUT«Type check failed in assignment to '$v'; expected 'Mu' but got 'Foo'␤  in method REIFY at src/gen/CORE.setting:5655␤  in method reify at src/gen/CORE.setting:4949␤  in method gimme at src/gen/CORE.setting:5323␤  in method elems at src/gen/CORE.setting:5303␤  in blo…

[12:58] <moritz> r: subset Foo of Str where 1; ~( <a b c> X~~ Foo )

[12:58] <p6eval> rakudo 024843: OUTPUT«Type check failed in assignment to '$v'; expected 'Mu' but got 'Foo'␤  in method REIFY at src/gen/CORE.setting:5655␤  in method reify at src/gen/CORE.setting:4949␤  in method gimme at src/gen/CORE.setting:5323␤  in method elems at src/gen/CORE.setting:5303␤  in blo…

[12:59] <moritz> r:  ~( <a b c> X~~ Str )

[12:59] <p6eval> rakudo 024843:  ( no output )

[13:01] <gfldex> it's not overly consistent to have X~~ but not >>~~>>

[13:01] <gfldex> and it's means not autothreading for ~~

[13:01] <gfldex> what makes me a little sad

[13:02] <moritz> well, X~~ also doesn't work

[13:02] <gfldex> shout it?

[13:02] <gfldex> *should

[13:02] <moritz> good question

[13:03] <moritz> it probably could, but without the automagic topicalization

[13:03] <gfldex> TimToady: should X~~ and >>~~>> be and dwim?

[13:03] <moritz> std: 1 X~~ 2

[13:04] <p6eval> std f179a1b: OUTPUT«ok 00:00 41m␤»

[13:04] <moritz> std: 1 >>~~>> 1

[13:04] <p6eval> std f179a1b: OUTPUT«ok 00:00 41m␤»

[13:04] <moritz> std parses them :-)

[13:04] *** [particle] joined
[13:04] <gfldex> does that mean they have to be or does it mean they can be?

[13:05] <jnthn> r: subset Foo of Str where /a|b|c/; say Foo ~~ Mu

[13:05] <p6eval> rakudo 024843: OUTPUT«False␤»

[13:05] *** bacek joined
[13:05] <jnthn> r: subset Foo of Str where /a|b|c/; say Foo ~~ Str

[13:05] <p6eval> rakudo 024843: OUTPUT«True␤»

[13:05] <jnthn> wtf...

[13:06] <tadzik> r: subset Foo of Str where /a|b|c/; say Foo.^mro

[13:06] <p6eval> rakudo 024843: OUTPUT«No such method 'mro' for invocant of type 'Perl6::Metamodel::SubsetHOW'␤  in block <anon> at /tmp/Q9t8t1Asel:1␤␤»

[13:06] <moritz> gfldex: I don't know

[13:06] <tadzik> hy

[13:06] <moritz> tadzik: mro is only for stuff we call methods on, no?

[13:07] <moritz> r: subset Foo of Str where /a/; say Foo.uc

[13:07] <p6eval> rakudo 024843: OUTPUT«Nominal type check failed for parameter ''; expected Cool but got Foo instead␤  in method uc at src/gen/CORE.setting:1876␤  in block <anon> at /tmp/6yKOSAo7iD:1␤␤»

[13:07] <moritz> r: subset Foo of Str where /a/; say Foo ~~ Cool

[13:07] <p6eval> rakudo 024843: OUTPUT«False␤»

[13:07] <gfldex> the spec seams not to say anything about X~~ but got something about [~~]

[13:08] *** Psyche^ joined
[13:08] <moritz> std: [~~] 1, 2, 3

[13:08] <p6eval> std f179a1b: OUTPUT«ok 00:00 42m␤»

[13:09] <gfldex> it feels like there would be something amiss without X~~ but i felt wrong about perl6 before :)

[13:09] <moritz> r: subset Foo of Str where /a/; augment class Foo { method foo() { say 'lol' } }; Foo.foo

[13:09] <p6eval> rakudo 024843: OUTPUT«===SORRY!===␤augment not allowed without 'use MONKEY_TYPING'␤at /tmp/EE3wFUBGWn:1␤»

[13:10] <moritz> r: use MONKEY_TYPING; subset Foo of Str where /a/; augment class Foo { method foo() { say 'lol' } }; Foo.foo

[13:10] <p6eval> rakudo 024843: OUTPUT«Useless declaration of a has-scoped method in class␤===SORRY!===␤Method 'compose' not found for invocant of class 'Perl6::Metamodel::SubsetHOW'␤»

[13:10] <moritz> that's quite a funny error :-)

[13:10] <tadzik> moritz: oh, right

[13:10] <tadzik> r: subset Foo of Str where /a|b|c/; say Foo.^parents

[13:10] <p6eval> rakudo 024843: OUTPUT«No such method 'parents' for invocant of type 'Perl6::Metamodel::SubsetHOW'␤  in block <anon> at /tmp/P6iLqu8BH0:1␤␤»

[13:10] <tadzik> okay

[13:11] <moritz> where would a has-scaoped method make sense, if not in a class? (ok, a role...)

[13:11] *** Patterner left
[13:11] *** Psyche^ is now known as Patterner

[13:13] * moritz submits rakudobug (subset !~~ Mu)

[13:14] <gfldex> std: subset Foo of Str; sub (*@l where { $^a X~~ Foo } ) { }

[13:14] <p6eval> std f179a1b: OUTPUT«Potential difficulties:␤  @l is declared but not used at /tmp/OIjzCiWA9d line 1:␤------> subset Foo of Str; sub (*⏏@l where { $^a X~~ Foo } ) { }␤ok 00:00 43m␤»

[13:15] *** benabik left
[13:15] <gfldex> looks like i can have typed slurpy arrays in signatures for the price of sloooowness

[13:16] <moritz> the reason we don't allow typed slurpies is that they are lazy

[13:17] <moritz> but type checks require evaluating all elements

[13:17] <gfldex> that could take some time :)

[13:17] <moritz> aye

[13:23] <mucker> hi guys .. i'm thinking of writing a forthish compiler. should i use nqp or pir ???

[13:23] <tadzik> nqp

[13:24] <jnthn> Maintaining a compiler in an assembly language considered unfun.

[13:24] <jnthn> Rakudo is almost rid of things that are written in PIR. Every time we re-do something in Perl 6 or NQP it gets easier to maintain :)

[13:24] <jnthn> And more accessible for people to hack on.

[13:24] <mucker> okie dokie :)

[13:24] <moritz> QAST! QAST! QAST!

[13:24] <jnthn> Yeah.

[13:25] <mucker> in the end nqp translates to pir, right ??

[13:25] <jnthn> I should deal with a few things before really digging into that though :)

[13:26] <dalek> rakudo: d7f45ff | moritz++ | src/core/Cool.pm:

[13:26] <dalek> rakudo: Cool.eval

[13:26] <dalek> rakudo: review: https://github.com/rakudo/rakudo/commit/d7f45ff8cf

[13:27] <moritz> meh

[13:27] <jnthn> grr

[13:27] <moritz> somebody pushed to mater

[13:27] * jnthn already :'d it away

[13:27] <moritz> *mster

[13:27] <moritz> grrr

[13:27] <jnthn> Then I typo'd nom.

[13:27] <jnthn> :/

[13:27] <dalek> rakudo/nom: 12983a9 | jnthn++ | src/Perl6/Metamodel/SubsetHOW.pm:

[13:27] <dalek> rakudo/nom: Fix silly thinko in subset type checking.

[13:27] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/12983a9c66

[13:27] * jnthn deletes his local master

[13:27] <jnthn> I thought I'd done that before. Guess it was on $other-machine.

[13:28] * moritz now +2 on renaming nom to master

[13:29] <jnthn> By now is it only a problem for people who cloned long enough ago to already have a master branch?

[13:29] <moritz> plus those that wonder where master is

[13:30] <jnthn> No, I mean, if we push what is currently nom to master...

[13:31] <moritz> hm, yes

[13:31] <jnthn> We did it to avoid poeple having to re-clone. But now, only people who grabbed a clone quite a long time ago will have a local master branch.

[13:32] <moritz> right

[13:32] <flussence> running `git remote prune origin` every few months is a good idea :)

[13:33] *** isBEKaml joined
[13:34] *** am0c left
[13:35] * jnthn deletes a few branches of his from GitHub too

[13:37] *** thou joined
[13:40] <PerlJam> re nom->master +! from me too.   (The only time I ever notice it though is when attempting to switch from another branch *back* to nom as my fingers tend to reflexively type "git co master")

[13:40] <PerlJam> er, +1 even

[13:40] <jnthn> Mine are gonna type nom for ages though... :)

[13:40] <moritz> well, I've had both problems

[13:41] <moritz> trying 'git checkout master' in rakudo, and later 'git checkout nom' in nqp :-)

[13:41] <PerlJam> heh

[13:43] *** fgomez left
[13:47] <moritz> I have deleted several more branches on github

[13:48] <moritz> so now pruning branches in your local repos is a good idea :-)

[13:54] *** fgomez joined
[14:04] *** mucker left
[14:06] *** benabik joined
[14:06] <pmichaud> ... ".threw" ?

[14:06] <pmichaud> https://github.com/rakudo/rakudo/commit/0248432017c0d2a85a89f4f9c7669fd3ace680e3

[14:07] <moritz> oops, should be .throw

[14:08] <moritz> I wonder why we're passing a test for it though :-)

[14:08] <pmichaud> it still dies, I guess.  :-)

[14:08] <pmichaud> good morning, #perl6

[14:08] <jnthn> o/ pmichaud  :)

[14:09] <moritz> oh, it seems I was imagining things. We don't pass a test for it

[14:09] <moritz> that makes me feel slightly less nervous

[14:09] *** icwiener joined
[14:10] <moritz> r: sub f() { gather { return } }; f()

[14:10] <p6eval> rakudo 024843:  ( no output )

[14:10] *** tokuhiro_ joined
[14:10] <moritz> r: sub f() { gather { return } }; ~f()

[14:10] <p6eval> rakudo 024843: OUTPUT«Attempt to return outside of any Routine␤  in block <anon> at src/gen/CORE.setting:363␤  in block <anon> at /tmp/3IDQ3DXSUd:1␤␤»

[14:10] <moritz> r: sub f() { gather { return } }; try ~f(); say $!.WHAT

[14:10] <p6eval> rakudo 024843: OUTPUT«X::ControlFlow::Return()␤»

[14:10] <moritz> well, that's not the same exception type :/

[14:12] <moritz> turns out I don't know to trigger the line in that patch :/

[14:12] <pmichaud> r: sub f() { gather { take 1; return; } };   try ~f();  say $!.WHAT;

[14:12] <p6eval> rakudo 024843: OUTPUT«X::ControlFlow::Return()␤»

[14:12] <jnthn> pmichaud: I'm been pondering NFAs for alternations a bit. It's not so hard to see that we could store/build the NFA for an alternation. But I'm not sure where we'd store the fate list (the order to try the branches). If we were to backtrack into a rule, it'd seem that it needs to stay around longer than a single invocation...

[14:13] <moritz> r: sub f() { return -> { return } }; f()()

[14:13] <p6eval> rakudo 024843: OUTPUT«Attempt to return outside of any Routine␤  in block <anon> at src/gen/CORE.setting:363␤  in block <anon> at /tmp/03tFLvGRCS:1␤␤»

[14:13] *** bluescreen10 left
[14:14] <pmichaud> jnthn: ummmmm, I had this figured out at one point... thinking

[14:14] <pmichaud> oh, yes

[14:14] <pmichaud> you can store it on the backtracking stack

[14:14] <colomon> n: say 1..6 ~~ 3

[14:14] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«False␤»

[14:15] <jnthn> pmichaud: Ain't the bs an integer array?

[14:15] <colomon> n: say 1..6 R~~ 3

[14:15] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«True␤»

[14:15] <sorear> good * #perl6

[14:15] <jnthn> pmichaud: Or is your point, "so are the fate"? :)

[14:15] <pmichaud> jnthn: sure.... but the alternations are just jump targets

[14:15] <colomon> r: say 1..6 R~~ 3

[14:15] <p6eval> rakudo 12983a: OUTPUT«True␤»

[14:15] <colomon> r: say 1..6 ~~ 3

[14:15] <p6eval> rakudo 12983a: OUTPUT«False␤»

[14:15] <jnthn> pmichaud: Oh...so you could just queue them all up on the bstack?

[14:15] <pmichaud> yes, longest alternation is queued last

[14:15] <pmichaud> then fail

[14:15] <jnthn> hah!

[14:16] <jnthn> pmichaud++

[14:16] <pmichaud> so, just a bunch of mark_push calls for the alternations that match

[14:16] <jnthn> Dang, that's really obvious in hindsight...

[14:16] <jnthn> :)

[14:16] <sorear> rakduo is going to use fates?

[14:17] <jnthn> sorear: If you're thinking what I think you're thinking - that's not quite what I mean here; I'm just talking about the point we cross fate edges as in, "we consider this branch matched"

[14:18] <jnthn> sorear: Not doing the "pass the matches down the tree" thing just yet.

[14:19] *** fglock joined
[14:19] <jnthn> pmichaud: I guess you saw the commit, but I tossed all of that weird sorting stuff in !protoregex too and twiddled the NFA runner to just spit out useful output.

[14:19] <sorear> jnthn: What does fate mean in a rakudo context?

[14:19] <fglock> o/

[14:19] <jnthn> sorear: I mean $EDGE_FATE

[14:19] <pmichaud> I didn't see the commit, no.  For some reason I'm not getting notifications of nqp commits.

[14:19] <jnthn> Oh

[14:19] <pmichaud> I know that I was at one time, but they seem to have stopped.

[14:19] <pmichaud> anyway, "toss weird sorting stuff"++

[14:19] <sorear> jnthn: I haven't read any of the new rakudo LTM code

[14:19] <jnthn> sorear: The edge type in the NFA you cross when you hit the end of the declarative prefix.

[14:20] <sorear> ah

[14:20] <jnthn> We could potentially change things so we retain all of the crossing points from the NFAs of merged subrules etc.

[14:20] <jnthn> And then we'd be able to do the fates a la STD.

[14:20] <jnthn> Or what I understand STD does.

[14:20] <pmichaud> right, I had planned that to be a "future optimization"  :)

[14:21] <sorear> the problem with *that* idea is that it leads to exponential blowup

[14:21] <sorear> which is why I dropped it from niecza

[14:21] <jnthn> sorear: It's not immediately clear to me why. What am I (likely) missing?

[14:21] <sorear> regex a { x | y }; regex b { <a>* }

[14:22] <pmichaud> jnthn: anyway; yes, using the bstack for alternations also means that ratcheting/commits work properly

[14:22] <sorear> currently that generates a rather small NFA

[14:22] <sorear> if the b NFA had to generate branch information for <a> as well, it would be much larger

[14:23] <sorear> perhaps a better example would be regex b { <a> <a> <a> <a> <a> }

[14:23] <dalek> rakudo/nom: 69240df | moritz++ | src/core/ (2 files):

[14:23] <dalek> rakudo/nom: cut an exception type that I do not know how to trigger

[14:23] <dalek> rakudo/nom: 

[14:23] <dalek> rakudo/nom: it is already well-covered by a similar type. pmichaud++ noted a typo in the

[14:23] <dalek> rakudo/nom: original code, so I guess it was never called.

[14:23] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/69240df8f9

[14:24] <sorear> STD expands out that NFA as xxxxx | xxxxy | ... yyyyx | yyyyy, each with a *different* fate set, because different fates need to go to a

[14:24] *** masonkramer joined
[14:24] <jnthn> Ouch.

[14:24] <jnthn> Oh wait, it computes the fate sets AOT, rather than during traversal?

[14:24] *** bluescreen10 joined
[14:25] <jnthn> That...wasn't what I had in mind. :)

[14:26] *** replore_ left
[14:26] * jnthn had figured you could cross multiple "sub-fate" edges, each of which fills in an entry in the fate set.

[14:26] <pmichaud> Me neither, although I hadn't explored it very far ("future optimization")

[14:26] <jnthn> Aye.

[14:26] <jnthn> I'm not planning to work on it...it's the alternations I'm interested in.

[14:26] <moritz> now the future is here :-). At least partially :-)

[14:26] <jnthn> Feel free to beat me to it, but I may give it a go at the weekend.

[14:26] <pmichaud> future is here suboptimally, I guess.

[14:26] <jnthn> s/it/them/

[14:27] <jnthn> (give the alternations a go, just to be clear :))

[14:27] <pmichaud> I think I'd rather spend my tuits on the .munch issue

[14:27] <sorear> jnthn: doing it during traversal leads to an exponential blowup of a different sort

[14:27] <pmichaud> since you're already spun up on the alternations one

[14:27] <jnthn> pmichaud: OK, that's fine.

[14:27] <pmichaud> also I need to catch up with nqp latest stuff

[14:27] <pmichaud> and I want to work on my synopsis-excerpting tool a bit

[14:28] <sorear> jnthn: contrived example: regex a { x | x }; regex b { <a>* }

[14:28] <jnthn> pmichaud: By now I can read NFAs by reading the list of integers. :)

[14:28] <pmichaud> jnthn: yes, it's not really that hard once you're into it

[14:28] <jnthn> pmichaud: Yeah, it ain't so bad :)

[14:28] <pmichaud> I like that particular encoding for a variety of reasons

[14:28] <sorear> jnthn: after reading xxx, the current set of active states is { K(fate = 000), K(fate = 001), ... K(fate = 111) }

[14:29] <sorear> jnthn: whereas without fate recording you only need to keep one copy of K in the active node set

[14:29] <jnthn> sorear: Contrived example is contrived, but yes, I think I see where you're going.

[14:30] <pmichaud> I suspect fate recording could be size limited somehow, though -- use the fate information if we have it, do it the long way if we don't

[14:30] <jnthn> *nod*

[14:30] <jnthn> So long as it's an optimization and not required for correctness, that works out fine.

[14:31] <jnthn> pmichaud: I'd rather you spend your tuits on munch too, fwiw :)

[14:31] <jnthn> I understand that area less well :)

[14:31] <pmichaud> good for me

[14:31] <pmichaud> s/good/works/

[14:32] <jnthn> \o/

[14:32] <pmichaud> I also may wrangle a few tickets, and work on regex performance a bit

[14:32] <jnthn> Yeah.

[14:32] <sorear> it seems that fates *are* required for correctness in the presence of backtracking though.

[14:33] <PerlJam> Have You guys read http://swtch.com/~rsc/regexp/regexp1.html  ?

[14:33] <jnthn> pmichaud: On regex performance: our "startup" time has sufferred because of building a bunch of quite complex NFAs as we start parsing. I already know what to do with this issue.

[14:33] <pmichaud> jnthn: what to do?

[14:33] <sorear> PerlJam: that page talks about regular expressions, not p6regex

[14:34] <sorear> PerlJam: I have had that link forwarded to me so many times I am starting to take it badly

[14:34] <pmichaud> PerlJam: yes, I read that page -- it was one of my sources for developing qregex

[14:34] <PerlJam> okay, just checking

[14:34] <jnthn> pmichaud: We can build them at compile time and they'll get serialized. (more)

[14:35] <PerlJam> sorear: aye, I just wanted to make sure you guys were aware of it  :)

[14:35] <jnthn> pmichaud: Since they're held by a caching mechanism, invalidation that later happens at runtime will not cause us issues.

[14:35] <sorear> p6: grammar F { regex a { a | aaaaa } ; regex TOP { ^ ( <a> | aaa ) <?{ $0.chars < 5 }> {} .* } }; say F.parse("aaaaa")

[14:35] <p6eval> pugs: OUTPUT«*** No such method in class F: "&parse"␤    at /tmp/1aI5mChYN2 line 1, column 100 - line 2, column 1␤»

[14:35] <p6eval> ..rakudo 12983a: OUTPUT«q[aaaaa]␤ 0 => q[a]␤  a => q[a]␤␤»

[14:35] <p6eval> ..niecza v18-1-gc86e3f0: OUTPUT«#<match from(0) to(5) text(aaaaa) pos([#<match from(0) to(1) text(a) pos([].list) named({"a" => #<match from(0) to(1) text(a) pos([].list) named({}.hash)>}.hash)>].list) named({}.hash)>␤»

[14:35] <pmichaud> jnthn: yes, I was hoping/thinking there would be a compile-time serialization possibility :)

[14:36] <sorear> p6: grammar F { regex a { a | aaaaa } ; regex TOP { ^ ( <a> | aaa ) <?{ $0.chars < 5 }> {} .* } }; say ~F.parse("aaaaa").[0]

[14:36] <p6eval> pugs: OUTPUT«*** No such method in class F: "&parse"␤    at /tmp/xKevWph4RE line 1, column 100 - line 2, column 1␤»

[14:36] <p6eval> ..rakudo 12983a, niecza v18-1-gc86e3f0: OUTPUT«a␤»

[14:36] <pmichaud> jnthn: at the time qregex was first being built, a lot of serialization was nyi :)

[14:36] <jnthn> pmichaud: Right. :)

[14:36] <pmichaud> but I was comfortable it could be made to work

[14:36] <sorear> I have been told that this should return q[aaa]

[14:36] <sorear> but making this work requires fatefulness

[14:40] <pmichaud> or some mechanism to control backing into subrules in the declarative prefix

[14:42] <pmichaud> maybe some variation of :exhaustive where the subrule knows to cache and order its matches based on ltm

[14:44] <pmichaud> or some way for a subrule to return a state that says "I have more matches, but none longer than the minimum you sent me"

[14:50] *** wtw left
[14:51] <pmichaud> afk for a bit

[14:51] *** kaare_ joined
[14:53] *** lestrrat left
[14:54] *** lestrrat joined
[15:01] *** fgomez left
[15:02] *** aesundstrom joined
[15:06] *** lestrrat left
[15:07] *** lestrrat joined
[15:18] *** plobsing_ left
[15:20] *** japhb left
[15:20] *** plobsing joined
[15:24] <kresike> bye all

[15:24] *** kresike left
[15:29] *** mucker joined
[15:29] *** tokuhiro_ left
[15:30] *** fhelmberger left
[15:32] *** fglock left
[15:32] *** bluescreen10 left
[15:33] *** fhelmberger joined
[15:35] *** fhelmberger left
[15:44] *** bluescreen10 joined
[15:52] *** bluescreen10 left
[15:53] *** bluescreen10 joined
[15:55] *** crab2313 joined
[15:56] *** fgomez joined
[16:02] *** JimmyZ left
[16:04] *** masonkramer left
[16:05] *** brrt left
[16:07] *** simcop2387 left
[16:07] *** simcop2387 joined
[16:16] *** japhb joined
[16:19] *** Kresike joined
[16:20] <Kresike> hi all

[16:20] <tadzik> hello again Kresike 

[16:20] <Kresike> hello again tadzik 

[16:42] *** not_gerd joined
[16:42] <not_gerd> n: say "foo".subst(/(foo)/, { say $0.WHAT; "bar" })

[16:42] <phenny> not_gerd: 18 May 00:09Z <flussence> tell not_gerd I don't even remember what that error was from... but I've built rakudo on my desktop and netbook recently without problems so I'll assume it's fixed.

[16:42] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Match()␤bar␤»

[16:42] <not_gerd> r: say "foo".subst(/(foo)/, { say $0.WHAT; "bar" })

[16:42] <p6eval> rakudo 69240d: OUTPUT«Any()␤bar␤»

[16:42] <not_gerd> ^ known?

[16:42] *** daxim left
[16:44] <jnthn> p6: say "foo".subst(/(foo)/, -> $/ { say $0.WHAT; "bar" })

[16:44] <p6eval> rakudo 69240d, niecza v18-1-gc86e3f0: OUTPUT«Match()␤bar␤»

[16:44] <p6eval> ..pugs: OUTPUT«Error eval perl5: "if (!$INC{'Pugs/Runtime/Match/HsBridge.pm'}) {␤    unshift @INC, '/home/p6eval/.cabal/share/Pugs-6.2.13.20120203/blib6/pugs/perl5/lib';␤    eval q[require 'Pugs/Runtime/Match/HsBridge.pm'] or die $@;␤}␤'Pugs::Runtime::Match::HsBridge'␤"␤*** Can't locate P…

[16:44] <jnthn> That's the way to do it.

[16:45] <not_gerd> jnthn: thanks

[16:45] <not_gerd> is it a niecza-bug then?

[16:45] <jnthn> I think there's an underlying unresolved spec question there, iirc.

[16:46] <jnthn> We'd like it to work with what you wrote, but making it do so is problematic, because how does match .subst now what $/ to set in order to have the closure see the right thing?

[16:46] <jnthn> s/now/known/

[16:47] <jnthn> Unless this all got resolved/decided somewhere and I forgot, of course.

[16:47] <diakopter> moritz: do we have an html version of Using Perl 6

[16:47] <moritz> diakopter: 'make html' should produce one

[16:48] <diakopter> oh! do we have the result linked from perl6.org?

[16:48] <diakopter> and are the chapters separated to different pages

[16:50] *** mikemol joined
[16:50] <diakopter> I have the itch to write reams of documentation, and I think Using Perl 6 might be the place for it, as long as it was automatically rendered/published to perl6.org

[16:51] <diakopter> "write reams.." also for my own learning.

[16:52] <dalek> perl6-examples: d792bfe | (Gerhard R)++ | shootout/regex-dna.p6.pl:

[16:52] <dalek> perl6-examples: [shootout/regex-dna] workaround for unresolved spec issue, jnthn++

[16:52] <dalek> perl6-examples: review: https://github.com/perl6/perl6-examples/commit/d792bfee10

[16:52] *** birdwind1pbird left
[16:53] *** dakkar left
[16:54] *** japhb left
[16:55] *** birdwind1pbird joined
[16:55] *** cognominal left
[16:55] *** cognominal joined
[16:56] *** estrabd joined
[17:08] *** sjohnson left
[17:08] *** am0c joined
[17:10] *** PacoAir left
[17:12] <not_gerd> https://gist.github.com/2837706

[17:12] <not_gerd> ^ golfed version of the regex-dna issue

[17:12] <not_gerd> eats all your memory on 32-bit systems

[17:12] <sorear> jnthn: What I (or was it colomon?) did some time last year was to set CALLER::<$/>, but save the old value to restore before .susbt returns

[17:12] <sorear> I'm happy with this, so is colomon, and no-one else has complained

[17:15] *** brrt joined
[17:17] *** bbkr_ left
[17:17] *** birdwind1pbird left
[17:18] *** birdwindupbird left
[17:20] *** _ilbot left
[17:21] *** _ilbot joined
[17:27] *** sjohnson joined
[17:31] *** benabik left
[17:36] *** wolfman2000 joined
[17:38] <TimToady> n: https://gist.github.com/2837838

[17:38] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765␤1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 5768 10609 19513 35890 66012␤1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 10671 20569 39648 76424 147312␤1 1 2 4 8 16 31 61 120 236 464 9…

[17:38] <TimToady> r: https://gist.github.com/2837838

[17:38] <p6eval> rakudo 69240d: OUTPUT«1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765␤1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 5768 10609 19513 35890 66012␤Not enough positional parameters passed; got 3 but expected 4␤  in whatevercode <anon> at eval_2:1␤  in block <anon> at s…

[17:38] <TimToady> rakudobug

[17:48] *** birdwindupbird joined
[17:49] * diakopter ponders how to golf it

[17:51] *** kaleem left
[17:52] <TimToady> my guess is that something's not flattening in list context that should

[17:52] <TimToady> s/list/slurpy/ to be a bit more precise

[17:53] <sorear> rakudobug?  usually it is niecza that has the horrible flattening problems

[17:54] <TimToady> but installing calls to flat doesn't seem to help

[17:55] <TimToady> well, it's always possible that TimToady is relying on niecza's buggy behavior somehow...

[17:56] * TimToady notes the odd semantics of "always" in that sentence

[18:01] * geekosaur will just point to James Nicoll re English

[18:02] *** not_gerd left
[18:03] *** raiph joined
[18:04] <TimToady> A linguist has a problem and says "I know, I'll use a level of indirection."  Now he has 7±2 problems...

[18:05] <diakopter> n: https://gist.github.com/2837921

[18:05] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Cannot unbox a Variable[] from an object of repr P6box[Int32]␤  at <unknown> line 0 (iter_flatten @ 0) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2391 (GatherIterator.reify @ 6) ␤  at <unknown> line 0 (ExitRunloop @ 0) ␤  at /tmp/w…

[18:05] <diakopter> internals leaky

[18:07] <diakopter> sorear: fyi this revision was the one that did that ^^ https://gist.github.com/2837921/48f465d8c478683c612a2bcd472751d724869ace

[18:07] <diakopter> so you'll have to paste that into a new gist to run it

[18:09] *** Celelibi left
[18:11] *** raiph left
[18:27] *** ruoso joined
[18:34] *** kboga joined
[18:38] <kboga> hi p6

[18:39] <kboga> t/spec/S02-types/bool.t seems to fail nondeterministically here: http://nopaste.snit.ch/paste

[18:40] <kboga> (was tested on latest nom)

[18:41] <jnthn> kboga: I managed to get something based on it to fail quite reliably...but didn't manage to get to the bottom of what on earth is going on yet.

[18:42] <kboga> ah, good that you guys are aware of it already though :)

[18:42] <diakopter> r: say ((1,1, {[+] @_} ... *)[0...4], *+*+*+*+* ... *)[4]

[18:42] <p6eval> rakudo 69240d: OUTPUT«8␤»

[18:42] <diakopter> r: say ((1,1, {[+] @_} ... *)[0...3], *+*+*+*+* ... *)[4]

[18:42] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 5␤  in block <anon> at /tmp/Rc_Hq3mTwO:1␤␤»

[18:42] <diakopter> jnthn: ^^ note

[18:43] <diakopter> something's off by one ;)

[18:44] *** brrt left
[18:46] <diakopter> n: say ((1,1, {[+] @_} ... *)[0...4], *+*+*+*+* ... *)[4]

[18:46] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«8␤»

[18:46] <diakopter> n: say ((1,1, {[+] @_} ... *)[0...3], *+*+*+*+* ... *)[4]

[18:46] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«Unhandled exception: Need more items on the LHS␤  at /home/p6eval/niecza/lib/CORE.setting line 1401 (die @ 5) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3128 (get-next-closure @ 11) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3172 (ANON @ 17) ␤  at…

[18:47] <diakopter> n: say ((1,1, {[+] @_} ... *)[0...5], *+*+*+*+* ... *)[4]

[18:47] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«8␤»

[18:47] *** am0c left
[18:49] *** kaleem joined
[18:49] <diakopter> whoa.

[18:49] <diakopter> r: say ((1,1, {[+] @_} ... *)[0...6], *+*+*+*+* ... *)[6]

[18:49] <p6eval> rakudo 69240d: OUTPUT«32␤»

[18:49] <diakopter> r: say ((1,1, {[+] @_} ... *)[0...5], *+*+*+*+* ... *)[6]

[18:49] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 5␤  in block <anon> at /tmp/s7cfYb8Y8c:1␤␤»

[18:49] <diakopter> r: say ((1,1, {[+] @_} ... *)[0...5], *+*+*+*+* ... *)[5]

[18:49] <p6eval> rakudo 69240d: OUTPUT«16␤»

[18:50] *** benabik joined
[18:51] <diakopter> r: say ((1,1, {[+] @_} ... *)[0...6], *+*+*+*+*+* ... *)[7]

[18:51] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 6␤  in block <anon> at /tmp/KHWhlbyY4K:1␤␤»

[18:51] <diakopter> TimToady: it's always getting only 3 positional parameters

[18:52] <PerlJam> r: say ((1,1, {[+] @_} ... *)[0...5], *+*+*+*+* ... *)[10]

[18:52] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 5␤  in block <anon> at /tmp/m7rWnL_oHI:1␤␤»

[18:52] <PerlJam> r: say ((1,1, {[+] @_} ... *)[0...5], *+*+*+*+* ... *)[9]

[18:52] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 5␤  in block <anon> at /tmp/QgSok6vtpP:1␤␤»

[18:53] *** replore_ joined
[18:58] <jnthn> kboga++ # pull requests

[19:00] *** brrt joined
[19:05] <kboga> np

[19:06] <kboga> gtg bye p6

[19:06] *** skids left
[19:06] *** kboga left
[19:09] <PerlJam> oh, SEQUENCE has 3 as a magic number.  I was thinking something completely different.

[19:11] *** kaleem left
[19:16] <diakopter> r: say ((1,1,2,4,8)[^4], *+*+*+* ... *)[4]

[19:16] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/WkDpAcE1QC:1␤␤»

[19:16] <jnthn> r: say (*+*+*+*).signature

[19:16] <p6eval> rakudo 69240d: OUTPUT«WhateverCode.new()␤»

[19:17] <jnthn> r: say (*+*+*+*).WHAT

[19:17] <p6eval> rakudo 69240d: OUTPUT«WhateverCode()␤»

[19:17] <benabik> WhateverCode as a signature?

[19:17] <jnthn> Hm.

[19:17] <diakopter> r: say ((1,1,2,4,8), *+*+*+* ... *)[4]

[19:17] <p6eval> rakudo 69240d: OUTPUT«8␤»

[19:17] <PerlJam> I bet the sequence op will always only pass 3 parameters to the code

[19:17] <jnthn> I doubt it.

[19:17] <diakopter> n: say ((1,1,2,4,8)[^4], *+*+*+* ... *)[4]

[19:17] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«8␤»

[19:17] <jnthn> PerlJam: Oh, it's in sequence?

[19:17] <PerlJam> oh.

[19:17] <PerlJam> well, that's my current guess.

[19:18] <jnthn> k

[19:18] <diakopter> r: say ((1,1,2,4,8)[^4], *+*+*+* ... *)[4]

[19:18] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/HgBaJv7BVP:1␤␤»

[19:18] <diakopter> r: say ((1,1,2,4,8), *+*+*+* ... *)[4]

[19:18] <p6eval> rakudo 69240d: OUTPUT«8␤»

[19:18] *** replore_ left
[19:18] <jnthn> say (1,1,2,4,8)[^4]

[19:18] <jnthn> r: ay (1,1,2,4,8)[^4]

[19:18] <p6eval> rakudo 69240d: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&ay' called (line 1)␤»

[19:19] <jnthn> r: say (1,1,2,4,8)[^4]

[19:19] <p6eval> rakudo 69240d: OUTPUT«1 1 2 4␤»

[19:21] <PerlJam> yeah, as soon as it needs to generate an element with the code block, it barfs with "got 3 but expected N"

[19:21] <TimToady> r: say {$^a + $^b + $^c + $^d}.arity

[19:21] <p6eval> rakudo 69240d: OUTPUT«4␤»

[19:22] <TimToady> r: say (*+*+*+*).arity

[19:22] <p6eval> rakudo 69240d: OUTPUT«WhateverCode.new()␤»

[19:22] <jnthn> It's seemingly applying the *.foo logic and deriving a new closure.

[19:23] <jnthn> r: say WhateverCode.^mro

[19:23] <p6eval> rakudo 69240d: OUTPUT«WhateverCode() Code() Any() Mu()␤»

[19:23] <jnthn> r: say Whatever.^mro

[19:23] <p6eval> rakudo 69240d: OUTPUT«Whatever() Any() Mu()␤»

[19:23] <jnthn> Hm, it ain't just inheriting it from Whatever. Guess it must be deliberate then...

[19:23] <jnthn> oh

[19:23] <jnthn> It's compile time I guess

[19:23] <TimToady> nodnod

[19:23] <diakopter> the parcel is flattening differently

[19:24] <jnthn> r: say ((*+*+*+*)).arity

[19:24] <p6eval> rakudo 69240d: OUTPUT«WhateverCode.new()␤»

[19:24] <jnthn> r: say (my $ = (*+*+*+*)).arity

[19:24] <p6eval> rakudo 69240d: OUTPUT«4␤»

[19:24] <TimToady> r: say .arity given *+*+*+*

[19:24] <p6eval> rakudo 69240d: OUTPUT«4␤»

[19:24] <diakopter> r: say ((1,1,2,4,8)[^4]).WHAT; say ((1,1,2,4,8)[^4], *+*+*+* ... *)[4]

[19:24] <p6eval> rakudo 69240d: OUTPUT«Parcel()␤Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/AoA_4u5C4Y:1␤␤»

[19:24] <diakopter> r: say ((1,1,2,4,8)).WHAT; say ((1,1,2,4,8), *+*+*+* ... *)[4]

[19:24] <p6eval> rakudo 69240d: OUTPUT«Parcel()␤8␤»

[19:25] <TimToady> so probably not the problem here

[19:25] *** brrt left
[19:26] <diakopter> r: say ((1,1,2,4,8)[^4]).WHAT; say ((1,1,2,4,8)[^4], {$^a + $^b + $^c + $^d} ... *)[4]

[19:26] <p6eval> rakudo 69240d: OUTPUT«Parcel()␤Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/23SVoLqOd5:1␤␤»

[19:27] <TimToady> r: say (1,1,2,4,8)[^4].perl

[19:27] <p6eval> rakudo 69240d: OUTPUT«(1, 1, 2, 4)␤»

[19:27] <PerlJam> Is munch not specced? 

[19:27] <TimToady> it is not

[19:27] <PerlJam> should it be?

[19:27] <TimToady> (yet-ish)

[19:28] <TimToady> maybe

[19:28] <PerlJam> ok

[19:29] <diakopter> r: say ((1,1,2,4,8,15)[^5], *+*+*+* ... *)[5]

[19:29] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/baTUwurQkA:1␤␤»

[19:30] <TimToady> r: (*+*+*+*).((1,1,2,4,8)[^4]).say

[19:30] <p6eval> rakudo 69240d: OUTPUT«Not enough positional parameters passed; got 1 but expected 4␤  in block <anon> at /tmp/r0rKLstLgW:1␤␤»

[19:30] <TimToady> r: (*+*+*+*).(|(1,1,2,4,8)[^4]).say

[19:30] <p6eval> rakudo 69240d: OUTPUT«8␤»

[19:31] <diakopter> workaround, I guess

[19:32] <jnthn> uh, (1,1,2,4,8)[^4] will certainly pass as a single argument.

[19:32] <jnthn> You need the |, as TimToady did, if it's going to flatten into the argument list.

[19:32] *** mucker left
[19:33] <TimToady> the ... is doing something different

[19:36] <jnthn> $tail.munch($tail.elems - $count);

[19:36] <jnthn> $value := $code(|$tail);

[19:37] <jnthn> Is that right?

[19:37] <jnthn> I'd naively have expected $value := $code(|$tail.munch(...));

[19:38] *** Kresike left
[19:39] *** Celelibi joined
[19:44] <timotimo> can something like algebraic types be made with perl6 somehow?

[19:45] *** Kresike joined
[19:46] <TimToady> that depends on how "like" you need them, and how fancy "somehow" can be

[19:47] *** isBEKaml left
[19:49] <aesundstrom> FWIW, Sage is the best CAS system I've seen for abstract algebra, and it's written in Python. Now, given that everything in Python (pick your version) can be done better in Perl6 ? ;)

[19:50] <PerlJam> They're turing equivalent, so ...  ;)

[19:51] <aesundstrom> http://www.sagemath.org/

[19:52] *** pupoque joined
[19:56] *** alester joined
[19:57] * diakopter tries jnthn's patch

[19:58] *** crab2313 left
[20:00] *** cognominal left
[20:00] <sorear> yay, small world

[20:00] <sorear> aesundstrom: william stein was my calc I instructor D:

[20:01] <TimToady> r: https://gist.github.com/2838595

[20:01] <p6eval> rakudo 69240d: OUTPUT«[RedBlack::B, [RedBlack::B, [RedBlack::B, Any, 1, Any], 2, [RedBlack::B, Any, 3, Any]], 4, [RedBlack::B, [RedBlack::B, [RedBlack::R, Any, 5, Any], 6, Any], 7, [RedBlack::B, [RedBlack::R, Any, 8, Any], 9, [RedBlack::R, Any, 10, Any]]]]␤»

[20:01] <TimToady> n: https://gist.github.com/2838595

[20:01] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Lexical B is not a package at /tmp/n53wP0DbF5 line 3:␤------> multi balance(B⏏,[R,[R,$a,$x,$b],$y,$c],$z,$d) { [R,[B,$␤␤A type must be provided at /tmp/n53wP0DbF5 line 3:␤------> multi balance(B⏏…

[20:01] <TimToady> timotimo: see gist ^^

[20:02] *** Kresike left
[20:02] <aesundstrom> sorear: cool

[20:02] <jnthn> Whoa.

[20:02] <TimToady> sorear: see nieczabug ^^

[20:04] <moritz> TimToady: is that stolen from the Haskell solution?

[20:04] <colomon> TimToady++

[20:04] *** Kresike joined
[20:06] <sorear> niecza: sub foo(True) { }

[20:06] <p6eval> niecza v18-1-gc86e3f0: OUTPUT«===SORRY!===␤␤Lexical True is not a package at /tmp/xNq0ZDs_Ri line 1:␤------> sub foo(True⏏) { }␤␤A type must be provided at /tmp/xNq0ZDs_Ri line 1:␤------> sub foo(True⏏) { }␤␤Potential difficulties:…

[20:06] <sorear> TimToady: golfed for yu

[20:10] <dalek> Heuristic branch merge: pushed 25 commits to nqp by moritz

[20:11] <TimToady> moritz: yes

[20:11] *** brrt joined
[20:13] <jnthn> 25 commits?

[20:13] <moritz> jnthn: that's the branch merge from kboga++, replacing lots of pir:: ops with nqp:: ops

[20:14] <jnthn> oh, it was a bunch of commits

[20:14] <jnthn> yay :)

[20:14] <jnthn> kboga++

[20:14] <moritz> jnthn: and introduces quite some that were missing

[20:14] <moritz> I'm now spectesting the corresponding rakudo branch too

[20:14] <jnthn> \o/

[20:15] <jnthn> I need to review various 6model related ones and pick nqp:: names for those soon I guess.

[20:15] <diakopter> I have a patch for the ... munch thing

[20:16] <jnthn> Does it fix things?

[20:16] <brrt> yay, i build perl6 again

[20:16] <diakopter> building.. I think it will.

[20:16] *** not_gerd joined
[20:16] <jnthn> diakopter++

[20:16] <not_gerd> I further golfed the regex-dna failure: https://gist.github.com/2837706

[20:16] <TimToady> diakopter: can you explain the problem in words of one polysyllable?

[20:16] <not_gerd> it's just the hich number of match objects

[20:17] <not_gerd> someone needs to add some laziness to subst()

[20:17] <not_gerd> s/hich/high/

[20:17] <moritz> not_gerd: huh? subst returns a string, strings aren't lazy

[20:17] <diakopter> overmunch

[20:17] <diakopter> do.

[20:17] <diakopter> doh.

[20:17] <diakopter> segfault

[20:17] <diakopter> haha

[20:18] <diakopter> that shouldn't be....

[20:18] <not_gerd> moritz: subst stores all matches in an array before starting the replacements

[20:18] <jnthn> not_gerd: Those match objects still seem...crazy big. It's not that long.

[20:18] <not_gerd> that array exhausts my 32-bit address space if the input string is too large

[20:18] <moritz> not_gerd: oh

[20:18] <diakopter> yeah, the patch fixes it.  the segfault was while building Text.pir

[20:18] * jnthn checks something...

[20:19] <diakopter> fix: https://gist.github.com/2838671

[20:21] <moritz> r: my Str subset MyStr; say MyStr ~~ Str

[20:21] <p6eval> rakudo 69240d: OUTPUT«False␤»

[20:21] <diakopter> (it didn't segfault when I typed make again)

[20:21] <dalek> Heuristic branch merge: pushed 20 commits to rakudo/nom by moritz

[20:22] <jnthn> moritz: Wasn't that the $*OFTYPE thingy we discussed the other day?

[20:22] <moritz> jnthn: yes. But it passed bogusly before your last fix

[20:22] <jnthn> oh!

[20:22] <jnthn> I...thought I spectested :S

[20:23] <diakopter> spectesting my patch.

[20:23] <dalek> roast: e208a23 | moritz++ | S12-subset/subtypes.t:

[20:23] <dalek> roast: TODO a test that was passing bogusly before rakudo 12983a9c6

[20:23] <dalek> roast: review: https://github.com/perl6/roast/commit/e208a23077

[20:23] *** kaare_ left
[20:24] <diakopter> TimToady: it was munching all but 3 even if there was a codeblock, then it tried to munch all but code.count

[20:25] <TimToady> why is it copying 3 values from the front of $tail when it won't need them?

[20:25] <moritz> the sequence code is surprisingly complex

[20:26] <diakopter> TimToady: yes, probably the whole section should be in one $code.defined if

[20:26] *** aesundstrom left
[20:26] <PerlJam> and $code should be called $generator or something IMHP

[20:27] <PerlJam> eer, IMHO

[20:28] *** spider-mario joined
[20:31] <diakopter> ok, spectesting new (much bigger with indentation changes) patch

[20:31] <not_gerd> is it feasible to steal Niecza's subst() implementation ( https://github.com/sorear/niecza/blob/master/lib/CORE.setting#L543 ) for Rakudo?

[20:31] <not_gerd> there are some implementation-specific bits in it...

[20:32] <moritz> not_gerd: I think one can fix it incrementally

[20:33] <dalek> nqp: aad2c3c | jnthn++ | src/QRegex/Cursor.nqp:

[20:33] <dalek> nqp: If we know we won't backtrack into a rule, throw away the bstack from the Cursor.

[20:33] <dalek> nqp: review: https://github.com/perl6/nqp/commit/aad2c3cc2f

[20:36] <moritz> not_gerd: testing a patch locally

[20:39] <diakopter> test failures; ugh.

[20:40] <moritz> diakopter: one in subset.t wouldn't be surprising

[20:40] *** birdwindupbird left
[20:40] <diakopter> there are a lot

[20:41] <diakopter> it's surprising.

[20:41] *** birdwindupbird joined
[20:42] <moritz> note that character ranges listify through sequences

[20:42] <moritz> ie ('a'..'c').list goes through ('a' ... 'c') in rakudo

[20:42] <diakopter> hm

[20:42] <moritz> so you can get test failures that don't look like they should have anything to do with sequences if you bust that case

[20:43] <diakopter> yeah

[20:43] <moritz> oh, and did I mention that the sequence code is surprisingly complex? :-)

[20:44] <diakopter> oh, I see my fail; fixing

[20:45] <PerlJam> moritz: why is that a surprise?  :)

[20:45] <moritz> PerlJam: because it's such a small op, only three dots :-)

[20:45] <moritz> ok, that's not logical, I know

[20:46] <PerlJam> It's one of the more magical ops though.

[20:46] * sorear tried to steal rakudo-nom's SEQUENCE earlier, it broke the compiler ;)

[20:48] <PerlJam> diakopter: gist the patch?

[20:49] <PerlJam> What little I understand, it seems like you only need to comment out the first munch in SEQUENCE and that should fix it.

[20:50] <diakopter> to be most efficient, as TimToady suggested, we don't need to access/copy the first three values... so I refactored it a bit more https://gist.github.com/2838884

[20:51] <diakopter> ugh. still test failures.

[20:51] <diakopter> wth

[20:51] <moritz> r: say Match ~~ Positional

[20:51] <p6eval> rakudo 69240d: OUTPUT«False␤»

[20:53] <jnthn> diakopter: You haven't got any other local changes, like leftover NQP changes?

[20:53] <diakopter> oh

[20:53] <diakopter> no

[20:54] <diakopter> I'm trying it more simply, but uglier

[20:54] <PerlJam> diakopter: oh, I figured that first "if $code.defined {}" was needed because you don't want any of the other elsifs to trigger when you have a WhateverCode  (i.e., you're not deducing the sequence from the values you have already, you're generating them from the WhateverCode)

[20:54] <diakopter> now look at it: https://gist.github.com/2838884

[20:55] <PerlJam> ah, that does it I bet

[20:55] <moritz> looks much saner

[20:56] <diakopter> we'll see

[20:56] <diakopter> I'm still curious why I got the segfault earlier while building Test.pir

[20:57] *** ilogger2 joined
[20:57] *** ChanServ sets mode: +v ilogger2

[20:58] <diakopter> that's better.

[20:59] <diakopter> wait 15 minutes (even with TEST_JOBS=4) and I'll tell you whether it's all green

[20:59] <moritz> r: say ('ab' ~~/(.)(.)).list.elems

[20:59] <p6eval> rakudo 69240d: OUTPUT«===SORRY!===␤Preceding context expects a term, but found infix / instead␤at /tmp/gvmYNBcVl5:1␤»

[20:59] <moritz> r: say ('ab' ~~/(.)(.)/).list.elems

[20:59] <p6eval> rakudo 69240d: OUTPUT«2␤»

[21:00] <diakopter> oh, I see why the big patch didn't work.  oops.

[21:02] <moritz> jnthn: how expensive are binding and assignment?

[21:02] <moritz> ie when both are possible to use, does it make sense to use binding over assignment?

[21:03] <jnthn> moritz: I guess we're talking about scalars?

[21:03] <moritz> jnthn: yes

[21:03] <jnthn> moritz: Not much difference.

[21:04] <jnthn> moritz: Most assignments are cheap.

[21:04] <jnthn> (e.g. if there's not a Proxy or something)

[21:05] <jnthn> The main improvemnet will be if the optimizer realizes you bind immediately to a scalar, then it doesn't need to create a scalar container.

[21:10] <dalek> rakudo/lazy-subst: 494bd4f | moritz++ | src/core/Str.pm:

[21:10] <dalek> rakudo/lazy-subst: in Str.subst, never produce the whole list of matches

[21:10] <dalek> rakudo/lazy-subst: 

[21:10] <dalek> rakudo/lazy-subst: for very long strings this is too memory intensive. not_gerd++

[21:10] <dalek> rakudo/lazy-subst: review: https://github.com/rakudo/rakudo/commit/494bd4f5a4

[21:11] <moritz> not_gerd: at your convenience, please test if the lazy-subst branch improves the situation for that benchmark on 32bit

[21:12] <not_gerd> moritz: will do

[21:13] <diakopter> spectest was green

[21:14] <dalek> roast: ef5c6d5 | diakopter++ | S03-sequence/basic.t:

[21:14] <dalek> roast: test rakudo sequence overmunching

[21:14] <dalek> roast: review: https://github.com/perl6/roast/commit/ef5c6d58fb

[21:14] <diakopter> oops. forgot to increment plan.

[21:15] <PerlJam> diakopter: that one won't trigger the error since it never needs to call the generator

[21:15] <dalek> roast: ab4afba | diakopter++ | S03-sequence/basic.t:

[21:15] <dalek> roast: increment plan

[21:15] <dalek> roast: review: https://github.com/perl6/roast/commit/ab4afbaf57

[21:15] <dalek> roast: 27dbc07 | diakopter++ | S03-sequence/basic.t:

[21:15] <dalek> roast: increment plan

[21:15] <dalek> roast: review: https://github.com/perl6/roast/commit/27dbc07bc7

[21:16] <diakopter> r: ((1,1,2,4,8)[^4], *+*+*+* ... *)[4]

[21:16] <p6eval> rakudo b057f6: OUTPUT«Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/b9F51w2XVH:1␤␤»

[21:16] <PerlJam> Hrm.

[21:19] <PerlJam> r: say (1,1,2,4,8, *+*+*+* ... *)[4];

[21:19] <p6eval> rakudo b057f6: OUTPUT«8␤»

[21:19] <PerlJam> ah, that's it.

[21:19] <PerlJam> r: say (1,1,2,4,8, *+*+*+* ... *)[6]

[21:19] <p6eval> rakudo b057f6: OUTPUT«Not enough positional parameters passed; got 3 but expected 4␤  in block <anon> at /tmp/lioh_NNGt5:1␤␤»

[21:20] <diakopter> would someone like to apply the patch to rakudo?

[21:20] <diakopter> it spectested green

[21:20] <PerlJam> diakopter: you don't have a commit bit?

[21:20] <diakopter> not to rakudo

[21:23] *** kurahaupo joined
[21:24] <not_gerd> moritz: the regex-dna benchmark still runs out of memory

[21:24] *** libertyprime joined
[21:25] <diakopter> TimToady++ triggered the bug

[21:26] *** libertyprime left
[21:27] *** libertyprime joined
[21:31] <diakopter> let's see, to whom do I fax/mail/email something these days to get a rakudo commit bit

[21:32] <gfldex> if masak would be awake you would have got it already :)

[21:33] <not_gerd> moritz: https://gist.github.com/2837706

[21:33] <not_gerd> fails at replacement 25580 here

[21:33] <not_gerd> it seems the match objects won't ger garbage collected...

[21:33] <not_gerd> ^get

[21:33] <PerlJam> hugme: add diakopter to rakudo

[21:33] <hugme> PerlJam: You need to register with freenode first

[21:34] <PerlJam> bummer.  :)

[21:34] <jnthn> Also, they're holding on to an insane amount of memory. I can't work out why right now.

[21:34] <diakopter> also, I need to send in a CLA I thought

[21:35] <jnthn> Yes.

[21:36] <diakopter> who receives the CLA these days

[21:36] <jnthn> I forget off hand...

[21:36] <diakopter> [Coke]?

[21:37] <jnthn> pmichaud may also know

[21:37] <sorear> TPF, isn't it?

[21:38] <diakopter> I shouldn't speak of it like it's a formality; I realize it's an application.

[21:39] <sorear> no, it is not an applicated

[21:39] <sorear> application

[21:39] <sorear> the CLA is a one-sided contract.  TPF has no incentive to ever refuse a CLA, and I've never heard of them doing so

[21:40] <sorear> I, the undersigned, agree that TPF has the non-exclusive rights to use my code as they see fit

[21:52] <not_gerd> good night, #perl6

[21:53] <sergot> good night o/ !

[21:59] *** b1rkh0ff joined
[22:06] *** Teratogen joined
[22:11] *** spaceships joined
[22:11] *** libertyprime left
[22:12] *** libertyprime joined
[22:14] *** kubrat joined
[22:18] *** spaceships left
[22:20] *** libertyprime left
[22:21] *** libertyprime joined
[22:31] *** whiteknight joined
[22:31] *** whiteknight is now known as Guest28985

[22:34] *** spaceships joined
[22:40] *** libertyprime left
[22:40] *** libertyprime joined
[23:07] *** [particle]1 joined
[23:11] *** icwiener_ joined
[23:15] <diakopter> phenny: ask moritz please apply my rakudo patch if you want the test I added to stop failing :)

[23:15] <phenny> diakopter: I'll pass that on when moritz is around.

[23:17] *** masonkramer joined
[23:17] <diakopter> phenny: ask moritz (or fudge it, of course)

[23:17] <phenny> diakopter: I'll pass that on when moritz is around.

[23:24] *** Chillance joined
[23:24] *** lestrrat joined
[23:33] *** wooden joined
[23:48] *** wolfman2000 joined
[23:55] <sorear> the debootstrapping experiment begins in earnest.

[23:55] <TimToady> have the appropriate amount of fun

