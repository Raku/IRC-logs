[00:08] *** awwaiid left
[00:09] *** awwaiid joined
[00:09] <dalek> niecza: eeed873 | sorear++ | docs/announce.v14:

[00:09] <dalek> niecza: Finish writing up announce.v14

[00:09] <dalek> niecza: review: https://github.com/sorear/niecza/commit/eeed873ec2

[01:04] *** Chillance left
[01:28] *** trippeh_ left
[01:40] <dalek> roast: 330bd62 | (Solomon Foster)++ | S02-magicals/env.t:

[01:40] <dalek> roast: Tweaks to avoid reams of "Use of uninitialized value in string context" errors.

[01:40] <dalek> roast: review: https://github.com/perl6/roast/commit/330bd62533

[01:41] *** whiteknight joined
[01:44] *** aaaswwefff joined
[01:51] *** aaaswwefff left
[01:56] *** kfo_ left
[01:57] *** kfo joined
[02:00] <sorear> I try to reserve the word 'error' for situations where the computation stops

[02:01] <sorear> phenny: tell pmurias If you see this message before Monday, I'd like it if you could give a better description of your changes for announce.v14

[02:01] <phenny> sorear: I'll pass that on when pmurias is around.

[02:03] <sorear> anyone else who wants to look at announce.v14, please go ahead

[02:04] <diakopter> sorear: Parameters like @foo and %foo now insist that their arguments to Positional and Associative respectively.  missing a verb?

[02:13] *** PZt left
[02:16] <Yary> Hi all... I was hoping to initialize a "lazy" attribute using Rakudo but I seem to be doing it wrong-

[02:16] <Yary> rakudo: class B {has @.x; method new(Int $y) {self.bless(*);@.x <== (0..$y)}}

[02:16] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Sorry, do not know how to handle this case of a feed operator yet. at line 1, near " (0..$y)}}"␤»

[02:16] <Yary> is there a way around that?

[02:19] <dalek> niecza: 830a9ed | sorear++ | docs/announce.v14:

[02:19] <dalek> niecza: Fix verb (diakopter)

[02:19] <dalek> niecza: review: https://github.com/sorear/niecza/commit/830a9ed4f4

[02:19] <sorear> Yary: keep it simple

[02:19] <sorear> Yary: <== is a parallel processing operator, it is not "simple" by any stretch

[02:20] <Yary> was just looking at the example in Iterators on initializing a range

[02:20] <Yary> s07

[02:20] <sorear> S07 is completely obsolete

[02:21] <Yary> well my code will work with eager semantics, easily

[02:21] <Yary> so I can use

[02:22] <sorear> <== has nothing to do with laziness anymore

[02:22] <Yary> rakudo: class B {has @.x; method new(Int $y) {self.bless(*, x=> (0..$y)}}

[02:22] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Unable to parse postcircumfix:sym<( )>, couldn't find final ')' at line 2␤»

[02:22] <Yary> typo

[02:22] <sorear> <== is the opposite of lazy, it will start extra threads to fill your array

[02:22] <Yary> rakudo: class B {has @.x; method new(Int $y) {self.bless(*, x=> (0..$y))}}

[02:22] <p6eval> rakudo 9719f7:  ( no output )

[02:22] <Yary> any pointers for up-to-date lazy/eager docs?

[02:23] <Yary> rakudo: class B {has @.x; method new(Int $y) {self.bless(*, x=> (0..$y))}}; my $b=B.new(3);say $b.x

[02:23] <p6eval> rakudo 9719f7: OUTPUT«0 1 2 3␤»

[02:25] *** ponbiki joined
[02:27] *** birdwindupbird joined
[02:31] <[Coke]> # 01/29/2012 - niecza at 99.52%

[02:31] <[Coke]> b: say 19548 - 19456

[02:31] <p6eval> b 1b7dd1: OUTPUT«92␤»

[02:32] *** birdwindupbird left
[02:37] <sorear> [Coke]: do you have a breakdown by synopsis for that?  is rakudo gaining or niecza losing?

[02:37] <sorear> Yary: no

[02:37] <[Coke]> I don't keep the synopsis breakdown.

[02:37] <[Coke]> I have the latest numbers and can plug them into the google spreadsheet. lemme do that.

[02:42] <[Coke]> Updated: https://docs.google.com/spreadsheet/ccc?key=0Ahm1zTZwW0VHdE1NN19GdE1fTmZZYnpGdURFM1A0cHc

[02:42] <[Coke]> rakudo's biggest lead is in S12.

[02:43] <[Coke]> (Objects)

[02:43] <colomon> it's all the metaprogramming and introspection

[02:43] <[Coke]> niecza is leading in S32, even without Temporal.

[02:43] <colomon> that's just the FatRat tests.  :)

[02:47] <Yary> I like s07, 0 vs 0, I'll have to remember to take that one with a grain of salt for now

[02:48] <TimToady> sorear: it still sez v13 on the first line

[02:51] <[Coke]> TimToady: good catch. ;)

[02:53] *** ponbiki left
[02:56] <dalek> niecza: ff52ee4 | sorear++ | docs/announce.v14:

[02:56] <dalek> niecza: s/13/14/ TimToady++

[02:56] <dalek> niecza: review: https://github.com/sorear/niecza/commit/ff52ee4231

[02:56] *** ponbiki joined
[03:00] *** whiteknight left
[03:06] *** skids left
[03:08] <colomon> Dang, that is an utterly insane list of niecza progress in the last month.

[03:19] *** orafu left
[03:19] *** orafu joined
[03:19] <TimToady> hmm, not a criticism of the document, but infix operators returning Bool should default to iffy, and ones where the returned type is different from the left argument should default to diffy

[03:32] *** kmwallio joined
[03:44] *** wolfman2000 joined
[03:47] <wolfman2000> masak: you awake?

[03:48] *** kmwallio left
[03:49] <Yary> Hello again, world, basic question- how do I override my class' stringification & numification?

[03:53] <Yary> or more accurately, change how objects in that class stringify/numify?

[03:54] <TimToady> wolfman2000: doubtful, he's in Sweden

[03:54] <wolfman2000> right, I forgot that.

[03:55] <wolfman2000> I was hoping to see what updates were made to his web framework that I recall he was working on.

[04:02] <TimToady> Yary: typically we've just defined Str or Num methods, though we might generalize that at some point

[04:02] <Yary> OK I'll try that, thanks

[04:02] <TimToady> they should probably be submethods, as should .perl and .gist unless you're willing to speak for subclasses as well

[04:05] *** lutok joined
[04:09] *** Radvendii left
[04:11] *** lutok left
[04:36] *** Trashlord left
[04:37] *** birdwindupbird joined
[04:38] <moritz> \o

[04:38] <offby1> _/o

[04:41] <sorear> \o

[04:51] *** Trashlord joined
[05:03] <eviltwin_b> /o\

[05:07] * offby1 pours rubbish on eviltwin_b, since he's already taken cover

[05:11] *** ponbiki left
[05:57] *** alvis left
[06:00] *** shinobicl_ left
[06:12] *** alvis joined
[06:14] *** kaleem joined
[06:22] *** lestrrat left
[06:23] *** lestrrat joined
[06:27] *** PZt joined
[06:33] *** xinming left
[06:54] *** xinming joined
[06:59] *** wtw joined
[07:01] *** zby_home_ left
[07:07] *** sftp joined
[07:28] *** flussence left
[07:29] *** flussence joined
[07:35] *** passr joined
[07:35] *** am0c_ joined
[07:35] <passr> perl6: say [!=] 1,2,3,1

[07:35] <p6eval> rakudo 9719f7: OUTPUT«Bool::True␤»

[07:35] <p6eval> ..niecza v13-381-g4158fa9: OUTPUT«Unhandled exception: assigning to readonly value␤  at /tmp/fYOEjkWoSB line 0 (ANON @ 1) ␤  at /home/p6eval/niecza/lib/CORE.setting line 2276 (reduceop @ 17) ␤  at /tmp/fYOEjkWoSB line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3609 (…

[07:35] <p6eval> ..pugs b927740: OUTPUT«1␤»

[07:35] *** am0c left
[07:36] *** am0c_ is now known as am0c

[07:37] <passr> hi perl6! why rakudo say true?say [!=] 1,2,3,1

[07:39] <moritz> because it's the same as  1 != 2 != 3 != 1, which in turn in the same as (1 != 2) && (2 != 3) && (3 != 1)

[07:39] <moritz> which is True

[07:43] <passr> moritz: If I want test all the numbers all diffrent, how to code?

[07:43] <moritz> passr: you could use a hash, for example

[07:44] <moritz> rakudo: sub all_uniq(*@a) { my %h; for @a { return False if %h{$_}++ }; True }; say all_uniq(<1 2 3>), all_uniq(<1 2 3 1>)

[07:44] <p6eval> rakudo 9719f7: OUTPUT«Bool::TrueBool::False␤»

[07:44] <moritz> rakudo: sub all_uniq(*@a) { @a.uniq.elems == @a.elems}; say all_uniq(<1 2 3>), all_uniq(<1 2 3 1>)

[07:44] <p6eval> rakudo 9719f7: OUTPUT«Bool::TrueBool::False␤»

[07:45] <passr> moritz:thanks!

[07:45] <moritz> rakudo: sub all_uniq(*@a) { so all(@a) == one(@a) }; say all_uniq(<1 2 3>), all_uniq(<1 2 3 1>)

[07:45] <p6eval> rakudo 9719f7: OUTPUT«Bool::TrueBool::False␤»

[07:53] <Timbus> i like that last one

[07:55] <Timbus> its the solution i would have came up with, but at the same time, wouldn't have known how to do it

[08:11] <sorear> welcome, passr

[08:12] <passr> sorear:hi~

[08:24] *** snearch joined
[08:27] <passr> rakudo: say ([1,2,3],[1,2,2],[4,5,6]).grep: {so all @$_ == one @$_}

[08:27] <p6eval> rakudo 9719f7: OUTPUT«1 2 3␤»

[08:28] <moritz> hrmpf

[08:28] <moritz> uses hashes then :-)

[08:29] <passr> moritz: something wrong?

[08:33] <masak> mornink, #perl6

[08:33] <masak> passr: useless use of 'so'

[08:34] <passr> moritz: thanks!

[08:34] <masak> it makes sense in the all_uniq sub, not so much in the grep, which already boolifies for you.

[08:34] *** mj41 joined
[08:35] <moritz> shouldn't that have also returned [4, 5, 6] ?

[08:36] <passr> but  no output?

[08:37] <Timbus> nom: say all @$_ == one @$_ for ([1,2,3])

[08:37] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::False, Bool::False, Bool::True))␤»

[08:37] <Timbus> got intified

[08:40] *** TimToady left
[08:40] *** daxim joined
[08:41] *** TimToady joined
[08:41] <Timbus> does one() not work on arrays or something or

[08:41] *** mj41 left
[08:42] <passr> maybe?

[08:42] <masak> nom: say all @$_ for [1, 2, 3]

[08:42] <p6eval> nom 9719f7: OUTPUT«all(1, 2, 3)␤»

[08:42] <masak> nom: say one @$_ for [1, 2, 3]

[08:42] <p6eval> nom 9719f7: OUTPUT«one(1, 2, 3)␤»

[08:43] <masak> nom: say all([1,2,3]) == one([1,2,3])

[08:43] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::True))␤»

[08:43] <masak> nom: say all(1,2,3) == one(1,2,3)

[08:43] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::True, Bool::False, Bool::False), one(Bool::False, Bool::True, Bool::False), one(Bool::False, Bool::False, Bool::True))␤»

[08:44] <masak> nom: say all([1,2,3].list) == one([1,2,3].list)

[08:44] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::True, Bool::False, Bool::False), one(Bool::False, Bool::True, Bool::False), one(Bool::False, Bool::False, Bool::True))␤»

[08:44] * Timbus holds his head and walks away

[08:44] *** daemon left
[08:44] <masak> that, believe it or not, is the correct response to anything junction-y.

[08:44] <Timbus> yes but

[08:44] <masak> use them below the headache threshold :)

[08:45] *** cosimo left
[08:45] <Timbus> nom: say all @$_ == one @$_ given [1,2,3]

[08:45] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::False, Bool::False, Bool::True))␤»

[08:45] <Timbus> whats up with that

[08:45] <Timbus> better shown

[08:45] <masak> nom: say all(@$_) == one(@$_) given [1,2,3]

[08:45] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::True, Bool::False, Bool::False), one(Bool::False, Bool::True, Bool::False), one(Bool::False, Bool::False, Bool::True))␤»

[08:45] <masak> Timbus: precedence.

[08:45] <Timbus> nom: say all @$_ == one @$_ given [9,3,6]

[08:45] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::False, Bool::True, Bool::False))␤»

[08:46] <Timbus> oh

[08:46] <masak> Timbus: 'all' is a listop, so it eats '@$_ == one @$_'

[08:46] <masak> case closed. :)

[08:46] <masak> use parens.

[08:46] *** cosimo joined
[08:46] <Timbus> arg

[08:47] * masak .oo( use parens for you arg )

[08:47] <masak> your*

[08:47] <sorear> all(@$_) perhaps better written .all

[08:48] *** daemon joined
[08:48] <Timbus> i blame passr for everything that just happened :I

[08:48] <masak> :D

[08:48] <passr> Thanks!Timbus,masak.

[08:48] * sorear -> sleep

[08:53] <passr> masak: can you write any shorter code than that?

[08:54] <masak> nom: say .all == .one given [1, 2, 3]

[08:54] <p6eval> nom 9719f7: OUTPUT«all(one(Bool::True, Bool::False, Bool::False), one(Bool::False, Bool::True, Bool::False), one(Bool::False, Bool::False, Bool::True))␤»

[08:54] <masak> nom: say so .all == .one given [1, 2, 3]

[08:54] <p6eval> nom 9719f7: OUTPUT«Bool::True␤»

[08:55] <masak> by sorear++'s suggestion.

[08:55] <passr> wow!

[08:55] *** lestrrat left
[08:55] *** lestrrat joined
[08:57] *** mj41 joined
[09:13] <moritz> nom: say so .all == .one given [1, 2, 4, 1]

[09:13] <p6eval> nom 9719f7: OUTPUT«Bool::False␤»

[09:13] <passr> masak: how to write it shorter.about this code: my @a = ^4; my @b = @a X~ @a X~ @a X~ @a

[09:17] <masak> niecza: my @a = ^4; @a = @a X~ @a for ^2; say @a

[09:17] <p6eval> niecza v13-381-g4158fa9: OUTPUT«0000 0001 0002 0003 0010 0011 0012 0013 0020 0021 0022 0023 0030 0031 0032 0033 0100 0101 0102 0103 0110 0111 0112 0113 0120 0121 0122 0123 0130 0131 0132 0133 0200 0201 0202 0203 0210 0211 0212 0213 0220 0221 0222 0223 0230 0231 0232 0233 0300 0301 0302 …

[09:18] <masak> niecza: my @a = ^4; @a X~= @a for ^2; say @a

[09:18] <p6eval> niecza v13-381-g4158fa9: OUTPUT«0012300123100123100123232001231001231001232320012310012310012323330012310012310012323200123100123100123232001231001231001232333001231001231001232320012310012310012323200123100123100123233 1001231001232300123001231001231001232320012310012310012323200123100…

[09:18] *** takesako joined
[09:18] <masak> niecza: my @a = ^4; @a [X~]= @a for ^2; say @a

[09:18] <p6eval> niecza v13-381-g4158fa9: OUTPUT«0000 0001 0002 0003 0010 0011 0012 0013 0020 0021 0022 0023 0030 0031 0032 0033 0100 0101 0102 0103 0110 0111 0112 0113 0120 0121 0122 0123 0130 0131 0132 0133 0200 0201 0202 0203 0210 0211 0212 0213 0220 0221 0222 0223 0230 0231 0232 0233 0300 0301 0302 …

[09:19] <daxim> http://d.hatena.ne.jp/tokuhirom/20120130/1327912149

[09:19] <jnthn> morning, #perl6

[09:19] <masak> niecza: my @a = (@a = ^4) X~ @a; say @a

[09:19] <p6eval> niecza v13-381-g4158fa9: OUTPUT«00 01 02 03 10 11 12 13 20 21 22 23 30 31 32 33␤»

[09:19] <masak> niecza: my @a = (@a = ((@a = ^4) X~ @a) X~ @a); say @a

[09:19] <p6eval> niecza v13-381-g4158fa9: OUTPUT«000 001 002 003 010 011 012 013 020 021 022 023 030 031 032 033 100 101 102 103 110 111 112 113 120 121 122 123 130 131 132 133 200 201 202 203 210 211 212 213 220 221 222 223 230 231 232 233 300 301 302 303 310 311 312 313 320 321 322 323 330 331 332 333…

[09:20] <masak> niecza: my @a = ((@a = ((@a = ^4) X~ @a)) X~ @a); say @a

[09:20] <p6eval> niecza v13-381-g4158fa9: OUTPUT«0000 0001 0002 0003 0010 0011 0012 0013 0020 0021 0022 0023 0030 0031 0032 0033 0100 0101 0102 0103 0110 0111 0112 0113 0120 0121 0122 0123 0130 0131 0132 0133 0200 0201 0202 0203 0210 0211 0212 0213 0220 0221 0222 0223 0230 0231 0232 0233 0300 0301 0302 …

[09:22] *** dakkar joined
[09:23] *** snearch left
[09:26] <moritz> nom: print .base(4).fmt('%04s ') for ^(4**4)

[09:26] <p6eval> nom 9719f7: OUTPUT«0000 0001 0002 0003 0010 0011 0012 0013 0020 0021 0022 0023 0030 0031 0032 0033 0100 0101 0102 0103 0110 0111 0112 0113 0120 0121 0122 0123 0130 0131 0132 0133 0200 0201 0202 0203 0210 0211 0212 0213 0220 0221 0222 0223 0230 0231 0232 0233 0300 0301 0302 0303 0310 031…

[09:27] <jnthn> :)

[09:27] <moritz> is that considered cheating? :-)

[09:27] <masak> it's indistinguishable from the real solution :P

[09:29] <tadzik> good morning!

[09:30] <moritz> o/ tadzik 

[09:30] <jnthn> ...and easier to read. :)

[09:30] <jnthn> tadzik: Wow, tadzik *in the morning*!

[09:30] <jnthn> ;)

[09:31] <masak> (tadzik in the morning)++

[09:32] <masak> nom: say (.base(4) for ^256).fmt('%04s')

[09:32] <p6eval> nom 9719f7: OUTPUT«0000 0001 0002 0003 0010 0011 0012 0013 0020 0021 0022 0023 0030 0031 0032 0033 0100 0101 0102 0103 0110 0111 0112 0113 0120 0121 0122 0123 0130 0131 0132 0133 0200 0201 0202 0203 0210 0211 0212 0213 0220 0221 0222 0223 0230 0231 0232 0233 0300 0301 0302 0303 0310 031…

[09:32] <tadzik> Achievement unlocked! :)

[09:34] <passr> Is it impossible use reduce operator? [ ]

[09:35] <moritz> I don't think so.

[09:36] <passr> it must be shortest,I think?

[09:36] <moritz> must it be?

[09:36] <moritz> nom: say [X~] [^4] xx 4

[09:36] <p6eval> nom 9719f7: OUTPUT«0000 0001 0002 0003 0010 0011 0012 0013 0020 0021 0022 0023 0030 0031 0032 0033 0100 0101 0102 0103 0110 0111 0112 0113 0120 0121 0122 0123 0130 0131 0132 0133 0200 0201 0202 0203 0210 0211 0212 0213 0220 0221 0222 0223 0230 0231 0232 0233 0300 0301 0302 0303 0310 031…

[09:36] <moritz> maybe :-)

[09:37] <passr> I love it !!

[09:40] <passr> moritz: That's all I need!Thanks!

[09:42] <masak> moritz++

[09:44] <passr> masak++ too

[09:44] <masak> nom: say [X~] ^4 xx 4

[09:44] <p6eval> nom 9719f7: OUTPUT«0123012301230123␤»

[09:44] <masak> just had to try :)

[09:47] *** Psyche^ joined
[09:48] *** Patterner left
[09:48] *** Psyche^ is now known as Patterner

[09:52] <passr> masak:precedence?

[09:53] <masak> nom: say ^4 xx 4

[09:53] <p6eval> nom 9719f7: OUTPUT«0 1 2 3 0 1 2 3 0 1 2 3 0 1 2 3␤»

[09:53] <moritz> flattening, not precedence

[09:54] <masak> passr: more like, without the array, you don't get X~ to cross four arrays against each other.

[09:57] <passr> thanks guys

[10:05] <passr> Is it impossible use reduce operator?  ([1,2,3],[1,2,2],[4,5,6]).grep: {so all(@$_) == one(@$_)}

[10:05] <masak> useless use of 'so' again.

[10:06] <moritz> passr: I don't think it's impossible. But I don't want to spoil your fun when you try to figure it out on your own

[10:07] <passr> :masak:thanks

[10:07] <passr> moritz: Can you try to do that?

[10:07] <Timbus> heh

[10:08] <passr> o/

[10:08] <moritz> passr: not spoil your fun? sure thing.

[10:09] *** am0c left
[10:10] <passr> don't worry. moritz.i just want to find a shortest code for that.but I can't do that myself.

[10:10] <masak> sure you can!

[10:10] <moritz> passr: why not?

[10:10] <masak> but why are you so obsessed with short code?

[10:11] <masak> there are so many other things to optimize for.

[10:11] <passr> I love short code

[10:11] <masak> the ability to grok the code tomorrow, for example :)

[10:14] <passr> moritz: If Ican do that ,I 'll not ask question here.

[10:15] <moritz> passr: it's not an either-or

[10:15] <moritz> passr: you can try, show us some partial successes, and then tell us why you can't get further

[10:16] <moritz> passr: right now it juts feels like "golf that for me!", which is not the friendliest way to interact with us

[10:16] <passr> moritz:I'll try

[10:17] <masak> it's not unfriendly as such. just a bit lazy. :)

[10:18] <passr> masak:not lazy,but stupid.

[10:19] <passr> masak: not so smart as you

[10:20] <masak> passr: I refuse to believe that, since I know my brain from the inside :)

[10:21] <masak> the trick isn't to be smart all the time. the trick is to notice when you have smart days, or smart afternoons, and do something cool then. :)

[10:21] <masak> I've been planning to put out a blog post saying "we're all stupid sometimes"

[10:21] <passr> masak: You are my teacher

[10:21] <masak> tools like RT and git and the test suite really help to even out the smart/stupid fluctuations.

[10:21] <Timbus> another illegitimate student

[10:22] <Timbus> D:

[10:22] <moritz> the trick is also not to think of yourself as being stupid, because you start to believe it, and feel discouraged to try

[10:22] <masak> Timbus: I was thinking that -- "oh no, not again" :P

[10:22] <moritz> the trick is also not to think of yourself as being smart, because it implies some hard-bounded limit that you can't bend

[10:22] <moritz> which isn't the case

[10:23] <masak> also, if you think you're smart, you might not be humble enough to learn when you need to.

[10:23] <moritz> the trick is to think yourself of exploring, because that's what you should do

[10:23] <masak> development. it's an exploration.

[10:23] <Timbus> the only time im smart is when im doing something fundamentally dumb :<

[10:23] <Timbus> see: my independent discovery of sleep sort http://rosettacode.org/wiki/Sorting_algorithms/Sleep_sort#Perl

[10:24] <moritz> there have been interesting behavioral studies involving children who solved some tasks, and then one group was praised for being smart, and the other for working hard on the problem

[10:24] <moritz> the first group, when faced with a more difficult task, gave up much earlier, and thust performed worse

[10:25] <Timbus> the "smart" children got a payrise, the "hard working" ones lobbied for one but didnt get it

[10:26] <passr> Timbus: I love it .but i can't understand that code at the first time

[10:27] *** lestrrat left
[10:28] *** lestrrat joined
[10:32] *** lestrrat left
[10:33] *** lestrrat joined
[10:35] *** passr left
[10:37] <masak> everybody, thank you so much for your p6cc solutions.

[10:38] <moritz> indeed. It is a joy to read, test and review

[10:38] <masak> moritz and I are having way too much fun analyzing them and comparing them.

[11:02] *** baest left
[11:03] *** bloonix left
[11:07] <flussence> perl6: [1..10].pick(*)».map: { sleep $_; say $_ }

[11:07] <p6eval> pugs b927740: OUTPUT«decodeUTF8': bad data: '\187'␤»

[11:07] <p6eval> ..rakudo 9719f7, niecza v13-381-g4158fa9: OUTPUT«(timeout)8␤»

[11:08] <flussence> heh, trying to be too clever :)

[11:08] <moritz> >> doesn't parallelize

[11:08] <moritz> (yet)

[11:09] *** Trashlord left
[11:10] *** Trashlord joined
[11:10] <flussence> OTOH, maybe I've just invented threaded bogosort... 

[11:42] *** icwiener joined
[11:58] *** mupon joined
[11:59] <mupon> nom: (1..10).map: { sleep $_; say $_ }

[11:59] <p6eval> nom 9719f7:  ( no output )

[11:59] <mupon> it works

[12:00] *** mupon left
[12:05] <flussence> .oO( methinks the audience missed the point... )

[12:09] * jnthn was trying to work out what the point was

[12:09] <jnthn> Maybe it's something like: "hi! I don't understand that map is lazy!"

[12:10] <jnthn> Not sure if the "it works" was a statement of fact or satire ;)

[12:21] <masak> I agree that it works.

[12:22] *** fasad joined
[12:22] <masak> just not the way the person might've expected.

[12:22] <masak> but clearly, it's the expectations that were wrong.

[12:40] <fasad> hi

[12:41] <masak> \o

[12:43] <fasad> so 'man perl6' says 'perl -v' should work just the same as 'perl6 --version' but for me it enters the REPL. Regression? or it never worked?

[12:44] <moritz> I think it worked back in the old (alpha) days

[12:46] <fasad> time to fix it?

[12:46] * masak submits rakudobug

[12:46] <moritz> I hope you have the time to fix it :-)

[12:47] <fasad> * fasad lowers his eyes

[12:47] <fasad> damn

[12:47] * fasad lowers his eyes

[12:48] *** timotimo left
[12:49] *** timotimo joined
[12:50] <masak> fasad: it's probably easier than you think.

[12:50] <fasad> masak: ok, offhand, what skills do i need?

[12:51] <masak> ability to read code.

[12:51] <masak> knowledge of where the flags are defined.

[12:51] <masak> luck.

[12:51] <moritz> (grep can help you, if you don't know where stuff happens)

[12:52] <fasad> and masak+moritz's blessings :p

[12:53] <masak> command_eval in nqp/HLL/Compiler.pm seems to have something to do with it all.

[12:53] <masak> but there ought to be some place where the flags are *set*.

[12:53] <moritz> that's typically in some Compiler.pm

[12:54] <jnthn> Either src/main.nqp or src/Perl6/Compiler.pm I suspect

[12:54] <moritz> so src/Perl6/Compiler.nqp

[12:54] <moritz> or main.nqp

[12:54] <jnthn> er, yes

[12:54] <moritz> or nqp's NQP::Compiler

[12:54] <moritz> or HLL::Compiler

[12:55] <masak> see? it's easy! :)

[12:55] <fasad> LOL

[12:56] <moritz> ... except that it's not so easy as it seems

[12:56] <moritz> because my initial tests seem to show that no single-letter versions of multi-letter options work

[12:59] *** rindolf joined
[12:59] <rindolf> Hi all. I'm getting a compilation error with the latest Rakudo Star using Parrot-4.0.0. Is it a known issue?

[13:00] <moritz> rindolf: no, but that's not the parrot that rakudo recommends

[13:00] <rindolf> moritz: OK.

[13:00] <moritz> rindolf: is there any reason for deviating from the recommendation?

[13:01] <rindolf> moritz: well, I've been packaging the new parrot/Rakudo/etc. for Mageia Linux Cauldron.

[13:01] <moritz> rindolf: anyway, what's the error?

[13:01] <rindolf> moritz: let me pastebot it.

[13:01] <fasad> rindolf: welcome :p

[13:02] <rindolf> moritz: here - http://paste.debian.net/154062/

[13:04] <moritz> never seen that one

[13:06] *** pomysl left
[13:06] *** pomysl joined
[13:06] *** pomysl left
[13:06] *** pomysl joined
[13:10] <dalek> nqp: b23ee76 | moritz++ | src/HLL/Compiler.pm:

[13:10] <dalek> nqp: fix -v short form of --version

[13:10] <dalek> nqp: review: https://github.com/perl6/nqp/commit/b23ee7651b

[13:11] <moritz> fasad: now tell me if that patch really looks complicated to you

[13:14] <fasad> moritz: no it doesn't *look* complicated, but there is so much knowledge & experience behind it which fails to meet the eye...

[13:14] <moritz> fasad: not at all

[13:14] <moritz> fasad: I just grepped for 'version' in HLL/Compiler.pm

[13:14] <moritz> fasad: the only other knowledge I had was that %adverbs holds the command line options

[13:15] <moritz> there aren't that many places mentioning 'version', and only one that does something conditionally on the presence of something version-y

[13:20] *** kaleem left
[13:20] *** mtk joined
[13:20] <fasad> ok, so i'm inspired now. 'perl6 -h' also does not work. so may i request that no one fixes it, & i''l fix it within 24hrs ! (coz i have to understand some git basics, get a github account!, etc.)

[13:21] <fasad> *i'll

[13:21] <moritz> fasad: +1

[13:23] <masak> ++fasad

[13:23] <masak> go go go! :)

[13:24] <masak> fasad: http://learn.github.com/p/intro.html looks good for learning Git.

[13:25] <fasad> masak: thanks. 'coz i need a crash course !

[13:27] *** rindolf left
[13:29] <moritz> phenny: tell rindolf fwiw on my machine (debian stable), rakudo compiles fine on a recent parrot

[13:29] <phenny> moritz: I'll pass that on when rindolf is around.

[13:36] <dalek> rakudo/nom: d63e72d | moritz++ | src/ (2 files):

[13:36] <dalek> rakudo/nom: more typed syntax errors

[13:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/d63e72d744

[13:36] <dalek> rakudo/nom: 0683298 | moritz++ | src/ (2 files):

[13:36] <dalek> rakudo/nom: more typed exceptions

[13:36] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/0683298ea6

[13:37] <dalek> nqp: cf6203f | moritz++ | tools/build/PARROT_REVISION:

[13:37] <dalek> nqp: bump parrot revision to get some testing

[13:37] <dalek> nqp: review: https://github.com/perl6/nqp/commit/cf6203f62b

[13:49] <[Coke]> b: say 668-100 # rt-testneeded

[13:49] <p6eval> b 1b7dd1: OUTPUT«568␤»

[13:49] <moritz> oh my, 100 testneeded again?

[13:49] <jnthn> Dammit, I should stop fixing stuff :P

[13:50] <[Coke]> rakudo: "foo" ~~ /<B::TOP>/

[13:50] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Could not locate compile-time value for symbol B␤»

[13:50] <jnthn> Hm, not a *bad* error, but would be better off saying that B is not predeclared or some such.

[13:51] <jnthn> Good we catch it at compile time, though :)

[13:51] <[Coke]> jnthn: it's upgraded from "null PMC"

[13:51] <[Coke]> RT #64366 if you really want a better error msg. ;)

[13:51] <jnthn> [Coke]: Then it's a huge improvement. That means compile time error, includes the name of the thing that's wrong, and not a Null PMC error

[13:51] <jnthn> [Coke]: No, I'll take this as sufficient improvement to say the ticket is done

[13:52] <[Coke]> so, 101 now. ;)

[13:52] <jnthn> moritz++ will probably make a pass through this stuff when doing typed exception things anyway.

[13:52] *** colomon left
[13:53] <[Coke]> rakudo: class foo { has $!baz; method bar { my $!baz = 'lorem'; say $!baz; }; }; my $foo = foo.new; $foo.bar;

[13:53] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Cannot use ! twigil on my variable at line 1, near " = 'lorem'"␤»

[13:53] <moritz> jnthn: yes, but I still need some ideas how to throw typed exceptions from the MOP

[13:53] <jnthn> moritz: Well, that one's from World.

[13:53] <[Coke]> rakudo: class foo { method bar { my $!baz = 'lorem'; say $!baz; }; };

[13:54] <jnthn> moritz: But yes, you do. :)

[13:54] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Cannot use ! twigil on my variable at line 1, near " = 'lorem'"␤»

[13:54] <jnthn> std: class foo { method bar { my $!baz = 'lorem'; say $!baz; }; };

[13:54] <p6eval> std 48335fc: OUTPUT«ok 00:01 110m␤»

[13:54] <jnthn> niecza: class foo { method bar { my $!baz = 'lorem'; say $!baz; }; };

[13:54] <[Coke]> rakudo: class foo { has $!baz = 'ipsum'; method bar { my $!baz = 'lorem';say $!baz; }; }; my $foo = foo.new; $foo.bar;

[13:54] <fasad> what is the relationship between nqp & rakudo ?

[13:54] <p6eval> niecza v13-381-g4158fa9: OUTPUT«===SORRY!===␤␤Unable to resolve method add_method in class Any at /tmp/ZYTyuEsibA line 1:␤------> class foo { method bar { my $!baz ⏏= 'lorem'; say $!baz; }; };␤␤Unhandled exception: Check failed␤␤  at /home/p6eval/nie…

[13:54] <p6eval> rakudo 9719f7: OUTPUT«===SORRY!===␤Cannot use ! twigil on my variable at line 1, near " = 'lorem'"␤»

[13:54] <moritz> rakudo: try eval q[class foo { method bar { my $!baz = 'lorem'; say $!baz; }; };]; say $!.WHAT

[13:54] <p6eval> rakudo 9719f7: OUTPUT«Exception()␤»

[13:54] <jnthn> niecza?! :)

[13:55] <moritz> fasad: much of rakudo's code is written in nqp

[13:55] <jnthn> [Coke]: What ticket are you looking at for the my $!x decl, ooc?

[13:55] <[Coke]> 69230

[13:55] <[Coke]> looks closable now.

[13:55] <[Coke]> (no longer silently fails in some cases.)

[13:56] <fasad> moritz: nqp is a compiler or a language?

[13:56] <moritz> fasad: nqp is a compiler for a subset of Perl 6 (and in that subset, much of rakudo is written)

[13:56] <jnthn> [Coke]: Sounds good. I think Rakudo's response there is fine.

[13:58] <[Coke]> std: std: 555 ~~!~~ 666

[13:58] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/sSDQhqr_KH line 1:␤------> std: 555 ~~!~~⏏ 666␤Parse failed␤FAILED 00:01 109m␤»…

[13:59] <[Coke]> std: 555 ~~!~~ 666

[13:59] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Expecting a term, but found either infix ~~ or redundant prefix ~␤  (to suppress this message, please use space between ~ ~) at /tmp/lT9_wQlZ86 line 1:␤------> 555 ~~!~~⏏ 666␤Parse failed␤FAILED 00:01 109m␤»…

[13:59] <[Coke]> rakudo: 555 ~~!~~ 666

[13:59] <p6eval> rakudo 9719f7:  ( no output )

[13:59] <fasad> moritz: oh, so nqp implemented some of Perl 6 features and using that primitive/incomplete set of features much of rakudo is written. correct?

[13:59] <[Coke]> (RT#76436)

[13:59] <jnthn> fasad: Yes

[13:59] <jnthn> fasad: Also, nqp is bootstrapped, which means it is written in itself and can compile itself.

[14:00] <[Coke]> rakudo: use Test; eval_lives_ok '1<&1'

[14:00] <p6eval> rakudo 9719f7: OUTPUT«(timeout)»

[14:00] * fasad thinks of oroboros

[14:00] <[Coke]> O_o

[14:01] <moritz> fasad: most C compilers are also written in C

[14:01] <PerlJam> fasad: this is perl, not python  ;)

[14:02] <fasad> PerlJam: sorry i'm not familiar with the python compiler

[14:02] <[Coke]> nom: https://gist.github.com/1704540

[14:02] <p6eval> nom 068329: OUTPUT«===SORRY!===␤Confused␤at /tmp/yOdOLj5os1:1␤»

[14:03] <moritz> [Coke]: looks like a newline slipped in so that line 4 isn't a comment

[14:03] <[Coke]> nom: https://gist.github.com/1704540

[14:03] <p6eval> nom 068329: OUTPUT«Not enough positional parameters passed; got 0 but expected at least 1 in sub-signature of parameter @x␤  in sub infix:<merge> at /tmp/mYJTOtWcrz:1␤  in block <anon> at /tmp/mYJTOtWcrz:7␤  in <anon> at /tmp/mYJTOtWcrz:1␤»

[14:03] <moritz> probably want $x? and $y? in the signature

[14:04] <fasad> PerlJam: what's unique about python compiler?

[14:04] <fasad> *s/unique/different/

[14:04] <[Coke]> rakudo: END { say "OH HAI" }; die "oh noes"

[14:04] <p6eval> rakudo 068329: OUTPUT«oh noes␤  in block <anon> at /tmp/KMF2Dt0ZAK:1␤  in <anon> at /tmp/KMF2Dt0ZAK:1␤»

[14:04] <dalek> roast: 31654a6 | moritz++ | S03-junctions/misc.t:

[14:04] <dalek> roast: RT #109188, junctions with the List type object

[14:04] <dalek> roast: review: https://github.com/perl6/roast/commit/31654a63ce

[14:04] <dalek> roast: 2002a2f | moritz++ | S32-exceptions/misc.t:

[14:04] <dalek> roast: more typed exceptions

[14:04] <dalek> roast: review: https://github.com/perl6/roast/commit/2002a2fe77

[14:04] <PerlJam> fasad: sorry, that was meant as humor.  oroboros is a serpent eating its own tail.  a python is a serpent. etc.

[14:04] <[Coke]> moritz: that's for TimToady's script in RT#77474

[14:05] <[Coke]> (the gist)

[14:05] <fasad> Perljam: oh!

[14:05] <masak> PerlJam: oh!

[14:05] * fasad is a flickering tubelight

[14:05] <masak> henceforth, explain all obscure jokes :)

[14:05] <[Coke]> rakudo: END { say "OH HAI" }; die "oh noes"

[14:05] <p6eval> rakudo 068329: OUTPUT«oh noes␤  in block <anon> at /tmp/iy3m4BMs6U:1␤  in <anon> at /tmp/iy3m4BMs6U:1␤»

[14:05] <[Coke]> argh.

[14:05] <PerlJam> I didn't realize it was that obscure :)

[14:05] <masak> niecza: END { say "OH HAI" }; die "oh noes"

[14:05] <p6eval> niecza v13-381-g4158fa9: OUTPUT«Unhandled exception: oh noes␤  at /home/p6eval/niecza/lib/CORE.setting line 1347 (die @ 3) ␤  at /tmp/2tAsrBgd0z line 1 (mainline @ 2) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3609 (ANON @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3610 (mo…

[14:06] <[Coke]> rakudo: say ( { 1 + 1 }, { 2 + 2 } ).>>.() ; # RT#77670

[14:06] <p6eval> rakudo 068329: OUTPUT«===SORRY!===␤Confused␤at /tmp/SoxLivAO_Z:1␤»

[14:06] <[Coke]> rakudo: my %h; %h<a> = 3; %h.nonexist

[14:06] <p6eval> rakudo 068329: OUTPUT«Method 'nonexist' not found for invocant of class 'Hash'␤  in block <anon> at /tmp/Eaa4YvK50_:1␤  in <anon> at /tmp/Eaa4YvK50_:1␤»

[14:07] <jnthn> rakudo: say ( { 1 + 1 }, { 2 + 2 } )>>.()

[14:07] <p6eval> rakudo 068329: OUTPUT«2 4␤»

[14:07] <jnthn> std: say ( { 1 + 1 }, { 2 + 2 } )>>.()

[14:07] <p6eval> std 48335fc: OUTPUT«ok 00:01 111m␤»

[14:07] <jnthn> std: say ( { 1 + 1 }, { 2 + 2 } ).>>.()

[14:07] <p6eval> std 48335fc: OUTPUT«ok 00:01 111m␤»

[14:07] <moritz> nom: https://gist.github.com/1704555

[14:07] <p6eval> nom 068329: OUTPUT«===SORRY!===␤Variable @y is not predeclared at line 2, near " };\nmulti "␤»

[14:08] <moritz> nom: https://gist.github.com/1704555

[14:08] <p6eval> nom 068329: OUTPUT«Ambiguous dispatch to multi 'infix:<merge>'. Ambiguous candidates had signatures:␤:(, @y)␤:(@x, )␤␤  in block <anon> at /tmp/73ZfGPG0we:9␤  in <anon> at /tmp/73ZfGPG0we:1␤»

[14:08] <fasad> i have rakudo installed, so do i need to clone nqp too for my task & if yes, will it interfere with my rakudo installation ?

[14:08] <[Coke]> jnthn: does your recent work make https://rt.perl.org/rt3/Ticket/Display.html?id=62244 closable?

[14:08] <moritz> fasad: how did you install rakudo? via the git repo?

[14:09] <fasad> moritz: yes. i have full rakudo source code.

[14:09] <moritz> fasad: then you already have a copy of nqp in the nqp/ dir

[14:09] <moritz> fasad: cd nqp; git checkout master; git pull # now you're ready for hacking

[14:09] <moritz> nom: https://gist.github.com/1704555

[14:10] <p6eval> nom 068329: OUTPUT«1␤»

[14:10] <jnthn> [Coke]: It's obsolete. The way we do NCI has changed, the way we do namespaces has changed, etc.

[14:10] <jnthn> [Coke]: Mention Zavolaj in the closing message, perhaps.

[14:10] <jnthn> "We have working NCI now, see ..."

[14:12] <[Coke]> is zavolaj shipped with star?

[14:13] <moritz> star: use NativeCall;

[14:13] <p6eval> star 2012.01:  ( no output )

[14:13] <jnthn> [Coke]: yes

[14:13] <moritz> yes!

[14:14] <moritz> [Coke]: I've responded to the hamming ticket

[14:15] <jnthn> star: use NativeCall; sub fork() returns Int is native() { * }; say fork();

[14:15] <p6eval> star 2012.01: OUTPUT«0␤29346␤»

[14:15] <fasad> moritz: so i have made the necesarry changes to the code. obviously i need to recompile rakudo with 'make install', right ?

[14:15] <moritz> fasad: well, first you recompile nqp

[14:16] <moritz> fasad: run 'make'

[14:16] <moritz> in the nqp dir

[14:16] <[Coke]> moritz++ jnthn++

[14:16] <jnthn> 'make install' in nqp dir

[14:16] <masak> the new Hamming code... outputs '1'?

[14:16] <PerlJam> jnthn: did you just show how to fork bomb the bot?

[14:16] <masak> that can't be right :)

[14:16] *** kaleem joined
[14:16] <moritz> PerlJam: no, it was not a loop

[14:16] <jnthn> PerlJam: No, that'd be like

[14:17] <[Coke]> I suspect we have to harden safe with NativeCall in place. :P

[14:17] <PerlJam> moritz: that exercise is trivial :)

[14:17] <PerlJam> [Coke]: indeed

[14:17] <jnthn> stаr: use NativeCall; sub fork() returns Int is native() { * }; say fork() while 1;

[14:17] <[Coke]> b: say 666-103; #rt

[14:17] <p6eval> b 1b7dd1: OUTPUT«563␤»

[14:17] <jnthn> ;-)

[14:18] <dalek> roast: b09f2a9 | moritz++ | S05-metasyntax/angle-brackets.t:

[14:18] <dalek> roast: fix and unfudge RT #64464 tests

[14:18] <dalek> roast: review: https://github.com/perl6/roast/commit/b09f2a9f51

[14:19] <jnthn> .oO( oh fork() :-) )

[14:19] <moritz> nom: say 'alive'

[14:19] <p6eval> nom 068329: OUTPUT«alive␤»

[14:19] <jnthn> .u stаr

[14:19] <phenny> jnthn: U+0073 U+0074 U+0430 U+0072

[14:19] <jnthn> ;-)

[14:19] <[Coke]> nom: our Str a

[14:20] <p6eval> nom 068329: OUTPUT«===SORRY!===␤In "our" declaration, typename Str must be predeclared (or marked as declarative with :: prefix) at line 1, near " a"␤»

[14:20] <masak> std: our Str a

[14:20] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Multiple prefix constraints not yet supported at /tmp/z5kimkhvrl line 1:␤------> our Str ⏏a␤Malformed our at /tmp/z5kimkhvrl line 1:␤------> our Str ⏏a␤    expecting any of:␤ multi_declarator␤       typen…

[14:20] <[Coke]> RT #76830

[14:22] <fasad> moritz: nqp 'make' & 'make install' done. next?

[14:23] <moritz> fasad: run ./nqp -h

[14:23] <moritz> fasad: see if that works

[14:23] <moritz> fasad: if it does, go back to the rakudo dir, and run   perl Configure.pl && make

[14:27] *** Yary_ joined
[14:27] <moritz> nom: class A { my $!foo }

[14:27] <p6eval> nom 068329: OUTPUT«===SORRY!===␤Cannot use ! twigil on my variable at line 1, near " }"␤»

[14:31] *** Yary left
[14:32] *** Yary_ is now known as Yary

[14:32] <masak> S12 has example uses of 'my' and the ! twigil.

[14:32] <masak> but you know that :)

[14:32] <moritz> std: my $!foo;

[14:32] <p6eval> std 48335fc: OUTPUT«ok 00:01 108m␤»

[14:39] <moritz> fwiw I plan to test RT #69230 properly with a typed exception

[14:39] *** PacoAir joined
[14:42] *** Yary left
[14:46] <jnthn> masak: Oh, that role private attribute thingy?

[14:46] *** Yary joined
[14:47] <PerlJam> jnthn: class attrs too

[14:47] <jnthn> PerlJam: There's no such thing as class attrs.

[14:47] <jnthn> my $.x; # a lexical and an accessor

[14:47] <dalek> roast: 56d7207 | moritz++ | S12-enums/basic.t:

[14:48] <dalek> roast: RT #77982, spooky interactions between enums

[14:48] <dalek> roast: review: https://github.com/perl6/roast/commit/56d720774f

[14:48] <dalek> roast: 33e961e | moritz++ | S32-exceptions/misc.t:

[14:48] <dalek> roast: RT #69230, my $!foo

[14:48] <dalek> roast: review: https://github.com/perl6/roast/commit/33e961e492

[14:48] <masak> right.

[14:48] <masak> that's what I meant.

[14:48] <masak> no, wait.

[14:48] <jnthn> S12 may want some cleanup here

[14:48] <masak> the spec mentions 'my %!something' too.

[14:48] <jnthn> I mean, we *could* say that my $!x; is just a lexical.

[14:48] * masak looks

[14:48] <PerlJam> S12:776

[14:48] <moritz> but that would be very strange

[14:48] <jnthn> But, why? That screws up your ability to read code and know what the scope of a $!foo thingy is.

[14:48] <moritz> because the ! twigil means 'attribute'

[14:49] <jnthn> Right.

[14:49] <moritz> \o/ first RT closed that is tested by typed exceptions

[14:49] <jnthn> nah, "my $!foo" just makes no sense to me.

[14:49] <masak> I can sort of see the symmetry in it.

[14:49] <flussence> .oO( heh... calling fork() in a repl has some amusing side effects )

[14:49] <masak> you can do 'has $looknotwigil' too.

[14:49] <moritz> no reason to mess it up even further

[14:50] <fasad> moritz: perl Configure.pl && make done. next 'make install' ?

[14:50] <jnthn> masak: Yeah, I'm not entirely fond of that either, but can live with "sigilless = you figure it out, dear compiler"

[14:50] <jnthn> er

[14:50] <jnthn> twigilless

[14:51] <masak> moritz: there will be people who think "class attribute" and expect "my $!twigilmeansnothing" to work.

[14:51] <PerlJam> masak: only if we prime them to expect that

[14:52] <moritz> masak: that's why we'll have a good error message for them

[14:52] <PerlJam> moritz: so ... what's the answer to "class attributes"?  :)

[14:52] <PerlJam> an ordinary lexical?

[14:53] <moritz> I think so

[14:53] <PerlJam> do they have to create the accessor?

[14:53] *** Yary left
[14:53] <masak> yes, an ordinary lexical.

[14:53] <masak> 'my @.classattr' creates the accessor.

[14:53] <masak> it's because we allow the dot that allowing the bang makes sense.

[14:53] *** am0c joined
[14:53] <masak> it's just filling out the table with sensible defaults.

[14:54] <masak> I oppose changing the status quo.

[14:54] <moritz> well

[14:54] <moritz> let's look at what the twigil mean:

[14:54] <jnthn> masak: The status quo is an error saying don't do that. :)

[14:54] <moritz> .  make me an accessor

[14:54] <moritz> !   attribute

[14:55] <moritz> (no twigil)   let the compiler figure it out

[14:55] <moritz> from that table, I don't see how 'my $.foo' implies we should allow 'my $!foo'

[14:56] <dalek> roast: 15c94ed | moritz++ | S12-attributes/instance.t:

[14:56] <dalek> roast: RT #108670, accessor name clash

[14:56] <dalek> roast: review: https://github.com/perl6/roast/commit/15c94edf2b

[14:56] <dalek> rakudo/nom: 5fcfed5 | moritz++ | src/Perl6/Actions.pm:

[14:56] <dalek> rakudo/nom: fix thinko

[14:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/5fcfed5474

[14:56] <dalek> rakudo/nom: cb00ad1 | moritz++ | src/ (2 files):

[14:56] <dalek> rakudo/nom: typed exceptions for "my $!foo"

[14:56] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/cb00ad1de4

[14:56] <masak> it's because you made the table up as you think it is, not how I see it :)

[14:56] <masak> .  make me an accessor

[14:56] <masak> !  no accessor

[14:57] <masak> (no twigil)  I don't know or don't care about attributes

[14:58] <moritz> my $x; # no accessor either

[14:58] <moritz> class A { has $.x; method foo() { $!x # look, I can use that, even though it means "no accessor", and we have an accessor

[14:58] <fasad> moritz: 'perl6 -h' now works for me. next?

[14:58] <moritz> fasad: go back to nqp, and commit your changes

[14:59] <moritz> git add src/HLL/Compiler.pm

[14:59] <moritz> git commit -m 'fix -h option'

[14:59] <moritz> fasad: and tell me your github ID

[15:00] <fasad> moritz: Siddhant

[15:00] <fasad> ^my github ID

[15:00] *** icwiener left
[15:00] <moritz> fasad: you now have commit access

[15:01] <moritz> so once you've committed your stuff, do a   git push

[15:02] <masak> moritz: sure, it means "no accessor" if you did "has $foo". if you did "my $foo" it even means "no attribute" :)

[15:02] <fasad> moritz: from the rakudo dir or nqp ?

[15:02] <moritz> fasad: nqp

[15:03] <moritz> masak: well, if, you think '! means attribute', you don't have to do that distinction in the first place

[15:03] <moritz> masak: ie it gives you a more consistent picture which doesn't need further distinctinos

[15:03] <PerlJam> And if you guys can't agree on how to think about it, imagine the newbie Perl 6 programmer's quandry!  

[15:03] <moritz> now apply ocaml's razor... erm, whatever it's called... :-)

[15:04] <moritz> PerlJam: well, she'll read the version of whoever last edited the UP6 chapter :-)

[15:04] <PerlJam> heh

[15:05] <fasad> moritz: i get "fatal: remote error:    You can't push to git://github.com/perl6/nqp.git   Use [email@hidden.address]
[15:05] <moritz> fasad: then edit the .git/config files, substituting git://github.com/perl6/nqp.git by [email@hidden.address]
[15:07] <moritz> fasad: and then try again to git push

[15:07] <masak> PerlJam: moritz argues out of orthogonality. I'm arguing out of DWIM.

[15:08] <masak> PerlJam: there's not really a right or wrong here. just whether to be strict or permissive.

[15:08] <moritz> well, not just orthogonality, but also readability

[15:08] <flussence> `git remote set-url --push origin [email@hidden.address] should work too

[15:08] <moritz> ie if you can safely make the connection ! => attribute

[15:09] <masak> people who think they'll get class attributes can still do that.

[15:09] <masak> I don't see the problem.

[15:09] *** birdwindupbird left
[15:09] <moritz> or   git config remote.origin.pushurl [email@hidden.address]
[15:09] <masak> people who know that class attributes don't exist will be surprised the variable is shared between instances, but if they're surprised at that, they haven't understood the class anyway.

[15:10] <masak> and will need to read source anyway.

[15:10] <PerlJam> in any case, the spec needs updating I think.

[15:12] <masak> I agree it's not clear enough.

[15:13] <masak> moritz: the 'safely make the connection ! => attribute' argument would be much stronger if it weren't for 'has $sans_twigil'

[15:14] <moritz> masak: no, that only influences the opposite direction

[15:14] <moritz> but I won't shed a tear if we'd abolish that one too

[15:14] *** phenny left
[15:14] <PerlJam> me either

[15:15] <masak> I'm fine with shedding both, yes.

[15:15] <masak> but I'm not sure everyone is.

[15:15] *** kaare_ joined
[15:16] *** phenny joined
[15:16] <fasad> moritz: on 'git push' i'm getting 'Permission denied (publickey).'

[15:16] <jnthn> A case for has $sans_twigil; is that iirc the Perl 5 MOP work will have things that look that way

[15:16] <moritz> fasad: have you told github about your public ssh key?

[15:17] <PerlJam> jnthn: sounds weak

[15:17] <PerlJam> (this is Perl *6* after all  ;)

[15:17] <masak> fasad: http://help.github.com/linux-set-up-git/

[15:17] <jnthn> PerlJam: Yeah, it's not a strong argument, just an existing one :)

[15:18] <masak> another case for 'has $sans_twigil': some people hate twigils.

[15:18] * [Coke] brings up perl6.org in IE5.5

[15:18] <masak> this will be a kind of safety valve for them.

[15:22] <dalek> roast: 5514f34 | moritz++ | S04-statements/given.t:

[15:22] <dalek> roast: RT #99912, regex in when-block failed to set $/

[15:22] <dalek> roast: review: https://github.com/perl6/roast/commit/5514f34135

[15:22] <moritz> that kinda fails to impress me too

[15:22] <moritz> we don't have a safety valve for those who hate curlies

[15:23] <moritz> and it's much harder to program in Perl 6 without curlies than without private attributes :-)

[15:25] *** baest joined
[15:27] <masak> if everyone else is fine with removing all('has $sans_twigil', 'my $!fake_twigil'), I am too.

[15:27] <masak> but not just one of them.

[15:27] *** pothos left
[15:27] <moritz> +2 then :-)

[15:27] <moritz> erm, -2

[15:27] <moritz> you know what I mean :-)

[15:27] *** pothos joined
[15:28] <masak> :P

[15:30] <dalek> roast: c0c67ef | moritz++ | S02-literals/misc-interpolation.t:

[15:30] <dalek> roast: RT #104594, lexicals in blocks in double-quoted strings

[15:30] <dalek> roast: review: https://github.com/perl6/roast/commit/c0c67ef9c9

[15:30] <dalek> nqp: e6c8684 | (Siddhant Saraf)++ | src/HLL/Compiler.pm:

[15:30] <dalek> nqp: fix -h short form of --help

[15:30] <dalek> nqp: review: https://github.com/perl6/nqp/commit/e6c86844d4

[15:31] <moritz> fasad++

[15:31] <moritz> down to 97 testneeded tickets

[15:31] <masak> fasad++

[15:32] <fasad> * pops open a champagne and pours out to everyone in #perl6

[15:32] <fasad> Cheers !

[15:32] <felher> If i want to specify: 'everything that is matched by <all-words> but not by <bad-words>', is "regex good-words { <!bad-words> <all-words>" in a

[15:32] * fasad pops open a champagne and pours out to everyone in #perl6

[15:32] <felher> * the way to go?

[15:32] <masak> er.

[15:33] <masak> could you repeat that so that it makes sense? :)

[15:33] <felher> If i want to specify: 'everything that is matched by <all-words> but not by <bad-words>', is "regex good-words { <!bad-words> <all-words> 

[15:33] <felher> Damn it.

[15:33] * felher brb

[15:33] <masak> felher: it sounds like you need a negative lookahead or something.

[15:34] <masak> or maybe '$string ~~ /<@good-words>/ && $string !~~ /<@bad-words>/'

[15:34] <moritz> <!bad-words> is a negative look-ahead

[15:34] <jnthn> fasad++ # contributing to Rakudo :)

[15:35] * felher is back with a new x-server.

[15:35] <felher> moritz,masak: thnx. so if i need a negative-lookahead and <!bad-words> is one, i'll use that :)

[15:36] <masak> <!before <bad-words>> is another.

[15:36] <masak> I'm not really sure what the difference is.

[15:36] <jnthn> The latter burns more CPU cycles :P

[15:36] <fasad> jnthn: :) this was my first ever code contribution to any open source project. Which was your first?

[15:36] <moritz> felher: but what you want often has many nasty edge cases, dependent on what exactly you want

[15:36] <jnthn> fasad: Fixing some Win32 build bug in Parrot, I think. :)

[15:37] <moritz> for example you should anchor stuff with word boundary

[15:38] <felher> moritz: yep, thnx :)

[15:38] <fasad> moritz, masak: what was your first code contribution ever to an open source project ?

[15:38] <fasad> *were

[15:40] <masak> hm, good question.

[15:40] <masak> might've been to Pugs, actually. but I'm not 100% sure.

[15:40] <moritz> fasad: I'm not sure I remember. Either some p5 module, or pugs docs

[15:41] <moritz> oh wait, code. then probably test cases for complex numbers for pugs

[15:41] * fasad will always remember

[15:43] <masak> moritz: I thought your first contribution was some web page fix.

[15:44] <masak> to the Pugs project, I mean.

[15:44] <masak> wasn't that why you got a commitbit?

[15:44] <moritz> masak: I just mentioned that a link was broken, but I didn't fix it

[15:44] <masak> oh!

[15:44] <flussence> come to think of it, perl6 is the first thing I remember contributing code for too...

[15:45] <fasad> :)

[15:45] <moritz> around that time I also fixed some code in igal (a html gallery generator written in perl), and some stuff in a syntax hilighter

[15:45] <moritz> can't say for sure which one was first

[15:47] *** wtw left
[15:48] * fasad is reading Bootstrapping (compiler) on Wikipedia & trying to wrap his head around the concept :)

[15:49] <masak> fasad: it's not so tricky. you write the compiler in such a way that it can compile its own source code.

[15:49] <masak> first you compile it with something else. then you compile it with itself.

[15:49] <masak> that's all, really.

[15:51] <fasad> yeah, but the first time you read it ... :)

[15:53] <fasad> but then you realize that that you were taught English in English, & things start making sense

[15:54] <moritz> that's a nice way to look at it.

[15:54] <masak> yeah. it's a good thing brains are better at filling in the blanks than programs :)

[15:59] *** skids joined
[16:01] *** lrnperl6 joined
[16:02] <fasad> so http://en.wikipedia.org/wiki/Bootstrapping_(compilers)#List_of_self-hosting_compilers does not list perl 6. Should it?

[16:03] <masak> Perl 6 is not a compiler.

[16:03] <masak> it's a language specification.

[16:03] <jnthn> decommute &

[16:04] <masak> I guess both Rakudo and Niecza can be said to be partly self-hosting, but not fully.

[16:04] <masak> well, maybe Niecza is at this point.

[16:05] <moritz> nqp is self-hosting

[16:06] <fasad> actually the heading is a bt misleading, it should be 'List of >programming languages having< self-hosting compilers'

[16:06] <fasad> ^^based on the content of the section

[16:07] <PerlJam> "Languages that have self-hosting compilers"  sure sounds like Perl 6 should be on that list

[16:07] *** am0c left
[16:07] <PerlJam> fasad: but, yeah, the title is all off

[16:08] * fasad is now fixing the wikipedia article

[16:10] *** GlitchMr joined
[16:11] *** MayDaniel joined
[16:12] <fasad> is perl 5 also self-hosting? #cause i've heard 'only perl can parse perl'

[16:12] <fasad> scratch that. perl's compiler is written in C, IIRC

[16:13] *** spine joined
[16:13] <arnsholt>  The Perl 5 compiler is written in C, yes

[16:13] *** nsh left
[16:14] <arnsholt> "Only perl can parse Perl" means that only perl (the program) can parse Perl (the language)

[16:14] <arnsholt> (Which is accomplished by deep magical sorcery, if you wondered =)

[16:15] <PerlJam> though the magic has been bubbling closer to the surface lately.

[16:16] * skids wonders as to the meaning of "as" trait on a parameter as used in Rakudo src/core.  Can't find "as" in spec except as a sub trait for inner return type specifier.

[16:16] *** MayDaniel left
[16:17] <masak> Perl 6 is all about building the awesomeness from the ground up and then making it perform. Perl 5 is all about condensing the awesomeness from Unix mythology and then trying to make it extensible and less magical while not breaking backwards compatibility. :)

[16:18] <masak> skids: "as" was de-spec'd and replaced by constructs such as Int(Any)

[16:18] <flussence> "as" is gone? when'd that happen?

[16:19] <flussence> (is it the as I'm thinking of?)

[16:19] <masak> what "as" are you thinking of? :)

[16:20] <flussence> the one in function signatures...

[16:20] <skids> masak: just the answer I was hoping for, since I was missing the Int(Num) feature... so I can use that until things congeal.  masak++

[16:20] <flussence> ah, that one's still there.

[16:21] <flussence> I think :/

[16:22] <skids> "sub A () as Int" is still there.

[16:22] <flussence> yeah, I can find that one... can't find "sub A ($a as Int)"

[16:23] <masak> hm, yes. maybe "as" survives for return casting.

[16:24] *** lrnperl6 left
[16:25] *** kaleem left
[16:26] <skids> That would apparently now be "sub A (Mu(Int) $a)" or somesuch.  Though I'm not quite sure what Mu(Int) would acheive where Int(Mu) makes sense to me.

[16:27] <flussence> std: sub A(Int(Str) $b) { ... }

[16:27] <p6eval> std 48335fc: OUTPUT«Potential difficulties:␤  $b is declared but not used at /tmp/g21e5TUidb line 1:␤------> sub A(Int(Str) ⏏$b) { ... }␤ok 00:01 111m␤»

[16:28] <flussence> perl6: sub A(Int(Str) $b) { say $b.WHAT }; A(1); A("1");

[16:28] <p6eval> niecza v13-381-g4158fa9: OUTPUT«Int()␤Unhandled exception: Nominal type check failed in binding $b in A; got Str, needed Int␤  at /tmp/9me2s0mHyg line 0 (A @ 1) ␤  at /tmp/9me2s0mHyg line 1 (mainline @ 3) ␤  at /home/p6eval/niecza/lib/CORE.setting line 3609 (ANON @ 3) ␤  at /home/p6eval…

[16:28] <p6eval> ..pugs b927740: OUTPUT«*** ␤    Unexpected "Int"␤    expecting word character, "|", ":", "*", parameter name or ")"␤    at /tmp/5yh5OIv89L line 1, column 7␤»

[16:28] <p6eval> ..rakudo cb00ad: OUTPUT«===SORRY!===␤Malformed block at line 1, near "(Int(Str) "␤»

[16:29] <flussence> niecza's doing *something*, but I'm not sure what.

[16:30] *** DarthGandalf left
[16:34] *** DarthGandalf joined
[16:47] *** fasad_ joined
[16:47] *** fasad left
[16:48] <TimToady> perl6: my @elems = <1 2 3 1>; say @elems == set @elems;

[16:48] <p6eval> rakudo cb00ad: OUTPUT«===SORRY!===␤CHECK FAILED:␤Undefined routine '&set' called (line 1)␤»

[16:48] <p6eval> ..pugs b927740: OUTPUT«*** No such subroutine: "&set"␤    at /tmp/smunr20Bbi line 1, column 28-48␤»

[16:48] <p6eval> ..niecza v13-381-g4158fa9: OUTPUT«Bool::False␤»

[16:49] <TimToady> niecza++

[16:49] <TimToady> niecza: my @elems = <1 2 3 1>; say @elems == set @elems;

[16:49] <p6eval> niecza v13-381-g4158fa9: OUTPUT«Bool::False␤»

[16:49] <TimToady> niecza: my @elems = <1 2 3 4>; say @elems == set @elems;

[16:49] <p6eval> niecza v13-381-g4158fa9: OUTPUT«Bool::True␤»

[16:49] <TimToady> just checking :)

[16:50] * eviltwin_b was just wondering about that :)

[16:51] <TimToady> anyway, that's likely to be faster than almost anything else

[16:52] *** mj41 left
[16:56] <ashleydev> TimToady: why faster?

[16:58] <TimToady> only constructs one object, which is really a hash

[16:58] <TimToady> and only uses it for its size

[16:59] <TimToady> at least, it's likely to be faster when set operations optimize away all the => True bits

[16:59] <sorear> good * #perl6

[17:00] <TimToady> howdy

[17:00] <masak> sorear! \o/

[17:01] <TimToady> I'm getting really tired of seeing things like all(one(Bool::False, Bool::False, Bool::True))

[17:01] <TimToady> I'm not sure .gist should add the Bool

[17:01] <TimToady> after all, you'd think the "gist" would be shorter

[17:02] <jnthn> nom: say True

[17:02] <p6eval> nom cb00ad: OUTPUT«Bool::True␤»

[17:02] <TimToady> instead it *adds* meta info

[17:02] <jnthn> Hm, should be trivial to fix.

[17:02] <TimToady> nom: print True,"

[17:02] <p6eval> nom cb00ad: OUTPUT«===SORRY!===␤Confused␤at /tmp/aJ1ejYtB4P:1␤»

[17:02] <moritz> nom: say ~True

[17:02] <TimToady> nom: print True,"\n";

[17:02] <p6eval> nom cb00ad: OUTPUT«True␤»

[17:02] <TimToady> nom: print True.perl

[17:02] <p6eval> nom cb00ad: OUTPUT«Bool::True»

[17:02] <TimToady> I think maybe only that one should add the type

[17:03] <TimToady> it's a lot easier to understand all(one(False, False, True))

[17:03] <sorear> TimToady: http://pastie.org/3283332 ?

[17:04] <jnthn> TimToady: Will make it happen.

[17:04] <TimToady> yes, that's what I am proposing

[17:04] <sorear> shall I commit?

[17:04] <sorear> or are you about to

[17:05] <TimToady> お願いします！

[17:05] * masak decommutes

[17:07] <sorear> dalek?

[17:08] <[Coke]> nom: say (22-1)/4 ; # averge numbers of submissions per not-me.

[17:08] <TimToady> had a long weekend, apparently

[17:08] <p6eval> nom cb00ad: OUTPUT«5.25␤»

[17:08] <sorear> I guess maybe it's blocking on email

[17:08] <[Coke]> O_o

[17:09] <jnthn> > say all(one(True, False), True)

[17:09] <jnthn> all(one(True, False), True)

[17:09] <jnthn> :)

[17:09] *** wolfman2000 left
[17:09] <TimToady> \o/

[17:09] <TimToady> sometimes we are very slow to see the obvious...

[17:10] <[Coke]> nom: next say all for one time

[17:10] <p6eval> nom cb00ad: OUTPUT«all()␤»

[17:11] <TimToady> nom: next

[17:11] <p6eval> nom cb00ad: OUTPUT«next without loop construct␤  in block <anon> at /tmp/5NnTtLEWFM:1␤  in <anon> at /tmp/5NnTtLEWFM:1␤»

[17:11] *** fasad_ is now known as fasad

[17:11] <TimToady> how does that not get the error in yours?

[17:11] <TimToady> oh, there's a for, duh

[17:12] <TimToady> for one time { say Cool }

[17:12] <TimToady> perl6: for one time { say Cool }

[17:12] <p6eval> pugs b927740: OUTPUT«*** No such subroutine: "&Cool"␤    at /tmp/2K8M7nvC6J line 1, column 20-25␤»

[17:12] <p6eval> ..rakudo cb00ad, niecza v13-381-g4158fa9: OUTPUT«Cool()␤»

[17:13] <TimToady> we now have an official one-time loop :)

[17:14] <TimToady> [Coke]++

[17:14] * jnthn gently pokes at dalek

[17:14] <dalek> specs: f4488b0 | sorear++ | S12-objects.pod:

[17:14] <dalek> specs: Change .gist on enums to not include the type

[17:14] <dalek> specs: 

[17:14] <dalek> specs: Because .gist should be shorter, and the types are rarely needed.  .perl

[17:14] <dalek> specs: stays as is, for disambiguation.

[17:14] <dalek> specs: review: https://github.com/perl6/specs/commit/f4488b01c1

[17:15] *** colomon joined
[17:16] <felher> jnthn: Oh, now that i see you. Does nom do backtracking into subrules yet? :)

[17:17] <jnthn> felher: Yeah, I fixed that just before the last compiler release

[17:17] <jnthn> (So that compiler release has it, and the Star release from this weekend has it too)

[17:18] <[Coke]> nom: for all time { say Cool}

[17:18] <p6eval> nom cb00ad: OUTPUT«Cool()␤»

[17:18] <dalek> roast: 8d71270 | jnthn++ | S02-types/bool.t:

[17:18] <dalek> roast: Update Bool.gist tests.

[17:18] <dalek> roast: review: https://github.com/perl6/roast/commit/8d71270ba1

[17:18] <felher> jnthn++: Awesome! Thanks :)

[17:19] <dalek> rakudo/nom: 683a387 | jnthn++ | src/core/ (2 files):

[17:19] <dalek> rakudo/nom: Enumerations should .gist to just the key, not including the full package name.

[17:19] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/683a38759e

[17:22] *** daxim left
[17:27] *** timotimo left
[17:28] <colomon> sorear: ping?

[17:28] <[Coke]> ooh, nclark doing ticket triage on perl6.

[17:29] <sorear> colomon: pong

[17:29] <dalek> niecza: fb2bb1e | sorear++ | lib/CORE.setting:

[17:29] <dalek> niecza: Enumerations should .gist to just the key, not including the full package name.

[17:29] <dalek> niecza: review: https://github.com/sorear/niecza/commit/fb2bb1e509

[17:29] <sorear> Nicholas in #p5p -- funny he's not here

[17:31] <sorear> release day!

[17:33] <colomon> \o/

[17:35] * sorear will, ahem, cheat and run a spectest on the p6eval box

[17:35] <sorear> colomon: pong?

[17:35] <colomon> sorear: I've been messing about with KeySet while waiting for the doctor this morning.  I can see Hash is doing some sort of proxy thing, ideally I need to figure out how to overload it so that I can remove False things from the KeySet in an efficient fashion.

[17:36] *** kaleem joined
[17:38] <dalek> rakudo/nom: ef22e37 | jnthn++ | src/core/Str.pm:

[17:38] <dalek> rakudo/nom: Forbid :8(non-Str-here), as per spec.

[17:38] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ef22e37099

[17:39] * jnthn nudges testneeded back up by 1 again ;)

[17:39] <jnthn> Also found two tickets to close that were already fixed and tested. :)

[17:39] <jnthn> Guess I should get on with my slides for $dayjob-event now...

[17:40] <sorear> or maybe I'll use feather instead, seems to be faster

[17:46] *** Chillance joined
[17:49] <[Coke]> Juerd++ #feather

[17:50] <[Coke]> jnthn++ moritz++ queue attrition

[17:52] <Juerd> Also, feather as a secure sudo which is rare these days :)

[17:52] <[Coke]> nom: enum Boo <True False Meh>; say any(Bool::True,Boo::True)

[17:52] <p6eval> nom 683a38: OUTPUT«any(True, True)␤»

[17:52] <[Coke]> nom: enum Boo <True False Meh>; say any(Bool::True,Boo::True).perl

[17:52] <p6eval> nom 683a38: OUTPUT«any(Bool::True, Boo::True)␤»

[17:52] *** GlitchMr left
[17:58] *** dakkar left
[17:58] <[Coke]> that's ok für gist?

[17:59] <sorear> I think so

[17:59] *** alester joined
[18:00] <[Coke]> hokay.

[18:03] *** ksi joined
[18:10] *** icwiener joined
[18:12] <sorear> sweet, 'All tests successful'

[18:12] <sorear> *however* the bootstrap failed!

[18:12] <colomon> all tests successful here as well.  

[18:14] <[Coke]> sorear: OOC, did you run with TEST_JOBS=n ?

[18:15] *** supernovus joined
[18:22] <dalek> rakudo/nom: ce5ccae | moritz++ | tools/build/NQP_REVISION:

[18:22] <dalek> rakudo/nom: bump NQP revision to get option handling and charclass fixes

[18:22] <dalek> rakudo/nom: review: https://github.com/rakudo/rakudo/commit/ce5ccaeb7e

[18:23] <sorear> [Coke]: no

[18:24] <sorear> fff.  bootstrap is not cooperating at all

[18:24] <sorear> looks like I won't get to the release until tonight, if at all :|

[18:24] *** kmwallio joined
[18:25] <moritz> fwiw bumping the parrot revision seem to have helped with the setting build times

[18:25] <moritz> from ~16min down to about 4min for the .pm -> .pir step

[18:25] <moritz> which is closer to what I remember from a while go

[18:27] <tadzik> ooh

[18:27] <tadzik> what did Parrot do?

[18:28] *** pmurias joined
[18:28] <sorear> apparently I majorly broke something somewhere

[18:28] <sorear> pmurias!

[18:28] <pmurias> sorear: hi

[18:28] <phenny> pmurias: 28 Jan 00:07Z <colomon> tell pmurias https://gist.github.com/1691700 # p5test results

[18:29] <phenny> pmurias: 02:01Z <sorear> tell pmurias If you see this message before Monday, I'd like it if you could give a better description of your changes for announce.v14

[18:29] <pmurias> pmurias: re release annoucement, the description of changes is perfect

[18:30] <benabik> pmurias: Talking to yourself again? ;-)

[18:30] <pmurias> again?

[18:30] <pmurias> sorear: re release annoucement, the description of changes is perfect

[18:30] <supernovus> Guh, tracking down grammar related bugs can be a pain. :p

[18:31] <tadzik> do you know Grammar::Tracer yet? :)

[18:32] <pmurias> sorear: i'm currently studing for my (numerical analysis)-- exam, but i hope to get much more work done on the p5 interop after the exam

[18:32] <supernovus> Not yet. At this point, I'm willing to try anything. I just want to make Exemel work properly under nom. I don't remember having this many problems porting from alpha to ng, but given how long ago it was, I probably did ;-)

[18:32] <tadzik> :)

[18:34] <pmurias> sorear: did you read the use :from<perl5> messages?

[18:34] <supernovus> It can now parse <thing name="blah"/> just fine, and stores the attributes "name" => "blah". But if the element has content, such as <a href="woot">this</a> it parses it, but doesn't find the "href" => "woot" part.

[18:35] *** fasad left
[18:36] <[Coke]> supernovus: you have any WIP on a branch?

[18:36] <moritz> tadzik: re what did parrot do, either they unbroke some earlier breakage, or maybe it was just my installation that was somehow busted

[18:38] <supernovus> [Coke]: https://github.com/supernovus/exemel   the master branch has my latest tests, and includes all the stuff I've done so far to get it to work with nom.

[18:38] <[Coke]> how do you test it? just "prove t/"?

[18:39] <sorear> pmurias: yes

[18:39] <sorear> pmurias: I don't have a good answer

[18:39] <supernovus> [Coke]: the t/03-query.t is the file I'm currently playing with.

[18:40] <supernovus> [Coke]: and I don't expect it to pass at the moment even if the grammar bug is tracked down, as I added some extra stuff to t/query.xml to test the bug more. I may pull out the extra stuff so that the file is in a state where it should pass if all the bugs were fixed.

[18:41] *** tjrandall joined
[18:41] *** tjrandall left
[18:41] <pmurias> sorear: i'll propably try reimporting stuff from the module twice, as serializing arbitary perl5 modules seems too crazy

[18:42] <sorear> pmurias: I agree

[18:42] * sorear tries reverting the latest LTM changes

[18:42] <supernovus> there query.t is now in its proper state again

[18:42] <supernovus> err, query.xml

[18:45] <tadzik> btw, any comments on https://github.com/rakudo/rakudo/compare/nom...usage-prints-WHY ?

[18:46] <sorear> There is no way I am going to finish the release in the next ten minutes - tonight it is

[18:47] <[Coke]> nom: my %a = { $.idattr => 3 }; say %a.perl

[18:47] <p6eval> nom ef22e3: OUTPUT«Null PMC access in find_method('idattr')␤  in block <anon> at /tmp/nLqcRL3iFS:1␤  in <anon> at /tmp/nLqcRL3iFS:1␤»

[18:48] <[Coke]> masak, is there a ticket for that?

[18:49] *** estrabd joined
[18:49] *** estrabd left
[18:50] *** estrabd joined
[18:51] <masak> [Coke]: no.

[18:52] <[Coke]> enjoy. ;)

[18:52] <[Coke]> supernovus: you are returning False and then trying to use it as a list, I tihnk.

[18:53] <supernovus> [Coke]: I know that part. It should never get there. The test failing isn't the issue, the fact that the attributes are entirely missing is. :-)

[18:53] <[Coke]> do you have a smaller snippet than 03*.t that demonstrates the failure?

[18:54] <supernovus> Sure, I'll write a quick snippet that will show exactly what's wrong.

[18:54] <[Coke]> If nothing else, we got another RT out of it. :P

[18:54] <dalek> niecza: 74ba1ec | sorear++ | / (2 files):

[18:54] <dalek> niecza: Revert "Ignore arguments to rules for LTM purposes"

[18:54] <dalek> niecza: 

[18:54] <dalek> niecza: This reverts commit 6915253d906f76e33c0a292a3cb5129310da238e.

[18:54] <dalek> niecza: Seems to break the bootstrap and I don't have time to study why just yet.

[18:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/74ba1ecdaa

[18:54] <dalek> niecza: 852f0ff | sorear++ | lib/Cursor.cs:

[18:54] <dalek> niecza: Fix use of variables in propagation

[18:54] <dalek> niecza: review: https://github.com/sorear/niecza/commit/852f0ffa1e

[18:55] <sorear> bootstrap succeeded; will finish release in a few hours

[18:59] <supernovus> [Coke]: Okay, take a look at the newly added what-is-wrong.p6 in the main folder.

[19:02] <[Coke]> supernovus: https://gist.github.com/1705999

[19:03] <[Coke]> the only difference I see between the 2 lines is the <?xml> prefix.

[19:03] <supernovus> hmm, that's not the output I'm getting at all...

[19:03] <[Coke]> but the comment makes me think I should be seeing something else.

[19:04] <[Coke]> $ perl6 --version

[19:04] <[Coke]> This is perl6 version 2012.01-45-g9719f7d built on parrot 3.11.0 revision RELEASE_3_11_0

[19:04] <supernovus> This is perl6 version 2012.01-43-g396f827 built on parrot 3.11.0 revision RELEASE_3_11_0

[19:04] <supernovus> I will rebuild and see what happens.

[19:04] <[Coke]> looks like mine is slightly newer.

[19:05] <[Coke]> (mine's probably a day or 2 old at this point.)

[19:07] <supernovus> Rebuilding from git to see if that helps. I last rebuilt 2 days ago.

[19:08] * masak submits [Coke]'s rakudobug

[19:11] <masak> nom: my %a = { $.idattr => 3 }; say "alive"

[19:11] <p6eval> nom ce5cca: OUTPUT«Null PMC access in find_method('idattr')␤  in block <anon> at /tmp/TfNWmA8_Lz:1␤  in <anon> at /tmp/TfNWmA8_Lz:1␤»

[19:11] <masak> nom: class A { my %a = { $.idattr => 3 } }; say "alive"

[19:11] <p6eval> nom ce5cca: OUTPUT«Null PMC access in find_method('idattr')␤  in <anon> at /tmp/IjSkXH_snl:1␤  in block <anon> at /tmp/IjSkXH_snl:1␤  in <anon> at /tmp/IjSkXH_snl:1␤»

[19:11] <masak> nom: my %a = { self.idattr => 3 }; say "alive"

[19:11] <p6eval> nom ce5cca: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/g6qCPc4vDg:1)␤»

[19:11] <masak> nom: class A { my %a = { self.idattr => 3 } }; say "alive"

[19:11] <p6eval> nom ce5cca: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/XwlqA54gqp:1)␤»

[19:11] <masak> nom: class A { method foo { my %a = { self.idattr => 3 } } }; say "alive"

[19:11] <p6eval> nom ce5cca: OUTPUT«alive␤»

[19:12] <masak> nom: say "before"; my %a = { self.idattr => 3 }; say "alive"

[19:12] <p6eval> nom ce5cca: OUTPUT«===SORRY!===␤Symbol 'self' not predeclared in <anonymous> (/tmp/0Sw1hpQTdv:1)␤»

[19:12] <masak> nom: say "before"; my %a = { $.idattr => 3 }; say "alive"

[19:12] <p6eval> nom ce5cca: OUTPUT«before␤Null PMC access in find_method('idattr')␤  in block <anon> at /tmp/i4okZIdPp8:1␤  in <anon> at /tmp/i4okZIdPp8:1␤»

[19:14] <masak> nom: class A { has $.idattr; my %a = { $.idattr => 3 } }; say "alive"

[19:14] <p6eval> nom ce5cca: OUTPUT«Null PMC access in find_method('idattr')␤  in <anon> at /tmp/F_HeJ0RhYK:1␤  in block <anon> at /tmp/F_HeJ0RhYK:1␤  in <anon> at /tmp/F_HeJ0RhYK:1␤»

[19:14] <TimToady> 'my $!classattr' makes much more sense when you think about 'trusts' and private accessors

[19:15] <masak> ooh

[19:15] <moritz> so 'my' doesn't (just) declare a lexical in that case?

[19:16] <jnthn> masak: We must have a ticket for that $.a in a place it ain't meant to be issue.

[19:16] <TimToady> anything with ! also gets a private accessor (which is not called when you just say $!foo)

[19:16] <TimToady> the private accessor is only for trusts-style calls

[19:17] <jnthn> Oh, that idea lives on?

[19:17] * jnthn thought it'd been gotten rid of...

[19:18] <jnthn> That's mean that "has $!a; has @!a" is problematic as well as the . variants that we recently disallowed.

[19:18] <dalek> roast: 6cfc6bd | moritz++ | S12-class/stubs.t:

[19:18] <dalek> roast: test for stubbed-but-not-filled-in class

[19:18] <dalek> roast: review: https://github.com/perl6/roast/commit/6cfc6bd47f

[19:19] <TimToady> how are you implementing $obj!THAT::CLASS::a then?

[19:20] <jnthn> TimToady: I'm not at the moment; if you want such an accessor you have to explicitly declare it.

[19:20] <jnthn> TimToady: I'm still a little bothered about generating them all when they won't be used the majority of the time. I guess some lazy technique would do.

[19:20] <TimToady> they don't need to be autogenerated unless you trust someone

[19:20] <jnthn> True.

[19:21] <jnthn> TimToady: Would "has $!x" only generate an ro private accessor?

[19:21] <jnthn> TimToady: And "is rw" needed for a rw one?

[19:21] <jnthn> e.g. has $!x is rw;

[19:22] <TimToady> I suspect all private accesses are born lvalues

[19:22] <jnthn> Another option would be not to generate accessors methods, but instead to spot the lack of one at compilation time and just compile it down to an attribute access.

[19:22] <TimToady> otherwise we don't know the intended state of $!x when 'has $.x is rw'

[19:22] <TimToady> and it seems to me if you trust yourself to modify $!x, you trust others too

[19:23] <jnthn> That is, $x!Foo::Bar::a would first look for a private method 'a', and failing one of those being in the private methods table, it'd consider whether there's an attribute.

[19:23] <TimToady> yes, private access is just a sub call really, and can be inlined

[19:23] <jnthn> Yeah, we already optimize those somewhat in Rakudo

[19:23] <jnthn> We also detect missing privates at CHECK time

[19:24] <jnthn> I think

[19:24] * TimToady omits pun on Unix

[19:24] <jnthn> :P

[19:24] <TimToady> or were you speakiing of deserters?

[19:25] <jnthn> TimToady: Well, what I'm really getting at is, would we expect Foo.^methods(:private) to come back with a bunch of generated private accessors?

[19:25] <jnthn> If yes, that probably means they have to be generated up front. If not, we can play tricks more easily. :)

[19:25] <jnthn> Though of course meta-objects can lie as much as they want too :)

[19:26] <TimToady> ^methods could generate them lazily for all that :)

[19:26] * jnthn suspected that answer was coming... :)

[19:26] <moritz> (test plan)++ # caught my accidental use of say() instead of is()

[19:27] <dalek> roast: ecd8da2 | moritz++ | S02-types/hash.t:

[19:27] <dalek> roast: RT #77922, Hash.new

[19:27] <dalek> roast: review: https://github.com/perl6/roast/commit/ecd8da2c98

[19:27] <supernovus> Okay, now I am really confused. The output from [Coke]'s rakudo is entirely different than mine. I just used a fresh compile.  https://gist.github.com/1706138

[19:28] *** mdxi is now known as sboyette

[19:28] <[Coke]> supernovus: your updated sample doc works for me still.

[19:28] <[Coke]> supernovus: did you install rakudo?

[19:29] <supernovus> [Coke]: Yeah, it's installed.

[19:29] <[Coke]> I'm on feather, if that helps.

[19:29] <supernovus> $ perl6 --version This is perl6 version 2012.01-52-gce5ccae built on parrot 4.0.0 revision RELEASE_4_0_0-85-g8a1265a 

[19:29] <jnthn> Where's the code for what-is-wrong.p6?

[19:29] * jnthn can try it

[19:29] <supernovus> jnthn: https://github.com/supernovus/exemel  

[19:31] <supernovus> I am going to try it on another machine and see what happens.

[19:32] <TimToady> and if you guys think 'has $x' is so terrible, I can only imagine what you'll think of:

[19:32] <TimToady> std: class X { has \x = 42; method sayit { x.say } }

[19:32] <p6eval> std 48335fc: OUTPUT«ok 00:01 109m␤»

[19:32] <TimToady> :P

[19:33] <dalek> roast: bddc607 | moritz++ | S12-attributes/instance.t:

[19:33] <dalek> roast: RT #74274, sneaking in access to private attributes through the back door

[19:33] <dalek> roast: review: https://github.com/perl6/roast/commit/bddc607ede

[19:33] <moritz> masak: ^^ one of your favorite bugs being close right now.

[19:33] <[Coke]> TimToady: yah, I don't particularly like it. ;)

[19:33] *** birdwindupbird joined
[19:33] <TimToady> std: class X { has \x is public = 42; method sayit { x.say } }

[19:33] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Term definition requires an initializer at /tmp/VuUWfstGP8 line 1:␤------> class X { has \x ⏏is public = 42; method sayit { x.say } }␤Confused at /tmp/VuUWfstGP8 line 1:␤------> class X { has \x ⏏is pub…

[19:34] <TimToady> innersting

[19:34] *** Trashlord left
[19:34] <jnthn> supernovus: Here is output I get: https://gist.github.com/1706190

[19:36] <supernovus> jnthn: So yours is like mine, in that the attributes magically vanish.

[19:36] <jnthn> Yeah.

[19:37] * jnthn looks around for a pmichaud :)

[19:37] <supernovus> Okay, I'm using Debian sid on the current testing box (which is actually a 32 bit VM running on virtualbox). How about jnthn and [Coke] ?

[19:38] <jnthn> supernovus: It's certainly a bug.

[19:38] <jnthn> supernovus: If you change

[19:38] <jnthn> rule element {

[19:38] <jnthn> to

[19:38] <jnthn> regex element {

[19:38] <jnthn> Then it captures properly.

[19:38] * jnthn whines about the bstack cut logic

[19:39] <dalek> roast: ba5ee93 | moritz++ | S06-traits/is-copy.t:

[19:39] <dalek> roast: RT #82810, ||= on an "is copy" array parameter

[19:39] <dalek> roast: review: https://github.com/perl6/roast/commit/ba5ee931ef

[19:40] <supernovus> Interesting. I'll try that and see what happens. Still doesn't explain why the bug doesn't show up on [Coke]'s computer.

[19:40] <jnthn> supernovus: No, I'm confused about that too

[19:41] <TimToady> if the 'b' stands for backtracking, I'd point out that keeping backtracking info outside of cursors is fraught with peril; I much prefer the view that backtracking is simply throwing away unwanted cursors

[19:41] <jnthn> I'm running a 64-bit build on Windows

[19:42] <jnthn> TimToady: $!bstack is an attribute of Cursor, which contains marks. It works in conjunction with $!cstack, which is a stack of cursors, and those are thrown away during backtracking involving captures or subrules.

[19:42] <supernovus> 64-bit Windows and 32-bit Linux are both showing the same bug. I'm going to try running this on 64-bit Linux and see what that does.

[19:42] <[Coke]> if you're on feather, it's /home/coke/sandbox/perl6pass/rakudo/install/bin/perl6

[19:43] <[Coke]> (which is also a 32bit linux.)

[19:43] <jnthn> TimToady: Or so far as I understand the design, anyway. ;-)

[19:43] * [Coke] dunno what's up, either.

[19:44] *** GlitchMr joined
[19:44] <supernovus> I don't know if I still have a feather account, it's been three lifetimes and several iterations of rakudo since I last logged in there :-)

[19:44] *** twirp joined
[19:44] <TimToady> ah, in that case, I'd say the problem is that the stack of cursors is getting out of sync with your control flow somehow; in STD-based grammars, this is managed by using lexically scoped lazy lists, so when you exit a scope it automatically trims the lazy lists that need to go away, and leaves the rest

[19:45] <jnthn> TimToady: It's something along those lines. It basically throws away cursors that it should not.

[19:45] <TimToady> well, I'm just guessing ignorantly, so take with eighteen grains of salt

[19:45] <jnthn> :)

[19:46] <jnthn> Well, with a little luck pmichaud++ may have a tuit or two to look at in sometime soon :)

[19:46] <jnthn> *it

[19:46] *** Vlavv_ joined
[19:46] *** GlitchMr left
[19:47] <TimToady> basically, the "cut" in a STD engine is the difference between the lazy lists you throw away, and the lazy list you return

[19:47] <supernovus> Well, none of novus@feather, supernovus@feather or huri@feather work, so I'm assuming I don't have an account on there anymore.

[19:48] <TimToady> STD is basically emulating continuations with lazy lists of closures

[19:48] <masak> moritz: nice!

[19:49] *** Vlavv` left
[19:51] *** kaleem left
[19:52] *** pmurias_ joined
[19:52] <jnthn> TimToady: Ah, that makes sense.

[19:52] * [Coke] checks.

[19:52] <jnthn> OK, I really should stop peeking at that and do the $dayjob slides... :)

[19:52] <[Coke]> supernovus: yah, don't see those.

[19:53] *** pmurias left
[19:58] <supernovus> okay, changing "rule element" to "regex element" now has all the included tests passing. I can't guarantee it's perfect, as I'm sure the test coverage should be a heck of a lot more, but basic XML parsing, manipulation, querying and output is now ready for the newest rakudo :-)

[19:59] <masak> supernovus++

[20:06] <supernovus> There, I updated the "State of modules on nom" list to show Exemel as working again. Next up DateTime::Utils.

[20:06] <jnthn> supernovus++

[20:06] <moritz> supernovus++ indeed

[20:09] <[Coke]> supernovus++

[20:13] <dalek> roast: 4808a9d | moritz++ | S05-metasyntax/charset.t:

[20:13] <dalek> roast: RT #89470, char classes with exclusions

[20:13] <dalek> roast: review: https://github.com/perl6/roast/commit/4808a9d135

[20:16] <moritz> jnthn: when you have some spare tuits, it would be very helpful for me if you could implement named arguments in nqp regexes (<.typed_panic: 'X::Malformed', what => "Block">). My attempts to wire up <LANG('MAIN', 'arglist')> for that task have failed :/

[20:16] <tadzik> huh, nom compilation fails for me

[20:16] <tadzik> https://gist.github.com/1706413

[20:17] <moritz> tadzik: uhm

[20:17] *** birdwindupbird left
[20:17] <moritz> tadzik: SymbolTable has long been renamed to World

[20:18] <moritz> tadzik: something is very outdated in your nom (maybe the Makefile?)

[20:18] <jnthn> moritz: In NQP, right?

[20:18] * tadzik tries git clean -fdx

[20:18] <moritz> jnthn: yes

[20:18] <moritz> jnthn: I want to use it Grammar.pm

[20:19] <jnthn> nom: grammar G { rule x(:$y) { { say $y } '' }; rule TOP { <x(y => 42)> } }; G.parse('')

[20:19] <p6eval> nom ce5cca: OUTPUT«Too many positional parameters passed; got 2 but expected 1␤  in regex x at /tmp/rY6d3MZgc7:1␤  in regex TOP at /tmp/rY6d3MZgc7:1␤  in method parse at src/gen/CORE.setting:7642␤  in block <anon> at /tmp/rY6d3MZgc7:1␤  in <anon> at /tmp/rY6d3MZgc7:1␤»

[20:19] <jnthn> Hm, needs doing there too

[20:19] *** birdwindupbird joined
[20:20] <moritz> I thought it worked in nom..

[20:20] *** icwiener left
[20:20] <moritz> nom: grammar G { method x(:$y) { say $y }; rule TOP { <x: y => 42> } }. G.parse('')

[20:20] <p6eval> nom ce5cca: OUTPUT«===SORRY!===␤Confused␤at /tmp/FdxsaWZFZf:1␤»

[20:23] <tadzik> argh, I'm on rakudo/master :/

[20:24] <moritz> didn't we mean to delete that branch?

[20:24] <tadzik> I don't think it matters when you do 'g co master'

[20:24] <tadzik> and then 'git pull' appears to be up-to-date

[20:24] * moritz deletes the branch

[20:24] <moritz> tadzik: then delete it locally too

[20:24] <moritz> git branch -D master

[20:25] <tadzik> I will

[20:25] <flussence> 'git remote prune origin' is a good idea to run once in a while too :)

[20:26] <jnthn> .u ௐ

[20:26] <phenny> U+0BD0 TAMIL OM (ௐ)

[20:27] <masak> I love seeing RT tickets get closed.

[20:28] <moritz> there's just a wee problem; I tend to write tests for those tickets that seem sensible and not too hard to test for

[20:29] <jnthn> .u ഇ

[20:29] <phenny> U+0D07 MALAYALAM LETTER I (ഇ)

[20:29] *** jaldhar left
[20:29] <moritz> so over time the 'testneeded' tag accumulates a bunch of weird tickets

[20:29] <moritz> which makes it not much fun to attack

[20:33] * skids tries to wrap head around S14:516

[20:34] <skids> All the example have role Foo[Bar] but then we have Array[Bar] whichis a class, not a role...

[20:36] *** nwc10 joined
[20:37] <TimToady> we can have punned roles as classes; in this case it would presumably override the default pun of Array[Any]

[20:39] <TimToady> though we still need to detangle the 'of' type from the default value

[20:39] <skids> Ah, so Array is supposed to be a punned class?

[20:39] <skids> erm, punned role as a class.

[20:39] <jnthn> Well, Foo[Bar] in Rakudo desugars to Foo.^parameterize(Bar) and the meta-class can do what it wants.

[20:40] <TimToady> the Array role would presumably be a slightly more concrete version of Positional

[20:40] <TimToady> where Array assumes mutability

[20:40] <jnthn> (So people can implement custom parametric types.)

[20:40] <jnthn> Note that this call may well happen at compile time, like many other MOP calls.

[20:41] <TimToady> sure, mostly just thinking about user-visible syntax, as is my wont

[20:41] <skids> so my Array[Recipe] %book; is really my Mu does Array[Recipe] %book;?

[20:41] <TimToady> no

[20:41] <moritz> std: $@*ARGS

[20:41] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Unsupported use of $@ variable as eval error; in Perl 6 please use $! at /tmp/t94nayz7EE line 1:␤------> $@⏏*ARGS␤Parse failed␤FAILED 00:01 107m␤»

[20:42] <jnthn> More like my %book := Hash[Array[Recipe]].new

[20:43] <moritz> jnthn: which method in World do i use to check if a symbol is in scope? find_symbol?

[20:44] <jnthn> moritz: What do you mean by "in scope"?

[20:44] <moritz> jnthn: declared, in visible in the lexical scope we're currently in

[20:44] <moritz> s/in/and/

[20:45] <jnthn> moritz: find_symbol works provided the thingy has a known compile time value. It throws if not. But some things aren't known at compile time at all

[20:45] <jnthn> moritz: already_declared may do it

[20:46] <jnthn> moritz: is_lexical is perhaps more what you're after

[20:46] <jnthn> Though it doesn't do multi-part names

[20:46] <moritz> that's OK

[20:47] <moritz> I just want to search for 'self'

[20:47] <jnthn> ah

[20:47] <moritz> std: $.foo

[20:47] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Variable $.foo used where no 'self' is available at /tmp/HWV9y7rZDq line 1:␤------> <BOL>⏏$.foo␤Check failed␤FAILED 00:01 108m␤»

[20:47] <jnthn> Is this for the $.foo bug?

[20:47] <moritz> yes

[20:48] <moritz> at least that's what I'm trying to fix :-)

[20:48] <jnthn> moritz: Yeah, that's best done by the way STD does it

[20:48] <jnthn> moritz: Which is by tracking invocant availability in some other way that also handles $!x being used in submethods

[20:48] <jnthn> er, $.x not being allowed there, I mean

[20:50] <moritz> I thought I'd just check if 'self' is declared, to catch those cases that generate a Null PMC Access

[20:50] *** nwc10 left
[20:51] <TimToady> the remaining 'as Int' should probably be replaced with --> Int(Any)

[20:52] <moritz> std: class A { has $.x; has $.y = $.x }

[20:52] <p6eval> std 48335fc: OUTPUT«===SORRY!===␤Virtual call $.x may not be used on partially constructed object at /tmp/euGptSo2wj line 1:␤------> class A { has $.x; has $.y = ⏏$.x }␤Check failed␤FAILED 00:01 110m␤»

[20:52] <moritz> SVG::Plot uses that syntax heavily :/

[20:53] <TimToady> if you really want to cheat, you can say $.y = self.x

[20:53] <jnthn> moritz: Was the virtualness intended or not?

[20:53] <TimToady> but we don't turn on virtualness of $.x by default there

[20:53] <TimToady> because it often is a think-o

[20:53] <moritz> jnthn: no. I just wanted dependent defaults

[20:53] <TimToady> $.y = $!x would work too

[20:53] <jnthn> std: class A { has $.x; has $.y = $!x }

[20:53] <masak> TimToady: +1 on --> Int(Any)

[20:53] <p6eval> std 48335fc: OUTPUT«ok 00:01 110m␤»

[20:54] <TimToady> funny thing about --> Int(Any) is it's opposite on what the type looks like from the outside, in a contravariant kind of way

[20:54] <moritz> jnthn: maybe I'll tackle $.foo in the STD way tomorrow

[20:55] <jnthn> moritz: +1

[20:55] <masak> TimToady: er. it's params that are contravariant, and return values are covariant :)

[20:55] <TimToady> sub foo (Int(Any) $x --> Int(Any)) {...} looks to the outside world like (Any --> Int)

[20:55] <masak> TimToady: I finally learned that by heart when re-learning Java generics not long ago.

[20:55] <TimToady> masak: yes, I always get those backwards :)

[20:55] <masak> :P

[20:56] <TimToady> and to the inside like (Int --> Any)

[20:56] <masak> TimToady: it's quite easy. it's not really params vs return values, it's consumers vs producers.

[20:56] <masak> consumers are naturally contravariant, producers naturally covariant.

[20:56] <TimToady> sure, and that's why it makes sense to use Int(Any) in both places

[20:56] <masak> er. perhaps I should call'em "sinks" and "sources". that seems to be the prevailing terminology.

[20:57] <TimToady> we don't have to tell people it will do what they expect :)

[20:57] <masak> :)

[20:57] <supernovus> Hmm, another interesting bug/feature. In DateTime::Math there are + and - subs. The one for adding seconds to a DateTime object works fine: multi infix:<+>(DateTime $dt, Numeric $x) is export { ... }  but the one for substracting seconds from a DateTime object never gets dispatched to: multi infix<->(DateTime $dt, Numeric $x) is export { ... }   instead a default infix:<->(\$a, \$b) { ... } from the CORE.setting gets called. 

[20:57] <masak> read-write containers can't be co-/contravariant, because they try to be both sources and sinks, and therefore end up being neither.

[20:58] <TimToady> they're invariant in their variance :)

[20:58] *** twirp left
[20:59] <supernovus> and no, the typo between infix and <-> is not in the actual code, that's just me mistyping things instead of copy/pasting.

[21:00] <skids> .oO(In soviet Perl6 the context of "sink" alters expectations of "kitchen")

[21:07] <TimToady> masak: though copy-in/copy-out params can coerce both ways; we don't really have those

[21:07] <TimToady> is copy is rw ?

[21:09] *** cognominal left
[21:10] *** cognominal joined
[21:10] <TimToady> probably not something we need to encourage right now, but might be useful for explicit boxing/unboxing coercions, I suppose

[21:12] *** birdwindupbird left
[21:13] <supernovus> guh, hand testing shows a bunch of the infix: stuf is not dispatching to the custom versions, but instead is going to the "default" versions in the setting. For instance >, >=, <=, !=, cmp, and <=> (as well as +) are going to the custom version, but <, == and of course - aren't.  This seems slightly odd to me.

[21:14] <benabik> Are they defined differently in the setting?

[21:19] *** timotimo joined
[21:19] *** PacoLinux joined
[21:20] <supernovus> benabik: not that I can tell. For instance, multi infix:<+>(\$a, \$b) { ... } in the setting gets overridden by multi infix:<+>(DateTime $dt, Numeric $x) is export { ... } in the library, but multi infix:<->(\$a, \$b) { ... } DOES NOT get overriden by multi infix:<->(DateTime $dt, Numeric $x) is export { ... } in the library. There seems to be no reason for the inconsistencies. 

[21:21] <PerlJam> supernovus: show the code?

[21:22] *** zby_home joined
[21:22] <supernovus> PerlJam: https://github.com/supernovus/temporal-utils   the library in question is lib/DateTime/Math.pm6 and the test in question is t/DateTime-math.t

[21:28] *** kaare_ left
[21:29] *** PacoLinux left
[21:38] <skids> If I'm getting things right, the only reason I can't seem to figure out how to write a class that is cool with being assigned integers is because that should try postcircumfix:<( )> -- as long as there's an "as Int" a.k.a. Int(Mu) there -- but A) postcircumfix:<( )>'s actually gets an unchewed capture and B) just NIY?  Or do I miss a trick?

[21:41] <supernovus> nom: class Foo {}; multi infix:<+>(Foo $a, Numeric $b) { say "Foo went up $b"; }; multi infix:<->(Foo $a, Numeric $b) { say "Foo went down $b"; }; my $a = Foo.new; $a + 1; $a - 1;

[21:41] <p6eval> nom ce5cca: OUTPUT«Foo went up 1␤No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu:U \$v, Mu %_!)␤␤  in method Numeric at src/gen/CORE.setting:649␤  in sub infix:<-> at src/gen/CORE.setting:2233␤  in block <anon> at /tmp/MJakwXcjJO:1␤  in <anon>…

[21:42] <skids> Heh, well I suppose that one way around it :-)

[21:47] <PerlJam> nom: class Foo {}; class Bar {};  multi infix:<+>(Foo $a, Bar $b) { say "up" }; multi infix:<->(Foo $a, Bar $b) { say "down" }; my $a = Foo.new; my $b = Bar.new;  $a + $b; $a - $b;

[21:47] <p6eval> nom ce5cca: OUTPUT«up␤No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu:U \$v, Mu %_!)␤␤  in method Numeric at src/gen/CORE.setting:649␤  in sub infix:<-> at src/gen/CORE.setting:2233␤  in block <anon> at /tmp/TmAPl2na81:1␤  in <anon> at /tmp/Tm…

[21:48] *** BlueMatt joined
[21:48] <supernovus> PerlJam: Yeah, it seems -, == and < are the operators that don't seem to be overridable at the moment. All the rest work fine. Beats me. :p

[21:48] <benabik> nom: class Foo {}; multi infix:<->(Foo $a, Numeric $b) { say "down" }; multi infix:<+>(Foo $a, Numeric $b) { say "up" }; my $a = Foo.new; $a - 1; $a +1

[21:48] <p6eval> nom ce5cca: OUTPUT«No applicable candidates found to dispatch to for 'Numeric'. Available candidates are:␤:(Mu:U \$v, Mu %_!)␤␤  in method Numeric at src/gen/CORE.setting:649␤  in sub infix:<-> at src/gen/CORE.setting:2233␤  in block <anon> at /tmp/BWzKASfJsI:1␤  in <anon> at /tmp/BWzKA…

[21:48] <benabik> Not order dependent.  :-)

[21:49] *** BlueMatt left
[21:51] <PerlJam> mine showed that it's trying to turn something Numeric though.  (there was no Numeric in my code, just the setting)

[21:52] <supernovus> Yeah, it's getting dispatched to the infix:<->(\$a, \$b) { $a.Numeric - $b.Numeric } version from the setting rather than the custom version.

[21:53] *** imarcusthis joined
[21:56] *** imarcusthis left
[21:57] *** skids left
[21:59] *** imarcusthis joined
[22:02] <spine> nom: (1=>1).map({ .key => 1}).say;

[22:02] <p6eval> nom ce5cca: OUTPUT«Method 'key' not found for invocant of class 'Any'␤  in block <anon> at /tmp/QxKemmos8k:1␤  in <anon> at /tmp/QxKemmos8k:1␤»

[22:02] <spine> nom: (1=>1).map({ ; .key => 1}).say;

[22:02] <p6eval> nom ce5cca: OUTPUT«1    1␤»

[22:02] <spine> I don't get it why those produce different output...

[22:02] *** cooper left
[22:02] *** cooper joined
[22:03] <supernovus> Well, I marked DateTime::Utils as working in nom, and noted the exception for DateTime::Math, which is broken until we can figure out the issue with certain infix operators not being overridable outside the setting.

[22:09] *** mj41 joined
[22:25] *** cj joined
[22:35] *** ksi left
[22:39] *** bbkr1 joined
[22:43] *** zby_home left
[22:48] *** vlixes joined
[23:12] *** kmwallio left
[23:37] *** mj41 left
[23:44] *** spine left
[23:44] *** PacoAir left
[23:47] *** whiteknight joined
[23:57] *** supernovus left
